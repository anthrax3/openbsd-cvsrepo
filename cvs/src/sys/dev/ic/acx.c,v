head	1.120;
access;
symbols
	OPENBSD_6_1:1.120.0.2
	OPENBSD_6_1_BASE:1.120
	OPENBSD_6_0:1.118.0.4
	OPENBSD_6_0_BASE:1.118
	OPENBSD_5_9:1.117.0.2
	OPENBSD_5_9_BASE:1.117
	OPENBSD_5_8:1.111.0.4
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.110.0.2
	OPENBSD_5_7_BASE:1.110
	OPENBSD_5_6:1.104.0.4
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.99.0.2
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.97.0.6
	OPENBSD_5_2_BASE:1.97
	OPENBSD_5_1_BASE:1.97
	OPENBSD_5_1:1.97.0.8
	OPENBSD_5_0:1.97.0.4
	OPENBSD_5_0_BASE:1.97
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.96.0.2
	OPENBSD_4_8_BASE:1.96
	OPENBSD_4_7:1.95.0.2
	OPENBSD_4_7_BASE:1.95
	OPENBSD_4_6:1.93.0.4
	OPENBSD_4_6_BASE:1.93
	OPENBSD_4_5:1.89.0.2
	OPENBSD_4_5_BASE:1.89
	OPENBSD_4_4:1.85.0.2
	OPENBSD_4_4_BASE:1.85
	OPENBSD_4_3:1.80.0.2
	OPENBSD_4_3_BASE:1.80
	OPENBSD_4_2:1.76.0.2
	OPENBSD_4_2_BASE:1.76
	OPENBSD_4_1:1.66.0.2
	OPENBSD_4_1_BASE:1.66
	OPENBSD_4_0:1.50.0.2
	OPENBSD_4_0_BASE:1.50;
locks; strict;
comment	@ * @;


1.120
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.119;
commitid	VyLWTsbepAOk7VQM;

1.119
date	2016.09.02.09.04.56;	author tom;	state Exp;
branches;
next	1.118;
commitid	8bBX2KCwacheynBF;

1.118
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.117;
commitid	QHiEhS9DHyE6oiIr;

1.117
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.116;
commitid	B0kwmVGiD5DVx4kv;

1.116
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.115;
commitid	5gdEnqVoJuTuwdTu;

1.115
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.114;
commitid	5DvsamK0GblTp8ww;

1.114
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.113;
commitid	YT6fyIEviv9qwbl6;

1.113
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.112;
commitid	p0v5tuE1Ch6fY0Nj;

1.112
date	2015.09.06.04.10.34;	author deraadt;	state Exp;
branches;
next	1.111;
commitid	2qNQzQCwO2JGWJFM;

1.111
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.110;
commitid	p4LJxGKbi0BU2cG6;

1.110
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.109;
commitid	Hly9lJn6CNMylcFu;

1.109
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.108;
commitid	yM2VFFhpDTeFQlve;

1.108
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.107;
commitid	LS2TNeCue5R9L67C;

1.107
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.106;
commitid	uzzBR7hz9ncd4O6G;

1.106
date	2014.09.08.07.21.40;	author kettenis;	state Exp;
branches;
next	1.105;
commitid	3YegmnAXr2Qe9e2H;

1.105
date	2014.09.06.05.41.35;	author jsg;	state Exp;
branches;
next	1.104;
commitid	TZ6gfz2Iz0CRv2Rz;

1.104
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.103;
commitid	TGHgrLxu6sxZoiFt;

1.103
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.102;
commitid	I19imNlAX05zJOED;

1.102
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.100;

1.100
date	2013.03.24.17.02.09;	author claudio;	state Exp;
branches;
next	1.99;

1.99
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.98;

1.98
date	2012.10.27.16.13.28;	author claudio;	state Exp;
branches;
next	1.97;

1.97
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.96;

1.96
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2009.09.13.14.42.52;	author krw;	state Exp;
branches;
next	1.94;

1.94
date	2009.07.28.11.39.52;	author blambert;	state Exp;
branches;
next	1.93;

1.93
date	2009.03.31.22.06.04;	author claudio;	state Exp;
branches;
next	1.92;

1.92
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.91;

1.91
date	2009.03.11.23.51.15;	author stsp;	state Exp;
branches;
next	1.90;

1.90
date	2009.03.09.11.25.22;	author stsp;	state Exp;
branches;
next	1.89;

1.89
date	2009.02.26.23.11.31;	author stsp;	state Exp;
branches;
next	1.88;

1.88
date	2008.11.23.12.11.27;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.22.21.40.36;	author brad;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.01.10.08.35;	author brad;	state Exp;
branches;
next	1.82;

1.82
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2008.03.13.23.07.28;	author brad;	state Exp;
branches;
next	1.80;

1.80
date	2007.11.26.09.28.33;	author martynas;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.14.11.36.52;	author mglocker;	state Exp;
branches;
next	1.78;

1.78
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2007.08.05.22.40.38;	author claudio;	state Exp;
branches;
next	1.75;

1.75
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2007.05.03.21.24.56;	author mglocker;	state Exp;
branches;
next	1.73;

1.73
date	2007.04.11.21.38.50;	author mglocker;	state Exp;
branches;
next	1.72;

1.72
date	2007.04.11.19.49.11;	author mglocker;	state Exp;
branches;
next	1.71;

1.71
date	2007.04.03.18.57.34;	author claudio;	state Exp;
branches;
next	1.70;

1.70
date	2007.03.29.12.27.59;	author claudio;	state Exp;
branches;
next	1.69;

1.69
date	2007.03.19.23.28.23;	author claudio;	state Exp;
branches;
next	1.68;

1.68
date	2007.03.16.11.06.39;	author claudio;	state Exp;
branches;
next	1.67;

1.67
date	2007.03.14.08.12.30;	author claudio;	state Exp;
branches;
next	1.66;

1.66
date	2007.03.01.10.55.14;	author claudio;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.28.09.26.26;	author claudio;	state Exp;
branches;
next	1.64;

1.64
date	2007.02.28.09.09.29;	author claudio;	state Exp;
branches;
next	1.63;

1.63
date	2007.02.23.22.17.05;	author claudio;	state Exp;
branches;
next	1.62;

1.62
date	2007.02.21.14.25.51;	author claudio;	state Exp;
branches;
next	1.61;

1.61
date	2007.02.20.22.06.46;	author claudio;	state Exp;
branches;
next	1.60;

1.60
date	2006.12.31.14.27.17;	author claudio;	state Exp;
branches;
next	1.59;

1.59
date	2006.12.30.22.43.01;	author claudio;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.17.21.45.48;	author claudio;	state Exp;
branches;
next	1.57;

1.57
date	2006.12.13.11.03.54;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2006.12.08.09.17.34;	author claudio;	state Exp;
branches;
next	1.55;

1.55
date	2006.11.26.17.20.33;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2006.11.09.23.15.54;	author claudio;	state Exp;
branches;
next	1.53;

1.53
date	2006.10.10.20.45.38;	author mbalmer;	state Exp;
branches;
next	1.52;

1.52
date	2006.10.03.17.37.31;	author claudio;	state Exp;
branches;
next	1.51;

1.51
date	2006.09.26.12.54.34;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.29.17.26.38;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.21.09.39.37;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.20.00.33.59;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2006.08.19.23.17.12;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2006.08.15.21.16.08;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.15.16.48.07;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.15.15.43.34;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.08.15.15.06.14;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2006.08.15.12.06.13;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2006.08.14.23.13.28;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.14.06.53.26;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.13.01.34.20;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.12.10.33.18;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.12.10.30.15;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.08.10.49.16;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.08.09.02.48;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.08.05.18.53;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.08.05.03.51;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.07.21.17.39;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.07.11.06.50;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.07.10.46.12;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.07.00.23.20;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.06.14.23.05;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.06.14.22.11;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2006.08.06.14.06.41;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.08.06.14.04.19;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2006.08.06.13.03.03;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2006.08.05.17.22.46;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.08.05.13.06.50;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2006.08.05.12.59.53;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2006.08.05.11.34.11;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.08.05.09.07.35;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.05.00.29.41;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.05.00.22.49;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2006.08.05.00.04.37;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2006.08.04.22.51.19;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.04.22.24.46;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.04.17.49.42;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.04.12.24.46;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2006.08.04.11.58.26;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2006.08.04.10.47.15;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.03.22.56.08;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.03.22.32.06;	author claudio;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.03.20.18.02;	author claudio;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.03.19.31.25;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.03.12.00.07;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.03.11.17.28;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.03.10.47.42;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.03.10.12.37;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.03.08.45.01;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.120
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: acx.c,v 1.119 2016/09/02 09:04:56 tom Exp $ */

/*
 * Copyright (c) 2006 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2006 The DragonFly Project.  All rights reserved.
 *
 * This code is derived from software contributed to The DragonFly Project
 * by Sepherosa Ziehau <sepherosa@@gmail.com>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name of The DragonFly Project nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE
 * COPYRIGHT HOLDERS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Copyright (c) 2003-2004 wlan.kewl.org Project
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *
 *    This product includes software developed by the wlan.kewl.org Project.
 *
 * 4. Neither the name of the wlan.kewl.org Project nor the names of its
 *    contributors may be used to endorse or promote products derived from
 *    this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * THE wlan.kewl.org Project BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/sockio.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/acxvar.h>
#include <dev/ic/acxreg.h>

#ifdef ACX_DEBUG
int acxdebug = 0;
#endif

int	 acx_attach(struct acx_softc *);
int	 acx_detach(void *);

int	 acx_init(struct ifnet *);
int	 acx_stop(struct acx_softc *);
void	 acx_init_info_reg(struct acx_softc *);
int	 acx_config(struct acx_softc *);
int	 acx_read_config(struct acx_softc *, struct acx_config *);
int	 acx_write_config(struct acx_softc *, struct acx_config *);
int	 acx_rx_config(struct acx_softc *);
int	 acx_set_crypt_keys(struct acx_softc *);
void	 acx_next_scan(void *);

void	 acx_start(struct ifnet *);
void	 acx_watchdog(struct ifnet *);

int	 acx_ioctl(struct ifnet *, u_long, caddr_t);

int	 acx_intr(void *);
void	 acx_disable_intr(struct acx_softc *);
void	 acx_enable_intr(struct acx_softc *);
void	 acx_txeof(struct acx_softc *);
void	 acx_txerr(struct acx_softc *, uint8_t);
void	 acx_rxeof(struct acx_softc *);

int	 acx_dma_alloc(struct acx_softc *);
void	 acx_dma_free(struct acx_softc *);
void	 acx_init_tx_ring(struct acx_softc *);
int	 acx_init_rx_ring(struct acx_softc *);
int	 acx_newbuf(struct acx_softc *, struct acx_rxbuf *, int);
int	 acx_encap(struct acx_softc *, struct acx_txbuf *,
	     struct mbuf *, struct ieee80211_node *, int);

int	 acx_reset(struct acx_softc *);

int	 acx_set_null_tmplt(struct acx_softc *);
int	 acx_set_probe_req_tmplt(struct acx_softc *, const char *, int);
#ifndef IEEE80211_STA_ONLY
int	 acx_set_probe_resp_tmplt(struct acx_softc *, struct ieee80211_node *);
int	 acx_beacon_locate(struct mbuf *, u_int8_t);
int	 acx_set_beacon_tmplt(struct acx_softc *, struct ieee80211_node *);
#endif

int	 acx_read_eeprom(struct acx_softc *, uint32_t, uint8_t *);
int	 acx_read_phyreg(struct acx_softc *, uint32_t, uint8_t *);
const char *	acx_get_rf(int);
int	 acx_get_maxrssi(int);

int	 acx_load_firmware(struct acx_softc *, uint32_t,
	     const uint8_t *, int);
int	 acx_load_radio_firmware(struct acx_softc *, const char *);
int	 acx_load_base_firmware(struct acx_softc *, const char *);

struct ieee80211_node
	*acx_node_alloc(struct ieee80211com *);
int	 acx_newstate(struct ieee80211com *, enum ieee80211_state, int);

void	 acx_init_cmd_reg(struct acx_softc *);
int	 acx_join_bss(struct acx_softc *, uint8_t, struct ieee80211_node *);
int	 acx_set_channel(struct acx_softc *, uint8_t);
int	 acx_init_radio(struct acx_softc *, uint32_t, uint32_t);

void	 acx_iter_func(void *, struct ieee80211_node *);
void	 acx_amrr_timeout(void *);
void	 acx_newassoc(struct ieee80211com *, struct ieee80211_node *, int);
#ifndef IEEE80211_STA_ONLY
void	 acx_set_tim(struct ieee80211com *, int, int);
#endif

int		acx_beacon_intvl = 100;	/* 100 TU */

/*
 * Possible values for the second parameter of acx_join_bss()
 */
#define ACX_MODE_ADHOC	0
#define ACX_MODE_UNUSED	1
#define ACX_MODE_STA	2
#define ACX_MODE_AP	3

struct cfdriver acx_cd = {
	NULL, "acx", DV_IFNET
};

int
acx_attach(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i, error;

	/* Initialize channel scanning timer */
	timeout_set(&sc->sc_chanscan_timer, acx_next_scan, sc);

	/* Allocate busdma stuffs */
	error = acx_dma_alloc(sc);
	if (error) {
		printf("%s: attach failed, could not allocate DMA!\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	/* Reset Hardware */
	error = acx_reset(sc);
	if (error) {
		printf("%s: attach failed, could not reset device!\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	/* Disable interrupts before firmware is loaded */
	acx_disable_intr(sc);

	/* Get radio type and form factor */
#define EEINFO_RETRY_MAX	50
	for (i = 0; i < EEINFO_RETRY_MAX; ++i) {
		uint16_t ee_info;

		ee_info = CSR_READ_2(sc, ACXREG_EEPROM_INFO);
		if (ACX_EEINFO_HAS_RADIO_TYPE(ee_info)) {
			sc->sc_form_factor = ACX_EEINFO_FORM_FACTOR(ee_info);
			sc->sc_radio_type = ACX_EEINFO_RADIO_TYPE(ee_info);
			break;
		}
		DELAY(10000);
	}
	if (i == EEINFO_RETRY_MAX) {
		printf("%s: attach failed, could not get radio type!\n",
		    sc->sc_dev.dv_xname);
		return (ENXIO);
	}
#undef EEINFO_RETRY_MAX

#ifdef DUMP_EEPROM
	for (i = 0; i < 0x40; ++i) {
		uint8_t val;

		error = acx_read_eeprom(sc, i, &val);
		if (error)
			return (error);
		if (i % 10 == 0)
			printf("\n");
		printf("%02x ", val);
	}
	printf("\n");
#endif	/* DUMP_EEPROM */

	/* Get EEPROM version */
	error = acx_read_eeprom(sc, ACX_EE_VERSION_OFS, &sc->sc_eeprom_ver);
	if (error) {
		printf("%s: attach failed, could not get EEPROM version!\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	ifp->if_softc = sc;
	ifp->if_ioctl = acx_ioctl;
	ifp->if_start = acx_start;
	ifp->if_watchdog = acx_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	/* Set channels */
	for (i = 1; i <= 14; ++i) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags = sc->chip_chan_flags;
	}

	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;

	/*
	 * NOTE: Don't overwrite ic_caps set by chip specific code
	 */
	ic->ic_caps =
	    IEEE80211_C_WEP |			/* WEP */
	    IEEE80211_C_MONITOR |		/* Monitor mode */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |			/* IBSS mode */
	    IEEE80211_C_HOSTAP |		/* Access Point */
	    IEEE80211_C_APPMGT |		/* AP Power Mgmt */
#endif
	    IEEE80211_C_SHPREAMBLE;		/* Short preamble */

	/* Get station id */
	for (i = 0; i < IEEE80211_ADDR_LEN; ++i) {
		error = acx_read_eeprom(sc, sc->chip_ee_eaddr_ofs - i,
		    &ic->ic_myaddr[i]);
		if (error) {
			printf("%s: attach failed, could not get station id\n",
			    sc->sc_dev.dv_xname);
			return error;
		}
	}

	printf("%s: %s, radio %s (0x%02x), EEPROM ver %u, address %s\n",
	    sc->sc_dev.dv_xname,
	    (sc->sc_flags & ACX_FLAG_ACX111) ? "ACX111" : "ACX100",
	    acx_get_rf(sc->sc_radio_type), sc->sc_radio_type,
	    sc->sc_eeprom_ver, ether_sprintf(ic->ic_myaddr));

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* Override node alloc */
	ic->ic_node_alloc = acx_node_alloc;
	ic->ic_newassoc = acx_newassoc;

#ifndef IEEE80211_STA_ONLY
	/* Override set TIM */
	ic->ic_set_tim = acx_set_tim;
#endif

	/* Override newstate */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = acx_newstate;

	/* Set maximal rssi */
	ic->ic_max_rssi = acx_get_maxrssi(sc->sc_radio_type);

	ieee80211_media_init(ifp, ieee80211_media_change,
	    ieee80211_media_status);

	/* AMRR rate control */
	sc->amrr.amrr_min_success_threshold = 1;
	sc->amrr.amrr_max_success_threshold = 15;
	timeout_set(&sc->amrr_ch, acx_amrr_timeout, sc);

	sc->sc_long_retry_limit = 4;
	sc->sc_short_retry_limit = 7;
	sc->sc_msdu_lifetime = 4096;

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(ACX_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(ACX_TX_RADIOTAP_PRESENT);
#endif

	return (0);
}

int
acx_detach(void *xsc)
{
	struct acx_softc *sc = xsc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	acx_stop(sc);
	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	acx_dma_free(sc);

	return (0);
}

int
acx_init(struct ifnet *ifp)
{
	struct acx_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	char fname[] = "tiacx111c16";
	int error, combined = 0;

	error = acx_stop(sc);
	if (error)
		return (EIO);

	/* enable card if possible */
	if (sc->sc_enable != NULL) {
		error = (*sc->sc_enable)(sc);
		if (error)
			return (EIO);
	}

	acx_init_tx_ring(sc);

	error = acx_init_rx_ring(sc);
	if (error) {
		printf("%s: can't initialize RX ring\n",
		    sc->sc_dev.dv_xname);
		goto back;
	}

	if (sc->sc_flags & ACX_FLAG_ACX111) {
		snprintf(fname, sizeof(fname), "tiacx111c%02X",
		    sc->sc_radio_type);
		error = acx_load_base_firmware(sc, fname);

		if (!error)
			combined = 1;
	}

	if (!combined) {
		snprintf(fname, sizeof(fname), "tiacx%s",
		    (sc->sc_flags & ACX_FLAG_ACX111) ? "111" : "100");
		error = acx_load_base_firmware(sc, fname);
	}

	if (error)
		goto back;

	/*
	 * Initialize command and information registers
	 * NOTE: This should be done after base firmware is loaded
	 */
	acx_init_cmd_reg(sc);
	acx_init_info_reg(sc);

	sc->sc_flags |= ACX_FLAG_FW_LOADED;

	if (!combined) {
		snprintf(fname, sizeof(fname), "tiacx%sr%02X",
		    (sc->sc_flags & ACX_FLAG_ACX111) ? "111" : "100",
		    sc->sc_radio_type);
		error = acx_load_radio_firmware(sc, fname);

		if (error)
			goto back;
	}

	error = sc->chip_init(sc);
	if (error)
		goto back;

	/* Get and set device various configuration */
	error = acx_config(sc);
	if (error)
		goto back;

	/* Setup crypto stuffs */
	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
		error = acx_set_crypt_keys(sc);
		if (error)
			goto back;
	}

	/* Turn on power led */
	CSR_CLRB_2(sc, ACXREG_GPIO_OUT, sc->chip_gpio_pled);

	acx_enable_intr(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		/* start background scanning */
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	else
		/* in monitor mode change directly into run state */
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	return (0);
back:
	acx_stop(sc);
	return (error);
}

void
acx_init_info_reg(struct acx_softc *sc)
{
	sc->sc_info = CSR_READ_4(sc, ACXREG_INFO_REG_OFFSET);
	sc->sc_info_param = sc->sc_info + ACX_INFO_REG_SIZE;
}

int
acx_set_crypt_keys(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_conf_wep_txkey wep_txkey;
	int i, error, got_wk = 0;

	for (i = 0; i < IEEE80211_WEP_NKID; ++i) {
		struct ieee80211_key *k = &ic->ic_nw_keys[i];

		if (k->k_len == 0)
			continue;

		if (sc->chip_hw_crypt) {
			error = sc->chip_set_wepkey(sc, k, i);
			if (error)
				return (error);
			got_wk = 1;
		}
	}

	if (!got_wk)
		return (0);

	/* Set current WEP key index */
	wep_txkey.wep_txkey = ic->ic_wep_txkey;
	if (acx_set_conf(sc, ACX_CONF_WEP_TXKEY, &wep_txkey,
	    sizeof(wep_txkey)) != 0) {
		printf("%s: set WEP txkey failed\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	return (0);
}

void
acx_next_scan(void *arg)
{
	struct acx_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
}

int
acx_stop(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct acx_buf_data *bd = &sc->sc_buf_data;
	struct acx_ring_data *rd = &sc->sc_ring_data;
	int i, error;

	sc->sc_firmware_ver = 0;
	sc->sc_hardware_id = 0;

	/* Reset hardware */
	error = acx_reset(sc);
	if (error)
		return (error);

	/* Firmware no longer functions after hardware reset */
	sc->sc_flags &= ~ACX_FLAG_FW_LOADED;

	acx_disable_intr(sc);

	/* Stop backgroud scanning */
	timeout_del(&sc->sc_chanscan_timer);

	/* Turn off power led */
	CSR_SETB_2(sc, ACXREG_GPIO_OUT, sc->chip_gpio_pled);

	/* Free TX mbuf */
	for (i = 0; i < ACX_TX_DESC_CNT; ++i) {
		struct acx_txbuf *buf;
		struct ieee80211_node *ni;

		buf = &bd->tx_buf[i];

		if (buf->tb_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, buf->tb_mbuf_dmamap);
			m_freem(buf->tb_mbuf);
			buf->tb_mbuf = NULL;
		}

		ni = (struct ieee80211_node *)buf->tb_node;
		if (ni != NULL)
			ieee80211_release_node(ic, ni);
		buf->tb_node = NULL;
	}

	/* Clear TX host descriptors */
	bzero(rd->tx_ring, ACX_TX_RING_SIZE);

	/* Free RX mbuf */
	for (i = 0; i < ACX_RX_DESC_CNT; ++i) {
		if (bd->rx_buf[i].rb_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat,
			    bd->rx_buf[i].rb_mbuf_dmamap);
			m_freem(bd->rx_buf[i].rb_mbuf);
			bd->rx_buf[i].rb_mbuf = NULL;
		}
	}

	/* Clear RX host descriptors */
	bzero(rd->rx_ring, ACX_RX_RING_SIZE);

	sc->sc_txtimer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);

	/* disable card if possible */
	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);

	return (0);
}

int
acx_config(struct acx_softc *sc)
{
	struct acx_config conf;
	int error;

	error = acx_read_config(sc, &conf);
	if (error)
		return (error);

	error = acx_write_config(sc, &conf);
	if (error)
		return (error);

	error = acx_rx_config(sc);
	if (error)
		return (error);

	if (acx_set_probe_req_tmplt(sc, "", 0) != 0) {
		printf("%s: can't set probe req template "
		    "(empty ssid)\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	/* XXX for PM?? */
	if (acx_set_null_tmplt(sc) != 0) {
		printf("%s: can't set null data template\n",
		    sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	return (0);
}

int
acx_read_config(struct acx_softc *sc, struct acx_config *conf)
{
	struct acx_conf_regdom reg_dom;
	struct acx_conf_antenna ant;
	struct acx_conf_fwrev fw_rev;
	uint32_t fw_rev_no;
	uint8_t sen;
	int error;

	/* Get region domain */
	if (acx_get_conf(sc, ACX_CONF_REGDOM, &reg_dom, sizeof(reg_dom)) != 0) {
		printf("%s: can't get region domain\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}
	conf->regdom = reg_dom.regdom;
	DPRINTF(("%s: regdom %02x\n", sc->sc_dev.dv_xname, reg_dom.regdom));

	/* Get antenna */
	if (acx_get_conf(sc, ACX_CONF_ANTENNA, &ant, sizeof(ant)) != 0) {
		printf("%s: can't get antenna\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}
	conf->antenna = ant.antenna;
	DPRINTF(("%s: antenna %02x\n", sc->sc_dev.dv_xname, ant.antenna));

	/* Get sensitivity XXX not used */
	if (sc->sc_radio_type == ACX_RADIO_TYPE_MAXIM ||
	    sc->sc_radio_type == ACX_RADIO_TYPE_RFMD ||
	    sc->sc_radio_type == ACX_RADIO_TYPE_RALINK) {
		error = acx_read_phyreg(sc, ACXRV_PHYREG_SENSITIVITY, &sen);
		if (error) {
			printf("%s: can't get sensitivity\n",
			    sc->sc_dev.dv_xname);
			return (error);
		}
	} else
		sen = 0;
	DPRINTF(("%s: sensitivity %02x\n", sc->sc_dev.dv_xname, sen));

	/* Get firmware revision */
	if (acx_get_conf(sc, ACX_CONF_FWREV, &fw_rev, sizeof(fw_rev)) != 0) {
		printf("%s: can't get firmware revision\n",
		    sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	if (strncmp(fw_rev.fw_rev, "Rev ", 4) != 0) {
		printf("%s: strange revision string -- %s\n",
		    sc->sc_dev.dv_xname, fw_rev.fw_rev);
		fw_rev_no = 0x01090407;
	} else {
		/*
		 *  01234
		 * "Rev xx.xx.xx.xx"
		 *      ^ Start from here
		 */
		fw_rev_no  = fw_rev.fw_rev[0] << 24;
		fw_rev_no |= fw_rev.fw_rev[1] << 16;
		fw_rev_no |= fw_rev.fw_rev[2] <<  8;
		fw_rev_no |= fw_rev.fw_rev[3];
	}
	sc->sc_firmware_ver = fw_rev_no;
	sc->sc_hardware_id = letoh32(fw_rev.hw_id);
	DPRINTF(("%s: fw rev %08x, hw id %08x\n",
	    sc->sc_dev.dv_xname, sc->sc_firmware_ver, sc->sc_hardware_id));

	if (sc->chip_read_config != NULL) {
		error = sc->chip_read_config(sc, conf);
		if (error)
			return (error);
	}

	return (0);
}

int
acx_write_config(struct acx_softc *sc, struct acx_config *conf)
{
	struct acx_conf_nretry_short sretry;
	struct acx_conf_nretry_long lretry;
	struct acx_conf_msdu_lifetime msdu_lifetime;
	struct acx_conf_rate_fallback rate_fb;
	struct acx_conf_antenna ant;
	struct acx_conf_regdom reg_dom;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int error;

	/* Set number of long/short retry */
	sretry.nretry = sc->sc_short_retry_limit;
	if (acx_set_conf(sc, ACX_CONF_NRETRY_SHORT, &sretry,
	    sizeof(sretry)) != 0) {
		printf("%s: can't set short retry limit\n", ifp->if_xname);
		return (ENXIO);
	}

	lretry.nretry = sc->sc_long_retry_limit;
	if (acx_set_conf(sc, ACX_CONF_NRETRY_LONG, &lretry,
	    sizeof(lretry)) != 0) {
		printf("%s: can't set long retry limit\n", ifp->if_xname);
		return (ENXIO);
	}

	/* Set MSDU lifetime */
	msdu_lifetime.lifetime = htole32(sc->sc_msdu_lifetime);
	if (acx_set_conf(sc, ACX_CONF_MSDU_LIFETIME, &msdu_lifetime,
	    sizeof(msdu_lifetime)) != 0) {
		printf("%s: can't set MSDU lifetime\n", ifp->if_xname);
		return (ENXIO);
	}

	/* Enable rate fallback */
	rate_fb.ratefb_enable = 1;
	if (acx_set_conf(sc, ACX_CONF_RATE_FALLBACK, &rate_fb,
	    sizeof(rate_fb)) != 0) {
		printf("%s: can't enable rate fallback\n", ifp->if_xname);
		return (ENXIO);
	}

	/* Set antenna */
	ant.antenna = conf->antenna;
	if (acx_set_conf(sc, ACX_CONF_ANTENNA, &ant, sizeof(ant)) != 0) {
		printf("%s: can't set antenna\n", ifp->if_xname);
		return (ENXIO);
	}

	/* Set region domain */
	reg_dom.regdom = conf->regdom;
	if (acx_set_conf(sc, ACX_CONF_REGDOM, &reg_dom, sizeof(reg_dom)) != 0) {
		printf("%s: can't set region domain\n", ifp->if_xname);
		return (ENXIO);
	}

	if (sc->chip_write_config != NULL) {
		error = sc->chip_write_config(sc, conf);
		if (error)
			return (error);
	}

	return (0);
}

int
acx_rx_config(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_conf_rxopt rx_opt;

	/* tell the RX receiver what frames we want to have */
	rx_opt.opt1 = htole16(RXOPT1_INCL_RXBUF_HDR);
	rx_opt.opt2 = htole16(
	    RXOPT2_RECV_ASSOC_REQ |
	    RXOPT2_RECV_AUTH |
	    RXOPT2_RECV_BEACON |
	    RXOPT2_RECV_CF |
	    RXOPT2_RECV_CTRL |
	    RXOPT2_RECV_DATA |
	    RXOPT2_RECV_MGMT |
	    RXOPT2_RECV_PROBE_REQ |
	    RXOPT2_RECV_PROBE_RESP |
	    RXOPT2_RECV_OTHER);

	/* in monitor mode go promiscuous */
	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		rx_opt.opt1 |= RXOPT1_PROMISC;
		rx_opt.opt2 |= RXOPT2_RECV_BROKEN | RXOPT2_RECV_ACK;
	} else
		rx_opt.opt1 |= RXOPT1_FILT_FDEST;

	/* finally set the RX options */
	if (acx_set_conf(sc, ACX_CONF_RXOPT, &rx_opt, sizeof(rx_opt)) != 0) {
		printf("%s: can not set RX options!\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	return (0);
}

int
acx_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct acx_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;
	uint8_t chan;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				error = acx_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				error = acx_stop(sc);
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		/* allow fast channel switching in monitor mode */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING)) {
				ic->ic_bss->ni_chan = ic->ic_ibss_chan;
				chan = ieee80211_chan2ieee(ic,
				    ic->ic_bss->ni_chan);
				(void)acx_set_channel(sc, chan);
			}
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING | IFF_UP)) ==
		    (IFF_RUNNING | IFF_UP))
			error = acx_init(ifp);
		else
			error = 0;
	}

	splx(s);

	return (error);
}

void
acx_start(struct ifnet *ifp)
{
	struct acx_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_buf_data *bd = &sc->sc_buf_data;
	struct acx_txbuf *buf;
	int trans, idx;

	if ((sc->sc_flags & ACX_FLAG_FW_LOADED) == 0 ||
	    (ifp->if_flags & IFF_RUNNING) == 0 ||
	    ifq_is_oactive(&ifp->if_snd))
		return;

	/*
	 * NOTE:
	 * We can't start from a random position that TX descriptor
	 * is free, since hardware will be confused by that.
	 * We have to follow the order of the TX ring.
	 */
	idx = bd->tx_free_start;
	trans = 0;
	for (buf = &bd->tx_buf[idx]; buf->tb_mbuf == NULL;
	     buf = &bd->tx_buf[idx]) {
		struct ieee80211_frame *wh;
		struct ieee80211_node *ni = NULL;
		struct mbuf *m;
		int rate;

		m = mq_dequeue(&ic->ic_mgtq);
		/* first dequeue management frames */
		if (m != NULL) {
			ni = m->m_pkthdr.ph_cookie;

			/*
			 * probe response mgmt frames are handled by the
			 * firmware already.  So, don't send them twice.
			 */
			wh = mtod(m, struct ieee80211_frame *);
			if ((wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
			    IEEE80211_FC0_SUBTYPE_PROBE_RESP) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
                                m_freem(m);
                                continue;
			}

			/*
			 * mgmt frames are sent at the lowest available
			 * bit-rate.
			 */
			rate = ni->ni_rates.rs_rates[0];
			rate &= IEEE80211_RATE_VAL;
		} else {
			struct ether_header *eh;

			/* then dequeue packets on the powersave queue */
			m = mq_dequeue(&ic->ic_pwrsaveq);
			if (m != NULL) {
				ni = m->m_pkthdr.ph_cookie;
				goto encapped;
			} else {
				IFQ_DEQUEUE(&ifp->if_snd, m);
				if (m == NULL)
					break;
			}
			if (ic->ic_state != IEEE80211_S_RUN) {
				DPRINTF(("%s: data packet dropped due to "
				    "not RUN.  Current state %d\n",
				    ifp->if_xname, ic->ic_state));
				m_freem(m);
				break;
			}

			if (m->m_len < sizeof(struct ether_header)) {
				m = m_pullup(m, sizeof(struct ether_header));
				if (m == NULL) {
					ifp->if_oerrors++;
					continue;
				}
			}
			eh = mtod(m, struct ether_header *);

			/* TODO power save */

#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

			if ((m = ieee80211_encap(ifp, m, &ni)) == NULL) {
				ifp->if_oerrors++;
				continue;
			}
encapped:
			if (ic->ic_fixed_rate != -1) {
				rate = ic->ic_sup_rates[ic->ic_curmode].
				    rs_rates[ic->ic_fixed_rate];
			} else
				rate = ni->ni_rates.rs_rates[ni->ni_txrate];
			rate &= IEEE80211_RATE_VAL;
		} 

#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif

		wh = mtod(m, struct ieee80211_frame *);
		if ((wh->i_fc[1] & IEEE80211_FC1_WEP) && !sc->chip_hw_crypt) {
			struct ieee80211_key *k;

			k = ieee80211_get_txkey(ic, wh, ni);
			if ((m = ieee80211_encrypt(ic, m, k)) == NULL) {
				ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				continue;
			}
		}

#if NBPFILTER > 0
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct acx_tx_radiotap_hdr *tap = &sc->sc_txtap;

			tap->wt_flags = 0;
			tap->wt_rate = rate;
			tap->wt_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			tap->wt_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_txtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
		}
#endif

		if (acx_encap(sc, buf, m, ni, rate) != 0) {
			/*
			 * NOTE: `m' will be freed in acx_encap()
			 * if we reach here.
			 */
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			ifp->if_oerrors++;
			continue;
		}

		/*
		 * NOTE:
		 * 1) `m' should not be touched after acx_encap()
		 * 2) `node' will be used to do TX rate control during
		 *    acx_txeof(), so it is not freed here.  acx_txeof()
		 *    will free it for us
		 */
		trans++;
		bd->tx_used_count++;
		idx = (idx + 1) % ACX_TX_DESC_CNT;
	}
	bd->tx_free_start = idx;

	if (bd->tx_used_count == ACX_TX_DESC_CNT)
		ifq_set_oactive(&ifp->if_snd);

	if (trans && sc->sc_txtimer == 0)
		sc->sc_txtimer = 5;
	ifp->if_timer = 1;
}

void
acx_watchdog(struct ifnet *ifp)
{
	struct acx_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if ((ifp->if_flags & IFF_RUNNING) == 0)
		return;

	if (sc->sc_txtimer) {
		if (--sc->sc_txtimer == 0) {
			printf("%s: watchdog timeout\n", ifp->if_xname);
			acx_init(ifp);
			ifp->if_oerrors++;
			return;
		} else
			ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
acx_intr(void *arg)
{
	struct acx_softc *sc = arg;
	uint16_t intr_status;

	if ((sc->sc_flags & ACX_FLAG_FW_LOADED) == 0)
		return (0);

	intr_status = CSR_READ_2(sc, ACXREG_INTR_STATUS_CLR);
	if (intr_status == ACXRV_INTR_ALL) {
		/* not our interrupt */
		return (0);
	}

	/* Acknowledge all interrupts */
	CSR_WRITE_2(sc, ACXREG_INTR_ACK, intr_status);

	intr_status &= sc->chip_intr_enable;
	if (intr_status == 0) {
		/* not interrupts we care about */
		return (1);
	}

#ifndef IEEE80211_STA_ONLY
	if (intr_status & ACXRV_INTR_DTIM)
		ieee80211_notify_dtim(&sc->sc_ic);
#endif

	if (intr_status & ACXRV_INTR_TX_FINI)
		acx_txeof(sc);

	if (intr_status & ACXRV_INTR_RX_FINI)
		acx_rxeof(sc);

	return (1);
}

void
acx_disable_intr(struct acx_softc *sc)
{
	CSR_WRITE_2(sc, ACXREG_INTR_MASK, sc->chip_intr_disable);
	CSR_WRITE_2(sc, ACXREG_EVENT_MASK, 0);
}

void
acx_enable_intr(struct acx_softc *sc)
{
	/* Mask out interrupts that are not in the enable set */
	CSR_WRITE_2(sc, ACXREG_INTR_MASK, ~sc->chip_intr_enable);
	CSR_WRITE_2(sc, ACXREG_EVENT_MASK, ACXRV_EVENT_DISABLE);
}

void
acx_txeof(struct acx_softc *sc)
{
	struct acx_buf_data *bd;
	struct acx_txbuf *buf;
	struct ifnet *ifp;
	int idx;

	ifp = &sc->sc_ic.ic_if;

	bd = &sc->sc_buf_data;
	idx = bd->tx_used_start;
	for (buf = &bd->tx_buf[idx]; buf->tb_mbuf != NULL;
	     buf = &bd->tx_buf[idx]) {
		uint8_t ctrl, error;

		ctrl = FW_TXDESC_GETFIELD_1(sc, buf, f_tx_ctrl);
		if ((ctrl & (DESC_CTRL_HOSTOWN | DESC_CTRL_ACXDONE)) !=
		    (DESC_CTRL_HOSTOWN | DESC_CTRL_ACXDONE))
			break;

		bus_dmamap_unload(sc->sc_dmat, buf->tb_mbuf_dmamap);
		m_freem(buf->tb_mbuf);
		buf->tb_mbuf = NULL;

		error = FW_TXDESC_GETFIELD_1(sc, buf, f_tx_error);
		if (error) {
			acx_txerr(sc, error);
			ifp->if_oerrors++;
		}

		/* Update rate control statistics for the node */
		if (buf->tb_node != NULL) {
			struct ieee80211com *ic;
			struct ieee80211_node *ni;
			struct acx_node *wn;
			int ntries;

			ic = &sc->sc_ic;
			ni = (struct ieee80211_node *)buf->tb_node;
			wn = (struct acx_node *)ni;
			ntries = FW_TXDESC_GETFIELD_1(sc, buf, f_tx_rts_fail) +
			    FW_TXDESC_GETFIELD_1(sc, buf, f_tx_ack_fail);

			wn->amn.amn_txcnt++;
			if (ntries > 0) {
				DPRINTFN(2, ("%s: tx intr ntries %d\n",
				    sc->sc_dev.dv_xname, ntries));
				wn->amn.amn_retrycnt++;
			}

			ieee80211_release_node(ic, ni);
			buf->tb_node = NULL;
		}

		FW_TXDESC_SETFIELD_1(sc, buf, f_tx_ctrl, DESC_CTRL_HOSTOWN);

		bd->tx_used_count--;

		idx = (idx + 1) % ACX_TX_DESC_CNT;
	}
	bd->tx_used_start = idx;

	sc->sc_txtimer = bd->tx_used_count == 0 ? 0 : 5;

	if (bd->tx_used_count != ACX_TX_DESC_CNT) {
		ifq_clr_oactive(&ifp->if_snd);
		acx_start(ifp);
	}
}

void
acx_txerr(struct acx_softc *sc, uint8_t err)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct acx_stats *stats = &sc->sc_stats;

	if (err == DESC_ERR_EXCESSIVE_RETRY) {
		/*
		 * This a common error (see comment below),
		 * so print it using DPRINTF().
		 */
		DPRINTF(("%s: TX failed -- excessive retry\n",
		    sc->sc_dev.dv_xname));
	} else
		printf("%s: TX failed -- ", ifp->if_xname);

	/*
	 * Although `err' looks like bitmask, it never
	 * has multiple bits set.
	 */
	switch (err) {
#if 0
	case DESC_ERR_OTHER_FRAG:
		/* XXX what's this */
		printf("error in other fragment\n");
		stats->err_oth_frag++;
		break;
#endif
	case DESC_ERR_ABORT:
		printf("aborted\n");
		stats->err_abort++;
		break;
	case DESC_ERR_PARAM:
		printf("wrong parameters in descriptor\n");
		stats->err_param++;
		break;
	case DESC_ERR_NO_WEPKEY:
		printf("WEP key missing\n");
		stats->err_no_wepkey++;
		break;
	case DESC_ERR_MSDU_TIMEOUT:
		printf("MSDU life timeout\n");
		stats->err_msdu_timeout++;
		break;
	case DESC_ERR_EXCESSIVE_RETRY:
		/*
		 * Possible causes:
		 * 1) Distance is too long
		 * 2) Transmit failed (e.g. no MAC level ACK)
		 * 3) Chip overheated (this should be rare)
		 */
		stats->err_ex_retry++;
		break;
	case DESC_ERR_BUF_OVERFLOW:
		printf("buffer overflow\n");
		stats->err_buf_oflow++;
		break;
	case DESC_ERR_DMA:
		printf("DMA error\n");
		stats->err_dma++;
		break;
	default:
		printf("unknown error %d\n", err);
		stats->err_unkn++;
		break;
	}
}

void
acx_rxeof(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_ring_data *rd = &sc->sc_ring_data;
	struct acx_buf_data *bd = &sc->sc_buf_data;
	struct ifnet *ifp = &ic->ic_if;
	int idx, ready;

	bus_dmamap_sync(sc->sc_dmat, rd->rx_ring_dmamap, 0,
	    rd->rx_ring_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

	/*
	 * Locate first "ready" rx buffer,
	 * start from last stopped position.
	 */
	idx = bd->rx_scan_start;
	ready = 0;
	do {
		struct acx_rxbuf *buf;

		buf = &bd->rx_buf[idx];
		if ((buf->rb_desc->h_ctrl & htole16(DESC_CTRL_HOSTOWN)) &&
		    (buf->rb_desc->h_status & htole32(DESC_STATUS_FULL))) {
			ready = 1;
			break;
		}
		idx = (idx + 1) % ACX_RX_DESC_CNT;
	} while (idx != bd->rx_scan_start);

	if (!ready)
		return;

	/*
	 * NOTE: don't mess up `idx' here, it will
	 * be used in the following code.
	 */
	do {
		struct acx_rxbuf_hdr *head;
		struct acx_rxbuf *buf;
		struct mbuf *m;
		struct ieee80211_rxinfo rxi;
		uint32_t desc_status;
		uint16_t desc_ctrl;
		int len, error;

		buf = &bd->rx_buf[idx];

		desc_ctrl = letoh16(buf->rb_desc->h_ctrl);
		desc_status = letoh32(buf->rb_desc->h_status);
		if (!(desc_ctrl & DESC_CTRL_HOSTOWN) ||
		    !(desc_status & DESC_STATUS_FULL))
			break;

		bus_dmamap_sync(sc->sc_dmat, buf->rb_mbuf_dmamap, 0,
		    buf->rb_mbuf_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

		m = buf->rb_mbuf;

		error = acx_newbuf(sc, buf, 0);
		if (error) {
			ifp->if_ierrors++;
			goto next;
		}

		head = mtod(m, struct acx_rxbuf_hdr *);

		len = letoh16(head->rbh_len) & ACX_RXBUF_LEN_MASK;
		if (len >= sizeof(struct ieee80211_frame_min) &&
		    len < MCLBYTES) {
			struct ieee80211_frame *wh;
			struct ieee80211_node *ni;

			m_adj(m, sizeof(struct acx_rxbuf_hdr) +
			    sc->chip_rxbuf_exhdr);
			wh = mtod(m, struct ieee80211_frame *);

			rxi.rxi_flags = 0;
			if ((wh->i_fc[1] & IEEE80211_FC1_WEP) &&
			    sc->chip_hw_crypt) {
				/* Short circuit software WEP */
				wh->i_fc[1] &= ~IEEE80211_FC1_WEP;

				/* Do chip specific RX buffer processing */
				if (sc->chip_proc_wep_rxbuf != NULL) {
					sc->chip_proc_wep_rxbuf(sc, m, &len);
					wh = mtod(m, struct ieee80211_frame *);
				}
				rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
			}

			m->m_len = m->m_pkthdr.len = len;

#if NBPFILTER > 0
			if (sc->sc_drvbpf != NULL) {
				struct mbuf mb;
				struct acx_rx_radiotap_hdr *tap = &sc->sc_rxtap;

				tap->wr_flags = 0;
				tap->wr_chan_freq =
				    htole16(ic->ic_bss->ni_chan->ic_freq);
				tap->wr_chan_flags =
				    htole16(ic->ic_bss->ni_chan->ic_flags);
				tap->wr_rssi = head->rbh_level;
				tap->wr_max_rssi = ic->ic_max_rssi;

				mb.m_data = (caddr_t)tap;
				mb.m_len = sc->sc_rxtap_len;
				mb.m_next = m;
				mb.m_nextpkt = NULL;
				mb.m_type = 0;
				mb.m_flags = 0;
				bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
			}
#endif

			ni = ieee80211_find_rxnode(ic, wh);

			rxi.rxi_rssi = head->rbh_level;
			rxi.rxi_tstamp = letoh32(head->rbh_time);
			ieee80211_input(ifp, m, ni, &rxi);

			ieee80211_release_node(ic, ni);
		} else {
			m_freem(m);
			ifp->if_ierrors++;
		}

next:
		buf->rb_desc->h_ctrl = htole16(desc_ctrl & ~DESC_CTRL_HOSTOWN);
		buf->rb_desc->h_status = 0;
		bus_dmamap_sync(sc->sc_dmat, rd->rx_ring_dmamap, 0,
		    rd->rx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

		idx = (idx + 1) % ACX_RX_DESC_CNT;
	} while (idx != bd->rx_scan_start);

	/*
	 * Record the position so that next
	 * time we can start from it.
	 */
	bd->rx_scan_start = idx;
}

int
acx_reset(struct acx_softc *sc)
{
	uint16_t reg;

	/* Halt ECPU */
	CSR_SETB_2(sc, ACXREG_ECPU_CTRL, ACXRV_ECPU_HALT);

	/* Software reset */
	reg = CSR_READ_2(sc, ACXREG_SOFT_RESET);
	CSR_WRITE_2(sc, ACXREG_SOFT_RESET, reg | ACXRV_SOFT_RESET);
	DELAY(100);
	CSR_WRITE_2(sc, ACXREG_SOFT_RESET, reg);

	/* Initialize EEPROM */
	CSR_SETB_2(sc, ACXREG_EEPROM_INIT, ACXRV_EEPROM_INIT);
	DELAY(50000);

	/* Test whether ECPU is stopped */
	reg = CSR_READ_2(sc, ACXREG_ECPU_CTRL);
	if (!(reg & ACXRV_ECPU_HALT)) {
		printf("%s: can't halt ECPU\n", sc->sc_dev.dv_xname);
		return (ENXIO);
	}

	return (0);
}

int
acx_read_eeprom(struct acx_softc *sc, uint32_t offset, uint8_t *val)
{
	int i;

	CSR_WRITE_4(sc, ACXREG_EEPROM_CONF, 0);
	CSR_WRITE_4(sc, ACXREG_EEPROM_ADDR, offset);
	CSR_WRITE_4(sc, ACXREG_EEPROM_CTRL, ACXRV_EEPROM_READ);

#define EE_READ_RETRY_MAX	100
	for (i = 0; i < EE_READ_RETRY_MAX; ++i) {
		if (CSR_READ_2(sc, ACXREG_EEPROM_CTRL) == 0)
			break;
		DELAY(10000);
	}
	if (i == EE_READ_RETRY_MAX) {
		printf("%s: can't read EEPROM offset %x (timeout)\n",
		    sc->sc_dev.dv_xname, offset);
		return (ETIMEDOUT);
	}
#undef EE_READ_RETRY_MAX

	*val = CSR_READ_1(sc, ACXREG_EEPROM_DATA);

	return (0);
}

int
acx_read_phyreg(struct acx_softc *sc, uint32_t reg, uint8_t *val)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;

	CSR_WRITE_4(sc, ACXREG_PHY_ADDR, reg);
	CSR_WRITE_4(sc, ACXREG_PHY_CTRL, ACXRV_PHY_READ);

#define PHY_READ_RETRY_MAX	100
	for (i = 0; i < PHY_READ_RETRY_MAX; ++i) {
		if (CSR_READ_4(sc, ACXREG_PHY_CTRL) == 0)
			break;
		DELAY(10000);
	}
	if (i == PHY_READ_RETRY_MAX) {
		printf("%s: can't read phy reg %x (timeout)\n",
		    ifp->if_xname, reg);
		return (ETIMEDOUT);
	}
#undef PHY_READ_RETRY_MAX

	*val = CSR_READ_1(sc, ACXREG_PHY_DATA);

	return (0);
}

void
acx_write_phyreg(struct acx_softc *sc, uint32_t reg, uint8_t val)
{
	CSR_WRITE_4(sc, ACXREG_PHY_DATA, val);
	CSR_WRITE_4(sc, ACXREG_PHY_ADDR, reg);
	CSR_WRITE_4(sc, ACXREG_PHY_CTRL, ACXRV_PHY_WRITE);
}

int
acx_load_base_firmware(struct acx_softc *sc, const char *name)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i, error;
	uint8_t *ucode;
	size_t size;

	error = loadfirmware(name, &ucode, &size);

	if (error != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    ifp->if_xname, error, name);
		return (EIO);
	}

	/* Load base firmware */
	error = acx_load_firmware(sc, 0, ucode, size);

	free(ucode, M_DEVBUF, size);

	if (error) {
		printf("%s: can't load base firmware\n", ifp->if_xname);
		return error;
	}
	DPRINTF(("%s: base firmware loaded\n", sc->sc_dev.dv_xname));

	/* Start ECPU */
	CSR_WRITE_2(sc, ACXREG_ECPU_CTRL, ACXRV_ECPU_START);

	/* Wait for ECPU to be up */
	for (i = 0; i < 500; ++i) {
		uint16_t reg;

		reg = CSR_READ_2(sc, ACXREG_INTR_STATUS);
		if (reg & ACXRV_INTR_FCS_THRESH) {
			CSR_WRITE_2(sc, ACXREG_INTR_ACK, ACXRV_INTR_FCS_THRESH);
			return (0);
		}
		DELAY(10000);
	}

	printf("%s: can't initialize ECPU (timeout)\n", ifp->if_xname);

	return (ENXIO);
}

int
acx_load_radio_firmware(struct acx_softc *sc, const char *name)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct acx_conf_mmap mem_map;
	uint32_t radio_fw_ofs;
	int error;
	uint8_t *ucode;
	size_t size;

	error = loadfirmware(name, &ucode, &size);

	if (error != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    ifp->if_xname, error, name);
		return (EIO);
	}

	/*
	 * Get the position, where base firmware is loaded, so that
	 * radio firmware can be loaded after it.
	 */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0) {
		free(ucode, M_DEVBUF, size);
		return (ENXIO);
	}
	radio_fw_ofs = letoh32(mem_map.code_end);

	/* Put ECPU into sleeping state, before loading radio firmware */
	if (acx_exec_command(sc, ACXCMD_SLEEP, NULL, 0, NULL, 0) != 0) {
		free(ucode, M_DEVBUF, size);
		return (ENXIO);
	}

	/* Load radio firmware */
	error = acx_load_firmware(sc, radio_fw_ofs, ucode, size);

	free(ucode, M_DEVBUF, size);

	if (error) {
		printf("%s: can't load radio firmware\n", ifp->if_xname);
		return (ENXIO);
	}
	DPRINTF(("%s: radio firmware loaded\n", sc->sc_dev.dv_xname));

	/* Wake up sleeping ECPU, after radio firmware is loaded */
	if (acx_exec_command(sc, ACXCMD_WAKEUP, NULL, 0, NULL, 0) != 0)
		return (ENXIO);

	/* Initialize radio */
	if (acx_init_radio(sc, radio_fw_ofs, size) != 0)
		return (ENXIO);

	/* Verify radio firmware's loading position */
	if (acx_get_conf(sc, ACX_CONF_MMAP, &mem_map, sizeof(mem_map)) != 0)
		return (ENXIO);

	if (letoh32(mem_map.code_end) != radio_fw_ofs + size) {
		printf("%s: loaded radio firmware position mismatch\n",
		    ifp->if_xname);
		return (ENXIO);
	}

	DPRINTF(("%s: radio firmware initialized\n", sc->sc_dev.dv_xname));

	return (0);
}

int
acx_load_firmware(struct acx_softc *sc, uint32_t offset, const uint8_t *data,
    int data_len)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	const uint32_t *fw;
	u_int32_t csum = 0;
	int i, fw_len;

	for (i = 4; i < data_len; i++)
		csum += data[i];

	fw = (const uint32_t *)data;

	if (*fw != htole32(csum)) {
		printf("%s: firmware checksum 0x%x does not match 0x%x!\n",
		    ifp->if_xname, *fw, htole32(csum));
		return (ENXIO);
	}

	/* skip csum + length */
	data += 8;
	data_len -= 8;

	fw = (const uint32_t *)data;
	fw_len = data_len / sizeof(uint32_t);

	/*
	 * LOADFW_AUTO_INC only works with some older firmware:
	 * 1) acx100's firmware
	 * 2) acx111's firmware whose rev is 0x00010011
	 */

	/* Load firmware */
	CSR_WRITE_4(sc, ACXREG_FWMEM_START, ACXRV_FWMEM_START_OP);
#ifndef LOADFW_AUTO_INC
	CSR_WRITE_4(sc, ACXREG_FWMEM_CTRL, 0);
#else
	CSR_WRITE_4(sc, ACXREG_FWMEM_CTRL, ACXRV_FWMEM_ADDR_AUTOINC);
	CSR_WRITE_4(sc, ACXREG_FWMEM_ADDR, offset);
#endif

	for (i = 0; i < fw_len; ++i) {
#ifndef LOADFW_AUTO_INC
		CSR_WRITE_4(sc, ACXREG_FWMEM_ADDR, offset + (i * 4));
#endif
		CSR_WRITE_4(sc, ACXREG_FWMEM_DATA, betoh32(fw[i]));
	}

	/* Verify firmware */
	CSR_WRITE_4(sc, ACXREG_FWMEM_START, ACXRV_FWMEM_START_OP);
#ifndef LOADFW_AUTO_INC
	CSR_WRITE_4(sc, ACXREG_FWMEM_CTRL, 0);
#else
	CSR_WRITE_4(sc, ACXREG_FWMEM_CTRL, ACXRV_FWMEM_ADDR_AUTOINC);
	CSR_WRITE_4(sc, ACXREG_FWMEM_ADDR, offset);
#endif

	for (i = 0; i < fw_len; ++i) {
		uint32_t val;

#ifndef LOADFW_AUTO_INC
		CSR_WRITE_4(sc, ACXREG_FWMEM_ADDR, offset + (i * 4));
#endif
		val = CSR_READ_4(sc, ACXREG_FWMEM_DATA);
		if (betoh32(fw[i]) != val) {
			printf("%s: firmware mismatch fw %08x  loaded %08x\n",
			    ifp->if_xname, fw[i], val);
			return (ENXIO);
		}
	}

	return (0);
}

struct ieee80211_node *
acx_node_alloc(struct ieee80211com *ic)
{
	struct acx_node *wn;

	wn = malloc(sizeof(*wn), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (wn == NULL)
		return (NULL);

	return ((struct ieee80211_node *)wn);
}

int
acx_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct acx_softc *sc = ic->ic_if.if_softc;
	struct ifnet *ifp = &ic->ic_if;
	int error = 0;

	timeout_del(&sc->amrr_ch);

	switch (nstate) {
	case IEEE80211_S_INIT:
		break;
	case IEEE80211_S_SCAN: {
			uint8_t chan;

			chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
			if (acx_set_channel(sc, chan) != 0) {
				error = 1;
				goto back;
			}

			/* 200ms => 5 channels per second */
			timeout_add_msec(&sc->sc_chanscan_timer, 200);
		}
		break;
	case IEEE80211_S_AUTH:
		if (ic->ic_opmode == IEEE80211_M_STA) {
			struct ieee80211_node *ni;
#ifdef ACX_DEBUG
			int i;
#endif

			ni = ic->ic_bss;

			if (acx_join_bss(sc, ACX_MODE_STA, ni) != 0) {
				printf("%s: join BSS failed\n", ifp->if_xname);
				error = 1;
				goto back;
			}

			DPRINTF(("%s: join BSS\n", sc->sc_dev.dv_xname));
			if (ic->ic_state == IEEE80211_S_ASSOC) {
				DPRINTF(("%s: change from assoc to run\n",
				    sc->sc_dev.dv_xname));
				ic->ic_state = IEEE80211_S_RUN;
			}

#ifdef ACX_DEBUG
			printf("%s: AP rates: ", sc->sc_dev.dv_xname);
			for (i = 0; i < ni->ni_rates.rs_nrates; ++i)
				printf("%d ", ni->ni_rates.rs_rates[i]);
			ieee80211_print_essid(ni->ni_essid, ni->ni_esslen);
			printf(" %s\n", ether_sprintf(ni->ni_bssid));
#endif
		}
		break;
	case IEEE80211_S_RUN:
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_IBSS ||
		    ic->ic_opmode == IEEE80211_M_HOSTAP) {
			struct ieee80211_node *ni;
			uint8_t chan;

			ni = ic->ic_bss;
			chan = ieee80211_chan2ieee(ic, ni->ni_chan);

			error = 1;

			if (acx_set_channel(sc, chan) != 0)
				goto back;

			if (acx_set_beacon_tmplt(sc, ni) != 0) {
				printf("%s: set beacon template failed\n",
				    ifp->if_xname);
				goto back;
			}

			if (acx_set_probe_resp_tmplt(sc, ni) != 0) {
				printf("%s: set probe response template "
				    "failed\n", ifp->if_xname);
				goto back;
			}

			if (ic->ic_opmode == IEEE80211_M_IBSS) {
				if (acx_join_bss(sc, ACX_MODE_ADHOC, ni) != 0) {
					printf("%s: join IBSS failed\n",
					    ifp->if_xname);
					goto back;
				}
			} else {
				if (acx_join_bss(sc, ACX_MODE_AP, ni) != 0) {
					printf("%s: join HOSTAP failed\n",
					    ifp->if_xname);
					goto back;
				}
			}

			DPRINTF(("%s: join IBSS\n", sc->sc_dev.dv_xname));
			error = 0;
		}
#endif
		/* fake a join to init the tx rate */
		if (ic->ic_opmode == IEEE80211_M_STA)
			acx_newassoc(ic, ic->ic_bss, 1);

		/* start automatic rate control timer */
		if (ic->ic_fixed_rate == -1)
			timeout_add_msec(&sc->amrr_ch, 500);
		break;
	default:
		break;
	}

back:
	if (error) {
		/* XXX */
		nstate = IEEE80211_S_INIT;
		arg = -1;
	}

	return (sc->sc_newstate(ic, nstate, arg));
}

int
acx_init_tmplt_ordered(struct acx_softc *sc)
{
	union {
		struct acx_tmplt_beacon		beacon;
		struct acx_tmplt_null_data	null;
		struct acx_tmplt_probe_req	preq;
		struct acx_tmplt_probe_resp	presp;
		struct acx_tmplt_tim		tim;
	} data;

	bzero(&data, sizeof(data));
	/*
	 * NOTE:
	 * Order of templates initialization:
	 * 1) Probe request
	 * 2) NULL data
	 * 3) Beacon
	 * 4) TIM
	 * 5) Probe response
	 * Above order is critical to get a correct memory map.
	 */
	if (acx_set_tmplt(sc, ACXCMD_TMPLT_PROBE_REQ, &data.preq,
	    sizeof(data.preq)) != 0)
		return (1);

	if (acx_set_tmplt(sc, ACXCMD_TMPLT_NULL_DATA, &data.null,
	    sizeof(data.null)) != 0)
		return (1);

	if (acx_set_tmplt(sc, ACXCMD_TMPLT_BEACON, &data.beacon,
	    sizeof(data.beacon)) != 0)
		return (1);

	if (acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &data.tim,
	    sizeof(data.tim)) != 0)
		return (1);

	if (acx_set_tmplt(sc, ACXCMD_TMPLT_PROBE_RESP, &data.presp,
	    sizeof(data.presp)) != 0)
		return (1);

	return (0);
}

int
acx_dma_alloc(struct acx_softc *sc)
{
	struct acx_ring_data *rd = &sc->sc_ring_data;
	struct acx_buf_data *bd = &sc->sc_buf_data;
	int i, error, nsegs;

	/* Allocate DMA stuffs for RX descriptors  */
	error = bus_dmamap_create(sc->sc_dmat, ACX_RX_RING_SIZE, 1,
	    ACX_RX_RING_SIZE, 0, BUS_DMA_NOWAIT, &rd->rx_ring_dmamap);

	if (error) {
		printf("%s: can't create rx ring dma tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_alloc(sc->sc_dmat, ACX_RX_RING_SIZE, PAGE_SIZE,
	    0, &rd->rx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);

	if (error != 0) {
		printf("%s: can't allocate rx ring dma memory\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_map(sc->sc_dmat, &rd->rx_ring_seg, nsegs,
	    ACX_RX_RING_SIZE, (caddr_t *)&rd->rx_ring,
	    BUS_DMA_NOWAIT);

	if (error != 0) {
		printf("%s: can't map rx desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamap_load(sc->sc_dmat, rd->rx_ring_dmamap,
	    rd->rx_ring, ACX_RX_RING_SIZE, NULL, BUS_DMA_WAITOK);

	if (error) {
		printf("%s: can't get rx ring dma address\n",
		    sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->sc_dmat, &rd->rx_ring_seg, 1);
		return (error);
	}

	rd->rx_ring_paddr = rd->rx_ring_dmamap->dm_segs[0].ds_addr;

	/* Allocate DMA stuffs for TX descriptors */
	error = bus_dmamap_create(sc->sc_dmat, ACX_TX_RING_SIZE, 1,
	    ACX_TX_RING_SIZE, 0, BUS_DMA_NOWAIT, &rd->tx_ring_dmamap);

	if (error) {
		printf("%s: can't create tx ring dma tag\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_alloc(sc->sc_dmat, ACX_TX_RING_SIZE, PAGE_SIZE,
	    0, &rd->tx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);

	if (error) {
		printf("%s: can't allocate tx ring dma memory\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamem_map(sc->sc_dmat, &rd->tx_ring_seg, nsegs,
	    ACX_TX_RING_SIZE, (caddr_t *)&rd->tx_ring, BUS_DMA_NOWAIT);

	if (error != 0) {
		printf("%s: can't map tx desc DMA memory\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	error = bus_dmamap_load(sc->sc_dmat, rd->tx_ring_dmamap,
	    rd->tx_ring, ACX_TX_RING_SIZE, NULL, BUS_DMA_WAITOK);

	if (error) {
		printf("%s: can't get tx ring dma address\n",
		    sc->sc_dev.dv_xname);
		bus_dmamem_free(sc->sc_dmat, &rd->tx_ring_seg, 1);
		return (error);
	}

	rd->tx_ring_paddr = rd->tx_ring_dmamap->dm_segs[0].ds_addr;

	/* Create a spare RX DMA map */
	error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1, MCLBYTES,
	    0, 0, &bd->mbuf_tmp_dmamap);

	if (error) {
		printf("%s: can't create tmp mbuf dma map\n",
		    sc->sc_dev.dv_xname);
		return (error);
	}

	/* Create DMA map for RX mbufs */
	for (i = 0; i < ACX_RX_DESC_CNT; ++i) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &bd->rx_buf[i].rb_mbuf_dmamap);
		if (error) {
			printf("%s: can't create rx mbuf dma map (%d)\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
		bd->rx_buf[i].rb_desc = &rd->rx_ring[i];
	}

	/* Create DMA map for TX mbufs */
	for (i = 0; i < ACX_TX_DESC_CNT; ++i) {
		error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &bd->tx_buf[i].tb_mbuf_dmamap);
		if (error) {
			printf("%s: can't create tx mbuf dma map (%d)\n",
			    sc->sc_dev.dv_xname, i);
			return (error);
		}
		bd->tx_buf[i].tb_desc1 = &rd->tx_ring[i * 2];
		bd->tx_buf[i].tb_desc2 = &rd->tx_ring[(i * 2) + 1];
	}

	return (0);
}

void
acx_dma_free(struct acx_softc *sc)
{
	struct acx_ring_data *rd = &sc->sc_ring_data;
	struct acx_buf_data *bd = &sc->sc_buf_data;
	int i;

	if (rd->rx_ring != NULL) {
		bus_dmamap_unload(sc->sc_dmat, rd->rx_ring_dmamap);
		bus_dmamem_free(sc->sc_dmat, &rd->rx_ring_seg, 1);
	}

	if (rd->tx_ring != NULL) {
		bus_dmamap_unload(sc->sc_dmat, rd->tx_ring_dmamap);
		bus_dmamem_free(sc->sc_dmat, &rd->tx_ring_seg, 1);
	}

	for (i = 0; i < ACX_RX_DESC_CNT; ++i) {
		if (bd->rx_buf[i].rb_desc != NULL) {
			if (bd->rx_buf[i].rb_mbuf != NULL) {
				bus_dmamap_unload(sc->sc_dmat,
				    bd->rx_buf[i].rb_mbuf_dmamap);
				m_freem(bd->rx_buf[i].rb_mbuf);
			}
			bus_dmamap_destroy(sc->sc_dmat,
			    bd->rx_buf[i].rb_mbuf_dmamap);
		}
	}

	for (i = 0; i < ACX_TX_DESC_CNT; ++i) {
		if (bd->tx_buf[i].tb_desc1 != NULL) {
			if (bd->tx_buf[i].tb_mbuf != NULL) {
				bus_dmamap_unload(sc->sc_dmat,
				    bd->tx_buf[i].tb_mbuf_dmamap);
				m_freem(bd->tx_buf[i].tb_mbuf);
			}
			bus_dmamap_destroy(sc->sc_dmat,
			    bd->tx_buf[i].tb_mbuf_dmamap);
		}
	}

	if (bd->mbuf_tmp_dmamap != NULL)
		bus_dmamap_destroy(sc->sc_dmat, bd->mbuf_tmp_dmamap);
}

void
acx_init_tx_ring(struct acx_softc *sc)
{
	struct acx_ring_data *rd;
	struct acx_buf_data *bd;
	uint32_t paddr;
	int i;

	rd = &sc->sc_ring_data;
	paddr = rd->tx_ring_paddr;
	for (i = 0; i < (ACX_TX_DESC_CNT * 2) - 1; ++i) {
		paddr += sizeof(struct acx_host_desc);

		bzero(&rd->tx_ring[i], sizeof(struct acx_host_desc));
		rd->tx_ring[i].h_ctrl = htole16(DESC_CTRL_HOSTOWN);

		if (i == (ACX_TX_DESC_CNT * 2) - 1)
			rd->tx_ring[i].h_next_desc = htole32(rd->tx_ring_paddr);
		else
			rd->tx_ring[i].h_next_desc = htole32(paddr);
	}

	bus_dmamap_sync(sc->sc_dmat, rd->tx_ring_dmamap, 0,
	    rd->tx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	bd = &sc->sc_buf_data;
	bd->tx_free_start = 0;
	bd->tx_used_start = 0;
	bd->tx_used_count = 0;
}

int
acx_init_rx_ring(struct acx_softc *sc)
{
	struct acx_ring_data *rd;
	struct acx_buf_data *bd;
	uint32_t paddr;
	int i;

	bd = &sc->sc_buf_data;
	rd = &sc->sc_ring_data;
	paddr = rd->rx_ring_paddr;

	for (i = 0; i < ACX_RX_DESC_CNT; ++i) {
		int error;

		paddr += sizeof(struct acx_host_desc);
		bzero(&rd->rx_ring[i], sizeof(struct acx_host_desc));

		error = acx_newbuf(sc, &bd->rx_buf[i], 1);
		if (error)
			return (error);

		if (i == ACX_RX_DESC_CNT - 1)
			rd->rx_ring[i].h_next_desc = htole32(rd->rx_ring_paddr);
		else
			rd->rx_ring[i].h_next_desc = htole32(paddr);
	}

	bus_dmamap_sync(sc->sc_dmat, rd->rx_ring_dmamap, 0,
	    rd->rx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	bd->rx_scan_start = 0;

	return (0);
}

int
acx_newbuf(struct acx_softc *sc, struct acx_rxbuf *rb, int wait)
{
	struct acx_buf_data *bd;
	struct mbuf *m;
	bus_dmamap_t map;
	uint32_t paddr;
	int error;

	bd = &sc->sc_buf_data;

	MGETHDR(m, wait ? M_WAITOK : M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, wait ? M_WAITOK : M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (ENOBUFS);
	}

	m->m_len = m->m_pkthdr.len = MCLBYTES;

	error = bus_dmamap_load_mbuf(sc->sc_dmat, bd->mbuf_tmp_dmamap, m,
	    wait ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT);
	if (error) {
		m_freem(m);
		printf("%s: can't map rx mbuf %d\n",
		    sc->sc_dev.dv_xname, error);
		return (error);
	}

	/* Unload originally mapped mbuf */
	if (rb->rb_mbuf != NULL)
		bus_dmamap_unload(sc->sc_dmat, rb->rb_mbuf_dmamap);

	/* Swap this dmamap with tmp dmamap */
	map = rb->rb_mbuf_dmamap;
	rb->rb_mbuf_dmamap = bd->mbuf_tmp_dmamap;
	bd->mbuf_tmp_dmamap = map;
	paddr = rb->rb_mbuf_dmamap->dm_segs[0].ds_addr;

	rb->rb_mbuf = m;
	rb->rb_desc->h_data_paddr = htole32(paddr);
	rb->rb_desc->h_data_len = htole16(m->m_len);

	bus_dmamap_sync(sc->sc_dmat, rb->rb_mbuf_dmamap, 0,
	    rb->rb_mbuf_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	return (0);
}

int
acx_encap(struct acx_softc *sc, struct acx_txbuf *txbuf, struct mbuf *m,
    struct ieee80211_node *ni, int rate)
{
	struct acx_ring_data *rd = &sc->sc_ring_data;
	struct acx_node *node = (struct acx_node *)ni;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t paddr;
	uint8_t ctrl;
	int error;

	if (txbuf->tb_mbuf != NULL)
		panic("free TX buf has mbuf installed");

	if (m->m_pkthdr.len > MCLBYTES) {
		printf("%s: mbuf too big\n", ifp->if_xname);
		error = E2BIG;
		goto back;
	} else if (m->m_pkthdr.len < ACX_FRAME_HDRLEN) {
		printf("%s: mbuf too small\n", ifp->if_xname);
		error = EINVAL;
		goto back;
	}

	error = bus_dmamap_load_mbuf(sc->sc_dmat, txbuf->tb_mbuf_dmamap, m,
	    BUS_DMA_NOWAIT);

	if (error && error != EFBIG) {
		printf("%s: can't map tx mbuf1 %d\n",
		    sc->sc_dev.dv_xname, error);
		goto back;
	}

	if (error) {	/* error == EFBIG */
		/* too many fragments, linearize */
		if (m_defrag(m, M_DONTWAIT)) {
			printf("%s: can't defrag tx mbuf\n", ifp->if_xname);
			goto back;
		}
		error = bus_dmamap_load_mbuf(sc->sc_dmat,
		    txbuf->tb_mbuf_dmamap, m, BUS_DMA_NOWAIT);
		if (error) {
			printf("%s: can't map tx mbuf2 %d\n",
			    sc->sc_dev.dv_xname, error);
			goto back;
		}
	}

	error = 0;

	bus_dmamap_sync(sc->sc_dmat, txbuf->tb_mbuf_dmamap, 0,
	    txbuf->tb_mbuf_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	txbuf->tb_mbuf = m;
	txbuf->tb_node = node;
	txbuf->tb_rate = rate;

	/*
	 * TX buffers are accessed in following way:
	 * acx_fw_txdesc -> acx_host_desc -> buffer
	 *
	 * It is quite strange that acx also queries acx_host_desc next to
	 * the one we have assigned to acx_fw_txdesc even if first one's
	 * acx_host_desc.h_data_len == acx_fw_txdesc.f_tx_len
	 *
	 * So we allocate two acx_host_desc for one acx_fw_txdesc and
	 * assign the first acx_host_desc to acx_fw_txdesc
	 *
	 * For acx111
	 * host_desc1.h_data_len = buffer_len
	 * host_desc2.h_data_len = buffer_len - mac_header_len
	 *
	 * For acx100
	 * host_desc1.h_data_len = mac_header_len
	 * host_desc2.h_data_len = buffer_len - mac_header_len
	 */
	paddr = txbuf->tb_mbuf_dmamap->dm_segs[0].ds_addr;
	txbuf->tb_desc1->h_data_paddr = htole32(paddr);
	txbuf->tb_desc2->h_data_paddr = htole32(paddr + ACX_FRAME_HDRLEN);

	txbuf->tb_desc1->h_data_len =
	    htole16(sc->chip_txdesc1_len ? sc->chip_txdesc1_len
	    : m->m_pkthdr.len);
	txbuf->tb_desc2->h_data_len =
	    htole16(m->m_pkthdr.len - ACX_FRAME_HDRLEN);

	/*
	 * NOTE:
	 * We can't simply assign f_tx_ctrl, we will first read it back
	 * and change it bit by bit
	 */
	ctrl = FW_TXDESC_GETFIELD_1(sc, txbuf, f_tx_ctrl);
	ctrl |= sc->chip_fw_txdesc_ctrl; /* extra chip specific flags */
	ctrl &= ~(DESC_CTRL_HOSTOWN | DESC_CTRL_ACXDONE);

	FW_TXDESC_SETFIELD_2(sc, txbuf, f_tx_len, m->m_pkthdr.len);
	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_error, 0);
	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_ack_fail, 0);
	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_rts_fail, 0);
	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_rts_ok, 0);
	sc->chip_set_fw_txdesc_rate(sc, txbuf, rate);

	txbuf->tb_desc1->h_ctrl = 0;
	txbuf->tb_desc2->h_ctrl = 0;
	bus_dmamap_sync(sc->sc_dmat, rd->tx_ring_dmamap, 0,
	    rd->tx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);

	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_ctrl2, 0);
	FW_TXDESC_SETFIELD_1(sc, txbuf, f_tx_ctrl, ctrl);

	/* Tell chip to inform us about TX completion */
	CSR_WRITE_2(sc, ACXREG_INTR_TRIG, ACXRV_TRIG_TX_FINI);
back:
	if (error)
		m_freem(m);

	return (error);
}

int
acx_set_null_tmplt(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_tmplt_null_data n;
	struct ieee80211_frame *wh;

	bzero(&n, sizeof(n));

	wh = &n.data;
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA |
	    IEEE80211_FC0_SUBTYPE_NODATA;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);

	return (acx_set_tmplt(sc, ACXCMD_TMPLT_NULL_DATA, &n, sizeof(n)));
}

int
acx_set_probe_req_tmplt(struct acx_softc *sc, const char *ssid, int ssid_len)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_tmplt_probe_req req;
	struct ieee80211_frame *wh;
	struct ieee80211_rateset *rs;
	uint8_t *frm;
	int len;

	bzero(&req, sizeof(req));

	wh = &req.data.u_data.f;
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_REQ;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, etherbroadcastaddr);

	frm = req.data.u_data.var;
	frm = ieee80211_add_ssid(frm, ssid, ssid_len);
	rs = &ic->ic_sup_rates[sc->chip_phymode];
	frm = ieee80211_add_rates(frm, rs);
	if (rs->rs_nrates > IEEE80211_RATE_SIZE)
		frm = ieee80211_add_xrates(frm, rs);
	len = frm - req.data.u_data.var;

	return (acx_set_tmplt(sc, ACXCMD_TMPLT_PROBE_REQ, &req,
	    ACX_TMPLT_PROBE_REQ_SIZ(len)));
}

#ifndef IEEE80211_STA_ONLY
struct mbuf *ieee80211_get_probe_resp(struct ieee80211com *,
    struct ieee80211_node *);

int
acx_set_probe_resp_tmplt(struct acx_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_tmplt_probe_resp resp;
	struct ieee80211_frame *wh;
	struct mbuf *m;
	int len;

	bzero(&resp, sizeof(resp));

	m = ieee80211_get_probe_resp(ic, ni);
	if (m == NULL)
		return (1);
	M_PREPEND(m, sizeof(struct ieee80211_frame), M_DONTWAIT);
	if (m == NULL)
		return (1);
	wh = mtod(m, struct ieee80211_frame *);
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_RESP;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	*(u_int16_t *)&wh->i_dur[0] = 0;
	IEEE80211_ADDR_COPY(wh->i_addr1, ni->ni_macaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, ni->ni_bssid);
	*(u_int16_t *)wh->i_seq = 0;

	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&resp.data);
	len = m->m_pkthdr.len + sizeof(resp.size);
	m_freem(m); 

	return (acx_set_tmplt(sc, ACXCMD_TMPLT_PROBE_RESP, &resp, len));
}

int
acx_beacon_locate(struct mbuf *m, u_int8_t type)
{
	int off;
	u_int8_t *frm;
	/*
	 * beacon frame format
	 *	[8] time stamp
	 *	[2] beacon interval
	 *	[2] cabability information
	 *	from here on [tlv] values
	 */

	if (m->m_len != m->m_pkthdr.len)
		panic("beacon not in contiguous mbuf");

	off = sizeof(struct ieee80211_frame) + 8 + 2 + 2;
	frm = mtod(m, u_int8_t *);
	for (; off + 1 < m->m_len; off += frm[off + 1] + 2) {
		if (frm[off] == type)
			return (off);
	}
	return (-1);
}

int
acx_set_beacon_tmplt(struct acx_softc *sc, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct acx_tmplt_beacon beacon;
	struct acx_tmplt_tim tim;
	struct mbuf *m;
	int len, off;

	bzero(&beacon, sizeof(beacon));
	bzero(&tim, sizeof(tim));

	m = ieee80211_beacon_alloc(ic, ni);
	if (m == NULL)
		return (1);

	off = acx_beacon_locate(m, IEEE80211_ELEMID_TIM);
	if (off < 0) {
		m_free(m);
		return (1);
	}

	m_copydata(m, 0, off, (caddr_t)&beacon.data);
	len = off + sizeof(beacon.size);

	if (acx_set_tmplt(sc, ACXCMD_TMPLT_BEACON, &beacon, len) != 0) {
		m_freem(m);
		return (1);
	}

	len = m->m_pkthdr.len - off;
	if (len == 0) {
		/* no TIM field */
		m_freem(m);
		return (0);
	}

	m_copydata(m, off, len, (caddr_t)&tim.data);
	len += sizeof(beacon.size);
	m_freem(m);

	return (acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &tim, len));
}
#endif	/* IEEE80211_STA_ONLY */

void
acx_init_cmd_reg(struct acx_softc *sc)
{
	sc->sc_cmd = CSR_READ_4(sc, ACXREG_CMD_REG_OFFSET);
	sc->sc_cmd_param = sc->sc_cmd + ACX_CMD_REG_SIZE;

	/* Clear command & status */
	CMD_WRITE_4(sc, 0);
}

int
acx_join_bss(struct acx_softc *sc, uint8_t mode, struct ieee80211_node *node)
{
	uint8_t bj_buf[BSS_JOIN_BUFLEN];
	struct bss_join_hdr *bj;
	int i, dtim_intvl;

	bzero(bj_buf, sizeof(bj_buf));
	bj = (struct bss_join_hdr *)bj_buf;

	for (i = 0; i < IEEE80211_ADDR_LEN; ++i)
		bj->bssid[i] = node->ni_bssid[IEEE80211_ADDR_LEN - i - 1];

	bj->beacon_intvl = htole16(acx_beacon_intvl);

	/* TODO tunable */
#ifndef IEEE80211_STA_ONLY
	if (sc->sc_ic.ic_opmode == IEEE80211_M_IBSS)
		dtim_intvl = 1;
	else
#endif
		dtim_intvl = 10;
	sc->chip_set_bss_join_param(sc, bj->chip_spec, dtim_intvl);

	bj->ndata_txrate = ACX_NDATA_TXRATE_1;
	bj->ndata_txopt = 0;
	bj->mode = mode;
	bj->channel = ieee80211_chan2ieee(&sc->sc_ic, node->ni_chan);
	bj->esslen = node->ni_esslen;
	bcopy(node->ni_essid, bj->essid, node->ni_esslen);

	DPRINTF(("%s: join BSS/IBSS on channel %d\n", sc->sc_dev.dv_xname,
	    bj->channel));
	return (acx_exec_command(sc, ACXCMD_JOIN_BSS,
	    bj, BSS_JOIN_PARAM_SIZE(bj), NULL, 0));
}

int
acx_set_channel(struct acx_softc *sc, uint8_t chan)
{
	if (acx_exec_command(sc, ACXCMD_ENABLE_TXCHAN, &chan, sizeof(chan),
	    NULL, 0) != 0) {
		DPRINTF(("%s: setting TX channel %d failed\n",
		    sc->sc_dev.dv_xname, chan));
		return (ENXIO);
	}

	if (acx_exec_command(sc, ACXCMD_ENABLE_RXCHAN, &chan, sizeof(chan),
	    NULL, 0) != 0) {
		DPRINTF(("%s: setting RX channel %d failed\n",
		    sc->sc_dev.dv_xname, chan));
		return (ENXIO);
	}

	return (0);
}

int
acx_get_conf(struct acx_softc *sc, uint16_t conf_id, void *conf,
    uint16_t conf_len)
{
	struct acx_conf *confcom;

	if (conf_len < sizeof(*confcom)) {
		printf("%s: %s configure data is too short\n",
		    sc->sc_dev.dv_xname, __func__);
		return (1);
	}

	confcom = conf;
	confcom->conf_id = htole16(conf_id);
	confcom->conf_data_len = htole16(conf_len - sizeof(*confcom));

	return (acx_exec_command(sc, ACXCMD_GET_CONF, confcom, sizeof(*confcom),
	    conf, conf_len));
}

int
acx_set_conf(struct acx_softc *sc, uint16_t conf_id, void *conf,
    uint16_t conf_len)
{
	struct acx_conf *confcom;

	if (conf_len < sizeof(*confcom)) {
		printf("%s: %s configure data is too short\n",
		    sc->sc_dev.dv_xname, __func__);
		return (1);
	}

	confcom = conf;
	confcom->conf_id = htole16(conf_id);
	confcom->conf_data_len = htole16(conf_len - sizeof(*confcom));

	return (acx_exec_command(sc, ACXCMD_SET_CONF, conf, conf_len, NULL, 0));
}

int
acx_set_tmplt(struct acx_softc *sc, uint16_t cmd, void *tmplt,
    uint16_t tmplt_len)
{
	uint16_t *size;

	if (tmplt_len < sizeof(*size)) {
		printf("%s: %s template is too short\n",
		    sc->sc_dev.dv_xname, __func__);
		return (1);
	}

	size = tmplt;
	*size = htole16(tmplt_len - sizeof(*size));

	return (acx_exec_command(sc, cmd, tmplt, tmplt_len, NULL, 0));
}

int
acx_init_radio(struct acx_softc *sc, uint32_t radio_ofs, uint32_t radio_len)
{
	struct radio_init r;

	r.radio_ofs = htole32(radio_ofs);
	r.radio_len = htole32(radio_len);

	return (acx_exec_command(sc, ACXCMD_INIT_RADIO, &r, sizeof(r), NULL,
	    0));
}

int
acx_exec_command(struct acx_softc *sc, uint16_t cmd, void *param,
    uint16_t param_len, void *result, uint16_t result_len)
{
	uint16_t status;
	int i, ret;

	if ((sc->sc_flags & ACX_FLAG_FW_LOADED) == 0) {
		printf("%s: cmd 0x%04x failed (base firmware not loaded)\n",
		    sc->sc_dev.dv_xname, cmd);
		return (1);
	}

	ret = 0;

	if (param != NULL && param_len != 0) {
		/* Set command param */
		CMDPRM_WRITE_REGION_1(sc, param, param_len);
	}

	/* Set command */
	CMD_WRITE_4(sc, cmd);

	/* Exec command */
	CSR_WRITE_2(sc, ACXREG_INTR_TRIG, ACXRV_TRIG_CMD_FINI);
	DELAY(50);

	/* Wait for command to complete */
	if (cmd == ACXCMD_INIT_RADIO) {
		/* radio initialization is extremely long */
		tsleep(&cmd, 0, "rdinit", (300 * hz) / 1000);	/* 300ms */
	}

#define CMDWAIT_RETRY_MAX	1000
	for (i = 0; i < CMDWAIT_RETRY_MAX; ++i) {
		uint16_t reg;

		reg = CSR_READ_2(sc, ACXREG_INTR_STATUS);
		if (reg & ACXRV_INTR_CMD_FINI) {
			CSR_WRITE_2(sc, ACXREG_INTR_ACK, ACXRV_INTR_CMD_FINI);
			break;
		}
		DELAY(50);
	}
	if (i == CMDWAIT_RETRY_MAX) {
		printf("%s: cmd %04x failed (timeout)\n",
		    sc->sc_dev.dv_xname, cmd);
		ret = 1;
		goto back;
	}
#undef CMDWAIT_RETRY_MAX

	/* Get command exec status */
	status = (CMD_READ_4(sc) >> ACX_CMD_STATUS_SHIFT);
	if (status != ACX_CMD_STATUS_OK) {
		DPRINTF(("%s: cmd %04x failed\n", sc->sc_dev.dv_xname, cmd));
		ret = 1;
		goto back;
	}

	if (result != NULL && result_len != 0) {
		/* Get command result */
		CMDPRM_READ_REGION_1(sc, result, result_len);
	}

back:
	CMD_WRITE_4(sc, 0);

	return (ret);
}

const char *
acx_get_rf(int rev)
{
	switch (rev) {
	case ACX_RADIO_TYPE_MAXIM:	return "MAX2820";
	case ACX_RADIO_TYPE_RFMD:	return "RFMD";
	case ACX_RADIO_TYPE_RALINK:	return "Ralink";
	case ACX_RADIO_TYPE_RADIA:	return "Radia";
	default:			return "unknown";
	}
}

int
acx_get_maxrssi(int radio)
{
	switch (radio) {
	case ACX_RADIO_TYPE_MAXIM:	return ACX_RADIO_RSSI_MAXIM;
	case ACX_RADIO_TYPE_RFMD:	return ACX_RADIO_RSSI_RFMD;
	case ACX_RADIO_TYPE_RALINK:	return ACX_RADIO_RSSI_RALINK;
	case ACX_RADIO_TYPE_RADIA:	return ACX_RADIO_RSSI_RADIA;
	default:			return ACX_RADIO_RSSI_UNKN;
	}
}

void
acx_iter_func(void *arg, struct ieee80211_node *ni)
{
	struct acx_softc *sc = arg;
	struct acx_node *wn = (struct acx_node *)ni;

	ieee80211_amrr_choose(&sc->amrr, ni, &wn->amn);
}

void
acx_amrr_timeout(void *arg)
{
	struct acx_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_opmode == IEEE80211_M_STA)
		acx_iter_func(sc, ic->ic_bss);
	else
		ieee80211_iterate_nodes(ic, acx_iter_func, sc);

	timeout_add_msec(&sc->amrr_ch, 500);
}

void
acx_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	struct acx_softc *sc = ic->ic_if.if_softc;
	int i;

	ieee80211_amrr_node_init(&sc->amrr, &((struct acx_node *)ni)->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	    i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	    i--);
	ni->ni_txrate = i;
}

#ifndef IEEE80211_STA_ONLY
void
acx_set_tim(struct ieee80211com *ic, int aid, int set)
{
	struct acx_softc *sc = ic->ic_if.if_softc;
	struct acx_tmplt_tim tim;
	u_int8_t *ep;

	ieee80211_set_tim(ic, aid, set);

	bzero(&tim, sizeof(tim));
	ep = ieee80211_add_tim(tim.data.u_mem, ic);

	acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &tim, ep - (u_int8_t *)&tim);
}
#endif
@


1.119
log
@No need to set 'error' to 0 at the beginning of acx_encap(), as
we're only going to set it again 10 lines later.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.118 2016/04/13 10:49:26 mpi Exp $ */
d1181 1
a1181 2
		} else
			ifp->if_opackets++;
@


1.118
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.117 2015/11/25 03:09:58 dlg Exp $ */
a2198 2

	error = 0;
@


1.117
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.116 2015/11/24 17:11:39 mpi Exp $ */
a287 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.116
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.115 2015/11/24 13:33:17 mpi Exp $ */
d480 1
a480 1
	ifp->if_flags &= ~IFF_OACTIVE;
d613 2
a614 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d914 1
a914 1
	    (ifp->if_flags & IFF_OACTIVE))
d1070 1
a1070 1
		ifp->if_flags |= IFF_OACTIVE;
d1220 1
a1220 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.115
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.114 2015/11/04 12:11:59 dlg Exp $ */
a106 1
#include <net/if_dl.h>
@


1.114
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.113 2015/10/25 12:48:46 mpi Exp $ */
a108 1
#include <net/if_types.h>
@


1.113
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.112 2015/09/06 04:10:34 deraadt Exp $ */
d933 1
a933 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
d961 1
a961 1
			IF_DEQUEUE(&ic->ic_pwrsaveq, m);
@


1.112
log
@firmware size for free()
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.111 2015/03/14 03:38:47 jsg Exp $ */
a841 1
	struct ifaddr *ifa;
a849 1
		ifa = (struct ifaddr *)data;
a850 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			 arp_ifinit(&ic->ic_ac, ifa);
@


1.111
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.110 2015/02/10 23:25:46 mpi Exp $ */
d1551 1
a1551 1
	free(ucode, M_DEVBUF, 0);
d1602 1
a1602 1
		free(ucode, M_DEVBUF, 0);
d1609 1
a1609 1
		free(ucode, M_DEVBUF, 0);
d1616 1
a1616 1
	free(ucode, M_DEVBUF, 0);
@


1.110
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.109 2014/12/22 02:28:51 tedu Exp $ */
a106 1
#include <net/if_arp.h>
@


1.109
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.108 2014/12/19 22:44:58 guenther Exp $ */
a1390 1
			m->m_pkthdr.rcvif = &ic->ic_if;
@


1.108
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.107 2014/09/14 14:17:24 jsg Exp $ */
a115 1
#ifdef INET
a117 1
#endif
a853 1
#ifdef INET
a855 1
#endif
@


1.107
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.106 2014/09/08 07:21:40 kettenis Exp $ */
d101 1
a103 1
#include <machine/endian.h>
@


1.106
log
@Don't include <sys/types.h>; we already include <sys/param.h>.
Add missing <sys/errno.h> and <sys/device.h>.  Makes a sparc64 kernel
compile again.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.105 2014/09/06 05:41:35 jsg Exp $ */
a95 1
#include <sys/proc.h>
@


1.105
log
@reduce the amount of pci includes
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.104 2014/07/22 13:12:11 mpi Exp $ */
d100 2
a101 1
#include <sys/types.h>
@


1.104
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.103 2014/07/12 18:48:17 tedu Exp $ */
a123 4

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>
@


1.103
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.102 2014/03/19 10:09:19 mpi Exp $ */
a117 1
#include <netinet/in_systm.h>
a118 1
#include <netinet/ip.h>
@


1.102
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.101 2013/08/07 01:06:27 bluhm Exp $ */
d1563 1
a1563 1
	free(ucode, M_DEVBUF);
d1614 1
a1614 1
		free(ucode, M_DEVBUF);
d1621 1
a1621 1
		free(ucode, M_DEVBUF);
d1628 1
a1628 1
	free(ucode, M_DEVBUF);
@


1.101
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.100 2013/03/24 17:02:09 claudio Exp $ */
d951 1
a951 2
			ni = (struct ieee80211_node *)m->m_pkthdr.rcvif;
			m->m_pkthdr.rcvif = NULL;
d978 1
a978 2
				ni = (struct ieee80211_node *)m->m_pkthdr.rcvif;
				m->m_pkthdr.rcvif = NULL;
@


1.100
log
@Use ieee80211_set_tim() directly now that it is available.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.99 2012/12/05 23:20:16 deraadt Exp $ */
a118 1
#include <netinet/in_var.h>
@


1.99
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.98 2012/10/27 16:13:28 claudio Exp $ */
d2765 1
a2765 4
	if (set)
		setbit(ic->ic_tim_bitmap, aid & ~0xc000);
	else
		clrbit(ic->ic_tim_bitmap, aid & ~0xc000);
@


1.98
log
@Implememnt AP side power saving for acx(4). Tested on acx11.
With some input and OK from kettenis@@ and OK sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.97 2010/08/27 17:08:00 jsg Exp $ */
a88 1
#include <sys/cdefs.h>
@


1.97
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.96 2010/08/07 03:50:01 krw Exp $ */
d205 3
d322 1
d350 5
d951 1
d975 1
a975 1
		} else if (!IFQ_IS_EMPTY(&ifp->if_snd)) {
d978 11
a988 4
			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL)
				break;

d1017 1
a1017 6

#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif

d1024 6
a1029 2
		} else
			break;
d1083 1
a1083 1
		trans = 1;
d1135 3
d1144 4
a1147 2
	/* Acknowledge all interrupts */
	CSR_WRITE_2(sc, ACXREG_INTR_ACK, ACXRV_INTR_ALL);
d2757 20
@


1.96
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.95 2009/09/13 14:42:52 krw Exp $ */
a291 1
	ifp->if_init = acx_init;
@


1.95
log
@M_DUP_PKTHDR() define -> m_dup_pkthdr() function to properly deal
with m_tag_copy_chain() failures.

Use m_defrag() to eliminate hand rolled defragging of mbufs and
some uses of M_DUP_PKTHDR().

Original diff from thib@@, claudio@@'s feedback integrated by me.

Tests kevlo@@ claudio@@, "reads ok" blambert@@

ok thib@@ claudio@@, "m_defrag() bits ok" kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.94 2009/07/28 11:39:52 blambert Exp $ */
d2200 1
a2200 1
		panic("free TX buf has mbuf installed\n");
@


1.94
log
@timeout_add -> timout_add_msec

ok jsg@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.93 2009/03/31 22:06:04 claudio Exp $ */
d2225 1
a2225 8
		struct mbuf *mnew;

		error = 0;

		MGETHDR(mnew, M_DONTWAIT, MT_DATA);
		if (mnew == NULL) {
			m_freem(m);
			error = ENOBUFS;
a2228 21

		M_DUP_PKTHDR(mnew, m);
		if (m->m_pkthdr.len > MHLEN) {
			MCLGET(mnew, M_DONTWAIT);
			if (!(mnew->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(mnew);
				error = ENOBUFS;
			}
		}

		if (error) {
			printf("%s: can't defrag tx mbuf\n", ifp->if_xname);
			goto back;
		}

		m_copydata(m, 0, m->m_pkthdr.len, mtod(mnew, caddr_t));
		m_freem(m);
		mnew->m_len = mnew->m_pkthdr.len;
		m = mnew;

@


1.93
log
@On watchdog timeout reset the full chip. Just draining the tx ring is not
enough to get the device unstuck. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.92 2009/03/29 21:53:52 sthen Exp $ */
a205 1
static int	acx_chanscan_rate = 5;	/* 5 channels per second */
d1751 2
a1752 2
			timeout_add(&sc->sc_chanscan_timer,
			    hz / acx_chanscan_rate);
d1837 1
a1837 1
			timeout_add(&sc->amrr_ch, hz / 2);
d2748 1
a2748 1
	timeout_add(&sc->amrr_ch, hz / 2);
@


1.92
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.91 2009/03/11 23:51:15 stsp Exp $ */
d1096 1
a1096 1
			acx_txeof(ifp->if_softc);
@


1.91
log
@Do more error checking in acx(4).
"If it works for you, commit it. The diff looks right." claudio@@
"Seems to work here with ACX111 CardBus" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.90 2009/03/09 11:25:22 stsp Exp $ */
d1930 1
a1930 1
		printf("%s: could not map rx desc DMA memory\n",
d1970 1
a1970 1
		printf("%s: could not map tx desc DMA memory\n",
@


1.90
log
@Do not start printing device info before attachment succeeded.
ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.89 2009/02/26 23:11:31 stsp Exp $ */
d167 1
a167 1
int	 acx_init_tx_ring(struct acx_softc *);
d275 2
d328 5
d412 5
a416 2
	if (sc->sc_enable != NULL)
		(*sc->sc_enable)(sc);
d418 1
a418 6
	error = acx_init_tx_ring(sc);
	if (error) {
		printf("%s: can't initialize TX ring\n",
		    sc->sc_dev.dv_xname);
		goto back;
	}
d495 1
d497 2
a498 4
	if (error)
		acx_stop(sc);

	return (0);
d865 1
a865 1
				acx_init(ifp);
d868 1
a868 1
				acx_stop(sc);
d904 3
a906 2
			acx_init(ifp);
		error = 0;
d1747 4
a1750 1
			(void)acx_set_channel(sc, chan);
d2070 1
a2070 1
int
a2098 2

	return (0);
d2450 1
a2450 2
	/* type not found */
	return (m->m_len);
d2470 4
@


1.89
log
@If acx_attach() fails, print the reason why it is failing.
Amendment to fix for PR6089. Patch by mglocker@@
"good night guys!" mglocker@@, "hurry up" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.88 2008/11/23 12:11:27 claudio Exp $ */
a269 4
	printf("%s: %s, radio %s (0x%02x)", sc->sc_dev.dv_xname,
	    (sc->sc_flags & ACX_FLAG_ACX111) ? "ACX111" : "ACX100",
	    acx_get_rf(sc->sc_radio_type), sc->sc_radio_type);

d285 1
a285 1
		printf("\n%s: attach failed, could not get EEPROM version!\n",
a289 2
	printf(", EEPROM ver %u", sc->sc_eeprom_ver);

d328 5
a332 1
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
@


1.88
log
@Don't use ifp->if_xname if you can use the sc_dev.dv_xname instead.
Removes some unneeded ifp pointers from the stack and don't assign
ifp->if_softc twice in the same function.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.87 2008/08/27 09:05:03 damien Exp $ */
d233 3
a235 1
	if (error)
d237 1
d241 3
a243 1
	if (error)
d245 1
d263 3
a265 1
	if (i == EEINFO_RETRY_MAX)
d267 1
d288 3
a290 1
	if (error)
d292 1
@


1.87
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.86 2008/08/14 16:02:24 damien Exp $ */
a227 2
	ifp->if_softc = sc;

a1455 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d1469 1
a1469 1
		    ifp->if_xname, offset);
a1885 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d1934 2
a1935 1
		printf("%s: can't create tx ring dma tag\n", ifp->if_xname);
d1944 1
a1944 1
		    ifp->if_xname);
d1961 2
a1962 1
		printf("%s: can't get tx ring dma address\n", ifp->if_xname);
d1974 2
a1975 1
		printf("%s: can't create tmp mbuf dma map\n", ifp->if_xname);
d1985 1
a1985 1
			    ifp->if_xname, i);
d1997 1
a1997 1
			    ifp->if_xname, i);
@


1.86
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.85 2008/07/21 18:43:19 damien Exp $ */
d177 1
d181 1
d311 2
a313 1
	    IEEE80211_C_MONITOR |		/* Monitor mode */
d315 1
d1773 1
d1816 1
a1816 1

d2375 1
d2478 1
d2506 6
a2511 1
	dtim_intvl = sc->sc_ic.ic_opmode == IEEE80211_M_IBSS ? 1 : 10;
@


1.85
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.84 2008/06/22 21:40:36 brad Exp $ */
a1419 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		(*ifp->if_start)(ifp);
@


1.84
log
@Update watchdog timer code from DragonFly.

From sephe@@DragonFly

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.83 2008/06/01 10:08:35 brad Exp $ */
d1318 1
d1354 1
d1365 1
d1396 3
a1398 2
			ieee80211_input(ifp, m, ni, head->rbh_level,
			    letoh32(head->rbh_time));
@


1.83
log
@Use 1Mbits/s as beacon sending rate; it seems to fix TX performance issue
when using acx(4) as HostAP.

From sephe@@DraonFly

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.82 2008/04/16 18:32:15 damien Exp $ */
d601 1
d1061 3
a1063 3
	if (trans && ifp->if_timer == 0)
		ifp->if_timer = 5;
	sc->sc_txtimer = 5;
d1082 2
a1083 2
		}
		ifp->if_timer = 5;
d1201 1
a1201 2
	ifp->if_timer = bd->tx_used_count == 0 ? 0 : 5;
	sc->sc_txtimer = 0;
@


1.82
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.81 2008/03/13 23:07:28 brad Exp $ */
d2505 1
a2505 1
	bj->ndata_txrate = ACX_NDATA_TXRATE_2;
@


1.81
log
@Do not increment the input packet counter in these drivers as
ieee80211_input() already does this.

Mentioned by Peter Philipp in PR 5248.

ok claudio@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.80 2007/11/26 09:28:33 martynas Exp $ */
d1001 4
a1004 2
			m = ieee80211_wep_crypt(ifp, m, 1);
			if (m == NULL) {
a1005 1
				m_freem(m);
@


1.80
log
@typos;  ok jmc@@
sys/netinet/in_pcb.c and sys/net/bridgestp.c ok henning@@
sys/dev/pci/bktr/* ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.79 2007/10/14 11:36:52 mglocker Exp $ */
a1395 1
			ifp->if_ipackets++;
@


1.79
log
@Fix a panic which happens with ACX100 chipsets in ieee80211_add_xrates()
because the drivers tries to set extended rates for a 11b chip.

Tested and OK winiger@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.78 2007/10/01 04:03:51 krw Exp $ */
d1241 1
a1241 1
		printf("wrong paramters in descriptor\n");
@


1.78
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.77 2007/08/28 18:34:38 deraadt Exp $ */
d2347 1
d2363 4
a2366 2
	frm = ieee80211_add_rates(frm, &ic->ic_sup_rates[sc->chip_phymode]);
	frm = ieee80211_add_xrates(frm, &ic->ic_sup_rates[sc->chip_phymode]);
@


1.77
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.76 2007/08/05 22:40:38 claudio Exp $ */
d1711 1
a1711 1
	wn = malloc(sizeof(struct acx_node), M_DEVBUF, M_NOWAIT);
a1713 2

	bzero(wn, sizeof(struct acx_node));
@


1.76
log
@Don't use ieee80211_beacon_alloc() in acx_set_probe_resp_tmplt() use
ieee80211_get_probe_resp() and code from ieee80211_mgmt_output() to build
a proper probe response. Found the hard way -- buffer overflow because of
oversized beacons -- by mglocker@@ and myself.  OK mglocker@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.75 2007/07/18 18:10:31 damien Exp $ */
d1527 1
a1527 1
		printf("%s: error %d, could not read microcode %s!\n",
d1576 1
a1576 1
		printf("%s: error %d, could not read microcode %s!\n",
@


1.75
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.74 2007/05/03 21:24:56 mglocker Exp $ */
d1182 1
a1182 1
				DPRINTF(("%s: tx intr ntries %d\n",
d2372 3
d2380 1
d2386 4
a2389 1
	m = ieee80211_beacon_alloc(ic, ni);
d2392 10
@


1.74
log
@Add monitor mode.  Add fast channel switching.  Do some simplifications
while there.

Comments, tested, and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.73 2007/04/11 21:38:50 mglocker Exp $ */
d500 1
a500 1
		struct ieee80211_wepkey *wk = &ic->ic_nw_keys[i];
d502 1
a502 1
		if (wk->wk_len == 0)
d506 1
a506 1
			error = sc->chip_set_wepkey(sc, wk, i);
@


1.73
log
@Remove debug leftovers to make console output quite again in hostap mode.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.72 2007/04/11 19:49:11 mglocker Exp $ */
d149 1
d197 1
a197 2
int	 acx_enable_txchan(struct acx_softc *, uint8_t);
int	 acx_enable_rxchan(struct acx_softc *, uint8_t);
d307 4
a310 2
	ic->ic_caps |= IEEE80211_C_WEP |	/* WEP */
	    IEEE80211_C_IBSS |			/* IBSS modes */
d384 1
d471 6
a476 2
	/* Begin background scanning */
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_SCAN, -1);
d626 4
a730 1
	struct acx_conf_rxopt rx_opt;
d785 31
a815 7
	/* What we want to receive and how to receive */
	/* XXX may not belong here, acx_init() */
	rx_opt.opt1 = htole16(RXOPT1_FILT_FDEST | RXOPT1_INCL_RXBUF_HDR);
	rx_opt.opt2 = htole16(RXOPT2_RECV_ASSOC_REQ | RXOPT2_RECV_AUTH |
	    RXOPT2_RECV_BEACON | RXOPT2_RECV_CF | RXOPT2_RECV_CTRL |
	    RXOPT2_RECV_DATA | RXOPT2_RECV_MGMT | RXOPT2_RECV_PROBE_REQ |
	    RXOPT2_RECV_PROBE_RESP | RXOPT2_RECV_OTHER);
d817 1
a817 1
		printf("%s: can't set RX option\n", ifp->if_xname);
d832 1
d864 15
d1736 1
a1736 9

			if (acx_enable_txchan(sc, chan) != 0) {
				DPRINTF(("%s: enable TX on channel %d failed\n",
				    ifp->if_xname, chan));
			}
			if (acx_enable_rxchan(sc, chan) != 0) {
				DPRINTF(("%s: enable RX on channel %d failed\n",
				    ifp->if_xname, chan));
			}
d1784 1
a1784 3
			if (acx_enable_txchan(sc, chan) != 0) {
				printf("%s: enable TX on channel %d failed\n",
				    ifp->if_xname, chan);
a1785 7
			}

			if (acx_enable_rxchan(sc, chan) != 0) {
				printf("%s: enable RX on channel %d failed\n",
				    ifp->if_xname, chan);
				goto back;
			}
d2501 1
a2501 1
acx_enable_txchan(struct acx_softc *sc, uint8_t chan)
d2503 13
a2515 3
	return (acx_exec_command(sc, ACXCMD_ENABLE_TXCHAN, &chan, sizeof(chan),
	    NULL, 0));
}
d2517 1
a2517 5
int
acx_enable_rxchan(struct acx_softc *sc, uint8_t chan)
{
	return (acx_exec_command(sc, ACXCMD_ENABLE_RXCHAN, &chan, sizeof(chan),
	    NULL, 0));
@


1.72
log
@As probe response mgmt frames are already handled by the firmware, ignore
the ones which come from the 802.11 stack.  Seen in the DragonFly driver.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.71 2007/04/03 18:57:34 claudio Exp $ */
a2377 2
		printf("acx_beacon_locate: off %d type %x len %x\n",
		    off, frm[off], frm[off + 1]);
a2401 2
	printf("acx_set_beacon_tmplt: acx_beacon_locate TIM off %d len %d\n",
	    off, m->m_pkthdr.len);
@


1.71
log
@Really drop data packets if the station is not associated. It does not
make sense to keep these packets around and send them out somewhen later
when they are no longer valid.  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.70 2007/03/29 12:27:59 claudio Exp $ */
d879 13
@


1.70
log
@Fix a scary bug when setting up the HW dma structure. Use a 2byte bus_space
access to write the mbuf lenght instead of a 4byte one. On big endian machines
the length was written to the wrong field and so no TX transactions were done.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.69 2007/03/19 23:28:23 claudio Exp $ */
d889 4
d897 1
a899 4

			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL)
				break;
@


1.69
log
@Only call bus_dmamap_unload() if we loaded a dmamap beforehand. Found out
the hard way on sparc64. Now acx(4) no longer panics but it does not yet
work.  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.68 2007/03/16 11:06:39 claudio Exp $ */
d2252 1
a2252 1
	FW_TXDESC_SETFIELD_4(sc, txbuf, f_tx_len, m->m_pkthdr.len);
@


1.68
log
@Split the beacon returned by ieee80211_beacon_alloc() in two parts and
fill everything up to IEEE80211_ELEMID_TIM into the beacon template and
everything after and including IEEE80211_ELEMID_TIM into the tim template.
This fixes the beacons on 11g where two TIM fields where announced.
acx_beacon_locate() is used to calculate the offset to a defined TLV field.
If other dirvers need it as well we may move it up into net80211.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.67 2007/03/14 08:12:30 claudio Exp $ */
d2108 2
a2109 1
	bus_dmamap_unload(sc->sc_dmat, rb->rb_mbuf_dmamap);
@


1.67
log
@In HostAP mode, ieee80211_input() will enqueue packets in if_snd without
calling if_start(). So call ifp->if_start() at the end of the RX interrupt
function. This solves the porblem of getting dhcp leases from the AP if the
network is quiet.  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.66 2007/03/01 10:55:14 claudio Exp $ */
d177 1
a1833 9
	/* Setup TIM template */
	data.tim.tim_eid = IEEE80211_ELEMID_TIM;
	data.tim.tim_len = ACX_TIM_LEN(ACX_TIM_BITMAP_LEN);
	if (acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &data.tim,
	    ACX_TMPLT_TIM_SIZ(ACX_TIM_BITMAP_LEN)) != 0) {
		printf("%s: can't set tim tmplt\n", sc->sc_dev.dv_xname);
		return (1);
	}

d2345 28
d2377 1
d2379 4
a2382 1
	int len;
d2387 22
a2408 3
	bzero(&beacon, sizeof(beacon));
	m_copydata(m, 0, m->m_pkthdr.len, (caddr_t)&beacon.data);
	len = m->m_pkthdr.len + sizeof(beacon.size);
d2411 1
a2411 1
	return (acx_set_tmplt(sc, ACXCMD_TMPLT_BEACON, &beacon, len));
@


1.66
log
@In acx_set_probe_resp_tmplt () ieee80211_beacon_alloc() could fail so check the
return value. Stolen from acx_set_beacon_tmplt() that already does this check.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.65 2007/02/28 09:26:26 claudio Exp $ */
d1351 7
@


1.65
log
@Another round of makro killing. Kill _ACX_CONF_FUNC() and replace all
calls with acx_set_conf()/acx_get_conf(). OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.64 2007/02/28 09:09:29 claudio Exp $ */
d2336 2
@


1.64
log
@Fix a ieee80211_node refcount leak -- the node lookup is done in
ieee80211_encap() so there is no need to do call ieee80211_find_txnode()
beforehands. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.63 2007/02/23 22:17:05 claudio Exp $ */
d510 2
a511 1
	if (acx_set_wep_txkey_conf(sc, &wep_txkey) != 0) {
d645 1
a645 1
	if (acx_get_regdom_conf(sc, &reg_dom) != 0) {
d653 1
a653 1
	if (acx_get_antenna_conf(sc, &ant) != 0) {
d675 1
a675 1
	if (acx_get_fwrev_conf(sc, &fw_rev) != 0) {
d725 2
a726 1
	if (acx_set_nretry_short_conf(sc, &sretry) != 0) {
d732 2
a733 1
	if (acx_set_nretry_long_conf(sc, &lretry) != 0) {
d740 2
a741 1
	if (acx_set_msdu_lifetime_conf(sc, &msdu_lifetime) != 0) {
d748 2
a749 1
	if (acx_set_rate_fallback_conf(sc, &rate_fb) != 0) {
d756 1
a756 1
	if (acx_set_antenna_conf(sc, &ant) != 0) {
d763 1
a763 1
	if (acx_set_regdom_conf(sc, &reg_dom) != 0) {
d781 1
a781 1
	if (acx_set_rxopt_conf(sc, &rx_opt) != 0) {
d1513 1
a1513 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0) {
d1545 1
a1545 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0)
@


1.63
log
@Another two missing htoleX() for big endian support. Still more missing
but now I'm able to receive packets on macppc. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.62 2007/02/21 14:25:51 claudio Exp $ */
a901 7

			ni = ieee80211_find_txnode(ic, eh->ether_dhost);
			if (ni == NULL) {
				m_freem(m);
				ifp->if_oerrors++;
				continue;
			}
@


1.62
log
@Make the firmware load on big endian systems and while there make sure that
the right value is printed in case of an error. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.61 2007/02/20 22:06:46 claudio Exp $ */
d771 5
a775 11
	rx_opt.opt1 = RXOPT1_FILT_FDEST | RXOPT1_INCL_RXBUF_HDR;
	rx_opt.opt2 = RXOPT2_RECV_ASSOC_REQ |
	    RXOPT2_RECV_AUTH |
	    RXOPT2_RECV_BEACON |
	    RXOPT2_RECV_CF |
	    RXOPT2_RECV_CTRL |
	    RXOPT2_RECV_DATA |
	    RXOPT2_RECV_MGMT |
	    RXOPT2_RECV_PROBE_REQ |
	    RXOPT2_RECV_PROBE_RESP |
	    RXOPT2_RECV_OTHER;
@


1.61
log
@Fix a memory leak in acx_load_radio_firmware() -- free the ucode after use.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.60 2006/12/31 14:27:17 claudio Exp $ */
d1581 1
a1581 1
	if (*fw != csum) {
d1583 1
a1583 1
		    ifp->if_xname, fw, csum);
@


1.60
log
@Bye bye unused acx_shutdown() we won't miss you.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.59 2006/12/30 22:43:01 claudio Exp $ */
d1521 2
a1522 1
	if (acx_get_mmap_conf(sc, &mem_map) != 0)
d1524 1
d1528 2
a1529 1
	if (acx_exec_command(sc, ACXCMD_SLEEP, NULL, 0, NULL, 0) != 0)
d1531 1
d1535 3
@


1.59
log
@Don't use M_DUP_PKTHDR() on static mbufs. M_DUP_PKTHDR() copies the mtag
chain and so a later MFREE() is needed to free the chain again.
Just initialize a minimal mbuf header for bpf_mtap().
See earlier rum(4) commit for the full story.
OK mglocker@@ Sounds good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.58 2006/12/17 21:45:48 claudio Exp $ */
a141 1
void	 acx_shutdown(void *);
a374 8
}

void
acx_shutdown(void *arg)
{
	struct acx_softc *sc = arg;

	acx_stop(sc);
@


1.58
log
@Kill some more macros. This time ACX_NOARG_FUNC and ACX_INIT_TMPLT_FUNC
bite the dust and make the code easier to read. Help and OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.57 2006/12/13 11:03:54 mglocker Exp $ */
a973 1
			M_DUP_PKTHDR(&mb, m);
d977 3
a979 1
			mb.m_pkthdr.len += mb.m_len;
a1331 1
				M_DUP_PKTHDR(&mb, m);
d1335 3
a1337 1
				mb.m_pkthdr.len += mb.m_len;
@


1.57
log
@First part of fixing broken beacon frames in acx(4) AP mode based on a
diff from Sepherosa Ziehau (DragonFly);  The firmware TIM element template
was initialized wrong.

Though, our ieee80211_alloc_beacon() routine calculates it's own TIM
element, which now results in having two TIMs in an acx(4) beacon.

Would it be an idea to introduce a ieee80211_alloc_beacon() flag to
turn the TIM element off?  Because fiddling out the TIM element in the
driver for cases in which the firmware calculates its own TIM is
a bit ugly ...

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.56 2006/12/08 09:17:34 claudio Exp $ */
d1533 1
a1533 1
	if (acx_sleep(sc) != 0)
d1545 1
a1545 1
	if (acx_wakeup(sc) != 0)
d1795 7
a1801 1
	struct acx_tmplt_tim tim;
d1803 1
d1814 2
a1815 1
	if (acx_init_probe_req_tmplt(sc) != 0)
d1818 2
a1819 1
	if (acx_init_null_data_tmplt(sc) != 0)
d1822 2
a1823 1
	if (acx_init_beacon_tmplt(sc) != 0)
d1826 2
a1827 1
	if (acx_init_tim_tmplt(sc) != 0)
d1830 2
a1831 1
	if (acx_init_probe_resp_tmplt(sc) != 0)
d1835 3
a1837 4
	bzero(&tim, sizeof(tim));
	tim.tim_eid = IEEE80211_ELEMID_TIM;
	tim.tim_len = ACX_TIM_LEN(ACX_TIM_BITMAP_LEN);
	if (acx_set_tmplt(sc, ACXCMD_TMPLT_TIM, &tim,
a1842 1
#undef CALL_SET_TMPLT
@


1.56
log
@First round of evil macro removal. _acx_set_##name##_tmplt bites the dust.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.55 2006/11/26 17:20:33 jsg Exp $ */
d1795 2
d1822 10
d2349 3
a2352 2

	m = ieee80211_beacon_alloc(ic, ni);
@


1.55
log
@Make use of ieee80211_std_rateset
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.54 2006/11/09 23:15:54 claudio Exp $ */
d2279 1
a2279 1
	return (_acx_set_null_data_tmplt(sc, &n, sizeof(n)));
d2307 1
a2307 1
	return (_acx_set_probe_req_tmplt(sc, &req,
d2326 1
a2326 1
	return (_acx_set_probe_resp_tmplt(sc, &resp, len));
d2344 1
a2344 1
	return (_acx_set_beacon_tmplt(sc, &beacon, len));
@


1.54
log
@Correctly update the m_pkthdr.len in the raw bpf tap. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.53 2006/10/10 20:45:38 mbalmer Exp $ */
a203 5
const struct ieee80211_rateset	acx_rates_11b =
	{ 4, { 2, 4, 11, 22 } };
const struct ieee80211_rateset	acx_rates_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

a292 4

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = acx_rates_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = acx_rates_11g;
@


1.53
log
@bescon -> beacon, found by Maxim Bourmistrov, thanks.  Since I am correcting
typos today...
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.52 2006/10/03 17:37:31 claudio Exp $ */
d987 1
a987 1
			mb.m_pkthdr.len = mb.m_len;
@


1.52
log
@Enable altq in acx(4) the tx path is already handling all cases correctly.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.51 2006/09/26 12:54:34 mglocker Exp $ */
d1750 1
a1750 1
				printf("%s: set bescon template failed\n",
@


1.51
log
@Get HostAP mode working and fix IBSS tweaks.  From DragonFly driver.

Tested by claudio and me so far.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.50 2006/08/29 17:26:38 mglocker Exp $ */
d296 2
@


1.50
log
@Don't panic when watchdog timeout is called.

formal ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.49 2006/08/21 09:39:37 mglocker Exp $ */
d177 2
a178 3
int	 acx_set_probe_resp_tmplt(struct acx_softc *, const char *, int,
	    int);
int	 acx_set_beacon_tmplt(struct acx_softc *, const char *, int, int);
d1747 1
a1747 2
			if (acx_set_beacon_tmplt(sc, ni->ni_essid,
			    ni->ni_esslen, chan) != 0) {
d1753 1
a1753 2
			if (acx_set_probe_resp_tmplt(sc, ni->ni_essid,
			    ni->ni_esslen, chan) != 0) {
d2272 1
a2274 1
	struct ieee80211com *ic = &sc->sc_ic;
d2292 1
a2294 1
	struct ieee80211com *ic = &sc->sc_ic;
a2311 1

d2319 1
a2319 2
acx_set_probe_resp_tmplt(struct acx_softc *sc, const char *ssid, int ssid_len,
    int chan)
d2321 1
d2323 1
a2323 3
	struct ieee80211_frame *wh;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t *frm;
d2328 4
a2331 10
	wh = &resp.data.u_data.f;
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_PROBE_RESP;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, ic->ic_myaddr);

	resp.data.u_data.beacon_intvl = htole16(acx_beacon_intvl);
	resp.data.u_data.cap = htole16(IEEE80211_CAPINFO_IBSS);
d2333 1
a2333 20
	frm = resp.data.u_data.var;
	frm = ieee80211_add_ssid(frm, ssid, ssid_len);
	frm = ieee80211_add_rates(frm, &ic->ic_sup_rates[sc->chip_phymode]);

	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = chan;

	/* This should after IBSS or TIM, but acx always keeps them last */
	frm = ieee80211_add_xrates(frm, &ic->ic_sup_rates[sc->chip_phymode]);

	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
	}

	len = frm - resp.data.u_data.var;

	return (_acx_set_probe_resp_tmplt(sc, &resp,
	    ACX_TMPLT_PROBE_RESP_SIZ(len)));
d2337 1
a2337 2
acx_set_beacon_tmplt(struct acx_softc *sc, const char *ssid, int ssid_len,
    int chan)
d2339 1
d2341 1
a2341 3
	struct ieee80211_frame *wh;
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t *frm;
d2346 4
a2349 28
	wh = &beacon.data.u_data.f;
	wh->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_MGT |
	    IEEE80211_FC0_SUBTYPE_BEACON;
	wh->i_fc[1] = IEEE80211_FC1_DIR_NODS;
	IEEE80211_ADDR_COPY(wh->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(wh->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(wh->i_addr3, ic->ic_myaddr);

	beacon.data.u_data.beacon_intvl = htole16(acx_beacon_intvl);
	beacon.data.u_data.cap = htole16(IEEE80211_CAPINFO_IBSS);

	frm = beacon.data.u_data.var;
	frm = ieee80211_add_ssid(frm, ssid, ssid_len);
	frm = ieee80211_add_rates(frm, &ic->ic_sup_rates[sc->chip_phymode]);

	*frm++ = IEEE80211_ELEMID_DSPARMS;
	*frm++ = 1;
	*frm++ = chan;

	/* This should after IBSS or TIM, but acx always keeps them last */
	frm = ieee80211_add_xrates(frm, &ic->ic_sup_rates[sc->chip_phymode]);

	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		*frm++ = IEEE80211_ELEMID_IBSSPARMS;
		*frm++ = 2;
	}

	len = frm - beacon.data.u_data.var;
d2351 1
a2351 1
	return (_acx_set_beacon_tmplt(sc, &beacon, ACX_TMPLT_BEACON_SIZ(len)));
@


1.49
log
@Add missing amrr statistic updates.  Makes rate control work proper.
Pointed out by damien@@.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.48 2006/08/20 00:33:59 mglocker Exp $ */
d1019 1
a1019 1
		ifp->if_timer = 1;
d1036 1
a1036 2
			acx_stop(ifp->if_softc);
			acx_init(ifp->if_softc);
d1040 1
a1040 1
		ifp->if_timer = 1;
d1158 1
a1158 1
	ifp->if_timer = bd->tx_used_count == 0 ? 0 : 1;
@


1.48
log
@Remove some dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.47 2006/08/19 23:17:12 mglocker Exp $ */
d902 1
d1127 1
d1131 2
d1136 10
@


1.47
log
@Replace existing rate adaption code with the ieee80211_amrr framework.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.46 2006/08/15 21:16:08 mglocker Exp $ */
a1646 1
	//node->nd_txrate = -1;
d2548 1
a2548 1
	DELAY(50);	/* XXX maybe 100 */
@


1.46
log
@Remove DPRINTF from watchdog routine.  To noisy even for debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.45 2006/08/15 16:48:07 mglocker Exp $ */
d126 1
a192 3
void	 acx_node_init(struct acx_softc *, struct acx_node *);
void	 acx_node_update(struct acx_softc *, struct acx_node *,
	     uint8_t, uint8_t);
d201 4
d298 4
d333 1
d345 5
a349 3
	sc->sc_txrate_upd_intvl_min = 10;	/* 10 seconds */
	sc->sc_txrate_upd_intvl_max = 300;	/* 5 minutes */
	sc->sc_txrate_sample_thresh = 30;	/* 30 packets */
a893 1

a896 1
#if 0
d898 2
a899 2
			 * Since mgmt data are transmitted at fixed rate
			 * they will not be used to do rate control.
d901 1
a901 4
			if (ni != NULL)
				ieee80211_free_node(ni);
#endif
			rate = 4;	/* XXX 2Mb/s for mgmt packet */
a903 1
			struct acx_node *node;
d949 6
a954 18
			node = (struct acx_node *)ni;
			if (node->nd_txrate < 0) {
				acx_node_init(sc, node);
#if 0
				if (ic->ic_opmode == IEEE80211_M_IBSS) {
					/* XXX
					 * Add extra reference here,
					 * so that some node (bss_dup)
					 * will not be freed just after
					 * they are allocated, which
					 * make TX rate control impossible
					 */
					ieee80211_ref_node(ni);
				}
#endif
			}

			rate = node->nd_rates.rs_rates[node->nd_txrate];
a1132 1
			acx_node_update(sc, buf->tb_node, buf->tb_rate, error);
d1640 1
a1640 1
	struct acx_node *node;
d1642 2
a1643 2
	node = malloc(sizeof(struct acx_node), M_DEVBUF, M_NOWAIT);
	if (node == NULL)
d1646 2
a1647 2
	bzero(node, (sizeof(struct acx_node)));
	node->nd_txrate = -1;
d1649 1
a1649 154
	return ((struct ieee80211_node *)node);
}

void
acx_node_init(struct acx_softc *sc, struct acx_node *node)
{
	struct ieee80211_rateset *nd_rset, *ic_rset, *cp_rset;
	struct ieee80211com *ic;
	int i, j, c;

	ic = &sc->sc_ic;

	nd_rset = &node->nd_node.ni_rates;
	ic_rset = &ic->ic_sup_rates[sc->chip_phymode];
	cp_rset = &node->nd_rates;
	c = 0;

#define IEEERATE(rate)	((rate) & IEEE80211_RATE_VAL)
	for (i = 0; i < nd_rset->rs_nrates; ++i) {
		uint8_t nd_rate = IEEERATE(nd_rset->rs_rates[i]);

		for (j = 0; j < ic_rset->rs_nrates; ++j) {
			if (nd_rate == IEEERATE(ic_rset->rs_rates[j])) {
				cp_rset->rs_rates[c++] = nd_rate;
				if (node->nd_txrate < 0) {
					/* XXX slow start?? */
					node->nd_txrate = 0;
					node->nd_node.ni_txrate = i;
				}
				break;
			}
		}
	}
	if (node->nd_node.ni_txrate < 0)
		panic("no compat rates");
	DPRINTF(("%s: node rate %d\n",
	    sc->sc_dev.dv_xname,
	    IEEERATE(nd_rset->rs_rates[node->nd_node.ni_txrate])));
#undef IEEERATE

	cp_rset->rs_nrates = c;

	node->nd_txrate_upd_intvl = sc->sc_txrate_upd_intvl_min;
	node->nd_txrate_upd_time = time_second;
	node->nd_txrate_sample = 0;
}

void
acx_node_update(struct acx_softc *sc, struct acx_node *node, uint8_t rate,
    uint8_t error)
{
	struct ieee80211_rateset *nd_rset, *cp_rset;
	int i, time_diff;

	nd_rset = &node->nd_node.ni_rates;
	cp_rset = &node->nd_rates;

	time_diff = time_second - node->nd_txrate_upd_time;

	if (error == DESC_ERR_MSDU_TIMEOUT ||
	    error == DESC_ERR_EXCESSIVE_RETRY) {
		uint8_t cur_rate;

		/* Reset packet sample counter */
		node->nd_txrate_sample = 0;

		if (rate > cp_rset->rs_rates[node->nd_txrate]) {
			/*
			 * This rate has already caused troubles,
			 * so don't count it in here.
			 */
			return;
		}

		/* Double TX rate updating interval */
		node->nd_txrate_upd_intvl *= 2;
		if (node->nd_txrate_upd_intvl <=
		    sc->sc_txrate_upd_intvl_min) {
			node->nd_txrate_upd_intvl =
				sc->sc_txrate_upd_intvl_min;
		} else if (node->nd_txrate_upd_intvl >
			   sc->sc_txrate_upd_intvl_max) {
			node->nd_txrate_upd_intvl =
				sc->sc_txrate_upd_intvl_max;
		}

		if (node->nd_txrate == 0)
			return;

		node->nd_txrate_upd_time += time_diff;

		/* TX rate down */
		node->nd_txrate--;
		cur_rate = cp_rset->rs_rates[node->nd_txrate + 1];
		while (cp_rset->rs_rates[node->nd_txrate] > cur_rate) {
			if (node->nd_txrate - 1 > 0)
				node->nd_txrate--;
			else
				break;
		}
		DPRINTF(("%s: rate down %s %d -> %d\n",
		    sc->sc_dev.dv_xname,
		    ether_sprintf(node->nd_node.ni_macaddr),
		    cp_rset->rs_rates[node->nd_txrate + 1],
		    cp_rset->rs_rates[node->nd_txrate]));
	} else if (node->nd_txrate + 1 < node->nd_rates.rs_nrates) {
		uint8_t cur_rate;

		node->nd_txrate_sample++;

		if (node->nd_txrate_sample <= sc->sc_txrate_sample_thresh ||
		    time_diff <= node->nd_txrate_upd_intvl)
			return;

		/* Reset packet sample counter */
		node->nd_txrate_sample = 0;

		/* Half TX rate updating interval */
		node->nd_txrate_upd_intvl /= 2;
		if (node->nd_txrate_upd_intvl < sc->sc_txrate_upd_intvl_min) {
			node->nd_txrate_upd_intvl = sc->sc_txrate_upd_intvl_min;
		} else if (node->nd_txrate_upd_intvl >
		    sc->sc_txrate_upd_intvl_max) {
			node->nd_txrate_upd_intvl = sc->sc_txrate_upd_intvl_max;
		}

		node->nd_txrate_upd_time += time_diff;

		/* TX Rate up */
		node->nd_txrate++;
		cur_rate = cp_rset->rs_rates[node->nd_txrate - 1];
		while (cp_rset->rs_rates[node->nd_txrate] < cur_rate) {
			if (node->nd_txrate + 1 < cp_rset->rs_nrates)
				node->nd_txrate++;
			else
				break;
		}
		DPRINTF(("%s: rate up %s %d -> %d\n",
		    sc->sc_dev.dv_xname,
		    ether_sprintf(node->nd_node.ni_macaddr),
		    cur_rate, cp_rset->rs_rates[node->nd_txrate]));
	} else
		return;

#define IEEERATE(rate)	((rate) & IEEE80211_RATE_VAL)
	/* XXX Update ieee80211_node's TX rate index */
	for (i = 0; i < nd_rset->rs_nrates; ++i) {
		if (IEEERATE(nd_rset->rs_rates[i]) ==
		    cp_rset->rs_rates[node->nd_txrate]) {
			node->nd_node.ni_txrate = i;
			break;
		}
	}
#undef IEEERATE
d1659 2
d1767 8
d2617 38
@


1.45
log
@Remove obsolete macros.

Pointed out by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.44 2006/08/15 15:43:34 deraadt Exp $ */
a1034 2

	DPRINTF(("%s: watchdog\n", ifp->if_xname));
@


1.44
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.43 2006/08/15 15:06:14 mglocker Exp $ */
a138 16
#define ACX_ENABLE_TXCHAN(sc, chan, ifname)				\
do {									\
	if (acx_enable_txchan((sc), (chan)) != 0) {			\
		DPRINTF(("%s: enable TX on channel %d failed\n",	\
		    (ifname), (chan)));					\
	}								\
} while (0)

#define ACX_ENABLE_RXCHAN(sc, chan, ifname)				\
do {									\
	if (acx_enable_rxchan((sc), (chan)) != 0) {			\
		DPRINTF(("%s: enable RX on channel %d failed\n",	\
		    (ifname), (chan)));					\
	}								\
} while (0)

d1831 9
a1839 2
			ACX_ENABLE_TXCHAN(sc, chan, ifp->if_xname);
			ACX_ENABLE_RXCHAN(sc, chan, ifp->if_xname);
@


1.43
log
@Some KNF and comment cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.42 2006/08/15 12:06:13 mglocker Exp $ */
d21 1
a21 1
 * 
d24 1
a24 1
 * 
d28 1
a28 1
 * 
d38 1
a38 1
 * 
d56 1
a56 1
 * 
d60 1
a60 1
 * 
d63 1
a63 1
 * 
d67 1
a67 1
 *    
d70 1
a70 1
 * 
d72 1
a72 1
 * 
d76 1
a76 1
 * 
d115 1
a115 1
#endif 
d198 1
a198 1
const char * 	acx_get_rf(int);
d415 1
a415 1
	
d623 1
a623 1
	
d687 2
a688 2
	    	error = acx_read_phyreg(sc, ACXRV_PHYREG_SENSITIVITY, &sen);
	    	if (error) {
d1613 1
a1613 1
	
d2005 1
a2005 1
	    0, &rd->rx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);	
d2045 1
a2045 1
	    0, &rd->tx_ring_seg, 1, &nsegs, BUS_DMA_NOWAIT);	
d2303 1
a2303 1
				     
d2323 1
a2323 1
		
d2343 1
a2343 1
		
@


1.42
log
@Improve watchdog handler.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.41 2006/08/14 23:13:28 mglocker Exp $ */
d1191 1
a1191 1
		 * so print it using DPRINTF()
d1264 1
a1264 1
	 * start from last stopped position
d1285 1
a1285 1
	 * be used in the following code
d1386 1
a1386 1
	 * time we can start from it
d1745 2
a1746 2
			 * This rate has already caused toubles,
			 * so don't count it in here
d1796 2
a1797 4
		if (node->nd_txrate_upd_intvl <
		    sc->sc_txrate_upd_intvl_min) {
			node->nd_txrate_upd_intvl =
				sc->sc_txrate_upd_intvl_min;
d1799 2
a1800 3
			   sc->sc_txrate_upd_intvl_max) {
			node->nd_txrate_upd_intvl =
				sc->sc_txrate_upd_intvl_max;
d2025 1
d2064 1
d2076 1
a2518 1
/* XXX C&P of acx_set_probe_resp_tmplt() */
d2690 1
a2690 1
		 uint16_t param_len, void *result, uint16_t result_len)
d2717 1
a2717 1
		/* XXX radio initialization is extremely long */
@


1.41
log
@Fix bogus scanning mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.40 2006/08/14 06:53:26 jsg Exp $ */
d1043 2
a1044 1
		ifp->if_timer = 5;
d1050 19
a1068 2
	printf("%s: watchdog timeout\n", ifp->if_xname);
	acx_txeof(ifp->if_softc);
d1070 1
a1070 1
	/* TODO */
d1173 2
a1174 1
	ifp->if_timer = bd->tx_used_count == 0 ? 0 : 5;
@


1.40
log
@Turn off debug messages by default.
Reminded by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.39 2006/08/13 01:34:20 mglocker Exp $ */
d1825 3
a1827 2
	case IEEE80211_S_SCAN:
		if (ic->ic_state != IEEE80211_S_INIT) {
@


1.39
log
@Enable hostap mode.  Tested with acx100 and acx111.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.38 2006/08/12 10:33:18 mglocker Exp $ */
a131 2
#define ACX_DEBUG

d136 1
a136 1
int acxdebug = 1;
@


1.38
log
@KNF tweak.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.37 2006/08/12 10:30:15 mglocker Exp $ */
d329 1
d1871 2
a1872 1
		if (ic->ic_opmode == IEEE80211_M_IBSS) {
d1907 12
a1918 3
			if (acx_join_bss(sc, ACX_MODE_ADHOC, ni) != 0) {
				printf("%s: join IBSS failed\n", ifp->if_xname);
				goto back;
@


1.37
log
@Fill ic_max_rssi with values depending on the radio type.  Makes signal
strength in percentage work.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.36 2006/08/08 10:49:16 jsg Exp $ */
d200 1
a200 1
const char * 	acx_get_rf(int rev);
@


1.36
log
@A more flexible method for deciding what firmware filenames to load.
ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.35 2006/08/08 09:02:48 mglocker Exp $ */
d201 1
d349 3
d1334 1
a1334 1
				tap->wr_max_rssi = 0; /* XXX */
d2740 12
@


1.35
log
@Don't yell about failed channel enabling in none-debug mode, because we
use a static number of channels.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.34 2006/08/08 05:18:53 jsg Exp $ */
d402 2
a403 1
	int error;
d427 15
a441 3
	error = acx_load_base_firmware(sc, (sc->sc_flags & ACX_FLAG_ACX111) ?
	    "tiacx111c16" : "tiacx100");
	
d454 6
a459 4
	/* ACX111 firmware is combined */
	if (!(sc->sc_flags & ACX_FLAG_ACX111)) {
		error = acx_load_radio_firmware(sc,
		    sc->sc_radio_type == 0x11 ? "tiacx100r11" : "tiacx100r0D");
@


1.34
log
@Mention which MAC we are using (ACX100 or ACX111) and fix
newline in cardbus attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.33 2006/08/08 05:03:51 jsg Exp $ */
d144 2
a145 2
		printf("%s: enable TX on channel %d failed\n",		\
		    (ifname), (chan));					\
d152 2
a153 2
		printf("%s: enable RX on channel %d failed\n",		\
		    (ifname), (chan));					\
d2696 1
a2696 1
		printf("%s: cmd %04x failed\n", sc->sc_dev.dv_xname, cmd);
@


1.33
log
@Print a string for radio type.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.32 2006/08/07 21:17:39 mglocker Exp $ */
d282 3
a284 2
	printf(", radio %s (0x%02x)", acx_get_rf(sc->sc_radio_type),
	    sc->sc_radio_type);
d303 1
a303 1
	printf(", version %u", sc->sc_eeprom_ver);
@


1.32
log
@Make radio type 0x11 work.  Radio firmware needs longer to initialize
for those types.  Increase tsleep() from 150ms to 300ms.

Tested by Marc Winiger <mw@@msys.ch> with 0x11 ACX100 CardBus & ACX100 PCI.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.31 2006/08/07 11:06:50 jsg Exp $ */
d200 1
d282 2
a283 1
	printf(", radio 0x%02x", sc->sc_radio_type);
d2709 12
@


1.31
log
@Remove some unused/uneeded code.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.30 2006/08/07 10:46:12 mglocker Exp $ */
d2668 1
a2668 1
		tsleep(&cmd, 0, "rdinit", (150 * hz) / 1000);	/* 150ms */
@


1.30
log
@Enable WEP.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.29 2006/08/07 00:23:20 mglocker Exp $ */
a437 8
#if 0
	if (sc->chip_post_basefw != NULL) {
		error = sc->chip_post_basefw(sc);
		if (error)
			goto back;
	}
#endif

a459 1
//		sc->sc_ic.ic_flags &= ~IEEE80211_F_DROPUNENC;
@


1.29
log
@Radio type is in hex not decimal.  Therefore decide correctly which
radio firmware to load.

Spotted by Marc Winiger <mw@@msys.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.28 2006/08/06 14:23:05 damien Exp $ */
a498 1
#if 0
d504 1
a504 1
		struct ieee80211_key *wk = &ic->ic_nw_keys[i];
d506 1
a506 1
		if (wk->wk_keylen == 0)
d512 1
a512 1
				return error;
a513 2
		} else if (wk->wk_flags & IEEE80211_KEY_XMIT) {
			wk->wk_flags |= IEEE80211_KEY_SWCRYPT;
d517 2
a518 3
	if (!got_wk || sc->chip_hw_crypt ||
	    ic->ic_def_txkey == IEEE80211_KEYIX_NONE)
		return 0;
d521 1
a521 1
	wep_txkey.wep_txkey = ic->ic_def_txkey;
d523 2
a524 3
		printf("%s: set WEP txkey failed\n",
		    sc->sc_dev.dv_xname);
		return ENXIO;
d526 2
a527 3
	return 0;
#endif
	return (ENXIO);
@


1.28
log
@remove a dragonflybsd'ism
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.27 2006/08/06 14:22:11 damien Exp $ */
d281 1
a281 1
	printf(", radio %02x", sc->sc_radio_type);
d448 2
a449 2
		error = acx_load_radio_firmware(sc, (sc->sc_radio_type == 11) ?
		    "tiacx100r11" : "tiacx100r0D");
@


1.27
log
@more s/f/wh/ that I forgot in rev 1.25
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.26 2006/08/06 14:06:41 damien Exp $ */
a1951 8

#if 0
void
acx_ring_dma_addr(void *arg, bus_dma_segment_t *seg, int nseg, int error)
{
	*((uint32_t *)arg) = seg->ds_addr;
}
#endif
@


1.26
log
@fix a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.25 2006/08/06 14:04:19 damien Exp $ */
d224 1
a224 1
static int	acx_chanscan_rate = 5;	/* 5 channels per seconds */
d888 1
a888 1
		struct ieee80211_frame *f;
d977 2
a978 2
		f = mtod(m, struct ieee80211_frame *);
		if ((f->i_fc[1] & IEEE80211_FC1_WEP) && !sc->chip_hw_crypt) {
d1294 1
a1294 1
			struct ieee80211_frame *f;
d1299 1
a1299 1
			f = mtod(m, struct ieee80211_frame *);
d1301 1
a1301 1
			if ((f->i_fc[1] & IEEE80211_FC1_WEP) &&
d1304 1
a1304 1
				f->i_fc[1] &= ~IEEE80211_FC1_WEP;
d1309 1
a1309 1
					f = mtod(m, struct ieee80211_frame *);
d1338 1
a1338 1
			ni = ieee80211_find_rxnode(ic, f);
d2338 1
a2338 1
	 * It is quite strange that acx also querys acx_host_desc next to
@


1.25
log
@use the same naming conventions than net80211.
set IEEE80211_FC0_VERSION_0 and IEEE80211_FC1_DIR_NODS instead of
blindly assuming these constants are zero.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.24 2006/08/06 13:03:03 mglocker Exp $ */
d224 1
a224 1
static int	acx_chanscan_rate = 5;	/* 5 seconds */
@


1.24
log
@Add bpf hooks.  Based on slightly modified diff from jsg.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.23 2006/08/05 17:22:46 damien Exp $ */
d2400 1
a2400 1
	struct ieee80211_frame *f;
d2405 7
a2411 5
	f = &n.data;
	f->i_fc[0] = IEEE80211_FC0_SUBTYPE_NODATA | IEEE80211_FC0_TYPE_DATA;
	IEEE80211_ADDR_COPY(f->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(f->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(f->i_addr3, etherbroadcastaddr);
d2420 1
a2420 1
	struct ieee80211_frame *f;
d2422 2
a2423 2
	uint8_t *v;
	int vlen;
d2427 14
a2440 11
	f = &req.data.u_data.f;
	f->i_fc[0] = IEEE80211_FC0_SUBTYPE_PROBE_REQ | IEEE80211_FC0_TYPE_MGT;
	IEEE80211_ADDR_COPY(f->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(f->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(f->i_addr3, etherbroadcastaddr);

	v = req.data.u_data.var;
	v = ieee80211_add_ssid(v, ssid, ssid_len);
	v = ieee80211_add_rates(v, &ic->ic_sup_rates[sc->chip_phymode]);
	v = ieee80211_add_xrates(v, &ic->ic_sup_rates[sc->chip_phymode]);
	vlen = v - req.data.u_data.var;
d2443 1
a2443 1
	    ACX_TMPLT_PROBE_REQ_SIZ(vlen)));
d2451 1
a2451 1
	struct ieee80211_frame *f;
d2453 2
a2454 2
	uint8_t *v;
	int vlen;
d2458 7
a2464 5
	f = &resp.data.u_data.f;
	f->i_fc[0] = IEEE80211_FC0_SUBTYPE_PROBE_RESP | IEEE80211_FC0_TYPE_MGT;
	IEEE80211_ADDR_COPY(f->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(f->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(f->i_addr3, ic->ic_myaddr);
d2469 7
a2475 7
	v = resp.data.u_data.var;
	v = ieee80211_add_ssid(v, ssid, ssid_len);
	v = ieee80211_add_rates(v, &ic->ic_sup_rates[sc->chip_phymode]);

	*v++ = IEEE80211_ELEMID_DSPARMS;
	*v++ = 1;
	*v++ = chan;
d2478 1
a2478 1
	v = ieee80211_add_xrates(v, &ic->ic_sup_rates[sc->chip_phymode]);
d2481 2
a2482 2
		*v++ = IEEE80211_ELEMID_IBSSPARMS;
		*v++ = 2;
d2485 1
a2485 1
	vlen = v - resp.data.u_data.var;
d2488 1
a2488 1
	    ACX_TMPLT_PROBE_RESP_SIZ(vlen)));
d2497 1
a2497 1
	struct ieee80211_frame *f;
d2499 2
a2500 2
	uint8_t *v;
	int vlen;
d2504 7
a2510 5
	f = &beacon.data.u_data.f;
	f->i_fc[0] = IEEE80211_FC0_SUBTYPE_BEACON | IEEE80211_FC0_TYPE_MGT;
	IEEE80211_ADDR_COPY(f->i_addr1, etherbroadcastaddr);
	IEEE80211_ADDR_COPY(f->i_addr2, ic->ic_myaddr);
	IEEE80211_ADDR_COPY(f->i_addr3, ic->ic_myaddr);
d2515 7
a2521 7
	v = beacon.data.u_data.var;
	v = ieee80211_add_ssid(v, ssid, ssid_len);
	v = ieee80211_add_rates(v, &ic->ic_sup_rates[sc->chip_phymode]);

	*v++ = IEEE80211_ELEMID_DSPARMS;
	*v++ = 1;
	*v++ = chan;
d2524 1
a2524 1
	v = ieee80211_add_xrates(v, &ic->ic_sup_rates[sc->chip_phymode]);
d2527 2
a2528 2
		*v++ = IEEE80211_ELEMID_IBSSPARMS;
		*v++ = 2;
d2531 1
a2531 1
	vlen = v - beacon.data.u_data.var;
d2533 1
a2533 1
	return (_acx_set_beacon_tmplt(sc, &beacon, ACX_TMPLT_BEACON_SIZ(vlen)));
@


1.23
log
@don't set ifp->if_xname twice.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.22 2006/08/05 13:06:50 mglocker Exp $ */
d355 13
d941 5
d951 5
d988 21
d1315 22
@


1.22
log
@Adjust copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.21 2006/08/05 12:59:53 jsg Exp $ */
a245 1
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
@


1.21
log
@If ieee80211_encap() returns NULL the node is already free,
do not try to free it again.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.20 2006/08/05 11:34:11 jsg Exp $ */
a4 1
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
@


1.20
log
@Be sure to call if_detach() so ghosts of hardware
don't come back to haunt us.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.19 2006/08/05 09:07:35 damien Exp $ */
d930 1
a930 3
			m = ieee80211_encap(ifp, m, &ni);
			if (m == NULL) {
				ieee80211_release_node(ic, ni);
@


1.19
log
@nuke latest remaining firmware ioctl bits.
ok jsg@@

s/le32toh/letoh32/g and remove __offsetof definition while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.18 2006/08/05 00:29:41 mglocker Exp $ */
d369 1
@


1.18
log
@Replace one more dragonfly quirk by ether_sprintf().  Fixes debug output
for AP rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.17 2006/08/05 00:22:49 mglocker Exp $ */
a201 4
#if 0
int	acx_copyin_firmware(struct acx_softc *, struct ifreq *);
#endif
void	 acx_free_firmware(struct acx_softc *);
a367 2
	acx_free_firmware(sc);

a1391 72
}

#if 0
int
acx_copyin_firmware(struct acx_softc *sc, struct ifreq *req)
{
	struct acx_firmware ufw, *kfw;
	uint8_t *base_fw, *radio_fw;
	int error;

	kfw = &sc->sc_firmware;
	base_fw = NULL;
	radio_fw = NULL;

	error = copyin(req->ifr_data, &ufw, sizeof(ufw));
	if (error)
		return error;

	/*
	 * For combined base firmware, there is no radio firmware.
	 * But base firmware must exist.
	 */
	if (ufw.base_fw_len <= 0 || ufw.radio_fw_len < 0)
		return EINVAL;

	base_fw = malloc(ufw.base_fw_len, M_DEVBUF, M_INTWAIT);
	error = copyin(ufw.base_fw, base_fw, ufw.base_fw_len);
	if (error)
		goto fail;

	if (ufw.radio_fw_len > 0) {
		radio_fw = malloc(ufw.radio_fw_len, M_DEVBUF, M_INTWAIT);
		error = copyin(ufw.radio_fw, radio_fw, ufw.radio_fw_len);
		if (error)
			goto fail;
	}

	kfw->base_fw_len = ufw.base_fw_len;
	if (kfw->base_fw != NULL)
		free(kfw->base_fw, M_DEVBUF);
	kfw->base_fw = base_fw;

	kfw->radio_fw_len = ufw.radio_fw_len;
	if (kfw->radio_fw != NULL)
		free(kfw->radio_fw, M_DEVBUF);
	kfw->radio_fw = radio_fw;

	return 0;
fail:
	if (base_fw != NULL)
		free(base_fw, M_DEVBUF);
	if (radio_fw != NULL)
		free(radio_fw, M_DEVBUF);
	return error;
}
#endif

void
acx_free_firmware(struct acx_softc *sc)
{
	struct acx_firmware *fw = &sc->sc_firmware;

	if (fw->base_fw != NULL) {
		free(fw->base_fw, M_DEVBUF);
		fw->base_fw = NULL;
		fw->base_fw_len = 0;
	}
	if (fw->radio_fw != NULL) {
		free(fw->radio_fw, M_DEVBUF);
		fw->radio_fw = NULL;
		fw->radio_fw_len = 0;
	}
@


1.17
log
@Replace dragonfly quirk by ether_sprintf().  Fixes debug output for
rate up / rate down.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.16 2006/08/05 00:04:37 mglocker Exp $ */
d1873 1
a1873 1
			printf(" %6D\n", ni->ni_bssid, ":");
@


1.16
log
@Slight KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.15 2006/08/04 22:51:19 mglocker Exp $ */
d1767 1
a1767 1
		DPRINTF(("%s: rate down %6D %d -> %d\n",
d1769 1
a1769 1
		    node->nd_node.ni_macaddr, ":",
d1807 1
a1807 1
		DPRINTF(("%s: rate up %6D %d -> %d\n",
d1809 1
a1809 1
		    node->nd_node.ni_macaddr, ":",
@


1.15
log
@Fix comment typo, spotted by jasper@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.14 2006/08/04 22:24:46 mglocker Exp $ */
d158 40
a197 40
int	acx_attach(struct acx_softc *);
int	acx_detach(void *);
void	acx_shutdown(void *);

int	acx_init(struct ifnet *);
int	acx_stop(struct acx_softc *);
void	acx_init_info_reg(struct acx_softc *);
int	acx_config(struct acx_softc *);
int	acx_read_config(struct acx_softc *, struct acx_config *);
int	acx_write_config(struct acx_softc *, struct acx_config *);
int	acx_set_crypt_keys(struct acx_softc *);
void	acx_next_scan(void *);

void	acx_start(struct ifnet *);
void	acx_watchdog(struct ifnet *);

int	acx_ioctl(struct ifnet *, u_long, caddr_t);

int	acx_intr(void *);
void	acx_disable_intr(struct acx_softc *);
void	acx_enable_intr(struct acx_softc *);
void	acx_txeof(struct acx_softc *);
void	acx_txerr(struct acx_softc *, uint8_t);
void	acx_rxeof(struct acx_softc *);

int	acx_dma_alloc(struct acx_softc *);
void	acx_dma_free(struct acx_softc *);
int	acx_init_tx_ring(struct acx_softc *);
int	acx_init_rx_ring(struct acx_softc *);
int	acx_newbuf(struct acx_softc *, struct acx_rxbuf *, int);
int	acx_encap(struct acx_softc *, struct acx_txbuf *,
			  struct mbuf *, struct ieee80211_node *, int);

int	acx_reset(struct acx_softc *);

int	acx_set_null_tmplt(struct acx_softc *);
int	acx_set_probe_req_tmplt(struct acx_softc *, const char *, int);
int	acx_set_probe_resp_tmplt(struct acx_softc *, const char *, int,
					 int);
int	acx_set_beacon_tmplt(struct acx_softc *, const char *, int, int);
d199 2
a200 2
int	acx_read_eeprom(struct acx_softc *, uint32_t, uint8_t *);
int	acx_read_phyreg(struct acx_softc *, uint32_t, uint8_t *);
d205 18
a222 17
void	acx_free_firmware(struct acx_softc *);
int	acx_load_firmware(struct acx_softc *, uint32_t,
				  const uint8_t *, int);
int	acx_load_radio_firmware(struct acx_softc *, const char *);
int	acx_load_base_firmware(struct acx_softc *, const char *);

struct ieee80211_node *acx_node_alloc(struct ieee80211com *);
void	acx_node_init(struct acx_softc *, struct acx_node *);
void	acx_node_update(struct acx_softc *, struct acx_node *,
				uint8_t, uint8_t);
int	acx_newstate(struct ieee80211com *, enum ieee80211_state, int);

void	acx_init_cmd_reg(struct acx_softc *);
int	acx_join_bss(struct acx_softc *, uint8_t, struct ieee80211_node *);
int	acx_enable_txchan(struct acx_softc *, uint8_t);
int	acx_enable_rxchan(struct acx_softc *, uint8_t);
int	acx_init_radio(struct acx_softc *, uint32_t, uint32_t);
d229 1
a229 1
static int	acx_chanscan_rate = 5;	/* 5/second */
a284 1

d319 1
a319 1
			ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
d330 2
a331 2
		       IEEE80211_C_IBSS |	/* IBSS modes */
		       IEEE80211_C_SHPREAMBLE;	/* Short preamble */
d377 1
d397 1
a397 1
		return EIO;
d479 1
d527 1
a527 1
	return ENXIO;
d556 1
a556 1
		return error;
d577 1
a577 2
			bus_dmamap_unload(sc->sc_dmat,
					  buf->tb_mbuf_dmamap);
d595 1
a595 1
					  bd->rx_buf[i].rb_mbuf_dmamap);
d612 1
a612 1
	return 0;
d623 1
a623 1
		return error;
d627 1
a627 1
		return error;
d632 1
a632 1
		return ENXIO;
d639 1
a639 1
		return ENXIO;
d641 2
a642 1
	return 0;
d658 1
a658 1
		return ENXIO;
d666 1
a666 1
		return ENXIO;
d679 1
a679 1
			return error;
d681 1
a681 1
	} else {
a682 1
	}
d689 1
a689 1
		return ENXIO;
d694 1
a694 1
			  sc->sc_dev.dv_xname, fw_rev.fw_rev);
d710 1
a710 1
		 sc->sc_dev.dv_xname, sc->sc_firmware_ver, sc->sc_hardware_id));
d715 1
a715 1
			return error;
d717 2
a718 1
	return 0;
d738 1
a738 1
		return ENXIO;
d744 1
a744 1
		return ENXIO;
d751 1
a751 1
		return ENXIO;
d758 1
a758 1
		return ENXIO;
d765 1
a765 1
		return ENXIO;
d772 1
a772 1
		return ENXIO;
d778 1
a778 1
			return error;
d785 9
a793 9
		      RXOPT2_RECV_AUTH |
		      RXOPT2_RECV_BEACON |
		      RXOPT2_RECV_CF |
		      RXOPT2_RECV_CTRL |
		      RXOPT2_RECV_DATA |
		      RXOPT2_RECV_MGMT |
		      RXOPT2_RECV_PROBE_REQ |
		      RXOPT2_RECV_PROBE_RESP |
		      RXOPT2_RECV_OTHER;
d796 1
a796 1
		return ENXIO;
d798 2
a799 1
	return 0;
d855 1
a855 1
	return error;
d960 1
a960 1
		} else {
a961 1
		}
a991 1

d1010 1
d1021 1
a1021 1
		return 0;
d1026 1
a1026 1
		return 0;
d1032 1
a1032 1
		return 1;
d1044 1
a1044 1
	return 1;
d1091 1
a1091 1
		} else {
a1092 1
		}
d1135 1
a1135 1
	} else {
a1136 1
	}
d1200 1
a1200 1
			rd->rx_ring_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
a1226 1

d1244 1
a1244 1
			buf->rb_mbuf_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1263 1
a1263 1
				 sc->chip_rxbuf_exhdr);
d1284 1
a1284 1
					letoh32(head->rbh_time));
d1331 1
a1331 1
		return ENXIO;
d1333 2
a1334 1
	return 0;
d1383 1
a1383 1
		return ETIMEDOUT;
d1388 2
a1389 1
	return 0;
d1485 1
a1485 1
		return EIO;
d1509 1
a1509 1
			return 0;
d1515 2
a1516 1
	return ENXIO;
d1572 1
a1572 1
		return ENXIO;
d1582 1
a1582 1
		  int data_len)
d1589 1
a1589 1
	for (i = 4; i < data_len; i++) {
a1590 1
	}
d1597 1
a1597 1
		return ENXIO;
d1648 1
a1648 1
			return ENXIO;
d1651 2
a1652 1
	return 0;
d1662 1
a1662 1
		return NULL;
d1666 2
a1667 1
	return (struct ieee80211_node *)node;
d1716 1
a1716 1
		uint8_t error)
d1811 1
a1811 1
	} else {
a1812 1
	}
d1843 1
a1843 1
				      hz / acx_chanscan_rate);
d1900 1
a1900 1
						 ni->ni_esslen, chan) != 0) {
d1907 1
a1907 2
						     ni->ni_esslen,
						     chan) != 0) {
d1932 2
a1933 1
	return sc->sc_newstate(ic, nstate, arg);
d1950 1
a1950 1
		return 1;
d1953 1
a1953 1
		return 1;
d1956 1
a1956 1
		return 1;
d1959 1
a1959 1
		return 1;
d1962 1
a1962 2
		return 1;

d1965 1
a1965 1
	return 0;
d1991 1
a1991 1
		return error;
d2000 1
a2000 1
		return error;
d2010 1
a2010 1
		return error;
d2014 1
a2014 2
				rd->rx_ring, ACX_RX_RING_SIZE,
				NULL, BUS_DMA_WAITOK);
d2019 1
a2019 1
		return error;
d2030 1
a2030 1
		return error;
a2032 1
	
d2037 3
a2039 2
		printf("%s: can't allocate tx ring dma memory\n", ifp->if_xname);
		return error;
d2043 1
a2043 2
	    ACX_TX_RING_SIZE, (caddr_t *)&rd->tx_ring,
	    BUS_DMA_NOWAIT);
d2048 1
a2048 1
		return error;
d2052 1
a2052 2
				rd->tx_ring, ACX_TX_RING_SIZE,
				NULL, BUS_DMA_WAITOK);
d2056 1
a2056 1
		return error;
d2066 1
a2066 1
		return error;
d2076 1
a2076 1
			return error;
d2088 1
a2088 1
			return error;
d2094 1
a2094 1
	return 0;
d2118 1
a2118 1
						  bd->rx_buf[i].rb_mbuf_dmamap);
d2122 1
a2122 1
					   bd->rx_buf[i].rb_mbuf_dmamap);
d2130 1
a2130 1
						  bd->tx_buf[i].tb_mbuf_dmamap);
d2134 1
a2134 1
					   bd->tx_buf[i].tb_mbuf_dmamap);
d2138 1
a2138 1
	if (bd->mbuf_tmp_dmamap != NULL) {
a2139 1
	}
d2165 1
a2165 1
			rd->tx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d2172 1
a2172 1
	return 0;
d2195 1
a2195 1
			return error;
d2204 1
a2204 1
			rd->rx_ring_dmamap->dm_mapsize, BUS_DMASYNC_PREWRITE);
d2207 2
a2208 1
	return 0;
d2234 2
a2235 3
	error = bus_dmamap_load_mbuf(sc->sc_dmat, bd->mbuf_tmp_dmamap,
				     m,
				     wait ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT);
d2238 3
a2240 3
		printf("%s: can't map rx mbuf %d\n", sc->sc_dev.dv_xname,
		    error);
		return error;
d2257 1
a2257 1
			rb->rb_mbuf_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
d2259 1
a2259 1
	return 0;
d2264 1
a2264 1
	  struct ieee80211_node *ni, int rate)
d2275 1
d2288 2
a2289 2
	error = bus_dmamap_load_mbuf(sc->sc_dmat, txbuf->tb_mbuf_dmamap,
				     m, BUS_DMA_NOWAIT);
d2292 2
a2293 2
		printf("%s: can't map tx mbuf1 %d\n", sc->sc_dev.dv_xname,
		    error);
d2302 1
d2332 1
a2332 2
					     txbuf->tb_mbuf_dmamap, m,
					     BUS_DMA_NOWAIT);
a2367 1

d2373 2
a2374 2
		htole16(sc->chip_txdesc1_len ? sc->chip_txdesc1_len
					     : m->m_pkthdr.len);
d2376 1
a2376 1
		htole16(m->m_pkthdr.len - ACX_FRAME_HDRLEN);
d2407 2
a2408 1
	return error;
d2426 1
a2426 1
	return _acx_set_null_data_tmplt(sc, &n, sizeof(n));
d2452 2
a2453 2
	return _acx_set_probe_req_tmplt(sc, &req,
					ACX_TMPLT_PROBE_REQ_SIZ(vlen));
d2458 1
a2458 1
			 int chan)
d2495 2
a2496 2
	return _acx_set_probe_resp_tmplt(sc, &resp,
					 ACX_TMPLT_PROBE_RESP_SIZ(vlen));
d2502 1
a2502 1
		     int chan)
d2539 1
a2539 1
	return _acx_set_beacon_tmplt(sc, &beacon, ACX_TMPLT_BEACON_SIZ(vlen));
d2580 2
a2581 2
	return acx_exec_command(sc, ACXCMD_JOIN_BSS,
				bj, BSS_JOIN_PARAM_SIZE(bj), NULL, 0);
d2587 2
a2588 2
	return acx_exec_command(sc, ACXCMD_ENABLE_TXCHAN, &chan, sizeof(chan),
				NULL, 0);
d2594 2
a2595 2
	return acx_exec_command(sc, ACXCMD_ENABLE_RXCHAN, &chan, sizeof(chan),
				NULL, 0);
d2600 1
a2600 1
	     uint16_t conf_len)
d2606 2
a2607 2
		sc->sc_dev.dv_xname, __func__);
		return 1;
d2614 2
a2615 2
	return acx_exec_command(sc, ACXCMD_GET_CONF, confcom, sizeof(*confcom),
				conf, conf_len);
d2620 1
a2620 1
	     uint16_t conf_len)
d2627 1
a2627 1
		return 1;
d2634 1
a2634 1
	return acx_exec_command(sc, ACXCMD_SET_CONF, conf, conf_len, NULL, 0);
d2639 1
a2639 1
	      uint16_t tmplt_len)
d2646 1
a2646 1
		return 1;
d2652 1
a2652 1
	return acx_exec_command(sc, cmd, tmplt, tmplt_len, NULL, 0);
d2662 3
a2664 1
	return acx_exec_command(sc, ACXCMD_INIT_RADIO, &r, sizeof(r), NULL, 0);
d2675 3
a2677 3
		printf("%s: cmd 0x%04x failed (base firmware "
		    "not loaded)", sc->sc_dev.dv_xname, cmd);
		return 1;
d2734 2
a2735 1
	return ret;
@


1.14
log
@Make driver more silent when ACX_DEBUG is off.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.13 2006/08/04 17:49:42 damien Exp $ */
d253 1
a253 1
	/* Initilize channel scanning timer */
@


1.13
log
@use ic->ic_myaddr instead of LLADDR(ifp->if_sadl) to build management
frames headers, just like net80211 does.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.12 2006/08/04 12:24:46 jsg Exp $ */
d142 1
a142 2

#define ACX_ENABLE_TXCHAN(sc, chan)					\
d145 2
a146 1
		printf("enable TX on channel %d failed\n", (chan));	\
d150 1
a150 1
#define ACX_ENABLE_RXCHAN(sc, chan)					\
d153 2
a154 1
		printf("enable RX on channel %d failed\n", (chan));	\
d904 3
a906 3
				printf("%s: data packet dropped due to "
					  "not RUN.  Current state %d\n",
					  ifp->if_xname, ic->ic_state);
d1837 2
a1838 2
			ACX_ENABLE_TXCHAN(sc, chan);
			ACX_ENABLE_RXCHAN(sc, chan);
@


1.12
log
@Use ACX100 radio 11 firmware for ACX100 radio 11.
ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.11 2006/08/04 11:58:26 jsg Exp $ */
d2417 1
a2417 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d2424 1
a2424 1
	IEEE80211_ADDR_COPY(f->i_addr2, LLADDR(ifp->if_sadl));
d2435 1
a2435 1
	struct ifnet *ifp = &sc->sc_ic.ic_if;
d2444 1
a2444 1
	IEEE80211_ADDR_COPY(f->i_addr2, LLADDR(ifp->if_sadl));
d2449 2
a2450 2
	v = ieee80211_add_rates(v, &sc->sc_ic.ic_sup_rates[sc->chip_phymode]);
	v = ieee80211_add_xrates(v, &sc->sc_ic.ic_sup_rates[sc->chip_phymode]);
a2463 1
	struct ifnet *ifp = &ic->ic_if;
d2472 2
a2473 2
	IEEE80211_ADDR_COPY(f->i_addr2, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(f->i_addr3, LLADDR(ifp->if_sadl));
a2507 1
	struct ifnet *ifp = &ic->ic_if;
d2516 2
a2517 2
	IEEE80211_ADDR_COPY(f->i_addr2, LLADDR(ifp->if_sadl));
	IEEE80211_ADDR_COPY(f->i_addr3, LLADDR(ifp->if_sadl));
@


1.11
log
@Remove code that reads the MAC address via the firmware
and then does nothing with it.  We already have this
via the EEPROM, which seems to work fine so far.

Slightly tweaked version of a diff from deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.10 2006/08/04 10:47:15 jsg Exp $ */
d207 1
a207 1
int	acx_load_radio_firmware(struct acx_softc *);
d440 2
a441 1
		error = acx_load_radio_firmware(sc);
d1517 1
a1517 1
acx_load_radio_firmware(struct acx_softc *sc)
a1523 1
	const char name[] = "tiacx100r0D";
@


1.10
log
@Load ACX111 firmware for ACX111.
ok mglocker@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.9 2006/08/03 22:56:08 deraadt Exp $ */
a643 1
	struct acx_conf_eaddr addr;
d649 1
a649 16
	int i, error;

	/* Get station id */
	if (acx_get_eaddr_conf(sc, &addr) != 0) {
		printf("%s: can't get station id\n", sc->sc_dev.dv_xname);
		return ENXIO;
	}

	/*
	 * Get and print station id in case that EEPROM station id's
	 * offset is not correct
	 */
	for (i = 0; i < IEEE80211_ADDR_LEN; ++i)
		conf->eaddr[IEEE80211_ADDR_LEN - 1 - i] = addr.eaddr[i];
	printf("%s: MAC address (from firmware): %s\n",
	    sc->sc_dev.dv_xname, ether_sprintf(conf->eaddr));
@


1.9
log
@delete some debug code that was put in for early development
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.8 2006/08/03 22:32:06 claudio Exp $ */
d208 1
a208 1
int	acx_load_base_firmware(struct acx_softc *);
d415 3
a417 1
	error = acx_load_base_firmware(sc);
d438 6
a443 4
	/* XXX decide whether firmware is combined */
	error = acx_load_radio_firmware(sc);
	if (error)
		goto back;
d1486 1
a1486 1
acx_load_base_firmware(struct acx_softc *sc)
a1490 1
	const char name[]= "tiacx100";
@


1.8
log
@Fix DMA initialization -- it helps to set the physical address of the buffer.
Additionally fix some obvious bugs and leftovers from dragonfly that cause
panics on OpenBSD. With this we are up and running on a ACX100A card.
Debugged with mglocker@@ via irc as I don't own an acx(4) card.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.7 2006/08/03 20:18:02 claudio Exp $ */
d196 1
a196 2
int	acx_set_beacon_tmplt(struct acx_softc *, const char *, int,
				     int);
d335 1
a335 1
					&ic->ic_myaddr[i]);
a392 2
	printf("A\n");

a400 2
	printf("B");

a407 2
	printf("C");

a414 2
	printf("D");

a418 2
	printf("E\n");

a425 2
	printf("F");

a435 2
	printf("G");

a444 2
	printf("H");

a449 2
	printf("I\n");

a457 2
	printf("J");

a468 2
	printf("L\n");

d661 1
a661 1
		  sc->sc_dev.dv_xname, ether_sprintf(conf->eaddr));
@


1.7
log
@Kill some dead code that we never need. Makes the code readable and me less
confused. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.6 2006/08/03 19:31:25 deraadt Exp $ */
a989 2

			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
a1004 5
#if NBPFILTER > 0
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif

d2057 2
d2096 2
d2193 1
d2229 1
a2247 15
#if 0
void
acx_buf_dma_addr(void *arg, bus_dma_segment_t *seg, int nseg,
		 bus_size_t mapsz, int error)
{
	if (error)
		return;

	/* XXX */
	if (nseg != 1)
		panic("too many RX DMA segments\n");
	*((uint32_t *)arg) = seg->ds_addr;
}
#endif

d2288 1
d2338 1
d2343 2
d2406 1
@


1.6
log
@pretty print radio & address
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.5 2006/08/03 12:00:07 mglocker Exp $ */
a156 3
#if 0
int	acx_probe(device_t);
#endif
a167 3
#ifdef foo
void	acx_begin_scan(struct acx_softc *);
#endif
a216 9
#if 0
int	acx_sysctl_txrate_upd_intvl_min(SYSCTL_HANDLER_ARGS);
int	acx_sysctl_txrate_upd_intvl_max(SYSCTL_HANDLER_ARGS);
int	acx_sysctl_txrate_sample_thresh(SYSCTL_HANDLER_ARGS);
int	acx_sysctl_long_retry_limit(SYSCTL_HANDLER_ARGS);
int	acx_sysctl_short_retry_limit(SYSCTL_HANDLER_ARGS);
int	acx_sysctl_msdu_lifetime(SYSCTL_HANDLER_ARGS);
#endif

a238 27
#if 0
static const struct acx_device {
	uint16_t	vid;
	uint16_t	did;
	void		(*set_param)(struct acx_softc *);
	const char	*desc;
} acx_devices[] = {
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX100A, acx100_set_param,
	  "Texas Instruments TNETW1100A Wireless Adapter" },
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX100B, acx100_set_param,
	  "Texas Instruments TNETW1100B Wireless Adapter" },
	{ PCI_VENDOR_TI, PCI_PRODUCT_TI_ACX111, acx111_set_param,
	  "Texas Instruments TNETW1130 Wireless Adapter" },
	{ 0, 0, NULL, NULL }
};

static device_method_t acx_methods[] = {
	DEVMETHOD(device_probe,		acx_probe),
	DEVMETHOD(device_attach,	acx_attach),
	DEVMETHOD(device_detach,	acx_detach),
	DEVMETHOD(device_shutdown,	acx_shutdown),
	DEVMETHOD(device_suspend,	acx_suspend),
	DEVMETHOD(device_resume,	acx_resume),
	{ 0, 0 }
};
#endif

a242 30
#if 0
static driver_t acx_driver = {
	"acx",
	acx_methods,
	sizeof(struct acx_softc)
};

static devclass_t acx_devclass;
#endif

#if 0
int
acx_probe(device_t dev)
{
	const struct acx_device *a;
	uint16_t did, vid;

	vid = pci_get_vendor(dev);
	did = pci_get_device(dev);
	for (a = acx_devices; a->desc != NULL; ++a) {
		if (vid == a->vid && did == a->did) {
			a->set_param(dev);
			device_set_desc(dev, a->desc);
			return 0;
		}
	}
	return ENXIO;
}
#endif

a249 3
	//acx111_set_param(sc);
	//acx100_set_param(sc);

a252 60
#if 0
#ifndef BURN_BRIDGES
	if (pci_get_powerstate(dev) != PCI_POWERSTATE_D0) {
		uint32_t mem1, mem2, irq;

		mem1 = pci_read_config(dev, sc->chip_mem1_rid, 4);
		mem2 = pci_read_config(dev, sc->chip_mem2_rid, 4);
		irq = pci_read_config(dev, PCIR_INTLINE, 4);

		device_printf(dev, "chip is in D%d power mode "
		    "-- setting to D0\n", pci_get_powerstate(dev));

		pci_set_powerstate(dev, PCI_POWERSTATE_D0);

		pci_write_config(dev, sc->chip_mem1_rid, mem1, 4);
		pci_write_config(dev, sc->chip_mem2_rid, mem2, 4);
		pci_write_config(dev, PCIR_INTLINE, irq, 4);
	}
#endif	/* !BURN_BRIDGE */
#endif

#if 0
	/* Enable bus mastering */
	pci_enable_busmaster(dev); 

	/* Allocate IO memory 1 */
	sc->sc_mem1_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY,
						 &sc->chip_mem1_rid,
						 RF_ACTIVE);
	if (sc->sc_mem1_res == NULL) {
		error = ENXIO;
		device_printf(dev, "can't allocate IO mem1\n");
		goto fail;
	}
	sc->sc_mem1_bt = rman_get_bustag(sc->sc_mem1_res);
	sc->sc_mem1_bh = rman_get_bushandle(sc->sc_mem1_res);

	/* Allocate IO memory 2 */
	sc->sc_mem2_res = bus_alloc_resource_any(dev, SYS_RES_MEMORY,
						 &sc->chip_mem2_rid,
						 RF_ACTIVE);
	if (sc->sc_mem2_res == NULL) {
		error = ENXIO;
		device_printf(dev, "can't allocate IO mem2\n");
		goto fail;
	}
	sc->sc_mem2_bt = rman_get_bustag(sc->sc_mem2_res);
	sc->sc_mem2_bh = rman_get_bushandle(sc->sc_mem2_res);

	/* Allocate irq */
	sc->sc_irq_res = bus_alloc_resource_any(dev, SYS_RES_IRQ,
						&sc->sc_irq_rid,
						RF_SHAREABLE | RF_ACTIVE);
	if (sc->sc_irq_res == NULL) {
		error = ENXIO;
		device_printf(dev, "can't allocate intr\n");
		goto fail;
	}
#endif

d259 1
a259 1
		goto fail;
d264 1
a264 1
		goto fail;
d282 3
a284 4
	if (i == EEINFO_RETRY_MAX) {
		error = ENXIO;
		goto fail;
	}
d304 1
a304 1
		goto fail;
d361 1
a361 72
#if 0
	sysctl_ctx_init(&sc->sc_sysctl_ctx);
	sc->sc_sysctl_tree = SYSCTL_ADD_NODE(&sc->sc_sysctl_ctx,
					     SYSCTL_STATIC_CHILDREN(_hw),
					     OID_AUTO,
					     device_get_nameunit(dev),
					     CTLFLAG_RD, 0, "");
	if (sc->sc_sysctl_tree == NULL) {
		device_printf(dev, "can't add sysctl node\n");
		error = ENXIO;
		goto fail1;
	}

	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "txrate_upd_intvl_min",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_txrate_upd_intvl_min, "I",
			"min seconds to wait before raising TX rate");
	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "txrate_upd_intvl_max",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_txrate_upd_intvl_max, "I",
			"max seconds to wait before raising TX rate");
	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "txrate_sample_threshold",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_txrate_sample_thresh, "I",
			"number of packets to be sampled "
			"before raising TX rate");

	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "long_retry_limit",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_long_retry_limit, "I",
			"max number of retries for RTS packets");
	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "short_retry_limit",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_short_retry_limit, "I",
			"max number of retries for non-RTS packets");

	SYSCTL_ADD_PROC(&sc->sc_sysctl_ctx,
			SYSCTL_CHILDREN(sc->sc_sysctl_tree),
			OID_AUTO, "msdu_lifetime",
			CTLTYPE_INT | CTLFLAG_RW,
			sc, 0, acx_sysctl_msdu_lifetime, "I",
			"MSDU life time");
#endif


#if 0
	error = bus_setup_intr(dev, sc->sc_irq_res, INTR_MPSAFE, acx_intr, sc,
			       &sc->sc_irq_handle, ifp->if_serializer);
	if (error) {
		device_printf(dev, "can't set up interrupt\n");
		goto fail1;
	}

	if (bootverbose)
		ieee80211_announce(ic);
#endif

	return 0;
//fail1:
	ieee80211_ifdetach(ifp);
fail:
	return error;
d377 1
a377 1
	return 0;
a487 3
#ifdef foo
	acx_begin_scan(sc);
#else
a488 1
#endif
a544 19
#ifdef foo
void
acx_begin_scan(struct acx_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t chan;

	ieee80211_begin_scan(ic, 1);

	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

	ACX_ENABLE_TXCHAN(sc, chan);
	ACX_ENABLE_RXCHAN(sc, chan);

	/* Start background scanning */
	timeout_add(&sc->sc_chanscan_timer, hz / acx_chanscan_rate);
}
#endif

d552 1
a552 5
	if (ic->ic_state == IEEE80211_S_SCAN) {
#if 0
		uint8_t chan;
#endif

a553 11

#if 0
		chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

		ACX_ENABLE_TXCHAN(sc, chan);
		ACX_ENABLE_RXCHAN(sc, chan);

		callout_reset(&sc->sc_chanscan_timer, hz / acx_chanscan_rate,
			      acx_next_scan, sc);
#endif
	}
@


1.5
log
@Fix more cvs Id tag tweaks in copyright notes.

Spotted by <gwyllion@@ulyssis.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.4 2006/08/03 11:17:28 mglocker Exp $ */
d423 1
a423 2
	DPRINTF(("%s: radio type %02x\n", sc->sc_dev.dv_xname,
	    sc->sc_radio_type));
d441 2
a442 2
	DPRINTF(("%s: EEPROM version %u\n", sc->sc_dev.dv_xname,
	    sc->sc_eeprom_ver));
d475 1
a475 2
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(ic->ic_myaddr));
@


1.4
log
@Change the firmware names as suggested on the main driver project
homepage; http://acx100.sourceforge.net/wiki/Firmware

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.3 2006/08/03 10:47:42 mglocker Exp $ */
a51 2
 * 
 * $DragonFly$
a57 2
 * $Id: acx.c,v 1.3 2006/08/03 10:47:42 mglocker Exp $
 *  
@


1.3
log
@Add/Fix copyright notes.
@
text
@d1 1
a1 1
/*	$OpenBSD: acx.c,v 1.2 2006/08/03 10:12:37 mglocker Exp $ */
d60 1
a60 1
 * $Id: acx.c,v 1.2 2006/08/03 10:12:37 mglocker Exp $
d1768 1
a1768 1
	const char name[]= "acx-100_base";
d1817 1
a1817 1
	const char name[] = "acx-100_radio_0d";
@


1.2
log
@Change to OpenBSD cvs tag.
@
text
@d1 18
a18 1
/*	$OpenBSD$ */
d60 1
a60 1
 * $Id: if_acx.c,v 1.3 2006/06/17 10:31:59 sephe Exp $
@


1.1
log
@Inital import for the acx(4) driver.

ok deraadt@@ jsg@@
@
text
@d1 1
a1 1
/* $Id: acx.c,v 1.6 2006/08/02 23:06:04 claudio Exp $ */
d43 1
a43 1
 * $Id: acx.c,v 1.6 2006/08/02 23:06:04 claudio Exp $
@

