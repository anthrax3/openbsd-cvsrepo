head	1.78;
access;
symbols
	OPENBSD_6_1:1.77.0.8
	OPENBSD_6_1_BASE:1.77
	OPENBSD_6_0:1.77.0.6
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.77.0.2
	OPENBSD_5_9_BASE:1.77
	OPENBSD_5_8:1.76.0.4
	OPENBSD_5_8_BASE:1.76
	OPENBSD_5_7:1.74.0.2
	OPENBSD_5_7_BASE:1.74
	OPENBSD_5_6:1.72.0.4
	OPENBSD_5_6_BASE:1.72
	OPENBSD_5_5:1.69.0.4
	OPENBSD_5_5_BASE:1.69
	OPENBSD_5_4:1.65.0.6
	OPENBSD_5_4_BASE:1.65
	OPENBSD_5_3:1.65.0.4
	OPENBSD_5_3_BASE:1.65
	OPENBSD_5_2:1.65.0.2
	OPENBSD_5_2_BASE:1.65
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.4
	OPENBSD_5_0:1.62.0.2
	OPENBSD_5_0_BASE:1.62
	OPENBSD_4_9:1.61.0.6
	OPENBSD_4_9_BASE:1.61
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.60.0.6
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.56.0.4
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.53.0.2
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.44.0.2
	OPENBSD_4_0_BASE:1.44
	OPENBSD_3_9:1.42.0.6
	OPENBSD_3_9_BASE:1.42
	OPENBSD_3_8:1.42.0.4
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.42.0.2
	OPENBSD_3_7_BASE:1.42
	OPENBSD_3_6:1.35.0.4
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.2
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.33.0.2
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.2
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.15
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.78
date	2017.06.11.02.06.36;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	08rugiXdMfZMrrJw;

1.77
date	2015.09.09.18.23.39;	author deraadt;	state Exp;
branches
	1.77.6.1
	1.77.8.1;
next	1.76;
commitid	b7uF71hcvJADoXUp;

1.76
date	2015.04.05.23.25.57;	author miod;	state Exp;
branches;
next	1.75;
commitid	XOdAFq379z2QzTF2;

1.75
date	2015.04.03.19.35.48;	author miod;	state Exp;
branches;
next	1.74;
commitid	tkqUStd9S6peIqQJ;

1.74
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.73;
commitid	yv0ECmCdICvq576h;

1.73
date	2014.08.30.14.42.05;	author miod;	state Exp;
branches;
next	1.72;
commitid	oj0wrK8U5rsPDSqa;

1.72
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.71;
commitid	I19imNlAX05zJOED;

1.71
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.70;

1.70
date	2014.03.18.22.36.37;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2014.02.20.11.13.44;	author kettenis;	state Exp;
branches;
next	1.68;

1.68
date	2014.02.20.11.09.48;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2013.10.20.20.07.29;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2013.10.18.17.38.33;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2012.05.06.13.23.54;	author mikeb;	state Exp;
branches;
next	1.64;

1.64
date	2011.09.19.11.15.18;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2011.08.18.20.02.58;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2009.02.06.22.51.04;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2009.02.06.20.27.40;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2009.01.29.21.00.05;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2009.01.28.17.37.40;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.01.04.03.51;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.17.13.59.08;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.17.13.57.44;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.12.22.02.33;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2007.01.11.22.02.03;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.11.21.58.05;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.18.18.58.37;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.18.18.57.26;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.16.15.52.30;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.11.29.12.15.27;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.29.12.13.54;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2006.08.22.21.04.32;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2006.04.16.21.03.45;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.02.27.22.10.57;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.01.24.19.20.04;	author miod;	state Exp;
branches;
next	1.40;

1.40
date	2005.01.23.16.55.18;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.23.16.53.21;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.05.23.04.25;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.03.19.18.47;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2004.09.14.22.27.04;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2003.12.16.06.07.13;	author mickey;	state Exp;
branches;
next	1.34;

1.34
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.33;

1.33
date	2003.08.21.18.06.56;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2003.08.19.03.13.07;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2003.08.19.02.52.38;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2003.08.19.02.25.11;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2003.08.17.05.52.41;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2003.08.17.02.55.08;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2003.08.11.06.25.36;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.24.17.42.29;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.03.23.09.36;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2003.02.18.09.39.45;	author miod;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2003.02.17.22.41.31;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.17.13.02.14;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.11.19.41.35;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.11.19.11.51;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.02.05.19.21.03;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.31.17.00.19;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.01.31.03.44.26;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.19.17.35.07;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.04.23.02.47;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.01.18.56.46;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.25.21.35.26;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.12.02.04.29.11;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.20.50.58;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.20.08.32.20;	author mickey;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.02.16.19.08.42;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.11.21.23.53;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.03.22.50.01;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.30.19.39.38;	author mickey;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.24.15;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2002.03.28.12.09.41;	author niklas;	state Exp;
branches;
next	1.5.4.7;

1.5.4.7
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.5.4.8;

1.5.4.8
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.5.4.9;

1.5.4.9
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.5.4.10;

1.5.4.10
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.05.19.21.59.43;	author tedu;	state Exp;
branches;
next	;

1.23.2.1
date	2003.05.31.00.48.46;	author margarida;	state Exp;
branches;
next	;

1.77.6.1
date	2017.06.12.18.36.58;	author tj;	state Exp;
branches;
next	;
commitid	pAx3CsrMr4TQwccw;

1.77.8.1
date	2017.06.12.18.34.05;	author tj;	state Exp;
branches;
next	;
commitid	itnrp6oIAzaojx9k;


desc
@@


1.78
log
@integer overflow for two range checks
fix from C Turt, ok miod
@
text
@/*	$OpenBSD: sti.c,v 1.77 2015/09/09 18:23:39 deraadt Exp $	*/

/*
 * Copyright (c) 2000-2003 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * TODO:
 *	call sti procs asynchronously;
 *	implement console scroll-back;
 *	X11 support on more models.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsconsio.h>

#include <dev/ic/stireg.h>
#include <dev/ic/stivar.h>

#include "sti.h"

struct cfdriver sti_cd = {
	NULL, "sti", DV_DULL
};

int	sti_alloc_attr(void *, int, int, int, long *);
int	sti_copycols(void *, int, int, int, int);
int	sti_copyrows(void *, int, int, int);
int	sti_cursor(void *, int, int, int);
int	sti_erasecols(void *, int, int, int, long);
int	sti_eraserows(void *, int, int, long);
int	sti_mapchar(void *, int, u_int *);
int	sti_putchar(void *, int, int, u_int, long);
void	sti_unpack_attr(void *, long, int *, int *, int *);

struct wsdisplay_emulops sti_emulops = {
	.cursor = sti_cursor,
	.mapchar = sti_mapchar,
	.putchar = sti_putchar,
	.copycols = sti_copycols,
	.erasecols = sti_erasecols,
	.copyrows = sti_copyrows,
	.eraserows = sti_eraserows,
	.alloc_attr = sti_alloc_attr,
	.unpack_attr = sti_unpack_attr
};

int	sti_alloc_screen(void *, const struct wsscreen_descr *, void **, int *,
	    int *, long *);
void	sti_free_screen(void *, void *);
int	sti_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t sti_mmap(void *, off_t, int);
int	sti_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);

const struct wsdisplay_accessops sti_accessops = {
	.ioctl = sti_ioctl,
	.mmap = sti_mmap,
	.alloc_screen = sti_alloc_screen,
	.free_screen = sti_free_screen,
	.show_screen = sti_show_screen
};

enum sti_bmove_funcs {
	bmf_clear, bmf_copy, bmf_invert, bmf_underline
};

void	sti_bmove(struct sti_screen *, int, int, int, int, int, int,
	    enum sti_bmove_funcs);
int	sti_init(struct sti_screen *, int);
#define	STI_TEXTMODE	0x01
#define	STI_CLEARSCR	0x02
#define	STI_FBMODE	0x04
int	sti_inqcfg(struct sti_screen *, struct sti_inqconfout *);
int	sti_setcment(struct sti_screen *, u_int, u_char, u_char, u_char);

struct sti_screen *
	sti_attach_screen(struct sti_softc *, int);
void	sti_describe_screen(struct sti_softc *, struct sti_screen *);
void	sti_end_attach_screen(struct sti_softc *, struct sti_screen *, int);
int	sti_fetchfonts(struct sti_screen *, struct sti_inqconfout *, u_int32_t,
	    u_int);
void	sti_region_setup(struct sti_screen *);
int	sti_rom_setup(struct sti_rom *, bus_space_tag_t, bus_space_tag_t,
	    bus_space_handle_t, bus_addr_t *, u_int);
int	sti_screen_setup(struct sti_screen *, int);

int	ngle_default_putcmap(struct sti_screen *, u_int, u_int);

void	ngle_artist_setupfb(struct sti_screen *);
void	ngle_elk_setupfb(struct sti_screen *);
void	ngle_timber_setupfb(struct sti_screen *);
int	ngle_putcmap(struct sti_screen *, u_int, u_int);

#if NSTI_PCI > 0
#define	STI_ENABLE_ROM(sc) \
do { \
	if ((sc) != NULL && (sc)->sc_enable_rom != NULL) \
		(*(sc)->sc_enable_rom)(sc); \
} while (0)
#define	STI_DISABLE_ROM(sc) \
do { \
	if ((sc) != NULL && (sc)->sc_disable_rom != NULL) \
		(*(sc)->sc_disable_rom)(sc); \
} while (0)
#else
#define	STI_ENABLE_ROM(sc)		do { /* nothing */ } while (0)
#define	STI_DISABLE_ROM(sc)		do { /* nothing */ } while (0)
#endif

/* Macros to read larger than 8 bit values from byte roms */
#define	parseshort(o) \
	((bus_space_read_1(memt, romh, (o) + 3) <<  8) | \
	 (bus_space_read_1(memt, romh, (o) + 7)))
#define	parseword(o) \
	((bus_space_read_1(memt, romh, (o) +  3) << 24) | \
	 (bus_space_read_1(memt, romh, (o) +  7) << 16) | \
	 (bus_space_read_1(memt, romh, (o) + 11) <<  8) | \
	 (bus_space_read_1(memt, romh, (o) + 15)))

int
sti_attach_common(struct sti_softc *sc, bus_space_tag_t iot,
    bus_space_tag_t memt, bus_space_handle_t romh, u_int codebase)
{
	struct sti_rom *rom;
	int rc;

	rom = (struct sti_rom *)malloc(sizeof(*rom), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (rom == NULL) {
		printf("cannot allocate rom data\n");
		return (ENOMEM);
	}

	rom->rom_softc = sc;
	rc = sti_rom_setup(rom, iot, memt, romh, sc->bases, codebase);
	if (rc != 0) {
		free(rom, M_DEVBUF, sizeof *rom);
		return (rc);
	}

	sc->sc_rom = rom;

	sti_describe(sc);

	sc->sc_scr = sti_attach_screen(sc,
	    sc->sc_flags & STI_CONSOLE ?  0 : STI_CLEARSCR);
	if (sc->sc_scr == NULL)
		rc = ENOMEM;

	return (rc);
}

struct sti_screen *
sti_attach_screen(struct sti_softc *sc, int flags)
{
	struct sti_screen *scr;
	int rc;

	scr = (struct sti_screen *)malloc(sizeof(*scr), M_DEVBUF,
	    M_NOWAIT | M_ZERO);
	if (scr == NULL) {
		printf("cannot allocate screen data\n");
		return (NULL);
	}

	scr->scr_rom = sc->sc_rom;
	rc = sti_screen_setup(scr, flags);
	if (rc != 0) {
		free(scr, M_DEVBUF, sizeof *scr);
		return (NULL);
	}

	sti_describe_screen(sc, scr);

	return (scr);
}

int
sti_rom_setup(struct sti_rom *rom, bus_space_tag_t iot, bus_space_tag_t memt,
    bus_space_handle_t romh, bus_addr_t *bases, u_int codebase)
{
	struct sti_dd *dd;
	int error, size, i;

	STI_ENABLE_ROM(rom->rom_softc);

	rom->iot = iot;
	rom->memt = memt;
	rom->romh = romh;
	rom->bases = bases;

	/*
	 * Get ROM header and code function pointers.
	 */

	dd = &rom->rom_dd;
	rom->rom_devtype = bus_space_read_1(memt, romh, 3);
	if (rom->rom_devtype == STI_DEVTYPE1) {
		dd->dd_type      = bus_space_read_1(memt, romh, 0x03);
		dd->dd_nmon      = bus_space_read_1(memt, romh, 0x07);
		dd->dd_grrev     = bus_space_read_1(memt, romh, 0x0b);
		dd->dd_lrrev     = bus_space_read_1(memt, romh, 0x0f);
		dd->dd_grid[0]   = parseword(0x10);
		dd->dd_grid[1]   = parseword(0x20);
		dd->dd_fntaddr   = parseword(0x30) & ~3;
		dd->dd_maxst     = parseword(0x40);
		dd->dd_romend    = parseword(0x50) & ~3;
		dd->dd_reglst    = parseword(0x60) & ~3;
		dd->dd_maxreent  = parseshort(0x70);
		dd->dd_maxtimo   = parseshort(0x78);
		dd->dd_montbl    = parseword(0x80) & ~3;
		dd->dd_udaddr    = parseword(0x90) & ~3;
		dd->dd_stimemreq = parseword(0xa0);
		dd->dd_udsize    = parseword(0xb0);
		dd->dd_pwruse    = parseshort(0xc0);
		dd->dd_bussup    = bus_space_read_1(memt, romh, 0xcb);
		dd->dd_ebussup   = bus_space_read_1(memt, romh, 0xcf);
		dd->dd_altcodet  = bus_space_read_1(memt, romh, 0xd3);
		dd->dd_eddst[0]  = bus_space_read_1(memt, romh, 0xd7);
		dd->dd_eddst[1]  = bus_space_read_1(memt, romh, 0xdb);
		dd->dd_eddst[2]  = bus_space_read_1(memt, romh, 0xdf);
		dd->dd_cfbaddr   = parseword(0xe0) & ~3;

		codebase <<= 2;
		dd->dd_pacode[0x0] = parseword(codebase + 0x000) & ~3;
		dd->dd_pacode[0x1] = parseword(codebase + 0x010) & ~3;
		dd->dd_pacode[0x2] = parseword(codebase + 0x020) & ~3;
		dd->dd_pacode[0x3] = parseword(codebase + 0x030) & ~3;
		dd->dd_pacode[0x4] = parseword(codebase + 0x040) & ~3;
		dd->dd_pacode[0x5] = parseword(codebase + 0x050) & ~3;
		dd->dd_pacode[0x6] = parseword(codebase + 0x060) & ~3;
		dd->dd_pacode[0x7] = parseword(codebase + 0x070) & ~3;
		dd->dd_pacode[0x8] = parseword(codebase + 0x080) & ~3;
		dd->dd_pacode[0x9] = parseword(codebase + 0x090) & ~3;
		dd->dd_pacode[0xa] = parseword(codebase + 0x0a0) & ~3;
		dd->dd_pacode[0xb] = parseword(codebase + 0x0b0) & ~3;
		dd->dd_pacode[0xc] = parseword(codebase + 0x0c0) & ~3;
		dd->dd_pacode[0xd] = parseword(codebase + 0x0d0) & ~3;
		dd->dd_pacode[0xe] = parseword(codebase + 0x0e0) & ~3;
		dd->dd_pacode[0xf] = parseword(codebase + 0x0f0) & ~3;
	} else {	/* STI_DEVTYPE4 */
		bus_space_read_raw_region_4(memt, romh, 0, (u_int8_t *)dd,
		    sizeof(*dd));
		/* fix pacode... */
		bus_space_read_raw_region_4(memt, romh, codebase,
		    (u_int8_t *)dd->dd_pacode, sizeof(dd->dd_pacode));
	}

	STI_DISABLE_ROM(rom->rom_softc);

#ifdef STIDEBUG
	printf("dd:\n"
	    "devtype=%x, rev=%x;%d, altt=%x, gid=%08x%08x, font=%x, mss=%x\n"
	    "end=%x, regions=%x, msto=%x, timo=%d, mont=%x, user=%x[%x]\n"
	    "memrq=%x, pwr=%d, bus=%x, ebus=%x, cfb=%x\n"
	    "code=",
	    dd->dd_type & 0xff, dd->dd_grrev, dd->dd_lrrev, dd->dd_altcodet,
	    dd->dd_grid[0], dd->dd_grid[1], dd->dd_fntaddr, dd->dd_maxst,
	    dd->dd_romend, dd->dd_reglst, dd->dd_maxreent, dd->dd_maxtimo,
	    dd->dd_montbl, dd->dd_udaddr, dd->dd_udsize, dd->dd_stimemreq,
	    dd->dd_pwruse, dd->dd_bussup, dd->dd_ebussup, dd->dd_cfbaddr);
	printf("%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x\n",
	    dd->dd_pacode[0x0], dd->dd_pacode[0x1], dd->dd_pacode[0x2],
	    dd->dd_pacode[0x3], dd->dd_pacode[0x4], dd->dd_pacode[0x5],
	    dd->dd_pacode[0x6], dd->dd_pacode[0x7], dd->dd_pacode[0x8],
	    dd->dd_pacode[0x9], dd->dd_pacode[0xa], dd->dd_pacode[0xb],
	    dd->dd_pacode[0xc], dd->dd_pacode[0xd], dd->dd_pacode[0xe],
	    dd->dd_pacode[0xf]);
#endif

	/*
	 * Figure out how much bytes we need for the STI code.
	 * Note there could be fewer than STI_END entries pointer
	 * entries populated, especially on older devices.
	 */

	for (i = STI_END; dd->dd_pacode[i] == 0; i--)
		;
	size = dd->dd_pacode[i] - dd->dd_pacode[STI_BEGIN];
	if (rom->rom_devtype == STI_DEVTYPE1)
		size = (size + 3) / 4;
	if (size == 0) {
		printf(": no code for the requested platform\n");
		return (EINVAL);
	}

	if (!(rom->rom_code = uvm_km_alloc(kernel_map, round_page(size)))) {
		printf(": cannot allocate %u bytes for code\n", size);
		return (ENOMEM);
	}
#ifdef STIDEBUG
	printf("code=0x%lx[%x]\n", rom->rom_code, size);
#endif

	/*
	 * Copy code into memory and make it executable.
	 */

	STI_ENABLE_ROM(rom->rom_softc);

	if (rom->rom_devtype == STI_DEVTYPE1) {
		u_int8_t *p = (u_int8_t *)rom->rom_code;
		u_int32_t addr, eaddr;

		for (addr = dd->dd_pacode[STI_BEGIN], eaddr = addr + size * 4;
		    addr < eaddr; addr += 4 )
			*p++ = bus_space_read_4(memt, romh, addr) & 0xff;

	} else	/* STI_DEVTYPE4 */
		bus_space_read_raw_region_4(memt, romh,
		    dd->dd_pacode[STI_BEGIN], (u_int8_t *)rom->rom_code,
		    size);

	STI_DISABLE_ROM(rom->rom_softc);

	if ((error = uvm_map_protect(kernel_map, rom->rom_code,
	    rom->rom_code + round_page(size), PROT_READ | PROT_EXEC, FALSE))) {
		printf(": uvm_map_protect failed (%d)\n", error);
		uvm_km_free(kernel_map, rom->rom_code, round_page(size));
		return (error);
	}

	/*
	 * Setup code function pointers.
	 */

#define	O(i) \
	(dd->dd_pacode[(i)] == 0 ? 0 : \
	    (rom->rom_code + (dd->dd_pacode[(i)] - dd->dd_pacode[0]) / \
	      (rom->rom_devtype == STI_DEVTYPE1? 4 : 1)))

	rom->init	= (sti_init_t)O(STI_INIT_GRAPH);
	rom->mgmt	= (sti_mgmt_t)O(STI_STATE_MGMT);
	rom->unpmv	= (sti_unpmv_t)O(STI_FONT_UNPMV);
	rom->blkmv	= (sti_blkmv_t)O(STI_BLOCK_MOVE);
	rom->test	= (sti_test_t)O(STI_SELF_TEST);
	rom->exhdl	= (sti_exhdl_t)O(STI_EXCEP_HDLR);
	rom->inqconf	= (sti_inqconf_t)O(STI_INQ_CONF);
	rom->scment	= (sti_scment_t)O(STI_SCM_ENT);
	rom->dmac	= (sti_dmac_t)O(STI_DMA_CTRL);
	rom->flowc	= (sti_flowc_t)O(STI_FLOW_CTRL);
	rom->utiming	= (sti_utiming_t)O(STI_UTIMING);
	rom->pmgr	= (sti_pmgr_t)O(STI_PROC_MGR);
	rom->util	= (sti_util_t)O(STI_UTIL);

#undef	O

	/*
	 * Set colormap entry is not implemented until 8.04, so force
	 * a NULL pointer here.
	 */
	if (dd->dd_grrev < STI_REVISION(8,4)) {
		rom->scment = NULL;
	}

	return (0);
}

/*
 * Map all regions.
 */
void
sti_region_setup(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t romh = rom->romh;
	bus_addr_t *bases = rom->bases;
	struct sti_dd *dd = &rom->rom_dd;
	struct sti_cfg *cc = &scr->scr_cfg;
	struct sti_region regions[STI_REGION_MAX], *r;
	u_int regno, regcnt;
	bus_addr_t addr;

#ifdef STIDEBUG
	printf("stiregions @@%p:\n", (void *)dd->dd_reglst);
#endif

	/*
	 * Read the region information.
	 */

	STI_ENABLE_ROM(rom->rom_softc);

	if (rom->rom_devtype == STI_DEVTYPE1) {
		for (regno = 0; regno < STI_REGION_MAX; regno++)
			*(u_int *)(regions + regno) =
			    parseword(dd->dd_reglst + regno * 0x10);
	} else {
		bus_space_read_raw_region_4(memt, romh, dd->dd_reglst,
		    (u_int8_t *)regions, sizeof regions);
	}

	STI_DISABLE_ROM(rom->rom_softc);

	/*
	 * Count them.
	 */

	for (regcnt = 0, r = regions; regcnt < STI_REGION_MAX; regcnt++, r++)
		if (r->last)
			break;
	regcnt++;

	/*
	 * Map them.
	 */

	for (regno = 0, r = regions; regno < regcnt; regno++, r++) {
		if (r->length == 0)
			continue;

		/*
		 * Assume an existing mapping exists.
		 */
		addr = bases[regno] + (r->offset << PGSHIFT);

#ifdef STIDEBUG
		printf("%08x @@ 0x%08lx%s%s%s%s\n",
		    r->length << PGSHIFT, addr, r->sys_only ? " sys" : "",
		    r->cache ? " cache" : "", r->btlb ? " btlb" : "",
		    r->last ? " last" : "");
#endif

		/*
		 * Region #0 is always the rom, and it should have been
		 * mapped already.
		 * XXX This expects a 1:1 mapping...
		 */
		if (regno == 0 && romh == bases[0]) {
			cc->regions[0] = addr;
			continue;
		}

		if (bus_space_map(memt, addr, r->length << PGSHIFT,
		    BUS_SPACE_MAP_LINEAR | (r->cache ?
		    BUS_SPACE_MAP_CACHEABLE : 0), &rom->regh[regno]) != 0) {
			rom->regh[regno] = romh;	/* XXX */
#ifdef STIDEBUG
			printf("already mapped region\n");
#endif
		} else {
			addr = (bus_addr_t)
			    bus_space_vaddr(memt, rom->regh[regno]);
			if (regno == 1) {
				scr->fbaddr = addr;
				scr->fblen = r->length << PGSHIFT;
			}
		}

		cc->regions[regno] = addr;
	}

#ifdef STIDEBUG
	/*
	 * Make sure we'll trap accessing unmapped regions
	 */
	for (regno = 0; regno < STI_REGION_MAX; regno++)
		if (cc->regions[regno] == 0)
		    cc->regions[regno] = 0x81234567;
#endif
}

int
sti_screen_setup(struct sti_screen *scr, int flags)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t romh = rom->romh;
	struct sti_dd *dd = &rom->rom_dd;
	struct sti_cfg *cc = &scr->scr_cfg;
	struct sti_inqconfout cfg;
	struct sti_einqconfout ecfg;
	int error, i;
	int geometry_kluge = 0;
	u_int fontindex = 0;

	bzero(cc, sizeof (*cc));
	cc->ext_cfg = &scr->scr_ecfg;
	bzero(cc->ext_cfg, sizeof(*cc->ext_cfg));

	if (dd->dd_stimemreq) {
		scr->scr_ecfg.addr =
		    malloc(dd->dd_stimemreq, M_DEVBUF, M_NOWAIT);
		if (!scr->scr_ecfg.addr) {
			printf("cannot allocate %d bytes for STI\n",
			    dd->dd_stimemreq);
			return (ENOMEM);
		}
	}

	sti_region_setup(scr);

	if ((error = sti_init(scr, 0))) {
		printf(": can not initialize (%d)\n", error);
		goto fail;
	}

	bzero(&cfg, sizeof(cfg));
	bzero(&ecfg, sizeof(ecfg));
	cfg.ext = &ecfg;
	if ((error = sti_inqcfg(scr, &cfg))) {
		printf(": error %d inquiring config\n", error);
		goto fail;
	}

	/*
	 * Older (rev 8.02) boards report wrong offset values,
	 * similar to the displayable area size, at least in m68k mode.
	 * Attempt to detect this and adjust here.
	 */
	if (cfg.owidth == cfg.width &&
	    cfg.oheight == cfg.height)
		geometry_kluge = 1;

	if (geometry_kluge) {
		scr->scr_cfg.oscr_width = cfg.owidth =
		    cfg.fbwidth - cfg.width;
		scr->scr_cfg.oscr_height = cfg.oheight =
		    cfg.fbheight - cfg.height;
	}

	/*
	 * Save a few fields for sti_describe_screen() later
	 */
	scr->fbheight = cfg.fbheight;
	scr->fbwidth = cfg.fbwidth;
	scr->oheight = cfg.oheight;
	scr->owidth = cfg.owidth;
	bcopy(cfg.name, scr->name, sizeof(scr->name));

	if ((error = sti_init(scr, STI_TEXTMODE | flags))) {
		printf(": can not initialize (%d)\n", error);
		goto fail;
	}
#ifdef STIDEBUG
	printf("conf: bpp=%d planes=%d attr=%b\n"
	    "crt=0x%x:0x%x:0x%x hw=0x%x:0x%x:0x%x\n", cfg.bpp,
	    cfg.planes, cfg.attributes, STI_INQCONF_BITS,
	    ecfg.crt_config[0], ecfg.crt_config[1], ecfg.crt_config[2],
	    ecfg.crt_hw[0], ecfg.crt_hw[1], ecfg.crt_hw[2]);
#endif
	scr->scr_bpp = cfg.bppu;

	/*
	 * Although scr->scr_ecfg.current_monitor is not filled by
	 * sti_init() as expected, we can nevertheless walk the monitor
	 * list, if there is any, and if we find a mode matching our
	 * resolution, pick its font index.
	 */
	if (dd->dd_montbl != 0) {
		STI_ENABLE_ROM(rom->rom_softc);

		for (i = 0; i < dd->dd_nmon; i++) {
			u_int offs = dd->dd_montbl + 8 * i;
			u_int32_t m[2];
			sti_mon_t mon = (void *)m;
			if (rom->rom_devtype == STI_DEVTYPE1) {
				m[0] = parseword(4 * offs);
				m[1] = parseword(4 * (offs + 4));
			} else {
				bus_space_read_raw_region_4(memt, romh, offs,
				    (u_int8_t *)mon, sizeof(*mon));
			}

			if (mon->width == scr->scr_cfg.scr_width &&
			    mon->height == scr->scr_cfg.scr_height) {
				fontindex = mon->font;
				break;
			}
		}

		STI_DISABLE_ROM(rom->rom_softc);

#ifdef STIDEBUG
		printf("font index: %d\n", fontindex);
#endif
	}

	if ((error = sti_fetchfonts(scr, &cfg, dd->dd_fntaddr, fontindex))) {
		printf(": cannot fetch fonts (%d)\n", error);
		goto fail;
	}

	/*
	 * setup screen descriptions:
	 *	figure number of fonts supported;
	 *	allocate wscons structures;
	 *	calculate dimensions.
	 */

	strlcpy(scr->scr_wsd.name, "std", sizeof(scr->scr_wsd.name));
	scr->scr_wsd.ncols = cfg.width / scr->scr_curfont.width;
	scr->scr_wsd.nrows = cfg.height / scr->scr_curfont.height;
	scr->scr_wsd.textops = &sti_emulops;
	scr->scr_wsd.fontwidth = scr->scr_curfont.width;
	scr->scr_wsd.fontheight = scr->scr_curfont.height;
	scr->scr_wsd.capabilities = WSSCREEN_REVERSE;

	scr->scr_scrlist[0] = &scr->scr_wsd;
	scr->scr_screenlist.nscreens = 1;
	scr->scr_screenlist.screens =
	    (const struct wsscreen_descr **)scr->scr_scrlist;

#ifndef SMALL_KERNEL
	/*
	 * Decide which board-specific routines to use.
	 */

	switch (dd->dd_grid[0]) {
	case STI_DD_CRX:
		scr->setupfb = ngle_elk_setupfb;
		scr->putcmap = ngle_putcmap;

		scr->reg10_value = 0x13601000;
		if (scr->scr_bpp > 8)
			scr->reg12_value = NGLE_BUFF1_CMAP3;
		else
			scr->reg12_value = NGLE_BUFF1_CMAP0;
		scr->cmap_finish_register = NGLE_REG_1;
		break;

	case STI_DD_TIMBER:
		scr->setupfb = ngle_timber_setupfb;
		scr->putcmap = ngle_putcmap;

		scr->reg10_value = 0x13602000;
		scr->reg12_value = NGLE_BUFF1_CMAP0;
		scr->cmap_finish_register = NGLE_REG_1;
		break;

	case STI_DD_ARTIST:
		scr->setupfb = ngle_artist_setupfb;
		scr->putcmap = ngle_putcmap;

		scr->reg10_value = 0x13601000;
		scr->reg12_value = NGLE_ARTIST_CMAP0;
		scr->cmap_finish_register = NGLE_REG_26;
		break;

	case STI_DD_EG:
		scr->setupfb = ngle_artist_setupfb;
		scr->putcmap = ngle_putcmap;

		scr->reg10_value = 0x13601000;
		if (scr->scr_bpp > 8) {
			scr->reg12_value = NGLE_BUFF1_CMAP3;
			scr->cmap_finish_register = NGLE_REG_1;
		} else {
			scr->reg12_value = NGLE_ARTIST_CMAP0;
			scr->cmap_finish_register = NGLE_REG_26;
		}
		break;

	case STI_DD_GRX:
	case STI_DD_CRX24:
	case STI_DD_EVRX:
	case STI_DD_3X2V:
	case STI_DD_DUAL_CRX:
	case STI_DD_HCRX:
	case STI_DD_LEGO:
	case STI_DD_SUMMIT:
	case STI_DD_PINNACLE:
	default:
		scr->setupfb = NULL;
		scr->putcmap =
		    rom->scment == NULL ? NULL : ngle_default_putcmap;
		break;
	}
#endif

	return (0);

fail:
	/* XXX free resources */
	if (scr->scr_ecfg.addr != NULL) {
		free(scr->scr_ecfg.addr, M_DEVBUF, 0);
		scr->scr_ecfg.addr = NULL;
	}

	return (ENXIO);
}

void
sti_describe_screen(struct sti_softc *sc, struct sti_screen *scr)
{
	struct sti_font *fp = &scr->scr_curfont;

	printf("%s: %s, %dx%d frame buffer, %dx%dx%d display\n",
	    sc->sc_dev.dv_xname, scr->name, scr->fbwidth, scr->fbheight,
	    scr->scr_cfg.scr_width, scr->scr_cfg.scr_height, scr->scr_bpp);

	printf("%s: %dx%d font type %d, %d bpc, charset %d-%d\n",
	    sc->sc_dev.dv_xname, fp->width, fp->height,
	    fp->type, fp->bpc, fp->first, fp->last);
}

void
sti_describe(struct sti_softc *sc)
{
	struct sti_rom *rom = sc->sc_rom;
	struct sti_dd *dd = &rom->rom_dd;

	printf(": rev %d.%02d;%d, ID 0x%08X%08X\n",
	    dd->dd_grrev >> 4, dd->dd_grrev & 0xf,
	    dd->dd_lrrev, dd->dd_grid[0], dd->dd_grid[1]);

	if (sc->sc_scr != NULL)
		sti_describe_screen(sc, sc->sc_scr);
}

/*
 * Final part of attachment. On hppa where we use the PDC console
 * during autoconf, this has to be postponed until autoconf has
 * completed.
 */
void
sti_end_attach(void *v)
{
	struct sti_softc *sc = (struct sti_softc *)v;

	if (sc->sc_scr != NULL)
		sti_end_attach_screen(sc, sc->sc_scr,
		    sc->sc_flags & STI_CONSOLE ? 1 : 0);
}

void
sti_end_attach_screen(struct sti_softc *sc, struct sti_screen *scr, int console)
{
	struct wsemuldisplaydev_attach_args waa;

	scr->scr_wsmode = WSDISPLAYIO_MODE_EMUL;

	waa.console = console;
	waa.scrdata = &scr->scr_screenlist;
	waa.accessops = &sti_accessops;
	waa.accesscookie = scr;
	waa.defaultscreens = 0;

	/* attach as console if required */
	if (console && !ISSET(sc->sc_flags, STI_ATTACHED)) {
		long defattr;

		sti_alloc_attr(scr, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&scr->scr_wsd, scr,
		    0, scr->scr_wsd.nrows - 1, defattr);
		sc->sc_flags |= STI_ATTACHED;
	}

	config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
}

u_int
sti_rom_size(bus_space_tag_t memt, bus_space_handle_t romh)
{
	int devtype;
	u_int romend;

	devtype = bus_space_read_1(memt, romh, 3);
	if (devtype == STI_DEVTYPE4) {
		bus_space_read_raw_region_4(memt, romh, 0x18,
		    (u_int8_t *)&romend, 4);
	} else {
		romend = parseword(0x50);
	}

	return (round_page(romend));
}

int
sti_fetchfonts(struct sti_screen *scr, struct sti_inqconfout *cfg,
    u_int32_t baseaddr, u_int fontindex)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t romh = rom->romh;
	struct sti_font *fp = &scr->scr_curfont;
	u_int32_t addr;
	int size;
#ifdef notyet
	int uc;
	struct {
		struct sti_unpmvflags flags;
		struct sti_unpmvin in;
		struct sti_unpmvout out;
	} a;
#endif

	/*
	 * Get the first PROM font in memory
	 */

	STI_ENABLE_ROM(rom->rom_softc);

rescan:
	addr = baseaddr;
	do {
		if (rom->rom_devtype == STI_DEVTYPE1) {
			fp->first  = parseshort(addr + 0x00);
			fp->last   = parseshort(addr + 0x08);
			fp->width  = bus_space_read_1(memt, romh,
			    addr + 0x13);
			fp->height = bus_space_read_1(memt, romh,
			    addr + 0x17);
			fp->type   = bus_space_read_1(memt, romh,
			    addr + 0x1b);
			fp->bpc    = bus_space_read_1(memt, romh,
			    addr + 0x1f);
			fp->next   = parseword(addr + 0x20);
			fp->uheight= bus_space_read_1(memt, romh,
			    addr + 0x33);
			fp->uoffset= bus_space_read_1(memt, romh,
			    addr + 0x37);
		} else { /* STI_DEVTYPE4 */
			bus_space_read_raw_region_4(memt, romh, addr,
			    (u_int8_t *)fp, sizeof(struct sti_font));
		}

#ifdef STIDEBUG
		STI_DISABLE_ROM(rom->rom_softc);
		printf("font@@%p: %d-%d, %dx%d, type %d, next %x\n",
		    (void *)addr, fp->first, fp->last, fp->width, fp->height,
		    fp->type, fp->next);
		STI_ENABLE_ROM(rom->rom_softc);
#endif

		if (fontindex == 0) {
			size = sizeof(struct sti_font) +
			    (fp->last - fp->first + 1) * fp->bpc;
			if (rom->rom_devtype == STI_DEVTYPE1)
				size *= 4;
			scr->scr_romfont = malloc(size, M_DEVBUF, M_NOWAIT);
			if (scr->scr_romfont == NULL)
				return (ENOMEM);

			bus_space_read_raw_region_4(memt, romh, addr,
			    (u_int8_t *)scr->scr_romfont, size);

			break;
		}

		addr = baseaddr + fp->next;
		fontindex--;
	} while (fp->next != 0);

	/*
	 * If our font index was bogus, we did not find the expected font.
	 * In this case, pick the first one and be done with it.
	 */
	if (fp->next == 0 && scr->scr_romfont == NULL) {
		fontindex = 0;
		goto rescan;
	}

	STI_DISABLE_ROM(rom->rom_softc);

#ifdef notyet
	/*
	 * If there is enough room in the off-screen framebuffer memory,
	 * display all the characters there in order to display them
	 * faster with blkmv operations rather than unpmv later on.
	 */
	if (size <= cfg->fbheight *
	    (cfg->fbwidth - cfg->width - cfg->owidth)) {
		bzero(&a, sizeof(a));
		a.flags.flags = STI_UNPMVF_WAIT;
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		a.in.font_addr = scr->scr_romfont;

		scr->scr_fontmaxcol = cfg->fbheight / fp->height;
		scr->scr_fontbase = cfg->width + cfg->owidth;
		for (uc = fp->first; uc <= fp->last; uc++) {
			a.in.x = ((uc - fp->first) / scr->scr_fontmaxcol) *
			    fp->width + scr->scr_fontbase;
			a.in.y = ((uc - fp->first) % scr->scr_fontmaxcol) *
			    fp->height;
			a.in.index = uc;

			(*scr->unpmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
			if (a.out.errno) {
#ifdef STIDEBUG
				printf("sti_unpmv %d returned %d\n",
				    uc, a.out.errno);
#endif
				return (0);
			}
		}

		free(scr->scr_romfont, M_DEVBUF, 0);
		scr->scr_romfont = NULL;
	}
#endif

	return (0);
}

/*
 * Wrappers around STI code pointers
 */

int
sti_init(struct sti_screen *scr, int mode)
{
	struct sti_rom *rom = scr->scr_rom;
	struct {
		struct sti_initflags flags;
		struct sti_initin in;
		struct sti_einitin ein;
		struct sti_initout out;
	} a;

	bzero(&a, sizeof(a));

	a.flags.flags = STI_INITF_WAIT | STI_INITF_EBET;
	if (mode & STI_TEXTMODE) {
		a.flags.flags |= STI_INITF_TEXT /* | STI_INITF_PNTS */ |
		    STI_INITF_ICMT | STI_INITF_CMB;
		if (mode & STI_CLEARSCR)
			a.flags.flags |= STI_INITF_CLEAR;
	} else if (mode & STI_FBMODE) {
		a.flags.flags |= STI_INITF_NTEXT /* | STI_INITF_PTS */;
	}

	a.in.text_planes = 1;
	a.in.ext_in = &a.ein;
#ifdef STIDEBUG
	printf("sti_init,%p(%x, %p, %p, %p)\n",
	    rom->init, a.flags.flags, &a.in, &a.out, &scr->scr_cfg);
#endif
	(*rom->init)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
	if (a.out.text_planes != a.in.text_planes)
		return (-1);	/* not colliding with sti errno values */
	return (a.out.errno);
}

int
sti_inqcfg(struct sti_screen *scr, struct sti_inqconfout *out)
{
	struct sti_rom *rom = scr->scr_rom;
	struct {
		struct sti_inqconfflags flags;
		struct sti_inqconfin in;
	} a;

	bzero(&a, sizeof(a));

	a.flags.flags = STI_INQCONFF_WAIT;
	(*rom->inqconf)(&a.flags, &a.in, out, &scr->scr_cfg);

	return out->errno;
}

void
sti_bmove(struct sti_screen *scr, int x1, int y1, int x2, int y2, int h, int w,
    enum sti_bmove_funcs f)
{
	struct sti_rom *rom = scr->scr_rom;
	struct {
		struct sti_blkmvflags flags;
		struct sti_blkmvin in;
		struct sti_blkmvout out;
	} a;

	bzero(&a, sizeof(a));

	a.flags.flags = STI_BLKMVF_WAIT;
	switch (f) {
	case bmf_clear:
		a.flags.flags |= STI_BLKMVF_CLR;
		a.in.bg_colour = STI_COLOUR_BLACK;
		break;
	case bmf_underline:
	case bmf_copy:
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		break;
	case bmf_invert:
		a.flags.flags |= STI_BLKMVF_COLR;
		a.in.fg_colour = STI_COLOUR_BLACK;
		a.in.bg_colour = STI_COLOUR_WHITE;
		break;
	}
	a.in.srcx = x1;
	a.in.srcy = y1;
	a.in.dstx = x2;
	a.in.dsty = y2;
	a.in.height = h;
	a.in.width = w;

	(*rom->blkmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
#ifdef STIDEBUG
	if (a.out.errno)
		printf("sti_blkmv returned %d\n", a.out.errno);
#endif
}

int
sti_setcment(struct sti_screen *scr, u_int i, u_char r, u_char g, u_char b)
{
	struct sti_rom *rom = scr->scr_rom;
	struct {
		struct sti_scmentflags flags;
		struct sti_scmentin in;
		struct sti_scmentout out;
	} a;

	bzero(&a, sizeof(a));

	a.flags.flags = STI_SCMENTF_WAIT;
	a.in.entry = i;
	a.in.value = (r << 16) | (g << 8) | b;

	(*rom->scment)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
#ifdef STIDEBUG
	if (a.out.errno)
		printf("sti_setcment(%d, %u, %u, %u): %d\n",
		    i, r, g, b, a.out.errno);
#endif

	return a.out.errno;
}

/*
 * wsdisplay accessops
 */

int
sti_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct wsdisplay_fbinfo *wdf;
	struct wsdisplay_cmap *cmapp;
	u_int mode, idx, count;
	int ret;

	ret = 0;
	switch (cmd) {
	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		switch (mode) {
		case WSDISPLAYIO_MODE_EMUL:
			if (scr->scr_wsmode != WSDISPLAYIO_MODE_EMUL)
				ret = sti_init(scr, STI_TEXTMODE);
			break;
		case WSDISPLAYIO_MODE_DUMBFB:
			if (scr->scr_wsmode != WSDISPLAYIO_MODE_DUMBFB) {
				if (scr->setupfb != NULL)
					scr->setupfb(scr);
				else
#if 0
					ret = sti_init(scr, STI_FBMODE);
#else
					ret = EINVAL;
#endif
			}
			break;
		case WSDISPLAYIO_MODE_MAPPED:
		default:
			ret = EINVAL;
			break;
		}
		if (ret == 0)
			scr->scr_wsmode = mode;
		break;

	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_STI;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = scr->scr_cfg.scr_height;
		wdf->width  = scr->scr_cfg.scr_width;
		wdf->depth  = scr->scr_bpp;
		if (scr->putcmap == NULL || scr->scr_bpp > 8)
			wdf->cmsize = 0;
		else
			wdf->cmsize = STI_NCMAP;
		break;

	case WSDISPLAYIO_LINEBYTES:
		if (scr->scr_bpp > 8)
			*(u_int *)data = scr->scr_cfg.fb_width * 4;
		else
			*(u_int *)data = scr->scr_cfg.fb_width;
		break;

	case WSDISPLAYIO_GETSUPPORTEDDEPTH:
		if (scr->scr_bpp > 8)
			*(u_int *)data = WSDISPLAYIO_DEPTH_24_32;
		else
			*(u_int *)data = WSDISPLAYIO_DEPTH_8;
		break;

	case WSDISPLAYIO_GETCMAP:
		if (scr->putcmap == NULL || scr->scr_bpp > 8)
			return ENODEV;
		cmapp = (struct wsdisplay_cmap *)data;
		idx = cmapp->index;
		count = cmapp->count;
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
			return EINVAL;
		if ((ret = copyout(&scr->scr_rcmap[idx], cmapp->red, count)))
			break;
		if ((ret = copyout(&scr->scr_gcmap[idx], cmapp->green, count)))
			break;
		if ((ret = copyout(&scr->scr_bcmap[idx], cmapp->blue, count)))
			break;
		break;

	case WSDISPLAYIO_PUTCMAP:
		if (scr->putcmap == NULL || scr->scr_bpp > 8)
			return ENODEV;
		cmapp = (struct wsdisplay_cmap *)data;
		idx = cmapp->index;
		count = cmapp->count;
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
			return EINVAL;
		if ((ret = copyin(cmapp->red, &scr->scr_rcmap[idx], count)))
			break;
		if ((ret = copyin(cmapp->green, &scr->scr_gcmap[idx], count)))
			break;
		if ((ret = copyin(cmapp->blue, &scr->scr_bcmap[idx], count)))
			break;
		ret = scr->putcmap(scr, idx, count);
		break;

	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
		break;

	default:
		return (-1);		/* not supported yet */
	}

	return (ret);
}

paddr_t
sti_mmap(void *v, off_t offset, int prot)
{
	struct sti_screen *scr = (struct sti_screen *)v;
#if 0
	struct sti_rom *rom = scr->scr_rom;
#endif
	paddr_t pa;

	if ((offset & PAGE_MASK) != 0)
		return -1;

	if (offset < 0 || offset >= scr->fblen)
		return -1;

#if 0 /* XXX not all platforms provide bus_space_mmap() yet */
	pa = bus_space_mmap(rom->memt, scr->fbaddr, offset, prot,
	    BUS_SPACE_MAP_LINEAR);
#else
	pa = scr->fbaddr + offset;
#endif

	return pa;
}

int
sti_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *cxp, int *cyp, long *defattr)
{
	struct sti_screen *scr = (struct sti_screen *)v;

	if (scr->scr_nscreens > 0)
		return ENOMEM;

	*cookiep = scr;
	*cxp = 0;
	*cyp = 0;
	sti_alloc_attr(scr, 0, 0, 0, defattr);
	scr->scr_nscreens++;
	return 0;
}

void
sti_free_screen(void *v, void *cookie)
{
	struct sti_screen *scr = (struct sti_screen *)v;

	scr->scr_nscreens--;
}

int
sti_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
#if 0
	struct sti_screen *scr = (struct sti_screen *)v;
#endif

	return 0;
}

/*
 * wsdisplay emulops
 */

int
sti_cursor(void *v, int on, int row, int col)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;

	sti_bmove(scr,
	    col * fp->width, row * fp->height,
	    col * fp->width, row * fp->height,
	    fp->height, fp->width, bmf_invert);

	return 0;
}

/*
 * ISO 8859-1 part of Unicode to HP Roman font index conversion array.
 */
static const u_int8_t
sti_unitoroman[0x100 - 0xa0] = {
	0xa0, 0xb8, 0xbf, 0xbb, 0xba, 0xbc,    0, 0xbd,
	0xab,    0, 0xf9, 0xfb,    0, 0xf6,    0, 0xb0,
	
	0xb3, 0xfe,    0,    0, 0xa8, 0xf3, 0xf4, 0xf2,
	   0,    0, 0xfa, 0xfd, 0xf7, 0xf8,    0, 0xb9,

	0xa1, 0xe0, 0xa2, 0xe1, 0xd8, 0xd0, 0xd3, 0xb4,
	0xa3, 0xdc, 0xa4, 0xa5, 0xe6, 0xe5, 0xa6, 0xa7,

	0xe3, 0xb6, 0xe8, 0xe7, 0xdf, 0xe9, 0xda,    0,
	0xd2, 0xad, 0xed, 0xae, 0xdb, 0xb1, 0xf0, 0xde,

	0xc8, 0xc4, 0xc0, 0xe2, 0xcc, 0xd4, 0xd7, 0xb5,
	0xc9, 0xc5, 0xc1, 0xcd, 0xd9, 0xd5, 0xd1, 0xdd,

	0xe4, 0xb7, 0xca, 0xc6, 0xc2, 0xea, 0xce,    0,
	0xd6, 0xcb, 0xc7, 0xc3, 0xcf, 0xb2, 0xf1, 0xef
};

int
sti_mapchar(void *v, int uni, u_int *index)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;
	int c;

	switch (fp->type) {
	case STI_FONT_HPROMAN8:
		if (uni >= 0x80 && uni < 0xa0)
			c = -1;
		else if (uni >= 0xa0 && uni < 0x100) {
			c = (int)sti_unitoroman[uni - 0xa0];
			if (c == 0)
				c = -1;
		} else
			c = uni;
		break;
	default:
		c = uni;
		break;
	}

	if (c == -1 || c < fp->first || c > fp->last) {
		*index = '?';
		return (0);
	}

	*index = c;
	return (5);
}

int
sti_putchar(void *v, int row, int col, u_int uc, long attr)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_rom *rom = scr->scr_rom;
	struct sti_font *fp = &scr->scr_curfont;
	int bg, fg;

	sti_unpack_attr(scr, attr, &fg, &bg, NULL);

	if (scr->scr_romfont != NULL) {
		/*
		 * Font is in memory, use unpmv
		 */
		struct {
			struct sti_unpmvflags flags;
			struct sti_unpmvin in;
			struct sti_unpmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_UNPMVF_WAIT;
		a.in.fg_colour = fg;
		a.in.bg_colour = bg;

		a.in.x = col * fp->width;
		a.in.y = row * fp->height;
		a.in.font_addr = scr->scr_romfont;
		a.in.index = uc;

		(*rom->unpmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
	} else {
		/*
		 * Font is in frame buffer, use blkmv
		 */
		struct {
			struct sti_blkmvflags flags;
			struct sti_blkmvin in;
			struct sti_blkmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_BLKMVF_WAIT;
		a.in.fg_colour = fg;
		a.in.bg_colour = bg;

		a.in.srcx = ((uc - fp->first) / scr->scr_fontmaxcol) *
		    fp->width + scr->scr_fontbase;
		a.in.srcy = ((uc - fp->first) % scr->scr_fontmaxcol) *
		    fp->height;
		a.in.dstx = col * fp->width;
		a.in.dsty = row * fp->height;
		a.in.height = fp->height;
		a.in.width = fp->width;

		(*rom->blkmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
	}

	return 0;
}

int
sti_copycols(void *v, int row, int srccol, int dstcol, int ncols)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;

	sti_bmove(scr,
	    srccol * fp->width, row * fp->height,
	    dstcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_copy);

	return 0;
}

int
sti_erasecols(void *v, int row, int startcol, int ncols, long attr)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;

	sti_bmove(scr,
	    startcol * fp->width, row * fp->height,
	    startcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_clear);

	return 0;
}

int
sti_copyrows(void *v, int srcrow, int dstrow, int nrows)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;

	sti_bmove(scr, 0, srcrow * fp->height, 0, dstrow * fp->height,
	    nrows * fp->height, scr->scr_cfg.scr_width, bmf_copy);

	return 0;
}

int
sti_eraserows(void *v, int srcrow, int nrows, long attr)
{
	struct sti_screen *scr = (struct sti_screen *)v;
	struct sti_font *fp = &scr->scr_curfont;

	sti_bmove(scr, 0, srcrow * fp->height, 0, srcrow * fp->height,
	    nrows * fp->height, scr->scr_cfg.scr_width, bmf_clear);

	return 0;
}

int
sti_alloc_attr(void *v, int fg, int bg, int flags, long *pattr)
{
#if 0
	struct sti_screen *scr = (struct sti_screen *)v;
#endif

	*pattr = flags & WSATTR_REVERSE;
	return 0;
}

void
sti_unpack_attr(void *v, long attr, int *fg, int *bg, int *ul)
{
#if 0
	struct sti_screen *scr = (struct sti_screen *)v;
#endif

	if (attr & WSATTR_REVERSE) {
		*fg = STI_COLOUR_BLACK;
		*bg = STI_COLOUR_WHITE;
	} else {
		*fg = STI_COLOUR_WHITE;
		*bg = STI_COLOUR_BLACK;
	}
	if (ul != NULL)
		*ul = 0;
}

int
ngle_default_putcmap(struct sti_screen *scr, u_int idx, u_int count)
{
	int i, ret;

	for (i = idx + count - 1; i >= (int)idx; i--)
		if ((ret = sti_setcment(scr, i, scr->scr_rcmap[i],
		    scr->scr_gcmap[i], scr->scr_bcmap[i])))
			return EINVAL;

	return 0;
}

#ifndef SMALL_KERNEL

void	ngle_setup_hw(bus_space_tag_t, bus_space_handle_t);
void	ngle_setup_fb(bus_space_tag_t, bus_space_handle_t, uint32_t);
void	ngle_setup_attr_planes(struct sti_screen *scr);
void	ngle_setup_bt458(struct sti_screen *scr);

#define	ngle_bt458_write(memt, memh, r, v) \
	bus_space_write_4(memt, memh, NGLE_REG_RAMDAC + ((r) << 2), (v) << 24)

void
ngle_artist_setupfb(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];

	ngle_setup_bt458(scr);

	ngle_setup_hw(memt, memh);
	ngle_setup_fb(memt, memh, scr->reg10_value);

	ngle_setup_attr_planes(scr);

	ngle_setup_hw(memt, memh);
	bus_space_write_4(memt, memh, NGLE_REG_21,
	    bus_space_read_4(memt, memh, NGLE_REG_21) | 0x0a000000);
	bus_space_write_4(memt, memh, NGLE_REG_27,
	    bus_space_read_4(memt, memh, NGLE_REG_27) | 0x00800000);
}

void
ngle_elk_setupfb(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];

	ngle_setup_bt458(scr);

	ngle_setup_hw(memt, memh);
	ngle_setup_fb(memt, memh, scr->reg10_value);

	ngle_setup_attr_planes(scr);

	ngle_setup_hw(memt, memh);
	/* enable overlay planes in Bt458 command register */
	ngle_bt458_write(memt, memh, 0x0c, 0x06);
	ngle_bt458_write(memt, memh, 0x0e, 0x43);
}

void
ngle_timber_setupfb(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];

	ngle_setup_bt458(scr);

	ngle_setup_hw(memt, memh);
	/* enable overlay planes in Bt458 command register */
	ngle_bt458_write(memt, memh, 0x0c, 0x06);
	ngle_bt458_write(memt, memh, 0x0e, 0x43);
}

void
ngle_setup_bt458(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];

	ngle_setup_hw(memt, memh);
	/* set Bt458 read mask register to all planes */
	ngle_bt458_write(memt, memh, 0x08, 0x04);
	ngle_bt458_write(memt, memh, 0x0a, 0xff);
}

void
ngle_setup_attr_planes(struct sti_screen *scr)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];

	ngle_setup_hw(memt, memh);
	bus_space_write_4(memt, memh, NGLE_REG_11, 0x2ea0d000);
	bus_space_write_4(memt, memh, NGLE_REG_14, 0x23000302);
	bus_space_write_4(memt, memh, NGLE_REG_12, scr->reg12_value);
	bus_space_write_4(memt, memh, NGLE_REG_8, 0xffffffff);

	bus_space_write_4(memt, memh, NGLE_REG_6, 0x00000000);
	bus_space_write_4(memt, memh, NGLE_REG_9,
	    (scr->scr_cfg.scr_width << 16) | scr->scr_cfg.scr_height);
	bus_space_write_4(memt, memh, NGLE_REG_6, 0x05000000);
	bus_space_write_4(memt, memh, NGLE_REG_9, 0x00040001);

	ngle_setup_hw(memt, memh);
	bus_space_write_4(memt, memh, NGLE_REG_12, 0x00000000);

	ngle_setup_fb(memt, memh, scr->reg10_value);
}

int
ngle_putcmap(struct sti_screen *scr, u_int idx, u_int count)
{
	struct sti_rom *rom = scr->scr_rom;
	bus_space_tag_t memt = rom->memt;
	bus_space_handle_t memh = rom->regh[2];
	uint8_t *r, *g, *b;
	uint32_t cmap_finish;

	if (scr->scr_bpp > 8)
		cmap_finish = 0x83000100;
	else
		cmap_finish = 0x80000100;

	r = scr->scr_rcmap + idx;
	g = scr->scr_gcmap + idx;
	b = scr->scr_bcmap + idx;

	ngle_setup_hw(memt, memh);
	bus_space_write_4(memt, memh, NGLE_REG_10, 0xbbe0f000);
	bus_space_write_4(memt, memh, NGLE_REG_14, 0x03000300);
	bus_space_write_4(memt, memh, NGLE_REG_13, 0xffffffff);

	while (count-- != 0) {
		ngle_setup_hw(memt, memh);
		bus_space_write_4(memt, memh, NGLE_REG_3, 0x400 | (idx << 2));
		bus_space_write_4(memt, memh, NGLE_REG_4,
		    (*r << 16) | (*g << 8) | *b);

		idx++;
		r++, g++, b++;
	}

	bus_space_write_4(memt, memh, NGLE_REG_2, 0x400);
	bus_space_write_4(memt, memh, scr->cmap_finish_register, cmap_finish);
	ngle_setup_fb(memt, memh, scr->reg10_value);


	return 0;
}

void
ngle_setup_hw(bus_space_tag_t memt, bus_space_handle_t memh)
{
	uint8_t stat;

	do {
		stat = bus_space_read_1(memt, memh, NGLE_REG_15b0);
		if (stat == 0)
			stat = bus_space_read_1(memt, memh, NGLE_REG_15b0);
	} while (stat != 0);
}

void
ngle_setup_fb(bus_space_tag_t memt, bus_space_handle_t memh, uint32_t reg10)
{
	ngle_setup_hw(memt, memh);
	bus_space_write_4(memt, memh, NGLE_REG_10, reg10);
	bus_space_write_4(memt, memh, NGLE_REG_14, 0x83000300);
	ngle_setup_hw(memt, memh);
	bus_space_write_1(memt, memh, NGLE_REG_16b1, 1);
}
#endif	/* SMALL_KERNEL */
@


1.77
log
@sizes for free(); ok sthen semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.76 2015/04/05 23:25:57 miod Exp $	*/
d1133 1
a1133 1
		if (idx >= STI_NCMAP || idx + count > STI_NCMAP)
d1149 1
a1149 1
		if (idx >= STI_NCMAP || idx + count > STI_NCMAP)
@


1.77.6.1
log
@MFC: fix an integer overflow in two range checks of the sti display driver.

ok tb
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.77 2015/09/09 18:23:39 deraadt Exp $	*/
d1133 1
a1133 1
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
d1149 1
a1149 1
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
@


1.77.8.1
log
@MFC: fix an integer overflow in two range checks of the sti display driver.

ok tb
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.77 2015/09/09 18:23:39 deraadt Exp $	*/
d1133 1
a1133 1
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
d1149 1
a1149 1
		if (idx >= STI_NCMAP || count > STI_NCMAP - idx)
@


1.76
log
@Work-in-progress support for non-accelerated X11 on *some* sti(4) frame buffers;
based upon the old HP ngle X11 driver. Currently limited to CRX (720/735/750),
Timber (710, old 715), Artist (712, 715) and EG (B-series), however the
colormap isn't set up correctly on Timber and EG yet.

Joint work with Artem Falcon, now in good enough shape to be worked further
in the tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.75 2015/04/03 19:35:48 miod Exp $	*/
d168 1
a168 1
		free(rom, M_DEVBUF, 0);
d200 1
a200 1
		free(scr, M_DEVBUF, 0);
@


1.75
log
@Fix unsigned vs signed comparison in for() loop condition causing an infinite
loop for WSDISPLAYIO_PUTCMAP ioctl with idx == 0; reported by Artem Falcon.

[according to my investigation, none of the other for() loops in the kernel
 are affected by a similar issue]
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.74 2014/11/16 12:31:00 deraadt Exp $	*/
d32 1
a32 1
 *	X11 support.
d67 9
a75 9
	sti_cursor,
	sti_mapchar,
	sti_putchar,
	sti_copycols,
	sti_erasecols,
	sti_copyrows,
	sti_eraserows,
	sti_alloc_attr,
	sti_unpack_attr
d103 1
d118 7
d308 1
a308 1
	for (i = STI_END; !dd->dd_pacode[i]; i--)
d363 6
a368 6
	rom->init	= (sti_init_t)	O(STI_INIT_GRAPH);
	rom->mgmt	= (sti_mgmt_t)	O(STI_STATE_MGMT);
	rom->unpmv	= (sti_unpmv_t)	O(STI_FONT_UNPMV);
	rom->blkmv	= (sti_blkmv_t)	O(STI_BLOCK_MOVE);
	rom->test	= (sti_test_t)	O(STI_SELF_TEST);
	rom->exhdl	= (sti_exhdl_t)	O(STI_EXCEP_HDLR);
d371 2
a372 2
	rom->dmac	= (sti_dmac_t)	O(STI_DMA_CTRL);
	rom->flowc	= (sti_flowc_t)	O(STI_FLOW_CTRL);
d374 2
a375 2
	rom->pmgr	= (sti_pmgr_t)	O(STI_PROC_MGR);
	rom->util	= (sti_util_t)	O(STI_UTIL);
a401 1
	bus_space_handle_t bh;
d467 3
a469 1
		    r->cache ? BUS_SPACE_MAP_CACHEABLE : 0, &bh)) {
d474 2
a475 2
			/* XXX should use bus_space_vaddr */
			addr = (bus_addr_t)bh;
d636 67
d946 10
a955 4
	a.flags.flags = STI_INITF_WAIT | STI_INITF_CMB | STI_INITF_EBET |
	    (mode & STI_TEXTMODE ? STI_INITF_TEXT | STI_INITF_PBET |
	     STI_INITF_PBETI | STI_INITF_ICMT : 0) |
	    (mode & STI_CLEARSCR ? STI_INITF_CLEAR : 0);
d1046 5
a1062 1
	struct sti_rom *rom = scr->scr_rom;
d1066 1
a1066 1
	int i, ret;
d1072 24
a1095 7
		if (scr->scr_wsmode == WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_DUMBFB)
			ret = sti_init(scr, 0);
		else if (scr->scr_wsmode == WSDISPLAYIO_MODE_DUMBFB &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			ret = sti_init(scr, STI_TEXTMODE);
		scr->scr_wsmode = mode;
d1107 1
a1107 1
		if (rom->scment == NULL)
d1114 11
a1124 1
		*(u_int *)data = scr->scr_cfg.fb_width;
d1128 1
a1128 1
		if (rom->scment == NULL)
d1144 1
a1144 1
		if (rom->scment == NULL)
d1157 1
a1157 13
		for (i = idx + count - 1; i >= (int)idx; i--)
			if ((ret = sti_setcment(scr, i, scr->scr_rcmap[i],
			    scr->scr_gcmap[i], scr->scr_bcmap[i]))) {
#ifdef STIDEBUG
				printf("sti_ioctl: "
				    "sti_setcment(%d, %u, %u, %u): %d\n", i,
				    (u_int)scr->scr_rcmap[i],
				    (u_int)scr->scr_gcmap[i],
				    (u_int)scr->scr_bcmap[i], ret);
#endif
				ret = EINVAL;
				break;
			}
d1174 1
d1176 15
a1190 1
	struct sti_screen *scr = (struct sti_screen *)v;
d1193 1
a1193 2
	/* XXX not finished */
	return -1;
d1449 181
@


1.74
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.73 2014/08/30 14:42:05 miod Exp $	*/
d1044 1
a1044 1
		for (i = idx + count - 1; i >= idx; i--)
@


1.73
log
@Fix format strings in STIDEBUG code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.72 2014/07/12 18:48:17 tedu Exp $	*/
d340 1
a340 1
	    rom->rom_code + round_page(size), UVM_PROT_RX, FALSE))) {
@


1.72
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.71 2014/03/28 17:57:11 mpi Exp $	*/
d315 1
a315 1
	printf("code=0x%x[%x]\n", rom->rom_code, size);
d400 1
a400 1
	printf("stiregions @@%p:\n", dd->dd_reglst);
d443 1
a443 1
		printf("%08x @@ 0x%08x%s%s%s%s\n",
d777 2
a778 2
		    addr, fp->first, fp->last, fp->width, fp->height, fp->type,
		    fp->next);
@


1.71
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.70 2014/03/18 22:36:37 miod Exp $	*/
d160 1
a160 1
		free(rom, M_DEVBUF);
d192 1
a192 1
		free(scr, M_DEVBUF);
d632 1
a632 1
		free(scr->scr_ecfg.addr, M_DEVBUF);
d845 1
a845 1
		free(scr->scr_romfont, M_DEVBUF);
@


1.70
log
@Retire hp300, mvme68k and mvme88k ports. These ports have no users, keeping
this hardware alive is becoming increasingly difficult, and I should heed the
message sent by the three disks which have died on me over the last few days.

Noone sane will mourn these ports anyway. So long, and thanks for the fish.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.69 2014/02/20 11:13:44 kettenis Exp $	*/
d40 1
a40 1
#include <uvm/uvm.h>
@


1.69
log
@revert previous commit; didn't intend to commit those bits
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.67 2013/10/20 20:07:29 miod Exp $	*/
a1333 43

#if NSTI_DIO > 0 || NSTI_SGC > 0

/*
 * Early console support.  Only used on hp300.
 */

int
sti_cnattach(struct sti_rom *rom, struct sti_screen *scr, bus_space_tag_t memt,
    bus_addr_t *bases, u_int codebase)
{
	bus_space_handle_t romh;
	u_int romend;
	int error;
	long defattr;

	if ((error = bus_space_map(memt, bases[0], PAGE_SIZE, 0, &romh)) != 0)
		return (error);

	/*
	 * Compute real PROM size
	 */
	romend = sti_rom_size(memt, romh);

	bus_space_unmap(memt, romh, PAGE_SIZE);

	if ((error = bus_space_map(memt, bases[0], romend, 0, &romh)) != 0)
		return (error);

	bases[0] = romh;
	if (sti_rom_setup(rom, memt, memt, romh, bases, codebase) != 0)
		panic(__func__);
	scr->scr_rom = rom;
	if (sti_screen_setup(scr, STI_CLEARSCR) != 0)
		panic(__func__);

	sti_alloc_attr(scr, 0, 0, 0, &defattr);
	wsdisplay_cnattach(&scr->scr_wsd, scr, 0, 0, defattr);

	return (0);
}

#endif	/* NSTI_SGC > 0 */
@


1.68
log
@Avoid printing the "nvram corrupt" message for onboard 2200s found on Sun
hardware.

ok dlg@@, jmatthew@@
@
text
@a469 1
				printf("0x%x/0x%x\n", scr->fbaddr, scr->fblen);
d1071 1
a1071 1
sti_mmap(void *v, off_t off, int prot)
d1073 1
a1074 11

	if (off & PGOFSET)
		return (-1);

	if (scr->scr_wsmode == WSDISPLAYIO_MODE_DUMBFB) {
#if 0
		if (off >= 0 && off < scr->fblen)
			return (bus_space_mmap(scr->scr_rom->memt, scr->fbaddr,
			    off, prot, BUS_SPACE_MAP_LINEAR));
#else
		return (scr->fbaddr + off);
a1075 1
	}
d1077 2
a1078 1
	return (-1);
@


1.67
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.66 2013/10/18 17:38:33 miod Exp $	*/
d470 1
d1072 1
a1072 1
sti_mmap(void *v, off_t offset, int prot)
d1074 6
d1081 5
a1085 1
	struct sti_screen *scr = (struct sti_screen *)v;
d1087 1
d1089 1
a1089 2
	/* XXX not finished */
	return -1;
@


1.66
log
@Make sure that, when a particular mapchar() can't find a proper glyph for the
requested character in the font it is using, it suggests a question mark
character, instead of a space, so that the existence of the non-representable
character becomes visible.

Note that this is consistent with pcdisplay which suggests a diamond for
missing glyphs.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.65 2012/05/06 13:23:54 mikeb Exp $	*/
d87 5
a91 6
	sti_ioctl,
	sti_mmap,
	sti_alloc_screen,
	sti_free_screen,
	sti_show_screen,
	NULL			/* load_font */
@


1.65
log
@add support for the reverse video attribute in sti(4)
makes programs like less and mg look a wee bit prettier
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.64 2011/09/19 11:15:18 miod Exp $	*/
d1184 1
a1184 1
		*index = ' ';
@


1.64
log
@Missing argument in STIDEBUG printf
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.63 2011/08/18 20:02:58 miod Exp $	*/
d621 1
a621 1
	scr->scr_wsd.capabilities = 0;
d1198 3
d1215 3
a1217 3
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
d1237 2
a1238 3
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
d1314 1
a1314 1
	*pattr = 0;
d1325 7
a1331 2
	*fg = WSCOL_WHITE;
	*bg = WSCOL_BLACK;
@


1.63
log
@So, it turns out that models 362 and 382 built-in frame buffer only shows up
in DIO-II space, as a fat device spanning four select codes (i.e. 16MB of
memory). This is way too much for an at-most 2 Mpixel 8bit frame buffer, and
it turns out that this is because the device provides both a regular DIO-II
frame buffer (spanning two select codes) and a regular STI frame buffer
(spanning the other two select codes).
This commit introduces a straightforward sti@@dio attachment to get a working
sti(4) and wsdisplay(4) in a ridiculously small number of lines; however
the console code needs some changes to avoid duplicating globals.

While there, add sti@@dio support for the bootblocks, and I couldn't help
myself but clean the most rotten parts of them, and try to have them reuse
various files in sys/arch/hp300/dev instead of rolling their outdated ones.

Tested on a real 382 with the low-resolution frame buffer:
sti0 at dio0 scode 132: rev 8.02;129, ID 0x27134CB440A00499
sti0: 382V, 2048x512 frame buffer, 640x480x8 display
sti0: 8x16 font type 1, 16 bpc, charset 0-255
wsdisplay0 at sti0 mux 1: console (std, vt100 emulation)

Boot blocks updates tested on DIO-II 425t (serial/glass console), SGC 425e
(serial/glass console) and 382 (serial/glass console). And will be tested
on SGC 425t soon as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.62 2011/04/07 15:30:16 miod Exp $	*/
d1053 1
a1053 1
				    (u_int)scr->scr_bcmap[i]);
@


1.62
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.61 2009/09/05 14:09:35 miod Exp $	*/
d1329 1
a1329 1
#if NSTI_SGC > 0
d1332 1
a1332 2
 * Early console support.
 * Only used on hp300 with unique sti@@sgc attachment.
@


1.61
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.60 2009/02/06 22:51:04 miod Exp $	*/
d352 1
a352 1
	(dd->dd_pacode[(i)] == 0 ? NULL : \
@


1.60
log
@Split sti structures into rom-related information and screen-related
information. This is preliminary work to help eventually supporting the
dual-head ELK model.

Also split the initialization code in several routines, this makes the
code easier to read, and makes it easier to release resources upon failure.

Finally, don't forget to clear the text planes on non-console displays
when initializing.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.59 2009/02/06 20:27:40 miod Exp $	*/
d57 5
a61 5
void	sti_copycols(void *, int, int, int, int);
void	sti_copyrows(void *, int, int, int);
void	sti_cursor(void *, int, int, int);
void	sti_erasecols(void *, int, int, int, long);
void	sti_eraserows(void *, int, int, long);
d63 1
a63 1
void	sti_putchar(void *, int, int, u_int, long);
d1122 1
a1122 1
void
d1132 2
d1192 1
a1192 1
void
d1249 2
d1253 1
a1253 1
void
d1263 2
d1267 1
a1267 1
void
d1277 2
d1281 1
a1281 1
void
d1289 2
d1293 1
a1293 1
void
d1301 2
@


1.59
log
@The new font selection logic would loop and consume all kmem on proms
with only one font (such as many 712 onboard graphics). Oops again (poukram).
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.58 2009/01/29 21:00:05 miod Exp $	*/
d56 9
a64 9
void sti_cursor(void *v, int on, int row, int col);
int  sti_mapchar(void *v, int uni, u_int *index);
void sti_putchar(void *v, int row, int col, u_int uc, long attr);
void sti_copycols(void *v, int row, int srccol, int dstcol, int ncols);
void sti_erasecols(void *v, int row, int startcol, int ncols, long attr);
void sti_copyrows(void *v, int srcrow, int dstrow, int nrows);
void sti_eraserows(void *v, int row, int nrows, long attr);
int  sti_alloc_attr(void *v, int fg, int bg, int flags, long *pattr);
void sti_unpack_attr(void *v, long attr, int *fg, int *bg, int *ul);
d78 7
a84 8
int sti_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p);
paddr_t sti_mmap(void *v, off_t offset, int prot);
int sti_alloc_screen(void *v, const struct wsscreen_descr *type,
	void **cookiep, int *cxp, int *cyp, long *defattr);
	void sti_free_screen(void *v, void *cookie);
int sti_show_screen(void *v, void *cookie, int waitok,
	void (*cb)(void *, int, int), void *cbarg);
int sti_load_font(void *v, void *cookie, struct wsdisplay_font *);
d92 1
a92 1
	sti_load_font
d99 18
a116 10
int sti_init(struct sti_screen *scr, int mode);
int sti_inqcfg(struct sti_screen *scr, struct sti_inqconfout *out);
void sti_bmove(struct sti_screen *scr, int, int, int, int, int, int,
    enum sti_bmove_funcs);
int sti_setcment(struct sti_screen *scr, u_int i, u_char r, u_char g, u_char b);
int sti_fetchfonts(struct sti_screen *scr, struct sti_inqconfout *cfg,
    u_int32_t baseaddr, u_int fontindex);
int sti_screen_setup(struct sti_screen *scr, bus_space_tag_t iot,
    bus_space_tag_t memt, bus_space_handle_t romh, bus_addr_t *bases,
    u_int codebase);
d134 10
d145 34
a178 3
sti_attach_common(sc, codebase)
	struct sti_softc *sc;
	u_int codebase;
d183 2
a184 1
	scr = malloc(sizeof(*scr), M_DEVBUF, M_NOWAIT | M_ZERO);
d187 1
a187 1
		return (ENOMEM);
d190 3
a192 5
	sc->sc_scr = scr;
	scr->scr_main = sc;

	if ((rc = sti_screen_setup(scr, sc->iot, sc->memt, sc->romh, sc->bases,
	    codebase)) != 0) {
d194 1
a194 2
		sc->sc_scr = NULL;
		return (rc);
d197 3
a199 2
	sti_describe(sc);
	return (0);
d203 2
a204 3
sti_screen_setup(struct sti_screen *scr, bus_space_tag_t iot,
    bus_space_tag_t memt, bus_space_handle_t romh, bus_addr_t *bases,
    u_int codebase)
a205 3
	struct sti_inqconfout cfg;
	struct sti_einqconfout ecfg;
	bus_space_handle_t fbh;
a206 1
	struct sti_cfg *cc;
a207 2
	int geometry_kluge = 0;
	u_int fontindex = 0;
d209 6
a214 1
	STI_ENABLE_ROM(scr->scr_main);
d216 3
a218 17
	scr->iot = iot;
	scr->memt = memt;
	scr->romh = romh;
	scr->bases = bases;
	scr->scr_devtype = bus_space_read_1(memt, romh, 3);

	/* { extern int pmapdebug; pmapdebug = 0xfffff; } */
	dd = &scr->scr_dd;
	if (scr->scr_devtype == STI_DEVTYPE1) {
#define	parseshort(o) \
	((bus_space_read_1(memt, romh, (o) + 3) <<  8) | \
	 (bus_space_read_1(memt, romh, (o) + 7)))
#define	parseword(o) \
	((bus_space_read_1(memt, romh, (o) +  3) << 24) | \
	 (bus_space_read_1(memt, romh, (o) +  7) << 16) | \
	 (bus_space_read_1(memt, romh, (o) + 11) <<  8) | \
	 (bus_space_read_1(memt, romh, (o) + 15)))
d220 27
a246 24
		dd->dd_type  = bus_space_read_1(memt, romh, 0x03);
		dd->dd_nmon  = bus_space_read_1(memt, romh, 0x07);
		dd->dd_grrev = bus_space_read_1(memt, romh, 0x0b);
		dd->dd_lrrev = bus_space_read_1(memt, romh, 0x0f);
		dd->dd_grid[0] = parseword(0x10);
		dd->dd_grid[1] = parseword(0x20);
		dd->dd_fntaddr = parseword(0x30) & ~3;
		dd->dd_maxst   = parseword(0x40);
		dd->dd_romend  = parseword(0x50) & ~3;
		dd->dd_reglst  = parseword(0x60) & ~3;
		dd->dd_maxreent= parseshort(0x70);
		dd->dd_maxtimo = parseshort(0x78);
		dd->dd_montbl  = parseword(0x80) & ~3;
		dd->dd_udaddr  = parseword(0x90) & ~3;
		dd->dd_stimemreq=parseword(0xa0);
		dd->dd_udsize  = parseword(0xb0);
		dd->dd_pwruse  = parseshort(0xc0);
		dd->dd_bussup  = bus_space_read_1(memt, romh, 0xcb);
		dd->dd_ebussup = bus_space_read_1(memt, romh, 0xcf);
		dd->dd_altcodet= bus_space_read_1(memt, romh, 0xd3);
		dd->dd_eddst[0]= bus_space_read_1(memt, romh, 0xd7);
		dd->dd_eddst[1]= bus_space_read_1(memt, romh, 0xdb);
		dd->dd_eddst[2]= bus_space_read_1(memt, romh, 0xdf);
		dd->dd_cfbaddr = parseword(0xe0) & ~3;
d273 1
a273 1
	STI_DISABLE_ROM(scr->scr_main);
d277 1
a277 1
	    "devtype=%x, rev=%x;%d, altt=%x, gid=%016llx, font=%x, mss=%x\n"
d282 1
a282 1
	    *(u_int64_t *)dd->dd_grid, dd->dd_fntaddr, dd->dd_maxst,
d294 9
a302 2
	/* devise code size, could be less than STI_END entries */
	for (i = STI_END; !dd->dd_pacode[i]; i--);
d304 1
a304 1
	if (scr->scr_devtype == STI_DEVTYPE1)
d310 2
a311 1
	if (!(scr->scr_code = uvm_km_alloc(kernel_map, round_page(size)))) {
d316 1
a316 1
	printf("code=0x%x[%x]\n", scr->scr_code, size);
d319 5
a323 1
	STI_ENABLE_ROM(scr->scr_main);
d325 2
a326 3
	/* copy code into memory */
	if (scr->scr_devtype == STI_DEVTYPE1) {
		u_int8_t *p = (u_int8_t *)scr->scr_code;
d335 1
a335 1
		    dd->dd_pacode[STI_BEGIN], (u_int8_t *)scr->scr_code,
d338 31
a368 1
	STI_DISABLE_ROM(scr->scr_main);
d370 1
a370 17
#define	O(i)	(dd->dd_pacode[(i)]? (scr->scr_code + \
	(dd->dd_pacode[(i)] - dd->dd_pacode[0]) / \
	(scr->scr_devtype == STI_DEVTYPE1? 4 : 1)) : NULL)

	scr->init	= (sti_init_t)	O(STI_INIT_GRAPH);
	scr->mgmt	= (sti_mgmt_t)	O(STI_STATE_MGMT);
	scr->unpmv	= (sti_unpmv_t)	O(STI_FONT_UNPMV);
	scr->blkmv	= (sti_blkmv_t)	O(STI_BLOCK_MOVE);
	scr->test	= (sti_test_t)	O(STI_SELF_TEST);
	scr->exhdl	= (sti_exhdl_t)	O(STI_EXCEP_HDLR);
	scr->inqconf	= (sti_inqconf_t)O(STI_INQ_CONF);
	scr->scment	= (sti_scment_t)O(STI_SCM_ENT);
	scr->dmac	= (sti_dmac_t)	O(STI_DMA_CTRL);
	scr->flowc	= (sti_flowc_t)	O(STI_FLOW_CTRL);
	scr->utiming	= (sti_utiming_t)O(STI_UTIMING);
	scr->pmgr	= (sti_pmgr_t)	O(STI_PROC_MGR);
	scr->util	= (sti_util_t)	O(STI_UTIL);
d377 1
a377 1
		scr->scment = NULL;
d380 2
a381 6
	if ((error = uvm_map_protect(kernel_map, scr->scr_code,
	    scr->scr_code + round_page(size), UVM_PROT_RX, FALSE))) {
		printf(": uvm_map_protect failed (%d)\n", error);
		uvm_km_free(kernel_map, scr->scr_code, round_page(size));
		return (error);
	}
d383 16
a398 19
	cc = &scr->scr_cfg;
	bzero(cc, sizeof (*cc));
	cc->ext_cfg = &scr->scr_ecfg;
	bzero(cc->ext_cfg, sizeof(*cc->ext_cfg));
	if (dd->dd_stimemreq) {
		scr->scr_ecfg.addr =
		    malloc(dd->dd_stimemreq, M_DEVBUF, M_NOWAIT);
		if (!scr->scr_ecfg.addr) {
			printf("cannot allocate %d bytes for STI\n",
			    dd->dd_stimemreq);
			uvm_km_free(kernel_map, scr->scr_code,
			    round_page(size));
			return (ENOMEM);
		}
	}
	{
		int i = dd->dd_reglst;
		u_int32_t *p;
		struct sti_region r;
d401 1
a401 1
		printf("stiregions @@%p:\n", i);
d404 33
a436 1
		STI_ENABLE_ROM(scr->scr_main);
d438 4
a441 12
		r.last = 0;
		for (p = cc->regions; !r.last &&
		     p < &cc->regions[STI_REGION_MAX]; p++) {

			if (scr->scr_devtype == STI_DEVTYPE1) {
				*(u_int *)&r = parseword(i);
				i += 16;
			} else {
				bus_space_read_raw_region_4(memt, romh, i,
				    (u_int8_t *)&r, 4);
				i += 4;
			}
a442 1
			*p = bases[p - cc->regions] + (r.offset << PGSHIFT);
d444 4
a447 6
			STI_DISABLE_ROM(scr->scr_main);
			printf("%08x @@ 0x%08x%s%s%s%s\n",
			    r.length << PGSHIFT, *p, r.sys_only? " sys" : "",
			    r.cache? " cache" : "", r.btlb? " btlb" : "",
			    r.last? " last" : "");
			STI_ENABLE_ROM(scr->scr_main);
d450 9
a458 3
			/* skip rom if it has already been mapped */
			if (p == cc->regions && romh == bases[0])
				continue;
d460 2
a461 2
			if (bus_space_map(memt, *p, r.length << PGSHIFT,
			    r.cache ? BUS_SPACE_MAP_CACHEABLE : 0, &fbh)) {
d463 1
a463 3
				STI_DISABLE_ROM(scr->scr_main);
				printf("already mapped region\n");
				STI_ENABLE_ROM(scr->scr_main);
d465 6
a470 6
			} else {
				if (p - cc->regions == 1) {
					scr->fbaddr = *p;
					scr->fblen = r.length << PGSHIFT;
				}
				*p = fbh;
d474 1
a474 1
		STI_DISABLE_ROM(scr->scr_main);
d477 40
d519 1
a519 2
		/* XXX free resources */
		return (ENXIO);
d527 1
a527 2
		/* XXX free resources */
		return (ENXIO);
d547 1
a547 1
	 * Save a few fields for sti_describe() later
d555 1
a555 1
	if ((error = sti_init(scr, STI_TEXTMODE))) {
d557 1
a557 2
		/* XXX free resources */
		return (ENXIO);
a558 1

d575 1
a575 1
		STI_ENABLE_ROM(scr->scr_main);
d581 1
a581 1
			if (scr->scr_devtype == STI_DEVTYPE1) {
a591 5
#ifdef STIDEBUG
				STI_DISABLE_ROM(scr->scr_main);
				printf("font index: %d\n", fontindex);
				STI_ENABLE_ROM(scr->scr_main);
#endif
d596 5
a600 1
		STI_DISABLE_ROM(scr->scr_main);
d605 1
a605 2
		/* XXX free resources */
		return (ENXIO);
d628 8
a635 1
	/* { extern int pmapdebug; pmapdebug = 0; } */
d637 1
a637 1
	return (0);
d641 1
a641 1
sti_describe(struct sti_softc *sc)
a642 2
	struct sti_screen *scr = sc->sc_scr;
	struct sti_dd *dd = &scr->scr_dd;
d645 3
a647 8
	printf(": %s rev %d.%02d;%d, ID 0x%016llX\n",
	    scr->name, dd->dd_grrev >> 4, dd->dd_grrev & 0xf,
	    dd->dd_lrrev, *(u_int64_t *)dd->dd_grid);

	printf("%s: %dx%d frame buffer, %dx%dx%d display, offset %dx%d\n",
	    sc->sc_dev.dv_xname, scr->fbwidth, scr->fbheight,
	    scr->scr_cfg.scr_width, scr->scr_cfg.scr_height, scr->scr_bpp,
	    scr->owidth, scr->oheight);
d655 19
d676 10
a685 1
	struct sti_softc *sc = v;
d688 1
a688 1
	sc->sc_wsmode = WSDISPLAYIO_MODE_EMUL;
d690 2
a691 2
	waa.console = sc->sc_flags & STI_CONSOLE ? 1 : 0;
	waa.scrdata = &sc->sc_scr->scr_screenlist;
d693 1
a693 1
	waa.accesscookie = sc;
d697 1
a697 1
	if (waa.console && !ISSET(sc->sc_flags, STI_ATTACHED)) {
d700 3
a702 3
		sti_alloc_attr(sc, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&sc->sc_scr->scr_wsd, sc->sc_scr,
		    0, sc->sc_scr->scr_wsd.nrows - 1, defattr);
d710 1
a710 1
sti_rom_size(bus_space_tag_t iot, bus_space_handle_t ioh)
d715 1
a715 1
	devtype = bus_space_read_1(iot, ioh, 3);
d717 1
a717 1
		bus_space_read_raw_region_4(iot, ioh, 0x18,
d720 1
a720 5
		romend =
		    (bus_space_read_1(iot, ioh, 0x50 +  3) << 24) |
		    (bus_space_read_1(iot, ioh, 0x50 +  7) << 16) |
		    (bus_space_read_1(iot, ioh, 0x50 + 11) <<  8) |
		    (bus_space_read_1(iot, ioh, 0x50 + 15));
d730 3
a735 2
	bus_space_tag_t memt;
	bus_space_handle_t romh;
a744 3
	memt = scr->memt;
	romh = scr->romh;

d749 1
a749 1
	STI_ENABLE_ROM(scr->scr_main);
d754 1
a754 1
		if (scr->scr_devtype == STI_DEVTYPE1) {
d776 1
a776 1
		STI_DISABLE_ROM(scr->scr_main);
d780 1
a780 1
		STI_ENABLE_ROM(scr->scr_main);
d786 1
a786 1
			if (scr->scr_devtype == STI_DEVTYPE1)
d811 1
a811 1
	STI_DISABLE_ROM(scr->scr_main);
d854 4
d859 1
a859 3
sti_init(scr, mode)
	struct sti_screen *scr;
	int mode;
d861 1
d872 3
a874 2
	    (mode & STI_TEXTMODE? STI_INITF_TEXT | STI_INITF_PBET |
	     STI_INITF_PBETI | STI_INITF_ICMT : 0);
d879 1
a879 1
	    scr->init, a.flags.flags, &a.in, &a.out, &scr->scr_cfg);
d881 1
a881 1
	(*scr->init)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
d890 1
d899 1
a899 1
	(*scr->inqconf)(&a.flags, &a.in, out, &scr->scr_cfg);
d905 2
a906 4
sti_bmove(scr, x1, y1, x2, y2, h, w, f)
	struct sti_screen *scr;
	int x1, y1, x2, y2, h, w;
	enum sti_bmove_funcs f;
d908 1
d941 1
a941 1
	(*scr->blkmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
d951 1
d964 1
a964 1
	(*scr->scment)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
d969 4
d974 1
a974 6
sti_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d976 2
a977 2
	struct sti_softc *sc = v;
	struct sti_screen *scr = sc->sc_scr;
d987 1
a987 1
		if (sc->sc_wsmode == WSDISPLAYIO_MODE_EMUL &&
d990 1
a990 1
		else if (sc->sc_wsmode == WSDISPLAYIO_MODE_DUMBFB &&
d993 1
a993 1
		sc->sc_wsmode = mode;
d1005 1
a1005 1
		if (scr->scment == NULL)
d1016 1
a1016 1
		if (scr->scment == NULL)
d1032 1
a1032 1
		if (scr->scment == NULL)
a1063 5
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
d1072 1
a1072 4
sti_mmap(v, offset, prot)
	void *v;
	off_t offset;
	int prot;
d1074 4
d1083 2
a1084 6
sti_alloc_screen(v, type, cookiep, cxp, cyp, defattr)
	void *v;
	const struct wsscreen_descr *type;
	void **cookiep;
	int *cxp, *cyp;
	long *defattr;
d1086 1
a1086 1
	struct sti_softc *sc = v;
d1088 1
a1088 1
	if (sc->sc_nscreens > 0)
d1091 1
a1091 1
	*cookiep = sc->sc_scr;
d1094 2
a1095 2
	sti_alloc_attr(sc, 0, 0, 0, defattr);
	sc->sc_nscreens++;
d1100 1
a1100 3
sti_free_screen(v, cookie)
	void *v;
	void *cookie;
d1102 1
a1102 1
	struct sti_softc *sc = v;
d1104 1
a1104 1
	sc->sc_nscreens--;
d1108 2
a1109 6
sti_show_screen(v, cookie, waitok, cb, cbarg)
	void *v;
	void *cookie;
	int waitok;
	void (*cb)(void *, int, int);
	void *cbarg;
d1111 4
d1118 3
a1120 8
int
sti_load_font(v, cookie, font)
	void *v;
	void *cookie;
	struct wsdisplay_font *font;
{
	return -1;
}
d1123 1
a1123 3
sti_cursor(v, on, row, col)
	void *v;
	int on, row, col;
d1125 1
a1125 1
	struct sti_screen *scr = v;
d1159 1
a1159 4
sti_mapchar(v, uni, index)
	void *v;
	int uni;
	u_int *index;
d1161 1
a1161 1
	struct sti_screen *scr = v;
d1191 1
a1191 5
sti_putchar(v, row, col, uc, attr)
	void *v;
	int row, col;
	u_int uc;
	long attr;
d1193 2
a1194 1
	struct sti_screen *scr = v;
d1218 1
a1218 1
		(*scr->unpmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
d1245 1
a1245 1
		(*scr->blkmv)(&a.flags, &a.in, &a.out, &scr->scr_cfg);
d1250 1
a1250 3
sti_copycols(v, row, srccol, dstcol, ncols)
	void *v;
	int row, srccol, dstcol, ncols;
d1252 1
a1252 1
	struct sti_screen *scr = v;
d1262 1
a1262 4
sti_erasecols(v, row, startcol, ncols, attr)
	void *v;
	int row, startcol, ncols;
	long attr;
d1264 1
a1264 1
	struct sti_screen *scr = v;
d1274 1
a1274 3
sti_copyrows(v, srcrow, dstrow, nrows)
	void *v;
	int srcrow, dstrow, nrows;
d1276 1
a1276 1
	struct sti_screen *scr = v;
d1284 1
a1284 4
sti_eraserows(v, srcrow, nrows, attr)
	void *v;
	int srcrow, nrows;
	long attr;
d1286 1
a1286 1
	struct sti_screen *scr = v;
d1294 1
a1294 4
sti_alloc_attr(v, fg, bg, flags, pattr)
	void *v;
	int fg, bg, flags;
	long *pattr;
d1296 3
a1298 1
	/* struct sti_screen *scr = v; */
a1300 1

d1307 4
d1320 2
a1321 1
 * Early console support
a1323 7
void
sti_clear(struct sti_screen *scr)
{
	sti_bmove(scr, 0, 0, 0, 0,
	    scr->scr_cfg.scr_height, scr->scr_cfg.scr_width, bmf_clear);
}

d1325 2
a1326 2
sti_cnattach(struct sti_screen *scr, bus_space_tag_t iot, bus_addr_t *bases,
    u_int codebase)
d1328 1
a1328 1
	bus_space_handle_t ioh;
d1333 1
a1333 1
	if ((error = bus_space_map(iot, bases[0], PAGE_SIZE, 0, &ioh)) != 0)
d1339 1
a1339 1
	romend = sti_rom_size(iot, ioh);
d1341 1
a1341 1
	bus_space_unmap(iot, ioh, PAGE_SIZE);
d1343 1
a1343 1
	if ((error = bus_space_map(iot, bases[0], romend, 0, &ioh)) != 0)
d1346 5
a1350 2
	bases[0] = ioh;
	if (sti_screen_setup(scr, iot, iot, ioh, bases, codebase) != 0)
@


1.58
log
@Oops, correct logic when requested font index is out of bounds. Thankfully
it's a can't happen situation.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.57 2009/01/28 17:37:40 miod Exp $	*/
d673 1
a673 1
	if (fp->next == 0) {
@


1.57
log
@If the rom contains a monitor table, look for an entry matching our
display resolution, and if one is found, pick the built-in font it points
to, instead of the first font from the list. If the index is wrong and the
font list is shorter, revert to the previous behaviour of using the first
ROM font.

This fixes the font discrepency on my B132L (INTERNAL_EG_1280) where PDC
would use the 10x20 font, which is third in the list, and OpenBSD would
use the 8x16 font instead.

Tested on byte- and word- roms, gsc and pci cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.56 2007/10/01 04:03:51 krw Exp $	*/
d673 1
a673 1
	if (addr == 0) {
@


1.56
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...'.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.55 2007/06/17 13:59:08 miod Exp $	*/
d106 1
a106 1
    u_int32_t addr);
d167 1
d260 1
a260 1
	/* divise code size, could be less than STI_END entries */
d358 4
a361 3
			if (scr->scr_devtype == STI_DEVTYPE1)
				*(u_int *)&r = parseword(i), i+= 16;
			else {
d455 37
a491 1
	if ((error = sti_fetchfonts(scr, &cfg, dd->dd_fntaddr))) {
d593 1
a593 1
    u_int32_t addr)
d596 1
d618 2
d632 1
a632 1
			fp->next   = parseword(addr + 0x23);
d637 1
a637 1
		} else	/* STI_DEVTYPE4 */
d640 18
d659 2
a660 7
		size = sizeof(struct sti_font) +
		    (fp->last - fp->first + 1) * fp->bpc;
		if (scr->scr_devtype == STI_DEVTYPE1)
			size *= 4;
		scr->scr_romfont = malloc(size, M_DEVBUF, M_NOWAIT);
		if (scr->scr_romfont == NULL)
			return (ENOMEM);
d662 2
a663 2
		bus_space_read_raw_region_4(memt, romh, addr,
		    (u_int8_t *)scr->scr_romfont, size);
d665 12
a676 2
		addr = NULL; /* fp->next */
	} while (addr);
a847 4
	case WSDISPLAYIO_GMODE:
		*(u_int *)data = sc->sc_wsmode;
		break;

@


1.55
log
@We can not consider the first sti region as always mapped, since on pci
cards it is no longer the rom image. This lets sti@@pci work on non-dino
bridges.
Found by and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.54 2007/06/17 13:57:44 miod Exp $	*/
d135 1
a135 1
	scr = malloc(sizeof(struct sti_screen), M_DEVBUF, M_NOWAIT);
a140 1
	bzero(scr, sizeof(struct sti_screen));
@


1.54
log
@Make sure to pass valid extended initialization structure pointers in
sti_init(), for recent sti proms require them. Also, return a meaningful
error value.
ok kettenis@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.53 2007/01/12 22:02:33 miod Exp $	*/
d376 6
a381 6
			/* rom has already been mapped */
			if (p != cc->regions) {
				if (bus_space_map(memt, *p,
				    r.length << PGSHIFT,
				    r.cache ? BUS_SPACE_MAP_CACHEABLE : 0,
				    &fbh)) {
d383 3
a385 3
					STI_DISABLE_ROM(scr->scr_main);
					printf("already mapped region\n");
					STI_ENABLE_ROM(scr->scr_main);
d387 4
a390 6
				} else {
					if (p - cc->regions == 1) {
						scr->fbaddr = *p;
						scr->fblen = r.length << PGSHIFT;
					}
					*p = fbh;
d392 1
@


1.53
log
@Keep the wsscreen_descr in the softc, to allow sti of different text
resolutions to attach without disturbing each other.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.52 2007/01/11 22:02:03 miod Exp $	*/
d331 1
a331 1
	bzero(&cc->ext_cfg, sizeof(*cc->ext_cfg));
d667 1
d677 1
d683 3
a685 1
	return (a.out.text_planes != a.in.text_planes || a.out.errno);
@


1.52
log
@Add the ability for a sti backend to specify callbacks to disable and enable
access to the sti rom, as this seems to be necessary for sti@@pci; hide this
with macros so that platforms which do not have pci support (i.e. hp300)
do not get bloated from this.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.51 2007/01/11 21:58:05 miod Exp $	*/
a95 16
struct wsscreen_descr sti_default_screen = {
	"default", 0, 0,
	&sti_emulops,
	0, 0,
	0
};

const struct wsscreen_descr *sti_default_scrlist[] = {
	&sti_default_screen
};

struct wsscreen_list sti_default_screenlist = {
	sizeof(sti_default_scrlist) / sizeof(sti_default_scrlist[0]),
	sti_default_scrlist
};

d462 1
a462 1
	 * parse screen descriptions:
d468 12
a479 4
	sti_default_screen.ncols = cfg.width / scr->scr_curfont.width;
	sti_default_screen.nrows = cfg.height / scr->scr_curfont.height;
	sti_default_screen.fontwidth = scr->scr_curfont.width;
	sti_default_screen.fontheight = scr->scr_curfont.height;
d516 1
a516 1
	waa.scrdata = &sti_default_screenlist;
d526 2
a527 2
		wsdisplay_cnattach(&sti_default_screen, sc->sc_scr,
		    0, sti_default_screen.nrows - 1, defattr);
d1189 1
a1189 1
	wsdisplay_cnattach(&sti_default_screen, scr, 0, 0, defattr);
@


1.51
log
@Allow sti_attach_common() to return an error code, and do not fall into
sti_end_attach() if an error has occured.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.50 2006/12/18 18:58:37 miod Exp $	*/
a34 2
#include "wsdisplay.h"

d50 2
d127 16
d159 1
d185 2
d255 2
d293 2
d309 2
d314 1
d367 3
d384 1
d389 1
d399 1
d401 1
d412 2
d586 3
d624 2
d1157 2
d1160 1
a1160 1
 * Console support
d1201 2
@


1.50
log
@Read word-mode rom regions with bus_space_read_raw_region instead of
bus_space_region, for they might lie on a bus with a different endianness than
the cpu.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.48 2006/12/16 15:52:30 miod Exp $	*/
d123 1
a123 1
void sti_screen_setup(struct sti_screen *scr, bus_space_tag_t iot,
d127 1
a127 1
void
d133 1
d138 1
a138 1
		return;
d144 7
a150 2
	sti_screen_setup(scr, sc->iot, sc->memt, sc->romh, sc->bases,
	    codebase);
d152 1
d155 1
a155 1
void
d260 4
d266 1
a266 1
		return;
d315 1
a315 1
		return;
d330 1
a330 1
			return;
d383 2
a384 1
		return;
d392 2
a393 1
		return;
d423 2
a424 1
		return;
d438 2
a439 1
		return;
d455 2
d1151 2
a1152 1
	sti_screen_setup(scr, iot, iot, ioh, bases, codebase);
@


1.49
log
@Change sti attachment to pass an array of base addresses for the sti regions,
instead of using the rom mapping for region #0 and the device mapping for
region #1. This will allow sti devices on which regions may be relative to
different origins to attach (to be used very soon).

ok mickey@@
@
text
@d222 2
a223 2
		bus_space_read_region_4(memt, romh, 0, (u_int32_t *)dd,
		    sizeof(*dd) / 4);
d225 2
a226 2
		bus_space_read_region_4(memt, romh, codebase,
		    (u_int32_t *)dd->dd_pacode, sizeof(dd->dd_pacode) / 4);
d271 3
a273 3
		bus_space_read_region_4(memt, romh,
		    dd->dd_pacode[STI_BEGIN], (u_int32_t *)scr->scr_code,
		    size / 4);
d336 5
a340 2
			else
				*(u_int *)&r = bus_space_read_4(memt, romh, i), i += 4;
d498 2
a499 1
		romend = bus_space_read_4(iot, ioh, 0x18);
d552 2
a553 2
			bus_space_read_region_4(memt, romh, addr,
			    (u_int32_t *)fp, sizeof(struct sti_font) / 4);
d563 2
a564 2
		bus_space_read_region_4(memt, romh, addr,
		    (u_int32_t *)scr->scr_romfont, size / 4);
@


1.48
log
@Better sti_mapchar() implementation, matches Latin char indexes to HP Roman
font indicies whenever possible.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.47 2006/11/29 19:08:22 miod Exp $	*/
d124 1
a124 1
    bus_space_tag_t memt, bus_space_handle_t romh, bus_addr_t base,
d143 1
a143 1
	sti_screen_setup(scr, sc->iot, sc->memt, sc->romh, sc->base,
d150 1
a150 1
    bus_space_tag_t memt, bus_space_handle_t romh, bus_addr_t base,
d164 1
d339 1
a339 2
			*p = (p == cc->regions? romh : base) +
			    (r.offset << PGSHIFT);
d341 1
a341 1
			printf("%x @@ 0x%x%s%s%s%s\n",
d1108 1
a1108 1
sti_cnattach(struct sti_screen *scr, bus_space_tag_t iot, bus_addr_t base,
d1116 1
a1116 1
	if ((error = bus_space_map(iot, base, PAGE_SIZE, 0, &ioh)) != 0)
d1126 1
a1126 1
	if ((error = bus_space_map(iot, base, romend, 0, &ioh)) != 0)
d1129 2
a1130 1
	sti_screen_setup(scr, iot, iot, ioh, base, codebase);
@


1.47
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.46 2006/11/29 12:15:27 miod Exp $	*/
d899 24
d929 24
a952 2
	if (uni < 256)
		*index = uni;
d954 2
a955 1
	return 1;
@


1.46
log
@Use uvm_km_alloc() instead of uvm_km_alloc1(), so that the latter can
change within uvm without breaking code. From art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.45 2006/11/29 12:13:54 miod Exp $	*/
d63 2
a64 1
int  sti_alloc_attr(void *v, int fg, int bg, int flags, long *);
d74 2
a75 1
	sti_alloc_attr
d100 1
a100 1
	WSSCREEN_REVERSE | WSSCREEN_UNDERLINE
d1038 9
@


1.45
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.44 2006/08/22 21:04:32 miod Exp $	*/
d250 1
a250 1
	if (!(scr->scr_code = uvm_km_alloc1(kernel_map, round_page(size), 0))) {
@


1.44
log
@Clear sti display on console attach, now that the bootloader leaves us
with scribbles around; ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.43 2006/04/16 21:03:45 miod Exp $	*/
d470 1
@


1.43
log
@Introduce sti_rom_size() which will compute the size of a card's rom, and
use it instead of duplicating the same logic in 3 places.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.42 2005/02/27 22:10:57 miod Exp $	*/
d1040 7
@


1.42
log
@Split sti softc in two structures, one device-related for regular device
attachment and interface, one screen-attached for the real work.

The attachment code is now required to decide whether sti_end_attach() is
run immediately, or as a startuphook.

This allows hp300 to initialize sti early, and use it as a console; hppa
is functionally unchanged, as it uses the PROM console until the root device
is mounted.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.41 2005/01/24 19:20:04 miod Exp $	*/
d484 20
d1046 1
a1046 2
	int devtype;
	u_int32_t romend;
d1056 1
a1056 10
	devtype = bus_space_read_1(iot, ioh, 3);
	if (devtype == STI_DEVTYPE4) {
		romend = bus_space_read_4(iot, ioh, 0x18);
	} else {
		romend =
		    (bus_space_read_1(iot, ioh, 0x50 +  3) << 24) |
		    (bus_space_read_1(iot, ioh, 0x50 +  7) << 16) |
		    (bus_space_read_1(iot, ioh, 0x50 + 11) <<  8) |
		    (bus_space_read_1(iot, ioh, 0x50 + 15));
	}
a1059 1
	romend = round_page(romend);
@


1.41
log
@sti colormap fixes:
- correct bounds checking in colormap ioctls.
- force the scment() pointer to NULL on < 8.04 revisions; 8.02 provide a
  non-NULL pointer, but it does not point to any meaningful piece of code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.40 2005/01/23 16:55:18 miod Exp $	*/
d114 3
a116 3
int sti_init(struct sti_softc *sc, int mode);
int sti_inqcfg(struct sti_softc *sc, struct sti_inqconfout *out);
void sti_bmove(struct sti_softc *sc, int, int, int, int, int, int,
d118 2
a119 2
int sti_setcment(struct sti_softc *sc, u_int i, u_char r, u_char g, u_char b);
int sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg,
d121 3
a123 1
void sti_attach_deferred(void *);
d130 21
d159 4
a162 1
	sc->sc_devtype = bus_space_read_1(sc->memt, sc->romh, 3);
d165 2
a166 2
	dd = &sc->sc_dd;
	if (sc->sc_devtype == STI_DEVTYPE1) {
d168 2
a169 2
	((bus_space_read_1(sc->memt, sc->romh, (o) + 3) <<  8) | \
	 (bus_space_read_1(sc->memt, sc->romh, (o) + 7)))
d171 9
a179 9
	((bus_space_read_1(sc->memt, sc->romh, (o) +  3) << 24) | \
	 (bus_space_read_1(sc->memt, sc->romh, (o) +  7) << 16) | \
	 (bus_space_read_1(sc->memt, sc->romh, (o) + 11) <<  8) | \
	 (bus_space_read_1(sc->memt, sc->romh, (o) + 15)))

		dd->dd_type  = bus_space_read_1(sc->memt, sc->romh, 0x03);
		dd->dd_nmon  = bus_space_read_1(sc->memt, sc->romh, 0x07);
		dd->dd_grrev = bus_space_read_1(sc->memt, sc->romh, 0x0b);
		dd->dd_lrrev = bus_space_read_1(sc->memt, sc->romh, 0x0f);
d193 6
a198 6
		dd->dd_bussup  = bus_space_read_1(sc->memt, sc->romh, 0xcb);
		dd->dd_ebussup = bus_space_read_1(sc->memt, sc->romh, 0xcf);
		dd->dd_altcodet= bus_space_read_1(sc->memt, sc->romh, 0xd3);
		dd->dd_eddst[0]= bus_space_read_1(sc->memt, sc->romh, 0xd7);
		dd->dd_eddst[1]= bus_space_read_1(sc->memt, sc->romh, 0xdb);
		dd->dd_eddst[2]= bus_space_read_1(sc->memt, sc->romh, 0xdf);
d219 1
a219 1
		bus_space_read_region_4(sc->memt, sc->romh, 0, (u_int32_t *)dd,
d222 1
a222 1
		bus_space_read_region_4(sc->memt, sc->romh, codebase,
d248 1
a248 1
	if (sc->sc_devtype == STI_DEVTYPE1)
d250 1
a250 1
	if (!(sc->sc_code = uvm_km_alloc1(kernel_map, round_page(size), 0))) {
d255 1
a255 1
	printf("code=0x%x[%x]\n", sc->sc_code, size);
d259 2
a260 2
	if (sc->sc_devtype == STI_DEVTYPE1) {
		u_int8_t *p = (u_int8_t *)sc->sc_code;
d265 1
a265 1
			*p++ = bus_space_read_4(sc->memt, sc->romh, addr) & 0xff;
d268 2
a269 2
		bus_space_read_region_4(sc->memt, sc->romh,
		    dd->dd_pacode[STI_BEGIN], (u_int32_t *)sc->sc_code,
d272 1
a272 1
#define	O(i)	(dd->dd_pacode[(i)]? (sc->sc_code + \
d274 14
a287 14
	(sc->sc_devtype == STI_DEVTYPE1? 4 : 1)) : NULL)
	sc->init	= (sti_init_t)	O(STI_INIT_GRAPH);
	sc->mgmt	= (sti_mgmt_t)	O(STI_STATE_MGMT);
	sc->unpmv	= (sti_unpmv_t)	O(STI_FONT_UNPMV);
	sc->blkmv	= (sti_blkmv_t)	O(STI_BLOCK_MOVE);
	sc->test	= (sti_test_t)	O(STI_SELF_TEST);
	sc->exhdl	= (sti_exhdl_t)	O(STI_EXCEP_HDLR);
	sc->inqconf	= (sti_inqconf_t)O(STI_INQ_CONF);
	sc->scment	= (sti_scment_t)O(STI_SCM_ENT);
	sc->dmac	= (sti_dmac_t)	O(STI_DMA_CTRL);
	sc->flowc	= (sti_flowc_t)	O(STI_FLOW_CTRL);
	sc->utiming	= (sti_utiming_t)O(STI_UTIMING);
	sc->pmgr	= (sti_pmgr_t)	O(STI_PROC_MGR);
	sc->util	= (sti_util_t)	O(STI_UTIL);
d294 1
a294 1
		sc->scment = NULL;
d297 2
a298 2
	if ((error = uvm_map_protect(kernel_map, sc->sc_code,
	    sc->sc_code + round_page(size), UVM_PROT_RX, FALSE))) {
d300 1
a300 1
		uvm_km_free(kernel_map, sc->sc_code, round_page(size));
d304 1
a304 1
	cc = &sc->sc_cfg;
d306 1
a306 1
	cc->ext_cfg = &sc->sc_ecfg;
d309 3
a311 2
		sc->sc_ecfg.addr = malloc(dd->dd_stimemreq, M_DEVBUF, M_NOWAIT);
		if (!sc->sc_ecfg.addr) {
d314 2
a315 1
			uvm_km_free(kernel_map, sc->sc_code, round_page(size));
d331 1
a331 1
			if (sc->sc_devtype == STI_DEVTYPE1)
d334 1
a334 1
				*(u_int *)&r = bus_space_read_4(sc->memt, sc->romh, i), i += 4;
d336 1
a336 1
			*p = (p == cc->regions? sc->romh : sc->base) +
d347 1
a347 1
				if (bus_space_map(sc->memt, *p,
d356 2
a357 2
						sc->fbaddr = *p;
						sc->fblen = r.length << PGSHIFT;
d365 1
a365 1
	if ((error = sti_init(sc, 0))) {
d373 1
a373 1
	if ((error = sti_inqcfg(sc, &cfg))) {
d388 1
a388 1
		sc->sc_cfg.oscr_width = cfg.owidth =
d390 1
a390 1
		sc->sc_cfg.oscr_height = cfg.oheight =
d394 10
a403 1
	if ((error = sti_init(sc, STI_TEXTMODE))) {
d415 4
a418 12
	sc->sc_wsmode = WSDISPLAYIO_MODE_EMUL;
	sc->sc_bpp = cfg.bppu;
	printf(": %s rev %d.%02d;%d, ID 0x%016llX\n"
	    "%s: %dx%d frame buffer, %dx%dx%d display, offset %dx%d\n",
	    cfg.name, dd->dd_grrev >> 4, dd->dd_grrev & 0xf, dd->dd_lrrev,
	    *(u_int64_t *)dd->dd_grid,
	    sc->sc_dev.dv_xname, cfg.fbwidth, cfg.fbheight,
	    cfg.width, cfg.height, cfg.bppu, cfg.owidth, cfg.oheight);

	if ((error = sti_fetchfonts(sc, &cfg, dd->dd_fntaddr))) {
		printf("%s: cannot fetch fonts (%d)\n",
		    sc->sc_dev.dv_xname, error);
d429 4
a432 4
	sti_default_screen.ncols = cfg.width / sc->sc_curfont.width;
	sti_default_screen.nrows = cfg.height / sc->sc_curfont.height;
	sti_default_screen.fontwidth = sc->sc_curfont.width;
	sti_default_screen.fontheight = sc->sc_curfont.height;
d434 2
a435 3
#if NWSDISPLAY > 0
	startuphook_establish(sti_attach_deferred, sc);
#endif
d437 19
a455 1
	/* { extern int pmapdebug; pmapdebug = 0; } */
d459 1
a459 1
sti_attach_deferred(void *v)
d464 3
a466 1
	waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
d472 1
a472 1
	if (waa.console) {
d476 1
a476 1
		wsdisplay_cnattach(&sti_default_screen, sc,
d478 1
d485 2
a486 1
sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg, u_int32_t addr)
d488 1
a488 1
	struct sti_font *fp = &sc->sc_curfont;
d490 2
d501 3
d508 1
a508 1
		if (sc->sc_devtype == STI_DEVTYPE1) {
d511 1
a511 1
			fp->width  = bus_space_read_1(sc->memt, sc->romh,
d513 1
a513 1
			fp->height = bus_space_read_1(sc->memt, sc->romh,
d515 1
a515 1
			fp->type   = bus_space_read_1(sc->memt, sc->romh,
d517 1
a517 1
			fp->bpc    = bus_space_read_1(sc->memt, sc->romh,
d520 1
a520 1
			fp->uheight= bus_space_read_1(sc->memt, sc->romh,
d522 1
a522 1
			fp->uoffset= bus_space_read_1(sc->memt, sc->romh,
d525 1
a525 1
			bus_space_read_region_4(sc->memt, sc->romh, addr,
a527 4
		printf("%s: %dx%d font type %d, %d bpc, charset %d-%d\n",
		    sc->sc_dev.dv_xname, fp->width, fp->height,
		    fp->type,  fp->bpc, fp->first, fp->last);

d530 1
a530 1
		if (sc->sc_devtype == STI_DEVTYPE1)
d532 2
a533 2
		sc->sc_romfont = malloc(size, M_DEVBUF, M_NOWAIT);
		if (sc->sc_romfont == NULL)
d536 2
a537 2
		bus_space_read_region_4(sc->memt, sc->romh, addr,
		    (u_int32_t *)sc->sc_romfont, size / 4);
d554 1
a554 1
		a.in.font_addr = sc->sc_romfont;
d556 2
a557 2
		sc->sc_fontmaxcol = cfg->fbheight / fp->height;
		sc->sc_fontbase = cfg->width + cfg->owidth;
d559 3
a561 3
			a.in.x = ((uc - fp->first) / sc->sc_fontmaxcol) *
			    fp->width + sc->sc_fontbase;
			a.in.y = ((uc - fp->first) % sc->sc_fontmaxcol) *
d565 1
a565 1
			(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d567 4
a570 2
				printf("%s: unpmv %d returned %d\n",
				    sc->sc_dev.dv_xname, uc, a.out.errno);
d575 2
a576 2
		free(sc->sc_romfont, M_DEVBUF);
		sc->sc_romfont = NULL;
d584 2
a585 2
sti_init(sc, mode)
	struct sti_softc *sc;
d594 1
a594 1
	bzero(&a,  sizeof(a));
d601 2
a602 2
	printf("%s: init,%p(%x, %p, %p, %p)\n", sc->sc_dev.dv_xname,
	    sc->init, a.flags.flags, &a.in, &a.out, &sc->sc_cfg);
d604 1
a604 1
	(*sc->init)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d609 1
a609 3
sti_inqcfg(sc, out)
	struct sti_softc *sc;
	struct sti_inqconfout *out;
d616 1
a616 1
	bzero(&a,  sizeof(a));
d619 1
a619 1
	(*sc->inqconf)(&a.flags, &a.in, out, &sc->sc_cfg);
d625 2
a626 2
sti_bmove(sc, x1, y1, x2, y2, h, w, f)
	struct sti_softc *sc;
d662 1
a662 1
	(*sc->blkmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d665 1
a665 2
		printf("%s: blkmv returned %d\n",
		    sc->sc_dev.dv_xname, a.out.errno);
d670 1
a670 1
sti_setcment(struct sti_softc *sc, u_int i, u_char r, u_char g, u_char b)
d684 1
a684 1
	(*sc->scment)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d698 1
d714 1
a714 1
			ret = sti_init(sc, 0);
d717 1
a717 1
			ret = sti_init(sc, STI_TEXTMODE);
d727 4
a730 4
		wdf->height = sc->sc_cfg.scr_height;
		wdf->width  = sc->sc_cfg.scr_width;
		wdf->depth  = sc->sc_bpp;
		if (sc->scment == NULL)
d737 1
a737 1
		*(u_int *)data = sc->sc_cfg.fb_width;
d741 1
a741 1
		if (sc->scment == NULL)
d748 1
a748 1
		if ((ret = copyout(&sc->sc_rcmap[idx], cmapp->red, count)))
d750 1
a750 1
		if ((ret = copyout(&sc->sc_gcmap[idx], cmapp->green, count)))
d752 1
a752 1
		if ((ret = copyout(&sc->sc_bcmap[idx], cmapp->blue, count)))
d757 1
a757 1
		if (sc->scment == NULL)
d764 1
a764 1
		if ((ret = copyin(cmapp->red, &sc->sc_rcmap[idx], count)))
d766 1
a766 1
		if ((ret = copyin(cmapp->green, &sc->sc_gcmap[idx], count)))
d768 1
a768 1
		if ((ret = copyin(cmapp->blue, &sc->sc_bcmap[idx], count)))
d771 2
a772 2
			if ((ret = sti_setcment(sc, i, sc->sc_rcmap[i],
			    sc->sc_gcmap[i], sc->sc_bcmap[i]))) {
d776 3
a778 3
				    (u_int)sc->sc_rcmap[i],
				    (u_int)sc->sc_gcmap[i],
				    (u_int)sc->sc_bcmap[i]);
d824 1
a824 1
	*cookiep = sc;
d867 2
a868 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d870 1
a870 1
	sti_bmove(sc,
d895 2
a896 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d898 1
a898 1
	if (sc->sc_romfont != NULL) {
d916 1
a916 1
		a.in.font_addr = sc->sc_romfont;
d919 1
a919 1
		(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d937 3
a939 3
		a.in.srcx = ((uc - fp->first) / sc->sc_fontmaxcol) *
		    fp->width + sc->sc_fontbase;
		a.in.srcy = ((uc - fp->first) % sc->sc_fontmaxcol) *
d946 1
a946 1
		(*sc->blkmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d955 2
a956 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d958 1
a958 1
	sti_bmove(sc,
d970 2
a971 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d973 1
a973 1
	sti_bmove(sc,
d984 2
a985 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d987 2
a988 2
	sti_bmove(sc, 0, srcrow * fp->height, 0, dstrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_copy);
d997 2
a998 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d1000 2
a1001 2
	sti_bmove(sc, 0, srcrow * fp->height, 0, srcrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_clear);
d1010 1
a1010 1
	/* struct sti_softc *sc = v; */
d1015 45
@


1.40
log
@bus_space_map() sti regions with BUS_SPACE_MAP_CACHEABLE if they have the
cache bit set in the region descriptor.  Halves sti processing time on hp300.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.39 2005/01/23 16:53:21 miod Exp $	*/
d263 8
d679 4
a682 1
		wdf->cmsize = STI_NCMAP;
d691 1
a691 1
			return ENOTTY;
d695 1
a695 1
		if (idx > STI_NCMAP || idx + count >= STI_NCMAP)
d707 1
a707 1
			return ENOTTY;
d711 1
a711 1
		if (idx > STI_NCMAP || idx + count >= STI_NCMAP)
d744 1
a744 1
		return (ENOTTY);	/* not supported yet */
@


1.39
log
@Two sti(4) changes necessary for hp300:
- specify which microcode bank (pa or m68k) to use at attachment time.
- compensate for broken 8.02 m68k code which reports wrong frame buffer
  offset.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.38 2005/01/05 23:04:25 miod Exp $	*/
d312 3
a314 1
				    r.length << PGSHIFT, 0, &fbh)) {
@


1.38
log
@Let wsdisplay drivers return zero for WSDISPLAYIO_[GS]VIDEO ioctls - most
of the work is done in the upper layer, but they get to see the ioctl,
so don't always return an error.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.37 2004/11/03 19:18:47 mickey Exp $	*/
d124 1
a124 1
sti_attach_common(sc)
d126 1
d134 1
d175 18
a192 17
		dd->dd_pacode[0x0] = parseword(0x100) & ~3;
		dd->dd_pacode[0x1] = parseword(0x110) & ~3;
		dd->dd_pacode[0x2] = parseword(0x120) & ~3;
		dd->dd_pacode[0x3] = parseword(0x130) & ~3;
		dd->dd_pacode[0x4] = parseword(0x140) & ~3;
		dd->dd_pacode[0x5] = parseword(0x150) & ~3;
		dd->dd_pacode[0x6] = parseword(0x160) & ~3;
		dd->dd_pacode[0x7] = parseword(0x170) & ~3;
		dd->dd_pacode[0x8] = parseword(0x180) & ~3;
		dd->dd_pacode[0x9] = parseword(0x190) & ~3;
		dd->dd_pacode[0xa] = parseword(0x1a0) & ~3;
		dd->dd_pacode[0xb] = parseword(0x1b0) & ~3;
		dd->dd_pacode[0xc] = parseword(0x1c0) & ~3;
		dd->dd_pacode[0xd] = parseword(0x1d0) & ~3;
		dd->dd_pacode[0xe] = parseword(0x1e0) & ~3;
		dd->dd_pacode[0xf] = parseword(0x1f0) & ~3;
	} else	/* STI_DEVTYPE4 */
d195 4
d340 16
d923 1
a923 2
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, dstrow * fp->height,
d936 1
a936 2
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, srcrow * fp->height,
a951 1

@


1.37
log
@oops missed to set devtype here rather than in sti_sgc.c:1.23
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.36 2004/09/14 22:27:04 mickey Exp $	*/
d700 2
@


1.36
log
@allocate ext-cfg memory if was requestd in dd_stimemreq
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.35 2003/12/16 06:07:13 mickey Exp $	*/
d133 2
@


1.35
log
@only map the rom and do not touch the hpa space getting rid of memsize define that was not really true; plus tested by otto@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.34 2003/10/21 18:58:49 jmc Exp $	*/
d263 11
@


1.34
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.33 2003/08/21 18:06:56 mickey Exp $	*/
d280 1
a280 1
			*p = (p == cc->regions? sc->romh : sc->ioh) +
d296 7
a302 2
				} else if (p - cc->regions == 1)
					sc->fbh = fbh;
@


1.33
log
@fix the offsets in decoding byte rom dd (verified per manual); miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.32 2003/08/19 03:13:07 mickey Exp $	*/
d346 1
a346 1
	 *	calculate dimentions.
@


1.32
log
@give better depth and cmsize
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.31 2003/08/19 02:52:38 mickey Exp $	*/
d146 4
a149 4
		dd->dd_type  = bus_space_read_1(sc->memt, sc->romh, 3);
		dd->dd_nmon  = bus_space_read_1(sc->memt, sc->romh, 7);
		dd->dd_grrev = bus_space_read_1(sc->memt, sc->romh, 11);
		dd->dd_lrrev = bus_space_read_1(sc->memt, sc->romh, 15);
d158 12
a169 10
				/* what happened to 0x80 ? */
		dd->dd_montbl  = parseword(0x90);
		dd->dd_udaddr  = parseword(0xa0) & ~3;
		dd->dd_stimemreq=parseword(0xb0);
		dd->dd_udsize  = parseword(0xc0);
		dd->dd_pwruse  = parseshort(0xd0);
		dd->dd_bussup  = bus_space_read_1(sc->memt, sc->romh, 0xdb);
		dd->dd_ebussup = bus_space_read_1(sc->memt, sc->romh, 0xdf);
		dd->dd_altcodet= bus_space_read_1(sc->memt, sc->romh, 0xe3);
		dd->dd_cfbaddr = parseword(0xf0) & ~3;
@


1.31
log
@implement WSDISPLAYIO_{GET,PUT}CMAP; untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.30 2003/08/19 02:25:11 mickey Exp $	*/
d326 1
d625 2
a626 2
		wdf->depth  = 8;	/* XXX */
		wdf->cmsize = 256;
@


1.30
log
@inquire ext config and dump it in debugging and also fix other debugging prints
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.29 2003/08/17 05:52:41 mickey Exp $	*/
d118 1
d566 20
d595 3
a597 2
	u_int mode;
	int ret;
d633 15
d649 28
d685 1
a685 1
		return (-1);	/* not supported yet */
@


1.29
log
@implement WSDISPLAYIO_{S,G}MODE
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.28 2003/08/17 02:55:08 mickey Exp $	*/
d127 1
d190 3
a192 3
	    "devtype=%x, rev=%x;%d, gid=%x%x, font=%x, mss=%x\n"
	    "end=%x, mmap=%x, msto=%x, timo=%d, mont=%x, ua=%x\n"
	    "memrq=%x, pwr=%d, bus=%x, ebus=%x, altt=%x, cfb=%x\n"
d194 5
a198 7
	    dd->dd_type & 0xff, dd->dd_grrev, dd->dd_lrrev,
	    dd->dd_grid[0], dd->dd_grid[1],
	    dd->dd_fntaddr, dd->dd_maxst, dd->dd_romend,
	    dd->dd_reglst, dd->dd_maxreent,
	    dd->dd_maxtimo, dd->dd_montbl, dd->dd_udaddr,
	    dd->dd_stimemreq, dd->dd_udsize, dd->dd_pwruse,
	    dd->dd_bussup, dd->dd_altcodet, dd->dd_cfbaddr);
d207 1
a207 1
	/* divine code size, could be less than STI_END entries */
d304 3
d317 7
d330 1
a330 1
	    cfg.width, cfg.height, cfg.bpp, cfg.owidth, cfg.oheight);
a510 1
	bzero(out, sizeof(*out));
@


1.28
log
@print out the graphics id
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.27 2003/08/11 06:25:36 mickey Exp $	*/
d315 1
d566 2
d569 1
d571 15
d615 1
a615 1
	return (0);
@


1.27
log
@free code memory should change permissions fail
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.26 2003/06/02 19:24:22 mickey Exp $	*/
d315 1
a315 1
	printf(": %s rev %d.%02d;%d\n"
d318 1
@


1.26
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.25 2003/05/24 17:42:29 miod Exp $	*/
d255 1
@


1.25
log
@Disable off-screen font loading. We still need to use the pdc console routines
before we switch to wsdisplay, and this can clobber the font image in some
cases, especially lower (<= 1024x768) resolutions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.24 2003/04/03 23:09:36 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.24
log
@adjust protection on the allocated memory through the uvm same as it was allocated w/o cutting short onto the pmap layer
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.23 2003/02/18 09:39:45 miod Exp $	*/
d377 3
a379 1
	int uc, size;
d385 1
d429 1
d463 1
@


1.23
log
@Whenever possible, store the prom font data in off-screen frame buffer
memory, and use block move operations in putchar, rather than keeping a copy
of the prom font in memory and using memory to frame buffer transfers.

Recommended by the sti docs. No visible performance improvement though.

Tested on both kind of sti devices by mickey@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.22 2003/02/17 22:41:31 mickey Exp $	*/
d218 1
a218 2
	if (!(sc->sc_code = uvm_km_kmemalloc(kernel_map,
	    uvm.kernel_object, round_page(size), UVM_KMF_NOWAIT))) {
d223 1
a223 1
	printf("code=0x%x\n", sc->sc_code);
d257 5
a261 4
	/* assuming d/i caches are coherent or pmap_protect
	 * will take care of that */
	pmap_protect(pmap_kernel(), sc->sc_code,
	    sc->sc_code + round_page(size), UVM_PROT_RX);
@


1.23.2.1
log
@Pull patch from -current:
Fix by miod@@

Disable off-screen font loading. We still need to use the pdc console routines
before we switch to wsdisplay, and this can clobber the font image in some
cases, especially lower (<= 1024x768) resolutions.

Ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.25 2003/05/24 17:42:29 miod Exp $	*/
d377 1
a377 3
	int size;
#ifdef notyet
	int uc;
a382 1
#endif
a425 1
#ifdef notyet
a458 1
#endif
@


1.22
log
@can use the same bus_space_read_region_4() to copy both type1 and type4 prom; tested on type4 by me and miod on type1
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.21 2003/02/17 13:02:14 mickey Exp $	*/
d122 3
a124 2
	enum sti_bmove_funcs);
int sti_fetchfonts(struct sti_softc *sc, u_int32_t addr);
d325 1
a325 1
	if ((error = sti_fetchfonts(sc, dd->dd_fntaddr))) {
d374 1
a374 1
sti_fetchfonts(struct sti_softc *sc, u_int32_t addr)
d377 6
a382 1
	int size;
d384 3
d426 34
a683 1
/* TODO reimplement w/ blkmv and font in the fb mem per doc suggest */
a692 5
	struct {
		struct sti_unpmvflags flags;
		struct sti_unpmvin in;
		struct sti_unpmvout out;
	} a;
d694 38
a731 1
	bzero(&a, sizeof(a));
d733 8
a740 8
	a.flags.flags = STI_UNPMVF_WAIT;
	/* XXX does not handle text attributes */
	a.in.fg_colour = STI_COLOUR_WHITE;
	a.in.bg_colour = STI_COLOUR_BLACK;
	a.in.x = col * fp->width;
	a.in.y = row * fp->height;
	a.in.font_addr = sc->sc_romfont;
	a.in.index = uc;
d742 2
a743 1
	(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d783 3
a785 2
	sti_bmove(sc, 0, srcrow * fp->height, 0, dstrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.fb_width, bmf_copy);
d797 3
a799 2
	sti_bmove(sc, 0, srcrow * fp->height, 0, srcrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.fb_width, bmf_clear);
@


1.21
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.20 2003/02/11 19:41:35 miod Exp $	*/
d411 2
a412 15
		if (sc->sc_devtype == STI_DEVTYPE1) {
			u_int8_t *p;

			bzero(sc->sc_romfont, size);
			p = (u_int8_t *)sc->sc_romfont + 3;
			addr += 3;
			for (; size != 0; size -= 4) {
				*p = bus_space_read_1(sc->memt, sc->romh,
				    addr);
				p += 4;
				addr += 4;
			}
		} else
			bus_space_read_region_4(sc->memt, sc->romh, addr,
			    (u_int32_t *)sc->sc_romfont, size / 4);
@


1.20
log
@As hil devices can only attach after interrupts are enabled, delay
the attachment of wsdisplay to sti as well.
This allows us to have a working console for boot -a, and still attach
a full-blown wscons console as soon as possible.

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.19 2003/02/11 19:11:51 miod Exp $	*/
d531 1
a531 1
	struct sti_softc *sc;
@


1.19
log
@Byte-prom font loading support.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.18 2003/02/05 19:21:03 mickey Exp $	*/
d124 1
d343 5
a347 2
	{
		struct wsemuldisplaydev_attach_args waa;
d349 5
a353 13
		waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
		waa.scrdata = &sti_default_screenlist;
		waa.accessops = &sti_accessops;
		waa.accesscookie = sc;

		/* attach as console if required */
		if (waa.console) {
			long defattr;

			sti_alloc_attr(sc, 0, 0, 0, &defattr);
			wsdisplay_cnattach(&sti_default_screen, sc,
			    0, sti_default_screen.nrows - 1, defattr);
		}
d355 12
a366 1
		config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
d368 2
a369 2
#endif
	/* { extern int pmapdebug; pmapdebug = 0; } */
@


1.18
log
@implement a few wsdisplay ioctls. comment on the putchar implementation
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.17 2003/01/31 17:00:19 miod Exp $	*/
d336 4
a339 4
	sti_default_screen.ncols = cfg.width / sc->sc_curfont->width;
	sti_default_screen.nrows = cfg.height / sc->sc_curfont->height;
	sti_default_screen.fontwidth = sc->sc_curfont->width;
	sti_default_screen.fontheight = sc->sc_curfont->height;
d368 1
a368 1
	struct sti_font ff;
d373 15
a387 9
			ff.first  = parseshort(addr + 0x00);
			ff.last   = parseshort(addr + 0x08);
			ff.width  = bus_space_read_1(sc->memt, sc->romh, addr + 0x13);
			ff.height = bus_space_read_1(sc->memt, sc->romh, addr + 0x17);
			ff.type   = bus_space_read_1(sc->memt, sc->romh, addr + 0x1b);
			ff.bpc    = bus_space_read_1(sc->memt, sc->romh, addr + 0x1f);
			ff.next   = parseword(addr + 0x23);
			ff.uheight= bus_space_read_1(sc->memt, sc->romh, addr + 0x33);
			ff.uoffset= bus_space_read_1(sc->memt, sc->romh, addr + 0x37);
d390 1
a390 1
			    (u_int32_t *)&ff, sizeof(ff) / 4);
d393 2
a394 2
		    sc->sc_dev.dv_xname,
		    ff.width, ff.height, ff.type,  ff.bpc, ff.first, ff.last);
d396 6
a401 3
		size = sizeof(ff) + (ff.last - ff.first + 1) * ff.bpc;
		sc->sc_curfont = malloc(size, M_DEVBUF, M_NOWAIT);
		if (sc->sc_curfont == NULL)
d405 11
a415 1
			/* TODO */
d418 1
a418 1
			    (u_int32_t *)sc->sc_curfont, size / 4);
d420 1
a420 1
		addr = 0 /*ff.next*/;
d488 1
a488 1
		a.in.bg_colour = 0;
d492 2
a493 2
		a.in.fg_colour = 1;
		a.in.bg_colour = 0;
d497 2
a498 2
		a.in.fg_colour = 0;
		a.in.bg_colour = 1;
d627 1
a627 1
	struct sti_font *fp = sc->sc_curfont;
d656 1
a656 1
	struct sti_font *fp = sc->sc_curfont;
d667 2
a668 2
	a.in.fg_colour = 1;
	a.in.bg_colour = 0;
d671 1
a671 1
	a.in.font_addr = (void *)fp;
d673 1
d683 1
a683 1
	struct sti_font *fp = sc->sc_curfont;
d698 1
a698 1
	struct sti_font *fp = sc->sc_curfont;
d712 1
a712 1
	struct sti_font *fp = sc->sc_curfont;
d725 1
a725 1
	struct sti_font *fp = sc->sc_curfont;
@


1.17
log
@Working wscons attachment and block move operations; joint debug by mickey
and myself.
wsdisplay at sti will be enabled as soon as byte-size rom font loading is done.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.16 2003/01/31 03:44:26 mickey Exp $	*/
d505 7
a511 1
	/* struct sti_softc *sc; */
d513 26
a538 1
	return -1;
d628 1
@


1.16
log
@fetch the font and use it, some cleanup and knf
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.15 2002/07/19 17:35:07 mickey Exp $	*/
d196 1
a196 1
	    dd->dd_type, dd->dd_grrev, dd->dd_lrrev,
a344 2
		/* attach WSDISPLAY */
		bzero(&waa, sizeof(waa));
d350 9
d477 1
d517 1
a517 1
	return offset;
d528 11
a538 1
	return -1;
d546 3
d580 3
a582 3
	    row * fp->height, col * fp->width,
	    row * fp->height, col * fp->width,
	    fp->width, fp->height, bmf_invert);
d634 3
a636 3
	    row * fp->height, srccol * fp->width,
	    row * fp->height, dstcol * fp->width,
	    ncols * fp->width, fp->height, bmf_copy);
d649 3
a651 3
	    row * fp->height, startcol * fp->width,
	    row * fp->height, startcol * fp->width,
	    ncols * fp->width, fp->height, bmf_clear);
d662 2
a663 2
	sti_bmove(sc, srcrow * fp->height, 0, dstrow * fp->height, 0,
	    sc->sc_cfg.fb_width, nrows + fp->height, bmf_copy);
d675 2
a676 2
	sti_bmove(sc, srcrow * fp->height, 0, srcrow * fp->height, 0,
	    sc->sc_cfg.fb_width, nrows + fp->height, bmf_clear);
@


1.15
log
@a few more comments and debugs, other cosmetic stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.14 2002/03/14 03:16:05 millert Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000-2001 Michael Shalayeff
d123 1
a132 1
	struct sti_fontcfg *ff;
d227 2
a228 2
		register u_int8_t *p = (u_int8_t *)sc->sc_code;
		register u_int32_t addr, eaddr;
d264 2
a265 2
		register int i = dd->dd_reglst;
		register u_int32_t *p;
d269 1
a269 1
		printf ("stiregions @@%p:\n", i);
d283 4
a286 4
			printf("%x @@ 0x%x %s%s%s%s\n",
			    r.length << PGSHIFT, *p, r.sys_only? "sys " : "",
			    r.cache? "cache " : "", r.btlb? "btlb " : "",
			    r.last? "last" : "");
d303 1
a303 1
		printf (": can not initialize (%d)\n", error);
d308 1
a308 1
		printf (": error %d inquiring config\n", error);
d313 1
a313 1
		printf (": can not initialize (%d)\n", error);
a316 15
	ff = &sc->sc_fontcfg;
	if (sc->sc_devtype == STI_DEVTYPE1) {
		i = dd->dd_fntaddr;
		ff->first  = parseshort(i + 0x00);
		ff->last   = parseshort(i + 0x08);
		ff->width  = bus_space_read_1(sc->memt, sc->romh, i + 0x13);
		ff->height = bus_space_read_1(sc->memt, sc->romh, i + 0x17);
		ff->type   = bus_space_read_1(sc->memt, sc->romh, i + 0x1b);
		ff->bpc    = bus_space_read_1(sc->memt, sc->romh, i + 0x1f);
		ff->uheight= bus_space_read_1(sc->memt, sc->romh, i + 0x33);
		ff->uoffset= bus_space_read_1(sc->memt, sc->romh, i + 0x37);
	} else	/* STI_DEVTYPE4 */
		bus_space_read_region_4(sc->memt, sc->romh, dd->dd_fntaddr,
		    (u_int32_t *)ff, sizeof(*ff) / 4);

d318 2
a319 3
	    "%s: %dx%d frame buffer, %dx%dx%d display, offset %dx%d\n"
	    "%s: %dx%d font type %d, %d bpc, charset %d-%d\n", cfg.name,
	    dd->dd_grrev >> 4, dd->dd_grrev & 0xf, dd->dd_lrrev,
d321 7
a327 3
	    cfg.width, cfg.height, cfg.bpp, cfg.owidth, cfg.oheight,
	    sc->sc_dev.dv_xname,
	    ff->width, ff->height, ff->type,  ff->bpc, ff->first, ff->last);
d336 4
a339 4
	sti_default_screen.ncols = cfg.width / ff->width;
	sti_default_screen.nrows = cfg.height / ff->height;
	sti_default_screen.fontwidth = ff->width;
	sti_default_screen.fontheight = ff->height;
d359 42
d484 2
a485 2
		printf ("%s: blkmv returned %d\n",
			sc->sc_dev.dv_xname, a.out.errno);
d497 1
a497 1
	/* register struct sti_softc *sc; */
d555 2
a556 1
	register struct sti_softc *sc = v;
d558 4
a561 3
	sti_bmove(sc, row * sc->sc_fontcfg.height, col * sc->sc_fontcfg.width,
		  row * sc->sc_fontcfg.height, col * sc->sc_fontcfg.width,
		  sc->sc_fontcfg.width, sc->sc_fontcfg.height, bmf_invert);
d583 2
a584 1
	register struct sti_softc *sc = v;
d597 3
a599 3
	a.in.x = col * sc->sc_fontcfg.width;
	a.in.y = row * sc->sc_fontcfg.height;
	a.in.font_addr = 0/*STI_FONTAD(sc->sc_devtype, sc->sc_rom)*/;
d609 2
a610 1
	register struct sti_softc *sc = v;
d613 3
a615 4
	    row * sc->sc_fontcfg.height, srccol * sc->sc_fontcfg.width,
	    row * sc->sc_fontcfg.height, dstcol * sc->sc_fontcfg.width,
	    ncols * sc->sc_fontcfg.width, sc->sc_fontcfg.height,
	    bmf_copy);
d624 2
a625 1
	register struct sti_softc *sc = v;
d628 3
a630 4
	    row * sc->sc_fontcfg.height, startcol * sc->sc_fontcfg.width,
	    row * sc->sc_fontcfg.height, startcol * sc->sc_fontcfg.width,
	    ncols * sc->sc_fontcfg.width, sc->sc_fontcfg.height,
	    bmf_clear);
d638 2
a639 1
	register struct sti_softc *sc = v;
d641 2
a642 5
	sti_bmove(sc,
	    srcrow * sc->sc_fontcfg.height, 0,
	    dstrow * sc->sc_fontcfg.height, 0,
	    sc->sc_cfg.fb_width, nrows + sc->sc_fontcfg.height,
	    bmf_copy);
d651 2
a652 1
	register struct sti_softc *sc = v;
d654 2
a655 5
	sti_bmove(sc,
	    srcrow * sc->sc_fontcfg.height, 0,
	    srcrow * sc->sc_fontcfg.height, 0,
	    sc->sc_cfg.fb_width, nrows + sc->sc_fontcfg.height,
	    bmf_clear);
d664 1
a664 1
	/* register struct sti_softc *sc = v; */
@


1.14
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.13 2002/03/14 01:26:55 millert Exp $	*/
d135 1
d221 3
d228 1
d230 3
a232 3
		for (i = 0; i < size; i++)
			*p++ = bus_space_read_1(sc->memt, sc->romh,
			    dd->dd_pacode[0] + i * 4 + 3);
d235 3
a237 5
		bus_space_read_region_4(sc->memt, sc->romh, dd->dd_pacode[0],
		    (u_int32_t *)sc->sc_code, size / 4);

	/* flush from cache */
	MD_CACHE_CTL(sc->sc_code, size, MD_CACHE_FLUSH);
d256 2
d259 1
a259 2
	    sc->sc_code + round_page(size), VM_PROT_READ|VM_PROT_EXECUTE);
	pmap_update(pmap_kernel());
d289 1
a289 1
			/* rom was already mapped */
d294 1
a294 1
					printf("cannot map region\n");
a295 1
					/* who cares: return; */
d367 1
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.12 2002/03/04 23:02:47 mickey Exp $	*/
d86 2
a87 2
int sti_show_screen __P((void *v, void *cookie, int waitok,
	void (*cb)(void *, int, int), void *cbarg));
@


1.12
log
@do not attach wsdisplay if there is none configured
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.11 2002/02/01 18:56:46 mickey Exp $	*/
d61 8
a68 8
void sti_cursor __P((void *v, int on, int row, int col));
int  sti_mapchar __P((void *v, int uni, u_int *index));
void sti_putchar __P((void *v, int row, int col, u_int uc, long attr));
void sti_copycols __P((void *v, int row, int srccol, int dstcol, int ncols));
void sti_erasecols __P((void *v, int row, int startcol, int ncols, long attr));
void sti_copyrows __P((void *v, int srcrow, int dstrow, int nrows));
void sti_eraserows __P((void *v, int row, int nrows, long attr));
int  sti_alloc_attr __P((void *v, int fg, int bg, int flags, long *));
d81 5
a85 5
int sti_ioctl __P((void *v, u_long cmd, caddr_t data, int flag, struct proc *p));
paddr_t sti_mmap __P((void *v, off_t offset, int prot));
int sti_alloc_screen __P((void *v, const struct wsscreen_descr *type,
	void **cookiep, int *cxp, int *cyp, long *defattr));
	void sti_free_screen __P((void *v, void *cookie));
d87 2
a88 2
	void (*cb) __P((void *, int, int)), void *cbarg));
int sti_load_font __P((void *v, void *cookie, struct wsdisplay_font *));
d119 4
a122 4
int sti_init __P((struct sti_softc *sc, int mode));
int sti_inqcfg __P((struct sti_softc *sc, struct sti_inqconfout *out));
void sti_bmove __P((struct sti_softc *sc, int, int, int, int, int, int,
	enum sti_bmove_funcs));
d501 1
a501 1
	void (*cb) __P((void *, int, int));
@


1.11
log
@clean the hppa leftover, from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.10 2002/01/25 21:35:26 mickey Exp $	*/
d40 2
a129 1
	struct wsemuldisplaydev_attach_args waa;
d350 10
a359 6
	/* attach WSDISPLAY */
	bzero(&waa, sizeof(waa));
	waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
	waa.scrdata = &sti_default_screenlist;
	waa.accessops = &sti_accessops;
	waa.accesscookie = sc;
d361 3
a363 1
	config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
@


1.10
log
@tell wsdisplay if we are a console
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.9 2001/12/08 02:24:07 art Exp $	*/
a50 2

#include <hppa/dev/cpudevs.h>
@


1.9
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.8 2001/12/02 04:29:11 mickey Exp $	*/
d353 1
a353 3
#if notyet
	waa.console = sc->sc_dev.dv_unit == 0;
#endif
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.10 2002/01/25 21:35:26 mickey Exp $	*/
d353 3
a355 1
	waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.9.2.1 2002/01/31 22:55:32 niklas Exp $	*/
a39 2
#include "wsdisplay.h"

d52 2
d61 8
a68 8
void sti_cursor(void *v, int on, int row, int col);
int  sti_mapchar(void *v, int uni, u_int *index);
void sti_putchar(void *v, int row, int col, u_int uc, long attr);
void sti_copycols(void *v, int row, int srccol, int dstcol, int ncols);
void sti_erasecols(void *v, int row, int startcol, int ncols, long attr);
void sti_copyrows(void *v, int srcrow, int dstrow, int nrows);
void sti_eraserows(void *v, int row, int nrows, long attr);
int  sti_alloc_attr(void *v, int fg, int bg, int flags, long *);
d81 8
a88 8
int sti_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p);
paddr_t sti_mmap(void *v, off_t offset, int prot);
int sti_alloc_screen(void *v, const struct wsscreen_descr *type,
	void **cookiep, int *cxp, int *cyp, long *defattr);
	void sti_free_screen(void *v, void *cookie);
int sti_show_screen(void *v, void *cookie, int waitok,
	void (*cb)(void *, int, int), void *cbarg);
int sti_load_font(void *v, void *cookie, struct wsdisplay_font *);
d119 4
a122 4
int sti_init(struct sti_softc *sc, int mode);
int sti_inqcfg(struct sti_softc *sc, struct sti_inqconfout *out);
void sti_bmove(struct sti_softc *sc, int, int, int, int, int, int,
	enum sti_bmove_funcs);
d130 1
d351 6
a356 10
#if NWSDISPLAY > 0
	{
		struct wsemuldisplaydev_attach_args waa;

		/* attach WSDISPLAY */
		bzero(&waa, sizeof(waa));
		waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
		waa.scrdata = &sti_default_screenlist;
		waa.accessops = &sti_accessops;
		waa.accesscookie = sc;
d358 1
a358 3
		config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
	}
#endif
d496 1
a496 1
	void (*cb)(void *, int, int);
@


1.9.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.9.2.2 2002/06/11 03:42:20 art Exp $	*/
a134 1
	/* { extern int pmapdebug; pmapdebug = 0xfffff; } */
a219 3
#ifdef STIDEBUG
	printf("code=0x%x\n", sc->sc_code);
#endif
a223 1
		register u_int32_t addr, eaddr;
d225 3
a227 3
		for (addr = dd->dd_pacode[STI_BEGIN], eaddr = addr + size * 4;
		    addr < eaddr; addr += 4 )
			*p++ = bus_space_read_4(sc->memt, sc->romh, addr) & 0xff;
d230 5
a234 3
		bus_space_read_region_4(sc->memt, sc->romh,
		    dd->dd_pacode[STI_BEGIN], (u_int32_t *)sc->sc_code,
		    size / 4);
a252 2
	/* assuming d/i caches are coherent or pmap_protect
	 * will take care of that */
d254 2
a255 1
	    sc->sc_code + round_page(size), UVM_PROT_RX);
d285 1
a285 1
			/* rom has already been mapped */
d290 1
a290 1
					printf("already mapped region\n");
d292 1
a363 1
	/* { extern int pmapdebug; pmapdebug = 0; } */
@


1.9.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
d122 1
a122 4
    enum sti_bmove_funcs);
int sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg,
    u_int32_t addr);
void sti_attach_deferred(void *);
d132 1
d196 1
a196 1
	    dd->dd_type & 0xff, dd->dd_grrev, dd->dd_lrrev,
d216 2
a217 1
	if (!(sc->sc_code = uvm_km_alloc1(kernel_map, round_page(size), 0))) {
d222 1
a222 1
	printf("code=0x%x[%x]\n", sc->sc_code, size);
d227 2
a228 2
		u_int8_t *p = (u_int8_t *)sc->sc_code;
		u_int32_t addr, eaddr;
d256 4
a259 5
	if ((error = uvm_map_protect(kernel_map, sc->sc_code,
	    sc->sc_code + round_page(size), UVM_PROT_RX, FALSE))) {
		printf(": uvm_map_protect failed (%d)\n", error);
		return;
	}
d264 2
a265 2
		int i = dd->dd_reglst;
		u_int32_t *p;
d269 1
a269 1
		printf("stiregions @@%p:\n", i);
d283 4
a286 4
			printf("%x @@ 0x%x%s%s%s%s\n",
			    r.length << PGSHIFT, *p, r.sys_only? " sys" : "",
			    r.cache? " cache" : "", r.btlb? " btlb" : "",
			    r.last? " last" : "");
d303 1
a303 1
		printf(": can not initialize (%d)\n", error);
d308 1
a308 1
		printf(": error %d inquiring config\n", error);
d313 1
a313 1
		printf(": can not initialize (%d)\n", error);
d317 15
d333 3
a335 2
	    "%s: %dx%d frame buffer, %dx%dx%d display, offset %dx%d\n",
	    cfg.name, dd->dd_grrev >> 4, dd->dd_grrev & 0xf, dd->dd_lrrev,
d337 3
a339 7
	    cfg.width, cfg.height, cfg.bpp, cfg.owidth, cfg.oheight);

	if ((error = sti_fetchfonts(sc, &cfg, dd->dd_fntaddr))) {
		printf("%s: cannot fetch fonts (%d)\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}
d348 4
a351 4
	sti_default_screen.ncols = cfg.width / sc->sc_curfont.width;
	sti_default_screen.nrows = cfg.height / sc->sc_curfont.height;
	sti_default_screen.fontwidth = sc->sc_curfont.width;
	sti_default_screen.fontheight = sc->sc_curfont.height;
d354 2
a355 5
	startuphook_establish(sti_attach_deferred, sc);
#endif

	/* { extern int pmapdebug; pmapdebug = 0; } */
}
d357 6
a362 5
void
sti_attach_deferred(void *v)
{
	struct sti_softc *sc = v;
	struct wsemuldisplaydev_attach_args waa;
d364 1
a364 12
	waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
	waa.scrdata = &sti_default_screenlist;
	waa.accessops = &sti_accessops;
	waa.accesscookie = sc;

	/* attach as console if required */
	if (waa.console) {
		long defattr;

		sti_alloc_attr(sc, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&sti_default_screen, sc,
		    0, sti_default_screen.nrows - 1, defattr);
d366 2
a367 92

	config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
}

int
sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg, u_int32_t addr)
{
	struct sti_font *fp = &sc->sc_curfont;
	int uc, size;
	struct {
		struct sti_unpmvflags flags;
		struct sti_unpmvin in;
		struct sti_unpmvout out;
	} a;

	/*
	 * Get the first PROM font in memory
	 */
	do {
		if (sc->sc_devtype == STI_DEVTYPE1) {
			fp->first  = parseshort(addr + 0x00);
			fp->last   = parseshort(addr + 0x08);
			fp->width  = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x13);
			fp->height = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x17);
			fp->type   = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x1b);
			fp->bpc    = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x1f);
			fp->next   = parseword(addr + 0x23);
			fp->uheight= bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x33);
			fp->uoffset= bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x37);
		} else	/* STI_DEVTYPE4 */
			bus_space_read_region_4(sc->memt, sc->romh, addr,
			    (u_int32_t *)fp, sizeof(struct sti_font) / 4);

		printf("%s: %dx%d font type %d, %d bpc, charset %d-%d\n",
		    sc->sc_dev.dv_xname, fp->width, fp->height,
		    fp->type,  fp->bpc, fp->first, fp->last);

		size = sizeof(struct sti_font) +
		    (fp->last - fp->first + 1) * fp->bpc;
		if (sc->sc_devtype == STI_DEVTYPE1)
			size *= 4;
		sc->sc_romfont = malloc(size, M_DEVBUF, M_NOWAIT);
		if (sc->sc_romfont == NULL)
			return (ENOMEM);

		bus_space_read_region_4(sc->memt, sc->romh, addr,
		    (u_int32_t *)sc->sc_romfont, size / 4);

		addr = NULL; /* fp->next */
	} while (addr);

	/*
	 * If there is enough room in the off-screen framebuffer memory,
	 * display all the characters there in order to display them
	 * faster with blkmv operations rather than unpmv later on.
	 */
	if (size <= cfg->fbheight *
	    (cfg->fbwidth - cfg->width - cfg->owidth)) {
		bzero(&a, sizeof(a));
		a.flags.flags = STI_UNPMVF_WAIT;
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		a.in.font_addr = sc->sc_romfont;

		sc->sc_fontmaxcol = cfg->fbheight / fp->height;
		sc->sc_fontbase = cfg->width + cfg->owidth;
		for (uc = fp->first; uc <= fp->last; uc++) {
			a.in.x = ((uc - fp->first) / sc->sc_fontmaxcol) *
			    fp->width + sc->sc_fontbase;
			a.in.y = ((uc - fp->first) % sc->sc_fontmaxcol) *
			    fp->height;
			a.in.index = uc;

			(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
			if (a.out.errno) {
				printf("%s: unpmv %d returned %d\n",
				    sc->sc_dev.dv_xname, uc, a.out.errno);
				return (0);
			}
		}

		free(sc->sc_romfont, M_DEVBUF);
		sc->sc_romfont = NULL;
	}

	return (0);
d432 1
a432 1
		a.in.bg_colour = STI_COLOUR_BLACK;
d436 2
a437 2
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
d440 2
a441 3
		a.flags.flags |= STI_BLKMVF_COLR;
		a.in.fg_colour = STI_COLOUR_BLACK;
		a.in.bg_colour = STI_COLOUR_WHITE;
d454 2
a455 2
		printf("%s: blkmv returned %d\n",
		    sc->sc_dev.dv_xname, a.out.errno);
d467 1
a467 2
	struct sti_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
d469 1
a469 31
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_STI;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_cfg.scr_height;
		wdf->width  = sc->sc_cfg.scr_width;
		wdf->depth  = 8;	/* XXX */
		wdf->cmsize = 256;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_cfg.fb_width;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
d479 1
a479 1
	return -1;
d490 1
a490 11
	struct sti_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return ENOMEM;

	*cookiep = sc;
	*cxp = 0;
	*cyp = 0;
	sti_alloc_attr(sc, 0, 0, 0, defattr);
	sc->sc_nscreens++;
	return 0;
a497 3
	struct sti_softc *sc = v;

	sc->sc_nscreens--;
d525 1
a525 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d527 3
a529 4
	sti_bmove(sc,
	    col * fp->width, row * fp->height,
	    col * fp->width, row * fp->height,
	    fp->height, fp->width, bmf_invert);
d551 6
a556 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d558 1
a558 47
	if (sc->sc_romfont != NULL) {
		/*
		 * Font is in memory, use unpmv
		 */
		struct {
			struct sti_unpmvflags flags;
			struct sti_unpmvin in;
			struct sti_unpmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_UNPMVF_WAIT;
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		a.in.x = col * fp->width;
		a.in.y = row * fp->height;
		a.in.font_addr = sc->sc_romfont;
		a.in.index = uc;

		(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
	} else {
		/*
		 * Font is in frame buffer, use blkmv
		 */
		struct {
			struct sti_blkmvflags flags;
			struct sti_blkmvin in;
			struct sti_blkmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_BLKMVF_WAIT;
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;

		a.in.srcx = ((uc - fp->first) / sc->sc_fontmaxcol) *
		    fp->width + sc->sc_fontbase;
		a.in.srcy = ((uc - fp->first) % sc->sc_fontmaxcol) *
		    fp->height;
		a.in.dstx = col * fp->width;
		a.in.dsty = row * fp->height;
		a.in.height = fp->height;
		a.in.width = fp->width;
d560 9
a568 2
		(*sc->blkmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
	}
d576 1
a576 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d579 4
a582 3
	    srccol * fp->width, row * fp->height,
	    dstcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_copy);
d591 1
a591 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d594 4
a597 3
	    startcol * fp->width, row * fp->height,
	    startcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_clear);
d605 1
a605 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d607 5
a611 3
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, dstrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_copy);
d620 1
a620 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d622 5
a626 3
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, srcrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_clear);
d635 1
a635 1
	/* struct sti_softc *sc = v; */
@


1.8
log
@bzero the waa and not ready yet for the console
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.7 2001/11/06 19:53:18 miod Exp $	*/
d256 1
@


1.7
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.6 2001/09/19 20:50:58 mickey Exp $	*/
d351 4
a354 1
	waa.console = sc->sc_dev.dv_unit;
@


1.6
log
@merge vm/vm_kern.h into uvm/uvm_extern.h; art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5 2001/03/20 08:32:20 mickey Exp $	*/
a44 1
#include <vm/vm.h>
@


1.5
log
@better default screen init
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.4 2001/02/16 19:08:42 mickey Exp $	*/
a45 1
#include <vm/vm_kern.h>
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5 2001/03/20 08:32:20 mickey Exp $	*/
@


1.5.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5.4.1 2001/05/14 22:24:15 niklas Exp $	*/
d46 1
@


1.5.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d45 1
@


1.5.4.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5.4.3 2001/11/13 21:10:01 niklas Exp $	*/
d351 1
a351 4
	bzero(&waa, sizeof(waa));
#if notyet
	waa.console = sc->sc_dev.dv_unit == 0;
#endif
@


1.5.4.5
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a39 2
#include "wsdisplay.h"

d52 2
d130 1
a255 1
	pmap_update(pmap_kernel());
d350 8
a357 3
#if NWSDISPLAY > 0
	{
		struct wsemuldisplaydev_attach_args waa;
d359 1
a359 10
		/* attach WSDISPLAY */
		bzero(&waa, sizeof(waa));
		waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
		waa.scrdata = &sti_default_screenlist;
		waa.accessops = &sti_accessops;
		waa.accesscookie = sc;

		config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
	}
#endif
@


1.5.4.6
log
@Merge in -current from about a week ago
@
text
@d61 8
a68 8
void sti_cursor(void *v, int on, int row, int col);
int  sti_mapchar(void *v, int uni, u_int *index);
void sti_putchar(void *v, int row, int col, u_int uc, long attr);
void sti_copycols(void *v, int row, int srccol, int dstcol, int ncols);
void sti_erasecols(void *v, int row, int startcol, int ncols, long attr);
void sti_copyrows(void *v, int srcrow, int dstrow, int nrows);
void sti_eraserows(void *v, int row, int nrows, long attr);
int  sti_alloc_attr(void *v, int fg, int bg, int flags, long *);
d81 8
a88 8
int sti_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p);
paddr_t sti_mmap(void *v, off_t offset, int prot);
int sti_alloc_screen(void *v, const struct wsscreen_descr *type,
	void **cookiep, int *cxp, int *cyp, long *defattr);
	void sti_free_screen(void *v, void *cookie);
int sti_show_screen(void *v, void *cookie, int waitok,
	void (*cb)(void *, int, int), void *cbarg);
int sti_load_font(void *v, void *cookie, struct wsdisplay_font *);
d119 4
a122 4
int sti_init(struct sti_softc *sc, int mode);
int sti_inqcfg(struct sti_softc *sc, struct sti_inqconfout *out);
void sti_bmove(struct sti_softc *sc, int, int, int, int, int, int,
	enum sti_bmove_funcs);
d501 1
a501 1
	void (*cb)(void *, int, int);
@


1.5.4.7
log
@Sync the SMP branch with 3.3
@
text
@d4 1
a4 1
 * Copyright (c) 2000-2003 Michael Shalayeff
d122 1
a122 4
    enum sti_bmove_funcs);
int sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg,
    u_int32_t addr);
void sti_attach_deferred(void *);
d132 1
a134 1
	/* { extern int pmapdebug; pmapdebug = 0xfffff; } */
d195 1
a195 1
	    dd->dd_type & 0xff, dd->dd_grrev, dd->dd_lrrev,
a219 3
#ifdef STIDEBUG
	printf("code=0x%x\n", sc->sc_code);
#endif
d223 1
a223 2
		u_int8_t *p = (u_int8_t *)sc->sc_code;
		u_int32_t addr, eaddr;
d225 3
a227 3
		for (addr = dd->dd_pacode[STI_BEGIN], eaddr = addr + size * 4;
		    addr < eaddr; addr += 4 )
			*p++ = bus_space_read_4(sc->memt, sc->romh, addr) & 0xff;
d230 5
a234 3
		bus_space_read_region_4(sc->memt, sc->romh,
		    dd->dd_pacode[STI_BEGIN], (u_int32_t *)sc->sc_code,
		    size / 4);
a252 2
	/* assuming d/i caches are coherent or pmap_protect
	 * will take care of that */
d254 2
a255 1
	    sc->sc_code + round_page(size), UVM_PROT_RX);
d260 2
a261 2
		int i = dd->dd_reglst;
		u_int32_t *p;
d265 1
a265 1
		printf("stiregions @@%p:\n", i);
d279 4
a282 4
			printf("%x @@ 0x%x%s%s%s%s\n",
			    r.length << PGSHIFT, *p, r.sys_only? " sys" : "",
			    r.cache? " cache" : "", r.btlb? " btlb" : "",
			    r.last? " last" : "");
d285 1
a285 1
			/* rom has already been mapped */
d290 1
a290 1
					printf("already mapped region\n");
d292 1
d300 1
a300 1
		printf(": can not initialize (%d)\n", error);
d305 1
a305 1
		printf(": error %d inquiring config\n", error);
d310 1
a310 1
		printf(": can not initialize (%d)\n", error);
d314 15
d330 3
a332 2
	    "%s: %dx%d frame buffer, %dx%dx%d display, offset %dx%d\n",
	    cfg.name, dd->dd_grrev >> 4, dd->dd_grrev & 0xf, dd->dd_lrrev,
d334 3
a336 7
	    cfg.width, cfg.height, cfg.bpp, cfg.owidth, cfg.oheight);

	if ((error = sti_fetchfonts(sc, &cfg, dd->dd_fntaddr))) {
		printf("%s: cannot fetch fonts (%d)\n",
		    sc->sc_dev.dv_xname, error);
		return;
	}
d345 4
a348 4
	sti_default_screen.ncols = cfg.width / sc->sc_curfont.width;
	sti_default_screen.nrows = cfg.height / sc->sc_curfont.height;
	sti_default_screen.fontwidth = sc->sc_curfont.width;
	sti_default_screen.fontheight = sc->sc_curfont.height;
d351 2
a352 5
	startuphook_establish(sti_attach_deferred, sc);
#endif

	/* { extern int pmapdebug; pmapdebug = 0; } */
}
d354 6
a359 5
void
sti_attach_deferred(void *v)
{
	struct sti_softc *sc = v;
	struct wsemuldisplaydev_attach_args waa;
d361 1
a361 12
	waa.console = sc->sc_flags & STI_CONSOLE? 1 : 0;
	waa.scrdata = &sti_default_screenlist;
	waa.accessops = &sti_accessops;
	waa.accesscookie = sc;

	/* attach as console if required */
	if (waa.console) {
		long defattr;

		sti_alloc_attr(sc, 0, 0, 0, &defattr);
		wsdisplay_cnattach(&sti_default_screen, sc,
		    0, sti_default_screen.nrows - 1, defattr);
d363 1
a363 92

	config_found(&sc->sc_dev, &waa, wsemuldisplaydevprint);
}

int
sti_fetchfonts(struct sti_softc *sc, struct sti_inqconfout *cfg, u_int32_t addr)
{
	struct sti_font *fp = &sc->sc_curfont;
	int uc, size;
	struct {
		struct sti_unpmvflags flags;
		struct sti_unpmvin in;
		struct sti_unpmvout out;
	} a;

	/*
	 * Get the first PROM font in memory
	 */
	do {
		if (sc->sc_devtype == STI_DEVTYPE1) {
			fp->first  = parseshort(addr + 0x00);
			fp->last   = parseshort(addr + 0x08);
			fp->width  = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x13);
			fp->height = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x17);
			fp->type   = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x1b);
			fp->bpc    = bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x1f);
			fp->next   = parseword(addr + 0x23);
			fp->uheight= bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x33);
			fp->uoffset= bus_space_read_1(sc->memt, sc->romh,
			    addr + 0x37);
		} else	/* STI_DEVTYPE4 */
			bus_space_read_region_4(sc->memt, sc->romh, addr,
			    (u_int32_t *)fp, sizeof(struct sti_font) / 4);

		printf("%s: %dx%d font type %d, %d bpc, charset %d-%d\n",
		    sc->sc_dev.dv_xname, fp->width, fp->height,
		    fp->type,  fp->bpc, fp->first, fp->last);

		size = sizeof(struct sti_font) +
		    (fp->last - fp->first + 1) * fp->bpc;
		if (sc->sc_devtype == STI_DEVTYPE1)
			size *= 4;
		sc->sc_romfont = malloc(size, M_DEVBUF, M_NOWAIT);
		if (sc->sc_romfont == NULL)
			return (ENOMEM);

		bus_space_read_region_4(sc->memt, sc->romh, addr,
		    (u_int32_t *)sc->sc_romfont, size / 4);

		addr = NULL; /* fp->next */
	} while (addr);

	/*
	 * If there is enough room in the off-screen framebuffer memory,
	 * display all the characters there in order to display them
	 * faster with blkmv operations rather than unpmv later on.
	 */
	if (size <= cfg->fbheight *
	    (cfg->fbwidth - cfg->width - cfg->owidth)) {
		bzero(&a, sizeof(a));
		a.flags.flags = STI_UNPMVF_WAIT;
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		a.in.font_addr = sc->sc_romfont;

		sc->sc_fontmaxcol = cfg->fbheight / fp->height;
		sc->sc_fontbase = cfg->width + cfg->owidth;
		for (uc = fp->first; uc <= fp->last; uc++) {
			a.in.x = ((uc - fp->first) / sc->sc_fontmaxcol) *
			    fp->width + sc->sc_fontbase;
			a.in.y = ((uc - fp->first) % sc->sc_fontmaxcol) *
			    fp->height;
			a.in.index = uc;

			(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
			if (a.out.errno) {
				printf("%s: unpmv %d returned %d\n",
				    sc->sc_dev.dv_xname, uc, a.out.errno);
				return (0);
			}
		}

		free(sc->sc_romfont, M_DEVBUF);
		sc->sc_romfont = NULL;
	}

	return (0);
d428 1
a428 1
		a.in.bg_colour = STI_COLOUR_BLACK;
d432 2
a433 2
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
d436 2
a437 3
		a.flags.flags |= STI_BLKMVF_COLR;
		a.in.fg_colour = STI_COLOUR_BLACK;
		a.in.bg_colour = STI_COLOUR_WHITE;
d450 2
a451 2
		printf("%s: blkmv returned %d\n",
		    sc->sc_dev.dv_xname, a.out.errno);
d463 1
a463 2
	struct sti_softc *sc = v;
	struct wsdisplay_fbinfo *wdf;
d465 1
a465 31
	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_STI;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		wdf->height = sc->sc_cfg.scr_height;
		wdf->width  = sc->sc_cfg.scr_width;
		wdf->depth  = 8;	/* XXX */
		wdf->cmsize = 256;
		break;

	case WSDISPLAYIO_LINEBYTES:
		*(u_int *)data = sc->sc_cfg.fb_width;
		break;

	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);	/* not supported yet */
	}

	return (0);
d475 1
a475 1
	return -1;
d486 1
a486 11
	struct sti_softc *sc = v;

	if (sc->sc_nscreens > 0)
		return ENOMEM;

	*cookiep = sc;
	*cxp = 0;
	*cyp = 0;
	sti_alloc_attr(sc, 0, 0, 0, defattr);
	sc->sc_nscreens++;
	return 0;
a493 3
	struct sti_softc *sc = v;

	sc->sc_nscreens--;
d521 1
a521 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d523 3
a525 4
	sti_bmove(sc,
	    col * fp->width, row * fp->height,
	    col * fp->width, row * fp->height,
	    fp->height, fp->width, bmf_invert);
d547 6
a552 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d554 1
a554 47
	if (sc->sc_romfont != NULL) {
		/*
		 * Font is in memory, use unpmv
		 */
		struct {
			struct sti_unpmvflags flags;
			struct sti_unpmvin in;
			struct sti_unpmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_UNPMVF_WAIT;
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;
		a.in.x = col * fp->width;
		a.in.y = row * fp->height;
		a.in.font_addr = sc->sc_romfont;
		a.in.index = uc;

		(*sc->unpmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
	} else {
		/*
		 * Font is in frame buffer, use blkmv
		 */
		struct {
			struct sti_blkmvflags flags;
			struct sti_blkmvin in;
			struct sti_blkmvout out;
		} a;

		bzero(&a, sizeof(a));

		a.flags.flags = STI_BLKMVF_WAIT;
		/* XXX does not handle text attributes */
		a.in.fg_colour = STI_COLOUR_WHITE;
		a.in.bg_colour = STI_COLOUR_BLACK;

		a.in.srcx = ((uc - fp->first) / sc->sc_fontmaxcol) *
		    fp->width + sc->sc_fontbase;
		a.in.srcy = ((uc - fp->first) % sc->sc_fontmaxcol) *
		    fp->height;
		a.in.dstx = col * fp->width;
		a.in.dsty = row * fp->height;
		a.in.height = fp->height;
		a.in.width = fp->width;
d556 9
a564 2
		(*sc->blkmv)(&a.flags, &a.in, &a.out, &sc->sc_cfg);
	}
d572 1
a572 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d575 4
a578 3
	    srccol * fp->width, row * fp->height,
	    dstcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_copy);
d587 1
a587 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d590 4
a593 3
	    startcol * fp->width, row * fp->height,
	    startcol * fp->width, row * fp->height,
	    fp->height, ncols * fp->width, bmf_clear);
d601 1
a601 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d603 5
a607 3
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, dstrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_copy);
d616 1
a616 2
	struct sti_softc *sc = v;
	struct sti_font *fp = &sc->sc_curfont;
d618 5
a622 3
	sti_bmove(sc, sc->sc_cfg.oscr_width, srcrow * fp->height,
	    sc->sc_cfg.oscr_width, srcrow * fp->height,
	    nrows * fp->height, sc->sc_cfg.scr_width, bmf_clear);
d631 1
a631 1
	/* struct sti_softc *sc = v; */
@


1.5.4.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5.4.7 2003/03/28 00:38:15 niklas Exp $	*/
d218 2
a219 1
	if (!(sc->sc_code = uvm_km_alloc1(kernel_map, round_page(size), 0))) {
d224 1
a224 1
	printf("code=0x%x[%x]\n", sc->sc_code, size);
d258 4
a261 5
	if ((error = uvm_map_protect(kernel_map, sc->sc_code,
	    sc->sc_code + round_page(size), UVM_PROT_RX, FALSE))) {
		printf(": uvm_map_protect failed (%d)\n", error);
		return;
	}
@


1.5.4.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.5.4.8 2003/05/13 19:35:02 ho Exp $	*/
d15 5
d377 1
a377 3
	int size;
#ifdef notyet
	int uc;
a382 1
#endif
a425 1
#ifdef notyet
a458 1
#endif
@


1.5.4.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a117 1
int sti_setcment(struct sti_softc *sc, u_int i, u_char r, u_char g, u_char b);
a126 1
	struct sti_einqconfout ecfg;
d144 4
a147 4
		dd->dd_type  = bus_space_read_1(sc->memt, sc->romh, 0x03);
		dd->dd_nmon  = bus_space_read_1(sc->memt, sc->romh, 0x07);
		dd->dd_grrev = bus_space_read_1(sc->memt, sc->romh, 0x0b);
		dd->dd_lrrev = bus_space_read_1(sc->memt, sc->romh, 0x0f);
d156 10
a165 12
		dd->dd_montbl  = parseword(0x80) & ~3;
		dd->dd_udaddr  = parseword(0x90) & ~3;
		dd->dd_stimemreq=parseword(0xa0);
		dd->dd_udsize  = parseword(0xb0);
		dd->dd_pwruse  = parseshort(0xc0);
		dd->dd_bussup  = bus_space_read_1(sc->memt, sc->romh, 0xcb);
		dd->dd_ebussup = bus_space_read_1(sc->memt, sc->romh, 0xcf);
		dd->dd_altcodet= bus_space_read_1(sc->memt, sc->romh, 0xd3);
		dd->dd_eddst[0]= bus_space_read_1(sc->memt, sc->romh, 0xd7);
		dd->dd_eddst[1]= bus_space_read_1(sc->memt, sc->romh, 0xdb);
		dd->dd_eddst[2]= bus_space_read_1(sc->memt, sc->romh, 0xdf);
		dd->dd_cfbaddr = parseword(0xe0) & ~3;
d189 3
a191 3
	    "devtype=%x, rev=%x;%d, altt=%x, gid=%016llx, font=%x, mss=%x\n"
	    "end=%x, regions=%x, msto=%x, timo=%d, mont=%x, user=%x[%x]\n"
	    "memrq=%x, pwr=%d, bus=%x, ebus=%x, cfb=%x\n"
d193 7
a199 5
	    dd->dd_type & 0xff, dd->dd_grrev, dd->dd_lrrev, dd->dd_altcodet,
	    *(u_int64_t *)dd->dd_grid, dd->dd_fntaddr, dd->dd_maxst,
	    dd->dd_romend, dd->dd_reglst, dd->dd_maxreent, dd->dd_maxtimo,
	    dd->dd_montbl, dd->dd_udaddr, dd->dd_udsize, dd->dd_stimemreq,
	    dd->dd_pwruse, dd->dd_bussup, dd->dd_ebussup, dd->dd_cfbaddr);
d208 1
a208 1
	/* divise code size, could be less than STI_END entries */
a254 1
		uvm_km_free(kernel_map, sc->sc_code, round_page(size));
d277 1
a277 1
			*p = (p == cc->regions? sc->romh : sc->base) +
d293 2
a294 7
				} else {
					if (p - cc->regions == 1) {
						sc->fbaddr = *p;
						sc->fblen = r.length << PGSHIFT;
					}
					*p = fbh;
				}
a303 3
	bzero(&cfg, sizeof(cfg));
	bzero(&ecfg, sizeof(ecfg));
	cfg.ext = &ecfg;
d314 1
a314 10
#ifdef STIDEBUG
	printf("conf: bpp=%d planes=%d attr=%b\n"
	    "crt=0x%x:0x%x:0x%x hw=0x%x:0x%x:0x%x\n", cfg.bpp,
	    cfg.planes, cfg.attributes, STI_INQCONF_BITS,
	    ecfg.crt_config[0], ecfg.crt_config[1], ecfg.crt_config[2],
	    ecfg.crt_hw[0], ecfg.crt_hw[1], ecfg.crt_hw[2]);
#endif
	sc->sc_wsmode = WSDISPLAYIO_MODE_EMUL;
	sc->sc_bpp = cfg.bppu;
	printf(": %s rev %d.%02d;%d, ID 0x%016llX\n"
a316 1
	    *(u_int64_t *)dd->dd_grid,
d318 1
a318 1
	    cfg.width, cfg.height, cfg.bppu, cfg.owidth, cfg.oheight);
d330 1
a330 1
	 *	calculate dimensions.
d499 1
a553 20
sti_setcment(struct sti_softc *sc, u_int i, u_char r, u_char g, u_char b)
{
	struct {
		struct sti_scmentflags flags;
		struct sti_scmentin in;
		struct sti_scmentout out;
	} a;

	bzero(&a, sizeof(a));

	a.flags.flags = STI_SCMENTF_WAIT;
	a.in.entry = i;
	a.in.value = (r << 16) | (g << 8) | b;

	(*sc->scment)(&a.flags, &a.in, &a.out, &sc->sc_cfg);

	return a.out.errno;
}

int
a562 3
	struct wsdisplay_cmap *cmapp;
	u_int mode, idx, count;
	int i, ret;
a563 1
	ret = 0;
a564 15
	case WSDISPLAYIO_GMODE:
		*(u_int *)data = sc->sc_wsmode;
		break;

	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (sc->sc_wsmode == WSDISPLAYIO_MODE_EMUL &&
		    mode == WSDISPLAYIO_MODE_DUMBFB)
			ret = sti_init(sc, 0);
		else if (sc->sc_wsmode == WSDISPLAYIO_MODE_DUMBFB &&
		    mode == WSDISPLAYIO_MODE_EMUL)
			ret = sti_init(sc, STI_TEXTMODE);
		sc->sc_wsmode = mode;
		break;

d573 2
a574 2
		wdf->depth  = sc->sc_bpp;
		wdf->cmsize = STI_NCMAP;
a581 15
		if (sc->scment == NULL)
			return ENOTTY;
		cmapp = (struct wsdisplay_cmap *)data;
		idx = cmapp->index;
		count = cmapp->count;
		if (idx > STI_NCMAP || idx + count >= STI_NCMAP)
			return EINVAL;
		if ((ret = copyout(&sc->sc_rcmap[idx], cmapp->red, count)))
			break;
		if ((ret = copyout(&sc->sc_gcmap[idx], cmapp->green, count)))
			break;
		if ((ret = copyout(&sc->sc_bcmap[idx], cmapp->blue, count)))
			break;
		break;

a582 28
		if (sc->scment == NULL)
			return ENOTTY;
		cmapp = (struct wsdisplay_cmap *)data;
		idx = cmapp->index;
		count = cmapp->count;
		if (idx > STI_NCMAP || idx + count >= STI_NCMAP)
			return EINVAL;
		if ((ret = copyin(cmapp->red, &sc->sc_rcmap[idx], count)))
			break;
		if ((ret = copyin(cmapp->green, &sc->sc_gcmap[idx], count)))
			break;
		if ((ret = copyin(cmapp->blue, &sc->sc_bcmap[idx], count)))
			break;
		for (i = idx + count - 1; i >= idx; i--)
			if ((ret = sti_setcment(sc, i, sc->sc_rcmap[i],
			    sc->sc_gcmap[i], sc->sc_bcmap[i]))) {
#ifdef STIDEBUG
				printf("sti_ioctl: "
				    "sti_setcment(%d, %u, %u, %u): %d\n", i,
				    (u_int)sc->sc_rcmap[i],
				    (u_int)sc->sc_gcmap[i],
				    (u_int)sc->sc_bcmap[i]);
#endif
				ret = EINVAL;
				break;
			}
		break;

d591 1
a591 1
		return (ENOTTY);	/* not supported yet */
d594 1
a594 1
	return (ret);
@


1.4
log
@sti_mmap() proper return type
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.3 2001/01/11 21:23:53 mickey Exp $	*/
d101 16
a131 1
	struct wsscreen_descr **sl;
d347 4
a350 16
	MALLOC(sc->sc_screens, struct wsscreen_descr *,
	    1*sizeof(*sc->sc_screens), M_DEVBUF, M_NOWAIT);
	MALLOC(sl, struct wsscreen_descr **,
	    1*sizeof(sc->sc_screens), M_DEVBUF, M_NOWAIT);

	sl[0] = &sc->sc_screens[0];
	sc->sc_screens[0].name = "default";
	sc->sc_screens[0].ncols = cfg.width / ff->width;
	sc->sc_screens[0].nrows = cfg.height / ff->height;
	sc->sc_screens[0].textops = &sti_emulops;
	sc->sc_screens[0].fontwidth = ff->width;
	sc->sc_screens[0].fontheight = ff->height;
	sc->sc_screens[0].capabilities = WSSCREEN_REVERSE | WSSCREEN_UNDERLINE;

	sc->sti_screenlist.nscreens = 1;
	sc->sti_screenlist.screens = (const struct wsscreen_descr **)sl;
d354 1
a354 1
	waa.scrdata = &sc->sti_screenlist;
@


1.3
log
@fix a few types and alignment problems
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.2 2000/09/03 22:50:01 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d33 6
d84 1
a84 1
int sti_mmap __P((void *v, off_t offset, int prot));
d460 1
a460 1
int
@


1.2
log
@fix revision parsing, print local revision
@
text
@d1 1
a1 1
/*	$OpenBSD: sti.c,v 1.1 2000/05/30 19:39:38 mickey Exp $	*/
d109 1
d242 1
a242 1
		register u_int *p;
d249 2
a250 2
		for (p = (u_int *)cc->regions; !r.last &&
		     p < (u_int *)&cc->regions[STI_REGION_MAX]; p++) {
d257 1
a257 1
			*p = (p == (u_int *)cc->regions? sc->romh : sc->ioh) +
d267 1
a267 1
			if (p != (u_int *)cc->regions) {
d269 1
a269 1
				    r.length << PGSHIFT, 0, &sc->fbh)) {
d274 2
a275 1
				}
d369 5
a373 1
	sc->init(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d391 1
a391 1
	sc->inqconf(&a.flags, &a.in, out, &sc->sc_cfg);
d433 1
a433 1
	sc->blkmv(&a.flags, &a.in, &a.out, &sc->sc_cfg);
d550 1
a550 1
	sc->unpmv(&a.flags, &a.in, &a.out, &sc->sc_cfg);
@


1.1
log
@sti hp graphics, available in pci and hp-prop sgc bus form factors.
attach point for wsdisplay.
a few problems may exist w/ certain prom versions.
tested in byte- and word-wide modes.
no support yet for multiple resolutions and fonts.
pci not tested (obviously).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d128 3
a130 2
		dd->dd_grrev = bus_space_read_1(sc->memt, sc->romh, 7);
		dd->dd_lrrev = bus_space_read_1(sc->memt, sc->romh, 11);
d172 1
a172 1
	    "devtype=%x, rev=%d.%d, gid=%x%x, font=%x, mss=%x\n"
d308 1
a308 1
	printf(": %s rev %d.%02d\n"
d310 2
a311 2
	    "%s: %dx%d font type %d, %d bpc, charset %d-%d\n",
	    cfg.name, dd->dd_grrev >> 4, dd->dd_lrrev & 0xf,
@

