head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.48
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.14.0.46
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.40
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.42
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.34
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.38
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.36
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.32
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.30
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.26
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.28
	OPENBSD_5_0:1.14.0.24
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.14.0.22
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.14.0.20
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.16
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.18
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.14
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.12
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.10
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.14.0.8
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.6
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.4
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.16
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.14
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.12
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.10
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.8
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	OPENBSD_3_3:1.13.0.6
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.4
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.7.0.2
	OPENBSD_2_7_BASE:1.7
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.14
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.06.24.20.56.29;	author fgsch;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2001.06.24.20.34.22;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.09.05.05.06.58;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.28.17.48.10;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.23.16.53.08;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.19.07.27.43;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.08.05.50.50;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.01.07.02;	author niklas;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.07.26.05.43.15;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.05.02.22.35.40;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.01.03.10.05.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.07.53.58;	author fgsch;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.23.49;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.40.54;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.42.18;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@/*	$OpenBSD: i82365var.h,v 1.13 2002/03/14 01:26:54 millert Exp $	*/
/*	$NetBSD: i82365var.h,v 1.4 1998/05/23 18:32:29 matt Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/device.h>
#include <sys/timeout.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciachip.h>

#include <dev/ic/i82365reg.h>

struct proc;

struct pcic_event {
	SIMPLEQ_ENTRY(pcic_event) pe_q;
	int	pe_type;
};

/* pe_type */
#define PCIC_EVENT_INSERTION	0
#define PCIC_EVENT_REMOVAL	1

struct pcic_handle {
	struct device *ph_parent;
	bus_space_tag_t ph_bus_t;
	bus_space_handle_t ph_bus_h;
	u_int8_t (*ph_read)(struct pcic_handle *, int);
	void (*ph_write)(struct pcic_handle *, int, int);

	int	vendor;
	int	sock;
	int	flags;
	int	laststate;
	int	memalloc;
	struct {
		bus_addr_t	addr;
		bus_size_t	size;
		long		offset;
		int		kind;
	} mem[PCIC_MEM_WINS];
	int	ioalloc;
	struct {
		bus_addr_t	addr;
		bus_size_t	size;
		int		width;
	} io[PCIC_IO_WINS];
	int	ih_irq;
	struct device *pcmcia;

	int	shutdown;
	struct proc *event_thread;
	SIMPLEQ_HEAD(, pcic_event) events;
};

#define	PCIC_FLAG_SOCKETP	0x0001
#define	PCIC_FLAG_CARDP		0x0002

#define PCIC_LASTSTATE_PRESENT	0x0002
#define PCIC_LASTSTATE_HALF	0x0001
#define PCIC_LASTSTATE_EMPTY	0x0000

#define	C0SA PCIC_CHIP0_BASE+PCIC_SOCKETA_INDEX
#define	C0SB PCIC_CHIP0_BASE+PCIC_SOCKETB_INDEX
#define	C1SA PCIC_CHIP1_BASE+PCIC_SOCKETA_INDEX
#define	C1SB PCIC_CHIP1_BASE+PCIC_SOCKETB_INDEX

/*
 * This is sort of arbitrary.  It merely needs to be "enough". It can be
 * overridden in the conf file, anyway.
 */

#define	PCIC_MEM_PAGES	4
#define	PCIC_MEMSIZE	PCIC_MEM_PAGES*PCIC_MEM_PAGESIZE

#define	PCIC_NSLOTS	4

struct	pcic_ranges {
	u_short	start;
	u_short	len;
};

struct pcic_softc {
	struct device dev;

	bus_space_tag_t memt;
	bus_space_handle_t memh;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;

	/* XXX isa_chipset_tag_t, pci_chipset_tag_t, etc. */
	void *intr_est;

	pcmcia_chipset_tag_t pct;

	/* this needs to be large enough to hold PCIC_MEM_PAGES bits */
	int	subregionmask;
#define PCIC_MAX_MEM_PAGES	(8 * sizeof(int))

	/* used by memory window mapping functions */
	bus_addr_t membase;

	/*
	 * used by io window mapping functions.  These can actually overlap
	 * with another pcic, since the underlying extent mapper will deal
	 * with individual allocations.  This is here to deal with the fact
	 * that different busses have different real widths (different pc
	 * hardware seems to use 10 or 12 bits for the I/O bus).
	 */
	bus_addr_t iobase;
	bus_addr_t iosize;
	struct pcic_ranges *ranges;

	int	irq;
	void	*ih;

	/* used by socket event polling */
	struct timeout poll_timeout;
	int poll_established;

	struct pcic_handle handle[PCIC_NSLOTS];
};


int	pcic_ident_ok(int);
int	pcic_vendor(struct pcic_handle *);

void	pcic_attach(struct pcic_softc *);
void	pcic_attach_sockets(struct pcic_softc *);
int	pcic_intr(void *arg);
void	pcic_poll_intr(void *arg);

int	pcic_chip_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	pcic_chip_mem_free(pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *);
int	pcic_chip_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_size_t *, int *);
void	pcic_chip_mem_unmap(pcmcia_chipset_handle_t, int);

int	pcic_chip_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
	    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pcic_chip_io_free(pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *);
int	pcic_chip_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
void	pcic_chip_io_unmap(pcmcia_chipset_handle_t, int);

void	pcic_chip_socket_enable(pcmcia_chipset_handle_t);
void	pcic_chip_socket_disable(pcmcia_chipset_handle_t);

void	pcic_power(int, void *);

#define pcic_read(h, idx) \
	(*(h)->ph_read)((h), (idx))

#define pcic_write(h, idx, data) \
	(*(h)->ph_write)((h), (idx), (data))
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.12 2001/06/24 20:56:29 fgsch Exp $	*/
d166 1
a166 1
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
@


1.12
log
@remove cold.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.11 2001/06/24 20:34:22 fgsch Exp $	*/
d56 2
a57 2
	u_int8_t (*ph_read) __P((struct pcic_handle *, int));
	void (*ph_write) __P((struct pcic_handle *, int, int));
d153 2
a154 2
int	pcic_ident_ok __P((int));
int	pcic_vendor __P((struct pcic_handle *));
d156 20
a175 20
void	pcic_attach __P((struct pcic_softc *));
void	pcic_attach_sockets __P((struct pcic_softc *));
int	pcic_intr __P((void *arg));
void	pcic_poll_intr __P((void *arg));

int	pcic_chip_mem_alloc __P((pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *));
void	pcic_chip_mem_free __P((pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *));
int	pcic_chip_mem_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *));
void	pcic_chip_mem_unmap __P((pcmcia_chipset_handle_t, int));

int	pcic_chip_io_alloc __P((pcmcia_chipset_handle_t, bus_addr_t,
	    bus_size_t, bus_size_t, struct pcmcia_io_handle *));
void	pcic_chip_io_free __P((pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *));
int	pcic_chip_io_map __P((pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *));
void	pcic_chip_io_unmap __P((pcmcia_chipset_handle_t, int));
d177 2
a178 2
void	pcic_chip_socket_enable __P((pcmcia_chipset_handle_t));
void	pcic_chip_socket_disable __P((pcmcia_chipset_handle_t));
d180 1
a180 1
void	pcic_power __P((int, void *));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.12 2001/06/24 20:56:29 fgsch Exp $	*/
d56 2
a57 2
	u_int8_t (*ph_read)(struct pcic_handle *, int);
	void (*ph_write)(struct pcic_handle *, int, int);
d153 2
a154 2
int	pcic_ident_ok(int);
int	pcic_vendor(struct pcic_handle *);
d156 20
a175 20
void	pcic_attach(struct pcic_softc *);
void	pcic_attach_sockets(struct pcic_softc *);
int	pcic_intr(void *arg);
void	pcic_poll_intr(void *arg);

int	pcic_chip_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	pcic_chip_mem_free(pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *);
int	pcic_chip_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
void	pcic_chip_mem_unmap(pcmcia_chipset_handle_t, int);

int	pcic_chip_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
	    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pcic_chip_io_free(pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *);
int	pcic_chip_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
void	pcic_chip_io_unmap(pcmcia_chipset_handle_t, int);
d177 2
a178 2
void	pcic_chip_socket_enable(pcmcia_chipset_handle_t);
void	pcic_chip_socket_disable(pcmcia_chipset_handle_t);
d180 1
a180 1
void	pcic_power(int, void *);
@


1.11
log
@move extern int cold to .h
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.10 2000/09/05 05:06:58 fgsch Exp $	*/
a41 2

extern int cold;
@


1.10
log
@Use 32 pages instead of 4 in mem_alloc. This is needed by cnw, and useful
w/ other drivers as well. The iomem change has changed long ago to keep
using 4 pages; From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.9 2000/06/28 17:48:10 aaron Exp $	*/
d42 2
@


1.9
log
@Make suspend -> eject card -> resume work.

On suspend, the apm code calls each function in its powerhook list. This list
contains pointers to functions that are to be executed on PWR_SUSPEND and
PWR_RESUME. One of these functions is pcmcia_power() which calls xxx_activate()
for each PC Card that is connected with the action DVACT_ACTIVATE (where xxx
is the name of the driver for the PC Card). On resume, the same thing happens,
except the action is DVACT_ACTIVATE.

Clearly, if a card is gone when we resume, trying to activate it is a bad idea.
This commit adds a pcic_power() function that runs before pcmcia_power(). On
resume, it uses pcic_intr_socket() to detect any events that occurred while we
were suspended. (I had to split pcic_event_thread() into a threaded part and
a non-threaded part, since the thread will not run when we are in interrupt
context, but I need the events to be processed before pcmcia_power() runs.) So,
by the time pcic_power() is through, all events that occurred during suspend
have been processed, and pcmcia_power() will not try to activate cards that are
not there since they have already been completely and properly detached.

Note that event handling for card removals first calls the deactivate functions
on the card then the detach functions. When we suspend, apm does the deactivate
for us. So on resume, if we detect a card has been removed, we skip the
deactivation step and just detach. We use the DVF_ACTIVE bit to determine
whether or not deactivation has already occurred. Deactivating a device that
has already been deactivated causes a panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.8 2000/06/23 16:53:08 aaron Exp $	*/
d126 1
@


1.8
log
@Implement PCMCIA event polling. This will either complement interrupt-driven
event notification from the pcic (if an interrupt is available) or allow the
insertion and removal of PCMCIA devices even if there is no IRQ for the pcic.
Each socket is checked for status change every 0.5 seconds using art's timeout
code. Insertion and removal events should no longer ever go unnoticed.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.7 2000/04/19 07:27:43 fgsch Exp $	*/
d178 2
@


1.7
log
@Fix a bug introduced after cardbus commit where uart16550a was
being detected as uart16450 as side effect. This also corrects the
posibility of misdetection of vadem controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.6 2000/04/08 05:50:50 aaron Exp $	*/
d34 1
d144 4
d158 1
@


1.6
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.5 1999/08/08 01:07:02 niklas Exp $	*/
d56 1
a56 1
	void (*ph_write) __P((struct pcic_handle *, int, u_int8_t));
@


1.5
log
@Fill in detach support in the i82365 driver; mostly netbsd, as was the
former  pcmcia commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.4 1999/07/26 05:43:15 deraadt Exp $	*/
d52 6
a57 1
	struct pcic_softc *sc;
a153 3
static inline int pcic_read __P((struct pcic_handle *, int));
static inline void pcic_write __P((struct pcic_handle *, int, int));

d173 5
a177 26
static __inline int pcic_read __P((struct pcic_handle *, int));
static __inline int
pcic_read(h, idx)
	struct pcic_handle *h;
	int idx;
{
	if (idx != -1)
		bus_space_write_1(h->sc->iot, h->sc->ioh, PCIC_REG_INDEX,
		    h->sock + idx);
	return (bus_space_read_1(h->sc->iot, h->sc->ioh, PCIC_REG_DATA));
}

static __inline void pcic_write __P((struct pcic_handle *, int, int));
static __inline void
pcic_write(h, idx, data)
	struct pcic_handle *h;
	int idx;
	int data;
{
	if (idx != -1)
		bus_space_write_1(h->sc->iot, h->sc->ioh, PCIC_REG_INDEX,
		    h->sock + idx);
	if (data != -1)
		bus_space_write_1(h->sc->iot, h->sc->ioh, PCIC_REG_DATA,
		   (data));
}
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.10 2000/09/05 05:06:58 fgsch Exp $	*/
a33 1
#include <sys/timeout.h>
d52 1
a52 6
	struct device *ph_parent;
	bus_space_tag_t ph_bus_t;
	bus_space_handle_t ph_bus_h;
	u_int8_t (*ph_read) __P((struct pcic_handle *, int));
	void (*ph_write) __P((struct pcic_handle *, int, int));

a119 1
#define PCIC_MAX_MEM_PAGES	(8 * sizeof(int))
a137 4
	/* used by socket event polling */
	struct timeout poll_timeout;
	int poll_established;

d148 3
a150 1
void	pcic_poll_intr __P((void *arg));
d171 26
a196 7
void	pcic_power __P((int, void *));

#define pcic_read(h, idx) \
	(*(h)->ph_read)((h), (idx))

#define pcic_write(h, idx, data) \
	(*(h)->ph_write)((h), (idx), (data))
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.5.4.1 2001/05/14 22:23:49 niklas Exp $	*/
@


1.5.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
a57 2
	u_int8_t (*ph_read)(struct pcic_handle *, int);
	void (*ph_write)(struct pcic_handle *, int, int);
d153 2
a154 2
int	pcic_ident_ok(int);
int	pcic_vendor(struct pcic_handle *);
d156 20
a175 20
void	pcic_attach(struct pcic_softc *);
void	pcic_attach_sockets(struct pcic_softc *);
int	pcic_intr(void *arg);
void	pcic_poll_intr(void *arg);

int	pcic_chip_mem_alloc(pcmcia_chipset_handle_t, bus_size_t,
	    struct pcmcia_mem_handle *);
void	pcic_chip_mem_free(pcmcia_chipset_handle_t,
	    struct pcmcia_mem_handle *);
int	pcic_chip_mem_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_mem_handle *, bus_addr_t *, int *);
void	pcic_chip_mem_unmap(pcmcia_chipset_handle_t, int);

int	pcic_chip_io_alloc(pcmcia_chipset_handle_t, bus_addr_t,
	    bus_size_t, bus_size_t, struct pcmcia_io_handle *);
void	pcic_chip_io_free(pcmcia_chipset_handle_t,
	    struct pcmcia_io_handle *);
int	pcic_chip_io_map(pcmcia_chipset_handle_t, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
void	pcic_chip_io_unmap(pcmcia_chipset_handle_t, int);
d177 2
a178 2
void	pcic_chip_socket_enable(pcmcia_chipset_handle_t);
void	pcic_chip_socket_disable(pcmcia_chipset_handle_t);
d180 1
a180 1
void	pcic_power(int, void *);
@


1.4
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.3 1999/05/02 22:35:40 fgsch Exp $	*/
d40 11
d56 1
d72 4
d80 4
@


1.3
log
@Add support for Vadem PCMCIA controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.2 1999/01/03 10:05:52 deraadt Exp $	*/
a123 1
char	*pcic_vendor_to_string __P((int));
@


1.2
log
@provide pcmcia IO bus mapper with list of blocks where it should
preferentially map; idea by me, code by niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365var.h,v 1.1 1998/09/11 07:53:58 fgsch Exp $	*/
d174 3
a176 1
	bus_space_write_1(h->sc->iot, h->sc->ioh, PCIC_REG_DATA, (data));
@


1.1
log
@Added support for Intel 82365SL PCIC controllers and clones from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 5
d113 1
@

