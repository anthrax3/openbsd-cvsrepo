head	1.89;
access;
symbols
	OPENBSD_6_1:1.89.0.2
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.87.0.4
	OPENBSD_6_0_BASE:1.87
	OPENBSD_5_9:1.86.0.2
	OPENBSD_5_9_BASE:1.86
	OPENBSD_5_8:1.78.0.4
	OPENBSD_5_8_BASE:1.78
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.75.0.4
	OPENBSD_5_6_BASE:1.75
	OPENBSD_5_5:1.73.0.4
	OPENBSD_5_5_BASE:1.73
	OPENBSD_5_4:1.69.0.4
	OPENBSD_5_4_BASE:1.69
	OPENBSD_5_3:1.69.0.2
	OPENBSD_5_3_BASE:1.69
	OPENBSD_5_2:1.68.0.2
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.4
	OPENBSD_5_0:1.67.0.2
	OPENBSD_5_0_BASE:1.67
	OPENBSD_4_9:1.66.0.2
	OPENBSD_4_9_BASE:1.66
	OPENBSD_4_8:1.61.0.2
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.56.0.2
	OPENBSD_4_7_BASE:1.56
	OPENBSD_4_6:1.53.0.6
	OPENBSD_4_6_BASE:1.53
	OPENBSD_4_5:1.53.0.2
	OPENBSD_4_5_BASE:1.53
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.46.0.2
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.43.0.2
	OPENBSD_4_2_BASE:1.43
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.89
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.88;
commitid	VyLWTsbepAOk7VQM;

1.88
date	2016.11.29.10.22.30;	author jsg;	state Exp;
branches;
next	1.87;
commitid	ZQetSMB5ilG2z10X;

1.87
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.86;
commitid	QHiEhS9DHyE6oiIr;

1.86
date	2016.01.12.09.28.09;	author stsp;	state Exp;
branches;
next	1.85;
commitid	1npmDuWgN1zBR6BQ;

1.85
date	2015.12.11.16.07.01;	author mpi;	state Exp;
branches;
next	1.84;
commitid	fbhqfhfdKxBcsetK;

1.84
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.83;
commitid	B0kwmVGiD5DVx4kv;

1.83
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.82;
commitid	5gdEnqVoJuTuwdTu;

1.82
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.81;
commitid	FuSD2mFDJWATHIDx;

1.81
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.80;
commitid	5DvsamK0GblTp8ww;

1.80
date	2015.11.20.03.35.22;	author dlg;	state Exp;
branches;
next	1.79;
commitid	eYnPulzvLjDImPCa;

1.79
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.78;
commitid	p0v5tuE1Ch6fY0Nj;

1.78
date	2015.05.21.09.36.20;	author mpi;	state Exp;
branches;
next	1.77;
commitid	IzQAc3r8SVdLPh6M;

1.77
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.76;
commitid	yM2VFFhpDTeFQlve;

1.76
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.75;
commitid	LS2TNeCue5R9L67C;

1.75
date	2014.07.22.13.12.12;	author mpi;	state Exp;
branches;
next	1.74;
commitid	TGHgrLxu6sxZoiFt;

1.74
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.73;
commitid	I19imNlAX05zJOED;

1.73
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2013.11.14.12.24.18;	author dlg;	state Exp;
branches;
next	1.71;

1.71
date	2013.10.01.20.05.59;	author sf;	state Exp;
branches;
next	1.70;

1.70
date	2013.08.07.01.06.30;	author bluhm;	state Exp;
branches;
next	1.69;

1.69
date	2012.12.05.23.20.18;	author deraadt;	state Exp;
branches;
next	1.68;

1.68
date	2011.12.01.23.34.08;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.21.16.52.45;	author tedu;	state Exp;
branches;
next	1.66;

1.66
date	2010.09.20.07.40.41;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2010.08.27.20.06.39;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.62;

1.62
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2010.08.07.16.16.18;	author kettenis;	state Exp;
branches;
next	1.60;

1.60
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2010.05.19.15.27.35;	author oga;	state Exp;
branches;
next	1.58;

1.58
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.57;

1.57
date	2010.03.29.23.33.39;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2009.12.30.01.24.54;	author chl;	state Exp;
branches;
next	1.55;

1.55
date	2009.11.12.15.27.49;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2009.11.06.09.02.42;	author fgsch;	state Exp;
branches;
next	1.53;

1.53
date	2009.01.26.19.09.41;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2008.08.29.12.14.53;	author damien;	state Exp;
branches;
next	1.51;

1.51
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2008.07.01.11.44.12;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2008.03.13.23.07.29;	author brad;	state Exp;
branches;
next	1.46;

1.46
date	2007.12.30.17.37.57;	author claudio;	state Exp;
branches;
next	1.45;

1.45
date	2007.09.18.00.46.41;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2007.05.22.04.29.16;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.02.14.20.09.20;	author claudio;	state Exp;
branches;
next	1.40;

1.40
date	2006.12.30.22.43.01;	author claudio;	state Exp;
branches;
next	1.39;

1.39
date	2006.12.07.23.50.10;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2006.11.25.19.42.41;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2006.10.13.22.35.49;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2006.10.11.19.42.28;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2006.10.11.19.20.46;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2006.10.11.10.20.31;	author claudio;	state Exp;
branches;
next	1.33;

1.33
date	2006.10.09.21.09.40;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.09.21.01.55;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.09.20.45.27;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2006.10.06.21.55.33;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.05.14.22.54;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2006.10.05.12.15.43;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2006.10.05.11.08.30;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.05.08.56.51;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2006.10.04.18.13.37;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2006.10.04.14.23.12;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2006.10.03.17.26.14;	author claudio;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.02.21.46.43;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.02.18.06.55;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.01.22.03.25;	author claudio;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.01.21.49.08;	author claudio;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.01.21.26.21;	author claudio;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.01.21.13.45;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2006.09.27.19.35.17;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.26.21.32.49;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.23.13.44.42;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2006.09.23.13.29.58;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2006.09.19.17.38.39;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2006.09.16.12.20.10;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2006.09.16.10.36.12;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2006.08.31.22.45.32;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2006.08.31.21.36.54;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.31.20.47.40;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2006.08.31.17.05.50;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.31.09.26.14;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.28.14.10.52;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.28.10.23.49;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.24.23.55.35;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.22.18.12.13;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.89
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: pgt.c,v 1.88 2016/11/29 10:22:30 jsg Exp $  */

/*
 * Copyright (c) 2006 Claudio Jeker <claudio@@openbsd.org>
 * Copyright (c) 2006 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2004 Fujitsu Laboratories of America, Inc.
 * Copyright (c) 2004 Brian Fundakowski Feldman
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/endian.h>
#include <sys/sockio.h>
#include <sys/kthread.h>
#include <sys/time.h>
#include <sys/ioctl.h>
#include <sys/device.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <net/if.h>
#include <net/if_llc.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/pgtreg.h>
#include <dev/ic/pgtvar.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

#ifdef PGT_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

#define	SETOID(oid, var, size) {					\
	if (pgt_oid_set(sc, oid, var, size) != 0)			\
		break;							\
}

/*
 * This is a driver for the Intersil Prism family of 802.11g network cards,
 * based upon version 1.2 of the Linux driver and firmware found at
 * http://www.prism54.org/.
 */

#define SCAN_TIMEOUT			5	/* 5 seconds */

struct cfdriver pgt_cd = {
        NULL, "pgt", DV_IFNET
};

void	 pgt_media_status(struct ifnet *ifp, struct ifmediareq *imr);
int	 pgt_media_change(struct ifnet *ifp);
void	 pgt_write_memory_barrier(struct pgt_softc *);
uint32_t pgt_read_4(struct pgt_softc *, uint16_t);
void	 pgt_write_4(struct pgt_softc *, uint16_t, uint32_t);
void	 pgt_write_4_flush(struct pgt_softc *, uint16_t, uint32_t);
void	 pgt_debug_events(struct pgt_softc *, const char *);
uint32_t pgt_queue_frags_pending(struct pgt_softc *, enum pgt_queue);
void	 pgt_reinit_rx_desc_frag(struct pgt_softc *, struct pgt_desc *);
int	 pgt_load_tx_desc_frag(struct pgt_softc *, enum pgt_queue,
	     struct pgt_desc *);
void	 pgt_unload_tx_desc_frag(struct pgt_softc *, struct pgt_desc *);
int	 pgt_load_firmware(struct pgt_softc *);
void	 pgt_cleanup_queue(struct pgt_softc *, enum pgt_queue,
	     struct pgt_frag *);
int	 pgt_reset(struct pgt_softc *);
void	 pgt_stop(struct pgt_softc *, unsigned int);
void	 pgt_reboot(struct pgt_softc *);
void	 pgt_init_intr(struct pgt_softc *);
void	 pgt_update_intr(struct pgt_softc *, int);
struct mbuf
	*pgt_ieee80211_encap(struct pgt_softc *, struct ether_header *,
	     struct mbuf *, struct ieee80211_node **);
void	 pgt_input_frames(struct pgt_softc *, struct mbuf *);
void	 pgt_wakeup_intr(struct pgt_softc *);
void	 pgt_sleep_intr(struct pgt_softc *);
void	 pgt_empty_traps(struct pgt_softc_kthread *);
void	 pgt_per_device_kthread(void *);
void	 pgt_async_reset(struct pgt_softc *);
void	 pgt_async_update(struct pgt_softc *);
void	 pgt_txdone(struct pgt_softc *, enum pgt_queue);
void	 pgt_rxdone(struct pgt_softc *, enum pgt_queue);
void	 pgt_trap_received(struct pgt_softc *, uint32_t, void *, size_t);
void	 pgt_mgmtrx_completion(struct pgt_softc *, struct pgt_mgmt_desc *);
struct mbuf
	*pgt_datarx_completion(struct pgt_softc *, enum pgt_queue);
int	 pgt_oid_get(struct pgt_softc *, enum pgt_oid, void *, size_t);
int	 pgt_oid_retrieve(struct pgt_softc *, enum pgt_oid, void *, size_t);
int	 pgt_oid_set(struct pgt_softc *, enum pgt_oid, const void *, size_t);
void	 pgt_state_dump(struct pgt_softc *);
int	 pgt_mgmt_request(struct pgt_softc *, struct pgt_mgmt_desc *);
void	 pgt_desc_transmit(struct pgt_softc *, enum pgt_queue,
	     struct pgt_desc *, uint16_t, int);
void	 pgt_maybe_trigger(struct pgt_softc *, enum pgt_queue);
struct ieee80211_node
	*pgt_ieee80211_node_alloc(struct ieee80211com *);
void	 pgt_ieee80211_newassoc(struct ieee80211com *,
	     struct ieee80211_node *, int);
void	 pgt_ieee80211_node_free(struct ieee80211com *,
	    struct ieee80211_node *);
void	 pgt_ieee80211_node_copy(struct ieee80211com *,
	     struct ieee80211_node *,
	     const struct ieee80211_node *);
int	 pgt_ieee80211_send_mgmt(struct ieee80211com *,
	     struct ieee80211_node *, int, int, int);
int	 pgt_net_attach(struct pgt_softc *);
void	 pgt_start(struct ifnet *);
int	 pgt_ioctl(struct ifnet *, u_long, caddr_t);
void	 pgt_obj_bss2scanres(struct pgt_softc *,
	     struct pgt_obj_bss *, struct wi_scan_res *, uint32_t);
void	 node_mark_active_ap(void *, struct ieee80211_node *);
void	 node_mark_active_adhoc(void *, struct ieee80211_node *);
void	 pgt_watchdog(struct ifnet *);
int	 pgt_init(struct ifnet *);
void	 pgt_update_hw_from_sw(struct pgt_softc *, int, int);
void	 pgt_hostap_handle_mlme(struct pgt_softc *, uint32_t,
	     struct pgt_obj_mlme *);
void	 pgt_update_sw_from_hw(struct pgt_softc *,
	     struct pgt_async_trap *, struct mbuf *);
int	 pgt_newstate(struct ieee80211com *, enum ieee80211_state, int);
int	 pgt_drain_tx_queue(struct pgt_softc *, enum pgt_queue);
int	 pgt_dma_alloc(struct pgt_softc *);
int	 pgt_dma_alloc_queue(struct pgt_softc *sc, enum pgt_queue pq);
void	 pgt_dma_free(struct pgt_softc *);
void	 pgt_dma_free_queue(struct pgt_softc *sc, enum pgt_queue pq);
void	 pgt_wakeup(struct pgt_softc *);

void
pgt_write_memory_barrier(struct pgt_softc *sc)
{
	bus_space_barrier(sc->sc_iotag, sc->sc_iohandle, 0, 0,
	    BUS_SPACE_BARRIER_WRITE);
}

u_int32_t
pgt_read_4(struct pgt_softc *sc, uint16_t offset)
{
	return (bus_space_read_4(sc->sc_iotag, sc->sc_iohandle, offset));
}

void
pgt_write_4(struct pgt_softc *sc, uint16_t offset, uint32_t value)
{
	bus_space_write_4(sc->sc_iotag, sc->sc_iohandle, offset, value);
}

/*
 * Write out 4 bytes and cause a PCI flush by reading back in on a
 * harmless register.
 */
void
pgt_write_4_flush(struct pgt_softc *sc, uint16_t offset, uint32_t value)
{
	bus_space_write_4(sc->sc_iotag, sc->sc_iohandle, offset, value);
	(void)bus_space_read_4(sc->sc_iotag, sc->sc_iohandle, PGT_REG_INT_EN);
}

/*
 * Print the state of events in the queues from an interrupt or a trigger.
 */
void
pgt_debug_events(struct pgt_softc *sc, const char *when)
{
#define	COUNT(i)							\
	letoh32(sc->sc_cb->pcb_driver_curfrag[i]) -			\
	letoh32(sc->sc_cb->pcb_device_curfrag[i])
	if (sc->sc_debug & SC_DEBUG_EVENTS)
		DPRINTF(("%s: ev%s: %u %u %u %u %u %u\n",
		    sc->sc_dev.dv_xname, when, COUNT(0), COUNT(1), COUNT(2),
		    COUNT(3), COUNT(4), COUNT(5)));
#undef COUNT
}

uint32_t
pgt_queue_frags_pending(struct pgt_softc *sc, enum pgt_queue pq)
{
	return (letoh32(sc->sc_cb->pcb_driver_curfrag[pq]) -
	    letoh32(sc->sc_cb->pcb_device_curfrag[pq]));
}

void
pgt_reinit_rx_desc_frag(struct pgt_softc *sc, struct pgt_desc *pd)
{
	pd->pd_fragp->pf_addr = htole32((uint32_t)pd->pd_dmaaddr);
	pd->pd_fragp->pf_size = htole16(PGT_FRAG_SIZE);
	pd->pd_fragp->pf_flags = 0;

	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, pd->pd_dmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
}

int
pgt_load_tx_desc_frag(struct pgt_softc *sc, enum pgt_queue pq,
    struct pgt_desc *pd)
{
	int error;

	error = bus_dmamap_load(sc->sc_dmat, pd->pd_dmam, pd->pd_mem,
	    PGT_FRAG_SIZE, NULL, BUS_DMA_NOWAIT);
	if (error) {
		DPRINTF(("%s: unable to load %s tx DMA: %d\n",
		    sc->sc_dev.dv_xname,
		    pgt_queue_is_data(pq) ? "data" : "mgmt", error));
		return (error);
	}
	pd->pd_dmaaddr = pd->pd_dmam->dm_segs[0].ds_addr;
	pd->pd_fragp->pf_addr = htole32((uint32_t)pd->pd_dmaaddr);
	pd->pd_fragp->pf_size = htole16(PGT_FRAG_SIZE);
	pd->pd_fragp->pf_flags = htole16(0);

	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, pd->pd_dmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);

	return (0);
}

void
pgt_unload_tx_desc_frag(struct pgt_softc *sc, struct pgt_desc *pd)
{
        bus_dmamap_unload(sc->sc_dmat, pd->pd_dmam);
	pd->pd_dmaaddr = 0;
}

int
pgt_load_firmware(struct pgt_softc *sc)
{
	int error, reg, dirreg, fwoff, ucodeoff, fwlen;
	uint8_t *ucode;
	uint32_t *uc;
	size_t size;
	char *name;

	if (sc->sc_flags & SC_ISL3877)
		name = "pgt-isl3877";
	else
		name = "pgt-isl3890";	/* includes isl3880 */

	error = loadfirmware(name, &ucode, &size);

	if (error != 0) {
		DPRINTF(("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name));
		return (EIO);
	}

	if (size & 3) {
		DPRINTF(("%s: bad firmware size %u\n",
		    sc->sc_dev.dv_xname, size));
		free(ucode, M_DEVBUF, 0);
		return (EINVAL);
	}

	pgt_reboot(sc);

	fwoff = 0;
	ucodeoff = 0;
	uc = (uint32_t *)ucode;
	reg = PGT_FIRMWARE_INTERNAL_OFFSET;
	while (fwoff < size) {
		pgt_write_4_flush(sc, PGT_REG_DIR_MEM_BASE, reg);

		if ((size - fwoff) >= PGT_DIRECT_MEMORY_SIZE)
			fwlen = PGT_DIRECT_MEMORY_SIZE;
		else
			fwlen = size - fwoff;

		dirreg = PGT_DIRECT_MEMORY_OFFSET;
		while (fwlen > 4) {
			pgt_write_4(sc, dirreg, uc[ucodeoff]);
			fwoff += 4;
			dirreg += 4;
			reg += 4;
			fwlen -= 4;
			ucodeoff++;
		}
		pgt_write_4_flush(sc, dirreg, uc[ucodeoff]);
		fwoff += 4;
		dirreg += 4;
		reg += 4;
		fwlen -= 4;
		ucodeoff++;
	}
	DPRINTF(("%s: %d bytes microcode loaded from %s\n",
	    sc->sc_dev.dv_xname, fwoff, name));

	reg = pgt_read_4(sc, PGT_REG_CTRL_STAT);
	reg &= ~(PGT_CTRL_STAT_RESET | PGT_CTRL_STAT_CLOCKRUN);
	reg |= PGT_CTRL_STAT_RAMBOOT;
	pgt_write_4_flush(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);

	reg |= PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);

	reg &= ~PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);

	free(ucode, M_DEVBUF, 0);
	
	return (0);
}

void
pgt_cleanup_queue(struct pgt_softc *sc, enum pgt_queue pq,
    struct pgt_frag *pqfrags)
{
	struct pgt_desc *pd;
	unsigned int i;

	sc->sc_cb->pcb_device_curfrag[pq] = 0;
	i = 0;
	/* XXX why only freeq ??? */
	TAILQ_FOREACH(pd, &sc->sc_freeq[pq], pd_link) {
		pd->pd_fragnum = i;
		pd->pd_fragp = &pqfrags[i];
		if (pgt_queue_is_rx(pq))
			pgt_reinit_rx_desc_frag(sc, pd);
		i++;
	}
	sc->sc_freeq_count[pq] = i;
	/*
	 * The ring buffer describes how many free buffers are available from
	 * the host (for receive queues) or how many are pending (for
	 * transmit queues).
	 */
	if (pgt_queue_is_rx(pq))
		sc->sc_cb->pcb_driver_curfrag[pq] = htole32(i);
	else
		sc->sc_cb->pcb_driver_curfrag[pq] = 0;
}

/*
 * Turn off interrupts, reset the device (possibly loading firmware),
 * and put everything in a known state.
 */
int
pgt_reset(struct pgt_softc *sc)
{
	int error;

	/* disable all interrupts */
	pgt_write_4_flush(sc, PGT_REG_INT_EN, 0);
	DELAY(PGT_WRITEIO_DELAY);

	/*
	 * Set up the management receive queue, assuming there are no
	 * requests in progress.
	 */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE);
	pgt_cleanup_queue(sc, PGT_QUEUE_DATA_LOW_RX,
	    &sc->sc_cb->pcb_data_low_rx[0]);
	pgt_cleanup_queue(sc, PGT_QUEUE_DATA_LOW_TX,
	    &sc->sc_cb->pcb_data_low_tx[0]);
	pgt_cleanup_queue(sc, PGT_QUEUE_DATA_HIGH_RX,
	    &sc->sc_cb->pcb_data_high_rx[0]);
	pgt_cleanup_queue(sc, PGT_QUEUE_DATA_HIGH_TX,
	    &sc->sc_cb->pcb_data_high_tx[0]);
	pgt_cleanup_queue(sc, PGT_QUEUE_MGMT_RX,
	    &sc->sc_cb->pcb_mgmt_rx[0]);
	pgt_cleanup_queue(sc, PGT_QUEUE_MGMT_TX,
	    &sc->sc_cb->pcb_mgmt_tx[0]);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_PREREAD);

	/* load firmware */
	if (sc->sc_flags & SC_NEEDS_FIRMWARE) {
		error = pgt_load_firmware(sc);
		if (error) {
			printf("%s: firmware load failed\n",
			    sc->sc_dev.dv_xname);
			return (error);
		}
		sc->sc_flags &= ~SC_NEEDS_FIRMWARE;
		DPRINTF(("%s: firmware loaded\n", sc->sc_dev.dv_xname));
	}

	/* upload the control block's DMA address */
	pgt_write_4_flush(sc, PGT_REG_CTRL_BLK_BASE,
	    htole32((uint32_t)sc->sc_cbdmam->dm_segs[0].ds_addr));
	DELAY(PGT_WRITEIO_DELAY);

	/* send a reset event */
	pgt_write_4_flush(sc, PGT_REG_DEV_INT, PGT_DEV_INT_RESET);
	DELAY(PGT_WRITEIO_DELAY);

	/* await only the initialization interrupt */
	pgt_write_4_flush(sc, PGT_REG_INT_EN, PGT_INT_STAT_INIT);	
	DELAY(PGT_WRITEIO_DELAY);

	return (0);
}

/*
 * If we're trying to reset and the device has seemingly not been detached,
 * we'll spend a minute seeing if we can't do the reset.
 */
void
pgt_stop(struct pgt_softc *sc, unsigned int flag)
{
	struct ieee80211com *ic;
	unsigned int wokeup;
	int tryagain = 0;

	ic = &sc->sc_ic;

	ic->ic_if.if_flags &= ~IFF_RUNNING;
	sc->sc_flags |= SC_UNINITIALIZED;
	sc->sc_flags |= flag;

	pgt_drain_tx_queue(sc, PGT_QUEUE_DATA_LOW_TX);
	pgt_drain_tx_queue(sc, PGT_QUEUE_DATA_HIGH_TX);
	pgt_drain_tx_queue(sc, PGT_QUEUE_MGMT_TX);

trying_again:
	/* disable all interrupts */
	pgt_write_4_flush(sc, PGT_REG_INT_EN, 0);
	DELAY(PGT_WRITEIO_DELAY);

	/* reboot card */
	pgt_reboot(sc);

	do {
		wokeup = 0;
		/*
		 * We don't expect to be woken up, just to drop the lock
		 * and time out.  Only tx queues can have anything valid
		 * on them outside of an interrupt.
		 */
		while (!TAILQ_EMPTY(&sc->sc_mgmtinprog)) {
			struct pgt_mgmt_desc *pmd;

			pmd = TAILQ_FIRST(&sc->sc_mgmtinprog);
			TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd, pmd_link);
			pmd->pmd_error = ENETRESET;
			wakeup_one(pmd);
			if (sc->sc_debug & SC_DEBUG_MGMT)
				DPRINTF(("%s: queue: mgmt %p <- %#x "
				    "(drained)\n", sc->sc_dev.dv_xname,
				    pmd, pmd->pmd_oid));
			wokeup++;
		}
		if (wokeup > 0) {
			if (flag == SC_NEEDS_RESET && sc->sc_flags & SC_DYING) {
				sc->sc_flags &= ~flag;
				return;
			}
		}
	} while (wokeup > 0);

	if (flag == SC_NEEDS_RESET) {
		int error;

		DPRINTF(("%s: resetting\n", sc->sc_dev.dv_xname));
		sc->sc_flags &= ~SC_POWERSAVE;
		sc->sc_flags |= SC_NEEDS_FIRMWARE;
		error = pgt_reset(sc);
		if (error == 0) {
			tsleep(&sc->sc_flags, 0, "pgtres", hz);
			if (sc->sc_flags & SC_UNINITIALIZED) {
				printf("%s: not responding\n",
				    sc->sc_dev.dv_xname);
				/* Thud.  It was probably removed. */
				if (tryagain)
					panic("pgt went for lunch"); /* XXX */
				tryagain = 1;
			} else {
				/* await all interrupts */
				pgt_write_4_flush(sc, PGT_REG_INT_EN,
				    PGT_INT_STAT_SOURCES);	
				DELAY(PGT_WRITEIO_DELAY);
				ic->ic_if.if_flags |= IFF_RUNNING;
			}
		}

		if (tryagain)
			goto trying_again;

		sc->sc_flags &= ~flag;
		if (ic->ic_if.if_flags & IFF_RUNNING)
			pgt_update_hw_from_sw(sc,
			    ic->ic_state != IEEE80211_S_INIT,
			    ic->ic_opmode != IEEE80211_M_MONITOR);
	}

	ic->ic_if.if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ic->ic_if.if_snd);
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);
}

void
pgt_attach(struct device *self)
{
	struct pgt_softc *sc = (struct pgt_softc *)self;
	int error;

	/* debug flags */
	//sc->sc_debug |= SC_DEBUG_QUEUES;	/* super verbose */
	//sc->sc_debug |= SC_DEBUG_MGMT;
	sc->sc_debug |= SC_DEBUG_UNEXPECTED;
	//sc->sc_debug |= SC_DEBUG_TRIGGER;	/* verbose */
	//sc->sc_debug |= SC_DEBUG_EVENTS;	/* super verbose */
	//sc->sc_debug |= SC_DEBUG_POWER;
	sc->sc_debug |= SC_DEBUG_TRAP;
	sc->sc_debug |= SC_DEBUG_LINK;
	//sc->sc_debug |= SC_DEBUG_RXANNEX;
	//sc->sc_debug |= SC_DEBUG_RXFRAG;
	//sc->sc_debug |= SC_DEBUG_RXETHER;

	/* enable card if possible */
	if (sc->sc_enable != NULL)
		(*sc->sc_enable)(sc);

	error = pgt_dma_alloc(sc);
	if (error)
		return;

	sc->sc_ic.ic_if.if_softc = sc;
	TAILQ_INIT(&sc->sc_mgmtinprog);
	TAILQ_INIT(&sc->sc_kthread.sck_traps);
	sc->sc_flags |= SC_NEEDS_FIRMWARE | SC_UNINITIALIZED;
	sc->sc_80211_ioc_auth = IEEE80211_AUTH_OPEN;

	error = pgt_reset(sc);
	if (error)
		return;

	tsleep(&sc->sc_flags, 0, "pgtres", hz);
	if (sc->sc_flags & SC_UNINITIALIZED) {
		printf("%s: not responding\n", sc->sc_dev.dv_xname);
		sc->sc_flags |= SC_NEEDS_FIRMWARE;
		return;
	} else {
		/* await all interrupts */
		pgt_write_4_flush(sc, PGT_REG_INT_EN, PGT_INT_STAT_SOURCES);
		DELAY(PGT_WRITEIO_DELAY);
	}

	error = pgt_net_attach(sc);
	if (error)
		return;

	if (kthread_create(pgt_per_device_kthread, sc, NULL,
	    sc->sc_dev.dv_xname) != 0)
		return;

	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);
}

int
pgt_detach(struct pgt_softc *sc)
{
	if (sc->sc_flags & SC_NEEDS_FIRMWARE || sc->sc_flags & SC_UNINITIALIZED)
		/* device was not initialized correctly, so leave early */
		goto out;

	/* stop card */
	pgt_stop(sc, SC_DYING);
	pgt_reboot(sc);

	ieee80211_ifdetach(&sc->sc_ic.ic_if);
	if_detach(&sc->sc_ic.ic_if);

out:
	/* disable card if possible */
	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);

	pgt_dma_free(sc);

	return (0);
}

void
pgt_reboot(struct pgt_softc *sc)
{
	uint32_t reg;

	reg = pgt_read_4(sc, PGT_REG_CTRL_STAT);
	reg &= ~(PGT_CTRL_STAT_RESET | PGT_CTRL_STAT_RAMBOOT);
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);

	reg |= PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);

	reg &= ~PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_RESET_DELAY);
}

void
pgt_init_intr(struct pgt_softc *sc)
{
	if ((sc->sc_flags & SC_UNINITIALIZED) == 0) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: spurious initialization\n",
			    sc->sc_dev.dv_xname));
	} else {
		sc->sc_flags &= ~SC_UNINITIALIZED;
		wakeup(&sc->sc_flags);
	}
}

/*
 * If called with a NULL last_nextpkt, only the mgmt queue will be checked
 * for new packets.
 */
void
pgt_update_intr(struct pgt_softc *sc, int hack)
{
	/* priority order */
	enum pgt_queue pqs[PGT_QUEUE_COUNT] = {
	    PGT_QUEUE_MGMT_TX, PGT_QUEUE_MGMT_RX, 
	    PGT_QUEUE_DATA_HIGH_TX, PGT_QUEUE_DATA_HIGH_RX, 
	    PGT_QUEUE_DATA_LOW_TX, PGT_QUEUE_DATA_LOW_RX
	};
	struct mbuf *m;
	uint32_t npend;
	unsigned int dirtycount;
	int i;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE);
	pgt_debug_events(sc, "intr");
	/*
	 * Check for completion of tx in their dirty queues.
	 * Check completion of rx into their dirty queues.
	 */
	for (i = 0; i < PGT_QUEUE_COUNT; i++) {
		size_t qdirty, qfree;

		qdirty = sc->sc_dirtyq_count[pqs[i]];
		qfree = sc->sc_freeq_count[pqs[i]];
		/*
		 * We want the wrap-around here.
		 */
		if (pgt_queue_is_rx(pqs[i])) {
			int data;

			data = pgt_queue_is_data(pqs[i]);
#ifdef PGT_BUGGY_INTERRUPT_RECOVERY
			if (hack && data)
				continue;
#endif
			npend = pgt_queue_frags_pending(sc, pqs[i]);
			/*
			 * Receive queues clean up below, so qdirty must
			 * always be 0.
			 */
			if (npend > qfree) {
				if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
					DPRINTF(("%s: rx queue [%u] "
					    "overflowed by %u\n",
					    sc->sc_dev.dv_xname, pqs[i],
					    npend - qfree));
				sc->sc_flags |= SC_INTR_RESET;
				break;
			}
			while (qfree-- > npend)
				pgt_rxdone(sc, pqs[i]);
		} else {
			npend = pgt_queue_frags_pending(sc, pqs[i]);
			if (npend > qdirty) {
				if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
					DPRINTF(("%s: tx queue [%u] "
					    "underflowed by %u\n",
					    sc->sc_dev.dv_xname, pqs[i],
					    npend - qdirty));
				sc->sc_flags |= SC_INTR_RESET;
				break;
			}
			/*
			 * If the free queue was empty, or the data transmit
			 * queue just became empty, wake up any waiters.
			 */
			if (qdirty > npend) {
				if (pgt_queue_is_data(pqs[i])) {
					sc->sc_ic.ic_if.if_timer = 0;
					ifq_clr_oactive(
					    &sc->sc_ic.ic_if.if_snd);
				}
				while (qdirty-- > npend)
					pgt_txdone(sc, pqs[i]);
			}
		}
	}

	/*
	 * This is the deferred completion for received management frames
	 * and where we queue network frames for stack input. 
	 */
	dirtycount = sc->sc_dirtyq_count[PGT_QUEUE_MGMT_RX];
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PGT_QUEUE_MGMT_RX])) {
		struct pgt_mgmt_desc *pmd;

		pmd = TAILQ_FIRST(&sc->sc_mgmtinprog);
		/*
		 * If there is no mgmt request in progress or the operation
		 * returned is explicitly a trap, this pmd will essentially
		 * be ignored.
		 */
		pgt_mgmtrx_completion(sc, pmd);
	}
	sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_MGMT_RX] =
	    htole32(dirtycount +
		letoh32(sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_MGMT_RX]));

	dirtycount = sc->sc_dirtyq_count[PGT_QUEUE_DATA_HIGH_RX];
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PGT_QUEUE_DATA_HIGH_RX])) {
		if ((m = pgt_datarx_completion(sc, PGT_QUEUE_DATA_HIGH_RX)))
			pgt_input_frames(sc, m);
	}
	sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_DATA_HIGH_RX] =
	    htole32(dirtycount +
		letoh32(sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_DATA_HIGH_RX]));

	dirtycount = sc->sc_dirtyq_count[PGT_QUEUE_DATA_LOW_RX];
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PGT_QUEUE_DATA_LOW_RX])) {
		if ((m = pgt_datarx_completion(sc, PGT_QUEUE_DATA_LOW_RX)))
			pgt_input_frames(sc, m);
	}
	sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_DATA_LOW_RX] =
	    htole32(dirtycount +
		letoh32(sc->sc_cb->pcb_driver_curfrag[PGT_QUEUE_DATA_LOW_RX]));

	/*
	 * Write out what we've finished with.
	 */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_PREREAD);
}

struct mbuf *
pgt_ieee80211_encap(struct pgt_softc *sc, struct ether_header *eh,
    struct mbuf *m, struct ieee80211_node **ni)
{
	struct ieee80211com *ic;
	struct ieee80211_frame *frame;
	struct llc *snap;

	ic = &sc->sc_ic;
	if (ni != NULL && ic->ic_opmode == IEEE80211_M_MONITOR) {
		*ni = ieee80211_ref_node(ic->ic_bss);
		(*ni)->ni_inact = 0;
		return (m);
	}

	M_PREPEND(m, sizeof(*frame) + sizeof(*snap), M_DONTWAIT);
	if (m == NULL)
		return (m);
	if (m->m_len < sizeof(*frame) + sizeof(*snap)) {
		m = m_pullup(m, sizeof(*frame) + sizeof(*snap));
		if (m == NULL)
			return (m);
	}
	frame = mtod(m, struct ieee80211_frame *);
	snap = (struct llc *)&frame[1];
	if (ni != NULL) {
		if (ic->ic_opmode == IEEE80211_M_STA) {
			*ni = ieee80211_ref_node(ic->ic_bss);
		}
#ifndef IEEE80211_STA_ONLY
		else {
			*ni = ieee80211_find_node(ic, eh->ether_shost);
			/*
			 * Make up associations for ad-hoc mode.  To support
			 * ad-hoc WPA, we'll need to maintain a bounded
			 * pool of ad-hoc stations.
			 */
			if (*ni == NULL &&
			    ic->ic_opmode != IEEE80211_M_HOSTAP) {
				*ni = ieee80211_dup_bss(ic, eh->ether_shost);
				if (*ni != NULL) {
					(*ni)->ni_associd = 1;
					ic->ic_newassoc(ic, *ni, 1);
				}
			}
			if (*ni == NULL) {
				m_freem(m);
				return (NULL);
			}
		}
#endif
		(*ni)->ni_inact = 0;
	}
	snap->llc_dsap = snap->llc_ssap = LLC_SNAP_LSAP;
	snap->llc_control = LLC_UI;
	snap->llc_snap.org_code[0] = 0;
	snap->llc_snap.org_code[1] = 0;
	snap->llc_snap.org_code[2] = 0;
	snap->llc_snap.ether_type = eh->ether_type;
	frame->i_fc[0] = IEEE80211_FC0_VERSION_0 | IEEE80211_FC0_TYPE_DATA;
	/* Doesn't look like much of the 802.11 header is available. */
	*(uint16_t *)frame->i_dur = *(uint16_t *)frame->i_seq = 0;
	/*
	 * Translate the addresses; WDS is not handled.
	 */
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		frame->i_fc[1] = IEEE80211_FC1_DIR_FROMDS;
		IEEE80211_ADDR_COPY(frame->i_addr1, eh->ether_dhost);
		IEEE80211_ADDR_COPY(frame->i_addr2, ic->ic_bss->ni_bssid);
		IEEE80211_ADDR_COPY(frame->i_addr3, eh->ether_shost);
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
	case IEEE80211_M_AHDEMO:
		frame->i_fc[1] = IEEE80211_FC1_DIR_NODS;
		IEEE80211_ADDR_COPY(frame->i_addr1, eh->ether_dhost);
		IEEE80211_ADDR_COPY(frame->i_addr2, eh->ether_shost);
		IEEE80211_ADDR_COPY(frame->i_addr3, ic->ic_bss->ni_bssid);
		break;
	case IEEE80211_M_HOSTAP:
		/* HostAP forwarding defaults to being done on firmware. */
		frame->i_fc[1] = IEEE80211_FC1_DIR_TODS;
		IEEE80211_ADDR_COPY(frame->i_addr1, ic->ic_bss->ni_bssid);
		IEEE80211_ADDR_COPY(frame->i_addr2, eh->ether_shost);
		IEEE80211_ADDR_COPY(frame->i_addr3, eh->ether_dhost);
		break;
#endif
	default:
		break;
	}
	return (m);
}

void
pgt_input_frames(struct pgt_softc *sc, struct mbuf *m)
{
	struct ether_header eh;
	struct ifnet *ifp;
	struct ieee80211_channel *chan;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct ieee80211com *ic;
	struct pgt_rx_annex *pra;
	struct pgt_rx_header *pha;
	struct mbuf *next;
	unsigned int n;
	uint32_t rstamp;
	uint8_t rssi;

	ic = &sc->sc_ic;
	ifp = &ic->ic_if;
	for (next = m; m != NULL; m = next) {
		next = m->m_nextpkt;
		m->m_nextpkt = NULL;

		if (ic->ic_opmode == IEEE80211_M_MONITOR) {
			if (m->m_len < sizeof(*pha)) {
				m = m_pullup(m, sizeof(*pha));
				if (m == NULL) {
					if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
						DPRINTF(("%s: m_pullup "
						    "failure\n",
						    sc->sc_dev.dv_xname));
					ifp->if_ierrors++;
					continue;
				}
			}
			pha = mtod(m, struct pgt_rx_header *);
			pra = NULL;
			goto input;
		}

		if (m->m_len < sizeof(*pra)) {
			m = m_pullup(m, sizeof(*pra));
			if (m == NULL) {
				if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
					DPRINTF(("%s: m_pullup failure\n",
					    sc->sc_dev.dv_xname));
				ifp->if_ierrors++;
				continue;
			}
		}
		pra = mtod(m, struct pgt_rx_annex *);
		pha = &pra->pra_header;
		if (sc->sc_debug & SC_DEBUG_RXANNEX)
			DPRINTF(("%s: rx annex: ? %04x "
			    "len %u clock %u flags %02x ? %02x rate %u ? %02x "
			    "freq %u ? %04x rssi %u pad %02x%02x%02x\n",
			    sc->sc_dev.dv_xname,
			    letoh16(pha->pra_unknown0),
			    letoh16(pha->pra_length),
			    letoh32(pha->pra_clock), pha->pra_flags,
			    pha->pra_unknown1, pha->pra_rate,
			    pha->pra_unknown2, letoh32(pha->pra_frequency),
			    pha->pra_unknown3, pha->pra_rssi,
			    pha->pra_pad[0], pha->pra_pad[1], pha->pra_pad[2]));
		if (sc->sc_debug & SC_DEBUG_RXETHER)
			DPRINTF(("%s: rx ether: %s < %s 0x%04x\n",
			    sc->sc_dev.dv_xname,
			    ether_sprintf(pra->pra_ether_dhost),
			    ether_sprintf(pra->pra_ether_shost),
			    ntohs(pra->pra_ether_type)));

		memcpy(eh.ether_dhost, pra->pra_ether_dhost, ETHER_ADDR_LEN);
		memcpy(eh.ether_shost, pra->pra_ether_shost, ETHER_ADDR_LEN);
		eh.ether_type = pra->pra_ether_type;

input:
		/*
		 * This flag is set if e.g. packet could not be decrypted.
		 */
		if (pha->pra_flags & PRA_FLAG_BAD) {
			ifp->if_ierrors++;
			m_freem(m);
			continue;
		}

		/*
		 * After getting what we want, chop off the annex, then
		 * turn into something that looks like it really was
		 * 802.11.
		 */
		rssi = pha->pra_rssi;
		rstamp = letoh32(pha->pra_clock);
		n = ieee80211_mhz2ieee(letoh32(pha->pra_frequency), 0);
		if (n <= IEEE80211_CHAN_MAX)
			chan = &ic->ic_channels[n];
		else
			chan = ic->ic_bss->ni_chan;
		/* Send to 802.3 listeners. */
		if (pra) {
			m_adj(m, sizeof(*pra));
		} else
			m_adj(m, sizeof(*pha));

		m = pgt_ieee80211_encap(sc, &eh, m, &ni);
		if (m != NULL) {
#if NBPFILTER > 0
			if (sc->sc_drvbpf != NULL) {
				struct mbuf mb;
				struct pgt_rx_radiotap_hdr *tap = &sc->sc_rxtap;

				tap->wr_flags = 0;
				tap->wr_chan_freq = htole16(chan->ic_freq);
				tap->wr_chan_flags = htole16(chan->ic_flags);
				tap->wr_rssi = rssi;
				tap->wr_max_rssi = ic->ic_max_rssi;

				mb.m_data = (caddr_t)tap;
				mb.m_len = sc->sc_rxtap_len;
				mb.m_next = m;
				mb.m_nextpkt = NULL;
				mb.m_type = 0;
				mb.m_flags = 0;
				bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
			}
#endif
			rxi.rxi_flags = 0;
			ni->ni_rssi = rxi.rxi_rssi = rssi;
			ni->ni_rstamp = rxi.rxi_tstamp = rstamp;
			ieee80211_input(ifp, m, ni, &rxi);
			/*
			 * The frame may have caused the node to be marked for
			 * reclamation (e.g. in response to a DEAUTH message)
			 * so use free_node here instead of unref_node.
			 */
			if (ni == ic->ic_bss)
				ieee80211_unref_node(&ni);
			else
				ieee80211_release_node(&sc->sc_ic, ni);
		} else {
			ifp->if_ierrors++;
		}
	}
}

void
pgt_wakeup_intr(struct pgt_softc *sc)
{
	int shouldupdate;
	int i;

	shouldupdate = 0;
	/* Check for any queues being empty before updating. */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
	for (i = 0; !shouldupdate && i < PGT_QUEUE_COUNT; i++) {
		if (pgt_queue_is_tx(i))
			shouldupdate = pgt_queue_frags_pending(sc, i);
		else
			shouldupdate = pgt_queue_frags_pending(sc, i) <
			    sc->sc_freeq_count[i];
	}
	if (!TAILQ_EMPTY(&sc->sc_mgmtinprog))
		shouldupdate = 1;
	if (sc->sc_debug & SC_DEBUG_POWER)
		DPRINTF(("%s: wakeup interrupt (update = %d)\n",
		    sc->sc_dev.dv_xname, shouldupdate));
	sc->sc_flags &= ~SC_POWERSAVE;
	if (shouldupdate) {
		pgt_write_4_flush(sc, PGT_REG_DEV_INT, PGT_DEV_INT_UPDATE);
		DELAY(PGT_WRITEIO_DELAY);
	}
}

void
pgt_sleep_intr(struct pgt_softc *sc)
{
	int allowed;
	int i;

	allowed = 1;
	/* Check for any queues not being empty before allowing. */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
	for (i = 0; allowed && i < PGT_QUEUE_COUNT; i++) {
		if (pgt_queue_is_tx(i))
			allowed = pgt_queue_frags_pending(sc, i) == 0;
		else
			allowed = pgt_queue_frags_pending(sc, i) >=
			    sc->sc_freeq_count[i];
	}
	if (!TAILQ_EMPTY(&sc->sc_mgmtinprog))
		allowed = 0;
	if (sc->sc_debug & SC_DEBUG_POWER)
		DPRINTF(("%s: sleep interrupt (allowed = %d)\n",
		    sc->sc_dev.dv_xname, allowed));
	if (allowed && sc->sc_ic.ic_flags & IEEE80211_F_PMGTON) {
		sc->sc_flags |= SC_POWERSAVE;
		pgt_write_4_flush(sc, PGT_REG_DEV_INT, PGT_DEV_INT_SLEEP);
		DELAY(PGT_WRITEIO_DELAY);
	}
}

void
pgt_empty_traps(struct pgt_softc_kthread *sck)
{
	struct pgt_async_trap *pa;
	struct mbuf *m;

	while (!TAILQ_EMPTY(&sck->sck_traps)) {
		pa = TAILQ_FIRST(&sck->sck_traps);
		TAILQ_REMOVE(&sck->sck_traps, pa, pa_link);
		m = pa->pa_mbuf;
		m_freem(m);
	}
}

void
pgt_per_device_kthread(void *argp)
{
	struct pgt_softc *sc;
	struct pgt_softc_kthread *sck;
	struct pgt_async_trap *pa;
	struct mbuf *m;
	int s;

	sc = argp;
	sck = &sc->sc_kthread;
	while (!sck->sck_exit) {
		if (!sck->sck_update && !sck->sck_reset &&
		    TAILQ_EMPTY(&sck->sck_traps))
			tsleep(&sc->sc_kthread, 0, "pgtkth", 0);
		if (sck->sck_reset) {
			DPRINTF(("%s: [thread] async reset\n",
			    sc->sc_dev.dv_xname));
			sck->sck_reset = 0;
			sck->sck_update = 0;
			pgt_empty_traps(sck);
			s = splnet();
			pgt_stop(sc, SC_NEEDS_RESET);
			splx(s);
		} else if (!TAILQ_EMPTY(&sck->sck_traps)) {
			DPRINTF(("%s: [thread] got a trap\n",
			    sc->sc_dev.dv_xname));
			pa = TAILQ_FIRST(&sck->sck_traps);
			TAILQ_REMOVE(&sck->sck_traps, pa, pa_link);
			m = pa->pa_mbuf;
			m_adj(m, sizeof(*pa));
			pgt_update_sw_from_hw(sc, pa, m);
			m_freem(m);
		} else if (sck->sck_update) {
			sck->sck_update = 0;
			pgt_update_sw_from_hw(sc, NULL, NULL);
		}
	}
	pgt_empty_traps(sck);
	kthread_exit(0);
}

void
pgt_async_reset(struct pgt_softc *sc)
{
	if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET))
		return;
	sc->sc_kthread.sck_reset = 1;
	wakeup(&sc->sc_kthread);
}

void
pgt_async_update(struct pgt_softc *sc)
{
	if (sc->sc_flags & SC_DYING)
		return;
	sc->sc_kthread.sck_update = 1;
	wakeup(&sc->sc_kthread);
}

int
pgt_intr(void *arg)
{
	struct pgt_softc *sc;
	struct ifnet *ifp;
	u_int32_t reg;

	sc = arg;
	ifp = &sc->sc_ic.ic_if;

	/*
	 * Here the Linux driver ands in the value of the INT_EN register,
	 * and masks off everything but the documented interrupt bits.  Why?
	 *
	 * Unknown bit 0x4000 is set upon initialization, 0x8000000 some
	 * other times.
	 */
	if (sc->sc_ic.ic_flags & IEEE80211_F_PMGTON &&
	    sc->sc_flags & SC_POWERSAVE) {
		/*
		 * Don't try handling the interrupt in sleep mode.
		 */
		reg = pgt_read_4(sc, PGT_REG_CTRL_STAT);
		if (reg & PGT_CTRL_STAT_SLEEPMODE)
			return (0);
	}
	reg = pgt_read_4(sc, PGT_REG_INT_STAT);
	if (reg == 0)
		return (0); /* This interrupt is not from us */

	pgt_write_4_flush(sc, PGT_REG_INT_ACK, reg);
	if (reg & PGT_INT_STAT_INIT)
		pgt_init_intr(sc);
	if (reg & PGT_INT_STAT_UPDATE) {
		pgt_update_intr(sc, 0);
		/*
		 * If we got an update, it's not really asleep.
		 */
		sc->sc_flags &= ~SC_POWERSAVE;
		/*
		 * Pretend I have any idea what the documentation
		 * would say, and just give it a shot sending an
		 * "update" after acknowledging the interrupt
		 * bits and writing out the new control block.
		 */
		pgt_write_4_flush(sc, PGT_REG_DEV_INT, PGT_DEV_INT_UPDATE);
		DELAY(PGT_WRITEIO_DELAY);
	}
	if (reg & PGT_INT_STAT_SLEEP && !(reg & PGT_INT_STAT_WAKEUP))
		pgt_sleep_intr(sc);
	if (reg & PGT_INT_STAT_WAKEUP)
		pgt_wakeup_intr(sc);

	if (sc->sc_flags & SC_INTR_RESET) {
		sc->sc_flags &= ~SC_INTR_RESET;
		pgt_async_reset(sc);
	}

	if (reg & ~PGT_INT_STAT_SOURCES && sc->sc_debug & SC_DEBUG_UNEXPECTED) {
		DPRINTF(("%s: unknown interrupt bits %#x (stat %#x)\n",
		    sc->sc_dev.dv_xname,
		    reg & ~PGT_INT_STAT_SOURCES,
		    pgt_read_4(sc, PGT_REG_CTRL_STAT)));
	}

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		pgt_start(ifp);

	return (1);
}

void
pgt_txdone(struct pgt_softc *sc, enum pgt_queue pq)
{
	struct pgt_desc *pd;

	pd = TAILQ_FIRST(&sc->sc_dirtyq[pq]);
	TAILQ_REMOVE(&sc->sc_dirtyq[pq], pd, pd_link);
	sc->sc_dirtyq_count[pq]--;
	TAILQ_INSERT_TAIL(&sc->sc_freeq[pq], pd, pd_link);
	sc->sc_freeq_count[pq]++;
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0,
	    pd->pd_dmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
	/* Management frames want completion information. */
	if (sc->sc_debug & SC_DEBUG_QUEUES) {
		DPRINTF(("%s: queue: tx %u <- [%u]\n",
		    sc->sc_dev.dv_xname, pd->pd_fragnum, pq));
		if (sc->sc_debug & SC_DEBUG_MGMT && pgt_queue_is_mgmt(pq)) {
			struct pgt_mgmt_frame *pmf;

			pmf = (struct pgt_mgmt_frame *)pd->pd_mem;
			DPRINTF(("%s: queue: txmgmt %p <- "
			    "(ver %u, op %u, flags %#x)\n",
			    sc->sc_dev.dv_xname,
			    pd, pmf->pmf_version, pmf->pmf_operation,
			    pmf->pmf_flags));
		}
	}
	pgt_unload_tx_desc_frag(sc, pd);
}

void
pgt_rxdone(struct pgt_softc *sc, enum pgt_queue pq)
{
	struct pgt_desc *pd;

	pd = TAILQ_FIRST(&sc->sc_freeq[pq]);
	TAILQ_REMOVE(&sc->sc_freeq[pq], pd, pd_link);
	sc->sc_freeq_count[pq]--;
	TAILQ_INSERT_TAIL(&sc->sc_dirtyq[pq], pd, pd_link);
	sc->sc_dirtyq_count[pq]++;
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0,
	    pd->pd_dmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD);
	if (sc->sc_debug & SC_DEBUG_QUEUES)
		DPRINTF(("%s: queue: rx %u <- [%u]\n",
		    sc->sc_dev.dv_xname, pd->pd_fragnum, pq));
	if (sc->sc_debug & SC_DEBUG_UNEXPECTED &&
	    pd->pd_fragp->pf_flags & ~htole16(PF_FLAG_MF))
		DPRINTF(("%s: unknown flags on rx [%u]: %#x\n",
		    sc->sc_dev.dv_xname, pq, letoh16(pd->pd_fragp->pf_flags)));
}

/*
 * Traps are generally used for the firmware to report changes in state
 * back to the host.  Mostly this processes changes in link state, but
 * it needs to also be used to initiate WPA and other authentication
 * schemes in terms of client (station) or server (access point).
 */
void
pgt_trap_received(struct pgt_softc *sc, uint32_t oid, void *trapdata,
    size_t size)
{
	struct pgt_async_trap *pa;
	struct mbuf *m;
	char *p;
	size_t total;

	if (sc->sc_flags & SC_DYING)
		return;

	total = sizeof(oid) + size + sizeof(struct pgt_async_trap);
	if (total > MLEN) {
		MGETHDR(m, M_DONTWAIT, MT_DATA);
		if (m == NULL)
			return;
		MCLGET(m, M_DONTWAIT);
		if (!(m->m_flags & M_EXT)) {
			m_freem(m);
			m = NULL;
		}
	} else
		m = m_get(M_DONTWAIT, MT_DATA);

	if (m == NULL)
		return;
	else
		m->m_len = total;

	pa = mtod(m, struct pgt_async_trap *);
	p = mtod(m, char *) + sizeof(*pa);
	*(uint32_t *)p = oid;
	p += sizeof(uint32_t);
	memcpy(p, trapdata, size);
	pa->pa_mbuf = m;

	TAILQ_INSERT_TAIL(&sc->sc_kthread.sck_traps, pa, pa_link);
	wakeup(&sc->sc_kthread);
}

/*
 * Process a completed management response (all requests should be
 * responded to, quickly) or an event (trap).
 */
void
pgt_mgmtrx_completion(struct pgt_softc *sc, struct pgt_mgmt_desc *pmd)
{
	struct pgt_desc *pd;
	struct pgt_mgmt_frame *pmf;
	uint32_t oid, size;

	pd = TAILQ_FIRST(&sc->sc_dirtyq[PGT_QUEUE_MGMT_RX]);
	TAILQ_REMOVE(&sc->sc_dirtyq[PGT_QUEUE_MGMT_RX], pd, pd_link);
	sc->sc_dirtyq_count[PGT_QUEUE_MGMT_RX]--;
	TAILQ_INSERT_TAIL(&sc->sc_freeq[PGT_QUEUE_MGMT_RX],
	    pd, pd_link);
	sc->sc_freeq_count[PGT_QUEUE_MGMT_RX]++;
	if (letoh16(pd->pd_fragp->pf_size) < sizeof(*pmf)) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: mgmt desc too small: %u\n",
			    sc->sc_dev.dv_xname,
			    letoh16(pd->pd_fragp->pf_size)));
		goto out_nopmd;
	}
	pmf = (struct pgt_mgmt_frame *)pd->pd_mem;
	if (pmf->pmf_version != PMF_VER) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: unknown mgmt version %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_version));
		goto out_nopmd;
	}
	if (pmf->pmf_device != PMF_DEV) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: unknown mgmt dev %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_device));
		goto out;
	}
	if (pmf->pmf_flags & ~PMF_FLAG_VALID) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: unknown mgmt flags %x\n",
			    sc->sc_dev.dv_xname,
			    pmf->pmf_flags & ~PMF_FLAG_VALID));
		goto out;
	}
	if (pmf->pmf_flags & PMF_FLAG_LE) {
		oid = letoh32(pmf->pmf_oid);
		size = letoh32(pmf->pmf_size);
	} else {
		oid = betoh32(pmf->pmf_oid);
		size = betoh32(pmf->pmf_size);
	}
	if (pmf->pmf_operation == PMF_OP_TRAP) {
		pmd = NULL; /* ignored */
		DPRINTF(("%s: mgmt trap received (op %u, oid %#x, len %u)\n",
		    sc->sc_dev.dv_xname,
		    pmf->pmf_operation, oid, size));
		pgt_trap_received(sc, oid, (char *)pmf + sizeof(*pmf),
		    min(size, PGT_FRAG_SIZE - sizeof(*pmf)));
		goto out_nopmd;
	}
	if (pmd == NULL) {
		if (sc->sc_debug & (SC_DEBUG_UNEXPECTED | SC_DEBUG_MGMT))
			DPRINTF(("%s: spurious mgmt received "
			    "(op %u, oid %#x, len %u)\n", sc->sc_dev.dv_xname,
			    pmf->pmf_operation, oid, size));
		goto out_nopmd;
	}
	switch (pmf->pmf_operation) {
	case PMF_OP_RESPONSE:
		pmd->pmd_error = 0;
		break;
	case PMF_OP_ERROR:
		pmd->pmd_error = EPERM;
		goto out;
	default:
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: unknown mgmt op %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_operation));
		pmd->pmd_error = EIO;
		goto out;
	}
	if (oid != pmd->pmd_oid) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			DPRINTF(("%s: mgmt oid changed from %#x -> %#x\n",
			    sc->sc_dev.dv_xname, pmd->pmd_oid, oid));
		pmd->pmd_oid = oid;
	}
	if (pmd->pmd_recvbuf != NULL) {
		if (size > PGT_FRAG_SIZE) {
			if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
				DPRINTF(("%s: mgmt oid %#x has bad size %u\n",
				    sc->sc_dev.dv_xname, oid, size));
			pmd->pmd_error = EIO;
			goto out;
		}
		if (size > pmd->pmd_len)
			pmd->pmd_error = ENOMEM;
		else
			memcpy(pmd->pmd_recvbuf, (char *)pmf + sizeof(*pmf),
			    size);
		pmd->pmd_len = size;
	}

out:
	TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd, pmd_link);
	wakeup_one(pmd);
	if (sc->sc_debug & SC_DEBUG_MGMT)
		DPRINTF(("%s: queue: mgmt %p <- (op %u, oid %#x, len %u)\n",
		    sc->sc_dev.dv_xname, pmd, pmf->pmf_operation,
		    pmd->pmd_oid, pmd->pmd_len));
out_nopmd:
	pgt_reinit_rx_desc_frag(sc, pd);
}

/*
 * Queue packets for reception and defragmentation.  I don't know now
 * whether the rx queue being full enough to start, but not finish,
 * queueing a fragmented packet, can happen.
 */
struct mbuf *
pgt_datarx_completion(struct pgt_softc *sc, enum pgt_queue pq)
{
	struct ifnet *ifp;
	struct pgt_desc *pd;
	struct mbuf *top, **mp, *m;
	size_t datalen;
	uint16_t morefrags, dataoff;
	int tlen = 0;

	ifp = &sc->sc_ic.ic_if;
	m = NULL;
	top = NULL;
	mp = &top;

	while ((pd = TAILQ_FIRST(&sc->sc_dirtyq[pq])) != NULL) {
		TAILQ_REMOVE(&sc->sc_dirtyq[pq], pd, pd_link);
		sc->sc_dirtyq_count[pq]--;
		datalen = letoh16(pd->pd_fragp->pf_size);
		dataoff = letoh32(pd->pd_fragp->pf_addr) - pd->pd_dmaaddr;
		morefrags = pd->pd_fragp->pf_flags & htole16(PF_FLAG_MF);

		if (sc->sc_debug & SC_DEBUG_RXFRAG)
			DPRINTF(("%s: rx frag: len %u memoff %u flags %x\n",
			    sc->sc_dev.dv_xname, datalen, dataoff,
			    pd->pd_fragp->pf_flags));

		/* Add the (two+?) bytes for the header. */
		if (datalen + dataoff > PGT_FRAG_SIZE) {
			if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
				DPRINTF(("%s data rx too big: %u\n",
				    sc->sc_dev.dv_xname, datalen));
			goto fail;
		}

		if (m == NULL)
			MGETHDR(m, M_DONTWAIT, MT_DATA);
		else
			m = m_get(M_DONTWAIT, MT_DATA);

		if (m == NULL)
			goto fail;
		if (datalen > MHLEN) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT)) {
				m_free(m);
				goto fail;
			}
		}
		bcopy(pd->pd_mem + dataoff, mtod(m, char *), datalen);
		m->m_len = datalen;
		tlen += datalen;

		*mp = m;
		mp = &m->m_next;

		TAILQ_INSERT_TAIL(&sc->sc_freeq[pq], pd, pd_link);
		sc->sc_freeq_count[pq]++;
		pgt_reinit_rx_desc_frag(sc, pd);

		if (!morefrags)
			break;
	}

	if (top) {
		top->m_pkthdr.len = tlen;
	}
	return (top);

fail:
	TAILQ_INSERT_TAIL(&sc->sc_freeq[pq], pd, pd_link);
	sc->sc_freeq_count[pq]++;
	pgt_reinit_rx_desc_frag(sc, pd);

	ifp->if_ierrors++;
	m_freem(top);
	return (NULL);
}

int
pgt_oid_get(struct pgt_softc *sc, enum pgt_oid oid,
    void *arg, size_t arglen)
{
	struct pgt_mgmt_desc pmd;
	int error;

	bzero(&pmd, sizeof(pmd));
	pmd.pmd_recvbuf = arg;
	pmd.pmd_len = arglen;
	pmd.pmd_oid = oid;

	error = pgt_mgmt_request(sc, &pmd);
	if (error == 0)
		error = pmd.pmd_error;
	if (error != 0 && error != EPERM && sc->sc_debug & SC_DEBUG_UNEXPECTED)
		DPRINTF(("%s: failure getting oid %#x: %d\n",
		    sc->sc_dev.dv_xname, oid, error));

	return (error);
}

int
pgt_oid_retrieve(struct pgt_softc *sc, enum pgt_oid oid,
    void *arg, size_t arglen)
{
	struct pgt_mgmt_desc pmd;
	int error;

	bzero(&pmd, sizeof(pmd));
	pmd.pmd_sendbuf = arg;
	pmd.pmd_recvbuf = arg;
	pmd.pmd_len = arglen;
	pmd.pmd_oid = oid;

	error = pgt_mgmt_request(sc, &pmd);
	if (error == 0)
		error = pmd.pmd_error;
	if (error != 0 && error != EPERM && sc->sc_debug & SC_DEBUG_UNEXPECTED)
		DPRINTF(("%s: failure retrieving oid %#x: %d\n",
		    sc->sc_dev.dv_xname, oid, error));

	return (error);
}

int
pgt_oid_set(struct pgt_softc *sc, enum pgt_oid oid,
    const void *arg, size_t arglen)
{
	struct pgt_mgmt_desc pmd;
	int error;

	bzero(&pmd, sizeof(pmd));
	pmd.pmd_sendbuf = arg;
	pmd.pmd_len = arglen;
	pmd.pmd_oid = oid;

	error = pgt_mgmt_request(sc, &pmd);
	if (error == 0)
		error = pmd.pmd_error;
	if (error != 0 && error != EPERM && sc->sc_debug & SC_DEBUG_UNEXPECTED)
		DPRINTF(("%s: failure setting oid %#x: %d\n",
		    sc->sc_dev.dv_xname, oid, error));

	return (error);
}

void
pgt_state_dump(struct pgt_softc *sc)
{
	printf("%s: state dump: control 0x%08x interrupt 0x%08x\n",
	    sc->sc_dev.dv_xname,
	    pgt_read_4(sc, PGT_REG_CTRL_STAT),
	    pgt_read_4(sc, PGT_REG_INT_STAT));

	printf("%s: state dump: driver curfrag[]\n",
	    sc->sc_dev.dv_xname);

	printf("%s: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",
	    sc->sc_dev.dv_xname,
	    letoh32(sc->sc_cb->pcb_driver_curfrag[0]),
	    letoh32(sc->sc_cb->pcb_driver_curfrag[1]),
	    letoh32(sc->sc_cb->pcb_driver_curfrag[2]),
	    letoh32(sc->sc_cb->pcb_driver_curfrag[3]),
	    letoh32(sc->sc_cb->pcb_driver_curfrag[4]),
	    letoh32(sc->sc_cb->pcb_driver_curfrag[5]));

	printf("%s: state dump: device curfrag[]\n",
	    sc->sc_dev.dv_xname);

	printf("%s: 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x 0x%08x\n",
	    sc->sc_dev.dv_xname,
	    letoh32(sc->sc_cb->pcb_device_curfrag[0]),
	    letoh32(sc->sc_cb->pcb_device_curfrag[1]),
	    letoh32(sc->sc_cb->pcb_device_curfrag[2]),
	    letoh32(sc->sc_cb->pcb_device_curfrag[3]),
	    letoh32(sc->sc_cb->pcb_device_curfrag[4]),
	    letoh32(sc->sc_cb->pcb_device_curfrag[5]));
}

int
pgt_mgmt_request(struct pgt_softc *sc, struct pgt_mgmt_desc *pmd)
{
	struct pgt_desc *pd;
	struct pgt_mgmt_frame *pmf;
	int error, i;

	if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET))
		return (EIO);
	if (pmd->pmd_len > PGT_FRAG_SIZE - sizeof(*pmf))
		return (ENOMEM);
	pd = TAILQ_FIRST(&sc->sc_freeq[PGT_QUEUE_MGMT_TX]);
	if (pd == NULL)
		return (ENOMEM);
	error = pgt_load_tx_desc_frag(sc, PGT_QUEUE_MGMT_TX, pd);
	if (error)
		return (error);
	pmf = (struct pgt_mgmt_frame *)pd->pd_mem;
	pmf->pmf_version = PMF_VER;
	/* "get" and "retrieve" operations look the same */
	if (pmd->pmd_recvbuf != NULL)
		pmf->pmf_operation = PMF_OP_GET;
	else
		pmf->pmf_operation = PMF_OP_SET;
	pmf->pmf_oid = htobe32(pmd->pmd_oid);
	pmf->pmf_device = PMF_DEV;
	pmf->pmf_flags = 0;
	pmf->pmf_size = htobe32(pmd->pmd_len);
	/* "set" and "retrieve" operations both send data */
	if (pmd->pmd_sendbuf != NULL)
		memcpy(pmf + 1, pmd->pmd_sendbuf, pmd->pmd_len);
	else
		bzero(pmf + 1, pmd->pmd_len);
	pmd->pmd_error = EINPROGRESS;
	TAILQ_INSERT_TAIL(&sc->sc_mgmtinprog, pmd, pmd_link);
	if (sc->sc_debug & SC_DEBUG_MGMT)
		DPRINTF(("%s: queue: mgmt %p -> (op %u, oid %#x, len %u)\n",
		    sc->sc_dev.dv_xname,
		    pmd, pmf->pmf_operation,
		    pmd->pmd_oid, pmd->pmd_len));
	pgt_desc_transmit(sc, PGT_QUEUE_MGMT_TX, pd,
	    sizeof(*pmf) + pmd->pmd_len, 0);
	/*
	 * Try for one second, triggering 10 times.
	 *
	 * Do our best to work around seemingly buggy CardBus controllers
	 * on Soekris 4521 that fail to get interrupts with alarming
	 * regularity: run as if an interrupt occurred and service every
	 * queue except for mbuf reception.
	 */
	i = 0;
	do {
		if (tsleep(pmd, 0, "pgtmgm", hz / 10) != EWOULDBLOCK)
			break;
		if (pmd->pmd_error != EINPROGRESS)
			break;
		if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET)) {
			pmd->pmd_error = EIO;
			TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd, pmd_link);
			break;
		}
		if (i != 9)
			pgt_maybe_trigger(sc, PGT_QUEUE_MGMT_RX);
#ifdef PGT_BUGGY_INTERRUPT_RECOVERY
		pgt_update_intr(sc, 0);
#endif
	} while (i++ < 10);

	if (pmd->pmd_error == EINPROGRESS) {
		printf("%s: timeout waiting for management "
		    "packet response to %#x\n",
		    sc->sc_dev.dv_xname, pmd->pmd_oid);
		TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd, pmd_link);
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			pgt_state_dump(sc);
		pgt_async_reset(sc);
		error = ETIMEDOUT;
	} else
		error = 0;

	return (error);
}

void
pgt_desc_transmit(struct pgt_softc *sc, enum pgt_queue pq, struct pgt_desc *pd,
    uint16_t len, int morecoming)
{
	TAILQ_REMOVE(&sc->sc_freeq[pq], pd, pd_link);
	sc->sc_freeq_count[pq]--;
	TAILQ_INSERT_TAIL(&sc->sc_dirtyq[pq], pd, pd_link);
	sc->sc_dirtyq_count[pq]++;
	if (sc->sc_debug & SC_DEBUG_QUEUES)
		DPRINTF(("%s: queue: tx %u -> [%u]\n", sc->sc_dev.dv_xname,
		    pd->pd_fragnum, pq));
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE);
	if (morecoming)
		pd->pd_fragp->pf_flags |= htole16(PF_FLAG_MF);
	pd->pd_fragp->pf_size = htole16(len);
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0,
	    pd->pd_dmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE);
	sc->sc_cb->pcb_driver_curfrag[pq] =
	    htole32(letoh32(sc->sc_cb->pcb_driver_curfrag[pq]) + 1);
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_PREREAD);
	if (!morecoming)
		pgt_maybe_trigger(sc, pq);
}

void
pgt_maybe_trigger(struct pgt_softc *sc, enum pgt_queue pq)
{
	unsigned int tries = 1000000 / PGT_WRITEIO_DELAY; /* one second */
	uint32_t reg;

	if (sc->sc_debug & SC_DEBUG_TRIGGER)
		DPRINTF(("%s: triggered by queue [%u]\n",
		    sc->sc_dev.dv_xname, pq));
	pgt_debug_events(sc, "trig");
	if (sc->sc_flags & SC_POWERSAVE) {
		/* Magic values ahoy? */
		if (pgt_read_4(sc, PGT_REG_INT_STAT) == 0xabadface) {
			do {
				reg = pgt_read_4(sc, PGT_REG_CTRL_STAT);
				if (!(reg & PGT_CTRL_STAT_SLEEPMODE))
					DELAY(PGT_WRITEIO_DELAY);
			} while (tries-- != 0);
			if (!(reg & PGT_CTRL_STAT_SLEEPMODE)) {
				if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
					DPRINTF(("%s: timeout triggering from "
					    "sleep mode\n",
					    sc->sc_dev.dv_xname));
				pgt_async_reset(sc);
				return;
			}
		}
		pgt_write_4_flush(sc, PGT_REG_DEV_INT,
		    PGT_DEV_INT_WAKEUP);
		DELAY(PGT_WRITEIO_DELAY);
		/* read the status back in */
		(void)pgt_read_4(sc, PGT_REG_CTRL_STAT);
		DELAY(PGT_WRITEIO_DELAY);
	} else {
		pgt_write_4_flush(sc, PGT_REG_DEV_INT, PGT_DEV_INT_UPDATE);
		DELAY(PGT_WRITEIO_DELAY);
	}
}

struct ieee80211_node *
pgt_ieee80211_node_alloc(struct ieee80211com *ic)
{
	struct pgt_ieee80211_node *pin;

	pin = malloc(sizeof(*pin), M_DEVBUF, M_NOWAIT | M_ZERO);
	if (pin != NULL) {
		pin->pin_dot1x_auth = PIN_DOT1X_UNAUTHORIZED;
	}
	return (struct ieee80211_node *)pin;
}

void
pgt_ieee80211_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni,
    int reallynew)
{
	ieee80211_ref_node(ni);
}

void
pgt_ieee80211_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct pgt_ieee80211_node *pin;

	pin = (struct pgt_ieee80211_node *)ni;
	free(pin, M_DEVBUF, 0);
}

void
pgt_ieee80211_node_copy(struct ieee80211com *ic, struct ieee80211_node *dst,
    const struct ieee80211_node *src)
{
	const struct pgt_ieee80211_node *psrc;
	struct pgt_ieee80211_node *pdst;

	psrc = (const struct pgt_ieee80211_node *)src;
	pdst = (struct pgt_ieee80211_node *)dst;
	bcopy(psrc, pdst, sizeof(*psrc));
}

int
pgt_ieee80211_send_mgmt(struct ieee80211com *ic, struct ieee80211_node *ni,
    int type, int arg1, int arg2)
{
	return (EOPNOTSUPP);
}

int
pgt_net_attach(struct pgt_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct ieee80211_rateset *rs;
	uint8_t rates[IEEE80211_RATE_MAXSIZE];
	struct pgt_obj_buffer psbuffer;
	struct pgt_obj_frequencies *freqs;
	uint32_t phymode, country;
	unsigned int chan, i, j, firstchan = -1;
	int error;

	psbuffer.pob_size = htole32(PGT_FRAG_SIZE * PGT_PSM_BUFFER_FRAME_COUNT);
	psbuffer.pob_addr = htole32(sc->sc_psmdmam->dm_segs[0].ds_addr);
	error = pgt_oid_set(sc, PGT_OID_PSM_BUFFER, &psbuffer, sizeof(country));
	if (error)
		return (error);
	error = pgt_oid_get(sc, PGT_OID_PHY, &phymode, sizeof(phymode));
	if (error)
		return (error);
	error = pgt_oid_get(sc, PGT_OID_MAC_ADDRESS, ic->ic_myaddr,
	    sizeof(ic->ic_myaddr));
	if (error)
		return (error);
	error = pgt_oid_get(sc, PGT_OID_COUNTRY, &country, sizeof(country));
	if (error)
		return (error);

	ifp->if_softc = sc;
	ifp->if_ioctl = pgt_ioctl;
	ifp->if_start = pgt_start;
	ifp->if_watchdog = pgt_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);

	/*
	 * Set channels
	 *
	 * Prism hardware likes to report supported frequencies that are
	 * not actually available for the country of origin.
	 */
	j = sizeof(*freqs) + (IEEE80211_CHAN_MAX + 1) * sizeof(uint16_t);
	freqs = malloc(j, M_DEVBUF, M_WAITOK);
	error = pgt_oid_get(sc, PGT_OID_SUPPORTED_FREQUENCIES, freqs, j);
	if (error) {
		free(freqs, M_DEVBUF, 0);
		return (error);
	}

	for (i = 0, j = letoh16(freqs->pof_count); i < j; i++) {
		chan = ieee80211_mhz2ieee(letoh16(freqs->pof_freqlist_mhz[i]),
		    0);

		if (chan > IEEE80211_CHAN_MAX) {
			printf("%s: reported bogus channel (%uMHz)\n",
			    sc->sc_dev.dv_xname, chan);
			free(freqs, M_DEVBUF, 0);
			return (EIO);
		}

		if (letoh16(freqs->pof_freqlist_mhz[i]) < 5000) {
			if (!(phymode & htole32(PGT_OID_PHY_2400MHZ)))
				continue;
			if (country == letoh32(PGT_COUNTRY_USA)) {
				if (chan >= 12 && chan <= 14)
					continue;
			}
			if (chan <= 14)
				ic->ic_channels[chan].ic_flags |=
				    IEEE80211_CHAN_B;
			ic->ic_channels[chan].ic_flags |= IEEE80211_CHAN_PUREG;
		} else {
			if (!(phymode & htole32(PGT_OID_PHY_5000MHZ)))
				continue;
			ic->ic_channels[chan].ic_flags |= IEEE80211_CHAN_A;
		}

		ic->ic_channels[chan].ic_freq =
		    letoh16(freqs->pof_freqlist_mhz[i]);

		if (firstchan == -1)
			firstchan = chan;

		DPRINTF(("%s: set channel %d to freq %uMHz\n",
		    sc->sc_dev.dv_xname, chan,
		    letoh16(freqs->pof_freqlist_mhz[i])));
	}
	free(freqs, M_DEVBUF, 0);
	if (firstchan == -1) {
		printf("%s: no channels found\n", sc->sc_dev.dv_xname);
		return (EIO);
	}

	/*
	 * Set rates
	 */
	bzero(rates, sizeof(rates));
	error = pgt_oid_get(sc, PGT_OID_SUPPORTED_RATES, rates, sizeof(rates));
	if (error)
		return (error);
	for (i = 0; i < sizeof(rates) && rates[i] != 0; i++) {
		switch (rates[i]) {
		case 2:
		case 4:
		case 11:
		case 22:
		case 44: /* maybe */
			if (phymode & htole32(PGT_OID_PHY_2400MHZ)) {
				rs = &ic->ic_sup_rates[IEEE80211_MODE_11B];
				rs->rs_rates[rs->rs_nrates++] = rates[i];
			}
		default:
			if (phymode & htole32(PGT_OID_PHY_2400MHZ)) {
				rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];
				rs->rs_rates[rs->rs_nrates++] = rates[i];
			}
			if (phymode & htole32(PGT_OID_PHY_5000MHZ)) {
				rs = &ic->ic_sup_rates[IEEE80211_MODE_11A];
				rs->rs_rates[rs->rs_nrates++] = rates[i];
			}
			rs = &ic->ic_sup_rates[IEEE80211_MODE_AUTO];
			rs->rs_rates[rs->rs_nrates++] = rates[i];
		}
	}

	ic->ic_caps = IEEE80211_C_WEP | IEEE80211_C_PMGT | IEEE80211_C_TXPMGT |
	    IEEE80211_C_SHSLOT | IEEE80211_C_SHPREAMBLE | IEEE80211_C_MONITOR;
#ifndef IEEE80211_STA_ONLY
	ic->ic_caps |= IEEE80211_C_IBSS | IEEE80211_C_HOSTAP;
#endif
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	/* setup post-attach/pre-lateattach vector functions */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = pgt_newstate;
	ic->ic_node_alloc = pgt_ieee80211_node_alloc;
	ic->ic_newassoc = pgt_ieee80211_newassoc;
	ic->ic_node_free = pgt_ieee80211_node_free;
	ic->ic_node_copy = pgt_ieee80211_node_copy;
	ic->ic_send_mgmt = pgt_ieee80211_send_mgmt;
	ic->ic_max_rssi = 255;	/* rssi is a u_int8_t */

	/* let net80211 handle switching around the media + resetting */
	ieee80211_media_init(ifp, pgt_media_change, pgt_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(PGT_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(PGT_TX_RADIOTAP_PRESENT);
#endif
	return (0);
}

int
pgt_media_change(struct ifnet *ifp)
{
	struct pgt_softc *sc = ifp->if_softc;
	int error;

        error = ieee80211_media_change(ifp);
        if (error == ENETRESET) {
                pgt_update_hw_from_sw(sc, 0, 0);
                error = 0;
        }

        return (error);
}

void
pgt_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct pgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t rate;
	int s;

	imr->ifm_status = 0;
	imr->ifm_active = IFM_IEEE80211 | IFM_NONE;

	if (!(ifp->if_flags & IFF_UP))
		return;

	s = splnet();

	if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate] & IEEE80211_RATE_VAL;
	} else {
		if (pgt_oid_get(sc, PGT_OID_LINK_STATE, &rate, sizeof(rate)))
			goto out;
		rate = letoh32(rate);
		if (sc->sc_debug & SC_DEBUG_LINK) {
			DPRINTF(("%s: %s: link rate %u\n",
			    sc->sc_dev.dv_xname, __func__, rate));
		}
		if (rate == 0)
			goto out;
	}

	imr->ifm_status = IFM_AVALID;
	imr->ifm_active = IFM_IEEE80211;
	if (ic->ic_state == IEEE80211_S_RUN)
		imr->ifm_status |= IFM_ACTIVE;

	imr->ifm_active |= ieee80211_rate2media(ic, rate, ic->ic_curmode);

	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_AHDEMO:
		imr->ifm_active |= IFM_IEEE80211_ADHOC | IFM_FLAG0;
		break;
	case IEEE80211_M_HOSTAP:
		imr->ifm_active |= IFM_IEEE80211_HOSTAP;
		break;
#endif
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	default:
		break;
	}

out:
	splx(s);
}

/*
 * Start data frames.  Critical sections surround the boundary of
 * management frame transmission / transmission acknowledgement / response
 * and data frame transmission / transmission acknowledgement.
 */
void
pgt_start(struct ifnet *ifp)
{
	struct pgt_softc *sc;
	struct ieee80211com *ic;
	struct pgt_desc *pd;
	struct mbuf *m;
	int error;

	sc = ifp->if_softc;
	ic = &sc->sc_ic;

	if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET) ||
	    !(ifp->if_flags & IFF_RUNNING) ||
	    ic->ic_state != IEEE80211_S_RUN) {
		return;
	}

	/*
	 * Management packets should probably be MLME frames
	 * (i.e. hostap "managed" mode); we don't touch the
	 * net80211 management queue.
	 */
	for (; sc->sc_dirtyq_count[PGT_QUEUE_DATA_LOW_TX] <
	    PGT_QUEUE_FULL_THRESHOLD && !IFQ_IS_EMPTY(&ifp->if_snd);) {
		pd = TAILQ_FIRST(&sc->sc_freeq[PGT_QUEUE_DATA_LOW_TX]);
		m = ifq_deq_begin(&ifp->if_snd);
		if (m == NULL)
			break;
		if (m->m_pkthdr.len <= PGT_FRAG_SIZE) {
			error = pgt_load_tx_desc_frag(sc,
			    PGT_QUEUE_DATA_LOW_TX, pd);
			if (error) {
				ifq_deq_rollback(&ifp->if_snd, m);
				break;
			}
			ifq_deq_commit(&ifp->if_snd, m);
			m_copydata(m, 0, m->m_pkthdr.len, pd->pd_mem);
			pgt_desc_transmit(sc, PGT_QUEUE_DATA_LOW_TX,
			    pd, m->m_pkthdr.len, 0);
		} else if (m->m_pkthdr.len <= PGT_FRAG_SIZE * 2) {
			struct pgt_desc *pd2;

			/*
			 * Transmit a fragmented frame if there is
			 * not enough room in one fragment; limit
			 * to two fragments (802.11 itself couldn't
			 * even support a full two.)
			 */
			if (sc->sc_dirtyq_count[PGT_QUEUE_DATA_LOW_TX] + 2 >
			    PGT_QUEUE_FULL_THRESHOLD) {
				ifq_deq_rollback(&ifp->if_snd, m);
				break;
			}
			pd2 = TAILQ_NEXT(pd, pd_link);
			error = pgt_load_tx_desc_frag(sc,
			    PGT_QUEUE_DATA_LOW_TX, pd);
			if (error == 0) {
				error = pgt_load_tx_desc_frag(sc,
				    PGT_QUEUE_DATA_LOW_TX, pd2);
				if (error) {
					pgt_unload_tx_desc_frag(sc, pd);
					TAILQ_INSERT_HEAD(&sc->sc_freeq[
					    PGT_QUEUE_DATA_LOW_TX], pd,
					    pd_link);
				}
			}
			if (error) {
				ifq_deq_rollback(&ifp->if_snd, m);
				break;
			}
			ifq_deq_commit(&ifp->if_snd, m);
			m_copydata(m, 0, PGT_FRAG_SIZE, pd->pd_mem);
			pgt_desc_transmit(sc, PGT_QUEUE_DATA_LOW_TX,
			    pd, PGT_FRAG_SIZE, 1);
			m_copydata(m, PGT_FRAG_SIZE,
			    m->m_pkthdr.len - PGT_FRAG_SIZE, pd2->pd_mem);
			pgt_desc_transmit(sc, PGT_QUEUE_DATA_LOW_TX,
			    pd2, m->m_pkthdr.len - PGT_FRAG_SIZE, 0);
		} else {
			ifq_deq_commit(&ifp->if_snd, m);
			ifp->if_oerrors++;
			m_freem(m);
			m = NULL;
		}
		if (m != NULL) {
			struct ieee80211_node *ni;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
			ifp->if_timer = 1;
			sc->sc_txtimer = 5;
			ni = ieee80211_find_txnode(&sc->sc_ic,
			    mtod(m, struct ether_header *)->ether_dhost);
			if (ni != NULL) {
				ni->ni_inact = 0;
				if (ni != ic->ic_bss)
					ieee80211_release_node(&sc->sc_ic, ni);
			}
#if NBPFILTER > 0
			if (sc->sc_drvbpf != NULL) {
				struct mbuf mb;
				struct ether_header eh;
				struct pgt_tx_radiotap_hdr *tap = &sc->sc_txtap;

				bcopy(mtod(m, struct ether_header *), &eh,
				    sizeof(eh));
				m_adj(m, sizeof(eh));
				m = pgt_ieee80211_encap(sc, &eh, m, NULL);

				tap->wt_flags = 0;
				//tap->wt_rate = rate;
				tap->wt_rate = 0;
				tap->wt_chan_freq =
				    htole16(ic->ic_bss->ni_chan->ic_freq);
				tap->wt_chan_flags =
				    htole16(ic->ic_bss->ni_chan->ic_flags);

				if (m != NULL) {
					mb.m_data = (caddr_t)tap;
					mb.m_len = sc->sc_txtap_len;
					mb.m_next = m;
					mb.m_nextpkt = NULL;
					mb.m_type = 0;
					mb.m_flags = 0;

					bpf_mtap(sc->sc_drvbpf, &mb,
					    BPF_DIRECTION_OUT);
				}
			}
#endif
			m_freem(m);
		}
	}
}

int
pgt_ioctl(struct ifnet *ifp, u_long cmd, caddr_t req)
{
	struct pgt_softc *sc = ifp->if_softc;
	struct ifreq *ifr;
	struct wi_req *wreq;
	struct ieee80211_nodereq_all *na;
	struct ieee80211com *ic;
        struct pgt_obj_bsslist *pob;
        struct wi_scan_p2_hdr *p2hdr;
        struct wi_scan_res *res;
        uint32_t noise;
	int maxscan, i, j, s, error = 0;

	ic = &sc->sc_ic;
	ifr = (struct ifreq *)req;

	s = splnet();
	switch (cmd) {
	case SIOCS80211SCAN:
		/*
		 * This chip scans always as soon as it gets initialized.
		 */

		/*
		 * Give us a bit time to scan in case we were not
		 * initialized before and let the userland process wait.
		 */
		tsleep(&sc->sc_flags, 0, "pgtsca", hz * SCAN_TIMEOUT);

		break;
	case SIOCG80211ALLNODES: {
		struct ieee80211_nodereq *nr = NULL;
		na = (struct ieee80211_nodereq_all *)req;
		wreq = malloc(sizeof(*wreq), M_DEVBUF, M_WAITOK | M_ZERO);

		maxscan = PGT_OBJ_BSSLIST_NBSS;
		pob = malloc(sizeof(*pob) +
		    sizeof(struct pgt_obj_bss) * maxscan, M_DEVBUF, M_WAITOK);
		error = pgt_oid_get(sc, PGT_OID_NOISE_FLOOR, &noise,
		    sizeof(noise));

		if (error == 0) {
			noise = letoh32(noise);
			error = pgt_oid_get(sc, PGT_OID_BSS_LIST, pob,
			    sizeof(*pob) +
			    sizeof(struct pgt_obj_bss) * maxscan);
		}

		if (error == 0) {
			maxscan = min(PGT_OBJ_BSSLIST_NBSS,
			    letoh32(pob->pob_count));
			maxscan = min(maxscan,
			    (sizeof(wreq->wi_val) - sizeof(*p2hdr)) /
			    WI_PRISM2_RES_SIZE);
			p2hdr = (struct wi_scan_p2_hdr *)&wreq->wi_val;
			p2hdr->wi_rsvd = 0;
			p2hdr->wi_reason = 1;
			wreq->wi_len = (maxscan * WI_PRISM2_RES_SIZE) / 2 +
			    sizeof(*p2hdr) / 2;
			wreq->wi_type = WI_RID_SCAN_RES;
		}

		for (na->na_nodes = j = i = 0; i < maxscan &&
		    (na->na_size >= j + sizeof(struct ieee80211_nodereq));
		    i++) {
			/* allocate node space */
			if (nr == NULL)
				nr = malloc(sizeof(*nr), M_DEVBUF, M_WAITOK);

			/* get next BSS scan result */
			res = (struct wi_scan_res *)
			    ((char *)&wreq->wi_val + sizeof(*p2hdr) +
			    i * WI_PRISM2_RES_SIZE);
			pgt_obj_bss2scanres(sc, &pob->pob_bsslist[i],
			    res, noise);

			/* copy it to node structure for ifconfig to read */
			bzero(nr, sizeof(*nr));
			IEEE80211_ADDR_COPY(nr->nr_macaddr, res->wi_bssid);
			IEEE80211_ADDR_COPY(nr->nr_bssid, res->wi_bssid);
			nr->nr_channel = letoh16(res->wi_chan);
			nr->nr_chan_flags = IEEE80211_CHAN_B;
			nr->nr_rssi = letoh16(res->wi_signal);
			nr->nr_max_rssi = 0; /* XXX */
			nr->nr_nwid_len = letoh16(res->wi_ssid_len);
			bcopy(res->wi_ssid, nr->nr_nwid, nr->nr_nwid_len);
			nr->nr_intval = letoh16(res->wi_interval);
			nr->nr_capinfo = letoh16(res->wi_capinfo);
			nr->nr_txrate = res->wi_rate == WI_WAVELAN_RES_1M ? 2 :
			    (res->wi_rate == WI_WAVELAN_RES_2M ? 4 :
			    (res->wi_rate == WI_WAVELAN_RES_5M ? 11 :
			    (res->wi_rate == WI_WAVELAN_RES_11M ? 22 : 0)));
			nr->nr_nrates = 0;
			while (res->wi_srates[nr->nr_nrates] != 0) {
				nr->nr_rates[nr->nr_nrates] =
				    res->wi_srates[nr->nr_nrates] &
				    WI_VAR_SRATES_MASK;
				nr->nr_nrates++;
			}
			nr->nr_flags = 0;
			if (bcmp(nr->nr_macaddr, nr->nr_bssid,
			    IEEE80211_ADDR_LEN) == 0)
				nr->nr_flags |= IEEE80211_NODEREQ_AP;
			error = copyout(nr, (caddr_t)na->na_node + j,
			    sizeof(struct ieee80211_nodereq));
			if (error)
				break;

			/* point to next node entry */
			j += sizeof(struct ieee80211_nodereq);
			na->na_nodes++;
		}
		if (nr)
			free(nr, M_DEVBUF, 0);
		free(pob, M_DEVBUF, 0);
		free(wreq, M_DEVBUF, 0);
		break;
	}
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0) {
				pgt_init(ifp);
				error = ENETRESET;
			}
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				pgt_stop(sc, SC_NEEDS_RESET);
				error = ENETRESET;
			}
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > PGT_FRAG_SIZE) {
			error = EINVAL;
			break;
		}
		/* FALLTHROUGH */
	default:
		error = ieee80211_ioctl(ifp, cmd, req);
		break;
	}

	if (error == ENETRESET) {
		pgt_update_hw_from_sw(sc, 0, 0);
		error = 0;
	}
	splx(s);

	return (error);
}

void
pgt_obj_bss2scanres(struct pgt_softc *sc, struct pgt_obj_bss *pob,
    struct wi_scan_res *scanres, uint32_t noise)
{
	struct ieee80211_rateset *rs;
	struct wi_scan_res ap;
	unsigned int i, n;

	rs = &sc->sc_ic.ic_sup_rates[IEEE80211_MODE_AUTO];
	bzero(&ap, sizeof(ap));
	ap.wi_chan = ieee80211_mhz2ieee(letoh16(pob->pob_channel), 0);
	ap.wi_noise = noise;
	ap.wi_signal = letoh16(pob->pob_rssi);
	IEEE80211_ADDR_COPY(ap.wi_bssid, pob->pob_address);
	ap.wi_interval = letoh16(pob->pob_beacon_period);
	ap.wi_capinfo = letoh16(pob->pob_capinfo);
	ap.wi_ssid_len = min(sizeof(ap.wi_ssid), pob->pob_ssid.pos_length);
	memcpy(ap.wi_ssid, pob->pob_ssid.pos_ssid, ap.wi_ssid_len);
	n = 0;
	for (i = 0; i < 16; i++) {
		if (letoh16(pob->pob_rates) & (1 << i)) {
			if (i > rs->rs_nrates)
				break;
			ap.wi_srates[n++] = ap.wi_rate = rs->rs_rates[i];
			if (n >= sizeof(ap.wi_srates) / sizeof(ap.wi_srates[0]))
				break;
		}
	}
	memcpy(scanres, &ap, WI_PRISM2_RES_SIZE);
}

void
node_mark_active_ap(void *arg, struct ieee80211_node *ni)
{
	/*
	 * HostAP mode lets all nodes stick around unless
	 * the firmware AP kicks them off.
	 */
	ni->ni_inact = 0;
}

void
node_mark_active_adhoc(void *arg, struct ieee80211_node *ni)
{
	struct pgt_ieee80211_node *pin;

	/*
	 * As there is no association in ad-hoc, we let links just
	 * time out naturally as long they are not holding any private
	 * configuration, such as 802.1x authorization.
	 */
	pin = (struct pgt_ieee80211_node *)ni;
	if (pin->pin_dot1x_auth == PIN_DOT1X_AUTHORIZED)
		pin->pin_node.ni_inact = 0;
}

void
pgt_watchdog(struct ifnet *ifp)
{
	struct pgt_softc *sc;

	sc = ifp->if_softc;
	/*
	 * Check for timed out transmissions (and make sure to set
	 * this watchdog to fire again if there is still data in the
	 * output device queue).
	 */
	if (sc->sc_dirtyq_count[PGT_QUEUE_DATA_LOW_TX] != 0) {
		int count;

		ifp->if_timer = 1;
		if (sc->sc_txtimer && --sc->sc_txtimer == 0) {
			count = pgt_drain_tx_queue(sc, PGT_QUEUE_DATA_LOW_TX);
			if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
				DPRINTF(("%s: timeout %d data transmissions\n",
				    sc->sc_dev.dv_xname, count));
		}
	}
	if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET))
		return;
	/*
	 * If we're goign to kick the device out of power-save mode
	 * just to update the BSSID and such, we should not do it
	 * very often; need to determine in what way to do that.
	 */
	if (ifp->if_flags & IFF_RUNNING &&
	    sc->sc_ic.ic_state != IEEE80211_S_INIT &&
	    sc->sc_ic.ic_opmode != IEEE80211_M_MONITOR)
		pgt_async_update(sc);

#ifndef IEEE80211_STA_ONLY
	/*
	 * As a firmware-based HostAP, we should not time out
	 * nodes inside the driver additionally to the timeout
	 * that exists in the firmware.  The only things we
	 * should have to deal with timing out when doing HostAP
	 * are the privacy-related.
	 */
	switch (sc->sc_ic.ic_opmode) {
	case IEEE80211_M_HOSTAP:
		ieee80211_iterate_nodes(&sc->sc_ic,
		    node_mark_active_ap, NULL);
		break;
	case IEEE80211_M_IBSS:
		ieee80211_iterate_nodes(&sc->sc_ic,
		    node_mark_active_adhoc, NULL);
		break;
	default:
		break;
	}
#endif
	ieee80211_watchdog(ifp);
	ifp->if_timer = 1;
}

int
pgt_init(struct ifnet *ifp)
{
	struct pgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	/* set default channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;

	if (!(sc->sc_flags & (SC_DYING | SC_UNINITIALIZED)))
		pgt_update_hw_from_sw(sc,
		    ic->ic_state != IEEE80211_S_INIT,
		    ic->ic_opmode != IEEE80211_M_MONITOR);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Begin background scanning */
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_SCAN, -1);

	return (0);
}

/*
 * After most every configuration change, everything needs to be fully
 * reinitialized.  For some operations (currently, WEP settings
 * in ad-hoc+802.1x mode), the change is "soft" and doesn't remove
 * "associations," and allows EAP authorization to occur again.
 * If keepassoc is specified, the reset operation should try to go
 * back to the BSS had before.
 */
void
pgt_update_hw_from_sw(struct pgt_softc *sc, int keepassoc, int keepnodes)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct arpcom *ac = &ic->ic_ac;
	struct ifnet *ifp = &ac->ac_if;
	struct pgt_obj_key keyobj;
	struct pgt_obj_ssid essid;
	uint8_t availrates[IEEE80211_RATE_MAXSIZE + 1];
	uint32_t mode, bsstype, config, profile, channel, slot, preamble;
	uint32_t wep, exunencrypted, wepkey, dot1x, auth, mlme;
	unsigned int i;
	int success, shouldbeup, s;

	config = PGT_CONFIG_MANUAL_RUN | PGT_CONFIG_RX_ANNEX;

	/*
	 * Promiscuous mode is currently a no-op since packets transmitted,
	 * while in promiscuous mode, don't ever seem to go anywhere.
	 */
	shouldbeup = ifp->if_flags & IFF_RUNNING && ifp->if_flags & IFF_UP;

	if (shouldbeup) {
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			if (ifp->if_flags & IFF_PROMISC)
				mode = PGT_MODE_CLIENT;	/* what to do? */
			else
				mode = PGT_MODE_CLIENT;
			bsstype = PGT_BSS_TYPE_STA;
			dot1x = PGT_DOT1X_AUTH_ENABLED;
			break;
#ifndef IEEE80211_STA_ONLY
		case IEEE80211_M_IBSS:
			if (ifp->if_flags & IFF_PROMISC)
				mode = PGT_MODE_CLIENT;	/* what to do? */
			else
				mode = PGT_MODE_CLIENT;
			bsstype = PGT_BSS_TYPE_IBSS;
			dot1x = PGT_DOT1X_AUTH_ENABLED;
			break;
		case IEEE80211_M_HOSTAP:
			mode = PGT_MODE_AP;
			bsstype = PGT_BSS_TYPE_STA;
			/*
			 * For IEEE 802.1x, we need to authenticate and
			 * authorize hosts from here on or they remain
			 * associated but without the ability to send or
			 * receive normal traffic to us (courtesy the
			 * firmware AP implementation).
			 */
			dot1x = PGT_DOT1X_AUTH_ENABLED;
			/*
			 * WDS mode needs several things to work:
			 * discovery of exactly how creating the WDS
			 * links is meant to function, an interface
			 * for this, and ability to encode or decode
			 * the WDS frames.
			 */
			if (sc->sc_wds)
				config |= PGT_CONFIG_WDS;
			break;
#endif
		case IEEE80211_M_MONITOR:
			mode = PGT_MODE_PROMISCUOUS;
			bsstype = PGT_BSS_TYPE_ANY;
			dot1x = PGT_DOT1X_AUTH_NONE;
			break;
		default:
			goto badopmode;
		}
	} else {
badopmode:
		mode = PGT_MODE_CLIENT;
		bsstype = PGT_BSS_TYPE_NONE;
	}

	DPRINTF(("%s: current mode is ", sc->sc_dev.dv_xname));
	switch (ic->ic_curmode) {
	case IEEE80211_MODE_11A:
		profile = PGT_PROFILE_A_ONLY;
		preamble = PGT_OID_PREAMBLE_MODE_DYNAMIC;
		DPRINTF(("IEEE80211_MODE_11A\n"));
		break;
	case IEEE80211_MODE_11B:
		profile = PGT_PROFILE_B_ONLY;
		preamble = PGT_OID_PREAMBLE_MODE_LONG;
		DPRINTF(("IEEE80211_MODE_11B\n"));
		break;
	case IEEE80211_MODE_11G:
		profile = PGT_PROFILE_G_ONLY;
		preamble = PGT_OID_PREAMBLE_MODE_SHORT;
		DPRINTF(("IEEE80211_MODE_11G\n"));
		break;
	case IEEE80211_MODE_AUTO:
		profile = PGT_PROFILE_MIXED_G_WIFI;
		preamble = PGT_OID_PREAMBLE_MODE_DYNAMIC;
		DPRINTF(("IEEE80211_MODE_AUTO\n"));
		break;
	default:
		panic("unknown mode %d", ic->ic_curmode);
	}

	switch (sc->sc_80211_ioc_auth) {
	case IEEE80211_AUTH_NONE:
		auth = PGT_AUTH_MODE_NONE;
		break;
	case IEEE80211_AUTH_OPEN:
		auth = PGT_AUTH_MODE_OPEN;
		break;
	default:
		auth = PGT_AUTH_MODE_SHARED;
		break;
	}

	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
		wep = 1;
		exunencrypted = 1;
	} else {
		wep = 0;
		exunencrypted = 0;
	}

	mlme = htole32(PGT_MLME_AUTO_LEVEL_AUTO);
	wep = htole32(wep);
	exunencrypted = htole32(exunencrypted);
	profile = htole32(profile);
	preamble = htole32(preamble);
	bsstype = htole32(bsstype);
	config = htole32(config);
	mode = htole32(mode);

	if (!wep || !sc->sc_dot1x)
		dot1x = PGT_DOT1X_AUTH_NONE;
	dot1x = htole32(dot1x);
	auth = htole32(auth);

	if (ic->ic_flags & IEEE80211_F_SHSLOT)
		slot = htole32(PGT_OID_SLOT_MODE_SHORT);
	else
		slot = htole32(PGT_OID_SLOT_MODE_DYNAMIC);

	if (ic->ic_des_chan == IEEE80211_CHAN_ANYC) {
		if (keepassoc)
			channel = 0;
		else
			channel = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	} else
		channel = ieee80211_chan2ieee(ic, ic->ic_des_chan);

	DPRINTF(("%s: set rates", sc->sc_dev.dv_xname));
	for (i = 0; i < ic->ic_sup_rates[ic->ic_curmode].rs_nrates; i++) {
		availrates[i] = ic->ic_sup_rates[ic->ic_curmode].rs_rates[i];
		DPRINTF((" %d", availrates[i]));
	}
	DPRINTF(("\n"));
	availrates[i++] = 0;

	essid.pos_length = min(ic->ic_des_esslen, sizeof(essid.pos_ssid));
	memcpy(&essid.pos_ssid, ic->ic_des_essid, essid.pos_length);

	s = splnet();
	for (success = 0; success == 0; success = 1) {
		SETOID(PGT_OID_PROFILE, &profile, sizeof(profile));
		SETOID(PGT_OID_CONFIG, &config, sizeof(config));
		SETOID(PGT_OID_MLME_AUTO_LEVEL, &mlme, sizeof(mlme));

		if (!IEEE80211_ADDR_EQ(ic->ic_myaddr, ac->ac_enaddr)) {
			SETOID(PGT_OID_MAC_ADDRESS, ac->ac_enaddr,
			    sizeof(ac->ac_enaddr));
			IEEE80211_ADDR_COPY(ic->ic_myaddr, ac->ac_enaddr);
		}

		SETOID(PGT_OID_MODE, &mode, sizeof(mode));
		SETOID(PGT_OID_BSS_TYPE, &bsstype, sizeof(bsstype));

		if (channel != 0 && channel != IEEE80211_CHAN_ANY)
			SETOID(PGT_OID_CHANNEL, &channel, sizeof(channel));

		if (ic->ic_flags & IEEE80211_F_DESBSSID) {
			SETOID(PGT_OID_BSSID, ic->ic_des_bssid,
			    sizeof(ic->ic_des_bssid));
		} else if (keepassoc) {
			SETOID(PGT_OID_BSSID, ic->ic_bss->ni_bssid,
			    sizeof(ic->ic_bss->ni_bssid));
		}

		SETOID(PGT_OID_SSID, &essid, sizeof(essid));

		if (ic->ic_des_esslen > 0)
			SETOID(PGT_OID_SSID_OVERRIDE, &essid, sizeof(essid));

		SETOID(PGT_OID_RATES, &availrates, i);
		SETOID(PGT_OID_EXTENDED_RATES, &availrates, i);
		SETOID(PGT_OID_PREAMBLE_MODE, &preamble, sizeof(preamble));
		SETOID(PGT_OID_SLOT_MODE, &slot, sizeof(slot));
		SETOID(PGT_OID_AUTH_MODE, &auth, sizeof(auth));
		SETOID(PGT_OID_EXCLUDE_UNENCRYPTED, &exunencrypted,
		    sizeof(exunencrypted));
		SETOID(PGT_OID_DOT1X, &dot1x, sizeof(dot1x));
		SETOID(PGT_OID_PRIVACY_INVOKED, &wep, sizeof(wep));
		/*
		 * Setting WEP key(s)
		 */
		if (letoh32(wep) != 0) {
			keyobj.pok_type = PGT_OBJ_KEY_TYPE_WEP;
			/* key 1 */
			keyobj.pok_length = min(sizeof(keyobj.pok_key),
			    IEEE80211_KEYBUF_SIZE);
			keyobj.pok_length = min(keyobj.pok_length,
			    ic->ic_nw_keys[0].k_len);
			bcopy(ic->ic_nw_keys[0].k_key, keyobj.pok_key,
			    keyobj.pok_length);
			SETOID(PGT_OID_DEFAULT_KEY0, &keyobj, sizeof(keyobj));
			/* key 2 */
			keyobj.pok_length = min(sizeof(keyobj.pok_key),
			    IEEE80211_KEYBUF_SIZE);
			keyobj.pok_length = min(keyobj.pok_length,
			    ic->ic_nw_keys[1].k_len);
			bcopy(ic->ic_nw_keys[1].k_key, keyobj.pok_key,
			    keyobj.pok_length);
			SETOID(PGT_OID_DEFAULT_KEY1, &keyobj, sizeof(keyobj));
			/* key 3 */
			keyobj.pok_length = min(sizeof(keyobj.pok_key),
			    IEEE80211_KEYBUF_SIZE);
			keyobj.pok_length = min(keyobj.pok_length,
			    ic->ic_nw_keys[2].k_len);
			bcopy(ic->ic_nw_keys[2].k_key, keyobj.pok_key,
			    keyobj.pok_length);
			SETOID(PGT_OID_DEFAULT_KEY2, &keyobj, sizeof(keyobj));
			/* key 4 */
			keyobj.pok_length = min(sizeof(keyobj.pok_key),
			    IEEE80211_KEYBUF_SIZE);
			keyobj.pok_length = min(keyobj.pok_length,
			    ic->ic_nw_keys[3].k_len);
			bcopy(ic->ic_nw_keys[3].k_key, keyobj.pok_key,
			    keyobj.pok_length);
			SETOID(PGT_OID_DEFAULT_KEY3, &keyobj, sizeof(keyobj));

			wepkey = htole32(ic->ic_wep_txkey);
			SETOID(PGT_OID_DEFAULT_KEYNUM, &wepkey, sizeof(wepkey));
		}
		/* set mode again to commit */
		SETOID(PGT_OID_MODE, &mode, sizeof(mode));
	}
	splx(s);

	if (success) {
		if (shouldbeup && keepnodes)
			sc->sc_flags |= SC_NOFREE_ALLNODES;
		if (shouldbeup)
			ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
		else
			ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	} else {
		printf("%s: problem setting modes\n", sc->sc_dev.dv_xname);
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	}
}

void
pgt_hostap_handle_mlme(struct pgt_softc *sc, uint32_t oid,
    struct pgt_obj_mlme *mlme)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct pgt_ieee80211_node *pin;
	struct ieee80211_node *ni;

	ni = ieee80211_find_node(ic, mlme->pom_address);
	pin = (struct pgt_ieee80211_node *)ni;
	switch (oid) {
	case PGT_OID_DISASSOCIATE:
		if (ni != NULL)
			ieee80211_release_node(&sc->sc_ic, ni);
		break;
	case PGT_OID_ASSOCIATE:
		if (ni == NULL) {
			ni = ieee80211_dup_bss(ic, mlme->pom_address);
			if (ni == NULL)
				break;
			ic->ic_newassoc(ic, ni, 1);
			pin = (struct pgt_ieee80211_node *)ni;
		}
		ni->ni_associd = letoh16(mlme->pom_id);
		pin->pin_mlme_state = letoh16(mlme->pom_state);
		break;
	default:
		if (pin != NULL)
			pin->pin_mlme_state = letoh16(mlme->pom_state);
		break;
	}
}

/*
 * Either in response to an event or after a certain amount of time,
 * synchronize our idea of the network we're part of from the hardware.
 */
void
pgt_update_sw_from_hw(struct pgt_softc *sc, struct pgt_async_trap *pa,
	    struct mbuf *args)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct pgt_obj_ssid ssid;
	struct pgt_obj_bss bss;
	uint32_t channel, noise, ls;
	int error, s;

	if (pa != NULL) {
		struct pgt_obj_mlme *mlme;
		uint32_t oid;

		oid = *mtod(args, uint32_t *);
		m_adj(args, sizeof(uint32_t));
		if (sc->sc_debug & SC_DEBUG_TRAP)
			DPRINTF(("%s: trap: oid %#x len %u\n",
			    sc->sc_dev.dv_xname, oid, args->m_len));
		switch (oid) {
		case PGT_OID_LINK_STATE:
			if (args->m_len < sizeof(uint32_t))
				break;
			ls = letoh32(*mtod(args, uint32_t *));
			if (sc->sc_debug & (SC_DEBUG_TRAP | SC_DEBUG_LINK))
				DPRINTF(("%s: %s: link rate %u\n",
				    sc->sc_dev.dv_xname, __func__, ls));
			if (ls)
				ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
			else
				ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
			goto gotlinkstate;
		case PGT_OID_DEAUTHENTICATE:
		case PGT_OID_AUTHENTICATE:
		case PGT_OID_DISASSOCIATE:
		case PGT_OID_ASSOCIATE:
			if (args->m_len < sizeof(struct pgt_obj_mlme))
				break;
			mlme = mtod(args, struct pgt_obj_mlme *);
			if (sc->sc_debug & SC_DEBUG_TRAP)
				DPRINTF(("%s: mlme: address "
				    "%s id 0x%02x state 0x%02x code 0x%02x\n",
				    sc->sc_dev.dv_xname,
				    ether_sprintf(mlme->pom_address),
				    letoh16(mlme->pom_id),
				    letoh16(mlme->pom_state),
				    letoh16(mlme->pom_code)));
#ifndef IEEE80211_STA_ONLY
			if (ic->ic_opmode == IEEE80211_M_HOSTAP)
				pgt_hostap_handle_mlme(sc, oid, mlme);
#endif
			break;
		}
		return;
	}
	if (ic->ic_state == IEEE80211_S_SCAN) {
		s = splnet();
		error = pgt_oid_get(sc, PGT_OID_LINK_STATE, &ls, sizeof(ls));
		splx(s);
		if (error)
			return;
		DPRINTF(("%s: up_sw_from_hw: link %u\n", sc->sc_dev.dv_xname,
		    htole32(ls)));
		if (ls != 0)
			ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	}

gotlinkstate:
	s = splnet();
	if (pgt_oid_get(sc, PGT_OID_NOISE_FLOOR, &noise, sizeof(noise)) != 0)
		goto out;
	sc->sc_noise = letoh32(noise);
	if (ic->ic_state == IEEE80211_S_RUN) {
		if (pgt_oid_get(sc, PGT_OID_CHANNEL, &channel,
		    sizeof(channel)) != 0)
			goto out;
		channel = min(letoh32(channel), IEEE80211_CHAN_MAX);
		ic->ic_bss->ni_chan = &ic->ic_channels[channel];
		if (pgt_oid_get(sc, PGT_OID_BSSID, ic->ic_bss->ni_bssid,
		    sizeof(ic->ic_bss->ni_bssid)) != 0)
			goto out;
		IEEE80211_ADDR_COPY(&bss.pob_address, ic->ic_bss->ni_bssid);
		error = pgt_oid_retrieve(sc, PGT_OID_BSS_FIND, &bss,
		    sizeof(bss));
		if (error == 0)
			ic->ic_bss->ni_rssi = bss.pob_rssi;
		else if (error != EPERM)
			goto out;
		error = pgt_oid_get(sc, PGT_OID_SSID, &ssid, sizeof(ssid));
		if (error)
			goto out;
		ic->ic_bss->ni_esslen = min(ssid.pos_length,
		    sizeof(ic->ic_bss->ni_essid));
		memcpy(ic->ic_bss->ni_essid, ssid.pos_ssid,
		    ssid.pos_length);
	}

out:
	splx(s);
}

int
pgt_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct pgt_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;

	ostate = ic->ic_state;

	DPRINTF(("%s: newstate %s -> %s\n", sc->sc_dev.dv_xname,
	    ieee80211_state_name[ostate], ieee80211_state_name[nstate]));

	switch (nstate) {
	case IEEE80211_S_INIT:
		if (sc->sc_dirtyq_count[PGT_QUEUE_DATA_LOW_TX] == 0)
			ic->ic_if.if_timer = 0;
		ic->ic_mgt_timer = 0;
		ic->ic_flags &= ~IEEE80211_F_SIBSS;
		ieee80211_free_allnodes(ic);
		break;
	case IEEE80211_S_SCAN:
		ic->ic_if.if_timer = 1;
		ic->ic_mgt_timer = 0;
		if (sc->sc_flags & SC_NOFREE_ALLNODES)
			sc->sc_flags &= ~SC_NOFREE_ALLNODES;
		else
			ieee80211_free_allnodes(ic);

#ifndef IEEE80211_STA_ONLY
		/* Just use any old channel; we override it anyway. */
		if (ic->ic_opmode == IEEE80211_M_HOSTAP)
			ieee80211_create_ibss(ic, ic->ic_ibss_chan);
#endif
		break;
	case IEEE80211_S_RUN:
		ic->ic_if.if_timer = 1;
		break;
	default:
		break;
	}

	return (sc->sc_newstate(ic, nstate, arg));
}

int
pgt_drain_tx_queue(struct pgt_softc *sc, enum pgt_queue pq)
{
	int wokeup = 0;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTREAD | BUS_DMASYNC_PREWRITE);
	sc->sc_cb->pcb_device_curfrag[pq] =
	    sc->sc_cb->pcb_driver_curfrag[pq];
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0,
	    sc->sc_cbdmam->dm_mapsize,
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_PREREAD);
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[pq])) {
		struct pgt_desc *pd;

		pd = TAILQ_FIRST(&sc->sc_dirtyq[pq]);
		TAILQ_REMOVE(&sc->sc_dirtyq[pq], pd, pd_link);
		sc->sc_dirtyq_count[pq]--;
		TAILQ_INSERT_TAIL(&sc->sc_freeq[pq], pd, pd_link);
		sc->sc_freeq_count[pq]++;
		pgt_unload_tx_desc_frag(sc, pd);
		if (sc->sc_debug & SC_DEBUG_QUEUES)
			DPRINTF(("%s: queue: tx %u <- [%u] (drained)\n",
			    sc->sc_dev.dv_xname, pd->pd_fragnum, pq));
		wokeup++;
		if (pgt_queue_is_data(pq))
			sc->sc_ic.ic_if.if_oerrors++;
	}

	return (wokeup);
}

int
pgt_dma_alloc(struct pgt_softc *sc)
{
	size_t size;
	int i, error, nsegs;

	for (i = 0; i < PGT_QUEUE_COUNT; i++) {
		TAILQ_INIT(&sc->sc_freeq[i]);
		TAILQ_INIT(&sc->sc_dirtyq[i]);
	}

	/*
	 * control block
	 */
	size = sizeof(struct pgt_control_block);

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_NOWAIT, &sc->sc_cbdmam);
	if (error != 0) {
		printf("%s: can not create DMA tag for control block\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE,
	    0, &sc->sc_cbdmas, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: can not allocate DMA memory for control block\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->sc_cbdmas, nsegs,
	    size, (caddr_t *)&sc->sc_cb, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can not map DMA memory for control block\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_cbdmam,
	    sc->sc_cb, size, NULL, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can not load DMA map for control block\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	/*
	 * powersave
	 */
	size = PGT_FRAG_SIZE * PGT_PSM_BUFFER_FRAME_COUNT;

	error = bus_dmamap_create(sc->sc_dmat, size, 1, size, 0,
	    BUS_DMA_ALLOCNOW, &sc->sc_psmdmam);
	if (error != 0) {
		printf("%s: can not create DMA tag for powersave\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamem_alloc(sc->sc_dmat, size, PAGE_SIZE,
	   0, &sc->sc_psmdmas, 1, &nsegs, BUS_DMA_NOWAIT | BUS_DMA_ZERO);
	if (error != 0) {
		printf("%s: can not allocate DMA memory for powersave\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamem_map(sc->sc_dmat, &sc->sc_psmdmas, nsegs,
	    size, (caddr_t *)&sc->sc_psmbuf, BUS_DMA_NOWAIT);
	if (error != 0) {
		printf("%s: can not map DMA memory for powersave\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	error = bus_dmamap_load(sc->sc_dmat, sc->sc_psmdmam,
	    sc->sc_psmbuf, size, NULL, BUS_DMA_WAITOK);
	if (error != 0) {
		printf("%s: can not load DMA map for powersave\n",
		    sc->sc_dev.dv_xname);
		goto out;
	}

	/*
	 * fragments
	 */
	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_DATA_LOW_RX);
	if (error != 0)
		goto out;

	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_DATA_LOW_TX);
	if (error != 0)
		goto out;

	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_DATA_HIGH_RX);
	if (error != 0)
		goto out;

	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_DATA_HIGH_TX);
	if (error != 0)
		goto out;

	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_MGMT_RX);
	if (error != 0)
		goto out;

	error = pgt_dma_alloc_queue(sc, PGT_QUEUE_MGMT_TX);
	if (error != 0)
		goto out;

out:
	if (error) {
		printf("%s: error in DMA allocation\n", sc->sc_dev.dv_xname);
		pgt_dma_free(sc);
	}

	return (error);
}

int
pgt_dma_alloc_queue(struct pgt_softc *sc, enum pgt_queue pq)
{
	struct pgt_desc *pd;
	size_t i, qsize;
	int error, nsegs;

	switch (pq) {
		case PGT_QUEUE_DATA_LOW_RX:
			qsize = PGT_QUEUE_DATA_RX_SIZE;
			break;
		case PGT_QUEUE_DATA_LOW_TX:
			qsize = PGT_QUEUE_DATA_TX_SIZE;
			break;
		case PGT_QUEUE_DATA_HIGH_RX:
			qsize = PGT_QUEUE_DATA_RX_SIZE;
			break;
		case PGT_QUEUE_DATA_HIGH_TX:
			qsize = PGT_QUEUE_DATA_TX_SIZE;
			break;
		case PGT_QUEUE_MGMT_RX:
			qsize = PGT_QUEUE_MGMT_SIZE;
			break;
		case PGT_QUEUE_MGMT_TX:
			qsize = PGT_QUEUE_MGMT_SIZE;
			break;
		default:
			return (EINVAL);
	}

	for (i = 0; i < qsize; i++) {
		pd = malloc(sizeof(*pd), M_DEVBUF, M_WAITOK);

		error = bus_dmamap_create(sc->sc_dmat, PGT_FRAG_SIZE, 1,
		    PGT_FRAG_SIZE, 0, BUS_DMA_ALLOCNOW, &pd->pd_dmam);
		if (error != 0) {
			printf("%s: can not create DMA tag for fragment\n",
			    sc->sc_dev.dv_xname);
			free(pd, M_DEVBUF, 0);
			break;
		}

		error = bus_dmamem_alloc(sc->sc_dmat, PGT_FRAG_SIZE, PAGE_SIZE,
		    0, &pd->pd_dmas, 1, &nsegs, BUS_DMA_WAITOK);
		if (error != 0) {
			printf("%s: error alloc frag %zu on queue %u\n",
			    sc->sc_dev.dv_xname, i, pq);
			free(pd, M_DEVBUF, 0);
			break;
		}

		error = bus_dmamem_map(sc->sc_dmat, &pd->pd_dmas, nsegs,
		    PGT_FRAG_SIZE, (caddr_t *)&pd->pd_mem, BUS_DMA_WAITOK);
		if (error != 0) {
			printf("%s: error map frag %zu on queue %u\n",
			    sc->sc_dev.dv_xname, i, pq);
			free(pd, M_DEVBUF, 0);
			break;
		}

		if (pgt_queue_is_rx(pq)) {
			error = bus_dmamap_load(sc->sc_dmat, pd->pd_dmam,
			    pd->pd_mem, PGT_FRAG_SIZE, NULL, BUS_DMA_NOWAIT);
			if (error != 0) {
				printf("%s: error load frag %zu on queue %u\n",
				    sc->sc_dev.dv_xname, i, pq);
				bus_dmamem_free(sc->sc_dmat, &pd->pd_dmas,
				    nsegs);
				free(pd, M_DEVBUF, 0);
				break;
			}
			pd->pd_dmaaddr = pd->pd_dmam->dm_segs[0].ds_addr;
		}
		TAILQ_INSERT_TAIL(&sc->sc_freeq[pq], pd, pd_link);
	}

	return (error);
}

void
pgt_dma_free(struct pgt_softc *sc)
{
	/*
	 * fragments
	 */
	if (sc->sc_dmat != NULL) {
		pgt_dma_free_queue(sc, PGT_QUEUE_DATA_LOW_RX);
		pgt_dma_free_queue(sc, PGT_QUEUE_DATA_LOW_TX);
		pgt_dma_free_queue(sc, PGT_QUEUE_DATA_HIGH_RX);
		pgt_dma_free_queue(sc, PGT_QUEUE_DATA_HIGH_TX);
		pgt_dma_free_queue(sc, PGT_QUEUE_MGMT_RX);
		pgt_dma_free_queue(sc, PGT_QUEUE_MGMT_TX);
	}

	/*
	 * powersave
	 */
	if (sc->sc_psmbuf != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->sc_psmdmam);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_psmdmas, 1);
		sc->sc_psmbuf = NULL;
		sc->sc_psmdmam = NULL;
	}

	/*
	 * control block
	 */
	if (sc->sc_cb != NULL) {
		bus_dmamap_unload(sc->sc_dmat, sc->sc_cbdmam);
		bus_dmamem_free(sc->sc_dmat, &sc->sc_cbdmas, 1);
		sc->sc_cb = NULL;
		sc->sc_cbdmam = NULL;
	}
}

void
pgt_dma_free_queue(struct pgt_softc *sc, enum pgt_queue pq)
{
	struct pgt_desc	*pd;

	while (!TAILQ_EMPTY(&sc->sc_freeq[pq])) {
		pd = TAILQ_FIRST(&sc->sc_freeq[pq]);
		TAILQ_REMOVE(&sc->sc_freeq[pq], pd, pd_link);
		if (pd->pd_dmam != NULL) {
			bus_dmamap_unload(sc->sc_dmat, pd->pd_dmam);
			pd->pd_dmam = NULL;
		}
		bus_dmamem_free(sc->sc_dmat, &pd->pd_dmas, 1);
		free(pd, M_DEVBUF, 0);
	}
}

int
pgt_activate(struct device *self, int act)
{
	struct pgt_softc *sc = (struct pgt_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	DPRINTF(("%s: %s(%d)\n", sc->sc_dev.dv_xname, __func__, why));

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING) {
			pgt_stop(sc, SC_NEEDS_RESET);
			pgt_update_hw_from_sw(sc, 0, 0);
		}
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, act);
		break;
	case DVACT_WAKEUP:
		pgt_wakeup(sc);
		break;
	}
	return 0;
}

void
pgt_wakeup(struct pgt_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (sc->sc_power != NULL)
		(*sc->sc_power)(sc, DVACT_RESUME);

	pgt_stop(sc, SC_NEEDS_RESET);
	pgt_update_hw_from_sw(sc, 0, 0);

	if (ifp->if_flags & IFF_UP) {
		pgt_init(ifp);
		pgt_update_hw_from_sw(sc, 0, 0);
	}
}
@


1.88
log
@m_free() and m_freem() test for NULL.  Simplify callers which had their own
NULL tests.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.87 2016/04/13 10:49:26 mpi Exp $  */
a2183 1
			ifp->if_opackets++;
@


1.87
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.86 2016/01/12 09:28:09 stsp Exp $  */
d1541 1
a1541 2
	if (top)
		m_freem(top);
d2226 1
a2226 2
			if (m != NULL)
				m_freem(m);
@


1.86
log
@Remove wireless turbo mode support. It is a non-standard extension
which only worked with ath(4) devices from a decade ago.
Diff tested on ath(4) hardware by me to verify that 11a/b modes still work.
ok reyk deraadt chris sthen kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.85 2015/12/11 16:07:01 mpi Exp $  */
a1880 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.85
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.84 2015/11/25 03:09:58 dlg Exp $  */
a2637 2
	case IEEE80211_MODE_TURBO: /* not handled */
		/* FALLTHROUGH */
@


1.84
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.83 2015/11/24 17:11:39 mpi Exp $  */
d557 1
a557 1
pgt_attach(void *xsc)
d559 1
a559 1
	struct pgt_softc *sc = xsc;
@


1.83
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.82 2015/11/24 13:45:06 mpi Exp $  */
d551 2
a552 1
	ic->ic_if.if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d750 2
a751 2
					sc->sc_ic.ic_if.if_flags &=
					    ~IFF_OACTIVE;
d2528 1
a2528 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.82
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.81 2015/11/24 13:33:17 mpi Exp $  */
a65 1
#include <net/if_dl.h>
@


1.81
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.80 2015/11/20 03:35:22 dlg Exp $  */
a65 1
#include <net/if_arp.h>
@


1.80
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.79 2015/10/25 12:48:46 mpi Exp $  */
a69 1
#include <net/if_types.h>
@


1.79
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.78 2015/05/21 09:36:20 mpi Exp $  */
d2123 1
a2123 1
		IFQ_POLL(&ifp->if_snd, m);
d2129 2
a2130 1
			if (error)
d2132 2
a2133 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
d2147 2
a2148 1
			    PGT_QUEUE_FULL_THRESHOLD)
d2150 1
d2164 2
a2165 1
			if (error)
d2167 2
a2168 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
d2177 1
a2177 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.78
log
@No need to set "rcvif", if_input() does it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.77 2014/12/22 02:28:51 tedu Exp $  */
a2233 1
	struct ifaddr *ifa;
a2349 1
		ifa = (struct ifaddr *)req;
a2350 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			 arp_ifinit(&sc->sc_ic.ic_ac, ifa);
@


1.77
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.76 2014/12/19 22:44:58 guenther Exp $  */
a1533 1
		top->m_pkthdr.rcvif = ifp;
@


1.76
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.75 2014/07/22 13:12:12 mpi Exp $  */
a75 1
#ifdef INET
a77 1
#endif
a2353 1
#ifdef INET
a2355 1
#endif
@


1.75
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.74 2014/07/12 18:48:17 tedu Exp $  */
a62 1
#include <machine/endian.h>
@


1.74
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.73 2013/12/06 21:03:03 deraadt Exp $  */
a78 1
#include <netinet/in_systm.h>
a79 1
#include <netinet/ip.h>
@


1.73
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.72 2013/11/14 12:24:18 dlg Exp $  */
d315 1
a315 1
		free(ucode, M_DEVBUF);
d369 1
a369 1
	free(ucode, M_DEVBUF);
d1830 1
a1830 1
	free(pin, M_DEVBUF);
d1901 1
a1901 1
		free(freqs, M_DEVBUF);
d1912 1
a1912 1
			free(freqs, M_DEVBUF);
d1943 1
a1943 1
	free(freqs, M_DEVBUF);
d2351 3
a2353 3
			free(nr, M_DEVBUF);
		free(pob, M_DEVBUF);
		free(wreq, M_DEVBUF);
d3187 1
a3187 1
			free(pd, M_DEVBUF);
d3196 1
a3196 1
			free(pd, M_DEVBUF);
d3205 1
a3205 1
			free(pd, M_DEVBUF);
d3217 1
a3217 1
				free(pd, M_DEVBUF);
d3277 1
a3277 1
		free(pd, M_DEVBUF);
@


1.72
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.71 2013/10/01 20:05:59 sf Exp $  */
a60 1
#include <sys/task.h>
d192 1
a192 1
void	 pgt_resume(void *, void *);
a581 2
	task_set(&sc->sc_resume_t, pgt_resume, sc, NULL);

d3298 2
a3299 2
	case DVACT_RESUME:
		task_add(systq, &sc->sc_resume_t);
d3306 1
a3306 1
pgt_resume(void *arg1, void *arg2)
a3307 1
	struct pgt_softc *sc = arg1;
@


1.71
log
@Use %z* for size_t

while there, fix a few %d into %u
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.70 2013/08/07 01:06:30 bluhm Exp $  */
d61 1
a61 1
#include <sys/workq.h>
d583 2
d3302 1
a3302 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    pgt_resume, sc, NULL);
@


1.70
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.69 2012/12/05 23:20:18 deraadt Exp $  */
d3195 1
a3195 1
			printf("%s: error alloc frag %u on queue %u\n",
d3204 1
a3204 1
			printf("%s: error map frag %u on queue %u\n",
d3214 1
a3214 1
				printf("%s: error load frag %u on queue %u\n",
@


1.69
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.68 2011/12/01 23:34:08 miod Exp $  */
a80 1
#include <netinet/in_var.h>
@


1.68
log
@Be sure to splx() before return in pgt_media_status(); from Jan Klemkow on
tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.67 2011/06/21 16:52:45 tedu Exp $  */
a46 1
#include <sys/cdefs.h>
@


1.67
log
@remove some unnecessary casts.  ok blambert deraadt kettenis matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.66 2010/09/20 07:40:41 deraadt Exp $  */
d2059 1
a2059 1
			return;
d2066 1
a2066 1
			return;
d2097 1
@


1.66
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.65 2010/09/07 16:21:42 deraadt Exp $  */
d1687 1
a1687 2
		memcpy((char *)pmf + sizeof(*pmf), pmd->pmd_sendbuf,
		    pmd->pmd_len);
d1689 1
a1689 1
		bzero((char *)pmf + sizeof(*pmf), pmd->pmd_len);
@


1.65
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.64 2010/08/27 20:06:39 deraadt Exp $  */
a194 1
void	 pgt_shutdown(void *);
a635 6
	/*
	 * Disable shutdown and power hooks
	 */
        if (sc->sc_shutdown_hook != NULL)
                shutdownhook_disestablish(sc->sc_shutdown_hook);

a2020 8

	/*
         * Enable shutdown and power hooks
         */
        sc->sc_shutdown_hook = shutdownhook_establish(pgt_shutdown, sc);
        if (sc->sc_shutdown_hook == NULL)
                printf("%s: WARNING: unable to establish shutdown hook\n",
                    sc->sc_dev.dv_xname);
a3281 10
}

void
pgt_shutdown(void *arg)
{
	struct pgt_softc *sc = arg;

	DPRINTF(("%s: %s\n", sc->sc_dev.dv_xname, __func__));

	pgt_stop(sc, SC_DYING);
@


1.64
log
@Massage the powerhook function into an activate function, and since we do
not neccessarily have a working filesystem for the firmware yet, use a workq
to postpone resume.  Then make the powerhook function call the activate
function.  There remains some questions about the sc_power functions...
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.63 2010/08/27 17:08:00 jsg Exp $  */
a195 1
void	 pgt_powerhook(int, void *);
a641 2
        if (sc->sc_power_hook != NULL)
                powerhook_disestablish(sc->sc_power_hook);
a2035 5
        sc->sc_power_hook = powerhook_establish(pgt_powerhook, sc);
        if (sc->sc_power_hook == NULL)
                printf("%s: WARNING: unable to establish power hook\n",
                    sc->sc_dev.dv_xname);

a3349 6
}

void
pgt_powerhook(int why, void *arg)
{
	pgt_activate(arg, why);
@


1.63
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.62 2010/08/27 04:09:18 deraadt Exp $  */
d62 1
d196 2
a197 1
void	 pgt_power(int, void *);
d2039 1
a2039 1
        sc->sc_power_hook = powerhook_establish(pgt_power, sc);
d3317 2
a3318 2
void
pgt_power(int why, void *arg)
d3320 1
a3320 1
	struct pgt_softc *sc = arg;
a3321 1
	int s;
d3325 22
a3346 1
	s = splnet();
d3348 2
a3349 4
	switch (why) {
	case PWR_SUSPEND:
		pgt_stop(sc, SC_NEEDS_RESET);
		pgt_update_hw_from_sw(sc, 0, 0);
d3351 2
a3352 6
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
		break;
	case PWR_RESUME:
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, why);
d3354 2
a3355 1
		pgt_stop(sc, SC_NEEDS_RESET);
a3356 7

		if ((ifp->if_flags & IFF_UP) &&
		    !(ifp->if_flags & IFF_RUNNING)) {
			pgt_init(ifp);
			pgt_update_hw_from_sw(sc, 0, 0);
		}
		break;
d3358 1
d3360 4
a3363 1
	splx(s);
@


1.62
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.61 2010/08/07 16:16:18 kettenis Exp $  */
a1893 1
	ifp->if_init = pgt_init;
@


1.61
log
@Unmap registers upon detach.  Avoid panics when detaching a partially attached
device.  Found out the hard way by hotplugging an unsupported "Soft-Mac"
device.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.60 2010/08/07 03:50:01 krw Exp $  */
a3327 1
	case PWR_STANDBY:
@


1.60
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.59 2010/05/19 15:27:35 oga Exp $  */
d606 1
@


1.59
log
@BUS_DMA_ZERO instead of alloc, map, bzero.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.58 2010/04/20 22:05:43 tedu Exp $  */
d2678 1
a2678 1
		panic("unknown mode %d\n", ic->ic_curmode);
@


1.58
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.57 2010/03/29 23:33:39 krw Exp $  */
d3077 1
a3077 1
	    0, &sc->sc_cbdmas, 1, &nsegs, BUS_DMA_NOWAIT);
a3090 1
	bzero(sc->sc_cb, size);
d3114 1
a3114 1
	   0, &sc->sc_psmdmas, 1, &nsegs, BUS_DMA_NOWAIT);
a3127 1
	bzero(sc->sc_psmbuf, size);
@


1.57
log
@Initialize various uninitialized variables. Found by jsg@@ via Clang.

Feedback from miod@@ and kettenis@@.

ok beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.56 2009/12/30 01:24:54 chl Exp $  */
a57 1
#include <sys/sysctl.h>
@


1.56
log
@remove dead assignments and newly created unused variables.

found by LLVM/Clang Static Analyzer.

ok claudio@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.55 2009/11/12 15:27:49 deraadt Exp $  */
d3202 2
@


1.55
log
@memory leak found by parfait in an ioctl path, ok damien jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.54 2009/11/06 09:02:42 fgsch Exp $  */
d719 1
a719 1
		size_t qdirty, qfree, qtotal;
a722 1
		qtotal = qdirty + qfree;
d736 2
a737 2
			 * Receive queues clean up below, so qfree must
			 * always be qtotal (qdirty is 0).
d931 1
a931 1
	uint8_t rate, rssi;
a1007 1
		rate = pha->pra_rate;
a3179 1
	struct pgt_frag *pcbqueue;
a3184 1
			pcbqueue = sc->sc_cb->pcb_data_low_rx;
a3187 1
			pcbqueue = sc->sc_cb->pcb_data_low_tx;
a3190 1
			pcbqueue = sc->sc_cb->pcb_data_high_rx;
a3193 1
			pcbqueue = sc->sc_cb->pcb_data_high_tx;
a3196 1
			pcbqueue = sc->sc_cb->pcb_mgmt_rx;
a3199 1
			pcbqueue = sc->sc_cb->pcb_mgmt_tx;
@


1.54
log
@cosmetic. claudio@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.53 2009/01/26 19:09:41 damien Exp $  */
d2380 1
@


1.53
log
@Add some initial HT bits (not enabled yet) based on 802.11n Draft 7.01:
- implement A-MPDU frames buffering and reordering
- implement A-MSDU decapsulation
- process/send ADDBA Request, ADDBA Response and DELBA action frames
- process Block Ack Request control frames (including MTBAR)
- implement PBAC support (Protected Block Ack)
- add some incomplete HT Capabilities and HT Operation IEs parsing

Add more Management Frame Protection bits based on 802.11w Draft 7.0:
- implement SA Query procedure (both AP and STA)
- cleanup BIP

Fix some bugs:
- fix check for WEP key length that otherwise caused a stack smash in
  ieee80211_wep_encrypt (pointed out by Xavier Santolaria on macppc)
- properly stop EAPOL timeout: fixes a panic that occured in HostAP mode
  when turning the interface down while a 4-way handshake is in progress
  (pointed out by Doughertys)

Did some code cleanup too.

The HT bits are currently not compiled in (IEEE80211_NO_HT is defined)
because they won't be ready until after the next release and I didn't
want to grow the kernel or to inadvertently introduce new bugs.
They are here such that other people can look at the code.
Notice that I had to add an extra parameter to ic_send_mgmt() for
action frames, that is why there are small changes in drivers defining
their own ic_send_mgmt() handler.

Sorry for the not very incremental diff but this has been sitting in
my tree for too long now.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.52 2008/08/29 12:14:53 damien Exp $  */
d134 1
a134 1
	     struct pgt_frag []);
d380 1
a380 1
    struct pgt_frag pqfrags[])
@


1.52
log
@move code to support Frequency-Hopping spread spectrum (FHSS) PHYs
to the Attic.  nothing uses it in the tree and it is very unlikely
that something will use it one day.
the only driver supporting FHSS PHYs in the tree is ray(4) and it
does not use net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.51 2008/08/27 09:05:03 damien Exp $  */
d174 1
a174 1
	     struct ieee80211_node *, int, int);
d1861 1
a1861 1
    int type, int arg)
@


1.51
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.50 2008/07/21 18:43:19 damien Exp $  */
a2671 2
	case IEEE80211_MODE_FH:
		/* FALLTHROUGH */
@


1.50
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.49 2008/07/01 11:44:12 claudio Exp $  */
d852 3
a854 1
		} else {
d874 1
d896 1
d911 1
d1996 5
a2000 4
	ic->ic_caps = IEEE80211_C_WEP | IEEE80211_C_IBSS | IEEE80211_C_PMGT |
	    IEEE80211_C_HOSTAP | IEEE80211_C_TXPMGT | IEEE80211_C_SHSLOT |
	    IEEE80211_C_SHPREAMBLE | IEEE80211_C_MONITOR;

d2104 1
d2114 1
d2522 1
d2542 1
d2610 1
d2640 1
d2926 1
d2929 1
d3007 1
d3011 1
@


1.49
log
@Do not use MINCLSIZE to figure out if a single mbuf or a mcluster should be
used. Instead use MHLEN and MLEN acordingly because MINCLSIZE is bigger than
a single mbuf now.
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.48 2008/04/16 18:32:15 damien Exp $  */
d919 1
d1038 4
a1041 3
			ni->ni_rssi = rssi;
			ni->ni_rstamp = rstamp;
			ieee80211_input(ifp, m, ni, rssi, rstamp);
@


1.48
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.47 2008/03/13 23:07:29 brad Exp $  */
d1332 1
a1332 1
	if (total >= MINCLSIZE) {
d1521 1
a1521 1
		if (datalen >= MINCLSIZE) {
@


1.47
log
@Do not increment the input packet counter in these drivers as
ieee80211_input() already does this.

Mentioned by Peter Philipp in PR 5248.

ok claudio@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.46 2007/12/30 17:37:57 claudio Exp $  */
a2980 4
		if (ic->ic_wep_ctx != NULL) {
			free(ic->ic_wep_ctx, M_DEVBUF);  
			ic->ic_wep_ctx = NULL;
		}
@


1.46
log
@Only do pullups when necessary, m_pullup() always prepends an mbuf
which is very bad if it is not necessary as it causes scrary mbuf
fragmentation.
tested and OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.45 2007/09/18 00:46:41 krw Exp $  */
a1543 1
		ifp->if_ipackets++;
@


1.45
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.44 2007/08/28 18:34:38 deraadt Exp $  */
a839 2
	if (m != NULL)
		m = m_pullup(m, sizeof(*frame) + sizeof(*snap));
d842 5
@


1.44
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.43 2007/07/18 18:10:31 damien Exp $  */
d1815 1
a1815 1
	pin = malloc(sizeof(*pin), M_DEVBUF, M_NOWAIT);
a1816 1
		bzero(pin, sizeof *pin);
d2286 1
a2286 2
		wreq = malloc(sizeof(*wreq), M_DEVBUF, M_WAITOK);
		bzero(wreq, sizeof(*wreq));
@


1.43
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.42 2007/05/22 04:29:16 ray Exp $  */
d311 1
a311 1
		DPRINTF(("%s: error %d, could not read microcode %s!\n",
@


1.42
log
@Pass string to printf instead of struct that contains string.

OK tedu@@ and miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.41 2007/02/14 20:09:20 claudio Exp $  */
d2778 2
a2779 2
			    ic->ic_nw_keys[0].wk_len);
			bcopy(ic->ic_nw_keys[0].wk_key, keyobj.pok_key,
d2786 2
a2787 2
			    ic->ic_nw_keys[1].wk_len);
			bcopy(ic->ic_nw_keys[1].wk_key, keyobj.pok_key,
d2794 2
a2795 2
			    ic->ic_nw_keys[2].wk_len);
			bcopy(ic->ic_nw_keys[2].wk_key, keyobj.pok_key,
d2802 2
a2803 2
			    ic->ic_nw_keys[3].wk_len);
			bcopy(ic->ic_nw_keys[3].wk_key, keyobj.pok_key,
@


1.41
log
@Add SIOCADDMULTI and SIOCDELMULTI ioctl handlers. Without them IPv6 does
not work. Issue reported by brad@@  OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.40 2006/12/30 22:43:01 claudio Exp $  */
d3062 1
a3062 1
		    sc->sc_dev);
d3070 1
a3070 1
		    sc->sc_dev);
d3078 1
a3078 1
		    sc->sc_dev);
d3087 1
a3087 1
		    sc->sc_dev);
d3100 1
a3100 1
		    sc->sc_dev);
d3108 1
a3108 1
		    sc->sc_dev);
d3116 1
a3116 1
		    sc->sc_dev);
d3125 1
a3125 1
		    sc->sc_dev);
d3158 1
a3158 1
		printf("%s: error in DMA allocation\n", sc->sc_dev);
@


1.40
log
@Don't use M_DUP_PKTHDR() on static mbufs. M_DUP_PKTHDR() copies the mtag
chain and so a later MFREE() is needed to free the chain again.
Just initialize a minimal mbuf header for bpf_mtap().
See earlier rum(4) commit for the full story.
OK mglocker@@ Sounds good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.39 2006/12/07 23:50:10 mglocker Exp $  */
d2372 2
a2373 1
	case SIOCSIFADDR: ifa = (struct ifaddr *)req;
d2392 9
@


1.39
log
@Fix some channel tweaks;  e.g. solves a bug which sets the channel to 40
when switching into hostap mode.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.38 2006/11/25 19:42:41 damien Exp $  */
a1024 1
				M_DUP_PKTHDR(&mb, m);
d1028 3
a1030 2
				mb.m_pkthdr.len += mb.m_len;

a2233 1
					M_DUP_PKTHDR(&mb, m);
d2237 3
a2239 1
					mb.m_pkthdr.len += mb.m_len;
@


1.38
log
@remove a comment that only applies to freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.37 2006/10/13 22:35:49 mglocker Exp $  */
d2528 1
a2528 1
	struct ieee80211com *ic;
d2530 2
a2531 1
	ic = &sc->sc_ic;
d2701 1
a2701 2
			channel = htole32(ieee80211_chan2ieee(ic,
			    ic->ic_bss->ni_chan));
d2703 1
a2703 1
			channel = 0;
d2705 1
a2705 1
		channel = htole32(ieee80211_chan2ieee(ic, ic->ic_des_chan));
d2733 1
a2733 1
		if (channel != 0)
@


1.37
log
@Fix kernel page fault when the device gets detached after the firmware
failed to load.

Spotted by bernd@@, aaron@@

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.36 2006/10/11 19:42:28 damien Exp $  */
a2952 3
/*
 * Synchronization here is due to the softc lock being held when called.
 */
@


1.36
log
@more ether_sprintf()'s

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.35 2006/10/11 19:20:46 damien Exp $  */
d628 4
a635 4
	/* disable card if possible */
	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);

d646 5
@


1.35
log
@fix a potential null deref and a memleak (both in error path).

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.34 2006/10/11 10:20:31 claudio Exp $  */
d968 1
a968 3
			DPRINTF(("%s: rx ether: "
			    "%02x:%02x:%02x:%02x:%02x:%02x < "
			    "%02x:%02x:%02x:%02x:%02x:%02x 0x%04x\n",
d970 2
a971 6
			    pra->pra_ether_dhost[0], pra->pra_ether_dhost[1],
			    pra->pra_ether_dhost[2], pra->pra_ether_dhost[3],
			    pra->pra_ether_dhost[4], pra->pra_ether_dhost[5],
			    pra->pra_ether_shost[0], pra->pra_ether_shost[1],
			    pra->pra_ether_shost[2], pra->pra_ether_shost[3],
			    pra->pra_ether_shost[4], pra->pra_ether_shost[5],
d2890 1
a2890 2
				    "%02x:%02x:%02x:%02x:%02x:%02x "
				    "id 0x%02x state 0x%02x code 0x%02x\n",
d2892 1
a2892 3
				    mlme->pom_address[0], mlme->pom_address[1],
				    mlme->pom_address[2], mlme->pom_address[3],
				    mlme->pom_address[4], mlme->pom_address[5],
@


1.34
log
@Use correct arguments in printfs. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.33 2006/10/09 21:09:40 mglocker Exp $  */
d1817 2
a1818 2
	bzero(pin, sizeof *pin);
	if (pin != NULL)
d1820 1
a1820 1

d3204 1
@


1.33
log
@Kill unused debug flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.32 2006/10/09 21:01:55 mglocker Exp $  */
d3203 1
a3203 1
			    sc->sc_dev);
d3211 1
a3211 1
			    sc->sc_dev, i, pq, error);
d3220 1
a3220 1
			    sc->sc_dev, i, pq);
d3230 1
a3230 1
				    sc->sc_dev, i, pq);
@


1.32
log
@Change historical leftovers (tsleep "pftres" to "pgtres").
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.31 2006/10/09 20:45:27 mglocker Exp $  */
a573 1
	//ieee80211_debug = 1;
@


1.31
log
@Add powerhooks.  Tested with a Netgear WG511v1 on my X40.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.30 2006/10/06 21:55:33 mglocker Exp $  */
d536 1
a536 1
			tsleep(&sc->sc_flags, 0, "pftres", hz);
d605 1
a605 1
	tsleep(&sc->sc_flags, 0, "pftres", hz);
@


1.30
log
@Fix cardbus support for pgt(4).  Tested with a Netgear WG511.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.29 2006/10/05 14:22:54 mglocker Exp $  */
d136 2
a137 1
void	 pgt_disable(struct pgt_softc *, unsigned int);
d195 2
d476 1
a476 1
pgt_disable(struct pgt_softc *sc, unsigned int flag)
d630 1
a630 1
	pgt_disable(sc, SC_DYING);
d637 8
d1150 1
a1150 1
			pgt_disable(sc, SC_NEEDS_RESET);
d2026 12
d2388 1
a2388 1
				pgt_disable(sc, SC_NEEDS_RESET);
d3296 48
@


1.29
log
@Zap more dead dot1x code.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.28 2006/10/05 12:15:43 mglocker Exp $  */
d584 4
d629 4
@


1.28
log
@Zap dead dot1x routine pgt_update_hw_from_nodes().  There is some more
dot1x stuff spreaded around which needs to be removed.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.27 2006/10/05 11:08:30 mglocker Exp $  */
d2956 1
a2956 11
		if (sc->sc_flags & SC_NOFREE_ALLNODES) {
#if 0
			struct ieee80211_node *ni;
			struct pgt_ieee80211_node *pin;

			/* Locked already by pff mutex. */
			TAILQ_FOREACH(ni, &ic->ic_node, ni_list) {
				pin = (struct pgt_ieee80211_node *)ni;
				pin->pin_dot1x_auth = PIN_DOT1X_UNAUTHORIZED;
			}
#endif
d2958 1
a2958 1
		} else
@


1.27
log
@Remove obsolete ioctl command.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.26 2006/10/05 08:56:51 mglocker Exp $  */
a183 1
void	 pgt_update_hw_from_nodes(struct pgt_softc *);
a2787 65
/*
 * After doing a soft-reinitialization, we will restore settings from
 * our pgt_ieee80211_nodes.  As we also lock the node list with our
 * softc mutex, unless we were to drop that the node list will remain
 * valid (see pgt_watchdog()).
 */
void
pgt_update_hw_from_nodes(struct pgt_softc *sc)
{
	struct pgt_ieee80211_node *pin;
#if 0
	struct ieee80211_node *ni;
#endif
	struct pgt_ieee80211_node **addresses;
	size_t i, n;
	int s;

	n = 0;
#if 0
	TAILQ_FOREACH(ni, &sc->sc_ic.ic_node, ni_list) {
		pin = (struct pgt_ieee80211_node *)ni;
		if (pin->pin_dot1x_auth != pin->pin_dot1x_auth_desired)
			n++;
	}
#endif
	if (n == 0)
		return;
	addresses = malloc(sizeof(*addresses) * n, M_DEVBUF, M_NOWAIT);
	if (addresses == NULL)
		return;
	n = 0;
#if 0
	TAILQ_FOREACH(ni, &sc->sc_ic.ic_node, ni_list) {
		pin = (struct pgt_ieee80211_node *)ni;
		if (pin->pin_dot1x_auth != pin->pin_dot1x_auth_desired) {
			addresses[n++] = pin;
			ieee80211_ref_node(&pin->pin_node);
		}
	}
#endif
	s = splnet();
	for (i = 0; i < n; i++) {
		pin = addresses[i];
		if (pgt_oid_set(sc,
		    pin->pin_dot1x_auth_desired == PIN_DOT1X_AUTHORIZED ?
		    PGT_OID_EAPAUTHSTA : PGT_OID_EAPUNAUTHSTA,
		    pin->pin_node.ni_macaddr, sizeof(pin->pin_node.ni_macaddr))
		    == 0) {
			pin->pin_dot1x_auth = pin->pin_dot1x_auth_desired;
			DPRINTF(("%s: %02x:%02x:%02x:%02x:%02x:%02x "
			    "reauthorized to %d\n", __func__,
			    pin->pin_node.ni_macaddr[0],
			    pin->pin_node.ni_macaddr[1],
			    pin->pin_node.ni_macaddr[2],
			    pin->pin_node.ni_macaddr[3],
			    pin->pin_node.ni_macaddr[4],
			    pin->pin_node.ni_macaddr[5],
			    pin->pin_dot1x_auth));
		}
		ieee80211_release_node(&sc->sc_ic, &pin->pin_node);
	}
	splx(s);
	free(addresses, M_DEVBUF);
}

a2976 1
		pgt_update_hw_from_nodes(sc);
@


1.26
log
@Zap dead routine pgt_80211_set().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.25 2006/10/04 18:13:37 mglocker Exp $  */
a2225 4
#if 0
	struct ifprismoidreq *preq;
	struct ieee80211req *ireq;
#endif
a2242 19
#if 0
	case SIOCGPRISMOID:
	case SIOCSPRISMOID:
		error = suser(curthread);
		if (error)
			return (error);
		preq = (struct ifprismoidreq *)req;
		if (preq->ifr_oidlen > sizeof(preq->ifr_oiddata))
			return (ENOMEM);
		pgt_enter_critical(sc);
		if (cmd == SIOCGPRISMOID)
			error = pgt_oid_retrieve(sc, preq->ifr_oid,
			    preq->ifr_oiddata, preq->ifr_oidlen);
		else
			error = pgt_oid_set(sc, preq->ifr_oid,
			    preq->ifr_oiddata, preq->ifr_oidlen);
		pgt_exit_critical(sc);
		break;
#endif
@


1.25
log
@Merge pgt_start_body() into pgt_start().

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.24 2006/10/04 14:23:12 mglocker Exp $  */
a178 3
#if 0
int	 pgt_80211_set(struct pgt_softc *, struct ieee80211req *);
#endif
a592 1

a2435 110

#if 0
int
pgt_80211_set(struct pgt_softc *sc, struct ieee80211req *ireq)
{
	struct ieee80211req_mlme mlme;
	struct ieee80211com *ic;
	int error;

	ic = &sc->sc_ic;
	switch (ireq->i_type) {
	/*
	 * These are 802.11 requests we want to let fall through to
	 * net80211 but do not need a reset afterward.
	 */
	case IEEE80211_POWERSAVE_OFF:
	case IEEE80211_POWERSAVE_ON:
		error = ieee80211_ioctl(&ic->ic_if, SIOCS80211,
		    (caddr_t)ireq);
		if (error == ENETRESET)
			error = 0;
		break;
	/*
	 * These are 802.11 requests we want to let fall through to
	 * net80211 but then use their results without doing a full
	 * reset afterward.
	 */
	case IEEE80211_IOC_WEPKEY:
	case IEEE80211_IOC_WEPTXKEY:
		error = ieee80211_ioctl(&ic->ic_if, SIOCS80211, (caddr_t)ireq);
		if (error == ENETRESET) {
			pgt_update_hw_from_sw(sc,
			    ic->ic_state != IEEE80211_S_INIT,
			    ic->ic_opmode != IEEE80211_M_MONITOR);
			error = 0;
		}
		break;
	case IEEE80211_IOC_WEP:
		switch (ireq->i_val) {
		case IEEE80211_WEP_OFF:
		case IEEE80211_WEP_ON:
		case IEEE80211_WEP_MIXED:
			error = 0;
			break;
		default:
			error = EINVAL;
		}
		if (error)
			break;
		if (sc->sc_80211_ioc_wep != ireq->i_val) {
			sc->sc_80211_ioc_wep = ireq->i_val;
			pgt_update_hw_from_sw(sc, 0,
			    ic->ic_opmode != IEEE80211_M_MONITOR);
			error = 0;
		} else
			error = 0;
		break;
	case IEEE80211_IOC_AUTHMODE:
		switch (ireq->i_val) {
		case IEEE80211_AUTH_NONE:
		case IEEE80211_AUTH_OPEN:
		case IEEE80211_AUTH_SHARED:
			error = 0;
			break;
		default:
			error = EINVAL;
		}
		if (error)
			break;
		if (sc->sc_80211_ioc_auth != ireq->i_val) {
			sc->sc_80211_ioc_auth = ireq->i_val;
			pgt_update_hw_from_sw(sc, 0, 0);
			error = 0;
		} else
			error = 0;
		break;
	case IEEE80211_IOC_MLME:
		if (ireq->i_len != sizeof(mlme)) {
			error = EINVAL;
			break;
		}
		error = copyin(ireq->i_data, &mlme, sizeof(mlme));
		if (error)
			break;
		pgt_enter_critical(sc);
		switch (ic->ic_opmode) {
		case IEEE80211_M_STA:
			error = pgt_do_mlme_sta(sc, &mlme);
			break;
		case IEEE80211_M_HOSTAP:
			error = pgt_do_mlme_hostap(sc, &mlme);
			break;
		case IEEE80211_M_IBSS:
			error = pgt_do_mlme_adhoc(sc, &mlme);
			break;
		default:
			error = EINVAL;
			break;
		}
		pgt_exit_critical(sc);
		if (error == 0)
			error = copyout(&mlme, ireq->i_data, sizeof(mlme));
		break;
	default:
		error = EOPNOTSUPP;
		break;
	}
	return (error);
}
#endif
@


1.24
log
@Mini cleanup.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.23 2006/10/03 17:26:14 claudio Exp $  */
a175 2
void	 pgt_start_body(struct pgt_softc *, struct ieee80211com *,
	     struct ifnet *);
d2090 5
d2100 3
a2111 15

	pgt_start_body(sc, ic, ifp);
}

/*
 * Start data frames.  Critical sections surround the boundary of
 * management frame transmission / transmission acknowledgement / response
 * and data frame transmission / transmission acknowledgement.
 */
void
pgt_start_body(struct pgt_softc *sc, struct ieee80211com *ic, struct ifnet *ifp)
{
	struct pgt_desc *pd;
	struct mbuf *m;
	int error;
@


1.23
log
@Do not use IF_PREPEND. Instead use IFQ_POLL and IFQ_DEQUEUE. This should
"fix" altq. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.22 2006/10/02 21:46:43 mglocker Exp $  */
d733 1
a733 1
			while (qfree-- > npend) {
a734 1
			}
d920 3
a922 2
						printf("%s: m_pullup failure\n",
						    sc->sc_dev.dv_xname);
d936 2
a937 2
					printf("%s: m_pullup failure\n",
					    sc->sc_dev.dv_xname);
d1063 2
a1064 2
		printf("%s: wakeup interrupt (update = %d)\n",
		    sc->sc_dev.dv_xname, shouldupdate);
d1093 2
a1094 2
		printf("%s: sleep interrupt (allowed = %d)\n",
		    sc->sc_dev.dv_xname, allowed);
a1149 2
			//DPRINTF(("%s: [thread] update_sw_from_hw\n",
			//    sc->sc_dev.dv_xname));
d1221 1
a1221 2
		pgt_write_4_flush(sc, PGT_REG_DEV_INT,
		    PGT_DEV_INT_UPDATE);
d1235 1
a1235 1
		printf("%s: unknown interrupt bits %#x (stat %#x)\n",
d1238 1
a1238 1
		    pgt_read_4(sc, PGT_REG_CTRL_STAT));
d1400 2
a1401 2
		DPRINTF(("%s: mgmt trap received "
		    "(op %u, oid %#x, len %u)\n", sc->sc_dev.dv_xname,
d1685 2
a1686 2
		DPRINTF(("%s: queue: mgmt %p -> (op %u, "
		    "oid %#x, len %u)\n", sc->sc_dev.dv_xname,
a2405 4
		/*
		 * XXX net80211 does not prevent modification of the
		 * ieee80211com while it fondles it.
		 */
d2603 1
a2603 2
				DPRINTF(("%s: timed out %d data "
				    "transmissions\n",
@


1.22
log
@Zap unused MLME routines.  Probably they were just used in WPA mode.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.21 2006/10/02 18:06:55 mglocker Exp $  */
d1888 1
a1888 1
	IFQ_SET_MAXLEN(&ifp->if_snd, PGT_QUEUE_FULL_THRESHOLD);
d2133 1
a2133 1
		IFQ_DEQUEUE(&ifp->if_snd, m);
d2139 1
a2139 2
			if (error) {
				IF_PREPEND(&ifp->if_snd, m);
d2141 1
a2141 1
			}
d2155 1
a2155 2
			    PGT_QUEUE_FULL_THRESHOLD) {
				IF_PREPEND(&ifp->if_snd, m);
a2156 1
			}
d2170 1
a2170 2
			if (error) {
				IF_PREPEND(&ifp->if_snd, m);
d2172 1
a2172 1
			}
d2181 1
@


1.21
log
@Simplify device attachment.  From brad@@ with a tiny correction.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.20 2006/10/01 22:03:25 claudio Exp $  */
a181 6
int	 pgt_node_set_authorization(struct pgt_softc *,
	     struct pgt_ieee80211_node *,
	     enum pin_dot1x_authorization);
int	 pgt_do_mlme_sta(struct pgt_softc *, struct ieee80211req_mlme *);
int	 pgt_do_mlme_hostap(struct pgt_softc *, struct ieee80211req_mlme *);
int	 pgt_do_mlme_adhoc(struct pgt_softc *, struct ieee80211req_mlme *);
a2458 141

#if 0
int
pgt_node_set_authorization(struct pgt_softc *sc,
    struct pgt_ieee80211_node *pin, enum pin_dot1x_authorization newstate)
{
	int error;

	if (pin->pin_dot1x_auth == newstate)
		return (0);

	DPRINTF(("%s: %02x:%02x:%02x:%02x:%02x:%02x "
	    "changing authorization to %d\n", __func__,
	    pin->pin_node.ni_macaddr[0], pin->pin_node.ni_macaddr[1],
	    pin->pin_node.ni_macaddr[2], pin->pin_node.ni_macaddr[3],
	    pin->pin_node.ni_macaddr[4], pin->pin_node.ni_macaddr[5],
	    newstate));

	error = pgt_oid_set(sc,
	    newstate == PIN_DOT1X_AUTHORIZED ?
	    PGT_OID_EAPAUTHSTA : PGT_OID_EAPUNAUTHSTA,
	    pin->pin_node.ni_macaddr, sizeof(pin->pin_node.ni_macaddr));
	if (error == 0)
		pin->pin_dot1x_auth = pin->pin_dot1x_auth_desired = newstate;

	return (error);
}
#endif

#if 0
int
pgt_do_mlme_sta(struct pgt_softc *sc, struct ieee80211req_mlme *imlme)
{
	struct pgt_obj_mlme pffmlme;
	struct ieee80211com *ic;
	int error = 0;

	ic = &sc->sc_ic;
	switch (imlme->im_op) {
	case IEEE80211_MLME_ASSOC:
		IEEE80211_ADDR_COPY(pffmlme.pom_address, imlme->im_macaddr);
		pffmlme.pom_id = htole16(0);
		pffmlme.pom_state = htole16(PGT_MLME_STATE_ASSOC);
		pffmlme.pom_code = htole16(imlme->im_reason);
		error = pgt_oid_set(sc, PGT_OID_ASSOCIATE,
		    &pffmlme, sizeof(pffmlme));
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}
#endif

#if 0
int
pgt_do_mlme_hostap(struct pgt_softc *sc, struct ieee80211req_mlme *imlme)
{
	struct pgt_ieee80211_node *pin;
	struct ieee80211com *ic;
	int error = 0;

	ic = &sc->sc_ic;
	switch (imlme->im_op) {
	/* Would IEEE80211_MLME_ASSOC/PGT_MLME_STATE_ASSOC be used for WDS? */
	case IEEE80211_MLME_AUTHORIZE:
		pin = (struct pgt_ieee80211_node *)ieee80211_find_node(ic,
		    imlme->im_macaddr);
		if (pin == NULL) {
			error = ENOENT;
			break;
		}
		error = pgt_node_set_authorization(sc, pin,
		    PIN_DOT1X_AUTHORIZED);
		ieee80211_release_node(ic, (struct ieee80211_node *)pin);
		break;
	case IEEE80211_MLME_UNAUTHORIZE:
		pin = (struct pgt_ieee80211_node *)ieee80211_find_node(ic,
		    imlme->im_macaddr);
		if (pin == NULL) {
			error = ENOENT;
			break;
		}
		error = pgt_node_set_authorization(sc, pin,
		    PIN_DOT1X_UNAUTHORIZED);
		ieee80211_release_node(ic, (struct ieee80211_node *)pin);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}
#endif

#if 0
int
pgt_do_mlme_adhoc(struct pgt_softc *sc, struct ieee80211req_mlme *imlme)
{
	struct pgt_ieee80211_node *pin;
	struct ieee80211com *ic;
	int error = 0;

	ic = &sc->sc_ic;
	switch (imlme->im_op) {
	case IEEE80211_MLME_AUTHORIZE:
		pin = (struct pgt_ieee80211_node *)ieee80211_find_txnode(ic,
		    imlme->im_macaddr);
		if (pin == NULL) {
			error = ENOMEM;
			break;
		} else if ((struct ieee80211_node *)pin == ic->ic_bss) {
			error = EINVAL;
			break;
		}
		error = pgt_node_set_authorization(sc, pin,
		    PIN_DOT1X_AUTHORIZED);
		ieee80211_release_node(ic, (struct ieee80211_node *)pin);
		break;
	case IEEE80211_MLME_UNAUTHORIZE:
		pin = (struct pgt_ieee80211_node *)ieee80211_find_txnode(ic,
		    imlme->im_macaddr);
		if (pin == NULL) {
			error = ENOMEM;
			break;
		} else if ((struct ieee80211_node *)pin == ic->ic_bss) {
			error = EINVAL;
			break;
		}
		error = pgt_node_set_authorization(sc, pin,
		    PIN_DOT1X_UNAUTHORIZED);
		ieee80211_release_node(ic, (struct ieee80211_node *)pin);
		break;
	default:
		error = EINVAL;
		break;
	}
	return (error);
}
#endif
@


1.20
log
@Make monitor mode work by prepending the right kind headers and fixing the
channel selection code. Joint work with mglocker@@, OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.19 2006/10/01 21:49:08 claudio Exp $  */
a207 8
pgt_attachhook(void *xsc)
{
	struct pgt_softc *sc = xsc;

	pgt_attach(sc);
}

void
d576 2
a577 2
int
pgt_attach(struct pgt_softc *sc)
d579 1
d598 1
a598 1
		return (error);
d609 1
a609 1
		return (error);
d614 1
a614 1
		error = ETIMEDOUT;
a619 2
	if (error)
		goto failed;
d623 1
a623 1
		goto failed;
d627 1
a627 1
		goto failed;
a629 3

failed:
	return (error);
@


1.19
log
@Get rid of this strange pgt_data_frame which is unused. Nice side-effect is
an easier to read pgt_datarx_completion. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.18 2006/10/01 21:26:21 claudio Exp $  */
d836 6
d850 1
a850 2
		if (ic->ic_opmode == IEEE80211_M_STA ||
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
a907 3
		/*
		 * What format do monitor-mode's frames take?
		 */
d922 1
d934 16
d961 1
d963 1
a963 1
			DPRINTF(("%s: rx annex: ? %04x ? %04x "
d967 7
a973 8
			    letoh16(pdf.pdf_unknown),
			    letoh16(pra->pra_unknown0),
			    letoh16(pra->pra_length),
			    letoh32(pra->pra_clock), pra->pra_flags,
			    pra->pra_unknown1, pra->pra_rate,
			    pra->pra_unknown2, letoh32(pra->pra_frequency),
			    pra->pra_unknown3, pra->pra_rssi,
			    pra->pra_pad[0], pra->pra_pad[1], pra->pra_pad[2]));
d986 6
d995 1
a995 1
		if (pra->pra_flags & PRA_FLAG_BAD) {
d1000 1
a1000 3
		memcpy(eh.ether_dhost, pra->pra_ether_dhost, ETHER_ADDR_LEN);
		memcpy(eh.ether_shost, pra->pra_ether_shost, ETHER_ADDR_LEN);
		eh.ether_type = pra->pra_ether_type;
d1006 4
a1009 4
		rssi = pra->pra_rssi;
		rstamp = letoh32(pra->pra_clock);
		rate = pra->pra_rate;
		n = ieee80211_mhz2ieee(letoh32(pra->pra_frequency), 0);
d1015 5
a1019 1
		m_adj(m, sizeof(*pra));
d2993 1
a2993 1
		channel = htole32(ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan));
d3021 1
a3021 1
		if (channel != 0 && channel != htole32(IEEE80211_CHAN_ANY))
@


1.18
log
@Kill some #if 0 code. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.17 2006/10/01 21:13:45 claudio Exp $  */
a918 1
	struct pgt_data_frame pdf;
a922 2
	uint16_t dataoff;
	int encrypted;
a930 12
		dataoff = *mtod(m, uint16_t *);
		m_adj(m, 2);
		if (dataoff < sizeof(pdf)) {
			if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
				printf("%s: missing pgt_data_frame header\n",
				    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
			m_freem(m);
			continue;
		}
		bcopy(mtod(m, struct pgt_data_frame *), &pdf, sizeof(pdf));
		m_adj(m, dataoff);
a974 19
		/*
		 * The 16-bit word preceding the received frame contains
		 * values that seem to have a very non-random distribution
		 * and possibly follow a periodic distribution.  The only
		 * two values for it that seem to occur for WEP-decrypted
		 * packets (assuming it is indeed a 16-bit word and not
		 * something else) are 0x4008 and 0x4808.
		 *
		 * Those two values can be found in large runs in the
		 * histogram that get zero hits over the course of
		 * hundreds of thousands of samples from an 802.11b
		 * sender source (ping -f).  Further analysis shows
		 * that the 0x000c bits are always 0x0008 when WEP
		 * has been used, and never otherwise.  The bottom
		 * two bits seem to not be set in any known
		 * circumstances.
		 */
		encrypted = sc->sc_ic.ic_flags == IEEE80211_F_WEPON &&
		    (letoh16(pdf.pdf_unknown) & 0xc) == 0x8;
d1495 1
a1495 2
		if (m == NULL) {
			datalen += dataoff;
d1497 1
a1497 19
			if (m == NULL)
				goto fail;
			if (datalen + 2 >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					m_free(m);
					goto fail;
				}
			}
		
			/*
			 * Add a uint16_t at the beginning containing the
			 * actual data offset.
			 */
			*mtod(m, uint16_t *) = dataoff;
			bcopy(pd->pd_mem, mtod(m, char *) + 2, datalen);
			m->m_len = datalen + 2;
			tlen += datalen + 2;
		} else {
d1499 7
a1505 1
			if (m == NULL)
a1506 6
			if (datalen >= MINCLSIZE) {
				MCLGET(m, M_DONTWAIT);
				if (!(m->m_flags & M_EXT)) {
					m_free(m);
					goto fail;
				}
a1507 3
			bcopy(pd->pd_mem + dataoff, mtod(m, char *), datalen);
			m->m_len = datalen;
			tlen += datalen;
d1509 3
a1511 1

@


1.17
log
@Set ic_max_rssi to 255 the rssi value returned by the card is a u_int8_t
and mglocker@@ and I both have seen values up to 240. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.16 2006/09/27 19:35:17 brad Exp $  */
a1030 17
#if 0
				struct pgt_ieee80211_radiotap pir;

				bzero(&pir, sizeof(pir));
				pir.pir_header.it_len = htole16(sizeof(pir));
				pir.pir_header.it_present =
				    htole32(PGT_IEEE80211_RADIOTAP_PRESENT);
				if (encrypted)
					pir.pir_flags |=
					    IEEE80211_RADIOTAP_F_WEP;
				pir.pir_rate = rate;
				pir.pir_channel = htole16(chan->ic_freq);
				pir.pir_channel_flags = htole16(chan->ic_flags);
				pir.pir_db_antsignal = rssi;
				pir.pir_db_antnoise = sc->sc_noise;
				bpf_mtap2(sc->sc_drvbpf, &pir, sizeof(pir), m);
#endif
a2251 30
#if 0
				struct pgt_ieee80211_radiotap pir;
				struct ether_header eh;

				/*
				 * Fill out what we can when faking
				 * up a radiotapified outgoing frame.
				 */
				bzero(&pir, sizeof(pir));
				pir.pir_header.it_len = htole16(sizeof(pir));
				pir.pir_header.it_present =
				    htole32(PGT_IEEE80211_RADIOTAP_PRESENT);
				if (sc->sc_80211_ioc_wep != IEEE80211_WEP_OFF)
					pir.pir_flags |=
					    IEEE80211_RADIOTAP_F_WEP;
				pir.pir_channel =
				    htole16(ic->ic_bss->ni_chan->ic_freq);
				pir.pir_channel_flags =
				    htole16(ic->ic_bss->ni_chan->ic_flags);
				pir.pir_db_antnoise = sc->sc_noise;
				memcpy(mtod(m, struct ether_header *), &eh,
				    sizeof(eh));
				m_adj(m, sizeof(eh));
				m = pgt_ieee80211_encap(sc, &eh, m, NULL);
				if (m != NULL) {
					bpf_mtap2(sc->sc_drvbpf, &pir,
					    sizeof(pir), m);
					m_freem(m);
				}
#endif
@


1.16
log
@- do not bother printing the attach error message from the attach hook
if pgt_attach() fails.
- remove pgt_disable/pgt_reboot from the pgt_attach error path, just
return for now.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.15 2006/09/26 21:32:49 mglocker Exp $  */
d1055 1
a1055 1
				//tap->wr_max_rssi = ic->ic_max_rssi;
d2061 1
@


1.15
log
@Start to get HostAP mode working for pgt(4).  Works at the first try,
but surely needs more testing and some more modifications.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.14 2006/09/23 13:44:42 mglocker Exp $  */
a210 1
	int error;
d212 1
a212 5
	error = pgt_attach(sc);
	if (error) {
		printf("%s: attach error\n", sc->sc_dev.dv_xname);
		return;
	}
a640 5
	if (error) {
		pgt_disable(sc, SC_DYING);
		pgt_reboot(sc);
	}

@


1.14
log
@In pgt_media_status() also DPRINTF if the rate == 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.13 2006/09/23 13:29:58 mglocker Exp $  */
a3300 3
#if 0
		struct pgt_obj_mlmeex *mlmeex;
#endif
a3411 3
#if 0
		IF_DRAIN(&ic->ic_mgtq);
#endif
a3416 1
		ic->ic_state = nstate;
a3418 1
#if 0
d3422 1
d3431 1
d3433 1
a3433 1
		} else {
d3435 1
a3435 2
		}
		ic->ic_state = nstate;
a3438 1
#endif
@


1.13
log
@Update media state correctly.

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.12 2006/09/19 17:38:39 brad Exp $  */
a1922 1

a2128 2
		if (rate == 0)
			return;
d2133 2
@


1.12
log
@add missing sys/device.h.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pgt.c,v 1.11 2006/09/16 12:20:10 mglocker Exp $  */
a113 10
/*
 * hack to get it compiled (from FreeBSD)
 */
#define IEEE80211_IOC_MLME		21
#define IEEE80211_IOC_AUTHMODE		7
#define IEEE80211_POWERSAVE_ON		1
#define IEEE80211_POWERSAVE_OFF		0
#define IEEE80211_MLME_UNAUTHORIZE	5
#define IEEE80211_MLME_AUTHORIZE	4

d120 1
d1964 6
d1977 2
a1978 6
	/*
	 * Prism hardware likes to report supported frequencies that are
	 * not actually available for the country of origin.
	 */
	j = letoh16(freqs->pof_count);
	for (i = 0; i < j; i++) {
d1981 1
d1988 1
d2005 1
d2008 1
d2011 4
d2021 4
d2064 1
a2064 1
	/* Set up post-attach/pre-lateattach vector functions */
d2074 1
a2074 1
	ieee80211_media_init(ifp, pgt_media_change, ieee80211_media_status);
d2108 60
d3001 1
d3006 1
d3011 1
d3016 1
d3025 1
d3079 2
a3080 1
	for (i = 0; i < ic->ic_sup_rates[ic->ic_curmode].rs_nrates; i++)
d3082 3
d3086 1
d3319 2
a3320 2
				DPRINTF(("%s: link: %u\n",
				    sc->sc_dev.dv_xname, ls));
@


1.11
log
@Don't panic if firmware files are not in place.  Ja ja ja ja claudio@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d62 1
@


1.10
log
@Bring pgt(4) in a working state.  Much work also done by claudio@@.

ok deraadt@@
@
text
@d629 1
a629 1
		goto failed;
@


1.9
log
@Start to get interface attach working.

ok deraadt@@
@
text
@d1 20
a20 1
/*-
a95 2
#define PGT_DEBUG

d102 5
d114 1
a114 1
 * hack to get it compiled
a115 11
/* got from if_wi */
#define WI_PRISM2_RES_SIZE	62
#define WI_RID_SCAN_REQ		0xFCE1
#define WI_RID_SCAN_APS		0x0600
#define WI_RID_CHANNEL_LIST	0xFD10
#define WI_RID_SCAN_RES		0xFD88
#define WI_RID_COMMS_QUALITY	0xFD43 
/* got from FreeBSD */
#define IEEE80211_WEP_OFF		0
#define IEEE80211_WEP_ON		1
#define IEEE80211_WEP_MIXED		2
a117 3
#define IEEE80211_IOC_WEP		3
#define IEEE80211_IOC_WEPTXKEY		6
#define IEEE80211_IOC_WEPKEY		4
d123 2
d129 1
a139 6
void	 pgt_enter_critical(struct pgt_softc *);
int	 pgt_try_enter_data_critical(struct pgt_softc *);
void	 pgt_exit_critical(struct pgt_softc *);
#if 0
void	 pgt_try_exit_data_critical(struct pgt_softc *);
#endif
d146 1
a146 1
void	 pgt_update_intr(struct pgt_softc *, struct mbuf ***, int);
a154 2
struct mbuf
	*pgt_alloc_async(size_t);
a155 1
void	 pgt_async_trap(struct pgt_softc *, uint32_t, void *, size_t);
a156 2
//void	 pgt_poll(struct ifnet *, enum poll_cmd, int);
void	 pgt_intr_body(struct pgt_softc *, struct mbuf **, int);
d161 2
a162 2
int	 pgt_datarx_completion(struct pgt_softc *, enum pgt_queue,
	     struct mbuf ***, int);
a182 1
void	 pgt_net_detach(struct pgt_softc *);
d189 1
a192 1
#if 0
a197 2
int	 pgt_wavelan_get(struct pgt_softc *, struct wi_req *);
int	 pgt_wavelan_set(struct pgt_softc *, struct wi_req *);
d200 1
a200 1
void	 pgt_periodic(struct ifnet *);
d208 1
a208 3
int	 pgt_media_change(struct ifnet *);
void	 pgt_media_status(struct ifnet *, struct ifmediareq *);
int	 pgt_new_state(struct ieee80211com *, enum ieee80211_state, int);
d268 3
a270 3
		printf("%s: ev%s: %u %u %u %u %u %u\n",
		    sc->sc_dev.dv_xname, when,
		    COUNT(0), COUNT(1), COUNT(2), COUNT(3), COUNT(4), COUNT(5));
d286 1
a286 1
	pd->pd_fragp->pf_flags = htole16(0);
d301 1
a301 1
		printf("%s: unable to load %s tx DMA: %d\n",
d303 1
a303 1
		    pgt_queue_is_data(pq) ? "data" : "mgmt", error);
d306 1
a323 68
/*
 * The critical lock uses int sc_critical to signify whether there are
 * currently transmissions in flight (> 0), is a management in progress
 * (<= -1), or the device is not critical (== 0).  Management waiters
 * prevent further transmissions from contributing to sc_critical --
 * that is, make it monotonically decrease again back to 0 as
 * transmissions complete or time out.
 */
void
pgt_enter_critical(struct pgt_softc *sc)
{
	//if (sc->sc_critical < 0 && sc->sc_critical_thread == curthread) {
	if (sc->sc_critical < 0) {
		sc->sc_critical--;
	} else {
		while (sc->sc_critical != 0) {
			sc->sc_refcnt++;
			//cv_wait(&sc->sc_critical_cv, &sc->sc_lock);
			sc->sc_refcnt--;
		}
		sc->sc_critical = -1;
		//sc->sc_critical_thread = curthread;
	}
}

void
pgt_exit_critical(struct pgt_softc *sc)
{
	if (++sc->sc_critical == 0) {
		sc->sc_critical_thread = NULL;
		//if (sc->sc_critical_cv.cv_waiters == 0 &&
		    if (sc->sc_flags & SC_START_DESIRED) {
			sc->sc_flags &= ~SC_START_DESIRED;
			if (sc->sc_ic.ic_if.if_flags & IFF_RUNNING)
				pgt_start_body(sc, &sc->sc_ic,
				    &sc->sc_ic.ic_if);
		} else {
			//cv_signal(&sc->sc_critical_cv);
		}
	}
}

int
pgt_try_enter_data_critical(struct pgt_softc *sc)
{
	if (sc->sc_critical <= -1) {
	    // || sc->sc_critical_cv.cv_waiters > 0) {
		/*
		 * Don't start new data packets if management
		 * wants a chance.
		 */
		sc->sc_flags |= SC_START_DESIRED;
		return (0);
	} else  {
		sc->sc_critical++;
		return (1);
	}
}

#if 0
void
pgt_try_exit_data_critical(struct pgt_softc *sc)
{
	if (--sc->sc_critical == 0)
		cv_signal(&sc->sc_critical_cv);
}
#endif

d329 1
a329 1
	const uint32_t *uc;
d341 2
a342 2
		printf("%s: error %d, could not read microcode %s!\n",
		    sc->sc_dev.dv_xname, error, name);
d347 2
a348 2
		printf("%s: bad firmware size %u\n",
		    sc->sc_dev.dv_xname, size);
d357 1
a357 1
	uc = (const uint32_t *)ucode;
d415 1
a415 1
	sc->sc_cb->pcb_device_curfrag[pq] = htole32(0);
d417 1
d434 1
a434 1
		sc->sc_cb->pcb_driver_curfrag[pq] = htole32(0);
d447 1
a447 1
	pgt_write_4_flush(sc, PGT_REG_INT_EN, 0x00000000);
d486 3
a488 3
	//pgt_write_4_flush(sc, PGT_REG_CTRL_BLK_BASE,
	//    htole32((uint32_t)sc->sc_cbdmabusaddr));
	//DELAY(PGT_WRITEIO_DELAY);
a508 1
	uint32_t reg;
d510 1
a510 1
	int tries = 6, tryagain;
a513 19
	if (flag == SC_DYING && sc->sc_flags & SC_DYING) {
		while (sc->sc_drainer != NULL);
			//(void)msleep(&sc->sc_drainer, &sc->sc_lock,
			//    PZERO, "pffol1", hz / 10);
		//goto out2;
		return;
	}
	if (flag == SC_NEEDS_RESET) {
		if (sc->sc_drainer != NULL || sc->sc_flags & SC_GONE)
			/*
			 * Multiple pending resets are not useful.
			 */
			//goto out2;
			return;
	} else {
		while (sc->sc_drainer != NULL);
			//(void)msleep(&sc->sc_drainer, &sc->sc_lock,
			//    PZERO, "pffol1", hz / 10);
	}
a515 7
#ifdef DEVICE_POLLING
	ether_poll_deregister(&ic->ic_if);
	/* Turn back on interrupts. */
	pgt_write_4_flush(sc, PGT_REG_INT_EN, PGT_INT_STAT_SOURCES);	
	DELAY(PGT_WRITEIO_DELAY);
#endif
	//sc->sc_drainer = curthread;
d517 1
a517 6
	/*
	 * The detacher has to wait for all activity to cease (the refcount
	 * will reach 1 and sc_async_events will have been emptied).  If
	 * we were to drain while doing just a "reset" then this could
	 * deadlock.
	 */
d521 1
a521 5
	if (flag == SC_DYING) {
		while (sc->sc_refcnt > 1);
			//(void)msleep(&sc->sc_drainer, &sc->sc_lock,
			//    PZERO, "pffol2", hz / 10);
	}
a522 1
	tryagain = 0;
d524 1
a524 18
	pgt_write_4_flush(sc, PGT_REG_INT_EN, 0x00000000);
	DELAY(PGT_WRITEIO_DELAY);
	if (sc->sc_intcookie != NULL) {
		//bus_teardown_intr(sc->sc_dev, sc->sc_intres, sc->sc_intcookie);
		sc->sc_intcookie = NULL;
	}
	reg = pgt_read_4(sc, PGT_REG_CTRL_STAT);
	reg &= ~(PGT_CTRL_STAT_RESET | PGT_CTRL_STAT_RAMBOOT);
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);
	reg |= PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
	DELAY(PGT_WRITEIO_DELAY);
	reg &= ~PGT_CTRL_STAT_RESET;
	pgt_write_4(sc, PGT_REG_CTRL_STAT, reg);
	pgt_write_memory_barrier(sc);
d526 4
d545 3
a547 2
				printf("%s: queue: mgmt %p <- 0x%x (drained)\n",
				    sc->sc_dev.dv_xname, pmd, pmd->pmd_oid);
a550 2
			//(void)msleep(&sc->sc_drainer, &sc->sc_lock,
			//    PZERO, "pffol3", hz / 10);
d553 1
a553 1
				goto out;
d557 2
a558 1
	if (flag == SC_NEEDS_RESET && !(sc->sc_flags & SC_GONE)) {
d561 1
a561 2
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
		sc->sc_refcnt++;
a563 13
		//error = bus_setup_intr(sc->sc_dev, sc->sc_intres,
		//    INTR_TYPE_NET | INTR_MPSAFE, pgt_intr,
		//    &ic->ic_if, &sc->sc_intcookie);
		if (error != 0 || sc->sc_flags & SC_DYING) {
			if (error != 0) {
				printf("%s: failure establishing irq in "
				    "reset: %d\n",
				    sc->sc_dev.dv_xname, error);
				sc->sc_flags |= SC_DYING;
			}
			sc->sc_refcnt--;
			goto out;
		}
d566 1
a566 2
			//(void)msleep(&sc->sc_flags, &sc->sc_lock, PZERO,
			//    "pffres", hz * 10);
d571 3
a573 4
				if (--tries == 0)
					sc->sc_flags |= SC_GONE;
				else
					tryagain = 1;
d582 1
a582 1
		sc->sc_refcnt--;
d585 1
d592 3
a594 3
out:
	sc->sc_drainer = NULL;
	wakeup(&sc->sc_drainer);
d602 14
a620 1
	sc->sc_refcnt = 1;
d624 1
a624 10
	/*
	error = bus_setup_intr(dev, sc->sc_intres, INTR_TYPE_NET | INTR_MPSAFE,
	    pgt_intr, &sc->sc_ic.ic_if, &sc->sc_intcookie);
	if (error != 0) {
		printf("%s: failure establishing interrupt: %d\n",
		    sc->sc_dev.dv_xname, error);
		goto failed;
	}
	*/
	sc->sc_80211_ioc_wep = IEEE80211_WEP_OFF;
a630 1
	sc->sc_refcnt++;
a631 1
	sc->sc_refcnt--;
d647 4
d665 1
a665 2
	pgt_net_detach(sc);
	sc->sc_flags |= SC_GONE;
d669 5
d704 2
a705 2
			printf("%s: spurious initialization\n",
			    sc->sc_dev.dv_xname);
d717 1
a717 2
pgt_update_intr(struct pgt_softc *sc, struct mbuf ***last_nextpkt,
    int max_datarx_count)
d725 1
d728 1
a728 1
	int i, prevwasmf;
d752 1
a752 1
			if (last_nextpkt == NULL && data)
d761 5
a765 5
				if (sc->sc_flags & SC_DEBUG_UNEXPECTED)
					printf("%s: rx queue [%u] overflowed "
					    "by %u\n",
					    sc->sc_dev.dv_xname,
					    pqs[i], npend - qfree);
a769 6
#ifdef DEVICE_POLLING
				if (data && max_datarx_count != -1) {
					if (max_datarx_count-- == 0)
						break;
				}
#endif
d775 5
a779 5
				if (sc->sc_flags & SC_DEBUG_UNEXPECTED)
					printf("%s: tx queue [%u] underflowed "
					    "by %u\n",
					    sc->sc_dev.dv_xname,
					    pqs[i], npend - qdirty);
d788 5
a792 2
				if (TAILQ_EMPTY(&sc->sc_freeq[pqs[i]]))
					wakeup(&sc->sc_freeq[pqs[i]]);
d820 4
a823 4
	prevwasmf = 0;
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PGT_QUEUE_DATA_HIGH_RX]))
		prevwasmf = pgt_datarx_completion(sc, PGT_QUEUE_DATA_HIGH_RX,
		    last_nextpkt, prevwasmf);
d829 4
a832 4
	prevwasmf = 0;
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PGT_QUEUE_DATA_LOW_RX]))
		prevwasmf = pgt_datarx_completion(sc, PGT_QUEUE_DATA_LOW_RX,
		    last_nextpkt, prevwasmf);
d854 1
a854 1
	M_PREPEND(m, sizeof(frame) + sizeof(snap), M_DONTWAIT);
d856 1
a856 1
		m = m_pullup(m, sizeof(frame) + sizeof(snap));
d939 1
a939 1
	struct mbuf *next, *m2;
d951 1
a951 45
		//if (m->m_flags & M_PROTO2) {
		if (m->m_flags) {
			/*
			 * We either ended up losing the previous
			 * frag, or we're trying to receive more than
			 * two of them.
			 */
			ifp->if_ierrors++;
			m_freem(m);
			continue;
		}
		if (m->m_flags & M_PROTO1) {
			if (next == NULL) {
				if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
					printf("%s: more frags set, but not "
					    "found\n",
					    sc->sc_dev.dv_xname);
				ifp->if_ierrors++;
				m_freem(m);
				continue;
			} else {
				//if (!(next->m_flags & M_PROTO2)) {
				if (!(next->m_flags)) {
					if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
						printf("%s: more frags set, "
						   "but next is not one\n",
						    sc->sc_dev.dv_xname);
					ifp->if_ierrors++;
					m_freem(m);
					continue;
				}
				/*
				 * If there are yet more frags after the
				 * second, we're not touching them here.
				 */
				//next->m_flags &= ~(M_PROTO1 | M_PROTO2);
			}
			m->m_flags &= ~M_PROTO1;
			m2 = next;
			next = m2->m_nextpkt;
			m2->m_nextpkt = NULL;
			/* Remove any preceding junk from the latter frag. */
			m_adj(m2, *mtod(m2, uint16_t *));
			m_cat(m, m2);
		}
d964 9
a972 7
		m = m_pullup(m, sizeof(*pra));
		if (m == NULL) {
			if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
				printf("%s: m_pullup failure\n",
				    sc->sc_dev.dv_xname);
			ifp->if_ierrors++;
			continue;
d976 1
a976 1
			printf("%s: rx annex: ? %04x ? %04x "
d987 1
a987 1
			    pra->pra_pad[0], pra->pra_pad[1], pra->pra_pad[2]);
d989 1
a989 1
			printf("%s: rx ether: "
d999 1
a999 1
			    ntohs(pra->pra_ether_type));
d1025 1
a1025 1
		encrypted = sc->sc_80211_ioc_wep != IEEE80211_WEP_OFF &&
d1044 1
a1044 3
		m_adj(m, sizeof(*pra) - sizeof(eh));
		memcpy(mtod(m, struct ether_header *), &eh, sizeof(eh));
		m_adj(m, sizeof(eh));
d1047 1
d1049 1
d1064 18
a1081 1
				//bpf_mtap2(sc->sc_drvbpf, &pir, sizeof(pir), m);
d1083 1
d1183 1
d1189 2
a1190 3
		    TAILQ_EMPTY(&sck->sck_traps)) {
			//cv_wait(&sck->sck_needed, &sc->sc_lock);
		}
d1192 2
d1197 1
a1197 1
			pgt_enter_critical(sc);
d1199 1
a1199 1
			pgt_exit_critical(sc);
d1201 2
d1209 3
a1211 1
		} else {
a1219 16
struct mbuf *
pgt_alloc_async(size_t trapdata)
{
	struct mbuf *m;
	size_t total;

	total = trapdata + sizeof(struct pgt_async_trap);
	if (total >= MINCLSIZE)
		MGETHDR(m, MT_DATA, 0);
	else
		m = m_get(M_DONTWAIT, MT_DATA);
	if (m != NULL)
		m->m_len = total;
	return (m);
}

d1226 1
a1226 23
	//cv_signal(&sc->sc_kthread.sck_needed);
}

void
pgt_async_trap(struct pgt_softc *sc, uint32_t oid, void *data, size_t len)
{
	struct pgt_async_trap *pa;
	struct mbuf *m;
	char *p;

	if (sc->sc_flags & SC_DYING)
		return;
	m = pgt_alloc_async(sizeof(oid) + len);
	if (m == NULL)
		return;
	pa = mtod(m, struct pgt_async_trap *);
	p = mtod(m, char *) + sizeof(*pa);
	*(uint32_t *)p = oid;
	p += sizeof(uint32_t);
	memcpy(p, data, len);
	pa->pa_mbuf = m;
	TAILQ_INSERT_TAIL(&sc->sc_kthread.sck_traps, pa, pa_link);
	//cv_signal(&sc->sc_kthread.sck_needed);
d1235 1
a1235 33
	//cv_signal(&sc->sc_kthread.sck_needed);
}

#ifdef DEVICE_POLLING
void
pgt_poll(struct ifnet *ifp, enum poll_cmd cmd, int count)
{
	struct pgt_softc *sc;
	struct mbuf *datarx = NULL;

	sc = ifp->if_softc;
	if (!(ifp->if_capenable & IFCAP_POLLING)) {
		ether_poll_deregister(ifp);	/* already have Giant, no LOR */
		cmd = POLL_DEREGISTER;
	}
	if (cmd == POLL_DEREGISTER) {   /* final call, enable interrupts */
		pgt_write_4_flush(sc, PGT_REG_INT_EN, PGT_INT_STAT_SOURCES);	
		DELAY(PGT_WRITEIO_DELAY);
                return;
        }
	pgt_intr_body(sc, &datarx, count);
	if (cmd == POLL_AND_CHECK_STATUS) {
		/* Do more expensive periodic stuff. */
		pgt_async_update(sc);
	}
	/*
	 * Now that we have unlocked the softc, decode and enter the
	 * data frames we've received.
	 */
	if (datarx != NULL)
		pgt_input_frames(sc, datarx);
	//if (!IFQ_DRV_IS_EMPTY(&sc->sc_ic.ic_if.if_snd))
	//	pgt_start(&sc->sc_ic.ic_if);
a1236 1
#endif
d1243 1
a1243 1
	struct mbuf *datarx = NULL;
a1247 33
#ifdef DEVICE_POLLING
	if (ifp->if_flags & IFF_POLLING)
		return;
	if (ifp->if_capenable & IFCAP_POLLING &&
	    !(sc->sc_flags & SC_UNINITIALIZED) &&
	    ether_poll_register(pgt_poll, ifp)) {
		/* Turn off interrupts. */
		pgt_write_4_flush(sc, PGT_REG_INT_EN, 0);	
		DELAY(PGT_WRITEIO_DELAY);
		pgt_poll(ifp, POLL_ONLY, 1);
		return;
	}
#endif
	pgt_intr_body(sc, &datarx, -1);

	/*
	 * Now that we have unlocked the softc, decode and enter the
	 * data frames we've received.
	 */
	if (datarx != NULL)
		pgt_input_frames(sc, datarx);
	//if (!IFQ_DRV_IS_EMPTY(&ifp->if_snd))
	//	pgt_start(ifp);

	return (0);
}

void
pgt_intr_body(struct pgt_softc *sc, struct mbuf **datarx,
    int max_datarx_count)
{
	u_int32_t reg;

d1262 1
a1262 1
			return;
d1264 22
a1285 33
#ifdef DEVICE_POLLING
	if (sc->sc_ic.ic_if.if_flags & IFF_POLLING)
		reg = PGT_INT_STAT_UPDATE;
	else
#endif
		reg = pgt_read_4(sc, PGT_REG_INT_STAT);
	if (reg != 0) {
#ifdef DEVICE_POLLING
		if (!(sc->sc_ic.ic_if.if_flags & IFF_POLLING))
#endif
			pgt_write_4_flush(sc, PGT_REG_INT_ACK, reg);
		if (reg & PGT_INT_STAT_INIT)
			pgt_init_intr(sc);
		if (reg & PGT_INT_STAT_UPDATE) {
			pgt_update_intr(sc, &datarx, max_datarx_count);
			/*
			 * If we got an update, it's not really asleep.
			 */
			sc->sc_flags &= ~SC_POWERSAVE;
			/*
			 * Pretend I have any idea what the documentation
			 * would say, and just give it a shot sending an
			 * "update" after acknowledging the interrupt
			 * bits and writing out the new control block.
			 */
			pgt_write_4_flush(sc, PGT_REG_DEV_INT,
			    PGT_DEV_INT_UPDATE);
			DELAY(PGT_WRITEIO_DELAY);
		}
		if (reg & PGT_INT_STAT_SLEEP && !(reg & PGT_INT_STAT_WAKEUP))
			pgt_sleep_intr(sc);
		if (reg & PGT_INT_STAT_WAKEUP)
			pgt_wakeup_intr(sc);
d1287 5
d1296 1
d1303 5
d1325 2
a1326 2
		printf("%s: queue: tx %u <- [%u]\n",
		    sc->sc_dev.dv_xname, pd->pd_fragnum, pq);
d1331 2
a1332 2
			printf("%s: queue: txmgmt %p <- "
			    "(ver %u, op %u, flags 0x%x)\n",
d1335 1
a1335 1
			    pmf->pmf_flags);
a1338 4
	/*
	if (pgt_queue_is_data(pq))
		pgt_try_exit_data_critical(sc);
	*/
d1355 2
a1356 2
		printf("%s: queue: rx %u <- [%u]\n",
		    sc->sc_dev.dv_xname, pd->pd_fragnum, pq);
d1359 2
a1360 2
		printf("%s: unknown flags on rx [%u]: 0x%x\n",
		    sc->sc_dev.dv_xname, pq, letoh16(pd->pd_fragp->pf_flags));
d1373 4
a1376 2
	pgt_async_trap(sc, oid, trapdata, size);
}
d1378 42
a1419 10
/*
 * Process a completed management response (all requests should be
 * responded to, quickly) or an event (trap).
 */
void
pgt_mgmtrx_completion(struct pgt_softc *sc, struct pgt_mgmt_desc *pmd)
{
	struct pgt_desc *pd;
	struct pgt_mgmt_frame *pmf;
	uint32_t oid, size;
d1429 1
a1429 1
			printf("%s: mgmt desc too small: %u\n",
d1431 1
a1431 1
			    letoh16(pd->pd_fragp->pf_size));
d1437 2
a1438 2
			printf("%s: unknown mgmt version %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_version);
d1443 2
a1444 2
			printf("%s: unknown mgmt dev %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_device);
d1449 1
a1449 1
			printf("%s: unknown mgmt flags %u\n",
d1451 1
a1451 1
			    pmf->pmf_flags & ~PMF_FLAG_VALID);
d1463 3
d1472 3
a1474 3
			printf("%s: spurious mgmt received "
			    "(op %u, oid 0x%x, len %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_operation, oid, size);
d1486 2
a1487 2
			printf("%s: unknown mgmt op %u\n",
			    sc->sc_dev.dv_xname, pmf->pmf_operation);
d1493 2
a1494 3
			printf("%s: mgmt oid changed from 0x%x "
			    "-> 0x%x\n",
			    sc->sc_dev.dv_xname, pmd->pmd_oid, oid);
d1500 2
a1501 3
				printf("%s: mgmt oid 0x%x "
				    "has bad size %u\n",
				    sc->sc_dev.dv_xname, oid, size);
d1512 1
d1515 1
a1515 4
#ifdef DEVICE_POLLING
	if (!(sc->sc_ic.ic_if.if_flags & IFF_POLLING))
#endif
		wakeup_one(pmd);
d1517 1
a1517 2
		printf("%s: queue: mgmt %p <- (op %u, "
		    "oid 0x%x, len %u)\n",
d1519 1
a1519 1
		    pmd->pmd_oid, pmd->pmd_len);
d1529 2
a1530 3
int
pgt_datarx_completion(struct pgt_softc *sc, enum pgt_queue pq,
    struct mbuf ***last_nextpkt, int prevwasmf)
d1534 1
a1534 1
	struct mbuf *m;
d1536 2
a1537 2
	uint16_t dataoff;
	int morefrags;
d1540 22
a1561 27
	pd = TAILQ_FIRST(&sc->sc_dirtyq[pq]);
	TAILQ_REMOVE(&sc->sc_dirtyq[pq], pd, pd_link);
	sc->sc_dirtyq_count[pq]--;
	datalen = letoh16(pd->pd_fragp->pf_size);
	dataoff = letoh32(pd->pd_fragp->pf_addr) - pd->pd_dmaaddr;
	morefrags = pd->pd_fragp->pf_flags & htole16(PF_FLAG_MF);
	if (sc->sc_debug & SC_DEBUG_RXFRAG)
		printf("%s: rx frag: len %u memoff %u\n",
		    sc->sc_dev.dv_xname, datalen, dataoff);
	/* Add the (two+?) bytes for the header. */
	datalen += dataoff;
	if (datalen > PGT_FRAG_SIZE) {
		if (sc->sc_debug & SC_DEBUG_UNEXPECTED)
			printf("%s data rx too big: %u\n",
			    sc->sc_dev.dv_xname, datalen);
		ifp->if_ierrors++;
		goto out;
	}
	/* Add a uint16_t at the beginning containing the actual data offset. */
	if (prevwasmf) {
		if (datalen + 2 >= MINCLSIZE)
			MGETHDR(m, MT_DATA, 0);
		else
			m = m_get(M_DONTWAIT, MT_DATA);
		if (m == NULL) {
			ifp->if_ierrors++;
			goto out;
d1563 1
a1563 8
		//m->m_flags |= M_PROTO2;
		bcopy(pd->pd_mem, mtod(m, char *) + 2, datalen);
		m->m_len = datalen;
	} else {
		m = m_devget(pd->pd_mem, datalen,
		    sizeof(struct ieee80211_frame) + 2, ifp, NULL);
		if (m != NULL)
			M_PREPEND(m, 2, M_DONTWAIT);
d1565 34
a1598 2
			ifp->if_ierrors++;
			goto out;
d1600 11
d1612 2
a1613 8
	*mtod(m, uint16_t *) = dataoff;
	if (morefrags)
		m->m_flags |= M_PROTO1;
	else
		/*
		 * Count non-fragmented packets and the last fragment
		 * in fragmented packets.
		 */
d1615 6
a1620 3
	**last_nextpkt = m;
	*last_nextpkt = &m->m_nextpkt;
out:
d1624 5
a1628 1
	return (morefrags);
d1642 1
d1647 3
a1649 3
		printf("%s: failure getting oid 0x%x: %d\n",
		    sc->sc_dev.dv_xname,
		    oid, error);
d1665 1
d1670 3
a1672 2
		printf("%s: failure retrieving oid 0x%x: %d\n",
		    sc->sc_dev.dv_xname, oid, error);
d1687 1
d1692 3
a1694 2
		printf("%s: failure setting oid 0x%x: %d\n",
		    sc->sc_dev.dv_xname, oid, error);
d1701 2
a1702 2
	printf("%s: state dump: control 0x%08x "
	    "interrupt 0x%08x\n", sc->sc_dev.dv_xname,
d1768 2
a1769 2
		printf("%s: queue: mgmt %p -> (op %u, "
		    "oid 0x%x, len %u)\n", sc->sc_dev.dv_xname,
d1771 1
a1771 1
		    pmd->pmd_oid, pmd->pmd_len);
a1773 14
	sc->sc_refcnt++;
#ifdef DEVICE_POLLING
	/*
	 * If we're polling, try 1/10th second initially at the smallest
	 * interval we can sleep for.
	 */
	for (i = 0; sc->sc_ic.ic_if.if_flags & IFF_POLLING && i < 100; i++) {
		pgt_update_intr(sc, NULL, 0);
		if (pmd->pmd_error != EINPROGRESS)
			goto usedpoll;
		if (tsleep(pmd, 0, "pgtmgp", 1) != EWOULDBLOCK)
			break;
	}
#endif
d1796 1
a1796 1
		pgt_update_intr(sc, NULL, 0);
a1799 3
#ifdef DEVICE_POLLING
usedpoll:
#endif
d1802 1
a1802 1
		    "packet response to 0x%x\n",
a1810 1
	sc->sc_refcnt--;
d1824 2
a1825 2
		printf("%s: queue: tx %u -> [%u]\n", sc->sc_dev.dv_xname,
		    pd->pd_fragnum, pq);
d1851 2
a1852 2
		printf("%s: triggered by queue [%u]\n",
		    sc->sc_dev.dv_xname, pq);
d1864 1
a1864 1
					printf("%s: timeout triggering from "
d1866 1
a1866 1
					    sc->sc_dev.dv_xname);
d1892 1
d1898 1
a1898 1
	    int reallynew)
d1914 1
a1914 1
	    const struct ieee80211_node *src)
d1926 1
a1926 1
	    int type, int arg)
d1936 1
a1936 2
	struct arpcom *ac = &ic->ic_ac;
	struct ifnet *ifp = &ac->ac_if;
d1946 12
a1957 11
	psbuffer.pob_addr = htole32((uint32_t)sc->sc_psmdmabusaddr);
	error = pgt_oid_set(sc, PGT_OID_PSM_BUFFER, &psbuffer,
	    sizeof(psbuffer));
	if (error == 0)
		error = pgt_oid_get(sc, PGT_OID_PHY, &phymode, sizeof(phymode));
	if (error == 0)
		error = pgt_oid_get(sc, PGT_OID_MAC_ADDRESS, ac->ac_enaddr,
		    sizeof(ac->ac_enaddr));
	if (error == 0)
		error = pgt_oid_get(sc, PGT_OID_COUNTRY, &country,
		    sizeof(country));
d1961 3
a1963 8
	//if_initname(ifp, device_get_name(sc->sc_dev),
	//    device_get_unit(sc->sc_dev));
	ifp->if_flags = IFF_BROADCAST | IFF_MULTICAST | IFF_RUNNING;
	ifp->if_capabilities = IFCAP_VLAN_MTU;
#ifdef DEVICE_POLLING
	ifp->if_capabilities |= IFCAP_POLLING;
#endif
	//ifp->if_capenable = IFCAP_VLAN_MTU;
d1965 4
a1968 3
	ifp->if_ioctl = pgt_ioctl;
	ifp->if_watchdog = pgt_periodic;
	ifp->if_init = pgt_init;
a1969 1
	//ifp->if_snd.ifq_drv_maxlen = PGT_QUEUE_FULL_THRESHOLD;
a1971 1
	IEEE80211_ADDR_COPY(ic->ic_myaddr, ac->ac_enaddr);
d2029 1
a2029 1
		case 44:	/* maybe */
d2047 1
d2051 1
a2051 1
	ic->ic_phytype = IEEE80211_T_OFDM;	/* XXX not really used */
d2054 1
a2054 1
	ic->ic_protmode = IEEE80211_PROT_NONE;
d2057 4
a2060 2
	/* Set up post-attach/pre-lateattach vector functions. */
	ic->ic_newstate = pgt_new_state;
d2066 1
d2068 14
a2081 6
	ieee80211_media_init(ifp, pgt_media_change, pgt_media_status);
	//bpfattach2(ifp, DLT_IEEE802_11_RADIO, sizeof(struct ieee80211_frame) +
	//    sizeof(struct pgt_ieee80211_radiotap), &sc->sc_drvbpf);
	/* default to the first channel we know of */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	sc->sc_if_flags = ifp->if_flags;
d2086 2
a2087 2
void
pgt_net_detach(struct pgt_softc *sc)
d2089 10
a2098 3
	ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);
	bpfdetach(&sc->sc_ic.ic_if);
	ieee80211_ifdetach(&sc->sc_ic.ic_if);
d2109 1
d2115 1
a2130 2
	if (!pgt_try_enter_data_critical(sc))
		return;
d2137 1
a2137 2
	    //PGT_QUEUE_FULL_THRESHOLD && !IFQ_DRV_IS_EMPTY(&ifp->if_snd);) {
	    PGT_QUEUE_FULL_THRESHOLD;) {
d2139 1
a2139 1
		//IFQ_DRV_DEQUEUE(&ifp->if_snd, m);
d2146 1
a2146 1
				//IFQ_DRV_PREPEND(&ifp->if_snd, m);
a2151 3
			//BPF_MTAP(ifp, m);
			ifp->if_opackets++;
			sc->sc_critical++;
d2163 1
a2163 1
				//IFQ_DRV_PREPEND(&ifp->if_snd, m);
d2180 1
a2180 1
				//IFQ_DRV_PREPEND(&ifp->if_snd, m);
a2189 3
			//BPF_MTAP(ifp, m);
			ifp->if_opackets++;
			sc->sc_critical += 2;
d2197 5
a2201 1

d2203 1
a2203 1
			//getbinuptime(&sc->sc_data_tx_started);
d2211 1
d2213 1
d2238 2
a2239 2
					//bpf_mtap2(sc->sc_drvbpf, &pir,
					//    sizeof(pir), m);
d2242 31
a2272 1
			} else {
a2273 1
			}
a2275 1
	//pgt_try_exit_data_critical(sc);
d2281 4
d2286 1
d2289 7
a2295 3
	//struct ifprismoidreq *preq;
	//struct ieee80211req *ireq;
	int error, oldflags;
d2297 1
d2299 2
d2305 1
a2305 1
		//error = suser(curthread);
d2321 15
a2335 2
	case SIOCGWAVELAN:
	case SIOCSWAVELAN:
d2337 15
a2351 1
		error = copyin(ifr->ifr_data, wreq, sizeof(*wreq));
d2353 62
a2414 8
			if (cmd == SIOCGWAVELAN) {
				error = pgt_wavelan_get(sc, wreq);
				if (error == 0)
					error = copyout(wreq, ifr->ifr_data,
					    sizeof(*wreq));
			} else {
				error = pgt_wavelan_set(sc, wreq);
			}
d2416 3
a2418 3
		free(wreq, M_DEVBUF);
		if (error == EOPNOTSUPP)
			goto notours;
d2420 8
d2429 3
a2431 8
		error = 0;
		oldflags = sc->sc_if_flags;
		sc->sc_if_flags = ifp->if_flags;
		if ((oldflags & (IFF_PROMISC | IFF_UP)) !=
		    (ifp->if_flags & (IFF_PROMISC | IFF_UP))) {
			if (!(oldflags & IFF_UP) && ifp->if_flags & IFF_UP) {
				ieee80211_new_state(&sc->sc_ic,
				    IEEE80211_S_SCAN, -1);
d2433 4
a2436 4
			} else if (oldflags & IFF_UP &&
			    !(ifp->if_flags & IFF_UP)) {
				ieee80211_new_state(&sc->sc_ic,
				    IEEE80211_S_INIT, -1);
a2442 2
			uprintf("%s: bad MTU (values > %u non-functional)\n",
			    ifp->if_xname, PGT_FRAG_SIZE);
d2444 1
a2444 14
		} else {
			ifp->if_mtu = ifr->ifr_mtu;
			error = 0;
		}
		break;
#ifdef DEVICE_POLLING
	case SIOCSIFCAP:
		if (!(ifp->if_capabilities & IFF_RUNNING)) {
			error = EIO;
		} else {
			if ((ifr->ifr_reqcap & IFCAP_POLLING) !=
			    (ifp->if_capenable & IFCAP_POLLING))
				ifp->if_capenable ^= IFCAP_POLLING;
			error = 0;
d2446 1
a2446 2
		break;
#endif
a2447 1
notours:
d2455 1
d2460 2
d2467 1
a2467 1
	    struct wi_scan_res *scanres, uint32_t noise)
d2496 1
d2505 2
a2506 1
	IEEE80211_DPRINTF(("%s: %02x:%02x:%02x:%02x:%02x:%02x "
d2512 1
d2519 1
d2522 1
d2641 1
a2641 1
	//struct ieee80211req_mlme mlme;
d2723 1
a2723 1
			//error = pgt_do_mlme_sta(sc, &mlme);
d2726 1
a2726 1
			//error = pgt_do_mlme_hostap(sc, &mlme);
d2729 1
a2729 1
			//error = pgt_do_mlme_adhoc(sc, &mlme);
a2746 88
int
pgt_wavelan_get(struct pgt_softc *sc, struct wi_req *wreq)
{
	struct ieee80211com *ic;
	struct pgt_obj_bsslist *pob;
	struct wi_scan_p2_hdr *p2hdr;
	struct wi_scan_res *scan;
	uint32_t noise;
	unsigned int maxscan, i;
	int error;

	ic = &sc->sc_ic;
	switch (wreq->wi_type) {
	case WI_RID_COMMS_QUALITY:
		wreq->wi_val[0] = 0;	/* don't know correction factor */
		wreq->wi_val[1] = htole16(ic->ic_node_getrssi(ic, ic->ic_bss));
		wreq->wi_val[2] = htole16(sc->sc_noise);
		wreq->wi_len = 4;
		error = 0;
		break;
	case WI_RID_SCAN_RES:
		maxscan = PGT_OBJ_BSSLIST_NBSS;
		pob = malloc(sizeof(*pob) +
		    sizeof(struct pgt_obj_bss) * maxscan, M_DEVBUF, M_WAITOK);
		pgt_enter_critical(sc);
		error = pgt_oid_get(sc, PGT_OID_NOISE_FLOOR, &noise,
		    sizeof(noise));
		if (error == 0) {
			noise = letoh32(noise);
			error = pgt_oid_get(sc, PGT_OID_BSS_LIST, pob,
			    sizeof(*pob) +
			    sizeof(struct pgt_obj_bss) * maxscan);
		}
		if (error == 0) {
			maxscan = min(PGT_OBJ_BSSLIST_NBSS,
			    letoh32(pob->pob_count));
			maxscan = min(maxscan,
			    (sizeof(wreq->wi_val) - sizeof(*p2hdr)) /
			    WI_PRISM2_RES_SIZE);
			p2hdr = (struct wi_scan_p2_hdr *)&wreq->wi_val;
			p2hdr->wi_rsvd = 0;
			p2hdr->wi_reason = 1;	/* what should it be? */
			for (i = 0; i < maxscan; i++) {
				scan = (struct wi_scan_res *)
				    ((char *)&wreq->wi_val + sizeof(*p2hdr) +
				    i * WI_PRISM2_RES_SIZE);
				pgt_obj_bss2scanres(sc, &pob->pob_bsslist[i],
				    scan, noise);
			}
			wreq->wi_len = (maxscan * WI_PRISM2_RES_SIZE) / 2 +
			    sizeof(*p2hdr) / 2;
		}
		pgt_exit_critical(sc);
		free(pob, M_DEVBUF);
		break;
	default:
		error = EOPNOTSUPP;
		break;
	}
	return (error);
}

int
pgt_wavelan_set(struct pgt_softc *sc, struct wi_req *wreq)
{
	int error;

	/*
	 * If we wanted to, we could support the "partial reset" interface
	 * here, but the Wavelan interface should really not need to be used.
	 */
	switch (wreq->wi_type) {
	case WI_RID_SCAN_REQ:
	case WI_RID_SCAN_APS:
		/* We're always scanning. */
		error = 0;
		break;
	case WI_RID_CHANNEL_LIST:
		/* The user can just use net80211's interface. */
		error = EPERM;
		break;
	default:
		error = EOPNOTSUPP;
		break;
	}
	return (error);
}

d2773 1
a2773 1
pgt_periodic(struct ifnet *ifp)
a2783 1
		struct bintime txtime;
d2787 1
a2787 3
		//getbinuptime(&txtime);
		bintime_sub(&txtime, &sc->sc_data_tx_started);
		if (txtime.sec >= 1) {
d2789 4
a2792 3
			if (sc->sc_flags & SC_DEBUG_UNEXPECTED)
				printf("%s: timed out %d data transmissions\n",
				    sc->sc_dev.dv_xname, count);
d2805 2
a2806 4
#ifdef DEVICE_POLLING
		if (!(ifp->if_flags & IFF_POLLING))
#endif
			pgt_async_update(sc);
d2837 1
d2843 6
d2869 2
a2870 2
	uint32_t mode, bsstype, config, profile, channel, slot, preamble,
	    wep, exunencrypted, wepkey, dot1x, auth, mlme;
d2872 1
a2872 1
	int success, shouldbeup;
d2875 1
d2881 1
d2934 1
d2949 3
a2951 2
	case IEEE80211_MODE_TURBO:
		/* not handled */
d2959 1
d2971 5
a2975 2
	switch (sc->sc_80211_ioc_wep) {
	case IEEE80211_WEP_OFF:
a2977 10
		break;
	case IEEE80211_WEP_MIXED:
		wep = 1;
		exunencrypted = 0;
		break;
	case IEEE80211_WEP_ON:
	default:
		wep = 1;
		exunencrypted = 1;
		break;
d2979 1
d2988 1
d2993 1
d2998 1
d3005 3
a3007 3
	} else {
		channel = htole32(ieee80211_chan2ieee(ic, ic->ic_des_chan));
	}
d3013 2
a3014 1
	pgt_enter_critical(sc);
a3015 4
#define	SETOID(oid, var, size) {					\
	if (pgt_oid_set(sc, oid, var, size) != 0)			\
		break;							\
}
d3019 1
d3025 1
d3028 2
a3029 1
		if (channel != 0)
d3031 1
d3039 1
d3041 1
d3044 1
d3054 3
d3059 1
d3067 1
d3075 1
d3083 1
d3091 1
a3096 1
#undef SETOID
d3098 2
a3099 1
	pgt_exit_critical(sc);
d3117 1
a3117 1
 * valid (see pgt_periodic()).
d3123 3
a3125 1
	//struct ieee80211_node *ni;
d3128 1
d3131 1
a3131 1
	/*
d3137 1
a3137 1
	*/
d3144 1
a3144 1
	/*
d3152 2
a3153 2
	*/
	pgt_enter_critical(sc);
d3162 1
a3162 1
			IEEE80211_DPRINTF(("%s: %02x:%02x:%02x:%02x:%02x:%02x "
d3174 1
a3174 1
	pgt_exit_critical(sc);
d3223 1
a3223 1
	int error;
d3235 2
a3236 2
			printf("%s: trap: oid 0x%x len %u\n",
			    sc->sc_dev.dv_xname, oid, args->m_len);
d3243 2
a3244 2
				printf("%s: link: %u\n",
				    sc->sc_dev.dv_xname, ls);
d3258 1
a3258 1
				printf("%s: mlme: address "
d3267 1
a3267 1
				    letoh16(mlme->pom_code));
d3275 1
a3275 1
		pgt_enter_critical(sc);
d3277 1
a3277 1
		pgt_exit_critical(sc);
d3280 3
a3282 1
		if (letoh32(ls) != 0)
d3285 1
d3287 1
a3287 1
	pgt_enter_critical(sc);
a3314 17
out:
	pgt_exit_critical(sc);
}

int
pgt_media_change(struct ifnet *ifp)
{
	struct pgt_softc *sc = ifp->if_softc;
	int error;
	
	error = ieee80211_media_change(ifp);
	if (error == ENETRESET) {
		pgt_update_hw_from_sw(sc, 0, 0);
		error = 0;
	}
	return (error);
}
a3315 49
void
pgt_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct pgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t ls;
	int alreadylocked;
	
	imr->ifm_active = IFM_IEEE80211;
	if (!(ifp->if_flags & IFF_UP))
		return;
	alreadylocked = 0;
	if (!alreadylocked)
		alreadylocked = 0;
	imr->ifm_status = IFM_AVALID;
	pgt_enter_critical(sc);
	if (pgt_oid_get(sc, PGT_OID_LINK_STATE, &ls, sizeof(ls)) != 0) {
		imr->ifm_active |= IFM_NONE;
		imr->ifm_status = 0;
		goto out;
	}
	ls = letoh32(ls);
	if (sc->sc_debug & SC_DEBUG_LINK)
		printf("%s: link: %u\n", sc->sc_dev.dv_xname, ls);
	if (ls == 0) {
		imr->ifm_active |= IFM_NONE;
		imr->ifm_status = 0;
		goto out;
	}
	if (ic->ic_state != IEEE80211_S_INIT)
		imr->ifm_status |= IFM_ACTIVE;
	/* XXX query the PHY "mode"? */
	imr->ifm_active |= ieee80211_rate2media(ic, ls, IEEE80211_MODE_AUTO);
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
	case IEEE80211_M_IBSS:
		imr->ifm_active |= IFM_IEEE80211_ADHOC;
		break;
	case IEEE80211_M_AHDEMO:
		imr->ifm_active |= IFM_IEEE80211_ADHOC | IFM_FLAG0;
		break;
	case IEEE80211_M_HOSTAP:
		imr->ifm_active |= IFM_IEEE80211_HOSTAP;
		break;
	case IEEE80211_M_MONITOR:
		imr->ifm_active |= IFM_IEEE80211_MONITOR;
		break;
	}
d3317 1
a3317 3
	pgt_exit_critical(sc);
	if (!alreadylocked)
		alreadylocked = 0;
d3324 1
a3324 2
pgt_new_state(struct ieee80211com *ic, enum ieee80211_state nstate,
    int mgtdata)
d3326 1
a3326 1
	struct pgt_softc *sc;
a3328 1
	sc = (struct pgt_softc *)ic->ic_if.if_softc;
d3330 2
a3331 1
	IEEE80211_DPRINTF(("%s: %s -> %s\n", __func__,
d3333 1
d3340 3
a3342 1
		//IF_DRAIN(&ic->ic_mgtq);
d3351 1
d3355 2
a3356 2
			//struct ieee80211_node *ni;
			//struct pgt_ieee80211_node *pin;
a3358 1
			/*
a3362 1
			*/
d3371 1
a3374 2
		ic->ic_mgt_timer = 0;
		ic->ic_state = nstate;
a3375 2
		//if (!IFQ_DRV_IS_EMPTY(&ic->ic_if.if_snd))
		//	pgt_start_body(sc, ic, &ic->ic_if);
d3380 2
a3381 1
	return (0);
d3407 2
a3408 2
			printf("%s: queue: tx %u <- [%u] (drained)\n",
			    sc->sc_dev.dv_xname, pd->pd_fragnum, pq);
d3410 1
a3410 1
		if (pgt_queue_is_data(pq)) {
a3411 2
			//pgt_try_exit_data_critical(sc);
		}
d3413 1
d3434 1
a3434 1
	    BUS_DMA_ALLOCNOW, &sc->sc_cbdmam);
d3456 1
d3459 1
a3459 1
	    sc->sc_cb, size, NULL, BUS_DMA_WAITOK);
d3494 1
d3606 1
a3606 1
			    pd->pd_mem, PGT_FRAG_SIZE, NULL, BUS_DMA_WAITOK);
d3615 1
@


1.8
log
@Some first cleanup run.

ok deraadt@@
@
text
@a776 2
	return (0);

d784 4
a787 2
	pgt_disable(sc, SC_DYING);
	pgt_reboot(sc);
d1971 1
a1971 3
		/*
		if (msleep(pmd, &sc->sc_lock, PZERO, "pffmgp", 1) !=
		    EWOULDBLOCK)
a1972 1
		*/
d1985 1
a1985 3
		/*
		if (msleep(pmd, &sc->sc_lock, PZERO, "pffmgm", hz / 10) !=
		    EWOULDBLOCK)
a1986 1
		*/
d1991 1
a1991 2
			TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd,
			    pmd_link);	
d2000 1
d2006 3
a2008 3
		    "packet response to 0x%x\n", sc->sc_dev.dv_xname, pmd->pmd_oid);
		TAILQ_REMOVE(&sc->sc_mgmtinprog, pmd,
		    pmd_link);	
d2013 1
a2013 1
	} else {
a2014 1
	}
d2016 1
d2264 1
d2280 1
d3635 1
a3635 1
	for (i = 0; i < PGT_QUEUE_COUNT; i++)
d3637 2
@


1.7
log
@Bring chip into initialized state.

ok deraadt@@
@
text
@a139 3
#if 0
void	 pgt_kill_kthread(struct pgt_softc *);
#endif
a192 1

a198 1

d260 1
a260 1
	(void)bus_space_read_4(sc->sc_iotag, sc->sc_iohandle, PFF_REG_INT_EN);
d290 1
a290 1
	pd->pd_fragp->pf_size = htole16(PFF_FRAG_SIZE);
d304 1
a304 1
	    PFF_FRAG_SIZE, NULL, BUS_DMA_NOWAIT);
d312 1
a312 1
	pd->pd_fragp->pf_size = htole16(PFF_FRAG_SIZE);
a355 1

d430 1
a430 1
	reg = PFF_FIRMWARE_INTERNAL_OFFSET;
d432 1
a432 1
		pgt_write_4_flush(sc, PFF_REG_DIR_MEM_BASE, reg);
d434 2
a435 2
		if ((size - fwoff) >= PFF_DIRECT_MEMORY_SIZE)
			fwlen = PFF_DIRECT_MEMORY_SIZE;
d439 1
a439 1
		dirreg = PFF_DIRECT_MEMORY_OFFSET;
d458 4
a461 4
	reg = pgt_read_4(sc, PFF_REG_CTRL_STAT);
	reg &= ~(PFF_CTRL_STAT_RESET | PFF_CTRL_STAT_CLOCKRUN);
	reg |= PFF_CTRL_STAT_RAMBOOT;
	pgt_write_4_flush(sc, PFF_REG_CTRL_STAT, reg);
d463 1
a463 1
	DELAY(PFF_WRITEIO_DELAY);
d465 2
a466 2
	reg |= PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d468 1
a468 1
	DELAY(PFF_WRITEIO_DELAY);
d470 2
a471 2
	reg &= ~PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d473 1
a473 1
	DELAY(PFF_WRITEIO_DELAY);
d518 2
a519 2
	pgt_write_4_flush(sc, PFF_REG_INT_EN, 0x00000000);
	DELAY(PFF_WRITEIO_DELAY);
d528 1
a528 1
	pgt_cleanup_queue(sc, PFF_QUEUE_DATA_LOW_RX,
d530 1
a530 1
	pgt_cleanup_queue(sc, PFF_QUEUE_DATA_LOW_TX,
d532 1
a532 1
	pgt_cleanup_queue(sc, PFF_QUEUE_DATA_HIGH_RX,
d534 1
a534 1
	pgt_cleanup_queue(sc, PFF_QUEUE_DATA_HIGH_TX,
d536 1
a536 1
	pgt_cleanup_queue(sc, PFF_QUEUE_MGMT_RX,
d538 1
a538 1
	pgt_cleanup_queue(sc, PFF_QUEUE_MGMT_TX,
d557 1
a557 1
	//pgt_write_4_flush(sc, PFF_REG_CTRL_BLK_BASE,
d559 1
a559 1
	//DELAY(PFF_WRITEIO_DELAY);
d562 2
a563 2
	pgt_write_4_flush(sc, PFF_REG_DEV_INT, PFF_DEV_INT_RESET);
	DELAY(PFF_WRITEIO_DELAY);
d566 2
a567 2
	pgt_write_4_flush(sc, PFF_REG_INT_EN, PFF_INT_STAT_INIT);	
	DELAY(PFF_WRITEIO_DELAY);
d585 1
a585 4
#ifdef DEVICE_POLLING
	mtx_lock(&Giant);
#endif
	//mtx_lock(&sc->sc_lock);
d610 2
a611 2
	pgt_write_4_flush(sc, PFF_REG_INT_EN, PFF_INT_STAT_SOURCES);	
	DELAY(PFF_WRITEIO_DELAY);
d621 3
a623 3
	pgt_drain_tx_queue(sc, PFF_QUEUE_DATA_LOW_TX);
	pgt_drain_tx_queue(sc, PFF_QUEUE_DATA_HIGH_TX);
	pgt_drain_tx_queue(sc, PFF_QUEUE_MGMT_TX);
d632 2
a633 3
	pgt_write_4_flush(sc, PFF_REG_INT_EN, 0x00000000);
	DELAY(PFF_WRITEIO_DELAY);
	//mtx_unlock(&sc->sc_lock);
d638 3
a640 4
	//mtx_lock(&sc->sc_lock);
	reg = pgt_read_4(sc, PFF_REG_CTRL_STAT);
	reg &= ~(PFF_CTRL_STAT_RESET | PFF_CTRL_STAT_RAMBOOT);
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d642 3
a644 3
	DELAY(PFF_WRITEIO_DELAY);
	reg |= PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d646 3
a648 3
	DELAY(PFF_WRITEIO_DELAY);
	reg &= ~PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d650 1
a650 1
	DELAY(PFF_WRITEIO_DELAY);
a685 1
		//mtx_unlock(&sc->sc_lock);
a688 1
		//mtx_lock(&sc->sc_lock);
d713 3
a715 3
				pgt_write_4_flush(sc, PFF_REG_INT_EN,
				    PFF_INT_STAT_SOURCES);	
				DELAY(PFF_WRITEIO_DELAY);
a730 5
//out2:
	//mtx_unlock(&sc->sc_lock);
#ifdef DEVICE_POLLING
	mtx_unlock(&Giant);
#endif
a732 14
#if 0
void
pgt_kill_kthread(struct pgt_softc *sc)
{
	if (sc->sc_flags & SC_KTHREAD) {
		mtx_lock(&sc->sc_lock);
		sc->sc_kthread.sck_exit = 1;
		cv_signal(&sc->sc_kthread.sck_needed);
		msleep(sc->sc_kthread.sck_proc, &sc->sc_lock, PPAUSE | PDROP,
		    "pffktc", 0);
	}
}
#endif

a745 5
	//mtx_init(&sc->sc_lock, device_get_nameunit(dev), MTX_NETWORK_LOCK,
	//    MTX_DEF);
	//cv_init(&sc->sc_critical_cv, "pffccv");
	//cv_init(&sc->sc_kthread.sck_needed, "pffkth");
	//sc->sc_dev = dev;
a747 26
	SYSCTL_ADD_UINT(device_get_sysctl_ctx(dev),
	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
	    OID_AUTO, "debug", CTLFLAG_RW, &sc->sc_debug, 0,
	    "0x1:queue,0x2:mgmt,0x4:unexpected,0x8:trigger,0x10:events,"
	    "0x20:power,0x40:trap,0x80:link,0x100:rxannex,0x200:rxfrag,"
	    "0x400:rxether");
	TUNABLE_INT_FETCH("dev.pff.debug", &sc->sc_debug);
	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
	    OID_AUTO, "dot1x", CTLFLAG_RW, &sc->sc_dot1x, 0,
	    "Enable 802.1x authentication mode");
	SYSCTL_ADD_INT(device_get_sysctl_ctx(dev),
	    SYSCTL_CHILDREN(device_get_sysctl_tree(dev)),
	    OID_AUTO, "wds", CTLFLAG_RW, &sc->sc_wds, 0,
	    "Enable WDS");
	*/
	/*	    
	error = kthread_create(pgt_per_device_kthread, sc,
	    &sc->sc_kthread.sck_proc, 0, 0, device_get_nameunit(dev));
	if (error != 0) {
		printf("%s: failure establishing kthread: %d\n",
		    sc->sc_dev.dv_xname, error);
		goto failed;
	}
	sc->sc_flags |= SC_KTHREAD;
	
a755 2
	//mtx_lock(&sc->sc_lock);
	/* reset 802.11 state */
d771 2
a772 2
		pgt_write_4_flush(sc, PFF_REG_INT_EN, PFF_INT_STAT_SOURCES);
		DELAY(PFF_WRITEIO_DELAY);
d774 1
a774 3

	//mtx_unlock(&sc->sc_lock);
	if (error != 0)
d780 5
a784 3
	if (error == 0) {
		ieee80211_new_state(&sc->sc_ic, IEEE80211_S_INIT, -1);
	} else {
d786 2
a787 7
		pgt_disable(sc, SC_DYING);
		pgt_reboot(sc);
		//pgt_kill_kthread(sc);
		//cv_destroy(&sc->sc_kthread.sck_needed);
		//cv_destroy(&sc->sc_critical_cv);
		//mtx_destroy(&sc->sc_lock);
	}
a794 2
	return (0);

a798 4
	//pgt_kill_kthread(sc);
	//cv_destroy(&sc->sc_kthread.sck_needed);
	//cv_destroy(&sc->sc_critical_cv);
	//mtx_destroy(&sc->sc_lock);
d808 3
a810 3
	reg = pgt_read_4(sc, PFF_REG_CTRL_STAT);
	reg &= ~(PFF_CTRL_STAT_RESET | PFF_CTRL_STAT_RAMBOOT);
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d812 1
a812 1
	DELAY(PFF_WRITEIO_DELAY);
d814 2
a815 2
	reg |= PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d817 1
a817 1
	DELAY(PFF_WRITEIO_DELAY);
d819 2
a820 2
	reg &= ~PFF_CTRL_STAT_RESET;
	pgt_write_4(sc, PFF_REG_CTRL_STAT, reg);
d822 1
a822 1
	DELAY(PFF_RESET_DELAY);
d847 4
a850 4
	enum pgt_queue pqs[PFF_QUEUE_COUNT] = {
	    PFF_QUEUE_MGMT_TX, PFF_QUEUE_MGMT_RX, 
	    PFF_QUEUE_DATA_HIGH_TX, PFF_QUEUE_DATA_HIGH_RX, 
	    PFF_QUEUE_DATA_LOW_TX, PFF_QUEUE_DATA_LOW_RX
d864 1
a864 1
	for (i = 0; i < PFF_QUEUE_COUNT; i++) {
d877 1
a877 1
#ifdef PFF_BUGGY_INTERRUPT_RECOVERY
d932 2
a933 2
	dirtycount = sc->sc_dirtyq_count[PFF_QUEUE_MGMT_RX];
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PFF_QUEUE_MGMT_RX])) {
d944 1
a944 1
	sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_MGMT_RX] =
d946 1
a946 1
		letoh32(sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_MGMT_RX]));
d948 1
a948 1
	dirtycount = sc->sc_dirtyq_count[PFF_QUEUE_DATA_HIGH_RX];
d950 2
a951 2
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PFF_QUEUE_DATA_HIGH_RX]))
		prevwasmf = pgt_datarx_completion(sc, PFF_QUEUE_DATA_HIGH_RX,
d953 1
a953 1
	sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_DATA_HIGH_RX] =
d955 1
a955 1
		letoh32(sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_DATA_HIGH_RX]));
d957 1
a957 1
	dirtycount = sc->sc_dirtyq_count[PFF_QUEUE_DATA_LOW_RX];
d959 2
a960 2
	while (!TAILQ_EMPTY(&sc->sc_dirtyq[PFF_QUEUE_DATA_LOW_RX]))
		prevwasmf = pgt_datarx_completion(sc, PFF_QUEUE_DATA_LOW_RX,
d962 1
a962 1
	sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_DATA_LOW_RX] =
d964 1
a964 1
		letoh32(sc->sc_cb->pcb_driver_curfrag[PFF_QUEUE_DATA_LOW_RX]));
d1226 1
a1226 1
				    htole32(PFF_IEEE80211_RADIOTAP_PRESENT);
d1266 1
a1266 1
	for (i = 0; !shouldupdate && i < PFF_QUEUE_COUNT; i++) {
d1280 2
a1281 2
		pgt_write_4_flush(sc, PFF_REG_DEV_INT, PFF_DEV_INT_UPDATE);
		DELAY(PFF_WRITEIO_DELAY);
d1296 1
a1296 1
	for (i = 0; allowed && i < PFF_QUEUE_COUNT; i++) {
d1310 2
a1311 2
		pgt_write_4_flush(sc, PFF_REG_DEV_INT, PFF_DEV_INT_SLEEP);
		DELAY(PFF_WRITEIO_DELAY);
a1338 1
	//mtx_lock(&sc->sc_lock);
a1348 1
			//mtx_unlock(&sc->sc_lock);
a1349 1
			//mtx_lock(&sc->sc_lock);
a1363 1
	//mtx_unlock(&sc->sc_lock);
a1430 1
	//mtx_lock(&sc->sc_lock);
d1436 2
a1437 3
		pgt_write_4_flush(sc, PFF_REG_INT_EN, PFF_INT_STAT_SOURCES);	
		DELAY(PFF_WRITEIO_DELAY);
                //mtx_unlock(&sc->sc_lock);
a1444 1
	//mtx_unlock(&sc->sc_lock);
a1465 1
	//mtx_lock(&sc->sc_lock);
d1467 1
a1467 2
	if (ifp->if_flags & IFF_POLLING) {
		//mtx_unlock(&sc->sc_lock);
a1468 1
	}
d1473 2
a1474 3
		pgt_write_4_flush(sc, PFF_REG_INT_EN, 0);	
		DELAY(PFF_WRITEIO_DELAY);
		//mtx_unlock(&sc->sc_lock);
a1479 1
	//mtx_unlock(&sc->sc_lock);
d1511 2
a1512 3
		reg = pgt_read_4(sc, PFF_REG_CTRL_STAT);
		if (reg & PFF_CTRL_STAT_SLEEPMODE) {
			//mtx_unlock(&sc->sc_lock);
a1513 1
		}
d1517 1
a1517 1
		reg = PFF_INT_STAT_UPDATE;
d1520 1
a1520 1
		reg = pgt_read_4(sc, PFF_REG_INT_STAT);
d1525 2
a1526 2
			pgt_write_4_flush(sc, PFF_REG_INT_ACK, reg);
		if (reg & PFF_INT_STAT_INIT)
d1528 1
a1528 1
		if (reg & PFF_INT_STAT_UPDATE) {
d1540 3
a1542 3
			pgt_write_4_flush(sc, PFF_REG_DEV_INT,
			    PFF_DEV_INT_UPDATE);
			DELAY(PFF_WRITEIO_DELAY);
d1544 1
a1544 1
		if (reg & PFF_INT_STAT_SLEEP && !(reg & PFF_INT_STAT_WAKEUP))
d1546 1
a1546 1
		if (reg & PFF_INT_STAT_WAKEUP)
d1553 1
a1553 1
	if (reg & ~PFF_INT_STAT_SOURCES && sc->sc_debug & SC_DEBUG_UNEXPECTED) {
d1556 2
a1557 2
		    reg & ~PFF_INT_STAT_SOURCES,
		    pgt_read_4(sc, PFF_REG_CTRL_STAT));
d1642 4
a1645 4
	pd = TAILQ_FIRST(&sc->sc_dirtyq[PFF_QUEUE_MGMT_RX]);
	TAILQ_REMOVE(&sc->sc_dirtyq[PFF_QUEUE_MGMT_RX], pd, pd_link);
	sc->sc_dirtyq_count[PFF_QUEUE_MGMT_RX]--;
	TAILQ_INSERT_TAIL(&sc->sc_freeq[PFF_QUEUE_MGMT_RX],
d1647 1
a1647 1
	sc->sc_freeq_count[PFF_QUEUE_MGMT_RX]++;
d1685 1
a1685 1
		    min(size, PFF_FRAG_SIZE - sizeof(*pmf)));
d1717 1
a1717 1
		if (size > PFF_FRAG_SIZE) {
d1775 1
a1775 1
	if (datalen > PFF_FRAG_SIZE) {
d1890 2
a1891 2
	    pgt_read_4(sc, PFF_REG_CTRL_STAT),
	    pgt_read_4(sc, PFF_REG_INT_STAT));
d1927 1
a1927 1
	if (pmd->pmd_len > PFF_FRAG_SIZE - sizeof(*pmf))
d1929 1
a1929 1
	pd = TAILQ_FIRST(&sc->sc_freeq[PFF_QUEUE_MGMT_TX]);
d1932 1
a1932 1
	error = pgt_load_tx_desc_frag(sc, PFF_QUEUE_MGMT_TX, pd);
d1959 1
a1959 1
	pgt_desc_transmit(sc, PFF_QUEUE_MGMT_TX, pd,
d2002 2
a2003 2
			pgt_maybe_trigger(sc, PFF_QUEUE_MGMT_RX);
#ifdef PFF_BUGGY_INTERRUPT_RECOVERY
d2058 1
a2058 1
	unsigned int tries = 1000000 / PFF_WRITEIO_DELAY; /* one second */
d2067 1
a2067 1
		if (pgt_read_4(sc, PFF_REG_INT_STAT) == 0xabadface) {
d2069 3
a2071 3
				reg = pgt_read_4(sc, PFF_REG_CTRL_STAT);
				if (!(reg & PFF_CTRL_STAT_SLEEPMODE))
					DELAY(PFF_WRITEIO_DELAY);
d2073 1
a2073 1
			if (!(reg & PFF_CTRL_STAT_SLEEPMODE)) {
d2082 3
a2084 3
		pgt_write_4_flush(sc, PFF_REG_DEV_INT,
		    PFF_DEV_INT_WAKEUP);
		DELAY(PFF_WRITEIO_DELAY);
d2086 2
a2087 2
		(void)pgt_read_4(sc, PFF_REG_CTRL_STAT);
		DELAY(PFF_WRITEIO_DELAY);
d2089 2
a2090 2
		pgt_write_4_flush(sc, PFF_REG_DEV_INT, PFF_DEV_INT_UPDATE);
		DELAY(PFF_WRITEIO_DELAY);
d2156 1
a2156 2
	//mtx_lock(&sc->sc_lock);
	psbuffer.pob_size = htole32(PFF_FRAG_SIZE * PFF_PSM_BUFFER_FRAME_COUNT);
d2158 1
a2158 1
	error = pgt_oid_set(sc, PFF_OID_PSM_BUFFER, &psbuffer,
d2161 1
a2161 1
		error = pgt_oid_get(sc, PFF_OID_PHY, &phymode, sizeof(phymode));
d2163 1
a2163 1
		error = pgt_oid_get(sc, PFF_OID_MAC_ADDRESS, ac->ac_enaddr,
d2166 1
a2166 1
		error = pgt_oid_get(sc, PFF_OID_COUNTRY, &country,
a2167 1
	//mtx_unlock(&sc->sc_lock);
d2183 2
a2184 2
	IFQ_SET_MAXLEN(&ifp->if_snd, PFF_QUEUE_FULL_THRESHOLD);
	//ifp->if_snd.ifq_drv_maxlen = PFF_QUEUE_FULL_THRESHOLD;
d2190 1
a2190 3
	//mtx_lock(&sc->sc_lock);
	error = pgt_oid_get(sc, PFF_OID_SUPPORTED_FREQUENCIES, freqs, j);
	//mtx_unlock(&sc->sc_lock);
d2210 1
a2210 1
			if (!(phymode & htole32(PFF_OID_PHY_2400MHZ)))
d2212 1
a2212 1
			if (country == letoh32(PFF_COUNTRY_USA)) {
d2221 1
a2221 1
			if (!(phymode & htole32(PFF_OID_PHY_5000MHZ)))
d2236 1
a2236 3
	//mtx_lock(&sc->sc_lock);
	error = pgt_oid_get(sc, PFF_OID_SUPPORTED_RATES, rates, sizeof(rates));
	//mtx_unlock(&sc->sc_lock);
d2246 1
a2246 1
			if (phymode & htole32(PFF_OID_PHY_2400MHZ)) {
d2251 1
a2251 1
			if (phymode & htole32(PFF_OID_PHY_2400MHZ)) {
d2255 1
a2255 1
			if (phymode & htole32(PFF_OID_PHY_5000MHZ)) {
a2303 1
	//mtx_lock(&sc->sc_lock);
a2306 1
		//mtx_unlock(&sc->sc_lock);
a2309 1
	//mtx_unlock(&sc->sc_lock);
d2331 4
a2334 4
	for (; sc->sc_dirtyq_count[PFF_QUEUE_DATA_LOW_TX] <
	    //PFF_QUEUE_FULL_THRESHOLD && !IFQ_DRV_IS_EMPTY(&ifp->if_snd);) {
	    PFF_QUEUE_FULL_THRESHOLD;) {
		pd = TAILQ_FIRST(&sc->sc_freeq[PFF_QUEUE_DATA_LOW_TX]);
d2338 1
a2338 1
		if (m->m_pkthdr.len <= PFF_FRAG_SIZE) {
d2340 1
a2340 1
			    PFF_QUEUE_DATA_LOW_TX, pd);
d2346 1
a2346 1
			pgt_desc_transmit(sc, PFF_QUEUE_DATA_LOW_TX,
d2351 1
a2351 1
		} else if (m->m_pkthdr.len <= PFF_FRAG_SIZE * 2) {
d2360 2
a2361 2
			if (sc->sc_dirtyq_count[PFF_QUEUE_DATA_LOW_TX] + 2 >
			    PFF_QUEUE_FULL_THRESHOLD) {
d2367 1
a2367 1
			    PFF_QUEUE_DATA_LOW_TX, pd);
d2370 1
a2370 1
				    PFF_QUEUE_DATA_LOW_TX, pd2);
d2374 1
a2374 1
					    PFF_QUEUE_DATA_LOW_TX], pd,
d2382 7
a2388 7
			m_copydata(m, 0, PFF_FRAG_SIZE, pd->pd_mem);
			pgt_desc_transmit(sc, PFF_QUEUE_DATA_LOW_TX,
			    pd, PFF_FRAG_SIZE, 1);
			m_copydata(m, PFF_FRAG_SIZE,
			    m->m_pkthdr.len - PFF_FRAG_SIZE, pd2->pd_mem);
			pgt_desc_transmit(sc, PFF_QUEUE_DATA_LOW_TX,
			    pd2, m->m_pkthdr.len - PFF_FRAG_SIZE, 0);
d2420 1
a2420 1
				    htole32(PFF_IEEE80211_RADIOTAP_PRESENT);
a2466 1
		//mtx_lock(&sc->sc_lock);
a2474 1
		//mtx_unlock(&sc->sc_lock);
a2496 1
		//mtx_lock(&sc->sc_lock);
a2511 1
		//mtx_unlock(&sc->sc_lock);
d2514 1
a2514 1
		if (ifr->ifr_mtu > PFF_FRAG_SIZE) {
d2516 1
a2516 1
			    ifp->if_xname, PFF_FRAG_SIZE);
a2518 1
			//mtx_lock(&sc->sc_lock);
a2519 1
			//mtx_unlock(&sc->sc_lock);
a2524 1
		//mtx_lock(&sc->sc_lock);
a2532 1
		//mtx_unlock(&sc->sc_lock);
a2544 1
		//mtx_lock(&sc->sc_lock);
a2545 1
		//mtx_unlock(&sc->sc_lock);
d2598 1
a2598 1
	    PFF_OID_EAPAUTHSTA : PFF_OID_EAPUNAUTHSTA,
d2618 1
a2618 1
		pffmlme.pom_state = htole16(PFF_MLME_STATE_ASSOC);
d2620 1
a2620 1
		error = pgt_oid_set(sc, PFF_OID_ASSOCIATE,
d2641 1
a2641 1
	/* Would IEEE80211_MLME_ASSOC/PFF_MLME_STATE_ASSOC be used for WDS? */
a2747 1
			//mtx_lock(&sc->sc_lock);
a2751 1
			//mtx_unlock(&sc->sc_lock);
a2765 1
		//mtx_lock(&sc->sc_lock);
a2772 1
		//mtx_unlock(&sc->sc_lock);
a2785 1
		//mtx_lock(&sc->sc_lock);
a2791 1
		//mtx_unlock(&sc->sc_lock);
a2800 1
		//mtx_lock(&sc->sc_lock);
a2816 1
		//mtx_unlock(&sc->sc_lock);
d2849 1
a2849 1
		maxscan = PFF_OBJ_BSSLIST_NBSS;
a2851 1
		//mtx_lock(&sc->sc_lock);
d2853 1
a2853 1
		error = pgt_oid_get(sc, PFF_OID_NOISE_FLOOR, &noise,
d2857 1
a2857 1
			error = pgt_oid_get(sc, PFF_OID_BSS_LIST, pob,
d2862 1
a2862 1
			maxscan = min(PFF_OBJ_BSSLIST_NBSS,
a2880 1
		//mtx_unlock(&sc->sc_lock);
a2946 1
	//mtx_lock(&sc->sc_lock);
d2952 1
a2952 1
	if (sc->sc_dirtyq_count[PFF_QUEUE_DATA_LOW_TX] != 0) {
d2960 1
a2960 1
			count = pgt_drain_tx_queue(sc, PFF_QUEUE_DATA_LOW_TX);
d2966 1
a2966 2
	if (sc->sc_flags & (SC_DYING | SC_NEEDS_RESET)) {
		//mtx_unlock(&sc->sc_lock);
a2967 1
	}
a3000 1
	//mtx_unlock(&sc->sc_lock);
a3009 1
	//mtx_lock(&sc->sc_lock);
a3013 1
	//mtx_unlock(&sc->sc_lock);
d3040 1
a3040 1
	config = PFF_CONFIG_MANUAL_RUN | PFF_CONFIG_RX_ANNEX;
d3050 1
a3050 1
				mode = PFF_MODE_CLIENT;	/* what to do? */
d3052 3
a3054 3
				mode = PFF_MODE_CLIENT;
			bsstype = PFF_BSS_TYPE_STA;
			dot1x = PFF_DOT1X_AUTH_ENABLED;
d3058 1
a3058 1
				mode = PFF_MODE_CLIENT;	/* what to do? */
d3060 3
a3062 3
				mode = PFF_MODE_CLIENT;
			bsstype = PFF_BSS_TYPE_IBSS;
			dot1x = PFF_DOT1X_AUTH_ENABLED;
d3065 2
a3066 2
			mode = PFF_MODE_AP;
			bsstype = PFF_BSS_TYPE_STA;
d3074 1
a3074 1
			dot1x = PFF_DOT1X_AUTH_ENABLED;
d3083 1
a3083 1
				config |= PFF_CONFIG_WDS;
d3086 3
a3088 3
			mode = PFF_MODE_PROMISCUOUS;
			bsstype = PFF_BSS_TYPE_ANY;
			dot1x = PFF_DOT1X_AUTH_NONE;
d3095 2
a3096 2
		mode = PFF_MODE_CLIENT;
		bsstype = PFF_BSS_TYPE_NONE;
d3100 2
a3101 2
		profile = PFF_PROFILE_A_ONLY;
		preamble = PFF_OID_PREAMBLE_MODE_DYNAMIC;
d3104 2
a3105 2
		profile = PFF_PROFILE_B_ONLY;
		preamble = PFF_OID_PREAMBLE_MODE_LONG;
d3108 2
a3109 2
		profile = PFF_PROFILE_G_ONLY;
		preamble = PFF_OID_PREAMBLE_MODE_SHORT;
d3115 2
a3116 2
		profile = PFF_PROFILE_MIXED_G_WIFI;
		preamble = PFF_OID_PREAMBLE_MODE_DYNAMIC;
d3123 1
a3123 1
		auth = PFF_AUTH_MODE_NONE;
d3126 1
a3126 1
		auth = PFF_AUTH_MODE_OPEN;
d3129 1
a3129 1
		auth = PFF_AUTH_MODE_SHARED;
d3147 1
a3147 1
	mlme = htole32(PFF_MLME_AUTO_LEVEL_AUTO);
d3156 1
a3156 1
		dot1x = PFF_DOT1X_AUTH_NONE;
d3160 1
a3160 1
		slot = htole32(PFF_OID_SLOT_MODE_SHORT);
d3162 1
a3162 1
		slot = htole32(PFF_OID_SLOT_MODE_DYNAMIC);
d3183 3
a3185 3
		SETOID(PFF_OID_PROFILE, &profile, sizeof(profile));
		SETOID(PFF_OID_CONFIG, &config, sizeof(config));
		SETOID(PFF_OID_MLME_AUTO_LEVEL, &mlme, sizeof(mlme));
d3187 1
a3187 1
			SETOID(PFF_OID_MAC_ADDRESS, ac->ac_enaddr,
d3191 2
a3192 2
		SETOID(PFF_OID_MODE, &mode, sizeof(mode));
		SETOID(PFF_OID_BSS_TYPE, &bsstype, sizeof(bsstype));
d3194 1
a3194 1
			SETOID(PFF_OID_CHANNEL, &channel, sizeof(channel));
d3196 1
a3196 1
			SETOID(PFF_OID_BSSID, ic->ic_des_bssid,
d3199 1
a3199 1
			SETOID(PFF_OID_BSSID, ic->ic_bss->ni_bssid,
d3202 1
a3202 1
		SETOID(PFF_OID_SSID, &essid, sizeof(essid));
d3204 7
a3210 7
			SETOID(PFF_OID_SSID_OVERRIDE, &essid, sizeof(essid));
		SETOID(PFF_OID_RATES, &availrates, i);
		SETOID(PFF_OID_EXTENDED_RATES, &availrates, i);
		SETOID(PFF_OID_PREAMBLE_MODE, &preamble, sizeof(preamble));
		SETOID(PFF_OID_SLOT_MODE, &slot, sizeof(slot));
		SETOID(PFF_OID_AUTH_MODE, &auth, sizeof(auth));
		SETOID(PFF_OID_EXCLUDE_UNENCRYPTED, &exunencrypted,
d3212 2
a3213 2
		SETOID(PFF_OID_DOT1X, &dot1x, sizeof(dot1x));
		SETOID(PFF_OID_PRIVACY_INVOKED, &wep, sizeof(wep));
d3215 1
a3215 1
			keyobj.pok_type = PFF_OBJ_KEY_TYPE_WEP;
d3222 1
a3222 1
			SETOID(PFF_OID_DEFAULT_KEY0, &keyobj, sizeof(keyobj));
d3229 1
a3229 1
			SETOID(PFF_OID_DEFAULT_KEY1, &keyobj, sizeof(keyobj));
d3236 1
a3236 1
			SETOID(PFF_OID_DEFAULT_KEY2, &keyobj, sizeof(keyobj));
d3243 1
a3243 1
			SETOID(PFF_OID_DEFAULT_KEY3, &keyobj, sizeof(keyobj));
d3245 1
a3245 1
			SETOID(PFF_OID_DEFAULT_KEYNUM, &wepkey, sizeof(wepkey));
d3248 1
a3248 1
		SETOID(PFF_OID_MODE, &mode, sizeof(mode));
d3307 1
a3307 1
		    PFF_OID_EAPAUTHSTA : PFF_OID_EAPUNAUTHSTA,
d3338 1
a3338 1
	case PFF_OID_DISASSOCIATE:
d3342 1
a3342 1
	case PFF_OID_ASSOCIATE:
d3387 1
a3387 1
		case PFF_OID_LINK_STATE:
d3399 4
a3402 4
		case PFF_OID_DEAUTHENTICATE:
		case PFF_OID_AUTHENTICATE:
		case PFF_OID_DISASSOCIATE:
		case PFF_OID_ASSOCIATE:
d3425 1
a3425 1
		error = pgt_oid_get(sc, PFF_OID_LINK_STATE, &ls, sizeof(ls));
d3434 1
a3434 1
	if (pgt_oid_get(sc, PFF_OID_NOISE_FLOOR, &noise, sizeof(noise)) != 0)
d3438 1
a3438 1
		if (pgt_oid_get(sc, PFF_OID_CHANNEL, &channel,
d3443 1
a3443 1
		if (pgt_oid_get(sc, PFF_OID_BSSID, ic->ic_bss->ni_bssid,
d3447 1
a3447 1
		error = pgt_oid_retrieve(sc, PFF_OID_BSS_FIND, &bss,
d3453 1
a3453 1
		error = pgt_oid_get(sc, PFF_OID_SSID, &ssid, sizeof(ssid));
a3472 1
		//mtx_lock(&sc->sc_lock);
a3473 1
		//mtx_unlock(&sc->sc_lock);
a3489 1
	//alreadylocked = mtx_owned(&sc->sc_lock);
a3492 1
		//mtx_lock(&sc->sc_lock);
d3495 1
a3495 1
	if (pgt_oid_get(sc, PFF_OID_LINK_STATE, &ls, sizeof(ls)) != 0) {
a3530 1
		//mtx_unlock(&sc->sc_lock);
d3550 1
a3550 1
		if (sc->sc_dirtyq_count[PFF_QUEUE_DATA_LOW_TX] == 0)
d3639 1
a3639 1
	for (i = 0; i < PFF_QUEUE_COUNT; i++)
d3682 1
a3682 1
	size = PFF_FRAG_SIZE * PFF_PSM_BUFFER_FRAME_COUNT;
d3719 1
a3719 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_DATA_LOW_RX);
d3723 1
a3723 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_DATA_LOW_TX);
d3727 1
a3727 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_DATA_HIGH_RX);
d3731 1
a3731 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_DATA_HIGH_TX);
d3735 1
a3735 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_MGMT_RX);
d3739 1
a3739 1
	error = pgt_dma_alloc_queue(sc, PFF_QUEUE_MGMT_TX);
d3761 1
a3761 1
		case PFF_QUEUE_DATA_LOW_RX:
d3763 1
a3763 1
			qsize = PFF_QUEUE_DATA_RX_SIZE;
d3765 1
a3765 1
		case PFF_QUEUE_DATA_LOW_TX:
d3767 1
a3767 1
			qsize = PFF_QUEUE_DATA_TX_SIZE;
d3769 1
a3769 1
		case PFF_QUEUE_DATA_HIGH_RX:
d3771 1
a3771 1
			qsize = PFF_QUEUE_DATA_RX_SIZE;
d3773 1
a3773 1
		case PFF_QUEUE_DATA_HIGH_TX:
d3775 1
a3775 1
			qsize = PFF_QUEUE_DATA_TX_SIZE;
d3777 1
a3777 1
		case PFF_QUEUE_MGMT_RX:
d3779 1
a3779 1
			qsize = PFF_QUEUE_MGMT_SIZE;
d3781 1
a3781 1
		case PFF_QUEUE_MGMT_TX:
d3783 1
a3783 1
			qsize = PFF_QUEUE_MGMT_SIZE;
d3790 2
a3791 2
		error = bus_dmamap_create(sc->sc_dmat, PFF_FRAG_SIZE, 1,
		    PFF_FRAG_SIZE, 0, BUS_DMA_ALLOCNOW, &pd->pd_dmam);
d3798 1
a3798 1
		error = bus_dmamem_alloc(sc->sc_dmat, PFF_FRAG_SIZE, PAGE_SIZE,
d3808 1
a3808 1
		    PFF_FRAG_SIZE, (caddr_t *)&pd->pd_mem, BUS_DMA_WAITOK);
d3818 1
a3818 1
			    pd->pd_mem, PFF_FRAG_SIZE, NULL, BUS_DMA_WAITOK);
d3841 6
a3846 6
		pgt_dma_free_queue(sc, PFF_QUEUE_DATA_LOW_RX);
		pgt_dma_free_queue(sc, PFF_QUEUE_DATA_LOW_TX);
		pgt_dma_free_queue(sc, PFF_QUEUE_DATA_HIGH_RX);
		pgt_dma_free_queue(sc, PFF_QUEUE_DATA_HIGH_TX);
		pgt_dma_free_queue(sc, PFF_QUEUE_MGMT_RX);
		pgt_dma_free_queue(sc, PFF_QUEUE_MGMT_TX);
@


1.6
log
@Do proper chipset identification.

ok deraadt@@
@
text
@d245 1
a245 1
uint32_t
d829 1
a829 1
	//(void)msleep(&sc->sc_flags, &sc->sc_lock, PZERO, "pffres", hz);
a839 2
	return (0);

d843 3
d1540 1
a1540 1
pgt_intr(void *argp)
d1542 1
a1543 1
	struct pgt_softc *sc;
d1546 2
a1547 1
	return (0);
a1548 2
	ifp = argp;
	sc = ifp->if_softc;
d1585 1
a1585 1
	uint32_t reg;
@


1.5
log
@Get firmware loaded.

ok deraadt@@
@
text
@a235 2

	DPRINTF(("%s: attach ok\n", sc->sc_dev.dv_xname));
d411 2
a412 2
	if (sc->sc_dev_type == PFF_DEV_ISL3877)
		name = "isl3877";
d414 1
a414 3
		name = "isl3890";	/* includes isl3880 */

	name = "pgt-isl3890";
d461 2
a462 2
	DPRINTF(("%s: %d bytes of firmware microcode loaded\n",
	    sc->sc_dev.dv_xname, fwoff));
@


1.4
log
@Port bus_dmamap_load(9) and bus_dmamap_sync(9).
@
text
@d77 8
d135 1
a135 1
int	 pgt_upload_firmware(struct pgt_softc *);
d140 1
d142 1
d226 15
d405 1
a405 1
pgt_upload_firmware(struct pgt_softc *sc)
d407 1
a407 1
	uint32_t dirreg, reg, fwoff;
d409 1
a409 1
	int fwlen, error;
d418 2
d437 3
a440 1
	fwoff = 0;
d442 1
a442 1
		u_int32_t *uc = (u_int32_t *)ucode;
d444 1
a444 2
		pgt_write_4_flush(sc, PFF_REG_DIR_MEM_BASE, reg);
		if (size - fwoff >= PFF_DIRECT_MEMORY_SIZE)
d448 1
d451 1
a451 1
			pgt_write_4(sc, dirreg, uc[fwoff]);
d456 1
d458 1
a458 1
		pgt_write_4_flush(sc, dirreg, uc[fwoff]);
d463 1
d465 2
d474 1
d479 1
d519 1
a519 1
 * Turn off interrupts, reset the device (possibly uploading firmware),
d530 1
d553 2
d556 4
a559 2
		error = pgt_upload_firmware(sc);
		if (error)
d561 1
d563 1
d565 1
d567 4
a570 3
	pgt_write_4_flush(sc, PFF_REG_CTRL_BLK_BASE,
	    htole32((uint32_t)sc->sc_cbdmabusaddr));
	DELAY(PFF_WRITEIO_DELAY);
d574 1
d578 1
d755 1
d760 1
a760 1
		//mtx_lock(&sc->sc_lock);
d762 3
a764 3
		//cv_signal(&sc->sc_kthread.sck_needed);
		//msleep(sc->sc_kthread.sck_proc, &sc->sc_lock, PPAUSE | PDROP,
		//    "pffktc", 0);
d767 1
a777 2
	return (0);

d827 1
d829 13
a841 13
	if (error == 0) {
		sc->sc_refcnt++;
		//(void)msleep(&sc->sc_flags, &sc->sc_lock, PZERO, "pffres", hz);
		sc->sc_refcnt--;
		if (sc->sc_flags & SC_UNINITIALIZED) {
			printf("%s: not responding\n", sc->sc_dev.dv_xname);
			error = ETIMEDOUT;
		} else {
			/* await all interrupts */
			pgt_write_4_flush(sc, PFF_REG_INT_EN,
			    PFF_INT_STAT_SOURCES);	
			DELAY(PFF_WRITEIO_DELAY);
		}
d843 3
d856 1
a856 1
		pgt_kill_kthread(sc);
d861 1
d874 1
a874 1
	pgt_kill_kthread(sc);
d892 1
d897 1
d1153 1
d1572 1
d1580 1
a1580 1
//		pgt_start(ifp);
d1647 3
a1649 3
	if (reg & ~PFF_INT_STAT_SOURCES && sc->sc_debug & SC_DEBUG_UNEXPECTED)
		printf("%s: unknown interrupt bits %#x "
		    "(stat %#x)\n", sc->sc_dev.dv_xname,
d1652 1
@


1.3
log
@Move DMA mapping code from if_pgt_pci.c to pgt.c and port it as is for now.
Remove dead code chunk from if_pgt_pci.c.

For those who want to refer to the original code you can find it in
~mglocker/pgt/orig.
@
text
@a83 10
 * The definitions for this API are _terrible_!
 */
#ifndef BUS_DMASYNC_PREDMA2CPU
#define	BUS_DMASYNC_PREDMA2CPU		BUS_DMASYNC_PREREAD
#define	BUS_DMASYNC_POSTDMA2CPU		BUS_DMASYNC_POSTREAD
#define	BUS_DMASYNC_PRECPU2DMA		BUS_DMASYNC_PREWRITE
#define	BUS_DMASYNC_POSTCPU2DMA		BUS_DMASYNC_POSTWRITE
#endif

/*
d274 3
a276 2
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, 0, BUS_DMASYNC_POSTCPU2DMA);
a284 3
	/* XXX */
        //error = bus_dmamap_load(sc->sc_dmat, pd->pd_dmam, pd->pd_mem,
        //    PFF_FRAG_SIZE, pgt_load_busaddr, &pd->pd_dmaaddr, 0);
d296 4
a299 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA);
d499 3
a501 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU | BUS_DMASYNC_PRECPU2DMA);
d514 3
a516 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA | BUS_DMASYNC_PREDMA2CPU);
d882 3
a884 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU | BUS_DMASYNC_PRECPU2DMA);
d995 3
a997 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA | BUS_DMASYNC_PREDMA2CPU);
d1288 3
a1290 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU);
d1318 3
a1320 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU);
d1609 3
a1611 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU);
d1644 3
a1646 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU);
d2075 3
a2077 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU | BUS_DMASYNC_PRECPU2DMA);
d2081 3
a2083 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, pd->pd_dmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA);
d2086 3
a2088 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA | BUS_DMASYNC_PREDMA2CPU);
d3682 3
a3684 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTDMA2CPU | BUS_DMASYNC_PRECPU2DMA);
d3687 3
a3689 3
	/* XXX */
	bus_dmamap_sync(sc->sc_dmat, sc->sc_cbdmam, 0, 0,
	    BUS_DMASYNC_POSTCPU2DMA | BUS_DMASYNC_PREDMA2CPU);
@


1.2
log
@Add some first PCI glue.
@
text
@d220 4
d285 1
a285 1
	bus_dmamap_sync(sc->sc_fragdmat, pd->pd_dmam, 0, 0, BUS_DMASYNC_POSTCPU2DMA);
d295 1
a295 1
        //error = bus_dmamap_load(sc->sc_fragdmat, pd->pd_dmam, pd->pd_mem,
d297 1
a297 1
	error = bus_dmamap_load(sc->sc_fragdmat, pd->pd_dmam, pd->pd_mem,
d309 1
a309 1
	bus_dmamap_sync(sc->sc_fragdmat, pd->pd_dmam, 0, 0,
d317 1
a317 1
        bus_dmamap_unload(sc->sc_fragdmat, pd->pd_dmam);
d511 1
a511 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d526 1
a526 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d737 4
d894 1
a894 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d1007 1
a1007 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d1300 1
a1300 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d1330 1
a1330 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d1621 1
a1621 1
	bus_dmamap_sync(sc->sc_fragdmat, pd->pd_dmam, 0, 0,
d1656 1
a1656 1
	bus_dmamap_sync(sc->sc_fragdmat, pd->pd_dmam, 0, 0,
d2087 1
a2087 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d2093 1
a2093 1
	bus_dmamap_sync(sc->sc_fragdmat, pd->pd_dmam, 0, 0,
d2098 1
a2098 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d3694 1
a3694 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d3699 1
a3699 1
	bus_dmamap_sync(sc->sc_cbdmat, sc->sc_cbdmam, 0, 0,
d3720 254
@


1.1
log
@Very initial import to support the PrismGT chipset (FullMAC for now).

ok deraadt@@
@
text
@a158 1
void	 pgt_intr(void *);
d733 2
d820 2
d830 1
d1491 1
a1491 1
void
d1498 2
d1529 2
@

