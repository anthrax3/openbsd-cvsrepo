head	1.58;
access;
symbols
	OPENBSD_6_1:1.58.0.26
	OPENBSD_6_1_BASE:1.58
	OPENBSD_6_0:1.58.0.28
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.58.0.22
	OPENBSD_5_9_BASE:1.58
	OPENBSD_5_8:1.58.0.24
	OPENBSD_5_8_BASE:1.58
	OPENBSD_5_7:1.58.0.16
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.58.0.20
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.58.0.18
	OPENBSD_5_5_BASE:1.58
	OPENBSD_5_4:1.58.0.14
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.58.0.12
	OPENBSD_5_3_BASE:1.58
	OPENBSD_5_2:1.58.0.8
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.10
	OPENBSD_5_0:1.58.0.6
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.58.0.4
	OPENBSD_4_9_BASE:1.58
	OPENBSD_4_8:1.58.0.2
	OPENBSD_4_8_BASE:1.58
	OPENBSD_4_7:1.54.0.4
	OPENBSD_4_7_BASE:1.54
	OPENBSD_4_6:1.54.0.6
	OPENBSD_4_6_BASE:1.54
	OPENBSD_4_5:1.54.0.2
	OPENBSD_4_5_BASE:1.54
	OPENBSD_4_4:1.53.0.2
	OPENBSD_4_4_BASE:1.53
	OPENBSD_4_3:1.52.0.4
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.52.0.2
	OPENBSD_4_2_BASE:1.52
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.49.0.2
	OPENBSD_4_0_BASE:1.49
	OPENBSD_3_9:1.37.0.2
	OPENBSD_3_9_BASE:1.37
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.6
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.4
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.2
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.5
	OPENBSD_3_3:1.5.0.6
	OPENBSD_3_3_BASE:1.5
	OPENBSD_3_2:1.5.0.4
	OPENBSD_3_2_BASE:1.5
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.5
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.58
date	2010.06.23.04.53.53;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2010.06.23.03.46.25;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2010.06.21.11.43.38;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2010.06.04.06.52.58;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2008.10.28.11.43.10;	author marco;	state Exp;
branches;
next	1.53;

1.53
date	2008.04.10.06.39.00;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2007.01.27.05.09.51;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.28.08.26.00;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2006.05.21.18.28.24;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2006.04.20.13.02.26;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2006.04.20.04.39.11;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.18.04.15.44;	author marco;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.29.13.38.05;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2006.03.20.10.49.53;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2006.03.20.10.10.59;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.20.09.59.26;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.19.11.53.23;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.17.13.34.23;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.17.10.49.12;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2005.12.13.12.13.59;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2005.12.12.09.39.29;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2005.12.10.12.03.24;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.26.05.49.47;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.23.21.36.19;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2005.10.02.06.30.50;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.30.09.07.01;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2005.09.30.07.53.03;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2005.09.26.21.33.02;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2005.09.25.04.48.51;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2005.09.22.07.37.32;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2005.09.21.10.36.14;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.21.08.52.44;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2005.09.21.08.33.04;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2005.09.19.07.45.28;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.31.17.59.09;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.31.12.52.36;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.30.02.40.26;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.15.23.22.46;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.08.20.23.46;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.08.03.11.36;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.05.04.16.51;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2005.07.29.16.01.30;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2005.07.18.15.10.57;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.18.01.29.01;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2005.06.28.18.33.11;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.27.20.39.30;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.09.19.50.48;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.29.22.40.38;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.26.00.11.24;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.02.19.24.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.12.14.52.52;	author mickey;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.04.30.15.45.05;	author mickey;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.04.30.15.43.10;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2001.03.09.11.14.22;	author mickey;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.23.29;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.40.35;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	;

1.4.2.1
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	;


desc
@@


1.58
log
@cut ami over to iopools.

makes the ioctl and sensor paths more reliably now that they cant fail
due to a ccb allocation failure, and allows better sharing of resources
between multiple logical volumes and physical devices.
@
text
@/*	$OpenBSD: amivar.h,v 1.57 2010/06/23 03:46:25 dlg Exp $	*/

/*
 * Copyright (c) 2001 Michael Shalayeff
 * Copyright (c) 2005 Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

struct ami_mem {
	bus_dmamap_t		am_map;
	bus_dma_segment_t	am_seg;
	size_t			am_size;
	caddr_t			am_kva;
};

#define AMIMEM_MAP(_am)		((_am)->am_map)
#define AMIMEM_DVA(_am)		((_am)->am_map->dm_segs[0].ds_addr)
#define AMIMEM_KVA(_am)		((void *)(_am)->am_kva)

struct ami_ccbmem {
	struct ami_passthrough	cd_pt;
	struct ami_sgent	cd_sg[AMI_SGEPERCMD];
};

struct ami_softc;

struct ami_ccb {
	struct ami_softc	*ccb_sc;

	struct ami_iocmd	ccb_cmd;
	struct ami_passthrough	*ccb_pt;
	paddr_t			ccb_ptpa;
	struct ami_sgent	*ccb_sglist;
	paddr_t			ccb_sglistpa;
	int			ccb_offset;
	bus_dmamap_t		ccb_dmamap;

	struct scsi_xfer	*ccb_xs;
	void			(*ccb_done)(struct ami_softc *sc,
				    struct ami_ccb *ccb);

	volatile enum {
		AMI_CCB_FREE,
		AMI_CCB_READY,
		AMI_CCB_QUEUED,
		AMI_CCB_PREQUEUED
	}			ccb_state;
	int			ccb_flags;
#define AMI_CCB_F_ERR			(1<<0)
	int			ccb_status;
	TAILQ_ENTRY(ami_ccb)	ccb_link;
};

TAILQ_HEAD(ami_ccb_list, ami_ccb);

struct ami_rawsoftc {
	struct scsi_link	sc_link;
	struct ami_softc	*sc_softc;
	u_int8_t		sc_channel;

	int			sc_proctarget;	/* ses/safte target id */
	char			sc_procdev[16];	/* ses/safte device */
};

struct ami_softc {
	struct device		sc_dev;
	void			*sc_ih;
	struct scsi_link	sc_link;

	int			sc_flags;
#define AMI_CHECK_SIGN	0x0001
#define AMI_BROKEN 	0x0002
#define AMI_QUARTZ	0x0008

	/* low-level interface */
	int			(*sc_init)(struct ami_softc *sc);
	int			(*sc_exec)(struct ami_softc *sc,
				    struct ami_iocmd *);
	int			(*sc_done)(struct ami_softc *sc,
				    struct ami_iocmd *);
	int			(*sc_poll)(struct ami_softc *sc,
				    struct ami_iocmd *);
	int			(*sc_ioctl)(struct device *, u_long, caddr_t);

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;

	struct ami_ccb		*sc_ccbs;
	struct ami_ccb_list	sc_ccb_freeq;
	struct mutex		sc_ccb_freeq_mtx;

	struct ami_mem		*sc_mbox_am;
	volatile struct ami_iocmd *sc_mbox;
	paddr_t			sc_mbox_pa;

	struct ami_ccb_list	sc_ccb_preq, sc_ccb_runq;
	struct mutex		sc_cmd_mtx;

	struct scsi_iopool	sc_iopool;

	struct ami_mem		*sc_ccbmem_am;

	int			sc_timeout;
	struct timeout		sc_run_tmo;
	int			sc_dis_poll;

	struct rwlock		sc_lock;

	char			sc_fwver[16];
	char			sc_biosver[16];
	int			sc_maxcmds;
	int			sc_memory;
	int			sc_targets;
	int			sc_channels;
	int			sc_maxunits;
	int			sc_nunits;
	struct {
		u_int8_t		hd_present;
		u_int8_t		hd_is_logdrv;
		u_int8_t		hd_prop;
		u_int8_t		hd_stat;
		u_int32_t		hd_size;
		char			dev[16];
	}			sc_hdr[AMI_BIG_MAX_LDRIVES];
	struct ami_rawsoftc	*sc_rawsoftcs;

	struct ksensor		*sc_sensors;
	struct ksensordev	sc_sensordev;
	struct ami_big_diskarray *sc_bd;

	/* bio stuff */
	struct bioc_inq		sc_bi;
	char			sc_plist[AMI_BIG_MAX_PDRIVES];

	struct ami_ccb		*sc_mgmtccb;
	int			sc_drainio;
	u_int8_t		sc_drvinscnt;
};

int  ami_attach(struct ami_softc *sc);
int  ami_intr(void *);

int ami_quartz_init(struct ami_softc *sc);
int ami_quartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_quartz_done(struct ami_softc *sc, struct ami_iocmd *);
int ami_quartz_poll(struct ami_softc *sc, struct ami_iocmd *);

int ami_schwartz_init(struct ami_softc *sc);
int ami_schwartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_schwartz_done(struct ami_softc *sc, struct ami_iocmd *);
int ami_schwartz_poll(struct ami_softc *sc, struct ami_iocmd *);

#ifdef AMI_DEBUG
void ami_print_mbox(struct ami_iocmd *);
#endif /* AMI_DEBUG */
@


1.57
log
@switch ami over to using mutexes instead of splbio to protect itself. this
protects the ccb runqueues and the mailbox with a single mutex.

the biggest change as a consequence of this is a rewrite of the polled
command code. it now forces the polled command onto the chip ahead of the
pending runqueue, and simply runs the interrupt handler until the ccb
completes.

tested by sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.56 2010/06/21 11:43:38 dlg Exp $	*/
d120 2
@


1.56
log
@protect the ccb free list with its own mutex.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.55 2010/06/04 06:52:58 dlg Exp $	*/
d110 4
a117 3
	struct ami_ccb		*sc_ccbs;
	struct ami_ccb_list	sc_ccb_freeq;
	struct mutex		sc_ccb_freeq_mtx;
d119 1
@


1.55
log
@gc unused variable
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.54 2008/10/28 11:43:10 marco Exp $	*/
d115 3
a117 1
	struct ami_ccb_list	sc_ccb_freeq, sc_ccb_preq, sc_ccb_runq;
@


1.54
log
@Major overhaul of bio.
Fix set hotspare that didn't always work.
Fix several very subtle bugs because of firmware lies
Fix disk size that sometimes was incorrect
Only poke drives if something changed so it makes bio way faster on subsequent calls

Tested by several folks, thanks
Ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.53 2008/04/10 06:39:00 dlg Exp $	*/
a151 1
	int			sc_drained;
@


1.53
log
@the success of a command is reported in the mbox, but not passed on to the
completion routines to do anything useful with.

this stashes the commands status in the ccb for the ccb_done handlers to
use. the completion path for passthru commands now checks the mbox status
to see if the command actually works. this prevents phantom devices from
appearing on the passthru busses.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.51 2007/01/27 05:09:51 dlg Exp $	*/
a29 2
#include <sys/sensors.h>

d146 9
@


1.52
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d73 1
@


1.51
log
@convert to our locks to rwlocks.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.50 2006/12/23 17:46:39 deraadt Exp $	*/
d144 2
a145 2
	struct sensor		*sc_sensors;
	struct sensordev	sc_sensordev;
@


1.50
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.49 2006/06/28 08:26:00 dlg Exp $	*/
d124 1
a124 1
	struct lock		sc_lock;
@


1.49
log
@rewrite how the sensors are created. previously they would wait for io to
be done on the logical disks so ami_scsi_cmd can stash the name of the
device doing the io. we now walk the device tree after the logical disks
are attached and use the names of ami's child devices.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.48 2006/05/21 18:28:24 dlg Exp $	*/
d30 2
d145 1
@


1.48
log
@the maximum possible number of ccbs that a megaraid can use (126 of them)
is preallocated in the softc, even if the driver is only ever going to use
one of them when running. this allocates them separately during attach as a
first step toward having the driver only allocate as many ccbs as the
firmware can support.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.47 2006/04/20 13:02:26 dlg Exp $	*/
d142 1
a142 2
	int			sc_first_poll;
	struct sensor		*sc_sens_ld;
@


1.47
log
@get rid of the ccb list typedef. while here switch to TAILQ_HEAD instead
of TAILQ_TAIL when pulling ccbs off the free list since it does less
"interesting" things with pointers. changes prompted by lint bitching.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.46 2006/04/20 04:39:11 dlg Exp $	*/
d113 1
a113 1
	struct ami_ccb		sc_ccbs[AMI_MAXCMDS];
@


1.46
log
@this is the proper fix for krws bug. i feel kinda bad taking the commit
from him since he did most of the hard work on it.

when marco added the sensor for logical disks he added some extra bits
to the softc, but inside an #if NBIO > 0 block. NBIO is set by "bio.h"
which was included in ami.c, but not in ami_pci.c which is what is
actually responsible for getting the softc allocated. because of this
the softc in the rest of the system was smaller than what ami.c needed,
so technically it was using unallocated memory. in krws case that
unallocated space was filled with garbage, hence his panic.

the moral of this story is do NOT put #if inside structs that are passed
between different source files. its too easy to have this kind of screwup
happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.45 2006/04/18 04:15:44 marco Exp $	*/
d74 1
a74 1
typedef TAILQ_HEAD(ami_queue_head, ami_ccb)	ami_queue_head;
d114 1
a114 1
	ami_queue_head		sc_ccb_freeq, sc_ccb_preq, sc_ccb_runq;
@


1.45
log
@Display logical disk status in sysctl.  Now one can use sensorsd to
monitor disks on ami.
Ex.: hw.sensors.0=sd2, logical disk, WARNING, drive, degraded

Requested deraadt@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.44 2006/03/29 13:38:05 dlg Exp $	*/
d141 1
a141 1
#if NBIO > 0
a144 1
#endif /* NBIO > 0 */
@


1.44
log
@we never use what the ccb completion functions return, so make them all
return void instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.43 2006/03/20 10:49:53 dlg Exp $	*/
d141 5
@


1.43
log
@finer grained use of splbio in the ioctl paths. only use it when dealing
with the ccb queues rather than over the whole ioctl.

also get rid of the CMD_WAIT flag which is used to restrict the ioctl to
only one caller at a time. this is actually protecting from overuse of
ccbs for management tasks (like bioctl) by making sure the scsi paths
will always have their ccbs. replace the flag with a real lock so that
callers can sleep till the mgmt ccb is free, rather than returning EBUSY
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.42 2006/03/20 10:10:59 dlg Exp $	*/
d60 1
a60 1
	int			(*ccb_done)(struct ami_softc *sc,
@


1.42
log
@shrink the ccb even more. instead of having a "wakeup" member to say when
the ioctl paths can wake up, check the state of the ccb instead. when the
ccb becomes READY again then the command has completed.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.41 2006/03/20 09:59:26 dlg Exp $	*/
a92 1
#define	AMI_CMDWAIT	0x0004
d121 2
@


1.41
log
@remove the bits in the ccb for generalised handling of dmaable memory.

now that each code path that puts commands on the hardware has specific
completion routines, we dont have to deal with the memory magic in a
generic fashion.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.40 2006/03/19 11:53:23 dlg Exp $	*/
d63 1
a63 3
	volatile int		ccb_wakeup;

	enum {
@


1.40
log
@this is a really large reworking of how ami works in terms of submitting
commands to the hardware and completing them.

previously the driver was very engineered toward moving io from the
logical disks scsi commands onto the hardware and off. as we built extra
functionality into the driver, this path grew more and more hairy as bits
were tacked on to cope.

this strips it back to dealing with getting the command onto the hardware
and off again. each path that submits commands now has to do all its work
before submitting the ccb, and supply a function for completing the ccb.
both the async and polled paths call the completion routines for commands
now. async commands that fail to get onto the hardware first go are stuck
on a queue and retried out of a timeout. previously this was only done for
scsi commands, now all paths take advantage of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.39 2006/03/17 13:34:23 dlg Exp $	*/
d57 1
a59 8

	void			*ccb_data;
	int			ccb_len;
	enum {
		AMI_CCB_IN,
		AMI_CCB_OUT
	}			ccb_dir;
	bus_dmamap_t		ccb_dmamap;
@


1.39
log
@split the completion path up. its now the responsibility of the the path
that sets the command up to say how its should be completed. this means
we dont have to complicate a generic handler to cope with all the different
setup paths. however, at the moment we're using the generic complicated
one :)
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.38 2006/03/17 10:49:12 dlg Exp $	*/
d78 2
d124 1
a124 1
	ami_queue_head		sc_free_ccb, sc_ccbq, sc_ccbdone;
d129 1
a129 1
	struct timeout		sc_requeue_tmo;
@


1.38
log
@remove the last remnants of AMI_POLLING
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.37 2005/12/13 12:13:59 dlg Exp $	*/
d67 2
@


1.37
log
@use consistent naming for members of the softc struct
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.36 2005/12/12 09:39:29 dlg Exp $	*/
a125 1
	struct timeout		sc_poll_tmo;
@


1.36
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.35 2005/12/10 12:03:24 dlg Exp $	*/
d111 3
a113 3
	bus_space_tag_t		iot;
	bus_space_handle_t	ioh;
	bus_dma_tag_t		dmat;
@


1.35
log
@another go at cleaning up bus_dma usage.

when you're using the bus dma api like we are, there are two
bus_dma_segment_t's involved, one for the pa stuff and one for the dva
stuff. we set this up ok in ami_allocmem, but then we forget half of it
when we return from that function. even worse, we assume theyre the same
thing in ami_freemem.

this diff fixes that by wrapping all the dma bits into a struct (called
struct ami_mem) and providing a few macros for accessing the useful parts
of it. we just pass this struct around now instead of having to handle all
the busdma bits in every function.

ok marco@@ jason@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.34 2005/11/26 05:49:47 marco Exp $	*/
d95 2
a96 1
/* don't use 0x0001 */
a99 1
	u_int			sc_flags;
@


1.34
log
@Move bus_dma from pa to dva.  I wrote the initial diff with an ok from dlg@@

krw@@ removed all seg references and cleaned up htole32 a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.33 2005/11/23 21:36:19 dlg Exp $	*/
d30 11
d115 1
a117 1
	bus_dmamap_t		sc_mbox_map;
d122 1
a122 2
	struct ami_ccbmem	*sc_ccbmem;
	bus_dmamap_t		sc_ccbmap;
@


1.33
log
@make this easier for me to read by changing the locking to use the bare
spl calls rather than ami's macro wrappers for them.

ok krw@@ marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.32 2005/10/02 06:30:50 dlg Exp $	*/
a106 1
	bus_dma_segment_t	sc_mbox_seg[1];
a112 1
	bus_dma_segment_t	sc_ccbseg[1];
@


1.32
log
@replace the two separate dmamem allocations for the passthrough commands
and the scatter gather lists with a single allocation containing both.
more importantly, actually sync the appropriate parts of this allocation
when giving the commands to or taking the response from the device.

tested by and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.31 2005/09/30 09:07:01 dlg Exp $	*/
a138 5

/* XXX These have to become spinlocks in case of SMP */
#define AMI_LOCK_AMI(sc) splbio()
#define AMI_UNLOCK_AMI(sc, lock) splx(lock)
typedef int ami_lock_t;
@


1.31
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.30 2005/09/30 07:53:03 dlg Exp $	*/
d30 5
d39 1
d45 2
d48 2
a49 5
	volatile int		ccb_wakeup;
	TAILQ_ENTRY(ami_ccb)	ccb_link;
	enum {
		AMI_CCB_FREE, AMI_CCB_READY, AMI_CCB_QUEUED, AMI_CCB_PREQUEUED
	} ccb_state;
d52 2
a53 1
		AMI_CCB_IN, AMI_CCB_OUT
a54 1
	void			*ccb_data;
d56 10
d112 3
a114 7
	struct ami_passthrough	*sc_pts;
	bus_dmamap_t		sc_ptmap;
	bus_dma_segment_t	sc_ptseg[1];

	struct ami_sgent	*sc_sgents;
	bus_dmamap_t		sc_sgmap;
	bus_dma_segment_t	sc_sgseg[1];
@


1.30
log
@remove the dmamap used for iocmds since they were only copied into the
mbox, no dma was ever performed on them. store them in the ccb instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.29 2005/09/26 21:33:02 dlg Exp $	*/
d56 3
a58 3
	struct scsi_link sc_link;
	struct ami_softc *sc_softc;
	u_int8_t	sc_channel;
d60 2
a61 2
	int		sc_proctarget;	/* ses/safte target id */
	char		sc_procdev[16];	/* ses/safte device */
d65 3
a67 3
	struct device	sc_dev;
	void		*sc_ih;
	struct scsi_link sc_link;
d73 1
a73 1
	u_int	sc_flags;
d76 12
a87 9
	int (*sc_init)(struct ami_softc *sc);
	int (*sc_exec)(struct ami_softc *sc, struct ami_iocmd *);
	int (*sc_done)(struct ami_softc *sc, struct ami_iocmd *);
	int (*sc_poll)(struct ami_softc *sc, struct ami_iocmd *);
	int (*sc_ioctl)(struct device *, u_long, caddr_t);

	bus_space_tag_t	iot;
	bus_space_handle_t ioh;
	bus_dma_tag_t	dmat;
d90 28
a117 28
	paddr_t		sc_mbox_pa;
	bus_dmamap_t	sc_mbox_map;
	bus_dma_segment_t sc_mbox_seg[1];

	struct ami_ccb	sc_ccbs[AMI_MAXCMDS];
	ami_queue_head	sc_free_ccb, sc_ccbq, sc_ccbdone;

	struct ami_passthrough *sc_pts;
	bus_dmamap_t	sc_ptmap;
	bus_dma_segment_t sc_ptseg[1];

	struct ami_sgent *sc_sgents;
	bus_dmamap_t	sc_sgmap;
	bus_dma_segment_t sc_sgseg[1];

	int		sc_timeout;
	struct timeout	sc_requeue_tmo;
	struct timeout	sc_poll_tmo;
	int		sc_dis_poll;

	char	sc_fwver[16];
	char	sc_biosver[16];
	int	sc_maxcmds;
	int	sc_memory;
	int	sc_targets;
	int	sc_channels;
	int	sc_maxunits;
	int	sc_nunits;
d119 8
a126 8
		u_int8_t	hd_present;
		u_int8_t	hd_is_logdrv;
		u_int8_t	hd_prop;
		u_int8_t	hd_stat;
		u_int32_t	hd_size;
		char		dev[16];
	} sc_hdr[AMI_BIG_MAX_LDRIVES];
	struct ami_rawsoftc *sc_rawsoftcs;
@


1.29
log
@allocate and map the mbox separately to the iocmds used by the ccbs.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.28 2005/09/25 04:48:51 dlg Exp $	*/
d34 1
a34 2
	struct ami_iocmd	*ccb_cmd;
	paddr_t			ccb_cmdpa;
d94 1
a94 5
	void		*sc_cmds;
	bus_dmamap_t	sc_cmdmap;
	bus_dma_segment_t sc_cmdseg[1];

	void		*sc_pts;
d98 1
a98 1
	void		*sc_sgents;
@


1.28
log
@1.82 again; dont use the scsi xfer to decide if we should dma_sync.
instead use generic variables in the ccb so commands not originating from
the scsi layer can be handled by ami_done as well.

this version does not freeze like 1.82. the secret seems to be to go
ami_put_ccb before scsi_done.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.27 2005/09/22 07:37:32 dlg Exp $	*/
d89 3
@


1.27
log
@revert 1.82 and 1.83 of ami.c and 1.26 of amivar.h since it seems to be
causing random lockups on my machine. sigh.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.25 2005/09/21 08:52:44 dlg Exp $	*/
d47 3
@


1.26
log
@dont use the scsi xfer in ami_done to figure out if we have to sync a
buffer or not. this will allow us to issue arbitrary passthrough commands
without needing them to come in via ami_scsi_raw_cmd. useful for management
functionality...
@
text
@d46 1
a47 4
	int			ccb_len;
	enum {
		AMI_CCB_IN, AMI_CCB_OUT
	}			ccb_dir;
@


1.25
log
@remove the bits in the ccb that were needed to support scsi commands on
the passthrough bus when bounce buffers were used.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.24 2005/09/21 08:33:04 dlg Exp $	*/
d46 1
d48 3
a50 1
	void			*ccb_data;
@


1.24
log
@allocate space in each ccb to store a passthrough command
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.23 2005/09/19 07:45:28 dlg Exp $	*/
a40 6
	struct {
		void *idata;
		int dir;
#define AMI_PT_IN	(0x00)
#define AMI_PT_OUT	(0x01)
	} ami_pt;
@


1.23
log
@replace the pointer mess used to handle wakeups on ccbs with a real flag

tested and ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.22 2005/09/15 05:33:39 krw Exp $	*/
d36 2
d98 4
@


1.22
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.21 2005/08/31 17:59:09 marco Exp $	*/
d45 1
a45 1
	volatile int		*ccb_done;
@


1.21
log
@Fix some tsleep magic.  Code done by krw@@

feel free to commit, krw@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.20 2005/08/31 12:52:36 marco Exp $	*/
a116 2
		u_int8_t	hd_heads;
		u_int8_t	hd_secs;
@


1.20
log
@Make ioctls stop polling for completion.  This enhances the responsiveness
of the system.

tested and ok krw@@, dlg@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.19 2005/08/30 02:40:26 dlg Exp $	*/
d45 1
a45 3
	int			ccb_type;
#define AMI_IO_CCB	(0x00)
#define AMI_MGMT_CCB	(0x01)
@


1.19
log
@unfortunately large fixes to memleaks caused by abuse of incomplete
allocmem and freemem functions. freemem now unmaps dma memory from the
kernel address space instead of leaking it.

lots of tweaks and input from marco (who also found the bug in the first
place). lots of testing by krw and marco.

ok krw@@ marco@@ permitted by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.18 2005/08/15 23:22:46 marco Exp $	*/
d45 3
@


1.18
log
@Add global hot spare support.
Add flag to determine controller type.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.17 2005/08/08 20:23:46 marco Exp $	*/
a39 2
		bus_dmamap_t idatamap;
		bus_dma_segment_t idataseg[1];
@


1.17
log
@Add ses link.  Tested and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.16 2005/08/08 03:11:36 marco Exp $	*/
d75 1
@


1.16
log
@Add devices to structures.

ok and help deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.15 2005/08/05 04:16:51 marco Exp $	*/
d62 3
@


1.15
log
@Add support for SCSI pass-through commands for enclosure and processor devices
to expose ses(4) and safte(4) information.

ok beck@@, dlg@@
put your ami pt diff in, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.14 2005/07/29 16:01:30 marco Exp $	*/
d119 1
@


1.14
log
@Redo bioctl because initial implementation was too complex.

tested and ok dlg@@ beck@@
get it in @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.12 2005/07/18 01:29:01 marco Exp $	*/
d39 8
a46 1
	struct ami_ccb		*ccb_ccb1;	/* for passthrough */
@


1.13
log
@revert marcos bio changes, mickey not ok
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.11 2005/06/28 18:33:11 marco Exp $	*/
@


1.12
log
@Rip out all previous bio code because it sucked.  Replaced all ioctl code in
ami(4) and bio(4).

Note that this will break trees where userland and kernel are not in sync.

ok dlg@@
@
text
@a94 1
	int		sc_state_ch;
@


1.11
log
@NBIO > 0 the bioctl code.
Conditional jump to ami_ioctl() if NBIO > 0 is defined.

ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.10 2005/05/27 20:39:30 marco Exp $	*/
d95 1
@


1.10
log
@step 1 in fixing bioctl commands intermixed with regular io.

- Added the magical sequence for polling IO
- Created new polling function per hardware generation

Lots and lots of constructive yelling mickey@@
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.9 2005/05/09 19:50:48 marco Exp $	*/
d72 1
@


1.9
log
@replace sc_quirk with sc_flags, spotted and ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.8 2005/03/29 22:40:38 marco Exp $	*/
d63 2
a64 1
#define AMI_BROKEN 0x0002
d71 1
d93 1
d126 1
d131 1
@


1.8
log
@add copyright me
per mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.7 2004/12/26 00:11:24 marco Exp $	*/
d62 2
a90 4

/* don't use 0x0001 */
#define AMI_BROKEN 0x0002
	u_int16_t sc_quirks;
@


1.7
log
@This should fix long outstanding issues with ami(4).  The reported
symptoms that were fixed are:
* Very slow throughput
* ccb timeout (i.e. ami0: timeout ccb 1)
* All IO to ami devices hangs
* Only 1 LD (Logical Drive) can be accessed at the same time
* System hangs/freezes when running IO to ami cards.

Issues it doesn't fix:
* Really old ULTRA-2 controllers still crash whenever more than 1 LD are
  accessed at the same time therefore the driver limits the maximum LDs to 1.

Tested by several folks and ok beck@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.6 2003/06/02 19:24:22 mickey Exp $	*/
d5 1
@


1.6
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.5 2002/03/14 01:26:54 millert Exp $	*/
d89 4
d129 3
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.4 2001/12/12 14:52:52 mickey Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.4
log
@usmoke some scsi drugs, a little bit
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.3 2001/04/30 15:45:05 mickey Exp $	*/
d69 3
a71 3
	int (*sc_init) __P((struct ami_softc *sc));
	int (*sc_exec) __P((struct ami_softc *sc, struct ami_iocmd *));
	int (*sc_done) __P((struct ami_softc *sc, struct ami_iocmd *));
d119 2
a120 2
int  ami_attach __P((struct ami_softc *sc));
int  ami_intr __P((void *));
d122 7
a128 7
int ami_quartz_init __P((struct ami_softc *sc));
int ami_quartz_exec __P((struct ami_softc *sc, struct ami_iocmd *));
int ami_quartz_done __P((struct ami_softc *sc, struct ami_iocmd *));

int ami_schwartz_init __P((struct ami_softc *sc));
int ami_schwartz_exec __P((struct ami_softc *sc, struct ami_iocmd *));
int ami_schwartz_done __P((struct ami_softc *sc, struct ami_iocmd *));
@


1.4.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.4 2001/12/12 14:52:52 mickey Exp $	*/
d69 3
a71 3
	int (*sc_init)(struct ami_softc *sc);
	int (*sc_exec)(struct ami_softc *sc, struct ami_iocmd *);
	int (*sc_done)(struct ami_softc *sc, struct ami_iocmd *);
d119 2
a120 2
int  ami_attach(struct ami_softc *sc);
int  ami_intr(void *);
d122 7
a128 7
int ami_quartz_init(struct ami_softc *sc);
int ami_quartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_quartz_done(struct ami_softc *sc, struct ami_iocmd *);

int ami_schwartz_init(struct ami_softc *sc);
int ami_schwartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_schwartz_done(struct ami_softc *sc, struct ami_iocmd *);
@


1.3
log
@rework scsi stuff a bit, better locking.
still concurrent commands get busted, for some reason,
for tihs reason we lock to1 command at a time for now.
prev commit toamivar.h was a homeless -m.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.2 2001/04/30 15:43:10 mickey Exp $	*/
d80 1
a80 1
	ami_queue_head	sc_free_ccb, sc_ccbq, sc_ccb2q, sc_ccbdone;
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.1 2001/03/09 11:14:22 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
d43 1
d55 6
a64 1
	struct scsi_link sc_link_raw;
d70 1
a70 1
	int (*sc_exec) __P((struct ami_softc *sc));
d92 1
d111 1
d123 1
a123 1
int ami_quartz_exec __P((struct ami_softc *sc));
d127 1
a127 1
int ami_schwartz_exec __P((struct ami_softc *sc));
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.3.2.1 2001/05/14 22:23:29 niklas Exp $	*/
d4 1
a4 1
 * Copyright (c) 2001 Michael Shalayeff
a42 1
	struct ami_ccb		*ccb_ccb1;	/* for passthrough */
a53 6
struct ami_rawsoftc {
	struct scsi_link sc_link;
	struct ami_softc *sc_softc;
	u_int8_t	sc_channel;
};

d58 1
d64 1
a64 1
	int (*sc_exec) __P((struct ami_softc *sc, struct ami_iocmd *));
a85 1
	struct timeout	sc_poll_tmo;
a103 1
	struct ami_rawsoftc *sc_rawsoftcs;
d115 1
a115 1
int ami_quartz_exec __P((struct ami_softc *sc, struct ami_iocmd *));
d119 1
a119 1
int ami_schwartz_exec __P((struct ami_softc *sc, struct ami_iocmd *));
@


1.3.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 1
a80 1
	ami_queue_head	sc_free_ccb, sc_ccbq, sc_ccbdone;
@


1.3.2.4
log
@Merge in -current from about a week ago
@
text
@d69 3
a71 3
	int (*sc_init)(struct ami_softc *sc);
	int (*sc_exec)(struct ami_softc *sc, struct ami_iocmd *);
	int (*sc_done)(struct ami_softc *sc, struct ami_iocmd *);
d119 2
a120 2
int  ami_attach(struct ami_softc *sc);
int  ami_intr(void *);
d122 7
a128 7
int ami_quartz_init(struct ami_softc *sc);
int ami_quartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_quartz_done(struct ami_softc *sc, struct ami_iocmd *);

int ami_schwartz_init(struct ami_softc *sc);
int ami_schwartz_exec(struct ami_softc *sc, struct ami_iocmd *);
int ami_schwartz_done(struct ami_softc *sc, struct ami_iocmd *);
@


1.3.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.3.2.4 2002/03/28 11:51:00 niklas Exp $	*/
d15 5
@


1.2
log
@ami.c
@
text
@d1 1
a1 1
/*	$OpenBSD: amivar.h,v 1.1 2001/03/09 11:14:22 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 2000 Michael Shalayeff
@


1.1
log
@seems to work; rush because of cvs's battery at 73% now
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d43 1
d55 6
a64 1
	struct scsi_link sc_link_raw;
d70 1
a70 1
	int (*sc_exec) __P((struct ami_softc *sc));
d92 1
d111 1
d123 1
a123 1
int ami_quartz_exec __P((struct ami_softc *sc));
d127 1
a127 1
int ami_schwartz_exec __P((struct ami_softc *sc));
@

