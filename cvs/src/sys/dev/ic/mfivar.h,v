head	1.54;
access;
symbols
	OPENBSD_6_2:1.54.0.8
	OPENBSD_6_2_BASE:1.54
	OPENBSD_6_1:1.54.0.12
	OPENBSD_6_1_BASE:1.54
	OPENBSD_6_0:1.54.0.10
	OPENBSD_6_0_BASE:1.54
	OPENBSD_5_9:1.54.0.4
	OPENBSD_5_9_BASE:1.54
	OPENBSD_5_8:1.54.0.6
	OPENBSD_5_8_BASE:1.54
	OPENBSD_5_7:1.54.0.2
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.8
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.6
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.50.0.2
	OPENBSD_5_3_BASE:1.50
	OPENBSD_5_2:1.42.0.2
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.2
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.31.0.4
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.31.0.2
	OPENBSD_4_3_BASE:1.31
	OPENBSD_4_2:1.30.0.2
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.28.0.2
	OPENBSD_4_0_BASE:1.28;
locks; strict;
comment	@ * @;


1.54
date	2014.08.15.02.27.02;	author yasuoka;	state Exp;
branches;
next	1.53;
commitid	yBlCT4oSbR2KFU4a;

1.53
date	2013.05.03.02.46.28;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.01.03.44.22;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2013.04.30.07.19.23;	author dlg;	state Exp;
branches;
next	1.50;

1.50
date	2012.08.17.11.31.34;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2012.08.16.06.45.51;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2012.08.14.10.44.36;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2012.08.14.10.13.39;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2012.08.14.03.46.46;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2012.08.14.03.44.11;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2012.08.14.03.42.03;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2012.08.13.05.20.30;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.12.06.12.30;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2011.04.09.20.23.31;	author marco;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.30.08.53.50;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2010.06.30.19.10.05;	author mk;	state Exp;
branches;
next	1.38;

1.38
date	2010.04.10.17.26.10;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.04.08.04.43;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.04.07.57.28;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2009.01.28.23.45.12;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.31.21.39.04;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.27.03.11.58;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.26.18.56.24;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2008.02.11.01.07.02;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.31.18.18.46;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.31.18.13.17;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.19.19.05.45;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.25.00.21.31;	author marco;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.23.00.43.57;	author marco;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.22.02.24.11;	author marco;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.22.01.08.39;	author marco;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.21.20.20.17;	author marco;	state Exp;
branches;
next	1.20;

1.20
date	2006.05.18.17.25.02;	author marco;	state Exp;
branches;
next	1.19;

1.19
date	2006.05.17.23.40.26;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.17.21.50.21;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.17.16.00.53;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2006.05.16.22.51.10;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2006.05.15.23.20.57;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2006.05.10.21.48.50;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.21.21.39.32;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.20.14.01.08;	author dlg;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.17.16.46.39;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2006.04.17.00.48.14;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2006.04.16.23.35.43;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2006.04.16.17.10.08;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2006.04.16.16.34.35;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.16.14.40.00;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.07.20.27.51;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.07.20.05.31;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.07.16.28.07;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.07.16.10.34;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.06.20.22.53;	author marco;	state Exp;
branches;
next	;


desc
@@


1.54
log
@Create a function which loads sgd in the mfi_iop_ops struct so that skinny
adapters can use "IEEE sgl".

tested dlg yasuoka
ok dlg jsg
@
text
@/* $OpenBSD: mfivar.h,v 1.53 2013/05/03 02:46:28 dlg Exp $ */
/*
 * Copyright (c) 2006 Marco Peereboom <marco@@peereboom.us>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

struct mfi_softc;
#define DEVNAME(_s)	((_s)->sc_dev.dv_xname)

/* #define MFI_DEBUG */
#ifdef MFI_DEBUG
extern uint32_t			mfi_debug;
#define DPRINTF(x...)		do { if (mfi_debug) printf(x); } while(0)
#define DNPRINTF(n,x...)	do { if (mfi_debug & n) printf(x); } while(0)
#define	MFI_D_CMD		0x0001
#define	MFI_D_INTR		0x0002
#define	MFI_D_MISC		0x0004
#define	MFI_D_DMA		0x0008
#define	MFI_D_IOCTL		0x0010
#define	MFI_D_RW		0x0020
#define	MFI_D_MEM		0x0040
#define	MFI_D_CCB		0x0080
#else
#define DPRINTF(x...)
#define DNPRINTF(n,x...)
#endif

struct mfi_mem {
	bus_dmamap_t		am_map;
	bus_dma_segment_t	am_seg;
	size_t			am_size;
	caddr_t			am_kva;
};

#define MFIMEM_MAP(_am)		((_am)->am_map)
#define MFIMEM_LEN(_am)		((_am)->am_map->dm_mapsize)
#define MFIMEM_DVA(_am)		((_am)->am_map->dm_segs[0].ds_addr)
#define MFIMEM_KVA(_am)		((void *)(_am)->am_kva)

struct mfi_prod_cons {
	uint32_t		mpc_producer;
	uint32_t		mpc_consumer;
	uint32_t		mpc_reply_q[1]; /* compensate for 1 extra reply per spec */
};

struct mfi_ccb {
	union mfi_frame		*ccb_frame;
	paddr_t			ccb_pframe;
	bus_addr_t		ccb_pframe_offset;
	uint32_t		ccb_frame_size;
	uint32_t		ccb_extra_frames;

	struct mfi_sense	*ccb_sense;
	paddr_t			ccb_psense;

	bus_dmamap_t		ccb_dmamap;

	union mfi_sgl		*ccb_sgl;

	/* data for sgl */
	void			*ccb_data;
	uint32_t		ccb_len;

	uint32_t		ccb_direction;
#define MFI_DATA_NONE	0
#define MFI_DATA_IN	1
#define MFI_DATA_OUT	2

	void			*ccb_cookie;
	void			(*ccb_done)(struct mfi_softc *,
				    struct mfi_ccb *);

	volatile enum {
		MFI_CCB_FREE,
		MFI_CCB_READY,
		MFI_CCB_DONE
	}			ccb_state;
	uint32_t		ccb_flags;
#define MFI_CCB_F_ERR			(1<<0)
	SLIST_ENTRY(mfi_ccb)	ccb_link;
};

SLIST_HEAD(mfi_ccb_list, mfi_ccb);

enum mfi_iop {
	MFI_IOP_XSCALE,
	MFI_IOP_PPC,
	MFI_IOP_GEN2,
	MFI_IOP_SKINNY
};

struct mfi_iop_ops {
	u_int32_t	(*mio_fw_state)(struct mfi_softc *);
	void		(*mio_intr_ena)(struct mfi_softc *);
	int		(*mio_intr)(struct mfi_softc *);
	void		(*mio_post)(struct mfi_softc *, struct mfi_ccb *);
	u_int		(*mio_sgd_load)(struct mfi_softc *, struct mfi_ccb *);
	u_int32_t	mio_idb;
	u_int32_t	mio_flags;
#define MFI_IOP_F_SYSPD		(1 << 0)
};

struct mfi_pd_link {
	u_int16_t		pd_id;
	struct mfi_pd_details	pd_info;
};

struct mfi_pd_softc {
	struct scsi_link	pd_link;
	struct scsibus_softc	*pd_scsibus;
	struct mfi_pd_link	*pd_links[MFI_MAX_PD];
};

struct mfi_softc {
	struct device		sc_dev;
	void			*sc_ih;
	struct scsi_link	sc_link;
	struct scsi_iopool	sc_iopool;

	const struct mfi_iop_ops *sc_iop;

	int			sc_64bit_dma;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;

	/* save some useful information for logical drives that is missing
	 * in sc_ld_list
	 */
	struct {
		uint32_t	ld_present;
		char		ld_dev[16];	/* device name sd? */
	}			sc_ld[MFI_MAX_LD];

	/* scsi ioctl from sd device */
	int			(*sc_ioctl)(struct device *, u_long, caddr_t);

	/* firmware determined max, totals and other information*/
	uint32_t		sc_max_cmds;
	uint32_t		sc_max_sgl;
	uint32_t		sc_sgl_size;
	uint32_t		sc_ld_cnt;

	uint16_t		sc_sgl_flags;
	uint16_t		sc_reserved;

	/* bio */
	struct mfi_conf		*sc_cfg;
	struct mfi_ctrl_info	sc_info;
	struct mfi_ld_list	sc_ld_list;
	struct mfi_ld_details	*sc_ld_details; /* array to all logical disks */
	int			sc_no_pd; /* used physical disks */
	int			sc_ld_sz; /* sizeof sc_ld_details */

	/* all commands */
	struct mfi_ccb		*sc_ccb;

	/* producer/consumer pointers and reply queue */
	struct mfi_mem		*sc_pcq;

	/* frame memory */
	struct mfi_mem		*sc_frames;
	uint32_t		sc_frames_size;

	/* sense memory */
	struct mfi_mem		*sc_sense;

	struct mfi_ccb_list	sc_ccb_freeq;
	struct mutex		sc_ccb_mtx;

	struct scsibus_softc	*sc_scsibus;
	struct mfi_pd_softc	*sc_pd;

	/* mgmt lock */
	struct rwlock		sc_lock;

	/* sensors */
	struct ksensordev	sc_sensordev;
	struct ksensor		*sc_bbu;
	struct ksensor		*sc_bbu_status;
	struct ksensor		*sc_sensors;
};

int	mfi_attach(struct mfi_softc *sc, enum mfi_iop);
int	mfi_intr(void *);
@


1.53
log
@break out the battery status into excruciating detail. makes it harder for
$VENDOR to complain about a lack of diagnostic material from their crappy
mgmt tools if you're not running an operating system they support.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.52 2013/05/01 03:44:22 dlg Exp $ */
d108 1
@


1.52
log
@provide a sensor for the battery backup unit (bbu) on mfi boards that
support it.

now i can tell (a bit better) why io might be slow on some of my boxes.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.51 2013/04/30 07:19:23 dlg Exp $ */
d191 1
@


1.51
log
@white space tweak
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.50 2012/08/17 11:31:34 dlg Exp $ */
d189 2
a191 1
	struct ksensordev	sc_sensordev;
@


1.50
log
@add support for "physical devices" on skinny controllers.

these controllers let you specify disks that should be accessed directly
rather than be part of logical volumes. apparently you can plug in things
like tape drives too.

anyway, physical devices are exposed via a separate scsibus attached to
mfi.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.49 2012/08/16 06:45:51 dlg Exp $ */
d19 1
a19 1
#define DEVNAME(_s)     ((_s)->sc_dev.dv_xname)
@


1.49
log
@stop passing mfi_softc around as a member of the ccb, consistently give it
as the first argument to functions. like mfii.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.48 2012/08/14 10:44:36 dlg Exp $ */
d109 13
d183 1
@


1.48
log
@use scsi_get_link to find out the name of a child device for bioctl rather
than snoop scsi commands and copy it in an io path.

no functional change, but the code has one less XXX now.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.47 2012/08/14 10:13:39 dlg Exp $ */
d18 1
a57 2
	struct mfi_softc	*ccb_sc;

d81 2
a82 1
	void			(*ccb_done)(struct mfi_ccb *);
@


1.47
log
@expose the max number of logical volumes the hardware supports as the width
of its scsibus. only advertise 1 lun on logical volumes instead of letting
the midlayer fix it up to 8.

give every target on the bus max_cmds openings. iopools means they will
properly share access to them.

this in particular is useful on skinny controllers which only advertise 31
command slots. if you have 16 volumes, theyll only get 1 opening each with
the old maths. this way round the ones that are busy will share the slots.

tested on a perc5 with two volumes and hard workloads.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.46 2012/08/14 03:46:46 dlg Exp $ */
d168 2
@


1.46
log
@gc sc_flags now that the iop struct can tell us where the different IDBs
are.

noted by haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.45 2012/08/14 03:44:11 dlg Exp $ */
a139 1
	uint32_t		sc_max_ld;
@


1.45
log
@oops, dont claim FUSION is an iop type we will support in mfi(4)
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.44 2012/08/14 03:42:03 dlg Exp $ */
a119 1
	int			sc_flags;
@


1.44
log
@move knowledge of the location of the inbound doorbell out of code in
transition_firmware into a member of the iop structures.

ok mikeb@@ haesbaert@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.43 2012/08/13 05:20:30 dlg Exp $ */
d100 1
a100 2
	MFI_IOP_SKINNY,
	MFI_IOP_FUSION
@


1.43
log
@do appropriate bus_dmamapy_syncs around the pcq/completion ring.

tested on a perc5 (xscale)
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.42 2012/01/12 06:12:30 dlg Exp $ */
d100 2
a101 1
	MFI_IOP_SKINNY
d109 1
@


1.42
log
@add support for skinny variants.

from Alexey Suslikov
reviewed by marco
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.41 2011/04/09 20:23:31 marco Exp $ */
d46 1
@


1.41
log
@add all 64 bit dma plumbing but stick with 32 for now by default.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.40 2010/12/30 08:53:50 dlg Exp $ */
d98 2
a99 1
	MFI_IOP_GEN2
d118 1
@


1.40
log
@cut mfi over to using iopools.

this gets rid of NO_CCB, provides better scheduling of io between busy
logical volumes on the same controller, and makes the ioctl and sensor
paths more reliable.

this is the least intrusive version of this change i could come up with. it
only took 4 or 5 goes...

ok marco@@
deraadt@@ says this is a good time for this change.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.39 2010/06/30 19:10:05 mk Exp $ */
d116 1
a116 1
	u_int32_t		sc_flags;
d136 1
d139 3
@


1.39
log
@Use SLIST for the ccb free list.

ok krw, discontent grunts from marco.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.38 2010/04/10 17:26:10 marco Exp $ */
d112 1
@


1.38
log
@sprinkle some bus_dmamap_sync around frame access.
prompted by oga
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.37 2010/01/04 08:04:43 dlg Exp $ */
d90 1
a90 1
	TAILQ_ENTRY(mfi_ccb)	ccb_link;
d93 1
a93 1
TAILQ_HEAD(mfi_ccb_list, mfi_ccb);
@


1.37
log
@rename ccb_xs to ccb_cookie and change its type from a scsi_xfer * to a
void *. this lets us pass things other than scsi_xfers to ccb completion
handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.36 2010/01/04 07:57:28 dlg Exp $ */
d60 1
@


1.36
log
@protect the ccb free queue with a mutex rather than splbio
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.34 2008/10/31 21:39:04 marco Exp $ */
d79 1
a79 2
	struct scsi_xfer	*ccb_xs;

@


1.35
log
@Add support for next generation megaraid sas raid controllers.
From Jim Giannoules <gortag@@gmail.com>
@
text
@d160 1
@


1.34
log
@Generalize function to obtain all details to do bio stuff.  This is in
preparation to start showing unsused disks which will require all this
information to do the math.

While at it fix a size of hotspare volume bug.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.33 2008/10/27 03:11:58 marco Exp $ */
d97 2
a98 1
	MFI_IOP_PPC
@


1.33
log
@Move some include stuff around
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.32 2008/10/26 18:56:24 marco Exp $ */
d136 3
a138 1
	/* XXX these struct should be local to mgmt function */
d141 3
a143 1
	struct mfi_ld_details	sc_ld_details;
@


1.32
log
@Move sensors into SMALL_KERNEL
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.31 2008/02/11 01:07:02 dlg Exp $ */
a17 2
#include <sys/sensors.h>

a119 3
	/* mgmt lock */
	struct rwlock		sc_lock;

d156 4
a159 1
#ifndef SMALL_KERNEL
a161 1
#endif
@


1.31
log
@add support for the mfi controllers with the ppc iops, aka, LSI SAS1078 or
Dell PERC6.

committed off a machine booting and rooting off a perc6. tested on a perc5
by marco@@
ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.29 2006/12/23 17:46:39 deraadt Exp $ */
d161 1
d164 1
@


1.30
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d97 12
d114 2
d165 1
a165 1
int	mfi_attach(struct mfi_softc *sc);
@


1.29
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.28 2006/08/31 18:18:46 marco Exp $ */
d147 2
a148 2
	struct sensor		*sc_sensors;
	struct sensordev	sc_sensordev;
@


1.28
log
@Oops! Disable debug.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.27 2006/08/31 18:13:17 marco Exp $ */
d18 2
d148 1
@


1.27
log
@Add sensor thread for individual sd devices.

tested dlg
ok dlg deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.26 2006/06/19 19:05:45 marco Exp $ */
a19 1
#define MFI_DEBUG
@


1.26
log
@Add hot spare support.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.25 2006/05/25 00:21:31 marco Exp $ */
d20 1
d145 2
@


1.25
log
@Add physical device and read config structures.
Add initial part of BIOCDISK
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.24 2006/05/23 00:43:57 marco Exp $ */
d125 1
@


1.24
log
@Add first half of physical disk data for bio.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.23 2006/05/22 02:24:11 marco Exp $ */
a127 1
	struct mfi_pd_list	*sc_pd_list;
@


1.23
log
@Add mail box to mfi_mgmt to handle sub commands more gracefully.
Remove some debug crud that snuck in the TEST_UNIT_READY case.
Finish other half of BIOCVOL primitive.
Add several structures to fill out the BIOCVOL primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.22 2006/05/22 01:08:39 marco Exp $ */
d128 1
@


1.22
log
@Add first half of BIOCVOL primitive.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.21 2006/05/21 20:20:17 marco Exp $ */
d127 1
@


1.21
log
@Add generic management function.
Redo ccb_state flags so that we can actually sleep on it.
Redo mfi_get_info to use new mgmt function.
Add rw_locks for mgmt interface.
Make BIOCINQ dynamic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.20 2006/05/18 17:25:02 marco Exp $ */
d109 3
a111 1
	/* save some useful information for logical drives */
a113 1
		quad_t		ld_size;	/* READ CAPICITY */
d126 1
@


1.20
log
@And we have lift off!  Was able to create a filesystem and write to the
filesystem.

Collapse both completion routines into one.
Fixup scsi error reporting in the completion routine.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.19 2006/05/17 23:40:26 marco Exp $ */
d86 1
a86 2
		MFI_CCB_QUEUED,
		MFI_CCB_PREQUEUED
d105 3
@


1.19
log
@Add completion routines.
Fix some bugs inside the interrupt handler.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.18 2006/05/17 21:50:21 marco Exp $ */
a20 1
#define MFI_DEBUG
@


1.18
log
@Add mfi_get_info to obtain all kinds of fun information from the fw.
Print out whole info structure when debug is enabled.
Add a nice print with useful info during attach.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.17 2006/05/17 16:00:53 marco Exp $ */
d21 1
@


1.17
log
@Refactor scsi path so that we can have a single sgl function for io and non-io
traffic.
Redo parameters on functions that were passing too many parameters around.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.16 2006/05/16 22:51:10 marco Exp $ */
d117 1
a117 1
	/* firmware determined max and totals */
d122 1
@


1.16
log
@Fix some more htole32 screw-ups.
Colapse all little SCSI functions into a single generic one.
Fix a bug in the SGE calculation.

This brings the driver up to post:
mfi0 at pci12 dev 14 function 0 "Dell PERC SAS" rev 0x00: Dell PERC 5/e irq 5
scsibus3 at mfi0: 2 targets
sd1 at scsibus3 targ 0 lun 0: <DELL, PERC 5/E Adapter, 1.00> SCSI5 0/direct fixed
sd1: 237824MB, 237824 cyl, 64 head, 32 sec, 512 bytes/sec, 487063552 sec total
sd2 at scsibus3 targ 1 lun 0: <DELL, PERC 5/E Adapter, 1.00> SCSI5 0/direct fixed
sd2: 34176MB, 34176 cyl, 64 head, 32 sec, 512 bytes/sec, 69992448 sec total
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.15 2006/05/15 23:20:57 marco Exp $ */
d70 4
d75 3
a77 2
#define MFI_DATA_IN	0
#define MFI_DATA_OUT	1
d81 1
a81 2
	void			(*ccb_done)(struct mfi_softc *sc,
				    struct mfi_ccb *ccb);
@


1.15
log
@Add INQUIRY command.
Add sgl magic.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.14 2006/05/10 21:48:50 marco Exp $ */
d20 1
a20 1
#define MFI_DEBUG
@


1.14
log
@Add some airplane code.

add bio hooks.
add scsi entry point for io.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.13 2006/04/21 21:39:32 marco Exp $ */
d60 1
d68 6
d116 2
@


1.13
log
@Add mfi_poll and use the new shiny function to setup all the hardware queues.
Lots of ideas from the FreeBSD driver.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.12 2006/04/20 14:01:08 dlg Exp $ */
d95 10
@


1.12
log
@marco hates typedefs as much as i do, so he asked me to clean mfi like i
just did with ami.  this gets rid of the typedef for the ccb lists.

also uses TAILQ_FIRST to get ccbs off the freelist. this is a proactive
fix for a lint teary.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.11 2006/04/17 16:46:39 marco Exp $ */
d60 1
@


1.11
log
@Sprinkle more debug.  Remove 64 byte boundary; it doesn't seem to like it.
Hack around 64 byte boundary for the frames for now.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.10 2006/04/17 00:48:14 marco Exp $ */
d82 1
a82 1
typedef TAILQ_HEAD(mfi_queue_head, mfi_ccb)	mfi_queue_head;
d112 1
a112 1
	mfi_queue_head		sc_ccb_freeq;
@


1.10
log
@Setup ccbs and clean up ccb structure.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.9 2006/04/16 23:35:43 marco Exp $ */
d31 2
@


1.9
log
@Add frame memory and sglist allocation.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.8 2006/04/16 17:10:08 marco Exp $ */
d56 1
a56 1
	union mfi_frame		ccb_frame;
d59 3
a61 7
#if 0
	struct ami_iocmd	ccb_cmd;
	struct ami_passthrough	*ccb_pt;
	paddr_t			ccb_ptpa;
	struct ami_sgent	*ccb_sglist;
	paddr_t			ccb_sglistpa;
	int			ccb_offset;
d63 1
a63 1
#endif
d65 1
d97 3
d105 1
@


1.8
log
@Add get and put ccb functions.  Shuffle some more definitions.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.7 2006/04/16 16:34:35 marco Exp $ */
d102 6
@


1.7
log
@Add interrupt handler.  Idea borrowed from FreeBSD since it is much nicer
than the Linux one.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.6 2006/04/16 14:40:00 marco Exp $ */
a52 19
struct mfi_softc {
	struct device		sc_dev;
	void			*sc_ih;
	struct scsi_link	sc_link;

	u_int32_t		sc_flags;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_dma_tag_t		sc_dmat;

	/* firmware determined max and totals */
	uint32_t		sc_max_cmds;
	uint32_t		sc_max_sgl;

	/* producer/consumer pointers and reply queue */
	struct mfi_mem		*sc_pcq;
};

d80 24
a103 1
	TAILQ_ENTRY(MFI_ccb)	ccb_link;
@


1.6
log
@Add skeleton ccb structure.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.5 2006/04/07 20:27:51 marco Exp $ */
d47 6
d68 2
a69 2
	/* reply queue */
	struct mfi_mem		*sc_reply_q;
@


1.5
log
@Replace bus_space functions with generic ones that do barriers.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.4 2006/04/07 20:05:31 marco Exp $ */
d64 30
@


1.4
log
@Add memory allocator functions.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.3 2006/04/07 16:28:07 marco Exp $ */
d30 1
@


1.3
log
@Make a better debug mechanism.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.2 2006/04/07 16:10:34 marco Exp $ */
d35 11
d56 7
@


1.2
log
@Add DEVNAME.
@
text
@d1 1
a1 1
/* $OpenBSD: mfivar.h,v 1.1 2006/04/06 20:22:53 marco Exp $ */
d19 15
@


1.1
log
@Add skeleton driver for MegaRAID SAS.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d17 2
@

