head	1.25;
access;
symbols
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.24.0.6
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.2
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.2
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.17.0.4
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.2
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.15.0.2
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.6
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.5.0.2
	OPENBSD_4_8_BASE:1.5;
locks; strict;
comment	@ * @;


1.25
date	2017.01.12.16.32.28;	author stsp;	state Exp;
branches;
next	1.24;
commitid	1Zd7y0b8dZf1uELZ;

1.24
date	2016.01.05.18.41.15;	author stsp;	state Exp;
branches;
next	1.23;
commitid	2QagMjdMhQhIaQgu;

1.23
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.22;
commitid	5gdEnqVoJuTuwdTu;

1.22
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.21;
commitid	FuSD2mFDJWATHIDx;

1.21
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.20;
commitid	5DvsamK0GblTp8ww;

1.20
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.19;
commitid	LS2TNeCue5R9L67C;

1.19
date	2014.07.22.13.12.11;	author mpi;	state Exp;
branches;
next	1.18;
commitid	TGHgrLxu6sxZoiFt;

1.18
date	2013.08.07.01.06.28;	author bluhm;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.20.09.54.20;	author stsp;	state Exp;
branches;
next	1.16;

1.16
date	2012.10.20.09.53.32;	author stsp;	state Exp;
branches;
next	1.15;

1.15
date	2012.06.10.21.23.36;	author kettenis;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.07.14.19.53;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.05.21.31.34;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2011.01.01.14.25.03;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.01.13.44.42;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2011.01.01.10.48.31;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.31.21.23.55;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.31.14.06.05;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.10.21.06.44;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2010.10.18.16.05.28;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2010.06.21.19.54.28;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2010.05.13.09.03.12;	author damien;	state Exp;
branches;
next	1.3;

1.3
date	2010.05.11.19.34.20;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2010.05.11.17.59.39;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2010.05.10.17.44.21;	author damien;	state Exp;
branches;
next	;


desc
@@


1.25
log
@Finish initial 11n support for athn(4).

The heavy lifting was done by damien@@ years ago. I didn't even have
to figure out what the hardware expects, the code was already there.

This driver now supports MCS 0-15 in client and hostap mode.
No Tx aggregation and no 40 MHz channels yet.

tested by vgross@@, bmercer@@, tb@@, jmc@@, Vadim Vygonets, Peter Kay
ok bmercer@@ tb@@ phessler@@
@
text
@/*	$OpenBSD: ar9380.c,v 1.24 2016/01/05 18:41:15 stsp Exp $	*/

/*-
 * Copyright (c) 2011 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2010 Atheros Communications Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Atheros 802.11a/g/n chipsets.
 * Routines for AR9380 and AR9485 chipsets.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/bus.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_mira.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/ic/athnreg.h>
#include <dev/ic/athnvar.h>

#include <dev/ic/ar9003reg.h>
#include <dev/ic/ar9380reg.h>

int	ar9380_attach(struct athn_softc *);
void	ar9380_setup(struct athn_softc *);
const	uint8_t *ar9380_get_rom_template(struct athn_softc *, uint8_t);
void	ar9380_swap_rom(struct athn_softc *);
int	ar9380_set_synth(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9380_get_paprd_masks(struct athn_softc *, struct ieee80211_channel *,
	    uint32_t *, uint32_t *);
void	ar9380_init_from_rom(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9380_init_swreg(struct athn_softc *);
int	ar9485_pmu_write(struct athn_softc *, uint32_t, uint32_t);
void	ar9485_init_swreg(struct athn_softc *);
void	ar9380_spur_mitigate_cck(struct athn_softc *,
	    struct ieee80211_channel *, struct ieee80211_channel *);
void	ar9380_spur_mitigate_ofdm(struct athn_softc *,
	    struct ieee80211_channel *, struct ieee80211_channel *);
void	ar9380_spur_mitigate(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9380_set_txpower(struct athn_softc *, struct ieee80211_channel *,
	    struct ieee80211_channel *);
void	ar9380_get_correction(struct athn_softc *, struct ieee80211_channel *,
	    int, int *, int *);
void	ar9380_set_correction(struct athn_softc *, struct ieee80211_channel *);

/* Extern functions. */
int	athn_interpolate(int, int, int, int, int);
uint8_t	athn_chan2fbin(struct ieee80211_channel *);
void	athn_get_pier_ival(uint8_t, const uint8_t *, int, int *, int *);
int	ar9003_attach(struct athn_softc *);
void	ar9003_write_txpower(struct athn_softc *, int16_t power[]);
void	ar9003_get_lg_tpow(struct athn_softc *, struct ieee80211_channel *,
	    uint8_t, const uint8_t *, const struct ar_cal_target_power_leg *,
	    int, uint8_t[]);
void	ar9003_get_ht_tpow(struct athn_softc *, struct ieee80211_channel *,
	    uint8_t, const uint8_t *, const struct ar_cal_target_power_ht *,
	    int, uint8_t[]);


int
ar9380_attach(struct athn_softc *sc)
{
	sc->ngpiopins = 17;
	sc->ops.setup = ar9380_setup;
	sc->ops.get_rom_template = ar9380_get_rom_template;
	sc->ops.swap_rom = ar9380_swap_rom;
	sc->ops.init_from_rom = ar9380_init_from_rom;
	sc->ops.set_txpower = ar9380_set_txpower;
	sc->ops.set_synth = ar9380_set_synth;
	sc->ops.spur_mitigate = ar9380_spur_mitigate;
	sc->ops.get_paprd_masks = ar9380_get_paprd_masks;
	sc->cca_min_2g = AR9380_PHY_CCA_MIN_GOOD_VAL_2GHZ;
	sc->cca_max_2g = AR9380_PHY_CCA_MAX_GOOD_VAL_2GHZ;
	sc->cca_min_5g = AR9380_PHY_CCA_MIN_GOOD_VAL_5GHZ;
	sc->cca_max_5g = AR9380_PHY_CCA_MAX_GOOD_VAL_5GHZ;
	if (AR_SREV_9485(sc)) {
		sc->ini = &ar9485_1_1_ini;
		sc->serdes = &ar9485_1_1_serdes;
	} else {
		sc->ini = &ar9380_2_2_ini;
		sc->serdes = &ar9380_2_2_serdes;
	}

	return (ar9003_attach(sc));
}

void
ar9380_setup(struct athn_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ar9380_eeprom *eep = sc->eep;
	struct ar9380_base_eep_hdr *base = &eep->baseEepHeader;
	uint8_t type;

	if (base->opFlags & AR_OPFLAGS_11A)
		sc->flags |= ATHN_FLAG_11A;
	if (base->opFlags & AR_OPFLAGS_11G)
		sc->flags |= ATHN_FLAG_11G;
	if (base->opFlags & AR_OPFLAGS_11N)
		sc->flags |= ATHN_FLAG_11N;

	IEEE80211_ADDR_COPY(ic->ic_myaddr, eep->macAddr);
	sc->led_pin = base->wlanLedGpio;

	/* Check if we have a hardware radio switch. */
	if (base->rfSilent & AR_EEP_RFSILENT_ENABLED) {
		sc->flags |= ATHN_FLAG_RFSILENT;
		/* Get GPIO pin used by hardware radio switch. */
		sc->rfsilent_pin = MS(base->rfSilent,
		    AR_EEP_RFSILENT_GPIO_SEL);
		/* Get polarity of hardware radio switch. */
		if (base->rfSilent & AR_EEP_RFSILENT_POLARITY)
			sc->flags |= ATHN_FLAG_RFSILENT_REVERSED;
	}

	/* Set the number of HW key cache entries. */
	sc->kc_entries = AR_KEYTABLE_SIZE;

	sc->txchainmask = MS(base->txrxMask, AR_EEP_TX_MASK);
	sc->rxchainmask = MS(base->txrxMask, AR_EEP_RX_MASK);

	/* Fast PLL clock is always supported. */
	sc->flags |= ATHN_FLAG_FAST_PLL_CLOCK;

	/* Enable PA predistortion if supported. */
	if (base->featureEnable & AR_EEP_PAPRD)
		sc->flags |= ATHN_FLAG_PAPRD;
	/*
	 * Some 3-stream chips may exceed the PCIe power requirements,
	 * requiring to reduce the number of Tx chains in some cases.
	 */
	if ((base->miscConfiguration & AR_EEP_CHAIN_MASK_REDUCE) &&
	    sc->txchainmask == 0x7)
		sc->flags |= ATHN_FLAG_3TREDUCE_CHAIN;

	/* Select initialization values based on ROM. */
	type = MS(eep->baseEepHeader.txrxgain, AR_EEP_RX_GAIN);
	if (!AR_SREV_9485(sc)) {
		if (type == AR_EEP_RX_GAIN_WO_XLNA)
			sc->rx_gain = &ar9380_2_2_rx_gain_wo_xlna;
		else
			sc->rx_gain = &ar9380_2_2_rx_gain;
	} else
		sc->rx_gain = &ar9485_1_1_rx_gain;

	/* Select initialization values based on ROM. */
	type = MS(eep->baseEepHeader.txrxgain, AR_EEP_TX_GAIN);
	if (!AR_SREV_9485(sc)) {
		if (type == AR_EEP_TX_GAIN_HIGH_OB_DB)
			sc->tx_gain = &ar9380_2_2_tx_gain_high_ob_db;
		else if (type == AR_EEP_TX_GAIN_LOW_OB_DB)
			sc->tx_gain = &ar9380_2_2_tx_gain_low_ob_db;
		else if (type == AR_EEP_TX_GAIN_HIGH_POWER)
			sc->tx_gain = &ar9380_2_2_tx_gain_high_power;
		else
			sc->tx_gain = &ar9380_2_2_tx_gain;
	} else
		sc->tx_gain = &ar9485_1_1_tx_gain;
}

const uint8_t *
ar9380_get_rom_template(struct athn_softc *sc, uint8_t ref)
{
	int i;

	/* Retrieve template ROM image for given reference. */
	for (i = 0; i < nitems(ar9380_rom_templates); i++)
		if (ar9380_rom_templates[i][1] == ref)
			return (ar9380_rom_templates[i]);
	return (NULL);
}

void
ar9380_swap_rom(struct athn_softc *sc)
{
#if BYTE_ORDER == BIG_ENDIAN
	struct ar9380_eeprom *eep = sc->eep;
	struct ar9380_base_eep_hdr *base = &eep->baseEepHeader;
	struct ar9380_modal_eep_header *modal;
	int i;

	base->regDmn[0] = swap16(base->regDmn[0]);
	base->regDmn[1] = swap16(base->regDmn[1]);
	base->swreg = swap32(base->swreg);

	modal = &eep->modalHeader2G;
	modal->antCtrlCommon = swap32(modal->antCtrlCommon);
	modal->antCtrlCommon2 = swap32(modal->antCtrlCommon2);
	modal->papdRateMaskHt20 = swap32(modal->papdRateMaskHt20);
	modal->papdRateMaskHt40 = swap32(modal->papdRateMaskHt40);
	for (i = 0; i < AR9380_MAX_CHAINS; i++)
		modal->antCtrlChain[i] = swap16(modal->antCtrlChain[i]);

	modal = &eep->modalHeader5G;
	modal->antCtrlCommon = swap32(modal->antCtrlCommon);
	modal->antCtrlCommon2 = swap32(modal->antCtrlCommon2);
	modal->papdRateMaskHt20 = swap32(modal->papdRateMaskHt20);
	modal->papdRateMaskHt40 = swap32(modal->papdRateMaskHt40);
	for (i = 0; i < AR9380_MAX_CHAINS; i++)
		modal->antCtrlChain[i] = swap16(modal->antCtrlChain[i]);
#endif
}

void
ar9380_get_paprd_masks(struct athn_softc *sc, struct ieee80211_channel *c,
    uint32_t *ht20mask, uint32_t *ht40mask)
{
	const struct ar9380_eeprom *eep = sc->eep;
	const struct ar9380_modal_eep_header *modal;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		modal = &eep->modalHeader2G;
	else
		modal = &eep->modalHeader5G;
	*ht20mask = modal->papdRateMaskHt20;
	*ht40mask = modal->papdRateMaskHt40;
}

int
ar9380_set_synth(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	uint32_t freq = c->ic_freq;
	uint32_t chansel, phy;

	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		if (AR_SREV_9485(sc))
			chansel = ((freq << 16) - 215) / 15;
		else
			chansel = (freq << 16) / 15;
		AR_WRITE(sc, AR_PHY_SYNTH_CONTROL, AR9380_BMODE);
	} else {
		chansel = (freq << 15) / 15;
		chansel >>= 1;
		AR_WRITE(sc, AR_PHY_SYNTH_CONTROL, 0);
	}

	/* Enable Long Shift Select for synthesizer. */
	AR_SETBITS(sc, AR_PHY_65NM_CH0_SYNTH4,
	    AR_PHY_SYNTH4_LONG_SHIFT_SELECT);
	AR_WRITE_BARRIER(sc);

	/* Program synthesizer. */
	phy = (chansel << 2) | AR9380_FRACMODE;
	DPRINTFN(4, ("AR_PHY_65NM_CH0_SYNTH7=0x%08x\n", phy));
	AR_WRITE(sc, AR_PHY_65NM_CH0_SYNTH7, phy);
	AR_WRITE_BARRIER(sc);
	/* Toggle Load Synth Channel bit. */
	AR_WRITE(sc, AR_PHY_65NM_CH0_SYNTH7, phy | AR9380_LOAD_SYNTH);
	AR_WRITE_BARRIER(sc);
	return (0);
}

void
ar9380_init_from_rom(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar9380_eeprom *eep = sc->eep;
	const struct ar9380_modal_eep_header *modal;
	uint8_t db, margin, ant_div_ctrl;
	uint32_t reg;
	int i, maxchains;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		modal = &eep->modalHeader2G;
	else
		modal = &eep->modalHeader5G;

	/* Apply XPA bias level. */
	if (AR_SREV_9485(sc)) {
		reg = AR_READ(sc, AR9485_PHY_65NM_CH0_TOP2);
		reg = RW(reg, AR9485_PHY_65NM_CH0_TOP2_XPABIASLVL,
		    modal->xpaBiasLvl);
		AR_WRITE(sc, AR9485_PHY_65NM_CH0_TOP2, reg);
	} else {
		reg = AR_READ(sc, AR_PHY_65NM_CH0_TOP);
		reg = RW(reg, AR_PHY_65NM_CH0_TOP_XPABIASLVL,
		    modal->xpaBiasLvl & 0x3);
		AR_WRITE(sc, AR_PHY_65NM_CH0_TOP, reg);
		reg = AR_READ(sc, AR_PHY_65NM_CH0_THERM);
		reg = RW(reg, AR_PHY_65NM_CH0_THERM_XPABIASLVL_MSB,
		    modal->xpaBiasLvl >> 2);
		reg |= AR_PHY_65NM_CH0_THERM_XPASHORT2GND;
		AR_WRITE(sc, AR_PHY_65NM_CH0_THERM, reg);
	}

	/* Apply antenna control. */
	reg = AR_READ(sc, AR_PHY_SWITCH_COM);
	reg = RW(reg, AR_SWITCH_TABLE_COM_ALL, modal->antCtrlCommon);
	AR_WRITE(sc, AR_PHY_SWITCH_COM, reg);
	reg = AR_READ(sc, AR_PHY_SWITCH_COM_2);
	reg = RW(reg, AR_SWITCH_TABLE_COM_2_ALL, modal->antCtrlCommon2);
	AR_WRITE(sc, AR_PHY_SWITCH_COM_2, reg);

	maxchains = AR_SREV_9485(sc) ? 1 : AR9380_MAX_CHAINS;
	for (i = 0; i < maxchains; i++) {
		reg = AR_READ(sc, AR_PHY_SWITCH_CHAIN(i));
		reg = RW(reg, AR_SWITCH_TABLE_ALL, modal->antCtrlChain[i]);
		AR_WRITE(sc, AR_PHY_SWITCH_CHAIN(i), reg);
	}

	if (AR_SREV_9485(sc)) {
		ant_div_ctrl = eep->base_ext1.ant_div_control;
		reg = AR_READ(sc, AR_PHY_MC_GAIN_CTRL);
		reg = RW(reg, AR_PHY_MC_GAIN_CTRL_ANT_DIV_CTRL_ALL,
		    MS(ant_div_ctrl, AR_EEP_ANT_DIV_CTRL_ALL));
		if (ant_div_ctrl & AR_EEP_ANT_DIV_CTRL_ANT_DIV)
			reg |= AR_PHY_MC_GAIN_CTRL_ENABLE_ANT_DIV;
		else
			reg &= ~AR_PHY_MC_GAIN_CTRL_ENABLE_ANT_DIV;
		AR_WRITE(sc, AR_PHY_MC_GAIN_CTRL, reg);
		reg = AR_READ(sc, AR_PHY_CCK_DETECT);
		if (ant_div_ctrl & AR_EEP_ANT_DIV_CTRL_FAST_DIV)
			reg |= AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;
		else
			reg &= ~AR_PHY_CCK_DETECT_BB_ENABLE_ANT_FAST_DIV;
		AR_WRITE(sc, AR_PHY_CCK_DETECT, reg);
	}

	if (eep->baseEepHeader.miscConfiguration & AR_EEP_DRIVE_STRENGTH) {
		/* Apply drive strength. */
		reg = AR_READ(sc, AR_PHY_65NM_CH0_BIAS1);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_0, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_1, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_2, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_3, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_4, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS1_5, 5);
		AR_WRITE(sc, AR_PHY_65NM_CH0_BIAS1, reg);

		reg = AR_READ(sc, AR_PHY_65NM_CH0_BIAS2);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_0, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_1, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_2, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_3, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_4, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_5, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_6, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_7, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS2_8, 5);
		AR_WRITE(sc, AR_PHY_65NM_CH0_BIAS2, reg);

		reg = AR_READ(sc, AR_PHY_65NM_CH0_BIAS4);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS4_0, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS4_1, 5);
		reg = RW(reg, AR_PHY_65NM_CH0_BIAS4_2, 5);
		AR_WRITE(sc, AR_PHY_65NM_CH0_BIAS4, reg);
	}

	/* Apply attenuation settings. */
	maxchains = AR_SREV_9485(sc) ? 1 : AR9380_MAX_CHAINS;
	for (i = 0; i < maxchains; i++) {
		if (IEEE80211_IS_CHAN_5GHZ(c) &&
		    eep->base_ext2.xatten1DBLow[i] != 0) {
			if (c->ic_freq <= 5500) {
				db = athn_interpolate(c->ic_freq,
				    5180, eep->base_ext2.xatten1DBLow[i],
				    5500, modal->xatten1DB[i]);
			} else {
				db = athn_interpolate(c->ic_freq,
				    5500, modal->xatten1DB[i],
				    5785, eep->base_ext2.xatten1DBHigh[i]);
			}
		} else
			db = modal->xatten1DB[i];
		if (IEEE80211_IS_CHAN_5GHZ(c) &&
		    eep->base_ext2.xatten1MarginLow[i] != 0) {
			if (c->ic_freq <= 5500) {
				margin = athn_interpolate(c->ic_freq,
				    5180, eep->base_ext2.xatten1MarginLow[i],
				    5500, modal->xatten1Margin[i]);
			} else {
				margin = athn_interpolate(c->ic_freq,
				    5500, modal->xatten1Margin[i],
				    5785, eep->base_ext2.xatten1MarginHigh[i]);
			}
		} else
			margin = modal->xatten1Margin[i];
		reg = AR_READ(sc, AR_PHY_EXT_ATTEN_CTL(i));
		reg = RW(reg, AR_PHY_EXT_ATTEN_CTL_XATTEN1_DB, db);
		reg = RW(reg, AR_PHY_EXT_ATTEN_CTL_XATTEN1_MARGIN, margin);
		AR_WRITE(sc, AR_PHY_EXT_ATTEN_CTL(i), reg);
	}

	/* Initialize switching regulator. */
	if (AR_SREV_9485(sc))
		ar9485_init_swreg(sc);
	else
		ar9485_init_swreg(sc);

	/* Apply tuning capabilities. */
	if (AR_SREV_9485(sc) &&
	    (eep->baseEepHeader.featureEnable & AR_EEP_TUNING_CAPS)) {
		reg = AR_READ(sc, AR9485_PHY_CH0_XTAL);
		reg = RW(reg, AR9485_PHY_CH0_XTAL_CAPINDAC,
		    eep->baseEepHeader.params_for_tuning_caps[0]);
		reg = RW(reg, AR9485_PHY_CH0_XTAL_CAPOUTDAC,
		    eep->baseEepHeader.params_for_tuning_caps[0]);
		AR_WRITE(sc, AR9485_PHY_CH0_XTAL, reg);
	}
	AR_WRITE_BARRIER(sc);
}

void
ar9380_init_swreg(struct athn_softc *sc)
{
	const struct ar9380_eeprom *eep = sc->eep;

	if (eep->baseEepHeader.featureEnable & AR_EEP_INTERNAL_REGULATOR) {
		/* Internal regulator is ON. */
		AR_CLRBITS(sc, AR_RTC_REG_CONTROL1,
		    AR_RTC_REG_CONTROL1_SWREG_PROGRAM);
		AR_WRITE(sc, AR_RTC_REG_CONTROL0, eep->baseEepHeader.swreg);
		AR_SETBITS(sc, AR_RTC_REG_CONTROL1,
		    AR_RTC_REG_CONTROL1_SWREG_PROGRAM);
	} else
		AR_SETBITS(sc, AR_RTC_SLEEP_CLK, AR_RTC_FORCE_SWREG_PRD);
	AR_WRITE_BARRIER(sc);
}

int
ar9485_pmu_write(struct athn_softc *sc, uint32_t addr, uint32_t val)
{
	int ntries;

	AR_WRITE(sc, addr, val);
	/* Wait for write to complete. */
	for (ntries = 0; ntries < 100; ntries++) {
		if (AR_READ(sc, addr) == val)
			return (0);
		AR_WRITE(sc, addr, val);	/* Insist. */
		AR_WRITE_BARRIER(sc);
		DELAY(10);
	}
	return (ETIMEDOUT);
}

#define ar9486_pmu_read	AR_READ

void
ar9485_init_swreg(struct athn_softc *sc)
{
	const struct ar9380_eeprom *eep = sc->eep;
	uint32_t reg;

	ar9485_pmu_write(sc, AR_PHY_PMU2,
	    ar9486_pmu_read(sc, AR_PHY_PMU2) & ~AR_PHY_PMU2_PGM);

	if (eep->baseEepHeader.featureEnable & AR_EEP_INTERNAL_REGULATOR) {
		ar9485_pmu_write(sc, AR_PHY_PMU1, 0x131dc17a);

		reg = ar9486_pmu_read(sc, AR_PHY_PMU2);
		reg = (reg & ~0xffc00000) | 0x10000000;
		ar9485_pmu_write(sc, AR_PHY_PMU2, reg);
	} else {
		ar9485_pmu_write(sc, AR_PHY_PMU1,
		    ar9486_pmu_read(sc, AR_PHY_PMU1) | AR_PHY_PMU1_PWD);
	}

	ar9485_pmu_write(sc, AR_PHY_PMU2,
	    ar9486_pmu_read(sc, AR_PHY_PMU2) | AR_PHY_PMU2_PGM);
}

void
ar9380_spur_mitigate_cck(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	/* NB: It is safe to call this function for 5GHz channels. */
	static const int16_t freqs[] = { 2420, 2440, 2464, 2480 };
	int i, spur, freq;
	uint32_t reg;

	for (i = 0; i < nitems(freqs); i++) {
		spur = freqs[i] - c->ic_freq;
		if (abs(spur) < 10)	/* +/- 10MHz range. */
			break;
	}
	if (i == nitems(freqs)) {
		/* Disable CCK spur mitigation. */
		reg = AR_READ(sc, AR_PHY_AGC_CONTROL);
		reg = RW(reg, AR_PHY_AGC_CONTROL_YCOK_MAX, 0x5);
		AR_WRITE(sc, AR_PHY_AGC_CONTROL, reg);
		reg = AR_READ(sc, AR_PHY_CCK_SPUR_MIT);
		reg = RW(reg, AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ, 0);
		reg &= ~AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT;
		AR_WRITE(sc, AR_PHY_CCK_SPUR_MIT, reg);
		AR_WRITE_BARRIER(sc);
		return;
	}
	freq = (spur * 524288) / 11;

	reg = AR_READ(sc, AR_PHY_AGC_CONTROL);
	reg = RW(reg, AR_PHY_AGC_CONTROL_YCOK_MAX, 0x7);
	AR_WRITE(sc, AR_PHY_AGC_CONTROL, reg);

	reg = AR_READ(sc, AR_PHY_CCK_SPUR_MIT);
	reg = RW(reg, AR_PHY_CCK_SPUR_MIT_CCK_SPUR_FREQ, freq);
	reg = RW(reg, AR_PHY_CCK_SPUR_MIT_SPUR_RSSI_THR, 0x7f);
	reg = RW(reg, AR_PHY_CCK_SPUR_MIT_SPUR_FILTER_TYPE, 0x2);
	reg |= AR_PHY_CCK_SPUR_MIT_USE_CCK_SPUR_MIT;
	AR_WRITE(sc, AR_PHY_CCK_SPUR_MIT, reg);
	AR_WRITE_BARRIER(sc);
}

void
ar9380_spur_mitigate_ofdm(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar9380_eeprom *eep = sc->eep;
	const uint8_t *spurchans;
	uint32_t reg;
	int idx, spur_delta_phase, spur_off, range, i;
	int freq, spur, spur_freq_sd, spur_subchannel_sd;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		spurchans = eep->modalHeader2G.spurChans;
	else
		spurchans = eep->modalHeader5G.spurChans;
	if (spurchans[0] == 0)
		return;

	/* Disable OFDM spur mitigation. */
	AR_CLRBITS(sc, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_FILTER);

	reg = AR_READ(sc, AR_PHY_TIMING11);
	reg = RW(reg, AR_PHY_TIMING11_SPUR_FREQ_SD, 0);
	reg = RW(reg, AR_PHY_TIMING11_SPUR_DELTA_PHASE, 0);
	reg &= ~AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC;
	reg &= ~AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR;
	AR_WRITE(sc, AR_PHY_TIMING11, reg);

	AR_CLRBITS(sc, AR_PHY_SFCORR_EXT,
	    AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD);

	AR_CLRBITS(sc, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_RSSI);

	reg = AR_READ(sc, AR_PHY_SPUR_REG);
	reg = RW(reg, AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0);
	reg &= ~AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI;
	reg &= ~AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT;
	reg &= ~AR_PHY_SPUR_REG_ENABLE_MASK_PPM;
	AR_WRITE(sc, AR_PHY_SPUR_REG, reg);
	AR_WRITE_BARRIER(sc);

	freq = c->ic_freq;
	if (extc != NULL) {
		range = 19;	/* +/- 19MHz range. */
		if (AR_READ(sc, AR_PHY_GEN_CTRL) & AR_PHY_GC_DYN2040_PRI_CH)
			freq += 10;
		else
			freq -= 10;
	} else
		range = 10;	/* +/- 10MHz range. */
	for (i = 0; i < AR9380_EEPROM_MODAL_SPURS; i++) {
		spur = spurchans[i];
		if (spur == 0)
			return;
		/* Convert to frequency. */
		if (IEEE80211_IS_CHAN_2GHZ(c))
			spur = 2300 + spur;
		else
			spur = 4900 + (spur * 5);
		spur -= freq;
		if (abs(spur) < range)
			break;
	}
	if (i == AR9380_EEPROM_MODAL_SPURS)
		return;

	/* Enable OFDM spur mitigation. */
	if (extc != NULL) {
		spur_delta_phase = (spur * 131072) / 5;
		reg = AR_READ(sc, AR_PHY_GEN_CTRL);
		if (spur < 0) {
			spur_subchannel_sd =
			    (reg & AR_PHY_GC_DYN2040_PRI_CH) == 0;
			spur_off = spur + 10;
		} else {
			spur_subchannel_sd =
			    (reg & AR_PHY_GC_DYN2040_PRI_CH) != 0;
			spur_off = spur - 10;
		}
	} else {
		spur_delta_phase = (spur * 262144) / 5;
		spur_subchannel_sd = 0;
		spur_off = spur;
	}
	spur_freq_sd = (spur_off * 512) / 11;

	AR_SETBITS(sc, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_FILTER);

	reg = AR_READ(sc, AR_PHY_TIMING11);
	reg = RW(reg, AR_PHY_TIMING11_SPUR_FREQ_SD, spur_freq_sd);
	reg = RW(reg, AR_PHY_TIMING11_SPUR_DELTA_PHASE, spur_delta_phase);
	reg |= AR_PHY_TIMING11_USE_SPUR_FILTER_IN_AGC;
	reg |= AR_PHY_TIMING11_USE_SPUR_FILTER_IN_SELFCOR;
	AR_WRITE(sc, AR_PHY_TIMING11, reg);

	reg = AR_READ(sc, AR_PHY_SFCORR_EXT);
	if (spur_subchannel_sd)
		reg |= AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD;
	else
		reg &= ~AR_PHY_SFCORR_EXT_SPUR_SUBCHANNEL_SD;
	AR_WRITE(sc, AR_PHY_SFCORR_EXT, reg);

	AR_SETBITS(sc, AR_PHY_TIMING4, AR_PHY_TIMING4_ENABLE_SPUR_RSSI);

	reg = AR_READ(sc, AR_PHY_SPUR_REG);
	reg = RW(reg, AR_PHY_SPUR_REG_MASK_RATE_CNTL, 0xff);
	reg = RW(reg, AR_PHY_SPUR_REG_SPUR_RSSI_THRESH, 34);
	reg |= AR_PHY_SPUR_REG_EN_VIT_SPUR_RSSI;
	if (AR_READ(sc, AR_PHY_MODE) & AR_PHY_MODE_DYNAMIC)
		reg |= AR_PHY_SPUR_REG_ENABLE_NF_RSSI_SPUR_MIT;
	reg |= AR_PHY_SPUR_REG_ENABLE_MASK_PPM;
	AR_WRITE(sc, AR_PHY_SPUR_REG, reg);

	idx = (spur * 16) / 5;
	if (idx < 0)
		idx--;

	/* Write pilot mask. */
	AR_SETBITS(sc, AR_PHY_TIMING4,
	    AR_PHY_TIMING4_ENABLE_PILOT_MASK |
	    AR_PHY_TIMING4_ENABLE_CHAN_MASK);

	reg = AR_READ(sc, AR_PHY_PILOT_SPUR_MASK);
	reg = RW(reg, AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_IDX_A, idx);
	reg = RW(reg, AR_PHY_PILOT_SPUR_MASK_CF_PILOT_MASK_A, 0x0c);
	AR_WRITE(sc, AR_PHY_PILOT_SPUR_MASK, reg);

	reg = AR_READ(sc, AR_PHY_SPUR_MASK_A);
	reg = RW(reg, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_IDX_A, idx);
	reg = RW(reg, AR_PHY_SPUR_MASK_A_CF_PUNC_MASK_A, 0xa0);
	AR_WRITE(sc, AR_PHY_SPUR_MASK_A, reg);

	reg = AR_READ(sc, AR_PHY_CHAN_SPUR_MASK);
	reg = RW(reg, AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_IDX_A, idx);
	reg = RW(reg, AR_PHY_CHAN_SPUR_MASK_CF_CHAN_MASK_A, 0x0c);
	AR_WRITE(sc, AR_PHY_CHAN_SPUR_MASK, reg);
	AR_WRITE_BARRIER(sc);
}

void
ar9380_spur_mitigate(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	/* NB: We call spur_mitigate_cck for 5GHz too, just to disable it. */
	ar9380_spur_mitigate_cck(sc, c, extc);
	ar9380_spur_mitigate_ofdm(sc, c, extc);
}

void
ar9380_set_txpower(struct athn_softc *sc, struct ieee80211_channel *c,
    struct ieee80211_channel *extc)
{
	const struct ar9380_eeprom *eep = sc->eep;
	uint8_t tpow_cck[4], tpow_ofdm[4];
	uint8_t tpow_ht20[14], tpow_ht40[14];
	int16_t power[ATHN_POWER_COUNT];

	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		/* Get CCK target powers. */
		ar9003_get_lg_tpow(sc, c, AR_CTL_11B,
		    eep->calTargetFbinCck, eep->calTargetPowerCck,
		    AR9380_NUM_2G_CCK_TARGET_POWERS, tpow_cck);

		/* Get OFDM target powers. */
		ar9003_get_lg_tpow(sc, c, AR_CTL_11G,
		    eep->calTargetFbin2G, eep->calTargetPower2G,
		    AR9380_NUM_2G_20_TARGET_POWERS, tpow_ofdm);

		/* Get HT-20 target powers. */
		ar9003_get_ht_tpow(sc, c, AR_CTL_2GHT20,
		    eep->calTargetFbin2GHT20, eep->calTargetPower2GHT20,
		    AR9380_NUM_2G_20_TARGET_POWERS, tpow_ht20);

		if (extc != NULL) {
			/* Get HT-40 target powers. */
			ar9003_get_ht_tpow(sc, c, AR_CTL_2GHT40,
			    eep->calTargetFbin2GHT40,
			    eep->calTargetPower2GHT40,
			    AR9380_NUM_2G_40_TARGET_POWERS, tpow_ht40);
		}
	} else {
		/* Get OFDM target powers. */
		ar9003_get_lg_tpow(sc, c, AR_CTL_11A,
		    eep->calTargetFbin5G, eep->calTargetPower5G,
		    AR9380_NUM_5G_20_TARGET_POWERS, tpow_ofdm);

		/* Get HT-20 target powers. */
		ar9003_get_ht_tpow(sc, c, AR_CTL_5GHT20,
		    eep->calTargetFbin5GHT20, eep->calTargetPower5GHT20,
		    AR9380_NUM_5G_20_TARGET_POWERS, tpow_ht20);

		if (extc != NULL) {
			/* Get HT-40 target powers. */
			ar9003_get_ht_tpow(sc, c, AR_CTL_5GHT40,
			    eep->calTargetFbin5GHT40,
			    eep->calTargetPower5GHT40,
			    AR9380_NUM_5G_40_TARGET_POWERS, tpow_ht40);
		}
	}

	memset(power, 0, sizeof(power));
	/* Shuffle target powers accross transmit rates. */
	power[ATHN_POWER_OFDM6 ] =
	power[ATHN_POWER_OFDM9 ] =
	power[ATHN_POWER_OFDM12] =
	power[ATHN_POWER_OFDM18] =
	power[ATHN_POWER_OFDM24] = tpow_ofdm[0];
	power[ATHN_POWER_OFDM36] = tpow_ofdm[1];
	power[ATHN_POWER_OFDM48] = tpow_ofdm[2];
	power[ATHN_POWER_OFDM54] = tpow_ofdm[3];
	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		power[ATHN_POWER_CCK1_LP ] =
		power[ATHN_POWER_CCK2_LP ] =
		power[ATHN_POWER_CCK2_SP ] =
		power[ATHN_POWER_CCK55_LP] = tpow_cck[0];
		power[ATHN_POWER_CCK55_SP] = tpow_cck[1];
		power[ATHN_POWER_CCK11_LP] = tpow_cck[2];
		power[ATHN_POWER_CCK11_SP] = tpow_cck[3];
	}
	/* Next entry covers MCS0, MCS8 and MCS16. */
	power[ATHN_POWER_HT20( 0)] = tpow_ht20[ 0];
	/* Next entry covers MCS1-3, MCS9-11 and MCS17-19. */
	power[ATHN_POWER_HT20( 1)] = tpow_ht20[ 1];
	power[ATHN_POWER_HT20( 4)] = tpow_ht20[ 2];
	power[ATHN_POWER_HT20( 5)] = tpow_ht20[ 3];
	power[ATHN_POWER_HT20( 6)] = tpow_ht20[ 4];
	power[ATHN_POWER_HT20( 7)] = tpow_ht20[ 5];
	power[ATHN_POWER_HT20(12)] = tpow_ht20[ 6];
	power[ATHN_POWER_HT20(13)] = tpow_ht20[ 7];
	power[ATHN_POWER_HT20(14)] = tpow_ht20[ 8];
	power[ATHN_POWER_HT20(15)] = tpow_ht20[ 9];
	power[ATHN_POWER_HT20(20)] = tpow_ht20[10];
	power[ATHN_POWER_HT20(21)] = tpow_ht20[11];
	power[ATHN_POWER_HT20(22)] = tpow_ht20[12];
	power[ATHN_POWER_HT20(23)] = tpow_ht20[13];
	if (extc != NULL) {
		/* Next entry covers MCS0, MCS8 and MCS16. */
		power[ATHN_POWER_HT40( 0)] = tpow_ht40[ 0];
		/* Next entry covers MCS1-3, MCS9-11 and MCS17-19. */
		power[ATHN_POWER_HT40( 1)] = tpow_ht40[ 1];
		power[ATHN_POWER_HT40( 4)] = tpow_ht40[ 2];
		power[ATHN_POWER_HT40( 5)] = tpow_ht40[ 3];
		power[ATHN_POWER_HT40( 6)] = tpow_ht40[ 4];
		power[ATHN_POWER_HT40( 7)] = tpow_ht40[ 5];
		power[ATHN_POWER_HT40(12)] = tpow_ht40[ 6];
		power[ATHN_POWER_HT40(13)] = tpow_ht40[ 7];
		power[ATHN_POWER_HT40(14)] = tpow_ht40[ 8];
		power[ATHN_POWER_HT40(15)] = tpow_ht40[ 9];
		power[ATHN_POWER_HT40(20)] = tpow_ht40[10];
		power[ATHN_POWER_HT40(21)] = tpow_ht40[11];
		power[ATHN_POWER_HT40(22)] = tpow_ht40[12];
		power[ATHN_POWER_HT40(23)] = tpow_ht40[13];
	}

	/* Write transmit power values to hardware. */
	ar9003_write_txpower(sc, power);

	/* Apply transmit power correction. */
	ar9380_set_correction(sc, c);
}

void
ar9380_get_correction(struct athn_softc *sc, struct ieee80211_channel *c,
    int chain, int *corr, int *temp)
{
	const struct ar9380_eeprom *eep = sc->eep;
	const struct ar9380_cal_data_per_freq_op_loop *pierdata;
	const uint8_t *pierfreq;
	uint8_t fbin;
	int lo, hi, npiers;

	if (IEEE80211_IS_CHAN_2GHZ(c)) {
		pierfreq = eep->calFreqPier2G;
		pierdata = eep->calPierData2G[chain];
		npiers = AR9380_NUM_2G_CAL_PIERS;
	} else {
		pierfreq = eep->calFreqPier5G;
		pierdata = eep->calPierData5G[chain];
		npiers = AR9380_NUM_5G_CAL_PIERS;
	}
	/* Find channel in ROM pier table. */
	fbin = athn_chan2fbin(c);
	athn_get_pier_ival(fbin, pierfreq, npiers, &lo, &hi);

	*corr = athn_interpolate(fbin,
	    pierfreq[lo], pierdata[lo].refPower,
	    pierfreq[hi], pierdata[hi].refPower);
	*temp = athn_interpolate(fbin,
	    pierfreq[lo], pierdata[lo].tempMeas,
	    pierfreq[hi], pierdata[hi].tempMeas);
}

void
ar9380_set_correction(struct athn_softc *sc, struct ieee80211_channel *c)
{
	const struct ar9380_eeprom *eep = sc->eep;
	const struct ar9380_modal_eep_header *modal;
	uint32_t reg;
	int8_t slope;
	int i, corr, temp, temp0;

	if (IEEE80211_IS_CHAN_2GHZ(c))
		modal = &eep->modalHeader2G;
	else
		modal = &eep->modalHeader5G;

	for (i = 0; i < AR9380_MAX_CHAINS; i++) {
		ar9380_get_correction(sc, c, i, &corr, &temp);
		if (i == 0)
			temp0 = temp;

		reg = AR_READ(sc, AR_PHY_TPC_11_B(i));
		reg = RW(reg, AR_PHY_TPC_11_OLPC_GAIN_DELTA, corr);
		AR_WRITE(sc, AR_PHY_TPC_11_B(i), reg);

		/* Enable open loop power control. */
		reg = AR_READ(sc, AR_PHY_TPC_6_B(i));
		reg = RW(reg, AR_PHY_TPC_6_ERROR_EST_MODE, 3);
		AR_WRITE(sc, AR_PHY_TPC_6_B(i), reg);
	}

	/* Enable temperature compensation. */
	if (IEEE80211_IS_CHAN_5GHZ(c) &&
	    eep->base_ext2.tempSlopeLow != 0) {
		if (c->ic_freq <= 5500) {
			slope = athn_interpolate(c->ic_freq,
			    5180, eep->base_ext2.tempSlopeLow,
			    5500, modal->tempSlope);
		} else {
			slope = athn_interpolate(c->ic_freq,
			    5500, modal->tempSlope,
			    5785, eep->base_ext2.tempSlopeHigh);
		}
	} else
		slope = modal->tempSlope;

	reg = AR_READ(sc, AR_PHY_TPC_19);
	reg = RW(reg, AR_PHY_TPC_19_ALPHA_THERM, slope);
	AR_WRITE(sc, AR_PHY_TPC_19, reg);

	reg = AR_READ(sc, AR_PHY_TPC_18);
	reg = RW(reg, AR_PHY_TPC_18_THERM_CAL, temp0);
	AR_WRITE(sc, AR_PHY_TPC_18, reg);
	AR_WRITE_BARRIER(sc);
}
@


1.24
log
@Remove the IEEE80211_NO_HT macro. Reduces ifdef spaghetti, enables 11n mode
in bsd.rd, and might uncover some bugs. Suggested by tedu@@ and deraadt@@.
ok sthen@@ jasper@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.23 2015/11/24 17:11:39 mpi Exp $	*/
d52 1
@


1.23
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.22 2015/11/24 13:45:06 mpi Exp $	*/
a584 1
#ifndef IEEE80211_NO_HT
a591 1
#endif
a609 1
#ifndef IEEE80211_NO_HT
d622 1
a622 3
	} else
#endif
	{
@


1.22
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.21 2015/11/24 13:33:17 mpi Exp $	*/
a44 1
#include <net/if_dl.h>
@


1.21
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.20 2014/12/19 22:44:58 guenther Exp $	*/
a44 1
#include <net/if_arp.h>
@


1.20
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.19 2014/07/22 13:12:11 mpi Exp $	*/
a47 1
#include <net/if_types.h>
@


1.19
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.18 2013/08/07 01:06:28 bluhm Exp $	*/
d37 1
a39 1
#include <machine/endian.h>
@


1.18
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.17 2012/10/20 09:54:20 stsp Exp $	*/
a50 1
#include <netinet/in_systm.h>
@


1.17
log
@Init values for the AR9485 were for version 1.0 of this chip, which according
to Atheros Linux developers was never sold. So update initvals to what Linux
is using for the 1.1 generation. Because the serdes values are written to
different registers on the AR9485 this involves tweaking the serdes init code
for all athn(4) chip families. This commit doesn't make AR9485 devices work
yet but is a step in the right direction.

Tested by krw, kettenis, and Andrew Ngo.  ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.16 2012/10/20 09:53:32 stsp Exp $	*/
a51 1
#include <netinet/in_var.h>
@


1.16
log
@Fix hardware kill switch detection for the ar9300 chip family. The driver was
checking the wrong bits of eeprom to determine rfkill switch pin and polarity,
and was reading the wrong register to determine rfkill gpio pin state.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.15 2012/06/10 21:23:36 kettenis Exp $	*/
d120 4
a123 3
	if (AR_SREV_9485(sc))
		sc->ini = &ar9485_1_0_ini;
	else
d125 2
a126 1
	sc->serdes = &ar9380_2_2_serdes;
d188 1
a188 1
		sc->rx_gain = &ar9485_1_0_rx_gain;
d202 1
a202 1
		sc->tx_gain = &ar9485_1_0_tx_gain;
@


1.15
log
@Allow a variable number of words for the Serializer/Deserializer programming.
Probably not enought to make the AR9380 chips to work, but at least the kernel
shouldn't crash anymore when we see one.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.14 2011/04/07 14:19:53 miod Exp $	*/
d151 5
a155 1
		sc->rfsilent_pin = base->wlanDisableGpio;
@


1.14
log
@Make sure the eeprom pointer is correctly initialized in
ar9380_spur_mitigate_ofdm().
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.13 2011/01/05 21:31:34 damien Exp $	*/
d124 1
@


1.13
log
@cosmetic, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.12 2011/01/01 14:25:03 damien Exp $	*/
d546 1
a546 1
	const struct ar9380_eeprom *eep;
@


1.12
log
@cleanup, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.11 2011/01/01 13:44:42 damien Exp $	*/
d494 1
a494 1
		    AR_READ(sc, AR_PHY_PMU1) | AR_PHY_PMU1_PWD);
@


1.11
log
@more AR9380/AR9485 bits.
add Tx gain initvals for high-power AR9380 solutions.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.10 2011/01/01 10:48:31 damien Exp $	*/
d475 2
d484 1
a484 1
	    AR_READ(sc, AR_PHY_PMU2) & ~AR_PHY_PMU2_PGM);
d489 1
a489 1
		reg = AR_READ(sc, AR_PHY_PMU2);
d498 1
a498 1
	    AR_READ(sc, AR_PHY_PMU2) | AR_PHY_PMU2_PGM);
@


1.10
log
@add code to read OTPROM on the AR9485
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.9 2010/12/31 21:23:55 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2010 Damien Bergamini <damien.bergamini@@free.fr>
d75 3
d120 4
a123 1
	sc->ini = &ar9380_2_2_ini;
d175 7
a181 4
	if (type == AR_EEP_RX_GAIN_WO_XLNA)
		sc->rx_gain = &ar9380_2_2_rx_gain_wo_xlna;
	else
		sc->rx_gain = &ar9380_2_2_rx_gain;
d185 11
a195 6
	if (type == AR_EEP_TX_GAIN_HIGH_OB_DB)
		sc->tx_gain = &ar9380_2_2_tx_gain_high_ob_db;
	else if (type == AR_EEP_TX_GAIN_LOW_OB_DB)
		sc->tx_gain = &ar9380_2_2_tx_gain_low_ob_db;
	else
		sc->tx_gain = &ar9380_2_2_tx_gain;
d264 4
a267 1
		chansel = (freq << 16) / 15;
d297 1
a297 1
	uint8_t db, margin;
d299 1
a299 1
	int i;
d307 16
a322 9
	reg = AR_READ(sc, AR_PHY_65NM_CH0_TOP);
	reg = RW(reg, AR_PHY_65NM_CH0_TOP_XPABIASLVL,
	    modal->xpaBiasLvl & 0x3);
	AR_WRITE(sc, AR_PHY_65NM_CH0_TOP, reg);
	reg = AR_READ(sc, AR_PHY_65NM_CH0_THERM);
	reg = RW(reg, AR_PHY_65NM_CH0_THERM_XPABIASLVL_MSB,
	    modal->xpaBiasLvl >> 2);
	reg |= AR_PHY_65NM_CH0_THERM_XPASHORT2GND;
	AR_WRITE(sc, AR_PHY_65NM_CH0_THERM, reg);
d332 2
a333 1
	for (i = 0; i < AR9380_MAX_CHAINS; i++) {
d339 18
d360 6
a365 1
		reg = (reg & ~0x00ffffc0) | 0x00b6db40;
d369 9
a377 1
		reg = (reg & ~0xffffffe0) | 0xb6db6da0;
d381 3
a383 1
		reg = (reg & ~0xff800000) | 0xb6800000;
d388 2
a389 1
	for (i = 0; i < AR9380_MAX_CHAINS; i++) {
d422 24
d456 41
@


1.9
log
@limit the number of Tx chains used on some 3-stream AR9380 chips
for MCS0~15 to not exceed the PCIe power requirements.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.8 2010/12/31 14:06:05 damien Exp $	*/
a103 2
	sc->eep_base = AR9380_EEP_START_LOC;
	sc->eep_size = sizeof(struct ar9380_eeprom);
@


1.8
log
@Make the athn(4) back-end more bus agnostic by moving read and write
operations to callbacks in the PCI and CardBus front-ends.
This will allow support of other buses like USB.
Assume the following memory model:
- writes are ordered but may be buffered and require explicit flush
- a read always flushes all buffered writes
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.7 2010/11/10 21:06:44 damien Exp $	*/
d22 1
a22 1
 * Routines for AR9380 and AR9381 chipsets.
d161 7
@


1.7
log
@Several updates for the Osprey (AR9380):
- Add the different ROM templates for the different chips
- Fix AR_PHY_65NM_CH0_TOP_XPABIASLVL definition
- Apply attenuation settings from the ROM
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.6 2010/10/18 16:05:28 damien Exp $	*/
d256 1
d262 1
d265 1
d367 1
d393 1
d408 1
d449 1
d551 1
d758 1
@


1.6
log
@remove v2.0 initialization values for the Osprey.
this is a pre-production chip.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.5 2010/06/21 19:54:28 damien Exp $	*/
d67 1
a105 1
	sc->eep_def = ar9380_def_rom;
d108 1
d179 12
d272 1
d284 1
a284 1
	    MS(modal->xpaBiasLvl, AR_EEP_XPABIASLVL));
d287 3
a289 2
	reg = RW(reg, AR_PHY_65NM_CH0_THERM_SPARE,
	    MS(modal->xpaBiasLvl, AR_EEP_THERM_SPARE));
d321 34
d703 1
d708 5
d729 13
a741 4
	if (IEEE80211_IS_CHAN_2GHZ(c))
		slope = eep->modalHeader2G.tempSlope;
	else
		slope = eep->modalHeader5G.tempSlope;
@


1.5
log
@Implement PA linearization on adapters with digital predistorters
(AR9003 family only).

The power amplifier predistortion state machine works as follows:
1) Disable digital predistorters for all Tx chains
2) Repeat steps 3~7 for all Tx chains
3)   Force Tx gain to that of training signal
4)   Send training signal (asynchronous)
5)   Wait for training signal to complete (asynchronous)
6)   Read PA measurements (input power, output power, output phase)
7)   Compute the predistortion function that linearizes PA output
8) Write predistortion functions to hardware tables for all Tx chains
9) Enable digital predistorters for all Tx chains

from ath9k (though implementation differs a lot)
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.4 2010/05/13 09:03:12 damien Exp $	*/
d118 1
a118 4
	if (AR_SREV_9380_20(sc))
		sc->ini = &ar9380_2_0_ini;
	else
		sc->ini = &ar9380_2_2_ini;
d163 5
a167 11
	if (AR_SREV_9380_20(sc)) {
		if (type == AR_EEP_RX_GAIN_WO_XLNA)
			sc->rx_gain = &ar9380_2_0_rx_gain_wo_xlna;
		else
			sc->rx_gain = &ar9380_2_0_rx_gain;
	} else {
		if (type == AR_EEP_RX_GAIN_WO_XLNA)
			sc->rx_gain = &ar9380_2_2_rx_gain_wo_xlna;
		else
			sc->rx_gain = &ar9380_2_2_rx_gain;
	}
d170 6
a175 15
	if (AR_SREV_9380_20(sc)) {
		if (type == AR_EEP_TX_GAIN_HIGH_OB_DB)
			sc->tx_gain = &ar9380_2_0_tx_gain_high_ob_db;
		else if (type == AR_EEP_TX_GAIN_LOW_OB_DB)
			sc->tx_gain = &ar9380_2_0_tx_gain_low_ob_db;
		else
			sc->tx_gain = &ar9380_2_0_tx_gain;
	} else {
		if (type == AR_EEP_TX_GAIN_HIGH_OB_DB)
			sc->tx_gain = &ar9380_2_2_tx_gain_high_ob_db;
		else if (type == AR_EEP_TX_GAIN_LOW_OB_DB)
			sc->tx_gain = &ar9380_2_2_tx_gain_low_ob_db;
		else
			sc->tx_gain = &ar9380_2_2_tx_gain;
	}
@


1.4
log
@initialization values for AR9380 2.2.
turns out the Rx gain tables are the same as 2.0 (and the Tx gain
registers too), which saves us a few bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.3 2010/05/11 19:34:20 damien Exp $	*/
d70 2
d113 1
d160 4
d212 2
d220 2
d227 15
a529 1
#ifndef IEEE80211_NO_HT
a530 1
#endif
a543 1
#ifndef IEEE80211_NO_HT
a555 1
#endif
a561 1
#ifndef IEEE80211_NO_HT
a573 1
#endif
a594 1
#ifndef IEEE80211_NO_HT
a628 1
#endif
d682 1
a682 1
		reg = RW(reg, AR_PHY_TPC_OLPC_GAIN_DELTA, corr);
d702 1
a702 1
	reg = RW(reg, AR_PHY_TPC_18_THERM_CAL_VALUE, temp0);
@


1.3
log
@enable fast PLL clock for 5GHz on AR9280 >=2.0 (unless EEPROM says the
opposite) and on AR9380 2.0.

tested on my AR9280 2.1 with a NETGEAR WNHDE111 AP.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.2 2010/05/11 17:59:39 damien Exp $	*/
d115 4
a118 1
	sc->ini = &ar9380_2_0_ini;
d159 11
a169 5
	if (type == AR_EEP_RX_GAIN_WO_XLNA)
		sc->rx_gain = &ar9380_2_0_rx_gain_wo_xlna;
	else
		sc->rx_gain = &ar9380_2_0_rx_gain;

d172 15
a186 6
	if (type == AR_EEP_TX_GAIN_HIGH_OB_DB)
		sc->tx_gain = &ar9380_2_0_tx_gain_high_ob_db;
	else if (type == AR_EEP_TX_GAIN_LOW_OB_DB)
		sc->tx_gain = &ar9380_2_0_tx_gain_low_ob_db;
	else
		sc->tx_gain = &ar9380_2_0_tx_gain;
@


1.2
log
@various AR9003 fixes (found during code inspection):
- the ROM deviceCap field is now 8 bits (instead of 16), so the number
  of entries in the key cache is always 0; just use the default value.
- AR_CR_RXE is equal to 0 on AR9003.
- do not use ``m'' unititialized in ar9003_rx_process.
- if an Rx descriptor is not valid (bad signature), skip it instead of
  leaving it at the head of the FIFO.
- update the Rx software descriptor with new virtual and physical address
  of Rx descritor when mapping a new buffer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ar9380.c,v 1.1 2010/05/10 17:44:21 damien Exp $	*/
d150 3
@


1.1
log
@athn(4) is going to support a new family of Atheros 802.11n
chips (AR9003), which differs from the currently supported
families (AR5008, AR9001 and AR9002).

The main differences (from a driver point of view) are:

* DMA:
Tx and Rx descriptors have changed.
A single Tx descriptor can now reference up to 4 scatter/gather
DMA segments.
There is now a DMA ring for reporting Tx status with separate
Tx status descriptors (this ring is used to report Tx status for
all the Tx FIFOs).
Rx status descriptors are now put at the beginning of Rx buffers
and do not need to be allocated separately from buffers.
There are two Rx FIFOs (low priority and high priority) instead
of one.

* ROM:
The AR9003 family uses OTP-ROM instead of EEPROM.
Reading the ROM is totally insane since vendors can provide only
the chunks of ROM that differ from a default image (and thus the
default image has to be stored in the driver).
This is referenced as "compressed ROM" in the Linux driver, though
there is no real compression involved, at least for the moment.

* PHY registers:
All PHY registers have changed.
Some registers offsets do not fit on 16 bits anymore, but
since they are 32-bit aligned, we can still make them fit on
16 bits to save .rodata space in initialization tables.

* MAC registers:
Some MAC registers offsets have changed (GPIO, interrupt masks)
which is quite annoying (though ~98% remain the same.)

* Initialization values:
Initialization values are now split in mac/soc/bb/radio blocks
and pre/core/post phases in the Linux driver.  I have chosen to
not go that road and merge these blocks in modal and non-modal
initialization values (similar to the other families).
The initialization order remains exactly the same as the Linux
driver though.

To manage these differences, I have split athn.c in two backends:
ar5008.c contains the bits that are specific to the AR5008,
AR9001 and AR9002 families (used by ar5416.c, ar9280.c,
ar9285.c and ar9287.c) and that were previously in athn.c.

ar9003.c contains the bits that are specific to the new
AR9003 family (used by ar9380.c only for now.)

I have introduced a thin hardware abstraction layer (actually
a set of pointers to functions) that is used in athn.c.
My intent is to keep this abstraction layer as thin as possible
and not to create another ugly pile of abstraction layers a la
MadWifi.

I think I've managed to keep things sane, probably at the expense
of duplicating some code in both ar5008.c and ar9003.c, but at
least we do not have to dig through layers and layers of virtual
descriptors to figure out what is mapped to the hardware.

Tested for non-regression on various AR5416 (sparc64+i386), AR9281
and AR9285 (i386 only) adapters.
AR9380 part is not tested (hardware is not available to the general
public yet).

Committed over my AR9285 2.0.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 1
a126 1
	uint8_t kc_entries_log, type;
d145 2
a146 4
	/* Get the number of HW key cache entries. */
	kc_entries_log = MS(base->deviceCap, AR_EEP_DEVCAP_KC_ENTRIES);
	sc->kc_entries = (kc_entries_log != 0) ?
	    1 << kc_entries_log : AR_KEYTABLE_SIZE;
d516 1
a516 1
		    eep->calTargetFbin2G, eep->calTargetPower5G,
@

