head	1.27;
access;
symbols
	OPENBSD_6_2_BASE:1.27
	OPENBSD_6_1:1.27.0.8
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.27.0.6
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.25.0.24
	OPENBSD_5_8_BASE:1.25
	OPENBSD_5_7:1.25.0.16
	OPENBSD_5_7_BASE:1.25
	OPENBSD_5_6:1.25.0.20
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.18
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.25.0.14
	OPENBSD_5_4_BASE:1.25
	OPENBSD_5_3:1.25.0.12
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.8
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.10
	OPENBSD_5_0:1.25.0.6
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.4
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.24.0.6
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.8
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.6
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.14.0.8
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.6
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.11.0.6
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.4
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.7.0.8
	OPENBSD_2_7_BASE:1.7
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5;
locks; strict;
comment	@ * @;


1.27
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.26;
commitid	5gdEnqVoJuTuwdTu;

1.26
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5DvsamK0GblTp8ww;

1.25
date	2010.04.20.20.42.54;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.07.01.46.59;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2006.10.20.18.27.25;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.10.20.17.11.39;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.20.17.02.24;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.20.16.54.01;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.10.00.09.07;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.29.11.31.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.09.16.00.48;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.10.22.23.26.02;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2004.01.07.00.34.25;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2003.10.21.18.58.49;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.01.26.55;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.29.01.39.32;	author aaron;	state Exp;
branches
	1.11.6.1;
next	1.10;

1.10
date	2001.03.13.06.02.00;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.12.05.36.58;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.30.14.31.39;	author fgsch;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.03.26.06.34.26;	author fgsch;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	98.11.06.06.32.15;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	98.10.14.07.34.42;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.10.05.10.06.16;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.10.05.07.24.13;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	98.10.04.22.28.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.06.38.03;	author fgsch;	state Exp;
branches;
next	;

1.7.6.1
date	2001.05.14.22.24.03;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.03.28.11.51.01;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2004.02.19.10.56.20;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.03.14.02.30.09;	author jason;	state Exp;
branches;
next	;

1.11.6.1
date	2002.06.11.03.42.19;	author art;	state Exp;
branches;
next	;


desc
@@


1.27
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: ne2000.c,v 1.26 2015/11/24 13:33:17 mpi Exp $	*/
/*	$NetBSD: ne2000.c,v 1.12 1998/06/10 01:15:50 thorpej Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 * adapters.
 *
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Copyright (C) 1993, David Greenman.  This software may be used, modified,
 * copied, distributed, and sold, in both source and binary form provided that
 * the above copyright and these terms are retained.  Under no circumstances is
 * the author responsible for the proper functioning of this software, nor does
 * the author assume any responsibility for damages incurred with its use.
 */

/*
 * Common code shared by all NE2000-compatible Ethernet interfaces.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>

#include <dev/ic/ne2000reg.h>
#include <dev/ic/ne2000var.h>

#include <dev/ic/ax88190reg.h>

int	ne2000_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	ne2000_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	ne2000_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	ne2000_test_mem(struct dp8390_softc *);

void	ne2000_writemem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, u_int8_t *, int, size_t, int);
void	ne2000_readmem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, int, u_int8_t *, size_t, int);

#define ASIC_BARRIER(asict, asich) \
	bus_space_barrier((asict), (asich), 0, 0x10, \
	    BUS_SPACE_BARRIER_READ | BUS_SPACE_BARRIER_WRITE)

struct cfdriver ne_cd = {
	NULL, "ne", DV_IFNET
};

int
ne2000_attach(struct ne2000_softc *nsc, u_int8_t *myea)
{
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	bus_space_tag_t nict = dsc->sc_regt;
	bus_space_handle_t nich = dsc->sc_regh;
	bus_space_tag_t asict = nsc->sc_asict;
	bus_space_handle_t asich = nsc->sc_asich;
	u_int8_t romdata[16];
	int memsize, i, useword;

	/*
	 * Detect it again unless caller specified it; this gives us
	 * the memory size.
	 */
	if (nsc->sc_type == NE2000_TYPE_UNKNOWN)
		nsc->sc_type = ne2000_detect(nsc);

	/*
	 * 8k of memory for NE1000, 16k otherwise.
	 */
	switch (nsc->sc_type) {
	case NE2000_TYPE_UNKNOWN:
	default:
		printf(": where did the card go?\n");
		return (1);
	case NE2000_TYPE_NE1000:
		memsize = 8192;
		useword = 0;
		break;
	case NE2000_TYPE_NE2000:
	case NE2000_TYPE_AX88190:		/* XXX really? */
	case NE2000_TYPE_AX88790:
	case NE2000_TYPE_DL10019:
	case NE2000_TYPE_DL10022:
		memsize = 8192 * 2;
		useword = 1;
		break;
 	}

	nsc->sc_useword = useword;

	dsc->cr_proto = ED_CR_RD2;
	if (nsc->sc_type == NE2000_TYPE_AX88190 ||
	    nsc->sc_type == NE2000_TYPE_AX88790) {
		dsc->rcr_proto = ED_RCR_INTT;
		dsc->sc_flags |= DP8390_DO_AX88190_WORKAROUND;
	} else
		dsc->rcr_proto = 0;

	/*
	 * DCR gets:
	 *
	 *	FIFO threshold to 8, No auto-init Remote DMA,
	 *	byte order=80x86.
	 *
	 * NE1000 gets byte-wide DMA, NE2000 gets word-wide DMA.
	 */
	dsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS | (useword ? ED_DCR_WTS : 0);

	dsc->test_mem = ne2000_test_mem;
	dsc->ring_copy = ne2000_ring_copy;
	dsc->write_mbuf = ne2000_write_mbuf;
	dsc->read_hdr = ne2000_read_hdr;

	/* Registers are linear. */
	for (i = 0; i < 16; i++)
		dsc->sc_reg_map[i] = i;

	/*
	 * NIC memory doens't start at zero on an NE board.
	 * The start address is tied to the bus width.
	 * (It happens to be computed the same way as mem size.)
	 */
	dsc->mem_start = memsize;

#ifdef GWETHER
	{
		int x, mstart = 0;
		int8_t pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE],
		    tbuf[ED_PAGE_SIZE];

		for (i = 0; i < ED_PAGE_SIZE; i++)
			pbuf0[i] = 0;

		/* Search for the start of RAM. */
		for (x = 1; x < 256; x++) {
			ne2000_writemem(nict, nich, asict, asich, pbuf0,
			    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);
			ne2000_readmem(nict, nich, asict, asich,
			    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);
			if (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {
				for (i = 0; i < ED_PAGE_SIZE; i++)
					pbuf[i] = 255 - x;
				ne2000_writemem(nict, nich, asict, asich,
				    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,
				    useword);
				ne2000_readmem(nict, nich, asict, asich,
				    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,
				    useword);
				if (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0) {
					mstart = x << ED_PAGE_SHIFT;
					memsize = ED_PAGE_SIZE;
					break;
				}
			}
		}

		if (mstart == 0) {
			printf(": cannot find start of RAM\n");
			return;
		}

		/* Search for the end of RAM. */
		for (++x; x < 256; x++) {
			ne2000_writemem(nict, nich, asict, asich, pbuf0,
			    x << ED_PAGE_SHIFT, ED_PAGE_SIZE, useword);
			ne2000_readmem(nict, nich, asict, asich,
			    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE, useword);
			if (bcmp(pbuf0, tbuf, ED_PAGE_SIZE) == 0) {
				for (i = 0; i < ED_PAGE_SIZE; i++)
					pbuf[i] = 255 - x;
				ne2000_writemem(nict, nich, asict, asich,
				    pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE,
				    useword);
				ne2000_readmem(nict, nich, asict, asich,
				    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE,
				    useword);
				if (bcmp(pbuf, tbuf, ED_PAGE_SIZE) == 0)
					memsize += ED_PAGE_SIZE;
				else
					break;
			} else
				break;
		}

		printf(": RAM start 0x%x, size %d\n",
		    mstart, memsize);

		dsc->mem_start = mstart;
	}
#endif /* GWETHER */

	dsc->mem_size = memsize;

	if (myea == NULL) {
		/* Read the station address. */
		if (nsc->sc_type == NE2000_TYPE_AX88190 ||
		    nsc->sc_type == NE2000_TYPE_AX88790) {
			/* Select page 0 registers. */
			NIC_BARRIER(nict, nich);
			bus_space_write_1(nict, nich, ED_P0_CR,
			    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
			NIC_BARRIER(nict, nich);
			/* Select word transfer. */
			bus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_WTS);
			NIC_BARRIER(nict, nich);
			ne2000_readmem(nict, nich, asict, asich,
			    AX88190_NODEID_OFFSET, dsc->sc_arpcom.ac_enaddr,
			    ETHER_ADDR_LEN, useword);
		} else {
			ne2000_readmem(nict, nich, asict, asich, 0, romdata,
			    sizeof(romdata), useword);
			for (i = 0; i < ETHER_ADDR_LEN; i++)
				dsc->sc_arpcom.ac_enaddr[i] =
				    romdata[i * (useword ? 2 : 1)];
		}
	} else
		bcopy(myea, dsc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	/* Clear any pending interrupts that might have occurred above. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_ISR, 0xff);
	NIC_BARRIER(nict, nich);

	if (dsc->sc_media_init == NULL)
		dsc->sc_media_init = dp8390_media_init;

	if (dp8390_config(dsc)) {
		printf(": setup failed\n");
		return (1);
	}

	return (0);
}

/*
 * Detect an NE-2000 or compatible.  Returns a model code.
 */
int
ne2000_detect(struct ne2000_softc *nsc)
{
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	bus_space_tag_t nict = dsc->sc_regt;
	bus_space_handle_t nich = dsc->sc_regh;
	bus_space_tag_t asict = nsc->sc_asict;
	bus_space_handle_t asich = nsc->sc_asich;
	static u_int8_t test_pattern[32] = "THIS is A memory TEST pattern";
	u_int8_t test_buffer[32], tmp;
	int state, i, rv = 0;

	state = dsc->sc_enabled;
	dsc->sc_enabled = 0;

	/* Reset the board. */
#ifdef GWETHER
	bus_space_write_1(asict, asich, NE2000_ASIC_RESET, 0);
	ASIC_BARRIER(asict, asich);
	delay(200);
#endif /* GWETHER */
	tmp = bus_space_read_1(asict, asich, NE2000_ASIC_RESET);
	ASIC_BARRIER(asict, asich);
	delay(10000);

	/*
	 * I don't know if this is necessary; probably cruft leftover from
	 * Clarkson packet driver code. Doesn't do a thing on the boards I've
	 * tested. -DG [note that a outb(0x84, 0) seems to work here, and is
	 * non-invasive...but some boards don't seem to reset and I don't have
	 * complete documentation on what the 'right' thing to do is...so we do
	 * the invasive thing for now.  Yuck.]
	 */
	bus_space_write_1(asict, asich, NE2000_ASIC_RESET, tmp);
	ASIC_BARRIER(asict, asich);
	delay(5000);

	/*
	 * This is needed because some NE clones apparently don't reset the
	 * NIC properly (or the NIC chip doesn't reset fully on power-up).
	 * XXX - this makes the probe invasive!  Done against my better
	 * judgement.  -DLG
	 */
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
	NIC_BARRIER(nict, nich);

	delay(5000);

	/*
	 * Generic probe routine for testing for the existence of a DS8390.
	 * Must be performed  after the NIC has just been reset.  This
	 * works by looking at certain register values that are guaranteed
	 * to be initialized a certain way after power-up or reset.
	 *
	 * Specifically:
	 *
	 *	Register		reset bits	set bits
	 *	--------		----------	--------
	 *	CR			TXP, STA	RD2, STP
	 *	ISR					RST
	 *	IMR			<all>
	 *	DCR					LAS
	 *	TCR			LB1, LB0
	 *
	 * We only look at CR and ISR, however, since looking at the others
	 * would require changing register pages, which would be intrusive
	 * if this isn't an 8390.
	 */

	tmp = bus_space_read_1(nict, nich, ED_P0_CR);
	if ((tmp & (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=
	    (ED_CR_RD2 | ED_CR_STP))
		goto out;

	tmp = bus_space_read_1(nict, nich, ED_P0_ISR);
	if ((tmp & ED_ISR_RST) != ED_ISR_RST)
		goto out;

	bus_space_write_1(nict, nich,
	    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	for (i = 0; i < 100; i++) {
		if ((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RST) ==
		    ED_ISR_RST) {
			/* Ack the reset bit. */
			bus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RST);
			NIC_BARRIER(nict, nich);
			break;
		}
		delay(100);
	}

#if 0
	/* XXX */
	if (i == 100)
		goto out;
#endif

	/*
	 * Test the ability to read and write to the NIC memory.  This has
	 * the side effect of determining if this is an NE1000 or an NE2000.
	 */

	/*
	 * This prevents packets from being stored in the NIC memory when
	 * the readmem routine turns on the start bit in the CR.
	 */
	bus_space_write_1(nict, nich, ED_P0_RCR, ED_RCR_MON);
	NIC_BARRIER(nict, nich);

	/* Temporarily initialize DCR for byte operations. */
	bus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);

	bus_space_write_1(nict, nich, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);
	bus_space_write_1(nict, nich, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);

	/*
	 * Write a test pattern in byte mode.  If this fails, then there
	 * probably isn't any memory at 8k - which likely means that the
	 * board is an NE2000.
	 */
	ne2000_writemem(nict, nich, asict, asich, test_pattern, 8192,
	    sizeof(test_pattern), 0);
	ne2000_readmem(nict, nich, asict, asich, 8192, test_buffer,
	    sizeof(test_buffer), 0);

	if (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {
		/* not an NE1000 - try NE2000 */
		bus_space_write_1(nict, nich, ED_P0_DCR,
		    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);
		bus_space_write_1(nict, nich, ED_P0_PSTART,
		    16384 >> ED_PAGE_SHIFT);
		bus_space_write_1(nict, nich, ED_P0_PSTOP,
		    32768 >> ED_PAGE_SHIFT);

		/*
		 * Write the test pattern in word mode.  If this also fails,
		 * then we don't know what this board is.
		 */
		ne2000_writemem(nict, nich, asict, asich, test_pattern, 16384,
		    sizeof(test_pattern), 1);
		ne2000_readmem(nict, nich, asict, asich, 16384, test_buffer,
		    sizeof(test_buffer), 1);

		if (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))
			goto out;	/* not an NE2000 either */

		rv = NE2000_TYPE_NE2000;
	} else {
		/* We're an NE1000. */
		rv = NE2000_TYPE_NE1000;
	}

	/* Clear any pending interrupts that might have occurred above. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_ISR, 0xff);

 out:
	dsc->sc_enabled = state;

	return (rv);
}

/*
 * Write an mbuf chain to the destination NIC memory address using programmed
 * I/O.
 */
int
ne2000_write_mbuf(struct dp8390_softc *sc, struct mbuf *m, int buf)
{
	struct ne2000_softc *nsc = (struct ne2000_softc *)sc;
	bus_space_tag_t nict = sc->sc_regt;
	bus_space_handle_t nich = sc->sc_regh;
	bus_space_tag_t asict = nsc->sc_asict;
	bus_space_handle_t asich = nsc->sc_asich;
	int savelen;
	int maxwait = 100;	/* about 120us */

	savelen = m->m_pkthdr.len;

	/* Select page 0 registers. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	/* Reset remote DMA complete flag. */
	bus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);
	NIC_BARRIER(nict, nich);

	/* Set up DMA byte count. */
	bus_space_write_1(nict, nich, ED_P0_RBCR0, savelen);
	bus_space_write_1(nict, nich, ED_P0_RBCR1, savelen >> 8);

	/* Set up destination address in NIC mem. */
	bus_space_write_1(nict, nich, ED_P0_RSAR0, buf);
	bus_space_write_1(nict, nich, ED_P0_RSAR1, buf >> 8);

	/* Set remote DMA write. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich,
	    ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	/*
	 * Transfer the mbuf chain to the NIC memory.  NE2000 cards
	 * require that data be transferred as words, and only words,
	 * so that case requires some extra code to patch over odd-length
	 * mbufs.
	 */
	if (nsc->sc_type == NE2000_TYPE_NE1000) {
		/* NE1000s are easy. */
		for (; m != 0; m = m->m_next) {
			if (m->m_len) {
				bus_space_write_multi_1(asict, asich,
				    NE2000_ASIC_DATA, mtod(m, u_int8_t *),
				    m->m_len);
			}
		}
	} else {
		/* NE2000s are a bit trickier. */
		u_int8_t *data, savebyte[2];
		int l, leftover;
#ifdef DIAGNOSTIC
		u_int8_t *lim;
#endif
		/* Start out with no leftover data. */
		leftover = 0;
		savebyte[0] = savebyte[1] = 0;

		for (; m != 0; m = m->m_next) {
			l = m->m_len;
			if (l == 0)
				continue;
			data = mtod(m, u_int8_t *);
#ifdef DIAGNOSTIC
			lim = data + l;
#endif
			while (l > 0) {
				if (leftover) {
					/*
					 * Data left over (from mbuf or
					 * realignment).  Buffer the next
					 * byte, and write it and the
					 * leftover data out.
					 */
					savebyte[1] = *data++;
					l--;
					bus_space_write_raw_multi_2(asict,
					    asich, NE2000_ASIC_DATA,
					    savebyte, 2);
					leftover = 0;
				} else if (ALIGNED_POINTER(data,
					   u_int16_t) == 0) {
					/*
					 * Unaligned data; buffer the next
					 * byte.
					 */
					savebyte[0] = *data++;
					l--;
					leftover = 1;
				} else {
					/*
					 * Aligned data; output contiguous
					 * words as much as we can, then
					 * buffer the remaining byte, if any.
					 */
					leftover = l & 1;
					l &= ~1;
					bus_space_write_raw_multi_2(asict,
					    asich, NE2000_ASIC_DATA, data, l);
					data += l;
					if (leftover)
						savebyte[0] = *data++;
					l = 0;
				}
			}
			if (l < 0)
				panic("ne2000_write_mbuf: negative len");
#ifdef DIAGNOSTIC
			if (data != lim)
				panic("ne2000_write_mbuf: data != lim");
#endif
		}
		if (leftover) {
			savebyte[1] = 0;
			bus_space_write_raw_multi_2(asict, asich,
			    NE2000_ASIC_DATA, savebyte, 2);
		}
	}
	NIC_BARRIER(nict, nich);

	/* AX88796 doesn't seem to have remote DMA complete */
	if (sc->sc_flags & DP8390_NO_REMOTE_DMA_COMPLETE)
		return (savelen);

	/*
	 * Wait for remote DMA to complete.  This is necessary because on the
	 * transmit side, data is handled internally by the NIC in bursts, and
	 * we can't start another remote DMA until this one completes.  Not
	 * waiting causes really bad things to happen - like the NIC wedging
	 * the bus.
	 */
	while (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=
	    ED_ISR_RDC) && --maxwait) {
		bus_space_read_1(nict, nich, ED_P0_CRDA1);
		bus_space_read_1(nict, nich, ED_P0_CRDA0);
		NIC_BARRIER(nict, nich);
		DELAY(1);
	}

	if (maxwait == 0) {
		log(LOG_WARNING,
		    "%s: remote transmit DMA failed to complete\n",
		    sc->sc_dev.dv_xname);
		dp8390_reset(sc);
	}

	return (savelen);
}

/*
 * Given a source and destination address, copy 'amount' of a packet from
 * the ring buffer into a linear destination buffer.  Takes into account
 * ring-wrap.
 */
int
ne2000_ring_copy(struct dp8390_softc *sc, int src, caddr_t dst,
    u_short amount)
{
	struct ne2000_softc *nsc = (struct ne2000_softc *)sc;
	bus_space_tag_t nict = sc->sc_regt;
	bus_space_handle_t nich = sc->sc_regh;
	bus_space_tag_t asict = nsc->sc_asict;
	bus_space_handle_t asich = nsc->sc_asich;
	u_short tmp_amount;
	int useword = nsc->sc_useword;

	/* Does copy wrap to lower addr in ring buffer? */
	if (src + amount > sc->mem_end) {
		tmp_amount = sc->mem_end - src;

		/* Copy amount up to end of NIC memory. */
		ne2000_readmem(nict, nich, asict, asich, src,
		    (u_int8_t *)dst, tmp_amount, useword);

		amount -= tmp_amount;
		src = sc->mem_ring;
		dst += tmp_amount;
	}

	ne2000_readmem(nict, nich, asict, asich, src, (u_int8_t *)dst,
	    amount, useword);

	return (src + amount);
}

void
ne2000_read_hdr(struct dp8390_softc *sc, int buf, struct dp8390_ring *hdr)
{
	struct ne2000_softc *nsc = (struct ne2000_softc *)sc;

	ne2000_readmem(sc->sc_regt, sc->sc_regh, nsc->sc_asict, nsc->sc_asich,
	    buf, (u_int8_t *)hdr, sizeof(struct dp8390_ring),
	    nsc->sc_useword);
#if BYTE_ORDER == BIG_ENDIAN
	hdr->count = swap16(hdr->count);
#endif
}

int
ne2000_test_mem(struct dp8390_softc *sc)
{
	/* Noop. */
	return (0);
}

/*
 * Given a NIC memory source address and a host memory destination address,
 * copy 'amount' from NIC to host using programmed i/o.  The 'amount' is
 * rounded up to a word - ok as long as mbufs are word sized.
 */
void
ne2000_readmem(bus_space_tag_t nict, bus_space_handle_t nich,
    bus_space_tag_t asict, bus_space_handle_t asich, int src,
    u_int8_t *dst, size_t amount, int useword)
{

	/* Select page 0 registers. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	/* Round up to a word. */
	if (amount & 1)
		++amount;

	/* Set up DMA byte count. */
	bus_space_write_1(nict, nich, ED_P0_RBCR0, amount);
	bus_space_write_1(nict, nich, ED_P0_RBCR1, amount >> 8);

	/* Set up source address in NIC mem. */
	bus_space_write_1(nict, nich, ED_P0_RSAR0, src);
	bus_space_write_1(nict, nich, ED_P0_RSAR1, src >> 8);

	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);

	ASIC_BARRIER(asict, asich);
	if (useword)
		bus_space_read_raw_multi_2(asict, asich, NE2000_ASIC_DATA,
		    dst, amount);
	else
		bus_space_read_multi_1(asict, asich, NE2000_ASIC_DATA,
		    dst, amount);
}

/*
 * Stripped down routine for writing a linear buffer to NIC memory.  Only
 * used in the probe routine to test the memory.  'len' must be even.
 */
void
ne2000_writemem(bus_space_tag_t nict, bus_space_handle_t nich,
    bus_space_tag_t asict, bus_space_handle_t asich, u_int8_t *src,
    int dst, size_t len, int useword)
{
	int maxwait = 100;	/* about 120us */

	/* Select page 0 registers. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	/* Reset remote DMA complete flag. */
	bus_space_write_1(nict, nich, ED_P0_ISR, ED_ISR_RDC);
	NIC_BARRIER(nict, nich);

	/* Set up DMA byte count. */
	bus_space_write_1(nict, nich, ED_P0_RBCR0, len);
	bus_space_write_1(nict, nich, ED_P0_RBCR1, len >> 8);

	/* Set up destination address in NIC mem. */
	bus_space_write_1(nict, nich, ED_P0_RSAR0, dst);
	bus_space_write_1(nict, nich, ED_P0_RSAR1, dst >> 8);

	/* Set remote DMA write. */
	NIC_BARRIER(nict, nich);
	bus_space_write_1(nict, nich, ED_P0_CR,
	    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
	NIC_BARRIER(nict, nich);

	ASIC_BARRIER(asict, asich);
	if (useword)
		bus_space_write_raw_multi_2(asict, asich, NE2000_ASIC_DATA,
		    src, len);
	else
		bus_space_write_multi_1(asict, asich, NE2000_ASIC_DATA,
		    src, len);
	ASIC_BARRIER(asict, asich);

	/*
	 * Wait for remote DMA to complete.  This is necessary because on the
	 * transmit side, data is handled internally by the NIC in bursts, and
	 * we can't start another remote DMA until this one completes.  Not
	 * waiting causes really bad things to happen - like the NIC wedging
	 * the bus.
	 */
	while (((bus_space_read_1(nict, nich, ED_P0_ISR) & ED_ISR_RDC) !=
	    ED_ISR_RDC) && --maxwait)
		DELAY(1);
}

int
ne2000_detach(struct ne2000_softc *sc, int flags)
{
	return (dp8390_detach(&sc->sc_dp8390, flags));
}
@


1.26
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.25 2010/04/20 20:42:54 deraadt Exp $	*/
a58 1
#include <net/if_dl.h>
@


1.25
log
@- Fix a calculation bug with the RX ring buffer memory address which
  slipped into the original NetBSD code around sixteen years ago.
  Although it has been working so far because some devices used
  address zero and other devices ignored the wrong higher bits.

- Remove the mem_ring override in ne2000_attach() now that
  dp8390_config() calculates mem_ring correctly.

From NetBSD, via brad
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.24 2008/06/26 05:42:16 ray Exp $	*/
a59 1
#include <net/if_types.h>
@


1.24
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.23 2006/11/07 01:46:59 brad Exp $	*/
a275 7

	/*
	 * We need to compute mem_ring a bit differently; override the
	 * value set up in dp8390_config().
	 */
	dsc->mem_ring =
	    dsc->mem_start + ((dsc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);
@


1.23
log
@- The ASIX AX88796 is an NE2000 compatible ethernet chip, but doesn't seem
to have "remote DMA complete bit" is ISR.  So, don't wait for ISR.RDC bit
after writing a packet.

From bsh@@NetBSD

- Figure out whether the shared memory region is word-accessible in the same
place we figure out its size, and store this in the softc, rather than using
a series of comparisons later.

From mycroft@@NetBSD

- support for the NE2000 type AX88790.

From Yong-Jhen Hong <yongjhen at alqualonde dot org> via NetBSD

Tested by deraadt@@ and Adriaan <misc dot adriaan at gmail dot com>
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.22 2006/10/20 18:27:25 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.22
log
@use the ASIX AX88190 defines from ax88190reg.h and remove some
AX88190 specific defines from ne2000reg.h

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.21 2006/10/20 17:11:39 brad Exp $	*/
d116 1
a116 1
	if (nsc->sc_type == 0) {
a117 5
		if (nsc->sc_type == 0) {
			printf(": where did the card go?\n");
			return (1);
		}
	}
d119 23
a141 1
	useword = NE2000_USE_WORD(nsc);
d144 2
a145 1
	if (nsc->sc_type == NE2000_TYPE_AX88190) {
a170 15
	 * 8k of memory for NE1000, 16k otherwise.
	 */
	switch (nsc->sc_type) {
	case NE2000_TYPE_NE1000:
		memsize = 8192;
		break;
	case NE2000_TYPE_NE2000:
	case NE2000_TYPE_AX88190:		/* XXX really? */
	case NE2000_TYPE_DL10019:
	case NE2000_TYPE_DL10022:
		memsize = 8192 * 2;
		break;
	}

	/*
d248 2
a249 1
		if (nsc->sc_type == NE2000_TYPE_AX88190) {
d259 2
a260 2
			    AX88190_NODEID_OFFSET,
			    dsc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN, useword);
d591 4
d635 1
a635 1
	int useword = NE2000_USE_WORD(nsc);
d663 1
a663 1
	    NE2000_USE_WORD(nsc));
@


1.21
log
@remove another chunk of unused NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.20 2006/10/20 17:02:24 brad Exp $	*/
d81 2
d255 1
a255 1
			    NE2000_AX88190_NODEID_OFFSET,
@


1.20
log
@remove some NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.19 2006/10/20 16:54:01 brad Exp $	*/
a73 6

#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define	bus_space_write_stream_2	bus_space_write_2
#define	bus_space_write_multi_stream_2	bus_space_write_multi_2
#define	bus_space_read_multi_stream_2	bus_space_read_multi_2
#endif /* __BUS_SPACE_HAS_STREAM_METHODS */
@


1.19
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.18 2006/10/10 00:09:07 brad Exp $	*/
a69 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#else
a71 1
#endif
a264 4
#ifdef __NetBSD__
				dsc->sc_enaddr[i] =
				    romdata[i * (useword ? 2 : 1)];
#else
a266 1
#endif
a546 5
#ifdef __NetBSD__
					bus_space_write_stream_2(asict, asich,
					    NE2000_ASIC_DATA,
					    *(u_int16_t *)savebyte);
#else
a549 1
#endif
a567 5
#ifdef __NetBSD__
					bus_space_write_multi_stream_2(asict,
					    asich, NE2000_ASIC_DATA,
					    (u_int16_t *)data, l >> 1);
#else
a569 1
#endif
a584 4
#ifdef __NetBSD__
			bus_space_write_stream_2(asict, asich, NE2000_ASIC_DATA,
			    *(u_int16_t *)savebyte);
#else
a586 1
#endif
a706 4
#ifdef __NetBSD__
		bus_space_read_multi_stream_2(asict, asich, NE2000_ASIC_DATA,
		    (u_int16_t *)dst, amount >> 1);
#else
a708 1
#endif
a750 4
#ifdef __NetBSD__
		bus_space_write_multi_stream_2(asict, asich, NE2000_ASIC_DATA,
		    (u_int16_t *)src, len >> 1);
#else
a752 1
#endif
@


1.18
log
@Add bus_space_barrier.
Add DELAY in some busy loops to allow the DMA engine to actually do something
(neccessary on fast processors).

From ws@@ & mycroft@@ NetBSD

Testing by deraadt@@ nick@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.17 2006/07/29 11:31:20 miod Exp $	*/
d110 1
a110 3
ne2000_attach(nsc, myea)
	struct ne2000_softc *nsc;
	u_int8_t *myea;
d307 1
a307 2
ne2000_detect(nsc)
	struct ne2000_softc *nsc;
d476 1
a476 4
ne2000_write_mbuf(sc, m, buf)
	struct dp8390_softc *sc;
	struct mbuf *m;
	int buf;
d648 2
a649 5
ne2000_ring_copy(sc, src, dst, amount)
	struct dp8390_softc *sc;
	int src;
	caddr_t dst;
	u_short amount;
d679 1
a679 4
ne2000_read_hdr(sc, buf, hdr)
	struct dp8390_softc *sc;
	int buf;
	struct dp8390_ring *hdr;
d692 1
a692 2
ne2000_test_mem(sc)
	struct dp8390_softc *sc;
a693 1

d704 3
a706 9
ne2000_readmem(nict, nich, asict, asich, src, dst, amount, useword)
	bus_space_tag_t nict;
	bus_space_handle_t nich;
	bus_space_tag_t asict;
	bus_space_handle_t asich;
	int src;
	u_int8_t *dst;
	size_t amount;
	int useword;
d750 3
a752 9
ne2000_writemem(nict, nich, asict, asich, src, dst, len, useword)
	bus_space_tag_t nict;
	bus_space_handle_t nich;
	bus_space_tag_t asict;
	bus_space_handle_t asich;
	u_int8_t *src;
	int dst;
	size_t len;
	int useword;
d807 1
a807 3
ne2000_detach(sc, flags)
	struct ne2000_softc *sc;
	int flags;
@


1.17
log
@Do not redefine ALIGNED_POINTER, it comes from <machine/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.16 2006/07/09 16:00:48 miod Exp $	*/
d101 4
d257 1
d260 1
d263 1
d283 1
d285 1
d327 1
d331 1
d343 1
d354 1
d390 1
d397 1
d419 1
d465 1
d495 1
d498 1
d502 1
d513 1
d516 1
d621 1
d631 6
a636 1
	    ED_ISR_RDC) && --maxwait);
d730 1
d733 1
d747 1
d751 1
d783 1
d786 1
d790 1
d801 1
d804 1
d806 1
d818 1
d828 2
a829 1
	    ED_ISR_RDC) && --maxwait);
@


1.16
log
@In ne2000_detect(), temporarily mark the dp8390 subpart as inactive, so that
we ignore interrupts; this allows unplugging a card when the probe gets stuck
without panicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.15 2005/10/22 23:26:02 brad Exp $	*/
a549 6
#ifdef i386
#define ALIGNED_POINTER(p,t)	1
#endif
#ifdef alpha
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)
#endif
@


1.15
log
@shorten ne(4) dmesg entries from 2-3 lines to 1.

Thanks to Han Boetes for testing on an isapnp card.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.14 2004/01/07 00:34:25 fgsch Exp $	*/
d310 4
a313 1
	int i, rv = 0;
d452 2
@


1.14
log
@amout -> amount; from Pedro Martelletto.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.13 2003/10/21 18:58:49 jmc Exp $	*/
d125 1
a125 2
			printf("%s: where did the card go?\n",
			    dsc->sc_dev.dv_xname);
d213 1
a213 2
			printf("%s: cannot find start of RAM\n",
			    dsc->sc_dev.dv_xname);
d240 2
a241 2
		printf("%s: RAM start 0x%x, size %d\n",
		    dsc->sc_dev.dv_xname, mstart, memsize);
d282 1
a282 1
		printf("%s: setup failed\n", dsc->sc_dev.dv_xname);
@


1.13
log
@typos from Tom Cosgrove;

Tom: I did not commit a couple of your changes.

i did not include some punctuation fixes (full stops, etc.)
mnemorable -> mnemonic: i decided memorable was probably better
instrunctions -> instruction: i kept the plural
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.12 2002/03/14 01:26:55 millert Exp $	*/
d624 1
a624 1
 * Given a source and destination address, copy 'amout' of a packet from
@


1.12
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.11 2001/03/29 01:39:32 aaron Exp $	*/
d345 1
a345 1
	 * Generic probe routine for testing for the existance of a DS8390.
@


1.11
log
@Add MII support to NE2000 PCMCIA driver. Both the Netgear FA410TXC and
New Media LiveWire Fast Ethernet adapters now work after these changes,
although the Netgear card still requires media to be set manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.10 2001/03/13 06:02:00 aaron Exp $	*/
d91 9
a99 9
int	ne2000_write_mbuf __P((struct dp8390_softc *, struct mbuf *, int));
int	ne2000_ring_copy __P((struct dp8390_softc *, int, caddr_t, u_short));
void	ne2000_read_hdr __P((struct dp8390_softc *, int, struct dp8390_ring *));
int	ne2000_test_mem __P((struct dp8390_softc *));

void	ne2000_writemem __P((bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, u_int8_t *, int, size_t, int));
void	ne2000_readmem __P((bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, int, u_int8_t *, size_t, int));
@


1.11.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.11 2001/03/29 01:39:32 aaron Exp $	*/
d91 9
a99 9
int	ne2000_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	ne2000_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	ne2000_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	ne2000_test_mem(struct dp8390_softc *);

void	ne2000_writemem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, u_int8_t *, int, size_t, int);
void	ne2000_readmem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, int, u_int8_t *, size_t, int);
@


1.10
log
@The prescence of a DL10019 does not appear to imply a 24k buffer size. Always
use an 8k buffer for NE1000 cards, 16k otherwise. This is likely sub-optimal,
but at least it fixes the D-Link DE660 card, which hasn't worked since last
August (and it seems like a fairly common model). fgsch@@ ok. Thanks to Felix
Kronlage who donated a test card and dongle for me to debug with.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.9 2001/03/12 05:36:58 aaron Exp $	*/
d169 1
d793 8
@


1.9
log
@Adjust the way that media is initialized on DP8390-compatibles; from NetBSD.
The dp8390_softc now has media_init and media_fini function pointers that
do the work. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.8 2000/05/30 14:31:39 fgsch Exp $	*/
d160 1
a160 2
	 * 8k of memory for NE1000, 16k for NE2000 and 24k for the
	 * card uses DL10019.
d168 1
a169 3
		break;
	case NE2000_TYPE_DL10019:
		memsize = 8192 * 3;
@


1.8
log
@Changes from NetBSD:
* support for ax88190
* set the memory size based on the ne2k type, changing the number
  of transmit buffers.
* make ne2000_attach return some value so it can be used in pcmcia.
* move code for dl10019 to the pcmcia part.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.7 1999/03/26 06:34:26 fgsch Exp $	*/
d106 1
a106 1
ne2000_attach(nsc, myea, media, nmedia, defmedia)
a108 1
	int *media, nmedia, defmedia;
d282 4
a285 1
	if (dp8390_config(dsc, media, nmedia, defmedia)) {
@


1.8.2.1
log
@Pull in patch from current:
Fix (aaron):
The prescence of a DL10019 does not appear to imply a 24k buffer size. Always
use an 8k buffer for NE1000 cards, 16k otherwise. This is likely sub-optimal,
but at least it fixes the D-Link DE660 card, which hasn't worked since last
August (and it seems like a fairly common model). fgsch@@ ok. Thanks to Felix
Kronlage who donated a test card and dongle for me to debug with.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.8 2000/05/30 14:31:39 fgsch Exp $	*/
d161 2
a162 1
	 * 8k of memory for NE1000, 16k otherwise.
d170 2
d173 1
a173 1
		memsize = 8192 * 2;
@


1.7
log
@Add support for some 100Mbit PCMCIA cards.
Change the ne2000_detect parm list.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.6 1998/11/06 06:32:15 fgsch Exp $	*/
d105 1
a105 1
void
d120 2
a121 1
	 * Detect it again; this gives us the memory size.
a122 1
	nsc->sc_type = ne2000_detect(nsc);
d124 6
a129 2
		printf("%s: where did the card go?\n", dsc->sc_dev.dv_xname);
		return;
d132 1
a132 1
	useword = (nsc->sc_type != NE2000_TYPE_NE1000);
d135 5
d149 1
a149 2
	dsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |
	    (nsc->sc_type != NE2000_TYPE_NE1000 ? ED_DCR_WTS : 0);
d161 2
a162 1
	 * 8k of memory plus an additional 8k if an NE2000.
d164 12
a175 1
	memsize = 8192 + (nsc->sc_type != NE2000_TYPE_NE1000 ? 8192 : 0);
d254 1
a254 1
	if (myea == NULL && nsc->sc_type != NE2000_TYPE_DL10019) {
d256 13
a268 3
		ne2000_readmem(nict, nich, asict, asich, 0, romdata,
		    sizeof(romdata), useword);
		for (i = 0; i < ETHER_ADDR_LEN; i++)
d270 2
a271 1
			dsc->sc_enaddr[i] = romdata[i * (useword ? 2 : 1)];
d273 2
a274 2
			dsc->sc_arpcom.ac_enaddr[i] =
				romdata[i * (useword ? 2 : 1)];
d276 3
a278 1
	}
d285 1
a285 1
		return;
d294 2
d443 2
a444 14
		tmp = 0;
		for (i = 4; i < 12; i++)
			tmp += bus_space_read_1(asict, asich, i);

		if (tmp == 0xff) {
			for (i = 0; i < ETHER_ADDR_LEN; i++)
				dsc->sc_arpcom.ac_enaddr[i] =
					bus_space_read_1(asict, asich, i + 4);

			rv = NE2000_TYPE_DL10019;
		} else {
			/* We're an NE1000. */
			rv = NE2000_TYPE_NE1000;
		}
d641 1
a641 1
	int useword = (nsc->sc_type != NE2000_TYPE_NE1000);
d672 1
a672 1
	    (nsc->sc_type != NE2000_TYPE_NE1000));
@


1.7.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.11 2001/03/29 01:39:32 aaron Exp $	*/
d105 2
a106 2
int
ne2000_attach(nsc, myea)
d109 1
d120 1
a120 2
	 * Detect it again unless caller specified it; this gives us
	 * the memory size.
d122 1
d124 2
a125 6
		nsc->sc_type = ne2000_detect(nsc);
		if (nsc->sc_type == 0) {
			printf("%s: where did the card go?\n",
			    dsc->sc_dev.dv_xname);
			return (1);
		}
d128 1
a128 1
	useword = NE2000_USE_WORD(nsc);
a130 5
	if (nsc->sc_type == NE2000_TYPE_AX88190) {
		dsc->rcr_proto = ED_RCR_INTT;
		dsc->sc_flags |= DP8390_DO_AX88190_WORKAROUND;
	} else
		dsc->rcr_proto = 0;
d140 2
a141 1
	dsc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS | (useword ? ED_DCR_WTS : 0);
d153 1
a153 1
	 * 8k of memory for NE1000, 16k otherwise.
d155 1
a155 11
	switch (nsc->sc_type) {
	case NE2000_TYPE_NE1000:
		memsize = 8192;
		break;
	case NE2000_TYPE_NE2000:
	case NE2000_TYPE_AX88190:		/* XXX really? */
	case NE2000_TYPE_DL10019:
	case NE2000_TYPE_DL10022:
		memsize = 8192 * 2;
		break;
	}
d234 1
a234 1
	if (myea == NULL) {
d236 3
a238 13
		if (nsc->sc_type == NE2000_TYPE_AX88190) {
			/* Select page 0 registers. */
			bus_space_write_1(nict, nich, ED_P0_CR,
			    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
			/* Select word transfer. */
			bus_space_write_1(nict, nich, ED_P0_DCR, ED_DCR_WTS);
			ne2000_readmem(nict, nich, asict, asich,
			    NE2000_AX88190_NODEID_OFFSET,
			    dsc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN, useword);
		} else {
			ne2000_readmem(nict, nich, asict, asich, 0, romdata,
			    sizeof(romdata), useword);
			for (i = 0; i < ETHER_ADDR_LEN; i++)
d240 1
a240 2
				dsc->sc_enaddr[i] =
				    romdata[i * (useword ? 2 : 1)];
d242 2
a243 2
				dsc->sc_arpcom.ac_enaddr[i] =
				    romdata[i * (useword ? 2 : 1)];
d245 1
a245 3
		}
	} else
		bcopy(myea, dsc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
d250 1
a250 4
	if (dsc->sc_media_init == NULL)
		dsc->sc_media_init = dp8390_media_init;

	if (dp8390_config(dsc)) {
d252 1
a252 1
		return (1);
a260 2

	return (0);
d408 14
a421 2
		/* We're an NE1000. */
		rv = NE2000_TYPE_NE1000;
d618 1
a618 1
	int useword = NE2000_USE_WORD(nsc);
d649 1
a649 1
	    NE2000_USE_WORD(nsc));
a769 8
}

int
ne2000_detach(sc, flags)
	struct ne2000_softc *sc;
	int flags;
{
	return (dp8390_detach(&sc->sc_dp8390, flags));
@


1.7.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d91 9
a99 9
int	ne2000_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	ne2000_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	ne2000_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	ne2000_test_mem(struct dp8390_softc *);

void	ne2000_writemem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, u_int8_t *, int, size_t, int);
void	ne2000_readmem(bus_space_tag_t, bus_space_handle_t,
	    bus_space_tag_t, bus_space_handle_t, int, u_int8_t *, size_t, int);
@


1.7.6.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d345 1
a345 1
	 * Generic probe routine for testing for the existence of a DS8390.
d624 1
a624 1
 * Given a source and destination address, copy 'amount' of a packet from
@


1.6
log
@Support for RealTek 8019 and 8029 NE2000-compatible network interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.5 1998/10/14 07:34:42 fgsch Exp $	*/
d122 1
a122 1
	nsc->sc_type = ne2000_detect(nict, nich, asict, asich);
d128 1
a128 1
	useword = (nsc->sc_type == NE2000_TYPE_NE2000);
d141 1
a141 1
	    (nsc->sc_type == NE2000_TYPE_NE2000 ? ED_DCR_WTS : 0);
d155 1
a155 1
	memsize = 8192 + (nsc->sc_type == NE2000_TYPE_NE2000 ? 8192 : 0);
d234 1
a234 1
	if (myea == NULL) {
d245 1
a245 7
	} else
#ifdef __NetBSD__
		bcopy(myea, dsc->sc_enaddr, sizeof(dsc->sc_enaddr));
#else
		bcopy(myea, dsc->sc_arpcom.ac_enaddr,
			sizeof(dsc->sc_arpcom.ac_enaddr));
#endif
d267 2
a268 5
ne2000_detect(nict, nich, asict, asich)
	bus_space_tag_t nict;
	bus_space_handle_t nich;
	bus_space_tag_t asict;
	bus_space_handle_t asich;
d270 5
d408 14
a421 2
		/* We're an NE1000. */
		rv = NE2000_TYPE_NE1000;
d618 1
a618 1
	int useword = (nsc->sc_type == NE2000_TYPE_NE2000);
d649 1
a649 1
	    (nsc->sc_type == NE2000_TYPE_NE2000));
@


1.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.4 1998/10/05 10:06:16 niklas Exp $	*/
d106 1
a106 1
ne2000_attach(nsc, myea)
d109 1
d256 1
a256 1
	if (dp8390_config(dsc, NULL, 0, 0)) {
@


1.4
log
@We really should use our bus.h API, all big-endian users were broken
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.3 1998/10/05 07:24:13 fgsch Exp $	*/
d214 1
a214 1
				    x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE
d225 1
a225 1
		    dsc->sc_dev.dv_xname, mstart, msize);
@


1.3
log
@Remove unimportant printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.2 1998/10/04 22:28:14 niklas Exp $	*/
d505 1
d509 5
d538 1
d542 4
d561 1
d564 4
d692 1
d695 4
d741 1
d744 4
@


1.2
log
@Use swap16 not bswap16 in OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ne2000.c,v 1.1 1998/09/22 06:38:03 fgsch Exp $	*/
a734 3

	if (maxwait == 0)
		printf("ne2000_writemem: failed to complete\n");
@


1.1
log
@Add the NE[12]00 core driver from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d626 1
a626 1
	hdr->count = bswap16(hdr->count);
@

