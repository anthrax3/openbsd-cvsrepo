head	1.163;
access;
symbols
	OPENBSD_6_2:1.163.0.2
	OPENBSD_6_2_BASE:1.163
	OPENBSD_6_1:1.161.0.4
	OPENBSD_6_1_BASE:1.161
	OPENBSD_6_0:1.158.0.10
	OPENBSD_6_0_BASE:1.158
	OPENBSD_5_9:1.158.0.4
	OPENBSD_5_9_BASE:1.158
	OPENBSD_5_8:1.158.0.6
	OPENBSD_5_8_BASE:1.158
	OPENBSD_5_7:1.158.0.2
	OPENBSD_5_7_BASE:1.158
	OPENBSD_5_6:1.157.0.4
	OPENBSD_5_6_BASE:1.157
	OPENBSD_5_5:1.156.0.4
	OPENBSD_5_5_BASE:1.156
	OPENBSD_5_4:1.154.0.4
	OPENBSD_5_4_BASE:1.154
	OPENBSD_5_3:1.154.0.2
	OPENBSD_5_3_BASE:1.154
	OPENBSD_5_2:1.149.0.2
	OPENBSD_5_2_BASE:1.149
	OPENBSD_5_1_BASE:1.148
	OPENBSD_5_1:1.148.0.6
	OPENBSD_5_0:1.148.0.2
	OPENBSD_5_0_BASE:1.148
	OPENBSD_4_9:1.145.0.2
	OPENBSD_4_9_BASE:1.145
	OPENBSD_4_8:1.144.0.2
	OPENBSD_4_8_BASE:1.144
	OPENBSD_4_7:1.137.0.2
	OPENBSD_4_7_BASE:1.137
	OPENBSD_4_6:1.131.0.6
	OPENBSD_4_6_BASE:1.131
	OPENBSD_4_5:1.131.0.2
	OPENBSD_4_5_BASE:1.131
	OPENBSD_4_4:1.128.0.2
	OPENBSD_4_4_BASE:1.128
	OPENBSD_4_3:1.121.0.2
	OPENBSD_4_3_BASE:1.121
	OPENBSD_4_2:1.117.0.2
	OPENBSD_4_2_BASE:1.117
	OPENBSD_4_1:1.112.0.4
	OPENBSD_4_1_BASE:1.112
	OPENBSD_4_0:1.112.0.2
	OPENBSD_4_0_BASE:1.112
	OPENBSD_3_9:1.109.0.2
	OPENBSD_3_9_BASE:1.109
	OPENBSD_3_8:1.105.0.2
	OPENBSD_3_8_BASE:1.105
	OPENBSD_3_7:1.99.0.2
	OPENBSD_3_7_BASE:1.99
	OPENBSD_3_6:1.98.0.2
	OPENBSD_3_6_BASE:1.98
	SMP_SYNC_A:1.97
	SMP_SYNC_B:1.97
	OPENBSD_3_5:1.95.0.2
	OPENBSD_3_5_BASE:1.95
	OPENBSD_3_4:1.92.0.2
	OPENBSD_3_4_BASE:1.92
	UBC_SYNC_A:1.88
	OPENBSD_3_3:1.88.0.2
	OPENBSD_3_3_BASE:1.88
	OPENBSD_3_2:1.86.0.2
	OPENBSD_3_2_BASE:1.86
	OPENBSD_3_1:1.84.0.2
	OPENBSD_3_1_BASE:1.84
	UBC_SYNC_B:1.87
	UBC:1.76.0.4
	UBC_BASE:1.76
	OPENBSD_3_0:1.76.0.2
	OPENBSD_3_0_BASE:1.76
	OPENBSD_2_9_BASE:1.63
	OPENBSD_2_9:1.63.0.2
	OPENBSD_2_8:1.55.0.6
	OPENBSD_2_8_BASE:1.55
	OPENBSD_2_7:1.55.0.4
	OPENBSD_2_7_BASE:1.55
	SMP:1.55.0.2
	SMP_BASE:1.55
	kame_19991208:1.53
	OPENBSD_2_6:1.50.0.2
	OPENBSD_2_6_BASE:1.50
	OPENBSD_2_5:1.43.0.2
	OPENBSD_2_5_BASE:1.43
	OPENBSD_2_4:1.41.0.2
	OPENBSD_2_4_BASE:1.41
	OPENBSD_2_3:1.38.0.2
	OPENBSD_2_3_BASE:1.38
	OPENBSD_2_2:1.36.0.2
	OPENBSD_2_2_BASE:1.36
	OPENBSD_2_1:1.34.0.2
	OPENBSD_2_1_BASE:1.34;
locks; strict;
comment	@ * @;


1.163
date	2017.04.30.16.45.46;	author mpi;	state Exp;
branches;
next	1.162;
commitid	2Gtqjzrin9LL2yHk;

1.162
date	2017.04.30.13.04.49;	author mpi;	state Exp;
branches;
next	1.161;
commitid	xDPbcPU6tYP39nZG;

1.161
date	2016.09.04.18.20.34;	author tedu;	state Exp;
branches;
next	1.160;
commitid	5vdSYy8ueEhs20To;

1.160
date	2016.09.03.14.43.37;	author jsg;	state Exp;
branches;
next	1.159;
commitid	kmy1dtXauhpMnPAS;

1.159
date	2016.08.16.08.15.04;	author kettenis;	state Exp;
branches;
next	1.158;
commitid	pIWrKeAHR1EBzu22;

1.158
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.157;
commitid	uzzBR7hz9ncd4O6G;

1.157
date	2014.04.13.15.42.32;	author deraadt;	state Exp;
branches;
next	1.156;

1.156
date	2013.12.09.19.54.31;	author deraadt;	state Exp;
branches;
next	1.155;

1.155
date	2013.12.09.19.47.42;	author deraadt;	state Exp;
branches;
next	1.154;

1.154
date	2013.02.14.22.22.48;	author kettenis;	state Exp;
branches;
next	1.153;

1.153
date	2012.10.17.22.27.27;	author deraadt;	state Exp;
branches;
next	1.152;

1.152
date	2012.08.25.18.02.17;	author kettenis;	state Exp;
branches;
next	1.151;

1.151
date	2012.08.25.17.40.34;	author kettenis;	state Exp;
branches;
next	1.150;

1.150
date	2012.08.19.18.38.12;	author kettenis;	state Exp;
branches;
next	1.149;

1.149
date	2012.05.12.18.02.33;	author kettenis;	state Exp;
branches;
next	1.148;

1.148
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.147;

1.147
date	2011.05.22.22.36.53;	author drahn;	state Exp;
branches;
next	1.146;

1.146
date	2011.03.23.15.51.11;	author fgsch;	state Exp;
branches;
next	1.145;

1.145
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.144;

1.144
date	2010.08.07.15.50.23;	author kettenis;	state Exp;
branches;
next	1.143;

1.143
date	2010.08.06.21.04.14;	author kettenis;	state Exp;
branches;
next	1.142;

1.142
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.141;

1.141
date	2010.06.28.14.13.32;	author deraadt;	state Exp;
branches;
next	1.140;

1.140
date	2010.06.28.04.36.31;	author ckuethe;	state Exp;
branches;
next	1.139;

1.139
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.138;

1.138
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.137;

1.137
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.136;

1.136
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.135;

1.135
date	2009.11.01.20.29.00;	author nicm;	state Exp;
branches;
next	1.134;

1.134
date	2009.10.31.12.00.07;	author fgsch;	state Exp;
branches;
next	1.133;

1.133
date	2009.10.31.06.40.16;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.131;

1.131
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.130;

1.130
date	2008.11.23.17.59.00;	author deraadt;	state Exp;
branches;
next	1.129;

1.129
date	2008.10.15.19.12.19;	author blambert;	state Exp;
branches;
next	1.128;

1.128
date	2008.06.08.13.55.06;	author kettenis;	state Exp;
branches;
next	1.127;

1.127
date	2008.04.25.11.30.22;	author dlg;	state Exp;
branches;
next	1.126;

1.126
date	2008.04.24.12.54.44;	author jsing;	state Exp;
branches;
next	1.125;

1.125
date	2008.04.24.12.53.50;	author jsing;	state Exp;
branches;
next	1.124;

1.124
date	2008.04.24.12.49.40;	author jsing;	state Exp;
branches;
next	1.123;

1.123
date	2008.04.24.12.29.34;	author jsing;	state Exp;
branches;
next	1.122;

1.122
date	2008.04.09.19.50.38;	author deraadt;	state Exp;
branches;
next	1.121;

1.121
date	2008.01.23.16.37.55;	author jsing;	state Exp;
branches;
next	1.120;

1.120
date	2008.01.12.13.32.23;	author miod;	state Exp;
branches;
next	1.119;

1.119
date	2008.01.08.00.29.36;	author dlg;	state Exp;
branches;
next	1.118;

1.118
date	2007.08.22.09.22.30;	author jasper;	state Exp;
branches;
next	1.117;

1.117
date	2007.07.15.19.25.49;	author kettenis;	state Exp;
branches;
next	1.116;

1.116
date	2007.06.22.10.09.21;	author jasper;	state Exp;
branches;
next	1.115;

1.115
date	2007.05.08.21.28.11;	author deraadt;	state Exp;
branches;
next	1.114;

1.114
date	2007.05.08.21.18.18;	author deraadt;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.08.20.33.07;	author deraadt;	state Exp;
branches;
next	1.112;

1.112
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.111;

1.111
date	2006.04.27.19.31.44;	author deraadt;	state Exp;
branches;
next	1.110;

1.110
date	2006.03.27.06.14.52;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2006.01.01.11.59.40;	author miod;	state Exp;
branches;
next	1.108;

1.108
date	2005.11.21.18.16.39;	author millert;	state Exp;
branches;
next	1.107;

1.107
date	2005.11.11.15.22.00;	author fgsch;	state Exp;
branches;
next	1.106;

1.106
date	2005.09.26.22.32.06;	author miod;	state Exp;
branches;
next	1.105;

1.105
date	2005.07.18.16.18.28;	author deraadt;	state Exp;
branches;
next	1.104;

1.104
date	2005.07.18.14.36.34;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2005.07.17.12.20.50;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2005.07.11.23.41.58;	author uwe;	state Exp;
branches;
next	1.101;

1.101
date	2005.07.02.15.39.04;	author uwe;	state Exp;
branches;
next	1.100;

1.100
date	2005.05.27.18.42.15;	author uwe;	state Exp;
branches;
next	1.99;

1.99
date	2004.10.20.12.40.14;	author pefo;	state Exp;
branches;
next	1.98;

1.98
date	2004.08.09.22.24.29;	author pefo;	state Exp;
branches;
next	1.97;

1.97
date	2004.05.30.20.59.57;	author deraadt;	state Exp;
branches;
next	1.96;

1.96
date	2004.05.03.15.18.21;	author drahn;	state Exp;
branches;
next	1.95;

1.95
date	2003.10.31.04.07.10;	author drahn;	state Exp;
branches;
next	1.94;

1.94
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.92;

1.92
date	2003.08.15.20.32.16;	author tedu;	state Exp;
branches;
next	1.91;

1.91
date	2003.07.15.03.15.58;	author jason;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.03.21.09.02;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.88;

1.88
date	2002.12.19.01.22.40;	author mickey;	state Exp;
branches;
next	1.87;

1.87
date	2002.10.17.22.11.02;	author art;	state Exp;
branches;
next	1.86;

1.86
date	2002.07.06.19.14.20;	author nordin;	state Exp;
branches;
next	1.85;

1.85
date	2002.06.11.04.54.10;	author miod;	state Exp;
branches;
next	1.84;

1.84
date	2002.04.09.15.08.43;	author pefo;	state Exp;
branches;
next	1.83;

1.83
date	2002.03.14.01.26.54;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2002.03.14.01.24.21;	author jason;	state Exp;
branches;
next	1.81;

1.81
date	2002.02.05.04.15.30;	author mickey;	state Exp;
branches;
next	1.80;

1.80
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.79;

1.79
date	2002.01.25.21.23.38;	author mickey;	state Exp;
branches;
next	1.78;

1.78
date	2002.01.23.07.14.41;	author ericj;	state Exp;
branches;
next	1.77;

1.77
date	2002.01.23.06.45.32;	author ericj;	state Exp;
branches;
next	1.76;

1.76
date	2001.10.05.21.01.10;	author mickey;	state Exp;
branches
	1.76.4.1;
next	1.75;

1.75
date	2001.10.02.23.39.27;	author art;	state Exp;
branches;
next	1.74;

1.74
date	2001.09.30.15.20.59;	author art;	state Exp;
branches;
next	1.73;

1.73
date	2001.09.30.15.07.52;	author art;	state Exp;
branches;
next	1.72;

1.72
date	2001.09.30.01.19.58;	author art;	state Exp;
branches;
next	1.71;

1.71
date	2001.09.30.00.57.07;	author art;	state Exp;
branches;
next	1.70;

1.70
date	2001.09.30.00.37.17;	author art;	state Exp;
branches;
next	1.69;

1.69
date	2001.09.30.00.11.57;	author art;	state Exp;
branches;
next	1.68;

1.68
date	2001.09.29.23.26.07;	author art;	state Exp;
branches;
next	1.67;

1.67
date	2001.09.29.03.07.57;	author art;	state Exp;
branches;
next	1.66;

1.66
date	2001.09.27.22.29.51;	author art;	state Exp;
branches;
next	1.65;

1.65
date	2001.09.27.21.35.46;	author millert;	state Exp;
branches;
next	1.64;

1.64
date	2001.09.27.15.37.33;	author art;	state Exp;
branches;
next	1.63;

1.63
date	2001.04.17.04.30.49;	author aaron;	state Exp;
branches;
next	1.62;

1.62
date	2001.03.15.21.09.17;	author art;	state Exp;
branches;
next	1.61;

1.61
date	2001.03.15.18.55.02;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2001.03.15.18.47.52;	author art;	state Exp;
branches;
next	1.59;

1.59
date	2001.03.15.17.52.20;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2001.03.13.02.53.51;	author mickey;	state Exp;
branches;
next	1.57;

1.57
date	2001.01.24.09.38.04;	author hugh;	state Exp;
branches;
next	1.56;

1.56
date	2000.11.08.15.42.48;	author art;	state Exp;
branches;
next	1.55;

1.55
date	2000.01.27.09.05.33;	author mickey;	state Exp;
branches
	1.55.2.1;
next	1.54;

1.54
date	2000.01.11.04.08.45;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	99.11.28.12.26.05;	author downsj;	state Exp;
branches;
next	1.52;

1.52
date	99.11.09.04.00.08;	author rahnds;	state Exp;
branches;
next	1.51;

1.51
date	99.10.26.12.27.39;	author downsj;	state Exp;
branches;
next	1.50;

1.50
date	99.08.08.16.28.17;	author niklas;	state Exp;
branches;
next	1.49;

1.49
date	99.08.08.15.08.24;	author niklas;	state Exp;
branches;
next	1.48;

1.48
date	99.08.08.01.34.14;	author niklas;	state Exp;
branches;
next	1.47;

1.47
date	99.07.26.15.27.22;	author niklas;	state Exp;
branches;
next	1.46;

1.46
date	99.07.26.15.09.00;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	99.07.26.12.31.43;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	99.06.25.17.59.23;	author rees;	state Exp;
branches;
next	1.43;

1.43
date	99.02.09.02.39.43;	author rees;	state Exp;
branches;
next	1.42;

1.42
date	99.01.11.05.12.16;	author millert;	state Exp;
branches;
next	1.41;

1.41
date	98.09.20.21.41.27;	author rahnds;	state Exp;
branches;
next	1.40;

1.40
date	98.08.18.08.52.13;	author pefo;	state Exp;
branches;
next	1.39;

1.39
date	98.08.07.16.48.14;	author pefo;	state Exp;
branches;
next	1.38;

1.38
date	98.02.23.11.41.24;	author downsj;	state Exp;
branches;
next	1.37;

1.37
date	98.02.05.16.49.24;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	97.09.03.20.55.28;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.07.07.16.37.12;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	97.04.10.17.16.37;	author pefo;	state Exp;
branches;
next	1.33;

1.33
date	97.03.17.08.11.11;	author pefo;	state Exp;
branches;
next	1.32;

1.32
date	97.03.12.20.17.37;	author pefo;	state Exp;
branches;
next	1.31;

1.31
date	97.03.06.07.07.43;	author tholo;	state Exp;
branches;
next	1.30;

1.30
date	96.12.10.22.28.28;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	96.12.10.19.21.53;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	96.11.29.22.54.52;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	96.11.12.20.30.27;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	96.11.09.21.50.43;	author tholo;	state Exp;
branches;
next	1.25;

1.25
date	96.10.30.15.01.49;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	96.10.22.01.11.50;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	96.10.16.23.18.42;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.10.16.12.31.58;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.08.29.12.58.30;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.07.02.09.47.46;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	96.06.24.20.48.31;	author pefo;	state Exp;
branches;
next	1.18;

1.18
date	96.06.22.23.12.14;	author pefo;	state Exp;
branches;
next	1.17;

1.17
date	96.06.10.19.29.59;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.06.10.07.32.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.26.00.27.14;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.10.12.37.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.07.07.36.25;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.04.29.14.16.15;	author hvozda;	state Exp;
branches;
next	1.11;

1.11
date	96.04.21.22.23.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.04.18.23.47.32;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.03.20.01.00.42;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.03.19.21.10.09;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.08.16.42.51;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.02.20.04.35.49;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.01.16.20.13.02;	author hvozda;	state Exp;
branches;
next	1.4;

1.4
date	96.01.03.05.16.10;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.17;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.02.37.17;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches;
next	;

1.55.2.1
date	2001.05.14.22.23.38;	author niklas;	state Exp;
branches;
next	1.55.2.2;

1.55.2.2
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.55.2.3;

1.55.2.3
date	2002.03.06.02.11.43;	author niklas;	state Exp;
branches;
next	1.55.2.4;

1.55.2.4
date	2002.03.28.11.51.00;	author niklas;	state Exp;
branches;
next	1.55.2.5;

1.55.2.5
date	2003.03.28.00.38.12;	author niklas;	state Exp;
branches;
next	1.55.2.6;

1.55.2.6
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	1.55.2.7;

1.55.2.7
date	2004.02.19.10.56.17;	author niklas;	state Exp;
branches;
next	1.55.2.8;

1.55.2.8
date	2004.06.05.23.12.41;	author niklas;	state Exp;
branches;
next	;

1.76.4.1
date	2002.01.31.22.55.31;	author niklas;	state Exp;
branches;
next	1.76.4.2;

1.76.4.2
date	2002.06.11.03.42.17;	author art;	state Exp;
branches;
next	1.76.4.3;

1.76.4.3
date	2002.10.29.00.33.24;	author art;	state Exp;
branches;
next	1.76.4.4;

1.76.4.4
date	2003.05.19.21.54.24;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.163
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@/*	$OpenBSD: com.c,v 1.162 2017/04/30 13:04:49 mpi Exp $	*/
/*	$NetBSD: com.c,v 1.82.4.1 1996/06/02 09:08:00 mrg Exp $	*/

/*
 * Copyright (c) 1997 - 1999, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)com.c	7.5 (Berkeley) 5/16/91
 */

/*
 * COM driver, based on HP dca driver
 * uses National Semiconductor NS16450/NS16550AF UART
 */
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/selinfo.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/vnode.h>
#ifdef DDB
#include <ddb/db_var.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#define	COM_CONSOLE
#include <dev/cons.h>

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/ic/ns16550reg.h>
#define	com_lcr	com_cfcr

cdev_decl(com);

static u_char tiocm_xxx2mcr(int);

void	compwroff(struct com_softc *);
void	cominit(bus_space_tag_t, bus_space_handle_t, int, int);
int	com_is_console(bus_space_tag_t, bus_addr_t);

struct cfdriver com_cd = {
	NULL, "com", DV_TTY
};

int	comdefaultrate = TTYDEF_SPEED;
#ifdef COM_CONSOLE
int	comconsfreq;
int	comconsrate = TTYDEF_SPEED;
bus_addr_t comconsaddr = 0;
int	comconsattached;
bus_space_tag_t comconsiot;
bus_space_handle_t comconsioh;
int	comconsunit;
tcflag_t comconscflag = TTYDEF_CFLAG;
#endif

int	commajor;

#define	DEVUNIT(x)	(minor(x) & 0x7f)
#define	DEVCUA(x)	(minor(x) & 0x80)

int
comspeed(long freq, long speed)
{
#define	divrnd(n, q)	(((n)*2/(q)+1)/2)	/* divide and round off */

	int x, err;

	if (speed == 0)
		return 0;
	if (speed < 0)
		return -1;
	x = divrnd((freq / 16), speed);
	if (x <= 0)
		return -1;
	err = divrnd((quad_t)freq * 1000 / 16, speed * x) - 1000;
	if (err < 0)
		err = -err;
	if (err > COM_TOLERANCE)
		return -1;
	return x;

#undef	divrnd
}

#ifdef COM_CONSOLE
int
comprobe1(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int i, k;

	/* force access to id reg */
	bus_space_write_1(iot, ioh, com_lcr, 0);
	bus_space_write_1(iot, ioh, com_iir, 0);
	for (i = 0; i < 32; i++) {
		k = bus_space_read_1(iot, ioh, com_iir);
		if (k & 0x38) {
			bus_space_read_1(iot, ioh, com_data); /* cleanup */
		} else
			break;
	}
	if (i >= 32)
		return 0;

	return 1;
}
#endif

int
com_detach(struct device *self, int flags)
{
	struct com_softc *sc = (struct com_softc *)self;
	int maj, mn;

	sc->sc_swflags |= COM_SW_DEAD;

	/* Locate the major number. */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == comopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	/* XXX a symbolic constant for the cua bit would be nicer. */
	mn |= 0x80;
	vdevgone(maj, mn, mn, VCHR);

	/* Detach and free the tty. */
	if (sc->sc_tty) {
		ttyfree(sc->sc_tty);
	}

	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
	softintr_disestablish(sc->sc_si);

	return (0);
}

int
com_activate(struct device *self, int act)
{
	struct com_softc *sc = (struct com_softc *)self;
	int s, rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (timeout_del(&sc->sc_dtr_tmo)) {
			/* Make sure DTR gets raised upon resume. */
			SET(sc->sc_mcr, MCR_DTR | MCR_RTS);
		}
		timeout_del(&sc->sc_diag_tmo);
		break;
	case DVACT_RESUME:
		com_resume(sc);
		break;
	case DVACT_DEACTIVATE:
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
			rv = EBUSY;
			break;
		}

		s = spltty();
		if (sc->disable != NULL && sc->enabled != 0) {
			(*sc->disable)(sc);
			sc->enabled = 0;
		}
		splx(s);
		break;
	}
	return (rv);
}

int
comopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct tty *tp;
	int s;
	int error = 0;

	if (unit >= com_cd.cd_ndevs)
		return ENXIO;
	sc = com_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

	s = spltty();
	if (!sc->sc_tty) {
		tp = sc->sc_tty = ttymalloc(1000000);
	} else
		tp = sc->sc_tty;
	splx(s);

	tp->t_oproc = comstart;
	tp->t_param = comparam;
	tp->t_dev = dev;
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
		ttychars(tp);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
#ifdef COM_CONSOLE
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
			tp->t_cflag = comconscflag;
			tp->t_ispeed = tp->t_ospeed = comconsrate;
		} else
#endif
		{
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_ispeed = tp->t_ospeed = comdefaultrate;
		}
		if (ISSET(sc->sc_swflags, COM_SW_CLOCAL))
			SET(tp->t_cflag, CLOCAL);
		if (ISSET(sc->sc_swflags, COM_SW_CRTSCTS))
			SET(tp->t_cflag, CRTSCTS);
		if (ISSET(sc->sc_swflags, COM_SW_MDMBUF))
			SET(tp->t_cflag, MDMBUF);
		tp->t_lflag = TTYDEF_LFLAG;

		s = spltty();

		sc->sc_initialize = 1;
		comparam(tp, &tp->t_termios);
		ttsetwater(tp);

		sc->sc_ibufp = sc->sc_ibuf = sc->sc_ibufs[0];
		sc->sc_ibufhigh = sc->sc_ibuf + COM_IHIGHWATER;
		sc->sc_ibufend = sc->sc_ibuf + COM_IBUFSIZE;

		iot = sc->sc_iot;
		ioh = sc->sc_ioh;

		/*
		 * Wake up the sleepy heads.
		 */
		if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
			switch (sc->sc_uarttype) {
			case COM_UART_ST16650:
			case COM_UART_ST16650V2:
				bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
				bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
				bus_space_write_1(iot, ioh, com_ier, 0);
				bus_space_write_1(iot, ioh, com_efr, 0);
				bus_space_write_1(iot, ioh, com_lcr, 0);
				break;
			case COM_UART_TI16750:
				bus_space_write_1(iot, ioh, com_ier, 0);
				break;
			}
		}

		if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
			u_int8_t fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST;
			u_int8_t lcr;

			if (tp->t_ispeed <= 1200)
				fifo |= FIFO_TRIGGER_1;
			else if (tp->t_ispeed <= 38400)
				fifo |= FIFO_TRIGGER_4;
			else
				fifo |= FIFO_TRIGGER_8;
			if (sc->sc_uarttype == COM_UART_TI16750) {
				fifo |= FIFO_ENABLE_64BYTE;
				lcr = bus_space_read_1(iot, ioh, com_lcr);
				bus_space_write_1(iot, ioh, com_lcr,
				    lcr | LCR_DLAB);
			}

			/*
			 * (Re)enable and drain FIFOs.
			 *
			 * Certain SMC chips cause problems if the FIFOs are
			 * enabled while input is ready. Turn off the FIFO
			 * if necessary to clear the input. Test the input
			 * ready bit after enabling the FIFOs to handle races
			 * between enabling and fresh input.
			 *
			 * Set the FIFO threshold based on the receive speed.
			 */
			for (;;) {
				bus_space_write_1(iot, ioh, com_fifo, 0);
				delay(100);
				(void) bus_space_read_1(iot, ioh, com_data);
				bus_space_write_1(iot, ioh, com_fifo, fifo |
				    FIFO_RCV_RST | FIFO_XMT_RST);
				delay(100);
				if(!ISSET(bus_space_read_1(iot, ioh,
				    com_lsr), LSR_RXRDY))
					break;
			}
			if (sc->sc_uarttype == COM_UART_TI16750)
				bus_space_write_1(iot, ioh, com_lcr, lcr);
		}

		/* Flush any pending I/O. */
		while (ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
			(void) bus_space_read_1(iot, ioh, com_data);

		/* You turn me on, baby! */
		sc->sc_mcr = MCR_DTR | MCR_RTS;
		if (!ISSET(sc->sc_hwflags, COM_HW_NOIEN))
			SET(sc->sc_mcr, MCR_IENABLE);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		sc->sc_ier = IER_ERXRDY | IER_ERLS | IER_EMSC;
		bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

		sc->sc_msr = bus_space_read_1(iot, ioh, com_msr);
		if (ISSET(sc->sc_swflags, COM_SW_SOFTCAR) || DEVCUA(dev) ||
		    ISSET(sc->sc_msr, MSR_DCD) || ISSET(tp->t_cflag, MDMBUF))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0)
		return EBUSY;
	else
		s = spltty();

	if (DEVCUA(dev)) {
		if (ISSET(tp->t_state, TS_ISOPEN)) {
			/* Ah, but someone already is dialed in... */
			splx(s);
			return EBUSY;
		}
		sc->sc_cua = 1;		/* We go into CUA mode. */
	} else {
		/* tty (not cua) device; wait for carrier if necessary. */
		if (ISSET(flag, O_NONBLOCK)) {
			if (sc->sc_cua) {
				/* Opening TTY non-blocking... but the CUA is busy. */
				splx(s);
				return EBUSY;
			}
		} else {
			while (sc->sc_cua ||
			    (!ISSET(tp->t_cflag, CLOCAL) &&
				!ISSET(tp->t_state, TS_CARR_ON))) {
				SET(tp->t_state, TS_WOPEN);
				error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH, ttopen, 0);
				/*
				 * If TS_WOPEN has been reset, that means the cua device
				 * has been closed.  We don't want to fail in that case,
				 * so just go around again.
				 */
				if (error && ISSET(tp->t_state, TS_WOPEN)) {
					CLR(tp->t_state, TS_WOPEN);
					if (!sc->sc_cua && !ISSET(tp->t_state, TS_ISOPEN))
						compwroff(sc);
					splx(s);
					return error;
				}
			}
		}
	}
	splx(s);

	return (*linesw[tp->t_line].l_open)(dev, tp, p);
}

int
comclose(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc = com_cd.cd_devs[unit];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;
	int s;

#ifdef COM_CONSOLE
	/* XXX This is for cons.c. */
	if (!ISSET(tp->t_state, TS_ISOPEN))
		return 0;
#endif

	if(sc->sc_swflags & COM_SW_DEAD)
		return 0;

	(*linesw[tp->t_line].l_close)(tp, flag, p);
	s = spltty();
	if (ISSET(tp->t_state, TS_WOPEN)) {
		/* tty device is waiting for carrier; drop dtr then re-raise */
		CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		timeout_add_sec(&sc->sc_dtr_tmo, 2);
	} else {
		/* no one else waiting; turn off the uart */
		compwroff(sc);
	}
	CLR(tp->t_state, TS_BUSY | TS_FLUSH);
	sc->sc_cua = 0;
	splx(s);
	ttyclose(tp);

#ifdef COM_CONSOLE
#ifdef notyet /* XXXX */
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		ttyfree(tp);
		sc->sc_tty = 0;
	}
#endif
#endif
	return 0;
}

void
compwroff(struct com_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp = sc->sc_tty;

	CLR(sc->sc_lcr, LCR_SBREAK);
	bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
	bus_space_write_1(iot, ioh, com_ier, 0);
	if (ISSET(tp->t_cflag, HUPCL) &&
	    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
		/* XXX perhaps only clear DTR */
		sc->sc_mcr = 0;
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/*
	 * Turn FIFO off; enter sleep mode if possible.
	 */
	bus_space_write_1(iot, ioh, com_fifo, 0);
	delay(100);
	if (ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		(void) bus_space_read_1(iot, ioh, com_data);
	delay(100);
	bus_space_write_1(iot, ioh, com_fifo,
			  FIFO_RCV_RST | FIFO_XMT_RST);

	if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			break;
		}
	}
}

void
com_resume(struct com_softc *sc)
{
	struct tty *tp = sc->sc_tty;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int ospeed;

	if (!tp || !ISSET(tp->t_state, TS_ISOPEN)) {
#ifdef COM_CONSOLE
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			cominit(iot, ioh, comconsrate, comconsfreq);
#endif
		return;
	}

	/*
	 * Wake up the sleepy heads.
	 */
	if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, 0);
			bus_space_write_1(iot, ioh, com_efr, 0);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, 0);
			break;
		}
	}

	ospeed = comspeed(sc->sc_frequency, tp->t_ospeed);

	if (ospeed != 0) {
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_dlbl, ospeed);
		bus_space_write_1(iot, ioh, com_dlbh, ospeed >> 8);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
	} else {
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
	}

	if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
		u_int8_t fifo = FIFO_ENABLE|FIFO_RCV_RST|FIFO_XMT_RST;
		u_int8_t lcr;

		if (tp->t_ispeed <= 1200)
			fifo |= FIFO_TRIGGER_1;
		else if (tp->t_ispeed <= 38400)
			fifo |= FIFO_TRIGGER_4;
		else
			fifo |= FIFO_TRIGGER_8;
		if (sc->sc_uarttype == COM_UART_TI16750) {
			fifo |= FIFO_ENABLE_64BYTE;
			lcr = bus_space_read_1(iot, ioh, com_lcr);
			bus_space_write_1(iot, ioh, com_lcr,
			    lcr | LCR_DLAB);
		}

		/*
		 * (Re)enable and drain FIFOs.
		 *
		 * Certain SMC chips cause problems if the FIFOs are
		 * enabled while input is ready. Turn off the FIFO
		 * if necessary to clear the input. Test the input
		 * ready bit after enabling the FIFOs to handle races
		 * between enabling and fresh input.
		 *
		 * Set the FIFO threshold based on the receive speed.
		 */
		for (;;) {
			bus_space_write_1(iot, ioh, com_fifo, 0);
			delay(100);
			(void) bus_space_read_1(iot, ioh, com_data);
			bus_space_write_1(iot, ioh, com_fifo, fifo |
			    FIFO_RCV_RST | FIFO_XMT_RST);
			delay(100);
			if(!ISSET(bus_space_read_1(iot, ioh,
			    com_lsr), LSR_RXRDY))
				break;
		}
		if (sc->sc_uarttype == COM_UART_TI16750)
			bus_space_write_1(iot, ioh, com_lcr, lcr);
	}

	/* You turn me on, baby! */
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
}

void
com_raisedtr(void *arg)
{
	struct com_softc *sc = arg;

	SET(sc->sc_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);
}

int
comread(dev_t dev, struct uio *uio, int flag)
{
	struct com_softc *sc = com_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
comwrite(dev_t dev, struct uio *uio, int flag)
{
	struct com_softc *sc = com_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
comtty(dev_t dev)
{
	struct com_softc *sc = com_cd.cd_devs[DEVUNIT(dev)];
	struct tty *tp = sc->sc_tty;

	return (tp);
}

static u_char
tiocm_xxx2mcr(int data)
{
	u_char m = 0;

	if (ISSET(data, TIOCM_DTR))
		SET(m, MCR_DTR);
	if (ISSET(data, TIOCM_RTS))
		SET(m, MCR_RTS);
	return m;
}

int
comioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int unit = DEVUNIT(dev);
	struct com_softc *sc = com_cd.cd_devs[unit];
	struct tty *tp = sc->sc_tty;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int error;

	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;
	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return error;

	switch (cmd) {
	case TIOCSBRK:
		SET(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		break;
	case TIOCCBRK:
		CLR(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		break;
	case TIOCSDTR:
		SET(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCCDTR:
		CLR(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMSET:
		CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
	case TIOCMBIS:
		SET(sc->sc_mcr, tiocm_xxx2mcr(*(int *)data));
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMBIC:
		CLR(sc->sc_mcr, tiocm_xxx2mcr(*(int *)data));
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		break;
	case TIOCMGET: {
		u_char m;
		int bits = 0;

		m = sc->sc_mcr;
		if (ISSET(m, MCR_DTR))
			SET(bits, TIOCM_DTR);
		if (ISSET(m, MCR_RTS))
			SET(bits, TIOCM_RTS);
		m = sc->sc_msr;
		if (ISSET(m, MSR_DCD))
			SET(bits, TIOCM_CD);
		if (ISSET(m, MSR_CTS))
			SET(bits, TIOCM_CTS);
		if (ISSET(m, MSR_DSR))
			SET(bits, TIOCM_DSR);
		if (ISSET(m, MSR_RI | MSR_TERI))
			SET(bits, TIOCM_RI);
		if (bus_space_read_1(iot, ioh, com_ier))
			SET(bits, TIOCM_LE);
		*(int *)data = bits;
		break;
	}
	case TIOCGFLAGS: {
		int driverbits, userbits = 0;

		driverbits = sc->sc_swflags;
		if (ISSET(driverbits, COM_SW_SOFTCAR))
			SET(userbits, TIOCFLAG_SOFTCAR);
		if (ISSET(driverbits, COM_SW_CLOCAL))
			SET(userbits, TIOCFLAG_CLOCAL);
		if (ISSET(driverbits, COM_SW_CRTSCTS))
			SET(userbits, TIOCFLAG_CRTSCTS);
		if (ISSET(driverbits, COM_SW_MDMBUF))
			SET(userbits, TIOCFLAG_MDMBUF);
		if (ISSET(driverbits, COM_SW_PPS))
			SET(userbits, TIOCFLAG_PPS);

		*(int *)data = userbits;
		break;
	}
	case TIOCSFLAGS: {
		int userbits, driverbits = 0;

		error = suser(p, 0);
		if (error != 0)
			return(EPERM);

		userbits = *(int *)data;
		if (ISSET(userbits, TIOCFLAG_SOFTCAR) ||
		    ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			SET(driverbits, COM_SW_SOFTCAR);
		if (ISSET(userbits, TIOCFLAG_CLOCAL))
			SET(driverbits, COM_SW_CLOCAL);
		if (ISSET(userbits, TIOCFLAG_CRTSCTS))
			SET(driverbits, COM_SW_CRTSCTS);
		if (ISSET(userbits, TIOCFLAG_MDMBUF))
			SET(driverbits, COM_SW_MDMBUF);
		if (ISSET(userbits, TIOCFLAG_PPS))
			SET(driverbits, COM_SW_PPS);

		sc->sc_swflags = driverbits;
		break;
	}
	default:
		return ENOTTY;
	}

	return 0;
}

/* already called at spltty */
int
comparam(struct tty *tp, struct termios *t)
{
	struct com_softc *sc = com_cd.cd_devs[DEVUNIT(tp->t_dev)];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int ospeed = comspeed(sc->sc_frequency, t->c_ospeed);
	u_char lcr;
	tcflag_t oldcflag;

	/* Check requested parameters. */
	if (ospeed < 0 || (t->c_ispeed && t->c_ispeed != t->c_ospeed))
		return EINVAL;

	lcr = ISSET(sc->sc_lcr, LCR_SBREAK);

	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		SET(lcr, LCR_5BITS);
		break;
	case CS6:
		SET(lcr, LCR_6BITS);
		break;
	case CS7:
		SET(lcr, LCR_7BITS);
		break;
	case CS8:
		SET(lcr, LCR_8BITS);
		break;
	}
	if (ISSET(t->c_cflag, PARENB)) {
		SET(lcr, LCR_PENAB);
		if (!ISSET(t->c_cflag, PARODD))
			SET(lcr, LCR_PEVEN);
	}
	if (ISSET(t->c_cflag, CSTOPB))
		SET(lcr, LCR_STOPB);

	sc->sc_lcr = lcr;

	if (ospeed == 0) {
		CLR(sc->sc_mcr, MCR_DTR);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/*
	 * Set the FIFO threshold based on the receive speed, if we are
	 * changing it.
	 */
	if (sc->sc_initialize || (tp->t_ispeed != t->c_ispeed)) {
		sc->sc_initialize = 0;

		if (ospeed != 0) {
			/*
			 * Make sure the transmit FIFO is empty before
			 * proceeding.  If we don't do this, some revisions
			 * of the UART will hang.  Interestingly enough,
			 * even if we do this while the last character is
			 * still being pushed out, they don't hang.  This
			 * seems good enough.
			 */
			while (ISSET(tp->t_state, TS_BUSY)) {
				int error;

				++sc->sc_halt;
				error = ttysleep(tp, &tp->t_outq,
				    TTOPRI | PCATCH, "comprm", 0);
				--sc->sc_halt;
				if (error) {
					comstart(tp);
					return (error);
				}
			}

			bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
			bus_space_write_1(iot, ioh, com_dlbl, ospeed);
			bus_space_write_1(iot, ioh, com_dlbh, ospeed >> 8);
			bus_space_write_1(iot, ioh, com_lcr, lcr);
			SET(sc->sc_mcr, MCR_DTR);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
		} else
			bus_space_write_1(iot, ioh, com_lcr, lcr);

		if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
			if (sc->sc_uarttype == COM_UART_TI16750) {
				bus_space_write_1(iot, ioh, com_lcr,
				    lcr | LCR_DLAB);
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE | FIFO_ENABLE_64BYTE |
				    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
				bus_space_write_1(iot, ioh, com_lcr, lcr);
			} else
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE |
				    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
		}
	} else
		bus_space_write_1(iot, ioh, com_lcr, lcr);

	/* When not using CRTSCTS, RTS follows DTR. */
	if (!ISSET(t->c_cflag, CRTSCTS)) {
		if (ISSET(sc->sc_mcr, MCR_DTR)) {
			if (!ISSET(sc->sc_mcr, MCR_RTS)) {
				SET(sc->sc_mcr, MCR_RTS);
				bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			}
		} else {
			if (ISSET(sc->sc_mcr, MCR_RTS)) {
				CLR(sc->sc_mcr, MCR_RTS);
				bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			}
		}
		sc->sc_dtr = MCR_DTR | MCR_RTS;
	} else
		sc->sc_dtr = MCR_DTR;

	/* and copy to tty */
	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	oldcflag = tp->t_cflag;
	tp->t_cflag = t->c_cflag;

	/*
	 * If DCD is off and MDMBUF is changed, ask the tty layer if we should
	 * stop the device.
	 */
	if (!ISSET(sc->sc_msr, MSR_DCD) &&
	    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR) &&
	    ISSET(oldcflag, MDMBUF) != ISSET(tp->t_cflag, MDMBUF) &&
	    (*linesw[tp->t_line].l_modem)(tp, 0) == 0) {
		CLR(sc->sc_mcr, sc->sc_dtr);
		bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
	}

	/* Just to be sure... */
	comstart(tp);
	return 0;
}

void
comstart(struct tty *tp)
{
	struct com_softc *sc = com_cd.cd_devs[DEVUNIT(tp->t_dev)];
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY))
		goto out;
	if (ISSET(tp->t_state, TS_TIMEOUT | TS_TTSTOP) || sc->sc_halt > 0)
		goto stopped;
	if (ISSET(tp->t_cflag, CRTSCTS) && !ISSET(sc->sc_msr, MSR_CTS))
		goto stopped;
	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto stopped;
	SET(tp->t_state, TS_BUSY);

	/* Enable transmit completion interrupts. */
	if (!ISSET(sc->sc_ier, IER_ETXRDY)) {
		SET(sc->sc_ier, IER_ETXRDY);
		bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
	}

	if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
		u_char buffer[128];	/* largest fifo */
		int i, n;

		n = q_to_b(&tp->t_outq, buffer,
		    min(sc->sc_fifolen, sizeof buffer));
		for (i = 0; i < n; i++) {
			bus_space_write_1(iot, ioh, com_data, buffer[i]);
		}
		bzero(buffer, n);
	} else if (tp->t_outq.c_cc != 0)
		bus_space_write_1(iot, ioh, com_data, getc(&tp->t_outq));
out:
	splx(s);
	return;
stopped:
	if (ISSET(sc->sc_ier, IER_ETXRDY)) {
		CLR(sc->sc_ier, IER_ETXRDY);
		bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
	}
	splx(s);
}

/*
 * Stop output on a line.
 */
int
comstop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY))
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	splx(s);
	return 0;
}

void
comdiag(void *arg)
{
	struct com_softc *sc = arg;
	int overflows, floods;
	int s;

	s = spltty();
	sc->sc_errors = 0;
	overflows = sc->sc_overflows;
	sc->sc_overflows = 0;
	floods = sc->sc_floods;
	sc->sc_floods = 0;
	splx(s);
	log(LOG_WARNING, "%s: %d silo overflow%s, %d ibuf overflow%s\n",
	    sc->sc_dev.dv_xname,
	    overflows, overflows == 1 ? "" : "s",
	    floods, floods == 1 ? "" : "s");
}

void
comsoft(void *arg)
{
	struct com_softc *sc = (struct com_softc *)arg;
	struct tty *tp;
	u_char *ibufp;
	u_char *ibufend;
	int c;
	int s;
	static int lsrmap[8] = {
		0,      TTY_PE,
		TTY_FE, TTY_PE|TTY_FE,
		TTY_FE, TTY_PE|TTY_FE,
		TTY_FE, TTY_PE|TTY_FE
	};

	if (sc == NULL || sc->sc_ibufp == sc->sc_ibuf)
		return;

	tp = sc->sc_tty;

	s = spltty();

	ibufp = sc->sc_ibuf;
	ibufend = sc->sc_ibufp;

	if (ibufp == ibufend) {
		splx(s);
		return;
	}

	sc->sc_ibufp = sc->sc_ibuf = (ibufp == sc->sc_ibufs[0]) ?
				     sc->sc_ibufs[1] : sc->sc_ibufs[0];
	sc->sc_ibufhigh = sc->sc_ibuf + COM_IHIGHWATER;
	sc->sc_ibufend = sc->sc_ibuf + COM_IBUFSIZE;

	if (tp == NULL || !ISSET(tp->t_state, TS_ISOPEN)) {
		splx(s);
		return;
	}

	if (ISSET(tp->t_cflag, CRTSCTS) &&
	    !ISSET(sc->sc_mcr, MCR_RTS)) {
		/* XXX */
		SET(sc->sc_mcr, MCR_RTS);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr,
		    sc->sc_mcr);
	}

	splx(s);

	while (ibufp < ibufend) {
		c = *ibufp++;
		if (ISSET(*ibufp, LSR_OE)) {
			sc->sc_overflows++;
			if (sc->sc_errors++ == 0)
				timeout_add_sec(&sc->sc_diag_tmo, 60);
		}
		/* This is ugly, but fast. */
		c |= lsrmap[(*ibufp++ & (LSR_BI|LSR_FE|LSR_PE)) >> 2];
		(*linesw[tp->t_line].l_rint)(c, tp);
	}
}

int
comintr(void *arg)
{
	struct com_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct tty *tp;
	u_char lsr, data, msr, delta;

	if (!sc->sc_tty)
		return (0);		/* Can't do squat. */

	if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
		return (0);

	tp = sc->sc_tty;

	for (;;) {
		lsr = bus_space_read_1(iot, ioh, com_lsr);

		if (ISSET(lsr, LSR_RXRDY)) {
			u_char *p = sc->sc_ibufp;

			softintr_schedule(sc->sc_si);
			do {
				data = bus_space_read_1(iot, ioh, com_data);
				if (ISSET(lsr, LSR_BI)) {
#if defined(COM_CONSOLE) && defined(DDB)
					if (ISSET(sc->sc_hwflags,
					    COM_HW_CONSOLE)) {
						if (db_console)
							db_enter();
						goto next;
					}
#endif
					data = 0;
				}
				if (p >= sc->sc_ibufend) {
					sc->sc_floods++;
					if (sc->sc_errors++ == 0)
						timeout_add_sec(&sc->sc_diag_tmo, 60);
				} else {
					*p++ = data;
					*p++ = lsr;
					if (p == sc->sc_ibufhigh &&
					    ISSET(tp->t_cflag, CRTSCTS)) {
						/* XXX */
						CLR(sc->sc_mcr, MCR_RTS);
						bus_space_write_1(iot, ioh, com_mcr,
						    sc->sc_mcr);
					}
				}
#if defined(COM_CONSOLE) && defined(DDB)
			next:
#endif
				lsr = bus_space_read_1(iot, ioh, com_lsr);
			} while (ISSET(lsr, LSR_RXRDY));

			sc->sc_ibufp = p;
		}
		msr = bus_space_read_1(iot, ioh, com_msr);

		if (msr != sc->sc_msr) {
			delta = msr ^ sc->sc_msr;

			ttytstamp(tp, sc->sc_msr & MSR_CTS, msr & MSR_CTS,
			    sc->sc_msr & MSR_DCD, msr & MSR_DCD);

			sc->sc_msr = msr;
			if (ISSET(delta, MSR_DCD)) {
				if (!ISSET(sc->sc_swflags, COM_SW_SOFTCAR) &&
				    (*linesw[tp->t_line].l_modem)(tp, ISSET(msr, MSR_DCD)) == 0) {
					CLR(sc->sc_mcr, sc->sc_dtr);
					bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
				}
			}
			if (ISSET(delta & msr, MSR_CTS) &&
			    ISSET(tp->t_cflag, CRTSCTS)) {
				/* the line is up and we want to do rts/cts flow control */
				(*linesw[tp->t_line].l_start)(tp);
			}
		}

		if (ISSET(lsr, LSR_TXRDY) && ISSET(tp->t_state, TS_BUSY)) {
			CLR(tp->t_state, TS_BUSY | TS_FLUSH);
			if (sc->sc_halt > 0)
				wakeup(&tp->t_outq);
			(*linesw[tp->t_line].l_start)(tp);
		}

		if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
	}
}

/*
 * The following functions are polled getc and putc routines, used
 * by the console glue.
 */

int
com_common_getc(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	int s = splhigh();
	u_char stat, c;

	/* Block until a character becomes available. */
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		continue;

	c = bus_space_read_1(iot, ioh, com_data);

	/* Clear any interrupts generated by this transmission. */
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return (c);
}

void
com_common_putc(bus_space_tag_t iot, bus_space_handle_t ioh, int c)
{
	int s = spltty();
	int timo;

	/* Wait for any pending transmission to finish. */
	timo = 2000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		delay(1);

	bus_space_write_1(iot, ioh, com_data, (u_int8_t)(c & 0xff));
	bus_space_barrier(iot, ioh, 0, COM_NPORTS,
	    (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE));

	/* Wait for this transmission to complete. */
	timo = 2000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		delay(1);

	splx(s);
}

void
cominit(bus_space_tag_t iot, bus_space_handle_t ioh, int rate, int frequency)
{
	int s = splhigh();
	u_char stat;

	bus_space_write_1(iot, ioh, com_lcr, LCR_DLAB);
	rate = comspeed(frequency, rate); /* XXX not comdefaultrate? */
	bus_space_write_1(iot, ioh, com_dlbl, rate);
	bus_space_write_1(iot, ioh, com_dlbh, rate >> 8);
	bus_space_write_1(iot, ioh, com_lcr, LCR_8BITS);
	bus_space_write_1(iot, ioh, com_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(iot, ioh, com_ier, 0);  /* Make sure they are off */
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_1);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
}

#ifdef COM_CONSOLE
void  
comcnprobe(struct consdev *cp)
{
	bus_space_handle_t ioh;
	int found;

	if (comconsaddr == 0)
		return;

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &ioh))
		return;
	found = comprobe1(comconsiot, ioh);
	bus_space_unmap(comconsiot, ioh, COM_NPORTS);
	if (!found)
		return;

	/* Locate the major number. */
	for (commajor = 0; commajor < nchrdev; commajor++)
		if (cdevsw[commajor].d_open == comopen)
			break;

	/* Initialize required fields. */
	cp->cn_dev = makedev(commajor, comconsunit);
	cp->cn_pri = CN_HIGHPRI;
}

void
comcninit(struct consdev *cp)
{
	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
		panic("comcninit: mapping failed");

	if (comconsfreq == 0)
		comconsfreq = COM_FREQ;

	cominit(comconsiot, comconsioh, comconsrate, comconsfreq);
}

int
comcnattach(bus_space_tag_t iot, bus_addr_t iobase, int rate,
    int frequency, tcflag_t cflag)
{
	static struct consdev comcons = {
		NULL, NULL, comcngetc, comcnputc, comcnpollc, NULL,
		NODEV, CN_LOWPRI
	};

#ifndef __sparc64__
	if (bus_space_map(iot, iobase, COM_NPORTS, 0, &comconsioh))
		return ENOMEM;
#endif

	cominit(iot, comconsioh, rate, frequency);

	cn_tab = &comcons;

	comconsiot = iot;
	comconsaddr = iobase;
	comconscflag = cflag;
	comconsfreq = frequency;
	comconsrate = rate;

	return (0);
}

int
comcngetc(dev_t dev)
{
	return (com_common_getc(comconsiot, comconsioh));
}

/*
 * Console kernel output character routine.
 */
void
comcnputc(dev_t dev, int c)
{
	com_common_putc(comconsiot, comconsioh, c);
}

void
comcnpollc(dev_t dev, int on)
{

}
#endif	/* COM_CONSOLE */

void	com_enable_debugport(struct com_softc *);
void	com_fifo_probe(struct com_softc *);

#ifdef COM_CONSOLE
void
com_enable_debugport(struct com_softc *sc)
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}
#endif	/* COM_CONSOLE */

void
com_attach_subr(struct com_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int probe = 0;
	u_int8_t lcr;

	sc->sc_ier = 0;
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

#ifdef COM_CONSOLE
	if (sc->sc_iot == comconsiot && sc->sc_iobase == comconsaddr) {
		comconsattached = 1;
		delay(10000);			/* wait for output to finish */
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
	}
#endif

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);
	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

	/*
	 * Skip specific probes if attachment code knows it already.
	 */
	if (sc->sc_uarttype == COM_UART_UNKNOWN) {
		switch (bus_space_read_1(iot, ioh, com_iir) >> 6) {
		case 0:
			sc->sc_uarttype = COM_UART_16450;
			break;
		case 2:
			sc->sc_uarttype = COM_UART_16550;
			break;
		case 3:
			sc->sc_uarttype = COM_UART_16550A;
			break;
		default:
			sc->sc_uarttype = COM_UART_UNKNOWN;
			break;
		}
		probe = 1;
	}

	/* Probe for ST16650s */
	if (probe && sc->sc_uarttype == COM_UART_16550A) {
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			bus_space_write_1(iot, ioh, com_efr, EFR_CTS);
			if (bus_space_read_1(iot, ioh, com_efr) != 0)
				sc->sc_uarttype = COM_UART_ST16650;
			bus_space_write_1(iot, ioh, com_efr, 0);
		} else {
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

#if 0	/* until com works with large FIFOs */
	/* Probe for XR16850s */
	if (probe && sc->sc_uarttype == COM_UART_ST16650V2) {
		u_int8_t dlbl, dlbh;

		/* Enable latch access and get the current values. */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		dlbl = bus_space_read_1(iot, ioh, com_dlbl);
		dlbh = bus_space_read_1(iot, ioh, com_dlbh);

		/* Zero out the latch divisors */
		bus_space_write_1(iot, ioh, com_dlbl, 0);
		bus_space_write_1(iot, ioh, com_dlbh, 0);

		if (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {
			sc->sc_uarttype = COM_UART_XR16850;
			sc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);
		}

		/* Reset to original. */
		bus_space_write_1(iot, ioh, com_dlbl, dlbl);
		bus_space_write_1(iot, ioh, com_dlbh, dlbh);
	}
#endif

	/* Probe for TI16750s */
	if (probe && sc->sc_uarttype == COM_UART_16550A) {
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_ENABLE | FIFO_ENABLE_64BYTE);
		if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 7) {
#if 0
			bus_space_write_1(iot, ioh, com_lcr, 0);
			if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 6)
#endif
				sc->sc_uarttype = COM_UART_TI16750;
		}
		bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	}

	/* Reset the LCR (latch access is probably enabled). */
	bus_space_write_1(iot, ioh, com_lcr, lcr);

	/* Probe for 8250 */
	if (probe && sc->sc_uarttype == COM_UART_16450) {
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf(": unknown uart\n");
		break;
	case COM_UART_8250:
		printf(": ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf(": ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf(": ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		if (sc->sc_fifolen == 0)
			sc->sc_fifolen = 16;
		printf(": ns16550a, %d byte fifo\n", sc->sc_fifolen);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		break;
	case COM_UART_ST16650:
		printf(": st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		if (sc->sc_fifolen == 0)
			sc->sc_fifolen = 32;
		printf(": st16650, %d byte fifo\n", sc->sc_fifolen);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		break;
	case COM_UART_ST16C654:
		printf(": st16c654, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
	case COM_UART_TI16750:
		printf(": ti16750, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
#if 0
	case COM_UART_XR16850:
		printf(": xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#ifdef COM_UART_OX16C950
	case COM_UART_OX16C950:
		printf(": ox16c950 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#endif
#endif
	default:
		panic("comattach: bad fifo type");
	}

#ifdef COM_CONSOLE
	if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
#endif
		com_fifo_probe(sc);

	if (sc->sc_fifolen == 0) {
		CLR(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 1;
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	if (ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);

	sc->sc_mcr = 0;
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);

#ifdef COM_CONSOLE
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == comopen)
				break;

		if (maj < nchrdev && cn_tab->cn_dev == NODEV)
			cn_tab->cn_dev = makedev(maj, sc->sc_dev.dv_unit);

		printf("%s: console\n", sc->sc_dev.dv_xname);
	}
#endif

	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
	sc->sc_si = softintr_establish(IPL_TTY, comsoft, sc);
	if (sc->sc_si == NULL)
		panic("%s: can't establish soft interrupt",
		    sc->sc_dev.dv_xname);

	/*
	 * If there are no enable/disable functions, assume the device
	 * is always enabled.
	 */
	if (!sc->enable)
		sc->enabled = 1;

#ifdef COM_CONSOLE
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
		com_enable_debugport(sc);
#endif
}

void
com_fifo_probe(struct com_softc *sc)
{
	bus_space_handle_t ioh = sc->sc_ioh;
	bus_space_tag_t iot = sc->sc_iot;
	u_int8_t fifo, ier;
	int timo, len;

	if (!ISSET(sc->sc_hwflags, COM_HW_FIFO))
		return;

	ier = 0;
	bus_space_write_1(iot, ioh, com_ier, ier);
	bus_space_write_1(iot, ioh, com_lcr, LCR_DLAB);
	bus_space_write_1(iot, ioh, com_dlbl, 3);
	bus_space_write_1(iot, ioh, com_dlbh, 0);
	bus_space_write_1(iot, ioh, com_lcr, LCR_PNONE | LCR_8BITS);
	bus_space_write_1(iot, ioh, com_mcr, MCR_LOOPBACK);

	fifo = FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST;
	if (sc->sc_uarttype == COM_UART_TI16750)
		fifo |= FIFO_ENABLE_64BYTE;

	bus_space_write_1(iot, ioh, com_fifo, fifo);

	for (len = 0; len < 256; len++) {
		bus_space_write_1(iot, ioh, com_data, (len + 1));
		timo = 2000;
		while (!ISSET(bus_space_read_1(iot, ioh, com_lsr),
		    LSR_TXRDY) && --timo)
			delay(1);
		if (!timo)
			break;
	}

	delay(100);

	for (len = 0; len < 256; len++) {
		timo = 2000;
		while (!ISSET(bus_space_read_1(iot, ioh, com_lsr),
		    LSR_RXRDY) && --timo)
			delay(1);
		if (!timo || bus_space_read_1(iot, ioh, com_data) != (len + 1))
			break;
	}

	/* For safety, always use the smaller value. */
	if (sc->sc_fifolen > len) {
		printf("%s: probed fifo depth: %d bytes\n",
		    sc->sc_dev.dv_xname, len);
		sc->sc_fifolen = len;
	}
}
@


1.162
log
@Unifdef KGDB.

It doesn't compile und hasn't been working during the last decade.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.161 2016/09/04 18:20:34 tedu Exp $	*/
d1091 1
a1091 1
							Debugger();
@


1.161
log
@remove some more sparc remnants. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.160 2016/09/03 14:43:37 jsg Exp $	*/
a117 11
#ifdef KGDB
#include <sys/kgdb.h>

bus_addr_t com_kgdb_addr;
bus_space_tag_t com_kgdb_iot;
bus_space_handle_t com_kgdb_ioh;

int    com_kgdb_getc(void *);
void   com_kgdb_putc(void *, int);
#endif /* KGDB */

a218 3
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
a219 1
#endif /* KGDB */
a251 8
#ifdef KGDB
	/*
	 * If this is the kgdb port, no other use is permitted.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return (EBUSY);
#endif /* KGDB */

a1059 55
#ifdef KGDB

/*
 * If a line break is set, or data matches one of the characters
 * gdb uses to signal a connection, then start up kgdb. Just gobble
 * any other data. Done in a stand alone function because comintr
 * does tty stuff and we don't have one.
 */

int
kgdbintr(void *arg)
{
	struct com_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char lsr, data, msr, delta;

	if (!ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return(0);

	for (;;) {
		lsr = bus_space_read_1(iot, ioh, com_lsr);
		if (ISSET(lsr, LSR_RXRDY)) {
			do {
				data = bus_space_read_1(iot, ioh, com_data);
				if (data == 3 || data == '$' || data == '+' ||
				    ISSET(lsr, LSR_BI)) {
					kgdb_connect(1);
					data = 0;
				}
				lsr = bus_space_read_1(iot, ioh, com_lsr);
			} while (ISSET(lsr, LSR_RXRDY));

		}
		if (ISSET(lsr, LSR_BI|LSR_FE|LSR_PE|LSR_OE))
			printf("weird lsr %02x\n", lsr);

		msr = bus_space_read_1(iot, ioh, com_msr);

		if (msr != sc->sc_msr) {
			delta = msr ^ sc->sc_msr;
			sc->sc_msr = msr;
			if (ISSET(delta, MSR_DCD)) {
				if (!ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
					CLR(sc->sc_mcr, sc->sc_dtr);
					bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
				}
			}
		}
		if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
	}
}
#endif /* KGDB */

d1156 2
a1157 2
 * The following functions are polled getc and putc routines, shared
 * by the console and kgdb glue.
a1307 44
#ifdef KGDB
int
com_kgdb_attach(bus_space_tag_t iot, bus_addr_t iobase, int rate,
    int frequency, tcflag_t cflag)
{
#ifdef COM_CONSOLE
	if (iot == comconsiot && iobase == comconsaddr) {
		return (EBUSY); /* cannot share with console */
	}
#endif

	com_kgdb_iot = iot;
	com_kgdb_addr = iobase;

	if (bus_space_map(com_kgdb_iot, com_kgdb_addr, COM_NPORTS, 0,
	    &com_kgdb_ioh))
		panic("com_kgdb_attach: mapping failed");

	/* XXX We currently don't respect KGDBMODE? */
	cominit(com_kgdb_iot, com_kgdb_ioh, rate, frequency);

	kgdb_attach(com_kgdb_getc, com_kgdb_putc, NULL);
	kgdb_dev = 123; /* unneeded, only to satisfy some tests */

	return (0);
}

/* ARGSUSED */
int
com_kgdb_getc(void *arg)
{

	return (com_common_getc(com_kgdb_iot, com_kgdb_ioh));
}

/* ARGSUSED */
void
com_kgdb_putc(void *arg, int c)
{

	return (com_common_putc(com_kgdb_iot, com_kgdb_ioh, c));
}
#endif /* KGDB */

d1311 1
a1311 1
#if defined(COM_CONSOLE) || defined(KGDB)
a1318 4
#ifdef KGDB
	SET(sc->sc_ier, IER_ERXRDY);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
#endif
d1324 1
a1324 1
#endif	/* COM_CONSOLE || KGDB */
d1511 2
a1512 15
#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
	}
#endif /* KGDB */

#if defined(COM_CONSOLE) || defined(KGDB)
	if (!ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
d1560 2
a1561 2
#if defined(COM_CONSOLE) || defined(KGDB)
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
@


1.160
log
@de-zaurus com.c
"looks correct" deraadt@@ guenther@@ on an earlier rev
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.159 2016/08/16 08:15:04 kettenis Exp $	*/
a81 1
#if !defined(__sparc__) || defined(__sparc64__)
a82 1
#endif
a83 1
#if !defined(__sparc__) || defined(__sparc64__)
a85 1
#endif
@


1.159
log
@Only probe the UART type if sc_uarttype is set to COM_UART_UNKNOWN.
This allows glue drivers to set the type based on other information (such as
Oopen Firmware or device tree properties) without going through to risky
code paths.

ok deraadt@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.158 2014/09/14 14:17:24 jsg Exp $	*/
a95 10
#ifdef COM_PXA2X0
#define com_isr 8
#define ISR_SEND	(ISR_RXPL | ISR_XMODE | ISR_XMITIR)
#define ISR_RECV	(ISR_RXPL | ISR_XMODE | ISR_RCVEIR)
#endif

#ifdef __zaurus__
#include <arch/zaurus/dev/zaurus_scoopvar.h>
#endif

a108 3
#ifdef COM_PXA2X0
bus_addr_t comsiraddr;
#endif
a340 3
			case COM_UART_PXA2X0:
				bus_space_write_1(iot, ioh, com_ier, IER_EUART);
				break;
a396 4
#ifdef COM_PXA2X0
		if (sc->sc_uarttype == COM_UART_PXA2X0)
			sc->sc_ier |= IER_EUART | IER_ERXTOUT;
#endif  
a404 9
#ifdef COM_PXA2X0
		if (sc->sc_uarttype == COM_UART_PXA2X0 &&
		    ISSET(sc->sc_hwflags, COM_HW_SIR)) {
			bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
#ifdef __zaurus__
			scoop_set_irled(1);
#endif
		}
#endif
a536 9
#ifdef COM_PXA2X0
		case COM_UART_PXA2X0:
			bus_space_write_1(iot, ioh, com_ier, 0);
#ifdef __zaurus__
			if (ISSET(sc->sc_hwflags, COM_HW_SIR))
				scoop_set_irled(0);
#endif
			break;
#endif
a572 3
		case COM_UART_PXA2X0:
			bus_space_write_1(iot, ioh, com_ier, IER_EUART);
			break;
a632 10

#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0 &&
	    ISSET(sc->sc_hwflags, COM_HW_SIR)) {
		bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
#ifdef __zaurus__
		scoop_set_irled(1);
#endif
	}
#endif
a957 7
#ifdef COM_PXA2X0
	/* Enable transmitter slow infrared mode. */
	if (sc->sc_uarttype == COM_UART_PXA2X0 &&
	    ISSET(sc->sc_hwflags, COM_HW_SIR))
		bus_space_write_1(iot, ioh, com_isr, ISR_SEND);
#endif

a982 15
#ifdef COM_PXA2X0
		if (sc->sc_uarttype == COM_UART_PXA2X0 &&
		    ISSET(sc->sc_hwflags, COM_HW_SIR)) {
			int timo;

			/* Wait for empty transmit shift register. */
			timo = 20000;
			while (!ISSET(bus_space_read_1(iot, ioh, com_lsr),
			    LSR_TSRE) && --timo)
				delay(1);

			/* Enable receiver slow infrared mode. */
			bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
		}
#endif
a1231 7
#ifdef COM_PXA2X0
		if (sc->sc_uarttype == COM_UART_PXA2X0 &&
		    ISSET(sc->sc_hwflags, COM_HW_SIR) &&
		    ISSET(lsr, LSR_TXRDY) && ISSET(lsr, LSR_TSRE))
			bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
#endif

a1247 5
#ifdef COM_PXA2X0
	if (com_is_console(iot, comsiraddr))
		bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
#endif

a1270 4
#ifdef COM_PXA2X0
	if (com_is_console(iot, comsiraddr))
		bus_space_write_1(iot, ioh, com_isr, ISR_SEND);
#endif
a1279 12
#ifdef COM_PXA2X0
	if (com_is_console(iot, comsiraddr)) {
		/* Wait for transmit shift register to become empty. */
		timo = 20000;
		while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TSRE)
		    && --timo)
			delay(1);

		bus_space_write_1(iot, ioh, com_isr, ISR_RECV);
	}
#endif

a1294 4
#ifdef COM_PXA2X0
	/* XXX */
	bus_space_write_1(iot, ioh, com_ier, IER_EUART);  /* Make sure they are off */
#else
a1295 1
#endif
a1433 15
#ifdef COM_PXA2X0
int
com_is_console(bus_space_tag_t iot, bus_addr_t iobase)
{

	if (comconsiot == iot && comconsaddr == iobase)
		return (1);
#ifdef KGDB
	else if (com_kgdb_iot == iot && com_kgdb_addr == iobase)
		return (1);
#endif
	return (0);
}
#endif /* COM_PXA2X0 */

a1446 4
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART | IER_ERXTOUT;
#endif
a1464 4
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART;
#endif
a1603 12
#ifdef COM_PXA2X0
	case COM_UART_PXA2X0:
		printf(": pxa2x0, 32 byte fifo");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		if (sc->sc_iobase == comsiraddr) {
			SET(sc->sc_hwflags, COM_HW_SIR);
			printf(" (SIR)");
		}
		printf("\n");
		break;
#endif
a1720 4
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		ier |= IER_EUART;
#endif
@


1.158
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.157 2014/04/13 15:42:32 deraadt Exp $	*/
d1586 1
d1620 1
a1620 1
	if (sc->sc_uarttype == COM_UART_UNKNOWN)
d1635 2
d1638 2
a1639 1
	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
d1654 2
a1655 1
	if (sc->sc_uarttype == COM_UART_ST16650V2) { /* Probe for XR16850s */
d1678 2
a1679 1
	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for TI16750s */
d1695 3
a1697 1
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
@


1.157
log
@wrap a long line
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.156 2013/12/09 19:54:31 deraadt Exp $	*/
a69 1
#include <sys/proc.h>
@


1.156
log
@At resume, do not spin flushing characters in from the chip.  There shouldn't
be any characters.  If the chip is not actually there for some reason, we'd
be spinning so early in the resume sequence, we'd probably go mad trying to
find the reason..
ok kettenis
request: people with serial ports on their laptops, try to run a "cu" over
a suspend/resume cycle, and see if you see "input noise"
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.155 2013/12/09 19:47:42 deraadt Exp $	*/
d1449 2
a1450 1
comcnattach(bus_space_tag_t iot, bus_addr_t iobase, int rate, int frequency, tcflag_t cflag)
@


1.155
log
@At suspend/resume time cope with timeouts, DTR on resume in a bus
bus-independent fashion.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.154 2013/02/14 22:22:48 kettenis Exp $	*/
a670 4

	/* Flush any pending I/O. */
	while (ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		(void) bus_space_read_1(iot, ioh, com_data);
@


1.154
log
@No need to treat amd64 specially; always return CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.153 2012/10/17 22:27:27 deraadt Exp $	*/
d237 10
@


1.153
log
@Narrow the spltty/splx pair in com_activate to only enclose the minimum
operation which requires it.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.152 2012/08/25 18:02:17 kettenis Exp $	*/
a1426 1
#if defined(COMCONSOLE) || !defined(__amd64__)
a1427 3
#else
	cp->cn_pri = CN_LOWPRI;
#endif
@


1.152
log
@Better detection of the st16650 v1 (with the broken fifo).  Gets rid of
false positives like the DUART on the MPC8347 as found on socppc.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.151 2012/08/25 17:40:34 kettenis Exp $	*/
a235 1
	s = spltty();
d247 1
d252 1
a254 1
	splx(s);
@


1.151
log
@Turns out the v445 isn't happy at all if we touch the registers that deal
with sleep mode.  So skip the wakeup code as well if we are a serial console.
The port on the v445 almost certainly isn't a real st16650 and probably
doesn't implement sleep mode (perhaps someone cut the soft core down a bit
too much?).  But it is indistinguishable from it, so we have to deal with it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.149 2012/05/12 18:02:33 kettenis Exp $	*/
d1636 4
a1639 1
			sc->sc_uarttype = COM_UART_ST16650;
@


1.150
log
@Skip putting a port in sleep mode when it is used as serial console.  In that
case the kernel will still be using the port even after the last process closes
it.  And on machines like the v445 the firmware won't be happy if the console
port is in sleep mode when the kernel reboots or halts.

ok miod@@
@
text
@d332 17
a348 15
		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, 0);
			bus_space_write_1(iot, ioh, com_efr, 0);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, 0);
			break;
		case COM_UART_PXA2X0:
			bus_space_write_1(iot, ioh, com_ier, IER_EUART);
			break;
d589 17
a605 15
	switch (sc->sc_uarttype) {
	case COM_UART_ST16650:
	case COM_UART_ST16650V2:
		bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
		bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
		bus_space_write_1(iot, ioh, com_ier, 0);
		bus_space_write_1(iot, ioh, com_efr, 0);
		bus_space_write_1(iot, ioh, com_lcr, 0);
		break;
	case COM_UART_TI16750:
		bus_space_write_1(iot, ioh, com_ier, 0);
		break;
	case COM_UART_PXA2X0:
		bus_space_write_1(iot, ioh, com_ier, IER_EUART);
		break;
@


1.149
log
@Remove unused variable.

ok mpi@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.148 2011/07/03 15:47:16 matthew Exp $	*/
d543 12
a554 11
	switch (sc->sc_uarttype) {
	case COM_UART_ST16650:
	case COM_UART_ST16650V2:
		bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
		bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
		bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
		bus_space_write_1(iot, ioh, com_lcr, 0);
		break;
	case COM_UART_TI16750:
		bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
		break;
d556 2
a557 2
	case COM_UART_PXA2X0:
		bus_space_write_1(iot, ioh, com_ier, 0);
d559 2
a560 2
		if (ISSET(sc->sc_hwflags, COM_HW_SIR))
			scoop_set_irled(0);
d562 1
a562 1
		break;
d564 1
@


1.148
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.147 2011/05/22 22:36:53 drahn Exp $	*/
a125 1
int	comconsinit;
a1437 1
	comconsinit = 0;
@


1.147
log
@Fix a problem found where one SOC has a uart implementation that causes bus
errors if the fifo is read when the fifo is empty. Dont read an empty fifo.
ok deraaadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.146 2011/03/23 15:51:11 fgsch Exp $	*/
a238 3
	case DVACT_ACTIVATE:
		break;

@


1.146
log
@only read from the UART if there is something to read. fix beagle, otherwise
it will crash with 'External Non-Linefetch Abort (S)'.
similar diff provided by drahn@@. tested by jasper@@, deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.145 2010/08/28 12:48:14 miod Exp $	*/
d541 2
a542 1
	(void) bus_space_read_1(iot, ioh, com_data);
@


1.145
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.144 2010/08/07 15:50:23 kettenis Exp $	*/
d1792 2
a1793 1
	(void)bus_space_read_1(iot, ioh, com_data);
@


1.144
log
@Add resume support for serial consoles.

Tested by sthen@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.143 2010/08/06 21:04:14 kettenis Exp $	*/
d1556 1
a1556 2
com_enable_debugport(sc)
	struct com_softc *sc;
d1578 1
a1578 2
com_attach_subr(sc)
	struct com_softc *sc;
@


1.143
log
@Initial stab at making com@@puc suspend and resume properly.  Works fine
for using cu(1) between two OpenBSD machines.  Probably doesn't work for
serial consoles but we don't support those on puc(4) anyway.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.142 2010/07/02 17:27:01 nicm Exp $	*/
d577 5
a581 1
	if (!tp || !ISSET(tp->t_state, TS_ISOPEN))
d583 1
@


1.142
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.141 2010/06/28 14:13:32 deraadt Exp $	*/
d567 104
@


1.141
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.140 2010/06/28 04:36:31 ckuethe Exp $	*/
d887 3
a889 9
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (ISSET(tp->t_state, TS_ASLEEP)) {
			CLR(tp->t_state, TS_ASLEEP);
			wakeup(&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto stopped;
	}
@


1.140
log
@Use a more moderate fifo trigger level (4) for moderately quick
(sub-38400) port speeds. Inspired by netbsd. ok fgsch krw deraadt miod
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.139 2010/06/26 23:24:44 guenther Exp $	*/
d289 1
a289 1
		tp = sc->sc_tty = ttymalloc();
@


1.139
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.138 2010/04/12 12:57:52 tedu Exp $	*/
d359 2
@


1.138
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.137 2009/11/09 17:53:39 nicm Exp $	*/
a70 1
#include <sys/user.h>
@


1.137
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.136 2009/11/04 19:14:10 kettenis Exp $	*/
d469 1
a469 1
	return (*linesw[tp->t_line].l_open)(dev, tp);
d491 1
a491 1
	(*linesw[tp->t_line].l_close)(tp, flag);
@


1.136
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.135 2009/11/01 20:29:00 nicm Exp $	*/
a891 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.135
log
@Call selwakeup()/KNOTE() even if the queue has emptied completely.

ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.134 2009/10/31 12:00:07 fgsch Exp $	*/
a226 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a227 3
#else
	timeout_del(&sc->sc_comsoft_tmo);
#endif
a326 4
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
		timeout_add(&sc->sc_comsoft_tmo, 1);
#endif

a502 3
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
	timeout_del(&sc->sc_comsoft_tmo);
#endif
d1002 1
a1002 1
		goto out;
d1013 1
a1013 1
		goto out;
d1023 1
a1023 1
		goto out;
a1046 7

out:
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
	timeout_add(&sc->sc_comsoft_tmo, 1);
#else
	;
#endif
a1126 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1127 1
#endif
a1714 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a1718 3
#else
	timeout_set(&sc->sc_comsoft_tmo, comsoft, sc);
#endif
@


1.134
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.133 2009/10/31 06:40:16 deraadt Exp $	*/
d902 2
a905 2
		selwakeup(&tp->t_wsel);
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.133
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.132 2009/10/13 19:33:16 pirofti Exp $	*/
d434 1
a434 1
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0)
@


1.132
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.131 2009/01/11 16:54:59 blambert Exp $	*/
d905 1
@


1.131
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.130 2008/11/23 17:59:00 deraadt Exp $	*/
d237 1
a237 1
com_activate(struct device *self, enum devact act)
@


1.130
log
@pccom can finally die; ok kettenis dlg drahn, tested by okan
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.129 2008/10/15 19:12:19 blambert Exp $	*/
d1051 1
a1051 1
				timeout_add(&sc->sc_diag_tmo, 60 * hz);
@


1.129
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.128 2008/06/08 13:55:06 kettenis Exp $	*/
a107 1
/* XXX: These belong elsewhere */
d1340 1
a1340 1
#if defined(COMCONSOLE) || defined(PCCOMCONSOLE) || !defined(__amd64__)
d1465 52
d1518 295
@


1.128
log
@Make serial console on non-primary ports work to on i386.

tested by jbg@@, "it is right" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.127 2008/04/25 11:30:22 dlg Exp $	*/
d506 1
a506 1
		timeout_add(&sc->sc_dtr_tmo, hz * 2);
d1164 1
a1164 1
						timeout_add(&sc->sc_diag_tmo, 60 * hz);
@


1.127
log
@the code that parses arguments from the boot loader on amd64 wasnt checking
what type of console was specified, so when a glass console was used it was
still configuring serial bits. this makes it so serial config only occurs
for serial console devices.

found by jolan@@, thib@@, and maybe sthen@@
sorry guys
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.126 2008/04/24 12:54:44 jsing Exp $	*/
d133 1
d1340 1
a1340 1
	cp->cn_dev = makedev(commajor, CONUNIT);
@


1.126
log
@MD_ISA_IOT is not defined anywhere so get rid of it.

Spotted by drahn@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.125 2008/04/24 12:53:50 jsing Exp $	*/
d129 1
a129 1
bus_addr_t comconsaddr = CONADDR;
@


1.125
log
@Keep order of "#if defined..." consistent.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.124 2008/04/24 12:49:40 jsing Exp $	*/
a1319 4
	/* XXX NEEDS TO BE FIXED XXX */
#ifdef MD_ISA_IOT
	comconsiot = MD_ISA_IOT;
#endif
@


1.124
log
@Clean up comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.122 2008/04/09 19:50:38 deraadt Exp $	*/
d84 1
a84 1
#if defined(__sparc64__) || !defined(__sparc__)
@


1.123
log
@Cleanup serial console handling and remove some of the MD code from com.c.
Specify the serial configuration from within the MD code, rather than
passing things via macros. This will allow other platforms to more readily
change the serial console configuration.

Committing this so it actually gets tested.

ok dlg@@
@
text
@d207 1
a207 1
	/* locate the major number */
d403 1
a403 1
		/* flush any pending I/O */
d406 2
a407 1
		/* you turn me on, baby */
d445 1
a445 1
		sc->sc_cua = 1;		/* We go into CUA mode */
d447 1
a447 1
		/* tty (not cua) device; wait for carrier if necessary */
d450 1
a450 1
				/* Opening TTY non-blocking... but the CUA is busy */
d753 1
a753 1
	/* check requested parameters */
d1131 1
a1131 1
		return (0);		/* can't do squat. */
d1241 1
a1241 1
	/* block until a character becomes available */
d1246 2
a1247 1
	/* clear any interrupts generated by this transmission */
d1259 1
a1259 1
	/* wait for any pending transmission to finish */
d1272 1
a1272 1
	/* wait for this transmission to complete */
d1279 1
a1279 1
		/* wait for transmit shift register to become empty */
@


1.122
log
@Increase buffer size sent to the fifo, and clamp the size correctly.
Scrub the buffer afterwards, too
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.121 2008/01/23 16:37:55 jsing Exp $	*/
d129 1
a129 1
bus_addr_t comconsaddr;
a1224 10
 * Following are all routines needed for COM to act as console
 */

#if defined(__sgi__)
#undef CONADDR
#undef COM_FREQ
#include <machine/autoconf.h>
#endif

/*
d1320 1
a1320 5
	bus_space_tag_t iot = MD_ISA_IOT;
#elif defined(__sgi__)
	bus_space_tag_t iot = sys_config.cons_iot;
#else
	bus_space_tag_t iot = 0;
d1325 1
a1325 1
	if (CONADDR == 0)
d1328 1
a1328 2
	comconsiot = iot;
	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh))
d1330 2
a1331 2
	found = comprobe1(iot, ioh);
	bus_space_unmap(iot, ioh, COM_NPORTS);
d1335 1
a1335 1
	/* locate the major number */
d1340 1
a1340 1
	/* initialize required fields */
a1351 2
	comconsaddr = CONADDR;

a1360 1

@


1.121
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.119 2008/01/08 00:29:36 dlg Exp $	*/
d921 2
a922 4
		u_char buffer[64];	/* XXX: largest fifo */

		int n = q_to_b(&tp->t_outq, buffer, sc->sc_fifolen);
		int i;
d924 2
d929 1
@


1.120
log
@Make comconsrate initialized to TTYDEF_SPEED at compile-time, for ports
which need to setup the chip before comcnattach() is invoked.
@
text
@d1357 1
a1357 1
	cp->cn_pri = CN_REMOTE;
d1359 1
a1359 1
	cp->cn_pri = CN_NORMAL;
d1384 1
a1384 1
		NODEV, CN_NORMAL
@


1.119
log
@the rsc-console on the v880 operates at 115200, not the 9600 we think we
have to force all console devices to. this change passes the right speed
to the com code, and continues to use it when the device is opened as the
console device.

figured out by kettenis@@
ok kettenis@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.117 2007/07/15 19:25:49 kettenis Exp $	*/
d127 1
a127 1
int	comconsrate;
@


1.118
log
@fix compilation with KDGB
from Nicholas Marriott

ok deraadt@@
@
text
@d127 1
d308 1
a308 1
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
d310 2
a311 1
		else
d313 1
d315 2
a323 1
		tp->t_ispeed = tp->t_ospeed = comdefaultrate;
d1374 1
a1374 1
	cominit(comconsiot, comconsioh, comdefaultrate, comconsfreq);
d1400 1
@


1.117
log
@Delay switching to the real serial console until we attach the serial device.
The variety of different serial devices is just too big to make a decision up
front.  This should make the second serial port on four-digit B/C/J-class
workstation work as a serial console too.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.116 2007/06/22 10:09:21 jasper Exp $	*/
d1425 1
a1425 5
    int frequency,tcflag_t cflag)
	bus_space_tag_t iot;
	bus_addr_t iobase;
	int rate, frequency;
	tcflag_t cflag;
@


1.116
log
@ansify/de-register
no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.115 2007/05/08 21:28:11 deraadt Exp $	*/
a1327 2
#elif defined(hppa)
	bus_space_tag_t iot = &hppa_bustag;
a1339 3
#ifdef __hppa__
	found = 1;
#else
a1340 1
#endif
@


1.115
log
@backout while the amd64 puc situation is rethought
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.112 2006/06/23 06:27:11 miod Exp $	*/
d152 1
a152 3
comspeed(freq, speed)
	long freq;
	long speed;
d177 1
a177 3
comprobe1(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d199 1
a199 3
com_detach(self, flags)
	struct device *self;
	int flags;
d236 1
a236 3
com_activate(self, act)
	struct device *self;
	enum devact act;
d267 1
a267 4
comopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d476 1
a476 4
comclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d525 1
a525 2
compwroff(sc)
	struct com_softc *sc;
d575 1
a575 2
com_raisedtr(arg)
	void *arg;
d584 1
a584 4
comread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d593 1
a593 4
comwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d602 1
a602 2
comtty(dev)
	dev_t dev;
d611 1
a611 2
tiocm_xxx2mcr(data)
	int data;
d623 1
a623 6
comioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d739 1
a739 3
comparam(tp, t)
	struct tty *tp;
	struct termios *t;
d878 1
a878 2
comstart(tp)
	struct tty *tp;
d957 1
a957 3
comstop(tp, flag)
	struct tty *tp;
	int flag;
d970 1
a970 2
comdiag(arg)
	void *arg;
d990 1
a990 2
comsoft(arg)
	void *arg;
d994 1
a994 1
	register u_char *ibufp;
d996 1
a996 1
	register int c;
d1070 1
a1070 2
kgdbintr(arg)
	void *arg;
d1116 1
a1116 2
comintr(arg)
	void *arg;
d1136 1
a1136 1
			register u_char *p = sc->sc_ibufp;
d1235 1
a1235 3
com_common_getc(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d1257 1
a1257 4
com_common_putc(iot, ioh, c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int c;
d1296 1
a1296 4
cominit(iot, ioh, rate, frequency)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int rate, frequency;
d1321 1
a1321 2
comcnprobe(cp)
	struct consdev *cp;  
d1366 1
a1366 2
comcninit(cp)
	struct consdev *cp;
d1382 1
a1382 5
comcnattach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	bus_addr_t iobase;
	int rate, frequency;
	tcflag_t cflag;
d1407 1
a1407 2
comcngetc(dev)
	dev_t dev;
d1416 1
a1416 3
comcnputc(dev, c)
	dev_t dev;
	int c;
d1422 1
a1422 3
comcnpollc(dev, on)
	dev_t dev;
	int on;
d1430 2
a1431 1
com_kgdb_attach(iot, iobase, rate, frequency, cflag)
d1461 1
a1461 2
com_kgdb_getc(arg)
	void *arg;
d1469 1
a1469 3
com_kgdb_putc(arg, c)
	void *arg;
	int c;
@


1.114
log
@move com_activate() to where it belongs
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.113 2007/05/08 20:33:07 deraadt Exp $	*/
d201 72
@


1.113
log
@put more foo_detach() routines where they are used
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.112 2006/06/23 06:27:11 miod Exp $	*/
a200 33

int
com_activate(self, act)
	struct device *self;
	enum devact act;
{
	struct com_softc *sc = (struct com_softc *)self;
	int s, rv = 0;

	s = spltty();
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
		if (sc->sc_hwflags & COM_HW_CONSOLE) {
#endif /* KGDB */
			rv = EBUSY;
			break;
		}

		if (sc->disable != NULL && sc->enabled != 0) {
			(*sc->disable)(sc);
			sc->enabled = 0;
		}
		break;
	}
	splx(s);
	return (rv);
}
@


1.112
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.111 2006/04/27 19:31:44 deraadt Exp $	*/
a200 39

int
com_detach(self, flags)
	struct device *self;
	int flags;
{
	struct com_softc *sc = (struct com_softc *)self;
	int maj, mn;

	sc->sc_swflags |= COM_SW_DEAD;

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == comopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	/* XXX a symbolic constant for the cua bit would be nicer. */
	mn |= 0x80;
	vdevgone(maj, mn, mn, VCHR);

	/* Detach and free the tty. */
	if (sc->sc_tty) {
		ttyfree(sc->sc_tty);
	}

	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	softintr_disestablish(sc->sc_si);
#else
	timeout_del(&sc->sc_comsoft_tmo);
#endif

	return (0);
}
@


1.111
log
@2 lines of code in most drivers, to do the timestamping; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.110 2006/03/27 06:14:52 deraadt Exp $	*/
a251 1
		rv = EOPNOTSUPP;
@


1.110
log
@in detach, mark device with COM_SW_DEAD, so that close() will not go
tapping additional registes.  allows it to work on macppc, where doing
such a tap after unplug is very bad.  drahn helped fkr@@bytemine.de
ok miod and drahn
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.109 2006/01/01 11:59:40 miod Exp $	*/
d1220 4
@


1.109
log
@Let cons_init() and cons_init_bell() initialize the whole consdev structure,
thus removing the need for drivers to initialize cn_pri to CN_DEAD when
hardware probe fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.108 2005/11/21 18:16:39 millert Exp $	*/
d210 2
d505 3
@


1.108
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.107 2005/11/11 15:22:00 fgsch Exp $	*/
d1375 1
a1375 2
	if(CONADDR == 0) {
		cp->cn_pri = CN_DEAD;
a1376 1
	}
d1379 1
a1379 2
	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh)) {
		cp->cn_pri = CN_DEAD;
a1380 1
	}
d1387 1
a1387 2
	if (!found) {
		cp->cn_pri = CN_DEAD;
a1388 1
	}
@


1.107
log
@fix kgdb compilation; input and ok miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.106 2005/09/26 22:32:06 miod Exp $	*/
d68 1
a68 1
#include <sys/select.h>
@


1.106
log
@Share com probe code between com and pccom; allows us to get rid of awkward
code duplication in cardbus, pcmcia and puc attachments.

Joint effort with fgs@@; blessed deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.105 2005/07/18 16:18:28 deraadt Exp $	*/
d1491 1
d1495 1
@


1.105
log
@fix sparc64 console; same diff as miod
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.104 2005/07/18 14:36:34 deraadt Exp $	*/
a113 1
void	com_enable_debugport(struct com_softc *);
a201 232
void
com_attach_subr(sc)
	struct com_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t lcr;

	sc->sc_ier = 0;
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART;
#endif
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);

#ifdef COM_CONSOLE
	if (sc->sc_iobase == comconsaddr) {
		comconsattached = 1;

		/*
		 * Need to reset baud rate, etc. of next print so reset
		 * comconsinit.  Also make sure console is always "hardwired".
		 */
		delay(10000);			/* wait for output to finish */
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
	}
#endif

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);
	bus_space_write_1(iot, ioh, com_lcr, 0xbf);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

#ifdef COM_PXA2X0
	/* Attachment driver presets COM_UART_PXA2X0. */
	if (sc->sc_uarttype != COM_UART_PXA2X0)
#endif
	switch(bus_space_read_1(iot, ioh, com_iir) >> 6) {
	case 0:
		sc->sc_uarttype = COM_UART_16450;
		break;
	case 2:
		sc->sc_uarttype = COM_UART_16550;
		break;
	case 3:
		sc->sc_uarttype = COM_UART_16550A;
		break;
	default:
		sc->sc_uarttype = COM_UART_UNKNOWN;
		break;
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			sc->sc_uarttype = COM_UART_ST16650;
		} else {
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for TI16750s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_ENABLE | FIFO_ENABLE_64BYTE);
		if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 7) {
#if 0
			bus_space_write_1(iot, ioh, com_lcr, 0);
			if ((bus_space_read_1(iot, ioh, com_iir) >> 5) == 6)
#endif
				sc->sc_uarttype = COM_UART_TI16750;
		}
		bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	}
	bus_space_write_1(iot, ioh, com_lcr, lcr);
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	sc->sc_fifolen = 1;	/* default */
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf(": unknown uart\n");
		break;
	case COM_UART_8250:
		printf(": ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf(": ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf(": ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		printf(": ns16550a, 16 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 16;
		break;
#ifdef COM_PXA2X0
	case COM_UART_PXA2X0:
		printf(": pxa2x0, 32 byte fifo");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		if (sc->sc_iobase == comsiraddr) {
			SET(sc->sc_hwflags, COM_HW_SIR);
			printf(" (SIR)");
		}
		printf("\n");
		break;
#endif
	case COM_UART_ST16650:
		printf(": st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		printf(": st16650, 32 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 32;
		break;
	case COM_UART_TI16750:
		printf(": ti16750, 64 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 64;
		break;
	default:
		panic("comattach: bad fifo type");
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);

	sc->sc_mcr = 0;
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);

#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
	}
#endif /* KGDB */

#ifdef COM_CONSOLE
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == comopen)
				break;

		if (maj < nchrdev && cn_tab->cn_dev == NODEV)
			cn_tab->cn_dev = makedev(maj, sc->sc_dev.dv_unit);

		printf("%s: console\n", sc->sc_dev.dv_xname);
	}
#endif

	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	sc->sc_si = softintr_establish(IPL_TTY, comsoft, sc);
	if (sc->sc_si == NULL)
		panic("%s: can't establish soft interrupt.", sc->sc_dev.dv_xname);
#else
	timeout_set(&sc->sc_comsoft_tmo, comsoft, sc);
#endif

	/*
	 * If there are no enable/disable functions, assume the device
	 * is always enabled.
	 */
	if (!sc->enable)
		sc->enabled = 1;

#if defined(COM_CONSOLE) || defined(KGDB)
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
		com_enable_debugport(sc);
#endif
}

void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
#ifdef KGDB
	SET(sc->sc_ier, IER_ERXRDY);
#ifdef COM_PXA2X0
	if (sc->sc_uarttype == COM_UART_PXA2X0)
		sc->sc_ier |= IER_EUART | IER_ERXTOUT;
#endif
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
#endif
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}

d354 1
a354 1
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
d565 1
a565 1
		bus_space_write_1(iot, ioh, com_lcr, 0xbf);
@


1.104
log
@COM_CONSOLE & DDB fix
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.103 2005/07/17 12:20:50 miod Exp $	*/
d88 1
a88 1
#if !defined(__sparc__) && !defined(__sparc64__)
@


1.103
log
@Allow the console support code not to be compiled in; this will be
necessary for and only used on sparc, shortly.

Reluctantely ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.102 2005/07/11 23:41:58 uwe Exp $	*/
d1436 1
a1436 1
#ifdef DDB
@


1.102
log
@Enable IR receive mode only for infrared capable PXA2x0 UARTs. Normal
reception is blocked while the IR receiver or transmitter is enabled.

Also enable the PXA2x0 UART before clearing the FIFO (suggested by
drahn@@ some time ago), and disable the UART in compwroff().

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.101 2005/07/02 15:39:04 uwe Exp $	*/
d84 1
d86 1
d88 2
d91 1
a107 2
#include "com.h"

d123 4
a129 3
#ifdef COM_PXA2X0
bus_addr_t comsiraddr;
#endif
d134 1
d178 1
d201 1
d219 1
d231 1
d374 1
d388 1
d407 1
d410 1
d549 1
d553 1
d731 1
d735 1
d756 1
d763 1
d1411 1
a1411 1
#ifdef DDB
d1590 1
d1714 1
d1764 1
d1777 1
@


1.101
log
@xscale UART FIFOs are 32 bytes deep; found by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.100 2005/05/27 18:42:15 uwe Exp $	*/
d581 3
d787 9
a796 6

#if defined(COM_PXA2X0) && defined(__zaurus__)
	if (sc->sc_uarttype == COM_UART_PXA2X0 &&
	    ISSET(sc->sc_hwflags, COM_HW_SIR))
		scoop_set_irled(0);
#endif
d1453 1
@


1.100
log
@- Merge changes from pxacom back into the common com driver.

Changes to the common com driver (partly from NetBSD):
- Multiply before divide in comspeed() to avoid overflow (from NetBSD).
- Don't call getc() and send -1 if the output queue is empty.
- Take UART clock frequency as a parameter instead of using COM_FREQ.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.99 2004/10/20 12:40:14 pefo Exp $	*/
d317 1
a317 1
		printf(": pxa2x0, 16 byte fifo");
d319 1
a319 1
		sc->sc_fifolen = 16;
@


1.99
log
@Use bus_addr_t instead of int for port address/offset, ok mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.98 2004/08/09 22:24:29 pefo Exp $	*/
a76 1
#include <sys/types.h>
d93 10
d112 2
d120 1
d123 3
d163 1
a163 1
	err = divrnd((freq / 16) * 1000, speed * x) - 1000;
d205 4
d235 4
d315 12
d410 4
d633 4
d645 9
d785 6
d1139 7
d1161 1
a1161 1
	} else
d1170 15
d1445 6
d1463 1
a1463 1
#include "machine/autoconf.h"
a1465 1

d1479 5
d1509 5
a1513 1
	bus_space_write_1(iot, ioh, com_data, c);
d1522 12
a1536 3
/*
 * Following are all routines needed for COM to act as console
 */
d1538 1
a1538 1
cominit(iot, ioh, rate)
d1541 1
a1541 1
	int rate;
d1547 1
a1547 1
	rate = comspeed(COM_FREQ, rate); /* XXX not comdefaultrate? */
d1552 4
d1557 1
d1569 3
a1571 1
#if defined(__sgi__)
d1625 4
a1628 1
	cominit(comconsiot, comconsioh, comdefaultrate);
d1650 1
a1650 1
	cominit(iot, comconsioh, rate);
d1657 1
d1708 1
a1708 1
	cominit(com_kgdb_iot, com_kgdb_ioh, rate);
d1735 13
@


1.98
log
@remove old arc stuff and add sgi support.
ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.97 2004/05/30 20:59:57 deraadt Exp $	*/
d110 1
a110 1
int	comconsaddr;
d121 1
a121 1
int com_kgdb_addr;
d1523 1
a1523 1
	int iobase;
d1578 1
a1578 1
	int iobase;
@


1.97
log
@serial console hack from tom.  who, after having been told a few times
to commit it, has not.  what is going on guys?
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.96 2004/05/03 15:18:21 drahn Exp $	*/
d1374 1
a1374 1
#if defined(arc)
d1376 2
a1377 1
	extern int CONADDR;
d1380 1
d1461 2
a1462 2
#if defined(arc)
	bus_space_tag_t iot = &arc_bus_io;
@


1.96
log
@Remove OpenBSD/pegaos, this has been announced before but delayed until
the tree was stable. No point in code supporting a company which screws
its employees being in the OpenBSD tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.92.4.1 2003/10/10 17:04:17 drahn Exp $	*/
d1497 1
d1499 3
@


1.95
log
@Use isa iot for pegasos com console attachment, perhaps this could
be adopted MI?
@
text
@a1462 2
#elif defined(__pegasos__)
	bus_space_tag_t iot = MD_ISA_IOT;
@


1.94
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.93 2003/09/23 16:51:12 millert Exp $	*/
d1463 2
@


1.93
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.92 2003/08/15 20:32:16 tedu Exp $	*/
a405 1
		tty_detach(sc->sc_tty);
a484 1
		tty_attach(tp);
@


1.92
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.91 2003/07/15 03:15:58 jason Exp $	*/
d347 1
a347 1
	sc->sc_si = softintr_establish(IPL_TTY, compoll, sc);
d351 1
a351 1
	timeout_set(&sc->sc_poll_tmo, compoll, sc);
d415 1
a415 1
	timeout_del(&sc->sc_poll_tmo);
d519 1
a519 1
		timeout_add(&sc->sc_poll_tmo, 1);
d680 1
a680 1
	timeout_del(&sc->sc_poll_tmo);
d1151 1
a1151 1
compoll(arg)
d1216 1
a1216 1
	timeout_add(&sc->sc_poll_tmo, 1);
@


1.91
log
@move prototype for com_raisedtr() to comvar.h (just like pccom).
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.90 2003/06/03 21:09:02 deraadt Exp $	*/
d887 1
a887 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.90
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.89 2003/06/02 23:28:02 millert Exp $	*/
a101 1
void	com_raisedtr(void *);
@


1.89
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.88 2002/12/19 01:22:40 mickey Exp $	*/
a14 3
 * 3. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.88
log
@comparam() does not need an spltty() for it, already called there.
time-bound loops in com_common_cnputc() and lower to spltty(),
which i guess is left from times when timeouts were processed at splhigh().
jason@@ tested and ok, art@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.87 2002/10/17 22:11:02 art Exp $	*/
d45 1
a45 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.87
log
@ifndef __HAVE_GENERIC_SOFT_INTERRUPTS leaved a label without a statement after it. Fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.86 2002/07/06 19:14:20 nordin Exp $	*/
d922 1
a933 1
	int s;
a964 2
	s = spltty();

a993 1
					splx(s);
a1059 1
	splx(s);
d1419 1
a1419 1
	int s = splhigh();
d1423 1
a1423 1
	timo = 150000;
d1425 1
a1425 1
		continue;
d1432 1
a1432 1
	timo = 1500000;
d1434 1
a1434 1
		continue;
@


1.86
log
@Remove kernel support for NTP. ok deraadt@@ and tholo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.85 2002/06/11 04:54:10 miod Exp $	*/
d1229 2
@


1.85
log
@com.c is not a block device, no bdev_decl() for it.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.84 2002/04/09 15:08:43 pefo Exp $	*/
a1296 4
#ifdef PPS_SYNC
	struct timeval tv;
	long usec;
#endif /* PPS_SYNC */
a1356 13
#ifdef PPS_SYNC
				if (ISSET(sc->sc_swflags, COM_SW_PPS)) {
					if (ISSET(msr, MSR_DCD)) {
						usec = time.tv_usec;
						microtime(&tv);
						usec = tv.tv_usec - usec;
						if (usec < 0)
							usec += 1000000;
						hardpps(&tv, usec);
					}
				}
				else
#endif /* PPS_SYNC */
@


1.84
log
@Don't enable interrupts until an open() is done. Until then the driver
is not handling them and may throw the kernel into a spurious interrupt
loop. ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.83 2002/03/14 01:26:54 millert Exp $	*/
a104 1
bdev_decl(com);
@


1.83
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.82 2002/03/14 01:24:21 jason Exp $	*/
d382 1
d385 1
d1477 1
a1477 1
	bus_space_write_1(iot, ioh, com_ier, IER_ERXRDY | IER_ETXRDY);
@


1.82
log
@compare pointers with NULL not 0
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.81 2002/02/05 04:15:30 mickey Exp $	*/
d107 1
a107 1
static u_char tiocm_xxx2mcr __P((int));
d109 3
a111 3
void	compwroff __P((struct com_softc *));
void	com_raisedtr __P((void *));
void	com_enable_debugport	__P((struct com_softc *));
d134 2
a135 2
int    com_kgdb_getc __P((void *));
void   com_kgdb_putc __P((void *, int));
@


1.81
log
@restore CN_REMOTE priority, as it always was there.
anyway, only i386 uses that path and only if forced anyway.
also do not do comprobe1() on hppa since that hoses the port.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.80 2002/01/30 20:45:34 nordin Exp $	*/
d1178 1
a1178 1
	if (sc == 0 || sc->sc_ibufp == sc->sc_ibuf)
d1198 1
a1198 1
	if (tp == 0 || !ISSET(tp->t_state, TS_ISOPEN)) {
@


1.80
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.79 2002/01/25 21:23:38 mickey Exp $	*/
d1507 3
d1511 1
d1525 1
a1525 1
	cp->cn_pri = CN_NORMAL;
a1531 1

@


1.79
log
@CONADDR is defined elsewhere for hppa
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.78 2002/01/23 07:14:41 ericj Exp $	*/
a139 5

/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
@


1.78
log
@
oops, make the kgdb var's non-static
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.77 2002/01/23 06:45:32 ericj Exp $	*/
d1407 1
a1407 1
#if defined(arc) || defined(hppa)
@


1.77
log
@
allow this to compile with KGDB
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.76 2001/10/05 21:01:10 mickey Exp $	*/
d130 3
a132 3
static int com_kgdb_addr;
static bus_space_tag_t com_kgdb_iot;
static bus_space_handle_t com_kgdb_ioh;
@


1.76
log
@restore some of that dead code needed for dev/cons functionality
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.75 2001/10/02 23:39:27 art Exp $	*/
d337 1
a337 1
	if (iot == com_kgdb_iot && iobase == com_kgdb_addr &&
@


1.76.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.80 2002/01/30 20:45:34 nordin Exp $	*/
d130 3
a132 3
int com_kgdb_addr;
bus_space_tag_t com_kgdb_iot;
bus_space_handle_t com_kgdb_ioh;
d141 5
d337 1
a337 1
	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
d1407 1
a1407 1
#if defined(arc)
@


1.76.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.76.4.1 2002/01/31 22:55:31 niklas Exp $	*/
d107 1
a107 1
static u_char tiocm_xxx2mcr(int);
d109 3
a111 3
void	compwroff(struct com_softc *);
void	com_raisedtr(void *);
void	com_enable_debugport(struct com_softc *);
d134 2
a135 2
int    com_kgdb_getc(void *);
void   com_kgdb_putc(void *, int);
a381 1
#ifdef KGDB
a383 1
#endif
d1178 1
a1178 1
	if (sc == NULL || sc->sc_ibufp == sc->sc_ibuf)
d1198 1
a1198 1
	if (tp == NULL || !ISSET(tp->t_state, TS_ISOPEN)) {
d1475 1
a1475 1
	bus_space_write_1(iot, ioh, com_ier, 0);  /* Make sure they are off */
a1506 3
#ifdef __hppa__
	found = 1;
#else
a1507 1
#endif
d1521 1
a1521 1
	cp->cn_pri = CN_REMOTE;
d1528 1
@


1.76.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.76.4.2 2002/06/11 03:42:17 art Exp $	*/
d105 1
a1229 2
#else
	;
d1298 4
d1362 13
@


1.76.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a921 1
/* already called at spltty */
d933 1
d965 2
d996 1
d1063 1
d1423 1
a1423 1
	int s = spltty();
d1427 1
a1427 1
	timo = 2000;
d1429 1
a1429 1
		delay(1);
d1436 1
a1436 1
	timo = 2000;
d1438 1
a1438 1
		delay(1);
@


1.75
log
@#ifdef FOO works much better when FOO isn't misspelled.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.74 2001/09/30 15:20:59 art Exp $	*/
d118 1
d1486 57
@


1.74
log
@Enable break interrupt earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.73 2001/09/30 15:07:52 art Exp $	*/
d1319 1
a1319 1
#ifdef __HAVE_GENERIC_SOFT_INTERUPTS
@


1.73
log
@Next round of cleanups.
 - some KNF.
 - disable interrupts earlier in attach.
 - give it some more time in attach to finish earlier output.
 - explicit bus_space_barrier in comcnputc.
 - dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.72 2001/09/30 01:19:58 art Exp $	*/
d111 1
a131 1
static int com_kgdb_attached;
a339 2
		com_enable_debugport(sc);
		com_kgdb_attached = 1;
d374 2
a377 1
#ifdef KGDB
a392 1
#endif /* KGDB */
@


1.72
log
@Remove dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.71 2001/09/30 00:57:07 art Exp $	*/
a117 1
int	comconsinit;
d182 5
a186 5
	    k = bus_space_read_1(iot, ioh, com_iir);
	    if (k & 0x38) {
		bus_space_read_1(iot, ioh, com_data); /* cleanup */
	    } else
		break;
d189 1
a189 1
	    return 0;
d202 4
d213 1
a213 2
		delay(1000);			/* wait for output to finish */
		comconsinit = 0;
a221 1

a267 1

d327 2
a328 3
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, 0);
	bus_space_write_1(iot, ioh, com_mcr, 0);
d1452 2
a1530 8
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;

	if (comconsinit == 0) {
		cominit(iot, ioh, comdefaultrate);
		comconsinit = 1;
	}

@


1.71
log
@Remove the COM_HAYESP code. It doesn't appear to have been ever used and
it's very intrusive and makes the code less readable.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.70 2001/09/30 00:37:17 art Exp $	*/
a115 4
#ifndef CONSPEED
#define	CONSPEED B9600
#endif

a119 1
int	comconsrate;
a1306 6
#ifdef COM_DEBUG
	int n;
	struct {
		u_char iir, lsr, msr;
	} iter[32];
#endif
a1310 5
#ifdef COM_DEBUG
	n = 0;
	if (ISSET(iter[n].iir = bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
		return (0);
#else
a1312 1
#endif
a1316 3
#ifdef COM_DEBUG
		iter[n].lsr =
#endif
a1327 5
#ifdef notdef
					printf("break %02x %02x %02x %02x\n",
					    sc->sc_msr, sc->sc_mcr, sc->sc_lcr,
					    sc->sc_dtr);
#endif
a1355 5
#ifdef COM_DEBUG
				if (++n >= 32)
					goto ohfudge;
				iter[n].lsr =
#endif
a1360 8
#ifdef COM_DEBUG
		else if (ISSET(lsr, LSR_BI|LSR_FE|LSR_PE|LSR_OE))
			printf("weird lsr %02x\n", lsr);
#endif

#ifdef COM_DEBUG
		iter[n].msr =
#endif
a1399 6
#ifdef COM_DEBUG
		if (++n >= 32)
			goto ohfudge;
		if (ISSET(iter[n].iir = bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
#else
a1401 1
#endif
a1402 14
#ifdef COM_DEBUG
ohfudge:
	printf("comintr: too many iterations");
	for (n = 0; n < 32; n++) {
		if ((n % 4) == 0)
			printf("\ncomintr: iter[%02d]", n);
		printf("  %02x %02x %02x", iter[n].iir, iter[n].lsr, iter[n].msr);
	}
	printf("\n");
	printf("comintr: msr %02x mcr %02x lcr %02x ier %02x\n",
	    sc->sc_msr, sc->sc_mcr, sc->sc_lcr, sc->sc_ier);
	printf("comintr: state %08x cc %d\n", sc->sc_tty->t_state,
	    sc->sc_tty->t_outq.c_cc);
#endif
a1413 44
void
comcnprobe(cp)
	struct consdev *cp;
{
	/* XXX NEEDS TO BE FIXED XXX */
#if defined(arc)
	bus_space_tag_t iot = &arc_bus_io;
#elif defined(powerpc)
	bus_space_tag_t iot = &ppc_isa_io;
#elif defined(hppa)
	bus_space_tag_t iot = &hppa_bustag;
#else
	bus_space_tag_t iot = 0;
#endif
	bus_space_handle_t ioh;
	int found;

	if(CONADDR == 0) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	comconsiot = iot;
	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh)) {
		cp->cn_pri = CN_DEAD;
		return;
	}
	found = comprobe1(iot, ioh);
	bus_space_unmap(iot, ioh, COM_NPORTS);
	if (!found) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	/* locate the major number */
	for (commajor = 0; commajor < nchrdev; commajor++)
		if (cdevsw[commajor].d_open == comopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(commajor, CONUNIT);
	cp->cn_pri = CN_NORMAL;
}

a1464 15

void
comcninit(cp)
	struct consdev *cp;
{

	comconsaddr = CONADDR;

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
		panic("comcninit: mapping failed");

	cominit(comconsiot, comconsioh, comdefaultrate);
	comconsinit = 0;
}

@


1.70
log
@Move out the com at commulti attachment into an ownfile.
Same story as isapnp - not tested because i386 uses pccom.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.69 2001/09/30 00:11:57 art Exp $	*/
a98 3
#ifdef COM_HAYESP
#include <dev/ic/hayespreg.h>
#endif
a199 65
#ifdef COM_HAYESP
int
comprobeHAYESP(hayespioh, sc)
	bus_space_handle_t hayespioh;
	struct com_softc *sc;
{
	char	val, dips;
	int	combaselist[] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
	bus_space_tag_t iot = sc->sc_iot;

	/*
	 * Hayes ESP cards have two iobases.  One is for compatibility with
	 * 16550 serial chips, and at the same ISA PC base addresses.  The
	 * other is for ESP-specific enhanced features, and lies at a
	 * different addressing range entirely (0x140, 0x180, 0x280, or 0x300).
	 */

	/* Test for ESP signature */
	if ((bus_space_read_1(iot, hayespioh, 0) & 0xf3) == 0)
		return 0;

	/*
	 * ESP is present at ESP enhanced base address; unknown com port
	 */

	/* Get the dip-switch configurations */
	bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_GETDIPS);
	dips = bus_space_read_1(iot, hayespioh, HAYESP_STATUS1);

	/* Determine which com port this ESP card services: bits 0,1 of  */
	/*  dips is the port # (0-3); combaselist[val] is the com_iobase */
	if (sc->sc_iobase != combaselist[dips & 0x03])
		return 0;

	printf(": ESP");

	/* Check ESP Self Test bits. */
	/* Check for ESP version 2.0: bits 4,5,6 == 010 */
	bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_GETTEST);
	val = bus_space_read_1(iot, hayespioh, HAYESP_STATUS1); /* Clear reg 1 */
	val = bus_space_read_1(iot, hayespioh, HAYESP_STATUS2);
	if ((val & 0x70) < 0x20) {
		printf("-old (%o)", val & 0x70);
		/* we do not support the necessary features */
		return 0;
	}

	/* Check for ability to emulate 16550: bit 8 == 1 */
	if ((dips & 0x80) == 0) {
		printf(" slave");
		/* XXX Does slave really mean no 16550 support?? */
		return 0;
	}

	/*
	 * If we made it this far, we are a full-featured ESP v2.0 (or
	 * better), at the correct com port address.
	 */

	SET(sc->sc_hwflags, COM_HW_HAYESP);
	printf(", 1024 byte fifo\n");
	return 1;
}
#endif

a220 20
#ifdef COM_HAYESP
	/* Look for a Hayes ESP board. */
	for (hayespp = hayesp_ports; *hayespp != 0; hayespp++) {
		bus_space_handle_t hayespioh;

#define	HAYESP_NPORTS	8			/* XXX XXX XXX ??? ??? ??? */
		if (bus_space_map(iot, *hayespp, HAYESP_NPORTS, 0, &hayespioh))
			continue;
		if (comprobeHAYESP(hayespioh, sc)) {
			sc->sc_hayespbase = *hayespp;
			sc->sc_hayespioh = hayespioh;
			sc->sc_fifolen = 1024;
			break;
		}
		bus_space_unmap(iot, hayespioh, HAYESP_NPORTS);
	}
	/* No ESP; look for other things. */
	if (*hayespp == 0) {
#endif

a330 3
#ifdef COM_HAYESP
	}
#endif
a564 32
#ifdef COM_HAYESP
		/* Setup the ESP board */
		if (ISSET(sc->sc_hwflags, COM_HW_HAYESP)) {
			bus_space_handle_t hayespioh = sc->sc_hayespioh;

			bus_space_write_1(iot, ioh, com_fifo,
			    FIFO_DMA_MODE|FIFO_ENABLE|
			    FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_8);

			/* Set 16550 compatibility mode */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETMODE);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			    HAYESP_MODE_FIFO|HAYESP_MODE_RTS|
			    HAYESP_MODE_SCALE);

			/* Set RTS/CTS flow control */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETFLOWTYPE);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, HAYESP_FLOW_RTS);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, HAYESP_FLOW_CTS);

			/* Set flow control levels */
			bus_space_write_1(iot, hayespioh, HAYESP_CMD1, HAYESP_SETRXFLOW);
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			    HAYESP_HIBYTE(HAYESP_RXHIWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			    HAYESP_LOBYTE(HAYESP_RXHIWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			    HAYESP_HIBYTE(HAYESP_RXLOWMARK));
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
			    HAYESP_LOBYTE(HAYESP_RXLOWMARK));
		} else
#endif
d1022 1
a1022 2
		if (!ISSET(sc->sc_hwflags, COM_HW_HAYESP) &&
		    ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
a1112 3
#ifdef COM_HAYESP
		u_char buffer[1024];	/* XXX: largest fifo */
#else
d1114 1
a1114 1
#endif
@


1.69
log
@Move out com at isapnp attachment into an own file.
Not tested because the only system with isapnp is i386 and i386 uses pccom.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.68 2001/09/29 23:26:07 art Exp $	*/
a111 6
/*
 * XXX the following two cfattach structs should be different, and possibly
 * XXX elsewhere.
 */
int	comprobe __P((struct device *, void *, void *));
void	comattach __P((struct device *, struct device *, void *));
a114 6
#if NCOM_COMMULTI
struct cfattach com_commulti_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

a266 75

int
comprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int iobase;
	int rv = 1;

#if NCOM_COMMULTI
	if (1) {
		struct cfdata *cf = match;
		struct commulti_attach_args *ca = aux;

		if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != ca->ca_slave)
			return (0);

		iot = ca->ca_iot;
		iobase = ca->ca_iobase;
		ioh = ca->ca_ioh;
	} else
#endif
		return(0);			/* This cannot happen */

#ifdef KGDB
	if (iobase == com_kgdb_addr)
		goto out;
#endif
	/* if it's in use as console, it's there. */
	if (iobase == comconsaddr && !comconsattached)
		goto out;

	rv = comprobe1(iot, ioh);
out:
	return (rv);
}

void
comattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct com_softc *sc = (void *)self;
	int iobase;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct commulti_attach_args *ca = aux;
#ifdef COM_HAYESP
	int	hayesp_ports[] = { 0x140, 0x180, 0x280, 0x300, 0 };
	int	*hayespp;
#endif

	/*
	 * XXX should be broken out into functions for isa attach and
	 * XXX for commulti attach, with a helper function that contains
	 * XXX most of the interesting stuff.
	 */
	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;
	iobase = ca->ca_iobase;
	iot = ca->ca_iot;
	ioh = ca->ca_ioh;

	if (ca->ca_noien)
		SET(sc->sc_hwflags, COM_HW_NOIEN);

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_iobase = iobase;
	sc->sc_frequency = COM_FREQ;

	com_attach_subr(sc);
}
@


1.68
log
@Next step in making the com driver improvable.
Split out the com at isa attachment into its own file.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.67 2001/09/29 03:07:57 art Exp $	*/
a105 4
#if NCOM_ISAPNP
#include <dev/isa/isavar.h>	/* XXX */
#endif

a120 6
#if NCOM_ISAPNP
struct cfattach com_isapnp_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

a165 8
/* Macros for determining bus type. */
#if NCOM_ISAPNP
#define IS_ISAPNP(parent) \
    (strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isapnp") == 0)
#else
#define IS_ISAPNP(parent) 0
#endif

a289 14
	/*
	 * XXX should be broken out into functions for isa probe and
	 * XXX for commulti probe, with a helper function that contains
	 * XXX most of the interesting stuff.
	 */
#if NCOM_ISAPNP
	if (IS_ISAPNP(parent)) {
		struct isa_attach_args *ia = aux;

		iot = ia->ia_iot;
		iobase = ia->ia_iobase;
		ioh = ia->ia_ioh;
	} else
#endif
a324 3
#if NCOM_ISAPNP || NCOM_COMMULTI
	int irq;
#endif
d327 1
d340 3
a342 17
#if NCOM_ISAPNP
	if (IS_ISAPNP(parent)) {
		struct isa_attach_args *ia = aux;

		/*
		 * We're living on an isa.
		 */
		iobase = ia->ia_iobase;
		iot = ia->ia_iot;
		/* No console support! */
		ioh = ia->ia_ioh;
		irq = ia->ia_irq;
	} else
#endif
#if NCOM_COMMULTI
	if (1) {
		struct commulti_attach_args *ca = aux;
d344 2
a345 39
		/*
		 * We're living on a commulti.
		 */
		iobase = ca->ca_iobase;
		iot = ca->ca_iot;
		ioh = ca->ca_ioh;
		irq = IRQUNK;

		if (ca->ca_noien)
			SET(sc->sc_hwflags, COM_HW_NOIEN);
	} else
#endif
		panic("comattach: impossible");
#if NCOM_ISAPNP || NCOM_COMMULTI
        if (irq != IRQUNK) {
#if NCOM_ISAPNP
	if (IS_ISAPNP(parent)) {
		struct isa_attach_args *ia = aux;

#ifdef KGDB     
		if (iobase == com_kgdb_addr) {
			sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				IST_EDGE, IPL_HIGH, kgdbintr, sc,
				sc->sc_dev.dv_xname);
		} else {
			sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				IST_EDGE, IPL_TTY, comintr, sc,
				sc->sc_dev.dv_xname);
		}
#else   
		sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
			IST_EDGE, IPL_TTY, comintr, sc,
			sc->sc_dev.dv_xname);
#endif /* KGDB */
	} else
#endif          
		panic("comattach: IRQ but can't have one");
	}       
#endif          
@


1.67
log
@- compoll is now scheduled once for every sc instead of just one timeout for
  all ports and looping over them.
- support for generic soft interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.66 2001/09/27 22:29:51 art Exp $	*/
d106 1
a106 1
#if NCOM_ISA || NCOM_ISAPNP
a124 6
#if NCOM_ISA
struct cfattach com_isa_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

a144 3
#ifdef COMCONSOLE
int	comdefaultrate = CONSPEED;		/* XXX why set default? */
#else
a145 1
#endif
a176 7
#if NCOM_ISA
#define IS_ISA(parent) \
    (strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa") == 0)
#else
#define IS_ISA(parent) 0
#endif

d305 1
a305 1
	int iobase, needioh;
d313 2
a314 2
#if NCOM_ISA || NCOM_ISAPNP
	if (IS_ISA(parent) || IS_ISAPNP(parent)) {
d319 1
a319 5
		if (IS_ISAPNP(parent)) {
			ioh = ia->ia_ioh;
			needioh = 0;
		} else
			needioh = 1;
a332 1
		needioh = 0;
a344 4
	if (needioh && bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh)) {
		rv = 0;
		goto out;
	}
a345 3
	if (needioh)
		bus_space_unmap(iot, ioh, COM_NPORTS);

a346 8
#if NCOM_ISA
	if (rv && IS_ISA(parent)) {
		struct isa_attach_args *ia = aux;

		ia->ia_iosize = COM_NPORTS;
		ia->ia_msize = 0;
	}
#endif
d357 1
a357 1
#if NCOM_ISA || NCOM_ISAPNP || NCOM_COMMULTI
d374 2
a375 2
#if NCOM_ISA || NCOM_ISAPNP
	if (IS_ISA(parent) || IS_ISAPNP(parent)) {
d383 2
a384 24
		if (IS_ISAPNP(parent)) {
			/* No console support! */
			ioh = ia->ia_ioh;
		} else {
#ifdef KGDB
			if ((iobase != comconsaddr) &&
			    (iobase != com_kgdb_addr)) {
#else
			if (iobase != comconsaddr) {
#endif
				if (bus_space_map(iot, iobase, COM_NPORTS, 0,
				    &ioh))
					panic("comattach: io mapping failed");
			} else
#ifdef KGDB
				if (iobase == comconsaddr) {
					ioh = comconsioh;
				} else {
					ioh = com_kgdb_ioh;
				}
#else
				ioh = comconsioh;
#endif
		}
d405 1
a405 1
#if NCOM_ISA || NCOM_ISAPNP || NCOM_COMMULTI
d407 2
a408 2
#if NCOM_ISA || NCOM_ISAPNP
	if (IS_ISA(parent) || IS_ISAPNP(parent)) {
a613 1
	/* XXX maybe move up some? */
d644 1
a1812 3
#ifdef	COMCONSOLE
	cp->cn_pri = CN_REMOTE;		/* Force a serial port console */
#else
a1813 1
#endif
d1954 1
a1955 1

@


1.66
log
@Simplify comstart a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.65 2001/09/27 21:35:46 millert Exp $	*/
a163 2
struct timeout compoll_to;

a164 2
int	comsopen = 0;
int	comevents = 0;
a687 3
	if (!timeout_initialized(&compoll_to))
		timeout_set(&compoll_to, compoll, NULL);

d690 7
d753 5
d859 3
a861 2
		if (comsopen++ == 0)
			timeout_add(&compoll_to, 1);
d1052 3
a1054 2
	if (--comsopen == 0)
		timeout_del(&compoll_to);
d1535 1
a1535 2
	int unit;
	struct com_softc *sc;
d1548 1
a1548 3
	s = spltty();
	if (comevents == 0) {
		splx(s);
a1549 3
	}
	comevents = 0;
	splx(s);
d1551 1
a1551 4
	for (unit = 0; unit < com_cd.cd_ndevs; unit++) {
		sc = com_cd.cd_devs[unit];
		if (sc == 0 || sc->sc_ibufp == sc->sc_ibuf)
			continue;
d1553 1
a1553 1
		tp = sc->sc_tty;
d1555 2
a1556 1
		s = spltty();
d1558 4
a1561 2
		ibufp = sc->sc_ibuf;
		ibufend = sc->sc_ibufp;
d1563 4
a1566 4
		if (ibufp == ibufend) {
			splx(s);
			continue;
		}
d1568 4
a1571 4
		sc->sc_ibufp = sc->sc_ibuf = (ibufp == sc->sc_ibufs[0]) ?
					     sc->sc_ibufs[1] : sc->sc_ibufs[0];
		sc->sc_ibufhigh = sc->sc_ibuf + COM_IHIGHWATER;
		sc->sc_ibufend = sc->sc_ibuf + COM_IBUFSIZE;
d1573 7
a1579 4
		if (tp == 0 || !ISSET(tp->t_state, TS_ISOPEN)) {
			splx(s);
			continue;
		}
d1581 1
a1581 9
		if (ISSET(tp->t_cflag, CRTSCTS) &&
		    !ISSET(sc->sc_mcr, MCR_RTS)) {
			/* XXX */
			SET(sc->sc_mcr, MCR_RTS);
			bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr,
			    sc->sc_mcr);
		}

		splx(s);
d1583 10
a1592 11
		while (ibufp < ibufend) {
			c = *ibufp++;
			if (ISSET(*ibufp, LSR_OE)) {
				sc->sc_overflows++;
				if (sc->sc_errors++ == 0)
					timeout_add(&sc->sc_diag_tmo, 60 * hz);
			}
			/* This is ugly, but fast. */
			c |= lsrmap[(*ibufp++ & (LSR_BI|LSR_FE|LSR_PE)) >> 2];
			(*linesw[tp->t_line].l_rint)(c, tp);
		}
d1596 3
a1598 1
	timeout_add(&compoll_to, 1);
d1700 3
a1702 1
			comevents = 1;
@


1.65
log
@Enable #if 0'd code in comcnputc() so serial console works correctly;
art@@openbsd.org
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.64 2001/09/27 15:37:33 art Exp $	*/
d1454 1
d1459 1
d1466 6
a1471 5
		u_char *cp = buffer;
		int n = q_to_b(&tp->t_outq, cp, sc->sc_fifolen);
		do {
			bus_space_write_1(iot, ioh, com_data, *cp++);
		} while (--n);
@


1.64
log
@Split out comattach that does isa and isapnp attachment and initialization,
into comattach that does the isa stuff and com_attach_subr that does the
init.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.63 2001/04/17 04:30:49 aaron Exp $	*/
a2007 2
#if 0
	/* XXX not needed? */
a2014 1
#endif
@


1.63
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.62 2001/03/15 21:09:17 art Exp $	*/
a406 1
	u_int8_t lcr;
d468 26
d500 12
a511 1
	if (iobase == comconsaddr) {
a661 26
#if NCOM_ISA || NCOM_ISAPNP || NCOM_COMMULTI
	if (irq != IRQUNK) {
#if NCOM_ISA || NCOM_ISAPNP
		if (IS_ISA(parent) || IS_ISAPNP(parent)) {
			struct isa_attach_args *ia = aux;

#ifdef KGDB
			if (iobase == com_kgdb_addr) {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, kgdbintr, sc,
				    sc->sc_dev.dv_xname);
			} else {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_TTY, comintr, sc,
				    sc->sc_dev.dv_xname);
			}
#else
			sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
			    IST_EDGE, IPL_TTY, comintr, sc,
			    sc->sc_dev.dv_xname);
#endif /* KGDB */
		} else
#endif
			panic("comattach: IRQ but can't have one");
	}
#endif
d1977 1
d1980 1
@


1.62
log
@Put back new timeouts. This time with correct timeout for compoll.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.61 2001/03/15 18:55:02 deraadt Exp $	*/
d1963 1
a1963 1
		NULL, NULL, comcngetc, comcnputc, comcnpollc,
@


1.61
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.60 2001/03/15 18:47:52 art Exp $	*/
d164 2
d228 1
a228 1
#undef	divrnd(n, q)
d248 1
a248 1
	if (i >= 32) 
d290 1
a290 1
 	/* Check ESP Self Test bits. */
d351 1
a351 1
 
d478 1
a478 1
		/* 
d680 7
a686 1
	} 
d709 1
a709 1
	
d741 2
a742 3
	untimeout(compoll, NULL);
	untimeout(com_raisedtr, sc);
	untimeout(comdiag, sc);
d794 1
a794 1
 
d845 1
a845 1
			timeout(compoll, NULL, 1);
d882 1
a882 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
d893 1
a893 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
d930 1
a930 1
			 	bus_space_write_1(iot, ioh, com_fifo, 0);
d938 1
a938 1
				    	break;
d1006 1
a1006 1
 
d1030 1
a1030 1
		timeout(com_raisedtr, sc, hz * 2);
d1037 1
a1037 1
		untimeout(compoll, NULL);
d1111 1
a1111 1
 
d1114 1
a1114 1
 
d1123 1
a1123 1
 
d1136 1
a1136 1
 
d1243 1
a1243 1
		error = suser(p->p_ucred, &p->p_acflag); 
d1245 1
a1245 1
			return(EPERM); 
a1504 1

d1576 1
a1576 1
			if (*ibufp & LSR_OE) {
d1579 1
a1579 1
					timeout(comdiag, sc, 60 * hz);
d1588 1
a1588 1
	timeout(compoll, NULL, 1);
d1712 1
a1712 1
						timeout(comdiag, sc, 60 * hz);
@


1.60
log
@back out new timeouts until I find out why they break alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.59 2001/03/15 17:52:20 deraadt Exp $	*/
d204 1
a204 1
comspeedcomspeed(freq, speed)
@


1.59
log
@support puc devices with higher speeds (not tested yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.58 2001/03/13 02:53:51 mickey Exp $	*/
d226 1
a226 1
#undef	divrnd
d246 1
a246 1
	if (i >= 32)
d288 1
a288 1
	/* Check ESP Self Test bits. */
d349 1
a349 1

d476 1
a476 1
		/*
d678 1
a678 5
	}

	timeout_set(&sc->sc_poll_tmo, compoll, sc);
	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
d701 1
a701 1

d733 3
a735 3
	timeout_del(&sc->sc_poll_tmo);
	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
d787 1
a787 1

d838 1
a838 1
			timeout_add(&sc->sc_poll_tmo, 1);
d875 1
a875 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
d886 1
a886 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
d923 1
a923 1
				bus_space_write_1(iot, ioh, com_fifo, 0);
d931 1
a931 1
					break;
d999 1
a999 1

d1023 1
a1023 1
		timeout_add(&sc->sc_dtr_tmo, hz * 2);
d1030 1
a1030 1
		timeout_del(&sc->sc_poll_tmo);
d1104 1
a1104 1

d1107 1
a1107 1

d1116 1
a1116 1

d1129 1
a1129 1

d1236 1
a1236 1
		error = suser(p->p_ucred, &p->p_acflag);
d1238 1
a1238 1
			return(EPERM);
d1498 1
d1570 1
a1570 1
			if (ISSET(*ibufp, LSR_OE)) {
d1573 1
a1573 1
					timeout_add(&sc->sc_diag_tmo, 60 * hz);
d1582 1
a1582 1
	timeout_add(&sc->sc_poll_tmo, 1);
d1706 1
a1706 1
						timeout_add(&sc->sc_diag_tmo, 60 * hz);
@


1.58
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.57 2001/01/24 09:38:04 hugh Exp $	*/
d204 2
a205 1
comspeed(speed)
d216 1
a216 1
	x = divrnd((COM_FREQ / 16), speed);
d219 1
a219 1
	err = divrnd((COM_FREQ / 16) * 1000, speed * x) - 1000;
d471 1
d1275 1
a1275 1
	int ospeed = comspeed(t->c_ospeed);
d1940 1
a1940 1
	rate = comspeed(rate); /* XXX not comdefaultrate? */
@


1.57
log
@KGDB for i386 from NetBSD via niklas, with tweaks and accommodations.
Tested by various, vetted by mickey & theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.56 2000/11/08 15:42:48 art Exp $	*/
d225 1
a225 1
#undef	divrnd(n, q)
d245 1
a245 1
	if (i >= 32) 
d287 1
a287 1
 	/* Check ESP Self Test bits. */
d348 1
a348 1
 
d474 1
a474 1
		/* 
d676 5
a680 1
	} 
d703 1
a703 1
	
d735 3
a737 3
	untimeout(compoll, NULL);
	untimeout(com_raisedtr, sc);
	untimeout(comdiag, sc);
d789 1
a789 1
 
d840 1
a840 1
			timeout(compoll, NULL, 1);
d877 1
a877 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
d888 1
a888 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2, 
d925 1
a925 1
			 	bus_space_write_1(iot, ioh, com_fifo, 0);
d933 1
a933 1
				    	break;
d1001 1
a1001 1
 
d1025 1
a1025 1
		timeout(com_raisedtr, sc, hz * 2);
d1032 1
a1032 1
		untimeout(compoll, NULL);
d1106 1
a1106 1
 
d1109 1
a1109 1
 
d1118 1
a1118 1
 
d1131 1
a1131 1
 
d1238 1
a1238 1
		error = suser(p->p_ucred, &p->p_acflag); 
d1240 1
a1240 1
			return(EPERM); 
a1499 1

d1571 1
a1571 1
			if (*ibufp & LSR_OE) {
d1574 1
a1574 1
					timeout(comdiag, sc, 60 * hz);
d1583 1
a1583 1
	timeout(compoll, NULL, 1);
d1707 1
a1707 1
						timeout(comdiag, sc, 60 * hz);
@


1.56
log
@Add comcnattach that does the basic steps needed to attach
a com as a serial console. (idea from NetBSD).

If cn_tab->cn_dev == NODEV, try to find comopen in cdevsw and set cn_dev
to the right device.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.55 2000/01/27 09:05:33 mickey Exp $	*/
d159 1
d169 10
a178 5
#include <machine/remote-sl.h>
extern int kgdb_dev;
extern int kgdb_rate;
extern int kgdb_debug_init;
#endif
d360 4
d426 4
d431 1
d436 7
d444 1
d628 11
d642 1
d649 11
a659 16
	if (kgdb_dev == makedev(commajor, unit)) {
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			kgdb_dev = -1;	/* can't debug over console port */
		else {
			cominit(iot, ioh, kgdb_rate);
			if (kgdb_debug_init) {
				/*
				 * Print prefix of device name,
				 * let kgdb_connect print the rest.
				 */
				printf("%s: ", sc->sc_dev.dv_xname);
				kgdb_connect(1);
			} else
				printf("%s: kgdb enabled\n",
				    sc->sc_dev.dv_xname);
		}
d661 1
a661 1
#endif
d686 18
d753 3
d757 1
d792 8
d1583 56
d1859 52
d1916 3
a1918 1
	if (bus_space_map(comconsiot, CONADDR, COM_NPORTS, 0, &comconsioh))
a1921 1
	comconsaddr = CONADDR;
d1935 1
a1935 1
	rate = comspeed(comdefaultrate);
d1939 1
d1941 2
a1942 1
	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
d1977 1
a1977 11
	int s = splhigh();
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;
	u_char stat, c;

	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		;
	c = bus_space_read_1(iot, ioh, com_data);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return c;
d1988 2
a1989 1
	int s = splhigh();
a1991 2
	u_char stat;
	register int timo;
a1992 3
#ifdef KGDB
	if (dev != kgdb_dev)
#endif
a1996 12
	/* wait for any pending transmission to finish */
	timo = 50000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
	bus_space_write_1(iot, ioh, com_data, c);
	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
#if 0 /* I don't think sooooo (pefo) */
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
d1998 2
a1999 1
	splx(s);
d2009 48
@


1.55
log
@isa-avoidance
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.54 2000/01/11 04:08:45 mickey Exp $	*/
d94 2
d634 11
a644 1
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
d646 1
a1688 1
#include <dev/cons.h>
d1774 26
@


1.55.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.63 2001/04/17 04:30:49 aaron Exp $	*/
a93 2
#include <dev/cons.h>

a156 1
int	comconsrate;
a160 2
struct timeout compoll_to;

d166 5
a170 10
#include <sys/kgdb.h>

static int com_kgdb_addr;
static bus_space_tag_t com_kgdb_iot;
static bus_space_handle_t com_kgdb_ioh;
static int com_kgdb_attached;

int    com_kgdb_getc __P((void *));
void   com_kgdb_putc __P((void *, int));
#endif /* KGDB */
d196 1
a196 2
comspeed(freq, speed)
	long freq;
d207 1
a207 1
	x = divrnd((freq / 16), speed);
d210 1
a210 1
	err = divrnd((freq / 16) * 1000, speed * x) - 1000;
d217 1
a217 1
#undef	divrnd
d237 1
a237 1
	if (i >= 32)
d279 1
a279 1
	/* Check ESP Self Test bits. */
d340 1
a340 1

a351 4
#ifdef KGDB
	if (iobase == com_kgdb_addr)
		goto out;
#endif
a413 4
#ifdef KGDB
			if ((iobase != comconsaddr) &&
			    (iobase != com_kgdb_addr)) {
#else
a414 1
#endif
a418 7
#ifdef KGDB
				if (iobase == comconsaddr) {
					ioh = comconsioh;
				} else {
					ioh = com_kgdb_ioh;
				}
#else
a419 1
#endif
a444 1
	sc->sc_frequency = COM_FREQ;
d449 1
a449 1
		/*
a602 11
#ifdef KGDB
			if (iobase == com_kgdb_addr) {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_HIGH, kgdbintr, sc,
				    sc->sc_dev.dv_xname);
			} else {
				sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
				    IST_EDGE, IPL_TTY, comintr, sc,
				    sc->sc_dev.dv_xname);
			}
#else
a605 1
#endif /* KGDB */
d612 16
a627 11
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */

	if (iot == com_kgdb_iot && iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
		SET(sc->sc_hwflags, COM_HW_KGDB);
		com_enable_debugport(sc);
		com_kgdb_attached = 1;
d629 1
a629 1
#endif /* KGDB */
d632 1
a632 11
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == comopen)
				break;

		if (maj < nchrdev && cn_tab->cn_dev == NODEV)
			cn_tab->cn_dev = makedev(maj, sc->sc_dev.dv_unit);

a633 7
	}

	if (!timeout_initialized(&compoll_to))
		timeout_set(&compoll_to, compoll, NULL);

	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);
a642 18
#ifdef KGDB
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	SET(sc->sc_ier, IER_ERXRDY);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS | MCR_IENABLE);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);

	splx(s);
}
#endif /* KGDB */

d670 3
a672 2
	timeout_del(&sc->sc_dtr_tmo);
	timeout_del(&sc->sc_diag_tmo);
a691 3
#ifdef KGDB
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
#else
a692 1
#endif /* KGDB */
d720 1
a720 1

a726 8
#ifdef KGDB
	/*
	 * If this is the kgdb port, no other use is permitted.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return (EBUSY);
#endif /* KGDB */

d763 1
a763 1
			timeout_add(&compoll_to, 1);
d800 1
a800 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
d811 1
a811 1
			bus_space_write_1(iot, hayespioh, HAYESP_CMD2,
d848 1
a848 1
				bus_space_write_1(iot, ioh, com_fifo, 0);
d856 1
a856 1
					break;
d924 1
a924 1

d948 1
a948 1
		timeout_add(&sc->sc_dtr_tmo, hz * 2);
d955 1
a955 1
		timeout_del(&compoll_to);
d1029 1
a1029 1

d1032 1
a1032 1

d1041 1
a1041 1

d1054 1
a1054 1

d1161 1
a1161 1
		error = suser(p->p_ucred, &p->p_acflag);
d1163 1
a1163 1
			return(EPERM);
d1196 1
a1196 1
	int ospeed = comspeed(sc->sc_frequency, t->c_ospeed);
d1423 1
d1495 1
a1495 1
			if (ISSET(*ibufp, LSR_OE)) {
d1498 1
a1498 1
					timeout_add(&sc->sc_diag_tmo, 60 * hz);
d1507 1
a1507 56
	timeout_add(&compoll_to, 1);
}

#ifdef KGDB

/*
 * If a line break is set, or data matches one of the characters
 * gdb uses to signal a connection, then start up kgdb. Just gobble
 * any other data. Done in a stand alone function because comintr
 * does tty stuff and we don't have one.
 */

int
kgdbintr(arg)
	void *arg;
{
	struct com_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char lsr, data, msr, delta;

	if (!ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return(0);

	for (;;) {
		lsr = bus_space_read_1(iot, ioh, com_lsr);
		if (ISSET(lsr, LSR_RXRDY)) {
			do {
				data = bus_space_read_1(iot, ioh, com_data);
				if (data == 3 || data == '$' || data == '+' ||
				    ISSET(lsr, LSR_BI)) {
					kgdb_connect(1);
					data = 0;
				}
				lsr = bus_space_read_1(iot, ioh, com_lsr);
			} while (ISSET(lsr, LSR_RXRDY));

		}
		if (ISSET(lsr, LSR_BI|LSR_FE|LSR_PE|LSR_OE))
			printf("weird lsr %02x\n", lsr);

		msr = bus_space_read_1(iot, ioh, com_msr);

		if (msr != sc->sc_msr) {
			delta = msr ^ sc->sc_msr;
			sc->sc_msr = msr;
			if (ISSET(delta, MSR_DCD)) {
				if (!ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
					CLR(sc->sc_mcr, sc->sc_dtr);
					bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
				}
			}
		}
		if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_NOPEND))
			return (1);
	}
a1508 1
#endif /* KGDB */
d1575 1
a1575 1
						timeout_add(&sc->sc_diag_tmo, 60 * hz);
d1676 1
a1730 52
/*
 * The following functions are polled getc and putc routines, shared
 * by the console and kgdb glue.
 */

int
com_common_getc(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	int s = splhigh();
	u_char stat, c;

	/* block until a character becomes available */
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		continue;

	c = bus_space_read_1(iot, ioh, com_data);
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return (c);
}

void
com_common_putc(iot, ioh, c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int c;
{
	int s = splhigh();
	int timo;

	/* wait for any pending transmission to finish */
	timo = 150000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	bus_space_write_1(iot, ioh, com_data, c);

	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		continue;

	splx(s);
}

/*
 * Following are all routines needed for COM to act as console
 */

d1736 1
a1736 3
	comconsaddr = CONADDR;

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
d1740 1
d1754 1
a1754 1
	rate = comspeed(COM_FREQ, rate); /* XXX not comdefaultrate? */
a1757 1
	bus_space_write_1(iot, ioh, com_mcr, MCR_DTR | MCR_RTS);
d1759 1
a1759 2
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_1);
a1764 26
comcnattach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	int iobase;
	int rate, frequency;
	tcflag_t cflag;
{
	static struct consdev comcons = {
		NULL, NULL, comcngetc, comcnputc, comcnpollc, NULL,
		NODEV, CN_NORMAL
	};

	if (bus_space_map(iot, iobase, COM_NPORTS, 0, &comconsioh))
		return ENOMEM;

	cominit(iot, comconsioh, rate);

	cn_tab = &comcons;

	comconsiot = iot;
	comconsaddr = iobase;
	comconscflag = cflag;

	return (0);
}

int
d1768 11
a1778 1
	return (com_common_getc(comconsiot, comconsioh));
d1789 1
a1789 2
#if 0
	/* XXX not needed? */
d1792 2
d1795 3
d1802 12
d1815 1
a1815 2
	com_common_putc(comconsiot, comconsioh, c);

a1824 48

#ifdef KGDB
int
com_kgdb_attach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	int iobase;
	int rate, frequency;
	tcflag_t cflag;
{
	if (iot == comconsiot && iobase == comconsaddr) {
		return (EBUSY); /* cannot share with console */
	}

	com_kgdb_iot = iot;
	com_kgdb_addr = iobase;

	if (bus_space_map(com_kgdb_iot, com_kgdb_addr, COM_NPORTS, 0,
	    &com_kgdb_ioh))
		panic("com_kgdb_attach: mapping failed");

	/* XXX We currently don't respect KGDBMODE? */
	cominit(com_kgdb_iot, com_kgdb_ioh, rate);

	kgdb_attach(com_kgdb_getc, com_kgdb_putc, NULL);
	kgdb_dev = 123; /* unneeded, only to satisfy some tests */

	return (0);
}

/* ARGSUSED */
int
com_kgdb_getc(arg)
	void *arg;
{

	return (com_common_getc(com_kgdb_iot, com_kgdb_ioh));
}

/* ARGSUSED */
void
com_kgdb_putc(arg, c)
	void *arg;
	int c;
{

	return (com_common_putc(com_kgdb_iot, com_kgdb_ioh, c));
}
#endif /* KGDB */
@


1.55.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.55.2.1 2001/05/14 22:23:38 niklas Exp $	*/
d99 3
d106 4
d116 6
d124 18
a141 1
void	com_enable_debugport	__P((struct com_softc *));
d147 7
d155 2
a157 1
int	comconsaddr;
d159 1
d164 2
d167 2
d176 1
d190 15
d242 5
a246 5
		k = bus_space_read_1(iot, ioh, com_iir);
		if (k & 0x38) {
			bus_space_read_1(iot, ioh, com_data); /* cleanup */
		} else
			break;
d249 37
d288 27
d317 73
d392 3
a394 2
com_attach_subr(sc)
	struct com_softc *sc;
d396 11
a406 2
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
d409 65
a473 3
	sc->sc_ier = 0;
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, sc->sc_ier);
d475 1
a475 1
	if (sc->sc_iobase == comconsaddr) {
d482 2
a483 1
		delay(10000);			/* wait for output to finish */
d488 20
d512 1
d559 1
d618 3
d622 3
a624 2
	sc->sc_mcr = 0;
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
d626 26
d662 2
d667 1
d682 3
a686 7
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	sc->sc_si = softintr_establish(IPL_TTY, compoll, sc);
	if (sc->sc_si == NULL)
		panic("%s: can't establish soft interrupt.", sc->sc_dev.dv_xname);
#else
	timeout_set(&sc->sc_poll_tmo, compoll, sc);
#endif
a693 3

	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE|COM_HW_KGDB))
		com_enable_debugport(sc);
d696 1
d712 1
a742 5
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	softintr_disestablish(sc->sc_si);
#else
	timeout_del(&sc->sc_poll_tmo);
#endif
d844 2
a845 3
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
		timeout_add(&sc->sc_poll_tmo, 1);
#endif
d871 32
d1036 2
a1037 3
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
	timeout_del(&sc->sc_poll_tmo);
#endif
d1359 2
a1360 1
		if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
a1443 1
	/* Enable transmit completion interrupts. */
a1447 1

d1449 3
d1453 6
a1458 7

		int n = q_to_b(&tp->t_outq, buffer, sc->sc_fifolen);
		int i;

		for (i = 0; i < n; i++) {
			bus_space_write_1(iot, ioh, com_data, buffer[i]);
		}
d1515 2
a1516 1
	struct com_softc *sc = (struct com_softc *)arg;
d1529 3
a1531 1
	if (sc == 0 || sc->sc_ibufp == sc->sc_ibuf)
d1533 3
d1537 6
a1542 1
	tp = sc->sc_tty;
d1544 1
a1544 1
	s = spltty();
d1546 2
a1547 2
	ibufp = sc->sc_ibuf;
	ibufend = sc->sc_ibufp;
d1549 4
a1552 4
	if (ibufp == ibufend) {
		splx(s);
		goto out;
	}
d1554 4
a1557 4
	sc->sc_ibufp = sc->sc_ibuf = (ibufp == sc->sc_ibufs[0]) ?
				     sc->sc_ibufs[1] : sc->sc_ibufs[0];
	sc->sc_ibufhigh = sc->sc_ibuf + COM_IHIGHWATER;
	sc->sc_ibufend = sc->sc_ibuf + COM_IBUFSIZE;
d1559 4
a1562 4
	if (tp == 0 || !ISSET(tp->t_state, TS_ISOPEN)) {
		splx(s);
		goto out;
	}
d1564 7
a1570 7
	if (ISSET(tp->t_cflag, CRTSCTS) &&
	    !ISSET(sc->sc_mcr, MCR_RTS)) {
		/* XXX */
		SET(sc->sc_mcr, MCR_RTS);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr,
		    sc->sc_mcr);
	}
d1572 1
a1572 1
	splx(s);
d1574 11
a1584 10
	while (ibufp < ibufend) {
		c = *ibufp++;
		if (ISSET(*ibufp, LSR_OE)) {
			sc->sc_overflows++;
			if (sc->sc_errors++ == 0)
				timeout_add(&sc->sc_diag_tmo, 60 * hz);
		}
		/* This is ugly, but fast. */
		c |= lsrmap[(*ibufp++ & (LSR_BI|LSR_FE|LSR_PE)) >> 2];
		(*linesw[tp->t_line].l_rint)(c, tp);
d1588 1
a1588 3
#ifndef __HAVE_GENERIC_SOFT_INTERRUPTS
	timeout_add(&sc->sc_poll_tmo, 1);
#endif
d1660 6
d1670 5
d1677 1
d1682 3
d1690 1
a1690 3
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
			softintr_schedule(sc->sc_si);
#endif
d1694 5
d1727 5
d1737 8
d1784 6
d1792 1
d1794 14
d1819 48
a1905 2
	bus_space_barrier(iot, ioh, 0, COM_NPORTS,
	    (BUS_SPACE_BARRIER_READ|BUS_SPACE_BARRIER_WRITE));
d1918 15
a1954 57
void  
comcnprobe(cp)
	struct consdev *cp;  
{
	/* XXX NEEDS TO BE FIXED XXX */
#if defined(arc)
	bus_space_tag_t iot = &arc_bus_io;
#elif defined(hppa)
	bus_space_tag_t iot = &hppa_bustag;
#else
	bus_space_tag_t iot = 0;
#endif
	bus_space_handle_t ioh;
	int found;

	if(CONADDR == 0) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	comconsiot = iot;
	if (bus_space_map(iot, CONADDR, COM_NPORTS, 0, &ioh)) {
		cp->cn_pri = CN_DEAD;
		return;
	}
	found = comprobe1(iot, ioh);
	bus_space_unmap(iot, ioh, COM_NPORTS);
	if (!found) {
		cp->cn_pri = CN_DEAD;
		return;
	}

	/* locate the major number */
	for (commajor = 0; commajor < nchrdev; commajor++)
		if (cdevsw[commajor].d_open == comopen)
			break;

	/* initialize required fields */
	cp->cn_dev = makedev(commajor, CONUNIT);
	cp->cn_pri = CN_NORMAL;
}

void
comcninit(cp)
	struct consdev *cp;
{

	comconsaddr = CONADDR;

	if (bus_space_map(comconsiot, comconsaddr, COM_NPORTS, 0, &comconsioh))
		panic("comcninit: mapping failed");

	cominit(comconsiot, comconsioh, comdefaultrate);
	comconsinit = 0;
}


a1966 1
#ifndef __sparc64__
a1968 1
#endif
d1996 10
d2007 1
@


1.55.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d130 3
a132 3
int com_kgdb_addr;
bus_space_tag_t com_kgdb_iot;
bus_space_handle_t com_kgdb_ioh;
d141 5
d337 1
a337 1
	if (iot == com_kgdb_iot && sc->sc_iobase == com_kgdb_addr &&
d1407 1
a1407 1
#if defined(arc)
a1511 3
#ifdef __hppa__
	found = 1;
#else
a1512 1
#endif
d1526 1
a1526 1
	cp->cn_pri = CN_REMOTE;
d1533 1
@


1.55.2.4
log
@Merge in -current from about a week ago
@
text
@d107 1
a107 1
static u_char tiocm_xxx2mcr(int);
d109 3
a111 3
void	compwroff(struct com_softc *);
void	com_raisedtr(void *);
void	com_enable_debugport(struct com_softc *);
d134 2
a135 2
int    com_kgdb_getc(void *);
void   com_kgdb_putc(void *, int);
d1178 1
a1178 1
	if (sc == NULL || sc->sc_ibufp == sc->sc_ibuf)
d1198 1
a1198 1
	if (tp == NULL || !ISSET(tp->t_state, TS_ISOPEN)) {
@


1.55.2.5
log
@Sync the SMP branch with 3.3
@
text
@d105 1
a381 1
#ifdef KGDB
a383 1
#endif
a920 1
/* already called at spltty */
d932 1
d964 2
d995 1
d1062 1
a1227 2
#else
	;
d1296 4
d1360 13
d1437 1
a1437 1
	int s = spltty();
d1441 1
a1441 1
	timo = 2000;
d1443 1
a1443 1
		delay(1);
d1450 1
a1450 1
	timo = 2000;
d1452 1
a1452 1
		delay(1);
d1475 1
a1475 1
	bus_space_write_1(iot, ioh, com_ier, 0);  /* Make sure they are off */
@


1.55.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.55.2.5 2003/03/28 00:38:12 niklas Exp $	*/
d15 3
d45 5
a49 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.55.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d102 1
d348 1
a348 1
	sc->sc_si = softintr_establish(IPL_TTY, comsoft, sc);
d352 1
a352 1
	timeout_set(&sc->sc_comsoft_tmo, comsoft, sc);
d407 1
d416 1
a416 1
	timeout_del(&sc->sc_comsoft_tmo);
d487 1
d520 1
a520 1
		timeout_add(&sc->sc_comsoft_tmo, 1);
d681 1
a681 1
	timeout_del(&sc->sc_comsoft_tmo);
d888 1
a888 1
		error = suser(p, 0);
d1152 1
a1152 1
comsoft(arg)
d1217 1
a1217 1
	timeout_add(&sc->sc_comsoft_tmo, 1);
a1465 2
#elif defined(__pegasos__)
	bus_space_tag_t iot = MD_ISA_IOT;
@


1.55.2.8
log
@Merge with the trunk
@
text
@d1463 2
a1498 1
#if defined(COMCONSOLE) || defined(PCCOMCONSOLE) || !defined(__amd64__)
a1499 3
#else
	cp->cn_pri = CN_NORMAL;
#endif
@


1.54
log
@a few ifdef accomodations for hppa, also a few knf spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.53 1999/11/28 12:26:05 downsj Exp $	*/
a93 2
#include <dev/isa/isavar.h>	/* XXX */

d104 4
d382 4
a385 1
	int iobase, irq;
d597 1
d610 1
a610 1

@


1.53
log
@Enable TI16750 UART support.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.52 1999/11/09 04:00:08 rahnds Exp $	*/
d409 1
a409 1
	       		if (iobase != comconsaddr) {
d789 2
a790 2
			     FIFO_DMA_MODE|FIFO_ENABLE|
			     FIFO_RCV_RST|FIFO_XMT_RST|FIFO_TRIGGER_8);
d795 2
a796 2
			     HAYESP_MODE_FIFO|HAYESP_MODE_RTS|
			     HAYESP_MODE_SCALE);
d806 1
a806 1
			     HAYESP_HIBYTE(HAYESP_RXHIWMARK));
d808 1
a808 1
			     HAYESP_LOBYTE(HAYESP_RXHIWMARK));
d810 1
a810 1
			     HAYESP_HIBYTE(HAYESP_RXLOWMARK));
d812 1
a812 1
			     HAYESP_LOBYTE(HAYESP_RXLOWMARK));
d895 1
a895 1
			       (!ISSET(tp->t_cflag, CLOCAL) &&
d1672 1
a1672 1
#ifdef arc
d1682 1
a1682 1
#ifdef arc
d1684 1
a1684 2
#else
#ifdef powerpc
d1686 2
d1689 1
a1689 2
        bus_space_tag_t iot = 0;
#endif   
@


1.52
log
@in the ifdef POWERPC section, do use ppc, not p4e, for the iohandle
for the console configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.51 1999/10/26 12:27:39 downsj Exp $	*/
a511 1
#ifdef notyet
d517 1
d520 1
a524 1
#endif
@


1.51
log
@This file has my code in it, attach my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.50 1999/08/08 16:28:17 niklas Exp $	*/
d1686 1
a1686 1
	bus_space_tag_t iot = &p4e_isa_io;
@


1.50
log
@pasto from pccom.c
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.49 1999/08/08 15:08:24 niklas Exp $	*/
d4 27
@


1.49
log
@revert function accidentally committed
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.48 1999/08/08 01:34:14 niklas Exp $	*/
a630 3
	/* Free the receive buffer. */
	free(sc->sc_rbuf, M_DEVBUF);

d652 1
a652 1
	s = splserial();
d659 1
a659 1
		if (sc->sc_hwflags & (COM_HW_CONSOLE|COM_HW_KGDB)) {
@


1.48
log
@Detach support for com; NetBSD and me
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.47 1999/07/26 15:27:22 niklas Exp $	*/
a675 17

#if defined(DDB) || defined(KGDB)
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	sc->sc_ier = IER_ERXRDY;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);
	splx(s);
}
#endif
@


1.47
log
@Move over the ISA PnP support from pccom.c to com.c
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.46 1999/07/26 15:09:00 niklas Exp $	*/
d59 1
d601 7
d609 84
@


1.46
log
@fix my last commit where I committed more than intended
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.44 1999/06/25 17:59:23 rees Exp $	*/
d99 6
d150 15
a287 4
#if NCOM_ISA
#define IS_ISA(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa")
#endif
d293 2
a294 2
#if NCOM_ISA
	if (IS_ISA(parent)) {
d299 5
a303 1
		needioh = 1;
d368 2
a369 2
#if NCOM_ISA
	if (IS_ISA(parent)) {
d377 11
a387 5
	        if (iobase != comconsaddr) {
	                if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
				panic("comattach: io mapping failed");
		} else
	                ioh = comconsioh;
d565 2
a566 2
#if NCOM_ISA
		if (IS_ISA(parent)) {
@


1.45
log
@Remove obsolete detach code that has been dead for very long
@
text
@a98 6
#if NCOM_ISAPNP
struct cfattach com_isapnp_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

a120 1
int	comconsrate;
d130 5
a134 10
#include <sys/kgdb.h>

static int com_kgdb_addr;
static bus_space_tag_t com_kgdb_iot;
static bus_space_handle_t com_kgdb_ioh;
static int com_kgdb_attached;

int	com_kgdb_getc __P((void *));
void	com_kgdb_putc __P((void *, int));
#endif /* KGDB */
d145 2
a146 2
comspeed(speed, frequency)
	long speed, frequency;
a151 1
#if 0
d154 1
a154 2
#endif
	if (speed <= 0)
d156 1
a156 1
	x = divrnd((frequency / 16), speed);
d159 1
a159 1
	err = divrnd((frequency / 16) * 1000, speed * x) - 1000;
a346 1
	sc->sc_frequency = COM_FREQ;
d551 16
a566 10
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */
	if (iot == com_kgdb_iot && iobase == com_kgdb_addr &&
	    !ISSET(sc->sc_hwflags, COM_HW_CONSOLE)) {
		com_kgdb_attached = 1;

		SET(sc->sc_hwflags, COM_HW_KGDB);
		printf("%s: kgdb\n", sc->sc_dev.dv_xname);
a572 14

#ifdef DDB
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
		com_enable_debugport(sc);
#endif

#ifdef KGDB
	/*
	 * Allow kgdb to "take over" this port.  If this is
	 * the kgdb device, it has exclusive use.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		com_enable_debugport(sc);
#endif
a574 17
#if defined(DDB) || defined(KGDB)
void
com_enable_debugport(sc)
	struct com_softc *sc;
{
	int s;

	/* Turn on line break interrupt, set carrier. */
	s = splhigh();
	sc->sc_ier = IER_ERXRDY;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_ier, sc->sc_ier);
	SET(sc->sc_mcr, MCR_DTR | MCR_RTS);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, com_mcr, sc->sc_mcr);
	splx(s);
}
#endif

a594 8
#ifdef KGDB
	/*
	 * If this is the kgdb port, no other use is permitted.
	 */
	if (ISSET(sc->sc_hwflags, COM_HW_KGDB))
		return (EBUSY);
#endif

a1055 31
u_char
com_cflag2lcr(cflag)
	tcflag_t cflag;
{
	u_char lcr = 0;

	switch (ISSET(cflag, CSIZE)) {
	case CS5:
		SET(lcr, LCR_5BITS);
		break;
	case CS6:
		SET(lcr, LCR_6BITS);
		break;
	case CS7:
		SET(lcr, LCR_7BITS);
		break;
	case CS8:
		SET(lcr, LCR_8BITS);
		break;
	}
	if (ISSET(cflag, PARENB)) {
		SET(lcr, LCR_PENAB);
		if (!ISSET(cflag, PARODD))
			SET(lcr, LCR_PEVEN);
	}
	if (ISSET(cflag, CSTOPB))
		SET(lcr, LCR_STOPB);

	return (lcr);
}

d1064 1
a1064 1
	int ospeed = comspeed(t->c_ospeed, sc->sc_frequency);
a1438 7
#ifdef KGDB
					if (ISSET(sc->sc_hwflags,
					    COM_HW_KGDB)) {
						kgdb_connect(1);
						goto next;
					}
#endif
d1455 1
a1455 1
#if defined(DDB) || defined(KGDB)
a1598 57
/*
 * The following functions are polled getc and putc routines, shared
 * by the console and kgdb glue.
 */

int
com_common_getc(iot, ioh)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
{
	int s = splhigh();
	u_char stat, c;

	/* block until a character becomes available */
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		;

	c = bus_space_read_1(iot, ioh, com_data);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return (c);
}

void
com_common_putc(iot, ioh, c)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int c;
{
	int s = splhigh();
	u_char stat;
	int timo;

	/* wait for any pending transmission to finish */
	timo = 50000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY)
	    && --timo)
		;

	bus_space_write_1(iot, ioh, com_data, c);
	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY)
	    && --timo)
		;

#if 0 /* I don't think sooooo (pefo) */
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
#endif
	splx(s);
}

/*
 * Following are all routines needed for COM to act as console
 */

d1604 1
a1604 2
	if (cominit(comconsiot, CONADDR, comdefaultrate, COM_FREQ,
	    comconscflag, &comconsioh))
d1607 1
d1612 2
a1613 5
/*
 * Initialize UART to known state.
 */
int
cominit(iot, iobase, rate, frequency, cflag, iohp)
d1615 2
a1616 4
	int iobase;
	int rate, frequency;
	tcflag_t cflag;
	bus_space_handle_t *iohp;
d1618 2
a1619 4
	bus_space_handle_t ioh;

	if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
		return (ENOMEM); /* ??? */
a1620 2
	bus_space_write_1(iot, ioh, com_lcr, LCR_EERS);
	bus_space_write_1(iot, ioh, com_efr, 0);
d1622 1
a1622 1
	rate = comspeed(rate, frequency);
d1625 5
a1629 8
	bus_space_write_1(iot, ioh, com_lcr, com_cflag2lcr(cflag));
	bus_space_write_1(iot, ioh, com_mcr, 0);
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_1);
	bus_space_write_1(iot, ioh, com_ier, 0);

	*iohp = ioh;
	return (0);
d1636 11
a1646 1
	return (com_common_getc(comconsiot, comconsioh));
d1657 27
a1683 1
	com_common_putc(comconsiot, comconsioh, c);
a1691 74
}

#ifdef KGDB
int
com_kgdb_attach(iot, iobase, rate, frequency, cflag)
	bus_space_tag_t iot;
	int iobase;
	int rate, frequency;
	tcflag_t cflag;
{
	int res;

	if (iot == comconsiot && iobase == comconsaddr)
		return (EBUSY); /* cannot share with console */

	res = cominit(iot, iobase, rate, frequency, cflag, &com_kgdb_ioh);
	if (res)
		return (res);

	kgdb_attach(com_kgdb_getc, com_kgdb_putc, NULL);
	kgdb_dev = 123; /* unneeded, only to satisfy some tests */

	com_kgdb_iot = iot;
	com_kgdb_addr = iobase;

	return (0);
}

/* ARGSUSED */
int
com_kgdb_getc(arg)
	void *arg;
{

	return (com_common_getc(com_kgdb_iot, com_kgdb_ioh));
}

/* ARGSUSED */
void
com_kgdb_putc(arg, c)
	void *arg;
	int c;
{

	return (com_common_putc(com_kgdb_iot, com_kgdb_ioh, c));
}
#endif /* KGDB */

/*
 * Helper function to identify the com ports used by
 * console or KGDB (and not yet autoconf attached)
 */
int
com_is_console(iot, iobase, ioh)
	bus_space_tag_t iot;
	int iobase;
	bus_space_handle_t *ioh;
{
	bus_space_handle_t help;

	if (!comconsattached &&
	    iot == comconsiot && iobase == comconsaddr)
		help = comconsioh;
#ifdef KGDB
	else if (!com_kgdb_attached &&
	    iot == com_kgdb_iot && iobase == com_kgdb_addr)
		help = com_kgdb_ioh;
#endif
	else
		return (0);

	if (ioh)
		*ioh = help;
	return (1);
@


1.44
log
@Don't turn off uart when closing cua device if tty is waiting.
Instead just drop dtr briefly.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.43 1999/02/09 02:39:43 rees Exp $	*/
a89 1
void	comstart_pending __P((void *));
d99 6
d127 1
d137 10
a146 5
#include <machine/remote-sl.h>
extern int kgdb_dev;
extern int kgdb_rate;
extern int kgdb_debug_init;
#endif
a155 15
/*
 * must be called at spltty() or higher.
 */
void
com_absent_notify(sc)
	struct com_softc *sc;
{
	struct tty *tp = sc->sc_tty;

	if (tp) {
		CLR(tp->t_state, TS_CARR_ON|TS_BUSY);
		ttyflush(tp, FREAD|FWRITE);
	}
}

d157 2
a158 2
comspeed(speed)
	long speed;
d164 1
d167 2
a168 1
	if (speed < 0)
d170 1
a170 1
	x = divrnd((COM_FREQ / 16), speed);
d173 1
a173 1
	err = divrnd((COM_FREQ / 16) * 1000, speed * x) - 1000;
d359 1
a359 7
	if (ISSET(sc->sc_hwflags, COM_HW_REATTACH)) {
		int s;
		s = spltty();
		com_absent_notify(sc);
		splx(s);
	} else
	    sc->sc_hwflags = 0;
d361 1
d566 10
a575 16
	if (kgdb_dev == makedev(commajor, unit)) {
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			kgdb_dev = -1;	/* can't debug over console port */
		else {
			cominit(iot, ioh, kgdb_rate);
			if (kgdb_debug_init) {
				/*
				 * Print prefix of device name,
				 * let kgdb_connect print the rest.
				 */
				printf("%s: ", sc->sc_dev.dv_xname);
				kgdb_connect(1);
			} else
				printf("%s: kgdb enabled\n",
				    sc->sc_dev.dv_xname);
		}
d582 30
d613 1
d632 1
a632 1
	if (!sc || ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING))
d635 8
d860 8
a867 10
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		if (ISSET(tp->t_state, TS_WOPEN)) {
			/* tty device is waiting for carrier; drop dtr then re-raise */
			CLR(sc->sc_mcr, MCR_DTR | MCR_RTS);
			bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
			timeout(com_raisedtr, sc, hz * 2);
		} else {
			/* no one else waiting; turn off the uart */
			compwroff(sc);
		}
a874 7
#ifdef COM_DEBUG
	/* mark it ready for more use if reattached earlier */
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT_PENDING)) {
	    printf("comclose pending cleared\n");
	}
#endif
	CLR(sc->sc_hwflags, COM_HW_ABSENT_PENDING);
a945 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a957 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a998 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

d1104 31
d1143 1
a1143 1
	int ospeed = comspeed(t->c_ospeed);
a1147 7
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		int s = spltty();
		com_absent_notify(sc);
		splx(s);
		return EIO;
	}

a1282 12
comstart_pending(arg)
	void *arg;
{
	struct com_softc *sc = arg;
	int s;

	s = spltty();
	com_absent_notify(sc);
	splx(s);
}

void
a1291 10
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		/*
		 * not quite good enough: if caller is ttywait() it will
		 * go to sleep immediately, so hang out a bit and then
		 * prod caller again.
		 */
		com_absent_notify(sc);
		timeout(comstart_pending, sc, 1);
		goto out;
	}
d1477 1
a1477 1
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT) || !sc->sc_tty)
d1518 7
d1541 1
a1541 1
#ifdef DDB
d1685 57
d1747 2
a1748 1
	if (bus_space_map(comconsiot, CONADDR, COM_NPORTS, 0, &comconsioh))
a1750 1
	cominit(comconsiot, comconsioh, comdefaultrate);
d1755 5
a1759 2
void
cominit(iot, ioh, rate)
d1761 5
a1766 4
	int rate;
{
	int s = splhigh();
	u_char stat;
d1768 5
d1774 1
a1774 1
	rate = comspeed(comdefaultrate);
d1777 8
a1784 5
	bus_space_write_1(iot, ioh, com_lcr, LCR_8BITS);
	bus_space_write_1(iot, ioh, com_ier, IER_ERXRDY | IER_ETXRDY);
	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
d1791 1
a1791 11
	int s = splhigh();
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;
	u_char stat, c;

	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_RXRDY))
		;
	c = bus_space_read_1(iot, ioh, com_data);
	stat = bus_space_read_1(iot, ioh, com_iir);
	splx(s);
	return c;
d1802 1
a1802 27
	int s = splhigh();
	bus_space_tag_t iot = comconsiot;
	bus_space_handle_t ioh = comconsioh;
	u_char stat;
	register int timo;

#ifdef KGDB
	if (dev != kgdb_dev)
#endif
	if (comconsinit == 0) {
		cominit(iot, ioh, comdefaultrate);
		comconsinit = 1;
	}
	/* wait for any pending transmission to finish */
	timo = 50000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
	bus_space_write_1(iot, ioh, com_data, c);
	/* wait for this transmission to complete */
	timo = 1500000;
	while (!ISSET(stat = bus_space_read_1(iot, ioh, com_lsr), LSR_TXRDY) && --timo)
		;
#if 0 /* I don't think sooooo (pefo) */
	/* clear any interrupts generated by this transmission */
	stat = bus_space_read_1(iot, ioh, com_iir);
#endif
	splx(s);
d1811 74
@


1.43
log
@Fix cua device to not block on open.
Turn off chip (and dtr) on interrupted open.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.42 1999/01/11 05:12:16 millert Exp $	*/
d92 1
d794 7
a800 3
				error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
						 ttopen, 0);
				if (error) {
d823 2
d834 11
a844 2
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING))
		compwroff(sc);
d882 2
a883 1
		bus_space_write_1(iot, ioh, com_mcr, 0);
d908 10
@


1.42
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.41 1998/09/20 21:41:27 rahnds Exp $	*/
d91 1
a779 9
	}

	/* wait for carrier if necessary */
	if (ISSET(flag, O_NONBLOCK)) {
		if (!DEVCUA(dev) && sc->sc_cua) {
			/* Opening TTY non-blocking... but the CUA is busy */
			splx(s);
			return EBUSY;
		}
d781 4
a784 14
		while (sc->sc_cua ||
		    (!ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON))) {
			SET(tp->t_state, TS_WOPEN);
			error = ttysleep(tp, &tp->t_rawq, TTIPRI | PCATCH,
			    ttopen, 0);
			if (!DEVCUA(dev) && sc->sc_cua && error == EINTR)
				continue;
			if (error) {
				/* XXX should turn off chip if we're the
				   only waiter */
				if (DEVCUA(dev))
					sc->sc_cua = 0;
				CLR(tp->t_state, TS_WOPEN);
d786 16
a801 1
				return error;
a802 2
			if (!DEVCUA(dev) && sc->sc_cua)
				continue;
a818 2
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
d827 2
a828 34
	if (!ISSET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING)) {
		/* can't do any of this stuff .... */
		CLR(sc->sc_lcr, LCR_SBREAK);
		bus_space_write_1(iot, ioh, com_lcr, sc->sc_lcr);
		bus_space_write_1(iot, ioh, com_ier, 0);
		if (ISSET(tp->t_cflag, HUPCL) &&
		    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
			/* XXX perhaps only clear DTR */
			bus_space_write_1(iot, ioh, com_mcr, 0);
		}

		/*
		 * Turn FIFO off; enter sleep mode if possible.
		 */
		bus_space_write_1(iot, ioh, com_fifo, 0);
		delay(100);
		(void) bus_space_read_1(iot, ioh, com_data);
		delay(100);
		bus_space_write_1(iot, ioh, com_fifo,
		    FIFO_RCV_RST | FIFO_XMT_RST);

		switch (sc->sc_uarttype) {
		case COM_UART_ST16650:
		case COM_UART_ST16650V2:
			bus_space_write_1(iot, ioh, com_lcr, 0xbf);
			bus_space_write_1(iot, ioh, com_efr, EFR_ECB);
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			bus_space_write_1(iot, ioh, com_lcr, 0);
			break;
		case COM_UART_TI16750:
			bus_space_write_1(iot, ioh, com_ier, IER_SLEEP);
			break;
		}
	}
d851 42
a892 1
 
@


1.41
log
@Powerpc port uses com.c not just power4e.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.40 1998/08/18 08:52:13 pefo Exp $	*/
d542 1
a542 1
		panic("comattach: bad fifo type\n");
@


1.40
log
@Remove clearing of interrupt after character output in cnputci(). Clearing
the int will make the tty stop if output is currently active.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.39 1998/08/07 16:48:14 pefo Exp $	*/
d1611 1
a1611 1
#ifdef power4e
@


1.39
log
@com.c needs to know about mem mapped ports in ppc systems.

ncr.c and if_de.c needs some hooks for systems with ncr and dec
ether chips on the motherboard that runs on odd clocks and doesn't
support a srom. srom is emulated in machine dependent code.

big endian support for ncr and dec ether finished. the 21040
have some more coding requirements if it is to run BE since
it does not have the descriptor endian swap configuration bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.38 1998/02/23 11:41:24 downsj Exp $	*/
d1731 1
d1734 1
@


1.38
log
@New probe routine and support for ST16650.

Compiles, but completely untested.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.37 1998/02/05 16:49:24 deraadt Exp $	*/
d1611 5
a1615 1
	bus_space_tag_t iot = 0;
@


1.37
log
@rename ddb.panic_ddb, and add ddb.console. Now you can stop console ddb entry
with a sysctl. There will be architectures and drivers that lack function,
and I trust the maintainers of those will forget to add the code..
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.36 1997/09/03 20:55:28 deraadt Exp $	*/
d352 1
d430 1
d439 10
a448 3
	/* look for a NS 16550AF UART with FIFOs */
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_14);
d450 98
a547 10
	if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_FIFO_MASK) ==
	    IIR_FIFO_MASK)
		if (ISSET(bus_space_read_1(iot, ioh, com_fifo), FIFO_TRIGGER_14) ==
		    FIFO_TRIGGER_14) {
			SET(sc->sc_hwflags, COM_HW_FIFO);
			printf(": ns16550a, working fifo\n");
		} else
			printf(": ns16550, broken fifo\n");
	else
		printf(": ns8250 or ns16450, no fifo\n");
d659 18
d710 14
d739 2
a740 4
				bus_space_write_1(iot, ioh, com_fifo,
				    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST |
				    (tp->t_ispeed <= 1200 ?
				    FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
d746 2
d844 23
d1148 1
a1148 1
			 * even if we do this will the last character is
d1176 13
a1188 4
		    ISSET(sc->sc_hwflags, COM_HW_FIFO))
			bus_space_write_1(iot, ioh, com_fifo,
			    FIFO_ENABLE |
			    (t->c_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
d1267 1
a1267 2
	if (ISSET(tp->t_state, TS_TIMEOUT | TS_TTSTOP) ||
	    sc->sc_halt > 0)
d1286 1
d1288 3
a1290 8
	if (ISSET(sc->sc_hwflags, COM_HW_HAYESP)) {
		u_char buffer[1024], *cp = buffer;
		int n = q_to_b(&tp->t_outq, cp, sizeof buffer);
		do
			bus_space_write_1(iot, ioh, com_data, *cp++);
		while (--n);
	}
	else
d1292 2
a1293 3
	if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
		u_char buffer[16], *cp = buffer;
		int n = q_to_b(&tp->t_outq, cp, sizeof buffer);
d1451 1
a1451 1
		return 0;		/* can't do squat. */
@


1.36
log
@fix cua/tty locking
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.35 1997/07/07 16:37:12 niklas Exp $	*/
d59 3
d1330 2
a1331 1
						Debugger();
@


1.35
log
@Removed an unused arg
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.34 1997/04/10 17:16:37 pefo Exp $	*/
d657 3
a659 3
		while (!(DEVCUA(dev) && sc->sc_cua) &&
		    !ISSET(tp->t_cflag, CLOCAL) &&
		    !ISSET(tp->t_state, TS_CARR_ON)) {
d663 2
d674 2
@


1.34
log
@Need to separate i/o and mem on mips
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.33 1997/03/17 08:11:11 pefo Exp $	*/
d181 1
a181 1
comprobe1(iot, ioh, iobase)
a183 1
	int iobase;
d320 1
a320 1
	rv = comprobe1(iot, ioh, iobase);
d1463 1
a1463 1
	found = comprobe1(iot, ioh, CONADDR);
@


1.33
log
@Serial console trouble again...
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.32 1997/03/12 20:17:37 pefo Exp $	*/
d1436 1
a1436 1
#if NCOM_LOCALBUS
d1447 1
a1447 1
	bus_space_tag_t iot = &arc_bus;
@


1.32
log
@The stupid "use console before configured" scheeme strikes again :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.31 1997/03/06 07:07:43 tholo Exp $	*/
d1436 1
a1436 3
#if NCOM_PICA
#include <arc/arc/arctype.h>
	extern int cputype;
d1453 5
@


1.31
log
@Initial implementation of support for calling hardpps() on carrier enable
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.30 1996/12/10 22:28:28 deraadt Exp $	*/
d1436 7
d1448 3
d1452 1
a1454 8
#if NCOM_PICA
	/* XXX */
#include <arc/arc/arctype.h>
	extern int cputype;

	if(cputype != ACER_PICA_61)
		return;
#endif
d1456 1
a1486 4
#if 0
	XXX NEEDS TO BE FIXED XXX
	comconsiot = ???;
#endif
@


1.30
log
@the real changes by niklas... I did not merge correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.2 1996/12/03 11:08:31 deraadt Exp $	*/
d885 2
d908 2
d1278 4
d1371 19
a1389 5
			if (ISSET(delta, MSR_DCD) &&
			    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR) &&
			    (*linesw[tp->t_line].l_modem)(tp, ISSET(msr, MSR_DCD)) == 0) {
				CLR(sc->sc_mcr, sc->sc_dtr);
				bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);
@


1.29
log
@clr TS_WOPEN if bailing on cua opens
As well, at this point I've also done fancy cvs repository mangling to
ensure that the com* files in sys/dev/ic maintain the history we had
before. (Yes, I cleaned up the 2.0 tags too..)
@
text
@d1 1
a1 1
/*	$OpenBSD: kom.c,v 1.28 1996/11/29 22:54:52 niklas Exp $	*/
d63 4
a66 3
#include <dev/isa/isavar.h>
#include <dev/isa/comreg.h>
#include <dev/isa/comvar.h>
a74 58

#define	COM_IBUFSIZE	(2 * 512)
#define	COM_IHIGHWATER	((3 * COM_IBUFSIZE) / 4)

struct com_softc {
	struct device sc_dev;
	void *sc_ih;
	bus_space_tag_t sc_iot;
	struct tty *sc_tty;

	int sc_overflows;
	int sc_floods;
	int sc_errors;

	int sc_halt;

	int sc_iobase;
#ifdef COM_HAYESP
	int sc_hayespbase;
#endif

	bus_space_handle_t sc_ioh;
	bus_space_handle_t sc_hayespioh;
	isa_chipset_tag_t sc_ic;

	u_char sc_hwflags;
#define	COM_HW_NOIEN	0x01
#define	COM_HW_FIFO	0x02
#define	COM_HW_HAYESP	0x04
#define	COM_HW_ABSENT_PENDING	0x08	/* reattached, awaiting close/reopen */
#define	COM_HW_ABSENT	0x10		/* configure actually failed, or removed */
#define	COM_HW_REATTACH	0x20		/* reattaching */
#define	COM_HW_CONSOLE	0x40
	u_char sc_swflags;
#define	COM_SW_SOFTCAR	0x01
#define	COM_SW_CLOCAL	0x02
#define	COM_SW_CRTSCTS	0x04
#define	COM_SW_MDMBUF	0x08
	u_char sc_msr, sc_mcr, sc_lcr, sc_ier;
	u_char sc_dtr;

	u_char	sc_cua;

	u_char	sc_initialize;		/* force initialization */

	u_char *sc_ibuf, *sc_ibufp, *sc_ibufhigh, *sc_ibufend;
	u_char sc_ibufs[2][COM_IBUFSIZE];
};

#ifdef COM_HAYESP
int comprobeHAYESP __P((bus_space_handle_t hayespioh, struct com_softc *sc));
#endif
void	comdiag		__P((void *));
int	comspeed	__P((long));
int	comparam	__P((struct tty *, struct termios *));
void	comstart	__P((struct tty *));
void	compoll		__P((void *));

a78 7
struct consdev;
void	comcnprobe	__P((struct consdev *));
void	comcninit	__P((struct consdev *));
int	comcngetc	__P((dev_t));
void	comcnputc	__P((dev_t, int));
void	comcnpollc	__P((dev_t, int));

a86 1
void	com_absent_notify __P((struct com_softc *sc));
a100 9
#if NCOM_PICA
#undef  CONADDR         /* This is stupid but using devs before config .. */
#define CONADDR 0xe0006000

struct cfattach com_pica_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif

a139 179
#if NCOM_PCMCIA
#include <dev/pcmcia/pcmciavar.h>

int	com_pcmcia_match __P((struct device *, void *, void *));
void	com_pcmcia_attach __P((struct device *, struct device *, void *));
int	com_pcmcia_detach __P((struct device *));

struct cfattach com_pcmcia_ca = {
	sizeof(struct com_softc), com_pcmcia_match, comattach,
	com_pcmcia_detach
};

int	com_pcmcia_mod __P((struct pcmcia_link *pc_link, struct device *self,
	    struct pcmcia_conf *pc_cf, struct cfdata *cf));

/* additional setup needed for pcmcia devices */
/* modify config entry */
int 
com_pcmcia_mod(pc_link, self, pc_cf, cf)
    struct pcmcia_link *pc_link;
    struct device *self;
    struct pcmcia_conf *pc_cf; 
    struct cfdata *cf;
{               
	int err; 

	if (!(err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,
	    pc_cf, cf))) {
		pc_cf->memwin = 0;
		if (pc_cf->cfgtype == 0) 
		pc_cf->cfgtype = CFGENTRYID; /* determine from ioaddr */
	}
	return err;
}

int com_pcmcia_isa_attach __P((struct device *, void *, void *,
			       struct pcmcia_link *));
int com_pcmcia_remove __P((struct pcmcia_link *, struct device *));

static struct pcmcia_com {
	struct pcmcia_device pcd;
} pcmcia_com =  {
	{"PCMCIA Modem card", com_pcmcia_mod, com_pcmcia_isa_attach,
	 NULL, com_pcmcia_remove}
};          


struct pcmciadevs pcmcia_com_devs[] = {
	{ "com", 0,
	NULL, "*MODEM*", NULL, NULL,
	NULL, (void *)&pcmcia_com 
	},
	{ "com", 0,
	NULL, NULL, "*MODEM*", NULL,
	NULL, (void *)&pcmcia_com 
	},
	{ "com", 0,
	NULL, NULL, NULL, "*MODEM*",
	NULL, (void *)&pcmcia_com 
	},
	{NULL}
};
#define ncom_pcmcia_devs sizeof(pcmcia_com_devs)/sizeof(pcmcia_com_devs[0])

int
com_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return pcmcia_slave_match(parent, match, aux, pcmcia_com_devs,
	    ncom_pcmcia_devs);
}

int
com_pcmcia_isa_attach(parent, match, aux, pc_link)
	struct device *parent;
	void *match;
	void *aux;
	struct pcmcia_link *pc_link;
{
	struct isa_attach_args *ia = aux;
	struct com_softc *sc = match;
	int rval;

	if ((rval = comprobe(parent, sc->sc_dev.dv_cfdata, ia))) {
		if (ISSET(pc_link->flags, PCMCIA_REATTACH)) {
#ifdef COM_DEBUG
			printf("comreattach, hwflags=%x\n", sc->sc_hwflags);
#endif
			sc->sc_hwflags = COM_HW_REATTACH |
				(sc->sc_hwflags & (COM_HW_ABSENT_PENDING|COM_HW_CONSOLE));
		} else
			sc->sc_hwflags = 0;
		sc->sc_ic = ia->ia_ic;
	}
	return rval;
}


/*
 * Called by config_detach attempts, shortly after com_pcmcia_remove
 * was called.
 */
int
com_pcmcia_detach(self)
	struct device *self;
{
	struct com_softc *sc = (void *)self;

	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT_PENDING)) {
		/* don't let it really be detached, it is still open */
		return EBUSY;
	}
	return 0;		/* OK! */
}

/*
 * called by pcmcia framework to accept/reject remove attempts.
 * If we return 0, then the detach will proceed.
 */
int
com_pcmcia_remove(pc_link, self)
	struct pcmcia_link *pc_link;
	struct device *self;
{
	struct com_softc *sc = (void *)self;
	struct tty *tp;
	int s;

	if (!sc->sc_tty)
		goto ok;
	tp = sc->sc_tty;

	/* not in use ?  if so, return "OK" */
	if (!ISSET(tp->t_state, TS_ISOPEN) &&
	    !ISSET(tp->t_state, TS_WOPEN)) {
		ttyfree(sc->sc_tty);
		sc->sc_tty = NULL;
    ok:
		isa_intr_disestablish(sc->sc_ic, sc->sc_ih);
		sc->sc_ih = NULL;
		SET(sc->sc_hwflags, COM_HW_ABSENT);
		return 0;		/* OK! */
	}
	/*
	 * Not easily removed.  Put device into a dead state, clean state
	 * as best we can.  notify all waiters.
	 */
	SET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING);
#ifdef COM_DEBUG
	printf("pending detach flags %x\n", sc->sc_hwflags);
#endif

	s = spltty();
	com_absent_notify(sc);
	splx(s);

	return 0;
}

#if 0
void
com_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcmcia_attach_args *paa = aux;
	
	printf("com_pcmcia_attach %p %p %p\n", parent, self, aux);
	delay(2000000);
	if (!pcmcia_configure(parent, self, paa->paa_link)) {
		struct com_softc *sc = (void *)self;
		sc->sc_hwflags |= COM_HW_ABSENT;
		printf(": not attached\n");
	}
}
#endif
#endif

d279 1
a279 5
#if NCOM_ISA || NCOM_PCMCIA
#define IS_ISA(parent) \
	(!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isa") || \
	 !strcmp((parent)->dv_cfdata->cf_driver->cd_name, "pcmcia"))
#elif NCOM_ISA
a282 4
#if NCOM_PICA
#define IS_PICA(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "pica")
#endif
d288 1
a288 1
#if NCOM_ISA || NCOM_PCMCIA
a310 10
#if NCOM_PICA
	if(IS_PICA(parent)) {
		struct confargs *ca = aux;
		if(!BUS_MATCHNAME(ca, "com"))
			return(0);
		iobase = (long)BUS_CVTADDR(ca);
		iot = 0;
		needioh = 1;
	} else
#endif
d326 1
a326 1
#if NCOM_ISA || NCOM_PCMCIA
d364 1
a364 1
#if NCOM_ISA || NCOM_PCMCIA
a396 9
#if NCOM_PICA
	if(IS_PICA(parent)) {
		struct confargs *ca = aux;
		iobase = (long)BUS_CVTADDR(ca);
		iot = 0;
		irq = 0;
		ioh = iobase;
	} else
#endif
d459 1
a459 1
#if NCOM_ISA || NCOM_PCMCIA
a465 6
		} else
#endif
#if NCOM_PICA
		if (IS_PICA(parent)) {
			struct confargs *ca = aux;
			BUS_INTR_ESTABLISH(ca, comintr, (void *)(long)sc);
@


1.28
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.27 1996/11/12 20:30:27 niklas Exp $	*/
d955 1
@


1.27
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.26 1996/11/09 21:50:43 tholo Exp $	*/
d60 1
a60 1
#include <machine/bus.old.h>
d81 1
a81 1
	bus_chipset_tag_t sc_bc;
d95 3
a97 2
	bus_io_handle_t sc_ioh;
	bus_io_handle_t sc_hayespioh;
d124 1
a124 1
int comprobeHAYESP __P((bus_io_handle_t hayespioh, struct com_softc *sc));
d166 9
d191 2
a192 2
bus_chipset_tag_t comconsbc;
bus_io_handle_t comconsioh;
d307 1
d353 1
a353 1
		isa_intr_disestablish(sc->sc_bc, sc->sc_ih);
d434 3
a436 3
comprobe1(bc, ioh, iobase)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d442 2
a443 2
	bus_io_write_1(bc, ioh, com_lcr, 0);
	bus_io_write_1(bc, ioh, com_iir, 0);
d445 1
a445 1
	    k = bus_io_read_1(bc, ioh, com_iir);
d447 1
a447 1
		bus_io_read_1(bc, ioh, com_data); /* cleanup */
d460 1
a460 1
	bus_io_handle_t hayespioh;
d465 1
a465 1
	bus_chipset_tag_t bc = sc->sc_bc;
d475 1
a475 1
	if ((bus_io_read_1(bc, hayespioh, 0) & 0xf3) == 0)
d483 2
a484 2
	bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_GETDIPS);
	dips = bus_io_read_1(bc, hayespioh, HAYESP_STATUS1);
d495 3
a497 3
	bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_GETTEST);
	val = bus_io_read_1(bc, hayespioh, HAYESP_STATUS1); /* Clear reg 1 */
	val = bus_io_read_1(bc, hayespioh, HAYESP_STATUS2);
d527 2
a528 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d540 4
d553 1
a553 1
		bc = ia->ia_bc;
d566 1
a566 1
		bc = ca->ca_bc;
d572 10
d588 1
a588 1
	if (needioh && bus_io_map(bc, iobase, COM_NPORTS, &ioh)) {
d592 1
a592 1
	rv = comprobe1(bc, ioh, iobase);
d594 1
a594 1
		bus_io_unmap(bc, ioh, COM_NPORTS);
d615 2
a616 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d643 1
a643 1
		bc = ia->ia_bc;
d645 1
a645 1
	                if (bus_io_map(bc, iobase, COM_NPORTS, &ioh))
d660 1
a660 1
		bc = ca->ca_bc;
d668 9
d679 1
a679 1
	sc->sc_bc = bc;
d699 1
a699 1
		bus_io_handle_t hayespioh;
d702 1
a702 1
		if (bus_io_map(bc, *hayespp, HAYESP_NPORTS, &hayespioh))
d709 1
a709 1
		bus_io_unmap(bc, hayespioh, HAYESP_NPORTS);
d716 1
a716 1
	bus_io_write_1(bc, ioh, com_fifo,
d719 1
a719 1
	if (ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_FIFO_MASK) ==
d721 1
a721 1
		if (ISSET(bus_io_read_1(bc, ioh, com_fifo), FIFO_TRIGGER_14) ==
d729 1
a729 1
	bus_io_write_1(bc, ioh, com_fifo, 0);
d735 2
a736 2
	bus_io_write_1(bc, ioh, com_ier, 0);
	bus_io_write_1(bc, ioh, com_mcr, 0);
d748 6
d762 1
a762 1
			cominit(bc, ioh, kgdb_rate);
d790 2
a791 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d844 1
a844 1
		bc = sc->sc_bc;
d849 1
a849 1
			bus_io_handle_t hayespioh = sc->sc_hayespioh;
d851 1
a851 1
			bus_io_write_1(bc, ioh, com_fifo,
d856 2
a857 2
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETMODE);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, 
d862 3
a864 3
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETFLOWTYPE);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, HAYESP_FLOW_RTS);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, HAYESP_FLOW_CTS);
d867 2
a868 2
			bus_io_write_1(bc, hayespioh, HAYESP_CMD1, HAYESP_SETRXFLOW);
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2, 
d870 1
a870 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d872 1
a872 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d874 1
a874 1
			bus_io_write_1(bc, hayespioh, HAYESP_CMD2,
d891 1
a891 1
			 	bus_io_write_1(bc, ioh, com_fifo, 0);
d893 2
a894 2
				(void) bus_io_read_1(bc, ioh, com_data);
				bus_io_write_1(bc, ioh, com_fifo,
d899 1
a899 1
				if(!ISSET(bus_io_read_1(bc, ioh,
d906 2
a907 2
		while (ISSET(bus_io_read_1(bc, ioh, com_lsr), LSR_RXRDY))
			(void) bus_io_read_1(bc, ioh, com_data);
d912 1
a912 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d914 1
a914 1
		bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d916 1
a916 1
		sc->sc_msr = bus_io_read_1(bc, ioh, com_msr);
d974 2
a975 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d987 2
a988 2
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
		bus_io_write_1(bc, ioh, com_ier, 0);
d992 1
a992 1
			bus_io_write_1(bc, ioh, com_mcr, 0);
d1090 2
a1091 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1111 1
a1111 1
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
d1115 1
a1115 1
		bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
d1119 1
a1119 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1123 1
a1123 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1129 1
a1129 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1133 1
a1133 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1153 1
a1153 1
		if (bus_io_read_1(bc, ioh, com_ier))
d1208 2
a1209 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1256 1
a1256 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1289 4
a1292 4
			bus_io_write_1(bc, ioh, com_lcr, lcr | LCR_DLAB);
			bus_io_write_1(bc, ioh, com_dlbl, ospeed);
			bus_io_write_1(bc, ioh, com_dlbh, ospeed >> 8);
			bus_io_write_1(bc, ioh, com_lcr, lcr);
d1294 1
a1294 1
			bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1296 1
a1296 1
			bus_io_write_1(bc, ioh, com_lcr, lcr);
d1300 1
a1300 1
			bus_io_write_1(bc, ioh, com_fifo,
d1304 1
a1304 1
		bus_io_write_1(bc, ioh, com_lcr, lcr);
d1311 1
a1311 1
				bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1316 1
a1316 1
				bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1338 1
a1338 1
		bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1364 2
a1365 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1399 1
a1399 1
		bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d1406 1
a1406 1
			bus_io_write_1(bc, ioh, com_data, *cp++);
d1415 1
a1415 1
			bus_io_write_1(bc, ioh, com_data, *cp++);
d1418 1
a1418 1
		bus_io_write_1(bc, ioh, com_data, getc(&tp->t_outq));
d1425 1
a1425 1
		bus_io_write_1(bc, ioh, com_ier, sc->sc_ier);
d1527 1
a1527 1
			bus_io_write_1(sc->sc_bc, sc->sc_ioh, com_mcr,
d1555 2
a1556 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1571 1
a1571 1
	if (ISSET(iter[n].iir = bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND))
d1574 1
a1574 1
	if (ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND))
d1584 1
a1584 1
		lsr = bus_io_read_1(bc, ioh, com_lsr);
d1591 1
a1591 1
				data = bus_io_read_1(bc, ioh, com_data);
d1618 1
a1618 1
						bus_io_write_1(bc, ioh, com_mcr,
d1630 1
a1630 1
				lsr = bus_io_read_1(bc, ioh, com_lsr);
d1643 1
a1643 1
		msr = bus_io_read_1(bc, ioh, com_msr);
d1652 1
a1652 1
				bus_io_write_1(bc, ioh, com_mcr, sc->sc_mcr);
d1671 1
a1671 1
		if (ISSET(iter[n].iir = bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND))
d1674 1
a1674 1
		if (ISSET(bus_io_read_1(bc, ioh, com_iir), IIR_NOPEND))
d1704 2
a1705 2
	bus_chipset_tag_t bc = 0;
	bus_io_handle_t ioh;
d1707 8
d1716 1
a1716 1
	if (bus_io_map(bc, CONADDR, COM_NPORTS, &ioh)) {
d1720 2
a1721 2
	found = comprobe1(bc, ioh, CONADDR);
	bus_io_unmap(bc, ioh, COM_NPORTS);
d1748 1
a1748 1
	comconsbc = ???;
d1750 1
a1750 1
	if (bus_io_map(comconsbc, CONADDR, COM_NPORTS, &comconsioh))
d1753 1
a1753 1
	cominit(comconsbc, comconsioh, comdefaultrate);
d1759 3
a1761 3
cominit(bc, ioh, rate)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d1767 1
a1767 1
	bus_io_write_1(bc, ioh, com_lcr, LCR_DLAB);
d1769 6
a1774 6
	bus_io_write_1(bc, ioh, com_dlbl, rate);
	bus_io_write_1(bc, ioh, com_dlbh, rate >> 8);
	bus_io_write_1(bc, ioh, com_lcr, LCR_8BITS);
	bus_io_write_1(bc, ioh, com_ier, IER_ERXRDY | IER_ETXRDY);
	bus_io_write_1(bc, ioh, com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
	stat = bus_io_read_1(bc, ioh, com_iir);
d1783 2
a1784 2
	bus_chipset_tag_t bc = comconsbc;
	bus_io_handle_t ioh = comconsioh;
d1787 1
a1787 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_RXRDY))
d1789 2
a1790 2
	c = bus_io_read_1(bc, ioh, com_data);
	stat = bus_io_read_1(bc, ioh, com_iir);
d1804 2
a1805 2
	bus_chipset_tag_t bc = comconsbc;
	bus_io_handle_t ioh = comconsioh;
d1813 1
a1813 1
		cominit(bc, ioh, comdefaultrate);
d1818 1
a1818 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_TXRDY) && --timo)
d1820 1
a1820 1
	bus_io_write_1(bc, ioh, com_data, c);
d1823 1
a1823 1
	while (!ISSET(stat = bus_io_read_1(bc, ioh, com_lsr), LSR_TXRDY) && --timo)
d1826 1
a1826 1
	stat = bus_io_read_1(bc, ioh, com_iir);
@


1.26
log
@Break shall be handled as data == 0 and FE bit set; from Theo
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.25 1996/10/30 15:01:49 niklas Exp $	*/
d60 1
a60 1
#include <machine/bus.h>
@


1.25
log
@cominit is used from the outside (the alpha port)
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.24 1996/10/22 01:11:50 downsj Exp $	*/
d1565 1
@


1.24
log
@patch com speed initialization
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.23 1996/10/16 23:18:42 deraadt Exp $	*/
a167 2

void cominit __P((bus_chipset_tag_t, bus_io_handle_t, int));
@


1.23
log
@contextual usage
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.22 1996/10/16 12:31:58 deraadt Exp $	*/
d116 2
d795 1
d1225 3
a1227 5
#if 1
	if (tp->t_ispeed != t->c_ispeed) {
#else
	if (1) {
#endif
@


1.22
log
@unused variables
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.21 1996/08/29 12:58:30 deraadt Exp $	*/
d1582 1
d1584 1
@


1.21
log
@sunos-like cua behaviour; inspired by budd@@cs.bu.edu in his scn.c
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.20 1996/07/02 09:47:46 downsj Exp $	*/
d228 9
a236 10
    int err; 
    struct pcmciadevs *dev = pc_link->device;
    struct ed_softc *sc = (void *)self; 
    if (!(err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,
				  pc_cf, cf))) {
        pc_cf->memwin = 0;
	if (pc_cf->cfgtype == 0) 
	    pc_cf->cfgtype = CFGENTRYID; /* determine from ioaddr */
    }
    return err;
d244 1
a244 1
    struct pcmcia_device pcd;
d246 2
a247 2
    {"PCMCIA Modem card", com_pcmcia_mod, com_pcmcia_isa_attach,
     NULL, com_pcmcia_remove}
d252 13
a264 13
  { "com", 0,
  NULL, "*MODEM*", NULL, NULL,
  NULL, (void *)&pcmcia_com 
  },
  { "com", 0,
  NULL, NULL, "*MODEM*", NULL,
  NULL, (void *)&pcmcia_com 
  },
  { "com", 0,
  NULL, NULL, NULL, "*MODEM*",
  NULL, (void *)&pcmcia_com 
  },
  {NULL}
d274 1
a274 1
				  ncom_pcmcia_devs);
d286 1
d288 1
a288 2
	int rval;
	if (rval = comprobe(parent, sc->sc_dev.dv_cfdata, ia)) {
@


1.20
log
@better FIFO enabling code; netbsd pr#2574, cliff@@wport.com
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.19 1996/06/24 20:48:31 pefo Exp $	*/
d114 2
d196 2
a197 1
#define	COMUNIT(x)	(minor(x))
d749 1
a749 1
	int unit = COMUNIT(dev);
d763 1
d769 1
d877 1
a877 1
		if (ISSET(sc->sc_swflags, COM_SW_SOFTCAR) ||
d887 9
d897 9
a905 2
	if (!ISSET(flag, O_NONBLOCK))
		while (!ISSET(tp->t_cflag, CLOCAL) &&
d913 2
d919 1
d931 1
a931 1
	int unit = COMUNIT(dev);
d958 1
d984 1
a984 1
	struct com_softc *sc = com_cd.cd_devs[COMUNIT(dev)];
d1003 1
a1003 1
	struct com_softc *sc = com_cd.cd_devs[COMUNIT(dev)];
d1020 1
a1020 1
	struct com_softc *sc = com_cd.cd_devs[COMUNIT(dev)];
d1047 1
a1047 1
	int unit = COMUNIT(dev);
d1167 1
a1167 1
	struct com_softc *sc = com_cd.cd_devs[COMUNIT(tp->t_dev)];
d1325 1
a1325 1
	struct com_softc *sc = com_cd.cd_devs[COMUNIT(tp->t_dev)];
@


1.19
log
@pica changes backed out. does not belong here
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.18 1996/06/22 23:12:14 pefo Exp $	*/
d833 27
a859 5
		if (ISSET(sc->sc_hwflags, COM_HW_FIFO))
			/* Set the FIFO threshold based on the receive speed. */
			bus_io_write_1(bc, ioh, com_fifo,
			    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST |
			    (tp->t_ispeed <= 1200 ? FIFO_TRIGGER_1 : FIFO_TRIGGER_8));
@


1.18
log
@Pica bus support added
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.17 1996/06/10 19:29:59 niklas Exp $	*/
a160 10
#if NCOM_PICA
#undef  CONADDR         /* This is stupid but using devs before config .. */
#define CONADDR 0xe0006000

struct cfattach com_pica_ca = {
	sizeof(struct com_softc), comprobe, comattach
};
#endif


a526 4
#if NCOM_PICA
#define IS_PICA(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "pica")
#endif
a540 10
#if NCOM_PICA
	if(IS_PICA(parent)) {
		struct confargs *ca = aux;
		if(!BUS_MATCHNAME(ca, "com"))
			return(0);
		iobase = (long)BUS_CVTADDR(ca);
		bc = 0;
		needioh = 1;
	} else
#endif
a624 9
#if NCOM_PICA
	if(IS_PICA(parent)) {
		struct confargs *ca = aux;
		iobase = (long)BUS_CVTADDR(ca);
		bc = 0;
		irq = 0;
		ioh = iobase;
	} else
#endif
a711 6
#if NCOM_PICA
		if (IS_PICA(parent)) {
			struct confargs *ca = aux;
			BUS_INTR_ESTABLISH(ca, comintr, (void *)(long)sc);
		} else
#endif
a1619 1
#if 0
a1623 3
#else
	ioh = CONADDR;
#endif
@


1.17
log
@Some cleanup for -Wall -Wstrict-prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.16 1996/06/10 07:32:39 deraadt Exp $	*/
d161 9
d537 4
d555 10
d649 9
d745 6
d1659 1
d1664 3
@


1.16
log
@tty_attach()
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.15 1996/05/26 00:27:14 deraadt Exp $	*/
d144 4
a147 2
int comprobe __P((struct device *, void *, void *));
void comattach __P((struct device *, struct device *, void *));
a215 1
void	com_absent_notify __P((struct com_softc *sc));
d388 3
a390 2
	struct tty *tp;
	if (tp = sc->sc_tty) {
d427 1
a427 2
	int tmp;
	int i,k;
@


1.15
log
@sync 0521
@
text
@d1 2
a2 2
/*	$OpenBSD: com.c,v 1.14 1996/05/10 12:37:13 deraadt Exp $	*/
/*	$NetBSD: com.c,v 1.82 1996/05/12 23:52:00 mycroft Exp $	*/
d760 1
a760 1
	if (!sc->sc_tty)
d762 2
a763 1
	else
@


1.14
log
@proto change
@
text
@d1 2
a2 2
/*	$OpenBSD: com.c,v 1.11 1996/04/21 22:23:15 deraadt Exp $	*/
/*	$NetBSD: com.c,v 1.81 1996/05/05 19:50:44 christos Exp $	*/
d60 1
a60 3
#ifdef i386							/* XXX */
#include <machine/cpu.h>					/* XXX */
#else								/* XXX */
a61 2
#endif								/* XXX */
#include <machine/bus.h>
@


1.13
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*	$NetBSD: com.c,v 1.80 1996/04/29 20:03:00 christos Exp $	*/
a128 1
int	comintr		__P((void *));
@


1.12
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d2 1
a2 1
/*	$NetBSD: com.c,v 1.79 1996/04/15 18:54:31 cgd Exp $	*/
d78 1
d125 19
a143 9
int comopen __P((dev_t, int, int, struct proc *));
int comclose __P((dev_t, int, int, struct proc *));
void comdiag __P((void *));
int comintr __P((void *));
void compoll __P((void *));
int comparam __P((struct tty *, struct termios *));
void comstart __P((struct tty *));
void com_absent_notify __P((struct com_softc *sc));
void comstart_pending __P((void *arg));
d169 1
a169 1
int cominit __P((bus_chipset_tag_t, bus_io_handle_t, int));
d208 3
a210 3
int com_pcmcia_match __P((struct device *, void *, void *));
void com_pcmcia_attach __P((struct device *, struct device *, void *));
int com_pcmcia_detach __P((struct device *));
d217 3
a219 5
int 
com_pcmcia_mod __P((struct pcmcia_link *pc_link,
		    struct device *self,
		    struct pcmcia_conf *pc_cf,
		    struct cfdata *cf));
a518 1
	struct cfdata *cf = match;
d548 1
a591 1
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
a594 1
	struct tty *tp;
d725 1
a725 1
			(void) cominit(bc, ioh, kgdb_rate);
d1352 1
a1352 1
void
d1355 1
d1364 1
d1619 2
a1620 1
	bus_chipset_tag_t bc;
a1623 4
#if 0
	XXX NEEDS TO BE FIXED XXX
	bc = ???;
#endif
d1666 1
d1686 1
d1721 1
a1721 1
		(void) cominit(bc, ioh, comdefaultrate);
@


1.11
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.10 1996/04/18 23:47:32 niklas Exp $	*/
d84 1
a97 1
	bus_chipset_tag_t sc_bc;
d105 3
d131 2
d153 1
d160 4
d194 18
a211 2
/*#include "pcmciabus.h"*/
#if NPCMCIABUS >0                       
a212 1
#include <dev/pcmcia/pcmciabus.h>
d214 2
a215 2
static int 
commod(pc_link,self,pc_cf,cf)
d222 1
a222 1
    struct pcmciadevs *dev=pc_link->device;
d224 5
a228 4
    if(!(err=pc_link->adapter->bus_link->bus_config(pc_link,self,pc_cf,cf))) {
        pc_cf->memwin=0;
	if(pc_cf->cfgtype==0) 
	    pc_cf->cfgtype=CFGENTRYID; /* determine from ioaddr */
d232 5
d239 3
a241 2
} pcmcia_com= {
    "PCMCIA Modem card",commod,NULL,NULL,NULL
d243 4
a246 2
struct pcmciadevs pcmcia_com_devs[]={
  { "com", 0, 
d250 1
a250 1
  { "com", 0, 
d254 1
a254 1
  { "com", 0, 
d260 26
d287 102
d516 8
d529 2
a530 2
#if NCOM_ISA
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isa")) {
d566 2
a567 2
#if NCOM_ISA
	if (rv && !strcmp(parent->dv_cfdata->cf_driver->cd_name, "isa")) {
d598 7
a604 1
	sc->sc_hwflags = 0;
d606 2
a607 2
#if NCOM_ISA
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isa")) {
d636 1
a636 1
			sc->sc_hwflags |= COM_HW_NOIEN;
d701 2
a702 2
#if NCOM_ISA
		if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isa")) {
d755 1
a755 1
	if (!sc)
d895 10
a904 7
	CLR(sc->sc_lcr, LCR_SBREAK);
	bus_io_write_1(bc, ioh, com_lcr, sc->sc_lcr);
	bus_io_write_1(bc, ioh, com_ier, 0);
	if (ISSET(tp->t_cflag, HUPCL) &&
	    !ISSET(sc->sc_swflags, COM_SW_SOFTCAR)) {
		/* XXX perhaps only clear DTR */
		bus_io_write_1(bc, ioh, com_mcr, 0);
d911 8
d937 7
d956 7
d1004 7
d1125 7
d1260 12
d1281 10
d1475 3
@


1.10
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: com.c,v 1.9 1996/03/20 01:00:42 mickey Exp $	*/
/*	$NetBSD: com.c,v 1.75 1996/03/10 09:01:24 cgd Exp $	*/
d60 5
a64 1
#include <machine/cpu.h>
d76 2
a117 1
int comprobe __P((struct device *, void *, void *));
a120 1
void comattach __P((struct device *, struct device *, void *));
d129 18
a146 1
int cominit __P((bus_chipset_tag_t, bus_io_handle_t, int));
d148 2
a149 2
struct cfdriver comcd = {
	NULL, "com", comprobe, comattach, DV_TTY, sizeof(struct com_softc)
d152 2
d164 1
d184 1
a184 1
#include "pcmciabus.h"
d354 6
d366 4
a369 1
	} else {
d379 3
a381 1
	}
d396 1
d403 1
d423 5
d430 1
d445 4
a448 1
	} else {
d461 3
a463 1
	}
d524 12
a535 3
	if (irq != IRQUNK)
		sc->sc_ih = isa_intr_establish(irq, IST_EDGE, IPL_TTY,
		    comintr, sc, sc->sc_dev.dv_xname);
d576 1
a576 1
	if (unit >= comcd.cd_ndevs)
d578 1
a578 1
	sc = comcd.cd_devs[unit];
d595 4
a598 1
		tp->t_cflag = TTYDEF_CFLAG;
d707 1
a707 1
	struct com_softc *sc = comcd.cd_devs[unit];
d747 1
a747 1
	struct com_softc *sc = comcd.cd_devs[COMUNIT(dev)];
d759 1
a759 1
	struct com_softc *sc = comcd.cd_devs[COMUNIT(dev)];
d769 1
a769 1
	struct com_softc *sc = comcd.cd_devs[COMUNIT(dev)];
d797 1
a797 1
	struct com_softc *sc = comcd.cd_devs[unit];
d909 1
a909 1
	struct com_softc *sc = comcd.cd_devs[COMUNIT(tp->t_dev)];
d1048 1
a1048 1
	struct com_softc *sc = comcd.cd_devs[COMUNIT(tp->t_dev)];
d1169 2
a1170 2
	for (unit = 0; unit < comcd.cd_ndevs; unit++) {
		sc = comcd.cd_devs[unit];
@


1.9
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: com.c,v 1.8 1996/03/19 21:10:09 mickey Exp $	*/
/*	$NetBSD: com.c,v 1.65 1996/02/10 20:23:18 christos Exp $	*/
d5 2
a6 1
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
d61 1
a61 1
#include <machine/pio.h>
d65 1
d84 2
d90 5
d105 1
a105 1
	u_char sc_msr, sc_mcr, sc_lcr;
d113 3
d125 2
a130 1
int	comdefaultrate = TTYDEF_SPEED;
d132 1
a132 1
int	comconsole = COMCONSOLE;
d134 1
a134 1
int	comconsole = -1;
d136 1
d138 4
d230 3
a232 1
comprobe1(iobase)
d239 4
a242 4
	outb(iobase + com_lcr, 0);
	outb(iobase + com_iir, 0);
	for(i=0;i<32;i++) {
	    k=inb(iobase + com_iir);
d244 1
a244 1
		inb(iobase + com_data ); /* cleanup */
d248 1
a248 1
	if(i>=32) 
d256 2
a257 2
comprobeHAYESP(iobase, sc)
	int iobase;
d262 1
d272 1
a272 1
	if ((inb(iobase) & 0xf3) == 0)
d280 2
a281 2
	outb(iobase + HAYESP_CMD1, HAYESP_GETDIPS);
	dips = inb(iobase + HAYESP_STATUS1);
d292 3
a294 3
	outb(iobase + HAYESP_CMD1, HAYESP_GETTEST);
	val = inb(iobase + HAYESP_STATUS1);	/* Clear reg 1 */
	val = inb(iobase + HAYESP_STATUS2);
d314 1
a314 1
	printf(", 1024k fifo\n");
d324 17
a340 2
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;
d342 21
a362 2
	if (!comprobe1(iobase))
		return 0;
d364 4
a367 3
	ia->ia_iosize = COM_NPORTS;
	ia->ia_msize = 0;
	return 1;
a375 1
	struct isa_attach_args *ia = aux;
d377 3
a379 1
	int iobase = ia->ia_iobase;
d386 33
a419 2
	sc->sc_hwflags = ISSET(cf->cf_flags, COM_HW_NOIEN);
	sc->sc_swflags = 0;
d421 12
a432 2
	if (sc->sc_dev.dv_unit == comconsole)
		delay(1000);
d436 7
a442 2
	for (hayespp = hayesp_ports; *hayespp != 0; hayespp++)
		if (comprobeHAYESP(*hayespp, sc)) {
d444 1
d447 2
d454 1
a454 1
	outb(iobase + com_fifo,
d457 4
a460 2
	if (ISSET(inb(iobase + com_iir), IIR_FIFO_MASK) == IIR_FIFO_MASK)
		if (ISSET(inb(iobase + com_fifo), FIFO_TRIGGER_14) == FIFO_TRIGGER_14) {
d467 1
a467 1
	outb(iobase + com_fifo, 0);
d473 2
a474 2
	outb(iobase + com_ier, 0);
	outb(iobase + com_mcr, 0);
d476 2
a477 2
	if (ia->ia_irq != IRQUNK)
		sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_TTY,
d482 1
a482 1
		if (comconsole == unit)
d485 1
a485 1
			(void) cominit(unit, kgdb_rate);
d500 3
a502 9
	if (sc->sc_dev.dv_unit == comconsole) {
		/*
		 * Need to reset baud rate, etc. of next print so reset
		 * comconsinit.  Also make sure console is always "hardwired".
		 */
		comconsinit = 0;
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
	}
d513 2
a514 1
	int iobase;
d560 2
a561 1
		iobase = sc->sc_iobase;
d565 1
a565 1
			int hayespbase = sc->sc_hayespbase;
d567 1
a567 1
			outb(iobase + com_fifo,
d572 2
a573 2
			outb(hayespbase + HAYESP_CMD1, HAYESP_SETMODE);
			outb(hayespbase + HAYESP_CMD2, 
d578 3
a580 3
			outb(hayespbase + HAYESP_CMD1, HAYESP_SETFLOWTYPE);
			outb(hayespbase + HAYESP_CMD2, HAYESP_FLOW_RTS);
			outb(hayespbase + HAYESP_CMD2, HAYESP_FLOW_CTS);
d583 2
a584 2
			outb(hayespbase + HAYESP_CMD1, HAYESP_SETRXFLOW);
			outb(hayespbase + HAYESP_CMD2, 
d586 1
a586 1
			outb(hayespbase + HAYESP_CMD2,
d588 1
a588 1
			outb(hayespbase + HAYESP_CMD2,
d590 1
a590 1
			outb(hayespbase + HAYESP_CMD2,
d596 1
a596 1
			outb(iobase + com_fifo,
d600 2
a601 2
		while (ISSET(inb(iobase + com_lsr), LSR_RXRDY))
			(void) inb(iobase + com_data);
d606 3
a608 3
		outb(iobase + com_mcr, sc->sc_mcr);
		outb(iobase + com_ier,
		    IER_ERXRDY | IER_ETXRDY | IER_ERLS | IER_EMSC);
d610 1
a610 1
		sc->sc_msr = inb(iobase + com_msr);
d649 2
a650 1
	int iobase = sc->sc_iobase;
d660 2
a661 2
	outb(iobase + com_lcr, sc->sc_lcr);
	outb(iobase + com_ier, 0);
d665 1
a665 1
		outb(iobase + com_mcr, 0);
d673 1
a673 1
	if (unit != comconsole) {
d739 2
a740 1
	int iobase = sc->sc_iobase;
d753 1
a753 1
		outb(iobase + com_lcr, sc->sc_lcr);
d757 1
a757 1
		outb(iobase + com_lcr, sc->sc_lcr);
d761 1
a761 1
		outb(iobase + com_mcr, sc->sc_mcr);
d765 1
a765 1
		outb(iobase + com_mcr, sc->sc_mcr);
d771 1
a771 1
		outb(iobase + com_mcr, sc->sc_mcr);
d775 1
a775 1
		outb(iobase + com_mcr, sc->sc_mcr);
d795 1
a795 1
		if (inb(iobase + com_ier))
d850 2
a851 1
	int iobase = sc->sc_iobase;
d861 1
a861 1
	lcr = sc->sc_lcr & LCR_SBREAK;
d891 1
a891 1
		outb(iobase + com_mcr, sc->sc_mcr);
d898 1
d900 38
a937 2
		if (ISSET(sc->sc_hwflags, COM_HW_FIFO))
			outb(iobase + com_fifo,
a939 9
	}

	if (ospeed != 0) {
		outb(iobase + com_lcr, lcr | LCR_DLAB);
		outb(iobase + com_dlbl, ospeed);
		outb(iobase + com_dlbh, ospeed >> 8);
		outb(iobase + com_lcr, lcr);
		SET(sc->sc_mcr, MCR_DTR);
		outb(iobase + com_mcr, sc->sc_mcr);
d941 1
a941 1
		outb(iobase + com_lcr, lcr);
d948 1
a948 1
				outb(iobase + com_mcr, sc->sc_mcr);
d953 1
a953 1
				outb(iobase + com_mcr, sc->sc_mcr);
d975 1
a975 1
		outb(iobase + com_mcr, sc->sc_mcr);
d978 1
d980 1
d989 2
a990 1
	int iobase = sc->sc_iobase;
d994 1
a994 1
	if (ISSET(tp->t_state, TS_TTSTOP | TS_BUSY))
d996 3
d1000 1
a1000 1
		goto out;
d1007 1
a1007 1
			goto out;
d1012 4
d1021 1
a1021 1
			outb(iobase + com_data, *cp++);
d1030 1
a1030 1
			outb(iobase + com_data, *cp++);
d1033 1
a1033 1
		outb(iobase + com_data, getc(&tp->t_outq));
d1036 7
d1140 2
a1141 1
			outb(sc->sc_iobase + com_mcr, sc->sc_mcr);
d1168 2
a1169 1
	int iobase = sc->sc_iobase;
d1172 6
d1179 6
a1184 1
	if (ISSET(inb(iobase + com_iir), IIR_NOPEND))
d1186 1
d1191 4
a1194 1
		lsr = inb(iobase + com_lsr);
d1196 1
a1196 1
		if (ISSET(lsr, LSR_RCV_MASK)) {
d1201 1
a1201 2
				data = ISSET(lsr, LSR_RXRDY) ?
				    inb(iobase + com_data) : 0;
d1203 5
d1209 2
a1210 1
					if (sc->sc_dev.dv_unit == comconsole) {
a1214 1
					data = '\0';
d1227 2
a1228 2
						outb(iobase + com_mcr,
						     sc->sc_mcr);
d1232 7
a1238 2
				lsr = inb(iobase + com_lsr);
			} while (ISSET(lsr, LSR_RCV_MASK));
d1242 1
a1242 1
#if 0
d1247 4
a1250 1
		msr = inb(iobase + com_msr);
d1259 1
a1259 1
				outb(iobase + com_mcr, sc->sc_mcr);
d1269 4
a1272 5
			CLR(tp->t_state, TS_BUSY);
			if (ISSET(tp->t_state, TS_FLUSH))
				CLR(tp->t_state, TS_FLUSH);
			else
				(*linesw[tp->t_line].l_start)(tp);
d1275 7
a1281 1
		if (ISSET(inb(iobase + com_iir), IIR_NOPEND))
d1283 1
d1285 14
d1310 3
d1314 11
a1324 1
	if (!comprobe1(CONADDR)) {
d1348 9
a1356 2
	cominit(CONUNIT, comdefaultrate);
	comconsole = CONUNIT;
d1360 4
a1363 2
cominit(unit, rate)
	int unit, rate;
a1365 1
	int iobase = CONADDR;
d1368 1
a1368 1
	outb(iobase + com_lcr, LCR_DLAB);
d1370 6
a1375 6
	outb(iobase + com_dlbl, rate);
	outb(iobase + com_dlbh, rate >> 8);
	outb(iobase + com_lcr, LCR_8BITS);
	outb(iobase + com_ier, IER_ERXRDY | IER_ETXRDY);
	outb(iobase + com_fifo, FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_4);
	stat = inb(iobase + com_iir);
d1383 2
a1384 1
	int iobase = CONADDR;
d1387 1
a1387 1
	while (!ISSET(stat = inb(iobase + com_lsr), LSR_RXRDY))
d1389 2
a1390 2
	c = inb(iobase + com_data);
	stat = inb(iobase + com_iir);
d1404 2
a1405 1
	int iobase = CONADDR;
d1413 1
a1413 1
		(void) cominit(COMUNIT(dev), comdefaultrate);
d1418 1
a1418 1
	while (!ISSET(stat = inb(iobase + com_lsr), LSR_TXRDY) && --timo)
d1420 1
a1420 1
	outb(iobase + com_data, c);
d1423 1
a1423 1
	while (!ISSET(stat = inb(iobase + com_lsr), LSR_TXRDY) && --timo)
d1426 1
a1426 1
	stat = inb(iobase + com_iir);
@


1.8
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.7 1996/03/08 16:42:51 niklas Exp $	*/
d370 1
a370 1
		    comintr, sc);
@


1.7
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d370 1
a370 1
		    comintr, sc, sc->sc_dev.dv_xname);
@


1.6
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: com.c,v 1.62 1995/10/15 19:43:04 mycroft Exp $	*/
d65 3
a67 1
#include <dev/ic/espreg.h>
d70 1
a70 1
#define	COM_IBUFSIZE	(2 * 256)
d83 3
a85 1
	int sc_espbase;
d89 1
a89 1
#define	COM_HW_ESP	0x04
d234 1
d236 3
a238 3
comprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d240 9
a248 2
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;
d250 2
a251 1
	if (!comprobe1(iobase))
d254 3
a256 4
	ia->ia_iosize = COM_NPORTS;
	ia->ia_msize = 0;
	return 1;
}
d258 8
a265 7
int
comprobeESP(esp_port, sc)
	int esp_port;
	struct com_softc *sc;
{
	char	val, dips;
	int	com_base_list[] = { 0x3f8, 0x2f8, 0x3e8, 0x2e8 };
a266 12
	/* Test for ESP signature at the ESP i/o port. */
	if ((inb(esp_port) & 0xf3) == 0)
		return(0);

	/* Check compatibility mode settings */
	outb(esp_port + ESP_CMD1, ESP_GETDIPS);
	dips = inb(esp_port + ESP_STATUS1);

	/* Does this ESP board service this com port?: Bits 0,1 == COM0..3 */
	if (sc->sc_iobase != com_base_list[(dips & 0x03)]) {
		return(0);
	}
d269 1
a269 1
	/* Check ESP Self Test bits. */
d271 3
a273 3
	outb(esp_port + ESP_CMD1, ESP_GETTEST);
	val = inb(esp_port + ESP_STATUS1);	/* Always 0x00 */
	val = inb(esp_port + ESP_STATUS2);
d276 2
a277 1
		return(0);
d280 2
a281 2
	/* Check for ability to emulate 16550: bit 7 set */
	if (ISSET(dips, 0x80) == 0) {
d283 2
a284 1
		return(0);
d287 25
a311 4
	/* We're a full featured ESP card at the right com port. */
	SET(sc->sc_hwflags, COM_HW_ESP);
	printf(", 1024 byte fifo\n");
	return(1);
d324 4
a327 2
	int	esp_ports[] = { 0x140, 0x180, 0x280, 0 };
	int	*espp;
d336 1
d338 3
a340 3
	for (espp = esp_ports; *espp != 0; espp++)
		if (comprobeESP(*espp, sc)) {
			sc->sc_espbase = *espp;
d344 17
a360 15
	if (*espp == 0) {
		/* look for a NS 16550AF UART with FIFOs */
		outb(iobase + com_fifo,
		    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_14);
		delay(100);
		if (ISSET(inb(iobase + com_iir), IIR_FIFO_MASK) == IIR_FIFO_MASK)
			if (ISSET(inb(iobase + com_fifo), FIFO_TRIGGER_14) ==
			    FIFO_TRIGGER_14) {
				SET(sc->sc_hwflags, COM_HW_FIFO);
				printf(": ns16550a, working fifo\n");
			} else
				printf(": ns16550, broken fifo\n");
		else
			printf(": ns8250 or ns16450, no fifo\n");
		outb(iobase + com_fifo, 0);
d362 1
d458 4
a462 2
		/* Set up the ESP board */
		if (ISSET(sc->sc_hwflags, COM_HW_ESP)) {
d464 2
a465 4
			    /* XXX - bug in ESP requires DMA flag set */
			    FIFO_DMA_MODE |
			    FIFO_ENABLE | FIFO_RCV_RST |
			    FIFO_XMT_RST | FIFO_TRIGGER_8);
d468 4
a471 3
			outb(sc->sc_espbase + ESP_CMD1, ESP_SETMODE);
			outb(sc->sc_espbase + ESP_CMD2,
				ESP_MODE_FIFO | ESP_MODE_RTS | ESP_MODE_SCALE);
d474 3
a476 3
			outb(sc->sc_espbase + ESP_CMD1, ESP_SETFLOWTYPE);
			outb(sc->sc_espbase + ESP_CMD2, ESP_FLOW_RTS);
			outb(sc->sc_espbase + ESP_CMD2, ESP_FLOW_CTS);
d479 12
a490 6
			outb(sc->sc_espbase + ESP_CMD1, ESP_SETRXFLOW);
			outb(sc->sc_espbase + ESP_CMD2, HIBYTE(RXHIGHWATER));
			outb(sc->sc_espbase + ESP_CMD2, LOBYTE(RXHIGHWATER));
			outb(sc->sc_espbase + ESP_CMD2, HIBYTE(RXLOWWATER));
			outb(sc->sc_espbase + ESP_CMD2, LOBYTE(RXLOWWATER));
		} else if (ISSET(sc->sc_hwflags, COM_HW_FIFO))
d870 3
a872 1
	if (ISSET(sc->sc_hwflags, COM_HW_ESP)) {
d875 1
a875 1
		do {
d877 5
a881 2
		} while (--n);
	} else if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
@


1.5
log
@Last of the glue and devices for for PCMCIA support from Stefan Grefen
<grefen@@convex.com> with modifications by John Kohl <jtk@@kolvir.blrc.ma.us>
@
text
@d339 1
a339 1
		    comintr, sc);
@


1.4
log
@Patches to use Hayes ESP with com.c; from banshee@@gabriella.resort.com;
netbsd pr#1865. the ESP card code is always enabled -- we will have to
see if that fails on any chipsets.
@
text
@d137 44
d210 2
d216 9
a224 2
	if (inb(iobase + com_iir) & 0x38)
		return 0;
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d64 1
d80 1
d84 1
d192 44
d246 2
d256 23
a278 13
	/* look for a NS 16550AF UART with FIFOs */
	outb(iobase + com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_14);
	delay(100);
	if (ISSET(inb(iobase + com_iir), IIR_FIFO_MASK) == IIR_FIFO_MASK)
		if (ISSET(inb(iobase + com_fifo), FIFO_TRIGGER_14) == FIFO_TRIGGER_14) {
			SET(sc->sc_hwflags, COM_HW_FIFO);
			printf(": ns16550a, working fifo\n");
		} else
			printf(": ns16550, broken fifo\n");
	else
		printf(": ns8250 or ns16450, no fifo\n");
	outb(iobase + com_fifo, 0);
d374 27
a400 2
		/* Set the FIFO threshold based on the receive speed. */
		if (ISSET(sc->sc_hwflags, COM_HW_FIFO))
d779 7
a785 1
	if (ISSET(sc->sc_hwflags, COM_HW_FIFO)) {
@


1.2
log
@update from netbsd
@
text
@d226 2
a227 2
		sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE,
		    ISA_IPL_TTY, comintr, sc);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: com.c,v 1.61 1995/07/04 06:47:18 mycroft Exp $	*/
d64 1
d88 1
a88 1
	u_char sc_msr, sc_mcr;
d129 4
a132 4
#define	bis(c, b)	do { const register int com_ad = (c); \
			     outb(com_ad, inb(com_ad) | (b)); } while(0)
#define	bic(c, b)	do { const register int com_ad = (c); \
			     outb(com_ad, inb(com_ad) & ~(b)); } while(0)
d165 1
a165 1
	outb(iobase + com_cfcr, 0);
d201 1
a201 1
	sc->sc_hwflags = cf->cf_flags & COM_HW_NOIEN;
d211 3
a213 3
	if ((inb(iobase + com_iir) & IIR_FIFO_MASK) == IIR_FIFO_MASK)
		if ((inb(iobase + com_fifo) & FIFO_TRIGGER_14) == FIFO_TRIGGER_14) {
			sc->sc_hwflags |= COM_HW_FIFO;
d255 2
a256 2
		sc->sc_hwflags |= COM_HW_CONSOLE;
		sc->sc_swflags |= COM_SW_SOFTCAR;
d287 2
a288 2
	if ((tp->t_state & TS_ISOPEN) == 0) {
		tp->t_state |= TS_WOPEN;
d293 6
a298 6
		if (sc->sc_swflags & COM_SW_CLOCAL)
			tp->t_cflag |= CLOCAL;
		if (sc->sc_swflags & COM_SW_CRTSCTS)
			tp->t_cflag |= CRTSCTS;
		if (sc->sc_swflags & COM_SW_MDMBUF)
			tp->t_cflag |= MDMBUF;
d316 1
a316 1
		if (sc->sc_hwflags & COM_HW_FIFO)
d321 1
a321 1
		while (inb(iobase + com_lsr) & LSR_RXRDY)
d325 2
a326 2
		if ((sc->sc_hwflags & COM_HW_NOIEN) == 0)
			sc->sc_mcr |= MCR_IENABLE;
d332 3
a334 3
		if (sc->sc_swflags & COM_SW_SOFTCAR || sc->sc_msr & MSR_DCD ||
		    tp->t_cflag & MDMBUF)
			tp->t_state |= TS_CARR_ON;
d336 2
a337 2
			tp->t_state &= ~TS_CARR_ON;
	} else if (tp->t_state&TS_XCLUDE && p->p_ucred->cr_uid != 0) {
d339 1
a339 1
	} else
d343 6
a348 6
	if ((flag & O_NONBLOCK) == 0)
		while ((tp->t_cflag & CLOCAL) == 0 &&
		    (tp->t_state & TS_CARR_ON) == 0) {
			tp->t_state |= TS_WOPEN;
			error = ttysleep(tp, (caddr_t)&tp->t_rawq, 
			    TTIPRI | PCATCH, ttopen, 0);
d374 1
a374 1
	if ((tp->t_state & TS_ISOPEN) == 0)
d379 2
a380 1
	bic(iobase + com_cfcr, CFCR_SBREAK);
d382 2
a383 2
	if (tp->t_cflag & HUPCL &&
	    (sc->sc_swflags & COM_SW_SOFTCAR) == 0) {
d387 1
a387 1
	tp->t_state &= ~(TS_BUSY | TS_FLUSH);
d441 4
a444 4
	if (data & TIOCM_DTR)
		m |= MCR_DTR;
	if (data & TIOCM_RTS)
		m |= MCR_RTS;
d471 2
a472 1
		bis(iobase + com_cfcr, CFCR_SBREAK);
d475 2
a476 1
		bic(iobase + com_cfcr, CFCR_SBREAK);
d479 2
a480 1
		outb(iobase + com_mcr, sc->sc_mcr |= sc->sc_dtr);
d483 2
a484 1
		outb(iobase + com_mcr, sc->sc_mcr &= ~sc->sc_dtr);
d487 1
a487 1
		sc->sc_mcr &= ~(MCR_DTR | MCR_RTS);
d489 2
a490 2
		outb(iobase + com_mcr,
		    sc->sc_mcr |= tiocm_xxx2mcr(*(int *)data));
d493 2
a494 2
		outb(iobase + com_mcr,
		    sc->sc_mcr &= ~tiocm_xxx2mcr(*(int *)data));
d501 4
a504 4
		if (m & MCR_DTR)
			bits |= TIOCM_DTR;
		if (m & MCR_RTS)
			bits |= TIOCM_RTS;
d506 8
a513 8
		if (m & MSR_DCD)
			bits |= TIOCM_CD;
		if (m & MSR_CTS)
			bits |= TIOCM_CTS;
		if (m & MSR_DSR)
			bits |= TIOCM_DSR;
		if (m & (MSR_RI | MSR_TERI))
			bits |= TIOCM_RI;
d515 1
a515 1
			bits |= TIOCM_LE;
d520 1
a520 1
		int bits = 0;
d522 9
a530 8
		if (sc->sc_swflags & COM_SW_SOFTCAR)
			bits |= TIOCFLAG_SOFTCAR;
		if (sc->sc_swflags & COM_SW_CLOCAL)
			bits |= TIOCFLAG_CLOCAL;
		if (sc->sc_swflags & COM_SW_CRTSCTS)
			bits |= TIOCFLAG_CRTSCTS;
		if (sc->sc_swflags & COM_SW_MDMBUF)
			bits |= TIOCFLAG_MDMBUF;
d532 1
a532 1
		*(int *)data = bits;
d543 9
a551 9
		if ((userbits & TIOCFLAG_SOFTCAR) ||
		    (sc->sc_hwflags & COM_HW_CONSOLE))
			driverbits |= COM_SW_SOFTCAR;
		if (userbits & TIOCFLAG_CLOCAL)
			driverbits |= COM_SW_CLOCAL;
		if (userbits & TIOCFLAG_CRTSCTS)
			driverbits |= COM_SW_CRTSCTS;
		if (userbits & TIOCFLAG_MDMBUF)
			driverbits |= COM_SW_MDMBUF;
d571 1
a571 1
	u_char cfcr;
d579 3
a581 1
	switch (t->c_cflag & CSIZE) {
d583 1
a583 1
		cfcr = CFCR_5BITS;
d586 1
a586 1
		cfcr = CFCR_6BITS;
d589 1
a589 1
		cfcr = CFCR_7BITS;
d592 1
a592 1
		cfcr = CFCR_8BITS;
d595 4
a598 4
	if (t->c_cflag & PARENB) {
		cfcr |= CFCR_PENAB;
		if ((t->c_cflag & PARODD) == 0)
			cfcr |= CFCR_PEVEN;
d600 4
a603 2
	if (t->c_cflag & CSTOPB)
		cfcr |= CFCR_STOPB;
d607 4
a610 2
	if (ospeed == 0)
		outb(iobase + com_mcr, sc->sc_mcr &= ~MCR_DTR);
d617 1
a617 1
		if (sc->sc_hwflags & COM_HW_FIFO)
d624 1
a624 1
		outb(iobase + com_cfcr, cfcr | CFCR_DLAB);
d627 3
a629 2
		outb(iobase + com_cfcr, cfcr);
		outb(iobase + com_mcr, sc->sc_mcr |= MCR_DTR);
d631 1
a631 1
		outb(iobase + com_cfcr, cfcr);
d634 6
a639 4
	if ((t->c_cflag & CRTSCTS) == 0) {
		if (sc->sc_mcr & MCR_DTR) {
			if ((sc->sc_mcr & MCR_RTS) == 0)
				outb(iobase + com_mcr, sc->sc_mcr |= MCR_RTS);
d641 4
a644 2
			if (sc->sc_mcr & MCR_RTS)
				outb(iobase + com_mcr, sc->sc_mcr &= ~MCR_RTS);
d660 3
a662 3
	if ((sc->sc_msr & MSR_DCD) == 0 &&
	    (sc->sc_swflags & COM_SW_SOFTCAR) == 0 &&
	    (oldcflag & MDMBUF) != (tp->t_cflag & MDMBUF) &&
d664 2
a665 1
		outb(iobase + com_mcr, sc->sc_mcr &= ~sc->sc_dtr);
d681 1
a681 1
	if (tp->t_state & (TS_TTSTOP | TS_BUSY))
d683 1
a683 2
	if ((tp->t_cflag & CRTSCTS) != 0 &&
	    (sc->sc_msr & MSR_CTS) == 0)
d686 3
a688 3
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
d694 2
a695 2
	tp->t_state |= TS_BUSY;
	if (sc->sc_hwflags & COM_HW_FIFO) {
d717 3
a719 3
	if (tp->t_state & TS_BUSY)
		if ((tp->t_state & TS_TTSTOP) == 0)
			tp->t_state |= TS_FLUSH;
d793 1
a793 1
		if (tp == 0 || (tp->t_state & TS_ISOPEN) == 0) {
d798 6
a803 3
		if ((tp->t_cflag & CRTSCTS) != 0 &&
		    (sc->sc_mcr & MCR_RTS) == 0)
			outb(sc->sc_iobase + com_mcr, sc->sc_mcr |= MCR_RTS);
d833 1
a833 1
	if (inb(iobase + com_iir) & IIR_NOPEND)
d841 1
a841 1
		if (lsr & LSR_RCV_MASK) {
d846 3
a848 1
				if ((lsr & LSR_BI) != 0) {
d856 1
a856 2
				} else
					data = inb(iobase + com_data);
d865 3
a867 1
					    (tp->t_cflag & CRTSCTS) != 0)
d869 2
a870 1
						     sc->sc_mcr &= ~MCR_RTS);
d874 1
a874 1
			} while (lsr & LSR_RCV_MASK);
d878 4
a881 8

		if (lsr & LSR_TXRDY && (tp->t_state & TS_BUSY) != 0) {
			tp->t_state &= ~TS_BUSY;
			if (tp->t_state & TS_FLUSH)
				tp->t_state &= ~TS_FLUSH;
			else
				(*linesw[tp->t_line].l_start)(tp);
		}
d888 5
a892 4
			if ((delta & MSR_DCD) != 0 &&
			    (sc->sc_swflags & COM_SW_SOFTCAR) == 0 &&
			    (*linesw[tp->t_line].l_modem)(tp, (msr & MSR_DCD) != 0) == 0) {
				outb(iobase + com_mcr, sc->sc_mcr &= ~sc->sc_dtr);
d894 2
a895 2
			if ((delta & msr & MSR_CTS) != 0 &&
			    (tp->t_cflag & CRTSCTS) != 0) {
d901 9
a909 1
		if (inb(iobase + com_iir) & IIR_NOPEND)
d960 1
a960 1
	outb(iobase + com_cfcr, CFCR_DLAB);
d964 1
a964 1
	outb(iobase + com_cfcr, CFCR_8BITS);
d978 1
a978 1
	while (((stat = inb(iobase + com_lsr)) & LSR_RXRDY) == 0)
d1008 1
a1008 1
	while (((stat = inb(iobase + com_lsr)) & LSR_TXRDY) == 0 && --timo)
d1013 1
a1013 1
	while (((stat = inb(iobase + com_lsr)) & LSR_TXRDY) == 0 && --timo)
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
