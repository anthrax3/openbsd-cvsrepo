head	1.11;
access;
symbols
	OPENBSD_6_2_BASE:1.11
	OPENBSD_6_1:1.9.0.4
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.8.0.4
	OPENBSD_6_0_BASE:1.8
	OPENBSD_5_9:1.2.0.6
	OPENBSD_5_9_BASE:1.2
	OPENBSD_5_8:1.2.0.8
	OPENBSD_5_8_BASE:1.2
	OPENBSD_5_7:1.2.0.2
	OPENBSD_5_7_BASE:1.2
	OPENBSD_5_6:1.2.0.4
	OPENBSD_5_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.11
date	2017.05.29.12.58.37;	author jmatthew;	state Exp;
branches;
next	1.10;
commitid	4creoj1zD9Rwgo6f;

1.10
date	2017.05.27.12.40.51;	author sf;	state Exp;
branches;
next	1.9;
commitid	uLnBuPkrKyXpxRQE;

1.9
date	2016.10.25.06.20.41;	author dlg;	state Exp;
branches;
next	1.8;
commitid	61P1f8kxIbXrwi3t;

1.8
date	2016.04.14.11.18.32;	author dlg;	state Exp;
branches;
next	1.7;
commitid	xizj9bAz5c6r27Bv;

1.7
date	2016.04.14.00.10.37;	author dlg;	state Exp;
branches;
next	1.6;
commitid	ALmxAwnuquUCCFRL;

1.6
date	2016.04.13.12.28.57;	author dlg;	state Exp;
branches;
next	1.5;
commitid	PZv26Yhf8dtGd4O9;

1.5
date	2016.04.13.12.21.15;	author dlg;	state Exp;
branches;
next	1.4;
commitid	JE9d4x2wXwjmlBoZ;

1.4
date	2016.04.13.12.14.12;	author dlg;	state Exp;
branches;
next	1.3;
commitid	7Io3f5uOVuqCNxgI;

1.3
date	2016.04.13.12.07.03;	author dlg;	state Exp;
branches;
next	1.2;
commitid	5mbojfTbkyUkCN9o;

1.2
date	2014.04.15.10.28.07;	author dlg;	state Exp;
branches;
next	1.1;

1.1
date	2014.04.12.05.06.58;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Add hibernate support for nvme(4).  This creates a separate IO queue that is
only active during hibernation, preallocating the the submission and completion
queues during attach as they need to be page-aligned.

tested on an x270 that successfully hibernates now.
ok dlg@@
@
text
@/*	$OpenBSD: nvmevar.h,v 1.10 2017/05/27 12:40:51 sf Exp $ */

/*
 * Copyright (c) 2014 David Gwynne <dlg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#define NVME_IO_Q	1
#define NVME_HIB_Q	2

struct nvme_dmamem {
	bus_dmamap_t		ndm_map;
	bus_dma_segment_t	ndm_seg;
	size_t			ndm_size;
	caddr_t			ndm_kva;
};
#define NVME_DMA_MAP(_ndm)	((_ndm)->ndm_map)
#define NVME_DMA_LEN(_ndm)	((_ndm)->ndm_map->dm_segs[0].ds_len)
#define NVME_DMA_DVA(_ndm)	((u_int64_t)(_ndm)->ndm_map->dm_segs[0].ds_addr)
#define NVME_DMA_KVA(_ndm)	((void *)(_ndm)->ndm_kva)

struct nvme_softc;
struct nvme_queue;

struct nvme_ccb {
	SIMPLEQ_ENTRY(nvme_ccb)	ccb_entry;

	bus_dmamap_t		ccb_dmamap;

	void			*ccb_cookie;
	void			(*ccb_done)(struct nvme_softc *sc,
				    struct nvme_ccb *, struct nvme_cqe *);

	bus_addr_t		ccb_prpl_off;
	u_int64_t		ccb_prpl_dva;
	u_int64_t		*ccb_prpl;

	u_int16_t		ccb_id;
};
SIMPLEQ_HEAD(nvme_ccb_list, nvme_ccb);

struct nvme_queue {
	struct mutex		q_sq_mtx;
	struct mutex		q_cq_mtx;
	struct nvme_dmamem	*q_sq_dmamem;
	struct nvme_dmamem	*q_cq_dmamem;
	bus_size_t 		q_sqtdbl; /* submission queue tail doorbell */
	bus_size_t 		q_cqhdbl; /* completion queue head doorbell */
	u_int16_t		q_id;
	u_int32_t		q_entries;
	u_int32_t		q_sq_tail;
	u_int32_t		q_cq_head;
	u_int16_t		q_cq_phase;
};

struct nvme_namespace {
	struct nvm_identify_namespace *ident;
};

struct nvme_softc {
	struct device		sc_dev;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	bus_size_t		sc_ios;
	bus_dma_tag_t		sc_dmat;

	void			*sc_ih;

	u_int			sc_rdy_to;
	u_int			sc_mps_bits;
	size_t			sc_mps;
	size_t			sc_mdts;
	u_int			sc_max_sgl;
	u_int			sc_dstrd;

	struct nvm_identify_controller
				sc_identify;

	u_int			sc_nn;
	struct nvme_namespace	*sc_namespaces;

	struct nvme_queue	*sc_admin_q;
	struct nvme_queue	*sc_q;
	struct nvme_queue	*sc_hib_q;

	struct mutex		sc_ccb_mtx;
	struct nvme_ccb		*sc_ccbs;
	struct nvme_ccb_list	sc_ccb_list;
	struct nvme_dmamem	*sc_ccb_prpls;
	struct scsi_iopool	sc_iopool;

	struct scsi_link	sc_link;
	struct scsibus_softc	*sc_scsibus;
};

int	nvme_attach(struct nvme_softc *);
int	nvme_activate(struct nvme_softc *, int);
int	nvme_intr(void *);
int	nvme_intr_intx(void *);

#define DEVNAME(_sc) ((_sc)->sc_dev.dv_xname)
@


1.10
log
@nvme: Add suspend/resume code

Based on an initial patch by ehrhardt@@ . Thanks to claudio@@ for testing
and deraadt@@ for advice.

"go ahead" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.9 2016/10/25 06:20:41 dlg Exp $ */
d19 3
d96 1
@


1.9
log
@mask and unmask the interrupt source in an intx specific intr handler.

it seems devices using levelled intx interrupts need to explicitely ack
interrupts by masking and unmasking the source around the completion
ring handling. without this completions can be lost, which in turn
causes long (permanent?) stalls in the block layer under heavy write
load.

ive experienced this problem with an intel nvme part that only has
intx and msix support. because we dont support msix yet we only
use intx on it. it appeared to lock up before this fix.

this has been tested on both that intel board and a samsung with msi.
this fix was based on work found in code by nonaka
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.8 2016/04/14 11:18:32 dlg Exp $ */
d79 1
d83 1
@


1.8
log
@provide a shutdown hook that follows the procedure in the docs
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.7 2016/04/14 00:10:37 dlg Exp $ */
d105 1
@


1.7
log
@tabs, not spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.2 2014/04/15 10:28:07 dlg Exp $ */
d42 4
d95 1
d103 1
@


1.6
log
@wire up the scsi midlayer. scsibus should appear after this.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.5 2016/04/13 12:21:15 dlg Exp $ */
d82 2
a83 2
	u_int                   sc_nn;
	struct nvme_namespace   *sc_namespaces;
@


1.5
log
@allocate an array of things to hold info about namespaces

so far the only useful info is namespace identify info
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.4 2016/04/13 12:14:12 dlg Exp $ */
d92 3
@


1.4
log
@stash the controller identify and number of namespaces in the softc.

the nn is used to size the scsi bus, and the controller identify is used
to build responses for various scsi commands.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.2 2014/04/15 10:28:07 dlg Exp $ */
d60 4
d83 1
@


1.3
log
@make a place for q_id to go
@
text
@d75 5
@


1.2
log
@i wanted to work on this in the tree so i could commit lots of small
steps, but unfortunately the next step after "talk to the chips
registers" was "get command queues working" which ended up being a
huge amount of plumbing.

anyway, this lets me successfully run an identify controller command
against the chip and should be cut up the right way to be usable
for io command submissions. will need to think about how to avoid
overflowing rings though.
@
text
@d1 1
a1 1
/*	$OpenBSD: nvmevar.h,v 1.1 2014/04/12 05:06:58 dlg Exp $ */
d53 1
@


1.1
log
@start working on a driver for non volatile memory express controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: mpivar.h,v 1.36 2013/01/17 10:34:37 dlg Exp $ */
d26 1
d30 16
d47 2
d53 4
a56 3
	u_int			q_entries;
	u_int			q_sq_head;
	u_int			q_cq_tail;
d70 3
d76 5
@

