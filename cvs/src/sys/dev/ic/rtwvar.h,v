head	1.31;
access;
symbols
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.6
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.22
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.14
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.18
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.16
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.12
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.10
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.8
	OPENBSD_5_0:1.30.0.4
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.25.0.4
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.24.0.4
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.24.0.2
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.23.0.4
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8;
locks; strict;
comment	@ * @;


1.31
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.30;
commitid	YT6fyIEviv9qwbl6;

1.30
date	2010.09.07.16.21.43;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.29.16.46.58;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.27;

1.27
date	2009.08.10.22.10.07;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2009.07.28.11.45.05;	author blambert;	state Exp;
branches;
next	1.25;

1.25
date	2009.06.10.18.41.07;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.07.20.20.15;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.27.04.25.12;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2006.01.05.05.36.06;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.04.14.04.33;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2005.10.24.02.53.32;	author reyk;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.24.02.46.08;	author reyk;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.23.12.57.43;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2005.10.23.08.47.14;	author reyk;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.15.00.33.48;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2005.09.14.23.20.17;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.15.01.33.50;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.29.06.03.11;	author reyk;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.29.03.49.52;	author reyk;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.29.02.54.51;	author reyk;	state Exp;
branches;
next	1.9;

1.9
date	2005.05.26.05.41.45;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.02.11.14.12;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.19.03.33.30;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2005.02.14.12.49.29;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2005.01.22.11.22.18;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2005.01.22.10.14.25;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2005.01.19.11.07.33;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2005.01.19.09.36.18;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2004.12.29.01.02.31;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@/*	$OpenBSD: rtwvar.h,v 1.30 2010/09/07 16:21:43 deraadt Exp $	*/
/*	$NetBSD: rtwvar.h,v 1.10 2004/12/26 22:37:57 mycroft Exp $	*/

/*-
 * Copyright (c) 2004, 2005 David Young.  All rights reserved.
 *
 * Driver for the Realtek RTL8180 802.11 MAC/BBP by David Young.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of David Young may not be used to endorse or promote
 *    products derived from this software without specific prior
 *    written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY David Young ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
 * PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL David
 * Young BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
 * OF SUCH DAMAGE.
 */

#ifndef _DEV_IC_RTWVAR_H_
#define	_DEV_IC_RTWVAR_H_

#include <sys/device.h>
#include <sys/queue.h>
#include <sys/timeout.h>

#ifdef RTW_DEBUG
#define	RTW_DEBUG_TUNE		0x0000001
#define	RTW_DEBUG_PKTFILT	0x0000002
#define	RTW_DEBUG_XMIT		0x0000004
#define	RTW_DEBUG_XMIT_DESC	0x0000008
#define	RTW_DEBUG_NODE		0x0000010
#define	RTW_DEBUG_PWR		0x0000020
#define	RTW_DEBUG_ATTACH	0x0000040
#define	RTW_DEBUG_REGDUMP	0x0000080
#define	RTW_DEBUG_ACCESS	0x0000100
#define	RTW_DEBUG_RESET		0x0000200
#define	RTW_DEBUG_INIT		0x0000400
#define	RTW_DEBUG_IOSTATE	0x0000800
#define	RTW_DEBUG_RECV		0x0001000
#define	RTW_DEBUG_RECV_DESC	0x0002000
#define	RTW_DEBUG_IO_KICK	0x0004000
#define	RTW_DEBUG_INTR		0x0008000
#define	RTW_DEBUG_PHY		0x0010000
#define	RTW_DEBUG_PHYIO		0x0020000
#define	RTW_DEBUG_PHYBITIO	0x0040000
#define	RTW_DEBUG_TIMEOUT	0x0080000
#define	RTW_DEBUG_BUGS		0x0100000
#define	RTW_DEBUG_BEACON	0x0200000
#define	RTW_DEBUG_LED		0x0400000
#define	RTW_DEBUG_KEY		0x0800000
#define	RTW_DEBUG_XMIT_RSRC	0x1000000
#define	RTW_DEBUG_OACTIVE	0x2000000
#define	RTW_DEBUG_MAX		0x3ffffff

extern int rtw_debug;
#define RTW_DPRINTF(__flags, __x)	\
	if ((rtw_debug & (__flags)) != 0) printf __x
#define	DPRINTF(__sc, __flags, __x)				\
	if (((__sc)->sc_ic.ic_if.if_flags & IFF_DEBUG) != 0)	\
		RTW_DPRINTF(__flags, __x)
#else /* RTW_DEBUG */
#define RTW_DPRINTF(__flags, __x)
#define	DPRINTF(__sc, __flags, __x)
#endif /* RTW_DEBUG */

#define	KASSERT2(__cond, __msg)		\
	do {				\
		if (!(__cond))		\
			panic __msg ;	\
	} while (0)

enum rtw_locale {
	RTW_LOCALE_USA = 0,
	RTW_LOCALE_EUROPE,
	RTW_LOCALE_JAPAN,
	RTW_LOCALE_UNKNOWN
};

#define	RTW_RFCHIPID_RESERVED	0x00
#define	RTW_RFCHIPID_INTERSIL	0x01
#define	RTW_RFCHIPID_RFMD2948	0x02
#define	RTW_RFCHIPID_PHILIPS	0x03
#define	RTW_RFCHIPID_MAXIM2820	0x04
#define	RTW_RFCHIPID_GCT	0x05
#define	RTW_RFCHIPID_RFMD2958	0x06
#define	RTW_RFCHIPID_MAXIM2822	0x07
#define	RTW_RFCHIPID_MAXIM2825	0x08
#define	RTW_RFCHIPID_RTL8225	0x09
#define	RTW_RFCHIPID_RTL8255	0x0a

/* sc_flags */
#define RTW_F_ENABLED		0x00000001	/* chip is enabled */
#define RTW_F_DIGPHY		0x00000002	/* digital PHY */
#define RTW_F_DFLANTB		0x00000004	/* B antenna is default */
#define RTW_F_RTL8185		0x00000008	/* RTL8185 or newer */
#define RTW_F_ANTDIV		0x00000010	/* h/w antenna diversity */
#define RTW_F_9356SROM		0x00000020	/* 93c56 SROM */
#define RTW_F_SLEEP		0x00000040	/* chip is asleep */
#define RTW_F_INVALID		0x00000080	/* chip is absent */
	/* all PHY flags */
#define RTW_F_ALLPHY		(RTW_F_DIGPHY|RTW_F_DFLANTB|RTW_F_ANTDIV)

enum rtw_access {
	RTW_ACCESS_NONE = 0,
	RTW_ACCESS_CONFIG = 1,
	RTW_ACCESS_ANAPARM = 2
};

struct rtw_regs {
	bus_space_tag_t		r_bt;
	bus_space_handle_t	r_bh;
	enum rtw_access		r_access;
	void			*r_priv;

	/* bus independent I/O callbacks */
	u_int8_t	(*r_read8)(void *, u_int32_t);
	u_int16_t	(*r_read16)(void *, u_int32_t);
	u_int32_t	(*r_read32)(void *, u_int32_t);
	void		(*r_write8)(void *, u_int32_t, u_int8_t);
	void		(*r_write16)(void *, u_int32_t, u_int16_t);
	void		(*r_write32)(void *, u_int32_t, u_int32_t);
	void		(*r_barrier)(void *, u_int32_t, u_int32_t, int);
};

#define RTW_SR_GET(sr, ofs) \
    (((sr)->sr_content[(ofs)/2] >> (((ofs) % 2 == 0) ? 0 : 8)) & 0xff)

#define RTW_SR_GET16(sr, ofs) \
    (RTW_SR_GET((sr), (ofs)) | (RTW_SR_GET((sr), (ofs) + 1) << 8))

struct rtw_srom {
	u_int16_t		*sr_content;
	u_int16_t		sr_size;
};

struct rtw_rxsoft {
	struct mbuf			*rs_mbuf;
	bus_dmamap_t			rs_dmamap;
};

struct rtw_duration {
	uint16_t	d_rts_dur;
	uint16_t	d_data_dur;
	uint16_t	d_plcp_len;
	uint8_t		d_residue;	/* unused octets in time slot */
};

struct rtw_txsoft {
	SIMPLEQ_ENTRY(rtw_txsoft)	ts_q;
	struct mbuf			*ts_mbuf;
	bus_dmamap_t			ts_dmamap;
	struct ieee80211_node		*ts_ni;	/* destination node */
	u_int				ts_first;	/* 1st hw descriptor */
	u_int				ts_last;	/* last hw descriptor */
	struct rtw_duration		ts_d0;
	struct rtw_duration		ts_dn;
};

#define RTW_NTXPRI	4	/* number of Tx priorities */
#define RTW_TXPRILO	0
#define RTW_TXPRIMD	1
#define RTW_TXPRIHI	2
#define RTW_TXPRIBCN	3	/* beacon priority */

#define RTW_MAXPKTSEGS		64	/* max 64 segments per Tx packet */

/* Note well: the descriptor rings must begin on RTW_DESC_ALIGNMENT
 * boundaries.  I allocate them consecutively from one buffer, so
 * just round up.
 */
#define RTW_TXQLENLO	64	/* low-priority queue length */
#define RTW_TXQLENMD	64	/* medium-priority */
#define RTW_TXQLENHI	64	/* high-priority */
#define RTW_TXQLENBCN	8	/* beacon */

#define RTW_NTXDESCLO	RTW_TXQLENLO
#define RTW_NTXDESCMD	RTW_TXQLENMD
#define RTW_NTXDESCHI	RTW_TXQLENHI
#define RTW_NTXDESCBCN	RTW_TXQLENBCN

#define RTW_NTXDESCTOTAL	(RTW_NTXDESCLO + RTW_NTXDESCMD + \
				 RTW_NTXDESCHI + RTW_NTXDESCBCN)

#define RTW_RXQLEN	64

struct rtw_rxdesc_blk {
	struct rtw_rxdesc	*rdb_desc;
	u_int			rdb_next;
	u_int			rdb_ndesc;
	bus_dma_tag_t		rdb_dmat;
	bus_dmamap_t		rdb_dmamap;
};

struct rtw_txdesc_blk {
	u_int			tdb_ndesc;
	u_int			tdb_next;
	u_int			tdb_nfree;
	bus_dma_tag_t		tdb_dmat;
	bus_dmamap_t		tdb_dmamap;
	bus_addr_t		tdb_physbase;
	bus_addr_t		tdb_ofs;
	bus_size_t		tdb_basereg;
	uint32_t		tdb_base;

	struct rtw_txdesc	*tdb_desc;
};

#define RTW_NEXT_IDX(__htc, __idx)	(((__idx) + 1) % (__htc)->tdb_ndesc)

#define RTW_NEXT_DESC(__htc, __idx) \
    ((__htc)->tdb_physbase + \
     sizeof(struct rtw_txdesc) * RTW_NEXT_IDX((__htc), (__idx)))

SIMPLEQ_HEAD(rtw_txq, rtw_txsoft);

struct rtw_txsoft_blk {
	/* dirty/free s/w descriptors */
	struct rtw_txq		tsb_dirtyq;
	struct rtw_txq		tsb_freeq;
	u_int			tsb_ndesc;
	int			tsb_tx_timer;
	struct rtw_txsoft	*tsb_desc;
	u_int8_t			tsb_poll;
};

struct rtw_descs {
	struct rtw_txdesc	hd_txlo[RTW_NTXDESCLO];
	struct rtw_txdesc	hd_txmd[RTW_NTXDESCMD];
	struct rtw_txdesc	hd_txhi[RTW_NTXDESCMD];
	struct rtw_rxdesc	hd_rx[RTW_RXQLEN];
	struct rtw_txdesc	hd_bcn[RTW_NTXDESCBCN];
};
#define RTW_DESC_OFFSET(ring, i)	offsetof(struct rtw_descs, ring[i])
#define RTW_RING_OFFSET(ring)		RTW_DESC_OFFSET(ring, 0)
#define RTW_RING_BASE(sc, ring)		((sc)->sc_desc_physaddr + \
					 RTW_RING_OFFSET(ring))

/* Radio capture format for RTL8180. */

#define RTW_RX_RADIOTAP_PRESENT					\
	((1 << IEEE80211_RADIOTAP_TSFT)			|	\
	 (1 << IEEE80211_RADIOTAP_FLAGS)		|	\
	 (1 << IEEE80211_RADIOTAP_RATE)			|	\
	 (1 << IEEE80211_RADIOTAP_CHANNEL)		|	\
	 (1 << IEEE80211_RADIOTAP_LOCK_QUALITY)		|	\
	 (1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL)		|	\
	 0)

struct rtw_rx_radiotap_header {
	struct ieee80211_radiotap_header	rr_ihdr;
	u_int64_t				rr_tsft;
	u_int8_t				rr_flags;
	u_int8_t				rr_rate;
	u_int16_t				rr_chan_freq;
	u_int16_t				rr_chan_flags;
	u_int16_t				rr_barker_lock;
	u_int8_t				rr_antsignal;
} __packed;

#define RTW_TX_RADIOTAP_PRESENT				\
	((1 << IEEE80211_RADIOTAP_FLAGS)	|	\
	 (1 << IEEE80211_RADIOTAP_RATE)		|	\
	 (1 << IEEE80211_RADIOTAP_CHANNEL)	|	\
	 0)

struct rtw_tx_radiotap_header {
	struct ieee80211_radiotap_header	rt_ihdr;
	u_int8_t				rt_flags;
	u_int8_t				rt_rate;
	u_int16_t				rt_chan_freq;
	u_int16_t				rt_chan_flags;
} __packed;

struct rtw_mtbl {
	int			(*mt_newstate)(struct ieee80211com *,
					enum ieee80211_state, int);
	void			(*mt_recv_mgmt)(struct ieee80211com *,
				    struct mbuf *, struct ieee80211_node *,
				    struct ieee80211_rxinfo *, int);
	struct ieee80211_node	*(*mt_node_alloc)(struct ieee80211com *);
	void			(*mt_node_free)(struct ieee80211com *,
					struct ieee80211_node *);
};

enum rtw_pwrstate { RTW_OFF = 0, RTW_SLEEP, RTW_ON };

struct rtw_phy {
	struct rtw_rf	*p_rf;
	struct rtw_regs	*p_regs;
};

struct rtw_bbpset {
	u_int	bb_antatten;
	u_int	bb_chestlim;
	u_int	bb_chsqlim;
	u_int	bb_ifagcdet;
	u_int	bb_ifagcini;
	u_int	bb_ifagclimit;
	u_int	bb_lnadet;
	u_int	bb_sys1;
	u_int	bb_sys2;
	u_int	bb_sys3;
	u_int	bb_trl;
	u_int	bb_txagc;
};

typedef int (*rtw_rf_write_t)(struct rtw_regs *, int, u_int,
    u_int32_t);

typedef void (*rtw_pwrstate_t)(struct rtw_regs *, enum rtw_pwrstate, int, int);

union rtw_keys {
	u_int8_t	rk_keys[4][16];
	u_int32_t	rk_words[16];
};

#define	RTW_LED_SLOW_MSEC	500
#define	RTW_LED_FAST_MSEC	100

struct rtw_led_state {
#define	RTW_LED0	0x1
#define	RTW_LED1	0x2
	u_int8_t	ls_slowblink:2;
	u_int8_t	ls_actblink:2;
	u_int8_t	ls_default:2;
	u_int8_t	ls_state;
	u_int8_t	ls_event;
#define	RTW_LED_S_RX	0x1
#define	RTW_LED_S_TX	0x2
#define	RTW_LED_S_SLOW	0x4
	struct timeout	ls_slow_ch;
	struct timeout	ls_fast_ch;
};

struct rtw_softc {
	struct device		sc_dev;
	struct ieee80211com	sc_ic;
	struct rtw_regs		sc_regs;
	bus_dma_tag_t		sc_dmat;
	u_int32_t		sc_flags;

	int			sc_rfchipid;
	enum rtw_locale		sc_locale;
	u_int8_t		sc_phydelay;
	struct rtw_bbpset       sc_bbpset;

	/* s/w Tx/Rx descriptors */
	struct rtw_txsoft_blk	sc_txsoft_blk[RTW_NTXPRI];
	struct rtw_txdesc_blk	sc_txdesc_blk[RTW_NTXPRI];

	struct rtw_rxsoft	sc_rxsoft[RTW_RXQLEN];
	struct rtw_rxdesc_blk	sc_rxdesc_blk;

	struct rtw_descs	*sc_descs;

	bus_dma_segment_t	sc_desc_segs;
	int			sc_desc_nsegs;
	bus_dmamap_t		sc_desc_dmamap;
#define	sc_desc_physaddr sc_desc_dmamap->dm_segs[0].ds_addr

	struct rtw_srom		sc_srom;

	enum rtw_pwrstate	sc_pwrstate;

	rtw_pwrstate_t		sc_pwrstate_cb;

	u_int16_t		sc_inten;
	int			(*sc_rf_init)(struct rtw_softc *, u_int,
				    u_int8_t, enum rtw_pwrstate);
	int			(*sc_rf_pwrstate)(struct rtw_softc *,
				    enum rtw_pwrstate);
	int			(*sc_rf_tune)(struct rtw_softc *, u_int);
	int			(*sc_rf_txpower)(struct rtw_softc *, u_int8_t);

	/* interrupt acknowledge hook */
	void			(*sc_intr_ack)(struct rtw_regs *);

	int			(*sc_enable)(struct rtw_softc *);
	void			(*sc_disable)(struct rtw_softc *);
	void			(*sc_power)(struct rtw_softc *, int);
	struct rtw_mtbl		sc_mtbl;

	caddr_t			sc_radiobpf;

	struct timeval		sc_last_beacon;
	struct timeout		sc_scan_to;
	u_int			sc_cur_chan;

	u_int32_t		sc_tsfth;	/* most significant TSFT bits */
	u_int32_t		sc_rcr;		/* RTW_RCR */
	u_int8_t		sc_csthr;	/* carrier-sense threshold */

	int			sc_do_tick;	/* indicate 1s ticks */
	struct timeval		sc_tick0;	/* first tick */

	u_int8_t		sc_rev;		/* PCI/Cardbus revision */

	u_int32_t		sc_anaparm[2];	/* RTW_ANAPARM_? registers */

	union {
		struct rtw_rx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_rxtapu;
	union {
		struct rtw_tx_radiotap_header	tap;
		u_int8_t			pad[64];
	} sc_txtapu;
	union rtw_keys		sc_keys;
	int			sc_txkey;
	struct mbuf_queue	sc_beaconq;
	struct rtw_led_state	sc_led_state;
	u_int			sc_hwverid;
};

#define	sc_if		sc_ic.ic_if
#define sc_rxtap	sc_rxtapu.tap
#define sc_txtap	sc_txtapu.tap

extern int rtw_host_rfio;

void rtw_txdac_enable(struct rtw_softc *, int);
void rtw_anaparm_enable(struct rtw_regs *, int);
void rtw_config0123_enable(struct rtw_regs *, int);
void rtw_continuous_tx_enable(struct rtw_softc *, int);
void rtw_set_access(struct rtw_regs *, enum rtw_access);

void rtw_attach(struct rtw_softc *);
int rtw_detach(struct rtw_softc *);
int rtw_intr(void *);

void rtw_disable(struct rtw_softc *);
int rtw_enable(struct rtw_softc *);

int rtw_activate(struct device *, int);
void rtw_shutdown(void *);

const char *rtw_pwrstate_string(enum rtw_pwrstate);

#endif /* _DEV_IC_RTWVAR_H_ */
@


1.30
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.29 2010/08/29 16:46:58 deraadt Exp $	*/
d426 1
a426 1
	struct ifqueue		sc_beaconq;
@


1.29
log
@Massage the powerhook functions into activate functions, and then call
them from the powerhook.  Fix a few quibbles about the things done for
the IFF_RUNNING and IFF_UP cases
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.28 2009/10/13 19:33:16 pirofti Exp $	*/
a289 4
struct rtw_hooks {
	void			*rh_power;	/* power management hook */
};

a397 1
	struct rtw_hooks	sc_hooks;
a450 1
void rtw_powerhook(int, void *);
@


1.28
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.27 2009/08/10 22:10:07 deraadt Exp $	*/
d456 1
a456 1
void rtw_power(int, void *);
@


1.27
log
@hook no longer needed
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.26 2009/07/28 11:45:05 blambert Exp $	*/
d455 1
a455 1
int rtw_activate(struct device *, enum devact);
@


1.26
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.25 2009/06/10 18:41:07 miod Exp $	*/
a290 1
	void			*rh_shutdown;	/* shutdown hook */
@


1.25
log
@Remove (unused) CASSERT macro. Whatever it was intended to be used for, it
caused severe blood damage to laboratory animals. Not to mention swine flu.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.24 2008/07/21 18:43:19 damien Exp $	*/
d338 2
a339 2
#define	RTW_LED_SLOW_TICKS	MAX(1, hz/2)
#define	RTW_LED_FAST_TICKS	MAX(1, hz/10)
@


1.24
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.23 2007/06/07 20:20:15 damien Exp $	*/
a181 3

#define CASSERT(cond, complaint)					\
	complaint[(cond) ? 0 : -1] = complaint[(cond) ? 0 : -1]
@


1.23
log
@move ieee80211_compute_duration() and ieee80211_compute_duration1()
functions into the two drivers that use them (atw and rtw.)
this code is not generic enough to be used by other drivers and
there is no chance that it will ever be used in newer driver since
it supports 802.11b only.
plus, it hurts my eyes each time i look into ieee80211_output.c.

"fine with me as long as the logic doesn't change in the functions" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.22 2006/06/27 04:25:12 jsg Exp $	*/
d303 1
a303 1
				    int, int, u_int32_t);
@


1.22
log
@__attribute__((__packed__)) -> __packed
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.21 2006/01/05 05:36:06 jsg Exp $	*/
d157 7
d171 2
a172 2
	struct ieee80211_duration	ts_d0;
	struct ieee80211_duration	ts_dn;
@


1.21
log
@part of rev 1.58 of rtw.c David Young comitted to NetBSD:

Miscellaneous Realtek RTL8180L driver improvements:

3 Revamp handling of transmit descriptor rings.

4 Reliably IFF_OACTIVE when transmit descriptors are available, to
  stop the transmit section of the driver from freezing up.

5 Fix beacon transmission in adhoc and hostap modes.  XXX There is
  a wart in hostap mode, where beacons are transmitted at 1/2 the
  correct rate.  Load beacon descriptors when the RTW_INTR_BINT
  interrupt arrives; schedule RTW_INTR_BINT 1ms ahead of the target
  beacon time.

6 Recover more gracefully from tx/rx errors: avoid
  transmitter/receiver/chip resets.  Try to re-synchronize software
  state with hardware state---e.g., load next descriptor pointer
  from hardware.

7 Activate the transmit watchdog timer for beacons as well as other
  packets.

8 Introduce rtw_idle() that waits for transmit DMA to finish; call
  it before resetting the transmitter.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.20 2005/11/04 14:04:33 jsg Exp $	*/
d270 1
a270 1
} __attribute__((__packed__));
d284 1
a284 1
} __attribute__((__packed__));
@


1.20
log
@Move access to RF tranceiver functions to be via callbacks.
"looks fine" reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.19 2005/10/24 02:53:32 reyk Exp $	*/
d43 27
a69 24
#define	RTW_DEBUG_TUNE		0x000001
#define	RTW_DEBUG_PKTFILT	0x000002
#define	RTW_DEBUG_XMIT		0x000004
#define	RTW_DEBUG_XMIT_DESC	0x000008
#define	RTW_DEBUG_NODE		0x000010
#define	RTW_DEBUG_PWR		0x000020
#define	RTW_DEBUG_ATTACH	0x000040
#define	RTW_DEBUG_REGDUMP	0x000080
#define	RTW_DEBUG_ACCESS	0x000100
#define	RTW_DEBUG_RESET		0x000200
#define	RTW_DEBUG_INIT		0x000400
#define	RTW_DEBUG_IOSTATE	0x000800
#define	RTW_DEBUG_RECV		0x001000
#define	RTW_DEBUG_RECV_DESC	0x002000
#define	RTW_DEBUG_IO_KICK	0x004000
#define	RTW_DEBUG_INTR		0x008000
#define	RTW_DEBUG_PHY		0x010000
#define	RTW_DEBUG_PHYIO		0x020000
#define	RTW_DEBUG_PHYBITIO	0x040000
#define	RTW_DEBUG_TIMEOUT	0x080000
#define	RTW_DEBUG_BUGS		0x100000
#define	RTW_DEBUG_BEACON	0x200000
#define	RTW_DEBUG_LED		0x400000
#define	RTW_DEBUG_MAX		0x7fffff
d186 1
a186 1
#define RTW_TXQLENBCN	1	/* beacon */
d214 3
@


1.19
log
@change read/write callbacks to use a void * instead of struct rtw_regs.
why? rtw uses the smc93cx6 EEPROM and a separate diff will allow
accessing it without depending on the bus_space_* functions. this is
required for the RTL8187L.

discussed with jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.18 2005/10/24 02:46:08 reyk Exp $	*/
d379 6
@


1.18
log
@two sc_anaparm registers
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.17 2005/10/23 12:57:43 jsg Exp $	*/
d129 7
a135 7
	u_int8_t	(*r_read8)(struct rtw_regs *, u_int32_t);
	u_int16_t	(*r_read16)(struct rtw_regs *, u_int32_t);
	u_int32_t	(*r_read32)(struct rtw_regs *, u_int32_t);
	void		(*r_write8)(struct rtw_regs *, u_int32_t, u_int8_t);
	void		(*r_write16)(struct rtw_regs *, u_int32_t, u_int16_t);
	void		(*r_write32)(struct rtw_regs *, u_int32_t, u_int32_t);
	void		(*r_barrier)(struct rtw_regs *, u_int32_t, u_int32_t, int);
@


1.17
log
@Move rtw_attach error condition handling out of rtw_detach and into
rtw_attach simplifying things in the process. ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.16 2005/10/23 08:47:14 reyk Exp $	*/
d404 1
a404 1
	u_int32_t		sc_anaparm;	/* register RTW_ANAPARM */
@


1.16
log
@use read/write/barrier callbacks, will be used later

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.15 2005/09/15 00:33:48 jsg Exp $	*/
a84 6
#define NEXT_ATTACH_STATE(sc, state) do {			\
	DPRINTF(sc, RTW_DEBUG_ATTACH,				\
	    ("%s: attach state %s\n", __func__, #state));	\
	sc->sc_attach_state = state;				\
} while (0)

a279 6
enum rtw_attach_state {FINISHED, FINISH_DESCMAP_LOAD, FINISH_DESCMAP_CREATE,
	FINISH_DESC_MAP, FINISH_DESC_ALLOC, FINISH_RXMAPS_CREATE,
	FINISH_TXMAPS_CREATE, FINISH_RESET, FINISH_READ_SROM, FINISH_PARSE_SROM,
	FINISH_RF_ATTACH, FINISH_ID_STA, FINISH_TXDESCBLK_SETUP,
	FINISH_TXCTLBLK_SETUP, DETACHED};

a352 1
	enum rtw_attach_state	sc_attach_state;
@


1.15
log
@Remove rtw_rfbus_write abstraction for readability.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.14 2005/09/14 23:20:17 jsg Exp $	*/
d132 10
@


1.14
log
@Remove rtw_rf/rtw_rfbus and some other related abstractions
which made things overly complicated.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.13 2005/06/15 01:33:50 jsg Exp $	*/
a359 1
	rtw_rf_write_t		sc_rf_write;
@


1.13
log
@Match RTL8255 transceiver and stub out related support functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.12 2005/05/29 06:03:11 reyk Exp $	*/
d98 11
a108 13
enum rtw_rfchipid {
	RTW_RFCHIPID_RESERVED	= 0x00,
	RTW_RFCHIPID_INTERSIL	= 0x01,
	RTW_RFCHIPID_RFMD2948	= 0x02,
	RTW_RFCHIPID_PHILIPS	= 0x03,
	RTW_RFCHIPID_MAXIM2820	= 0x04,
	RTW_RFCHIPID_GCT	= 0x05,
	RTW_RFCHIPID_RFMD2958	= 0x06,
	RTW_RFCHIPID_MAXIM2822	= 0x07,
	RTW_RFCHIPID_MAXIM2825	= 0x08,
	RTW_RFCHIPID_RTL8225	= 0x09,
	RTW_RFCHIPID_RTL8255	= 0x0a
};
a299 2
typedef void (*rtw_continuous_tx_cb_t)(void *arg, int);

d320 1
a320 17
struct rtw_rf {
	void	(*rf_destroy)(struct rtw_rf *);
	/* args: frequency, txpower, power state */
	int	(*rf_init)(struct rtw_rf *, u_int, u_int8_t,
		    enum rtw_pwrstate);
	/* arg: power state */
	int	(*rf_pwrstate)(struct rtw_rf *, enum rtw_pwrstate);
	/* arg: frequency */
	int	(*rf_tune)(struct rtw_rf *, u_int);
	/* arg: txpower */
	int	(*rf_txpower)(struct rtw_rf *, u_int8_t);
	rtw_continuous_tx_cb_t	rf_continuous_tx_cb;
	void			*rf_continuous_tx_arg;
	struct rtw_bbpset	rf_bbpset;
};

typedef int (*rtw_rf_write_t)(struct rtw_regs *, enum rtw_rfchipid, u_int,
a322 34
struct rtw_rfbus {
	struct rtw_regs		*b_regs;
	rtw_rf_write_t		b_write;
};

void rtw_rf_destroy(struct rtw_rf *);
int rtw_rf_init(struct rtw_rf *, u_int, u_int8_t, enum rtw_pwrstate);
int rtw_rf_pwrstate(struct rtw_rf *, enum rtw_pwrstate);
int rtw_rf_tune(struct rtw_rf *, u_int);
int rtw_rf_txpower(struct rtw_rf *, u_int8_t);
int rtw_rfbus_write(struct rtw_rfbus *, enum rtw_rfchipid, u_int, u_int32_t);

struct rtw_max2820 {
	struct rtw_rf		mx_rf;
	struct rtw_rfbus	mx_bus;
	int			mx_is_a;	/* 1: MAX2820A/MAX2821A */
};

struct rtw_sa2400 {
	struct rtw_rf		sa_rf;
	struct rtw_rfbus	sa_bus;
	int			sa_digphy;	/* 1: digital PHY */
};

struct rtw_rtl8225 {
	struct rtw_rf		rt_rf;
	struct rtw_rfbus	rt_bus;
};

struct rtw_rtl8255 {
	struct rtw_rf		rt_rf;
	struct rtw_rfbus	rt_bus;
};

d356 1
a356 1
	enum rtw_rfchipid	sc_rfchipid;
d359 2
a380 2

	struct rtw_rf		*sc_rf;
@


1.12
log
@use JAPAN for locale code 0 stored in some rtw EEPROMs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.11 2005/05/29 03:49:52 reyk Exp $	*/
d99 11
a109 10
	RTW_RFCHIPID_RESERVED = 0,
	RTW_RFCHIPID_INTERSIL = 1,
	RTW_RFCHIPID_RFMD2948 = 2,
	RTW_RFCHIPID_PHILIPS = 3,
	RTW_RFCHIPID_MAXIM2820 = 4,
	RTW_RFCHIPID_GCT = 5,
	RTW_RFCHIPID_RFMD2958 = 6,
	RTW_RFCHIPID_MAXIM2822 = 7,
	RTW_RFCHIPID_MAXIM2825 = 8,
	RTW_RFCHIPID_RTL8225 = 9
d368 5
@


1.11
log
@knf
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.10 2005/05/29 02:54:51 reyk Exp $	*/
d115 1
a119 1
#define RTW_F_RTL8185		0x00000100	/* RTL8185 or newer */
@


1.10
log
@cleanup rtw
@
text
@d1 3
a3 2
/*	$OpenBSD: rtwvar.h,v 1.9 2005/05/26 05:41:45 jsg Exp $	*/
/* $NetBSD: rtwvar.h,v 1.10 2004/12/26 22:37:57 mycroft Exp $ */
d109 1
a109 1
}; 
d170 2
a171 1
#define CASSERT(cond, complaint) complaint[(cond) ? 0 : -1] = complaint[(cond) ? 0 : -1]
d327 1
a327 1
	                  enum rtw_pwrstate);
d433 1
a433 1
	void (*sc_intr_ack)(struct rtw_regs *);
@


1.9
log
@Fix compilation on macppc and likely other archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.8 2005/03/02 11:14:12 jsg Exp $	*/
d78 12
d100 1
a100 1
	RTW_RFCHIPID_RFMD = 2,
d102 6
a107 2
	RTW_RFCHIPID_MAXIM = 4,
	RTW_RFCHIPID_GCT = 5
d118 1
d364 5
d468 1
a468 1
	int			sc_hwverid;
@


1.8
log
@radiotap support largely based on NetBSD rtw.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.7 2005/02/19 03:33:30 jsg Exp $	*/
d37 1
@


1.7
log
@From part of NetBSD rtw.c rev 1.42:
log message:
Program the LEDs based on operating state and packet activity.

 * On a Revision F RTL8180, blink LED1 at 1Hz to indicate
   scan/authenticate/associate states.  In the run state, turn LED1
   on.  In every state, blink LED1 at 5Hz to indicate non-beacon
   tx/rx activity.  I would like to use two LEDs, but in all my
   Rev. F instances, LED0 is not wired to an LED; instead, the
   first LED is wired to indicate that the card's power is on.

 * On a Revision D RTL8180, program the LEDs so that LED0 indicates
   Tx, and LED1 indicates Rx.  The Rx LED will blink annoyingly if
   there are beacons in the air, but at least the Tx LED is useful.

 * Store the hardware revision in the softc to support my futile
   attempt at programming LEDs for both Rev. D and Rev. F parts;
   I never did get Rev. D LEDs to work right.

 * Add a debug flag RTW_DEBUG_LED for the LED transitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.6 2005/02/14 12:49:29 jsg Exp $	*/
d206 1
a206 1
	uint8_t			tsb_poll;
d223 8
a230 4
#define RTW_RX_RADIOTAP_PRESENT	\
	((1 << IEEE80211_RADIOTAP_FLAGS) | (1 << IEEE80211_RADIOTAP_RATE) | \
	 (1 << IEEE80211_RADIOTAP_CHANNEL) | \
	 (1 << IEEE80211_RADIOTAP_DB_ANTSIGNAL))
d234 1
d239 1
d243 5
a247 3
#define RTW_TX_RADIOTAP_PRESENT	((1 << IEEE80211_RADIOTAP_FLAGS) | \
				 (1 << IEEE80211_RADIOTAP_RATE) | \
				 (1 << IEEE80211_RADIOTAP_CHANNEL))
@


1.6
log
@From NetBSD:

From part of rtw.c rev 1.42:
log message:

Add RTW_TPPOLL_ALL, RTW_TPPOLL_SALL to start and stop, respectively,
all of the transmit rings.

Revamp the transmit section to make better use of all the transmit
rings:  beacon queue, high-, low-, and medium-priority rings.  Put
beacon frames on the beacon ring.  All other management frames,
and data frames, go on the medium-priority ring.  Power-save data
frames go on the high-priority ring.  (Note that powersaving is
not implemented!)  This is a work in progress.

Send all 802.11 Management frames at 1Mbps.

After we put a packet on a transmit ring, tickle the right bit in
the TPPOLL to tell RTL8180.  Stop all rings on error and in rtw_stop.

And rtw.c rev 1.33:
log message:

Consolidate variables related to the rx ring in sc_rxdesc_blk,
which is a struct rtw_rxdesc_blk.

Put a copy of the DMA tag and the DMA map into the rx- and tx-ring
blocks so that I don't have to pass them to subroutines all of the
time.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.5 2005/01/22 11:22:18 jsg Exp $	*/
d62 3
a64 2
#define RTW_DEBUG_BEACON	0x200000
#define	RTW_DEBUG_MAX		0x3fffff
a76 9
#if 0
enum rtw_rftype {
	RTW_RFTYPE_INTERSIL = 0,
	RTW_RFTYPE_RFMD,
	RTW_RFTYPE_PHILIPS,
	RTW_RFTYPE_MAXIM
};
#endif

d340 23
a369 3
#if 0
	enum rtw_rftype		sc_rftype;
#endif
d433 1
d436 1
@


1.5
log
@Reduce diff to NetBSD.
From part of rtw.c rev 1.42:
Move the register access mode into struct rtw_regs.  Change
rtw_set_access, rtw_set_access1 to match.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.4 2005/01/22 10:14:25 jsg Exp $	*/
d62 2
a63 1
#define	RTW_DEBUG_MAX		0x1fffff
d180 8
d192 2
d214 1
a333 1

d365 2
d368 1
a368 6
	u_int			sc_txq;
	u_int			sc_txnext;

	struct rtw_txdesc_blk	sc_txdesc_blk[RTW_NTXPRI];
	struct rtw_rxdesc	*sc_rxdesc;
	u_int			sc_rxnext;
d388 1
a388 1
	void (*sc_intr_ack) __P((struct rtw_regs *));
d421 2
a422 2
	enum rtw_access		sc_access;
	
@


1.4
log
@Reduce diff to NetBSD.
From rtw.c rev 1.34:

I like the tlp/atw-style names for software descriptors, txsoft,
better than txctl.  Change from rtw_txctl/rtw_rxctl to
rtw_txsoft/rtw_rxsoft.  Change the descriptor blocks' names to
match: rtw_txctl_blk becomes rtw_txsoft_blk.  Change the member-name
prefixes for both software and hardware descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.3 2005/01/19 11:07:33 jsg Exp $	*/
d111 6
d120 1
a336 4
enum rtw_access {RTW_ACCESS_NONE = 0,
		 RTW_ACCESS_CONFIG = 1,
		 RTW_ACCESS_ANAPARM = 2};

d428 1
a428 1
void rtw_set_access(struct rtw_softc *, enum rtw_access);
@


1.3
log
@destatic functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.2 2005/01/19 09:36:18 jsg Exp $	*/
d127 3
a129 3
struct rtw_rxctl {
	struct mbuf			*srx_mbuf;
	bus_dmamap_t			srx_dmamap;
d132 9
a140 9
struct rtw_txctl {
	SIMPLEQ_ENTRY(rtw_txctl)	stx_q;
	struct mbuf			*stx_mbuf;
	bus_dmamap_t			stx_dmamap;
	struct ieee80211_node		*stx_ni;	/* destination node */
	u_int				stx_first;	/* 1st hw descriptor */
	u_int				stx_last;	/* last hw descriptor */
	struct ieee80211_duration	stx_d0;
	struct ieee80211_duration	stx_dn;
d173 6
a178 6
	u_int			htc_ndesc;
	u_int			htc_next;
	u_int			htc_nfree;
	bus_addr_t		htc_physbase;
	bus_addr_t		htc_ofs;
	struct rtw_txdesc	*htc_desc;
d181 1
a181 1
#define RTW_NEXT_IDX(__htc, __idx)	(((__idx) + 1) % (__htc)->htc_ndesc)
d184 1
a184 1
    ((__htc)->htc_physbase + \
d187 1
a187 1
SIMPLEQ_HEAD(rtw_txq, rtw_txctl);
d189 1
a189 1
struct rtw_txctl_blk {
d191 5
a195 5
	struct rtw_txq		stc_dirtyq;
	struct rtw_txq		stc_freeq;
	u_int			stc_ndesc;
	int			stc_tx_timer;
	struct rtw_txctl	*stc_desc;
d350 2
a351 2
	struct rtw_txctl_blk	sc_txctl_blk[RTW_NTXPRI];
	struct rtw_rxctl	sc_rxctl[RTW_RXQLEN];
@


1.2
log
@Use the RF chipset type rather than the hardware version when determining
whether to use host or MAC controlled RF I/O.

From part of NetBSD rev 1.42
@
text
@d1 1
a1 1
/*	$OpenBSD: rtwvar.h,v 1.1 2004/12/29 01:02:31 jsg Exp $	*/
a299 31
static __inline void
rtw_rf_destroy(struct rtw_rf *rf)
{
	(*rf->rf_destroy)(rf);
}

static __inline int
rtw_rf_init(struct rtw_rf *rf, u_int freq, u_int8_t opaque_txpower,
    enum rtw_pwrstate power)
{
	return (*rf->rf_init)(rf, freq, opaque_txpower, power);
}

static __inline int
rtw_rf_pwrstate(struct rtw_rf *rf, enum rtw_pwrstate power)
{
	return (*rf->rf_pwrstate)(rf, power);
}

static __inline int
rtw_rf_tune(struct rtw_rf *rf, u_int freq)
{
	return (*rf->rf_tune)(rf, freq);
}

static __inline int
rtw_rf_txpower(struct rtw_rf *rf, u_int8_t opaque_txpower)
{
	return (*rf->rf_txpower)(rf, opaque_txpower);
}

d308 7
a314 6
static __inline int
rtw_rfbus_write(struct rtw_rfbus *bus, enum rtw_rfchipid rfchipid, u_int addr,
    u_int32_t val)
{
	return (*bus->b_write)(bus->b_regs, rfchipid, addr, val);
}
@


1.1
log
@Driver for Realtek 802.11 devices from NetBSD.
Not yet working.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d441 2
@

