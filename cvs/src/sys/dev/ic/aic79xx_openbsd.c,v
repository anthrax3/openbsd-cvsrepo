head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.2
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.4
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.4
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.40.0.2
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.39.0.2
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.38.0.2
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.37
	OPENBSD_5_1:1.37.0.10
	OPENBSD_5_0:1.37.0.6
	OPENBSD_5_0_BASE:1.37
	OPENBSD_4_9:1.37.0.4
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.35.0.2
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.28.0.4
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.28.0.2
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.26.0.4
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.26.0.2
	OPENBSD_4_1_BASE:1.26
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.23.0.2
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.8.0.2
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	SMP:1.3.0.2;
locks; strict;
comment	@ * @;


1.45
date	2016.08.17.01.16.11;	author krw;	state Exp;
branches;
next	1.44;
commitid	mJdt5Xp4htkBtkXA;

1.44
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.43;
commitid	15xZY6veDWwRM6Iq;

1.43
date	2015.07.17.21.42.49;	author krw;	state Exp;
branches;
next	1.42;
commitid	bEhopXwWgYXDvWRJ;

1.42
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.41;
commitid	I19imNlAX05zJOED;

1.41
date	2014.01.17.23.23.58;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2012.12.05.23.20.16;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.01.20.08.40.41;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.30;

1.30
date	2008.11.25.18.10.00;	author krw;	state Exp;
branches;
next	1.29;

1.29
date	2008.11.24.00.31.35;	author krw;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.20.00.21.49;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.07.17.58.39;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.04.14.20.37;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2005.12.28.02.43.54;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.02.03.27.39;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.06.23.04.28;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.30.17.29.55;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.28.04.12.24;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2004.12.27.21.34.42;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2004.12.24.22.17.56;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2004.12.20.22.07.25;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.20.20.56.32;	author krw;	state Exp;
branches;
next	1.14;

1.14
date	2004.12.19.06.17.54;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.13.04.07.26;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.23.05.15.35;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.18.01.33.28;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.14.01.25.14;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.10.15.08.10;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2004.08.23.20.16.01;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2004.08.13.23.38.54;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2004.08.06.01.29.19;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2004.06.22.22.40.35;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2004.06.21.18.33.04;	author krw;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.25.12.22.49;	author krw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2004.05.20.04.35.47;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2004.05.20.03.11.45;	author marco;	state Exp;
branches;
next	;

1.3.2.1
date	2004.06.05.23.12.39;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Move to iopool. No voluntary testers after several years of requests so now
everybody gets to test!
@
text
@/*	$OpenBSD: aic79xx_openbsd.c,v 1.44 2016/03/19 11:34:22 mpi Exp $	*/

/*
 * Copyright (c) 2004 Milos Urbanek, Kenneth R. Westerback & Marco Peereboom
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Bus independent OpenBSD shim for the aic79xx based Adaptec SCSI controllers
 *
 * Copyright (c) 1994-2002 Justin T. Gibbs.
 * Copyright (c) 2001-2002 Adaptec Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions, and the following disclaimer,
 *    without modification.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Alternatively, this software may be distributed under the terms of the
 * GNU Public License ("GPL").
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <dev/ic/aic79xx_openbsd.h>
#include <dev/ic/aic79xx_inline.h>
#include <dev/ic/aic79xx.h>

#ifndef AHD_TMODE_ENABLE
#define AHD_TMODE_ENABLE 0
#endif

/* XXX milos add ahd_ioctl */
void	ahd_action(struct scsi_xfer *);
void	ahd_execute_scb(void *, bus_dma_segment_t *, int);
int	ahd_poll(struct ahd_softc *, int);
void	ahd_setup_data(struct ahd_softc *, struct scsi_xfer *,
		    struct scb *);

void	ahd_adapter_req_set_xfer_mode(struct ahd_softc *, struct scb *);
void    ahd_minphys(struct buf *, struct scsi_link *);

struct cfdriver ahd_cd = {
	NULL, "ahd", DV_DULL
};

static struct scsi_adapter ahd_switch =
{
	ahd_action,
	ahd_minphys,
	0,
	0,
};

/*
 * Attach all the sub-devices we can find
 */
int
ahd_attach(struct ahd_softc *ahd)
{
	struct scsibus_attach_args saa;
	char   ahd_info[256];
	int	s;

	ahd_controller_info(ahd, ahd_info, sizeof ahd_info);
	printf("%s\n", ahd_info);
	ahd_lock(ahd, &s);

	/*
	 * fill in the prototype scsi_links.
	 */
	ahd->sc_channel.adapter_target = ahd->our_id;
	if (ahd->features & AHD_WIDE)
		ahd->sc_channel.adapter_buswidth = 16;
	ahd->sc_channel.adapter_softc = ahd;
	ahd->sc_channel.adapter = &ahd_switch;
	ahd->sc_channel.openings = 16; /* Must ALWAYS be < 256!! */
	ahd->sc_channel.pool = &ahd->sc_iopool;

	if (bootverbose) {
		ahd_controller_info(ahd, ahd_info, sizeof ahd_info);
		printf("%s: %s\n", ahd->sc_dev.dv_xname, ahd_info);
	}

	ahd_intr_enable(ahd, TRUE);

	if (ahd->flags & AHD_RESET_BUS_A)
		ahd_reset_channel(ahd, 'A', TRUE);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &ahd->sc_channel;

	ahd->sc_child = config_found((void *)&ahd->sc_dev, &saa, scsiprint);

	ahd_unlock(ahd, &s);

	return (1);

}

/*
 * Catch an interrupt from the adapter
 */
int
ahd_platform_intr(void *arg)
{
	struct	ahd_softc *ahd;

	/* XXX in ahc there is some bus_dmamap_sync(PREREAD|PREWRITE); */

	ahd = (struct ahd_softc *)arg;
	return ahd_intr(ahd);
}

/*
 * We have an scb which has been processed by the
 * adaptor, now we look to see how the operation
 * went.
 */
void
ahd_done(struct ahd_softc *ahd, struct scb *scb)
{
	struct scsi_xfer *xs = scb->xs;

	/* XXX in ahc there is some bus_dmamap_sync(PREREAD|PREWRITE); */

	TAILQ_REMOVE(&ahd->pending_scbs, scb, next);

	timeout_del(&xs->stimeout);

	if (xs->datalen) {
		int op;

		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_POSTREAD;
		else
			op = BUS_DMASYNC_POSTWRITE;
		bus_dmamap_sync(ahd->parent_dmat, scb->dmamap, 0,
		    scb->dmamap->dm_mapsize, op);
		bus_dmamap_unload(ahd->parent_dmat, scb->dmamap);
	}

	/* Translate the CAM status code to a SCSI error code. */
	switch (xs->error) {
	case CAM_SCSI_STATUS_ERROR:
	case CAM_REQ_INPROG:
	case CAM_REQ_CMP:
		switch (xs->status) {
		case SCSI_TASKSET_FULL:
		case SCSI_BUSY:
			xs->error = XS_BUSY;
			break;
		case SCSI_CHECK:
		case SCSI_TERMINATED:
			if ((scb->flags & SCB_SENSE) == 0) {
				/* CHECK on CHECK? */
				xs->error = XS_DRIVER_STUFFUP;
			} else
				xs->error = XS_NOERROR;
			break;
		default:
			xs->error = XS_NOERROR;
			break;
		}
		break;
	case CAM_BUSY:
	case CAM_REQUEUE_REQ:
		xs->error = XS_BUSY;
		break;
	case CAM_CMD_TIMEOUT:
		xs->error = XS_TIMEOUT;
		break;
	case CAM_BDR_SENT:
	case CAM_SCSI_BUS_RESET:
		xs->error = XS_RESET;
		break;
	case CAM_SEL_TIMEOUT:
		xs->error = XS_SELTIMEOUT;
		break;
	default:
		xs->error = XS_DRIVER_STUFFUP;
		break;
	}

	if (xs->error != XS_NOERROR) {
		/* Don't clobber any existing error state */
	} else if ((scb->flags & SCB_SENSE) != 0) {
		/*
		 * We performed autosense retrieval.
		 *
		 * Zero any sense not transferred by the
		 * device.  The SCSI spec mandates that any
		 * untransferred data should be assumed to be
		 * zero.  Complete the 'bounce' of sense information
		 * through buffers accessible via bus-space by
		 * copying it into the clients csio.
		 */
		memset(&xs->sense, 0, sizeof(struct scsi_sense_data));
		memcpy(&xs->sense, ahd_get_sense_buf(ahd, scb),
		    sizeof(struct scsi_sense_data));
		xs->error = XS_SENSE;
	} else if ((scb->flags & SCB_PKT_SENSE) != 0) {
		struct scsi_status_iu_header *siu;
		u_int32_t len;

		siu = (struct scsi_status_iu_header *)scb->sense_data;
		len = SIU_SENSE_LENGTH(siu);
		memset(&xs->sense, 0, sizeof(xs->sense));
		memcpy(&xs->sense, SIU_SENSE_DATA(siu),
		    ulmin(len, sizeof(xs->sense)));
		xs->error = XS_SENSE;
	}

	scsi_done(xs);
}

void
ahd_minphys(struct buf *bp, struct scsi_link *sl)
{
	/*
	 * Even though the card can transfer up to 16megs per command
	 * we are limited by the number of segments in the dma segment
	 * list that we can hold.  The worst case is that all pages are
	 * discontinuous physically, hence the "page per segment" limit
	 * enforced here.
	 */
	if (bp->b_bcount > ((AHD_NSEG - 1) * PAGE_SIZE)) {
		bp->b_bcount = ((AHD_NSEG - 1) * PAGE_SIZE);
	}
	minphys(bp);
}

void
ahd_action(struct scsi_xfer *xs)
{
	struct	ahd_softc *ahd;
	struct scb *scb;
	struct hardware_scb *hscb;
	u_int	target_id;
	u_int	our_id;
	int	s;
	struct	ahd_initiator_tinfo *tinfo;
	struct	ahd_tmode_tstate *tstate;
	u_int16_t quirks;

	SC_DEBUG(xs->sc_link, SDEV_DB3, ("ahd_action\n"));
	ahd = (struct ahd_softc *)xs->sc_link->adapter_softc;

	target_id = xs->sc_link->target;
	our_id = SCSI_SCSI_ID(ahd, xs->sc_link);

	ahd_lock(ahd, &s);
	if ((ahd->flags & AHD_INITIATORROLE) == 0) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		ahd_unlock(ahd, &s);
		return;
	}
	/*
	 * get an scb to use.
	 */
	tinfo = ahd_fetch_transinfo(ahd, 'A', our_id, target_id, &tstate);

	quirks = xs->sc_link->quirks;

	ahd_unlock(ahd, &s);

	scb = xs->io;
	hscb = scb->hscb;
	scb->flags = SCB_FLAG_NONE;
	scb->hscb->control = 0;
	ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = NULL;

	SC_DEBUG(xs->sc_link, SDEV_DB3, ("start scb(%p)\n", scb));

	scb->xs = xs;
	timeout_set(&xs->stimeout, ahd_timeout, scb);

	/*
	 * Put all the arguments for the xfer in the scb
	 */
	hscb->control = 0;
	hscb->scsiid = BUILD_SCSIID(ahd, xs->sc_link, target_id, our_id);
	hscb->lun = xs->sc_link->lun;
	if (xs->xs_control & XS_CTL_RESET) {
		hscb->cdb_len = 0;
		scb->flags |= SCB_DEVICE_RESET;
		hscb->control |= MK_MESSAGE;
		hscb->task_management = SIU_TASKMGMT_LUN_RESET;
		ahd_execute_scb(scb, NULL, 0);
	} else {
		hscb->task_management = 0;
		ahd_setup_data(ahd, xs, scb);
	}
}

void
ahd_execute_scb(void *arg, bus_dma_segment_t *dm_segs, int nsegments)
{
	struct	scb *scb;
	struct	scsi_xfer *xs;
	struct	ahd_softc *ahd;
	struct	ahd_initiator_tinfo *tinfo;
	struct	ahd_tmode_tstate *tstate;
	u_int	mask;
	int	s;

	scb = (struct scb *)arg;
	xs = scb->xs;
	xs->error = CAM_REQ_INPROG;
	xs->status = 0;
	ahd = (struct ahd_softc *)xs->sc_link->adapter_softc;

	if (nsegments != 0) {
		void *sg;
		int op;
		u_int i;

		ahd_setup_data_scb(ahd, scb);

		/* Copy the segments into our SG list */
		for (i = nsegments, sg = scb->sg_list; i > 0; i--) {

			sg = ahd_sg_setup(ahd, scb, sg, dm_segs->ds_addr,
					  dm_segs->ds_len,
					  /*last*/i == 1);
			dm_segs++;
		}

		if ((xs->flags & SCSI_DATA_IN) != 0)
			op = BUS_DMASYNC_PREREAD;
		else
			op = BUS_DMASYNC_PREWRITE;

		bus_dmamap_sync(ahd->parent_dmat, scb->dmamap, 0,
				scb->dmamap->dm_mapsize, op);

	}

	ahd_lock(ahd, &s);

	/*
	 * Last time we need to check if this SCB needs to
	 * be aborted.
	 */
	if (xs->flags & ITSDONE) {
		if (nsegments != 0)
			bus_dmamap_unload(ahd->parent_dmat,
					  scb->dmamap);
		ahd_unlock(ahd, &s);
		return;
	}

	tinfo = ahd_fetch_transinfo(ahd, SCSIID_CHANNEL(ahd, scb->hscb->scsiid),
				    SCSIID_OUR_ID(scb->hscb->scsiid),
				    SCSIID_TARGET(ahd, scb->hscb->scsiid),
				    &tstate);

	mask = SCB_GET_TARGET_MASK(ahd, scb);

	if ((tstate->discenable & mask) != 0)
		scb->hscb->control |= DISCENB;

	if ((tstate->tagenable & mask) != 0)
		scb->hscb->control |= TAG_ENB;

	if ((tinfo->curr.ppr_options & MSG_EXT_PPR_PROT_IUS) != 0) {
		scb->flags |= SCB_PACKETIZED;
		if (scb->hscb->task_management != 0)
			scb->hscb->control &= ~MK_MESSAGE;
	}

	if ((tstate->auto_negotiate & mask) != 0) {
		scb->flags |= SCB_AUTO_NEGOTIATE;
		scb->hscb->control |= MK_MESSAGE;
	}

	/* XXX with ahc there was some bus_dmamap_sync(PREREAD|PREWRITE); */

	TAILQ_INSERT_HEAD(&ahd->pending_scbs, scb, next);

	if (!(xs->flags & SCSI_POLL))
		timeout_add_msec(&xs->stimeout, xs->timeout);

	scb->flags |= SCB_ACTIVE;

	if ((scb->flags & SCB_TARGET_IMMEDIATE) != 0) {
		/* Define a mapping from our tag to the SCB. */
		ahd->scb_data.scbindex[SCB_GET_TAG(scb)] = scb;
		ahd_pause(ahd);
		ahd_set_scbptr(ahd, SCB_GET_TAG(scb));
		ahd_outb(ahd, RETURN_1, CONT_MSG_LOOP_TARG);
		ahd_unpause(ahd);
	} else {
		ahd_queue_scb(ahd, scb);
	}

	if (!(xs->flags & SCSI_POLL)) {
		int target = xs->sc_link->target;
		int lun = SCB_GET_LUN(scb);

		if (ahd->inited_target[target] == 0) {
			struct  ahd_devinfo devinfo;

			ahd_adapter_req_set_xfer_mode(ahd, scb);
			ahd_compile_devinfo(&devinfo, ahd->our_id, target, lun,
			    'A', /*XXX milos*/ROLE_UNKNOWN);
			ahd_scb_devinfo(ahd, &devinfo, scb);
			ahd_update_neg_request(ahd, &devinfo, tstate, tinfo,
				AHD_NEG_IF_NON_ASYNC);
			ahd->inited_target[target] = 1;
		}

		ahd_unlock(ahd, &s);
		return;
	}

	/*
	 * If we can't use interrupts, poll for completion
	 */
	SC_DEBUG(xs->sc_link, SDEV_DB3, ("cmd_poll\n"));

	do {
		if (ahd_poll(ahd, xs->timeout)) {
			if (!(xs->flags & SCSI_SILENT))
				printf("cmd fail\n");
			ahd_timeout(scb);
			break;
		}
	} while (!(xs->flags & ITSDONE));

	ahd_unlock(ahd, &s);
}

int
ahd_poll(struct ahd_softc *ahd, int wait)
{
	while (--wait) {
		DELAY(1000);
		if (ahd_inb(ahd, INTSTAT) & INT_PEND)
			break;
	}

	if (wait == 0) {
		printf("%s: board is not responding\n", ahd_name(ahd));
		return (EIO);
	}

	ahd_intr((void *)ahd);
	return (0);
}

void
ahd_setup_data(struct ahd_softc *ahd, struct scsi_xfer *xs,
	       struct scb *scb)
{
	struct hardware_scb *hscb;

	hscb = scb->hscb;
	xs->resid = xs->status = 0;
	xs->error = CAM_REQ_INPROG;

	hscb->cdb_len = xs->cmdlen;
	if (hscb->cdb_len > MAX_CDB_LEN) {
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	memcpy(hscb->shared_data.idata.cdb, xs->cmd, hscb->cdb_len);

	/* Only use S/G if there is a transfer */
	if (xs->datalen) {
		int error;

		error = bus_dmamap_load(ahd->parent_dmat,
					scb->dmamap, xs->data,
					xs->datalen, NULL,
					((xs->flags & SCSI_NOSLEEP) ?
					BUS_DMA_NOWAIT : BUS_DMA_WAITOK) |
					BUS_DMA_STREAMING |
					((xs->flags & XS_CTL_DATA_IN) ?
					BUS_DMA_READ : BUS_DMA_WRITE));
		if (error) {
#ifdef AHD_DEBUG
			printf("%s: in ahd_setup_data(): bus_dmamap_load() "
			    "= %d\n", ahd_name(ahd), error);
#endif
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
		ahd_execute_scb(scb, scb->dmamap->dm_segs,
		    scb->dmamap->dm_nsegs);
	} else {
		ahd_execute_scb(scb, NULL, 0);
	}
}

void
ahd_platform_set_tags(struct ahd_softc *ahd, struct ahd_devinfo *devinfo,
    ahd_queue_alg alg)
{
	struct ahd_tmode_tstate *tstate;

	ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
	    devinfo->target, &tstate);

	if (alg != AHD_QUEUE_NONE)
		tstate->tagenable |= devinfo->target_mask;
	else
		tstate->tagenable &= ~devinfo->target_mask;
}

int
ahd_platform_alloc(struct ahd_softc *ahd, void *platform_arg)
{
	if (sizeof(struct ahd_platform_data) > 0) {
		ahd->platform_data = malloc(sizeof(struct ahd_platform_data),
		    M_DEVBUF, M_NOWAIT | M_ZERO);
		if (ahd->platform_data == NULL)
			return (ENOMEM);
	}

	return (0);
}

void
ahd_platform_free(struct ahd_softc *ahd)
{
	if (sizeof(struct ahd_platform_data) > 0)
		free(ahd->platform_data, M_DEVBUF, 0);
}

int
ahd_softc_comp(struct ahd_softc *lahd, struct ahd_softc *rahd)
{
	/* We don't sort softcs under OpenBSD so report equal always */
	return (0);
}

int
ahd_detach(struct device *self, int flags)
{
	int rv = 0;

	struct ahd_softc *ahd = (struct ahd_softc*)self;

	if (ahd->sc_child != NULL)
		rv = config_detach((void *)ahd->sc_child, flags);

	ahd_free(ahd);

	return rv;
}

void
ahd_adapter_req_set_xfer_mode(struct ahd_softc *ahd, struct scb *scb)
{
	struct ahd_initiator_tinfo *tinfo;
	struct ahd_tmode_tstate *tstate;
	int target_id, our_id;
	struct ahd_devinfo devinfo;
	u_int16_t quirks;
	u_int width, ppr_options, period, offset;
	int s;

	target_id = scb->xs->sc_link->target;
	our_id = SCSI_SCSI_ID(ahd, scb->xs->sc_link);

	s = splbio();

	quirks = scb->xs->sc_link->quirks;
	tinfo = ahd_fetch_transinfo(ahd, 'A', our_id, target_id, &tstate);
	ahd_compile_devinfo(&devinfo, our_id, target_id, 0, 'A',
	    ROLE_INITIATOR);

	tstate->discenable |= (ahd->user_discenable & devinfo.target_mask);

	if (quirks & SDEV_NOTAGS)
		tstate->tagenable &= ~devinfo.target_mask;
	else if (ahd->user_tagenable & devinfo.target_mask)
		tstate->tagenable |= devinfo.target_mask;

	if (quirks & SDEV_NOWIDE)
		width = MSG_EXT_WDTR_BUS_8_BIT;
	else
		width = MSG_EXT_WDTR_BUS_16_BIT;

	ahd_validate_width(ahd, NULL, &width, ROLE_UNKNOWN);
	if (width > tinfo->user.width)
		width = tinfo->user.width;
	ahd_set_width(ahd, &devinfo, width, AHD_TRANS_GOAL, FALSE);

	if (quirks & SDEV_NOSYNC) {
		period = 0;
		offset = 0;
	} else {
		period = tinfo->user.period;
		offset = tinfo->user.offset;
	}

	/* XXX Look at saved INQUIRY flags for PPR capabilities XXX */
	ppr_options = tinfo->user.ppr_options;
	/* XXX Other reasons to avoid ppr? XXX */
	if (width < MSG_EXT_WDTR_BUS_16_BIT)
		ppr_options = 0;

	if ((tstate->discenable & devinfo.target_mask) == 0 ||
	    (tstate->tagenable & devinfo.target_mask) == 0)
		ppr_options &= ~MSG_EXT_PPR_PROT_IUS;

	ahd_find_syncrate(ahd, &period, &ppr_options, AHD_SYNCRATE_MAX);
	ahd_validate_offset(ahd, NULL, period, &offset, width, ROLE_UNKNOWN);

	if (offset == 0) {
		period = 0;
		ppr_options = 0;
	}

	if (ppr_options != 0 && tinfo->user.transport_version >= 3) {
		tinfo->goal.transport_version = tinfo->user.transport_version;
		tinfo->curr.transport_version = tinfo->user.transport_version;
	}

	ahd_set_syncrate(ahd, &devinfo, period, offset, ppr_options,
		AHD_TRANS_GOAL, FALSE);

	splx(s);
}

void
aic_timer_reset(aic_timer_t *timer, u_int msec, ahd_callback_t *func,
    void *arg)
{
	uint64_t nticks;

	nticks = msec;
	nticks *= hz;
	nticks /= 1000;
	callout_reset(timer, nticks, func, arg);
}

void
aic_scb_timer_reset(struct scb *scb, u_int msec)
{
	uint64_t nticks;

	nticks = msec;
	nticks *= hz;
	nticks /= 1000;
	if (!(scb->xs->xs_control & XS_CTL_POLL))
		callout_reset(&scb->xs->xs_callout, nticks, ahd_timeout, scb);
}

void
ahd_flush_device_writes(struct ahd_softc *ahd)
{
	/* XXX Is this sufficient for all architectures??? */
	ahd_inb(ahd, INTSTAT);
}

void
aic_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
{
	int s;

	ahd_lock(ahd, &s);

	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0) {
		ahd->flags &= ~AHD_RESOURCE_SHORTAGE;
	}

	if (!cold) {
		/* we are no longer in autoconf */
		timeout_del(&scb->xs->stimeout);
	}

	ahd_unlock(ahd, &s);
}

void
ahd_print_path(struct ahd_softc *ahd, struct scb *scb)
{
	sc_print_addr(scb->xs->sc_link);
}

void
ahd_platform_dump_card_state(struct ahd_softc *ahd)
{
	/* Nothing to do here for OpenBSD */
	printf("FEATURES = 0x%x, FLAGS = 0x%x, CHIP = 0x%x BUGS =0x%x\n",
		ahd->features, ahd->flags, ahd->chip, ahd->bugs);
}

void
ahd_platform_flushwork(struct ahd_softc *ahd)
{
}
@


1.44
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.43 2015/07/17 21:42:49 krw Exp $	*/
d115 2
a116 1
	ahd->sc_channel.openings = 16;
a161 1
	int s;
d165 1
a165 1
	LIST_REMOVE(scb, pending_links);
a251 2
	ahd_lock(ahd, &s);
	ahd_free_scb(ahd, scb);
a252 1
	ahd_unlock(ahd, &s);
a281 1
	u_int	col_idx;
a303 13
	if ((quirks & SDEV_NOTAGS) != 0 ||
	    (tinfo->curr.ppr_options & MSG_EXT_PPR_PROT_IUS) != 0)
		col_idx = AHD_NEVER_COL_IDX;
	else
		col_idx = AHD_BUILD_COL_IDX(target_id, xs->sc_link->lun);

	if ((scb = ahd_get_scb(ahd, col_idx)) == NULL) {
		ahd->flags |= AHD_RESOURCE_SHORTAGE;
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		ahd_unlock(ahd, &s);
		return;
	}
d306 1
d308 3
a387 1
		ahd_free_scb(ahd, scb);
d418 1
a418 1
	LIST_INSERT_HEAD(&ahd->pending_scbs, scb, pending_links);
a495 1
	int s;
a502 2
		ahd_lock(ahd, &s);
		ahd_free_scb(ahd, scb);
a504 1
		ahd_unlock(ahd, &s);
a526 2
			ahd_lock(ahd, &s);
			ahd_free_scb(ahd, scb);
a528 1
			ahd_unlock(ahd, &s);
@


1.43
log
@Nuke a bunch of leading and trailing whitespace so I don't go blind
reading this code. No intentional functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.42 2014/07/12 18:48:17 tedu Exp $	*/
d695 1
a695 1
	uint64_t ticks;
d697 4
a700 4
	ticks = msec;
	ticks *= hz;
	ticks /= 1000;
	callout_reset(timer, ticks, func, arg);
d706 1
a706 1
	uint64_t ticks;
d708 3
a710 3
	ticks = msec;
	ticks *= hz;
	ticks /= 1000;
d712 1
a712 1
		callout_reset(&scb->xs->xs_callout, ticks, ahd_timeout, scb);
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.41 2014/01/17 23:23:58 dlg Exp $	*/
d75 1
a75 1
void	ahd_setup_data(struct ahd_softc *, struct scsi_xfer *, 
d148 1
a148 1
	ahd = (struct ahd_softc *)arg; 
d244 1
a244 1
 		siu = (struct scsi_status_iu_header *)scb->sense_data;
d293 1
a293 1
	
d308 1
a308 1
	if ((quirks & SDEV_NOTAGS) != 0 || 
d322 1
a322 1
		
d324 1
a324 1
		
d380 1
a380 1
		
d515 1
a515 1
	
d527 1
a527 1
		
d568 1
a568 1
	if (alg != AHD_QUEUE_NONE) 
d582 1
a582 1
	}	
@


1.41
log
@if the hardware is too busy or its queues are too full, return XS_BUSY,
not XS_NO_CCB.

discussed with krw@@ who agrees
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.40 2013/05/30 16:15:02 deraadt Exp $	*/
d591 1
a591 1
		free(ahd->platform_data, M_DEVBUF);
@


1.40
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.39 2012/12/05 23:20:16 deraadt Exp $	*/
a187 2
			xs->error = XS_NO_CCB;
			break;
d205 1
a214 3
	case CAM_REQUEUE_REQ:
		xs->error = XS_NO_CCB;
		break;
d547 1
a547 1
			xs->error = XS_NO_CCB;
@


1.39
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.38 2012/02/24 06:19:00 guenther Exp $	*/
a613 3

	if (ahd->shutdown_hook != NULL)
		shutdownhook_disestablish(ahd->shutdown_hook);
@


1.38
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.37 2010/06/28 18:31:02 krw Exp $	*/
a61 5

#include <sys/cdefs.h>
/*
__FBSDID("$FreeBSD: src/sys/dev/aic7xxx/aic79xx_osm.c,v 1.16 2003/12/17 00:02:09 gibbs Exp $");
*/
@


1.37
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.36 2010/03/23 01:57:19 krw Exp $	*/
d240 1
a240 1
		 * untransfered data should be assumed to be
@


1.36
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.35 2010/01/20 08:40:41 krw Exp $	*/
a97 9
/* the below structure is so we have a default dev struct for our link struct */
static struct scsi_device ahd_dev =
{
	NULL, /* Use default error handler */
	NULL, /* have a queue, served by this */
	NULL, /* have no async handler */
	NULL, /* Use default 'done' routine */
};

a120 1
	ahd->sc_channel.device = &ahd_dev;
@


1.35
log
@Remove horrible hack in ahc/ahd that made some commands retry
endlessly.  Use the shiny new XS_NO_CCB instead to retry commands
that can't start. Neither dlg@@ nor I can figure out why 4.6 and
earlier worked.

Problem noted, debugged with and fix tested by Jeff Ross and his
new external enclosure. Thanks!

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.34 2010/01/10 00:10:23 krw Exp $	*/
d77 2
a78 2
int	ahd_action(struct scsi_xfer *);
int	ahd_execute_scb(void *, bus_dma_segment_t *, int);
d80 1
a80 1
int	ahd_setup_data(struct ahd_softc *, struct scsi_xfer *, 
d293 1
a293 1
int32_t
d318 1
a318 1
		return (COMPLETE);
d335 2
d338 1
a338 1
		return (NO_CCB);
d360 1
a360 1
		return (ahd_execute_scb(scb, NULL, 0));
d363 1
a363 1
		return (ahd_setup_data(ahd, xs, scb));
d367 1
a367 1
int
d422 1
a422 1
		return (COMPLETE);
d486 1
a486 1
		return (SUCCESSFULLY_QUEUED);
a503 1
	return (COMPLETE);
d524 1
a524 1
int
d542 1
a542 1
		return (COMPLETE);
d566 2
d569 1
a569 1
			return (NO_CCB);       /* XXX fvdl */
d571 1
a571 1
		error = ahd_execute_scb(scb, scb->dmamap->dm_segs,
a572 1
		return error;
d574 1
a574 1
		return ahd_execute_scb(scb, NULL, 0);
@


1.34
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.33 2009/11/22 14:14:10 krw Exp $	*/
d203 1
a203 8
			/* SCSI Layer won't requeue, so we force infinite
			 * retries until queue space is available. XS_BUSY
			 * is dangerous because if the NOSLEEP flag is set
			 * it can cause the I/O to return EIO. XS_BUSY code
			 * falls through to XS_TIMEOUT anyway.
			 */ 
			xs->error = XS_TIMEOUT;
			xs->retries++;
d232 1
a232 2
		xs->error = XS_TIMEOUT;
		xs->retries++;
@


1.33
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.32 2009/02/16 21:19:06 miod Exp $	*/
a280 1
	xs->flags |= ITSDONE;
a323 1
		xs->flags |= ITSDONE;
a546 1
		xs->flags |= ITSDONE;
@


1.32
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.31 2009/01/21 21:53:59 grange Exp $	*/
d577 1
a577 1
			return (TRY_AGAIN_LATER);       /* XXX fvdl */
@


1.31
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.30 2008/11/25 18:10:00 krw Exp $	*/
d84 1
a84 1
void    ahd_minphys(struct buf *);
d287 1
a287 1
ahd_minphys(struct buf *bp)
@


1.30
log
@dontqueue is set but never used. garbage collect it.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.29 2008/11/24 00:31:35 krw Exp $	*/
d462 1
a462 1
		timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
@


1.29
log
@Return NO_CCB instead of TRY_AGAIN_LATER when ccb's run out.

"I'm all for it." marco@@ "Yeah" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.28 2007/10/20 00:21:49 krw Exp $	*/
a310 1
	int	dontqueue = 0;
a317 3

	/* determine safety of software queueing */
	dontqueue = xs->flags & SCSI_POLL;
@


1.28
log
@Put scsi_done() invocations inside existing splbio/splx pairs to make
damned sure scsi_done is invoked at splbio. Noted by deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.27 2007/09/07 17:58:39 krw Exp $	*/
d350 1
a350 1
		return (TRY_AGAIN_LATER);
@


1.27
log
@The obvious bzero/memset -> M_ZERO changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.26 2006/11/28 23:59:45 dlg Exp $	*/
a280 2
	ahd_unlock(ahd, &s);

d283 1
d326 1
d331 1
a332 1
		/* return 	ccb->ccb_h.status = CAM_PROVIDE_FAIL; */
a336 1
	ahd_lock(ahd, &s);
a551 1
		ahd_unlock(ahd, &s);
d555 1
@


1.26
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.25 2006/05/22 20:35:12 krw Exp $	*/
d612 1
a612 1
		    M_DEVBUF, M_NOWAIT);
a614 1
		bzero(ahd->platform_data, sizeof(struct ahd_platform_data));
@


1.25
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.24 2006/03/04 14:20:37 krw Exp $	*/
d113 1
d142 4
a145 2
	ahd->sc_child = config_found((void *)&ahd->sc_dev,
	    &ahd->sc_channel, scsiprint);
@


1.24
log
@All CAM_* values stored in xs->error must be 'interpreted' by
ah[cd]_done() into XS_* values understood by the SCSI code before
returning xs to the tender mercies of the SCSI code.

So if we bail out without calling ah[cd]_done(), because the request
cdb length is excessive, don't use ah[cd]_set_transaction() to put
CAM_REQ_INVALID into xs->error, just jam in XS_DRIVER_STUFFUP as
ah[cd]_done() would have. If CAM_REQ_INVALID escapes it will be
interpreted as XS_SHORT_SENSE as far as I can tell.

This code path should never be trod so the net effect should be
minimal.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.23 2005/12/28 02:43:54 krw Exp $	*/
d642 2
a643 1
	shutdownhook_disestablish(ahd->shutdown_hook);
@


1.23
log
@Strip out fancy timeout code that attempts to mimic FreeBSD's thread
based timeout handling. Use the simple timeout == bus reset model
instead. Also move verbose debug output inside #ifdef/#endif.

Fixes immediate crashes on encountering a timeout.

Noted by per englebrecht when trying 'smartctl -d scsi -a /dev/rsd0c'.

Thanks to per englebrecht and luiz gustavo for testing.

Should only impact timeout handling. No change to normal processing.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.22 2005/11/02 03:27:39 krw Exp $	*/
a547 1
		aic_set_transaction_status(scb, CAM_REQ_INVALID);
d551 1
@


1.22
log
@It is invalid to scsi_done(xs) and then return TRY_AGAIN_LATER.
scsi_done() can release the scsi_request xs and TRY_AGAIN_LATER will
refer to it and submit it for re-execution. This was being done only
if bus_dmamap_load() failed.

Ensure the controller resources are freed before returning
TRY_AGAIN_LATER, since new resources will be allocated when the
command is executed again.

Don't bother setting xs->error before returning TRY_AGAIN_LATER as the
code returned to sets xs->error to XS_BUSY.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.21 2005/10/06 23:04:28 krw Exp $	*/
a172 1
	struct scb *list_scb;
a192 30
	/*
	 * If the recovery SCB completes, we have to be
	 * out of our timeout.
	 */
	if ((scb->flags & SCB_RECOVERY_SCB) != 0) {
		ahd->scb_data.recovery_scbs--;

		if (aic_get_transaction_status(scb) == CAM_BDR_SENT
		 || aic_get_transaction_status(scb) == CAM_REQ_ABORTED)
			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);

		if (ahd->scb_data.recovery_scbs == 0) {
			/*
			 * All recovery actions have completed successfully,
			 * so reinstate the timeouts for all other pending
			 * commands.
			 */
			LIST_FOREACH(list_scb, &ahd->pending_scbs,
			    pending_links) {
				if (!(list_scb->xs->flags & SCSI_POLL))
					aic_scb_timer_reset(list_scb,
					    aic_get_timeout(list_scb));
			}

			ahd_print_path(ahd, scb);
			printf("%s: no longer in timeout, status = %x\n",
			       ahd_name(ahd), aic_get_transaction_status(scb));
		}
	}

d762 1
a762 2
	if ((ahd->flags & AHD_RESOURCE_SHORTAGE) != 0 ||
	    (scb->flags & SCB_RECOVERY_SCB) != 0) {
a790 22
}

void
ahd_set_recoveryscb(struct ahd_softc *ahd, struct scb *scb)
{

	if ((scb->flags & SCB_RECOVERY_SCB) == 0) {
		struct scb *list_scb;

		scb->flags |= SCB_RECOVERY_SCB;

		AIC_SCB_DATA(ahd)->recovery_scbs++;

		/*
		 * Go through all of our pending SCBs and remove
		 * any scheduled timeouts for them.  We will reschedule
		 * them after we've successfully fixed this problem.
		 */
		LIST_FOREACH(list_scb, &ahd->pending_scbs, pending_links) {
			timeout_del(&list_scb->xs->stimeout);
		}
	}
@


1.21
log
@Use correct timer when reinstating timeouts. Adapted from FreeBSD
aic79xx_osm.c r1.22 fix by gibbs.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.20 2004/12/30 17:29:55 krw Exp $	*/
a378 1
		xs->error = XS_DRIVER_STUFFUP;
d571 2
a572 1
	
a578 2
		int s;
		
d607 3
a609 3
			xs->error = XS_BUSY;
			xs->flags |= ITSDONE;
			scsi_done(xs);
@


1.20
log
@Current ahd timeout code does nothing. Add fbsd style timeout
handling which will at least try to recover.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.19 2004/12/28 04:12:24 krw Exp $	*/
d214 2
a215 2
					aic_scb_timer_reset(scb,
					    aic_get_timeout(scb));
@


1.19
log
@Don't allow an infinite number of SCSI bus resets per i/o.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.18 2004/12/27 21:34:42 krw Exp $	*/
d173 1
d199 1
a199 1
		struct	scb *list_scb;
d201 20
a220 10
		/*
		 * We were able to complete the command successfully,
		 * so reinstate the timeouts for all other pending
		 * commands.
		 */
		LIST_FOREACH(list_scb, &ahd->pending_scbs, pending_links) {
			struct scsi_xfer *txs = list_scb->xs;
			if (!(txs->flags & SCSI_POLL))
				timeout_add(&list_scb->xs->stimeout,
				    (list_scb->xs->timeout * hz)/1000);
a221 6

		if (aic_get_transaction_status(scb) != CAM_REQ_INPROG)
			aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
		ahd_print_path(ahd, scb);
		printf("%s: no longer in timeout, status = %x\n",
		    ahd_name(ahd), xs->status);
d827 10
d838 10
@


1.18
log
@Fix tag handling for non-U320/packetized devices. Allow tags for these
devices.

Tidy up man page, remove lies and cruft.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.17 2004/12/24 22:17:56 krw Exp $	*/
d260 1
@


1.17
log
@Kill bit of ahc cruft. Elminate lots of leading spaces. Other KNF. No
functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.16 2004/12/20 22:07:25 krw Exp $	*/
d364 1
a364 1
	if ((quirks & SDEV_NOTAGS) == 0 || 
a472 8

	/* disable tags and disconection to work around overlapped commands 
	 * for non U320 devices
	 */
	if ((tinfo->curr.ppr_options & MSG_EXT_PPR_PROT_IUS) == 0) {
		scb->hscb->control &= ~TAG_ENB;
		scb->hscb->control &= ~DISCENB;
	}
@


1.16
log
@In the rare case that SCSI_RESET is set, ensure that xs->stimeout is
valid and don't call ahd_setup_data() after ahd_execute_scb() may have
freed the scb.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.15 2004/12/20 20:56:32 krw Exp $	*/
d87 1
a87 1
	        NULL, "ahd", DV_DULL
d123 7
a129 7
        ahd->sc_channel.adapter_target = ahd->our_id;
        if (ahd->features & AHD_WIDE)
                ahd->sc_channel.adapter_buswidth = 16;
        ahd->sc_channel.adapter_softc = ahd;
        ahd->sc_channel.adapter = &ahd_switch;
        ahd->sc_channel.openings = 16;
        ahd->sc_channel.device = &ahd_dev;
d132 3
a134 3
                ahd_controller_info(ahd, ahd_info, sizeof ahd_info);
                printf("%s: %s\n", ahd->sc_dev.dv_xname, ahd_info);
        }
d139 1
a139 1
                ahd_reset_channel(ahd, 'A', TRUE);
d182 1
a182 1
                int op;
d184 8
a191 8
                if ((xs->flags & SCSI_DATA_IN) != 0)
                        op = BUS_DMASYNC_POSTREAD;
                else
                        op = BUS_DMASYNC_POSTWRITE;
                bus_dmamap_sync(ahd->parent_dmat, scb->dmamap, 0,
                                scb->dmamap->dm_mapsize, op);
                bus_dmamap_unload(ahd->parent_dmat, scb->dmamap);
        }
d207 4
a210 4
                        if (!(txs->flags & SCSI_POLL))
                                timeout_add(&list_scb->xs->stimeout,
                                    (list_scb->xs->timeout * hz)/1000);
                }
d213 1
a213 1
                	aic_set_transaction_status(scb, CAM_CMD_TIMEOUT);
d215 2
a216 2
                printf("%s: no longer in timeout, status = %x\n",
                       ahd_name(ahd), xs->status);
d222 49
a270 49
        case CAM_REQ_INPROG:
        case CAM_REQ_CMP:
                switch (xs->status) {
                case SCSI_TASKSET_FULL:
                        /* SCSI Layer won't requeue, so we force infinite
                         * retries until queue space is available. XS_BUSY
                         * is dangerous because if the NOSLEEP flag is set
                         * it can cause the I/O to return EIO. XS_BUSY code
                         * falls through to XS_TIMEOUT anyway.
                         */ 
                        xs->error = XS_TIMEOUT;
                        xs->retries++;
                        break;
                case SCSI_BUSY:
                        xs->error = XS_BUSY;
                        break;
                case SCSI_CHECK:
                case SCSI_TERMINATED:
                        if ((scb->flags & SCB_SENSE) == 0) {
                                /* CHECK on CHECK? */
                                xs->error = XS_DRIVER_STUFFUP;
                        } else
                                xs->error = XS_NOERROR;
                        break;
                default:
                        xs->error = XS_NOERROR;
                        break;
                }
                break;
        case CAM_BUSY:
                xs->error = XS_BUSY;
                break;
        case CAM_CMD_TIMEOUT:
                xs->error = XS_TIMEOUT;
                break;
        case CAM_BDR_SENT:
        case CAM_SCSI_BUS_RESET:
                xs->error = XS_RESET;
        case CAM_REQUEUE_REQ:
                xs->error = XS_TIMEOUT;
                xs->retries++;
                break;
        case CAM_SEL_TIMEOUT:
                xs->error = XS_SELTIMEOUT;
                break;
        default:
                xs->error = XS_DRIVER_STUFFUP;
                break;
        }
d286 3
a288 3
                memcpy(&xs->sense, ahd_get_sense_buf(ahd, scb),
                    sizeof(struct scsi_sense_data));
                xs->error = XS_SENSE;
d298 1
a298 1
                xs->error = XS_SENSE;
d300 1
a300 4
#if 0	/* MU: no such settings in ahc */
	if (scb->flags & SCB_REQUEUE)
                xs->error = XS_REQUEUE;
#endif
d306 1
a306 1
        scsi_done(xs);
d310 1
a310 2
ahd_minphys(bp)
        struct buf *bp;
d312 11
a322 11
        /*
         * Even though the card can transfer up to 16megs per command
         * we are limited by the number of segments in the dma segment
         * list that we can hold.  The worst case is that all pages are
         * discontinuous physically, hence the "page per segment" limit
         * enforced here.
         */
        if (bp->b_bcount > ((AHD_NSEG - 1) * PAGE_SIZE)) {
                bp->b_bcount = ((AHD_NSEG - 1) * PAGE_SIZE);
        }
        minphys(bp);
d526 1
a526 1
									                        	ahd->inited_target[target] = 1;
d600 6
a605 6
                                        xs->datalen, NULL,
                                        ((xs->flags & SCSI_NOSLEEP) ?
                                         BUS_DMA_NOWAIT : BUS_DMA_WAITOK) |
                                        BUS_DMA_STREAMING |
                                        ((xs->flags & XS_CTL_DATA_IN) ?
                                         BUS_DMA_READ : BUS_DMA_WRITE));
d608 2
a609 3
                        printf("%s: in ahd_setup_data(): bus_dmamap_load() "
                               "= %d\n",
                               ahd_name(ahd), error);
d612 3
a614 3
                        xs->flags |= ITSDONE;
                        scsi_done(xs);
                        return (TRY_AGAIN_LATER);       /* XXX fvdl */
d616 2
a617 3
		error = ahd_execute_scb(scb,
				scb->dmamap->dm_segs,
                                scb->dmamap->dm_nsegs);
d625 2
a626 2
ahd_platform_set_tags(struct ahd_softc *ahd,
		      struct ahd_devinfo *devinfo, ahd_queue_alg alg)
d630 2
a631 2
        ahd_fetch_transinfo(ahd, devinfo->channel, devinfo->our_scsiid,
                            devinfo->target, &tstate);
d633 4
a636 4
        if (alg != AHD_QUEUE_NONE) 
                tstate->tagenable |= devinfo->target_mask;
        else
                tstate->tagenable &= ~devinfo->target_mask;
d672 1
a672 1
        struct ahd_softc *ahd = (struct ahd_softc*)self;
d674 2
a675 2
        if (ahd->sc_child != NULL)
                rv = config_detach((void *)ahd->sc_child, flags);
d677 1
a677 1
        shutdownhook_disestablish(ahd->shutdown_hook);
d679 1
a679 1
        ahd_free(ahd);
d681 1
a681 1
        return rv;
@


1.15
log
@Activate packetized status handling.

ok tdeval@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.14 2004/12/19 06:17:54 krw Exp $	*/
d387 1
d400 1
a400 1
		ahd_execute_scb(scb, NULL, 0);
d403 1
a404 7
#if 0
	if (ccb->ccb_h.flags & CAM_TAG_ACTION_VALID)
		hscb->control |= ccb->csio.tag_action;
#endif
	timeout_set(&xs->stimeout, ahd_timeout, scb);

	return ahd_setup_data(ahd, xs, scb);
@


1.14
log
@Reduce delta to FreeBSD by adding and using ahd_alloc() rather than
manually reproducing bits in ahd_pci.c.

Just as in ahc, avoid allocating and freeing zero length bits of
memory for platform data.

Don't try to free all or part of ahd_softc, but correctly free
allocated memory for seep_config if necessary.

Add a final few fields to ahd_softc and scb in preparation for
updating/fixing timeout handling.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.13 2004/12/13 04:07:26 krw Exp $	*/
a288 1
#if 0
d291 1
a291 18
		u_int sense_len;
		int i;

		/*
		 * Copy only the sense data into the provided buffer.
		 */
		siu = (struct scsi_status_iu_header *)scb->sense_data;
		sense_len = MIN(scsi_4btoul(siu->sense_length),
				sizeof(struct scsi_sense_data));
		memset(&xs->sense, 0, &xs->sense);
		memcpy(&xs->sense, 
		       ahd_get_sense_buf(ahd, scb) + SIU_SENSE_OFFSET(siu),
		       sense_len);
		printf("Copied %d bytes of sense data offset %d:", sense_len,
		       SIU_SENSE_OFFSET(siu));
		for (i = 0; i < sense_len; i++)
			printf(" 0x%x", ((uint8_t *)&xs->sense)[i]);
		printf("\n");
d293 5
a298 1
#endif
@


1.13
log
@Use millisends rather than microseconds in parameters to timer
functions, and ultra-conservative calculations, to avoid possible
overflow issues. Also consistant with values passed in scsi requests.

Whitespace and comment tweaks.

Update FreeBSD tags now that we are sync'd to the latest version.

From FreeBSD aic79xx.c r1.33, aic79xx.h r1.23, aic_osm_lib.h r1.4.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.12 2004/11/23 05:15:35 krw Exp $	*/
d667 7
a673 6
	ahd->platform_data = malloc(sizeof(struct ahd_platform_data), M_DEVBUF,
	    M_NOWAIT /*| M_ZERO*/);
	if (ahd->platform_data == NULL)
		return (ENOMEM);

	memset(ahd->platform_data, 0, sizeof(struct ahd_platform_data));
d681 2
a682 1
	free(ahd->platform_data, M_DEVBUF);
@


1.12
log
@More FreeBSD delta reduction. Use aic_* defines rather than ahd_* one
line and zero line functions. Fix a potential bug
(ahd_set_transaction_status was used where ahd_set_scsi_status was
intended) inside a currently #ifdef 0/#endif section of code.

No functional changes intended except for a bit of extra locking via
ahd_list_lock*.

ok marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.11 2004/11/18 01:33:28 krw Exp $	*/
d783 2
a784 1
aic_scb_timer_reset(struct scb *scb, u_int usec)
d786 18
a803 4
	if (!(scb->xs->xs_control & XS_CTL_POLL)) {
		callout_reset(&scb->xs->xs_callout,
		    (usec * hz)/1000000, ahd_timeout, scb);
	}
@


1.11
log
@More NetBSD cruft removal/FreeBSD delta reduction. Whitespace, function and variable shuffle. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.10 2004/11/14 01:25:14 krw Exp $	*/
d212 2
a213 2
		if (ahd_get_transaction_status(scb) != CAM_REQ_INPROG)
                	ahd_set_transaction_status(scb, CAM_CMD_TIMEOUT);
d311 1
a311 1
		ahd_set_transaction_status(scb, XS_SENSE);
d316 1
a316 1
                ahd_set_transaction_status(scb, XS_REQUEUE);
d606 1
a606 1
		ahd_set_transaction_status(scb, CAM_REQ_INVALID);
d783 1
a783 7
ahd_timer_reset(ahd_timer_t *timer, u_int usec, ahd_callback_t *func, void *arg)
{
	callout_reset(timer, (usec * hz)/1000000, func, arg);
}

void
ahd_scb_timer_reset(struct scb *scb, u_int usec)
d799 1
a799 145
ahd_lockinit(struct ahd_softc *ahd)
{
}

void
ahd_lock(struct ahd_softc *ahd, int *flags)
{
	*flags = splbio();
}

void
ahd_unlock(struct ahd_softc *ahd, int *flags)
{
	splx(*flags);
}

/* Lock held during command compeletion to the upper layer */
void
ahd_done_lockinit(struct ahd_softc *ahd)
{
}

void
ahd_done_lock(struct ahd_softc *ahd, int *flags)
{
}

void
ahd_done_unlock(struct ahd_softc *ahd, int *flags)
{
}

/* Lock held during ahd_list manipulation and ahd softc frees */
void
ahd_list_lockinit(void)
{
}

void
ahd_list_lock(int *flags)
{
}

void
ahd_list_unlock(int *flags)
{
}

void ahd_set_transaction_status(struct scb *scb, uint32_t status)
{
	scb->xs->error = status;
}

void ahd_set_scsi_status(struct scb *scb, uint32_t status)
{
	scb->xs->xs_status = status;
}

uint32_t ahd_get_transaction_status(struct scb *scb)
{
	if (scb->xs->flags & ITSDONE)
		return CAM_REQ_CMP;
	else
		return scb->xs->error;
}

uint32_t ahd_get_scsi_status(struct scb *scb)
{
	return (scb->xs->status);
}

void ahd_set_transaction_tag(struct scb *scb, int enabled, u_int type)
{
}

u_long ahd_get_transfer_length(struct scb *scb)
{
	return (scb->xs->datalen);
}

int ahd_get_transfer_dir(struct scb *scb)
{
	return (scb->xs->flags & (SCSI_DATA_IN | SCSI_DATA_OUT));
}

void ahd_set_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

void ahd_set_sense_residual(struct scb *scb, u_long resid)
{
	scb->xs->resid = resid;
}

u_long ahd_get_residual(struct scb *scb)
{
	return (scb->xs->resid);
}

int ahd_perform_autosense(struct scb *scb)
{
	/* Return true for OpenBSD */
	return (1);
}

uint32_t
ahd_get_sense_bufsize(struct ahd_softc *ahd, struct scb *scb)
{
	return (sizeof(struct scsi_sense_data));
}

void
ahd_freeze_simq(struct ahd_softc *ahd)
{
        /* do nothing for now */
}

void
ahd_release_simq(struct ahd_softc *ahd)
{
        /* do nothing for now */
}

void
ahd_freeze_scb(struct scb *scb)
{
        /* do nothing for now */
}

void
ahd_platform_freeze_devq(struct ahd_softc *ahd, struct scb *scb)
{
}

int
ahd_platform_abort_scbs(struct ahd_softc *ahd, int target,
			char channel, int lun, u_int tag,
			role_t role, uint32_t status)
{
	return (0);
}

void
ahd_platform_scb_free(struct ahd_softc *ahd, struct scb *scb)
a815 19
}

int
ahd_get_pci_function(ahd_dev_softc_t pci)
{
	return (pci->pa_function);
}

int
ahd_get_pci_slot(ahd_dev_softc_t pci)
{
	return (pci->pa_device);
}


int
ahd_get_pci_bus(ahd_dev_softc_t pci)
{
	return (pci->pa_bus);
@


1.10
log
@More NetBSD cruft removal, starting with 'struct ahd_pci_busdata' and
the fallout from that. Ensure pcireg_t variables are being used with
pci_conf_read/write functions - found one uint16_t variable
(pcix_status) being used to store and restore (32 bit) pcireg_t
values.

Some KNF.

No functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.9 2004/10/10 15:08:10 marco Exp $	*/
a313 3
	if (scb->flags & SCB_FREEZE_QUEUE) {
                scb->flags &= ~SCB_FREEZE_QUEUE;
        }
d932 1
a932 7
	struct scsi_xfer *xs = scb->xs;
	int target;

	target = xs->sc_link->target;
	if (!(scb->flags & SCB_FREEZE_QUEUE)) {
		scb->flags |= SCB_FREEZE_QUEUE;
	}
@


1.9
log
@Work around "overlapped command" issue on devices that are slower than U320.  Committing this due to a preemptive "I don't like your fix" comment from krw@@

Tested by pval@@, krw@@ and me, ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.8 2004/08/23 20:16:01 marco Exp $	*/
a974 12
}

uint32_t
ahd_pci_read_config(ahd_dev_softc_t pci, int reg, int width)
{
	return (pci_conf_read(pci->pa_pc, pci->pa_tag, reg));
}

void
ahd_pci_write_config(ahd_dev_softc_t pci, int reg, uint32_t value, int width)
{
	pci_conf_write(pci->pa_pc, pci->pa_tag, reg, value);
@


1.8
log
@Fix license.  ok krw@@, deraadt@@ tedu@@ & Milos Urbanek <urbanek at zoom-int.cz>
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.7 2004/08/13 23:38:54 krw Exp $	*/
d499 8
@


1.7
log
@Fix issue with auto request sense handling for both ahc and ahd.

Restore hppa functionality, add sgi functionality for ahc.

ok deraadt@@, plus marco@@, mickey@@, pefo@@ for various bits.
@
text
@d1 29
a29 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.6 2004/08/06 01:29:19 marco Exp $	*/
a59 5
 *
 * Additional copyrights by:
 * Milos Urbanek
 * Kenneth R. Westerback
 * Marco Peereboom
@


1.6
log
@Remove __static inline to make the kernel ~24k smaller on i386 and make the debug sessions bearable.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.5 2004/06/22 22:40:35 krw Exp $	*/
d198 1
@


1.5
log
@Enable ahd interrupts and reset the channel before scanning the bus
for devices. This is how ahc is done too. Fixes probe hang on Theo's
box with the 7902B chip.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.4 2004/06/21 18:33:04 krw Exp $	*/
d47 1
d752 244
@


1.4
log
@Fix ahd_[get|set]_transaction_status vs ahd_[get|set]_scsi_status confusion.

Allocate max number of SCB's at initialization.

Display negotiated transfer parameters.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.3 2004/05/25 12:22:49 krw Exp $	*/
a111 3
	ahd->sc_child = config_found((void *)&ahd->sc_dev,
	    &ahd->sc_channel, scsiprint);

d116 3
@


1.3
log
@Attach scsi bus, find devices without crashing, successfully do simple
i/o's on i386. De-static many functions.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.2 2004/05/20 04:35:47 marco Exp $	*/
d188 2
a189 2
		if (ahd_get_scsi_status(scb) != CAM_REQ_INPROG)
                	ahd_set_scsi_status(scb, CAM_CMD_TIMEOUT);
d286 1
a286 1
		ahd_set_scsi_status(scb, XS_SENSE);
d294 1
a294 1
                ahd_set_scsi_status(scb, XS_REQUEUE);
d576 1
a576 1
		ahd_set_scsi_status(scb, CAM_REQ_INVALID);
@


1.3.2.1
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2
log
@Remove bogus $Id.
@
text
@d1 1
a1 1
/*	$OpenBSD: aic79xx_openbsd.c,v 1.1 2004/05/20 03:11:45 marco Exp $	*/
d53 4
a56 4
static int	ahd_action(struct scsi_xfer *);
static int	ahd_execute_scb(void *, bus_dma_segment_t *, int);
static int	ahd_poll(struct ahd_softc *, int);
static int	ahd_setup_data(struct ahd_softc *, struct scsi_xfer *, 
d112 3
d321 1
a321 1
static int32_t
d358 1
a358 1
	quirks = scb->xs->sc_link->quirks;
d404 1
a404 1
static int
d544 1
a544 1
static int
d562 1
a562 1
static int
@


1.1
log
@Add ahd.  ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 2
 *
 * $Id: aic79xx_openbsd.c,v 1.1.1.1 2004/05/17 14:17:17 openbsd-devel Exp $
@

