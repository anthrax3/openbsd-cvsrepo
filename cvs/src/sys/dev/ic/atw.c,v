head	1.95;
access;
symbols
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.92.0.2
	OPENBSD_5_9_BASE:1.92
	OPENBSD_5_8:1.87.0.4
	OPENBSD_5_8_BASE:1.87
	OPENBSD_5_7:1.86.0.2
	OPENBSD_5_7_BASE:1.86
	OPENBSD_5_6:1.83.0.4
	OPENBSD_5_6_BASE:1.83
	OPENBSD_5_5:1.80.0.4
	OPENBSD_5_5_BASE:1.80
	OPENBSD_5_4:1.76.0.10
	OPENBSD_5_4_BASE:1.76
	OPENBSD_5_3:1.76.0.8
	OPENBSD_5_3_BASE:1.76
	OPENBSD_5_2:1.76.0.4
	OPENBSD_5_2_BASE:1.76
	OPENBSD_5_1_BASE:1.76
	OPENBSD_5_1:1.76.0.6
	OPENBSD_5_0:1.76.0.2
	OPENBSD_5_0_BASE:1.76
	OPENBSD_4_9:1.75.0.2
	OPENBSD_4_9_BASE:1.75
	OPENBSD_4_8:1.69.0.4
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.69.0.2
	OPENBSD_4_7_BASE:1.69
	OPENBSD_4_6:1.66.0.4
	OPENBSD_4_6_BASE:1.66
	OPENBSD_4_5:1.65.0.2
	OPENBSD_4_5_BASE:1.65
	OPENBSD_4_4:1.60.0.2
	OPENBSD_4_4_BASE:1.60
	OPENBSD_4_3:1.55.0.2
	OPENBSD_4_3_BASE:1.55
	OPENBSD_4_2:1.54.0.2
	OPENBSD_4_2_BASE:1.54
	OPENBSD_4_1:1.52.0.2
	OPENBSD_4_1_BASE:1.52
	OPENBSD_4_0:1.48.0.2
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.29.0.2
	OPENBSD_3_7_BASE:1.29
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26;
locks; strict;
comment	@ * @;


1.95
date	2017.01.22.10.17.37;	author dlg;	state Exp;
branches;
next	1.94;
commitid	VyLWTsbepAOk7VQM;

1.94
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.93;
commitid	QHiEhS9DHyE6oiIr;

1.93
date	2016.03.15.20.50.22;	author krw;	state Exp;
branches;
next	1.92;
commitid	JZR2bOwahEjnBJaG;

1.92
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.91;
commitid	J9apD0jq2AjFmqZc;

1.91
date	2015.11.25.03.09.58;	author dlg;	state Exp;
branches;
next	1.90;
commitid	B0kwmVGiD5DVx4kv;

1.90
date	2015.11.04.12.11.59;	author dlg;	state Exp;
branches;
next	1.89;
commitid	YT6fyIEviv9qwbl6;

1.89
date	2015.10.25.12.48.46;	author mpi;	state Exp;
branches;
next	1.88;
commitid	p0v5tuE1Ch6fY0Nj;

1.88
date	2015.09.06.04.10.58;	author deraadt;	state Exp;
branches;
next	1.87;
commitid	TKxl4zDGz5dy4HmP;

1.87
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.86;
commitid	p4LJxGKbi0BU2cG6;

1.86
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.85;
commitid	Hly9lJn6CNMylcFu;

1.85
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.84;
commitid	yM2VFFhpDTeFQlve;

1.84
date	2014.12.19.22.44.58;	author guenther;	state Exp;
branches;
next	1.83;
commitid	LS2TNeCue5R9L67C;

1.83
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.82;
commitid	I19imNlAX05zJOED;

1.82
date	2014.07.08.17.19.25;	author deraadt;	state Exp;
branches;
next	1.81;
commitid	EF98ch02VpFassUi;

1.81
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.80;

1.80
date	2013.12.06.21.03.02;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2013.12.03.22.47.28;	author brad;	state Exp;
branches;
next	1.78;

1.78
date	2013.11.26.09.50.32;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2013.11.14.12.30.39;	author dlg;	state Exp;
branches;
next	1.76;

1.76
date	2011.04.05.19.54.35;	author jasper;	state Exp;
branches;
next	1.75;

1.75
date	2010.11.11.17.47.00;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.20.00.11.37;	author jsg;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.07.16.21.42;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2010.09.06.19.20.21;	author deraadt;	state Exp;
branches;
next	1.71;

1.71
date	2010.08.29.16.46.58;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2010.08.27.04.09.18;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2009.08.16.18.03.48;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2009.08.16.17.24.04;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2009.08.10.20.29.54;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2009.06.03.20.00.36;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.64;

1.64
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2008.10.03.00.58.39;	author brad;	state Exp;
branches;
next	1.62;

1.62
date	2008.08.29.09.30.23;	author damien;	state Exp;
branches;
next	1.61;

1.61
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2008.05.13.02.24.08;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2008.03.13.23.07.29;	author brad;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.30.11.33.14;	author kettenis;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.18.18.22.26;	author damien;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.07.20.20.15;	author damien;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.14.04.49.43;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.14.04.46.44;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.03.18.16.43;	author claudio;	state Exp;
branches;
next	1.49;

1.49
date	2006.11.26.17.20.33;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2006.08.30.11.20.20;	author jsg;	state Exp;
branches;
next	1.47;

1.47
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.25.22.41.42;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.22.19.39.06;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2006.02.28.06.52.35;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.17.09.13.22;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2005.10.11.13.07.02;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.09.24.11.19.14;	author jsg;	state Exp;
branches;
next	1.39;

1.39
date	2005.09.24.09.22.26;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2005.09.23.23.01.21;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2005.09.22.00.27.18;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2005.09.08.12.44.55;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.27.09.13.50;	author avsm;	state Exp;
branches;
next	1.34;

1.34
date	2005.07.18.02.43.26;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2005.07.02.23.10.16;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2005.06.21.05.36.43;	author kevlo;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.27.18.57.19;	author robert;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.26.16.35.25;	author naddy;	state Exp;
branches;
next	1.29;

1.29
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.15.05.24.10;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.31.04.27.52;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.25.13.36.08;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.25.00.30.48;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.25.00.16.35;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.25.00.03.52;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2004.07.19.21.14.17;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.15.16.21.13;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2004.07.15.16.13.10;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.15.16.11.51;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.15.15.50.51;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.15.15.39.40;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.15.15.28.59;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.15.15.11.02;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.15.13.00.49;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.15.12.55.09;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.15.12.29.39;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.15.12.22.02;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.15.12.18.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.15.12.15.09;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.15.12.08.14;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2004.07.15.12.00.31;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2004.07.15.11.53.32;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.07.19.19.37;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.07.19.18.35;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.07.19.11.27;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.07.19.07.23;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.22.23.55.24;	author millert;	state Exp;
branches;
next	;


desc
@@


1.95
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: atw.c,v 1.94 2016/04/13 10:49:26 mpi Exp $	*/
/*	$NetBSD: atw.c,v 1.69 2004/07/23 07:07:55 dyoung Exp $	*/

/*-
 * Copyright (c) 1998, 1999, 2000, 2002, 2003, 2004 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by David Young, by Jason R. Thorpe, and by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Device driver for the ADMtek ADM8211 802.11 MAC/BBP.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/time.h>
#include <sys/endian.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/atwreg.h>
#include <dev/ic/rf3000reg.h>
#include <dev/ic/si4136reg.h>
#include <dev/ic/atwvar.h>
#include <dev/ic/smc93cx6var.h>

/* XXX TBD open questions
 *
 *
 * When should I set DSSS PAD in reg 0x15 of RF3000? In 1-2Mbps
 * modes only, or all modes (5.5-11 Mbps CCK modes, too?) Does the MAC
 * handle this for me?
 *
 */
/* device attachment
 *
 *    print TOFS[012]
 *
 * device initialization
 *
 *    clear ATW_FRCTL_MAXPSP to disable max power saving
 *    set ATW_TXBR_ALCUPDATE to enable ALC
 *    set TOFS[012]? (hope not)
 *    disable rx/tx
 *    set ATW_PAR_SWR (software reset)
 *    wait for ATW_PAR_SWR clear
 *    disable interrupts
 *    ack status register
 *    enable interrupts
 *
 * rx/tx initialization
 *
 *    disable rx/tx w/ ATW_NAR_SR, ATW_NAR_ST
 *    allocate and init descriptor rings
 *    write ATW_PAR_DSL (descriptor skip length)
 *    write descriptor base addrs: ATW_TDBD, ATW_TDBP, write ATW_RDB
 *    write ATW_NAR_SQ for one/both transmit descriptor rings
 *    write ATW_NAR_SQ for one/both transmit descriptor rings
 *    enable rx/tx w/ ATW_NAR_SR, ATW_NAR_ST
 *
 * rx/tx end
 *
 *    stop DMA
 *    disable rx/tx w/ ATW_NAR_SR, ATW_NAR_ST
 *    flush tx w/ ATW_NAR_HF
 *
 * scan
 *
 *    initialize rx/tx
 *
 * BSS join: (re)association response
 *
 *    set ATW_FRCTL_AID
 *
 * optimizations ???
 *
 */

#define ATW_REFSLAVE	/* slavishly do what the reference driver does */

int atw_bbp_io_enable_delay = 20 * 1000;
int atw_bbp_io_disable_delay = 2 * 1000;
int atw_writewep_delay = 1000;
int atw_beacon_len_adjust = 4;
int atw_dwelltime = 200;
int atw_xindiv2 = 0;

#ifdef ATW_DEBUG
int atw_debug = 0;

#define ATW_DPRINTF(x)	if (atw_debug > 0) printf x
#define ATW_DPRINTF2(x)	if (atw_debug > 1) printf x
#define ATW_DPRINTF3(x)	if (atw_debug > 2) printf x
#define	DPRINTF(sc, x)	if ((sc)->sc_ic.ic_if.if_flags & IFF_DEBUG) printf x
#define	DPRINTF2(sc, x)	if ((sc)->sc_ic.ic_if.if_flags & IFF_DEBUG) ATW_DPRINTF2(x)
#define	DPRINTF3(sc, x)	if ((sc)->sc_ic.ic_if.if_flags & IFF_DEBUG) ATW_DPRINTF3(x)
void atw_print_regs(struct atw_softc *, const char *);
void atw_dump_pkt(struct ifnet *, struct mbuf *);

/* Note well: I never got atw_rf3000_read or atw_si4126_read to work. */
#	ifdef ATW_BBPDEBUG
int atw_rf3000_read(struct atw_softc *sc, u_int, u_int *);
void atw_rf3000_print(struct atw_softc *);
#	endif /* ATW_BBPDEBUG */

#	ifdef ATW_SYNDEBUG
int atw_si4126_read(struct atw_softc *, u_int, u_int *);
void atw_si4126_print(struct atw_softc *);
#	endif /* ATW_SYNDEBUG */

#else
#define ATW_DPRINTF(x)
#define ATW_DPRINTF2(x)
#define ATW_DPRINTF3(x)
#define	DPRINTF(sc, x)	/* nothing */
#define	DPRINTF2(sc, x)	/* nothing */
#define	DPRINTF3(sc, x)	/* nothing */
#endif

#ifdef ATW_STATS
void	atw_print_stats(struct atw_softc *);
#endif

const char *atw_printmac(u_int8_t);

/* ifnet methods */
void	atw_start(struct ifnet *);
void	atw_watchdog(struct ifnet *);
int	atw_ioctl(struct ifnet *, u_long, caddr_t);
int	atw_init(struct ifnet *);
void	atw_stop(struct ifnet *, int);

/* Rx/Tx process */
void	atw_rxdrain(struct atw_softc *);
void	atw_txdrain(struct atw_softc *);
int	atw_add_rxbuf(struct atw_softc *, int);
void	atw_idle(struct atw_softc *, u_int32_t);

/* Device (de)activation and power state */
void	atw_disable(struct atw_softc *);
void	atw_reset(struct atw_softc *);

/* Interrupt handlers */
void	atw_rxintr(struct atw_softc *);
void	atw_txintr(struct atw_softc *);
void	atw_linkintr(struct atw_softc *, u_int32_t);

/* 802.11 state machine */
int	atw_newstate(struct ieee80211com *, enum ieee80211_state, int);
int	atw_tune(struct atw_softc *);
#ifndef IEEE80211_STA_ONLY
void	atw_recv_mgmt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, struct ieee80211_rxinfo *, int);
#endif
void	atw_next_scan(void *);

/* Device initialization */
void	atw_wcsr_init(struct atw_softc *);
void	atw_cmdr_init(struct atw_softc *);
void	atw_tofs2_init(struct atw_softc *);
void	atw_txlmt_init(struct atw_softc *);
void	atw_test1_init(struct atw_softc *);
void	atw_rf_reset(struct atw_softc *);
void	atw_cfp_init(struct atw_softc *);
void	atw_tofs0_init(struct atw_softc *);
void	atw_ifs_init(struct atw_softc *);
void	atw_response_times_init(struct atw_softc *);
void	atw_bbp_io_init(struct atw_softc *);
void	atw_nar_init(struct atw_softc *);

/* RAM/ROM utilities */
void	atw_clear_sram(struct atw_softc *);
void	atw_write_sram(struct atw_softc *, u_int, u_int8_t *, u_int);
int	atw_read_srom(struct atw_softc *);

/* BSS setup */
void	atw_predict_beacon(struct atw_softc *sc);
void	atw_start_beacon(struct atw_softc *, int);
void	atw_write_bssid(struct atw_softc *);
void	atw_write_ssid(struct atw_softc *);
void	atw_write_sup_rates(struct atw_softc *);
void	atw_write_wep(struct atw_softc *);

/* Media */
int	atw_media_change(struct ifnet *);
void	atw_media_status(struct ifnet *, struct ifmediareq *);

void	atw_filter_setup(struct atw_softc *);

/* 802.11 utilities */
struct	ieee80211_node *atw_node_alloc(struct ieee80211com *);
void	atw_node_free(struct ieee80211com *, struct ieee80211_node *);
static	__inline uint32_t atw_last_even_tsft(uint32_t, uint32_t, uint32_t);
uint64_t atw_get_tsft(struct atw_softc *sc);
void	atw_change_ibss(struct atw_softc *);
int	atw_compute_duration1(int, int, uint32_t, int, struct atw_duration *);
int	atw_compute_duration(struct ieee80211_frame *, int, uint32_t, int,
	    int, struct atw_duration *, struct atw_duration *, int *, int);

/*
 * Tuner/transceiver/modem
 */
void	atw_bbp_io_enable(struct atw_softc *, int);

/* RFMD RF3000 Baseband Processor */
int	atw_rf3000_init(struct atw_softc *);
int	atw_rf3000_tune(struct atw_softc *, u_int);
int	atw_rf3000_write(struct atw_softc *, u_int, u_int);

/* Silicon Laboratories Si4126 RF/IF Synthesizer */
void	atw_si4126_tune(struct atw_softc *, u_int);
void	atw_si4126_write(struct atw_softc *, u_int, u_int);
void	atw_si4126_init(struct atw_softc *);

const struct atw_txthresh_tab atw_txthresh_tab_lo[] = {
	{ ATW_NAR_TR_L64,	"64 bytes" },
	{ ATW_NAR_TR_L160,	"160 bytes" },
	{ ATW_NAR_TR_L192,	"192 bytes" },
	{ ATW_NAR_SF,		"store and forward" },
	{ 0,			NULL }
};
const struct atw_txthresh_tab atw_txthresh_tab_hi[] = {
	{ ATW_NAR_TR_H96,	"96 bytes" },
	{ ATW_NAR_TR_H288,	"288 bytes" },
	{ ATW_NAR_TR_H544,	"544 bytes" },
	{ ATW_NAR_SF,		"store and forward" },
	{ 0,			NULL }
};

struct cfdriver atw_cd = {
    NULL, "atw", DV_IFNET
};

static const u_int atw_rfmd2958_ifn[] = {
	0x22bd, 0x22d2, 0x22e8, 0x22fe, 0x2314, 0x232a, 0x2340,
	0x2355, 0x236b, 0x2381, 0x2397, 0x23ad, 0x23c2, 0x23f7
};

static const u_int atw_rfmd2958_rf1r[] = {
	0x05d17, 0x3a2e8, 0x2e8ba, 0x22e8b, 0x1745d, 0x0ba2e, 0x00000,
	0x345d1, 0x28ba2, 0x1d174, 0x11745, 0x05d17, 0x3a2e8, 0x11745
};


#ifdef ATW_DEBUG

const char *atw_tx_state[] = {
	"STOPPED",
	"RUNNING - read descriptor",
	"RUNNING - transmitting",
	"RUNNING - filling fifo",	/* XXX */
	"SUSPENDED",
	"RUNNING -- write descriptor",
	"RUNNING -- write last descriptor",
	"RUNNING - fifo full"
};

const char *atw_rx_state[] = {
	"STOPPED",
	"RUNNING - read descriptor",
	"RUNNING - check this packet, pre-fetch next",
	"RUNNING - wait for reception",
	"SUSPENDED",
	"RUNNING - write descriptor",
	"RUNNING - flush fifo",
	"RUNNING - fifo drain"
};

#endif

/*
 * atw_enable:
 *
 *	Enable the ADM8211 chip.
 */
int
atw_enable(struct atw_softc *sc)
{

	if (ATW_IS_ENABLED(sc) == 0) {
		if (sc->sc_enable != NULL && (*sc->sc_enable)(sc) != 0) {
			printf("%s: device enable failed\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
		sc->sc_flags |= ATWF_ENABLED;
	}
	return (0);
}

/*
 * atw_disable:
 *
 *	Disable the ADM8211 chip.
 */
void
atw_disable(struct atw_softc *sc)
{
	if (!ATW_IS_ENABLED(sc))
		return;
	if (sc->sc_disable != NULL)
		(*sc->sc_disable)(sc);
	sc->sc_flags &= ~ATWF_ENABLED;
}

/* Returns -1 on failure. */
int
atw_read_srom(struct atw_softc *sc)
{
	struct seeprom_descriptor sd;
	u_int32_t test0, fail_bits;

	(void)memset(&sd, 0, sizeof(sd));

	test0 = ATW_READ(sc, ATW_TEST0);

	switch (sc->sc_rev) {
	case ATW_REVISION_BA:
	case ATW_REVISION_CA:
		fail_bits = ATW_TEST0_EPNE;
		break;
	default:
		fail_bits = ATW_TEST0_EPNE|ATW_TEST0_EPSNM;
		break;
	}
	if ((test0 & fail_bits) != 0) {
		printf("%s: bad or missing/bad SROM\n", sc->sc_dev.dv_xname);
		return -1;
	}

	switch (test0 & ATW_TEST0_EPTYP_MASK) {
	case ATW_TEST0_EPTYP_93c66:
		ATW_DPRINTF(("%s: 93c66 SROM\n", sc->sc_dev.dv_xname));
		sc->sc_sromsz = 512;
		sd.sd_chip = C56_66;
		break;
	case ATW_TEST0_EPTYP_93c46:
		ATW_DPRINTF(("%s: 93c46 SROM\n", sc->sc_dev.dv_xname));
		sc->sc_sromsz = 128;
		sd.sd_chip = C46;
		break;
	default:
		printf("%s: unknown SROM type %d\n", sc->sc_dev.dv_xname,
		    MASK_AND_RSHIFT(test0, ATW_TEST0_EPTYP_MASK));
		return -1;
	}

	sc->sc_srom = malloc(sc->sc_sromsz, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc->sc_srom == NULL) {
		printf("%s: unable to allocate SROM buffer\n",
		    sc->sc_dev.dv_xname);
		return -1;
	}

	/*
	 * ADM8211 has a single 32-bit register for controlling the
	 * 93cx6 SROM.  Bit SRS enables the serial port. There is no
	 * "ready" bit. The ADM8211 input/output sense is the reverse
	 * of read_seeprom's.
	 */
	sd.sd_tag = sc->sc_st;
	sd.sd_bsh = sc->sc_sh;
	sd.sd_regsize = 4;
	sd.sd_control_offset = ATW_SPR;
	sd.sd_status_offset = ATW_SPR;
	sd.sd_dataout_offset = ATW_SPR;
	sd.sd_CK = ATW_SPR_SCLK;
	sd.sd_CS = ATW_SPR_SCS;
	sd.sd_DI = ATW_SPR_SDO;
	sd.sd_DO = ATW_SPR_SDI;
	sd.sd_MS = ATW_SPR_SRS;
	sd.sd_RDY = 0;

	if (!read_seeprom(&sd, sc->sc_srom, 0, sc->sc_sromsz/2)) {
		printf("%s: could not read SROM\n", sc->sc_dev.dv_xname);
		free(sc->sc_srom, M_DEVBUF, sc->sc_sromsz);
		return -1;
	}
#ifdef ATW_DEBUG
	{
		int i;
		ATW_DPRINTF(("\nSerial EEPROM:\n\t"));
		for (i = 0; i < sc->sc_sromsz/2; i = i + 1) {
			if (((i % 8) == 0) && (i != 0)) {
				ATW_DPRINTF(("\n\t"));
			}
			ATW_DPRINTF((" 0x%x", sc->sc_srom[i]));
		}
		ATW_DPRINTF(("\n"));
	}
#endif /* ATW_DEBUG */
	return 0;
}

#ifdef ATW_DEBUG
void
atw_print_regs(struct atw_softc *sc, const char *where)
{
#define PRINTREG(sc, reg) \
	ATW_DPRINTF2(("%s: reg[ " #reg " / %03x ] = %08x\n", \
	    sc->sc_dev.dv_xname, reg, ATW_READ(sc, reg)))

	ATW_DPRINTF2(("%s: %s\n", sc->sc_dev.dv_xname, where));

	PRINTREG(sc, ATW_PAR);
	PRINTREG(sc, ATW_FRCTL);
	PRINTREG(sc, ATW_TDR);
	PRINTREG(sc, ATW_WTDP);
	PRINTREG(sc, ATW_RDR);
	PRINTREG(sc, ATW_WRDP);
	PRINTREG(sc, ATW_RDB);
	PRINTREG(sc, ATW_CSR3A);
	PRINTREG(sc, ATW_TDBD);
	PRINTREG(sc, ATW_TDBP);
	PRINTREG(sc, ATW_STSR);
	PRINTREG(sc, ATW_CSR5A);
	PRINTREG(sc, ATW_NAR);
	PRINTREG(sc, ATW_CSR6A);
	PRINTREG(sc, ATW_IER);
	PRINTREG(sc, ATW_CSR7A);
	PRINTREG(sc, ATW_LPC);
	PRINTREG(sc, ATW_TEST1);
	PRINTREG(sc, ATW_SPR);
	PRINTREG(sc, ATW_TEST0);
	PRINTREG(sc, ATW_WCSR);
	PRINTREG(sc, ATW_WPDR);
	PRINTREG(sc, ATW_GPTMR);
	PRINTREG(sc, ATW_GPIO);
	PRINTREG(sc, ATW_BBPCTL);
	PRINTREG(sc, ATW_SYNCTL);
	PRINTREG(sc, ATW_PLCPHD);
	PRINTREG(sc, ATW_MMIWADDR);
	PRINTREG(sc, ATW_MMIRADDR1);
	PRINTREG(sc, ATW_MMIRADDR2);
	PRINTREG(sc, ATW_TXBR);
	PRINTREG(sc, ATW_CSR15A);
	PRINTREG(sc, ATW_ALCSTAT);
	PRINTREG(sc, ATW_TOFS2);
	PRINTREG(sc, ATW_CMDR);
	PRINTREG(sc, ATW_PCIC);
	PRINTREG(sc, ATW_PMCSR);
	PRINTREG(sc, ATW_PAR0);
	PRINTREG(sc, ATW_PAR1);
	PRINTREG(sc, ATW_MAR0);
	PRINTREG(sc, ATW_MAR1);
	PRINTREG(sc, ATW_ATIMDA0);
	PRINTREG(sc, ATW_ABDA1);
	PRINTREG(sc, ATW_BSSID0);
	PRINTREG(sc, ATW_TXLMT);
	PRINTREG(sc, ATW_MIBCNT);
	PRINTREG(sc, ATW_BCNT);
	PRINTREG(sc, ATW_TSFTH);
	PRINTREG(sc, ATW_TSC);
	PRINTREG(sc, ATW_SYNRF);
	PRINTREG(sc, ATW_BPLI);
	PRINTREG(sc, ATW_CAP0);
	PRINTREG(sc, ATW_CAP1);
	PRINTREG(sc, ATW_RMD);
	PRINTREG(sc, ATW_CFPP);
	PRINTREG(sc, ATW_TOFS0);
	PRINTREG(sc, ATW_TOFS1);
	PRINTREG(sc, ATW_IFST);
	PRINTREG(sc, ATW_RSPT);
	PRINTREG(sc, ATW_TSFTL);
	PRINTREG(sc, ATW_WEPCTL);
	PRINTREG(sc, ATW_WESK);
	PRINTREG(sc, ATW_WEPCNT);
	PRINTREG(sc, ATW_MACTEST);
	PRINTREG(sc, ATW_FER);
	PRINTREG(sc, ATW_FEMR);
	PRINTREG(sc, ATW_FPSR);
	PRINTREG(sc, ATW_FFER);
#undef PRINTREG
}
#endif /* ATW_DEBUG */

const char*
atw_printmac(u_int8_t rev) {
	switch (rev) {
	case ATW_REVISION_AB:
		return "ADM8211AB";
	case ATW_REVISION_AF:
		return "ADM8211AF";
	case ATW_REVISION_BA:
		return "ADM8211BA";
	case ATW_REVISION_CA:
		return "ADM8211CA";
	default:
		return "unknown";
	}
}

/*
 * Finish attaching an ADMtek ADM8211 MAC.  Called by bus-specific front-end.
 */
void
atw_attach(struct atw_softc *sc)
{
	static const u_int8_t empty_macaddr[IEEE80211_ADDR_LEN] = {
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00
	};
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int country_code, error, i, srom_major;
	u_int32_t reg;
	static const char *type_strings[] = {"Intersil (not supported)",
	    "RFMD", "Marvel (not supported)"};

	sc->sc_txth = atw_txthresh_tab_lo;

	SIMPLEQ_INIT(&sc->sc_txfreeq);
	SIMPLEQ_INIT(&sc->sc_txdirtyq);

#ifdef ATW_DEBUG
	atw_print_regs(sc, "atw_attach");
#endif /* ATW_DEBUG */

	/*
	 * Allocate the control data structures, and create and load the
	 * DMA map for it.
	 */
	if ((error = bus_dmamem_alloc(sc->sc_dmat,
	    sizeof(struct atw_control_data), PAGE_SIZE, 0, &sc->sc_cdseg,
	    1, &sc->sc_cdnseg, 0)) != 0) {
		printf("%s: unable to allocate control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_0;
	}

	if ((error = bus_dmamem_map(sc->sc_dmat, &sc->sc_cdseg, sc->sc_cdnseg,
	    sizeof(struct atw_control_data), (caddr_t *)&sc->sc_control_data,
	    BUS_DMA_COHERENT)) != 0) {
		printf("%s: unable to map control data, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat,
	    sizeof(struct atw_control_data), 1,
	    sizeof(struct atw_control_data), 0, 0, &sc->sc_cddmamap)) != 0) {
		printf("%s: unable to create control data DMA map, "
		    "error = %d\n", sc->sc_dev.dv_xname, error);
		goto fail_2;
	}

	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_cddmamap,
	    sc->sc_control_data, sizeof(struct atw_control_data), NULL,
	    0)) != 0) {
		printf("%s: unable to load control data DMA map, error = %d\n",
		    sc->sc_dev.dv_xname, error);
		goto fail_3;
	}

	/*
	 * Create the transmit buffer DMA maps.
	 */
	sc->sc_ntxsegs = ATW_NTXSEGS;
	for (i = 0; i < ATW_TXQUEUELEN; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES,
		    sc->sc_ntxsegs, MCLBYTES, 0, 0,
		    &sc->sc_txsoft[i].txs_dmamap)) != 0) {
			printf("%s: unable to create tx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_4;
		}
	}

	/*
	 * Create the receive buffer DMA maps.
	 */
	for (i = 0; i < ATW_NRXDESC; i++) {
		if ((error = bus_dmamap_create(sc->sc_dmat, MCLBYTES, 1,
		    MCLBYTES, 0, 0, &sc->sc_rxsoft[i].rxs_dmamap)) != 0) {
			printf("%s: unable to create rx DMA map %d, "
			    "error = %d\n", sc->sc_dev.dv_xname, i, error);
			goto fail_5;
		}
	}
	for (i = 0; i < ATW_NRXDESC; i++) {
		sc->sc_rxsoft[i].rxs_mbuf = NULL;
	}

	switch (sc->sc_rev) {
	case ATW_REVISION_AB:
	case ATW_REVISION_AF:
		sc->sc_sramlen = ATW_SRAM_A_SIZE;
		break;
	case ATW_REVISION_BA:
	case ATW_REVISION_CA:
		sc->sc_sramlen = ATW_SRAM_B_SIZE;
		break;
	}

	/* Reset the chip to a known state. */
	atw_reset(sc);

	if (atw_read_srom(sc) == -1)
		return;

	sc->sc_rftype = MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_CSR20],
	    ATW_SR_RFTYPE_MASK);

	sc->sc_bbptype = MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_CSR20],
	    ATW_SR_BBPTYPE_MASK);

	if (sc->sc_rftype >= nitems(type_strings)) {
		printf("%s: unknown RF\n", sc->sc_dev.dv_xname);
		return;
	}
	if (sc->sc_bbptype >= nitems(type_strings)) {
		printf("%s: unknown BBP\n", sc->sc_dev.dv_xname);
		return;
	}

	printf("%s: MAC %s, BBP %s, RF %s", sc->sc_dev.dv_xname,
	    atw_printmac(sc->sc_rev), type_strings[sc->sc_bbptype],
	    type_strings[sc->sc_rftype]);

	/* XXX There exists a Linux driver which seems to use RFType = 0 for
	 * MARVEL. My bug, or theirs?
	 */

	reg = LSHIFT(sc->sc_rftype, ATW_SYNCTL_RFTYPE_MASK);

	switch (sc->sc_rftype) {
	case ATW_RFTYPE_INTERSIL:
		reg |= ATW_SYNCTL_CS1;
		break;
	case ATW_RFTYPE_RFMD:
		reg |= ATW_SYNCTL_CS0;
		break;
	case ATW_RFTYPE_MARVEL:
		break;
	}

	sc->sc_synctl_rd = reg | ATW_SYNCTL_RD;
	sc->sc_synctl_wr = reg | ATW_SYNCTL_WR;

	reg = LSHIFT(sc->sc_bbptype, ATW_BBPCTL_TYPE_MASK);

	switch (sc->sc_bbptype) {
	case ATW_BBPTYPE_INTERSIL:
		reg |= ATW_BBPCTL_TWI;
		break;
	case ATW_BBPTYPE_RFMD:
		reg |= ATW_BBPCTL_RF3KADDR_ADDR | ATW_BBPCTL_NEGEDGE_DO |
		    ATW_BBPCTL_CCA_ACTLO;
		break;
	case ATW_BBPTYPE_MARVEL:
		break;
	case ATW_C_BBPTYPE_RFMD:
		printf("%s: ADM8211C MAC/RFMD BBP not supported yet.\n",
		    sc->sc_dev.dv_xname);
		break;
	}

	sc->sc_bbpctl_wr = reg | ATW_BBPCTL_WR;
	sc->sc_bbpctl_rd = reg | ATW_BBPCTL_RD;

	/*
	 * From this point forward, the attachment cannot fail.  A failure
	 * before this point releases all resources that may have been
	 * allocated.
	 */
	sc->sc_flags |= ATWF_ATTACHED /* | ATWF_RTSCTS */;

	ATW_DPRINTF((" SROM MAC %04x%04x%04x",
	    htole16(sc->sc_srom[ATW_SR_MAC00]),
	    htole16(sc->sc_srom[ATW_SR_MAC01]),
	    htole16(sc->sc_srom[ATW_SR_MAC10])));

	srom_major = MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_FORMAT_VERSION],
	    ATW_SR_MAJOR_MASK);

	if (srom_major < 2)
		sc->sc_rf3000_options1 = 0;
	else if (sc->sc_rev == ATW_REVISION_BA) {
		sc->sc_rf3000_options1 =
		    MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_CR28_CR03],
		    ATW_SR_CR28_MASK);
	} else
		sc->sc_rf3000_options1 = 0;

	sc->sc_rf3000_options2 = MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_CTRY_CR29],
	    ATW_SR_CR29_MASK);

	country_code = MASK_AND_RSHIFT(sc->sc_srom[ATW_SR_CTRY_CR29],
	    ATW_SR_CTRY_MASK);

#define ADD_CHANNEL(_ic, _chan) do {					\
	_ic->ic_channels[_chan].ic_flags = IEEE80211_CHAN_B;		\
	_ic->ic_channels[_chan].ic_freq =				\
	    ieee80211_ieee2mhz(_chan, _ic->ic_channels[_chan].ic_flags);\
} while (0)

	/* Find available channels */
	switch (country_code) {
	case COUNTRY_MMK2:	/* 1-14 */
		ADD_CHANNEL(ic, 14);
		/*FALLTHROUGH*/
	case COUNTRY_ETSI:	/* 1-13 */
		for (i = 1; i <= 13; i++)
			ADD_CHANNEL(ic, i);
		break;
	case COUNTRY_FCC:	/* 1-11 */
	case COUNTRY_IC:	/* 1-11 */
		for (i = 1; i <= 11; i++)
			ADD_CHANNEL(ic, i);
		break;
	case COUNTRY_MMK:	/* 14 */
		ADD_CHANNEL(ic, 14);
		break;
	case COUNTRY_FRANCE:	/* 10-13 */
		for (i = 10; i <= 13; i++)
			ADD_CHANNEL(ic, i);
		break;
	default:	/* assume channels 10-11 */
	case COUNTRY_SPAIN:	/* 10-11 */
		for (i = 10; i <= 11; i++)
			ADD_CHANNEL(ic, i);
		break;
	}

	/* Read the MAC address. */
	reg = ATW_READ(sc, ATW_PAR0);
	ic->ic_myaddr[0] = MASK_AND_RSHIFT(reg, ATW_PAR0_PAB0_MASK);
	ic->ic_myaddr[1] = MASK_AND_RSHIFT(reg, ATW_PAR0_PAB1_MASK);
	ic->ic_myaddr[2] = MASK_AND_RSHIFT(reg, ATW_PAR0_PAB2_MASK);
	ic->ic_myaddr[3] = MASK_AND_RSHIFT(reg, ATW_PAR0_PAB3_MASK);
	reg = ATW_READ(sc, ATW_PAR1);
	ic->ic_myaddr[4] = MASK_AND_RSHIFT(reg, ATW_PAR1_PAB4_MASK);
	ic->ic_myaddr[5] = MASK_AND_RSHIFT(reg, ATW_PAR1_PAB5_MASK);

	if (IEEE80211_ADDR_EQ(ic->ic_myaddr, empty_macaddr)) {
		printf(" could not get mac address, attach failed\n");
		return;
	}

	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));

	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	ifp->if_ioctl = atw_ioctl;
	ifp->if_start = atw_start;
	ifp->if_watchdog = atw_watchdog;

	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_MONITOR | IEEE80211_C_WEP;
#ifndef IEEE80211_STA_ONLY
	ic->ic_caps |= IEEE80211_C_IBSS;
#endif
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;	

	/*
	 * Call MI attach routines.
	 */

	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = atw_newstate;

#ifndef IEEE80211_STA_ONLY
	sc->sc_recv_mgmt = ic->ic_recv_mgmt;
	ic->ic_recv_mgmt = atw_recv_mgmt;
#endif

	sc->sc_node_free = ic->ic_node_free;
	ic->ic_node_free = atw_node_free;

	sc->sc_node_alloc = ic->ic_node_alloc;
	ic->ic_node_alloc = atw_node_alloc;

	/* possibly we should fill in our own sc_send_prresp, since
	 * the ADM8211 is probably sending probe responses in ad hoc
	 * mode.
	 */

	/* complete initialization */
	ieee80211_media_init(ifp, atw_media_change, atw_media_status);
	timeout_set(&sc->sc_scan_to, atw_next_scan, sc);

#if NBPFILTER > 0
	bpfattach(&sc->sc_radiobpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);
#endif

	memset(&sc->sc_rxtapu, 0, sizeof(sc->sc_rxtapu));
	sc->sc_rxtap.ar_ihdr.it_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.ar_ihdr.it_present = ATW_RX_RADIOTAP_PRESENT;

	memset(&sc->sc_txtapu, 0, sizeof(sc->sc_txtapu));
	sc->sc_txtap.at_ihdr.it_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.at_ihdr.it_present = ATW_TX_RADIOTAP_PRESENT;

	return;

	/*
	 * Free any resources we've allocated during the failed attach
	 * attempt.  Do this in reverse order and fall through.
	 */
 fail_5:
	for (i = 0; i < ATW_NRXDESC; i++) {
		if (sc->sc_rxsoft[i].rxs_dmamap == NULL)
			continue;
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_rxsoft[i].rxs_dmamap);
	}
 fail_4:
	for (i = 0; i < ATW_TXQUEUELEN; i++) {
		if (sc->sc_txsoft[i].txs_dmamap == NULL)
			continue;
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_txsoft[i].txs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmat, sc->sc_cddmamap);
 fail_3:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_cddmamap);
 fail_2:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_control_data,
	    sizeof(struct atw_control_data));
 fail_1:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_cdseg, sc->sc_cdnseg);
 fail_0:
	return;
}

struct ieee80211_node *
atw_node_alloc(struct ieee80211com *ic)
{
	struct atw_softc *sc = (struct atw_softc *)ic->ic_if.if_softc;
	struct ieee80211_node *ni = (*sc->sc_node_alloc)(ic);

	DPRINTF(sc, ("%s: alloc node %p\n", sc->sc_dev.dv_xname, ni));
	return ni;
}

void
atw_node_free(struct ieee80211com *ic, struct ieee80211_node *ni)
{
	struct atw_softc *sc = (struct atw_softc *)ic->ic_if.if_softc;

	DPRINTF(sc, ("%s: freeing node %p %s\n", sc->sc_dev.dv_xname, ni,
	    ether_sprintf(ni->ni_bssid)));
	(*sc->sc_node_free)(ic, ni);
}


static void
atw_test1_reset(struct atw_softc *sc)
{
	switch (sc->sc_rev) {
	case ATW_REVISION_BA:
		if (1 /* XXX condition on transceiver type */) {
			ATW_SET(sc, ATW_TEST1, ATW_TEST1_TESTMODE_MONITOR);
		}
		break;
	case ATW_REVISION_CA:
		ATW_CLR(sc, ATW_TEST1, ATW_TEST1_TESTMODE_MASK);
		break;
	default:
		break;
	}
}

/*
 * atw_reset:
 *
 *	Perform a soft reset on the ADM8211.
 */
void
atw_reset(struct atw_softc *sc)
{
	int i;
	uint32_t lpc;

	ATW_WRITE(sc, ATW_NAR, 0x0);
	DELAY(20 * 1000);

	/* Reference driver has a cryptic remark indicating that this might
	 * power-on the chip.  I know that it turns off power-saving....
	 */
	ATW_WRITE(sc, ATW_FRCTL, 0x0);

	ATW_WRITE(sc, ATW_PAR, ATW_PAR_SWR);

	for (i = 0; i < 50; i++) {
		if (ATW_READ(sc, ATW_PAR) == 0)
			break;
		DELAY(1000);
	}

	/* ... and then pause 100ms longer for good measure. */
	DELAY(100 * 1000);

	DPRINTF2(sc, ("%s: atw_reset %d iterations\n", sc->sc_dev.dv_xname, i));

	if (ATW_ISSET(sc, ATW_PAR, ATW_PAR_SWR))
		printf("%s: reset failed to complete\n", sc->sc_dev.dv_xname);

	atw_test1_reset(sc);
	/*
	 * Initialize the PCI Access Register.
	 */
	sc->sc_busmode = ATW_PAR_PBL_8DW;

	ATW_WRITE(sc, ATW_PAR, sc->sc_busmode);
	DPRINTF(sc, ("%s: ATW_PAR %08x busmode %08x\n", sc->sc_dev.dv_xname,
	    ATW_READ(sc, ATW_PAR), sc->sc_busmode));

	/* Turn off maximum power saving, etc.
	 *
	 * XXX Following example of reference driver, should I set
	 * an AID of 1?  It didn't seem to help....
	 */
	ATW_WRITE(sc, ATW_FRCTL, 0x0);

	DELAY(100 * 1000);

	/* Recall EEPROM. */
	ATW_SET(sc, ATW_TEST0, ATW_TEST0_EPRLD);

	DELAY(10 * 1000);

	lpc = ATW_READ(sc, ATW_LPC);

	DPRINTF(sc, ("%s: ATW_LPC %#08x\n", __func__, lpc));

	/* A reset seems to affect the SRAM contents, so put them into
	 * a known state.
	 */
	atw_clear_sram(sc);

	memset(sc->sc_bssid, 0xff, sizeof(sc->sc_bssid));
}

void
atw_clear_sram(struct atw_softc *sc)
{
	memset(sc->sc_sram, 0, sizeof(sc->sc_sram));
	/* XXX not for revision 0x20. */
	atw_write_sram(sc, 0, sc->sc_sram, sc->sc_sramlen);
}

/* TBD atw_init
 *
 * set MAC based on ic->ic_bss->myaddr
 * write WEP keys
 * set TX rate
 */

/* Tell the ADM8211 to raise ATW_INTR_LINKOFF if 7 beacon intervals pass
 * without receiving a beacon with the preferred BSSID & SSID.
 * atw_write_bssid & atw_write_ssid set the BSSID & SSID.
 */
void
atw_wcsr_init(struct atw_softc *sc)
{
	uint32_t wcsr;

	wcsr = ATW_READ(sc, ATW_WCSR);
	wcsr &= ~(ATW_WCSR_BLN_MASK|ATW_WCSR_LSOE|ATW_WCSR_MPRE|ATW_WCSR_LSOE);
	wcsr |= LSHIFT(7, ATW_WCSR_BLN_MASK);
	ATW_WRITE(sc, ATW_WCSR, wcsr);	/* XXX resets wake-up status bits */

	DPRINTF(sc, ("%s: %s reg[WCSR] = %08x\n",
	    sc->sc_dev.dv_xname, __func__, ATW_READ(sc, ATW_WCSR)));
}

/* Turn off power management.  Set Rx store-and-forward mode. */
void
atw_cmdr_init(struct atw_softc *sc)
{
	uint32_t cmdr;
	cmdr = ATW_READ(sc, ATW_CMDR);
	cmdr &= ~ATW_CMDR_APM;
	cmdr |= ATW_CMDR_RTE;
	cmdr &= ~ATW_CMDR_DRT_MASK;
	cmdr |= ATW_CMDR_DRT_SF;

	ATW_WRITE(sc, ATW_CMDR, cmdr);
}

void
atw_tofs2_init(struct atw_softc *sc)
{
	uint32_t tofs2;
	/* XXX this magic can probably be figured out from the RFMD docs */
#ifndef ATW_REFSLAVE
	tofs2 = LSHIFT(4, ATW_TOFS2_PWR1UP_MASK)    | /* 8 ms = 4 * 2 ms */
	      LSHIFT(13, ATW_TOFS2_PWR0PAPE_MASK) | /* 13 us */
	      LSHIFT(8, ATW_TOFS2_PWR1PAPE_MASK)  | /* 8 us */
	      LSHIFT(5, ATW_TOFS2_PWR0TRSW_MASK)  | /* 5 us */
	      LSHIFT(12, ATW_TOFS2_PWR1TRSW_MASK) | /* 12 us */
	      LSHIFT(13, ATW_TOFS2_PWR0PE2_MASK)  | /* 13 us */
	      LSHIFT(4, ATW_TOFS2_PWR1PE2_MASK)   | /* 4 us */
	      LSHIFT(5, ATW_TOFS2_PWR0TXPE_MASK);  /* 5 us */
#else
	/* XXX new magic from reference driver source */
	tofs2 = LSHIFT(8, ATW_TOFS2_PWR1UP_MASK)    | /* 8 ms = 4 * 2 ms */
	      LSHIFT(8, ATW_TOFS2_PWR0PAPE_MASK) | /* 13 us */
	      LSHIFT(1, ATW_TOFS2_PWR1PAPE_MASK)  | /* 8 us */
	      LSHIFT(5, ATW_TOFS2_PWR0TRSW_MASK)  | /* 5 us */
	      LSHIFT(12, ATW_TOFS2_PWR1TRSW_MASK) | /* 12 us */
	      LSHIFT(13, ATW_TOFS2_PWR0PE2_MASK)  | /* 13 us */
	      LSHIFT(1, ATW_TOFS2_PWR1PE2_MASK)   | /* 4 us */
	      LSHIFT(8, ATW_TOFS2_PWR0TXPE_MASK);  /* 5 us */
#endif
	ATW_WRITE(sc, ATW_TOFS2, tofs2);
}

void
atw_nar_init(struct atw_softc *sc)
{
	ATW_WRITE(sc, ATW_NAR, ATW_NAR_SF|ATW_NAR_PB);
}

void
atw_txlmt_init(struct atw_softc *sc)
{
	ATW_WRITE(sc, ATW_TXLMT, LSHIFT(512, ATW_TXLMT_MTMLT_MASK) |
	                         LSHIFT(1, ATW_TXLMT_SRTYLIM_MASK));
}

void
atw_test1_init(struct atw_softc *sc)
{
	uint32_t test1;

	test1 = ATW_READ(sc, ATW_TEST1);
	test1 &= ~(ATW_TEST1_DBGREAD_MASK|ATW_TEST1_CONTROL);
	/* XXX magic 0x1 */
	test1 |= LSHIFT(0x1, ATW_TEST1_DBGREAD_MASK) | ATW_TEST1_CONTROL;
	ATW_WRITE(sc, ATW_TEST1, test1);
}

void
atw_rf_reset(struct atw_softc *sc)
{
	/* XXX this resets an Intersil RF front-end? */
	/* TBD condition on Intersil RFType? */
	ATW_WRITE(sc, ATW_SYNRF, ATW_SYNRF_INTERSIL_EN);
	DELAY(10 * 1000);
	ATW_WRITE(sc, ATW_SYNRF, 0);
	DELAY(5 * 1000);
}

/* Set 16 TU max duration for the contention-free period (CFP). */
void
atw_cfp_init(struct atw_softc *sc)
{
	uint32_t cfpp;

	cfpp = ATW_READ(sc, ATW_CFPP);
	cfpp &= ~ATW_CFPP_CFPMD;
	cfpp |= LSHIFT(16, ATW_CFPP_CFPMD);
	ATW_WRITE(sc, ATW_CFPP, cfpp);
}

void
atw_tofs0_init(struct atw_softc *sc)
{
	/* XXX I guess that the Cardbus clock is 22MHz?
	 * I am assuming that the role of ATW_TOFS0_USCNT is
	 * to divide the bus clock to get a 1MHz clock---the datasheet is not
	 * very clear on this point. It says in the datasheet that it is
	 * possible for the ADM8211 to accommodate bus speeds between 22MHz
	 * and 33MHz; maybe this is the way? I see a binary-only driver write
	 * these values. These values are also the power-on default.
	 */
	ATW_WRITE(sc, ATW_TOFS0,
	    LSHIFT(22, ATW_TOFS0_USCNT_MASK) |
	    ATW_TOFS0_TUCNT_MASK /* set all bits in TUCNT */);
}

/* Initialize interframe spacing: 802.11b slot time, SIFS, DIFS, EIFS. */
void
atw_ifs_init(struct atw_softc *sc)
{
	uint32_t ifst;
	/* XXX EIFS=0x64, SIFS=110 are used by the reference driver.
	 * Go figure.
	 */
	ifst = LSHIFT(IEEE80211_DUR_DS_SLOT, ATW_IFST_SLOT_MASK) |
	    LSHIFT(22 * 5 /* IEEE80211_DUR_DS_SIFS */ /* # of 22MHz cycles */,
		   ATW_IFST_SIFS_MASK) |
	    LSHIFT(IEEE80211_DUR_DS_DIFS, ATW_IFST_DIFS_MASK) |
	    LSHIFT(0x64 /* IEEE80211_DUR_DS_EIFS */, ATW_IFST_EIFS_MASK);

	ATW_WRITE(sc, ATW_IFST, ifst);
}

void
atw_response_times_init(struct atw_softc *sc)
{
	/* XXX More magic. Relates to ACK timing?  The datasheet seems to
	 * indicate that the MAC expects at least SIFS + MIRT microseconds
	 * to pass after it transmits a frame that requires a response;
	 * it waits at most SIFS + MART microseconds for the response.
	 * Surely this is not the ACK timeout?
	 */
	ATW_WRITE(sc, ATW_RSPT, LSHIFT(0xffff, ATW_RSPT_MART_MASK) |
	    LSHIFT(0xff, ATW_RSPT_MIRT_MASK));
}

/* Set up the MMI read/write addresses for the baseband. The Tx/Rx
 * engines read and write baseband registers after Rx and before
 * Tx, respectively.
 */
void
atw_bbp_io_init(struct atw_softc *sc)
{
	uint32_t mmiraddr2;

	/* XXX The reference driver does this, but is it *really*
	 * necessary?
	 */
	switch (sc->sc_rev) {
	case ATW_REVISION_AB:
	case ATW_REVISION_AF:
		mmiraddr2 = 0x0;
		break;
	default:
		mmiraddr2 = ATW_READ(sc, ATW_MMIRADDR2);
		mmiraddr2 &=
		    ~(ATW_MMIRADDR2_PROREXT|ATW_MMIRADDR2_PRORLEN_MASK);
		break;
	}

	switch (sc->sc_bbptype) {
	case ATW_BBPTYPE_INTERSIL:
		ATW_WRITE(sc, ATW_MMIWADDR, ATW_MMIWADDR_INTERSIL);
		ATW_WRITE(sc, ATW_MMIRADDR1, ATW_MMIRADDR1_INTERSIL);
		mmiraddr2 |= ATW_MMIRADDR2_INTERSIL;
		break;
	case ATW_BBPTYPE_MARVEL:
		/* TBD find out the Marvel settings. */
		break;
	case ATW_BBPTYPE_RFMD:
	default:
		ATW_WRITE(sc, ATW_MMIWADDR, ATW_MMIWADDR_RFMD);
		ATW_WRITE(sc, ATW_MMIRADDR1, ATW_MMIRADDR1_RFMD);
		mmiraddr2 |= ATW_MMIRADDR2_RFMD;
		break;
	}
	ATW_WRITE(sc, ATW_MMIRADDR2, mmiraddr2);

	atw_si4126_init(sc);

	ATW_WRITE(sc, ATW_MACTEST, ATW_MACTEST_MMI_USETXCLK);
}

void
atw_si4126_init(struct atw_softc *sc)
{
	switch (sc->sc_rftype) {
	case ATW_RFTYPE_RFMD:
		if (sc->sc_rev >= ATW_REVISION_BA) {
			atw_si4126_write(sc, 0x1f, 0x00000);
			atw_si4126_write(sc, 0x0c, 0x3001f);
			atw_si4126_write(sc, SI4126_GAIN, 0x29c03);
			atw_si4126_write(sc, SI4126_RF1N, 0x1ff6f);
			atw_si4126_write(sc, SI4126_RF2N, 0x29403);
			atw_si4126_write(sc, SI4126_RF2R, 0x1456f);
			atw_si4126_write(sc, 0x09, 0x10050);
			atw_si4126_write(sc, SI4126_IFR, 0x3fff8);
		}
		break;
	default:
		break;
	}
}

/*
 * atw_init:		[ ifnet interface function ]
 *
 *	Initialize the interface.  Must be called at splnet().
 */
int
atw_init(struct ifnet *ifp)
{
	struct atw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct atw_txsoft *txs;
	struct atw_rxsoft *rxs;
	int i, error = 0;

	if ((error = atw_enable(sc)) != 0)
		goto out;

	/*
	 * Cancel any pending I/O. This also resets.
	 */
	atw_stop(ifp, 0);

	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	DPRINTF(sc, ("%s: channel %d freq %d flags 0x%04x\n",
	    __func__, ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan),
	    ic->ic_bss->ni_chan->ic_freq, ic->ic_bss->ni_chan->ic_flags));

	atw_wcsr_init(sc);

	atw_cmdr_init(sc);

	/* Set data rate for PLCP Signal field, 1Mbps = 10 x 100Kb/s.
	 *
	 * XXX Set transmit power for ATIM, RTS, Beacon.
	 */
	ATW_WRITE(sc, ATW_PLCPHD, LSHIFT(10, ATW_PLCPHD_SIGNAL_MASK) |
	    LSHIFT(0xb0, ATW_PLCPHD_SERVICE_MASK));

	atw_tofs2_init(sc);

	atw_nar_init(sc);

	atw_txlmt_init(sc);

	atw_test1_init(sc);

	atw_rf_reset(sc);

	atw_cfp_init(sc);

	atw_tofs0_init(sc);

	atw_ifs_init(sc);

	/* XXX Fall asleep after one second of inactivity.
	 * XXX A frame may only dribble in for 65536us.
	 */
	ATW_WRITE(sc, ATW_RMD,
	    LSHIFT(1, ATW_RMD_PCNT) | LSHIFT(0xffff, ATW_RMD_RMRD_MASK));

	atw_response_times_init(sc);

	atw_bbp_io_init(sc);

	ATW_WRITE(sc, ATW_STSR, 0xffffffff);

	if ((error = atw_rf3000_init(sc)) != 0)
		goto out;

	ATW_WRITE(sc, ATW_PAR, sc->sc_busmode);
	DPRINTF(sc, ("%s: ATW_PAR %08x busmode %08x\n", sc->sc_dev.dv_xname,
	    ATW_READ(sc, ATW_PAR), sc->sc_busmode));

	/*
	 * Initialize the transmit descriptor ring.
	 */
	memset(sc->sc_txdescs, 0, sizeof(sc->sc_txdescs));
	for (i = 0; i < ATW_NTXDESC; i++) {
		sc->sc_txdescs[i].at_ctl = 0;
		/* no transmit chaining */
		sc->sc_txdescs[i].at_flags = 0 /* ATW_TXFLAG_TCH */;
		sc->sc_txdescs[i].at_buf2 =
		    htole32(ATW_CDTXADDR(sc, ATW_NEXTTX(i)));
	}
	/* use ring mode */
	sc->sc_txdescs[ATW_NTXDESC - 1].at_flags |= htole32(ATW_TXFLAG_TER);
	ATW_CDTXSYNC(sc, 0, ATW_NTXDESC,
	    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);
	sc->sc_txfree = ATW_NTXDESC;
	sc->sc_txnext = 0;

	/*
	 * Initialize the transmit job descriptors.
	 */
	SIMPLEQ_INIT(&sc->sc_txfreeq);
	SIMPLEQ_INIT(&sc->sc_txdirtyq);
	for (i = 0; i < ATW_TXQUEUELEN; i++) {
		txs = &sc->sc_txsoft[i];
		txs->txs_mbuf = NULL;
		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);
	}

	/*
	 * Initialize the receive descriptor and receive job
	 * descriptor rings.
	 */
	for (i = 0; i < ATW_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf == NULL) {
			if ((error = atw_add_rxbuf(sc, i)) != 0) {
				printf("%s: unable to allocate or map rx "
				    "buffer %d, error = %d\n",
				    sc->sc_dev.dv_xname, i, error);
				/*
				 * XXX Should attempt to run with fewer receive
				 * XXX buffers instead of just failing.
				 */
				atw_rxdrain(sc);
				goto out;
			}
		} else
			ATW_INIT_RXDESC(sc, i);
	}
	sc->sc_rxptr = 0;

	/*
	 * Initialize the interrupt mask and enable interrupts.
	 */
	/* normal interrupts */
	sc->sc_inten =  ATW_INTR_TCI | ATW_INTR_TDU | ATW_INTR_RCI |
	    ATW_INTR_NISS | ATW_INTR_LINKON | ATW_INTR_BCNTC;

	/* abnormal interrupts */
	sc->sc_inten |= ATW_INTR_TPS | ATW_INTR_TLT | ATW_INTR_TRT |
	    ATW_INTR_TUF | ATW_INTR_RDU | ATW_INTR_RPS | ATW_INTR_AISS |
	    ATW_INTR_FBE | ATW_INTR_LINKOFF | ATW_INTR_TSFTF | ATW_INTR_TSCZ;

	sc->sc_linkint_mask = ATW_INTR_LINKON | ATW_INTR_LINKOFF |
	    ATW_INTR_BCNTC | ATW_INTR_TSFTF | ATW_INTR_TSCZ;
	sc->sc_rxint_mask = ATW_INTR_RCI | ATW_INTR_RDU;
	sc->sc_txint_mask = ATW_INTR_TCI | ATW_INTR_TUF | ATW_INTR_TLT |
	    ATW_INTR_TRT;

	sc->sc_linkint_mask &= sc->sc_inten;
	sc->sc_rxint_mask &= sc->sc_inten;
	sc->sc_txint_mask &= sc->sc_inten;

	ATW_WRITE(sc, ATW_IER, sc->sc_inten);
	ATW_WRITE(sc, ATW_STSR, 0xffffffff);

	DPRINTF(sc, ("%s: ATW_IER %08x, inten %08x\n",
	    sc->sc_dev.dv_xname, ATW_READ(sc, ATW_IER), sc->sc_inten));

	/*
	 * Give the transmit and receive rings to the ADM8211.
	 */
	ATW_WRITE(sc, ATW_RDB, ATW_CDRXADDR(sc, sc->sc_rxptr));
	ATW_WRITE(sc, ATW_TDBD, ATW_CDTXADDR(sc, sc->sc_txnext));

	sc->sc_txthresh = 0;
	sc->sc_opmode = ATW_NAR_SR | ATW_NAR_ST |
	    sc->sc_txth[sc->sc_txthresh].txth_opmode;

	/* common 802.11 configuration */
	ic->ic_flags &= ~IEEE80211_F_IBSSON;
	switch (ic->ic_opmode) {
	case IEEE80211_M_STA:
		break;
#ifndef IEEE80211_STA_ONLY
	case IEEE80211_M_AHDEMO: /* XXX */
	case IEEE80211_M_IBSS:
		ic->ic_flags |= IEEE80211_F_IBSSON;
		/*FALLTHROUGH*/
#endif
	default: /* XXX */
		break;
	}

#ifndef IEEE80211_STA_ONLY
	switch (ic->ic_opmode) {
	case IEEE80211_M_AHDEMO:
		ic->ic_bss->ni_intval = ic->ic_lintval;
		ic->ic_bss->ni_rssi = 0;
		ic->ic_bss->ni_rstamp = 0;
		break;
	default:					/* XXX */
		break;
	}
#endif
	sc->sc_wepctl = 0;

	atw_write_ssid(sc);
	atw_write_sup_rates(sc);
	if (ic->ic_caps & IEEE80211_C_WEP)
		atw_write_wep(sc);

	ic->ic_state = IEEE80211_S_INIT;

	/*
	 * Set the receive filter.  This will start the transmit and
	 * receive processes.
	 */
	atw_filter_setup(sc);

	/*
	 * Start the receive process.
	 */
	ATW_WRITE(sc, ATW_RDR, 0x1);

	/*
	 * Note that the interface is now running.
	 */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* send no beacons, yet. */
	atw_start_beacon(sc, 0);

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		error = ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		error = ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
 out:
	if (error) {
		ifp->if_flags &= ~IFF_RUNNING;
		ifq_clr_oactive(&ifp->if_snd);
		ifp->if_timer = 0;
		printf("%s: interface not running\n", sc->sc_dev.dv_xname);
	}
#ifdef ATW_DEBUG
	atw_print_regs(sc, "end of init");
#endif /* ATW_DEBUG */

	return (error);
}

/* enable == 1: host control of RF3000/Si4126 through ATW_SYNCTL.
 *           0: MAC control of RF3000/Si4126.
 *
 * Applies power, or selects RF front-end? Sets reset condition.
 *
 * TBD support non-RFMD BBP, non-SiLabs synth.
 */
void
atw_bbp_io_enable(struct atw_softc *sc, int enable)
{
	if (enable) {
		ATW_WRITE(sc, ATW_SYNRF,
		    ATW_SYNRF_SELRF|ATW_SYNRF_PE1|ATW_SYNRF_PHYRST);
		DELAY(atw_bbp_io_enable_delay);
	} else {
		ATW_WRITE(sc, ATW_SYNRF, 0);
		DELAY(atw_bbp_io_disable_delay); /* shorter for some reason */
	}
}

int
atw_tune(struct atw_softc *sc)
{
	int rc;
	u_int chan;
	struct ieee80211com *ic = &sc->sc_ic;

	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return 0;

	if (chan == sc->sc_cur_chan)
		return 0;

	DPRINTF(sc, ("%s: chan %d -> %d\n", sc->sc_dev.dv_xname,
	    sc->sc_cur_chan, chan));

	atw_idle(sc, ATW_NAR_SR|ATW_NAR_ST);

	atw_si4126_tune(sc, chan);
	if ((rc = atw_rf3000_tune(sc, chan)) != 0)
		printf("%s: failed to tune channel %d\n", sc->sc_dev.dv_xname,
		    chan);

	ATW_WRITE(sc, ATW_NAR, sc->sc_opmode);
	DELAY(20 * 1000);
	ATW_WRITE(sc, ATW_RDR, 0x1);

	if (rc == 0)
		sc->sc_cur_chan = chan;

	return rc;
}

#ifdef ATW_SYNDEBUG
void
atw_si4126_print(struct atw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	u_int addr, val;

	if (atw_debug < 3 || (ifp->if_flags & IFF_DEBUG) == 0)
		return;

	for (addr = 0; addr <= 8; addr++) {
		printf("%s: synth[%d] = ", sc->sc_dev.dv_xname, addr);
		if (atw_si4126_read(sc, addr, &val) == 0) {
			printf("<unknown> (quitting print-out)\n");
			break;
		}
		printf("%05x\n", val);
	}
}
#endif /* ATW_SYNDEBUG */

/* Tune to channel chan by adjusting the Si4126 RF/IF synthesizer.
 *
 * The RF/IF synthesizer produces two reference frequencies for
 * the RF2948B transceiver.  The first frequency the RF2948B requires
 * is two times the so-called "intermediate frequency" (IF). Since
 * a SAW filter on the radio fixes the IF at 374MHz, I program the
 * Si4126 to generate IF LO = 374MHz x 2 = 748MHz.  The second
 * frequency required by the transceiver is the radio frequency
 * (RF). This is a superheterodyne transceiver; for f(chan) the
 * center frequency of the channel we are tuning, RF = f(chan) -
 * IF.
 *
 * XXX I am told by SiLabs that the Si4126 will accept a broader range
 * of XIN than the 2-25MHz mentioned by the datasheet, even *without*
 * XINDIV2 = 1.  I've tried this (it is necessary to double R) and it
 * works, but I have still programmed for XINDIV2 = 1 to be safe.
 */
void
atw_si4126_tune(struct atw_softc *sc, u_int chan)
{
	u_int mhz;
	u_int R;
	u_int32_t gpio;
	u_int16_t gain;

#ifdef ATW_SYNDEBUG
	atw_si4126_print(sc);
#endif /* ATW_SYNDEBUG */

	if (sc->sc_rev >= ATW_REVISION_BA) {
		atw_si4126_write(sc, SI4126_MAIN, 0x04007);
		atw_si4126_write(sc, SI4126_POWER, 0x00033);
		atw_si4126_write(sc, SI4126_IFN,
		    atw_rfmd2958_ifn[chan - 1]);
		atw_si4126_write(sc, SI4126_RF1R,
		    atw_rfmd2958_rf1r[chan - 1]);
#ifdef NOTYET
		/* set TX POWER? */
		atw_si4126_write(sc, 0x0a,
		    (sc->sc_srom[ATW_SR_CSR20] & mask) |
		    power << 9);
#endif
		/* set TX GAIN */
		atw_si4126_write(sc, 0x09, 0x00050 |
		    sc->sc_srom[ATW_SR_TXPOWER(chan - 1)]);
		/* wait 100us from power-up for RF, IF to settle */
		DELAY(100);

		return;
	}

	if (chan == 14)
		mhz = 2484;
	else
		mhz = 2412 + 5 * (chan - 1);

	/* Tune IF to 748MHz to suit the IF LO input of the
	 * RF2494B, which is 2 x IF. No need to set an IF divider
         * because an IF in 526MHz - 952MHz is allowed.
	 *
	 * XIN is 44.000MHz, so divide it by two to get allowable
	 * range of 2-25MHz. SiLabs tells me that this is not
	 * strictly necessary.
	 */

	if (atw_xindiv2)
		R = 44;
	else
		R = 88;

	/* Power-up RF, IF synthesizers. */
	atw_si4126_write(sc, SI4126_POWER,
	    SI4126_POWER_PDIB|SI4126_POWER_PDRB);

	/* set LPWR, too? */
	atw_si4126_write(sc, SI4126_MAIN,
	    (atw_xindiv2) ? SI4126_MAIN_XINDIV2 : 0);

	/* Set the phase-locked loop gain.  If RF2 N > 2047, then
	 * set KP2 to 1.
	 *
	 * REFDIF This is different from the reference driver, which
	 * always sets SI4126_GAIN to 0.
	 */
	gain = LSHIFT(((mhz - 374) > 2047) ? 1 : 0, SI4126_GAIN_KP2_MASK);

	atw_si4126_write(sc, SI4126_GAIN, gain);

	/* XIN = 44MHz.
	 *
	 * If XINDIV2 = 1, IF = N/(2 * R) * XIN.  I choose N = 1496,
	 * R = 44 so that 1496/(2 * 44) * 44MHz = 748MHz.
	 *
	 * If XINDIV2 = 0, IF = N/R * XIN.  I choose N = 1496, R = 88
	 * so that 1496/88 * 44MHz = 748MHz.
	 */
	atw_si4126_write(sc, SI4126_IFN, 1496);

	atw_si4126_write(sc, SI4126_IFR, R);

#ifndef ATW_REFSLAVE
	/* Set RF1 arbitrarily. DO NOT configure RF1 after RF2, because
	 * then RF1 becomes the active RF synthesizer, even on the Si4126,
	 * which has no RF1!
	 */
	atw_si4126_write(sc, SI4126_RF1R, R);

	atw_si4126_write(sc, SI4126_RF1N, mhz - 374);
#endif

	/* N/R * XIN = RF. XIN = 44MHz. We desire RF = mhz - IF,
	 * where IF = 374MHz.  Let's divide XIN to 1MHz. So R = 44.
	 * Now let's multiply it to mhz. So mhz - IF = N.
	 */
	atw_si4126_write(sc, SI4126_RF2R, R);

	atw_si4126_write(sc, SI4126_RF2N, mhz - 374);

	/* wait 100us from power-up for RF, IF to settle */
	DELAY(100);

	gpio = ATW_READ(sc, ATW_GPIO);
	gpio &= ~(ATW_GPIO_EN_MASK|ATW_GPIO_O_MASK|ATW_GPIO_I_MASK);
	gpio |= LSHIFT(1, ATW_GPIO_EN_MASK);

	if ((sc->sc_if.if_flags & IFF_LINK1) != 0 && chan != 14) {
		/* Set a Prism RF front-end to a special mode for channel 14?
		 *
		 * Apparently the SMC2635W needs this, although I don't think
		 * it has a Prism RF.
		 */
		gpio |= LSHIFT(1, ATW_GPIO_O_MASK);
	}
	ATW_WRITE(sc, ATW_GPIO, gpio);

#ifdef ATW_SYNDEBUG
	atw_si4126_print(sc);
#endif /* ATW_SYNDEBUG */
}

/* Baseline initialization of RF3000 BBP: set CCA mode and enable antenna
 * diversity.
 *
 * !!!
 * !!! Call this w/ Tx/Rx suspended, atw_idle(, ATW_NAR_ST|ATW_NAR_SR).
 * !!!
 */
int
atw_rf3000_init(struct atw_softc *sc)
{
	int rc = 0;

	atw_bbp_io_enable(sc, 1);

	/* CCA is acquisition sensitive */
	rc = atw_rf3000_write(sc, RF3000_CCACTL,
	    LSHIFT(RF3000_CCACTL_MODE_BOTH, RF3000_CCACTL_MODE_MASK));

	if (rc != 0)
		goto out;

	/* enable diversity */
	rc = atw_rf3000_write(sc, RF3000_DIVCTL, RF3000_DIVCTL_ENABLE);

	if (rc != 0)
		goto out;

	/* sensible setting from a binary-only driver */
	rc = atw_rf3000_write(sc, RF3000_GAINCTL,
	    LSHIFT(0x1d, RF3000_GAINCTL_TXVGC_MASK));

	if (rc != 0)
		goto out;

	/* magic from a binary-only driver */
	rc = atw_rf3000_write(sc, RF3000_LOGAINCAL,
	    LSHIFT(0x38, RF3000_LOGAINCAL_CAL_MASK));

	if (rc != 0)
		goto out;

	rc = atw_rf3000_write(sc, RF3000_HIGAINCAL, RF3000_HIGAINCAL_DSSSPAD);

	if (rc != 0)
		goto out;

	/*
	 * XXX Reference driver remarks that Abocom sets this to 50.
	 * Meaning 0x50, I think....  50 = 0x32, which would set a bit
	 * in the "reserved" area of register RF3000_OPTIONS1.
	 */
	rc = atw_rf3000_write(sc, RF3000_OPTIONS1, sc->sc_rf3000_options1);

	if (rc != 0)
		goto out;

	rc = atw_rf3000_write(sc, RF3000_OPTIONS2, sc->sc_rf3000_options2);

	if (rc != 0)
		goto out;

out:
	atw_bbp_io_enable(sc, 0);
	return rc;
}

#ifdef ATW_BBPDEBUG
void
atw_rf3000_print(struct atw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	u_int addr, val;

	if (atw_debug < 3 || (ifp->if_flags & IFF_DEBUG) == 0)
		return;

	for (addr = 0x01; addr <= 0x15; addr++) {
		printf("%s: bbp[%d] = \n", sc->sc_dev.dv_xname, addr);
		if (atw_rf3000_read(sc, addr, &val) != 0) {
			printf("<unknown> (quitting print-out)\n");
			break;
		}
		printf("%08x\n", val);
	}
}
#endif /* ATW_BBPDEBUG */

/* Set the power settings on the BBP for channel `chan'. */
int
atw_rf3000_tune(struct atw_softc *sc, u_int chan)
{
	int rc = 0;
	u_int32_t reg;
	u_int16_t txpower, lpf_cutoff, lna_gs_thresh;

	txpower = sc->sc_srom[ATW_SR_TXPOWER(chan)];
	lpf_cutoff = sc->sc_srom[ATW_SR_LPF_CUTOFF(chan)];
	lna_gs_thresh = sc->sc_srom[ATW_SR_LNA_GS_THRESH(chan)];

	/* odd channels: LSB, even channels: MSB */
	if (chan % 2 == 1) {
		txpower &= 0xFF;
		lpf_cutoff &= 0xFF;
		lna_gs_thresh &= 0xFF;
	} else {
		txpower >>= 8;
		lpf_cutoff >>= 8;
		lna_gs_thresh >>= 8;
	}

#ifdef ATW_BBPDEBUG
	atw_rf3000_print(sc);
#endif /* ATW_BBPDEBUG */

	DPRINTF(sc, ("%s: chan %d txpower %02x, lpf_cutoff %02x, "
	    "lna_gs_thresh %02x\n",
	    sc->sc_dev.dv_xname, chan, txpower, lpf_cutoff, lna_gs_thresh));

	atw_bbp_io_enable(sc, 1);

	if ((rc = atw_rf3000_write(sc, RF3000_GAINCTL,
	    LSHIFT(txpower, RF3000_GAINCTL_TXVGC_MASK))) != 0)
		goto out;

	if ((rc = atw_rf3000_write(sc, RF3000_LOGAINCAL, lpf_cutoff)) != 0)
		goto out;

	if ((rc = atw_rf3000_write(sc, RF3000_HIGAINCAL, lna_gs_thresh)) != 0)
		goto out;

	if ((rc = atw_rf3000_write(sc, RF3000_OPTIONS1, 0x0)) != 0)
		goto out;

	rc = atw_rf3000_write(sc, RF3000_OPTIONS2, RF3000_OPTIONS2_LNAGS_DELAY);
	if (rc != 0)
		goto out;

#ifdef ATW_BBPDEBUG
	atw_rf3000_print(sc);
#endif /* ATW_BBPDEBUG */

out:
	atw_bbp_io_enable(sc, 0);

	/* set beacon, rts, atim transmit power */
	reg = ATW_READ(sc, ATW_PLCPHD);
	reg &= ~ATW_PLCPHD_SERVICE_MASK;
	reg |= LSHIFT(LSHIFT(txpower, RF3000_GAINCTL_TXVGC_MASK),
	    ATW_PLCPHD_SERVICE_MASK);
	ATW_WRITE(sc, ATW_PLCPHD, reg);
	DELAY(2 * 1000);

	return rc;
}

/* Write a register on the RF3000 baseband processor using the
 * registers provided by the ADM8211 for this purpose.
 *
 * Return 0 on success.
 */
int
atw_rf3000_write(struct atw_softc *sc, u_int addr, u_int val)
{
	u_int32_t reg;
	int i;

	reg = sc->sc_bbpctl_wr |
	     LSHIFT(val & 0xff, ATW_BBPCTL_DATA_MASK) |
	     LSHIFT(addr & 0x7f, ATW_BBPCTL_ADDR_MASK);

	for (i = 10; --i >= 0; ) {
		ATW_WRITE(sc, ATW_BBPCTL, reg);
		DELAY(2000);
		if (ATW_ISSET(sc, ATW_BBPCTL, ATW_BBPCTL_WR) == 0)
			break;
	}

	if (i < 0) {
		printf("%s: BBPCTL still busy\n", sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}
	return 0;
}

/* Read a register on the RF3000 baseband processor using the registers
 * the ADM8211 provides for this purpose.
 *
 * The 7-bit register address is addr.  Record the 8-bit data in the register
 * in *val.
 *
 * Return 0 on success.
 *
 * XXX This does not seem to work. The ADM8211 must require more or
 * different magic to read the chip than to write it. Possibly some
 * of the magic I have derived from a binary-only driver concerns
 * the "chip address" (see the RF3000 manual).
 */
#ifdef ATW_BBPDEBUG
int
atw_rf3000_read(struct atw_softc *sc, u_int addr, u_int *val)
{
	u_int32_t reg;
	int i;

	for (i = 1000; --i >= 0; ) {
		if (ATW_ISSET(sc, ATW_BBPCTL, ATW_BBPCTL_RD|ATW_BBPCTL_WR) == 0)
			break;
		DELAY(100);
	}

	if (i < 0) {
		printf("%s: start atw_rf3000_read, BBPCTL busy\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	reg = sc->sc_bbpctl_rd | LSHIFT(addr & 0x7f, ATW_BBPCTL_ADDR_MASK);

	ATW_WRITE(sc, ATW_BBPCTL, reg);

	for (i = 1000; --i >= 0; ) {
		DELAY(100);
		if (ATW_ISSET(sc, ATW_BBPCTL, ATW_BBPCTL_RD) == 0)
			break;
	}

	ATW_CLR(sc, ATW_BBPCTL, ATW_BBPCTL_RD);

	if (i < 0) {
		printf("%s: atw_rf3000_read wrote %08x; BBPCTL still busy\n",
		    sc->sc_dev.dv_xname, reg);
		return ETIMEDOUT;
	}
	if (val != NULL)
		*val = MASK_AND_RSHIFT(reg, ATW_BBPCTL_DATA_MASK);
	return 0;
}
#endif /* ATW_BBPDEBUG */

/* Write a register on the Si4126 RF/IF synthesizer using the registers
 * provided by the ADM8211 for that purpose.
 *
 * val is 18 bits of data, and val is the 4-bit address of the register.
 *
 * Return 0 on success.
 */
void
atw_si4126_write(struct atw_softc *sc, u_int addr, u_int val)
{
	uint32_t bits, mask, reg;
	int nbits;

	if (sc->sc_rev >= ATW_REVISION_BA) {
		nbits = 24;

		val &= 0x3ffff;
		addr &= 0x1f;
		bits = val | (addr << 18);
	} else {
		nbits = 22;

		KASSERT((addr & ~PRESHIFT(SI4126_TWI_ADDR_MASK)) == 0);
		KASSERT((val & ~PRESHIFT(SI4126_TWI_DATA_MASK)) == 0);

		bits = LSHIFT(val, SI4126_TWI_DATA_MASK) |
		    LSHIFT(addr, SI4126_TWI_ADDR_MASK);
	}

	reg = ATW_SYNRF_SELSYN;
	/* reference driver: reset Si4126 serial bus to initial
	 * conditions?
	 */
	ATW_WRITE(sc, ATW_SYNRF, reg | ATW_SYNRF_LEIF);
	ATW_WRITE(sc, ATW_SYNRF, reg);

	for (mask = (1 << (nbits - 1)); mask != 0; mask >>= 1) {
		if ((bits & mask) != 0)
			reg |= ATW_SYNRF_SYNDATA;
		else
			reg &= ~ATW_SYNRF_SYNDATA;
		ATW_WRITE(sc, ATW_SYNRF, reg);
		ATW_WRITE(sc, ATW_SYNRF, reg | ATW_SYNRF_SYNCLK);
		ATW_WRITE(sc, ATW_SYNRF, reg);
	}
	ATW_WRITE(sc, ATW_SYNRF, reg | ATW_SYNRF_LEIF);
	ATW_WRITE(sc, ATW_SYNRF, 0x0);
}

/* Read 18-bit data from the 4-bit address addr in Si4126
 * RF synthesizer and write the data to *val. Return 0 on success.
 *
 * XXX This does not seem to work. The ADM8211 must require more or
 * different magic to read the chip than to write it.
 */
#ifdef ATW_SYNDEBUG
int
atw_si4126_read(struct atw_softc *sc, u_int addr, u_int *val)
{
	u_int32_t reg;
	int i;

	KASSERT((addr & ~PRESHIFT(SI4126_TWI_ADDR_MASK)) == 0);

	for (i = 1000; --i >= 0; ) {
		if (ATW_ISSET(sc, ATW_SYNCTL, ATW_SYNCTL_RD|ATW_SYNCTL_WR) == 0)
			break;
		DELAY(100);
	}

	if (i < 0) {
		printf("%s: start atw_si4126_read, SYNCTL busy\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

	reg = sc->sc_synctl_rd | LSHIFT(addr, ATW_SYNCTL_DATA_MASK);

	ATW_WRITE(sc, ATW_SYNCTL, reg);

	for (i = 1000; --i >= 0; ) {
		DELAY(100);
		if (ATW_ISSET(sc, ATW_SYNCTL, ATW_SYNCTL_RD) == 0)
			break;
	}

	ATW_CLR(sc, ATW_SYNCTL, ATW_SYNCTL_RD);

	if (i < 0) {
		printf("%s: atw_si4126_read wrote %#08x, SYNCTL still busy\n",
		    sc->sc_dev.dv_xname, reg);
		return ETIMEDOUT;
	}
	if (val != NULL)
		*val = MASK_AND_RSHIFT(ATW_READ(sc, ATW_SYNCTL),
		                       ATW_SYNCTL_DATA_MASK);
	return 0;
}
#endif /* ATW_SYNDEBUG */

/* XXX is the endianness correct? test. */
#define	atw_calchash(addr) \
	(ether_crc32_le((addr), IEEE80211_ADDR_LEN) & 0x3f)

/*
 * atw_filter_setup:
 *
 *	Set the ADM8211's receive filter.
 */
void
atw_filter_setup(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct arpcom *ac = &ic->ic_ac;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int hash;
	u_int32_t hashes[2];
	struct ether_multi *enm;
	struct ether_multistep step;

	/* According to comments in tlp_al981_filter_setup
	 * (dev/ic/tulip.c) the ADMtek AL981 does not like for its
	 * multicast filter to be set while it is running.  Hopefully
	 * the ADM8211 is not the same!
	 */
	if ((ifp->if_flags & IFF_RUNNING) != 0)
		atw_idle(sc, ATW_NAR_SR);

	sc->sc_opmode &= ~(ATW_NAR_PR|ATW_NAR_MM);

	/* XXX in scan mode, do not filter packets.  Maybe this is
	 * unnecessary.
	 */
	if (ic->ic_state == IEEE80211_S_SCAN ||
	    (ifp->if_flags & IFF_PROMISC) != 0) {
		sc->sc_opmode |= ATW_NAR_PR;
		goto allmulti;
	}

	hashes[0] = hashes[1] = 0x0;

	if (ac->ac_multirangecnt > 0)
		goto allmulti;

	/*
	 * Program the 64-bit multicast hash filter.
	 */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		hash = atw_calchash(enm->enm_addrlo);
		hashes[hash >> 5] |= 1 << (hash & 0x1f);
		ETHER_NEXT_MULTI(step, enm);
		sc->sc_opmode |= ATW_NAR_MM;
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
	goto setit;

allmulti:
	sc->sc_opmode |= ATW_NAR_MM;
	ifp->if_flags |= IFF_ALLMULTI;
	hashes[0] = hashes[1] = 0xffffffff;

setit:
	ATW_WRITE(sc, ATW_MAR0, hashes[0]);
	ATW_WRITE(sc, ATW_MAR1, hashes[1]);
	ATW_WRITE(sc, ATW_NAR, sc->sc_opmode);
	DELAY(20 * 1000);
	ATW_WRITE(sc, ATW_RDR, 0x1);

	DPRINTF(sc, ("%s: ATW_NAR %08x opmode %08x\n", sc->sc_dev.dv_xname,
	    ATW_READ(sc, ATW_NAR), sc->sc_opmode));
}

/* Tell the ADM8211 our preferred BSSID. The ADM8211 must match
 * a beacon's BSSID and SSID against the preferred BSSID and SSID
 * before it will raise ATW_INTR_LINKON. When the ADM8211 receives
 * no beacon with the preferred BSSID and SSID in the number of
 * beacon intervals given in ATW_BPLI, then it raises ATW_INTR_LINKOFF.
 */
void
atw_write_bssid(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	u_int8_t *bssid;

	bssid = ic->ic_bss->ni_bssid;

	ATW_WRITE(sc, ATW_BSSID0,
	    LSHIFT(bssid[0], ATW_BSSID0_BSSIDB0_MASK) |
	    LSHIFT(bssid[1], ATW_BSSID0_BSSIDB1_MASK) |
	    LSHIFT(bssid[2], ATW_BSSID0_BSSIDB2_MASK) |
	    LSHIFT(bssid[3], ATW_BSSID0_BSSIDB3_MASK));

	ATW_WRITE(sc, ATW_ABDA1,
	    (ATW_READ(sc, ATW_ABDA1) &
	    ~(ATW_ABDA1_BSSIDB4_MASK|ATW_ABDA1_BSSIDB5_MASK)) |
	    LSHIFT(bssid[4], ATW_ABDA1_BSSIDB4_MASK) |
	    LSHIFT(bssid[5], ATW_ABDA1_BSSIDB5_MASK));

	DPRINTF(sc, ("%s: BSSID %s -> ", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_bssid)));
	DPRINTF(sc, ("%s\n", ether_sprintf(bssid)));

	memcpy(sc->sc_bssid, bssid, sizeof(sc->sc_bssid));
}

/* Write buflen bytes from buf to SRAM starting at the SRAM's ofs'th
 * 16-bit word.
 */
void
atw_write_sram(struct atw_softc *sc, u_int ofs, u_int8_t *buf, u_int buflen)
{
	u_int i;
	u_int8_t *ptr;

	memcpy(&sc->sc_sram[ofs], buf, buflen);

	KASSERT(ofs % 2 == 0 && buflen % 2 == 0);

	KASSERT(buflen + ofs <= sc->sc_sramlen);

	ptr = &sc->sc_sram[ofs];

	for (i = 0; i < buflen; i += 2) {
		ATW_WRITE(sc, ATW_WEPCTL, ATW_WEPCTL_WR |
		    LSHIFT((ofs + i) / 2, ATW_WEPCTL_TBLADD_MASK));
		DELAY(atw_writewep_delay);

		ATW_WRITE(sc, ATW_WESK,
		    LSHIFT((ptr[i + 1] << 8) | ptr[i], ATW_WESK_DATA_MASK));
		DELAY(atw_writewep_delay);
	}
	ATW_WRITE(sc, ATW_WEPCTL, sc->sc_wepctl); /* restore WEP condition */

	if (sc->sc_if.if_flags & IFF_DEBUG) {
		int n_octets = 0;
		printf("%s: wrote %d bytes at 0x%x wepctl 0x%08x\n",
		    sc->sc_dev.dv_xname, buflen, ofs, sc->sc_wepctl);
		for (i = 0; i < buflen; i++) {
			printf(" %02x", ptr[i]);
			if (++n_octets % 24 == 0)
				printf("\n");
		}
		if (n_octets % 24 != 0)
			printf("\n");
	}
}

/* Write WEP keys from the ieee80211com to the ADM8211's SRAM. */
void
atw_write_wep(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
#if 0
	u_int32_t reg;
	int i;
#endif
	/* SRAM shared-key record format: key0 flags key1 ... key12 */
	u_int8_t buf[IEEE80211_WEP_NKID]
	            [1 /* key[0] */ + 1 /* flags */ + 12 /* key[1 .. 12] */];

	sc->sc_wepctl = 0;
	ATW_WRITE(sc, ATW_WEPCTL, sc->sc_wepctl);

	if ((ic->ic_flags & IEEE80211_F_WEPON) == 0)
		return;

	memset(&buf[0][0], 0, sizeof(buf));

#if 0
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		if (ic->ic_nw_keys[i].k_len > 5) {
			buf[i][1] = ATW_WEP_ENABLED | ATW_WEP_104BIT;
		} else if (ic->ic_nw_keys[i].k_len != 0) {
			buf[i][1] = ATW_WEP_ENABLED;
		} else {
			buf[i][1] = 0;
			continue;
		}
		buf[i][0] = ic->ic_nw_keys[i].k_key[0];
		memcpy(&buf[i][2], &ic->ic_nw_keys[i].k_key[1],
		    ic->ic_nw_keys[i].k_len - 1);
	}

	reg = ATW_READ(sc, ATW_MACTEST);
	reg |= ATW_MACTEST_MMI_USETXCLK | ATW_MACTEST_FORCE_KEYID;
	reg &= ~ATW_MACTEST_KEYID_MASK;
	reg |= LSHIFT(ic->ic_wep_txkey, ATW_MACTEST_KEYID_MASK);
	ATW_WRITE(sc, ATW_MACTEST, reg);

	sc->sc_wepctl = ATW_WEPCTL_WEPENABLE;

	switch (sc->sc_rev) {
	case ATW_REVISION_AB:
	case ATW_REVISION_AF:
		/* Bypass WEP on Rx. */
		sc->sc_wepctl |= ATW_WEPCTL_WEPRXBYP;
		break;
	default:
		break;
	}
#endif

	atw_write_sram(sc, ATW_SRAM_ADDR_SHARED_KEY, (u_int8_t*)&buf[0][0],
	    sizeof(buf));
}

void
atw_change_ibss(struct atw_softc *sc)
{
	atw_predict_beacon(sc);
	atw_write_bssid(sc);
	atw_start_beacon(sc, 1);
}

#ifndef IEEE80211_STA_ONLY
void
atw_recv_mgmt(struct ieee80211com *ic, struct mbuf *m,
    struct ieee80211_node *ni, struct ieee80211_rxinfo *rxi, int subtype)
{
	struct atw_softc *sc = (struct atw_softc*)ic->ic_softc;

	/* The ADM8211A answers probe requests. */
	if (subtype == IEEE80211_FC0_SUBTYPE_PROBE_REQ &&
	    sc->sc_rev < ATW_REVISION_BA)
		return;

	(*sc->sc_recv_mgmt)(ic, m, ni, rxi, subtype);

	switch (subtype) {
	case IEEE80211_FC0_SUBTYPE_PROBE_RESP:
	case IEEE80211_FC0_SUBTYPE_BEACON:
		if (ic->ic_opmode != IEEE80211_M_IBSS ||
		    ic->ic_state != IEEE80211_S_RUN)
			break;
		if (ieee80211_ibss_merge(ic, ni, atw_get_tsft(sc)) == ENETRESET)
			atw_change_ibss(sc);
		break;
	default:
		break;
	}
	return;
}
#endif

/* Write the SSID in the ieee80211com to the SRAM on the ADM8211.
 * In ad hoc mode, the SSID is written to the beacons sent by the
 * ADM8211. In both ad hoc and infrastructure mode, beacons received
 * with matching SSID affect ATW_INTR_LINKON/ATW_INTR_LINKOFF
 * indications.
 */
void
atw_write_ssid(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	/* 34 bytes are reserved in ADM8211 SRAM for the SSID, but
	 * it only expects the element length, not its ID.
	 */
	u_int8_t buf[roundup(1 /* length */ + IEEE80211_NWID_LEN, 2)];

	memset(buf, 0, sizeof(buf));
	buf[0] = ic->ic_bss->ni_esslen;
	memcpy(&buf[1], ic->ic_bss->ni_essid, ic->ic_bss->ni_esslen);

	atw_write_sram(sc, ATW_SRAM_ADDR_SSID, buf,
	    roundup(1 + ic->ic_bss->ni_esslen, 2));
}

/* Write the supported rates in the ieee80211com to the SRAM of the ADM8211.
 * In ad hoc mode, the supported rates are written to beacons sent by the
 * ADM8211.
 */
void
atw_write_sup_rates(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	/*
	 * There is not enough space in the ADM8211 SRAM for the
	 * full IEEE80211_RATE_MAXSIZE
	 */
	u_int8_t buf[12];
	u_int8_t nrates;

	memset(buf, 0, sizeof(buf));
	if (ic->ic_bss->ni_rates.rs_nrates > sizeof(buf) - 1)
		nrates = sizeof(buf) - 1;
	else
		nrates = ic->ic_bss->ni_rates.rs_nrates;
	buf[0] = nrates;
	memcpy(&buf[1], ic->ic_bss->ni_rates.rs_rates, nrates);

	/* XXX deal with rev BA bug linux driver talks of? */

	atw_write_sram(sc, ATW_SRAM_ADDR_SUPRATES, buf, sizeof(buf));
}

/* Start/stop sending beacons. */
void
atw_start_beacon(struct atw_softc *sc, int start)
{
	struct ieee80211com *ic = &sc->sc_ic;
#ifndef IEEE80211_STA_ONLY
	uint16_t chan;
	uint32_t bpli;
#endif
	uint32_t bcnt, cap0, cap1, capinfo;
	size_t len;

	if (ATW_IS_ENABLED(sc) == 0)
		return;

	/* start beacons */
	len = sizeof(struct ieee80211_frame) +
	    8 /* timestamp */ + 2 /* beacon interval */ +
	    2 /* capability info */ +
	    2 + ic->ic_bss->ni_esslen /* SSID element */ +
	    2 + ic->ic_bss->ni_rates.rs_nrates /* rates element */ +
	    3 /* DS parameters */ +
	    IEEE80211_CRC_LEN;

	bcnt = ATW_READ(sc, ATW_BCNT) & ~ATW_BCNT_BCNT_MASK;
	cap0 = ATW_READ(sc, ATW_CAP0) & ~ATW_CAP0_CHN_MASK;
	cap1 = ATW_READ(sc, ATW_CAP1) & ~ATW_CAP1_CAPI_MASK;

	ATW_WRITE(sc, ATW_BCNT, bcnt);
	ATW_WRITE(sc, ATW_CAP1, cap1);

	if (!start)
		return;

	/* TBD use ni_capinfo */

	capinfo = 0;
	if (sc->sc_flags & ATWF_SHORT_PREAMBLE)
		capinfo |= IEEE80211_CAPINFO_SHORT_PREAMBLE;
	if (ic->ic_flags & IEEE80211_F_WEPON)
		capinfo |= IEEE80211_CAPINFO_PRIVACY;

#ifndef IEEE80211_STA_ONLY
	switch (ic->ic_opmode) {
	case IEEE80211_M_IBSS:
		len += 4; /* IBSS parameters */
		capinfo |= IEEE80211_CAPINFO_IBSS;
		break;
	default:
		return;
	}

	/* set listen interval
	 * XXX do software units agree w/ hardware?
	 */
	bpli = LSHIFT(ic->ic_bss->ni_intval, ATW_BPLI_BP_MASK) |
	    LSHIFT(ic->ic_lintval / ic->ic_bss->ni_intval, ATW_BPLI_LI_MASK);

	chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

	bcnt |= LSHIFT(len, ATW_BCNT_BCNT_MASK);
	cap0 |= LSHIFT(chan, ATW_CAP0_CHN_MASK);
	cap1 |= LSHIFT(capinfo, ATW_CAP1_CAPI_MASK);

	ATW_WRITE(sc, ATW_BCNT, bcnt);
	ATW_WRITE(sc, ATW_BPLI, bpli);
	ATW_WRITE(sc, ATW_CAP0, cap0);
	ATW_WRITE(sc, ATW_CAP1, cap1);

	DPRINTF(sc, ("%s: atw_start_beacon reg[ATW_BCNT] = %08x\n",
	    sc->sc_dev.dv_xname, bcnt));
	DPRINTF(sc, ("%s: atw_start_beacon reg[ATW_CAP1] = %08x\n",
	    sc->sc_dev.dv_xname, cap1));
#endif
}

/* Return the 32 lsb of the last TSFT divisible by ival. */
static __inline uint32_t
atw_last_even_tsft(uint32_t tsfth, uint32_t tsftl, uint32_t ival)
{
	/* Following the reference driver's lead, I compute
	 *
	 *   (uint32_t)((((uint64_t)tsfth << 32) | tsftl) % ival)
	 *
	 * without using 64-bit arithmetic, using the following
	 * relationship:
	 *
	 *     (0x100000000 * H + L) % m
	 *   = ((0x100000000 % m) * H + L) % m
	 *   = (((0xffffffff + 1) % m) * H + L) % m
	 *   = ((0xffffffff % m + 1 % m) * H + L) % m
	 *   = ((0xffffffff % m + 1) * H + L) % m
	 */
	return ((0xFFFFFFFF % ival + 1) * tsfth + tsftl) % ival;
}

uint64_t
atw_get_tsft(struct atw_softc *sc)
{
	int i;
	uint32_t tsfth, tsftl;
	for (i = 0; i < 2; i++) {
		tsfth = ATW_READ(sc, ATW_TSFTH);
		tsftl = ATW_READ(sc, ATW_TSFTL);
		if (ATW_READ(sc, ATW_TSFTH) == tsfth)
			break;
	}
	return ((uint64_t)tsfth << 32) | tsftl;
}

/* If we've created an IBSS, write the TSF time in the ADM8211 to
 * the ieee80211com.
 *
 * Predict the next target beacon transmission time (TBTT) and
 * write it to the ADM8211.
 */
void
atw_predict_beacon(struct atw_softc *sc)
{
#define TBTTOFS 20 /* TU */

	struct ieee80211com *ic = &sc->sc_ic;
	uint64_t tsft;
	uint32_t ival, past_even, tbtt, tsfth, tsftl;
	union {
		uint64_t	word;
		uint8_t		tstamp[8];
	} u;

#ifndef IEEE80211_STA_ONLY
	if ((ic->ic_opmode == IEEE80211_M_IBSS) &&
	    (ic->ic_flags & IEEE80211_F_SIBSS)) {
		tsft = atw_get_tsft(sc);
		u.word = htole64(tsft);
		(void)memcpy(&ic->ic_bss->ni_tstamp[0], &u.tstamp[0],
		    sizeof(ic->ic_bss->ni_tstamp));
	} else
#endif
	{
		(void)memcpy(&u, &ic->ic_bss->ni_tstamp[0], sizeof(u));
		tsft = letoh64(u.word);
	}

	ival = ic->ic_bss->ni_intval * IEEE80211_DUR_TU;

	tsftl = tsft & 0xFFFFFFFF;
	tsfth = tsft >> 32;

	/* We sent/received the last beacon `past' microseconds
	 * after the interval divided the TSF timer.
	 */
	past_even = tsftl - atw_last_even_tsft(tsfth, tsftl, ival);

	/* Skip ten beacons so that the TBTT cannot pass before
	 * we've programmed it.  Ten is an arbitrary number.
	 */
	tbtt = past_even + ival * 10;

	ATW_WRITE(sc, ATW_TOFS1,
	    LSHIFT(1, ATW_TOFS1_TSFTOFSR_MASK) |
	    LSHIFT(TBTTOFS, ATW_TOFS1_TBTTOFS_MASK) |
	    LSHIFT(MASK_AND_RSHIFT(tbtt - TBTTOFS * IEEE80211_DUR_TU,
	        ATW_TBTTPRE_MASK), ATW_TOFS1_TBTTPRE_MASK));
#undef TBTTOFS
}

void
atw_next_scan(void *arg)
{
	struct atw_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	/* don't call atw_start w/o network interrupts blocked */
	s = splnet();
	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
	splx(s);
}

/* Synchronize the hardware state with the software state. */
int
atw_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet *ifp = &ic->ic_if;
	struct atw_softc *sc = ifp->if_softc;
	enum ieee80211_state ostate = ic->ic_state;
	int error;

	if (nstate == IEEE80211_S_INIT) {
		timeout_del(&sc->sc_scan_to);
		sc->sc_cur_chan = IEEE80211_CHAN_ANY;
		atw_start_beacon(sc, 0);
		return (*sc->sc_newstate)(ic, nstate, arg);
	}

	if ((error = atw_tune(sc)) != 0)
		return error;

	switch (nstate) {
	case IEEE80211_S_ASSOC:
		break;
	case IEEE80211_S_INIT:
		panic("%s: unexpected state IEEE80211_S_INIT", __func__);
		break;
	case IEEE80211_S_SCAN:
		timeout_add_msec(&sc->sc_scan_to, atw_dwelltime);
		break;
	case IEEE80211_S_RUN:
		if (ic->ic_opmode == IEEE80211_M_STA)
			break;
		/*FALLTHROUGH*/
	case IEEE80211_S_AUTH:
		atw_write_bssid(sc);
		atw_write_ssid(sc);
		atw_write_sup_rates(sc);

		if (
#ifndef IEEE80211_STA_ONLY
		    ic->ic_opmode == IEEE80211_M_AHDEMO ||
#endif
		    ic->ic_opmode == IEEE80211_M_MONITOR)
			break;

		/* set listen interval
		 * XXX do software units agree w/ hardware?
		 */
		ATW_WRITE(sc, ATW_BPLI,
		    LSHIFT(ic->ic_bss->ni_intval, ATW_BPLI_BP_MASK) |
		    LSHIFT(ic->ic_lintval / ic->ic_bss->ni_intval,
			   ATW_BPLI_LI_MASK));

		DPRINTF(sc, ("%s: reg[ATW_BPLI] = %08x\n",
		    sc->sc_dev.dv_xname, ATW_READ(sc, ATW_BPLI)));

		atw_predict_beacon(sc);
		break;
	}

	if (nstate != IEEE80211_S_SCAN)
		timeout_del(&sc->sc_scan_to);

#ifndef IEEE80211_STA_ONLY
	if (nstate == IEEE80211_S_RUN &&
	    ic->ic_opmode == IEEE80211_M_IBSS)
		atw_start_beacon(sc, 1);
	else
#endif
		atw_start_beacon(sc, 0);

	error = (*sc->sc_newstate)(ic, nstate, arg);

	if (ostate == IEEE80211_S_INIT && nstate == IEEE80211_S_SCAN)
		atw_write_bssid(sc);

	return error;
}

/*
 * atw_add_rxbuf:
 *
 *	Add a receive buffer to the indicated descriptor.
 */
int
atw_add_rxbuf(struct atw_softc *sc, int idx)
{
	struct atw_rxsoft *rxs = &sc->sc_rxsoft[idx];
	struct mbuf *m;
	int error;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (ENOBUFS);

	MCLGET(m, M_DONTWAIT);
	if ((m->m_flags & M_EXT) == 0) {
		m_freem(m);
		return (ENOBUFS);
	}

	if (rxs->rxs_mbuf != NULL)
		bus_dmamap_unload(sc->sc_dmat, rxs->rxs_dmamap);

	rxs->rxs_mbuf = m;

	error = bus_dmamap_load(sc->sc_dmat, rxs->rxs_dmamap,
	    m->m_ext.ext_buf, m->m_ext.ext_size, NULL,
	    BUS_DMA_READ|BUS_DMA_NOWAIT);
	if (error) {
		printf("%s: can't load rx DMA map %d, error = %d\n",
		    sc->sc_dev.dv_xname, idx, error);
		panic("atw_add_rxbuf");	/* XXX */
	}

	bus_dmamap_sync(sc->sc_dmat, rxs->rxs_dmamap, 0,
	    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);

	ATW_INIT_RXDESC(sc, idx);

	return (0);
}

/*
 * Release any queued transmit buffers.
 */
void
atw_txdrain(struct atw_softc *sc)
{
	struct atw_txsoft *txs;

	while ((txs = SIMPLEQ_FIRST(&sc->sc_txdirtyq)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_txdirtyq, txs_q);
		if (txs->txs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, txs->txs_dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
		}
		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);
	}
	sc->sc_tx_timer = 0;
}

/*
 * atw_stop:		[ ifnet interface function ]
 *
 *	Stop transmission on the interface.
 */
void
atw_stop(struct ifnet *ifp, int disable)
{
	struct atw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	/*
	 * Mark the interface down and cancel the watchdog timer.
	*/
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	/* Disable interrupts. */
	ATW_WRITE(sc, ATW_IER, 0);

	/* Stop the transmit and receive processes. */
	sc->sc_opmode = 0;
	ATW_WRITE(sc, ATW_NAR, 0);
	DELAY(20 * 1000);
	ATW_WRITE(sc, ATW_TDBD, 0);
	ATW_WRITE(sc, ATW_TDBP, 0);
	ATW_WRITE(sc, ATW_RDB, 0);

	atw_txdrain(sc);

	if (disable) {
		atw_rxdrain(sc);
		atw_disable(sc);
	}

	if (!disable)
		atw_reset(sc);
}

/*
 * atw_rxdrain:
 *
 *	Drain the receive queue.
 */
void
atw_rxdrain(struct atw_softc *sc)
{
	struct atw_rxsoft *rxs;
	int i;

	for (i = 0; i < ATW_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf == NULL)
			continue;
		bus_dmamap_unload(sc->sc_dmat, rxs->rxs_dmamap);
		m_freem(rxs->rxs_mbuf);
		rxs->rxs_mbuf = NULL;
	}
}

/*
 * atw_detach:
 *
 *	Detach an ADM8211 interface.
 */
int
atw_detach(struct atw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct atw_rxsoft *rxs;
	struct atw_txsoft *txs;
	int i;

	/*
	 * Succeed now if there isn't any work to do.
	 */
	if ((sc->sc_flags & ATWF_ATTACHED) == 0)
		return (0);

	timeout_del(&sc->sc_scan_to);

	ieee80211_ifdetach(ifp);
	if_detach(ifp);

	for (i = 0; i < ATW_NRXDESC; i++) {
		rxs = &sc->sc_rxsoft[i];
		if (rxs->rxs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, rxs->rxs_dmamap);
			m_freem(rxs->rxs_mbuf);
			rxs->rxs_mbuf = NULL;
		}
		bus_dmamap_destroy(sc->sc_dmat, rxs->rxs_dmamap);
	}
	for (i = 0; i < ATW_TXQUEUELEN; i++) {
		txs = &sc->sc_txsoft[i];
		if (txs->txs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, txs->txs_dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
		}
		bus_dmamap_destroy(sc->sc_dmat, txs->txs_dmamap);
	}
	bus_dmamap_unload(sc->sc_dmat, sc->sc_cddmamap);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_cddmamap);
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_control_data,
	    sizeof(struct atw_control_data));
	bus_dmamem_free(sc->sc_dmat, &sc->sc_cdseg, sc->sc_cdnseg);

	if (sc->sc_srom)
		free(sc->sc_srom, M_DEVBUF, sc->sc_sromsz);

	return (0);
}

int
atw_intr(void *arg)
{
	struct atw_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	u_int32_t status, rxstatus, txstatus, linkstatus;
	int handled = 0, txthresh;

#ifdef DEBUG
	if (ATW_IS_ENABLED(sc) == 0)
		panic("%s: atw_intr: not enabled", sc->sc_dev.dv_xname);
#endif

	/*
	 * If the interface isn't running, the interrupt couldn't
	 * possibly have come from us.
	 */
	if ((ifp->if_flags & IFF_RUNNING) == 0 ||
	    (sc->sc_dev.dv_flags & DVF_ACTIVE) == 0)
		return (0);

	for (;;) {
		status = ATW_READ(sc, ATW_STSR);

		if (status)
			ATW_WRITE(sc, ATW_STSR, status);

#ifdef ATW_DEBUG
#define PRINTINTR(flag) do { \
	if ((status & flag) != 0) { \
		printf("%s" #flag, delim); \
		delim = ","; \
	} \
} while (0)

		if (atw_debug > 1 && status) {
			const char *delim = "<";

			printf("%s: reg[STSR] = %x",
			    sc->sc_dev.dv_xname, status);

			PRINTINTR(ATW_INTR_FBE);
			PRINTINTR(ATW_INTR_LINKOFF);
			PRINTINTR(ATW_INTR_LINKON);
			PRINTINTR(ATW_INTR_RCI);
			PRINTINTR(ATW_INTR_RDU);
			PRINTINTR(ATW_INTR_REIS);
			PRINTINTR(ATW_INTR_RPS);
			PRINTINTR(ATW_INTR_TCI);
			PRINTINTR(ATW_INTR_TDU);
			PRINTINTR(ATW_INTR_TLT);
			PRINTINTR(ATW_INTR_TPS);
			PRINTINTR(ATW_INTR_TRT);
			PRINTINTR(ATW_INTR_TUF);
			PRINTINTR(ATW_INTR_BCNTC);
			PRINTINTR(ATW_INTR_ATIME);
			PRINTINTR(ATW_INTR_TBTT);
			PRINTINTR(ATW_INTR_TSCZ);
			PRINTINTR(ATW_INTR_TSFTF);
			printf(">\n");
		}
#undef PRINTINTR
#endif /* ATW_DEBUG */

		if ((status & sc->sc_inten) == 0)
			break;

		handled = 1;

		rxstatus = status & sc->sc_rxint_mask;
		txstatus = status & sc->sc_txint_mask;
		linkstatus = status & sc->sc_linkint_mask;

		if (linkstatus) {
			atw_linkintr(sc, linkstatus);
		}

		if (rxstatus) {
			/* Grab any new packets. */
			atw_rxintr(sc);

			if (rxstatus & ATW_INTR_RDU) {
				printf("%s: receive ring overrun\n",
				    sc->sc_dev.dv_xname);
				/* Get the receive process going again. */
				ATW_WRITE(sc, ATW_RDR, 0x1);
				break;
			}
		}

		if (txstatus) {
			/* Sweep up transmit descriptors. */
			atw_txintr(sc);

			if (txstatus & ATW_INTR_TLT)
				DPRINTF(sc, ("%s: tx lifetime exceeded\n",
				    sc->sc_dev.dv_xname));

			if (txstatus & ATW_INTR_TRT)
				DPRINTF(sc, ("%s: tx retry limit exceeded\n",
				    sc->sc_dev.dv_xname));

			/* If Tx under-run, increase our transmit threshold
			 * if another is available.
			 */
			txthresh = sc->sc_txthresh + 1;
			if ((txstatus & ATW_INTR_TUF) &&
			    sc->sc_txth[txthresh].txth_name != NULL) {
				/* Idle the transmit process. */
				atw_idle(sc, ATW_NAR_ST);

				sc->sc_txthresh = txthresh;
				sc->sc_opmode &= ~(ATW_NAR_TR_MASK|ATW_NAR_SF);
				sc->sc_opmode |=
				    sc->sc_txth[txthresh].txth_opmode;
				printf("%s: transmit underrun; new "
				    "threshold: %s\n", sc->sc_dev.dv_xname,
				    sc->sc_txth[txthresh].txth_name);

				/* Set the new threshold and restart
				 * the transmit process.
				 */
				ATW_WRITE(sc, ATW_NAR, sc->sc_opmode);
				DELAY(20 * 1000);
				ATW_WRITE(sc, ATW_RDR, 0x1);
				/* XXX Log every Nth underrun from
				 * XXX now on?
				 */
			}
		}

		if (status & (ATW_INTR_TPS|ATW_INTR_RPS)) {
			if (status & ATW_INTR_TPS)
				printf("%s: transmit process stopped\n",
				    sc->sc_dev.dv_xname);
			if (status & ATW_INTR_RPS)
				printf("%s: receive process stopped\n",
				    sc->sc_dev.dv_xname);
			(void)atw_init(ifp);
			break;
		}

		if (status & ATW_INTR_FBE) {
			printf("%s: fatal bus error\n", sc->sc_dev.dv_xname);
			(void)atw_init(ifp);
			break;
		}

		/*
		 * Not handled:
		 *
		 *	Transmit buffer unavailable -- normal
		 *	condition, nothing to do, really.
		 *
		 *	Early receive interrupt -- not available on
		 *	all chips, we just use RI.  We also only
		 *	use single-segment receive DMA, so this
		 *	is mostly useless.
		 *
		 *      TBD others
		 */
	}

	/* Try to get more packets going. */
	atw_start(ifp);

	return (handled);
}

/*
 * atw_idle:
 *
 *	Cause the transmit and/or receive processes to go idle.
 *
 *      XXX It seems that the ADM8211 will not signal the end of the Rx/Tx
 *	process in STSR if I clear SR or ST after the process has already
 *	ceased. Fair enough. But the Rx process status bits in ATW_TEST0
 *      do not seem to be too reliable. Perhaps I have the sense of the
 *	Rx bits switched with the Tx bits?
 */
void
atw_idle(struct atw_softc *sc, u_int32_t bits)
{
	u_int32_t ackmask = 0, opmode, stsr, test0;
	int i, s;

	s = splnet();

	opmode = sc->sc_opmode & ~bits;

	if (bits & ATW_NAR_SR)
		ackmask |= ATW_INTR_RPS;

	if (bits & ATW_NAR_ST) {
		ackmask |= ATW_INTR_TPS;
		/* set ATW_NAR_HF to flush TX FIFO. */
		opmode |= ATW_NAR_HF;
	}

	ATW_WRITE(sc, ATW_NAR, opmode);
	DELAY(20 * 1000);

	for (i = 0; i < 10; i++) {
		stsr = ATW_READ(sc, ATW_STSR);
		if ((stsr & ackmask) == ackmask)
			break;
		DELAY(1000);
	}

	ATW_WRITE(sc, ATW_STSR, stsr & ackmask);

	if ((stsr & ackmask) == ackmask)
		goto out;

	test0 = ATW_READ(sc, ATW_TEST0);

	if ((bits & ATW_NAR_ST) != 0 && (stsr & ATW_INTR_TPS) == 0 &&
	    (test0 & ATW_TEST0_TS_MASK) != ATW_TEST0_TS_STOPPED) {
		DPRINTF2(sc, ("%s: transmit process not idle [%s]\n",
		    sc->sc_dev.dv_xname,
		    atw_tx_state[MASK_AND_RSHIFT(test0, ATW_TEST0_TS_MASK)]));
		DPRINTF2(sc, ("%s: bits %08x test0 %08x stsr %08x\n",
		    sc->sc_dev.dv_xname, bits, test0, stsr));
	}

	if ((bits & ATW_NAR_SR) != 0 && (stsr & ATW_INTR_RPS) == 0 &&
	    (test0 & ATW_TEST0_RS_MASK) != ATW_TEST0_RS_STOPPED) {
		DPRINTF2(sc, ("%s: receive process not idle [%s]\n",
		    sc->sc_dev.dv_xname,
		    atw_rx_state[MASK_AND_RSHIFT(test0, ATW_TEST0_RS_MASK)]));
		DPRINTF2(sc, ("%s: bits %08x test0 %08x stsr %08x\n",
		    sc->sc_dev.dv_xname, bits, test0, stsr));
	}
out:
	if ((bits & ATW_NAR_ST) != 0)
		atw_txdrain(sc);
	splx(s);
	return;
}

/*
 * atw_linkintr:
 *
 *	Helper; handle link-status interrupts.
 */
void
atw_linkintr(struct atw_softc *sc, u_int32_t linkstatus)
{
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_state != IEEE80211_S_RUN)
		return;

	if (linkstatus & ATW_INTR_LINKON) {
		DPRINTF(sc, ("%s: link on\n", sc->sc_dev.dv_xname));
		sc->sc_rescan_timer = 0;
	} else if (linkstatus & ATW_INTR_LINKOFF) {
		DPRINTF(sc, ("%s: link off\n", sc->sc_dev.dv_xname));
		if (ic->ic_opmode != IEEE80211_M_STA)
			return;
		sc->sc_rescan_timer = 3;
		ic->ic_if.if_timer = 1;
	}
}

#if 0
static __inline int
atw_hw_decrypted(struct atw_softc *sc, struct ieee80211_frame *wh)
{
	if ((sc->sc_ic.ic_flags & IEEE80211_F_WEPON) == 0)
		return 0;
	if ((wh->i_fc[1] & IEEE80211_FC1_WEP) == 0)
		return 0;
	return (sc->sc_wepctl & ATW_WEPCTL_WEPRXBYP) == 0;
}
#endif

/*
 * atw_rxintr:
 *
 *	Helper; handle receive interrupts.
 */
void
atw_rxintr(struct atw_softc *sc)
{
	static int rate_tbl[] = {2, 4, 11, 22, 44};
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct ieee80211_frame *wh;
	struct ifnet *ifp = &ic->ic_if;
	struct atw_rxsoft *rxs;
	struct mbuf *m;
	u_int32_t rxstat;
	int i, len, rate, rate0;
	u_int32_t rssi, rssi0;

	for (i = sc->sc_rxptr;; i = ATW_NEXTRX(i)) {
		rxs = &sc->sc_rxsoft[i];

		ATW_CDRXSYNC(sc, i, BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

		rxstat = letoh32(sc->sc_rxdescs[i].ar_stat);
		rssi0 = letoh32(sc->sc_rxdescs[i].ar_rssi);
		rate0 = MASK_AND_RSHIFT(rxstat, ATW_RXSTAT_RXDR_MASK);

		if (rxstat & ATW_RXSTAT_OWN)
			break; /* We have processed all receive buffers. */

		DPRINTF3(sc,
		    ("%s: rx stat %08x rssi0 %08x buf1 %08x buf2 %08x\n",
		    sc->sc_dev.dv_xname,
		    rxstat, rssi0,
		    letoh32(sc->sc_rxdescs[i].ar_buf1),
		    letoh32(sc->sc_rxdescs[i].ar_buf2)));

		/*
		 * Make sure the packet fits in one buffer.  This should
		 * always be the case.
		 */
		if ((rxstat & (ATW_RXSTAT_FS|ATW_RXSTAT_LS)) !=
		    (ATW_RXSTAT_FS|ATW_RXSTAT_LS)) {
			printf("%s: incoming packet spilled, resetting\n",
			    sc->sc_dev.dv_xname);
			(void)atw_init(ifp);
			return;
		}

		/*
		 * If an error occurred, update stats, clear the status
		 * word, and leave the packet buffer in place.  It will
		 * simply be reused the next time the ring comes around.
	 	 * If 802.1Q VLAN MTU is enabled, ignore the Frame Too Long
		 * error.
		 */

		if ((rxstat & ATW_RXSTAT_ES) != 0 &&
		    ((sc->sc_ic.ic_if.if_capabilities & IFCAP_VLAN_MTU) == 0 ||
		     (rxstat & (ATW_RXSTAT_DE | ATW_RXSTAT_SFDE |
		                ATW_RXSTAT_SIGE | ATW_RXSTAT_CRC16E |
				ATW_RXSTAT_RXTOE | ATW_RXSTAT_CRC32E |
				ATW_RXSTAT_ICVE)) != 0)) {
#define	PRINTERR(bit, str)						\
			if (rxstat & (bit))				\
				printf("%s: receive error: %s\n",	\
				    sc->sc_dev.dv_xname, str)
			ifp->if_ierrors++;
			PRINTERR(ATW_RXSTAT_DE, "descriptor error");
			PRINTERR(ATW_RXSTAT_SFDE, "PLCP SFD error");
			PRINTERR(ATW_RXSTAT_SIGE, "PLCP signal error");
			PRINTERR(ATW_RXSTAT_CRC16E, "PLCP CRC16 error");
			PRINTERR(ATW_RXSTAT_RXTOE, "time-out");
			PRINTERR(ATW_RXSTAT_CRC32E, "FCS error");
			PRINTERR(ATW_RXSTAT_ICVE, "WEP ICV error");
#undef PRINTERR
			ATW_INIT_RXDESC(sc, i);
			continue;
		}

		bus_dmamap_sync(sc->sc_dmat, rxs->rxs_dmamap, 0,
		    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_POSTREAD);

		/*
		 * No errors; receive the packet.  Note the ADM8211
		 * includes the CRC in promiscuous mode.
		 */
		len = MASK_AND_RSHIFT(rxstat, ATW_RXSTAT_FL_MASK);

		/*
		 * Allocate a new mbuf cluster.  If that fails, we are
		 * out of memory, and must drop the packet and recycle
		 * the buffer that's already attached to this descriptor.
		 */
		m = rxs->rxs_mbuf;
		if (atw_add_rxbuf(sc, i) != 0) {
			ifp->if_ierrors++;
			ATW_INIT_RXDESC(sc, i);
			bus_dmamap_sync(sc->sc_dmat, rxs->rxs_dmamap, 0,
			    rxs->rxs_dmamap->dm_mapsize, BUS_DMASYNC_PREREAD);
			continue;
		}

		if (sc->sc_opmode & ATW_NAR_PR)
			len -= IEEE80211_CRC_LEN;
		m->m_pkthdr.len = m->m_len = MIN(m->m_ext.ext_size, len);

		if (rate0 >= sizeof(rate_tbl) / sizeof(rate_tbl[0]))
			rate = 0;
		else
			rate = rate_tbl[rate0];

		/* The RSSI comes straight from a register in the
		 * baseband processor.  I know that for the RF3000,
		 * the RSSI register also contains the antenna-selection
		 * bits.  Mask those off.
		 *
		 * TBD Treat other basebands.
		 */
		if (sc->sc_bbptype == ATW_BBPTYPE_RFMD)
			rssi = rssi0 & RF3000_RSSI_MASK;
		else
			rssi = rssi0;

#if NBPFILTER > 0
		/* Pass this up to any BPF listeners. */
		if (sc->sc_radiobpf != NULL) {
			struct mbuf mb;

			struct atw_rx_radiotap_header *tap = &sc->sc_rxtap;

			tap->ar_rate = rate;
			tap->ar_chan_freq = ic->ic_bss->ni_chan->ic_freq;
			tap->ar_chan_flags = ic->ic_bss->ni_chan->ic_flags;

			/* TBD verify units are dB */
			tap->ar_antsignal = (int)rssi;
			/* TBD tap->ar_flags */

			mb.m_data = (caddr_t)tap;
			mb.m_len = tap->ar_ihdr.it_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_IN);
 		}
#endif /* NBPFILTER > 0 */

		wh = mtod(m, struct ieee80211_frame *);
		ni = ieee80211_find_rxnode(ic, wh);
		rxi.rxi_flags = 0;
#if 0
		if (atw_hw_decrypted(sc, wh)) {
			wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
			rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
		}
#endif
		rxi.rxi_rssi = (int)rssi;
		rxi.rxi_tstamp = 0;
		ieee80211_input(ifp, m, ni, &rxi);
		/*
		 * The frame may have caused the node to be marked for
		 * reclamation (e.g. in response to a DEAUTH message)
		 * so use release_node here instead of unref_node.
		 */
		ieee80211_release_node(ic, ni);
	}

	/* Update the receive pointer. */
	sc->sc_rxptr = i;
}

/*
 * atw_txintr:
 *
 *	Helper; handle transmit interrupts.
 */
void
atw_txintr(struct atw_softc *sc)
{
#define TXSTAT_ERRMASK (ATW_TXSTAT_TUF | ATW_TXSTAT_TLT | ATW_TXSTAT_TRT | \
    ATW_TXSTAT_TRO | ATW_TXSTAT_SOFBR)
#define TXSTAT_FMT "\20\31ATW_TXSTAT_SOFBR\32ATW_TXSTAT_TRO\33ATW_TXSTAT_TUF" \
    "\34ATW_TXSTAT_TRT\35ATW_TXSTAT_TLT"
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct atw_txsoft *txs;
	u_int32_t txstat;

	DPRINTF3(sc, ("%s: atw_txintr: sc_flags 0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_flags));

	ifq_clr_oactive(&ifp->if_snd);

	/*
	 * Go through our Tx list and free mbufs for those
	 * frames that have been transmitted.
	 */
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txdirtyq)) != NULL) {
		ATW_CDTXSYNC(sc, txs->txs_lastdesc, 1,
		    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);

#ifdef ATW_DEBUG
		if ((ifp->if_flags & IFF_DEBUG) != 0 && atw_debug > 2) {
			int i;
			printf("    txsoft %p transmit chain:\n", txs);
			ATW_CDTXSYNC(sc, txs->txs_firstdesc,
			    txs->txs_ndescs - 1,
			    BUS_DMASYNC_POSTREAD|BUS_DMASYNC_POSTWRITE);
			for (i = txs->txs_firstdesc;; i = ATW_NEXTTX(i)) {
				printf("     descriptor %d:\n", i);
				printf("       at_status:   0x%08x\n",
				    letoh32(sc->sc_txdescs[i].at_stat));
				printf("       at_flags:      0x%08x\n",
				    letoh32(sc->sc_txdescs[i].at_flags));
				printf("       at_buf1: 0x%08x\n",
				    letoh32(sc->sc_txdescs[i].at_buf1));
				printf("       at_buf2: 0x%08x\n",
				    letoh32(sc->sc_txdescs[i].at_buf2));
				if (i == txs->txs_lastdesc)
					break;
			}
		}
#endif

		txstat = letoh32(sc->sc_txdescs[txs->txs_lastdesc].at_stat);
		if (txstat & ATW_TXSTAT_OWN)
			break;

		SIMPLEQ_REMOVE_HEAD(&sc->sc_txdirtyq, txs_q);

		sc->sc_txfree += txs->txs_ndescs;

		bus_dmamap_sync(sc->sc_dmat, txs->txs_dmamap,
		    0, txs->txs_dmamap->dm_mapsize,
		    BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, txs->txs_dmamap);
		m_freem(txs->txs_mbuf);
		txs->txs_mbuf = NULL;

		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);

		if ((ifp->if_flags & IFF_DEBUG) != 0 &&
		    (txstat & TXSTAT_ERRMASK) != 0) {
			printf("%s: txstat %b %d\n", sc->sc_dev.dv_xname,
			    txstat & TXSTAT_ERRMASK, TXSTAT_FMT,
			    MASK_AND_RSHIFT(txstat, ATW_TXSTAT_ARC_MASK));
		}

		/*
		 * Check for errors and collisions.
		 */
		if (txstat & ATW_TXSTAT_TUF)
			sc->sc_stats.ts_tx_tuf++;
		if (txstat & ATW_TXSTAT_TLT)
			sc->sc_stats.ts_tx_tlt++;
		if (txstat & ATW_TXSTAT_TRT)
			sc->sc_stats.ts_tx_trt++;
		if (txstat & ATW_TXSTAT_TRO)
			sc->sc_stats.ts_tx_tro++;
		if (txstat & ATW_TXSTAT_SOFBR) {
			sc->sc_stats.ts_tx_sofbr++;
		}

		if ((txstat & ATW_TXSTAT_ES) == 0)
			ifp->if_collisions +=
			    MASK_AND_RSHIFT(txstat, ATW_TXSTAT_ARC_MASK);
		else
			ifp->if_oerrors++;
	}

	/*
	 * If there are no more pending transmissions, cancel the watchdog
	 * timer.
	 */
	if (txs == NULL)
		sc->sc_tx_timer = 0;
#undef TXSTAT_ERRMASK
#undef TXSTAT_FMT
}

/*
 * atw_watchdog:	[ifnet interface function]
 *
 *	Watchdog timer handler.
 */
void
atw_watchdog(struct ifnet *ifp)
{
	struct atw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t test1, rra, rwa;

	ifp->if_timer = 0;
	if (ATW_IS_ENABLED(sc) == 0)
		return;

	if (sc->sc_rescan_timer) {
		if (--sc->sc_rescan_timer == 0)
			(void)ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	}
	if (sc->sc_tx_timer) {
		if (--sc->sc_tx_timer == 0 &&
		    !SIMPLEQ_EMPTY(&sc->sc_txdirtyq)) {
			printf("%s: transmit timeout\n", ifp->if_xname);
			ifp->if_oerrors++;
			(void)atw_init(ifp);
			atw_start(ifp);
		}
	}
	if (sc->sc_tx_timer != 0 || sc->sc_rescan_timer != 0)
		ifp->if_timer = 1;

	/*
	 * ADM8211B seems to stall every so often, check for this.
	 * These bits are what the Linux driver checks, they don't
	 * seem to be documented by ADMTek/Infineon?
	 */
	if (sc->sc_rev == ATW_REVISION_BA) {
		test1 = ATW_READ(sc, ATW_TEST1);
		rra = (test1 >> 12) & 0x1ff;
		rwa = (test1 >> 2) & 0x1ff;

		if ((rra != rwa) && !(test1 & 0x2)) {
			atw_init(ifp);
			atw_start(ifp);
		}
	}

	ieee80211_watchdog(ifp);
}

/*
 * Arguments in:
 *
 * paylen:  payload length (no FCS, no WEP header)
 *
 * hdrlen:  header length
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * flags:   IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d:       802.11 Duration field for RTS,
 *          802.11 Duration field for data frame,
 *          PLCP Length for data frame,
 *          residual octets at end of data slot
 */
int
atw_compute_duration1(int len, int use_ack, uint32_t flags, int rate,
    struct atw_duration *d)
{
	int pre, ctsrate;
	int ack, bitlen, data_dur, remainder;

	/* RTS reserves medium for SIFS | CTS | SIFS | (DATA) | SIFS | ACK
	 * DATA reserves medium for SIFS | ACK
	 *
	 * XXXMYC: no ACK on multicast/broadcast or control packets
	 */

	bitlen = len * 8;

	pre = IEEE80211_DUR_DS_SIFS;
	if ((flags & IEEE80211_F_SHPREAMBLE) != 0)
		pre += IEEE80211_DUR_DS_SHORT_PREAMBLE +
		    IEEE80211_DUR_DS_FAST_PLCPHDR;
	else
		pre += IEEE80211_DUR_DS_LONG_PREAMBLE +
		    IEEE80211_DUR_DS_SLOW_PLCPHDR;

	d->d_residue = 0;
	data_dur = (bitlen * 2) / rate;
	remainder = (bitlen * 2) % rate;
	if (remainder != 0) {
		d->d_residue = (rate - remainder) / 16;
		data_dur++;
	}

	switch (rate) {
	case 2:		/* 1 Mb/s */
	case 4:		/* 2 Mb/s */
		/* 1 - 2 Mb/s WLAN: send ACK/CTS at 1 Mb/s */
		ctsrate = 2;
		break;
	case 11:	/* 5.5 Mb/s */
	case 22:	/* 11  Mb/s */
	case 44:	/* 22  Mb/s */
		/* 5.5 - 11 Mb/s WLAN: send ACK/CTS at 2 Mb/s */
		ctsrate = 4;
		break;
	default:
		/* TBD */
		return -1;
	}

	d->d_plcp_len = data_dur;

	ack = (use_ack) ? pre + (IEEE80211_DUR_DS_SLOW_ACK * 2) / ctsrate : 0;

	d->d_rts_dur =
	    pre + (IEEE80211_DUR_DS_SLOW_CTS * 2) / ctsrate +
	    pre + data_dur +
	    ack;

	d->d_data_dur = ack;

	return 0;
}

/*
 * Arguments in:
 *
 * wh:      802.11 header
 *
 * len: packet length 
 *
 * rate:    MSDU speed, units 500kb/s
 *
 * fraglen: fragment length, set to maximum (or higher) for no
 *          fragmentation
 *
 * flags:   IEEE80211_F_WEPON (hardware adds WEP),
 *          IEEE80211_F_SHPREAMBLE (use short preamble),
 *          IEEE80211_F_SHSLOT (use short slot length)
 *
 * Arguments out:
 *
 * d0: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 *
 * dn: 802.11 Duration fields (RTS/Data), PLCP Length, Service fields
 *     of first/only fragment
 */
int
atw_compute_duration(struct ieee80211_frame *wh, int len, uint32_t flags,
    int fraglen, int rate, struct atw_duration *d0, struct atw_duration *dn,
    int *npktp, int debug)
{
	int ack, rc;
	int firstlen, hdrlen, lastlen, lastlen0, npkt, overlen, paylen;

	if ((wh->i_fc[1] & IEEE80211_FC1_DIR_MASK) == IEEE80211_FC1_DIR_DSTODS)
		hdrlen = sizeof(struct ieee80211_frame_addr4);
	else
		hdrlen = sizeof(struct ieee80211_frame);

	paylen = len - hdrlen;

	if ((flags & IEEE80211_F_WEPON) != 0)
		overlen = IEEE80211_WEP_TOTLEN + IEEE80211_CRC_LEN;
	else
		overlen = IEEE80211_CRC_LEN;

	npkt = paylen / fraglen;
	lastlen0 = paylen % fraglen;

	if (npkt == 0)			/* no fragments */
		lastlen = paylen + overlen;
	else if (lastlen0 != 0) {	/* a short "tail" fragment */
		lastlen = lastlen0 + overlen;
		npkt++;
	} else				/* full-length "tail" fragment */
		lastlen = fraglen + overlen;

	if (npktp != NULL)
		*npktp = npkt;

	if (npkt > 1)
		firstlen = fraglen + overlen;
	else
		firstlen = paylen + overlen;

	if (debug) {
		printf("%s: npkt %d firstlen %d lastlen0 %d lastlen %d "
		    "fraglen %d overlen %d len %d rate %d flags %08x\n",
		    __func__, npkt, firstlen, lastlen0, lastlen, fraglen,
		    overlen, len, rate, flags);
	}

	ack = !IEEE80211_IS_MULTICAST(wh->i_addr1) &&
	    (wh->i_fc[1] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_CTL;

	rc = atw_compute_duration1(firstlen + hdrlen, ack, flags, rate, d0);
	if (rc == -1)
		return rc;

	if (npkt <= 1) {
		*dn = *d0;
		return 0;
	}
	return atw_compute_duration1(lastlen + hdrlen, ack, flags, rate, dn);
}

#ifdef ATW_DEBUG
void
atw_dump_pkt(struct ifnet *ifp, struct mbuf *m0)
{
	struct atw_softc *sc = ifp->if_softc;
	struct mbuf *m;
	int i, noctets = 0;

	printf("%s: %d-byte packet\n", sc->sc_dev.dv_xname,
	    m0->m_pkthdr.len);

	for (m = m0; m; m = m->m_next) {
		if (m->m_len == 0)
			continue;
		for (i = 0; i < m->m_len; i++) {
			printf(" %02x", ((u_int8_t*)m->m_data)[i]);
			if (++noctets % 24 == 0)
				printf("\n");
		}
	}
	printf("%s%s: %d bytes emitted\n",
	    (noctets % 24 != 0) ? "\n" : "", sc->sc_dev.dv_xname, noctets);
}
#endif /* ATW_DEBUG */

/*
 * atw_start:		[ifnet interface function]
 *
 *	Start packet transmission on the interface.
 */
void
atw_start(struct ifnet *ifp)
{
	struct atw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct atw_frame *hh;
	struct mbuf *m0, *m;
	struct atw_txsoft *txs, *last_txs;
	struct atw_txdesc *txd;
	int do_encrypt, npkt, rate;
	bus_dmamap_t dmamap;
	int ctl, error, firsttx, nexttx, lasttx = -1, first, ofree, seg;

	DPRINTF2(sc, ("%s: atw_start: sc_flags 0x%08x, if_flags 0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_flags, ifp->if_flags));

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	/*
	 * Remember the previous number of free descriptors and
	 * the first descriptor we'll use.
	 */
	ofree = sc->sc_txfree;
	firsttx = sc->sc_txnext;

	DPRINTF2(sc, ("%s: atw_start: txfree %d, txnext %d\n",
	    sc->sc_dev.dv_xname, ofree, firsttx));

	/*
	 * Loop through the send queue, setting up transmit descriptors
	 * until we drain the queue, or use up all available transmit
	 * descriptors.
	 */
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txfreeq)) != NULL &&
	       sc->sc_txfree != 0) {

		/*
		 * Grab a packet off the management queue, if it
		 * is not empty. Otherwise, from the data queue.
		 */
		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
		} else {
			/* send no data packets until we are associated */
			if (ic->ic_state != IEEE80211_S_RUN)
				break;
			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif /* NBPFILTER > 0 */
			if ((m0 = ieee80211_encap(ifp, m0, &ni)) == NULL) {
				ifp->if_oerrors++;
				break;
			}

			if (ic->ic_flags & IEEE80211_F_WEPON) {
				wh = mtod(m0, struct ieee80211_frame *);
				k = ieee80211_get_txkey(ic, wh, ni);
				m0 = ieee80211_encrypt(ic, m0, k);
				if (m0 == NULL) {
					ifp->if_oerrors++;
					break;	
				}
			}
		}

		wh = mtod(m0, struct ieee80211_frame *);

		/* XXX do real rate control */
		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT)
			rate = 2;
		else
			rate = MAX(2, ieee80211_get_rate(ic));

		if (atw_compute_duration(wh, m0->m_pkthdr.len,
		    ic->ic_flags & ~IEEE80211_F_WEPON, ic->ic_fragthreshold,
		    rate, &txs->txs_d0, &txs->txs_dn, &npkt,
		    (sc->sc_if.if_flags & (IFF_DEBUG|IFF_LINK2)) ==
		    (IFF_DEBUG|IFF_LINK2)) == -1) {
			DPRINTF2(sc, ("%s: fail compute duration\n", __func__));
			m_freem(m0);
			break;
		}

		/*
		 * XXX Misleading if fragmentation is enabled.  Better
		 * to fragment in software?
		 */
		*(uint16_t *)wh->i_dur = htole16(txs->txs_d0.d_rts_dur);

#if NBPFILTER > 0
		/*
		 * Pass the packet to any BPF listeners.
		 */
		if (ic->ic_rawbpf != NULL)
			bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);

		if (sc->sc_radiobpf != NULL) {
			struct mbuf mb;
			struct atw_tx_radiotap_header *tap = &sc->sc_txtap;

			tap->at_rate = rate;
			tap->at_chan_freq = ic->ic_bss->ni_chan->ic_freq;
			tap->at_chan_flags = ic->ic_bss->ni_chan->ic_flags;

			/* TBD tap->at_flags */

			mb.m_data = (caddr_t)tap;
			mb.m_len = tap->at_ihdr.it_len;
			mb.m_next = m0;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_OUT);
		}
#endif /* NBPFILTER > 0 */

		M_PREPEND(m0, offsetof(struct atw_frame, atw_ihdr), M_DONTWAIT);

		if (ni != NULL)
			ieee80211_release_node(ic, ni);

		if (m0 == NULL) {
			ifp->if_oerrors++;
			break;
		}

		/* just to make sure. */
		m0 = m_pullup(m0, sizeof(struct atw_frame));

		if (m0 == NULL) {
			ifp->if_oerrors++;
			break;
		}

		hh = mtod(m0, struct atw_frame *);
		wh = &hh->atw_ihdr;

		do_encrypt = ((wh->i_fc[1] & IEEE80211_FC1_WEP) != 0) ? 1 : 0;

		/* Copy everything we need from the 802.11 header:
		 * Frame Control; address 1, address 3, or addresses
		 * 3 and 4. NIC fills in BSSID, SA.
		 */
		if (wh->i_fc[1] & IEEE80211_FC1_DIR_TODS) {
			if (wh->i_fc[1] & IEEE80211_FC1_DIR_FROMDS)
				panic("%s: illegal WDS frame",
				    sc->sc_dev.dv_xname);
			memcpy(hh->atw_dst, wh->i_addr3, IEEE80211_ADDR_LEN);
		} else
			memcpy(hh->atw_dst, wh->i_addr1, IEEE80211_ADDR_LEN);

		*(u_int16_t*)hh->atw_fc = *(u_int16_t*)wh->i_fc;

		/* initialize remaining Tx parameters */
		memset(&hh->u, 0, sizeof(hh->u));

		hh->atw_rate = rate * 5;
		/* XXX this could be incorrect if M_FCS. _encap should
		 * probably strip FCS just in case it sticks around in
		 * bridged packets.
		 */
		hh->atw_service = IEEE80211_PLCP_SERVICE; /* XXX guess */
		hh->atw_paylen = htole16(m0->m_pkthdr.len -
		    sizeof(struct atw_frame));

		hh->atw_fragthr = htole16(ATW_FRAGTHR_FRAGTHR_MASK);
		hh->atw_rtylmt = 3;
		hh->atw_hdrctl = htole16(ATW_HDRCTL_UNKNOWN1);
#if 0
		if (do_encrypt) {
			hh->atw_hdrctl |= htole16(ATW_HDRCTL_WEP);
			hh->atw_keyid = ic->ic_wep_txkey;
		}
#endif

		hh->atw_head_plcplen = htole16(txs->txs_d0.d_plcp_len);
		hh->atw_tail_plcplen = htole16(txs->txs_dn.d_plcp_len);
		if (txs->txs_d0.d_residue)
			hh->atw_head_plcplen |= htole16(0x8000);
		if (txs->txs_dn.d_residue)
			hh->atw_tail_plcplen |= htole16(0x8000);
		hh->atw_head_dur = htole16(txs->txs_d0.d_rts_dur);
		hh->atw_tail_dur = htole16(txs->txs_dn.d_rts_dur);

		/* never fragment multicast frames */
		if (IEEE80211_IS_MULTICAST(hh->atw_dst)) {
			hh->atw_fragthr = htole16(ATW_FRAGTHR_FRAGTHR_MASK);
		} else if (sc->sc_flags & ATWF_RTSCTS) {
			hh->atw_hdrctl |= htole16(ATW_HDRCTL_RTSCTS);
		}

#ifdef ATW_DEBUG
		hh->atw_fragnum = 0;

		if ((ifp->if_flags & IFF_DEBUG) != 0 && atw_debug > 2) {
			printf("%s: dst = %s, rate = 0x%02x, "
			    "service = 0x%02x, paylen = 0x%04x\n",
			    sc->sc_dev.dv_xname, ether_sprintf(hh->atw_dst),
			    hh->atw_rate, hh->atw_service, hh->atw_paylen);

			printf("%s: fc[0] = 0x%02x, fc[1] = 0x%02x, "
			    "dur1 = 0x%04x, dur2 = 0x%04x, "
			    "dur3 = 0x%04x, rts_dur = 0x%04x\n",
			    sc->sc_dev.dv_xname, hh->atw_fc[0], hh->atw_fc[1],
			    hh->atw_tail_plcplen, hh->atw_head_plcplen,
			    hh->atw_tail_dur, hh->atw_head_dur);

			printf("%s: hdrctl = 0x%04x, fragthr = 0x%04x, "
			    "fragnum = 0x%02x, rtylmt = 0x%04x\n",
			    sc->sc_dev.dv_xname, hh->atw_hdrctl,
			    hh->atw_fragthr, hh->atw_fragnum, hh->atw_rtylmt);

			printf("%s: keyid = %d\n",
			    sc->sc_dev.dv_xname, hh->atw_keyid);

			atw_dump_pkt(ifp, m0);
		}
#endif /* ATW_DEBUG */

		dmamap = txs->txs_dmamap;

		/*
		 * Load the DMA map.  Copy and try (once) again if the packet
		 * didn't fit in the alloted number of segments.
		 */
		for (first = 1;
		     (error = bus_dmamap_load_mbuf(sc->sc_dmat, dmamap, m0,
		                  BUS_DMA_WRITE|BUS_DMA_NOWAIT)) != 0 && first;
		     first = 0) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				printf("%s: unable to allocate Tx mbuf\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			if (m0->m_pkthdr.len > MHLEN) {
				MCLGET(m, M_DONTWAIT);
				if ((m->m_flags & M_EXT) == 0) {
					printf("%s: unable to allocate Tx "
					    "cluster\n", sc->sc_dev.dv_xname);
					m_freem(m);
					break;
				}
			}
			m_copydata(m0, 0, m0->m_pkthdr.len, mtod(m, caddr_t));
			m->m_pkthdr.len = m->m_len = m0->m_pkthdr.len;
			m_freem(m0);
			m0 = m;
			m = NULL;
		}
		if (error != 0) {
			printf("%s: unable to load Tx buffer, "
			    "error = %d\n", sc->sc_dev.dv_xname, error);
			m_freem(m0);
			break;
		}

		/*
		 * Ensure we have enough descriptors free to describe
		 * the packet.
		 */
		if (dmamap->dm_nsegs > sc->sc_txfree) {
			/*
			 * Not enough free descriptors to transmit
			 * this packet.  Unload the DMA map and
			 * drop the packet.  Notify the upper layer
			 * that there are no more slots left.
			 *
			 * XXX We could allocate an mbuf and copy, but
			 * XXX it is worth it?
			 */
			ifq_set_oactive(&ifp->if_snd);
			bus_dmamap_unload(sc->sc_dmat, dmamap);
			m_freem(m0);
			break;
		}

		/*
		 * WE ARE NOW COMMITTED TO TRANSMITTING THE PACKET.
		 */

		/* Sync the DMA map. */
		bus_dmamap_sync(sc->sc_dmat, dmamap, 0, dmamap->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);

		/* XXX arbitrary retry limit; 8 because I have seen it in
		 * use already and maybe 0 means "no tries" !
		 */
		ctl = htole32(LSHIFT(8, ATW_TXCTL_TL_MASK));

		DPRINTF2(sc, ("%s: TXDR <- max(10, %d)\n",
		    sc->sc_dev.dv_xname, rate * 5));
		ctl |= htole32(LSHIFT(MAX(10, rate * 5), ATW_TXCTL_TXDR_MASK));

		/*
		 * Initialize the transmit descriptors.
		 */
		for (nexttx = sc->sc_txnext, seg = 0;
		     seg < dmamap->dm_nsegs;
		     seg++, nexttx = ATW_NEXTTX(nexttx)) {
			/*
			 * If this is the first descriptor we're
			 * enqueueing, don't set the OWN bit just
			 * yet.  That could cause a race condition.
			 * We'll do it below.
			 */
			txd = &sc->sc_txdescs[nexttx];
			txd->at_ctl = ctl |
			    ((nexttx == firsttx) ? 0 : htole32(ATW_TXCTL_OWN));

			txd->at_buf1 = htole32(dmamap->dm_segs[seg].ds_addr);
			txd->at_flags =
			    htole32(LSHIFT(dmamap->dm_segs[seg].ds_len,
			                   ATW_TXFLAG_TBS1_MASK)) |
			    ((nexttx == (ATW_NTXDESC - 1))
			        ? htole32(ATW_TXFLAG_TER) : 0);
			lasttx = nexttx;
		}

		if (lasttx == -1)
			panic("%s: bad lastx", ifp->if_xname);
		/* Set `first segment' and `last segment' appropriately. */
		sc->sc_txdescs[sc->sc_txnext].at_flags |=
		    htole32(ATW_TXFLAG_FS);
		sc->sc_txdescs[lasttx].at_flags |= htole32(ATW_TXFLAG_LS);

#ifdef ATW_DEBUG
		if ((ifp->if_flags & IFF_DEBUG) != 0 && atw_debug > 2) {
			printf("     txsoft %p transmit chain:\n", txs);
			for (seg = sc->sc_txnext;; seg = ATW_NEXTTX(seg)) {
				printf("     descriptor %d:\n", seg);
				printf("       at_ctl:   0x%08x\n",
				    letoh32(sc->sc_txdescs[seg].at_ctl));
				printf("       at_flags:      0x%08x\n",
				    letoh32(sc->sc_txdescs[seg].at_flags));
				printf("       at_buf1: 0x%08x\n",
				    letoh32(sc->sc_txdescs[seg].at_buf1));
				printf("       at_buf2: 0x%08x\n",
				    letoh32(sc->sc_txdescs[seg].at_buf2));
				if (seg == lasttx)
					break;
			}
		}
#endif

		/* Sync the descriptors we're using. */
		ATW_CDTXSYNC(sc, sc->sc_txnext, dmamap->dm_nsegs,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/*
		 * Store a pointer to the packet so we can free it later,
		 * and remember what txdirty will be once the packet is
		 * done.
		 */
		txs->txs_mbuf = m0;
		txs->txs_firstdesc = sc->sc_txnext;
		txs->txs_lastdesc = lasttx;
		txs->txs_ndescs = dmamap->dm_nsegs;

		/* Advance the tx pointer. */
		sc->sc_txfree -= dmamap->dm_nsegs;
		sc->sc_txnext = nexttx;

		SIMPLEQ_REMOVE_HEAD(&sc->sc_txfreeq, txs_q);
		SIMPLEQ_INSERT_TAIL(&sc->sc_txdirtyq, txs, txs_q);

		last_txs = txs;
	}

	if (txs == NULL || sc->sc_txfree == 0) {
		/* No more slots left; notify upper layer. */
		ifq_set_oactive(&ifp->if_snd);
	}

	if (sc->sc_txfree != ofree) {
		DPRINTF2(sc, ("%s: packets enqueued, IC on %d, OWN on %d\n",
		    sc->sc_dev.dv_xname, lasttx, firsttx));
		/*
		 * Cause a transmit interrupt to happen on the
		 * last packet we enqueued.
		 */
		sc->sc_txdescs[lasttx].at_flags |= htole32(ATW_TXFLAG_IC);
		ATW_CDTXSYNC(sc, lasttx, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/*
		 * The entire packet chain is set up.  Give the
		 * first descriptor to the chip now.
		 */
		sc->sc_txdescs[firsttx].at_ctl |= htole32(ATW_TXCTL_OWN);
		ATW_CDTXSYNC(sc, firsttx, 1,
		    BUS_DMASYNC_PREREAD|BUS_DMASYNC_PREWRITE);

		/* Wake up the transmitter. */
		ATW_WRITE(sc, ATW_TDR, 0x1);

		/* Set a watchdog timer in case the chip flakes out. */
		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

int
atw_activate(struct device *self, int act)
{
	struct atw_softc *sc = (struct atw_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			atw_stop(ifp, 1);
		if (sc->sc_power != NULL)
			(*sc->sc_power)(sc, act);
		break;
	case DVACT_WAKEUP:
		atw_wakeup(sc);
		break;
	}
	return 0;
}

void
atw_wakeup(struct atw_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (sc->sc_power != NULL)
		(*sc->sc_power)(sc, DVACT_RESUME);
	if (ifp->if_flags & IFF_UP)
		atw_init(ifp);
}

/*
 * atw_ioctl:		[ifnet interface function]
 *
 *	Handle control requests from the operator.
 */
int
atw_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct atw_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	/* XXX monkey see, monkey do. comes from wi_ioctl. */
	if ((sc->sc_dev.dv_flags & DVF_ACTIVE) == 0)
		return ENXIO;

	s = splnet();

	switch (cmd) {
        case SIOCSIFADDR:
                ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ATW_IS_ENABLED(sc)) {
				/*
				 * To avoid rescanning another access point,
				 * do not call atw_init() here.  Instead,
				 * only reflect media settings.
				 */
				atw_filter_setup(sc);
			} else
				error = atw_init(ifp);
		} else if (ATW_IS_ENABLED(sc))
			atw_stop(ifp, 1);
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ic.ic_ac) :
		    ether_delmulti(ifr, &sc->sc_ic.ic_ac);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				atw_filter_setup(sc); /* do not rescan */
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET) {
			if (ATW_IS_ENABLED(sc))
				error = atw_init(ifp);
			else
				error = 0;
		}
		break;
	}

	/* Try to get more packets going. */
	if (ATW_IS_ENABLED(sc))
		atw_start(ifp);

	splx(s);
	return (error);
}

int
atw_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
		    (IFF_RUNNING|IFF_UP))
			atw_init(ifp);		/* XXX lose error */
		error = 0;
	}
	return error;
}

void
atw_media_status(struct ifnet *ifp, struct ifmediareq *imr)
{
	struct atw_softc *sc = ifp->if_softc;

	if (ATW_IS_ENABLED(sc) == 0) {
		imr->ifm_active = IFM_IEEE80211 | IFM_NONE;
		imr->ifm_status = 0;
		return;
	}
	ieee80211_media_status(ifp, imr);
}
@


1.94
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.93 2016/03/15 20:50:22 krw Exp $	*/
a3294 2

		ifp->if_opackets++;
@


1.93
log
@'accomodate' -> 'accommodate' in comments.

Started by diff from Mical Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.92 2015/12/08 13:34:22 tedu Exp $	*/
a792 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.92
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.91 2015/11/25 03:09:58 dlg Exp $	*/
d1115 1
a1115 1
	 * possible for the ADM8211 to accomodate bus speeds between 22MHz
@


1.91
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.90 2015/11/04 12:11:59 dlg Exp $	*/
d789 1
a789 2
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST |
	    IFF_NOTRAILERS;
@


1.90
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.89 2015/10/25 12:48:46 mpi Exp $	*/
d1436 1
a1436 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1447 2
a1448 1
		ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d2648 2
a2649 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d3220 1
a3220 1
	ifp->if_flags &= ~IFF_OACTIVE;
d3576 1
a3576 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
d3838 1
a3838 1
			ifp->if_flags |= IFF_OACTIVE;
d3938 1
a3938 1
		ifp->if_flags |= IFF_OACTIVE;
@


1.89
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.88 2015/09/06 04:10:58 deraadt Exp $	*/
d3599 1
a3599 1
		IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.88
log
@srom size is tracked, pass to free()
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.87 2015/03/14 03:38:47 jsg Exp $	*/
a4006 1
	struct ieee80211com *ic = &sc->sc_ic;
a4007 1
   	struct ifaddr *ifa = (struct ifaddr *)data;
a4018 3
                if (ifa->ifa_addr->sa_family == AF_INET) {
                        arp_ifinit(&ic->ic_ac, ifa);
                }
@


1.87
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.86 2015/02/10 23:25:46 mpi Exp $	*/
d422 1
a422 1
		free(sc->sc_srom, M_DEVBUF, 0);
d2742 1
a2742 1
		free(sc->sc_srom, M_DEVBUF, 0);
@


1.86
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.85 2014/12/22 02:28:51 tedu Exp $	*/
a51 1
#include <net/if_dl.h>
@


1.85
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.84 2014/12/19 22:44:58 guenther Exp $	*/
a3131 1
		m->m_pkthdr.rcvif = ifp;
@


1.84
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.83 2014/07/12 18:48:17 tedu Exp $	*/
a58 1
#ifdef INET
a60 1
#endif
a4022 1
#ifdef INET
a4025 1
#endif  /* INET */
@


1.83
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.82 2014/07/08 17:19:25 deraadt Exp $	*/
d49 1
a49 2

#include <machine/endian.h>
@


1.82
log
@decouple struct uvmexp into a new file, so that uvm_extern.h and sysctl.h
don't need to be married.
ok guenther miod beck jsing kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.81 2014/03/19 10:09:19 mpi Exp $	*/
d426 1
a426 1
		free(sc->sc_srom, M_DEVBUF);
d2746 1
a2746 1
		free(sc->sc_srom, M_DEVBUF);
@


1.81
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.80 2013/12/06 21:03:02 deraadt Exp $	*/
a50 2

#include <uvm/uvm_extern.h>
@


1.80
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.79 2013/12/03 22:47:28 brad Exp $	*/
d3608 1
a3608 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.79
log
@#if 0 out atw_hw_decrypted() as it is currently an unused function as the
code calling it is also #if 0'd out.

atw.c:3021:1: error: unused function 'atw_hw_decrypted' [-Werror,-Wunused-function]

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.78 2013/11/26 09:50:32 mpi Exp $	*/
a562 2
	task_set(&sc->sc_resume_t, atw_resume, sc, NULL);

d3988 2
a3989 2
	case DVACT_RESUME:
		task_add(systq, &sc->sc_resume_t);
d3996 1
a3996 1
atw_resume(void *arg1, void *arg2)
a3997 1
	struct atw_softc *sc = (struct atw_softc *)arg1;
@


1.78
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.77 2013/11/14 12:30:39 dlg Exp $	*/
d3020 1
d3030 1
@


1.77
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.76 2011/04/05 19:54:35 jasper Exp $	*/
d2033 1
a2033 1
	struct arpcom *ec = &ic->ic_ac;
d2061 3
d2067 1
a2067 1
	ETHER_FIRST_MULTI(step, ec, enm);
a2068 4
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
		    ETHER_ADDR_LEN) != 0)
			goto allmulti;

@


1.76
log
@- use nitems() no binary change on amd64

"reads OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.75 2010/11/11 17:47:00 miod Exp $	*/
d563 2
d3990 1
a3990 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    atw_resume, sc, NULL);
@


1.75
log
@Pass a few more M_ZERO to malloc() or its wrappers, when useful; ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.74 2010/09/20 00:11:37 jsg Exp $	*/
d658 1
a658 1
	if (sc->sc_rftype >= sizeof(type_strings)/sizeof(type_strings[0])) {
d662 1
a662 1
	if (sc->sc_bbptype >= sizeof(type_strings)/sizeof(type_strings[0])) {
@


1.74
log
@After the gcc4 switch the stack protector triggers in atw
when a buffer is overflowed.  Fix this and increase the
size of the rate buffer (which is still < IEEE80211_RATE_MAXSIZE
due to hardware restrictions) while here.

ok claudio@@ damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.73 2010/09/07 16:21:42 deraadt Exp $	*/
d400 1
a400 1
	sc->sc_srom = malloc(sc->sc_sromsz, M_DEVBUF, M_NOWAIT);
d407 2
a408 2
	(void)memset(sc->sc_srom, 0, sc->sc_sromsz);
	/* ADM8211 has a single 32-bit register for controlling the
@


1.73
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.72 2010/09/06 19:20:21 deraadt Exp $	*/
d2295 3
a2297 2
	/* 14 bytes are probably (XXX) reserved in the ADM8211 SRAM for
	 * supported rates
d2299 2
a2300 1
	u_int8_t buf[roundup(1 /* length */ + IEEE80211_RATE_SIZE, 2)];
d2303 6
a2308 3
	buf[0] = ic->ic_bss->ni_rates.rs_nrates;
	memcpy(&buf[1], ic->ic_bss->ni_rates.rs_rates,
	    ic->ic_bss->ni_rates.rs_nrates);
@


1.72
log
@All PWR_{SUSPEND,RESUME} can now be replaced by DVACT_{SUSPEND,RESUME}
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.71 2010/08/29 16:46:58 deraadt Exp $	*/
a844 9
	/*
	 * Add a suspend hook to make sure we come back up after a
	 * resume.
	 */
	sc->sc_powerhook = powerhook_establish(atw_powerhook, sc);
	if (sc->sc_powerhook == NULL)
		printf("%s: WARNING: unable to establish power hook\n",
		    sc->sc_dev.dv_xname);

a2742 3
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);

a3999 6
}

void
atw_powerhook(int why, void *arg)
{
	atw_activate(arg, why);
@


1.71
log
@Massage the powerhook functions into activate functions, and then call
them from the powerhook.  Fix a few quibbles about the things done for
the IFF_RUNNING and IFF_UP cases
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.70 2010/08/27 04:09:18 deraadt Exp $	*/
d3988 1
a3988 1
	case PWR_SUSPEND:
d3994 1
a3994 1
	case PWR_RESUME:
@


1.70
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.69 2009/08/16 18:03:48 jsg Exp $	*/
d849 1
a849 1
	sc->sc_powerhook = powerhook_establish(atw_power, sc);
d3981 2
a3982 7
/*
 * atw_power:
 *
 *	Power management (suspend/resume) hook.
 */
void
atw_power(int why, void *arg)
d3984 1
a3984 1
	struct atw_softc *sc = arg;
a3985 3
	int s;

	DPRINTF(sc, ("%s: atw_power(%d,)\n", sc->sc_dev.dv_xname, why));
d3987 1
a3987 2
	s = splnet();
	switch (why) {
d3989 2
a3990 1
		atw_stop(ifp, 1);
d3992 1
a3992 1
			(*sc->sc_power)(sc, why);
d3995 2
a3996 5
		if (ifp->if_flags & IFF_UP) {
			if (sc->sc_power != NULL)
				(*sc->sc_power)(sc, why);
			atw_init(ifp);
		}
d3999 19
a4017 1
	splx(s);
@


1.69
log
@remove use of BITS and BIT macros.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.68 2009/08/16 17:24:04 jsg Exp $	*/
a3996 3
	case PWR_STANDBY:
		/* XXX do nothing. */
		break;
@


1.68
log
@start getting rid of some of these horrific bit macros, remove
usage of BITS().  There is a binary change due to the way these
macros are further used in the MASK_AND_RSHIFT specifically
for ATW_SR_RFTYPE_MASK and ATW_SR_BBPTYPE_MASK.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.67 2009/08/10 20:29:54 deraadt Exp $	*/
d1963 1
a1963 1
	for (mask = BIT(nbits - 1); mask != 0; mask >>= 1) {
@


1.67
log
@More cases of shutdown hooks not needed after card is already stopped.  In
these cases the xxstop function is a bit more complicated and has a flag of
some sort, but the use of that flag does not matter;  DMA is already ceased
ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.66 2009/06/03 20:00:36 deraadt Exp $	*/
d2029 1
a2029 1
	(ether_crc32_le((addr), IEEE80211_ADDR_LEN) & BITS(5, 0))
@


1.66
log
@put the values direct in the array, otherwise the nested macros are longer
than standards permit
found & ok by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.65 2009/01/21 21:53:59 grange Exp $	*/
a845 8
	 * Make sure the interface is shutdown during reboot.
	 */
	sc->sc_sdhook = shutdownhook_establish(atw_shutdown, sc);
	if (sc->sc_sdhook == NULL)
		printf("%s: WARNING: unable to establish shutdown hook\n",
		    sc->sc_dev.dv_xname);

	/*
a2751 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
a2758 9
}

/* atw_shutdown: make sure the interface is stopped at reboot time. */
void
atw_shutdown(void *arg)
{
	struct atw_softc *sc = arg;

	atw_stop(&sc->sc_ic.ic_if, 1);
@


1.65
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.64 2008/11/28 02:44:17 brad Exp $	*/
d267 14
a280 2
const struct atw_txthresh_tab atw_txthresh_tab_lo[] = ATW_TXTHRESH_TAB_LO_RATE;
const struct atw_txthresh_tab atw_txthresh_tab_hi[] = ATW_TXTHRESH_TAB_HI_RATE;
@


1.64
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.63 2008/10/03 00:58:39 brad Exp $	*/
d2522 1
a2522 1
		timeout_add(&sc->sc_scan_to, atw_dwelltime * hz / 1000);
@


1.63
log
@Remove a few small ifdef/ifndef OpenBSD sections which contained some
NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.62 2008/08/29 09:30:23 damien Exp $	*/
a4043 7
        case SIOCSIFMTU:
                if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
                        error = EINVAL;
                } else if (ifp->if_mtu != ifr->ifr_mtu) {
                        ifp->if_mtu = ifr->ifr_mtu;
                }
                break;
d4052 1
d4067 1
d4080 1
@


1.62
log
@the atw(4) man page says:

   "The driver lets you change to Host AP mode, but it does not work
    and it probably never will."

so just remove the HOSTAP capability bit in the code and remove this
sentence.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.61 2008/08/27 09:05:03 damien Exp $	*/
a310 21
#ifndef __OpenBSD__
int
atw_activate(struct device *self, enum devact act)
{
	struct atw_softc *sc = (struct atw_softc *)self;
	int rv = 0, s;

	s = splnet();
	switch (act) {
	case DVACT_ACTIVATE:
		break;

	case DVACT_DEACTIVATE:
		if_deactivate(&sc->sc_ic.ic_if);
		break;
	}
	splx(s);
	return rv;
}
#endif

a787 4
#if !defined(__OpenBSD__)
	ifp->if_init = atw_init;
	ifp->if_stop = atw_stop;
#endif
a2035 1
#if defined(__OpenBSD__)
a2036 3
#else
	struct ethercom *ec = &ic->ic_ec;
#endif
a3102 1
#if defined(__OpenBSD__)
a3103 3
#else
		    ((sc->sc_ic.ic_ec.ec_capenable & ETHERCAP_VLAN_MTU) == 0 ||
#endif
a3289 1
#if defined(__OpenBSD__)
a3292 8
#else
			static char txstat_buf[sizeof("ffffffff<>" TXSTAT_FMT)];
			bitmask_snprintf(txstat & TXSTAT_ERRMASK, TXSTAT_FMT,
			    txstat_buf, sizeof(txstat_buf));
			printf("%s: txstat %s %d\n", sc->sc_dev.dv_xname,
			    txstat_buf,
			    MASK_AND_RSHIFT(txstat, ATW_TXSTAT_ARC_MASK));
#endif
a4018 6
#if !defined(__OpenBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
a4075 1
#if defined(__OpenBSD__)
a4077 4
#else
		    ether_addmulti(ifr, &sc->sc_ic.ic_ec) :
		    ether_delmulti(ifr, &sc->sc_ic.ic_ec);
#endif
@


1.61
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.60 2008/07/21 18:43:19 damien Exp $	*/
d819 1
a819 1
	ic->ic_caps |= IEEE80211_C_IBSS | IEEE80211_C_HOSTAP;
a1431 2
	case IEEE80211_M_HOSTAP: /* XXX */
		break;
a1439 1
	case IEEE80211_M_HOSTAP:
a2391 5
	case IEEE80211_M_HOSTAP:
		/* XXX 6-byte minimum TIM */
		len += atw_beacon_len_adjust;
		capinfo |= IEEE80211_CAPINFO_ESS;
		break;
d2474 2
a2475 3
	if ((ic->ic_opmode == IEEE80211_M_HOSTAP) ||
	    ((ic->ic_opmode == IEEE80211_M_IBSS) &&
	     (ic->ic_flags & IEEE80211_F_SIBSS))) {
d2589 1
a2589 2
	    (ic->ic_opmode == IEEE80211_M_HOSTAP ||
	     ic->ic_opmode == IEEE80211_M_IBSS))
@


1.60
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.59 2008/06/26 05:42:15 ray Exp $	*/
d203 1
d206 1
d817 4
a820 3
	ic->ic_caps = IEEE80211_C_PMGT | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_MONITOR | IEEE80211_C_WEP;

d833 1
d836 1
d1427 1
d1434 2
a1435 1
	case IEEE80211_M_MONITOR: /* XXX */
d1439 1
d1450 1
a1450 1

d2271 1
d2299 1
d2352 1
d2354 3
a2356 1
	uint32_t bcnt, bpli, cap0, cap1, capinfo;
d2389 1
d2425 1
d2481 1
d2489 3
a2491 1
	} else {
d2571 4
a2574 1
		if (ic->ic_opmode == IEEE80211_M_AHDEMO ||
d2596 1
d2602 1
@


1.59
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.58 2008/05/13 02:24:08 brad Exp $	*/
d204 1
a204 1
	    struct ieee80211_node *, int, int, u_int32_t);
d2265 1
a2265 1
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
d2274 1
a2274 1
	(*sc->sc_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
d3069 1
d3217 1
d3219 1
a3219 1
		if (atw_hw_decrypted(sc, wh))
d3221 2
d3224 3
a3226 1
		ieee80211_input(ifp, m, ni, (int)rssi, 0);
@


1.58
log
@Remove commented out NetBSD __KERNEL_RCSID macro usage.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.57 2008/04/16 18:32:15 damien Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.57
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.56 2008/03/13 23:07:29 brad Exp $	*/
a42 5

#include <sys/cdefs.h>
#if defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.69 2004/07/23 07:07:55 dyoung Exp $");
#endif
@


1.56
log
@Do not increment the input packet counter in these drivers as
ieee80211_input() already does this.

Mentioned by Peter Philipp in PR 5248.

ok claudio@@ mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.55 2007/09/30 11:33:14 kettenis Exp $	*/
d3617 1
d3674 5
a3678 2
			if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
				if ((m0 = ieee80211_wep_crypt(ifp, m0, 1)) == NULL) {
@


1.55
log
@s/NPBFILTER/NBPFILTER/ in #endif comment. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.54 2007/07/18 18:22:26 damien Exp $	*/
a3178 1
		ifp->if_ipackets++;
@


1.54
log
@convert code under #if 0 to the new ieee80211_key structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.53 2007/06/07 20:20:15 damien Exp $	*/
d3225 1
a3225 1
#endif /* NPBFILTER > 0 */
@


1.53
log
@move ieee80211_compute_duration() and ieee80211_compute_duration1()
functions into the two drivers that use them (atw and rtw.)
this code is not generic enough to be used by other drivers and
there is no chance that it will ever be used in newer driver since
it supports 802.11b only.
plus, it hurts my eyes each time i look into ieee80211_output.c.

"fine with me as long as the logic doesn't change in the functions" jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.52 2007/02/14 04:49:43 jsg Exp $	*/
d2231 1
a2231 1
		if (ic->ic_nw_keys[i].wk_len > 5) {
d2233 1
a2233 1
		} else if (ic->ic_nw_keys[i].wk_len != 0) {
d2239 3
a2241 3
		buf[i][0] = ic->ic_nw_keys[i].wk_key[0];
		memcpy(&buf[i][2], &ic->ic_nw_keys[i].wk_key[1],
		    ic->ic_nw_keys[i].wk_len - 1);
@


1.52
log
@put debug string tables under ATW_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.51 2007/02/14 04:46:44 jsg Exp $	*/
d258 3
d3416 165
d3691 1
a3691 1
		if (ieee80211_compute_duration(wh, m0->m_pkthdr.len,
@


1.51
log
@remove no longer used rate related variable/defines
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.50 2007/01/03 18:16:43 claudio Exp $	*/
d291 3
d315 2
@


1.50
log
@M_DUP_PKTHDR() cleanup. On static buffers M_DUP_PKTHDR() will leak mbuf tags.
See similar rum(4) commit for more info. OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.49 2006/11/26 17:20:33 jsg Exp $	*/
a143 4

#define	VOODOO_DUR_11_ROUNDING		0x01 /* necessary */
#define	VOODOO_DUR_2_4_SPECIALCASE	0x02 /* NOT necessary */
int atw_voodoo = VOODOO_DUR_11_ROUNDING;
@


1.49
log
@Make use of ieee80211_std_rateset
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.48 2006/08/30 11:20:20 jsg Exp $	*/
a3212 1
			M_DUP_PKTHDR(&mb, m);
d3216 3
a3218 1
			mb.m_pkthdr.len += mb.m_len;
a3554 1
			M_DUP_PKTHDR(&mb, m0);
d3558 3
a3560 1
			mb.m_pkthdr.len += mb.m_len;
@


1.48
log
@Return from channel tuning code if we get IEEE80211_CHAN_ANY
as per other drivers instead of doing panics.

Should workaround PR 5206 which I could never manage
to reproduce, though we really shouldn't be getting
IEEE80211_CHAN_ANY here.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.47 2006/06/23 06:27:11 miod Exp $	*/
d571 1
a571 1
	int country_code, error, i, nrate, srom_major;
d826 1
a826 6
	nrate = 0;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 2;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 4;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 11;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[nrate++] = 22;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates = nrate;
@


1.47
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.46 2006/05/22 20:35:12 krw Exp $	*/
d1530 2
a1531 2
	if (chan == IEEE80211_CHAN_ANY)
		panic("%s: chan == IEEE80211_CHAN_ANY", __func__);
@


1.46
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.45 2006/03/25 22:41:42 djm Exp $	*/
a326 1
		rv = EOPNOTSUPP;
@


1.45
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.44 2006/03/22 19:39:06 deraadt Exp $	*/
d2778 4
a2781 2
	shutdownhook_disestablish(sc->sc_sdhook);
	powerhook_disestablish(sc->sc_powerhook);
@


1.44
log
@incorrect check for end of array; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.43 2006/02/28 06:52:35 jsg Exp $	*/
d3222 1
a3222 1
			bpf_mtap(sc->sc_radiobpf, &mb);
d3501 1
a3501 1
				bpf_mtap(ifp->if_bpf, m0);
d3546 1
a3546 1
			bpf_mtap(ic->ic_rawbpf, m0);
d3563 1
a3563 1
			bpf_mtap(sc->sc_radiobpf, &mb);
@


1.43
log
@Switch to software WEP in a way mostly similiar to what David Young
did in NetBSD.  Fixes WEP on aanriot@@'s ADM8211A.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.42 2006/02/17 09:13:22 jsg Exp $	*/
d674 1
a674 1
	if (sc->sc_rftype > sizeof(type_strings)/sizeof(type_strings[0])) {
d678 1
a678 1
	if (sc->sc_bbptype > sizeof(type_strings)/sizeof(type_strings[0])) {
@


1.42
log
@Use ieee80211_compute_duration() instead of homerolled function.
From a change to NetBSD by David Young.
Tested by aanriot@@ on ADM8211A and me on ADM8211B.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.41 2005/10/11 13:07:02 brad Exp $	*/
d2129 1
d2215 4
a2221 2
	u_int32_t reg;
	int i;
d2231 1
d2263 1
d3228 1
d3231 1
d3507 7
d3619 1
d3624 1
@


1.41
log
@Eliminate use of M_HASFCS.

From thorpej NetBSD

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.40 2005/09/24 11:19:14 jsg Exp $	*/
a256 1
void	atw_frame_setdurs(struct atw_softc *, struct atw_frame *, int, int);
a3407 84
/* Compute the 802.11 Duration field and the PLCP Length fields for
 * a len-byte frame (HEADER + PAYLOAD + FCS) sent at rate * 500Kbps.
 * Write the fields to the ADM8211 Tx header, frm.
 *
 * TBD use the fragmentation threshold to find the right duration for
 * the first & last fragments.
 *
 * TBD make certain of the duration fields applied by the ADM8211 to each
 * fragment. I think that the ADM8211 knows how to subtract the CTS
 * duration when ATW_HDRCTL_RTSCTS is clear; that is why I add it regardless.
 * I also think that the ADM8211 does *some* arithmetic for us, because
 * otherwise I think we would have to set a first duration for CTS/first
 * fragment, a second duration for fragments between the first and the
 * last, and a third duration for the last fragment.
 *
 * TBD make certain that duration fields reflect addition of FCS/WEP
 * and correct duration arithmetic as necessary.
 */
void
atw_frame_setdurs(struct atw_softc *sc, struct atw_frame *frm, int rate,
    int len)
{
	int remainder;

	/* deal also with encrypted fragments */
	if (frm->atw_hdrctl & htole16(ATW_HDRCTL_WEP)) {
		DPRINTF2(sc, ("%s: atw_frame_setdurs len += 8\n",
		    sc->sc_dev.dv_xname));
		len += IEEE80211_WEP_IVLEN + IEEE80211_WEP_KIDLEN +
		       IEEE80211_WEP_CRCLEN;
	}

	/* 802.11 Duration Field for CTS/Data/ACK sequence minus FCS & WEP
	 * duration (XXX added by MAC?).
	 */
	frm->atw_head_dur = (16 * (len - IEEE80211_CRC_LEN)) / rate;
	remainder = (16 * (len - IEEE80211_CRC_LEN)) % rate;

	if (rate <= 4)
		/* 1-2Mbps WLAN: send ACK/CTS at 1Mbps */
		frm->atw_head_dur += 3 * (IEEE80211_DUR_DS_SIFS +
		    IEEE80211_DUR_DS_SHORT_PREAMBLE +
		    IEEE80211_DUR_DS_FAST_PLCPHDR) +
		    IEEE80211_DUR_DS_SLOW_CTS + IEEE80211_DUR_DS_SLOW_ACK;
	else
		/* 5-11Mbps WLAN: send ACK/CTS at 2Mbps */
		frm->atw_head_dur += 3 * (IEEE80211_DUR_DS_SIFS +
		    IEEE80211_DUR_DS_SHORT_PREAMBLE +
		    IEEE80211_DUR_DS_FAST_PLCPHDR) +
		    IEEE80211_DUR_DS_FAST_CTS + IEEE80211_DUR_DS_FAST_ACK;

	/* lengthen duration if long preamble */
	if ((sc->sc_flags & ATWF_SHORT_PREAMBLE) == 0)
		frm->atw_head_dur +=
		    3 * (IEEE80211_DUR_DS_LONG_PREAMBLE -
		         IEEE80211_DUR_DS_SHORT_PREAMBLE) +
		    3 * (IEEE80211_DUR_DS_SLOW_PLCPHDR -
		         IEEE80211_DUR_DS_FAST_PLCPHDR);

	if (remainder != 0)
		frm->atw_head_dur++;

	if ((atw_voodoo & VOODOO_DUR_2_4_SPECIALCASE) &&
	    (rate == 2 || rate == 4)) {
		/* derived from Linux: how could this be right? */
		frm->atw_head_plcplen = frm->atw_head_dur;
	} else {
		frm->atw_head_plcplen = (16 * len) / rate;
		remainder = (80 * len) % (rate * 5);

		if (remainder != 0) {
			frm->atw_head_plcplen++;

			/* XXX magic */
			if ((atw_voodoo & VOODOO_DUR_11_ROUNDING) &&
			    rate == 22 && remainder <= 30)
				frm->atw_head_plcplen |= 0x8000;
		}
	}
	frm->atw_tail_plcplen = frm->atw_head_plcplen =
	    htole16(frm->atw_head_plcplen);
	frm->atw_tail_dur = frm->atw_head_dur = htole16(frm->atw_head_dur);
}

d3449 1
a3449 1
	int do_encrypt, rate;
d3502 24
a3525 1
		rate = MAX(ieee80211_get_rate(ic), 2);
d3610 8
a3617 4
		/* TBD 4-addr frames */
		atw_frame_setdurs(sc, hh, rate,
		    m0->m_pkthdr.len - sizeof(struct atw_frame) +
		    sizeof(struct ieee80211_frame) + IEEE80211_CRC_LEN);
@


1.40
log
@The ADM8211B seems to stall after some time of constant
activity at DS11 speeds.  Check for this in the watchdog
using seemingly undocumented bits of the TEST1 register
used in Linux driver and restart if a stall is detected.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.39 2005/09/24 09:22:26 jsg Exp $	*/
d3177 1
a3177 1
			m->m_flags |= M_HASFCS;
@


1.39
log
@Make use of ieee80211_ibss_merge() from net80211.
Based on changes made by David Young to NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.38 2005/09/23 23:01:21 jsg Exp $	*/
d3368 1
d3389 17
@


1.38
log
@Handle SI4126 operations differently on ADM8211B.  This
is the final piece required to make ADM8211B based devices work.
Based around what the Linux driver does.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.37 2005/09/22 00:27:18 jsg Exp $	*/
d243 1
a243 1
void	atw_tsf(struct atw_softc *);
a259 2
void	atw_recv_beacon(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int, int, u_int32_t);
d261 2
a262 1
static	__inline void atw_tsft(struct atw_softc *, uint32_t *, uint32_t *);
d2265 7
a2271 1
const struct timeval atw_beacon_mininterval = {.tv_sec = 1, .tv_usec = 0};
d2279 7
a2286 3
	case IEEE80211_FC0_SUBTYPE_PROBE_REQ:
		/* do nothing: hardware answers probe request */
		break;
d2289 5
a2293 1
		atw_recv_beacon(ic, m, ni, subtype, rssi, rstamp);
a2295 1
		(*sc->sc_recv_mgmt)(ic, m, ni, subtype, rssi, rstamp);
a2300 127
static int
do_slow_print(struct atw_softc *sc, int *did_print)
{
	if ((sc->sc_if.if_flags & IFF_LINK0) == 0)
		return 0;
	if (!*did_print && (sc->sc_if.if_flags & IFF_DEBUG) == 0 &&
	    !ratecheck(&sc->sc_last_beacon, &atw_beacon_mininterval))
		return 0;

	*did_print = 1;
	return 1;
}

/* In ad hoc mode, atw_recv_beacon is responsible for the coalescence
 * of IBSSs with like SSID/channel but different BSSID. It joins the
 * oldest IBSS (i.e., with greatest TSF time), since that is the WECA
 * convention. Possibly the ADMtek chip does this for us; I will have
 * to test to find out.
 *
 * XXX we should add the duration field of the received beacon to
 * the TSF time it contains before comparing it with the ADM8211's
 * TSF.
 */
void
atw_recv_beacon(struct ieee80211com *ic, struct mbuf *m0,
    struct ieee80211_node *ni, int subtype, int rssi, u_int32_t rstamp)
{
	struct atw_softc *sc = (struct atw_softc*)ic->ic_softc;
	struct ieee80211_frame *wh;
	uint32_t tsftl, tsfth;
	uint32_t bcn_tsftl, bcn_tsfth;
	int did_print = 0, sign;
	union {
		uint32_t	words[2];
		uint8_t		tstamp[8];
	} u;

	(*sc->sc_recv_mgmt)(ic, m0, ni, subtype, rssi, rstamp);

	if (ic->ic_state != IEEE80211_S_RUN)
		return;

	atw_tsft(sc, &tsfth, &tsftl);

	(void)memcpy(&u, &ni->ni_tstamp[0], sizeof(u));
	bcn_tsftl = letoh32(u.words[0]);
	bcn_tsfth = letoh32(u.words[1]);

	/* we are faster, let the other guy catch up */
	if (bcn_tsfth < tsfth)
		sign = -1;
	else if (bcn_tsfth == tsfth && bcn_tsftl < tsftl)
		sign = -1;
	else
		sign = 1;

	if (memcmp(ni->ni_bssid, ic->ic_bss->ni_bssid,
	    IEEE80211_ADDR_LEN) == 0) {
		if (!do_slow_print(sc, &did_print))
			return;
		printf("%s: tsft offset %s%ull\n", sc->sc_dev.dv_xname,
		    (sign < 0) ? "-" : "",
		    (sign < 0)
			? ((((uint64_t)tsfth << 32) | tsftl) -
			    (((uint64_t)bcn_tsfth << 32) | bcn_tsftl))
			    : ((((uint64_t)bcn_tsfth << 32) | bcn_tsftl) -
				(((uint64_t)tsfth << 32) | tsftl)));
		return;
	}

	if (sign < 0)
		return;

	if (ieee80211_match_bss(ic, ni) != 0)
		return;

	if (do_slow_print(sc, &did_print)) {
		printf("%s: atw_recv_beacon: bssid mismatch %s\n",
		    sc->sc_dev.dv_xname, ether_sprintf(ni->ni_bssid));
	}

	if (ic->ic_opmode != IEEE80211_M_IBSS)
		return;

	if (do_slow_print(sc, &did_print)) {
		printf("%s: my tsft %llx beacon tsft %llx\n",
		    sc->sc_dev.dv_xname, ((uint64_t)tsfth << 32) | tsftl,
		    ((uint64_t)bcn_tsfth << 32) | bcn_tsftl);
	}

	wh = mtod(m0, struct ieee80211_frame *);

	if (do_slow_print(sc, &did_print)) {
		printf("%s: sync TSF with %s\n",
		    sc->sc_dev.dv_xname, ether_sprintf(wh->i_addr2));
	}

	ic->ic_flags &= ~IEEE80211_F_SIBSS;

	(void)memcpy(&ic->ic_bss->ni_tstamp[0], &u, sizeof(u));

	atw_tsf(sc);

	/* negotiate rates with new IBSS */
	ieee80211_fix_rate(ic, ni, IEEE80211_F_DOFRATE |
	    IEEE80211_F_DONEGO | IEEE80211_F_DODEL);
	if (ni->ni_rates.rs_nrates == 0) {
		if (do_slow_print(sc, &did_print)) {
			printf("%s: rates mismatch, BSSID %s\n",
			    sc->sc_dev.dv_xname, ether_sprintf(ni->ni_bssid));
		}
		return;
	}

	if (do_slow_print(sc, &did_print)) {
		printf("%s: sync BSSID %s -> ",
		    sc->sc_dev.dv_xname, ether_sprintf(ic->ic_bss->ni_bssid));
		printf("%s ", ether_sprintf(ni->ni_bssid));
		printf("(from %s)\n", ether_sprintf(wh->i_addr2));
	}

	(*ic->ic_node_copy)(ic, ic->ic_bss, ni);

	atw_write_bssid(sc);
	atw_start_beacon(sc, 1);
}

d2443 2
a2444 2
static __inline void
atw_tsft(struct atw_softc *sc, uint32_t *tsfth, uint32_t *tsftl)
d2447 1
d2449 3
a2451 3
		*tsfth = ATW_READ(sc, ATW_TSFTH);
		*tsftl = ATW_READ(sc, ATW_TSFTL);
		if (ATW_READ(sc, ATW_TSFTH) == *tsfth)
d2454 1
d2464 1
a2464 1
atw_tsf(struct atw_softc *sc)
d2469 1
d2472 1
a2472 1
		uint32_t	words[2];
d2479 3
a2481 4
		atw_tsft(sc, &tsfth, &tsftl);
		u.words[0] = htole32(tsftl);
		u.words[1] = htole32(tsfth);
		(void)memcpy(&ic->ic_bss->ni_tstamp[0], &u,
d2485 1
a2485 2
		tsftl = letoh32(u.words[0]);
		tsfth = letoh32(u.words[1]);
d2490 3
d2507 1
a2507 1
		ATW_TBTTPRE_MASK), ATW_TOFS1_TBTTPRE_MASK));
d2578 1
a2578 1
		atw_tsf(sc);
@


1.37
log
@Print MAC name and version and use "address" instead of
"802.11 address" when printing MAC address.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.36 2005/09/08 12:44:55 jsg Exp $	*/
d278 1
d287 10
d1243 3
d1249 21
d1609 22
d1766 2
a1767 1
	/* XXX Reference driver remarks that Abocom sets this to 50.
d1970 10
a1979 1
	const int nbits = 22;
d1981 2
a1982 2
	KASSERT((addr & ~PRESHIFT(SI4126_TWI_ADDR_MASK)) == 0);
	KASSERT((val & ~PRESHIFT(SI4126_TWI_DATA_MASK)) == 0);
d1984 3
a1986 2
	bits = LSHIFT(val, SI4126_TWI_DATA_MASK) |
	       LSHIFT(addr, SI4126_TWI_ADDR_MASK);
d2456 2
@


1.36
log
@Remove the last of the FreeBSD compatiblity goop.
ok reyk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.35 2005/08/27 09:13:50 avsm Exp $	*/
d192 2
d536 16
d674 3
a676 2
	printf("%s: %s RF, %s BBP", sc->sc_dev.dv_xname,
	    type_strings[sc->sc_rftype], type_strings[sc->sc_bbptype]);
d798 1
a798 1
	printf(" 802.11 address %s\n", ether_sprintf(ic->ic_myaddr));
@


1.35
log
@move some debug messages to use the debug macros so they dont appear
during normal operation.
deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.34 2005/07/18 02:43:26 fgsch Exp $	*/
a79 1
#include <net80211/ieee80211_compat.h>
d3816 2
a3817 1
		IASSERT(lasttx != -1, ("bad lastx"));
@


1.34
log
@remove trailing newline in panic(9); ok millert@@ and deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.33 2005/07/02 23:10:16 brad Exp $	*/
d3033 1
a3033 1
		printf("%s: transmit process not idle [%s]\n",
d3035 3
a3037 3
		    atw_tx_state[MASK_AND_RSHIFT(test0, ATW_TEST0_TS_MASK)]);
		printf("%s: bits %08x test0 %08x stsr %08x\n",
		    sc->sc_dev.dv_xname, bits, test0, stsr);
@


1.33
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.32 2005/06/21 05:36:43 kevlo Exp $	*/
d1481 1
a1481 1
		panic("%s: chan == IEEE80211_CHAN_ANY\n", __func__);
d2572 1
a2572 1
		panic("%s: unexpected state IEEE80211_S_INIT\n", __func__);
@


1.32
log
@remove duplicate function prototypes. ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.31 2005/05/27 18:57:19 robert Exp $	*/
d2700 6
a2722 6

	/*
	 * Mark the interface down and cancel the watchdog timer.
	 */
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
	ifp->if_timer = 0;
@


1.31
log
@make sure to enable socket on resume.
in order for the enable to work disable the socket on suspend.
lot of help from mickey@@

ok jsg@@ millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.30 2005/03/26 16:35:25 naddy Exp $	*/
a199 4
/* Device attachment */
void	atw_attach(struct atw_softc *);
int	atw_detach(struct atw_softc *);

a206 1
int	atw_enable(struct atw_softc *);
a207 2
void	atw_power(int, void *);
void	atw_shutdown(void *);
@


1.30
log
@enable reception of multicast frames; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.29 2005/02/17 18:28:05 reyk Exp $	*/
d3926 1
a3926 1
		atw_stop(ifp, 0);
@


1.29
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.28 2005/01/15 05:24:10 brad Exp $	*/
d2037 1
d2043 1
@


1.28
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.27 2004/12/31 04:27:52 jsg Exp $	*/
d3258 1
a3258 1
		 * so use free_node here instead of unref_node.
d3260 1
a3260 4
		if (ni == ic->ic_bss)
			ieee80211_unref_node(&ni);
		else
			ieee80211_free_node(ic, ni);
d3627 2
a3628 2
		if (ni != NULL && ni != ic->ic_bss)
			ieee80211_free_node(ic, ni);
@


1.27
log
@Define atw cfdriver struct in atw.c so atw at cardbus does not
depend on atw at pci. ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.26 2004/07/25 13:36:08 millert Exp $	*/
d4010 1
a4010 1
			if (ATW_IS_ENABLED(sc))
@


1.26
log
@Begin conditioning device configuration on revision number.  Three types
are known: ADM8211A (1.1/1.5), ADM8211B (2.0), ADM8211C (3.0).  The B and
C parts, while not yet supported, have AP capability.  From NetBSD (dyoung).
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.25 2004/07/25 00:30:48 millert Exp $	*/
d287 4
@


1.25
log
@Fix IBSS merges in atw(4).  From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.24 2004/07/25 00:16:35 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.68 2004/07/23 06:57:50 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.68 2004/07/23 06:57:50 dyoung Exp $");
d372 1
a372 1
	u_int32_t reg;
d376 1
a376 1
	reg = ATW_READ(sc, ATW_TEST0);
d378 11
a388 2
	if (reg & ATW_TEST0_EPNE) {
		printf("%s: SROM not detected\n", sc->sc_dev.dv_xname);
a390 4
#ifdef ATW_DEBUG
	if (reg & ATW_TEST0_EPSNM)
		printf("%s: bad SROM signature\n", sc->sc_dev.dv_xname);
#endif
d392 1
a392 1
	switch (reg & ATW_TEST0_EPTYP_MASK) {
d405 1
a405 1
		    MASK_AND_RSHIFT(reg, ATW_TEST0_EPTYP_MASK));
d549 1
a549 1
	int country_code, error, i, nrate;
d628 11
d716 15
d918 18
d971 1
d1012 1
a1012 1
	atw_write_sram(sc, 0, sc->sc_sram, sizeof(sc->sc_sram));
d1183 17
d1204 1
a1204 1
		ATW_WRITE(sc, ATW_MMIRADDR2, ATW_MMIRADDR2_INTERSIL);
d1213 1
a1213 1
		ATW_WRITE(sc, ATW_MMIRADDR2, ATW_MMIRADDR2_RFMD);
d1216 1
a1696 2
	 *
	 * EEPROMs for the ADM8211B contain a setting for this register.
d1698 1
a1698 1
	rc = atw_rf3000_write(sc, RF3000_OPTIONS1, 0x0);
d1703 1
a1703 1
	rc = atw_rf3000_write(sc, RF3000_OPTIONS2, RF3000_OPTIONS2_LNAGS_DELAY);
d2097 1
a2097 1
	KASSERT(buflen + ofs <= ATW_SRAM_A_SIZE);
d2165 11
a2175 6
	/* RX bypass WEP if revision != 0x20. (I assume revision != 0x20
	 * throughout.)
	 */
	sc->sc_wepctl = ATW_WEPCTL_WEPENABLE | ATW_WEPCTL_WEPRXBYP;
	if (sc->sc_if.if_flags & IFF_LINK2)
		sc->sc_wepctl &= ~ATW_WEPCTL_WEPRXBYP;
d3081 10
d3248 2
@


1.24
log
@Improve register definitions and slightly demystify some magic
numbers.  From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.23 2004/07/25 00:03:52 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.67 2004/07/23 23:13:27 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.67 2004/07/23 23:13:27 dyoung Exp $");
d1131 1
a1131 1
atw_bbp_io_init(struct atw_softc *sc) 
d2110 1
a2110 1
const struct timeval atw_beacon_mininterval = {1, 0}; /* 1s */
d2133 13
d2164 1
a2164 1
	int do_print = 0;
a2169 8
	if (ic->ic_if.if_flags & IFF_LINK0) {
		do_print = (ic->ic_if.if_flags & IFF_DEBUG)
		    ? 1 : ratecheck(&sc->sc_last_beacon,
		    &atw_beacon_mininterval);
	}

	wh = mtod(m0, struct ieee80211_frame *);

d2175 25
a2199 5
	if ((ni = ieee80211_lookup_node(ic, wh->i_addr2,
	    ic->ic_bss->ni_chan)) == NULL) {
		if (do_print)
			printf("%s: atw_recv_beacon: no node %s\n",
			    sc->sc_dev.dv_xname, ether_sprintf(wh->i_addr2));
d2203 1
a2203 1
	if (ieee80211_match_bss(ic, ni) != 0)
d2206 1
a2206 1
	if (memcmp(ni->ni_bssid, ic->ic_bss->ni_bssid, IEEE80211_ADDR_LEN) == 0)
d2209 1
a2209 1
	if (do_print)
d2212 1
d2217 1
a2217 7
	atw_tsft(sc, &tsfth, &tsftl);

	(void)memcpy(&u, &ic->ic_bss->ni_tstamp[0], sizeof(u));
	bcn_tsftl = letoh32(u.words[0]);
	bcn_tsfth = letoh32(u.words[1]);

	if (do_print)
d2221 1
d2223 1
a2223 5
	/* we are faster, let the other guy catch up */
	if (bcn_tsfth < tsfth)
		return;
	else if (bcn_tsfth == tsfth && bcn_tsftl < tsftl)
		return;
d2225 4
a2228 3
	if (do_print)
		printf("%s: sync TSF with %s\n", sc->sc_dev.dv_xname,
		    ether_sprintf(wh->i_addr2));
d2232 2
d2240 4
a2243 2
		printf("%s: rates mismatch, BSSID %s\n", sc->sc_dev.dv_xname,
			ether_sprintf(ni->ni_bssid));
d2247 3
a2249 3
	if (do_print) {
		printf("%s: sync BSSID %s -> ", sc->sc_dev.dv_xname,
		    ether_sprintf(ic->ic_bss->ni_bssid));
@


1.23
log
@The RSSI field in the Rx descriptor is the unadulterated content
of the DIVCTL/RSSI register on the RF3000 baseband.  Mask all but
the RSSI bits.  From NetBSD (dyoung).
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.22 2004/07/19 21:14:17 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.66 2004/07/16 23:13:27 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.66 2004/07/16 23:13:27 dyoung Exp $");
d2031 1
a2031 1
	KASSERT(buflen + ofs <= ATW_SRAM_SIZE);
@


1.22
log
@Delete the AP scan timeout in atw_detach.  Fixes a panic on detach if the
timeout is still active as seen by david@@
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.21 2004/07/15 16:21:13 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.65 2004/07/15 07:31:05 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.65 2004/07/15 07:31:05 dyoung Exp $");
d3005 1
a3005 1
	u_int32_t rssi;
d3013 1
a3013 1
		rssi = letoh32(sc->sc_rxdescs[i].ar_rssi);
d3020 1
a3020 1
		    ("%s: rx stat %08x rssi %08x buf1 %08x buf2 %08x\n",
d3022 1
a3022 2
		    letoh32(sc->sc_rxdescs[i].ar_stat),
		    letoh32(sc->sc_rxdescs[i].ar_rssi),
d3106 12
@


1.21
log
@Remove an errant ATW_CLR() that was the result of a merge error.
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.20 2004/07/15 16:13:10 millert Exp $	*/
d2675 2
@


1.20
log
@Insist that callers use atw_write_sram to copy even-length buffers
to even offsets in the ADM8211 SRAM.  From NetBSD (dyoung).
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.19 2004/07/15 16:11:51 millert Exp $	*/
a1756 2

	ATW_CLR(sc, ATW_BBPCTL, ATW_BBPCTL_WR);
@


1.19
log
@Totally revamp/re-organize device initialization using clue from the
reference driver.  From NetBSD (dyoung).
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.18 2004/07/15 15:50:51 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.64 2004/07/15 07:26:17 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.64 2004/07/15 07:26:17 dyoung Exp $");
d2031 1
a2031 7
	if (ofs % 2 != 0) {
		ofs--;
		buflen++;
	}

	if (buflen % 2 != 0)
		buflen++;
d2033 1
a2033 1
	assert(buflen + ofs <= ATW_SRAM_SIZE);
@


1.18
log
@Totally revamp device resets using clue from the reference driver.
From NetBSD (dyoung).
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.17 2004/07/15 15:39:40 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.63 2004/07/15 07:25:40 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.63 2004/07/15 07:25:40 dyoung Exp $");
d193 1
a197 1
void	atw_txdrain(struct atw_softc *);
d200 3
a202 4
void	atw_reset(struct atw_softc *);
int	atw_read_srom(struct atw_softc *);

void	atw_shutdown(void *);
d204 1
d206 1
d210 1
d214 2
d217 1
d222 1
d224 25
a250 1
void	atw_write_wep(struct atw_softc *);
d254 3
a256 2
void	atw_clear_sram(struct atw_softc *);
void	atw_write_sram(struct atw_softc *, u_int, u_int8_t *, u_int);
d259 1
d261 2
d264 2
a265 2
static __inline uint32_t atw_last_even_tsft(uint32_t, uint32_t, uint32_t);
static __inline void atw_tsft(struct atw_softc *, uint32_t *, uint32_t *);
d268 2
a269 7
void	atw_recv_mgmt(struct ieee80211com *, struct mbuf *,
	    struct ieee80211_node *, int, int, u_int32_t);
void	atw_node_free(struct ieee80211com *, struct ieee80211_node *);
void	atw_next_scan(void *);
struct ieee80211_node *atw_node_alloc(struct ieee80211com *);

int	atw_tune(struct atw_softc *);
d271 3
d972 3
a974 4
/*
 * atw_init:		[ ifnet interface function ]
 *
 *	Initialize the interface.  Must be called at splnet().
d976 2
a977 2
int
atw_init(struct ifnet *ifp)
d979 1
a979 6
	struct atw_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct atw_txsoft *txs;
	struct atw_rxsoft *rxs;
	u_int32_t reg;
	int i, error = 0;
d981 4
a984 2
	if ((error = atw_enable(sc)) != 0)
		goto out;
d986 3
a988 4
	/*
	 * Cancel any pending I/O. This also resets.
	 */
	atw_stop(ifp, 0);
d990 10
a999 4
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	DPRINTF(sc, ("%s: channel %d freq %d flags 0x%04x\n",
	    __func__, ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan),
	    ic->ic_bss->ni_chan->ic_freq, ic->ic_bss->ni_chan->ic_flags));
d1001 2
a1002 21
	/* Turn off APM??? (A binary-only driver does this.)
	 *
	 * Set Rx store-and-forward mode.
	 */
	reg = ATW_READ(sc, ATW_CMDR);
	reg &= ~ATW_CMDR_APM;
	reg &= ~ATW_CMDR_DRT_MASK;
	reg |= ATW_CMDR_RTE | LSHIFT(0x2, ATW_CMDR_DRT_MASK);

	ATW_WRITE(sc, ATW_CMDR, reg);

	/* Set data rate for PLCP Signal field, 1Mbps = 10 x 100Kb/s.
	 *
	 * XXX a binary-only driver sets a different service field than
	 * 0. why?
	 */
	reg = ATW_READ(sc, ATW_PLCPHD);
	reg &= ~(ATW_PLCPHD_SERVICE_MASK|ATW_PLCPHD_SIGNAL_MASK);
	reg |= LSHIFT(10, ATW_PLCPHD_SIGNAL_MASK) |
	    LSHIFT(0xb0, ATW_PLCPHD_SERVICE_MASK);
	ATW_WRITE(sc, ATW_PLCPHD, reg);
d1004 4
d1009 2
a1010 1
	reg = LSHIFT(4, ATW_TOFS2_PWR1UP_MASK)    | /* 8 ms = 4 * 2 ms */
d1018 13
a1030 1
	ATW_WRITE(sc, ATW_TOFS2, reg);
d1032 9
d1042 2
a1043 1
	                         LSHIFT(224, ATW_TXLMT_SRTYLIM_MASK));
d1045 15
d1066 7
d1074 5
a1078 3
	/* 16 TU max duration for contention-free period */
	reg = ATW_READ(sc, ATW_CFPP) & ~ATW_CFPP_CFPMD;
	ATW_WRITE(sc, ATW_CFPP, reg | LSHIFT(16, ATW_CFPP_CFPMD));
d1080 3
d1094 15
d1110 11
a1120 2
	/* Initialize interframe spacing.  EIFS=0x64 is used by a binary-only
	 * driver. Go figure.
a1121 8
	reg = LSHIFT(IEEE80211_DUR_DS_SLOT, ATW_IFST_SLOT_MASK) |
	      LSHIFT(22 * IEEE80211_DUR_DS_SIFS /* # of 22MHz cycles */,
	             ATW_IFST_SIFS_MASK) |
	      LSHIFT(IEEE80211_DUR_DS_DIFS, ATW_IFST_DIFS_MASK) |
	      LSHIFT(0x64 /* IEEE80211_DUR_DS_EIFS */, ATW_IFST_EIFS_MASK);
	ATW_WRITE(sc, ATW_IFST, reg);

	/* XXX More magic. Might relate to ACK timing. */
d1124 1
d1126 7
a1132 4
	/* Set up the MMI read/write addresses for the BBP.
	 *
	 * TBD find out the Marvel settings.
	 */
d1140 1
d1143 1
a1146 1
	default:
d1149 2
d1152 13
a1164 2
	sc->sc_wepctl = 0;
	ATW_WRITE(sc, ATW_MACTEST, ATW_MACTEST_MMI_USETXCLK);
d1166 1
a1166 1
	if ((error = atw_rf3000_init(sc)) != 0)
d1170 1
a1170 1
	 * Initialize the PCI Access Register.
d1172 1
a1172 1
	sc->sc_busmode = ATW_PAR_BAR;	/* XXX what is this? */
d1174 10
a1183 3
	/*
	 * If we're allowed to do so, use Memory Read Line
	 * and Memory Read Multiple.
d1185 23
a1207 1
	 * XXX Should we use Memory Write and Invalidate?
d1209 2
a1210 8
	if (sc->sc_flags & ATWF_MRL)
		sc->sc_busmode |= ATW_PAR_MRLE;
	if (sc->sc_flags & ATWF_MRM)
		sc->sc_busmode |= ATW_PAR_MRME;
	if (sc->sc_flags & ATWF_MWI)
		sc->sc_busmode |= ATW_PAR_MWIE;
	if (sc->sc_maxburst == 0)
		sc->sc_maxburst = 8;	/* ADM8211 default */
d1212 8
a1219 37
	switch (sc->sc_cacheline) {
	default:
		/* Use burst length. */
		break;
	case 8:
		sc->sc_busmode |= ATW_PAR_CAL_8DW;
		break;
	case 16:
		sc->sc_busmode |= ATW_PAR_CAL_16DW;
		break;
	case 32:
		sc->sc_busmode |= ATW_PAR_CAL_32DW;
		break;
	}
	switch (sc->sc_maxburst) {
	case 1:
		sc->sc_busmode |= ATW_PAR_PBL_1DW;
		break;
	case 2:
		sc->sc_busmode |= ATW_PAR_PBL_2DW;
		break;
	case 4:
		sc->sc_busmode |= ATW_PAR_PBL_4DW;
		break;
	case 8:
		sc->sc_busmode |= ATW_PAR_PBL_8DW;
		break;
	case 16:
		sc->sc_busmode |= ATW_PAR_PBL_16DW;
		break;
	case 32:
		sc->sc_busmode |= ATW_PAR_PBL_32DW;
		break;
	default:
		sc->sc_busmode |= ATW_PAR_PBL_8DW;
		break;
	}
a1225 7
	 * Initialize the OPMODE register.  We don't write it until
	 * we're ready to begin the transmit and receive processes.
	 */
	sc->sc_opmode = ATW_NAR_SR | ATW_NAR_ST |
	    sc->sc_txth[sc->sc_txthresh].txth_opmode;

	/*
a1276 9
	/* disable all wake-up events */
	ATW_CLR(sc, ATW_WCSR, ATW_WCSR_WP1E|ATW_WCSR_WP2E|ATW_WCSR_WP3E|
	                      ATW_WCSR_WP4E|ATW_WCSR_WP5E|ATW_WCSR_TSFTWE|
			      ATW_WCSR_TIMWE|ATW_WCSR_ATIMWE|ATW_WCSR_KEYWE|
			      ATW_WCSR_WFRE|ATW_WCSR_MPRE|ATW_WCSR_LSOE);

	/* ack all wake-up events */
	ATW_SET(sc, ATW_WCSR, 0);

d1308 1
d1310 4
a1313 1
	ATW_WRITE(sc, ATW_RDB, ATW_CDRXADDR(sc, sc->sc_rxptr));
a1329 2
	atw_start_beacon(sc, 0);

d1341 2
d1348 2
a1365 1
	ic->ic_state = IEEE80211_S_INIT;
d1367 6
a1372 1
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
a1373 2
	else
		error = ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
@


1.17
log
@kill sc_intr_ack
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.16 2004/07/15 15:28:59 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.60 2004/07/15 07:20:46 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.60 2004/07/15 07:20:46 dyoung Exp $");
d864 9
d876 2
a877 2
	for (i = 0; i < 10000; i++) {
		if (ATW_ISSET(sc, ATW_PAR, ATW_PAR_SWR) == 0)
d879 1
a879 1
		DELAY(1);
d882 3
d890 17
a906 2
	/* Turn off maximum power saving. */
	ATW_CLR(sc, ATW_FRCTL, ATW_FRCTL_MAXPSP);
d913 4
d922 1
a922 1
	memset(sc->sc_bssid, 0, sizeof(sc->sc_bssid));
@


1.16
log
@Take the paranoia out of the code for writing baseband registers.
Totally revamp the way that the synthesizer and baseband are programmed.
From NetBSD (dyoung).  Also remove trailing whitespace from lines (me).
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.14 2004/07/15 13:00:49 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.59 2004/07/15 07:19:46 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.59 2004/07/15 07:19:46 dyoung Exp $");
a1189 2
	if (sc->sc_intr_ack != NULL)
		(*sc->sc_intr_ack)(sc);
@


1.15
log
@missing bits from last commit
@
text
@d2 1
a2 1
/*	$NetBSD: atw.c,v 1.57 2004/07/15 07:11:23 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.57 2004/07/15 07:11:23 dyoung Exp $");
d52 2
a53 2
#include <sys/systm.h> 
#include <sys/mbuf.h>   
d65 1
a65 1
 
d70 1
a70 1
#if NBPFILTER > 0 
d72 1
a72 1
#endif 
d113 2
a114 2
 *    ack status register 
 *    enable interrupts 
d121 1
a121 1
 *    write descriptor base addrs: ATW_TDBD, ATW_TDBP, write ATW_RDB		
d144 2
d150 3
a152 3
int atw_rfio_enable_delay = 20 * 1000;
int atw_rfio_disable_delay = 2 * 1000;
int atw_writewep_delay = 5;
d155 1
d170 1
a170 1
#	ifdef ATW_BBPDEBUG 
d175 1
a175 1
#	ifdef ATW_SYNDEBUG 
d242 1
a242 1
void	atw_rfio_enable(struct atw_softc *, int);
d246 1
a246 1
int	atw_rf3000_tune(struct atw_softc *, u_int8_t);
d250 2
a251 2
int	atw_si4126_tune(struct atw_softc *, u_int8_t);
int	atw_si4126_write(struct atw_softc *, u_int, u_int);
d1278 1
a1278 1
atw_rfio_enable(struct atw_softc *sc, int enable)
d1283 1
a1283 1
		DELAY(atw_rfio_enable_delay);
d1286 1
a1286 1
		DELAY(atw_rfio_disable_delay); /* shorter for some reason */
d1294 1
a1294 2
	u_int32_t reg;
	int chan;
d1309 2
a1310 2
	if ((rc = atw_si4126_tune(sc, chan)) != 0 ||
	    (rc = atw_rf3000_tune(sc, chan)) != 0)
a1313 4
	reg = ATW_READ(sc, ATW_CAP0) & ~ATW_CAP0_CHN_MASK;
	ATW_WRITE(sc, ATW_CAP0,
	    reg | LSHIFT(chan, ATW_CAP0_CHN_MASK));

d1315 2
d1362 2
a1363 2
int
atw_si4126_tune(struct atw_softc *sc, u_int8_t chan)
a1364 1
	int rc = 0;
d1367 1
a1367 1
	u_int32_t reg;
d1376 1
a1376 1
	else 
d1388 4
a1391 1
	R = 44;
d1393 3
a1395 1
	atw_rfio_enable(sc, 1);
d1397 3
a1399 4
	/* Power-up RF, IF synthesizers. */
	if ((rc = atw_si4126_write(sc, SI4126_POWER,
	    SI4126_POWER_PDIB|SI4126_POWER_PDRB)) != 0)
		goto out;
d1401 6
a1406 1
	/* If RF2 N > 2047, then set KP2 to 1. */
d1409 1
a1409 2
	if ((rc = atw_si4126_write(sc, SI4126_GAIN, gain)) != 0)
		goto out;
d1411 7
a1417 7
	/* set LPWR, too? */
	if ((rc = atw_si4126_write(sc, SI4126_MAIN,
	    SI4126_MAIN_XINDIV2)) != 0)
		goto out;

	/* We set XINDIV2 = 1, so IF = N/(2 * R) * XIN.  XIN = 44MHz.
	 * I choose N = 1496, R = 44 so that 1496/(2 * 44) * 44MHz = 748MHz.
d1419 1
a1419 2
	if ((rc = atw_si4126_write(sc, SI4126_IFN, 1496)) != 0)
		goto out;
d1421 1
a1421 2
	if ((rc = atw_si4126_write(sc, SI4126_IFR, R)) != 0)
		goto out;
d1423 1
d1428 1
a1428 2
	if ((rc = atw_si4126_write(sc, SI4126_RF1R, R)) != 0)
		goto out;
d1430 2
a1431 2
	if ((rc = atw_si4126_write(sc, SI4126_RF1N, mhz - 374)) != 0)
		goto out;
d1437 1
a1437 2
	if ((rc = atw_si4126_write(sc, SI4126_RF2R, R)) != 0)
		goto out;
d1439 1
a1439 2
	if ((rc = atw_si4126_write(sc, SI4126_RF2N, mhz - 374)) != 0)
		goto out;
d1444 9
a1452 6
	if ((sc->sc_if.if_flags & IFF_LINK1) == 0 || chan == 14) {
		/* XXX there is a binary driver which sends
		 * ATW_GPIO_EN_MASK = 1, ATW_GPIO_O_MASK = 1. I had speculated
		 * that this enables the Si4126 by raising its PWDN#, but I
		 * think that it actually sets the Prism RF front-end
		 * to a special mode for channel 14.  
d1454 1
a1454 4
		reg = ATW_READ(sc, ATW_GPIO);
		reg &= ~(ATW_GPIO_EN_MASK|ATW_GPIO_O_MASK|ATW_GPIO_I_MASK);
		reg |= LSHIFT(1, ATW_GPIO_EN_MASK) | LSHIFT(1, ATW_GPIO_O_MASK);
		ATW_WRITE(sc, ATW_GPIO, reg);
d1456 1
a1460 5

out:
	atw_rfio_enable(sc, 0);

	return rc;
d1466 3
a1468 1
 * Call this w/ Tx/Rx suspended.
d1475 5
a1479 1
	atw_idle(sc, ATW_NAR_SR|ATW_NAR_ST);
d1481 2
a1482 1
	atw_rfio_enable(sc, 1);
d1509 6
a1524 7
	/* CCA is acquisition sensitive */ 
	rc = atw_rf3000_write(sc, RF3000_CCACTL,
	    LSHIFT(RF3000_CCACTL_MODE_ACQ, RF3000_CCACTL_MODE_MASK));

	if (rc != 0)
		goto out;

d1526 1
a1526 2
	atw_rfio_enable(sc, 0);
	ATW_WRITE(sc, ATW_NAR, sc->sc_opmode);
d1553 1
a1553 1
atw_rf3000_tune(struct atw_softc *sc, u_int8_t chan)
d1582 1
a1582 1
	atw_rfio_enable(sc, 1);
d1594 6
a1599 6
	/* from a binary-only driver. */
	reg = ATW_READ(sc, ATW_PLCPHD);
	reg &= ~ATW_PLCPHD_SERVICE_MASK;
	reg |= LSHIFT(LSHIFT(txpower, RF3000_GAINCTL_TXVGC_MASK),
	    ATW_PLCPHD_SERVICE_MASK);
	ATW_WRITE(sc, ATW_PLCPHD, reg);
d1606 9
a1614 1
	atw_rfio_enable(sc, 0);
a1629 11
	for (i = 1000; --i >= 0; ) {
		if (ATW_ISSET(sc, ATW_BBPCTL, ATW_BBPCTL_RD|ATW_BBPCTL_WR) == 0)
			break;
		DELAY(100);
	}

	if (i < 0) {
		printf("%s: BBPCTL busy (pre-write)\n", sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

d1634 3
a1636 4
	ATW_WRITE(sc, ATW_BBPCTL, reg);

	for (i = 1000; --i >= 0; ) {
		DELAY(100);
d1644 1
a1644 1
		printf("%s: BBPCTL busy (post-write)\n", sc->sc_dev.dv_xname);
d1712 1
a1712 1
int
d1715 2
a1716 2
	u_int32_t bits, reg;
	int i;
a1720 12
	for (i = 1000; --i >= 0; ) {
		if (ATW_ISSET(sc, ATW_SYNCTL, ATW_SYNCTL_RD|ATW_SYNCTL_WR) == 0)
			break;
		DELAY(100);
	}

	if (i < 0) {
		printf("%s: start atw_si4126_write, SYNCTL busy\n",
		    sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

d1724 15
a1738 17
	reg = sc->sc_synctl_wr | LSHIFT(bits, ATW_SYNCTL_DATA_MASK);

	ATW_WRITE(sc, ATW_SYNCTL, reg);

	for (i = 1000; --i >= 0; ) {
		DELAY(100);
		if (ATW_ISSET(sc, ATW_SYNCTL, ATW_SYNCTL_WR) == 0)
			break;
	}

	/* restore to acceptable starting condition */
	ATW_CLR(sc, ATW_SYNCTL, ATW_SYNCTL_WR);

	if (i < 0) {
		printf("%s: atw_si4126_write wrote %08x, SYNCTL still busy\n",
		    sc->sc_dev.dv_xname, reg);
		return ETIMEDOUT;
d1740 2
a1741 1
	return 0;
d1784 1
a1784 1
		printf("%s: atw_si4126_read wrote %08x, SYNCTL still busy\n",
d2254 1
a2254 1
	 * 
d2798 1
a2798 1
	s = splnet(); 
d3112 1
a3112 1
			    txstat & TXSTAT_ERRMASK, TXSTAT_FMT, 
d3584 1
a3584 1
 
@


1.14
log
@Simplify the Rx filter setup.  From NetBSD (dyoung)
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.13 2004/07/15 12:55:09 millert Exp $	*/
d1618 11
d1633 4
a1636 3
	for (i = 10; --i >= 0; ) {
		ATW_WRITE(sc, ATW_BBPCTL, reg);
		DELAY(2000);
d1641 2
d1644 1
a1644 1
		printf("%s: BBPCTL still busy\n", sc->sc_dev.dv_xname);
d1828 1
a1828 1
	u_int32_t hashes[2] = { 0, 0 };
d1832 4
a1835 7
	DPRINTF(sc, ("%s: atw_filter_setup: sc_flags 0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_flags));

	/*
	 * If we're running, idle the receive engine.  If we're NOT running,
	 * we're being called from atw_init(), and our writing ATW_NAR will
	 * start the transmit and receive processes in motion.
d1837 1
a1837 1
	if (ifp->if_flags & IFF_RUNNING)
d1842 5
a1846 3
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC) {
d1848 1
a1848 3
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
		goto setit;
d1851 2
a1857 1
		/* XXX */
d1866 2
d1869 3
a1871 18
	if (ifp->if_flags & IFF_BROADCAST) {
		hash = atw_calchash(etherbroadcastaddr);
		hashes[hash >> 5] |= 1 << (hash & 0x1f);
	}

	/* all bits set => hash is useless */
	if (~(hashes[0] & hashes[1]) == 0)
		goto allmulti;

 setit:
	if (ifp->if_flags & IFF_ALLMULTI)
		sc->sc_opmode |= ATW_NAR_MM;

	/* XXX in scan mode, do not filter packets. maybe this is
	 * unnecessary.
	 */
	if (ic->ic_state == IEEE80211_S_SCAN)
		sc->sc_opmode |= ATW_NAR_PR;
d1873 1
d1877 2
a1880 2

	DPRINTF(sc, ("%s: atw_filter_setup: returning\n", sc->sc_dev.dv_xname));
@


1.13
log
@Countdown correctly to the Target Beacon Transmission Time.
Borrowing an idea from the reference driver, use no 64-bit arithmetic.
From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.12 2004/07/15 12:29:39 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.56 2004/07/15 07:10:25 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.56 2004/07/15 07:10:25 dyoung Exp $");
a1617 11
	for (i = 1000; --i >= 0; ) {
		if (ATW_ISSET(sc, ATW_BBPCTL, ATW_BBPCTL_RD|ATW_BBPCTL_WR) == 0)
			break;
		DELAY(100);
	}

	if (i < 0) {
		printf("%s: BBPCTL busy (pre-write)\n", sc->sc_dev.dv_xname);
		return ETIMEDOUT;
	}

d1622 3
a1624 4
	ATW_WRITE(sc, ATW_BBPCTL, reg);

	for (i = 1000; --i >= 0; ) {
		DELAY(100);
a1628 2
	ATW_CLR(sc, ATW_BBPCTL, ATW_BBPCTL_WR);

d1630 1
a1630 1
		printf("%s: BBPCTL busy (post-write)\n", sc->sc_dev.dv_xname);
@


1.12
log
@Simplify IBSS merge code.
In atw_start_beacon, set CAP0 as well as BCNT and CAP1.
From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.11 2004/07/15 12:22:02 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.55 2004/07/15 07:01:20 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.55 2004/07/15 07:01:20 dyoung Exp $");
d227 2
a228 1
static __inline u_int64_t atw_predict_beacon(u_int64_t, u_int32_t);
d2067 2
a2068 2
	u_int64_t tsft, bcn_tsft;
	u_int32_t tsftl, tsfth;
d2070 4
d2109 1
a2109 7
	/* If we read TSFTL right before rollover, we read a TSF timer
	 * that is too high rather than too low. This prevents a spurious
	 * synchronization down the line, however, our IBSS could suffer
	 * from a creeping TSF....
	 */
	tsftl = ATW_READ(sc, ATW_TSFTL);
	tsfth = ATW_READ(sc, ATW_TSFTH);
d2111 3
a2113 2
	tsft = (u_int64_t)tsfth << 32 | tsftl;
	bcn_tsft = letoh64(*(u_int64_t*)ni->ni_tstamp);
d2117 2
a2118 1
		    sc->sc_dev.dv_xname, tsft, bcn_tsft);
d2121 3
a2123 1
	if (bcn_tsft < tsft)
d2276 22
a2297 7
/* First beacon was sent at time 0 microseconds, current time is
 * tsfth << 32 | tsftl microseconds, and beacon interval is tbtt
 * microseconds.  Return the expected time in microseconds for the
 * beacon after next.
 */
static __inline u_int64_t
atw_predict_beacon(u_int64_t tsft, u_int32_t tbtt)
d2299 7
a2305 1
	return tsft + (tbtt - tsft % tbtt);
d2320 5
a2324 1
	u_int64_t tsft, tbtt;
d2329 15
a2343 13
		tsft = ATW_READ(sc, ATW_TSFTH);
		tsft <<= 32;
		tsft |= ATW_READ(sc, ATW_TSFTL);
		*(u_int64_t*)&ic->ic_bss->ni_tstamp[0] = htole64(tsft);
	} else
		tsft = letoh64(*(u_int64_t*)&ic->ic_bss->ni_tstamp[0]);

	tbtt = atw_predict_beacon(tsft,
	    ic->ic_bss->ni_intval * IEEE80211_DUR_TU);

	/* skip one more beacon so that the TBTT cannot pass before
	 * we've programmed it, and also so that we can subtract a
	 * few TU so that we wake a little before TBTT. 
d2345 1
a2345 1
	tbtt += ic->ic_bss->ni_intval * IEEE80211_DUR_TU;
d2347 4
a2350 5
	/* wake up a little early */
	tbtt -= TBTTOFS * IEEE80211_DUR_TU;

	DPRINTF(sc, ("%s: tsft %llx tbtt %llx\n",
	    sc->sc_dev.dv_xname, tsft, tbtt));
d2355 2
a2356 3
	    LSHIFT(
		MASK_AND_RSHIFT((u_int32_t)tbtt, BITS(25, 10)),
		ATW_TOFS1_TBTTPRE_MASK));
@


1.11
log
@Re-synchronize TSFT after an IBSS merge.

Set up the Tx descriptor ring more safely.  Fix an endianness bug.
"It's a wonder this ever worked."  (Actually, it's not.)

hange the order in which I write the BSSID registers on the ADM8211,
to match the reference driver.  This probably does not make any
functional difference.

Only write the SSID buffer to the ADM8211 SRAM up to the end of
the SSID, not up to the end of the buffer.  Given the (too
conservative?) delays involved, this should save some time when we
join a new network.

From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.10 2004/07/15 12:18:57 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.53 2004/07/15 06:53:11 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.53 2004/07/15 06:53:11 dyoung Exp $");
d2070 2
a2071 2
	if (ic->ic_if.if_flags & IFF_DEBUG)
		do_print = (ic->ic_if.if_flags & IFF_LINK0)
d2074 1
d2080 1
a2080 4
	if (ic->ic_state != IEEE80211_S_RUN) {
		if (do_print)
			printf("%s: atw_recv_beacon: not running\n",
			    sc->sc_dev.dv_xname);
a2081 1
	}
d2091 1
a2091 4
	if (ieee80211_match_bss(ic, ni) != 0) {
		if (do_print)
			printf("%s: atw_recv_beacon: ssid mismatch %s\n",
			    sc->sc_dev.dv_xname, ether_sprintf(wh->i_addr2));
a2092 1
	}
d2202 3
a2204 1
	u_int32_t len, capinfo, reg_bcnt, reg_cap1;
a2208 2
	len = capinfo = 0;

d2218 3
a2220 2
	reg_bcnt = ATW_READ(sc, ATW_BCNT) & ~ATW_BCNT_BCNT_MASK;
	reg_cap1 = ATW_READ(sc, ATW_CAP1) & ~ATW_CAP1_CAPI_MASK;
d2222 2
a2223 2
	ATW_WRITE(sc, ATW_BCNT, reg_bcnt);
	ATW_WRITE(sc, ATW_CAP1, reg_cap1);
d2230 1
d2250 7
a2256 2
	reg_bcnt |= LSHIFT(len, ATW_BCNT_BCNT_MASK);
	reg_cap1 |= LSHIFT(capinfo, ATW_CAP1_CAPI_MASK);
d2258 8
a2265 2
	ATW_WRITE(sc, ATW_BCNT, reg_bcnt);
	ATW_WRITE(sc, ATW_CAP1, reg_cap1);
d2268 1
a2268 1
	    sc->sc_dev.dv_xname, reg_bcnt));
d2270 1
a2270 1
	    sc->sc_dev.dv_xname, reg_cap1));
@


1.10
log
@In the transmit interrupt handler, do not unnecessarily synchronize
all the descriptors for a buffer chain.  Just synchronize the last
one, which has the interesting stuff.

We still synchronize all the descriptors for the buffer chain if
super-verbose debugging is enabled, since the driver will print
all the descriptors for the chain.

Delay for tens of milliseconds lot after writing the Network Access
Register.  This is what the reference driver does, we can probably
lower the delays later.

From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.9 2004/07/15 12:15:09 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.49 2004/07/15 06:38:46 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.49 2004/07/15 06:38:46 dyoung Exp $");
d1106 1
d1108 1
a1108 1
		sc->sc_txdescs[i].at_ctl = 0 /* ATW_TXFLAG_TCH */;
d1113 1
a1113 1
	sc->sc_txdescs[ATW_NTXDESC - 1].at_ctl |= ATW_TXFLAG_TER;
d1910 6
a1921 6
	ATW_WRITE(sc, ATW_BSSID0,
	    LSHIFT(bssid[0], ATW_BSSID0_BSSIDB0_MASK) |
	    LSHIFT(bssid[1], ATW_BSSID0_BSSIDB1_MASK) |
	    LSHIFT(bssid[2], ATW_BSSID0_BSSIDB2_MASK) |
	    LSHIFT(bssid[3], ATW_BSSID0_BSSIDB3_MASK));

a2135 1
#if 0
a2136 1
#endif
d2170 3
a2172 1
	/* 34 bytes are reserved in ADM8211 SRAM for the SSID */
d2179 2
a2180 1
	atw_write_sram(sc, ATW_SRAM_ADDR_SSID, buf, sizeof(buf));
@


1.9
log
@Delete some dead code and a less-than-helpful comment.

Don't call back into the bus-specific code for resets any longer.
It does not seem to be necessary.

When super-verbose debugging is enabled, convert Rx descriptors'
endianness before printing them.

Clamp the length of a received packet, just in case the chip lies.

From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.8 2004/07/15 12:08:14 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.47 2004/07/15 06:34:24 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.47 2004/07/15 06:34:24 dyoung Exp $");
d2496 1
d2726 2
d2803 1
d2805 1
a2805 1
	for (i = 0; i < 1000; i++) {
d2809 1
a2809 1
		DELAY(10);
d3056 1
a3056 2
		ATW_CDTXSYNC(sc, txs->txs_lastdesc,
		    txs->txs_ndescs,
d3063 3
@


1.8
log
@Don't send data packets until the interface is in state RUN.  This
stops ARP and IPv6 Neighbor Discovery packets from trickling out
the interface before it is time.

Remove dead code from atw_clear_sram.

During scans, initialize the BSSID to ff:ff:ff:ff:ff:ff before
sending the first probe request.

From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.7 2004/07/15 12:00:31 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.43 2004/07/15 06:30:12 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.43 2004/07/15 06:30:12 dyoung Exp $");
d2345 1
a2628 3
		if (sc->sc_intr_ack != NULL)
			(*sc->sc_intr_ack)(sc);

a2785 1
	/* without this, somehow we run concurrently w/ interrupt handler */
d2898 4
a2901 4
		    sc->sc_rxdescs[i].ar_stat,
		    sc->sc_rxdescs[i].ar_rssi,
		    sc->sc_rxdescs[i].ar_buf1,
		    sc->sc_rxdescs[i].ar_buf2));
d2977 1
a2977 1
		m->m_pkthdr.len = m->m_len = len;
a3309 5

#if 0 /* TBD ??? */
	if ((sc->sc_flags & ATWF_LINK_UP) == 0 && ifp->if_snd.ifq_len < 10)
		return;
#endif
@


1.7
log
@Do not treat the lost beacon count specially any more.  It is kind of
a dumb way to track the link condition anyway.  From NetBSD (dyoung).
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.6 2004/07/15 11:53:32 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.39 2004/07/15 05:54:13 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.39 2004/07/15 05:54:13 dyoung Exp $");
a892 10
#if 0
	for (addr = 0; addr < 448; addr++) {
		ATW_WRITE(sc, ATW_WEPCTL,
		    ATW_WEPCTL_WR | ATW_WEPCTL_UNKNOWN0	| addr);
		DELAY(1000);
		ATW_WRITE(sc, ATW_WESK, 0);
		DELAY(1000); /* paranoia */
	}
	return;
#endif
a2363 2
		memset(sc->sc_bssid, 0, IEEE80211_ADDR_LEN);
		atw_write_bssid(sc);
d2404 6
a2409 1
	return (*sc->sc_newstate)(ic, nstate, arg);
d3346 3
@


1.6
log
@In ad hoc mode, don't set the mysterious EA bit in the Network Access
Register.  ADMtek's reference driver does not use it at all, and it
does not seem to make any difference whether we set it or not.  Also
remove some dead code and test instrumentation.  From NetBSD (dyoung).
@
text
@d1 1
a1 1
/*	$OpenBSD: atw.c,v 1.5 2004/07/07 19:19:37 millert Exp $	*/
a218 1
void	atw_write_bcn_thresh(struct atw_softc *);
a887 2

	sc->sc_lost_bcn_thresh = 0;
a1937 38
/* Tell the ADM8211 how many beacon intervals must pass without
 * receiving a beacon with the preferred BSSID & SSID set by
 * atw_write_bssid and atw_write_ssid before ATW_INTR_LINKOFF
 * raised.
 */
void
atw_write_bcn_thresh(struct atw_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int lost_bcn_thresh;

	/* Lose link after one second or 7 beacons, whichever comes
	 * first, but do not lose link before 2 beacons are lost.
	 *
	 * In host AP mode, set the lost-beacon threshold to 0.
	 */
	if (ic->ic_opmode == IEEE80211_M_HOSTAP)
		lost_bcn_thresh = 0;
	else {
		int beacons_per_second =
		    1000000 / (IEEE80211_DUR_TU * MAX(1,ic->ic_bss->ni_intval));
		lost_bcn_thresh = MAX(2, MIN(7, beacons_per_second));
	}

	/* XXX resets wake-up status bits */
	ATW_WRITE(sc, ATW_WCSR,
	    (ATW_READ(sc, ATW_WCSR) & ~ATW_WCSR_BLN_MASK) |
	    (LSHIFT(lost_bcn_thresh, ATW_WCSR_BLN_MASK) & ATW_WCSR_BLN_MASK));

	DPRINTF(sc, ("%s: lost-beacon threshold %d -> %d\n",
	    sc->sc_dev.dv_xname, sc->sc_lost_bcn_thresh, lost_bcn_thresh));

	sc->sc_lost_bcn_thresh = lost_bcn_thresh;

	DPRINTF(sc, ("%s: atw_write_bcn_thresh reg[WCSR] = %08x\n",
	    sc->sc_dev.dv_xname, ATW_READ(sc, ATW_WCSR)));
}

a2167 1
	atw_write_bcn_thresh(sc);
a2383 1
		atw_write_bcn_thresh(sc);
@


1.5
log
@Only drain the transmit queue if we are idling the transmit section.
From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.4 2004/07/07 19:18:35 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.37 2004/06/23 09:41:54 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.37 2004/06/23 09:41:54 dyoung Exp $");
a135 4
 * IBSS join/create
 *
 *    set ATW_NAR_EA (is set by ASIC?)
 *
a154 5
int atw_xhdrctl = 0;
int atw_xrtylmt = ~0;
int atw_xservice = IEEE80211_PLCP_SERVICE;
int atw_xpaylen = 0;

d164 5
d170 4
d175 2
a176 1
void atw_dump_pkt(struct ifnet *, struct mbuf *);
a244 3
#ifdef ATW_DEBUG
int	atw_rf3000_read(struct atw_softc *sc, u_int, u_int *);
#endif /* ATW_DEBUG */
a248 3
#ifdef ATW_DEBUG
int	atw_si4126_read(struct atw_softc *, u_int, u_int *);
#endif /* ATW_DEBUG */
a1213 1
		sc->sc_opmode &= ~ATW_NAR_EA;
a1219 2
		/* EA bit seems important for ad hoc reception. */
		sc->sc_opmode |= ATW_NAR_EA;
d1335 1
a1335 1
#ifdef ATW_DEBUG
d1354 1
a1354 1
#endif /* ATW_DEBUG */
d1382 1
a1382 1
#ifdef ATW_DEBUG
d1384 1
a1384 1
#endif /* ATW_DEBUG */
d1465 1
a1465 1
#ifdef ATW_DEBUG
d1467 1
a1467 1
#endif /* ATW_DEBUG */
d1537 1
a1537 1
#ifdef ATW_DEBUG
d1556 1
a1556 1
#endif /* ATW_DEBUG */
d1581 1
a1581 1
#ifdef ATW_DEBUG
d1583 1
a1583 1
#endif /* ATW_DEBUG */
d1608 1
a1608 1
#ifdef ATW_DEBUG
d1610 1
a1610 1
#endif /* ATW_DEBUG */
d1674 1
a1674 1
#ifdef ATW_DEBUG
d1714 1
a1714 1
#endif /* ATW_DEBUG */
d1774 1
a1774 1
#ifdef ATW_DEBUG
d1817 1
a1817 1
#endif /* ATW_DEBUG */
a3485 8
#if 0
		/* this virtually guaranteed that WEP-encrypted frames
		 * are fragmented. oops.
		 */
		hh->atw_fragthr = htole16(m0->m_pkthdr.len -
		    sizeof(struct atw_frame) + sizeof(struct ieee80211_frame));
		hh->atw_fragthr &= htole16(ATW_FRAGTHR_FRAGTHR_MASK);
#else
a3486 2
#endif

a3506 9
		/* experimental stuff */
		if (atw_xrtylmt != ~0)
			hh->atw_rtylmt = atw_xrtylmt;
		if (atw_xhdrctl != 0)
			hh->atw_hdrctl |= htole16(atw_xhdrctl);
		if (atw_xservice != IEEE80211_PLCP_SERVICE)
			hh->atw_service = atw_xservice;
		if (atw_xpaylen != 0)
			hh->atw_paylen = htole16(atw_xpaylen);
@


1.4
log
@After we wait for the MAC's transmit section to idle, drain the
transmit queue and cancel the watchdog timer.  Fixes the annoying
"atw0: transmit timeout" messages.  From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.3 2004/07/07 19:11:27 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.36 2004/06/23 09:27:59 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.36 2004/06/23 09:27:59 dyoung Exp $");
d2894 2
a2895 1
	atw_txdrain(sc);
@


1.3
log
@Check for ATW_C_BBPTYPE_RFMD in switch statement (not currently supported).
From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.2 2004/07/07 19:07:23 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.35 2004/06/23 09:05:50 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.35 2004/06/23 09:05:50 dyoung Exp $");
d193 1
d2515 20
a2543 1
	struct atw_txsoft *txs;
d2557 1
a2557 12
	/*
	 * Release any queued transmit buffers.
	 */
	while ((txs = SIMPLEQ_FIRST(&sc->sc_txdirtyq)) != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_txdirtyq, txs_q);
		if (txs->txs_mbuf != NULL) {
			bus_dmamap_unload(sc->sc_dmat, txs->txs_dmamap);
			m_freem(txs->txs_mbuf);
			txs->txs_mbuf = NULL;
		}
		SIMPLEQ_INSERT_TAIL(&sc->sc_txfreeq, txs, txs_q);
	}
d2570 1
a2570 2
	/* XXX */
	if (ATW_IS_ENABLED(sc))
d2894 1
@


1.2
log
@Fix typo: change ATW_RFTYPE_RFMD and family to ATW_BBPTYPE_RFMD.
This does not make any functional difference: each manufacturer's
RF type-number is the same as its BBP type-number.
From NetBSD (dyoung)
@
text
@d1 2
a2 2
/*	$OpenBSD: atw.c,v 1.1 2004/06/22 23:55:24 millert Exp $	*/
/*	$NetBSD: atw.c,v 1.33 2004/06/23 08:05:01 dyoung Exp $	*/
d46 1
a46 1
__KERNEL_RCSID(0, "$NetBSD: atw.c,v 1.32 2004/06/06 04:38:33 dyoung Exp $");
d647 4
@


1.1
log
@atw(4) driver from NetBSD (dyoung).  Based in part on a port by
Matthew Gream.

Unfortunately, the adm8211 card I have with me does not work correctly
with the driver yet so real testing will have to wait until I get
my hands on an adm8211-based DWL-650 or something similar.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: atw.c,v 1.32 2004/06/06 04:38:33 dyoung Exp $	*/
d639 1
a639 1
	case ATW_RFTYPE_INTERSIL:
d642 1
a642 1
	case ATW_RFTYPE_RFMD:
d646 1
a646 1
	case ATW_RFTYPE_MARVEL:
@

