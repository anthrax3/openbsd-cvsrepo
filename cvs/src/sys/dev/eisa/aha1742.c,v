head	1.44;
access;
symbols
	OPENBSD_6_0:1.44.0.8
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.6
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.44.0.4
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.16
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.14
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.43.0.10
	OPENBSD_5_4_BASE:1.43
	OPENBSD_5_3:1.43.0.8
	OPENBSD_5_3_BASE:1.43
	OPENBSD_5_2:1.43.0.6
	OPENBSD_5_2_BASE:1.43
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.4
	OPENBSD_5_0:1.43.0.2
	OPENBSD_5_0_BASE:1.43
	OPENBSD_4_9:1.42.0.4
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.42.0.2
	OPENBSD_4_8_BASE:1.42
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.26.0.4
	OPENBSD_4_4_BASE:1.26
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.21.0.4
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.21.0.2
	OPENBSD_3_9_BASE:1.21
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.4
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.14.0.18
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.16
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.14
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.12
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.10
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.8
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.14.0.6
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.4
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.14.0.2
	OPENBSD_2_1_BASE:1.14
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.44
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.43;
commitid	uzzBR7hz9ncd4O6G;

1.43
date	2011.04.05.14.51.57;	author krw;	state Exp;
branches;
next	1.42;

1.42
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.39;

1.39
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.01.10.00.40.25;	author krw;	state Exp;
branches;
next	1.36;

1.36
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.34;

1.34
date	2009.09.05.11.28.54;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.29.13.58.51;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.29;

1.29
date	2009.01.11.16.54.59;	author blambert;	state Exp;
branches;
next	1.28;

1.28
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.05.17.12.41;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.08.16.03.20;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.21.02.44.55;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2005.12.03.17.13.22;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.26.21.22.11;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2003.10.21.10.27.12;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.26.00.45.08;	author fgsch;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2001.02.03.07.24.49;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	96.11.28.23.27.36;	author niklas;	state Exp;
branches
	1.14.14.1;
next	1.13;

1.13
date	96.11.23.21.46.30;	author kstailey;	state Exp;
branches;
next	1.12;

1.12
date	96.11.12.20.30.07;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.10.16.12.38.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.06.02.10.42.58;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.05.26.00.26.52;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.10.12.34.20;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.02.13.50.44;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.04.28.04.17.27;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.04.21.22.20.12;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.09;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.40;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.08;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.30;	author deraadt;	state Exp;
branches;
next	;

1.14.14.1
date	2001.05.14.22.23.14;	author niklas;	state Exp;
branches;
next	1.14.14.2;

1.14.14.2
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.14.14.3;

1.14.14.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.14.14.4;

1.14.14.4
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.16.4.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.44
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: aha1742.c,v 1.43 2011/04/05 14:51:57 krw Exp $	*/
/*	$NetBSD: aha1742.c,v 1.61 1996/05/12 23:40:01 mycroft Exp $	*/

/*
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 *
 * commenced: Sun Sep 27 18:14:01 PDT 1992
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

typedef u_long physaddr;
typedef u_long physlen;

#define KVTOPHYS(x)	kvtop((caddr_t)x)

#define AHB_ECB_MAX	32	/* store up to 32 ECBs at one time */
#define	ECB_HASH_SIZE	32	/* hash table size for phystokv */
#define	ECB_HASH_SHIFT	9
#define ECB_HASH(x)	((((long)(x))>>ECB_HASH_SHIFT) & (ECB_HASH_SIZE - 1))

#define	AHB_NSEG	33	/* number of dma segments supported */

/*
 * EISA registers (offset from slot base)
 */
#define	EISA_VENDOR		0x0c80	/* vendor ID (2 ports) */
#define	EISA_MODEL		0x0c82	/* model number (2 ports) */
#define	EISA_CONTROL		0x0c84
#define	 EISA_RESET		0x04
#define	 EISA_ERROR		0x02
#define	 EISA_ENABLE		0x01

/*
 * AHA1740 EISA board mode registers (Offset from slot base)
 */
#define PORTADDR	0xCC0
#define	 PORTADDR_ENHANCED	0x80
#define BIOSADDR	0xCC1
#define	INTDEF		0xCC2
#define	SCSIDEF		0xCC3
#define	BUSDEF		0xCC4
#define	RESV0		0xCC5
#define	RESV1		0xCC6
#define	RESV2		0xCC7
/**** bit definitions for INTDEF ****/
#define	INT9	0x00
#define	INT10	0x01
#define	INT11	0x02
#define	INT12	0x03
#define	INT14	0x05
#define	INT15	0x06
#define INTHIGH 0x08		/* int high=ACTIVE (else edge) */
#define	INTEN	0x10
/**** bit definitions for SCSIDEF ****/
#define	HSCSIID	0x0F		/* our SCSI ID */
#define	RSTPWR	0x10		/* reset scsi bus on power up or reset */
/**** bit definitions for BUSDEF ****/
#define	B0uS	0x00		/* give up bus immediately */
#define	B4uS	0x01		/* delay 4uSec. */
#define	B8uS	0x02

/*
 * AHA1740 ENHANCED mode mailbox control regs (Offset from slot base)
 */
#define MBOXOUT0	0xCD0
#define MBOXOUT1	0xCD1
#define MBOXOUT2	0xCD2
#define MBOXOUT3	0xCD3

#define	ATTN		0xCD4
#define	G2CNTRL		0xCD5
#define	G2INTST		0xCD6
#define G2STAT		0xCD7

#define	MBOXIN0		0xCD8
#define	MBOXIN1		0xCD9
#define	MBOXIN2		0xCDA
#define	MBOXIN3		0xCDB

#define G2STAT2		0xCDC

/*
 * Bit definitions for the 5 control/status registers
 */
#define	ATTN_TARGET		0x0F
#define	ATTN_OPCODE		0xF0
#define  OP_IMMED		0x10
#define	  AHB_TARG_RESET	0x80
#define  OP_START_ECB		0x40
#define  OP_ABORT_ECB		0x50

#define	G2CNTRL_SET_HOST_READY	0x20
#define	G2CNTRL_CLEAR_EISA_INT	0x40
#define	G2CNTRL_HARD_RESET	0x80

#define	G2INTST_TARGET		0x0F
#define	G2INTST_INT_STAT	0xF0
#define	 AHB_ECB_OK		0x10
#define	 AHB_ECB_RECOVERED	0x50
#define	 AHB_HW_ERR		0x70
#define	 AHB_IMMED_OK		0xA0
#define	 AHB_ECB_ERR		0xC0
#define	 AHB_ASN		0xD0	/* for target mode */
#define	 AHB_IMMED_ERR		0xE0

#define	G2STAT_BUSY		0x01
#define	G2STAT_INT_PEND		0x02
#define	G2STAT_MBOX_EMPTY	0x04

#define	G2STAT2_HOST_READY	0x01

struct ahb_dma_seg {
	physaddr seg_addr;
	physlen seg_len;
};

struct ahb_ecb_status {
	u_short status;
#define	ST_DON	0x0001
#define	ST_DU	0x0002
#define	ST_QF	0x0008
#define	ST_SC	0x0010
#define	ST_DO	0x0020
#define	ST_CH	0x0040
#define	ST_INT	0x0080
#define	ST_ASA	0x0100
#define	ST_SNS	0x0200
#define	ST_INI	0x0800
#define	ST_ME	0x1000
#define	ST_ECA	0x4000
	u_char  host_stat;
#define	HS_OK			0x00
#define	HS_CMD_ABORTED_HOST	0x04
#define	HS_CMD_ABORTED_ADAPTER	0x05
#define	HS_TIMED_OUT		0x11
#define	HS_HARDWARE_ERR		0x20
#define	HS_SCSI_RESET_ADAPTER	0x22
#define	HS_SCSI_RESET_INCOMING	0x23
	u_char  target_stat;
	u_long  resid_count;
	u_long  resid_addr;
	u_short addit_status;
	u_char  sense_len;
	u_char  unused[9];
	u_char  cdb[6];
};

struct ahb_ecb {
	u_char  opcode;
#define	ECB_SCSI_OP	0x01
		u_char:4;
	u_char  options:3;
		u_char:1;
	short   opt1;
#define	ECB_CNE	0x0001
#define	ECB_DI	0x0080
#define	ECB_SES	0x0400
#define	ECB_S_G	0x1000
#define	ECB_DSB	0x4000
#define	ECB_ARS	0x8000
	short   opt2;
#define	ECB_LUN	0x0007
#define	ECB_TAG	0x0008
#define	ECB_TT	0x0030
#define	ECB_ND	0x0040
#define	ECB_DAT	0x0100
#define	ECB_DIR	0x0200
#define	ECB_ST	0x0400
#define	ECB_CHK	0x0800
#define	ECB_REC	0x4000
#define	ECB_NRB	0x8000
	u_short unused1;
	physaddr data_addr;
	physlen  data_length;
	physaddr status;
	physaddr link_addr;
	short   unused2;
	short   unused3;
	physaddr sense_ptr;
	u_char  req_sense_length;
	u_char  scsi_cmd_length;
	short   cksum;
	struct scsi_generic scsi_cmd;
	/*-----------------end of hardware supported fields----------------*/
	TAILQ_ENTRY(ahb_ecb) chain;
	struct ahb_ecb *nexthash;
	long hashkey;
	struct scsi_xfer *xs;	/* the scsi_xfer for this cmd */
	int flags;
#define ECB_FREE	0
#define ECB_ACTIVE	1
#define ECB_ABORTED	2
#define ECB_IMMED	4
#define ECB_IMMED_FAIL	8
	struct ahb_dma_seg ahb_dma[AHB_NSEG];
	struct ahb_ecb_status ecb_status;
	struct scsi_sense_data ecb_sense;
};

struct ahb_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	eisa_chipset_tag_t sc_ec;

	bus_space_handle_t sc_ioh;
	int sc_irq;
	void *sc_ih;

	struct ahb_ecb *immed_ecb;	/* an outstanding immediate command */
	struct ahb_ecb *ecbhash[ECB_HASH_SIZE];
	TAILQ_HEAD(, ahb_ecb) free_ecb;
	int numecbs;
	int ahb_scsi_dev;		/* our scsi id */
	struct scsi_link sc_link;
	struct mutex		sc_ecb_mtx;
	struct scsi_iopool	sc_iopool;
};

void ahb_send_mbox(struct ahb_softc *, int, struct ahb_ecb *);
int ahb_poll(struct ahb_softc *, struct scsi_xfer *, int);
void ahb_send_immed(struct ahb_softc *, int, u_long);
int ahbintr(void *);
void ahb_done(struct ahb_softc *, struct ahb_ecb *);
void ahb_ecb_free(void *, void *);
void *ahb_ecb_alloc(void *);
struct ahb_ecb *ahb_ecb_phys_kv(struct ahb_softc *, physaddr);
int ahb_find(bus_space_tag_t, bus_space_handle_t, struct ahb_softc *);
void ahb_init(struct ahb_softc *);
void ahbminphys(struct buf *, struct scsi_link *);
void ahb_scsi_cmd(struct scsi_xfer *);
void ahb_timeout(void *);
void ahb_print_ecb(struct ahb_ecb *);
void ahb_print_active_ecb(struct ahb_softc *);
int ahbprint(void *, const char *);

#define	MAX_SLOTS	15

#ifdef	AHBDEBUG
int     ahb_debug = 0;
#endif /* AHBDEBUG */
#define AHB_SHOWECBS 0x01
#define AHB_SHOWINTS 0x02
#define AHB_SHOWCMDS 0x04
#define AHB_SHOWMISC 0x08

struct scsi_adapter ahb_switch = {
	ahb_scsi_cmd,
	ahbminphys,
	0,
	0,
};

int	ahbmatch(struct device *, void *, void *);
void	ahbattach(struct device *, struct device *, void *);

struct cfattach ahb_ca = {
	sizeof(struct ahb_softc), ahbmatch, ahbattach
};

struct cfdriver ahb_cd = {
	NULL, "ahb", DV_DULL
};

/*
 * Function to send a command out through a mailbox
 */
void
ahb_send_mbox(sc, opcode, ecb)
	struct ahb_softc *sc;
	int opcode;
	struct ahb_ecb *ecb;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int wait = 300;	/* 1ms should be enough */

	while (--wait) {
		if ((bus_space_read_1(iot, ioh, G2STAT) &
		    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))
			break;
		delay(10);
	}
	if (!wait)
		panic("%s: board not responding", sc->sc_dev.dv_xname);

	/* don't know this will work */
	bus_space_write_4(iot, ioh, MBOXOUT0, KVTOPHYS(ecb));
	bus_space_write_1(iot, ioh, ATTN, opcode | ecb->xs->sc_link->target);
}

/*
 * Function to poll for command completion when in poll mode
 */
int
ahb_poll(sc, xs, count)
	struct ahb_softc *sc;
	struct scsi_xfer *xs;
	int count;
{				/* in msec  */
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s;

	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {
			s = splbio();
			ahbintr(sc);
			splx(s);
		}
		if (xs->flags & ITSDONE)
			return 0;
		delay(1000);
		count--;
	}
	return 1;
}

/*
 * Function to  send an immediate type command to the adapter
 */
void
ahb_send_immed(sc, target, cmd)
	struct ahb_softc *sc;
	int target;
	u_long cmd;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int wait = 100;	/* 1 ms enough? */

	while (--wait) {
		if ((bus_space_read_1(iot, ioh, G2STAT) &
		    (G2STAT_BUSY | G2STAT_MBOX_EMPTY)) == (G2STAT_MBOX_EMPTY))
			break;
		delay(10);
	}
	if (!wait)
		panic("%s: board not responding", sc->sc_dev.dv_xname);

	/* don't know this will work */
	bus_space_write_4(iot, ioh, MBOXOUT0, cmd);
	bus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);
	bus_space_write_1(iot, ioh, ATTN, OP_IMMED | target);
}

/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int
ahbmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct eisa_attach_args *ea = aux;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	int rv;

	/* must match one of our known ID strings */
	if (strcmp(ea->ea_idstring, "ADP0000") &&
	    strcmp(ea->ea_idstring, "ADP0001") &&
	    strcmp(ea->ea_idstring, "ADP0002") &&
	    strcmp(ea->ea_idstring, "ADP0400"))
		return (0);

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,
	    &ioh))
		return (0);

#ifdef notyet
	/* This won't compile as-is, anyway. */
	bus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);
	delay(10);
	bus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE);
	/* Wait for reset? */
	delay(1000);
#endif

	rv = !ahb_find(iot, ioh, NULL);

	bus_space_unmap(ea->ea_iot, ioh, EISA_SLOT_SIZE);

	return (rv);
}

int
ahbprint(aux, name)
	void *aux;
	const char *name;
{
	return UNCONF;
}

/*
 * Attach all the sub-devices we can find
 */
void
ahbattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct eisa_attach_args *ea = aux;
	struct ahb_softc *sc = (void *)self;
	struct scsibus_attach_args saa;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	eisa_chipset_tag_t ec = ea->ea_ec;
	eisa_intr_handle_t ih;
	const char *model, *intrstr;

	sc->sc_iot = iot;
	sc->sc_ec = ec;

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, 0,
	    &ioh))
		panic("ahbattach: can't map i/o addresses");
	sc->sc_ioh = ioh;
	if (ahb_find(iot, ioh, sc))
		panic("ahbattach: ahb_find failed!");

	ahb_init(sc);
	TAILQ_INIT(&sc->free_ecb);
	mtx_init(&sc->sc_ecb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, ahb_ecb_alloc, ahb_ecb_free);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->ahb_scsi_dev;
	sc->sc_link.adapter = &ahb_switch;
	sc->sc_link.openings = 2;
	sc->sc_link.pool = &sc->sc_iopool;

	if (!strcmp(ea->ea_idstring, "ADP0000"))
		model = EISA_PRODUCT_ADP0000;
	else if (!strcmp(ea->ea_idstring, "ADP0001"))
		model = EISA_PRODUCT_ADP0001;
	else if (!strcmp(ea->ea_idstring, "ADP0002"))
		model = EISA_PRODUCT_ADP0002;
	else if (!strcmp(ea->ea_idstring, "ADP0400"))
		model = EISA_PRODUCT_ADP0400;
	else
		model = "unknown model!";
	printf(": <%s> ", model);

	if (eisa_intr_map(ec, sc->sc_irq, &ih)) {
		printf("%s: couldn't map interrupt (%d)\n",
		    sc->sc_dev.dv_xname, sc->sc_irq);
		return;
	}
	intrstr = eisa_intr_string(ec, ih);
	sc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,
	    ahbintr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	if (intrstr != NULL)
		printf("%s\n", intrstr);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/*
	 * ask the adapter what subunits are present
	 */
	config_found(self, &saa, ahbprint);
}

/*
 * Catch an interrupt from the adaptor
 */
int
ahbintr(arg)
	void *arg;
{
	struct ahb_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ahb_ecb *ecb;
	u_char ahbstat;
	u_long mboxval;

#ifdef	AHBDEBUG
	printf("%s: ahbintr ", sc->sc_dev.dv_xname);
#endif /* AHBDEBUG */

	if ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) == 0)
		return 0;

	for (;;) {
		/*
		 * First get all the information and then
		 * acknowledge the interrupt
		 */
		ahbstat = bus_space_read_1(iot, ioh, G2INTST);
		mboxval = bus_space_read_4(iot, ioh, MBOXIN0);
		bus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);

#ifdef	AHBDEBUG
		printf("status = 0x%x ", ahbstat);
#endif /*AHBDEBUG */

		/*
		 * Process the completed operation
		 */
		switch (ahbstat & G2INTST_INT_STAT) {
		case AHB_ECB_OK:
		case AHB_ECB_RECOVERED:
		case AHB_ECB_ERR:
			ecb = ahb_ecb_phys_kv(sc, mboxval);
			if (!ecb) {
				printf("%s: BAD ECB RETURNED!\n",
				    sc->sc_dev.dv_xname);
				continue;	/* whatever it was, it'll timeout */
			}
			break;

		case AHB_IMMED_ERR:
			ecb->flags |= ECB_IMMED_FAIL;
		case AHB_IMMED_OK:
			ecb = sc->immed_ecb;
			sc->immed_ecb = NULL;
			break;

		default:
			printf("%s: unexpected interrupt %x\n",
			    sc->sc_dev.dv_xname, ahbstat);
			ecb = 0;
			break;
		}
		if (ecb) {
#ifdef	AHBDEBUG
			if (ahb_debug & AHB_SHOWCMDS)
				show_scsi_cmd(ecb->xs);
			if ((ahb_debug & AHB_SHOWECBS) && ecb)
				printf("<int ecb(%x)>", ecb);
#endif /*AHBDEBUG */
			timeout_del(&ecb->xs->stimeout);
			ahb_done(sc, ecb);
		}

		if ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) ==
		    0)
			return 1;
	}
}

/*
 * We have a ecb which has been processed by the adaptor, now we look to see
 * how the operation went.
 */
void
ahb_done(sc, ecb)
	struct ahb_softc *sc;
	struct ahb_ecb *ecb;
{
	struct ahb_ecb_status *stat = &ecb->ecb_status;
	struct scsi_sense_data *s1, *s2;
	struct scsi_xfer *xs = ecb->xs;

	SC_DEBUG(xs->sc_link, SDEV_DB2, ("ahb_done\n"));
	/*
	 * Otherwise, put the results of the operation
	 * into the xfer and call whoever started it
	 */
	if (ecb->flags & ECB_IMMED) {
		if (ecb->flags & ECB_IMMED_FAIL)
			xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}
	if (xs->error == XS_NOERROR) {
		if (stat->host_stat != HS_OK) {
			switch (stat->host_stat) {
			case HS_SCSI_RESET_ADAPTER:
				break;
			case HS_SCSI_RESET_INCOMING:
				break;
			case HS_CMD_ABORTED_HOST:
			case HS_CMD_ABORTED_ADAPTER:
				xs->error = XS_DRIVER_STUFFUP;
				break;
			case HS_TIMED_OUT:	/* No response */
				xs->error = XS_SELTIMEOUT;
				break;
			default:	/* Other scsi protocol messes */
				printf("%s: host_stat %x\n",
				    sc->sc_dev.dv_xname, stat->host_stat);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else if (stat->target_stat != SCSI_OK) {
			switch (stat->target_stat) {
			case SCSI_CHECK:
				s1 = &ecb->ecb_sense;
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;
			case SCSI_BUSY:
				xs->error = XS_BUSY;
				break;
			default:
				printf("%s: target_stat %x\n",
				    sc->sc_dev.dv_xname, stat->target_stat);
				xs->error = XS_DRIVER_STUFFUP;
			}
		} else
			xs->resid = 0;
	}
done:
	scsi_done(xs);
}

/*
 * A ecb (and hence a mbx-out) is put onto the free list.
 */
void
ahb_ecb_free(xsc, xecb)
	void *xsc, *xecb;
{
	struct ahb_softc *sc = xsc;
	struct ahb_ecb *ecb = xecb;

	ecb->flags = ECB_FREE;

	mtx_enter(&sc->sc_ecb_mtx);
	TAILQ_INSERT_HEAD(&sc->free_ecb, ecb, chain);
	mtx_leave(&sc->sc_ecb_mtx);
}

static inline void ahb_init_ecb(struct ahb_softc *, struct ahb_ecb *);

static inline void
ahb_init_ecb(sc, ecb)
	struct ahb_softc *sc;
	struct ahb_ecb *ecb;
{
	int hashnum;

	bzero(ecb, sizeof(struct ahb_ecb));
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	ecb->hashkey = KVTOPHYS(ecb);
	hashnum = ECB_HASH(ecb->hashkey);
	ecb->nexthash = sc->ecbhash[hashnum];
	sc->ecbhash[hashnum] = ecb;
}

/*
 * Get a free ecb
 */
void *
ahb_ecb_alloc(xsc)
	void *xsc;
{
	struct ahb_softc *sc = xsc;
	struct ahb_ecb *ecb;

	mtx_enter(&sc->sc_ecb_mtx);
	ecb = TAILQ_FIRST(&sc->free_ecb);
	if (ecb) {
		TAILQ_REMOVE(&sc->free_ecb, ecb, chain);
		ecb->flags = ECB_ACTIVE;
	}
	mtx_leave(&sc->sc_ecb_mtx);

	return ecb;
}

/*
 * given a physical address, find the ecb that it corresponds to.
 */
struct ahb_ecb *
ahb_ecb_phys_kv(sc, ecb_phys)
	struct ahb_softc *sc;
	physaddr ecb_phys;
{
	int hashnum = ECB_HASH(ecb_phys);
	struct ahb_ecb *ecb = sc->ecbhash[hashnum];

	while (ecb) {
		if (ecb->hashkey == ecb_phys)
			break;
		ecb = ecb->nexthash;
	}
	return ecb;
}

/*
 * Start the board, ready for normal operation
 */
int
ahb_find(iot, ioh, sc)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct ahb_softc *sc;
{
	u_char intdef;
	int i, irq, busid;
	int wait = 1000;	/* 1 sec enough? */

	bus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);

#define	NO_NO 1
#ifdef NO_NO
	/*
	 * reset board, If it doesn't respond, assume
	 * that it's not there.. good for the probe
	 */
	bus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_HARD_RESET);
	delay(1000);
	bus_space_write_1(iot, ioh, G2CNTRL, 0);
	delay(10000);
	while (--wait) {
		if ((bus_space_read_1(iot, ioh, G2STAT) & G2STAT_BUSY) == 0)
			break;
		delay(1000);
	}
	if (!wait) {
#ifdef AHBDEBUG
		if (ahb_debug & AHB_SHOWMISC)
			printf("ahb_find: No answer from aha1742 board\n");
#endif /*AHBDEBUG */
		return ENXIO;
	}
	i = bus_space_read_1(iot, ioh, MBOXIN0);
	if (i) {
		printf("self test failed, val = 0x%x\n", i);
		return EIO;
	}

	/* Set it again, just to be sure. */
	bus_space_write_1(iot, ioh, PORTADDR, PORTADDR_ENHANCED);
#endif

	while (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND) {
		printf(".");
		bus_space_write_1(iot, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);
		delay(10000);
	}

	intdef = bus_space_read_1(iot, ioh, INTDEF);
	switch (intdef & 0x07) {
	case INT9:
		irq = 9;
		break;
	case INT10:
		irq = 10;
		break;
	case INT11:
		irq = 11;
		break;
	case INT12:
		irq = 12;
		break;
	case INT14:
		irq = 14;
		break;
	case INT15:
		irq = 15;
		break;
	default:
		printf("illegal int setting %x\n", intdef);
		return EIO;
	}

	/* make sure we can interrupt */
	bus_space_write_1(iot, ioh, INTDEF, (intdef | INTEN));

	/* who are we on the scsi bus? */
	busid = (bus_space_read_1(iot, ioh, SCSIDEF) & HSCSIID);

	/* if we want to fill in softc, do so now */
	if (sc != NULL) {
		sc->sc_irq = irq;
		sc->ahb_scsi_dev = busid;
	}

	/*
	 * Note that we are going and return (to probe)
	 */
	return 0;
}

void
ahb_init(sc)
	struct ahb_softc *sc;
{

}

void
ahbminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((AHB_NSEG - 1) << PGSHIFT))
		bp->b_bcount = ((AHB_NSEG - 1) << PGSHIFT);
	minphys(bp);
}

/*
 * start a scsi operation given the command and the data address.  Also needs
 * the unit, target and lu.
 */
void
ahb_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct ahb_softc *sc = sc_link->adapter_softc;
	struct ahb_ecb *ecb;
	struct ahb_dma_seg *sg;
	int seg;		/* scatter gather seg being worked on */
	u_long thiskv, thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
	int s;

	SC_DEBUG(sc_link, SDEV_DB2, ("ahb_scsi_cmd\n"));
	/*
	 * get a ecb (mbox-out) to use. If the transfer
	 * is from a buf (possibly from interrupt time)
	 * then we can't allow it to sleep
	 */
	flags = xs->flags;
	ecb = xs->io;
	ecb->flags = ECB_ACTIVE;
	ecb->xs = xs;
	timeout_set(&ecb->xs->stimeout, ahb_timeout, ecb);

	/*
	 * If it's a reset, we need to do an 'immediate'
	 * command, and store its ecb for later
	 * if there is already an immediate waiting,
	 * then WE must wait
	 */
	if (flags & SCSI_RESET) {
		ecb->flags |= ECB_IMMED;
		if (sc->immed_ecb) {
			xs->error = XS_BUSY;
			scsi_done(xs);
			return;
		}
		sc->immed_ecb = ecb;

		s = splbio();

		ahb_send_immed(sc, sc_link->target, AHB_TARG_RESET);

		if ((flags & SCSI_POLL) == 0) {
			splx(s);
			timeout_add_msec(&ecb->xs->stimeout, xs->timeout);
			return;
		}

		splx(s);

		/*
		 * If we can't use interrupts, poll on completion
		 */
		if (ahb_poll(sc, xs, xs->timeout))
			ahb_timeout(ecb);
		return;
	}

	/*
	 * Put all the arguments for the xfer in the ecb
	 */
	ecb->opcode = ECB_SCSI_OP;
	ecb->opt1 = ECB_SES | ECB_DSB | ECB_ARS;
	if (xs->datalen)
		ecb->opt1 |= ECB_S_G;
	ecb->opt2 = sc_link->lun | ECB_NRB;
	ecb->scsi_cmd_length = xs->cmdlen;
	ecb->sense_ptr = KVTOPHYS(&ecb->ecb_sense);
	ecb->req_sense_length = sizeof(ecb->ecb_sense);
	ecb->status = KVTOPHYS(&ecb->ecb_status);
	ecb->ecb_status.host_stat = 0x00;
	ecb->ecb_status.target_stat = 0x00;

	if (xs->datalen && (flags & SCSI_RESET) == 0) {
		ecb->data_addr = KVTOPHYS(ecb->ahb_dma);
		sg = ecb->ahb_dma;
		seg = 0;

		/*
		 * Set up the scatter gather block
		 */
		SC_DEBUG(sc_link, SDEV_DB4,
		    ("%d @@0x%x:- ", xs->datalen, xs->data));
		datalen = xs->datalen;
		thiskv = (long) xs->data;
		thisphys = KVTOPHYS(thiskv);

		while (datalen && seg < AHB_NSEG) {
			bytes_this_seg = 0;

			/* put in the base address */
			sg->seg_addr = thisphys;

			SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

			/* do it at least once */
			nextphys = thisphys;
			while (datalen && thisphys == nextphys) {
				/*
				 * This page is contiguous (physically)
				 * with the last, just extend the
				 * length
				 */
				/* how far to the end of the page */
				nextphys = (thisphys & ~PGOFSET) + NBPG;
				bytes_this_page = nextphys - thisphys;
				/**** or the data ****/
				bytes_this_page = min(bytes_this_page,
						      datalen);
				bytes_this_seg += bytes_this_page;
				datalen -= bytes_this_page;

				/* get more ready for the next page */
				thiskv = (thiskv & ~PGOFSET) + NBPG;
				if (datalen)
					thisphys = KVTOPHYS(thiskv);
			}
			/*
			 * next page isn't contiguous, finish the seg
			 */
			SC_DEBUGN(sc_link, SDEV_DB4,
			    ("(0x%x)", bytes_this_seg));
			sg->seg_len = bytes_this_seg;
			sg++;
			seg++;
		}

		ecb->data_length = seg * sizeof(struct ahb_dma_seg);
		SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: ahb_scsi_cmd, more than %d dma segs\n",
			    sc->sc_dev.dv_xname, AHB_NSEG);
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}
	} else {	/* No data xfer, use non S/G values */
		ecb->data_addr = (physaddr)0;
		ecb->data_length = 0;
	}
	ecb->link_addr = (physaddr)0;

	/*
	 * Put the scsi command in the ecb and start it
	 */
	if ((flags & SCSI_RESET) == 0)
		bcopy(xs->cmd, &ecb->scsi_cmd, ecb->scsi_cmd_length);

	s = splbio();

	ahb_send_mbox(sc, OP_START_ECB, ecb);

	/*
	 * Usually return SUCCESSFULLY QUEUED
	 */
	if ((flags & SCSI_POLL) == 0) {
		splx(s);
		timeout_add_msec(&ecb->xs->stimeout, xs->timeout);
		return;
	}

	splx(s);

	/*
	 * If we can't use interrupts, poll on completion
	 */
	if (ahb_poll(sc, xs, xs->timeout)) {
		ahb_timeout(ecb);
		if (ahb_poll(sc, xs, 2000))
			ahb_timeout(ecb);
	}
}

void
ahb_timeout(arg)
	void *arg;
{
	struct ahb_ecb *ecb = arg;
	struct scsi_xfer *xs = ecb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct ahb_softc *sc = sc_link->adapter_softc;
	int s;

	sc_print_addr(sc_link);
	printf("timed out");

	s = splbio();

	if (ecb->flags & ECB_IMMED) {
		printf("\n");
		ecb->xs->retries = 0;	/* I MEAN IT ! */
		ecb->flags |= ECB_IMMED_FAIL;
		ahb_done(sc, ecb);
		splx(s);
		return;
	}

	/*
	 * If it has been through before, then
	 * a previous abort has failed, don't
	 * try abort again
	 */
	if (ecb->flags == ECB_ABORTED) {
		/* abort timed out */
		printf(" AGAIN\n");
		ecb->xs->retries = 0;	/* I MEAN IT ! */
		ahb_done(sc, ecb);
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		ecb->xs->error = XS_TIMEOUT;
		ecb->flags = ECB_ABORTED;
		ahb_send_mbox(sc, OP_ABORT_ECB, ecb);
		/* 2 secs for the abort */
		if ((xs->flags & SCSI_POLL) == 0)
			timeout_add_sec(&ecb->xs->stimeout, 2);
	}

	splx(s);
}

#ifdef	AHBDEBUG
void
ahb_print_ecb(ecb)
	struct ahb_ecb *ecb;
{
	printf("ecb:%x op:%x cmdlen:%d senlen:%d\n",
		ecb, ecb->opcode, ecb->cdblen, ecb->senselen);
	printf("	datlen:%d hstat:%x tstat:%x flags:%x\n",
		ecb->datalen, ecb->ecb_status.host_stat,
		ecb->ecb_status.target_stat, ecb->flags);
	show_scsi_cmd(ecb->xs);
}

void
ahb_print_active_ecb(sc)
	struct ahb_softc *sc;
{
	struct ahb_ecb *ecb;
	int i = 0;

	while (i++ < ECB_HASH_SIZE) {
		ecb = sc->ecb_hash_list[i];
		while (ecb) {
			if (ecb->flags != ECB_FREE)
				ahb_print_ecb(ecb);
			ecb = ecb->hash_list;
		}
	}
}
#endif /* AHBDEBUG */
@


1.43
log
@Iopoolification to eliminate another few instances of the current
shibboleth - NO_CCB. This in no way means this driver works.

ok gcc@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.42 2010/08/07 03:50:01 krw Exp $	*/
a58 1
#include <sys/proc.h>
@


1.42
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.41 2010/06/28 18:31:01 krw Exp $	*/
d269 1
a269 1
	struct ahb_ecb *immed_ecb;	/* an outstanding immediete command */
d275 2
d284 2
a285 2
void ahb_free_ecb(struct ahb_softc *, struct ahb_ecb *, int);
struct ahb_ecb *ahb_get_ecb(struct ahb_softc *, int);
d489 2
d499 1
d594 1
a594 1
			sc->immed_ecb = 0;
a681 1
	ahb_free_ecb(sc, ecb, xs->flags);
d686 1
a686 2
 * A ecb (and hence a mbx-out is put onto the
 * free list.
d689 2
a690 4
ahb_free_ecb(sc, ecb, flags)
	struct ahb_softc *sc;
	struct ahb_ecb *ecb;
	int flags;
d692 2
a693 1
	int s;
d695 1
a695 1
	s = splbio();
d697 1
a697 1
	ecb->flags = ECB_FREE;
d699 1
a699 9

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (TAILQ_NEXT(ecb, chain) == NULL)
		wakeup(&sc->free_ecb);

	splx(s);
a721 10
static inline void ahb_reset_ecb(struct ahb_softc *, struct ahb_ecb *);

static inline void
ahb_reset_ecb(sc, ecb)
	struct ahb_softc *sc;
	struct ahb_ecb *ecb;
{

}

a723 3
 *
 * If there are none, see if we can allocate a new one. If so, put it in the
 * hash table too otherwise either return an error or sleep.
d725 3
a727 4
struct ahb_ecb *
ahb_get_ecb(sc, flags)
	struct ahb_softc *sc;
	int flags;
d729 1
a730 1
	int s;
d732 5
a736 28
	s = splbio();

	/*
	 * If we can and have to, sleep waiting for one to come free
	 * but only if we can't allocate a new one.
	 */
	for (;;) {
		ecb = TAILQ_FIRST(&sc->free_ecb);
		if (ecb) {
			TAILQ_REMOVE(&sc->free_ecb, ecb, chain);
			break;
		}
		if (sc->numecbs < AHB_ECB_MAX) {
			ecb = (struct ahb_ecb *) malloc(sizeof(struct ahb_ecb),
			    M_TEMP, M_NOWAIT);
			if (ecb) {
				ahb_init_ecb(sc, ecb);
				sc->numecbs++;
			} else {
				printf("%s: can't malloc ecb\n",
				    sc->sc_dev.dv_xname);
				goto out;
			}
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;
		tsleep(&sc->free_ecb, PRIBIO, "ahbecb", 0);
d738 1
a739 5
	ahb_reset_ecb(sc, ecb);
	ecb->flags = ECB_ACTIVE;

out:
	splx(s);
d897 2
a898 5
	if ((ecb = ahb_get_ecb(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
d911 1
a911 1
			xs->error = XS_NO_CCB;
a1014 1
			ahb_free_ecb(sc, ecb, flags);
@


1.41
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.40 2010/06/26 23:24:44 guenther Exp $	*/
d342 1
a342 1
		panic("%s: board not responding\n", sc->sc_dev.dv_xname);
d400 1
a400 1
		panic("%s: board not responding\n", sc->sc_dev.dv_xname);
@


1.40
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.39 2010/05/20 00:55:17 krw Exp $	*/
a310 8
/* the below structure is so we have a default dev struct for our link struct */
struct scsi_device ahb_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

a493 1
	sc->sc_link.device = &ahb_dev;
@


1.39
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.38 2010/03/23 01:57:19 krw Exp $	*/
a59 1
#include <sys/user.h>
@


1.38
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.37 2010/01/10 00:40:25 krw Exp $	*/
a955 1
		s = splbio();
a956 1
		splx(s);
a971 1
			s = splbio();
a972 1
			splx(s);
a1075 1
			s = splbio();
a1076 1
			splx(s);
@


1.37
log
@A couple of missed ITSDONE setting before scsi_done().

seagate/trm/aha1742 were the only drivers paranoid enough to check
ITSDONE on getting the xs to execute. And optimistic enough to think
simply restting the flag would be a good thing. Have them chill out
like everyone else, reducing ITSDONE noise some more.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.36 2010/01/10 00:10:23 krw Exp $	*/
d289 1
a289 1
int ahb_scsi_cmd(struct scsi_xfer *);
d934 1
a934 1
int
d955 5
a959 1
		return (NO_CCB);
d972 7
a978 2
		if (sc->immed_ecb)
			return NO_CCB;
d988 1
a988 1
			return SUCCESSFULLY_QUEUED;
d998 1
a998 1
		return COMPLETE;
d1083 1
a1083 1
			return COMPLETE;
d1107 1
a1107 1
		return SUCCESSFULLY_QUEUED;
a1119 1
	return COMPLETE;
@


1.36
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.35 2009/11/22 14:14:10 krw Exp $	*/
a953 4
	if (flags & ITSDONE) {
		printf("%s: done?\n", sc->sc_dev.dv_xname);
		xs->flags &= ~ITSDONE;
	}
@


1.35
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.34 2009/09/05 11:28:54 dlg Exp $	*/
a686 1
	xs->flags |= ITSDONE;
@


1.34
log
@call scsi_done before returning COMPLETE
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.33 2009/08/29 13:58:51 jasper Exp $	*/
d974 1
a974 1
			return TRY_AGAIN_LATER;
@


1.33
log
@remove more unneeded Debugger() calls from dev/

agreed by deraadt@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.32 2009/03/29 21:53:52 sthen Exp $	*/
d1076 3
@


1.32
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.31 2009/02/16 21:19:06 miod Exp $	*/
a71 4
#ifndef DDB
#define Debugger() panic("should call debugger here (aha1742.c)")
#endif /* ! DDB */

d350 2
a351 4
	if (!wait) {
		printf("%s: board not responding\n", sc->sc_dev.dv_xname);
		Debugger();
	}
d408 2
a409 4
	if (!wait) {
		printf("%s: board not responding\n", sc->sc_dev.dv_xname);
		Debugger();
	}
@


1.31
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.30 2009/01/21 21:53:59 grange Exp $	*/
d497 1
a497 1
		panic("ahbattach: could not map I/O addresses");
@


1.30
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.29 2009/01/11 16:54:59 blambert Exp $	*/
d292 1
a292 1
void ahbminphys(struct buf *);
d932 1
a932 2
ahbminphys(bp)
	struct buf *bp;
a933 1

@


1.29
log
@Actual final round of timeout_add(to, n * hz) -> timeout_add_sec(to, n)
conversions.

ok kettenis@@
ok krw@@ (possibly for the second time :)
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.28 2008/11/25 17:52:02 krw Exp $	*/
d993 1
a993 1
			timeout_add(&ecb->xs->stimeout, (xs->timeout * hz) / 1000);
d1109 1
a1109 1
		timeout_add(&ecb->xs->stimeout, (xs->timeout * hz) / 1000);
@


1.28
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.27 2008/09/12 11:14:04 miod Exp $	*/
d1168 1
a1168 1
			timeout_add(&ecb->xs->stimeout, 2 * hz);
@


1.27
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.26 2007/11/05 17:12:41 krw Exp $	*/
d970 1
a970 1
		return TRY_AGAIN_LATER;
@


1.26
log
@More scsi_done() at SPLBIO. If you poll by manually calling the
interrupt function, wrap the call in splbio/splx!
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.25 2007/05/08 16:03:20 deraadt Exp $	*/
a955 3
#ifdef TFS
	struct iovec *iovp;
#endif
d1026 39
a1064 15
#ifdef	TFS
		if (flags & SCSI_DATA_UIO) {
			iovp = ((struct uio *) xs->data)->uio_iov;
			datalen = ((struct uio *) xs->data)->uio_iovcnt;
			xs->datalen = 0;
			while (datalen && seg < AHB_NSEG) {
				sg->seg_addr = (physaddr)iovp->iov_base;
				sg->seg_len = iovp->iov_len;
				xs->datalen += iovp->iov_len;
				SC_DEBUGN(sc_link, SDEV_DB4, ("(0x%x@@0x%x)",
				    iovp->iov_len, iovp->iov_base));
				sg++;
				iovp++;
				seg++;
				datalen--;
a1065 4
		}
		else
#endif /*TFS */
		{
d1067 1
a1067 1
			 * Set up the scatter gather block
d1069 5
a1073 45
			SC_DEBUG(sc_link, SDEV_DB4,
			    ("%d @@0x%x:- ", xs->datalen, xs->data));
			datalen = xs->datalen;
			thiskv = (long) xs->data;
			thisphys = KVTOPHYS(thiskv);

			while (datalen && seg < AHB_NSEG) {
				bytes_this_seg = 0;

				/* put in the base address */
				sg->seg_addr = thisphys;

				SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the last, just extend the
					 * length
					 */
					/* how far to the end of the page */
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = KVTOPHYS(thiskv);
				}
				/*
				 * next page isn't contiguous, finish the seg
				 */
				SC_DEBUGN(sc_link, SDEV_DB4,
				    ("(0x%x)", bytes_this_seg));
				sg->seg_len = bytes_this_seg;
				sg++;
				seg++;
			}
d1075 1
a1075 1
		/*end of iov/kv decision */
@


1.25
log
@ahb_debug should be inside #ifdef AHBDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.24 2007/04/10 17:47:55 miod Exp $	*/
d375 1
d382 2
a383 1
		if (bus_space_read_1(iot, ioh, G2STAT) & G2STAT_INT_PEND)
d385 2
@


1.24
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.23 2006/12/21 02:44:55 krw Exp $	*/
d300 2
d303 1
@


1.23
log
@'immediatly' -> 'immediately' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.22 2006/11/28 23:59:45 dlg Exp $	*/
d420 1
a420 1
 * If we find one, note it's address (slot) and call
@


1.22
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.21 2005/12/03 17:13:22 krw Exp $	*/
d123 1
a123 1
#define	B0uS	0x00		/* give up bus immediatly */
@


1.21
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.20 2005/02/17 18:07:36 jfb Exp $	*/
d478 1
d538 3
d544 1
a544 1
	config_found(self, &sc->sc_link, ahbprint);
@


1.20
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.19 2004/12/26 21:22:11 miod Exp $	*/
a961 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.19
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.18 2003/10/21 10:27:12 jmc Exp $	*/
d1061 1
a1061 1
					 * with the the last, just extend the
@


1.18
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.17 2002/03/14 01:26:53 millert Exp $	*/
d710 1
a710 1
	if (ecb->chain.tqe_next == 0)
d767 1
a767 1
		ecb = sc->free_ecb.tqh_first;
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.16 2001/08/26 00:45:08 fgsch Exp $	*/
d567 1
a567 1
		 * acknowlege the interrupt
@


1.16
log
@remove useless INUSE references from scsi_xfer->flags; art@@ miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.15 2001/02/03 07:24:49 mickey Exp $	*/
d282 16
a297 16
void ahb_send_mbox __P((struct ahb_softc *, int, struct ahb_ecb *));
int ahb_poll __P((struct ahb_softc *, struct scsi_xfer *, int));
void ahb_send_immed __P((struct ahb_softc *, int, u_long));
int ahbintr __P((void *));
void ahb_done __P((struct ahb_softc *, struct ahb_ecb *));
void ahb_free_ecb __P((struct ahb_softc *, struct ahb_ecb *, int));
struct ahb_ecb *ahb_get_ecb __P((struct ahb_softc *, int));
struct ahb_ecb *ahb_ecb_phys_kv __P((struct ahb_softc *, physaddr));
int ahb_find __P((bus_space_tag_t, bus_space_handle_t, struct ahb_softc *));
void ahb_init __P((struct ahb_softc *));
void ahbminphys __P((struct buf *));
int ahb_scsi_cmd __P((struct scsi_xfer *));
void ahb_timeout __P((void *));
void ahb_print_ecb __P((struct ahb_ecb *));
void ahb_print_active_ecb __P((struct ahb_softc *));
int ahbprint __P((void *, const char *));
d321 2
a322 2
int	ahbmatch __P((struct device *, void *, void *));
void	ahbattach __P((struct device *, struct device *, void *));
d716 1
a716 1
static inline void ahb_init_ecb __P((struct ahb_softc *, struct ahb_ecb *));
d736 1
a736 1
static inline void ahb_reset_ecb __P((struct ahb_softc *, struct ahb_ecb *));
@


1.16.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.16 2001/08/26 00:45:08 fgsch Exp $	*/
d282 16
a297 16
void ahb_send_mbox(struct ahb_softc *, int, struct ahb_ecb *);
int ahb_poll(struct ahb_softc *, struct scsi_xfer *, int);
void ahb_send_immed(struct ahb_softc *, int, u_long);
int ahbintr(void *);
void ahb_done(struct ahb_softc *, struct ahb_ecb *);
void ahb_free_ecb(struct ahb_softc *, struct ahb_ecb *, int);
struct ahb_ecb *ahb_get_ecb(struct ahb_softc *, int);
struct ahb_ecb *ahb_ecb_phys_kv(struct ahb_softc *, physaddr);
int ahb_find(bus_space_tag_t, bus_space_handle_t, struct ahb_softc *);
void ahb_init(struct ahb_softc *);
void ahbminphys(struct buf *);
int ahb_scsi_cmd(struct scsi_xfer *);
void ahb_timeout(void *);
void ahb_print_ecb(struct ahb_ecb *);
void ahb_print_active_ecb(struct ahb_softc *);
int ahbprint(void *, const char *);
d321 2
a322 2
int	ahbmatch(struct device *, void *, void *);
void	ahbattach(struct device *, struct device *, void *);
d716 1
a716 1
static inline void ahb_init_ecb(struct ahb_softc *, struct ahb_ecb *);
d736 1
a736 1
static inline void ahb_reset_ecb(struct ahb_softc *, struct ahb_ecb *);
@


1.15
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.14 1996/11/28 23:27:36 niklas Exp $	*/
a639 4
	if ((xs->flags & INUSE) == 0) {
		printf("%s: exiting but not in use!\n", sc->sc_dev.dv_xname);
		Debugger();
	}
d957 2
a958 2
	if ((flags & (ITSDONE|INUSE)) != INUSE) {
		printf("%s: done or not in use?\n", sc->sc_dev.dv_xname);
a959 1
		xs->flags |= INUSE;
@


1.14
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.13 1996/11/23 21:46:30 kstailey Exp $	*/
d79 1
a79 1
#define KVTOPHYS(x)	vtophys(x)
d216 1
a216 1
	        u_char:4;
d218 1
a218 1
	        u_char:1;
d612 1
a612 1
			untimeout(ahb_timeout, ecb);
d971 1
a989 1
			timeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);
d991 1
a1125 1
		timeout(ahb_timeout, ecb, (xs->timeout * hz) / 1000);
d1127 1
d1186 1
a1186 1
			timeout(ahb_timeout, ecb, 2 * hz);
@


1.14.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.15 2001/02/03 07:24:49 mickey Exp $	*/
d79 1
a79 1
#define KVTOPHYS(x)	kvtop((caddr_t)x)
d216 1
a216 1
		u_char:4;
d218 1
a218 1
		u_char:1;
d612 1
a612 1
			timeout_del(&ecb->xs->stimeout);
a970 1
	timeout_set(&ecb->xs->stimeout, ahb_timeout, ecb);
d989 1
a990 1
			timeout_add(&ecb->xs->stimeout, (xs->timeout * hz) / 1000);
d1125 1
a1126 1
		timeout_add(&ecb->xs->stimeout, (xs->timeout * hz) / 1000);
d1185 1
a1185 1
			timeout_add(&ecb->xs->stimeout, 2 * hz);
@


1.14.14.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.14.14.1 2001/05/14 22:23:14 niklas Exp $	*/
d640 4
d961 2
a962 2
	if (flags & ITSDONE) {
		printf("%s: done?\n", sc->sc_dev.dv_xname);
d964 1
@


1.14.14.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d282 16
a297 16
void ahb_send_mbox(struct ahb_softc *, int, struct ahb_ecb *);
int ahb_poll(struct ahb_softc *, struct scsi_xfer *, int);
void ahb_send_immed(struct ahb_softc *, int, u_long);
int ahbintr(void *);
void ahb_done(struct ahb_softc *, struct ahb_ecb *);
void ahb_free_ecb(struct ahb_softc *, struct ahb_ecb *, int);
struct ahb_ecb *ahb_get_ecb(struct ahb_softc *, int);
struct ahb_ecb *ahb_ecb_phys_kv(struct ahb_softc *, physaddr);
int ahb_find(bus_space_tag_t, bus_space_handle_t, struct ahb_softc *);
void ahb_init(struct ahb_softc *);
void ahbminphys(struct buf *);
int ahb_scsi_cmd(struct scsi_xfer *);
void ahb_timeout(void *);
void ahb_print_ecb(struct ahb_ecb *);
void ahb_print_active_ecb(struct ahb_softc *);
int ahbprint(void *, const char *);
d321 2
a322 2
int	ahbmatch(struct device *, void *, void *);
void	ahbattach(struct device *, struct device *, void *);
d716 1
a716 1
static inline void ahb_init_ecb(struct ahb_softc *, struct ahb_ecb *);
d736 1
a736 1
static inline void ahb_reset_ecb(struct ahb_softc *, struct ahb_ecb *);
@


1.14.14.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d567 1
a567 1
		 * acknowledge the interrupt
@


1.13
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.12 1996/11/12 20:30:07 niklas Exp $	*/
d62 1
a62 1
#include <machine/bus.old.h>
d267 1
a267 1
	bus_chipset_tag_t sc_bc;
d270 1
a270 1
	bus_io_handle_t sc_ioh;
d290 1
a290 1
int ahb_find __P((bus_chipset_tag_t, bus_io_handle_t, struct ahb_softc *));
d341 2
a342 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d346 2
a347 2
		if ((bus_io_read_1(bc, ioh, G2STAT) & (G2STAT_BUSY | G2STAT_MBOX_EMPTY))
		    == (G2STAT_MBOX_EMPTY))
d356 3
a358 2
	bus_io_write_4(bc, ioh, MBOXOUT0, KVTOPHYS(ecb)); /* don't know this will work */
	bus_io_write_1(bc, ioh, ATTN, opcode | ecb->xs->sc_link->target);
d370 2
a371 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d378 1
a378 1
		if (bus_io_read_1(bc, ioh, G2STAT) & G2STAT_INT_PEND)
d397 2
a398 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d402 2
a403 2
		if ((bus_io_read_1(bc, ioh, G2STAT) & (G2STAT_BUSY | G2STAT_MBOX_EMPTY))
		    == (G2STAT_MBOX_EMPTY))
d412 4
a415 3
	bus_io_write_4(bc, ioh, MBOXOUT0, cmd);	/* don't know this will work */
	bus_io_write_1(bc, ioh, G2CNTRL, G2CNTRL_SET_HOST_READY);
	bus_io_write_1(bc, ioh, ATTN, OP_IMMED | target);
d429 2
a430 2
	bus_chipset_tag_t bc = ea->ea_bc;
	bus_io_handle_t ioh;
d440 2
a441 1
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, &ioh))
d446 1
a446 1
	bus_io_write_1(bc, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);
d448 1
a448 1
	bus_io_write_1(bc, ioh, EISA_CONTROL, EISA_ENABLE);
d453 1
a453 1
	rv = !ahb_find(bc, ioh, NULL);
d455 1
a455 1
	bus_io_unmap(ea->ea_bc, ioh, EISA_SLOT_SIZE);
d478 2
a479 2
	bus_chipset_tag_t bc = ea->ea_bc;
	bus_io_handle_t ioh;
d484 1
a484 1
	sc->sc_bc = bc;
d487 2
a488 1
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, &ioh))
d491 1
a491 1
	if (ahb_find(bc, ioh, sc))
d551 2
a552 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d561 1
a561 1
	if ((bus_io_read_1(bc, ioh, G2STAT) & G2STAT_INT_PEND) == 0)
d569 3
a571 3
		ahbstat = bus_io_read_1(bc, ioh, G2INTST);
		mboxval = bus_io_read_4(bc, ioh, MBOXIN0);
		bus_io_write_1(bc, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);
d616 2
a617 1
		if ((bus_io_read_1(bc, ioh, G2STAT) & G2STAT_INT_PEND) == 0)
d825 3
a827 3
ahb_find(bc, ioh, sc)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d834 1
a834 1
	bus_io_write_1(bc, ioh, PORTADDR, PORTADDR_ENHANCED);
d842 1
a842 1
	bus_io_write_1(bc, ioh, G2CNTRL, G2CNTRL_HARD_RESET);
d844 1
a844 1
	bus_io_write_1(bc, ioh, G2CNTRL, 0);
d847 1
a847 1
		if ((bus_io_read_1(bc, ioh, G2STAT) & G2STAT_BUSY) == 0)
d858 1
a858 1
	i = bus_io_read_1(bc, ioh, MBOXIN0);
d865 1
a865 1
	bus_io_write_1(bc, ioh, PORTADDR, PORTADDR_ENHANCED);
d868 1
a868 1
	while (bus_io_read_1(bc, ioh, G2STAT) & G2STAT_INT_PEND) {
d870 1
a870 1
		bus_io_write_1(bc, ioh, G2CNTRL, G2CNTRL_CLEAR_EISA_INT);
d874 1
a874 1
	intdef = bus_io_read_1(bc, ioh, INTDEF);
d899 2
a900 1
	bus_io_write_1(bc, ioh, INTDEF, (intdef | INTEN));	/* make sure we can interrupt */
d903 1
a903 1
	busid = (bus_io_read_1(bc, ioh, SCSIDEF) & HSCSIID);
@


1.12
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.11 1996/10/16 12:38:05 deraadt Exp $	*/
d297 1
a297 1
int ahbprint __P((void *, char *));
d460 1
a460 1
	char *name;
@


1.11
log
@-Wall happiness
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.10 1996/06/02 10:42:58 tholo Exp $	*/
d62 1
a62 1
#include <machine/bus.h>
@


1.10
log
@Correct attach output
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.9 1996/05/26 00:26:52 deraadt Exp $	*/
d297 1
a299 1
static  ahb_slot = 0;		/* slot last board was found in */
d457 4
a460 1
ahbprint()
d462 1
a462 1

d715 2
d735 2
d772 3
a774 2
			if (ecb = (struct ahb_ecb *) malloc(sizeof(struct ahb_ecb),
			    M_TEMP, M_NOWAIT)) {
d943 1
d945 1
@


1.9
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1742.c,v 1.8 1996/05/10 12:34:20 deraadt Exp $	*/
d509 1
d528 1
a528 2
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
		    intrstr);
@


1.8
log
@rename softc
@
text
@d1 2
a2 2
/*	$OpenBSD: aha1742.c,v 1.4 1996/04/18 23:47:09 niklas Exp $	*/
/*	$NetBSD: aha1742.c,v 1.60 1996/05/05 03:12:47 mycroft Exp $	*/
d63 1
@


1.7
log
@more verbose interrupt handling?
@
text
@d2 1
a2 1
/*	$NetBSD: aha1742.c,v 1.59 1996/04/09 22:47:00 cgd Exp $	*/
d335 2
a336 2
ahb_send_mbox(ahb, opcode, ecb)
	struct ahb_softc *ahb;
d340 2
a341 2
	bus_chipset_tag_t bc = ahb->sc_bc;
	bus_io_handle_t ioh = ahb->sc_ioh;
d351 1
a351 1
		printf("%s: board not responding\n", ahb->sc_dev.dv_xname);
d363 2
a364 2
ahb_poll(ahb, xs, count)
	struct ahb_softc *ahb;
d368 2
a369 2
	bus_chipset_tag_t bc = ahb->sc_bc;
	bus_io_handle_t ioh = ahb->sc_ioh;
d377 1
a377 1
			ahbintr(ahb);
d390 2
a391 2
ahb_send_immed(ahb, target, cmd)
	struct ahb_softc *ahb;
d395 2
a396 2
	bus_chipset_tag_t bc = ahb->sc_bc;
	bus_io_handle_t ioh = ahb->sc_ioh;
d406 1
a406 1
		printf("%s: board not responding\n", ahb->sc_dev.dv_xname);
d470 1
a470 1
	struct ahb_softc *ahb = (void *)self;
d477 2
a478 2
	ahb->sc_bc = bc;
	ahb->sc_ec = ec;
d482 2
a483 2
	ahb->sc_ioh = ioh;
	if (ahb_find(bc, ioh, ahb))
d486 2
a487 2
	ahb_init(ahb);
	TAILQ_INIT(&ahb->free_ecb);
d492 5
a496 5
	ahb->sc_link.adapter_softc = ahb;
	ahb->sc_link.adapter_target = ahb->ahb_scsi_dev;
	ahb->sc_link.adapter = &ahb_switch;
	ahb->sc_link.device = &ahb_dev;
	ahb->sc_link.openings = 2;
a507 1
	printf(": %s\n", model);
d509 1
a509 1
	if (eisa_intr_map(ec, ahb->sc_irq, &ih)) {
d511 1
a511 1
		    ahb->sc_dev.dv_xname, ahb->sc_irq);
d515 3
a517 3
	ahb->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,
	    ahbintr, ahb, ahb->sc_dev.dv_xname);
	if (ahb->sc_ih == NULL) {
d519 1
a519 1
		    ahb->sc_dev.dv_xname);
d526 1
a526 1
		printf("%s: interrupting at %s\n", ahb->sc_dev.dv_xname,
d532 1
a532 1
	config_found(self, &ahb->sc_link, ahbprint);
d542 3
a544 3
	struct ahb_softc *ahb = arg;
	bus_chipset_tag_t bc = ahb->sc_bc;
	bus_io_handle_t ioh = ahb->sc_ioh;
d550 1
a550 1
	printf("%s: ahbintr ", ahb->sc_dev.dv_xname);
d576 1
a576 1
			ecb = ahb_ecb_phys_kv(ahb, mboxval);
d579 1
a579 1
				    ahb->sc_dev.dv_xname);
d587 2
a588 2
			ecb = ahb->immed_ecb;
			ahb->immed_ecb = 0;
d593 1
a593 1
			    ahb->sc_dev.dv_xname, ahbstat);
d605 1
a605 1
			ahb_done(ahb, ecb);
d618 2
a619 2
ahb_done(ahb, ecb)
	struct ahb_softc *ahb;
d632 1
a632 1
		printf("%s: exiting but not in use!\n", ahb->sc_dev.dv_xname);
d656 1
a656 1
				    ahb->sc_dev.dv_xname, stat->host_stat);
d672 1
a672 1
				    ahb->sc_dev.dv_xname, stat->target_stat);
d680 1
a680 1
	ahb_free_ecb(ahb, ecb, xs->flags);
d689 2
a690 2
ahb_free_ecb(ahb, ecb, flags)
	struct ahb_softc *ahb;
d699 1
a699 1
	TAILQ_INSERT_HEAD(&ahb->free_ecb, ecb, chain);
d706 1
a706 1
		wakeup(&ahb->free_ecb);
d712 2
a713 2
ahb_init_ecb(ahb, ecb)
	struct ahb_softc *ahb;
d725 2
a726 2
	ecb->nexthash = ahb->ecbhash[hashnum];
	ahb->ecbhash[hashnum] = ecb;
d730 2
a731 2
ahb_reset_ecb(ahb, ecb)
	struct ahb_softc *ahb;
d744 2
a745 2
ahb_get_ecb(ahb, flags)
	struct ahb_softc *ahb;
d758 1
a758 1
		ecb = ahb->free_ecb.tqh_first;
d760 1
a760 1
			TAILQ_REMOVE(&ahb->free_ecb, ecb, chain);
d763 1
a763 1
		if (ahb->numecbs < AHB_ECB_MAX) {
d766 2
a767 2
				ahb_init_ecb(ahb, ecb);
				ahb->numecbs++;
d770 1
a770 1
				    ahb->sc_dev.dv_xname);
d777 1
a777 1
		tsleep(&ahb->free_ecb, PRIBIO, "ahbecb", 0);
d780 1
a780 1
	ahb_reset_ecb(ahb, ecb);
d792 2
a793 2
ahb_ecb_phys_kv(ahb, ecb_phys)
	struct ahb_softc *ahb;
d797 1
a797 1
	struct ahb_ecb *ecb = ahb->ecbhash[hashnum];
d811 1
a811 1
ahb_find(bc, ioh, ahb)
d814 1
a814 1
	struct ahb_softc *ahb;
d891 3
a893 3
	if (ahb != NULL) {
		ahb->sc_irq = irq;
		ahb->ahb_scsi_dev = busid;
d903 2
a904 2
ahb_init(ahb)
	struct ahb_softc *ahb;
d928 1
a928 1
	struct ahb_softc *ahb = sc_link->adapter_softc;
d945 1
a945 1
		printf("%s: done or not in use?\n", ahb->sc_dev.dv_xname);
d949 1
a949 1
	if ((ecb = ahb_get_ecb(ahb, flags)) == NULL) {
d963 1
a963 1
		if (ahb->immed_ecb)
d965 1
a965 1
		ahb->immed_ecb = ecb;
d969 1
a969 1
		ahb_send_immed(ahb, sc_link->target, AHB_TARG_RESET);
d982 1
a982 1
		if (ahb_poll(ahb, xs, xs->timeout))
d1083 1
a1083 1
			    ahb->sc_dev.dv_xname, AHB_NSEG);
d1085 1
a1085 1
			ahb_free_ecb(ahb, ecb, flags);
d1102 1
a1102 1
	ahb_send_mbox(ahb, OP_START_ECB, ecb);
d1118 1
a1118 1
	if (ahb_poll(ahb, xs, xs->timeout)) {
d1120 1
a1120 1
		if (ahb_poll(ahb, xs, 2000))
d1133 1
a1133 1
	struct ahb_softc *ahb = sc_link->adapter_softc;
d1145 1
a1145 1
		ahb_done(ahb, ecb);
d1159 1
a1159 1
		ahb_done(ahb, ecb);
d1165 1
a1165 1
		ahb_send_mbox(ahb, OP_ABORT_ECB, ecb);
d1188 2
a1189 2
ahb_print_active_ecb(ahb)
	struct ahb_softc *ahb;
d1195 1
a1195 1
		ecb = ahb->ecb_hash_list[i];
@


1.6
log
@Make this compile; was missing new first argument
@
text
@d508 1
a508 1
	printf(" irq %d: %s\n", ahb->sc_irq, model);
d510 7
a516 4
#ifdef NEWCONFIG
	isa_establish(&ahb->sc_id, &ahb->sc_dev);
#endif
	ahb->sc_ih = eisa_intr_establish(NULL, ahb->sc_irq, IST_LEVEL, IPL_BIO,
d518 11
@


1.5
log
@partial sync with netbsd 960418, more to come
@
text
@d513 1
a513 1
	ahb->sc_ih = eisa_intr_establish(ahb->sc_irq, IST_LEVEL, IPL_BIO,
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: aha1742.c,v 1.57 1996/03/08 22:03:26 cgd Exp $	*/
a265 2
	struct isadev sc_id;
	void *sc_ih;
d267 2
a269 1

d271 1
d323 6
a328 2
struct cfdriver ahbcd = {
	NULL, "ahb", ahbmatch, ahbattach, DV_DULL, sizeof(struct ahb_softc)
d473 3
a475 1
	char *model;
d478 2
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: aha1742.c,v 1.52 1995/10/04 00:35:10 mycroft Exp $	*/
d62 1
a62 1
#include <machine/pio.h>
d66 1
d268 2
a270 1
	int sc_iobase;
d289 1
a289 1
int ahb_find __P((struct ahb_softc *));
d320 2
a321 3
int ahbprobe();
int ahbprobe1 __P((struct ahb_softc *, struct isa_attach_args *));
void ahbattach();
d324 1
a324 1
	NULL, "ahb", ahbprobe, ahbattach, DV_DULL, sizeof(struct ahb_softc)
d336 2
a337 2
	int iobase = ahb->sc_iobase;
	int stport = iobase + G2STAT;
d341 1
a341 1
		if ((inb(stport) & (G2STAT_BUSY | G2STAT_MBOX_EMPTY))
d351 2
a352 2
	outl(iobase + MBOXOUT0, KVTOPHYS(ecb));	/* don't know this will work */
	outb(iobase + ATTN, opcode | ecb->xs->sc_link->target);
d364 2
a365 2
	int iobase = ahb->sc_iobase;
	int stport = iobase + G2STAT;
d372 1
a372 1
		if (inb(stport) & G2STAT_INT_PEND)
d391 2
a392 2
	int iobase = ahb->sc_iobase;
	int stport = iobase + G2STAT;
d396 1
a396 1
		if ((inb(stport) & (G2STAT_BUSY | G2STAT_MBOX_EMPTY))
d406 3
a408 3
	outl(iobase + MBOXOUT0, cmd);	/* don't know this will work */
	outb(iobase + G2CNTRL, G2CNTRL_SET_HOST_READY);
	outb(iobase + ATTN, OP_IMMED | target);
d417 15
a431 8
ahbprobe(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ahb_softc *ahb = (void *)self;
	struct isa_attach_args *ia = aux;
	int iobase;
	u_short vendor, model;
d433 2
a434 21
#ifdef NEWCONFIG
	if (ia->ia_iobase != IOBASEUNK)
		return ahbprobe1(ahb, ia);
#endif

	while (ahb_slot < MAX_SLOTS) {
		ahb_slot++;
		iobase = 0x1000 * ahb_slot;

		vendor = htons(inw(iobase + EISA_VENDOR));
		if (vendor != 0x0490)	/* `ADP' */
			continue;

		model = htons(inw(iobase + EISA_MODEL));
		if ((model & 0xfff0) != 0x0000 &&
		    (model & 0xfff0) != 0x0100) {
#ifndef trusted
			printf("ahbprobe: ignoring model %04x\n", model);
#endif
			continue;
		}
d437 6
a442 5
		outb(iobase + EISA_CONTROL, EISA_ENABLE | EISA_RESET);
		delay(10);
		outb(iobase + EISA_CONTROL, EISA_ENABLE);
		/* Wait for reset? */
		delay(1000);
d445 1
a445 28
		ia->ia_iobase = iobase;
		if (ahbprobe1(ahb, ia))
			return 1;
	}

	return 0;
}

/*
 * Check if the device can be found at the port given
 * and if so, set it up ready for further work
 * as an argument, takes the isa_device structure from
 * autoconf.c.
 */
int
ahbprobe1(ahb, ia)
	struct ahb_softc *ahb;
	struct isa_attach_args *ia;
{

	ahb->sc_iobase = ia->ia_iobase;

	/*
	 * Try initialise a unit at this location
	 * sets up dma and bus speed, loads ahb->sc_irq
	 */
	if (ahb_find(ahb) != 0)
		return 0;
d447 1
a447 8
	if (ia->ia_irq != IRQUNK) {
		if (ia->ia_irq != ahb->sc_irq) {
			printf("%s: irq mismatch; kernel configured %d != board configured %d\n",
			    ahb->sc_dev.dv_xname, ia->ia_irq, ahb->sc_irq);
			return 0;
		}
	} else
		ia->ia_irq = ahb->sc_irq;
d449 1
a449 4
	ia->ia_drq = DRQUNK;
	ia->ia_msize = 0;
	ia->ia_iosize = 0x1000;
	return 1;
d465 1
a465 1
	struct isa_attach_args *ia = aux;
d467 10
a476 1
	u_short model;
d490 11
a500 11
	printf(": ");
	model = htons(inw(ahb->sc_iobase + EISA_MODEL));
	switch (model & 0xfff0) {
	case 0x0000:
		printf("model 1740 or 1742");
		break;
	case 0x0100:
		printf("model 1744");
		break;
	}
	printf(", revision %d\n", model & 0x000f);
d505 1
a505 1
	ahb->sc_ih = eisa_intr_establish(ia->ia_irq, IST_LEVEL, IPL_BIO,
d522 2
a526 1
	int iobase = ahb->sc_iobase;
d532 1
a532 1
	if ((inb(iobase + G2STAT) & G2STAT_INT_PEND) == 0)
d540 3
a542 3
		ahbstat = inb(iobase + G2INTST);
		mboxval = inl(iobase + MBOXIN0);
		outb(iobase + G2CNTRL, G2CNTRL_CLEAR_EISA_INT);
d587 1
a587 1
		if ((inb(iobase + G2STAT) & G2STAT_INT_PEND) == 0)
d790 3
a792 1
ahb_find(ahb)
a794 2
	int iobase = ahb->sc_iobase;
	int stport = iobase + G2STAT;
d796 1
a796 1
	int i;
d799 1
a799 1
	outb(iobase + PORTADDR, PORTADDR_ENHANCED);
d807 1
a807 1
	outb(iobase + G2CNTRL, G2CNTRL_HARD_RESET);
d809 1
a809 1
	outb(iobase + G2CNTRL, 0);
d812 1
a812 1
		if ((inb(stport) & G2STAT_BUSY) == 0)
d817 1
a817 1
#ifdef	AHBDEBUG
d823 1
a823 1
	i = inb(iobase + MBOXIN0);
d830 1
a830 1
	outb(iobase + PORTADDR, PORTADDR_ENHANCED);
d833 1
a833 1
	while (inb(stport) & G2STAT_INT_PEND) {
d835 1
a835 1
		outb(iobase + G2CNTRL, G2CNTRL_CLEAR_EISA_INT);
d839 1
a839 1
	intdef = inb(iobase + INTDEF);
d842 1
a842 1
		ahb->sc_irq = 9;
d845 1
a845 1
		ahb->sc_irq = 10;
d848 1
a848 1
		ahb->sc_irq = 11;
d851 1
a851 1
		ahb->sc_irq = 12;
d854 1
a854 1
		ahb->sc_irq = 14;
d857 1
a857 1
		ahb->sc_irq = 15;
d864 1
a864 1
	outb(iobase + INTDEF, (intdef | INTEN));	/* make sure we can interrupt */
d867 7
a873 1
	ahb->ahb_scsi_dev = (inb(iobase + SCSIDEF) & HSCSIID);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d543 1
a543 1
	    ahbintr, ahb);
@


1.1
log
@Initial revision
@
text
@d542 2
a543 2
	ahb->sc_ih = eisa_intr_establish(ia->ia_irq, EISA_IST_LEVEL,
	    EISA_IPL_BIO, ahbintr, ahb);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
