head	1.26;
access;
symbols
	OPENBSD_6_2:1.26.0.10
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.6
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.23.0.6
	OPENBSD_5_6_BASE:1.23
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.22.0.30
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.28
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.26
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.24
	OPENBSD_5_0:1.22.0.22
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.20
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.18
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.14
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.22.0.16
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.12
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.10
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.8
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.6
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.4
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.2
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.4
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.2
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.17.0.6
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.8
	SMP_BASE:1.11
	kame_19991208:1.11
	OPENBSD_2_6:1.11.0.6
	OPENBSD_2_6_BASE:1.11
	OPENBSD_2_5:1.11.0.4
	OPENBSD_2_5_BASE:1.11
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5DvsamK0GblTp8ww;

1.24
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.23;
commitid	nYggAidK85QbUFh2;

1.23
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.22;

1.22
date	2006.06.17.17.58.39;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.30.21.44.07;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.39;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.29.19.35.13;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2003.01.10.17.07.09;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.18.20.30.23;	author jason;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2001.03.09.09.36.31;	author mickey;	state Exp;
branches;
next	1.13;

1.13
date	2000.05.29.18.04.08;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.03.13.20.39.49;	author maja;	state Exp;
branches;
next	1.11;

1.11
date	98.09.19.10.08.04;	author maja;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	98.09.11.19.00.30;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.02.26.06.47.44;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	97.07.30.11.12.25;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.28.23.27.41;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.30.11;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.05.26.00.26.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.07.07.35.36;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.05.13.38.10;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	96.05.03.07.59.30;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.02.13.38.04;	author deraadt;	state Exp;
branches;
next	;

1.11.8.1
date	2000.03.24.09.09.07;	author niklas;	state Exp;
branches;
next	1.11.8.2;

1.11.8.2
date	2001.05.14.22.23.17;	author niklas;	state Exp;
branches;
next	1.11.8.3;

1.11.8.3
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.11.8.4;

1.11.8.4
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.11.8.5;

1.11.8.5
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.11.8.6;

1.11.8.6
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_ep_eisa.c,v 1.25 2015/11/24 13:33:17 mpi Exp $	*/
/*	$NetBSD: if_ep_eisa.c,v 1.13 1997/04/18 00:50:33 cgd Exp $	*/

/*
 * Copyright (c) 1997 Jonathan Stone <jonathan@@NetBSD.org>
 * Copyright (c) 1994 Herb Peyerl <hpeyerl@@beer.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Herb Peyerl.
 * 4. The name of Herb Peyerl may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/elink3var.h>
#include <dev/ic/elink3reg.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>

int ep_eisa_match(struct device *, void *, void *);
void ep_eisa_attach(struct device *, struct device *, void *);

struct cfattach ep_eisa_ca = {
	sizeof(struct ep_softc), ep_eisa_match, ep_eisa_attach
};

/* XXX move these somewhere else */
#define EISA_CONTROL	0x0c84
#define EISA_RESET	0x04
#define EISA_ERROR	0x02
#define EISA_ENABLE	0x01

int
ep_eisa_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct eisa_attach_args *ea = aux;

	/* must match one of our known ID strings */
	if (strcmp(ea->ea_idstring, "TCM5090") &&
	    strcmp(ea->ea_idstring, "TCM5091") &&
	    strcmp(ea->ea_idstring, "TCM5092") &&
	    strcmp(ea->ea_idstring, "TCM5093") &&
	    strcmp(ea->ea_idstring, "TCM5094") &&
	    strcmp(ea->ea_idstring, "TCM5095") &&
	    strcmp(ea->ea_idstring, "TCM5098") &&
	    strcmp(ea->ea_idstring, "TCM5920") &&
	    strcmp(ea->ea_idstring, "TCM5970") &&
	    strcmp(ea->ea_idstring, "TCM5971") &&
	    strcmp(ea->ea_idstring, "TCM5972"))
		return (0);

	return (1);
}

void
ep_eisa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ep_softc *sc = (void *)self;
	struct eisa_attach_args *ea = aux;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	u_int16_t k;
	eisa_chipset_tag_t ec = ea->ea_ec;
	eisa_intr_handle_t ih;
	const char *model, *intrstr;
	int chipset;
	u_int irq;

	/* Map i/o space. */
	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot),
	    EISA_SLOT_SIZE, 0, &ioh))
		panic(": can't map i/o space");

	sc->bustype = EP_BUS_EISA;
	sc->sc_ioh = ioh;
	sc->sc_iot = iot;

	bus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE);
	delay(4000);

	/* XXX What is this doing?!  Reading the i/o address? */
	k = bus_space_read_2(iot, ioh, EP_W0_ADDRESS_CFG);
	k = (k & 0x1f) * 0x10 + 0x200;

	/* Read the IRQ from the card. */
	irq = bus_space_read_2(iot, ioh, EP_W0_RESOURCE_CFG) >> 12;

	chipset = EP_CHIPSET_3C509;	/* assume dumb chipset */
	if (strcmp(ea->ea_idstring, "TCM5090") == 0)
		model = EISA_PRODUCT_TCM5090;
	else if (strcmp(ea->ea_idstring, "TCM5091") == 0)
		model = EISA_PRODUCT_TCM5091;
	else if (strcmp(ea->ea_idstring, "TCM5092") == 0)
		model = EISA_PRODUCT_TCM5092;
	else if (strcmp(ea->ea_idstring, "TCM5093") == 0)
		model = EISA_PRODUCT_TCM5093;
	else if (strcmp(ea->ea_idstring, "TCM5094") == 0)
		model = EISA_PRODUCT_TCM5094;
	else if (strcmp(ea->ea_idstring, "TCM5095") == 0)
		model = EISA_PRODUCT_TCM5095;
	else if (strcmp(ea->ea_idstring, "TCM5098") == 0)
		model = EISA_PRODUCT_TCM5098;
	else if (strcmp(ea->ea_idstring, "TCM5920") == 0) {
		model = EISA_PRODUCT_TCM5920;
		chipset = EP_CHIPSET_VORTEX;
	} else if (strcmp(ea->ea_idstring, "TCM5970") == 0) {
		model = EISA_PRODUCT_TCM5970;
		chipset = EP_CHIPSET_VORTEX;
	} else if (strcmp(ea->ea_idstring, "TCM5971") == 0) {
		model = EISA_PRODUCT_TCM5971;
		chipset = EP_CHIPSET_VORTEX;
	} else if (strcmp(ea->ea_idstring, "TCM5972") == 0) {
		model = EISA_PRODUCT_TCM5972;
		chipset = EP_CHIPSET_VORTEX;
	} else
		model = "unknown model!";

	if (eisa_intr_map(ec, irq, &ih)) {
		printf(": couldn't map interrupt (%u)\n", irq);
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
		return;
	}
	intrstr = eisa_intr_string(ec, ih);
	sc->sc_ih = eisa_intr_establish(ec, ih, IST_EDGE, IPL_NET,
	    epintr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt");
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
		return;
	}

	printf(": %s,", model);
	if (intrstr != NULL)
		printf(" %s,", intrstr);

	epconfig(sc, chipset, NULL);
	/* XXX because epconfig() will not print a newline for vortex chips */
	if (chipset == EP_CHIPSET_VORTEX)
		printf("\n");
}
@


1.25
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.24 2014/08/11 12:45:45 mpi Exp $	*/
a48 2
#include <net/if_dl.h>
#include <net/netisr.h>
@


1.24
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.23 2013/08/07 01:06:27 bluhm Exp $	*/
a49 1
#include <net/if_types.h>
@


1.23
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.22 2006/06/17 17:58:39 brad Exp $	*/
a53 1
#ifdef INET
d55 1
a55 4
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>   
#endif
@


1.22
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.21 2006/05/30 21:44:07 miod Exp $	*/
a56 1
#include <netinet/in_var.h>     
@


1.21
log
@Do not reset the board, for it will not keep the interrupt configuration the
BIOS configured it in; from NetBSD via Andrew Daugherity.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.20 2005/11/21 18:16:39 millert Exp $	*/
d45 1
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.19 2004/10/29 19:35:13 miod Exp $	*/
d141 1
a141 2
	/* Reset card. */
	bus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);
a142 3
	bus_space_write_1(iot, ioh, EISA_CONTROL, EISA_ENABLE);
	/* Wait for reset? */
	delay(1000);
@


1.19
log
@Prettier dmesg on vortexes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.18 2004/05/12 06:35:10 tedu Exp $	*/
d44 1
a44 1
#include <sys/select.h>
@


1.18
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.17 2003/01/10 17:07:09 mickey Exp $	*/
d207 3
@


1.17
log
@now that epconfig() prints stuff another new way fix the dmesg print again. also reclaim resources on failures and etc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.16 2002/03/14 01:26:53 millert Exp $	*/
a62 1
#include <net/bpfdesc.h>
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.15 2001/09/18 20:30:23 jason Exp $	*/
d136 1
a136 1
		panic("ep_eisa_attach: can't map i/o space");
d174 1
a174 2
	}
	else if (strcmp(ea->ea_idstring, "TCM5970") == 0) {
d177 1
a177 2
	}
	else if (strcmp(ea->ea_idstring, "TCM5971") == 0) {
d180 1
a180 2
	}
	else if (strcmp(ea->ea_idstring, "TCM5972") == 0) {
d183 1
a183 2
	}
	else
a184 1
	printf(": %s", model);
d187 2
a188 1
		printf("couldn't map interrupt (%u)\n", irq);
d195 1
a195 1
		printf("couldn't establish interrupt");
d199 1
d203 4
a207 3

	if (intrstr != NULL)
		printf(" %s\n", intrstr);
@


1.15
log
@allow a little more time for reset and match TCM5098 (from NetBSD pr's
13947 and 13948).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.14 2001/03/09 09:36:31 mickey Exp $	*/
d80 2
a81 2
int ep_eisa_match __P((struct device *, void *, void *));
void ep_eisa_attach __P((struct device *, struct device *, void *));
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.15 2001/09/18 20:30:23 jason Exp $	*/
d80 2
a81 2
int ep_eisa_match(struct device *, void *, void *);
void ep_eisa_attach(struct device *, struct device *, void *);
@


1.15.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 1
a136 1
		panic(": can't map i/o space");
d174 2
a175 1
	} else if (strcmp(ea->ea_idstring, "TCM5970") == 0) {
d178 2
a179 1
	} else if (strcmp(ea->ea_idstring, "TCM5971") == 0) {
d182 2
a183 1
	} else if (strcmp(ea->ea_idstring, "TCM5972") == 0) {
d186 2
a187 1
	} else
d189 1
d192 1
a192 2
		printf(": couldn't map interrupt (%u)\n", irq);
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
d199 1
a199 1
		printf(": couldn't establish interrupt");
a202 1
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
d206 2
a207 1
	printf(": %s,", model);
d209 1
a209 3
		printf(" %s,", intrstr);

	epconfig(sc, chipset, NULL);
@


1.14
log
@proper irq printout (like other busses)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.13 2000/05/29 18:04:08 aaron Exp $	*/
d107 1
d144 1
a144 1
	delay(10);
d169 2
@


1.13
log
@Support for 3c574 and 3CCFEM556BI PCMCIA Ethernet; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.12 2000/03/13 20:39:49 maja Exp $	*/
a201 2
	if (intrstr != NULL)
		printf("%s ", intrstr);
d204 3
@


1.12
log
@Add support for more 3com cards. William Yodlowsky <wyodlows@@route1.nj.devry.edu> and me. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.11 1998/09/19 10:08:04 maja Exp $	*/
d69 3
@


1.11
log
@Added if_media support from NetBSD. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.10 1998/09/11 19:00:30 deraadt Exp $	*/
d98 2
a99 1
	if (strcmp(ea->ea_idstring, "TCM5091") &&
d102 2
d153 3
a155 1
	if (strcmp(ea->ea_idstring, "TCM5091") == 0)
d161 4
@


1.11.8.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
a98 2
	if (strcmp(ea->ea_idstring, "TCM5090") &&
	    strcmp(ea->ea_idstring, "TCM5091") &&
a100 2
	    strcmp(ea->ea_idstring, "TCM5094") &&
	    strcmp(ea->ea_idstring, "TCM5095") &&
d150 1
a150 3
	if (strcmp(ea->ea_idstring, "TCM5090") == 0)
		model = EISA_PRODUCT_TCM5090;
	else if (strcmp(ea->ea_idstring, "TCM5091") == 0)
a155 4
	else if (strcmp(ea->ea_idstring, "TCM5094") == 0)
		model = EISA_PRODUCT_TCM5094;
	else if (strcmp(ea->ea_idstring, "TCM5095") == 0)
		model = EISA_PRODUCT_TCM5095;
@


1.11.8.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.14 2001/03/09 09:36:31 mickey Exp $	*/
a69 3
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

d199 2
a202 3

	if (intrstr != NULL)
		printf(" %s\n", intrstr);
@


1.11.8.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.11.8.2 2001/05/14 22:23:17 niklas Exp $	*/
a106 1
	    strcmp(ea->ea_idstring, "TCM5098") &&
d143 1
a143 1
	delay(4000);
a167 2
	else if (strcmp(ea->ea_idstring, "TCM5098") == 0)
		model = EISA_PRODUCT_TCM5098;
@


1.11.8.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d80 2
a81 2
int ep_eisa_match(struct device *, void *, void *);
void ep_eisa_attach(struct device *, struct device *, void *);
@


1.11.8.5
log
@Sync the SMP branch with 3.3
@
text
@d136 1
a136 1
		panic(": can't map i/o space");
d174 2
a175 1
	} else if (strcmp(ea->ea_idstring, "TCM5970") == 0) {
d178 2
a179 1
	} else if (strcmp(ea->ea_idstring, "TCM5971") == 0) {
d182 2
a183 1
	} else if (strcmp(ea->ea_idstring, "TCM5972") == 0) {
d186 2
a187 1
	} else
d189 1
d192 1
a192 2
		printf(": couldn't map interrupt (%u)\n", irq);
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
d199 1
a199 1
		printf(": couldn't establish interrupt");
a202 1
		bus_space_unmap(iot, ioh, EISA_SLOT_SIZE);
d206 2
a207 1
	printf(": %s,", model);
d209 1
a209 3
		printf(" %s,", intrstr);

	epconfig(sc, chipset, NULL);
@


1.11.8.6
log
@Merge with the trunk
@
text
@d63 1
@


1.10
log
@change missed by fgsch, tsk tsk tsk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.9 1998/02/26 06:47:44 deraadt Exp $	*/
d51 1
@


1.9
log
@clean dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.8 1997/07/30 11:12:25 niklas Exp $	*/
d192 1
a192 1
	epconfig(sc, chipset);
@


1.8
log
@Sync to NetBSD.  Adapt to use bus_space_multi_raw* interface of OpenBSD.
Some KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_eisa.c,v 1.13 1997/04/18 00:50:33 cgd Exp $	*/
d173 1
a173 1
	printf(": %s\n", model);
d190 1
a190 1
		printf("%s, ", intrstr);
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 1
/*	$NetBSD: if_ep_eisa.c,v 1.9 1996/10/21 22:31:04 thorpej Exp $	*/
d5 1
d99 5
a103 1
	    strcmp(ea->ea_idstring, "TCM5093"))
d118 1
a118 1
	u_int16_t k, conn = 0;
d122 1
d148 1
a148 3
	GO_WINDOW(0);
	conn = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);

d155 16
d173 1
a173 1
	printf(": <%s> ", model);
d192 1
a192 1
	epconfig(sc, conn);
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$NetBSD: if_ep_eisa.c,v 1.6 1996/05/14 22:21:05 thorpej Exp $	*/
d64 1
a64 1
#include <machine/bus.old.h>
d110 2
a111 2
	bus_chipset_tag_t bc = ea->ea_bc;
	bus_io_handle_t ioh;
d119 2
a120 1
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, &ioh))
d125 1
a125 1
	sc->sc_bc = bc;
d128 1
a128 1
	bus_io_write_1(bc, ioh, EISA_CONTROL, EISA_ENABLE | EISA_RESET);
d130 1
a130 1
	bus_io_write_1(bc, ioh, EISA_CONTROL, EISA_ENABLE);
d135 1
a135 1
	k = bus_io_read_2(bc, ioh, EP_W0_ADDRESS_CFG);
d139 1
a139 1
	irq = bus_io_read_2(bc, ioh, EP_W0_RESOURCE_CFG) >> 12;
d142 1
a142 1
	conn = bus_io_read_2(bc, ioh, EP_W0_CONFIG_CTRL);
@


1.5
log
@sync 0521
@
text
@d64 1
a64 1
#include <machine/bus.h>
@


1.4
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 1
a1 1
/*	$NetBSD: if_ep_eisa.c,v 1.3 1996/05/03 19:07:18 christos Exp $	*/
d4 1
a4 1
 * Copyright (c) 1994 Herb Peyerl <hpeyerl@@novatel.ca>
d65 1
d112 1
a112 2
	int irq, k;
	u_short conn = 0;
d116 1
d119 1
a119 2
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE,
	    &ioh))
d154 1
a154 1
		printf("couldn't map interrupt (%d)\n", irq);
d168 1
a168 2
		printf("interrupting at %s, ", sc->sc_dev.dv_xname,
		    intrstr);
@


1.3
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d1 1
a1 1
/*	$NetBSD: if_ep_eisa.c,v 1.1 1996/04/25 02:16:40 thorpej Exp $	*/
d36 1
d64 1
a64 1
#include <machine/pio.h>
a90 1
	struct cfdata *cf = match;
d109 3
a111 1
	int iobase, irq, k;
d117 5
a121 1
	sc->ep_iobase = iobase = EISA_SLOT_ADDR(ea->ea_slot);
d123 2
d127 1
a127 1
	outb(iobase + EISA_CONTROL, EISA_ENABLE | EISA_RESET);
d129 1
a129 1
	outb(iobase + EISA_CONTROL, EISA_ENABLE);
d133 2
a134 2
	/* XXX What is this doing?! */
	k = inw(iobase + EP_W0_ADDRESS_CFG);
d138 1
a138 1
	irq = inw(iobase + EP_W0_RESOURCE_CFG) >> 12;
d141 1
a141 1
	conn = inw(iobase + EP_W0_CONFIG_CTRL);
@


1.2
log
@prettier printf messages
@
text
@a56 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif 
        
@


1.1
log
@if_ep splitup
@
text
@d148 1
a148 1
	printf(": %s\n", model);
d151 1
a151 2
		printf("%s: couldn't map interrupt (%d)\n",
		    sc->sc_dev.dv_xname, irq);
d158 1
a158 2
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
d165 1
a165 1
		printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname,
@

