head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.13.0.12
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.6
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.13.0.4
	OPENBSD_5_7_BASE:1.13
	OPENBSD_5_6:1.12.0.20
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.12.0.18
	OPENBSD_5_5_BASE:1.12
	OPENBSD_5_4:1.12.0.14
	OPENBSD_5_4_BASE:1.12
	OPENBSD_5_3:1.12.0.12
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.10
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.8
	OPENBSD_5_0:1.12.0.6
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.12.0.4
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.2
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.4
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.8.0.2
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.6.0.2
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.5.0.6
	OPENBSD_4_1_BASE:1.5
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.18
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.16
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.14
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.12
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.10
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.2.0.8
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.6
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.14
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.13;
commitid	uRv5pa9QDlZaYgwD;

1.13
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.12;
commitid	uzzBR7hz9ncd4O6G;

1.12
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.29.13.58.51;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.8;

1.8
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.05.17.54.27;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.03.07.29.29;	author mickey;	state Exp;
branches
	1.3.6.1;
next	1.2;

1.2
date	97.04.13.20.22.38;	author mickey;	state Exp;
branches
	1.2.14.1;
next	1.1;

1.1
date	96.11.28.23.27.42;	author niklas;	state Exp;
branches;
next	;

1.2.14.1
date	2001.05.14.22.23.17;	author niklas;	state Exp;
branches;
next	1.2.14.2;

1.2.14.2
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.14
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: uha_eisa.c,v 1.13 2014/09/14 14:17:24 jsg Exp $	*/
/*	$NetBSD: uha_eisa.c,v 1.5 1996/10/21 22:31:07 thorpej Exp $	*/

/*
 * Copyright (c) 1994, 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>

#include <dev/ic/uhareg.h>
#include <dev/ic/uhavar.h>

#define	UHA_EISA_SLOT_OFFSET	0xc80
#define	UHA_EISA_IOSIZE		0x020

int	uha_eisa_match(struct device *, void *, void *);
void	uha_eisa_attach(struct device *, struct device *, void *);

struct cfattach uha_eisa_ca = {
	sizeof(struct uha_softc), uha_eisa_match, uha_eisa_attach
};

#define KVTOPHYS(x)	vtophys((vaddr_t)(x))

int u24_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u24_start_mbox(struct uha_softc *, struct uha_mscp *);
int u24_poll(struct uha_softc *, struct scsi_xfer *, int);
int u24_intr(void *);
void u24_init(struct uha_softc *);

/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int
uha_eisa_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct eisa_attach_args *ea = aux;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	int rv;

	/* must match one of our known ID strings */
	if (strncmp(ea->ea_idstring, "USC024", 6))
		return (0);

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +
	    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))
		return (0);

	rv = u24_find(iot, ioh, NULL);

	bus_space_unmap(iot, ioh, UHA_EISA_IOSIZE);

	return (rv);
}

/*
 * Attach all the sub-devices we can find
 */
void
uha_eisa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct eisa_attach_args *ea = aux;
	struct uha_softc *sc = (void *)self;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	eisa_chipset_tag_t ec = ea->ea_ec;
	eisa_intr_handle_t ih;
	const char *model, *intrstr;

	if (!strncmp(ea->ea_idstring, "USC024", 6))
		model = EISA_PRODUCT_USC0240;
	else
		model = "unknown model!";
	printf(": %s\n", model);

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +
	    UHA_EISA_SLOT_OFFSET, UHA_EISA_IOSIZE, 0, &ioh))
		panic("uha_attach: can't map I/O addresses");

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	if (!u24_find(iot, ioh, sc))
		panic("uha_attach: u24_find failed!");

	if (eisa_intr_map(ec, sc->sc_irq, &ih)) {
		printf("%s: couldn't map interrupt (%d)\n",
		    sc->sc_dev.dv_xname, sc->sc_irq);
		return;
	}
	intrstr = eisa_intr_string(ec, ih);
	sc->sc_ih = eisa_intr_establish(ec, ih, IST_LEVEL, IPL_BIO,
	    u24_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);

	/* Save function pointers for later use. */
	sc->start_mbox = u24_start_mbox;
	sc->poll = u24_poll;
	sc->init = u24_init;

	uha_attach(sc);
}

int
u24_find(iot, ioh, sc)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct uha_softc *sc;
{
	u_int8_t config0, config1, config2;
	int irq, drq;
	int resetcount = 4000;	/* 4 secs? */

	config0 = bus_space_read_1(iot, ioh, U24_CONFIG + 0);
	config1 = bus_space_read_1(iot, ioh, U24_CONFIG + 1);
	config2 = bus_space_read_1(iot, ioh, U24_CONFIG + 2);
	if ((config0 & U24_MAGIC1) == 0 ||
	    (config1 & U24_MAGIC2) == 0)
		return (0);

	drq = -1;

	switch (config0 & U24_IRQ_MASK) {
	case U24_IRQ10:
		irq = 10;
		break;
	case U24_IRQ11:
		irq = 11;
		break;
	case U24_IRQ14:
		irq = 14;
		break;
	case U24_IRQ15:
		irq = 15;
		break;
	default:
		printf("u24_find: illegal irq setting %x\n",
		    config0 & U24_IRQ_MASK);
		return (0);
	}

	bus_space_write_1(iot, ioh, U24_LINT, UHA_ASRST);

	while (--resetcount) {
		if (bus_space_read_1(iot, ioh, U24_LINT))
			break;
		delay(1000);	/* 1 mSec per loop */
	}
	if (!resetcount) {
		printf("u24_find: board timed out during reset\n");
		return (0);
	}

	/* if we want to fill in softc, do so now */
	if (sc != NULL) {
		sc->sc_irq = irq;
		sc->sc_drq = drq;
		sc->sc_scsi_dev = config2 & U24_HOSTID_MASK;
	}

	return (1);
}

void
u24_start_mbox(sc, mscp)
	struct uha_softc *sc;
	struct uha_mscp *mscp;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int spincount = 100000;	/* 1s should be enough */

	while (--spincount) {
		if ((bus_space_read_1(iot, ioh, U24_LINT) & U24_LDIP) == 0)
			break;
		delay(100);
	}
	if (!spincount)
		panic("%s: uha_start_mbox, board not responding",
		    sc->sc_dev.dv_xname);

	bus_space_write_4(iot, ioh, U24_OGMPTR, KVTOPHYS(mscp));
	if (mscp->flags & MSCP_ABORT)
		bus_space_write_1(iot, ioh, U24_OGMCMD, 0x80);
	else
		bus_space_write_1(iot, ioh, U24_OGMCMD, 0x01);
	bus_space_write_1(iot, ioh, U24_LINT, U24_OGMFULL);

	if ((mscp->xs->flags & SCSI_POLL) == 0)
		timeout_add_msec(&mscp->xs->stimeout, mscp->timeout);
}

int
u24_poll(sc, xs, count)
	struct uha_softc *sc;
	struct scsi_xfer *xs;
	int count;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s;

	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) {
			s = splbio();
			u24_intr(sc);
			splx(s);
		}
		if (xs->flags & ITSDONE)
			return (0);
		delay(1000);
		count--;
	}
	return (1);
}

int
u24_intr(arg)
	void *arg;
{
	struct uha_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct uha_mscp *mscp;
	u_char uhastat;
	u_long mboxval;

#ifdef	UHADEBUG
	printf("%s: uhaintr ", sc->sc_dev.dv_xname);
#endif /*UHADEBUG */

	if ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)
		return (0);

	for (;;) {
		/*
		 * First get all the information and then
		 * acknowledge the interrupt
		 */
		uhastat = bus_space_read_1(iot, ioh, U24_SINT);
		mboxval = bus_space_read_4(iot, ioh, U24_ICMPTR);
		bus_space_write_1(iot, ioh, U24_SINT, U24_ICM_ACK);
		bus_space_write_1(iot, ioh, U24_ICMCMD, 0);

#ifdef	UHADEBUG
		printf("status = 0x%x ", uhastat);
#endif /*UHADEBUG*/

		/*
		 * Process the completed operation
		 */
		mscp = uha_mscp_phys_kv(sc, mboxval);
		if (!mscp) {
			printf("%s: BAD MSCP RETURNED!\n",
			    sc->sc_dev.dv_xname);
			continue;	/* whatever it was, it'll timeout */
		}
		timeout_del(&mscp->xs->stimeout);
		uha_done(sc, mscp);

		if ((bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP) == 0)
			return (1);
	}
}

void
u24_init(sc)
	struct uha_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	/* free OGM and ICM */
	bus_space_write_1(iot, ioh, U24_OGMCMD, 0);
	bus_space_write_1(iot, ioh, U24_ICMCMD, 0);
	/* make sure interrupts are enabled */
#ifdef UHADEBUG
	printf("u24_init: lmask=%02x, smask=%02x\n",
	    bus_space_read_1(iot, ioh, U24_LMASK),
	    bus_space_read_1(iot, ioh, U24_SMASK));
#endif
	bus_space_write_1(iot, ioh, U24_LMASK, 0xd2);	/* XXX */
	bus_space_write_1(iot, ioh, U24_SMASK, 0x92);	/* XXX */
}
@


1.13
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.12 2010/08/07 03:50:01 krw Exp $	*/
a32 1
#include <sys/types.h>
@


1.12
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.11 2010/06/26 23:24:44 guenther Exp $	*/
a37 1
#include <sys/proc.h>
@


1.11
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.10 2009/08/29 13:58:51 jasper Exp $	*/
d233 1
a233 1
		panic("%s: uha_start_mbox, board not responding\n",
@


1.10
log
@remove more unneeded Debugger() calls from dev/

agreed by deraadt@@
ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.9 2009/03/29 21:53:52 sthen Exp $	*/
d39 1
a39 1
#include <sys/user.h>
@


1.9
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.8 2009/01/21 21:53:59 grange Exp $	*/
a55 4
#ifndef DDB
#define	Debugger() panic("should call debugger here (uha_eisa.c)")
#endif

d232 2
a233 2
	if (!spincount) {
		printf("%s: uha_start_mbox, board not responding\n",
a234 2
		Debugger();
	}
@


1.8
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.7 2007/11/05 17:54:27 krw Exp $	*/
d129 1
a129 1
		panic("uha_attach: could not map I/O addresses");
@


1.7
log
@More scsi_done() at SPLBIO. Wrap another interrupt function call while
polling in splbio/splx.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.6 2007/04/10 17:47:55 miod Exp $	*/
d250 1
a250 1
		timeout_add(&mscp->xs->stimeout, (mscp->timeout * hz) / 1000);
@


1.6
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.5 2005/11/23 11:30:14 mickey Exp $	*/
d261 1
d268 2
a269 1
		if (bus_space_read_1(iot, ioh, U24_SINT) & U24_SDIP)
d271 2
@


1.5
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.4 2002/03/14 01:26:53 millert Exp $	*/
d77 1
a77 1
 * If we find one, note it's address (slot) and call
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
d67 1
a67 1
#define KVTOPHYS(x)	vtophys(x)
@


1.3
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.2 1997/04/13 20:22:38 mickey Exp $	*/
d60 2
a61 2
int	uha_eisa_match __P((struct device *, void *, void *));
void	uha_eisa_attach __P((struct device *, struct device *, void *));
d69 5
a73 5
int u24_find __P((bus_space_tag_t, bus_space_handle_t, struct uha_softc *));
void u24_start_mbox __P((struct uha_softc *, struct uha_mscp *));
int u24_poll __P((struct uha_softc *, struct scsi_xfer *, int));
int u24_intr __P((void *));
void u24_init __P((struct uha_softc *));
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
d60 2
a61 2
int	uha_eisa_match(struct device *, void *, void *);
void	uha_eisa_attach(struct device *, struct device *, void *);
d69 5
a73 5
int u24_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u24_start_mbox(struct uha_softc *, struct uha_mscp *);
int u24_poll(struct uha_softc *, struct scsi_xfer *, int);
int u24_intr(void *);
void u24_init(struct uha_softc *);
@


1.2
log
@no Debugger() w/ no DDB defined
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.1 1996/11/28 23:27:42 niklas Exp $	*/
d250 1
a250 1
		timeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);
d318 1
a318 1
		untimeout(uha_timeout, mscp);
@


1.2.14.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.3 2001/02/03 07:29:29 mickey Exp $	*/
d250 1
a250 1
		timeout_add(&mscp->xs->stimeout, (mscp->timeout * hz) / 1000);
d318 1
a318 1
		timeout_del(&mscp->xs->stimeout);
@


1.2.14.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
a61 2
int	uha_eisa_match(struct device *, void *, void *);
void	uha_eisa_attach(struct device *, struct device *, void *);
d69 5
a73 5
int u24_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u24_start_mbox(struct uha_softc *, struct uha_mscp *);
int u24_poll(struct uha_softc *, struct scsi_xfer *, int);
int u24_intr(void *);
void u24_init(struct uha_softc *);
@


1.1
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_eisa.c,v 1.5 1996/10/21 22:31:07 thorpej Exp $	*/
d55 4
@
