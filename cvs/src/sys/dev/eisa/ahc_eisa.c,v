head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.22
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.18
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.8
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.16
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.14
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.12
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.10
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.6
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.4
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.2
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.6
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.12
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.9.0.10
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.8
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.6
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.8
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.7.0.6
	OPENBSD_2_3_BASE:1.7
	OPENBSD_2_2:1.7.0.4
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.7.0.2
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.21
date	2012.05.12.21.54.39;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2010.11.18.21.15.15;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2004.08.01.01.36.23;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2003.12.24.23.41.39;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2003.10.21.10.27.12;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.28.00.34.54;	author smurph;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.19.21.07.25;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.19.02.49.20;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.16.05.41.28;	author smurph;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.22.02.55.40;	author smurph;	state Exp;
branches
	1.9.10.1;
next	1.8;

1.8
date	99.01.11.01.57.59;	author millert;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	96.11.28.23.27.37;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.30.08;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.16.12.38.07;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.10.04.02.51.24;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.08.21.22.27.24;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.27.21.15.44;	author shawn;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.00.26.52;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2000.03.24.09.09.07;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.03.06.02.11.42;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.8.6.4;

1.8.6.4
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.8.6.5;

1.8.6.5
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	;

1.9.10.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.9.10.2;

1.9.10.2
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Initialize enough softc fields to give this attachment a chance to work.
This got broken during ahc updates 8 years ago (for 3.6), but there are no
reports of users of EISA ahc since 3.5 anyway...
@
text
@/*	$OpenBSD: ahc_eisa.c,v 1.20 2010/11/18 21:15:15 miod Exp $	*/
/*	$NetBSD: ahc_eisa.c,v 1.10 1996/10/21 22:30:58 thorpej Exp $	*/

/*
 * Product specific probe and attach routines for:
 * 	27/284X and aic7770 motherboard SCSI controllers
 *
 * Copyright (c) 1994, 1995, 1996 Justin T. Gibbs.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice immediately at the beginning of the file, without modification,
 *    this list of conditions, and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	$Id: ahc_eisa.c,v 1.20 2010/11/18 21:15:15 miod Exp $
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>

#define AHC_EISA_SLOT_OFFSET	0xc00
#define AHC_EISA_IOSIZE		0x100

int   ahc_eisa_irq(bus_space_tag_t, bus_space_handle_t);
int   ahc_eisa_match(struct device *, void *, void *);
void  ahc_eisa_attach(struct device *, struct device *, void *);


struct cfattach ahc_eisa_ca = {
	sizeof(struct ahc_softc), ahc_eisa_match, ahc_eisa_attach
};

/*
 * Return irq setting of the board, otherwise -1.
 */
int
ahc_eisa_irq(iot, ioh)
bus_space_tag_t iot;
bus_space_handle_t ioh;
{
	int irq;
	u_char intdef;
	u_char hcntrl;
	
	/* Pause the card preserving the IRQ type */
	hcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
	
	intdef = bus_space_read_1(iot, ioh, INTDEF);
	switch (irq = (intdef & VECTOR)) {
	case 9:
	case 10:
	case 11:
	case 12:
	case 14:
	case 15:
		break;
	default:
		printf("ahc_eisa_irq: illegal irq setting %d\n", intdef);
		return -1;
	}

	/* Note that we are going and return (to probe) */
	return irq;
}

/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int
ahc_eisa_match(parent, match, aux)
struct device *parent;
void *match, *aux;
{
	struct eisa_attach_args *ea = aux;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	int irq;

	/* must match one of our known ID strings */
	if (strcmp(ea->ea_idstring, "ADP7770") &&
		 strcmp(ea->ea_idstring, "ADP7771")
#if 0
		 && strcmp(ea->ea_idstring, "ADP7756")	/* not EISA, but VL */
		 && strcmp(ea->ea_idstring, "ADP7757")	/* not EISA, but VL */
#endif
		)
		return (0);

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +
			  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
		return (0);

	irq = ahc_eisa_irq(iot, ioh);

	bus_space_unmap(iot, ioh, AHC_EISA_IOSIZE);

	return (irq >= 0);
}

void
ahc_eisa_attach(parent, self, aux)
struct device *parent, *self;
void *aux;
{
	struct ahc_softc *ahc = (void *)self;
	struct eisa_attach_args *ea = aux;
	bus_space_tag_t iot = ea->ea_iot;
	bus_space_handle_t ioh;
	int irq;
	eisa_chipset_tag_t ec = ea->ea_ec;
	eisa_intr_handle_t ih;
	const char *model, *intrstr;
	u_int biosctrl;
	u_int scsiconf;
	u_int scsiconf1;
	u_int intdef;
	int i;
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ea->ea_dmat;

	if (bus_space_map(iot, EISA_SLOT_ADDR(ea->ea_slot) +
			  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
		panic("ahc_eisa_attach: can't map i/o addresses");
	if ((irq = ahc_eisa_irq(iot, ioh)) < 0)
		panic("ahc_eisa_attach: ahc_eisa_irq failed!");

	if (strcmp(ea->ea_idstring, "ADP7770") == 0) {
		model = EISA_PRODUCT_ADP7770;
	} else if (strcmp(ea->ea_idstring, "ADP7771") == 0) {
		model = EISA_PRODUCT_ADP7771;
	} else {
		panic("ahc_eisa_attach: Unknown device type %s",
				ea->ea_idstring);
	}
	printf(": %s\n", model);
	
	/*
	 * Instead of ahc_alloc() as in FreeBSD, do the few relevant
	 * initializations manually.
	 */
	LIST_INIT(&ahc->pending_scbs);
	for (i = 0; i < AHC_NUM_TARGETS; i++)
		TAILQ_INIT(&ahc->untagged_queues[i]);

	/*
	 * SCSI_IS_SCSIBUS_B() must returns false until sc_channel_b
	 * has been properly initialized. XXX Breaks if >254 scsi buses.
	 */
	ahc->sc_channel_b.scsibus = 0xff;

	ahc->channel = 'A';
	ahc->chip = AHC_AIC7770|AHC_EISA;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	ahc->tag = iot;
	ahc->bsh = ioh;
	ahc->bus_chip_init = ahc_chip_init;
	ahc->instruction_ram_size = 512;

	if (ahc_softc_init(ahc) != 0)
		return;
	
	if (ahc_reset(ahc, /*reinit*/FALSE) != 0)
		return;
	
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;
	
	if (eisa_intr_map(ec, irq, &ih)) {
		printf("%s: couldn't map interrupt (%d)\n",
		       ahc->sc_dev.dv_xname, irq);
		return;
	}

	/*
	 * Tell the user what type of interrupts we're using.
	 * useful for debugging irq problems
	 */
	if (bootverbose) {
		printf("%s: Using %s Interrupts\n",
		       ahc_name(ahc),
		       ahc->pause & IRQMS ?
		       "Level Sensitive" : "Edge Triggered");
	}

	/*
	 * Now that we know we own the resources we need, do the 
	 * card initialization.
	 *
	 * First, the aic7770 card specific setup.
	 */
	biosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);
	scsiconf = ahc_inb(ahc, SCSICONF);
	scsiconf1 = ahc_inb(ahc, SCSICONF + 1);
	
	/* Get the primary channel information */
	if ((biosctrl & CHANNEL_B_PRIMARY) != 0)
		ahc->flags |= AHC_PRIMARY_CHANNEL;

	if ((biosctrl & BIOSMODE) == BIOSDISABLED) {
		ahc->flags |= AHC_USEDEFAULTS;
	} else if ((ahc->features & AHC_WIDE) != 0) {
		ahc->our_id = scsiconf1 & HWSCSIID;
		if (scsiconf & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_A;
	} else {
		ahc->our_id = scsiconf & HSCSIID;
		ahc->our_id_b = scsiconf1 & HSCSIID;
		if (scsiconf & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_A;
		if (scsiconf1 & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_B;
	}
	/*
	 * We have no way to tell, so assume extended
	 * translation is enabled.
	 */
	
	ahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;
	
	/*      
	 * See if we have a Rev E or higher aic7770. Anything below a
	 * Rev E will have a R/O autoflush disable configuration bit.
	 * It's still not clear exactly what is different about the Rev E.
	 * We think it allows 8 bit entries in the QOUTFIFO to support
	 * "paging" SCBs so you can have more than 4 commands active at
	 * once.
	 */
	{
		char *id_string;
		u_char sblkctl;
		u_char sblkctl_orig;

		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
		sblkctl = sblkctl_orig ^ AUTOFLUSHDIS;
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
		if (sblkctl != sblkctl_orig) {
			id_string = "aic7770 >= Rev E";
			/*
			 * Ensure autoflush is enabled
			 */
			sblkctl &= ~AUTOFLUSHDIS;
			ahc_outb(ahc, SBLKCTL, sblkctl);

			/* Allow paging on this adapter */
			ahc->flags |= AHC_PAGESCBS;
		} else
			id_string = "aic7770 <= Rev C";

		if (bootverbose)
			printf("%s: %s\n", ahc_name(ahc), id_string);
	}

	/* Setup the FIFO threshold and the bus off time */
	{
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
	}

	/*
	 * Generic aic7xxx initialization.
	 */
	if (ahc_init(ahc)) {
		ahc_free(ahc);
		return;
	}
 
	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
	
	/*
	 * Enable the board's BUS drivers
	 */
	ahc_outb(ahc, BCTL, ENABLE);

	intrstr = eisa_intr_string(ec, ih);
	/*
	 * The IRQMS bit enables level sensitive interrupts only allow
	 * IRQ sharing if its set.
	 */
	ahc->ih = eisa_intr_establish(ec, ih,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO,
	    ahc_platform_intr, ahc, ahc->sc_dev.dv_xname);
	if (ahc->ih == NULL) {
		printf("%s: couldn't establish interrupt",
		       ahc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		ahc_free(ahc);
		return;
	}
	if (intrstr != NULL)
		printf("%s: interrupting at %s\n", ahc->sc_dev.dv_xname,
		    intrstr);
	
	ahc_intr_enable(ahc, TRUE);

	/* Attach sub-devices - always succeeds */
	ahc_attach(ahc);

}
@


1.20
log
@Don't
  #include "foo.h"
  #if NFOO > 0
  (whole file)
  #endif
since config(8) file inclusion rules already do it for you.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.19 2009/03/29 21:53:52 sthen Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.19 2009/03/29 21:53:52 sthen Exp $
d153 1
d177 14
d196 7
d282 1
a282 1
			id_string = "aic7770 >= Rev E, ";
d292 1
a292 1
			id_string = "aic7770 <= Rev C, ";
d294 2
a295 1
		printf("%s: %s", ahc_name(ahc), id_string);
d342 1
a342 1
		       intrstr);
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.18 2007/04/10 17:47:55 miod Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.18 2007/04/10 17:47:55 miod Exp $
a37 3
#include "eisa.h"
#if NEISA > 0

a326 1
#endif /* NEISA > 0 */
@


1.18
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.17 2004/08/01 01:36:23 krw Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.17 2004/08/01 01:36:23 krw Exp $
d165 1
a165 1
		panic("ahc_eisa_attach: could not map I/O addresses");
@


1.17
log
@Fold in relevant bits of the most recent two updates from
gibbs@@freebsd.

Large commit messages detailing all changes can be read at revisions
1.97 and 1.100 of aic7xxx.c:

www.freebsd.org/cgi/cvsweb.cgi/src/sys/dev/aic7xxx/aic7xxx.c

Tested by marco, nate and pefo. Fixed broken system for nate.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.16 2003/12/24 23:41:39 krw Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.16 2003/12/24 23:41:39 krw Exp $
d105 1
a105 1
 * If we find one, note it's address (slot) and call
@


1.16
log
@Sync ahc with NetBSD, which was in turn updated from FreeBSD by Pascal
Renauld of Network Storage Solutions, Inc. Many fixes, wider device
support. In particular, the notorious 'Target 0' problem seems to be
fixed.

Does *not* include any updates to isa or eisa code beyond what was
necessary to compile.

Known issues:

1) Tagged Queuing is probably not optimal.

2) PPR negotiation may not be fully functional.

3) No support yet for freezing devices or channels.

4) The mechanism for preventing 'A' and 'B' channel confusion during probe
can fail if scsibus > 254 found.

5) Requeuing I/O's not working. A workaround will be committed almost
immediately. At the moment timeouts, SCSI message rejects, aborting
SCB's and trying to freeze a device may cause incomplete i/o's to be
reported as complete.

6) Verbosity and probe messages need work.

7) Last disk on bus seems to go through an extra re-negotiation.

8) >16 devices on an adapter will trigger the usual problems of total
openings exceeding available SCB's under heavy load.

Tested by deraadt@@, beck@@, miod@@, naddy@@, drahn@@, marc@@ amoung
others.

ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.15 2003/10/21 10:27:12 jmc Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.15 2003/10/21 10:27:12 jmc Exp $
d185 1
a185 1
	if (ahc_reset(ahc) != 0)
@


1.15
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.14 2002/06/28 00:34:54 smurph Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.14 2002/06/28 00:34:54 smurph Exp $
a55 1
#include <dev/ic/aic7xxxreg.h>
a156 7
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
a161 2
	ahc->buffer_dmat = ea->ea_dmat;
        ahc->shared_data_dmat = ea->ea_dmat;
a179 1
	ahc->channel_b = 'B';
d222 1
a222 1
		ahc->platform_data->channel_b_primary = TRUE;
a292 3
       	/* Special func to force negotiation */
	ahc_force_neg(ahc);

d308 4
a311 5
	ahc->platform_data->ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
					 ? IST_LEVEL : IST_EDGE,
					 IPL_BIO, ahc_platform_intr, ahc,
					 ahc->sc_dev.dv_xname);
	if (ahc->platform_data->ih == NULL) {
@


1.14
log
@Return of new ahc
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.13 2002/03/19 21:07:25 millert Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.13 2002/03/19 21:07:25 millert Exp $
d82 1
a82 1
	/* Pause the card preseving the IRQ type */
d212 1
a212 1
	 * usefull for debugging irq problems
d259 1
a259 1
	 * It's still not clear exactly what is differenent about the Rev E.
@


1.13
log
@remove __P
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.12 2002/03/19 02:49:20 millert Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.12 2002/03/19 02:49:20 millert Exp $
d54 2
a56 1
#include <dev/ic/aic7xxxvar.h>
a59 11
#define INTDEF			0x5cul	/* Interrupt Definition Register */

/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	1
#endif
d87 1
a87 1
	switch (irq = (intdef & 0xf)) {
a144 2
	ahc_chip chip;
	u_char channel = 'A'; /* Only one channel */
d156 1
d158 15
a172 1
	ahc->sc_dmat = ea->ea_dmat;
a180 1
		chip = AHC_AIC7770|AHC_EISA;
a182 1
		chip = AHC_AIC7770|AHC_EISA;
a187 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
d191 5
d199 5
d233 1
a233 1
		ahc->flags |= AHC_CHANNEL_B_PRIMARY;
d269 1
a269 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d271 2
a272 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d279 1
a279 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d291 3
a293 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d304 8
d315 1
a315 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d322 1
a322 1
	ahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d324 1
a324 1
					 IPL_BIO, ahc_intr, ahc,
d326 1
a326 1
	if (ahc->sc_ih == NULL) {
d338 2
@


1.12
log
@revert to older ahc driver until the new one's bugs are fixed
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $
d71 3
a73 3
int   ahc_eisa_irq __P((bus_space_tag_t, bus_space_handle_t));
int   ahc_eisa_match __P((struct device *, void *, void *));
void  ahc_eisa_attach __P((struct device *, struct device *, void *));
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.10 2002/02/16 05:41:28 smurph Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.10 2002/02/16 05:41:28 smurph Exp $
a53 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d55 1
d59 1
d61 13
a73 3
int   ahc_eisa_irq(bus_space_tag_t, bus_space_handle_t);
int   ahc_eisa_match(struct device *, void *, void *);
void  ahc_eisa_attach(struct device *, struct device *, void *);
d97 1
a97 1
	switch (irq = (intdef & VECTOR)) {
d155 2
a167 1
	u_int intdef;
d169 1
a169 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ea->ea_dmat;
	ahc->buffer_dmat = ea->ea_dmat;
        ahc->shared_data_dmat = ea->ea_dmat;

d178 1
d181 1
d187 2
a191 5
	ahc->chip = AHC_AIC7770|AHC_EISA;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
a194 5
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;
	
d224 1
a224 1
		ahc->platform_data->channel_b_primary = TRUE;
d260 1
a260 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d262 2
a263 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d270 1
a270 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d282 3
a284 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a294 8
       	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
	
d298 1
a298 1
	ahc_outb(ahc, BCTL, ENABLE);
d305 1
a305 1
	ahc->platform_data->ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d307 1
a307 1
					 IPL_BIO, ahc_platform_intr, ahc,
d309 1
a309 1
	if (ahc->platform_data->ih == NULL) {
a320 2
	
	ahc_intr_enable(ahc, TRUE);
@


1.10
log
@eisa support for ahc. (left out)
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $
d61 3
a63 3
int   ahc_eisa_irq __P((bus_space_tag_t, bus_space_handle_t));
int   ahc_eisa_match __P((struct device *, void *, void *));
void  ahc_eisa_attach __P((struct device *, struct device *, void *));
@


1.9
log
@new ahc driver.  Adds support for newer Adaptec controllers.  This represents two months of work.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.8 1999/01/11 01:57:59 millert Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.8 1999/01/11 01:57:59 millert Exp $
d54 2
a56 1
#include <dev/ic/aic7xxxvar.h>
a59 11
#define INTDEF			0x5cul	/* Interrupt Definition Register */

/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	1
#endif
d87 1
a87 1
	switch (irq = (intdef & 0xf)) {
a144 2
	ahc_chip chip;
	u_char channel = 'A'; /* Only one channel */
d156 1
d158 15
a172 1
	ahc->sc_dmat = ea->ea_dmat;
a180 1
		chip = AHC_AIC7770|AHC_EISA;
a182 1
		chip = AHC_AIC7770|AHC_EISA;
a187 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
d191 5
d199 5
d233 1
a233 1
		ahc->flags |= AHC_CHANNEL_B_PRIMARY;
d269 1
a269 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d271 2
a272 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d279 1
a279 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d291 3
a293 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d304 8
d315 1
a315 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d322 1
a322 1
	ahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d324 1
a324 1
					 IPL_BIO, ahc_intr, ahc,
d326 1
a326 1
	if (ahc->sc_ih == NULL) {
d338 2
@


1.9.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.9 2000/03/22 02:55:40 smurph Exp $
d71 3
a73 3
int   ahc_eisa_irq(bus_space_tag_t, bus_space_handle_t);
int   ahc_eisa_match(struct device *, void *, void *);
void  ahc_eisa_attach(struct device *, struct device *, void *);
@


1.9.10.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.9.10.1 2002/06/11 03:42:16 art Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.9.10.1 2002/06/11 03:42:16 art Exp $
a53 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d55 1
d59 11
d97 1
a97 1
	switch (irq = (intdef & VECTOR)) {
d155 2
a167 1
	u_int intdef;
d169 1
a169 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ea->ea_dmat;
	ahc->buffer_dmat = ea->ea_dmat;
        ahc->shared_data_dmat = ea->ea_dmat;

d178 1
d181 1
d187 2
a191 5
	ahc->chip = AHC_AIC7770|AHC_EISA;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
a194 5
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;
	
d224 1
a224 1
		ahc->platform_data->channel_b_primary = TRUE;
d260 1
a260 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d262 2
a263 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d270 1
a270 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d282 3
a284 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a294 8
       	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
	
d298 1
a298 1
	ahc_outb(ahc, BCTL, ENABLE);
d305 1
a305 1
	ahc->platform_data->ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d307 1
a307 1
					 IPL_BIO, ahc_platform_intr, ahc,
d309 1
a309 1
	if (ahc->platform_data->ih == NULL) {
a320 2
	
	ahc_intr_enable(ahc, TRUE);
@


1.8
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.7 1996/11/28 23:27:37 niklas Exp $	*/
d3 1
a3 1
  
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.7 1996/11/28 23:27:37 niklas Exp $
d38 2
a39 4
#if defined(__FreeBSD__)
#include <eisa.h>
#endif
#if NEISA > 0 || defined(__NetBSD__) || defined(__OpenBSD__)
a42 3
#if defined(__FreeBSD__)
#include <sys/devconf.h>
#endif
a43 2

#if defined(__NetBSD__) || defined(__OpenBSD__)
a46 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a50 15
#if defined(__FreeBSD__)

#include <machine/clock.h>

#include <i386/eisa/eisaconf.h>
#include <i386/scsi/aic7xxx.h>
#include <dev/aic7xxx/aic7xxx_reg.h>

#define EISA_DEVICE_ID_ADAPTEC_AIC7770	0x04907770
#define EISA_DEVICE_ID_ADAPTEC_274x	0x04907771
#define EISA_DEVICE_ID_ADAPTEC_284xB	0x04907756 /* BIOS enabled */
#define EISA_DEVICE_ID_ADAPTEC_284x	0x04907757 /* BIOS disabled*/

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a53 1

a56 2
#endif /* defined(__NetBSD__) */

a60 106
#if defined(__FreeBSD__)

static int	aic7770probe __P((void));
static int	aic7770_attach __P((struct eisa_device *e_dev));

static struct eisa_driver ahc_eisa_driver = {
					"ahc",
					aic7770probe,
					aic7770_attach,
					/*shutdown*/NULL,
					&ahc_unit
				      };

DATA_SET (eisadriver_set, ahc_eisa_driver);

static struct kern_devconf kdc_aic7770 = {
	0, 0, 0,                /* filled in by dev_attach */
	"ahc", 0, { MDDT_EISA, 0, "bio" },
	eisa_generic_externalize, 0, 0, EISA_EXTERNALLEN,
	&kdc_eisa0,		/* parent */
	0,			/* parentdata */
	DC_UNCONFIGURED,	/* always start out here */
	NULL,
	DC_CLS_MISC		/* host adapters aren't special */
};


static char	*aic7770_match __P((eisa_id_t type));

static  char*
aic7770_match(type)
	eisa_id_t type;
{
	switch(type) {
		case EISA_DEVICE_ID_ADAPTEC_AIC7770:
			return ("Adaptec aic7770 SCSI host adapter");
			break;
		case EISA_DEVICE_ID_ADAPTEC_274x:
			return ("Adaptec 274X SCSI host adapter");
			break;
		case EISA_DEVICE_ID_ADAPTEC_284xB:
		case EISA_DEVICE_ID_ADAPTEC_284x:
			return ("Adaptec 284X SCSI host adapter");
			break;
		default:
			break;
	}
	return (NULL);
}

static int
aic7770probe(void)
{
	u_long iobase;
	char intdef;
	u_long irq;
	struct eisa_device *e_dev = NULL;
	int count;

	count = 0;
	while ((e_dev = eisa_match_dev(e_dev, aic7770_match))) {
		iobase = (e_dev->ioconf.slot * EISA_SLOT_SIZE)
			 + AHC_EISA_SLOT_OFFSET;
		ahc_reset(iobase);

		eisa_add_iospace(e_dev, iobase, AHC_EISA_IOSIZE, RESVADDR_NONE);
		intdef = inb(INTDEF + iobase);
		switch (intdef & 0xf) {
			case 9: 
				irq = 9;
				break;
			case 10:
				irq = 10;
				break;
			case 11:
				irq = 11;
				break;  
			case 12:
				irq = 12;
				break;
			case 14:
				irq = 14;
				break;
			case 15:
				irq = 15;
				break;
			default:
				printf("aic7770 at slot %d: illegal "
				    "irq setting %d\n", e_dev->ioconf.slot,
				    intdef);
				continue;
		}
		eisa_add_intr(e_dev, irq);
		eisa_registerdev(e_dev, &ahc_eisa_driver, &kdc_aic7770);
		if(e_dev->id == EISA_DEVICE_ID_ADAPTEC_284xB
		   || e_dev->id == EISA_DEVICE_ID_ADAPTEC_284x) {
			/* Our real parent is the isa bus.  Say so. */
			e_dev->kdc->kdc_parent = &kdc_isa0;
		}
		count++;
	}
	return count;
}

#elif defined(__NetBSD__) || defined(__OpenBSD__)

d68 1
a68 1
#define bootverbose	0
d70 4
a73 4
  
int	ahc_eisa_irq __P((bus_space_tag_t, bus_space_handle_t));
int	ahc_eisa_match __P((struct device *, void *, void *));
void	ahc_eisa_attach __P((struct device *, struct device *, void *));
d77 1
a77 1
	sizeof(struct ahc_data), ahc_eisa_match, ahc_eisa_attach
d85 2
a86 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
d90 6
a95 2

	ahc_reset("ahc_eisa", iot, ioh);
d121 2
a122 2
	struct device *parent;
	void *match, *aux;
d131 1
a131 1
	    strcmp(ea->ea_idstring, "ADP7771")
d133 2
a134 2
	    && strcmp(ea->ea_idstring, "ADP7756") /* not EISA, but VL */
	    && strcmp(ea->ea_idstring, "ADP7757") /* not EISA, but VL */
d136 1
a136 1
	    )
d140 1
a140 1
	    AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
a149 7
#endif /* defined(__NetBSD__) */

#if defined(__FreeBSD__)
static int
aic7770_attach(e_dev)
	struct eisa_device *e_dev;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d152 2
a153 3
	struct device *parent, *self;
	void *aux;
#endif
d155 3
a157 53
	ahc_type type;

#if defined(__FreeBSD__)
	struct ahc_data *ahc;
	resvaddr_t *iospace;
	int unit = e_dev->unit;
	int irq = ffs(e_dev->ioconf.irq) - 1;

	iospace = e_dev->ioconf.ioaddrs.lh_first;

	if(!iospace)
		return -1;

	switch(e_dev->id) {
		case EISA_DEVICE_ID_ADAPTEC_AIC7770:
			type = AHC_AIC7770;
			break;
		case EISA_DEVICE_ID_ADAPTEC_274x:
			type = AHC_274;
			break;          
		case EISA_DEVICE_ID_ADAPTEC_284xB:
		case EISA_DEVICE_ID_ADAPTEC_284x:
			type = AHC_284;
			break;
		default: 
			printf("aic7770_attach: Unknown device type!\n");
			return -1;
			break;
	}

	if(!(ahc = ahc_alloc(unit, iospace->addr, type, AHC_FNONE)))
		return -1;

	eisa_reg_start(e_dev);
	if(eisa_reg_iospace(e_dev, iospace)) {
		ahc_free(ahc);
		return -1;
	}

	/*
	 * The IRQMS bit enables level sensitive interrupts. Only allow
	 * IRQ sharing if it's set.
	 */
	if(eisa_reg_intr(e_dev, irq, ahc_intr, (void *)ahc, &bio_imask,
			 /*shared ==*/ahc->pause & IRQMS)) {
		ahc_free(ahc);
		return -1;
	}
	eisa_reg_end(e_dev);

#elif defined(__NetBSD__) || defined(__OpenBSD__)

	struct ahc_data *ahc = (void *)self;
d165 5
a169 1

d171 1
a171 1
	    AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
d178 1
a178 1
		type = AHC_AIC7770;
d181 1
a181 9
		type = AHC_274;
#if 0
	} else if (strcmp(ea->ea_idstring, "ADP7756") == 0) {
		model = EISA_PRODUCT_ADP7756;
		type = AHC_284;
	} else if (strcmp(ea->ea_idstring, "ADP7757") == 0) {
		model = EISA_PRODUCT_ADP7757;
		type = AHC_284;
#endif
d184 1
a184 1
		      ea->ea_idstring);
d188 7
a194 1
	ahc_construct(ahc, iot, ioh, type, AHC_FNONE);
d197 1
a197 1
		    ahc->sc_dev.dv_xname, irq);
a199 1
#endif /* defined(__NetBSD__) */
d205 1
a205 1
	if(bootverbose) {
d207 3
a209 2
		    ahc_name(ahc),
		    ahc->pause & IRQMS ?  "Level Sensitive" : "Edge Triggered");
d218 21
a238 28
	switch( ahc->type ) {
	    case AHC_AIC7770:
	    case AHC_274:
	    {
		u_char biosctrl = AHC_INB(ahc, HA_274_BIOSCTRL);

		/* Get the primary channel information */
		ahc->flags |= (biosctrl & CHANNEL_B_PRIMARY);

		if((biosctrl & BIOSMODE) == BIOSDISABLED)
			ahc->flags |= AHC_USEDEFAULTS;
		break;
	    }
	    case AHC_284:
	    {
		/* XXX
		 * All values are automagically intialized at
		 * POST for these cards, so we can always rely
		 * on the Scratch Ram values.  However, we should
		 * read the SEEPROM here (Dan has the code to do
		 * it) so we can say what kind of translation the
		 * BIOS is using.  Printing out the geometry could
		 * save a lot of users the grief of failed installs.
		 */
		break;
	    }
	    default:
		break;
d240 7
a246 1

d254 1
a254 1
	 */     
d264 1
a264 2
		if(sblkctl != sblkctl_orig)
		{
d274 1
a274 2
		}
		else
d290 1
a290 10
	if(ahc_init(ahc)){
#if defined(__FreeBSD__)
		ahc_free(ahc);
		/*
		 * The board's IRQ line is not yet enabled so it's safe
		 * to release the irq.
		 */
		eisa_release_intr(e_dev, irq, ahc_intr);
		return -1;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a292 1
#endif
d294 1
a294 1

a299 12
#if defined(__FreeBSD__)
	/*
	 * Enable our interrupt handler.
	 */
	if(eisa_enable_intr(e_dev, irq)) {
		ahc_free(ahc);
		eisa_release_intr(e_dev, irq, ahc_intr);
		return -1;
	}

	e_dev->kdc->kdc_state = DC_BUSY; /* host adapters always busy */
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d305 4
a308 6
	ahc->sc_ih = eisa_intr_establish(ec, ih,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO, ahc_intr, ahc
#ifdef __OpenBSD__
	    , ahc->sc_dev.dv_xname
#endif
	    );
d311 1
a311 1
		    ahc->sc_dev.dv_xname);
a320 1
#endif /* defined(__NetBSD__) */
a324 3
#if defined(__FreeBSD__)
	return 0;
#endif
a325 1

@


1.8.6.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
a3 1

d35 1
a35 1
 *	$Id$
d38 4
a41 2
#include "eisa.h"
#if NEISA > 0
d45 3
d49 2
d54 1
d59 15
d77 1
d81 2
d87 106
d200 1
a200 1
#define bootverbose	1
d202 4
a205 4

int   ahc_eisa_irq __P((bus_space_tag_t, bus_space_handle_t));
int   ahc_eisa_match __P((struct device *, void *, void *));
void  ahc_eisa_attach __P((struct device *, struct device *, void *));
d209 1
a209 1
	sizeof(struct ahc_softc), ahc_eisa_match, ahc_eisa_attach
d217 2
a218 2
bus_space_tag_t iot;
bus_space_handle_t ioh;
d222 2
a223 6
	u_char hcntrl;
	
	/* Pause the card preseving the IRQ type */
	hcntrl = bus_space_read_1(iot, ioh, HCNTRL) & IRQMS;
	bus_space_write_1(iot, ioh, HCNTRL, hcntrl | PAUSE);
	
d249 2
a250 2
struct device *parent;
void *match, *aux;
d259 1
a259 1
		 strcmp(ea->ea_idstring, "ADP7771")
d261 2
a262 2
		 && strcmp(ea->ea_idstring, "ADP7756")	/* not EISA, but VL */
		 && strcmp(ea->ea_idstring, "ADP7757")	/* not EISA, but VL */
d264 1
a264 1
		)
d268 1
a268 1
			  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
d278 7
d287 3
a289 2
struct device *parent, *self;
void *aux;
d291 53
a343 3
	ahc_chip chip;
	u_char channel = 'A'; /* Only one channel */
	struct ahc_softc *ahc = (void *)self;
d351 1
a351 5
	u_int biosctrl;
	u_int scsiconf;
	u_int scsiconf1;
	
	ahc->sc_dmat = ea->ea_dmat;
d353 1
a353 1
			  AHC_EISA_SLOT_OFFSET, AHC_EISA_IOSIZE, 0, &ioh))
d360 1
a360 1
		chip = AHC_AIC7770|AHC_EISA;
d363 9
a371 1
		chip = AHC_AIC7770|AHC_EISA;
d374 1
a374 1
				ea->ea_idstring);
d378 1
a378 7
	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
	
	ahc->channel = 'A';
	ahc->channel_b = 'B';
	if (ahc_reset(ahc) != 0)
		return;
	
d381 1
a381 1
		       ahc->sc_dev.dv_xname, irq);
d384 1
d390 1
a390 1
	if (bootverbose) {
d392 2
a393 3
		       ahc_name(ahc),
		       ahc->pause & IRQMS ?
		       "Level Sensitive" : "Edge Triggered");
d402 28
a429 21
	biosctrl = ahc_inb(ahc, HA_274_BIOSCTRL);
	scsiconf = ahc_inb(ahc, SCSICONF);
	scsiconf1 = ahc_inb(ahc, SCSICONF + 1);
	
	/* Get the primary channel information */
	if ((biosctrl & CHANNEL_B_PRIMARY) != 0)
		ahc->flags |= AHC_CHANNEL_B_PRIMARY;

	if ((biosctrl & BIOSMODE) == BIOSDISABLED) {
		ahc->flags |= AHC_USEDEFAULTS;
	} else if ((ahc->features & AHC_WIDE) != 0) {
		ahc->our_id = scsiconf1 & HWSCSIID;
		if (scsiconf & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_A;
	} else {
		ahc->our_id = scsiconf & HSCSIID;
		ahc->our_id_b = scsiconf1 & HSCSIID;
		if (scsiconf & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_A;
		if (scsiconf1 & TERM_ENB)
			ahc->flags |= AHC_TERM_ENB_B;
d431 1
a431 7
	/*
	 * We have no way to tell, so assume extended
	 * translation is enabled.
	 */
	
	ahc->flags |= AHC_EXTENDED_TRANS_A|AHC_EXTENDED_TRANS_B;
	
d439 1
a439 1
	 */
d449 2
a450 1
		if (sblkctl != sblkctl_orig) {
d460 2
a461 1
		} else
d477 10
a486 1
	if (ahc_init(ahc)) {
d489 1
d491 1
a491 1
 
d497 12
d514 6
a519 4
	ahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
					 ? IST_LEVEL : IST_EDGE,
					 IPL_BIO, ahc_intr, ahc,
					 ahc->sc_dev.dv_xname);
d522 1
a522 1
		       ahc->sc_dev.dv_xname);
d532 1
d537 3
d541 1
@


1.8.6.2
log
@Merge in trunk
@
text
@a53 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d55 1
d59 11
d97 1
a97 1
	switch (irq = (intdef & VECTOR)) {
d155 2
a167 1
	u_int intdef;
d169 1
a169 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ea->ea_dmat;
	ahc->buffer_dmat = ea->ea_dmat;
        ahc->shared_data_dmat = ea->ea_dmat;

d178 1
d181 1
d187 2
a191 5
	ahc->chip = AHC_AIC7770|AHC_EISA;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
a194 5
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;
	
d224 1
a224 1
		ahc->platform_data->channel_b_primary = TRUE;
d260 1
a260 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d262 2
a263 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d270 1
a270 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d282 3
a284 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a294 8
       	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
	
d298 1
a298 1
	ahc_outb(ahc, BCTL, ENABLE);
d305 1
a305 1
	ahc->platform_data->ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d307 1
a307 1
					 IPL_BIO, ahc_platform_intr, ahc,
d309 1
a309 1
	if (ahc->platform_data->ih == NULL) {
a320 2
	
	ahc_intr_enable(ahc, TRUE);
@


1.8.6.3
log
@Merge in -current from about a week ago
@
text
@d54 2
a56 1
#include <dev/ic/aic7xxxvar.h>
a59 1
#define INTDEF			0x5cul	/* Interrupt Definition Register */
d61 3
a63 13
/*
 * Under normal circumstances, these messages are unnecessary
 * and not terribly cosmetic.
 */
#ifdef DEBUG
#define bootverbose	1
#else
#define bootverbose	1
#endif

int   ahc_eisa_irq(bus_space_tag_t, bus_space_handle_t);
int   ahc_eisa_match(struct device *, void *, void *);
void  ahc_eisa_attach(struct device *, struct device *, void *);
d87 1
a87 1
	switch (irq = (intdef & 0xf)) {
a144 2
	ahc_chip chip;
	u_char channel = 'A'; /* Only one channel */
d156 1
d158 15
a172 1
	ahc->sc_dmat = ea->ea_dmat;
a180 1
		chip = AHC_AIC7770|AHC_EISA;
a182 1
		chip = AHC_AIC7770|AHC_EISA;
a187 2

	ahc_construct(ahc, iot, ioh, chip, AHC_FNONE, AHC_AIC7770_FE, channel);
d191 5
d199 5
d233 1
a233 1
		ahc->flags |= AHC_CHANNEL_B_PRIMARY;
d269 1
a269 1
		sblkctl_orig = AHC_INB(ahc, SBLKCTL);
d271 2
a272 2
		AHC_OUTB(ahc, SBLKCTL, sblkctl);
		sblkctl = AHC_INB(ahc, SBLKCTL);
d279 1
a279 1
			AHC_OUTB(ahc, SBLKCTL, sblkctl);
d291 3
a293 3
		u_char hostconf = AHC_INB(ahc, HOSTCONF);
		AHC_OUTB(ahc, BUSSPD, hostconf & DFTHRSH);
		AHC_OUTB(ahc, BUSTIME, (hostconf << 2) & BOFF);
d304 8
d315 1
a315 1
	AHC_OUTB(ahc, BCTL, ENABLE);
d322 1
a322 1
	ahc->sc_ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d324 1
a324 1
					 IPL_BIO, ahc_intr, ahc,
d326 1
a326 1
	if (ahc->sc_ih == NULL) {
d338 2
@


1.8.6.4
log
@Sync the SMP branch with 3.3
@
text
@a53 2
#include <dev/ic/aic7xxx_openbsd.h>
#include <dev/ic/aic7xxx_inline.h>
d55 1
d59 11
d97 1
a97 1
	switch (irq = (intdef & VECTOR)) {
d155 2
a167 1
	u_int intdef;
d169 1
a169 15
	/* 
	 * We really don't allocate our softc, but 
	 * we need to do the initialization. And this 
	 * also allocates the platform_data structure.
	 */
	ahc_alloc(ahc, ahc->sc_dev.dv_xname);
	
	ahc_set_name(ahc, ahc->sc_dev.dv_xname);
	ahc_set_unit(ahc, ahc->sc_dev.dv_unit);
	
	/* set dma tags */
	ahc->parent_dmat = ea->ea_dmat;
	ahc->buffer_dmat = ea->ea_dmat;
        ahc->shared_data_dmat = ea->ea_dmat;

d178 1
d181 1
d187 2
a191 5
	ahc->chip = AHC_AIC7770|AHC_EISA;
	ahc->features = AHC_AIC7770_FE;
	ahc->bugs |= AHC_TMODE_WIDEODD_BUG;
	ahc->flags |= AHC_PAGESCBS;
	
a194 5
	/* See if we are edge triggered */
	intdef = ahc_inb(ahc, INTDEF);
	if ((intdef & EDGE_TRIG) != 0)
		ahc->flags |= AHC_EDGE_INTERRUPT;
	
d224 1
a224 1
		ahc->platform_data->channel_b_primary = TRUE;
d260 1
a260 1
		sblkctl_orig = ahc_inb(ahc, SBLKCTL);
d262 2
a263 2
		ahc_outb(ahc, SBLKCTL, sblkctl);
		sblkctl = ahc_inb(ahc, SBLKCTL);
d270 1
a270 1
			ahc_outb(ahc, SBLKCTL, sblkctl);
d282 3
a284 3
		u_char hostconf = ahc_inb(ahc, HOSTCONF);
		ahc_outb(ahc, BUSSPD, hostconf & DFTHRSH);
		ahc_outb(ahc, BUSTIME, (hostconf << 2) & BOFF);
a294 8
       	/* Special func to force negotiation */
	ahc_force_neg(ahc);

	/*
	 * Link this softc in with all other ahc instances.
	 */
	ahc_softc_insert(ahc);
	
d298 1
a298 1
	ahc_outb(ahc, BCTL, ENABLE);
d305 1
a305 1
	ahc->platform_data->ih = eisa_intr_establish(ec, ih, ahc->pause & IRQMS
d307 1
a307 1
					 IPL_BIO, ahc_platform_intr, ahc,
d309 1
a309 1
	if (ahc->platform_data->ih == NULL) {
a320 2
	
	ahc_intr_enable(ahc, TRUE);
@


1.8.6.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d56 1
d82 1
a82 1
	/* Pause the card preserving the IRQ type */
d158 7
d170 2
d190 1
d212 1
a212 1
	 * useful for debugging irq problems
d233 1
a233 1
		ahc->flags |= AHC_PRIMARY_CHANNEL;
d259 1
a259 1
	 * It's still not clear exactly what is different about the Rev E.
d304 3
d322 5
a326 4
	ahc->ih = eisa_intr_establish(ec, ih,
	    ahc->pause & IRQMS ? IST_LEVEL : IST_EDGE, IPL_BIO,
	    ahc_platform_intr, ahc, ahc->sc_dev.dv_xname);
	if (ahc->ih == NULL) {
@


1.7
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ahc_eisa.c,v 1.10 1996/10/21 22:30:58 thorpej Exp $	*/
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.6 1996/11/12 20:30:08 niklas Exp $
d373 1
a373 1
		panic("ahc_eisa_attach: Unknown device type %s\n",
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 3
d35 1
a35 1
 *	$Id: ahc_eisa.c,v 1.5 1996/10/16 12:38:07 deraadt Exp $
d52 1
a52 1
#include <machine/bus.old.h>
d54 1
a54 1
#endif /* defined(__NetBSD__) */
d175 2
a176 2
				       "irq setting %d\n", e_dev->ioconf.slot,
					intdef);
d193 5
d199 5
a203 1

a211 2
int ahc_eisa_irq __P((bus_chipset_tag_t, bus_io_handle_t));

d216 3
a218 3
ahc_eisa_irq(bc, ioh)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d223 2
a224 2
	ahc_reset("ahc_eisa", bc, ioh);
	intdef = bus_io_read_1(bc, ioh, INTDEF);
d253 2
a254 2
	bus_chipset_tag_t bc = ea->ea_bc;
	bus_io_handle_t ioh;
d267 2
a268 2
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot) + AHC_EISA_SLOT_OFFSET, 
	    AHC_EISA_IOSIZE, &ioh))
d271 1
a271 1
	irq = ahc_eisa_irq(bc, ioh);
d273 1
a273 1
	bus_io_unmap(bc, ioh, AHC_EISA_IOSIZE);
d345 2
a346 2
	bus_chipset_tag_t bc = ea->ea_bc;
	bus_io_handle_t ioh;
d352 2
a353 2
	if (bus_io_map(bc, EISA_SLOT_ADDR(ea->ea_slot) + AHC_EISA_SLOT_OFFSET, 
		       AHC_EISA_IOSIZE, &ioh))
d355 1
a355 1
	if ((irq = ahc_eisa_irq(bc, ioh)) < 0)
d378 1
a378 1
	ahc_construct(ahc, bc, ioh, type, AHC_FNONE);
d381 1
a381 1
		       ahc->sc_dev.dv_xname, irq);
d392 2
a393 3
		       ahc_name(ahc),
		       ahc->pause & IRQMS ?
				"Level Sensitive" : "Edge Triggered");
d522 1
a522 1
		       ahc->sc_dev.dv_xname);
@


1.5
log
@-Wall happiness
@
text
@d32 1
a32 1
 *	$Id: ahc_eisa.c,v 1.4 1996/10/04 02:51:24 deraadt Exp $
d49 1
a49 1
#include <machine/bus.h>
@


1.4
log
@ahc on eisa, netbsd
@
text
@d32 1
a32 1
 *	$Id: ahc_eisa.c,v 1.3 1996/08/21 22:27:24 deraadt Exp $
d199 2
@


1.3
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d32 1
a32 1
 *	$Id: ahc_eisa.c,v 1.2 1996/06/27 21:15:44 shawn Exp $
d247 6
a252 3
	    strcmp(ea->ea_idstring, "ADP7771") &&
	    strcmp(ea->ea_idstring, "ADP7756") && /* XXX - not EISA, but VL */
	    strcmp(ea->ea_idstring, "ADP7757"))	  /* XXX - not EISA, but VL */
d352 1
d359 1
@


1.2
log
@new 2940 driver merged from freebsd sources 960623
@
text
@d32 1
a32 1
 *	$Id: aic7770.c,v 1.29 1996/05/30 07:18:52 gibbs Exp $
d38 1
a38 1
#if NEISA > 0 || defined(__NetBSD__)
d47 1
a47 1
#if defined(__NetBSD__)
d69 1
a69 1
#elif defined(__NetBSD__)
d188 1
a188 1
#elif defined(__NetBSD__)
d269 1
a269 1
#elif defined(__NetBSD__)
d326 1
a326 1
#elif defined(__NetBSD__)
d470 1
a470 1
#elif defined(__NetBSD__)
d492 1
a492 1
#elif defined(__NetBSD__)
@


1.1
log
@sync 0521
@
text
@a0 2
/*	$NetBSD: ahc_eisa.c,v 1.4 1996/05/20 00:55:44 thorpej Exp $	*/

d31 2
d374 1
a374 2
		printf(
		       "%s: Using %s Interrupts\n",
@
