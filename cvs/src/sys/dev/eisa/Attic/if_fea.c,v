head	1.22;
access;
symbols
	OPENBSD_5_4:1.20.0.12
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.20.0.10
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.8
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.6
	OPENBSD_5_0:1.20.0.4
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.18.0.4
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.17.0.20
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.18
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.16
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.14
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.12
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.10
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.8
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.6
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.4
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.2
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.16.0.2
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.15.0.6
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.4
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.2
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.15
	UBC:1.12.0.2
	UBC_BASE:1.12
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.8
	OPENBSD_2_8:1.8.0.6
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.4
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.6.0.8
	OPENBSD_2_6_BASE:1.6
	OPENBSD_2_5:1.6.0.6
	OPENBSD_2_5_BASE:1.6
	OPENBSD_2_4:1.6.0.4
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.6.0.2
	OPENBSD_2_3_BASE:1.6
	OPENBSD_2_2:1.5.0.4
	OPENBSD_2_2_BASE:1.5
	OPENBSD_2_1:1.5.0.2
	OPENBSD_2_1_BASE:1.5
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.22
date	2013.10.28.12.33.32;	author mpi;	state dead;
branches;
next	1.21;

1.21
date	2013.08.07.01.06.27;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.20.07.40.42;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.13.14.24.46;	author jasper;	state Exp;
branches;
next	1.18;

1.18
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.16;

1.16
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.14;

1.14
date	2002.06.02.22.49.59;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.06.19.53.18;	author miod;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.11.20.05.25;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.12.20.33.50;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	99.11.30.04.00.44;	author jason;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.11.23.04.49.29;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	97.11.07.08.06.39;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.28.23.27.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.11.12.20.30.12;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.21.22.27.27;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.06.18.10.20.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.05.26.00.26.55;	author deraadt;	state Exp;
branches;
next	;

1.8.2.1
date	2001.10.31.03.22.41;	author nate;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.11.13.21.09.59;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2002.03.28.12.29.45;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2004.02.19.10.56.14;	author niklas;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.06.05.23.12.37;	author niklas;	state Exp;
branches;
next	;

1.12.2.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@tedu FDDI support and the 3 flavors the driver for DEC devices, even
miod@@ cannot find two boards using the same media.

With precious punctuation review from guenther@@, thanks!

ok deraadt@@, henning@@
@
text
@/*	$OpenBSD: if_fea.c,v 1.21 2013/08/07 01:06:27 bluhm Exp $	*/
/*	$NetBSD: if_fea.c,v 1.9 1996/10/21 22:31:05 thorpej Exp $	*/

/*-
 * Copyright (c) 1995, 1996 Matt Thomas <matt@@3am-software.com>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Id: if_fea.c,v 1.6 1996/06/07 20:02:25 thomas Exp
 */

/*
 * DEC PDQ FDDI Controller
 *
 *	This module support the DEFEA EISA FDDI Controller.
 */


#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/mbuf.h>
#include <sys/protosw.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_types.h>
#include <net/if_dl.h>
#include <net/route.h>

#include "bpfilter.h"
#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#include <net/if_fddi.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/ic/pdqvar.h>
#include <dev/ic/pdqreg.h>

#include <dev/eisa/eisareg.h>
#include <dev/eisa/eisavar.h>
#include <dev/eisa/eisadevs.h>

/*
 *
 */

void pdq_eisa_subprobe(bus_space_tag_t, bus_space_handle_t,
    u_int32_t *, u_int32_t *, u_int32_t *);
void pdq_eisa_devinit(pdq_softc_t *);
int pdq_eisa_match(struct device *, void *, void *);
void pdq_eisa_attach(struct device *, struct device *, void *);

#define	DEFEA_INTRENABLE		0x8	/* level interrupt */
static int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };

void
pdq_eisa_subprobe(bc, iobase, maddr, msize, irq)
	bus_space_tag_t bc;
	bus_space_handle_t iobase;
	u_int32_t *maddr;
	u_int32_t *msize;
	u_int32_t *irq;
{
	if (irq != NULL)
		*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase,
		    PDQ_EISA_IO_CONFIG_STAT_0) & 3];

	*maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)
	    | (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);
	*msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;
}

void
pdq_eisa_devinit(sc)
	pdq_softc_t *sc;
{
	u_int8_t data;
	bus_space_tag_t tag;

	tag = sc->sc_bc;

	/*
	 * Do the standard initialization for the DEFEA registers.
	 */
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1,
	    (sc->sc_iobase >> 8) & 0xF0);
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1,
	    (sc->sc_iobase >> 8) & 0xF0);
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);
	data = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);
#if defined(PDQ_IOMAPPED)
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);
#else
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);
#endif
	data = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);
	PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0,
	    data | DEFEA_INTRENABLE);
}

int
pdq_eisa_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct eisa_attach_args *ea = (struct eisa_attach_args *) aux;

	if (strncmp(ea->ea_idstring, "DEC300", 6) == 0)
		return (1);
	return (0);
}

void
pdq_eisa_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	pdq_softc_t *sc = (pdq_softc_t *) self;
	struct eisa_attach_args *ea = (struct eisa_attach_args *) aux;
	u_int32_t irq, maddr, msize;
	eisa_intr_handle_t ih;
	const char *intrstr;

	sc->sc_iotag = ea->ea_iot;
	bcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);
	sc->sc_if.if_flags = 0;
	sc->sc_if.if_softc = sc;

	/*
	 * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is
	 * an alias for sc_csrhandle.  sc_iobase is used here to
	 * check the card's configuration.
	 */

	if (bus_space_map(sc->sc_iotag, EISA_SLOT_ADDR(ea->ea_slot),
	    EISA_SLOT_SIZE, 0, &sc->sc_iobase)) {
		printf("\n%s: failed to map I/O!\n", sc->sc_dev.dv_xname);
		return;
	}

	pdq_eisa_subprobe(sc->sc_iotag, sc->sc_iobase, &maddr, &msize, &irq);

#if defined(PDQ_IOMAPPED)
	sc->sc_csrtag = sc->sc_iotag;
	sc->sc_csrhandle = sc->sc_iobase;
#else
	if (maddr == 0 || msize == 0) {
		printf("\n%s: error: memory not enabled! ECU reconfiguration"
		    " required\n", sc->sc_dev.dv_xname);
		return;
	}

	if (bus_space_map(sc->sc_csrtag, maddr, msize, 0, &sc->sc_csrhandle)) {
		bus_space_unmap(sc->sc_iotag, sc->sc_iobase, EISA_SLOT_SIZE);
		printf("\n%s: can't map mem space (0x%x-0x%x)!\n",
		    sc->sc_dev.dv_xname, maddr, maddr + msize - 1);
		return;
	}
#endif
	pdq_eisa_devinit(sc);
	sc->sc_pdq = pdq_initialize(sc->sc_bc, sc->sc_membase,
	    sc->sc_if.if_xname, 0, (void *) sc, PDQ_DEFEA);
	if (sc->sc_pdq == NULL) {
		printf("%s: initialization failed\n", sc->sc_dev.dv_xname);
		return;
	}

	if (eisa_intr_map(ea->ea_ec, irq, &ih)) {
		printf("%s: can't map interrupt (%d)\n",
		    sc->sc_dev.dv_xname, irq);
		return;
	}
	intrstr = eisa_intr_string(ea->ea_ec, ih);
	sc->sc_ih = eisa_intr_establish(ea->ea_ec, ih, IST_LEVEL, IPL_NET,
	    (int (*)(void *)) pdq_interrupt, sc->sc_pdq, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: can't establish interrupt", sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	if (intrstr != NULL)
		printf(": interrupting at %s\n", intrstr);

	bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes,
	    sc->sc_arpcom.ac_enaddr, 6);

	pdq_ifattach(sc, NULL);

#if !defined(PDQ_IOMAPPED)
	printf("%s: using iomem 0x%x-0x%x\n", sc->sc_dev.dv_xname, maddr,
	    maddr + msize - 1);
#endif
}

struct cfattach fea_ca = {
	sizeof(pdq_softc_t), pdq_eisa_match, pdq_eisa_attach
};

struct cfdriver fea_cd = {
	NULL, "fea", DV_IFNET
};
@


1.21
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.20 2010/09/20 07:40:42 deraadt Exp $	*/
@


1.20
log
@Stop doing shutdown hooks in network drivers where possible.  We already
take all interfaces down, via their xxstop routines.  Claudio and I have
verified that none of the shutdown hooks do much extra beyond what xxstop
was already doing; it is largely a pile of junk.
ok claudio, some early comments by sthen; also read by matthew, jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.19 2009/08/13 14:24:46 jasper Exp $	*/
a59 1
#include <netinet/in_var.h>
@


1.19
log
@- consistify cfdriver for the ethernet drivers (0 -> NULL)

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.18 2009/03/29 21:53:52 sthen Exp $	*/
a227 5
	sc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset,
	    sc->sc_pdq);
	if (sc->sc_ats == NULL)
		printf("%s: warning: can't establish shutdown hook\n",
		    self->dv_xname);
@


1.18
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.17 2004/05/12 06:35:10 tedu Exp $	*/
d244 1
a244 1
	0, "fea", DV_IFNET
@


1.17
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.16 2004/01/09 21:32:23 brad Exp $	*/
d192 1
a192 1
		printf("\n%s: failed to map memory (0x%x-0x%x)!\n",
d206 1
a206 1
		printf("%s: couldn't map interrupt (%d)\n",
d214 1
a214 1
		printf("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
d231 1
a231 1
		printf("%s: warning: couldn't establish shutdown hook\n",
@


1.16
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.15 2002/06/09 03:14:18 todd Exp $	*/
a54 1
#include <net/bpfdesc.h>
@


1.15
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.14 2002/06/02 22:49:59 deraadt Exp $	*/
a66 2

#include <uvm/uvm_extern.h>
@


1.14
log
@withough -> without
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.13 2002/03/14 01:26:53 millert Exp $	*/
d227 1
a227 1
	    sc->sc_ac.ac_enaddr, 6);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.12 2001/11/06 19:53:18 miod Exp $	*/
d14 1
a14 1
 *    derived from this software withough specific prior written permission
@


1.12
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.11 2001/09/21 17:55:43 miod Exp $	*/
d84 5
a88 5
void pdq_eisa_subprobe	__P((bus_space_tag_t, bus_space_handle_t,
    u_int32_t *, u_int32_t *, u_int32_t *));
void pdq_eisa_devinit	__P((pdq_softc_t *));
int pdq_eisa_match	__P((struct device *, void *, void *));
void pdq_eisa_attach	__P((struct device *, struct device *, void *));
@


1.12.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.12 2001/11/06 19:53:18 miod Exp $	*/
d14 1
a14 1
 *    derived from this software without specific prior written permission
d84 5
a88 5
void pdq_eisa_subprobe(bus_space_tag_t, bus_space_handle_t,
    u_int32_t *, u_int32_t *, u_int32_t *);
void pdq_eisa_devinit(pdq_softc_t *);
int pdq_eisa_match(struct device *, void *, void *);
void pdq_eisa_attach(struct device *, struct device *, void *);
d227 1
a227 1
	    sc->sc_arpcom.ac_enaddr, 6);
@


1.11
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.10 2001/09/11 20:05:25 miod Exp $	*/
d68 1
a68 1
#include <vm/vm.h>
@


1.10
log
@Don't include <vm/vm_kern.h> if you don't need foo_map.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.9 2001/08/12 20:33:50 mickey Exp $	*/
d224 1
a224 1
		printf(": interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.9
log
@absolutely no need to include vm_parm.h after vm.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.8 1999/11/30 04:00:44 jason Exp $	*/
a68 1
#include <vm/vm_kern.h>
@


1.8
log
@more KNF and cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.7 1999/11/23 04:49:29 jason Exp $	*/
a69 1
#include <vm/vm_param.h>
@


1.8.2.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.8 1999/11/30 04:00:44 jason Exp $	*/
d69 2
d226 1
a226 1
		printf(": interrupting at %s\n", intrstr);
@


1.8.2.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d68 1
a68 1
#include <uvm/uvm_extern.h>
@


1.8.2.3
log
@Merge in -current from about a week ago
@
text
@d84 5
a88 5
void pdq_eisa_subprobe(bus_space_tag_t, bus_space_handle_t,
    u_int32_t *, u_int32_t *, u_int32_t *);
void pdq_eisa_devinit(pdq_softc_t *);
int pdq_eisa_match(struct device *, void *, void *);
void pdq_eisa_attach(struct device *, struct device *, void *);
@


1.8.2.4
log
@Sync the SMP branch with 3.3
@
text
@d14 1
a14 1
 *    derived from this software without specific prior written permission
d227 1
a227 1
	    sc->sc_arpcom.ac_enaddr, 6);
@


1.8.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d68 2
@


1.8.2.6
log
@Merge with the trunk
@
text
@d55 1
@


1.7
log
@pretty up kernel printf's
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.6 1997/11/07 08:06:39 niklas Exp $	*/
a44 3
#if defined(__FreeBSD__)
#include <sys/devconf.h>
#elif defined(__bsdi__) || defined(__NetBSD__) || defined(__OpenBSD__)
a45 1
#endif
a65 3
#if defined(__FreeBSD__)
#include <netinet/if_fddi.h>
#else
a66 1
#endif
a71 14
#if defined(__FreeBSD__)
#include <i386/eisa/eisaconf.h>
#include <i386/isa/icu.h>
#include <pci/pdqvar.h>
#include <pci/pdqreg.h>
#elif defined(__bsdi__)
#include <i386/isa/isa.h>
#include <i386/isa/icu.h>
#include <i386/isa/dma.h>
#include <i386/isa/isavar.h>
#include <i386/eisa/eisa.h>
#include <i386/eisa/pdqvar.h>
#include <i386/eisa/pdqreg.h>
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a80 1
#endif
d86 5
a90 6
#if defined(__FreeBSD__)
static pdq_softc_t *pdqs_eisa[16];
#define	PDQ_EISA_UNIT_TO_SOFTC(unit)	(pdqs_eisa[unit])
#define	DEFEA_INTRENABLE		0x8	/* level interrupt */
#define	pdq_eisa_ifwatchdog		NULL
static const int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };
a91 7
#elif defined(__bsdi__)
extern struct cfdriver feacd;
#define	PDQ_EISA_UNIT_TO_SOFTC(unit)	((pdq_softc_t *)feacd.cd_devs[unit])
#define	DEFEA_INTRENABLE		0x28	/* edge interrupt */
static const int pdq_eisa_irqs[4] = { IRQ9, IRQ10, IRQ11, IRQ15 };

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d93 1
a93 2
#define	pdq_eisa_ifwatchdog		NULL
static const int pdq_eisa_irqs[4] = { 9, 10, 11, 15 };
d95 38
d134 1
a134 10
#error unknown system
#endif

#ifndef pdq_eisa_ifwatchdog
static ifnet_ret_t
pdq_eisa_ifwatchdog(
    int unit)
{
    pdq_ifwatchdog(&PDQ_EISA_UNIT_TO_SOFTC(unit)->sc_if);
}
d136 46
d183 1
a183 14
static void
pdq_eisa_subprobe(
    pdq_bus_t bc,
    pdq_bus_ioport_t iobase,
    pdq_uint32_t *maddr,
    pdq_uint32_t *msize,
    pdq_uint32_t *irq)
{
    if (irq != NULL)
	*irq = pdq_eisa_irqs[PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_IO_CONFIG_STAT_0) & 3];
    *maddr = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_0) << 8)
	| (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_CMP_1) << 16);
    *msize = (PDQ_OS_IORD_8(bc, iobase, PDQ_EISA_MEM_ADD_MASK_0) + 4) << 8;
}
d185 3
a187 9
static void
pdq_eisa_devinit(
    pdq_softc_t *sc)
{
    pdq_uint8_t data;
    pdq_bus_t tag;

#if defined(__NetBSD__)
    tag = sc->sc_iotag;
d189 5
a193 2
    tag = sc->sc_bc;
#endif
d195 6
a200 12
    /*
     * Do the standard initialization for the DEFEA registers.
     */
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1, (sc->sc_iobase >> 8) & 0xF0);
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1, (sc->sc_iobase >> 8) & 0xF0);
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);
    data = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);
#if defined(PDQ_IOMAPPED)
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);
#else
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);
d202 7
a208 3
    data = PDQ_OS_IORD_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);
    PDQ_OS_IOWR_8(tag, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0, data | DEFEA_INTRENABLE);
}
d210 14
a223 191
#if defined(__FreeBSD__)
static int pdq_eisa_shutdown(struct kern_devconf *kdc, int force);
static int pdq_eisa_probe(void);
static int pdq_eisa_attach(struct eisa_device *ed);

static unsigned long pdq_eisa_unit;

static struct eisa_driver pdq_eisa_driver = {
    "fea", pdq_eisa_probe, pdq_eisa_attach, NULL, &pdq_eisa_unit
};

DATA_SET(eisadriver_set, pdq_eisa_driver);

static struct kern_devconf kdc_pdq_eisa = {
    0, 0, 0,			/* filled in by dev_attach */
    "fea", 0, { MDDT_EISA, 0, "net" },
    eisa_generic_externalize, 0, pdq_eisa_shutdown, EISA_EXTERNALLEN,
    &kdc_eisa0,			/* parent */
    0,				/* parentdata */
    DC_BUSY,			/* host adapters are always ``in use'' */
    "DEC DEFEA EISA FDDI Controller",
    DC_CLS_NETIF
};

static const char *
pdq_eisa_match(
    eisa_id_t type)
{
    if ((type >> 8) == 0x10a330)
	return kdc_pdq_eisa.kdc_description;
    return NULL;
}

static int
pdq_eisa_probe(
    void)
{
    struct eisa_device *ed = NULL;
    int count;

    for (count = 0; (ed = eisa_match_dev(ed, pdq_eisa_match)) != NULL; count++) {
	pdq_bus_ioport_t iobase = ed->ioconf.slot * EISA_SLOT_SIZE;
	pdq_uint32_t irq, maddr, msize;

	eisa_add_iospace(ed, iobase, 0x200, RESVADDR_NONE);
	pdq_eisa_subprobe(PDQ_BUS_EISA, iobase, &maddr, &msize, &irq);
	eisa_add_mspace(ed, maddr, msize, RESVADDR_NONE);
	eisa_add_intr(ed, irq);
	eisa_registerdev(ed, &pdq_eisa_driver, &kdc_pdq_eisa);
    }
    return count;
}

static void
pdq_eisa_interrupt(
    void *arg)
{
    pdq_softc_t * const sc = (pdq_softc_t *) arg;
    (void) pdq_interrupt(sc->sc_pdq);
}

static int
pdq_eisa_attach(
    struct eisa_device *ed)
{
    pdq_softc_t *sc;
    resvaddr_t *iospace;
    resvaddr_t *mspace;
    int irq = ffs(ed->ioconf.irq) - 1;

    sc = (pdq_softc_t *) malloc(sizeof(*sc), M_DEVBUF, M_WAITOK);
    if (sc == NULL) {
	printf("fea%d: malloc failed!\n", sc->sc_if.if_unit);
	return -1;
    }
    pdqs_eisa[ed->unit] = sc;

    bzero(sc, sizeof(pdq_softc_t));	/* Zero out the softc*/
    sc->sc_if.if_name = "fea";
    sc->sc_if.if_unit = ed->unit;

    if ((iospace = ed->ioconf.ioaddrs.lh_first) == NULL) {
	printf("fea%d: no iospace??\n", sc->sc_if.if_unit);
	return -1;
    }
    if ((mspace = ed->ioconf.maddrs.lh_first) == NULL) {
	printf("fea%d: no memory space??\n", sc->sc_if.if_unit);
	return -1;
    }

    sc->sc_iobase = (pdq_bus_ioport_t) iospace->addr;
    sc->sc_membase = (pdq_bus_memaddr_t) pmap_mapdev(mspace->addr, mspace->size);
    if (sc->sc_membase == NULL) {
	printf("fea%d: failed to map memory 0x%x-0x%x!\n",
	    sc->sc_if.if_unit, mspace->addr, mspace->addr + mspace->size - 1);
	return -1;
    }

    eisa_reg_start(ed);
    if (eisa_reg_iospace(ed, iospace)) {
	printf("fea%d: failed to register iospace 0x%x-0x%x!\n",
	    sc->sc_if.if_unit, iospace->addr, iospace->addr + iospace->size - 1);
	return -1;
    }
    if (eisa_reg_mspace(ed, mspace)) {
	printf("fea%d: failed to register memory 0x%x-0x%x!\n",
	    sc->sc_if.if_unit, mspace->addr, mspace->addr + mspace->size - 1);
	return -1;
    }

    if (eisa_reg_intr(ed, irq, pdq_eisa_interrupt, sc, &net_imask, 1)) {
	printf("fea%d: interrupt registration failed\n", sc->sc_if.if_unit);
	return -1;
    }

    eisa_reg_end(ed);

    pdq_eisa_devinit(sc);
    sc->sc_pdq = pdq_initialize(PDQ_BUS_EISA, sc->sc_membase,
				sc->sc_if.if_name, sc->sc_if.if_unit,
				(void *) sc, PDQ_DEFEA);
    if (sc->sc_pdq == NULL) {
	printf("fea%d: initialization failed\n", sc->sc_if.if_unit);
	return -1;
    }

    if (eisa_enable_intr(ed, irq)) {
	printf("fea%d: failed to enable interrupt\n", sc->sc_if.if_unit);
	return -1;
    }

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);
    pdq_ifattach(sc, pdq_eisa_ifwatchdog);

    ed->kdc->kdc_state = DC_BUSY;	 /* host adapters always busy */

    return 0;
}

static int
pdq_eisa_shutdown(
    struct kern_devconf *kdc,
    int force)
{
    pdq_hwreset(PDQ_EISA_UNIT_TO_SOFTC(kdc->kdc_unit)->sc_pdq);
    (void) dev_detach(kdc);
    return 0;
}
#endif /* __FreeBSD__ */

#if defined(__bsdi__)
static int
pdq_eisa_probe(
    struct device *parent,
    struct cfdata *cf,
    void *aux)
{
    struct isa_attach_args *ia = (struct isa_attach_args *) aux;
    int slot;
    pdq_uint32_t irq, maddr, msize;

    if (isa_bustype != BUS_EISA)
	return 0;

    if ((slot = eisa_match(cf, ia)) == 0)
	return 0;
    ia->ia_iobase = slot << 12;
    ia->ia_iosize = EISA_NPORT;
    eisa_slotalloc(slot);

    pdq_eisa_subprobe(PDQ_BUS_EISA, ia->ia_iobase, &maddr, &msize, &irq);
    if (ia->ia_irq != IRQUNK && irq != ia->ia_irq) {
	printf("fea%d: error: desired IRQ of %d does not match device's actual IRQ (%d),\n",
	    cf->cf_unit, ffs(ia->ia_irq) - 1, ffs(irq) - 1);
	return 0;
    }
    if (ia->ia_irq == IRQUNK) {
	if ((ia->ia_irq = isa_irqalloc(irq)) == 0) {
	    if ((ia->ia_irq = isa_irqalloc(IRQ9|IRQ10|IRQ11|IRQ15)) == 0) {
		printf("fea%d: error: IRQ %d is already in use\n", cf->cf_unit,
		    ffs(irq) - 1);
		return 0;
	    }
	    irq = PDQ_OS_IORD_8(PDQ_BUS_EISA, ia->ia_iobase, PDQ_EISA_IO_CONFIG_STAT_0) & ~3;
	    switch (ia->ia_irq) {
		case IRQ9:  irq |= 0;
		case IRQ10: irq |= 1;
		case IRQ11: irq |= 2;
		case IRQ15: irq |= 3;
	    }
	    PDQ_OS_IOWR_8(PDQ_BUS_EISA, ia->ia_iobase, PDQ_EISA_IO_CONFIG_STAT_0, irq);
d225 2
a226 14
    }
    if (maddr == 0) {
	printf("fea%d: error: memory not enabled! ECU reconfiguration required\n",
	    cf->cf_unit);
	return 0;
    }

    /* EISA bus masters don't use host DMA channels */
    ia->ia_drq = DRQNONE;

    ia->ia_maddr = (caddr_t) maddr;
    ia->ia_msize = msize;
    return 1;
}
d228 2
a229 40
static void
pdq_eisa_attach(
    struct device *parent,
    struct device *self,
    void *aux)
{
    pdq_softc_t *sc = (pdq_softc_t *) self;
    register struct isa_attach_args *ia = (struct isa_attach_args *) aux;
    register struct ifnet *ifp = &sc->sc_if;

    sc->sc_if.if_unit = sc->sc_dev.dv_unit;
    sc->sc_if.if_name = "fea";
    sc->sc_if.if_flags = 0;

    sc->sc_iobase = ia->ia_iobase;

    pdq_eisa_devinit(sc);
    sc->sc_pdq = pdq_initialize(PDQ_BUS_EISA,
				(pdq_bus_memaddr_t) ISA_HOLE_VADDR(ia->ia_maddr),
				sc->sc_if.if_name, sc->sc_if.if_unit,
				(void *) sc, PDQ_DEFEA);
    if (sc->sc_pdq == NULL) {
	printf("fea%d: initialization failed\n", sc->sc_if.if_unit);
	return;
    }

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);

    pdq_ifattach(sc, pdq_eisa_ifwatchdog);

    isa_establish(&sc->sc_id, &sc->sc_dev);

    sc->sc_ih.ih_fun = pdq_interrupt;
    sc->sc_ih.ih_arg = (void *) sc->sc_pdq;
    intr_establish(ia->ia_irq, &sc->sc_ih, DV_NET);

    sc->sc_ats.func = (void (*)(void *)) pdq_hwreset;
    sc->sc_ats.arg = (void *) sc->sc_pdq;
    atshutdown(&sc->sc_ats, ATSH_ADD);
}
d231 1
a231 27
static char *pdq_eisa_ids[] = {
    "DEC3001",	/* 0x0130A310 */
    "DEC3002",	/* 0x0230A310 */
    "DEC3003",	/* 0x0330A310 */
    "DEC3004",	/* 0x0430A310 */
};

struct cfdriver feacd = {
    0, "fea", pdq_eisa_probe, pdq_eisa_attach, DV_IFNET, sizeof(pdq_softc_t),
    pdq_eisa_ids
};
#endif /* __bsdi__ */

#if defined(__NetBSD__) || defined(__OpenBSD__)
static int
pdq_eisa_match(
    struct device *parent,
    void *match,
    void *aux)
{
    const struct eisa_attach_args * const ea = (struct eisa_attach_args *) aux;

    if (strncmp(ea->ea_idstring, "DEC300", 6) == 0)
	return 1;

    return 0;
}
d233 5
a237 81
static void
pdq_eisa_attach(
    struct device *parent,
    struct device *self,
    void *aux)
{
    pdq_softc_t * const sc = (pdq_softc_t *) self;
    struct eisa_attach_args * const ea = (struct eisa_attach_args *) aux;
    pdq_uint32_t irq, maddr, msize;
    eisa_intr_handle_t ih;
    const char *intrstr;

    sc->sc_iotag = ea->ea_iot;
    bcopy(sc->sc_dev.dv_xname, sc->sc_if.if_xname, IFNAMSIZ);
    sc->sc_if.if_flags = 0;
    sc->sc_if.if_softc = sc;

    /*
     * NOTE: sc_bc is an alias for sc_csrtag and sc_membase is
     * an alias for sc_csrhandle.  sc_iobase is used here to
     * check the card's configuration.
     */

    if (bus_space_map(sc->sc_iotag, EISA_SLOT_ADDR(ea->ea_slot),
      EISA_SLOT_SIZE, 0, &sc->sc_iobase)) {
	printf("\n%s: failed to map I/O!\n", sc->sc_dev.dv_xname);
	return;
    }

    pdq_eisa_subprobe(sc->sc_iotag, sc->sc_iobase, &maddr, &msize, &irq);

#if defined(PDQ_IOMAPPED)
    sc->sc_csrtag = sc->sc_iotag;
    sc->sc_csrhandle = sc->sc_iobase;
#else
    if (maddr == 0 || msize == 0) {
	printf("\n%s: error: memory not enabled! ECU reconfiguration required\n",
	    sc->sc_dev.dv_xname);
	return;
    }

    if (bus_space_map(sc->sc_csrtag, maddr, msize, 0, &sc->sc_csrhandle)) {
	bus_space_unmap(sc->sc_iotag, sc->sc_iobase, EISA_SLOT_SIZE);
	printf("\n%s: failed to map memory (0x%x-0x%x)!\n",
	    sc->sc_dev.dv_xname, maddr, maddr + msize - 1);
	return;
    }
#endif
    pdq_eisa_devinit(sc);
    sc->sc_pdq = pdq_initialize(sc->sc_bc, sc->sc_membase,
				sc->sc_if.if_xname, 0,
				(void *) sc, PDQ_DEFEA);
    if (sc->sc_pdq == NULL) {
	printf("%s: initialization failed\n", sc->sc_dev.dv_xname);
	return;
    }

    if (eisa_intr_map(ea->ea_ec, irq, &ih)) {
	printf("%s: couldn't map interrupt (%d)\n", sc->sc_dev.dv_xname, irq);
	return;
    }
    intrstr = eisa_intr_string(ea->ea_ec, ih);
    sc->sc_ih = eisa_intr_establish(ea->ea_ec, ih, IST_LEVEL, IPL_NET,
	(int (*)(void *)) pdq_interrupt, sc->sc_pdq, sc->sc_dev.dv_xname);
    if (sc->sc_ih == NULL) {
	printf("%s: couldn't establish interrupt", sc->sc_dev.dv_xname);
	if (intrstr != NULL)
	    printf(" at %s", intrstr);
	printf("\n");
	return;
    }
    if (intrstr != NULL)
	printf(": interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);

    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);

    pdq_ifattach(sc, pdq_eisa_ifwatchdog);

    sc->sc_ats = shutdownhook_establish((void (*)(void *)) pdq_hwreset, sc->sc_pdq);
    if (sc->sc_ats == NULL)
	printf("%s: warning: couldn't establish shutdown hook\n", self->dv_xname);
d239 2
a240 2
    printf("%s: using iomem 0x%x-0x%x\n", sc->sc_dev.dv_xname, maddr,
	maddr + msize - 1);
d245 1
a245 1
    sizeof(pdq_softc_t), pdq_eisa_match, pdq_eisa_attach
d249 1
a249 1
    0, "fea", DV_IFNET
a250 1
#endif
@


1.6
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: if_fea.c,v 1.9 1996/10/21 22:31:05 thorpej Exp $	*/
a517 4
    bcopy((caddr_t) sc->sc_pdq->pdq_hwaddr.lanaddr_bytes, sc->sc_ac.ac_enaddr, 6);

    pdq_ifattach(sc, pdq_eisa_ifwatchdog);

d532 7
a545 2
    if (intrstr != NULL)
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.5
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
@


1.4
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$NetBSD: if_fea.c,v 1.3.2.2 1996/06/09 23:34:52 cgd Exp $	*/
d94 1
a94 1
#include <machine/bus.old.h>
d159 7
d170 5
a174 5
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_FUNCTION_CTRL, 0x23);
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_IO_CMP_1_1, (sc->sc_iobase >> 8) & 0xF0);
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_IO_CMP_0_1, (sc->sc_iobase >> 8) & 0xF0);
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_SLOT_CTRL, 0x01);
    data = PDQ_OS_IORD_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF);
d176 1
a176 1
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data & ~1);
d178 1
a178 1
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_BURST_HOLDOFF, data | 1);
d180 2
a181 2
    data = PDQ_OS_IORD_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0);
    PDQ_OS_IOWR_8(sc->sc_bc, sc->sc_iobase, PDQ_EISA_IO_CONFIG_STAT_0, data | DEFEA_INTRENABLE);
d278 1
a278 1
	       sc->sc_if.if_unit, mspace->addr, mspace->addr + mspace->size - 1);
d285 1
a285 1
	       sc->sc_if.if_unit, iospace->addr, iospace->addr + iospace->size - 1);
d290 1
a290 1
	       sc->sc_if.if_unit, mspace->addr, mspace->addr + mspace->size - 1);
d357 1
a357 2
	       cf->cf_unit,
	       ffs(ia->ia_irq) - 1, ffs(irq) - 1);
d364 1
a364 1
		       ffs(irq) - 1);
d379 1
a379 1
	       cf->cf_unit);
d472 1
a472 1
    sc->sc_bc = ea->ea_bc;
d477 8
a484 1
    if (bus_io_map(sc->sc_bc, EISA_SLOT_ADDR(ea->ea_slot), EISA_SLOT_SIZE, &sc->sc_iobase)) {
d489 1
a489 1
    pdq_eisa_subprobe(sc->sc_bc, sc->sc_iobase, &maddr, &msize, &irq);
d491 4
a494 1
#if !defined(PDQ_IOMAPPED)
d497 1
a497 1
	       sc->sc_dev.dv_xname);
d501 2
a502 2
    if (bus_mem_map(sc->sc_bc, maddr, msize, 0, &sc->sc_membase)) {
	bus_io_unmap(sc->sc_bc, sc->sc_iobase, EISA_SLOT_SIZE);
@


1.3
log
@check for __OpenBSD__, prep for tossing __NetBSD__?
@
text
@d94 1
a94 1
#include <machine/bus.h>
@


1.2
log
@add missing newline in printf.  pointed out by Matt Thomas
@
text
@d46 1
a46 1
#elif defined(__bsdi__) || defined(__NetBSD__)
d92 1
a92 1
#elif defined(__NetBSD__)
d121 1
a121 1
#elif defined(__NetBSD__)
d439 1
a439 1
#if defined(__NetBSD__)
@


1.1
log
@sync 0521
@
text
@d1 1
a1 1
/*	$NetBSD: if_fea.c,v 1.3 1996/05/20 15:52:32 thorpej Exp $	*/
d26 1
a26 1
 * Id: if_fea.c,v 1.5 1996/05/17 01:15:18 thomas Exp
d487 2
a488 1
	printf("\n%s: failed to map memory!\n", sc->sc_dev.dv_xname);
d522 4
@
