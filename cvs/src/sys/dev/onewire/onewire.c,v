head	1.17;
access;
symbols
	OPENBSD_6_2:1.17.0.4
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.12
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.8
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.6
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.4
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.15.0.4
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.12.0.8
	OPENBSD_5_3_BASE:1.12
	OPENBSD_5_2:1.12.0.6
	OPENBSD_5_2_BASE:1.12
	OPENBSD_5_1_BASE:1.12
	OPENBSD_5_1:1.12.0.4
	OPENBSD_5_0:1.12.0.2
	OPENBSD_5_0_BASE:1.12
	OPENBSD_4_9:1.11.0.6
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.4
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.11.0.2
	OPENBSD_4_7_BASE:1.11
	OPENBSD_4_6:1.10.0.6
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.2
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.2.0.2
	OPENBSD_4_0_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2017.04.03.16.10.00;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	iirsjYYVIl178kMI;

1.16
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.15;
commitid	uzzBR7hz9ncd4O6G;

1.15
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.14;
commitid	OBNa5kfxQ2UXoiIw;

1.14
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.12;

1.12
date	2011.07.03.15.47.16;	author matthew;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.02.05.27.12;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.04.07.22.50.41;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.10.09.17.06.18;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2006.10.08.21.12.51;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2006.09.30.17.45.31;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2006.09.30.15.52.21;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2006.09.30.08.50.57;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2006.09.29.19.38.52;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.03.18.48.13;	author grange;	state Exp;
branches;
next	1.1;

1.1
date	2006.03.04.16.27.03;	author grange;	state Exp;
branches;
next	;


desc
@@


1.17
log
@provide size to free(9)
@
text
@/*	$OpenBSD: onewire.c,v 1.16 2014/09/14 14:17:25 jsg Exp $	*/

/*
 * Copyright (c) 2006 Alexander Yurchenko <grange@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * 1-Wire bus driver.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/queue.h>
#include <sys/rwlock.h>

#include <dev/onewire/onewirereg.h>
#include <dev/onewire/onewirevar.h>

#ifdef ONEWIRE_DEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

#define ONEWIRE_MAXDEVS		16
#define ONEWIRE_SCANTIME	3

struct onewire_softc {
	struct device			sc_dev;

	struct onewire_bus *		sc_bus;
	struct rwlock			sc_lock;
	struct proc *			sc_thread;
	TAILQ_HEAD(, onewire_device)	sc_devs;

	int				sc_dying;
	int				sc_flags;
	u_int64_t			sc_rombuf[ONEWIRE_MAXDEVS];
};

struct onewire_device {
	TAILQ_ENTRY(onewire_device)	d_list;
	struct device *			d_dev;	/* may be NULL */
	u_int64_t			d_rom;
	int				d_present;
};

int	onewire_match(struct device *, void *, void *);
void	onewire_attach(struct device *, struct device *, void *);
int	onewire_detach(struct device *, int);
int	onewire_activate(struct device *, int);
int	onewire_print(void *, const char *);

void	onewire_thread(void *);
void	onewire_createthread(void *);
void	onewire_scan(struct onewire_softc *);

struct cfattach onewire_ca = {
	sizeof(struct onewire_softc),
	onewire_match,
	onewire_attach,
	onewire_detach,
	onewire_activate
};

struct cfdriver onewire_cd = {
	NULL, "onewire", DV_DULL
};

int
onewire_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	return (strcmp(cf->cf_driver->cd_name, "onewire") == 0);
}

void
onewire_attach(struct device *parent, struct device *self, void *aux)
{
	struct onewire_softc *sc = (struct onewire_softc *)self;
	struct onewirebus_attach_args *oba = aux;

	sc->sc_bus = oba->oba_bus;
	sc->sc_flags = oba->oba_flags;
	rw_init(&sc->sc_lock, sc->sc_dev.dv_xname);
	TAILQ_INIT(&sc->sc_devs);

	printf("\n");

	if (sc->sc_flags & ONEWIRE_SCAN_NOW) {
		onewire_scan(sc);
		if (sc->sc_flags & ONEWIRE_NO_PERIODIC_SCAN)
			return;
	}

	kthread_create_deferred(onewire_createthread, sc);
}

int
onewire_detach(struct device *self, int flags)
{
	struct onewire_softc *sc = (struct onewire_softc *)self;

	sc->sc_dying = 1;
	if (sc->sc_thread != NULL) {
		wakeup(sc->sc_thread);
		tsleep(&sc->sc_dying, PWAIT, "owdt", 0);
	}

	return (config_detach_children(self, flags));
}

int
onewire_activate(struct device *self, int act)
{
	struct onewire_softc *sc = (struct onewire_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}

	return (config_activate_children(self, act));
}

int
onewire_print(void *aux, const char *pnp)
{
	struct onewire_attach_args *oa = aux;
	const char *famname;

	if (pnp == NULL)
		printf(" ");

	famname = onewire_famname(ONEWIRE_ROM_FAMILY_TYPE(oa->oa_rom));
	if (famname == NULL)
		printf("family 0x%02x", ONEWIRE_ROM_FAMILY_TYPE(oa->oa_rom));
	else
		printf("\"%s\"", famname);
	printf(" sn %012llx", ONEWIRE_ROM_SN(oa->oa_rom));

	if (pnp != NULL)
		printf(" at %s", pnp);

	return (UNCONF);
}

int
onewirebus_print(void *aux, const char *pnp)
{
	if (pnp != NULL)
		printf("onewire at %s", pnp);

	return (UNCONF);
}

int
onewire_lock(void *arg, int flags)
{
	struct onewire_softc *sc = arg;
	int lflags = RW_WRITE;

	if (flags & ONEWIRE_NOWAIT)
		lflags |= RW_NOSLEEP;

	return (rw_enter(&sc->sc_lock, lflags));
}

void
onewire_unlock(void *arg)
{
	struct onewire_softc *sc = arg;

	rw_exit(&sc->sc_lock);
}

int
onewire_reset(void *arg)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;

	return (bus->bus_reset(bus->bus_cookie));
}

int
onewire_bit(void *arg, int value)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;

	return (bus->bus_bit(bus->bus_cookie, value));
}

int
onewire_read_byte(void *arg)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	u_int8_t value = 0;
	int i;

	if (bus->bus_read_byte != NULL)
		return (bus->bus_read_byte(bus->bus_cookie));

	for (i = 0; i < 8; i++)
		value |= (bus->bus_bit(bus->bus_cookie, 1) << i);

	return (value);
}

void
onewire_write_byte(void *arg, int value)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	int i;

	if (bus->bus_write_byte != NULL)
		return (bus->bus_write_byte(bus->bus_cookie, value));

	for (i = 0; i < 8; i++)
		bus->bus_bit(bus->bus_cookie, (value >> i) & 0x1);
}

void
onewire_read_block(void *arg, void *buf, int len)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	u_int8_t *p = buf;

	if (bus->bus_read_block != NULL)
		return (bus->bus_read_block(bus->bus_cookie, buf, len));

	while (len--)
		*p++ = onewire_read_byte(arg);
}

void
onewire_write_block(void *arg, const void *buf, int len)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	const u_int8_t *p = buf;

	if (bus->bus_write_block != NULL)
		return (bus->bus_write_block(bus->bus_cookie, buf, len));

	while (len--)
		onewire_write_byte(arg, *p++);
}

int
onewire_triplet(void *arg, int dir)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	int rv;

	if (bus->bus_triplet != NULL)
		return (bus->bus_triplet(bus->bus_cookie, dir));

	rv = bus->bus_bit(bus->bus_cookie, 1);
	rv <<= 1;
	rv |= bus->bus_bit(bus->bus_cookie, 1);

	switch (rv) {
	case 0x0:
		bus->bus_bit(bus->bus_cookie, dir);
		break;
	case 0x1:
		bus->bus_bit(bus->bus_cookie, 0);
		break;
	default:
		bus->bus_bit(bus->bus_cookie, 1);
	}

	return (rv);
}

void
onewire_matchrom(void *arg, u_int64_t rom)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	int i;

	if (bus->bus_matchrom != NULL)
		return (bus->bus_matchrom(bus->bus_cookie, rom));

	onewire_write_byte(arg, ONEWIRE_CMD_MATCH_ROM);
	for (i = 0; i < 8; i++)
		onewire_write_byte(arg, (rom >> (i * 8)) & 0xff);
}

int
onewire_search(void *arg, u_int64_t *buf, int size, u_int64_t startrom)
{
	struct onewire_softc *sc = arg;
	struct onewire_bus *bus = sc->sc_bus;
	int search = 1, count = 0, lastd = -1, dir, rv, i, i0;
	u_int64_t mask, rom = startrom, lastrom;
	u_int8_t data[8];

	if (bus->bus_search != NULL)
		return (bus->bus_search(bus->bus_cookie, buf, size, rom));

	while (search && count < size) {
		/* XXX: yield processor */
		tsleep(sc, PWAIT, "owscan", hz / 10);

		/*
		 * Start new search. Go through the previous path to
		 * the point we made a decision last time and make an
		 * opposite decision. If we didn't make any decision
		 * stop searching.
		 */
		lastrom = rom;
		rom = 0;
		onewire_lock(sc, 0);
		onewire_reset(sc);
		onewire_write_byte(sc, ONEWIRE_CMD_SEARCH_ROM);
		for (i = 0, i0 = -1; i < 64; i++) {
			dir = (lastrom >> i) & 0x1;
			if (i == lastd)
				dir = 1;
			else if (i > lastd)
				dir = 0;
			rv = onewire_triplet(sc, dir);
			switch (rv) {
			case 0x0:
				if (i != lastd && dir == 0)
					i0 = i;
				mask = dir;
				break;
			case 0x1:
				mask = 0;
				break;
			case 0x2:
				mask = 1;
				break;
			default:
				DPRINTF(("%s: search triplet error 0x%x, "
				    "step %d\n",
				    sc->sc_dev.dv_xname, rv, i));
				onewire_unlock(sc);
				return (-1);
			}
			rom |= (mask << i);
		}
		onewire_unlock(sc);

		if ((lastd = i0) == -1)
			search = 0;

		if (rom == 0)
			continue;

		/*
		 * The last byte of the ROM code contains a CRC calculated
		 * from the first 7 bytes. Re-calculate it to make sure
		 * we found a valid device.
		 */
		for (i = 0; i < 8; i++)
			data[i] = (rom >> (i * 8)) & 0xff;
		if (onewire_crc(data, 7) != data[7])
			continue;

		buf[count++] = rom;
	}

	return (count);
}

void
onewire_thread(void *arg)
{
	struct onewire_softc *sc = arg;

	while (!sc->sc_dying) {
		onewire_scan(sc);
		if (sc->sc_flags & ONEWIRE_NO_PERIODIC_SCAN)
			break;
		tsleep(sc->sc_thread, PWAIT, "owidle", ONEWIRE_SCANTIME * hz);
	}

	sc->sc_thread = NULL;
	wakeup(&sc->sc_dying);
	kthread_exit(0);
}

void
onewire_createthread(void *arg)
{
	struct onewire_softc *sc = arg;

	if (kthread_create(onewire_thread, sc, &sc->sc_thread,
	    sc->sc_dev.dv_xname) != 0)
		printf("%s: can't create kernel thread\n",
		    sc->sc_dev.dv_xname);
}

void
onewire_scan(struct onewire_softc *sc)
{
	struct onewire_device *d, *next, *nd;
	struct onewire_attach_args oa;
	struct device *dev;
	int present;
	u_int64_t rom;
	int i, rv;

	/*
	 * Mark all currently present devices as absent before
	 * scanning. This allows to find out later which devices
	 * have been disappeared.
	 */
	TAILQ_FOREACH(d, &sc->sc_devs, d_list)
		d->d_present = 0;

	/*
	 * Reset the bus. If there's no presence pulse don't search
	 * for any devices.
	 */
	onewire_lock(sc, 0);
	rv = onewire_reset(sc);
	onewire_unlock(sc);
	if (rv != 0) {
		DPRINTF(("%s: no presence pulse\n", sc->sc_dev.dv_xname));
		goto out;
	}

	/* Scan the bus */
	if ((rv = onewire_search(sc, sc->sc_rombuf, ONEWIRE_MAXDEVS, 0)) == -1)
		return;

	for (i = 0; i < rv; i++) {
		rom = sc->sc_rombuf[i];

		/*
		 * Go through the list of attached devices to see if we
		 * found a new one.
		 */
		present = 0;
		TAILQ_FOREACH(d, &sc->sc_devs, d_list) {
			if (d->d_rom == rom) {
				d->d_present = 1;
				present = 1;
				break;
			}
		}
		if (!present) {
			nd = malloc(sizeof(struct onewire_device),
			    M_DEVBUF, M_NOWAIT);
			if (nd == NULL)
				continue;

			bzero(&oa, sizeof(oa));
			oa.oa_onewire = sc;
			oa.oa_rom = rom;
			dev = config_found(&sc->sc_dev, &oa, onewire_print);

			nd->d_dev = dev;
			nd->d_rom = rom;
			nd->d_present = 1;
			TAILQ_INSERT_TAIL(&sc->sc_devs, nd, d_list);
		}
	}

out:
	/* Detach disappeared devices */
	TAILQ_FOREACH_SAFE(d, &sc->sc_devs, d_list, next) {
		if (!d->d_present) {
			if (d->d_dev != NULL)
				config_detach(d->d_dev, DETACH_FORCE);
			TAILQ_REMOVE(&sc->sc_devs, d, d_list);
			free(d, M_DEVBUF, sizeof *d);
		}
	}
}
@


1.16
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.15 2014/07/12 18:48:51 tedu Exp $	*/
d496 1
a496 1
			free(d, M_DEVBUF, 0);
@


1.15
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.14 2013/11/18 20:21:51 deraadt Exp $	*/
a28 1
#include <sys/proc.h>
@


1.14
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.13 2013/04/10 01:35:55 guenther Exp $	*/
d497 1
a497 1
			free(d, M_DEVBUF);
@


1.13
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.12 2011/07/03 15:47:16 matthew Exp $	*/
d418 1
a418 1
	    "%s", sc->sc_dev.dv_xname) != 0)
@


1.12
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.11 2009/10/13 19:33:16 pirofti Exp $	*/
d492 1
a492 3
	for (d = TAILQ_FIRST(&sc->sc_devs);
	    d != TAILQ_END(&sc->sc_dev); d = next) {
		next = TAILQ_NEXT(d, d_list);
@


1.11
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.10 2009/01/02 05:27:12 miod Exp $	*/
a136 2
	case DVACT_ACTIVATE:
		break;
@


1.10
log
@Remember the id of all devices found, not only those for which a driver
has attached. Prevents spurious "not configured" messages at every bus
rescan.

Prodded by and ok fries@@
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.9 2008/04/07 22:50:41 miod Exp $	*/
d68 1
a68 1
int	onewire_activate(struct device *, enum devact);
d132 1
a132 1
onewire_activate(struct device *self, enum devact act)
@


1.9
log
@Allow a 1-Wire controller to request an immediate scan, and also to prevent
periodic scans.

ok grange@@ (until this gets replaced with a proper notification mechanism
to avoid unnecessary bus polling).
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.8 2007/10/09 17:06:18 gilles Exp $	*/
d60 1
a60 1
	struct device *			d_dev;
d475 5
d483 1
a483 3
			if ((dev = config_found(&sc->sc_dev, &oa,
			    onewire_print)) == NULL)
				continue;
a484 4
			nd = malloc(sizeof(struct onewire_device),
			    M_DEVBUF, M_NOWAIT);
			if (nd == NULL)
				continue;
d498 2
a499 1
			config_detach(d->d_dev, DETACH_FORCE);
@


1.8
log
@MALLOC -> malloc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.7 2006/10/08 21:12:51 grange Exp $	*/
d54 1
d102 1
d108 6
d404 2
@


1.7
log
@Rework bus scanning code so that most of work could be offloaded
the hardware. And fix another bug in the search algorithm.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.6 2006/09/30 17:45:31 grange Exp $	*/
d472 2
a473 2
			MALLOC(nd, struct onewire_device *,
			    sizeof(struct onewire_device), M_DEVBUF, M_NOWAIT);
d491 1
a491 1
			FREE(d, M_DEVBUF);
@


1.6
log
@Reduce max number of devices per bus to 16.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.5 2006/09/30 15:52:21 grange Exp $	*/
d54 1
a112 1
	int rv;
d120 1
a120 5
	onewire_lock(sc, 0);
	rv = config_detach_children(self, flags);
	onewire_unlock(sc);

	return (rv);
d310 2
a311 2
void
onewire_thread(void *arg)
d314 3
a316 31

	while (!sc->sc_dying) {
		onewire_scan(sc);
		tsleep(sc->sc_thread, PWAIT, "owidle", ONEWIRE_SCANTIME * hz);
	}

	sc->sc_thread = NULL;
	wakeup(&sc->sc_dying);
	kthread_exit(0);
}

void
onewire_createthread(void *arg)
{
	struct onewire_softc *sc = arg;

	if (kthread_create(onewire_thread, sc, &sc->sc_thread,
	    "%s", sc->sc_dev.dv_xname) != 0)
		printf("%s: can't create kernel thread\n",
		    sc->sc_dev.dv_xname);
}

void
onewire_scan(struct onewire_softc *sc)
{
	struct onewire_device *d, *next, *nd;
	struct onewire_attach_args oa;
	struct device *dev;
	int search = 1, count = 0, present;
	int dir, rv;
	u_int64_t mask, rom = 0, lastrom;
a317 1
	int i, i0, lastd = -1;
d319 2
a320 2
	TAILQ_FOREACH(d, &sc->sc_devs, d_list)
		d->d_present = 0;
d322 1
a322 1
	while (search && count++ < ONEWIRE_MAXDEVS) {
a326 12
		 * Reset the bus. If there's no presence pulse
		 * don't search for any devices.
		 */
		onewire_lock(sc, 0);
		if (onewire_reset(sc) != 0) {
			DPRINTF(("%s: scan: no presence pulse\n",
			    sc->sc_dev.dv_xname));
			onewire_unlock(sc);
			break;
		}

		/*
a331 1
		search = 0;
d334 2
d346 2
a347 5
				if (i != lastd) {
					if (dir == 0)
						i0 = i;
					search = 1;
				}
d357 1
a357 1
				DPRINTF(("%s: scan: triplet error 0x%x, "
d361 1
a361 1
				return;
a364 1
		lastd = i0;
d367 3
d383 69
d483 1
a484 1
	onewire_lock(sc, 0);
a493 1
	onewire_unlock(sc);
@


1.5
log
@Allow to offload the match rom command to hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.4 2006/09/30 08:50:57 grange Exp $	*/
d42 1
a42 1
#define ONEWIRE_MAXDEVS		256
@


1.4
log
@Convert from using lockmgr to rwlock.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.3 2006/09/29 19:38:52 grange Exp $	*/
d302 2
d305 3
@


1.3
log
@Extend bus master interface so that block read/write operations
can be offloaded to hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.2 2006/08/03 18:48:13 grange Exp $	*/
a27 1
#include <sys/lock.h>
d31 1
d49 1
a49 1
	struct lock			sc_lock;
d100 1
a100 1
	lockinit(&sc->sc_lock, PRIBIO, "owlock", 0, 0);
d178 1
a178 1
	int lflags = LK_EXCLUSIVE;
d181 1
a181 1
		lflags |= LK_NOWAIT;
d183 1
a183 1
	return (lockmgr(&sc->sc_lock, lflags, NULL));
d191 1
a191 1
	lockmgr(&sc->sc_lock, LK_RELEASE, NULL);
@


1.2
log
@Fix a nasty bug in the search algorithm, i was just lucky not to spot it
before. Problem found and patch provided by Jeff Rizzo <riz@@NetBSD.org>
a long long time ago. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: onewire.c,v 1.1 2006/03/04 16:27:03 grange Exp $	*/
d243 28
a296 18
}

void
onewire_read_block(void *arg, void *buf, int len)
{
	u_int8_t *p = buf;

	while (len--)
		*p++ = onewire_read_byte(arg);
}

void
onewire_write_block(void *arg, const void *buf, int len)
{
	const u_int8_t *p = buf;

	while (len--)
		onewire_write_byte(arg, *p++);
@


1.1
log
@Dallas 1-Wire bus support. Includes the following drivers:

gpioow(4)	1-Wire bus bit-banging through GPIO pin
onewire(4)	1-Wire bus driver
owid(4)		1-Wire ID family type device
owtemp(4)	1-Wire temperature family type device

Drivers for RS-232 and USB bus masters will follow.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d335 1
a335 1
	int i, i0 = -1;
d366 1
a366 1
		for (i = 0; i < 64; i++) {
d368 4
a371 2
			if (i == i0)
				dir = !dir;
d375 3
a377 2
				if (i != i0) {
					i0 = i;
d397 1
@

