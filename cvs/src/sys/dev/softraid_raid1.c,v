head	1.65;
access;
symbols
	OPENBSD_6_2:1.65.0.4
	OPENBSD_6_2_BASE:1.65
	OPENBSD_6_1:1.65.0.6
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.2
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.63.0.4
	OPENBSD_5_8_BASE:1.63
	OPENBSD_5_7:1.60.0.4
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.57.0.4
	OPENBSD_5_6_BASE:1.57
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.40.0.2
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.31.0.4
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.2
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.25.0.2
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.16.0.4
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.7.0.2
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.6.0.2
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.65
date	2016.04.12.16.26.54;	author krw;	state Exp;
branches;
next	1.64;
commitid	ATfj2h1H9b585gss;

1.64
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.63;
commitid	1ISokwrtQ24zRrhW;

1.63
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.62;
commitid	TJiPw62Nfq0KhqBx;

1.62
date	2015.07.19.21.06.04;	author krw;	state Exp;
branches;
next	1.61;
commitid	DQBduvhX3UJc1lbB;

1.61
date	2015.07.19.17.04.31;	author krw;	state Exp;
branches;
next	1.60;
commitid	WthDQr0yYlXab4V8;

1.60
date	2015.01.27.10.12.45;	author dlg;	state Exp;
branches;
next	1.59;
commitid	MDflvHKF0sUIDjfe;

1.59
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.58;
commitid	Z1vcFtHO8wRH0yRt;

1.58
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.57;
commitid	uzzBR7hz9ncd4O6G;

1.57
date	2014.07.12.07.39.12;	author blambert;	state Exp;
branches;
next	1.56;
commitid	d0e1MLWWcCZIgJ1z;

1.56
date	2014.01.22.04.24.29;	author jsing;	state Exp;
branches;
next	1.55;

1.55
date	2014.01.21.10.25.25;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.52;

1.52
date	2013.05.21.15.01.53;	author jsing;	state Exp;
branches;
next	1.51;

1.51
date	2013.05.21.14.25.23;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.21.13.00.21;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2013.03.31.13.31.44;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2013.03.31.11.12.06;	author jsing;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.29.15.26.45;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.29.12.00.59;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2013.03.29.11.46.45;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.27.14.30.11;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2013.03.25.16.01.49;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2013.01.18.05.59.28;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2013.01.17.03.37.31;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2013.01.16.09.21.50;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2013.01.16.07.06.29;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.01.16.06.29.14;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2012.01.22.11.13.32;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2011.12.25.15.16.21;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2010.11.06.23.01.56;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.01.19.31.04;	author thib;	state Exp;
branches;
next	1.23;

1.23
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.22;

1.22
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.20;

1.20
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.18;

1.18
date	2009.07.12.16.34.58;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2009.07.12.16.33.02;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2009.06.24.12.06.00;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.18.15.55.15;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.02.21.23.11;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.02.16.32.23;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.02.11.38.51;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.02.05.49.35;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.02.00.58.16;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2009.04.28.02.54.53;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2008.07.19.22.41.58;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2008.02.05.16.49.25;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2008.02.05.16.15.35;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.24.19.58.08;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.24.17.50.17;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.27.17.21.52;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.65
log
@No need to rescan chunks in each discipline to find appropriate
volume sector size.  Determine volume sector size in sr_meta_init().

Pointed out, tweaked and ok jsing@@
@
text
@/* $OpenBSD: softraid_raid1.c,v 1.64 2016/04/04 18:48:39 krw Exp $ */
/*
 * Copyright (c) 2007 Marco Peereboom <marco@@peereboom.us>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/task.h>
#include <sys/conf.h>
#include <sys/uio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>

/* RAID 1 functions. */
int	sr_raid1_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_raid1_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_raid1_init(struct sr_discipline *sd);
int	sr_raid1_rw(struct sr_workunit *);
int	sr_raid1_wu_done(struct sr_workunit *);
void	sr_raid1_set_chunk_state(struct sr_discipline *, int, int);
void	sr_raid1_set_vol_state(struct sr_discipline *);

/* Discipline initialisation. */
void
sr_raid1_discipline_init(struct sr_discipline *sd)
{
	/* Fill out discipline members. */
	sd->sd_type = SR_MD_RAID1;
	strlcpy(sd->sd_name, "RAID 1", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE |
	    SR_CAP_REBUILD | SR_CAP_REDUNDANT;
	sd->sd_max_wu = SR_RAID1_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_assemble = sr_raid1_assemble;
	sd->sd_create = sr_raid1_create;
	sd->sd_scsi_rw = sr_raid1_rw;
	sd->sd_scsi_wu_done = sr_raid1_wu_done;
	sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
	sd->sd_set_vol_state = sr_raid1_set_vol_state;
}

int
sr_raid1_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	if (no_chunk < 2) {
		sr_error(sd->sd_sc, "%s requires two or more chunks",
		    sd->sd_name);
		return EINVAL;
	}

	sd->sd_meta->ssdi.ssd_size = coerced_size;

	return sr_raid1_init(sd);
}

int
sr_raid1_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{
	return sr_raid1_init(sd);
}

int
sr_raid1_init(struct sr_discipline *sd)
{
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;

	return 0;
}

void
sr_raid1_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;

	/* multiple IOs to the same chunk that fail will come through here */
	if (old_state == new_state)
		goto done;

	switch (old_state) {
	case BIOC_SDONLINE:
		switch (new_state) {
		case BIOC_SDOFFLINE:
		case BIOC_SDSCRUB:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDOFFLINE:
		switch (new_state) {
		case BIOC_SDREBUILD:
		case BIOC_SDHOTSPARE:
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDSCRUB:
		if (new_state == BIOC_SDONLINE) {
			;
		} else
			goto die;
		break;

	case BIOC_SDREBUILD:
		switch (new_state) {
		case BIOC_SDONLINE:
			break;
		case BIOC_SDOFFLINE:
			/* Abort rebuild since the rebuild chunk disappeared. */
			sd->sd_reb_abort = 1;
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SDHOTSPARE:
		switch (new_state) {
		case BIOC_SDOFFLINE:
		case BIOC_SDREBUILD:
			break;
		default:
			goto die;
		}
		break;

	default:
die:
		splx(s); /* XXX */
		panic("%s: %s: %s: invalid chunk state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_chunks[c]->src_meta.scm_status = new_state;
	sd->sd_set_vol_state(sd);

	sd->sd_must_flush = 1;
	task_add(systq, &sd->sd_meta_save_task);
done:
	splx(s);
}

void
sr_raid1_set_vol_state(struct sr_discipline *sd)
{
	int			states[SR_MAX_STATES];
	int			new_state, i, s, nd;
	int			old_state = sd->sd_vol_status;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	nd = sd->sd_meta->ssdi.ssd_chunk_no;

#ifdef SR_DEBUG
	for (i = 0; i < nd; i++)
		DNPRINTF(SR_D_STATE, "%s: chunk %d status = %u\n",
		    DEVNAME(sd->sd_sc), i,
		    sd->sd_vol.sv_chunks[i]->src_meta.scm_status);
#endif

	for (i = 0; i < SR_MAX_STATES; i++)
		states[i] = 0;

	for (i = 0; i < nd; i++) {
		s = sd->sd_vol.sv_chunks[i]->src_meta.scm_status;
		if (s >= SR_MAX_STATES)
			panic("%s: %s: %s: invalid chunk state",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scmi.scm_devname);
		states[s]++;
	}

	if (states[BIOC_SDONLINE] == nd)
		new_state = BIOC_SVONLINE;
	else if (states[BIOC_SDONLINE] == 0)
		new_state = BIOC_SVOFFLINE;
	else if (states[BIOC_SDSCRUB] != 0)
		new_state = BIOC_SVSCRUB;
	else if (states[BIOC_SDREBUILD] != 0)
		new_state = BIOC_SVREBUILD;
	else if (states[BIOC_SDOFFLINE] != 0)
		new_state = BIOC_SVDEGRADED;
	else {
		DNPRINTF(SR_D_STATE, "%s: invalid volume state, old state "
		    "was %d\n", DEVNAME(sd->sd_sc), old_state);
		panic("invalid volume state");
	}

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid1_set_vol_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    old_state, new_state);

	switch (old_state) {
	case BIOC_SVONLINE:
		switch (new_state) {
		case BIOC_SVONLINE: /* can go to same state */
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVREBUILD: /* happens on boot */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVOFFLINE:
		/* XXX this might be a little too much */
		goto die;

	case BIOC_SVDEGRADED:
		switch (new_state) {
		case BIOC_SVOFFLINE:
		case BIOC_SVREBUILD:
		case BIOC_SVDEGRADED: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVBUILDING:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVBUILDING: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVSCRUB:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVSCRUB: /* can go to same state */
			break;
		default:
			goto die;
		}
		break;

	case BIOC_SVREBUILD:
		switch (new_state) {
		case BIOC_SVONLINE:
		case BIOC_SVOFFLINE:
		case BIOC_SVDEGRADED:
		case BIOC_SVREBUILD: /* can go to the same state */
			break;
		default:
			goto die;
		}
		break;

	default:
die:
		panic("%s: %s: invalid volume state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol_status = new_state;

	/* If we have just become degraded, look for a hotspare. */
	if (new_state == BIOC_SVDEGRADED)
		task_add(systq, &sd->sd_hotspare_rebuild_task);
}

int
sr_raid1_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	int			ios, chunk, i, rt;
	daddr_t			blkno;

	/* blkno and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blkno, "sr_raid1_rw"))
		goto bad;

	if (xs->flags & SCSI_DATA_IN)
		ios = 1;
	else
		ios = sd->sd_meta->ssdi.ssd_chunk_no;

	for (i = 0; i < ios; i++) {
		if (xs->flags & SCSI_DATA_IN) {
			rt = 0;
ragain:
			/* interleave reads */
			chunk = sd->mds.mdd_raid1.sr1_counter++ %
			    sd->sd_meta->ssdi.ssd_chunk_no;
			scp = sd->sd_vol.sv_chunks[chunk];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
				break;

			case BIOC_SDOFFLINE:
			case BIOC_SDREBUILD:
			case BIOC_SDHOTSPARE:
				if (rt++ < sd->sd_meta->ssdi.ssd_chunk_no)
					goto ragain;

				/* FALLTHROUGH */
			default:
				/* volume offline */
				printf("%s: is offline, cannot read\n",
				    DEVNAME(sd->sd_sc));
				goto bad;
			}
		} else {
			/* writes go on all working disks */
			chunk = i;
			scp = sd->sd_vol.sv_chunks[chunk];
			switch (scp->src_meta.scm_status) {
			case BIOC_SDONLINE:
			case BIOC_SDSCRUB:
			case BIOC_SDREBUILD:
				break;

			case BIOC_SDHOTSPARE: /* should never happen */
			case BIOC_SDOFFLINE:
				continue;

			default:
				goto bad;
			}
		}

		ccb = sr_ccb_rw(sd, chunk, blkno, xs->datalen, xs->data,
		    xs->flags, 0);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname);
			goto bad;
		}
		sr_wu_enqueue_ccb(wu, ccb);
	}

	sr_schedule_wu(wu);

	return (0);

bad:
	/* wu is unwound by sr_wu_put */
	return (1);
}

int
sr_raid1_wu_done(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;

	/* If at least one I/O succeeded, we are okay. */
	if (wu->swu_ios_succeeded > 0) {
		xs->error = XS_NOERROR;
		return SR_WU_OK;
	}

	/* If all I/O failed, retry reads and give up on writes. */
	if (xs->flags & SCSI_DATA_IN) {
		printf("%s: retrying read on block %lld\n",
		    sd->sd_meta->ssd_devname, (long long)wu->swu_blk_start);
		if (wu->swu_cb_active == 1)
			panic("%s: sr_raid1_intr_cb",
			    DEVNAME(sd->sd_sc));
		sr_wu_release_ccbs(wu);
		wu->swu_state = SR_WU_RESTART;
		if (sd->sd_scsi_rw(wu) == 0)
			return SR_WU_RESTART;
	} else {
		printf("%s: permanently failing write on block %lld\n",
		    sd->sd_meta->ssd_devname, (long long)wu->swu_blk_start);
	}

	wu->swu_state = SR_WU_FAILED;
	xs->error = XS_DRIVER_STUFFUP;

	return SR_WU_FAILED;
}
@


1.64
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.63 2015/07/21 03:30:51 krw Exp $ */
a78 3
	int i;
	u_int32_t secsize;

a84 6
	secsize = 0;
	for (i = 0; i < no_chunk; i++) {
		if (sd->sd_vol.sv_chunks[i]->src_secsize > secsize)
			secsize = sd->sd_vol.sv_chunks[i]->src_secsize;
	}
	sd->sd_meta->ssdi.ssd_secsize = secsize;
@


1.63
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.62 2015/07/19 21:06:04 krw Exp $ */
d79 3
d88 6
@


1.62
log
@Remove unneeded #include <disklabel.h>.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.61 2015/07/19 17:04:31 krw Exp $ */
d332 1
a332 1
	daddr_t			blk;
d334 2
a335 2
	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_raid1_rw"))
d388 1
a388 1
		ccb = sr_ccb_rw(sd, chunk, blk, xs->datalen, xs->data,
@


1.61
log
@Stop adding and subtracting data offset. Just keep to chunk relative
block offsets until actual i/o is constructed and needs the physical
offset. Eliminate a number of <<DEV_BSIZE shifts as a bonus.

No intentional functional change.

Fixed and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.60 2015/01/27 10:12:45 dlg Exp $ */
a30 1
#include <sys/disklabel.h>
@


1.60
log
@remove #include <sys/workq.h>. it wont exist anymore soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.59 2014/11/18 02:37:30 tedu Exp $ */
a337 3

	/* calculate physical block */
	blk += sd->sd_meta->ssd_data_offset;
@


1.59
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.58 2014/09/14 14:17:24 jsg Exp $ */
a35 1
#include <sys/workq.h>
@


1.58
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.57 2014/07/12 07:39:12 blambert Exp $ */
a44 1
#include <dev/rndvar.h>
@


1.57
log
@essentially mechanical conversion of softraid rebuild from
workq to taskq

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.56 2014/01/22 04:24:29 jsing Exp $ */
a24 1
#include <sys/proc.h>
@


1.56
log
@Switch metadata saves from the system workq to the system taskq.

ok dlg@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.55 2014/01/21 10:25:25 jsing Exp $ */
d325 1
a325 1
		workq_add_task(NULL, 0, sr_hotspare_rebuild_callback, sd, NULL);
@


1.55
log
@Order the volume state transitions by state value.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.54 2013/11/01 17:36:19 krw Exp $ */
d36 2
d192 1
a192 1
	workq_add_task(NULL, 0, sr_meta_save_callback, sd, NULL);
@


1.54
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.53 2013/06/11 16:42:13 deraadt Exp $ */
d264 1
a264 1
	case BIOC_SVSCRUB:
a265 1
		case BIOC_SVONLINE:
d267 2
a268 2
		case BIOC_SVDEGRADED:
		case BIOC_SVSCRUB: /* can go to same state */
d286 1
a286 1
	case BIOC_SVREBUILD:
d291 1
a291 1
		case BIOC_SVREBUILD: /* can go to the same state */
d298 1
a298 1
	case BIOC_SVDEGRADED:
d300 1
d302 2
a303 2
		case BIOC_SVREBUILD:
		case BIOC_SVDEGRADED: /* can go to the same state */
@


1.53
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.52 2013/05/21 15:01:53 jsing Exp $ */
d429 1
a429 1
		    sd->sd_meta->ssd_devname, wu->swu_blk_start);
d439 1
a439 1
		    sd->sd_meta->ssd_devname, wu->swu_blk_start);
@


1.52
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.50 2013/04/21 13:00:21 jsing Exp $ */
d334 1
a334 1
	daddr64_t		blk;
@


1.51
log
@Use a state to indicate that a work unit should only be constructed and not
scheduled, rather than trying to imply this from the rebuild flag.
@
text
@d333 1
a333 1
	int			ios, chunk, i, s, rt;
d405 1
a405 1
	s = splbio();
a406 19
	/* Construct the work unit, do not schedule it. */
	if (wu->swu_state == SR_WU_CONSTRUCT)
		goto queued;

	/* current io failed, restart */
	if (wu->swu_state == SR_WU_RESTART)
		goto start;

	/* deferred io failed, don't restart */
	if (wu->swu_state == SR_WU_REQUEUE)
		goto queued;

	if (sr_check_io_collision(wu))
		goto queued;

start:
	sr_raid_startwu(wu);
queued:
	splx(s);
d408 1
@


1.50
log
@Convert RAID1 to the new work unit completion functions and generic
interrupt handler. Disciplines such as RAID1/4/5/6 need a way to intercept
I/O when the work unit is complete, but before the SCSI xfer is complete.
This is provided via a sd_scsi_wu_done hook, which enables work units to be
restarted or otherwise modified before the SCSI xfer completion occurs.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.49 2013/03/31 15:44:52 jsing Exp $ */
d407 2
a408 2
	/* rebuild io, let rebuild routine deal with it */
	if (wu->swu_flags & SR_WUF_REBUILD)
@


1.49
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.48 2013/03/31 13:31:44 jsing Exp $ */
d53 1
a53 1
void	sr_raid1_intr(struct buf *);
d72 1
a72 1
	sd->sd_scsi_intr = sr_raid1_intr;
d432 2
a433 2
void
sr_raid1_intr(struct buf *bp)
a434 2
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
a436 18
	struct sr_softc		*sc = sd->sd_sc;
	int			s;

	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
	    DEVNAME(sc), bp, xs);

	s = splbio();

	sr_ccb_done(ccb);

	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete < wu->swu_io_count)
		goto done;

	xs->error = XS_NOERROR;
d438 4
a441 18
	/* if all ios failed, retry reads and give up on writes */
	if (wu->swu_ios_failed == wu->swu_ios_complete) {
		if (xs->flags & SCSI_DATA_IN) {
			printf("%s: retrying read on block %lld\n",
			    DEVNAME(sc), ccb->ccb_buf.b_blkno);
			if (wu->swu_cb_active == 1)
				panic("%s: sr_raid1_intr_cb",
				    DEVNAME(sd->sd_sc));
			sr_wu_release_ccbs(wu);
			wu->swu_state = SR_WU_RESTART;
			if (sd->sd_scsi_rw(wu) == 0)
				goto done;
			xs->error = XS_DRIVER_STUFFUP;
		} else {
			printf("%s: permanently failing write on block %lld\n",
			    DEVNAME(sc), ccb->ccb_buf.b_blkno);
			xs->error = XS_DRIVER_STUFFUP;
		}
d444 14
a457 20
	TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link)
		if (wu == wup)
			break;

	if (wup == NULL)
		panic("%s: wu %p not on pending queue",
		    DEVNAME(sd->sd_sc), wu);

	/* wu on pendq, remove */
	TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

	if (wu->swu_collider) {
		if (wu->swu_ios_failed)
			sr_raid_recreate_wu(wu->swu_collider);

		/* XXX Should the collider be failed if this xs failed? */
		/* restart deferred wu */
		wu->swu_collider->swu_state = SR_WU_INPROGRESS;
		TAILQ_REMOVE(&sd->sd_wu_defq, wu->swu_collider, swu_link);
		sr_raid_startwu(wu->swu_collider);
d460 2
a461 6
	if (wu->swu_flags & SR_WUF_REBUILD)
		wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
	if (wu->swu_flags & SR_WUF_WAKEUP)
		wakeup(wu);
	if (!(wu->swu_flags & SR_WUF_REBUILD))
		sr_scsi_done(sd, xs);
d463 1
a463 2
done:
	splx(s);
@


1.48
log
@More runtime value initialisation functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.47 2013/03/31 11:12:06 jsing Exp $ */
a80 1

d82 2
a83 1
		sr_error(sd->sd_sc, "RAID 1 requires two or more chunks");
@


1.47
log
@Provide default resource allocation and free functions. Convert all
disciplines except for AOE and CRYPTO, which require custom handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.46 2013/03/29 15:26:45 jsing Exp $ */
d51 1
d89 1
a89 3
	sd->sd_max_ccb_per_wu = no_chunk;

	return 0;
d96 2
d99 3
@


1.46
log
@Properly release ccbs when restarting a work unit.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.45 2013/03/29 12:00:59 jsing Exp $ */
a50 2
int	sr_raid1_alloc_resources(struct sr_discipline *);
int	sr_raid1_free_resources(struct sr_discipline *);
a67 1
	sd->sd_alloc_resources = sr_raid1_alloc_resources;
a69 1
	sd->sd_free_resources = sr_raid1_free_resources;
a100 33
}

int
sr_raid1_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_wu_alloc(sd))
		goto bad;
	if (sr_ccb_alloc(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_raid1_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raid1_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_free(sd);
	sr_ccb_free(sd);

	rv = 0;
	return (rv);
@


1.45
log
@Decouple wakeups on work unit completion from the type of I/O being
performed.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.44 2013/03/29 11:46:45 jsing Exp $ */
a495 1
			sr_ccb_put(ccb);
d499 1
a499 1
			TAILQ_INIT(&wu->swu_ccb);
@


1.44
log
@sd_wu_pending is only decremented when scsi_done() or scsi_io_put() are
called. As a result, factor out the the sd_sync check/wakeup code and move
it to after the scsi_done() call in sr_scsi_done(). Perform the same
sd_sync check/wakeup after scsi_io_put() calls (including the addition of
some that were previously missed).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.43 2013/03/27 14:30:11 jsing Exp $ */
d534 5
a538 7
	if (wu->swu_flags & SR_WUF_REBUILD) {
		/* XXX - decouple from SCSI_DATA_OUT. */
		if (wu->swu_xs->flags & SCSI_DATA_OUT) {
			wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
			wakeup(wu);
		}
	} else {
a539 1
	}
@


1.43
log
@Rewrite the work unit handling code in the RAID 1/4/5/6 interrupt handlers.
This simplifies the code and will allow for easier conversion to the workq
based work unit completion routines. It also ensures that work units are
always removed from the pending queue and that colliders are started, even
in the event of an I/O failure.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.42 2013/03/25 16:01:49 jsing Exp $ */
a542 3

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
@


1.42
log
@Factor out the code that is used to recreate work units - one copy of the
code is sufficient.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.41 2013/03/02 12:50:01 jsing Exp $ */
d473 1
a473 1
	int			s, pend;
d486 2
a487 24
	if (wu->swu_ios_complete >= wu->swu_io_count) {
		/* if all ios failed, retry reads and give up on writes */
		if (wu->swu_ios_failed == wu->swu_ios_complete) {
			if (xs->flags & SCSI_DATA_IN) {
				printf("%s: retrying read on block %lld\n",
				    DEVNAME(sc), ccb->ccb_buf.b_blkno);
				sr_ccb_put(ccb);
				if (wu->swu_cb_active == 1)
					panic("%s: sr_raid1_intr_cb",
					    DEVNAME(sd->sd_sc));
				TAILQ_INIT(&wu->swu_ccb);
				wu->swu_state = SR_WU_RESTART;
				if (sd->sd_scsi_rw(wu))
					goto bad;
				else
					goto retry;
			} else {
				printf("%s: permanently fail write on block "
				    "%lld\n", DEVNAME(sc),
				    ccb->ccb_buf.b_blkno);
				xs->error = XS_DRIVER_STUFFUP;
				goto bad;
			}
		}
d489 1
a489 1
		xs->error = XS_NOERROR;
d491 18
a508 21
		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					if (wu->swu_ios_failed)
						/* toss all ccbs and recreate */
						sr_raid_recreate_wu(wu->swu_collider);

					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
d510 1
d512 3
a514 12
		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		if (wu->swu_flags & SR_WUF_REBUILD) {
			if (wu->swu_xs->flags & SCSI_DATA_OUT) {
				wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
				wakeup(wu);
			}
		} else {
			sr_scsi_done(sd, xs);
		}
d516 16
a531 2
		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
a533 5
retry:
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
d535 5
a539 2
		wu->swu_flags |= SR_WUF_REBUILDIOCOMP;
		wakeup(wu);
d544 4
@


1.41
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.40 2013/01/18 05:59:28 jsing Exp $ */
a54 1
void	sr_raid1_recreate_wu(struct sr_workunit *);
d523 1
a523 1
						sr_raid1_recreate_wu(wu->swu_collider);
a565 21
}

void
sr_raid1_recreate_wu(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_workunit	*wup = wu;

	do {
		DNPRINTF(SR_D_INTR, "%s: sr_raid1_recreate_wu: %p\n", wup);

		/* toss all ccbs */
		sr_wu_release_ccbs(wup);

		/* recreate ccbs */
		wup->swu_state = SR_WU_REQUEUE;
		if (sd->sd_scsi_rw(wup))
			panic("could not requeue io");

		wup = wup->swu_collider;
	} while (wup);
@


1.40
log
@Convert RAID1 to new ccb functions.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.39 2013/01/17 03:37:31 jsing Exp $ */
a112 3
	if (!sd)
		return (rv);

a129 3

	if (!sd)
		return (rv);
@


1.39
log
@Restructure the RAID1 I/O path so that we only get a ccb once we are
certain that we need one. Also make code more consistent with other
disciplines.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.38 2013/01/16 09:21:50 jsing Exp $ */
a386 1
	wu->swu_io_count = ios;
a425 1
				wu->swu_io_count--;
a430 1

d433 2
a434 1
		ccb = sr_ccb_get(sd);
d442 1
a442 41

		if (xs->flags & SCSI_POLL) {
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
		} else {
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
		}

		if (xs->flags & SCSI_DATA_IN)
			ccb->ccb_buf.b_flags |= B_READ;
		else
			ccb->ccb_buf.b_flags |= B_WRITE;
	
		ccb->ccb_buf.b_flags |= B_PHYS;
		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_buf.b_bq = NULL;
		ccb->ccb_wu = wu;
		ccb->ccb_target = chunk;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[chunk]->src_dev_mm;
		ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[chunk]->src_vn;
		if ((ccb->ccb_buf.b_flags & B_READ) == 0)
			ccb->ccb_buf.b_vp->v_numoutput++;

		LIST_INIT(&ccb->ccb_buf.b_dep);

		if (wu->swu_cb_active == 1)
			panic("%s: sr_raid1_rw", DEVNAME(sd->sd_sc));
		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_raid1: b_bcount: %d "
		    "b_blkno: %x b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
a479 1
	struct buf		*b;
a484 5
	b = &ccb->ccb_buf;
	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %lld target: %d\n", DEVNAME(sc),
	    b->b_bcount, b->b_resid, b->b_flags, b->b_blkno, ccb->ccb_target);

d487 1
a487 15
	if (b->b_flags & B_ERROR) {
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target: %d\n",
		    DEVNAME(sc), b->b_blkno, ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;
d498 1
a498 1
				    DEVNAME(sc), b->b_blkno);
d511 2
a512 1
				    "%lld\n", DEVNAME(sc), b->b_blkno);
@


1.38
log
@Consistently call sr_scsi_done instead of scsi_done.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.37 2013/01/16 07:06:29 jsing Exp $ */
a371 1
	struct buf		*b;
d373 1
a373 1
	int			ios, x, i, s, rt;
a389 29
		ccb = sr_ccb_get(sd);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname);
			goto bad;
		}
		b = &ccb->ccb_buf;

		if (xs->flags & SCSI_POLL) {
			b->b_flags = 0;
			b->b_iodone = NULL;
		} else {
			b->b_flags = B_CALL;
			b->b_iodone = sr_raid1_intr;
		}

		b->b_flags |= B_PHYS;
		b->b_blkno = blk;
		b->b_bcount = xs->datalen;
		b->b_bufsize = xs->datalen;
		b->b_resid = xs->datalen;
		b->b_data = xs->data;
		b->b_error = 0;
		b->b_proc = curproc;
		b->b_bq = NULL;
		ccb->ccb_wu = wu;

d394 1
a394 1
			x = sd->mds.mdd_raid1.sr1_counter++ %
d396 1
a396 1
			scp = sd->sd_vol.sv_chunks[x];
a399 1
				b->b_flags |= B_READ;
d411 1
a411 1
				printf("%s: is offline, can't read\n",
a412 1
				sr_ccb_put(ccb);
d417 2
a418 2
			x = i;
			scp = sd->sd_vol.sv_chunks[x];
a422 1
				b->b_flags |= B_WRITE;
a427 1
				sr_ccb_put(ccb);
a434 5
		ccb->ccb_target = x;
		b->b_dev = sd->sd_vol.sv_chunks[x]->src_dev_mm;
		b->b_vp = sd->sd_vol.sv_chunks[x]->src_vn;
		if ((b->b_flags & B_READ) == 0)
			b->b_vp->v_numoutput++;
d436 39
a474 1
		LIST_INIT(&b->b_dep);
d483 2
a484 2
		    b->b_bcount, b->b_blkno,
		    b->b_flags, b->b_data);
@


1.37
log
@Add a new capability flag to identify disciplines where read failures are
not necessarily terminal (i.e. we have redundancy).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.36 2013/01/16 06:42:22 jsing Exp $ */
d615 1
a615 1
			scsi_done(xs);
d631 1
a631 1
		scsi_done(xs);
@


1.36
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.35 2013/01/16 06:29:14 jsing Exp $ */
d67 1
a67 1
	    SR_CAP_REBUILD;
@


1.35
log
@Factor out code used to release ccbs from a workunit.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.34 2013/01/15 09:28:29 jsing Exp $ */
a580 1
		xs->resid = 0;
@


1.34
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.33 2013/01/15 04:03:01 jsing Exp $ */
a642 1
	struct sr_ccb		*ccb;
d648 1
a648 7
		if (wu->swu_cb_active == 1)
			panic("%s: sr_raid1_recreate_wu", DEVNAME(sd->sd_sc));
		while ((ccb = TAILQ_FIRST(&wup->swu_ccb)) != NULL) {
			TAILQ_REMOVE(&wup->swu_ccb, ccb, ccb_link);
			sr_ccb_put(ccb);
		}
		TAILQ_INIT(&wup->swu_ccb);
@


1.33
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.32 2012/10/08 14:22:41 jsing Exp $ */
a62 1

d65 1
a90 1
	strlcpy(sd->sd_name, "RAID 1", sizeof(sd->sd_name));
@


1.32
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.30 2011/12/26 14:54:52 jsing Exp $ */
d76 1
@


1.31
log
@Convert softraid(4) to new bio(4) status interface. This allows bioctl(8)
to provide useful feedback, rather than reporting an ioctl failure and
leaving the user to consult dmesg. For now we continue to print most things
to the console, even if the message is a result of an ioctl.
@
text
@d50 1
a50 1
	    int);
d100 1
a100 1
    int no_chunk)
@


1.30
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.29 2011/12/25 15:28:17 jsing Exp $ */
d85 2
a86 1
	if (no_chunk < 2)
d88 1
@


1.29
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.28 2011/12/25 15:16:21 jsing Exp $ */
d56 2
@


1.28
log
@Move chunk state debugging code to a more useful location.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.27 2011/04/05 19:52:02 krw Exp $ */
d68 3
a70 1
	/* Setup discipline pointers. */
a71 2
	sd->sd_assemble = sr_raid1_assemble;
	sd->sd_alloc_resources = sr_raid1_alloc_resources;
a72 7
	sd->sd_start_discipline = NULL;
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
@


1.27
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.26 2010/11/06 23:01:56 marco Exp $ */
d250 7
a280 1
#ifdef SR_DEBUG
a282 5
		for (i = 0; i < nd; i++)
			DNPRINTF(SR_D_STATE, "%s: chunk %d status = %d\n",
			    DEVNAME(sd->sd_sc), i,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_status);
#endif
@


1.26
log
@Move raid1 and crypto io to a workq.  This is to avoid a potential VOP_
call while in interrupt context.

Contains an additional spl dance as found by thib.

Tested by many opn various arches.  Note that raid 0/4/5/6 have not been
moved over yet.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.25 2010/07/02 09:20:26 jsing Exp $ */
a617 2
			/* do not change the order of these 2 functions */
			sr_wu_put(wu);
a633 2
		/* do not change the order of these 2 functions */
		sr_wu_put(wu);
@


1.25
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.23 2010/03/26 11:20:34 jsing Exp $ */
d479 2
d565 3
d655 2
@


1.24
log
@make sure that buf's on the stack set the b_bq to NULL.
one memset -> bzero.

ok marco@@, jsing@@
@
text
@d384 1
a384 1
	blk += SR_DATA_OFFSET;
@


1.23
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.21 2009/12/15 13:19:37 jsing Exp $ */
d419 1
@


1.22
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d384 1
a384 1
	blk += SR_META_SIZE + SR_META_OFFSET;
@


1.21
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.18 2009/07/12 16:34:58 jsing Exp $ */
a577 1
		xs->flags |= ITSDONE;
a625 1
	xs->flags |= ITSDONE;
@


1.20
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d47 4
a65 1
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
d69 2
d83 26
@


1.19
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d60 2
a63 1
	sd->sd_rebuild = 1;
@


1.18
log
@Clean up debug droppings in sr_raid1_set_vol_state().

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.17 2009/07/12 16:33:02 jsing Exp $ */
d342 1
d369 1
d372 2
a373 2
			ccb->ccb_buf.b_flags = 0;
			ccb->ccb_buf.b_iodone = NULL;
d375 2
a376 2
			ccb->ccb_buf.b_flags = B_CALL;
			ccb->ccb_buf.b_iodone = sr_raid1_intr;
d379 8
a386 8
		ccb->ccb_buf.b_flags |= B_PHYS;
		ccb->ccb_buf.b_blkno = blk;
		ccb->ccb_buf.b_bcount = xs->datalen;
		ccb->ccb_buf.b_bufsize = xs->datalen;
		ccb->ccb_buf.b_resid = xs->datalen;
		ccb->ccb_buf.b_data = xs->data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
d399 1
a399 1
				ccb->ccb_buf.b_flags |= B_READ;
d424 1
a424 1
				ccb->ccb_buf.b_flags |= B_WRITE;
d439 4
a442 2
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[x]->src_dev_mm;
		ccb->ccb_buf.b_vp = NULL;
d444 1
a444 1
		LIST_INIT(&ccb->ccb_buf.b_dep);
d451 2
a452 2
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
d490 1
d496 1
d499 1
a499 2
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);
d503 1
a503 1
	if (ccb->ccb_buf.b_flags & B_ERROR) {
d505 1
a505 1
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
d528 1
a528 1
				    DEVNAME(sc), ccb->ccb_buf.b_blkno);
d538 1
a538 2
				    "%lld\n", DEVNAME(sc),
				    ccb->ccb_buf.b_blkno);
@


1.17
log
@Enable hotspare rebuilds for softraid RAID1.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.13 2009/06/02 16:32:23 marco Exp $ */
d242 3
a244 1
		printf("old_state = %d, ", old_state);
d246 2
a247 1
			printf("%d = %d, ", i,
d249 2
a250 1
		panic("invalid new_state");
d253 1
a253 1
	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state %d -> %d\n",
@


1.16
log
@Abort the current rebuild if the rebuild chunk disappears. Whilst here also
rename the abort flag so that it is more generalised.

ok marco@@
@
text
@d326 4
@


1.15
log
@Add other valid chunk state transitions for RAID 1.

ok marco@@
@
text
@d166 1
d168 2
@


1.14
log
@Abuse bio layer a little less by marking fake buffers with B_PHYS.
From beck with lots of squealing and ear bleeds.
Issue originally reported by todd.

ok beck
@
text
@a138 1
			break;
d147 5
a151 3
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
d153 1
d164 5
a168 3
		if (new_state == BIOC_SDONLINE) {
			;
		} else
d170 1
d174 5
a178 3
		if (new_state == BIOC_SDREBUILD) {
			;
		} else
d180 1
@


1.13
log
@Rebuild can go to degraded
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.12 2009/06/02 11:38:51 deraadt Exp $ */
d358 1
a553 1
				//printf("waking up write\n");
@


1.12
log
@marco needs to learn how to do his range checks better, found by Parfait
ok oga guenther
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.11 2009/06/02 05:49:35 marco Exp $ */
d286 1
@


1.11
log
@Add an identifier that tells us if we can rebuild this discipline.
KNF & spelling too
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.10 2009/06/02 00:58:16 marco Exp $ */
d212 1
a212 1
		if (s > SR_MAX_STATES)
@


1.10
log
@First bits for rebuild.  Disabled for now.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.9 2009/05/11 14:06:21 jsing Exp $ */
d62 1
@


1.9
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.7 2008/11/25 23:05:17 marco Exp $ */
d247 1
d431 4
d549 11
a559 3
		/* do not change the order of these 2 functions */
		sr_wu_put(wu);
		sr_scsi_done(sd, xs);
d571 9
a579 2
	sr_wu_put(wu);
	sr_scsi_done(sd, xs);
@


1.8
log
@Part one of partial bringup volumes.  Plenty of rope to kill your data
use with caution...
@
text
@d46 32
a77 1
/* RAID 1 functions */
@


1.7
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.6 2008/07/19 22:41:58 marco Exp $ */
d213 1
@


1.6
log
@Full rewrite of metadata handling.  This fixes power failures and crashes
that caused illegal checksums.  The new metadata code is more or less ready
to deal with other vendor's metadata formats.

While here clean up the name space.

Fix thib's pool mess by adding removing bad flags in interrupt context.

tested on macppc, amd64, i386, sparc64 & hppa

sparc64 has issues with crypto however those do not seem to be softraid
specific.

help from okan@@ ckuethe@@ Will Backman and others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.5 2008/02/05 16:49:25 marco Exp $ */
d514 1
a514 1
		scsi_done(xs);
d527 1
a527 1
	scsi_done(xs);
@


1.5
log
@Shave off a few more bytes by moving IO collision detection into a generic
fucntion.  Fix bug in the crypto code that could casuse data corruption as
a bonus, bad cut & past tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.4 2008/02/05 16:15:35 marco Exp $ */
d58 1
a58 1
	if (sr_alloc_wu(sd))
d60 1
a60 1
	if (sr_alloc_ccb(sd))
d79 2
a80 5
	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);
d92 2
a93 2
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname, c, new_state);
d148 2
a149 2
		    sd->sd_vol.sv_meta.svm_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname,
d158 1
a158 1
	workq_add_task(NULL, 0, sr_save_metadata_callback, sd, NULL);
d168 1
a168 1
	int			old_state = sd->sd_vol.sv_meta.svm_status;
d171 1
a171 1
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
d173 1
a173 1
	nd = sd->sd_vol.sv_meta.svm_no_chunk;
d183 2
a184 2
			    sd->sd_vol.sv_meta.svm_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_devname);
d207 1
a207 1
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d274 1
a274 1
		    sd->sd_vol.sv_meta.svm_devname,
d279 1
a279 1
	sd->sd_vol.sv_meta.svm_status = new_state;
d302 1
a302 1
		ios = sd->sd_vol.sv_meta.svm_no_chunk;
d306 1
a306 1
		ccb = sr_get_ccb(sd);
d311 1
a311 1
			    sd->sd_vol.sv_meta.svm_devname);
d337 1
a337 1
			    sd->sd_vol.sv_meta.svm_no_chunk;
d348 1
a348 1
				if (rt++ < sd->sd_vol.sv_meta.svm_no_chunk)
d356 1
a356 1
				sr_put_ccb(ccb);
d373 1
a373 1
				sr_put_ccb(ccb);
d391 1
a391 1
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d415 1
a415 1
	/* wu is unwound by sr_put_wu */
d465 1
a465 1
				sr_put_ccb(ccb);
d513 1
a513 1
		sr_put_wu(wu);
d526 1
a526 1
	sr_put_wu(wu);
d544 1
a544 1
			sr_put_ccb(ccb);
@


1.4
log
@Create a generic function to validate IO instead of copying and pasting
same code in all disciplines.  This shaves of a few bytes.

crypto 3185 -> 2690
raid 0 2843 -> 2378
raid 1 3474 -> 2689
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.3 2008/01/24 19:58:08 marco Exp $ */
a289 1
	struct sr_workunit	*wup;
d409 1
a409 16
	/* walk queue backwards and fill in collider if we have one */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
a410 1
	}
a411 1
	/* XXX deal with polling */
@


1.3
log
@Create chunk and state transition functions for RAID 0.
Move RAID 1 chunk and state transition functions into proper file.
Let Crypto use RAID 1 chunk and state transition functions for now but this
needs fixing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.2 2008/01/24 17:50:17 marco Exp $ */
d296 2
a297 12
	DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
a298 30
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid1_rw out of bounds start: %lld "
		    "end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}
@


1.2
log
@Bring softraid into the world of 16 byte commands; this allows for > 2TB disks
Fix bioctl size output which was off by *512; diagnosed by otto
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid1.c,v 1.1 2007/11/27 17:21:52 tedu Exp $ */
d87 196
@


1.1
log
@also move softraid raid1 into own file, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.88 2007/11/27 16:37:05 tedu Exp $ */
d117 2
@

