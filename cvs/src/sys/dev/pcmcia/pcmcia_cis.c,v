head	1.21;
access;
symbols
	OPENBSD_6_2:1.21.0.4
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.20.0.14
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.10
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.8
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.6
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.6
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.2
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.18.0.10
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.8
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.6
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.15.0.12
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.15.0.8
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.13.0.10
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.8
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.8.0.2
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.5.0.8
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.6
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.4
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.6
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.20;
commitid	uRv5pa9QDlZaYgwD;

1.20
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.19;
commitid	OBNa5kfxQ2UXoiIw;

1.19
date	2013.07.10.05.36.40;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.04.13.14.49;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.04.13.13.17;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2010.09.04.12.59.27;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.07.18.21.40;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.01.21.58.01;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2004.09.16.07.19.49;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2003.10.22.09.58.46;	author jmc;	state Exp;
branches;
next	1.10;

1.10
date	2003.05.06.11.22.30;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.19.19.03.25;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.5;

1.5
date	2000.06.06.01.02.26;	author fgsch;	state Exp;
branches
	1.5.8.1;
next	1.4;

1.4
date	2000.05.29.21.39.06;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.05.16.22.44.12;	author niklas;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.01.28.04.58.31;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.10.47.15;	author fgsch;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.08;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.3.4.5;

1.3.4.5
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.3.4.6;

1.3.4.6
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	;

1.5.8.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.5.8.2;

1.5.8.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.5.8.3;

1.5.8.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.5.8.4;

1.5.8.4
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: pcmcia_cis.c,v 1.20 2014/07/12 18:48:52 tedu Exp $	*/
/*	$NetBSD: pcmcia_cis.c,v 1.9 1998/08/22 23:41:48 msaitoh Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciachip.h>
#include <dev/pcmcia/pcmciavar.h>

#ifdef PCMCIACISDEBUG
#define	DPRINTF(arg) printf arg
#else
#define	DPRINTF(arg)
#endif

#define	PCMCIA_CIS_SIZE		1024

struct cis_state {
	int	count;
	int	gotmfc;
	struct pcmcia_config_entry temp_cfe;
	struct pcmcia_config_entry *default_cfe;
	struct pcmcia_card *card;
	struct pcmcia_function *pf;
};

int	pcmcia_parse_cis_tuple(struct pcmcia_tuple *, void *);

uint8_t
pcmcia_cis_read_1(struct pcmcia_tuple *tuple, bus_size_t idx)
{
	if (tuple->flags & PTF_INDIRECT) {
		bus_space_write_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_CONTROL, PCMCIA_ICR_ATTR);
		idx <<= tuple->addrshift;
		bus_space_write_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_ADDRESS + 0, idx >> 0);
		bus_space_write_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_ADDRESS + 1, idx >> 8);
		bus_space_write_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_ADDRESS + 2, idx >> 16);
		bus_space_write_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_ADDRESS + 3, idx >> 24);
		return bus_space_read_1(tuple->memt, tuple->memh,
		    tuple->indirect_ptr + PCMCIA_INDR_DATA);
	} else
		return bus_space_read_1(tuple->memt, tuple->memh,
		    idx << tuple->addrshift);
}

void
pcmcia_read_cis(sc)
	struct pcmcia_softc *sc;
{
	struct cis_state state;

	memset(&state, 0, sizeof state);

	state.card = &sc->card;

	state.card->error = 0;
	state.card->cis1_major = -1;
	state.card->cis1_minor = -1;
	state.card->cis1_info[0] = NULL;
	state.card->cis1_info[1] = NULL;
	state.card->cis1_info[2] = NULL;
	state.card->cis1_info[3] = NULL;
	state.card->manufacturer = PCMCIA_VENDOR_INVALID;
	state.card->product = PCMCIA_PRODUCT_INVALID;
	SIMPLEQ_INIT(&state.card->pf_head);

	state.pf = NULL;

	if (pcmcia_scan_cis((struct device *)sc, pcmcia_parse_cis_tuple,
	    &state) == -1)
		state.card->error++;
}

int
pcmcia_scan_cis(dev, fct, arg)
	struct device *dev;
	int (*fct)(struct pcmcia_tuple *, void *);
	void *arg;
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *) dev;
	pcmcia_chipset_tag_t pct;
	pcmcia_chipset_handle_t pch;
	int window;
	struct pcmcia_mem_handle pcmh;
	struct pcmcia_tuple tuple;
	int indirect_present;
	int longlink_present;
	int longlink_common;
	u_long longlink_addr;
	int mfc_count;
	int mfc_index;
	struct {
		int	common;
		u_long	addr;
	} mfc[256 / 5];
	int ret;

	ret = 0;

	pct = sc->pct;
	pch = sc->pch;

	/* allocate some memory */

	if (pcmcia_chip_mem_alloc(pct, pch, PCMCIA_CIS_SIZE, &pcmh)) {
#ifdef DIAGNOSTIC
		printf("%s: can't alloc memory to read attributes\n",
		    sc->dev.dv_xname);
#endif
		return -1;
	}

	/* initialize state for the primary tuple chain */
	if (pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_ATTR, 0,
	    PCMCIA_CIS_SIZE, &pcmh, &tuple.ptr, &window)) {
		pcmcia_chip_mem_free(pct, pch, &pcmh);
#ifdef DIAGNOSTIC
		printf("%s: can't map memory to read attributes\n",
		    sc->dev.dv_xname);
#endif
		return -1;
	}
	tuple.memt = pcmh.memt;
	tuple.memh = pcmh.memh;

	DPRINTF(("cis mem map %x\n", (unsigned int) tuple.memh));

	tuple.addrshift = 1;
	tuple.flags = 0;

	indirect_present = 0;
	longlink_present = 1;
	longlink_common = 1;
	longlink_addr = 0;

	mfc_count = 0;
	mfc_index = 0;

	DPRINTF(("%s: CIS tuple chain:\n", sc->dev.dv_xname));

	while (1) {
		while (1) {
			/*
			 * Perform boundary check for insane cards.
			 * If CIS is too long, simulate CIS end.
			 * (This check may not be sufficient for
			 * malicious cards.)
			 */
			if ((tuple.ptr << tuple.addrshift) >=
			    PCMCIA_CIS_SIZE - 1 - 32 /* ad hoc value */) {
				DPRINTF(("CISTPL_END (too long CIS)\n"));
				tuple.code = PCMCIA_CISTPL_END;
				goto cis_end;
			}

			/* get the tuple code */

			tuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);

			/* two special-case tuples */

			if (tuple.code == PCMCIA_CISTPL_NULL) {
				DPRINTF(("CISTPL_NONE\n 00\n"));
				tuple.ptr++;
				continue;
			} else if (tuple.code == PCMCIA_CISTPL_END) {
				DPRINTF(("CISTPL_END\n ff\n"));
			cis_end:
				/* Call the function for the END tuple, since
				   the CIS semantics depend on it */
				if ((*fct) (&tuple, arg)) {
					pcmcia_chip_mem_unmap(pct, pch,
							      window);
					ret = 1;
					goto done;
				}
				tuple.ptr++;
				break;
			}
			/* now all the normal tuples */

			tuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);
			switch (tuple.code) {
			case PCMCIA_CISTPL_INDIRECT:
				indirect_present = 1;
				DPRINTF(("CISTPL_INDIRECT\n"));
				break;
			case PCMCIA_CISTPL_LONGLINK_A:
			case PCMCIA_CISTPL_LONGLINK_C:
				if (tuple.length < 4) {
					DPRINTF(("CISTPL_LONGLINK_%s too "
					    "short %d\n",
					    longlink_common ? "C" : "A",
					    tuple.length));
					break;
				}
				longlink_present = 1;
				longlink_common = (tuple.code ==
				    PCMCIA_CISTPL_LONGLINK_C) ? 1 : 0;
				longlink_addr = pcmcia_tuple_read_4(&tuple, 0);
				DPRINTF(("CISTPL_LONGLINK_%s %lx\n",
				    longlink_common ? "C" : "A",
				    longlink_addr));
				break;
			case PCMCIA_CISTPL_NO_LINK:
				longlink_present = 0;
				DPRINTF(("CISTPL_NO_LINK\n"));
				break;
			case PCMCIA_CISTPL_CHECKSUM:
				if (tuple.length < 5) {
					DPRINTF(("CISTPL_CHECKSUM too "
					    "short %d\n", tuple.length));
					break;
				} {
					int16_t offset;
					u_long addr, length;
					u_int cksum, sum;
					int i;

					*((u_int16_t *) & offset) =
					    pcmcia_tuple_read_2(&tuple, 0);
					length = pcmcia_tuple_read_2(&tuple, 2);
					cksum = pcmcia_tuple_read_1(&tuple, 4);

					addr = tuple.ptr + offset;

					DPRINTF(("CISTPL_CHECKSUM addr=%lx "
					    "len=%lx cksum=%x",
					    addr, length, cksum));

					/*
					 * XXX do more work to deal with
					 * distant regions
					 */
					if ((addr >= PCMCIA_CIS_SIZE) ||
					    ((addr + length) >=
					      PCMCIA_CIS_SIZE)) {
						DPRINTF((" skipped, "
						    "too distant\n"));
						break;
					}
					sum = 0;
					for (i = 0; i < length; i++)
						sum += pcmcia_cis_read_1(&tuple,
						    addr + i);
					if (cksum != (sum & 0xff)) {
						DPRINTF((" failed sum=%x\n",
						    sum));
						printf("%s: CIS checksum "
						    "failed\n",
						    sc->dev.dv_xname);
#if 0
						/*
						 * XXX Some working cards have
						 * XXX bad checksums!!
						 */
						ret = -1;
#endif
					} else {
						DPRINTF((" ok\n"));
					}
				}
				break;
			case PCMCIA_CISTPL_LONGLINK_MFC:
				if (tuple.length < 6) {
					DPRINTF(("CISTPL_LONGLINK_MFC too "
					    "short %d\n", tuple.length));
					break;
				}
				if (((tuple.length - 1) % 5) != 0) {
					DPRINTF(("CISTPL_LONGLINK_MFC bogus "
					    "length %d\n", tuple.length));
					break;
				}
				{
					int i, tmp_count;

					/*
					 * put count into tmp var so that
					 * if we have to bail (because it's
					 * a bogus count) it won't be
					 * remembered for later use.
					 */
					tmp_count =
					    pcmcia_tuple_read_1(&tuple, 0);
					DPRINTF(("CISTPL_LONGLINK_MFC %d",
					    tmp_count));

					/*
					 * make _sure_ it's the right size;
					 * if too short, it may be a weird
					 * (unknown/undefined) format
					 */
					if (tuple.length != (tmp_count*5 + 1)) {
						DPRINTF((" bogus length %d\n",
						    tuple.length));
						break;
					}

#ifdef PCMCIACISDEBUG	/* maybe enable all the time? */
					/*
					 * sanity check for a programming
					 * error which is difficult to find
					 * when debugging.
					 */
					if (tmp_count >
					    howmany(sizeof mfc, sizeof mfc[0]))
						panic("CISTPL_LONGLINK_MFC mfc "
						    "count would blow stack");
#endif

					mfc_count = tmp_count;
					for (i = 0; i < mfc_count; i++) {
						mfc[i].common =
						    (pcmcia_tuple_read_1(&tuple,
						    1 + 5 * i) ==
						    PCMCIA_MFC_MEM_COMMON) ?
						    1 : 0;
						mfc[i].addr =
						    pcmcia_tuple_read_4(&tuple,
						    1 + 5 * i + 1);
						DPRINTF((" %s:%lx",
						    mfc[i].common ? "common" :
						    "attr", mfc[i].addr));
					}
					DPRINTF(("\n"));
				}
				/*
				 * for LONGLINK_MFC, fall through to the
				 * function.  This tuple has structural and
				 * semantic content.
				 */
			default:
				{
					if ((*fct) (&tuple, arg)) {
						pcmcia_chip_mem_unmap(pct,
						    pch, window);
						ret = 1;
						goto done;
					}
				}
				break;
			}	/* switch */
#ifdef PCMCIACISDEBUG
			/* print the tuple */
			{
				int i;

				DPRINTF((" %02x %02x", tuple.code,
				    tuple.length));

				for (i = 0; i < tuple.length; i++) {
					DPRINTF((" %02x",
					    pcmcia_tuple_read_1(&tuple, i)));
					if ((i % 16) == 13)
						DPRINTF(("\n"));
				}
				if ((i % 16) != 14)
					DPRINTF(("\n"));
			}
#endif
			/* skip to the next tuple */
			tuple.ptr += 2 + tuple.length;
		}

		/*
		 * the chain is done.  Clean up and move onto the next one,
		 * if any.  The loop is here in the case that there is an MFC
		 * card with no longlink (which defaults to existing, == 0).
		 * In general, this means that if one pointer fails, it will
		 * try the next one, instead of just bailing.
		 */

		while (1) {
			pcmcia_chip_mem_unmap(pct, pch, window);

			if (indirect_present) {
				/*
				 * Indirect CIS data needs to be obtained
				 * from specific registers accessible at
				 * a fixed location in the common window,
				 * but otherwise is similar to longlink
				 * in attribute memory.
				 */

				pcmcia_chip_mem_map(pct, pch, PCMCIA_MEM_COMMON,
				    0, PCMCIA_INDR_SIZE,
				    &pcmh, &tuple.indirect_ptr, &window);

				DPRINTF(("cis mem map %x ind %x\n",
				    (unsigned int) tuple.memh,
				    (unsigned int) tuple.indirect_ptr));

				tuple.addrshift = 1;
				tuple.flags |= PTF_INDIRECT;
				tuple.ptr = 0;
				longlink_present = 0;
				indirect_present = 0;
			} else if (longlink_present) {
				/*
				 * if the longlink is to attribute memory,
				 * then it is unindexed.  That is, if the
				 * link value is 0x100, then the actual
				 * memory address is 0x200.  This means that
				 * we need to multiply by 2 before calling
				 * mem_map, and then divide the resulting ptr
				 * by 2 after.
				 */

				if (!longlink_common)
					longlink_addr *= 2;

				pcmcia_chip_mem_map(pct, pch, longlink_common ?
				    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,
				    longlink_addr, PCMCIA_CIS_SIZE,
				    &pcmh, &tuple.ptr, &window);

				if (!longlink_common)
					tuple.ptr /= 2;

				DPRINTF(("cis mem map %x\n",
				    (unsigned int) tuple.memh));

				tuple.addrshift = longlink_common ? 0 : 1;
				longlink_present = 0;
				longlink_common = 1;
				longlink_addr = 0;
			} else if (mfc_count && (mfc_index < mfc_count)) {
				if (!mfc[mfc_index].common)
					mfc[mfc_index].addr *= 2;

				pcmcia_chip_mem_map(pct, pch,
				    mfc[mfc_index].common ?
				    PCMCIA_MEM_COMMON : PCMCIA_MEM_ATTR,
				    mfc[mfc_index].addr, PCMCIA_CIS_SIZE,
				    &pcmh, &tuple.ptr, &window);

				if (!mfc[mfc_index].common)
					tuple.ptr /= 2;

				DPRINTF(("cis mem map %x\n",
				    (unsigned int) tuple.memh));

				/* set parse state, and point at the next one */

				tuple.addrshift = mfc[mfc_index].common ? 0 : 1;

				mfc_index++;
			} else {
				goto done;
			}

			/* make sure that the link is valid */
			tuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);
			if (tuple.code != PCMCIA_CISTPL_LINKTARGET) {
				DPRINTF(("CISTPL_LINKTARGET expected, "
				    "code %02x observed\n", tuple.code));
				continue;
			}
			tuple.length = pcmcia_cis_read_1(&tuple, tuple.ptr + 1);
			if (tuple.length < 3) {
				DPRINTF(("CISTPL_LINKTARGET too short %d\n",
				    tuple.length));
				continue;
			}
			if ((pcmcia_tuple_read_1(&tuple, 0) != 'C') ||
			    (pcmcia_tuple_read_1(&tuple, 1) != 'I') ||
			    (pcmcia_tuple_read_1(&tuple, 2) != 'S')) {
				DPRINTF(("CISTPL_LINKTARGET magic "
				    "%02x%02x%02x incorrect\n",
				    pcmcia_tuple_read_1(&tuple, 0),
				    pcmcia_tuple_read_1(&tuple, 1),
				    pcmcia_tuple_read_1(&tuple, 2)));
				continue;
			}
			tuple.ptr += 2 + tuple.length;

			break;
		}
	}

	pcmcia_chip_mem_unmap(pct, pch, window);

done:
	/* Last, free the allocated memory block */
	pcmcia_chip_mem_free(pct, pch, &pcmh);

	return (ret);
}

/* XXX this is incredibly verbose.  Not sure what trt is */

void
pcmcia_print_cis(sc)
	struct pcmcia_softc *sc;
{
	struct pcmcia_card *card = &sc->card;
	struct pcmcia_function *pf;
	struct pcmcia_config_entry *cfe;
	int i;

	printf("%s: CIS version ", sc->dev.dv_xname);
	if (card->cis1_major == 4) {
		if (card->cis1_minor == 0)
			printf("PCMCIA 1.0\n");
		else if (card->cis1_minor == 1)
			printf("PCMCIA 2.0 or 2.1\n");
	} else if (card->cis1_major >= 5)
		printf("PC Card Standard %d.%d\n", card->cis1_major,
		    card->cis1_minor);
	else
		printf("unknown (major=%d, minor=%d)\n",
		    card->cis1_major, card->cis1_minor);

	printf("%s: CIS info: ", sc->dev.dv_xname);
	for (i = 0; i < 4; i++) {
		if (card->cis1_info[i] == NULL)
			break;
		if (i)
			printf(", ");
		printf("%s", card->cis1_info[i]);
	}
	printf("\n");

	printf("%s: Manufacturer code 0x%x, product 0x%x\n",
	       sc->dev.dv_xname, card->manufacturer, card->product);

	SIMPLEQ_FOREACH(pf, &card->pf_head, pf_list) {
		printf("%s: function %d: ", sc->dev.dv_xname, pf->number);

		switch (pf->function) {
		case PCMCIA_FUNCTION_UNSPEC:
			printf("unspecified");
			break;
		case PCMCIA_FUNCTION_MULTIFUNCTION:
			printf("multi-function");
			break;
		case PCMCIA_FUNCTION_MEMORY:
			printf("memory");
			break;
		case PCMCIA_FUNCTION_SERIAL:
			printf("serial port");
			break;
		case PCMCIA_FUNCTION_PARALLEL:
			printf("parallel port");
			break;
		case PCMCIA_FUNCTION_DISK:
			printf("fixed disk");
			break;
		case PCMCIA_FUNCTION_VIDEO:
			printf("video adapter");
			break;
		case PCMCIA_FUNCTION_NETWORK:
			printf("network adapter");
			break;
		case PCMCIA_FUNCTION_AIMS:
			printf("auto incrementing mass storage");
			break;
		case PCMCIA_FUNCTION_SCSI:
			printf("SCSI bridge");
			break;
		case PCMCIA_FUNCTION_SECURITY:
			printf("Security services");
			break;
		case PCMCIA_FUNCTION_INSTRUMENT:
			printf("Instrument");
			break;
		case PCMCIA_FUNCTION_IOBUS:
			printf("Serial I/O Bus Adapter");
			break;
		default:
			printf("unknown (%d)", pf->function);
			break;
		}

		printf(", ccr addr %lx mask %lx\n", pf->ccr_base, pf->ccr_mask);

		SIMPLEQ_FOREACH(cfe, &pf->cfe_head, cfe_list) {
			printf("%s: function %d, config table entry %d: ",
			    sc->dev.dv_xname, pf->number, cfe->number);

			switch (cfe->iftype) {
			case PCMCIA_IFTYPE_MEMORY:
				printf("memory card");
				break;
			case PCMCIA_IFTYPE_IO:
				printf("I/O card");
				break;
			default:
				printf("card type unknown");
				break;
			}

			printf("; irq mask %x", cfe->irqmask);

			if (cfe->num_iospace) {
				printf("; iomask %lx, iospace", cfe->iomask);

				for (i = 0; i < cfe->num_iospace; i++)
					printf(" %lx%s%lx",
					    cfe->iospace[i].start,
					    cfe->iospace[i].length ? "-" : "",
					    cfe->iospace[i].start +
					      cfe->iospace[i].length - 1);
			}
			if (cfe->num_memspace) {
				printf("; memspace");

				for (i = 0; i < cfe->num_memspace; i++)
					printf(" %lx%s%lx%s%lx",
					    cfe->memspace[i].cardaddr,
					    cfe->memspace[i].length ? "-" : "",
					    cfe->memspace[i].cardaddr +
					      cfe->memspace[i].length - 1,
					    cfe->memspace[i].hostaddr ?
					      "@@" : "",
					    cfe->memspace[i].hostaddr);
			}
			if (cfe->maxtwins)
				printf("; maxtwins %d", cfe->maxtwins);

			printf(";");

			if (cfe->flags & PCMCIA_CFE_MWAIT_REQUIRED)
				printf(" mwait_required");
			if (cfe->flags & PCMCIA_CFE_RDYBSY_ACTIVE)
				printf(" rdybsy_active");
			if (cfe->flags & PCMCIA_CFE_WP_ACTIVE)
				printf(" wp_active");
			if (cfe->flags & PCMCIA_CFE_BVD_ACTIVE)
				printf(" bvd_active");
			if (cfe->flags & PCMCIA_CFE_IO8)
				printf(" io8");
			if (cfe->flags & PCMCIA_CFE_IO16)
				printf(" io16");
			if (cfe->flags & PCMCIA_CFE_IRQSHARE)
				printf(" irqshare");
			if (cfe->flags & PCMCIA_CFE_IRQPULSE)
				printf(" irqpulse");
			if (cfe->flags & PCMCIA_CFE_IRQLEVEL)
				printf(" irqlevel");
			if (cfe->flags & PCMCIA_CFE_POWERDOWN)
				printf(" powerdown");
			if (cfe->flags & PCMCIA_CFE_READONLY)
				printf(" readonly");
			if (cfe->flags & PCMCIA_CFE_AUDIO)
				printf(" audio");

			printf("\n");
		}
	}

	if (card->error)
		printf("%s: %d errors found while parsing CIS\n",
		    sc->dev.dv_xname, card->error);
}

int
pcmcia_parse_cis_tuple(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	/* most of these are educated guesses */
	static struct pcmcia_config_entry init_cfe = {
		-1, PCMCIA_CFE_RDYBSY_ACTIVE | PCMCIA_CFE_WP_ACTIVE |
		PCMCIA_CFE_BVD_ACTIVE, PCMCIA_IFTYPE_MEMORY,
	};

	struct cis_state *state = arg;

	switch (tuple->code) {
	case PCMCIA_CISTPL_END:
		/*
		 * If we've seen a LONGLINK_MFC, and this is the first
		 * END after it, reset the function list.  
		 *
		 * XXX This might also be the right place to start a
		 * new function, but that assumes that a function
		 * definition never crosses any longlink, and I'm not
		 * sure about that.  This is probably safe for MFC
		 * cards, but what we have now isn't broken, so I'd
		 * rather not change it.
		 */
		if (state->gotmfc == 1) {
			struct pcmcia_function *pf, *pfnext;

			for (pf = SIMPLEQ_FIRST(&state->card->pf_head);
			    pf != NULL; pf = pfnext) {
				pfnext = SIMPLEQ_NEXT(pf, pf_list);
				free(pf, M_DEVBUF, 0);
			}

			SIMPLEQ_INIT(&state->card->pf_head);

			state->count = 0;
			state->gotmfc = 2;
			state->pf = NULL;
		}
		break;

	case PCMCIA_CISTPL_LONGLINK_MFC:
		/*
		 * This tuple's structure was dealt with in scan_cis.  here,
		 * record the fact that the MFC tuple was seen, so that
		 * functions declared before the MFC link can be cleaned
		 * up.
		 */
		state->gotmfc = 1;
		break;

#ifdef PCMCIACISDEBUG
	case PCMCIA_CISTPL_DEVICE:
	case PCMCIA_CISTPL_DEVICE_A:
		{
			u_int reg, dtype, dspeed;

			reg = pcmcia_tuple_read_1(tuple, 0);
			dtype = reg & PCMCIA_DTYPE_MASK;
			dspeed = reg & PCMCIA_DSPEED_MASK;

			DPRINTF(("CISTPL_DEVICE%s type=",
			(tuple->code == PCMCIA_CISTPL_DEVICE) ? "" : "_A"));
			switch (dtype) {
			case PCMCIA_DTYPE_NULL:
				DPRINTF(("null"));
				break;
			case PCMCIA_DTYPE_ROM:
				DPRINTF(("rom"));
				break;
			case PCMCIA_DTYPE_OTPROM:
				DPRINTF(("otprom"));
				break;
			case PCMCIA_DTYPE_EPROM:
				DPRINTF(("eprom"));
				break;
			case PCMCIA_DTYPE_EEPROM:
				DPRINTF(("eeprom"));
				break;
			case PCMCIA_DTYPE_FLASH:
				DPRINTF(("flash"));
				break;
			case PCMCIA_DTYPE_SRAM:
				DPRINTF(("sram"));
				break;
			case PCMCIA_DTYPE_DRAM:
				DPRINTF(("dram"));
				break;
			case PCMCIA_DTYPE_FUNCSPEC:
				DPRINTF(("funcspec"));
				break;
			case PCMCIA_DTYPE_EXTEND:
				DPRINTF(("extend"));
				break;
			default:
				DPRINTF(("reserved"));
				break;
			}
			DPRINTF((" speed="));
			switch (dspeed) {
			case PCMCIA_DSPEED_NULL:
				DPRINTF(("null"));
				break;
			case PCMCIA_DSPEED_250NS:
				DPRINTF(("250ns"));
				break;
			case PCMCIA_DSPEED_200NS:
				DPRINTF(("200ns"));
				break;
			case PCMCIA_DSPEED_150NS:
				DPRINTF(("150ns"));
				break;
			case PCMCIA_DSPEED_100NS:
				DPRINTF(("100ns"));
				break;
			case PCMCIA_DSPEED_EXT:
				DPRINTF(("ext"));
				break;
			default:
				DPRINTF(("reserved"));
				break;
			}
		}
		DPRINTF(("\n"));
		break;
#endif

	case PCMCIA_CISTPL_VERS_1:
		if (tuple->length < 6) {
			DPRINTF(("CISTPL_VERS_1 too short %d\n",
			    tuple->length));
			break;
		} {
			int start, i, ch, count;

			state->card->cis1_major = pcmcia_tuple_read_1(tuple, 0);
			state->card->cis1_minor = pcmcia_tuple_read_1(tuple, 1);

			for (count = 0, start = 0, i = 0;
			    (count < 4) && ((i + 4) < 256); i++) {
				ch = pcmcia_tuple_read_1(tuple, 2 + i);
				if (ch == 0xff)
					break;
				state->card->cis1_info_buf[i] = ch;
				if (ch == 0) {
					state->card->cis1_info[count] =
					    state->card->cis1_info_buf + start;
					start = i + 1;
					count++;
				}
			}
			DPRINTF(("CISTPL_VERS_1\n"));
		}
		break;

	case PCMCIA_CISTPL_MANFID:
		if (tuple->length < 4) {
			DPRINTF(("CISTPL_MANFID too short %d\n",
			    tuple->length));
			break;
		}
		state->card->manufacturer = pcmcia_tuple_read_2(tuple, 0);
		state->card->product = pcmcia_tuple_read_2(tuple, 2);
		DPRINTF(("CISTPL_MANFID\n"));
		break;

	case PCMCIA_CISTPL_FUNCID:
		if (tuple->length < 2) {
			DPRINTF(("CISTPL_FUNCID too short %d\n",
			    tuple->length));
			break;
		}

		/*
		 * As far as I understand this, manufacturers do multifunction
		 * cards in various ways.  Sadly enough I do not have the
		 * PC-Card standard (donate!) so I can only guess what can
		 * be done.
		 * The original code implies FUNCID nodes are above CONFIG
		 * nodes in the CIS tree, however Xircom does it the other
		 * way round, which of course makes things a bit hard.
		 * --niklas@@openbsd.org
		 */
		if (state->pf) {
			if (state->pf->function == PCMCIA_FUNCTION_UNSPEC) {
				/*
				 * This looks like a opportunistic function
				 * created by a CONFIG tuple.  Just keep it.
				 */
			} else {
				/*
				 * A function is being defined, end it.
				 */
				state->pf = NULL;
			}
		}
		if (state->pf == NULL) {
			state->pf = malloc(sizeof(*state->pf), M_DEVBUF,
			    M_NOWAIT | M_ZERO);
			if (state->pf == NULL)
				panic("pcmcia_parse_cis_tuple");
			state->pf->number = state->count++;
			state->pf->last_config_index = -1;
			SIMPLEQ_INIT(&state->pf->cfe_head);

			SIMPLEQ_INSERT_TAIL(&state->card->pf_head, state->pf,
			    pf_list);
		}
		state->pf->function = pcmcia_tuple_read_1(tuple, 0);

		DPRINTF(("CISTPL_FUNCID\n"));
		break;

	case PCMCIA_CISTPL_CONFIG:
		if (tuple->length < 3) {
			DPRINTF(("CISTPL_CONFIG too short %d\n",
			    tuple->length));
			break;
		} {
			u_int reg, rasz, rmsz, rfsz;
			int i;

			reg = pcmcia_tuple_read_1(tuple, 0);
			rasz = 1 + ((reg & PCMCIA_TPCC_RASZ_MASK) >>
			    PCMCIA_TPCC_RASZ_SHIFT);
			rmsz = 1 + ((reg & PCMCIA_TPCC_RMSZ_MASK) >>
			    PCMCIA_TPCC_RMSZ_SHIFT);
			rfsz = ((reg & PCMCIA_TPCC_RFSZ_MASK) >>
			    PCMCIA_TPCC_RFSZ_SHIFT);

			if (tuple->length < 2 + rasz + rmsz + rfsz) {
				DPRINTF(("CISTPL_CONFIG (%d,%d,%d) too "
				    "short %d\n", rasz, rmsz, rfsz,
				    tuple->length));
				break;
			}
			if (state->pf == NULL) {
				state->pf = malloc(sizeof(*state->pf),
				    M_DEVBUF, M_NOWAIT | M_ZERO);
				if (state->pf == NULL)
					panic("pcmcia_parse_cis_tuple");
				state->pf->number = state->count++;
				state->pf->last_config_index = -1;
				SIMPLEQ_INIT(&state->pf->cfe_head);

				SIMPLEQ_INSERT_TAIL(&state->card->pf_head,
				    state->pf, pf_list);

				state->pf->function = PCMCIA_FUNCTION_UNSPEC;
			}
			state->pf->last_config_index =
			    pcmcia_tuple_read_1(tuple, 1);

			state->pf->ccr_base = 0;
			for (i = 0; i < rasz; i++)
				state->pf->ccr_base |=
				    ((pcmcia_tuple_read_1(tuple, 2 + i)) <<
				    (i * 8));

			state->pf->ccr_mask = 0;
			for (i = 0; i < rmsz; i++)
				state->pf->ccr_mask |=
				    ((pcmcia_tuple_read_1(tuple,
				    2 + rasz + i)) << (i * 8));

			/* skip the reserved area and subtuples */

			/* reset the default cfe for each cfe list */
			state->temp_cfe = init_cfe;
			state->default_cfe = &state->temp_cfe;
		}
		DPRINTF(("CISTPL_CONFIG\n"));
		break;

	case PCMCIA_CISTPL_CFTABLE_ENTRY:
		if (tuple->length < 2) {
			DPRINTF(("CISTPL_CFTABLE_ENTRY too short %d\n",
			    tuple->length));
			break;
		} {
			int idx, i, j;
			u_int reg, reg2;
			u_int intface, def, num;
			u_int power, timing, iospace, irq, memspace, misc;
			struct pcmcia_config_entry *cfe;

			idx = 0;

			reg = pcmcia_tuple_read_1(tuple, idx);
			idx++;
			intface = reg & PCMCIA_TPCE_INDX_INTFACE;
			def = reg & PCMCIA_TPCE_INDX_DEFAULT;
			num = reg & PCMCIA_TPCE_INDX_NUM_MASK;

			/*
			 * this is a little messy.  Some cards have only a
			 * cfentry with the default bit set.  So, as we go
			 * through the list, we add new indexes to the queue,
			 * and keep a pointer to the last one with the
			 * default bit set.  if we see a record with the same
			 * index, as the default, we stash the default and
			 * replace the queue entry. otherwise, we just add
			 * new entries to the queue, pointing the default ptr
			 * at them if the default bit is set.  if we get to
			 * the end with the default pointer pointing at a
			 * record which hasn't had a matching index, that's
			 * ok; it just becomes a cfentry like any other.
			 */

			/*
			 * if the index in the cis differs from the default
			 * cis, create new entry in the queue and start it
			 * with the current default
			 */
			if (state->default_cfe == NULL) {
				DPRINTF(("CISTPL_CFTABLE_ENTRY with no "
				    "default\n"));
				break;
			}
			if (num != state->default_cfe->number) {
				cfe = (struct pcmcia_config_entry *)
				    malloc(sizeof(*cfe), M_DEVBUF, M_NOWAIT);
				if (cfe == NULL)
					panic("pcmcia_parse_cis_tuple");

				*cfe = *state->default_cfe;

				SIMPLEQ_INSERT_TAIL(&state->pf->cfe_head,
				    cfe, cfe_list);

				cfe->number = num;

				/*
				 * if the default bit is set in the cis, then
				 * point the new default at whatever is being
				 * filled in
				 */
				if (def)
					state->default_cfe = cfe;
			} else {
				/*
				 * the cis index matches the default index,
				 * fill in the default cfentry.  It is
				 * assumed that the cfdefault index is in the
				 * queue.  For it to be otherwise, the cis
				 * index would have to be -1 (initial
				 * condition) which is not possible, or there
				 * would have to be a preceding cis entry
				 * which had the same cis index and had the
				 * default bit unset. Neither condition
				 * should happen.  If it does, this cfentry
				 * is lost (written into temp space), which
				 * is an acceptable failure mode.
				 */

				cfe = state->default_cfe;

				/*
				 * if the cis entry does not have the default
				 * bit set, copy the default out of the way
				 * first.
				 */
				if (!def) {
					state->temp_cfe = *state->default_cfe;
					state->default_cfe = &state->temp_cfe;
				}
			}

			if (intface) {
				reg = pcmcia_tuple_read_1(tuple, idx);
				idx++;
				cfe->flags &= ~(PCMCIA_CFE_MWAIT_REQUIRED
				    | PCMCIA_CFE_RDYBSY_ACTIVE
				    | PCMCIA_CFE_WP_ACTIVE
				    | PCMCIA_CFE_BVD_ACTIVE);
				if (reg & PCMCIA_TPCE_IF_MWAIT)
					cfe->flags |= PCMCIA_CFE_MWAIT_REQUIRED;
				if (reg & PCMCIA_TPCE_IF_RDYBSY)
					cfe->flags |= PCMCIA_CFE_RDYBSY_ACTIVE;
				if (reg & PCMCIA_TPCE_IF_WP)
					cfe->flags |= PCMCIA_CFE_WP_ACTIVE;
				if (reg & PCMCIA_TPCE_IF_BVD)
					cfe->flags |= PCMCIA_CFE_BVD_ACTIVE;
				cfe->iftype = reg & PCMCIA_TPCE_IF_IFTYPE;
			}
			reg = pcmcia_tuple_read_1(tuple, idx);
			idx++;

			power = reg & PCMCIA_TPCE_FS_POWER_MASK;
			timing = reg & PCMCIA_TPCE_FS_TIMING;
			iospace = reg & PCMCIA_TPCE_FS_IOSPACE;
			irq = reg & PCMCIA_TPCE_FS_IRQ;
			memspace = reg & PCMCIA_TPCE_FS_MEMSPACE_MASK;
			misc = reg & PCMCIA_TPCE_FS_MISC;

			if (power) {
				/* skip over power, don't save */
				/* for each parameter selection byte */
				for (i = 0; i < power; i++) {
					reg = pcmcia_tuple_read_1(tuple, idx);
					idx++;
					/* for each bit */
					for (j = 0; j < 7; j++) {
						/* if the bit is set */
						if ((reg >> j) & 0x01) {
							/* skip over bytes */
							do {
								reg2 = pcmcia_tuple_read_1(tuple, idx);
								idx++;
								/*
								 * until
								 * non-
								 * extension
								 * byte
								 */
							} while (reg2 & 0x80);
						}
					}
				}
			}
			if (timing) {
				/* skip over timing, don't save */
				reg = pcmcia_tuple_read_1(tuple, idx);
				idx++;

				if ((reg & PCMCIA_TPCE_TD_RESERVED_MASK) !=
				    PCMCIA_TPCE_TD_RESERVED_MASK)
					idx++;
				if ((reg & PCMCIA_TPCE_TD_RDYBSY_MASK) !=
				    PCMCIA_TPCE_TD_RDYBSY_MASK)
					idx++;
				if ((reg & PCMCIA_TPCE_TD_WAIT_MASK) !=
				    PCMCIA_TPCE_TD_WAIT_MASK)
					idx++;
			}
			if (iospace) {
				if (tuple->length <= idx) {
					DPRINTF(("ran out of space before TPCE_IO\n"));

					goto abort_cfe;
				}

				reg = pcmcia_tuple_read_1(tuple, idx);
				idx++;

				cfe->flags &=
				    ~(PCMCIA_CFE_IO8 | PCMCIA_CFE_IO16);
				if (reg & PCMCIA_TPCE_IO_BUSWIDTH_8BIT)
					cfe->flags |= PCMCIA_CFE_IO8;
				if (reg & PCMCIA_TPCE_IO_BUSWIDTH_16BIT)
					cfe->flags |= PCMCIA_CFE_IO16;
				cfe->iomask =
				    reg & PCMCIA_TPCE_IO_IOADDRLINES_MASK;

				if (reg & PCMCIA_TPCE_IO_HASRANGE) {
					reg = pcmcia_tuple_read_1(tuple, idx);
					idx++;

					cfe->num_iospace = 1 + (reg &
					    PCMCIA_TPCE_IO_RANGE_COUNT);

					if (cfe->num_iospace >
					    (sizeof(cfe->iospace) /
					     sizeof(cfe->iospace[0]))) {
						DPRINTF(("too many io "
						    "spaces %d",
						    cfe->num_iospace));
						state->card->error++;
						break;
					}
					for (i = 0; i < cfe->num_iospace; i++) {
						switch (reg & PCMCIA_TPCE_IO_RANGE_ADDRSIZE_MASK) {
						case PCMCIA_TPCE_IO_RANGE_ADDRSIZE_ONE:
							cfe->iospace[i].start =
								pcmcia_tuple_read_1(tuple, idx);
							idx++;
							break;
						case PCMCIA_TPCE_IO_RANGE_ADDRSIZE_TWO:
							cfe->iospace[i].start =
								pcmcia_tuple_read_2(tuple, idx);
							idx += 2;
							break;
						case PCMCIA_TPCE_IO_RANGE_ADDRSIZE_FOUR:
							cfe->iospace[i].start =
								pcmcia_tuple_read_4(tuple, idx);
							idx += 4;
							break;
						}
						switch (reg &
							PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_MASK) {
						case PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_ONE:
							cfe->iospace[i].length =
								pcmcia_tuple_read_1(tuple, idx);
							idx++;
							break;
						case PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_TWO:
							cfe->iospace[i].length =
								pcmcia_tuple_read_2(tuple, idx);
							idx += 2;
							break;
						case PCMCIA_TPCE_IO_RANGE_LENGTHSIZE_FOUR:
							cfe->iospace[i].length =
								pcmcia_tuple_read_4(tuple, idx);
							idx += 4;
							break;
						}
						cfe->iospace[i].length++;
					}
				} else {
					cfe->num_iospace = 1;
					cfe->iospace[0].start = 0;
					cfe->iospace[0].length =
					    (1 << cfe->iomask);
				}
			}

			if (irq) {
				if (tuple->length <= idx) {
					DPRINTF(("ran out of space before TPCE_IR\n"));

					goto abort_cfe;
				}

				reg = pcmcia_tuple_read_1(tuple, idx);
				idx++;

				cfe->flags &= ~(PCMCIA_CFE_IRQSHARE
				    | PCMCIA_CFE_IRQPULSE
				    | PCMCIA_CFE_IRQLEVEL);
				if (reg & PCMCIA_TPCE_IR_SHARE)
					cfe->flags |= PCMCIA_CFE_IRQSHARE;
				if (reg & PCMCIA_TPCE_IR_PULSE)
					cfe->flags |= PCMCIA_CFE_IRQPULSE;
				if (reg & PCMCIA_TPCE_IR_LEVEL)
					cfe->flags |= PCMCIA_CFE_IRQLEVEL;

				if (reg & PCMCIA_TPCE_IR_HASMASK) {
					/*
					 * it's legal to ignore the
					 * special-interrupt bits, so I will
					 */

					cfe->irqmask =
					    pcmcia_tuple_read_2(tuple, idx);
					idx += 2;
				} else {
					cfe->irqmask =
					    (1 << (reg & PCMCIA_TPCE_IR_IRQ));
				}
			}
			if (memspace) {
				if (tuple->length <= idx) {
					DPRINTF(("ran out of space before TPCE_MS\n"));
					goto abort_cfe;
				}

				if (memspace == PCMCIA_TPCE_FS_MEMSPACE_NONE) {
					cfe->num_memspace = 0;
				} else if (memspace == PCMCIA_TPCE_FS_MEMSPACE_LENGTH) {
					cfe->num_memspace = 1;
					cfe->memspace[0].length = 256 *
					    pcmcia_tuple_read_2(tuple, idx);
					idx += 2;
					cfe->memspace[0].cardaddr = 0;
					cfe->memspace[0].hostaddr = 0;
				} else if (memspace ==
				    PCMCIA_TPCE_FS_MEMSPACE_LENGTHADDR) {
					cfe->num_memspace = 1;
					cfe->memspace[0].length = 256 *
					    pcmcia_tuple_read_2(tuple, idx);
					idx += 2;
					cfe->memspace[0].cardaddr = 256 *
					    pcmcia_tuple_read_2(tuple, idx);
					idx += 2;
					cfe->memspace[0].hostaddr = cfe->memspace[0].cardaddr;
				} else {
					int lengthsize;
					int cardaddrsize;
					int hostaddrsize;

					reg = pcmcia_tuple_read_1(tuple, idx);
					idx++;

					cfe->num_memspace = (reg &
					    PCMCIA_TPCE_MS_COUNT) + 1;

					if (cfe->num_memspace >
					    (sizeof(cfe->memspace) /
					     sizeof(cfe->memspace[0]))) {
						DPRINTF(("too many mem "
						    "spaces %d",
						    cfe->num_memspace));
						state->card->error++;
						break;
					}
					lengthsize =
						((reg & PCMCIA_TPCE_MS_LENGTH_SIZE_MASK) >>
						 PCMCIA_TPCE_MS_LENGTH_SIZE_SHIFT);
					cardaddrsize =
						((reg & PCMCIA_TPCE_MS_CARDADDR_SIZE_MASK) >>
						 PCMCIA_TPCE_MS_CARDADDR_SIZE_SHIFT);
					hostaddrsize =
						(reg & PCMCIA_TPCE_MS_HOSTADDR) ? cardaddrsize : 0;

					if (lengthsize == 0) {
						DPRINTF(("cfe memspace "
						    "lengthsize == 0"));
						state->card->error++;
					}
					for (i = 0; i < cfe->num_memspace; i++) {
						if (lengthsize) {
							cfe->memspace[i].length =
								256 * pcmcia_tuple_read_n(tuple, lengthsize,
								       idx);
							idx += lengthsize;
						} else {
							cfe->memspace[i].length = 0;
						}
						if (cfe->memspace[i].length == 0) {
							DPRINTF(("cfe->memspace[%d].length == 0",
								 i));
							state->card->error++;
						}
						if (cardaddrsize) {
							cfe->memspace[i].cardaddr =
								256 * pcmcia_tuple_read_n(tuple, cardaddrsize,
								       idx);
							idx += cardaddrsize;
						} else {
							cfe->memspace[i].cardaddr = 0;
						}
						if (hostaddrsize) {
							cfe->memspace[i].hostaddr =
								256 * pcmcia_tuple_read_n(tuple, hostaddrsize,
								       idx);
							idx += hostaddrsize;
						} else {
							cfe->memspace[i].hostaddr = 0;
						}
					}
				}
			}
			if (misc) {
				if (tuple->length <= idx) {
					DPRINTF(("ran out of space before TPCE_MI\n"));

					goto abort_cfe;
				}

				reg = pcmcia_tuple_read_1(tuple, idx);
				idx++;

				cfe->flags &= ~(PCMCIA_CFE_POWERDOWN
				    | PCMCIA_CFE_READONLY
				    | PCMCIA_CFE_AUDIO);
				if (reg & PCMCIA_TPCE_MI_PWRDOWN)
					cfe->flags |= PCMCIA_CFE_POWERDOWN;
				if (reg & PCMCIA_TPCE_MI_READONLY)
					cfe->flags |= PCMCIA_CFE_READONLY;
				if (reg & PCMCIA_TPCE_MI_AUDIO)
					cfe->flags |= PCMCIA_CFE_AUDIO;
				cfe->maxtwins = reg & PCMCIA_TPCE_MI_MAXTWINS;

				while (reg & PCMCIA_TPCE_MI_EXT) {
					reg = pcmcia_tuple_read_1(tuple, idx);
					idx++;
				}
			}
			/* skip all the subtuples */
		}

	abort_cfe:
		DPRINTF(("CISTPL_CFTABLE_ENTRY\n"));
		break;

	default:
		DPRINTF(("unhandled CISTPL %x\n", tuple->code));
		break;
	}

	return (0);
}
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.19 2013/07/10 05:36:40 brad Exp $	*/
a32 1
#include <sys/types.h>
@


1.19
log
@Remove unsigned comparison < 0.

Pointed out by LLVM.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.18 2010/09/04 13:14:49 miod Exp $	*/
d728 1
a728 1
				free(pf, M_DEVBUF);
@


1.18
log
@Off-by-two in the length check for CISTPL_CONFIG tuples.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.17 2010/09/04 13:13:17 miod Exp $	*/
a273 1
					    ((addr + length) < 0) ||
@


1.17
log
@Use pcmcia_cis_read_1() to read cis data to be checksummed, instead of
trying to roll our inline version of it and fail. Fixes `checksum error'
warnings on all the cards with checksum tuples I could find (admittedly not
many), and probably fixes all of them since this code has never been correct
in the first place.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.16 2010/09/04 12:59:27 miod Exp $	*/
d929 1
a929 1
			if (tuple->length < (rasz + rmsz + rfsz)) {
@


1.16
log
@Add support for indirect CIS data (CISTPL_INDIRECT tuple).
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.15 2007/09/11 13:39:34 gilles Exp $	*/
d283 2
a284 4
						sum +=
						    bus_space_read_1(tuple.memt,
						    tuple.memh, addr +
						    (i << tuple.addrshift));
@


1.15
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.14 2007/09/07 18:21:40 fgsch Exp $	*/
d62 22
d124 1
d166 2
a167 1
	tuple.mult = 2;
d169 1
d187 2
a188 2
			if (tuple.mult * tuple.ptr >= PCMCIA_CIS_SIZE - 1
			    - 32 /* ad hoc value */ ) {
d222 4
d285 2
a286 2
						    tuple.memh,
						    addr + tuple.mult * i);
d418 23
a440 1
			if (longlink_present) {
d465 1
a465 1
				tuple.mult = longlink_common ? 1 : 2;
d487 1
a487 1
				tuple.mult = mfc[mfc_index].common ? 1 : 2;
@


1.14
log
@sprinkle some M_ZERO love.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.13 2005/08/01 21:58:01 fgsch Exp $	*/
d848 1
a848 1
			    M_NOWAIT|M_ZERO);
d888 1
a888 1
				    M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.13
log
@CISTPL_CONFIG min length should be 3, not 5. audiovox GPRS works now.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.12 2004/09/16 07:19:49 brad Exp $	*/
d848 1
a848 1
			    M_NOWAIT);
a850 1
			bzero(state->pf, sizeof(*state->pf));
d888 1
a888 1
				    M_DEVBUF, M_NOWAIT);
a890 1
				bzero(state->pf, sizeof(*state->pf));
@


1.12
log
@some additional CIS sanity checks.

From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.11 2003/10/22 09:58:46 jmc Exp $	*/
d865 1
a865 1
		if (tuple->length < 5) {
@


1.11
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.10 2003/05/06 11:22:30 henning Exp $	*/
d68 1
a68 2
	state.count = 0;
	state.gotmfc = 0;
d156 13
d170 2
a171 5
			if (tuple.ptr * tuple.mult < PCMCIA_CIS_SIZE)
				tuple.code = pcmcia_cis_read_1(&tuple,
				    tuple.ptr);
			else
				tuple.code = PCMCIA_CISTPL_END;
d181 1
d288 1
a288 1
					int i;
d290 7
a296 1
					mfc_count =
d299 26
a324 1
					    mfc_count));
d966 5
@


1.10
log
@range check for the CIS table scan
normally, the CIS table is scanned until we hit the end tuple (CISTPL_END). I
have at least one card with an invalid CIS table without end tuple - while
this card is in error, this should not bring us to ddb. thus stop scanning
when we reach PCMCIA_CIS_SIZE

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.9 2002/11/19 18:36:18 jason Exp $	*/
d1017 3
a1019 2
								 * non-extensi
								 * on byte
@


1.9
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.8 2002/06/19 19:03:25 fgsch Exp $	*/
d158 5
a162 2

			tuple.code = pcmcia_cis_read_1(&tuple, tuple.ptr);
@


1.8
log
@move initialization a bit later.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.7 2002/03/14 01:27:01 millert Exp $	*/
d474 1
a474 2
	for (pf = card->pf_head.sqh_first; pf != NULL;
	    pf = pf->pf_list.sqe_next) {
d524 1
a524 2
		for (cfe = pf->cfe_head.sqh_first; cfe != NULL;
		    cfe = cfe->cfe_list.sqe_next) {
d633 3
a635 3
			for (pf = state->card->pf_head.sqh_first; pf != NULL;
			    pf = pfnext) {
				pfnext = pf->pf_list.sqe_next;
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.6 2002/01/11 01:31:21 nordin Exp $	*/
a127 2
	tuple.memt = pcmh.memt;
	tuple.memh = pcmh.memh;
d139 3
@


1.6
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.5 2000/06/06 01:02:26 fgsch Exp $	*/
d60 1
a60 1
int	pcmcia_parse_cis_tuple __P((struct pcmcia_tuple *, void *));
d94 1
a94 1
	int (*fct) __P((struct pcmcia_tuple *, void *));
@


1.5
log
@* correct some length checkings based on the specs; still a few to fix.
* add 1 to number of memspaces since MS_COUNT it's minus 1.
* print the correct function type in case of IOBUS.
* clean cfe->flags if intface is present
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.4 2000/05/29 21:39:06 fgsch Exp $	*/
d806 2
d847 2
d926 2
@


1.5.8.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.6 2002/01/11 01:31:21 nordin Exp $	*/
a805 2
			if (state->pf == NULL)
				panic("pcmcia_parse_cis_tuple");
a844 2
				if (state->pf == NULL)
					panic("pcmcia_parse_cis_tuple");
a921 2
				if (cfe == NULL)
					panic("pcmcia_parse_cis_tuple");
@


1.5.8.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.5.8.1 2002/01/31 22:55:37 niklas Exp $	*/
d60 1
a60 1
int	pcmcia_parse_cis_tuple(struct pcmcia_tuple *, void *);
d94 1
a94 1
	int (*fct)(struct pcmcia_tuple *, void *);
@


1.5.8.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.5.8.2 2002/06/11 03:42:28 art Exp $	*/
d128 2
a140 3
	tuple.memt = pcmh.memt;
	tuple.memh = pcmh.memh;

@


1.5.8.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 2
a159 5
			if (tuple.ptr * tuple.mult < PCMCIA_CIS_SIZE)
				tuple.code = pcmcia_cis_read_1(&tuple,
				    tuple.ptr);
			else
				tuple.code = PCMCIA_CISTPL_END;
d474 2
a475 1
	SIMPLEQ_FOREACH(pf, &card->pf_head, pf_list) {
d525 2
a526 1
		SIMPLEQ_FOREACH(cfe, &pf->cfe_head, cfe_list) {
d635 3
a637 3
			for (pf = SIMPLEQ_FIRST(&state->card->pf_head);
			    pf != NULL; pf = pfnext) {
				pfnext = SIMPLEQ_NEXT(pf, pf_list);
@


1.4
log
@OR the values in misc within cftable entry; in iospace, irq and misc
clean the flags before checking for particular capabilities. this is
needed because we use a template that might end messing the flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.3 1999/05/16 22:44:12 niklas Exp $	*/
d263 1
a263 1
				if (tuple.length < 1) {
d268 5
a272 4
				/*
				 * this is kind of ad hoc, as I don't have
				 * any real documentation
				 */
d454 2
a455 1
		printf("PC Card Standard %d.%d\n", card->cis1_major, card->cis1_minor);
d514 3
d774 1
a774 1
		if (tuple->length < 1) {
d820 1
a820 1
		if (tuple->length < 3) {
d880 5
a884 1
		{
d969 4
d1180 2
a1181 2
					cfe->num_memspace = reg &
					    PCMCIA_TPCE_MS_COUNT;
@


1.3
log
@Treat CIS functions a bit different as Xircom devices order the tuples a
bit backwards
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.2 1999/01/28 04:58:31 fgsch Exp $	*/
d1029 2
d1110 3
d1236 3
d1240 1
a1240 1
					cfe->flags = PCMCIA_CFE_POWERDOWN;
d1242 1
a1242 1
					cfe->flags = PCMCIA_CFE_READONLY;
d1244 1
a1244 1
					cfe->flags = PCMCIA_CFE_AUDIO;
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.5 2000/06/06 01:02:26 fgsch Exp $	*/
d263 1
a263 1
				if (tuple.length < 6) {
d268 4
a271 5
				if (((tuple.length - 1) % 5) != 0) {
					DPRINTF(("CISTPL_LONGLINK_MFC bogus "
					    "length %d\n", tuple.length));
					break;
				}
d453 1
a453 2
		printf("PC Card Standard %d.%d\n", card->cis1_major,
		    card->cis1_minor);
a511 3
		case PCMCIA_FUNCTION_IOBUS:
			printf("Serial I/O Bus Adapter");
			break;
d769 1
a769 1
		if (tuple->length < 2) {
d815 1
a815 1
		if (tuple->length < 5) {
d875 1
a875 5
		if (tuple->length < 2) {
			DPRINTF(("CISTPL_CFTABLE_ENTRY too short %d\n",
			    tuple->length));
			break;
		} {
a959 4
				cfe->flags &= ~(PCMCIA_CFE_MWAIT_REQUIRED
				    | PCMCIA_CFE_RDYBSY_ACTIVE
				    | PCMCIA_CFE_WP_ACTIVE
				    | PCMCIA_CFE_BVD_ACTIVE);
a1028 2
				cfe->flags &=
				    ~(PCMCIA_CFE_IO8 | PCMCIA_CFE_IO16);
a1107 3
				cfe->flags &= ~(PCMCIA_CFE_IRQSHARE
				    | PCMCIA_CFE_IRQPULSE
				    | PCMCIA_CFE_IRQLEVEL);
d1162 2
a1163 2
					cfe->num_memspace = (reg &
					    PCMCIA_TPCE_MS_COUNT) + 1;
a1230 3
				cfe->flags &= ~(PCMCIA_CFE_POWERDOWN
				    | PCMCIA_CFE_READONLY
				    | PCMCIA_CFE_AUDIO);
d1232 1
a1232 1
					cfe->flags |= PCMCIA_CFE_POWERDOWN;
d1234 1
a1234 1
					cfe->flags |= PCMCIA_CFE_READONLY;
d1236 1
a1236 1
					cfe->flags |= PCMCIA_CFE_AUDIO;
@


1.3.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a805 2
			if (state->pf == NULL)
				panic("pcmcia_parse_cis_tuple");
a844 2
				if (state->pf == NULL)
					panic("pcmcia_parse_cis_tuple");
a921 2
				if (cfe == NULL)
					panic("pcmcia_parse_cis_tuple");
@


1.3.4.3
log
@Merge in -current from roughly a week ago
@
text
@d60 1
a60 1
int	pcmcia_parse_cis_tuple(struct pcmcia_tuple *, void *);
d94 1
a94 1
	int (*fct)(struct pcmcia_tuple *, void *);
@


1.3.4.4
log
@Sync the SMP branch with 3.3
@
text
@d128 2
a140 3
	tuple.memt = pcmh.memt;
	tuple.memh = pcmh.memh;

d473 2
a474 1
	SIMPLEQ_FOREACH(pf, &card->pf_head, pf_list) {
d524 2
a525 1
		SIMPLEQ_FOREACH(cfe, &pf->cfe_head, cfe_list) {
d634 3
a636 3
			for (pf = SIMPLEQ_FIRST(&state->card->pf_head);
			    pf != NULL; pf = pfnext) {
				pfnext = SIMPLEQ_NEXT(pf, pf_list);
@


1.3.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.3.4.4 2003/03/28 00:38:26 niklas Exp $	*/
d158 2
a159 5
			if (tuple.ptr * tuple.mult < PCMCIA_CIS_SIZE)
				tuple.code = pcmcia_cis_read_1(&tuple,
				    tuple.ptr);
			else
				tuple.code = PCMCIA_CISTPL_END;
@


1.3.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1017 2
a1018 3
								 * non-
								 * extension
								 * byte
@


1.2
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_cis.c,v 1.1 1998/09/11 10:47:15 fgsch Exp $	*/
d615 2
a616 1
		/* if we've seen a LONGLINK_MFC, and this is the first
d642 1
d645 1
a645 1
		 * this tuple's structure was dealt with in scan_cis.  here,
d652 1
d728 1
d756 1
d767 1
d774 25
a798 1
		if ((state->pf == NULL) || (state->gotmfc == 2)) {
d813 1
d873 1
d1097 1
d1250 1
@


1.1
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 1
a44 2
int	pcmciacis_debug = 1;
#define	DPRINTF(arg) if (pcmciacis_debug) printf arg
d331 1
d988 6
d1066 6
d1097 8
a1104 1
				if (memspace == PCMCIA_TPCE_FS_MEMSPACE_LENGTH) {
d1120 1
a1120 1
					cfe->memspace[0].hostaddr = 0;
d1142 2
a1143 2
					    ((reg & PCMCIA_TPCE_MS_LENGTH_SIZE_MASK) >>
					    PCMCIA_TPCE_MS_LENGTH_SIZE_SHIFT);
d1145 2
a1146 2
					    ((reg & PCMCIA_TPCE_MS_CARDADDR_SIZE_MASK) >>
					    PCMCIA_TPCE_MS_CARDADDR_SIZE_SHIFT);
d1148 1
a1148 1
					(reg & PCMCIA_TPCE_MS_HOSTADDR) ? cardaddrsize : 0;
d1189 6
d1213 2
@

