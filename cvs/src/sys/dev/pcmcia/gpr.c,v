head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.17.0.6
	OPENBSD_6_1_BASE:1.17
	OPENBSD_6_0:1.17.0.2
	OPENBSD_6_0_BASE:1.17
	OPENBSD_5_9:1.16.0.12
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.16.0.20
	OPENBSD_5_8_BASE:1.16
	OPENBSD_5_7:1.16.0.18
	OPENBSD_5_7_BASE:1.16
	OPENBSD_5_6:1.16.0.16
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.16.0.14
	OPENBSD_5_5_BASE:1.16
	OPENBSD_5_4:1.16.0.10
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.8
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.6
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.4
	OPENBSD_5_0:1.16.0.2
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.15.0.2
	OPENBSD_4_9_BASE:1.15
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.16
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.12
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.10
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.6
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.4
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.6
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	SMP:1.9.0.4
	OPENBSD_3_3:1.9.0.2
	OPENBSD_3_3_BASE:1.9
	UBC:1.7.0.4
	UBC_SYNC_B:1.7
	OPENBSD_3_2:1.7.0.2
	OPENBSD_3_2_BASE:1.7;
locks; strict;
comment	@ * @;


1.17
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.16;
commitid	kCz5QgxnxRMKOzNf;

1.16
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.29.08.03.16;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.21.17.52.54;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.02.19.21.49;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2002.11.10.03.57.25;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.25.19.09.02;	author fgsch;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.07.29.18.53.32;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2002.07.10.21.53.26;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2002.06.17.20.41.51;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.17.18.44.15;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.15.06.43.19;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.15.05.55.59;	author fgsch;	state Exp;
branches;
next	;

1.7.4.1
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.19.56;	author tedu;	state Exp;
branches;
next	;

1.9.4.1
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@/*	$OpenBSD: gpr.c,v 1.16 2011/07/03 15:47:17 matthew Exp $	*/

/*
 * Copyright (c) 2002, Federico G. Schwindt
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * A driver for the Gemplus GPR400 SmartCard reader.
 *
 * The gpr400 driver written by Wolf Geldmacher <wgeldmacher@@paus.ch> for
 * Linux was used as documentation.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/proc.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/pcmcia/gprio.h>

/* Registers in I/O space (32 bytes) */
#define GPR400_HAP_CTRL		0x00	/* Handshake and PRG Control	*/
#define  GPR400_RESET		  0x01	/* Master reset			*/
#define  GPR400_IREQ		  0x02	/* Interrupt request		*/
#define  GPR400_INTR		  0x04	/* Interrupt			*/
					/* bits 3..8 PRG control	*/
#define GPR400_PD_CTRL		0x01	/* PRG data			*/
/* bytes 3..32 used for data exchange */

/* Registers in attribute memory (read only) */ 
#define GPR400_SETUP		0x018	/* General Setup 		*/
#define  GPR400_LOCK_MASK	 0x08	/* 0: locked, 1: unlocked	*/
#define GPR400_REG1		0x01a	/* SmartCard Reg. 1 		*/
#define  GPR400_DET_MASK	 0x08	/* 0: in the reader, 1: removed	*/
#define  GPR400_INS_MASK	 0x80	/* 0: not inserted, 1: inserted	*/
#define GPR400_REG2		0x01c	/* SmartCard Reg. 2 		*/
#define GPR400_CAC		0x01e	/* Clock and Control 		*/

/* TLV */
#define GPR400_CLOSE		0x10	/* Close session		*/
#define GPR400_OPEN		0x20	/* Open session			*/
#define GPR400_APDU		0x30	/* APDU exchange		*/
#define GPR400_POWER		0x40	/* Power down/Standby		*/
					/* 0: Power down, 1: Standby	*/
#define GPR400_SELECT		0x50	/* Select card			*/
#define  GPR400_DRV0		 0x00	/* Downloaded driver 0		*/
#define  GPR400_ISODRV		 0x02	/* ISO7816-3 driver		*/
#define  GPR400_CLK_MASK	 0x08	/* 0: 3.68MHz, 1: 7.36MHz	*/
#define GPR400_STATUS		0xA0	/* Reader status		*/

#define GPR400_CONT		0x04	/* Chain block			*/

#define GPR400_MEM_LEN		0x1000

#define GPRUNIT(x)		(minor(x) & 0x0f)

#ifdef GPRDEBUG
int gprdebug;
#define DPRINTF(x)		if (gprdebug) printf x
#else
#define DPRINTF(x)
#endif

struct gpr_softc {
	struct device			sc_dev;

	struct pcmcia_function         *sc_pf;

	bus_space_handle_t		sc_ioh;
	bus_space_tag_t			sc_iot;

	struct pcmcia_io_handle		sc_pioh;
	int				sc_iowin;

	bus_space_handle_t		sc_memh;
	bus_space_tag_t			sc_memt;

	struct pcmcia_mem_handle	sc_pmemh;
	int				sc_memwin;
	bus_addr_t			sc_offset;

	void *				sc_ih;
};

int	gpr_match(struct device *, void *, void *);
void	gpr_attach(struct device *, struct device *, void *);
int	gpr_detach(struct device *, int);
int	gpr_activate(struct device *, int);

int	gpropen(dev_t, int, int, struct proc *);
int	gprclose(dev_t, int, int, struct proc *);
int	gprioctl(dev_t, u_long, caddr_t, int, struct proc *);

int	gpr_intr(void *);

int	tlvput(struct gpr_softc *, int, u_int8_t *, int);

struct cfattach gpr_ca = {
	sizeof(struct gpr_softc), gpr_match, gpr_attach, gpr_detach,
	    gpr_activate
};

struct cfdriver gpr_cd = {
	NULL, "gpr", DV_DULL
};

int
gpr_match(struct device *parent, void *match, void *aux)
{
	struct pcmcia_attach_args *pa = aux;

	if (pa->manufacturer == PCMCIA_VENDOR_GEMPLUS &&
	    pa->product == PCMCIA_PRODUCT_GEMPLUS_GPR400)
		return (1);

	return (0);
}

void
gpr_attach(struct device *parent, struct device *self, void *aux)
{
	struct gpr_softc *sc = (void *)self;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const char *intrstr;

	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe;
	     cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {

		if (!pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,
		    cfe->iospace[0].length, cfe->iospace[0].length,
		    &sc->sc_pioh))
			break;
	}

	if (cfe == NULL) {
		printf(": can't alloc i/o space\n");
		goto fail_io_alloc;
	}

	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		goto fail_enable;
	}

	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,
	    sc->sc_pioh.size, &sc->sc_pioh, &sc->sc_iowin)) {
		printf(": can't map i/o space\n");
		goto fail_io_map;
	}

	/*
	 * GPR400 has some registers in attribute memory as well.
	 */
	if (pcmcia_mem_alloc(pa->pf, GPR400_MEM_LEN, &sc->sc_pmemh)) {
		printf(": can't map mem space\n");
		goto fail_mem_alloc;
	}

	if (pcmcia_mem_map(pa->pf, PCMCIA_MEM_ATTR, pa->pf->ccr_base,
	    GPR400_MEM_LEN, &sc->sc_pmemh, &sc->sc_offset, &sc->sc_memwin)) {
		printf(": can't map memory\n");
		goto fail_mem_map;
	}

	sc->sc_pf = pa->pf;
	sc->sc_iot = sc->sc_pioh.iot;
	sc->sc_ioh = sc->sc_pioh.ioh;
	sc->sc_memt = sc->sc_pmemh.memt;
	sc->sc_memh = sc->sc_pmemh.memh;

	printf(" port 0x%lx/%d", sc->sc_pioh.addr, sc->sc_pioh.size);

	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY, gpr_intr, sc,
	    sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(sc->sc_pf, sc->sc_ih);
	printf("%s%s\n", *intrstr ? ", " : "", intrstr);
	if (sc->sc_ih != NULL)
		return;

	pcmcia_mem_unmap(pa->pf, sc->sc_memwin);
fail_mem_map:
	pcmcia_mem_free(pa->pf, &sc->sc_pmemh);
fail_mem_alloc:
	pcmcia_io_unmap(pa->pf, sc->sc_iowin);
fail_io_map:
	pcmcia_function_disable(pa->pf);
fail_enable:
	pcmcia_io_free(pa->pf, &sc->sc_pioh);
fail_io_alloc:
	return;
}

int
gpr_detach(struct device *dev, int flags)
{
	struct gpr_softc *sc = (struct gpr_softc *)dev;

	pcmcia_io_unmap(sc->sc_pf, sc->sc_iowin);
	pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);
	pcmcia_mem_unmap(sc->sc_pf, sc->sc_memwin);
	pcmcia_mem_free(sc->sc_pf, &sc->sc_pmemh);

	return (0);
}

int
gpr_activate(struct device *dev, int act)
{
	struct gpr_softc *sc = (struct gpr_softc *)dev;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

int
gpropen(dev_t dev, int flags, int mode, struct proc *p)
{
	int unit = GPRUNIT(dev);
	struct gpr_softc *sc;

	DPRINTF(("%s: flags %d, mode %d\n", __func__, flags, mode));

	if (unit >= gpr_cd.cd_ndevs ||
	    (sc = gpr_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	return (tlvput(sc, GPR400_SELECT, "\x02", 1));
}

int
gprclose(dev_t dev, int flags, int mode, struct proc *p)
{
	int unit = GPRUNIT(dev);
	struct gpr_softc *sc = gpr_cd.cd_devs[unit];

	DPRINTF(("%s: flags %d, mode %d\n", __func__, flags, mode));

	(void)tlvput(sc, GPR400_CLOSE, NULL, 0);

	return (0);
}

int
gprioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
{
	int unit = GPRUNIT(dev);
	struct gpr_softc *sc = gpr_cd.cd_devs[unit];
	int error;

	DPRINTF(("%s: cmd %d, flags 0x%x\n", __func__, cmd, flags));

	switch (cmd) {
	case GPR_RESET:
	case GPR_SELECT:
	case GPR_POWER:
	case GPR_CLOSE:
		if ((flags & FWRITE) == 0)
			return (EACCES);
	default:
		break;
	}

	switch (cmd) {
	case GPR_RESET:
		/*
		 * To reset and power up the reader, set bit 0 in the
		 * HAP register for at least 5us and wait for 20ms.
		 */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, GPR400_HAP_CTRL,
		    GPR400_RESET);
		delay(10);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, GPR400_HAP_CTRL, 0);
		tsleep(sc, PWAIT, "gpreset", hz / 40);
		/* FALLTHROUGH */

	case GPR_SELECT:
		error = tlvput(sc, GPR400_SELECT, "\x02", 1);
		break;

	case GPR_POWER:
		{
			u_int8_t *mode;

			if (*(int *)addr)
				mode = "\x01";	/* Standby	*/
			else
				mode = "\x00";	/* Power down	*/

			error = tlvput(sc, GPR400_POWER, mode, 1);
		}
		break;

	case GPR_CLOSE:
		error = tlvput(sc, GPR400_CLOSE, NULL, 0);
		break;

	case GPR_RAM:
		{
			struct gpr400_ram r;

			bus_space_read_region_1(sc->sc_memt, sc->sc_memh,
		    	    sc->sc_offset, (u_int8_t *)&r,
			    sizeof(struct gpr400_ram));
			error = copyout(&r, addr, sizeof(struct gpr400_ram));
		}
		break;

	case GPR_CMD:
	case GPR_OPEN:
	case GPR_STATUS:
	case GPR_TLV:
	default:
		error = EINVAL;
		break;
	};

	return (error);
}

int
gpr_intr(void *arg)
{
	struct gpr_softc *sc = arg;
	u_int8_t val;

	DPRINTF(("%s: got interrupt\n", __func__));

	/* Ack interrupt */
	val = bus_space_read_1(sc->sc_iot, sc->sc_ioh, GPR400_HAP_CTRL);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, GPR400_HAP_CTRL,
	    val & ~GPR400_INTR);

	wakeup(sc);

	return (1);
}

int
tlvput(struct gpr_softc *sc, int cmd, u_int8_t *data, int len)
{
	int resid, ret;

	DPRINTF(("%s: cmd 0x%x, data %p, len %d\n", __func__,
	    cmd, data, len));

	resid = len;
	do {
		int n, s;

		n = min(resid, 28);
		resid -= n;

		if (resid)
			cmd |= GPR400_CONT;
		else
			cmd &= ~GPR400_CONT;

		DPRINTF(("%s: sending cmd 0x%x, len %d, left %d\n",
		    __func__, cmd, n, resid));

		bus_space_write_1(sc->sc_iot, sc->sc_ioh, 0x02, cmd);
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, 0x03, n);

		if (n) {
			bus_space_write_region_1(sc->sc_iot, sc->sc_ioh,
			    0x04, data, n);
			data += n;
		}

		s = spltty();

		/* Tell the reader to process this command. */
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, GPR400_HAP_CTRL,
		    GPR400_IREQ);

		tsleep(sc, PCATCH, "tlvput", 0);

		splx(s);

		/* Read the status.	*/
		ret = bus_space_read_1(sc->sc_iot, sc->sc_ioh, 0x04);

		DPRINTF(("%s: ret %d\n", __func__, ret));

		if (ret != 0x00 || (!resid && ret != 0xe7))
			return (EIO);

	} while (resid > 0);

	return (0);
}
@


1.16
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.15 2010/08/30 20:33:18 deraadt Exp $	*/
d278 1
a278 1
	(void)tlvput(sc, GPR400_CLOSE, (u_int8_t *)0, 0);
d334 1
a334 1
		error = tlvput(sc, GPR400_CLOSE, (u_int8_t *)0, 0);
@


1.15
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.14 2009/10/29 08:03:16 fgsch Exp $	*/
a244 5
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_TTY,
		    gpr_intr, sc, sc->sc_dev.dv_xname);
		break;
@


1.14
log
@Make sure the descriptor is writable for some operations. Pointed by miod@@.
While I'm here make this compile again.  miod@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.13 2009/10/13 19:33:16 pirofti Exp $	*/
a249 1

d251 3
a253 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
a256 1

@


1.13
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.12 2006/04/21 17:52:54 uwe Exp $	*/
d41 3
a44 2
#include <sys/ioctl.h>
#include <sys/conf.h>
d299 11
d347 2
a348 1
		    	    sc->sc_offset, &r, sizeof(struct gpr400_ram));
@


1.12
log
@Fix a typo and remove an unreachable label to let this compile again.
Based on a diff from Markus Schatzl (wtf at neuronenwerk de) to tech@@.
OK miod@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.11 2005/01/27 17:04:55 millert Exp $	*/
d118 1
a118 1
int	gpr_activate(struct device *, enum devact);
d239 1
a239 1
gpr_activate(struct device *dev, enum devact act)
@


1.11
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.10 2003/06/02 19:21:49 fgsch Exp $	*/
d207 1
a207 1
	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
a211 1
fail_intr:
@


1.10
log
@clean up license.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.9 2003/02/11 19:20:28 mickey Exp $	*/
d155 1
d207 4
a210 8
	if (sc->sc_ih == NULL) {
		printf(": couldn't establish interrupt\n");
		goto fail_intr;
	}

	printf("\n");

	return;
@


1.9
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.8 2002/11/10 03:57:25 fgsch Exp $	*/
a15 3
 * 3. Neither the name of the author nor the names of its contributors
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
@


1.9.4.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.9 2003/02/11 19:20:28 mickey Exp $	*/
d16 3
@


1.8
log
@fix logic.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.7 2002/09/25 19:09:02 fgsch Exp $	*/
d81 1
a81 1
#define  GPR400_CLK_MASK	 0x08	/* 0: 3.68Mhz, 1: 7.36Mhz	*/
@


1.7
log
@better text for clause 3. pointed out by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.5 2002/07/10 21:53:26 mickey Exp $	*/
d392 1
a392 1
		if (n)
@


1.7.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.7.4.2
log
@sync
@
text
@d81 1
a81 1
#define  GPR400_CLK_MASK	 0x08	/* 0: 3.68MHz, 1: 7.36MHz	*/
d392 1
a392 1
		if (resid)
@


1.6
log
@undrugs this.
- correct command in gprclose and gpropen.
- fix tlvput logic.
- change a few regs.
@
text
@d16 3
a18 3
 * 3. Neither the name of the Federico G. Schwindt nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.5
log
@proper cdev_decl(gpr)
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.4 2002/06/17 20:41:51 fgsch Exp $	*/
d66 4
a69 4
#define GPR400_SCARD1		0x01a	/* SmartCard Reg. 1 		*/
#define  GPR400_INS_MASK	 0x08	/* 0: in the reader, 1: removed	*/
#define  GPR400_DET_MASK	 0x80	/* 0: no inserted, 1: inserted	*/
#define GPR400_SCARD2		0x01c	/* SmartCard Reg. 2 		*/
d278 1
a278 1
	return (tlvput(sc, GPR_SELECT, "\x02", 1));
d289 1
a289 1
	(void)tlvput(sc, GPR_CLOSE, (u_int8_t *)0, 0);
d380 1
a380 1
	int i, resid;
d385 3
a387 7
	for (i = 0, resid = 1; resid || i < len; i += 28) {
		u_int8_t ret;
		int s;

		resid = len - i - 28;
		if (resid < 0)
			resid = 0;
d389 4
a392 1
		if (resid)
d397 2
a398 2
		DPRINTF(("%s: sending cmd 0x%x, len %d, resid %d\n",
		    __func__, cmd, len - resid, resid));
d401 1
a401 1
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, 0x03, len - resid);
d403 5
a407 3
		bus_space_write_region_1(sc->sc_iot, sc->sc_ioh,
		    0x04, data, len - resid);
		data += len - resid;
d426 2
a427 1
	}
@


1.4
log
@cosmetic changes in the copyright suggested by theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.3 2002/06/17 18:44:15 fgsch Exp $	*/
d46 1
@


1.3
log
@- make user ioctl's available via gprio.h
- correct tlvput checks.
- replace delay with tsleep(9) per jason@@ suggestion
- implement GPR_RAM.
- use bus_space_write_region_1(9).
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.2 2002/06/15 06:43:19 fgsch Exp $	*/
d10 9
a18 9
 *   * Redistributions of source code must retain the above copyright
 *     notice, this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright
 *     notice, this list of conditions and the following disclaimer in
 *     the documentation and/or other materials provided with the
 *     distribution.
 *   * Neither the name of the Federico G. Schwindt nor the names of its
 *     contributors may be used to endorse or promote products derived
 *     from this software without specific prior written permission.
@


1.2
log
@unmap/free memory as well on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: gpr.c,v 1.1 2002/06/15 05:55:59 fgsch Exp $	*/
d51 2
a88 13
/*
 * gpr device operations.
 */
#define GPR_CLOSE		_IO('g', 1)
#define GPR_CMD			_IO('g', 2)
#define GPR_OPEN		_IO('g', 3)
#define GPR_POWER		_IOW('g', 4, int)
#define GPR_RAM			_IO('g', 5)
#define GPR_RESET		_IO('g', 6)
#define GPR_SELECT		_IO('g', 7)
#define GPR_STATUS		_IO('g', 8)
#define GPR_TLV			_IO('g', 9)

d122 4
a125 3
int	gpr_open(dev_t, int, int, struct proc *);
int	gpr_close(dev_t, int, int, struct proc *);
int	gpr_ioctl(dev_t, u_long, caddr_t, int, struct proc *);
d128 1
a128 1
int	tlvput(struct gpr_softc *, u_long, u_int8_t *, int);
d266 1
a266 1
gpr_open(dev_t dev, int flags, int mode, struct proc *p)
a269 1
	int error;
d277 1
a277 4
	if ((error = tlvput(sc, GPR_SELECT, "\x02", 1)) < 0)
		return (error);

	return (0);
d281 1
a281 1
gpr_close(dev_t dev, int flags, int mode, struct proc *p)
a284 1
	int error;
d288 1
a288 2
	if ((error = tlvput(sc, GPR_CLOSE, "", 0)) < 0)
		return (error);
d294 1
a294 1
gpr_ioctl(dev_t dev, u_long cmd, caddr_t addr, int flags, struct proc *p)
d312 1
a312 1
		delay(20 * 1000);
d316 1
a316 3
		if ((error = tlvput(sc, GPR400_SELECT, "\x02", 1)) < 0)
			return (error);
		error = 0;
d328 1
a328 3
			if ((error = tlvput(sc, GPR400_POWER, mode, 1)) < 0)
				return (error);
			error = 0;
d333 11
a343 3
		if ((error = tlvput(sc, GPR400_CLOSE, "", 0)) < 0)
			return (error);
		error = 0;
a347 1
	case GPR_RAM:
d377 1
a377 1
tlvput(struct gpr_softc *sc, u_long cmd, u_int8_t *data, int len)
d379 1
a379 1
	int i, resid = 1;
d384 2
a385 2
	for (i = 0; resid || i < len; i += 28) {
		int j, ret;
d403 3
a405 4
		for (j = 0; j < len - resid; j++) {
			bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			    0x04 + j, *data++);
		}
@


1.1
log
@GPR400 smartcard reader driver, some stuff still missing.
jason@@ commented on it.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d248 2
@

