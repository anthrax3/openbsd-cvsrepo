head	1.55;
access;
symbols
	OPENBSD_6_1:1.55.0.10
	OPENBSD_6_1_BASE:1.55
	OPENBSD_6_0:1.55.0.6
	OPENBSD_6_0_BASE:1.55
	OPENBSD_5_9:1.55.0.2
	OPENBSD_5_9_BASE:1.55
	OPENBSD_5_8:1.55.0.4
	OPENBSD_5_8_BASE:1.55
	OPENBSD_5_7:1.54.0.4
	OPENBSD_5_7_BASE:1.54
	OPENBSD_5_6:1.53.0.16
	OPENBSD_5_6_BASE:1.53
	OPENBSD_5_5:1.53.0.14
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.53.0.10
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.8
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.49.0.2
	OPENBSD_4_7_BASE:1.49
	OPENBSD_4_6:1.48.0.8
	OPENBSD_4_6_BASE:1.48
	OPENBSD_4_5:1.48.0.4
	OPENBSD_4_5_BASE:1.48
	OPENBSD_4_4:1.48.0.2
	OPENBSD_4_4_BASE:1.48
	OPENBSD_4_3:1.46.0.8
	OPENBSD_4_3_BASE:1.46
	OPENBSD_4_2:1.46.0.6
	OPENBSD_4_2_BASE:1.46
	OPENBSD_4_1:1.46.0.4
	OPENBSD_4_1_BASE:1.46
	OPENBSD_4_0:1.46.0.2
	OPENBSD_4_0_BASE:1.46
	OPENBSD_3_9:1.44.0.2
	OPENBSD_3_9_BASE:1.44
	OPENBSD_3_8:1.41.0.2
	OPENBSD_3_8_BASE:1.41
	OPENBSD_3_7:1.39.0.2
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.38.0.2
	OPENBSD_3_6_BASE:1.38
	SMP_SYNC_A:1.37
	SMP_SYNC_B:1.37
	OPENBSD_3_5:1.37.0.2
	OPENBSD_3_5_BASE:1.37
	OPENBSD_3_4:1.34.0.2
	OPENBSD_3_4_BASE:1.34
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.2
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.32
	UBC:1.29.0.4
	UBC_BASE:1.29
	OPENBSD_3_0:1.29.0.2
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.28
	OPENBSD_2_9:1.28.0.2
	OPENBSD_2_8:1.26.0.4
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.26.0.2
	OPENBSD_2_7_BASE:1.26
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.24
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.5.0.2
	OPENBSD_2_4_BASE:1.5
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.2
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.1.0.2
	OPENBSD_2_1_BASE:1.1;
locks; strict;
comment	@ * @;


1.55
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.54;
commitid	p4LJxGKbi0BU2cG6;

1.54
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.53;
commitid	uzzBR7hz9ncd4O6G;

1.53
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.31.13.05.27;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2010.06.26.23.24.45;	author guenther;	state Exp;
branches;
next	1.49;

1.49
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.48;

1.48
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.47;

1.47
date	2008.05.21.18.49.47;	author kettenis;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.28.16.49.46;	author fkr;	state Exp;
branches;
next	1.45;

1.45
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2005.12.13.23.07.31;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2005.11.21.18.16.41;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2005.09.26.22.32.06;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.10.21.19.54;	author fgsch;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.19.15.39.16;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	2004.08.02.12.19.26;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2004.01.27.17.34.42;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.24.23.32.13;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2004.01.24.23.13.55;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2003.06.02.23.28.03;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.06.20.17.37.14;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.29.4.1;
next	1.28;

1.28
date	2001.03.28.19.59.48;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.16.21.47.48;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.03.19.42.19;	author angelos;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.10.27.17.41.47;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	99.10.26.12.26.59;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	99.10.26.12.04.35;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	99.08.16.16.51.19;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.08.16.07.41.29;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	99.08.14.05.47.41;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	99.08.12.09.02.58;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.08.09.22.16.05;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	99.08.08.01.34.15;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.07.26.06.22.57;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.07.26.06.15.42;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	99.07.26.05.43.15;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.28.04.58.29;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	99.01.21.08.55.08;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.01.11.05.12.19;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	98.12.31.00.23.34;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	98.12.30.22.03.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.12.21.14.59.31;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	98.12.21.09.56.07;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	98.10.14.07.34.43;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.09.11.10.47.14;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	98.03.05.14.39.38;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	97.07.07.17.04.18;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.11.30.13.39.24;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2001.05.14.22.26.05;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	;

1.29.4.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.29.4.2;

1.29.4.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.29.4.3;

1.29.4.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.29.4.4;

1.29.4.4
date	2003.05.19.22.19.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: com_pcmcia.c,v 1.54 2014/09/14 14:17:25 jsg Exp $	*/
/*	$NetBSD: com_pcmcia.c,v 1.15 1998/08/22 17:47:58 msaitoh Exp $	*/

/*
 * Copyright (c) 1997 - 1999, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1991 The Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)com.c	7.5 (Berkeley) 5/16/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/ioctl.h>
#include <sys/selinfo.h>
#include <sys/tty.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/uio.h>
#include <sys/kernel.h>
#include <sys/syslog.h>
#include <sys/types.h>
#include <sys/device.h>

#include <machine/intr.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciadevs.h>

#include "com.h"

#include <dev/ic/comreg.h>
#include <dev/ic/comvar.h>
#include <dev/ic/ns16550reg.h>

#include <dev/isa/isareg.h>

#define	com_lcr		com_cfcr

/* Devices that we need to match by CIS strings */
struct com_pcmcia_product {
	char *cis1_info[4];
} com_pcmcia_prod[] = {
	{ PCMCIA_CIS_MEGAHERTZ_XJ2288 },
	{ PCMCIA_CIS_NOVATEL_NRM6831 },
};

int com_pcmcia_match(struct device *, void *, void *);
void com_pcmcia_attach(struct device *, struct device *, void *);
int com_pcmcia_detach(struct device *, int);
void com_pcmcia_cleanup(void *);
int com_pcmcia_activate(struct device *, int);

int com_pcmcia_enable(struct com_softc *);
void com_pcmcia_disable(struct com_softc *);
int com_pcmcia_enable1(struct com_softc *);
void com_pcmcia_disable1(struct com_softc *);

struct com_pcmcia_softc {
	struct com_softc sc_com;		/* real "com" softc */

	/* PCMCIA-specific goo */
	struct pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o space info */
	int sc_io_window;			/* our i/o window */
	struct pcmcia_function *sc_pf;		/* our PCMCIA function */
	void *sc_ih;				/* interrupt handler */
};

struct cfattach com_pcmcia_ca = {
	sizeof(struct com_pcmcia_softc), com_pcmcia_match, com_pcmcia_attach,
	com_pcmcia_detach, com_pcmcia_activate
};

int
com_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	int i, j, comportmask;

	/* 1. Does it claim to be a serial device? */
	if (pa->pf->function == PCMCIA_FUNCTION_SERIAL)
	    return 1;

	/* 2. Does it have all four 'standard' port ranges? */
	comportmask = 0;
	SIMPLEQ_FOREACH(cfe, &pa->pf->cfe_head, cfe_list) {
		switch (cfe->iospace[0].start) {
		case IO_COM1:
			comportmask |= 1;
			break;
		case IO_COM2:
			comportmask |= 2;
			break;
		case IO_COM3:
			comportmask |= 4;
			break;
		case IO_COM4:
			comportmask |= 8;
			break;
		}
	}

	if (comportmask == 15)
		return 1;

	/* 3. Is this a card we know about? */
	for (i = 0; i < nitems(com_pcmcia_prod); i++) {
		for (j = 0; j < 4; j++)
			if (com_pcmcia_prod[i].cis1_info[j] &&
			    pa->card->cis1_info[j] &&
			    strcmp(pa->card->cis1_info[j],
			    com_pcmcia_prod[i].cis1_info[j]))
				break;
		if (j == 4)
			return 1;
	}

	return 0;
}

int
com_pcmcia_activate(dev, act)
	struct device *dev;
	int act;
{
	struct com_pcmcia_softc *sc = (void *) dev;

	switch (act) {
	case DVACT_SUSPEND:
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_TTY,
		    comintr, sc, sc->sc_com.sc_dev.dv_xname);
		com_resume(&sc->sc_com);
		break;
	case DVACT_DEACTIVATE:
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

void
com_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct com_pcmcia_softc *psc = (void *) self;
	struct com_softc *sc = &psc->sc_com;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const char *intrstr;
	int autoalloc = 0;

	psc->sc_pf = pa->pf;

retry:
	/* find a cfe we can use */

	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe;
	     cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {
#if 0
		/*
		 * Some modem cards (e.g. Xircom CM33) also have
		 * mem space.  Don't bother with this check.
		 */
		if (cfe->num_memspace != 0)
			continue;
#endif

		if (cfe->num_iospace != 1)
			continue;

		if (!pcmcia_io_alloc(pa->pf,
		    autoalloc ? 0 : cfe->iospace[0].start,
		    cfe->iospace[0].length, COM_NPORTS, &psc->sc_pcioh)) {
			goto found;
		}
	}
	if (autoalloc == 0) {
		autoalloc = 1;
		goto retry;
	} else if (!cfe) {
		printf(": can't allocate i/o space\n");
		return;
	}

found:
	sc->sc_iot = psc->sc_pcioh.iot;
	sc->sc_ioh = psc->sc_pcioh.ioh;

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (com_pcmcia_enable1(sc))
		printf(": function enable failed\n");

	sc->enabled = 1;

	/* map in the io space */

	if (pcmcia_io_map(pa->pf, ((cfe->flags & PCMCIA_CFE_IO16) ?
	    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8), 0, psc->sc_pcioh.size,
	    &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		return;
	}

	printf(" port 0x%lx/%lu", psc->sc_pcioh.addr,
	    (u_long)psc->sc_pcioh.size);

	sc->sc_iobase = -1;
	sc->enable = com_pcmcia_enable;
	sc->disable = com_pcmcia_disable;
	sc->sc_frequency = COM_FREQ;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;

	if (psc->sc_pf->sc->card.manufacturer == PCMCIA_VENDOR_AUDIOVOX &&
	    psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_AUDIOVOX_RTM8000)
		sc->sc_fifolen = 16;

	com_attach_subr(sc);

	/* establish the interrupt. */
	psc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY, comintr, sc,
	    sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, psc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);

#ifdef notyet
	sc->enabled = 0;

	com_pcmcia_disable1(sc);
#endif
}

int
com_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *)dev;
	int error;

	/* Release all resources.  */
	error = com_detach(dev, flags);
	if (error)
	    return (error);

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	return (0);
}

int
com_pcmcia_enable(sc)
	struct com_softc *sc;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;
	struct pcmcia_function *pf = psc->sc_pf;

	/* establish the interrupt. */
	psc->sc_ih = pcmcia_intr_establish(pf, IPL_TTY, comintr, sc,
	    sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}
	return com_pcmcia_enable1(sc);
}

int
com_pcmcia_enable1(sc)
	struct com_softc *sc;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;
	struct pcmcia_function *pf = psc->sc_pf;
	int ret;

	if ((ret = pcmcia_function_enable(pf)))
	    return(ret);

	if ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {
		int reg;

		/* turn off the ethernet-disable bit */

		reg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);
		if (reg & 0x08) {
		    reg &= ~0x08;
		    pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);
		}
	}

	return(ret);
}

void
com_pcmcia_disable(sc)
	struct com_softc *sc;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;

	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
	com_pcmcia_disable1(sc);
}

void
com_pcmcia_disable1(sc)
	struct com_softc *sc;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;

	pcmcia_function_disable(psc->sc_pf);
}
@


1.54
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.53 2011/07/03 15:47:17 matthew Exp $	*/
a104 1
#include <machine/bus.h>
@


1.53
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.52 2011/03/31 13:05:27 jasper Exp $	*/
a95 1
#include <sys/proc.h>
@


1.52
log
@- use nitems(); no binary change.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.51 2010/08/30 20:33:18 deraadt Exp $	*/
a213 5
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_TTY,
		    comintr, sc, sc->sc_com.sc_dev.dv_xname);
		break;
@


1.51
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.50 2010/06/26 23:24:45 guenther Exp $	*/
d192 1
a192 2
	for (i = 0; i < sizeof(com_pcmcia_prod)/sizeof(com_pcmcia_prod[0]);
	    i++) {
@


1.50
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.49 2009/10/13 19:33:16 pirofti Exp $	*/
a212 1
	int s;
a213 1
	s = spltty();
d220 12
a231 1

d233 3
a235 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
a238 1
	splx(s);
@


1.49
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.48 2008/06/26 05:42:17 ray Exp $	*/
a96 1
#include <sys/user.h>
@


1.48
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.47 2008/05/21 18:49:47 kettenis Exp $	*/
d135 1
a135 1
int com_pcmcia_activate(struct device *, enum devact);
d211 1
a211 1
	enum devact act;
@


1.47
log
@Switch i386 from pccom to com.  Welcomed by many.

ok dlg@@, jsing@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.46 2006/05/28 16:49:46 fkr Exp $	*/
a45 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.46
log
@remove the dev/isa/isavar.h include, as it is not needed
ok miod@@, martin@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.45 2006/04/20 20:31:13 miod Exp $	*/
a120 3
#ifdef i386
#include "pccom.h"
#endif
a122 4
#if NPCCOM > 0
#include <i386/isa/pccomvar.h>
#endif
#if NCOM > 0
a123 1
#endif
a158 1
#if NCOM
a162 6
#elif NPCCOM
struct cfattach pccom_pcmcia_ca = {
	sizeof(struct com_pcmcia_softc), com_pcmcia_match, com_pcmcia_attach,
	com_pcmcia_detach, com_pcmcia_activate
};
#endif
@


1.45
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.44 2005/12/13 23:07:31 mickey Exp $	*/
a126 1
#include <dev/isa/isavar.h>
@


1.44
log
@add novatel NRM6831; from Felix Kronlage <fkr@@hazardous.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.43 2005/11/21 18:16:41 millert Exp $	*/
d321 2
a322 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.43
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.42 2005/09/26 22:32:06 miod Exp $	*/
d144 1
@


1.42
log
@Share com probe code between com and pccom; allows us to get rid of awkward
code duplication in cardbus, pcmcia and puc attachments.

Joint effort with fgs@@; blessed deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.41 2005/08/10 21:19:54 fgsch Exp $	*/
d101 1
a101 1
#include <sys/select.h>
@


1.41
log
@Audiovox RTM-8000 has a st16650 uart but its fifo is 16 bytes instead of
32.  add a workaround for the time being. better code will be added later.
tested by Andreas Gunnarsson <andreas at zzlevo dot net>, deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.40 2005/07/19 15:39:16 deraadt Exp $	*/
a156 2
void com_pcmcia_attach2(struct com_softc *);

d327 7
a333 1
#ifdef notyet
d335 1
a335 1
#endif
a342 2
	com_pcmcia_attach2(sc);

a431 166
}

/*
 * XXX This should be handled by a generic attach
 */
void
com_pcmcia_attach2(sc)
	struct com_softc *sc;
{
	struct com_pcmcia_softc *psc = (struct com_pcmcia_softc *) sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t lcr;

	sc->sc_hwflags = 0;
	sc->sc_swflags = 0;

	/*
	 * Probe for all known forms of UART.
	 */
	lcr = bus_space_read_1(iot, ioh, com_lcr);

	bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
	bus_space_write_1(iot, ioh, com_efr, 0);
	bus_space_write_1(iot, ioh, com_lcr, 0);

	bus_space_write_1(iot, ioh, com_fifo, FIFO_ENABLE);
	delay(100);

	switch(bus_space_read_1(iot, ioh, com_iir) >> 6) {
	case 0:
		sc->sc_uarttype = COM_UART_16450;
		break;
	case 2:
		sc->sc_uarttype = COM_UART_16550;
		break;
	case 3:
		sc->sc_uarttype = COM_UART_16550A;
		break;
	default:
		sc->sc_uarttype = COM_UART_UNKNOWN;
		break;
	}

	if (sc->sc_uarttype == COM_UART_16550A) { /* Probe for ST16650s */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		if (bus_space_read_1(iot, ioh, com_efr) == 0) {
			sc->sc_uarttype = COM_UART_ST16650;
		} else {
			bus_space_write_1(iot, ioh, com_lcr, LCR_EFR);
			if (bus_space_read_1(iot, ioh, com_efr) == 0)
				sc->sc_uarttype = COM_UART_ST16650V2;
		}
	}

#if NPCCOM > 0
#ifdef i386
	if (sc->sc_uarttype == COM_UART_ST16650V2) {	/* Probe for XR16850s */
		u_int8_t dlbl, dlbh;

		/* Enable latch access and get the current values. */
		bus_space_write_1(iot, ioh, com_lcr, lcr | LCR_DLAB);
		dlbl = bus_space_read_1(iot, ioh, com_dlbl);
		dlbh = bus_space_read_1(iot, ioh, com_dlbh);

		/* Zero out the latch divisors */
		bus_space_write_1(iot, ioh, com_dlbl, 0);
		bus_space_write_1(iot, ioh, com_dlbh, 0);

		if (bus_space_read_1(iot, ioh, com_dlbh) == 0x10) {
			sc->sc_uarttype = COM_UART_XR16850;
			sc->sc_uartrev = bus_space_read_1(iot, ioh, com_dlbl);
		}

		/* Reset to original. */
		bus_space_write_1(iot, ioh, com_dlbl, dlbl);
		bus_space_write_1(iot, ioh, com_dlbh, dlbh);
	}
#endif
#endif

	/* Reset the LCR (latch access is probably enabled). */
	bus_space_write_1(iot, ioh, com_lcr, lcr);
	if (sc->sc_uarttype == COM_UART_16450) { /* Probe for 8250 */
		u_int8_t scr0, scr1, scr2;

		scr0 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0xa5);
		scr1 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, 0x5a);
		scr2 = bus_space_read_1(iot, ioh, com_scratch);
		bus_space_write_1(iot, ioh, com_scratch, scr0);

		if ((scr1 != 0xa5) || (scr2 != 0x5a))
			sc->sc_uarttype = COM_UART_8250;
	}

	/*
	 * Print UART type and initialize ourself.
	 */
	sc->sc_fifolen = 1;	/* default */
	switch (sc->sc_uarttype) {
	case COM_UART_UNKNOWN:
		printf(": unknown uart\n");
		break;
	case COM_UART_8250:
		printf(": ns8250, no fifo\n");
		break;
	case COM_UART_16450:
		printf(": ns16450, no fifo\n");
		break;
	case COM_UART_16550:
		printf(": ns16550, no working fifo\n");
		break;
	case COM_UART_16550A:
		printf(": ns16550a, 16 byte fifo\n");
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 16;
		break;
	case COM_UART_ST16650:
		printf(": st16650, no working fifo\n");
		break;
	case COM_UART_ST16650V2:
		if (psc->sc_pf->sc->card.manufacturer ==
		    PCMCIA_VENDOR_AUDIOVOX &&
		    psc->sc_pf->sc->card.product ==
		    PCMCIA_PRODUCT_AUDIOVOX_RTM8000)
			sc->sc_fifolen = 16;
		else
			sc->sc_fifolen = 32;
		printf(": st16650, %d byte fifo\n", sc->sc_fifolen);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		break;
#if NPCCOM > 0
#ifdef i386
	case COM_UART_XR16850:
		printf(": xr16850 (rev %d), 128 byte fifo\n", sc->sc_uartrev);
		SET(sc->sc_hwflags, COM_HW_FIFO);
		sc->sc_fifolen = 128;
		break;
#endif
#endif
	default:
		panic("comattach: bad fifo type");
	}

	/* clear and disable fifo */
	bus_space_write_1(iot, ioh, com_fifo, FIFO_RCV_RST | FIFO_XMT_RST);
	(void)bus_space_read_1(iot, ioh, com_data);
	bus_space_write_1(iot, ioh, com_fifo, 0);

	sc->sc_mcr = 0;
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr);

	timeout_set(&sc->sc_diag_tmo, comdiag, sc);
	timeout_set(&sc->sc_dtr_tmo, com_raisedtr, sc);

#if NCOM > 0
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	sc->sc_si = softintr_establish(IPL_TTY, comsoft, sc);
	if (sc->sc_si == NULL)
		panic("%s: can't establish soft interrupt.", sc->sc_dev.dv_xname);
#else
	timeout_set(&sc->sc_comsoft_tmo, comsoft, sc);
#endif
#endif
@


1.40
log
@more adaption for new com files framework
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.39 2005/01/27 17:04:55 millert Exp $	*/
d343 1
a343 1
	
d432 1
a432 1
/* 
d439 1
d510 1
a510 1
	
d553 8
a560 1
		printf(": st16650, 32 byte fifo\n");
a561 1
		sc->sc_fifolen = 32;
@


1.39
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.38 2004/08/02 12:19:26 miod Exp $	*/
d169 1
a169 1
#if NCOM_PCMCIA
d174 1
a174 1
#elif NPCCOM_PCMCIA
@


1.38
log
@Initialize timeouts correctly, match isa com; fixes panics in
PR #3732 and #3881 (although more issues remain).
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.37 2004/01/27 17:34:42 deraadt Exp $	*/
d266 1
d333 5
a337 4
	psc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY,
	    comintr, sc, "");
	if (psc->sc_ih == NULL)
		printf(", couldn't establish interrupt");
@


1.37
log
@this part is not needed for sierra wireless
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.36 2004/01/24 23:32:13 deraadt Exp $	*/
d571 16
@


1.36
log
@Also add support for Sierra A550 and A710/A750 which are apparently map
the com port at the same place
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.35 2004/01/24 23:13:55 deraadt Exp $	*/
a143 3
	{ PCMCIA_CIS_SIERRA_A550 },
	{ PCMCIA_CIS_SIERRA_A555 },
	{ PCMCIA_CIS_SIERRA_A710 },
@


1.35
log
@Sierra A555 1x card support
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.34 2003/06/02 23:28:03 millert Exp $	*/
d144 1
d146 1
@


1.34
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.33 2002/11/19 18:36:18 jason Exp $	*/
d144 1
@


1.33
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.32 2002/06/20 17:37:14 fgsch Exp $	*/
d79 1
a79 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.32
log
@make this compile on sparc64; deraadt and millert ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.31 2002/03/14 01:27:00 millert Exp $	*/
d200 1
a200 2
	for (cfe = pa->pf->cfe_head.sqh_first; cfe;
	     cfe = cfe->cfe_list.sqe_next) {
@


1.31
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.30 2002/01/30 20:45:34 nordin Exp $	*/
a123 2
#include <dev/isa/isavar.h>

d131 1
@


1.30
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.29 2001/08/17 21:52:16 deraadt Exp $	*/
d151 10
a160 10
int com_pcmcia_match __P((struct device *, void *, void *));
void com_pcmcia_attach __P((struct device *, struct device *, void *));
int com_pcmcia_detach __P((struct device *, int));
void com_pcmcia_cleanup __P((void *));
int com_pcmcia_activate __P((struct device *, enum devact));

int com_pcmcia_enable __P((struct com_softc *));
void com_pcmcia_disable __P((struct com_softc *));
int com_pcmcia_enable1 __P((struct com_softc *));
void com_pcmcia_disable1 __P((struct com_softc *));
d162 1
a162 1
void com_pcmcia_attach2 __P((struct com_softc *));
@


1.29
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.28 2001/03/28 19:59:48 millert Exp $	*/
a142 1
#define	SET(t, f)	(t) |= (f)
@


1.29.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.30 2002/01/30 20:45:34 nordin Exp $	*/
d143 1
@


1.29.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.29.4.1 2002/01/31 22:55:37 niklas Exp $	*/
d151 10
a160 10
int com_pcmcia_match(struct device *, void *, void *);
void com_pcmcia_attach(struct device *, struct device *, void *);
int com_pcmcia_detach(struct device *, int);
void com_pcmcia_cleanup(void *);
int com_pcmcia_activate(struct device *, enum devact);

int com_pcmcia_enable(struct com_softc *);
void com_pcmcia_disable(struct com_softc *);
int com_pcmcia_enable1(struct com_softc *);
void com_pcmcia_disable1(struct com_softc *);
d162 1
a162 1
void com_pcmcia_attach2(struct com_softc *);
@


1.29.4.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.29.4.2 2002/06/11 03:42:28 art Exp $	*/
d124 2
a132 1
#include <dev/isa/isavar.h>
@


1.29.4.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d200 2
a201 1
	SIMPLEQ_FOREACH(cfe, &pa->pf->cfe_head, cfe_list) {
@


1.28
log
@Move code to set sc_frequency out of #ifdef notyet since we now need it.
From deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.27 2000/12/16 21:47:48 mickey Exp $	*/
a250 1
		printf("%s:", sc->sc_com.sc_dev.dv_xname);
d252 1
a252 2
		    comintr, sc);
		printf("\n");
d339 2
a340 1
	psc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY, comintr, sc);
d380 2
a381 1
	psc->sc_ih = pcmcia_intr_establish(pf, IPL_TTY, comintr, sc);
@


1.27
log
@make sure cis1_info[i] is not NULL before strcmp() w/ it; fixes some obscure panics
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.26 2000/04/24 19:43:35 niklas Exp $	*/
a334 2
	
#ifdef notyet
d337 1
@


1.26
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.25 2000/02/03 19:42:19 angelos Exp $	*/
d228 3
a230 2
			    strcmp(com_pcmcia_prod[i].cis1_info[j],
			    pa->card->cis1_info[j]))
@


1.25
log
@Make pccomms suspendable (tested on a 3Com Megahertz combo card).
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.24 1999/10/27 17:41:47 fgsch Exp $	*/
d252 1
a252 1
						  comintr, sc);
d257 1
a258 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d424 1
a425 1
	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
@


1.25.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.28 2001/03/28 19:59:48 millert Exp $	*/
d228 2
a229 3
			    pa->card->cis1_info[j] &&
			    strcmp(pa->card->cis1_info[j],
			    com_pcmcia_prod[i].cis1_info[j]))
d252 1
a252 1
		    comintr, sc);
d257 1
a258 1
		pcmcia_function_disable(sc->sc_pf);
d334 2
a337 1
#ifdef notyet
d424 1
a425 1
	com_pcmcia_disable1(sc);
@


1.25.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.25.2.1 2001/05/14 22:26:05 niklas Exp $	*/
d251 1
d253 2
a254 1
		    comintr, sc, sc->sc_com.sc_dev.dv_xname);
d341 1
a341 2
	psc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_TTY,
	    comintr, sc, "");
d381 1
a381 2
	psc->sc_ih = pcmcia_intr_establish(pf, IPL_TTY, comintr, sc,
	    sc->sc_dev.dv_xname);
@


1.25.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
@


1.25.2.4
log
@Merge in -current from roughly a week ago
@
text
@d151 5
a155 5
int com_pcmcia_match(struct device *, void *, void *);
void com_pcmcia_attach(struct device *, struct device *, void *);
int com_pcmcia_detach(struct device *, int);
void com_pcmcia_cleanup(void *);
int com_pcmcia_activate(struct device *, enum devact);
d157 4
a160 4
int com_pcmcia_enable(struct com_softc *);
void com_pcmcia_disable(struct com_softc *);
int com_pcmcia_enable1(struct com_softc *);
void com_pcmcia_disable1(struct com_softc *);
d162 1
a162 1
void com_pcmcia_attach2(struct com_softc *);
@


1.25.2.5
log
@Sync the SMP branch with 3.3
@
text
@d124 2
a132 1
#include <dev/isa/isavar.h>
d201 2
a202 1
	SIMPLEQ_FOREACH(cfe, &pa->pf->cfe_head, cfe_list) {
@


1.25.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.25.2.5 2003/03/28 00:38:26 niklas Exp $	*/
d79 5
a83 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.24
log
@Use SIMPLEQ_XXX.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.23 1999/10/26 12:26:59 downsj Exp $	*/
d156 1
d178 1
a178 1
	com_pcmcia_detach, com_activate
d183 1
a183 1
	com_pcmcia_detach, com_activate
d236 27
@


1.23
log
@This file has my code in it, attach my copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.22 1999/10/26 12:04:35 downsj Exp $	*/
d253 2
a254 2
	for (cfe = pa->pf->cfe_head.sqh_first; cfe;
	     cfe = cfe->cfe_list.sqe_next) {
@


1.22
log
@Rename internal com_attach() routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.21 1999/08/16 16:51:19 deraadt Exp $	*/
d4 27
@


1.21
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.20 1999/08/16 07:41:29 fgsch Exp $	*/
d135 1
a135 1
void com_attach __P((struct com_softc *));
d290 1
a290 1
	com_attach(sc);
d386 1
a386 1
com_attach(sc)
@


1.20
log
@more shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.19 1999/08/14 05:47:41 fgsch Exp $	*/
a119 1
	char *name;
d122 1
a122 1
	{ PCMCIA_STR_MEGAHERTZ_XJ2288, PCMCIA_CIS_MEGAHERTZ_XJ2288 },
@


1.19
log
@Support for 3CXEM556B-INT.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.18 1999/08/12 09:02:58 niklas Exp $	*/
d118 2
a119 1
struct com_dev {
d122 2
a125 10
/* Devices that we need to match by CIS strings */
static struct com_dev com_devs[] = {
	{ PCMCIA_STR_MEGAHERTZ_XJ2288,
	  PCMCIA_CIS_MEGAHERTZ_XJ2288 },
};


static int com_devs_size = sizeof(com_devs) / sizeof(com_devs[0]);
static struct com_dev *com_dev_match __P((struct pcmcia_card *));

a159 21
/* Look for pcmcia cards with particular CIS strings */
static struct com_dev *
com_dev_match(card)
	struct pcmcia_card *card;
{
	int i, j;

	for (i = 0; i < com_devs_size; i++) {
		for (j = 0; j < 4; j++)
			if (com_devs[i].cis1_info[j] &&
			    strcmp(com_devs[i].cis1_info[j],
				   card->cis1_info[j]))
				break;
		if (j == 4)
			return &com_devs[i];
	}

	return NULL;
}


a164 1
	int comportmask;
d167 1
d197 10
a206 2
	if (com_dev_match(pa->card) != NULL)
		return 1;
@


1.18
log
@conditionalize some code only working on pccom so far
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.17 1999/08/09 22:16:05 fgsch Exp $	*/
d368 2
a369 1
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556)) {
@


1.17
log
@Remove unnecessary printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.16 1999/08/08 01:34:15 niklas Exp $	*/
d454 1
d478 1
d526 1
d533 1
@


1.16
log
@Detach support for com; NetBSD and me
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.15 1999/07/26 06:22:57 deraadt Exp $	*/
a300 2
	printf(": serial device");

@


1.15
log
@better
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.14 1999/07/26 06:15:42 fgsch Exp $	*/
d99 5
d105 1
a105 1
#ifdef i386
d107 2
a108 1
#else
a114 5
#include "com.h"
#ifdef i386
#include "pccom.h"
#endif

d135 1
d157 2
a158 1
	sizeof(struct com_pcmcia_softc), com_pcmcia_match, com_pcmcia_attach
d162 2
a163 1
	sizeof(struct com_pcmcia_softc), com_pcmcia_match, com_pcmcia_attach
d263 1
a263 2
		    cfe->iospace[0].length, (1 << cfe->iomask),
		    &psc->sc_pcioh)) {
a283 1
#ifdef notyet
a284 1
#endif
a297 3
#ifdef notyet
	sc->sc_frequency = COM_FREQ;

d303 3
d320 19
@


1.14
log
@Print the irq first.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.13 1999/07/26 05:43:15 deraadt Exp $	*/
d310 1
a310 2
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
@


1.13
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.12 1999/01/28 04:58:29 fgsch Exp $	*/
a306 2
	com_attach(sc);

d312 2
@


1.12
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.11 1999/01/21 08:55:08 niklas Exp $	*/
d293 2
@


1.11
log
@Remove remnicients of old pcmcia code, allow both pccom & com at pcmcia
work again
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.10 1999/01/11 05:12:19 millert Exp $	*/
d348 2
a349 1
	if (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) {
@


1.10
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.9 1998/12/31 00:23:34 niklas Exp $	*/
d109 5
d153 1
d157 5
@


1.9
log
@I messed up in my last patch, thanks wim and federico
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.8 1998/12/30 22:03:45 deraadt Exp $	*/
d501 1
a501 1
		panic("comattach: bad fifo type\n");
@


1.8
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.7 1998/12/21 14:59:31 niklas Exp $	*/
d247 1
a247 1
		    autoalloc ? cfe->iospace[0].start : 0,
@


1.7
log
@Use the iomask in a correct way
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.6 1998/12/21 09:56:07 niklas Exp $	*/
d161 1
a161 1
		       	if (com_devs[i].cis1_info[j] &&
d190 14
a203 14
	  switch (cfe->iospace[0].start) {
	  case IO_COM1:
	    comportmask |= 1;
	    break;
	  case IO_COM2:
	    comportmask |= 2;
	    break;
	  case IO_COM3:
	    comportmask |= 4;
	    break;
	  case IO_COM4:
	    comportmask |= 8;
	    break;
	  }
d207 1
a207 1
	    return 1;
d211 1
a211 1
	    return 1;
d300 1
a300 1
		       sc->sc_dev.dv_xname);
d320 1
a320 1
		       sc->sc_dev.dv_xname);
@


1.6
log
@zero alignment is not allowed.  shorten some long lines.
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.5 1998/10/14 07:34:43 fgsch Exp $	*/
d246 5
a250 13
		if (autoalloc == 1) {
			if (cfe->iomask == 3) {
				if (!pcmcia_io_alloc(pa->pf, 0,
				    cfe->iospace[0].length,
				    cfe->iospace[0].length, &psc->sc_pcioh)) {
					goto found;
				}
			}
		} else {
			if (!pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,
			    cfe->iospace[0].length, 1, &psc->sc_pcioh)) {
				goto found;
			}
@


1.5
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.4 1998/09/11 10:47:14 fgsch Exp $	*/
d248 3
a250 3
				if (!pcmcia_io_alloc(pa->pf, 0, cfe->iospace[0].length,
									 cfe->iospace[0].length,
									 &psc->sc_pcioh)) {
d256 1
a256 1
								 cfe->iospace[0].length, 0, &psc->sc_pcioh)) {
@


1.4
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a296 1
#endif
a299 1
#ifdef notyet
@


1.3
log
@please GCC 2.8
@
text
@d1 38
a38 2
/*	$OpenBSD: com_pcmcia.c,v 1.2 1997/07/07 17:04:18 niklas Exp $	*/
/*	$NetBSD: com.c,v 1.82.4.1 1996/06/02 09:08:00 mrg Exp $	*/
a40 2
 * Copyright (c) 1993, 1994, 1995, 1996
 *	Charles M. Hannum.  All rights reserved.
d71 2
d77 11
a88 1
#include <sys/tty.h>
d90 1
d92 4
a95 1
#include <machine/intr.h>
d100 3
d104 1
d107 1
a107 1
#include <dev/pcmcia/pcmciavar.h>
d109 1
a109 1
/* Macros to clear/set/test flags. */
a110 2
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
d112 35
a146 10
int	com_pcmcia_match __P((struct device *, void *, void *));
void	com_pcmcia_attach __P((struct device *, struct device *, void *));
int	com_pcmcia_detach __P((struct device *));

int	com_pcmcia_mod __P((struct pcmcia_link *pc_link, struct device *self,
	    struct pcmcia_conf *pc_cf, struct cfdata *cf));
int	com_pcmcia_isa_attach __P((struct device *, void *, void *,
	    struct pcmcia_link *));
int	com_pcmcia_remove __P((struct pcmcia_link *, struct device *));
int	com_pcmcia_probe __P((struct device *, void *, void *));
d149 1
a149 2
	sizeof(struct com_softc), com_pcmcia_match, com_pcmcia_attach,
	com_pcmcia_detach
d152 15
a166 16
/* additional setup needed for pcmcia devices */
/* modify config entry */
int 
com_pcmcia_mod(pc_link, self, pc_cf, cf)
    struct pcmcia_link *pc_link;
    struct device *self;
    struct pcmcia_conf *pc_cf; 
    struct cfdata *cf;
{               
	int err; 

	if (!(err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,
	    pc_cf, cf))) {
		pc_cf->memwin = 0;
		if (pc_cf->cfgtype == 0) 
		pc_cf->cfgtype = CFGENTRYID; /* determine from ioaddr */
d168 2
a169 1
	return err;
a171 24
static struct pcmcia_com {
	struct pcmcia_device pcd;
} pcmcia_com =  {
	{"PCMCIA Modem card", com_pcmcia_mod, com_pcmcia_isa_attach,
	 NULL, com_pcmcia_remove}
};          


struct pcmciadevs pcmcia_com_devs[] = {
	{ "com", 0,
	NULL, "*MODEM*", NULL, NULL,
	NULL, (void *)&pcmcia_com 
	},
	{ "com", 0,
	NULL, NULL, "*MODEM*", NULL,
	NULL, (void *)&pcmcia_com 
	},
	{ "com", 0,
	NULL, NULL, NULL, "*MODEM*",
	NULL, (void *)&pcmcia_com 
	},
	{NULL}
};
#define ncom_pcmcia_devs sizeof(pcmcia_com_devs)/sizeof(pcmcia_com_devs[0])
d178 36
a213 2
	return pcmcia_slave_match(parent, match, aux, pcmcia_com_devs,
	    ncom_pcmcia_devs);
d216 3
a218 4
int
com_pcmcia_isa_attach(parent, match, aux, pc_link)
	struct device *parent;
	void *match;
a219 1
	struct pcmcia_link *pc_link;
d221 59
a279 8
	struct isa_attach_args *ia = aux;
	struct com_softc *sc = match;
	int rval;

	if ((rval = com_pcmcia_probe(parent, sc->sc_dev.dv_cfdata, ia))) {
		if (ISSET(pc_link->flags, PCMCIA_REATTACH)) {
#ifdef COM_DEBUG
			printf("comreattach, hwflags=%x\n", sc->sc_hwflags);
d281 8
a288 5
			sc->sc_hwflags = COM_HW_REATTACH | (sc->sc_hwflags &
			    (COM_HW_ABSENT_PENDING|COM_HW_CONSOLE));
		} else
			sc->sc_hwflags = 0;
		sc->sc_ic = ia->ia_ic;
d290 27
a316 1
	return rval;
a318 5

/*
 * Called by config_detach attempts, shortly after com_pcmcia_remove
 * was called.
 */
d320 2
a321 2
com_pcmcia_detach(self)
	struct device *self;
d323 2
a324 1
	struct com_softc *sc = (void *)self;
d326 6
a331 3
	if (ISSET(sc->sc_hwflags, COM_HW_ABSENT_PENDING)) {
		/* don't let it really be detached, it is still open */
		return EBUSY;
d333 1
a333 1
	return 0;		/* OK! */
a335 4
/*
 * called by pcmcia framework to accept/reject remove attempts.
 * If we return 0, then the detach will proceed.
 */
d337 2
a338 3
com_pcmcia_remove(pc_link, self)
	struct pcmcia_link *pc_link;
	struct device *self;
d340 17
a356 18
	struct com_softc *sc = (void *)self;
	struct tty *tp;
	int s;

	if (!sc->sc_tty)
		goto ok;
	tp = sc->sc_tty;

	/* not in use ?  if so, return "OK" */
	if (!ISSET(tp->t_state, TS_ISOPEN) &&
	    !ISSET(tp->t_state, TS_WOPEN)) {
		ttyfree(sc->sc_tty);
		sc->sc_tty = NULL;
    ok:
		isa_intr_disestablish(sc->sc_ic, sc->sc_ih);
		sc->sc_ih = NULL;
		SET(sc->sc_hwflags, COM_HW_ABSENT);
		return 0;		/* OK! */
a357 12
	/*
	 * Not easily removed.  Put device into a dead state, clean state
	 * as best we can.  notify all waiters.
	 */
	SET(sc->sc_hwflags, COM_HW_ABSENT|COM_HW_ABSENT_PENDING);
#ifdef COM_DEBUG
	printf("pending detach flags %x\n", sc->sc_hwflags);
#endif

	s = spltty();
	com_absent_notify(sc);
	splx(s);
d359 1
a359 1
	return 0;
a361 1
#if 0
d363 2
a364 3
com_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d366 4
a369 9
	struct pcmcia_attach_args *paa = aux;
	
	printf("com_pcmcia_attach %p %p %p\n", parent, self, aux);
	delay(2000000);
	if (!pcmcia_configure(parent, self, paa->paa_link)) {
		struct com_softc *sc = (void *)self;
		sc->sc_hwflags |= COM_HW_ABSENT;
		printf(": not attached\n");
	}
a370 1
#endif
d372 3
a374 4
int
com_pcmcia_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d376 3
a378 26
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int iobase, needioh;
	int rv = 1;
	struct isa_attach_args *ia = aux;

	iot = ia->ia_iot;
	iobase = ia->ia_iobase;
	needioh = 1;

	/* if it's in use as console, it's there. */
	if (iobase == comconsaddr && !comconsattached)
		goto out;

	if (needioh && bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh)) {
		rv = 0;
		goto out;
	}
	rv = comprobe1(iot, ioh);
	if (needioh)
		bus_space_unmap(iot, ioh, COM_NPORTS);

out:
	ia->ia_iosize = COM_NPORTS;
	ia->ia_msize = 0;
	return (rv);
d381 3
d385 2
a386 3
com_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d388 5
a392 13
	struct com_softc *sc = (void *)self;
	int iobase, irq;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct isa_attach_args *ia = aux;

	if (ISSET(sc->sc_hwflags, COM_HW_REATTACH)) {
		int s;
		s = spltty();
		com_absent_notify(sc);
		splx(s);
	} else
	    sc->sc_hwflags = 0;
d396 1
a396 1
	 * We're living on an isa.
d398 22
a419 24
	iobase = ia->ia_iobase;
	iot = ia->ia_iot;
        if (iobase != comconsaddr) {
                if (bus_space_map(iot, iobase, COM_NPORTS, 0, &ioh))
			panic("comattach: io mapping failed");
	} else
                ioh = comconsioh;
	irq = ia->ia_irq;

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	sc->sc_iobase = iobase;

	if (iobase == comconsaddr) {
		comconsattached = 1;

		/* 
		 * Need to reset baud rate, etc. of next print so reset
		 * comconsinit.  Also make sure console is always "hardwired".
		 */
		delay(1000);			/* wait for output to finish */
		comconsinit = 0;
		SET(sc->sc_hwflags, COM_HW_CONSOLE);
		SET(sc->sc_swflags, COM_SW_SOFTCAR);
d422 10
a431 15
	/* look for a NS 16550AF UART with FIFOs */
	bus_space_write_1(iot, ioh, com_fifo,
	    FIFO_ENABLE | FIFO_RCV_RST | FIFO_XMT_RST | FIFO_TRIGGER_14);
	delay(100);
	if (ISSET(bus_space_read_1(iot, ioh, com_iir), IIR_FIFO_MASK) ==
	    IIR_FIFO_MASK) {
		if (ISSET(bus_space_read_1(iot, ioh, com_fifo),
		    FIFO_TRIGGER_14) == FIFO_TRIGGER_14) {
			SET(sc->sc_hwflags, COM_HW_FIFO);
			printf(": ns16550a, working fifo\n");
		} else
			printf(": ns16550, broken fifo\n");
	} else
		printf(": ns8250 or ns16450, no fifo\n");
	bus_space_write_1(iot, ioh, com_fifo, 0);
d433 16
a448 27
	/* disable interrupts */
	bus_space_write_1(iot, ioh, com_ier, 0);
	bus_space_write_1(iot, ioh, com_mcr, 0);

	if (irq != IRQUNK) {
		struct isa_attach_args *ia = aux;

		sc->sc_ih = isa_intr_establish(ia->ia_ic, irq,
		    IST_EDGE, IPL_TTY, comintr, sc, sc->sc_dev.dv_xname);
	}

#ifdef KGDB
	if (kgdb_dev == makedev(commajor, unit)) {
		if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
			kgdb_dev = -1;	/* can't debug over console port */
		else {
			cominit(iot, ioh, kgdb_rate);
			if (kgdb_debug_init) {
				/*
				 * Print prefix of device name,
				 * let kgdb_connect print the rest.
				 */
				printf("%s: ", sc->sc_dev.dv_xname);
				kgdb_connect(1);
			} else
				printf("%s: kgdb enabled\n",
				    sc->sc_dev.dv_xname);
d450 21
d472 37
d510 3
d514 4
a517 3
	/* XXX maybe move up some? */
	if (ISSET(sc->sc_hwflags, COM_HW_CONSOLE))
		printf("%s: console\n", sc->sc_dev.dv_xname);
@


1.2
log
@Removed the unused arg of comprobe1
@
text
@d1 1
a1 1
/*	$OpenBSD: com_pcmcia.c,v 1.1 1996/11/30 13:39:24 niklas Exp $	*/
d322 1
a322 1
	    IIR_FIFO_MASK)
d329 1
a329 1
	else
@


1.1
log
@Com driver moved, still somewhat ISA-dependent though, but it will
improve.  Pica and PCMCIA-dependent stuff factored out.
@
text
@d1 1
a1 1
/*	$OpenBSD: com.c,v 1.28 1996/11/29 22:54:52 niklas Exp $	*/
d258 1
a258 1
	rv = comprobe1(iot, ioh, iobase);
@

