head	1.48;
access;
symbols
	OPENBSD_6_2:1.48.0.10
	OPENBSD_6_2_BASE:1.48
	OPENBSD_6_1:1.48.0.8
	OPENBSD_6_1_BASE:1.48
	OPENBSD_6_0:1.48.0.4
	OPENBSD_6_0_BASE:1.48
	OPENBSD_5_9:1.48.0.2
	OPENBSD_5_9_BASE:1.48
	OPENBSD_5_8:1.45.0.4
	OPENBSD_5_8_BASE:1.45
	OPENBSD_5_7:1.44.0.4
	OPENBSD_5_7_BASE:1.44
	OPENBSD_5_6:1.43.0.4
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.42.0.4
	OPENBSD_5_5_BASE:1.42
	OPENBSD_5_4:1.41.0.10
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.8
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.41.0.6
	OPENBSD_5_2_BASE:1.41
	OPENBSD_5_1_BASE:1.41
	OPENBSD_5_1:1.41.0.4
	OPENBSD_5_0:1.41.0.2
	OPENBSD_5_0_BASE:1.41
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.8
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.4
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.37.0.2
	OPENBSD_4_4_BASE:1.37
	OPENBSD_4_3:1.36.0.4
	OPENBSD_4_3_BASE:1.36
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.35.0.4
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.2
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.33.0.2
	OPENBSD_3_8_BASE:1.33
	OPENBSD_3_7:1.32.0.2
	OPENBSD_3_7_BASE:1.32
	OPENBSD_3_6:1.31.0.2
	OPENBSD_3_6_BASE:1.31
	SMP_SYNC_A:1.31
	SMP_SYNC_B:1.31
	OPENBSD_3_5:1.30.0.4
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.30.0.2
	OPENBSD_3_4_BASE:1.30
	UBC_SYNC_A:1.29
	OPENBSD_3_3:1.29.0.4
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.29.0.2
	OPENBSD_3_2_BASE:1.29
	OPENBSD_3_1:1.28.0.2
	OPENBSD_3_1_BASE:1.28
	UBC_SYNC_B:1.29
	UBC:1.27.0.4
	UBC_BASE:1.27
	OPENBSD_3_0:1.27.0.2
	OPENBSD_3_0_BASE:1.27
	OPENBSD_2_9_BASE:1.26
	OPENBSD_2_9:1.26.0.4
	OPENBSD_2_8:1.26.0.2
	OPENBSD_2_8_BASE:1.26
	OPENBSD_2_7:1.23.0.2
	OPENBSD_2_7_BASE:1.23
	SMP:1.21.0.2
	SMP_BASE:1.21
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.2
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.8.0.2
	OPENBSD_2_3_BASE:1.8
	OPENBSD_2_2:1.7.0.2
	OPENBSD_2_2_BASE:1.7
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.48
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.47;
commitid	f4dx5ry1aOiKJw33;

1.47
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.46;
commitid	5gdEnqVoJuTuwdTu;

1.46
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.45;
commitid	5DvsamK0GblTp8ww;

1.45
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.44;
commitid	p4LJxGKbi0BU2cG6;

1.44
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.43;
commitid	nYggAidK85QbUFh2;

1.43
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.42;

1.42
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.40;

1.40
date	2011.03.31.13.05.27;	author jasper;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.08.20.25.17;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.17.18.01.52;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.30;

1.30
date	2003.07.08.20.17.05;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.01.13.31.06;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.27.4.1;
next	1.26;

1.26
date	2000.09.15.22.28.52;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2000.06.28.18.03.37;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2000.05.29.18.04.07;	author aaron;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.24.15.27.02;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.02.18.47.01;	author deraadt;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	99.08.16.16.51.19;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.08.16.07.41.29;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	99.08.16.06.49.29;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	99.08.14.05.47.41;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.07.26.05.43.15;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	99.05.28.12.41.55;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.01.28.04.58.30;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	98.12.17.20.14.35;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	98.09.19.10.08.06;	author maja;	state Exp;
branches;
next	1.10;

1.10
date	98.09.16.21.16.55;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	98.09.11.10.47.14;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	98.03.17.00.00.57;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	97.07.30.11.12.28;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.11.28.23.28.15;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.12.20.31.00;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.12.36.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.07.34.16;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.05.13.39.22;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.05.03.07.58.23;	author deraadt;	state Exp;
branches;
next	;

1.21.2.1
date	2001.05.14.22.26.06;	author niklas;	state Exp;
branches;
next	1.21.2.2;

1.21.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.21.2.3;

1.21.2.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.21.2.4;

1.21.2.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.21.2.5;

1.21.2.5
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.21.2.6;

1.21.2.6
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.27.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.27.4.2;

1.27.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.48
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@/*	$OpenBSD: if_ep_pcmcia.c,v 1.47 2015/11/24 17:11:40 mpi Exp $	*/
/*	$NetBSD: if_ep_pcmcia.c,v 1.16 1998/08/17 23:20:40 thorpej Exp $  */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/elink3var.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

int	ep_pcmcia_match(struct device *, void *, void *);
void	ep_pcmcia_attach(struct device *, struct device *, void *);
int	ep_pcmcia_detach(struct device *, int);
int	ep_pcmcia_activate(struct device *, int);

int	ep_pcmcia_get_enaddr(struct pcmcia_tuple *, void *);
#ifdef notyet
int	ep_pcmcia_enable(struct ep_softc *);
void	ep_pcmcia_disable(struct ep_softc *);
void	ep_pcmcia_disable1(struct ep_softc *);
#endif

int	ep_pcmcia_enable1(struct ep_softc *);

struct ep_pcmcia_softc {
	struct ep_softc sc_ep;			/* real "ep" softc */

	/* PCMCIA-specific goo */
	struct pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o space info */
	int sc_io_window;			/* our i/o window */
	struct pcmcia_function *sc_pf;		/* our PCMCIA function */
};

struct cfattach ep_pcmcia_ca = {
	sizeof(struct ep_pcmcia_softc), ep_pcmcia_match, ep_pcmcia_attach,
	ep_pcmcia_detach, ep_pcmcia_activate
};

struct ep_pcmcia_product {
	u_int16_t	epp_product;	/* PCMCIA product ID */
	u_short		epp_chipset;	/* 3Com chipset used */
	int		epp_flags;	/* initial softc flags */
	int		epp_expfunc;	/* expected function */
} ep_pcmcia_prod[] = {
	{ PCMCIA_PRODUCT_3COM_3C562,	EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3C589,	EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3CXEM556,	EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3CXEM556B,EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3C1,	EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3CCFEM556BI, EP_CHIPSET_ROADRUNNER,
	  EP_FLAGS_MII,			0 },

	{ PCMCIA_PRODUCT_3COM_3C574,	EP_CHIPSET_ROADRUNNER,
	  EP_FLAGS_MII,			0 }
};

struct ep_pcmcia_product *ep_pcmcia_lookup(struct pcmcia_attach_args *);

struct ep_pcmcia_product *
ep_pcmcia_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	int i;

	for (i = 0; i < nitems(ep_pcmcia_prod); i++)
		if (pa->product == ep_pcmcia_prod[i].epp_product &&
		    pa->pf->number == ep_pcmcia_prod[i].epp_expfunc)
			return &ep_pcmcia_prod[i];

	return (NULL);
}

int
ep_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;

	if (pa->manufacturer != PCMCIA_VENDOR_3COM)
		return (0);

	if (ep_pcmcia_lookup(pa) != NULL)
		return (1);

	return (0);
}

#ifdef notdef
int
ep_pcmcia_enable(sc)
	struct ep_softc *sc;
{
	struct ep_pcmcia_softc *psc = (struct ep_pcmcia_softc *) sc;
	struct pcmcia_function *pf = psc->sc_pf;

	/* establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, epintr,
	    sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (ep_pcmcia_enable1(sc));
}
#endif

int
ep_pcmcia_enable1(sc)
	struct ep_softc *sc;
{
	struct ep_pcmcia_softc *psc = (struct ep_pcmcia_softc *) sc;
	struct pcmcia_function *pf = psc->sc_pf;
	int ret;

	if ((ret = pcmcia_function_enable(pf)))
		return (ret);

	if ((psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) ||
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556) ||
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556B)) {
		int reg;

		/* turn off the serial-disable bit */

		reg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);
		if (reg & 0x08) {
			reg &= ~0x08;
			pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);
		}

	}

	return (ret);
}

#ifdef notyet
void
ep_pcmcia_disable(sc)
	struct ep_softc *sc;
{
	struct ep_pcmcia_softc *psc = (struct ep_pcmcia_softc *) sc;

	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
	ep_pcmcia_disable1(sc);
}

void
ep_pcmcia_disable1(sc)
	struct ep_softc *sc;
{
	struct ep_pcmcia_softc *psc = (struct ep_pcmcia_softc *) sc;

	pcmcia_function_disable(psc->sc_pf);
}
#endif

void
ep_pcmcia_attach(parent, self, aux)
	struct device  *parent, *self;
	void           *aux;
{
	struct ep_pcmcia_softc *psc = (void *) self;
	struct ep_softc *sc = &psc->sc_ep;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	struct ep_pcmcia_product *epp;
	u_int8_t myla[ETHER_ADDR_LEN];
	u_int8_t *enaddr = NULL;
	const char *intrstr;
	int i;

	psc->sc_pf = pa->pf;
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (ep_pcmcia_enable1(sc))
		printf(": function enable failed\n");

#ifdef notyet
	sc->enabled = 1;
#endif

	if (cfe->num_memspace != 0)
		printf(": unexpected number of memory spaces %d should be 0\n",
		    cfe->num_memspace);

	if (cfe->num_iospace != 1)
		printf(": unexpected number of I/O spaces %d should be 1\n",
		    cfe->num_iospace);

	if (pa->product == PCMCIA_PRODUCT_3COM_3C562) {
		bus_addr_t maxaddr = (pa->pf->sc->iobase + pa->pf->sc->iosize);

		for (i = pa->pf->sc->iobase; i < maxaddr; i += 0x10) {
			/*
			 * the 3c562 can only use 0x??00-0x??7f
			 * according to the Linux driver
			 */
			if (i & 0x80)
				continue;
			if (pcmcia_io_alloc(pa->pf, i, cfe->iospace[0].length,
			    cfe->iospace[0].length, &psc->sc_pcioh) == 0)
				break;
		}
		if (i >= maxaddr) {
			printf(": can't allocate i/o space\n");
			return;
		}
	} else {
		if (pcmcia_io_alloc(pa->pf, 0, cfe->iospace[0].length,
		    cfe->iospace[0].length, &psc->sc_pcioh))
			printf(": can't allocate i/o space\n");
	}

	sc->sc_iot = psc->sc_pcioh.iot;
	sc->sc_ioh = psc->sc_pcioh.ioh;

	if (pcmcia_io_map(pa->pf, ((cfe->flags & PCMCIA_CFE_IO16) ?
	    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8), 0, cfe->iospace[0].length,
	    &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		return;
	}

	printf(" port 0x%lx/%ld", psc->sc_pcioh.addr, psc->sc_pcioh.size);

	switch (pa->product) {
	case PCMCIA_PRODUCT_3COM_3C562:
		/*
		 * 3c562a-c use this; 3c562d does it in the regular way.
		 * we might want to check the revision and produce a warning
		 * in the future.
		 */
		/* FALLTHROUGH */
	case PCMCIA_PRODUCT_3COM_3C574:
	case PCMCIA_PRODUCT_3COM_3CCFEM556BI:
		/*
		 * Apparently, some 3c574s do it this way, as well.
		 */
		if (pcmcia_scan_cis(parent, ep_pcmcia_get_enaddr, myla))
			enaddr = myla;
		break;
	}

	sc->bustype = EP_BUS_PCMCIA;

	epp = ep_pcmcia_lookup(pa);
	if (epp == NULL)
		panic("ep_pcmcia_attach: impossible");

	sc->ep_flags = epp->epp_flags;

#ifdef notyet
	sc->enable = ep_pcmcia_enable;
	sc->disable = ep_pcmcia_disable;
#endif

	/* establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, epintr, sc,
	    sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);

	printf(":");

	epconfig(sc, epp->epp_chipset, enaddr);

#ifdef notyet
	sc->enabled = 0;

	ep_pcmcia_disable1(sc);
#endif
}

int
ep_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	int rv;
	struct ep_pcmcia_softc *psc = (struct ep_pcmcia_softc *)dev;

	if ((rv = ep_detach(dev)) != 0)
		return (rv);

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	return (0);
}

int
ep_pcmcia_activate(dev, act)
	struct device *dev;
	int act;
{
	struct ep_pcmcia_softc *sc = (struct ep_pcmcia_softc *)dev;
	struct ep_softc *esc = &sc->sc_ep;
	struct ifnet *ifp = &esc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			epstop(esc);
		if (sc->sc_ep.sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ep.sc_ih);
		sc->sc_ep.sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ep.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    epintr, sc, esc->sc_dev.dv_xname);
		if (ifp->if_flags & IFF_UP)
			epinit(esc);
		break;
	case DVACT_DEACTIVATE:
		if (sc->sc_ep.sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ep.sc_ih);
		sc->sc_ep.sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

int
ep_pcmcia_get_enaddr(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	u_int8_t *myla = arg;
	int i;

	/* this is 3c562a-c magic */
	if (tuple->code == 0x88) {
		if (tuple->length < ETHER_ADDR_LEN)
			return (0);

		for (i = 0; i < ETHER_ADDR_LEN; i += 2) {
			myla[i] = pcmcia_tuple_read_1(tuple, i + 1);
			myla[i + 1] = pcmcia_tuple_read_1(tuple, i);
		}

		return (1);
	}
	return (0);
}
@


1.47
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.46 2015/11/24 13:33:18 mpi Exp $	*/
a76 1
#include <net/netisr.h>
@


1.46
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.45 2015/03/14 03:38:49 jsg Exp $	*/
a76 1
#include <net/if_dl.h>
@


1.45
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.44 2014/08/11 12:45:45 mpi Exp $	*/
a77 1
#include <net/if_types.h>
@


1.44
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.43 2014/05/04 20:09:15 sf Exp $	*/
a95 1
#include <dev/ic/elink3reg.h>
@


1.43
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.42 2013/08/07 01:06:39 bluhm Exp $	*/
a81 1
#ifdef INET
a82 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a83 1
#endif
@


1.42
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.41 2011/07/03 15:47:17 matthew Exp $	*/
d334 1
a334 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.41
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.40 2011/03/31 13:05:27 jasper Exp $	*/
a84 1
#include <netinet/in_var.h>
@


1.40
log
@- use nitems(); no binary change.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.39 2010/08/30 20:33:18 deraadt Exp $	*/
a412 9
	case DVACT_ACTIVATE:
		if (sc->sc_ep.sc_ih == NULL) {
			pcmcia_function_enable(sc->sc_pf);
			sc->sc_ep.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
			    epintr, sc, esc->sc_dev.dv_xname);
		}
		if (ifp->if_flags & IFF_UP)
			epinit(esc);
		break;
@


1.39
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.38 2009/10/13 19:33:16 pirofti Exp $	*/
d171 1
a171 1
	for (i = 0; i < sizeof(ep_pcmcia_prod)/sizeof(ep_pcmcia_prod[0]); i++)
@


1.38
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.37 2008/06/26 05:42:17 ray Exp $	*/
a410 1
	int s;
a411 1
	s = splnet();
d414 18
d435 2
a436 1
		epinit(esc);
a437 1

d439 3
a441 4
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			epstop(esc);
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ep.sc_ih);
a444 1
	splx(s);
@


1.37
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.36 2007/05/08 20:25:17 deraadt Exp $	*/
d110 1
a110 1
int	ep_pcmcia_activate(struct device *, enum devact);
d406 1
a406 1
	enum devact act;
@


1.36
log
@#ifdef notdef functions which are only called in #ifdef notdef contexts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.35 2006/06/17 18:01:52 brad Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.35
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.34 2005/11/21 18:16:42 millert Exp $	*/
d120 1
d123 2
a126 1
void	ep_pcmcia_disable1(struct ep_softc *);
d202 1
d221 1
d252 1
d271 1
@


1.34
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.33 2005/06/08 17:03:01 henning Exp $	*/
d80 1
@


1.33
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.32 2005/01/27 17:04:55 millert Exp $	*/
d79 1
a79 1
#include <sys/select.h>
@


1.32
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.31 2004/05/12 06:35:11 tedu Exp $	*/
a93 5
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
@


1.31
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.30 2003/07/08 20:17:05 mickey Exp $	*/
d283 1
d374 5
a378 4
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, epintr,
	    sc, "");
	if (sc->sc_ih == NULL)
		printf(", couldn't establish interrupt");
@


1.30
log
@no need for an explicit machine/intr.h; tested on alpha, i386, sparc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.29 2002/07/01 13:31:06 fgsch Exp $	*/
a102 1
#include <net/bpfdesc.h>
@


1.29
log
@when printing the size, use what we have map'ed, not what's in the
configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.28 2002/03/14 01:27:01 millert Exp $	*/
a107 1
#include <machine/intr.h>
@


1.28
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.27 2001/08/17 21:52:16 deraadt Exp $	*/
d341 1
a341 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, cfe->iospace[0].length);
@


1.27
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.26 2000/09/15 22:28:52 aaron Exp $	*/
d120 8
a127 8
int	ep_pcmcia_match __P((struct device *, void *, void *));
void	ep_pcmcia_attach __P((struct device *, struct device *, void *));
int	ep_pcmcia_detach __P((struct device *, int));
int	ep_pcmcia_activate __P((struct device *, enum devact));

int	ep_pcmcia_get_enaddr __P((struct pcmcia_tuple *, void *));
int	ep_pcmcia_enable __P((struct ep_softc *));
void	ep_pcmcia_disable __P((struct ep_softc *));
d129 2
a130 2
int	ep_pcmcia_enable1 __P((struct ep_softc *));
void	ep_pcmcia_disable1 __P((struct ep_softc *));
d174 1
a174 1
struct ep_pcmcia_product *ep_pcmcia_lookup __P((struct pcmcia_attach_args *));
@


1.27.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.27 2001/08/17 21:52:16 deraadt Exp $	*/
d120 8
a127 8
int	ep_pcmcia_match(struct device *, void *, void *);
void	ep_pcmcia_attach(struct device *, struct device *, void *);
int	ep_pcmcia_detach(struct device *, int);
int	ep_pcmcia_activate(struct device *, enum devact);

int	ep_pcmcia_get_enaddr(struct pcmcia_tuple *, void *);
int	ep_pcmcia_enable(struct ep_softc *);
void	ep_pcmcia_disable(struct ep_softc *);
d129 2
a130 2
int	ep_pcmcia_enable1(struct ep_softc *);
void	ep_pcmcia_disable1(struct ep_softc *);
d174 1
a174 1
struct ep_pcmcia_product *ep_pcmcia_lookup(struct pcmcia_attach_args *);
@


1.27.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.27.4.1 2002/06/11 03:42:28 art Exp $	*/
d341 1
a341 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.26
log
@Support the ejection of mii ep(4) devices, i.e., the 3c574.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.25 2000/06/28 18:03:37 millert Exp $	*/
d214 2
a215 1
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, epintr, sc);
d375 2
a376 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, epintr, sc);
d422 2
a423 4
		printf("%s:", esc->sc_dev.dv_xname);
		sc->sc_ep.sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, epintr, sc);
		printf("\n");
@


1.25
log
@Remove pointless variable.  It is set to 0, then returned without modification.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.24 2000/05/29 18:04:07 aaron Exp $	*/
d394 1
d396 3
a398 2
	struct ep_softc *sc = &psc->sc_ep;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a401 3

	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.24
log
@Support for 3c574 and 3CCFEM556BI PCMCIA Ethernet; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.23 2000/04/24 19:43:35 niklas Exp $	*/
a396 1
	int rv = 0;
d404 1
a404 1
	return (rv);
@


1.23
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.22 2000/04/24 15:27:02 fgsch Exp $	*/
d110 3
d167 1
a167 2
#ifdef notyet
	{ PCMCIA_PRODUCT_3COM_3CCFEM556BI, EP_CHIPSET_BOOMERANG,
d170 1
a170 1
	{ PCMCIA_PRODUCT_3COM_3C574,	EP_CHIPSET_BOOMERANG,
a171 1
#endif
d365 2
@


1.22
log
@3C1 and 3CCFEM556BI (this one uses boomerang chipset, so no support yet);
from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.21 2000/02/02 18:47:01 deraadt Exp $	*/
d258 1
a259 1
	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
d430 1
a431 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ep.sc_ih);
@


1.21
log
@make the activate routines do xxstop() and xxinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.20 1999/08/16 16:51:19 deraadt Exp $	*/
d161 3
d165 3
d169 1
a169 1
	  EP_FLAGS_MII,			0}
d350 1
@


1.21.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.26 2000/09/15 22:28:52 aaron Exp $	*/
a109 3
#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

d161 4
a164 8
	{ PCMCIA_PRODUCT_3COM_3C1,	EP_CHIPSET_3C509,
	  0,				0 },

	{ PCMCIA_PRODUCT_3COM_3CCFEM556BI, EP_CHIPSET_ROADRUNNER,
	  EP_FLAGS_MII,			0 },

	{ PCMCIA_PRODUCT_3COM_3C574,	EP_CHIPSET_ROADRUNNER,
	  EP_FLAGS_MII,			0 }
d252 1
a253 1
	ep_pcmcia_disable1(sc);
a343 1
	case PCMCIA_PRODUCT_3COM_3CCFEM556BI:
a357 2
	sc->ep_flags = epp->epp_flags;

a383 1
	int rv;
d385 3
a387 3

	if ((rv = ep_detach(dev)) != 0)
		return (rv);
d392 4
a395 1
	return (0);
d423 1
a424 1
		pcmcia_function_disable(sc->sc_pf);
@


1.21.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.21.2.1 2001/05/14 22:26:06 niklas Exp $	*/
d214 1
a214 2
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, epintr,
	    sc, sc->sc_dev.dv_xname);
d374 1
a374 2
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, epintr,
	    sc, "");
d420 4
a423 2
		sc->sc_ep.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    epintr, sc, esc->sc_dev.dv_xname);
@


1.21.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 8
a127 8
int	ep_pcmcia_match(struct device *, void *, void *);
void	ep_pcmcia_attach(struct device *, struct device *, void *);
int	ep_pcmcia_detach(struct device *, int);
int	ep_pcmcia_activate(struct device *, enum devact);

int	ep_pcmcia_get_enaddr(struct pcmcia_tuple *, void *);
int	ep_pcmcia_enable(struct ep_softc *);
void	ep_pcmcia_disable(struct ep_softc *);
d129 2
a130 2
int	ep_pcmcia_enable1(struct ep_softc *);
void	ep_pcmcia_disable1(struct ep_softc *);
d174 1
a174 1
struct ep_pcmcia_product *ep_pcmcia_lookup(struct pcmcia_attach_args *);
@


1.21.2.4
log
@Sync the SMP branch with 3.3
@
text
@d341 1
a341 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.21.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d108 1
@


1.21.2.6
log
@Merge with the trunk
@
text
@d103 1
@


1.20
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.19 1999/08/16 07:41:29 fgsch Exp $	*/
d404 2
d412 1
d415 2
d420 3
@


1.19
log
@more shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.18 1999/08/16 06:49:29 fgsch Exp $	*/
d144 1
a144 1
	u_int32_t	epp_product;	/* PCMCIA product ID */
@


1.18
log
@Remove unnecessary code. Shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.17 1999/08/14 05:47:41 fgsch Exp $	*/
d367 2
@


1.17
log
@Support for 3CXEM556B-INT.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.16 1999/08/08 01:17:23 niklas Exp $	*/
d148 1
a148 2
	const char	*epp_name;	/* device name */
} ep_pcmcia_products[] = {
d150 1
a150 2
	  0,				0,
	  PCMCIA_STR_3COM_3C562 },
d153 1
a153 2
	  0,				0,
	  PCMCIA_STR_3COM_3C589 },
d156 1
a156 2
	  0,				0,
	  PCMCIA_STR_3COM_3CXEM556 },
d159 1
a159 2
	  0,				0,
	  PCMCIA_STR_3COM_3CXEM556B },
d163 1
a163 2
	  EP_FLAGS_MII,			0,
	  PCMCIA_STR_3COM_3C574 },
a164 4

	{ 0,				0,
	  0,				0,
	  NULL },
d173 1
a173 1
	struct ep_pcmcia_product *epp;
d175 4
a178 4
	for (epp = ep_pcmcia_products; epp->epp_name != NULL; epp++)
		if (pa->product == epp->epp_product &&
		    pa->pf->number == epp->epp_expfunc)
			return (epp);
a367 1
	printf(": <%s>", epp->epp_name);
@


1.16
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.15 1999/07/26 05:43:15 deraadt Exp $	*/
d162 4
d239 2
a240 1
	    (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3CXEM556)) {
@


1.15
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.14 1999/05/28 12:41:55 niklas Exp $	*/
d119 2
d139 2
a140 1
	sizeof(struct ep_pcmcia_softc), ep_pcmcia_match, ep_pcmcia_attach
d285 1
a285 1
	cfe = pa->pf->cfe_head.sqh_first;
d381 44
@


1.14
log
@0 alignment is bad, now aic at pcmcia at least attaches!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.13 1999/01/28 04:58:30 fgsch Exp $	*/
d335 2
a359 2
	printf(": %s,", epp->epp_name);

a364 2
	epconfig(sc, epp->epp_chipset, enaddr);

d368 4
a371 2
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
@


1.13
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.12 1998/12/17 20:14:35 fgsch Exp $	*/
d312 1
a312 1
			    0, &psc->sc_pcioh) == 0)
@


1.12
log
@Disable 3c574 until all the MII code required is added.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.11 1998/09/19 10:08:06 maja Exp $	*/
d150 1
d155 4
d231 2
a232 1
	if (psc->sc_pf->sc->card.product == PCMCIA_PRODUCT_3COM_3C562) {
@


1.11
log
@Added if_media support from NetBSD. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.10 1998/09/16 21:16:55 deraadt Exp $	*/
d154 1
d158 1
@


1.10
log
@fix ep probe message printouts
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.9 1998/09/11 10:47:14 fgsch Exp $	*/
d86 1
@


1.9
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d349 1
a349 1
	printf(": %s\n", epp->epp_name);
@


1.8
log
@delete extra print
@
text
@d1 39
a39 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.7 1997/07/30 11:12:28 niklas Exp $       */
d42 1
a42 2
 * Copyright (c) 1994 Herb Peyerl <hpeyerl@@novatel.ca>
 * All rights reserved.
d54 2
a55 2
 *      This product includes software developed by Herb Peyerl.
 * 4. The name of Herb Peyerl may not be used to endorse or promote products
d73 1
a80 1
#include <sys/systm.h>
a82 1
#include <net/netisr.h>
d95 5
d107 1
d112 1
a112 1
#include <dev/isa/isavar.h>		/*XXX*/
d114 1
d116 18
a133 9
int ep_pcmcia_match __P((struct device *, void *, void *));
void ep_pcmcia_attach __P((struct device *, struct device *, void *));
int ep_pcmcia_detach __P((struct device *));

int ep_pcmcia_isasetup __P((struct device *, void *, void *,
    struct pcmcia_link *));
int epmod __P((struct pcmcia_link *, struct device *, struct pcmcia_conf *,
    struct cfdata *));
int ep_remove __P((struct pcmcia_link *, struct device *));
d136 1
a136 2
	sizeof(struct ep_softc), ep_pcmcia_match, ep_pcmcia_attach,
	ep_pcmcia_detach
d139 39
a177 1
/* additional setup needed for pcmcia devices */
d179 13
a191 35
ep_pcmcia_isasetup(parent, match, aux, pc_link)
	struct device	*parent;
	void		*match;
	void		*aux;
	struct pcmcia_link *pc_link;
{
	struct ep_softc *sc = (void *) match;
	struct isa_attach_args *ia = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	extern int ifqmaxlen;

	bus_space_write_2(iot, ioh, EP_COMMAND, WINDOW_SELECT | 0);
	bus_space_write_2(iot, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
	bus_space_write_2(iot, ioh, EP_W0_RESOURCE_CFG, 0x3f00);

	/*
	 * ok til here. Now try to figure out which link we have.
	 * try coax first...
	 */
#ifdef EP_COAX_DEFAULT
	bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG, 0xC000);
#else
	/* COAX as default is reported to be a problem */
	bus_space_write_2(iot, ioh, EP_W0_ADDRESS_CFG, 0x0000);
#endif
	ifp->if_snd.ifq_maxlen = ifqmaxlen;

	ia->ia_iosize = 0x10;
	ia->ia_msize = 0;

 	sc->bustype = EP_BUS_PCMCIA;
	sc->pcmcia_flags = (pc_link->flags & PCMCIA_REATTACH) ? EP_REATTACH:0;
	return 1;
a193 1
/* modify config entry */
d195 13
a207 22
epmod(pc_link, self, pc_cf, cf)
	struct pcmcia_link *pc_link;
	struct device  *self;
	struct pcmcia_conf *pc_cf;
	struct cfdata  *cf;
{
	int             err;
/*	struct pcmciadevs *dev = pc_link->device;*/
/*	struct ep_softc *sc = (void *) self;*/

	if ((err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self, pc_cf,
	    cf)) != 0) {
		printf("bus_config failed %d\n", err);
		return err;
	}

	if (pc_cf->io[0].len > 0x10)
		pc_cf->io[0].len = 0x10;
#if 0
	pc_cf->cfgtype = DOSRESET;
#endif
	pc_cf->cfgtype = 1;
d209 1
a209 1
	return 0;
d213 31
a243 22
ep_remove(pc_link, self)
	struct pcmcia_link *pc_link;
	struct device  *self;
{
	struct ep_softc *sc = (void *) self;
	struct ifnet   *ifp = &sc->sc_arpcom.ac_if;

	if_down(ifp);
	epstop(sc);
	ifp->if_flags &= ~(IFF_RUNNING | IFF_UP);
	sc->pcmcia_flags = EP_ABSENT;
	return PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);
}

static struct pcmcia_3com {
	struct pcmcia_device pcd;
} pcmcia_3com = {
	{
		"PCMCIA 3COM 3C589", epmod,
		ep_pcmcia_isasetup, NULL, ep_remove
	},
};
d245 3
a247 7
struct pcmciadevs pcmcia_ep_devs[] = {
	{
		"ep", 0, "3Com Corporation", "3C589",
		NULL, NULL,
		(void *) -1, (void *) &pcmcia_3com
	},
};
d249 3
a251 4
int
ep_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d253 3
a255 2
	return pcmcia_slave_match(parent, match, aux, pcmcia_ep_devs,
	    sizeof(pcmcia_ep_devs)/sizeof(pcmcia_ep_devs[0]));
d260 2
a261 2
	struct device *parent, *self;
	void *aux;
d263 106
a368 14
	struct ep_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;

	if (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh))
		panic("ep_isa_attach: can't map i/o space");

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	
	epconfig(sc, EP_CHIPSET_3C509);
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
	    IST_EDGE, IPL_NET, epintr, sc, sc->sc_dev.dv_xname);
a370 4
/*
 * No detach; network devices are too well linked into the rest of the
 * kernel.
 */
d372 3
a374 2
ep_pcmcia_detach(self)
	struct device *self;
d376 16
a391 1
	return EBUSY;
@


1.7
log
@Sync to NetBSD.  Adapt to use bus_space_multi_raw* interface of OpenBSD.
Some KNF too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.6 1996/11/28 23:28:15 niklas Exp $       */
a211 2
	printf(": ");

@


1.6
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 2
/*	$OpenBSD: if_ep_pcmcia.c,v 1.5 1996/11/12 20:31:00 niklas Exp $       */
/*	$NetBSD: if_ep.c,v 1.90 1996/04/11 22:29:15 cgd Exp $	*/
d77 5
a81 5
static int ep_pcmcia_isasetup __P((struct device *, void *,
				void *, struct pcmcia_link *));
static int epmod __P((struct pcmcia_link *, struct device *,
		      struct pcmcia_conf *, struct cfdata * cf));
static int ep_remove __P((struct pcmcia_link *, struct device *));
d89 1
a89 1
static int
d128 1
a128 1
static int
d139 2
a140 2
	if ((err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self,
				     pc_cf, cf)) != 0) {
d146 1
a146 1
	    pc_cf->io[0].len = 0x10;
d155 1
a155 1
static int
a204 1
	u_short conn = 0;
a211 3
	GO_WINDOW(0);
	conn = bus_space_read_2(iot, ioh, EP_W0_CONFIG_CTRL);

d214 1
a214 1
	epconfig(sc, conn);
@


1.5
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.4 1996/10/16 12:36:29 deraadt Exp $       */
d66 1
a66 1
#include <machine/bus.old.h>
d100 7
a106 7
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
	extern int      ifqmaxlen;

	bus_io_write_2(bc, ioh, EP_COMMAND, WINDOW_SELECT | 0);
	bus_io_write_2(bc, ioh, EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
	bus_io_write_2(bc, ioh, EP_W0_RESOURCE_CFG, 0x3f00);
d113 1
a113 1
	bus_io_write_2(bc, ioh, EP_W0_ADDRESS_CFG, 0xC000);
d116 1
a116 1
	bus_io_write_2(bc, ioh, EP_W0_ADDRESS_CFG, 0x0000);
d204 2
a205 2
	bus_chipset_tag_t bc = ia->ia_bc;
	bus_io_handle_t ioh;
d208 1
a208 1
	if (bus_io_map(bc, ia->ia_iobase, ia->ia_iosize, &ioh))
d211 1
a211 1
	sc->sc_bc = bc;
d215 1
a215 1
	conn = bus_io_read_2(bc, ioh, EP_W0_CONFIG_CTRL);
@


1.4
log
@unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep_pcmcia.c,v 1.3 1996/05/07 07:34:16 deraadt Exp $       */
d66 1
a66 1
#include <machine/bus.h>
@


1.3
log
@convert to machine/bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ep.c,v 1.11 1996/04/21 22:23:52 deraadt Exp $       */
a101 1
	int             i;
@


1.2
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d66 1
a66 1
#include <machine/pio.h>
d100 2
d105 3
a107 3
	outw(ia->ia_iobase + EP_COMMAND, WINDOW_SELECT | 0);
	outw(ia->ia_iobase + EP_W0_CONFIG_CTRL, ENABLE_DRQ_IRQ);
	outw(ia->ia_iobase + EP_W0_RESOURCE_CFG, 0x3f00);
d114 1
a114 1
	outw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0xC000);
d117 1
a117 1
	outw(ia->ia_iobase + EP_W0_ADDRESS_CFG, 0x0000);
d204 3
a207 1
	struct isa_attach_args *ia = aux;
d209 6
a214 1
	sc->ep_iobase = ia->ia_iobase;
d216 1
a216 1
	conn = inw(ia->ia_iobase + EP_W0_CONFIG_CTRL);
@


1.1
log
@pcmcia version of if_ep (duct-taped together by me)
@
text
@a59 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

@

