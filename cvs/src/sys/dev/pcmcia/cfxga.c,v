head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.14
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.12
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.8
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.4
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.28.0.4
	OPENBSD_5_6_BASE:1.28
	OPENBSD_5_5:1.27.0.4
	OPENBSD_5_5_BASE:1.27
	OPENBSD_5_4:1.23.0.2
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.19.0.4
	OPENBSD_4_8_BASE:1.19
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.17.0.6
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.2
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.16.0.4
	OPENBSD_4_4_BASE:1.16
	OPENBSD_4_3:1.16.0.2
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.29
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.28;
commitid	20ZyHa9gTJxHxhwD;

1.28
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.27;
commitid	OBNa5kfxQ2UXoiIw;

1.27
date	2014.01.22.02.58.35;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.10.21.10.36.25;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.20.20.07.30;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2013.06.11.18.15.55;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.22.11.35.58;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.15;

1.15
date	2007.09.09.01.00.35;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.29.19.11.17;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.29.19.08.22;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2006.11.29.12.13.55;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.28.12.01.27;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2006.11.27.19.31.46;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.27.13.48.31;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.27.12.49.40;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.27.11.50.02;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.27.11.25.34;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.11.27.00.29.02;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.11.26.23.31.14;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2006.11.26.18.51.10;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.11.26.17.04.22;	author miod;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.16.20.45.00;	author miod;	state Exp;
branches;
next	;


desc
@@


1.29
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: cfxga.c,v 1.28 2014/07/12 18:48:52 tedu Exp $	*/

/*
 * Copyright (c) 2005, 2006, Matthieu Herrb and Miodrag Vallat
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHORS DISCLAIM ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Display driver for the Colorgraphic CompactFlash ``VoyagerVGA'' card.
 * based upon the Epson S1D13806 graphics chip.
 *
 * Our goals are:
 * - to provide a somewhat usable emulation mode for extra text display.
 * - to let an application (such as an X server) map the controller registers
 *   in order to do its own display game.
 *
 * Driving this card is somewhat a challenge since:
 * - its video memory is not directly accessible.
 * - no operation can make use of DMA.
 */

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/conf.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciareg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/rasops/rasops.h>

#include <dev/pcmcia/cfxgareg.h>

/*
#define CFXGADEBUG
#define ENABLE_8BIT_MODES
*/

#ifdef CFXGADEBUG
#define	DPRINTF(arg) printf arg
#else
#define	DPRINTF(arg)
#endif

struct cfxga_screen;

#define	CFXGA_MODE_640x480x16	0
#define	CFXGA_MODE_800x600x16	1
#ifdef ENABLE_8BIT_MODES
#define	CFXGA_MODE_640x480x8	2
#define	CFXGA_MODE_800x600x8	3
#define	CFXGA_NMODES		4
#else
#define	CFXGA_NMODES		2
#endif

struct cfxga_softc {
	struct device sc_dev;
	struct pcmcia_function *sc_pf;
	int	sc_state;
#define	CS_MAPPED	0x0001
#define	CS_RESET	0x0002

	struct pcmcia_mem_handle sc_pmemh;
	int sc_memwin;
	bus_addr_t sc_offset;

	int sc_mode;

	int sc_nscreens;
	LIST_HEAD(, cfxga_screen) sc_scr;
	struct cfxga_screen *sc_active;

	/* wsdisplay glue */
	struct wsscreen_descr sc_wsd[CFXGA_NMODES];
	struct wsscreen_list sc_wsl;
	struct wsscreen_descr *sc_scrlist[CFXGA_NMODES];
	struct wsdisplay_emulops sc_ops;
	struct device *sc_wsdisplay;
};

int	cfxga_match(struct device *, void *,  void *);
void	cfxga_attach(struct device *, struct device *, void *);
int	cfxga_detach(struct device *, int);
int	cfxga_activate(struct device *, int);

struct cfattach cfxga_ca = {
	sizeof(struct cfxga_softc), cfxga_match, cfxga_attach,
	cfxga_detach, cfxga_activate
};

struct cfdriver cfxga_cd = {
	NULL, "cfxga", DV_DULL
};

int	cfxga_alloc_screen(void *, const struct wsscreen_descr *, void **,
	    int *, int *, long *);
void	cfxga_burner(void *, u_int, u_int);
void	cfxga_free_screen(void *, void *);
int	cfxga_ioctl(void *, u_long, caddr_t, int, struct proc *);
paddr_t	cfxga_mmap(void *, off_t, int);
int	cfxga_load_font(void *, void *, struct wsdisplay_font *);
int	cfxga_list_font(void *, struct wsdisplay_font *);
int	cfxga_show_screen(void *, void *, int, void (*)(void *, int, int),
	    void *);

struct wsdisplay_accessops cfxga_accessops = {
	.ioctl = cfxga_ioctl,
	.mmap = cfxga_mmap,
	.alloc_screen = cfxga_alloc_screen,
	.free_screen = cfxga_free_screen,
	.show_screen = cfxga_show_screen,
	.load_font = cfxga_load_font,
	.list_font = cfxga_list_font,
	.burn_screen = cfxga_burner
};

/*
 * Per-screen structure
 */

struct cfxga_screen {
	LIST_ENTRY(cfxga_screen) scr_link;
	struct cfxga_softc *scr_sc;	/* parent reference */
	struct rasops_info scr_ri;	/* raster op glue */
	struct wsdisplay_charcell *scr_mem;	/* backing memory */
};
	
int	cfxga_copycols(void *, int, int, int, int);
int	cfxga_copyrows(void *, int, int, int);
int	cfxga_do_cursor(struct rasops_info *);
int	cfxga_erasecols(void *, int, int, int, long);
int	cfxga_eraserows(void *, int, int, long);
int	cfxga_putchar(void *, int, int, u_int, long);

int	cfxga_install_function(struct pcmcia_function *);
void	cfxga_remove_function(struct pcmcia_function *);

int	cfxga_expand_char(struct cfxga_screen *, u_int, int, int, long);
int	cfxga_repaint_screen(struct cfxga_screen *);
void	cfxga_reset_video(struct cfxga_softc *);
void	cfxga_reset_and_repaint(struct cfxga_softc *);
int	cfxga_solid_fill(struct cfxga_screen *, int, int, int, int, int32_t);
int	cfxga_standalone_rop(struct cfxga_screen *, u_int,
	    int, int, int, int, int, int);
int	cfxga_synchronize(struct cfxga_softc *);
u_int	cfxga_wait(struct cfxga_softc *, u_int, u_int);

#define	cfxga_clear_screen(scr) \
	cfxga_solid_fill(scr, 0, 0, scr->scr_ri.ri_width, \
	    scr->scr_ri.ri_height, scr->scr_ri.ri_devcmap[WSCOL_BLACK])

#define	cfxga_read_1(sc, addr) \
	bus_space_read_1((sc)->sc_pmemh.memt, (sc)->sc_pmemh.memh, \
	    (sc)->sc_offset + (addr))
#define	cfxga_read_2(sc, addr) \
	bus_space_read_2((sc)->sc_pmemh.memt, (sc)->sc_pmemh.memh, \
	    (sc)->sc_offset + (addr))
#define	cfxga_write_1(sc, addr, val) \
	bus_space_write_1((sc)->sc_pmemh.memt, (sc)->sc_pmemh.memh, \
	    (sc)->sc_offset + (addr), (val))
#define	cfxga_write_2(sc, addr, val) \
	bus_space_write_2((sc)->sc_pmemh.memt, (sc)->sc_pmemh.memh, \
	    (sc)->sc_offset + (addr), (val))

#define	cfxga_stop_memory_blt(sc) \
	(void)cfxga_read_2(sc, CFREG_BITBLT_DATA)

const char *cfxga_modenames[CFXGA_NMODES] = {
	"640x480x16",
	"800x600x16",
#ifdef ENABLE_8BIT_MODES
	"640x480x8",
	"800x600x8"
#endif
};

/*
 * This card is very poorly engineered, specificationwise. It does not
 * provide any CIS information, and has no vendor/product numbers as
 * well: as such, there is no easy way to differentiate it from any
 * other cheapo PCMCIA card.
 *
 * The best we can do is probe for a chip ID. This is not perfect but better
 * than matching blindly. Of course this requires us to play some nasty games
 * behind the PCMCIA framework to be able to do this probe, and correctly fail
 * if this is not the card we are looking for.
 *
 * In shorter words: some card designers ought to be shot, as a service
 * to the community.
 */

/*
 * Create the necessary pcmcia function structures to alleviate the lack
 * of any CIS information on this device.
 * Actually, we hijack the fake function created by the pcmcia framework.
 */
int
cfxga_install_function(struct pcmcia_function *pf)
{
	struct pcmcia_config_entry *cfe;

	/* Get real. */
	pf->pf_flags &= ~PFF_FAKE;

	/* Tell the pcmcia framework where the CCR is. */
	pf->ccr_base = 0x800;
	pf->ccr_mask = 0x67;

	/* Create a simple cfe. */
	cfe = (struct pcmcia_config_entry *)malloc(sizeof *cfe,
	    M_DEVBUF, M_NOWAIT | M_ZERO);
	if (cfe == NULL) {
		DPRINTF(("%s: cfe allocation failed\n", __func__));
		return (ENOMEM);
	}

	cfe->number = 42;	/* have to put some value... */
	cfe->flags = PCMCIA_CFE_IO16;
	cfe->iftype = PCMCIA_IFTYPE_MEMORY;

	SIMPLEQ_INSERT_TAIL(&pf->cfe_head, cfe, cfe_list);

	pcmcia_function_init(pf, cfe);
	return (0);
}

/*
 * Undo the changes done above.
 * Such a function is necessary since we need a full-blown pcmcia world
 * set up in order to do the device probe, but if we don't match the card,
 * leaving this state will cause trouble during other probes.
 */
void
cfxga_remove_function(struct pcmcia_function *pf)
{
	struct pcmcia_config_entry *cfe;

	/* we are the first and only entry... */
	cfe = SIMPLEQ_FIRST(&pf->cfe_head);
	SIMPLEQ_REMOVE_HEAD(&pf->cfe_head, cfe_list);
	free(cfe, M_DEVBUF, 0);

	/* And we're a figment of the kernel's imagination again. */
	pf->pf_flags |= PFF_FAKE;
}

int 
cfxga_match(struct device *parent, void *match, void *aux)
{
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_function *pf = pa->pf;
	struct pcmcia_mem_handle h;
	int rc;
	int win;
	bus_addr_t ptr;
	u_int8_t id = 0;

	if (pa->product != PCMCIA_PRODUCT_INVALID ||
	    pa->manufacturer != PCMCIA_VENDOR_INVALID)
		return (0);

	/* Only a card with no CIS will have a fake function... */
	if ((pf->pf_flags & PFF_FAKE) == 0)
		return (0);

	if (cfxga_install_function(pf) != 0)
		return (0);

	if (pcmcia_function_enable(pf) != 0) {
		DPRINTF(("%s: function enable failed\n", __func__));
		return (0);
	}

	rc = pcmcia_mem_alloc(pf, CFXGA_MEM_RANGE, &h);
	if (rc != 0)
		goto out;

	rc = pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, 0, CFXGA_MEM_RANGE,
	    &h, &ptr, &win);
	if (rc != 0)
		goto out2;

	id = (bus_space_read_1(h.memt, h.memh, ptr + CFREG_REV) &
	    CR_PRODUCT_MASK) >> CR_PRODUCT_SHIFT;

	pcmcia_mem_unmap(pa->pf, win);
out2:
	pcmcia_mem_free(pa->pf, &h);
out:
	pcmcia_function_disable(pf);
	cfxga_remove_function(pf);

	/*
	 * Be sure to return a value greater than com's if we match,
	 * otherwise it can win due to the way config(8) will order devices...
	 */
	return (id == PRODUCT_S1D13806 ? 10 : 0);
}

int
cfxga_activate(struct device *dev, int act)
{
	struct cfxga_softc *sc = (void *)dev;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		pcmcia_function_disable(sc->sc_pf);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void 
cfxga_attach(struct device *parent, struct device *self, void *aux)
{
	struct cfxga_softc *sc = (void *)self;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_function *pf = pa->pf;
	struct wsemuldisplaydev_attach_args waa;
	struct wsscreen_descr *wsd;
	u_int i;

	LIST_INIT(&sc->sc_scr);
	sc->sc_nscreens = 0;
	sc->sc_pf = pf;

	if (cfxga_install_function(pf) != 0) {
		printf(": pcmcia function setup failed\n");
		return;
	}

	if (pcmcia_function_enable(pf)) {
		printf(": function enable failed\n");
		return;
	}

	if (pcmcia_mem_alloc(pf, CFXGA_MEM_RANGE, &sc->sc_pmemh) != 0) {
		printf(": can't allocate memory space\n");
		return;
	}

	if (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, 0, CFXGA_MEM_RANGE,
	    &sc->sc_pmemh, &sc->sc_offset, &sc->sc_memwin) != 0) {
		printf(": can't map frame buffer registers\n");
		pcmcia_mem_free(pf, &sc->sc_pmemh);
		return;
	}

	SET(sc->sc_state, CS_MAPPED);

	printf("\n");

	sc->sc_mode = WSDISPLAYIO_MODE_EMUL;

	/*
	 * We actually defer real initialization to the creation of the
	 * first wsdisplay screen, since we do not know which mode to pick
	 * yet.
	 */

	for (wsd = sc->sc_wsd, i = 0; i < CFXGA_NMODES; wsd++, i++) {
		strlcpy(wsd->name, cfxga_modenames[i], sizeof(wsd->name));
		wsd->textops = &sc->sc_ops;
		sc->sc_scrlist[i] = wsd;
	}
	sc->sc_wsl.nscreens = CFXGA_NMODES;
	sc->sc_wsl.screens = (const struct wsscreen_descr **)sc->sc_scrlist;

	waa.console = 0;
	waa.scrdata = &sc->sc_wsl;
	waa.accessops = &cfxga_accessops;
	waa.accesscookie = sc;
	waa.defaultscreens = 1;

	if ((sc->sc_wsdisplay =
	    config_found(self, &waa, wsemuldisplaydevprint)) == NULL) {
		/* otherwise wscons will do this */
		if (sc->sc_active != NULL)
			cfxga_clear_screen(sc->sc_active);
		else
			cfxga_burner(sc, 0, 0);
	}
}

int
cfxga_detach(struct device *dev, int flags)
{
	struct cfxga_softc *sc = (void *)dev;

	/*
	 * Detach all children, and hope wsdisplay detach code is correct...
	 */
	if (sc->sc_wsdisplay != NULL) {
		config_detach(sc->sc_wsdisplay, DETACH_FORCE);
		/* sc->sc_wsdisplay = NULL; */
	}

	if (ISSET(sc->sc_state, CS_MAPPED)) {
		pcmcia_mem_unmap(sc->sc_pf, sc->sc_memwin);
		pcmcia_mem_free(sc->sc_pf, &sc->sc_pmemh);
		/* CLR(sc->sc_state, CS_MAPPED); */
	}

	return (0);
}

/*
 * Wscons operations
 */

int
cfxga_alloc_screen(void *v, const struct wsscreen_descr *type, void **cookiep,
    int *curxp, int *curyp, long *attrp)
{
	struct cfxga_softc *sc = v;
	struct cfxga_screen *scr;
	struct rasops_info *ri;
	u_int mode, width, height, depth, scrsize;

	scr = malloc(sizeof *scr, M_DEVBUF,
	    (cold ? M_NOWAIT : M_WAITOK) | M_ZERO);
	if (scr == NULL)
		return (ENOMEM);

	mode = type - sc->sc_wsd;
#ifdef DIAGNOSTIC
	if (mode >= CFXGA_NMODES)
		mode = CFXGA_MODE_640x480x16;
#endif
	switch (mode) {
	default:
	case CFXGA_MODE_640x480x16:
		width = 640;
		height = 480;
		depth = 16;
		break;
	case CFXGA_MODE_800x600x16:
		width = 800;
		height = 600;
		depth = 16;
		break;
#ifdef ENABLE_8BIT_MODES
	case CFXGA_MODE_640x480x8:
		width = 640;
		height = 480;
		depth = 8;
		break;
	case CFXGA_MODE_800x600x8:
		width = 800;
		height = 600;
		depth = 8;
		break;
#endif
	}

	ri = &scr->scr_ri;
	ri->ri_hw = (void *)scr;
	ri->ri_bits = NULL;
	ri->ri_depth = depth;
	ri->ri_width = width;
	ri->ri_height = height;
	ri->ri_stride = width * depth / 8;
	ri->ri_flg = 0;

	/* swap B and R at 16 bpp */
	if (depth == 16) {
		ri->ri_rnum = 5;
		ri->ri_rpos = 11;
		ri->ri_gnum = 6;
		ri->ri_gpos = 5;
		ri->ri_bnum = 5;
		ri->ri_bpos = 0;
	}

	if (type->nrows == 0)	/* first screen creation */
		rasops_init(ri, 100, 100);
	else
		rasops_init(ri, type->nrows, type->ncols);

	/*
	 * Allocate backing store to remember non-visible screen contents in
	 * emulation mode.
	 */
	scr->scr_mem = mallocarray(ri->ri_rows,
	    ri->ri_cols * sizeof(struct wsdisplay_charcell), M_DEVBUF,
	    (cold ? M_NOWAIT : M_WAITOK) | M_ZERO);
	if (scr->scr_mem == NULL) {
		free(scr, M_DEVBUF, 0);
		return (ENOMEM);
	}
	scrsize = ri->ri_rows * ri->ri_cols * sizeof(struct wsdisplay_charcell);

	ri->ri_ops.copycols = cfxga_copycols;
	ri->ri_ops.copyrows = cfxga_copyrows;
	ri->ri_ops.erasecols = cfxga_erasecols;
	ri->ri_ops.eraserows = cfxga_eraserows;
	ri->ri_ops.putchar = cfxga_putchar;
	ri->ri_do_cursor = cfxga_do_cursor;

	/*
	 * Finish initializing our screen descriptions, now that we know
	 * the actual console emulation parameters.
	 */
	if (type->nrows == 0) {
		struct wsscreen_descr *wsd = (struct wsscreen_descr *)type;

		wsd->nrows = ri->ri_rows;
		wsd->ncols = ri->ri_cols;
		bcopy(&ri->ri_ops, &sc->sc_ops, sizeof(sc->sc_ops));
		wsd->fontwidth = ri->ri_font->fontwidth;
		wsd->fontheight = ri->ri_font->fontheight;
		wsd->capabilities = ri->ri_caps;
	}

	scr->scr_sc = sc;
	LIST_INSERT_HEAD(&sc->sc_scr, scr, scr_link);
	sc->sc_nscreens++;

	ri->ri_ops.alloc_attr(ri, 0, 0, 0, attrp);

	*cookiep = ri;
	*curxp = *curyp = 0;
	
	return (0);
}

void
cfxga_burner(void *v, u_int on, u_int flags)
{
	struct cfxga_softc *sc = (void *)v;
	u_int8_t mode;

	mode = cfxga_read_1(sc, CFREG_MODE) & LCD_MODE_SWIVEL_BIT_0;

	if (on)
		cfxga_write_1(sc, CFREG_MODE, mode | MODE_CRT);
	else
		cfxga_write_1(sc, CFREG_MODE, mode | MODE_NO_DISPLAY);
}

void
cfxga_free_screen(void *v, void *cookie)
{
	struct cfxga_softc *sc = v;
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;

	LIST_REMOVE(scr, scr_link);
	sc->sc_nscreens--;

	if (scr == sc->sc_active) {
		sc->sc_active = NULL;
		cfxga_burner(sc, 0, 0);
	}

	free(scr->scr_mem, M_DEVBUF, 0);
	free(scr, M_DEVBUF, 0);
}

int
cfxga_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct cfxga_softc *sc = v;
	struct cfxga_screen *scr;
	struct wsdisplay_fbinfo *wdf;
	int mode;

	switch (cmd) {
	case WSDISPLAYIO_GTYPE:
		*(u_int *)data = WSDISPLAY_TYPE_CFXGA;
		break;

	case WSDISPLAYIO_GINFO:
		wdf = (struct wsdisplay_fbinfo *)data;
		scr = sc->sc_active;
		if (scr == NULL) {
			/* try later...after running wsconscfg to add screens */
			wdf->height = wdf->width = wdf->depth = wdf->cmsize = 0;
		} else {
			wdf->height = scr->scr_ri.ri_height;
			wdf->width = scr->scr_ri.ri_width;
			wdf->depth = scr->scr_ri.ri_depth;
			wdf->cmsize = scr->scr_ri.ri_depth <= 8 ?
			    (1 << scr->scr_ri.ri_depth) : 0;
		}
		break;

	case WSDISPLAYIO_SMODE:
		mode = *(u_int *)data;
		if (mode == sc->sc_mode)
			break;
		switch (mode) {
		case WSDISPLAYIO_MODE_EMUL:
			cfxga_reset_and_repaint(sc);
			break;
		case WSDISPLAYIO_MODE_MAPPED:
			break;
		default:
			return (EINVAL);
		}
		sc->sc_mode = mode;
		break;

	/* these operations are handled by the wscons code... */
	case WSDISPLAYIO_GVIDEO:
	case WSDISPLAYIO_SVIDEO:
		break;

	/* these operations are not supported... */
	case WSDISPLAYIO_GETCMAP:
	case WSDISPLAYIO_PUTCMAP:
	case WSDISPLAYIO_LINEBYTES:
	case WSDISPLAYIO_GCURPOS:
	case WSDISPLAYIO_SCURPOS:
	case WSDISPLAYIO_GCURMAX:
	case WSDISPLAYIO_GCURSOR:
	case WSDISPLAYIO_SCURSOR:
	default:
		return (-1);
	}

	return (0);
}

paddr_t
cfxga_mmap(void *v, off_t off, int prot)
{
	return (-1);
}

int
cfxga_show_screen(void *v, void *cookie, int waitok,
    void (*cb)(void *, int, int), void *cbarg)
{
	struct cfxga_softc *sc = v;
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw, *old;

	old = sc->sc_active;
	if (old == scr)
		return (0);

	sc->sc_active = scr;
	cfxga_reset_and_repaint(sc);	/* will turn video on if scr != NULL */

	return (0);
}

int
cfxga_load_font(void *v, void *emulcookie, struct wsdisplay_font *font)
{
	struct cfxga_softc *sc = v;
	struct cfxga_screen *scr = sc->sc_active;

	if (scr == NULL)
		return ENXIO;

	return rasops_load_font(&scr->scr_ri, emulcookie, font);
}

int
cfxga_list_font(void *v, struct wsdisplay_font *font)
{
	struct cfxga_softc *sc = v;
	struct cfxga_screen *scr = sc->sc_active;

	if (scr == NULL)
		return ENXIO;

	return rasops_list_font(&scr->scr_ri, font);
}

/*
 * Real frame buffer operations
 */

void
cfxga_reset_video(struct cfxga_softc *sc)
{
	struct cfxga_screen *scr = sc->sc_active;
	struct rasops_info *ri;
#ifdef ENABLE_8BIT_MODES
	const u_int8_t *cmap;
	u_int i;
#endif

	/*
	 * Reset controller
	 */

	/* need to write to both REV and MISC at the same time */
	cfxga_write_2(sc, CFREG_REV, 0x80 | (CM_REGSEL << 8));
	delay(25000);	/* maintain reset for a short while */
	/* need to write to both REV and MISC at the same time */
	cfxga_write_2(sc, CFREG_REV, 0 | (CM_MEMSEL << 8));
	delay(25000);
	/* stop any pending blt operation */
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, 0);
	cfxga_stop_memory_blt(sc);
	cfxga_write_1(sc, CFREG_MODE, 0);	/* disable all displays */

	/*
	 * Setup common video mode parameters.
	 */

	cfxga_write_2(sc, CFREG_MEMCLK, MEMCLK_SRC_CLK3);
#if 0
	cfxga_write_1(sc, CFREG_LCD_PCLK, LCD_PCLK_SRC_CLKI | LCD_PCLK_DIV_1);
	cfxga_write_1(sc, CFREG_MPLUG_CLK,
	    MPLUG_PCLK_SRC_CLKI2 | MPLUG_PCLK_DIV_1);
#endif
	cfxga_write_2(sc, CFREG_CRTTV_PCLK, CRT_PCLK_SRC_CLKI | CRT_PCLK_DIV_1);
	cfxga_write_2(sc, CFREG_WSTATE, WSTATE_MCLK);

	/* MEMCNF and DRAM_RFRSH need to be programmed at the same time */
	cfxga_write_2(sc, CFREG_MEMCNF,
	    MEMCNF_SDRAM_INIT | (DRAM_RFRSH_50MHZ << 8));
	delay(250);
	cfxga_write_2(sc, CFREG_DRAM_TIMING, DRAM_TIMING_50MHZ);

	/*
	 * Setup mode-dependent parameters.
	 */
	if (scr == NULL)
		return;

	ri = &scr->scr_ri;
	switch (scr->scr_ri.ri_width) {
	default:
	case 640:
		cfxga_write_1(sc, CFREG_CRT_HWIDTH, (640 / 8) - 1);
		/* HNDISP and HSTART need to be programmed at the same time */
		cfxga_write_2(sc, CFREG_CRT_HNDISP, 23 | (2 << 8));
		cfxga_write_1(sc, CFREG_CRT_HPULSE, 4);
		cfxga_write_2(sc, CFREG_CRT_VHEIGHT, 480 - 1);
		/* VNDISP and VSTART need to be programmed at the same time */
		cfxga_write_2(sc, CFREG_CRT_VNDISP, 39 | (8 << 8));
		cfxga_write_1(sc, CFREG_CRT_VPULSE, 2);
		break;
	case 800:
		cfxga_write_1(sc, CFREG_CRT_HWIDTH, (800 / 8) - 1);
		/* HNDISP and HSTART need to be programmed at the same time */
		cfxga_write_2(sc, CFREG_CRT_HNDISP, 27 | (2 << 8));
		cfxga_write_1(sc, CFREG_CRT_HPULSE, 4);
		cfxga_write_2(sc, CFREG_CRT_VHEIGHT, 600 - 1);
		/* VNDISP and VSTART need to be programmed at the same time */
		cfxga_write_2(sc, CFREG_CRT_VNDISP, 25 | (8 << 8));
		cfxga_write_1(sc, CFREG_CRT_VPULSE, 2);
		break;
	}
	cfxga_write_1(sc, CFREG_CRT_MODE,
	    ri->ri_depth == 16 ? CRT_MODE_16BPP : CRT_MODE_8BPP);
	cfxga_write_2(sc, CFREG_CRT_START_LOW, 0);
	cfxga_write_1(sc, CFREG_CRT_START_HIGH, 0);
	cfxga_write_2(sc, CFREG_CRT_MEMORY, ri->ri_width * ri->ri_depth / 16);
	cfxga_write_1(sc, CFREG_CRT_PANNING, 0);
	cfxga_write_1(sc, CFREG_CRT_FIFO_THRESHOLD_HIGH, 0);
	cfxga_write_1(sc, CFREG_CRT_FIFO_THRESHOLD_LOW, 0);
	cfxga_write_1(sc, CFREG_CRT_CURSOR_CONTROL, CURSOR_INACTIVE);

#ifdef ENABLE_8BIT_MODES
	/*
	 * On 8bpp video modes, program the LUT
	 */
	if (ri->ri_depth == 8) {
#if 0
		/* Wait for retrace */
		while ((cfxga_read_1(sc, CFREG_CRT_VNDISP) &
		    CRT_VNDISP_STATUS) == 0)
			delay(1);
#endif
		cfxga_write_1(sc, CFREG_LUT_MODE, LUT_CRT);
		cfxga_write_1(sc, CFREG_LUT_ADDRESS, 0); /* autoincrements */
		cmap = rasops_cmap;
		for (i = 256 * 3; i != 0; i--)
			cfxga_write_1(sc, CFREG_LUT_DATA, *cmap++ & 0xf0);
	}
#endif

	cfxga_write_1(sc, CFREG_TV_CONTROL,
	    TV_LUMINANCE_FILTER | TV_SVIDEO_OUTPUT | TV_NTSC_OUTPUT);

	cfxga_write_1(sc, CFREG_POWER_CONF, POWERSAVE_MBO);
	cfxga_write_1(sc, CFREG_WATCHDOG, 0);

	cfxga_write_1(sc, CFREG_MODE, MODE_CRT);
	delay(25000);
}

void
cfxga_reset_and_repaint(struct cfxga_softc *sc)
{
	cfxga_reset_video(sc);

	if (sc->sc_active != NULL)
		cfxga_repaint_screen(sc->sc_active);
	else
		cfxga_burner(sc, 0, 0);
}

/*
 * Wait for the blitter to be in a given state.
 */
u_int
cfxga_wait(struct cfxga_softc *sc, u_int mask, u_int result)
{
	u_int tries;

	for (tries = 10000; tries != 0; tries--) {
		if ((cfxga_read_1(sc, CFREG_BITBLT_CONTROL) & mask) == result)
			break;
		delay(10);
	}

	return (tries);
}

/*
 * Wait for all pending blitter operations to be complete.
 * Returns non-zero if the blitter got stuck.
 */
int
cfxga_synchronize(struct cfxga_softc *sc)
{
	/* Wait for previous operations to complete */
	if (cfxga_wait(sc, BITBLT_ACTIVE, 0) == 0) {
		DPRINTF(("%s: not ready\n", __func__));
		if (ISSET(sc->sc_state, CS_RESET))
			return (EAGAIN);
		else {
			DPRINTF(("%s: resetting...\n", sc->sc_dev.dv_xname));
			SET(sc->sc_state, CS_RESET);
			cfxga_reset_and_repaint(sc);
			CLR(sc->sc_state, CS_RESET);
		}
	}
	cfxga_stop_memory_blt(sc);
	return (0);
}

/*
 * Display a character.
 */
int
cfxga_expand_char(struct cfxga_screen *scr, u_int uc, int x, int y, long attr)
{
	struct cfxga_softc *sc = scr->scr_sc;
	struct rasops_info *ri = &scr->scr_ri;
	struct wsdisplay_font *font = ri->ri_font;
	u_int pos, sts, fifo_avail, chunk;
	u_int8_t *fontbits;
	int bg, fg, ul;
	u_int i;
	int rc;

	pos = (y * ri->ri_width + x) * ri->ri_depth / 8;
	fontbits = (u_int8_t *)(font->data + (uc - font->firstchar) *
	    ri->ri_fontscale);
	ri->ri_ops.unpack_attr(ri, attr, &fg, &bg, &ul);

	/* Wait for previous operations to complete */
	if ((rc = cfxga_synchronize(sc)) != 0)
		return (rc);

	cfxga_write_2(sc, CFREG_COLOR_EXPANSION,
	    ((font->fontwidth - 1) & 7) | (OP_COLOR_EXPANSION << 8));
	cfxga_write_2(sc, CFREG_BITBLT_SRC_LOW, font->fontwidth <= 8 ? 0 : 1);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_HIGH, 0);
	cfxga_write_2(sc, CFREG_BITBLT_DST_LOW, pos);
	cfxga_write_2(sc, CFREG_BITBLT_DST_HIGH, pos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET,
	    ri->ri_width * ri->ri_depth / 16);
	cfxga_write_2(sc, CFREG_BITBLT_WIDTH, font->fontwidth - 1);
	cfxga_write_2(sc, CFREG_BITBLT_HEIGHT, font->fontheight - 1);
	cfxga_write_2(sc, CFREG_BITBLT_FG, ri->ri_devcmap[fg]);
	cfxga_write_2(sc, CFREG_BITBLT_BG, ri->ri_devcmap[bg]);
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, BITBLT_ACTIVE |
	    (ri->ri_depth > 8 ? BITBLT_COLOR_16 : BITBLT_COLOR_8));

	if (cfxga_wait(sc, BITBLT_ACTIVE, BITBLT_ACTIVE) == 0)
		goto fail;	/* unlikely */
	fifo_avail = 0;

	for (i = font->fontheight; i != 0; i--) {
		/*
		 * Find out how much words we can feed before
		 * a FIFO check is needed.
		 */
		if (fifo_avail == 0) {
			sts = cfxga_read_1(sc, CFREG_BITBLT_CONTROL);
			if ((sts & BITBLT_FIFO_NOT_EMPTY) == 0)
				fifo_avail = font->fontwidth <= 8 ? 2 : 1;
			else if ((sts & BITBLT_FIFO_HALF_FULL) == 0)
				fifo_avail = font->fontwidth <= 8 ? 1 : 0;
			else {
				/*
				 * Let the cheap breathe for a short while.
				 * If this is not enough to free some FIFO
				 * entries, abort the operation.
				 */
				if (cfxga_wait(sc, BITBLT_FIFO_FULL, 0) == 0)
					goto fail;
			}
		}

		if (font->fontwidth <= 8) {
			chunk = *fontbits;
			if (ul && i == 1)
				chunk = 0xff;
		} else {
			chunk = *(u_int16_t *)fontbits;
			if (ul && i == 1)
				chunk = 0xffff;
		}
		cfxga_write_2(sc, CFREG_BITBLT_DATA, chunk);
		fontbits += font->stride;
		fifo_avail--;
	}

	return (0);

fail:
	DPRINTF(("%s: abort\n", __func__));
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, 0);
	cfxga_stop_memory_blt(sc);
	return (EINTR);
}

/*
 * Copy a memory bitmap to the frame buffer.
 *
 * This is slow - we only use this to repaint the whole frame buffer on
 * screen switches.
 */
int
cfxga_repaint_screen(struct cfxga_screen *scr)
{
	struct wsdisplay_charcell *cell = scr->scr_mem;
	struct rasops_info *ri = &scr->scr_ri;
	int x, y, cx, cy, lx, ly;
	int fg, bg;
	int rc;

	cfxga_clear_screen(scr);

	cx = ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;

	for (ly = 0, y = ri->ri_yorigin; ly < ri->ri_rows; ly++, y += cy) {
		for (lx = 0, x = ri->ri_xorigin; lx < ri->ri_cols;
		    lx++, x += cx) {
			if (cell->uc == 0 || cell->uc == ' ') {
				ri->ri_ops.unpack_attr(ri, cell->attr,
				    &fg, &bg, NULL);
				rc = cfxga_solid_fill(scr, x, y, cx, cy,
				    ri->ri_devcmap[bg]);
			} else {
				rc = cfxga_expand_char(scr, cell->uc,
				    x, y, cell->attr);
			}
			cell++;
			if (rc != 0)
				return (rc);
		}
	}

	return (0);
}

/*
 * Perform a solid fill operation.
 */
int
cfxga_solid_fill(struct cfxga_screen *scr, int x, int y, int cx, int cy,
    int32_t srccolor)
{
	struct cfxga_softc *sc = scr->scr_sc;
	struct rasops_info *ri = &scr->scr_ri;
	u_int pos;
	int rc;

	pos = (y * ri->ri_width + x) * ri->ri_depth / 8;

	/* Wait for previous operations to complete */
	if ((rc = cfxga_synchronize(sc)) != 0)
		return (rc);

	cfxga_write_2(sc, CFREG_BITBLT_ROP, 0 | (OP_SOLID_FILL << 8));
	cfxga_write_2(sc, CFREG_BITBLT_SRC_LOW, pos);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_HIGH, pos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_DST_LOW, pos);
	cfxga_write_2(sc, CFREG_BITBLT_DST_HIGH, pos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET,
	    ri->ri_width * ri->ri_depth / 16);
	cfxga_write_2(sc, CFREG_BITBLT_WIDTH, cx - 1);
	cfxga_write_2(sc, CFREG_BITBLT_HEIGHT, cy - 1);
	cfxga_write_2(sc, CFREG_BITBLT_FG, (u_int16_t)srccolor);
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, BITBLT_ACTIVE |
	    (ri->ri_depth > 8 ? BITBLT_COLOR_16 : BITBLT_COLOR_8));

	return (0);
}

/*
 * Perform an internal frame buffer operation.
 */
int
cfxga_standalone_rop(struct cfxga_screen *scr, u_int rop, int sx, int sy,
    int dx, int dy, int cx, int cy)
{
	struct cfxga_softc *sc = scr->scr_sc;
	struct rasops_info *ri = &scr->scr_ri;
	u_int srcpos, dstpos;
	u_int opcode;
	int rc;

	srcpos = (sy * ri->ri_width + sx) * ri->ri_depth / 8;
	dstpos = (dy * ri->ri_width + dx) * ri->ri_depth / 8;

	if (dstpos <= srcpos)
		opcode = (OP_MOVE_POSITIVE_ROP << 8) | rop;
	else
		opcode = (OP_MOVE_NEGATIVE_ROP << 8) | rop;

	/* Wait for previous operations to complete */
	if ((rc = cfxga_synchronize(sc)) != 0)
		return (rc);

	cfxga_write_2(sc, CFREG_BITBLT_ROP, opcode);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_LOW, srcpos);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_HIGH, srcpos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_DST_LOW, dstpos);
	cfxga_write_2(sc, CFREG_BITBLT_DST_HIGH, dstpos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET,
	    ri->ri_width * ri->ri_depth / 16);
	cfxga_write_2(sc, CFREG_BITBLT_WIDTH, cx - 1);
	cfxga_write_2(sc, CFREG_BITBLT_HEIGHT, cy - 1);
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, BITBLT_ACTIVE |
	    (ri->ri_depth > 8 ? BITBLT_COLOR_16 : BITBLT_COLOR_8));

	return (0);
}

/*
 * Text console raster operations.
 *
 * We shadow all these operations on a memory copy of the frame buffer.
 * Since we are running in emulation mode only, this could be optimized
 * by only storing actual character cell values (a la mda).
 */

int
cfxga_copycols(void *cookie, int row, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;
	int sx, dx, y, cx, cy;

	/* Copy columns in backing store. */
	memmove(scr->scr_mem + row * ri->ri_cols + dst,
	    scr->scr_mem + row * ri->ri_cols + src,
	    num * sizeof(struct wsdisplay_charcell));

	if (scr != scr->scr_sc->sc_active)
		return 0;

	sx = src * ri->ri_font->fontwidth + ri->ri_xorigin;
	dx = dst * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = row * ri->ri_font->fontheight + ri->ri_yorigin;
	cx = num * ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;
	return cfxga_standalone_rop(scr, ROP_SRC, sx, y, dx, y, cx, cy);
}

int
cfxga_copyrows(void *cookie, int src, int dst, int num)
{
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;
	int x, sy, dy, cx, cy;

	/* Copy rows in backing store. */
	memmove(scr->scr_mem + dst * ri->ri_cols,
	    scr->scr_mem + src * ri->ri_cols,
	    num * ri->ri_cols * sizeof(struct wsdisplay_charcell));

	if (scr != scr->scr_sc->sc_active)
		return 0;

	x = ri->ri_xorigin;
	sy = src * ri->ri_font->fontheight + ri->ri_yorigin;
	dy = dst * ri->ri_font->fontheight + ri->ri_yorigin;
	cx = ri->ri_emuwidth;
	cy = num * ri->ri_font->fontheight;
	return cfxga_standalone_rop(scr, ROP_SRC, x, sy, x, dy, cx, cy);
}

int
cfxga_do_cursor(struct rasops_info *ri)
{
	struct cfxga_screen *scr = ri->ri_hw;
	int x, y, cx, cy;

	if (scr != scr->scr_sc->sc_active)
		return 0;

	x = ri->ri_ccol * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = ri->ri_crow * ri->ri_font->fontheight + ri->ri_yorigin;
	cx = ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;
	return cfxga_standalone_rop(scr, ROP_ONES ^ ROP_SRC /* i.e. not SRC */,
	    x, y, x, y, cx, cy);
}

int
cfxga_erasecols(void *cookie, int row, int col, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;
	int fg, bg;
	int x, y, cx, cy;

	/* Erase columns in backing store. */
	for (x = col; x < col + num; x++) {
		scr->scr_mem[row * ri->ri_cols + x].uc = 0;
		scr->scr_mem[row * ri->ri_cols + x].attr = attr;
	}

	if (scr != scr->scr_sc->sc_active)
		return 0;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	x = col * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = row * ri->ri_font->fontheight + ri->ri_yorigin;
	cx = num * ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;
	return cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
}

int
cfxga_eraserows(void *cookie, int row, int num, long attr)
{
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;
	int fg, bg;
	int x, y, cx, cy;

	/* Erase rows in backing store. */
	for (x = 0; x < ri->ri_cols; x++) {
		scr->scr_mem[row * ri->ri_cols + x].uc = 0;
		scr->scr_mem[row * ri->ri_cols + x].attr = attr;
	}
	for (y = 1; y < num; y++)
		memmove(scr->scr_mem + (row + y) * ri->ri_cols,
		    scr->scr_mem + row * ri->ri_cols,
		    ri->ri_cols * sizeof(struct wsdisplay_charcell));

	if (scr != scr->scr_sc->sc_active)
		return 0;

	ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
	x = ri->ri_xorigin;
	y = row * ri->ri_font->fontheight + ri->ri_yorigin;
	cx = ri->ri_emuwidth;
	cy = num * ri->ri_font->fontheight;
	return cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
}

int
cfxga_putchar(void *cookie, int row, int col, u_int uc, long attr)
{
	struct rasops_info *ri = cookie;
	struct cfxga_screen *scr = ri->ri_hw;
	int x, y;

	scr->scr_mem[row * ri->ri_cols + col].uc = uc;
	scr->scr_mem[row * ri->ri_cols + col].attr = attr;

	if (scr != scr->scr_sc->sc_active)
		return 0;

	x = col * ri->ri_font->fontwidth + ri->ri_xorigin;
	y = row * ri->ri_font->fontheight + ri->ri_yorigin;

	if (uc == ' ') {
		int cx, cy, fg, bg;

		ri->ri_ops.unpack_attr(cookie, attr, &fg, &bg, NULL);
		cx = ri->ri_font->fontwidth;
		cy = ri->ri_font->fontheight;
		return cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
	} else {
		return cfxga_expand_char(scr, uc, x, y, attr);
	}
}
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.27 2014/01/22 02:58:35 jsg Exp $	*/
d504 2
a505 2
	scrsize = ri->ri_rows * ri->ri_cols * sizeof(struct wsdisplay_charcell);
	scr->scr_mem = malloc(scrsize, M_DEVBUF,
d511 1
@


1.27
log
@add a missing argument to a debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.26 2013/12/06 21:03:04 deraadt Exp $	*/
d257 1
a257 1
	free(cfe, M_DEVBUF);
d508 1
a508 1
		free(scr, M_DEVBUF);
d575 2
a576 2
	free(scr->scr_mem, M_DEVBUF);
	free(scr, M_DEVBUF);
@


1.26
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.25 2013/10/21 10:36:25 miod Exp $	*/
d286 1
a286 1
		DPRINTF(("%s: function enable failed\n"));
@


1.25
log
@Add load_font and list_font accessops to all rasops-based wsdisplay drivers.
Trivial except for tga(4) and gpx(4/vax) which need a bit more care setting
up a new font.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.24 2013/10/20 20:07:30 miod Exp $	*/
d320 1
a320 1
	int ret = 0;
d326 3
a328 2
	case DVACT_POWERDOWN:
		ret = config_activate_children(self, act);
d330 1
a330 1
	return (ret);
@


1.24
log
@Use C99 named initializers for struct wsdisplay_accessops fields.
No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.23 2013/06/11 18:15:55 deraadt Exp $	*/
d117 2
d128 2
d665 24
@


1.23
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.22 2013/05/30 16:15:02 deraadt Exp $	*/
d121 6
a126 9
	cfxga_ioctl,
	cfxga_mmap,
	cfxga_alloc_screen,
	cfxga_free_screen,
	cfxga_show_screen,
	NULL,
	NULL,
	NULL,
	cfxga_burner
@


1.22
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.21 2011/07/03 15:47:17 matthew Exp $	*/
d1053 2
a1054 2
	ovbcopy(scr->scr_mem + row * ri->ri_cols + src,
	    scr->scr_mem + row * ri->ri_cols + dst,
d1076 2
a1077 2
	ovbcopy(scr->scr_mem + src * ri->ri_cols,
	    scr->scr_mem + dst * ri->ri_cols,
d1147 2
a1148 2
		ovbcopy(scr->scr_mem + row * ri->ri_cols,
		    scr->scr_mem + (row + y) * ri->ri_cols,
@


1.21
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.20 2010/08/30 20:33:18 deraadt Exp $	*/
d319 1
d325 2
d328 1
a328 1
	return (0);
@


1.20
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.19 2009/10/13 19:33:16 pirofti Exp $	*/
a320 4
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		cfxga_reset_and_repaint(sc);
		break;
@


1.19
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.18 2009/09/05 14:09:35 miod Exp $	*/
d322 2
a323 6
		if (pcmcia_function_enable(sc->sc_pf) != 0) {
			printf("%s: function enable failed\n",
			    sc->sc_dev.dv_xname);
		} else {
			cfxga_reset_and_repaint(sc);
		}
@


1.18
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.17 2008/11/22 11:35:58 deraadt Exp $	*/
d100 1
a100 1
int	cfxga_activate(struct device *, enum devact);
d316 1
a316 1
cfxga_activate(struct device *dev, enum devact act)
@


1.17
log
@com not pccom; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.16 2007/09/11 13:39:33 gilles Exp $	*/
d143 6
a148 6
void	cfxga_copycols(void *, int, int, int, int);
void	cfxga_copyrows(void *, int, int, int);
void	cfxga_do_cursor(struct rasops_info *);
void	cfxga_erasecols(void *, int, int, int, long);
void	cfxga_eraserows(void *, int, int, long);
void	cfxga_putchar(void *, int, int, u_int, long);
d1050 1
a1050 1
void
d1063 1
a1063 1
		return;
d1070 1
a1070 1
	cfxga_standalone_rop(scr, ROP_SRC, sx, y, dx, y, cx, cy);
d1073 1
a1073 1
void
d1086 1
a1086 1
		return;
d1093 1
a1093 1
	cfxga_standalone_rop(scr, ROP_SRC, x, sy, x, dy, cx, cy);
d1096 1
a1096 1
void
d1103 1
a1103 1
		return;
d1109 1
a1109 1
	cfxga_standalone_rop(scr, ROP_ONES ^ ROP_SRC /* i.e. not SRC */,
d1113 1
a1113 1
void
d1128 1
a1128 1
		return;
d1135 1
a1135 1
	cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
d1138 1
a1138 1
void
d1157 1
a1157 1
		return;
d1164 1
a1164 1
	cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
d1167 1
a1167 1
void
d1178 1
a1178 1
		return;
d1189 1
a1189 1
		cfxga_solid_fill(scr, x, y, cx, cy, ri->ri_devcmap[bg]);
d1191 1
a1191 1
		cfxga_expand_char(scr, uc, x, y, attr);
@


1.16
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.15 2007/09/09 01:00:35 fgsch Exp $	*/
d309 1
a309 1
	 * Be sure to return a value greater than pccom's if we match,
@


1.15
log
@more M_ZERO conversions; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.14 2006/11/29 19:11:17 miod Exp $	*/
d226 1
a226 1
	    M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.14
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.13 2006/11/29 19:08:22 miod Exp $	*/
d226 1
a226 1
	    M_DEVBUF, M_NOWAIT);
a231 1
	bzero(cfe, sizeof *cfe);
d443 2
a444 1
	scr = malloc(sizeof *scr, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
a446 1
	bzero(scr, sizeof *scr);
d508 2
a509 1
	scr->scr_mem = malloc(scrsize, M_DEVBUF, cold ? M_NOWAIT : M_WAITOK);
a513 1
	bzero(scr->scr_mem, scrsize);
@


1.13
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.12 2006/11/29 12:13:55 miod Exp $	*/
a132 10
 * Backing memory cells for emulation mode.
 * We could theoretically hijack 8 bits from the rasops attribute, but this
 * will not accomodate font with more than 256 characters.
 */
struct charcell {
	u_int		uc;
	u_int32_t	attr;
};

/*
d140 1
a140 1
	struct charcell *scr_mem;	/* backing memory */
d508 1
a508 1
	scrsize = ri->ri_rows * ri->ri_cols * sizeof(struct charcell);
d937 1
a937 1
	struct charcell *cell = scr->scr_mem;
d1061 1
a1061 1
	    num * sizeof(struct charcell));
d1084 1
a1084 1
	    num * ri->ri_cols * sizeof(struct charcell));
d1155 1
a1155 1
		    ri->ri_cols * sizeof(struct charcell));
@


1.12
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.11 2006/11/28 12:01:27 miod Exp $	*/
d868 1
a868 1
	rasops_unpack_attr(attr, &fg, &bg, &ul);
d962 2
a963 1
				rasops_unpack_attr(cell->attr, &fg, &bg, NULL);
d1141 1
a1141 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d1170 1
a1170 1
	rasops_unpack_attr(attr, &fg, &bg, NULL);
d1197 1
a1197 1
		rasops_unpack_attr(attr, &fg, &bg, NULL);
@


1.11
log
@Reorder cfxga initialization sequence for clarity, and minor tweaks; no
functional changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.10 2006/11/27 19:31:46 miod Exp $	*/
a406 1
#ifdef notyet
a407 1
#endif
@


1.10
log
@Support for different video modes (by playing with wsconfcfg).
8 bit modes are disabled until I find why the LUT writes are ignored,
and Zaurus-like 640x480x16 is still the default.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.8 2006/11/27 12:49:40 miod Exp $	*/
d51 1
d64 1
a64 1
#ifdef notyet
d196 1
a196 1
#ifdef notyet
d478 1
a478 1
#ifdef notyet
d693 1
a693 1
#ifdef notyet
d711 1
d718 1
d722 4
d729 1
a731 11
	cfxga_write_2(sc, CFREG_CRT_START_LOW, 0);
	cfxga_write_1(sc, CFREG_CRT_START_HIGH, 0);
	cfxga_write_1(sc, CFREG_CRT_PANNING, 0);
	cfxga_write_1(sc, CFREG_CRT_FIFO_THRESHOLD_HIGH, 0);
	cfxga_write_1(sc, CFREG_CRT_FIFO_THRESHOLD_LOW, 0);

	cfxga_write_1(sc, CFREG_CRT_CURSOR_CONTROL, CURSOR_INACTIVE);

	cfxga_write_1(sc, CFREG_POWER_CONF, POWERSAVE_MBO);
	cfxga_write_1(sc, CFREG_WATCHDOG, 0);

a737 3
	cfxga_write_2(sc, CFREG_CRTTV_PCLK, CRT_PCLK_SRC_CLKI | CRT_PCLK_DIV_1);
	cfxga_write_2(sc, CFREG_WSTATE, WSTATE_MCLK);

a761 2
	cfxga_write_1(sc, CFREG_TV_CONTROL,
	    TV_LUMINANCE_FILTER | TV_SVIDEO_OUTPUT);
d764 2
d767 4
d772 1
a772 1
#ifdef notyet
d777 6
d790 6
@


1.9
log
@Do not use a complete bitmap as a backing store for multiple screens, but
remember character cells instead; this is noticeably faster.
@
text
@d61 10
d89 1
a89 1
	struct wsscreen_descr sc_wsd;
d91 1
a91 1
	struct wsscreen_descr *sc_scrlist[1];
d147 3
a149 9

	/* parent reference */
	struct cfxga_softc *scr_sc;

	/* raster op glue */
	struct rasops_info scr_ri;

	/* backing memory */
	struct charcell *scr_mem;
d166 2
a167 2
int	cfxga_solid_fill(struct cfxga_softc *, int, int, int, int, int32_t);
int	cfxga_standalone_rop(struct cfxga_softc *, u_int,
d172 3
a174 2
#define	cfxga_clear_screen(sc) \
	cfxga_solid_fill(sc, 0, 0, 640, 480, 0)
d192 9
d353 2
d388 5
a392 1
	cfxga_reset_video(sc);
d394 6
a399 5
	strlcpy(sc->sc_wsd.name, "std", sizeof(sc->sc_wsd.name));
	sc->sc_wsd.textops = &sc->sc_ops;

	sc->sc_scrlist[0] = &sc->sc_wsd;
	sc->sc_wsl.nscreens = 1;
d406 1
d408 1
d411 7
a417 2
	    config_found(self, &waa, wsemuldisplaydevprint)) == NULL)
		cfxga_clear_screen(sc);	/* otherwise wscons will do this */
d453 1
a453 1
	u_int scrsize;
d460 31
d494 4
a497 4
	ri->ri_depth = 16;
	ri->ri_width = 640;
	ri->ri_height = 480;
	ri->ri_stride = 640 * 16 / 8;
d501 8
a508 6
	ri->ri_rnum = 5;
	ri->ri_rpos = 11;
	ri->ri_gnum = 6;
	ri->ri_gpos = 5;
	ri->ri_bnum = 5;
	ri->ri_bpos = 0;
d510 1
a510 1
	if (sc->sc_wsd.nrows == 0)
d513 1
a513 1
		rasops_init(ri, sc->sc_wsd.nrows, sc->sc_wsd.ncols);
d534 9
a542 3
	if (sc->sc_wsd.nrows == 0) {
		sc->sc_wsd.nrows = ri->ri_rows;
		sc->sc_wsd.ncols = ri->ri_cols;
d544 3
a546 3
		sc->sc_wsd.fontwidth = ri->ri_font->fontwidth;
		sc->sc_wsd.fontheight = ri->ri_font->fontheight;
		sc->sc_wsd.capabilities = ri->ri_caps;
d598 1
a607 1
		/* it's not worth using sc->sc_active->scr_ri fields... */
d609 11
a619 4
		wdf->height = 640;
		wdf->width = 480;
		wdf->depth = 16;
		wdf->cmsize = 0;
d678 1
a678 5
	cfxga_repaint_screen(scr);

	/* turn back video on as well if necessary... */
	if (old == NULL)
		cfxga_burner(sc, 1, 0);
d690 7
d712 1
a712 1
	 * Setup video mode.
d726 1
a726 1
	cfxga_write_1(sc, CFREG_CRT_PANNING, PIXEL_PANNING_MASK_15BPP);
d732 1
a732 1
	cfxga_write_1(sc, CFREG_POWER_CONF, 0);
d735 33
a767 11
	/* 640x480x72x16 specific values */
	cfxga_write_1(sc, CFREG_CRTTV_PCLK, CRT_PCLK_SRC_CLKI | CRT_PCLK_DIV_1);
	cfxga_write_1(sc, CFREG_WSTATE, WSTATE_MCLK);
	cfxga_write_1(sc, CFREG_CRT_HWIDTH, (640 / 8) - 1);
	/* HNDISP and HSTART need to be programmed at the same time */
	cfxga_write_2(sc, CFREG_CRT_HNDISP, 23 | (2 << 8));
	cfxga_write_1(sc, CFREG_CRT_HPULSE, 4);
	cfxga_write_2(sc, CFREG_CRT_VHEIGHT, 480 - 1);
	/* VNDISP and VSTART need to be programmed at the same time */
	cfxga_write_2(sc, CFREG_CRT_VNDISP, 39 | (8 << 8));
	cfxga_write_1(sc, CFREG_CRT_VPULSE, 2);
d770 16
a785 2
	cfxga_write_1(sc, CFREG_CRT_MODE, CRT_MODE_16BPP);
	cfxga_write_2(sc, CFREG_CRT_MEMORY, 640);
d799 1
a799 1
		cfxga_clear_screen(sc);
d857 1
a857 1
	pos = (y * 640 + x) * (16 / 8);
d872 2
a873 1
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET, 640);
d878 2
a879 2
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL,
	    BITBLT_ACTIVE | BITBLT_COLOR_16);
d945 1
a945 1
	cfxga_clear_screen(scr->scr_sc);
d955 1
a955 1
				rc = cfxga_solid_fill(scr->scr_sc, x, y, cx, cy,
d974 1
a974 1
cfxga_solid_fill(struct cfxga_softc *sc, int x, int y, int cx, int cy,
d977 2
d982 1
a982 1
	pos = (y * 640 + x) * (16 / 8);
d993 2
a994 1
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET, 640);
d998 2
a999 2
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL,
	    BITBLT_ACTIVE | BITBLT_COLOR_16);
d1008 1
a1008 1
cfxga_standalone_rop(struct cfxga_softc *sc, u_int rop, int sx, int sy,
d1011 2
d1017 2
a1018 2
	srcpos = (sy * 640 + sx) * (16 / 8);
	dstpos = (dy * 640 + dx) * (16 / 8);
d1034 2
a1035 1
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET, 640);
d1038 2
a1039 2
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL,
	    BITBLT_ACTIVE | BITBLT_COLOR_16);
d1072 1
a1072 1
	cfxga_standalone_rop(scr->scr_sc, ROP_SRC, sx, y, dx, y, cx, cy);
d1095 1
a1095 1
	cfxga_standalone_rop(scr->scr_sc, ROP_SRC, x, sy, x, dy, cx, cy);
d1111 1
a1111 1
	cfxga_standalone_rop(scr->scr_sc, ROP_ONES ^ ROP_SRC /* i.e. not SRC */,
d1137 1
a1137 1
	cfxga_solid_fill(scr->scr_sc, x, y, cx, cy, ri->ri_devcmap[bg]);
d1166 1
a1166 1
	cfxga_solid_fill(scr->scr_sc, x, y, cx, cy, ri->ri_devcmap[bg]);
d1191 1
a1191 1
		cfxga_solid_fill(scr->scr_sc, x, y, cx, cy, ri->ri_devcmap[bg]);
@


1.8
log
@Separate solid fill operations from regular raster ops; this also brings
us accelerated copyrows and copycols.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.7 2006/11/27 11:50:02 miod Exp $	*/
d122 10
a142 1
	struct wsdisplay_emulops scr_ops;		/* old ri_ops */
d145 1
a145 1
	u_int8_t *scr_mem;
d158 2
a159 4
int	cfxga_expand_char(struct cfxga_softc *, struct cfxga_screen *, u_int,
	    int, int, long);
int	cfxga_memory_rop(struct cfxga_softc *, struct cfxga_screen *, u_int,
	    int, int, int, int);
a169 2
#define	cfxga_repaint_screen(sc) \
	cfxga_memory_rop(sc, sc->sc_active, ROP_SRC, 0, 0, 640, 480)
d425 1
a431 8
	scr->scr_mem = malloc(640 * 480 * 16 / 8, M_DEVBUF,
	    cold ? M_NOWAIT : M_WAITOK);
	if (scr->scr_mem == NULL) {
		free(scr, M_DEVBUF);
		return (ENOMEM);
	}
	bzero(scr->scr_mem, 640 * 480 * 16 / 8);

d434 1
a434 1
	ri->ri_bits = scr->scr_mem;
d439 1
a439 1
	/* ri->ri_flg = RI_FULLCLEAR; */
d454 12
a465 1
	scr->scr_ops = ri->ri_ops;
d604 1
a604 1
	cfxga_repaint_screen(sc);
d684 1
a684 1
		cfxga_repaint_screen(sc);
d733 1
a733 2
cfxga_expand_char(struct cfxga_softc *sc, struct cfxga_screen *scr, u_int uc,
    int x, int y, long attr)
d735 1
d823 1
a823 2
cfxga_memory_rop(struct cfxga_softc *sc, struct cfxga_screen *scr, u_int rop,
    int x, int y, int cx, int cy)
d825 4
a828 2
	u_int pos, sts, fifo_avail;
	u_int16_t *data;
d831 1
a831 2
	pos = (y * 640 + x) * (16 / 8);
	data = (u_int16_t *)(scr->scr_mem + pos);
d833 2
a834 3
	/* Wait for previous operations to complete */
	if ((rc = cfxga_synchronize(sc)) != 0)
		return (rc);
d836 10
a845 40
	cfxga_write_2(sc, CFREG_BITBLT_ROP, rop | (OP_WRITE_ROP << 8));
	cfxga_write_2(sc, CFREG_BITBLT_SRC_LOW, 0);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_HIGH, 0);
	cfxga_write_2(sc, CFREG_BITBLT_DST_LOW, pos);
	cfxga_write_2(sc, CFREG_BITBLT_DST_HIGH, pos >> 16);
	cfxga_write_2(sc, CFREG_BITBLT_OFFSET, 640);
	cfxga_write_2(sc, CFREG_BITBLT_WIDTH, cx - 1);
	cfxga_write_2(sc, CFREG_BITBLT_HEIGHT, cy - 1);
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL,
	    BITBLT_ACTIVE | BITBLT_COLOR_16);

	if (cfxga_wait(sc, BITBLT_ACTIVE, BITBLT_ACTIVE) == 0)
		goto fail;	/* unlikely */
	fifo_avail = 0;
	while (cy-- != 0) {
		for (x = 0; x < cx; x++) {
			/*
			 * Find out how much words we can feed before
			 * a FIFO check is needed.
			 */
			if (fifo_avail == 0) {
				sts = cfxga_read_1(sc, CFREG_BITBLT_CONTROL);
				if ((sts & BITBLT_FIFO_NOT_EMPTY) == 0)
					fifo_avail = 16;
				else if ((sts & BITBLT_FIFO_HALF_FULL) == 0)
					fifo_avail = 8;
				else if ((sts & BITBLT_FIFO_FULL) == 0) {
					/* pessimistic but safe choice */
					fifo_avail = 1;
				} else {
					/*
					 * Let the cheap breathe for a short
					 * while. If this is not enough to
					 * free some FIFO entries,
					 * abort the operation.
					 */
					if (cfxga_wait(sc, BITBLT_FIFO_FULL,
					    0) == 0)
						goto fail;
				}
d847 3
a849 3

			cfxga_write_2(sc, CFREG_BITBLT_DATA, *data++);
			fifo_avail--;
a850 1
		data += (640 - cx);
a853 6

fail:
	DPRINTF(("%s: abort\n", __func__));
	cfxga_write_2(sc, CFREG_BITBLT_CONTROL, 0);
	cfxga_stop_memory_blt(sc);
	return (EINTR);
d939 4
a942 1
	(*scr->scr_ops.copycols)(ri, row, src, dst, num);
d962 4
a965 1
	(*scr->scr_ops.copyrows)(ri, src, dst, num);
d1003 5
a1007 1
	(*scr->scr_ops.erasecols)(ri, row, col, num, attr);
d1028 9
a1036 1
	(*scr->scr_ops.eraserows)(ri, row, num, attr);
d1056 2
a1057 1
	(*scr->scr_ops.putchar)(ri, row, col, uc, attr);
d1073 1
a1073 1
		cfxga_expand_char(scr->scr_sc, scr, uc, x, y, attr);
@


1.7
log
@Do not perform frame buffer actions on non-active screens.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.3 2006/11/26 18:51:10 miod Exp $	*/
d155 3
a157 2
int	cfxga_standalone_rop(struct cfxga_softc *, u_int, u_int,
	    int, int, int, int, int32_t);
d162 1
a162 1
	cfxga_standalone_rop(sc, OP_SOLID_FILL, 0, 0, 0, 640, 480, 0)
d886 1
a886 1
 * Perform an internal frame buffer operation.
d889 2
a890 2
cfxga_standalone_rop(struct cfxga_softc *sc, u_int op, u_int rop, int x, int y,
    int cx, int cy, int32_t srccolor)
d901 1
a901 1
	cfxga_write_2(sc, CFREG_BITBLT_ROP, rop | (op << 8));
d909 38
a946 2
	if (op == OP_SOLID_FILL)
		cfxga_write_2(sc, CFREG_BITBLT_FG, (u_int16_t)srccolor);
d966 1
a966 1
	int x, y, cx, cy;
d973 2
a974 1
	x = dst * ri->ri_font->fontwidth + ri->ri_xorigin;
d978 1
a978 1
	cfxga_memory_rop(scr->scr_sc, scr, ROP_SRC, x, y, cx, cy);
d986 1
a986 1
	int x, y, cx, cy;
d994 2
a995 1
	y = dst * ri->ri_font->fontheight + ri->ri_yorigin;
d998 1
a998 1
	cfxga_memory_rop(scr->scr_sc, scr, ROP_SRC, x, y, cx, cy);
d1014 2
a1015 3
	cfxga_standalone_rop(scr->scr_sc, OP_MOVE_POSITIVE_ROP,
	    ROP_ONES ^ ROP_SRC /* i.e. not SRC */,
	    x, y, cx, cy, /* ri->ri_devcmap[WSCOL_BLACK] */ 0);
d1036 1
a1036 2
	cfxga_standalone_rop(scr->scr_sc, OP_SOLID_FILL, 0,
	    x, y, cx, cy, ri->ri_devcmap[bg]);
d1057 1
a1057 2
	cfxga_standalone_rop(scr->scr_sc, OP_SOLID_FILL, 0,
	    x, y, cx, cy, ri->ri_devcmap[bg]);
d1081 1
a1081 2
		cfxga_standalone_rop(scr->scr_sc, OP_SOLID_FILL, 0,
		    x, y, cx, cy, ri->ri_devcmap[bg]);
@


1.6
log
@Store the wsscreen_descr structure in the softc.
@
text
@d932 4
d952 3
d968 3
d990 3
d1012 3
d1032 3
@


1.5
log
@Always update cfxga_scr emulops field when creating a new screen, in case
the card was removed and then reinserted.
XXX It's still ugly, a better way to handle this is in the works.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.4 2006/11/26 23:31:14 miod Exp $	*/
d78 6
a83 1
	struct device *sc_wsd;
a120 13
struct wsscreen_descr cfxga_scr = {
	"std"
};

const struct wsscreen_descr *cfxga_scr_descr[] = {
	&cfxga_scr
};

const struct wsscreen_list cfxga_scr_list = {
	sizeof cfxga_scr_descr / sizeof cfxga_scr_descr[0],
	cfxga_scr_descr
};

d368 7
d376 1
a376 1
	waa.scrdata = &cfxga_scr_list;
d379 1
d381 2
a382 2
	if ((sc->sc_wsd = config_found(self, &waa, wsemuldisplaydevprint)) ==
	    NULL)
d394 3
a396 3
	if (sc->sc_wsd != NULL) {
		config_detach(sc->sc_wsd, DETACH_FORCE);
		/* sc->sc_wsd = NULL; */
d450 1
a450 1
	if (cfxga_scr.nrows == 0) {
d452 2
a453 9

		cfxga_scr.nrows = ri->ri_rows;
		cfxga_scr.ncols = ri->ri_cols;
		cfxga_scr.capabilities = ri->ri_caps;
	} else {
		rasops_init(ri, cfxga_scr.nrows, cfxga_scr.ncols);
	}

	cfxga_scr.textops = &ri->ri_ops;
d462 9
@


1.4
log
@Rewrite the blitter functions, providing an accelerated putchar in the
process; and fix synchronization points, so that the card no longer gets
stuck and in need of a reset after being flooded with rop requests.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.3 2006/11/26 18:51:10 miod Exp $	*/
a455 1
		cfxga_scr.textops = &ri->ri_ops;
d459 2
@


1.3
log
@Start reworking the raster ops code, and be smarter when monitoring the FIFO
for cpuu-to-display operation. This is much faster already.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.2 2006/11/26 17:04:22 miod Exp $	*/
a141 1
	void (*scr_do_cursor)(struct rasops_info *);	/* old ri_do_cursor */
d155 4
a160 1
void	cfxga_remove_function(struct pcmcia_function *);
d164 2
a165 1
	    int, int, int, int, u_int16_t);
d186 3
a466 1
	scr->scr_do_cursor = ri->ri_do_cursor;
d607 4
a610 2
	/* reset controller */
	cfxga_write_2(sc, CFREG_REV, 0x8080);
d617 1
a617 1

d619 1
a619 1
	(void)cfxga_read_1(sc, CFREG_BITBLT_DATA);
d669 1
d676 3
d693 4
d698 1
a698 2
cfxga_memory_rop(struct cfxga_softc *sc, struct cfxga_screen *scr, u_int rop,
    int x, int y, int cx, int cy)
d700 1
a700 6
	u_int pos, sts, fifo_avail;
	u_int16_t *data;

	pos = (y * 640 + x) * (16 / 8);
	data = (u_int16_t *)(scr->scr_mem + pos);

d702 1
a702 1
		DPRINTF(("%s(%d): not ready\n", __func__, rop));
a709 1
			return (0);
d712 111
a822 1
	(void)cfxga_read_1(sc, CFREG_BITBLT_DATA);
d835 2
a836 1
	(void)cfxga_wait(sc, BITBLT_ACTIVE, BITBLT_ACTIVE);
d861 2
a862 7
					    0) == 0) {
						DPRINTF(("%s: abort\n",
						    __func__));
						cfxga_write_2(sc,
						    CFREG_BITBLT_CONTROL, 0);
						return (EINTR);
					}
d873 6
d881 3
d886 1
a886 1
    int cx, int cy, u_int16_t srccolor)
d889 1
d893 3
a895 12
	if (cfxga_wait(sc, BITBLT_ACTIVE, 0) == 0) {
		DPRINTF(("%s(%d,%d): not ready\n", __func__, op, rop));
		if (ISSET(sc->sc_state, CS_RESET))
			return (EAGAIN);
		else {
			DPRINTF(("%s: resetting...\n", sc->sc_dev.dv_xname));
			SET(sc->sc_state, CS_RESET);
			cfxga_reset_and_repaint(sc);
			CLR(sc->sc_state, CS_RESET);
			return (0);
		}
	}
d906 1
a906 1
		cfxga_write_2(sc, CFREG_BITBLT_FG, srccolor);
d914 1
a914 9
 * Text console raster operations
 *
 * For all operations, we need first to run them on the memory frame buffer
 * (by means of the rasops primitives), then decide what to send to the
 * controller.
 *
 * For now we end up sending every operation to the device. But this could
 * be improved, based on actual knowledge of what sequences of operations
 * the wscons emulations perform. This is far from trivial...
d916 3
a918 5
 * Another approach worth trying would be to use a timeout and reblt the
 * whole screen if it has changed, i.e. set a flag in all raster op routines
 * below, and have the timeout callback do a blt if the flag is set.
 * However, since a whole blt takes close to a second (or maybe more) it
 * is probably not a good idea.
d963 2
a964 1
	    ROP_ONES ^ ROP_SRC /* not SRC */, x, y, cx, cy, WSCOL_BLACK);
d972 1
a972 1
	int fg, bg, uline;
d977 1
a977 1
	rasops_unpack_attr(attr, &fg, &bg, &uline);
d983 1
a983 1
	    x, y, cx, cy, bg);
d991 1
a991 1
	int fg, bg, uline;
d996 1
a996 1
	rasops_unpack_attr(attr, &fg, &bg, &uline);
d1002 1
a1002 1
	    x, y, cx, cy, bg);
d1010 1
a1010 1
	int x, y, cx, cy;
a1015 2
	cx = ri->ri_font->fontwidth;
	cy = ri->ri_font->fontheight;
d1018 1
a1018 1
		int fg, bg, uline;
d1020 3
a1022 1
		rasops_unpack_attr(attr, &fg, &bg, &uline);
d1024 4
a1027 3
		    x, y, cx, cy, bg);
	} else
		cfxga_memory_rop(scr->scr_sc, scr, ROP_SRC, x, y, cx, cy);
@


1.2
log
@Much better register description and values. No functional change yet - but
this code does not look like a bingo game chart anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: cfxga.c,v 1.1 2006/04/16 20:45:00 miod Exp $	*/
a48 4
/* Old defines, biting the dust soon */
#define	CROP_SOLIDFILL			0x0c0c
#define	CROP_EXTCOPY			0x000c

d161 2
a162 2
int	cfxga_standalone_rop(struct cfxga_softc *, u_int, int, int, int, int,
	    u_int16_t);
d166 1
a166 1
	cfxga_standalone_rop(sc, CROP_SOLIDFILL, 0, 0, 640, 480, 0)
d168 1
a168 1
	cfxga_memory_rop(sc, sc->sc_active, CROP_EXTCOPY, 0, 0, 640, 480)
d673 1
a673 1
	for (tries = 100000; tries != 0; tries--) {
d686 1
a686 1
	u_int pos;
d693 1
a693 1
		DPRINTF(("%s: not ready\n", __func__));
d706 1
a706 7
#if 0
	cfxga_write_1(sc, CFREG_BITBLT_ROP, rop);
	cfxga_write_1(sc, CFREG_BITBLT_OPERATION, OP_WRITE_ROP);
		/* unless we prefer OP_SOLID_FILL */
#else
	cfxga_write_2(sc, CFREG_BITBLT_ROP, rop);
#endif
d718 1
a720 2
			cfxga_write_2(sc, CFREG_BITBLT_DATA, *data++);

d722 2
a723 3
			 * Let the cheap breathe.
			 * If this is not enough to let it recover,
			 * abort the operation.
d725 25
a749 4
			if (cfxga_wait(sc, BITBLT_FIFO_FULL, 0) == 0) {
				DPRINTF(("%s: abort\n", __func__));
				cfxga_write_2(sc, CFREG_BITBLT_CONTROL, 0);
				return (EINTR);
d751 3
d762 1
a762 1
cfxga_standalone_rop(struct cfxga_softc *sc, u_int rop, int x, int y,
d770 1
a770 1
		DPRINTF(("%s: not ready\n", __func__));
d782 3
a784 9
#if 0
	cfxga_write_1(sc, CFREG_BITBLT_ROP, rop);
	cfxga_write_1(sc, CFREG_BITBLT_OPERATION, OP_WRITE_ROP);
		/* unless we prefer OP_SOLID_FILL */
#else
	cfxga_write_2(sc, CFREG_BITBLT_ROP, rop);
#endif
	cfxga_write_2(sc, CFREG_BITBLT_SRC_LOW, 0);
	cfxga_write_2(sc, CFREG_BITBLT_SRC_HIGH, 0);
d790 2
a791 1
	cfxga_write_2(sc, CFREG_BITBLT_FG, srccolor);
d828 1
a828 1
	cfxga_memory_rop(scr->scr_sc, scr, CROP_EXTCOPY, x, y, cx, cy);
d844 1
a844 1
	cfxga_memory_rop(scr->scr_sc, scr, CROP_EXTCOPY, x, y, cx, cy);
d857 2
a858 6
#if 0
	cfxga_standalone_rop(scr->scr_sc, CROP_SRCXORDST, x, y, cx, cy, 0);
#else
	(*scr->scr_do_cursor)(ri);
	cfxga_memory_rop(scr->scr_sc, scr, CROP_EXTCOPY, x, y, cx, cy);
#endif
d876 2
a877 2
	cfxga_standalone_rop(scr->scr_sc, CROP_SOLIDFILL, x, y, cx, cy,
	    ri->ri_devcmap[bg]);
d895 2
a896 2
	cfxga_standalone_rop(scr->scr_sc, CROP_SOLIDFILL, x, y, cx, cy,
	    ri->ri_devcmap[bg]);
d917 2
a918 2
		cfxga_standalone_rop(scr->scr_sc, CROP_SOLIDFILL, x, y, cx, cy,
		    ri->ri_devcmap[bg]);
d920 1
a920 1
		cfxga_memory_rop(scr->scr_sc, scr, CROP_EXTCOPY, x, y, cx, cy);
@


1.1
log
@Preliminary driver for the Colorgraphic VoyagerVGA pcmcia frame buffer;
more like a proof of concept than anything useful, due to the slowness of the
beast, but deraadt@@ insists this gets in the tree.

Written with matthieu@@'s help.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
 * Copyright (c) 2005 Matthieu Herrb and Miodrag Vallat
d10 1
a10 1
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
d12 1
a12 1
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
d20 2
a21 2
 * Work-in-progress display driver for the Colorgraphic CompactFlash
 * ``VoyagerVGA'' card.
d49 7
a55 1
/* #define CFXGADEBUG */
d174 4
a177 1
#define	cfxga_read(sc, addr) \
d180 4
a183 1
#define	cfxga_write(sc, addr, val) \
d294 2
a295 1
	id = bus_space_read_1(h.memt, h.memh, ptr) & CR_ID_MASK;
d308 1
a308 1
	return (id == CR_ID ? 10 : 0);
d440 1
a440 1
	/* swap B and R */
d484 1
a484 1
	u_int16_t ven;
d486 1
a486 1
	ven = cfxga_read(sc, CFREG_VIDEO);
d489 1
a489 1
		cfxga_write(sc, CFREG_VIDEO, ven | CV_VIDEO_VGA);
d491 1
a491 1
		cfxga_write(sc, CFREG_VIDEO, ven & ~CV_VIDEO_VGA);
d607 6
a612 2
	cfxga_write(sc, CFREG_BLT_CTRL, 0);
	cfxga_write(sc, CFREG_RESET, CR_RESET);
d614 3
a616 4
	cfxga_write(sc, CFREG_RESET, 0);
	delay(25000);
	cfxga_write(sc, CFREG_BLT_CTRL, 0);
	(void)cfxga_read(sc, CFREG_BLT_DATA);
d619 1
a619 2
	 * Setup video mode - magic values taken from the linux so-called
	 * driver source.
d622 19
a640 24
	/* clock */
	cfxga_write(sc, 0x10, 2);
	cfxga_write(sc, 0x14, 0);
	cfxga_write(sc, 0x1c, 2);
	/* memory configuration */
	cfxga_write(sc, 0x20, 0x0380);
	cfxga_write(sc, 0x2a, 0x100);
	/* CRT and TV settings */
	cfxga_write(sc, 0x62, 0);
	cfxga_write(sc, 0x64, 0);
	cfxga_write(sc, 0x68, 0);
	cfxga_write(sc, 0x6a, 0);
	/* cursor */
	cfxga_write(sc, 0x80, 0);
	cfxga_write(sc, 0x82, 0x259);
	cfxga_write(sc, 0x84, 0x190);
	cfxga_write(sc, 0x86, 0);
	cfxga_write(sc, 0x88, 0);
	cfxga_write(sc, 0x8a, 0x3f1f);
	cfxga_write(sc, 0x8c, 0x1f);
	cfxga_write(sc, 0x8e, 0);
	/* unknown */
	cfxga_write(sc, 0x1f0, 0x210);
	cfxga_write(sc, 0x1f4, 0);
d643 14
a656 15
	/* gpio */
	cfxga_write(sc, 0x04, 0x07);
	cfxga_write(sc, 0x08, 0x1ffe);
	/* more clock */
	cfxga_write(sc, 0x18, 0);
	cfxga_write(sc, 0x1e, 2);
	/* more CRT and TV settings */
	cfxga_write(sc, 0x50, 0x4f);
	cfxga_write(sc, 0x52, 0x217);
	cfxga_write(sc, 0x54, 0x4);
	cfxga_write(sc, 0x56, 0x1df);
	cfxga_write(sc, 0x58, 0x827);
	cfxga_write(sc, 0x5a, 0x1202);
	cfxga_write(sc, 0x60, 5);
	cfxga_write(sc, 0x66, 640);
d658 1
a658 1
	cfxga_write(sc, CFREG_VIDEO, CV_VIDEO_VGA);
d678 1
a678 2
		if ((bus_space_read_1(sc->sc_pmemh.memt, sc->sc_pmemh.memh,
		    sc->sc_offset + CFREG_BLT_CTRL) & mask) == result)
d696 1
a696 1
	if (cfxga_wait(sc, CC_BLT_BUSY, 0) == 0) {
d708 1
a708 1
	(void)cfxga_read(sc, CFREG_BLT_DATA);
d710 16
a725 9
	cfxga_write(sc, CFREG_BLT_ROP, rop);
	cfxga_write(sc, CFREG_BLT_UNK1, 0);
	cfxga_write(sc, CFREG_BLT_UNK2, 0);
	cfxga_write(sc, CFREG_BLT_SRCLOW, pos);
	cfxga_write(sc, CFREG_BLT_SRCHIGH, pos >> 16);
	cfxga_write(sc, CFREG_BLT_STRIDE, 640);
	cfxga_write(sc, CFREG_BLT_WIDTH, cx - 1);
	cfxga_write(sc, CFREG_BLT_HEIGHT, cy - 1);
	cfxga_write(sc, CFREG_BLT_CTRL, CC_BLT_BUSY | CC_BPP_16);
d727 1
a727 1
	(void)cfxga_wait(sc, CC_BLT_BUSY, CC_BLT_BUSY);
d730 1
a730 1
			cfxga_write(sc, CFREG_BLT_DATA, *data++);
d737 1
a737 1
			if (cfxga_wait(sc, CC_FIFO_BUSY, 0) == 0) {
d739 1
a739 1
				cfxga_write(sc, CFREG_BLT_CTRL, 0);
d757 1
a757 1
	if (cfxga_wait(sc, CC_BLT_BUSY, 0) == 0) {
d770 17
a786 10
	cfxga_write(sc, CFREG_BLT_ROP, rop);
	cfxga_write(sc, CFREG_BLT_UNK1, 0);
	cfxga_write(sc, CFREG_BLT_UNK2, 0);
	cfxga_write(sc, CFREG_BLT_SRCLOW, pos);
	cfxga_write(sc, CFREG_BLT_SRCHIGH, pos >> 16);
	cfxga_write(sc, CFREG_BLT_STRIDE, 640);
	cfxga_write(sc, CFREG_BLT_WIDTH, cx - 1);
	cfxga_write(sc, CFREG_BLT_HEIGHT, cy - 1);
	cfxga_write(sc, CFREG_BLT_SRCCOLOR, srccolor);
	cfxga_write(sc, CFREG_BLT_CTRL, CC_BLT_BUSY | CC_BPP_16);
@

