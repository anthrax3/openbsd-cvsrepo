head	1.92;
access;
symbols
	OPENBSD_6_2:1.92.0.6
	OPENBSD_6_2_BASE:1.92
	OPENBSD_6_1:1.92.0.4
	OPENBSD_6_1_BASE:1.92
	OPENBSD_6_0:1.91.0.2
	OPENBSD_6_0_BASE:1.91
	OPENBSD_5_9:1.90.0.2
	OPENBSD_5_9_BASE:1.90
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.81.0.4
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.78.0.4
	OPENBSD_5_6_BASE:1.78
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.73.0.10
	OPENBSD_5_4_BASE:1.73
	OPENBSD_5_3:1.73.0.8
	OPENBSD_5_3_BASE:1.73
	OPENBSD_5_2:1.73.0.6
	OPENBSD_5_2_BASE:1.73
	OPENBSD_5_1_BASE:1.73
	OPENBSD_5_1:1.73.0.4
	OPENBSD_5_0:1.73.0.2
	OPENBSD_5_0_BASE:1.73
	OPENBSD_4_9:1.71.0.2
	OPENBSD_4_9_BASE:1.71
	OPENBSD_4_8:1.69.0.2
	OPENBSD_4_8_BASE:1.69
	OPENBSD_4_7:1.67.0.2
	OPENBSD_4_7_BASE:1.67
	OPENBSD_4_6:1.65.0.4
	OPENBSD_4_6_BASE:1.65
	OPENBSD_4_5:1.64.0.2
	OPENBSD_4_5_BASE:1.64
	OPENBSD_4_4:1.63.0.2
	OPENBSD_4_4_BASE:1.63
	OPENBSD_4_3:1.61.0.2
	OPENBSD_4_3_BASE:1.61
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55;
locks; strict;
comment	@ * @;


1.92
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.91;
commitid	VyLWTsbepAOk7VQM;

1.91
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.90;
commitid	QHiEhS9DHyE6oiIr;

1.90
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.89;
commitid	fbhqfhfdKxBcsetK;

1.89
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.88;
commitid	B0kwmVGiD5DVx4kv;

1.88
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.87;
commitid	eYnPulzvLjDImPCa;

1.87
date	2015.11.11.10.07.25;	author mpi;	state Exp;
branches;
next	1.86;
commitid	9FpLdI4B7Tx69D1N;

1.86
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.85;
commitid	SaArro4mM2Ab3ure;

1.85
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.84;
commitid	MVWrtktB46JRxFWT;

1.84
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.83;
commitid	aiRvgNOa4qke9vft;

1.83
date	2015.04.08.10.07.47;	author mpi;	state Exp;
branches;
next	1.82;
commitid	hnmA6leYzflFI0c3;

1.82
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.81;
commitid	p4LJxGKbi0BU2cG6;

1.81
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.80;
commitid	yM2VFFhpDTeFQlve;

1.80
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.79;
commitid	uzzBR7hz9ncd4O6G;

1.79
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.78;
commitid	nYggAidK85QbUFh2;

1.78
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.77;
commitid	OBNa5kfxQ2UXoiIw;

1.77
date	2014.05.04.20.09.15;	author sf;	state Exp;
branches;
next	1.76;

1.76
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.14.12.21.13;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2013.08.21.05.21.45;	author dlg;	state Exp;
branches;
next	1.73;

1.73
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.72;

1.72
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.70;

1.70
date	2010.08.27.17.08.00;	author jsg;	state Exp;
branches;
next	1.69;

1.69
date	2010.07.02.03.13.42;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2010.05.20.14.03.05;	author nicm;	state Exp;
branches;
next	1.67;

1.67
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.66;

1.66
date	2009.08.17.13.07.37;	author martynas;	state Exp;
branches;
next	1.65;

1.65
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.64;

1.64
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.63;

1.63
date	2008.07.29.10.05.38;	author thib;	state Exp;
branches;
next	1.62;

1.62
date	2008.07.27.13.02.37;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2007.10.09.20.41.22;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2007.10.09.20.37.32;	author mglocker;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.09.08.24.17;	author mglocker;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.08.22.30.16;	author mglocker;	state Exp;
branches;
next	1.57;

1.57
date	2007.10.08.22.08.12;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2007.08.28.18.34.38;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.08.14.22.33.17;	author mglocker;	state Exp;
branches;
next	1.54;

1.54
date	2007.08.14.05.12.45;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2007.08.11.21.30.30;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2007.08.11.16.22.37;	author mglocker;	state Exp;
branches;
next	1.51;

1.51
date	2007.08.10.14.31.57;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2007.08.10.10.42.03;	author mglocker;	state Exp;
branches;
next	1.49;

1.49
date	2007.08.09.21.24.02;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2007.08.09.15.10.41;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2007.08.09.14.50.06;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2007.08.09.11.33.54;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2007.08.09.09.40.01;	author mglocker;	state Exp;
branches;
next	1.44;

1.44
date	2007.08.09.08.53.22;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2007.08.07.11.44.44;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2007.08.06.22.51.18;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2007.08.06.14.21.24;	author mglocker;	state Exp;
branches;
next	1.40;

1.40
date	2007.08.05.16.04.44;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2007.08.05.14.59.58;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2007.08.05.14.53.02;	author mglocker;	state Exp;
branches;
next	1.37;

1.37
date	2007.08.05.14.00.37;	author mglocker;	state Exp;
branches;
next	1.36;

1.36
date	2007.08.05.10.05.57;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2007.08.05.09.09.15;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2007.08.05.00.24.39;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2007.08.04.12.02.36;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.03.08.27.15;	author claudio;	state Exp;
branches;
next	1.31;

1.31
date	2007.08.02.21.15.50;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2007.08.02.10.59.31;	author claudio;	state Exp;
branches;
next	1.29;

1.29
date	2007.08.01.11.30.22;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.31.23.19.40;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2007.07.31.23.00.38;	author claudio;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.31.22.01.37;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2007.07.31.14.57.58;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.31.09.34.55;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.30.21.45.31;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.08.10.09.02;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2007.07.07.21.17.26;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.30.12.08.57;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.17.20.00.30;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.17.15.11.23;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.17.10.18.28;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.16.19.45.24;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.11.09.56.13;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.09.13.14.55;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.08.22.08.21;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.04.20.29.51;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.03.21.26.41;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.03.11.04.46;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.01.23.43.32;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.28.13.51.09;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.27.15.44.27;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.13.27.53;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.26.21.16.02;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.26.11.11.54;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.25.21.32.02;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.25.18.31.01;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.25.05.33.51;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.92
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*      $OpenBSD: if_malo.c,v 1.91 2016/04/13 10:49:26 mpi Exp $ */

/*
 * Copyright (c) 2007 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/tree.h>
#include <sys/malloc.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_llc.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/pcmcia/if_malovar.h>
#include <dev/pcmcia/if_maloreg.h>

/*
 * Driver for the Marvell 88W8385 chip (Compact Flash).
 */

#ifdef CMALO_DEBUG
int cmalo_d = 1;
#define DPRINTF(l, x...)	do { if ((l) <= cmalo_d) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

int	malo_pcmcia_match(struct device *, void *, void *);
void	malo_pcmcia_attach(struct device *, struct device *, void *);
int	malo_pcmcia_detach(struct device *, int);
int	malo_pcmcia_activate(struct device *, int);
void	malo_pcmcia_wakeup(struct malo_softc *);

void	cmalo_attach(struct device *);
int	cmalo_ioctl(struct ifnet *, u_long, caddr_t);
int	cmalo_fw_alloc(struct malo_softc *);
void	cmalo_fw_free(struct malo_softc *);
int	cmalo_fw_load_helper(struct malo_softc *);
int	cmalo_fw_load_main(struct malo_softc *);
int	cmalo_init(struct ifnet *);
void	cmalo_stop(struct malo_softc *);
int	cmalo_media_change(struct ifnet *);
int	cmalo_newstate(struct ieee80211com *, enum ieee80211_state, int);
void	cmalo_detach(void *);
int	cmalo_intr(void *);
void	cmalo_intr_mask(struct malo_softc *, int);
void	cmalo_rx(struct malo_softc *);
void	cmalo_start(struct ifnet *);
void	cmalo_watchdog(struct ifnet *);
int	cmalo_tx(struct malo_softc *, struct mbuf *);
void	cmalo_tx_done(struct malo_softc *);
void	cmalo_event(struct malo_softc *);
void	cmalo_select_network(struct malo_softc *);
void	cmalo_reflect_network(struct malo_softc *);
int	cmalo_wep(struct malo_softc *);
int	cmalo_rate2bitmap(int);

void	cmalo_hexdump(void *, int);
int	cmalo_cmd_get_hwspec(struct malo_softc *);
int	cmalo_cmd_rsp_hwspec(struct malo_softc *);
int	cmalo_cmd_set_reset(struct malo_softc *);
int	cmalo_cmd_set_scan(struct malo_softc *);
int	cmalo_cmd_rsp_scan(struct malo_softc *);
int	cmalo_parse_elements(struct malo_softc *, void *, int, int);
int	cmalo_cmd_set_auth(struct malo_softc *);
int	cmalo_cmd_set_wep(struct malo_softc *, uint16_t,
	    struct ieee80211_key *);
int	cmalo_cmd_set_snmp(struct malo_softc *, uint16_t);
int	cmalo_cmd_set_radio(struct malo_softc *, uint16_t);
int	cmalo_cmd_set_channel(struct malo_softc *, uint16_t);
int	cmalo_cmd_set_txpower(struct malo_softc *, int16_t);
int	cmalo_cmd_set_antenna(struct malo_softc *, uint16_t);
int	cmalo_cmd_set_macctrl(struct malo_softc *);
int	cmalo_cmd_set_macaddr(struct malo_softc *, uint8_t *);
int	cmalo_cmd_set_assoc(struct malo_softc *);
int	cmalo_cmd_rsp_assoc(struct malo_softc *);
int	cmalo_cmd_set_80211d(struct malo_softc *);
int	cmalo_cmd_set_bgscan_config(struct malo_softc *);
int	cmalo_cmd_set_bgscan_query(struct malo_softc *);
int	cmalo_cmd_set_rate(struct malo_softc *, int);
int	cmalo_cmd_request(struct malo_softc *, uint16_t, int);
int	cmalo_cmd_response(struct malo_softc *);

/*
 * PCMCIA bus.
 */
struct malo_pcmcia_softc {
	struct malo_softc	 sc_malo;

	struct pcmcia_function	*sc_pf;
	struct pcmcia_io_handle	 sc_pcioh;
	int			 sc_io_window;
	void			*sc_ih;
};

struct cfattach malo_pcmcia_ca = {
	sizeof(struct malo_pcmcia_softc),
	malo_pcmcia_match,
	malo_pcmcia_attach,
	malo_pcmcia_detach,
	malo_pcmcia_activate
};

int
malo_pcmcia_match(struct device *parent, void *match, void *aux)
{
	struct pcmcia_attach_args *pa = aux;

	if (pa->manufacturer == PCMCIA_VENDOR_AMBICOM &&
	    pa->product == PCMCIA_PRODUCT_AMBICOM_WL54CF)
		return (1);

	return (0);
}

void
malo_pcmcia_attach(struct device *parent, struct device *self, void *aux)
{
	struct malo_pcmcia_softc *psc = (struct malo_pcmcia_softc *)self;
	struct malo_softc *sc = &psc->sc_malo;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const char *intrstr = NULL;

	psc->sc_pf = pa->pf;
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);

	/* enable card */
	pcmcia_function_init(psc->sc_pf, cfe);
	if (pcmcia_function_enable(psc->sc_pf)) {
		printf(": can't enable function\n");
		return;
	}

	/* allocate I/O space */
	if (pcmcia_io_alloc(psc->sc_pf, 0,
	    cfe->iospace[0].length, cfe->iospace[0].length, &psc->sc_pcioh)) {
		printf(": can't allocate i/o space\n");
		pcmcia_function_disable(psc->sc_pf);
		return;
	}

	/* map I/O space */
	if (pcmcia_io_map(psc->sc_pf, PCMCIA_WIDTH_IO16, 0,
	    cfe->iospace[0].length, &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
		pcmcia_function_disable(psc->sc_pf);
		return;
	}
	sc->sc_iot = psc->sc_pcioh.iot;
	sc->sc_ioh = psc->sc_pcioh.ioh;

	printf(" port 0x%lx/%ld", psc->sc_pcioh.addr, psc->sc_pcioh.size);

	/* establish interrupt */
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, cmalo_intr, sc,
	    sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf(": can't establish interrupt\n");
		return;
	}
	intrstr = pcmcia_intr_string(psc->sc_pf, psc->sc_ih);
	if (intrstr != NULL) {
		if (*intrstr != '\0')
			printf(", %s", intrstr);
	}
	printf("\n");

	config_mountroot(self, cmalo_attach);
}

int
malo_pcmcia_detach(struct device *dev, int flags)
{
	struct malo_pcmcia_softc *psc = (struct malo_pcmcia_softc *)dev;
	struct malo_softc *sc = &psc->sc_malo;

	cmalo_detach(sc);

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	return (0);
}

int
malo_pcmcia_activate(struct device *dev, int act)
{
	struct malo_pcmcia_softc *psc = (struct malo_pcmcia_softc *)dev;
	struct malo_softc *sc = &psc->sc_malo;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	switch (act) {
	case DVACT_SUSPEND:
		if ((sc->sc_flags & MALO_DEVICE_ATTACHED) &&
		    (ifp->if_flags & IFF_RUNNING))
			cmalo_stop(sc);
		if (psc->sc_ih)
			pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
		psc->sc_ih = NULL;
		pcmcia_function_disable(psc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(psc->sc_pf);
		psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    cmalo_intr, sc, sc->sc_dev.dv_xname);
		break;
	case DVACT_WAKEUP:
		malo_pcmcia_wakeup(sc);
		break;
	case DVACT_DEACTIVATE:
		if ((sc->sc_flags & MALO_DEVICE_ATTACHED) &&
		    (ifp->if_flags & IFF_RUNNING))
			cmalo_stop(sc);		/* XXX tries to touch regs */
		if (psc->sc_ih)
			pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
		psc->sc_ih = NULL;
		pcmcia_function_disable(psc->sc_pf);
		break;
	}
	return (0);
}

void
malo_pcmcia_wakeup(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;
	
	s = splnet();
	while (sc->sc_flags & MALO_BUSY)
		tsleep(&sc->sc_flags, 0, "malopwr", 0);
	sc->sc_flags |= MALO_BUSY;

	cmalo_init(ifp);

	sc->sc_flags &= ~MALO_BUSY;
	wakeup(&sc->sc_flags);
	splx(s);
}

/*
 * Driver.
 */
void
cmalo_attach(struct device *self)
{
	struct malo_softc *sc = (struct malo_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int i;

	/* disable interrupts */
	cmalo_intr_mask(sc, 0);

	/* load firmware */
	if (cmalo_fw_alloc(sc) != 0)
		return;
	if (cmalo_fw_load_helper(sc) != 0)
		return;
	if (cmalo_fw_load_main(sc) != 0)
		return;
	sc->sc_flags |= MALO_FW_LOADED;

	/* allocate command buffer */
	sc->sc_cmd = malloc(MALO_CMD_BUFFER_SIZE, M_DEVBUF, M_NOWAIT);

	/* allocate data buffer */
	sc->sc_data = malloc(MCLBYTES, M_DEVBUF, M_NOWAIT);

	/* enable interrupts */
	cmalo_intr_mask(sc, 1);

	/* we are context save here for FW commands */
	sc->sc_cmd_ctxsave = 1;

	/* get hardware specs */
	cmalo_cmd_get_hwspec(sc);

	/* setup interface */
	ifp->if_softc = sc;
	ifp->if_ioctl = cmalo_ioctl;
	ifp->if_start = cmalo_start;
	ifp->if_watchdog = cmalo_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_caps = IEEE80211_C_MONITOR | IEEE80211_C_WEP;

	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	for (i = 0; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	/* attach interface */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = cmalo_newstate;
	ieee80211_media_init(ifp, cmalo_media_change, ieee80211_media_status);

	/* second attach line */
	printf("%s: address %s\n",
	    sc->sc_dev.dv_xname, ether_sprintf(ic->ic_myaddr));

	/* device attached */
	sc->sc_flags |= MALO_DEVICE_ATTACHED;
}

int
cmalo_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_nodereq_all *na;
	struct ieee80211_nodereq *nr;
	struct ifreq *ifr;
	int i, j, s, error = 0;

	s = splnet();
	/*
	 * Prevent processes from entering this function while another
	 * process is tsleep'ing in it.
	 */
	while ((sc->sc_flags & MALO_BUSY) && error == 0)
		error = tsleep(&sc->sc_flags, PCATCH, "maloioc", 0);
	if (error != 0) {
		splx(s);
		return error;
	}
	sc->sc_flags |= MALO_BUSY;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				cmalo_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cmalo_stop(sc);
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211SCAN:
		cmalo_cmd_set_scan(sc);
		break;
	case SIOCG80211ALLNODES:
		nr = NULL;
		na = (struct ieee80211_nodereq_all *)data;

		if ((nr = malloc(sizeof(*nr), M_DEVBUF, M_WAITOK)) == NULL)
			break;

		for (na->na_nodes = i = j = 0; i < sc->sc_net_num &&
		    (na->na_size >= j + sizeof(struct ieee80211_nodereq));
		    i++) {
			bzero(nr, sizeof(*nr));

			IEEE80211_ADDR_COPY(nr->nr_macaddr,
			    sc->sc_net[i].bssid);
			IEEE80211_ADDR_COPY(nr->nr_bssid,
			    sc->sc_net[i].bssid);
			nr->nr_channel = sc->sc_net[i].channel;
			nr->nr_chan_flags = IEEE80211_CHAN_B; /* XXX */
			nr->nr_rssi = sc->sc_net[i].rssi;
			nr->nr_max_rssi = 0; /* XXX */
			nr->nr_nwid_len = strlen(sc->sc_net[i].ssid);
			bcopy(sc->sc_net[i].ssid, nr->nr_nwid,
			    nr->nr_nwid_len);
			nr->nr_intval = sc->sc_net[i].beaconintvl;
			nr->nr_capinfo = sc->sc_net[i].capinfo;
			nr->nr_flags |= IEEE80211_NODEREQ_AP;

			if (copyout(nr, (caddr_t)na->na_node + j,
			    sizeof(struct ieee80211_nodereq)))
				break;

			j += sizeof(struct ieee80211_nodereq);
			na->na_nodes++;
		}

		if (nr)
			free(nr, M_DEVBUF, 0);
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & (IFF_UP | IFF_RUNNING))
			cmalo_init(ifp);
		error = 0;
	}

	sc->sc_flags &= ~MALO_BUSY;
	wakeup(&sc->sc_flags);
	splx(s);

	return (error);
}

int
cmalo_fw_alloc(struct malo_softc *sc)
{
	const char *name_h = "malo8385-h";
	const char *name_m = "malo8385-m";
	int error;

	if (sc->sc_fw_h == NULL) {
		/* read helper firmware image */
		error = loadfirmware(name_h, &sc->sc_fw_h, &sc->sc_fw_h_size);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s\n",
			    sc->sc_dev.dv_xname, error, name_h);
			return (EIO);
		}
	}

	if (sc->sc_fw_m == NULL) {
		/* read main firmware image */
		error = loadfirmware(name_m, &sc->sc_fw_m, &sc->sc_fw_m_size);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s\n",
			    sc->sc_dev.dv_xname, error, name_m);
			return (EIO);
		}
	}

	return (0);
}

void
cmalo_fw_free(struct malo_softc *sc)
{
	if (sc->sc_fw_h != NULL) {
		free(sc->sc_fw_h, M_DEVBUF, 0);
		sc->sc_fw_h = NULL;
	}

	if (sc->sc_fw_m != NULL) {
		free(sc->sc_fw_m, M_DEVBUF, 0);
		sc->sc_fw_m = NULL;
	}
}

int
cmalo_fw_load_helper(struct malo_softc *sc)
{
	uint8_t val8;
	uint16_t bsize, *uc;
	int offset, i;

	/* verify if the card is ready for firmware download */
	val8 = MALO_READ_1(sc, MALO_REG_SCRATCH);
	if (val8 == MALO_VAL_SCRATCH_FW_LOADED)
		/* firmware already loaded */
		return (0);
	if (val8 != MALO_VAL_SCRATCH_READY) {
		/* bad register value */
		printf("%s: device not ready for FW download\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	/* download the helper firmware */
	for (offset = 0; offset < sc->sc_fw_h_size; offset += bsize) {
		if (sc->sc_fw_h_size - offset >= MALO_FW_HELPER_BSIZE)
			bsize = MALO_FW_HELPER_BSIZE;
		else
			bsize = sc->sc_fw_h_size - offset;

		/* send a block in words and confirm it */
		DPRINTF(3, "%s: download helper FW block (%d bytes, %d off)\n",
		    sc->sc_dev.dv_xname, bsize, offset);
		MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, bsize);
		uc = (uint16_t *)(sc->sc_fw_h + offset);
		for (i = 0; i < bsize / 2; i++)
			MALO_WRITE_2(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
		MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_CMD_DL_OVER);
		MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE,
		    MALO_VAL_CMD_DL_OVER);

		/* poll for an acknowledgement */
		for (i = 0; i < 50; i++) {
			if (MALO_READ_1(sc, MALO_REG_CARD_STATUS) ==
			    MALO_VAL_CMD_DL_OVER)
				break;
			delay(1000);
		}
		if (i == 50) {
			printf("%s: timeout while helper FW block download\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
	}

	/* helper firmware download done */
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, 0);
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_CMD_DL_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_CMD_DL_OVER);
	DPRINTF(1, "%s: helper FW downloaded\n", sc->sc_dev.dv_xname);

	return (0);
}

int
cmalo_fw_load_main(struct malo_softc *sc)
{
	uint16_t val16, bsize, *uc;
	int offset, i, retry = 0;

	/* verify if the helper firmware has been loaded correctly */
	for (i = 0; i < 10; i++) {
		if (MALO_READ_1(sc, MALO_REG_RBAL) == MALO_FW_HELPER_LOADED)
			break;
		delay(1000);
	}
	if (i == 10) {
		printf("%s: helper FW not loaded\n", sc->sc_dev.dv_xname);
		return (EIO);
	}
	DPRINTF(1, "%s: helper FW loaded successfully\n", sc->sc_dev.dv_xname);

	/* download the main firmware */
	bsize = 0; /* XXX really??? */
	for (offset = 0; offset < sc->sc_fw_m_size; offset += bsize) {
		val16 = MALO_READ_2(sc, MALO_REG_RBAL);
		/*
		 * If the helper firmware serves us an odd integer then
		 * something went wrong and we retry to download the last
		 * block until we receive a good integer again, or give up.
		 */
		if (val16 & 0x0001) {
			if (retry > MALO_FW_MAIN_MAXRETRY) {
				printf("%s: main FW download failed\n",
				    sc->sc_dev.dv_xname);
				return (EIO);
			}
			retry++;
			offset -= bsize;
		} else {
			retry = 0;
			bsize = val16;
		}

		/* send a block in words and confirm it */
		DPRINTF(3, "%s: download main FW block (%d bytes, %d off)\n",
		    sc->sc_dev.dv_xname, bsize, offset);
		MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, bsize);
		uc = (uint16_t *)(sc->sc_fw_m + offset);
		for (i = 0; i < bsize / 2; i++)
			MALO_WRITE_2(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
		MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_CMD_DL_OVER);
		MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE,
		    MALO_VAL_CMD_DL_OVER);

		/* poll for an acknowledgement */
		for (i = 0; i < 5000; i++) {
			if (MALO_READ_1(sc, MALO_REG_CARD_STATUS) ==
			    MALO_VAL_CMD_DL_OVER)
				break;
		}
		if (i == 5000) {
			printf("%s: timeout while main FW block download\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
	}

	DPRINTF(1, "%s: main FW downloaded\n", sc->sc_dev.dv_xname);

	/* verify if the main firmware has been loaded correctly */
	for (i = 0; i < 500; i++) {
		if (MALO_READ_1(sc, MALO_REG_SCRATCH) ==
		    MALO_VAL_SCRATCH_FW_LOADED)
			break;
		delay(1000);
	}
	if (i == 500) {
		printf("%s: main FW not loaded\n", sc->sc_dev.dv_xname);
		return (EIO);
	}

	DPRINTF(1, "%s: main FW loaded successfully\n", sc->sc_dev.dv_xname);

	return (0);
}

int
cmalo_init(struct ifnet *ifp)
{
	struct malo_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	/* reload the firmware if necessary */
	if (!(sc->sc_flags & MALO_FW_LOADED)) {
		/* disable interrupts */
		cmalo_intr_mask(sc, 0);

		/* load firmware */
		if (cmalo_fw_load_helper(sc) != 0)
			return (EIO);
		if (cmalo_fw_load_main(sc) != 0)
			return (EIO);
		sc->sc_flags |= MALO_FW_LOADED;

		/* enable interrupts */
		cmalo_intr_mask(sc, 1);
	}

	/* reset association state flag */
	sc->sc_flags &= ~MALO_ASSOC_FAILED;

	/* get current channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	sc->sc_curchan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
	DPRINTF(1, "%s: current channel is %d\n",
	    sc->sc_dev.dv_xname, sc->sc_curchan);

	/* setup device */
	if (cmalo_cmd_set_macctrl(sc) != 0)
		return (EIO);
	if (cmalo_cmd_set_txpower(sc, 15) != 0)
		return (EIO);
	if (cmalo_cmd_set_antenna(sc, 1) != 0)
		return (EIO);
	if (cmalo_cmd_set_antenna(sc, 2) != 0)
		return (EIO);
	if (cmalo_cmd_set_radio(sc, 1) != 0)
		return (EIO);
	if (cmalo_cmd_set_channel(sc, sc->sc_curchan) != 0)
		return (EIO);
	if (cmalo_cmd_set_rate(sc, ic->ic_fixed_rate) != 0)
		return (EIO);
	if (cmalo_cmd_set_snmp(sc, MALO_OID_RTSTRESH) != 0)
		return (EIO);
	if (cmalo_cmd_set_snmp(sc, MALO_OID_SHORTRETRY) != 0)
		return (EIO);
	if (cmalo_cmd_set_snmp(sc, MALO_OID_FRAGTRESH) != 0)
		return (EIO);
	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	if (cmalo_cmd_set_macaddr(sc, ic->ic_myaddr) != 0)
		return (EIO);
	if (sc->sc_ic.ic_flags & IEEE80211_F_WEPON) {
		if (cmalo_wep(sc) != 0)
			return (EIO);
	}

	/* device up */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* start network */
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	if (sc->sc_flags & MALO_ASSOC_FAILED)
		ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

	/* we are not context save anymore for FW commands */
	sc->sc_cmd_ctxsave = 0;

	return (0);
}

void
cmalo_stop(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	/* device down */
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* change device back to initial state */
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);

	/* reset device */
	cmalo_cmd_set_reset(sc);
	sc->sc_flags &= ~MALO_FW_LOADED;
	ifp->if_timer = 0;

	DPRINTF(1, "%s: device down\n", sc->sc_dev.dv_xname);
}

int
cmalo_media_change(struct ifnet *ifp)
{
	int error;

	if ((error = ieee80211_media_change(ifp) != ENETRESET))
		return (error);

	if (ifp->if_flags & (IFF_UP | IFF_RUNNING))
		cmalo_init(ifp);

	return (0);
}

int
cmalo_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct malo_softc *sc = ic->ic_if.if_softc;
	enum ieee80211_state ostate;

	ostate = ic->ic_state;

	if (ostate == nstate)
		goto out;

	switch (nstate) {
		case IEEE80211_S_INIT:
			DPRINTF(1, "%s: newstate is IEEE80211_S_INIT\n",
			    sc->sc_dev.dv_xname);
			break;
		case IEEE80211_S_SCAN:
			DPRINTF(1, "%s: newstate is IEEE80211_S_SCAN\n",
			    sc->sc_dev.dv_xname);
			cmalo_cmd_set_scan(sc);
			if (!sc->sc_net_num) {
				/* no networks found */
				DPRINTF(1, "%s: no networks found\n",
				    sc->sc_dev.dv_xname);
				break;
			}
			cmalo_select_network(sc);
			cmalo_cmd_set_auth(sc);
			cmalo_cmd_set_assoc(sc);
			break;
		case IEEE80211_S_AUTH:
			DPRINTF(1, "%s: newstate is IEEE80211_S_AUTH\n",
			    sc->sc_dev.dv_xname);
			break;
		case IEEE80211_S_ASSOC:
			DPRINTF(1, "%s: newstate is IEEE80211_S_ASSOC\n",
			    sc->sc_dev.dv_xname);
			break;
		case IEEE80211_S_RUN:
			DPRINTF(1, "%s: newstate is IEEE80211_S_RUN\n",
			    sc->sc_dev.dv_xname);
			cmalo_reflect_network(sc);
			break;
		default:
			break;
	}

out:
	return (sc->sc_newstate(ic, nstate, arg));
}

void
cmalo_detach(void *arg)
{
	struct malo_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (!(sc->sc_flags & MALO_DEVICE_ATTACHED))
		/* device was not properly attached */
		return;

	/* free command buffer */
	if (sc->sc_cmd != NULL)
		free(sc->sc_cmd, M_DEVBUF, 0);

	/* free data buffer */
	if (sc->sc_data != NULL)
		free(sc->sc_data, M_DEVBUF, 0);

	/* free firmware */
	cmalo_fw_free(sc);

	/* detach inferface */
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
}

int
cmalo_intr(void *arg)
{
	struct malo_softc *sc = arg;
	uint16_t intr = 0;

	/* read interrupt reason */
	intr = MALO_READ_2(sc, MALO_REG_HOST_INTR_CAUSE);
	if (intr == 0) {
		/* interrupt not for us */
		return (0);
	}
	if (intr == 0xffff) {
		/* card has been detached */
		return (0);
	}

	/* disable interrupts */
	cmalo_intr_mask(sc, 0);

	/* acknowledge interrupt */
	MALO_WRITE_2(sc, MALO_REG_HOST_INTR_CAUSE,
	    intr & MALO_VAL_HOST_INTR_MASK_ON);

	/* enable interrupts */
	cmalo_intr_mask(sc, 1);

	DPRINTF(2, "%s: interrupt handler called (intr = 0x%04x)\n",
	    sc->sc_dev.dv_xname, intr);

	if (intr & MALO_VAL_HOST_INTR_TX)
		/* TX frame sent */
		cmalo_tx_done(sc);
	if (intr & MALO_VAL_HOST_INTR_RX)
		/* RX frame received */
		cmalo_rx(sc);
	if (intr & MALO_VAL_HOST_INTR_CMD) {
		/* command response */
		wakeup(sc);
		if (!sc->sc_cmd_ctxsave)
			cmalo_cmd_response(sc);
	}
	if (intr & MALO_VAL_HOST_INTR_EVENT)
		/* event */
		cmalo_event(sc);

	return (1);
}

void
cmalo_intr_mask(struct malo_softc *sc, int enable)
{
	uint16_t val16;

	val16 = MALO_READ_2(sc, MALO_REG_HOST_INTR_MASK);

	DPRINTF(3, "%s: intr mask changed from 0x%04x ",
	    sc->sc_dev.dv_xname, val16);

	if (enable)
		MALO_WRITE_2(sc, MALO_REG_HOST_INTR_MASK,
		    val16 & ~MALO_VAL_HOST_INTR_MASK_ON);
	else
		MALO_WRITE_2(sc, MALO_REG_HOST_INTR_MASK,
		    val16 | MALO_VAL_HOST_INTR_MASK_ON);

	val16 = MALO_READ_2(sc, MALO_REG_HOST_INTR_MASK);

	DPRINTF(3, "to 0x%04x\n", val16);
}

void
cmalo_rx(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct malo_rx_desc *rxdesc;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	uint8_t *data;
	uint16_t psize;
	int i;

	splassert(IPL_NET);

	/* read the whole RX packet which is always 802.3 */
	psize = MALO_READ_2(sc, MALO_REG_DATA_READ_LEN);
	if (psize & 0x0001) {
		MALO_READ_MULTI_2(sc, MALO_REG_DATA_READ, sc->sc_data,
		    psize - 1);
		data = (uint8_t *)sc->sc_data;
		data[psize - 1] = MALO_READ_1(sc, MALO_REG_DATA_READ);
	} else 
		MALO_READ_MULTI_2(sc, MALO_REG_DATA_READ, sc->sc_data, psize);
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_RX_DL_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_RX_DL_OVER);

	/* access RX packet descriptor */
	rxdesc = (struct malo_rx_desc *)sc->sc_data;
	rxdesc->status = letoh16(rxdesc->status);
	rxdesc->pkglen = letoh16(rxdesc->pkglen);
	rxdesc->pkgoffset = letoh32(rxdesc->pkgoffset);

	DPRINTF(2, "RX status=%d, pkglen=%d, pkgoffset=%d\n",
	    rxdesc->status, rxdesc->pkglen, rxdesc->pkgoffset);

	if (rxdesc->status != MALO_RX_STATUS_OK)
		/* RX packet is not OK */
		return;

	/* remove the LLC / SNAP header */
	data = sc->sc_data + rxdesc->pkgoffset;
	i = (ETHER_ADDR_LEN * 2) + sizeof(struct llc);
	bcopy(data + i, data + (ETHER_ADDR_LEN * 2), rxdesc->pkglen - i);
	rxdesc->pkglen -= sizeof(struct llc);

	/* prepare mbuf */
	m = m_devget(sc->sc_data + rxdesc->pkgoffset,
	    rxdesc->pkglen, ETHER_ALIGN);
	if (m == NULL) {
		DPRINTF(1, "RX m_devget failed\n");
		ifp->if_ierrors++;
		return;
	}

	/* push the frame up to the network stack if not in monitor mode */
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		ml_enqueue(&ml, m);
		if_input(ifp, &ml);
#if NBPFILTER > 0
	} else {
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
	}

}

void
cmalo_start(struct ifnet *ifp)
{
	struct malo_softc *sc = ifp->if_softc;
	struct mbuf *m;

	/* don't transmit packets if interface is busy or down */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	IFQ_DEQUEUE(&ifp->if_snd, m);
	if (m == NULL)
		return;

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

	if (cmalo_tx(sc, m) != 0)
		ifp->if_oerrors++;
}

void
cmalo_watchdog(struct ifnet *ifp)
{
	DPRINTF(2, "watchdog timeout\n");

	/* accept TX packets again */
	ifq_clr_oactive(&ifp->if_snd);
}

int
cmalo_tx(struct malo_softc *sc, struct mbuf *m)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	struct malo_tx_desc *txdesc = sc->sc_data;
	uint8_t *data;
	uint16_t psize;

	splassert(IPL_NET);

	bzero(sc->sc_data, sizeof(*txdesc));
	psize = sizeof(*txdesc) + m->m_pkthdr.len;
	data = mtod(m, uint8_t *);

	/* prepare TX descriptor */
	txdesc->pkgoffset = htole32(sizeof(*txdesc));
	txdesc->pkglen = htole16(m->m_pkthdr.len);
	bcopy(data, txdesc->dstaddrhigh, sizeof(txdesc->dstaddrhigh));
	bcopy(data + sizeof(txdesc->dstaddrhigh), txdesc->dstaddrlow,
	    sizeof(txdesc->dstaddrlow));

	/* copy mbuf data to the buffer */
	m_copydata(m, 0, m->m_pkthdr.len, sc->sc_data + sizeof(*txdesc));
	m_freem(m);

	/* send TX packet to the device */
	MALO_WRITE_2(sc, MALO_REG_DATA_WRITE_LEN, psize);
	if (psize & 0x0001) {
		MALO_WRITE_MULTI_2(sc, MALO_REG_DATA_WRITE, sc->sc_data,
		    psize - 1);
		data = (uint8_t *)sc->sc_data;
		MALO_WRITE_1(sc, MALO_REG_DATA_WRITE, data[psize - 1]);
	} else
		MALO_WRITE_MULTI_2(sc, MALO_REG_DATA_WRITE, sc->sc_data, psize);
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_TX_DL_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_TX_DL_OVER);

	ifq_set_oactive(&ifp->if_snd);
	ifp->if_timer = 5;

	DPRINTF(2, "%s: TX status=%d, pkglen=%d, pkgoffset=%d\n",
	    sc->sc_dev.dv_xname, txdesc->status, letoh16(txdesc->pkglen),
	    sizeof(*txdesc));

	return (0);
}

void
cmalo_tx_done(struct malo_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	splassert(IPL_NET);

	DPRINTF(2, "%s: TX done\n", sc->sc_dev.dv_xname);

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;
	cmalo_start(ifp);
}

void
cmalo_event(struct malo_softc *sc)
{
	uint16_t event;

	/* read event reason */
	event = MALO_READ_2(sc, MALO_REG_CARD_STATUS);
	event &= MALO_VAL_CARD_STATUS_MASK;
	event = event >> 8;

	switch (event) {
	case MALO_EVENT_DEAUTH:
		DPRINTF(1, "%s: got deauthentication event (0x%04x)\n",
		    sc->sc_dev.dv_xname, event);
		/* try to associate again */
		cmalo_cmd_set_assoc(sc);
		break;
	case MALO_EVENT_DISASSOC:
		DPRINTF(1, "%s: got disassociation event (0x%04x)\n",
		    sc->sc_dev.dv_xname, event);
		/* try to associate again */
		cmalo_cmd_set_assoc(sc);
		break;
	default:
		DPRINTF(1, "%s: got unknown event (0x%04x)\n",
		    sc->sc_dev.dv_xname, event);
		break;
	}

	/* acknowledge event */
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_HOST_INTR_EVENT);
}

void
cmalo_select_network(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i, best_rssi;

	/* reset last selected network */
	sc->sc_net_cur = 0;

	/* get desired network */
	if (ic->ic_des_esslen) {
		for (i = 0; i < sc->sc_net_num; i++) {
			if (!strcmp(ic->ic_des_essid, sc->sc_net[i].ssid)) {
				sc->sc_net_cur = i;
				DPRINTF(1, "%s: desired network found (%s)\n",
				    sc->sc_dev.dv_xname, ic->ic_des_essid);
				return;
			}
		}
		DPRINTF(1, "%s: desired network not found in scan results "
		    "(%s)\n",
		    sc->sc_dev.dv_xname, ic->ic_des_essid);
	}

	/* get network with best signal strength */
	best_rssi = sc->sc_net[0].rssi;
	for (i = 0; i < sc->sc_net_num; i++) {
		if (best_rssi < sc->sc_net[i].rssi) {
			best_rssi = sc->sc_net[i].rssi;
			sc->sc_net_cur = i;
		}
	}
	DPRINTF(1, "%s: best network found (%s)\n",
	    sc->sc_dev.dv_xname, sc->sc_net[sc->sc_net_cur].ssid);
}

void
cmalo_reflect_network(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t chan;

	/* reflect active network to our 80211 stack */

	/* BSSID */
	IEEE80211_ADDR_COPY(ic->ic_bss->ni_bssid,
	    sc->sc_net[sc->sc_net_cur].bssid);

	/* SSID */
	ic->ic_bss->ni_esslen = strlen(sc->sc_net[sc->sc_net_cur].ssid);
	bcopy(sc->sc_net[sc->sc_net_cur].ssid, ic->ic_bss->ni_essid,
	    ic->ic_bss->ni_esslen);

	/* channel */
	chan = sc->sc_net[sc->sc_net_cur].channel;
	ic->ic_bss->ni_chan = &ic->ic_channels[chan];
}

int
cmalo_wep(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	int i;

	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		struct ieee80211_key *key = &ic->ic_nw_keys[i];

		if (!key->k_len)
			continue;

		DPRINTF(1, "%s: setting wep key for index %d\n",
		    sc->sc_dev.dv_xname, i);

		cmalo_cmd_set_wep(sc, i, key);
	}

	return (0);
}

int
cmalo_rate2bitmap(int rate)
{
	switch (rate) {
	/* CCK rates */
	case  0:	return (MALO_RATE_BITMAP_DS1);
	case  1:	return (MALO_RATE_BITMAP_DS2);
	case  2:	return (MALO_RATE_BITMAP_DS5);
	case  3:	return (MALO_RATE_BITMAP_DS11);

	/* OFDM rates */
	case  4:	return (MALO_RATE_BITMAP_OFDM6);
	case  5:	return (MALO_RATE_BITMAP_OFDM9);
	case  6:	return (MALO_RATE_BITMAP_OFDM12);
	case  7:	return (MALO_RATE_BITMAP_OFDM18);
	case  8:	return (MALO_RATE_BITMAP_OFDM24);
	case  9:	return (MALO_RATE_BITMAP_OFDM36);
	case 10:	return (MALO_RATE_BITMAP_OFDM48);
	case 11:	return (MALO_RATE_BITMAP_OFDM54);

	/* unknown rate: should not happen */
	default:	return (0);
	}
}

void
cmalo_hexdump(void *buf, int len)
{
#ifdef CMALO_DEBUG
	int i;

	if (cmalo_d >= 2) {
		for (i = 0; i < len; i++) {
			if (i % 16 == 0)
				printf("%s%5i:", i ? "\n" : "", i);
			if (i % 4 == 0)
				printf(" ");
			printf("%02x", (int)*((u_char *)buf + i));
		}
		printf("\n");
	}
#endif
}

int
cmalo_cmd_get_hwspec(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_spec *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_HWSPEC);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_spec *)(hdr + 1);

	/* set all bits for MAC address, otherwise we won't get one back */
	memset(body->macaddr, 0xff, ETHER_ADDR_LEN);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_rsp_hwspec(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_spec *body;
	int i;

	body = (struct malo_cmd_body_spec *)(hdr + 1);

	/* get our MAC address */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		ic->ic_myaddr[i] = body->macaddr[i];

	return (0);
}

int
cmalo_cmd_set_reset(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr);

	hdr->cmd = htole16(MALO_CMD_RESET);
	hdr->size = 0;
	hdr->seqnum = htole16(1);
	hdr->result = 0;

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 1) != 0)
		return (EIO);

	/* give the device some time to finish the reset */
	delay(100);

	return (0);
}

int
cmalo_cmd_set_scan(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_scan *body;
	struct malo_cmd_tlv_ssid *body_ssid;
	struct malo_cmd_tlv_chanlist *body_chanlist;
	struct malo_cmd_tlv_rates *body_rates;
	//struct malo_cmd_tlv_numprobes *body_numprobes;
	uint16_t psize;
	int i;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_SCAN);
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_scan *)(hdr + 1);

	body->bsstype = 0x03; /* any BSS */
	memset(body->bssid, 0xff, ETHER_ADDR_LEN);

	body_ssid = sc->sc_cmd + psize;
	body_ssid->type = htole16(MALO_TLV_TYPE_SSID);
	body_ssid->size = htole16(0);
	psize += (sizeof(*body_ssid) - 1);

	body_chanlist = sc->sc_cmd + psize;
	body_chanlist->type = htole16(MALO_TLV_TYPE_CHANLIST);
	body_chanlist->size = htole16(sizeof(body_chanlist->data));
	for (i = 0; i < CHANNELS; i++) {
		body_chanlist->data[i].radiotype = 0x00;
		body_chanlist->data[i].channumber = (i + 1);
		body_chanlist->data[i].scantype = 0x00; /* active */
		body_chanlist->data[i].minscantime = htole16(0);
		body_chanlist->data[i].maxscantime = htole16(100);
	}
	psize += sizeof(*body_chanlist);

	body_rates = sc->sc_cmd + psize;
	body_rates->type = htole16(MALO_TLV_TYPE_RATES);
	body_rates->size =
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates);
	psize += (sizeof(*body_rates) - 1) + letoh16(body_rates->size);
#if 0
	body_numprobes = sc->sc_cmd + psize;
	body_numprobes->type = htole16(MALO_TLV_TYPE_NUMPROBES);
	body_numprobes->size = htole16(2);
	body_numprobes->numprobes = htole16(1);
	psize += sizeof(*body_numprobes);
#endif
	hdr->size = htole16(psize - sizeof(*hdr));

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_rsp_scan(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_rsp_scan *body;
	struct malo_cmd_body_rsp_scan_set *set;
	uint16_t psize;
	int i;

	bzero(sc->sc_net, sizeof(sc->sc_net));
	psize = sizeof(*hdr) + sizeof(*body);

	body = (struct malo_cmd_body_rsp_scan *)(hdr + 1);

	body->bufsize = letoh16(body->bufsize);

	DPRINTF(1, "bufsize=%d, APs=%d\n", body->bufsize, body->numofset);
	sc->sc_net_num = body->numofset;

	/* cycle through found networks */
	for (i = 0; i < body->numofset; i++) {
		set = (struct malo_cmd_body_rsp_scan_set *)(sc->sc_cmd + psize);

		set->size = letoh16(set->size);
		set->beaconintvl = letoh16(set->beaconintvl);
		set->capinfo = letoh16(set->capinfo);

		DPRINTF(1, "size=%d, bssid=%s, rssi=%d, beaconintvl=%d, "
		    "capinfo=0x%04x\n",
		    set->size, ether_sprintf(set->bssid), set->rssi,
		    set->beaconintvl, set->capinfo);

		/* save scan results */
		bcopy(set->bssid, sc->sc_net[i].bssid, sizeof(set->bssid));
		bcopy(set->timestamp, sc->sc_net[i].timestamp,
		    sizeof(set->timestamp));
		sc->sc_net[i].rssi = set->rssi;
		sc->sc_net[i].beaconintvl = set->beaconintvl;
		sc->sc_net[i].capinfo = set->capinfo;
		cmalo_parse_elements(sc, (set + 1),
		    set->size - (sizeof(*set) - sizeof(set->size)), i);

		psize += (set->size + sizeof(set->size));
	}

	return (0);
}

int
cmalo_parse_elements(struct malo_softc *sc, void *buf, int size, int pos)
{
	uint8_t eid, len;
	int i;

	DPRINTF(2, "element_size=%d, element_pos=%d\n", size, pos);

	for (i = 0; i < size; ) {
		eid = *(uint8_t *)(buf + i);
		i++;
		len = *(uint8_t *)(buf + i);
		i++;
		DPRINTF(2, "eid=%d, len=%d, ", eid, len);

		switch (eid) {
		case IEEE80211_ELEMID_SSID:
			bcopy(buf + i, sc->sc_net[pos].ssid, len);
			DPRINTF(2, "ssid=%s\n", sc->sc_net[pos].ssid);
			break;
		case IEEE80211_ELEMID_RATES:
			bcopy(buf + i, sc->sc_net[pos].rates, len);
			DPRINTF(2, "rates\n");
			break;
		case IEEE80211_ELEMID_DSPARMS:
			sc->sc_net[pos].channel = *(uint8_t *)(buf + i);
			DPRINTF(2, "chnl=%d\n", sc->sc_net[pos].channel);
			break;
		default:
			DPRINTF(2, "unknown\n");
			break;
		}

		i += len;
	}

	return (0);
}

int
cmalo_cmd_set_auth(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_auth *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_AUTH);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_auth *)(hdr + 1);

	bcopy(sc->sc_net[sc->sc_net_cur].bssid, body->peermac, ETHER_ADDR_LEN);
	body->authtype = 0;

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_wep(struct malo_softc *sc, uint16_t index,
    struct ieee80211_key *key)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_wep *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_WEP);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_wep *)(hdr + 1);

	body->action = htole16(MALO_WEP_ACTION_TYPE_ADD);
	body->key_index = htole16(index);

	if (body->key_index == 0) {
		if (key->k_len > 5)
			body->key_type_1 = MALO_WEP_KEY_TYPE_104BIT;
		else
			body->key_type_1 = MALO_WEP_KEY_TYPE_40BIT;
		bcopy(key->k_key, body->key_value_1, key->k_len);
	}
	if (body->key_index == 1) {
		if (key->k_len > 5)
			body->key_type_2 = MALO_WEP_KEY_TYPE_104BIT;
		else
			body->key_type_2 = MALO_WEP_KEY_TYPE_40BIT;
		bcopy(key->k_key, body->key_value_2, key->k_len);
	}
	if (body->key_index == 2) {
		if (key->k_len > 5)
			body->key_type_3 = MALO_WEP_KEY_TYPE_104BIT;
		else
			body->key_type_3 = MALO_WEP_KEY_TYPE_40BIT;
		bcopy(key->k_key, body->key_value_3, key->k_len);
	}
	if (body->key_index == 3) {
		if (key->k_len > 5)
			body->key_type_4 = MALO_WEP_KEY_TYPE_104BIT;
		else
			body->key_type_4 = MALO_WEP_KEY_TYPE_40BIT;
		bcopy(key->k_key, body->key_value_4, key->k_len);
	}

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_snmp(struct malo_softc *sc, uint16_t oid)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_snmp *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_SNMP);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_snmp *)(hdr + 1);

	body->action = htole16(1);

	switch (oid) {
	case MALO_OID_RTSTRESH:
		body->oid = htole16(MALO_OID_RTSTRESH);
		body->size = htole16(2);
		*(uint16_t *)body->data = htole16(2347);
		break;
	case MALO_OID_SHORTRETRY:
		body->oid = htole16(MALO_OID_SHORTRETRY);
		body->size = htole16(2);
		*(uint16_t *)body->data = htole16(4);
		break;
	case MALO_OID_FRAGTRESH:
		body->oid = htole16(MALO_OID_FRAGTRESH);
		body->size = htole16(2);
		*(uint16_t *)body->data = htole16(2346);
		break;
	case MALO_OID_80211D:
		body->oid = htole16(MALO_OID_80211D);
		body->size = htole16(2);
		*(uint16_t *)body->data = htole16(1);
		break;
	default:
		break;
	}

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_radio(struct malo_softc *sc, uint16_t control)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_radio *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_RADIO);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_radio *)(hdr + 1);

	body->action = htole16(1);

	if (control) {
		body->control  = htole16(MALO_CMD_RADIO_ON);
		body->control |= htole16(MALO_CMD_RADIO_AUTO_P);
	}

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_channel(struct malo_softc *sc, uint16_t channel)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_channel *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_CHANNEL);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_channel *)(hdr + 1);

	body->action = htole16(1);
	body->channel = htole16(channel);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}


int
cmalo_cmd_set_txpower(struct malo_softc *sc, int16_t txpower)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_txpower *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_TXPOWER);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_txpower *)(hdr + 1);

	body->action = htole16(1);
	body->txpower = htole16(txpower);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_antenna(struct malo_softc *sc, uint16_t action)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_antenna *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_ANTENNA);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_antenna *)(hdr + 1);

	/* 1 = set RX, 2 = set TX */
	body->action = htole16(action);

	if (action == 1)
		/* set RX antenna */
		body->antenna_mode = htole16(0xffff);
	if (action == 2)
		/* set TX antenna */
		body->antenna_mode = htole16(2);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_macctrl(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_macctrl *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_MACCTRL);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_macctrl *)(hdr + 1);

	body->action  = htole16(MALO_CMD_MACCTRL_RX_ON);
	body->action |= htole16(MALO_CMD_MACCTRL_TX_ON);
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		body->action |= htole16(MALO_CMD_MACCTRL_PROMISC_ON);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_macaddr(struct malo_softc *sc, uint8_t *macaddr)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_macaddr *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_MACADDR);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_macaddr *)(hdr + 1);

	body->action = htole16(1);
	bcopy(macaddr, body->macaddr, ETHER_ADDR_LEN);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_assoc(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_assoc *body;
	struct malo_cmd_tlv_ssid *body_ssid;
	struct malo_cmd_tlv_phy *body_phy;
	struct malo_cmd_tlv_cf *body_cf;
	struct malo_cmd_tlv_rates *body_rates;
	struct malo_cmd_tlv_passeid *body_passeid;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_ASSOC);
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_assoc *)(hdr + 1);

	bcopy(sc->sc_net[sc->sc_net_cur].bssid, body->peermac, ETHER_ADDR_LEN);
	body->capinfo = htole16(sc->sc_net[sc->sc_net_cur].capinfo);
	body->listenintrv = htole16(10);

	body_ssid = sc->sc_cmd + psize;
	body_ssid->type = htole16(MALO_TLV_TYPE_SSID);
	body_ssid->size = htole16(strlen(sc->sc_net[sc->sc_net_cur].ssid));
	bcopy(sc->sc_net[sc->sc_net_cur].ssid, body_ssid->data,
	    letoh16(body_ssid->size));
	psize += (sizeof(*body_ssid) - 1) + letoh16(body_ssid->size);

	body_phy = sc->sc_cmd + psize;
	body_phy->type = htole16(MALO_TLV_TYPE_PHY);
	body_phy->size = htole16(1);
	bcopy(&sc->sc_net[sc->sc_net_cur].channel, body_phy->data, 1);
	psize += sizeof(*body_phy);

	body_cf = sc->sc_cmd + psize;
	body_cf->type = htole16(MALO_TLV_TYPE_CF);
	body_cf->size = htole16(0);
	psize += (sizeof(*body_cf) - 1);

	body_rates = sc->sc_cmd + psize;
	body_rates->type = htole16(MALO_TLV_TYPE_RATES);
	body_rates->size = htole16(strlen(sc->sc_net[sc->sc_net_cur].rates));
	bcopy(sc->sc_net[sc->sc_net_cur].rates, body_rates->data,
	    letoh16(body_rates->size));
	psize += (sizeof(*body_rates) - 1) + letoh16(body_rates->size);

	/* hack to correct FW's wrong generated rates-element-id */
	body_passeid = sc->sc_cmd + psize;
	body_passeid->type = htole16(MALO_TLV_TYPE_PASSEID);
	body_passeid->size = body_rates->size;
	bcopy(body_rates->data, body_passeid->data, letoh16(body_rates->size));
	psize += (sizeof(*body_passeid) - 1) + letoh16(body_passeid->size);

	hdr->size = htole16(psize - sizeof(*hdr));

	/* process command request */
	if (!sc->sc_cmd_ctxsave) {
		if (cmalo_cmd_request(sc, psize, 1) != 0)
			return (EIO);
		return (0);
	}
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_rsp_assoc(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_rsp_assoc *body;

	body = (struct malo_cmd_body_rsp_assoc *)(hdr + 1);

	if (body->status) {
		DPRINTF(1, "%s: association failed (status %d)\n",
		    sc->sc_dev.dv_xname, body->status);
		sc->sc_flags |= MALO_ASSOC_FAILED;
	} else
		DPRINTF(1, "%s: association successful\n",
		    sc->sc_dev.dv_xname, body->status);

	return (0);
}

int
cmalo_cmd_set_80211d(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_80211d *body;
	struct malo_cmd_tlv_80211d *body_80211d;
	uint16_t psize;
	int i;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_80211D);
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_80211d *)(hdr + 1);

	body->action = htole16(1);

	body_80211d = sc->sc_cmd + psize;
	body_80211d->type = htole16(MALO_TLV_TYPE_80211D);
	body_80211d->size = htole16(sizeof(body_80211d->data) +
	    sizeof(body_80211d->countrycode));
	bcopy("EU ", body_80211d->countrycode,
	    sizeof(body_80211d->countrycode));
	for (i = 0; i < CHANNELS; i++) {
		body_80211d->data[i].firstchannel = 1;
		body_80211d->data[i].numchannels = 12;
		body_80211d->data[i].maxtxpower = 10;
	}
	psize += sizeof(*body_80211d);

	hdr->size = htole16(psize - sizeof(*hdr));
	
	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_bgscan_config(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_bgscan_config *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_BGSCAN_CONFIG);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_bgscan_config *)(hdr + 1);

	body->action = htole16(1);
	body->enable = 1;
	body->bsstype = 0x03;
	body->chperscan = 12;
	body->scanintvl = htole32(100);
	body->maxscanres = htole16(12);

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_bgscan_query(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_bgscan_query *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_BGSCAN_QUERY);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_bgscan_query *)(hdr + 1);

	body->flush = 0;

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_set_rate(struct malo_softc *sc, int rate)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_rate *body;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_RATE);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_rate *)(hdr + 1);

	body->action = htole16(1);
	if (rate == -1) {
 		body->hwauto = htole16(1);
		body->ratebitmap = htole16(MALO_RATE_BITMAP_AUTO);
	} else {
 		body->hwauto = 0;
		body->ratebitmap = htole16(cmalo_rate2bitmap(rate));
	}

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_request(struct malo_softc *sc, uint16_t psize, int no_response)
{
	uint8_t *cmd;

	cmalo_hexdump(sc->sc_cmd, psize);

	/* send command request */
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, psize);
	if (psize & 0x0001) {
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, sc->sc_cmd,
		    psize - 1);
		cmd = (uint8_t *)sc->sc_cmd;
		MALO_WRITE_1(sc, MALO_REG_CMD_WRITE, cmd[psize - 1]);
	} else
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, sc->sc_cmd, psize);
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_CMD_DL_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_CMD_DL_OVER);

	if (no_response)
		/* we don't expect a response */
		return (0);

	/* wait for the command response */
	if (tsleep(sc, 0, "malocmd", 500)) {
		printf("%s: timeout while waiting for cmd response\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);
}

int
cmalo_cmd_response(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	uint16_t psize;
	uint8_t *cmd;
	int s;

	s = splnet();

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);

	/* read the whole command response */
	psize = MALO_READ_2(sc, MALO_REG_CMD_READ_LEN);
	if (psize & 0x0001) {
		MALO_READ_MULTI_2(sc, MALO_REG_CMD_READ, sc->sc_cmd,
		    psize - 1);
		cmd = (uint8_t *)sc->sc_cmd;
		cmd[psize - 1] = MALO_READ_1(sc, MALO_REG_CMD_READ);
	} else
		MALO_READ_MULTI_2(sc, MALO_REG_CMD_READ, sc->sc_cmd, psize);

	cmalo_hexdump(sc->sc_cmd, psize);

	/*
	 * We convert the header values into the machines correct endianess,
	 * so we don't have to letoh16() all over the code.  The body is
	 * kept in the cards order, little endian.  We need to take care
	 * about the body endianess in the corresponding response routines.
	 */
	hdr->cmd = letoh16(hdr->cmd);
	hdr->size = letoh16(hdr->size);
	hdr->seqnum = letoh16(hdr->seqnum);
	hdr->result = letoh16(hdr->result);

	/* check for a valid command response */
	if (!(hdr->cmd & MALO_CMD_RESP)) {
		printf("%s: got invalid command response (0x%04x)\n",
		    sc->sc_dev.dv_xname, hdr->cmd);
		splx(s);
		return (EIO);
	}
	hdr->cmd &= ~MALO_CMD_RESP;

	/* association cmd response is special */
	if (hdr->cmd == 0x0012)
		hdr->cmd = MALO_CMD_ASSOC;

	/* to which command does the response belong */
	switch (hdr->cmd) {
	case MALO_CMD_HWSPEC:
		DPRINTF(1, "%s: got hwspec cmd response\n",
		    sc->sc_dev.dv_xname);
		cmalo_cmd_rsp_hwspec(sc);
		break;
	case MALO_CMD_RESET:
		/* reset will not send back a response */
		break;
	case MALO_CMD_SCAN:
		DPRINTF(1, "%s: got scan cmd response\n",
		    sc->sc_dev.dv_xname);
		cmalo_cmd_rsp_scan(sc);
		break;
	case MALO_CMD_AUTH:
		/* do nothing */
		DPRINTF(1, "%s: got auth cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_WEP:
		/* do nothing */
		DPRINTF(1, "%s: got wep cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_SNMP:
		/* do nothing */
		DPRINTF(1, "%s: got snmp cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_RADIO:
		/* do nothing */
		DPRINTF(1, "%s: got radio cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_CHANNEL:
		/* do nothing */
		DPRINTF(1, "%s: got channel cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_TXPOWER:
		/* do nothing */
		DPRINTF(1, "%s: got txpower cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_ANTENNA:
		/* do nothing */
		DPRINTF(1, "%s: got antenna cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_MACCTRL:
		/* do nothing */
		DPRINTF(1, "%s: got macctrl cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_MACADDR:
		/* do nothing */
		DPRINTF(1, "%s: got macaddr cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_ASSOC:
		/* do nothing */
		DPRINTF(1, "%s: got assoc cmd response\n",
		    sc->sc_dev.dv_xname);
		cmalo_cmd_rsp_assoc(sc);
		break;
	case MALO_CMD_80211D:
		/* do nothing */
		DPRINTF(1, "%s: got 80211d cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_BGSCAN_CONFIG:
		/* do nothing */
		DPRINTF(1, "%s: got bgscan config cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_BGSCAN_QUERY:
		/* do nothing */
		DPRINTF(1, "%s: got bgscan query cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_RATE:
		/* do nothing */
		DPRINTF(1, "%s: got rate cmd response\n",
		    sc->sc_dev.dv_xname);
		break;
	default:
		printf("%s: got unknown cmd response (0x%04x)\n",
		    sc->sc_dev.dv_xname, hdr->cmd);
		break;
	}

	splx(s);

	return (0);
}
@


1.91
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.90 2015/12/11 16:07:02 mpi Exp $ */
a1068 1
	ifp->if_opackets++;
@


1.90
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.89 2015/11/25 03:09:59 dlg Exp $ */
a328 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.89
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.88 2015/11/20 03:35:23 dlg Exp $ */
d73 1
a73 1
void	cmalo_attach(void *);
d209 1
a209 5
	/* attach device */
	if (rootvp == NULL)
		mountroothook_establish(cmalo_attach, sc);
	else
		cmalo_attach(sc);
d288 1
a288 1
cmalo_attach(void *arg)
d290 1
a290 1
	struct malo_softc *sc = arg;
@


1.88
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.87 2015/11/11 10:07:25 mpi Exp $ */
d719 1
a719 1
	ifp->if_flags &= ~IFF_OACTIVE;
d742 2
a743 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d993 1
a993 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1015 1
a1015 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1055 1
a1055 1
	ifp->if_flags |= IFF_OACTIVE;
d1075 1
a1075 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.87
log
@Kill useless IFQ_POLL().

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.86 2015/10/25 13:13:06 mpi Exp $ */
a997 1

@


1.86
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.85 2015/06/24 09:40:54 mpi Exp $ */
d995 1
a995 1
	IFQ_POLL(&ifp->if_snd, m);
a998 1
	IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.85
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.84 2015/04/13 08:45:48 mpi Exp $ */
a372 1
	struct ifaddr *ifa;
a390 1
		ifa = (struct ifaddr *)data;
a391 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.84
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.83 2015/04/08 10:07:47 mpi Exp $ */
a977 1
		ifp->if_ipackets++;
@


1.83
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.82 2015/03/14 03:38:49 jsg Exp $ */
d969 1
a969 1
	    rxdesc->pkglen, ETHER_ALIGN, ifp);
@


1.82
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.81 2014/12/22 02:28:52 tedu Exp $ */
d928 1
a975 5
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

a977 1
		ether_input_mbuf(ifp, m);
d979 7
d987 1
@


1.81
log
@unifdef INET
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.80 2014/09/14 14:17:25 jsg Exp $ */
a49 1
#include <dev/pcmcia/pcmciareg.h>
@


1.80
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.79 2014/08/11 12:45:45 mpi Exp $ */
a394 1
#ifdef INET
a396 1
#endif
@


1.79
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.78 2014/07/12 18:48:52 tedu Exp $ */
a21 1
#include <sys/proc.h>
@


1.78
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.77 2014/05/04 20:09:15 sf Exp $ */
a42 1
#include <netinet/in_systm.h>
@


1.77
log
@format string fixes for bus_addr_t and bus_size_t

bus_addr_t and bus_size_t are u_long everywhere

ok kettenis@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.76 2013/12/06 21:03:04 deraadt Exp $ */
d459 1
a459 1
			free(nr, M_DEVBUF);
d513 1
a513 1
		free(sc->sc_fw_h, M_DEVBUF);
d518 1
a518 1
		free(sc->sc_fw_m, M_DEVBUF);
d842 1
a842 1
		free(sc->sc_cmd, M_DEVBUF);
d846 1
a846 1
		free(sc->sc_data, M_DEVBUF);
@


1.76
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.75 2013/11/14 12:21:13 dlg Exp $ */
d196 1
a196 1
	printf(" port 0x%x/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.75
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.74 2013/08/21 05:21:45 dlg Exp $ */
a31 1
#include <sys/task.h>
d74 1
a74 1
void	malo_pcmcia_resume(void *, void *);
d255 3
a257 1
		task_add(systq, &sc->sc_resume_t);
d273 1
a273 1
malo_pcmcia_resume(void *arg1, void *arg2)
a274 1
	struct malo_softc *sc = arg1;
a303 2

	task_set(&sc->sc_resume_t, malo_pcmcia_resume, sc, NULL);
@


1.74
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.73 2011/07/03 15:47:17 matthew Exp $ */
d32 1
a32 1
#include <sys/workq.h>
d256 1
a256 2
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    malo_pcmcia_resume, sc, NULL);
d304 2
@


1.73
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.72 2011/04/07 15:30:16 miod Exp $ */
d974 1
a974 1
	    rxdesc->pkglen, ETHER_ALIGN, ifp, NULL);
@


1.72
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.71 2010/08/30 20:33:18 deraadt Exp $ */
a242 7
	case DVACT_ACTIVATE:
		pcmcia_function_enable(psc->sc_pf);
		psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    cmalo_intr, sc, sc->sc_dev.dv_xname);
		workq_queue_task(NULL, &sc->sc_resume_wqt, 0,
		    malo_pcmcia_resume, sc, NULL);
		break;
@


1.71
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.70 2010/08/27 17:08:00 jsg Exp $ */
d208 1
a208 1
		if (*intrstr != NULL)
@


1.70
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.69 2010/07/02 03:13:42 tedu Exp $ */
d32 1
d75 1
a240 1
	int s;
a241 1
	s = splnet();
d247 18
a264 1
		cmalo_init(ifp);
d267 4
a270 4
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			cmalo_stop(sc);
		if (psc->sc_ih != NULL)
d272 1
d276 20
a296 2

	return (0);
d389 11
d480 2
d639 1
a639 1
                MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE,
d700 2
a701 2
        ic->ic_bss->ni_chan = ic->ic_ibss_chan;
        sc->sc_curchan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
d756 1
a756 1
        struct ifnet *ifp = &ic->ic_if;
d767 1
@


1.69
log
@fix a variety of uninit errors.  ok and one correction deraadt
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.68 2010/05/20 14:03:05 nicm Exp $ */
a303 1
	ifp->if_init = cmalo_init;
@


1.68
log
@Split some copies of two struct members together into two bcopy rather
than one to make gcc4 -Wbounded happy.

ok krw
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.67 2009/10/13 19:33:16 pirofti Exp $ */
d562 1
@


1.67
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.66 2009/08/17 13:07:37 martynas Exp $ */
d1001 3
a1003 1
	bcopy(data, txdesc->dstaddrhigh, ETHER_ADDR_LEN);
@


1.66
log
@initialize retry to zero;  otherwise if firmware sends odd val16
from the very beginning;  we might never retry.  ok mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.65 2009/03/29 21:53:53 sthen Exp $ */
d73 1
a73 1
int	malo_pcmcia_activate(struct device *, enum devact);
d233 1
a233 1
malo_pcmcia_activate(struct device *dev, enum devact act)
@


1.65
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.64 2008/10/14 18:01:53 naddy Exp $ */
d547 1
a547 1
	int offset, i, retry;
@


1.64
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.63 2008/07/29 10:05:38 thib Exp $ */
d172 1
a172 1
		printf(": can't enable function!\n");
d179 1
a179 1
		printf(": can't allocate i/o space!\n");
d187 1
a187 1
		printf(": can't map i/o space!\n");
d201 1
a201 1
		printf(": can't establish interrupt!\n");
d497 1
a497 1
		printf("%s: device not ready for FW download!\n",
d528 1
a528 1
			printf("%s: timeout while helper FW block download!\n",
d556 1
a556 1
		printf("%s: helper FW not loaded!\n", sc->sc_dev.dv_xname);
d571 1
a571 1
				printf("%s: main FW download failed!\n",
d600 1
a600 1
			printf("%s: timeout while main FW block download!\n",
d616 1
a616 1
		printf("%s: main FW not loaded!\n", sc->sc_dev.dv_xname);
d758 1
a758 1
				DPRINTF(1, "%s: no networks found!\n",
d933 1
a933 1
		DPRINTF(1, "RX m_devget failed!\n");
d1097 1
a1097 1
		    "(%s)!\n",
d1836 1
a1836 1
		DPRINTF(1, "%s: association failed (status %d)!\n",
d2011 1
a2011 1
		printf("%s: timeout while waiting for cmd response!\n",
d2056 1
a2056 1
		printf("%s: got invalid command response (0x%04x)!\n",
d2154 1
a2154 1
		printf("%s: got unknown cmd response (0x%04x)!\n",
@


1.63
log
@check for m_devget() returning NULL, increment ierror count
and just return;

OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.62 2008/07/27 13:02:37 mglocker Exp $ */
d930 2
a931 2
	m = m_devget(sc->sc_data + rxdesc->pkgoffset - ETHER_ALIGN,
	    rxdesc->pkglen + ETHER_ALIGN, 0, ifp, NULL);
a936 1
	m_adj(m, ETHER_ALIGN);
@


1.62
log
@Some devices take longer to load the firmware.  Increase the firmware
load timeout from 50000us to 500000us.

Reported and tested by William Dunand with an I-O DATA WN-G54/CF device.
Since this device works now, we add it to the man page.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.61 2007/10/09 20:41:22 mglocker Exp $ */
d932 5
@


1.61
log
@Ops, forgot debug printf.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.60 2007/10/09 20:37:32 mglocker Exp $ */
d609 1
a609 1
	for (i = 0; i < 50; i++) {
d615 1
a615 1
	if (i == 50) {
@


1.60
log
@Setup channels with OFDM flags.  Permit user to set fix rates.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.59 2007/10/09 08:24:17 mglocker Exp $ */
a1970 2

	printf("rate=0x%04x\n", body->ratebitmap);
@


1.59
log
@Load the firmware files just one time per device lifecycle (attach time)
instead on every `ifconfig up'.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.58 2007/10/08 22:30:16 mglocker Exp $ */
d97 1
d121 1
a121 1
int	cmalo_cmd_set_rate(struct malo_softc *);
d322 2
a323 2
		    IEEE80211_CHAN_B |
		    IEEE80211_CHAN_G;
d669 1
a669 1
	if (cmalo_cmd_set_rate(sc) != 0)
d1152 25
d1948 1
a1948 1
cmalo_cmd_set_rate(struct malo_softc *sc)
d1964 9
a1972 2
	body->hwauto = htole16(1);
	body->ratebitmap = htole16(0x1fff);
@


1.58
log
@Give the device a bit time to finish the reset when stopped.  Avoids
helper firmware load timeouts when device is brought up very fast again,
like seen with trunk(4).
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.57 2007/10/08 22:08:12 mglocker Exp $ */
d77 2
d277 2
d439 44
d485 1
a485 3
	const char *name = "malo8385-h";
	size_t usize;
	uint8_t val8, *ucode;
d487 1
a487 1
	int error, offset, i;
a500 7
	/* read helper firmware image */
	if ((error = loadfirmware(name, &ucode, &usize)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}

d502 2
a503 2
	for (offset = 0; offset < usize; offset += bsize) {
		if (usize - offset >= MALO_FW_HELPER_BSIZE)
d506 1
a506 1
			bsize = usize - offset;
d512 1
a512 1
		uc = (uint16_t *)(ucode + offset);
a528 1
			free(ucode, M_DEVBUF);
a531 1
	free(ucode, M_DEVBUF);
a544 3
	const char *name = "malo8385-m";
	size_t usize;
	uint8_t *ucode;
d546 1
a546 8
	int error, offset, i, retry;

	/* read main firmware image */
	if ((error = loadfirmware(name, &ucode, &usize)) != 0) {
		printf("%s: error %d, could not read firmware %s\n",
		    sc->sc_dev.dv_xname, error, name);
		return (EIO);
	}
a555 1
		free(ucode, M_DEVBUF);
d561 1
a561 1
	for (offset = 0; offset < usize; offset += bsize) {
a571 1
				free(ucode, M_DEVBUF);
d585 1
a585 1
		uc = (uint16_t *)(ucode + offset);
a600 1
			free(ucode, M_DEVBUF);
a603 1
	free(ucode, M_DEVBUF);
d804 3
@


1.57
log
@Make pcmcia malo(4) work with trunk(4) by:
Setting interface ethernet address from link level address.
Adding firmware command to set ethernet address.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.56 2007/08/28 18:34:38 deraadt Exp $ */
d1207 3
@


1.56
log
@unify firmware load failure messages; ok mglocker
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.55 2007/08/14 22:33:17 mglocker Exp $ */
d38 1
d112 1
d653 3
d1667 29
d2056 5
@


1.55
log
@Indention and comment.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.54 2007/08/14 05:12:45 mglocker Exp $ */
d455 2
a456 2
		printf("%s: can't read microcode %s (error %d)!\n",
		    sc->sc_dev.dv_xname, name, error);
d514 2
a515 2
		printf("%s: can't read microcode %s (error %d)!\n",
		    sc->sc_dev.dv_xname, name, error);
@


1.54
log
@Replace bus_space_write/read_2 loops in cmd req/rsp routines with
bus_space_write/read_raw_multi_2.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.53 2007/08/11 21:30:30 mglocker Exp $ */
d59 1
a59 1
 * Driver for the Marvell 88W8385 CF chip.
d134 4
a137 4
	    malo_pcmcia_match,
	    malo_pcmcia_attach,
	    malo_pcmcia_detach,
	    malo_pcmcia_activate
@


1.53
log
@Set command context save flag already in attach routine.  Avoids double
processing of command responses.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.52 2007/08/11 16:22:37 mglocker Exp $ */
d1891 1
a1891 2
	uint16_t *uc;
	int i;
d1897 7
a1903 5
	uc = (uint16_t *)sc->sc_cmd;
	for (i = 0; i < psize / 2; i++)
		MALO_WRITE_2(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
	if (psize & 0x0001)
		MALO_WRITE_1(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
d1925 3
a1927 2
	uint16_t psize, *uc;
	int i, s;
d1935 7
a1941 3
	uc = (uint16_t *)sc->sc_cmd;
	for (i = 0; i < psize / 2; i++)
		uc[i] = htole16(MALO_READ_2(sc, MALO_REG_CMD_READ));
@


1.52
log
@Remove IBSS capability flag for now.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.51 2007/08/10 14:31:57 mglocker Exp $ */
d288 3
a628 3

	/* we are context save here for FW commands */
	sc->sc_cmd_ctxsave = 1;
@


1.51
log
@Fix some letho16() tweaks which made my macppc crash on an
assoiciation.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.50 2007/08/10 10:42:03 mglocker Exp $ */
d303 1
a303 4
	ic->ic_caps =
	    IEEE80211_C_MONITOR |
	    IEEE80211_C_IBSS |
	    IEEE80211_C_WEP;
@


1.50
log
@Add missing multicast part to ioctl.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.49 2007/08/09 21:24:02 mglocker Exp $ */
d1692 1
a1692 1
	    body_ssid->size);
d1710 1
a1710 1
	    body_rates->size);
d1717 1
a1717 1
	bcopy(body_rates->data, body_passeid->data, body_rates->size);
@


1.49
log
@If an association has failed, set the device back to INIT state.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.48 2007/08/09 15:10:41 mglocker Exp $ */
d343 1
d365 9
@


1.48
log
@Check all FW commands in the init path.  None of them shall timeout,
otherwise we abort initialization.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.47 2007/08/09 14:50:06 mglocker Exp $ */
d611 3
a616 1

d653 1
d656 4
a659 2

	ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
d1738 4
a1741 1
	}
@


1.47
log
@o Add a mechanism to execute single commands even if are are not context
  save.  Protects cmalo_cmd_set_assoc() for now.
o In case of deauthentication or disassociation, try to reassociate.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.46 2007/08/09 11:33:54 mglocker Exp $ */
d634 8
a645 6

	cmalo_cmd_set_rate(sc);

	cmalo_cmd_set_snmp(sc, MALO_OID_RTSTRESH);
	cmalo_cmd_set_snmp(sc, MALO_OID_SHORTRETRY);
	cmalo_cmd_set_snmp(sc, MALO_OID_FRAGTRESH);
@


1.46
log
@Correctly acknowledge event interrupts.  Got the wrong register value
before.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.45 2007/08/09 09:40:01 mglocker Exp $ */
d618 3
d654 3
d804 1
a804 1
	if (intr & MALO_VAL_HOST_INTR_CMD)
d807 3
d1005 7
a1011 1
	case MALO_EVENT_DISSASOC:
d1014 2
d1706 5
@


1.45
log
@Comment.  Sort some register values.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.44 2007/08/09 08:53:22 mglocker Exp $ */
d1007 1
a1007 1
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_CMD_DL_OVER);
@


1.44
log
@Add event handler.  Events notify us about things like when a
disassociation frame has arrived.

Nice side effect;  As we acknowledge the event reason after receiving
a disassociation frame (which happens pretty often by wi(4) hostap) now,
the FW issues an automatic reassociation, and we do not loose network
connectivity anymore.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.43 2007/08/07 11:44:44 mglocker Exp $ */
d1006 1
a1006 1
	/* clear event */
@


1.43
log
@Improve a evil tsleep() loop by using wakeup() in the interrupt handler.
Still not sure if the tsleep() is safe here, but better than the
previous version.

spotted and OK claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.42 2007/08/06 22:51:18 mglocker Exp $ */
d90 1
d801 3
d983 25
@


1.42
log
@o Replace bus_space_write_2 for-loops in TX/RX with
  bus_space_write_raw_multi_2.
o Make TX/RX work on big endian archs (tested on macppc).

in co-operation and OK claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.41 2007/08/06 14:21:24 mglocker Exp $ */
d799 1
a799 1
		sc->sc_cmd_running = 0;
d1843 1
a1843 7
	sc->sc_cmd_running = 1;
	for (i = 0; i < 1000; i++) {
		if (sc->sc_cmd_running == 0)
			break;
		tsleep(sc, 0, "malocmd", 1);
	}
	if (sc->sc_cmd_running) {
@


1.41
log
@Fix FW command API for big endian archs.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.40 2007/08/05 16:04:44 mglocker Exp $ */
d834 1
a834 1
	uint16_t psize, *uc;
d841 7
a847 5
	uc = (uint16_t *)sc->sc_data;
	for (i = 0; i < psize / 2; i++)
		uc[i] = htole16(MALO_READ_2(sc, MALO_REG_DATA_READ));
	if (psize & 0x0001)
		uc[i] = MALO_READ_1(sc, MALO_REG_DATA_READ);
d927 1
a927 2
	uint16_t psize, *uc;
	int i;
d946 7
a952 5
	uc = (uint16_t *)sc->sc_data;
	for (i = 0; i < psize / 2; i++)
		MALO_WRITE_2(sc, MALO_REG_DATA_WRITE, uc[i]);
	if (psize & 0x0001)
		MALO_WRITE_1(sc, MALO_REG_DATA_WRITE, uc[i]);
@


1.40
log
@Fix DPRINTF tweaks.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.39 2007/08/05 14:59:58 mglocker Exp $ */
d394 4
a397 2
			bcopy(nr, (caddr_t)na->na_node + j,
			    sizeof(struct ieee80211_nodereq));
d1018 1
a1018 1
	uint32_t chan;
d1032 1
a1032 1
	chan = letoh32(sc->sc_net[sc->sc_net_cur].channel);
d1190 1
a1190 1
	psize += (sizeof(*body_rates) - 1) + body_rates->size;
d1224 2
d1233 4
d1627 1
a1627 1
	psize += (sizeof(*body_ssid) - 1) + body_ssid->size;
d1645 1
a1645 1
	psize += (sizeof(*body_rates) - 1) + body_rates->size;
d1652 1
a1652 1
	psize += (sizeof(*body_passeid) - 1) + body_passeid->size;
@


1.39
log
@Low-Noise watchdog routine (debug level 2).
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.38 2007/08/05 14:53:02 mglocker Exp $ */
d911 1
a911 3
	struct malo_softc *sc = ifp->if_softc;

	DPRINTF(2, "%s: watchdog timeout\n", sc->sc_dev.dv_xname);
@


1.38
log
@Parse association command response to check if an association was
successfull or not.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.37 2007/08/05 14:00:37 mglocker Exp $ */
d913 1
a913 1
	DPRINTF(1, "%s: watchdog timeout\n", sc->sc_dev.dv_xname);
@


1.37
log
@Remove IFQ_SET_MAXLEN() for TX queue.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.36 2007/08/05 10:05:57 mglocker Exp $ */
d111 1
d1661 16
d1951 1
@


1.36
log
@Add WEP support, which is done fully by the FW.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.35 2007/08/05 09:09:15 mglocker Exp $ */
a296 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.35
log
@o Some better variable namings.
o Fix some comments.
o Add a forgotten splx().
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.34 2007/08/05 00:24:39 mglocker Exp $ */
d92 1
d102 2
d628 4
d1036 21
d1321 59
d1894 5
@


1.34
log
@o Reflect active network settings to ifconfig.
o Enable selection of desired network by setting nwid.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.33 2007/08/04 12:02:36 mglocker Exp $ */
a255 1

d371 1
a371 1
		for (na->na_nodes = i = j = 0; i < sc->sc_aps_num &&
d377 1
a377 1
			    sc->sc_aps[i].bssid);
d379 2
a380 2
			    sc->sc_aps[i].bssid);
			nr->nr_channel = sc->sc_aps[i].channel;
d382 1
a382 1
			nr->nr_rssi = sc->sc_aps[i].rssi;
d384 2
a385 2
			nr->nr_nwid_len = strlen(sc->sc_aps[i].ssid);
			bcopy(sc->sc_aps[i].ssid, nr->nr_nwid,
d387 2
a388 2
			nr->nr_intval = sc->sc_aps[i].beaconintvl;
			nr->nr_capinfo = sc->sc_aps[i].capinfo;
d697 1
a697 1
			if (!sc->sc_aps_num) {
d978 1
a978 1
	sc->sc_aps_best = 0;
d982 3
a984 3
		for (i = 0; i < sc->sc_aps_num; i++) {
			if (!strcmp(ic->ic_des_essid, sc->sc_aps[i].ssid)) {
				sc->sc_aps_best = i;
d996 5
a1000 5
	best_rssi = sc->sc_aps[0].rssi;
	for (i = 0; i < sc->sc_aps_num; i++) {
		if (best_rssi < sc->sc_aps[i].rssi) {
			best_rssi = sc->sc_aps[i].rssi;
			sc->sc_aps_best = i;
d1004 1
a1004 1
	    sc->sc_dev.dv_xname, sc->sc_aps[sc->sc_aps_best].ssid);
d1017 1
a1017 1
	    sc->sc_aps[sc->sc_aps_best].bssid);
d1020 2
a1021 2
	ic->ic_bss->ni_esslen = strlen(sc->sc_aps[sc->sc_aps_best].ssid);
	bcopy(sc->sc_aps[sc->sc_aps_best].ssid, ic->ic_bss->ni_essid,
d1025 1
a1025 1
	chan = letoh32(sc->sc_aps[sc->sc_aps_best].channel);
d1191 1
a1191 1
	bzero(sc->sc_aps, sizeof(sc->sc_aps));
d1197 1
a1197 1
	sc->sc_aps_num = body->numofset;
d1209 2
a1210 2
		bcopy(set->bssid, sc->sc_aps[i].bssid, sizeof(set->bssid));
		bcopy(set->timestamp, sc->sc_aps[i].timestamp,
d1212 3
a1214 3
		sc->sc_aps[i].rssi = set->rssi;
		sc->sc_aps[i].beaconintvl = set->beaconintvl;
		sc->sc_aps[i].capinfo = set->capinfo;
d1241 2
a1242 2
			bcopy(buf + i, sc->sc_aps[pos].ssid, len);
			DPRINTF(2, "ssid=%s\n", sc->sc_aps[pos].ssid);
d1245 1
a1245 1
			bcopy(buf + i, sc->sc_aps[pos].rates, len);
d1249 2
a1250 2
			sc->sc_aps[pos].channel = *(uint8_t *)(buf + i);
			DPRINTF(2, "chnl=%d\n", sc->sc_aps[pos].channel);
d1279 1
a1279 1
	bcopy(sc->sc_aps[sc->sc_aps_best].bssid, body->peermac, ETHER_ADDR_LEN);
d1525 2
a1526 2
	bcopy(sc->sc_aps[sc->sc_aps_best].bssid, body->peermac, ETHER_ADDR_LEN);
	body->capinfo = htole16(sc->sc_aps[sc->sc_aps_best].capinfo);
d1531 2
a1532 2
	body_ssid->size = htole16(strlen(sc->sc_aps[sc->sc_aps_best].ssid));
	bcopy(sc->sc_aps[sc->sc_aps_best].ssid, body_ssid->data,
d1539 1
a1539 1
	bcopy(&sc->sc_aps[sc->sc_aps_best].channel, body_phy->data, 1);
d1549 2
a1550 2
	body_rates->size = htole16(strlen(sc->sc_aps[sc->sc_aps_best].rates));
	bcopy(sc->sc_aps[sc->sc_aps_best].rates, body_rates->data,
d1753 1
a1753 1
	s = splnet(); /* XXX */
d1780 1
@


1.33
log
@o Improve interrupt handler;  fixes TX watchdog timeouts on my zaurus.
o Add /* FALLTHROUGH */'s to state handler (spotted by claudio@@).
o Adapt debug levels.

OK claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.32 2007/08/03 08:27:15 claudio Exp $ */
d91 1
d639 2
a640 2
	else
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
d698 6
d705 3
a707 3
			if (!sc->sc_aps_num)
				/* no AP found */
				break;
d711 1
a711 2
			cmalo_cmd_set_auth(sc);
			/* FALLTHROUGH */
d715 1
a715 2
			cmalo_cmd_set_assoc(sc);
			/* FALLTHROUGH */
d719 1
d975 1
d978 1
a978 1
	/* get AP with best signal strength */
d980 17
d1004 11
d1016 12
a1027 2
	DPRINTF(1, "best network found is %s\n",
	    sc->sc_aps[sc->sc_aps_best].ssid);
@


1.32
log
@switch cmalo_rx() to use m_getdev() instead of something hand rolled.
cmalo_rx() is called from the interrupt handler and therefor is running at
IPL_NET so no need to do spl dances instead sprinkel some splassert() into
the rx and tx path.  OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.31 2007/08/02 21:15:50 mglocker Exp $ */
d63 1
a63 1
int cmalo_d = 2;
d705 1
d710 1
d751 1
a751 1
	uint16_t intr;
d753 1
a754 1

d764 10
a786 4
	/* acknowledge interrupt */
	intr &= MALO_VAL_HOST_INTR_MASK_ON;
	MALO_WRITE_2(sc, MALO_REG_HOST_INTR_CAUSE, intr);

d797 1
a797 1
	DPRINTF(1, "%s: intr mask changed from 0x%04x ",
d809 1
a809 1
	DPRINTF(1, "to 0x%04x\n", val16);
d981 1
a981 1
	DPRINTF(2, "best network found is %s\n",
@


1.31
log
@Activate watchdog timer.  We need to find out about the issue that the
device stops with TX interrupts so often.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.30 2007/08/02 10:59:31 claudio Exp $ */
d813 1
a813 1
	int i, s;
d815 1
a815 1
	s = splnet();
d836 1
a836 1
	if (rxdesc->status != MALO_RX_STATUS_OK) {
a837 1
		splx(s);
a838 1
	}
d847 3
a849 18
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		ifp->if_ierrors++;
		splx(s);
		return;
	}
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		ifp->if_ierrors++;
		m_freem(m);
		splx(s);
		return;
	}
	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = m->m_len = rxdesc->pkglen;
	m->m_data += ETHER_ALIGN;
	data = mtod(m, uint8_t *);
	bcopy(sc->sc_data + rxdesc->pkgoffset, data, m->m_pkthdr.len);
a860 2

	splx(s);
d908 2
d947 2
@


1.30
log
@ETHER_ALIGN the mbuf so that it works on strictalignment archs. This is a
quick hack because cmalo_rx() should use m_getdev() instead.  OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.29 2007/08/01 11:30:22 mglocker Exp $ */
d87 1
d291 1
a291 1
	//ifp->if_watchdog = cmalo_watchdog;
d907 11
d951 1
d969 1
@


1.29
log
@Improve state switching and fix some debug output.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.28 2007/07/31 23:19:40 mglocker Exp $ */
d863 1
@


1.28
log
@Add first version to enable auto association (best signal AP).  Therefore
remove experimental, hard-coded MAC address block.

Also tested by claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.27 2007/07/31 23:00:38 claudio Exp $ */
d635 1
a635 1
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
d637 1
a637 3
		ieee80211_new_state(ic, IEEE80211_S_AUTH, -1);
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	} else
d680 6
d696 4
a699 1
			break;
a702 3
			if (sc->sc_aps_num == 0)
				break;
			cmalo_select_network(sc);
a707 1
			break;
d716 1
d983 1
a983 1
	if (cmalo_d <= 2) {
d1732 4
d1784 5
@


1.27
log
@Add missing splx(s); calls. OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.26 2007/07/31 22:01:37 claudio Exp $ */
d89 1
a254 17
/* XXX experimental */
#if 0
uint8_t ap[] = { 0x00, 0x17, 0x9a, 0x44, 0xda, 0x83 };
uint8_t chan[] = { 0x01 };
uint8_t ssid[] = "nazgul";

uint8_t ap[] = { 0x00, 0x15, 0xe9, 0xa4, 0x6e, 0xd1 };
uint8_t chan[] = { 0x04 };
uint8_t ssid[] = "foobar";
#endif

uint8_t ap[] = { 0x00, 0x04, 0x75, 0x88, 0xa5, 0xb4 };
uint8_t chan[] = { 0x04 };
uint8_t ssid[] = "foobar";

uint8_t rates[] = { 0x01, 0x04, 0x82, 0x84, 0x0b, 0x16 };

d370 1
a370 1
		for (na->na_nodes = i = j = 0; i < sc->sc_networks_num &&
d376 1
a376 1
			    sc->sc_networks[i].bssid);
d378 2
a379 2
			    sc->sc_networks[i].bssid);
			nr->nr_channel = sc->sc_networks[i].channel;
d381 1
a381 1
			nr->nr_rssi = sc->sc_networks[i].rssi;
d383 2
a384 2
			nr->nr_nwid_len = strlen(sc->sc_networks[i].ssid);
			bcopy(sc->sc_networks[i].ssid, nr->nr_nwid,
d386 2
a387 2
			nr->nr_intval = sc->sc_networks[i].beaconintvl;
			nr->nr_capinfo = sc->sc_networks[i].capinfo;
a630 2
	cmalo_cmd_set_assoc(sc);

d635 6
a640 1
	ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
d691 1
d696 4
a699 1
			break;
d703 1
d955 19
d1135 1
a1135 1
	bzero(sc->sc_networks, sizeof(sc->sc_networks));
d1141 1
a1141 1
	sc->sc_networks_num = body->numofset;
d1153 2
a1154 2
		bcopy(set->bssid, sc->sc_networks[i].bssid, sizeof(set->bssid));
		bcopy(set->timestamp, sc->sc_networks[i].timestamp,
d1156 3
a1158 3
		sc->sc_networks[i].rssi = set->rssi;
		sc->sc_networks[i].beaconintvl = set->beaconintvl;
		sc->sc_networks[i].capinfo = set->capinfo;
d1185 2
a1186 2
			bcopy(buf + i, sc->sc_networks[pos].ssid, len);
			DPRINTF(2, "ssid=%s\n", sc->sc_networks[pos].ssid);
d1189 1
a1189 1
			bcopy(buf + i, sc->sc_networks[pos].rates, len);
d1193 2
a1194 2
			sc->sc_networks[pos].channel = *(uint8_t *)(buf + i);
			DPRINTF(2, "chnl=%d\n", sc->sc_networks[pos].channel);
d1223 1
a1223 1
	bcopy(ap, body->peermac, ETHER_ADDR_LEN);
a1451 1
	struct ieee80211com *ic = &sc->sc_ic;
d1469 2
a1470 2
	bcopy(ap, body->peermac, ETHER_ADDR_LEN);
	body->capinfo = htole16(IEEE80211_CAPINFO_ESS);
d1475 3
a1477 2
	body_ssid->size = htole16(6);
	bcopy(ssid, body_ssid->data, 6);
d1483 1
a1483 1
	bcopy(chan, body_phy->data, 1);
d1493 3
a1495 4
	body_rates->size =
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates);
d1501 2
a1502 2
	body_passeid->size = htole16(6);
	bcopy(rates, body_passeid->data, 6);
@


1.26
log
@Plug a mbuf leak in the TX path and replace a handbuilt m_copydata()
implementation with m_copydata(). Remove the CMALO_DEBUG that slipped in
somehow.  OK mglocker@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.25 2007/07/31 14:57:58 mglocker Exp $ */
d839 1
a839 1
	if (rxdesc->status != MALO_RX_STATUS_OK)
d841 1
d843 1
d855 1
d862 1
@


1.25
log
@Start to improve TX/RX path;  don't accept further packets from TX queue
unless the last packet has been processed by the device.  Protect RX
routine with splnet().  This changes let me scp with ~575KB/s in 11b for
now.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.24 2007/07/31 09:34:55 mglocker Exp $ */
a61 1
#define CMALO_DEBUG
a909 1
	struct mbuf *m0;
d912 1
a912 1
	int i, off;
d924 2
a925 6
	off = sizeof(*txdesc);
	for (m0 = m; m0; m0 = m0->m_next) {
		data = mtod(m0, uint8_t *);
		bcopy(data, sc->sc_data + off, m0->m_len);
		off += m0->m_len;
	}
d940 1
a940 1
	    sc->sc_dev.dv_xname, txdesc->status, m->m_pkthdr.len,
@


1.24
log
@Simplify TX path.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.23 2007/07/30 21:45:31 mglocker Exp $ */
d817 3
a819 1
	int i;
d877 2
d909 1
d943 1
a943 1
	/* XXX ifp->if_flags |= IFF_OACTIVE ??? */
@


1.23
log
@After two weeks of fumbling arround in the association FW command, i found
a trick to correct the wrong generated rates-element-id in the FW association
mgmt packet.  Makes it possible to associate to more AP's.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.22 2007/07/08 10:09:02 mglocker Exp $ */
d62 1
a880 1
	struct ieee80211com *ic = &sc->sc_ic;
d883 1
d887 5
a891 8
	for (;;) {
		/* mgmt frames */
		IF_POLL(&ic->ic_mgtq, m);
		if (m != NULL) {
			IF_DEQUEUE(&ic->ic_mgtq, m);
			/* all mgmt frames are handled by the FW */
			continue;
		}
a892 5
		/* data frames */
		IFQ_POLL(&ifp->if_snd, m);
		if (m == NULL)
			break;
		IFQ_DEQUEUE(&ifp->if_snd, m);
d894 2
a895 2
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
d897 3
a899 5
		if (cmalo_tx(sc, m) != 0) {
			ifp->if_oerrors++;
			break;
		}
	}
@


1.22
log
@Process scan command results.  Enable 'ifconfig -M'.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.21 2007/07/07 21:17:26 mglocker Exp $ */
d259 4
d264 2
a265 1
uint8_t ap[] = { 0x00, 0x15, 0xe9, 0xa4, 0x6e, 0xd1 };
d269 2
d647 1
a647 1
	//cmalo_cmd_set_assoc(sc);
d1185 1
a1185 1
			DPRINTF(2, "rates\n", sc->sc_networks[pos].rates);
d1454 1
d1466 1
a1466 1
	body->capinfo = htole16(IEEE80211_CAPINFO_ESS);	
d1484 1
a1484 1
	psize += sizeof(*body_cf);
d1489 3
a1491 3
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
d1493 7
@


1.21
log
@Make the scan command work, finally.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.20 2007/06/30 12:08:57 mglocker Exp $ */
d95 2
d344 2
d347 1
a347 1
	int s, error = 0;
d369 39
a639 2
	cmalo_cmd_set_scan(sc);

d1115 81
a1719 1
		/* do nothing */
d1722 1
@


1.20
log
@Add 802.11d (domain info) command.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.19 2007/06/17 20:00:30 mglocker Exp $ */
a595 3
	cmalo_cmd_set_snmp(sc, MALO_OID_80211D);
	
	cmalo_cmd_set_80211d(sc);
d1050 3
a1052 3
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
@


1.19
log
@Add background SCAN command.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.18 2007/06/17 15:11:23 mglocker Exp $ */
d103 1
d596 3
d600 1
a600 1
	//cmalo_cmd_set_scan(sc);
d602 1
a602 1
	cmalo_cmd_set_assoc(sc);
d1012 1
d1018 1
a1018 1
	struct malo_cmd_tlv_numprobes *body_numprobes;
d1031 1
d1036 1
a1036 1
	psize += sizeof(*body_ssid);
d1052 4
a1055 3
	body_rates->size = htole16(ieee80211_std_rateset_11g.rs_nrates);
	bcopy(ieee80211_std_rateset_11g.rs_rates, body_rates->data,
	    ieee80211_std_rateset_11g.rs_nrates);
d1057 1
a1057 1

d1063 1
a1063 1

d1139 5
d1321 1
d1361 4
a1364 3
	body_rates->size = htole16(ieee80211_std_rateset_11g.rs_nrates);
	bcopy(ieee80211_std_rateset_11g.rs_rates, body_rates->data,
	    ieee80211_std_rateset_11g.rs_nrates);
d1380 44
d1527 2
d1638 5
@


1.18
log
@Pass the device a better rate set.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.17 2007/06/17 10:18:28 mglocker Exp $ */
d103 2
d1366 61
d1578 10
@


1.17
log
@Add first shoot of SCAN command.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.16 2007/06/16 19:45:24 mglocker Exp $ */
a1005 1
	struct ieee80211com *ic = &sc->sc_ic;
d1037 1
a1037 1
		body_chanlist->data[i].minscantime = htole16(6);
d1044 3
a1046 4
	body_rates->size =
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
a1306 1
	struct ieee80211com *ic = &sc->sc_ic;
d1346 3
a1348 4
	body_rates->size =
	    htole16(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, body_rates->data,
	    ic->ic_sup_rates[IEEE80211_MODE_11G].rs_nrates);
@


1.16
log
@Add three new firmware commands to set authentication, set rate adaption,
and tune several 802.11 parameters.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.15 2007/06/11 09:56:13 mglocker Exp $ */
d94 1
d250 1
d253 2
a254 1
#if 0
d257 1
a257 1
#endif
d594 2
d1004 66
d1312 4
a1315 4
	struct malo_cmd_body_assoc_ssid *body_ssid;
	struct malo_cmd_body_assoc_phy *body_phy;
	struct malo_cmd_body_assoc_cf *body_cf;
	struct malo_cmd_body_assoc_rate *body_rate;
d1333 1
a1333 1
	bcopy("nazgul", body_ssid->data, 6);
d1347 3
a1349 3
	body_rate = sc->sc_cmd + psize;
	body_rate->type = htole16(MALO_TLV_TYPE_RATES);
	body_rate->size =
d1351 1
a1351 1
	bcopy(ic->ic_sup_rates[IEEE80211_MODE_11G].rs_rates, body_rate->data,
d1353 1
a1353 1
	psize += (sizeof(*body_rate) - 1) + body_rate->size;
d1419 1
a1419 1
	for (i = 0; i < 100; i++) {
d1480 5
@


1.15
log
@Handle mbuf chains in TX path.  Improve debug output.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.14 2007/06/09 13:14:55 mglocker Exp $ */
d94 2
d102 1
d247 9
d585 6
d999 77
a1245 6
	uint8_t ap[] = { 0x00, 0x17, 0x9a, 0x44, 0xda, 0x83 };	/* XXX */
	uint8_t chan[] = { 0x01 };				/* XXX */
#if 0
	uint8_t ap[] = { 0x00, 0x15, 0xe9, 0xa4, 0x6e, 0xd1 };	/* XXX */
	uint8_t chan[] = { 0x02 };				/* XXX */
#endif
d1253 1
a1254 1
	body = (struct malo_cmd_body_assoc *)(hdr + 1);
d1256 1
a1256 1
	body->capinfo = htole16(IEEE80211_CAPINFO_ESS);
d1297 30
d1410 10
d1443 5
@


1.14
log
@Initialize TX queue.  Handle TX done interrupts in a own function.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.13 2007/06/08 22:08:21 mglocker Exp $ */
d49 1
d678 1
a678 1
	uint16_t intr; 
d841 1
d844 1
a844 1
	int i;
d855 7
a861 2
	/* copy mbuf packet to the buffer */
	bcopy(data, sc->sc_data + sizeof(*txdesc), m->m_pkthdr.len);
d873 6
d887 1
a887 1
	DPRINTF(2, "%s: TX frame sent\n", sc->sc_dev.dv_xname);
d908 1
a909 1
	printf("\n");
d1143 1
d1153 4
d1167 1
a1167 1
	body->capinfo = 0;
d1189 5
a1193 2
	body_rate->size = htole16(0);
	psize += sizeof(*body_rate);
d1229 1
a1229 1
	for (i = 0; i < 50; i++) {
@


1.13
log
@Add TX path which enables some first (unreliable yet) packet transfers.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.12 2007/06/04 20:29:51 mglocker Exp $ */
d87 1
d281 2
a573 2
	ieee80211_new_state(ic, IEEE80211_S_RUN, -1);

d576 3
d589 5
a593 1
	DPRINTF(1, "%s: device down\n", sc->sc_dev.dv_xname);
d595 1
a595 1
	/* power cycle device */
d599 1
a599 2
	/* device down */
	ifp->if_flags &= ~IFF_RUNNING;
d695 1
a695 1
		DPRINTF(2, "%s: TX frame sent\n", sc->sc_dev.dv_xname);
d808 3
d812 1
d817 1
d820 1
d822 3
a824 2
		if (m != NULL) {
			IFQ_DEQUEUE(&ifp->if_snd, m);
d826 2
a827 2
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
d829 2
a830 5
			if (cmalo_tx(sc, m) != 0) {
				ifp->if_oerrors++;
				break;
			}
		} else
d832 1
d866 9
a874 2
	DPRINTF(2, "%s: TX pkglen=%d, pkgoffset=%d\n",
	    sc->sc_dev.dv_xname, txdesc->pkglen, txdesc->pkgoffset);
d876 3
a878 1
	return (0);
@


1.12
log
@Enable channel switching.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.11 2007/06/03 21:26:41 mglocker Exp $ */
d85 2
d97 1
d276 1
a276 1
	//ifp->if_start = cmalo_start;
d569 4
d614 25
d686 3
d743 2
a744 2
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DATA_DL_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DATA_DL_OVER);
d792 1
d794 64
a857 1
	m_freem(m);
d1107 59
d1187 1
a1187 1
	for (i = 0; i < 10; i++) {
d1206 3
a1208 1
	int i;
d1279 2
@


1.11
log
@Make RX path work on big endian, too.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.10 2007/06/03 11:04:46 mglocker Exp $ */
d332 2
a333 2
		if ((ifp->if_flags & IFF_UP)) {
			if (!(ifp->if_flags & IFF_RUNNING))
d336 1
a336 1
			if ((ifp->if_flags & IFF_RUNNING))
d346 1
a346 2
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
d527 1
d545 7
d563 1
a563 1
	if (cmalo_cmd_set_channel(sc, 1) != 0)
d596 1
a596 1
	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
@


1.10
log
@The firmware converts every 802.11 RX data frame into a 802.3 frame,
including the LLC/SNAP header.  Mgmt frames are handled completely inside
the firmware, we won't ever see any mgmt frame for this device.

Remove the LLC/SNAP header in the driver to get an useable frame which
we can pass up to the network stack.  Remove some unused firmware commands.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.9 2007/06/01 23:43:32 mglocker Exp $ */
d706 3
d736 1
a736 1
	m->m_pkthdr.len = m->m_len = letoh16(rxdesc->pkglen);
@


1.9
log
@Add RX path and enable monitor mode.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.8 2007/05/28 13:51:09 mglocker Exp $ */
d39 1
a89 2
int	cmalo_cmd_get_status(struct malo_softc *);
int	cmalo_cmd_rsp_status(struct malo_softc *);
a94 1
int	cmalo_cmd_set_macaddr(struct malo_softc *);
d694 1
a694 1
	/* read the whole RX packet */
d704 1
d714 6
d743 1
a743 1
	if (ic->ic_opmode != IEEE80211_M_MONITOR)
d745 2
a837 38
cmalo_cmd_get_status(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	uint16_t psize;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr);

	hdr->cmd = htole16(MALO_CMD_STATUS);
	hdr->size = 0;
	hdr->seqnum = htole16(1);
	hdr->result = 0;

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
cmalo_cmd_rsp_status(struct malo_softc *sc)
{
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_status *body;

	body = (struct malo_cmd_body_status *)(hdr + 1);

	printf("%s: FW status = 0x%04x, MAC status = 0x%04x\n",
	    body->fw_status, body->mac_status);

	return (0);
}

int
a997 33
cmalo_cmd_set_macaddr(struct malo_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct malo_cmd_header *hdr = sc->sc_cmd;
	struct malo_cmd_body_macaddr *body;
	uint16_t psize;
	int i;

	bzero(sc->sc_cmd, MALO_CMD_BUFFER_SIZE);
	psize = sizeof(*hdr) + sizeof(*body);

	hdr->cmd = htole16(MALO_CMD_MACADDR);
	hdr->size = htole16(sizeof(*body));
	hdr->seqnum = htole16(1);
	hdr->result = 0;
	body = (struct malo_cmd_body_macaddr *)(hdr + 1);

	body->action = htole16(1);

	for (i = 0; i < ETHER_ADDR_LEN; i++)
		body->macaddr[i] = ic->ic_myaddr[i];

	/* process command request */
	if (cmalo_cmd_request(sc, psize, 0) != 0)
		return (EIO);

	/* process command repsonse */
	cmalo_cmd_response(sc);

	return (0);
}

int
a1078 5
	case MALO_CMD_STATUS:
		DPRINTF(1, "%s: got status cmd response\n",
		    sc->sc_dev.dv_xname);
		cmalo_cmd_rsp_status(sc);
		break;
a1101 5
		    sc->sc_dev.dv_xname);
		break;
	case MALO_CMD_MACADDR:
		/* do nothing */
		DPRINTF(1, "%s: got macaddr cmd response\n",
@


1.8
log
@Add a bunch of new firmware commands to configure MAC/PHY/RF, and do so.
Simplify command interface.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.7 2007/05/27 15:44:27 mglocker Exp $ */
d19 2
d31 5
d78 2
d82 2
a83 1
void	cmalo_intr_mask(struct malo_softc *sc, int);
d259 6
a267 3
	/* allocate command buffer */
	sc->sc_cmd = malloc(MALO_CMD_BUFFER_SIZE, M_USBDEV, M_WAITOK);

d283 1
d302 3
a304 2
	ieee80211_media_init(ifp, ieee80211_media_change,
	    ieee80211_media_status);
d343 1
a343 1
		error = EINVAL;
d347 7
d401 3
a403 2
		MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
		MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);
d408 1
a408 1
			    MALO_VAL_DNLD_OVER)
d423 2
a424 2
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);
d488 3
a490 2
		MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
                MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);
d495 1
a495 1
			    MALO_VAL_DNLD_OVER)
d548 3
a550 1
	if (cmalo_cmd_set_channel(sc, 1) != 0)
d558 1
a558 5
	if (cmalo_cmd_set_txpower(sc, 15) != 0)
		return (EIO);
	if (cmalo_cmd_set_macctrl(sc) != 0)
		return (EIO);
	if (cmalo_cmd_set_macaddr(sc) != 0)
d583 22
d620 4
d649 3
d686 59
d981 1
a981 1
		body->antenna_mode = htole16(0xffff);	/* diversity */
d999 1
d1015 2
d1074 2
a1075 2
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);
@


1.7
log
@Values which are written to a 16-bit register shall be uint16_t not int.
Spacing.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.6 2007/05/27 13:27:53 mglocker Exp $ */
d79 3
d83 5
d526 12
d601 1
a601 1
	if (intr & MALO_VAL_HOST_INTR_CMD) {
a603 1
	}
d658 1
a658 2
	uint16_t psize, *uc;
	int i;
d663 1
a663 1
	hdr->cmd = htole16(MALO_VAL_CMD_HWSPEC);
d672 2
a673 20
	cmalo_hexdump(sc->sc_cmd, psize);

	/* send command request */
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, psize);
	uc = (uint16_t *)hdr;
	for (i = 0; i < psize / 2; i++)
		MALO_WRITE_2(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);

	/* wait for the command response */
	sc->sc_cmd_running = 1;
	for (i = 0; i < 10; i++) {
		if (sc->sc_cmd_running == 0)
			break;
		tsleep(sc, 0, "malocmd", 1);
	}
	if (sc->sc_cmd_running) {
		printf("%s: timeout while waiting for cmd response!\n",
		    sc->sc_dev.dv_xname);
a674 1
	}
d703 22
a724 2
	uint16_t psize, *uc;
	int i;
d729 1
a729 1
	hdr->cmd = htole16(MALO_VAL_CMD_RESET);
d734 53
a786 7
	/* send command request */
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, psize);
	uc = (uint16_t *)hdr;
	for (i = 0; i < psize / 2; i++)
		MALO_WRITE_2(sc, MALO_REG_CMD_WRITE, htole16(uc[i]));
	MALO_WRITE_1(sc, MALO_REG_HOST_STATUS, MALO_VAL_DNLD_OVER);
	MALO_WRITE_2(sc, MALO_REG_CARD_INTR_CAUSE, MALO_VAL_DNLD_OVER);
d796 1
a796 2
	uint16_t psize, *uc;
	int i;
d801 1
a801 1
	hdr->cmd = htole16(MALO_VAL_CMD_CHANNEL);
d810 144
d958 1
a958 1
	uc = (uint16_t *)hdr;
d964 4
a980 3
	/* process command repsonse */
	cmalo_cmd_response(sc);

d1013 1
a1013 1
	if (!(hdr->cmd & MALO_VAL_CMD_RESP)) {
d1018 1
a1018 1
	hdr->cmd &= ~MALO_VAL_CMD_RESP;
d1022 3
a1024 1
	case MALO_VAL_CMD_HWSPEC:
d1027 1
a1027 1
	case MALO_VAL_CMD_RESET:
d1030 11
a1040 1
	case MALO_VAL_CMD_CHANNEL:
d1043 20
@


1.6
log
@Make it work on big endian archs, too.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.5 2007/05/26 21:16:02 mglocker Exp $ */
d334 3
a336 3
	uint8_t *ucode, val8;
	uint16_t *uc;
	int offset, error, bsize, i;
a367 1

a370 1

d405 2
a406 2
	uint16_t val16, *uc;
	int offset, error, bsize, retry, i;
@


1.5
log
@Cast offset arg of bus_space_write_multi_2 to (uint16_t *).  Fix device
detach panic.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.4 2007/05/26 11:11:54 mglocker Exp $ */
d335 1
d368 5
a372 2
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE,
		    (uint16_t *)(ucode + offset), bsize / 2);
d407 1
a407 1
	uint16_t val16;
d456 3
a458 2
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE,
		    (uint16_t *)(ucode + offset), bsize / 2);
d641 1
a641 1
	uint16_t psize;
d660 3
a662 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, (uint16_t *)hdr, psize / 2);
d706 2
a707 1
	uint16_t psize;
d719 3
a721 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, (uint16_t *)hdr, psize / 2);
d733 1
a733 1
	uint16_t psize;
d752 3
a754 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, (uint16_t *)hdr, psize / 2);
d781 2
a782 1
	int len;
d786 7
a792 3
	/* read the whole command answer */
	len = MALO_READ_2(sc, MALO_REG_CMD_READ_LEN);
	MALO_READ_MULTI_2(sc, MALO_REG_CMD_READ, sc->sc_cmd, len / 2);
d794 10
a803 1
	cmalo_hexdump(sc->sc_cmd, len);
@


1.4
log
@Tune command interface.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.3 2007/05/25 21:32:02 mglocker Exp $ */
d210 2
a211 1
		pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
d286 3
d367 2
a368 2
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, (ucode + offset),
		    bsize / 2);
d452 2
a453 2
		MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, (ucode + offset),
		    bsize / 2);
d545 4
d550 2
a551 1
	free(sc->sc_cmd, M_DEVBUF);
d655 1
a655 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, hdr, psize / 2);
d711 1
a711 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, hdr, psize / 2);
d742 1
a742 1
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, hdr, psize / 2);
@


1.3
log
@Make FW commands save in the way that requests/responses must be done
serialized.  Establish initial device up/down dance.
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.2 2007/05/25 18:31:01 mglocker Exp $ */
d20 1
d22 1
d54 1
a54 1
int cmalo_d = 1;
d79 1
d360 1
a360 1
		DPRINTF(2, "%s: download helper FW block (%d bytes, %d off)\n",
d445 1
a445 1
		DPRINTF(2, "%s: download main FW block (%d bytes, %d off)\n",
d494 4
d502 4
d508 4
a556 3
	DPRINTF(2, "%s: interrupt handler called (intr = 0x%04x)\n",
	    sc->sc_dev.dv_xname, intr);

d566 3
d606 1
d609 8
a616 6
	for (i = 0; i < len; i++) {
		if (i % 16 == 0)
			printf("%s%4i:", i ? "\n" : "", i);
		if (i % 4 == 0)
			printf(" ");
		printf("%02x", (int)*((u_char *)buf + i));
a617 1

d619 1
d627 1
d631 1
d634 1
a634 1
	hdr->size = htole16(sizeof(*hdr) + sizeof(*body));
d642 1
a642 1
	cmalo_hexdump(sc->sc_cmd, hdr->size);
d645 2
a646 2
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, hdr->size);
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, hdr, hdr->size / 2);
d652 1
a652 1
	for (i = 0; i < 50; i++) {
d655 1
a655 1
		delay(1000);
d657 1
a657 1
	if (i == 50) {
d690 1
d693 1
d696 1
a696 1
	hdr->size = htole16(sizeof(*hdr));
d701 2
a702 2
	MALO_WRITE_2(sc, MALO_REG_CMD_WRITE_LEN, hdr->size);
	MALO_WRITE_MULTI_2(sc, MALO_REG_CMD_WRITE, hdr, hdr->size / 2);
d710 47
d786 5
d792 1
a792 1
		printf("%s: got unknown command response (0x%04x)!\n",
@


1.2
log
@Bump firmware package version;  Better naming of the malo firmware files.

discussed with, and OK claudio@@
@
text
@d1 1
a1 1
/*      $OpenBSD: if_malo.c,v 1.1 2007/05/25 05:33:51 mglocker Exp $ */
d69 1
a69 1
int	cmalo_detach(void *);
d76 1
a176 1
	int error;
d178 1
a178 2
	if ((error = cmalo_detach(sc)))
		return (error);
d235 1
d241 1
a241 1
	sc->sc_cmd = malloc(CMD_BUFFER_SIZE, M_USBDEV, M_WAITOK);
a244 1
	delay(1000); /* XXX */
d351 2
a352 2
		if (usize - offset >= FW_HELPER_BSIZE)
			bsize = FW_HELPER_BSIZE;
d408 1
a408 1
		if (MALO_READ_1(sc, MALO_REG_RBAL) == FW_HELPER_OK)
d428 1
a428 1
			if (retry > FW_MAIN_MAX_RETRY) {
d487 12
a498 1
	//struct malo_softc *sc = ifp->if_softc;
d506 8
d515 2
d519 1
a519 1
int
a531 2

	return (0);
d556 1
a556 1
		cmalo_cmd_response(sc);
d609 1
d611 1
a611 1
	bzero(sc->sc_cmd, CMD_BUFFER_SIZE);
d630 16
d667 21
d693 1
a693 1
	bzero(sc->sc_cmd, CMD_BUFFER_SIZE);
d713 3
@


1.1
log
@Initial driver stub for the Marvell 88W8385 PCMCIA (CF) device.

Loads firmware, sends first FW command, establish interrupts.
@
text
@d1 1
a1 1
/*      $OpenBSD$ */
d326 1
a326 1
	const char *name = "mrv8385-h.fw";
d394 1
a394 1
	const char *name = "mrv8385-m.fw";
@

