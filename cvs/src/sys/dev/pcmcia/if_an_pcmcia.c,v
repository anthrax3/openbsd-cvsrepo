head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.24.0.4
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.23.0.4
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.16
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.14
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.10
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.8
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.16
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.12
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.10
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.8
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.6
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.4
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.19.0.2
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.14.0.2
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.2
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.10
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	SMP:1.4.0.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.2.0.2
	OPENBSD_2_7_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5DvsamK0GblTp8ww;

1.24
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.23;
commitid	p4LJxGKbi0BU2cG6;

1.23
date	2015.02.28.00.16.36;	author jsg;	state Exp;
branches;
next	1.22;
commitid	kJcdEGpn9m1nZJxc;

1.22
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2006.03.10.00.27.55;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.30.11.41.00;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.09.21.19.47;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.13.14.15.33;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2005.09.13.12.11.04;	author reyk;	state Exp;
branches;
next	1.14;

1.14
date	2005.06.20.22.42.29;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.02.19.24.23;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.10;

1.10
date	2002.06.25.15.13.09;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.09.22.34.16;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.06.09.03.14.18;	author todd;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.30.00.31.15;	author art;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2001.04.06.18.02.58;	author aaron;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	2000.06.23.16.12.35;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.03.01.02.00;	author mickey;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.26.06;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.4.4.4;

1.4.4.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.4.4.5;

1.4.4.5
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.05.19.22.19.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_an_pcmcia.c,v 1.25 2015/11/24 13:33:18 mpi Exp $	*/

/*
 * Copyright (c) 1999 Michael Shalayeff
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR OR HIS RELATIVES BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF MIND, USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
 * IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/socket.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/ic/anreg.h>
#include <dev/ic/anvar.h>

int  an_pcmcia_match(struct device *, void *, void *);
void an_pcmcia_attach(struct device *, struct device *, void *);
int  an_pcmcia_detach(struct device *, int);
int  an_pcmcia_activate(struct device *, int);

struct an_pcmcia_softc {
	struct an_softc sc_an;

	struct pcmcia_io_handle sc_pcioh;
	int sc_io_window;
	struct pcmcia_function *sc_pf;

	int sc_state;
#define	AN_PCMCIA_ATTACHED	3
};

struct cfattach an_pcmcia_ca = {   
	sizeof(struct an_pcmcia_softc), an_pcmcia_match, an_pcmcia_attach,
	an_pcmcia_detach, an_pcmcia_activate
};

int
an_pcmcia_match(struct device *parent, void *match, void *aux)
{
	struct pcmcia_attach_args *pa = aux;

	if (pa->pf->function != PCMCIA_FUNCTION_NETWORK)
		return 0;

	switch (pa->manufacturer) {
	case PCMCIA_VENDOR_AIRONET:
		switch (pa->product) {
		case PCMCIA_PRODUCT_AIRONET_PC4500:
		case PCMCIA_PRODUCT_AIRONET_PC4800:
		case PCMCIA_PRODUCT_AIRONET_350:
			return 1;
		}
	}

	return 0;
}

void
an_pcmcia_attach(struct device *parent, struct device *self, void *aux)
{
	struct an_pcmcia_softc *psc = (struct an_pcmcia_softc *)self;
	struct an_softc *sc = (struct an_softc *)self;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const char *intrstr;
	int error;

	psc->sc_pf = pa->pf;
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);

	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		return;
	}

	if (pcmcia_io_alloc(pa->pf, 0, AN_IOSIZ, AN_IOSIZ, &psc->sc_pcioh)) {
		printf(": can't alloc i/o space\n");
		pcmcia_function_disable(pa->pf);
		return;
	}

	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, 0, AN_IOSIZ,
	    &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		pcmcia_io_free(pa->pf, &psc->sc_pcioh);
		pcmcia_function_disable(pa->pf);
		return;
	}

	sc->sc_iot = psc->sc_pcioh.iot;
	sc->sc_ioh = psc->sc_pcioh.ioh;
	sc->sc_enabled = 1;

	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc,
	    sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);
	printf("\n");

	error = an_attach(sc);
	if (error) {
		printf("%s: failed to attach controller\n",
		    self->dv_xname);
		return;
	}

	sc->sc_enabled = 0;
	psc->sc_state = AN_PCMCIA_ATTACHED;
}

int
an_pcmcia_detach(struct device *dev, int flags)
{
	struct an_pcmcia_softc *psc = (struct an_pcmcia_softc *)dev;
	int error;

	if (psc->sc_state != AN_PCMCIA_ATTACHED)
		return (0);

	error = an_detach(&psc->sc_an);
	if (error)
		return (error);

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	return 0;
}

int
an_pcmcia_activate(struct device *dev, int act)
{
	struct an_pcmcia_softc *psc = (struct an_pcmcia_softc *)dev;
	struct an_softc *sc = &psc->sc_an;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;

	switch (act) {
	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			an_stop(ifp, 1);
		if (sc->sc_ih)
			pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(psc->sc_pf);
		break;
	}
	return (0);
}
@


1.25
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.24 2015/03/14 03:38:49 jsg Exp $	*/
a36 1
#include <net/if_dl.h>
@


1.24
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.23 2015/02/28 00:16:36 jsg Exp $	*/
a37 1
#include <net/if_types.h>
@


1.23
log
@unbreak pcmcia an(4) by adding back some lines removed in rev 1.21
without this is won't attach.

ok stsp@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.22 2011/07/03 15:47:17 matthew Exp $	*/
a45 2

#include <machine/bus.h>
@


1.22
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.21 2010/08/30 20:33:18 deraadt Exp $	*/
d133 1
d149 1
@


1.21
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.20 2009/10/13 19:33:16 pirofti Exp $	*/
a178 6
	case DVACT_ACTIVATE:
		pcmcia_function_enable(psc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    an_intr, sc, sc->sc_dev.dv_xname);
		an_init(ifp);
		break;
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.19 2006/03/10 00:27:55 jsg Exp $	*/
a132 1
	sc->sc_enabled = 1;
a147 1
	sc->sc_enabled = 0;
a176 1
	int s;
a177 1
	s = splnet();
a184 1

d189 3
a191 1
		pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
a194 2

	splx(s);
@


1.19
log
@ansi. no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.18 2006/01/30 11:41:00 jsg Exp $	*/
d59 1
a59 1
int  an_pcmcia_activate(struct device *, enum devact);
d173 1
a173 1
an_pcmcia_activate(struct device *dev, enum devact act)
@


1.18
log
@Add basic radiotap support.  Modelled somewhat after
ral and NetBSD wi radiotap.
"looks ok" damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.17 2006/01/09 21:19:47 jsg Exp $	*/
d78 1
a78 3
an_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d99 1
a99 3
an_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d154 1
a154 3
an_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
d173 1
a173 3
an_pcmcia_activate(dev, act)
	struct device *dev;
	enum devact act;
@


1.17
log
@Move an(4) to a driver based on the NetBSD one.
This brings net80211 support and support for newer hardware.
In addition ancontrol is no longer needed.

This driver does not yet work on big endian archs like the previous
one did.

"do it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.16 2005/09/13 14:15:33 mickey Exp $	*/
d45 1
@


1.16
log
@only include what is needed (tree.h) and not the whole metric assload of unrelated crap (mbuf.h)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.15 2005/09/13 12:11:04 reyk Exp $	*/
d52 1
a53 1
#include <dev/ic/anreg.h>
d66 3
d109 1
d134 3
a136 2
	sc->an_btag = psc->sc_pcioh.iot;
	sc->an_bhandle = psc->sc_pcioh.ioh;
d143 8
d152 2
a153 1
	an_attach(sc);
d162 1
a162 3
	struct an_softc *sc = (struct an_softc *)dev;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
d164 2
a165 4
	if (sc->an_gone) {
		printf ("%s: already detached\n", sc->sc_dev.dv_xname);
		return 0;
	}
d167 3
a169 2
	if (ifp->if_flags & IFF_RUNNING)
		an_stop(sc);
a173 5
	ether_ifdetach(ifp);
	if_detach(ifp);

	sc->an_gone = 1;

d194 1
a194 1
		an_init(sc);
d200 1
a200 1
			an_stop(sc);
@


1.15
log
@replace the node hash table with a red-black tree. this fixes some
bugs in the node table (like duplicate nodes in hostap mode), we get
rid of possible hash collisions, and it simplifies the code.

tested by many, ok damien@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.14 2005/06/20 22:42:29 jsg Exp $	*/
d34 1
a34 1
#include <sys/mbuf.h>
@


1.14
log
@Replace arpcom in the softc with ieee80211com in preparation for
further net80211 changes. ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.13 2005/01/27 17:04:55 millert Exp $	*/
d34 1
@


1.13
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.12 2003/06/02 19:24:23 mickey Exp $	*/
d43 2
d148 2
a149 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d177 2
a178 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.12
log
@kill the caluses three and four on some of my code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.11 2002/11/19 18:36:18 jason Exp $	*/
d102 1
d130 5
a134 3
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc, "");
	if (sc->sc_ih == NULL)
		printf("no irq");
@


1.11
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.10 2002/06/25 15:13:09 millert Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Michael Shalayeff.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.10
log
@Back out my change to pass in sc_dev.dv_xname to pcmcia_intr_establish().
It screws up printing in dmesg and doesn't actually help anything
since interupts in "vmstat -i" show up as pcmcia*, not wi* or an*.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.9 2002/06/09 22:34:16 millert Exp $	*/
d109 1
a109 1
	cfe = pa->pf->cfe_head.sqh_first;
@


1.9
log
@Pass in the device name to pcmcia_intr_establish() instead of ""
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.8 2002/06/09 03:14:18 todd Exp $	*/
d134 1
a134 2
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    an_intr, sc, sc->sc_dev.dv_xname);
@


1.8
log
@a step towards consistancy; in general:
	'struct arpcom foo' -> 'struct arpcom sc_arpcom'
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.6 2001/09/30 00:31:15 art Exp $	*/
d135 1
a135 1
	    an_intr, sc, "");
@


1.7
log
@First round of __P removal in sys
@
text
@d149 1
a149 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
d177 1
a177 1
	struct ifnet *ifp = &sc->arpcom.ac_if;
@


1.6
log
@Make the kernel compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.5 2001/08/17 21:52:16 deraadt Exp $	*/
d57 4
a60 4
int  an_pcmcia_match         __P((struct device *, void *, void *));
void an_pcmcia_attach        __P((struct device *, struct device *, void *));
int  an_pcmcia_detach        __P((struct device *, int));
int  an_pcmcia_activate      __P((struct device *, enum devact));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.6 2001/09/30 00:31:15 art Exp $	*/
d57 4
a60 4
int  an_pcmcia_match(struct device *, void *, void *);
void an_pcmcia_attach(struct device *, struct device *, void *);
int  an_pcmcia_detach(struct device *, int);
int  an_pcmcia_activate(struct device *, enum devact);
d149 1
a149 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d177 1
a177 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.6.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.6.4.1 2002/06/11 03:42:28 art Exp $	*/
d134 2
a135 1
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc, "");
@


1.6.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);
@


1.5
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.4 2001/04/06 18:02:58 aaron Exp $	*/
d43 1
@


1.4
log
@Match the Cisco Aironet 350 card; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.3 2000/06/23 16:12:35 aaron Exp $	*/
d133 2
a134 1
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc);
d183 2
a184 3
		sc->sc_ih =
		    pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc);
		printf("\n");
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.4 2001/04/06 18:02:58 aaron Exp $	*/
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.4.4.1 2001/05/14 22:26:06 niklas Exp $	*/
a42 1
#include <net/if_media.h>
d133 1
a133 2
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    an_intr, sc, "");
d182 3
a184 2
		sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		    an_intr, sc, sc->sc_dev.dv_xname);
@


1.4.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 4
a60 4
int  an_pcmcia_match(struct device *, void *, void *);
void an_pcmcia_attach(struct device *, struct device *, void *);
int  an_pcmcia_detach(struct device *, int);
int  an_pcmcia_activate(struct device *, enum devact);
@


1.4.4.4
log
@Sync the SMP branch with 3.3
@
text
@d109 1
a109 1
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);
d134 2
a135 1
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, an_intr, sc, "");
d149 1
a149 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
d177 1
a177 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
@


1.4.4.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.4.4.4 2003/03/28 00:38:26 niklas Exp $	*/
d15 5
@


1.3
log
@Pass the correct sizeo() to cfattach struct so we don't panic on detach.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.2 2000/04/24 19:43:35 niklas Exp $	*/
d89 1
@


1.2
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_an_pcmcia.c,v 1.1 2000/04/03 01:02:00 mickey Exp $	*/
d61 1
a61 1
struct	an_pcmcia_softc {
d65 1
a66 1
	int sc_io_window;
d70 1
a70 1
	sizeof (struct an_softc), an_pcmcia_match, an_pcmcia_attach,
d173 1
a173 1
	struct an_softc *sc = (struct an_softc *)dev;
@


1.1
log
@aironet 802.11 ds driver from freebsd, isa and pci are missing
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d191 1
a192 1
		pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
@

