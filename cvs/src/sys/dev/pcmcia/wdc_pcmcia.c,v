head	1.31;
access;
symbols
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.31.0.12
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.8
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.31.0.6
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.4
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.28.0.4
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.2
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.27.0.6
	OPENBSD_5_2_BASE:1.27
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.4
	OPENBSD_5_0:1.27.0.2
	OPENBSD_5_0_BASE:1.27
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.21.0.4
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.2
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.18.0.4
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.2
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.17.0.8
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.6
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.4
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.6
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.16.0.4
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.2
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.14.0.12
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.10
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.8
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.4
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.6
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.31
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.30;
commitid	uzzBR7hz9ncd4O6G;

1.30
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	Jjzk0Y0KSLF2oro4;

1.29
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.26;

1.26
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.25;

1.25
date	2011.03.31.13.05.27;	author jasper;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.31.17.13.47;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2010.08.29.18.41.24;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.26.22.26.12;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.17;

1.17
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.01.27.17.04.56;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.11.22.07.58;	author drahn;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.09.05.34;	author d;	state Exp;
branches;
next	1.10;

1.10
date	2001.01.29.00.20.17;	author csapuntz;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.24.19.43.36;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.10.07.06.15;	author csapuntz;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.01.17.01.48;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.10.09.03.42.05;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	99.08.16.16.51.20;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.07.21.05.23.13;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.07.21.04.41.54;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.07.20.21.51.21;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.08;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.31;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: wdc_pcmcia.c,v 1.30 2014/07/10 14:21:20 deraadt Exp $	*/
/*	$NetBSD: wdc_pcmcia.c,v 1.19 1999/02/19 21:49:43 abs Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum, by Onno van der Linden and by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/ata/atavar.h>
#include <dev/ic/wdcvar.h>

#define WDC_PCMCIA_REG_NPORTS      8
#define WDC_PCMCIA_AUXREG_OFFSET   (WDC_PCMCIA_REG_NPORTS + 6)
#define WDC_PCMCIA_AUXREG_NPORTS   2

struct wdc_pcmcia_softc {
	struct wdc_softc sc_wdcdev;
	struct channel_softc *wdc_chanptr;
	struct channel_softc wdc_channel;
	struct pcmcia_io_handle sc_pioh;
	struct pcmcia_io_handle sc_auxpioh;
	int sc_iowindow;
	int sc_auxiowindow;
	void *sc_ih;
	struct pcmcia_function *sc_pf;
	int sc_flags;
#define WDC_PCMCIA_ATTACH       0x0001
};

static int wdc_pcmcia_match(struct device *, void *, void *);
static void wdc_pcmcia_attach(struct device *, struct device *, void *);
int    wdc_pcmcia_detach(struct device *, int);
int    wdc_pcmcia_activate(struct device *, int);

struct cfattach wdc_pcmcia_ca = {
	sizeof(struct wdc_pcmcia_softc), wdc_pcmcia_match, wdc_pcmcia_attach,
	wdc_pcmcia_detach, wdc_pcmcia_activate
};

struct wdc_pcmcia_product {
	u_int16_t	wpp_vendor;	/* vendor ID */
	u_int16_t	wpp_product;	/* product ID */
	int		wpp_quirk_flag;	/* Quirk flags */
#define WDC_PCMCIA_FORCE_16BIT_IO	0x01 /* Don't use PCMCIA_WIDTH_AUTO */
#define WDC_PCMCIA_NO_EXTRA_RESETS	0x02 /* Only reset ctrl once */
	const char	*wpp_cis_info[4];	/* XXX necessary? */
} wdc_pcmcia_pr[] = {

	{ /* PCMCIA_VENDOR_DIGITAL XXX */ 0x0100,
	  PCMCIA_PRODUCT_DIGITAL_MOBILE_MEDIA_CDROM,
	  0, { NULL, "Digital Mobile Media CD-ROM", NULL, NULL }, },

	{ PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_PORTABLE_CDROM,
	  0, { NULL, "Portable CD-ROM Drive", NULL, NULL }, },

	{ PCMCIA_VENDOR_HAGIWARASYSCOM, PCMCIA_PRODUCT_INVALID,	/* XXX */
	  WDC_PCMCIA_FORCE_16BIT_IO, { NULL, NULL, NULL, NULL }, },

	/* The TEAC IDE/Card II is used on the Sony Vaio */
	{ PCMCIA_VENDOR_TEAC, PCMCIA_PRODUCT_TEAC_IDECARDII,
	  WDC_PCMCIA_NO_EXTRA_RESETS, PCMCIA_CIS_TEAC_IDECARDII },

	/*
	 * EXP IDE/ATAPI DVD Card use with some DVD players.
	 * Does not have a vendor ID or product ID.
	 */
	{ PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
	  0, PCMCIA_CIS_EXP_EXPMULTIMEDIA },

	/* Mobile Dock 2, which doesn't have vendor ID nor product ID */
	{ PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
	  0, PCMCIA_CIS_SHUTTLE_IDE_ATAPI },

	/* Archos MiniCD */
	{ PCMCIA_VENDOR_ARCHOS, PCMCIA_PRODUCT_ARCHOS_ARC_ATAPI,
	  0, PCMCIA_CIS_ARCHOS_ARC_ATAPI },
};

struct wdc_pcmcia_disk_device_interface_args {
	int ddi_type;		/* interface type */
	int ddi_reqfn;		/* function we are requesting iftype */
	int ddi_curfn;		/* function we are currently parsing in CIS */
};

int	wdc_pcmcia_disk_device_interface_callback(struct pcmcia_tuple *,
	    void *);
int	wdc_pcmcia_disk_device_interface(struct pcmcia_function *);
struct wdc_pcmcia_product *
	wdc_pcmcia_lookup(struct pcmcia_attach_args *);

int
wdc_pcmcia_disk_device_interface_callback(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	struct wdc_pcmcia_disk_device_interface_args *ddi = arg;

	switch (tuple->code) {
	case PCMCIA_CISTPL_FUNCID:
		ddi->ddi_curfn++;
		break;

	case PCMCIA_CISTPL_FUNCE:
		if (ddi->ddi_reqfn != ddi->ddi_curfn)
			break;

		/* subcode (disk device interface), data (interface type) */
		if (tuple->length < 2)
			break;

		/* check type */
		if (pcmcia_tuple_read_1(tuple, 0) !=
		    PCMCIA_TPLFE_TYPE_DISK_DEVICE_INTERFACE)
			break;

		ddi->ddi_type = pcmcia_tuple_read_1(tuple, 1);
		return (1);
	}
	return (0);
}

int
wdc_pcmcia_disk_device_interface(pf)
	struct pcmcia_function *pf;
{
	struct wdc_pcmcia_disk_device_interface_args ddi;

	ddi.ddi_reqfn = pf->number;
	ddi.ddi_curfn = -1;
	if (pcmcia_scan_cis((struct device *)pf->sc,
	    wdc_pcmcia_disk_device_interface_callback, &ddi) > 0)
		return (ddi.ddi_type);
	else
		return (-1);
}

struct wdc_pcmcia_product *
wdc_pcmcia_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	struct wdc_pcmcia_product *wpp;
	int i, cis_match;

	for (wpp = wdc_pcmcia_pr;
	    wpp < &wdc_pcmcia_pr[nitems(wdc_pcmcia_pr)];
	    wpp++)
		if ((wpp->wpp_vendor == PCMCIA_VENDOR_INVALID ||
		     pa->manufacturer == wpp->wpp_vendor) &&
		    (wpp->wpp_product == PCMCIA_PRODUCT_INVALID ||
		     pa->product == wpp->wpp_product)) {
			cis_match = 1;
			for (i = 0; i < 4; i++) {
				if (!(wpp->wpp_cis_info[i] == NULL ||
				      (pa->card->cis1_info[i] != NULL &&
				       strcmp(pa->card->cis1_info[i],
					      wpp->wpp_cis_info[i]) == 0)))
					cis_match = 0;
			}
			if (cis_match)
				return (wpp);
		}

	return (NULL);
}

static int
wdc_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_softc *sc;
	int iftype;

	if (wdc_pcmcia_lookup(pa) != NULL)
		return (1);

	if (pa->pf->function == PCMCIA_FUNCTION_DISK) {
		sc = pa->pf->sc;

		pcmcia_chip_socket_enable(sc->pct, sc->pch);
		iftype = wdc_pcmcia_disk_device_interface(pa->pf);
		pcmcia_chip_socket_disable(sc->pct, sc->pch);

		if (iftype == PCMCIA_TPLFE_DDI_PCCARD_ATA)
			return (1);
	}

	return (0);
}

static void
wdc_pcmcia_attach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
{
	struct wdc_pcmcia_softc *sc = (void *)self;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	struct wdc_pcmcia_product *wpp;
	const char *intrstr;
	int quirks;

	sc->sc_pf = pa->pf;

	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;
	    cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {
		if (cfe->num_iospace != 1 && cfe->num_iospace != 2)
			continue;

		if (pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,
		    cfe->iospace[0].length,
		    cfe->iospace[0].start == 0 ? cfe->iospace[0].length : 0,
		    &sc->sc_pioh))
			continue;

		if (cfe->num_iospace == 2) {
			if (!pcmcia_io_alloc(pa->pf, cfe->iospace[1].start,
			    cfe->iospace[1].length, 0, &sc->sc_auxpioh))
				break;
		} else /* num_iospace == 1 */ {
			sc->sc_auxpioh.iot = sc->sc_pioh.iot;
			if (!bus_space_subregion(sc->sc_pioh.iot,
			    sc->sc_pioh.ioh, WDC_PCMCIA_AUXREG_OFFSET,
			    WDC_PCMCIA_AUXREG_NPORTS, &sc->sc_auxpioh.ioh))
				break;
		}
		pcmcia_io_free(pa->pf, &sc->sc_pioh);
	}

	if (cfe == NULL) {
		printf(": can't handle card info\n");
		goto no_config_entry;
	}

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		goto enable_failed;
	}

	/*
	 * XXX  DEC Mobile Media CDROM is not yet tested whether it works
	 * XXX  with PCMCIA_WIDTH_IO16.  HAGIWARA SYS-COM HPC-CF32 doesn't
	 * XXX  work with PCMCIA_WIDTH_AUTO.
	 * XXX  CANON FC-8M (SANDISK SDCFB 8M) works for both _AUTO and IO16.
	 * XXX  So, here is temporary work around.
	 */
	wpp = wdc_pcmcia_lookup(pa);
	if (wpp != NULL)
		quirks = wpp->wpp_quirk_flag;
	else
		quirks = 0;

	if (pcmcia_io_map(pa->pf, quirks & WDC_PCMCIA_FORCE_16BIT_IO ?
	    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_AUTO, 0,
	    sc->sc_pioh.size, &sc->sc_pioh, &sc->sc_iowindow)) {
		printf(": can't map first i/o space\n");
		goto iomap_failed;
	} 

	/*
	 * Currently, # of iospace is 1 except DIGITAL Mobile Media CD-ROM.
	 * So whether the work around like above is necessary or not
	 * is unknown.  XXX.
	 */
	if (cfe->num_iospace <= 1)
		sc->sc_auxiowindow = -1;
	else if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,
	    sc->sc_auxpioh.size, &sc->sc_auxpioh, &sc->sc_auxiowindow)) {
		printf(": can't map second i/o space\n");
		goto iomapaux_failed;
	}

	printf(" port 0x%lx/%lu",
	    sc->sc_pioh.addr, (u_long)sc->sc_pioh.size);
	if (cfe->num_iospace > 1 && sc->sc_auxpioh.size > 0)
		printf(",0x%lx/%lu",
		    sc->sc_auxpioh.addr, (u_long)sc->sc_auxpioh.size);

	sc->wdc_channel.cmd_iot = sc->sc_pioh.iot;
	sc->wdc_channel.cmd_ioh = sc->sc_pioh.ioh;
	sc->wdc_channel.ctl_iot = sc->sc_auxpioh.iot;
	sc->wdc_channel.ctl_ioh = sc->sc_auxpioh.ioh;
	sc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;
	sc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;
	sc->sc_wdcdev.PIO_cap = 0;
	sc->wdc_chanptr = &sc->wdc_channel;
	sc->sc_wdcdev.channels = &sc->wdc_chanptr;
	sc->sc_wdcdev.nchannels = 1;
	sc->wdc_channel.channel = 0;
	sc->wdc_channel.wdc = &sc->sc_wdcdev;
	sc->wdc_channel.ch_queue = wdc_alloc_queue();
	if (sc->wdc_channel.ch_queue == NULL) {
		printf("cannot allocate channel queue\n");
		goto ch_queue_alloc_failed;
	}
	if (quirks & WDC_PCMCIA_NO_EXTRA_RESETS)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_NO_EXTRA_RESETS;

	/* Establish the interrupt handler. */
	sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, wdcintr,
	    &sc->wdc_channel, sc->sc_wdcdev.sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(sc->sc_pf, sc->sc_ih);
	if (*intrstr)
		printf(": %s", intrstr);

	printf("\n");

	sc->sc_flags |= WDC_PCMCIA_ATTACH;
	wdcattach(&sc->wdc_channel);
	wdc_print_current_modes(&sc->wdc_channel);
	sc->sc_flags &= ~WDC_PCMCIA_ATTACH;
	return;

 ch_queue_alloc_failed:
        /* Unmap our aux i/o window. */
        if (sc->sc_auxiowindow != -1)
                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);

 iomapaux_failed:
        /* Unmap our i/o window. */
        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);

 iomap_failed:
        /* Disable the function */
        pcmcia_function_disable(sc->sc_pf);

 enable_failed:
        /* Unmap our i/o space. */
        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);
        if (cfe->num_iospace == 2)
                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);

 no_config_entry:
        sc->sc_iowindow = -1;
}

int
wdc_pcmcia_detach(self, flags)
	struct device *self;
	int  flags;
{
        struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;
        int error;

        if (sc->sc_iowindow == -1)
                /* Nothing to detach */
                return (0);
	
	if ((error = wdcdetach(&sc->wdc_channel, flags)) != 0) 
		return (error);

        if (sc->wdc_channel.ch_queue != NULL)
                wdc_free_queue(sc->wdc_channel.ch_queue);

        /* Unmap our i/o window and i/o space. */
        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);
        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);
        if (sc->sc_auxiowindow != -1) {
                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);
                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);
        }

        return (0);
}

int
wdc_pcmcia_activate(self, act)
	struct device *self;
	int act;
{
	struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;
	int rv = 0;

	if (sc->sc_iowindow == -1)
		/* Nothing to activate/deactivate. */
		return (0);

	switch (act) {
	case DVACT_DEACTIVATE:
		rv = config_activate_children(self, act);
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, 
		    wdcintr, &sc->wdc_channel, sc->sc_wdcdev.sc_dev.dv_xname);
		wdcreset(&sc->wdc_channel, VERBOSE);
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}
@


1.30
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.29 2013/12/06 21:03:04 deraadt Exp $	*/
a46 1
#include <sys/proc.h>
@


1.29
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.28 2012/10/08 21:47:50 deraadt Exp $	*/
a47 2

#include <uvm/uvm_extern.h>
@


1.28
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.27 2011/07/03 15:47:17 matthew Exp $	*/
d434 1
a434 7
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
d448 1
a448 1
	case DVACT_DEACTIVATE:
d454 3
@


1.27
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.26 2011/05/09 22:33:54 matthew Exp $	*/
d438 3
@


1.26
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.25 2011/03/31 13:05:27 jasper Exp $	*/
a433 10
	case DVACT_ACTIVATE:
		if (sc->sc_ih == NULL) {
			/* XXX attach function already did the work */
			pcmcia_function_enable(sc->sc_pf);
			sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, 
			    wdcintr, &sc->wdc_channel, sc->sc_wdcdev.sc_dev.dv_xname);
			wdcreset(&sc->wdc_channel, VERBOSE);
		}
		rv = config_activate_children(self, act);
		break;
@


1.25
log
@- use nitems(); no binary change.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.24 2010/08/31 17:13:47 deraadt Exp $	*/
d346 1
a346 2
	sc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),
	    M_DEVBUF, M_NOWAIT);
d348 1
a348 1
		printf("can't allocate memory for command queue\n");
d408 1
a408 1
                free(sc->wdc_channel.ch_queue, M_DEVBUF);
@


1.24
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.23 2010/08/30 20:33:18 deraadt Exp $	*/
d195 1
a195 1
	    wpp < &wdc_pcmcia_pr[sizeof(wdc_pcmcia_pr)/sizeof(wdc_pcmcia_pr[0])];
@


1.23
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.22 2010/08/29 18:41:24 deraadt Exp $	*/
d443 3
@


1.22
log
@wdcactivate() can go since it is just a wrapper around
config_activate_children (same change made to wdc.c and wdcvar.h)
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.21 2009/10/13 19:33:17 pirofti Exp $	*/
a140 2
int	wdc_pcmcia_enable(void *, int);

a354 10
#ifdef notyet
	/* We can enable and disable the controller. */
	sc->sc_wdcdev.sc_atapi_adapter.scsipi_enable = wdc_pcmcia_enable;

	/*
	 * Disable the pcmcia function now; wdcattach() will enable
	 * us again as it adds references to probe for children.
	 */
	pcmcia_function_disable(pa->pf);
#else
a360 1
#endif
d428 1
a428 1
	int rv = 0, s;
a433 1
	s = splbio();
d436 6
a441 5
		if (pcmcia_function_enable(sc->sc_pf)) {
			printf("%s: couldn't enable PCMCIA function\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			rv = EIO;
			break;
d443 11
a453 1

a455 9
		if (sc->sc_ih == NULL) {
			printf("%s: "
			    "couldn't establish interrupt handler\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			pcmcia_function_disable(sc->sc_pf);
			rv = EIO;
			break;
		}

a458 1

d460 4
a463 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
a464 1
		rv = config_activate_children(self, act);
a466 1
	splx(s);
a468 38

#if 0
int
wdc_pcmcia_enable(arg, onoff)
	void *arg;
	int onoff;
{
	struct wdc_pcmcia_softc *sc = arg;

	if (onoff) {
                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0) {
			if (pcmcia_function_enable(sc->sc_pf)) {
				printf("%s: couldn't enable PCMCIA function\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				return (EIO);
			}

			sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, 
			    wdcintr, &sc->wdc_channel, sc->sc_dev.dv_xname);
			if (sc->sc_ih == NULL) {
				printf("%s: "
				    "couldn't establish interrupt handler\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				pcmcia_function_disable(sc->sc_pf);
				return (EIO);
			}

			wdcreset(&sc->wdc_channel, VERBOSE);
		}
	} else {
                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		pcmcia_function_disable(sc->sc_pf);
	}

	return (0);
}
#endif
@


1.21
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.20 2009/04/26 22:26:12 kettenis Exp $	*/
d469 1
a469 1
		rv = wdcactivate(self, act);
d475 1
a475 1
		rv = wdcactivate(self, act);
@


1.20
log
@Prevent panic upon detach if the device didn't fully attach.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.19 2009/03/29 21:53:53 sthen Exp $	*/
d83 1
a83 1
int    wdc_pcmcia_activate(struct device *, enum devact);
d438 1
a438 1
	enum devact act;
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.18 2008/06/26 05:42:17 ray Exp $	*/
d442 4
@


1.18
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.17 2006/04/20 20:31:13 miod Exp $	*/
d312 1
a312 1
		printf(": can't map first I/O space\n");
d325 1
a325 1
		printf(": can't map second I/O space\n");
@


1.17
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.16 2005/01/27 17:04:56 millert Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.16
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.15 2005/01/11 22:07:58 drahn Exp $	*/
d336 2
a337 2
	printf(" port 0x%lx/%d",
	    sc->sc_pioh.addr, sc->sc_pioh.size);
d339 2
a340 2
		printf(",0x%lx/%d",
		    sc->sc_auxpioh.addr, sc->sc_auxpioh.size);
@


1.15
log
@Pass device names on intr_establish() call, other drivers need this too.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.14 2002/03/14 01:27:01 millert Exp $	*/
d261 1
d377 3
a379 3
	if (sc->sc_ih == NULL) {
		printf("couldn't establish interrupt handler");
	}
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.13 2001/11/06 19:53:19 miod Exp $	*/
d375 1
a375 1
	    &sc->wdc_channel, "");
@


1.13
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.12 2001/08/17 21:52:16 deraadt Exp $	*/
d87 4
a90 4
static int wdc_pcmcia_match	__P((struct device *, void *, void *));
static void wdc_pcmcia_attach	__P((struct device *, struct device *, void *));
int    wdc_pcmcia_detach   __P((struct device *, int));
int    wdc_pcmcia_activate __P((struct device *, enum devact));
d142 3
a144 3
int	wdc_pcmcia_disk_device_interface_callback __P((struct pcmcia_tuple *,
	    void *));
int	wdc_pcmcia_disk_device_interface __P((struct pcmcia_function *));
d146 1
a146 1
	wdc_pcmcia_lookup __P((struct pcmcia_attach_args *));
d148 1
a148 1
int	wdc_pcmcia_enable __P((void *, int));
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.13 2001/11/06 19:53:19 miod Exp $	*/
d87 4
a90 4
static int wdc_pcmcia_match(struct device *, void *, void *);
static void wdc_pcmcia_attach(struct device *, struct device *, void *);
int    wdc_pcmcia_detach(struct device *, int);
int    wdc_pcmcia_activate(struct device *, enum devact);
d142 3
a144 3
int	wdc_pcmcia_disk_device_interface_callback(struct pcmcia_tuple *,
	    void *);
int	wdc_pcmcia_disk_device_interface(struct pcmcia_function *);
d146 1
a146 1
	wdc_pcmcia_lookup(struct pcmcia_attach_args *);
d148 1
a148 1
int	wdc_pcmcia_enable(void *, int);
@


1.12
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.11 2001/06/12 09:05:34 d Exp $	*/
d56 1
a56 1
#include <vm/vm.h>
@


1.11
log
@Add Archos MiniCD (comes with some Toshiba laptops). ok csapuntz,fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.10 2001/01/29 00:20:17 csapuntz Exp $	*/
d375 1
a375 1
	    &sc->wdc_channel);
d460 1
a460 1
		    wdcintr, &sc->wdc_channel);
d501 1
a501 1
			    wdcintr, &sc->wdc_channel);
@


1.10
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.9 2000/04/24 19:43:36 niklas Exp $	*/
d130 4
@


1.9
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.8 2000/04/10 07:06:15 csapuntz Exp $	*/
d381 1
@


1.8
log
@

Added support for wd detach (merge from NetBSD). Support for
SCSI/ATAPI detach is not here yet.

Minor cleanup of wdc. Downgrade to UDMA mode 1 before going further.
Want to stay in UDMA modes because they're more error-resilient due to
a CRC.

Got rid of some of the ridiculous amount of softc sharing going on.
Hopefully, this will make the life of whoever goes in and fixes the
ref-counting to be correct easier.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.7 2000/02/01 17:01:48 fgsch Exp $	*/
d447 7
d460 1
a460 8
			rv = EIO;
			break;
		}

		if (pcmcia_function_enable(sc->sc_pf)) {
			printf("%s: couldn't enable PCMCIA function\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d470 1
a471 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d489 6
d501 1
a504 6
			if (pcmcia_function_enable(sc->sc_pf)) {
				printf("%s: couldn't enable PCMCIA function\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
				return (EIO);
			}
a507 1
		pcmcia_function_disable(sc->sc_pf);
d510 1
@


1.7
log
@New prods; use defines where available; rearrange some entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.6 1999/10/09 03:42:05 csapuntz Exp $	*/
d83 2
d89 2
d93 2
a94 1
	sizeof(struct wdc_pcmcia_softc), wdc_pcmcia_match, wdc_pcmcia_attach
d288 1
a288 1
		return;
d295 1
a295 1
		return;
a313 1
		/* XXX should unallocate */
d315 1
a315 1
		return;
d323 3
a325 2
	if (cfe->num_iospace > 1 &&
	    pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,
a326 1
		/* XXX should unallocate */
d328 1
a328 1
		return;
d354 1
a354 1
		return;
d379 1
d381 24
d408 32
a439 3
wdc_pcmcia_enable(arg, onoff)
	void *arg;
	int onoff;
d441 2
a442 1
	struct wdc_pcmcia_softc *sc = arg;
d444 5
a448 4
	if (onoff) {
		/* Establish the interrupt handler. */
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, wdcintr,
		    &sc->wdc_channel);
d450 2
a451 1
			printf("%s: couldn't establish interrupt handler\n",
d453 2
a454 1
			return (EIO);
d461 44
a504 1
			return (EIO);
d508 2
a509 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d514 1
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.10 2001/01/29 00:20:17 csapuntz Exp $	*/
a82 2
	int sc_flags;
#define WDC_PCMCIA_ATTACH       0x0001
a86 2
int    wdc_pcmcia_detach   __P((struct device *, int));
int    wdc_pcmcia_activate __P((struct device *, enum devact));
d89 1
a89 2
	sizeof(struct wdc_pcmcia_softc), wdc_pcmcia_match, wdc_pcmcia_attach,
	wdc_pcmcia_detach, wdc_pcmcia_activate
d283 1
a283 1
		goto no_config_entry;
d290 1
a290 1
		goto enable_failed;
d309 1
d311 1
a311 1
		goto iomap_failed;
d319 2
a320 3
	if (cfe->num_iospace <= 1)
		sc->sc_auxiowindow = -1;
	else if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_AUTO, 0,
d322 1
d324 1
a324 1
		goto iomapaux_failed;
d350 1
a350 1
		goto ch_queue_alloc_failed;
a374 1
	sc->sc_flags |= WDC_PCMCIA_ATTACH;
a375 97
	wdc_print_current_modes(&sc->wdc_channel);
	sc->sc_flags &= ~WDC_PCMCIA_ATTACH;
	return;

 ch_queue_alloc_failed:
        /* Unmap our aux i/o window. */
        if (sc->sc_auxiowindow != -1)
                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);

 iomapaux_failed:
        /* Unmap our i/o window. */
        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);

 iomap_failed:
        /* Disable the function */
        pcmcia_function_disable(sc->sc_pf);

 enable_failed:
        /* Unmap our i/o space. */
        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);
        if (cfe->num_iospace == 2)
                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);

 no_config_entry:
        sc->sc_iowindow = -1;
}

int
wdc_pcmcia_detach(self, flags)
	struct device *self;
	int  flags;
{
        struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;
        int error;

        if (sc->sc_iowindow == -1)
                /* Nothing to detach */
                return (0);
	
	if ((error = wdcdetach(&sc->wdc_channel, flags)) != 0) 
		return (error);

        if (sc->wdc_channel.ch_queue != NULL)
                free(sc->wdc_channel.ch_queue, M_DEVBUF);

        /* Unmap our i/o window and i/o space. */
        pcmcia_io_unmap(sc->sc_pf, sc->sc_iowindow);
        pcmcia_io_free(sc->sc_pf, &sc->sc_pioh);
        if (sc->sc_auxiowindow != -1) {
                pcmcia_io_unmap(sc->sc_pf, sc->sc_auxiowindow);
                pcmcia_io_free(sc->sc_pf, &sc->sc_auxpioh);
        }

        return (0);
}

int
wdc_pcmcia_activate(self, act)
	struct device *self;
	enum devact act;
{
	struct wdc_pcmcia_softc *sc = (struct wdc_pcmcia_softc *)self;
	int rv = 0, s;

	s = splbio();
	switch (act) {
	case DVACT_ACTIVATE:
		if (pcmcia_function_enable(sc->sc_pf)) {
			printf("%s: couldn't enable PCMCIA function\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			rv = EIO;
			break;
		}

		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, 
		    wdcintr, &sc->wdc_channel);
		if (sc->sc_ih == NULL) {
			printf("%s: "
			    "couldn't establish interrupt handler\n",
			    sc->sc_wdcdev.sc_dev.dv_xname);
			pcmcia_function_disable(sc->sc_pf);
			rv = EIO;
			break;
		}

		wdcreset(&sc->wdc_channel, VERBOSE);
		rv = wdcactivate(self, act);
		break;

	case DVACT_DEACTIVATE:
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		pcmcia_function_disable(sc->sc_pf);
		rv = wdcactivate(self, act);
		break;
	}
	splx(s);
	return (rv);
a377 1
#if 0
d386 8
a393 6
                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0) {
			if (pcmcia_function_enable(sc->sc_pf)) {
				printf("%s: couldn't enable PCMCIA function\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				return (EIO);
			}
d395 5
a399 11
			sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_BIO, 
			    wdcintr, &sc->wdc_channel);
			if (sc->sc_ih == NULL) {
				printf("%s: "
				    "couldn't establish interrupt handler\n",
				    sc->sc_wdcdev.sc_dev.dv_xname);
				pcmcia_function_disable(sc->sc_pf);
				return (EIO);
			}

			wdcreset(&sc->wdc_channel, VERBOSE);
a401 2
                if ((sc->sc_flags & WDC_PCMCIA_ATTACH) == 0)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d403 1
a407 1
#endif
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.7.2.1 2001/05/14 22:26:08 niklas Exp $	*/
a129 4

	/* Archos MiniCD */
	{ PCMCIA_VENDOR_ARCHOS, PCMCIA_PRODUCT_ARCHOS_ARC_ATAPI,
	  0, PCMCIA_CIS_ARCHOS_ARC_ATAPI },
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.7.2.2 2001/07/04 10:43:31 niklas Exp $	*/
d375 1
a375 1
	    &sc->wdc_channel, "");
d460 1
a460 1
		    wdcintr, &sc->wdc_channel, sc->sc_wdcdev.sc_dev.dv_xname);
d501 1
a501 1
			    wdcintr, &sc->wdc_channel, sc->sc_dev.dv_xname);
@


1.7.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 1
a56 1
#include <uvm/uvm_extern.h>
@


1.7.2.5
log
@Merge in -current from roughly a week ago
@
text
@d87 4
a90 4
static int wdc_pcmcia_match(struct device *, void *, void *);
static void wdc_pcmcia_attach(struct device *, struct device *, void *);
int    wdc_pcmcia_detach(struct device *, int);
int    wdc_pcmcia_activate(struct device *, enum devact);
d142 3
a144 3
int	wdc_pcmcia_disk_device_interface_callback(struct pcmcia_tuple *,
	    void *);
int	wdc_pcmcia_disk_device_interface(struct pcmcia_function *);
d146 1
a146 1
	wdc_pcmcia_lookup(struct pcmcia_attach_args *);
d148 1
a148 1
int	wdc_pcmcia_enable(void *, int);
@


1.6
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.5 1999/08/16 16:51:20 deraadt Exp $	*/
d103 1
a103 2
	  0, { NULL, "Digital Mobile Media CD-ROM", NULL, NULL },
	  },
d105 5
a109 10
	{ PCMCIA_VENDOR_IBM,
	  PCMCIA_PRODUCT_IBM_PORTABLE_CDROM_DRIVE,
	  0, { NULL, "Portable CD-ROM Drive", NULL, NULL },
	  },

	{ PCMCIA_VENDOR_HAGIWARASYSCOM,
	  -1,			/* XXX */
	  WDC_PCMCIA_FORCE_16BIT_IO,
	  { NULL, NULL, NULL, NULL },
	  },
d112 13
a124 5
	{ PCMCIA_VENDOR_TEAC,
	  PCMCIA_PRODUCT_TEAC_IDECARDII,
	  WDC_PCMCIA_NO_EXTRA_RESETS,
	  PCMCIA_CIS_TEAC_IDECARDII,
	  },
@


1.5
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.4 1999/07/26 05:43:16 deraadt Exp $	*/
a373 1
	wdc_final_attach(&sc->wdc_channel);
@


1.4
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.3 1999/07/21 05:23:13 deraadt Exp $	*/
d93 2
a94 2
	u_int32_t	wpp_vendor;	/* vendor ID */
	u_int32_t	wpp_product;	/* product ID */
d99 1
a99 2
	const char	*wpp_name;	/* product name */
} wdc_pcmcia_products[] = {
d104 1
a104 1
	  PCMCIA_STR_DIGITAL_MOBILE_MEDIA_CDROM },
d109 1
a109 1
	  PCMCIA_STR_IBM_PORTABLE_CDROM_DRIVE },
d115 1
a115 1
	  "Hagiwara SYS-COM CompactFlash Card" },
d122 1
a122 3
	  PCMCIA_STR_TEAC_IDECARDII },

	{ 0, 0, 0, { NULL, NULL, NULL, NULL}, NULL }
d192 4
a195 2
	for (wpp = wdc_pcmcia_products; wpp->wpp_name != NULL; wpp++)
		if ((wpp->wpp_vendor == -1 ||
d197 1
a197 1
		    (wpp->wpp_product == -1 ||
@


1.3
log
@change how this prints
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.2 1999/07/21 04:41:54 fgsch Exp $	*/
d308 1
d321 1
d326 6
d368 1
a368 1
		printf("couldn't establish interrupt handler\n");
@


1.2
log
@Shorter IBM portable cdrom string.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_pcmcia.c,v 1.1 1999/07/20 21:51:21 fgsch Exp $	*/
a323 2
	printf("\n");

d340 1
a340 2
		printf("%s: can't allocate memory for command queue",
		    sc->sc_wdcdev.sc_dev.dv_xname);
d360 1
a360 2
		printf("%s: couldn't establish interrupt handler\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
d363 2
@


1.1
log
@Add wdc pcmcia controller. As the other new ATA code, it needs to be
uncommented.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 1
a109 1
	  0, { NULL, "PCMCIA Portable CD-ROM Drive", NULL, NULL },
@

