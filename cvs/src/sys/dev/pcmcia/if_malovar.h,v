head	1.30;
access;
symbols
	OPENBSD_6_2_BASE:1.30
	OPENBSD_6_1:1.30.0.16
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.30.0.12
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.30.0.2
	OPENBSD_5_9_BASE:1.30
	OPENBSD_5_8:1.30.0.10
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.8
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.6
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.28.0.12
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.10
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.8
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.6
	OPENBSD_5_0:1.28.0.4
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.27.0.12
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.27.0.8
	OPENBSD_4_7_BASE:1.27
	OPENBSD_4_6:1.27.0.10
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.6
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.4
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.24.0.2
	OPENBSD_4_2_BASE:1.24;
locks; strict;
comment	@ * @;


1.30
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.14.12.21.13;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.09.20.37.32;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2007.10.09.08.24.17;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2007.10.08.22.08.12;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2007.08.09.21.24.02;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2007.08.09.14.50.06;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2007.08.07.11.44.44;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2007.08.06.22.51.18;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2007.08.05.14.53.02;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2007.08.05.10.05.57;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2007.08.05.09.09.15;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2007.08.01.11.30.22;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.31.23.19.40;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.30.21.45.31;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2007.07.08.10.09.03;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.30.12.08.57;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.17.20.00.30;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.17.10.18.28;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.16.19.45.24;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.08.22.08.21;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.04.20.29.51;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.03.21.26.41;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.01.23.43.32;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.28.13.51.09;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.05.26.21.16.03;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.26.11.11.54;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.25.21.32.02;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.25.05.33.51;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.30
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@/*	$OpenBSD: if_malovar.h,v 1.29 2013/11/14 12:21:13 dlg Exp $ */

/*
 * Copyright (c) 2007 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* simplify bus space access */
#define MALO_READ_1(sc, reg) \
	bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, (reg))
#define MALO_READ_2(sc, reg) \
	bus_space_read_2((sc)->sc_iot, (sc)->sc_ioh, (reg))
#define	MALO_READ_MULTI_2(sc, reg, off, size) \
	bus_space_read_raw_multi_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (off), \
	(size))
#define MALO_WRITE_1(sc, reg, val) \
	bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define MALO_WRITE_2(sc, reg, val) \
	bus_space_write_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (val))
#define MALO_WRITE_MULTI_2(sc, reg, off, size) \
	bus_space_write_raw_multi_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (off), \
	(size))

/* miscellaneous */
#define MALO_FW_HELPER_BSIZE	256	/* helper FW block size */
#define MALO_FW_HELPER_LOADED	0x10	/* helper FW loaded */
#define MALO_FW_MAIN_MAXRETRY	20	/* main FW block resend max retry */
#define MALO_CMD_BUFFER_SIZE	256	/* cmd buffer */

/* device flags */
#define MALO_DEVICE_ATTACHED	(1 << 0)
#define MALO_FW_LOADED		(1 << 1)
#define MALO_ASSOC_FAILED	(1 << 2)
#define MALO_BUSY		(1 << 3)
/*
 * FW command structures
 */
struct malo_cmd_header {
	uint16_t	cmd;
	uint16_t	size;
	uint16_t	seqnum;
	uint16_t	result;
	/* malo_cmd_body */
};

struct malo_cmd_body_spec {
	uint16_t	hw_if_version;
	uint16_t	hw_version;
	uint16_t	num_of_wcb;
	uint16_t	num_of_mcast;
	uint8_t		macaddr[ETHER_ADDR_LEN];
	uint16_t	regioncode;
	uint16_t	num_of_antenna;
	uint32_t	fw_version;
	uint32_t	wcbbase;
	uint32_t	rxpdrdptr;
	uint32_t	rxpdwrptr;
	uint32_t	fw_capinfo;
} __packed;

struct malo_cmd_body_scan {
	uint8_t		bsstype;
	uint8_t		bssid[ETHER_ADDR_LEN];
	/* malo_cmd_tlv_ssid */
	/* malo_cmd_tlv_chanlist */
	/* malo_cmd_tlv_rates */
	/* malo_cmd_tlv_numprobes */
} __packed;

struct malo_cmd_body_rsp_scan {
	uint16_t	bufsize;
	uint8_t		numofset;
} __packed;
struct malo_cmd_body_rsp_scan_set {
	uint16_t	size;
	uint8_t		bssid[ETHER_ADDR_LEN];
	uint8_t		rssi;
	uint8_t		timestamp[8];
	uint16_t	beaconintvl;
	uint16_t	capinfo;
} __packed;

struct malo_cmd_body_auth {
	uint8_t		peermac[ETHER_ADDR_LEN];
	uint8_t		authtype;
} __packed;

#define MALO_WEP_ACTION_TYPE_ADD	0x02
#define MALO_WEP_ACTION_TYPE_REMOVE	0x04
#define MALO_WEP_ACTION_TYPE_DEFAULT	0x08
#define MALO_WEP_KEY_TYPE_40BIT		0x01
#define MALO_WEP_KEY_TYPE_104BIT	0x02
struct malo_cmd_body_wep {
	uint16_t	action;
	uint16_t	key_index;
	uint8_t		key_type_1;
	uint8_t		key_type_2;
	uint8_t		key_type_3;
	uint8_t		key_type_4;
	uint8_t		key_value_1[16];
	uint8_t		key_value_2[16];
	uint8_t		key_value_3[16];
	uint8_t		key_value_4[16];
} __packed;

#define MALO_OID_BSS		0x00
#define MALO_OID_RATE		0x01
#define MALO_OID_BCNPERIOD	0x02
#define MALO_OID_DTIMPERIOD	0x03
#define MALO_OID_ASSOCTIMEOUT	0x04
#define MALO_OID_RTSTRESH	0x05
#define MALO_OID_SHORTRETRY	0x06
#define MALO_OID_LONGRETRY	0x07
#define MALO_OID_FRAGTRESH	0x08
#define MALO_OID_80211D		0x09
#define MALO_OID_80211H		0x0a
struct malo_cmd_body_snmp {
	uint16_t	action;
	uint16_t	oid;
	uint16_t	size;
	uint8_t		data[128];
} __packed;

struct malo_cmd_body_radio {
	uint16_t	action;
	uint16_t	control;
} __packed;

struct malo_cmd_body_channel {
	uint16_t	action;
	uint16_t	channel;
	uint16_t	rftype;
	uint16_t	reserved;
	uint8_t		channel_list[32];
} __packed;

struct malo_cmd_body_txpower {
	uint16_t	action;
	int16_t		txpower;	
} __packed;

struct malo_cmd_body_antenna {
	uint16_t	action;
	uint16_t	antenna_mode;
} __packed;

struct malo_cmd_body_macctrl {
	uint16_t	action;
	uint16_t	reserved;
} __packed;

struct malo_cmd_body_macaddr {
	uint16_t	action;
	uint8_t		macaddr[ETHER_ADDR_LEN];
} __packed;

struct malo_cmd_body_assoc {
	uint8_t		peermac[ETHER_ADDR_LEN];
	uint16_t	capinfo;
	uint16_t	listenintrv;
	uint16_t	bcnperiod;
	uint8_t		dtimperiod;
	/* malo_cmd_tlv_ssid */
	/* malo_cmd_tlv_phy */
	/* malo_cmd_tlv_cf */
	/* malo_cmd_tlv_rate */
} __packed;

struct malo_cmd_body_rsp_assoc {
	uint16_t	capinfo;
	uint16_t	status;
	uint16_t	assoc_id;
	uint16_t	info_len;
	/* uint8_t	info[270] */
} __packed;

struct malo_cmd_body_80211d {
	uint16_t	action;
	/* malo_cmd_tlv_80211d */
} __packed;

struct malo_cmd_body_bgscan_config {
	uint16_t	action;
	uint8_t		enable;
	uint8_t		bsstype;
	uint8_t		chperscan;
	uint8_t		discard;
	uint16_t	reserved;
	uint32_t	scanintvl;
	uint32_t	storecond;
	uint32_t	reportcond;
	uint16_t	maxscanres;
} __packed;

struct malo_cmd_body_bgscan_query {
	uint8_t		flush;
} __packed;

#define MALO_RATE_BITMAP_DS1	(1 << 0)
#define MALO_RATE_BITMAP_DS2	(1 << 1)
#define MALO_RATE_BITMAP_DS5	(1 << 2)
#define MALO_RATE_BITMAP_DS11	(1 << 3)
#define MALO_RATE_BITMAP_OFDM6	(1 << 5)
#define MALO_RATE_BITMAP_OFDM9	(1 << 6)
#define MALO_RATE_BITMAP_OFDM12	(1 << 7)
#define MALO_RATE_BITMAP_OFDM18	(1 << 8)
#define MALO_RATE_BITMAP_OFDM24	(1 << 9)
#define MALO_RATE_BITMAP_OFDM36	(1 << 10)
#define MALO_RATE_BITMAP_OFDM48	(1 << 11)
#define MALO_RATE_BITMAP_OFDM54	(1 << 12)
#define MALO_RATE_BITMAP_AUTO	0x1fef
struct malo_cmd_body_rate {
	uint16_t	action;
	uint16_t	hwauto;
	uint16_t	ratebitmap;
} __packed;

/*
 * FW command TLV structures
 */
#define MALO_TLV_TYPE_SSID	0x0000
#define MALO_TLV_TYPE_RATES	0x0001
#define MALO_TLV_TYPE_PHY	0x0003
#define MALO_TLV_TYPE_CF	0x0004
#define MALO_TLV_TYPE_80211D	0x0007
#define MALO_TLV_TYPE_CHANLIST	0x0101
#define MALO_TLV_TYPE_NUMPROBES	0x0102
#define MALO_TLV_TYPE_PASSEID	0x010a

struct malo_cmd_tlv_ssid {
	uint16_t	type;
	uint16_t	size;
	uint8_t		data[1];
} __packed;

struct malo_cmd_tlv_rates {
	uint16_t	type;
	uint16_t	size;
	uint8_t		data[1];
} __packed;

struct malo_cmd_tlv_phy {
	uint16_t	type;
	uint16_t	size;
	uint8_t		data[1];
} __packed;

struct malo_cmd_tlv_cf {
	uint16_t	type;
	uint16_t	size;
	uint8_t		data[1];
} __packed;

struct malo_cmd_tlv_80211d_param {
	uint8_t		firstchannel;
	uint8_t		numchannels;
	uint8_t		maxtxpower;
} __packed;
struct malo_cmd_tlv_80211d {
	uint16_t	type;
	uint16_t	size;
	uint8_t		countrycode[3];
	struct malo_cmd_tlv_80211d_param data[12];
} __packed;

struct malo_cmd_tlv_chanlist_param {
	uint8_t		radiotype;
	uint8_t		channumber;
	uint8_t		scantype;
	uint16_t	minscantime;
	uint16_t	maxscantime;
} __packed;
#define CHANNELS	12
struct malo_cmd_tlv_chanlist {
	uint16_t	type;
	uint16_t	size;
	struct malo_cmd_tlv_chanlist_param data[CHANNELS];
} __packed;

struct malo_cmd_tlv_numprobes {
	uint16_t	type;
	uint16_t	size;
	uint16_t	numprobes;
} __packed;

struct malo_cmd_tlv_passeid {
	uint16_t        type;
	uint16_t        size;
	uint8_t         data[1];
} __packed;

/* RX descriptor */
#define MALO_RX_STATUS_OK	0x0001
struct malo_rx_desc {
	uint16_t	status;
	uint8_t		snr;
	uint8_t		control;
	uint16_t	pkglen;
	uint8_t		nf;
	uint8_t		rate;
	uint32_t	pkgoffset;
	uint32_t	reserved1;
	uint8_t		priority;
	uint8_t		reserved2[3];
} __packed;

/* TX descriptor */
struct malo_tx_desc {
	uint32_t	status;
	uint32_t	control;
	uint32_t	pkgoffset;
	uint16_t	pkglen;
	uint8_t		dstaddrhigh[2];
	uint8_t		dstaddrlow[4];
	uint8_t		priority;
	uint8_t		flags;
	uint8_t		reserved[2];
} __packed;

/* scanned network */
struct malo_networks {
	uint8_t		bssid[ETHER_ADDR_LEN];
	uint8_t		rssi;
	uint8_t		timestamp[8];
	uint16_t	beaconintvl;
	uint16_t	capinfo;
	uint8_t		ssid[32];
	uint8_t		rates[14];
	uint8_t		channel;
} __packed;

/*
 * Softc
 */
struct malo_softc {
	struct device		 sc_dev;
	struct ieee80211com	 sc_ic;
	bus_space_tag_t		 sc_iot;
	bus_space_handle_t	 sc_ioh;
	int			 (*sc_newstate)
				 (struct ieee80211com *, enum ieee80211_state,
				     int);

	int			 sc_flags;
	uint8_t			*sc_fw_h;
	uint8_t			*sc_fw_m;
	size_t			 sc_fw_h_size;
	size_t			 sc_fw_m_size;
	int			 sc_cmd_ctxsave;
	void			*sc_cmd;
	void			*sc_data;
	uint8_t			 sc_curchan;
	int			 sc_net_num;
	int			 sc_net_cur;
	struct malo_networks	 sc_net[12];
	struct timeout		 sc_scan_to;
};
@


1.29
log
@replace workqs with tasks for handling resume

from kimberley manning
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.28 2010/08/30 20:33:18 deraadt Exp $ */
a367 1
	struct task		 sc_resume_t;
@


1.28
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.27 2007/10/09 20:37:32 mglocker Exp $ */
d368 1
a368 1
	struct workq_task	 sc_resume_wqt;
@


1.27
log
@Setup channels with OFDM flags.  Permit user to set fix rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.26 2007/10/09 08:24:17 mglocker Exp $ */
d45 1
a45 1

d368 1
@


1.26
log
@Load the firmware files just one time per device lifecycle (attach time)
instead on every `ifconfig up'.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.25 2007/10/08 22:08:12 mglocker Exp $ */
d210 13
@


1.25
log
@Make pcmcia malo(4) work with trunk(4) by:
Setting interface ethernet address from link level address.
Adding firmware command to set ethernet address.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.24 2007/08/09 21:24:02 mglocker Exp $ */
d343 4
@


1.24
log
@If an association has failed, set the device back to INIT state.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.23 2007/08/09 14:50:06 mglocker Exp $ */
d161 5
@


1.23
log
@o Add a mechanism to execute single commands even if are are not context
  save.  Protects cmalo_cmd_set_assoc() for now.
o In case of deauthentication or disassociation, try to reassociate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.22 2007/08/07 11:44:44 mglocker Exp $ */
d44 1
@


1.22
log
@Improve a evil tsleep() loop by using wakeup() in the interrupt handler.
Still not sure if the tsleep() is safe here, but better than the
previous version.

spotted and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.21 2007/08/06 22:51:18 mglocker Exp $ */
d337 1
@


1.21
log
@o Replace bus_space_write_2 for-loops in TX/RX with
  bus_space_write_raw_multi_2.
o Make TX/RX work on big endian archs (tested on macppc).

in co-operation and OK claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.20 2007/08/05 14:53:02 mglocker Exp $ */
a337 1
	uint8_t			 sc_cmd_running;
@


1.20
log
@Parse association command response to check if an association was
successfull or not.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.19 2007/08/05 10:05:57 mglocker Exp $ */
d25 1
a25 1
	bus_space_read_multi_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (off), \
d32 1
a32 1
	bus_space_write_multi_2((sc)->sc_iot, (sc)->sc_ioh, (reg), (off), \
@


1.19
log
@Add WEP support, which is done fully by the FW.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.18 2007/08/05 09:09:15 mglocker Exp $ */
d172 8
@


1.18
log
@o Some better variable namings.
o Fix some comments.
o Add a forgotten splx().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.17 2007/08/01 11:30:22 mglocker Exp $ */
d96 18
@


1.17
log
@Improve state switching and fix some debug output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.16 2007/07/31 23:19:40 mglocker Exp $ */
d286 2
a287 2
/* scanned AP's */
struct malo_aps {
d315 3
a317 3
	int			 sc_aps_num;
	int			 sc_aps_best;
	struct malo_aps		 sc_aps[12];
@


1.16
log
@Add first version to enable auto association (best signal AP).  Therefore
remove experimental, hard-coded MAC address block.

Also tested by claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.15 2007/07/30 21:45:31 mglocker Exp $ */
d318 1
@


1.15
log
@After two weeks of fumbling arround in the association FW command, i found
a trick to correct the wrong generated rates-element-id in the FW association
mgmt packet.  Makes it possible to associate to more AP's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.14 2007/07/08 10:09:03 mglocker Exp $ */
d286 2
a287 2
/* scanned networks */
struct malo_networks {
d315 3
a317 2
	int			 sc_networks_num;
	struct malo_networks	 sc_networks[12];
@


1.14
log
@Process scan command results.  Enable 'ifconfig -M'.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.13 2007/06/30 12:08:57 mglocker Exp $ */
d194 1
d250 6
@


1.13
log
@Add 802.11d (domain info) command.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.12 2007/06/17 20:00:30 mglocker Exp $ */
d80 13
d279 12
d308 2
@


1.12
log
@Add background SCAN command.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.11 2007/06/17 10:18:28 mglocker Exp $ */
d143 5
d178 1
d204 12
@


1.11
log
@Add first shoot of SCAN command.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.10 2007/06/16 19:45:24 mglocker Exp $ */
d141 17
@


1.10
log
@Add three new firmware commands to set authentication, set rate adaption,
and tune several 802.11 parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.9 2007/06/08 22:08:21 mglocker Exp $ */
d45 3
a47 1
/* FW command header */
a55 1
/* FW command bodies */
d71 9
d137 10
a146 4
	/* malo_cmd_body_assoc_ssid */
	/* malo_cmd_body_assoc_phy */
	/* malo_cmd_body_assoc_cf */
	/* malo_cmd_body_assoc_rate */
d148 4
d153 1
d156 4
a159 2
#define MALO_TLV_TYPE_RATES	0x0001
struct malo_cmd_body_assoc_ssid {
d164 2
a165 1
struct malo_cmd_body_assoc_phy {
d170 2
a171 1
struct malo_cmd_body_assoc_cf {
d176 2
a177 1
struct malo_cmd_body_assoc_rate {
d183 18
a200 4
struct malo_cmd_body_rate {
	uint16_t	action;
	uint16_t	hwauto;
	uint16_t	ratebitmap;
d231 3
@


1.9
log
@Add TX path which enables some first (unreliable yet) packet transfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.8 2007/06/04 20:29:51 mglocker Exp $ */
d70 23
d155 6
@


1.8
log
@Enable channel switching.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.7 2007/06/03 21:26:41 mglocker Exp $ */
d51 1
d98 36
d147 13
@


1.7
log
@Make RX path work on big endian, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.6 2007/06/01 23:43:32 mglocker Exp $ */
d125 1
@


1.6
log
@Add RX path and enable monitor mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.5 2007/05/28 13:51:09 mglocker Exp $ */
a68 10
struct malo_cmd_body_status {
	uint16_t	fw_status;
	uint16_t	mac_status;
	uint16_t	rf_status;
	uint16_t	current_channel;
	uint8_t		ap_mac[ETHER_ADDR_LEN];
	uint16_t	reserved;
	uint32_t	max_linkspeed;
} __packed;

a94 5
} __packed;

struct malo_cmd_body_macaddr {
	uint16_t	action;
	uint8_t		macaddr[ETHER_ADDR_LEN];
@


1.5
log
@Add a bunch of new firmware commands to configure MAC/PHY/RF, and do so.
Simplify command interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.4 2007/05/26 21:16:03 mglocker Exp $ */
d112 15
d132 3
d139 1
@


1.4
log
@Cast offset arg of bus_space_write_multi_2 to (uint16_t *).  Fix device
detach panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.3 2007/05/26 11:11:54 mglocker Exp $ */
d69 15
d90 20
@


1.3
log
@Tune command interface.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.2 2007/05/25 21:32:02 mglocker Exp $ */
d42 2
a43 1
#define MALO_FW_LOADED		(1 << 0)
@


1.2
log
@Make FW commands save in the way that requests/responses must be done
serialized.  Establish initial device up/down dance.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_malovar.h,v 1.1 2007/05/25 05:33:51 mglocker Exp $ */
d66 9
a74 1
};
@


1.1
log
@Initial driver stub for the Marvell 88W8385 PCMCIA (CF) device.

Loads firmware, sends first FW command, establish interrupts.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d36 7
a42 4
#define FW_HELPER_BSIZE		256	/* helper FW block size */
#define FW_HELPER_OK		0x10	/* helper FW loaded */
#define FW_MAIN_MAX_RETRY	20	/* main FW block resend max retry */
#define CMD_BUFFER_SIZE		256	/* cmd buffer */
a69 1

a70 1

d74 1
d76 1
@

