head	1.21;
access;
symbols
	OPENBSD_6_1:1.21.0.28
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.24
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.14
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.21.0.22
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.21.0.20
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.18
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.16
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.21.0.12
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.10
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.8
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.6
	OPENBSD_5_0:1.21.0.4
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.20
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.16
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.18
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.14
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.12
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.10
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.8
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.6
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.4
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.17.0.8
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.6
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.17.0.4
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.4
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.16
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.10
	OPENBSD_2_8:1.12.0.8
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.6
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.4
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.2
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.6.0.2
	OPENBSD_2_4_BASE:1.6
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.4
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.4.0.2
	OPENBSD_2_1_BASE:1.4
	OPENBSD_2_0:1.1.0.2
	OPENBSD_2_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.21
date	2010.09.04.12.59.27;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.05.18.21.04;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.16.07;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.01.02.20.33.40;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	99.08.16.16.51.20;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	99.08.08.01.00.15;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	99.07.20.21.51.21;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	99.05.27.13.36.55;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.05.27.13.32.38;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.01.28.04.58.32;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	98.09.11.10.47.15;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	97.11.07.08.07.36;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.03.01.22.42.59;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.11.28.23.28.17;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	96.11.12.20.31.01;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	96.04.29.14.17.39;	author hvozda;	state Exp;
branches;
next	;

1.12.4.1
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.12.4.3;

1.12.4.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.12.4.4;

1.12.4.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	;

1.13.4.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.13.4.2;

1.13.4.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.13.4.3;

1.13.4.3
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Add support for indirect CIS data (CISTPL_INDIRECT tuple).
@
text
@/*	$OpenBSD: pcmciavar.h,v 1.20 2005/11/23 11:39:37 mickey Exp $	*/
/*	$NetBSD: pcmciavar.h,v 1.5 1998/07/19 17:28:17 christos Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/queue.h>

#include <machine/bus.h>

#include <dev/pcmcia/pcmciachip.h>

extern int	pcmcia_verbose;

/*
 * Contains information about mapped/allocated i/o spaces.
 */
struct pcmcia_io_handle {
	bus_space_tag_t iot;		/* bus space tag (from chipset) */
	bus_space_handle_t ioh;		/* mapped space handle */
	bus_addr_t      addr;		/* resulting address in bus space */
	bus_size_t      size;		/* size of i/o space */
	int             flags;		/* misc. information */
};

#define	PCMCIA_IO_ALLOCATED	0x01	/* i/o space was allocated */

/*
 * Contains information about allocated memory space.
 */
struct pcmcia_mem_handle {
	bus_space_tag_t memt;		/* bus space tag (from chipset) */
	bus_space_handle_t memh;	/* mapped space handle */
	bus_addr_t      addr;		/* resulting address in bus space */
	bus_size_t      size;		/* size of mem space */
	pcmcia_mem_handle_t mhandle;	/* opaque memory handle */
	bus_size_t      realsize;	/* how much we really allocated */
};

/* pcmcia itself */

#define PCMCIA_CFE_MWAIT_REQUIRED	0x0001
#define PCMCIA_CFE_RDYBSY_ACTIVE	0x0002
#define PCMCIA_CFE_WP_ACTIVE		0x0004
#define PCMCIA_CFE_BVD_ACTIVE		0x0008
#define PCMCIA_CFE_IO8			0x0010
#define PCMCIA_CFE_IO16			0x0020
#define PCMCIA_CFE_IRQSHARE		0x0040
#define PCMCIA_CFE_IRQPULSE		0x0080
#define PCMCIA_CFE_IRQLEVEL		0x0100
#define PCMCIA_CFE_POWERDOWN		0x0200
#define PCMCIA_CFE_READONLY		0x0400
#define PCMCIA_CFE_AUDIO		0x0800

struct pcmcia_config_entry {
	int		number;
	u_int32_t	flags;
	int		iftype;
	int		num_iospace;

	/*
	 * The card will only decode this mask in any case, so we can
	 * do dynamic allocation with this in mind, in case the suggestions
	 * below are no good.
	 */
	u_long		iomask;
	struct {
		u_long	length;
		u_long	start;
	} iospace[4];		/* XXX this could be as high as 16 */
	u_int16_t	irqmask;
	int		num_memspace;
	struct {
		u_long	length;
		u_long	cardaddr;
		u_long	hostaddr;
	} memspace[2];		/* XXX this could be as high as 8 */
	int		maxtwins;
	SIMPLEQ_ENTRY(pcmcia_config_entry) cfe_list;
};

struct pcmcia_function {
	/* read off the card */
	int		number;
	int		function;
	int		last_config_index;
	u_long		ccr_base;
	u_long		ccr_mask;
	SIMPLEQ_HEAD(, pcmcia_config_entry) cfe_head;
	SIMPLEQ_ENTRY(pcmcia_function) pf_list;
	/* run-time state */
	struct pcmcia_softc *sc;
	struct device *child;
	struct pcmcia_config_entry *cfe;
	struct pcmcia_mem_handle pf_pcmh;
#define	pf_ccrt		pf_pcmh.memt
#define	pf_ccrh		pf_pcmh.memh
#define	pf_ccr_mhandle	pf_pcmh.mhandle
#define	pf_ccr_realsize	pf_pcmh.realsize
	bus_size_t	pf_ccr_offset;
	int		pf_ccr_window;
	bus_addr_t	pf_mfc_iobase;
	bus_addr_t	pf_mfc_iomax;
	int		(*ih_fct)(void *);
	void		*ih_arg;
	int		ih_ipl;
	int		pf_flags;
};

/* pf_flags */
#define	PFF_ENABLED	0x0001		/* function is enabled */
#define	PFF_FAKE	0x0002		/* function is made up (no CIS) */

struct pcmcia_card {
	int		cis1_major;
	int		cis1_minor;
	/* XXX waste of space? */
	char		cis1_info_buf[256];
	char		*cis1_info[4];
	u_int16_t	manufacturer;
#define	PCMCIA_VENDOR_INVALID	0xffff
	u_int16_t	product;
#define	PCMCIA_PRODUCT_INVALID	0xffff
	u_int16_t	error;
#define	PCMCIA_CIS_INVALID		{ NULL, NULL, NULL, NULL }
	SIMPLEQ_HEAD(, pcmcia_function) pf_head;
};

struct pcmcia_softc {
	struct device	dev;

	/* this stuff is for the socket */
	pcmcia_chipset_tag_t pct;
	pcmcia_chipset_handle_t pch;

	/* this stuff is for the card */
	struct pcmcia_card card;
	void		*ih;
	int		sc_enabled_count;	/* how many functions are
						   enabled */

	/*
	 * These are passed down from the PCMCIA chip, and exist only
	 * so that cards with Very Special address allocation needs
	 * know what range they should be dealing with.
	 */
	bus_addr_t iobase;		/* start i/o space allocation here */
	bus_size_t iosize;		/* size of the i/o space range */
};

struct pcmcia_cis_quirk {
	u_int16_t manufacturer;
	u_int16_t product;
	char *cis1_info[4];
	struct pcmcia_function *pf;
	struct pcmcia_config_entry *cfe;
};

struct pcmcia_attach_args {
	u_int16_t manufacturer;
	u_int16_t product;
	struct pcmcia_card *card;
	struct pcmcia_function *pf;
};

struct pcmcia_tuple {
	unsigned int	code;
	unsigned int	length;
	unsigned int	addrshift;
	unsigned int	flags;
#define	PTF_INDIRECT	0x01
	bus_size_t	indirect_ptr;
	bus_size_t	ptr;
	bus_space_tag_t	memt;
	bus_space_handle_t memh;
};

void	pcmcia_read_cis(struct pcmcia_softc *);
void	pcmcia_check_cis_quirks(struct pcmcia_softc *);
void	pcmcia_print_cis(struct pcmcia_softc *);
int	pcmcia_scan_cis(struct device * dev,
	    int (*) (struct pcmcia_tuple *, void *), void *);
uint8_t	pcmcia_cis_read_1(struct pcmcia_tuple *, bus_size_t);

#define	pcmcia_tuple_read_1(tuple, idx1)				\
	(pcmcia_cis_read_1((tuple), ((tuple)->ptr+(2+(idx1)))))

#define	pcmcia_tuple_read_2(tuple, idx2)				\
	(pcmcia_tuple_read_1((tuple), (idx2)) | 			\
	 (pcmcia_tuple_read_1((tuple), (idx2)+1)<<8))

#define	pcmcia_tuple_read_3(tuple, idx3)				\
	(pcmcia_tuple_read_1((tuple), (idx3)) |				\
	 (pcmcia_tuple_read_1((tuple), (idx3)+1)<<8) |			\
	 (pcmcia_tuple_read_1((tuple), (idx3)+2)<<16))

#define	pcmcia_tuple_read_4(tuple, idx4)				\
	(pcmcia_tuple_read_1((tuple), (idx4)) |				\
	 (pcmcia_tuple_read_1((tuple), (idx4)+1)<<8) |			\
	 (pcmcia_tuple_read_1((tuple), (idx4)+2)<<16) |			\
	 (pcmcia_tuple_read_1((tuple), (idx4)+3)<<24))

#define	pcmcia_tuple_read_n(tuple, n, idxn)				\
	(((n)==1)?pcmcia_tuple_read_1((tuple), (idxn)) :		\
	 (((n)==2)?pcmcia_tuple_read_2((tuple), (idxn)) :		\
	  (((n)==3)?pcmcia_tuple_read_3((tuple), (idxn)) :		\
	   /* n == 4 */ pcmcia_tuple_read_4((tuple), (idxn)))))

#define	PCMCIA_SPACE_MEMORY	1
#define	PCMCIA_SPACE_IO		2

int	pcmcia_ccr_read(struct pcmcia_function *, int);
void	pcmcia_ccr_write(struct pcmcia_function *, int, int);

#define	pcmcia_mfc(sc)	(SIMPLEQ_FIRST(&(sc)->card.pf_head) &&		\
    SIMPLEQ_NEXT(SIMPLEQ_FIRST(&(sc)->card.pf_head), pf_list))

void	pcmcia_function_init(struct pcmcia_function *,
	    struct pcmcia_config_entry *);
int	pcmcia_function_enable(struct pcmcia_function *);
void	pcmcia_function_disable(struct pcmcia_function *);

#define	pcmcia_io_alloc(pf, start, size, align, pciop)			\
	(pcmcia_chip_io_alloc((pf)->sc->pct, pf->sc->pch, (start),	\
	 (size), (align), (pciop)))

int	pcmcia_io_map(struct pcmcia_function *, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);

#define	pcmcia_io_unmap(pf, window)					\
	(pcmcia_chip_io_unmap((pf)->sc->pct, (pf)->sc->pch, (window)))

#define pcmcia_io_free(pf, pciop)					\
	(pcmcia_chip_io_free((pf)->sc->pct, (pf)->sc->pch, (pciop)))

#define pcmcia_mem_alloc(pf, size, pcmhp)				\
	(pcmcia_chip_mem_alloc((pf)->sc->pct, (pf)->sc->pch, (size), (pcmhp)))

#define pcmcia_mem_free(pf, pcmhp)					\
	(pcmcia_chip_mem_free((pf)->sc->pct, (pf)->sc->pch, (pcmhp)))

#define pcmcia_mem_map(pf, kind, card_addr, size, pcmhp, offsetp, windowp) \
	(pcmcia_chip_mem_map((pf)->sc->pct, (pf)->sc->pch, (kind),	\
	 (card_addr), (size), (pcmhp), (offsetp), (windowp)))

#define	pcmcia_mem_unmap(pf, window)					\
	(pcmcia_chip_mem_unmap((pf)->sc->pct, (pf)->sc->pch, (window)))

void	*pcmcia_intr_establish(struct pcmcia_function *, int,
	    int (*) (void *), void *, char *);
void 	pcmcia_intr_disestablish(struct pcmcia_function *, void *);
const char *pcmcia_intr_string(struct pcmcia_function *, void *);
@


1.20
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.19 2005/08/05 18:21:04 fgsch Exp $	*/
d196 4
a199 1
	u_long		mult;
d210 1
a210 3

#define	pcmcia_cis_read_1(tuple, idx0)					\
	(bus_space_read_1((tuple)->memt, (tuple)->memh, (tuple)->mult*(idx0)))
@


1.19
log
@correct io base/limit registers handling. from mycroft. only affects
multi function cards for now. this fixes the Novatel Wireless Merlin UMTS
Modem reported by Bolke de Bruin <bdbruin at aub dot nl>
tested by several ppl, commit deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.18 2005/01/27 17:03:23 millert Exp $	*/
d127 1
a127 1
	bus_addr_t	pf_ccr_offset;
d197 1
a197 1
	bus_addr_t	ptr;
@


1.18
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.17 2002/11/19 18:36:18 jason Exp $	*/
d129 2
a130 2
	long		pf_mfc_iobase;
	long		pf_mfc_iomax;
@


1.17
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.16 2002/03/14 03:16:07 millert Exp $	*/
d278 1
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.15 2002/03/14 01:27:01 millert Exp $	*/
d241 2
a242 2
#define	pcmcia_mfc(sc)	((sc)->card.pf_head.sqh_first &&		\
			 (sc)->card.pf_head.sqh_first->pf_list.sqe_next)
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.14 2002/01/02 20:33:40 deraadt Exp $	*/
d205 2
a206 2
int	pcmcia_scan_cis __P((struct device * dev,
	    int (*) (struct pcmcia_tuple *, void *), void *));
d275 2
a276 2
void	*pcmcia_intr_establish __P((struct pcmcia_function *, int,
	    int (*) (void *), void *, char *));
@


1.14
log
@remove doubled #define; openbsd@@davidkrause.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.13 2001/08/17 21:52:16 deraadt Exp $	*/
d131 1
a131 1
	int		(*ih_fct) __P((void *));
d202 3
a204 3
void	pcmcia_read_cis __P((struct pcmcia_softc *));
void	pcmcia_check_cis_quirks __P((struct pcmcia_softc *));
void	pcmcia_print_cis __P((struct pcmcia_softc *));
d238 2
a239 2
int	pcmcia_ccr_read __P((struct pcmcia_function *, int));
void	pcmcia_ccr_write __P((struct pcmcia_function *, int, int));
d244 4
a247 4
void	pcmcia_function_init __P((struct pcmcia_function *,
	    struct pcmcia_config_entry *));
int	pcmcia_function_enable __P((struct pcmcia_function *));
void	pcmcia_function_disable __P((struct pcmcia_function *));
d253 2
a254 2
int	pcmcia_io_map __P((struct pcmcia_function *, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *));
d277 1
a277 1
void 	pcmcia_intr_disestablish __P((struct pcmcia_function *, void *));
@


1.13
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.12 1999/08/16 16:51:20 deraadt Exp $	*/
a251 3

#define	pcmcia_io_free(pf, pciohp)					\
	(pcmcia_chip_io_free((pf)->sc->pct, (pf)->sc->pch, (pciohp)))
@


1.13.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.14 2002/01/02 20:33:40 deraadt Exp $	*/
d252 3
@


1.13.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.13.4.1 2002/01/31 22:55:37 niklas Exp $	*/
d131 1
a131 1
	int		(*ih_fct)(void *);
d202 5
a206 5
void	pcmcia_read_cis(struct pcmcia_softc *);
void	pcmcia_check_cis_quirks(struct pcmcia_softc *);
void	pcmcia_print_cis(struct pcmcia_softc *);
int	pcmcia_scan_cis(struct device * dev,
	    int (*) (struct pcmcia_tuple *, void *), void *);
d238 2
a239 2
int	pcmcia_ccr_read(struct pcmcia_function *, int);
void	pcmcia_ccr_write(struct pcmcia_function *, int, int);
d244 4
a247 4
void	pcmcia_function_init(struct pcmcia_function *,
	    struct pcmcia_config_entry *);
int	pcmcia_function_enable(struct pcmcia_function *);
void	pcmcia_function_disable(struct pcmcia_function *);
d253 2
a254 2
int	pcmcia_io_map(struct pcmcia_function *, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
d275 3
a277 3
void	*pcmcia_intr_establish(struct pcmcia_function *, int,
	    int (*) (void *), void *, char *);
void 	pcmcia_intr_disestablish(struct pcmcia_function *, void *);
@


1.13.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d241 2
a242 2
#define	pcmcia_mfc(sc)	(SIMPLEQ_FIRST(&(sc)->card.pf_head) &&		\
    SIMPLEQ_NEXT(SIMPLEQ_FIRST(&(sc)->card.pf_head), pf_list))
@


1.12
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.11 1999/08/08 01:00:15 niklas Exp $	*/
d279 1
a279 1
	    int (*) (void *), void *));
@


1.12.4.1
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.12 1999/08/16 16:51:20 deraadt Exp $	*/
d279 1
a279 1
	    int (*) (void *), void *, char *));
@


1.12.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d252 3
@


1.12.4.3
log
@Merge in -current from roughly a week ago
@
text
@d131 1
a131 1
	int		(*ih_fct)(void *);
d202 5
a206 5
void	pcmcia_read_cis(struct pcmcia_softc *);
void	pcmcia_check_cis_quirks(struct pcmcia_softc *);
void	pcmcia_print_cis(struct pcmcia_softc *);
int	pcmcia_scan_cis(struct device * dev,
	    int (*) (struct pcmcia_tuple *, void *), void *);
d238 2
a239 2
int	pcmcia_ccr_read(struct pcmcia_function *, int);
void	pcmcia_ccr_write(struct pcmcia_function *, int, int);
d244 4
a247 4
void	pcmcia_function_init(struct pcmcia_function *,
	    struct pcmcia_config_entry *);
int	pcmcia_function_enable(struct pcmcia_function *);
void	pcmcia_function_disable(struct pcmcia_function *);
d253 2
a254 2
int	pcmcia_io_map(struct pcmcia_function *, int, bus_addr_t,
	    bus_size_t, struct pcmcia_io_handle *, int *);
d275 3
a277 3
void	*pcmcia_intr_establish(struct pcmcia_function *, int,
	    int (*) (void *), void *, char *);
void 	pcmcia_intr_disestablish(struct pcmcia_function *, void *);
@


1.12.4.4
log
@Sync the SMP branch with 3.3
@
text
@d241 2
a242 2
#define	pcmcia_mfc(sc)	(SIMPLEQ_FIRST(&(sc)->card.pf_head) &&		\
    SIMPLEQ_NEXT(SIMPLEQ_FIRST(&(sc)->card.pf_head), pf_list))
@


1.11
log
@Support detaching.  Support CIS-less cards.  Style police.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.10 1999/07/20 21:51:21 fgsch Exp $	*/
d147 4
a150 9
	/*
	 * Use int32_t for manufacturer and product so that they can
	 * hold the id value found in card CIS and special value that
	 * indicates no id was found.
	 */
	int32_t		manufacturer;
#define	PCMCIA_VENDOR_INVALID	-1
	int32_t		product;
#define	PCMCIA_PRODUCT_INVALID		-1
d179 2
a180 2
	int32_t manufacturer;
	int32_t product;
d187 2
a188 2
	int32_t manufacturer;
	int32_t product;
@


1.10
log
@Add wdc pcmcia controller. As the other new ATA code, it needs to be
uncommented.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.9 1999/05/27 13:36:55 niklas Exp $	*/
d120 1
d139 1
d263 6
@


1.9
log
@Revert accidentally committed stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.7 1999/01/28 04:58:32 fgsch Exp $	*/
d255 3
@


1.8
log
@A Sound+SCSI card
@
text
@a133 1
	int		irq;
@


1.7
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmciavar.h,v 1.6 1998/09/11 10:47:15 fgsch Exp $	*/
d134 1
@


1.6
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d40 2
d181 8
d206 1
@


1.5
log
@$OpenBSD$
@
text
@d1 3
a3 1
/*	$OpenBSD: pcmciavar.h,v 1.4 1997/03/01 22:42:59 niklas Exp $	*/
d5 1
a5 2
 * Copyright (c) 1995,1996 John T. Kohl.  All rights reserved.
 * Copyright (c) 1993, 1994 Stefan Grefen.  All rights reserved.
d11 1
a11 1
 *    notice, this list of conditions and the following dipclaimer.
d17 1
a17 1
 *	This product includes software developed by Charles Hannum.
a30 1
 *
a31 1
 /* derived from scsicconf.[ch] writenn by Julian Elischer et al */
d33 2
a34 2
#ifndef	_PCMCIA_PCMCIAVAR_H_
#define _PCMCIA_PCMCIAVAR_H_ 1
a35 3
#include <sys/queue.h>
#include <sys/select.h>
#include <machine/cpu.h>
d38 1
a38 33
/*
 * The following documentation tries to describe the relationship between the
 * various structures defined in this file:
 *
 * each adapter type has a pcmcia_adapter struct. This describes the adapter and
 *    identifies routines that can be called to use the adapter.
 * each device type has a pcmcia_device struct. This describes the device and
 *    identifies routines that can be called to use the device.
 * each existing device position (pcmciabus + port)
 *    can be described by a pcmcia_link struct.
 *    Only port positions that actually have devices, have a pcmcia_link
 *    structure assigned. so in effect each device has pcmcia_link struct.
 *    The pcmcia_link structure contains information identifying both the
 *    device driver and the adapter driver for that port on that pcmcia bus,
 *    and can be said to 'link' the two.
 * each individual pcmcia bus has an array that points to all the pcmcia_link
 *    structs associated with that pcmcia bus. Slots with no device have
 *    a NULL pointer.
 * each individual device also knows the address of it's own pcmcia_link
 *    structure.
 *
 *				-------------
 *
 * The key to all this is the pcmcia_link structure which associates all the 
 * other structures with each other in the correct configuration.  The
 * pcmcia_link is the connecting information that allows each part of the 
 * pcmcia system to find the associated other parts.
 */


struct pcmcia_link;
struct pcmcia_conf;
struct pcmcia_adapter;
d41 1
a41 3
 * These entrypoints are called by the high-end drivers to get services from
 * whatever low-end drivers they are attached to each adapter type has one of
 * these statically allocated.
d43 6
a48 26
struct pcmcia_funcs {
/* 4 map io range */
	int (*pcmcia_map_io) __P((struct pcmcia_link *, u_int, u_int, int));
/* 8 map memory window */
	int (*pcmcia_map_mem) __P((struct pcmcia_link *, bus_space_tag_t,
				   caddr_t, u_int, u_int, int));
/*12 map interrupt */
	int (*pcmcia_map_intr) __P((struct pcmcia_link *, int, int));
/*16 power on/off etc */
	int (*pcmcia_service) __P((struct pcmcia_link *, int, void *, int));
};

struct pcmciabus_link {			/* Link back to the bus we are on */
	/* Bus specific configure    */
	int (*bus_config) __P((struct pcmcia_link *, struct device *,
			       struct pcmcia_conf *, struct cfdata *));
	/* Bus specific unconfigure  */
	int (*bus_unconfig) __P((struct pcmcia_link *));
	/* Bus specific probe */
	int (*bus_probe) __P((struct device *, void *,
			       void *, struct pcmcia_link *));
	/* Bus specific search	     */
	int (*bus_search) __P((struct device *, void *, cfprint_t));
	/* initialize scratch        */
	int (*bus_init) __P((struct device *, struct cfdata *,
			     void *, struct pcmcia_adapter *, int));
a49 58
#define PCMCIA_BUS_INIT(a,b,c,d,e,f) \
	((*(a)->bus_link->bus_init)((b),(c),(d),(e),(f)))
#define PCMCIA_BUS_SEARCH(a,b,c,d) \
	((*(a)->bus_link->bus_search)((b),(c),(d)))
#define PCMCIA_BUS_PROBE(a,b,c,d,e) \
	((*(a)->bus_link->bus_probe)((b),(c),(d),(e)))
#define PCMCIA_BUS_CONFIG(a,b,c,d,e) \
	((*(a)->bus_link->bus_config)((b),(c),(d),(e)))
#define PCMCIA_BUS_UNCONFIG(a,b) \
	((*(a)->bus_link->bus_unconfig)((b)))


/*
 * One of these goes at the front of each chip controller's softc, right
 * after the struct device.
 */
struct pcmcia_adapter {
	struct pcmcia_funcs *chip_link;
	struct pcmciabus_link *bus_link;
	bus_space_tag_t pa_memt;	/* mem access handle */
        void *adapter_softc;
	caddr_t scratch_mem;		/* pointer to scratch window */
	int scratch_memsiz;		/* size of scratch window    */
	bus_space_handle_t scratch_memh;/* bus memory handle */
	int scratch_inuse;		/* window in use             */
	int nslots;			/* # of slots controlled */
};

#define PCMCIA_MAP_ATTR		0x0100 /* for memory only */
#define PCMCIA_MAP_8		0x0100 /* for io only */
#define PCMCIA_MAP_16		0x0200
#define PCMCIA_UNMAP		0x0400
#define PCMCIA_PHYSICAL_ADDR    0x0800
#define PCMCIA_UNMAP_ALL	0x0c00
#define PCMCIA_FIXED_WIN    	0x1000
#define PCMCIA_LAST_WIN	        0x0010
#define PCMCIA_FIRST_WIN	0x0020
#define PCMCIA_ANY_WIN		0x0030

#define	PCMCIA_OP_RESET	    	0x0000
#define	PCMCIA_OP_POWER  	0x0001
#define	PCMCIA_OP_STATUS  	0x0002
#define	PCMCIA_OP_GETREGS  	0x0003
#define	PCMCIA_OP_WAIT  	0x0004

#define PCMCIA_POWER_ON		0x0001
#define PCMCIA_POWER_5V		0x0002
#define PCMCIA_POWER_3V		0x0004
#define PCMCIA_POWER_AUTO	0x0008

#define PCMCIA_CARD_PRESENT     0x0001
#define PCMCIA_BATTERY		0x0002
#define PCMCIA_WRITE_PROT	0x0004
#define PCMCIA_READY		0x0008
#define PCMCIA_POWER		0x0010
#define PCMCIA_POWER_PP		0x0020
#define PCMCIA_CARD_IS_MAPPED   0x1000
#define PCMCIA_CARD_INUSE       0x2000
d51 1
d54 1
a54 4
 * This structure describes the connection between an adapter driver and
 * a device driver, and is used by each to call services provided by
 * the other, and to allow generic pcmcia glue code to call these services
 * as well.
d56 121
a176 23
struct pcmcia_link {
       	u_char	pcmciabus;		/* the Nth pcmciabus */
       	u_char	slot;			/* slot of this dev */
       	u_char	flags;			
#define CARD_IS_MAPPED         0x01
#define PCMCIA_ATTACH          0x02
#define PCMCIA_REATTACH        0x04
#define PCMCIA_SLOT_INUSE      0x08
#define PCMCIA_ATTACH_TYPE     (PCMCIA_ATTACH|PCMCIA_REATTACH)
#define PCMCIA_SLOT_EVENT	0x80
#define PCMCIA_SLOT_OPEN	0x40
        u_char	opennings;

	u_char    iowin;
	u_char    memwin;
	u_char    intr;
	u_char    dummy;
       	struct	pcmcia_adapter *adapter;	/* adapter entry points etc. */
       	struct	pcmciadevs *device;	/* device entry points etc. */
	struct pcmciabus_softc *bus;	/* parent pcmcia bus */
	struct device *devp;		/* pointer to configured device */
       	void	*fordriver;		/* for private use by the driver */
	struct selinfo	pcmcialink_sel;	/* for select users */
a178 85
/*
 * One of these is allocated and filled in for each pcmcia bus.
 * it holds pointers to allow the pcmcia bus to get to the driver
 * it also has a template entry which is the prototype struct
 * supplied by the adapter driver, this is used to initialise
 * the others, before they have the rest of the fields filled in
 */
struct pcmciabus_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	bus_space_tag_t sc_memt;
	struct pcmcia_link *sc_link[4];	/* up to 4 slots per bus */
	struct pcmcia_adapter *sc_driver;
};

struct pcmcia_conf {
    int irq_share:1; 
    int irq_level:1; /* 1 level */
    int irq_pulse:1; /* 1  pulse */
    int irq_vend:1;
    int irq_iock:1;
    int irq_berr:1;
    int irq_nmi:1;
    int iocard:1;
    u_char iowin;
    u_char memwin;
    u_char irq_num;
    u_char cfgtype;
#define CFGENTRYID     0x20
#define CFGENTRYMASK   (CFGENTRYID|(CFGENTRYID-1))
#define DOSRESET       0x40
    int cfg_regmask;
    int irq_mask;
    int cfg_off;
    struct iowin {
	int start;
	int len;
	int flags;
    }io[4];
    struct memwin {
	int start; 
	int caddr;
	int len;
	int flags;
    }mem[4];
    char driver_name[8][4]; /* up to four different functions on a card */
    int  unitid;
    int  cfgid;
};

struct pcmcia_device {
    char *name;
    int (*pcmcia_config) __P((struct pcmcia_link *, struct device *,
			      struct pcmcia_conf *, struct cfdata *));
    int (*pcmcia_probe) __P((struct device *, void *,
			     void *, struct pcmcia_link *));
    int (*pcmcia_insert) __P((struct pcmcia_link *, struct device *,
			      struct cfdata *));
    int	(*pcmcia_remove) __P((struct pcmcia_link *, struct device *));
};

#define MAX_CIS_NAMELEN	64		/* version info string len */

struct pcmcia_cardinfo {
    char manufacturer[MAX_CIS_NAMELEN];
    char model[MAX_CIS_NAMELEN];
    char add_info1[MAX_CIS_NAMELEN];
    char add_info2[MAX_CIS_NAMELEN];
};

struct pcmciadevs {
        char *devname;
        int flags;              /* 1 show my comparisons during boot(debug) */
#define PC_SHOWME       0x01
        char *manufacturer;
        char *model;
        char *add_inf1;
        char *add_inf2;
        void *param;
        struct pcmcia_device *dev;
};

/*
 * PCMCIA driver attach arguments
 */
d180 84
a263 46
	struct pcmcia_cardinfo *paa_cardinfo; /* card that we're looking at */
	struct pcmcia_link *paa_link;	/* this nexus */
	int paa_bestmatch;		/* best match so far */
	int paa_matchonly;		/* only do matches, don't attach */
	void	*paa_aux;		/* driver specific */
};

struct pcmciabus_attach_args {
	bus_space_tag_t pba_iot;
	bus_space_tag_t pba_memt;
	bus_space_tag_t pba_memh;
	int	pba_maddr;
	int	pba_msize;
	void	*pba_aux;		/* driver specific */
};

#ifdef _KERNEL
extern int pcmcia_add_device __P((struct pcmciadevs *));
extern int pcmcia_get_cf __P((struct pcmcia_link *, u_char *, int, int,
			      struct pcmcia_conf *));
extern int pcmcia_targmatch __P((struct device *, struct cfdata *, void *));
#endif

/* in pcmcia_conf.c, available for user space too: */
extern int pcmcia_get_cisver1 __P((struct pcmcia_link *, u_char *, int,
				   char *, char *, char *, char *));
void parse_cfent  __P((u_char *, int, int, struct pcmcia_conf *));
void read_cfg_info __P((u_char *, int, struct pcmcia_conf *));
void pcmcia_getstr __P((char *buf, u_char **, u_char *));
extern int   pcmcia_configure __P((struct device *, void *, void *));
extern int   pcmcia_register __P((void *, struct pcmciabus_link *,
				  struct pcmcia_funcs *, int));
extern int pcmcia_read_cis __P((struct pcmcia_link *, u_char *, int, int));
extern int pcmcia_strcmp __P((const char *, const char *, int, const char *));
extern int pcmcia_matchvalue __P((const struct pcmcia_cardinfo *,
				  struct pcmciadevs *));
extern int pcmcia_bestvalue __P((struct pcmcia_cardinfo *,
				 struct pcmciadevs *,
				 int,
				 struct pcmciadevs **));
extern int pcmcia_slave_match __P((struct device *,
				   void *,
				   void *aux,
				   struct pcmciadevs *,
				   int));
#endif /* _PCMCIA_PCMCIAVAR_H_ */
@


1.4
log
@Corrected ISA memory mapping errors that caused PCMCIA to be broken.
Thanks to Angelos who helped my debug this.
@
text
@d1 1
a1 1
/*	$Id: pcmciavar.h,v 1.3 1996/11/28 23:28:17 niklas Exp $	*/
@


1.3
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 1
a1 1
/*	$Id: pcmciavar.h,v 1.2 1996/11/12 20:31:01 niklas Exp $	*/
d295 1
@


1.2
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$Id: pcmciavar.h,v 1.1 1996/04/29 14:17:39 hvozda Exp $	*/
d40 1
a40 1
#include <machine/bus.old.h>
d85 1
a85 1
	int (*pcmcia_map_mem) __P((struct pcmcia_link *, bus_chipset_tag_t,
d127 2
a128 2
	bus_chipset_tag_t pa_bc;	/* bus chipset */
        void *          adapter_softc;
d131 1
a131 1
	bus_mem_handle_t scratch_memh;	/* bus memory handle */
d208 2
a209 1
	bus_chipset_tag_t sc_bc;
d293 2
a294 1
	bus_chipset_tag_t pba_bc;
@


1.1
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d1 1
a1 1
/*	$Id: pcmciavar.h,v 1.18 1996/04/15 23:55:47 jtk Exp $	*/
d40 1
a40 1
#include <machine/bus.h>
@
