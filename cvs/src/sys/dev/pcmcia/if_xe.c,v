head	1.59;
access;
symbols
	OPENBSD_6_2:1.59.0.2
	OPENBSD_6_2_BASE:1.59
	OPENBSD_6_1:1.59.0.4
	OPENBSD_6_1_BASE:1.59
	OPENBSD_6_0:1.58.0.2
	OPENBSD_6_0_BASE:1.58
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.52.0.4
	OPENBSD_5_8_BASE:1.52
	OPENBSD_5_7:1.46.0.4
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.44.0.4
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.41.0.4
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.41.0.2
	OPENBSD_5_3_BASE:1.41
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.39.0.2
	OPENBSD_4_9_BASE:1.39
	OPENBSD_4_8:1.38.0.4
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.38.0.2
	OPENBSD_4_7_BASE:1.38
	OPENBSD_4_6:1.37.0.6
	OPENBSD_4_6_BASE:1.37
	OPENBSD_4_5:1.37.0.2
	OPENBSD_4_5_BASE:1.37
	OPENBSD_4_4:1.35.0.4
	OPENBSD_4_4_BASE:1.35
	OPENBSD_4_3:1.35.0.2
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.33.0.2
	OPENBSD_4_2_BASE:1.33
	OPENBSD_4_1:1.32.0.4
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.2
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.31.0.2
	OPENBSD_3_9_BASE:1.31
	OPENBSD_3_8:1.29.0.2
	OPENBSD_3_8_BASE:1.29
	OPENBSD_3_7:1.28.0.2
	OPENBSD_3_7_BASE:1.28
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.26.0.2
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.25.0.4
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.25.0.2
	OPENBSD_3_3_BASE:1.25
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.23.0.4
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.2
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.17.0.2
	OPENBSD_2_8_BASE:1.17
	OPENBSD_2_7:1.14.0.2
	OPENBSD_2_7_BASE:1.14
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9;
locks; strict;
comment	@ * @;


1.59
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.58;
commitid	VyLWTsbepAOk7VQM;

1.58
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.57;
commitid	QHiEhS9DHyE6oiIr;

1.57
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.56;
commitid	J9apD0jq2AjFmqZc;

1.56
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.55;
commitid	B0kwmVGiD5DVx4kv;

1.55
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.54;
commitid	5DvsamK0GblTp8ww;

1.54
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.53;
commitid	eYnPulzvLjDImPCa;

1.53
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.52;
commitid	SaArro4mM2Ab3ure;

1.52
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.51;
commitid	9ERVupAoYqW4Iok9;

1.51
date	2015.06.29.10.24.14;	author dlg;	state Exp;
branches;
next	1.50;
commitid	dPBZlySYlNWIDDe3;

1.50
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.49;
commitid	MVWrtktB46JRxFWT;

1.49
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.48;
commitid	0fL6zHGm3fqppVdw;

1.48
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.47;
commitid	hN5bFCE56DrAjl99;

1.47
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.46;
commitid	p4LJxGKbi0BU2cG6;

1.46
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.45;
commitid	yM2VFFhpDTeFQlve;

1.45
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.44;
commitid	nYggAidK85QbUFh2;

1.44
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.43;
commitid	OBNa5kfxQ2UXoiIw;

1.43
date	2013.11.26.09.50.33;	author mpi;	state Exp;
branches;
next	1.42;

1.42
date	2013.08.07.01.06.40;	author bluhm;	state Exp;
branches;
next	1.41;

1.41
date	2012.11.28.01.15.33;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.39;

1.39
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2009.02.09.19.14.31;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.03.01.31.24;	author brad;	state Exp;
branches;
next	1.35;

1.35
date	2007.09.11.13.39.33;	author gilles;	state Exp;
branches;
next	1.34;

1.34
date	2007.09.07.18.21.40;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.06.09.43.44;	author henning;	state Exp;
branches;
next	1.32;

1.32
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.31;

1.31
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2005.11.09.05.56.05;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.27.17.04.56;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.26;

1.26
date	2003.10.22.09.58.46;	author jmc;	state Exp;
branches;
next	1.25;

1.25
date	2003.02.11.19.20.28;	author mickey;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.23.4.1;
next	1.22;

1.22
date	2001.07.08.23.38.07;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.06.34.52;	author kjc;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.25.04.05.51;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.21.54.57;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.20.19.39.46;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.16.17.08.08;	author aaron;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.26.20.08.39;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.02.02.17.37;	author bjc;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.24.21.15.33;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.24.21.10.09;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.24.19.43.36;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.02.19.09.59;	author fgsch;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.02.01.17.03.06;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	99.09.16.11.28.42;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	99.08.13.20.36.38;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	99.08.09.03.54.01;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	99.08.08.21.44.43;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.05.19.14.04.04;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.05.18.22.19.44;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.05.18.19.18.21;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.26.07;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.07.04.10.43.27;	author niklas;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	1.11.2.7;

1.11.2.7
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.23.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.23.4.2;

1.23.4.2
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.59
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_xe.c,v 1.58 2016/04/13 10:49:26 mpi Exp $	*/

/*
 * Copyright (c) 1999 Niklas Hallqvist, Brandon Creighton, Job de Haas
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist,
 *	C Stone and Job de Haas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * A driver for Xircom ethernet PC-cards.
 *
 * The driver has been inspired by the xirc2ps_cs.c driver found in Linux'
 * PCMCIA package written by Werner Koch <werner.koch@@guug.de>:
 * [xirc2ps_cs.c wk 14.04.97] (1.31 1998/12/09 19:32:55)
 * I will note that no code was used verbatim from that driver as it is under
 * the much too strong GNU General Public License, it was only used as a
 * "specification" of sorts.
 * Other inspirations have been if_fxp.c, if_ep_pcmcia.c and elink3.c as
 * they were found in OpenBSD 2.4.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

/*
 * Maximum number of bytes to read per interrupt.  Linux recommends
 * somewhere between 2000-22000.
 * XXX This is currently a hard maximum.
 */
#define MAX_BYTES_INTR 12000

#include <dev/mii/miivar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>
#include <dev/pcmcia/if_xereg.h>

#ifdef __GNUC__
#define INLINE	__inline
#else
#define INLINE
#endif	/* __GNUC__ */

#ifdef XEDEBUG

#define XED_CONFIG	0x1
#define XED_MII		0x2
#define XED_INTR	0x4
#define XED_FIFO	0x8

#ifndef XEDEBUG_DEF
#define XEDEBUG_DEF	(XED_CONFIG|XED_INTR)
#endif	/* XEDEBUG_DEF */

int xedebug = XEDEBUG_DEF;

#define DPRINTF(cat, x) if (xedebug & (cat)) printf x

#else	/* XEDEBUG */
#define DPRINTF(cat, x) (void)0
#endif	/* XEDEBUG */

int	xe_pcmcia_match(struct device *, void *, void *);
void	xe_pcmcia_attach(struct device *, struct device *, void *);
int	xe_pcmcia_detach(struct device *, int);
int	xe_pcmcia_activate(struct device *, int);

/*
 * In case this chipset ever turns up out of pcmcia attachments (very
 * unlikely) do the driver splitup.
 */
struct xe_softc {
	struct	device sc_dev;			/* Generic device info */
	u_int32_t	sc_flags;		/* Misc. flags */
	void	*sc_ih;				/* Interrupt handler */
	struct	arpcom sc_arpcom;		/* Ethernet common part */
	struct	ifmedia sc_media;		/* Media control */
	struct	mii_data sc_mii;		/* MII media information */
	int	sc_all_mcasts;			/* Receive all multicasts */
	bus_space_tag_t sc_bst;			/* Bus cookie */
	bus_space_handle_t	sc_bsh;		/* Bus I/O handle */
	bus_size_t	sc_offset;		/* Offset of registers */
	u_int8_t	sc_rev;			/* Chip revision */
};

#define XEF_MOHAWK	0x001
#define XEF_DINGO	0x002
#define XEF_MODEM	0x004
#define XEF_UNSUPPORTED 0x008
#define XEF_CE		0x010
#define XEF_CE2		0x020
#define XEF_CE3		0x040
#define XEF_CE33	0x080
#define XEF_CE56	0x100

struct xe_pcmcia_softc {
	struct	xe_softc sc_xe;			/* Generic device info */
	struct	pcmcia_mem_handle sc_pcmh;	/* PCMCIA memspace info */
	int	sc_mem_window;			/* mem window */
	struct	pcmcia_io_handle sc_pcioh;	/* iospace info */
	int	sc_io_window;			/* io window info */
	struct	pcmcia_function *sc_pf;		/* PCMCIA function */
};

/* Autoconfig definition of driver back-end */
struct cfdriver xe_cd = {
	NULL, "xe", DV_IFNET
};

struct cfattach xe_pcmcia_ca = {
	sizeof (struct xe_pcmcia_softc), xe_pcmcia_match, xe_pcmcia_attach,
	xe_pcmcia_detach, xe_pcmcia_activate
};

void	xe_cycle_power(struct xe_softc *);
void	xe_full_reset(struct xe_softc *);
void	xe_init(struct xe_softc *);
int	xe_intr(void *);
int	xe_ioctl(struct ifnet *, u_long, caddr_t);
int	xe_mdi_read(struct device *, int, int);
void	xe_mdi_write(struct device *, int, int, int);
int	xe_mediachange(struct ifnet *);
void	xe_mediastatus(struct ifnet *, struct ifmediareq *);
int	xe_pcmcia_funce_enaddr(struct device *, u_int8_t *);
u_int32_t xe_pcmcia_interpret_manfid(struct device *);
int	xe_pcmcia_lan_nid_ciscallback(struct pcmcia_tuple *, void *);
int	xe_pcmcia_manfid_ciscallback(struct pcmcia_tuple *, void *);
u_int16_t xe_get(struct xe_softc *);
void	xe_reset(struct xe_softc *);
void	xe_set_address(struct xe_softc *);
void	xe_start(struct ifnet *);
void	xe_statchg(struct device *);
void	xe_stop(struct xe_softc *);
void	xe_watchdog(struct ifnet *);
#ifdef XEDEBUG
void	xe_reg_dump(struct xe_softc *);
#endif	/* XEDEBUG */

int
xe_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;
	
	if (pa->pf->function != PCMCIA_FUNCTION_NETWORK)
		return (0);

	switch (pa->manufacturer) {
	case PCMCIA_VENDOR_COMPAQ:
	case PCMCIA_VENDOR_COMPAQ2:
		return (0);

	case PCMCIA_VENDOR_INTEL:
	case PCMCIA_VENDOR_XIRCOM:
		/* XXX Per-productid checking here. */
		return (1);

	default:
		return (0);
	}
}

void
xe_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)self;
	struct xe_softc *sc = &psc->sc_xe;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_function *pf = pa->pf;
	struct pcmcia_config_entry *cfe = NULL;
	struct ifnet *ifp;
	u_int8_t myla[ETHER_ADDR_LEN], *enaddr = NULL;
	int state = 0;
	struct pcmcia_mem_handle pcmh;
	int ccr_window;
	bus_size_t ccr_offset;
	const char *intrstr;

	psc->sc_pf = pf;

#if 0
	/* Figure out what card we are. */
	sc->sc_flags = xe_pcmcia_interpret_manfid(parent);
#endif
	if (sc->sc_flags & XEF_UNSUPPORTED) {
		printf(": card unsupported\n");
		goto bad;
	}

	/* Tell the pcmcia framework where the CCR is. */
	pf->ccr_base = 0x800;
	pf->ccr_mask = 0x67;

	/* Fake a cfe. */
	SIMPLEQ_FIRST(&pa->pf->cfe_head) = cfe = (struct pcmcia_config_entry *)
	    malloc(sizeof *cfe, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (!cfe) {
		printf(": function enable failed\n");
		return;
	}

	/*
	 * XXX Use preprocessor symbols instead.
	 * Enable ethernet & its interrupts, wiring them to -INT
	 * No I/O base.
	 */
	cfe->number = 0x5;
	cfe->flags = 0;		/* XXX Check! */
	cfe->iftype = PCMCIA_IFTYPE_IO;
	cfe->num_iospace = 0;
	cfe->num_memspace = 0;
	cfe->irqmask = 0x8eb0;

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		goto bad;
	}

	state++;

	if (pcmcia_io_alloc(pa->pf, 0, 16, 16, &psc->sc_pcioh)) {
		printf(": io allocation failed\n");
		goto bad;
	}

	state++;

	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, 0, 16, &psc->sc_pcioh,
		&psc->sc_io_window)) {
		printf(": can't map io space\n");
		goto bad;
	}
	sc->sc_bst = psc->sc_pcioh.iot;
	sc->sc_bsh = psc->sc_pcioh.ioh;
	sc->sc_offset = 0;

	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, 16);

#if 0
	if (pcmcia_mem_alloc(pf, 16, &psc->sc_pcmh)) {
		printf(": pcmcia memory allocation failed\n");
		goto bad;
	}
	state++;

	if (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, 0x300, 16, &psc->sc_pcmh,
	    &sc->sc_offset, &psc->sc_mem_window)) {
		printf(": pcmcia memory mapping failed\n");
		goto bad;
	}

	sc->sc_bst = psc->sc_pcmh.memt;
	sc->sc_bsh = psc->sc_pcmh.memh;
#endif

	/* Figure out what card we are. */
	sc->sc_flags = xe_pcmcia_interpret_manfid(parent);

	/*
	 * Configuration as advised by DINGO documentation.
	 * We only know about this flag after the manfid interpretation.
	 * Dingo has some extra configuration registers in the CCR space.
	 */
	if (sc->sc_flags & XEF_DINGO) {
		if (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE_DINGO, &pcmh)) {
			DPRINTF(XED_CONFIG, ("bad mem alloc\n"));
			goto bad;
		}

		if (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,
		    PCMCIA_CCR_SIZE_DINGO, &pcmh, &ccr_offset,
		    &ccr_window)) {
			DPRINTF(XED_CONFIG, ("bad mem map\n"));
			pcmcia_mem_free(pf, &pcmh);
			goto bad;
		}

		bus_space_write_1(pcmh.memt, pcmh.memh,
		    ccr_offset + PCMCIA_CCR_DCOR0, PCMCIA_CCR_DCOR0_SFINT);
		bus_space_write_1(pcmh.memt, pcmh.memh,
		    ccr_offset + PCMCIA_CCR_DCOR1,
		    PCMCIA_CCR_DCOR1_FORCE_LEVIREQ | PCMCIA_CCR_DCOR1_D6);
		bus_space_write_1(pcmh.memt, pcmh.memh,
		    ccr_offset + PCMCIA_CCR_DCOR2, 0);
		bus_space_write_1(pcmh.memt, pcmh.memh,
		    ccr_offset + PCMCIA_CCR_DCOR3, 0);
		bus_space_write_1(pcmh.memt, pcmh.memh,
		    ccr_offset + PCMCIA_CCR_DCOR4, 0);

		/* We don't need them anymore and can free them (I think). */
		pcmcia_mem_unmap(pf, ccr_window);
		pcmcia_mem_free(pf, &pcmh);
	}

	/*
	 * Try to get the ethernet address from FUNCE/LAN_NID tuple.
	 */
	if (xe_pcmcia_funce_enaddr(parent, myla))
		enaddr = myla;
	ifp = &sc->sc_arpcom.ac_if;
	if (enaddr)
		bcopy(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);
	else {
		printf(", unable to get ethernet address\n");
		goto bad;
	}

	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = xe_ioctl;
	ifp->if_start = xe_start;
	ifp->if_watchdog = xe_watchdog;

	/* Establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc,
	    sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf(", couldn't establish interrupt\n");
		goto bad;
	}
	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
	printf("%s%s: address %s\n", *intrstr ? ", " : "", intrstr,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Reset and initialize the card. */
	xe_full_reset(sc);

	/* Initialize our media structures and probe the phy. */
	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = xe_mdi_read;
	sc->sc_mii.mii_writereg = xe_mdi_write;
	sc->sc_mii.mii_statchg = xe_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, xe_mediachange,
	    xe_mediastatus);
	DPRINTF(XED_MII | XED_CONFIG,
	    ("bmsr %x\n", xe_mdi_read(&sc->sc_dev, 0, 1)));
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL)
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO, 0,
		    NULL);
	ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);

	/*
	 * Attach the interface.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

	/*
	 * Reset and initialize the card again for DINGO (as found in Linux
	 * driver).  Without this Dingo will get a watchdog timeout the first
	 * time.  The ugly media tickling seems to be necessary for getting
	 * autonegotiation to work too.
	 */
	if (sc->sc_flags & XEF_DINGO) {
		xe_full_reset(sc);
		xe_init(sc);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_AUTO);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER | IFM_NONE);
		xe_stop(sc);
	}
	return;

bad:
	if (state > 2)
		pcmcia_io_unmap(pf, psc->sc_io_window);
	if (state > 1)
		pcmcia_io_free(pf, &psc->sc_pcioh);
	if (state > 0)
		pcmcia_function_disable(pa->pf);
	free(cfe, M_DEVBUF, 0);
}

int
xe_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct xe_pcmcia_softc *psc = (struct xe_pcmcia_softc *)dev;
	struct xe_softc *sc = &psc->sc_xe;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;

	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
}

int
xe_pcmcia_activate(dev, act)
	struct device *dev;
	int act;
{
	struct xe_pcmcia_softc *sc = (struct xe_pcmcia_softc *)dev;
	struct ifnet *ifp = &sc->sc_xe.sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		if (ifp->if_flags & IFF_RUNNING)
			xe_stop(&sc->sc_xe);
		ifp->if_flags &= ~IFF_RUNNING;
		if (sc->sc_xe.sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);
		sc->sc_xe.sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_xe.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    xe_intr, sc, sc->sc_xe.sc_dev.dv_xname);
		/* XXX this is a ridiculous */
		xe_reset(&sc->sc_xe);
		if ((ifp->if_flags & IFF_UP) == 0)
			xe_stop(&sc->sc_xe);
		break;
	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_RUNNING;
		if (sc->sc_xe.sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);
		sc->sc_xe.sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

/*
 * XXX These two functions might be OK to factor out into pcmcia.c since
 * if_sm_pcmcia.c uses similar ones.
 */
int
xe_pcmcia_funce_enaddr(parent, myla)
	struct device *parent;
	u_int8_t *myla;
{
	/* XXX The Linux driver has more ways to do this in case of failure. */
	return (pcmcia_scan_cis(parent, xe_pcmcia_lan_nid_ciscallback, myla));
}

int
xe_pcmcia_lan_nid_ciscallback(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	u_int8_t *myla = arg;
	int i;

	if (tuple->code == PCMCIA_CISTPL_FUNCE) {
		if (tuple->length < 2)
			return (0);

		switch (pcmcia_tuple_read_1(tuple, 0)) {
		case PCMCIA_TPLFE_TYPE_LAN_NID:
			if (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN)
				return (0);
			break;

		case 0x02:
			/*
			 * Not sure about this, I don't have a CE2
			 * that puts the ethernet addr here.
			 */
		 	if (pcmcia_tuple_read_1(tuple, 1) != 13)
				return (0);
			break;

		default:
			return (0);
		}

		for (i = 0; i < ETHER_ADDR_LEN; i++)
			myla[i] = pcmcia_tuple_read_1(tuple, i + 2);
		return (1);
	}

	/* Yet another spot where this might be. */
	if (tuple->code == 0x89) {
		pcmcia_tuple_read_1(tuple, 1);
		for (i = 0; i < ETHER_ADDR_LEN; i++)
			myla[i] = pcmcia_tuple_read_1(tuple, i + 2);
		return (1);
	}
	return (0);
}

u_int32_t
xe_pcmcia_interpret_manfid (parent)
	struct device *parent;
{
	u_int32_t flags = 0;
	struct pcmcia_softc *psc = (struct pcmcia_softc *)parent;
	char *tptr;

	if (!pcmcia_scan_cis(parent, xe_pcmcia_manfid_ciscallback, &flags))
		return (XEF_UNSUPPORTED);

	if (flags & XEF_CE) {
		tptr = memchr(psc->card.cis1_info[2], 'C',
		    strlen(psc->card.cis1_info[2]));
		/* XXX not sure if other CE2s hide "CE2" in different places */
		if (tptr && *(tptr + 1) == 'E' && *(tptr + 2) == '2') {
			flags ^= (XEF_CE | XEF_UNSUPPORTED);
			flags |= XEF_CE2;
		}
	}
	return (flags);
}

int
xe_pcmcia_manfid_ciscallback(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	u_int32_t *flagsp = arg;
	u_int8_t media, product;

	if (tuple->code == PCMCIA_CISTPL_MANFID) {
		if (tuple->length < 2)
			return (0);

		media = pcmcia_tuple_read_1(tuple, 3);
		product = pcmcia_tuple_read_1(tuple, 4);

		if (!(product & XEPROD_CREDITCARD) ||
		    !(media & XEMEDIA_ETHER)) {
			*flagsp |= XEF_UNSUPPORTED;
			return (1);
		}

		if (media & XEMEDIA_MODEM)
			*flagsp |= XEF_MODEM;

		switch (product & XEPROD_IDMASK) {
		case 1:
			/* XXX Can be CE2 too (we double-check later). */
			*flagsp |= XEF_CE | XEF_UNSUPPORTED;
			break;
		case 2:
			*flagsp |= XEF_CE2;
			break;
		case 3:
			if (!(*flagsp & XEF_MODEM))
				*flagsp |= XEF_MOHAWK;
			*flagsp |= XEF_CE3;
			break;
		case 4:
			*flagsp |= XEF_CE33;
			break;
		case 5:
			*flagsp |= XEF_CE56 | XEF_MOHAWK;
			break;
		case 6:
		case 7:
			*flagsp |= XEF_CE56 | XEF_MOHAWK | XEF_DINGO;
			break;
		default:
			*flagsp |= XEF_UNSUPPORTED;
			break;
		}

		return (1);
	}
	return (0);
}

int
xe_intr(arg)
	void *arg;
{
	struct xe_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int8_t esr, rsr, isr, rx_status, savedpage;
	u_int16_t tx_status, recvcount = 0, tempint;

	ifp->if_timer = 0;	/* turn watchdog timer off */

	if (sc->sc_flags & XEF_MOHAWK) {
		/* Disable interrupt (Linux does it). */
		bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,
		    0);
	}

	savedpage =
	    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + PR);

	PAGE(sc, 0);
	esr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ESR);
	isr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + ISR0);
	rsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);
				
	/* Check to see if card has been ejected. */
	if (isr == 0xff) {
		printf("%s: interrupt for dead card\n", sc->sc_dev.dv_xname);
		goto end;
	}

	PAGE(sc, 40);
	rx_status =
	    bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RXST0);
	tx_status =
	    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + TXST0);

	/*
	 * XXX Linux writes to RXST0 and TXST* here.  My CE2 works just fine
	 * without it, and I can't see an obvious reason for it.
	 */

	PAGE(sc, 0);
	while (esr & FULL_PKT_RCV) {
		if (!(rsr & RSR_RX_OK))
			break;

		/* Compare bytes read this interrupt to hard maximum. */
		if (recvcount > MAX_BYTES_INTR) {
			DPRINTF(XED_INTR,
			    ("%s: too many bytes this interrupt\n",
			    sc->sc_dev.dv_xname));
			ifp->if_iqdrops++;
			/* Drop packet. */
			bus_space_write_2(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + DO0, DO_SKIP_RX_PKT);
		}
		tempint = xe_get(sc);
		recvcount += tempint;
		esr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
		    sc->sc_offset + ESR);
		rsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
		    sc->sc_offset + RSR);
	}
	
	/* Packet too long? */
	if (rsr & RSR_TOO_LONG) {
		ifp->if_ierrors++;
		DPRINTF(XED_INTR,
		    ("%s: packet too long\n", sc->sc_dev.dv_xname));
	}

	/* CRC error? */
	if (rsr & RSR_CRCERR) {
		ifp->if_ierrors++;
		DPRINTF(XED_INTR,
		    ("%s: CRC error detected\n", sc->sc_dev.dv_xname));
	}

	/* Alignment error? */
	if (rsr & RSR_ALIGNERR) {
		ifp->if_ierrors++;
		DPRINTF(XED_INTR,
		    ("%s: alignment error detected\n", sc->sc_dev.dv_xname));
	}

	/* Check for rx overrun. */
	if (rx_status & RX_OVERRUN) {
		bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,
		    CLR_RX_OVERRUN);
		DPRINTF(XED_INTR, ("overrun cleared\n"));
	}
			
	/* Try to start more packets transmitting. */
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		xe_start(ifp);

	/* Detected excessive collisions? */
	if (tx_status & EXCESSIVE_COLL) {
		DPRINTF(XED_INTR,
		    ("%s: excessive collisions\n", sc->sc_dev.dv_xname));
		bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,
		    RESTART_TX);
		ifp->if_oerrors++;
	}
	
	if (tx_status & TX_ABORT)
		ifp->if_oerrors++;

end:
	/* Reenable interrupts. */
	PAGE(sc, savedpage);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR,
	    ENABLE_INT);

	return (1);
}

u_int16_t
xe_get(sc)
	struct xe_softc *sc;
{
	u_int8_t rsr;
	struct mbuf *top, **mp, *m;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int16_t pktlen, len, recvcount = 0;
	u_int8_t *data;
	
	PAGE(sc, 0);
	rsr = bus_space_read_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RSR);

	pktlen =
	    bus_space_read_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + RBC0) &
	    RBC_COUNT_MASK;
	if (pktlen == 0) {
		/*
		 * XXX At least one CE2 sets RBC0 == 0 occasionally, and only
		 * when MPE is set.  It is not known why.
		 */
		return (0);
	}
	recvcount += pktlen;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (recvcount);
	m->m_pkthdr.len = pktlen;
	len = MHLEN;
	top = 0;
	mp = &top;
	
	while (pktlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (recvcount);
			}
			len = MLEN;
		}
		if (pktlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (!(m->m_flags & M_EXT)) {
				m_freem(m);
				m_freem(top);
				return (recvcount);
			}
			len = MCLBYTES;
		}
		if (!top) {
			caddr_t newdata = (caddr_t)ALIGN(m->m_data +
			    sizeof (struct ether_header)) -
			    sizeof (struct ether_header);
			len -= newdata - m->m_data;
			m->m_data = newdata;
		}
		len = min(pktlen, len);

		data = mtod(m, u_int8_t *);
		if (len > 1) {
		        len &= ~1;
			bus_space_read_raw_multi_2(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + EDP, data, len);
		} else
			*data = bus_space_read_1(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + EDP);
		m->m_len = len;
		pktlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	/* Skip Rx packet. */
	bus_space_write_2(sc->sc_bst, sc->sc_bsh, sc->sc_offset + DO0,
	    DO_SKIP_RX_PKT);

	ml_enqueue(&ml, top);
	if_input(ifp, &ml);

	return (recvcount);
}


/*
 * Serial management for the MII.
 * The DELAY's below stem from the fact that the maximum frequency
 * acceptable on the MDC pin is 2.5 MHz and fast processors can easily
 * go much faster than that.
 */

/* Let the MII serial management be idle for one period. */
static INLINE void xe_mdi_idle(struct xe_softc *);
static INLINE void
xe_mdi_idle(sc)
	struct xe_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;

	/* Drive MDC low... */
	bus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);
	DELAY(1);

	/* and high again. */
	bus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);
	DELAY(1);
}

/* Pulse out one bit of data. */
static INLINE void xe_mdi_pulse(struct xe_softc *, int);
static INLINE void
xe_mdi_pulse(sc, data)
	struct xe_softc *sc;
	int data;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;
	u_int8_t bit = data ? MDIO_HIGH : MDIO_LOW;

	/* First latch the data bit MDIO with clock bit MDC low...*/
	bus_space_write_1(bst, bsh, offset + GP2, bit | MDC_LOW);
	DELAY(1);

	/* then raise the clock again, preserving the data bit. */
	bus_space_write_1(bst, bsh, offset + GP2, bit | MDC_HIGH);
	DELAY(1);
}

/* Probe one bit of data. */
static INLINE int xe_mdi_probe(struct xe_softc *sc);
static INLINE int
xe_mdi_probe(sc)
	struct xe_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;
	u_int8_t x;

	/* Pull clock bit MDCK low... */
	bus_space_write_1(bst, bsh, offset + GP2, MDC_LOW);
	DELAY(1);

	/* Read data and drive clock high again. */
	x = bus_space_read_1(bst, bsh, offset + GP2) & MDIO;
	bus_space_write_1(bst, bsh, offset + GP2, MDC_HIGH);
	DELAY(1);

	return (x);
}

/* Pulse out a sequence of data bits. */
static INLINE void xe_mdi_pulse_bits(struct xe_softc *, u_int32_t, int);
static INLINE void
xe_mdi_pulse_bits(sc, data, len)
	struct xe_softc *sc;
	u_int32_t data;
	int len;
{
	u_int32_t mask;

	for (mask = 1 << (len - 1); mask; mask >>= 1)
		xe_mdi_pulse(sc, data & mask);
}

/* Read a PHY register. */
int
xe_mdi_read(self, phy, reg)
	struct device *self;
	int phy;
	int reg;
{
	struct xe_softc *sc = (struct xe_softc *)self;
	int i;
	u_int32_t mask;
	u_int32_t data = 0;

	PAGE(sc, 2);
	for (i = 0; i < 32; i++)	/* Synchronize. */
		xe_mdi_pulse(sc, 1);
	xe_mdi_pulse_bits(sc, 0x06, 4); /* Start + Read opcode */
	xe_mdi_pulse_bits(sc, phy, 5);	/* PHY address */
	xe_mdi_pulse_bits(sc, reg, 5);	/* PHY register */
	xe_mdi_idle(sc);		/* Turn around. */
	xe_mdi_probe(sc);		/* Drop initial zero bit. */

	for (mask = 1 << 15; mask; mask >>= 1)
		if (xe_mdi_probe(sc))
			data |= mask;
	xe_mdi_idle(sc);

	DPRINTF(XED_MII,
	    ("xe_mdi_read: phy %d reg %d -> %x\n", phy, reg, data));
	return (data);
}

/* Write a PHY register. */
void
xe_mdi_write(self, phy, reg, value)
	struct device *self;
	int phy;
	int reg;
	int value;
{
	struct xe_softc *sc = (struct xe_softc *)self;
	int i;

	PAGE(sc, 2);
	for (i = 0; i < 32; i++)	/* Synchronize. */
		xe_mdi_pulse(sc, 1);
	xe_mdi_pulse_bits(sc, 0x05, 4); /* Start + Write opcode */
	xe_mdi_pulse_bits(sc, phy, 5);	/* PHY address */
	xe_mdi_pulse_bits(sc, reg, 5);	/* PHY register */
	xe_mdi_pulse_bits(sc, 0x02, 2); /* Turn around. */
	xe_mdi_pulse_bits(sc, value, 16);	/* Write the data */
	xe_mdi_idle(sc);		/* Idle away. */

	DPRINTF(XED_MII,
	    ("xe_mdi_write: phy %d reg %d val %x\n", phy, reg, value));
}

void
xe_statchg(self)
	struct device *self;
{
}

/*
 * Change media according to request.
 */
int
xe_mediachange(ifp)
	struct ifnet *ifp;
{
	if (ifp->if_flags & IFF_UP)
		xe_init(ifp->if_softc);
	return (0);
}

/*
 * Notify the world which media we're using.
 */
void
xe_mediastatus(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct xe_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

void
xe_reset(sc)
	struct xe_softc *sc;
{
	int s;

	s = splnet();
	xe_stop(sc);
	xe_full_reset(sc);
	xe_init(sc);
	splx(s);
}

void
xe_watchdog(ifp)
	struct ifnet *ifp;
{
	struct xe_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	xe_reset(sc);
}

void
xe_stop(sc)
	register struct xe_softc *sc;
{
	/* Disable interrupts. */
	PAGE(sc, 0);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + CR, 0);

	PAGE(sc, 1);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + IMR0, 0);
	
	/* Power down, wait. */
	PAGE(sc, 4);
	bus_space_write_1(sc->sc_bst, sc->sc_bsh, sc->sc_offset + GP1, 0);
	DELAY(40000);
	
	/* Cancel watchdog timer. */
	sc->sc_arpcom.ac_if.if_timer = 0;
}

void
xe_init(sc)
	struct xe_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	DPRINTF(XED_CONFIG, ("xe_init\n"));

	s = splnet();

	xe_set_address(sc);

	/* Set current media. */
	mii_mediachg(&sc->sc_mii);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);
}

/*
 * Start outputting on the interface.
 * Always called as splnet().
 */
void
xe_start(ifp)
	struct ifnet *ifp;
{
	struct xe_softc *sc = ifp->if_softc;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;
	unsigned int s, len, pad = 0;
	struct mbuf *m0, *m;
	u_int16_t space;

	/* Don't transmit if interface is busy or not running. */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	/* Peek at the next packet. */
	m0 = ifq_deq_begin(&ifp->if_snd);
	if (m0 == NULL)
		return;

	/* We need to use m->m_pkthdr.len, so require the header. */
	if (!(m0->m_flags & M_PKTHDR))
		panic("xe_start: no header mbuf");

	len = m0->m_pkthdr.len;

	/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN)
		pad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;

	PAGE(sc, 0);
	space = bus_space_read_2(bst, bsh, offset + TSO0) & 0x7fff;
	if (len + pad + 2 > space) {
		ifq_deq_rollback(&ifp->if_snd, m0);
		DPRINTF(XED_FIFO,
		    ("%s: not enough space in output FIFO (%d > %d)\n",
		    sc->sc_dev.dv_xname, len + pad + 2, space));
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m0);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/*
	 * Do the output at splhigh() so that an interrupt from another device
	 * won't cause a FIFO underrun.
	 */
	s = splhigh();

	bus_space_write_2(bst, bsh, offset + TSO2, (u_int16_t)len + pad + 2);
	bus_space_write_2(bst, bsh, offset + EDP, (u_int16_t)len + pad);
	for (m = m0; m; ) {
		if (m->m_len > 1)
			bus_space_write_raw_multi_2(bst, bsh, offset + EDP,
			    mtod(m, u_int8_t *), m->m_len & ~1);
		if (m->m_len & 1)
			bus_space_write_1(bst, bsh, offset + EDP,
			    *(mtod(m, u_int8_t *) + m->m_len - 1));
		m0 = m_free(m);
		m = m0;
	}
	if (sc->sc_flags & XEF_MOHAWK)
		bus_space_write_1(bst, bsh, offset + CR, TX_PKT | ENABLE_INT);
	else {
		for (; pad > 1; pad -= 2)
			bus_space_write_2(bst, bsh, offset + EDP, 0);
		if (pad == 1)
			bus_space_write_1(bst, bsh, offset + EDP, 0);
	}

	splx(s);

	ifp->if_timer = 5;
}

int
xe_ioctl(ifp, command, data)
	struct ifnet *ifp;
	u_long command;
	caddr_t data;
{
	struct xe_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		xe_init(sc);
		break;

	case SIOCSIFFLAGS:
		sc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;
				
		PAGE(sc, 0x42);
		if ((ifp->if_flags & IFF_PROMISC) ||
		    (ifp->if_flags & IFF_ALLMULTI))
			bus_space_write_1(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + SWC1,
			    SWC1_PROMISC | SWC1_MCAST_PROM);
		else
			bus_space_write_1(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + SWC1, 0);

		/*
		 * If interface is marked up and not running, then start it.
		 * If it is marked down and running, stop it.
		 * XXX If it's up then re-initialize it. This is so flags
		 * such as IFF_PROMISC are handled.
		 */
		if (ifp->if_flags & IFF_UP) {
			xe_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				xe_stop(sc);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		sc->sc_all_mcasts = (ifp->if_flags & IFF_ALLMULTI) ? 1 : 0;
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (!sc->sc_all_mcasts &&
			    !(ifp->if_flags & IFF_PROMISC))
				xe_set_address(sc);

			/*
			 * xe_set_address() can turn on all_mcasts if we run
			 * out of space, so check it again rather than else {}.
			 */
			if (sc->sc_all_mcasts)
				xe_init(sc);
			error = 0;
		}
		break;

	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error =
		    ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, command);
		break;

	default:
		error = ENOTTY;
	}

	splx(s);
	return (error);
}

void
xe_set_address(sc)
	struct xe_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;
	struct arpcom *arp = &sc->sc_arpcom;
	struct ether_multi *enm;
	struct ether_multistep step;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i, page, pos, num;

	PAGE(sc, 0x50);
	for (i = 0; i < 6; i++) {
		bus_space_write_1(bst, bsh, offset + IA + i,
		    sc->sc_arpcom.ac_enaddr[(sc->sc_flags & XEF_MOHAWK) ?
		    5 - i : i]);
	}

	if (arp->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		sc->sc_all_mcasts=1;
	} else if (arp->ac_multicnt > 0) {
		if (arp->ac_multicnt > 9) {
			PAGE(sc, 0x42);
			bus_space_write_1(sc->sc_bst, sc->sc_bsh,
			    sc->sc_offset + SWC1,
			    SWC1_PROMISC | SWC1_MCAST_PROM);
			return;
		}

		ETHER_FIRST_MULTI(step, arp, enm);

		pos = IA + 6;
		for (page = 0x50, num = arp->ac_multicnt; num > 0 && enm;
		    num--) {
			for (i = 0; i < 6; i++) {
				bus_space_write_1(bst, bsh, offset + pos,
				    enm->enm_addrlo[
				    (sc->sc_flags & XEF_MOHAWK) ? 5 - i : i]);

				if (++pos > 15) {
					pos = IA;
					page++;
					PAGE(sc, page);
				}
			}
		}
	}
}

void
xe_cycle_power(sc)
	struct xe_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;

	PAGE(sc, 4);
	DELAY(1);
	bus_space_write_1(bst, bsh, offset + GP1, 0);
	DELAY(40000);
	if (sc->sc_flags & XEF_MOHAWK)
		bus_space_write_1(bst, bsh, offset + GP1, POWER_UP);
	else
		/* XXX What is bit 2 (aka AIC)? */
		bus_space_write_1(bst, bsh, offset + GP1, POWER_UP | 4);
	DELAY(20000);
}

void
xe_full_reset(sc)
	struct xe_softc *sc;
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;

	/* Do an as extensive reset as possible on all functions. */
	xe_cycle_power(sc);
	bus_space_write_1(bst, bsh, offset + CR, SOFT_RESET);
	DELAY(20000);
	bus_space_write_1(bst, bsh, offset + CR, 0);
	DELAY(20000);
	if (sc->sc_flags & XEF_MOHAWK) {
		PAGE(sc, 4);
		/*
		 * Drive GP1 low to power up ML6692 and GP2 high to power up
		 * the 10MHz chip.  XXX What chip is that?  The phy?
		 */
		bus_space_write_1(bst, bsh, offset + GP0,
		    GP1_OUT | GP2_OUT | GP2_WR);
	}
	DELAY(500000);

	/* Get revision information.  XXX Symbolic constants. */
	sc->sc_rev = bus_space_read_1(bst, bsh, offset + BV) &
	    ((sc->sc_flags & XEF_MOHAWK) ? 0x70 : 0x30) >> 4;

	/* Media selection.  XXX Maybe manual overriding too? */
	if (!(sc->sc_flags & XEF_MOHAWK)) {
		PAGE(sc, 4);
		/*
		 * XXX I have no idea what this really does, it is from the
		 * Linux driver.
		 */
		bus_space_write_1(bst, bsh, offset + GP0, GP1_OUT);
	}
	DELAY(40000);

	/* Setup the ethernet interrupt mask. */
	PAGE(sc, 1);
	bus_space_write_1(bst, bsh, offset + IMR0,
	    ISR_TX_OFLOW | ISR_PKT_TX | ISR_MAC_INT | /* ISR_RX_EARLY | */
	    ISR_RX_FULL | ISR_RX_PKT_REJ | ISR_FORCED_INT);
#if 0
	bus_space_write_1(bst, bsh, offset + IMR0, 0xff);
#endif
	if (!(sc->sc_flags & XEF_DINGO))
		/* XXX What is this?  Not for Dingo at least. */
		bus_space_write_1(bst, bsh, offset + IMR1, 1);

	/*
	 * Disable source insertion.
	 * XXX Dingo does not have this bit, but Linux does it unconditionally.
	 */
	if (!(sc->sc_flags & XEF_DINGO)) {
		PAGE(sc, 0x42);
		bus_space_write_1(bst, bsh, offset + SWC0, 0x20);
	}

	/* Set the local memory dividing line. */
	if (sc->sc_rev != 1) {
		PAGE(sc, 2);
		/* XXX Symbolic constant preferrable. */
		bus_space_write_2(bst, bsh, offset + RBS0, 0x2000);
	}

	xe_set_address(sc);

	/*
	 * Apparently the receive byte pointer can be bad after a reset, so
	 * we hardwire it correctly.
	 */
	PAGE(sc, 0);
	bus_space_write_2(bst, bsh, offset + DO0, DO_CHG_OFFSET);

	/* Setup ethernet MAC registers. XXX Symbolic constants. */
	PAGE(sc, 0x40);
	bus_space_write_1(bst, bsh, offset + RX0MSK,
	    PKT_TOO_LONG | CRC_ERR | RX_OVERRUN | RX_ABORT | RX_OK);
	bus_space_write_1(bst, bsh, offset + TX0MSK,
	    CARRIER_LOST | EXCESSIVE_COLL | TX_UNDERRUN | LATE_COLLISION |
	    SQE | TX_ABORT | TX_OK);
	if (!(sc->sc_flags & XEF_DINGO))
		/* XXX From Linux, dunno what 0xb0 means. */
		bus_space_write_1(bst, bsh, offset + TX1MSK, 0xb0);
	bus_space_write_1(bst, bsh, offset + RXST0, 0);
	bus_space_write_1(bst, bsh, offset + TXST0, 0);
	bus_space_write_1(bst, bsh, offset + TXST1, 0);

	/* Enable MII function if available. */
	if (LIST_FIRST(&sc->sc_mii.mii_phys)) {
		PAGE(sc, 2);
		bus_space_write_1(bst, bsh, offset + MSR,
		    bus_space_read_1(bst, bsh, offset + MSR) | SELECT_MII);
		DELAY(20000);
	} else {
		PAGE(sc, 0);
				
		/* XXX Do we need to do this? */
		PAGE(sc, 0x42);
		bus_space_write_1(bst, bsh, offset + SWC1, SWC1_AUTO_MEDIA);
		DELAY(50000);

		/* XXX Linux probes the media here. */
	}

	/* Configure the LED registers. */
	PAGE(sc, 2);

	/* XXX This is not good for 10base2. */
	bus_space_write_1(bst, bsh, offset + LED,
	    LED_TX_ACT << LED1_SHIFT | LED_10MB_LINK << LED0_SHIFT);
	if (sc->sc_flags & XEF_DINGO)
		bus_space_write_1(bst, bsh, offset + LED3,
		    LED_100MB_LINK << LED3_SHIFT);

	/* Enable receiver and go online. */
	PAGE(sc, 0x40);
	bus_space_write_1(bst, bsh, offset + CMD0, ENABLE_RX | ONLINE);

#if 0
	/* XXX Linux does this here - is it necessary? */
	PAGE(sc, 1);
	bus_space_write_1(bst, bsh, offset + IMR0, 0xff);
	if (!(sc->sc_flags & XEF_DINGO))
		/* XXX What is this?  Not for Dingo at least. */
		bus_space_write_1(bst, bsh, offset + IMR1, 1);
#endif

       /* Enable interrupts. */
	PAGE(sc, 0);
	bus_space_write_1(bst, bsh, offset + CR, ENABLE_INT);

	/* XXX This is pure magic for me, found in the Linux driver. */
	if ((sc->sc_flags & (XEF_DINGO | XEF_MODEM)) == XEF_MODEM) {
		if ((bus_space_read_1(bst, bsh, offset + 0x10) & 0x01) == 0)
			/* Unmask the master interrupt bit. */
			bus_space_write_1(bst, bsh, offset + 0x10, 0x11);
	}

	/*
	 * The Linux driver says this:
	 * We should switch back to page 0 to avoid a bug in revision 0
	 * where regs with offset below 8 can't be read after an access
	 * to the MAC registers.
	 */
	PAGE(sc, 0);
}

#ifdef XEDEBUG
void
xe_reg_dump(sc)
	struct xe_softc *sc;
{
	int page, i;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	bus_size_t offset = sc->sc_offset;

	printf("%x: Common registers: ", sc->sc_dev.dv_xname);
	for (i = 0; i < 8; i++) {
		printf(" %2.2x", bus_space_read_1(bst, bsh, offset + i));
	}
	printf("\n");

	for (page = 0; page < 8; page++) {
		printf("%s: Register page %2.2x: ", sc->sc_dev.dv_xname, page);
		PAGE(sc, page);
		for (i = 8; i < 16; i++) {
			printf(" %2.2x",
			    bus_space_read_1(bst, bsh, offset + i));
		}
		printf("\n");
	}

	for (page = 0x40; page < 0x5f; page++) {
		if (page == 0x43 || (page >= 0x46 && page <= 0x4f) ||
		    (page >= 0x51 && page <= 0x5e))
			continue;
		printf("%s: Register page %2.2x: ", sc->sc_dev.dv_xname, page);
		PAGE(sc, page);
		for (i = 8; i < 16; i++) {
			printf(" %2.2x",
			    bus_space_read_1(bst, bsh, offset + i));
		}
		printf("\n");
	}
}
#endif	/* XEDEBUG */
@


1.58
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.57 2015/12/08 13:34:22 tedu Exp $	*/
d725 1
a725 1
	if ((tx_status & EXCESSIVE_COLL) && ifp->if_opackets > 0) {
d733 1
a733 1
	if ((tx_status & TX_ABORT) && ifp->if_opackets > 0)
a1151 1
	++ifp->if_opackets;
@


1.57
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.56 2015/11/25 03:09:59 dlg Exp $	*/
a364 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.56
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.55 2015/11/24 13:33:18 mpi Exp $	*/
d361 1
a361 1
	    IFF_BROADCAST | IFF_NOTRAILERS | IFF_SIMPLEX | IFF_MULTICAST;
@


1.55
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.54 2015/11/20 03:35:23 dlg Exp $	*/
d1067 1
a1067 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1088 1
a1088 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
@


1.54
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.53 2015/10/25 13:13:06 mpi Exp $	*/
a60 1
#include <net/if_types.h>
@


1.53
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.52 2015/07/08 07:21:50 mpi Exp $	*/
d1093 1
a1093 1
	IFQ_POLL(&ifp->if_snd, m0);
d1110 1
d1117 1
a1117 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.52
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.51 2015/06/29 10:24:14 dlg Exp $	*/
a1162 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1171 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_arpcom, ifa);
@


1.51
log
@dont double count if_ibytes here, it gets done by something inside
if_input.

from and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.50 2015/06/24 09:40:54 mpi Exp $	*/
d1138 1
a1138 1
		MFREE(m, m0);
@


1.50
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.49 2015/05/19 11:24:01 mpi Exp $	*/
a687 1
		ifp->if_ibytes += tempint;
@


1.49
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.48 2015/05/13 10:42:46 jsg Exp $	*/
a826 1
	ifp->if_ipackets++;
@


1.48
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.47 2015/03/14 03:38:49 jsg Exp $	*/
d754 1
a776 1
	m->m_pkthdr.rcvif = ifp;
d826 1
a826 1
	
d828 3
a830 7
	
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, top, BPF_DIRECTION_IN);
#endif
	
	ether_input_mbuf(ifp, top);
@


1.47
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.46 2014/12/22 02:28:52 tedu Exp $	*/
d774 1
a774 1
	if (m == 0)
d785 1
a785 1
			if (m == 0) {
d1100 1
a1100 1
	if (m0 == 0)
@


1.46
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.45 2014/08/11 12:45:45 mpi Exp $	*/
a59 1
#include <net/if_dl.h>
@


1.45
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.44 2014/07/12 18:48:52 tedu Exp $	*/
a1179 1
#ifdef INET
a1181 1
#endif  /* INET */
@


1.44
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.43 2013/11/26 09:50:33 mpi Exp $	*/
a63 1
#ifdef INET
a64 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a65 1
#endif
@


1.43
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not change the behavior of any driver but if you encounter
any problem, feel free to revert the offending chunk and ping me about
it.

ok naddy@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.42 2013/08/07 01:06:40 bluhm Exp $	*/
d431 1
a431 1
	free(cfe, M_DEVBUF);
@


1.42
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.41 2012/11/28 01:15:33 brad Exp $	*/
d1276 5
a1280 2
		
	if (arp->ac_multicnt > 0) {
a1293 12
			if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
			    sizeof(enm->enm_addrlo)) != 0) {
				/*
				 * The multicast address is really a range;
				 * it's easier just to accept all multicasts.
				 * XXX should we be setting IFF_ALLMULTI here?
				 */
				ifp->if_flags |= IFF_ALLMULTI;
				sc->sc_all_mcasts=1;
				break;
			}

@


1.41
log
@- Use IF_Gbps(1) instead of IF_Mbps(1000)
- Use IF_Mbps() instead of multiplying the link speed by a bare value
- Remove a useless comment as baudrate is already handled properly
- Remove some commented out bits of code
- Use IF_Mbps() instead of the bare value

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.40 2011/07/03 15:47:17 matthew Exp $	*/
a66 1
#include <netinet/in_var.h>
@


1.40
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.39 2010/08/30 20:33:18 deraadt Exp $	*/
a988 1
	/* XXX Update ifp->if_baudrate */
@


1.39
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.38 2009/10/13 19:33:16 pirofti Exp $	*/
a465 7
	case DVACT_ACTIVATE:
		if (sc->sc_xe.sc_ih == NULL) {
			pcmcia_function_enable(sc->sc_pf);
			sc->sc_xe.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
			    xe_intr, sc, sc->sc_xe.sc_dev.dv_xname);
		}
		break;
@


1.38
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.37 2009/02/09 19:14:31 chl Exp $	*/
a422 5

#ifdef notyet
	pcmcia_function_disable(pa->pf);
#endif	/* notyet */

a463 1
	int s;
a464 1
	s = splnet();
d467 16
d486 4
a489 1
		xe_init(&sc->sc_xe);
a490 1

d493 4
a496 3
		if (ifp->if_flags & IFF_RUNNING)
			xe_stop(&sc->sc_xe);
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);
a499 1
	splx(s);
@


1.37
log
@fix uninitialized argument.

Found by LLVM/Clang Static Analyzer.

ok krw@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.36 2008/10/03 01:31:24 brad Exp $	*/
d118 1
a118 1
int	xe_pcmcia_activate(struct device *, enum devact);
d465 1
a465 1
	enum devact act;
@


1.36
log
@Merge xe_ether_ioctl() into xe_ioctl() which was just a handler for
SIOCSIFADDR, now this looks like every other driver. Also return ENOTTY
for unknown ioctl's. Reduces i386 GENERIC by 112 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.35 2007/09/11 13:39:33 gilles Exp $	*/
d225 1
a225 1
	struct pcmcia_config_entry *cfe;
@


1.35
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.34 2007/09/07 18:21:40 fgsch Exp $	*/
a167 1
int	xe_ether_ioctl(struct ifnet *, u_long cmd, caddr_t);
a1165 34
xe_ether_ioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ifaddr *ifa = (struct ifaddr *)data;
	struct xe_softc *sc = ifp->if_softc;

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			xe_init(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif	/* INET */

		default:
			xe_init(sc);
			break;
		}
		break;

	default:
		return (EINVAL);
	}

	return (0);
}

int
d1172 1
d1180 6
a1185 1
		error = xe_ether_ioctl(ifp, command, data);
d1248 1
a1248 1
		error = EINVAL;
d1250 1
@


1.34
log
@sprinkle some M_ZERO love.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.33 2007/06/06 09:43:44 henning Exp $	*/
d252 1
a252 1
	    malloc(sizeof *cfe, M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.33
log
@do not include ipx headers (were not needed in the first place)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.32 2006/03/25 22:41:46 djm Exp $	*/
d252 1
a252 1
	    malloc(sizeof *cfe, M_DEVBUF, M_NOWAIT);
a256 1
	bzero(cfe, sizeof *cfe);
@


1.32
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.31 2005/11/23 11:39:37 mickey Exp $	*/
a69 5
#endif

#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
@


1.31
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.30 2005/11/09 05:56:05 brad Exp $	*/
d840 1
a840 1
		bpf_mtap(ifp->if_bpf, top);
d1136 1
a1136 1
		bpf_mtap(ifp->if_bpf, m0);
@


1.30
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.29 2005/06/08 17:03:01 henning Exp $	*/
d139 1
a139 1
	bus_addr_t	sc_offset;		/* Offset of registers */
d237 1
a237 1
	bus_addr_t ccr_offset;
d863 1
a863 1
	bus_addr_t offset = sc->sc_offset;
d883 1
a883 1
	bus_addr_t offset = sc->sc_offset;
d903 1
a903 1
	bus_addr_t offset = sc->sc_offset;
d1099 1
a1099 1
	bus_addr_t offset = sc->sc_offset;
d1295 1
a1295 1
	bus_addr_t offset = sc->sc_offset;
d1356 1
a1356 1
	bus_addr_t offset = sc->sc_offset;
d1376 1
a1376 1
	bus_addr_t offset = sc->sc_offset;
d1529 1
a1529 1
	bus_addr_t offset = sc->sc_offset;
@


1.29
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.28 2005/01/27 17:04:56 millert Exp $	*/
d1076 1
a1076 1
	s = splimp();
d1216 1
a1216 1
	s = splimp();
@


1.28
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.27 2004/05/12 06:35:11 tedu Exp $	*/
a76 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1179 3
#ifdef NS
	struct ns_addr *ina;
#endif	/* NS */
a1191 15

#ifdef NS
		case AF_NS:
			ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)sc->sc_arpcom.ac_enaddr;
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr, ifp->if_addrlen);
			/* Set new address. */
			xe_init(sc);
			break;
#endif	/* NS */
@


1.27
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.26 2003/10/22 09:58:46 jmc Exp $	*/
d243 1
a243 1

d387 2
a388 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc, "");
d393 3
a395 2

	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.26
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.25 2003/02/11 19:20:28 mickey Exp $	*/
a83 1
#include <net/bpfdesc.h>
@


1.25
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.24 2002/03/14 01:27:01 millert Exp $	*/
d330 1
a330 1
	 * Configuration as adviced by DINGO documentation.
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.23 2001/08/17 21:52:16 deraadt Exp $	*/
d1410 1
a1410 1
		 * the 10Mhz chip.  XXX What chip is that?  The phy?
@


1.23
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.22 2001/07/08 23:38:07 fgsch Exp $	*/
d126 4
a129 4
int	xe_pcmcia_match __P((struct device *, void *, void *));
void	xe_pcmcia_attach __P((struct device *, struct device *, void *));
int	xe_pcmcia_detach __P((struct device *, int));
int	xe_pcmcia_activate __P((struct device *, enum devact));
d178 21
a198 21
void	xe_cycle_power __P((struct xe_softc *));
int	xe_ether_ioctl __P((struct ifnet *, u_long cmd, caddr_t));
void	xe_full_reset __P((struct xe_softc *));
void	xe_init __P((struct xe_softc *));
int	xe_intr __P((void *));
int	xe_ioctl __P((struct ifnet *, u_long, caddr_t));
int	xe_mdi_read __P((struct device *, int, int));
void	xe_mdi_write __P((struct device *, int, int, int));
int	xe_mediachange __P((struct ifnet *));
void	xe_mediastatus __P((struct ifnet *, struct ifmediareq *));
int	xe_pcmcia_funce_enaddr __P((struct device *, u_int8_t *));
u_int32_t xe_pcmcia_interpret_manfid __P((struct device *));
int	xe_pcmcia_lan_nid_ciscallback __P((struct pcmcia_tuple *, void *));
int	xe_pcmcia_manfid_ciscallback __P((struct pcmcia_tuple *, void *));
u_int16_t xe_get __P((struct xe_softc *));
void	xe_reset __P((struct xe_softc *));
void	xe_set_address __P((struct xe_softc *));
void	xe_start __P((struct ifnet *));
void	xe_statchg __P((struct device *));
void	xe_stop __P((struct xe_softc *));
void	xe_watchdog __P((struct ifnet *));
d200 1
a200 1
void	xe_reg_dump __P((struct xe_softc *));
d860 1
a860 1
static INLINE void xe_mdi_idle __P((struct xe_softc *));
d879 1
a879 1
static INLINE void xe_mdi_pulse __P((struct xe_softc *, int));
d900 1
a900 1
static INLINE int xe_mdi_probe __P((struct xe_softc *sc));
d923 1
a923 1
static INLINE void xe_mdi_pulse_bits __P((struct xe_softc *, u_int32_t, int));
@


1.23.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.23 2001/08/17 21:52:16 deraadt Exp $	*/
d126 4
a129 4
int	xe_pcmcia_match(struct device *, void *, void *);
void	xe_pcmcia_attach(struct device *, struct device *, void *);
int	xe_pcmcia_detach(struct device *, int);
int	xe_pcmcia_activate(struct device *, enum devact);
d178 21
a198 21
void	xe_cycle_power(struct xe_softc *);
int	xe_ether_ioctl(struct ifnet *, u_long cmd, caddr_t);
void	xe_full_reset(struct xe_softc *);
void	xe_init(struct xe_softc *);
int	xe_intr(void *);
int	xe_ioctl(struct ifnet *, u_long, caddr_t);
int	xe_mdi_read(struct device *, int, int);
void	xe_mdi_write(struct device *, int, int, int);
int	xe_mediachange(struct ifnet *);
void	xe_mediastatus(struct ifnet *, struct ifmediareq *);
int	xe_pcmcia_funce_enaddr(struct device *, u_int8_t *);
u_int32_t xe_pcmcia_interpret_manfid(struct device *);
int	xe_pcmcia_lan_nid_ciscallback(struct pcmcia_tuple *, void *);
int	xe_pcmcia_manfid_ciscallback(struct pcmcia_tuple *, void *);
u_int16_t xe_get(struct xe_softc *);
void	xe_reset(struct xe_softc *);
void	xe_set_address(struct xe_softc *);
void	xe_start(struct ifnet *);
void	xe_statchg(struct device *);
void	xe_stop(struct xe_softc *);
void	xe_watchdog(struct ifnet *);
d200 1
a200 1
void	xe_reg_dump(struct xe_softc *);
d860 1
a860 1
static INLINE void xe_mdi_idle(struct xe_softc *);
d879 1
a879 1
static INLINE void xe_mdi_pulse(struct xe_softc *, int);
d900 1
a900 1
static INLINE int xe_mdi_probe(struct xe_softc *sc);
d923 1
a923 1
static INLINE void xe_mdi_pulse_bits(struct xe_softc *, u_int32_t, int);
@


1.23.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1410 1
a1410 1
		 * the 10MHz chip.  XXX What chip is that?  The phy?
@


1.22
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.21 2001/06/27 06:34:52 kjc Exp $	*/
d388 1
a388 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc);
d486 2
a487 4
		printf("%s:", sc->sc_xe.sc_dev.dv_xname);
		sc->sc_xe.sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, xe_intr, sc);
		printf("\n");
@


1.21
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.20 2001/06/25 04:05:51 fgsch Exp $	*/
a384 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
@


1.20
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.19 2001/06/23 21:54:57 fgsch Exp $	*/
d385 2
a386 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d740 1
a740 1
	if (ifp->if_snd.ifq_head)
d1116 1
a1116 1
	m0 = ifp->if_snd.ifq_head;
d1139 1
a1139 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.19
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.18 2001/02/20 19:39:46 mickey Exp $	*/
a771 1
	struct ether_header *eh;
a843 2
	eh = mtod(top, struct ether_header *);
	
d849 1
a849 2
	m_adj(top, sizeof(struct ether_header));
	ether_input(ifp, eh, top);
@


1.18
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.17 2000/10/16 17:08:08 aaron Exp $	*/
a85 3

#define ETHER_MIN_LEN 64
#define ETHER_CRC_LEN 4
@


1.17
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.16 2000/08/26 20:08:39 nate Exp $	*/
a422 4
#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif	/* NBPFILTER > 0 */
@


1.16
log
@Add support for detach of xe and aue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.15 2000/06/02 02:17:37 bjc Exp $	*/
d411 2
a412 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.15
log
@make sure we are writing to the correct page; fixes a subtle bug which
was breaking CE2 -- niklas says this fixes all sorts of other stuff too

also, use my real name in copyright notice
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.14 2000/04/24 21:15:33 niklas Exp $	*/
a464 1
	struct mii_softc *msc;
d467 2
a468 3
	for (msc = LIST_FIRST(&sc->sc_mii.mii_phys); msc;
	    msc = LIST_FIRST(&sc->sc_mii.mii_phys))
		rv |= mii_detach(msc, flags);
@


1.14
log
@use mii_detach, now xe detach/attach rocks again
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.11 2000/02/02 19:09:59 fgsch Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Niklas Hallqvist, C Stone, Job de Haas
d1141 1
a1162 1
	PAGE(sc, 0);
@


1.13
log
@Fix promiscuous mode (from martin@@crt.se). Style nits.  Do not look at
instance numbers in mii matching
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.12 2000/04/24 19:43:36 niklas Exp $	*/
d469 2
a470 4
	    msc = LIST_FIRST(&sc->sc_mii.mii_phys)) {
		LIST_REMOVE(msc, mii_list);
		rv |= config_detach(&msc->mii_dev, flags);
	}
@


1.12
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.11 2000/02/02 19:09:59 fgsch Exp $	*/
d407 1
a407 1
	ifmedia_init(&sc->sc_mii.mii_media, 0, xe_mediachange,
d949 1
a949 1
		xe_mdi_pulse (sc, data & mask);
a1280 1
			xe_full_reset(sc);
d1362 1
a1362 1
			    sizeof (enm->enm_addrlo)) != 0) {
d1389 1
a1389 1
xe_cycle_power (sc)
d1409 1
a1409 1
xe_full_reset (sc)
d1417 1
a1417 1
	xe_cycle_power (sc);
d1561 1
a1561 1
xe_reg_dump (sc)
@


1.11
log
@Call xxx_init and xxx_stop on activate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.10 2000/02/01 17:03:06 fgsch Exp $	*/
d507 1
a508 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_xe.sc_ih);
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.18 2001/02/20 19:39:46 mickey Exp $	*/
d4 1
a4 1
 * Copyright (c) 1999 Niklas Hallqvist, Brandon Creighton, Job de Haas
d407 1
a407 1
	ifmedia_init(&sc->sc_mii.mii_media, IFM_IMASK, xe_mediachange,
d411 1
a411 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d422 4
d465 1
d468 5
a472 2
	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
d507 1
a508 1
		pcmcia_function_disable(sc->sc_pf);
d949 1
a949 1
		xe_mdi_pulse(sc, data & mask);
a1142 1
	PAGE(sc, 0);
d1164 1
d1281 1
d1363 1
a1363 1
			    sizeof(enm->enm_addrlo)) != 0) {
d1390 1
a1390 1
xe_cycle_power(sc)
d1410 1
a1410 1
xe_full_reset(sc)
d1418 1
a1418 1
	xe_cycle_power(sc);
d1562 1
a1562 1
xe_reg_dump(sc)
@


1.11.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.11.2.1 2001/05/14 22:26:07 niklas Exp $	*/
d87 3
d388 1
a388 2
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
	IFQ_SET_READY(&ifp->if_snd);
d742 1
a742 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d775 1
d848 2
d855 2
a856 1
	ether_input_mbuf(ifp, top);
d1122 1
a1122 1
	IFQ_POLL(&ifp->if_snd, m0);
d1145 1
a1145 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.11.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.11.2.2 2001/07/04 10:43:27 niklas Exp $	*/
d385 1
d389 1
a389 1
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc, "");
d487 4
a490 2
		sc->sc_xe.sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    xe_intr, sc, sc->sc_xe.sc_dev.dv_xname);
@


1.11.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d126 4
a129 4
int	xe_pcmcia_match(struct device *, void *, void *);
void	xe_pcmcia_attach(struct device *, struct device *, void *);
int	xe_pcmcia_detach(struct device *, int);
int	xe_pcmcia_activate(struct device *, enum devact);
d178 21
a198 21
void	xe_cycle_power(struct xe_softc *);
int	xe_ether_ioctl(struct ifnet *, u_long cmd, caddr_t);
void	xe_full_reset(struct xe_softc *);
void	xe_init(struct xe_softc *);
int	xe_intr(void *);
int	xe_ioctl(struct ifnet *, u_long, caddr_t);
int	xe_mdi_read(struct device *, int, int);
void	xe_mdi_write(struct device *, int, int, int);
int	xe_mediachange(struct ifnet *);
void	xe_mediastatus(struct ifnet *, struct ifmediareq *);
int	xe_pcmcia_funce_enaddr(struct device *, u_int8_t *);
u_int32_t xe_pcmcia_interpret_manfid(struct device *);
int	xe_pcmcia_lan_nid_ciscallback(struct pcmcia_tuple *, void *);
int	xe_pcmcia_manfid_ciscallback(struct pcmcia_tuple *, void *);
u_int16_t xe_get(struct xe_softc *);
void	xe_reset(struct xe_softc *);
void	xe_set_address(struct xe_softc *);
void	xe_start(struct ifnet *);
void	xe_statchg(struct device *);
void	xe_stop(struct xe_softc *);
void	xe_watchdog(struct ifnet *);
d200 1
a200 1
void	xe_reg_dump(struct xe_softc *);
d860 1
a860 1
static INLINE void xe_mdi_idle(struct xe_softc *);
d879 1
a879 1
static INLINE void xe_mdi_pulse(struct xe_softc *, int);
d900 1
a900 1
static INLINE int xe_mdi_probe(struct xe_softc *sc);
d923 1
a923 1
static INLINE void xe_mdi_pulse_bits(struct xe_softc *, u_int32_t, int);
@


1.11.2.5
log
@Sync the SMP branch with 3.3
@
text
@d1410 1
a1410 1
		 * the 10MHz chip.  XXX What chip is that?  The phy?
@


1.11.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d330 1
a330 1
	 * Configuration as advised by DINGO documentation.
@


1.11.2.7
log
@Merge with the trunk
@
text
@d84 1
@


1.10
log
@Enable Intel EE PRO; still need to find a working phy.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.9 1999/09/16 11:28:42 niklas Exp $	*/
d489 1
d496 1
d499 2
d504 3
@


1.9
log
@Do not try to output when there is no space in the FIFO, optimize too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.8 1999/08/13 20:36:38 fgsch Exp $	*/
a218 1
	case PCMCIA_VENDOR_INTEL:
d221 1
@


1.8
log
@Use macros defined in pcmciavar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.7 1999/08/09 03:54:01 fgsch Exp $	*/
d115 1
d1115 1
d1130 14
a1144 1
	len = m0->m_pkthdr.len;
a1150 4
	/* Pad to ETHER_MIN_LEN - ETHER_CRC_LEN. */
	if (len < ETHER_MIN_LEN - ETHER_CRC_LEN)
		pad = ETHER_MIN_LEN - ETHER_CRC_LEN - len;

a1169 3
	for (; pad > 0; pad--)
		bus_space_write_1(bst, bsh, offset + EDP, 0);

d1172 7
@


1.7
log
@XEF_CE3 cards w/o modem are XEF_MOHAWK too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.6 1999/08/08 21:44:43 niklas Exp $	*/
d448 1
a448 2
		pcmcia_chip_io_unmap(pf->sc->pct, pf->sc->pch,
		    psc->sc_io_window);
d450 1
a450 1
		pcmcia_chip_io_free(pf->sc->pct, pf->sc->pch, &psc->sc_pcioh);
@


1.6
log
@Explicitly set ifq_maxlen, ifinit does not get its hand on interfaces
attached later, which pcmcia is able to handle now.  Also print the right
port range.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.5 1999/08/08 01:17:23 niklas Exp $	*/
d623 2
a624 4
			/*
			 * XXX Linux driver suggests this can be Mohawk if
			 * there is no modem function on the card.
			 */
@


1.5
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.4 1999/07/26 05:43:16 deraadt Exp $	*/
d309 2
a327 2
	printf(" port 0x%lx/%d", psc->sc_pcmh.addr, 16);

d387 1
@


1.4
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.3 1999/05/19 14:04:04 niklas Exp $	*/
d130 2
d176 2
a177 1
	sizeof (struct xe_pcmcia_softc), xe_pcmcia_match, xe_pcmcia_attach
d388 8
a395 1
	printf(": address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
a424 9
	/* Establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, xe_intr, sc);
	if (sc->sc_ih == NULL) {
		printf(", couldn't establish interrupt\n");
		goto bad;
	}

	printf("\n");

a438 1

a439 3
	/*
	 * XXX This should be done once the framework has enable/disable hooks.
	 */
d454 51
@


1.3
log
@Make autoneg at boot work. some indent.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.2 1999/05/18 22:19:44 niklas Exp $	*/
d323 2
d373 1
a373 2
		printf("%s: unable to get ethernet address\n",
		    sc->sc_dev.dv_xname);
d400 1
a400 2
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		printf(", no phy found, using auto mode");
a402 1
	}
a414 2
	printf("\n");

d418 1
a418 2
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
d421 2
@


1.2
log
@indent nit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_xe.c,v 1.1 1999/05/18 19:18:21 niklas Exp $	*/
d346 1
a346 1
			ccr_offset + PCMCIA_CCR_DCOR0, PCMCIA_CCR_DCOR0_SFINT);
d348 2
a349 2
			ccr_offset + PCMCIA_CCR_DCOR1,
			PCMCIA_CCR_DCOR1_FORCE_LEVIREQ | PCMCIA_CCR_DCOR1_D6);
d351 1
a351 1
			ccr_offset + PCMCIA_CCR_DCOR2, 0);
d353 1
a353 1
			ccr_offset + PCMCIA_CCR_DCOR3, 0);
d355 1
a355 1
			ccr_offset + PCMCIA_CCR_DCOR4, 0);
d429 2
a430 1
	 * time.
d432 1
a432 1
	if (sc->sc_flags & XEF_DINGO)
d434 6
@


1.1
log
@Xircom ethernet, with some rough ends still, but it can do 100Mbit if tickled.
It is no cardbus code though.  So far tested on CE2 and Realport.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1105 2
a1106 2
				MFREE(m, m0);
				m = m0;
@

