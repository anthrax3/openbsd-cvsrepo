head	1.99;
access;
symbols
	OPENBSD_6_1:1.99.0.8
	OPENBSD_6_1_BASE:1.99
	OPENBSD_6_0:1.99.0.4
	OPENBSD_6_0_BASE:1.99
	OPENBSD_5_9:1.99.0.2
	OPENBSD_5_9_BASE:1.99
	OPENBSD_5_8:1.98.0.4
	OPENBSD_5_8_BASE:1.98
	OPENBSD_5_7:1.97.0.4
	OPENBSD_5_7_BASE:1.97
	OPENBSD_5_6:1.96.0.8
	OPENBSD_5_6_BASE:1.96
	OPENBSD_5_5:1.96.0.6
	OPENBSD_5_5_BASE:1.96
	OPENBSD_5_4:1.96.0.2
	OPENBSD_5_4_BASE:1.96
	OPENBSD_5_3:1.95.0.8
	OPENBSD_5_3_BASE:1.95
	OPENBSD_5_2:1.95.0.6
	OPENBSD_5_2_BASE:1.95
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.4
	OPENBSD_5_0:1.95.0.2
	OPENBSD_5_0_BASE:1.95
	OPENBSD_4_9:1.94.0.2
	OPENBSD_4_9_BASE:1.94
	OPENBSD_4_8:1.93.0.4
	OPENBSD_4_8_BASE:1.93
	OPENBSD_4_7:1.93.0.2
	OPENBSD_4_7_BASE:1.93
	OPENBSD_4_6:1.92.0.6
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.92.0.2
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.90.0.6
	OPENBSD_4_4_BASE:1.90
	OPENBSD_4_3:1.90.0.4
	OPENBSD_4_3_BASE:1.90
	OPENBSD_4_2:1.90.0.2
	OPENBSD_4_2_BASE:1.90
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.88.0.2
	OPENBSD_4_0_BASE:1.88
	OPENBSD_3_9:1.86.0.2
	OPENBSD_3_9_BASE:1.86
	OPENBSD_3_8:1.79.0.2
	OPENBSD_3_8_BASE:1.79
	OPENBSD_3_7:1.78.0.2
	OPENBSD_3_7_BASE:1.78
	OPENBSD_3_6:1.75.0.2
	OPENBSD_3_6_BASE:1.75
	SMP_SYNC_A:1.75
	SMP_SYNC_B:1.75
	OPENBSD_3_5:1.74.0.2
	OPENBSD_3_5_BASE:1.74
	OPENBSD_3_4:1.72.0.2
	OPENBSD_3_4_BASE:1.72
	UBC_SYNC_A:1.67
	OPENBSD_3_3:1.66.0.2
	OPENBSD_3_3_BASE:1.66
	OPENBSD_3_2:1.62.0.2
	OPENBSD_3_2_BASE:1.62
	OPENBSD_3_1:1.59.0.2
	OPENBSD_3_1_BASE:1.59
	UBC_SYNC_B:1.62
	UBC:1.57.0.2
	UBC_BASE:1.57
	OPENBSD_3_0:1.55.0.2
	OPENBSD_3_0_BASE:1.55
	OPENBSD_2_9_BASE:1.43
	OPENBSD_2_9:1.43.0.2
	OPENBSD_2_8:1.31.0.2
	OPENBSD_2_8_BASE:1.31
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.20
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.99
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.98;
commitid	5DvsamK0GblTp8ww;

1.98
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.97;
commitid	p4LJxGKbi0BU2cG6;

1.97
date	2014.11.24.02.03.37;	author brad;	state Exp;
branches;
next	1.96;
commitid	Wmnzf8bGQILqXRTG;

1.96
date	2013.05.09.19.53.48;	author miod;	state Exp;
branches;
next	1.95;

1.95
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.94;

1.94
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.92;

1.92
date	2008.10.04.17.30.59;	author deraadt;	state Exp;
branches;
next	1.91;

1.91
date	2008.09.29.18.45.59;	author deraadt;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.08.18.50.06;	author deraadt;	state Exp;
branches;
next	1.89;

1.89
date	2006.09.22.22.19.53;	author fgsch;	state Exp;
branches;
next	1.88;

1.88
date	2006.07.09.19.37.00;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2006.03.04.04.59.35;	author jsg;	state Exp;
branches;
next	1.86;

1.86
date	2005.12.09.06.23.49;	author uwe;	state Exp;
branches;
next	1.85;

1.85
date	2005.12.05.18.07.27;	author fgsch;	state Exp;
branches;
next	1.84;

1.84
date	2005.11.23.11.39.37;	author mickey;	state Exp;
branches;
next	1.83;

1.83
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.82;

1.82
date	2005.10.22.23.26.06;	author brad;	state Exp;
branches;
next	1.81;

1.81
date	2005.09.19.20.19.02;	author fgsch;	state Exp;
branches;
next	1.80;

1.80
date	2005.09.19.19.03.57;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2005.03.24.01.47.30;	author deraadt;	state Exp;
branches;
next	1.78;

1.78
date	2005.02.07.20.11.43;	author matthieu;	state Exp;
branches;
next	1.77;

1.77
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.76;

1.76
date	2004.12.12.07.05.49;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2004.05.11.04.38.17;	author deraadt;	state Exp;
branches;
next	1.74;

1.74
date	2003.11.17.19.48.51;	author fgsch;	state Exp;
branches;
next	1.73;

1.73
date	2003.10.28.23.45.07;	author fgsch;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.25.17.35.37;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2003.06.13.08.54.35;	author fgsch;	state Exp;
branches;
next	1.70;

1.70
date	2003.06.13.08.49.30;	author pb;	state Exp;
branches;
next	1.69;

1.69
date	2003.06.01.20.18.45;	author fgsch;	state Exp;
branches;
next	1.68;

1.68
date	2003.05.24.19.09.29;	author henning;	state Exp;
branches;
next	1.67;

1.67
date	2003.05.11.09.52.43;	author henning;	state Exp;
branches;
next	1.66;

1.66
date	2003.03.18.23.13.26;	author mickey;	state Exp;
branches;
next	1.65;

1.65
date	2003.01.02.02.18.27;	author fgsch;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.20.15.01.13;	author fgsch;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.10.18.52.02;	author mickey;	state Exp;
branches;
next	1.62;

1.62
date	2002.08.17.21.59.02;	author fgsch;	state Exp;
branches;
next	1.61;

1.61
date	2002.08.08.23.33.43;	author fgsch;	state Exp;
branches;
next	1.60;

1.60
date	2002.05.06.03.38.28;	author pvalchev;	state Exp;
branches;
next	1.59;

1.59
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.58;

1.58
date	2001.12.20.04.17.23;	author fgsch;	state Exp;
branches;
next	1.57;

1.57
date	2001.11.06.21.56.13;	author mickey;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2001.10.25.17.27.25;	author mickey;	state Exp;
branches;
next	1.55;

1.55
date	2001.10.08.14.20.16;	author aaron;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.18.16.50.03;	author aaron;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.18.16.19.01;	author aaron;	state Exp;
branches;
next	1.52;

1.52
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.12.05.54.25;	author fgsch;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.04.05.56.49;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2001.05.28.04.25.59;	author fgsch;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.27.19.50.25;	author fgsch;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.25.05.10.21;	author fgsch;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.22.10.51.35;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.22.09.26.47;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2001.05.22.08.34.27;	author fgsch;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.19.05.32.39;	author fgsch;	state Exp;
branches;
next	1.42;

1.42
date	2001.04.19.05.10.33;	author fgsch;	state Exp;
branches;
next	1.41;

1.41
date	2001.04.18.14.59.31;	author aaron;	state Exp;
branches;
next	1.40;

1.40
date	2001.03.31.15.01.34;	author aaron;	state Exp;
branches;
next	1.39;

1.39
date	2001.03.29.01.39.33;	author aaron;	state Exp;
branches;
next	1.38;

1.38
date	2001.03.27.10.23.44;	author peter;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.13.02.31.37;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.12.05.37.01;	author aaron;	state Exp;
branches;
next	1.35;

1.35
date	2001.02.27.08.41.51;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2001.02.14.17.47.57;	author mickey;	state Exp;
branches;
next	1.33;

1.33
date	2001.01.29.05.37.51;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.16.21.47.49;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.30.20.51.35;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2000.06.26.06.22.00;	author aaron;	state Exp;
branches;
next	1.29;

1.29
date	2000.05.30.14.36.41;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.25.04.48.49;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.19.09.19.43;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.02.18.47.02;	author deraadt;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.02.01.16.59.07;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2000.01.31.22.51.48;	author fgsch;	state Exp;
branches;
next	1.22;

1.22
date	99.12.23.17.07.03;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	99.12.22.21.15.53;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	99.10.31.17.53.47;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	99.08.25.21.56.52;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	99.08.16.16.51.19;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.08.16.08.58.45;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	99.08.16.08.49.05;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	99.08.15.19.10.31;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	99.08.15.05.32.13;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	99.08.13.21.10.48;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	99.07.01.06.29.55;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	99.06.03.06.40.28;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	99.03.26.06.34.28;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	99.01.31.11.28.39;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	99.01.28.04.58.30;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	98.12.04.06.49.58;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.11.06.06.32.15;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	98.11.05.09.12.52;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	98.10.14.07.34.43;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.09.16.36;	author fgsch;	state Exp;
branches;
next	;

1.25.2.1
date	2001.05.14.22.26.06;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.07.04.10.43.23;	author niklas;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2001.11.13.21.10.03;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.25.2.6;

1.25.2.6
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.25.2.7;

1.25.2.7
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.25.2.8;

1.25.2.8
date	2003.05.13.19.35.09;	author ho;	state Exp;
branches;
next	1.25.2.9;

1.25.2.9
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	1.25.2.10;

1.25.2.10
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.25.2.11;

1.25.2.11
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.57.2.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.57.2.2;

1.57.2.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.57.2.3;

1.57.2.3
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.57.2.4;

1.57.2.4
date	2003.05.19.22.19.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.99
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@/*	$OpenBSD: if_ne_pcmcia.c,v 1.98 2015/03/14 03:38:49 jsg Exp $	*/
/*	$NetBSD: if_ne_pcmcia.c,v 1.17 1998/08/15 19:00:04 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/socket.h>

#include <net/if.h>
#include <net/if_media.h>
#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/bus.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <dev/mii/miivar.h>
#include <dev/mii/mii_bitbang.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>

#include <dev/ic/ne2000reg.h>
#include <dev/ic/ne2000var.h>

#include <dev/ic/dl10019var.h>

#include <dev/ic/rtl80x9reg.h>
#include <dev/ic/rtl80x9var.h>

#include <dev/ic/ax88190reg.h>
#include <dev/ic/ax88190var.h>

int	ne_pcmcia_match(struct device *, void *, void *);
void	ne_pcmcia_attach(struct device *, struct device *, void *);
int	ne_pcmcia_detach(struct device *, int);
int	ne_pcmcia_activate(struct device *, int);

int	ne_pcmcia_enable(struct dp8390_softc *);
void	ne_pcmcia_disable(struct dp8390_softc *);

struct ne_pcmcia_softc {
	struct ne2000_softc sc_ne2000;		/* real "ne2000" softc */

	/* PCMCIA-specific goo */
	struct pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o information */
	int sc_asic_io_window;			/* i/o window for ASIC */
	int sc_nic_io_window;			/* i/o window for NIC */
	struct pcmcia_function *sc_pf;		/* our PCMCIA function */
	void *sc_ih;				/* interrupt handle */
};

u_int8_t *
	ne_pcmcia_get_enaddr(struct ne_pcmcia_softc *, int,
	    u_int8_t[ETHER_ADDR_LEN]);
u_int8_t *
	ne_pcmcia_dl10019_get_enaddr(struct ne_pcmcia_softc *,
	    u_int8_t[ETHER_ADDR_LEN]);
int	ne_pcmcia_ax88190_set_iobase(struct ne_pcmcia_softc *);

struct cfattach ne_pcmcia_ca = {
	sizeof(struct ne_pcmcia_softc), ne_pcmcia_match, ne_pcmcia_attach,
	ne_pcmcia_detach, ne_pcmcia_activate
};

const struct ne2000dev {
    u_int16_t manufacturer;
    u_int16_t product;
    char *cis_info[4];
    int function;
    int enet_maddr;
    unsigned char enet_vendor[3];
    int flags;
#define NE2000DVF_AX88190	0x0002	/* chip is ASIX AX88190 */
} ne2000devs[] = {
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_AMBICOM_AMB8002T,
      0, -1, { 0x00, 0x10, 0x7a } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_PREMAX_PE200,
      0, 0x07f0, { 0x00, 0x20, 0xe0 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DIGITAL_DEPCMXX,
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_PLANET_SMARTCOM2000,
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DLINK_DE660,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DLINK_DE660PLUS,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_RPTI_EP400,
      0, -1, { 0x00, 0x40, 0x95 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_RPTI_EP401,
      0, -1, { 0x00, 0x40, 0x95 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_ACCTON_EN2212,
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_ADDTRON_W89C926,
      0, -1, { 0x00, 0x40, 0x33 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_SVEC_COMBOCARD,
      0, -1, { 0x00, 0xe0, 0x98 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_SVEC_LANCARD,
      0, 0x07f0, { 0x00, 0xc0, 0x6c } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_EPSON_EEN10B,
      PCMCIA_CIS_EPSON_EEN10B,
      0, 0x0ff0, { 0x00, 0x00, 0x48 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_EDIMAX_NE2000,
      0, -1, { 0x00, 0x00, 0xb4 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_CNET_NE2000,
      0, -1, { 0x00, 0x80, 0xad } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_CNET_CNF301,
      PCMCIA_CIS_CNET_CNF301,
      0, -1, { 0x00, 0x10, 0x60 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_BILLIONTON_LNT10TN,
      0, -1, { 0x00, 0x00, 0x00 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_NDC_ND5100_E,
      0, -1, { 0x00, 0x80, 0xc6 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_SYNERGY21_S21810,
      0, -1, { 0x00, 0x48, 0x54 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_TAMARACK_NE2000,
      0, -1, { 0x00, 0x47, 0x43 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_GVC_NIC2000P,
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_WISECOM_T210CT,
      0, -1, { 0x00, 0x20, 0x18 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_WISECOM_IPORT,
      0, -1, { 0x00, 0x02, 0xdd } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_AROWANA_FE,
      0, -1, { 0x00, 0x48, 0x54 }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_GVC_NP0335,
      0, -1, { 0x00, 0x40, 0x05 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_RELIA_RE2408T,
      0, -1, { 0x00, 0xc0, 0x0c } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_BILLIONTON_CFLT2,
      0, -1, { 0x00, 0x10, 0x60 } },

    /*
     * You have to add new entries which contains
     * PCMCIA_VENDOR_INVALID and/or PCMCIA_PRODUCT_INVALID
     * in front of this comment.
     *
     * There are cards which use a generic vendor and product id but needs
     * a different handling depending on the cis_info, so ne2000_match
     * needs a table where the exceptions comes first and then the normal
     * product and vendor entries.
     */

    { PCMCIA_VENDOR_GREYCELL, PCMCIA_PRODUCT_GREYCELL_GCS2000,
      PCMCIA_CIS_GREYCELL_GCS2000,
      0, -1, { 0x00, 0x47, 0x43 } },

    { PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x08, 0x00, 0x5a } },

    { PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x00, 0x04, 0xac } },

    { PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x00, 0x06, 0x29 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ECARD_1,
      PCMCIA_CIS_LINKSYS_ECARD_1,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_PCM100,
      PCMCIA_CIS_LINKSYS_PCM100,
      0, -1, { 0x00, 0x04, 0x5a } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
      0, -1, { 0x00, 0x04, 0x5a }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_PLANEX_FNW3600T,
      0, -1, { 0x00, 0x90, 0xcc } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_SVEC_PN650TX,
      0, -1, { 0x00, 0xe0, 0x98 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_TRENDNET_TECF100,
      0, -1, { 0x00, 0x12, 0x0e } },

    /*
     * This entry should be here so that above two cards doesn't
     * match with this.  FNW-3700T won't match above entries due to
     * MAC address check.
     */
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_PLANEX_FNW3700T,
      0, -1, { 0x00, 0x90, 0xcc }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_LINKSYS_ETHERFAST,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_LINKSYS_ETHERFAST,
      0, -1, { 0x00, 0x50, 0xba } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_DLINK_DE650,
      0, -1, { 0x00, 0xe0, 0x98 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_IODATA_PCETTXR,
      0, -1, { 0x00, 0xa0, 0xb0 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x05, 0x5d } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x50, 0xba } },

     { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
       PCMCIA_CIS_DLINK_DFE670TXD,
       0, -1, { 0x00, 0x0d, 0x88 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x13, 0x46 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x40, 0x05 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_TRUST_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_TRUST_COMBO_ECARD,
      0, 0x0120, { 0x20, 0x04, 0x49 } },

    /* Although the comments above say to put VENDOR/PRODUCT INVALID IDs
       above this list, we need to keep this one below the ECARD_1, or else
       both will match the same more-generic entry rather than the more
       specific one above with proper vendor and product IDs. */
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_LINKSYS_ECARD_2,
      0, -1, { 0x00, 0x80, 0xc8 } },

    /*
     * D-Link DE-650 has many minor versions:
     *
     *   CIS information          Manufacturer Product  Note
     * 1 "D-Link, DE-650"             INVALID  INVALID  white card
     * 2 "D-Link, DE-650, Ver 01.00"  INVALID  INVALID  became bare metal
     * 3 "D-Link, DE-650, Ver 01.00"   0x149    0x265   minor change in look
     * 4 "D-Link, DE-650, Ver 01.00"   0x149    0x265   collision LED added
     *
     * While the 1st and the 2nd types should use the "D-Link DE-650" entry,
     * the 3rd and the 4th types should use the "Linksys EtherCard" entry.
     * Therefore, this entry must be below the LINKSYS_ECARD_1.  --itohy
     */
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DLINK_DE650,
      0, 0x0040, { 0x00, 0x80, 0xc8 } },

    /*
     * IO-DATA PCLA/TE and later version of PCLA/T has valid
     * vendor/product ID and it is possible to read MAC address
     * using standard I/O ports.  It also read from CIS offset 0x01c0.
     * On the other hand, earlier version of PCLA/T doesn't have valid
     * vendor/product ID and MAC address must be read from CIS offset
     * 0x0ff0 (i.e., usual ne2000 way to read it doesn't work).
     * And CIS information of earlier and later version of PCLA/T are
     * same except fourth element.  So, for now, we place the entry for
     * PCLA/TE (and later version of PCLA/T) followed by entry
     * for the earlier version of PCLA/T (or, modify to match all CIS
     * information and have three or more individual entries).
     */
    { PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_PCLATE,
      PCMCIA_CIS_IODATA_PCLATE,
      0, -1, { 0x00, 0xa0, 0xb0 } },

    /*
     * This entry should be placed after above PCLA-TE entry.
     * See above comments for detail.
     */
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_IODATA_PCLAT,
      0, 0x0ff0, { 0x00, 0xa0, 0xb0 } },

    { PCMCIA_VENDOR_DAYNA, PCMCIA_PRODUCT_DAYNA_COMMUNICARD_E_1,
      PCMCIA_CIS_DAYNA_COMMUNICARD_E_1,
      0, 0x0110, { 0x00, 0x80, 0x19 } },

    { PCMCIA_VENDOR_DAYNA, PCMCIA_PRODUCT_DAYNA_COMMUNICARD_E_2,
      PCMCIA_CIS_DAYNA_COMMUNICARD_E_2,
      0, -1, { 0x00, 0x80, 0x19 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_PCC_T,
      PCMCIA_CIS_COREGA_ETHER_PCC_T,
      0, -1, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_PCC_TD,
      PCMCIA_CIS_COREGA_ETHER_PCC_TD,
      0, -1, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_II_PCC_T,
      PCMCIA_CIS_COREGA_ETHER_II_PCC_T,
      0, -1, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_II_PCC_TD,
      PCMCIA_CIS_COREGA_ETHER_II_PCC_TD,
      0, -1, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FAST_ETHER_PCC_TX,
      PCMCIA_CIS_COREGA_FAST_ETHER_PCC_TX,
      0, -1, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FETHER_PCC_TXF,
      PCMCIA_CIS_COREGA_FETHER_PCC_TXF,
      0, -1, { 0x00, 0x90, 0x99 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FETHER_PCC_TXD,
      PCMCIA_CIS_COREGA_FETHER_PCC_TXD,
      0, -1, { 0x00, 0x90, 0x99 } },

    { PCMCIA_VENDOR_COMPEX, PCMCIA_PRODUCT_COMPEX_LINKPORT_ENET_B,
      PCMCIA_CIS_COMPEX_LINKPORT_ENET_B,
      0, 0x01c0, { 0x00, 0xa0, 0x0c } },

    { PCMCIA_VENDOR_SMC, PCMCIA_PRODUCT_SMC_EZCARD,
      PCMCIA_CIS_SMC_EZCARD,
      0, 0x01c0, { 0x00, 0xe0, 0x29 } },

    { PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_8041TX,
      PCMCIA_CIS_IODATA_8041TX,
      0, -1, { 0x00, 0x04, 0xe2 } },

    { PCMCIA_VENDOR_SMC, PCMCIA_PRODUCT_SMC_8041,
      PCMCIA_CIS_SMC_8041,
      0, -1, { 0x00, 0x04, 0xe2 } },

    { PCMCIA_VENDOR_SOCKET, PCMCIA_PRODUCT_SOCKET_LP_ETHER_CF,
      PCMCIA_CIS_SOCKET_LP_ETHER_CF,
      0, -1, { 0x00, 0xc0, 0x1b} },

    { PCMCIA_VENDOR_SOCKET, PCMCIA_PRODUCT_SOCKET_LP_ETHER,
      PCMCIA_CIS_SOCKET_LP_ETHER,
      0, -1, { 0x00, 0xc0, 0x1b } },

    { PCMCIA_VENDOR_SOCKET, PCMCIA_PRODUCT_SOCKET_ETHER_CF_10_100,
      PCMCIA_CIS_SOCKET_ETHER_CF_10_100,
      0, -1, { 0x00, 0x12, 0x0e } },

    { PCMCIA_VENDOR_SOCKET, PCMCIA_PRODUCT_SOCKET_ETHER_CF_10_100,
      PCMCIA_CIS_SOCKET_ETHER_CF_10_100,
      0, -1, { 0x00, 0xe0, 0x98 } },

    { PCMCIA_VENDOR_XIRCOM, PCMCIA_PRODUCT_XIRCOM_CFE_10,
      PCMCIA_CIS_XIRCOM_CFE_10,
      0, -1, { 0x00, 0x10, 0xa4 } },

    { PCMCIA_VENDOR_MELCO, PCMCIA_PRODUCT_MELCO_LPC3_TX,
      PCMCIA_CIS_MELCO_LPC3_TX,
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_BUFFALO, PCMCIA_PRODUCT_BUFFALO_LPC_CF_CLT,
      PCMCIA_CIS_INVALID,
      0, -1, { 0x00, 0x07, 0x40 } },

    { PCMCIA_VENDOR_BUFFALO, PCMCIA_PRODUCT_BUFFALO_LPC3_CLT,
      PCMCIA_CIS_INVALID,
      0, -1, { 0x00, 0x07, 0x40 } },

    { PCMCIA_VENDOR_BUFFALO, PCMCIA_PRODUCT_BUFFALO_LPC4_CLX,
      PCMCIA_CIS_INVALID,
      0, -1, { 0x00, 0x40, 0xfa }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_DUAL, PCMCIA_PRODUCT_DUAL_NE2000,
      PCMCIA_CIS_DUAL_NE2000,
      0, 0x0ff0, { 0x00, 0xa0, 0x0c } },

    { PCMCIA_VENDOR_ALLIEDTELESIS, PCMCIA_PRODUCT_ALLIEDTELESIS_LA_PCM,
      PCMCIA_CIS_ALLIEDTELESIS_LA_PCM,
      0, 0x0ff0, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PCM,
      PCMCIA_CIS_KINGSTON_KNE_PCM,
      0, 0x0ff0, { 0xe2, 0x0c, 0x0f } },

    { PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PC2,
      PCMCIA_CIS_KINGSTON_KNE_PC2,
      0, 0x0180, { 0x00, 0xc0, 0xf0 } },

    { PCMCIA_VENDOR_TELECOMDEVICE, PCMCIA_PRODUCT_TELECOMDEVICE_TCD_HPC100,
      PCMCIA_CIS_TELECOMDEVICE_TCD_HPC100,
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_MACNICA, PCMCIA_PRODUCT_MACNICA_ME1_JEIDA,
      PCMCIA_CIS_MACNICA_ME1_JEIDA,
      0, 0x00b8, { 0x08, 0x00, 0x42 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_NETGEAR_FA410TXC,
      0, -1, { 0x00, 0x40, 0xf4 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_NETGEAR_FA410TXC,
      0, -1, { 0x00, 0x48, 0x54 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x40, 0x05 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x11, 0x95 } },

     { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
       PCMCIA_CIS_DLINK_DFE670TXD,
       0, -1, { 0x00, 0x0d, 0x88 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA411,
      PCMCIA_CIS_NETGEAR_FA411,
      0, -1, { 0x00, 0x40, 0xf4 } },

    { PCMCIA_VENDOR_BELKIN, PCMCIA_PRODUCT_BELKIN_F5D5020,
      PCMCIA_CIS_BELKIN_F5D5020,
      0, -1, { 0x00, 0x30, 0xbd } },

#if 0
    /* the rest of these are stolen from the linux pcnet pcmcia device
       driver.  Since I don't know the manfid or cis info strings for
       any of them, they're not compiled in until I do. */
    { "APEX MultiCard",
      0x0000, 0x0000, NULL, NULL, 0,
      0x03f4, { 0x00, 0x20, 0xe5 } },
    { "ASANTE FriendlyNet",
      0x0000, 0x0000, NULL, NULL, 0,
      0x4910, { 0x00, 0x00, 0x94 } },
    { "Danpex EN-6200P2",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0110, { 0x00, 0x40, 0xc7 } },
    { "DataTrek NetCard",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x20, 0xe8 } },
    { "EP-210 Ethernet",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0110, { 0x00, 0x40, 0x33 } },
    { "ELECOM Laneed LD-CDWA",
      0x0000, 0x0000, NULL, NULL, 0,
      0x00b8, { 0x08, 0x00, 0x42 } },
    { "Grey Cell GCS2220",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0000, { 0x00, 0x47, 0x43 } },
    { "Hypertec Ethernet",
      0x0000, 0x0000, NULL, NULL, 0,
      0x01c0, { 0x00, 0x40, 0x4c } },
    { "IBM FME",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0374, { 0x00, 0x04, 0xac } },
    { "IBM FME",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0374, { 0x08, 0x00, 0x5a } },
    { "Katron PE-520",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0110, { 0x00, 0x40, 0xf6 } },
    { "Kingston KNE-PCM/x",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0xc0, 0xf0 } },
    { "Longshine LCS-8534",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0000, { 0x08, 0x00, 0x00 } },
    { "Maxtech PCN2000",
      0x0000, 0x0000, NULL, NULL, 0,
      0x5000, { 0x00, 0x00, 0xe8 } },
    { "NDC Instant-Link",
      0x0000, 0x0000, NULL, NULL, 0,
      0x003a, { 0x00, 0x80, 0xc6 } },
    { "Network General Sniffer",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x00, 0x65 } },
    { "Panasonic VEL211",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x80, 0x45 } },
    { "SCM Ethernet",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x20, 0xcb } },
    { "Socket EA",
      0x0000, 0x0000, NULL, NULL, 0,
      0x4000, { 0x00, 0xc0, 0x1b } },
    { "Volktek NPL-402CT",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0060, { 0x00, 0x40, 0x05 } },
#endif
};

#define	NE2000_NDEVS	(sizeof(ne2000devs) / sizeof(ne2000devs[0]))

#define ne2000_match(card, fct, n) \
((((((card)->manufacturer != PCMCIA_VENDOR_INVALID) && \
    ((card)->manufacturer == ne2000devs[(n)].manufacturer) && \
    ((card)->product != PCMCIA_PRODUCT_INVALID) && \
    ((card)->product == ne2000devs[(n)].product)) || \
   ((ne2000devs[(n)].cis_info[0]) && (ne2000devs[(n)].cis_info[1]) && \
    ((card)->cis1_info[0]) && ((card)->cis1_info[1]) && \
    (strcmp((card)->cis1_info[0], ne2000devs[(n)].cis_info[0]) == 0) && \
    (strcmp((card)->cis1_info[1], ne2000devs[(n)].cis_info[1]) == 0))) && \
  ((fct) == ne2000devs[(n)].function))? \
 &ne2000devs[(n)]:NULL)

int
ne_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;
	int i;

	for (i = 0; i < NE2000_NDEVS; i++) {
		if (ne2000_match(pa->card, pa->pf->number, i))
			return (1);
	}

	return (0);
}

void
ne_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ne_pcmcia_softc *psc = (void *) self;
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const struct ne2000dev *ne_dev;
	const char *intrstr;
	int i;
	u_int8_t myea[6], *enaddr;

	psc->sc_pf = pa->pf;

	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;
	    cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {
#if 0
		/*
		 * Some ne2000 driver's claim to have memory; others don't.
		 * Since I don't care, I don't check.
		 */

		if (cfe->num_memspace != 1) {
			printf(": unexpected number of memory spaces, "
			    " %d should be 1\n", cfe->num_memspace);
			return;
		}
#endif

		if (cfe->num_iospace == 1) {
			if (cfe->iospace[0].length != NE2000_NPORTS) {
				printf(": unexpected I/O space "
				    "configuration\n");
				continue;
			}
		} else if (cfe->num_iospace == 2) {
			/*
			 * Some cards report a separate space for NIC and ASIC.
			 * This make some sense, but we must allocate a single
			 * NE2000_NPORTS-sized chunk, due to brain damaged
			 * address decoders on some of these cards.
			 */
			if (cfe->iospace[0].length + cfe->iospace[1].length !=
			    NE2000_NPORTS) {
#ifdef DIAGNOSTIC
				printf(": unexpected I/O space "
				    "configuration\n");
#endif
				continue;
			}
		} else {
#ifdef DIAGNOSTIC
			printf(": unexpected number of i/o spaces %d"
			    " should be 1 or 2\n", cfe->num_iospace);
#endif
			continue;
		}

		if (pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,
		    NE2000_NPORTS, NE2000_NPORTS, &psc->sc_pcioh)) {
#ifdef DIAGNOSTIC
			printf(": can't allocate I/O space\n");
#endif
			continue;
		}

		break;
	}

	if (cfe == NULL) {
		printf(": no suitable config entry\n");
		goto fail_1;
	}

	dsc->sc_regt = psc->sc_pcioh.iot;
	dsc->sc_regh = psc->sc_pcioh.ioh;

	nsc->sc_asict = psc->sc_pcioh.iot;
	if (bus_space_subregion(dsc->sc_regt, dsc->sc_regh,
	    NE2000_ASIC_OFFSET, NE2000_ASIC_NPORTS, &nsc->sc_asich)) {
		printf(": can't get subregion for asic\n");
		goto fail_2;
	}

#ifdef notyet
	/* Set up power management hooks. */
	dsc->sc_enable = ne_pcmcia_enable;
	dsc->sc_disable = ne_pcmcia_disable;
#endif

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		goto fail_2;
	}

	dsc->sc_enabled = 1;

	/* some cards claim to be io16, but they're lying. */
	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO8, NE2000_NIC_OFFSET,
	    NE2000_NIC_NPORTS, &psc->sc_pcioh, &psc->sc_nic_io_window)) {
		printf(": can't map NIC I/O space\n");
		goto fail_3;
	}

	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, NE2000_ASIC_OFFSET,
	    NE2000_ASIC_NPORTS, &psc->sc_pcioh, &psc->sc_asic_io_window)) {
		printf(": can't map ASIC I/O space\n");
		goto fail_4;
	}

	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, NE2000_NPORTS);

	/*
	 * Read the station address from the board.
	 */
	i = 0;
again:
	enaddr = NULL;			/* Ask ASIC by default */
	for (; i < NE2000_NDEVS; i++) {
		ne_dev = ne2000_match(pa->card, pa->pf->number, i);
		if (ne_dev != NULL) {
			if (ne_dev->enet_maddr >= 0) {
				enaddr = ne_pcmcia_get_enaddr(psc,
				    ne_dev->enet_maddr, myea);
				if (enaddr == NULL)
					continue;
			} else {
				enaddr = ne_pcmcia_dl10019_get_enaddr(psc,
				    myea);
			}
			break;
		}
	}
	if (i == NE2000_NDEVS) {
		printf(": can't match ethernet vendor code\n");
		goto fail_5;
	}

	if (enaddr != NULL) {
		/*
		 * Make sure this is what we expect.
		 */
		if (enaddr[0] != ne_dev->enet_vendor[0] ||
		    enaddr[1] != ne_dev->enet_vendor[1] ||
		    enaddr[2] != ne_dev->enet_vendor[2]) {
			++i;
			goto again;
		}
	}

	if ((ne_dev->flags & NE2000DVF_AX88190) != 0) {
		if (ne_pcmcia_ax88190_set_iobase(psc))
			goto fail_5;

		dsc->sc_mediachange = ax88190_mediachange;
		dsc->sc_mediastatus = ax88190_mediastatus;
		dsc->init_card = ax88190_init_card;
		dsc->stop_card = ax88190_stop_card;
		dsc->sc_media_init = ax88190_media_init;
		dsc->sc_media_fini = ax88190_media_fini;

		nsc->sc_type = NE2000_TYPE_AX88190;
	}

	/*
	 * Check for a Realtek 8019.
	 */
	bus_space_write_1(dsc->sc_regt, dsc->sc_regh, ED_P0_CR,
	    ED_CR_PAGE_0 | ED_CR_STP);
	if (bus_space_read_1(dsc->sc_regt, dsc->sc_regh, NERTL_RTL0_8019ID0)
		== RTL0_8019ID0 &&
	    bus_space_read_1(dsc->sc_regt, dsc->sc_regh, NERTL_RTL0_8019ID1)
		== RTL0_8019ID1) {
		dsc->sc_mediachange = rtl80x9_mediachange;
		dsc->sc_mediastatus = rtl80x9_mediastatus;
		dsc->init_card = rtl80x9_init_card;
		dsc->sc_media_init = rtl80x9_media_init;
	}

	if (nsc->sc_type == NE2000_TYPE_DL10019 ||
	    nsc->sc_type == NE2000_TYPE_DL10022) {
		dsc->sc_mediachange = dl10019_mediachange;
		dsc->sc_mediastatus = dl10019_mediastatus;
		dsc->init_card = dl10019_init_card;
		dsc->stop_card = dl10019_stop_card;
		dsc->sc_media_init = dl10019_media_init;
		dsc->sc_media_fini = dl10019_media_fini;
	}

	/* set up the interrupt */
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, dp8390_intr,
	    dsc, dsc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, psc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);

	if (ne2000_attach(nsc, enaddr))
		goto fail_5;

#if notyet
	pcmcia_function_disable(pa->pf);
#endif
	return;

fail_5:
	/* Unmap ASIC I/O windows. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_asic_io_window);

fail_4:
	/* Unmap NIC I/O windows. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_nic_io_window);

fail_3:
	pcmcia_function_disable(pa->pf);

fail_2:
	/* Free our I/O space. */
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

fail_1:
	psc->sc_nic_io_window = -1;
}

int
ne_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct ne_pcmcia_softc *psc = (struct ne_pcmcia_softc *)dev;
	int error;

	if (psc->sc_nic_io_window == -1)
		/* Nothing to detach. */
		return (0);

	error = ne2000_detach(&psc->sc_ne2000, flags);
	if (error != 0)
		return (error);

	/* Unmap our i/o windows. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_asic_io_window);
	pcmcia_io_unmap(psc->sc_pf, psc->sc_nic_io_window);

	/* Free our i/o space. */
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	return (0);
}

int
ne_pcmcia_activate(dev, act)
	struct device *dev;
	int act;
{
	struct ne_pcmcia_softc *sc = (struct ne_pcmcia_softc *)dev;
	struct dp8390_softc *esc = &sc->sc_ne2000.sc_dp8390;
	struct ifnet *ifp = &esc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_SUSPEND:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING) {
			dp8390_stop(esc);
			ifp->if_flags &= ~IFF_RUNNING;
		}
		if (sc->sc_ih != NULL)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	case DVACT_RESUME:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    dp8390_intr, sc, esc->sc_dev.dv_xname);
		dp8390_enable(esc);
		if (ifp->if_flags & IFF_UP)
			dp8390_init(esc);
		break;
	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING) {
			dp8390_stop(esc);
			ifp->if_flags &= ~IFF_RUNNING;
		}
		if (sc->sc_ih != NULL)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

#ifdef notyet
int
ne_pcmcia_enable(dsc)
	struct dp8390_softc *dsc;
{
	struct ne_pcmcia_softc *psc = (struct ne_pcmcia_softc *)dsc;

	/* set up the interrupt */
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, dp8390_intr,
	    dsc, dsc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    dsc->sc_dev.dv_xname);
		return (1);
	}

	return (pcmcia_function_enable(psc->sc_pf));
}

void
ne_pcmcia_disable(dsc)
	struct dp8390_softc *dsc;
{
	struct ne_pcmcia_softc *psc = (struct ne_pcmcia_softc *)dsc;

	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
	pcmcia_function_disable(psc->sc_pf);
}
#endif

u_int8_t *
ne_pcmcia_get_enaddr(psc, maddr, myea)
	struct ne_pcmcia_softc *psc;
	int maddr;
	u_int8_t myea[ETHER_ADDR_LEN];
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pcmcia_mem_handle pcmh;
	bus_size_t offset;
	u_int8_t *enaddr = NULL;
	int j, mwindow;

	if (maddr < 0)
		return (NULL);

	if (pcmcia_mem_alloc(psc->sc_pf, ETHER_ADDR_LEN * 2, &pcmh)) {
		printf("%s: can't alloc mem for enet addr\n",
		    dsc->sc_dev.dv_xname);
		goto fail_1;
	}
	if (pcmcia_mem_map(psc->sc_pf, PCMCIA_MEM_ATTR, maddr,
	    ETHER_ADDR_LEN * 2, &pcmh, &offset, &mwindow)) {
		printf("%s: can't map mem for enet addr\n",
		    dsc->sc_dev.dv_xname);
		goto fail_2;
	}
	for (j = 0; j < ETHER_ADDR_LEN; j++)
		myea[j] = bus_space_read_1(pcmh.memt, pcmh.memh,
		    offset + (j * 2));
	enaddr = myea;

	pcmcia_mem_unmap(psc->sc_pf, mwindow);
 fail_2:
	pcmcia_mem_free(psc->sc_pf, &pcmh);
 fail_1:
	return (enaddr);
}

u_int8_t *
ne_pcmcia_dl10019_get_enaddr(psc, myea)
	struct ne_pcmcia_softc *psc;
	u_int8_t myea[ETHER_ADDR_LEN];
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	u_int8_t sum;
	int j, type;

	for (j = 0, sum = 0; j < 8; j++) {
		sum += bus_space_read_1(nsc->sc_asict, nsc->sc_asich,
		    0x04 + j);
	}
	if (sum != 0xff)
		return (NULL);

	for (j = 0; j < ETHER_ADDR_LEN; j++) {
		myea[j] = bus_space_read_1(nsc->sc_asict,
		    nsc->sc_asich, 0x04 + j);
	}

	/* XXX - magic values from Linux */
	type = bus_space_read_1(nsc->sc_asict, nsc->sc_asich, 0x0f);
	if (type == 0x91 || type == 0x99)
		nsc->sc_type = NE2000_TYPE_DL10022;
	else
		nsc->sc_type = NE2000_TYPE_DL10019;

	return (myea);
}

int
ne_pcmcia_ax88190_set_iobase(psc)
	struct ne_pcmcia_softc *psc;
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pcmcia_mem_handle pcmh;
	bus_size_t offset;
	int rv = 1, mwindow;

	if (pcmcia_mem_alloc(psc->sc_pf, AX88190_LAN_IOSIZE, &pcmh)) {
		printf("%s: can't alloc mem for LAN iobase\n",
		    dsc->sc_dev.dv_xname);
		goto fail_1;
	}
	if (pcmcia_mem_map(psc->sc_pf, PCMCIA_MEM_ATTR,
	    AX88190_LAN_IOBASE, AX88190_LAN_IOSIZE, &pcmh, &offset,
	    &mwindow)) {
		printf("%s: can't map mem for LAN iobase\n",
		    dsc->sc_dev.dv_xname);
		goto fail_2;
	}

#ifdef NE_DEBUG
	printf(": LAN iobase 0x%x (0x%x) ->",
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 2) << 8,
	    (u_int)psc->sc_pcioh.addr);
#endif
	bus_space_write_1(pcmh.memt, pcmh.memh, offset,
	    psc->sc_pcioh.addr & 0xff);
	bus_space_write_1(pcmh.memt, pcmh.memh, offset + 2,
	    psc->sc_pcioh.addr >> 8);
#ifdef NE_DEBUG
	printf(" 0x%x", bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 2) << 8);
#endif
	rv = 0;

	pcmcia_mem_unmap(psc->sc_pf, mwindow);
 fail_2:
	pcmcia_mem_free(psc->sc_pf, &pcmh);
 fail_1:
	return (rv);
}
@


1.98
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.97 2014/11/24 02:03:37 brad Exp $	*/
a38 1
#include <net/if_types.h>
@


1.97
log
@use the correct capitalization for Realtek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.96 2013/05/09 19:53:48 miod Exp $	*/
a59 1
#include <dev/ic/dl10019reg.h>
@


1.96
log
@- use NETGEAR vendor ID for NETGEAR products, not LINKSYS.
- add NETGEAR FA410TXC with 00:13:46 manufacturer part of the Ethernet address;   tested by Riccardo Mottola, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.95 2011/07/03 15:47:17 matthew Exp $	*/
d780 1
a780 1
	 * Check for a RealTek 8019.
@


1.95
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.94 2010/08/30 20:33:18 deraadt Exp $	*/
d299 1
a299 1
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
d303 1
a303 1
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
d307 1
a307 1
     { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
d311 5
a315 1
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
@


1.94
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.93 2009/10/13 19:33:16 pirofti Exp $	*/
a869 8
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    dp8390_intr, sc, esc->sc_dev.dv_xname);
		/* XXX this is ridiculous */
		dp8390_init(esc);
		dp8390_stop(esc);
		break;
@


1.93
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.92 2008/10/04 17:30:59 deraadt Exp $	*/
a867 1
	int s;
a868 1
	s = splnet();
d874 1
d876 20
a896 1

d899 1
a899 1
		if (ifp->if_flags & IFF_RUNNING)
d901 3
a903 1
		if (sc->sc_ih != NULL) {
d905 1
a905 2
			sc->sc_ih = NULL;
		}
a908 1
	splx(s);
@


1.92
log
@More Linksys models (to match the Netgear ones) from PR 3879.  I am not
adding the PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID version though
without proof that it actually exists.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.91 2008/09/29 18:45:59 deraadt Exp $	*/
d72 1
a72 1
int	ne_pcmcia_activate(struct device *, enum devact);
d863 1
a863 1
	enum devact act;
@


1.91
log
@Support another ne(4) at pcmcia(4), pr5940 from Kamo Hiroyasu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.90 2007/05/08 18:50:06 deraadt Exp $	*/
d306 8
@


1.90
log
@places they get called are #ifdef notdef, so the code itself can be too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.89 2006/09/22 22:19:53 fgsch Exp $	*/
d294 4
@


1.89
log
@variant of Socket 10/100 CF+ ethernet card.
from Andrew Smith (asmith at tranquility dot fsbusiness dot co dot uk)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.88 2006/07/09 19:37:00 miod Exp $	*/
d882 1
d910 1
@


1.88
log
@*enty->*ently where applicable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.87 2006/03/04 04:59:35 jsg Exp $	*/
d420 4
@


1.87
log
@Add support for Socket CF 10/100.
From Andrew Smith <asmith at tranquility.fsbusiness.co.uk>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.86 2005/12/09 06:23:49 uwe Exp $	*/
d326 1
a326 1
     * Therefore, this enty must be below the LINKSYS_ECARD_1.  --itohy
@


1.86
log
@Don't disestablish a NULL interrupt handle after an incomplete attachment.
ok fgsch@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.85 2005/12/05 18:07:27 fgsch Exp $	*/
d416 4
@


1.85
log
@trendnet TE-CF100 support; tested and ok uwe@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.84 2005/11/23 11:39:37 mickey Exp $	*/
d863 4
a866 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
@


1.84
log
@use proper bus_size_t for register offsets and not bus_addr_t; uwe@@ miod@@ testing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.83 2005/11/21 18:16:42 millert Exp $	*/
d269 4
@


1.83
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.82 2005/10/22 23:26:06 brad Exp $	*/
d904 1
a904 1
	bus_addr_t offset;
d972 1
a972 1
	bus_addr_t offset;
@


1.82
log
@shorten ne(4) dmesg entries from 2-3 lines to 1.

Thanks to Han Boetes for testing on an isapnp card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.81 2005/09/19 20:19:02 fgsch Exp $	*/
d35 1
a35 1
#include <sys/select.h>
@


1.81
log
@spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.80 2005/09/19 19:03:57 deraadt Exp $	*/
a781 2

	printf("\n");
@


1.80
log
@another D-Link DFE-670TXD PCMCIA varient; from henrik@@flodell.se; ok fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.79 2005/03/24 01:47:30 deraadt Exp $	*/
d148 1
a148 1
      PCMCIA_CIS_ADDTRON_W89C926, 
d398 2
a399 2
	  PCMCIA_CIS_IODATA_8041TX,
	  0, -1, { 0x00, 0x04, 0xe2 } },
d402 2
a403 2
	  PCMCIA_CIS_SMC_8041,
	  0, -1, { 0x00, 0x04, 0xe2 } },
@


1.79
log
@another D-Link DFE-670TXD PCMCIA card, next MAC 3-byte seq; from
openbsd@@sillence.co.uk
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.78 2005/02/07 20:11:43 matthieu Exp $	*/
d472 4
@


1.78
log
@Add Billionton CFLT2 Compact Flash. ok pval@@ drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.77 2005/01/27 17:04:55 millert Exp $	*/
d468 4
@


1.77
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.76 2004/12/12 07:05:49 deraadt Exp $	*/
d214 4
@


1.76
log
@support 3 buffalo pcmcia ns2k devices found in japan (one of which is CF)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.75 2004/05/11 04:38:17 deraadt Exp $	*/
d581 1
d766 4
a769 3
	    dsc, "");
	if (psc->sc_ih == NULL)
		printf("no irq");
@


1.75
log
@support Iodata SMC8041TX; mjc@@bitz.ca
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.74 2003/11/17 19:48:51 fgsch Exp $	*/
d416 12
@


1.74
log
@Corega Ether II PCC-TD support.
from Katsuhiko Hirohashi <hasiyan at mk2 dot org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.73 2003/10/28 23:45:07 fgsch Exp $	*/
d392 4
@


1.73
log
@another ne2k entry. from Janjaap van Velthooven via PR/3524.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.72 2003/06/25 17:35:37 miod Exp $	*/
d367 4
@


1.72
log
@#include <machine/intr.h> is not necessary here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.71 2003/06/13 08:54:35 fgsch Exp $	*/
d210 4
@


1.71
log
@turn these DIAGNOSTIC into NE_DEBUG. there is no really need to fill
dmesg with it under normal circumstances.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.70 2003/06/13 08:49:30 pb Exp $	*/
a45 1
#include <machine/intr.h>
@


1.70
log
@attach/support yet-another-DFE670TXD (0x0149/0x4530/004005)

fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.69 2003/06/01 20:18:45 fgsch Exp $	*/
d953 1
a953 1
#ifdef DIAGNOSTIC
d963 1
a963 1
#ifdef DIAGNOSTIC
@


1.69
log
@Kingston KNE-PCM/x support.
tested by Lane Myer <myer at FreeBSD-uk dot eu dot org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.68 2003/05/24 19:09:29 henning Exp $	*/
d437 4
@


1.68
log
@Addtron W89C926; from nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.67 2003/05/11 09:52:43 henning Exp $	*/
d414 4
a485 3
    { "Kingston KNE-PCM/x",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0xe2, 0x0c, 0x0f } },
@


1.67
log
@CNET CNF301, Lucas Maneos <openbsd@@subs.maneos.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.66 2003/03/18 23:13:26 mickey Exp $	*/
d147 4
@


1.66
log
@match on SMC 8041TX by cis; from netbsd via mbing@@nfr.net; miod@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.65 2003/01/02 02:18:27 fgsch Exp $	*/
d167 4
@


1.65
log
@D-Link DFE-650TXD new vendor mac.
from Scott Parish <srp at srparish dot net> via PR/3052.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.64 2002/11/20 15:01:13 fgsch Exp $	*/
d377 4
@


1.64
log
@Belkin F5D5020 support; from Michael J. Eisenhower.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.62 2002/08/17 21:59:02 fgsch Exp $	*/
d275 4
@


1.63
log
@match on gvc np0335; form George Lewis via pr2971
@
text
@d422 4
@


1.62
log
@Arowana Fast-Ethernet support; patch by Thomas Delaet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.61 2002/08/08 23:33:43 fgsch Exp $	*/
d199 4
@


1.61
log
@D-Link DFE-670TXD support; reported and tested by RD Thrush <rd@@thrush.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.60 2002/05/06 03:38:28 pvalchev Exp $	*/
d195 4
@


1.60
log
@Match D-Link DE-660+, tested by drewc@@rift.com, ok fgs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.59 2002/03/14 01:27:01 millert Exp $	*/
d267 4
@


1.59
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.58 2001/12/20 04:17:23 fgsch Exp $	*/
d130 4
@


1.58
log
@Netgear FA411 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.57 2001/11/06 21:56:13 mickey Exp $	*/
d70 4
a73 4
int	ne_pcmcia_match __P((struct device *, void *, void *));
void	ne_pcmcia_attach __P((struct device *, struct device *, void *));
int	ne_pcmcia_detach __P((struct device *, int));
int	ne_pcmcia_activate __P((struct device *, enum devact));
d75 2
a76 2
int	ne_pcmcia_enable __P((struct dp8390_softc *));
void	ne_pcmcia_disable __P((struct dp8390_softc *));
d90 2
a91 2
	ne_pcmcia_get_enaddr __P((struct ne_pcmcia_softc *, int,
	    u_int8_t[ETHER_ADDR_LEN]));
d93 3
a95 3
	ne_pcmcia_dl10019_get_enaddr __P((struct ne_pcmcia_softc *,
	    u_int8_t[ETHER_ADDR_LEN]));
int	ne_pcmcia_ax88190_set_iobase __P((struct ne_pcmcia_softc *));
@


1.57
log
@it appears pcm100 is not the same as combo ecard even same vendor/prod ids; fixing pr#2166
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.56 2001/10/25 17:27:25 mickey Exp $	*/
d401 4
@


1.57.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.58 2001/12/20 04:17:23 fgsch Exp $	*/
a400 4

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA411,
      PCMCIA_CIS_NETGEAR_FA411,
      0, -1, { 0x00, 0x40, 0xf4 } },
@


1.57.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.57.2.1 2002/01/31 22:55:37 niklas Exp $	*/
d70 4
a73 4
int	ne_pcmcia_match(struct device *, void *, void *);
void	ne_pcmcia_attach(struct device *, struct device *, void *);
int	ne_pcmcia_detach(struct device *, int);
int	ne_pcmcia_activate(struct device *, enum devact);
d75 2
a76 2
int	ne_pcmcia_enable(struct dp8390_softc *);
void	ne_pcmcia_disable(struct dp8390_softc *);
d90 2
a91 2
	ne_pcmcia_get_enaddr(struct ne_pcmcia_softc *, int,
	    u_int8_t[ETHER_ADDR_LEN]);
d93 3
a95 3
	ne_pcmcia_dl10019_get_enaddr(struct ne_pcmcia_softc *,
	    u_int8_t[ETHER_ADDR_LEN]);
int	ne_pcmcia_ax88190_set_iobase(struct ne_pcmcia_softc *);
a129 4
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DLINK_DE660PLUS,
@


1.57.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.57.2.2 2002/06/11 03:42:28 art Exp $	*/
a195 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_AROWANA_FE,
      0, -1, { 0x00, 0x48, 0x54 }, NE2000DVF_AX88190 },

a266 4

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x50, 0xba } },
@


1.57.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a167 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_CNET_CNF301,
      PCMCIA_CIS_CNET_CNF301,
      0, -1, { 0x00, 0x10, 0x60 } },

a199 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_GVC_NP0335,
      0, -1, { 0x00, 0x40, 0x05 } },

a273 4
      0, -1, { 0x00, 0x05, 0x5d } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
a369 4
    { PCMCIA_VENDOR_SMC, PCMCIA_PRODUCT_SMC_8041,
	  PCMCIA_CIS_SMC_8041,
	  0, -1, { 0x00, 0x04, 0xe2 } },

a416 4

    { PCMCIA_VENDOR_BELKIN, PCMCIA_PRODUCT_BELKIN_F5D5020,
      PCMCIA_CIS_BELKIN_F5D5020,
      0, -1, { 0x00, 0x30, 0xbd } },
@


1.56
log
@match on corega pcc-td
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.55 2001/10/08 14:20:16 aaron Exp $	*/
d222 4
@


1.55
log
@Support the WiseCom iPort 10/100; thanks to Brendan Hiley <ultr0s@@mbox.com.au>
for testing the patch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.54 2001/08/18 16:50:03 aaron Exp $	*/
d324 4
@


1.54
log
@Make use of ax88190_stop_card and dl10019_stop_card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.53 2001/08/18 16:19:01 aaron Exp $	*/
d187 4
@


1.53
log
@Support for PCMCIA network cards with an ASIX AX88190. Committing this over
a Linksys PCMPC100 Ver 3 10/100 card that now works.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.52 2001/08/17 21:52:16 deraadt Exp $	*/
d651 1
d678 1
@


1.52
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.51 2001/06/12 05:54:25 fgsch Exp $	*/
d67 3
d109 2
d221 1
a221 1
      0, -1, { 0x00, 0x04, 0x5a } },
d242 1
a242 1
      0, -1, { 0x00, 0x90, 0xcc }, /* NE2000DVF_AX88190 */ },
d360 1
a360 1
      0, -1, { 0x00, 0x40, 0x26 }, /* NE2000DVF_AX88190 */ },
d376 1
a376 1
      0, -1, { 0x00, 0x40, 0x26 }, /* NE2000DVF_AX88190 */ },
a643 1
#ifdef notyet
d648 6
a655 1
#endif
d881 1
a881 1
	if (pcmcia_mem_alloc(psc->sc_pf, NE2000_AX88190_LAN_IOSIZE, &pcmh)) {
d887 2
a888 2
	    NE2000_AX88190_LAN_IOBASE, NE2000_AX88190_LAN_IOSIZE,
	    &pcmh, &offset, &mwindow)) {
d895 1
a895 1
	printf("%s: LAN iobase 0x%x (0x%x) ->", dsc->sc_dev.dv_xname,
d905 1
a905 1
	printf(" 0x%x\n", bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
@


1.51
log
@Yet another entry for the Netgear FA410TXC; from
Brandin L Claar <claar@@arl.psu.edu>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.50 2001/06/04 05:56:49 fgsch Exp $	*/
d674 1
a674 1
	    dsc);
d747 2
a748 4
		printf("%s:", esc->sc_dev.dv_xname);
		sc->sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, dp8390_intr, sc);
		printf("\n");
d772 1
a772 1
	    dsc);
@


1.50
log
@Linksys PCM100 support; from Matt Behrens <matt@@zigg.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.49 2001/05/28 04:25:59 fgsch Exp $	*/
d376 4
@


1.49
log
@Remove FA410TX from the invalid list; it's confusing and should be matched
using the linksys etherfast entry; aaron@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.48 2001/05/27 19:50:25 fgsch Exp $	*/
d215 8
a249 4

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
      0, -1, { 0x00, 0x80, 0xc8 } },
@


1.48
log
@Netgear FA410TXC; thanks to Loic Tortay <loict@@bougon.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.47 2001/05/25 05:10:21 fgsch Exp $	*/
a165 4

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_NETGEAR_FA410TX,
      0, -1, { 0x00, 0xe0, 0x98 } },
@


1.47
log
@Wisecom T210CT; from Daniel Lucq <dlucq@@ieee.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.46 2001/05/22 10:51:35 fgsch Exp $	*/
d376 4
@


1.46
log
@A few more entries from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.45 2001/05/22 09:26:47 fgsch Exp $	*/
d182 4
@


1.45
log
@Corega FastEther TXD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.44 2001/05/22 08:34:27 fgsch Exp $	*/
d341 4
d364 9
@


1.44
log
@Add Synergy21 S21810 support; from NetBSD.
Remove flags, it's not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.43 2001/04/19 05:32:39 fgsch Exp $	*/
d321 6
a326 2
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FAST_ETHER_PCC_TXF,
      PCMCIA_CIS_COREGA_FAST_ETHER_PCC_TXF,
@


1.43
log
@Remove extra arg; from Loic Tortay <loict@@bougon.net> via aaron@@.
deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.42 2001/04/19 05:10:33 fgsch Exp $	*/
a105 3
    int flags;
#define NE2000DVF_DL10019	0x0001		/* chip is D-Link DL10019 */
#define NE2000DVF_AX88190	0x0002		/* chip is ASIX AX88190 */
d172 4
d229 1
a229 1
      0, -1, { 0x00, 0x90, 0xcc }, NE2000DVF_AX88190 },
d343 1
a343 1
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },
@


1.42
log
@When printing the address/size, use the correct value 32, not 16.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.41 2001/04/18 14:59:31 aaron Exp $	*/
d593 1
a593 2
		printf(": can't match ethernet vendor code\n",
		    dsc->sc_dev.dv_xname);
@


1.41
log
@Support the Corega FEther PCC-TXF card; taka@@trans-nt.com. Addresses PR/1777.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.40 2001/03/31 15:01:34 aaron Exp $	*/
d569 1
a569 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, NE2000_NIC_NPORTS);
@


1.40
log
@Add support for GVC NIC-2000BT Ethernet adapter.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.39 2001/03/29 01:39:33 aaron Exp $	*/
d319 4
@


1.39
log
@Add MII support to NE2000 PCMCIA driver. Both the Netgear FA410TXC and
New Media LiveWire Fast Ethernet adapters now work after these changes,
although the Netgear card still requires media to be set manually.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.38 2001/03/27 10:23:44 peter Exp $	*/
d178 4
d589 1
a589 1
		printf("%s: can't match ethernet vendor code\n",
@


1.38
log
@Add an old 'ne' compatible card from Greycell and the matching data
to if_ne_pcmcia.c. OK mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.37 2001/03/13 02:31:37 mickey Exp $	*/
d52 3
d61 3
d107 2
a108 2
#define	NE2000DVF_DL10019	0x0001		/* chip is D-Link DL10019 */
#define	NE2000DVF_AX88190	0x0002		/* chip is ASIX AX88190 */
d171 4
d626 9
d676 1
a676 3
	struct dp8390_softc *dsc = &psc->sc_ne2000.sc_dp8390;
	struct ifnet *ifp = &dsc->sc_arpcom.ac_if;
	int rv = 0;
d682 5
d689 2
d693 1
a693 4
	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
d803 1
a803 1
	int j;
d805 1
a805 1
	for (j = 0, sum = 0; j < 8; j++)
d808 1
d811 2
a812 1
	for (j = 0; j < ETHER_ADDR_LEN; j++)
d815 9
a823 1
	nsc->sc_type = NE2000_TYPE_DL10019;
@


1.37
log
@aaron@@ called for an order!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.36 2001/03/12 05:37:01 aaron Exp $	*/
d178 4
@


1.36
log
@Adjust the way that media is initialized on DP8390-compatibles; from NetBSD.
The dp8390_softc now has media_init and media_fini function pointers that
do the work. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.35 2001/02/27 08:41:51 fgsch Exp $	*/
d164 4
a332 4

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_TAMARACK_NE2000,
      0, -1, { 0x00, 0x47, 0x43 } },
@


1.35
log
@Half support for this D-Link DFE-650 model that has completely different
vendor; from kart@@hal-pc.org.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.34 2001/02/14 17:47:57 mickey Exp $	*/
a445 7
	void (*npp_init_media) __P((struct dp8390_softc *, int **,
	    int *, int *));
	int *media, nmedia, defmedia;

	npp_init_media = NULL;
	media = NULL;
	nmedia = defmedia = 0;
a605 1
		npp_init_media = rtl80x9_init_media;
d609 1
d620 1
a620 5
	/* Initialize media, if we have it. */
	if (npp_init_media != NULL)
		(*npp_init_media)(dsc, &media, &nmedia, &defmedia);

	if (ne2000_attach(nsc, enaddr, media, nmedia, defmedia))
@


1.34
log
@another ne2k, from markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.33 2001/01/29 05:37:51 mickey Exp $	*/
d211 4
@


1.33
log
@const match table
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.32 2000/12/16 21:47:49 mickey Exp $	*/
d326 3
@


1.32
log
@make sure cis1_info[i] is not NULL before strcmp() w/ it; fixes some obscure panics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.31 2000/08/30 20:51:35 fgsch Exp $	*/
d93 1
a93 1
struct ne2000dev {
d166 1
a166 1
     * PCMCIA_VENDOR_INVALID and/or PCMCIA_PRODUCT_INVALID 
d217 1
a217 1
      PCMCIA_CIS_LINKSYS_COMBO_ECARD, 
d265 1
a265 1
 
d311 1
a311 1
      PCMCIA_CIS_MELCO_LPC3_TX, 
d436 1
a436 1
	struct ne2000dev *ne_dev;
d559 1
a559 1
				enaddr = ne_pcmcia_get_enaddr(psc, 
@


1.31
log
@- Finally fix the problem introduced after the ax88190 support; the MAC
  should be read correctly in all cards.
- Disable support for AX88190 till I get some card for testing.

Thanks to palante@@subterrain.net for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.30 2000/06/26 06:22:00 aaron Exp $	*/
d404 1
@


1.30
log
@Make the Linksys Combo PCMCIA EthernetCard (EC2T) work again; it was broken by
the last commit for AX88190 support. There are at least three variants of ne's
that have manufacturer id 0x143 (Linksys) + product id 0xc1ab. Each one has its
enaddr in a different place.

The matching code for PCMCIA NE2000 is really gross. In particular, the flags
field in ne2000_devs (for NE2000DVF_DL10019 and NE2000_AX88190) is a complete
hack. The driver should really try each method of reading the Ethernet address
(from the ROM, DL10019, and AX88190) and choose the one that generates the
correct checksum.

I plan to fix this later...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.29 2000/05/30 14:36:41 fgsch Exp $	*/
a163 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD_2,
      0, -1, { 0x00, 0xe0, 0x98 } },

d193 1
a193 1
      0, -1, { 0x00, 0x90, 0xcc }, NE2000DVF_DL10019 },
d197 1
a197 1
      0, -1, { 0x00, 0xe0, 0x98 }, NE2000DVF_DL10019 },
d210 1
a210 1
      0, -1, { 0x00, 0x80, 0xc8 }, NE2000DVF_DL10019 },
d214 1
a214 1
      0, -1, { 0x00, 0xe0, 0x98 }, NE2000DVF_DL10019 },
d292 1
a292 1
      0, -1, { 0x00, 0x00, 0xf4 }, NE2000DVF_DL10019 },
d562 3
a574 9
	if ((ne_dev->flags & NE2000DVF_DL10019) != 0) {
		enaddr = ne_pcmcia_dl10019_get_enaddr(psc, myea);
		if (enaddr == NULL) {
			++i;
			goto again;
		}
		nsc->sc_type = NE2000_TYPE_DL10019;
	}

d587 1
d594 1
a782 1
#define PAR0	0x04
d785 1
a785 1
		    PAR0 + j);
d790 2
a791 2
		    nsc->sc_asich, PAR0 + j);
#undef PAR0
@


1.29
log
@Changes from NetBSD:
* support for ax88190 cards
* instead of using the first cfe entry, go thru the whole list.
* change the code so cards with same id but different mac can be
  allowed (ibm infomover by instance)
* on fail, be sure to unmap and/or free all the resources previously
  allocated; we really need to do this in the rest of the drivers
* new products
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.28 2000/04/25 04:48:49 fgsch Exp $	*/
d163 4
@


1.28
log
@sync unknown list with reality; minor changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.27 2000/04/24 19:43:35 niklas Exp $	*/
d80 8
d100 3
d179 8
d193 1
a193 1
      0, -1, { 0x00, 0x90, 0xcc } },
d197 1
a197 1
      0, -1, { 0x00, 0xe0, 0x98 } },
a203 1
#if 0
d206 1
a206 2
      0, -1, { 0x00, 0x90, 0xcc } },
#endif
d210 5
a214 1
      0, -1, { 0x00, 0x80, 0xc8 } }, 
d292 1
a292 1
      0, -1, { 0x00, 0x00, 0xf4 } },
a309 1
#if 0
d312 1
a312 2
      0, -1, { 0x00, 0x40, 0x26 } },
#endif
a353 9
    { "IBM CCAE",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x08, 0x00, 0x5a } },
    { "IBM CCAE",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x04, 0xac } },
    { "IBM CCAE",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x06, 0x29 } },
d436 2
a437 4
	struct pcmcia_mem_handle pcmh;
	bus_addr_t offset;
	int i, j, mwindow;
	u_int8_t *enaddr = NULL;
a446 1
	cfe = pa->pf->cfe_head.sqh_first;
d448 2
d451 4
a454 4
	/*
	 * Some ne2000 driver's claim to have memory; others don't.
	 * Since I don't care, I don't check.
	 */
d456 5
a460 5
	if (cfe->num_memspace != 1) {
		printf(": unexpected number of memory spaces, "
		    " %d should be 1\n", cfe->num_memspace);
		return;
	}
d463 27
a489 4
	if (cfe->num_iospace == 1) {
		if (cfe->iospace[0].length != NE2000_NPORTS) {
			printf(": unexpected I/O space configuration\n");
			return;
d491 7
a497 11
	} else if (cfe->num_iospace == 2) {
		/*
		 * Some cards report a separate space for NIC and ASIC.
		 * This make some sense, but we must allocate a single
		 * NE2000_NPORTS-sized chunk, due to brain damaged
		 * address decoders on some of these cards.
		 */
		if ((cfe->iospace[0].length + cfe->iospace[1].length) !=
		    NE2000_NPORTS) {
			printf(": unexpected I/O space configuration\n");
			return;
d499 2
a500 3
	} else {
		printf(": unexpected number of i/o spaces %d"
		    " should be 1 or 2\n", cfe->num_iospace);
d503 3
a505 4
	if (pcmcia_io_alloc(pa->pf, 0, NE2000_NPORTS, NE2000_NPORTS,
	    &psc->sc_pcioh)) {
		printf(": can't alloc i/o space\n");
		return;
d513 1
a513 2
	    NE2000_ASIC_OFFSET, NE2000_ASIC_NPORTS,
	    &nsc->sc_asich)) {
d515 1
a515 1
		return;
d518 1
a518 1
#if 0
d528 1
a528 1
		return;
d534 4
a537 5
	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO8,
	    NE2000_NIC_OFFSET, NE2000_NIC_NPORTS,
	    &psc->sc_pcioh, &psc->sc_nic_io_window)) {
		printf(": can't map NIC i/o space\n");
		return;
d540 4
a543 5
	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16,
	    NE2000_ASIC_OFFSET, NE2000_ASIC_NPORTS,
	    &psc->sc_pcioh, &psc->sc_asic_io_window)) {
		printf(": can't map ASIC i/o space\n");
		return;
d551 6
a556 3
	for (i = 0; i < NE2000_NDEVS; i++) {
		if ((ne_dev = ne2000_match(pa->card, pa->pf->number, i))
		    != NULL) {
d558 4
a561 20
				if (pcmcia_mem_alloc(pa->pf,
				    ETHER_ADDR_LEN * 2, &pcmh)) {
					printf(": can't alloc mem for"
					    " address\n");
					return;
				}
				if (pcmcia_mem_map(pa->pf, PCMCIA_MEM_ATTR,
				    ne_dev->enet_maddr, ETHER_ADDR_LEN * 2,
				    &pcmh, &offset, &mwindow)) {
					printf(": can't map mem for"
					    " address\n");
					return;
				}
				for (j = 0; j < ETHER_ADDR_LEN; j++)
					dsc->sc_arpcom.ac_enaddr[j] =
					    bus_space_read_1(pcmh.memt,
					    pcmh.memh, offset + (j * 2));
				pcmcia_mem_unmap(pa->pf, mwindow);
				pcmcia_mem_free(pa->pf, &pcmh);
				enaddr = dsc->sc_arpcom.ac_enaddr;
d566 14
d588 2
a589 9
			printf("%s: enet addr has incorrect vendor code\n",
			    dsc->sc_dev.dv_xname);
			printf(": (%02x:%02x:%02x should be "
			    "%02x:%02x:%02x)\n",
			    enaddr[0], enaddr[1], enaddr[2],
			    ne_dev->enet_vendor[0],
			    ne_dev->enet_vendor[1],
			    ne_dev->enet_vendor[2]);
			return;
d593 7
d627 2
a628 1
	ne2000_attach(nsc, enaddr, media, nmedia, defmedia);
d630 1
a630 1
#if 0
d633 19
d664 4
d737 107
@


1.27
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.26 2000/04/19 09:19:43 fgsch Exp $	*/
d107 1
a107 1
      0, 0xff0, { 0x00, 0x00, 0xe8 } },
d131 1
a131 1
      0, 0x7f0, { 0x00, 0xc0, 0x6c } },
d135 1
a135 1
      0, 0xff0, { 0x00, 0x00, 0x48 } },
a367 3
    { "NE2000 Compatible",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0xa0, 0x0c } },
@


1.26
log
@new products; rearrange.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.25 2000/02/02 18:47:02 deraadt Exp $	*/
d658 1
a659 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d690 1
a691 2

	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
@


1.25
log
@make the activate routines do xxstop() and xxinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.24 2000/02/01 16:59:07 fgsch Exp $	*/
d114 4
d133 4
d145 7
a151 3
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_EPSON_EEN10B,
      PCMCIA_CIS_EPSON_EEN10B,
      0, 0xff0, { 0x00, 0x00, 0x48 } },
d180 11
a276 4
    { PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PC2,
      PCMCIA_CIS_KINGSTON_KNE_PC2,
      0, 0x0180, { 0x00, 0xc0, 0xf0 } },

a280 4
    { PCMCIA_VENDOR_ALLIEDTELESIS, PCMCIA_PRODUCT_ALLIEDTELESIS_LA_PCM,
      PCMCIA_CIS_ALLIEDTELESIS_LA_PCM,
      0, 0x0ff0, { 0x00, 0x00, 0xf4 } },

d285 10
d298 8
@


1.25.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.40 2001/03/31 15:01:34 aaron Exp $	*/
a51 3
#include <dev/mii/miivar.h>
#include <dev/mii/mii_bitbang.h>

a57 3
#include <dev/ic/dl10019reg.h>
#include <dev/ic/dl10019var.h>

a79 8
u_int8_t *
	ne_pcmcia_get_enaddr __P((struct ne_pcmcia_softc *, int,
	    u_int8_t[ETHER_ADDR_LEN]));
u_int8_t *
	ne_pcmcia_dl10019_get_enaddr __P((struct ne_pcmcia_softc *,
	    u_int8_t[ETHER_ADDR_LEN]));
int	ne_pcmcia_ax88190_set_iobase __P((struct ne_pcmcia_softc *));

d85 1
a85 1
const struct ne2000dev {
a91 3
    int flags;
#define NE2000DVF_DL10019	0x0001		/* chip is D-Link DL10019 */
#define NE2000DVF_AX88190	0x0002		/* chip is ASIX AX88190 */
d107 1
a107 1
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },
a113 4
      PCMCIA_CIS_RPTI_EP400,
      0, -1, { 0x00, 0x40, 0x95 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d127 1
a127 5
      0, 0x07f0, { 0x00, 0xc0, 0x6c } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_EPSON_EEN10B,
      PCMCIA_CIS_EPSON_EEN10B,
      0, 0x0ff0, { 0x00, 0x00, 0x48 } },
d137 3
a139 19
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_BILLIONTON_LNT10TN,
      0, -1, { 0x00, 0x00, 0x00 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_NDC_ND5100_E,
      0, -1, { 0x00, 0x80, 0xc6 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_NETGEAR_FA410TX,
      0, -1, { 0x00, 0xe0, 0x98 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_TAMARACK_NE2000,
      0, -1, { 0x00, 0x47, 0x43 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_GVC_NIC2000P,
      0, 0x0ff0, { 0x00, 0x00, 0xe8 } },
d143 1
a143 1
     * PCMCIA_VENDOR_INVALID and/or PCMCIA_PRODUCT_INVALID
a151 4
    { PCMCIA_VENDOR_GREYCELL, PCMCIA_PRODUCT_GREYCELL_GCS2000,
      PCMCIA_CIS_GREYCELL_GCS2000,
      0, -1, { 0x00, 0x47, 0x43 } },

a155 8
    { PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x00, 0x04, 0xac } },

    { PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x00, 0x06, 0x29 } },

a167 13
    /*
     * This entry should be here so that above two cards doesn't
     * match with this.  FNW-3700T won't match above entries due to
     * MAC address check.
     */
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_PLANEX_FNW3700T,
      0, -1, { 0x00, 0x90, 0xcc }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_LINKSYS_ETHERFAST,
      0, -1, { 0x00, 0x80, 0xc8 } },

d170 1
a170 5
      0, -1, { 0x00, 0x50, 0xba } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ETHERFAST,
      PCMCIA_CIS_DLINK_DE650,
      0, -1, { 0x00, 0xe0, 0x98 } },
d173 1
a173 1
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
d221 1
a221 1

d254 4
d262 4
a269 8
    { PCMCIA_VENDOR_XIRCOM, PCMCIA_PRODUCT_XIRCOM_CFE_10,
      PCMCIA_CIS_XIRCOM_CFE_10,
      0, -1, { 0x00, 0x10, 0xa4 } },

    { PCMCIA_VENDOR_MELCO, PCMCIA_PRODUCT_MELCO_LPC3_TX,
      PCMCIA_CIS_MELCO_LPC3_TX,
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },

a273 7
    { PCMCIA_VENDOR_ALLIEDTELESIS, PCMCIA_PRODUCT_ALLIEDTELESIS_LA_PCM,
      PCMCIA_CIS_ALLIEDTELESIS_LA_PCM,
      0, 0x0ff0, { 0x00, 0x00, 0xf4 } },

    { PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PC2,
      PCMCIA_CIS_KINGSTON_KNE_PC2,
      0, 0x0180, { 0x00, 0xc0, 0xf0 } },
d302 9
d335 3
a363 1
    ((card)->cis1_info[0]) && ((card)->cis1_info[1]) && \
d395 12
a406 3
	const struct ne2000dev *ne_dev;
	int i;
	u_int8_t myea[6], *enaddr;
d409 1
a410 2
	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;
	    cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {
d412 4
a415 4
		/*
		 * Some ne2000 driver's claim to have memory; others don't.
		 * Since I don't care, I don't check.
		 */
d417 5
a421 5
		if (cfe->num_memspace != 1) {
			printf(": unexpected number of memory spaces, "
			    " %d should be 1\n", cfe->num_memspace);
			return;
		}
d424 4
a427 27
		if (cfe->num_iospace == 1) {
			if (cfe->iospace[0].length != NE2000_NPORTS) {
				printf(": unexpected I/O space "
				    "configuration\n");
				continue;
			}
		} else if (cfe->num_iospace == 2) {
			/*
			 * Some cards report a separate space for NIC and ASIC.
			 * This make some sense, but we must allocate a single
			 * NE2000_NPORTS-sized chunk, due to brain damaged
			 * address decoders on some of these cards.
			 */
			if (cfe->iospace[0].length + cfe->iospace[1].length !=
			    NE2000_NPORTS) {
#ifdef DIAGNOSTIC
				printf(": unexpected I/O space "
				    "configuration\n");
#endif
				continue;
			}
		} else {
#ifdef DIAGNOSTIC
			printf(": unexpected number of i/o spaces %d"
			    " should be 1 or 2\n", cfe->num_iospace);
#endif
			continue;
d429 11
a439 7

		if (pcmcia_io_alloc(pa->pf, cfe->iospace[0].start,
		    NE2000_NPORTS, NE2000_NPORTS, &psc->sc_pcioh)) {
#ifdef DIAGNOSTIC
			printf(": can't allocate I/O space\n");
#endif
			continue;
d441 3
a443 2

		break;
d446 4
a449 3
	if (cfe == NULL) {
		printf(": no suitable config entry\n");
		goto fail_1;
d457 2
a458 1
	    NE2000_ASIC_OFFSET, NE2000_ASIC_NPORTS, &nsc->sc_asich)) {
d460 1
a460 1
		goto fail_2;
d463 1
a463 1
#ifdef notyet
d473 1
a473 1
		goto fail_2;
d479 5
a483 4
	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO8, NE2000_NIC_OFFSET,
	    NE2000_NIC_NPORTS, &psc->sc_pcioh, &psc->sc_nic_io_window)) {
		printf(": can't map NIC I/O space\n");
		goto fail_3;
d486 5
a490 4
	if (pcmcia_io_map(pa->pf, PCMCIA_WIDTH_IO16, NE2000_ASIC_OFFSET,
	    NE2000_ASIC_NPORTS, &psc->sc_pcioh, &psc->sc_asic_io_window)) {
		printf(": can't map ASIC I/O space\n");
		goto fail_4;
d498 3
a500 6
	i = 0;
again:
	enaddr = NULL;			/* Ask ASIC by default */
	for (; i < NE2000_NDEVS; i++) {
		ne_dev = ne2000_match(pa->card, pa->pf->number, i);
		if (ne_dev != NULL) {
d502 20
a521 7
				enaddr = ne_pcmcia_get_enaddr(psc,
				    ne_dev->enet_maddr, myea);
				if (enaddr == NULL)
					continue;
			} else {
				enaddr = ne_pcmcia_dl10019_get_enaddr(psc,
				    myea);
a525 5
	if (i == NE2000_NDEVS) {
		printf(": can't match ethernet vendor code\n",
		    dsc->sc_dev.dv_xname);
		goto fail_5;
	}
d534 9
a542 2
			++i;
			goto again;
a545 9
#ifdef notyet
	if ((ne_dev->flags & NE2000DVF_AX88190) != 0) {
		if (ne_pcmcia_ax88190_set_iobase(psc))
			goto fail_5;

		nsc->sc_type = NE2000_TYPE_AX88190;
	}
#endif

d555 1
a558 10
		dsc->sc_media_init = rtl80x9_media_init;
	}

	if (nsc->sc_type == NE2000_TYPE_DL10019 ||
	    nsc->sc_type == NE2000_TYPE_DL10022) {
		dsc->sc_mediachange = dl10019_mediachange;
		dsc->sc_mediastatus = dl10019_mediastatus;
		dsc->init_card = dl10019_init_card;
		dsc->sc_media_init = dl10019_media_init;
		dsc->sc_media_fini = dl10019_media_fini;
d569 5
a573 2
	if (ne2000_attach(nsc, enaddr))
		goto fail_5;
d575 1
a575 1
#if notyet
a577 19
	return;

fail_5:
	/* Unmap ASIC I/O windows. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_asic_io_window);

fail_4:
	/* Unmap NIC I/O windows. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_nic_io_window);

fail_3:
	pcmcia_function_disable(pa->pf);

fail_2:
	/* Free our I/O space. */
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

fail_1:
	psc->sc_nic_io_window = -1;
d586 3
a588 9
	int error;

	if (psc->sc_nic_io_window == -1)
		/* Nothing to detach. */
		return (0);

	error = ne2000_detach(&psc->sc_ne2000, flags);
	if (error != 0)
		return (error);
a589 1
	/* Unmap our i/o windows. */
d592 1
d594 2
a595 2
	/* Free our i/o space. */
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
d597 1
a597 1
	return (0);
d625 1
a626 1
		pcmcia_function_disable(sc->sc_pf);
a656 1
	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
a657 1
}
d659 1
a659 114
u_int8_t *
ne_pcmcia_get_enaddr(psc, maddr, myea)
	struct ne_pcmcia_softc *psc;
	int maddr;
	u_int8_t myea[ETHER_ADDR_LEN];
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pcmcia_mem_handle pcmh;
	bus_addr_t offset;
	u_int8_t *enaddr = NULL;
	int j, mwindow;

	if (maddr < 0)
		return (NULL);

	if (pcmcia_mem_alloc(psc->sc_pf, ETHER_ADDR_LEN * 2, &pcmh)) {
		printf("%s: can't alloc mem for enet addr\n",
		    dsc->sc_dev.dv_xname);
		goto fail_1;
	}
	if (pcmcia_mem_map(psc->sc_pf, PCMCIA_MEM_ATTR, maddr,
	    ETHER_ADDR_LEN * 2, &pcmh, &offset, &mwindow)) {
		printf("%s: can't map mem for enet addr\n",
		    dsc->sc_dev.dv_xname);
		goto fail_2;
	}
	for (j = 0; j < ETHER_ADDR_LEN; j++)
		myea[j] = bus_space_read_1(pcmh.memt, pcmh.memh,
		    offset + (j * 2));
	enaddr = myea;

	pcmcia_mem_unmap(psc->sc_pf, mwindow);
 fail_2:
	pcmcia_mem_free(psc->sc_pf, &pcmh);
 fail_1:
	return (enaddr);
}

u_int8_t *
ne_pcmcia_dl10019_get_enaddr(psc, myea)
	struct ne_pcmcia_softc *psc;
	u_int8_t myea[ETHER_ADDR_LEN];
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	u_int8_t sum;
	int j, type;

	for (j = 0, sum = 0; j < 8; j++) {
		sum += bus_space_read_1(nsc->sc_asict, nsc->sc_asich,
		    0x04 + j);
	}
	if (sum != 0xff)
		return (NULL);

	for (j = 0; j < ETHER_ADDR_LEN; j++) {
		myea[j] = bus_space_read_1(nsc->sc_asict,
		    nsc->sc_asich, 0x04 + j);
	}

	/* XXX - magic values from Linux */
	type = bus_space_read_1(nsc->sc_asict, nsc->sc_asich, 0x0f);
	if (type == 0x91 || type == 0x99)
		nsc->sc_type = NE2000_TYPE_DL10022;
	else
		nsc->sc_type = NE2000_TYPE_DL10019;

	return (myea);
}

int
ne_pcmcia_ax88190_set_iobase(psc)
	struct ne_pcmcia_softc *psc;
{
	struct ne2000_softc *nsc = &psc->sc_ne2000;
	struct dp8390_softc *dsc = &nsc->sc_dp8390;
	struct pcmcia_mem_handle pcmh;
	bus_addr_t offset;
	int rv = 1, mwindow;

	if (pcmcia_mem_alloc(psc->sc_pf, NE2000_AX88190_LAN_IOSIZE, &pcmh)) {
		printf("%s: can't alloc mem for LAN iobase\n",
		    dsc->sc_dev.dv_xname);
		goto fail_1;
	}
	if (pcmcia_mem_map(psc->sc_pf, PCMCIA_MEM_ATTR,
	    NE2000_AX88190_LAN_IOBASE, NE2000_AX88190_LAN_IOSIZE,
	    &pcmh, &offset, &mwindow)) {
		printf("%s: can't map mem for LAN iobase\n",
		    dsc->sc_dev.dv_xname);
		goto fail_2;
	}

#ifdef DIAGNOSTIC
	printf("%s: LAN iobase 0x%x (0x%x) ->", dsc->sc_dev.dv_xname,
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 2) << 8,
	    (u_int)psc->sc_pcioh.addr);
#endif
	bus_space_write_1(pcmh.memt, pcmh.memh, offset,
	    psc->sc_pcioh.addr & 0xff);
	bus_space_write_1(pcmh.memt, pcmh.memh, offset + 2,
	    psc->sc_pcioh.addr >> 8);
#ifdef DIAGNOSTIC
	printf(" 0x%x\n", bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
	    bus_space_read_1(pcmh.memt, pcmh.memh, offset + 2) << 8);
#endif
	rv = 0;

	pcmcia_mem_unmap(psc->sc_pf, mwindow);
 fail_2:
	pcmcia_mem_free(psc->sc_pf, &pcmh);
 fail_1:
	return (rv);
@


1.25.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.25.2.1 2001/05/14 22:26:06 niklas Exp $	*/
d106 3
d171 2
a172 2
      PCMCIA_CIS_SYNERGY21_S21810,
      0, -1, { 0x00, 0x48, 0x54 } },
a181 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_WISECOM_T210CT,
      0, -1, { 0x00, 0x20, 0x18 } },

a213 8
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
      0, -1, { 0x00, 0x04, 0x5a } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
d228 1
a228 1
      0, -1, { 0x00, 0x90, 0xcc }, /* NE2000DVF_AX88190 */ },
d242 4
a319 8
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FETHER_PCC_TXF,
      PCMCIA_CIS_COREGA_FETHER_PCC_TXF,
      0, -1, { 0x00, 0x90, 0x99 } },

    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_FETHER_PCC_TXD,
      PCMCIA_CIS_COREGA_FETHER_PCC_TXD,
      0, -1, { 0x00, 0x90, 0x99 } },

a331 4
    { PCMCIA_VENDOR_SOCKET, PCMCIA_PRODUCT_SOCKET_LP_ETHER,
      PCMCIA_CIS_SOCKET_LP_ETHER,
      0, -1, { 0x00, 0xc0, 0x1b } },

d338 1
a338 1
      0, -1, { 0x00, 0x40, 0x26 }, /* NE2000DVF_AX88190 */ },
a350 17

    { PCMCIA_VENDOR_TELECOMDEVICE, PCMCIA_PRODUCT_TELECOMDEVICE_TCD_HPC100,
      PCMCIA_CIS_TELECOMDEVICE_TCD_HPC100,
      0, -1, { 0x00, 0x40, 0x26 }, /* NE2000DVF_AX88190 */ },

    { PCMCIA_VENDOR_MACNICA, PCMCIA_PRODUCT_MACNICA_ME1_JEIDA,
      PCMCIA_CIS_MACNICA_ME1_JEIDA,
      0, 0x00b8, { 0x08, 0x00, 0x42 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_NETGEAR_FA410TXC,
      0, -1, { 0x00, 0x40, 0xf4 } },

    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_NETGEAR_FA410TXC,
      0, -1, { 0x00, 0x48, 0x54 } },

d565 1
a565 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, NE2000_NPORTS);
d589 2
a590 1
		printf(": can't match ethernet vendor code\n");
@


1.25.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.25.2.2 2001/07/04 10:43:23 niklas Exp $	*/
a66 3
#include <dev/ic/ax88190reg.h>
#include <dev/ic/ax88190var.h>

a105 2
    int flags;
#define NE2000DVF_AX88190	0x0002	/* chip is ASIX AX88190 */
a182 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_WISECOM_IPORT,
      0, -1, { 0x00, 0x02, 0xdd } },

d216 1
a216 1
      0, -1, { 0x00, 0x04, 0x5a }, NE2000DVF_AX88190 },
d237 1
a237 1
      0, -1, { 0x00, 0x90, 0xcc }, NE2000DVF_AX88190 },
a316 4
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_PCC_TD,
      PCMCIA_CIS_COREGA_ETHER_PCC_TD,
      0, -1, { 0x00, 0x00, 0xf4 } },

d355 1
a355 1
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },
d371 1
a371 1
      0, -1, { 0x00, 0x40, 0x26 }, NE2000DVF_AX88190 },
d639 1
a643 7
		dsc->sc_mediachange = ax88190_mediachange;
		dsc->sc_mediastatus = ax88190_mediastatus;
		dsc->init_card = ax88190_init_card;
		dsc->stop_card = ax88190_stop_card;
		dsc->sc_media_init = ax88190_media_init;
		dsc->sc_media_fini = ax88190_media_fini;

d646 1
a667 1
		dsc->stop_card = dl10019_stop_card;
d674 1
a674 1
	    dsc, "");
d747 4
a750 2
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    dp8390_intr, sc, esc->sc_dev.dv_xname);
d774 1
a774 1
	    dsc, dsc->sc_dev.dv_xname);
d874 1
a874 1
	if (pcmcia_mem_alloc(psc->sc_pf, AX88190_LAN_IOSIZE, &pcmh)) {
d880 2
a881 2
	    AX88190_LAN_IOBASE, AX88190_LAN_IOSIZE, &pcmh, &offset,
	    &mwindow)) {
d888 1
a888 1
	printf(": LAN iobase 0x%x (0x%x) ->",
d898 1
a898 1
	printf(" 0x%x", bus_space_read_1(pcmh.memt, pcmh.memh, offset + 0) |
@


1.25.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a221 4

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_PCM100,
      PCMCIA_CIS_LINKSYS_PCM100,
      0, -1, { 0x00, 0x04, 0x5a } },
@


1.25.2.5
log
@Merge in trunk
@
text
@a401 4
    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA411,
      PCMCIA_CIS_NETGEAR_FA411,
      0, -1, { 0x00, 0x40, 0xf4 } },

@


1.25.2.6
log
@Merge in -current from roughly a week ago
@
text
@d70 4
a73 4
int	ne_pcmcia_match(struct device *, void *, void *);
void	ne_pcmcia_attach(struct device *, struct device *, void *);
int	ne_pcmcia_detach(struct device *, int);
int	ne_pcmcia_activate(struct device *, enum devact);
d75 2
a76 2
int	ne_pcmcia_enable(struct dp8390_softc *);
void	ne_pcmcia_disable(struct dp8390_softc *);
d90 2
a91 2
	ne_pcmcia_get_enaddr(struct ne_pcmcia_softc *, int,
	    u_int8_t[ETHER_ADDR_LEN]);
d93 3
a95 3
	ne_pcmcia_dl10019_get_enaddr(struct ne_pcmcia_softc *,
	    u_int8_t[ETHER_ADDR_LEN]);
int	ne_pcmcia_ax88190_set_iobase(struct ne_pcmcia_softc *);
@


1.25.2.7
log
@Sync the SMP branch with 3.3
@
text
@a132 4
      PCMCIA_CIS_DLINK_DE660PLUS,
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
a191 8
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_AROWANA_FE,
      0, -1, { 0x00, 0x48, 0x54 }, NE2000DVF_AX88190 },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_GVC_NP0335,
      0, -1, { 0x00, 0x40, 0x05 } },

a263 8
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x05, 0x5d } },

    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x50, 0xba } },

a357 4
    { PCMCIA_VENDOR_SMC, PCMCIA_PRODUCT_SMC_8041,
	  PCMCIA_CIS_SMC_8041,
	  0, -1, { 0x00, 0x04, 0xe2 } },

a404 4

    { PCMCIA_VENDOR_BELKIN, PCMCIA_PRODUCT_BELKIN_F5D5020,
      PCMCIA_CIS_BELKIN_F5D5020,
      0, -1, { 0x00, 0x30, 0xbd } },
@


1.25.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.25.2.7 2003/03/28 00:38:26 niklas Exp $	*/
a166 4

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_CNET_CNF301,
      PCMCIA_CIS_CNET_CNF301,
      0, -1, { 0x00, 0x10, 0x60 } },
@


1.25.2.9
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.25.2.8 2003/05/13 19:35:09 ho Exp $	*/
a148 4
      PCMCIA_CIS_ADDTRON_W89C926, 
      0, -1, { 0x00, 0x40, 0x33 } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
a409 4
    { PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PCM,
      PCMCIA_CIS_KINGSTON_KNE_PCM,
      0, 0x0ff0, { 0xe2, 0x0c, 0x0f } },

d478 3
@


1.25.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d46 1
a211 4
    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_RELIA_RE2408T,
      0, -1, { 0x00, 0xc0, 0x0c } },

a365 4
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_ETHER_II_PCC_TD,
      PCMCIA_CIS_COREGA_ETHER_II_PCC_TD,
      0, -1, { 0x00, 0x00, 0xf4 } },

a437 4
    { PCMCIA_VENDOR_NETGEAR, PCMCIA_PRODUCT_NETGEAR_FA410TXC,
      PCMCIA_CIS_DLINK_DFE670TXD,
      0, -1, { 0x00, 0x40, 0x05 } },

d949 1
a949 1
#ifdef NE_DEBUG
d959 1
a959 1
#ifdef NE_DEBUG
@


1.25.2.11
log
@Merge with the trunk
@
text
@a392 4
    { PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_8041TX,
	  PCMCIA_CIS_IODATA_8041TX,
	  0, -1, { 0x00, 0x04, 0xe2 } },

@


1.24
log
@Some new prods; rearrange entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.23 2000/01/31 22:51:48 fgsch Exp $	*/
d606 2
d614 1
d617 2
d622 3
@


1.23
log
@Add CNet NE2000 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.22 1999/12/23 17:07:03 fgsch Exp $	*/
d94 4
a129 8
      PCMCIA_CIS_AMBICOM_AMB8002T,
      0, -1, { 0x00, 0x10, 0x7a } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_PLANEX_FNW3600T,
      0, -1, { 0x00, 0x90, 0xcc } },

    { PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d137 4
d161 12
d205 22
a226 1
    { PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_PCLAT,
d228 1
a228 2
      /* two possible location, 0x01c0 or 0x0ff0 */
      0, -1, { 0x00, 0xa0, 0xb0 } },
a257 4
    { PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_FAST_ECARD,
      PCMCIA_CIS_LINKSYS_FAST_ECARD,
      0, -1, { 0x00, 0x80, 0xc8} },

a292 3
    { "Epson EEN10B",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x00, 0x48 } },
@


1.22
log
@Edimax NE2000; from tom@@knienieder.com.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.21 1999/12/22 21:15:53 fgsch Exp $	*/
d136 4
@


1.21
log
@Add Dual NE2000.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.20 1999/10/31 17:53:47 fgsch Exp $	*/
d132 4
@


1.20
log
@New prods: Planex FNW-3600-T and Corega Ether II & Fast Ether.
Rearrage a few entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.19 1999/08/25 21:56:52 fgsch Exp $	*/
d233 4
@


1.19
log
@Move COREGA to ALLIEDTELESIS.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.18 1999/08/16 16:51:19 deraadt Exp $	*/
d127 5
a131 1
      0, -1, { 0x00, 0x00, 0xb2 } },
d198 10
a207 2
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_PCC_2,
      PCMCIA_CIS_COREGA_PCC_2,
d212 1
a212 1
      0, 0xd400, { 0x01, 0x03, 0xdc } },
d229 4
@


1.18
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.17 1999/08/16 08:58:45 fgsch Exp $	*/
d214 2
a215 2
    { PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_LA_PCM,
      PCMCIA_CIS_COREGA_LA_PCM,
@


1.17
log
@Remove unneeded ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.16 1999/08/16 08:49:05 fgsch Exp $	*/
d86 2
a87 2
    int32_t manufacturer;
    int32_t product;
a349 1
	const char *typestr = "";
a501 1
		typestr = " (RTL8019)";
d514 1
a514 1
	printf(": <%s>\n", typestr);
@


1.16
log
@Remove unnecessary code. Shorten dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.15 1999/08/15 19:10:31 fgsch Exp $	*/
a41 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#else
a43 1
#endif
@


1.15
log
@Allied Telesis LA-PCM support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.14 1999/08/15 05:32:13 deraadt Exp $	*/
a89 1
    char *name;
d97 1
a97 2
    { PCMCIA_STR_PREMAX_PE200,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d101 1
a101 2
    { PCMCIA_STR_DIGITAL_DEPCMXX,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d105 1
a105 2
    { PCMCIA_STR_PLANET_SMARTCOM2000,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d109 1
a109 2
    { PCMCIA_STR_DLINK_DE660,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d113 1
a113 2
    { PCMCIA_STR_RPTI_EP401,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d117 1
a117 2
    { PCMCIA_STR_ACCTON_EN2212,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d121 1
a121 2
    { PCMCIA_STR_SVEC_COMBOCARD,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d125 1
a125 2
    { PCMCIA_STR_SVEC_LANCARD,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d129 1
a129 2
    { PCMCIA_STR_AMBICOM_AMB8002T,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d144 1
a144 2
    { PCMCIA_STR_IBM_INFOMOVER,
      PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
d148 1
a148 2
    { PCMCIA_STR_LINKSYS_ECARD_1,
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ECARD_1,
d152 1
a152 2
    { PCMCIA_STR_LINKSYS_COMBO_ECARD, 
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
d156 1
a156 2
    { PCMCIA_STR_LINKSYS_TRUST_COMBO_ECARD,
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_TRUST_COMBO_ECARD,
d164 1
a164 2
    { PCMCIA_STR_LINKSYS_ECARD_2, 
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d181 1
a181 2
    { PCMCIA_STR_DLINK_DE650,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
d185 1
a185 2
    { PCMCIA_STR_IODATA_PCLAT,
      PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_PCLAT,
d190 1
a190 2
    { PCMCIA_STR_DAYNA_COMMUNICARD_E_1,
      PCMCIA_VENDOR_DAYNA, PCMCIA_PRODUCT_DAYNA_COMMUNICARD_E_1,
d194 1
a194 2
    { PCMCIA_STR_DAYNA_COMMUNICARD_E_2,
      PCMCIA_VENDOR_DAYNA, PCMCIA_PRODUCT_DAYNA_COMMUNICARD_E_2,
d198 1
a198 2
    { PCMCIA_STR_COREGA_PCC_2,
      PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_PCC_2,
d202 1
a202 2
    { PCMCIA_STR_COMPEX_LINKPORT_ENET_B,
      PCMCIA_VENDOR_COMPEX, PCMCIA_PRODUCT_COMPEX_LINKPORT_ENET_B,
d206 1
a206 2
    { PCMCIA_STR_KINGSTON_KNE_PC2,
      PCMCIA_VENDOR_KINGSTON, PCMCIA_PRODUCT_KINGSTON_KNE_PC2,
d210 1
a210 2
    { PCMCIA_STR_LINKSYS_FAST_ECARD,
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_FAST_ECARD,
d214 1
a214 2
    { PCMCIA_STR_SMC_EZCARD,
      PCMCIA_VENDOR_SMC, PCMCIA_PRODUCT_SMC_EZCARD,
d218 1
a218 2
    { PCMCIA_STR_COREGA_LA_PCM,
      PCMCIA_VENDOR_COREGA, PCMCIA_PRODUCT_COREGA_LA_PCM,
d520 1
a520 1
	printf(": <%s%s>\n", ne_dev->name, typestr);
@


1.14
log
@ambicom ethernet address is in rom; 00107A==Ambicom sez hugh
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.13 1999/08/13 21:10:48 deraadt Exp $	*/
d242 5
a250 3
    { "Allied Telesis LA-PCM",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0ff0, { 0x00, 0x00, 0xf4 } },
@


1.13
log
@AmbiCom AMB8002T
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.12 1999/08/08 01:17:23 niklas Exp $	*/
d141 1
a141 1
      0, 0x7f0, { 0x00, 0x00, 0xb2 } },
@


1.12
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.11 1999/07/26 05:43:16 deraadt Exp $	*/
d137 5
@


1.11
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.10 1999/07/01 06:29:55 fgsch Exp $	*/
d65 4
a68 2
int ne_pcmcia_match __P((struct device *, void *, void *));
void ne_pcmcia_attach __P((struct device *, struct device *, void *));
d85 2
a86 1
	sizeof(struct ne_pcmcia_softc), ne_pcmcia_match, ne_pcmcia_attach
d549 29
d579 15
@


1.10
log
@Add NewMedia BusToaster SCSI Host Adapter.
Remove repeated entry in if_ne_pcmcia.c. Minor cosmetical changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.9 1999/06/03 06:40:28 fgsch Exp $	*/
d385 1
a385 1
		printf(": unexpected number of memory spaces "
d460 1
a460 1
	printf("\n");
d471 2
a472 3
					printf("%s: can't alloc mem for"
					    " enet addr\n",
					    dsc->sc_dev.dv_xname);
d478 2
a479 3
					printf("%s: can't map mem for"
					    " enet addr\n",
					    dsc->sc_dev.dv_xname);
d503 2
a504 2
			printf("%s: (%02x:%02x:%02x should be "
			    "%02x:%02x:%02x)\n", dsc->sc_dev.dv_xname,
d529 7
a535 2
	printf("%s: %s%s Ethernet\n", dsc->sc_dev.dv_xname, ne_dev->name,
	    typestr);
a546 6
	/* set up the interrupt */
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, dp8390_intr,
	    dsc);
	if (psc->sc_ih == NULL)
		printf("%s: couldn't establish interrupt\n",
		    dsc->sc_dev.dv_xname);
@


1.9
log
@Add SMC EZCARD definition and Fujitsu products from Netbsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.8 1999/03/26 06:34:28 fgsch Exp $	*/
a252 3
    { "Dayna CommuniCard E",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0110, { 0x00, 0x80, 0x19 } },
@


1.8
log
@Add support for some 100Mbit PCMCIA cards.
Change the ne2000_detect parm list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.7 1999/01/31 11:28:39 fgsch Exp $	*/
d228 6
@


1.7
log
@Add support for Kingston KNE-PC2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.6 1999/01/28 04:58:30 fgsch Exp $	*/
d223 5
d362 1
a362 1
	u_int8_t myea[6], *enaddr = NULL;
d482 2
a483 1
					myea[j] = bus_space_read_1(pcmh.memt,
d487 1
a487 1
				enaddr = myea;
@


1.6
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.5 1998/12/04 06:49:58 fgsch Exp $	*/
d219 4
a283 3
    { "Kingston KNE-PC2",
      0x0000, 0x0000, NULL, NULL, 0,
      0x0180, { 0x00, 0xc0, 0xf0 } },
@


1.5
log
@Add support for another ne2k compatible card, vendor unknown.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.4 1998/11/06 06:32:15 fgsch Exp $	*/
d125 4
a128 17
    /*
     * D-Link DE-650 has many minor versions:
     *
     *   CIS information          Manufacturer Product  Note
     * 1 "D-Link, DE-650"             INVALID  INVALID  white card
     * 2 "D-Link, DE-650, Ver 01.00"  INVALID  INVALID  became bare metal
     * 3 "D-Link, DE-650, Ver 01.00"   0x149    0x265   minor change in look
     * 4 "D-Link, DE-650, Ver 01.00"   0x149    0x265   collision LED added
     *
     * While the 1st and the 2nd types should use the "D-Link DE-650" entry,
     * the 3rd and the 4th types should use the "Linksys EtherCard" entry.
     * Therefore, the Linksys entry should be before the D-Link.  --itohy
     */
    { PCMCIA_STR_LINKSYS_ECARD_1, 
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ECARD_1,
      PCMCIA_CIS_LINKSYS_ECARD_1, 
      0, -1, { 0x00, 0x80, 0xc8 } },
d130 1
a130 1
    { PCMCIA_STR_DLINK_DE650,
d132 2
a133 2
      PCMCIA_CIS_DLINK_DE650,
      0, 0x0040, { 0x00, 0x80, 0xc8 } },
d151 5
d175 18
d209 10
a218 4
    { PCMCIA_STR_UNKNOWN_ECARD,
      PCMCIA_VENDOR_UNKNOWN, PCMCIA_PRODUCT_UNKNOWN_ECARD,
      PCMCIA_CIS_UNKNOWN_ECARD,
      0, -1, { 0x00, 0xa0, 0x0c } },
@


1.4
log
@Support for RealTek 8019 and 8029 NE2000-compatible network interfaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.3 1998/11/05 09:12:52 fgsch Exp $	*/
d198 5
@


1.3
log
@D-Link DE-650 has many minor versions.  Be sure to use the correct one.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.2 1998/10/14 07:34:43 fgsch Exp $	*/
d62 3
d336 8
d484 22
a505 1
	printf("%s: %s Ethernet\n", dsc->sc_dev.dv_xname, ne_dev->name);
d507 1
a507 1
	ne2000_attach(nsc, enaddr);
@


1.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ne_pcmcia.c,v 1.1 1998/09/22 09:16:36 fgsch Exp $	*/
a106 5
    { PCMCIA_STR_DLINK_DE650,
      PCMCIA_VENDOR_INVALID, PCMCIA_PRODUCT_INVALID,
      PCMCIA_CIS_DLINK_DE650,
      0, 0x0040, { 0x00, 0x80, 0xc8 } },

d123 23
a159 5

    { PCMCIA_STR_LINKSYS_ECARD_1, 
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ECARD_1,
      PCMCIA_CIS_LINKSYS_ECARD_1, 
      0, -1, { 0x00, 0x80, 0xc8 } },
@


1.1
log
@Support for ne2k pcmcia. This is the driver without modifications.
feedback time.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a96 5
    { PCMCIA_STR_IBM_INFOMOVER,
      PCMCIA_VENDOR_IBM, PCMCIA_PRODUCT_IBM_INFOMOVER,
      PCMCIA_CIS_IBM_INFOMOVER,
      0, 0x0ff0, { 0x08, 0x00, 0x5a } },

a101 15
    { PCMCIA_STR_LINKSYS_ECARD, 
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_ECARD,
      PCMCIA_CIS_LINKSYS_ECARD, 
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_STR_LINKSYS_COMBO_ECARD, 
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_COMBO_ECARD, 
      0, -1, { 0x00, 0x80, 0xc8 } },

    { PCMCIA_STR_LINKSYS_TRUST_COMBO_ECARD,
      PCMCIA_VENDOR_LINKSYS, PCMCIA_PRODUCT_LINKSYS_TRUST_COMBO_ECARD,
      PCMCIA_CIS_LINKSYS_TRUST_COMBO_ECARD,
      0, 0x0120, { 0x20, 0x04, 0x49 } },

a116 11
    { PCMCIA_STR_IODATA_PCLAT,
      PCMCIA_VENDOR_IODATA, PCMCIA_PRODUCT_IODATA_PCLAT,
      PCMCIA_CIS_IODATA_PCLAT,
      /* two possible location, 0x01c0 or 0x0ff0 */
      0, -1, { 0x00, 0xa0, 0xb0 } },

    { PCMCIA_STR_DAYNA_COMMUNICARD_E,
      PCMCIA_VENDOR_DAYNA, PCMCIA_PRODUCT_DAYNA_COMMUNICARD_E,
      PCMCIA_CIS_DAYNA_COMMUNICARD_E,
      0, 0x0110, { 0x00, 0x80, 0x19 } },

d126 56
@

