head	1.48;
access;
symbols
	OPENBSD_6_1:1.47.0.6
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.47.0.2
	OPENBSD_6_0_BASE:1.47
	OPENBSD_5_9:1.46.0.6
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.14
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.46.0.12
	OPENBSD_5_7_BASE:1.46
	OPENBSD_5_6:1.46.0.10
	OPENBSD_5_6_BASE:1.46
	OPENBSD_5_5:1.46.0.8
	OPENBSD_5_5_BASE:1.46
	OPENBSD_5_4:1.46.0.4
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.46.0.2
	OPENBSD_5_3_BASE:1.46
	OPENBSD_5_2:1.45.0.4
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.45
	OPENBSD_5_1:1.45.0.2
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.39.0.12
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.8
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.10
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.6
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.4
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.37.0.6
	OPENBSD_4_2_BASE:1.37
	OPENBSD_4_1:1.37.0.4
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.2
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.35.0.4
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.2
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.34.0.2
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.33.0.8
	OPENBSD_3_6_BASE:1.33
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	OPENBSD_3_5:1.33.0.6
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.33.0.4
	OPENBSD_3_4_BASE:1.33
	UBC_SYNC_A:1.33
	OPENBSD_3_3:1.33.0.2
	OPENBSD_3_3_BASE:1.33
	OPENBSD_3_2:1.32.0.4
	OPENBSD_3_2_BASE:1.32
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.32
	UBC:1.30.0.4
	UBC_BASE:1.30
	OPENBSD_3_0:1.30.0.2
	OPENBSD_3_0_BASE:1.30
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.4
	OPENBSD_2_8:1.29.0.2
	OPENBSD_2_8_BASE:1.29
	OPENBSD_2_7:1.28.0.2
	OPENBSD_2_7_BASE:1.28
	SMP:1.25.0.2
	SMP_BASE:1.25
	kame_19991208:1.24
	OPENBSD_2_6:1.24.0.2
	OPENBSD_2_6_BASE:1.24
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.10.0.4
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.48
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.47;
commitid	uRv5pa9QDlZaYgwD;

1.47
date	2016.06.06.07.09.44;	author mpi;	state Exp;
branches;
next	1.46;
commitid	yFKbYtFC4kjpAUmU;

1.46
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2011.09.17.15.38.43;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.01.11.45.42;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.31.17.13.47;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.07.18.21.40;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2006.04.16.20.43.12;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.13.18.17.40;	author fgsch;	state Exp;
branches;
next	1.35;

1.35
date	2005.08.05.18.21.04;	author fgsch;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2002.01.11.01.31.21;	author nordin;	state Exp;
branches;
next	1.30;

1.30
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.30.4.1;
next	1.29;

1.29
date	2000.06.28.17.38.25;	author aaron;	state Exp;
branches;
next	1.28;

1.28
date	2000.04.28.13.36.58;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	2000.04.24.19.06.00;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2000.04.08.05.50.51;	author aaron;	state Exp;
branches;
next	1.25;

1.25
date	2000.02.05.22.10.50;	author deraadt;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	99.08.16.21.46.11;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	99.08.16.16.51.20;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	99.08.16.07.45.22;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	99.08.16.06.46.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	99.08.16.06.21.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	99.08.08.01.00.14;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.07.30.17.13.51;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.07.01.13.48.07;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	99.07.01.06.27.00;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	99.05.27.13.36.55;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	99.05.27.13.32.38;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	99.03.04.23.23.56;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.28.04.58.31;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	98.09.11.10.47.14;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	97.08.19.21.59.49;	author angelos;	state Exp;
branches;
next	1.9;

1.9
date	97.04.17.08.21.12;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.28.23.28.16;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.47.07;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.12.36.54;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.07.34.17;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.03.07.59.40;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.29.14.17.15;	author hvozda;	state Exp;
branches;
next	1.2;

1.2
date	96.01.26.21.27.31;	author hvozda;	state Exp;
branches;
next	1.1;

1.1
date	96.01.15.00.05.03;	author hvozda;	state Exp;
branches;
next	;

1.25.2.1
date	2001.05.14.22.26.07;	author niklas;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.25.2.3;

1.25.2.3
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.25.2.4;

1.25.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.25.2.5;

1.25.2.5
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	;

1.30.4.1
date	2002.01.31.22.55.37;	author niklas;	state Exp;
branches;
next	1.30.4.2;

1.30.4.2
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.30.4.3;

1.30.4.3
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.48
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: pcmcia.c,v 1.47 2016/06/06 07:09:44 mpi Exp $	*/
/*	$NetBSD: pcmcia.c,v 1.9 1998/08/13 02:10:55 eeh Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciachip.h>
#include <dev/pcmcia/pcmciavar.h>

#ifdef PCMCIADEBUG
#define	DPRINTF(arg) printf arg
#else
#define	DPRINTF(arg)
#endif

#ifdef PCMCIAVERBOSE
int	pcmcia_verbose = 1;
#else
int	pcmcia_verbose = 0;
#endif

int	pcmcia_match(struct device *, void *, void *);
int	pcmcia_submatch(struct device *, void *, void *);
void	pcmcia_attach(struct device *, struct device *, void *);
int	pcmcia_activate(struct device *, int);
int	pcmcia_print(void *, const char *);
void	pcmcia_card_detach_notify(struct device *, void *);
int	pcmcia_card_intr(void *);

struct cfdriver pcmcia_cd = {
	NULL, "pcmcia", DV_DULL
};

struct cfattach pcmcia_ca = {
	sizeof(struct pcmcia_softc), pcmcia_match, pcmcia_attach, NULL,
	pcmcia_activate
};

int
pcmcia_ccr_read(pf, ccr)
	struct pcmcia_function *pf;
	int ccr;
{

	return (bus_space_read_1(pf->pf_ccrt, pf->pf_ccrh,
	    pf->pf_ccr_offset + ccr));
}

void
pcmcia_ccr_write(pf, ccr, val)
	struct pcmcia_function *pf;
	int ccr;
	int val;
{

	if ((pf->ccr_mask) & (1 << (ccr / 2))) {
		bus_space_write_1(pf->pf_ccrt, pf->pf_ccrh,
		    pf->pf_ccr_offset + ccr, val);
	}
}

int
pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct pcmciabus_attach_args *paa = aux;

	if (strcmp(paa->paa_busname, cf->cf_driver->cd_name))
		return 0;

	/* If the autoconfiguration got this far, there's a socket here. */
	return (1);
}

void
pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcmciabus_attach_args *paa = aux;
	struct pcmcia_softc *sc = (struct pcmcia_softc *) self;

	printf("\n");

	sc->pct = paa->pct;
	sc->pch = paa->pch;
	sc->iobase = paa->iobase;
	sc->iosize = paa->iosize;

	sc->ih = NULL;
}

int
pcmcia_activate(struct device *self, int act)
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *)self;
	struct pcmcia_function *pf;

	switch (act) {
	case DVACT_QUIESCE:
	case DVACT_SUSPEND:
	case DVACT_POWERDOWN:
	case DVACT_RESUME:
		for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
		     pf = SIMPLEQ_NEXT(pf, pf_list)) {
			if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL ||
			    pf->child == NULL)
				continue;
			config_suspend(pf->child, act);
		}
		break;
	case DVACT_DEACTIVATE:
		for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
		     pf = SIMPLEQ_NEXT(pf, pf_list)) {
			if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL ||
			    pf->child == NULL)
				continue;
			config_deactivate(pf->child);
		}
		break;
	}
	return (0);
}

int
pcmcia_card_attach(dev)
	struct device *dev;
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *) dev;
	struct pcmcia_function *pf;
	struct pcmcia_attach_args paa;
	int attached;

	/*
	 * this is here so that when socket_enable calls gettype, trt happens
	 */
	SIMPLEQ_FIRST(&sc->card.pf_head) = NULL;

	pcmcia_chip_socket_enable(sc->pct, sc->pch);

	pcmcia_read_cis(sc);

	pcmcia_chip_socket_disable(sc->pct, sc->pch);

	pcmcia_check_cis_quirks(sc);

	/*
	 * Bail now if there was an error in the CIS.
	 */

	if (sc->card.error)
		return (1);

#if 0
	if (SIMPLEQ_EMPTY(&sc->card.pf_head))
		return (1);
#endif

	if (pcmcia_verbose)
		pcmcia_print_cis(sc);

	/*
	 * If there was no function, this might be CIS-less card we still
	 * want to probe.  Fixup a function element for it.
	 */
	if (SIMPLEQ_FIRST(&sc->card.pf_head) == NULL) {
		pf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT | M_ZERO);
		if (pf == NULL)
			panic("pcmcia_card_attach");
		pf->number = 0;
		pf->pf_flags = PFF_FAKE;
		pf->last_config_index = -1;
		SIMPLEQ_INIT(&pf->cfe_head);
		SIMPLEQ_INSERT_TAIL(&sc->card.pf_head, pf, pf_list);
	}

	attached = 0;

	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	    pf = SIMPLEQ_NEXT(pf, pf_list)) {
		pf->sc = sc;
		pf->child = NULL;
		pf->cfe = NULL;
		pf->ih_fct = NULL;
		pf->ih_arg = NULL;
	}

	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	    pf = SIMPLEQ_NEXT(pf, pf_list)) {
		paa.manufacturer = sc->card.manufacturer;
		paa.product = sc->card.product;
		paa.card = &sc->card;
		paa.pf = pf;

		pf->child = config_found_sm(&sc->dev, &paa, pcmcia_print,
		    pcmcia_submatch);
		if (pf->child) {
			attached++;

			if ((pf->pf_flags & (PFF_FAKE | PFF_ENABLED)) ==
			    PFF_ENABLED)
				DPRINTF(("%s: function %d CCR at %d offset %lx"
					": %x %x %x %x, %x %x %x %x, %x\n",
					sc->dev.dv_xname, pf->number,
					pf->pf_ccr_window, pf->pf_ccr_offset,
					pcmcia_ccr_read(pf, 0x00),
					pcmcia_ccr_read(pf, 0x02),
					pcmcia_ccr_read(pf, 0x04),
					pcmcia_ccr_read(pf, 0x06),
					pcmcia_ccr_read(pf, 0x0A),
					pcmcia_ccr_read(pf, 0x0C),
					pcmcia_ccr_read(pf, 0x0E),
					pcmcia_ccr_read(pf, 0x10),
					pcmcia_ccr_read(pf, 0x12)));
		}
	}
	return (attached ? 0 : 1);
}

void
pcmcia_card_detach(dev, flags)
	struct device *dev;
	int flags;		/* DETACH_* flags */
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *) dev;
	struct pcmcia_function *pf;
	int error;

	/*
	 * We are running on either the PCMCIA socket's event thread
	 * or in user context detaching a device by user request.
	 */
	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	     pf = SIMPLEQ_NEXT(pf, pf_list)) {
		if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)
			continue;
		if (pf->child == NULL)
			continue;
		DPRINTF(("%s: detaching %s (function %d)\n",
		    sc->dev.dv_xname, pf->child->dv_xname, pf->number));
		if ((error = config_detach(pf->child, flags)) != 0) {
			printf("%s: error %d detaching %s (function %d)\n",
			    sc->dev.dv_xname, error, pf->child->dv_xname,
			    pf->number);
		} else
			pf->child = NULL;
	}
}

void
pcmcia_card_deactivate(dev)
	struct device *dev;
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *) dev;
	struct pcmcia_function *pf;

	/*
	 * We're in the chip's card removal interrupt handler.
	 * Deactivate the child driver.  The PCMCIA socket's
	 * event thread will run later to finish the detach.
	 */
	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	     pf = SIMPLEQ_NEXT(pf, pf_list)) {
		if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL ||
		    pf->child == NULL)
			continue;
		DPRINTF(("%s: deactivating %s (function %d)\n",
		    sc->dev.dv_xname, pf->child->dv_xname, pf->number));
		config_deactivate(pf->child);
	}
}

int
pcmcia_submatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct pcmcia_attach_args *paa = aux;

	if (cf->cf_loc[0 /* PCMCIACF_FUNCTION */] !=
	    -1 /* PCMCIACF_FUNCTION_DEFAULT */ &&
	    cf->cf_loc[0 /* PCMCIACF_FUNCTION */] != paa->pf->number)
		return (0);

	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}

int
pcmcia_print(arg, pnp)
	void *arg;
	const char *pnp;
{
	struct pcmcia_attach_args *pa = arg;
	struct pcmcia_softc *sc = pa->pf->sc;
	struct pcmcia_card *card = &sc->card;
	int i;

	if (pnp) {
		for (i = 0; i < 4 && card->cis1_info[i]; i++)
			printf("%s%s", i ? ", " : "\"", card->cis1_info[i]);
		if (i != 0)
			printf("\"");

		if (card->manufacturer != PCMCIA_VENDOR_INVALID &&
		    card->product != PCMCIA_PRODUCT_INVALID) {
			if (i != 0)
				printf(" ");
			printf("(");
			if (card->manufacturer != PCMCIA_VENDOR_INVALID)
				printf("manufacturer 0x%x%s",
				    card->manufacturer,
				    card->product == PCMCIA_PRODUCT_INVALID ?
				    "" : ", ");
			if (card->product != PCMCIA_PRODUCT_INVALID)
				printf("product 0x%x",
				    card->product);
			printf(")");
		}
		if (i != 0)
			printf(" ");
		printf("at %s", pnp);
	}
	printf(" function %d", pa->pf->number);

	if (!pnp) {
		for (i = 0; i < 3 && card->cis1_info[i]; i++)
			printf("%s%s", i ? ", " : " \"", card->cis1_info[i]);
		if (i != 0)
			printf("\"");
	}

	return (UNCONF);
}

int
pcmcia_card_gettype(dev)
	struct device  *dev;
{
	struct pcmcia_softc *sc = (struct pcmcia_softc *)dev;
	struct pcmcia_function *pf;

	/*
	 * Set the iftype to memory if this card has no functions (not yet
	 * probed), or only one function, and that is not initialized yet or
	 * that is memory.
	 */
	pf = SIMPLEQ_FIRST(&sc->card.pf_head);
	if (pf == NULL || (SIMPLEQ_NEXT(pf, pf_list) == NULL &&
	    ((pf->pf_flags & PFF_FAKE) ||
	    pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))
		return (PCMCIA_IFTYPE_MEMORY);
	else
		return (PCMCIA_IFTYPE_IO);
}

/*
 * Initialize a PCMCIA function.  May be called as long as the function is
 * disabled.
 */
void
pcmcia_function_init(pf, cfe)
	struct pcmcia_function *pf;
	struct pcmcia_config_entry *cfe;
{
	if (pf->pf_flags & PFF_ENABLED)
		panic("pcmcia_function_init: function is enabled");

	/* Remember which configuration entry we are using. */
	pf->cfe = cfe;
}

/* Enable a PCMCIA function */
int
pcmcia_function_enable(pf)
	struct pcmcia_function *pf;
{
	struct pcmcia_function *tmp;
	int reg;

	if (pf->cfe == NULL)
		panic("pcmcia_function_enable: function not initialized");

	/*
	 * Increase the reference count on the socket, enabling power, if
	 * necessary.
	 */
	if (pf->sc->sc_enabled_count++ == 0)
		pcmcia_chip_socket_enable(pf->sc->pct, pf->sc->pch);
	DPRINTF(("%s: ++enabled_count = %d\n", pf->sc->dev.dv_xname,
		 pf->sc->sc_enabled_count));

	if (pf->pf_flags & PFF_ENABLED) {
		/*
		 * Don't do anything if we're already enabled.
		 */
		DPRINTF(("%s: pcmcia_function_enable on enabled func\n",
		    pf->sc->dev.dv_xname));
		return (0);
	}

	/* If there was no CIS don't mess with CCR */
	if (pf->pf_flags & PFF_FAKE)
		goto done;

	/*
	 * It's possible for different functions' CCRs to be in the same
	 * underlying page.  Check for that.
	 */
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
		if ((tmp->pf_flags & PFF_ENABLED) &&
		    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&
		    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=
		     (tmp->ccr_base - tmp->pf_ccr_offset +
		      tmp->pf_ccr_realsize))) {
			pf->pf_ccrt = tmp->pf_ccrt;
			pf->pf_ccrh = tmp->pf_ccrh;
			pf->pf_ccr_realsize = tmp->pf_ccr_realsize;

			/*
			 * pf->pf_ccr_offset = (tmp->pf_ccr_offset -
			 * tmp->ccr_base) + pf->ccr_base;
			 */
			pf->pf_ccr_offset =
			    (tmp->pf_ccr_offset + pf->ccr_base) -
			    tmp->ccr_base;
			pf->pf_ccr_window = tmp->pf_ccr_window;
			break;
		}
	}

	if (tmp == NULL) {
		if (pcmcia_mem_alloc(pf, PCMCIA_CCR_SIZE, &pf->pf_pcmh))
			goto bad;

		if (pcmcia_mem_map(pf, PCMCIA_MEM_ATTR, pf->ccr_base,
		    PCMCIA_CCR_SIZE, &pf->pf_pcmh, &pf->pf_ccr_offset,
		    &pf->pf_ccr_window)) {
			pcmcia_mem_free(pf, &pf->pf_pcmh);
			goto bad;
		}
	}

	reg = (pf->cfe->number & PCMCIA_CCR_OPTION_CFINDEX);
	reg |= PCMCIA_CCR_OPTION_LEVIREQ;
	if (pcmcia_mfc(pf->sc)) {
		reg |= PCMCIA_CCR_OPTION_FUNC_ENABLE;
		if (pf->ccr_mask & (1 << (PCMCIA_CCR_IOBASE0 / 2)))
			reg |= PCMCIA_CCR_OPTION_ADDR_DECODE;
		if (pf->ih_fct)
			reg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;

	}

	pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);

	reg = 0;

	if ((pf->cfe->flags & PCMCIA_CFE_IO16) == 0)
		reg |= PCMCIA_CCR_STATUS_IOIS8;
	if (pf->cfe->flags & PCMCIA_CFE_AUDIO)
		reg |= PCMCIA_CCR_STATUS_AUDIO;
	pcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);

	pcmcia_ccr_write(pf, PCMCIA_CCR_SOCKETCOPY, 0);

	if (pcmcia_mfc(pf->sc)) {
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,
				 (pf->pf_mfc_iobase >>  0) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,
				 (pf->pf_mfc_iobase >>  8) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2,
				 (pf->pf_mfc_iobase >> 16) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3,
				 (pf->pf_mfc_iobase >> 24) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE,
				 pf->pf_mfc_iomax - pf->pf_mfc_iobase);
	}

#ifdef PCMCIADEBUG
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
		printf("%s: function %d CCR at %d offset %lx: "
		       "%x %x %x %x, %x %x %x %x, %x\n",
		       tmp->sc->dev.dv_xname, tmp->number,
		       tmp->pf_ccr_window, tmp->pf_ccr_offset,
		       pcmcia_ccr_read(tmp, 0x00),
		       pcmcia_ccr_read(tmp, 0x02),
		       pcmcia_ccr_read(tmp, 0x04),
		       pcmcia_ccr_read(tmp, 0x06),

		       pcmcia_ccr_read(tmp, 0x0A),
		       pcmcia_ccr_read(tmp, 0x0C),
		       pcmcia_ccr_read(tmp, 0x0E),
		       pcmcia_ccr_read(tmp, 0x10),

		       pcmcia_ccr_read(tmp, 0x12));
	}
#endif

 done:
	pf->pf_flags |= PFF_ENABLED;
	delay(1000);
	return (0);

 bad:
	/*
	 * Decrement the reference count, and power down the socket, if
	 * necessary.
	 */
	if (--pf->sc->sc_enabled_count == 0)
		pcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);
	DPRINTF(("%s: --enabled_count = %d\n", pf->sc->dev.dv_xname,
		 pf->sc->sc_enabled_count));

	return (1);
}

/* Disable PCMCIA function. */
void
pcmcia_function_disable(pf)
	struct pcmcia_function *pf;
{
	struct pcmcia_function *tmp;

	if (pf->cfe == NULL)
		panic("pcmcia_function_enable: function not initialized");

	if ((pf->pf_flags & PFF_ENABLED) == 0) {
		/*
		 * Don't do anything if we're already disabled.
		 */
		return;
	}

	/* If there was no CIS don't mess with CCR */
	if (pf->pf_flags & PFF_FAKE) {
		pf->pf_flags &= ~PFF_ENABLED;
		goto done;
	}

	/*
	 * it's possible for different functions' CCRs to be in the same
	 * underlying page.  Check for that.  Note we mark us as disabled
	 * first to avoid matching ourself.
	 */
	pf->pf_flags &= ~PFF_ENABLED;
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
		if ((tmp->pf_flags & PFF_ENABLED) &&
		    (pf->ccr_base >= (tmp->ccr_base - tmp->pf_ccr_offset)) &&
		    ((pf->ccr_base + PCMCIA_CCR_SIZE) <=
		(tmp->ccr_base - tmp->pf_ccr_offset + tmp->pf_ccr_realsize)))
			break;
	}

	/* Not used by anyone else; unmap the CCR. */
	if (tmp == NULL) {
		pcmcia_mem_unmap(pf, pf->pf_ccr_window);
		pcmcia_mem_free(pf, &pf->pf_pcmh);
	}

 done:
	/*
	 * Decrement the reference count, and power down the socket, if
	 * necessary.
	 */
	if (--pf->sc->sc_enabled_count == 0)
		pcmcia_chip_socket_disable(pf->sc->pct, pf->sc->pch);
	DPRINTF(("%s: --enabled_count = %d\n", pf->sc->dev.dv_xname,
		 pf->sc->sc_enabled_count));
}

int
pcmcia_io_map(pf, width, offset, size, pcihp, windowp)
	struct pcmcia_function *pf;
	int width;
	bus_addr_t offset;
	bus_size_t size;
	struct pcmcia_io_handle *pcihp;
	int *windowp;
{
	int reg;

	if (pcmcia_chip_io_map(pf->sc->pct, pf->sc->pch,
	    width, offset, size, pcihp, windowp))
		return (1);

	/*
	 * XXX In the multifunction multi-iospace-per-function case, this
	 * needs to cooperate with io_alloc to make sure that the spaces
	 * don't overlap, and that the ccr's are set correctly.
	 */

	if (pcmcia_mfc(pf->sc) &&
	    (pf->ccr_mask & (1 << (PCMCIA_CCR_IOBASE0 / 2)))) {
		bus_addr_t iobase = pcihp->addr;
		bus_addr_t iomax = pcihp->addr + pcihp->size - 1;

		if (pf->pf_mfc_iomax == 0) {
			pf->pf_mfc_iobase = iobase;
			pf->pf_mfc_iomax = iomax;
		} else {
			if (iobase < pf->pf_mfc_iobase)
				pf->pf_mfc_iobase = iobase;
			if (iomax > pf->pf_mfc_iomax)
				pf->pf_mfc_iomax = iomax;
		}

		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE0,
				 (pf->pf_mfc_iobase >>  0) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE1,
				 (pf->pf_mfc_iobase >>  8) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2,
				 (pf->pf_mfc_iobase >> 16) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3,
				 (pf->pf_mfc_iobase >> 24) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE,
				 pf->pf_mfc_iomax - pf->pf_mfc_iobase);

		reg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);
		reg |= PCMCIA_CCR_OPTION_ADDR_DECODE;
		pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);
	}
	return (0);
}

void *
pcmcia_intr_establish(pf, ipl, ih_fct, ih_arg, xname)
	struct pcmcia_function *pf;
	int ipl;
	int (*ih_fct)(void *);
	void *ih_arg;
	char *xname;
{
	void *ret;
	int s, ihcnt, hiipl, reg;
	struct pcmcia_function *pf2;

	/* Behave differently if this is a multifunction card. */
	if (pcmcia_mfc(pf->sc)) {
		/*
		 * Mask all the ipl's which are already used by this card,
		 * and find the highest ipl number (lowest priority).
		 */
		ihcnt = 0;
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
			if (pf2->ih_fct) {
				DPRINTF(("%s: function %d has ih_fct %p\n",
				    pf->sc->dev.dv_xname, pf2->number,
				    pf2->ih_fct));

				if (ihcnt == 0)
					hiipl = pf2->ih_ipl;
				else if (pf2->ih_ipl > hiipl)
					hiipl = pf2->ih_ipl;

				ihcnt++;
			}
		}

		/*
		 * Establish the real interrupt, changing the ipl if
		 * necessary.
		 */
		if (ihcnt == 0) {
#ifdef DIAGNOSTIC
			if (pf->sc->ih != NULL)
				panic("card has intr handler, "
				    "but no function does");
#endif
			s = spltty();

			/* Set up the handler for the new function. */
			pf->ih_fct = ih_fct;
			pf->ih_arg = ih_arg;
			pf->ih_ipl = ipl;

			pf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc,
			    xname);
			splx(s);
		} else if (ipl > hiipl) {
#ifdef DIAGNOSTIC
			if (pf->sc->ih == NULL)
				panic("functions have ih, "
				    "but the card does not");
#endif

			s = spltty();

			pcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,
			    pf->sc->ih);

			/* set up the handler for the new function */
			pf->ih_fct = ih_fct;
			pf->ih_arg = ih_arg;
			pf->ih_ipl = ipl;

			pf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc,
			    xname);

			splx(s);
		} else {
			s = spltty();

			/* Set up the handler for the new function. */
			pf->ih_fct = ih_fct;
			pf->ih_arg = ih_arg;
			pf->ih_ipl = ipl;

			splx(s);
		}

		ret = pf->sc->ih;

		if (ret != NULL) {
			reg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);
			reg |= PCMCIA_CCR_OPTION_IREQ_ENABLE;
			pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);

			reg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);
			reg |= PCMCIA_CCR_STATUS_INTRACK;
			pcmcia_ccr_write(pf, PCMCIA_CCR_STATUS, reg);
		}
	} else
		ret = pcmcia_chip_intr_establish(pf->sc->pct, pf->sc->pch,
		    pf, ipl, ih_fct, ih_arg, xname);

	return (ret);
}

void
pcmcia_intr_disestablish(pf, ih)
	struct pcmcia_function *pf;
	void *ih;
{
	int s, reg, ihcnt, hiipl;
	struct pcmcia_function *pf2;

	/* Behave differently if this is a multifunction card.  */
	if (pcmcia_mfc(pf->sc)) {
		/*
		 * Mask all the ipl's which are already used by this card,
		 * and find the highest ipl number (lowest priority).  Skip
		 * the current function.
		 */
		ihcnt = 0;
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
			if (pf2 == pf)
				continue;

			if (pf2->ih_fct) {
				if (ihcnt == 0)
					hiipl = pf2->ih_ipl;
				else if (pf2->ih_ipl > hiipl)
					hiipl = pf2->ih_ipl;
				ihcnt++;
			}
		}

		/*
		 * If the ih being removed is lower priority than the lowest
		 * priority remaining interrupt, up the priority.
		 */

		/*
		 * ihcnt is the number of interrupt handlers *not* including
		 * the one about to be removed.
		 */
		if (ihcnt == 0) {
#ifdef DIAGNOSTIC
			if (pf->sc->ih == NULL)
				panic("disestablishing last function, but card has no ih");
#endif
			pcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,
			    pf->sc->ih);

			reg = pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION);
			reg &= ~PCMCIA_CCR_OPTION_IREQ_ENABLE;
			pcmcia_ccr_write(pf, PCMCIA_CCR_OPTION, reg);

			pf->ih_fct = NULL;
			pf->ih_arg = NULL;

			pf->sc->ih = NULL;
		} else if (pf->ih_ipl > hiipl) {
#ifdef DIAGNOSTIC
			if (pf->sc->ih == NULL)
				panic("changing ih ipl, but card has no ih");
#endif
			s = spltty();

			pcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch,
			    pf->sc->ih);
			pf->sc->ih = pcmcia_chip_intr_establish(pf->sc->pct,
			    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc,
			    NULL);

			/* Null out the handler for this function. */
			pf->ih_fct = NULL;
			pf->ih_arg = NULL;

			splx(s);
		} else {
			s = spltty();

			pf->ih_fct = NULL;
			pf->ih_arg = NULL;

			splx(s);
		}
	} else
		pcmcia_chip_intr_disestablish(pf->sc->pct, pf->sc->pch, ih);
}

const char *
pcmcia_intr_string(pf, ih)
	struct pcmcia_function *pf;
	void *ih;
{
	return pcmcia_chip_intr_string(pf->sc->pct, pf->sc->pch, ih);
}

int
pcmcia_card_intr(arg)
	void *arg;
{
	struct pcmcia_softc *sc = arg;
	struct pcmcia_function *pf;
	int reg, ret, ret2;

	ret = 0;

	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	    pf = SIMPLEQ_NEXT(pf, pf_list)) {
#ifdef PCMCIADEBUG
		printf("%s: intr flags=%x fct=%d cor=%02x csr=%02x pin=%02x",
		       sc->dev.dv_xname, pf->pf_flags, pf->number,
		       pcmcia_ccr_read(pf, PCMCIA_CCR_OPTION),
		       pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS),
		       pcmcia_ccr_read(pf, PCMCIA_CCR_PIN));
#endif
		if (pf->ih_fct != NULL &&
		    (pf->ccr_mask & (1 << (PCMCIA_CCR_STATUS / 2)))) {
			reg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);
			if (reg & PCMCIA_CCR_STATUS_INTR) {
				ret2 = (*pf->ih_fct)(pf->ih_arg);
				if (ret2 != 0 && ret == 0)
					ret = ret2;
				reg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);
#ifdef PCMCIADEBUG
				printf("; csr %02x->%02x",
				    reg, reg & ~PCMCIA_CCR_STATUS_INTR);
#endif
				pcmcia_ccr_write(pf, PCMCIA_CCR_STATUS,
				    reg & ~PCMCIA_CCR_STATUS_INTR);
			}
		}
#ifdef PCMCIADEBUG
		printf("\n");
#endif
	}

	return (ret);
}
@


1.47
log
@Kill unused function wrappers, from David Hill.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.46 2012/10/08 21:47:50 deraadt Exp $	*/
a32 1
#include <sys/types.h>
@


1.46
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.45 2011/09/17 15:38:43 miod Exp $	*/
d61 1
a61 7

static inline void pcmcia_socket_enable(pcmcia_chipset_tag_t,
					     pcmcia_chipset_handle_t *);
static inline void pcmcia_socket_disable(pcmcia_chipset_tag_t,
					      pcmcia_chipset_handle_t *);

int pcmcia_card_intr(void *);
a405 14
}

static inline void pcmcia_socket_enable(pct, pch)
     pcmcia_chipset_tag_t pct;
     pcmcia_chipset_handle_t *pch;
{
	pcmcia_chip_socket_enable(pct, pch);
}

static inline void pcmcia_socket_disable(pct, pch)
     pcmcia_chipset_tag_t pct;
     pcmcia_chipset_handle_t *pch;
{
	pcmcia_chip_socket_disable(pct, pch);
@


1.45
log
@Fix a truncated DPRINTF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.44 2011/07/03 15:47:17 matthew Exp $	*/
d143 1
@


1.44
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.43 2010/09/07 16:21:46 deraadt Exp $	*/
d451 2
a452 1
		DPRINTF(("%s: pcmcia_function_enable on enabled func\n"));
@


1.43
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.42 2010/09/01 11:45:42 miod Exp $	*/
a140 3
	case DVACT_ACTIVATE:
		/* No children yet */
		break;
@


1.42
log
@Failure to attach a pcmcia driver could leave the function to be disabled
after config_found() returns; check for this and do not invoke pcmcia_ccr_read()
on a disabled function in the following DPRINTF. No change for kernels
without option PCMCIADEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.41 2010/08/31 17:13:47 deraadt Exp $	*/
a60 1
void	pcmcia_powerhook(int why, void *arg);
a131 1
	powerhook_establish(pcmcia_powerhook, sc);
a165 6
}

void
pcmcia_powerhook(int why, void *arg)
{
	pcmcia_activate(arg, why);
@


1.41
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.40 2010/08/30 20:33:18 deraadt Exp $	*/
d251 2
a252 1
			if ((pf->pf_flags & PFF_FAKE) == 0)
@


1.40
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.39 2007/09/11 13:39:34 gilles Exp $	*/
d146 3
a148 1
	case DVACT_DEACTIVATE:
d154 1
a154 1
			config_deactivate(pf->child);
d157 1
a157 2
	case DVACT_SUSPEND:
	case DVACT_RESUME:
d163 1
a163 1
			config_suspend(pf->child, act);
d167 1
a167 1
	return 0;
@


1.39
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.38 2007/09/07 18:21:40 fgsch Exp $	*/
d58 1
d61 1
a61 1
void	pcmcia_power(int why, void *arg);
d75 2
a76 1
	sizeof(struct pcmcia_softc), pcmcia_match, pcmcia_attach
d133 1
a133 1
	powerhook_establish(pcmcia_power, sc);
d136 2
a137 4
void
pcmcia_power(why, arg)
	int why;
	void *arg;
d139 1
a139 1
	struct pcmcia_softc *sc = (struct pcmcia_softc *) arg;
a140 5
	struct device *d;
	int act = DVACT_ACTIVATE;

	if (why != PWR_RESUME)
		act = DVACT_DEACTIVATE;
d142 10
a151 10
	for (pf = SIMPLEQ_FIRST(&sc->card.pf_head); pf != NULL;
	     pf = SIMPLEQ_NEXT(pf, pf_list)) {
		if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)
			continue;
		d = pf->child;
		if (d == NULL)
			continue;
		if (act == DVACT_ACTIVATE)
			config_activate(pf->child);
		else
d153 12
d166 7
d313 2
a314 3
		if (SIMPLEQ_FIRST(&pf->cfe_head) == NULL)
			continue;
		if (pf->child == NULL)
@


1.38
log
@sprinkle some M_ZERO love.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.37 2006/04/16 20:43:12 miod Exp $	*/
d203 1
a203 1
		pf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.37
log
@If we stumble on a card with no declared functions, try attaching it anyway,
in case some driver knows better.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.36 2006/03/13 18:17:40 fgsch Exp $	*/
d203 1
a203 1
		pf = malloc(sizeof *pf, M_DEVBUF, M_NOWAIT);
a205 1
		bzero(pf, sizeof *pf);
@


1.36
log
@Set the address decode bit only if the iobase 0 register is available.
Fixes the wd part of the sandisk wifi + 128 CF.
Only multi function cards are affected at this time.  quasi ok from uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.35 2005/08/05 18:21:04 fgsch Exp $	*/
a182 1
#if 1
d184 1
a184 2
	 * Bail now if the card has no functions, or if there was an error in
	 * the CIS.
d189 2
d339 2
a340 1
		printf("\"");
d344 1
a344 1
			if (i)
d357 1
a357 1
		if (i)
d366 2
a367 1
		printf("\"");
@


1.35
log
@correct io base/limit registers handling. from mycroft. only affects
multi function cards for now. this fixes the Novatel Wireless Merlin UMTS
Modem reported by Bolke de Bruin <bdbruin at aub dot nl>
tested by several ppl, commit deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.34 2005/01/27 17:03:23 millert Exp $	*/
d371 1
a371 1
int 
d495 3
a497 2
		reg |= (PCMCIA_CCR_OPTION_FUNC_ENABLE |
			PCMCIA_CCR_OPTION_ADDR_DECODE);
d502 1
a502 1
	
d514 1
a514 1
	
d520 1
a520 1
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 
d540 1
a540 1
		       pcmcia_ccr_read(tmp, 0x0C), 
d641 2
a642 1
	if (pcmcia_mfc(pf->sc)) {
d872 1
a872 1
int 
@


1.34
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.33 2002/11/19 18:36:18 jason Exp $	*/
a514 8
		long tmp, iosize;

		tmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;
		/* round up to nearest (2^n)-1 */
		for (iosize = 1; iosize < tmp; iosize <<= 1)
			;
		iosize--;

d516 1
a516 1
				 pf->pf_mfc_iobase & 0xff);
d518 7
a524 5
				 (pf->pf_mfc_iobase >> 8) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);

		pcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);
d641 2
a642 1
		long tmp, iosize;
d645 2
a646 2
			pf->pf_mfc_iobase = pcihp->addr + offset;
			pf->pf_mfc_iomax = pf->pf_mfc_iobase + size;
d648 4
a651 5
			/* This makes the assumption that nothing overlaps. */
			if (pf->pf_mfc_iobase > pcihp->addr + offset)
				pf->pf_mfc_iobase = pcihp->addr + offset;
			if (pf->pf_mfc_iomax < pcihp->addr + offset + size)
				pf->pf_mfc_iomax = pcihp->addr + offset + size;
a653 6
		tmp = pf->pf_mfc_iomax - pf->pf_mfc_iobase;
		/* round up to nearest (2^n)-1 */
		for (iosize = 1; iosize >= tmp; iosize <<= 1)
			;
		iosize--;

d655 1
a655 1
				 pf->pf_mfc_iobase & 0xff);
d657 7
a663 5
				 (pf->pf_mfc_iobase >> 8) & 0xff);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE2, 0);
		pcmcia_ccr_write(pf, PCMCIA_CCR_IOBASE3, 0);

		pcmcia_ccr_write(pf, PCMCIA_CCR_IOSIZE, iosize);
@


1.33
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.32 2002/03/14 01:27:01 millert Exp $	*/
d870 8
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.31 2002/01/11 01:31:21 nordin Exp $	*/
d173 1
a173 1
	sc->card.pf_head.sqh_first = NULL;
d191 1
a191 1
	if (sc->card.pf_head.sqh_first == NULL)
d458 1
a458 2
	for (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;
	    tmp = tmp->pf_list.sqe_next) {
d534 1
a534 2
	for (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;
	     tmp = tmp->pf_list.sqe_next) {
d600 1
a600 2
	for (tmp = pf->sc->card.pf_head.sqh_first; tmp != NULL;
	    tmp = tmp->pf_list.sqe_next) {
d701 1
a701 2
		for (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;
		    pf2 = pf2->pf_list.sqe_next)
d714 1
d804 1
a804 2
		for (pf2 = pf->sc->card.pf_head.sqh_first; pf2 != NULL;
		    pf2 = pf2->pf_list.sqe_next) {
@


1.31
log
@Check result from malloc(9) when using M_NOWAIT. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.30 2001/08/17 21:52:16 deraadt Exp $	*/
d55 11
a65 11
int	pcmcia_match __P((struct device *, void *, void *));
int	pcmcia_submatch __P((struct device *, void *, void *));
void	pcmcia_attach __P((struct device *, struct device *, void *));
int	pcmcia_print __P((void *, const char *));
void	pcmcia_card_detach_notify __P((struct device *, void *));
void	pcmcia_power __P((int why, void *arg));

static inline void pcmcia_socket_enable __P((pcmcia_chipset_tag_t,
					     pcmcia_chipset_handle_t *));
static inline void pcmcia_socket_disable __P((pcmcia_chipset_tag_t,
					      pcmcia_chipset_handle_t *));
d67 1
a67 1
int pcmcia_card_intr __P((void *));
d689 1
a689 1
	int (*ih_fct) __P((void *));
@


1.30
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.29 2000/06/28 17:38:25 aaron Exp $	*/
d204 2
@


1.30.4.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.31 2002/01/11 01:31:21 nordin Exp $	*/
a203 2
		if (pf == NULL)
			panic("pcmcia_card_attach");
@


1.30.4.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.30.4.1 2002/01/31 22:55:37 niklas Exp $	*/
d55 11
a65 11
int	pcmcia_match(struct device *, void *, void *);
int	pcmcia_submatch(struct device *, void *, void *);
void	pcmcia_attach(struct device *, struct device *, void *);
int	pcmcia_print(void *, const char *);
void	pcmcia_card_detach_notify(struct device *, void *);
void	pcmcia_power(int why, void *arg);

static inline void pcmcia_socket_enable(pcmcia_chipset_tag_t,
					     pcmcia_chipset_handle_t *);
static inline void pcmcia_socket_disable(pcmcia_chipset_tag_t,
					      pcmcia_chipset_handle_t *);
d67 1
a67 1
int pcmcia_card_intr(void *);
d689 1
a689 1
	int (*ih_fct)(void *);
@


1.30.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d173 1
a173 1
	SIMPLEQ_FIRST(&sc->card.pf_head) = NULL;
d191 1
a191 1
	if (SIMPLEQ_EMPTY(&sc->card.pf_head))
d458 2
a459 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d535 2
a536 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d602 2
a603 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d704 2
a705 1
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
a717 1
		}
d807 2
a808 1
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
@


1.29
log
@Don't call the drivers' xxx_activate() function directly -- use the system
config_activate() and config_deactivate() routines instead. This way, the
DVF_ACTIVE bit gets updated appropriately.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.28 2000/04/28 13:36:58 niklas Exp $	*/
d684 1
a684 1
pcmcia_intr_establish(pf, ipl, ih_fct, ih_arg)
d689 1
d735 2
a736 1
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc);
d756 2
a757 1
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc);
d784 1
a784 1
		    pf, ipl, ih_fct, ih_arg);
d854 2
a855 1
			    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);
@


1.28
log
@Disable framework for recognition of CIS-less cards, several other match
functions in the tree does not cope well.  Since we have no driver for any
CIS-less cards, this disabling does not take away functionality, it only
removes a strcmp panic in the pcmcia probes.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.27 2000/04/24 19:06:00 niklas Exp $	*/
d154 4
a157 2
		if (d->dv_cfdata->cf_attach->ca_activate)
			(*d->dv_cfdata->cf_attach->ca_activate)(d, act);
@


1.27
log
@wait just a bit for enabling to settle, fixes pccom on an xe
when using the faster cardbus mode of the PCI1131 chip
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.26 2000/04/08 05:50:51 aaron Exp $	*/
d181 1
a181 1
#if 0
@


1.26
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.25 2000/02/05 22:10:50 deraadt Exp $	*/
d553 1
@


1.25
log
@if card has an activate function, call it on apm power changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.24 1999/08/16 21:46:11 fgsch Exp $	*/
d105 6
@


1.25.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.29 2000/06/28 17:38:25 aaron Exp $	*/
a104 6
	struct cfdata *cf = match;
	struct pcmciabus_attach_args *paa = aux;

	if (strcmp(paa->paa_busname, cf->cf_driver->cd_name))
		return 0;

d148 2
a149 4
		if (act == DVACT_ACTIVATE)
			config_activate(pf->child);
		else
			config_deactivate(pf->child);
d175 1
a175 1
#if 1
a546 1
	delay(1000);
@


1.25.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.25.2.1 2001/05/14 22:26:07 niklas Exp $	*/
d684 1
a684 1
pcmcia_intr_establish(pf, ipl, ih_fct, ih_arg, xname)
a688 1
	char *xname;
d734 1
a734 2
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc,
			    xname);
d754 1
a754 2
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc,
			    xname);
d781 1
a781 1
		    pf, ipl, ih_fct, ih_arg, xname);
d851 1
a851 2
			    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc,
			    NULL);
@


1.25.2.3
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a203 2
		if (pf == NULL)
			panic("pcmcia_card_attach");
@


1.25.2.4
log
@Merge in -current from roughly a week ago
@
text
@d55 11
a65 11
int	pcmcia_match(struct device *, void *, void *);
int	pcmcia_submatch(struct device *, void *, void *);
void	pcmcia_attach(struct device *, struct device *, void *);
int	pcmcia_print(void *, const char *);
void	pcmcia_card_detach_notify(struct device *, void *);
void	pcmcia_power(int why, void *arg);

static inline void pcmcia_socket_enable(pcmcia_chipset_tag_t,
					     pcmcia_chipset_handle_t *);
static inline void pcmcia_socket_disable(pcmcia_chipset_tag_t,
					      pcmcia_chipset_handle_t *);
d67 1
a67 1
int pcmcia_card_intr(void *);
d689 1
a689 1
	int (*ih_fct)(void *);
@


1.25.2.5
log
@Sync the SMP branch with 3.3
@
text
@d173 1
a173 1
	SIMPLEQ_FIRST(&sc->card.pf_head) = NULL;
d191 1
a191 1
	if (SIMPLEQ_EMPTY(&sc->card.pf_head))
d458 2
a459 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d535 2
a536 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d602 2
a603 1
	SIMPLEQ_FOREACH(tmp, &pf->sc->card.pf_head, pf_list) {
d704 2
a705 1
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
a717 1
		}
d807 2
a808 1
		SIMPLEQ_FOREACH(pf2, &pf->sc->card.pf_head, pf_list) {
@


1.24
log
@remove space.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.23 1999/08/16 16:51:20 deraadt Exp $	*/
d60 1
d125 26
@


1.23
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.22 1999/08/16 07:45:22 fgsch Exp $	*/
d301 1
a301 1
			printf("%s%s", i ? ", " : " \"", card->cis1_info[i]);
d312 2
a313 1
				    card->product == PCMCIA_PRODUCT_INVALID ? "" : ", ");
@


1.22
log
@Fix typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.21 1999/08/16 06:46:18 deraadt Exp $	*/
d304 2
a305 1
		if (card->manufacturer != -1 && card->product != -1) {
d309 2
a310 2
			if (card->manufacturer != -1)
				printf("manufacturer 0x%lx%s",
d312 3
a314 3
				    card->product == -1 ? "" : ", ");
			if (card->product != -1)
				printf("product 0x%lx",
@


1.21
log
@even nicer
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.20 1999/08/16 06:21:13 deraadt Exp $	*/
d313 1
a313 1
				printf("product 0x%lx%s",
@


1.20
log
@repair output of pcmcia_print() to match pciprint() and others; fgsch and I
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.19 1999/08/08 01:00:14 niklas Exp $	*/
d300 2
a301 6
		printf("\"");
		for (i = 0; i < 4 && card->cis1_info[i]; i++) {
			if (i)
				printf(", ");
			printf("%s", card->cis1_info[i]);
		}
d324 2
a325 6
		printf(" \"");
		for (i = 0; i < 3 && card->cis1_info[i]; i++) {
			if (i)
				printf(" ");
			printf("%s", card->cis1_info[i]);
		}
@


1.19
log
@Support detaching.  Support CIS-less cards.  Style police.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.18 1999/07/30 17:13:51 deraadt Exp $	*/
d300 2
a301 8
		int p = 0;
		for (i = 0; i < 4; i++) {
			if (p == 0) {
				printf("\"");
				p = 1;
			}
			if (card->cis1_info[i] == NULL)
				break;
d306 2
a307 4
		if (p)
			printf("\"");
		if (i)
			printf(" ");
d309 2
d321 3
d326 10
@


1.18
log
@pretty print manufacturer and product for unknown devices
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.17 1999/07/01 13:48:07 niklas Exp $	*/
d37 1
d59 1
d104 1
a104 1
	/* if the autoconfiguration got this far, there's a socket here */
d148 1
d150 2
a151 2
	 * bail now if the card has no functions, or if there was an error in
	 * the cis.
d158 1
d163 14
d179 2
a180 2
	for (pf = sc->card.pf_head.sqh_first; pf != NULL;
	    pf = pf->pf_list.sqe_next) {
d182 1
d188 2
a189 2
	for (pf = sc->card.pf_head.sqh_first; pf != NULL;
	    pf = pf->pf_list.sqe_next) {
d195 3
a197 2
		if (config_found_sm(&sc->dev, &paa, pcmcia_print,
		    pcmcia_submatch)) {
d200 1
a200 1
			if (SIMPLEQ_FIRST(&pf->cfe_head)) {
a213 1
			}
d220 31
a250 1
pcmcia_card_detach(dev)
d253 18
a270 2
	/* struct pcmcia_softc *sc = (struct pcmcia_softc *) dev; */
	/* don't do anything yet */
d341 1
a341 1
	 * set the iftype to memory if this card has no functions (not yet
d346 3
a348 3
	if (pf == NULL ||
	    (SIMPLEQ_NEXT(pf, pf_list) == NULL &&
	    (pf->cfe == NULL || pf->cfe->iftype == PCMCIA_IFTYPE_MEMORY)))
d412 4
d417 1
a417 1
	 * it's possible for different functions' CCRs to be in the same
d517 1
d551 6
a561 1

d578 1
d605 1
a605 1
	 * XXX in the multifunction multi-iospace-per-function case, this
d607 1
a607 1
	 * don't overlap, and that the ccr's are set correctly
d617 1
a617 1
			/* this makes the assumption that nothing overlaps */
d654 2
d657 1
a657 2
	/* behave differently if this is a multifunction card */

a658 3
		int s, ihcnt, hiipl, reg;
		struct pcmcia_function *pf2;

d660 2
a661 2
		 * mask all the ipl's which are already used by this card,
		 * and find the highest ipl number (lowest priority)
a662 1

a663 5
		s = 0;		/* this is only here to keep the compiler
				   happy */
		hiipl = 0;	/* this is only here to keep the compiler
				   happy */

d665 1
a665 1
		     pf2 = pf2->pf_list.sqe_next) {
d668 2
a669 2
					 pf->sc->dev.dv_xname, pf2->number,
					 pf2->ih_fct));
d671 3
a673 1
				if (ihcnt == 0) {
a674 4
				} else {
					if (pf2->ih_ipl > hiipl)
						hiipl = pf2->ih_ipl;
				}
a677 1
		}
d680 2
a681 2
		 * establish the real interrupt, changing the ipl if
		 * necessary
a682 1

d686 2
a687 1
				panic("card has intr handler, but no function does");
d691 1
a691 2
			/* set up the handler for the new function */

d702 2
a703 1
				panic("functions have ih, but the card does not");
d709 1
a709 1
						      pf->sc->ih);
d723 1
a723 2
			/* set up the handler for the new function */

d742 1
a742 1
	} else {
a744 1
	}
d754 2
a755 1
	/* behave differently if this is a multifunction card */
d757 1
a758 3
		int s, ihcnt, hiipl;
		struct pcmcia_function *pf2;

d760 1
a760 1
		 * mask all the ipl's which are already used by this card,
a763 1

a764 5
		s = 0;		/* this is only here to keep the compipler
				   happy */
		hiipl = 0;	/* this is only here to keep the compipler
				   happy */

d766 1
a766 1
		     pf2 = pf2->pf_list.sqe_next) {
d771 3
a773 1
				if (ihcnt == 0) {
a774 4
				} else {
					if (pf2->ih_ipl > hiipl)
						hiipl = pf2->ih_ipl;
				}
d780 1
a780 1
		 * if the ih being removed is lower priority than the lowest
d784 4
a787 3
		/* ihcnt is the number of interrupt handlers *not* including
		   the one about to be removed. */

a788 2
			int reg;

d816 1
a816 2
			/* null out the handler for this function */

d829 1
a829 1
	} else {
a830 1
	}
d843 2
a844 2
	for (pf = sc->card.pf_head.sqh_first; pf != NULL;
	    pf = pf->pf_list.sqe_next) {
@


1.17
log
@Forgotten changes needed by the Xircom driver.  Includes acceptance
of config-less functions, lowering of some splhighs to spltty and some
stylistic changes
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.16 1999/07/01 06:27:00 fgsch Exp $	*/
d251 11
a261 2
		printf("(manufacturer 0x%x, product 0x%x)", card->manufacturer,
		       card->product);
@


1.16
log
@This should fix the problem reported by mickey@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.15 1999/05/27 13:36:55 niklas Exp $	*/
a162 3
		if (pf->cfe_head.sqh_first == NULL)
			continue;

a170 3
		if (pf->cfe_head.sqh_first == NULL)
			continue;

d180 15
a194 9
			DPRINTF(("%s: function %d CCR at %d "
			     "offset %lx: %x %x %x %x, %x %x %x %x, %x\n",
			     sc->dev.dv_xname, pf->number,
			     pf->pf_ccr_window, pf->pf_ccr_offset,
			     pcmcia_ccr_read(pf, 0x00),
			pcmcia_ccr_read(pf, 0x02), pcmcia_ccr_read(pf, 0x04),
			pcmcia_ccr_read(pf, 0x06), pcmcia_ccr_read(pf, 0x0A),
			pcmcia_ccr_read(pf, 0x0C), pcmcia_ccr_read(pf, 0x0E),
			pcmcia_ccr_read(pf, 0x10), pcmcia_ccr_read(pf, 0x12)));
a196 1

d334 1
a341 1

d386 1
d398 1
a398 1

d615 1
a615 1
			s = splhigh();
d632 1
a632 2
			/* XXX need #ifdef for splserial on x86 */
			s = splhigh();
d647 1
a647 1
			s = splhigh();
d747 1
a747 2
			/* XXX need #ifdef for splserial on x86 */
			s = splhigh();
d761 1
a761 1
			s = splhigh();
@


1.15
log
@Revert accidentally committed stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.13 1999/03/04 23:23:56 deraadt Exp $	*/
a43 1
#define PCMCIA_CARD_INTR (pcmcia_card_intrdebug)
a45 1
#define PCMCIA_CARD_INTR (pcmcia_card_intr)
a63 3
#ifdef PCMCIADEBUG
int pcmcia_card_intrdebug __P((void *));
#else
a64 1
#endif
d624 1
a624 1
			    pf->sc->pch, pf, ipl, PCMCIA_CARD_INTR, pf->sc);
d644 1
a644 1
			    pf->sc->pch, pf, ipl, PCMCIA_CARD_INTR, pf->sc);
d754 1
a754 1
			    pf->sc->pch, pf, hiipl, PCMCIA_CARD_INTR, pf->sc);
a786 17
		if (pf->ih_fct != NULL &&
		    (pf->ccr_mask & (1 << (PCMCIA_CCR_STATUS / 2)))) {
			reg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);
			if (reg & PCMCIA_CCR_STATUS_INTR) {
				ret2 = (*pf->ih_fct)(pf->ih_arg);
				if (ret2 != 0 && ret == 0)
					ret = ret2;
				reg = pcmcia_ccr_read(pf, PCMCIA_CCR_STATUS);
				pcmcia_ccr_write(pf, PCMCIA_CCR_STATUS,
				    reg & ~PCMCIA_CCR_STATUS_INTR);
			}
		}
	}

	return (ret);
}

a787 12
int 
pcmcia_card_intrdebug(arg)
	void *arg;
{
	struct pcmcia_softc *sc = arg;
	struct pcmcia_function *pf;
	int reg, ret, ret2;

	ret = 0;

	for (pf = sc->card.pf_head.sqh_first; pf != NULL;
	    pf = pf->pf_list.sqe_next) {
d793 1
d802 1
d805 1
d810 1
d812 1
a816 1
#endif
@


1.14
log
@A Sound+SCSI card
@
text
@d169 3
d180 3
d192 9
a200 15
			if (SIMPLEQ_FIRST(&pf->cfe_head)) {
				DPRINTF(("%s: function %d CCR at %d offset %lx"
				    ": %x %x %x %x, %x %x %x %x, %x\n",
				    sc->dev.dv_xname, pf->number,
				    pf->pf_ccr_window, pf->pf_ccr_offset,
				    pcmcia_ccr_read(pf, 0x00),
				    pcmcia_ccr_read(pf, 0x02),
				    pcmcia_ccr_read(pf, 0x04),
				    pcmcia_ccr_read(pf, 0x06),
				    pcmcia_ccr_read(pf, 0x0A),
				    pcmcia_ccr_read(pf, 0x0C),
				    pcmcia_ccr_read(pf, 0x0E),
				    pcmcia_ccr_read(pf, 0x10),
				    pcmcia_ccr_read(pf, 0x12)));
			}
d335 1
a335 1
	    pf->sc->sc_enabled_count));
d341 1
a341 2
		DPRINTF(("%s: pcmcia_function_enable on enabled func\n"));
 		return (0);
d348 1
a392 1

d621 1
a621 1
			s = spltty();
d638 2
a639 1
			s = spltty();
d642 1
a642 1
			    pf->sc->ih);
d654 1
a654 1
			s = spltty();
d754 2
a755 1
			s = spltty();
d769 1
a769 1
			s = spltty();
a780 1
#ifndef PCMCIADEBUG
d810 1
a810 1
#else	/* PCMCIADEBUG */
d847 1
a847 1
#endif	/* PCMCIADEBUG */
@


1.13
log
@" quote in pcmcia_print
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.12 1999/01/28 04:58:31 fgsch Exp $	*/
a168 3
		if (pf->cfe_head.sqh_first == NULL)
			continue;

a176 3
		if (pf->cfe_head.sqh_first == NULL)
			continue;

d186 15
a200 9
			DPRINTF(("%s: function %d CCR at %d "
			     "offset %lx: %x %x %x %x, %x %x %x %x, %x\n",
			     sc->dev.dv_xname, pf->number,
			     pf->pf_ccr_window, pf->pf_ccr_offset,
			     pcmcia_ccr_read(pf, 0x00),
			pcmcia_ccr_read(pf, 0x02), pcmcia_ccr_read(pf, 0x04),
			pcmcia_ccr_read(pf, 0x06), pcmcia_ccr_read(pf, 0x0A),
			pcmcia_ccr_read(pf, 0x0C), pcmcia_ccr_read(pf, 0x0E),
			pcmcia_ccr_read(pf, 0x10), pcmcia_ccr_read(pf, 0x12)));
d335 1
a335 1
		 pf->sc->sc_enabled_count));
d341 2
a342 1
		return (0);
a348 1

d393 1
d622 1
a622 1
			s = splhigh();
d639 1
a639 2
			/* XXX need #ifdef for splserial on x86 */
			s = splhigh();
d642 1
a642 1
						      pf->sc->ih);
d654 1
a654 1
			s = splhigh();
d754 1
a754 2
			/* XXX need #ifdef for splserial on x86 */
			s = splhigh();
d768 1
a768 1
			s = splhigh();
d780 1
d810 1
a810 1
#ifdef PCMCIADEBUG
d847 1
a847 1
#endif
@


1.12
log
@Add support for:
	- 3COM 3CXEM556 (Ethernet/Modem)
	- SVEC Combo and Lancard
	- Corega PCC-T
Add pcmcia_check_cis_quirks to fix some cards whose CIS flat-out lies.
Add more products to pcmciadevs.
Correctly read 1 controller if CL-PD6729.
Remove some unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.11 1998/09/11 10:47:14 fgsch Exp $	*/
d242 1
d244 4
d254 2
@


1.11
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a37 3
/* XXX only needed for intr debugging */
#include <vm/vm.h>

d43 2
a44 2
int	pcmcia_debug = 1;
#define	DPRINTF(arg) if (pcmcia_debug) printf arg
d47 1
d66 3
d70 1
d150 2
d417 16
a432 6
	DPRINTF(("%s: function %d CCR at %d offset %lx: "
		 "%x %x %x %x, %x %x %x %x, %x\n",
		 pf->sc->dev.dv_xname, pf->number,
		 pf->pf_ccr_window, pf->pf_ccr_offset,
		 pcmcia_ccr_read(pf, 0x00), pcmcia_ccr_read(pf, 0x02),
		 pcmcia_ccr_read(pf, 0x04), pcmcia_ccr_read(pf, 0x06),
d434 3
a436 4
		 pcmcia_ccr_read(pf, 0x0A), pcmcia_ccr_read(pf, 0x0C), 
		 pcmcia_ccr_read(pf, 0x0E), pcmcia_ccr_read(pf, 0x10),

		 pcmcia_ccr_read(pf, 0x12)));
d623 1
a623 1
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc);
d643 1
a643 1
			    pf->sc->pch, pf, ipl, pcmcia_card_intr, pf->sc);
d753 1
a753 1
			    pf->sc->pch, pf, hiipl, pcmcia_card_intr, pf->sc);
d786 31
a816 2
#if 0
		printf("%s: intr flags=%x fct=%d physaddr=%lx cor=%02x csr=%02x pin=%02x",
a817 2
		       pmap_extract(pmap_kernel(),
		           (vaddr_t) pf->pf_ccrh) + pf->pf_ccr_offset,
a820 1
#endif
a828 1
#if 0
a830 1
#endif
a834 1
#if 0
a835 1
#endif
d840 1
@


1.10
log
@- add wavelan files in files.pcmcia
- accept version 5.0 from the card as legal
- fix the mapping (pcmcia.c, pcmcia_read_cis())
@
text
@d1 2
a2 1
/*	$OpenBSD: pcmcia.c,v 1.9 1997/04/17 08:21:12 niklas Exp $	*/
d5 1
a5 2
 * Copyright (c) 1996 John T. Kohl.  All rights reserved.
 * Copyright (c) 1994 Stefan Grefen.  All rights reserved.
d17 1
a17 2
 *	This product includes software developed by Charles Hannum.
 *	This product includes software developed by Stefan Grefen.
a30 1
 *
a32 12
/*
 * XXX - these next two lines are just "glue" until the confusion over
 * pcmcia vs pcmciabus between the framework and sys/conf/files
 * gets resolved
 */
#define pcmciabus_cd pcmcia_cd
#define pcmciabus_ca pcmcia_ca

/*
 * derived from scsiconf.c writte by Julian Elischer et al
 * TODO add modload support and loadable lists of devices
 */
a35 1
#include <sys/malloc.h>
a36 3
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/proc.h>
d38 5
a43 2
#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmcia_ioctl.h>
d45 3
a47 5
#ifdef IBM_WD
#define PCMCIA_DEBUG
#endif
#ifdef PCMCIA_DEBUG
# define PPRINTF(a)	printf a
d49 1
a49 1
# define PPRINTF(a)
d52 4
a55 2
#ifdef PCMCIA_DEBUG
void pcmciadumpcf __P((struct pcmcia_conf *));
d58 4
a61 17
static struct old_devs {
	struct device *dev;
	struct pcmciadevs *pcdev;
} *deldevs;
static int      ndeldevs = 0;

#define PCMCIA_SERVICE(a,b,c,d,e)   ((a)->chip_link->pcmcia_service(b,c,\
								(void *) d,e))
#define PCMCIA_MAP_IO(a,b,c,d,e)    ((a)->chip_link->pcmcia_map_io(b,c,d,e))
#define PCMCIA_MAP_INTR(a,b,c,d)    ((a)->chip_link->pcmcia_map_intr(b,c,d))
/*
 * XXX
 * this is quite broken in the face of various bus mapping stuff...
 * drivers need to cooperate with the pcmcia framework to deal with
 * bus mapped memory.  Whee.
 */
#define PCMCIA_MAP_MEM(a,b,c,d,e,f,g) ((a)->chip_link->pcmcia_map_mem(b,c,d,e,f,g))
d63 4
a66 4
#define SCRATCH_MEM(a)	((caddr_t)(a)->scratch_memh)
#define SCRATCH_MEMT(a)	((a)->pa_memt)
#define SCRATCH_SIZE(a)	((a)->scratch_memsiz)
#define SCRATCH_INUSE(a)((a)->scratch_inuse)
d68 1
a68 17
/*
 * Declarations
 */
int pcmcia_probedev __P((struct pcmcia_link *, struct pcmcia_cardinfo *));
int pcmcia_probe_bus __P((int, int));
int pcmciabusmatch __P((struct device *, void *, void *));
void pcmciabusattach __P((struct device *, struct device *, void *));
int  pcmcia_mapcard __P((struct pcmcia_link *, int, struct pcmcia_conf *));
int  pcmcia_mapcard_and_configure __P((struct pcmcia_link *, int,
	struct pcmcia_conf *));

int pcmcia_unconfigure __P((struct pcmcia_link *));
int pcmcia_unmapcard __P((struct pcmcia_link *));

int pcmcia_print __P((void *, const char *));
int pcmcia_submatch __P((struct device *, void *, void *));
void pcmcia_probe_link __P((struct pcmcia_link *));
d70 3
a72 1
void pcmcia_detach __P((struct device *, void *));
d75 1
a75 1
	sizeof(struct pcmciabus_softc), pcmciabusmatch, pcmciabusattach,
d78 5
a82 3
struct cfdriver pcmcia_cd = {
	NULL, "pcmcia", DV_DULL, 1
};
d84 3
a86 7
int pcmciaopen __P((dev_t, int, int, struct proc *));
int pcmciaclose __P((dev_t, int, int, struct proc *));
int pcmciachip_ioctl __P((int, int, caddr_t));
int pcmciaslot_ioctl __P((struct pcmcia_link *, int, int, caddr_t));
int pcmciaioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int pcmciaselect __P((dev_t, int, struct proc *));
int pcmciammap __P((dev_t, int, int));
d88 5
a92 7
#if 0
int
pcmcia_register(adapter_softc, bus_link, chip_link, slot)
	void           *adapter_softc;
	struct pcmciabus_link *bus_link;
	struct pcmcia_funcs *chip_link;
	int             slot;
d94 4
a97 10
	PPRINTF(("- pcmcia_register\n"));
	if (pcmcia_cntrl == 0)
		bzero(pcmcia_drivers, sizeof(pcmcia_drivers));

	if (pcmcia_cntrl < 4) {
		pcmcia_drivers[slot].adapter_softc = adapter_softc;
		pcmcia_drivers[slot].chip_link = chip_link;
		pcmcia_drivers[slot].bus_link = bus_link;
		pcmcia_cntrl++;
		return 1;
a98 1
	return 0;
a99 1
#endif
d102 3
a104 4
pcmciabusmatch(parent, self, aux)
	struct device	*parent;
	void 		*self;
	void		*aux;
d106 2
a107 13
	struct pcmciabus_softc *sc = (void *)self;
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
	struct pcmciabus_attach_args *pba = aux;
	struct pcmcia_adapter *pca = pba->pba_aux;
	int found = 0;

	PPRINTF(("- pcmciabusmatch %p %p\n", pba, pca));

	if (pca->bus_link) {
		if (PCMCIA_BUS_INIT(pca, parent, cf, aux, pca, 0))
			found++;
	}
	return found != 0;
a109 4
/*
 * The routine called by the adapter boards to get all their
 * devices configured in.
 */
d111 3
a113 4
pcmciabusattach(parent, self, aux)
	struct device	*parent;
	struct device 	*self;
	void		*aux;
d115 3
a117 9
	struct pcmciabus_softc *sc = (struct pcmciabus_softc *) self;
	struct cfdata  *cf = self->dv_cfdata;
	struct pcmciabus_attach_args *pba = aux;
	struct pcmcia_adapter *pca = pba->pba_aux;

	PPRINTF(("- pcmciabusattach\n"));
	if (pca->bus_link) {
		PCMCIA_BUS_INIT(pca, parent, cf, aux, pca, 1);
	}
d120 6
a125 4
	sc->sc_driver = pca;
	sc->sc_iot = pba->pba_iot;
	sc->sc_memt = pba->pba_memt;
	pcmcia_probe_bus(sc->sc_dev.dv_unit, -1);
a127 6
/*
 * Probe the requested pcmcia bus. It must be already set up.
 * -1 requests all set up pcmcia busses.
 */
int pcmcia_probe_busses __P((int, int));

d129 2
a130 2
pcmcia_probe_busses(bus, slot)
	int             bus, slot;
d132 20
a151 10
	PPRINTF(("- pcmcia_probe_busses\n"));
	if (bus == -1) {
		for (bus = 0; bus < pcmciabus_cd.cd_ndevs; bus++)
			if (pcmciabus_cd.cd_devs[bus])
				pcmcia_probe_bus(bus, slot);
		return 0;
	} else {
		return pcmcia_probe_bus(bus, slot);
	}
}
d153 14
a166 4
/* Macros to clear/set/test flags. */
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))
d168 4
a171 25
/*
 * Probe the requested pcmcia bus. It must be already set up.
 */
int
pcmcia_probe_bus(bus, slot)
	int             bus, slot;
{
	struct pcmciabus_softc *pcmcia;
	int             maxslot, minslot;
	struct pcmcia_link *link;

	PPRINTF(("- pcmcia_probe_bus\n"));
	if (bus < 0 || bus >= pcmciabus_cd.cd_ndevs)
		return ENXIO;
	pcmcia = pcmciabus_cd.cd_devs[bus];
	if (!pcmcia || pcmcia->sc_driver == NULL) /* bus is not configured */
		return ENXIO;

	if (slot == -1) {
		maxslot = pcmcia->sc_driver->nslots - 1;
		minslot = 0;
	} else {
		if (slot < 0 || slot >= pcmcia->sc_driver->nslots)
			return EINVAL;
		maxslot = minslot = slot;
d174 4
a177 5
	for (slot = minslot; slot <= maxslot; slot++) {
		if ((link = pcmcia->sc_link[slot])) {
			if (link->devp)
				continue;
		}
d179 18
a196 14
		/*
	         * If we presently don't have a link block
	         * then allocate one
	         */
		if (!link) {
			pcmcia->sc_link[slot] = link =
				malloc(sizeof(*link), M_TEMP, M_NOWAIT);
			if (link == NULL)
				return ENOMEM;
			bzero(link, sizeof(*link));
			link->opennings = 1;
			link->adapter = pcmcia->sc_driver;
			link->bus = pcmcia;
			link->slot = slot;
a197 1
		(void) pcmcia_probe_link(link);
d199 2
a200 1
	return 0;
d204 11
a214 2
pcmcia_probe_link(link)
	struct pcmcia_link *link;
d216 7
a222 4
	struct pcmcia_cardinfo cardinfo;
	struct pcmcia_attach_args paa;
	struct pcmciabus_softc *pcmcia = link->bus;
	int             i;
d224 2
a225 11
	PPRINTF(("- pcmcia_probe_link %p\n", link));
	/*
	 * Set up card and fetch card info.
	 */
	if (pcmcia_probedev(link, &cardinfo) == 0) {
		/* could not fetch its strings, so give up on it. */
		PCMCIA_SERVICE(link->adapter,
			       link, PCMCIA_OP_POWER,
			       0, 0);
		return;
	}
d227 22
a248 18
	/*
	 * See if we can reattach a device.
	 */
	CLR(link->flags, PCMCIA_ATTACH_TYPE);
	SET(link->flags, PCMCIA_REATTACH);
	for (i = 0; i < ndeldevs; i++) {
		if (deldevs[i].dev) {
			PPRINTF(("trying device\n"));
			link->device = deldevs[i].pcdev;
			if (pcmcia_configure(deldevs[i].dev->dv_parent,
					     deldevs[i].dev, link)) {
				CLR(link->flags, PCMCIA_ATTACH_TYPE);
				SET(link->flags, PCMCIA_SLOT_INUSE);
				deldevs[i].dev = NULL;
				deldevs[i].pcdev = NULL;
				return;
			}
		}
d250 1
d252 2
d255 6
a260 7
	paa.paa_cardinfo = &cardinfo;
	paa.paa_link = link;
	paa.paa_aux = NULL;
	paa.paa_bestmatch = 0;
	paa.paa_matchonly = 1;
	CLR(link->flags, PCMCIA_ATTACH_TYPE);
	SET(link->flags, PCMCIA_ATTACH);
d263 3
a265 3
	 * Run the config matching routines to find us a good match.
	 * match routines will flag on "matchonly" and fill in stuff
	 * into the link structure, but not return any match.
d267 7
a273 22
	(void) config_found_sm(&pcmcia->sc_dev,
			       &paa,
			       pcmcia_print,
			       pcmcia_submatch);

	if (PCMCIA_BUS_SEARCH(link->adapter,
			      &pcmcia->sc_dev,
			      link, NULL)) {
		CLR(link->flags, PCMCIA_ATTACH_TYPE);
		SET(link->flags, PCMCIA_SLOT_INUSE);
	} else {
		CLR(link->flags, PCMCIA_ATTACH_TYPE|PCMCIA_SLOT_INUSE);
		link->device = NULL;
		printf("%s slot %d: No matching config entry.\n",
		       pcmcia->sc_dev.dv_xname,
		       link->slot);
		PCMCIA_SERVICE(link->adapter,
			       link, PCMCIA_OP_POWER,
			       0, 0);
		link->fordriver = NULL;
	}
	return;
d277 2
a278 3
 * given a target ask the device what
 * it is, and find the correct driver table
 * entry.
d280 27
d308 2
a309 3
pcmcia_probedev(link, cardinfo)
	struct pcmcia_link *link;
	struct pcmcia_cardinfo *cardinfo;
d311 20
a330 17
	struct pcmcia_adapter *pca = link->adapter;
	u_char          scratch[CIS_MAXSIZE];
	int             card_stat;
	int             err;
	int             pow = 0;
	int             slot = link->slot;

	PPRINTF(("- pcmcia_probe_dev\n"));

	printf("%s slot %d: ", ((struct device *) link->bus)->dv_xname, slot);

	/* turn off power in case it's on, to get a fresh start on things: */
	PCMCIA_SERVICE(pca, link, PCMCIA_OP_POWER, 0, 0);
	if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_STATUS,
				  &card_stat, 0)) != 0) {
		printf("failed to get status %d\n", err);
		return NULL;
d333 15
a347 4
	if (ISSET(card_stat, PCMCIA_CARD_PRESENT) == 0) {
		printf("empty\n");
		return NULL;
	}
d349 9
a357 7
	if (!ISSET(card_stat, PCMCIA_POWER)) {
		pow = 1;
		if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_POWER, 10000,
					  PCMCIA_POWER_ON|
					  PCMCIA_POWER_5V)) != 0) {
			printf("failed to turn on power %d\n", err);
			return NULL;
d361 9
a369 6
	if (!ISSET(link->flags, (PCMCIA_SLOT_INUSE | CARD_IS_MAPPED))) {
		if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_RESET,
					  500000, 0)) != 0) {
			printf("failed to reset %d\n", err);
			PCMCIA_SERVICE(pca, link, PCMCIA_OP_POWER, 0, 0);
			return NULL;
d373 7
a379 7
	/*
	 * Ask the device what it is
	 */
	if ((err = pcmcia_read_cis(link, scratch, 0, sizeof(scratch))) != 0) {
		printf("failed to read cis info %d\n", err);
		goto bad;
	}
a380 6
	if ((err = pcmcia_get_cisver1(link, scratch, sizeof(scratch),
				      cardinfo->manufacturer,
				      cardinfo->model, cardinfo->add_info1,
				      cardinfo->add_info2)) != 0) {
		printf("failed to get cis info %d\n", err);
		goto bad;
d382 1
d384 1
a384 13
	printf("<%s, %s", cardinfo->manufacturer, cardinfo->model);
	if (cardinfo->add_info1[0])
		printf(", %s", cardinfo->add_info1);
	if (cardinfo->add_info2[0])
		printf(", %s", cardinfo->add_info2);
	printf(">\n");

	return 1;
bad:
	if (!pow)
		PCMCIA_SERVICE(pca, link, PCMCIA_OP_POWER, 0, 0);
	return 0;
}
d386 5
a390 19
int
pcmcia_configure(parent, self, aux)
	struct device  *parent;
	void 	       *self;
	void           *aux;
{
	struct device  *dev = self;
	struct pcmcia_link *link = aux;
	struct cfdata  *cf = dev->dv_cfdata;
	struct cfdriver *cd = cf->cf_driver;
	struct pcmciadevs *pcs = link->device;
	struct pcmcia_device *pcd;
	struct pcmcia_adapter *pca = link->adapter;
	struct pcmcia_conf pc_cf;
	char *devname = (char *) link->fordriver;
	u_char          scratch[CIS_MAXSIZE];
	int             mymap = 0;

	PPRINTF(("- pcmcia_configure\n"));
d392 1
a392 2
	if ((devname && strcmp(devname, cd->cd_name)) || !pca)
		return 0;
d394 2
a395 2
	if (link->devp)
		return 0;		/* something else already attached */
d397 5
a401 50
	if (pcs == NULL)
		pcd = NULL;
	else
		pcd = pcs->dev;

	PPRINTF(("pcmcia_configure: %p\n", pcd));
	if (!ISSET(link->flags, CARD_IS_MAPPED)) {
		/* read 'suggested' configuration */
		PPRINTF(("pcmcia_configure: calling read cis\n"));
		if (pcmcia_read_cis(link, scratch, 0, sizeof(scratch)) != 0)
			return 0;

		bzero(&pc_cf, sizeof(pc_cf));

		PPRINTF(("pcmcia_configure: calling get cf\n"));
		if (pcmcia_get_cf(link, scratch, sizeof(scratch), -1,
				  &pc_cf) != 0)
			return 0;
#ifdef PCMCIA_DEBUG
		pcmciadumpcf(&pc_cf);
#endif
		/* and modify it (device specific) */
		if (pcd && pcd->pcmcia_config) {
			PPRINTF(("pcmcia_configure: calling config %p %p\n",
				 pcd, pcd->pcmcia_config));
			if ((*pcd->pcmcia_config)(link, dev, &pc_cf, cf))
				return 0;

			if ((pc_cf.cfgtype & CFGENTRYMASK) == CFGENTRYID) {
				PPRINTF(("pcmcia_configure: calling cf2\n"));
				if (pcmcia_get_cf(link, scratch,
						  sizeof(scratch), -2,
						  &pc_cf) != 0)
					return 0;

				PPRINTF(("pcmcia_configure: calling conf2\n"));
				if (pcd->pcmcia_config(link, dev, &pc_cf, cf))
					return 0;
				/* give it a try */
				if(pc_cf.cfgid==0)
				    pc_cf.cfgid=1;
			}
		} else {
			PPRINTF(("pcmcia_configure: calling bus config\n"));
			if (PCMCIA_BUS_CONFIG(pca, link, dev, &pc_cf, cf))
				return 0;
		}
#ifdef PCMCIA_DEBUG
		pcmciadumpcf(&pc_cf);
#endif
d403 6
a408 2
		if (pcmcia_mapcard(link, -1, &pc_cf) != 0)
			return 0;
d410 1
a410 1
		mymap = 1;
a411 1
	link->devp = dev;
d413 6
a418 5
	PPRINTF(("pcmcia_configure: calling bus attach\n"));
	if (!(PCMCIA_BUS_PROBE(pca, parent, dev, cf, link))) {
		PPRINTF(("pcmcia_configure: bus probe failed\n"));
		goto bad;
	}
d420 2
a421 4
	if (pcd && pcd->pcmcia_insert && pcd->pcmcia_insert(link, dev, cf)) {
		PPRINTF(("pcmcia_configure: pcmcia_insert failed\n"));
		goto bad;
	}
d423 1
a423 1
	return 1;
d425 2
a426 7
bad:
	link->devp = NULL;
	if (mymap)
		pcmcia_unmapcard(link);
	PPRINTF(("pcmcia_configure: configuration error\n"));
	return 0;
}
d428 9
a436 6
void
pcmcia_detach(dev, arg)
	struct device *dev;
	void *arg;
{
	struct pcmcia_link *link = arg;
d438 1
a438 4
	link->devp = NULL;
	printf("%s: device %s at slot %d detached/really\n",
	       dev->dv_parent->dv_xname,
	       dev->dv_xname, link->slot);
d441 4
a444 3
int
pcmcia_unconfigure(link)
	struct pcmcia_link *link;
d446 1
a446 8
	int             i;
	struct device  *dev;
	struct pcmcia_adapter *pca = link->adapter;
	struct pcmcia_device *pcd;

	PPRINTF(("- pcmcia_unconfigure\n"));
	if (link->devp == NULL)
		return ENODEV;
d448 2
a449 4
	if (link->device)
		pcd = link->device->dev;
	else
		pcd = NULL;
d451 1
a451 42
	if (ISSET(link->flags, CARD_IS_MAPPED)) {
		if (pcd && pcd->pcmcia_remove) {
			if ((*pcd->pcmcia_remove)(link, link->devp))
				return EBUSY;
		}
		else {
			if (PCMCIA_BUS_UNCONFIG(pca, link))
				return EBUSY;
		}
		if (pcmcia_unmapcard(link) != 0)
			return EBUSY;
	}
	if (config_detach(link->devp->dv_cfdata, pcmcia_detach, link)) {
		/* must be retained */
		for (i = 0; deldevs && deldevs[i].dev && i < ndeldevs; i++)
			continue;

		if (i >= ndeldevs) {
			int sz = ndeldevs ? (ndeldevs * 2) : 
				(MINALLOCSIZE / sizeof(deldevs[0]));
			struct old_devs *ndel = malloc(sz * sizeof(deldevs[0]),
						      M_DEVBUF, M_NOWAIT);
			if (!ndel) {
				PPRINTF(("pcmcia_delete: creating dev array"));
				return ENOMEM;
			}
			bzero(ndel, sz * sizeof(ndel[0]));
			if (ndeldevs) {
				bcopy(deldevs, ndel,
				      ndeldevs * sizeof(deldevs[0]));
				free(deldevs, M_DEVBUF);
			}
			ndeldevs = sz - 1;
			deldevs = ndel;
		}
		dev = deldevs[i].dev = link->devp;
		deldevs[i].pcdev = link->device;
		link->devp = NULL;
		TAILQ_REMOVE(&alldevs, dev, dv_list);
		printf("%s: device %s at slot %d detached/retained\n",
		       dev->dv_parent->dv_xname,
		       dev->dv_xname, link->slot);
d453 1
a453 4
		 * Make this node eligible to probe again.
		 * Since we're indirectly allocating state,
		 * this device data will not get trashed later and we
		 * can hold onto it.
d455 1
a455 1
/*		dev->dv_cfdata->cf_fstate = FSTATE_NOTFOUND;*/
a456 2
	return 0;
}
d458 5
a462 4
/*
 * Map the card into I/O and memory space, using the details provided
 * with pc_cf.
 */
d464 8
a471 39
int
pcmcia_mapcard(link, unit, pc_cf)
	struct pcmcia_link *link;
	int unit;
	struct pcmcia_conf *pc_cf;
{
	struct pcmcia_adapter *pca = link->adapter;
	int s, i, err;
	PPRINTF(("- pcmcia_mapcard\n"));

	if (pca == NULL)
		return ENXIO;
	s = splbio();

	while (SCRATCH_INUSE(pca))
		sleep((caddr_t) & SCRATCH_INUSE(pca), PZERO - 1);

	SCRATCH_INUSE(pca) = 1;
	splx(s);
	for (i = 0; i < pc_cf->memwin; i++) {
		if ((err = PCMCIA_MAP_MEM(pca, link, pca->pa_memt,
					  (caddr_t) pc_cf->mem[i].start,
					  pc_cf->mem[i].caddr,
					  pc_cf->mem[i].len,
					  (pc_cf->mem[i].flags &
					  (PCMCIA_MAP_16 | PCMCIA_MAP_ATTR)) |
					  i | PCMCIA_PHYSICAL_ADDR)) != 0) {
			PPRINTF(("pcmcia_mapcard: mapmem %d err%d\n", i, err));
			goto error;
		}
	}
	for (i = 0; i < pc_cf->iowin; i++) {
		if ((err = PCMCIA_MAP_IO(pca, link, pc_cf->io[i].start,
					 pc_cf->io[i].len,
					 (pc_cf->io[i].flags & (PCMCIA_MAP_16 |
					 PCMCIA_MAP_8)) | i)) != 0) {
			PPRINTF(("pcmcia_mapcard: mapio %d err %d\n", i, err));
			goto error;
		}
d474 4
a477 14
	if ((pc_cf->irq_num & 0xf) > 0) {
		if ((err = PCMCIA_MAP_INTR(pca, link, pc_cf->irq_num & 0xf,
					   0)) != 0) {
			PPRINTF(("pcmcia_mapcard: map_intr %d err %d\n", 
			         pc_cf->irq_num & 0xf, err));
			goto error;
		}
	}
	/* Now we've mapped everything enable it */
	if ((err = PCMCIA_MAP_MEM(pca, link, SCRATCH_MEMT(pca),
	     SCRATCH_MEM(pca), pc_cf->cfg_off & (~(SCRATCH_SIZE(pca) - 1)),
	     SCRATCH_SIZE(pca), PCMCIA_MAP_ATTR | PCMCIA_LAST_WIN)) != 0) {
		PPRINTF(("pcmcia_mapcard: enable err %d\n", err));
		goto error;
d480 9
a488 5
	if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_RESET, -500000,
				  pc_cf->iocard)) != 0) {
		PPRINTF(("failed to reset %d\n", err));
		goto error;
	}
d490 14
a503 11
#define GETMEM(x) bus_space_read_1(pca->pa_memt,			      \
    (bus_space_handle_t)SCRATCH_MEM(pca),				      \
    (pc_cf->cfg_off & (SCRATCH_SIZE(pca)-1)) + x)
#define PUTMEM(x,v) bus_space_write_1(pca->pa_memt,			      \
    (bus_space_handle_t)SCRATCH_MEM(pca),				      \
    (pc_cf->cfg_off & (SCRATCH_SIZE(pca)-1)) + x, v)

	if (ISSET(pc_cf->cfgtype, DOSRESET)) {
		PUTMEM(0, PCMCIA_SRESET);
		delay(50000);
	}
d505 5
d511 2
a512 11
	PPRINTF(("CMDR %x\n",(ISSET(pc_cf->cfgtype, CFGENTRYID) ?
			 pc_cf->cfgid |CFGENTRYID:
			 (pc_cf->cfgtype & CFGENTRYMASK)|1)|
		    (pc_cf->irq_level ? PCMCIA_LVLREQ : 0)
	));

	PUTMEM(0, (ISSET(pc_cf->cfgtype, CFGENTRYID) ?
		   pc_cf->cfgid |CFGENTRYID:
		   (pc_cf->cfgtype & CFGENTRYMASK)|1)|
	       (pc_cf->irq_level ? PCMCIA_LVLREQ : 0));
	delay(50000);
d514 10
a523 2
	if (ISSET(pc_cf->cfg_regmask, (1 << (PCMCIA_SCR / 2))))
		PUTMEM(PCMCIA_SCR, (link->slot & 1) | 0x10);
d525 5
a529 9
#if 0
	DPRINTF(("CCSR %x\n", GETMEM(PCMCIA_CCSR]));
	if (ISSET(GETMEM(PCMCIA_CCSR), PCMCIA_POWER_DOWN)) {
		u_char val = GETMEM(PCMCIA_CCSR);
		CLR(val, PCMCIA_POWER_DOWN);
		PUTMEM(PCMCIA_CCSR, var);
		DPRINTF(("CCSR now %x\n", GETMEM(PCMCIA_CCSR)));
	}
#endif
d531 6
d538 1
a538 1
	PPRINTF(("pcmcia_mapcard: about to initialize...\n"));
d540 3
a542 36
	if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_WAIT,
				  1000, 0)) != 0) {
		PPRINTF(("failed to initialize %d\n", err));
		err = 0;		/* XXX */
	}
error:
	PCMCIA_MAP_MEM(pca, link, SCRATCH_MEMT(pca), SCRATCH_MEM(pca), 0,
		       SCRATCH_SIZE(pca), PCMCIA_LAST_WIN | PCMCIA_UNMAP);
	if (err != 0) {
		PPRINTF(("pcmcia_mapcard: unmaping\n"));
		for (i = 0; i < pc_cf->memwin; i++) {
			PCMCIA_MAP_MEM(pca, link,
				       pca->pa_memt,
				       (caddr_t) pc_cf->mem[i].start,
				       pc_cf->mem[i].caddr,
				       pc_cf->mem[i].len,
				       (pc_cf->mem[i].flags & (PCMCIA_MAP_16 |
				       PCMCIA_MAP_ATTR)) | i |
				       PCMCIA_PHYSICAL_ADDR | PCMCIA_UNMAP);
		}
		for (i = 0; i < pc_cf->iowin; i++) {
			PCMCIA_MAP_IO(pca, link, pc_cf->io[i].start,
				      pc_cf->io[i].len,
				      (pc_cf->io[i].flags & (PCMCIA_MAP_16 |
				      PCMCIA_MAP_8)) | i | PCMCIA_UNMAP);
		}
		PCMCIA_MAP_INTR(pca, link, pc_cf->irq_num, PCMCIA_UNMAP);
		CLR(link->flags, CARD_IS_MAPPED);
		link->iowin = 0;
		link->memwin = 0;
		link->intr = 0;
	} else {
		SET(link->flags, CARD_IS_MAPPED);
		link->iowin = pc_cf->iowin;
		link->memwin = pc_cf->memwin;
		link->intr = pc_cf->irq_num;
d544 1
a544 5
	s = splbio();
	SCRATCH_INUSE(pca) = 0;
	wakeup((caddr_t) & SCRATCH_INUSE(pca));
	splx(s);
	return err;
d547 6
a552 3
int
pcmcia_unmapcard(link)
	struct pcmcia_link *link;
d554 3
a556 21
	int             i;
	struct pcmcia_adapter *pca = link->adapter;
	PPRINTF(("- pcmcia_unmapcard\n"));
	if (!pca)
		return ENODEV;

	for (i = 0; i < link->memwin; i++)
		PCMCIA_MAP_MEM(pca, link, pca->pa_memt, 0, 0, 0,
			       (i | PCMCIA_UNMAP));

	for (i = 0; i < link->iowin; i++)
		PCMCIA_MAP_IO(pca, link, 0, 0, (i | PCMCIA_UNMAP));

	PCMCIA_MAP_INTR(pca, link, link->intr, PCMCIA_UNMAP);
	PCMCIA_SERVICE(pca, link, PCMCIA_OP_RESET, 50000, 0);
	CLR(link->flags, (CARD_IS_MAPPED | PCMCIA_SLOT_INUSE));
	link->iowin = 0;
	link->memwin = 0;
	link->intr = 0;
	return 0;
}
d558 3
d562 24
a585 8
int
pcmcia_mapcard_and_configure(link, unit, pc_cf)
	struct pcmcia_link *link;
	struct pcmcia_conf *pc_cf;
	int             unit;
{
	int             mymap = 0;
	int err;
d587 2
a588 4
	PPRINTF(("- pcmcia_mapcard_and_configure\n"));
	if (pc_cf->driver_name[0][0]) {
		if ((err = pcmcia_mapcard(link, unit, pc_cf)) != 0) {
			return err;
a589 14
		mymap=1;
		link->fordriver = pc_cf->driver_name[0];
	} else
		link->fordriver = NULL;
	
	pcmcia_probe_link(link);

	if (!ISSET(link->flags, PCMCIA_SLOT_INUSE)) {
		if (mymap)
			pcmcia_unmapcard(link);
		return ENODEV;
	}
	return 0;
}
d591 17
d609 8
a616 54
int
pcmcia_read_cis(link, scratch, offs, len)
	struct pcmcia_link *link;
	u_char         *scratch;
	int             offs, len;
{
	struct pcmcia_adapter *pca = link->adapter;
	int             s;
	int             err = 0;
	int             j = 0;
	u_char *p = SCRATCH_MEM(pca);
	int size = SCRATCH_SIZE(pca);
	volatile int *inuse = &SCRATCH_INUSE(pca);
	int pgoff = offs / size;
	int toff;

	toff = offs - (pgoff * size);

	PPRINTF(("- pcmcia_read_cis: mem %p size %d\n", p, size));
	if (pca == NULL)
		return ENXIO;

	s = splbio();
	while (*inuse)
		sleep((caddr_t) inuse, PZERO - 1);
	*inuse = 1;
	splx(s);

	while (len > 0) {
		int tlen = min(len, (size - toff) / 2);
		int i;

		if ((err = PCMCIA_MAP_MEM(pca, link, pca->pa_memt, p, pgoff,
					  size,
					  PCMCIA_MAP_ATTR |
					  PCMCIA_LAST_WIN)) != 0)
			goto error;

		PPRINTF(("- pcmcia_read_cis: mem mapped\n"));

		for (i = 0; i < tlen; j++, i++)
			scratch[j] = p[toff + i * 2];

		PCMCIA_MAP_MEM(pca, link, pca->pa_memt, p, 0, size,
			       PCMCIA_LAST_WIN | PCMCIA_UNMAP);
		len -= tlen;
		pgoff++;
		toff = 0;
	}
error:
	s = splbio();
	*inuse = 0;
	wakeup((caddr_t) inuse); 
	splx(s);
d618 2
a619 3
	PPRINTF(("- pcmcia_read_cis return %d\n", err));
	return err;
}
d621 2
a622 12
/* here we start our pseudodev for controlling the slots */
#define PCMCIABUS_UNIT(a)    (minor(a))
#define PCMCIABUS_SLOT(a)    (a&0x3)	/* per-controller */
#define PCMCIABUS_SLOTID(a)  (a&0xf)	/* system-wide assignment */
#define PCMCIABUS_CHIPNO(a)  ((a&0xf)>>2)
#define PCMCIABUS_CHIPID(a)  (a&0x3)
#define PCMCIABUS_CHIP       0x40
#define PCMCIABUS_BUS        0x80
#define PCMCIABUS_BUSID(a)   (a&0x3)
#define PCMCIABUS_DEVTYPE(a) ((a)&(PCMCIABUS_CHIP|PCMCIABUS_BUS))
static int      busopen = 0;
static int      chipopen[4] = {0, 0, 0, 0};
d624 4
a627 48
int
pcmciaopen(dev, flag, mode, p)
	dev_t           dev;
	int             flag, mode;
	struct proc    *p;
{
	int             unit = PCMCIABUS_UNIT(dev);
	int		chipid, slot;
	struct	pcmcia_link *link;
	struct pcmciabus_softc *pcmcia;

	PPRINTF(("- pcmciabusopen\n"));
	switch (PCMCIABUS_DEVTYPE(unit)) {
	case PCMCIABUS_BUS:
		if (unit != PCMCIABUS_BUS)
			return ENXIO;
		if (busopen)
			return EBUSY;
		busopen = 1;
		break;

	case PCMCIABUS_CHIP:
		chipid = PCMCIABUS_CHIPID(unit);
		if (chipid < 0 || chipid >= pcmciabus_cd.cd_ndevs)
			return ENXIO;
		pcmcia = pcmciabus_cd.cd_devs[chipid];
		if (pcmcia == NULL || pcmcia->sc_driver == NULL)
			return ENXIO;

		if (chipopen[chipid])
			return EBUSY;

		chipopen[chipid] = 1;
		break;

	case 0:
		slot = PCMCIABUS_SLOT(unit);
		chipid = PCMCIABUS_CHIPNO(unit);

		if (chipid < 0 || chipid >= pcmciabus_cd.cd_ndevs)
			return ENXIO;

		pcmcia = pcmciabus_cd.cd_devs[chipid];
		if (pcmcia == NULL || pcmcia->sc_driver == NULL)
			return ENXIO;
		link = pcmcia->sc_link[slot];
		if (!link)
		 	return ENXIO;
d629 2
a630 2
		if (ISSET(link->flags, PCMCIA_SLOT_OPEN))
			return EBUSY;
d632 3
a634 2
		SET(link->flags, PCMCIA_SLOT_OPEN);
		break;
d636 1
a636 2
	default:
		return ENXIO;
d638 3
a640 3
	}
	return 0;
}
d642 2
d645 1
a645 33
int
pcmciaclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
{
	int unit = PCMCIABUS_UNIT(dev);
	int chipid, slot;
	struct	pcmcia_link *link;
	struct pcmciabus_softc *pcmcia;
	int s;

	PPRINTF(("- pcmciabusclose\n"));
	switch (PCMCIABUS_DEVTYPE(unit)) {
	case PCMCIABUS_BUS:
		busopen = 0;
		break;

	case PCMCIABUS_CHIP:
		chipid = PCMCIABUS_CHIPID(unit);
		chipopen[chipid] = 0;
		break;

	case 0:
		slot = PCMCIABUS_SLOT(unit);
		chipid = PCMCIABUS_CHIPNO(unit);
		pcmcia = pcmciabus_cd.cd_devs[chipid];
		link = pcmcia->sc_link[slot];

		s = splclock();
		CLR(link->flags, (PCMCIA_SLOT_OPEN|PCMCIA_SLOT_EVENT));
		splx(s);
		break;
d647 12
a658 2
	default:
		return ENXIO;
d660 2
a661 1
	return 0;
d664 27
a690 24
int
pcmciachip_ioctl(chipid, cmd, data)
	int             chipid, cmd;
	caddr_t         data;
{
	struct pcmciabus_softc *pcmcia = pcmciabus_cd.cd_devs[chipid];
	struct pcmcia_adapter *pca = pcmcia->sc_driver;
	struct pcmcia_link link;
	struct pcmcia_regs *pi = (void *) data;

	PPRINTF(("- pcmciachip_ioctl\n"));
	if (pca->chip_link == NULL || pca->adapter_softc == NULL)
		return ENXIO;

	switch (cmd) {
	case PCMCIAIO_READ_REGS:
		pi->chip = chipid;
		link.adapter = pca;
		link.slot = 0;
		return PCMCIA_SERVICE(pca, &link, PCMCIA_OP_GETREGS,
				      pi->chip_data, 0);
	}
	return ENOTTY;
}
d692 8
a699 29
int
pcmciaslot_ioctl(link, slotid, cmd, data)
	struct pcmcia_link *link;
	int             slotid, cmd;
	caddr_t         data;
{
	int             err = 0;
	struct pcmciabus_softc *pcmcia =
	    pcmciabus_cd.cd_devs[PCMCIABUS_CHIPNO(slotid)];
	struct pcmcia_adapter *pca = pcmcia->sc_driver;

	PPRINTF(("- pcmciaslot_ioctl\n"));
	if (link == NULL || pca->chip_link == NULL ||
	    pca->adapter_softc == NULL)
		return ENXIO;

	switch (cmd) {
	case PCMCIAIO_GET_STATUS:
		{
			struct pcmcia_status *pi = (void *) data;
			pi->slot = slotid;
			pi->status = 0;
			err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_STATUS,
					     &pi->status, 0);
			if (!err) {
			    if (ISSET(link->flags, CARD_IS_MAPPED))
				SET(pi->status, PCMCIA_CARD_IS_MAPPED);
			    if (ISSET(link->flags, PCMCIA_SLOT_INUSE))
				SET(pi->status, PCMCIA_CARD_INUSE);
a700 1
			return err;
d703 4
a706 14
	case PCMCIAIO_GET_INFO:
		{
			struct pcmcia_info *pi = (void *) data;
			int             status;

			if ((err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_STATUS,
						  &status, 0)) != 0)
				return err;
			if (!ISSET(status, PCMCIA_CARD_PRESENT))
				return ENODEV;
			pi->slot = slotid;
			return pcmcia_read_cis(link, pi->cis_data, 0,
					       CIS_MAXSIZE);
		}
d708 2
a709 5
	case PCMCIAIO_CONFIGURE:
		{
			struct pcmcia_conf *pc_cf = (void *) data;
			return pcmcia_mapcard_and_configure(link, -1, pc_cf);
		}
d711 2
a712 2
	case PCMCIAIO_UNCONFIGURE:
		return pcmcia_unconfigure(link);
d714 6
a719 33
	case PCMCIAIO_UNMAP:
		if (ISSET(link->flags, PCMCIA_SLOT_INUSE))
			return EBUSY;
		return pcmcia_unmapcard(link);

	case PCMCIAIO_SET_POWER:
		{
			int             pi = *(int *) data;
			pi &= 0x3;
			switch (pi) {
			case PCMCIASIO_POWER_OFF:
				return PCMCIA_SERVICE(pca, link,
						      PCMCIA_OP_POWER, 0, 0);

			case PCMCIASIO_POWER_5V:
			case PCMCIASIO_POWER_3V:
			case PCMCIASIO_POWER_AUTO:
				err = PCMCIA_SERVICE(pca, link,
						     PCMCIA_OP_POWER,
						     10000, pi);
				if (err)
					return err;

				err = PCMCIA_SERVICE(pca, link,
						     PCMCIA_OP_RESET,
						     500000, 0);
				if (err) {
					PPRINTF(("failed to reset %d\n", err));
					PCMCIA_SERVICE(pca, link,
						       PCMCIA_OP_POWER, 0, 0);
					return err;
				}
				return 0;
d721 3
a723 4
			default:
				return EINVAL;
			}
		}
d725 2
a726 22
	case PCMCIAIO_READ_COR:
		{
			struct pcmcia_info *pi = (void *)data;
			struct pcmcia_conf pc_cf;
			int status,s;

			err = PCMCIA_SERVICE(pca, link, PCMCIA_OP_STATUS, 
					     &status, 0);
			if (err)
				return err;
			if (!ISSET(status, PCMCIA_CARD_PRESENT)) 
				return ENODEV;

			if ((status = pcmcia_read_cis(link, pi->cis_data, 0,
						      CIS_MAXSIZE)))
				return status;

			bzero(&pc_cf, sizeof(pc_cf));
			if (pcmcia_get_cf(link, pi->cis_data,
					  sizeof(pi->cis_data), -1,
					  &pc_cf) != 0 )
				return EIO;
d728 8
a735 1
			s=splbio();
d737 4
a740 2
			while(SCRATCH_INUSE(pca))
				sleep((caddr_t)&SCRATCH_INUSE(pca), PZERO - 1);
d742 1
a742 39
			SCRATCH_INUSE(pca) = 1;
			splx(s);
			if ((err = PCMCIA_MAP_MEM(pca, link,
						  SCRATCH_MEMT(pca),
						  SCRATCH_MEM(pca),
						  pc_cf.cfg_off &
						  ~(SCRATCH_SIZE(pca)-1),
						  SCRATCH_SIZE(pca),
						  PCMCIA_MAP_ATTR|
						  PCMCIA_LAST_WIN)) == 0) {
				int m, i;
				u_char *d = pi->cis_data,*p;
				p = SCRATCH_MEM(pca)+
				    (pc_cf.cfg_off & (SCRATCH_SIZE(pca)-1));
				for (i = 0, m = 1; i < 32; i++, m <<= 1) {
					if (pc_cf.cfg_regmask & m) {
						*d++ = i;
						*d++ = p[i*2];
					}
				}
				*d++ = 0xff;
				*d++ = 0xff;
				PCMCIA_MAP_MEM(pca, link,
					       SCRATCH_MEMT(pca),
					       SCRATCH_MEM(pca),
					       0,SCRATCH_SIZE(pca), 
					       PCMCIA_LAST_WIN|PCMCIA_UNMAP);
			} 
			s = splbio();
			SCRATCH_INUSE(pca)=0;
			wakeup((caddr_t)&SCRATCH_INUSE(pca));
			splx(s);
			return err;
		}
	default:
		return ENOTTY;
	}
	return ENOTTY;
}
d744 2
a745 20
int
pcmciaioctl(dev, cmd, data, flag, p)
	dev_t		dev;
	u_long		cmd;
	caddr_t		data;
	int		flag;
	struct proc	*p;
{
	int unit = PCMCIABUS_UNIT(dev);
	int chipid = PCMCIABUS_CHIPNO(unit);
	struct pcmciabus_softc *pcmcia;
	struct pcmcia_link *link;

	PPRINTF(("- pcmciabusioctl\n"));
	if (chipid < 0 || chipid >= pcmciabus_cd.cd_ndevs)
		return ENXIO;

	pcmcia = pcmciabus_cd.cd_devs[chipid];
	if (pcmcia == NULL)
		return ENXIO;
d747 3
a749 15
	switch (PCMCIABUS_DEVTYPE(unit)) {
#if 0
	case PCMCIABUS_BUS:
		return pcmciabus_ioctl(PCMCIABUS_BUSID(unit), cmd, data);
#endif
	case PCMCIABUS_CHIP:
		return pcmciachip_ioctl(PCMCIABUS_CHIPID(unit), cmd, data);
	case 0:
		link = pcmcia->sc_link[PCMCIABUS_SLOT(unit)];
		return pcmciaslot_ioctl(link, PCMCIABUS_SLOTID(unit),
					cmd, data);
	default:
		return ENXIO;
	}
}
d751 2
a752 24
int
pcmciaselect(device, rw, p)
	dev_t device;
	int rw;
	struct proc *p;
{
	int s;
	int unit = PCMCIABUS_UNIT(device);
	int chipid = PCMCIABUS_CHIPNO(unit);
	struct pcmciabus_softc *pcmcia;
	struct pcmcia_link *link;

	PPRINTF(("- pcmciabus_select\n"));
	pcmcia = pcmciabus_cd.cd_devs[chipid];
	
	switch (PCMCIABUS_DEVTYPE(unit)) {
	case 0:
		link = pcmcia->sc_link[PCMCIABUS_SLOT(unit)];
		break;
	case PCMCIABUS_BUS:
	case PCMCIABUS_CHIP:
	default:
		return 0;
	}
a753 8
	s = splpcmcia();
	switch (rw) {
	case FREAD:
	case FWRITE:
		break;
	case 0:
		if (ISSET(link->flags, PCMCIA_SLOT_EVENT)) {
			CLR(link->flags, PCMCIA_SLOT_EVENT);
a754 1
			return 1;
d756 2
a757 2
		selrecord(p, &link->pcmcialink_sel);
		break;
a758 2
	splx(s);
	return 0;
d761 3
a763 4
int
pcmciammap(dev, offset, nprot)
	dev_t dev;
	int offset, nprot;
d765 3
a767 2
	return ENXIO;
}
d769 1
d771 19
a789 38
#ifdef PCMCIA_DEBUG
void
pcmciadumpcf(cf)
	struct pcmcia_conf * cf;
{
	int             i;
	static char    *ios[] = {
		"auto", "8bit", "16bit", "illegal"
	};
	printf("Driver name %s\n", cf->driver_name[0]);
	printf("CFG offset %x\n", cf->cfg_off);
	printf("IRQ type %s%s\n", cf->irq_level ? "Level " : "", 
				  cf->irq_pulse ? "Pulse" : "");
	printf("IRQ num %x\n", cf->irq_num);
	printf("IRQ mask %x\n", cf->irq_mask);
	printf("CFG type %x %x\n", cf->cfgtype,cf->cfgid);
	printf("Cardtype %s\n", cf->iocard ? "IO" : "MEM");
	for (i = 0; i < cf->iowin; i++) {
		printf("iowin  %x-%x %s\n", cf->io[i].start,
		       cf->io[i].start + cf->io[i].len - 1,
		       ios[(cf->io[i].flags & 
			    (PCMCIA_MAP_8 | PCMCIA_MAP_16)) >> 8]);
	}
	for (i = 0; i < cf->memwin; i++) {
		printf("memwin  (%x)%x-%x %x\n",
		       cf->mem[i].caddr,
		       cf->mem[i].start,
		       cf->mem[i].start + cf->mem[i].len - 1,
		       cf->mem[i].flags);
	}
}
#endif

int
pcmcia_print(aux, pnp)
	void *aux;
	const char *pnp;
{
d791 2
a792 2
	struct pcmcia_attach_args *paa = aux;
	printf(" slot %d", paa->paa_link->slot);
d794 4
a797 17
	return (0);			/* be silent */
}

/*
 * Filter out inappropriate configurations before heading off to
 * the device match routines.
 */
int
pcmcia_submatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct device *self = match;
	struct cfdata *cf = self->dv_cfdata;
	struct pcmcia_attach_args *paa = aux;
	struct pcmcia_link *link = paa->paa_link;

d799 1
a799 3
	printf("pcmcia_submatch: paa=%p link=%p, cf=%p\n", paa, link, cf);
	delay(2000000);

a800 5

	if (cf->cf_loc[6] != -1 && link->slot != cf->cf_loc[6]) {
		printf("slot mismatch: %d cf_loc %d\n", link->slot,
		    cf->cf_loc[6]);
		return 0;
d803 1
a803 1
	return ((*cf->cf_attach->ca_match)(parent, match, aux));
@


1.9
log
@Minor KNF + $OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia.c,v 1.8 1996/11/28 23:28:16 niklas Exp $	*/
d856 4
d872 1
a872 3
		int pgoff = offs / size;
		int toff = offs - (pgoff * size);
		int tlen = min(len + toff, size / 2) - toff;
d889 2
@


1.8
log
@Adaption to new bus.h from NetBSD.  Various driver has been updated to
NetBSD 961107 state.  Other has not, partly because sometimes the bus.h
changes was coupled with other changes.
@
text
@d1 2
a2 1
/*	$Id: pcmcia.c,v 1.7 1996/11/23 21:47:07 kstailey Exp $	*/
d35 5
a39 3
/* XXX - these next two lines are just "glue" until the confusion over
   pcmcia vs pcmciabus between the framework and sys/conf/files
   gets resolved */
d43 4
a46 2
/* derived from scsiconf.c writte by Julian Elischer et al */
/* TODO add modload support and loadable lists of devices */
d83 2
a84 1
/* XXX
d332 2
a333 1
	/* Run the config matching routines to find us a good match.
d903 1
a903 1
#define PCMCIABUS_CHIPID(a) (a&0x3)
d1358 2
a1359 1
		printf("slot mismatch: %d cf_loc %d\n", link->slot, cf->cf_loc[6]);
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$Id: pcmcia.c,v 1.6 1996/10/16 12:36:54 deraadt Exp $	*/
d85 2
a86 2
#define SCRATCH_MEM(a)	((a)->scratch_memh)
#define SCRATCH_BC(a)	((a)->pa_bc)
d192 2
a193 1
	sc->sc_bc = pba->pba_bc;
d651 1
a651 2
		if ((err = PCMCIA_MAP_MEM(pca, link,
					  pca->pa_bc,
d681 3
a683 3
	if ((err = PCMCIA_MAP_MEM(pca, link, SCRATCH_BC(pca), SCRATCH_MEM(pca),
	     pc_cf->cfg_off & (~(SCRATCH_SIZE(pca) - 1)), SCRATCH_SIZE(pca),
				  PCMCIA_MAP_ATTR | PCMCIA_LAST_WIN)) != 0) {
d694 6
a699 5
#define GETMEM(x) bus_mem_read_1(pca->pa_bc, SCRATCH_MEM(pca), \
				 (pc_cf->cfg_off & (SCRATCH_SIZE(pca)-1)) + x)
#define PUTMEM(x,v) \
	bus_mem_write_1(pca->pa_bc, SCRATCH_MEM(pca), \
			(pc_cf->cfg_off & (SCRATCH_SIZE(pca)-1)) + x, v)
d741 1
a741 1
	PCMCIA_MAP_MEM(pca, link, SCRATCH_BC(pca), SCRATCH_MEM(pca), 0,
d747 1
a747 1
				       pca->pa_bc,
d790 1
a790 1
		PCMCIA_MAP_MEM(pca, link, pca->pa_bc, 0, 0, 0,
d866 1
a866 1
		if ((err = PCMCIA_MAP_MEM(pca, link, pca->pa_bc, p, pgoff,
d877 1
a877 1
		PCMCIA_MAP_MEM(pca, link, pca->pa_bc, p, 0, size,
d1159 1
a1159 1
						  SCRATCH_BC(pca),
d1179 1
a1179 1
					       SCRATCH_BC(pca),
@


1.6
log
@type death
@
text
@d1 1
a1 1
/*	$Id: pcmcia.c,v 1.5 1996/05/07 07:34:17 deraadt Exp $	*/
d104 1
a104 1
int pcmcia_print __P((void *, char *));
d1320 1
a1320 1
	char *pnp;
@


1.5
log
@convert to machine/bus.h
@
text
@d1 1
a1 1
/*	$Id: pcmcia.c,v 1.4 1996/05/03 07:59:40 deraadt Exp $	*/
d98 2
d108 2
d118 8
d200 2
d967 4
a970 1
pcmciaclose(dev)
d1197 5
a1201 5
	dev_t           dev;
	int             cmd;
	caddr_t         data;
	int             flag;
	struct proc    *p;
d1276 3
a1278 1
pcmciammap()
@


1.4
log
@prettier printf messages
@
text
@d1 1
a1 1
/*	$Id: pcmcia.c,v 1.3 1996/04/29 14:17:15 hvozda Exp $	*/
a49 1
#include <sys/cpu.h>
d680 1
a680 1
#define GETMEM(x) bus_mem_read_1(pca->scratch_bc, SCRATCH_MEM(pca), \
d683 1
a683 1
	bus_mem_write_1(pca->scratch_bc, SCRATCH_MEM(pca), \
@


1.3
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d1 1
a1 1
/*	$Id: pcmcia.c,v 1.22 1996/04/15 23:55:46 jtk Exp $	*/
d359 1
a359 1
	printf("%s: slot %d ", ((struct device *) link->bus)->dv_xname, slot);
d370 1
a370 1
		printf("is empty\n");
d409 1
a409 1
	printf("contains <%s, %s", cardinfo->manufacturer, cardinfo->model);
@


1.2
log
@Better config symantics (elimitates 'options PCMCIA_*'; thanks Theo).
Also a example kernel demonstrating how to configure PCMCIA devices.
@
text
@d1 1
d3 1
a31 1
 *      $Id: pcmcia.c,v 1.1 1996/01/15 00:05:03 hvozda Exp $
d34 6
d49 2
d52 2
a53 2
#include <dev/pcmcia/pcmcia.h>
#include <dev/pcmcia/pcmciabus.h>
a55 4
#include "ed.h"
#include "com.h"
#include "ep.h"

d65 3
a67 4
static void pcmciadumpcf __P((struct pcmcia_conf *));
static int pcmcia_strcmp __P((char *, char *, int, char *));

void pcmcia_shuthook __P((void *));
d69 4
a72 4
static struct pcmcia_adapter pcmcia_drivers[4];
static int      pcmcia_cntrl = 0;
static int      probed = 0;
static struct device **deldevs = NULL;
a74 34
/* I've decided to re-ifdef these.  It makes making a kernel easier
    until I either get config(8) modified to deal somehow
    or figure out a better to way declare the prototypes and
    build up the knowndevs struct.  Stefan may have ideas...
*/

#if NED > 0
extern struct pcmciadevs pcmcia_ed_devs[];
#endif
#if NCOM > 0
extern struct pcmciadevs pcmcia_com_devs[];
#endif
#if NEP > 0
extern struct pcmciadevs pcmcia_ep_devs[];
#endif

static struct pcmciadevs *knowndevs[] = {
#if NED > 0
	pcmcia_ed_devs,
#endif
#if NCOM > 0
	pcmcia_com_devs,
#endif
#if NEP > 0
	pcmcia_ep_devs,
#endif
	NULL
};

#ifdef notyet
static struct pcmciadevs *knowndevs[10] = { NULL };
#define KNOWNSIZE (sizeof(knowndevs) / sizeof(knowndevs[0]))
#endif

d79 6
a84 8
#define PCMCIA_MAP_MEM(a,b,c,d,e,f) ((a)->chip_link->pcmcia_map_mem(b,c,d,e,f))

#define PCMCIA_BUS_INIT(a,b,c,d,e,f)((a)->bus_link->bus_init((b),(c),(d),(e)\
									,(f)))
#define PCMCIA_BUS_SEARCH(a,b,c,d)  ((a)->bus_link->bus_search((b),(c),(d)))
#define PCMCIA_BUS_PROBE(a,b,c,d,e) ((a)->bus_link->bus_probe((b),(c),(d),(e)))
#define PCMCIA_BUS_CONFIG(a,b,c,d,e)((a)->bus_link->bus_config((b),(c),(d),(e)))
#define PCMCIA_BUS_UNCONFIG(a,b)    ((a)->bus_link->bus_unconfig((b)))
d86 2
a87 1
#define SCRATCH_MEM(a)	((a)->scratch_mem)
d94 2
a95 4
struct pcmciadevs *pcmcia_probedev __P((struct pcmcia_link *));
struct pcmciadevs *pcmcia_selectdev __P((char *, char *, char *, char *));
int pcmcia_probe_bus __P((struct pcmcia_link *, int, int,
			  struct pcmcia_conf *));
d98 1
d100 2
a101 4
struct cfdriver pcmciabuscd = {
	NULL, "pcmcia", pcmciabusmatch, pcmciabusattach, DV_DULL,
	sizeof(struct pcmciabus_softc), 1
};
d103 3
a105 6
#ifdef notyet
int
pcmcia_add_device(devs)
	struct pcmciadevs *devs;
{
	int i;
d107 3
a109 2
	if (devs == NULL)
		return 0;
d111 3
a113 13
	for (i = 0; i < KNOWNSIZE; i++)
		if (knowndevs[i] == NULL)
			break;

	if (i == KNOWNSIZE)
		panic("Too many pcmcia devices");

	knowndevs[i] = devs;
	for (; devs->devname != NULL; devs++)
		printf("added %s\n", devs->devname);
	return i;
}
#endif
d115 1
d136 1
d146 10
a155 12
	int             i, found = 0;

	PPRINTF(("- pcmciabusmatch\n"));
	if (pcmcia_cntrl <= 0)
		return 0;

	for (i = 0; i < 4; i++)
		if (pcmcia_drivers[i].bus_link) {
			if (PCMCIA_BUS_INIT(&pcmcia_drivers[i], parent, cf,
					    aux, &pcmcia_drivers[i], 0))
				found++;
		}
d171 2
a172 1
	int             i, found = 0;
d175 3
a177 7
	for (i = 0; i < 4; i++)
		if (pcmcia_drivers[i].bus_link) {
			if (PCMCIA_BUS_INIT(&pcmcia_drivers[i], parent, cf,
					    aux, &pcmcia_drivers[i], 1))
				found++;
		}

d180 3
a182 1
	pcmcia_probe_bus(NULL, sc->sc_dev.dv_unit, -1, NULL);
d195 3
a197 3
		for (bus = 0; bus < pcmciabuscd.cd_ndevs; bus++)
			if (pcmciabuscd.cd_devs[bus])
				pcmcia_probe_bus(NULL, bus, slot, NULL);
d200 1
a200 1
		return pcmcia_probe_bus(NULL, bus, slot, NULL);
d204 5
d213 1
a213 2
pcmcia_probe_bus(link, bus, slot, cf)
	struct pcmcia_link *link;
a214 1
	struct pcmcia_conf *cf;
d217 2
a218 3
	int             maxslot, minslot, maxlun, minlun;
	struct pcmciadevs *bestmatch = NULL;
	int             spec_probe = (link != NULL);
d221 1
a221 1
	if (bus < 0 || bus >= pcmciabuscd.cd_ndevs)
d223 2
a224 2
	pcmcia = pcmciabuscd.cd_devs[bus];
	if (!pcmcia)
d228 1
a228 1
		maxslot = 7;
d231 1
a231 1
		if (slot < 0 || slot > 7)
d237 1
a237 1
		if (link = pcmcia->sc_link[slot]) {
a240 2
		if (pcmcia_drivers[slot >> 1].adapter_softc == NULL)
			continue;
d253 2
a254 1
			link->adapter = &pcmcia_drivers[slot >> 1];
d257 42
a298 24
		bestmatch = pcmcia_probedev(link);
		/*
		 * We already know what the device is.  We use a
		 * special matching routine which insists that the
		 * cfdata is of the right type rather than putting
		 * more intelligence in individual match routines for
		 * each high-level driver.
		 * We must have the final probe do all of the comparisons,
		 * or we could get stuck in an infinite loop trying the same
		 * device repeatedly.  We use the `fordriver' field of
		 * the pcmcia_link for now, rather than inventing a new
		 * structure just for the config_search().
		 */
		if (link->fordriver == NULL) {
			if (bestmatch)
				link->fordriver = bestmatch->devname;
			else {
				if (!spec_probe) {
					link->device = NULL;
					link->devp = NULL;
					PCMCIA_SERVICE(link->adapter,
						       link, PCMCIA_OP_POWER,
						       0, 0);
				}
d301 2
d304 32
a335 50
		if (spec_probe) {
			if (cf && pcmcia_mapcard(link, -1, cf) != 0)
				link->fordriver = NULL;
		}

		if (link->fordriver != NULL) {
			int             i;
			struct device **delp = deldevs;
			int             found = 0;
			link->device = bestmatch;
			link->flags = (link->flags &
					  ~(PCMCIA_ATTACH_TYPE)) |
					    PCMCIA_REATTACH;
			for (i = 0; i < ndeldevs; i++, delp++) {
				if (*delp &&
				    pcmcia_configure((*delp)->dv_parent, *delp,
						     link)) {
					link->flags = (link->flags &
							  ~PCMCIA_ATTACH_TYPE)
						       | PCMCIA_SLOT_INUSE;
					found = 1;
					*delp = NULL;
					break;
				}
			}
			if (!found) {
				link->flags = (link->flags &
				       ~PCMCIA_ATTACH_TYPE) | PCMCIA_ATTACH;
				if (PCMCIA_BUS_SEARCH(link->adapter,
						      &pcmcia->sc_dev,
						      link, NULL)) {
					link->flags = (link->flags &
							  ~PCMCIA_ATTACH_TYPE)
						       | PCMCIA_SLOT_INUSE;
				} else {
					link->flags &= ~(PCMCIA_ATTACH_TYPE |
							 PCMCIA_SLOT_INUSE);
					link->device = NULL;
					printf(
					    "No matching config entry %s.\n",
					       link->fordriver ? 
					       link->fordriver : "(NULL)");
					if (!spec_probe)
						PCMCIA_SERVICE(link->adapter,
							       link,
							       PCMCIA_OP_POWER,
							       0, 0);
				}
			}
		}
d337 1
a337 1
	return 0;
d345 2
a346 2
struct pcmciadevs *
pcmcia_probedev(link)
d348 1
a351 4
	char            manu[MAX_CIS_NAMELEN];
	char            model[MAX_CIS_NAMELEN];
	char            add_inf1[MAX_CIS_NAMELEN];
	char            add_inf2[MAX_CIS_NAMELEN];
d359 1
a359 3
	printf("%s slot %d:",
	       ((struct device *) link->adapter->adapter_softc)->dv_xname,
	       slot & 1);
d361 2
d369 2
a370 2
	if ((card_stat & PCMCIA_CARD_PRESENT) == 0) {
		printf(" <slot empty>\n");
d374 1
a374 1
	if (!(card_stat & PCMCIA_POWER)) {
d384 1
a384 1
	if (!(link->flags & (PCMCIA_SLOT_INUSE | CARD_IS_MAPPED))) {
d402 3
a404 2
				      manu, model, add_inf1,
				      add_inf2)) != 0) {
d409 5
a413 5
	printf(" <%s, %s", manu, model);
	if (add_inf1[0])
		printf(", %s", add_inf1);
	if (add_inf2[0])
		printf(", %s", add_inf2);
d416 1
a416 6

	/*
	 * Try make as good a match as possible with
	 * available sub drivers
	 */
	return pcmcia_selectdev(manu, model, add_inf1, add_inf2);
d420 1
a420 99
	return NULL;
}

/*
 * Try make as good a match as possible with
 * available sub drivers
 */
struct pcmciadevs *
pcmcia_selectdev(manu, model, add_inf1, add_inf2)
	char *manu, *model, *add_inf1, *add_inf2;
{
	u_int bestmatches = 0;
	struct pcmciadevs *bestmatch = (struct pcmciadevs *) 0;
	struct pcmciadevs **dlist, *dentry;

	PPRINTF(("- pcmcia_selectdev\n"));
	for (dlist = knowndevs; *dlist; dlist++)
		for (dentry = *dlist; dentry && 
				      dentry->devname != NULL; dentry++) {
			int match = 0;

#ifdef PCMCIA_DEBUG
			dentry->flags |= PC_SHOWME;
#endif
    	    	    	match|=pcmcia_strcmp(dentry->manufacturer,
    	    	    	    	    manu,dentry->flags,"manufacturer")<<6;
    	    	    	match|=pcmcia_strcmp(dentry->model,
    	    	    	    	    model,dentry->flags,"model")<<4;
    	    	    	match|=pcmcia_strcmp(dentry->add_inf1,
    	    	    	    	    add_inf1,dentry->flags,"info1")<<2;
    	    	    	match|=pcmcia_strcmp(dentry->add_inf2,
    	    	    	    	    add_inf2,dentry->flags,"info2");
/* the following was replaced by the wildcard function called above */
#if 0
			if (dentry->flags & PC_SHOWME)
				printf("manufacturer = `%s'-`%s'\n", 
				       dentry->manufacturer ?
				       dentry->manufacturer :
				       "X",
				       manu);
			if (dentry->manufacturer) {
			    if (strcmp(dentry->manufacturer, manu) == 0) {
				match |= 8;
			    } else {
				continue;
			    }
			}

			if (dentry->flags & PC_SHOWME)
				printf("model = `%s'-`%s'\n",
				       dentry->model ? dentry->model :
				       "X",
				       model);
			if (dentry->model)  {
			    if (strcmp(dentry->model, model) == 0) {
				match |= 4;
			    } else {
				continue;
			    }
			}


			if (dentry->flags & PC_SHOWME)
				printf("info1 = `%s'-`%s'\n",
				       dentry->add_inf1 ? dentry->add_inf1 :
				       "X",
				       add_inf1);
			if (dentry->add_inf1) {
			    if (strcmp(dentry->add_inf1, add_inf1) == 0) {
				match |= 2;
			    } else {
				continue;
			    }
			}

			if (dentry->flags & PC_SHOWME)
				printf("info2 = `%s'-`%s'\n", 
				       dentry->add_inf2 ? dentry->add_inf2 :
				       "X",
				       add_inf2);
			if (dentry->add_inf2) {
			    if (strcmp(dentry->add_inf2, add_inf2) == 0) {
				match |= 1;
			    } else {
				continue;
			    }
			}
#endif
#ifdef PCMCIA_DEBUG
			printf("match == %d [%d]\n",match,bestmatches);
#endif

			if(match > bestmatches) {
				bestmatches = match;
				bestmatch = dentry;
			}
		}

	return bestmatch;
a432 1
	char           *devname = (char *) link->fordriver;
d437 1
d443 1
a443 1
	if (strcmp(devname, cd->cd_name) || !pca)
d446 3
d454 2
a455 2
	PPRINTF(("pcmcia_configure: %x\n", pcd));
	if (!(link->flags & CARD_IS_MAPPED)) {
d472 3
a474 2
			PPRINTF(("pcmcia_configure: calling config\n"));
			if (pcd->pcmcia_config(link, dev, &pc_cf, cf))
d507 1
a507 1
	PPRINTF(("pcmcia_configure: calling bus probe\n"));
a517 2
	link->shuthook = shutdownhook_establish(pcmcia_shuthook,
						(void *)link);
d524 1
a524 1
	printf("pcmcia_configure: configuration error\n");
d529 3
a531 2
pcmcia_shuthook(arg)
void *arg;
d533 6
a538 8
    struct pcmcia_link *link = (struct pcmcia_link *)arg;
    if (pcmcia_unconfigure(link) == 0) {
	/*
	 * turn off power too.
	 */
	PCMCIA_SERVICE(link->adapter, link, PCMCIA_OP_RESET, 500000, 0);
	PCMCIA_SERVICE(link->adapter, link, PCMCIA_OP_POWER, 0, 0);
    }
d545 1
a545 3
	int             status;
	int             i, err;
	struct device **delp;
d559 1
a559 1
	if (link->flags & CARD_IS_MAPPED) {
d561 1
a561 1
			if (pcd->pcmcia_remove(link, link->devp))
d571 37
a607 20
	delp = deldevs;
	for (i = 0; delp && *delp && i < ndeldevs; i++, delp++)
		continue;
	if (i >= ndeldevs) {
		int sz = ndeldevs ? (ndeldevs * 2) : 
				    (MINALLOCSIZE / sizeof(void *));
		struct device **ndel = malloc(sz * sizeof(void *),
					      M_DEVBUF, M_NOWAIT);
		if (!ndel) {
			PPRINTF(("pcmcia_delete: creating dev array"));
			return ENOMEM;
		}
		bzero(ndel, sz * sizeof(void *));
		if (ndeldevs) {
			bcopy(deldevs, ndel, ndeldevs * sizeof(void *));
			free(deldevs, M_DEVBUF);
		}
		ndeldevs = sz - 1;
		deldevs = ndel;
		delp = deldevs + i;
a608 6
	dev = *delp = link->devp;
	link->devp = NULL;
	printf("device %s in pcmcia slot %d detached\n", dev->dv_xname,
	       link->slot);
	shutdownhook_disestablish(link->shuthook);
	link->shuthook = 0;
d612 5
d620 1
d638 1
d668 1
a668 1
	if ((err = PCMCIA_MAP_MEM(pca, link, SCRATCH_MEM(pca),
d681 8
a688 4
#define GETMEM(x) SCRATCH_MEM(pca)[(pc_cf->cfg_off & \
			            (SCRATCH_SIZE(pca) - 1)) + x]
	if ((pc_cf->cfgtype & DOSRESET)) {
		GETMEM(0) = PCMCIA_SRESET;
d693 1
a693 1
	PPRINTF(("CMDR %x\n",((pc_cf->cfgtype & CFGENTRYID) ?
d699 4
a702 4
	GETMEM(0) = ((pc_cf->cfgtype & CFGENTRYID) ?
			 pc_cf->cfgid |CFGENTRYID:
			 (pc_cf->cfgtype & CFGENTRYMASK)|1)|
		    (pc_cf->irq_level ? PCMCIA_LVLREQ : 0);
d705 2
a706 2
	if (pc_cf->cfg_regmask & (1 << (PCMCIA_SCR / 2)))
		GETMEM(PCMCIA_SCR) = (link->slot & 1) | 0x10;
d710 5
a714 3
	if (GETMEM(PCMCIA_CCSR] & PCMCIA_POWER_DOWN) {
		GETMEM(PCMCIA_CCSR] &= ~PCMCIA_POWER_DOWN;
		DPRINTF(("CCSR now %x\n", GETMEM(PCMCIA_CCSR]));
d718 3
d722 1
a722 1
				  500000, 0)) != 0)
d724 2
d727 2
a728 1
	PCMCIA_MAP_MEM(pca, link, 0, 0, 0, PCMCIA_LAST_WIN | PCMCIA_UNMAP);
d730 1
d733 1
d748 1
a748 1
		link->flags &= ~CARD_IS_MAPPED;
d753 1
a753 1
		link->flags |= CARD_IS_MAPPED;
d776 2
a777 1
		PCMCIA_MAP_MEM(pca, link, 0, 0, 0, (i | PCMCIA_UNMAP));
d783 2
a784 2
	PCMCIA_SERVICE(pca, link, PCMCIA_OP_RESET, 0, 0);
	link->flags &= ~(CARD_IS_MAPPED | PCMCIA_SLOT_INUSE);
d792 1
a792 1
static int
a797 1
	int             err;
d799 1
a802 1
#if 0
a806 1
#endif
d808 1
a808 1
	} else {
d810 4
a813 4
		pc_cf = NULL;
	}
	pcmcia_probe_bus(link, 0, link->slot, pc_cf);
	if ((link->flags & PCMCIA_SLOT_INUSE) == 0) {
d836 1
a836 1
	PPRINTF(("- pcmcia_read_cis\n"));
d852 2
a853 1
		if ((err = PCMCIA_MAP_MEM(pca, link, p, pgoff, size,
d858 2
d863 1
a863 1
		PCMCIA_MAP_MEM(pca, link, p, 0, size,
d873 1
d879 7
a885 4
#define PCMCIABUS_SLOT(a)    (a&0x7)
#define PCMCIABUS_CHIPIID(a) (a&0x3)
#define PCMCIABUS_CHIP       0x10
#define PCMCIABUS_BUS        0x20
d891 1
a891 1
pcmciabusopen(dev, flag, mode, p)
a901 2
	if (pcmcia_cntrl == 0)
		return ENXIO;
d912 2
a913 2
		chipid = PCMCIABUS_CHIPIID(unit);
		if (chipid > 3)
d915 2
a916 1
		if (pcmcia_drivers[chipid].adapter_softc == NULL)
d927 1
a927 1
		chipid = slot >> 1;
d929 1
a929 1
		if (chipid > 7)
d932 2
a933 1
		if (pcmcia_drivers[chipid].adapter_softc == NULL)
a934 1
		pcmcia = pcmciabuscd.cd_devs[0];
d936 2
d939 1
a939 1
		if (link->flags & PCMCIA_SLOT_OPEN)
d942 1
a942 1
		link->flags |= PCMCIA_SLOT_OPEN;
d954 1
a954 1
pcmciabusclose(dev)
a962 2
	if (pcmcia_cntrl == 0)
		return ENXIO;
d969 1
a969 1
		chipid = PCMCIABUS_CHIPIID(unit);
d975 2
a976 1
		pcmcia = pcmciabuscd.cd_devs[0];
d980 1
a980 1
		link->flags &= ~(PCMCIA_SLOT_OPEN|PCMCIA_SLOT_EVENT);
d995 2
a996 2
	int             err = 0;
	struct pcmcia_adapter *pca = &pcmcia_drivers[chipid];
d1008 1
a1008 1
		link.slot = chipid << 1;
d1022 3
a1024 1
	struct pcmcia_adapter *pca = &pcmcia_drivers[slotid >> 1];
d1040 4
a1043 4
				pi->status |= ((link->flags & CARD_IS_MAPPED) ?
					       PCMCIA_CARD_IS_MAPPED : 0) |
					((link->flags & PCMCIA_SLOT_INUSE) ?
					 PCMCIA_CARD_INUSE : 0);
d1056 1
a1056 1
			if ((status & PCMCIA_CARD_PRESENT) == 0)
d1073 2
d1121 1
a1121 1
			if ((status & PCMCIA_CARD_PRESENT) == 0) 
d1124 2
a1125 2
			if (status = pcmcia_read_cis(link, pi->cis_data, 0,
						     CIS_MAXSIZE))
d1141 3
a1143 1
			if ((err = PCMCIA_MAP_MEM(pca, link, SCRATCH_MEM(pca),
d1161 3
a1163 1
				PCMCIA_MAP_MEM(pca, link, SCRATCH_MEM(pca),
d1180 1
a1180 1
pcmciabusioctl(dev, cmd, data, flag, p)
d1187 2
a1188 1
	int             unit = PCMCIABUS_UNIT(dev);
d1192 6
a1197 3
	PPRINTF(("- pcmciabus_ioctl\n"));
	pcmcia = pcmciabuscd.cd_devs[0];
	if (pcmcia_cntrl == 0 || pcmcia == NULL)
d1199 1
d1203 1
a1203 1
		return pcmciabus_ioctl(0, cmd, data);
d1206 1
a1206 1
		return pcmciachip_ioctl(PCMCIABUS_CHIPIID(unit), cmd, data);
d1209 2
a1210 1
		return pcmciaslot_ioctl(link, PCMCIABUS_SLOT(unit), cmd, data);
d1217 1
a1217 1
pcmciabusselect(device, rw, p)
d1224 1
d1228 2
a1229 2
	PPRINTF(("- pcmciabus_ioctl\n"));
	pcmcia = pcmciabuscd.cd_devs[0];
d1241 1
a1241 1
	s = splclock();		/* XXX something higher than all devices that can plug in.... */
d1247 2
a1248 2
		if (link->flags & PCMCIA_SLOT_EVENT) {
			link->flags &= ~PCMCIA_SLOT_EVENT;
d1260 1
a1260 1
pcmciabusmmap()
a1264 40
/* pcmcia template string match. A '*' matches any number of characters.
   A NULL template matches all strings.
   return-value 
    0 nomatch 
    1 wildcard match 
    2 excact match
 */
static int
pcmcia_strcmp(templ,val,flags,msg)
    char *templ;
    char *val;
    int flags;
    char *msg;
{
    char *ltempl=NULL,*lval=NULL;

    if (flags & PC_SHOWME)
	    printf("%s = `%s'-`%s'\n", msg, templ ? templ : "X", val);

    if(templ==NULL)
        return 1;
    while(*val) {
        while(*templ=='*') {
            ltempl=++templ;
            lval=val;
        }
        if(*templ==*val) {
            templ++;
            val++;
        } else {
            if(ltempl==NULL)
                return 0;
            val=++lval;
            templ=ltempl;
        }
    }
    if(*templ!=0 && *templ!='*')
        return 0;
    return  ltempl?1:2;
}
d1267 1
a1267 1
static void
d1280 1
d1298 40
@


1.1
log
@ISA <-> PCMCIA glue for PCMCIA support.
@
text
@d30 1
a30 1
 *      $Id: pcmcia.c,v 1.3 1995/10/30 04:53:42 jtk Exp $
d47 4
d77 1
a77 1
#ifdef PCMCIA_ED
d80 1
a80 1
#ifdef PCMCIA_COM
d83 1
a83 1
#ifdef PCMCIA_EP
d88 1
a88 1
#ifdef PCMCIA_ED
d91 1
a91 1
#ifdef PCMCIA_COM
d94 1
a94 1
#ifdef PCMCIA_EP
@
