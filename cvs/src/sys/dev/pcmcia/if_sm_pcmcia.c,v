head	1.37;
access;
symbols
	OPENBSD_6_1:1.37.0.6
	OPENBSD_6_1_BASE:1.37
	OPENBSD_6_0:1.37.0.4
	OPENBSD_6_0_BASE:1.37
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.35.0.4
	OPENBSD_5_7_BASE:1.35
	OPENBSD_5_6:1.33.0.6
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.4
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.32.0.10
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.8
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.6
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.8
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.27.0.6
	OPENBSD_4_2_BASE:1.27
	OPENBSD_4_1:1.27.0.4
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.2
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.23.0.2
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.22.0.2
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.21.0.2
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.20.0.4
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.20.0.2
	OPENBSD_3_4_BASE:1.20
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.19.0.2
	OPENBSD_3_3_BASE:1.19
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.17
	UBC:1.15.0.4
	UBC_BASE:1.15
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.12.0.2
	OPENBSD_2_7_BASE:1.12
	SMP:1.11.0.2
	SMP_BASE:1.11
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.3.0.4
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.2
	OPENBSD_2_4_BASE:1.3;
locks; strict;
comment	@ * @;


1.37
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.36;
commitid	5gdEnqVoJuTuwdTu;

1.36
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.35;
commitid	p4LJxGKbi0BU2cG6;

1.35
date	2014.12.03.20.09.32;	author krw;	state Exp;
branches;
next	1.34;
commitid	rapVfhq63upxHrrZ;

1.34
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.33;
commitid	nYggAidK85QbUFh2;

1.33
date	2013.08.07.01.06.40;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.31.13.05.27;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.17.18.01.52;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2006.04.20.20.31.13;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.23.14.42.55;	author martin;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.27.17.04.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2003.09.04.03.46.48;	author avsm;	state Exp;
branches;
next	1.19;

1.19
date	2003.02.18.13.14.43;	author jmc;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.01.13.31.06;	author fgsch;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.15.4.1;
next	1.14;

1.14
date	2000.08.04.15.51.02;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.20.05.01.11;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.24.19.43.36;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	2000.02.02.19.09.59;	author fgsch;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	99.10.01.04.05.11;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	99.08.16.16.51.20;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.08.16.10.25.18;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	99.08.16.07.57.33;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	99.08.16.07.55.40;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.10.14.07.34.43;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	98.09.12.07.48.07;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.10.47.14;	author fgsch;	state Exp;
branches;
next	;

1.11.2.1
date	2001.05.14.22.26.07;	author niklas;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.11.2.4;

1.11.2.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.11.2.5;

1.11.2.5
date	2004.02.19.10.56.31;	author niklas;	state Exp;
branches;
next	1.11.2.6;

1.11.2.6
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.15.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.15.4.2;

1.15.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	1.15.4.3;

1.15.4.3
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_sm_pcmcia.c,v 1.36 2015/03/14 03:38:49 jsg Exp $	*/
/*	$NetBSD: if_sm_pcmcia.c,v 1.11 1998/08/15 20:47:32 thorpej Exp $  */

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/timeout.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>

#include <dev/ic/smc91cxxvar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

int	sm_pcmcia_match(struct device *, void *, void *);
void	sm_pcmcia_attach(struct device *, struct device *, void *);
int	sm_pcmcia_detach(struct device *, int);
int	sm_pcmcia_activate(struct device *, int);

struct sm_pcmcia_softc {
	struct	smc91cxx_softc sc_smc;		/* real "smc" softc */

	/* PCMCIA-specific goo. */
	struct	pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o space info */
	int	sc_io_window;			/* our i/o window */
	void	*sc_ih;				/* interrupt cookie */
	struct	pcmcia_function *sc_pf;		/* our PCMCIA function */
};

struct cfattach sm_pcmcia_ca = {
	sizeof(struct sm_pcmcia_softc), sm_pcmcia_match, sm_pcmcia_attach,
	sm_pcmcia_detach, sm_pcmcia_activate
};

int	sm_pcmcia_enable(struct smc91cxx_softc *);
void	sm_pcmcia_disable(struct smc91cxx_softc *);

int	sm_pcmcia_ascii_enaddr(const char *, u_int8_t *);
int	sm_pcmcia_funce_enaddr(struct device *, u_int8_t *);

int	sm_pcmcia_lannid_ciscallback(struct pcmcia_tuple *, void *);

struct sm_pcmcia_product {
	u_int16_t	spp_vendor;	/* vendor ID */
	u_int16_t	spp_product;	/* product ID */
	int		spp_expfunc;	/* expected function */
} sm_pcmcia_prod[] = {
	{ PCMCIA_VENDOR_MEGAHERTZ2,	PCMCIA_PRODUCT_MEGAHERTZ2_XJACK,
	  0 },
	{ PCMCIA_VENDOR_MEGAHERTZ2,	PCMCIA_PRODUCT_MEGAHERTZ2_XJEM1144,
	  0 },
	{ PCMCIA_VENDOR_NEWMEDIA,	PCMCIA_PRODUCT_NEWMEDIA_BASICS,
	  0 },
	{ PCMCIA_VENDOR_SMC,		PCMCIA_PRODUCT_SMC_8020,
	  0 },
	{ PCMCIA_VENDOR_PSION,		PCMCIA_PRODUCT_PSION_GOLDCARD,
	  0 }
};

int
sm_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;
	int i;

	for (i = 0; i < nitems(sm_pcmcia_prod); i++)
		if (pa->manufacturer == sm_pcmcia_prod[i].spp_vendor &&
		    pa->product == sm_pcmcia_prod[i].spp_product &&
		    pa->pf->number == sm_pcmcia_prod[i].spp_expfunc)
			return (1);
	return (0);
}

void
sm_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct sm_pcmcia_softc *psc = (struct sm_pcmcia_softc *)self;
	struct smc91cxx_softc *sc = &psc->sc_smc;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	u_int8_t myla[ETHER_ADDR_LEN], *enaddr = NULL;
	const char *intrstr;

	psc->sc_pf = pa->pf;
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);

	/* Enable the card. */
	pcmcia_function_init(pa->pf, cfe);
	if (pcmcia_function_enable(pa->pf)) {
		printf(": function enable failed\n");
		return;
	}

	/* XXX sanity check number of mem and i/o spaces */

	/* Allocate and map i/o space for the card. */
	if (pcmcia_io_alloc(pa->pf, 0, cfe->iospace[0].length,
	    cfe->iospace[0].length, &psc->sc_pcioh)) {
		printf(": can't allocate i/o space\n");
		return;
	}

	sc->sc_bst = psc->sc_pcioh.iot;
	sc->sc_bsh = psc->sc_pcioh.ioh;

#ifdef notyet
	sc->sc_enable = sm_pcmcia_enable;
	sc->sc_disable = sm_pcmcia_disable;
#endif
	sc->sc_enabled = 1;

	if (pcmcia_io_map(pa->pf, (cfe->flags & PCMCIA_CFE_IO16) ?
	    PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_IO8, 0, cfe->iospace[0].length,
	    &psc->sc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		return;
	}

	printf(" port 0x%lx/%lu", psc->sc_pcioh.addr,
	    (u_long)psc->sc_pcioh.size);

	/*
	 * First try to get the Ethernet address from FUNCE/LANNID tuple.
	 */
	if (sm_pcmcia_funce_enaddr(parent, myla))
		enaddr = myla;

	/*
	 * If that failed, try one of the CIS info strings.
	 */
	if (enaddr == NULL) {
		char *cisstr = NULL;

		switch (pa->manufacturer) {
		case PCMCIA_VENDOR_MEGAHERTZ2:
			cisstr = pa->pf->sc->card.cis1_info[3];
			break;
		case PCMCIA_VENDOR_SMC:
			cisstr = pa->pf->sc->card.cis1_info[2];
			break;
		}
		if (cisstr != NULL && sm_pcmcia_ascii_enaddr(cisstr, myla))
			enaddr = myla;
	}

	if (enaddr == NULL)
		printf(", unable to get Ethernet address\n");

	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    smc91cxx_intr, sc, sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, psc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);

	/* Perform generic initialization. */
	smc91cxx_attach(sc, enaddr);

#ifdef notyet
	pcmcia_function_disable(pa->pf);
#endif
}

int
sm_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct sm_pcmcia_softc *psc = (struct sm_pcmcia_softc *)dev;
	struct ifnet *ifp = &psc->sc_smc.sc_arpcom.ac_if;
	int rv = 0;

	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
}

int
sm_pcmcia_activate(dev, act)
	struct device *dev;
	int act;
{
	struct sm_pcmcia_softc *sc = (struct sm_pcmcia_softc *)dev;
	struct ifnet *ifp = &sc->sc_smc.sc_arpcom.ac_if;

	switch (act) {
	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			smc91cxx_stop(&sc->sc_smc);
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}

int
sm_pcmcia_ascii_enaddr(cisstr, myla)
	const char *cisstr;
	u_int8_t *myla;
{
	char enaddr_str[12];
	int i, j;

	if (strlen(cisstr) != 12) {
		/* Bogus address! */
		return (0);
	}
	bcopy(cisstr, enaddr_str, sizeof enaddr_str);
	for (i = 0; i < 6; i++) {
		for (j = 0; j < 2; j++) {
			/* Convert to upper case. */
			if (enaddr_str[(i * 2) + j] >= 'a' &&
			    enaddr_str[(i * 2) + j] <= 'z')
				enaddr_str[(i * 2) + j] -= 'a' - 'A';

			/* Parse the digit. */
			if (enaddr_str[(i * 2) + j] >= '0' &&
			    enaddr_str[(i * 2) + j] <= '9')
				myla[i] |= enaddr_str[(i * 2) + j]
				    - '0';
			else if (enaddr_str[(i * 2) + j] >= 'A' &&
				 enaddr_str[(i * 2) + j] <= 'F')
				myla[i] |= enaddr_str[(i * 2) + j]
				    - 'A' + 10;
			else {
				/* Bogus digit!! */
				return (0);
			}

			/* Compensate for ordering of digits. */
			if (j == 0)
				myla[i] <<= 4;
		}
	}

	return (1);
}

int
sm_pcmcia_funce_enaddr(parent, myla)
	struct device *parent;
	u_int8_t *myla;
{

	return (pcmcia_scan_cis(parent, sm_pcmcia_lannid_ciscallback, myla));
}

int
sm_pcmcia_lannid_ciscallback(tuple, arg)
	struct pcmcia_tuple *tuple;
	void *arg;
{
	u_int8_t *myla = arg;
	int i;

	if (tuple->code == PCMCIA_CISTPL_FUNCE || tuple->code ==
	    PCMCIA_CISTPL_SPCL) {
		/* subcode, length */
		if (tuple->length < 2)
			return (0);

		if ((pcmcia_tuple_read_1(tuple, 0) !=
		     PCMCIA_TPLFE_TYPE_LAN_NID) ||
		    (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN))
			return (0);

		for (i = 0; i < ETHER_ADDR_LEN; i++)
			myla[i] = pcmcia_tuple_read_1(tuple, i + 2);
		return (1);
	}
	return (0);
}

int
sm_pcmcia_enable(sc)
	struct smc91cxx_softc *sc;
{
	struct sm_pcmcia_softc *psc = (struct sm_pcmcia_softc *)sc;

	/* Establish the interrupt handler. */
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, smc91cxx_intr,
	    sc, sc->sc_dev.dv_xname);
	if (psc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt handler\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (pcmcia_function_enable(psc->sc_pf));
}

void
sm_pcmcia_disable(sc)
	struct smc91cxx_softc *sc;
{
	struct sm_pcmcia_softc *psc = (struct sm_pcmcia_softc *)sc;

	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
	pcmcia_function_disable(psc->sc_pf);
}
@


1.36
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.35 2014/12/03 20:09:32 krw Exp $	*/
a47 1
#include <net/if_dl.h>
@


1.35
log
@More duplicate #include cleanout.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.34 2014/08/11 12:45:45 mpi Exp $	*/
a63 1
#include <dev/ic/smc91cxxreg.h>
@


1.34
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.33 2013/08/07 01:06:40 bluhm Exp $	*/
a59 2

#include <net/if_media.h>
@


1.33
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.32 2011/07/03 15:47:17 matthew Exp $	*/
a50 1
#ifdef INET
a51 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a52 1
#endif
@


1.32
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.31 2011/03/31 13:05:27 jasper Exp $	*/
a53 1
#include <netinet/in_var.h>
@


1.31
log
@- use nitems(); no binary change.

ok fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.30 2010/08/30 20:33:18 deraadt Exp $	*/
a256 6
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    smc91cxx_intr, sc, sc->sc_smc.sc_dev.dv_xname);
		smc91cxx_init(&sc->sc_smc);
		break;
@


1.30
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.29 2009/10/13 19:33:16 pirofti Exp $	*/
d131 1
a131 1
	for (i = 0; i < sizeof(sm_pcmcia_prod)/sizeof(sm_pcmcia_prod[0]); i++)
@


1.29
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.28 2008/06/26 05:42:17 ray Exp $	*/
a254 1
	int s;
a255 1
	s = splnet();
a262 1

d267 3
a269 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
a272 1
	splx(s);
@


1.28
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.27 2006/06/17 18:01:52 brad Exp $	*/
d81 1
a81 1
int	sm_pcmcia_activate(struct device *, enum devact);
d251 1
a251 1
	enum devact act;
@


1.27
log
@add sys/timeout.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.26 2006/04/20 20:31:13 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.26
log
@Fix various printf() issues: too many arguments, not enough arguments, argument
order reversed, wrong modifiers. ok deraadt@@ marco@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.25 2006/01/23 14:42:55 martin Exp $	*/
d51 1
@


1.25
log
@update sm(4) from NetBSD, including support for more models and MII;
also activate ISA attachment;

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.24 2005/11/21 18:16:42 millert Exp $	*/
d192 2
a193 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.24
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.23 2005/06/08 17:03:01 henning Exp $	*/
d71 5
@


1.23
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.22 2005/01/27 17:04:56 millert Exp $	*/
d50 1
a50 1
#include <sys/select.h>
@


1.22
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.21 2004/05/12 06:35:11 tedu Exp $	*/
a62 5
#endif

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
@


1.21
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.20 2003/09/04 03:46:48 avsm Exp $	*/
d155 1
d222 4
a225 3
	    smc91cxx_intr, sc, "");
	if (psc->sc_ih == NULL)
		printf(": couldn't establish interrupt\n");
@


1.20
log
@remove an unneccessary (and incorrectly sized) bzero
fix suggested by tedu@@, ok deraadt@@, fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.19 2003/02/18 13:14:43 jmc Exp $	*/
a71 1
#include <net/bpfdesc.h>
@


1.19
log
@intial -> initial;

the great intial witch hunt, as prompted by tdeval@@

os-aix-dso.c: ok henning@@
ab.C: ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.18 2002/11/19 18:36:18 jason Exp $	*/
d294 1
a294 2
	bcopy(cisstr, enaddr_str, 12);
	bzero(myla, sizeof(myla));
@


1.18
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.17 2002/07/01 13:31:06 fgsch Exp $	*/
d226 1
a226 1
	/* Perform generic intialization. */
@


1.17
log
@when printing the size, use what we have map'ed, not what's in the
configuration.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.16 2002/03/14 01:27:01 millert Exp $	*/
d158 1
a158 1
	cfe = pa->pf->cfe_head.sqh_first;
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.15 2001/08/17 21:52:16 deraadt Exp $	*/
d192 1
a192 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, cfe->iospace[0].length);
@


1.15
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.14 2000/08/04 15:51:02 aaron Exp $	*/
d85 4
a88 4
int	sm_pcmcia_match __P((struct device *, void *, void *));
void	sm_pcmcia_attach __P((struct device *, struct device *, void *));
int	sm_pcmcia_detach __P((struct device *, int));
int	sm_pcmcia_activate __P((struct device *, enum devact));
d105 2
a106 2
int	sm_pcmcia_enable __P((struct smc91cxx_softc *));
void	sm_pcmcia_disable __P((struct smc91cxx_softc *));
d108 2
a109 2
int	sm_pcmcia_ascii_enaddr __P((const char *, u_int8_t *));
int	sm_pcmcia_funce_enaddr __P((struct device *, u_int8_t *));
d111 1
a111 1
int	sm_pcmcia_lannid_ciscallback __P((struct pcmcia_tuple *, void *));
@


1.15.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.15 2001/08/17 21:52:16 deraadt Exp $	*/
d85 4
a88 4
int	sm_pcmcia_match(struct device *, void *, void *);
void	sm_pcmcia_attach(struct device *, struct device *, void *);
int	sm_pcmcia_detach(struct device *, int);
int	sm_pcmcia_activate(struct device *, enum devact);
d105 2
a106 2
int	sm_pcmcia_enable(struct smc91cxx_softc *);
void	sm_pcmcia_disable(struct smc91cxx_softc *);
d108 2
a109 2
int	sm_pcmcia_ascii_enaddr(const char *, u_int8_t *);
int	sm_pcmcia_funce_enaddr(struct device *, u_int8_t *);
d111 1
a111 1
int	sm_pcmcia_lannid_ciscallback(struct pcmcia_tuple *, void *);
@


1.15.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.15.4.1 2002/06/11 03:42:28 art Exp $	*/
d192 1
a192 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
@


1.15.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d158 1
a158 1
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);
d226 1
a226 1
	/* Perform generic initialization. */
@


1.14
log
@Support for the Psion Goldcard; pt98kfr@@student.hk-r.se
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.13 2000/06/20 05:01:11 niklas Exp $	*/
d221 2
a222 2
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, smc91cxx_intr,
	    sc);
a264 1
		printf("%s:", sc->sc_smc.sc_dev.dv_xname);
d266 1
a266 2
		    smc91cxx_intr, sc);
		printf("\n");
d369 1
a369 1
	    sc);
@


1.13
log
@Almost make a Megahertz card working, still rx probs though
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.12 2000/04/24 19:43:36 niklas Exp $	*/
d125 2
d345 2
a346 1
	if (tuple->code == PCMCIA_CISTPL_FUNCE) {
@


1.12
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.11 2000/02/02 19:09:59 fgsch Exp $	*/
d120 2
a121 1

a123 1

@


1.11
log
@Call xxx_init and xxx_stop on activate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.10 1999/10/01 04:05:11 downsj Exp $	*/
d274 1
a275 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d384 1
a385 2

	pcmcia_intr_disestablish(psc->sc_pf, psc->sc_ih);
@


1.11.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.14 2000/08/04 15:51:02 aaron Exp $	*/
d120 1
a120 2
	{ PCMCIA_VENDOR_MEGAHERTZ2,	PCMCIA_PRODUCT_MEGAHERTZ2_XJEM1144,
	  0 },
d123 1
a124 2
	  0 },
	{ PCMCIA_VENDOR_PSION,		PCMCIA_PRODUCT_PSION_GOLDCARD,
d274 1
a275 1
		pcmcia_function_disable(sc->sc_pf);
d343 1
a343 2
	if (tuple->code == PCMCIA_CISTPL_FUNCE || tuple->code ==
	    PCMCIA_CISTPL_SPCL) {
d384 2
a386 1
	pcmcia_function_disable(psc->sc_pf);
@


1.11.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.11.2.1 2001/05/14 22:26:07 niklas Exp $	*/
d221 2
a222 2
	psc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    smc91cxx_intr, sc, "");
d265 1
d267 2
a268 1
		    smc91cxx_intr, sc, sc->sc_smc.sc_dev.dv_xname);
d371 1
a371 1
	    sc, sc->sc_dev.dv_xname);
@


1.11.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 4
a88 4
int	sm_pcmcia_match(struct device *, void *, void *);
void	sm_pcmcia_attach(struct device *, struct device *, void *);
int	sm_pcmcia_detach(struct device *, int);
int	sm_pcmcia_activate(struct device *, enum devact);
d105 2
a106 2
int	sm_pcmcia_enable(struct smc91cxx_softc *);
void	sm_pcmcia_disable(struct smc91cxx_softc *);
d108 2
a109 2
int	sm_pcmcia_ascii_enaddr(const char *, u_int8_t *);
int	sm_pcmcia_funce_enaddr(struct device *, u_int8_t *);
d111 1
a111 1
int	sm_pcmcia_lannid_ciscallback(struct pcmcia_tuple *, void *);
@


1.11.2.4
log
@Sync the SMP branch with 3.3
@
text
@d158 1
a158 1
	cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head);
d192 1
a192 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, psc->sc_pcioh.size);
d226 1
a226 1
	/* Perform generic initialization. */
@


1.11.2.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d294 2
a295 1
	bcopy(cisstr, enaddr_str, sizeof enaddr_str);
@


1.11.2.6
log
@Merge with the trunk
@
text
@d72 1
@


1.10
log
@Attach to SMC 8020 cards, they seem to work fine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.9 1999/08/16 16:51:20 deraadt Exp $	*/
d256 1
d263 1
d266 2
d271 3
@


1.9
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.8 1999/08/16 10:25:18 fgsch Exp $	*/
d124 1
a124 2
#if 0
	{ PCMCIA_VENDOR_SMC,		PCMCIA_PRODUCT_SMC_8020BT,
a125 1
#endif
@


1.8
log
@Remove unneeded ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.7 1999/08/16 07:57:33 fgsch Exp $	*/
d114 2
a115 2
	u_int32_t	spp_vendor;	/* vendor ID */
	u_int32_t	spp_product;	/* product ID */
@


1.7
log
@Don't establish irq later.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.5 1999/08/08 01:17:23 niklas Exp $	*/
a54 3
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif
a61 3
#ifdef __NetBSD__
#include <netinet/if_inarp.h>
#else
a62 1
#endif
@


1.6
log
@shorten dmesg output.
@
text
@d186 1
d189 2
d228 5
d236 1
d238 1
@


1.5
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.4 1999/07/26 05:43:16 deraadt Exp $	*/
d124 1
a124 2
	const char	*spp_name;	/* product name */
} sm_pcmcia_products[] = {
d126 1
a126 1
	  0,				PCMCIA_STR_MEGAHERTZ2_XJACK },
d129 1
a129 1
	  0,				PCMCIA_STR_NEWMEDIA_BASICS },
d133 1
a133 1
	  0,				PCMCIA_STR_SMC_8020BT },
a134 3

	{ 0,				0,
	  0,				NULL },
a136 16
struct sm_pcmcia_product *sm_pcmcia_lookup __P((struct pcmcia_attach_args *));

struct sm_pcmcia_product *
sm_pcmcia_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	struct sm_pcmcia_product *spp;

	for (spp = sm_pcmcia_products; spp->spp_name != NULL; spp++)
		if (pa->manufacturer == spp->spp_vendor &&
		    pa->product == spp->spp_product &&
		    pa->pf->number == spp->spp_expfunc)
			return (spp);
	return (NULL);
}

d143 1
d145 5
a149 2
	if (sm_pcmcia_lookup(pa) != NULL)
		return (1);
a162 1
	struct sm_pcmcia_product *spp;
a196 6

	spp = sm_pcmcia_lookup(pa);
	if (spp == NULL)
		panic("sm_pcmcia_attach: impossible");

	printf(": %s", spp->spp_name);
@


1.4
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.3 1998/10/14 07:34:43 fgsch Exp $	*/
d94 2
d108 2
a109 1
	sizeof(struct sm_pcmcia_softc), sm_pcmcia_match, sm_pcmcia_attach
d252 43
@


1.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.2 1998/09/12 07:48:07 fgsch Exp $	*/
d210 2
d216 1
a216 1
	printf(": %s\n", spp->spp_name);
a233 1

a237 1

d243 1
a243 2
		printf("%s: unable to get Ethernet address\n",
		    sc->sc_dev.dv_xname);
@


1.2
log
@if_media support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_sm_pcmcia.c,v 1.1 1998/09/11 10:47:14 fgsch Exp $	*/
d318 4
a321 4
	if ((pcmcia_tuple_read_1(tuple, 0) !=
		PCMCIA_TPLFE_TYPE_LAN_NID) ||
	    (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN))
		return (0);
@


1.1
log
@PCMCIA code ported from NetBSD.
Support for aic, ep, pccom and sm.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a58 1
#endif
@

