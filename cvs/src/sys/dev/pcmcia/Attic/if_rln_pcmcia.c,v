head	1.16;
access;
symbols
	OPENBSD_4_3:1.15.0.14
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.15.0.12
	OPENBSD_4_2_BASE:1.15
	OPENBSD_4_1:1.15.0.10
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.8
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.8
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.6
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.4
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.2
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.13.0.4
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.13
	UBC:1.12.0.4
	UBC_BASE:1.12
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.10.0.4
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.9.0.2
	SMP_BASE:1.9
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.2
	OPENBSD_2_6_BASE:1.7;
locks; strict;
comment	@ * @;


1.16
date	2008.04.23.13.28.59;	author jsg;	state dead;
branches;
next	1.15;

1.15
date	2005.01.27.17.04.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2000.12.16.21.47.49;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.24.19.43.36;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	2000.02.05.13.55.45;	author d;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2000.02.03.18.42.42;	author angelos;	state Exp;
branches;
next	1.7;

1.7
date	99.08.23.23.24.47;	author d;	state Exp;
branches;
next	1.6;

1.6
date	99.08.19.06.38.24;	author d;	state Exp;
branches;
next	1.5;

1.5
date	99.08.18.06.06.13;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.18.05.24.42;	author d;	state Exp;
branches;
next	1.3;

1.3
date	99.08.16.16.51.19;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.07.30.13.43.37;	author d;	state Exp;
branches;
next	;

1.9.2.1
date	2001.05.14.22.26.07;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.9.2.4;

1.9.2.4
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	;

1.12.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2003.05.19.22.19.57;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Remove driver for pre 802.11 RangeLAN2 wireless devices.
It doesn't compile, was never finished, is now irrelevant, and miod
has taken it apon himself to scare good boys and girls by suggesting
they read the code.

ok dlg@@
@
text
@/*	$OpenBSD: if_rln_pcmcia.c,v 1.15 2005/01/27 17:04:56 millert Exp $	*/
/*
 * David Leonard <d@@openbsd.org>, 1999. Public domain.
 *
 * Proxim RangeLAN2 PC-Card and compatibles
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/queue.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/rln.h>
#include <dev/ic/rlnvar.h>
#include <dev/ic/rlnreg.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

struct rln_pcmcia_softc {
	struct rln_softc psc_rln;		/* real "rln" softc */

	struct pcmcia_io_handle psc_pcioh;	/* PCMCIA i/o information */
	int sc_io_window;			/* i/o window for the card */
	struct pcmcia_function *psc_pf;		/* our PCMCIA function */
	void *psc_ih;				/* our interrupt handle */
};

static int	rln_pcmcia_match(struct device *, void *, void *);
static struct	rln_pcmcia_product * rln_pcmcia_product_lookup(struct pcmcia_attach_args *);
static void	rln_pcmcia_attach(struct device *, struct device *, void *);
static int	rln_pcmcia_detach(struct device *, int);
static int	rln_pcmcia_activate(struct device *, enum devact);
static int	rlnintr_pcmcia(void *arg);

struct cfattach rln_pcmcia_ca = {
	sizeof(struct rln_pcmcia_softc), rln_pcmcia_match, rln_pcmcia_attach,
	rln_pcmcia_detach, rln_pcmcia_activate
};

static struct rln_pcmcia_product {
	u_int16_t	manufacturer;
	u_int16_t	product;
	const char	*cis[4];
	u_int8_t	flags;
} rln_pcmcia_products[] = {
	/* Digital RoamAbout 2400 FH, from d@@openbsd.org */
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_ROAMABOUT_2400FH,
	  PCMCIA_CIS_PROXIM_ROAMABOUT_2400FH,
	  0 },
	/* AMP Wireless, from jimduchek@@ou.edu */
	{ PCMCIA_VENDOR_COMPEX,
	  PCMCIA_PRODUCT_COMPEX_AMP_WIRELESS,
	  PCMCIA_CIS_COMPEX_AMP_WIRELESS,
	  0 },
	/* Proxim RangeLAN2 7401, from louis@@bertrandtech.on.ca */
	{ PCMCIA_VENDOR_PROXIM,
	  PCMCIA_PRODUCT_PROXIM_RANGELAN2_7401,
	  PCMCIA_CIS_PROXIM_RANGELAN2_7401,
	  0 },
	/* Generic and clone cards matched by CIS alone */
	{ PCMCIA_VENDOR_INVALID,
	  PCMCIA_PRODUCT_INVALID,
	  PCMCIA_CIS_PROXIM_RL2_7200,
	  0 },
	{ PCMCIA_VENDOR_INVALID,
	  PCMCIA_PRODUCT_INVALID,
	  PCMCIA_CIS_PROXIM_RL2_7400,
	  0 },
	{ PCMCIA_VENDOR_INVALID,
	  PCMCIA_PRODUCT_INVALID,
	  PCMCIA_CIS_PROXIM_SYMPHONY,
	  0 }
};
#define NPRODUCTS (sizeof rln_pcmcia_products / sizeof rln_pcmcia_products[0])

/* Match the card information with known card types */
static struct rln_pcmcia_product *
rln_pcmcia_product_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	int i, j;
	struct rln_pcmcia_product *rpp;

	for (i = 0; i < NPRODUCTS; i++) {
		rpp = &rln_pcmcia_products[i];
		if (rpp->manufacturer != PCMCIA_VENDOR_INVALID &&
		    rpp->manufacturer != pa->manufacturer)
			continue;
		if (rpp->product != PCMCIA_PRODUCT_INVALID &&
		    rpp->product != pa->product)
			continue;
		for (j = 0; j < 4; j++) {
			if (rpp->cis[j] == NULL)
				return rpp;
			if (pa->card->cis1_info[j] &&
			    strcmp(pa->card->cis1_info[j], rpp->cis[j]) != 0)
				break;
		}
		if (j == 4)
			return rpp;
	}
	return NULL;
}

/* Do we know this card? */
static int
rln_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;

	return (rln_pcmcia_product_lookup(pa) != NULL);
}

/* Attach and configure */
void
rln_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct rln_pcmcia_softc *psc = (void *) self;
	struct rln_softc *sc = &psc->psc_rln;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	struct rln_pcmcia_product *rpp;
	const char *intrstr;

	psc->psc_pf = pa->pf;
	cfe = SIMPLEQ_FIRST(&psc->psc_pf->cfe_head);

	/* Guess the transfer width we will be using */
	if (cfe->flags & PCMCIA_CFE_IO16)
		sc->sc_width = 16;
	else if (cfe->flags & PCMCIA_CFE_IO8)
		sc->sc_width = 8;
	else
		sc->sc_width = 0;

#ifdef DIAGNOSTIC
	/* We only expect one i/o region and no memory region */
	if (cfe->num_memspace != 0)
		printf(": unexpected number of memory spaces (%d)\n",
		    cfe->num_memspace);
	if (cfe->num_iospace != 1)
		printf(": unexpected number of i/o spaces (%d)\n",
		    cfe->num_iospace);
	else if (cfe->iospace[0].length != RLN_NPORTS)
		printf(": unexpected size of i/o space (0x%x)\n",
		    cfe->iospace[0].length);
	if (sc->sc_width == 0)
		printf(": unknown bus width\n");
#endif /* DIAGNOSTIC */

	pcmcia_function_init(psc->psc_pf, cfe);

	/* Allocate i/o space */
	if (pcmcia_io_alloc(psc->psc_pf, 0, RLN_NPORTS,
	    RLN_NPORTS, &psc->psc_pcioh)) {
		printf(": can't allocate i/o space\n");
		return;
	}

	sc->sc_iot = psc->psc_pcioh.iot;
	sc->sc_ioh = psc->psc_pcioh.ioh;

	/* Map i/o space */
	if (pcmcia_io_map(psc->psc_pf, ((sc->sc_width == 8) ? PCMCIA_WIDTH_IO8 :
	    (sc->sc_width == 16) ? PCMCIA_WIDTH_IO16 : PCMCIA_WIDTH_AUTO),
	    0, RLN_NPORTS, &psc->psc_pcioh, &psc->sc_io_window)) {
		printf(": can't map i/o space\n");
		return;
	}
	printf(" port 0x%lx/%d", psc->psc_pcioh.addr, RLN_NPORTS);

	/* Enable the card */
	if (pcmcia_function_enable(psc->psc_pf)) {
		printf(": function enable failed\n");
		return;
	}

#ifdef notyet
	sc->enable = rln_pcmcia_enable;
	sc->disable = rln_pcmcia_disable;
#endif

	rpp = rln_pcmcia_product_lookup(pa);

	/* Check if the device has a separate antenna module */
	sc->sc_cardtype = 0;
	switch (psc->psc_pf->ccr_base) {
	case 0x0100:
		sc->sc_cardtype |= RLN_CTYPE_ONE_PIECE;
		break;
	case 0x0800:
		sc->sc_cardtype &= ~RLN_CTYPE_ONE_PIECE;
		break;
#ifdef DIAGNOSTIC
	default:
		printf(": cannot tell if one or two piece (ccr addr %x)\n",
			sc->sc_dev.dv_xname, psc->psc_pf->ccr_base);
#endif
	}

	/* The PC-card needs to be told to use 'irq' 15 */
	sc->sc_irq = 15;

	/*
	 * We need to get an interrupt before configuring, since
	 * polling registers (the alternative) to reading card
	 * responses, causes hard lock-ups.
	 */
	psc->psc_ih = pcmcia_intr_establish(psc->psc_pf, IPL_NET,
		rlnintr_pcmcia, sc, sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, psc->sc_ih);
	if (*intrstr)
		printf(", %s", intrstr);
	sc->sc_ih = NULL;

#ifdef DIAGNOSTIC
	if (rpp->manufacturer == PCMCIA_VENDOR_INVALID)
		printf(" manf %04x prod %04x", pa->manufacturer, pa->product);
#endif

	rln_reset(sc);
	rlnconfig(sc);
	printf("\n");
}

static int
rln_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct rln_pcmcia_softc *psc = (struct rln_pcmcia_softc *)dev;
	struct rln_softc *sc = (struct rln_softc *)dev;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;

	pcmcia_io_unmap(psc->psc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->psc_pf, &psc->psc_pcioh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
}

static int
rln_pcmcia_activate(dev, act)
	struct device *dev;
	enum devact act;
{
	struct rln_pcmcia_softc *psc = (struct rln_pcmcia_softc *)dev;
	struct rln_softc *sc = (struct rln_softc *)dev;
        struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int s;

	s = splnet();
	switch (act) {
	case DVACT_ACTIVATE:
		pcmcia_function_enable(psc->psc_pf);
		psc->psc_ih = pcmcia_intr_establish(psc->psc_pf, IPL_NET,
		    rlnintr_pcmcia, psc, sc->sc_dev.dv_xname);
		rlninit(sc);
		break;

	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			rlnstop(sc);
		pcmcia_intr_disestablish(psc->psc_pf, psc->psc_ih);
		pcmcia_function_disable(psc->psc_pf);
		break;
	}
	splx(s);
	return (0);
}

/* Interrupt handler */
static int
rlnintr_pcmcia(arg)
	void *arg;
{
	struct rln_softc *sc = (struct rln_softc *)arg;
	struct rln_pcmcia_softc *psc = (struct rln_pcmcia_softc *)sc;
	int opt;
	int ret;

	/* Need to immediately read/write the option register for PC-card */
	opt = pcmcia_ccr_read(psc->psc_pf, PCMCIA_CCR_OPTION);
	pcmcia_ccr_write(psc->psc_pf, PCMCIA_CCR_OPTION, opt);

	/* Call actual interrupt handler */
	ret = rlnintr(sc);

	return (ret);
}
@


1.15
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.14 2002/11/19 18:36:18 jason Exp $	*/
@


1.14
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.13 2002/03/14 01:27:01 millert Exp $	*/
d141 1
d228 4
a231 4
		rlnintr_pcmcia, sc, "");
	if (psc->psc_ih == NULL)
		printf(": couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
@


1.13
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.12 2001/08/17 21:52:16 deraadt Exp $	*/
d143 1
a143 1
	cfe = psc->psc_pf->cfe_head.sqh_first;
@


1.12
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.11 2000/12/16 21:47:49 mickey Exp $	*/
d41 6
a46 7
static int	rln_pcmcia_match __P((struct device *, void *, void *));
static struct	rln_pcmcia_product * rln_pcmcia_product_lookup
     __P((struct pcmcia_attach_args *));
static void	rln_pcmcia_attach __P((struct device *, struct device *, void *));
static int	rln_pcmcia_detach __P((struct device *, int));
static int	rln_pcmcia_activate __P((struct device *, enum devact));
static int	rlnintr_pcmcia __P((void *arg));
@


1.12.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.12 2001/08/17 21:52:16 deraadt Exp $	*/
d41 7
a47 6
static int	rln_pcmcia_match(struct device *, void *, void *);
static struct	rln_pcmcia_product * rln_pcmcia_product_lookup(struct pcmcia_attach_args *);
static void	rln_pcmcia_attach(struct device *, struct device *, void *);
static int	rln_pcmcia_detach(struct device *, int);
static int	rln_pcmcia_activate(struct device *, enum devact);
static int	rlnintr_pcmcia(void *arg);
@


1.12.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d143 1
a143 1
	cfe = SIMPLEQ_FIRST(&psc->psc_pf->cfe_head);
@


1.11
log
@make sure cis1_info[i] is not NULL before strcmp() w/ it; fixes some obscure panics
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.10 2000/04/24 19:43:36 niklas Exp $	*/
d228 1
a228 1
		rlnintr_pcmcia, sc);
d277 2
a278 5
		printf("%s:", sc->sc_dev.dv_xname);
		psc->psc_ih =
		    pcmcia_intr_establish(psc->psc_pf, IPL_NET, rlnintr_pcmcia,
		        psc);
		printf("\n");
@


1.10
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.9 2000/02/05 13:55:45 d Exp $	*/
d110 2
a111 1
			if (strcmp(pa->card->cis1_info[j], rpp->cis[j]) != 0)
@


1.9
log
@repair suspend/activate; extern rlnstop, rlninit
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.8 2000/02/03 18:42:42 angelos Exp $	*/
d288 1
a289 1
		pcmcia_intr_disestablish(psc->psc_pf, psc->psc_ih);
@


1.9.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.11 2000/12/16 21:47:49 mickey Exp $	*/
d110 1
a110 2
			if (pa->card->cis1_info[j] &&
			    strcmp(pa->card->cis1_info[j], rpp->cis[j]) != 0)
d288 1
a289 1
		pcmcia_function_disable(psc->psc_pf);
@


1.9.2.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.9.2.1 2001/05/14 22:26:07 niklas Exp $	*/
d228 1
a228 1
		rlnintr_pcmcia, sc, "");
d277 5
a281 2
		psc->psc_ih = pcmcia_intr_establish(psc->psc_pf, IPL_NET,
		    rlnintr_pcmcia, psc, sc->sc_dev.dv_xname);
@


1.9.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 7
a47 6
static int	rln_pcmcia_match(struct device *, void *, void *);
static struct	rln_pcmcia_product * rln_pcmcia_product_lookup(struct pcmcia_attach_args *);
static void	rln_pcmcia_attach(struct device *, struct device *, void *);
static int	rln_pcmcia_detach(struct device *, int);
static int	rln_pcmcia_activate(struct device *, enum devact);
static int	rlnintr_pcmcia(void *arg);
@


1.9.2.4
log
@Sync the SMP branch with 3.3
@
text
@d143 1
a143 1
	cfe = SIMPLEQ_FIRST(&psc->psc_pf->cfe_head);
@


1.8
log
@Fix the activate routine to support suspend/resume.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.7 1999/08/23 23:24:47 d Exp $	*/
d33 1
a33 1
	struct rln_softc sc_rln;		/* real "rln" softc */
d35 1
a35 1
	struct pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o information */
d37 2
a38 2
	struct pcmcia_function *sc_pf;		/* our PCMCIA function */
	void *sc_ih;				/* our interrupt handle */
d137 1
a137 1
	struct rln_softc *sc = &psc->sc_rln;
d142 2
a143 2
	psc->sc_pf = pa->pf;
	cfe = psc->sc_pf->cfe_head.sqh_first;
d168 1
a168 1
	pcmcia_function_init(psc->sc_pf, cfe);
d171 2
a172 2
	if (pcmcia_io_alloc(psc->sc_pf, 0, RLN_NPORTS,
	    RLN_NPORTS, &psc->sc_pcioh)) {
d177 2
a178 2
	sc->sc_iot = psc->sc_pcioh.iot;
	sc->sc_ioh = psc->sc_pcioh.ioh;
d181 1
a181 1
	if (pcmcia_io_map(psc->sc_pf, ((sc->sc_width == 8) ? PCMCIA_WIDTH_IO8 :
d183 1
a183 1
	    0, RLN_NPORTS, &psc->sc_pcioh, &psc->sc_io_window)) {
d187 1
a187 1
	printf(" port 0x%lx/%d", psc->sc_pcioh.addr, RLN_NPORTS);
d190 1
a190 1
	if (pcmcia_function_enable(psc->sc_pf)) {
d204 1
a204 1
	switch (psc->sc_pf->ccr_base) {
d214 1
a214 1
			sc->sc_dev.dv_xname, psc->sc_pf->ccr_base);
d226 1
a226 1
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
d228 1
a228 1
	if (sc->sc_ih == NULL)
d231 1
d253 2
a254 2
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
d267 2
a268 1
	struct rln_pcmcia_softc *sc = (struct rln_pcmcia_softc *)dev;
d275 1
a275 1
		pcmcia_function_enable(sc->sc_pf);
d277 3
a279 3
		sc->sc_rln.sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, rlnintr_pcmcia,
		        sc);
d288 2
a289 2
		pcmcia_function_disable(sc->sc_pf);
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_rln.sc_ih);
d307 2
a308 2
	opt = pcmcia_ccr_read(psc->sc_pf, PCMCIA_CCR_OPTION);
	pcmcia_ccr_write(psc->sc_pf, PCMCIA_CCR_OPTION, opt);
d311 1
a311 1
	ret = rlnintr(arg);
@


1.7
log
@reset card before attempting config
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.6 1999/08/19 06:38:24 d Exp $	*/
d267 1
d274 1
d278 2
d283 3
@


1.6
log
@test vendor id against PCMCIA_VENDOR_INVALID, not against 0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.5 1999/08/18 06:06:13 fgsch Exp $	*/
d237 1
@


1.5
log
@Remove unneeded code. Use u_int16_t.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.4 1999/08/18 05:24:42 d Exp $	*/
d233 1
a233 1
	if (rpp->manufacturer == 0)
@


1.4
log
@make most functions static
use defines from pcmciadevs
remove some futile debugging and ancient detach code
print configure message in `the new way'
fix compile error where 'sc' wasn't defined
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.3 1999/08/16 16:51:19 deraadt Exp $	*/
d55 2
a56 3
	const char	*name;
	u_int32_t	manufacturer;
	u_int32_t	product;
d61 1
a61 2
	{ PCMCIA_STR_PROXIM_ROAMABOUT_2400FH,
	  PCMCIA_VENDOR_PROXIM,
d66 1
a66 2
	{ PCMCIA_STR_COMPEX_AMP_WIRELESS,
	  PCMCIA_VENDOR_COMPEX,
d71 1
a71 2
	{ PCMCIA_STR_PROXIM_RANGELAN2_7401,
	  PCMCIA_VENDOR_PROXIM,
d76 1
a76 2
	{ PCMCIA_STR_PROXIM_RL2_7200,
	  PCMCIA_VENDOR_INVALID,
d80 1
a80 2
	{ PCMCIA_STR_PROXIM_RL2_7400,
	  PCMCIA_VENDOR_INVALID,
d84 1
a84 2
	{ PCMCIA_STR_PROXIM_SYMPHONY,
	  PCMCIA_VENDOR_INVALID,
a231 1
	printf(" <%s>", rpp->name);
@


1.3
log
@manufacturer and product are 16 bits, 0xffff is the special case
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.2 1999/08/08 01:17:23 niklas Exp $	*/
d41 2
a42 2
int	rln_pcmcia_match __P((struct device *, void *, void *));
struct	rln_pcmcia_product * rln_pcmcia_product_lookup
d44 4
a47 9
void	rln_pcmcia_attach __P((struct device *, struct device *, void *));
int	rln_pcmcia_detach __P((struct device *, int));
int	rln_pcmcia_activate __P((struct device *, enum devact));
int	rlnintr_pcmcia __P((void *arg));

#ifdef notyet
int  rln_pcmcia_enable __P((struct rln_softc *));
void rln_pcmcia_disable __P((struct rln_softc *));
#endif
a53 4
#define PCMCIA_CIS_RANGELAN2_7200 { "PROXIM", "LAN CARD",    "RANGELAN2", NULL }
#define PCMCIA_CIS_RANGELAN2_7400 { "PROXIM", "LAN PC CARD", "RANGELAN2", NULL }
#define PCMCIA_CIS_SYMPHONY       { "PROXIM", "LAN PC CARD", "SYMPHONY", NULL }

a54 2
	u_int16_t	manufacturer;
	u_int16_t	product;
d56 3
d61 11
a71 3
	{ 0x0126,				/* Digital */
	  0x1058,				/* RoamAbout 2400 FH */
	  "Digital RoamAbout 2400 FH",
d73 5
a77 3
	{ 0x8a01,				/* AMP */
	  0x0066,				/* Wireless */
	  "AMP Wireless",
d79 5
a83 3
	{ 0,
	  0,
	  "unknown RangeLAN2 wireless network card",
d85 10
d96 1
d98 2
a99 2
/* Match the product and manufacturer codes with known card types */
struct rln_pcmcia_product *
d103 1
d106 18
a123 6
	for (rpp = rln_pcmcia_products; rpp->manufacturer && rpp->product;
	    rpp++)
		if (pa->manufacturer == rpp->manufacturer &&
		    pa->product == rpp->product)
			break;
	return (rpp);
d126 2
a127 2
/* Match card CIS info string with RangeLAN2 cards */
int
d133 2
a134 16
	static const char *cis_7200[] = PCMCIA_CIS_RANGELAN2_7200;
	static const char *cis_7400[] = PCMCIA_CIS_RANGELAN2_7400;
	static const char *cis_symp[] = PCMCIA_CIS_SYMPHONY;
	static const char **cis_info[] = { cis_7200, cis_7400, cis_symp, NULL };
	const char ***cis;
	int i;

	for (cis = cis_info; *cis; cis++) {
		for (i = 0; ; i++) {
			if ((*cis)[i] == NULL)
				return (1);
			if (strcmp((*cis)[i], pa->card->cis1_info[i]) != 0)
				break;
		}
	}
	return (0);
a148 11
#ifdef RLNDEBUG
	/* Allowed i/o base addresses from the RoamAbout owner's manual */
	int i;
	static bus_addr_t iobases[] = {
		0x270, 		/* useful in user-space debugging */
		0x100, 0x120, 0x140, 0x218, 0x270, 0x280, 0x290, 0x298,
		0x2a0, 0x2a8, 0x2e0, 0x300, 0x310, 0x358, 0x360, 0x368,
		0
	};
#endif

a177 8
#ifdef RLNDEBUG
	/* Try only those ports from the manual */
	for (i=0; iobases[i] != 0; i++)
		if (pcmcia_io_alloc(psc->sc_pf, iobases[i], RLN_NPORTS,
		    RLN_NPORTS, &psc->sc_pcioh) == 0)
			break;
	if (iobases[i] == 0) {
#else
d180 1
a180 2
#endif
		printf(": can't alloc i/o space\n");
d194 1
d220 1
a220 1
		printf("\n%s: cannot tell if one or two piece (ccr addr %x)\n",
a232 1
	printf("\n");
d236 1
a236 1
		printf("%s: couldn't establish interrupt\n",
d239 1
a239 1
	printf("%s: %s", sc->sc_dev.dv_xname, rpp->name);
d244 1
d249 1
a249 1
int
d255 1
d268 1
a268 1
int
d295 1
a295 1
int
a312 31

#ifdef notyet
int
rln_pcmcia_enable(sc)
	struct rln_softc *sc;
{
	struct rln_pcmcia_softc *psc = (struct rln_pcmcia_softc *) sc;
	struct pcmcia_function *pf = psc->sc_pf;

	/* Establish the interrupt */
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
		rlnintr_pcmcia, sc);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	return (pcmcia_function_enable(pf));
}

void
rln_pcmcia_disable(sc)
	struct rln_softc *sc;
{
	struct rln_pcmcia_softc *psc = (struct rln_pcmcia_softc *) sc;

	pcmcia_function_disable(psc->sc_pf);
	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);
}
#endif
@


1.2
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.1 1999/07/30 13:43:37 d Exp $	*/
d64 2
a65 2
	u_int32_t	manufacturer;
	u_int32_t	product;
@


1.1
log
@rename rl2->rln for sanity
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rln_pcmcia.c,v 1.4 1999/07/14 07:22:14 d Exp $	*/
d41 7
a47 5
static int  rln_pcmcia_match __P((struct device *, void *, void *));
static struct rln_pcmcia_product * rln_pcmcia_product_lookup __P((
		struct pcmcia_attach_args *));
static void rln_pcmcia_attach __P((struct device *, struct device *, void *));
static int rlnintr_pcmcia __P((void *arg));
d50 2
a51 2
static int  rln_pcmcia_enable __P((struct rln_softc *));
static void rln_pcmcia_disable __P((struct rln_softc *));
d55 2
a56 1
	sizeof(struct rln_pcmcia_softc), rln_pcmcia_match, rln_pcmcia_attach
d84 1
a84 1
static struct rln_pcmcia_product *
d99 1
a99 1
static int
d124 1
a124 1
static void
d254 44
d299 1
a299 1
static int
d319 1
a319 1
static int
d338 1
a338 1
static void
@

