head	1.33;
access;
symbols
	SMP_SYNC_A:1.33
	SMP_SYNC_B:1.33
	UBC_SYNC_A:1.33
	UBC_SYNC_B:1.33
	OPENBSD_2_9_BASE:1.31
	OPENBSD_2_9:1.31.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.8.0.2
	SMP_BASE:1.8
	kame_19991208:1.4
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.33
date	2001.05.15.02.40.35;	author millert;	state dead;
branches;
next	1.32;

1.32
date	2001.05.14.21.45.25;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.23.20.52.35;	author millert;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.08.21.44.36;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.04.08.15.45.50;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	2001.04.04.20.13.11;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.19.20.24.59;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2001.03.19.20.13.43;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	2001.03.17.18.54.52;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2001.03.11.08.41.28;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2001.02.20.19.39.46;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.01.17.04.54.47;	author aaron;	state Exp;
branches;
next	1.21;

1.21
date	2001.01.16.20.18.33;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2001.01.14.23.11.10;	author angelos;	state Exp;
branches;
next	1.19;

1.19
date	2001.01.11.06.45.25;	author angelos;	state Exp;
branches;
next	1.18;

1.18
date	2001.01.10.17.43.38;	author angelos;	state Exp;
branches;
next	1.17;

1.17
date	2000.11.08.14.25.24;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.17.19.10.55;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.30.01.04.28;	author art;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.20.07.24.36;	author todd;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.00.12.41;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.18.04.02.11;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.24.06.23.36;	author itojun;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.24.19.43.36;	author niklas;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.03.27.18.34.58;	author jason;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.03.00.56.45;	author angelos;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.02.02.18.47.02;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.12.16.04.51.30;	author angelos;	state Exp;
branches;
next	1.5;

1.5
date	99.12.15.21.49.07;	author angelos;	state Exp;
branches;
next	1.4;

1.4
date	99.10.27.00.58.35;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.08.13.20.36.38;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.08.01.17.23;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	99.07.11.16.25.36;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.26.07;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.43.26;	author niklas;	state dead;
branches;
next	;

1.10.2.1
date	2000.06.19.03.21.55;	author jason;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Split wi(4) into bus-dependent and bus-independent bits similar to
an(4) -- no real code changes at this point.
Rename if_wavelan_ieee.h to if_wi_ieee.h while I'm at it and
create an if_wivar.h similar to NetBSD.
PCI adaptors exist that are not true PCMCIA controllers so
wi(4) @@ PCI is possible (though the code is not working yet ;-).
@
text
@/*	$OpenBSD: if_wi.c,v 1.32 2001/05/14 21:45:25 mickey Exp $	*/

/*
 * Copyright (c) 1997, 1998, 1999
 *	Bill Paul <wpaul@@ctr.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 *	From: if_wi.c,v 1.7 1999/07/04 14:40:22 wpaul Exp $
 */

/*
 * Lucent WaveLAN/IEEE 802.11 PCMCIA driver for FreeBSD.
 *
 * Written by Bill Paul <wpaul@@ctr.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The WaveLAN/IEEE adapter is the second generation of the WaveLAN
 * from Lucent. Unlike the older cards, the new ones are programmed
 * entirely via a firmware-driven controller called the Hermes.
 * Unfortunately, Lucent will not release the Hermes programming manual
 * without an NDA (if at all). What they do release is an API library
 * called the HCF (Hardware Control Functions) which is supposed to
 * do the device-specific operations of a device driver for you. The
 * publically available version of the HCF library (the 'HCF Light') is
 * a) extremely gross, b) lacks certain features, particularly support
 * for 802.11 frames, and c) is contaminated by the GNU Public License.
 *
 * This driver does not use the HCF or HCF Light at all. Instead, it
 * programs the Hermes controller directly, using information gleaned
 * from the HCF Light code and corresponding documentation.
 *
 * This driver supports both the PCMCIA and ISA versions of the
 * WaveLAN/IEEE cards. Note however that the ISA card isn't really
 * anything of the sort: it's actually a PCMCIA bridge adapter
 * that fits into an ISA slot, into which a PCMCIA WaveLAN card is
 * inserted. Consequently, you need to use the pccard support for
 * both the ISA and PCMCIA adapters.
 */

#define WI_HERMES_AUTOINC_WAR	/* Work around data write autoinc bug. */
#define WI_HERMES_STATS_WAR	/* Work around stats counter bug. */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>
#include <net/if_types.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <i386/isa/icu.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>
#include <dev/pcmcia/if_wireg.h>
#include <dev/pcmcia/if_wavelan_ieee.h>

#define BPF_MTAP(if,mbuf) bpf_mtap((if)->if_bpf, (mbuf))
#define BPFATTACH(if_bpf,if,dlt,sz)
#define STATIC
#define WI_PRT_FMT "%s"
#define WI_PRT_ARG(sc) (sc)->sc_dev.dv_xname

#ifdef WIDEBUG

u_int32_t	widebug = WIDEBUG;

#define WID_INTR	0x01
#define WID_START	0x02
#define WID_IOCTL	0x04
#define WID_INIT	0x08
#define WID_STOP	0x10
#define WID_RESET	0x20

#define DPRINTF(mask,args) if (widebug & (mask)) printf args;

#else	/* !WIDEBUG */
#define DPRINTF(mask,args)
#endif	/* WIDEBUG */

#if !defined(lint) && !defined(__OpenBSD__)
static const char rcsid[] =
	"$OpenBSD: if_wi.c,v 1.32 2001/05/14 21:45:25 mickey Exp $";
#endif	/* lint */

#ifdef foo
static u_int8_t	wi_mcast_addr[6] = { 0x01, 0x60, 0x1D, 0x00, 0x01, 0x00 };
#endif

STATIC void wi_reset		__P((struct wi_softc *));
STATIC int wi_ioctl		__P((struct ifnet *, u_long, caddr_t));
STATIC void wi_init		__P((void *));
STATIC void wi_start		__P((struct ifnet *));
STATIC void wi_stop		__P((struct wi_softc *));
STATIC void wi_watchdog		__P((struct ifnet *));
STATIC void wi_shutdown		__P((void *));
STATIC void wi_rxeof		__P((struct wi_softc *));
STATIC void wi_txeof		__P((struct wi_softc *, int));
STATIC void wi_update_stats	__P((struct wi_softc *));
STATIC void wi_setmulti		__P((struct wi_softc *));

STATIC int wi_cmd		__P((struct wi_softc *, int, int));
STATIC int wi_read_record	__P((struct wi_softc *, struct wi_ltv_gen *));
STATIC int wi_write_record	__P((struct wi_softc *, struct wi_ltv_gen *));
STATIC int wi_read_data		__P((struct wi_softc *, int,
					int, caddr_t, int));
STATIC int wi_write_data	__P((struct wi_softc *, int,
					int, caddr_t, int));
STATIC int wi_seek		__P((struct wi_softc *, int, int, int));
STATIC int wi_alloc_nicmem	__P((struct wi_softc *, int, int *));
STATIC void wi_inquire		__P((void *));
STATIC void wi_setdef		__P((struct wi_softc *, struct wi_req *));
STATIC int wi_mgmt_xmit		__P((struct wi_softc *, caddr_t, int));

int	wi_pcmcia_match		__P((struct device *, void *, void *));
void	wi_pcmcia_attach	__P((struct device *, struct device *, void *));
int	wi_pcmcia_detach	__P((struct device *, int));
int	wi_pcmcia_activate	__P((struct device *, enum devact));
int	wi_intr			__P((void *));

/* Autoconfig definition of driver back-end */
struct cfdriver wi_cd = {
	NULL, "wi", DV_IFNET
};

struct cfattach wi_ca = {
	sizeof (struct wi_softc), wi_pcmcia_match, wi_pcmcia_attach,
	wi_pcmcia_detach, wi_pcmcia_activate
};

static const struct wi_pcmcia_product {
	u_int32_t	pp_vendor;
	u_int32_t	pp_product;
	const char	*pp_cisinfo[4];
	const char	*pp_name;
	int		pp_prism2;
} wi_pcmcia_products[] = {
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_LUCENT_WAVELAN_IEEE,
	  "WaveLAN/IEEE",
	  0 },

	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE737A,
	  PCMCIA_CIS_3COM_3CRWE737A,
	  "3Com AirConnect Wireless LAN",
	  1 },

	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCC_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCC_11,
	  "Corega Wireless LAN PCC-11",
	  1 },

	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCA_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCA_11,
	  "Corega Wireless LAN PCCA-11",
	  1 },

	{ PCMCIA_VENDOR_INTERSIL,
	  PCMCIA_PRODUCT_INTERSIL_PRISM2,
	  PCMCIA_CIS_INTERSIL_PRISM2,
	  "Intersil Prism II",
	  1 },

	{ PCMCIA_VENDOR_SAMSUNG,
	  PCMCIA_PRODUCT_SAMSUNG_SWL_2000N,
	  PCMCIA_CIS_SAMSUNG_SWL_2000N,
	  "Samsung MagicLAN SWL-2000N",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_SMC_2632W,
	  "SMC 2632 EZ Connect Wireless PC Card",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NANOSPEED_PRISM2,
	  "NANOSPEED ROOT-RZ2000 WLAN Card",
	  1 },

	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI300_IEEE,
	  PCMCIA_CIS_ELSA_XI300_IEEE,
	  "XI300 Wireless LAN",
	  1 },

	{ PCMCIA_VENDOR_COMPAQ,
	  PCMCIA_PRODUCT_COMPAQ_NC5004,
	  PCMCIA_CIS_COMPAQ_NC5004,
	  "Compaq Agency NC5004 Wireless Card",
	  1 },

	{ PCMCIA_VENDOR_CONTEC,
	  PCMCIA_PRODUCT_CONTEC_FX_DS110_PCC,
	  PCMCIA_CIS_CONTEC_FX_DS110_PCC,
	  "Contec FLEXLAN/FX-DS110-PCC",
	  1 },

	{ PCMCIA_VENDOR_TDK,
	  PCMCIA_PRODUCT_TDK_LAK_CD011WL,
	  PCMCIA_CIS_TDK_LAK_CD011WL,
	  "TDK LAK-CD011WL",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NEC_CMZ_RT_WP,
	  "NEC Wireless Card CMZ-RT-WP",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NTT_ME_WLAN,
	  "NTT-ME 11Mbps Wireless LAN PC Card",
	  1 },

	{ PCMCIA_VENDOR_ADDTRON,
	  PCMCIA_PRODUCT_ADDTRON_AWP100,
	  PCMCIA_CIS_ADDTRON_AWP100,
	  "Addtron AWP-100",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_CABLETRON_ROAMABOUT,
	  "Cabletron RoamAbout",
	  0 },

	{ PCMCIA_VENDOR_IODATA2,
	  PCMCIA_PRODUCT_IODATA2_WNB11PCM,
	  PCMCIA_CIS_IODATA2_WNB11PCM,
	  "I-O DATA WN-B11/PCM",
	  1 },

	{ PCMCIA_VENDOR_LINKSYS,
	  PCMCIA_PRODUCT_LINKSYS_WPC11,
	  PCMCIA_CIS_LINKSYS_WPC11,
	  "Linksys WPC11",
	  1 },

	{ 0,
	  0,
	  { NULL, NULL, NULL, NULL },
	  NULL,
	  0 }
};

static const struct wi_pcmcia_product *wi_lookup __P((struct pcmcia_attach_args *pa));

const struct wi_pcmcia_product *
wi_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	const struct wi_pcmcia_product *pp;

	/*
	 * match by CIS information first
	 * XXX: Farallon SkyLINE 11mb uses PRISM II but vendor ID
	 *	and product ID is the same as Lucent WaveLAN
	 */
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
		if (pa->card->cis1_info[0] != NULL &&
		    pp->pp_cisinfo[0] != NULL &&
		    strcmp(pa->card->cis1_info[0], pp->pp_cisinfo[0]) == 0 &&
		    pa->card->cis1_info[1] != NULL &&
		    pp->pp_cisinfo[1] != NULL &&
		    strcmp(pa->card->cis1_info[1], pp->pp_cisinfo[1]) == 0)
			return pp;
	}

	/* match by vendor/product id */
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
		if (pa->manufacturer != PCMCIA_VENDOR_INVALID &&
		    pa->manufacturer == pp->pp_vendor &&
		    pa->product != PCMCIA_PRODUCT_INVALID &&
		    pa->product == pp->pp_product)
			return pp;
	}

	return NULL;
}

int
wi_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;

	if (wi_lookup(pa) != NULL)
		return 1;
	return 0;
}

void
wi_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wi_softc		*sc = (struct wi_softc *)self;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_function	*pf = pa->pf;
	struct pcmcia_config_entry *cfe = pf->cfe_head.sqh_first;
	const struct wi_pcmcia_product *pp;
	struct wi_ltv_macaddr	mac;
	struct wi_ltv_gen	gen;
	struct ifnet		*ifp;
	int			state = 0;

	sc->sc_pf = pf;

	/* Enable the card. */
	pcmcia_function_init(pf, cfe);
	if (pcmcia_function_enable(pf)) {
		printf(": function enable failed\n");
		goto bad;
	}
	state++;

	if (pcmcia_io_alloc(pf, 0, WI_IOSIZ, WI_IOSIZ, &sc->sc_pcioh)) {
		printf(": can't alloc i/o space\n");
		goto bad;
	}
	state++;

	if (pcmcia_io_map(pf, PCMCIA_WIDTH_IO16, 0, WI_IOSIZ, &sc->sc_pcioh,
	    &sc->sc_io_window)) {
		printf(": can't map io space\n");
		goto bad;
	}
	state++;

	sc->wi_gone = 0;
	sc->wi_btag = sc->sc_pcioh.iot;
	sc->wi_bhandle = sc->sc_pcioh.ioh;

	pp = wi_lookup(pa);
	if (pp == NULL) {
		/* should not happen */
		sc->sc_prism2 = 0;
	} else
		sc->sc_prism2 = pp->pp_prism2;

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);

	wi_reset(sc);

	/* Read the station address. */
	mac.wi_type = WI_RID_MAC_NODE;
	mac.wi_len = 4;
	wi_read_record(sc, (struct wi_ltv_gen *)&mac);
	bcopy((char *)&mac.wi_mac_addr, (char *)&sc->arpcom.ac_enaddr,
	    ETHER_ADDR_LEN);

	printf(": %saddress %s", sc->sc_prism2? "Prism II, " : "",
	    ether_sprintf(sc->arpcom.ac_enaddr));

	ifp = &sc->arpcom.ac_if;
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wi_ioctl;
	ifp->if_start = wi_start;
	ifp->if_watchdog = wi_watchdog;
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	bzero(sc->wi_node_name, sizeof(sc->wi_node_name));
	bcopy(WI_DEFAULT_NODENAME, sc->wi_node_name,
	    sizeof(WI_DEFAULT_NODENAME) - 1);

	bzero(sc->wi_net_name, sizeof(sc->wi_net_name));
	bcopy(WI_DEFAULT_NETNAME, sc->wi_net_name,
	    sizeof(WI_DEFAULT_NETNAME) - 1);

	bzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));
	bcopy(WI_DEFAULT_IBSS, sc->wi_ibss_name,
	    sizeof(WI_DEFAULT_IBSS) - 1);

	sc->wi_portnum = WI_DEFAULT_PORT;
	sc->wi_ptype = WI_PORTTYPE_BSS;
	sc->wi_ap_density = WI_DEFAULT_AP_DENSITY;
	sc->wi_rts_thresh = WI_DEFAULT_RTS_THRESH;
	sc->wi_tx_rate = WI_DEFAULT_TX_RATE;
	sc->wi_max_data_len = WI_DEFAULT_DATALEN;
	sc->wi_create_ibss = WI_DEFAULT_CREATE_IBSS;
	sc->wi_pm_enabled = WI_DEFAULT_PM_ENABLED;
	sc->wi_max_sleep = WI_DEFAULT_MAX_SLEEP;

	/*
	 * Read the default channel from the NIC. This may vary
	 * depending on the country where the NIC was purchased, so
	 * we can't hard-code a default and expect it to work for
	 * everyone.
	 */
	gen.wi_type = WI_RID_OWN_CHNL;
	gen.wi_len = 2;
	wi_read_record(sc, &gen);
	sc->wi_channel = gen.wi_val;

	/*
	 * Find out if we support WEP on this card.
	 */
	gen.wi_type = WI_RID_WEP_AVAIL;
	gen.wi_len = 2;
	wi_read_record(sc, &gen);
	sc->wi_has_wep = gen.wi_val;
	timeout_set(&sc->sc_timo, wi_inquire, sc);

	bzero((char *)&sc->wi_stats, sizeof(sc->wi_stats));

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);

#if NBPFILTER > 0
	BPFATTACH(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	    sizeof(struct ether_header));
#endif

	shutdownhook_establish(wi_shutdown, sc);

	/* Establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pa->pf, IPL_NET, wi_intr, sc);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		goto bad;
	}
	printf("\n");

	wi_init(sc);
	wi_stop(sc);
	return;

bad:
	if (state > 2)
		pcmcia_io_unmap(pf, sc->sc_io_window);
	if (state > 1)
		pcmcia_io_free(pf, &sc->sc_pcioh);
	if (state > 0)
		pcmcia_function_disable(pf);
}

int
wi_pcmcia_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct wi_softc *sc = (struct wi_softc *)dev;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int rv = 0;

	pcmcia_io_unmap(sc->sc_pf, sc->sc_io_window);
	pcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
}

int
wi_pcmcia_activate(dev, act)
	struct device *dev;
	enum devact act;
{
	struct wi_softc *sc = (struct wi_softc *)dev;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int s;

	s = splnet();
	switch (act) {
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		printf("%s:", WI_PRT_ARG(sc));
		sc->sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, wi_intr, sc);
		printf("\n");
		wi_init(sc);
		break;

	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		if (ifp->if_flags & IFF_RUNNING)
			wi_stop(sc);
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	splx(s);
	return (0);
}

int
wi_intr(vsc)
	void			*vsc;
{
	struct wi_softc		*sc = vsc;
	struct ifnet		*ifp;
	u_int16_t		status;

	DPRINTF(WID_INTR, ("wi_intr: sc %p\n", sc));

	ifp = &sc->arpcom.ac_if;

	if (!(ifp->if_flags & IFF_UP)) {
		CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);
		CSR_WRITE_2(sc, WI_INT_EN, 0);
		return (0);
	}

	/* Disable interrupts. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);

	status = CSR_READ_2(sc, WI_EVENT_STAT);
	CSR_WRITE_2(sc, WI_EVENT_ACK, ~WI_INTRS);

	if (status & WI_EV_RX) {
		wi_rxeof(sc);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_RX);
	}

	if (status & WI_EV_TX) {
		wi_txeof(sc, status);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX);
	}

	if (status & WI_EV_ALLOC) {
		int			id;
		id = CSR_READ_2(sc, WI_ALLOC_FID);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);
		if (id == sc->wi_tx_data_id)
			wi_txeof(sc, status);
	}

	if (status & WI_EV_INFO) {
		wi_update_stats(sc);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO);
	}

	if (status & WI_EV_TX_EXC) {
		wi_txeof(sc, status);
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_TX_EXC);
	}

	if (status & WI_EV_INFO_DROP) {
		CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_INFO_DROP);
	}

	/* Re-enable interrupts. */
	CSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);

	if (ifp->if_snd.ifq_head != NULL)
		wi_start(ifp);

	return (1);
}

STATIC void
wi_rxeof(sc)
	struct wi_softc		*sc;
{
	struct ifnet		*ifp;
	struct ether_header	*eh;
	struct wi_frame		rx_frame;
	struct mbuf		*m;
	int			id;

	ifp = &sc->arpcom.ac_if;

	id = CSR_READ_2(sc, WI_RX_FID);

	/* First read in the frame header */
	if (wi_read_data(sc, id, 0, (caddr_t)&rx_frame, sizeof(rx_frame))) {
		ifp->if_ierrors++;
		return;
	}

	if (rx_frame.wi_status & WI_STAT_ERRSTAT) {
		ifp->if_ierrors++;
		return;
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}
	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		ifp->if_ierrors++;
		return;
	}

	eh = mtod(m, struct ether_header *);
	m->m_pkthdr.rcvif = ifp;

	if (rx_frame.wi_status == WI_STAT_1042 ||
	    rx_frame.wi_status == WI_STAT_TUNNEL ||
	    rx_frame.wi_status == WI_STAT_WMP_MSG) {
		if((rx_frame.wi_dat_len + WI_SNAPHDR_LEN) > MCLBYTES) {
			printf(WI_PRT_FMT ": oversized packet received "
			    "(wi_dat_len=%d, wi_status=0x%x)\n",
			    WI_PRT_ARG(sc), rx_frame.wi_dat_len,
			    rx_frame.wi_status);
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
		m->m_pkthdr.len = m->m_len =
		    rx_frame.wi_dat_len + WI_SNAPHDR_LEN;

		bcopy((char *)&rx_frame.wi_addr1,
		    (char *)&eh->ether_dhost, ETHER_ADDR_LEN);
		bcopy((char *)&rx_frame.wi_addr2,
		    (char *)&eh->ether_shost, ETHER_ADDR_LEN);
		bcopy((char *)&rx_frame.wi_type,
		    (char *)&eh->ether_type, sizeof(u_int16_t));

		if (wi_read_data(sc, id, WI_802_11_OFFSET,
		    mtod(m, caddr_t) + sizeof(struct ether_header),
		    m->m_len + 2)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
	} else {
		if((rx_frame.wi_dat_len +
		    sizeof(struct ether_header)) > MCLBYTES) {
			printf(WI_PRT_FMT ": oversized packet received "
			    "(wi_dat_len=%d, wi_status=0x%x)\n",
			    WI_PRT_ARG(sc), rx_frame.wi_dat_len,
			    rx_frame.wi_status);
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
		m->m_pkthdr.len = m->m_len =
		    rx_frame.wi_dat_len + sizeof(struct ether_header);

		if (wi_read_data(sc, id, WI_802_3_OFFSET,
		    mtod(m, caddr_t), m->m_len + 2)) {
			m_freem(m);
			ifp->if_ierrors++;
			return;
		}
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/* Handle BPF listeners. */
	if (ifp->if_bpf)
		BPF_MTAP(ifp, m);
#endif

	/* Receive packet. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);

	return;
}

STATIC void
wi_txeof(sc, status)
	struct wi_softc		*sc;
	int			status;
{
	struct ifnet		*ifp;

	ifp = &sc->arpcom.ac_if;

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_OACTIVE;

	if (status & WI_EV_TX_EXC)
		ifp->if_oerrors++;
	else
		ifp->if_opackets++;

	return;
}

void
wi_inquire(xsc)
	void			*xsc;
{
	struct wi_softc		*sc;
	struct ifnet		*ifp;
	int s, rv;

	sc = xsc;
	ifp = &sc->arpcom.ac_if;

	timeout_add(&sc->sc_timo, hz * 60);

	/* Don't do this while we're transmitting */
	if (ifp->if_flags & IFF_OACTIVE)
		return;

	s = splnet();
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);
	splx(s);
	if (rv)
		printf(WI_PRT_FMT ": wi_cmd failed with %d\n", WI_PRT_ARG(sc),
		    rv);

	return;
}

void
wi_update_stats(sc)
	struct wi_softc		*sc;
{
	struct wi_ltv_gen	gen;
	u_int16_t		id;
	struct ifnet		*ifp;
	u_int32_t		*ptr;
	int			i;
	u_int16_t		t;

	ifp = &sc->arpcom.ac_if;

	id = CSR_READ_2(sc, WI_INFO_FID);

	wi_read_data(sc, id, 0, (char *)&gen, 4);

	if (gen.wi_type != WI_INFO_COUNTERS ||
	    gen.wi_len > (sizeof(sc->wi_stats) / 4) + 1)
		return;

	ptr = (u_int32_t *)&sc->wi_stats;

	for (i = 0; i < gen.wi_len - 1; i++) {
		t = CSR_READ_2(sc, WI_DATA1);
#ifdef WI_HERMES_STATS_WAR
		if (t > 0xF000)
			t = ~t & 0xFFFF;
#endif
		ptr[i] += t;
	}

	ifp->if_collisions = sc->wi_stats.wi_tx_single_retries +
	    sc->wi_stats.wi_tx_multi_retries +
	    sc->wi_stats.wi_tx_retry_limit;

	return;
}

STATIC int
wi_cmd(sc, cmd, val)
	struct wi_softc		*sc;
	int			cmd;
	int			val;
{
	int			i, s = 0;

	CSR_WRITE_2(sc, WI_PARAM0, val);
	CSR_WRITE_2(sc, WI_COMMAND, cmd);

	for (i = WI_TIMEOUT; i--; DELAY(1)) {
		/*
		 * Wait for 'command complete' bit to be
		 * set in the event status register.
		 */
		s = CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_CMD;
		if (s) {
			/* Ack the event and read result code. */
			s = CSR_READ_2(sc, WI_STATUS);
			CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_CMD);
#ifdef foo
			if ((s & WI_CMD_CODE_MASK) != (cmd & WI_CMD_CODE_MASK))
				return(EIO);
#endif
			if (s & WI_STAT_CMD_RESULT)
				return(EIO);
			break;
		}
	}

	if (i < 0)
		return(ETIMEDOUT);

	return(0);
}

STATIC void
wi_reset(sc)
	struct wi_softc		*sc;
{
	DPRINTF(WID_RESET, ("wi_reset: sc %p\n", sc));

	if (wi_cmd(sc, WI_CMD_INI, 0))
		printf(WI_PRT_FMT ": init failed\n", WI_PRT_ARG(sc));
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);

	/* Calibrate timer. */
	WI_SETVAL(WI_RID_TICK_TIME, 8);

	return;
}

/*
 * Read an LTV record from the NIC.
 */
STATIC int
wi_read_record(sc, ltv)
	struct wi_softc		*sc;
	struct wi_ltv_gen	*ltv;
{
	u_int16_t		*ptr;
	int			i, len, code;
	struct wi_ltv_gen	*oltv, p2ltv;

	if (sc->sc_prism2) {
		oltv = ltv;
		switch (ltv->wi_type) {
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		}
	}

	/* Tell the NIC to enter record read mode. */
	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_READ, ltv->wi_type))
		return(EIO);

	/* Seek to the record. */
	if (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))
		return(EIO);

	/*
	 * Read the length and record type and make sure they
	 * match what we expect (this verifies that we have enough
	 * room to hold all of the returned data).
	 */
	len = CSR_READ_2(sc, WI_DATA1);
	if (len > ltv->wi_len)
		return(ENOSPC);
	code = CSR_READ_2(sc, WI_DATA1);
	if (code != ltv->wi_type)
		return(EIO);

	ltv->wi_len = len;
	ltv->wi_type = code;

	/* Now read the data. */
	ptr = &ltv->wi_val;
	for (i = 0; i < ltv->wi_len - 1; i++)
		ptr[i] = CSR_READ_2(sc, WI_DATA1);

	if (sc->sc_prism2) {
		switch (oltv->wi_type) {
		case WI_RID_TX_RATE:
		case WI_RID_CUR_TX_RATE:
			switch (ltv->wi_val) {
			case 1: oltv->wi_val = 1; break;
			case 2: oltv->wi_val = 2; break;
			case 3:	oltv->wi_val = 6; break;
			case 4: oltv->wi_val = 5; break;
			case 7: oltv->wi_val = 7; break;
			case 8: oltv->wi_val = 11; break;
			case 15: oltv->wi_val = 3; break;
			default: oltv->wi_val = 0x100 + ltv->wi_val; break;
			}
			break;
		case WI_RID_ENCRYPTION:
			oltv->wi_len = 2;
			if (ltv->wi_val & 0x01)
				oltv->wi_val = 1;
			else
				oltv->wi_val = 0;
			break;
		case WI_RID_TX_CRYPT_KEY:
			oltv->wi_len = 2;
			oltv->wi_val = ltv->wi_val;
			break;
		}
	}

	return(0);
}

/*
 * Same as read, except we inject data instead of reading it.
 */
STATIC int
wi_write_record(sc, ltv)
	struct wi_softc		*sc;
	struct wi_ltv_gen	*ltv;
{
	u_int16_t		*ptr;
	int			i;
	struct wi_ltv_gen	p2ltv;

	if (sc->sc_prism2) {
		switch (ltv->wi_type) {
		case WI_RID_TX_RATE:
			switch (ltv->wi_val) {
			case 1: p2ltv.wi_val = 1; break;
			case 2: p2ltv.wi_val = 2; break;
			case 3:	p2ltv.wi_val = 15; break;
			case 5: p2ltv.wi_val = 4; break;
			case 6: p2ltv.wi_val = 3; break;
			case 7: p2ltv.wi_val = 7; break;
			case 11: p2ltv.wi_val = 8; break;
			default: return EINVAL;
			}
			ltv = &p2ltv;
			break;
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			if (ltv->wi_val & 0x01)
				p2ltv.wi_val = 0x03;
			else
				p2ltv.wi_val = 0x90;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			p2ltv.wi_val = ltv->wi_val;
			ltv = &p2ltv;
			break;
		case WI_RID_DEFLT_CRYPT_KEYS: {
				int error;
				struct wi_ltv_str ws;
				struct wi_ltv_keys *wk = (struct wi_ltv_keys *)ltv;
				for (i = 0; i < 4; i++) {
					ws.wi_len = 4;
					ws.wi_type = WI_RID_P2_CRYPT_KEY0 + i;
					memcpy(ws.wi_str, &wk->wi_keys[i].wi_keydat, 5);
					ws.wi_str[5] = '\0';
					error = wi_write_record(sc,
					    (struct wi_ltv_gen *)&ws);
					if (error)
						return (error);
				}
			}
			return (0);
		}
	}

	if (wi_seek(sc, ltv->wi_type, 0, WI_BAP1))
		return(EIO);

	CSR_WRITE_2(sc, WI_DATA1, ltv->wi_len);
	CSR_WRITE_2(sc, WI_DATA1, ltv->wi_type);

	ptr = &ltv->wi_val;
	for (i = 0; i < ltv->wi_len - 1; i++)
		CSR_WRITE_2(sc, WI_DATA1, ptr[i]);

	if (wi_cmd(sc, WI_CMD_ACCESS|WI_ACCESS_WRITE, ltv->wi_type))
		return(EIO);

	return(0);
}

STATIC int
wi_seek(sc, id, off, chan)
	struct wi_softc		*sc;
	int			id, off, chan;
{
	int			i;
	int			selreg, offreg;

	switch (chan) {
	case WI_BAP0:
		selreg = WI_SEL0;
		offreg = WI_OFF0;
		break;
	case WI_BAP1:
		selreg = WI_SEL1;
		offreg = WI_OFF1;
		break;
	default:
		printf(WI_PRT_FMT ": invalid data path: %x\n", WI_PRT_ARG(sc),
		    chan);
		return(EIO);
	}

	CSR_WRITE_2(sc, selreg, id);
	CSR_WRITE_2(sc, offreg, off);

	for (i = WI_TIMEOUT; i--; DELAY(1))
		if (!(CSR_READ_2(sc, offreg) & (WI_OFF_BUSY|WI_OFF_ERR)))
			break;

	if (i < 0)
		return(ETIMEDOUT);

	return(0);
}

STATIC int
wi_read_data(sc, id, off, buf, len)
	struct wi_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
{
	int			i;
	u_int16_t		*ptr;

	if (wi_seek(sc, id, off, WI_BAP1))
		return(EIO);

	ptr = (u_int16_t *)buf;
	for (i = 0; i < len / 2; i++)
		ptr[i] = CSR_READ_2(sc, WI_DATA1);

	return(0);
}

/*
 * According to the comments in the HCF Light code, there is a bug in
 * the Hermes (or possibly in certain Hermes firmware revisions) where
 * the chip's internal autoincrement counter gets thrown off during
 * data writes: the autoincrement is missed, causing one data word to
 * be overwritten and subsequent words to be written to the wrong memory
 * locations. The end result is that we could end up transmitting bogus
 * frames without realizing it. The workaround for this is to write a
 * couple of extra guard words after the end of the transfer, then
 * attempt to read then back. If we fail to locate the guard words where
 * we expect them, we preform the transfer over again.
 */
STATIC int
wi_write_data(sc, id, off, buf, len)
	struct wi_softc		*sc;
	int			id, off;
	caddr_t			buf;
	int			len;
{
	int			i;
	u_int16_t		*ptr;

#ifdef WI_HERMES_AUTOINC_WAR
again:
#endif

	if (wi_seek(sc, id, off, WI_BAP0))
		return(EIO);

	ptr = (u_int16_t *)buf;
	for (i = 0; i < (len / 2); i++)
		CSR_WRITE_2(sc, WI_DATA0, ptr[i]);

#ifdef WI_HERMES_AUTOINC_WAR
	CSR_WRITE_2(sc, WI_DATA0, 0x1234);
	CSR_WRITE_2(sc, WI_DATA0, 0x5678);

	if (wi_seek(sc, id, off + len, WI_BAP0))
		return(EIO);

	if (CSR_READ_2(sc, WI_DATA0) != 0x1234 ||
	    CSR_READ_2(sc, WI_DATA0) != 0x5678)
		goto again;
#endif

	return(0);
}

/*
 * Allocate a region of memory inside the NIC and zero
 * it out.
 */
STATIC int
wi_alloc_nicmem(sc, len, id)
	struct wi_softc		*sc;
	int			len;
	int			*id;
{
	int			i;

	if (wi_cmd(sc, WI_CMD_ALLOC_MEM, len)) {
		printf(WI_PRT_FMT ": failed to allocate %d bytes on NIC\n",
		    WI_PRT_ARG(sc), len);
		return(ENOMEM);
	}

	for (i = WI_TIMEOUT; i--; DELAY(1)) {
		if (CSR_READ_2(sc, WI_EVENT_STAT) & WI_EV_ALLOC)
			break;
	}

	if (i < 0)
		return(ETIMEDOUT);

	CSR_WRITE_2(sc, WI_EVENT_ACK, WI_EV_ALLOC);
	*id = CSR_READ_2(sc, WI_ALLOC_FID);

	if (wi_seek(sc, *id, 0, WI_BAP0))
		return(EIO);

	for (i = 0; i < len / 2; i++)
		CSR_WRITE_2(sc, WI_DATA0, 0);

	return(0);
}

STATIC void
wi_setmulti(sc)
	struct wi_softc		*sc;
{
	struct ifnet		*ifp;
	int			i = 0;
	struct wi_ltv_mcast	mcast;
	struct ether_multistep	step;
	struct ether_multi	*enm;

	ifp = &sc->arpcom.ac_if;

	bzero((char *)&mcast, sizeof(mcast));

	mcast.wi_type = WI_RID_MCAST;
	mcast.wi_len = ((ETHER_ADDR_LEN / 2) * 16) + 1;

	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
		wi_write_record(sc, (struct wi_ltv_gen *)&mcast);
		return;
	}

	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
	while (enm != NULL) {
		if (i >= 16) {
			bzero((char *)&mcast, sizeof(mcast));
			break;
		}

		/* Punt on ranges. */
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0)
			break;
		bcopy(enm->enm_addrlo, (char *)&mcast.wi_mcast[i],
		    ETHER_ADDR_LEN);
		i++;
		ETHER_NEXT_MULTI(step, enm);
	}

	mcast.wi_len = (i * 3) + 1;
	wi_write_record(sc, (struct wi_ltv_gen *)&mcast);

	return;
}

STATIC void
wi_setdef(sc, wreq)
	struct wi_softc		*sc;
	struct wi_req		*wreq;
{
	struct sockaddr_dl	*sdl;
	struct ifaddr		*ifa;
	struct ifnet		*ifp;
	extern struct ifaddr	**ifnet_addrs;

	ifp = &sc->arpcom.ac_if;

	switch(wreq->wi_type) {
	case WI_RID_MAC_NODE:
		ifa = ifnet_addrs[ifp->if_index];
		sdl = (struct sockaddr_dl *)ifa->ifa_addr;
		bcopy((char *)&wreq->wi_val, LLADDR(sdl), ETHER_ADDR_LEN);
		bcopy((char *)&wreq->wi_val, (char *)&sc->arpcom.ac_enaddr,
		    ETHER_ADDR_LEN);
		break;
	case WI_RID_PORTTYPE:
		sc->wi_ptype = wreq->wi_val[0];
		break;
	case WI_RID_TX_RATE:
		sc->wi_tx_rate = wreq->wi_val[0];
		break;
	case WI_RID_MAX_DATALEN:
		sc->wi_max_data_len = wreq->wi_val[0];
		break;
	case WI_RID_RTS_THRESH:
		sc->wi_rts_thresh = wreq->wi_val[0];
		break;
	case WI_RID_SYSTEM_SCALE:
		sc->wi_ap_density = wreq->wi_val[0];
		break;
	case WI_RID_CREATE_IBSS:
		sc->wi_create_ibss = wreq->wi_val[0];
		break;
	case WI_RID_OWN_CHNL:
		sc->wi_channel = wreq->wi_val[0];
		break;
	case WI_RID_NODENAME:
		bzero(sc->wi_node_name, sizeof(sc->wi_node_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_node_name, 30);
		break;
	case WI_RID_DESIRED_SSID:
		bzero(sc->wi_net_name, sizeof(sc->wi_net_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_net_name, 30);
		break;
	case WI_RID_OWN_SSID:
		bzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));
		bcopy((char *)&wreq->wi_val[1], sc->wi_ibss_name, 30);
		break;
	case WI_RID_PM_ENABLED:
		sc->wi_pm_enabled = wreq->wi_val[0];
		break;
	case WI_RID_MAX_SLEEP:
		sc->wi_max_sleep = wreq->wi_val[0];
		break;
	case WI_RID_ENCRYPTION:
		sc->wi_use_wep = wreq->wi_val[0];
		break;
	case WI_RID_TX_CRYPT_KEY:
		sc->wi_tx_key = wreq->wi_val[0];
		break;
	case WI_RID_DEFLT_CRYPT_KEYS:
		bcopy((char *)wreq, (char *)&sc->wi_keys,
		    sizeof(struct wi_ltv_keys));
		break;
	default:
		break;
	}

	/* Reinitialize WaveLAN. */
	wi_init(sc);

	return;
}

STATIC int
wi_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
{
	int			s, error = 0;
	struct wi_softc		*sc;
	struct wi_req		wreq;
	struct ifreq		*ifr;
	struct proc		*p = curproc;
	struct ifaddr		*ifa = (struct ifaddr *)data;

	s = splimp();

	sc = ifp->if_softc;
	ifr = (struct ifreq *)data;

	if (sc->wi_gone) {
		splx(s);
		return(ENODEV);
	}

	DPRINTF (WID_IOCTL, ("wi_ioctl: command %lu data %p\n",
	    command, data));

	if ((error = ether_ioctl(ifp, &sc->arpcom, command, data)) > 0) {
		splx(s);
		return error;
	}

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			wi_init(sc);
			arp_ifinit(&sc->arpcom, ifa);
			break;
#endif	/* INET */
		default:
			wi_init(sc);
			break;
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->wi_if_flags & IFF_PROMISC)) {
				WI_SETVAL(WI_RID_PROMISC, 1);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->wi_if_flags & IFF_PROMISC) {
				WI_SETVAL(WI_RID_PROMISC, 0);
			}
			wi_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING) {
				wi_stop(sc);
			}
		}
		sc->wi_if_flags = ifp->if_flags;
		error = 0;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* Update our multicast list. */
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			wi_setmulti(sc);
			error = 0;
		}
		break;
	case SIOCGWAVELAN:
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		if (wreq.wi_type == WI_RID_IFACE_STATS) {
			bcopy((char *)&sc->wi_stats, (char *)&wreq.wi_val,
			    sizeof(sc->wi_stats));
			wreq.wi_len = (sizeof(sc->wi_stats) / 2) + 1;
		} else if (wreq.wi_type == WI_RID_DEFLT_CRYPT_KEYS) {
			/* For non-root user, return all-zeroes keys */
			if (suser(p->p_ucred, &p->p_acflag))
				bzero((char *)&wreq,
					sizeof(struct wi_ltv_keys));
			else
				bcopy((char *)&sc->wi_keys, (char *)&wreq,
					sizeof(struct wi_ltv_keys));
		} else {
			if (wi_read_record(sc, (struct wi_ltv_gen *)&wreq)) {
				error = EINVAL;
				break;
			}
		}
		error = copyout(&wreq, ifr->ifr_data, sizeof(wreq));
		break;
	case SIOCSWAVELAN:
		error = suser(p->p_ucred, &p->p_acflag);
		if (error)
			break;
		error = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (error)
			break;
		if (wreq.wi_type == WI_RID_IFACE_STATS) {
			error = EINVAL;
			break;
		} else if (wreq.wi_type == WI_RID_MGMT_XMIT) {
			error = wi_mgmt_xmit(sc, (caddr_t)&wreq.wi_val,
			    wreq.wi_len);
		} else {
			error = wi_write_record(sc, (struct wi_ltv_gen *)&wreq);
			if (!error)
				wi_setdef(sc, &wreq);
		}
		break;
	default:
		error = EINVAL;
		break;
	}

	splx(s);

	return(error);
}

STATIC void
wi_init(xsc)
	void			*xsc;
{
	struct wi_softc		*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	int			s;
	struct wi_ltv_macaddr	mac;
	int			id = 0;

	if (sc->wi_gone)
		return;

	DPRINTF(WID_INIT, ("wi_init: sc %p\n", sc));

	s = splimp();

	if (ifp->if_flags & IFF_RUNNING)
		wi_stop(sc);

	wi_reset(sc);

	/* Program max data length. */
	WI_SETVAL(WI_RID_MAX_DATALEN, sc->wi_max_data_len);

	/* Enable/disable IBSS creation. */
	WI_SETVAL(WI_RID_CREATE_IBSS, sc->wi_create_ibss);

	/* Set the port type. */
	WI_SETVAL(WI_RID_PORTTYPE, sc->wi_ptype);

	/* Program the RTS/CTS threshold. */
	WI_SETVAL(WI_RID_RTS_THRESH, sc->wi_rts_thresh);

	/* Program the TX rate */
	WI_SETVAL(WI_RID_TX_RATE, sc->wi_tx_rate);

	/* Access point density */
	WI_SETVAL(WI_RID_SYSTEM_SCALE, sc->wi_ap_density);

	/* Power Management Enabled */
	WI_SETVAL(WI_RID_PM_ENABLED, sc->wi_pm_enabled);

	/* Power Managment Max Sleep */
	WI_SETVAL(WI_RID_MAX_SLEEP, sc->wi_max_sleep);

	/* Specify the IBSS name */
	WI_SETSTR(WI_RID_OWN_SSID, sc->wi_ibss_name);

	/* Specify the network name */
	WI_SETSTR(WI_RID_DESIRED_SSID, sc->wi_net_name);

	/* Specify the frequency to use */
	WI_SETVAL(WI_RID_OWN_CHNL, sc->wi_channel);

	/* Program the nodename. */
	WI_SETSTR(WI_RID_NODENAME, sc->wi_node_name);

	/* Set our MAC address. */
	mac.wi_len = 4;
	mac.wi_type = WI_RID_MAC_NODE;
	bcopy((char *)&sc->arpcom.ac_enaddr,
	   (char *)&mac.wi_mac_addr, ETHER_ADDR_LEN);
	wi_write_record(sc, (struct wi_ltv_gen *)&mac);

	/* Configure WEP. */
	if (sc->wi_has_wep) {
		WI_SETVAL(WI_RID_ENCRYPTION, sc->wi_use_wep);
		WI_SETVAL(WI_RID_TX_CRYPT_KEY, sc->wi_tx_key);
		sc->wi_keys.wi_len = (sizeof(struct wi_ltv_keys) / 2) + 1;
		sc->wi_keys.wi_type = WI_RID_DEFLT_CRYPT_KEYS;
		wi_write_record(sc, (struct wi_ltv_gen *)&sc->wi_keys);
	}

	/* Initialize promisc mode. */
	if (ifp->if_flags & IFF_PROMISC) {
		WI_SETVAL(WI_RID_PROMISC, 1);
	} else {
		WI_SETVAL(WI_RID_PROMISC, 0);
	}

	/* Set multicast filter. */
	wi_setmulti(sc);

	/* Enable desired port */
	wi_cmd(sc, WI_CMD_ENABLE|sc->wi_portnum, 0);

	if (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))
		printf(WI_PRT_FMT ": tx buffer allocation failed\n",
		    WI_PRT_ARG(sc));
	sc->wi_tx_data_id = id;

	if (wi_alloc_nicmem(sc, 1518 + sizeof(struct wi_frame) + 8, &id))
		printf(WI_PRT_FMT ": mgmt. buffer allocation failed\n",
		    WI_PRT_ARG(sc));
	sc->wi_tx_mgmt_id = id;

	/* enable interrupts */
	CSR_WRITE_2(sc, WI_INT_EN, WI_INTRS);

	splx(s);

	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	timeout_add(&sc->sc_timo, hz * 60);

	return;
}

STATIC void
wi_start(ifp)
	struct ifnet		*ifp;
{
	struct wi_softc		*sc;
	struct mbuf		*m0;
	struct wi_frame		tx_frame;
	struct ether_header	*eh;
	int			id;

	sc = ifp->if_softc;

	DPRINTF(WID_START, ("wi_start: ifp %p sc %p\n", ifp, sc));

	if (sc->wi_gone)
		return;

	if (ifp->if_flags & IFF_OACTIVE)
		return;

	IF_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;

	bzero((char *)&tx_frame, sizeof(tx_frame));
	id = sc->wi_tx_data_id;
	eh = mtod(m0, struct ether_header *);

	/*
	 * Use RFC1042 encoding for IP and ARP datagrams,
	 * 802.3 for anything else.
	 */
	if (ntohs(eh->ether_type) == ETHERTYPE_IP ||
	    ntohs(eh->ether_type) == ETHERTYPE_ARP ||
	    ntohs(eh->ether_type) == ETHERTYPE_REVARP ||
	    ntohs(eh->ether_type) == ETHERTYPE_IPV6) {
		bcopy((char *)&eh->ether_dhost,
		    (char *)&tx_frame.wi_addr1, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_shost,
		    (char *)&tx_frame.wi_addr2, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_dhost,
		    (char *)&tx_frame.wi_dst_addr, ETHER_ADDR_LEN);
		bcopy((char *)&eh->ether_shost,
		    (char *)&tx_frame.wi_src_addr, ETHER_ADDR_LEN);

		tx_frame.wi_dat_len = m0->m_pkthdr.len - WI_SNAPHDR_LEN;
		tx_frame.wi_frame_ctl = WI_FTYPE_DATA;
		tx_frame.wi_dat[0] = htons(WI_SNAP_WORD0);
		tx_frame.wi_dat[1] = htons(WI_SNAP_WORD1);
		tx_frame.wi_len = htons(m0->m_pkthdr.len - WI_SNAPHDR_LEN);
		tx_frame.wi_type = eh->ether_type;

		m_copydata(m0, sizeof(struct ether_header),
		    m0->m_pkthdr.len - sizeof(struct ether_header),
		    (caddr_t)&sc->wi_txbuf);

		wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
		    sizeof(struct wi_frame));
		wi_write_data(sc, id, WI_802_11_OFFSET, (caddr_t)&sc->wi_txbuf,
		    (m0->m_pkthdr.len - sizeof(struct ether_header)) + 2);
	} else {
		tx_frame.wi_dat_len = m0->m_pkthdr.len;

		m_copydata(m0, 0, m0->m_pkthdr.len, (caddr_t)&sc->wi_txbuf);

		wi_write_data(sc, id, 0, (caddr_t)&tx_frame,
		    sizeof(struct wi_frame));
		wi_write_data(sc, id, WI_802_3_OFFSET, (caddr_t)&sc->wi_txbuf,
		    m0->m_pkthdr.len + 2);
	}

#if NBPFILTER > 0
	/*
	 * If there's a BPF listner, bounce a copy of
	 * this frame to him.
	 */
	if (ifp->if_bpf)
		BPF_MTAP(ifp, m0);
#endif

	m_freem(m0);

	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id))
		printf(WI_PRT_FMT ": xmit failed\n", WI_PRT_ARG(sc));

	ifp->if_flags |= IFF_OACTIVE;

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	return;
}

STATIC int
wi_mgmt_xmit(sc, data, len)
	struct wi_softc		*sc;
	caddr_t			data;
	int			len;
{
	struct wi_frame		tx_frame;
	int			id;
	struct wi_80211_hdr	*hdr;
	caddr_t			dptr;

	if (sc->wi_gone)
		return(ENODEV);

	hdr = (struct wi_80211_hdr *)data;
	dptr = data + sizeof(struct wi_80211_hdr);

	bzero((char *)&tx_frame, sizeof(tx_frame));
	id = sc->wi_tx_mgmt_id;

	bcopy((char *)hdr, (char *)&tx_frame.wi_frame_ctl,
	   sizeof(struct wi_80211_hdr));

	tx_frame.wi_dat_len = len - WI_SNAPHDR_LEN;
	tx_frame.wi_len = htons(len - WI_SNAPHDR_LEN);

	wi_write_data(sc, id, 0, (caddr_t)&tx_frame, sizeof(struct wi_frame));
	wi_write_data(sc, id, WI_802_11_OFFSET_RAW, dptr,
	    (len - sizeof(struct wi_80211_hdr)) + 2);

	if (wi_cmd(sc, WI_CMD_TX|WI_RECLAIM, id)) {
		printf(WI_PRT_FMT ": xmit failed\n", WI_PRT_ARG(sc));
		return(EIO);
	}

	return(0);
}

STATIC void
wi_stop(sc)
	struct wi_softc		*sc;
{
	struct ifnet		*ifp;

	if (sc->wi_gone)
		return;

	DPRINTF(WID_STOP, ("wi_stop: sc %p\n", sc));

	ifp = &sc->arpcom.ac_if;

	CSR_WRITE_2(sc, WI_INT_EN, 0);
	wi_cmd(sc, WI_CMD_DISABLE|sc->wi_portnum, 0);

	timeout_del(&sc->sc_timo);

	ifp->if_flags &= ~(IFF_RUNNING|IFF_OACTIVE);

	return;
}

STATIC void
wi_watchdog(ifp)
	struct ifnet		*ifp;
{
	struct wi_softc		*sc;

	sc = ifp->if_softc;

	printf(WI_PRT_FMT ": device timeout\n", WI_PRT_ARG(sc));

	wi_init(sc);

	ifp->if_oerrors++;

	return;
}

STATIC void
wi_shutdown(arg)
	void			*arg;
{
	struct wi_softc		*sc;

	sc = arg;
	wi_stop(sc);

	return;
}
@


1.32
log
@if we are prism2 print so
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.31 2001/04/23 20:52:35 millert Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.31 2001/04/23 20:52:35 millert Exp $";
@


1.31
log
@The Linksys WPC11 uses the Lucent Wavelan vendor and product IDs but
it is a Prism2 card.  We add fake entries in pcmciadevs and the
wi_pcmcia_product list so that it gets treated as Prism2.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $";
d415 2
a416 1
	printf(": address %s", ether_sprintf(sc->arpcom.ac_enaddr));
@


1.30
log
@addtron card has prism2 in it, it's justthat cis was not given properly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.29 2001/04/08 15:45:50 mickey Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.29 2001/04/08 15:45:50 mickey Exp $";
d291 6
@


1.29
log
@correct wi_write_record(); from freebsd; pointed out by Alfred Perlstein <bright@@wintelcom.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.28 2001/04/04 20:13:11 mickey Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.28 2001/04/04 20:13:11 mickey Exp $";
d275 3
a277 3
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NTT_ME_WLAN,
d279 1
a279 1
	  0 },
@


1.28
log
@match on a few more cards, prism2 support; aaron@@ ok; from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.27 2001/03/19 20:24:59 niklas Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.27 2001/03/19 20:24:59 niklas Exp $";
d959 1
a959 1
	struct wi_ltv_gen	*oltv;
d962 1
a962 1
		switch (oltv->wi_type) {
a963 1
		case WI_RID_CUR_TX_RATE:
d965 8
a972 8
			case 1: oltv->wi_val = 1; break;
			case 2: oltv->wi_val = 2; break;
			case 3:	oltv->wi_val = 6; break;
			case 4: oltv->wi_val = 5; break;
			case 7: oltv->wi_val = 7; break;
			case 8: oltv->wi_val = 11; break;
			case 15: oltv->wi_val = 3; break;
			default: oltv->wi_val = 0x100 + ltv->wi_val; break;
d974 1
d977 2
a978 1
			oltv->wi_len = 2;
d980 1
a980 1
				oltv->wi_val = 1;
d982 2
a983 1
				oltv->wi_val = 0;
d986 4
a989 2
			oltv->wi_len = 2;
			oltv->wi_val = ltv->wi_val;
d991 16
@


1.27
log
@DELAY(1) is nicer than DELAY(10), multiply loop counter by 10 due to that.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.26 2001/03/19 20:13:43 niklas Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.26 2001/03/19 20:13:43 niklas Exp $";
d184 151
d342 3
a344 18
	if (pa->pf->function != PCMCIA_FUNCTION_NETWORK)
		return (0);

	switch (pa->manufacturer) {
	case PCMCIA_VENDOR_LUCENT:
		/* XXX Per-productid checking here. */
		return (1);

	case PCMCIA_VENDOR_ELSA:
		switch (pa->product) {
		case PCMCIA_PRODUCT_ELSA_XI300_IEEE:
			return (1);
		}
		return (0);

	default:
		return (0);
	}
d356 1
d389 7
d871 17
d917 29
d959 30
@


1.26
log
@Sniffed glue.  Reinstate Mickey's time-bound loops but fix
the race in wi_inquire that made them stall machines for up to 500ms.
Also lower the maximum wait-time for commands to 50ms, and check for
actually timed out commands in wi_inquire.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.24 2001/03/11 08:41:28 mickey Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.24 2001/03/11 08:41:28 mickey Exp $";
d674 1
a674 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d812 1
a812 1
	for (i = WI_TIMEOUT; i--; DELAY(10))
d908 1
a908 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
@


1.25
log
@mickey has been sniffing glue
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.23 2001/02/20 19:39:46 mickey Exp $	*/
d53 1
a53 1
 * publically available version of the HCF library (the 'HCF Light') is 
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.23 2001/02/20 19:39:46 mickey Exp $";
d190 1
a190 1
	
d603 1
d614 6
a619 1
	wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);
d674 1
a674 1
	for (i = 0; i < WI_TIMEOUT; i++) {
d694 1
a694 1
	if (i == WI_TIMEOUT)
d812 1
a812 1
	for (i = 0; i < WI_TIMEOUT; i++) {
a814 1
	}
d816 1
a816 1
	if (i == WI_TIMEOUT)
d908 1
a908 1
	for (i = 0; i < WI_TIMEOUT; i++) {
d913 1
a913 1
	if (i == WI_TIMEOUT)
d991 1
a991 1
		      ETHER_ADDR_LEN);
d1076 1
a1076 1
			     command, data));
d1136 1
a1136 1
                         * accordingly.
d1154 1
a1154 1
			    		sizeof(struct wi_ltv_keys));
d1157 1
a1157 1
			    		sizeof(struct wi_ltv_keys));
d1438 1
a1438 1
STATIC void 
@


1.24
log
@make those loops time-bound, space police
@
text
@d53 1
a53 1
 * publically available version of the HCF library (the 'HCF Light') is
d190 1
a190 1

d668 1
a668 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d688 1
a688 1
	if (i < 0)
d806 1
a806 1
	for (i = WI_TIMEOUT; i--; DELAY(10))
d809 1
d811 1
a811 1
	if (i < 0)
d903 1
a903 1
	for (i = WI_TIMEOUT; i--; DELAY(10)) {
d908 1
a908 1
	if (i < 0)
d986 1
a986 1
		    ETHER_ADDR_LEN);
d1071 1
a1071 1
	    command, data));
d1131 1
a1131 1
			 * accordingly.
d1149 1
a1149 1
					sizeof(struct wi_ltv_keys));
d1152 1
a1152 1
					sizeof(struct wi_ltv_keys));
d1433 1
a1433 1
STATIC void
@


1.23
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.22 2001/01/17 04:54:47 aaron Exp $	*/
d53 1
a53 1
 * publically available version of the HCF library (the 'HCF Light') is 
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.22 2001/01/17 04:54:47 aaron Exp $";
d190 1
a190 1
	
d668 1
a668 1
	for (i = 0; i < WI_TIMEOUT; i++) {
d688 1
a688 1
	if (i == WI_TIMEOUT)
d806 1
a806 1
	for (i = 0; i < WI_TIMEOUT; i++) {
a808 1
	}
d810 1
a810 1
	if (i == WI_TIMEOUT)
d902 1
a902 1
	for (i = 0; i < WI_TIMEOUT; i++) {
d907 1
a907 1
	if (i == WI_TIMEOUT)
d985 1
a985 1
		      ETHER_ADDR_LEN);
d1070 1
a1070 1
			     command, data));
d1130 1
a1130 1
                         * accordingly.
d1148 1
a1148 1
			    		sizeof(struct wi_ltv_keys));
d1151 1
a1151 1
			    		sizeof(struct wi_ltv_keys));
d1432 1
a1432 1
STATIC void 
@


1.22
log
@Fix breakage from revision 1.20 that freaked my WaveLAN out.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.21 2001/01/16 20:18:33 mickey Exp $	*/
d112 1
a112 1
#define BPFATTACH(if_bpf,if,dlt,sz) bpfattach((if_bpf), (if), (dlt), (sz))
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.21 2001/01/16 20:18:33 mickey Exp $";
@


1.21
log
@match on elsa xi300; from netbsd, no other visible changes in the driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.20 2001/01/14 23:11:10 angelos Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.20 2001/01/14 23:11:10 angelos Exp $";
d938 1
a938 1
	mcast.wi_len = (ETHER_ADDR_LEN * 16) + 1;
@


1.20
log
@Run wi_init() after setting/unsetting IFF_PROMISC (or any other flags,
for that matter).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.19 2001/01/11 06:45:25 angelos Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.19 2001/01/11 06:45:25 angelos Exp $";
d198 7
@


1.19
log
@Newline at end of debug printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.18 2001/01/10 17:43:38 angelos Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.18 2001/01/10 17:43:38 angelos Exp $";
d931 1
a931 1
	mcast.wi_len = (3 * 16) + 1;
d1105 2
a1106 2
			} else
				wi_init(sc);
@


1.18
log
@BSS mode by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.17 2000/11/08 14:25:24 art Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.17 2000/11/08 14:25:24 art Exp $";
d1063 2
a1064 1
	DPRINTF (WID_IOCTL, ("wi_ioctl: command %lu data %p", command, data));
@


1.17
log
@Initialize the timeout in attach, not wi_init.
The difference is that we do not risk reinitializing a pending timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.16 2000/09/17 19:10:55 provos Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.16 2000/09/17 19:10:55 provos Exp $";
d283 1
a283 1
	sc->wi_ptype = WI_PORTTYPE_ADHOC;
@


1.16
log
@implement SIOCSIFMTU, okay deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.15 2000/06/30 01:04:28 art Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.15 2000/06/30 01:04:28 art Exp $";
d310 1
a1286 1
	timeout_set(&sc->sc_timo, wi_inquire, sc);
@


1.15
log
@Convert to use new timeout API.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.14 2000/06/20 07:24:36 todd Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.14 2000/06/20 07:24:36 todd Exp $";
d1082 8
@


1.14
log
@KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.13 2000/06/19 00:12:41 aaron Exp $	*/
a110 2
#define TIMEOUT(handle,func,arg,time) timeout((func), (arg), (time))
#define UNTIMEOUT(func,arg,handle) untimeout((func), (arg))
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.13 2000/06/19 00:12:41 aaron Exp $";
d599 1
a599 1
	TIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);
d1278 2
a1279 1
	TIMEOUT(sc->wi_stat_ch, wi_inquire, sc, hz * 60);
d1433 1
a1433 1
	UNTIMEOUT(wi_inquire, sc, sc->wi_stat_ch);
@


1.13
log
@Insert missing splx(); me and roberto@@ns2.freenix.org.

Hacking at USENIX 2000 :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.12 2000/06/18 04:02:11 aaron Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.12 2000/06/18 04:02:11 aaron Exp $";
d400 2
a401 1
int wi_intr(vsc)
d465 2
a466 1
STATIC void wi_rxeof(sc)
d571 2
a572 1
STATIC void wi_txeof(sc, status)
d591 2
a592 1
void wi_inquire(xsc)
d612 2
a613 1
void wi_update_stats(sc)
d651 2
a652 1
STATIC int wi_cmd(sc, cmd, val)
d688 2
a689 1
STATIC void wi_reset(sc)
d708 2
a709 1
STATIC int wi_read_record(sc, ltv)
d750 2
a751 1
STATIC int wi_write_record(sc, ltv)
d774 2
a775 1
STATIC int wi_seek(sc, id, off, chan)
d811 2
a812 1
STATIC int wi_read_data(sc, id, off, buf, len)
d843 2
a844 1
STATIC int wi_write_data(sc, id, off, buf, len)
d883 2
a884 1
STATIC int wi_alloc_nicmem(sc, len, id)
d917 2
a918 1
STATIC void wi_setmulti(sc)
d962 2
a963 1
STATIC void wi_setdef(sc, wreq)
d1041 2
a1042 1
STATIC int wi_ioctl(ifp, command, data)
d1175 2
a1176 1
STATIC void wi_init(xsc)
d1285 2
a1286 1
STATIC void wi_start(ifp)
d1380 2
a1381 1
STATIC int wi_mgmt_xmit(sc, data, len)
d1418 2
a1419 1
STATIC void wi_stop(sc)
d1441 2
a1442 1
STATIC void wi_watchdog(ifp)
d1458 2
a1459 1
STATIC void wi_shutdown(arg)
@


1.12
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.11 2000/05/24 06:23:36 itojun Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.11 2000/05/24 06:23:36 itojun Exp $";
d1043 2
a1044 1
	if (sc->wi_gone)
d1046 1
@


1.11
log
@properly configure multicast table.
use RFC1042 encap for IPv6 packet, just like base station does.
(testers wanted - the code works for me just fine on kame/netbsd)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.10 2000/04/24 19:43:36 niklas Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.10 2000/04/24 19:43:36 niklas Exp $";
d1035 1
a1035 1
	struct proc *p = curproc;
@


1.10
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.9 2000/03/27 18:34:58 jason Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.9 2000/03/27 18:34:58 jason Exp $";
d1091 12
a1102 2
		wi_setmulti(sc);
		error = 0;
d1299 2
a1300 1
	    ntohs(eh->ether_type) == ETHERTYPE_REVARP) {
@


1.10.2.1
log
@Pull in patch from current:
Fix (aaron):
Insert missing splx(); me and roberto@@ns2.freenix.org.

Hacking at USENIX 2000 :-)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.10 2000/04/24 19:43:36 niklas Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.10 2000/04/24 19:43:36 niklas Exp $";
d1043 1
a1043 2
	if (sc->wi_gone) {
		splx(s);
a1044 1
	}
@


1.9
log
@don't include rcsid in compile
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.8 2000/02/03 00:56:45 angelos Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.8 2000/02/03 00:56:45 angelos Exp $";
d392 1
a393 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
@


1.8
log
@WEP support -- from FreeBSD (wpaul)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.7 2000/02/02 18:47:02 deraadt Exp $	*/
d136 1
a136 1
#if !defined(lint)
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.7 2000/02/02 18:47:02 deraadt Exp $";
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $	*/
d53 1
a53 1
 * publically available version of the HCF library (the 'HCF Light') is
d111 2
d114 1
a114 1
#define BPFATTACH(if_bpf,if,dlt,sz)
d136 1
a136 1
#if !defined(lint) && !defined(__OpenBSD__)
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.30 2001/04/08 21:44:36 mickey Exp $";
a185 151
static const struct wi_pcmcia_product {
	u_int32_t	pp_vendor;
	u_int32_t	pp_product;
	const char	*pp_cisinfo[4];
	const char	*pp_name;
	int		pp_prism2;
} wi_pcmcia_products[] = {
	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_LUCENT_WAVELAN_IEEE,
	  "WaveLAN/IEEE",
	  0 },

	{ PCMCIA_VENDOR_3COM,
	  PCMCIA_PRODUCT_3COM_3CRWE737A,
	  PCMCIA_CIS_3COM_3CRWE737A,
	  "3Com AirConnect Wireless LAN",
	  1 },

	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCC_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCC_11,
	  "Corega Wireless LAN PCC-11",
	  1 },

	{ PCMCIA_VENDOR_COREGA,
	  PCMCIA_PRODUCT_COREGA_WIRELESS_LAN_PCCA_11,
	  PCMCIA_CIS_COREGA_WIRELESS_LAN_PCCA_11,
	  "Corega Wireless LAN PCCA-11",
	  1 },

	{ PCMCIA_VENDOR_INTERSIL,
	  PCMCIA_PRODUCT_INTERSIL_PRISM2,
	  PCMCIA_CIS_INTERSIL_PRISM2,
	  "Intersil Prism II",
	  1 },

	{ PCMCIA_VENDOR_SAMSUNG,
	  PCMCIA_PRODUCT_SAMSUNG_SWL_2000N,
	  PCMCIA_CIS_SAMSUNG_SWL_2000N,
	  "Samsung MagicLAN SWL-2000N",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_SMC_2632W,
	  "SMC 2632 EZ Connect Wireless PC Card",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NANOSPEED_PRISM2,
	  "NANOSPEED ROOT-RZ2000 WLAN Card",
	  1 },

	{ PCMCIA_VENDOR_ELSA,
	  PCMCIA_PRODUCT_ELSA_XI300_IEEE,
	  PCMCIA_CIS_ELSA_XI300_IEEE,
	  "XI300 Wireless LAN",
	  1 },

	{ PCMCIA_VENDOR_COMPAQ,
	  PCMCIA_PRODUCT_COMPAQ_NC5004,
	  PCMCIA_CIS_COMPAQ_NC5004,
	  "Compaq Agency NC5004 Wireless Card",
	  1 },

	{ PCMCIA_VENDOR_CONTEC,
	  PCMCIA_PRODUCT_CONTEC_FX_DS110_PCC,
	  PCMCIA_CIS_CONTEC_FX_DS110_PCC,
	  "Contec FLEXLAN/FX-DS110-PCC",
	  1 },

	{ PCMCIA_VENDOR_TDK,
	  PCMCIA_PRODUCT_TDK_LAK_CD011WL,
	  PCMCIA_CIS_TDK_LAK_CD011WL,
	  "TDK LAK-CD011WL",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NEC_CMZ_RT_WP,
	  "NEC Wireless Card CMZ-RT-WP",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_NTT_ME_WLAN,
	  "NTT-ME 11Mbps Wireless LAN PC Card",
	  1 },

	{ PCMCIA_VENDOR_ADDTRON,
	  PCMCIA_PRODUCT_ADDTRON_AWP100,
	  PCMCIA_CIS_ADDTRON_AWP100,
	  "Addtron AWP-100",
	  1 },

	{ PCMCIA_VENDOR_LUCENT,
	  PCMCIA_PRODUCT_LUCENT_WAVELAN_IEEE,
	  PCMCIA_CIS_CABLETRON_ROAMABOUT,
	  "Cabletron RoamAbout",
	  0 },

	{ PCMCIA_VENDOR_IODATA2,
	  PCMCIA_PRODUCT_IODATA2_WNB11PCM,
	  PCMCIA_CIS_IODATA2_WNB11PCM,
	  "I-O DATA WN-B11/PCM",
	  1 },

	{ 0,
	  0,
	  { NULL, NULL, NULL, NULL },
	  NULL,
	  0 }
};

static const struct wi_pcmcia_product *wi_lookup __P((struct pcmcia_attach_args *pa));

const struct wi_pcmcia_product *
wi_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	const struct wi_pcmcia_product *pp;

	/*
	 * match by CIS information first
	 * XXX: Farallon SkyLINE 11mb uses PRISM II but vendor ID
	 *	and product ID is the same as Lucent WaveLAN
	 */
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
		if (pa->card->cis1_info[0] != NULL &&
		    pp->pp_cisinfo[0] != NULL &&
		    strcmp(pa->card->cis1_info[0], pp->pp_cisinfo[0]) == 0 &&
		    pa->card->cis1_info[1] != NULL &&
		    pp->pp_cisinfo[1] != NULL &&
		    strcmp(pa->card->cis1_info[1], pp->pp_cisinfo[1]) == 0)
			return pp;
	}

	/* match by vendor/product id */
	for (pp = wi_pcmcia_products; pp->pp_name != NULL; pp++) {
		if (pa->manufacturer != PCMCIA_VENDOR_INVALID &&
		    pa->manufacturer == pp->pp_vendor &&
		    pa->product != PCMCIA_PRODUCT_INVALID &&
		    pa->product == pp->pp_product)
			return pp;
	}

	return NULL;
}

d192 3
d196 8
a203 3
	if (wi_lookup(pa) != NULL)
		return 1;
	return 0;
a214 1
	const struct wi_pcmcia_product *pp;
a246 7
	pp = wi_lookup(pa);
	if (pp == NULL) {
		/* should not happen */
		sc->sc_prism2 = 0;
	} else
		sc->sc_prism2 = pp->pp_prism2;

d285 1
a285 1
	sc->wi_ptype = WI_PORTTYPE_BSS;
a311 1
	timeout_set(&sc->sc_timo, wi_inquire, sc);
d392 1
a393 1
		pcmcia_function_disable(sc->sc_pf);
d400 1
a400 2
int
wi_intr(vsc)
d464 1
a464 2
STATIC void
wi_rxeof(sc)
d569 1
a569 2
STATIC void
wi_txeof(sc, status)
d588 1
a588 2
void
wi_inquire(xsc)
a592 1
	int s, rv;
d597 1
a597 1
	timeout_add(&sc->sc_timo, hz * 60);
d603 1
a603 6
	s = splnet();
	rv = wi_cmd(sc, WI_CMD_INQUIRE, WI_INFO_COUNTERS);
	splx(s);
	if (rv)
		printf(WI_PRT_FMT ": wi_cmd failed with %d\n", WI_PRT_ARG(sc),
		    rv);
d608 1
a608 2
void
wi_update_stats(sc)
d646 1
a646 2
STATIC int
wi_cmd(sc, cmd, val)
d656 1
a656 1
	for (i = WI_TIMEOUT; i--; DELAY(1)) {
d676 1
a676 1
	if (i < 0)
d682 1
a682 2
STATIC void
wi_reset(sc)
d701 1
a701 2
STATIC int
wi_read_record(sc, ltv)
a706 17
	struct wi_ltv_gen	*oltv, p2ltv;

	if (sc->sc_prism2) {
		oltv = ltv;
		switch (ltv->wi_type) {
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		}
	}
a735 29
	if (sc->sc_prism2) {
		switch (oltv->wi_type) {
		case WI_RID_TX_RATE:
		case WI_RID_CUR_TX_RATE:
			switch (ltv->wi_val) {
			case 1: oltv->wi_val = 1; break;
			case 2: oltv->wi_val = 2; break;
			case 3:	oltv->wi_val = 6; break;
			case 4: oltv->wi_val = 5; break;
			case 7: oltv->wi_val = 7; break;
			case 8: oltv->wi_val = 11; break;
			case 15: oltv->wi_val = 3; break;
			default: oltv->wi_val = 0x100 + ltv->wi_val; break;
			}
			break;
		case WI_RID_ENCRYPTION:
			oltv->wi_len = 2;
			if (ltv->wi_val & 0x01)
				oltv->wi_val = 1;
			else
				oltv->wi_val = 0;
			break;
		case WI_RID_TX_CRYPT_KEY:
			oltv->wi_len = 2;
			oltv->wi_val = ltv->wi_val;
			break;
		}
	}

d742 1
a742 2
STATIC int
wi_write_record(sc, ltv)
a747 50
	struct wi_ltv_gen	p2ltv;

	if (sc->sc_prism2) {
		switch (ltv->wi_type) {
		case WI_RID_TX_RATE:
			switch (ltv->wi_val) {
			case 1: p2ltv.wi_val = 1; break;
			case 2: p2ltv.wi_val = 2; break;
			case 3:	p2ltv.wi_val = 15; break;
			case 5: p2ltv.wi_val = 4; break;
			case 6: p2ltv.wi_val = 3; break;
			case 7: p2ltv.wi_val = 7; break;
			case 11: p2ltv.wi_val = 8; break;
			default: return EINVAL;
			}
			ltv = &p2ltv;
			break;
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			if (ltv->wi_val & 0x01)
				p2ltv.wi_val = 0x03;
			else
				p2ltv.wi_val = 0x90;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			p2ltv.wi_val = ltv->wi_val;
			ltv = &p2ltv;
			break;
		case WI_RID_DEFLT_CRYPT_KEYS: {
				int error;
				struct wi_ltv_str ws;
				struct wi_ltv_keys *wk = (struct wi_ltv_keys *)ltv;
				for (i = 0; i < 4; i++) {
					ws.wi_len = 4;
					ws.wi_type = WI_RID_P2_CRYPT_KEY0 + i;
					memcpy(ws.wi_str, &wk->wi_keys[i].wi_keydat, 5);
					ws.wi_str[5] = '\0';
					error = wi_write_record(sc,
					    (struct wi_ltv_gen *)&ws);
					if (error)
						return (error);
				}
			}
			return (0);
		}
	}
d765 1
a765 2
STATIC int
wi_seek(sc, id, off, chan)
d790 1
a790 1
	for (i = WI_TIMEOUT; i--; DELAY(1))
d793 1
d795 1
a795 1
	if (i < 0)
d801 1
a801 2
STATIC int
wi_read_data(sc, id, off, buf, len)
d832 1
a832 2
STATIC int
wi_write_data(sc, id, off, buf, len)
d871 1
a871 2
STATIC int
wi_alloc_nicmem(sc, len, id)
d884 1
a884 1
	for (i = WI_TIMEOUT; i--; DELAY(1)) {
d889 1
a889 1
	if (i < 0)
d904 1
a904 2
STATIC void
wi_setmulti(sc)
d918 1
a918 1
	mcast.wi_len = ((ETHER_ADDR_LEN / 2) * 16) + 1;
d948 1
a948 2
STATIC void
wi_setdef(sc, wreq)
d965 1
a965 1
		    ETHER_ADDR_LEN);
d1026 1
a1026 2
STATIC int
wi_ioctl(ifp, command, data)
d1035 1
a1035 1
	struct proc		*p = curproc;
d1043 1
a1043 2
	if (sc->wi_gone) {
		splx(s);
a1044 1
	}
d1046 1
a1046 2
	DPRINTF (WID_IOCTL, ("wi_ioctl: command %lu data %p\n",
	    command, data));
a1068 8
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
			error = EINVAL;
		} else if (ifp->if_mtu != ifr->ifr_mtu) {
			ifp->if_mtu = ifr->ifr_mtu;
		}
		break;

d1079 2
a1080 2
			}
			wi_init(sc);
d1091 2
a1092 12
		/* Update our multicast list. */
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			wi_setmulti(sc);
			error = 0;
		}
d1106 1
a1106 1
					sizeof(struct wi_ltv_keys));
d1109 1
a1109 1
					sizeof(struct wi_ltv_keys));
d1147 1
a1147 2
STATIC void
wi_init(xsc)
d1251 1
a1251 1
	timeout_add(&sc->sc_timo, hz * 60);
d1256 1
a1256 2
STATIC void
wi_start(ifp)
d1289 1
a1289 2
	    ntohs(eh->ether_type) == ETHERTYPE_REVARP ||
	    ntohs(eh->ether_type) == ETHERTYPE_IPV6) {
d1349 1
a1349 2
STATIC int
wi_mgmt_xmit(sc, data, len)
d1386 1
a1386 2
STATIC void
wi_stop(sc)
d1401 1
a1401 1
	timeout_del(&sc->sc_timo);
d1408 1
a1408 2
STATIC void
wi_watchdog(ifp)
d1424 1
a1424 2
STATIC void
wi_shutdown(arg)
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.8.2.1 2001/05/14 22:26:07 niklas Exp $	*/
d136 1
a136 1
	"$OpenBSD: if_wi.c,v 1.8.2.1 2001/05/14 22:26:07 niklas Exp $";
@


1.7
log
@make the activate routines do xxstop() and xxinit()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.6 1999/12/16 04:51:30 angelos Exp $	*/
d138 1
a138 1
	"$OpenBSD: if_wi.c,v 1.6 1999/12/16 04:51:30 angelos Exp $";
d305 8
d1006 10
d1102 8
d1210 9
@


1.6
log
@Get the index in the ifnet_addrs array right (as if_index is
pre-incremented on assignment in net/if.c)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.5 1999/12/15 21:49:07 angelos Exp $	*/
a72 4
#ifdef __FreeBSD__
#include "card.h"
#include "wi.h"
#endif	/* __FreeBSD__ */
a81 1
#ifndef __FreeBSD__
a82 1
#endif	/* !__FreeBSD__ */
a84 4
#ifdef __FreeBSD__
#include <net/if_arp.h>
#include <net/ethernet.h>
#endif	/* __FreeBSD__ */
a100 5
#ifdef __FreeBSD__
#include <machine/clock.h>
#include <machine/md_var.h>
#include <machine/bus_pio.h>
#endif	/* __FreeBSD__ */
a104 24
#ifdef __FreeBSD__

#include <i386/isa/isa_device.h>
#include <i386/isa/if_wireg.h>
#include <machine/if_wavelan_ieee.h>

#if NCARD > 0
#include <sys/select.h>
#include <pccard/cardinfo.h>
#include <pccard/slot.h>
#endif	/* NCARD > 0 */

static struct wi_softc wi_softc[NWI];

#define TIMEOUT(handle,func,arg,time) (handle) = timeout((func), (arg), (time))
#define UNTIMEOUT(func,arg,handle) untimeout((func), (arg), (handle))
#define BPF_MTAP(if,mbuf) bpf_mtap((if), (mbuf))
#define BPFATTACH(if_bpf,if,dlt,sz) bpfattach((if), (dlt), (sz))
#define STATIC static
#define WI_PRT_FMT "wi%d"
#define WI_PRT_ARG(sc) (sc)->wi_unit

#else	/* !__FreeBSD__ */

a118 2
#endif	/* __FreeBSD__ */

d138 1
a138 5
#ifdef __FreeBSD__
	"$Id: if_wi.c,v 1.5 1999/12/15 21:49:07 angelos Exp $";
#else	/* !__FreeBSD__ */
	"$OpenBSD: if_wi.c,v 1.5 1999/12/15 21:49:07 angelos Exp $";
#endif	/* __FreeBSD__ */
a150 3
#ifdef __FreeBSD__
STATIC void wi_shutdown		__P((int, void *));
#else	/* !__FreeBSD__ */
a151 1
#endif	/* __FreeBSD__ */
d170 5
a174 236
#ifdef __FreeBSD__

STATIC int wi_probe		__P((struct isa_device *));
STATIC int wi_attach		__P((struct isa_device *));
#ifdef PCCARD_MODULE
static ointhand2_t		wi_intr;
#else
void wi_intr			__P((int));
#endif	/* PCCARD_MODULE */

struct isa_driver widriver = {
	wi_probe,
	wi_attach,
	"wi",
	1
};

#if NCARD > 0
STATIC int wi_pccard_init	__P((struct pccard_devinfo *));
STATIC void wi_pccard_unload	__P((struct pccard_devinfo *));
STATIC int wi_pccard_intr	__P((struct pccard_devinfo *));

#ifdef PCCARD_MODULE
PCCARD_MODULE(wi, wi_pccard_init, wi_pccard_unload,
		wi_pccard_intr, 0, net_imask);
#else
static struct pccard_device wi_info = {
	"wi",
	wi_pccard_init,
	wi_pccard_unload,
	wi_pccard_intr,
	0,			/* Attributes - presently unused */
	&net_imask		/* Interrupt mask for device */
				/* XXX - Should this also include net_imask? */
};

DATA_SET(pccarddrv_set, wi_info);
#endif

/* Initialize the PCCARD. */
STATIC int wi_pccard_init(sc_p)
	struct pccard_devinfo	*sc_p;
{
	struct wi_softc		*sc;
	int			i;
	u_int32_t		irq;

	if (sc_p->isahd.id_unit >= NWI)
		return(ENODEV);

	sc = &wi_softc[sc_p->isahd.id_unit];
	sc->wi_gone = 0;
	sc->wi_unit = sc_p->isahd.id_unit;
	sc->wi_bhandle = sc_p->isahd.id_iobase;
	sc->wi_btag = I386_BUS_SPACE_IO;

	/* Make sure interrupts are disabled. */
	CSR_WRITE_2(sc, WI_INT_EN, 0);
	CSR_WRITE_2(sc, WI_EVENT_ACK, 0xFFFF);

	/* Grr. IRQ is encoded as a bitmask. */
	irq = sc_p->isahd.id_irq;
	for (i = 0; i < 32; i++) {
		if (irq & 0x1)
			break;
		irq >>= 1;
	}

	/*
	 * Print a nice probe message to let the operator
	 * know something interesting is happening.
	 */
	printf("wi%d: <WaveLAN/IEEE 802.11> at 0x%x-0x%x irq %d on isa\n",
	    sc_p->isahd.id_unit, sc_p->isahd.id_iobase,
	    sc_p->isahd.id_iobase + WI_IOSIZ - 1, i);

	if (wi_attach(&sc_p->isahd))
		return(ENXIO);

	return(0);
}

STATIC void wi_pccard_unload(sc_p)
	struct pccard_devinfo	*sc_p;
{
	struct wi_softc		*sc;
	struct ifnet		*ifp;

	sc = &wi_softc[sc_p->isahd.id_unit];
	ifp = &sc->arpcom.ac_if;

	if (sc->wi_gone) {
		printf("wi%d: already unloaded\n", sc_p->isahd.id_unit);
		return;
	}

	ifp->if_flags &= ~IFF_RUNNING;
	if_down(ifp);
	sc->wi_gone = 1;
	printf("wi%d: unloaded\n", sc_p->isahd.id_unit);

	return;
}

STATIC int wi_pccard_intr(sc_p)
	struct pccard_devinfo	*sc_p;
{
	wi_intr(sc_p->isahd.id_unit);
	return(1);
}

#endif

STATIC int wi_probe(isa_dev)
	struct isa_device	*isa_dev;
{
	/*
	 * The ISA WaveLAN/IEEE card is actually not an ISA card:
	 * it's a PCMCIA card plugged into a PCMCIA bridge adapter
	 * that fits into an ISA slot. Consequently, we will always
	 * be using the pccard support to probe and attach these
	 * devices, so we can never actually probe one from here.
	 */
	return(0);
}

STATIC int wi_attach(isa_dev)
	struct isa_device	*isa_dev;
{
	struct wi_softc		*sc;
	struct wi_ltv_macaddr	mac;
	struct wi_ltv_gen	gen;
	struct ifnet		*ifp;
	char			ifname[IFNAMSIZ];

#ifdef PCCARD_MODULE
	isa_dev->id_ointr = wi_intr;
#endif
	sc = &wi_softc[isa_dev->id_unit];
	ifp = &sc->arpcom.ac_if;

	/* Reset the NIC. */
	wi_reset(sc);

	/* Read the station address. */
	mac.wi_type = WI_RID_MAC_NODE;
	mac.wi_len = 4;
	wi_read_record(sc, (struct wi_ltv_gen *)&mac);
	bcopy((char *)&mac.wi_mac_addr,
	   (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	printf("wi%d: Ethernet address: %6D\n", sc->wi_unit,
	    sc->arpcom.ac_enaddr, ":");

	ifp->if_softc = sc;
	ifp->if_unit = sc->wi_unit;
	ifp->if_name = "wi";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = wi_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = wi_start;
	ifp->if_watchdog = wi_watchdog;
	ifp->if_init = wi_init;
	ifp->if_baudrate = 10000000;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	bzero(sc->wi_node_name, sizeof(sc->wi_node_name));
	bcopy(WI_DEFAULT_NODENAME, sc->wi_node_name,
	    sizeof(WI_DEFAULT_NODENAME) - 1);

	bzero(sc->wi_net_name, sizeof(sc->wi_net_name));
	bcopy(WI_DEFAULT_NETNAME, sc->wi_net_name,
	    sizeof(WI_DEFAULT_NETNAME) - 1);

	bzero(sc->wi_ibss_name, sizeof(sc->wi_ibss_name));
	bcopy(WI_DEFAULT_IBSS, sc->wi_ibss_name,
	    sizeof(WI_DEFAULT_IBSS) - 1);

	sc->wi_portnum = WI_DEFAULT_PORT;
	sc->wi_ptype = WI_PORTTYPE_ADHOC;
	sc->wi_ap_density = WI_DEFAULT_AP_DENSITY;
	sc->wi_rts_thresh = WI_DEFAULT_RTS_THRESH;
	sc->wi_tx_rate = WI_DEFAULT_TX_RATE;
	sc->wi_max_data_len = WI_DEFAULT_DATALEN;
	sc->wi_create_ibss = WI_DEFAULT_CREATE_IBSS;
	sc->wi_pm_enabled = WI_DEFAULT_PM_ENABLED;
	sc->wi_max_sleep = WI_DEFAULT_MAX_SLEEP;

	/*
	 * Read the default channel from the NIC. This may vary
	 * depending on the country where the NIC was purchased, so
	 * we can't hard-code a default and expect it to work for
	 * everyone.
	 */
	gen.wi_type = WI_RID_OWN_CHNL;
	gen.wi_len = 2;
	wi_read_record(sc, &gen);
	sc->wi_channel = gen.wi_val;

	bzero((char *)&sc->wi_stats, sizeof(sc->wi_stats));

	wi_init(sc);
	wi_stop(sc);

	/*
	 * If this logical interface has already been attached,
	 * don't attach it again or chaos will ensue.
	 */
	sprintf(ifname, "wi%d", sc->wi_unit);

	if (ifunit(ifname) == NULL) {
		callout_handle_init(&sc->wi_stat_ch);
		/*
		 * Call MI attach routines.
		 */
		if_attach(ifp);
		ether_ifattach(ifp);

#if NBPFILTER > 0
		bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif

		at_shutdown(wi_shutdown, sc, SHUTDOWN_POST_SYNC);
	}

	return(0);
}

#else	/* !__FreeBSD__ */

int	wi_pcmcia_match __P((struct device *, void *, void *));
void	wi_pcmcia_attach __P((struct device *, struct device *, void *));
int	wi_pcmcia_detach __P((struct device *, int));
int	wi_pcmcia_activate __P((struct device *, enum devact));
int	wi_intr __P((void *));
a330 8

#ifdef notyet
	/*
	 * XXX This should be done once the framework has enable/disable hooks.
	 */
	pcmcia_function_disable(pf);
#endif	/* notyet */

d366 1
d373 1
d376 2
d381 3
a390 1
#endif	/* __FreeBSD__ */
a391 6
#ifdef __FreeBSD__
void wi_intr(unit)
	int			unit;
{
	struct wi_softc		*sc = &wi_softc[unit];
#else	/* !__FreeBSD__ */
a395 1
#endif	/* __FreeBSD__ */
a901 3
#ifdef __FreeBSD__
	struct ifmultiaddr	*ifma;
#else
a903 1
#endif
a916 15
#ifdef __FreeBSD__
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
				ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		if (i < 16) {
			bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
			    (char *)&mcast.wi_mcast[i], ETHER_ADDR_LEN);
			i++;
		} else {
			bzero((char *)&mcast, sizeof(mcast));
			break;
		}
	}
#else	/* !__FreeBSD__ */
a932 1
#endif	/* __FreeBSD__ */
a946 1
#ifndef __FreeBSD__
a947 1
#endif	/* !__FreeBSD__ */
a1017 1
#ifndef __FreeBSD__
a1018 1
#endif	/* !__FreeBSD__ */
a1029 1
#ifndef __FreeBSD__
a1033 1
#endif	/* !__FreeBSD__ */
a1035 7
#ifdef __FreeBSD__
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#else	/* !__FreeBSD__ */
a1049 1
#endif	/* __FreeBSD__ */
a1388 4
#ifdef __FreeBSD__
STATIC void wi_shutdown(howto, arg)
	int			howto;
#else	/* !__FreeBSD__ */
a1389 1
#endif	/* __FreeBSD__ */
@


1.5
log
@Require privileges to change card parameters.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.4 1999/10/27 00:58:35 deraadt Exp $	*/
d180 1
a180 1
	"$Id: if_wi.c,v 1.4 1999/10/27 00:58:35 deraadt Exp $";
d182 1
a182 1
	"$OpenBSD: if_wi.c,v 1.4 1999/10/27 00:58:35 deraadt Exp $";
d1264 1
a1264 1
		ifa = ifnet_addrs[ifp->if_index - 1];
d1268 1
a1268 1
		   ETHER_ADDR_LEN);
@


1.4
log
@do not pre-filter bpf packets; jason
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.3 1999/08/13 20:36:38 fgsch Exp $	*/
d84 1
d180 1
a180 1
	"$Id: if_wi.c,v 1.3 1999/08/13 20:36:38 fgsch Exp $";
d182 1
a182 1
	"$OpenBSD: if_wi.c,v 1.3 1999/08/13 20:36:38 fgsch Exp $";
d1328 1
d1416 3
@


1.3
log
@Use macros defined in pcmciavar.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.2 1999/08/08 01:17:23 niklas Exp $	*/
d179 1
a179 1
	"$Id: if_wi.c,v 1.2 1999/08/08 01:17:23 niklas Exp $";
d181 1
a181 1
	"$OpenBSD: if_wi.c,v 1.2 1999/08/08 01:17:23 niklas Exp $";
a598 2
	printf("\n");

d606 1
d838 1
a838 1
	if (ifp->if_bpf) {
a839 7
		if (ifp->if_flags & IFF_PROMISC &&
		    (bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr,
		    ETHER_ADDR_LEN) && (eh->ether_dhost[0] & 1) == 0)) {
			m_freem(m);
			return;
		}
	}
@


1.2
log
@Add detaching support to networking pcmcia cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi.c,v 1.1 1999/07/11 16:25:36 niklas Exp $	*/
d179 1
a179 1
	"$Id: if_wi.c,v 1.1 1999/07/11 16:25:36 niklas Exp $";
d181 1
a181 1
	"$OpenBSD: if_wi.c,v 1.1 1999/07/11 16:25:36 niklas Exp $";
d623 1
a623 2
		pcmcia_chip_io_unmap(pf->sc->pct, pf->sc->pch,
		    sc->sc_io_window);
d625 1
a625 1
		pcmcia_chip_io_free(pf->sc->pct, pf->sc->pch, &sc->sc_pcioh);
@


1.1
log
@WaveLAN driver from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d179 1
a179 1
	"$Id: if_wi.c,v 1.7 1999/07/04 14:40:22 wpaul Exp $";
d181 1
a181 1
	"$OpenBSD$";
d451 2
d461 2
a462 1
	sizeof (struct wi_softc), wi_pcmcia_match, wi_pcmcia_attach
a493 1
	struct pcmcia_io_handle	pcioh;
d498 2
a499 1
	int			io_window;
d509 1
a509 1
	if (pcmcia_io_alloc(pf, 0, WI_IOSIZ, WI_IOSIZ, &pcioh)) {
d515 2
a516 2
	if (pcmcia_io_map(pf, PCMCIA_WIDTH_IO16, 0, WI_IOSIZ, &pcioh,
	    &io_window)) {
d523 2
a524 2
	sc->wi_btag = pcioh.iot;
	sc->wi_bhandle = pcioh.ioh;
d623 2
a624 1
		pcmcia_chip_io_unmap(pf->sc->pct, pf->sc->pch, io_window);
d626 1
a626 1
		pcmcia_chip_io_free(pf->sc->pct, pf->sc->pch, &pcioh);
d631 42
@

