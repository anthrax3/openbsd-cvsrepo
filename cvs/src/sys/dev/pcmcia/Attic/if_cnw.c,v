head	1.37;
access;
symbols
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.32.0.4
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.24.0.6
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.23.0.4
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.2
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.22.0.6
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.4
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.18.0.2
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.8
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.6
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.4
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.2
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.15.0.6
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.2
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.13.0.2
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.12.0.4
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.10.0.4
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.4
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.6.0.2
	OPENBSD_2_7_BASE:1.6
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.37
date	2016.09.03.16.18.21;	author tedu;	state dead;
branches;
next	1.36;
commitid	n66Gi25TQf2NHQM4;

1.36
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.35;
commitid	QHiEhS9DHyE6oiIr;

1.35
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.34;
commitid	J9apD0jq2AjFmqZc;

1.34
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5gdEnqVoJuTuwdTu;

1.33
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.32;
commitid	SaArro4mM2Ab3ure;

1.32
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.31;
commitid	9ERVupAoYqW4Iok9;

1.31
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.30;
commitid	MVWrtktB46JRxFWT;

1.30
date	2015.05.21.09.36.20;	author mpi;	state Exp;
branches;
next	1.29;
commitid	IzQAc3r8SVdLPh6M;

1.29
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.28;
commitid	0fL6zHGm3fqppVdw;

1.28
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.27;
commitid	hN5bFCE56DrAjl99;

1.27
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.25;
commitid	yM2VFFhpDTeFQlve;

1.25
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.24;
commitid	nYggAidK85QbUFh2;

1.24
date	2013.08.07.01.06.39;	author bluhm;	state Exp;
branches;
next	1.23;

1.23
date	2013.02.18.23.29.21;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.30.20.33.18;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2009.03.29.21.53.53;	author sthen;	state Exp;
branches;
next	1.18;

1.18
date	2008.10.03.01.41.40;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.07.20.34.27;	author jmc;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.19.18.36.18;	author jason;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.01;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.06.27.06.34.51;	author kjc;	state Exp;
branches;
next	1.8;

1.8
date	2001.06.25.04.05.50;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.20.19.39.46;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.03.18.47.06;	author angelos;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.02.01.17.39.33;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.01.17.00.04;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.24.07.11.09;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.20.34.17;	author fgsch;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.06;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.43.22;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.5.2.6;

1.5.2.6
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	1.5.2.7;

1.5.2.7
date	2004.06.05.23.12.55;	author niklas;	state Exp;
branches;
next	;

1.10.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2003.05.19.22.19.56;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@remove cnw driver. it was never enabled anywhere except on amd64 (and only
there by accident) where it hasn't seen much use...
@
text
@/*	$OpenBSD: if_cnw.c,v 1.36 2016/04/13 10:49:26 mpi Exp $	*/
/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Michael Eriksson.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This is a driver for the Xircom CreditCard Netwave (also known as
 * the Netwave Airsurfer) wireless LAN PCMCIA adapter.
 *
 * When this driver was developed, the Linux Netwave driver was used
 * as a hardware manual. That driver is Copyright (c) 1997 University
 * of Tromsø, Norway. It is part of the Linux pcmcia-cs package that
 * can be found at http://pcmcia-cs.sourceforge.net/. The most
 * recent version of the pcmcia-cs package when this driver was
 * written was 3.0.6.
 *
 * Unfortunately, a lot of explicit numeric constants were used in the
 * Linux driver. I have tried to use symbolic names whenever possible,
 * but since I don't have any real hardware documentation, there's
 * still one or two "magic numbers" :-(.
 *
 * Driver limitations: This driver doesn't do multicasting or receiver
 * promiscuity, because of missing hardware documentation. I couldn't
 * get receiver promiscuity to work, and I haven't even tried
 * multicast. Volunteers are welcome, of course :-).
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/ioctl.h>

#include <dev/pcmcia/if_cnwreg.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif


/*
 * Let these be patchable variables, initialized from macros that can
 * be set in the kernel config file. Someone with lots of spare time
 * could probably write a nice Netwave configuration program to do
 * this a little bit more elegantly :-).
 */
#ifndef CNW_DOMAIN
#define CNW_DOMAIN	0x100
#endif
int cnw_domain = CNW_DOMAIN;		/* Domain */
#ifndef CNW_SCRAMBLEKEY
#define CNW_SCRAMBLEKEY 0
#endif
int cnw_skey = CNW_SCRAMBLEKEY;		/* Scramble key */


int	cnw_match(struct device *, void *, void *);
void	cnw_attach(struct device *, struct device *, void *);
int	cnw_detach(struct device *, int);
int	cnw_activate(struct device *, int);

struct cnw_softc {
	struct device sc_dev;		    /* Device glue (must be first) */
	struct arpcom sc_arpcom;	    /* Ethernet common part */
	int sc_domain;			    /* Netwave domain */
	int sc_skey;			    /* Netwave scramble key */

	/* PCMCIA-specific stuff */
	struct pcmcia_function *sc_pf;	    /* PCMCIA function */
	struct pcmcia_io_handle sc_pcioh;   /* PCMCIA I/O space handle */
	int sc_iowin;			    /*   ...window */
	bus_space_tag_t sc_iot;		    /*   ...bus_space tag */
	bus_space_handle_t sc_ioh;	    /*   ...bus_space handle */
	struct pcmcia_mem_handle sc_pcmemh; /* PCMCIA memory handle */
	bus_addr_t sc_memoff;		    /*   ...offset */
	int sc_memwin;			    /*   ...window */
	bus_space_tag_t sc_memt;	    /*   ...bus_space tag */
	bus_space_handle_t sc_memh;	    /*   ...bus_space handle */
	void *sc_ih;			    /* Interrupt cookie */
};

struct cfattach cnw_ca = {
	sizeof(struct cnw_softc), cnw_match, cnw_attach,
	cnw_detach, cnw_activate 
};

struct cfdriver cnw_cd = {
	NULL, "cnw", DV_IFNET
};

void cnw_reset(struct cnw_softc *);
void cnw_init(struct cnw_softc *);
int cnw_enable(struct cnw_softc *sc);
void cnw_disable(struct cnw_softc *sc);
void cnw_config(struct cnw_softc *sc, u_int8_t *);
void cnw_start(struct ifnet *);
void cnw_transmit(struct cnw_softc *, struct mbuf *);
struct mbuf *cnw_read(struct cnw_softc *);
void cnw_recv(struct cnw_softc *);
int cnw_intr(void *arg);
int cnw_ioctl(struct ifnet *, u_long, caddr_t);
void cnw_watchdog(struct ifnet *);

/* ---------------------------------------------------------------- */

/* Help routines */
static int wait_WOC(struct cnw_softc *, int);
static int read16(struct cnw_softc *, int);
static int cnw_cmd(struct cnw_softc *, int, int, int, int);

/* 
 * Wait until the WOC (Write Operation Complete) bit in the 
 * ASR (Adapter Status Register) is asserted. 
 */
static int
wait_WOC(sc, line)
	struct cnw_softc *sc;
	int line;
{
	int i, asr;

	for (i = 0; i < 5000; i++) {
		asr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);
		if (asr & CNW_ASR_WOC)
			return (0);
		DELAY(100);
	}
	if (line > 0)
		printf("%s: wedged at line %d\n", sc->sc_dev.dv_xname, line);
	return (1);
}
#define WAIT_WOC(sc) wait_WOC(sc, __LINE__)


/*
 * Read a 16 bit value from the card. 
 */
static int
read16(sc, offset)
	struct cnw_softc *sc;
	int offset;
{
	int hi, lo;

	/* This could presumably be done more efficient with
	 * bus_space_read_2(), but I don't know anything about the
	 * byte sex guarantees... Besides, this is pretty cheap as
	 * well :-)
	 */
	lo = bus_space_read_1(sc->sc_memt, sc->sc_memh,
			      sc->sc_memoff + offset);
	hi = bus_space_read_1(sc->sc_memt, sc->sc_memh,
			      sc->sc_memoff + offset + 1);
	return ((hi << 8) | lo);
}


/*
 * Send a command to the card by writing it to the command buffer.
 */
int
cnw_cmd(sc, cmd, count, arg1, arg2)
	struct cnw_softc *sc;
	int cmd, count, arg1, arg2;
{
	int ptr = sc->sc_memoff + CNW_EREG_CB;

	if (wait_WOC(sc, 0)) {
		printf("%s: wedged when issuing cmd 0x%x\n",
		       sc->sc_dev.dv_xname, cmd);
		/*
		 * We'll continue anyway, as that's probably the best
		 * thing we can do; at least the user knows there's a
		 * problem, and can reset the interface with ifconfig
		 * down/up.
		 */
	}

	bus_space_write_1(sc->sc_memt, sc->sc_memh, ptr, cmd);
	if (count > 0) {
		bus_space_write_1(sc->sc_memt, sc->sc_memh, ptr + 1, arg1);
		if (count > 1)
			bus_space_write_1(sc->sc_memt, sc->sc_memh,
					  ptr + 2, arg2);
	}
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
			  ptr + count + 1, CNW_CMD_EOC);
	return (0);
}
#define CNW_CMD0(sc, cmd) \
		do { cnw_cmd(sc, cmd, 0, 0, 0); } while (0)
#define CNW_CMD1(sc, cmd, arg1)	\
		do { cnw_cmd(sc, cmd, 1, arg1 , 0); } while (0)
#define CNW_CMD2(sc, cmd, arg1, arg2) \
		do { cnw_cmd(sc, cmd, 2, arg1, arg2); } while (0)

/* ---------------------------------------------------------------- */

/*
 * Reset the hardware.
 */
void
cnw_reset(sc)
	struct cnw_softc *sc;
{
#ifdef CNW_DEBUG
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
		printf("%s: resetting\n", sc->sc_dev.dv_xname);
#endif
	wait_WOC(sc, 0);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, CNW_PMR_RESET);
	bus_space_write_1(sc->sc_memt, sc->sc_memh,
			  sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_WOC);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_PMR, 0);
}


/*
 * Initialize the card.
 */
void
cnw_init(sc)
	struct cnw_softc *sc;
{
	/* Reset the card */
	cnw_reset(sc);

	/* Issue a NOP to check the card */
	CNW_CMD0(sc, CNW_CMD_NOP);

	/* Set up receive configuration */
	CNW_CMD1(sc, CNW_CMD_SRC, CNW_RXCONF_RXENA | CNW_RXCONF_BCAST);

	/* Set up transmit configuration */
	CNW_CMD1(sc, CNW_CMD_STC, CNW_TXCONF_TXENA);

	/* Set domain */
	CNW_CMD2(sc, CNW_CMD_SMD, sc->sc_domain, sc->sc_domain >> 8);

	/* Set scramble key */
	CNW_CMD2(sc, CNW_CMD_SSK, sc->sc_skey, sc->sc_skey >> 8);

	/* Enable interrupts */
	WAIT_WOC(sc);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh,
			  CNW_REG_IMR, CNW_IMR_IENA | CNW_IMR_RFU1);

	/* Enable receiver */
	CNW_CMD0(sc, CNW_CMD_ER);

	/* "Set the IENA bit in COR" */
	WAIT_WOC(sc);
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, CNW_REG_COR,
			  CNW_COR_IENA | CNW_COR_LVLREQ);
}


/*
 * Enable and initialize the card.
 */
int
cnw_enable(sc)
	struct cnw_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
	    cnw_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt handler\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}
	if (pcmcia_function_enable(sc->sc_pf) != 0) {
		printf("%s: couldn't enable card\n", sc->sc_dev.dv_xname);
		return (EIO);
	}
	cnw_init(sc);
	ifp->if_flags |= IFF_RUNNING;
	return (0);
}


/*
 * Stop and disable the card.
 */
void
cnw_disable(sc)
	struct cnw_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
	pcmcia_function_disable(sc->sc_pf);
	ifp->if_flags &= ~IFF_RUNNING;
	ifp->if_timer = 0;
}


/*
 * Match the hardware we handle.
 */
int
cnw_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pcmcia_attach_args *pa = aux;

	if (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&
	    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_801)
		return (1);
	if (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&
	    pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW_802)
		return (1);
	return (0);
}


/*
 * Attach the card.
 */
void
cnw_attach(parent, self, aux)
	struct device  *parent, *self;
	void           *aux;
{
	struct cnw_softc *sc = (void *) self;
	struct pcmcia_attach_args *pa = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int i;

	/* Enable the card */
	sc->sc_pf = pa->pf;
	pcmcia_function_init(sc->sc_pf, SIMPLEQ_FIRST(&sc->sc_pf->cfe_head));
	if (pcmcia_function_enable(sc->sc_pf)) {
		printf(": function enable failed\n");
		return;
	}

	/* Map I/O register and "memory" */
	if (pcmcia_io_alloc(sc->sc_pf, 0, CNW_IO_SIZE, CNW_IO_SIZE,
			    &sc->sc_pcioh) != 0) {
		printf(": can't allocate i/o space\n");
		return;
	}
	if (pcmcia_io_map(sc->sc_pf, PCMCIA_WIDTH_IO16, 0,
			  CNW_IO_SIZE, &sc->sc_pcioh, &sc->sc_iowin) != 0) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_iot = sc->sc_pcioh.iot;
	sc->sc_ioh = sc->sc_pcioh.ioh;
	if (pcmcia_mem_alloc(sc->sc_pf, CNW_MEM_SIZE, &sc->sc_pcmemh) != 0) {
		printf(": can't allocate memory\n");
		return;
	}
	if (pcmcia_mem_map(sc->sc_pf, PCMCIA_MEM_COMMON, CNW_MEM_ADDR,
			   CNW_MEM_SIZE, &sc->sc_pcmemh, &sc->sc_memoff,
			   &sc->sc_memwin) != 0) {
		printf(": can't map mem space\n");
		return;
	}
	sc->sc_memt = sc->sc_pcmemh.memt;
	sc->sc_memh = sc->sc_pcmemh.memh;

	/* Finish setup of softc */
	sc->sc_domain = cnw_domain;
	sc->sc_skey = cnw_skey;

	/* Get MAC address */
	cnw_reset(sc);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->sc_arpcom.ac_enaddr[i] = bus_space_read_1(sc->sc_memt,
		    sc->sc_memh, sc->sc_memoff + CNW_EREG_PA + i);
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	       ether_sprintf(sc->sc_arpcom.ac_enaddr));

	/* Set up ifnet structure */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = cnw_start;
	ifp->if_ioctl = cnw_ioctl;
	ifp->if_watchdog = cnw_watchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX;

	/* Attach the interface */
	if_attach(ifp);
	ether_ifattach(ifp);

	if_addgroup(ifp, "wlan");
	ifp->if_priority = IF_WIRELESS_DEFAULT_PRIORITY;

	/* Disable the card now, and turn it on when the interface goes up */
	pcmcia_function_disable(sc->sc_pf);
}

/*
 * Start outputting on the interface.
 */
void
cnw_start(ifp)
	struct ifnet *ifp;
{
	struct cnw_softc *sc = ifp->if_softc;
	struct mbuf *m0;
	int asr;

#ifdef CNW_DEBUG
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
		printf("%s: cnw_start\n", ifp->if_xname);
#endif

	for (;;) {
		/* Is there any buffer space available on the card? */
		WAIT_WOC(sc);
		asr = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);
		if (!(asr & CNW_ASR_TXBA)) {
#ifdef CNW_DEBUG
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("%s: no buffer space\n", ifp->if_xname);
#endif
			return;
		}

		IFQ_DEQUEUE(&ifp->if_snd, m0);
		if (m0 == NULL)
			return;

#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
		
		cnw_transmit(sc, m0);
		++ifp->if_opackets;
		ifp->if_timer = 3; /* start watchdog timer */
	}
}


/*
 * Transmit a packet.
 */
void
cnw_transmit(sc, m0)
	struct cnw_softc *sc;
	struct mbuf *m0;
{
	int buffer, bufsize, bufoffset, bufptr, bufspace, len, mbytes, n;
	struct mbuf *m;
	u_int8_t *mptr;

	/* Get buffer info from card */
	buffer = read16(sc, CNW_EREG_TDP);
	bufsize = read16(sc, CNW_EREG_TDP + 2);
	bufoffset = read16(sc, CNW_EREG_TDP + 4);
#ifdef CNW_DEBUG
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
		printf("%s: cnw_transmit b=0x%x s=%d o=0x%x\n",
		       sc->sc_dev.dv_xname, buffer, bufsize, bufoffset);
#endif

	/* Copy data from mbuf chain to card buffers */
	bufptr = sc->sc_memoff + buffer + bufoffset;
	bufspace = bufsize;
	len = 0;
	for (m = m0; m; ) {
		mptr = mtod(m, u_int8_t *);
		mbytes = m->m_len;
		len += mbytes;
		while (mbytes > 0) {
			if (bufspace == 0) {
				buffer = read16(sc, buffer);
				bufptr = sc->sc_memoff + buffer + bufoffset;
				bufspace = bufsize;
#ifdef CNW_DEBUG
				if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
					printf("%s:   next buffer @@0x%x\n",
					       sc->sc_dev.dv_xname, buffer);
#endif
			}
			n = mbytes <= bufspace ? mbytes : bufspace;
			bus_space_write_region_1(sc->sc_memt, sc->sc_memh,
						 bufptr, mptr, n);
			bufptr += n;
			bufspace -= n;
			mptr += n;
			mbytes -= n;
		}
		m0 = m_free(m);
		m = m0;
	}

	/* Issue transmit command */
	CNW_CMD2(sc, CNW_CMD_TL, len, len >> 8);
}


/*
 * Pull a packet from the card into an mbuf chain.
 */
struct mbuf *
cnw_read(sc)
	struct cnw_softc *sc;
{
	struct mbuf *m, *top, **mp;
	int totbytes, buffer, bufbytes, bufptr, mbytes, n;
	u_int8_t *mptr;

	WAIT_WOC(sc);
	totbytes = read16(sc, CNW_EREG_RDP);
#ifdef CNW_DEBUG
	if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
		printf("%s: recv %d bytes\n", sc->sc_dev.dv_xname, totbytes);
#endif
	buffer = CNW_EREG_RDP + 2;
	bufbytes = 0;
	bufptr = 0; /* XXX make gcc happy */

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (0);
	m->m_pkthdr.len = totbytes;
	mbytes = MHLEN;
	top = 0;
	mp = &top;

	while (totbytes > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (0);
			}
			mbytes = MLEN;
		}
		if (totbytes >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if ((m->m_flags & M_EXT) == 0) {
				m_free(m);
				m_freem(top);
				return (0);
			}
			mbytes = MCLBYTES;
		}
		if (!top) {
			int pad =
			    ALIGN(sizeof(struct ether_header)) -
			        sizeof(struct ether_header);
			m->m_data += pad;
			mbytes -= pad;
		}
		mptr = mtod(m, u_int8_t *);
		mbytes = m->m_len = min(totbytes, mbytes);
		totbytes -= mbytes;
		while (mbytes > 0) {
			if (bufbytes == 0) {
				buffer = read16(sc, buffer);
				bufbytes = read16(sc, buffer + 2);
				bufptr = sc->sc_memoff + buffer +
					read16(sc, buffer + 4);
#ifdef CNW_DEBUG
				if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
					printf("%s:   %d bytes @@0x%x+0x%x\n",
					       sc->sc_dev.dv_xname, bufbytes,
					       buffer, bufptr - buffer -
					       sc->sc_memoff);
#endif
			}
			n = mbytes <= bufbytes ? mbytes : bufbytes;
			bus_space_read_region_1(sc->sc_memt, sc->sc_memh,
						bufptr, mptr, n);
			bufbytes -= n;
			bufptr += n;
			mbytes -= n;
			mptr += n;
		}
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}


/*
 * Handle received packets.
 */
void
cnw_recv(sc)
	struct cnw_softc *sc;
{
	int rser;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	for (;;) {
		WAIT_WOC(sc);
		rser = bus_space_read_1(sc->sc_memt, sc->sc_memh,
					sc->sc_memoff + CNW_EREG_RSER);
		if (!(rser & CNW_RSER_RXAVAIL))
			break;

		/* Pull packet off card */
		m = cnw_read(sc);

		/* Acknowledge packet */
		CNW_CMD0(sc, CNW_CMD_SRP);

		/* Did we manage to get the packet from the interface? */
		if (m == NULL) {
			++ifp->if_ierrors;
			break;
		}
		ml_enqueue(&ml, m);
	}

	if_input(ifp, &ml);
}


/*
 * Interrupt handler.
 */
int
cnw_intr(arg)
	void *arg;
{
	struct cnw_softc *sc = arg;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int ret, status, rser, tser;

	if (!(sc->sc_arpcom.ac_if.if_flags & IFF_RUNNING))
		return (0);
	ifp->if_timer = 0;	/* stop watchdog timer */

	ret = 0;
	for (;;) {
		WAIT_WOC(sc);
		if (!(bus_space_read_1(sc->sc_iot, sc->sc_ioh,
				       CNW_REG_CCSR) & 0x02)) {
			if (ret == 0)
				printf("%s: spurious interrupt\n",
				       sc->sc_dev.dv_xname);
			return (ret);
		}
		ret = 1;
		status = bus_space_read_1(sc->sc_iot, sc->sc_ioh, CNW_REG_ASR);

		/* Anything to receive? */
		if (status & CNW_ASR_RXRDY)
			cnw_recv(sc);

		/* Receive error */
		if (status & CNW_ASR_RXERR) {
			/*
			 * I get a *lot* of spurious receive errors
			 * (many per second), even when the interface
			 * is quiescent, so we don't increment
			 * if_ierrors here.
			 */
			rser = bus_space_read_1(sc->sc_memt, sc->sc_memh,
						sc->sc_memoff + CNW_EREG_RSER);
			/* Clear error bits in RSER */
			WAIT_WOC(sc);
			bus_space_write_1(sc->sc_memt, sc->sc_memh,
				sc->sc_memoff + CNW_EREG_RSERW,
				CNW_RSER_RXERR |
				(rser & (CNW_RSER_RXCRC | CNW_RSER_RXBIG)));
			/* Clear RXERR in ASR */
			WAIT_WOC(sc);
			bus_space_write_1(sc->sc_memt, sc->sc_memh,
				sc->sc_memoff + CNW_EREG_ASCC, CNW_ASR_RXERR);
		}

		/* Transmit done */
		if (status & CNW_ASR_TXDN) {
			tser = bus_space_read_1(sc->sc_memt, sc->sc_memh,
						CNW_EREG_TSER);
			if (tser & CNW_TSER_TXOK) {
				WAIT_WOC(sc);
				bus_space_write_1(sc->sc_memt, sc->sc_memh,
					sc->sc_memoff + CNW_EREG_TSERW,
					CNW_TSER_TXOK | CNW_TSER_RTRY);
			}
			if (tser & CNW_TSER_ERROR) {
				++ifp->if_oerrors;
				WAIT_WOC(sc);
				bus_space_write_1(sc->sc_memt, sc->sc_memh,
					sc->sc_memoff + CNW_EREG_TSERW,
					(tser & CNW_TSER_ERROR) |
					CNW_TSER_RTRY);
			}
			/* Continue to send packets from the queue */
			cnw_start(&sc->sc_arpcom.ac_if);
		}
				
	}
}


/*
 * Handle device ioctls.
 */
int
cnw_ioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct cnw_softc *sc = ifp->if_softc;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		if (!(ifp->if_flags & IFF_RUNNING) &&
		    (error = cnw_enable(sc)) != 0)
			break;
		ifp->if_flags |= IFF_UP;
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_RUNNING) {
			/*
			 * The interface is marked down and it is running, so
			 * stop it.
			 */
			cnw_disable(sc);
		} else if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == IFF_UP){
			/*
			 * The interface is marked up and it is stopped, so
			 * start it.
			 */
			error = cnw_enable(sc);
		}
		break;

	default:
		error = ENOTTY;
		break;
	}

	splx(s);
	return (error);
}


/*
 * Device timeout/watchdog routine. Entered if the device neglects to
 * generate an interrupt after a transmit has been started on it.
 */
void
cnw_watchdog(ifp)
	struct ifnet *ifp;
{
	struct cnw_softc *sc = ifp->if_softc;

	printf("%s: device timeout; card reset\n", sc->sc_dev.dv_xname);
	++ifp->if_oerrors;
	cnw_init(sc);
}


int
cnw_detach(dev, flags)
	struct device *dev;
	int flags;
{
	struct cnw_softc *sc = (struct cnw_softc *)dev;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int rv = 0;

	pcmcia_io_unmap(sc->sc_pf, sc->sc_iowin);
	pcmcia_io_free(sc->sc_pf, &sc->sc_pcioh);
	pcmcia_mem_unmap(sc->sc_pf, sc->sc_memwin);
	pcmcia_mem_free(sc->sc_pf, &sc->sc_pcmemh);

	ether_ifdetach(ifp);
	if_detach(ifp);

	return (rv);
}

int
cnw_activate(dev, act)
	struct device *dev;
	int act;
{
	struct cnw_softc *sc = (struct cnw_softc *)dev;
        struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	switch (act) {
	case DVACT_DEACTIVATE:
		ifp->if_timer = 0;
		ifp->if_flags &= ~IFF_RUNNING; /* XXX no cnw_stop() ? */
		if (sc->sc_ih)
			pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
		sc->sc_ih = NULL;
		pcmcia_function_disable(sc->sc_pf);
		break;
	}
	return (0);
}
@


1.36
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.35 2015/12/08 13:34:22 tedu Exp $	*/
@


1.35
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.34 2015/11/24 17:11:40 mpi Exp $	*/
a421 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.34
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.33 2015/10/25 13:13:06 mpi Exp $	*/
d421 1
a421 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;
@


1.33
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.32 2015/07/08 07:21:50 mpi Exp $	*/
a67 1
#include <net/if_dl.h>
@


1.32
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.31 2015/06/24 09:40:54 mpi Exp $	*/
a751 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a761 5
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		}
@


1.31
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.30 2015/05/21 09:36:20 mpi Exp $	*/
d529 1
a529 1
		MFREE(m, m0);
@


1.30
log
@No need to set "rcvif", if_input() does it for you.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.29 2015/05/19 11:24:01 mpi Exp $	*/
a654 1
		++ifp->if_ipackets;
@


1.29
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.28 2015/05/13 10:42:46 jsg Exp $	*/
a561 1
	m->m_pkthdr.rcvif = &sc->sc_arpcom.ac_if;
@


1.28
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.27 2015/03/14 03:38:49 jsg Exp $	*/
d635 1
a636 1
	struct ether_header *eh;
d643 1
a643 1
			return;
d654 1
a654 1
			return;
d657 2
d660 1
a660 20
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

		/*
		 * Check that the packet is for us or {multi,broad}cast. Maybe
		 * there's a fool-poof hardware check for this, but I don't
		 * really know...
		 */
		eh = mtod(m, struct ether_header *);
		if ((eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(sc->sc_arpcom.ac_enaddr, eh->ether_dhost,
			sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			continue;
		}

		ether_input_mbuf(ifp, m);
	}
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.26 2014/12/22 02:28:52 tedu Exp $	*/
d465 1
a465 1
		if (m0 == 0)
d560 1
a560 1
	if (m == 0)
d571 1
a571 1
			if (m == 0) {
d652 1
a652 1
		if (m == 0) {
@


1.26
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.25 2014/08/11 12:45:45 mpi Exp $	*/
a63 1
#include <dev/pcmcia/pcmciareg.h>
@


1.25
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.24 2013/08/07 01:06:39 bluhm Exp $	*/
a783 1
#ifdef INET
a786 1
#endif
@


1.24
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.23 2013/02/18 23:29:21 jsg Exp $	*/
a70 1
#ifdef INET
a71 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a72 1
#endif
@


1.23
log
@set the wireless interface priority and interfaces to the wlan group
for the remaining pre 802.11b wireless drivers.

ok krw@@ phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.22 2011/07/03 15:47:17 matthew Exp $	*/
a73 1
#include <netinet/in_var.h>
@


1.22
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.21 2010/08/30 20:33:18 deraadt Exp $	*/
d434 3
@


1.21
log
@Convert the pcmcia power hook to an activate function.  Then change the
model so that DVACT_SUSPEND methods call sub-drivers with DVACT_SUSPEND
not DVACT_DEACTIVATE, and such.  This creates a whole bunch of fallout,
which needs fixing.
wdc(4), ne(4), and wi(4) have been fully tested and actually work better
than they ever have before (no more wdc timeouts on resume!)
malo(4) has some other nasty bug which has not yet been spotted which
causes crazy panics.
The other drivers are more rare and will be fixed if people show up
with hardware; for now at least they have been adapted to the new model.
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.20 2009/10/13 19:33:16 pirofti Exp $	*/
a864 6
	case DVACT_ACTIVATE:
		pcmcia_function_enable(sc->sc_pf);
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    cnw_intr, sc, sc->sc_dev.dv_xname);
		cnw_init(sc);
		break;
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.19 2009/03/29 21:53:53 sthen Exp $	*/
a862 1
	int s;
a863 1
	s = splnet();
a870 1

d874 3
a876 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
a879 1
	splx(s);
@


1.19
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.18 2008/10/03 01:41:40 brad Exp $	*/
d103 1
a103 1
int	cnw_activate(struct device *, enum devact);
d859 1
a859 1
	enum devact act;
@


1.18
log
@Return ENOTTY for unknown ioctl's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.17 2008/06/26 05:42:17 ray Exp $	*/
d404 1
a404 1
		printf(": can't map memory\n");
@


1.17
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.16 2006/03/25 22:41:46 djm Exp $	*/
a779 1

d811 1
a811 1
		error = EINVAL;
@


1.16
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.15 2005/01/27 17:04:55 millert Exp $	*/
a16 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.15
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.14 2004/05/12 06:35:11 tedu Exp $	*/
d480 1
a480 1
			bpf_mtap(ifp->if_bpf, m0);
d670 1
a670 1
			bpf_mtap(ifp->if_bpf, m);
@


1.14
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.13 2003/11/07 20:34:27 jmc Exp $	*/
d318 1
a318 1
	    cnw_intr, sc, "");
@


1.13
log
@updated URL and a typo from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.12 2002/11/19 18:36:18 jason Exp $	*/
a87 1
#include <net/bpfdesc.h>
@


1.12
log
@Use queue.h macros instead of using the structure names directly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.11 2002/03/14 01:27:01 millert Exp $	*/
d44 2
a45 3
 * of Tromsø, Norway. It is part of the Linix pcmcia-cs package that
 * can be found at
 * http://hyper.stanford.edu/HyperNews/get/pcmcia/home.html. The most
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.10 2001/08/17 21:52:16 deraadt Exp $	*/
d387 1
a387 1
	pcmcia_function_init(sc->sc_pf, sc->sc_pf->cfe_head.sqh_first);
@


1.10
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.9 2001/06/27 06:34:51 kjc Exp $	*/
d109 4
a112 4
int	cnw_match __P((struct device *, void *, void *));
void	cnw_attach __P((struct device *, struct device *, void *));
int	cnw_detach __P((struct device *, int));
int	cnw_activate __P((struct device *, enum devact));
d143 12
a154 12
void cnw_reset __P((struct cnw_softc *));
void cnw_init __P((struct cnw_softc *));
int cnw_enable __P((struct cnw_softc *sc));
void cnw_disable __P((struct cnw_softc *sc));
void cnw_config __P((struct cnw_softc *sc, u_int8_t *));
void cnw_start __P((struct ifnet *));
void cnw_transmit __P((struct cnw_softc *, struct mbuf *));
struct mbuf *cnw_read __P((struct cnw_softc *));
void cnw_recv __P((struct cnw_softc *));
int cnw_intr __P((void *arg));
int cnw_ioctl __P((struct ifnet *, u_long, caddr_t));
void cnw_watchdog __P((struct ifnet *));
d159 3
a161 3
static int wait_WOC __P((struct cnw_softc *, int));
static int read16 __P((struct cnw_softc *, int));
static int cnw_cmd __P((struct cnw_softc *, int, int, int, int));
@


1.10.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.10 2001/08/17 21:52:16 deraadt Exp $	*/
d109 4
a112 4
int	cnw_match(struct device *, void *, void *);
void	cnw_attach(struct device *, struct device *, void *);
int	cnw_detach(struct device *, int);
int	cnw_activate(struct device *, enum devact);
d143 12
a154 12
void cnw_reset(struct cnw_softc *);
void cnw_init(struct cnw_softc *);
int cnw_enable(struct cnw_softc *sc);
void cnw_disable(struct cnw_softc *sc);
void cnw_config(struct cnw_softc *sc, u_int8_t *);
void cnw_start(struct ifnet *);
void cnw_transmit(struct cnw_softc *, struct mbuf *);
struct mbuf *cnw_read(struct cnw_softc *);
void cnw_recv(struct cnw_softc *);
int cnw_intr(void *arg);
int cnw_ioctl(struct ifnet *, u_long, caddr_t);
void cnw_watchdog(struct ifnet *);
d159 3
a161 3
static int wait_WOC(struct cnw_softc *, int);
static int read16(struct cnw_softc *, int);
static int cnw_cmd(struct cnw_softc *, int, int, int, int);
@


1.10.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d387 1
a387 1
	pcmcia_function_init(sc->sc_pf, SIMPLEQ_FIRST(&sc->sc_pf->cfe_head));
@


1.9
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.8 2001/06/25 04:05:50 fgsch Exp $	*/
d319 2
a320 1
	sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);
d879 2
a880 4
		printf("%s:", sc->sc_dev.dv_xname);
		sc->sc_ih =
		    pcmcia_intr_establish(sc->sc_pf, IPL_NET, cnw_intr, sc);
		printf("\n");
@


1.8
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.7 2001/02/20 19:39:46 mickey Exp $	*/
d437 1
d475 1
a475 1
		IF_DEQUEUE(&ifp->if_snd, m0);
@


1.7
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.6 2000/04/24 19:43:35 niklas Exp $	*/
d686 1
a686 3
		/* Pass the packet up, with the ether header sort-of removed */
		m_adj(m, sizeof(struct ether_header));
		ether_input(ifp, eh, m);
@


1.6
log
@Do not unmap CCR before using them for the last time
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.5 2000/02/03 18:47:06 angelos Exp $	*/
a440 4
#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.5
log
@cnw_activate hacking
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.4 2000/02/01 17:39:33 fgsch Exp $	*/
d344 1
a345 1
	pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
d893 1
a894 1
		pcmcia_intr_disestablish(sc->sc_pf, sc->sc_ih);
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.7 2001/02/20 19:39:46 mickey Exp $	*/
d344 1
a345 1
	pcmcia_function_disable(sc->sc_pf);
d441 4
d893 1
a894 1
		pcmcia_function_disable(sc->sc_pf);
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.5.2.1 2001/05/14 22:26:06 niklas Exp $	*/
a436 1
	IFQ_SET_READY(&ifp->if_snd);
d474 1
a474 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d686 3
a688 1
		ether_input_mbuf(ifp, m);
@


1.5.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.5.2.2 2001/07/04 10:43:22 niklas Exp $	*/
d319 1
a319 2
	sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
	    cnw_intr, sc, "");
d878 4
a881 2
		sc->sc_ih = pcmcia_intr_establish(sc->sc_pf, IPL_NET,
		    cnw_intr, sc, sc->sc_dev.dv_xname);
@


1.5.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d109 4
a112 4
int	cnw_match(struct device *, void *, void *);
void	cnw_attach(struct device *, struct device *, void *);
int	cnw_detach(struct device *, int);
int	cnw_activate(struct device *, enum devact);
d143 12
a154 12
void cnw_reset(struct cnw_softc *);
void cnw_init(struct cnw_softc *);
int cnw_enable(struct cnw_softc *sc);
void cnw_disable(struct cnw_softc *sc);
void cnw_config(struct cnw_softc *sc, u_int8_t *);
void cnw_start(struct ifnet *);
void cnw_transmit(struct cnw_softc *, struct mbuf *);
struct mbuf *cnw_read(struct cnw_softc *);
void cnw_recv(struct cnw_softc *);
int cnw_intr(void *arg);
int cnw_ioctl(struct ifnet *, u_long, caddr_t);
void cnw_watchdog(struct ifnet *);
d159 3
a161 3
static int wait_WOC(struct cnw_softc *, int);
static int read16(struct cnw_softc *, int);
static int cnw_cmd(struct cnw_softc *, int, int, int, int);
@


1.5.2.5
log
@Sync the SMP branch with 3.3
@
text
@d387 1
a387 1
	pcmcia_function_init(sc->sc_pf, SIMPLEQ_FIRST(&sc->sc_pf->cfe_head));
@


1.5.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 3
a46 2
 * of Tromsø, Norway. It is part of the Linux pcmcia-cs package that
 * can be found at http://pcmcia-cs.sourceforge.net/. The most
@


1.5.2.7
log
@Merge with the trunk
@
text
@d88 1
@


1.4
log
@oops, return 0 if not match.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.3 2000/02/01 17:00:04 fgsch Exp $	*/
d876 1
d883 1
d886 2
d891 2
@


1.3
log
@sync with the new names; add support for a second model.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.2 1999/08/24 07:11:09 fgsch Exp $	*/
d363 1
a363 1
		return 1;
d366 2
a367 1
		return 1;
@


1.2
log
@Remove unneeded printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cnw.c,v 1.1 1999/08/13 20:34:17 fgsch Exp $	*/
d361 6
a366 2
	return (pa->manufacturer == PCMCIA_VENDOR_XIRCOM &&
		pa->product == PCMCIA_PRODUCT_XIRCOM_XIR_CNW);
@


1.1
log
@Xircom NetWave support. Donations welcomed.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a411 1
	printf(": %s\n", PCMCIA_STR_XIRCOM_XIR_CNW);
@

