head	1.17;
access;
symbols
	OPENBSD_4_3:1.16.0.10
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.8
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.16.0.6
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.11
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3
	SMP:1.2.0.2
	SMP_BASE:1.2;
locks; strict;
comment	@ * @;


1.17
date	2008.05.23.14.04.19;	author brad;	state dead;
branches;
next	1.16;

1.16
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.21.11.16.00;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.27.17.04.55;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.22.09.58.46;	author jmc;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.15.22.18.11;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.05.22.11.04.50;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.26.20.08.51;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.04.18.08.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.04.04.36.59;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.17.16.16.31;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.24.19.43.35;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.11.10.29.36;	author niklas;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.12.16.02.56.57;	author deraadt;	state Exp;
branches;
next	;

1.2.2.1
date	2001.05.14.22.26.06;	author niklas;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.07.04.10.43.22;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2001.10.31.03.22.48;	author nate;	state Exp;
branches;
next	1.2.2.4;

1.2.2.4
date	2002.03.28.15.34.52;	author niklas;	state Exp;
branches;
next	1.2.2.5;

1.2.2.5
date	2003.03.28.00.38.26;	author niklas;	state Exp;
branches;
next	1.2.2.6;

1.2.2.6
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.42.28;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2002.10.29.00.33.30;	author art;	state Exp;
branches;
next	;


desc
@@


1.17
log
@Bye bye awi(4). No net80211 love, uses its own WEP code and has not worked
properly in 8.5 years so just garbage collect the driver.

ok damien@@ deraadt@@
@
text
@/* $NetBSD: if_awi_pcmcia.c,v 1.13 2000/03/22 11:22:20 onoe Exp $ */
/* $OpenBSD: if_awi_pcmcia.c,v 1.16 2005/11/21 18:16:42 millert Exp $ */

/*-
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Bill Sommerfeld
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * PCMCIA attachment for BayStack 650 802.11FH PCMCIA card,
 * based on the AMD 79c930 802.11 controller chip.
 *
 * This attachment can probably be trivially adapted for other FH and
 * DS cards based on the same chipset.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ic/am79c930reg.h>
#include <dev/ic/am79c930var.h>
#include <dev/ic/awireg.h>
#include <dev/ic/awivar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciadevs.h>

struct awi_pcmcia_softc {
	struct awi_softc sc_awi;		/* real "awi" softc */

	/* PCMCIA-specific goo */
	struct pcmcia_io_handle sc_pcioh;	/* PCMCIA i/o space info */
	struct pcmcia_mem_handle sc_memh;	/* PCMCIA memory space info */
	int sc_io_window;			/* our i/o window */
	int sc_mem_window;			/* our memory window */
	struct pcmcia_function *sc_pf;		/* our PCMCIA function */
	void *sc_powerhook;			/* power hook descriptor */
};

static int awi_pcmcia_match(struct device *, void *, void *);
static void awi_pcmcia_attach(struct device *, struct device *, void *);
static int awi_pcmcia_detach(struct device *, int);
static int awi_pcmcia_enable(struct awi_softc *);
static void awi_pcmcia_disable(struct awi_softc *);
static void awi_pcmcia_powerhook(int, void *);

static int	awi_pcmcia_find(struct awi_pcmcia_softc *,
    struct pcmcia_attach_args *, struct pcmcia_config_entry *);

struct cfattach awi_pcmcia_ca = {
	sizeof(struct awi_pcmcia_softc), awi_pcmcia_match, awi_pcmcia_attach,
	awi_pcmcia_detach, awi_activate
};

static struct awi_pcmcia_product {
	u_int16_t	app_vendor;	/* vendor ID */
	u_int16_t	app_product;	/* product ID */
	const char	*app_cisinfo[4]; /* CIS information */
	const char	*app_name;	/* product name */
} awi_pcmcia_products[] = {
	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_STACK_650,
	  PCMCIA_CIS_BAY_STACK_650,	"BayStack 650" },

	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_STACK_660,
	  PCMCIA_CIS_BAY_STACK_660,	"BayStack 660" },

	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_SURFER_PRO,
	  PCMCIA_CIS_BAY_SURFER_PRO,	"AirSurfer Pro" },

	{ PCMCIA_VENDOR_AMD,		PCMCIA_PRODUCT_AMD_AM79C930,
	  PCMCIA_CIS_AMD_AM79C930,	"AMD AM79C930" },

	{ PCMCIA_VENDOR_ICOM,		PCMCIA_PRODUCT_ICOM_SL200,
	  PCMCIA_CIS_ICOM_SL200,	"Icom SL-200" },

	{ PCMCIA_VENDOR_NOKIA,		PCMCIA_PRODUCT_NOKIA_C020_WLAN,
	  PCMCIA_CIS_NOKIA_C020_WLAN,	"Nokia C020" },

	{ PCMCIA_VENDOR_FARALLON,	PCMCIA_PRODUCT_FARALLON_SKYLINE,
	  PCMCIA_CIS_FARALLON_SKYLINE,	"SkyLINE Wireless" },

	{ PCMCIA_VENDOR_ZOOM,		PCMCIA_PRODUCT_ZOOM_AIR4000,
	  PCMCIA_CIS_ZOOM_AIR4000,	"Zoom Air-4000" },

/*	{ PCMCIA_VENDOR_BREEZECOM,	PCMCIA_PRODUCT_BREEZECOM_BREEZENET,
	  PCMCIA_CIS_BREEZECOM_BREEZENET,	"BreezeNet SC-PX" },
*/
	{ 0,				0,
	  { NULL, NULL, NULL, NULL },	NULL },
};

static struct awi_pcmcia_product *
	awi_pcmcia_lookup(struct pcmcia_attach_args *);

static struct awi_pcmcia_product *
awi_pcmcia_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	struct awi_pcmcia_product *app;

	for (app = awi_pcmcia_products; app->app_name != NULL; app++) {
		/* match by vendor/product id */
		if (pa->manufacturer != PCMCIA_VENDOR_INVALID &&
		    pa->manufacturer == app->app_vendor &&
		    pa->product != PCMCIA_PRODUCT_INVALID &&
		    pa->product == app->app_product)
			return (app);

		/* match by CIS information */
		if (pa->card->cis1_info[0] != NULL &&
		    app->app_cisinfo[0] != NULL &&
		    strcmp(pa->card->cis1_info[0], app->app_cisinfo[0]) == 0 &&
		    pa->card->cis1_info[1] != NULL &&
		    app->app_cisinfo[1] != NULL &&
		    strcmp(pa->card->cis1_info[1], app->app_cisinfo[1]) == 0)
			return (app);
	}

	return (NULL);
}

static int
awi_pcmcia_enable(sc)
	struct awi_softc *sc;
{
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *)sc;
	struct pcmcia_function *pf = psc->sc_pf;

	/* establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, awi_intr,
	    sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return (1);
	}

	if (pcmcia_function_enable(pf)) {
		pcmcia_intr_disestablish(pf, sc->sc_ih);
		return (1);
	}
	DELAY(1000);

	return (0);
}

static void
awi_pcmcia_disable(sc)
	struct awi_softc *sc;
{
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *)sc;
	struct pcmcia_function *pf = psc->sc_pf;

	pcmcia_intr_disestablish (pf, sc->sc_ih);
	pcmcia_function_disable (pf);
}

static int
awi_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct pcmcia_attach_args *pa = aux;

	if (awi_pcmcia_lookup(pa) != NULL)
		return (1);

	return (0);
}

static int
awi_pcmcia_find(psc, pa, cfe)
	struct awi_pcmcia_softc *psc;
	struct pcmcia_attach_args *pa;
	struct pcmcia_config_entry *cfe;
{
	struct awi_softc *sc = &psc->sc_awi;
	int fail = 0;
	u_int8_t version[AWI_BANNER_LEN];

	/*
	 * see if we can read the firmware version sanely
	 * through the i/o ports.
	 * if not, try a different CIS string..
	 */
	if (pcmcia_io_alloc(psc->sc_pf, cfe->iospace[0].start,
	    cfe->iospace[0].length, AM79C930_IO_ALIGN,
	    &psc->sc_pcioh) != 0)
		goto fail;

	if (pcmcia_io_map(psc->sc_pf, PCMCIA_WIDTH_AUTO, 0, psc->sc_pcioh.size,
	    &psc->sc_pcioh, &psc->sc_io_window))
		goto fail_io_free;

	/* Enable the card. */
	pcmcia_function_init(psc->sc_pf, cfe);
	if (pcmcia_function_enable(psc->sc_pf))
		goto fail_io_unmap;

	sc->sc_chip.sc_bustype = AM79C930_BUS_PCMCIA;
	sc->sc_chip.sc_iot = psc->sc_pcioh.iot;
	sc->sc_chip.sc_ioh = psc->sc_pcioh.ioh;
	am79c930_chip_init(&sc->sc_chip, 0);

	DELAY(1000);

	awi_read_bytes(sc, AWI_BANNER, version, AWI_BANNER_LEN);

	if (memcmp(version, "PCnetMobile:", 12) == 0)
		return (0);

	fail++;
	pcmcia_function_disable(psc->sc_pf);

 fail_io_unmap:
	fail++;
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);

 fail_io_free:
	fail++;
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
 fail:
	fail++;
	psc->sc_io_window = -1;
	return (fail);
}

static void
awi_pcmcia_attach(parent, self, aux)
	struct device  *parent, *self;
	void           *aux;
{
	struct awi_pcmcia_softc *psc = (void *)self;
	struct awi_softc *sc = &psc->sc_awi;
	struct awi_pcmcia_product *app;
	struct pcmcia_attach_args *pa = aux;
	struct pcmcia_config_entry *cfe;
	const char *intrstr;
#if 0
	bus_addr_t memoff;
#endif

	app = awi_pcmcia_lookup(pa);
	if (app == NULL)
		panic("awi_pcmcia_attach: impossible");

	psc->sc_pf = pa->pf;

	for (cfe = SIMPLEQ_FIRST(&pa->pf->cfe_head); cfe != NULL;
	     cfe = SIMPLEQ_NEXT(cfe, cfe_list)) {
		if (cfe->iftype != PCMCIA_IFTYPE_IO)
			continue;
		if (cfe->num_iospace < 1)
			continue;
		if (cfe->iospace[0].length < AM79C930_IO_SIZE)
			continue;

		if (awi_pcmcia_find(psc, pa, cfe) == 0)
			break;
	}
	if (cfe == NULL) {
		printf(": no suitable CIS info found\n");
		goto no_config_entry;
	}

	sc->sc_enabled = 1;
	printf(": %s\n", app->app_name);

	psc->sc_mem_window = -1;
#if 0	/* if memory mode is disabled it futhers futher */
	if (pcmcia_mem_alloc(psc->sc_pf, AM79C930_MEM_SIZE,
	    &psc->sc_memh) != 0) {
		printf("%s: unable to allocate memory space; using i/o only\n",
		    sc->sc_dev.dv_xname);
	} else if (pcmcia_mem_map(psc->sc_pf,
	    PCMCIA_MEM_COMMON, AM79C930_MEM_BASE,
	    AM79C930_MEM_SIZE, &psc->sc_memh, &memoff, &psc->sc_mem_window)) {
		printf("%s: unable to map memory space; using i/o only\n",
		    sc->sc_dev.dv_xname);
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
	} else {
		sc->sc_chip.sc_memt = psc->sc_memh.memt;
		sc->sc_chip.sc_memh = psc->sc_memh.memh;
		am79c930_chip_init(&sc->sc_chip, 1);
	}
#endif

	sc->sc_enable = awi_pcmcia_enable;
	sc->sc_disable = awi_pcmcia_disable;

	/* establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    awi_intr, sc, sc->sc_dev.dv_xname);
	intrstr = pcmcia_intr_string(psc->sc_pf, sc->sc_ih);
	if (sc->sc_ih == NULL) {
		printf(", %s\n", intrstr);
		goto no_interrupt;
	}
	if (*intrstr)
		printf(", %s", intrstr);
	sc->sc_ifp = &sc->sc_arpcom.ac_if;
	sc->sc_cansleep = 1;

	if (awi_attach(sc) != 0) {
		printf("%s: failed to attach controller\n",
		    sc->sc_dev.dv_xname);
		goto attach_failed;
	}
	psc->sc_powerhook = powerhook_establish(awi_pcmcia_powerhook, psc);

	sc->sc_enabled = 0;
	/* disable device and disestablish the interrupt */
	awi_pcmcia_disable(sc);
	return;

 attach_failed:
	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);

 no_interrupt:
	/* Unmap our memory window and space */
	if (psc->sc_mem_window != -1) {
		pcmcia_mem_unmap(psc->sc_pf, psc->sc_mem_window);
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
	}

	/* Unmap our i/o window and space */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);

	/* Disable the function */
	pcmcia_function_disable(psc->sc_pf);

 no_config_entry:
	psc->sc_io_window = -1;
}


static int
awi_pcmcia_detach(self, flags)
	struct device *self;
	int flags;
{
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *)self;
	int error;

	if (psc->sc_io_window == -1)
		/* Nothing to detach. */
		return (0);

	if (psc->sc_powerhook != NULL)
		powerhook_disestablish(psc->sc_powerhook);

	error = awi_detach(&psc->sc_awi);
	if (error != 0)
		return (error);

	/* Unmap our memory window and free memory space */
	if (psc->sc_mem_window != -1) {
		pcmcia_mem_unmap(psc->sc_pf, psc->sc_mem_window);
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
	}

	/* Unmap our i/o window. */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);

	/* Free our i/o space. */
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
	return (0);
}

static void
awi_pcmcia_powerhook(why, arg)
	int why;
	void *arg;
{
	struct awi_pcmcia_softc *psc = arg;
	struct awi_softc *sc = &psc->sc_awi;

	awi_power(sc, why);
}
@


1.16
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.15 2005/02/21 11:16:00 dlg Exp $ */
@


1.15
log
@unbreak compilation by including some missing headers

requested by and ok reyk@@
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.14 2005/01/27 17:04:55 millert Exp $ */
d57 1
a57 1
#include <sys/select.h>
@


1.14
log
@Use pcmcia_intr_string() for printing the irq (or error) string.
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.13 2004/11/23 21:12:23 fgsch Exp $ */
d68 1
@


1.13
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.12 2003/10/22 09:58:46 jmc Exp $ */
d297 1
d352 2
a353 1
	    awi_intr, sc, "");
d355 1
a355 2
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
d358 2
@


1.12
log
@typos from Tom Cosgrove;
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.11 2002/09/15 22:18:11 deraadt Exp $ */
d67 1
a67 1
#include <net/if_ieee80211.h>
@


1.11
log
@make it at least compile; parts from maurice@@amaze.nl
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.10 2002/03/14 01:27:00 millert Exp $ */
d44 1
a44 1
 * This attachment can probably be trivally adapted for other FH and
@


1.10
log
@First round of __P removal in sys
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.9 2001/08/17 21:52:16 deraadt Exp $ */
d357 1
a357 1
	sc->sc_ifp = &sc->sc_ec.ac_if;
@


1.9
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.8 2001/05/22 11:04:50 fgsch Exp $ */
d98 6
a103 6
static int awi_pcmcia_match __P((struct device *, void *, void *));
static void awi_pcmcia_attach __P((struct device *, struct device *, void *));
static int awi_pcmcia_detach __P((struct device *, int));
static int awi_pcmcia_enable __P((struct awi_softc *));
static void awi_pcmcia_disable __P((struct awi_softc *));
static void awi_pcmcia_powerhook __P((int, void *));
d105 2
a106 2
static int	awi_pcmcia_find __P((struct awi_pcmcia_softc *,
    struct pcmcia_attach_args *, struct pcmcia_config_entry *));
d151 1
a151 1
	awi_pcmcia_lookup __P((struct pcmcia_attach_args *));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.9 2001/08/17 21:52:16 deraadt Exp $ */
d98 6
a103 6
static int awi_pcmcia_match(struct device *, void *, void *);
static void awi_pcmcia_attach(struct device *, struct device *, void *);
static int awi_pcmcia_detach(struct device *, int);
static int awi_pcmcia_enable(struct awi_softc *);
static void awi_pcmcia_disable(struct awi_softc *);
static void awi_pcmcia_powerhook(int, void *);
d105 2
a106 2
static int	awi_pcmcia_find(struct awi_pcmcia_softc *,
    struct pcmcia_attach_args *, struct pcmcia_config_entry *);
d151 1
a151 1
	awi_pcmcia_lookup(struct pcmcia_attach_args *);
@


1.9.4.2
log
@sync to -current
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.9.4.1 2002/06/11 03:42:28 art Exp $ */
d357 1
a357 1
	sc->sc_ifp = &sc->sc_arpcom.ac_if;
@


1.8
log
@Vendor and prodid are 16-bits, not 32.
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.7 2001/01/26 20:08:51 mickey Exp $ */
d188 2
a189 1
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, awi_intr, sc);
d350 2
a351 1
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, awi_intr, sc);
@


1.7
log
@match on zoom air-4000, as it has been reported by Ian Cass <ian.cass@@knowledge.com>
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.6 2000/09/04 18:08:47 mickey Exp $ */
d114 2
a115 2
	u_int32_t	app_vendor;	/* vendor ID */
	u_int32_t	app_product;	/* product ID */
@


1.6
log
@oops recycle variable, only used when mem mode enabled
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.5 2000/09/04 04:36:59 mickey Exp $ */
d139 3
@


1.5
log
@futhers futher
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.5 2000/09/04 04:35:15 mickey Exp $ */
d293 1
d295 1
@


1.4
log
@replace if_awi w/ semi-current netbsd driver; still has problems
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.3 2000/04/24 19:43:35 niklas Exp $ */
d322 1
d338 1
@


1.3
log
@Do not unmap CCR before using them for the last time
@
text
@d1 2
a2 2
/* $NetBSD: if_awi_pcmcia.c,v 1.5 1999/11/06 16:43:54 sommerfeld Exp $ */
/* $OpenBSD: if_awi_pcmcia.c,v 1.2 2000/02/11 10:29:36 niklas Exp $ */
a63 1
#ifdef INET
a64 5
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#endif

d67 1
a67 4
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif
a70 1
#include <net/bpfdesc.h>
a85 8
int	awi_pcmcia_match __P((struct device *, void *, void *));
void	awi_pcmcia_attach __P((struct device *, struct device *, void *));
int	awi_pcmcia_detach __P((struct device *, int));

int	awi_pcmcia_get_enaddr __P((struct pcmcia_tuple *, void *));
int	awi_pcmcia_enable __P((struct awi_softc *));
void	awi_pcmcia_disable __P((struct awi_softc *));

d87 1
a87 1
	struct awi_softc sc_awi;			/* real "awi" softc */
d91 1
d93 1
d95 1
d98 8
a105 1
int	awi_pcmcia_find __P((struct awi_pcmcia_softc *,
d108 3
a110 3
/* Autoconfig definition of driver back-end */
struct cfdriver awi_cd = {
        NULL, "awi", DV_IFNET
d113 32
a144 3
struct cfattach awi_pcmcia_ca = {
	sizeof(struct awi_pcmcia_softc), awi_pcmcia_match, awi_pcmcia_attach,
	awi_pcmcia_detach, /* awi_activate */ 0
d147 8
a154 4
/*
 *  XXX following is common to most PCMCIA NIC's and belongs
 * in common code
 */
d156 17
a172 4
struct awi_pcmcia_get_enaddr_args {
	int got_enaddr;
	u_int8_t enaddr[ETHER_ADDR_LEN];
};
d174 2
a175 1
int	awi_pcmcia_get_enaddr __P((struct pcmcia_tuple *, void *));
d177 1
a177 1
int
d181 1
a181 1
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *) sc;
d191 8
a198 1
	return (pcmcia_function_enable(pf));
d201 1
a201 1
void
d205 1
a205 1
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *) sc;
d212 1
a212 1
int
d220 1
a220 4
	if (pa->manufacturer != PCMCIA_VENDOR_BAY)
		return (0);

	if (pa->product == PCMCIA_PRODUCT_BAY_STACK_650)
d226 2
a227 2
int
awi_pcmcia_find (psc, pa, cfe)
d235 1
a235 1
	
d242 2
a243 1
	    cfe->iospace[0].length, 0, &psc->sc_pcioh) != 0)
d245 1
a245 1
	
d252 1
a252 1
	if (pcmcia_function_enable(psc->sc_pf)) 
d254 2
a255 1
		
d262 1
a262 1
	awi_read_bytes (sc, AWI_BANNER, version, AWI_BANNER_LEN);
d265 2
a266 2
		return 0;
	
d268 2
a269 2
	pcmcia_function_disable (psc->sc_pf);
	
d272 2
a273 2
	pcmcia_io_unmap (psc->sc_pf, psc->sc_io_window);
	
d276 1
a276 1
	pcmcia_io_free (psc->sc_pf, &psc->sc_pcioh);
d279 2
a280 1
	return fail;
d283 1
a283 3


void
d288 1
a288 1
	struct awi_pcmcia_softc *psc = (void *) self;
d290 1
a292 3
	struct awi_pcmcia_get_enaddr_args pgea;
#if 0
	struct pcmcia_mem_handle memh;
a293 2
	int memwin;
#endif
d295 3
a297 26
#if 0
	int i, j;

	for (cfe = pa->pf->cfe_head.sqh_first, i=0;
	     cfe != NULL;
	     cfe = cfe->cfe_list.sqe_next, i++) {
		printf("%d: %d memspaces, %d iospaces\n",
		    i, cfe->num_memspace, cfe->num_iospace);
		printf("%d: number %d flags %x iftype %d iomask %lx irqmask %x maxtwins %x\n",
		    i, cfe->number, cfe->flags, cfe->iftype, cfe->iomask,
		    cfe->irqmask, cfe->maxtwins);
		for (j=0; j<cfe->num_memspace; j++) {
			printf("%d: mem %d: len %lx card %lx host %lx\n",
			    i, j,
			    cfe->memspace[j].length,
			    cfe->memspace[j].cardaddr,
			    cfe->memspace[j].hostaddr);
		}
		for (j=0; j<cfe->num_iospace; j++) {
			printf("%d: io %d: len %lx start %lx\n",
			    i, j,
			    cfe->iospace[j].length,
			    cfe->iospace[j].start);
		}
	}
#endif
d315 1
a315 1
		return;
d319 1
a319 2
	sc->sc_state = AWI_ST_SELFTEST;
	printf(": BayStack 650 Wireless (802.11)\n");
d321 3
a323 2
#if 0
	if (pcmcia_mem_alloc(psc->sc_pf, AM79C930_MEM_SIZE, &memh) != 0) {
d326 3
a328 3
	} else if (pcmcia_mem_map(psc->sc_pf, PCMCIA_MEM_COMMON,
	    AM79C930_MEM_BASE, AM79C930_MEM_SIZE,
	    &memh, &memoff, &memwin)) {
d331 1
a331 1
		pcmcia_mem_free(psc->sc_pf, &memh);
d333 2
a334 2
		sc->sc_chip.sc_memt = memh.memt;
		sc->sc_chip.sc_memh = memh.memh;
a336 1
#endif
a337 2
	sc->sc_chip.sc_bustype = AM79C930_BUS_PCMCIA;
	
d341 4
a344 4
	/* Read station address. */
	pgea.got_enaddr = 0;
	if (pcmcia_scan_cis(parent, awi_pcmcia_get_enaddr, &pgea) == -1) {
		printf("%s: Couldn't read CIS to get ethernet address\n",
d346 7
a352 3
		return;
	} else if (!pgea.got_enaddr) {
		printf("%s: Couldn't get ethernet address from CIS\n",
d354 3
a356 7
		return;
	} else
#ifdef DIAGNOSTIC
		printf("%s: Ethernet address from CIS: %s\n",
		    sc->sc_dev.dv_xname, ether_sprintf(pgea.enaddr))
#endif
		;
d358 14
a371 1
	awi_attach(sc, pgea.enaddr);
d373 3
a375 4
#ifndef NETBSD_ORIGINAL
	awi_init(sc);
	awi_stop(sc);
#endif
d377 2
a378 2
#ifdef notyet  /* NETBSD_ORIGINAL */
	sc->sc_state = AWI_ST_OFF;
d380 2
a381 6
	sc->sc_enabled = 0;
	/*
	 * XXX This should be done once the framework has enable/disable hooks.
	 */
	pcmcia_function_disable(psc->sc_pf);
#endif  /* notyet */
d385 1
a385 1
int
d391 18
a414 7

#ifdef notyet
	/*
	 * Our softc is about to go away, so drop our reference
	 * to the ifnet.
	 */
	if_delref(psc->sc_awi.sc_ethercom.ec_if);
a415 3
#else
	return (EBUSY);
#endif
d418 3
a420 8
/*
 * XXX copied verbatim from if_mbe_pcmcia.c.
 * this function should be in common pcmcia code..
 */

int
awi_pcmcia_get_enaddr(tuple, arg)
	struct pcmcia_tuple *tuple;
d423 2
a424 2
	struct awi_pcmcia_get_enaddr_args *p = arg;
	int i;
d426 1
a426 15
	if (tuple->code == PCMCIA_CISTPL_FUNCE) {
		if (tuple->length < 2) /* sub code and ether addr length */
			return (0);

		if ((pcmcia_tuple_read_1(tuple, 0) !=
			PCMCIA_TPLFE_TYPE_LAN_NID) ||
		    (pcmcia_tuple_read_1(tuple, 1) != ETHER_ADDR_LEN))
			return (0);

		for (i = 0; i < ETHER_ADDR_LEN; i++)
			p->enaddr[i] = pcmcia_tuple_read_1(tuple, i + 2);
		p->got_enaddr = 1;
		return (1);
	}
	return (0);
@


1.2
log
@Turn iff debugging code in attach, prolong a delay timer that made certain
cards hang at attach time.  The driver still has problems though.
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.1 1999/12/16 02:56:57 deraadt Exp $ */
d162 1
a163 1
	pcmcia_intr_disestablish (pf, sc->sc_ih);
@


1.2.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/* $NetBSD: if_awi_pcmcia.c,v 1.13 2000/03/22 11:22:20 onoe Exp $ */
/* $OpenBSD: if_awi_pcmcia.c,v 1.7 2001/01/26 20:08:51 mickey Exp $ */
d64 1
d66 5
d73 4
a76 1
#include <net/if_ieee80211.h>
d80 1
d96 8
d105 1
a105 1
	struct awi_softc sc_awi;		/* real "awi" softc */
a108 1
	struct pcmcia_mem_handle sc_memh;	/* PCMCIA memory space info */
a109 1
	int sc_mem_window;			/* our memory window */
a110 1
	void *sc_powerhook;			/* power hook descriptor */
d113 2
a114 6
static int awi_pcmcia_match __P((struct device *, void *, void *));
static void awi_pcmcia_attach __P((struct device *, struct device *, void *));
static int awi_pcmcia_detach __P((struct device *, int));
static int awi_pcmcia_enable __P((struct awi_softc *));
static void awi_pcmcia_disable __P((struct awi_softc *));
static void awi_pcmcia_powerhook __P((int, void *));
d116 4
a119 2
static int	awi_pcmcia_find __P((struct awi_pcmcia_softc *,
    struct pcmcia_attach_args *, struct pcmcia_config_entry *));
d123 1
a123 1
	awi_pcmcia_detach, awi_activate
d126 8
a133 35
static struct awi_pcmcia_product {
	u_int32_t	app_vendor;	/* vendor ID */
	u_int32_t	app_product;	/* product ID */
	const char	*app_cisinfo[4]; /* CIS information */
	const char	*app_name;	/* product name */
} awi_pcmcia_products[] = {
	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_STACK_650,
	  PCMCIA_CIS_BAY_STACK_650,	"BayStack 650" },

	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_STACK_660,
	  PCMCIA_CIS_BAY_STACK_660,	"BayStack 660" },

	{ PCMCIA_VENDOR_BAY,		PCMCIA_PRODUCT_BAY_SURFER_PRO,
	  PCMCIA_CIS_BAY_SURFER_PRO,	"AirSurfer Pro" },

	{ PCMCIA_VENDOR_AMD,		PCMCIA_PRODUCT_AMD_AM79C930,
	  PCMCIA_CIS_AMD_AM79C930,	"AMD AM79C930" },

	{ PCMCIA_VENDOR_ICOM,		PCMCIA_PRODUCT_ICOM_SL200,
	  PCMCIA_CIS_ICOM_SL200,	"Icom SL-200" },

	{ PCMCIA_VENDOR_NOKIA,		PCMCIA_PRODUCT_NOKIA_C020_WLAN,
	  PCMCIA_CIS_NOKIA_C020_WLAN,	"Nokia C020" },

	{ PCMCIA_VENDOR_FARALLON,	PCMCIA_PRODUCT_FARALLON_SKYLINE,
	  PCMCIA_CIS_FARALLON_SKYLINE,	"SkyLINE Wireless" },

	{ PCMCIA_VENDOR_ZOOM,		PCMCIA_PRODUCT_ZOOM_AIR4000,
	  PCMCIA_CIS_ZOOM_AIR4000,	"Zoom Air-4000" },

/*	{ PCMCIA_VENDOR_BREEZECOM,	PCMCIA_PRODUCT_BREEZECOM_BREEZENET,
	  PCMCIA_CIS_BREEZECOM_BREEZENET,	"BreezeNet SC-PX" },
*/
	{ 0,				0,
	  { NULL, NULL, NULL, NULL },	NULL },
d136 1
a136 2
static struct awi_pcmcia_product *
	awi_pcmcia_lookup __P((struct pcmcia_attach_args *));
d138 1
a138 28
static struct awi_pcmcia_product *
awi_pcmcia_lookup(pa)
	struct pcmcia_attach_args *pa;
{
	struct awi_pcmcia_product *app;

	for (app = awi_pcmcia_products; app->app_name != NULL; app++) {
		/* match by vendor/product id */
		if (pa->manufacturer != PCMCIA_VENDOR_INVALID &&
		    pa->manufacturer == app->app_vendor &&
		    pa->product != PCMCIA_PRODUCT_INVALID &&
		    pa->product == app->app_product)
			return (app);

		/* match by CIS information */
		if (pa->card->cis1_info[0] != NULL &&
		    app->app_cisinfo[0] != NULL &&
		    strcmp(pa->card->cis1_info[0], app->app_cisinfo[0]) == 0 &&
		    pa->card->cis1_info[1] != NULL &&
		    app->app_cisinfo[1] != NULL &&
		    strcmp(pa->card->cis1_info[1], app->app_cisinfo[1]) == 0)
			return (app);
	}

	return (NULL);
}

static int
d142 1
a142 1
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *)sc;
d152 1
a152 8

	if (pcmcia_function_enable(pf)) {
		pcmcia_intr_disestablish(pf, sc->sc_ih);
		return (1);
	}
	DELAY(1000);

	return (0);
d155 1
a155 1
static void
d159 1
a159 1
	struct awi_pcmcia_softc *psc = (struct awi_pcmcia_softc *)sc;
d162 1
a163 1
	pcmcia_function_disable (pf);
d166 1
a166 1
static int
d174 4
a177 1
	if (awi_pcmcia_lookup(pa) != NULL)
d183 2
a184 2
static int
awi_pcmcia_find(psc, pa, cfe)
d192 1
a192 1

d199 1
a199 2
	    cfe->iospace[0].length, AM79C930_IO_ALIGN,
	    &psc->sc_pcioh) != 0)
d201 1
a201 1

d208 1
a208 1
	if (pcmcia_function_enable(psc->sc_pf))
d210 1
a210 2

	sc->sc_chip.sc_bustype = AM79C930_BUS_PCMCIA;
d217 1
a217 1
	awi_read_bytes(sc, AWI_BANNER, version, AWI_BANNER_LEN);
d220 2
a221 2
		return (0);

d223 2
a224 2
	pcmcia_function_disable(psc->sc_pf);

d227 2
a228 2
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);

d231 1
a231 1
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
d234 1
a234 2
	psc->sc_io_window = -1;
	return (fail);
d237 3
a239 1
static void
d244 1
a244 1
	struct awi_pcmcia_softc *psc = (void *)self;
a245 1
	struct awi_pcmcia_product *app;
d248 1
d250 1
d252 1
d255 26
a280 3
	app = awi_pcmcia_lookup(pa);
	if (app == NULL)
		panic("awi_pcmcia_attach: impossible");
d298 1
a298 1
		goto no_config_entry;
d302 2
a303 1
	printf(": %s\n", app->app_name);
d305 2
a306 4
	psc->sc_mem_window = -1;
#if 0	/* if memory mode is disabled it futhers futher */
	if (pcmcia_mem_alloc(psc->sc_pf, AM79C930_MEM_SIZE,
	    &psc->sc_memh) != 0) {
d309 3
a311 3
	} else if (pcmcia_mem_map(psc->sc_pf,
	    PCMCIA_MEM_COMMON, AM79C930_MEM_BASE,
	    AM79C930_MEM_SIZE, &psc->sc_memh, &memoff, &psc->sc_mem_window)) {
d314 1
a314 1
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
d316 2
a317 2
		sc->sc_chip.sc_memt = psc->sc_memh.memt;
		sc->sc_chip.sc_memh = psc->sc_memh.memh;
d322 2
d327 8
a334 4
	/* establish the interrupt. */
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET, awi_intr, sc);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
d336 7
a342 4
		goto no_interrupt;
	}
	sc->sc_ifp = &sc->sc_ec.ac_if;
	sc->sc_cansleep = 1;
d344 1
a344 6
	if (awi_attach(sc) != 0) {
		printf("%s: failed to attach controller\n",
		    sc->sc_dev.dv_xname);
		goto attach_failed;
	}
	psc->sc_powerhook = powerhook_establish(awi_pcmcia_powerhook, psc);
d346 4
a349 14
	sc->sc_enabled = 0;
	/* disable device and disestablish the interrupt */
	awi_pcmcia_disable(sc);
	return;

 attach_failed:
	pcmcia_intr_disestablish(psc->sc_pf, sc->sc_ih);

 no_interrupt:
	/* Unmap our memory window and space */
	if (psc->sc_mem_window != -1) {
		pcmcia_mem_unmap(psc->sc_pf, psc->sc_mem_window);
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
	}
d351 2
a352 3
	/* Unmap our i/o window and space */
	pcmcia_io_unmap(psc->sc_pf, psc->sc_io_window);
	pcmcia_io_free(psc->sc_pf, &psc->sc_pcioh);
d354 4
a357 1
	/* Disable the function */
d359 1
a359 3

 no_config_entry:
	psc->sc_io_window = -1;
d363 1
a363 1
static int
a368 18
	int error;

	if (psc->sc_io_window == -1)
		/* Nothing to detach. */
		return (0);

	if (psc->sc_powerhook != NULL)
		powerhook_disestablish(psc->sc_powerhook);

	error = awi_detach(&psc->sc_awi);
	if (error != 0)
		return (error);

	/* Unmap our memory window and free memory space */
	if (psc->sc_mem_window != -1) {
		pcmcia_mem_unmap(psc->sc_pf, psc->sc_mem_window);
		pcmcia_mem_free(psc->sc_pf, &psc->sc_memh);
	}
d375 7
d383 3
d388 8
a395 3
static void
awi_pcmcia_powerhook(why, arg)
	int why;
d398 2
a399 2
	struct awi_pcmcia_softc *psc = arg;
	struct awi_softc *sc = &psc->sc_awi;
d401 15
a415 1
	awi_power(sc, why);
@


1.2.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.2.2.1 2001/05/14 22:26:06 niklas Exp $ */
d114 2
a115 2
	u_int16_t	app_vendor;	/* vendor ID */
	u_int16_t	app_product;	/* product ID */
@


1.2.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d2 1
a2 1
/* $OpenBSD: if_awi_pcmcia.c,v 1.2.2.2 2001/07/04 10:43:22 niklas Exp $ */
d188 1
a188 2
	sc->sc_ih = pcmcia_intr_establish(pf, IPL_NET, awi_intr,
	    sc, sc->sc_dev.dv_xname);
d349 1
a349 2
	sc->sc_ih = pcmcia_intr_establish(psc->sc_pf, IPL_NET,
	    awi_intr, sc, "");
@


1.2.2.4
log
@Merge in -current from roughly a week ago
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d98 6
a103 6
static int awi_pcmcia_match(struct device *, void *, void *);
static void awi_pcmcia_attach(struct device *, struct device *, void *);
static int awi_pcmcia_detach(struct device *, int);
static int awi_pcmcia_enable(struct awi_softc *);
static void awi_pcmcia_disable(struct awi_softc *);
static void awi_pcmcia_powerhook(int, void *);
d105 2
a106 2
static int	awi_pcmcia_find(struct awi_pcmcia_softc *,
    struct pcmcia_attach_args *, struct pcmcia_config_entry *);
d151 1
a151 1
	awi_pcmcia_lookup(struct pcmcia_attach_args *);
@


1.2.2.5
log
@Sync the SMP branch with 3.3
@
text
@d357 1
a357 1
	sc->sc_ifp = &sc->sc_arpcom.ac_if;
@


1.2.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d44 1
a44 1
 * This attachment can probably be trivially adapted for other FH and
@


1.1
log
@non-working awi driver; someone finish it
@
text
@d2 1
a2 1
/* $OpenBSD$ */
d215 1
a215 1
	DELAY(100);
d248 2
a250 1
	struct awi_pcmcia_get_enaddr_args pgea;
d253 1
d255 1
a255 1
#if 1
d300 1
a300 1
	
d304 2
a305 1
	
d320 1
@

