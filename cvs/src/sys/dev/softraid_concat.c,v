head	1.26;
access;
symbols
	OPENBSD_6_2_BASE:1.26
	OPENBSD_6_1:1.25.0.6
	OPENBSD_6_1_BASE:1.25
	OPENBSD_6_0:1.25.0.2
	OPENBSD_6_0_BASE:1.25
	OPENBSD_5_9:1.23.0.2
	OPENBSD_5_9_BASE:1.23
	OPENBSD_5_8:1.23.0.4
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.21.0.8
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.21.0.6
	OPENBSD_5_6_BASE:1.21
	OPENBSD_5_5:1.21.0.4
	OPENBSD_5_5_BASE:1.21
	OPENBSD_5_4:1.17.0.2
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.2.0.4
	OPENBSD_5_2_BASE:1.2
	OPENBSD_5_1_BASE:1.2
	OPENBSD_5_1:1.2.0.2;
locks; strict;
comment	@ * @;


1.26
date	2017.04.28.23.33.07;	author krw;	state Exp;
branches;
next	1.25;
commitid	KS2UGe2iTzRvvrTr;

1.25
date	2016.04.12.16.26.54;	author krw;	state Exp;
branches
	1.25.2.1
	1.25.6.1;
next	1.24;
commitid	ATfj2h1H9b585gss;

1.24
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.23;
commitid	1ISokwrtQ24zRrhW;

1.23
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.22;
commitid	TJiPw62Nfq0KhqBx;

1.22
date	2015.07.19.17.04.31;	author krw;	state Exp;
branches;
next	1.21;
commitid	WthDQr0yYlXab4V8;

1.21
date	2013.11.22.03.47.07;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2013.11.21.16.54.46;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2013.11.21.16.34.50;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2013.05.21.15.01.53;	author jsing;	state Exp;
branches;
next	1.15;

1.15
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2013.03.31.13.31.44;	author jsing;	state Exp;
branches;
next	1.13;

1.13
date	2013.03.31.11.12.06;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2013.03.30.02.02.14;	author jsing;	state Exp;
branches;
next	1.11;

1.11
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.10;

1.10
date	2013.03.02.12.25.55;	author jsing;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.18.11.14.48;	author jsing;	state Exp;
branches;
next	1.8;

1.8
date	2013.01.18.02.09.50;	author jsing;	state Exp;
branches;
next	1.7;

1.7
date	2013.01.17.02.43.50;	author jsing;	state Exp;
branches;
next	1.6;

1.6
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.5;

1.5
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.3;

1.3
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.2;

1.2
date	2012.01.22.11.13.32;	author jsing;	state Exp;
branches;
next	1.1;

1.1
date	2011.12.31.17.06.10;	author jsing;	state Exp;
branches;
next	;

1.25.2.1
date	2017.05.03.02.43.11;	author jsg;	state Exp;
branches;
next	;
commitid	SLwzu5yqCzb5LLjG;

1.25.6.1
date	2017.05.03.02.36.29;	author jsg;	state Exp;
branches;
next	;
commitid	QdXvViH8dvRWXFgT;


desc
@@


1.26
log
@Restore calculation of volume size. Accidentally removed in
r1.25. Fixes creation of concat volumes.

Noticed by and diff from Thordur I. Bjornsson via tech@@

ok jsing@@
@
text
@/* $OpenBSD: softraid_concat.c,v 1.25 2016/04/12 16:26:54 krw Exp $ */
/*
 * Copyright (c) 2008 Marco Peereboom <marco@@peereboom.us>
 * Copyright (c) 2011 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/queue.h>
#include <sys/sensors.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>

/* CONCAT functions. */
int	sr_concat_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_concat_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_concat_init(struct sr_discipline *);
int	sr_concat_rw(struct sr_workunit *);

/* Discipline initialisation. */
void
sr_concat_discipline_init(struct sr_discipline *sd)
{
	/* Fill out discipline members. */
	sd->sd_type = SR_MD_CONCAT;
	strlcpy(sd->sd_name, "CONCAT", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE |
	    SR_CAP_NON_COERCED;
	sd->sd_max_wu = SR_CONCAT_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_assemble = sr_concat_assemble;
	sd->sd_create = sr_concat_create;
	sd->sd_scsi_rw = sr_concat_rw;
}

int
sr_concat_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	int i;

	if (no_chunk < 2) {
		sr_error(sd->sd_sc, "%s requires two or more chunks",
		    sd->sd_name);
		return EINVAL;
        }
	
	sd->sd_meta->ssdi.ssd_size = 0;
	for (i = 0; i < no_chunk; i++) {
		sd->sd_meta->ssdi.ssd_size +=
		    sd->sd_vol.sv_chunks[i]->src_size;
	}

	return sr_concat_init(sd);
}

int
sr_concat_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{
	return sr_concat_init(sd);
}

int
sr_concat_init(struct sr_discipline *sd)
{
	sd->sd_max_ccb_per_wu = SR_CONCAT_NOWU * sd->sd_meta->ssdi.ssd_chunk_no;

	return 0;
}

int
sr_concat_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	daddr_t			blkno;
	int64_t			lbaoffs, offset;
	int64_t			no_chunk, chunkend, chunk, chunksize;
	int64_t			length, leftover;
	u_int8_t		*data;

	/* blkno and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blkno, "sr_concat_rw"))
		goto bad;

	no_chunk = sd->sd_meta->ssdi.ssd_chunk_no;

	DNPRINTF(SR_D_DIS, "%s: %s: front end io: blkno %lld size %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    (long long)blkno, xs->datalen);

	/* All offsets are in bytes. */
	lbaoffs = blkno << DEV_BSHIFT;
	leftover = xs->datalen;
	data = xs->data;
	for (;;) {

		chunkend = 0;
		offset = lbaoffs;
		for (chunk = 0; chunk < no_chunk; chunk++) {
			chunksize = sd->sd_vol.sv_chunks[chunk]->src_size <<
			    DEV_BSHIFT;
			chunkend += chunksize;
			if (lbaoffs < chunkend)
				break;
			offset -= chunksize;
		}
		if (lbaoffs > chunkend)
			goto bad;

		length = MIN(MIN(leftover, chunkend - lbaoffs), MAXPHYS);

		/* make sure chunk is online */
		scp = sd->sd_vol.sv_chunks[chunk];
		if (scp->src_meta.scm_status != BIOC_SDONLINE)
			goto bad;

		DNPRINTF(SR_D_DIS, "%s: %s %s io lbaoffs %lld "
		    "chunk %lld chunkend %lld offset %lld length %lld "
		    "leftover %lld data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name,
		    lbaoffs, chunk, chunkend, offset, length, leftover, data);

		blkno = offset >> DEV_BSHIFT;
		ccb = sr_ccb_rw(sd, chunk, blkno, length, data, xs->flags, 0);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);
			goto bad;
		}
		sr_wu_enqueue_ccb(wu, ccb);

		leftover -= length;
		if (leftover == 0)
			break;
		data += length;
		lbaoffs += length;
	}

	sr_schedule_wu(wu);

	return (0);

bad:
	/* wu is unwound by sr_wu_put */
	return (1);
}
@


1.25
log
@No need to rescan chunks in each discipline to find appropriate
volume sector size.  Determine volume sector size in sr_meta_init().

Pointed out, tweaked and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.24 2016/04/04 18:48:39 krw Exp $ */
d63 2
d70 6
@


1.25.2.1
log
@OpenBSD 6.0 errata 21, May 1, 2017

softraid(4) was unable to create usable concat volumes because
it always set the size of the volume to zero sectors.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.25 2016/04/12 16:26:54 krw Exp $ */
a62 2
	int i;

a67 6
	
	sd->sd_meta->ssdi.ssd_size = 0;
	for (i = 0; i < no_chunk; i++) {
		sd->sd_meta->ssdi.ssd_size +=
		    sd->sd_vol.sv_chunks[i]->src_size;
	}
@


1.25.6.1
log
@OpenBSD 6.1 errata 004, May 2, 2017

softraid(4) was unable to create usable concat volumes because
it always set the size of the volume to zero sectors.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.25 2016/04/12 16:26:54 krw Exp $ */
a62 2
	int i;

a67 6
	
	sd->sd_meta->ssdi.ssd_size = 0;
	for (i = 0; i < no_chunk; i++) {
		sd->sd_meta->ssdi.ssd_size +=
		    sd->sd_vol.sv_chunks[i]->src_size;
	}
@


1.24
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.23 2015/07/21 03:30:51 krw Exp $ */
a62 3
	int			i;
	u_int32_t		secsize;

a67 10

	sd->sd_meta->ssdi.ssd_size = 0;
	secsize = 0;
	for (i = 0; i < no_chunk; i++) {
		if (sd->sd_vol.sv_chunks[i]->src_secsize > secsize)
			secsize = sd->sd_vol.sv_chunks[i]->src_secsize;
		sd->sd_meta->ssdi.ssd_size +=
		    sd->sd_vol.sv_chunks[i]->src_size;
	}
	sd->sd_meta->ssdi.ssd_secsize = secsize;
@


1.23
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.22 2015/07/19 17:04:31 krw Exp $ */
d64 1
d73 4
a76 1
	for (i = 0; i < no_chunk; i++)
d79 2
@


1.22
log
@Stop adding and subtracting data offset. Just keep to chunk relative
block offsets until actual i/o is constructed and needs the physical
offset. Eliminate a number of <<DEV_BSIZE shifts as a bonus.

No intentional functional change.

Fixed and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.21 2013/11/22 03:47:07 krw Exp $ */
d101 2
a102 2
	daddr_t			blk;
	int64_t			lbaoffs, physoffs;
d107 2
a108 2
	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_concat_rw"))
d113 1
a113 1
	DNPRINTF(SR_D_DIS, "%s: %s: front end io: lba %lld size %d\n",
d115 1
a115 1
	    (long long)blk, xs->datalen);
d118 1
a118 1
	lbaoffs = blk << DEV_BSHIFT;
d124 1
a124 1
		physoffs = lbaoffs;
d131 1
a131 1
			physoffs -= chunksize;
d144 1
a144 1
		    "chunk %lld chunkend %lld physoffs %lld length %lld "
d147 1
a147 1
		    lbaoffs, chunk, chunkend, physoffs, length, leftover, data);
d149 2
a150 2
		blk = physoffs >> DEV_BSHIFT;
		ccb = sr_ccb_rw(sd, chunk, blk, length, data, xs->flags, 0);
@


1.21
log
@Stray missing (long long) on a daddr_t variable being printed.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.20 2013/11/21 16:54:46 krw Exp $ */
a136 1
		physoffs += sd->sd_meta->ssd_data_offset << DEV_BSHIFT;
@


1.20
log
@Don't cast int64_t variables to (long long) when using %lld.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.19 2013/11/21 16:34:50 krw Exp $ */
d115 1
a115 1
	    blk, xs->datalen);
@


1.19
log
@Change a bunch of daddr_t variables that don't (obviously) contain
512-byte-block information to int64_t, the underlying type of
daddr_t at the moment. No change to .o files. Removal of now
unneeded (long long) casts is next.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.18 2013/11/01 17:36:19 krw Exp $ */
d148 1
a148 3
		    (long long)lbaoffs, (long long)chunk, (long long)chunkend,
		    (long long)physoffs, (long long)length, (long long)leftover,
		    data);
@


1.18
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.17 2013/06/11 16:42:13 deraadt Exp $ */
d101 4
a104 3
	daddr_t			blk, lbaoffs, chunk, chunksize;
	daddr_t			no_chunk, chunkend, physoffs;
	daddr_t			length, leftover;
@


1.17
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.16 2013/05/21 15:01:53 jsing Exp $ */
d147 3
a149 1
		    lbaoffs, chunk, chunkend, physoffs, length, leftover, data);
@


1.16
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.15 2013/03/31 15:44:52 jsing Exp $ */
d101 3
a103 3
	daddr64_t		blk, lbaoffs, chunk, chunksize;
	daddr64_t		no_chunk, chunkend, physoffs;
	daddr64_t		length, leftover;
@


1.15
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.14 2013/03/31 13:31:44 jsing Exp $ */
a100 1
	int			s;
d166 1
a166 1
	s = splbio();
d168 1
a168 2
	if (!sr_check_io_collision(wu))
		sr_raid_startwu(wu);
a169 2
	splx(s);
	return (0);
@


1.14
log
@More runtime value initialisation functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.13 2013/03/31 11:12:06 jsing Exp $ */
d66 2
a67 1
		sr_error(sd->sd_sc, "CONCAT requires two or more chunks");
@


1.13
log
@Provide default resource allocation and free functions. Convert all
disciplines except for AOE and CRYPTO, which require custom handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.12 2013/03/30 02:02:14 jsing Exp $ */
d39 1
a73 1
	sd->sd_max_ccb_per_wu = SR_CONCAT_NOWU * no_chunk;
d75 1
a75 1
	return 0;
d82 7
a88 1
	sd->sd_max_ccb_per_wu = SR_CONCAT_NOWU * no_chunk;
@


1.12
log
@Provide a default discipline interrupt handling function and migrate all of
the disciplines that now have the same interrupt code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.11 2013/03/02 12:50:01 jsing Exp $ */
a38 2
int	sr_concat_alloc_resources(struct sr_discipline *);
int	sr_concat_free_resources(struct sr_discipline *);
a52 1
	sd->sd_alloc_resources = sr_concat_alloc_resources;
a54 1
	sd->sd_free_resources = sr_concat_free_resources;
a84 33
}

int
sr_concat_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_concat_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_wu_alloc(sd))
		goto bad;
	if (sr_ccb_alloc(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_concat_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_concat_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_free(sd);
	sr_ccb_free(sd);

	rv = 0;
	return (rv);
@


1.11
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.10 2013/03/02 12:25:55 jsing Exp $ */
a41 1
void	sr_concat_intr(struct buf *);
a59 1
	sd->sd_scsi_intr = sr_concat_intr;
a206 20
}

void
sr_concat_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
#ifdef SR_DEBUG
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
#endif
	int			s;

	DNPRINTF(SR_D_INTR, "%s: %s %s intr bp %x xs %x\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name, bp, xs);

	s = splbio();
	sr_ccb_done(ccb);
	sr_wu_done(wu);
	splx(s);
@


1.10
log
@Unbreak softraid compilation with debug enabled.

Prompted by Dmitry Bogdan.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.9 2013/01/18 11:14:48 jsing Exp $ */
a87 1

a97 3
	if (!sd)
		return (rv);

a114 3

	if (!sd)
		return (rv);
@


1.9
log
@Convert softraid concat to new workunit completion functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.7 2013/01/17 02:43:50 jsing Exp $ */
d230 1
a230 1
	    DEVNAME(sd->sd_sc), sd->ssd_meta.ssd_devname, sd->sd_name, bp, xs);
@


1.8
log
@Clean up and rework workunit completion for concat. Ensure that we remove
the workunit from the pending queue and restart deferred workunits, even
in error conditions.

ok krw@@
@
text
@d183 6
d222 2
a223 1
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
d226 1
a226 1
	struct sr_softc		*sc = sd->sd_sc;
d229 2
a230 2
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
	    DEVNAME(sc), bp, xs);
a232 1

d234 1
a234 35

	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete >= wu->swu_io_count) {
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link)
			if (wup == wu)
				break;

		if (wup == NULL)
			panic("%s: wu %p not on pending queue\n",
			    DEVNAME(sc), wu);
			
		TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

		if (wu->swu_collider) {
			/* restart deferred wu */
			wu->swu_collider->swu_state = SR_WU_INPROGRESS;
			TAILQ_REMOVE(&sd->sd_wu_defq,
			    wu->swu_collider, swu_link);
			sr_raid_startwu(wu->swu_collider);
		}

		if (wu->swu_ios_failed)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;

		sr_scsi_done(sd, xs);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

@


1.7
log
@Convert softraid concat to the new ccb functions.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.6 2013/01/16 06:42:22 jsing Exp $ */
d220 1
a220 1
	int			s, pend;
d234 3
a236 2
		if (wu->swu_ios_failed)
			goto bad;
d238 5
a242 1
		xs->error = XS_NOERROR;
d244 6
a249 17
		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
d252 4
a255 3
		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);
a262 5
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
	sr_scsi_done(sd, xs);
@


1.6
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.5 2013/01/15 09:28:29 jsing Exp $ */
d160 1
a160 1
	for (wu->swu_io_count = 1;; wu->swu_io_count++) {
d180 1
a180 1
		if (scp->src_meta.scm_status != BIOC_SDONLINE) {
a181 1
		}
d183 2
a184 1
		ccb = sr_ccb_get(sd);
d188 1
a188 2
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname);
d191 1
a191 33

		DNPRINTF(SR_D_DIS, "%s: %s concat io: lbaoffs: %lld "
		    "chunk: %lld chunkend: %lld physoffs: %lld length: %lld "
		    "leftover: %lld data: %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, lbaoffs,
		    chunk, chunkend, physoffs, length, leftover, data);

		ccb->ccb_buf.b_flags = B_CALL | B_PHYS;
		ccb->ccb_buf.b_iodone = sr_concat_intr;
		ccb->ccb_buf.b_blkno = physoffs >> DEV_BSHIFT;
		ccb->ccb_buf.b_bcount = length;
		ccb->ccb_buf.b_bufsize = length;
		ccb->ccb_buf.b_resid = length;
		ccb->ccb_buf.b_data = data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_buf.b_bq = NULL;
		ccb->ccb_wu = wu;
		ccb->ccb_buf.b_flags |= xs->flags & SCSI_DATA_IN ?
		    B_READ : B_WRITE;
		ccb->ccb_target = chunk;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[chunk]->src_dev_mm;
		ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[chunk]->src_vn;
		if ((ccb->ccb_buf.b_flags & B_READ) == 0)
			ccb->ccb_buf.b_vp->v_numoutput++;
		LIST_INIT(&ccb->ccb_buf.b_dep);
		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_concat: b_bcount: %d "
		    "b_blkno: %lld b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
a224 5
	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %lld target: %d\n", DEVNAME(sc),
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);

d227 1
a227 18
	if (ccb->ccb_buf.b_flags & B_ERROR) {
		printf("%s: i/o error on block %lld target: %d b_error: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target,
		    ccb->ccb_buf.b_error);
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;
@


1.5
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.4 2013/01/15 04:03:01 jsing Exp $ */
a292 1
		xs->resid = 0;
@


1.4
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.3 2012/10/08 14:22:41 jsing Exp $ */
a47 1

d50 1
a73 2

	strlcpy(sd->sd_name, "CONCAT", sizeof(sd->sd_name));
@


1.3
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_concat.c,v 1.22 2010/07/02 09:20:26 jsing Exp $ */
d61 1
@


1.2
log
@Convert softraid(4) to new bio(4) status interface. This allows bioctl(8)
to provide useful feedback, rather than reporting an ioctl failure and
leaving the user to consult dmesg. For now we continue to print most things
to the console, even if the message is a result of an ioctl.
@
text
@d38 1
a38 1
	    int);
d87 1
a87 1
    int no_chunk)
@


1.1
log
@Implement a concatenating discipline for softraid.

Many thanks to Marco Peereboom for his assistance with testing and
debugging. Thanks also to Josh Grosse and Chris Jackman for testing.
@
text
@d69 2
a70 1
	if (no_chunk < 2)
d72 1
@

