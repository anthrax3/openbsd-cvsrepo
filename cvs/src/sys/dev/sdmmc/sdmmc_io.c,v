head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.2
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.27.0.4
	OPENBSD_6_1_BASE:1.27
	OPENBSD_6_0:1.26.0.2
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.21.0.4
	OPENBSD_5_7_BASE:1.21
	OPENBSD_5_6:1.20.0.4
	OPENBSD_5_6_BASE:1.20
	OPENBSD_5_5:1.19.0.16
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.12
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.10
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.8
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.6
	OPENBSD_5_0:1.19.0.4
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.14.0.4
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.6.0.4
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.2
	OPENBSD_4_0_BASE:1.6;
locks; strict;
comment	@ * @;


1.29
date	2017.08.28.23.45.10;	author jsg;	state Exp;
branches;
next	1.28;
commitid	xmGDb7DdHfLSqWQH;

1.28
date	2017.04.06.17.00.53;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	ErQa7kV2NPST9FWp;

1.27
date	2016.09.11.10.22.16;	author mglocker;	state Exp;
branches;
next	1.26;
commitid	1exthGqFpOvDi5Q4;

1.26
date	2016.05.12.15.26.42;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	ptTgzt2Ivnv6hhsG;

1.25
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	tXZ4cDDS7O2NIM1F;

1.24
date	2016.05.04.09.30.06;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	nKwnMLLuwctt5XwF;

1.23
date	2016.04.23.14.15.59;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	jADeWYdQPb0qx2Ml;

1.22
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.21;
commitid	p4LJxGKbi0BU2cG6;

1.21
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.20;
commitid	uzzBR7hz9ncd4O6G;

1.20
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.19;
commitid	OBNa5kfxQ2UXoiIw;

1.19
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.18;

1.18
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2009.11.11.21.59.16;	author jasper;	state Exp;
branches;
next	1.16;

1.16
date	2009.10.03.18.42.36;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.07.15.20.52.04;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.29.19.42.09;	author mk;	state Exp;
branches;
next	1.13;

1.13
date	2009.04.07.16.35.52;	author blambert;	state Exp;
branches;
next	1.12;

1.12
date	2008.12.02.23.49.54;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.24.07.32.08;	author blambert;	state Exp;
branches;
next	1.10;

1.10
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.02.01.48.37;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2007.05.31.10.09.01;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.26.18.37.45;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.18.04.10.35;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.19.21.14.30;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.03.03.01.49;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.21.53.41;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.18.45.23;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Fix a memory leak in an error path.  Coverity CID 1453042.
ok visa@@
@
text
@/*	$OpenBSD: sdmmc_io.c,v 1.28 2017/04/06 17:00:53 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Routines for SD I/O cards. */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/sdmmc/sdmmc_ioreg.h>
#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcvar.h>

struct sdmmc_intr_handler {
	struct sdmmc_softc *ih_softc;
	const char *ih_name;
	int (*ih_fun)(void *);
	void *ih_arg;
	TAILQ_ENTRY(sdmmc_intr_handler) entry;
};

int	sdmmc_submatch(struct device *, void *, void *);
int	sdmmc_print(void *, const char *);
int	sdmmc_io_rw_direct(struct sdmmc_softc *, struct sdmmc_function *,
	    int, u_char *, int);
int	sdmmc_io_rw_extended(struct sdmmc_softc *, struct sdmmc_function *,
	    int, u_char *, int, int);
int	sdmmc_io_xchg(struct sdmmc_softc *, struct sdmmc_function *,
	    int, u_char *);
void	sdmmc_io_reset(struct sdmmc_softc *);
int	sdmmc_io_send_op_cond(struct sdmmc_softc *, u_int32_t, u_int32_t *);

#ifdef SDMMC_DEBUG
#define DPRINTF(s)	printf s
#else
#define DPRINTF(s)	/**/
#endif

#ifdef SDMMC_DEBUG
int	sdmmc_verbose = 1;
#else
int	sdmmc_verbose = 0;
#endif

/*
 * Initialize SD I/O card functions (before memory cards).  The host
 * system and controller must support card interrupts in order to use
 * I/O functions.
 */
int
sdmmc_io_enable(struct sdmmc_softc *sc)
{
	u_int32_t host_ocr;
	u_int32_t card_ocr;

	rw_assert_wrlock(&sc->sc_lock);

	/* Set host mode to SD "combo" card. */
	SET(sc->sc_flags, SMF_SD_MODE|SMF_IO_MODE|SMF_MEM_MODE);

	/* Reset I/O functions. */
	sdmmc_io_reset(sc);

	/*
	 * Read the I/O OCR value, determine the number of I/O
	 * functions and whether memory is also present (a "combo
	 * card") by issuing CMD5.  SD memory-only and MMC cards
	 * do not respond to CMD5.
	 */
	if (sdmmc_io_send_op_cond(sc, 0, &card_ocr) != 0) {
		/* No SDIO card; switch to SD memory-only mode. */
		CLR(sc->sc_flags, SMF_IO_MODE);
		return 0;
	}

	/* Parse the additional bits in the I/O OCR value. */
	if (!ISSET(card_ocr, SD_IO_OCR_MEM_PRESENT)) {
		/* SDIO card without memory (not a "combo card"). */
		DPRINTF(("%s: no memory present\n", DEVNAME(sc)));
		CLR(sc->sc_flags, SMF_MEM_MODE);
	}
	sc->sc_function_count = SD_IO_OCR_NUM_FUNCTIONS(card_ocr);
	if (sc->sc_function_count == 0) {
		/* Useless SDIO card without any I/O functions. */
		DPRINTF(("%s: no I/O functions\n", DEVNAME(sc)));
		CLR(sc->sc_flags, SMF_IO_MODE);
		return 0;
	}
	card_ocr &= SD_IO_OCR_MASK;

	/* Set the lowest voltage supported by the card and host. */
	host_ocr = sdmmc_chip_host_ocr(sc->sct, sc->sch);
	if (sdmmc_set_bus_power(sc, host_ocr, card_ocr) != 0) {
		printf("%s: can't supply voltage requested by card\n",
		    DEVNAME(sc));
		return 1;
	}

	/* Send the new OCR value until all cards are ready. */
	if (sdmmc_io_send_op_cond(sc, host_ocr, NULL) != 0) {
		printf("%s: can't send I/O OCR\n", DEVNAME(sc));
		return 1;
	}
	return 0;
}

/*
 * Allocate sdmmc_function structures for SD card I/O function
 * (including function 0).
 */
void
sdmmc_io_scan(struct sdmmc_softc *sc)
{
	struct sdmmc_function *sf0, *sf;
	int i;

	rw_assert_wrlock(&sc->sc_lock);

	sf0 = sdmmc_function_alloc(sc);
	sf0->number = 0;
	if (sdmmc_set_relative_addr(sc, sf0) != 0) {
		printf("%s: can't set I/O RCA\n", DEVNAME(sc));
		sdmmc_function_free(sf0);
		return;
	}
	sc->sc_fn0 = sf0;
	SIMPLEQ_INSERT_TAIL(&sc->sf_head, sf0, sf_list);

	/* Verify that the RCA has been set by selecting the card. */
	if (sdmmc_select_card(sc, sf0) != 0) {
		printf("%s: can't select I/O RCA %d\n", DEVNAME(sc),
		    sf0->rca);
		SET(sf0->flags, SFF_ERROR);
		return;
	}

	for (i = 1; i <= sc->sc_function_count; i++) {
		sf = sdmmc_function_alloc(sc);
		sf->number = i;
		sf->rca = sf0->rca;

		SIMPLEQ_INSERT_TAIL(&sc->sf_head, sf, sf_list);
	}
}

/*
 * Initialize SDIO card functions.
 */
int
sdmmc_io_init(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	rw_assert_wrlock(&sc->sc_lock);

	if (sdmmc_read_cis(sf, &sf->cis) != 0) {
		printf("%s: can't read CIS\n", DEVNAME(sc));
		SET(sf->flags, SFF_ERROR);
		return 1;
	}

	sdmmc_check_cis_quirks(sf);

	if (sdmmc_verbose)
		sdmmc_print_cis(sf);

	if (sf->number == 0) {
		/* XXX respect host and card capabilities */
		(void)sdmmc_chip_bus_clock(sc->sct, sc->sch,
		    25000, SDMMC_TIMING_LEGACY);
	}

	return 0;
}

/*
 * Indicate whether the function is ready to operate.
 */
int
sdmmc_io_function_ready(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_function *sf0 = sc->sc_fn0;
	u_int8_t rv;

	rw_assert_wrlock(&sc->sc_lock);

	if (sf->number == 0)
		return 1;	/* FN0 is always ready */

	rv = sdmmc_io_read_1(sf0, SD_IO_CCCR_FN_READY);

	return (rv & (1 << sf->number)) != 0;
}

/*
 * Enable the I/O function.  Return zero if the function was
 * enabled successfully.
 */
int
sdmmc_io_function_enable(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_function *sf0 = sc->sc_fn0;
	u_int8_t rv;
	int retry = 5;

	if (sf->number == 0)
		return 0;	/* FN0 is always enabled */

	rw_enter_write(&sc->sc_lock);
	rv = sdmmc_io_read_1(sf0, SD_IO_CCCR_FN_ENABLE);
	rv |= (1<<sf->number);
	sdmmc_io_write_1(sf0, SD_IO_CCCR_FN_ENABLE, rv);
	rw_exit(&sc->sc_lock);

	while (!sdmmc_io_function_ready(sf) && retry-- > 0)
		tsleep(&lbolt, PPAUSE, "pause", 0);
	return (retry >= 0) ? 0 : ETIMEDOUT;
}

/*
 * Disable the I/O function.  Return zero if the function was
 * disabled successfully.
 */
void
sdmmc_io_function_disable(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_function *sf0 = sc->sc_fn0;
	u_int8_t rv;

	rw_assert_wrlock(&sc->sc_lock);

	if (sf->number == 0)
		return;		/* FN0 is always enabled */

	rv = sdmmc_io_read_1(sf0, SD_IO_CCCR_FN_ENABLE);
	rv &= ~(1<<sf->number);
	sdmmc_io_write_1(sf0, SD_IO_CCCR_FN_ENABLE, rv);
}

void
sdmmc_io_attach(struct sdmmc_softc *sc)
{
	struct sdmmc_function *sf;
	struct sdmmc_attach_args saa;

	rw_assert_wrlock(&sc->sc_lock);

	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		if (sf->number < 1)
			continue;

		bzero(&saa, sizeof saa);
		saa.sf = sf;

		sf->child = config_found_sm(&sc->sc_dev, &saa, sdmmc_print,
		    sdmmc_submatch);
	}
}

int
sdmmc_submatch(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;

	/* Skip the scsibus, it is configured directly. */
	if (strcmp(cf->cf_driver->cd_name, "scsibus") == 0)
		return 0;

	return cf->cf_attach->ca_match(parent, cf, aux);
}

int
sdmmc_print(void *aux, const char *pnp)
{
	struct sdmmc_attach_args *sa = aux;
	struct sdmmc_function *sf = sa->sf;
	struct sdmmc_cis *cis = &sf->sc->sc_fn0->cis;
	int i;

	if (pnp) {
		if (sf->number == 0)
			return QUIET;

		for (i = 0; i < 4 && cis->cis1_info[i]; i++)
			printf("%s%s", i ? ", " : "\"", cis->cis1_info[i]);
		if (i != 0)
			printf("\"");

		if (cis->manufacturer != SDMMC_VENDOR_INVALID &&
		    cis->product != SDMMC_PRODUCT_INVALID) {
			printf("%s(", i ? " " : "");
			if (cis->manufacturer != SDMMC_VENDOR_INVALID)
				printf("manufacturer 0x%x%s",
				    cis->manufacturer,
				    cis->product == SDMMC_PRODUCT_INVALID ?
				    "" : ", ");
			if (cis->product != SDMMC_PRODUCT_INVALID)
				printf("product 0x%x", cis->product);
			printf(")");
		}
		printf("%sat %s", i ? " " : "", pnp);
	}
	printf(" function %d", sf->number);

	if (!pnp) {
		for (i = 0; i < 3 && cis->cis1_info[i]; i++)
			printf("%s%s", i ? ", " : " \"", cis->cis1_info[i]);
		if (i != 0)
			printf("\"");
	}
	return UNCONF;
}

void
sdmmc_io_detach(struct sdmmc_softc *sc)
{
	struct sdmmc_function *sf;

	rw_assert_wrlock(&sc->sc_lock);

	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		if (sf->child != NULL) {
			config_detach(sf->child, DETACH_FORCE);
			sf->child = NULL;
		}
	}

	KASSERT(TAILQ_EMPTY(&sc->sc_intrq));
}

int
sdmmc_io_rw_direct(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int reg, u_char *datap, int arg)
{
	struct sdmmc_command cmd;
	int error;

	rw_assert_wrlock(&sc->sc_lock);

	/* Make sure the card is selected. */
	if ((error = sdmmc_select_card(sc, sf)) != 0) {
		rw_exit(&sc->sc_lock);
		return error;
	}

	arg |= ((sf == NULL ? 0 : sf->number) & SD_ARG_CMD52_FUNC_MASK) <<
	    SD_ARG_CMD52_FUNC_SHIFT;
	arg |= (reg & SD_ARG_CMD52_REG_MASK) <<
	    SD_ARG_CMD52_REG_SHIFT;
	arg |= (*datap & SD_ARG_CMD52_DATA_MASK) <<
	    SD_ARG_CMD52_DATA_SHIFT;

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = SD_IO_RW_DIRECT;
	cmd.c_arg = arg;
	cmd.c_flags = SCF_CMD_AC | SCF_RSP_R5;

	error = sdmmc_mmc_command(sc, &cmd);
	*datap = SD_R5_DATA(cmd.c_resp);

	return error;
}

/*
 * Useful values of `arg' to pass in are either SD_ARG_CMD53_READ or
 * SD_ARG_CMD53_WRITE.  SD_ARG_CMD53_INCREMENT may be ORed into `arg'
 * to access successive register locations instead of accessing the
 * same register many times.
 */
int
sdmmc_io_rw_extended(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int reg, u_char *datap, int datalen, int arg)
{
	struct sdmmc_command cmd;
	int error;

	rw_assert_wrlock(&sc->sc_lock);

#if 0
	/* Make sure the card is selected. */
	if ((error = sdmmc_select_card(sc, sf)) != 0) {
		rw_exit(&sc->sc_lock);
		return error;
	}
#endif

	arg |= ((sf == NULL ? 0 : sf->number) & SD_ARG_CMD53_FUNC_MASK) <<
	    SD_ARG_CMD53_FUNC_SHIFT;
	arg |= (reg & SD_ARG_CMD53_REG_MASK) <<
	    SD_ARG_CMD53_REG_SHIFT;
	arg |= (datalen & SD_ARG_CMD53_LENGTH_MASK) <<
	    SD_ARG_CMD53_LENGTH_SHIFT;

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = SD_IO_RW_EXTENDED;
	cmd.c_arg = arg;
	cmd.c_flags = SCF_CMD_AC | SCF_RSP_R5;
	cmd.c_data = datap;
	cmd.c_datalen = datalen;
	cmd.c_blklen = MIN(datalen, sdmmc_chip_host_maxblklen(sc->sct, sc->sch));

	if (!ISSET(arg, SD_ARG_CMD53_WRITE))
		cmd.c_flags |= SCF_CMD_READ;

	error = sdmmc_mmc_command(sc, &cmd);

	return error;
}

u_int8_t
sdmmc_io_read_1(struct sdmmc_function *sf, int reg)
{
	u_int8_t data = 0;

	rw_assert_wrlock(&sf->sc->sc_lock);
	
	(void)sdmmc_io_rw_direct(sf->sc, sf, reg, (u_char *)&data,
	    SD_ARG_CMD52_READ);
	return data;
}

void
sdmmc_io_write_1(struct sdmmc_function *sf, int reg, u_int8_t data)
{
	rw_assert_wrlock(&sf->sc->sc_lock);

	(void)sdmmc_io_rw_direct(sf->sc, sf, reg, (u_char *)&data,
	    SD_ARG_CMD52_WRITE);
}

u_int16_t
sdmmc_io_read_2(struct sdmmc_function *sf, int reg)
{
	u_int16_t data = 0;
	
	rw_assert_wrlock(&sf->sc->sc_lock);

	(void)sdmmc_io_rw_extended(sf->sc, sf, reg, (u_char *)&data, 2,
	    SD_ARG_CMD53_READ | SD_ARG_CMD53_INCREMENT);
	return data;
}

void
sdmmc_io_write_2(struct sdmmc_function *sf, int reg, u_int16_t data)
{
	rw_assert_wrlock(&sf->sc->sc_lock);

	(void)sdmmc_io_rw_extended(sf->sc, sf, reg, (u_char *)&data, 2,
	    SD_ARG_CMD53_WRITE | SD_ARG_CMD53_INCREMENT);
}

u_int32_t
sdmmc_io_read_4(struct sdmmc_function *sf, int reg)
{
	u_int32_t data = 0;
	
	rw_assert_wrlock(&sf->sc->sc_lock);

	(void)sdmmc_io_rw_extended(sf->sc, sf, reg, (u_char *)&data, 4,
	    SD_ARG_CMD53_READ | SD_ARG_CMD53_INCREMENT);
	return data;
}

void
sdmmc_io_write_4(struct sdmmc_function *sf, int reg, u_int32_t data)
{
	rw_assert_wrlock(&sf->sc->sc_lock);

	(void)sdmmc_io_rw_extended(sf->sc, sf, reg, (u_char *)&data, 4,
	    SD_ARG_CMD53_WRITE | SD_ARG_CMD53_INCREMENT);
}

int
sdmmc_io_read_multi_1(struct sdmmc_function *sf, int reg, u_char *data,
    int datalen)
{
	int error;

	rw_assert_wrlock(&sf->sc->sc_lock);

	while (datalen > SD_ARG_CMD53_LENGTH_MAX) {
		error = sdmmc_io_rw_extended(sf->sc, sf, reg, data,
		    SD_ARG_CMD53_LENGTH_MAX, SD_ARG_CMD53_READ);
		if (error)
			return error;
		data += SD_ARG_CMD53_LENGTH_MAX;
		datalen -= SD_ARG_CMD53_LENGTH_MAX;
	}

	return sdmmc_io_rw_extended(sf->sc, sf, reg, data, datalen,
	    SD_ARG_CMD53_READ);
}

int
sdmmc_io_write_multi_1(struct sdmmc_function *sf, int reg, u_char *data,
    int datalen)
{
	int error;

	rw_assert_wrlock(&sf->sc->sc_lock);

	while (datalen > SD_ARG_CMD53_LENGTH_MAX) {
		error = sdmmc_io_rw_extended(sf->sc, sf, reg, data,
		    SD_ARG_CMD53_LENGTH_MAX, SD_ARG_CMD53_WRITE);
		if (error)
			return error;
		data += SD_ARG_CMD53_LENGTH_MAX;
		datalen -= SD_ARG_CMD53_LENGTH_MAX;
	}

	return sdmmc_io_rw_extended(sf->sc, sf, reg, data, datalen,
	    SD_ARG_CMD53_WRITE);
}

int
sdmmc_io_xchg(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int reg, u_char *datap)
{

	rw_assert_wrlock(&sc->sc_lock);

	return sdmmc_io_rw_direct(sc, sf, reg, datap,
	    SD_ARG_CMD52_WRITE|SD_ARG_CMD52_EXCHANGE);
}

/*
 * Reset the I/O functions of the card.
 */
void
sdmmc_io_reset(struct sdmmc_softc *sc)
{
	u_int8_t data = CCCR_CTL_RES;

	rw_assert_wrlock(&sc->sc_lock);

	if (sdmmc_io_rw_direct(sc, NULL, SD_IO_CCCR_CTL, (u_char *)&data,
	    SD_ARG_CMD52_WRITE) == 0)
		sdmmc_delay(100000);
}

/*
 * Get or set the card's I/O OCR value (SDIO).
 */
int
sdmmc_io_send_op_cond(struct sdmmc_softc *sc, u_int32_t ocr, u_int32_t *ocrp)
{
	struct sdmmc_command cmd;
	int error;
	int i;

	rw_assert_wrlock(&sc->sc_lock);

	/*
	 * If we change the OCR value, retry the command until the OCR
	 * we receive in response has the "CARD BUSY" bit set, meaning
	 * that all cards are ready for identification.
	 */
	for (i = 0; i < 100; i++) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = SD_IO_SEND_OP_COND;
		cmd.c_arg = ocr;
		cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R4;

		error = sdmmc_mmc_command(sc, &cmd);
		if (error != 0)
			break;
		if (ISSET(MMC_R4(cmd.c_resp), SD_IO_OCR_MEM_READY) ||
		    ocr == 0)
			break;
		error = ETIMEDOUT;
		sdmmc_delay(10000);
	}
	if (error == 0 && ocrp != NULL)
		*ocrp = MMC_R4(cmd.c_resp);

	return error;
}

/*
 * Card interrupt handling
 */

void
sdmmc_intr_enable(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_function *sf0 = sc->sc_fn0;
	u_int8_t imask;

	rw_enter_write(&sc->sc_lock);
	imask = sdmmc_io_read_1(sf0, SD_IO_CCCR_INT_ENABLE);
	imask |= 1 << sf->number;
	sdmmc_io_write_1(sf0, SD_IO_CCCR_INT_ENABLE, imask);
	rw_exit(&sc->sc_lock);
}

void
sdmmc_intr_disable(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_function *sf0 = sc->sc_fn0;
	u_int8_t imask;

	rw_enter_write(&sc->sc_lock);
	imask = sdmmc_io_read_1(sf0, SD_IO_CCCR_INT_ENABLE);
	imask &= ~(1 << sf->number);
	sdmmc_io_write_1(sf0, SD_IO_CCCR_INT_ENABLE, imask);
	rw_exit(&sc->sc_lock);
}

/*
 * Establish a handler for the SDIO card interrupt.  Because the
 * interrupt may be shared with different SDIO functions, multiple
 * handlers can be established.
 */
void *
sdmmc_intr_establish(struct device *sdmmc, int (*fun)(void *),
    void *arg, const char *name)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)sdmmc;
	struct sdmmc_intr_handler *ih;
	int s;

	if (sc->sct->card_intr_mask == NULL)
		return NULL;

	ih = malloc(sizeof *ih, M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
	if (ih == NULL)
		return NULL;

	ih->ih_name = name;
	ih->ih_softc = sc;
	ih->ih_fun = fun;
	ih->ih_arg = arg;

	s = splhigh();
	if (TAILQ_EMPTY(&sc->sc_intrq)) {
		sdmmc_intr_enable(sc->sc_fn0);
		sdmmc_chip_card_intr_mask(sc->sct, sc->sch, 1);
	}
	TAILQ_INSERT_TAIL(&sc->sc_intrq, ih, entry);
	splx(s);
	return ih;
}

/*
 * Disestablish the given handler.
 */
void
sdmmc_intr_disestablish(void *cookie)
{
	struct sdmmc_intr_handler *ih = cookie;
	struct sdmmc_softc *sc = ih->ih_softc;
	int s;

	if (sc->sct->card_intr_mask == NULL)
		return;

	s = splhigh();
	TAILQ_REMOVE(&sc->sc_intrq, ih, entry);
	if (TAILQ_EMPTY(&sc->sc_intrq)) {
		sdmmc_chip_card_intr_mask(sc->sct, sc->sch, 0);
		sdmmc_intr_disable(sc->sc_fn0);
	}
	splx(s);

	free(ih, M_DEVBUF, sizeof *ih);
}

/*
 * Call established SDIO card interrupt handlers.  The host controller
 * must call this function from its own interrupt handler to handle an
 * SDIO interrupt from the card.
 */
void
sdmmc_card_intr(struct device *sdmmc)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)sdmmc;

	if (sc->sct->card_intr_mask == NULL)
		return;

	if (!sdmmc_task_pending(&sc->sc_intr_task))
		sdmmc_add_task(sc, &sc->sc_intr_task);
}

void
sdmmc_intr_task(void *arg)
{
	struct sdmmc_softc *sc = arg;
	struct sdmmc_intr_handler *ih;
	int s;

	s = splhigh();
	TAILQ_FOREACH(ih, &sc->sc_intrq, entry) {
		splx(s);

		/* XXX examine return value and do evcount stuff*/
		(void)ih->ih_fun(ih->ih_arg);

		s = splhigh();
	}
	sdmmc_chip_card_intr_ack(sc->sct, sc->sch);
	splx(s);
}
@


1.28
log
@Sizes for the remaining free() calls, and use mallocarray()
ok visa
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.27 2016/09/11 10:22:16 mglocker Exp $	*/
d140 1
a140 1
		SET(sf0->flags, SFF_ERROR);
@


1.27
log
@Get SDIO reset working.

Tested and ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.26 2016/05/12 15:26:42 kettenis Exp $	*/
d685 1
a685 1
	free(ih, M_DEVBUF, 0);
@


1.26
log
@Remove bogus rw_exit() call.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.25 2016/05/05 11:01:08 kettenis Exp $	*/
a115 3
	/* Reset I/O functions (again). */
	sdmmc_io_reset(sc);

d550 7
a556 4
#if 0 /* XXX command fails */
	(void)sdmmc_io_write(sc, NULL, SD_IO_REG_CCCR_CTL, CCCR_CTL_RES);
	sdmmc_delay(100000);
#endif
@


1.25
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.24 2016/05/04 09:30:06 kettenis Exp $	*/
d427 1
a427 1
	rw_exit(&sc->sc_lock);
@


1.24
log
@Add high-speed support for SD cards.  In theory this should double the
transfer rates to and from the card.  In practice the improvement will be
smaller, but I am seeing serious improvement in the read speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.23 2016/04/23 14:15:59 kettenis Exp $	*/
d188 1
a188 1
		    SDMMC_SDCLK_25MHZ);
@


1.23
log
@Implement reading of the CIS for functions 1-7.  Don't write a bogus bus width
value when initializing function 0, and correct a few related #defines.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.22 2015/03/14 03:38:49 jsg Exp $	*/
d184 6
@


1.22
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.21 2014/09/14 14:17:25 jsg Exp $	*/
d174 5
a178 9
	if (sf->number == 0) {
		sdmmc_io_write_1(sf, SD_IO_CCCR_BUS_WIDTH,
		    CCCR_BUS_WIDTH_1);

		if (sdmmc_read_cis(sf, &sf->cis) != 0) {
			printf("%s: can't read CIS\n", DEVNAME(sc));
			SET(sf->flags, SFF_ERROR);
			return 1;
		}
d180 4
a183 1
		sdmmc_check_cis_quirks(sf);
a184 3
		if (sdmmc_verbose)
			sdmmc_print_cis(sf);
	}
@


1.21
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.20 2014/07/12 18:48:52 tedu Exp $	*/
a28 1
#include <dev/sdmmc/sdmmcreg.h>
@


1.20
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.19 2010/08/24 14:52:23 blambert Exp $	*/
a24 1
#include <sys/proc.h>
@


1.19
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.18 2010/08/19 17:54:12 jasper Exp $	*/
d685 1
a685 1
	free(ih, M_DEVBUF);
@


1.18
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.17 2009/11/11 21:59:16 jasper Exp $	*/
d75 1
a75 1
	SDMMC_ASSERT_LOCKED(sc);
d139 1
a139 1
	SDMMC_ASSERT_LOCKED(sc);
d174 1
a174 1
	SDMMC_ASSERT_LOCKED(sc);
d204 1
a204 1
	SDMMC_ASSERT_LOCKED(sc);
d229 1
a229 1
	SDMMC_LOCK(sc);
d233 1
a233 1
	SDMMC_UNLOCK(sc);
d251 1
a251 1
	SDMMC_ASSERT_LOCKED(sc);
d267 1
a267 1
	SDMMC_ASSERT_LOCKED(sc);
d340 1
a340 1
	SDMMC_ASSERT_LOCKED(sc);
d359 1
a359 1
	SDMMC_ASSERT_LOCKED(sc);
d363 1
a363 1
		SDMMC_UNLOCK(sc);
d398 1
a398 1
	SDMMC_ASSERT_LOCKED(sc);
d403 1
a403 1
		SDMMC_UNLOCK(sc);
d427 1
a427 1
	SDMMC_UNLOCK(sc);
d436 1
a436 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d446 1
a446 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d457 1
a457 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d467 1
a467 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d478 1
a478 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d488 1
a488 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d500 1
a500 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d521 1
a521 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d541 1
a541 1
	SDMMC_ASSERT_LOCKED(sc);
d569 1
a569 1
	SDMMC_ASSERT_LOCKED(sc);
d608 1
a608 1
	SDMMC_LOCK(sc);
d612 1
a612 1
	SDMMC_UNLOCK(sc);
d622 1
a622 1
	SDMMC_LOCK(sc);
d626 1
a626 1
	SDMMC_UNLOCK(sc);
@


1.17
log
@fixup of locking issues with sdmmc, which were causing
"locking against myself" panics as found the hard way by
several. diff by blamert@@ with input from oga@@,
committing bret's behalf.

ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.16 2009/10/03 18:42:36 kettenis Exp $	*/
d98 1
a98 1
		DPRINTF(("%s: no memory present\n", SDMMCDEVNAME(sc)));
d104 1
a104 1
		DPRINTF(("%s: no I/O functions\n", SDMMCDEVNAME(sc)));
d114 1
a114 1
		    SDMMCDEVNAME(sc));
d123 1
a123 1
		printf("%s: can't send I/O OCR\n", SDMMCDEVNAME(sc));
d144 1
a144 1
		printf("%s: can't set I/O RCA\n", SDMMCDEVNAME(sc));
d153 1
a153 1
		printf("%s: can't select I/O RCA %d\n", SDMMCDEVNAME(sc),
d181 1
a181 1
			printf("%s: can't read CIS\n", SDMMCDEVNAME(sc));
@


1.16
log
@Add missing <sys/device.h>.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.15 2009/07/15 20:52:04 mk Exp $	*/
d204 2
d210 1
d251 2
a255 1
	SDMMC_LOCK(sc);
a258 1
	SDMMC_UNLOCK(sc);
d359 1
a359 1
	SDMMC_LOCK(sc);
a381 1
	SDMMC_UNLOCK(sc);
d398 1
a398 1
	SDMMC_LOCK(sc);
d435 2
d446 2
d457 2
d467 2
d478 2
d488 2
d500 2
d521 2
d540 3
@


1.15
log
@In sdmmc_intr_establish(), don't duplicate the `name' parameter.
Instead, just use the pointer, and don't free the pointer during
sdmmc_intr_disestablish().

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.14 2009/06/29 19:42:09 mk Exp $	*/
d22 1
@


1.14
log
@In sdmmc_intr_establish(), copy the entire name parameter instead of
dumping the last byte.

Input from otto@@ and peter@@.

ok on an earlier diff from miod (and krw IIRC).
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.13 2009/04/07 16:35:52 blambert Exp $	*/
d34 1
a34 1
	char *ih_name;
a618 1
	size_t namesz;
d627 1
a627 7
	namesz = strlen(name) + 1;
	ih->ih_name = malloc(namesz, M_DEVBUF, M_WAITOK | M_CANFAIL);
	if (ih->ih_name == NULL) {
		free(ih, M_DEVBUF);
		return NULL;
	}
	strlcpy(ih->ih_name, name, namesz);
a662 1
	free(ih->ih_name, M_DEVBUF);
@


1.13
log
@Remove recursion from the sdmmc locking regime.

In snaps for a while.

Originally hacked on phessler@@'s couch.
Testing by many, input from jsg@@

"I'm tired of seeing the Ms" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.12 2008/12/02 23:49:54 deraadt Exp $	*/
d619 1
d628 2
a629 1
	ih->ih_name = malloc(strlen(name), M_DEVBUF, M_WAITOK | M_CANFAIL);
d634 1
a634 1
	strlcpy(ih->ih_name, name, strlen(name));
@


1.12
log
@backout: would have been nice if this had been tested, to see that it
crashes the moment a card is plugged in.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.10 2007/09/17 01:33:33 krw Exp $	*/
d74 2
d138 2
d173 2
d263 2
d336 2
d547 1
a547 1
	SDMMC_LOCK(sc);
a571 1
	SDMMC_UNLOCK(sc);
@


1.11
log
@Rework sdmmc locking to remove recursion
Add SDMMC_ASSERT_LOCKED(), replacing many locking calls, and sprinkling
the assertion to make sure that future changes don't catch us out

"please commit" uwe@@
@
text
@a135 2
	SDMMC_ASSERT_LOCKED(sc);

d537 1
a537 1
	SDMMC_ASSERT_LOCKED(sc);
d562 1
@


1.10
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.9 2007/06/02 01:48:37 uwe Exp $	*/
d136 2
d539 1
a539 1
	SDMMC_LOCK(sc);
a563 1
	SDMMC_UNLOCK(sc);
@


1.9
log
@split up large CMD53 reads and writes
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.8 2007/05/31 10:09:01 uwe Exp $	*/
d614 1
a614 1
	ih = malloc(sizeof *ih, M_DEVBUF, M_WAITOK | M_CANFAIL);
a617 1
	bzero(ih, sizeof *ih);
@


1.8
log
@Add SDIO card interrupt handling code
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.7 2007/05/26 18:37:45 uwe Exp $	*/
d473 11
d492 11
@


1.7
log
@Wait until an I/O function becomes ready after enabling it, and make
sdmmc_io_rw_extended() non-incremental, by default.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.6 2006/07/18 04:10:35 uwe Exp $	*/
d23 1
d32 8
d334 2
d363 1
a363 1
	cmd.c_flags = SCF_CMD_BC/* XXX */ | SCF_RSP_R5;
d405 1
a405 1
	cmd.c_flags = SCF_CMD_ADTC/* XXX */ | SCF_RSP_R5;
d542 135
@


1.6
log
@First and foremost, avoid an obious race between two or more processes
trying to get MMC commands through to the SD/MMC host controller via the
emulated SCSI layer.  This is achieved by ensuring exclusive access to
the host controller for one process during any MMC command and during a
sequence of commands at the sdmmc(4) layer.

While at it, the command processing thread has been moved to sdmmc(4),
so as to simplify the implementation of future host controller drivers.
This should also pave the way for further cleanup of the code and for
new drivers.

Minor cleanups are included in this commit, as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.5 2006/06/19 21:14:30 miod Exp $	*/
d22 2
a36 2
int	sdmmc_io_write(struct sdmmc_softc *, struct sdmmc_function *,
	    int, u_char);
d161 1
a161 1
		(void)sdmmc_io_write(sc, sf, SD_IO_CCCR_BUS_WIDTH,
d178 22
a199 1
void
d205 4
d215 4
d221 4
d232 3
d361 6
d376 1
d382 1
a385 1
	arg |= SD_ARG_CMD53_INCREMENT;
d394 1
a394 1
	cmd.c_flags = SCF_CMD_BC/* XXX */ | SCF_RSP_R5;
d397 2
a398 1
	cmd.c_blklen = datalen;
d430 1
a430 1
	    SD_ARG_CMD53_READ);
d438 1
a438 1
	    SD_ARG_CMD53_WRITE);
d447 1
a447 1
	    SD_ARG_CMD53_READ);
d455 9
a463 1
	    SD_ARG_CMD53_WRITE);
d467 2
a468 2
sdmmc_io_write(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int reg, u_char data)
d470 1
a470 1
	return sdmmc_io_rw_direct(sc, sf, reg, &data,
@


1.5
log
@Appease the printf gods here too
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.4 2006/06/03 03:01:49 uwe Exp $	*/
d181 2
a182 1
	struct sdmmc_function *sf0 = sf->sc->sc_fn0;
d185 1
d189 1
d195 2
a196 1
	struct sdmmc_function *sf0 = sf->sc->sc_fn0;
d199 1
d203 1
d298 2
d301 2
a302 1
	if ((error = sdmmc_select_card(sc, sf)) != 0)
d304 1
d320 2
d332 2
d335 2
a336 1
	if ((error = sdmmc_select_card(sc, sf)) != 0)
d338 1
d358 3
a360 1
	return sdmmc_mmc_command(sc, &cmd);
d452 2
d476 2
@


1.4
log
@- only call config_found for function number > 0
- always display the product information in sdmmc_print()
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.4 2006/06/03 03:02:56 u Exp $	*/
d165 1
a165 1
			printf("%s: can't read CIS\n");
@


1.3
log
@SDIO card identification
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.2 2006/05/28 18:45:23 uwe Exp $	*/
d207 3
d262 7
@


1.2
log
@don't #undef SDMMC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_io.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d24 1
d29 13
d48 6
d68 1
a68 1
	/* Reset I/O functions (*must* do that before CMD5). */
d83 9
a91 2
	if (SD_IO_OCR_NF(card_ocr) == 0) {
		/* No I/O functions. */
d93 1
d96 1
d118 2
a119 1
 * Send the "I/O RESET" command.
d122 184
a305 1
sdmmc_io_reset(struct sdmmc_softc *sc)
d308 13
d323 28
a350 2
	cmd.c_opcode = SD_IO_RESET;
	cmd.c_flags = SCF_CMD_BC | SCF_RSP_R0;
d352 60
a411 1
	(void)sdmmc_mmc_command(sc, &cmd);
d427 1
a427 1
	 * that all cards are ready for card identification.
a443 2
	if (error == 0)
		printf("ocr: %x\n", MMC_R4(cmd.c_resp));
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a26 2

#undef SDMMC_DEBUG
@

