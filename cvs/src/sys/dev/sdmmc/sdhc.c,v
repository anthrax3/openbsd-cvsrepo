head	1.55;
access;
symbols
	OPENBSD_6_2:1.55.0.2
	OPENBSD_6_2_BASE:1.55
	OPENBSD_6_1:1.53.0.4
	OPENBSD_6_1_BASE:1.53
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.38.0.6
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.37.0.4
	OPENBSD_5_5_BASE:1.37
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.34.0.6
	OPENBSD_5_2_BASE:1.34
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.4
	OPENBSD_5_0:1.34.0.2
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.33.0.2
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.25.0.4
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.6
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.2
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.21.0.2
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.11.0.2
	OPENBSD_4_0_BASE:1.11;
locks; strict;
comment	@ * @;


1.55
date	2017.05.05.15.10.07;	author kettenis;	state Exp;
branches;
next	1.54;
commitid	IbC6iWFApnXDx1Uv;

1.54
date	2017.04.06.03.15.29;	author deraadt;	state Exp;
branches;
next	1.53;
commitid	gHgDmKzMHGPreBpA;

1.53
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.52;
commitid	CHRb0fCqa8XxUAMH;

1.52
date	2016.05.15.22.21.55;	author kettenis;	state Exp;
branches;
next	1.51;
commitid	yFibV1gOeNbxfWaL;

1.51
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.50;
commitid	tXZ4cDDS7O2NIM1F;

1.50
date	2016.05.04.14.05.32;	author kettenis;	state Exp;
branches;
next	1.49;
commitid	6foZUVTmx0CPCX6a;

1.49
date	2016.05.01.22.06.32;	author kettenis;	state Exp;
branches;
next	1.48;
commitid	SGIzmLw3IPj1HzN2;

1.48
date	2016.05.01.18.29.44;	author kettenis;	state Exp;
branches;
next	1.47;
commitid	oONNV7TyLsILUk2X;

1.47
date	2016.05.01.17.13.55;	author kettenis;	state Exp;
branches;
next	1.46;
commitid	0lWQBsHRzMTYEGIf;

1.46
date	2016.05.01.16.04.39;	author kettenis;	state Exp;
branches;
next	1.45;
commitid	rwmsBKqrjX2EodCO;

1.45
date	2016.04.30.13.33.35;	author kettenis;	state Exp;
branches;
next	1.44;
commitid	y3uQCNW4nj2l0pKr;

1.44
date	2016.04.30.11.32.23;	author kettenis;	state Exp;
branches;
next	1.43;
commitid	idV1JJlqFozdGODX;

1.43
date	2016.03.30.09.58.01;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	mzVnWVPSZkHcdcYj;

1.42
date	2016.03.27.18.49.41;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	eGPDZ3Cd83oVinOi;

1.41
date	2016.01.11.06.54.53;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	EvaZ1NgVtehxqcxu;

1.40
date	2016.01.10.14.11.43;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	hXWKWq7NLwPiJ2vl;

1.39
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.38;
commitid	p4LJxGKbi0BU2cG6;

1.38
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.37;
commitid	OBNa5kfxQ2UXoiIw;

1.37
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.31.21.28.32;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2011.07.31.16.55.01;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2010.08.31.17.13.47;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2010.08.31.16.25.28;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2010.08.27.15.41.43;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2010.08.27.04.09.20;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.02.18.05.28;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.02.09.21.58;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2009.01.13.19.44.20;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.06.08.01.01;	author jsg;	state Exp;
branches;
next	1.21;

1.21
date	2007.05.31.23.37.21;	author uwe;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.31.10.09.01;	author uwe;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.26.19.04.24;	author uwe;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.11.10.04.59;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.31.12.54.47;	author claudio;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.28.03.03.12;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.11.29.14.05.45;	author uwe;	state Exp;
branches;
next	1.14;

1.14
date	2006.11.29.01.46.53;	author uwe;	state Exp;
branches;
next	1.13;

1.13
date	2006.11.29.00.52.37;	author uwe;	state Exp;
branches;
next	1.12;

1.12
date	2006.10.19.10.55.56;	author tom;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.30.16.40.27;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.19.23.56.03;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.18.04.10.35;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.17.20.50.58;	author fgsch;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.17.20.48.27;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.10.17.58.23;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.29.01.32.33;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.02.20.03.05;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.21.47.42;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.18.45.23;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.55
log
@Implement two quirks to support the Arasan eMMC 5.1 controller found on
the Rockchip RK3399.

- Make it possible to override sdhc_signal_voltage().

- Make it possible to disable double-data rate modes.

ok patrick@@
@
text
@/*	$OpenBSD: sdhc.c,v 1.54 2017/04/06 03:15:29 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * SD Host Controller driver based on the SD Host Controller Standard
 * Simplified Specification Version 1.00 (www.sdcard.com).
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <dev/sdmmc/sdhcreg.h>
#include <dev/sdmmc/sdhcvar.h>
#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcreg.h>
#include <dev/sdmmc/sdmmcvar.h>

#define SDHC_COMMAND_TIMEOUT	hz
#define SDHC_BUFFER_TIMEOUT	hz
#define SDHC_TRANSFER_TIMEOUT	hz
#define SDHC_DMA_TIMEOUT	(hz*3)

struct sdhc_host {
	struct sdhc_softc *sc;		/* host controller device */
	struct device *sdmmc;		/* generic SD/MMC device */
	bus_space_tag_t iot;		/* host register set tag */
	bus_space_handle_t ioh;		/* host register set handle */
	u_int16_t version;		/* specification version */
	u_int clkbase;			/* base clock frequency in KHz */
	int maxblklen;			/* maximum block length */
	int flags;			/* flags for this host */
	u_int32_t ocr;			/* OCR value from capabilities */
	u_int8_t regs[14];		/* host controller state */
	u_int16_t intr_status;		/* soft interrupt status */
	u_int16_t intr_error_status;	/* soft error status */

	bus_dmamap_t adma_map;
	bus_dma_segment_t adma_segs[1];
	caddr_t adma2;
};

/* flag values */
#define SHF_USE_DMA		0x0001

#define HREAD1(hp, reg)							\
	(bus_space_read_1((hp)->iot, (hp)->ioh, (reg)))
#define HREAD2(hp, reg)							\
	(bus_space_read_2((hp)->iot, (hp)->ioh, (reg)))
#define HREAD4(hp, reg)							\
	(bus_space_read_4((hp)->iot, (hp)->ioh, (reg)))
#define HWRITE1(hp, reg, val)						\
	bus_space_write_1((hp)->iot, (hp)->ioh, (reg), (val))
#define HWRITE2(hp, reg, val)						\
	bus_space_write_2((hp)->iot, (hp)->ioh, (reg), (val))
#define HWRITE4(hp, reg, val)						\
	bus_space_write_4((hp)->iot, (hp)->ioh, (reg), (val))
#define HCLR1(hp, reg, bits)						\
	HWRITE1((hp), (reg), HREAD1((hp), (reg)) & ~(bits))
#define HCLR2(hp, reg, bits)						\
	HWRITE2((hp), (reg), HREAD2((hp), (reg)) & ~(bits))
#define HSET1(hp, reg, bits)						\
	HWRITE1((hp), (reg), HREAD1((hp), (reg)) | (bits))
#define HSET2(hp, reg, bits)						\
	HWRITE2((hp), (reg), HREAD2((hp), (reg)) | (bits))

int	sdhc_host_reset(sdmmc_chipset_handle_t);
u_int32_t sdhc_host_ocr(sdmmc_chipset_handle_t);
int	sdhc_host_maxblklen(sdmmc_chipset_handle_t);
int	sdhc_card_detect(sdmmc_chipset_handle_t);
int	sdhc_bus_power(sdmmc_chipset_handle_t, u_int32_t);
int	sdhc_bus_clock(sdmmc_chipset_handle_t, int, int);
int	sdhc_bus_width(sdmmc_chipset_handle_t, int);
void	sdhc_card_intr_mask(sdmmc_chipset_handle_t, int);
void	sdhc_card_intr_ack(sdmmc_chipset_handle_t);
int	sdhc_signal_voltage(sdmmc_chipset_handle_t, int);
void	sdhc_exec_command(sdmmc_chipset_handle_t, struct sdmmc_command *);
int	sdhc_start_command(struct sdhc_host *, struct sdmmc_command *);
int	sdhc_wait_state(struct sdhc_host *, u_int32_t, u_int32_t);
int	sdhc_soft_reset(struct sdhc_host *, int);
int	sdhc_wait_intr(struct sdhc_host *, int, int);
void	sdhc_transfer_data(struct sdhc_host *, struct sdmmc_command *);
void	sdhc_read_data(struct sdhc_host *, u_char *, int);
void	sdhc_write_data(struct sdhc_host *, u_char *, int);

#ifdef SDHC_DEBUG
int sdhcdebug = 0;
#define DPRINTF(n,s)	do { if ((n) <= sdhcdebug) printf s; } while (0)
void	sdhc_dump_regs(struct sdhc_host *);
#else
#define DPRINTF(n,s)	do {} while(0)
#endif

struct sdmmc_chip_functions sdhc_functions = {
	/* host controller reset */
	sdhc_host_reset,
	/* host controller capabilities */
	sdhc_host_ocr,
	sdhc_host_maxblklen,
	/* card detection */
	sdhc_card_detect,
	/* bus power and clock frequency */
	sdhc_bus_power,
	sdhc_bus_clock,
	sdhc_bus_width,
	/* command execution */
	sdhc_exec_command,
	/* card interrupt */
	sdhc_card_intr_mask,
	sdhc_card_intr_ack,
	/* UHS functions */
	sdhc_signal_voltage
};

struct cfdriver sdhc_cd = {
	NULL, "sdhc", DV_DULL
};

/*
 * Called by attachment driver.  For each SD card slot there is one SD
 * host controller standard register set. (1.3)
 */
int
sdhc_host_found(struct sdhc_softc *sc, bus_space_tag_t iot,
    bus_space_handle_t ioh, bus_size_t iosize, int usedma, u_int32_t caps)
{
	struct sdmmcbus_attach_args saa;
	struct sdhc_host *hp;
	int error = 1;
	int max_clock;
#ifdef SDHC_DEBUG
	u_int16_t version;

	version = bus_space_read_2(iot, ioh, SDHC_HOST_CTL_VERSION);
	printf("%s: SD Host Specification/Vendor Version ",
	    sc->sc_dev.dv_xname);
	switch(SDHC_SPEC_VERSION(version)) {
	case 0x00:
		printf("1.0/%u\n", SDHC_VENDOR_VERSION(version));
		break;
	default:
		printf(">1.0/%u\n", SDHC_VENDOR_VERSION(version));
		break;
	}
#endif

	/* Allocate one more host structure. */
	sc->sc_nhosts++;
	hp = malloc(sizeof(*hp), M_DEVBUF, M_WAITOK | M_ZERO);
	sc->sc_host[sc->sc_nhosts - 1] = hp;

	/* Fill in the new host structure. */
	hp->sc = sc;
	hp->iot = iot;
	hp->ioh = ioh;

	/* Store specification version. */
	hp->version = bus_space_read_2(iot, ioh, SDHC_HOST_CTL_VERSION);

	/*
	 * Reset the host controller and enable interrupts.
	 */
	(void)sdhc_host_reset(hp);

	/* Determine host capabilities. */
	if (caps == 0)
		caps = HREAD4(hp, SDHC_CAPABILITIES);

	/* Use DMA if the host system and the controller support it. */
	if (usedma && ISSET(caps, SDHC_ADMA2_SUPP))
		SET(hp->flags, SHF_USE_DMA);

	/*
	 * Determine the base clock frequency. (2.2.24)
	 */
	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3) {
		/* SDHC 3.0 supports 10-255 MHz. */
		max_clock = 255000;
		if (SDHC_BASE_FREQ_KHZ_V3(caps) != 0)
			hp->clkbase = SDHC_BASE_FREQ_KHZ_V3(caps);
	} else {
		/* SDHC 1.0/2.0 supports only 10-63 MHz. */
		max_clock = 63000;
		if (SDHC_BASE_FREQ_KHZ(caps) != 0)
			hp->clkbase = SDHC_BASE_FREQ_KHZ(caps);
	}
	if (hp->clkbase == 0) {
		/* The attachment driver must tell us. */
		printf("%s: base clock frequency unknown\n",
		    sc->sc_dev.dv_xname);
		goto err;
	} else if (hp->clkbase < 10000 || hp->clkbase > max_clock) {
		printf("%s: base clock frequency out of range: %u MHz\n",
		    sc->sc_dev.dv_xname, hp->clkbase / 1000);
		goto err;
	}

	printf("%s: SDHC %d.0, %d MHz base clock\n", DEVNAME(sc),
	    SDHC_SPEC_VERSION(hp->version) + 1, hp->clkbase / 1000);

	/*
	 * XXX Set the data timeout counter value according to
	 * capabilities. (2.2.15)
	 */

	/*
	 * Determine SD bus voltage levels supported by the controller.
	 */
	if (ISSET(caps, SDHC_VOLTAGE_SUPP_1_8V))
		SET(hp->ocr, MMC_OCR_1_65V_1_95V);
	if (ISSET(caps, SDHC_VOLTAGE_SUPP_3_0V))
		SET(hp->ocr, MMC_OCR_2_9V_3_0V | MMC_OCR_3_0V_3_1V);
	if (ISSET(caps, SDHC_VOLTAGE_SUPP_3_3V))
		SET(hp->ocr, MMC_OCR_3_2V_3_3V | MMC_OCR_3_3V_3_4V);

	/*
	 * Determine the maximum block length supported by the host
	 * controller. (2.2.24)
	 */
	switch((caps >> SDHC_MAX_BLK_LEN_SHIFT) & SDHC_MAX_BLK_LEN_MASK) {
	case SDHC_MAX_BLK_LEN_512:
		hp->maxblklen = 512;
		break;
	case SDHC_MAX_BLK_LEN_1024:
		hp->maxblklen = 1024;
		break;
	case SDHC_MAX_BLK_LEN_2048:
		hp->maxblklen = 2048;
		break;
	default:
		hp->maxblklen = 1;
		break;
	}

	if (ISSET(hp->flags, SHF_USE_DMA)) {
		int rseg;

		/* Allocate ADMA2 descriptor memory */
		error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE,
		    PAGE_SIZE, hp->adma_segs, 1, &rseg,
		    BUS_DMA_WAITOK | BUS_DMA_ZERO);
		if (error)
			goto adma_done;
		error = bus_dmamem_map(sc->sc_dmat, hp->adma_segs, rseg,
		    PAGE_SIZE, &hp->adma2, BUS_DMA_WAITOK | BUS_DMA_COHERENT);
		if (error) {
			bus_dmamem_free(sc->sc_dmat, hp->adma_segs, rseg);
			goto adma_done;
		}
		error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, 1, PAGE_SIZE,
		    0, BUS_DMA_WAITOK, &hp->adma_map);
		if (error) {
			bus_dmamem_unmap(sc->sc_dmat, hp->adma2, PAGE_SIZE);
			bus_dmamem_free(sc->sc_dmat, hp->adma_segs, rseg);
			goto adma_done;
		}
		error = bus_dmamap_load(sc->sc_dmat, hp->adma_map,
		    hp->adma2, PAGE_SIZE, NULL,
		    BUS_DMA_WAITOK | BUS_DMA_WRITE);
		if (error) {
			bus_dmamap_destroy(sc->sc_dmat, hp->adma_map);
			bus_dmamem_unmap(sc->sc_dmat, hp->adma2, PAGE_SIZE);
			bus_dmamem_free(sc->sc_dmat, hp->adma_segs, rseg);
			goto adma_done;
		}

	adma_done:
		if (error) {
			printf("%s: can't allocate DMA descriptor table\n",
			    DEVNAME(hp->sc));
			CLR(hp->flags, SHF_USE_DMA);
		}
	}

	/*
	 * Attach the generic SD/MMC bus driver.  (The bus driver must
	 * not invoke any chipset functions before it is attached.)
	 */
	bzero(&saa, sizeof(saa));
	saa.saa_busname = "sdmmc";
	saa.sct = &sdhc_functions;
	saa.sch = hp;
	saa.caps = SMC_CAPS_4BIT_MODE;
	saa.dmat = sc->sc_dmat;
	if (ISSET(hp->flags, SHF_USE_DMA))
		saa.caps |= SMC_CAPS_DMA;

	if (ISSET(caps, SDHC_HIGH_SPEED_SUPP))
		saa.caps |= SMC_CAPS_SD_HIGHSPEED;
	if (ISSET(caps, SDHC_HIGH_SPEED_SUPP))
		saa.caps |= SMC_CAPS_MMC_HIGHSPEED;

	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3) {
		uint32_t caps2 = HREAD4(hp, SDHC_CAPABILITIES2);

		if (ISSET(caps, SDHC_8BIT_MODE_SUPP))
			saa.caps |= SMC_CAPS_8BIT_MODE;

		if (ISSET(caps2, SDHC_DDR50_SUPP))
			saa.caps |= SMC_CAPS_MMC_DDR52;
	}

	if (ISSET(sc->sc_flags, SDHC_F_NODDR50))
		saa.caps &= ~SMC_CAPS_MMC_DDR52;

	hp->sdmmc = config_found(&sc->sc_dev, &saa, NULL);
	if (hp->sdmmc == NULL) {
		error = 0;
		goto err;
	}
	
	return 0;

err:
	free(hp, M_DEVBUF, sizeof *hp);
	sc->sc_host[sc->sc_nhosts - 1] = NULL;
	sc->sc_nhosts--;
	return (error);
}

int
sdhc_activate(struct device *self, int act)
{
	struct sdhc_softc *sc = (struct sdhc_softc *)self;
	struct sdhc_host *hp;
	int n, i, rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);

		/* Save the host controller state. */
		for (n = 0; n < sc->sc_nhosts; n++) {
			hp = sc->sc_host[n];
			for (i = 0; i < sizeof hp->regs; i++)
				hp->regs[i] = HREAD1(hp, i);
		}
		break;
	case DVACT_RESUME:
		/* Restore the host controller state. */
		for (n = 0; n < sc->sc_nhosts; n++) {
			hp = sc->sc_host[n];
			(void)sdhc_host_reset(hp);
			for (i = 0; i < sizeof hp->regs; i++)
				HWRITE1(hp, i, hp->regs[i]);
		}
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		sdhc_shutdown(self);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

/*
 * Shutdown hook established by or called from attachment driver.
 */
void
sdhc_shutdown(void *arg)
{
	struct sdhc_softc *sc = arg;
	struct sdhc_host *hp;
	int i;

	/* XXX chip locks up if we don't disable it before reboot. */
	for (i = 0; i < sc->sc_nhosts; i++) {
		hp = sc->sc_host[i];
		(void)sdhc_host_reset(hp);
	}
}

/*
 * Reset the host controller.  Called during initialization, when
 * cards are removed, upon resume, and during error recovery.
 */
int
sdhc_host_reset(sdmmc_chipset_handle_t sch)
{
	struct sdhc_host *hp = sch;
	u_int16_t imask;
	int error;
	int s;

	s = splsdmmc();

	/* Disable all interrupts. */
	HWRITE2(hp, SDHC_NINTR_SIGNAL_EN, 0);

	/*
	 * Reset the entire host controller and wait up to 100ms for
	 * the controller to clear the reset bit.
	 */
	if ((error = sdhc_soft_reset(hp, SDHC_RESET_ALL)) != 0) {
		splx(s);
		return (error);
	}	

	/* Set data timeout counter value to max for now. */
	HWRITE1(hp, SDHC_TIMEOUT_CTL, SDHC_TIMEOUT_MAX);

	/* Enable interrupts. */
	imask = SDHC_CARD_REMOVAL | SDHC_CARD_INSERTION |
	    SDHC_BUFFER_READ_READY | SDHC_BUFFER_WRITE_READY |
	    SDHC_DMA_INTERRUPT | SDHC_BLOCK_GAP_EVENT |
	    SDHC_TRANSFER_COMPLETE | SDHC_COMMAND_COMPLETE;

	HWRITE2(hp, SDHC_NINTR_STATUS_EN, imask);
	HWRITE2(hp, SDHC_EINTR_STATUS_EN, SDHC_EINTR_STATUS_MASK);
	HWRITE2(hp, SDHC_NINTR_SIGNAL_EN, imask);
	HWRITE2(hp, SDHC_EINTR_SIGNAL_EN, SDHC_EINTR_SIGNAL_MASK);

	splx(s);
	return 0;
}

u_int32_t
sdhc_host_ocr(sdmmc_chipset_handle_t sch)
{
	struct sdhc_host *hp = sch;
	return hp->ocr;
}

int
sdhc_host_maxblklen(sdmmc_chipset_handle_t sch)
{
	struct sdhc_host *hp = sch;
	return hp->maxblklen;
}

/*
 * Return non-zero if the card is currently inserted.
 */
int
sdhc_card_detect(sdmmc_chipset_handle_t sch)
{
	struct sdhc_host *hp = sch;

	if (hp->sc->sc_card_detect)
		return hp->sc->sc_card_detect(hp->sc);

	return ISSET(HREAD4(hp, SDHC_PRESENT_STATE), SDHC_CARD_INSERTED) ?
	    1 : 0;
}

/*
 * Set or change SD bus voltage and enable or disable SD bus power.
 * Return zero on success.
 */
int
sdhc_bus_power(sdmmc_chipset_handle_t sch, u_int32_t ocr)
{
	struct sdhc_host *hp = sch;
	u_int8_t vdd;
	int s;

	s = splsdmmc();

	/*
	 * Disable bus power before voltage change.
	 */
	if (!(hp->sc->sc_flags & SDHC_F_NOPWR0))
		HWRITE1(hp, SDHC_POWER_CTL, 0);

	/* If power is disabled, reset the host and return now. */
	if (ocr == 0) {
		splx(s);
		(void)sdhc_host_reset(hp);
		return 0;
	}

	/*
	 * Select the maximum voltage according to capabilities.
	 */
	ocr &= hp->ocr;
	if (ISSET(ocr, MMC_OCR_3_2V_3_3V|MMC_OCR_3_3V_3_4V))
		vdd = SDHC_VOLTAGE_3_3V;
	else if (ISSET(ocr, MMC_OCR_2_9V_3_0V|MMC_OCR_3_0V_3_1V))
		vdd = SDHC_VOLTAGE_3_0V;
	else if (ISSET(ocr, MMC_OCR_1_65V_1_95V))
		vdd = SDHC_VOLTAGE_1_8V;
	else {
		/* Unsupported voltage level requested. */
		splx(s);
		return EINVAL;
	}

	/*
	 * Enable bus power.  Wait at least 1 ms (or 74 clocks) plus
	 * voltage ramp until power rises.
	 */
	HWRITE1(hp, SDHC_POWER_CTL, (vdd << SDHC_VOLTAGE_SHIFT) |
	    SDHC_BUS_POWER);
	sdmmc_delay(10000);

	/*
	 * The host system may not power the bus due to battery low,
	 * etc.  In that case, the host controller should clear the
	 * bus power bit.
	 */
	if (!ISSET(HREAD1(hp, SDHC_POWER_CTL), SDHC_BUS_POWER)) {
		splx(s);
		return ENXIO;
	}

	splx(s);
	return 0;
}

/*
 * Return the smallest possible base clock frequency divisor value
 * for the CLOCK_CTL register to produce `freq' (KHz).
 */
static int
sdhc_clock_divisor(struct sdhc_host *hp, u_int freq)
{
	int max_div = 256;
	int div;

	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3)
		max_div = 2046;

	for (div = 1; div <= max_div; div *= 2)
		if ((hp->clkbase / div) <= freq)
			return (div / 2);
	/* No divisor found. */
	return -1;
}

/*
 * Set or change SDCLK frequency or disable the SD clock.
 * Return zero on success.
 */
int
sdhc_bus_clock(sdmmc_chipset_handle_t sch, int freq, int timing)
{
	struct sdhc_host *hp = sch;
	int s;
	int div;
	int sdclk;
	int timo;
	int error = 0;

	s = splsdmmc();

#ifdef DIAGNOSTIC
	/* Must not stop the clock if commands are in progress. */
	if (ISSET(HREAD4(hp, SDHC_PRESENT_STATE), SDHC_CMD_INHIBIT_MASK) &&
	    sdhc_card_detect(hp))
		printf("sdhc_sdclk_frequency_select: command in progress\n");
#endif

	/*
	 * Stop SD clock before changing the frequency.
	 */
	HWRITE2(hp, SDHC_CLOCK_CTL, 0);
	if (freq == SDMMC_SDCLK_OFF)
		goto ret;

	if (timing == SDMMC_TIMING_LEGACY)
		HCLR1(hp, SDHC_HOST_CTL, SDHC_HIGH_SPEED);
	else
		HSET1(hp, SDHC_HOST_CTL, SDHC_HIGH_SPEED);

	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3) {
		switch (timing) {
		case SDMMC_TIMING_MMC_DDR52:
			HCLR2(hp, SDHC_HOST_CTL2, SDHC_UHS_MODE_SELECT_MASK);
			HSET2(hp, SDHC_HOST_CTL2, SDHC_UHS_MODE_SELECT_DDR50);
			break;
		}
	}

	/*
	 * Set the minimum base clock frequency divisor.
	 */
	if ((div = sdhc_clock_divisor(hp, freq)) < 0) {
		/* Invalid base clock frequency or `freq' value. */
		error = EINVAL;
		goto ret;
	}
	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3)
		sdclk = SDHC_SDCLK_DIV_V3(div);
	else
		sdclk = SDHC_SDCLK_DIV(div);
	HWRITE2(hp, SDHC_CLOCK_CTL, sdclk);

	/*
	 * Start internal clock.  Wait 10ms for stabilization.
	 */
	HSET2(hp, SDHC_CLOCK_CTL, SDHC_INTCLK_ENABLE);
	for (timo = 1000; timo > 0; timo--) {
		if (ISSET(HREAD2(hp, SDHC_CLOCK_CTL), SDHC_INTCLK_STABLE))
			break;
		sdmmc_delay(10);
	}
	if (timo == 0) {
		error = ETIMEDOUT;
		goto ret;
	}

	/*
	 * Enable SD clock.
	 */
	HSET2(hp, SDHC_CLOCK_CTL, SDHC_SDCLK_ENABLE);

ret:
	splx(s);
	return error;
}

int
sdhc_bus_width(sdmmc_chipset_handle_t sch, int width)
{
	struct sdhc_host *hp = (struct sdhc_host *)sch;
	int reg;
	int s;

	if (width != 1 && width != 4 && width != 8)
		return EINVAL;

	s = splsdmmc();

	reg = HREAD1(hp, SDHC_HOST_CTL);
	reg &= ~SDHC_4BIT_MODE;
	if (SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3) {
		reg &= ~SDHC_8BIT_MODE;
	}
	if (width == 4) {
		reg |= SDHC_4BIT_MODE;
	} else if (width == 8) {
		KASSERT(SDHC_SPEC_VERSION(hp->version) >= SDHC_SPEC_V3);
		reg |= SDHC_8BIT_MODE;
	}
	HWRITE1(hp, SDHC_HOST_CTL, reg);

	splx(s);

	return 0;
}

void
sdhc_card_intr_mask(sdmmc_chipset_handle_t sch, int enable)
{
	struct sdhc_host *hp = sch;

	if (enable) {
		HSET2(hp, SDHC_NINTR_STATUS_EN, SDHC_CARD_INTERRUPT);
		HSET2(hp, SDHC_NINTR_SIGNAL_EN, SDHC_CARD_INTERRUPT);
	} else {
		HCLR2(hp, SDHC_NINTR_SIGNAL_EN, SDHC_CARD_INTERRUPT);
		HCLR2(hp, SDHC_NINTR_STATUS_EN, SDHC_CARD_INTERRUPT);
	}
}

void
sdhc_card_intr_ack(sdmmc_chipset_handle_t sch)
{
	struct sdhc_host *hp = sch;

	HSET2(hp, SDHC_NINTR_STATUS_EN, SDHC_CARD_INTERRUPT);
}

int
sdhc_signal_voltage(sdmmc_chipset_handle_t sch, int signal_voltage)
{
	struct sdhc_host *hp = sch;

	if (hp->sc->sc_signal_voltage)
		return hp->sc->sc_signal_voltage(hp->sc, signal_voltage);

	if (SDHC_SPEC_VERSION(hp->version) < SDHC_SPEC_V3)
		return EINVAL;

	switch (signal_voltage) {
	case SDMMC_SIGNAL_VOLTAGE_180:
		HSET2(hp, SDHC_HOST_CTL2, SDHC_1_8V_SIGNAL_EN);
		break;
	case SDMMC_SIGNAL_VOLTAGE_330:
		HCLR2(hp, SDHC_HOST_CTL2, SDHC_1_8V_SIGNAL_EN);
		break;
	default:
		return EINVAL;
	}

	/* Regulator output shall be stable within 5 ms. */
	sdmmc_delay(5000);

	/* Host controller clears this bit if 1.8V signalling fails. */
	if (signal_voltage == SDMMC_SIGNAL_VOLTAGE_180 &&
	    !ISSET(HREAD4(hp, SDHC_HOST_CTL2), SDHC_1_8V_SIGNAL_EN))
		return EIO;

	return 0;
}

int
sdhc_wait_state(struct sdhc_host *hp, u_int32_t mask, u_int32_t value)
{
	u_int32_t state;
	int timeout;

	for (timeout = 10; timeout > 0; timeout--) {
		if (((state = HREAD4(hp, SDHC_PRESENT_STATE)) & mask)
		    == value)
			return 0;
		sdmmc_delay(10000);
	}
	DPRINTF(0,("%s: timeout waiting for %x (state=%b)\n", DEVNAME(hp->sc),
	    value, state, SDHC_PRESENT_STATE_BITS));
	return ETIMEDOUT;
}

void
sdhc_exec_command(sdmmc_chipset_handle_t sch, struct sdmmc_command *cmd)
{
	struct sdhc_host *hp = sch;
	int error;

	/*
	 * Start the MMC command, or mark `cmd' as failed and return.
	 */
	error = sdhc_start_command(hp, cmd);
	if (error != 0) {
		cmd->c_error = error;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * Wait until the command phase is done, or until the command
	 * is marked done for any other reason.
	 */
	if (!sdhc_wait_intr(hp, SDHC_COMMAND_COMPLETE,
	    SDHC_COMMAND_TIMEOUT)) {
		cmd->c_error = ETIMEDOUT;
		SET(cmd->c_flags, SCF_ITSDONE);
		return;
	}

	/*
	 * The host controller removes bits [0:7] from the response
	 * data (CRC) and we pass the data up unchanged to the bus
	 * driver (without padding).
	 */
	if (cmd->c_error == 0 && ISSET(cmd->c_flags, SCF_RSP_PRESENT)) {
		if (ISSET(cmd->c_flags, SCF_RSP_136)) {
			u_char *p = (u_char *)cmd->c_resp;
			int i;

			for (i = 0; i < 15; i++)
				*p++ = HREAD1(hp, SDHC_RESPONSE + i);
		} else
			cmd->c_resp[0] = HREAD4(hp, SDHC_RESPONSE);
	}

	/*
	 * If the command has data to transfer in any direction,
	 * execute the transfer now.
	 */
	if (cmd->c_error == 0 && cmd->c_data != NULL)
		sdhc_transfer_data(hp, cmd);

	/* Turn off the LED. */
	HCLR1(hp, SDHC_HOST_CTL, SDHC_LED_ON);

	DPRINTF(1,("%s: cmd %u done (flags=%#x error=%d)\n",
	    DEVNAME(hp->sc), cmd->c_opcode, cmd->c_flags, cmd->c_error));
	SET(cmd->c_flags, SCF_ITSDONE);
}

int
sdhc_start_command(struct sdhc_host *hp, struct sdmmc_command *cmd)
{
	struct sdhc_adma2_descriptor32 *desc = (void *)hp->adma2;
	struct sdhc_softc *sc = hp->sc;
	u_int16_t blksize = 0;
	u_int16_t blkcount = 0;
	u_int16_t mode;
	u_int16_t command;
	int error;
	int seg;
	int s;
	
	DPRINTF(1,("%s: start cmd %u arg=%#x data=%#x dlen=%d flags=%#x "
	    "proc=\"%s\"\n", DEVNAME(hp->sc), cmd->c_opcode, cmd->c_arg,
	    cmd->c_data, cmd->c_datalen, cmd->c_flags, curproc ?
	    curproc->p_p->ps_comm : ""));

	/*
	 * The maximum block length for commands should be the minimum
	 * of the host buffer size and the card buffer size. (1.7.2)
	 */

	/* Fragment the data into proper blocks. */
	if (cmd->c_datalen > 0) {
		blksize = MIN(cmd->c_datalen, cmd->c_blklen);
		blkcount = cmd->c_datalen / blksize;
		if (cmd->c_datalen % blksize > 0) {
			/* XXX: Split this command. (1.7.4) */
			printf("%s: data not a multiple of %d bytes\n",
			    DEVNAME(hp->sc), blksize);
			return EINVAL;
		}
	}

	/* Check limit imposed by 9-bit block count. (1.7.2) */
	if (blkcount > SDHC_BLOCK_COUNT_MAX) {
		printf("%s: too much data\n", DEVNAME(hp->sc));
		return EINVAL;
	}

	/* Prepare transfer mode register value. (2.2.5) */
	mode = 0;
	if (ISSET(cmd->c_flags, SCF_CMD_READ))
		mode |= SDHC_READ_MODE;
	if (blkcount > 0) {
		mode |= SDHC_BLOCK_COUNT_ENABLE;
		if (blkcount > 1) {
			mode |= SDHC_MULTI_BLOCK_MODE;
			/* XXX only for memory commands? */
			mode |= SDHC_AUTO_CMD12_ENABLE;
		}
	}
	if (cmd->c_dmamap && cmd->c_datalen > 0 &&
	    ISSET(hp->flags, SHF_USE_DMA))
		mode |= SDHC_DMA_ENABLE;

	/*
	 * Prepare command register value. (2.2.6)
	 */
	command = (cmd->c_opcode & SDHC_COMMAND_INDEX_MASK) <<
	    SDHC_COMMAND_INDEX_SHIFT;

	if (ISSET(cmd->c_flags, SCF_RSP_CRC))
		command |= SDHC_CRC_CHECK_ENABLE;
	if (ISSET(cmd->c_flags, SCF_RSP_IDX))
		command |= SDHC_INDEX_CHECK_ENABLE;
	if (cmd->c_data != NULL)
		command |= SDHC_DATA_PRESENT_SELECT;

	if (!ISSET(cmd->c_flags, SCF_RSP_PRESENT))
		command |= SDHC_NO_RESPONSE;
	else if (ISSET(cmd->c_flags, SCF_RSP_136))
		command |= SDHC_RESP_LEN_136;
	else if (ISSET(cmd->c_flags, SCF_RSP_BSY))
		command |= SDHC_RESP_LEN_48_CHK_BUSY;
	else
		command |= SDHC_RESP_LEN_48;

	/* Wait until command and data inhibit bits are clear. (1.5) */
	if ((error = sdhc_wait_state(hp, SDHC_CMD_INHIBIT_MASK, 0)) != 0)
		return error;

	s = splsdmmc();

	/* Alert the user not to remove the card. */
	HSET1(hp, SDHC_HOST_CTL, SDHC_LED_ON);

	/* Set DMA start address if SHF_USE_DMA is set. */
	if (cmd->c_dmamap && ISSET(hp->flags, SHF_USE_DMA)) {
		for (seg = 0; seg < cmd->c_dmamap->dm_nsegs; seg++) {
			bus_addr_t paddr =
			    cmd->c_dmamap->dm_segs[seg].ds_addr;
			uint16_t len =
			    cmd->c_dmamap->dm_segs[seg].ds_len == 65536 ?
			    0 : cmd->c_dmamap->dm_segs[seg].ds_len;
			uint16_t attr;

			attr = SDHC_ADMA2_VALID | SDHC_ADMA2_ACT_TRANS;
			if (seg == cmd->c_dmamap->dm_nsegs - 1)
				attr |= SDHC_ADMA2_END;

			desc[seg].attribute = htole16(attr);
			desc[seg].length = htole16(len);
			desc[seg].address = htole32(paddr);
		}

		desc[cmd->c_dmamap->dm_nsegs].attribute = htole16(0);

		bus_dmamap_sync(sc->sc_dmat, hp->adma_map, 0, PAGE_SIZE,
		    BUS_DMASYNC_PREWRITE);

		HCLR1(hp, SDHC_HOST_CTL, SDHC_DMA_SELECT);
		HSET1(hp, SDHC_HOST_CTL, SDHC_DMA_SELECT_ADMA2);

		HWRITE4(hp, SDHC_ADMA_SYSTEM_ADDR,
		    hp->adma_map->dm_segs[0].ds_addr);
	}

	DPRINTF(1,("%s: cmd=%#x mode=%#x blksize=%d blkcount=%d\n",
	    DEVNAME(hp->sc), command, mode, blksize, blkcount));

	/*
	 * Start a CPU data transfer.  Writing to the high order byte
	 * of the SDHC_COMMAND register triggers the SD command. (1.5)
	 */
	HWRITE2(hp, SDHC_TRANSFER_MODE, mode);
	HWRITE2(hp, SDHC_BLOCK_SIZE, blksize);
	HWRITE2(hp, SDHC_BLOCK_COUNT, blkcount);
	HWRITE4(hp, SDHC_ARGUMENT, cmd->c_arg);
	HWRITE2(hp, SDHC_COMMAND, command);

	splx(s);
	return 0;
}

void
sdhc_transfer_data(struct sdhc_host *hp, struct sdmmc_command *cmd)
{
	struct sdhc_softc *sc = hp->sc;
	u_char *datap = cmd->c_data;
	int i, datalen;
	int mask;
	int error;

	if (cmd->c_dmamap) {
		int status;

		error = 0;
		for (;;) {
			status = sdhc_wait_intr(hp,
			    SDHC_DMA_INTERRUPT|SDHC_TRANSFER_COMPLETE,
			    SDHC_DMA_TIMEOUT);
			if (status & SDHC_TRANSFER_COMPLETE)
				break;
			if (!status) {
				error = ETIMEDOUT;
				break;
			}
		}

		bus_dmamap_sync(sc->sc_dmat, hp->adma_map, 0, PAGE_SIZE,
		    BUS_DMASYNC_POSTWRITE);
		goto done;
	}

	mask = ISSET(cmd->c_flags, SCF_CMD_READ) ?
	    SDHC_BUFFER_READ_ENABLE : SDHC_BUFFER_WRITE_ENABLE;
	error = 0;
	datalen = cmd->c_datalen;

	DPRINTF(1,("%s: resp=%#x datalen=%d\n", DEVNAME(hp->sc),
	    MMC_R1(cmd->c_resp), datalen));

#ifdef SDHC_DEBUG
	/* XXX I forgot why I wanted to know when this happens :-( */
	if ((cmd->c_opcode == 52 || cmd->c_opcode == 53) &&
	    ISSET(MMC_R1(cmd->c_resp), 0xcb00))
		printf("%s: CMD52/53 error response flags %#x\n",
		    DEVNAME(hp->sc), MMC_R1(cmd->c_resp) & 0xff00);
#endif

	while (datalen > 0) {
		if (!sdhc_wait_intr(hp, SDHC_BUFFER_READ_READY|
		    SDHC_BUFFER_WRITE_READY, SDHC_BUFFER_TIMEOUT)) {
			error = ETIMEDOUT;
			break;
		}

		if ((error = sdhc_wait_state(hp, mask, mask)) != 0)
			break;

		i = MIN(datalen, cmd->c_blklen);
		if (ISSET(cmd->c_flags, SCF_CMD_READ))
			sdhc_read_data(hp, datap, i);
		else
			sdhc_write_data(hp, datap, i);

		datap += i;
		datalen -= i;
	}

	if (error == 0 && !sdhc_wait_intr(hp, SDHC_TRANSFER_COMPLETE,
	    SDHC_TRANSFER_TIMEOUT))
		error = ETIMEDOUT;

done:
	if (error != 0)
		cmd->c_error = error;
	SET(cmd->c_flags, SCF_ITSDONE);

	DPRINTF(1,("%s: data transfer done (error=%d)\n",
	    DEVNAME(hp->sc), cmd->c_error));
}

void
sdhc_read_data(struct sdhc_host *hp, u_char *datap, int datalen)
{
	while (datalen > 3) {
		*(u_int32_t *)datap = HREAD4(hp, SDHC_DATA);
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		u_int32_t rv = HREAD4(hp, SDHC_DATA);
		do {
			*datap++ = rv & 0xff;
			rv = rv >> 8;
		} while (--datalen > 0);
	}
}

void
sdhc_write_data(struct sdhc_host *hp, u_char *datap, int datalen)
{
	while (datalen > 3) {
		DPRINTF(3,("%08x\n", *(u_int32_t *)datap));
		HWRITE4(hp, SDHC_DATA, *((u_int32_t *)datap));
		datap += 4;
		datalen -= 4;
	}
	if (datalen > 0) {
		u_int32_t rv = *datap++;
		if (datalen > 1)
			rv |= *datap++ << 8;
		if (datalen > 2)
			rv |= *datap++ << 16;
		DPRINTF(3,("rv %08x\n", rv));
		HWRITE4(hp, SDHC_DATA, rv);
	}
}

/* Prepare for another command. */
int
sdhc_soft_reset(struct sdhc_host *hp, int mask)
{
	int timo;

	DPRINTF(1,("%s: software reset reg=%#x\n", DEVNAME(hp->sc), mask));

	HWRITE1(hp, SDHC_SOFTWARE_RESET, mask);
	for (timo = 10; timo > 0; timo--) {
		if (!ISSET(HREAD1(hp, SDHC_SOFTWARE_RESET), mask))
			break;
		sdmmc_delay(10000);
		HWRITE1(hp, SDHC_SOFTWARE_RESET, 0);
	}
	if (timo == 0) {
		DPRINTF(1,("%s: timeout reg=%#x\n", DEVNAME(hp->sc),
		    HREAD1(hp, SDHC_SOFTWARE_RESET)));
		HWRITE1(hp, SDHC_SOFTWARE_RESET, 0);
		return (ETIMEDOUT);
	}

	return (0);
}

int
sdhc_wait_intr(struct sdhc_host *hp, int mask, int timo)
{
	int status;
	int s;

	mask |= SDHC_ERROR_INTERRUPT;

	s = splsdmmc();
	status = hp->intr_status & mask;
	while (status == 0) {
		if (tsleep(&hp->intr_status, PWAIT, "hcintr", timo)
		    == EWOULDBLOCK) {
			status |= SDHC_ERROR_INTERRUPT;
			break;
		}
		status = hp->intr_status & mask;
	}
	hp->intr_status &= ~status;

	DPRINTF(2,("%s: intr status %#x error %#x\n", DEVNAME(hp->sc), status,
	    hp->intr_error_status));
	
	/* Command timeout has higher priority than command complete. */
	if (ISSET(status, SDHC_ERROR_INTERRUPT)) {
		hp->intr_error_status = 0;
		(void)sdhc_soft_reset(hp, SDHC_RESET_DAT|SDHC_RESET_CMD);
		status = 0;
	}

	splx(s);
	return status;
}

/*
 * Established by attachment driver at interrupt priority IPL_SDMMC.
 */
int
sdhc_intr(void *arg)
{
	struct sdhc_softc *sc = arg;
	int host;
	int done = 0;

	/* We got an interrupt, but we don't know from which slot. */
	for (host = 0; host < sc->sc_nhosts; host++) {
		struct sdhc_host *hp = sc->sc_host[host];
		u_int16_t status;

		if (hp == NULL)
			continue;

		/* Find out which interrupts are pending. */
		status = HREAD2(hp, SDHC_NINTR_STATUS);
		if (!ISSET(status, SDHC_NINTR_STATUS_MASK))
			continue; /* no interrupt for us */

		/* Acknowledge the interrupts we are about to handle. */
		HWRITE2(hp, SDHC_NINTR_STATUS, status);
		DPRINTF(2,("%s: interrupt status=%b\n", DEVNAME(hp->sc),
		    status, SDHC_NINTR_STATUS_BITS));

		/* Claim this interrupt. */
		done = 1;

		/*
		 * Service error interrupts.
		 */
		if (ISSET(status, SDHC_ERROR_INTERRUPT)) {
			u_int16_t error;

			/* Acknowledge error interrupts. */
			error = HREAD2(hp, SDHC_EINTR_STATUS);
			HWRITE2(hp, SDHC_EINTR_STATUS, error);
			DPRINTF(2,("%s: error interrupt, status=%b\n",
			    DEVNAME(hp->sc), error, SDHC_EINTR_STATUS_BITS));

			if (ISSET(error, SDHC_CMD_TIMEOUT_ERROR|
			    SDHC_DATA_TIMEOUT_ERROR)) {
				hp->intr_error_status |= error;
				hp->intr_status |= status;
				wakeup(&hp->intr_status);
			}
		}

		/*
		 * Wake up the sdmmc event thread to scan for cards.
		 */
		if (ISSET(status, SDHC_CARD_REMOVAL|SDHC_CARD_INSERTION))
			sdmmc_needs_discover(hp->sdmmc);

		/*
		 * Wake up the blocking process to service command
		 * related interrupt(s).
		 */
		if (ISSET(status, SDHC_BUFFER_READ_READY|
		    SDHC_BUFFER_WRITE_READY|SDHC_COMMAND_COMPLETE|
		    SDHC_TRANSFER_COMPLETE)) {
			hp->intr_status |= status;
			wakeup(&hp->intr_status);
		}

		/*
		 * Service SD card interrupts.
		 */
		if (ISSET(status, SDHC_CARD_INTERRUPT)) {
			DPRINTF(0,("%s: card interrupt\n", DEVNAME(hp->sc)));
			HCLR2(hp, SDHC_NINTR_STATUS_EN, SDHC_CARD_INTERRUPT);
			sdmmc_card_intr(hp->sdmmc);
		}
	}
	return done;
}

void
sdhc_needs_discover(struct sdhc_softc *sc)
{
	int host;

	for (host = 0; host < sc->sc_nhosts; host++)
		sdmmc_needs_discover(sc->sc_host[host]->sdmmc);
}

#ifdef SDHC_DEBUG
void
sdhc_dump_regs(struct sdhc_host *hp)
{
	printf("0x%02x PRESENT_STATE:    %b\n", SDHC_PRESENT_STATE,
	    HREAD4(hp, SDHC_PRESENT_STATE), SDHC_PRESENT_STATE_BITS);
	printf("0x%02x POWER_CTL:        %x\n", SDHC_POWER_CTL,
	    HREAD1(hp, SDHC_POWER_CTL));
	printf("0x%02x NINTR_STATUS:     %x\n", SDHC_NINTR_STATUS,
	    HREAD2(hp, SDHC_NINTR_STATUS));
	printf("0x%02x EINTR_STATUS:     %x\n", SDHC_EINTR_STATUS,
	    HREAD2(hp, SDHC_EINTR_STATUS));
	printf("0x%02x NINTR_STATUS_EN:  %x\n", SDHC_NINTR_STATUS_EN,
	    HREAD2(hp, SDHC_NINTR_STATUS_EN));
	printf("0x%02x EINTR_STATUS_EN:  %x\n", SDHC_EINTR_STATUS_EN,
	    HREAD2(hp, SDHC_EINTR_STATUS_EN));
	printf("0x%02x NINTR_SIGNAL_EN:  %x\n", SDHC_NINTR_SIGNAL_EN,
	    HREAD2(hp, SDHC_NINTR_SIGNAL_EN));
	printf("0x%02x EINTR_SIGNAL_EN:  %x\n", SDHC_EINTR_SIGNAL_EN,
	    HREAD2(hp, SDHC_EINTR_SIGNAL_EN));
	printf("0x%02x CAPABILITIES:     %x\n", SDHC_CAPABILITIES,
	    HREAD4(hp, SDHC_CAPABILITIES));
	printf("0x%02x MAX_CAPABILITIES: %x\n", SDHC_MAX_CAPABILITIES,
	    HREAD4(hp, SDHC_MAX_CAPABILITIES));
}
#endif
@


1.54
log
@add sizes to free() calls
ok dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.53 2017/01/21 05:42:04 guenther Exp $	*/
d28 1
d321 3
d690 3
@


1.53
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.52 2016/05/15 22:21:55 kettenis Exp $	*/
d329 1
a329 1
	free(hp, M_DEVBUF, 0);
@


1.52
log
@Sync with the ADMA2 implementation in imxesdhc(4):

Map the ADMA2 descriptor table use BUS_DMA_COHERENT and add a missing
bus_dmamap_sync(9).  Doesn't really fix anything, but adding the missing
sync makes the code more correct.  Using BUS_DMA_COHERENT avoids some
cache flushes on architectures that implement it.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.51 2016/05/05 11:01:08 kettenis Exp $	*/
d803 1
a803 1
	    curproc->p_comm : ""));
@


1.51
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.50 2016/05/04 14:05:32 kettenis Exp $	*/
d262 1
a262 1
		    PAGE_SIZE, &hp->adma2, BUS_DMA_WAITOK);
d926 1
d948 2
@


1.50
log
@Print SD host controller version.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.49 2016/05/01 22:06:32 kettenis Exp $	*/
d89 1
a89 1
int	sdhc_bus_clock(sdmmc_chipset_handle_t, int);
d93 1
d127 3
a129 1
	sdhc_card_intr_ack
d311 2
d315 3
d553 1
a553 1
sdhc_bus_clock(sdmmc_chipset_handle_t sch, int freq)
d578 14
a624 5
	if (freq > 26000)
		HSET1(hp, SDHC_HOST_CTL, SDHC_HIGH_SPEED);
	else
		HCLR1(hp, SDHC_HOST_CTL, SDHC_HIGH_SPEED);

d638 1
a638 1
		return 1;
d680 30
@


1.49
log
@Print base clock frequency.

ok deraadt@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.48 2016/05/01 18:29:44 kettenis Exp $	*/
d212 2
a213 1
	printf("%s: %d MHz base clock\n", DEVNAME(sc), hp->clkbase / 1000);
@


1.48
log
@Add bus width switching support for MMC.  Enable 8-bit bus support on
sdhc(4) controllers that support it.  Mostly from NetBSD.

This makes the raw transfer rate of the eMMC on the Lenovo Ideacentre
Stick 300 go up to 40 MB/s.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.47 2016/05/01 17:13:55 kettenis Exp $	*/
d211 2
@


1.47
log
@Always write block count.  This fixes the DMA issues on Bay Trail.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.46 2016/05/01 16:04:39 kettenis Exp $	*/
d303 5
@


1.46
log
@Add support for changing the bus width to the sdmmc subsystem and the sdhc(4)
controller.  Use this to switch SD cards to a 4-bit bus if they support it.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.45 2016/04/30 13:33:35 kettenis Exp $	*/
d860 1
a860 2
	if (blkcount > 1)
		HWRITE2(hp, SDHC_BLOCK_COUNT, blkcount);
@


1.45
log
@Enable high speed timing for bus clock frequencies over 26MHz and advertise
support for it.  In principle SD cards use high speed timing for frequencies
over 25MHz, but it is silly to run those with a clock between 25-26MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.44 2016/04/30 11:32:23 kettenis Exp $	*/
d90 1
d121 1
d294 1
d603 30
@


1.44
log
@Implement DMA support.  Bits and pieces taken from NetBSD, but we only
support ADMA2.  The older SDMA mode has too many limitations to be really
usable.  Gives us only moderate speed improvements, bus reduces the CPU load
considerably.  We will reap the full benefits once we implement wider bus
widths and high speed modes.

There is a remining issue with simultanious use of eMMC and external SD card
on (some) Intel Bay Trail hardware.  Still under investigation.

ok patrick@@, stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.43 2016/03/30 09:58:01 kettenis Exp $	*/
d296 5
d591 5
@


1.43
log
@Expose the functionality that triggers a check for card insertion or removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.42 2016/03/27 18:49:41 kettenis Exp $	*/
d39 1
d54 4
d182 1
a182 1
	if (usedma && ISSET(caps, SDHC_DMA_SUPPORT))
d244 40
d292 3
d692 2
d699 1
d742 2
a743 2
#ifdef notyet
	if (ISSET(hp->flags, SHF_USE_DMA))
a744 1
#endif
d777 30
a806 1
	/* XXX: Set DMA start address if SHF_USE_DMA is set. */
d834 19
d893 1
@


1.42
log
@Make it possible to override the standard card detect mechanism.  The SD
controller on Intel's Bay Trail SoC tends to be used in a way where a
separate gpio is used that signals the presence of a card in a slot.  This
change allows us to support that mode.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.41 2016/01/11 06:54:53 kettenis Exp $	*/
d977 9
@


1.41
log
@Add (limited) support for controllers that implement version 3.0 of the
SD host controller standard.  Support the larger base clock and larger
clock divisors.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.40 2016/01/10 14:11:43 kettenis Exp $	*/
d384 4
@


1.40
log
@Seems the voltage bit defenitions in sdmmcreg.h for voltages below 2V
are not quite right.  At least I can't find them in any of the MMC and
SD card documentation I can find on the interwebs.  Instead there is a
single "low voltage bit" that indicates support for the 1.65-1.95V or
1.70-1.95V range depending on the document you're reading.  Go with the
1.65-1.95V range as that is what Linux does.

Necessary (but not sufficient) to make the eMMC on the ASUS X205TA work.

ok jsg@@ (who did the armv7 bits)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.39 2015/03/14 03:38:49 jsg Exp $	*/
d45 1
d137 1
d164 3
d183 11
a193 2
	if (SDHC_BASE_FREQ_KHZ(caps) != 0)
		hp->clkbase = SDHC_BASE_FREQ_KHZ(caps);
d199 1
a199 2
	} else if (hp->clkbase < 10000 || hp->clkbase > 63000) {
		/* SDHC 1.0 supports only 10-63 MHz. */
d459 1
d462 4
a465 1
	for (div = 1; div <= 256; div *= 2)
d482 1
d510 5
a514 1
	HWRITE2(hp, SDHC_CLOCK_CTL, div << SDHC_SDCLK_DIV_SHIFT);
@


1.39
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.38 2014/07/12 18:48:52 tedu Exp $	*/
d201 1
a201 1
		SET(hp->ocr, MMC_OCR_1_7V_1_8V | MMC_OCR_1_8V_1_9V);
d409 1
a409 1
	else if (ISSET(ocr, MMC_OCR_1_7V_1_8V|MMC_OCR_1_8V_1_9V))
@


1.38
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.37 2013/12/06 21:03:04 deraadt Exp $	*/
a26 1
#include <sys/kthread.h>
@


1.37
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.36 2013/05/31 21:28:32 deraadt Exp $	*/
d245 1
a245 1
	free(hp, M_DEVBUF);
@


1.36
log
@Correct sequencing in ca_activate function.  Some operations were in the
wrong order, and depth traversal was not gauranteed.
ok stsp (tested too)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.35 2012/10/08 21:47:50 deraadt Exp $	*/
a258 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
a268 4
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		sdhc_shutdown(self);
		break;
d277 7
@


1.35
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.34 2011/07/31 16:55:01 kettenis Exp $	*/
d263 1
a263 2
		/* XXX poll for command completion or suspend command
		 * in progress */
a270 1
		rv = config_activate_children(self, act);
@


1.34
log
@Add support for the Ricoh 5U823 SD/MMC controller found on the x220.

ok deraadt@@, phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.33 2010/09/07 16:21:46 deraadt Exp $	*/
d273 4
@


1.33
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.32 2010/08/31 17:13:47 deraadt Exp $	*/
d132 1
a132 1
    bus_space_handle_t ioh, bus_size_t iosize, int usedma)
a135 1
	u_int32_t caps;
d169 2
a170 1
	caps = HREAD4(hp, SDHC_CAPABILITIES);
@


1.32
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.31 2010/08/31 16:25:28 deraadt Exp $	*/
a285 6
}

void
sdhc_powerhook(int why, void *arg)
{
	sdhc_activate(arg, why);
@


1.31
log
@activate function should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.30 2010/08/27 15:41:43 deraadt Exp $	*/
d259 3
@


1.30
log
@Improve sdhc_activate, and make sdhc_powerhook a simple wrapper around
it for now
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.29 2010/08/27 04:09:20 deraadt Exp $	*/
d256 1
a256 1
	int n, i;
d269 1
a269 1
		config_activate_children((struct device *)sc, act);
d279 1
a279 1
		config_activate_children((struct device *)sc, act);
d282 1
a282 1
	return (0);
@


1.29
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.28 2010/08/19 17:54:12 jasper Exp $	*/
d251 2
a252 5
/*
 * Power hook established by or called from attachment driver.
 */
void
sdhc_power(int why, void *arg)
d254 1
a254 1
	struct sdhc_softc *sc = arg;
d258 2
a259 2
	switch(why) {
	case PWR_SUSPEND:
d269 1
a269 2
		config_activate_children((struct device *)sc,
		    DVACT_SUSPEND);
d271 1
a271 2

	case PWR_RESUME:
d279 1
a279 2
		config_activate_children((struct device *)sc,
		    DVACT_RESUME);
d282 7
@


1.28
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.27 2010/07/02 18:05:28 deraadt Exp $	*/
a261 1
	case PWR_STANDBY:
@


1.27
log
@One transition was wrong:  Suspending without a card, and then resuming with
was doing an attach, detach, and re-attach.  Repair the state transitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.26 2010/07/02 09:21:58 deraadt Exp $	*/
a54 2
#define HDEVNAME(hp)	((hp)->sc->sc_dev.dv_xname)

d554 1
a554 1
	DPRINTF(0,("%s: timeout waiting for %x (state=%b)\n", HDEVNAME(hp),
d613 1
a613 1
	    HDEVNAME(hp), cmd->c_opcode, cmd->c_flags, cmd->c_error));
d628 1
a628 1
	    "proc=\"%s\"\n", HDEVNAME(hp), cmd->c_opcode, cmd->c_arg,
d644 1
a644 1
			    HDEVNAME(hp), blksize);
d651 1
a651 1
		printf("%s: too much data\n", HDEVNAME(hp));
d706 1
a706 1
	    HDEVNAME(hp), command, mode, blksize, blkcount));
d736 1
a736 1
	DPRINTF(1,("%s: resp=%#x datalen=%d\n", HDEVNAME(hp),
d744 1
a744 1
		    HDEVNAME(hp), MMC_R1(cmd->c_resp) & 0xff00);
d776 1
a776 1
	    HDEVNAME(hp), cmd->c_error));
d822 1
a822 1
	DPRINTF(1,("%s: software reset reg=%#x\n", HDEVNAME(hp), mask));
d832 1
a832 1
		DPRINTF(1,("%s: timeout reg=%#x\n", HDEVNAME(hp),
d861 1
a861 1
	DPRINTF(2,("%s: intr status %#x error %#x\n", HDEVNAME(hp), status,
d900 1
a900 1
		DPRINTF(2,("%s: interrupt status=%b\n", HDEVNAME(hp),
d916 1
a916 1
			    HDEVNAME(hp), error, SDHC_EINTR_STATUS_BITS));
d947 1
a947 1
			DPRINTF(0,("%s: card interrupt\n", HDEVNAME(hp)));
@


1.26
log
@On resume, detach and then force a re-attach of the card, since we don't
know if it is the same card or if it got modified while we were not paying
attention.  Tested on x40 under apm, and some acpi machines.
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.25 2009/01/13 19:44:20 grange Exp $	*/
d275 2
@


1.25
log
@Trivial lvalue abuse fixes, no binary changes.
ok millert@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.24 2007/10/01 15:34:48 krw Exp $	*/
d285 2
@


1.24
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.23 2007/09/10 19:49:31 gilles Exp $	*/
d799 2
a800 1
		HWRITE4(hp, SDHC_DATA, *((u_int32_t *)datap)++);
@


1.23
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.22 2007/09/06 08:01:01 jsg Exp $	*/
d158 1
a158 2
	hp = (struct sdhc_host *)malloc(sizeof(struct sdhc_host),
	    M_DEVBUF, M_WAITOK);
a161 1
	bzero(hp, sizeof(struct sdhc_host));
@


1.22
log
@Don't try disabling bus power before setting the voltage on
the buggy ENE controller.
Tested by Alexey Suslikov <alexey.suslikov@@gmail.com> who
pointed out a similiar workaround in Linux.

ok miod@@, nit and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.21 2007/05/31 23:37:21 uwe Exp $	*/
d158 1
a158 1
	MALLOC(hp, struct sdhc_host *, sizeof(struct sdhc_host),
d249 1
a249 1
	FREE(hp, M_DEVBUF);
@


1.21
log
@don't print debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.20 2007/05/31 10:09:01 uwe Exp $	*/
d393 2
a394 1
	HWRITE1(hp, SDHC_POWER_CTL, 0);
@


1.20
log
@Add SDIO card interrupt handling code
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.19 2007/05/26 19:04:24 uwe Exp $	*/
a523 1
	printf("sdhc_card_intr_mask enable=%d\n", enable);
@


1.19
log
@Bug fixes and initial card interrupt support in sdhc

- Fix data transfers where c_datalen is not a multiple of 4
- Fix the handling of MMC commands with c_datalen < c_blklen
- Change the order of register writes in sdhc_start_command()
  and only write block count if we transfer multiple blocks
- Enable the SDIO card interrupt (but don't acknowledge it yet)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.18 2007/04/11 10:04:59 miod Exp $	*/
d87 2
d118 4
a121 1
	sdhc_exec_command
d341 1
a341 2
	    SDHC_TRANSFER_COMPLETE | SDHC_COMMAND_COMPLETE |
	    SDHC_CARD_INTERRUPT;
d519 22
d946 1
a946 1
			printf("%s: card interrupt\n", HDEVNAME(hp));
d948 1
a948 4
			/* XXX service card interrupt */
#ifdef notyet
			HSET2(hp, SDHC_NINTR_STATUS_EN, SDHC_CARD_INTERRUPT);
#endif
@


1.18
log
@((cast)ptr)++ is not a valid lvalue, despite being tolerated by gcc, so
replace the post-increment with a proper statement.

ok uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.17 2007/01/31 12:54:47 claudio Exp $	*/
d336 3
a338 1
	    SDHC_TRANSFER_COMPLETE | SDHC_COMMAND_COMPLETE;
d613 1
a613 1
		blksize = cmd->c_blklen;
d637 1
d686 1
d688 2
a689 1
	HWRITE2(hp, SDHC_BLOCK_COUNT, blkcount);
a690 1
	HWRITE2(hp, SDHC_TRANSFER_MODE, mode);
d713 8
d756 11
a766 13
	while (datalen > 0) {
		if (datalen > 3) {
			*((u_int32_t *)datap) = HREAD4(hp, SDHC_DATA);
			datap += 4;
			datalen -= 4;
		} else if (datalen > 1) {
			*((u_int16_t *)datap) = HREAD2(hp, SDHC_DATA);
			datap += 2;
			datalen -= 2;
		} else {
			*datap++ = HREAD1(hp, SDHC_DATA);
			datalen -= 1;
		}
d773 13
a785 14
	while (datalen > 0) {
		if (datalen > 3) {
			HWRITE4(hp, SDHC_DATA, *(u_int32_t *)datap);
			datap += 4;
			datalen -= 4;
		} else if (datalen > 1) {
			HWRITE2(hp, SDHC_DATA, *(u_int16_t *)datap);
			datap += 2;
			datalen -= 2;
		} else {
			HWRITE1(hp, SDHC_DATA, *datap);
			datap++;
			datalen -= 1;
		}
d923 1
d925 1
@


1.17
log
@Workaround for the problem where the SD card reader stops responding after
a card is ejected. Problem identified and patch provided by
Matthew R. Dempsky < mrd at alkemio dot org >:
> According to the Simplified SD Host Controller spec, this change
> shouldn't affect anything.  All of the bits in the Software Reset
> register are labeled as ignoring 0-bit writes, and yet somehow it
> changes behavior.
This seems to reliably fix the problems seen on many X40 laptops.
Tested by many, OK beck@@, "should be good to go" henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.16 2007/01/28 03:03:12 krw Exp $	*/
d746 2
a747 1
			*((u_int32_t *)datap)++ = HREAD4(hp, SDHC_DATA);
d750 2
a751 1
			*((u_int16_t *)datap)++ = HREAD2(hp, SDHC_DATA);
@


1.16
log
@Restore spl level before exiting on error.

Noted by Matthew R. Dempsky.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.15 2006/11/29 14:05:45 uwe Exp $	*/
d791 1
@


1.15
log
@make interrupt handler stay quiet in case of shared interrupts
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.14 2006/11/29 01:46:53 uwe Exp $	*/
d324 2
a325 1
	if ((error = sdhc_soft_reset(hp, SDHC_RESET_ALL)) != 0)
d327 1
@


1.14
log
@oops, don't always enable debugging
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.13 2006/11/29 00:52:37 uwe Exp $	*/
d852 1
a852 1
		/* Acknowledge interrupts we are about to handle. */
d854 4
a860 3

		if (!ISSET(status, SDHC_NINTR_STATUS_MASK))
			continue;
@


1.13
log
@Show debug messages depending on current debug level, which may be
changed with ddb or sdio(8).
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.12 2006/10/19 10:55:56 tom Exp $	*/
a35 2

#define SDHC_DEBUG
@


1.12
log
@s/Mhz/MHz/ in comments and printf() strings

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.11 2006/07/30 16:40:27 fgsch Exp $	*/
d37 2
d99 2
a101 1
#define DPRINTF(s)	printf s
d103 1
a103 1
#define DPRINTF(s)	do {} while(0)
d526 1
a526 1
	DPRINTF(("%s: timeout waiting for %x (state=%b)\n", HDEVNAME(hp),
d584 1
a584 1
	DPRINTF(("%s: cmd %u done (flags=%#x error=%d)\n",
d599 4
a602 4
	DPRINTF(("%s: start cmd %u arg=%#x data=%#x dlen=%d flags=%#x "
	    "proc=%#x \"%s\"\n", HDEVNAME(hp), cmd->c_opcode, cmd->c_arg,
	    cmd->c_data, cmd->c_datalen, cmd->c_flags, curproc,
	    curproc ? curproc->p_comm : ""));
d676 2
a677 2
	DPRINTF(("%s: writing cmd: blksize=%d blkcount=%d mode=%#x cmd=%#x\n",
	    HDEVNAME(hp), blksize, blkcount, mode, command));
d706 1
a706 1
	DPRINTF(("%s: resp=%#x datalen %u\n", HDEVNAME(hp),
d737 1
a737 1
	DPRINTF(("%s: data transfer done (error=%d)\n",
d784 1
a784 1
	DPRINTF(("%s: software reset reg=%#x\n", HDEVNAME(hp), mask));
d793 1
a793 1
		DPRINTF(("%s: timeout reg=%#x\n", HDEVNAME(hp),
d822 1
a822 1
	DPRINTF(("%s: intr status %#x error %#x\n", HDEVNAME(hp), status,
d857 1
a857 1
		DPRINTF(("%s: interrupt status=%b\n", HDEVNAME(hp),
d875 1
a875 1
			DPRINTF(("%s: error interrupt, status=%b\n",
@


1.11
log
@o Change sdhc_soft_reset() to pass the bits we want to reset and wait
  until all bits are cleared.
o Change sdhc_host_reset() to use the above function and use RESET_ALL.
  This avoid timeouts on TI controllers when initializing the controller but
  does not fix the command timeouts.
uwe@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.10 2006/07/19 23:56:03 fgsch Exp $	*/
d185 1
a185 1
		/* SDHC 1.0 supports only 10-63 Mhz. */
@


1.10
log
@add some more debugging code.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.9 2006/07/18 04:10:35 uwe Exp $	*/
d90 1
a90 1
void	sdhc_soft_reset(struct sdhc_host *);
a304 4
 *
 * Unfortunately, at least one vendor does not follow the simplified
 * SDHC specification: TI's PCI7621 does not clear reset bits, so we
 * have no way to tell whether the reset was successful or timed out.
d311 1
a311 1
	int timo;
d323 2
a324 12
	HWRITE1(hp, SDHC_SOFTWARE_RESET, SDHC_RESET_MASK);
	for (timo = 10; timo > 0; timo--) {
		if (!ISSET(HREAD1(hp, SDHC_SOFTWARE_RESET), SDHC_RESET_MASK))
			break;
		sdmmc_delay(10000);
	}
	if (timo == 0) {
		DPRINTF(("%s: timeout reg=%#x\n", HDEVNAME(hp),
		    HREAD1(hp, SDHC_SOFTWARE_RESET)));
		HWRITE1(hp, SDHC_SOFTWARE_RESET, 0);
		/* return ETIMEDOUT; but see above. */
	}
d776 2
a777 2
void
sdhc_soft_reset(struct sdhc_host *hp)
d779 18
a796 3
	DPRINTF(("%s: software reset\n", HDEVNAME(hp)));
	HWRITE1(hp, SDHC_SOFTWARE_RESET, SDHC_RESET_DAT|SDHC_RESET_CMD);
	sdmmc_delay(10000);
d825 1
a825 1
		sdhc_soft_reset(hp);
@


1.9
log
@First and foremost, avoid an obious race between two or more processes
trying to get MMC commands through to the SD/MMC host controller via the
emulated SCSI layer.  This is achieved by ensuring exclusive access to
the host controller for one process during any MMC command and during a
sequence of commands at the sdmmc(4) layer.

While at it, the command processing thread has been moved to sdmmc(4),
so as to simplify the implementation of future host controller drivers.
This should also pave the way for further cleanup of the code and for
new drivers.

Minor cleanups are included in this commit, as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.8 2006/07/17 20:50:58 fgsch Exp $	*/
d334 2
d610 3
a612 2
	DPRINTF(("%s: start cmd %u arg=%#x proc=%#x\"%s\"\n",
	    HDEVNAME(hp), cmd->c_opcode, cmd->c_arg, curproc,
d686 3
@


1.8
log
@silently return if sdmmc is disabled/not in the kernel. uwe@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.7 2006/07/17 20:48:27 fgsch Exp $	*/
a29 1
#include <sys/timeout.h>
d37 3
a39 2
#define SDHC_COMMAND_TIMEOUT	(hz*2)	/* 2 seconds */
#define SDHC_DATA_TIMEOUT	(hz*2)	/* 2 seconds */
a49 3
	struct proc *event_thread;	/* event processing thread */
	struct sdmmc_command *cmd;	/* current command or NULL */
	struct timeout cmd_to;		/* command timeout */
d51 2
d55 1
a55 1
#define HDEVNAME(hp)	((hp)->sdmmc->dv_xname)
a58 2
#define SHF_CARD_PRESENT	0x0002
#define SHF_CARD_ATTACHED	0x0004
a80 4
void	sdhc_create_event_thread(void *);
void	sdhc_event_thread(void *);
void	sdhc_event_process(struct sdhc_host *);

d87 2
a88 1
int	sdhc_exec_command(sdmmc_chipset_handle_t, struct sdmmc_command *);
d90 3
a92 4
int	sdhc_start_command(struct sdhc_host *, struct sdmmc_command *);
int	sdhc_wait_command(struct sdhc_host *, int);
int	sdhc_finish_command(struct sdhc_host *);
void	sdhc_transfer_data(struct sdhc_host *);
a94 1
void	sdhc_command_timeout(void *);
a160 1
	timeout_set(&hp->cmd_to, sdhc_command_timeout, hp);
a238 9

	/*
	 * Create the event thread that will attach and detach cards
	 * and perform other lengthy operations.
	 */
#ifdef DO_CONFIG_PENDING
	config_pending_incr();
#endif
	kthread_create_deferred(sdhc_create_event_thread, hp);
a242 1
	timeout_del(&hp->cmd_to);
a248 59
void
sdhc_create_event_thread(void *arg)
{
	struct sdhc_host *hp = arg;

	/* If there's a card, attach it. */
	sdhc_event_process(hp);

	if (kthread_create(sdhc_event_thread, hp, &hp->event_thread,
	    HDEVNAME(hp)) != 0)
		printf("%s: can't create event thread\n", HDEVNAME(hp));

#ifdef DO_CONFIG_PENDING
	config_pending_decr();
#endif
}

void
sdhc_event_thread(void *arg)
{
	struct sdhc_host *hp = arg;

	for (;;) {
		(void)tsleep((caddr_t)hp, PWAIT, "sdhcev", 0);
		sdhc_event_process(hp);
	}
}

void
sdhc_event_process(struct sdhc_host *hp)
{
	/* If there's a card, attach it, if it went away, detach it. */
	if (sdhc_card_detect(hp)) {
		if (!ISSET(hp->flags, SHF_CARD_PRESENT)) {
			SET(hp->flags, SHF_CARD_PRESENT);
			if (sdmmc_card_attach(hp->sdmmc) == 0)
				SET(hp->flags, SHF_CARD_ATTACHED);
		}
	} else {
		/* XXX If a command was in progress, abort it. */
		int s = splsdmmc();
		if (hp->cmd != NULL) {
			timeout_del(&hp->cmd_to);
			printf("%s: interrupted command %u\n",
			    HDEVNAME(hp), hp->cmd->c_opcode);
			hp->cmd = NULL;
		}
		splx(s);

		if (ISSET(hp->flags, SHF_CARD_PRESENT)) {
			CLR(hp->flags, SHF_CARD_PRESENT);
			if (ISSET(hp->flags, SHF_CARD_ATTACHED)) {
				sdmmc_card_detach(hp->sdmmc, DETACH_FORCE);
				CLR(hp->flags, SHF_CARD_ATTACHED);
			}
		}
	}
}

a521 33
/*
 * Send a command and data to the card and return the command response
 * and data from the card.
 *
 * If no callback function is specified, execute the command
 * synchronously; otherwise, return immediately and call the function
 * from the event thread after the command has completed.
 */
int
sdhc_exec_command(sdmmc_chipset_handle_t sch, struct sdmmc_command *cmd)
{
	struct sdhc_host *hp = sch;
	int error;

	if (hp->cmd != NULL)
		return EBUSY;

	error = sdhc_start_command(hp, cmd);
	if (error != 0)
		goto err;
	if (cmd->c_done != NULL)
		/* Execute this command asynchronously. */
		return error;

	error = sdhc_wait_command(hp, SCF_DONE|SCF_CMD_DONE);
	if (error != 0)
		goto err;
	return sdhc_finish_command(hp);
 err:
	cmd->c_error = error;
	SET(cmd->c_flags, SCF_DONE);
	return sdhc_finish_command(hp);
}
d540 58
d608 3
a610 7
	DPRINTF(("%s: start cmd %u arg=%#x\n", HDEVNAME(hp), cmd->c_opcode,
	    cmd->c_arg));
	hp->cmd = cmd;

	/* If the card went away, finish the command immediately. */
	if (!ISSET(hp->flags, SHF_CARD_PRESENT))
		return ETIMEDOUT;
a693 7
	/*
	 * Start a software timeout.  In the unlikely event that the
	 * controller's own timeout detection mechanism fails we will
	 * abort the transfer in software.
	 */
	timeout_add(&hp->cmd_to, SDHC_COMMAND_TIMEOUT);

a697 76
int
sdhc_wait_command(struct sdhc_host *hp, int flags)
{
	int s;

	for (;;) {
		/* Return if the command was aborted. */
		if (hp->cmd == NULL)
			return EIO;

		s = splsdmmc();

		/* Return if the command has reached the awaited state. */
		if (ISSET(hp->cmd->c_flags, flags)) {
			splx(s);
			return 0;
		}

		(void)tsleep((caddr_t)hp, PWAIT, "sdhccmd", 0);

		/* Process card events. */
		sdhc_event_process(hp);

		splx(s);
	}
}

int
sdhc_finish_command(struct sdhc_host *hp)
{
	struct sdmmc_command *cmd = hp->cmd;
	int error;

	if (cmd == NULL) {
		DPRINTF(("%s: finish NULL cmd\n", HDEVNAME(hp)));
		return 0;
	}

	/* Cancel command timeout. */
	timeout_del(&hp->cmd_to);

	/*
	 * The host controller removes bits [0:7] from the response
	 * data (CRC) and we pass the data up unchanged to the bus
	 * driver (without padding).
	 */
	if (cmd->c_error == 0 && ISSET(cmd->c_flags, SCF_RSP_PRESENT)) {
		if (ISSET(cmd->c_flags, SCF_RSP_136)) {
			u_char *p = (u_char *)cmd->c_resp;
			int i;

			for (i = 0; i < 15; i++)
				*p++ = HREAD1(hp, SDHC_RESPONSE + i);
		} else
			cmd->c_resp[0] = HREAD4(hp, SDHC_RESPONSE);
	}

	if (cmd->c_error == 0 && cmd->c_data != NULL) {
		timeout_add(&hp->cmd_to, SDHC_DATA_TIMEOUT);
		sdhc_transfer_data(hp);
	}

	/* Turn off the LED. */
	HCLR1(hp, SDHC_HOST_CTL, SDHC_LED_ON);

	error = cmd->c_error;
	hp->cmd = NULL;

	SET(cmd->c_flags, SCF_DONE);
	DPRINTF(("%s: cmd %u done (flags=%#x error=%d)\n",
	    HDEVNAME(hp), cmd->c_opcode, cmd->c_flags, error));
	if (cmd->c_done != NULL)
		cmd->c_done(hp->sdmmc, cmd);
	return error;
}

d699 1
a699 1
sdhc_transfer_data(struct sdhc_host *hp)
a700 1
	struct sdmmc_command *cmd = hp->cmd;
d711 3
a713 2
	DPRINTF(("%s: resp=%#x ", HDEVNAME(hp), MMC_R1(cmd->c_resp)));
	DPRINTF(("datalen %u\n", datalen));
d715 3
a717 2
		error = sdhc_wait_command(hp, SCF_DONE|SCF_BUF_READY);
		if (error != 0)
d719 1
d721 1
a721 2
		error = sdhc_wait_state(hp, mask, mask);
		if (error != 0)
a731 1
		CLR(cmd->c_flags, SCF_BUF_READY);
d734 3
a736 2
	if (error == 0)
		error = sdhc_wait_command(hp, SCF_DONE|SCF_XFR_DONE);
d738 1
a738 3
	timeout_del(&hp->cmd_to);

	if (cmd->c_error == 0) {
d740 1
a740 2
		SET(cmd->c_flags, SCF_DONE);
	}
d783 1
d785 1
a785 1
sdhc_command_timeout(void *arg)
d787 9
a795 2
	struct sdhc_host *hp = arg;
	struct sdmmc_command *cmd = hp->cmd;
d798 1
a798 2
	if (cmd == NULL)
		return;
d801 19
a819 12
	if (!ISSET(cmd->c_flags, SCF_DONE)) {
		DPRINTF(("%s: timeout cmd %u, resetting...\n",
		    HDEVNAME(hp), cmd->c_opcode));
		cmd->c_error = ETIMEDOUT;
		SET(cmd->c_flags, SCF_DONE);
		HWRITE1(hp, SDHC_SOFTWARE_RESET, SDHC_RESET_DAT|
		    SDHC_RESET_CMD);
		timeout_add(&hp->cmd_to, hz/2);
	} else {
		DPRINTF(("%s: timeout cmd %u, resetting...done\n",
		    HDEVNAME(hp), cmd->c_opcode));
		wakeup(hp);
d821 1
d823 1
d833 1
a834 1
	int host;
d844 1
d846 4
d853 2
a854 6
		/* Clear interrupts we are about to handle. */
		HWRITE2(hp, SDHC_NINTR_STATUS, status);
#ifdef SDHC_DEBUG
		printf("%s: interrupt status=%b\n", HDEVNAME(hp),
		    status, SDHC_NINTR_STATUS_BITS);
#endif
d857 1
a857 1
		 * Wake up the event thread to service the interrupt(s).
a858 30
		if (ISSET(status, SDHC_BUFFER_READ_READY|
		    SDHC_BUFFER_WRITE_READY)) {
			if (hp->cmd != NULL &&
			    !ISSET(hp->cmd->c_flags, SCF_DONE)) {
				SET(hp->cmd->c_flags, SCF_BUF_READY);
				wakeup(hp);
			}
			done++;
		}
		if (ISSET(status, SDHC_COMMAND_COMPLETE)) {
			if (hp->cmd != NULL &&
			    !ISSET(hp->cmd->c_flags, SCF_DONE)) {
				SET(hp->cmd->c_flags, SCF_CMD_DONE);
				wakeup(hp);
			}
			done++;
		}
		if (ISSET(status, SDHC_TRANSFER_COMPLETE)) {
			if (hp->cmd != NULL &&
			    !ISSET(hp->cmd->c_flags, SCF_DONE)) {
				SET(hp->cmd->c_flags, SCF_XFR_DONE);
				wakeup(hp);
			}
			done++;
		}
		if (ISSET(status, SDHC_CARD_REMOVAL|SDHC_CARD_INSERTION)) {
			wakeup(hp);
			done++;
		}

d862 1
a864 1

a867 2
			/* XXX command timeout has higher priority
			 * than command complete */
d869 4
a872 8
			    SDHC_DATA_TIMEOUT_ERROR) && hp->cmd != NULL &&
			    !ISSET(hp->cmd->c_flags, SCF_DONE)) {
				hp->cmd->c_error = ETIMEDOUT;
				SET(hp->cmd->c_flags, SCF_DONE);
				/* XXX can this reset be avoided? */
				HWRITE1(hp, SDHC_SOFTWARE_RESET,
				    SDHC_RESET_DAT|SDHC_RESET_CMD);
				timeout_add(&hp->cmd_to, hz/2);
a873 1
			done++;
d876 20
d897 1
a899 1
			printf("%s: card interrupt\n", HDEVNAME(hp));
@


1.7
log
@correct the way hosts are alloc'ed. fixes crashes on controllers with
multiple slots. tested by me and ian@@. uwe@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.6 2006/07/10 17:58:23 fgsch Exp $	*/
d141 1
d245 1
a245 1
		printf("%s: can't attach bus\n", sc->sc_dev.dv_xname);
d265 1
a265 1
	return 1;
@


1.6
log
@print the frequency in mhz, really.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.5 2006/06/29 01:32:33 uwe Exp $	*/
d159 3
a161 8
	MALLOC(hp, struct sdhc_host *, sizeof(struct sdhc_host) *
	    sc->sc_nhosts, M_DEVBUF, M_WAITOK);
	if (sc->sc_host != NULL) {
		bcopy(sc->sc_host, hp, sizeof(struct sdhc_host) *
		    (sc->sc_nhosts-1));
		FREE(sc->sc_host, M_DEVBUF);
	}
	sc->sc_host = hp;
a163 1
	hp = &sc->sc_host[sc->sc_nhosts-1];
d260 3
a262 1
	/* XXX: Leaking one sdhc_host structure here. */
d344 1
a344 1
			hp = &sc->sc_host[n];
d353 1
a353 1
			hp = &sc->sc_host[n];
d374 1
a374 1
		hp = &sc->sc_host[i];
d963 1
a963 1
		struct sdhc_host *hp = &sc->sc_host[host];
@


1.5
log
@Thanks to ian@@ who experimented a lot with his TI PCI7621 SDHC, we know
that the controller "kind-of" works, but it does not indicate completion
of the host controller reset.  Thus we cannot know whether the reset was
successful or not, so don't return an error if the reset timed out.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.4 2006/06/02 20:03:05 uwe Exp $	*/
d201 1
a201 1
		    sc->sc_dev.dv_xname, hp->clkbase);
@


1.4
log
@Implement power hook (without looking at the capabilities yet).
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.3 2006/06/01 21:47:42 uwe Exp $	*/
d108 1
a108 1
#define DPRINTF(s)	/**/
d179 1
a179 4
	if (sdhc_host_reset(hp) != 0) {
		printf("%s: host reset failed\n", sc->sc_dev.dv_xname);
		goto err;
	}
d358 1
d379 1
a379 1
		sdhc_host_reset(hp);
d385 5
a389 1
 * cards are removed and during error recovery.
a395 1
	int error = 0;
d405 2
a406 1
	 * Reset the entire host controller and wait up to 100ms.
d416 1
a416 1
		error = ETIMEDOUT;
d433 1
a433 1
	return error;
d482 1
a482 2
		if (sdhc_host_reset(hp) != 0)
			DPRINTF(("%s: host reset failed\n", HDEVNAME(hp)));
@


1.3
log
@fewer debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.2 2006/05/28 18:45:23 uwe Exp $	*/
d53 1
a296 1
		//DPRINTF(("%s: tsleep sdhcev\n", HDEVNAME(hp)));
a304 2
	//DPRINTF(("%s: event process\n", HDEVNAME(hp)));

d339 3
a341 1
	/* struct sdhc_softc *sc = arg; */
d346 9
a354 1
		/* XXX suspend or detach cards */
d356 1
d358 6
a363 1
		/* XXX resume or reattach cards */
@


1.2
log
@don't #undef SDMMC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sdhc.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d467 1
a467 1
			printf("%s: host reset failed\n", HDEVNAME(hp));
d649 2
a650 1
	DPRINTF(("%s: start cmd %u\n", HDEVNAME(hp), cmd->c_opcode));
a767 2
		DPRINTF(("%s: tsleep sdhccmd (flags=%#x)\n",
		    HDEVNAME(hp), flags));
a790 3
	DPRINTF(("%s: finish cmd %u (flags=%#x error=%d)\n",
	    HDEVNAME(hp), cmd->c_opcode, cmd->c_flags, cmd->c_error));

d1011 2
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a36 2

#undef SDHC_DEBUG
@

