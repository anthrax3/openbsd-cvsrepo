head	1.47;
access;
symbols
	OPENBSD_6_2:1.47.0.4
	OPENBSD_6_2_BASE:1.47
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.38.0.2
	OPENBSD_5_9_BASE:1.38
	OPENBSD_5_8:1.38.0.4
	OPENBSD_5_8_BASE:1.38
	OPENBSD_5_7:1.37.0.4
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.34.0.4
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.32.0.4
	OPENBSD_5_5_BASE:1.32
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.26.0.6
	OPENBSD_5_3_BASE:1.26
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.4
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.19.0.2
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.14.0.4
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.14.0.2
	OPENBSD_4_3_BASE:1.14
	OPENBSD_4_2:1.12.0.2
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.7.0.2
	OPENBSD_4_0_BASE:1.7;
locks; strict;
comment	@ * @;


1.47
date	2017.04.06.07.07.28;	author jsg;	state Exp;
branches;
next	1.46;
commitid	SsiIen2AJibDpkuK;

1.46
date	2017.04.06.03.15.29;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	gHgDmKzMHGPreBpA;

1.45
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.44;
commitid	CHRb0fCqa8XxUAMH;

1.44
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.43;
commitid	tXZ4cDDS7O2NIM1F;

1.43
date	2016.05.04.09.30.06;	author kettenis;	state Exp;
branches;
next	1.42;
commitid	nKwnMLLuwctt5XwF;

1.42
date	2016.05.01.22.07.42;	author kettenis;	state Exp;
branches;
next	1.41;
commitid	vxjh2K7JCSTI8Mby;

1.41
date	2016.05.01.16.04.39;	author kettenis;	state Exp;
branches;
next	1.40;
commitid	rwmsBKqrjX2EodCO;

1.40
date	2016.04.30.11.32.23;	author kettenis;	state Exp;
branches;
next	1.39;
commitid	idV1JJlqFozdGODX;

1.39
date	2016.03.19.11.41.56;	author mpi;	state Exp;
branches;
next	1.38;
commitid	YKz4aSf7zOPIkVrc;

1.38
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.37;
commitid	p4LJxGKbi0BU2cG6;

1.37
date	2015.02.16.17.35.17;	author miod;	state Exp;
branches;
next	1.36;
commitid	iD8buocQsI8XctnI;

1.36
date	2014.11.01.16.32.06;	author jsg;	state Exp;
branches;
next	1.35;
commitid	XzgnhFuyvefbeawB;

1.35
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.34;
commitid	uzzBR7hz9ncd4O6G;

1.34
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.33;
commitid	OBNa5kfxQ2UXoiIw;

1.33
date	2014.03.05.21.35.21;	author sthen;	state Exp;
branches;
next	1.32;

1.32
date	2014.01.23.01.41.44;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2013.12.21.17.10.08;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.18.20.21.51;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2013.09.12.11.54.04;	author rapha;	state Exp;
branches;
next	1.27;

1.27
date	2013.05.31.21.28.32;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2011.11.14.14.13.45;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2011.11.10.14.24.29;	author uwe;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.23;

1.23
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.02.18.05.28;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.02.09.21.58;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2009.04.07.16.35.52;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2009.02.20.19.16.35;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2009.01.09.10.58.38;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2009.01.09.10.55.22;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2008.12.02.23.49.54;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2008.11.24.07.32.08;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.31.10.09.01;	author uwe;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.26.17.06.36;	author uwe;	state Exp;
branches;
next	1.10;

1.10
date	2007.03.24.00.44.26;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2006.11.29.14.16.43;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.29.00.46.52;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.18.04.10.35;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.29.01.35.37;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2006.06.03.03.53.47;	author martin;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.01.22.33.37;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.21.53.41;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.18.45.23;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.47
log
@remove stray character in previous that broke the build
@
text
@/*	$OpenBSD: sdmmc.c,v 1.46 2017/04/06 03:15:29 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Host controller independent SD/MMC bus driver based on information
 * from SanDisk SD Card Product Manual Revision 2.2 (SanDisk), SDIO
 * Simple Specification Version 1.0 (SDIO) and the Linux "mmc" driver.
 */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/kthread.h>
#include <sys/malloc.h>
#include <sys/rwlock.h>
#include <sys/systm.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/sdmmc/sdmmc_scsi.h>
#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcreg.h>
#include <dev/sdmmc/sdmmcvar.h>

#ifdef SDMMC_IOCTL
#include "bio.h"
#if NBIO < 1
#undef SDMMC_IOCTL
#endif
#include <dev/biovar.h>
#endif

int	sdmmc_match(struct device *, void *, void *);
void	sdmmc_attach(struct device *, struct device *, void *);
int	sdmmc_detach(struct device *, int);
int	sdmmc_activate(struct device *, int);

void	sdmmc_create_thread(void *);
void	sdmmc_task_thread(void *);
void	sdmmc_discover_task(void *);
void	sdmmc_card_attach(struct sdmmc_softc *);
void	sdmmc_card_detach(struct sdmmc_softc *, int);
int	sdmmc_enable(struct sdmmc_softc *);
void	sdmmc_disable(struct sdmmc_softc *);
int	sdmmc_scan(struct sdmmc_softc *);
int	sdmmc_init(struct sdmmc_softc *);
#ifdef SDMMC_IOCTL
int	sdmmc_ioctl(struct device *, u_long, caddr_t);
#endif

#ifdef SDMMC_DEBUG
int sdmmcdebug = 0;
extern int sdhcdebug;	/* XXX should have a sdmmc_chip_debug() function */
void sdmmc_dump_command(struct sdmmc_softc *, struct sdmmc_command *);
#define DPRINTF(n,s)	do { if ((n) <= sdmmcdebug) printf s; } while (0)
#else
#define DPRINTF(n,s)	do {} while (0)
#endif

struct cfattach sdmmc_ca = {
	sizeof(struct sdmmc_softc), sdmmc_match, sdmmc_attach, sdmmc_detach,
	sdmmc_activate
};

struct cfdriver sdmmc_cd = {
	NULL, "sdmmc", DV_DULL
};

int
sdmmc_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct sdmmcbus_attach_args *saa = aux;

	return strcmp(saa->saa_busname, cf->cf_driver->cd_name) == 0;
}

void
sdmmc_attach(struct device *parent, struct device *self, void *aux)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)self;
	struct sdmmcbus_attach_args *saa = aux;
	int error;

	if (ISSET(saa->caps, SMC_CAPS_8BIT_MODE))
		printf(": 8-bit");
	else if (ISSET(saa->caps, SMC_CAPS_4BIT_MODE))
		printf(": 4-bit");
	else
		printf(": 1-bit");
	if (ISSET(saa->caps, SMC_CAPS_SD_HIGHSPEED))
		printf(", sd high-speed");
	if (ISSET(saa->caps, SMC_CAPS_MMC_HIGHSPEED))
		printf(", mmc high-speed");
	if (ISSET(saa->caps, SMC_CAPS_DMA))
		printf(", dma");
	printf("\n");

	sc->sct = saa->sct;
	sc->sch = saa->sch;
	sc->sc_dmat = saa->dmat;
	sc->sc_flags = saa->flags;
	sc->sc_caps = saa->caps;
	sc->sc_max_xfer = saa->max_xfer;

	if (ISSET(sc->sc_caps, SMC_CAPS_DMA)) {
		error = bus_dmamap_create(sc->sc_dmat, MAXPHYS, SDMMC_MAXNSEGS,
		    MAXPHYS, 0, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW, &sc->sc_dmap);
		if (error) {
			printf("%s: can't create DMA map\n", DEVNAME(sc));
			return;
		}
	}

	SIMPLEQ_INIT(&sc->sf_head);
	TAILQ_INIT(&sc->sc_tskq);
	TAILQ_INIT(&sc->sc_intrq);
	sdmmc_init_task(&sc->sc_discover_task, sdmmc_discover_task, sc);
	sdmmc_init_task(&sc->sc_intr_task, sdmmc_intr_task, sc);
	rw_init(&sc->sc_lock, DEVNAME(sc));

#ifdef SDMMC_IOCTL
	if (bio_register(self, sdmmc_ioctl) != 0)
		printf("%s: unable to register ioctl\n", DEVNAME(sc));
#endif

	/*
	 * Create the event thread that will attach and detach cards
	 * and perform other lengthy operations.  Enter config_pending
	 * state until the discovery task has run for the first time.
	 */
	SET(sc->sc_flags, SMF_CONFIG_PENDING);
	config_pending_incr();
	kthread_create_deferred(sdmmc_create_thread, sc);
}

int
sdmmc_detach(struct device *self, int flags)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)self;

	sc->sc_dying = 1;
	while (sc->sc_task_thread != NULL) {
		wakeup(&sc->sc_tskq);
		tsleep(sc, PWAIT, "mmcdie", 0);
	}

	if (sc->sc_dmap)
		bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmap);

	return 0;
}

int
sdmmc_activate(struct device *self, int act)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		/* If card in slot, cause a detach/re-attach */
		if (ISSET(sc->sc_flags, SMF_CARD_PRESENT))
			sc->sc_dying = -1;
		break;
	case DVACT_RESUME:
		rv = config_activate_children(self, act);
		wakeup(&sc->sc_tskq);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
sdmmc_create_thread(void *arg)
{
	struct sdmmc_softc *sc = arg;

	if (kthread_create(sdmmc_task_thread, sc, &sc->sc_task_thread,
	    DEVNAME(sc)) != 0)
		printf("%s: can't create task thread\n", DEVNAME(sc));

}

void
sdmmc_task_thread(void *arg)
{
	struct sdmmc_softc *sc = arg;
	struct sdmmc_task *task;
	int s;

restart:
	sdmmc_needs_discover(&sc->sc_dev);

	s = splsdmmc();
	while (!sc->sc_dying) {
		for (task = TAILQ_FIRST(&sc->sc_tskq); task != NULL;
		     task = TAILQ_FIRST(&sc->sc_tskq)) {
			splx(s);
			sdmmc_del_task(task);
			task->func(task->arg);
			s = splsdmmc();
		}
		tsleep(&sc->sc_tskq, PWAIT, "mmctsk", 0);
	}
	splx(s);

	if (ISSET(sc->sc_flags, SMF_CARD_PRESENT)) {
		rw_enter_write(&sc->sc_lock);
		sdmmc_card_detach(sc, DETACH_FORCE);
		rw_exit(&sc->sc_lock);
	}

	/*
	 * During a suspend, the card is detached since we do not know
	 * if it is the same upon wakeup.  Go re-discover the bus.
	 */
	if (sc->sc_dying == -1) {
		CLR(sc->sc_flags, SMF_CARD_PRESENT);
		sc->sc_dying = 0;
		goto restart;
	}
	sc->sc_task_thread = NULL;
	wakeup(sc);
	kthread_exit(0);
}

void
sdmmc_add_task(struct sdmmc_softc *sc, struct sdmmc_task *task)
{
	int s;

	s = splsdmmc();
	TAILQ_INSERT_TAIL(&sc->sc_tskq, task, next);
	task->onqueue = 1;
	task->sc = sc;
	wakeup(&sc->sc_tskq);
	splx(s);
}

void
sdmmc_del_task(struct sdmmc_task *task)
{
	struct sdmmc_softc *sc = task->sc;
	int s;

	if (sc == NULL)
		return;

	s = splsdmmc();
	task->sc = NULL;
	task->onqueue = 0;
	TAILQ_REMOVE(&sc->sc_tskq, task, next);
	splx(s);
}

void
sdmmc_needs_discover(struct device *self)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)self;

	if (!sdmmc_task_pending(&sc->sc_discover_task))
		sdmmc_add_task(sc, &sc->sc_discover_task);
}

void
sdmmc_discover_task(void *arg)
{
	struct sdmmc_softc *sc = arg;

	if (sdmmc_chip_card_detect(sc->sct, sc->sch)) {
		if (!ISSET(sc->sc_flags, SMF_CARD_PRESENT)) {
			SET(sc->sc_flags, SMF_CARD_PRESENT);
			sdmmc_card_attach(sc);
		}
	} else {
		if (ISSET(sc->sc_flags, SMF_CARD_PRESENT)) {
			CLR(sc->sc_flags, SMF_CARD_PRESENT);
			rw_enter_write(&sc->sc_lock);
			sdmmc_card_detach(sc, DETACH_FORCE);
			rw_exit(&sc->sc_lock);
		}
	}

	if (ISSET(sc->sc_flags, SMF_CONFIG_PENDING)) {
		CLR(sc->sc_flags, SMF_CONFIG_PENDING);
		config_pending_decr();
	}
}

/*
 * Called from process context when a card is present.
 */
void
sdmmc_card_attach(struct sdmmc_softc *sc)
{
	DPRINTF(1,("%s: attach card\n", DEVNAME(sc)));

	rw_enter_write(&sc->sc_lock);
	CLR(sc->sc_flags, SMF_CARD_ATTACHED);

	/*
	 * Power up the card (or card stack).
	 */
	if (sdmmc_enable(sc) != 0) {
		printf("%s: can't enable card\n", DEVNAME(sc));
		goto err;
	}

	/*
	 * Scan for I/O functions and memory cards on the bus,
	 * allocating a sdmmc_function structure for each.
	 */
	if (sdmmc_scan(sc) != 0) {
		printf("%s: no functions\n", DEVNAME(sc));
		goto err;
	}

	/*
	 * Initialize the I/O functions and memory cards.
	 */
	if (sdmmc_init(sc) != 0) {
		printf("%s: init failed\n", DEVNAME(sc));
		goto err;
	}

	/* Attach SCSI emulation for memory cards. */
	if (ISSET(sc->sc_flags, SMF_MEM_MODE))
		sdmmc_scsi_attach(sc);

	/* Attach I/O function drivers. */
	if (ISSET(sc->sc_flags, SMF_IO_MODE))
		sdmmc_io_attach(sc);

	SET(sc->sc_flags, SMF_CARD_ATTACHED);
	rw_exit(&sc->sc_lock);
	return;
err:
	sdmmc_card_detach(sc, DETACH_FORCE);
	rw_exit(&sc->sc_lock);
}

/*
 * Called from process context with DETACH_* flags from <sys/device.h>
 * when cards are gone.
 */
void
sdmmc_card_detach(struct sdmmc_softc *sc, int flags)
{
	struct sdmmc_function *sf, *sfnext;

	rw_assert_wrlock(&sc->sc_lock);

	DPRINTF(1,("%s: detach card\n", DEVNAME(sc)));

	if (ISSET(sc->sc_flags, SMF_CARD_ATTACHED)) {
		/* Detach I/O function drivers. */
		if (ISSET(sc->sc_flags, SMF_IO_MODE))
			sdmmc_io_detach(sc);

		/* Detach the SCSI emulation for memory cards. */
		if (ISSET(sc->sc_flags, SMF_MEM_MODE))
			sdmmc_scsi_detach(sc);

		CLR(sc->sc_flags, SMF_CARD_ATTACHED);
	}

	/* Power down. */
	sdmmc_disable(sc);

	/* Free all sdmmc_function structures. */
	for (sf = SIMPLEQ_FIRST(&sc->sf_head); sf != NULL; sf = sfnext) {
		sfnext = SIMPLEQ_NEXT(sf, sf_list);
		sdmmc_function_free(sf);
	}
	SIMPLEQ_INIT(&sc->sf_head);
	sc->sc_function_count = 0;
	sc->sc_fn0 = NULL;
}

int
sdmmc_enable(struct sdmmc_softc *sc)
{
	u_int32_t host_ocr;
	int error;

	rw_assert_wrlock(&sc->sc_lock);

	/*
	 * Calculate the equivalent of the card OCR from the host
	 * capabilities and select the maximum supported bus voltage.
	 */
	host_ocr = sdmmc_chip_host_ocr(sc->sct, sc->sch);
	error = sdmmc_chip_bus_power(sc->sct, sc->sch, host_ocr);
	if (error != 0) {
		printf("%s: can't supply bus power\n", DEVNAME(sc));
		goto err;
	}

	/*
	 * Select the minimum clock frequency.
	 */
	error = sdmmc_chip_bus_clock(sc->sct, sc->sch,
	    SDMMC_SDCLK_400KHZ, SDMMC_TIMING_LEGACY);
	if (error != 0) {
		printf("%s: can't supply clock\n", DEVNAME(sc));
		goto err;
	}

	/* XXX wait for card to power up */
	sdmmc_delay(250000);

	/* Initialize SD I/O card function(s). */
	if ((error = sdmmc_io_enable(sc)) != 0)
		goto err;

	/* Initialize SD/MMC memory card(s). */
	if (ISSET(sc->sc_flags, SMF_MEM_MODE) &&
	    (error = sdmmc_mem_enable(sc)) != 0)
		goto err;

 err:
	if (error != 0)
		sdmmc_disable(sc);

	return error;
}

void
sdmmc_disable(struct sdmmc_softc *sc)
{
	/* XXX complete commands if card is still present. */

	rw_assert_wrlock(&sc->sc_lock);

	/* Make sure no card is still selected. */
	(void)sdmmc_select_card(sc, NULL);

	/* Turn off bus power and clock. */
	(void)sdmmc_chip_bus_clock(sc->sct, sc->sch,
	    SDMMC_SDCLK_OFF, SDMMC_TIMING_LEGACY);
	(void)sdmmc_chip_bus_power(sc->sct, sc->sch, 0);
}

/*
 * Set the lowest bus voltage supported by the card and the host.
 */
int
sdmmc_set_bus_power(struct sdmmc_softc *sc, u_int32_t host_ocr,
    u_int32_t card_ocr)
{
	u_int32_t bit;

	rw_assert_wrlock(&sc->sc_lock);

	/* Mask off unsupported voltage levels and select the lowest. */
	DPRINTF(1,("%s: host_ocr=%x ", DEVNAME(sc), host_ocr));
	host_ocr &= card_ocr;
	for (bit = 4; bit < 23; bit++) {
		if (ISSET(host_ocr, 1<<bit)) {
			host_ocr &= 3<<bit;
			break;
		}
	}
	DPRINTF(1,("card_ocr=%x new_ocr=%x\n", card_ocr, host_ocr));

	if (host_ocr == 0 ||
	    sdmmc_chip_bus_power(sc->sct, sc->sch, host_ocr) != 0)
		return 1;
	return 0;
}

struct sdmmc_function *
sdmmc_function_alloc(struct sdmmc_softc *sc)
{
	struct sdmmc_function *sf;

	sf = (struct sdmmc_function *)malloc(sizeof *sf, M_DEVBUF,
	    M_WAITOK | M_ZERO);
	sf->sc = sc;
	sf->number = -1;
	sf->cis.manufacturer = SDMMC_VENDOR_INVALID;
	sf->cis.product = SDMMC_PRODUCT_INVALID;
	sf->cis.function = SDMMC_FUNCTION_INVALID;
	return sf;
}

void
sdmmc_function_free(struct sdmmc_function *sf)
{
	free(sf, M_DEVBUF, sizeof *sf);
}

/*
 * Scan for I/O functions and memory cards on the bus, allocating a
 * sdmmc_function structure for each.
 */
int
sdmmc_scan(struct sdmmc_softc *sc)
{

	rw_assert_wrlock(&sc->sc_lock);

	/* Scan for I/O functions. */
	if (ISSET(sc->sc_flags, SMF_IO_MODE))
		sdmmc_io_scan(sc);

	/* Scan for memory cards on the bus. */
	if (ISSET(sc->sc_flags, SMF_MEM_MODE))
		sdmmc_mem_scan(sc);

	/* There should be at least one function now. */
	if (SIMPLEQ_EMPTY(&sc->sf_head)) {
		printf("%s: can't identify card\n", DEVNAME(sc));
		return 1;
	}
	return 0;
}

/*
 * Initialize all the distinguished functions of the card, be it I/O
 * or memory functions.
 */
int
sdmmc_init(struct sdmmc_softc *sc)
{
	struct sdmmc_function *sf;

	rw_assert_wrlock(&sc->sc_lock);

	/* Initialize all identified card functions. */
	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		if (ISSET(sc->sc_flags, SMF_IO_MODE) &&
		    sdmmc_io_init(sc, sf) != 0)
			printf("%s: i/o init failed\n", DEVNAME(sc));

		if (ISSET(sc->sc_flags, SMF_MEM_MODE) &&
		    sdmmc_mem_init(sc, sf) != 0)
			printf("%s: mem init failed\n", DEVNAME(sc));
	}

	/* Any good functions left after initialization? */
	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		if (!ISSET(sf->flags, SFF_ERROR))
			return 0;
	}
	/* No, we should probably power down the card. */
	return 1;
}

void
sdmmc_delay(u_int usecs)
{
	int nticks = usecs / (1000000 / hz);

	if (!cold && nticks > 0)
		tsleep(&sdmmc_delay, PWAIT, "mmcdly", nticks);
	else
		delay(usecs);
}

int
sdmmc_app_command(struct sdmmc_softc *sc, struct sdmmc_command *cmd)
{
	struct sdmmc_command acmd;
	int error;

	rw_assert_wrlock(&sc->sc_lock);

	bzero(&acmd, sizeof acmd);
	acmd.c_opcode = MMC_APP_CMD;
	acmd.c_arg = 0;
	if (sc->sc_card != NULL) {
		acmd.c_arg = sc->sc_card->rca << 16;
	}
	acmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;

	error = sdmmc_mmc_command(sc, &acmd);
	if (error != 0) {
		return error;
	}

	if (!ISSET(MMC_R1(acmd.c_resp), MMC_R1_APP_CMD)) {
		/* Card does not support application commands. */
		return ENODEV;
	}

	error = sdmmc_mmc_command(sc, cmd);
	return error;
}

/*
 * Execute MMC command and data transfers.  All interactions with the
 * host controller to complete the command happen in the context of
 * the current process.
 */
int
sdmmc_mmc_command(struct sdmmc_softc *sc, struct sdmmc_command *cmd)
{
	int error;

	rw_assert_wrlock(&sc->sc_lock);

	sdmmc_chip_exec_command(sc->sct, sc->sch, cmd);

#ifdef SDMMC_DEBUG
	sdmmc_dump_command(sc, cmd);
#endif

	error = cmd->c_error;
	wakeup(cmd);

	return error;
}

/*
 * Send the "GO IDLE STATE" command.
 */
void
sdmmc_go_idle_state(struct sdmmc_softc *sc)
{
	struct sdmmc_command cmd;

	rw_assert_wrlock(&sc->sc_lock);

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = MMC_GO_IDLE_STATE;
	cmd.c_flags = SCF_CMD_BC | SCF_RSP_R0;

	(void)sdmmc_mmc_command(sc, &cmd);
}

/*
 * Send the "SEND_IF_COND" command, to check operating condition
 */
int
sdmmc_send_if_cond(struct sdmmc_softc *sc, uint32_t card_ocr)
{
	struct sdmmc_command cmd;
	uint8_t pat = 0x23;	/* any pattern will do here */
	uint8_t res;

	rw_assert_wrlock(&sc->sc_lock);

	bzero(&cmd, sizeof cmd);

	cmd.c_opcode = SD_SEND_IF_COND;
	cmd.c_arg = ((card_ocr & SD_OCR_VOL_MASK) != 0) << 8 | pat;
	cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R7;

	if (sdmmc_mmc_command(sc, &cmd) != 0)
		return 1;

	res = cmd.c_resp[0];
	if (res != pat)
		return 1;
	else
		return 0;
}

/*
 * Retrieve (SD) or set (MMC) the relative card address (RCA).
 */
int
sdmmc_set_relative_addr(struct sdmmc_softc *sc,
    struct sdmmc_function *sf)
{
	struct sdmmc_command cmd;

	rw_assert_wrlock(&sc->sc_lock);

	bzero(&cmd, sizeof cmd);

	if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
		cmd.c_opcode = SD_SEND_RELATIVE_ADDR;
		cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R6;
	} else {
		cmd.c_opcode = MMC_SET_RELATIVE_ADDR;
		cmd.c_arg = MMC_ARG_RCA(sf->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;
	}

	if (sdmmc_mmc_command(sc, &cmd) != 0)
		return 1;

	if (ISSET(sc->sc_flags, SMF_SD_MODE))
		sf->rca = SD_R6_RCA(cmd.c_resp);
	return 0;
}

int
sdmmc_select_card(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	struct sdmmc_command cmd;
	int error;

	rw_assert_wrlock(&sc->sc_lock);

	if (sc->sc_card == sf || (sf && sc->sc_card &&
	    sc->sc_card->rca == sf->rca)) {
		sc->sc_card = sf;
		return 0;
	}

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = MMC_SELECT_CARD;
	cmd.c_arg = sf == NULL ? 0 : MMC_ARG_RCA(sf->rca);
	cmd.c_flags = SCF_CMD_AC | (sf == NULL ? SCF_RSP_R0 : SCF_RSP_R1);
	error = sdmmc_mmc_command(sc, &cmd);
	if (error == 0 || sf == NULL)
		sc->sc_card = sf;
	return error;
}

#ifdef SDMMC_IOCTL
int
sdmmc_ioctl(struct device *self, u_long request, caddr_t addr)
{
	struct sdmmc_softc *sc = (struct sdmmc_softc *)self;
	struct sdmmc_command *ucmd;
	struct sdmmc_command cmd;
	void *data;
	int error = 0;

	switch (request) {
#ifdef SDMMC_DEBUG
	case SDIOCSETDEBUG:
		sdmmcdebug = (((struct bio_sdmmc_debug *)addr)->debug) & 0xff;
		sdhcdebug = (((struct bio_sdmmc_debug *)addr)->debug >> 8) & 0xff;
		break;
#endif

	case SDIOCEXECMMC:
	case SDIOCEXECAPP:
		ucmd = &((struct bio_sdmmc_command *)addr)->cmd;

		/* Refuse to transfer more than 512K per command. */
		if (ucmd->c_datalen > 524288)
			return ENOMEM;

		/* Verify that the data buffer is safe to copy. */
		if ((ucmd->c_datalen > 0 && ucmd->c_data == NULL) ||
		    (ucmd->c_datalen < 1 && ucmd->c_data != NULL) ||
		    ucmd->c_datalen < 0)
			return EINVAL;

		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = ucmd->c_opcode;
		cmd.c_arg = ucmd->c_arg;
		cmd.c_flags = ucmd->c_flags;
		cmd.c_blklen = ucmd->c_blklen;

		if (ucmd->c_data) {
			data = malloc(ucmd->c_datalen, M_TEMP,
			    M_WAITOK | M_CANFAIL);
			if (data == NULL)
				return ENOMEM;
			error = copyin(ucmd->c_data, data, ucmd->c_datalen);
			if (error != 0)
				goto exec_done;

			cmd.c_data = data;
			cmd.c_datalen = ucmd->c_datalen;
		}

		rw_enter_write(&sc->sc_lock);
		if (request == SDIOCEXECMMC)
			error = sdmmc_mmc_command(sc, &cmd);
		else
			error = sdmmc_app_command(sc, &cmd);
		rw_exit(&sc->sc_lock);
		if (error && !cmd.c_error)
			cmd.c_error = error;

		bcopy(&cmd.c_resp, ucmd->c_resp, sizeof cmd.c_resp);
		ucmd->c_flags = cmd.c_flags;
		ucmd->c_error = cmd.c_error;

		if (ucmd->c_data)
			error = copyout(data, ucmd->c_data, ucmd->c_datalen);
		else
			error = 0;

exec_done:
		if (ucmd->c_data)
			free(data, M_TEMP, ucmd->c_datalen);
		break;

	default:
		return ENOTTY;
	}
	return error;
}
#endif

#ifdef SDMMC_DEBUG
void
sdmmc_dump_command(struct sdmmc_softc *sc, struct sdmmc_command *cmd)
{
	int i;

	rw_assert_wrlock(&sc->sc_lock);

	DPRINTF(1,("%s: cmd %u arg=%#x data=%p dlen=%d flags=%#x "
	    "proc=\"%s\" (error %d)\n", DEVNAME(sc), cmd->c_opcode,
	    cmd->c_arg, cmd->c_data, cmd->c_datalen, cmd->c_flags,
	    curproc ? curproc->p_p->ps_comm : "", cmd->c_error));

	if (cmd->c_error || sdmmcdebug < 1)
		return;

	printf("%s: resp=", DEVNAME(sc));
	if (ISSET(cmd->c_flags, SCF_RSP_136))
		for (i = 0; i < sizeof cmd->c_resp; i++)
			printf("%02x ", ((u_char *)cmd->c_resp)[i]);
	else if (ISSET(cmd->c_flags, SCF_RSP_PRESENT))
		for (i = 0; i < 4; i++)
			printf("%02x ", ((u_char *)cmd->c_resp)[i]);
	printf("\n");
}
#endif
@


1.46
log
@add sizes to free() calls
ok dhill
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.45 2017/01/21 05:42:04 guenther Exp $	*/
d479 1
a479 1
b	for (bit = 4; bit < 23; bit++) {
@


1.45
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.44 2016/05/05 11:01:08 kettenis Exp $	*/
d479 1
a479 1
	for (bit = 4; bit < 23; bit++) {
d511 1
a511 1
	free(sf, M_DEVBUF, 0);
d806 1
a806 1
			free(data, M_TEMP, 0);
@


1.44
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.43 2016/05/04 09:30:06 kettenis Exp $	*/
d827 1
a827 1
	    curproc ? curproc->p_comm : "", cmd->c_error));
@


1.43
log
@Add high-speed support for SD cards.  In theory this should double the
transfer rates to and from the card.  In practice the improvement will be
smaller, but I am seeing serious improvement in the read speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.42 2016/05/01 22:07:42 kettenis Exp $	*/
d423 2
a424 1
	error = sdmmc_chip_bus_clock(sc->sct, sc->sch, SDMMC_SDCLK_400KHZ);
d460 2
a461 1
	(void)sdmmc_chip_bus_clock(sc->sct, sc->sch, SDMMC_SDCLK_OFF);
@


1.42
log
@Print some capabilities.

ok deraadt@@, patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.41 2016/05/01 16:04:39 kettenis Exp $	*/
a439 5

	/* XXX respect host and card capabilities */
	if (ISSET(sc->sc_flags, SMF_SD_MODE))
		(void)sdmmc_chip_bus_clock(sc->sct, sc->sch,
		    SDMMC_SDCLK_25MHZ);
@


1.41
log
@Add support for changing the bus width to the sdmmc subsystem and the sdhc(4)
controller.  Use this to switch SD cards to a 4-bit bus if they support it.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.40 2016/04/30 11:32:23 kettenis Exp $	*/
d101 12
@


1.40
log
@Implement DMA support.  Bits and pieces taken from NetBSD, but we only
support ADMA2.  The older SDMA mode has too many limitations to be really
usable.  Gives us only moderate speed improvements, bus reduces the CPU load
considerably.  We will reap the full benefits once we implement wider bus
widths and high speed modes.

There is a remining issue with simultanious use of eMMC and external SD card
on (some) Intel Bay Trail hardware.  Still under investigation.

ok patrick@@, stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.39 2016/03/19 11:41:56 mpi Exp $	*/
a62 1
int	sdmmc_set_bus_width(struct sdmmc_function *);
a699 31
}

/*
 * Switch card and host to the maximum supported bus width.
 */
int
sdmmc_set_bus_width(struct sdmmc_function *sf)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;
	int error;

	rw_enter_write(&sc->sc_lock);

	if (!ISSET(sc->sc_flags, SMF_SD_MODE)) {
		rw_exit(&sc->sc_lock);
		return EOPNOTSUPP;
	}

	if ((error = sdmmc_select_card(sc, sf)) != 0) {
		rw_exit(&sc->sc_lock);
		return error;
	}

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = SD_APP_SET_BUS_WIDTH;
	cmd.c_arg = SD_ARG_BUS_WIDTH_4;
	cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;
	error = sdmmc_app_command(sc, &cmd);
	rw_exit(&sc->sc_lock);
	return error;
@


1.39
log
@Reduces the noise around the global ``ticks''  variable by renaming all
local ones to ``nticks''.

(missed in previous)

ok stefan@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.38 2015/03/14 03:38:49 jsg Exp $	*/
d100 1
d106 1
d111 9
d152 4
@


1.38
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.37 2015/02/16 17:35:17 miod Exp $	*/
d551 1
a551 1
	int ticks = usecs / (1000000 / hz);
d553 2
a554 2
	if (!cold && ticks > 0)
		tsleep(&sdmmc_delay, PWAIT, "mmcdly", ticks);
@


1.37
log
@Memory leak if copyin() or copyout() fails; found by Maxime Villard
max@@M00nBSD.net's code scanner; ok doug@@ jca@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.36 2014/11/01 16:32:06 jsg Exp $	*/
a35 1
#include <dev/sdmmc/sdmmc_ioreg.h>
@


1.36
log
@fix the build when SDMMC_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.35 2014/09/14 14:17:25 jsg Exp $	*/
d752 1
a752 1
	int error;
d787 3
a789 2
			if (copyin(ucmd->c_data, data, ucmd->c_datalen))
				return EFAULT;
d808 4
a811 3
		if (ucmd->c_data && copyout(data, ucmd->c_data,
		    ucmd->c_datalen))
			return EFAULT;
d813 1
d821 1
a821 1
	return 0;
@


1.35
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.34 2014/07/12 18:48:52 tedu Exp $	*/
d830 1
a830 1
	DPRINTF(1,("%s: cmd %u arg=%#x data=%#x dlen=%d flags=%#x "
@


1.34
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.33 2014/03/05 21:35:21 sthen Exp $	*/
a29 1
#include <sys/proc.h>
@


1.33
log
@Raise the delay before initializing sdmmc. Still a hack so the XXX stays,
but at least lets the reader on X220 work pretty reliably, rather than about
1/4 of the time.  ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.32 2014/01/23 01:41:44 deraadt Exp $	*/
d490 1
a490 1
	free(sf, M_DEVBUF);
d813 1
a813 1
			free(data, M_TEMP);
@


1.32
log
@if cold, do not use tsleep, but use the delay path.
Such as during DVACT_RESUME...
ok guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.31 2013/12/21 17:10:08 deraadt Exp $	*/
d406 1
a406 1
	sdmmc_delay(100000);
@


1.31
log
@rearrange DVACT_RESUME chunk to avoid implying something ridiculous
ok stsp
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.31 2013/12/21 17:05:31 deraadt Exp $	*/
d555 1
a555 1
	if (ticks > 0)
@


1.30
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.29 2013/11/18 20:21:51 deraadt Exp $	*/
d160 1
a161 1
		rv = config_activate_children(self, act);
@


1.29
log
@simplify kthread_create(). no more stdarg
ok matthew guenther mikeb
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.28 2013/09/12 11:54:04 rapha Exp $	*/
a152 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d159 2
a160 1
	case DVACT_POWERDOWN:
d163 1
a163 2
	case DVACT_RESUME:
		wakeup(&sc->sc_tskq);
@


1.28
log
@Add basic support for eMMC memory.
Heavily based on netbsd.

Tested by dlg@@, bcallah@@ (sdhc), stsp@@ (rstx) and me (ommmc).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.27 2013/05/31 21:28:32 deraadt Exp $	*/
d179 1
a179 1
	    "%s", DEVNAME(sc)) != 0)
@


1.27
log
@Correct sequencing in ca_activate function.  Some operations were in the
wrong order, and depth traversal was not gauranteed.
ok stsp (tested too)
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.26 2011/11/14 14:13:45 deraadt Exp $	*/
d108 1
d575 3
@


1.26
log
@local variable not needed in sdmmc_activate
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.25 2011/11/10 14:24:29 uwe Exp $	*/
d149 1
d152 3
d156 1
d161 3
d166 1
d169 1
a169 1
	return (0);
@


1.25
log
@Fixed config_pending calls in sdmmc(4)

Root on SD/MMC card did not work reliably because the config_pending
state was cleared too early.  This change will clear config_pending
only after the card discovery has actually completed once.

ok deraadt@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.24 2010/08/24 14:52:23 blambert Exp $	*/
a148 1
	int rv = 0;
d160 1
a160 1
	return (rv);
@


1.24
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.23 2010/08/19 17:54:12 jasper Exp $	*/
d124 2
a125 1
	 * and perform other lengthy operations.
d127 1
a127 1
#ifdef DO_CONFIG_PENDING
a128 1
#endif
a172 3
#ifdef DO_CONFIG_PENDING
	config_pending_decr();
#endif
d273 5
@


1.23
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.22 2010/07/02 18:05:28 deraadt Exp $	*/
d31 1
d115 1
a115 1
	lockinit(&sc->sc_lock, PRIBIO, DEVNAME(sc), 0, 0);
d202 1
a202 1
		SDMMC_LOCK(sc);
d204 1
a204 1
		SDMMC_UNLOCK(sc);
d272 1
a272 1
			SDMMC_LOCK(sc);
d274 1
a274 1
			SDMMC_UNLOCK(sc);
d287 1
a287 1
	SDMMC_LOCK(sc);
d324 1
a324 1
	SDMMC_UNLOCK(sc);
d328 1
a328 1
	SDMMC_UNLOCK(sc);
d340 1
a340 1
	SDMMC_ASSERT_LOCKED(sc);
d375 1
a375 1
	SDMMC_ASSERT_LOCKED(sc);
d426 1
a426 1
	SDMMC_ASSERT_LOCKED(sc);
d445 1
a445 1
	SDMMC_ASSERT_LOCKED(sc);
d493 1
a493 1
	SDMMC_ASSERT_LOCKED(sc);
d520 1
a520 1
	SDMMC_ASSERT_LOCKED(sc);
d559 1
a559 1
	SDMMC_ASSERT_LOCKED(sc);
d590 1
a590 1
	SDMMC_ASSERT_LOCKED(sc);
d612 1
a612 1
	SDMMC_ASSERT_LOCKED(sc);
d631 1
a631 1
	SDMMC_ASSERT_LOCKED(sc);
d658 1
a658 1
	SDMMC_ASSERT_LOCKED(sc);
d689 1
a689 1
	SDMMC_LOCK(sc);
d692 1
a692 1
		SDMMC_UNLOCK(sc);
d697 1
a697 1
		SDMMC_UNLOCK(sc);
d706 1
a706 1
	SDMMC_UNLOCK(sc);
d716 1
a716 1
	SDMMC_ASSERT_LOCKED(sc);
d784 1
a784 1
		SDMMC_LOCK(sc);
d789 1
a789 1
		SDMMC_UNLOCK(sc);
d818 1
a818 1
	SDMMC_ASSERT_LOCKED(sc);
@


1.22
log
@One transition was wrong:  Suspending without a card, and then resuming with
was doing an attach, detach, and re-attach.  Repair the state transitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.21 2010/07/02 09:21:58 deraadt Exp $	*/
a67 2

#define DEVNAME(sc)	SDMMCDEVNAME(sc)
@


1.21
log
@On resume, detach and then force a re-attach of the card, since we don't
know if it is the same card or if it got modified while we were not paying
attention.  Tested on x40 under apm, and some acpi machines.
ok mlarkin kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.20 2009/04/07 16:35:52 blambert Exp $	*/
d153 5
a158 1
		sc->sc_dying = -1;	/* "bump" the task for a retry */
@


1.20
log
@Remove recursion from the sdmmc locking regime.

In snaps for a while.

Originally hacked on phessler@@'s couch.
Testing by many, input from jsg@@

"I'm tired of seeing the Ms" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.19 2009/02/20 19:16:35 miod Exp $	*/
d53 2
d81 2
a82 1
	sizeof(struct sdmmc_softc), sdmmc_match, sdmmc_attach, sdmmc_detach
d146 15
d182 1
d204 9
@


1.19
log
@Let the sdmmc adapters tell the sdmmc layer how much sectors they can
transfer with one command. Build on this and the recent minphys() changes
in the sdmmc layer to crank transfers at the maximum possible size instead
of a sad DEV_BSIZE.

Depending on your controller, this can speed up sdmmc I/O up to 2.5 times.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.18 2009/01/09 10:58:38 jsg Exp $	*/
d113 1
a113 1
	lockinit(&sc->sc_lock, PRIBIO, DEVNAME(sc), 0, LK_CANRECURSE);
d179 2
a180 1
	if (ISSET(sc->sc_flags, SMF_CARD_PRESENT))
d182 2
d241 1
d243 1
d309 2
d344 2
d386 1
d395 2
d414 2
d461 3
d489 2
d528 1
a528 1
	SDMMC_LOCK(sc);
a536 1
		SDMMC_UNLOCK(sc);
a541 1
		SDMMC_UNLOCK(sc);
a545 1
	SDMMC_UNLOCK(sc);
d559 1
a559 1
	SDMMC_LOCK(sc);
a569 1
	SDMMC_UNLOCK(sc);
d581 2
d600 2
d627 2
d685 2
d753 1
d758 1
d786 2
@


1.18
log
@Explain that any check pattern will work.
Suggested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.17 2009/01/09 10:55:22 jsg Exp $	*/
d105 2
@


1.17
log
@Add support for SDHC cards on SDHC capable host controllers.
Thanks to everyone who tested in particular jsing@@ who found several
problems in the initial diffs.

ok dlg@@ jsing@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.16 2008/12/02 23:49:54 deraadt Exp $	*/
d578 1
a578 1
	uint8_t pat = 0x23;
@


1.16
log
@backout: would have been nice if this had been tested, to see that it
crashes the moment a card is plugged in.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.14 2007/09/11 13:39:34 gilles Exp $	*/
d569 26
@


1.15
log
@Rework sdmmc locking to remove recursion
Add SDMMC_ASSERT_LOCKED(), replacing many locking calls, and sprinkling
the assertion to make sure that future changes don't catch us out

"please commit" uwe@@
@
text
@d111 1
a111 1
	lockinit(&sc->sc_lock, PRIBIO, DEVNAME(sc), 0, 0);
d177 1
a177 2
	if (ISSET(sc->sc_flags, SMF_CARD_PRESENT)) {
		SDMMC_LOCK(sc);
a178 2
		SDMMC_UNLOCK(sc);
	}
a235 1
			SDMMC_LOCK(sc);
a236 1
			SDMMC_UNLOCK(sc);
a301 2
	SDMMC_ASSERT_LOCKED(sc);

a334 2
	SDMMC_ASSERT_LOCKED(sc);

a374 1

a444 3

	SDMMC_ASSERT_LOCKED(sc);

d507 1
a507 1
	SDMMC_ASSERT_LOCKED(sc);
d516 1
d522 1
d527 1
d541 1
a541 1
	SDMMC_ASSERT_LOCKED(sc);
d552 1
a563 2
	SDMMC_ASSERT_LOCKED(sc);

a579 2
	SDMMC_ASSERT_LOCKED(sc);

a701 1
		SDMMC_LOCK(sc);
a707 1
		SDMMC_UNLOCK(sc);
@


1.14
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.13 2007/09/10 19:49:31 gilles Exp $	*/
d111 1
a111 1
	lockinit(&sc->sc_lock, PRIBIO, DEVNAME(sc), 0, LK_CANRECURSE);
d177 2
a178 1
	if (ISSET(sc->sc_flags, SMF_CARD_PRESENT))
d180 2
d239 1
d241 1
d307 2
d342 2
d384 1
d455 3
d520 1
a520 1
	SDMMC_LOCK(sc);
a528 1
		SDMMC_UNLOCK(sc);
a533 1
		SDMMC_UNLOCK(sc);
a537 1
	SDMMC_UNLOCK(sc);
d551 1
a551 1
	SDMMC_LOCK(sc);
a561 1
	SDMMC_UNLOCK(sc);
d573 2
d591 2
d715 1
d722 1
@


1.13
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.12 2007/05/31 10:09:01 uwe Exp $	*/
d423 1
a423 1
	    M_WAITOK|M_ZERO);
@


1.12
log
@Add SDIO card interrupt handling code
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.11 2007/05/26 17:06:36 uwe Exp $	*/
d422 2
a423 3
	MALLOC(sf, struct sdmmc_function *, sizeof *sf, M_DEVBUF,
	    M_WAITOK);
	bzero(sf, sizeof *sf);
d435 1
a435 1
	FREE(sf, M_DEVBUF);
@


1.11
log
@Use M_TEMP, not M_DEVBUF for temporary memory
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.10 2007/03/24 00:44:26 uwe Exp $	*/
d108 1
d110 1
@


1.10
log
@Dump command and response when debugging is enabled
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.9 2006/11/29 14:16:43 uwe Exp $	*/
d690 1
a690 1
			data = malloc(ucmd->c_datalen, M_DEVBUF,
d717 1
a717 1
			free(data, M_DEVBUF);
@


1.9
log
@move CSD/CID decoding to sdmmc_mem.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.8 2006/11/29 00:46:52 uwe Exp $	*/
d72 1
d544 3
a546 3
	DPRINTF(2,("%s: mmc cmd=%p opcode=%d proc=\"%s\" (error %d)\n",
	    DEVNAME(sc), cmd, cmd->c_opcode, curproc ? curproc->p_comm :
	    "", cmd->c_error));
d724 25
@


1.8
log
@add ioctl hack to support the sdio(8) userland tool
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.7 2006/07/18 04:10:35 uwe Exp $	*/
a647 90
}

int
sdmmc_decode_csd(struct sdmmc_softc *sc, sdmmc_response resp,
    struct sdmmc_function *sf)
{
	struct sdmmc_csd *csd = &sf->csd;

	if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
		/*
		 * CSD version 1.0 corresponds to SD system
		 * specification version 1.0 - 1.10. (SanDisk, 3.5.3)
		 */
		csd->csdver = SD_CSD_CSDVER(resp);
		if (csd->csdver != SD_CSD_CSDVER_1_0) {
			printf("%s: unknown SD CSD structure version 0x%x\n",
			    DEVNAME(sc), csd->csdver);
			return 1;
		}

		csd->capacity = SD_CSD_CAPACITY(resp);
		csd->read_bl_len = SD_CSD_READ_BL_LEN(resp);
	} else {
		csd->csdver = MMC_CSD_CSDVER(resp);
		if (csd->csdver != MMC_CSD_CSDVER_1_0 &&
		    csd->csdver != MMC_CSD_CSDVER_2_0) {
			printf("%s: unknown MMC CSD structure version 0x%x\n",
			    DEVNAME(sc), csd->csdver);
			return 1;
		}

		csd->mmcver = MMC_CSD_MMCVER(resp);
		csd->capacity = MMC_CSD_CAPACITY(resp);
		csd->read_bl_len = MMC_CSD_READ_BL_LEN(resp);
	}
	csd->sector_size = MIN(1 << csd->read_bl_len,
	    sdmmc_chip_host_maxblklen(sc->sct, sc->sch));
	if (csd->sector_size < (1<<csd->read_bl_len))
		csd->capacity *= (1<<csd->read_bl_len) /
		    csd->sector_size;

	return 0;
}

int
sdmmc_decode_cid(struct sdmmc_softc *sc, sdmmc_response resp,
    struct sdmmc_function *sf)
{
	struct sdmmc_cid *cid = &sf->cid;

	if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
		cid->mid = SD_CID_MID(resp);
		cid->oid = SD_CID_OID(resp);
		SD_CID_PNM_CPY(resp, cid->pnm);
		cid->rev = SD_CID_REV(resp);
		cid->psn = SD_CID_PSN(resp);
		cid->mdt = SD_CID_MDT(resp);
	} else {
		switch(sf->csd.mmcver) {
		case MMC_CSD_MMCVER_1_0:
		case MMC_CSD_MMCVER_1_4:
			cid->mid = MMC_CID_MID_V1(resp);
			MMC_CID_PNM_V1_CPY(resp, cid->pnm);
			cid->rev = MMC_CID_REV_V1(resp);
			cid->psn = MMC_CID_PSN_V1(resp);
			cid->mdt = MMC_CID_MDT_V1(resp);
			break;
		case MMC_CSD_MMCVER_2_0:
		case MMC_CSD_MMCVER_3_1:
		case MMC_CSD_MMCVER_4_0:
			cid->mid = MMC_CID_MID_V2(resp);
			cid->oid = MMC_CID_OID_V2(resp);
			MMC_CID_PNM_V2_CPY(resp, cid->pnm);
			cid->psn = MMC_CID_PSN_V2(resp);
			break;
		default:
			printf("%s: unknown MMC version %d\n",
			    DEVNAME(sc), sf->csd.mmcver);
			return 1;
		}
	}
	return 0;
}

void
sdmmc_print_cid(struct sdmmc_cid *cid)
{
	printf("mid=0x%02x oid=0x%04x pnm=\"%s\" rev=0x%02x psn=0x%08x"
	    " mdt=%03x\n", cid->mid, cid->oid, cid->pnm, cid->rev, cid->psn,
	    cid->mdt);
@


1.7
log
@First and foremost, avoid an obious race between two or more processes
trying to get MMC commands through to the SD/MMC host controller via the
emulated SCSI layer.  This is achieved by ensuring exclusive access to
the host controller for one process during any MMC command and during a
sequence of commands at the sdmmc(4) layer.

While at it, the command processing thread has been moved to sdmmc(4),
so as to simplify the implementation of future host controller drivers.
This should also pave the way for further cleanup of the code and for
new drivers.

Minor cleanups are included in this commit, as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.6 2006/06/29 01:35:37 uwe Exp $	*/
d42 8
d63 3
d70 3
a72 1
#define DPRINTF(s)	printf s
d74 1
a74 1
#define DPRINTF(s)	/**/
d110 5
d244 1
a244 1
	DPRINTF(("%s: attach card\n", DEVNAME(sc)));
d299 1
a299 1
	DPRINTF(("%s: detach card\n", DEVNAME(sc)));
d398 1
a398 1
	DPRINTF(("%s: host_ocr=%x ", DEVNAME(sc), host_ocr));
d406 1
a406 1
	DPRINTF(("card_ocr=%x new_ocr=%x\n", card_ocr, host_ocr));
d543 1
a543 1
	DPRINTF(("%s: mmc cmd=%p opcode=%d proc=\"%s\" (error %d)\n",
d739 76
@


1.6
log
@Oops! Clear the "function 0" pointer when the card goes away.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.5 2006/06/03 03:53:47 martin Exp $	*/
d28 1
d44 6
d54 3
a56 1
int	sdmmc_set_bus_width(struct sdmmc_softc *, struct sdmmc_function *);
d65 1
a65 1
	sizeof(struct sdmmc_softc), sdmmc_match, sdmmc_attach
d93 125
d221 1
a221 2
 * Called from the host driver when a card, or a stack of cards are
 * inserted.  Return zero if any card drivers have been attached.
d223 2
a224 2
int
sdmmc_card_attach(struct device *dev)
d226 1
a226 1
	struct sdmmc_softc *sc = (struct sdmmc_softc *)dev;
d228 2
a229 1
	DPRINTF(("%s: attach card\n", SDMMCDEVNAME(sc)));
d235 2
a236 2
		printf("%s: can't enable card\n", SDMMCDEVNAME(sc));
		return 1;
d244 2
a245 3
		printf("%s: no functions\n", SDMMCDEVNAME(sc));
		sdmmc_card_detach(dev, DETACH_FORCE);
		return 1;
d252 2
a253 3
		printf("%s: init failed\n", SDMMCDEVNAME(sc));
		sdmmc_card_detach(dev, DETACH_FORCE);
		return 1;
d264 6
a269 1
	return 0;
d273 1
a273 1
 * Called from host driver with DETACH_* flags from <sys/device.h>
d277 1
a277 1
sdmmc_card_detach(struct device *dev, int flags)
a278 1
	struct sdmmc_softc *sc = (struct sdmmc_softc *)dev;
d281 13
a293 1
	DPRINTF(("%s: detach card\n", SDMMCDEVNAME(sc)));
a297 8
	/* Detach I/O function drivers. */
	if (ISSET(sc->sc_flags, SMF_IO_MODE))
		sdmmc_io_detach(sc);

	/* Detach the SCSI emulation for memory cards. */
	if (ISSET(sc->sc_flags, SMF_MEM_MODE))
		sdmmc_scsi_detach(sc);

d321 1
a321 1
		printf("%s: can't supply bus power\n", SDMMCDEVNAME(sc));
d330 1
a330 1
		printf("%s: can't supply clock\n", SDMMCDEVNAME(sc));
d370 26
d435 1
a435 1
		printf("%s: can't identify card\n", SDMMCDEVNAME(sc));
d454 1
a454 1
			printf("%s: i/o init failed\n", SDMMCDEVNAME(sc));
d458 1
a458 1
			printf("%s: mem init failed\n", SDMMCDEVNAME(sc));
d476 1
a476 1
		(void)tsleep(&sdmmc_delay, PWAIT, "sdwait", ticks);
a480 26
/*
 * Set the lowest bus voltage supported by the card and the host.
 */
int
sdmmc_set_bus_power(struct sdmmc_softc *sc, u_int32_t host_ocr,
    u_int32_t card_ocr)
{
	u_int32_t bit;

	/* Mask off unsupported voltage levels and select the lowest. */
	DPRINTF(("%s: host_ocr=%x ", SDMMCDEVNAME(sc), host_ocr));
	host_ocr &= card_ocr;
	for (bit = 4; bit < 23; bit++) {
		if (ISSET(host_ocr, 1<<bit)) {
			host_ocr &= 3<<bit;
			break;
		}
	}
	DPRINTF(("card_ocr=%x new_ocr=%x\n", card_ocr, host_ocr));

	if (host_ocr == 0 ||
	    sdmmc_chip_bus_power(sc->sct, sc->sch, host_ocr) != 0)
		return 1;
	return 0;
}

d487 2
d495 2
a496 1
	if (error != 0)
d498 1
d500 1
a500 1
	if (!ISSET(MMC_R1(acmd.c_resp), MMC_R1_APP_CMD))
d502 1
d504 1
d506 3
a508 1
	return sdmmc_mmc_command(sc, cmd);
d511 5
d519 15
a533 1
	return sdmmc_chip_exec_command(sc->sct, sc->sch, cmd);
d583 1
a583 1
sdmmc_set_bus_width(struct sdmmc_softc *sc, struct sdmmc_function *sf)
d585 1
d589 4
a592 1
	if (!ISSET(sc->sc_flags, SMF_SD_MODE))
d594 1
d596 2
a597 1
	if ((error = sdmmc_select_card(sc, sf)) != 0)
d599 1
d605 3
a607 2

	return sdmmc_app_command(sc, &cmd);
d616 1
a616 2
	if (sc->sc_card == sf ||
	    (sc->sc_card != NULL && sf != NULL &&
d646 1
a646 1
			    SDMMCDEVNAME(sc), csd->csdver);
d657 1
a657 1
			    SDMMCDEVNAME(sc), csd->csdver);
d707 1
a707 1
			    SDMMCDEVNAME(sc), sf->csd.mmcver);
@


1.5
log
@prettier function declaration
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.4 2006/06/01 22:33:37 uwe Exp $	*/
d165 1
@


1.4
log
@Multiply the capacity for cards with block size >512 bytes (e.g. 2G cards).
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.3 2006/06/01 21:53:41 uwe Exp $	*/
d47 1
a47 2
int	sdmmc_set_bus_width(struct sdmmc_softc *,
	    struct sdmmc_function *);
@


1.3
log
@SDIO card identification
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.2 2006/05/28 18:45:23 uwe Exp $	*/
a489 1
		csd->sector_size = 1 << csd->read_bl_len;
d493 4
@


1.2
log
@don't #undef SDMMC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d35 1
a37 3
#ifdef notyet
#include <dev/sdmmc/sdmmcdevs.h>
#endif
a42 3

int	sdmmc_set_relative_addr(struct sdmmc_softc *, struct sdmmc_card *);
int	sdmmc_set_bus_width(struct sdmmc_softc *, struct sdmmc_card *);
d45 4
a48 6
int	sdmmc_decode_csd(struct sdmmc_softc *, sdmmc_response,
	    struct sdmmc_card *);
int	sdmmc_decode_cid(struct sdmmc_softc *, sdmmc_response,
	    struct sdmmc_card *);
void	sdmmc_print_cid(struct sdmmc_cid *);
void	sdmmc_identify_all(struct sdmmc_softc *);
d84 1
a84 1
	SIMPLEQ_INIT(&sc->cs_head);
a94 1
	struct sdmmc_card *cs;
d98 3
a100 1
	/* Power up the card (or card stack). */
d106 7
a112 7
	/* Scan for cards and allocate a card structure for each. */
	sdmmc_identify_all(sc);

	/* There should be at least one card now; otherwise, bail out. */
	if (SIMPLEQ_EMPTY(&sc->cs_head)) {
		printf("%s: can't identify card\n", SDMMCDEVNAME(sc));
		sdmmc_disable(sc);
d116 7
a122 8
	/* Initialize all identified cards. */
	SIMPLEQ_FOREACH(cs, &sc->cs_head, cs_list) {
		/* Boost the bus width. */
		(void)sdmmc_set_bus_width(sc, cs); /* XXX */

		if (ISSET(sc->sc_flags, SMF_MEM_MODE) &&
		    sdmmc_mem_init(sc, cs) != 0)
			printf("%s: init failed\n", SDMMCDEVNAME(sc));
a124 2
	/* XXX attach SDIO driver(s) */

d128 5
d144 1
a144 1
	struct sdmmc_card *cs, *csnext;
d151 5
a155 1
	/* Detach SCSI emulation. */
d159 4
a162 6
	/* XXX detach SDIO driver(s) */

	/* Free all card structures. */
	for (cs = SIMPLEQ_FIRST(&sc->cs_head); cs != NULL; cs = csnext) {
		csnext = SIMPLEQ_NEXT(cs, cs_list);
		FREE(cs, M_DEVBUF);
d164 2
a165 1
	SIMPLEQ_INIT(&sc->cs_head);
d194 3
d202 2
a203 1
	if ((error = sdmmc_mem_enable(sc)) != 0)
d206 1
a206 1
	/* XXX */
d222 1
a222 1
	/* Deselect all cards. */
d230 74
a340 93
/*
 * Read the CSD and CID from all cards and assign each card a unique
 * relative card address (RCA).
 */
void
sdmmc_identify_all(struct sdmmc_softc *sc)
{
	struct sdmmc_command cmd;
	struct sdmmc_card *cs;
	u_int16_t next_rca;
	int error;
	int i;

	/*
	 * CMD2 is a broadcast command understood by SD cards and MMC
	 * cards.  All cards begin to respond to the command, but back
	 * off if another card drives the CMD line to a different level.
	 * Only one card will get its entire response through.  That
	 * card remains silent once it has been assigned a RCA.
	 */
	for (i = 0; i < 100; i++) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_ALL_SEND_CID;
		cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R2;

		error = sdmmc_mmc_command(sc, &cmd);
		if (error == ETIMEDOUT) {
			/* No more cards there. */
			break;
		} else if (error != 0) {
			DPRINTF(("%s: can't read CID\n", SDMMCDEVNAME(sc)));
			break;
		}

		/* In MMC mode, find the next available RCA. */
		next_rca = 0;
		if (!ISSET(sc->sc_flags, SMF_SD_MODE))
			SIMPLEQ_FOREACH(cs, &sc->cs_head, cs_list)
				next_rca++;

		/* Allocate a card structure. */
		MALLOC(cs, struct sdmmc_card *, sizeof *cs, M_DEVBUF,
		    M_WAITOK);
		bzero(cs, sizeof *cs);
		cs->rca = next_rca;

		/*
		 * Remember the CID returned in the CMD2 response for
		 * later decoding.
		 */
		bcopy(cmd.c_resp, cs->raw_cid, sizeof cs->raw_cid);

		/*
		 * Silence the card by assigning it a unique RCA, or
		 * querying it for its RCA in case of SD.
		 */
		if (sdmmc_set_relative_addr(sc, cs) != 0) {
			printf("%s: can't set RCA\n", SDMMCDEVNAME(sc));
			FREE(cs, M_DEVBUF);
			break;
		}

		SIMPLEQ_INSERT_TAIL(&sc->cs_head, cs, cs_list);
	}

	/*
	 * All cards are either inactive or awaiting further commands.
	 * Read the CSDs and decode the raw CID for each card.
	 */
	SIMPLEQ_FOREACH(cs, &sc->cs_head, cs_list) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_SEND_CSD;
		cmd.c_arg = MMC_ARG_RCA(cs->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R2;

		if (sdmmc_mmc_command(sc, &cmd) != 0) {
			SET(cs->flags, SDMMCF_CARD_ERROR);
			continue;
		}

		if (sdmmc_decode_csd(sc, cmd.c_resp, cs) != 0 ||
		    sdmmc_decode_cid(sc, cs->raw_cid, cs) != 0) {
			SET(cs->flags, SDMMCF_CARD_ERROR);
			continue;
		}

#ifdef SDMMC_DEBUG
		printf("%s: CID: ", SDMMCDEVNAME(sc));
		sdmmc_print_cid(&cs->cid);
#endif
	}
}

d388 2
a389 1
sdmmc_set_relative_addr(struct sdmmc_softc *sc, struct sdmmc_card *cs)
d400 1
a400 1
		cmd.c_arg = MMC_ARG_RCA(cs->rca);
d408 1
a408 1
		cs->rca = SD_R6_RCA(cmd.c_resp);
d413 1
a413 1
 * Set the maximum supported bus width.
d416 1
a416 1
sdmmc_set_bus_width(struct sdmmc_softc *sc, struct sdmmc_card *cs)
d424 1
a424 1
	if ((error = sdmmc_select_card(sc, cs)) != 0)
d436 1
a436 1
sdmmc_select_card(struct sdmmc_softc *sc, struct sdmmc_card *cs)
d441 4
a444 1
	if (sc->sc_card == cs)
d446 1
d450 2
a451 2
	cmd.c_arg = cs == NULL ? 0 : MMC_ARG_RCA(cs->rca);
	cmd.c_flags = SCF_CMD_AC | (cs == NULL ? SCF_RSP_R0 : SCF_RSP_R1);
d453 2
a454 2
	if (error == 0 || cs == NULL)
		sc->sc_card = cs;
d460 1
a460 1
    struct sdmmc_card *cs)
d462 1
a462 1
	struct sdmmc_csd *csd = &cs->csd;
d499 1
a499 1
    struct sdmmc_card *cs)
d501 1
a501 1
	struct sdmmc_cid *cid = &cs->cid;
d511 1
a511 1
		switch(cs->csd.mmcver) {
d530 1
a530 1
			    SDMMCDEVNAME(sc), cs->csd.mmcver);
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a41 2

#undef SDMMC_DEBUG
@

