head	1.7;
access;
symbols
	OPENBSD_6_1:1.7.0.6
	OPENBSD_6_1_BASE:1.7
	OPENBSD_6_0:1.7.0.2
	OPENBSD_6_0_BASE:1.7
	OPENBSD_5_9:1.6.0.2
	OPENBSD_5_9_BASE:1.6
	OPENBSD_5_8:1.5.0.22
	OPENBSD_5_8_BASE:1.5
	OPENBSD_5_7:1.5.0.20
	OPENBSD_5_7_BASE:1.5
	OPENBSD_5_6:1.5.0.18
	OPENBSD_5_6_BASE:1.5
	OPENBSD_5_5:1.5.0.16
	OPENBSD_5_5_BASE:1.5
	OPENBSD_5_4:1.5.0.12
	OPENBSD_5_4_BASE:1.5
	OPENBSD_5_3:1.5.0.10
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.8
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.6
	OPENBSD_5_0:1.5.0.4
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.5.0.2
	OPENBSD_4_9_BASE:1.5
	OPENBSD_4_8:1.3.0.4
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.3.0.2
	OPENBSD_4_7_BASE:1.3
	OPENBSD_4_6:1.1.0.16
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.12
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.10
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.8
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.6
	OPENBSD_4_2_BASE:1.1
	OPENBSD_4_1:1.1.0.4
	OPENBSD_4_1_BASE:1.1
	OPENBSD_4_0:1.1.0.2
	OPENBSD_4_0_BASE:1.1;
locks; strict;
comment	@ * @;


1.7
date	2016.04.23.14.15.59;	author kettenis;	state Exp;
branches;
next	1.6;
commitid	jADeWYdQPb0qx2Ml;

1.6
date	2016.01.11.07.32.38;	author kettenis;	state Exp;
branches;
next	1.5;
commitid	X0riORaTUqhWyFdv;

1.5
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.4;

1.4
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2009.11.11.21.59.16;	author jasper;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.03.18.42.36;	author kettenis;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.01.21.53.41;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Implement reading of the CIS for functions 1-7.  Don't write a bogus bus width
value when initializing function 0, and correct a few related #defines.

ok deraadt@@
@
text
@/*	$OpenBSD: sdmmc_cis.c,v 1.6 2016/01/11 07:32:38 kettenis Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Routines to decode the Card Information Structure of SD I/O cards */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/systm.h>

#include <dev/sdmmc/sdmmc_ioreg.h>
#include <dev/sdmmc/sdmmcdevs.h>
#include <dev/sdmmc/sdmmcvar.h>

u_int32_t sdmmc_cisptr(struct sdmmc_function *);

#ifdef SDMMC_DEBUG
#define DPRINTF(s)	printf s
#else
#define DPRINTF(s)	/**/
#endif

u_int32_t
sdmmc_cisptr(struct sdmmc_function *sf)
{
	struct sdmmc_function *sf0 = sf->sc->sc_fn0;
	u_int32_t cisptr = 0;
	int reg;

	rw_assert_wrlock(&sf->sc->sc_lock);

	reg = SD_IO_CCCR_CISPTR + (sf->number * SD_IO_CCCR_SIZE);
	cisptr |= sdmmc_io_read_1(sf0, reg + 0) << 0;
	cisptr |= sdmmc_io_read_1(sf0, reg + 1) << 8;
	cisptr |= sdmmc_io_read_1(sf0, reg + 2) << 16;

	return cisptr;
}

int
sdmmc_read_cis(struct sdmmc_function *sf, struct sdmmc_cis *cis)
{
	struct sdmmc_function *sf0 = sf->sc->sc_fn0;
	int reg;
	u_int8_t tplcode;
	u_int8_t tpllen;

	rw_assert_wrlock(&sf->sc->sc_lock);

	reg = (int)sdmmc_cisptr(sf);
	if (reg < SD_IO_CIS_START ||
	    reg >= (SD_IO_CIS_START+SD_IO_CIS_SIZE-16)) {
		printf("%s: bad CIS ptr %#x\n", DEVNAME(sf->sc), reg);
		return 1;
	}

	for (;;) {
		tplcode = sdmmc_io_read_1(sf0, reg++);
		if (tplcode == SD_IO_CISTPL_END)
			break;
		if (tplcode == SD_IO_CISTPL_NULL)
			continue;

		tpllen = sdmmc_io_read_1(sf0, reg++);
		if (tpllen == 0) {
			printf("%s: CIS parse error at %d, "
			    "tuple code %#x, length %d\n",
			    DEVNAME(sf->sc), reg, tplcode, tpllen);
			break;
		}

		switch (tplcode) {
		case SD_IO_CISTPL_FUNCID:
			if (tpllen < 2) {
				printf("%s: bad CISTPL_FUNCID length\n",
				    DEVNAME(sf->sc));
				reg += tpllen;
				break;
			}
			cis->function = sdmmc_io_read_1(sf0, reg);
			reg += tpllen;
			break;
		case SD_IO_CISTPL_MANFID:
			if (tpllen < 4) {
				printf("%s: bad CISTPL_MANFID length\n",
				    DEVNAME(sf->sc));
				reg += tpllen;
				break;
			}
			cis->manufacturer = sdmmc_io_read_1(sf0, reg++);
			cis->manufacturer |= sdmmc_io_read_1(sf0, reg++) << 8;
			cis->product = sdmmc_io_read_1(sf0, reg++);
			cis->product |= sdmmc_io_read_1(sf0, reg++) << 8;
			break;
		case SD_IO_CISTPL_VERS_1:
			if (tpllen < 2) {
				printf("%s: CISTPL_VERS_1 too short\n",
				    DEVNAME(sf->sc));
				reg += tpllen;
				break;
			}
			{
				int start, i, ch, count;

				cis->cis1_major = sdmmc_io_read_1(sf0, reg++);
				cis->cis1_minor = sdmmc_io_read_1(sf0, reg++);

				for (count = 0, start = 0, i = 0;
				     (count < 4) && ((i + 4) < 256); i++) {
					ch = sdmmc_io_read_1(sf0, reg + i);
					if (ch == 0xff)
						break;
					cis->cis1_info_buf[i] = ch;
					if (ch == 0) {
						cis->cis1_info[count] =
						    cis->cis1_info_buf + start;
						start = i + 1;
						count++;
					}
				}

				reg += tpllen - 2;
			}
			break;
		default:
			DPRINTF(("%s: unknown tuple code %#x, length %d\n",
			    DEVNAME(sf->sc), tplcode, tpllen));
			reg += tpllen;
			break;
		}
	}

	return 0;
}

void
sdmmc_print_cis(struct sdmmc_function *sf)
{
	struct sdmmc_cis *cis = &sf->cis;
	int i;

	printf("%s: CIS version %d.%d\n", DEVNAME(sf->sc),
	    cis->cis1_major, cis->cis1_minor);

	printf("%s: CIS info: ", DEVNAME(sf->sc));
	for (i = 0; i < 4; i++) {
		if (cis->cis1_info[i] == NULL)
			break;
		if (i)
			printf(", ");
		printf("%s", cis->cis1_info[i]);
	}
	printf("\n");

	printf("%s: Manufacturer code 0x%x, product 0x%x\n",
	    DEVNAME(sf->sc), cis->manufacturer, cis->product);

	printf("%s: function %d: ", DEVNAME(sf->sc), sf->number);
	switch (sf->cis.function) {
	case TPLFID_FUNCTION_SDIO:
		printf("SDIO");
		break;
	default:
		printf("unknown (%d)", sf->cis.function);
		break;
	}
	printf("\n");
}

void
sdmmc_check_cis_quirks(struct sdmmc_function *sf)
{
	if (sf->cis.manufacturer == SDMMC_VENDOR_SPECTEC &&
	    sf->cis.product == SDMMC_PRODUCT_SPECTEC_SDW820) {
		/* This card lacks the VERS_1 tuple. */
		sf->cis.cis1_major = 0x01;
		sf->cis.cis1_minor = 0x00;
		sf->cis.cis1_info[0] = "Spectec";
		sf->cis.cis1_info[1] = "SDIO WLAN Card";
		sf->cis.cis1_info[2] = "SDW-820";
		sf->cis.cis1_info[3] = "";
	}
}
@


1.6
log
@Improve CIS parsing to recognize CISTPL_NULL codes instead of bailing out on
them.  Add symbolic constant for CISTPL_END.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_cis.c,v 1.5 2010/08/24 14:52:23 blambert Exp $	*/
d40 1
d42 1
d46 4
a49 8
	/* XXX where is the per-function CIS pointer register? */
	if (sf->number != 0)
		return SD_IO_CIS_START;

	/* XXX is the CIS pointer stored in little-endian format? */
	cisptr |= sdmmc_io_read_1(sf, SD_IO_CCCR_CISPTR+0) << 0;
	cisptr |= sdmmc_io_read_1(sf, SD_IO_CCCR_CISPTR+1) << 8;
	cisptr |= sdmmc_io_read_1(sf, SD_IO_CCCR_CISPTR+2) << 16;
d57 1
a63 6
	bzero(cis, sizeof *cis);

	/* XXX read per-function CIS */
	if (sf->number != 0)
		return 1;

d72 1
a72 1
		tplcode = sdmmc_io_read_1(sf, reg++);
d78 1
a78 1
		tpllen = sdmmc_io_read_1(sf, reg++);
d94 1
a94 1
			cis->function = sdmmc_io_read_1(sf, reg);
d104 4
a107 4
			cis->manufacturer = sdmmc_io_read_1(sf, reg++);
			cis->manufacturer |= sdmmc_io_read_1(sf, reg++) << 8;
			cis->product = sdmmc_io_read_1(sf, reg++);
			cis->product |= sdmmc_io_read_1(sf, reg++) << 8;
d119 2
a120 2
				cis->cis1_major = sdmmc_io_read_1(sf, reg++);
				cis->cis1_minor = sdmmc_io_read_1(sf, reg++);
d124 1
a124 1
					ch = sdmmc_io_read_1(sf, reg + i);
d174 2
a175 2
	case SDMMC_FUNCTION_WLAN:
		printf("wireless network adapter");
@


1.5
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_cis.c,v 1.4 2010/08/19 17:54:12 jasper Exp $	*/
d80 5
d86 4
a89 6

		if (tplcode == 0xff || tpllen == 0) {
			if (tplcode != 0xff)
				printf("%s: CIS parse error at %d, "
				    "tuple code %#x, length %d\n",
				    DEVNAME(sf->sc), reg, tplcode, tpllen);
@


1.4
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_cis.c,v 1.3 2009/11/11 21:59:16 jasper Exp $	*/
d42 1
a42 1
	SDMMC_ASSERT_LOCKED(sf->sc);
d63 1
a63 1
	SDMMC_ASSERT_LOCKED(sf->sc);
@


1.3
log
@fixup of locking issues with sdmmc, which were causing
"locking against myself" panics as found the hard way by
several. diff by blamert@@ with input from oga@@,
committing bret's behalf.

ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_cis.c,v 1.2 2009/10/03 18:42:36 kettenis Exp $	*/
d74 1
a74 1
		printf("%s: bad CIS ptr %#x\n", SDMMCDEVNAME(sf->sc), reg);
d86 1
a86 1
				    SDMMCDEVNAME(sf->sc), reg, tplcode, tpllen);
d94 1
a94 1
				    SDMMCDEVNAME(sf->sc));
d104 1
a104 1
				    SDMMCDEVNAME(sf->sc));
d116 1
a116 1
				    SDMMCDEVNAME(sf->sc));
d145 1
a145 1
			    SDMMCDEVNAME(sf->sc), tplcode, tpllen));
d160 1
a160 1
	printf("%s: CIS version %d.%d\n", SDMMCDEVNAME(sf->sc),
d163 1
a163 1
	printf("%s: CIS info: ", SDMMCDEVNAME(sf->sc));
d174 1
a174 1
	    SDMMCDEVNAME(sf->sc), cis->manufacturer, cis->product);
d176 1
a176 1
	printf("%s: function %d: ", SDMMCDEVNAME(sf->sc), sf->number);
@


1.2
log
@Add missing <sys/device.h>.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_cis.c,v 1.1 2006/06/01 21:53:41 uwe Exp $	*/
d42 2
d52 1
d63 2
d150 1
@


1.1
log
@SDIO card identification
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d22 1
@

