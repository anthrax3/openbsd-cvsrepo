head	1.18;
access;
symbols
	OPENBSD_5_5:1.17.0.16
	OPENBSD_5_5_BASE:1.17
	OPENBSD_5_4:1.17.0.12
	OPENBSD_5_4_BASE:1.17
	OPENBSD_5_3:1.17.0.10
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.8
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.6
	OPENBSD_5_0:1.17.0.4
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.2
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.6
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.2
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.11.0.4
	OPENBSD_4_4_BASE:1.11
	OPENBSD_4_3:1.11.0.2
	OPENBSD_4_3_BASE:1.11
	OPENBSD_4_2:1.9.0.2
	OPENBSD_4_2_BASE:1.9;
locks; strict;
comment	@ * @;


1.18
date	2014.07.11.21.54.38;	author tedu;	state dead;
branches;
next	1.17;
commitid	0n9cIGBISFAEt4b1;

1.17
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.15;

1.15
date	2010.07.02.02.40.16;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.11.10.12.19;	author claudio;	state Exp;
branches;
next	1.13;

1.13
date	2009.11.11.21.59.16;	author jasper;	state Exp;
branches;
next	1.12;

1.12
date	2008.11.01.09.24.35;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.25.12.20.25;	author uwe;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.24.21.34.48;	author uwe;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.19.07.59.57;	author uwe;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.19.07.58.05;	author uwe;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.06.23.18.06;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.06.22.48.00;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.03.21.57.38;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.02.01.30.37;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2007.05.31.23.37.21;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2007.05.31.23.28.30;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2007.05.31.18.45.09;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.18
log
@"It's not the years, honey; it's the mileage."

bluetooth support doesn't work and isn't going anywhere. the current
design is a dead end, and should not be the basis for any future support.
general consensus says to whack it so as to not mislead the unwary.
@
text
@/*	$OpenBSD: sbt.c,v 1.17 2010/08/24 14:52:23 blambert Exp $	*/

/*
 * Copyright (c) 2007 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for Type-A/B SDIO Bluetooth cards */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/socket.h>
#include <sys/systm.h>

#include <netbt/hci.h>

#include <dev/sdmmc/sdmmcdevs.h>
#include <dev/sdmmc/sdmmcvar.h>

#define CSR_READ_1(sc, reg)       sdmmc_io_read_1((sc)->sc_sf, (reg))
#define CSR_WRITE_1(sc, reg, val) sdmmc_io_write_1((sc)->sc_sf, (reg), (val))

#define SBT_REG_DAT	0x00		/* receiver/transmitter data */
#define SBT_REG_RPC	0x10		/* read packet control */
#define  RPC_PCRRT	(1<<0)		/* packet read retry */
#define SBT_REG_WPC	0x11		/* write packet control */
#define  WPC_PCWRT	(1<<0)		/* packet write retry */
#define SBT_REG_RC	0x12		/* retry control status/set */
#define SBT_REG_ISTAT	0x13		/* interrupt status */
#define  ISTAT_INTRD	(1<<0)		/* packet available for read */
#define SBT_REG_ICLR	0x13		/* interrupt clear */
#define SBT_REG_IENA	0x14		/* interrupt enable */
#define SBT_REG_BTMODE	0x20		/* SDIO Bluetooth card mode */
#define  BTMODE_TYPEB	(1<<0)		/* 1=Type-B, 0=Type-A */

#define SBT_PKT_BUFSIZ	65540
#define SBT_RXTRY_MAX	5

struct sbt_softc {
	struct device sc_dev;		/* base device */
	struct sdmmc_function *sc_sf;	/* SDIO function */
	struct workq *sc_workq;		/* transfer deferred packets */
	int sc_enabled;			/* HCI enabled */
	int sc_dying;			/* shutdown in progress */
	int sc_busy;			/* transmitting or receiving */
	void *sc_ih;
	u_char *sc_buf;
	int sc_rxtry;

	struct hci_unit *sc_unit;	/* MI host controller */
	struct bt_stats sc_stats;	/* MI bluetooth stats */
	struct ifqueue sc_cmdq;
	struct ifqueue sc_acltxq;
	struct ifqueue sc_scotxq;
};

int	sbt_match(struct device *, void *, void *);
void	sbt_attach(struct device *, struct device *, void *);
int	sbt_detach(struct device *, int);

int	sbt_write_packet(struct sbt_softc *, u_char *, size_t);
int	sbt_read_packet(struct sbt_softc *, u_char *, size_t *);

int	sbt_intr(void *);

int	sbt_enable(struct device *);
void	sbt_disable(struct device *);
void	sbt_start(struct sbt_softc *, struct mbuf *, struct ifqueue *, int);
void	sbt_xmit_cmd(struct device *, struct mbuf *);
void	sbt_xmit_acl(struct device *, struct mbuf *);
void	sbt_xmit_sco(struct device *, struct mbuf *);
void	sbt_start_task(void *, void *);

void	sbt_stats(struct device *, struct bt_stats *, int);

#undef DPRINTF
#define SBT_DEBUG
#ifdef SBT_DEBUG
int sbt_debug = 0;
#define DPRINTF(s)	printf s
#define DNPRINTF(n, s)	do { if ((n) <= sbt_debug) printf s; } while (0)
#else
#define DPRINTF(s)	do {} while (0)
#define DNPRINTF(n, s)	do {} while (0)
#endif

struct cfattach sbt_ca = {
	sizeof(struct sbt_softc), sbt_match, sbt_attach, sbt_detach
};

struct cfdriver sbt_cd = {
	NULL, "sbt", DV_DULL
};


/*
 * Autoconf glue
 */

static const struct sbt_product {
	u_int16_t	sp_vendor;
	u_int16_t	sp_product;
	const char	*sp_cisinfo[4];
} sbt_products[] = {
	{ SDMMC_VENDOR_SOCKETCOM,
	  SDMMC_PRODUCT_SOCKETCOM_BTCARD,
	  SDMMC_CIS_SOCKETCOM_BTCARD }
};

const struct hci_if sbt_hci = {
	.enable = sbt_enable,
	.disable = sbt_disable,
	.output_cmd = sbt_xmit_cmd,
	.output_acl = sbt_xmit_acl,
	.output_sco = sbt_xmit_sco,
	.get_stats = sbt_stats,
	.ipl = IPL_SDMMC
};

int
sbt_match(struct device *parent, void *match, void *aux)
{
	struct sdmmc_attach_args *sa = aux;
	const struct sbt_product *sp;
	struct sdmmc_function *sf;
	int i;

	if (sa->sf == NULL)
		return 0;	/* not SDIO */

	sf = sa->sf->sc->sc_fn0;
	sp = &sbt_products[0];

	for (i = 0; i < sizeof(sbt_products) / sizeof(sbt_products[0]);
	     i++, sp = &sbt_products[i])
		if (sp->sp_vendor == sf->cis.manufacturer &&
		    sp->sp_product == sf->cis.product)
			return 1;
	return 0;
}

void
sbt_attach(struct device *parent, struct device *self, void *aux)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;
	struct sdmmc_attach_args *sa = aux;

	SDMMC_ASSERT_LOCKED(sc->sc_sf->sc);

	printf("\n");

	sc->sc_sf = sa->sf;

	(void)sdmmc_io_function_disable(sc->sc_sf);
	if (sdmmc_io_function_enable(sc->sc_sf)) {
		printf("%s: function not ready\n", DEVNAME(sc));
		return;
	}

	/* It may be Type-B, but we use it only in Type-A mode. */
	printf("%s: SDIO Bluetooth Type-A\n", DEVNAME(sc));

	/* Create a shared buffer for receive and transmit. */
	sc->sc_buf = malloc(SBT_PKT_BUFSIZ, M_DEVBUF, M_NOWAIT);
	if (sc->sc_buf == NULL) {
		printf("%s: can't allocate cmd buffer\n", DEVNAME(sc));
		return;
	}

	/* Create a work thread to transmit deferred packets. */
	sc->sc_workq = workq_create(DEVNAME(sc), 1, IPL_SDMMC);
	if (sc->sc_workq == NULL) {
		printf("%s: can't allocate workq\n", DEVNAME(sc));
		return;
	}

	/* Enable the HCI packet transport read interrupt. */
	CSR_WRITE_1(sc, SBT_REG_IENA, ISTAT_INTRD);

	/* Enable the card interrupt for this function. */
	sc->sc_ih = sdmmc_intr_establish(parent, sbt_intr, sc, DEVNAME(sc));
	if (sc->sc_ih == NULL) {
		printf("%s: can't establish interrupt\n", DEVNAME(sc));
		return;
	}
	sdmmc_intr_enable(sc->sc_sf);

	/*
	 * Attach Bluetooth unit (machine-independent HCI).
	 */
	sc->sc_unit = hci_attach(&sbt_hci, &sc->sc_dev, 0);
}

int
sbt_detach(struct device *self, int flags)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;

	sc->sc_dying = 1;

	while (sc->sc_busy)
		tsleep(&sc->sc_busy, PWAIT, "sbtdie", 0);

	/* Detach HCI interface */
	if (sc->sc_unit) {
		hci_detach(sc->sc_unit);
		sc->sc_unit = NULL;
	}

	if (sc->sc_ih != NULL)
		sdmmc_intr_disestablish(sc->sc_ih);

	if (sc->sc_workq != NULL)
		workq_destroy(sc->sc_workq);

	if (sc->sc_buf != NULL)
		free(sc->sc_buf, M_DEVBUF);

	return 0;
}


/*
 * Bluetooth HCI packet transport
 */

int
sbt_write_packet(struct sbt_softc *sc, u_char *buf, size_t len)
{
	u_char hdr[3];
	size_t pktlen;
	int error = EIO;
	int retry = 3;

again:
	if (retry-- == 0) {
		DPRINTF(("%s: sbt_write_cmd: giving up\n", DEVNAME(sc)));
		return error;
	}

	/* Restart the current packet. */
	sdmmc_io_write_1(sc->sc_sf, SBT_REG_WPC, WPC_PCWRT);

	/* Write the packet length. */
	pktlen = len + 3;
	hdr[0] = pktlen & 0xff;
	hdr[1] = (pktlen >> 8) & 0xff;
	hdr[2] = (pktlen >> 16) & 0xff;
	error = sdmmc_io_write_multi_1(sc->sc_sf, SBT_REG_DAT, hdr, 3);
	if (error) {
		DPRINTF(("%s: sbt_write_packet: failed to send length\n",
		    DEVNAME(sc)));
		goto again;
	}

	error = sdmmc_io_write_multi_1(sc->sc_sf, SBT_REG_DAT, buf, len);
	if (error) {
		DPRINTF(("%s: sbt_write_packet: failed to send packet data\n",
		    DEVNAME(sc)));
		goto again;
	}
	return 0;
}

int
sbt_read_packet(struct sbt_softc *sc, u_char *buf, size_t *lenp)
{
	u_char hdr[3];
	size_t len;
	int error;

	error = sdmmc_io_read_multi_1(sc->sc_sf, SBT_REG_DAT, hdr, 3);
	if (error) {
		DPRINTF(("%s: sbt_read_packet: failed to read length\n",
		    DEVNAME(sc)));
		goto out;
	}
	len = (hdr[0] | (hdr[1] << 8) | (hdr[2] << 16)) - 3;
	if (len > *lenp) {
		DPRINTF(("%s: sbt_read_packet: len %u > %u\n",
		    DEVNAME(sc), len, *lenp));
		error = ENOBUFS;
		goto out;
	}

	DNPRINTF(2,("%s: sbt_read_packet: reading len %u bytes\n",
	    DEVNAME(sc), len));
	error = sdmmc_io_read_multi_1(sc->sc_sf, SBT_REG_DAT, buf, len);
	if (error) {
		DPRINTF(("%s: sbt_read_packet: failed to read packet data\n",
		    DEVNAME(sc)));
		goto out;
	}

out:
	rw_enter_write(&sc->sc_sf->sc->sc_lock);
	if (error) {
		if (sc->sc_rxtry >= SBT_RXTRY_MAX) {
			/* Drop and request the next packet. */
			sc->sc_rxtry = 0;
			CSR_WRITE_1(sc, SBT_REG_RPC, 0);
		} else {
			/* Request the current packet again. */
			sc->sc_rxtry++;
			CSR_WRITE_1(sc, SBT_REG_RPC, RPC_PCRRT);
		}
		rw_exit(&sc->sc_sf->sc->sc_lock);
		return error;
	}

	/* acknowledge read packet */
	CSR_WRITE_1(sc, SBT_REG_RPC, 0);

	rw_exit(&sc->sc_sf->sc->sc_lock);

	*lenp = len;
	return 0;
}

/*
 * Interrupt handling
 */

/* This function is called from the SDIO interrupt thread. */
int
sbt_intr(void *arg)
{
	struct sbt_softc *sc = arg;
	struct mbuf *m = NULL;
	u_int8_t status;
	size_t len;
	int s;

	/* Block further SDIO interrupts; XXX not really needed? */
	s = splsdmmc();

	rw_enter_write(&sc->sc_sf->sc->sc_lock);
	status = CSR_READ_1(sc, SBT_REG_ISTAT);
	CSR_WRITE_1(sc, SBT_REG_ICLR, status);
	rw_exit(&sc->sc_sf->sc->sc_lock);

	if ((status & ISTAT_INTRD) == 0)
		return 0;	/* shared SDIO card interrupt? */

	len = SBT_PKT_BUFSIZ;
	if (sbt_read_packet(sc, sc->sc_buf, &len) != 0 || len == 0) {
		DPRINTF(("%s: sbt_intr: read failed\n", DEVNAME(sc)));
		goto eoi;
	}

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL) {
		DPRINTF(("%s: sbt_intr: MGETHDR failed\n", DEVNAME(sc)));
		goto eoi;
	}

	m->m_pkthdr.len = m->m_len = MHLEN;
	m_copyback(m, 0, len, sc->sc_buf, M_NOWAIT);
	if (m->m_pkthdr.len == MAX(MHLEN, len)) {
		m->m_pkthdr.len = len;
		m->m_len = MIN(MHLEN, m->m_pkthdr.len);
	} else {
		DPRINTF(("%s: sbt_intr: m_copyback failed\n", DEVNAME(sc)));
		m_free(m);
		m = NULL;
	}

eoi:
	if (m != NULL) {
		switch (sc->sc_buf[0]) {
		case HCI_ACL_DATA_PKT:
			DNPRINTF(1,("%s: recv ACL packet (%d bytes)\n",
			    DEVNAME(sc), m->m_pkthdr.len));
			hci_input_acl(sc->sc_unit, m);
			break;
		case HCI_SCO_DATA_PKT:
			DNPRINTF(1,("%s: recv SCO packet (%d bytes)\n",
			    DEVNAME(sc), m->m_pkthdr.len));
			hci_input_sco(sc->sc_unit, m);
			break;
		case HCI_EVENT_PKT:
			DNPRINTF(1,("%s: recv EVENT packet (%d bytes)\n",
			    DEVNAME(sc), m->m_pkthdr.len));
			hci_input_event(sc->sc_unit, m);
			break;
		default:
			DPRINTF(("%s: recv 0x%x packet (%d bytes)\n",
			    DEVNAME(sc), sc->sc_buf[0], m->m_pkthdr.len));
			sc->sc_stats.err_rx++;
			m_free(m);
			break;
		}
	} else
		sc->sc_stats.err_rx++;

	splx(s);

	/* Claim this interrupt. */
	return 1;
}


/*
 * Bluetooth HCI unit functions
 */

int
sbt_enable(struct device *self)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;

	if (sc->sc_enabled)
		return 0;

	sc->sc_enabled = 1;
	return 0;
}

void
sbt_disable(struct device *self)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;
	int s;

	if (!sc->sc_enabled)
		return;

	s = splsdmmc();
#ifdef notyet			/* XXX */
	if (sc->sc_rxp) {
		m_freem(sc->sc_rxp);
		sc->sc_rxp = NULL;
	}

	if (sc->sc_txp) {
		m_freem(sc->sc_txp);
		sc->sc_txp = NULL;
	}
#endif
	sc->sc_enabled = 0;
	splx(s);
}

void
sbt_start(struct sbt_softc *sc, struct mbuf *m, struct ifqueue *q, int xmit)
{
	int s;
	int len;
#ifdef SBT_DEBUG
	const char *what;
#endif

	s = splsdmmc();
	if (m != NULL)
		IF_ENQUEUE(q, m);

	if (sc->sc_dying || IF_IS_EMPTY(q)) {
		splx(s);
		return;
	}

	if (curproc == NULL || sc->sc_busy) {
		(void)workq_add_task(sc->sc_workq, 0, sbt_start_task,
		    sc, (void *)(long)xmit);
		splx(s);
		return;
	}

	/* Defer additional transfers and reception of packets. */
	sdmmc_intr_disable(sc->sc_sf);
	sc->sc_busy++;

	IF_DEQUEUE(q, m);

#ifdef SBT_DEBUG
	switch (xmit) {
	case BTF_XMIT_CMD:
		what = "CMD";
		break;
	case BTF_XMIT_ACL:
		what = "ACL";
		break;
	case BTF_XMIT_SCO:
		what = "SCO";
		break;
	}
	DNPRINTF(1,("%s: xmit %s packet (%d bytes)\n", DEVNAME(sc),
	    what, m->m_pkthdr.len));
#endif

	sc->sc_unit->hci_flags |= xmit;

	len = m->m_pkthdr.len;
	m_copydata(m, 0, len, sc->sc_buf);
	m_freem(m);

	if (sbt_write_packet(sc, sc->sc_buf, len))
		DPRINTF(("%s: sbt_write_packet failed\n", DEVNAME(sc)));

	sc->sc_unit->hci_flags &= ~xmit;

	sc->sc_busy--;
	sdmmc_intr_enable(sc->sc_sf);

	if (sc->sc_dying)
		wakeup(&sc->sc_busy);

	splx(s);
}

void
sbt_xmit_cmd(struct device *self, struct mbuf *m)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;

	sbt_start(sc, m, &sc->sc_cmdq, BTF_XMIT_CMD);
}

void
sbt_xmit_acl(struct device *self, struct mbuf *m)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;

	sbt_start(sc, m, &sc->sc_acltxq, BTF_XMIT_ACL);
}

void
sbt_xmit_sco(struct device *self, struct mbuf *m)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;

	sbt_start(sc, m, &sc->sc_scotxq, BTF_XMIT_SCO);
}

void
sbt_start_task(void *arg1, void *arg2)
{
	struct sbt_softc *sc = arg1;
	int xmit = (long)arg2;

	switch (xmit) {
	case BTF_XMIT_CMD:
		sbt_xmit_cmd(&sc->sc_dev, NULL);
		break;
	case BTF_XMIT_ACL:
		sbt_xmit_acl(&sc->sc_dev, NULL);
		break;
	case BTF_XMIT_SCO:
		sbt_xmit_sco(&sc->sc_dev, NULL);
		break;
	}
}

void
sbt_stats(struct device *self, struct bt_stats *dest, int flush)
{
	struct sbt_softc *sc = (struct sbt_softc *)self;
	int s;

	s = splsdmmc();
	memcpy(dest, &sc->sc_stats, sizeof(struct bt_stats));

	if (flush)
		memset(&sc->sc_stats, 0, sizeof(struct bt_stats));

	splx(s);
}
@


1.17
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.16 2010/08/19 17:54:12 jasper Exp $	*/
@


1.16
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.15 2010/07/02 02:40:16 blambert Exp $	*/
d311 1
a311 1
	SDMMC_LOCK(sc->sc_sf->sc);
d322 1
a322 1
		SDMMC_UNLOCK(sc->sc_sf->sc);
d329 1
a329 1
	SDMMC_UNLOCK(sc->sc_sf->sc);
d352 1
a352 1
	SDMMC_LOCK(sc->sc_sf->sc);
d355 1
a355 1
	SDMMC_UNLOCK(sc->sc_sf->sc);
@


1.15
log
@m_copyback can fail to allocate memory, but is a void fucntion so gymnastics
are required to detect that.

Change the function to take a wait argument (used in nfs server, but
M_NOWAIT everywhere else for now) and to return an error

ok claudio@@ henning@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.14 2010/02/11 10:12:19 claudio Exp $	*/
a100 2

#define DEVNAME(sc)	((sc)->sc_dev.dv_xname)
@


1.14
log
@No need for M_CANFAIL if M_NOWAIT is used. Found by Gleydson Soares.
OK mk@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.13 2009/11/11 21:59:16 jasper Exp $	*/
d375 1
a375 1
	m_copyback(m, 0, len, sc->sc_buf);
@


1.13
log
@fixup of locking issues with sdmmc, which were causing
"locking against myself" panics as found the hard way by
several. diff by blamert@@ with input from oga@@,
committing bret's behalf.

ok todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.12 2008/11/01 09:24:35 tedu Exp $	*/
d181 1
a181 1
	sc->sc_buf = malloc(SBT_PKT_BUFSIZ, M_DEVBUF, M_NOWAIT | M_CANFAIL);
@


1.12
log
@new workq_create interface.  discovered by Vladimir Kirillov
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.11 2008/02/25 12:20:25 uwe Exp $	*/
d165 2
d313 1
d324 1
d331 2
d354 1
d357 1
@


1.11
log
@Fix broken cast on 64bit platforms
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.10 2008/02/24 21:34:48 uwe Exp $	*/
d186 1
a186 1
	sc->sc_workq = workq_create(DEVNAME(sc), 1);
@


1.10
log
@Sync sys/netbt with NetBSD
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.9 2007/06/19 07:59:57 uwe Exp $	*/
d473 1
a473 1
		    sc, (void *)xmit);
d548 1
a548 1
	int xmit = (int)arg2;
@


1.9
log
@Pass the correct flag to sbt_start() in sbt_start_cmd()
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.8 2007/06/19 07:58:05 uwe Exp $	*/
a55 1
	struct hci_unit sc_unit;	/* MI host controller */
d57 2
a58 1
	struct proc *sc_thread;		/* inquiry thread */
d60 1
d64 6
d81 9
a89 6
int	sbt_enable(struct hci_unit *);
void	sbt_disable(struct hci_unit *);
void	sbt_start(struct hci_unit *, struct ifqueue *, int);
void	sbt_start_cmd(struct hci_unit *);
void	sbt_start_acl(struct hci_unit *);
void	sbt_start_sco(struct hci_unit *);
d94 1
a94 1
int sbt_debug = 1;
d127 10
d178 2
a179 2
	sc->sc_buf = malloc(SBT_PKT_BUFSIZ, M_DEVBUF,
	    M_NOWAIT | M_CANFAIL);
d185 7
d206 1
a206 9
	sc->sc_unit.hci_softc = self;
	sc->sc_unit.hci_devname = DEVNAME(sc);
	sc->sc_unit.hci_enable = sbt_enable;
	sc->sc_unit.hci_disable = sbt_disable;
	sc->sc_unit.hci_start_cmd = sbt_start_cmd;
	sc->sc_unit.hci_start_acl = sbt_start_acl;
	sc->sc_unit.hci_start_sco = sbt_start_sco;
	sc->sc_unit.hci_ipl = IPL_TTY; /* XXX */
	hci_attach(&sc->sc_unit);
a214 2
	while (sc->sc_thread != NULL)
		tsleep(sc, PWAIT, "dying", 0);
d216 8
a223 1
	hci_detach(&sc->sc_unit);
d228 6
d335 1
d345 1
d383 1
a383 1
			hci_input_acl(&sc->sc_unit, m);
d388 1
a388 1
			hci_input_sco(&sc->sc_unit, m);
d393 1
a393 1
			hci_input_event(&sc->sc_unit, m);
d398 1
a398 1
			sc->sc_unit.hci_stats.err_rx++;
d403 1
a403 1
		sc->sc_unit.hci_stats.err_rx++;
d417 1
a417 1
sbt_enable(struct hci_unit *unit)
d419 3
a421 1
	if (unit->hci_flags & BTF_RUNNING)
d424 1
a424 2
	unit->hci_flags |= BTF_RUNNING;
	unit->hci_flags &= ~BTF_XMIT;
d429 1
a429 1
sbt_disable(struct hci_unit *unit)
d431 4
a434 1
	if (!(unit->hci_flags & BTF_RUNNING))
d437 1
d449 2
a450 2

	unit->hci_flags &= ~BTF_RUNNING;
d454 1
a454 1
sbt_start(struct hci_unit *unit, struct ifqueue *q, int xmit)
d456 1
a456 2
	struct sbt_softc *sc = (struct sbt_softc *)unit->hci_softc;
	struct mbuf *m;
d462 6
a467 1
	if (sc->sc_dying || IF_IS_EMPTY(q))
d469 12
d500 1
a500 1
	unit->hci_flags |= xmit;
d509 17
a525 1
	unit->hci_flags &= ~xmit;
d529 1
a529 1
sbt_start_cmd(struct hci_unit *unit)
d531 3
a533 1
	sbt_start(unit, &unit->hci_cmdq, BTF_XMIT_CMD);
d537 1
a537 1
sbt_start_acl(struct hci_unit *unit)
d539 3
a541 1
	sbt_start(unit, &unit->hci_acltxq, BTF_XMIT_ACL);
d545 1
a545 1
sbt_start_sco(struct hci_unit *unit)
d547 29
a575 1
	sbt_start(unit, &unit->hci_scotxq, BTF_XMIT_SCO);
@


1.8
log
@better debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.7 2007/06/06 23:18:06 uwe Exp $	*/
d462 1
a462 1
	sbt_start(unit, &unit->hci_cmdq, BTF_XMIT_ACL);
@


1.7
log
@Oops, dispatch packets to the correct hci_input_xxx() function
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.6 2007/06/06 22:48:00 uwe Exp $	*/
d82 1
d84 1
d86 1
d89 1
d222 1
a222 1
		printf("sbt_write_cmd: giving up :-(\n");
d236 2
a237 1
		DPRINTF(("sbt_write_packet: failed to send length\n"));
d243 2
a244 1
		DPRINTF(("sbt_write_packet: failed to send packet data\n"));
d259 2
a260 1
		DPRINTF(("sbt_read_packet: failed to read length\n"));
d265 2
a266 1
		DPRINTF(("sbt_read_packet: len %u > %u\n", len, *lenp));
d271 2
a272 1
	DPRINTF(("sbt_read_packet: reading len %u bytes\n", len));
d275 2
a276 1
		DPRINTF(("sbt_read_packet: failed to read packet data\n"));
d324 1
a324 1
		printf("sbt_intr: read failed\n");
d330 1
a330 1
		printf("sbt_intr: MGETHDR failed\n");
d340 1
a340 1
		printf("sbt_intr: m_copyback failed\n");
d349 2
d354 2
d359 2
d443 2
a444 2
	printf("%s: xmit %s packet (%d bytes)\n",
	    unit->hci_devname, what, m->m_pkthdr.len);
d454 1
a454 2
		printf("%s: sbt_write_packet failed\n",
		    unit->hci_devname);
@


1.6
log
@Let it compile with SBT_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.5 2007/06/03 21:57:38 uwe Exp $	*/
d51 1
a51 1
#define SBT_BUFSIZ_HCI	65540
d154 1
a154 1
	sc->sc_buf = malloc(SBT_BUFSIZ_HCI, M_DEVBUF,
d312 2
a313 2
	len = SBT_BUFSIZ_HCI;
	if (sbt_read_packet(sc, sc->sc_buf, &len) != 0) {
d337 17
a353 3
		DPRINTF(("%s: recv 0x%x packet (%d bytes)\n",
		    DEVNAME(sc), sc->sc_buf[0], m->m_pkthdr.len));
		hci_input_event(&sc->sc_unit, m);
d428 1
a428 1
	    unit->hci_devname, m->m_pkthdr.len);
@


1.5
log
@Implement transmission of ACL and SCO packets
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.4 2007/06/02 01:30:37 uwe Exp $	*/
d409 1
a409 1
	case BTF_XMIT_SCL:
@


1.4
log
@retry reading HCI packets a few times before giving up
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.3 2007/05/31 23:37:21 uwe Exp $	*/
d76 1
d387 1
a387 1
sbt_start_cmd(struct hci_unit *unit)
d392 3
d396 1
a396 1
	if (sc->sc_dying || IF_IS_EMPTY(&unit->hci_cmdq))
d399 1
a399 1
	IF_DEQUEUE(&unit->hci_cmdq, m);
d401 15
a415 2
	DPRINTF(("%s: xmit CMD packet (%d bytes)\n",
	    unit->hci_devname, m->m_pkthdr.len));
d417 1
a417 1
	unit->hci_flags |= BTF_XMIT_CMD;
d427 7
a433 1
	unit->hci_flags &= ~BTF_XMIT_CMD;
d439 1
a439 1
	printf("sbt_start_acl\n");
d445 1
a445 1
	printf("sbt_start_sco\n");
a446 1

@


1.3
log
@don't print debug messages
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.2 2007/05/31 23:28:30 uwe Exp $	*/
d40 1
d51 2
a52 1
#define SBT_BUFSIZ_HCI	65535
d62 1
a245 1
	int error, retry = 3;
d248 1
a248 4

again:
	if (retry-- == 0)
		return error;
d253 1
a253 1
		goto again;
d257 3
a259 2
		error = ENOMEM;
		goto again;
d262 1
d266 15
a280 1
		goto again;
d335 3
a337 1
	if (m != NULL)
d339 1
a339 1
	else
@


1.2
log
@Clean up and fix sbt_write_packet()
@
text
@d1 1
a1 1
/*	$OpenBSD: sbt.c,v 1.1 2007/05/31 18:45:09 uwe Exp $	*/
a68 1
int	sbt_intr_pending(struct sbt_softc *);
a279 9
sbt_intr_pending(struct sbt_softc *sc)
{
	u_char val = CSR_READ_1(sc, SBT_REG_ISTAT);
	if (val != 0)
		printf("sbt_intr_pending %x\n", val);
	return val != 0;
}

int
a291 1
	printf("sbt_intr status=0x%x\n");
a338 2
	printf("sbt_enable\n");

a349 2
	printf("sbt_disable\n");

@


1.1
log
@An SDIO Bluetooth driver, only initial bits and therefore not enabled yet
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a22 2
#include <sys/kernel.h>
#include <sys/kthread.h>
a64 4
void	sbt_create_thread(void *);

void	sbt_thread0(void *);
void	sbt_thread(void *);
a94 2
extern struct cfdriver bthub_cd;

a168 6
	/* Create a thread for the packet transport. */
#ifdef DO_CONFIG_PENDING
	config_pending_incr();
#endif
	kthread_create_deferred(sbt_create_thread, sc);

a182 17
void
sbt_create_thread(void *arg)
{
	struct sbt_softc *sc = arg;
	struct proc *thread0;

	if (kthread_create(sbt_thread, sc, &sc->sc_thread, "%s",
	    DEVNAME(sc)) != 0)
		printf("%s: unable to create thread\n", DEVNAME(sc));
	if (kthread_create(sbt_thread0, sc, &thread0, "%s (hci)",
	    DEVNAME(sc)) != 0)
		printf("%s: unable to create hci thread\n", DEVNAME(sc));
#ifdef DO_CONFIG_PENDING
	config_pending_decr();
#endif
}

a201 35
 * Bluetooth HCI packet transport thread (*caugh*)
 */

void
sbt_thread0(void *arg)
{
	struct sbt_softc *sc = arg;

	/* XXX wrong place */
	if (!(sc->sc_unit.hci_flags & BTF_UP) &&
	    hci_enable(&sc->sc_unit) == 0)
		sc->sc_unit.hci_flags |= BTF_UP;

	kthread_exit(0);
}

void
sbt_thread(void *arg)
{
	struct sbt_softc *sc = arg;

	while (!sc->sc_dying) {
#ifdef SBT_POLLING
		if (sbt_intr_pending(sc) && sbt_intr(sc))
			continue;
#endif
		tsleep(sc, PPAUSE, "slack", hz / 4);
	}

	sc->sc_thread = NULL;
	wakeup(sc);
	kthread_exit(0);
}

/*
d209 1
d223 4
a226 3
	hdr[0] = len & 0xff;
	hdr[1] = (len >> 8) & 0xff;
	hdr[2] = (len >> 16) & 0xff;
d296 3
d335 2
@

