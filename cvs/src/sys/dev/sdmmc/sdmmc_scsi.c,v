head	1.38;
access;
symbols
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.2
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.35.0.4
	OPENBSD_5_8_BASE:1.35
	OPENBSD_5_7:1.34.0.4
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.14
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.30.0.10
	OPENBSD_5_4_BASE:1.30
	OPENBSD_5_3:1.30.0.8
	OPENBSD_5_3_BASE:1.30
	OPENBSD_5_2:1.30.0.6
	OPENBSD_5_2_BASE:1.30
	OPENBSD_5_1_BASE:1.30
	OPENBSD_5_1:1.30.0.4
	OPENBSD_5_0:1.30.0.2
	OPENBSD_5_0_BASE:1.30
	OPENBSD_4_9:1.26.0.2
	OPENBSD_4_9_BASE:1.26
	OPENBSD_4_8:1.23.0.2
	OPENBSD_4_8_BASE:1.23
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.15.0.2
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.9.0.4
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.9.0.2
	OPENBSD_4_3_BASE:1.9
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.38
date	2017.01.21.05.42.04;	author guenther;	state Exp;
branches;
next	1.37;
commitid	CHRb0fCqa8XxUAMH;

1.37
date	2017.01.20.00.52.32;	author deraadt;	state Exp;
branches;
next	1.36;
commitid	FsY1FK5Q6ycMTr92;

1.36
date	2016.05.05.10.51.10;	author kettenis;	state Exp;
branches;
next	1.35;
commitid	Imv1Y4cyeyYhKR7R;

1.35
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.34;
commitid	p4LJxGKbi0BU2cG6;

1.34
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.33;
commitid	zM5ckwX4kwwmipG0;

1.33
date	2014.11.01.16.32.06;	author jsg;	state Exp;
branches;
next	1.32;
commitid	XzgnhFuyvefbeawB;

1.32
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.31;
commitid	uzzBR7hz9ncd4O6G;

1.31
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2011.07.17.22.46.48;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.07.09.02.11.29;	author matthew;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.09.00.39.29;	author matthew;	state Exp;
branches;
next	1.27;

1.27
date	2011.06.16.01.09.16;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2010.10.25.10.36.49;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.24;

1.24
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.23;

1.23
date	2010.06.20.23.05.29;	author mk;	state Exp;
branches;
next	1.22;

1.22
date	2010.05.20.00.55.18;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.01.09.23.15.07;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2009.10.03.18.42.36;	author kettenis;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.05.11.59.58;	author dlg;	state Exp;
branches;
next	1.17;

1.17
date	2009.04.07.16.35.52;	author blambert;	state Exp;
branches;
next	1.16;

1.16
date	2009.03.24.12.15.34;	author kettenis;	state Exp;
branches;
next	1.15;

1.15
date	2009.02.20.19.16.35;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2009.02.06.20.16.41;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2008.12.02.23.49.54;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2008.11.24.07.32.08;	author blambert;	state Exp;
branches;
next	1.9;

1.9
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.8;

1.8
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.7;

1.7
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2006.10.17.01.26.26;	author dlg;	state Exp;
branches;
next	1.5;

1.5
date	2006.08.23.16.34.56;	author pedro;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.18.04.10.35;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.21.53.41;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.18.45.23;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.38
log
@p_comm is the process's command and isn't per thread, so move it from
struct proc to struct process.

ok deraadt@@ kettenis@@
@
text
@/*	$OpenBSD: sdmmc_scsi.c,v 1.37 2017/01/20 00:52:32 deraadt Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* A SCSI adapter emulation to access SD/MMC memory cards */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/sdmmc/sdmmc_scsi.h>
#include <dev/sdmmc/sdmmcvar.h>

#define SDMMC_SCSIID_HOST	0x00
#define SDMMC_SCSIID_MAX	0x0f

#define SDMMC_SCSI_MAXCMDS	8

struct sdmmc_scsi_target {
	struct sdmmc_function *card;
};

struct sdmmc_ccb {
	struct sdmmc_scsi_softc *ccb_scbus;
	struct scsi_xfer *ccb_xs;
	int ccb_flags;
#define SDMMC_CCB_F_ERR		0x0001
	u_int32_t ccb_blockno;
	u_int32_t ccb_blockcnt;
	volatile enum {
		SDMMC_CCB_FREE,
		SDMMC_CCB_READY,
		SDMMC_CCB_QUEUED
	} ccb_state;
	struct sdmmc_command ccb_cmd;
	struct sdmmc_task ccb_task;
	TAILQ_ENTRY(sdmmc_ccb) ccb_link;
};

TAILQ_HEAD(sdmmc_ccb_list, sdmmc_ccb);

struct sdmmc_scsi_softc {
	struct scsi_adapter sc_adapter;
	struct scsi_link sc_link;
	struct device *sc_child;
	struct sdmmc_scsi_target *sc_tgt;
	int sc_ntargets;
	struct sdmmc_ccb *sc_ccbs;		/* allocated ccbs */
	struct sdmmc_ccb_list sc_ccb_freeq;	/* free ccbs */
	struct sdmmc_ccb_list sc_ccb_runq;	/* queued ccbs */
	struct mutex sc_ccb_mtx;
	struct scsi_iopool sc_iopool;
};

int	sdmmc_alloc_ccbs(struct sdmmc_scsi_softc *, int);
void	sdmmc_free_ccbs(struct sdmmc_scsi_softc *);
void	*sdmmc_ccb_alloc(void *);
void	sdmmc_ccb_free(void *, void *);

void	sdmmc_scsi_cmd(struct scsi_xfer *);
void	sdmmc_inquiry(struct scsi_xfer *);
void	sdmmc_start_xs(struct sdmmc_softc *, struct sdmmc_ccb *);
void	sdmmc_complete_xs(void *);
void	sdmmc_done_xs(struct sdmmc_ccb *);
void	sdmmc_stimeout(void *);
void	sdmmc_scsi_minphys(struct buf *, struct scsi_link *);

#ifdef SDMMC_DEBUG
#define DPRINTF(s)	printf s
#else
#define DPRINTF(s)	/**/
#endif

void
sdmmc_scsi_attach(struct sdmmc_softc *sc)
{
	struct sdmmc_attach_args saa;
	struct sdmmc_scsi_softc *scbus;
	struct sdmmc_function *sf;

	rw_assert_wrlock(&sc->sc_lock);

	scbus = malloc(sizeof *scbus, M_DEVBUF, M_WAITOK | M_ZERO);

	scbus->sc_tgt = malloc(sizeof(*scbus->sc_tgt) *
	    (SDMMC_SCSIID_MAX+1), M_DEVBUF, M_WAITOK | M_ZERO);

	/*
	 * Each card that sent us a CID in the identification stage
	 * gets a SCSI ID > 0, whether it is a memory card or not.
	 */
	scbus->sc_ntargets = 1;
	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		if (scbus->sc_ntargets >= SDMMC_SCSIID_MAX+1)
			break;
		scbus->sc_tgt[scbus->sc_ntargets].card = sf;
		scbus->sc_ntargets++;
	}

	/* Preallocate some CCBs and initialize the CCB lists. */
	if (sdmmc_alloc_ccbs(scbus, SDMMC_SCSI_MAXCMDS) != 0) {
		printf("%s: can't allocate ccbs\n", sc->sc_dev.dv_xname);
		goto free_sctgt;
	}

	sc->sc_scsibus = scbus;

	scbus->sc_adapter.scsi_cmd = sdmmc_scsi_cmd;
	scbus->sc_adapter.scsi_minphys = sdmmc_scsi_minphys;

	scbus->sc_link.adapter_target = SDMMC_SCSIID_HOST;
	scbus->sc_link.adapter_buswidth = scbus->sc_ntargets;
	scbus->sc_link.adapter_softc = sc;
	scbus->sc_link.luns = 1;
	scbus->sc_link.openings = 1;
	scbus->sc_link.adapter = &scbus->sc_adapter;
	scbus->sc_link.pool = &scbus->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.scsi_link = &scbus->sc_link;

	scbus->sc_child = config_found(&sc->sc_dev, &saa, scsiprint);
	if (scbus->sc_child == NULL) {
		printf("%s: can't attach scsibus\n", sc->sc_dev.dv_xname);
		goto free_ccbs;
	}
	return;

 free_ccbs:
	sc->sc_scsibus = NULL;
	sdmmc_free_ccbs(scbus);
 free_sctgt:
	free(scbus->sc_tgt, M_DEVBUF, 0);
	free(scbus, M_DEVBUF, 0);
}

void
sdmmc_scsi_detach(struct sdmmc_softc *sc)
{
	struct sdmmc_scsi_softc *scbus;
	struct sdmmc_ccb *ccb;
	int s;

	rw_assert_wrlock(&sc->sc_lock);

	scbus = sc->sc_scsibus;
	if (scbus == NULL)
		return;

	/* Complete all open scsi xfers. */
	s = splbio();
	for (ccb = TAILQ_FIRST(&scbus->sc_ccb_runq); ccb != NULL;
	     ccb = TAILQ_FIRST(&scbus->sc_ccb_runq))
		sdmmc_stimeout(ccb);
	splx(s);

	if (scbus->sc_child != NULL)
		config_detach(scbus->sc_child, DETACH_FORCE);

	if (scbus->sc_tgt != NULL)
		free(scbus->sc_tgt, M_DEVBUF, 0);

	sdmmc_free_ccbs(scbus);
	free(scbus, M_DEVBUF, 0);
	sc->sc_scsibus = NULL;
}

/*
 * CCB management
 */

int
sdmmc_alloc_ccbs(struct sdmmc_scsi_softc *scbus, int nccbs)
{
	struct sdmmc_ccb *ccb;
	int i;

	scbus->sc_ccbs = mallocarray(nccbs, sizeof(struct sdmmc_ccb),
	    M_DEVBUF, M_NOWAIT);
	if (scbus->sc_ccbs == NULL)
		return 1;

	TAILQ_INIT(&scbus->sc_ccb_freeq);
	TAILQ_INIT(&scbus->sc_ccb_runq);
	mtx_init(&scbus->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&scbus->sc_iopool, scbus, sdmmc_ccb_alloc,
	    sdmmc_ccb_free);

	for (i = 0; i < nccbs; i++) {
		ccb = &scbus->sc_ccbs[i];
		ccb->ccb_scbus = scbus;
		ccb->ccb_state = SDMMC_CCB_FREE;
		ccb->ccb_flags = 0;
		ccb->ccb_xs = NULL;

		TAILQ_INSERT_TAIL(&scbus->sc_ccb_freeq, ccb, ccb_link);
	}
	return 0;
}

void
sdmmc_free_ccbs(struct sdmmc_scsi_softc *scbus)
{
	if (scbus->sc_ccbs != NULL) {
		free(scbus->sc_ccbs, M_DEVBUF, 0);
		scbus->sc_ccbs = NULL;
	}
}

void *
sdmmc_ccb_alloc(void *xscbus)
{
	struct sdmmc_scsi_softc *scbus = xscbus;
	struct sdmmc_ccb *ccb;

	mtx_enter(&scbus->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&scbus->sc_ccb_freeq);
	if (ccb != NULL) {
		TAILQ_REMOVE(&scbus->sc_ccb_freeq, ccb, ccb_link);
		ccb->ccb_state = SDMMC_CCB_READY;
	}
	mtx_leave(&scbus->sc_ccb_mtx);

	return ccb;
}

void
sdmmc_ccb_free(void *xscbus, void *xccb)
{
	struct sdmmc_scsi_softc *scbus = xscbus;
	struct sdmmc_ccb *ccb = xccb;
	int s;

	s = splbio();
	if (ccb->ccb_state == SDMMC_CCB_QUEUED)
		TAILQ_REMOVE(&scbus->sc_ccb_runq, ccb, ccb_link);
	splx(s);

	ccb->ccb_state = SDMMC_CCB_FREE;
	ccb->ccb_flags = 0;
	ccb->ccb_xs = NULL;

	mtx_enter(&scbus->sc_ccb_mtx);
	TAILQ_INSERT_TAIL(&scbus->sc_ccb_freeq, ccb, ccb_link);
	mtx_leave(&scbus->sc_ccb_mtx);
}

/*
 * SCSI command emulation
 */

/* XXX move to some sort of "scsi emulation layer". */
static void
sdmmc_scsi_decode_rw(struct scsi_xfer *xs, u_int32_t *blocknop,
    u_int32_t *blockcntp)
{
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	
	if (xs->cmdlen == 6) {
		rw = (struct scsi_rw *)xs->cmd;
		*blocknop = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		*blockcntp = rw->length ? rw->length : 0x100;
	} else {
		rwb = (struct scsi_rw_big *)xs->cmd;
		*blocknop = _4btol(rwb->addr);
		*blockcntp = _2btol(rwb->length);
	}
}

void
sdmmc_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct sdmmc_softc *sc = link->adapter_softc;
	struct sdmmc_scsi_softc *scbus = sc->sc_scsibus;
	struct sdmmc_scsi_target *tgt = &scbus->sc_tgt[link->target];
	struct scsi_read_cap_data rcd;
	u_int32_t blockno;
	u_int32_t blockcnt;
	struct sdmmc_ccb *ccb;

	if (link->target >= scbus->sc_ntargets || tgt->card == NULL ||
	    link->lun != 0) {
		DPRINTF(("%s: sdmmc_scsi_cmd: no target %d\n",
		    DEVNAME(sc), link->target));
		/* XXX should be XS_SENSE and sense filled out */
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	DPRINTF(("%s: scsi cmd target=%d opcode=%#x proc=\"%s\" (poll=%#x)\n",
	    DEVNAME(sc), link->target, xs->cmd->opcode, curproc ?
	    curproc->p_p->ps_comm : "", xs->flags & SCSI_POLL));

	xs->error = XS_NOERROR;

	switch (xs->cmd->opcode) {
	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
		/* Deal with I/O outside the switch. */
		break;

	case INQUIRY:
		sdmmc_inquiry(xs);
		return;

	case TEST_UNIT_READY:
	case START_STOP:
	case SYNCHRONIZE_CACHE:
		scsi_done(xs);
		return;

	case READ_CAPACITY:
		bzero(&rcd, sizeof rcd);
		_lto4b(tgt->card->csd.capacity - 1, rcd.addr);
		_lto4b(tgt->card->csd.sector_size, rcd.length);
		bcopy(&rcd, xs->data, MIN(xs->datalen, sizeof rcd));
		scsi_done(xs);
		return;

	default:
		DPRINTF(("%s: unsupported scsi command %#x\n",
		    DEVNAME(sc), xs->cmd->opcode));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	/* A read or write operation. */
	sdmmc_scsi_decode_rw(xs, &blockno, &blockcnt);

	if (blockno >= tgt->card->csd.capacity ||
	    blockno + blockcnt > tgt->card->csd.capacity) {
		DPRINTF(("%s: out of bounds %u-%u >= %u\n", DEVNAME(sc),
		    blockno, blockcnt, tgt->card->csd.capacity));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}

	ccb = xs->io;

	ccb->ccb_xs = xs;
	ccb->ccb_blockcnt = blockcnt;
	ccb->ccb_blockno = blockno;

	sdmmc_start_xs(sc, ccb);
}

void
sdmmc_inquiry(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct sdmmc_softc *sc = link->adapter_softc;
	struct sdmmc_scsi_softc *scbus = sc->sc_scsibus;
	struct sdmmc_scsi_target *tgt = &scbus->sc_tgt[link->target];
	struct scsi_inquiry_data inq;
	struct scsi_inquiry *cdb = (struct scsi_inquiry *)xs->cmd;
	char vendor[sizeof(inq.vendor) + 1];
	char product[sizeof(inq.product) + 1];
	char revision[sizeof(inq.revision) + 1];

        if (xs->cmdlen != sizeof(*cdb)) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	if (ISSET(cdb->flags, SI_EVPD)) {
		xs->error = XS_DRIVER_STUFFUP;
		goto done;
	}

	memset(vendor, 0, sizeof(vendor));
	memset(product, 0, sizeof(product));
	memset(revision, 0, sizeof(revision));
	switch (tgt->card->cid.mid) {
	case 0x02:
	case 0x45:
		strlcpy(vendor, "Sandisk", sizeof(vendor));
		break;
	case 0x11:
		strlcpy(vendor, "Toshiba", sizeof(vendor));
		break;
	case 0x13:
		strlcpy(vendor, "Micron", sizeof(vendor));
		break;
	case 0x15:
		strlcpy(vendor, "Samsung", sizeof(vendor));
		break;
	case 0x70:
		strlcpy(vendor, "Kingston", sizeof(vendor));
		break;
	default:
		strlcpy(vendor, "SD/MMC", sizeof(vendor));
		break;
	}
	strlcpy(product, tgt->card->cid.pnm, sizeof(product));
	snprintf(revision, sizeof(revision), "%04X", tgt->card->cid.rev);

	memset(&inq, 0, sizeof inq);
	inq.device = T_DIRECT;
	inq.dev_qual2 = SID_REMOVABLE;
	inq.version = 2;
	inq.response_format = 2;
	inq.additional_length = 32;
	memcpy(inq.vendor, vendor, sizeof(inq.vendor));
	memcpy(inq.product, product, sizeof(inq.product));
	memcpy(inq.revision, revision, sizeof(inq.revision));

	memcpy(xs->data, &inq, MIN(xs->datalen, sizeof(inq)));

done:
	scsi_done(xs);
}

void
sdmmc_start_xs(struct sdmmc_softc *sc, struct sdmmc_ccb *ccb)
{
	struct sdmmc_scsi_softc *scbus = sc->sc_scsibus;
	struct scsi_xfer *xs = ccb->ccb_xs;
	int s;

	timeout_set(&xs->stimeout, sdmmc_stimeout, ccb);
	sdmmc_init_task(&ccb->ccb_task, sdmmc_complete_xs, ccb);

	s = splbio();
	TAILQ_INSERT_TAIL(&scbus->sc_ccb_runq, ccb, ccb_link);
	ccb->ccb_state = SDMMC_CCB_QUEUED;
	splx(s);

	if (ISSET(xs->flags, SCSI_POLL)) {
		sdmmc_complete_xs(ccb);
		return;
	}

	timeout_add_msec(&xs->stimeout, xs->timeout);
	sdmmc_add_task(sc, &ccb->ccb_task);
}

void
sdmmc_complete_xs(void *arg)
{
	struct sdmmc_ccb *ccb = arg;
	struct scsi_xfer *xs = ccb->ccb_xs;
	struct scsi_link *link = xs->sc_link;
	struct sdmmc_softc *sc = link->adapter_softc;
	struct sdmmc_scsi_softc *scbus = sc->sc_scsibus;
	struct sdmmc_scsi_target *tgt = &scbus->sc_tgt[link->target];
	int error;
	int s;

	DPRINTF(("%s: scsi cmd target=%d opcode=%#x proc=\"%s\" (poll=%#x)"
	    " complete\n", DEVNAME(sc), link->target, xs->cmd->opcode,
	    curproc ? curproc->p_p->ps_comm : "", xs->flags & SCSI_POLL));

	s = splbio();

	if (ISSET(xs->flags, SCSI_DATA_IN))
		error = sdmmc_mem_read_block(tgt->card, ccb->ccb_blockno,
		    xs->data, ccb->ccb_blockcnt * DEV_BSIZE);
	else
		error = sdmmc_mem_write_block(tgt->card, ccb->ccb_blockno,
		    xs->data, ccb->ccb_blockcnt * DEV_BSIZE);

	if (error != 0)
		xs->error = XS_DRIVER_STUFFUP;

	sdmmc_done_xs(ccb);
	splx(s);
}

void
sdmmc_done_xs(struct sdmmc_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ccb_xs;
#ifdef SDMMC_DEBUG
	struct scsi_link *link = xs->sc_link;
	struct sdmmc_softc *sc = link->adapter_softc;
#endif

	timeout_del(&xs->stimeout);

	DPRINTF(("%s: scsi cmd target=%d opcode=%#x proc=\"%s\" (error=%#x)"
	    " done\n", DEVNAME(sc), link->target, xs->cmd->opcode,
	    curproc ? curproc->p_p->ps_comm : "", xs->error));

	xs->resid = 0;

	if (ISSET(ccb->ccb_flags, SDMMC_CCB_F_ERR))
		xs->error = XS_DRIVER_STUFFUP;

	scsi_done(xs);
}

void
sdmmc_stimeout(void *arg)
{
	struct sdmmc_ccb *ccb = arg;
	int s;

	s = splbio();
	ccb->ccb_flags |= SDMMC_CCB_F_ERR;
	if (sdmmc_task_pending(&ccb->ccb_task)) {
		sdmmc_del_task(&ccb->ccb_task);
		sdmmc_done_xs(ccb);
	}
	splx(s);
}

void
sdmmc_scsi_minphys(struct buf *bp, struct scsi_link *sl)
{
	struct sdmmc_softc *sc = sl->adapter_softc;
	struct sdmmc_scsi_softc *scbus = sc->sc_scsibus;
	struct sdmmc_scsi_target *tgt = &scbus->sc_tgt[sl->target];
	struct sdmmc_function *sf = tgt->card;

	/* limit to max. transfer size supported by card/host */
	if (sc->sc_max_xfer != 0 &&
	    bp->b_bcount > sf->csd.sector_size * sc->sc_max_xfer)
		bp->b_bcount = sf->csd.sector_size * sc->sc_max_xfer;

	minphys(bp);
}
@


1.37
log
@sdmmc sd(4) devices should be marked SID_REMOVABLE, so that eject(1) can
succeed.  No downside in the bottom part of the driver.
ok dlg krw
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.36 2016/05/05 10:51:10 kettenis Exp $	*/
d316 1
a316 1
	    curproc->p_comm : "", xs->flags & SCSI_POLL));
d479 1
a479 1
	    curproc ? curproc->p_comm : "", xs->flags & SCSI_POLL));
d510 1
a510 1
	    curproc ? curproc->p_comm : "", xs->error));
@


1.36
log
@Populate SCSI inquiry data with information from SD and MMC cards.
Code is slightly more convoluted to avoid using strncpy(9).

ok jsg@@, millert@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.35 2015/03/14 03:38:49 jsg Exp $	*/
d427 1
@


1.35
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.34 2014/12/09 07:05:06 doug Exp $	*/
d379 3
d384 3
d398 28
a425 1
	bzero(&inq, sizeof inq);
d430 3
a432 4
	strlcpy(inq.vendor, "SD/MMC ", sizeof(inq.vendor));
	snprintf(inq.product, sizeof(inq.product),
	    "Drive #%02d", link->target);
	strlcpy(inq.revision, "   ", sizeof(inq.revision));
d434 1
a434 1
	bcopy(&inq, xs->data, MIN(xs->datalen, sizeof(inq)));
@


1.34
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.33 2014/11/01 16:32:06 jsg Exp $	*/
a23 1
#include <sys/kernel.h>
@


1.33
log
@fix the build when SDMMC_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.32 2014/09/14 14:17:25 jsg Exp $	*/
d200 1
a200 1
	scbus->sc_ccbs = malloc(sizeof(struct sdmmc_ccb) * nccbs,
@


1.32
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.31 2014/07/12 18:48:52 tedu Exp $	*/
d26 1
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.30 2011/07/17 22:46:48 matthew Exp $	*/
a25 1
#include <sys/proc.h>
@


1.30
log
@Backout a bunch of my SCSI commits from c2k11.  At least one of these
is causing problems when trying to boot sparc64 from an isp(4).

Verified to fix the sparc64/isp(4) regression by krw@@; ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.29 2011/07/09 02:11:29 matthew Exp $	*/
d155 2
a156 2
	free(scbus->sc_tgt, M_DEVBUF);
	free(scbus, M_DEVBUF);
d183 1
a183 1
		free(scbus->sc_tgt, M_DEVBUF);
d186 1
a186 1
	free(scbus, M_DEVBUF);
d227 1
a227 1
		free(scbus->sc_ccbs, M_DEVBUF);
@


1.29
log
@Simplify sdmmc_scsi by using SCSI_NO_ADAPTER_TARGET.

Tested by drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.28 2011/07/09 00:39:29 matthew Exp $	*/
d36 2
a37 1
#define SDMMC_SCSIID_MAX	0x10
d108 1
a108 1
	    SDMMC_SCSIID_MAX, M_DEVBUF, M_WAITOK | M_ZERO);
d112 1
a112 1
	 * gets a SCSI ID, whether it is a memory card or not.
d114 1
a114 1
	scbus->sc_ntargets = 0;
d116 1
a116 1
		if (scbus->sc_ntargets >= SDMMC_SCSIID_MAX)
d133 2
a134 1
	scbus->sc_link.adapter_target = SCSI_NO_ADAPTER_TARGET;
d136 1
d142 1
a142 3
	saa.saa.saa_sc_link = &scbus->sc_link;
	saa.saa.saa_targets = scbus->sc_ntargets;
	saa.saa.saa_luns = 1;
d144 1
a144 1
	scbus->sc_child = config_found(&sc->sc_dev, &saa.saa, scsiprint);
@


1.28
log
@Kludge around sdmmc(4)'s poor design: replace "struct scsi_link *"
with "struct scsibus_attach_args" in sdmmc_attach_args.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.27 2011/06/16 01:09:16 dlg Exp $	*/
d36 1
a36 2
#define SDMMC_SCSIID_HOST	0x00
#define SDMMC_SCSIID_MAX	0x0f
d107 1
a107 1
	    (SDMMC_SCSIID_MAX+1), M_DEVBUF, M_WAITOK | M_ZERO);
d111 1
a111 1
	 * gets a SCSI ID > 0, whether it is a memory card or not.
d113 1
a113 1
	scbus->sc_ntargets = 1;
d115 1
a115 1
		if (scbus->sc_ntargets >= SDMMC_SCSIID_MAX+1)
d132 1
a132 2
	scbus->sc_link.adapter_target = SDMMC_SCSIID_HOST;
	scbus->sc_link.adapter_buswidth = scbus->sc_ntargets;
a133 1
	scbus->sc_link.luns = 1;
d140 2
@


1.27
log
@dont respond to VPD inquiries with standard inquiry data. add a
check to make sure cmdlen is correct while there.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.26 2010/10/25 10:36:49 krw Exp $	*/
d142 1
a142 1
	saa.scsi_link = &scbus->sc_link;
d144 1
a144 1
	scbus->sc_child = config_found(&sc->sc_dev, &saa, scsiprint);
@


1.26
log
@Iopoolification. Tested by mcbride@@, dlg@@, and Gabriel Kihlman on tech@@.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.25 2010/08/24 14:52:23 blambert Exp $	*/
d83 1
a299 1
	struct scsi_inquiry_data inq;
d330 1
a330 11
		bzero(&inq, sizeof inq);
		inq.device = T_DIRECT;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		strlcpy(inq.vendor, "SD/MMC ", sizeof(inq.vendor));
		snprintf(inq.product, sizeof(inq.product),
		    "Drive #%02d", link->target);
		strlcpy(inq.revision, "   ", sizeof(inq.revision));
		bcopy(&inq, xs->data, MIN(xs->datalen, sizeof inq));
		scsi_done(xs);
d374 33
@


1.25
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.24 2010/08/19 17:54:12 jasper Exp $	*/
d73 2
d79 2
a80 2
struct sdmmc_ccb *sdmmc_get_ccb(struct sdmmc_scsi_softc *, int);
void	sdmmc_put_ccb(struct sdmmc_ccb *);
d138 1
d206 3
d231 2
a232 2
struct sdmmc_ccb *
sdmmc_get_ccb(struct sdmmc_scsi_softc *scbus, int flags)
d234 1
a235 1
	int s;
d237 2
a238 4
	s = splbio();
	while ((ccb = TAILQ_FIRST(&scbus->sc_ccb_freeq)) == NULL &&
	    !ISSET(flags, SCSI_NOSLEEP))
		tsleep(&scbus->sc_ccb_freeq, PRIBIO, "getccb", 0);
d243 2
a244 1
	splx(s);
d249 1
a249 1
sdmmc_put_ccb(struct sdmmc_ccb *ccb)
d251 2
a252 1
	struct sdmmc_scsi_softc *scbus = ccb->ccb_scbus;
d258 2
d263 2
d266 1
a266 3
	if (TAILQ_NEXT(ccb, ccb_link) == NULL)
		wakeup(&scbus->sc_ccb_freeq);
	splx(s);
d377 1
a377 7
	ccb = sdmmc_get_ccb(sc->sc_scsibus, xs->flags);
	if (ccb == NULL) {
		printf("%s: out of ccbs\n", DEVNAME(sc));
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;
	}
a379 1

a461 1
	sdmmc_put_ccb(ccb);
@


1.24
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.23 2010/06/20 23:05:29 mk Exp $	*/
d100 1
a100 1
	SDMMC_ASSERT_LOCKED(sc);
d162 1
a162 1
	SDMMC_ASSERT_LOCKED(sc);
@


1.23
log
@Don't use and maintain a function pointer that is only ever set to one
function.  Just call the function where needed.

ok krw dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.22 2010/05/20 00:55:18 krw Exp $	*/
a85 2

#define DEVNAME(sc)	SDMMCDEVNAME(sc)
@


1.22
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.21 2010/03/23 01:57:20 krw Exp $	*/
a49 1
	void (*ccb_done)(struct sdmmc_ccb *);
a211 1
		ccb->ccb_done = NULL;
a256 1
	ccb->ccb_done = NULL;
a379 1
	ccb->ccb_done = sdmmc_done_xs;
d439 1
a439 1
	ccb->ccb_done(ccb);
d477 1
a477 1
		ccb->ccb_done(ccb);
@


1.21
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.20 2010/01/09 23:15:07 krw Exp $	*/
a300 1
	int s;
a307 1
		s = splbio();
a308 1
		splx(s);
a336 1
		s = splbio();
a337 1
		splx(s);
a342 1
		s = splbio();
a343 1
		splx(s);
a350 1
		s = splbio();
a351 1
		splx(s);
a357 1
		s = splbio();
a358 1
		splx(s);
a369 1
		s = splbio();
a370 1
		splx(s);
a377 1
		s = splbio();
a378 1
		splx(s);
@


1.20
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.19 2009/10/03 18:42:36 kettenis Exp $	*/
d81 2
a82 2
int	sdmmc_scsi_cmd(struct scsi_xfer *);
int	sdmmc_start_xs(struct sdmmc_softc *, struct sdmmc_ccb *);
d289 1
a289 1
int
d312 1
a312 1
		return COMPLETE;
d343 1
a343 1
		return COMPLETE;
d351 1
a351 1
		return COMPLETE;
d361 1
a361 1
		return COMPLETE;
d370 1
a370 1
		return COMPLETE;
d384 1
a384 1
		return COMPLETE;
d394 1
a394 1
		return COMPLETE;
d403 1
a403 1
	return sdmmc_start_xs(sc, ccb);
d406 1
a406 1
int
d423 1
a423 1
		return COMPLETE;
a427 1
	return SUCCESSFULLY_QUEUED;
@


1.19
log
@Add missing <sys/device.h>.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.18 2009/09/05 11:59:58 dlg Exp $	*/
a308 1
		xs->flags |= ITSDONE;
a478 1
	xs->flags |= ITSDONE;
@


1.18
log
@scsi_done before COMPLETE
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.17 2009/04/07 16:35:52 blambert Exp $	*/
d23 1
@


1.17
log
@Remove recursion from the sdmmc locking regime.

In snaps for a while.

Originally hacked on phessler@@'s couch.
Testing by many, input from jsg@@

"I'm tired of seeing the Ms" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.16 2009/03/24 12:15:34 kettenis Exp $	*/
d348 3
@


1.16
log
@Remove redundant casts.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.15 2009/02/20 19:16:35 miod Exp $	*/
d102 2
d163 2
@


1.15
log
@Let the sdmmc adapters tell the sdmmc layer how much sectors they can
transfer with one command. Build on this and the recent minphys() changes
in the sdmmc layer to crank transfers at the maximum possible size instead
of a sad DEV_BSIZE.

Depending on your controller, this can speed up sdmmc I/O up to 2.5 times.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.14 2009/02/16 21:19:07 miod Exp $	*/
d102 1
a102 2
	scbus = (struct sdmmc_scsi_softc *)malloc(sizeof *scbus,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d104 1
a104 1
	scbus->sc_tgt = (struct sdmmc_scsi_target *)malloc(sizeof(*scbus->sc_tgt) *
@


1.14
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.13 2009/02/06 20:16:41 grange Exp $	*/
d500 10
a509 3
	/* XXX limit to max. transfer size supported by card/host? */
	if (bp->b_bcount > DEV_BSIZE)
		bp->b_bcount = DEV_BSIZE;
@


1.13
log
@Fix crash on zaurus when sd memory card plugged by providing an attachment
structure that slave devices like sbt expect.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.12 2009/01/21 21:54:00 grange Exp $	*/
d85 1
a85 1
void	sdmmc_scsi_minphys(struct buf *);
d498 1
a498 1
sdmmc_scsi_minphys(struct buf *bp)
@


1.12
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.11 2008/12/02 23:49:54 deraadt Exp $	*/
d98 1
a98 1
	struct scsibus_attach_args saa;
d139 1
a139 1
	saa.saa_sc_link = &scbus->sc_link;
@


1.11
log
@backout: would have been nice if this had been tested, to see that it
crashes the moment a card is plugged in.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.9 2007/09/11 13:39:34 gilles Exp $	*/
d420 1
a420 1
	timeout_add(&xs->stimeout, (xs->timeout * hz) / 1000);
@


1.10
log
@Rework sdmmc locking to remove recursion
Add SDMMC_ASSERT_LOCKED(), replacing many locking calls, and sprinkling
the assertion to make sure that future changes don't catch us out

"please commit" uwe@@
@
text
@d102 2
a103 1
	scbus = malloc(sizeof(*scbus), M_DEVBUF, M_WAITOK | M_ZERO);
d105 1
a105 1
	scbus->sc_tgt = malloc(sizeof(*scbus->sc_tgt) *
@


1.9
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.8 2007/09/10 19:49:31 gilles Exp $	*/
d102 1
a102 2
	scbus = (struct sdmmc_scsi_softc *)malloc(sizeof *scbus,
	    M_DEVBUF, M_WAITOK | M_ZERO);
d104 1
a104 1
	scbus->sc_tgt = (struct sdmmc_scsi_target *)malloc(sizeof(*scbus->sc_tgt) *
@


1.8
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.7 2006/11/28 23:59:45 dlg Exp $	*/
d103 1
a103 1
	    M_DEVBUF, M_WAITOK|M_ZERO);
d106 1
a106 1
	    (SDMMC_SCSIID_MAX+1), M_DEVBUF, M_WAITOK|M_ZERO);
@


1.7
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.6 2006/10/17 01:26:26 dlg Exp $	*/
d102 5
a106 8
	MALLOC(scbus, struct sdmmc_scsi_softc *,
	    sizeof *scbus, M_DEVBUF, M_WAITOK);
	bzero(scbus, sizeof *scbus);

	MALLOC(scbus->sc_tgt, struct sdmmc_scsi_target *,
	    sizeof(*scbus->sc_tgt) * (SDMMC_SCSIID_MAX+1),
	    M_DEVBUF, M_WAITOK);
	bzero(scbus->sc_tgt, sizeof(*scbus->sc_tgt) * (SDMMC_SCSIID_MAX+1));
d178 1
a178 1
		FREE(scbus->sc_tgt, M_DEVBUF);
d181 1
a181 1
	FREE(scbus, M_DEVBUF);
@


1.6
log
@dont pass a copy of sdmmcs scsi_link struct on the stack to the midlayer.
it triggered a panic on detach of the scsibus when it tried to use the
adapters scsi_link struct that was no longer there.

issue found by and this fix tested by pedro@@
ok krw@@ looks right deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.5 2006/08/23 16:34:56 pedro Exp $	*/
d98 1
d141 4
a144 2
	scbus->sc_child = config_found(&sc->sc_dev, &scbus->sc_link,
	    scsiprint);
@


1.5
log
@Protect scsi_done() with splbio(), discussed with and okay dlg@@, marco@@
and fgsch@@, uwe@@ time-out :(
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.4 2006/07/18 04:10:35 uwe Exp $	*/
a99 1
	struct sdmmc_attach_args saa;
d140 2
a141 11
	bzero(&saa, sizeof saa);
	bcopy(&scbus->sc_link, &saa.scsi_link, sizeof saa.scsi_link);

	/*
	 * Set saa.sf to something, so that SDIO drivers don't need a
	 * special case to weed out memory cards.
	 */
	saa.sf = sc->sc_fn0 != NULL ? sc->sc_fn0 :
	    SIMPLEQ_FIRST(&sc->sf_head);

	scbus->sc_child = config_found(&sc->sc_dev, &saa, scsiprint);
@


1.4
log
@First and foremost, avoid an obious race between two or more processes
trying to get MMC commands through to the SD/MMC host controller via the
emulated SCSI layer.  This is achieved by ensuring exclusive access to
the host controller for one process during any MMC command and during a
sequence of commands at the sdmmc(4) layer.

While at it, the command processing thread has been moved to sdmmc(4),
so as to simplify the implementation of future host controller drivers.
This should also pave the way for further cleanup of the code and for
new drivers.

Minor cleanups are included in this commit, as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.3 2006/06/01 21:53:41 uwe Exp $	*/
d307 1
d316 1
d318 1
d347 1
d349 1
d362 1
d364 1
d371 1
d373 1
d385 1
d387 1
d395 1
d397 1
@


1.3
log
@SDIO card identification
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.2 2006/05/28 18:45:23 uwe Exp $	*/
d19 1
a19 1
/* A SCSI bus emulation to access SD/MMC memory cards. */
d23 1
d25 1
d38 42
d81 4
a84 3
int	sdmmc_start_xs(struct sdmmc_softc *, struct scsi_xfer *);
int	sdmmc_done_xs(struct sdmmc_softc *, struct scsi_xfer *);
void	sdmmc_complete(struct sdmmc_softc *, struct scsi_xfer *);
d87 2
d123 6
d144 7
d152 12
d170 2
d174 9
d190 1
d195 100
d304 3
d311 1
a311 1
		    SDMMCDEVNAME(sc), link->target));
d319 3
a321 3
	DPRINTF(("%s: sdmmc_scsi_cmd: target=%d xs=%p cmd=%#x "
	    "datalen=%d (poll=%d)\n", SDMMCDEVNAME(sc), link->target,
	    xs, xs->cmd->opcode, xs->datalen, xs->flags & SCSI_POLL));
a359 1

d362 21
a382 1
		    SDMMCDEVNAME(sc), xs->cmd->opcode));
d388 2
a389 1
	/* XXX check bounds */
d391 4
a394 1
	return sdmmc_start_xs(sc, xs);
d398 1
a398 1
sdmmc_start_xs(struct sdmmc_softc *sc, struct scsi_xfer *xs)
d400 20
a419 2
	sdmmc_complete(sc, xs);
	return COMPLETE;
d423 1
a423 1
sdmmc_complete(struct sdmmc_softc *sc, struct scsi_xfer *xs)
d425 2
d428 1
a430 4
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
	u_int32_t blockno;
	u_int32_t blockcnt;
d432 1
d434 5
a438 11
	/* A read or write operation. */
	/* XXX move to some sort of "scsi emulation layer". */
	if (xs->cmdlen == 6) {
		rw = (struct scsi_rw *)xs->cmd;
		blockno = _3btol(rw->addr) & (SRW_TOPADDR << 16 | 0xffff);
		blockcnt = rw->length ? rw->length : 0x100;
	} else {
		rwb = (struct scsi_rw_big *)xs->cmd;
		blockno = _4btol(rwb->addr);
		blockcnt = _2btol(rwb->length);
	}
d441 2
a442 2
		error = sdmmc_mem_read_block(sc, tgt->card, blockno,
		    xs->data, blockcnt * DEV_BSIZE);
d444 3
a446 2
		error = sdmmc_mem_write_block(sc, tgt->card, blockno,
		    xs->data, blockcnt * DEV_BSIZE);
d450 20
d471 5
a475 1
	xs->resid = 0;
d477 15
@


1.2
log
@don't #undef SDMMC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_scsi.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d52 2
a53 1
	struct sdmmc_card *cs;
d69 1
a69 1
	SIMPLEQ_FOREACH(cs, &sc->cs_head, cs_list) {
d72 1
a72 1
		scbus->sc_tgt[scbus->sc_ntargets].card = cs;
d88 4
a91 2
	scbus->sc_child = config_found(&sc->sc_dev, &scbus->sc_link,
	    scsiprint);
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a31 2

#undef SDMMC_DEBUG
@

