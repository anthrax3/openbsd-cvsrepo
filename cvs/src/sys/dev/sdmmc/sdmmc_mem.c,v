head	1.29;
access;
symbols
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.2
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.21.0.4
	OPENBSD_5_8_BASE:1.21
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.4
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.18.0.4
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.16.0.12
	OPENBSD_5_4_BASE:1.16
	OPENBSD_5_3:1.16.0.10
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.8
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.6
	OPENBSD_5_0:1.16.0.4
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.2
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.14.0.4
	OPENBSD_4_8_BASE:1.14
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.7.0.6
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.4
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.2
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.2
	OPENBSD_4_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.29
date	2016.05.05.20.40.48;	author kettenis;	state Exp;
branches;
next	1.28;
commitid	dGQ3HEYdXc0TldZ2;

1.28
date	2016.05.05.11.01.08;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	tXZ4cDDS7O2NIM1F;

1.27
date	2016.05.04.09.30.06;	author kettenis;	state Exp;
branches;
next	1.26;
commitid	nKwnMLLuwctt5XwF;

1.26
date	2016.05.01.18.29.44;	author kettenis;	state Exp;
branches;
next	1.25;
commitid	oONNV7TyLsILUk2X;

1.25
date	2016.05.01.17.18.43;	author kettenis;	state Exp;
branches;
next	1.24;
commitid	vppYY9eNbkZcN61t;

1.24
date	2016.05.01.16.04.39;	author kettenis;	state Exp;
branches;
next	1.23;
commitid	rwmsBKqrjX2EodCO;

1.23
date	2016.04.30.11.32.23;	author kettenis;	state Exp;
branches;
next	1.22;
commitid	idV1JJlqFozdGODX;

1.22
date	2015.11.08.12.10.27;	author jsg;	state Exp;
branches;
next	1.21;
commitid	ZOkOru2dOZMywTcS;

1.21
date	2015.04.22.04.02.06;	author jsg;	state Exp;
branches;
next	1.20;
commitid	hTQTfjRu9uwv5kDM;

1.20
date	2014.09.23.12.08.13;	author rapha;	state Exp;
branches;
next	1.19;
commitid	CG5qfXvwwHTMHz9r;

1.19
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.18;
commitid	OBNa5kfxQ2UXoiIw;

1.18
date	2013.10.22.16.49.27;	author syl;	state Exp;
branches;
next	1.17;

1.17
date	2013.09.12.11.54.04;	author rapha;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.24.14.52.23;	author blambert;	state Exp;
branches;
next	1.15;

1.15
date	2010.08.19.17.54.12;	author jasper;	state Exp;
branches;
next	1.14;

1.14
date	2010.02.10.23.33.08;	author drahn;	state Exp;
branches;
next	1.13;

1.13
date	2009.10.03.18.42.36;	author kettenis;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.07.16.35.52;	author blambert;	state Exp;
branches;
next	1.11;

1.11
date	2009.02.20.19.16.35;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2009.01.09.10.55.22;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2008.12.02.23.49.54;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2008.11.24.07.32.08;	author blambert;	state Exp;
branches;
next	1.7;

1.7
date	2007.03.18.22.07.16;	author uwe;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.29.14.16.43;	author uwe;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.18.04.10.35;	author uwe;	state Exp;
branches;
next	1.4;

1.4
date	2006.06.29.01.40.51;	author uwe;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.01.21.53.41;	author uwe;	state Exp;
branches;
next	1.2;

1.2
date	2006.05.28.18.45.23;	author uwe;	state Exp;
branches;
next	1.1;

1.1
date	2006.05.28.17.21.14;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Bump up the clock to 25 MHz before trying to read the SCR register of an SD
card.  Data transfers don't seem to work on the Realtek RTS5229 Card Reader
if the clock frequency is too low, and reading the SCR requires a data
transfer.
@
text
@/*	$OpenBSD: sdmmc_mem.c,v 1.28 2016/05/05 11:01:08 kettenis Exp $	*/

/*
 * Copyright (c) 2006 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Routines for SD/MMC memory cards. */

#include <sys/param.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/systm.h>

#include <dev/sdmmc/sdmmcchip.h>
#include <dev/sdmmc/sdmmcreg.h>
#include <dev/sdmmc/sdmmcvar.h>

typedef struct { uint32_t _bits[512/32]; } __packed __aligned(4) sdmmc_bitfield512_t;

void	sdmmc_be512_to_bitfield512(sdmmc_bitfield512_t *);

int	sdmmc_decode_csd(struct sdmmc_softc *, sdmmc_response,
	    struct sdmmc_function *);
int	sdmmc_decode_cid(struct sdmmc_softc *, sdmmc_response,
	    struct sdmmc_function *);
void	sdmmc_print_cid(struct sdmmc_cid *);

int	sdmmc_mem_send_op_cond(struct sdmmc_softc *, u_int32_t, u_int32_t *);
int	sdmmc_mem_set_blocklen(struct sdmmc_softc *, struct sdmmc_function *);

int	sdmmc_mem_send_scr(struct sdmmc_softc *, uint32_t *);
int	sdmmc_mem_decode_scr(struct sdmmc_softc *, uint32_t *,
	    struct sdmmc_function *);

int	sdmmc_mem_send_cxd_data(struct sdmmc_softc *, int, void *, size_t);
int	sdmmc_set_bus_width(struct sdmmc_function *, int);
int	sdmmc_mem_mmc_switch(struct sdmmc_function *, uint8_t, uint8_t, uint8_t);

int	sdmmc_mem_sd_init(struct sdmmc_softc *, struct sdmmc_function *);
int	sdmmc_mem_mmc_init(struct sdmmc_softc *, struct sdmmc_function *);
int	sdmmc_mem_single_read_block(struct sdmmc_function *, int, u_char *,
	size_t);
int	sdmmc_mem_read_block_subr(struct sdmmc_function *, bus_dmamap_t,
	int, u_char *, size_t);
int	sdmmc_mem_single_write_block(struct sdmmc_function *, int, u_char *,
	size_t);
int	sdmmc_mem_write_block_subr(struct sdmmc_function *, bus_dmamap_t,
	int, u_char *, size_t);

#ifdef SDMMC_DEBUG
#define DPRINTF(s)	printf s
#else
#define DPRINTF(s)	/**/
#endif

/*
 * Initialize SD/MMC memory cards and memory in SDIO "combo" cards.
 */
int
sdmmc_mem_enable(struct sdmmc_softc *sc)
{
	u_int32_t host_ocr;
	u_int32_t card_ocr;

	rw_assert_wrlock(&sc->sc_lock);

	/* Set host mode to SD "combo" card or SD memory-only. */
	SET(sc->sc_flags, SMF_SD_MODE|SMF_MEM_MODE);

	/* Reset memory (*must* do that before CMD55 or CMD1). */
	sdmmc_go_idle_state(sc);

	/*
	 * Read the SD/MMC memory OCR value by issuing CMD55 followed
	 * by ACMD41 to read the OCR value from memory-only SD cards.
	 * MMC cards will not respond to CMD55 or ACMD41 and this is
	 * how we distinguish them from SD cards.
	 */
 mmc_mode:
	if (sdmmc_mem_send_op_cond(sc, 0, &card_ocr) != 0) {
		if (ISSET(sc->sc_flags, SMF_SD_MODE) &&
		    !ISSET(sc->sc_flags, SMF_IO_MODE)) {
			/* Not a SD card, switch to MMC mode. */
			CLR(sc->sc_flags, SMF_SD_MODE);
			goto mmc_mode;
		}
		if (!ISSET(sc->sc_flags, SMF_SD_MODE)) {
			DPRINTF(("%s: can't read memory OCR\n",
			    DEVNAME(sc)));
			return 1;
		} else {
			/* Not a "combo" card. */
			CLR(sc->sc_flags, SMF_MEM_MODE);
			return 0;
		}
	}

	/* Set the lowest voltage supported by the card and host. */
	host_ocr = sdmmc_chip_host_ocr(sc->sct, sc->sch);
	if (sdmmc_set_bus_power(sc, host_ocr, card_ocr) != 0) {
		DPRINTF(("%s: can't supply voltage requested by card\n",
		    DEVNAME(sc)));
		return 1;
	}

	/* Tell the card(s) to enter the idle state (again). */
	sdmmc_go_idle_state(sc);

	host_ocr &= card_ocr; /* only allow the common voltages */

	if (sdmmc_send_if_cond(sc, card_ocr) == 0)
		host_ocr |= SD_OCR_SDHC_CAP;

	/* Send the new OCR value until all cards are ready. */
	if (sdmmc_mem_send_op_cond(sc, host_ocr, NULL) != 0) {
		DPRINTF(("%s: can't send memory OCR\n", DEVNAME(sc)));
		return 1;
	}
	return 0;
}

/*
 * Read the CSD and CID from all cards and assign each card a unique
 * relative card address (RCA).  CMD2 is ignored by SDIO-only cards.
 */
void
sdmmc_mem_scan(struct sdmmc_softc *sc)
{
	struct sdmmc_command cmd;
	struct sdmmc_function *sf;
	u_int16_t next_rca;
	int error;
	int i;

	rw_assert_wrlock(&sc->sc_lock);

	/*
	 * CMD2 is a broadcast command understood by SD cards and MMC
	 * cards.  All cards begin to respond to the command, but back
	 * off if another card drives the CMD line to a different level.
	 * Only one card will get its entire response through.  That
	 * card remains silent once it has been assigned a RCA.
	 */
	for (i = 0; i < 100; i++) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_ALL_SEND_CID;
		cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R2;

		error = sdmmc_mmc_command(sc, &cmd);
		if (error == ETIMEDOUT) {
			/* No more cards there. */
			break;
		} else if (error != 0) {
			DPRINTF(("%s: can't read CID\n", DEVNAME(sc)));
			break;
		}

		/* In MMC mode, find the next available RCA. */
		next_rca = 1;
		if (!ISSET(sc->sc_flags, SMF_SD_MODE))
			SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list)
				next_rca++;

		/* Allocate a sdmmc_function structure. */
		sf = sdmmc_function_alloc(sc);
		sf->rca = next_rca;

		/*
		 * Remember the CID returned in the CMD2 response for
		 * later decoding.
		 */
		bcopy(cmd.c_resp, sf->raw_cid, sizeof sf->raw_cid);

		/*
		 * Silence the card by assigning it a unique RCA, or
		 * querying it for its RCA in the case of SD.
		 */
		if (sdmmc_set_relative_addr(sc, sf) != 0) {
			printf("%s: can't set mem RCA\n", DEVNAME(sc));
			sdmmc_function_free(sf);
			break;
		}

#if 0
		/* Verify that the RCA has been set by selecting the card. */
		if (sdmmc_select_card(sc, sf) != 0) {
			printf("%s: can't select mem RCA %d\n",
			    DEVNAME(sc), sf->rca);
			sdmmc_function_free(sf);
			break;
		}

		/* Deselect. */
		(void)sdmmc_select_card(sc, NULL);
#endif

		/*
		 * If this is a memory-only card, the card responding
		 * first becomes an alias for SDIO function 0.
		 */
		if (sc->sc_fn0 == NULL)
			sc->sc_fn0 = sf;

		SIMPLEQ_INSERT_TAIL(&sc->sf_head, sf, sf_list);
	}

	/*
	 * All cards are either inactive or awaiting further commands.
	 * Read the CSDs and decode the raw CID for each card.
	 */
	SIMPLEQ_FOREACH(sf, &sc->sf_head, sf_list) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_SEND_CSD;
		cmd.c_arg = MMC_ARG_RCA(sf->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R2;

		if (sdmmc_mmc_command(sc, &cmd) != 0) {
			SET(sf->flags, SFF_ERROR);
			continue;
		}

		if (sdmmc_decode_csd(sc, cmd.c_resp, sf) != 0 ||
		    sdmmc_decode_cid(sc, sf->raw_cid, sf) != 0) {
			SET(sf->flags, SFF_ERROR);
			continue;
		}

#ifdef SDMMC_DEBUG
		printf("%s: CID: ", DEVNAME(sc));
		sdmmc_print_cid(&sf->cid);
#endif
	}
}

int
sdmmc_decode_csd(struct sdmmc_softc *sc, sdmmc_response resp,
    struct sdmmc_function *sf)
{
	struct sdmmc_csd *csd = &sf->csd;

	if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
		/*
		 * CSD version 1.0 corresponds to SD system
		 * specification version 1.0 - 1.10. (SanDisk, 3.5.3)
		 */
		csd->csdver = SD_CSD_CSDVER(resp);
		switch (csd->csdver) {
		case SD_CSD_CSDVER_2_0:
			sf->flags |= SFF_SDHC;
			csd->capacity = SD_CSD_V2_CAPACITY(resp);
			csd->read_bl_len = SD_CSD_V2_BL_LEN;
			break;
		case SD_CSD_CSDVER_1_0:
			csd->capacity = SD_CSD_CAPACITY(resp);
			csd->read_bl_len = SD_CSD_READ_BL_LEN(resp);
			break;
		default:
			printf("%s: unknown SD CSD structure version 0x%x\n",
			    DEVNAME(sc), csd->csdver);
			return 1;
			break;
		}
		csd->ccc = SD_CSD_CCC(resp);
	} else {
		csd->csdver = MMC_CSD_CSDVER(resp);
		if (csd->csdver == MMC_CSD_CSDVER_1_0 ||
		    csd->csdver == MMC_CSD_CSDVER_2_0 ||
		    csd->csdver == MMC_CSD_CSDVER_EXT_CSD) {
			csd->mmcver = MMC_CSD_MMCVER(resp);
			csd->capacity = MMC_CSD_CAPACITY(resp);
			csd->read_bl_len = MMC_CSD_READ_BL_LEN(resp);
		} else {
			printf("%s: unknown MMC CSD structure version 0x%x\n",
			    DEVNAME(sc), csd->csdver);
			return 1;
		}
	}
	csd->sector_size = MIN(1 << csd->read_bl_len,
	    sdmmc_chip_host_maxblklen(sc->sct, sc->sch));
	if (csd->sector_size < (1<<csd->read_bl_len))
		csd->capacity *= (1<<csd->read_bl_len) /
		    csd->sector_size;

	return 0;
}

int
sdmmc_decode_cid(struct sdmmc_softc *sc, sdmmc_response resp,
    struct sdmmc_function *sf)
{
	struct sdmmc_cid *cid = &sf->cid;

	if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
		cid->mid = SD_CID_MID(resp);
		cid->oid = SD_CID_OID(resp);
		SD_CID_PNM_CPY(resp, cid->pnm);
		cid->rev = SD_CID_REV(resp);
		cid->psn = SD_CID_PSN(resp);
		cid->mdt = SD_CID_MDT(resp);
	} else {
		switch(sf->csd.mmcver) {
		case MMC_CSD_MMCVER_1_0:
		case MMC_CSD_MMCVER_1_4:
			cid->mid = MMC_CID_MID_V1(resp);
			MMC_CID_PNM_V1_CPY(resp, cid->pnm);
			cid->rev = MMC_CID_REV_V1(resp);
			cid->psn = MMC_CID_PSN_V1(resp);
			cid->mdt = MMC_CID_MDT_V1(resp);
			break;
		case MMC_CSD_MMCVER_2_0:
		case MMC_CSD_MMCVER_3_1:
		case MMC_CSD_MMCVER_4_0:
			cid->mid = MMC_CID_MID_V2(resp);
			cid->oid = MMC_CID_OID_V2(resp);
			MMC_CID_PNM_V2_CPY(resp, cid->pnm);
			cid->psn = MMC_CID_PSN_V2(resp);
			break;
		default:
			printf("%s: unknown MMC version %d\n",
			    DEVNAME(sc), sf->csd.mmcver);
			return 1;
		}
	}
	return 0;
}

#ifdef SDMMC_DEBUG
void
sdmmc_print_cid(struct sdmmc_cid *cid)
{
	printf("mid=0x%02x oid=0x%04x pnm=\"%s\" rev=0x%02x psn=0x%08x"
	    " mdt=%03x\n", cid->mid, cid->oid, cid->pnm, cid->rev, cid->psn,
	    cid->mdt);
}
#endif

int
sdmmc_mem_send_scr(struct sdmmc_softc *sc, uint32_t *scr)
{
	struct sdmmc_command cmd;
	void *ptr = NULL;
	int datalen = 8;
	int error = 0;

	ptr = malloc(datalen, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ptr == NULL)
		goto out;

	memset(&cmd, 0, sizeof(cmd));
	cmd.c_data = ptr;
	cmd.c_datalen = datalen;
	cmd.c_blklen = datalen;
	cmd.c_arg = 0;
	cmd.c_flags = SCF_CMD_ADTC | SCF_CMD_READ | SCF_RSP_R1;
	cmd.c_opcode = SD_APP_SEND_SCR;

	error = sdmmc_app_command(sc, &cmd);
	if (error == 0)
		memcpy(scr, ptr, datalen);

out:
	if (ptr != NULL)
		free(ptr, M_DEVBUF, datalen);

	return error;
}

int
sdmmc_mem_decode_scr(struct sdmmc_softc *sc, uint32_t *raw_scr,
    struct sdmmc_function *sf)
{
	sdmmc_response resp;
	int ver;

	memset(resp, 0, sizeof(resp));
	/*
	 * Change the raw SCR to a response.
	 */
	resp[0] = be32toh(raw_scr[1]) >> 8;		// LSW
	resp[1] = be32toh(raw_scr[0]);			// MSW
	resp[0] |= (resp[1] & 0xff) << 24;
	resp[1] >>= 8;

	ver = SCR_STRUCTURE(resp);
	sf->scr.sd_spec = SCR_SD_SPEC(resp);
	sf->scr.bus_width = SCR_SD_BUS_WIDTHS(resp);

	DPRINTF(("%s: %s: %08x%08x ver=%d, spec=%d, bus width=%d\n",
	    DEVNAME(sc), __func__, resp[1], resp[0],
	    ver, sf->scr.sd_spec, sf->scr.bus_width));

	if (ver != 0) {
		DPRINTF(("%s: unknown SCR structure version: %d\n",
		    DEVNAME(sc), ver));
		return EINVAL;
	}
	return 0;
}

int
sdmmc_mem_send_cxd_data(struct sdmmc_softc *sc, int opcode, void *data,
    size_t datalen)
{
	struct sdmmc_command cmd;
	void *ptr = NULL;
	int error = 0;

	ptr = malloc(datalen, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ptr == NULL) {
		error = ENOMEM;
		goto out;
	}

	memset(&cmd, 0, sizeof(cmd));
	cmd.c_data = ptr;
	cmd.c_datalen = datalen;
	cmd.c_blklen = datalen;
	cmd.c_opcode = opcode;
	cmd.c_arg = 0;
	cmd.c_flags = SCF_CMD_ADTC | SCF_CMD_READ;
	if (opcode == MMC_SEND_EXT_CSD)
		SET(cmd.c_flags, SCF_RSP_R1);
	else
		SET(cmd.c_flags, SCF_RSP_R2);

	error = sdmmc_mmc_command(sc, &cmd);
	if (error == 0)
		memcpy(data, ptr, datalen);

out:
	if (ptr != NULL)
		free(ptr, M_DEVBUF, 0);

	return error;
}

int
sdmmc_set_bus_width(struct sdmmc_function *sf, int width)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;
	int error;

	memset(&cmd, 0, sizeof(cmd));
	cmd.c_opcode = SD_APP_SET_BUS_WIDTH;
	cmd.c_flags = SCF_RSP_R1 | SCF_CMD_AC;

	switch (width) {
	case 1:
		cmd.c_arg = SD_ARG_BUS_WIDTH_1;
		break;

	case 4:
		cmd.c_arg = SD_ARG_BUS_WIDTH_4;
		break;

	default:
		return EINVAL;
	}

	error = sdmmc_app_command(sc, &cmd);
	if (error == 0)
		error = sdmmc_chip_bus_width(sc->sct, sc->sch, width);
	return error;
}

int
sdmmc_mem_sd_switch(struct sdmmc_function *sf, int mode, int group,
    int function, sdmmc_bitfield512_t *status)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;
	void *ptr = NULL;
	int gsft, error = 0;
	const int statlen = 64;

	if (sf->scr.sd_spec >= SCR_SD_SPEC_VER_1_10 &&
	    !ISSET(sf->csd.ccc, SD_CSD_CCC_SWITCH))
		return EINVAL;

	if (group <= 0 || group > 6 ||
	    function < 0 || function > 15)
		return EINVAL;

	gsft = (group - 1) << 2;

	ptr = malloc(statlen, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (ptr == NULL)
		goto out;

	memset(&cmd, 0, sizeof(cmd));
	cmd.c_data = ptr;
	cmd.c_datalen = statlen;
	cmd.c_blklen = statlen;
	cmd.c_opcode = SD_SEND_SWITCH_FUNC;
	cmd.c_arg =
	    (!!mode << 31) | (function << gsft) | (0x00ffffff & ~(0xf << gsft));
	cmd.c_flags = SCF_CMD_ADTC | SCF_CMD_READ | SCF_RSP_R1;

	error = sdmmc_mmc_command(sc, &cmd);
	if (error == 0)
		memcpy(status, ptr, statlen);

out:
	if (ptr != NULL)
		free(ptr, M_DEVBUF, statlen);

	if (error == 0)
		sdmmc_be512_to_bitfield512(status);

	return error;
}

int
sdmmc_mem_mmc_switch(struct sdmmc_function *sf, uint8_t set, uint8_t index,
    uint8_t value)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;

	memset(&cmd, 0, sizeof(cmd));
	cmd.c_opcode = MMC_SWITCH;
	cmd.c_arg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
	    (index << 16) | (value << 8) | set;
	cmd.c_flags = SCF_RSP_R1B | SCF_CMD_AC;

	return sdmmc_mmc_command(sc, &cmd);
}

/*
 * Initialize a SD/MMC memory card.
 */
int
sdmmc_mem_init(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	int error = 0;

	rw_assert_wrlock(&sc->sc_lock);

	if (sdmmc_select_card(sc, sf) != 0 ||
	    sdmmc_mem_set_blocklen(sc, sf) != 0)
		error = 1;

	if (ISSET(sc->sc_flags, SMF_SD_MODE))
		error = sdmmc_mem_sd_init(sc, sf);
	else
		error = sdmmc_mem_mmc_init(sc, sf);

	return error;
}

/* make 512-bit BE quantity __bitfield()-compatible */
void
sdmmc_be512_to_bitfield512(sdmmc_bitfield512_t *buf) {
	size_t i;
	uint32_t tmp0, tmp1;
	const size_t bitswords = nitems(buf->_bits);
	for (i = 0; i < bitswords/2; i++) {
		tmp0 = buf->_bits[i];
		tmp1 = buf->_bits[bitswords - 1 - i];
		buf->_bits[i] = be32toh(tmp1);
		buf->_bits[bitswords - 1 - i] = be32toh(tmp0);
	}
}

int
sdmmc_mem_sd_init(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	int support_func, best_func, error;
	sdmmc_bitfield512_t status; /* Switch Function Status */
	uint32_t raw_scr[2];

	/*
	 * All SD cards are supposed to support Default Speed mode
	 * with frequencies up to 25 MHz.  Bump up the clock frequency
	 * now as data transfers don't seem to work on the Realtek
	 * RTS5229 host controller if it is running at a low clock
	 * frequency.  Reading the SCR requires a data transfer.
	 */
	error = sdmmc_chip_bus_clock(sc->sct, sc->sch, SDMMC_SDCLK_25MHZ,
	    SDMMC_TIMING_LEGACY);
	if (error) {
		printf("%s: can't change bus clock\n", DEVNAME(sc));
		return error;
	}

	error = sdmmc_mem_send_scr(sc, raw_scr);
	if (error) {
		printf("%s: SD_SEND_SCR send failed\n", DEVNAME(sc));
		return error;
	}
	error = sdmmc_mem_decode_scr(sc, raw_scr, sf);
	if (error)
		return error;

	if (ISSET(sc->sc_caps, SMC_CAPS_4BIT_MODE) &&
	    ISSET(sf->scr.bus_width, SCR_SD_BUS_WIDTHS_4BIT)) {
		DPRINTF(("%s: change bus width\n", DEVNAME(sc)));
		error = sdmmc_set_bus_width(sf, 4);
		if (error) {
			printf("%s: can't change bus width\n", DEVNAME(sc));
			return error;
		}
	}

	best_func = 0;
	if (sf->scr.sd_spec >= SCR_SD_SPEC_VER_1_10 &&
	    ISSET(sf->csd.ccc, SD_CSD_CCC_SWITCH)) {
		DPRINTF(("%s: switch func mode 0\n", DEVNAME(sc)));
		error = sdmmc_mem_sd_switch(sf, 0, 1, 0, &status);
		if (error) {
			printf("%s: switch func mode 0 failed\n", DEVNAME(sc));
			return error;
		}

		support_func = SFUNC_STATUS_GROUP(&status, 1);

		if (support_func & (1 << SD_ACCESS_MODE_SDR25))
			best_func = 1;
	}

	if (best_func != 0) {
		DPRINTF(("%s: switch func mode 1(func=%d)\n",
		    DEVNAME(sc), best_func));
		error =
		    sdmmc_mem_sd_switch(sf, 1, 1, best_func, &status);
		if (error) {
			printf("%s: switch func mode 1 failed:"
			    " group 1 function %d(0x%2x)\n",
			    DEVNAME(sc), best_func, support_func);
			return error;
		}

		/* Wait 400KHz x 8 clock (2.5us * 8 + slop) */
		delay(25);

		/* High Speed mode, Frequency up to 50MHz. */
		error = sdmmc_chip_bus_clock(sc->sct, sc->sch,
		    SDMMC_SDCLK_50MHZ, SDMMC_TIMING_HIGHSPEED);
		if (error) {
			printf("%s: can't change bus clock\n", DEVNAME(sc));
			return error;
		}
	}

	return 0;
}

int
sdmmc_mem_mmc_init(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	int width, value;
	int card_type;
	int error = 0;
	u_int8_t ext_csd[512];
	int speed = 20000;
	int timing = SDMMC_TIMING_LEGACY;
	u_int32_t sectors = 0;

	if (sf->csd.mmcver >= MMC_CSD_MMCVER_4_0) {
		/* read EXT_CSD */
		error = sdmmc_mem_send_cxd_data(sc,
		    MMC_SEND_EXT_CSD, ext_csd, sizeof(ext_csd));
		if (error != 0) {
			SET(sf->flags, SFF_ERROR);
			printf("%s: can't read EXT_CSD\n", DEVNAME(sc));
			return error;
		}

		card_type = ext_csd[EXT_CSD_CARD_TYPE];

		if (card_type & EXT_CSD_CARD_TYPE_F_52M_1_8V &&
		    ISSET(sc->sc_caps, SMC_CAPS_MMC_DDR52)) {
			speed = 52000;
			timing = SDMMC_TIMING_MMC_DDR52;
		} else if (card_type & EXT_CSD_CARD_TYPE_F_52M &&
		    ISSET(sc->sc_caps, SMC_CAPS_MMC_HIGHSPEED)) {
			speed = 52000;
			timing = SDMMC_TIMING_HIGHSPEED;
		} else if (card_type & EXT_CSD_CARD_TYPE_F_26M) {
			speed = 26000;
		} else {
			printf("%s: unknown CARD_TYPE 0x%x\n", DEVNAME(sc),
			    ext_csd[EXT_CSD_CARD_TYPE]);
		}

		if (timing != SDMMC_TIMING_LEGACY) {
			/* switch to high speed timing */
			error = sdmmc_mem_mmc_switch(sf, EXT_CSD_CMD_SET_NORMAL,
			    EXT_CSD_HS_TIMING, EXT_CSD_HS_TIMING_HS);
			if (error != 0) {
				printf("%s: can't change high speed\n",
				    DEVNAME(sc));
				return error;
			}

			sdmmc_delay(10000);
		}

		error = sdmmc_chip_bus_clock(sc->sct, sc->sch, speed, SDMMC_TIMING_HIGHSPEED);
		if (error != 0) {
			printf("%s: can't change bus clock\n", DEVNAME(sc));
			return error;
		}

		if (timing != SDMMC_TIMING_LEGACY) {
			/* read EXT_CSD again */
			error = sdmmc_mem_send_cxd_data(sc,
			    MMC_SEND_EXT_CSD, ext_csd, sizeof(ext_csd));
			if (error != 0) {
				printf("%s: can't re-read EXT_CSD\n", DEVNAME(sc));
				return error;
			}
			if (ext_csd[EXT_CSD_HS_TIMING] != EXT_CSD_HS_TIMING_HS) {
				printf("%s, HS_TIMING set failed\n", DEVNAME(sc));
				return EINVAL;
			}
		}

		if (ISSET(sc->sc_caps, SMC_CAPS_8BIT_MODE)) {
			width = 8;
			value = EXT_CSD_BUS_WIDTH_8;
		} else if (ISSET(sc->sc_caps, SMC_CAPS_4BIT_MODE)) {
			width = 4;
			value = EXT_CSD_BUS_WIDTH_4;
		} else {
			width = 1;
			value = EXT_CSD_BUS_WIDTH_1;
		}

		if (width != 1) {
			error = sdmmc_mem_mmc_switch(sf, EXT_CSD_CMD_SET_NORMAL,
			    EXT_CSD_BUS_WIDTH, value);
			if (error == 0)
				error = sdmmc_chip_bus_width(sc->sct,
				    sc->sch, width);
			else {
				DPRINTF(("%s: can't change bus width"
				    " (%d bit)\n", DEVNAME(sc), width));
				return error;
			}

			/* XXXX: need bus test? (using by CMD14 & CMD19) */
			sdmmc_delay(10000);
		}

		if (timing == SDMMC_TIMING_MMC_DDR52) {
			switch (width) {
			case 4:
				value = EXT_CSD_BUS_WIDTH_4_DDR;
				break;
			case 8:
				value = EXT_CSD_BUS_WIDTH_8_DDR;
				break;
			}

			error = sdmmc_mem_mmc_switch(sf, EXT_CSD_CMD_SET_NORMAL,
			    EXT_CSD_BUS_WIDTH, value);
			if (error) {
				printf("%s: can't switch to DDR\n",
				    DEVNAME(sc));
				return error;
			}

			sdmmc_delay(10000);

			error = sdmmc_chip_signal_voltage(sc->sct, sc->sch,
			    SDMMC_SIGNAL_VOLTAGE_180);
			if (error) {
				printf("%s: can't switch signalling voltage\n",
				    DEVNAME(sc));
				return error;
			}

			error = sdmmc_chip_bus_clock(sc->sct, sc->sch, speed, timing);
			if (error != 0) {
				printf("%s: can't change bus clock\n", DEVNAME(sc));
				return error;
			}

			sdmmc_delay(10000);
		}

		sectors = ext_csd[EXT_CSD_SEC_COUNT + 0] << 0 |
		    ext_csd[EXT_CSD_SEC_COUNT + 1] << 8  |
		    ext_csd[EXT_CSD_SEC_COUNT + 2] << 16 |
		    ext_csd[EXT_CSD_SEC_COUNT + 3] << 24;

		if (sectors > (2u * 1024 * 1024 * 1024) / 512) {
			sf->flags |= SFF_SDHC;
			sf->csd.capacity = sectors;
		}
	}

	return error;
}

/*
 * Get or set the card's memory OCR value (SD or MMC).
 */
int
sdmmc_mem_send_op_cond(struct sdmmc_softc *sc, u_int32_t ocr,
    u_int32_t *ocrp)
{
	struct sdmmc_command cmd;
	int error;
	int i;

	rw_assert_wrlock(&sc->sc_lock);

	/*
	 * If we change the OCR value, retry the command until the OCR
	 * we receive in response has the "CARD BUSY" bit set, meaning
	 * that all cards are ready for identification.
	 */
	for (i = 0; i < 100; i++) {
		bzero(&cmd, sizeof cmd);
		cmd.c_arg = ocr;
		cmd.c_flags = SCF_CMD_BCR | SCF_RSP_R3;

		if (ISSET(sc->sc_flags, SMF_SD_MODE)) {
			cmd.c_opcode = SD_APP_OP_COND;
			error = sdmmc_app_command(sc, &cmd);
		} else {
			cmd.c_arg &= ~MMC_OCR_ACCESS_MODE_MASK;
			cmd.c_arg |= MMC_OCR_SECTOR_MODE;
			cmd.c_opcode = MMC_SEND_OP_COND;
			error = sdmmc_mmc_command(sc, &cmd);
		}
		if (error != 0)
			break;
		if (ISSET(MMC_R3(cmd.c_resp), MMC_OCR_MEM_READY) ||
		    ocr == 0)
			break;
		error = ETIMEDOUT;
		sdmmc_delay(10000);
	}
	if (error == 0 && ocrp != NULL)
		*ocrp = MMC_R3(cmd.c_resp);

	return error;
}

/*
 * Set the read block length appropriately for this card, according to
 * the card CSD register value.
 */
int
sdmmc_mem_set_blocklen(struct sdmmc_softc *sc, struct sdmmc_function *sf)
{
	struct sdmmc_command cmd;

	rw_assert_wrlock(&sc->sc_lock);

	bzero(&cmd, sizeof cmd);
	cmd.c_opcode = MMC_SET_BLOCKLEN;
	cmd.c_arg = sf->csd.sector_size;
	cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;
	DPRINTF(("%s: read_bl_len=%d sector_size=%d\n", DEVNAME(sc),
	    1 << sf->csd.read_bl_len, sf->csd.sector_size));

	return sdmmc_mmc_command(sc, &cmd);
}

int
sdmmc_mem_read_block_subr(struct sdmmc_function *sf, bus_dmamap_t dmap,
    int blkno, u_char *data, size_t datalen)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;
	int error;


	if ((error = sdmmc_select_card(sc, sf)) != 0)
		goto err;

	bzero(&cmd, sizeof cmd);
	cmd.c_data = data;
	cmd.c_datalen = datalen;
	cmd.c_blklen = sf->csd.sector_size;
	cmd.c_opcode = (datalen / cmd.c_blklen) > 1 ?
	    MMC_READ_BLOCK_MULTIPLE : MMC_READ_BLOCK_SINGLE;
	if (sf->flags & SFF_SDHC)
		cmd.c_arg = blkno;
	else
		cmd.c_arg = blkno << 9;
	cmd.c_flags = SCF_CMD_ADTC | SCF_CMD_READ | SCF_RSP_R1;
	cmd.c_dmamap = dmap;

	error = sdmmc_mmc_command(sc, &cmd);
	if (error != 0)
		goto err;

	if (ISSET(sc->sc_flags, SMF_STOP_AFTER_MULTIPLE) &&
	    cmd.c_opcode == MMC_READ_BLOCK_MULTIPLE) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_STOP_TRANSMISSION;
		cmd.c_arg = MMC_ARG_RCA(sf->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1B;
		error = sdmmc_mmc_command(sc, &cmd);
		if (error != 0)
			goto err;
	}

	do {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_SEND_STATUS;
		cmd.c_arg = MMC_ARG_RCA(sf->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;
		error = sdmmc_mmc_command(sc, &cmd);
		if (error != 0)
			break;
		/* XXX time out */
	} while (!ISSET(MMC_R1(cmd.c_resp), MMC_R1_READY_FOR_DATA));

err:
	return (error);
}

int
sdmmc_mem_single_read_block(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
{
	int error = 0;
	int i;

	for (i = 0; i < datalen / sf->csd.sector_size; i++) {
		error = sdmmc_mem_read_block_subr(sf, NULL,  blkno + i,
		    data + i * sf->csd.sector_size, sf->csd.sector_size);
		if (error)
			break;
	}

	return (error);
}

int
sdmmc_mem_read_block(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
{
	struct sdmmc_softc *sc = sf->sc;
	int error;

	rw_enter_write(&sc->sc_lock);

	if (ISSET(sc->sc_caps, SMC_CAPS_SINGLE_ONLY)) {
		error = sdmmc_mem_single_read_block(sf, blkno, data, datalen);
		goto out;
	}

	if (!ISSET(sc->sc_caps, SMC_CAPS_DMA)) {
		error = sdmmc_mem_read_block_subr(sf, NULL, blkno,
		    data, datalen);
		goto out;
	}

	/* DMA transfer */
	error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmap, data, datalen,
	    NULL, BUS_DMA_NOWAIT|BUS_DMA_READ);
	if (error)
		goto out;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmap, 0, datalen,
	    BUS_DMASYNC_PREREAD);

	error = sdmmc_mem_read_block_subr(sf, sc->sc_dmap, blkno, data,
	    datalen);
	if (error)
		goto unload;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmap, 0, datalen,
	    BUS_DMASYNC_POSTREAD);
unload:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmap);

out:
	rw_exit(&sc->sc_lock);
	return (error);
}

int
sdmmc_mem_write_block_subr(struct sdmmc_function *sf, bus_dmamap_t dmap,
    int blkno, u_char *data, size_t datalen)
{
	struct sdmmc_softc *sc = sf->sc;
	struct sdmmc_command cmd;
	int error;

	if ((error = sdmmc_select_card(sc, sf)) != 0)
		goto err;

	bzero(&cmd, sizeof cmd);
	cmd.c_data = data;
	cmd.c_datalen = datalen;
	cmd.c_blklen = sf->csd.sector_size;
	cmd.c_opcode = (datalen / cmd.c_blklen) > 1 ?
	    MMC_WRITE_BLOCK_MULTIPLE : MMC_WRITE_BLOCK_SINGLE;
	if (sf->flags & SFF_SDHC)
		cmd.c_arg = blkno;
	else
		cmd.c_arg = blkno << 9;
	cmd.c_flags = SCF_CMD_ADTC | SCF_RSP_R1;
	cmd.c_dmamap = dmap;

	error = sdmmc_mmc_command(sc, &cmd);
	if (error != 0)
		goto err;

	if (ISSET(sc->sc_flags, SMF_STOP_AFTER_MULTIPLE) &&
	    cmd.c_opcode == MMC_WRITE_BLOCK_MULTIPLE) {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_STOP_TRANSMISSION;
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1B;
		error = sdmmc_mmc_command(sc, &cmd);
		if (error != 0)
			goto err;
	}

	do {
		bzero(&cmd, sizeof cmd);
		cmd.c_opcode = MMC_SEND_STATUS;
		cmd.c_arg = MMC_ARG_RCA(sf->rca);
		cmd.c_flags = SCF_CMD_AC | SCF_RSP_R1;
		error = sdmmc_mmc_command(sc, &cmd);
		if (error != 0)
			break;
		/* XXX time out */
	} while (!ISSET(MMC_R1(cmd.c_resp), MMC_R1_READY_FOR_DATA));

err:
	return (error);
}

int
sdmmc_mem_single_write_block(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
{
	int error = 0;
	int i;

	for (i = 0; i < datalen / sf->csd.sector_size; i++) {
		error = sdmmc_mem_write_block_subr(sf, NULL, blkno + i,
		    data + i * sf->csd.sector_size, sf->csd.sector_size);
		if (error)
			break;
	}

	return (error);
}

int
sdmmc_mem_write_block(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
{
	struct sdmmc_softc *sc = sf->sc;
	int error;

	rw_enter_write(&sc->sc_lock);

	if (ISSET(sc->sc_caps, SMC_CAPS_SINGLE_ONLY)) {
		error = sdmmc_mem_single_write_block(sf, blkno, data, datalen);
		goto out;
	}

	if (!ISSET(sc->sc_caps, SMC_CAPS_DMA)) {
		error = sdmmc_mem_write_block_subr(sf, NULL, blkno,
		    data, datalen);
		goto out;
	}

	/* DMA transfer */
	error = bus_dmamap_load(sc->sc_dmat, sc->sc_dmap, data, datalen,
	    NULL, BUS_DMA_NOWAIT|BUS_DMA_WRITE);
	if (error)
		goto out;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmap, 0, datalen,
	    BUS_DMASYNC_PREWRITE);

	error = sdmmc_mem_write_block_subr(sf, sc->sc_dmap, blkno, data,
	    datalen);
	if (error)
		goto unload;

	bus_dmamap_sync(sc->sc_dmat, sc->sc_dmap, 0, datalen,
	    BUS_DMASYNC_POSTWRITE);
unload:
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmap);

out:
	rw_exit(&sc->sc_lock);
	return (error);
}
@


1.28
log
@Add Dual Data Rate support for eMMC at 52MHz.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.27 2016/05/04 09:30:06 kettenis Exp $	*/
d582 1
a582 1
	int support_func, best_func, bus_clock, timing, error;
d586 14
a619 2
	bus_clock = 25000;
	timing = SDMMC_TIMING_LEGACY;
d633 1
d635 14
a648 13
		if (best_func != 0) {
			DPRINTF(("%s: switch func mode 1(func=%d)\n",
			    DEVNAME(sc), best_func));
			error =
			    sdmmc_mem_sd_switch(sf, 1, 1, best_func, &status);
			if (error) {
				printf("%s: switch func mode 1 failed:"
				    " group 1 function %d(0x%2x)\n",
				    DEVNAME(sc), best_func, support_func);
				return error;
			}
			bus_clock = 50000;
			timing = SDMMC_TIMING_HIGHSPEED;
d650 6
a655 2
			/* Wait 400KHz x 8 clock (2.5us * 8 + slop) */
			delay(25);
a656 7
	}

	/* change bus clock */
	error = sdmmc_chip_bus_clock(sc->sct, sc->sch, bus_clock, timing);
	if (error) {
		printf("%s: can't change bus clock\n", DEVNAME(sc));
		return error;
@


1.27
log
@Add high-speed support for SD cards.  In theory this should double the
transfer rates to and from the card.  In practice the improvement will be
smaller, but I am seeing serious improvement in the read speeds.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.26 2016/05/01 18:29:44 kettenis Exp $	*/
d582 1
a582 1
	int support_func, best_func, bus_clock, error;
d607 1
d634 1
d642 1
a642 1
	error = sdmmc_chip_bus_clock(sc->sct, sc->sch, bus_clock);
d655 1
d658 2
a659 2
	int speed = 0;
	int hs_timing = 0;
d672 8
a679 1
		if (ext_csd[EXT_CSD_CARD_TYPE] & EXT_CSD_CARD_TYPE_F_52M) {
d681 2
a682 2
			hs_timing = 1;
		} else if (ext_csd[EXT_CSD_CARD_TYPE] & EXT_CSD_CARD_TYPE_F_26M) {
d689 33
d749 9
a757 2
		if (!ISSET(sc->sc_caps, SMC_CAPS_MMC_HIGHSPEED))
			hs_timing = 0;
a758 2
		if (hs_timing) {
			/* switch to high speed timing */
d760 3
a762 3
			    EXT_CSD_HS_TIMING, hs_timing);
			if (error != 0) {
				printf("%s: can't change high speed\n",
a767 1
		}
d769 7
a775 5
		error = sdmmc_chip_bus_clock(sc->sct, sc->sch, speed);
		if (error != 0) {
			printf("%s: can't change bus clock\n", DEVNAME(sc));
			return error;
		}
d777 1
a777 4
		if (hs_timing) {
			/* read EXT_CSD again */
			error = sdmmc_mem_send_cxd_data(sc,
			    MMC_SEND_EXT_CSD, ext_csd, sizeof(ext_csd));
d779 1
a779 1
				printf("%s: can't re-read EXT_CSD\n", DEVNAME(sc));
d782 2
a783 4
			if (ext_csd[EXT_CSD_HS_TIMING] != hs_timing) {
				printf("%s, HS_TIMING set failed\n", DEVNAME(sc));
				return EINVAL;
			}
@


1.26
log
@Add bus width switching support for MMC.  Enable 8-bit bus support on
sdhc(4) controllers that support it.  Mostly from NetBSD.

This makes the raw transfer rate of the eMMC on the Lenovo Ideacentre
Stick 300 go up to 40 MB/s.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.25 2016/05/01 17:18:43 kettenis Exp $	*/
d31 4
d276 1
a276 1

d371 1
a371 1
	if (error == 0) {
a372 1
	}
d481 47
d565 14
d582 2
a584 1
	int error;
d603 41
@


1.25
log
@Add a small delay after switching an MMC card into high-speed mode to make
sure it has witched before changing the bus clock speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.24 2016/05/01 16:04:39 kettenis Exp $	*/
d546 1
d572 28
d616 1
a616 2
		error =
		    sdmmc_chip_bus_clock(sc->sct, sc->sch, speed);
d630 1
a630 1
			if (ext_csd[EXT_CSD_HS_TIMING] != 1) {
@


1.24
log
@Add support for changing the bus width to the sdmmc subsystem and the sdhc(4)
controller.  Use this to switch SD cards to a 4-bit bus if they support it.

ok deraadt@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.23 2016/04/30 11:32:23 kettenis Exp $	*/
d583 2
@


1.23
log
@Implement DMA support.  Bits and pieces taken from NetBSD, but we only
support ADMA2.  The older SDMA mode has too many limitations to be really
usable.  Gives us only moderate speed improvements, bus reduces the CPU load
considerably.  We will reap the full benefits once we implement wider bus
widths and high speed modes.

There is a remining issue with simultanious use of eMMC and external SD card
on (some) Intel Bay Trail hardware.  Still under investigation.

ok patrick@@, stsp@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.22 2015/11/08 12:10:27 jsg Exp $	*/
d40 4
d45 1
d347 64
d448 30
d518 21
a538 1
	/* XXX */
@


1.22
log
@Always claim to support sector mode for eMMC.  Allows BeagleBone Black
boards with Micron eMMC to work.  The Micron eMMC seems to adhere to the
spec which states:

"If there is no indication by a host to a memory that the host is
capable of handling sector type of addressing the higher than 2GB of
density of memory will change its state to Inactive (similarly to a sit-
uation in which there is no common voltage range to work with)"

From Ian Sutton with feedback from uwe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.21 2015/04/22 04:02:06 jsg Exp $	*/
d47 2
a48 2
int	sdmmc_mem_read_block_subr(struct sdmmc_function *, int, u_char *,
	size_t);
d51 2
a52 2
int	sdmmc_mem_write_block_subr(struct sdmmc_function *, int, u_char *,
	size_t);
d569 2
a570 2
sdmmc_mem_read_block_subr(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
d591 1
d631 2
a632 2
		error = sdmmc_mem_read_block_subr(sf, blkno + i, data + i *
		    sf->csd.sector_size, sf->csd.sector_size);
d651 7
a657 2
	} else {
		error = sdmmc_mem_read_block_subr(sf, blkno, data, datalen);
d660 20
d685 2
a686 2
sdmmc_mem_write_block_subr(struct sdmmc_function *sf, int blkno, u_char *data,
    size_t datalen)
d706 1
d745 2
a746 2
		error = sdmmc_mem_write_block_subr(sf, blkno + i, data + i *
		    sf->csd.sector_size, sf->csd.sector_size);
d765 7
a771 2
	} else {
		error = sdmmc_mem_write_block_subr(sf, blkno, data, datalen);
d774 20
@


1.21
log
@Init error to 0 for sdmmc_mem_single_{read,write}_block
otherwise the value would be uninitialised in the unlikely
case of being called with length 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.20 2014/09/23 12:08:13 rapha Exp $	*/
d528 2
@


1.20
log
@Fix high capacity (> 2GB) eMMC support.
Based on a diff by Cedric Tessier, nezetic at gmail dot com, thanks!

Discussed with and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.19 2014/07/12 18:48:52 tedu Exp $	*/
d624 1
a624 1
	int error;
d712 1
a712 1
	int error;
@


1.19
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.18 2013/10/22 16:49:27 syl Exp $	*/
d431 1
d443 1
a443 8
		switch (ext_csd[EXT_CSD_CARD_TYPE]) {
		case EXT_CSD_CARD_TYPE_26M:
			speed = 26000;
			break;
		case EXT_CSD_CARD_TYPE_52M:
		case EXT_CSD_CARD_TYPE_52M_V18:
		case EXT_CSD_CARD_TYPE_52M_V12:
		case EXT_CSD_CARD_TYPE_52M_V12_18:
d446 3
a448 2
			break;
		default:
d485 10
@


1.18
log
@Add code for SMC_CAPS_SINGLE_ONLY capability.

This capability force the sdmmc stack to only issue
single blocks transfers.

tested by rapha@@ and I on ommmc(4).
tested by rapha@@ on pxammc(4).
ok rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.17 2013/09/12 11:54:04 rapha Exp $	*/
d373 1
a373 1
		free(ptr, M_DEVBUF);
@


1.17
log
@Add basic support for eMMC memory.
Heavily based on netbsd.

Tested by dlg@@, bcallah@@ (sdhc), stsp@@ (rstx) and me (ommmc).

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.16 2010/08/24 14:52:23 blambert Exp $	*/
d45 8
d562 1
a562 1
sdmmc_mem_read_block(struct sdmmc_function *sf, int blkno, u_char *data,
a568 1
	rw_enter_write(&sc->sc_lock);
d612 35
d648 1
a648 1
	return error;
d652 1
a652 1
sdmmc_mem_write_block(struct sdmmc_function *sf, int blkno, u_char *data,
a658 2
	rw_enter_write(&sc->sc_lock);

d700 35
d736 1
a736 1
	return error;
@


1.16
log
@lockmgr -> rwlock conversion

and with this, my adventure in sdmmc-land is over
bikeshed is still banana-shaped

ok oga@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.15 2010/08/19 17:54:12 jasper Exp $	*/
d40 6
d262 7
a268 2
		if (csd->csdver != MMC_CSD_CSDVER_1_0 &&
		    csd->csdver != MMC_CSD_CSDVER_2_0) {
a272 4

		csd->mmcver = MMC_CSD_MMCVER(resp);
		csd->capacity = MMC_CSD_CAPACITY(resp);
		csd->read_bl_len = MMC_CSD_READ_BL_LEN(resp);
d333 53
d399 86
@


1.15
log
@- fold several occurences of DEVNAME() into one located in sdmmcvar.h.
making DEVNAME() usage a lot more consistent.

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.14 2010/02/10 23:33:08 drahn Exp $	*/
d55 1
a55 1
	SDMMC_ASSERT_LOCKED(sc);
d125 1
a125 1
	SDMMC_ASSERT_LOCKED(sc);
d334 1
a334 1
	SDMMC_ASSERT_LOCKED(sc);
d353 1
a353 1
	SDMMC_ASSERT_LOCKED(sc);
d395 1
a395 1
	SDMMC_ASSERT_LOCKED(sc);
d415 1
a415 1
	SDMMC_LOCK(sc);
d459 1
a459 1
	SDMMC_UNLOCK(sc);
d471 1
a471 1
	SDMMC_LOCK(sc);
d514 1
a514 1
	SDMMC_UNLOCK(sc);
@


1.14
log
@Only allow the common voltages of the card and the host when writing the OCR
back to the card. fixes a problem where the controller supported lower voltages
than the card. With variable name change requested miod, ok miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.13 2009/10/03 18:42:36 kettenis Exp $	*/
d79 1
a79 1
			    SDMMCDEVNAME(sc)));
d92 1
a92 1
		    SDMMCDEVNAME(sc)));
d106 1
a106 1
		DPRINTF(("%s: can't send memory OCR\n", SDMMCDEVNAME(sc)));
d144 1
a144 1
			DPRINTF(("%s: can't read CID\n", SDMMCDEVNAME(sc)));
d169 1
a169 1
			printf("%s: can't set mem RCA\n", SDMMCDEVNAME(sc));
d178 1
a178 1
			    SDMMCDEVNAME(sc), sf->rca);
d219 1
a219 1
		printf("%s: CID: ", SDMMCDEVNAME(sc));
d249 1
a249 1
			    SDMMCDEVNAME(sc), csd->csdver);
d259 1
a259 1
			    SDMMCDEVNAME(sc), csd->csdver);
d309 1
a309 1
			    SDMMCDEVNAME(sc), sf->csd.mmcver);
d401 1
a401 1
	DPRINTF(("%s: read_bl_len=%d sector_size=%d\n", SDMMCDEVNAME(sc),
@


1.13
log
@Add missing <sys/device.h>.

ok deraadt@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.12 2009/04/07 16:35:52 blambert Exp $	*/
d98 2
@


1.12
log
@Remove recursion from the sdmmc locking regime.

In snaps for a while.

Originally hacked on phessler@@'s couch.
Testing by many, input from jsg@@

"I'm tired of seeing the Ms" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.11 2009/02/20 19:16:35 miod Exp $	*/
d22 1
@


1.11
log
@Let the sdmmc adapters tell the sdmmc layer how much sectors they can
transfer with one command. Build on this and the recent minphys() changes
in the sdmmc layer to crank transfers at the maximum possible size instead
of a sad DEV_BSIZE.

Depending on your controller, this can speed up sdmmc I/O up to 2.5 times.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.10 2009/01/09 10:55:22 jsg Exp $	*/
d54 2
d122 2
d331 2
a332 1
	SDMMC_LOCK(sc);
a335 1
	SDMMC_UNLOCK(sc);
d350 1
a350 1
	SDMMC_LOCK(sc);
a379 1
	SDMMC_UNLOCK(sc);
d391 2
@


1.10
log
@Add support for SDHC cards on SDHC capable host controllers.
Thanks to everyone who tested in particular jsing@@ who found several
problems in the initial diffs.

ok dlg@@ jsing@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.9 2008/12/02 23:49:54 deraadt Exp $	*/
d428 2
a429 3
	/* XXX sdhc(4) does not need this */
#ifdef __zaurus__
	if (cmd.c_opcode == MMC_READ_BLOCK_MULTIPLE) {
a437 1
#endif
d484 2
a485 3
	/* XXX sdhc(4) does not need this */
#ifdef __zaurus__
	if (cmd.c_opcode == MMC_WRITE_BLOCK_MULTIPLE) {
a492 1
#endif
@


1.9
log
@backout: would have been nice if this had been tested, to see that it
crashes the moment a card is plugged in.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.7 2007/03/18 22:07:16 uwe Exp $	*/
d96 3
d230 11
a240 1
		if (csd->csdver != SD_CSD_CSDVER_1_0) {
d244 1
a246 2
		csd->capacity = SD_CSD_CAPACITY(resp);
		csd->read_bl_len = SD_CSD_READ_BL_LEN(resp);
d418 4
a421 1
	cmd.c_arg = blkno << 9;
d476 4
a479 1
	cmd.c_arg = blkno << 9;
@


1.8
log
@Rework sdmmc locking to remove recursion
Add SDMMC_ASSERT_LOCKED(), replacing many locking calls, and sprinkling
the assertion to make sure that future changes don't catch us out

"please commit" uwe@@
@
text
@a53 2
	SDMMC_ASSERT_LOCKED(sc);

a116 2
	SDMMC_ASSERT_LOCKED(sc);

d334 1
a334 1
	SDMMC_ASSERT_LOCKED(sc);
d364 1
a375 2

	SDMMC_ASSERT_LOCKED(sc);
@


1.7
log
@DHC automatically sends a CMD12 after multiple-block transfers, but other
controllers don't.  Put in a temporary hack for pxammc on Zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.6 2006/11/29 14:16:43 uwe Exp $	*/
d54 2
d119 2
d338 1
a338 1
	SDMMC_LOCK(sc);
a367 1
	SDMMC_UNLOCK(sc);
d379 2
@


1.6
log
@move CSD/CID decoding to sdmmc_mem.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.5 2006/07/18 04:10:35 uwe Exp $	*/
d413 13
d467 12
@


1.5
log
@First and foremost, avoid an obious race between two or more processes
trying to get MMC commands through to the SD/MMC host controller via the
emulated SCSI layer.  This is achieved by ensuring exclusive access to
the host controller for one process during any MMC command and during a
sequence of commands at the sdmmc(4) layer.

While at it, the command processing thread has been moved to sdmmc(4),
so as to simplify the implementation of future host controller drivers.
This should also pave the way for further cleanup of the code and for
new drivers.

Minor cleanups are included in this commit, as well.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.4 2006/06/29 01:40:51 uwe Exp $	*/
d30 6
d214 92
@


1.4
log
@- Assign RCAs beginning at 1 since 0 is used to deselect all cards.
- Always set the "SDIO function 0" pointer to something, even if it is
  a memory-only card to avoid further special cases in SDIO drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.3 2006/06/01 21:53:41 uwe Exp $	*/
a61 1
		DPRINTF(("flags %x\n", sc->sc_flags));
d215 3
d220 3
a222 2
		return 1;
	return 0;
d236 2
d265 2
d290 2
a291 2
sdmmc_mem_read_block(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int blkno, u_char *data, size_t datalen)
d293 1
d297 2
d300 1
a300 1
		return error;
d313 1
a313 1
		return error;
d326 2
d332 2
a333 2
sdmmc_mem_write_block(struct sdmmc_softc *sc, struct sdmmc_function *sf,
    int blkno, u_char *data, size_t datalen)
d335 1
d339 2
d342 1
a342 1
		return error;
d355 1
a355 1
		return error;
d368 2
@


1.3
log
@SDIO card identification
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.2 2006/05/28 18:45:23 uwe Exp $	*/
d134 1
a134 1
		next_rca = 0;
d171 7
@


1.2
log
@don't #undef SDMMC_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: sdmmc_mem.c,v 1.1 2006/05/28 17:21:14 uwe Exp $	*/
d22 2
d31 1
a31 1
int	sdmmc_mem_set_blocklen(struct sdmmc_softc *, struct sdmmc_card *);
d70 2
a71 2
			printf("%s: can't read memory OCR\n",
			    SDMMCDEVNAME(sc));
d83 2
a84 2
		printf("%s: can't supply voltage requested by card\n",
		    SDMMCDEVNAME(sc));
d93 1
a93 1
		printf("%s: can't send memory OCR\n", SDMMCDEVNAME(sc));
d100 104
d207 1
a207 1
sdmmc_mem_init(struct sdmmc_softc *sc, struct sdmmc_card *cs)
d209 2
a210 2
	if (sdmmc_select_card(sc, cs) != 0 ||
	    sdmmc_mem_set_blocklen(sc, cs) != 0)
d229 1
a229 1
	 * that all cards are ready for card identification.
d261 1
a261 1
sdmmc_mem_set_blocklen(struct sdmmc_softc *sc, struct sdmmc_card *cs)
d267 1
a267 1
	cmd.c_arg = cs->csd.sector_size;
d270 1
a270 1
	    1 << cs->csd.read_bl_len, cs->csd.sector_size));
d276 1
a276 1
sdmmc_mem_read_block(struct sdmmc_softc *sc, struct sdmmc_card *cs,
d282 1
a282 1
	if ((error = sdmmc_select_card(sc, cs)) != 0)
d288 1
a288 1
	cmd.c_blklen = cs->csd.sector_size;
d301 1
a301 1
		cmd.c_arg = MMC_ARG_RCA(cs->rca);
d313 1
a313 1
sdmmc_mem_write_block(struct sdmmc_softc *sc, struct sdmmc_card *cs,
d319 1
a319 1
	if ((error = sdmmc_select_card(sc, cs)) != 0)
d325 1
a325 1
	cmd.c_blklen = cs->csd.sector_size;
d338 1
a338 1
		cmd.c_arg = MMC_ARG_RCA(cs->rca);
@


1.1
log
@Support for standard SD host controllers like the Ricoh 5C822, a small
generic bus layer, and SCSI emulation for SD/MMC memory cards.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d28 2
a29 1
#undef SDMMC_DEBUG
a35 3

int	sdmmc_mem_send_op_cond(struct sdmmc_softc *, u_int32_t, u_int32_t *);
int	sdmmc_mem_set_blocklen(struct sdmmc_softc *, struct sdmmc_card *);
@

