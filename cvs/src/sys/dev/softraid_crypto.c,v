head	1.137;
access;
symbols
	OPENBSD_6_2:1.137.0.4
	OPENBSD_6_2_BASE:1.137
	OPENBSD_6_1:1.133.0.4
	OPENBSD_6_1_BASE:1.133
	OPENBSD_6_0:1.130.0.2
	OPENBSD_6_0_BASE:1.130
	OPENBSD_5_9:1.124.0.2
	OPENBSD_5_9_BASE:1.124
	OPENBSD_5_8:1.122.0.4
	OPENBSD_5_8_BASE:1.122
	OPENBSD_5_7:1.116.0.4
	OPENBSD_5_7_BASE:1.116
	OPENBSD_5_6:1.110.0.4
	OPENBSD_5_6_BASE:1.110
	OPENBSD_5_5:1.109.0.4
	OPENBSD_5_5_BASE:1.109
	OPENBSD_5_4:1.95.0.2
	OPENBSD_5_4_BASE:1.95
	OPENBSD_5_3:1.86.0.2
	OPENBSD_5_3_BASE:1.86
	OPENBSD_5_2:1.80.0.4
	OPENBSD_5_2_BASE:1.80
	OPENBSD_5_1_BASE:1.80
	OPENBSD_5_1:1.80.0.2
	OPENBSD_5_0:1.71.0.2
	OPENBSD_5_0_BASE:1.71
	OPENBSD_4_9:1.62.0.2
	OPENBSD_4_9_BASE:1.62
	OPENBSD_4_8:1.54.0.2
	OPENBSD_4_8_BASE:1.54
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.39.0.4
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.18.0.2
	OPENBSD_4_3_BASE:1.18;
locks; strict;
comment	@ * @;


1.137
date	2017.06.12.16.39.51;	author jsing;	state Exp;
branches;
next	1.136;
commitid	lYiGlRibkERHgc9a;

1.136
date	2017.06.12.15.15.08;	author jsing;	state Exp;
branches;
next	1.135;
commitid	rZBVNdnOhYZYAsri;

1.135
date	2017.06.12.15.09.07;	author jsing;	state Exp;
branches;
next	1.134;
commitid	8LWhS9Dw7DIDsvAf;

1.134
date	2017.06.12.14.46.00;	author jsing;	state Exp;
branches;
next	1.133;
commitid	rVArjtyRmWezhEPV;

1.133
date	2017.02.07.17.25.46;	author patrick;	state Exp;
branches;
next	1.132;
commitid	dMJlqKWYCJoMV7JN;

1.132
date	2017.02.07.15.10.48;	author bluhm;	state Exp;
branches;
next	1.131;
commitid	7vg8X7gfUc0w7Qc8;

1.131
date	2016.09.08.17.39.08;	author jsing;	state Exp;
branches;
next	1.130;
commitid	plpYAZZ9wMj2Jrm9;

1.130
date	2016.05.31.15.11.26;	author jsing;	state Exp;
branches;
next	1.129;
commitid	0HGkVK0lBWEEjSRJ;

1.129
date	2016.05.28.00.10.36;	author tedu;	state Exp;
branches;
next	1.128;
commitid	DoXi3fddHkHfC6Zj;

1.128
date	2016.05.21.14.19.03;	author jsing;	state Exp;
branches;
next	1.127;
commitid	HqMrPgGWtGqBGin3;

1.127
date	2016.05.17.19.28.59;	author tedu;	state Exp;
branches;
next	1.126;
commitid	R1KhCAtbAI2yOEYx;

1.126
date	2016.04.12.16.26.54;	author krw;	state Exp;
branches;
next	1.125;
commitid	ATfj2h1H9b585gss;

1.125
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.124;
commitid	1ISokwrtQ24zRrhW;

1.124
date	2015.12.29.04.46.28;	author mmcc;	state Exp;
branches;
next	1.123;
commitid	QKSTqnEw1KIrhSLM;

1.123
date	2015.11.05.20.03.04;	author naddy;	state Exp;
branches;
next	1.122;
commitid	lspfYULTVUEiyMYH;

1.122
date	2015.07.27.04.11.58;	author halex;	state Exp;
branches;
next	1.121;
commitid	DIYFP8pVQzzZj4ER;

1.121
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.120;
commitid	TJiPw62Nfq0KhqBx;

1.120
date	2015.07.19.17.20.15;	author krw;	state Exp;
branches;
next	1.119;
commitid	VwpLklR724aMyBEd;

1.119
date	2015.07.19.16.12.10;	author krw;	state Exp;
branches;
next	1.118;
commitid	Dc93N2P6UBq5IEZc;

1.118
date	2015.07.05.20.51.33;	author mlarkin;	state Exp;
branches;
next	1.117;
commitid	F9F0j2U6tu66eMPq;

1.117
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.116;
commitid	p4LJxGKbi0BU2cG6;

1.116
date	2014.12.19.17.15.16;	author tedu;	state Exp;
branches;
next	1.115;
commitid	xhVw3ZjvZRpIXwAb;

1.115
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.114;
commitid	Z1vcFtHO8wRH0yRt;

1.114
date	2014.10.30.17.26.23;	author tedu;	state Exp;
branches;
next	1.113;
commitid	89qKXN9BlDM32oYx;

1.113
date	2014.10.30.17.23.45;	author tedu;	state Exp;
branches;
next	1.112;
commitid	dxRuG7Wc0MTa8cji;

1.112
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.111;
commitid	uzzBR7hz9ncd4O6G;

1.111
date	2014.09.13.16.06.37;	author doug;	state Exp;
branches;
next	1.110;
commitid	jdBY2kKXhfcoQitp;

1.110
date	2014.07.12.18.48.51;	author tedu;	state Exp;
branches;
next	1.109;
commitid	OBNa5kfxQ2UXoiIw;

1.109
date	2014.01.22.01.46.08;	author jsing;	state Exp;
branches;
next	1.108;

1.108
date	2014.01.21.06.38.11;	author jsing;	state Exp;
branches;
next	1.107;

1.107
date	2014.01.21.05.52.25;	author jsing;	state Exp;
branches;
next	1.106;

1.106
date	2014.01.21.05.22.21;	author jsing;	state Exp;
branches;
next	1.105;

1.105
date	2014.01.21.05.11.12;	author jsing;	state Exp;
branches;
next	1.104;

1.104
date	2014.01.21.04.23.14;	author jsing;	state Exp;
branches;
next	1.103;

1.103
date	2014.01.21.03.21.38;	author jsing;	state Exp;
branches;
next	1.102;

1.102
date	2014.01.20.10.54.54;	author jsing;	state Exp;
branches;
next	1.101;

1.101
date	2014.01.20.04.38.58;	author jsing;	state Exp;
branches;
next	1.100;

1.100
date	2014.01.20.04.16.29;	author jsing;	state Exp;
branches;
next	1.99;

1.99
date	2014.01.20.04.12.51;	author jsing;	state Exp;
branches;
next	1.98;

1.98
date	2013.12.21.20.46.20;	author guenther;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.19.15.12.13;	author krw;	state Exp;
branches;
next	1.96;

1.96
date	2013.11.04.21.02.57;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.94;

1.94
date	2013.05.21.15.01.53;	author jsing;	state Exp;
branches;
next	1.93;

1.93
date	2013.04.01.15.17.32;	author jsing;	state Exp;
branches;
next	1.92;

1.92
date	2013.04.01.07.58.43;	author jsing;	state Exp;
branches;
next	1.91;

1.91
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.90;

1.90
date	2013.03.31.11.37.40;	author jsing;	state Exp;
branches;
next	1.89;

1.89
date	2013.03.30.02.02.14;	author jsing;	state Exp;
branches;
next	1.88;

1.88
date	2013.03.29.11.46.45;	author jsing;	state Exp;
branches;
next	1.87;

1.87
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.18.23.22.18;	author jsing;	state Exp;
branches;
next	1.85;

1.85
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.83;

1.83
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.82;

1.82
date	2012.10.09.11.57.33;	author jsing;	state Exp;
branches;
next	1.81;

1.81
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.80;

1.80
date	2012.01.30.13.13.03;	author jsing;	state Exp;
branches;
next	1.79;

1.79
date	2012.01.22.11.13.32;	author jsing;	state Exp;
branches;
next	1.78;

1.78
date	2012.01.22.10.50.39;	author jsing;	state Exp;
branches;
next	1.77;

1.77
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.76;

1.76
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.75;

1.75
date	2011.09.20.12.20.44;	author jsing;	state Exp;
branches;
next	1.74;

1.74
date	2011.09.20.12.19.22;	author jsing;	state Exp;
branches;
next	1.73;

1.73
date	2011.09.18.19.40.49;	author jsing;	state Exp;
branches;
next	1.72;

1.72
date	2011.09.18.13.11.08;	author jsing;	state Exp;
branches;
next	1.71;

1.71
date	2011.07.07.00.17.14;	author tedu;	state Exp;
branches;
next	1.70;

1.70
date	2011.07.05.19.02.47;	author oga;	state Exp;
branches;
next	1.69;

1.69
date	2011.06.18.23.35.21;	author matthew;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.17.07.06.46;	author mk;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.05.11.09.00;	author stsp;	state Exp;
branches;
next	1.66;

1.66
date	2011.05.20.19.37.58;	author mikeb;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.06.03.14.51;	author marco;	state Exp;
branches;
next	1.64;

1.64
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.63;

1.63
date	2011.03.06.21.41.57;	author stsp;	state Exp;
branches;
next	1.62;

1.62
date	2011.01.12.20.48.34;	author marco;	state Exp;
branches;
next	1.61;

1.61
date	2011.01.12.20.41.48;	author deraadt;	state Exp;
branches;
next	1.60;

1.60
date	2011.01.12.20.38.33;	author marco;	state Exp;
branches;
next	1.59;

1.59
date	2011.01.12.19.45.03;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2010.11.06.23.01.56;	author marco;	state Exp;
branches;
next	1.57;

1.57
date	2010.09.27.19.49.43;	author thib;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.27.02.56.28;	author marco;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.23.18.49.39;	author oga;	state Exp;
branches;
next	1.54;

1.54
date	2010.07.02.09.26.05;	author jsing;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2010.04.18.16.57.48;	author jsing;	state Exp;
branches;
next	1.50;

1.50
date	2010.03.28.16.38.57;	author jsing;	state Exp;
branches;
next	1.49;

1.49
date	2010.03.28.10.14.18;	author jsing;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.47;

1.47
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.31.14.42.31;	author jsing;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.31.14.00.45;	author jsing;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.43;

1.43
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.42;

1.42
date	2009.11.24.02.19.35;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.24.01.03.54;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2009.06.11.19.42.59;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2009.06.11.02.59.06;	author marco;	state Exp;
branches;
next	1.37;

1.37
date	2009.06.09.23.17.35;	author chl;	state Exp;
branches;
next	1.36;

1.36
date	2009.06.03.17.39.27;	author ckuethe;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.02.21.23.11;	author marco;	state Exp;
branches;
next	1.34;

1.34
date	2009.06.02.11.38.51;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2008.09.22.19.44.00;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.15.11.18.10;	author djm;	state Exp;
branches;
next	1.29;

1.29
date	2008.07.19.22.41.58;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.25.17.43.09;	author thib;	state Exp;
branches;
next	1.27;

1.27
date	2008.06.14.18.40.50;	author hshoexer;	state Exp;
branches;
next	1.26;

1.26
date	2008.06.14.03.01.00;	author djm;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.14.00.12.21;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2008.06.13.22.08.17;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.13.21.03.40;	author hshoexer;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.13.18.26.59;	author hshoexer;	state Exp;
branches;
next	1.21;

1.21
date	2008.06.12.18.23.29;	author hshoexer;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.12.18.13.27;	author hshoexer;	state Exp;
branches;
next	1.19;

1.19
date	2008.06.11.00.26.18;	author hshoexer;	state Exp;
branches;
next	1.18;

1.18
date	2008.02.23.19.46.00;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2008.02.23.19.38.29;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2008.02.22.23.00.04;	author hshoexer;	state Exp;
branches;
next	1.15;

1.15
date	2008.02.19.03.28.28;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2008.02.17.21.11.37;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2008.02.17.20.40.56;	author hshoexer;	state Exp;
branches;
next	1.12;

1.12
date	2008.02.17.20.39.22;	author hshoexer;	state Exp;
branches;
next	1.11;

1.11
date	2008.02.15.05.29.25;	author ckuethe;	state Exp;
branches;
next	1.10;

1.10
date	2008.02.14.22.04.34;	author ckuethe;	state Exp;
branches;
next	1.9;

1.9
date	2008.02.07.15.08.49;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.05.16.49.25;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.05.16.15.35;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.31.20.55.43;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.29.23.25.02;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.27.15.02.28;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.26.19.29.55;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.24.17.50.17;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.27.16.37.05;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.137
log
@Limit the maximum size of softraid crypto volumes that can be created to
the size that is currently supported (a data area of 16TB, or
2^32 * 32 + 528 blocks including the softraid metadata/boot area), rather
than successfully creating the volume and then failing during resource
allocation (without properly reporting why it failed).

Found the hard way by sharon s. <mymlact at gmx dot com>
@
text
@/* $OpenBSD: softraid_crypto.c,v 1.136 2017/06/12 15:15:08 jsing Exp $ */
/*
 * Copyright (c) 2007 Marco Peereboom <marco@@peereboom.us>
 * Copyright (c) 2008 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 * Copyright (c) 2008 Damien Miller <djm@@mindrot.org>
 * Copyright (c) 2009 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/pool.h>
#include <sys/kernel.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/disklabel.h>
#include <sys/vnode.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/conf.h>
#include <sys/uio.h>
#include <sys/dkio.h>

#include <crypto/cryptodev.h>
#include <crypto/rijndael.h>
#include <crypto/md5.h>
#include <crypto/sha1.h>
#include <crypto/sha2.h>
#include <crypto/hmac.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>

/*
 * The per-I/O data that we need to preallocate. We cannot afford to allow I/O
 * to start failing when memory pressure kicks in. We can store this in the WU
 * because we assert that only one ccb per WU will ever be active.
 */
struct sr_crypto_wu {
	struct sr_workunit		 cr_wu;		/* Must be first. */
	struct uio			 cr_uio;
	struct iovec			 cr_iov;
	struct cryptop	 		*cr_crp;
	void				*cr_dmabuf;
};


struct sr_crypto_wu *sr_crypto_prepare(struct sr_workunit *, int);
int		sr_crypto_create_keys(struct sr_discipline *);
int		sr_crypto_get_kdf(struct bioc_createraid *,
		    struct sr_discipline *);
int		sr_crypto_decrypt(u_char *, u_char *, u_char *, size_t, int);
int		sr_crypto_encrypt(u_char *, u_char *, u_char *, size_t, int);
int		sr_crypto_decrypt_key(struct sr_discipline *);
int		sr_crypto_change_maskkey(struct sr_discipline *,
		    struct sr_crypto_kdfinfo *, struct sr_crypto_kdfinfo *);
int		sr_crypto_create(struct sr_discipline *,
		    struct bioc_createraid *, int, int64_t);
int		sr_crypto_assemble(struct sr_discipline *,
		    struct bioc_createraid *, int, void *);
int		sr_crypto_alloc_resources(struct sr_discipline *);
void		sr_crypto_free_resources(struct sr_discipline *);
int		sr_crypto_ioctl(struct sr_discipline *,
		    struct bioc_discipline *);
int		sr_crypto_meta_opt_handler(struct sr_discipline *,
		    struct sr_meta_opt_hdr *);
void		sr_crypto_write(struct cryptop *);
int		sr_crypto_rw(struct sr_workunit *);
int		sr_crypto_dev_rw(struct sr_workunit *, struct sr_crypto_wu *);
void		sr_crypto_done(struct sr_workunit *);
void		sr_crypto_read(struct cryptop *);
void		sr_crypto_calculate_check_hmac_sha1(u_int8_t *, int,
		   u_int8_t *, int, u_char *);
void		sr_crypto_hotplug(struct sr_discipline *, struct disk *, int);

#ifdef SR_DEBUG0
void		 sr_crypto_dumpkeys(struct sr_discipline *);
#endif

/* Discipline initialisation. */
void
sr_crypto_discipline_init(struct sr_discipline *sd)
{
	int i;

	/* Fill out discipline members. */
	sd->sd_type = SR_MD_CRYPTO;
	strlcpy(sd->sd_name, "CRYPTO", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE;
	sd->sd_max_wu = SR_CRYPTO_NOWU;

	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++)
		sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;

	/* Setup discipline specific function pointers. */
	sd->sd_alloc_resources = sr_crypto_alloc_resources;
	sd->sd_assemble = sr_crypto_assemble;
	sd->sd_create = sr_crypto_create;
	sd->sd_free_resources = sr_crypto_free_resources;
	sd->sd_ioctl_handler = sr_crypto_ioctl;
	sd->sd_meta_opt_handler = sr_crypto_meta_opt_handler;
	sd->sd_scsi_rw = sr_crypto_rw;
	sd->sd_scsi_done = sr_crypto_done;
}

int
sr_crypto_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	struct sr_meta_opt_item	*omi;
	int			rv = EINVAL;

	if (no_chunk != 1) {
		sr_error(sd->sd_sc, "%s requires exactly one chunk",
		    sd->sd_name);
		goto done;
	}

	if (coerced_size > SR_CRYPTO_MAXSIZE) {
		sr_error(sd->sd_sc, "%s exceeds maximum size (%lli > %llu)",
		    sd->sd_name, coerced_size, SR_CRYPTO_MAXSIZE);
		goto done;
	}

	/* Create crypto optional metadata. */
	omi = malloc(sizeof(struct sr_meta_opt_item), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	omi->omi_som = malloc(sizeof(struct sr_meta_crypto), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	omi->omi_som->som_type = SR_OPT_CRYPTO;
	omi->omi_som->som_length = sizeof(struct sr_meta_crypto);
	SLIST_INSERT_HEAD(&sd->sd_meta_opt, omi, omi_link);
	sd->mds.mdd_crypto.scr_meta = (struct sr_meta_crypto *)omi->omi_som;
	sd->sd_meta->ssdi.ssd_opt_no++;

	sd->mds.mdd_crypto.key_disk = NULL;

	if (bc->bc_key_disk != NODEV) {

		/* Create a key disk. */
		if (sr_crypto_get_kdf(bc, sd))
			goto done;
		sd->mds.mdd_crypto.key_disk =
		    sr_crypto_create_key_disk(sd, bc->bc_key_disk);
		if (sd->mds.mdd_crypto.key_disk == NULL)
			goto done;
		sd->sd_capabilities |= SR_CAP_AUTO_ASSEMBLE;

	} else if (bc->bc_opaque_flags & BIOC_SOOUT) {

		/* No hint available yet. */
		bc->bc_opaque_status = BIOC_SOINOUT_FAILED;
		rv = EAGAIN;
		goto done;

	} else if (sr_crypto_get_kdf(bc, sd))
		goto done;

	/* Passphrase volumes cannot be automatically assembled. */
	if (!(bc->bc_flags & BIOC_SCNOAUTOASSEMBLE) && bc->bc_key_disk == NODEV)
		goto done;

	sd->sd_meta->ssdi.ssd_size = coerced_size;

	sr_crypto_create_keys(sd);

	sd->sd_max_ccb_per_wu = no_chunk;

	rv = 0;
done:
	return (rv);
}

int
sr_crypto_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, void *data)
{
	int	rv = EINVAL;

	sd->mds.mdd_crypto.key_disk = NULL;

	/* Crypto optional metadata must already exist... */
	if (sd->mds.mdd_crypto.scr_meta == NULL)
		goto done;

	if (data != NULL) {
		/* Kernel already has mask key. */
		memcpy(sd->mds.mdd_crypto.scr_maskkey, data,
		    sizeof(sd->mds.mdd_crypto.scr_maskkey));
	} else if (bc->bc_key_disk != NODEV) {
		/* Read the mask key from the key disk. */
		sd->mds.mdd_crypto.key_disk =
		    sr_crypto_read_key_disk(sd, bc->bc_key_disk);
		if (sd->mds.mdd_crypto.key_disk == NULL)
			goto done;
	} else if (bc->bc_opaque_flags & BIOC_SOOUT) {
		/* provide userland with kdf hint */
		if (bc->bc_opaque == NULL)
			goto done;

		if (sizeof(sd->mds.mdd_crypto.scr_meta->scm_kdfhint) <
		    bc->bc_opaque_size)
			goto done;

		if (copyout(sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    bc->bc_opaque, bc->bc_opaque_size))
			goto done;

		/* we're done */
		bc->bc_opaque_status = BIOC_SOINOUT_OK;
		rv = EAGAIN;
		goto done;
	} else if (bc->bc_opaque_flags & BIOC_SOIN) {
		/* get kdf with maskkey from userland */
		if (sr_crypto_get_kdf(bc, sd))
			goto done;
	} else
		goto done;

	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;

	rv = 0;
done:
	return (rv);
}

struct sr_crypto_wu *
sr_crypto_prepare(struct sr_workunit *wu, int encrypt)
{
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_discipline	*sd = wu->swu_dis;
	struct sr_crypto_wu	*crwu;
	struct cryptodesc	*crd;
	int			flags, i, n;
	daddr_t			blkno;
	u_int			keyndx;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_prepare wu %p encrypt %d\n",
	    DEVNAME(sd->sd_sc), wu, encrypt);

	crwu = (struct sr_crypto_wu *)wu;
	crwu->cr_uio.uio_iovcnt = 1;
	crwu->cr_uio.uio_iov->iov_len = xs->datalen;
	if (xs->flags & SCSI_DATA_OUT) {
		crwu->cr_uio.uio_iov->iov_base = crwu->cr_dmabuf;
		memcpy(crwu->cr_uio.uio_iov->iov_base, xs->data, xs->datalen);
	} else
		crwu->cr_uio.uio_iov->iov_base = xs->data;

	blkno = wu->swu_blk_start;
	n = xs->datalen >> DEV_BSHIFT;

	/*
	 * We preallocated enough crypto descs for up to MAXPHYS of I/O.
	 * Since there may be less than that we need to tweak the amount
	 * of crypto desc structures to be just long enough for our needs.
	 */
	KASSERT(crwu->cr_crp->crp_ndescalloc >= n);
	crwu->cr_crp->crp_ndesc = n;
	flags = (encrypt ? CRD_F_ENCRYPT : 0) |
	    CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;

	/*
	 * Select crypto session based on block number.
	 *
	 * XXX - this does not handle the case where the read/write spans
	 * across a different key blocks (e.g. 0.5TB boundary). Currently
	 * this is already broken by the use of scr_key[0] below.
	 */
	keyndx = blkno >> SR_CRYPTO_KEY_BLKSHIFT;
	crwu->cr_crp->crp_sid = sd->mds.mdd_crypto.scr_sid[keyndx];

	crwu->cr_crp->crp_opaque = crwu;
	crwu->cr_crp->crp_ilen = xs->datalen;
	crwu->cr_crp->crp_alloctype = M_DEVBUF;
	crwu->cr_crp->crp_flags = CRYPTO_F_IOV | CRYPTO_F_NOQUEUE;
	crwu->cr_crp->crp_buf = &crwu->cr_uio;
	for (i = 0; i < crwu->cr_crp->crp_ndesc; i++, blkno++) {
		crd = &crwu->cr_crp->crp_desc[i];
		crd->crd_skip = i << DEV_BSHIFT;
		crd->crd_len = DEV_BSIZE;
		crd->crd_inject = 0;
		crd->crd_flags = flags;
		crd->crd_alg = sd->mds.mdd_crypto.scr_alg;
		crd->crd_klen = sd->mds.mdd_crypto.scr_klen;
		crd->crd_key = sd->mds.mdd_crypto.scr_key[0];
		memcpy(crd->crd_iv, &blkno, sizeof(blkno));
	}

	return (crwu);
}

int
sr_crypto_get_kdf(struct bioc_createraid *bc, struct sr_discipline *sd)
{
	int			rv = EINVAL;
	struct sr_crypto_kdfinfo *kdfinfo;

	if (!(bc->bc_opaque_flags & BIOC_SOIN))
		return (rv);
	if (bc->bc_opaque == NULL)
		return (rv);
	if (bc->bc_opaque_size != sizeof(*kdfinfo))
		return (rv);

	kdfinfo = malloc(bc->bc_opaque_size, M_DEVBUF, M_WAITOK | M_ZERO);
	if (copyin(bc->bc_opaque, kdfinfo, bc->bc_opaque_size))
		goto out;

	if (kdfinfo->len != bc->bc_opaque_size)
		goto out;

	/* copy KDF hint to disk meta data */
	if (kdfinfo->flags & SR_CRYPTOKDF_HINT) {
		if (sizeof(sd->mds.mdd_crypto.scr_meta->scm_kdfhint) <
		    kdfinfo->genkdf.len)
			goto out;
		memcpy(sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    &kdfinfo->genkdf, kdfinfo->genkdf.len);
	}

	/* copy mask key to run-time meta data */
	if ((kdfinfo->flags & SR_CRYPTOKDF_KEY)) {
		if (sizeof(sd->mds.mdd_crypto.scr_maskkey) <
		    sizeof(kdfinfo->maskkey))
			goto out;
		memcpy(sd->mds.mdd_crypto.scr_maskkey, &kdfinfo->maskkey,
		    sizeof(kdfinfo->maskkey));
	}

	bc->bc_opaque_status = BIOC_SOINOUT_OK;
	rv = 0;
out:
	explicit_bzero(kdfinfo, bc->bc_opaque_size);
	free(kdfinfo, M_DEVBUF, bc->bc_opaque_size);

	return (rv);
}

int
sr_crypto_encrypt(u_char *p, u_char *c, u_char *key, size_t size, int alg)
{
	rijndael_ctx		ctx;
	int			i, rv = 1;

	switch (alg) {
	case SR_CRYPTOM_AES_ECB_256:
		if (rijndael_set_key_enc_only(&ctx, key, 256) != 0)
			goto out;
		for (i = 0; i < size; i += RIJNDAEL128_BLOCK_LEN)
			rijndael_encrypt(&ctx, &p[i], &c[i]);
		rv = 0;
		break;
	default:
		DNPRINTF(SR_D_DIS, "%s: unsupported encryption algorithm %d\n",
		    "softraid", alg);
		rv = -1;
		goto out;
	}

out:
	explicit_bzero(&ctx, sizeof(ctx));
	return (rv);
}

int
sr_crypto_decrypt(u_char *c, u_char *p, u_char *key, size_t size, int alg)
{
	rijndael_ctx		ctx;
	int			i, rv = 1;

	switch (alg) {
	case SR_CRYPTOM_AES_ECB_256:
		if (rijndael_set_key(&ctx, key, 256) != 0)
			goto out;
		for (i = 0; i < size; i += RIJNDAEL128_BLOCK_LEN)
			rijndael_decrypt(&ctx, &c[i], &p[i]);
		rv = 0;
		break;
	default:
		DNPRINTF(SR_D_DIS, "%s: unsupported encryption algorithm %d\n",
		    "softraid", alg);
		rv = -1;
		goto out;
	}

out:
	explicit_bzero(&ctx, sizeof(ctx));
	return (rv);
}

void
sr_crypto_calculate_check_hmac_sha1(u_int8_t *maskkey, int maskkey_size,
    u_int8_t *key, int key_size, u_char *check_digest)
{
	u_char			check_key[SHA1_DIGEST_LENGTH];
	HMAC_SHA1_CTX		hmacctx;
	SHA1_CTX		shactx;

	bzero(check_key, sizeof(check_key));
	bzero(&hmacctx, sizeof(hmacctx));
	bzero(&shactx, sizeof(shactx));

	/* k = SHA1(mask_key) */
	SHA1Init(&shactx);
	SHA1Update(&shactx, maskkey, maskkey_size);
	SHA1Final(check_key, &shactx);

	/* mac = HMAC_SHA1_k(unencrypted key) */
	HMAC_SHA1_Init(&hmacctx, check_key, sizeof(check_key));
	HMAC_SHA1_Update(&hmacctx, key, key_size);
	HMAC_SHA1_Final(check_digest, &hmacctx);

	explicit_bzero(check_key, sizeof(check_key));
	explicit_bzero(&hmacctx, sizeof(hmacctx));
	explicit_bzero(&shactx, sizeof(shactx));
}

int
sr_crypto_decrypt_key(struct sr_discipline *sd)
{
	u_char			check_digest[SHA1_DIGEST_LENGTH];
	int			rv = 1;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_decrypt_key\n", DEVNAME(sd->sd_sc));

	if (sd->mds.mdd_crypto.scr_meta->scm_check_alg != SR_CRYPTOC_HMAC_SHA1)
		goto out;

	if (sr_crypto_decrypt((u_char *)sd->mds.mdd_crypto.scr_meta->scm_key,
	    (u_char *)sd->mds.mdd_crypto.scr_key,
	    sd->mds.mdd_crypto.scr_maskkey, sizeof(sd->mds.mdd_crypto.scr_key),
	    sd->mds.mdd_crypto.scr_meta->scm_mask_alg) == -1)
		goto out;

#ifdef SR_DEBUG0
	sr_crypto_dumpkeys(sd);
#endif

	/* Check that the key decrypted properly. */
	sr_crypto_calculate_check_hmac_sha1(sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey),
	    (u_int8_t *)sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key),
	    check_digest);
	if (memcmp(sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac,
	    check_digest, sizeof(check_digest)) != 0) {
		explicit_bzero(sd->mds.mdd_crypto.scr_key,
		    sizeof(sd->mds.mdd_crypto.scr_key));
		goto out;
	}

	rv = 0; /* Success */
out:
	/* we don't need the mask key anymore */
	explicit_bzero(&sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey));

	explicit_bzero(check_digest, sizeof(check_digest));

	return rv;
}

int
sr_crypto_create_keys(struct sr_discipline *sd)
{

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_create_keys\n",
	    DEVNAME(sd->sd_sc));

	if (AES_MAXKEYBYTES < sizeof(sd->mds.mdd_crypto.scr_maskkey))
		return (1);

	/* XXX allow user to specify */
	sd->mds.mdd_crypto.scr_meta->scm_alg = SR_CRYPTOA_AES_XTS_256;

	/* generate crypto keys */
	arc4random_buf(sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key));

	/* Mask the disk keys. */
	sd->mds.mdd_crypto.scr_meta->scm_mask_alg = SR_CRYPTOM_AES_ECB_256;
	sr_crypto_encrypt((u_char *)sd->mds.mdd_crypto.scr_key,
	    (u_char *)sd->mds.mdd_crypto.scr_meta->scm_key,
	    sd->mds.mdd_crypto.scr_maskkey, sizeof(sd->mds.mdd_crypto.scr_key),
	    sd->mds.mdd_crypto.scr_meta->scm_mask_alg);

	/* Prepare key decryption check code. */
	sd->mds.mdd_crypto.scr_meta->scm_check_alg = SR_CRYPTOC_HMAC_SHA1;
	sr_crypto_calculate_check_hmac_sha1(sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey),
	    (u_int8_t *)sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key),
	    sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac);

	/* Erase the plaintext disk keys */
	explicit_bzero(sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key));

#ifdef SR_DEBUG0
	sr_crypto_dumpkeys(sd);
#endif

	sd->mds.mdd_crypto.scr_meta->scm_flags = SR_CRYPTOF_KEY |
	    SR_CRYPTOF_KDFHINT;

	return (0);
}

int
sr_crypto_change_maskkey(struct sr_discipline *sd,
  struct sr_crypto_kdfinfo *kdfinfo1, struct sr_crypto_kdfinfo *kdfinfo2)
{
	u_char			check_digest[SHA1_DIGEST_LENGTH];
	u_char			*c, *p = NULL;
	size_t			ksz;
	int			rv = 1;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_change_maskkey\n",
	    DEVNAME(sd->sd_sc));

	if (sd->mds.mdd_crypto.scr_meta->scm_check_alg != SR_CRYPTOC_HMAC_SHA1)
		goto out;

	c = (u_char *)sd->mds.mdd_crypto.scr_meta->scm_key;
	ksz = sizeof(sd->mds.mdd_crypto.scr_key);
	p = malloc(ksz, M_DEVBUF, M_WAITOK | M_CANFAIL | M_ZERO);
	if (p == NULL)
		goto out;

	if (sr_crypto_decrypt(c, p, kdfinfo1->maskkey, ksz,
	    sd->mds.mdd_crypto.scr_meta->scm_mask_alg) == -1)
		goto out;

#ifdef SR_DEBUG0
	sr_crypto_dumpkeys(sd);
#endif

	sr_crypto_calculate_check_hmac_sha1(kdfinfo1->maskkey,
	    sizeof(kdfinfo1->maskkey), p, ksz, check_digest);
	if (memcmp(sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac,
	    check_digest, sizeof(check_digest)) != 0) {
		sr_error(sd->sd_sc, "incorrect key or passphrase");
		rv = EPERM;
		goto out;
	}

	/* Copy new KDF hint to metadata, if supplied. */
	if (kdfinfo2->flags & SR_CRYPTOKDF_HINT) {
		if (kdfinfo2->genkdf.len >
		    sizeof(sd->mds.mdd_crypto.scr_meta->scm_kdfhint))
			goto out;
		explicit_bzero(sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    sizeof(sd->mds.mdd_crypto.scr_meta->scm_kdfhint));
		memcpy(sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    &kdfinfo2->genkdf, kdfinfo2->genkdf.len);
	}

	/* Mask the disk keys. */
	c = (u_char *)sd->mds.mdd_crypto.scr_meta->scm_key;
	if (sr_crypto_encrypt(p, c, kdfinfo2->maskkey, ksz,
	    sd->mds.mdd_crypto.scr_meta->scm_mask_alg) == -1)
		goto out;

	/* Prepare key decryption check code. */
	sd->mds.mdd_crypto.scr_meta->scm_check_alg = SR_CRYPTOC_HMAC_SHA1;
	sr_crypto_calculate_check_hmac_sha1(kdfinfo2->maskkey,
	    sizeof(kdfinfo2->maskkey), (u_int8_t *)sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key), check_digest);

	/* Copy new encrypted key and HMAC to metadata. */
	memcpy(sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac, check_digest,
	    sizeof(sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac));

	rv = 0; /* Success */

out:
	if (p) {
		explicit_bzero(p, ksz);
		free(p, M_DEVBUF, ksz);
	}

	explicit_bzero(check_digest, sizeof(check_digest));
	explicit_bzero(&kdfinfo1->maskkey, sizeof(kdfinfo1->maskkey));
	explicit_bzero(&kdfinfo2->maskkey, sizeof(kdfinfo2->maskkey));

	return (rv);
}

struct sr_chunk *
sr_crypto_create_key_disk(struct sr_discipline *sd, dev_t dev)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_discipline	*fakesd = NULL;
	struct sr_metadata	*sm = NULL;
	struct sr_meta_chunk    *km;
	struct sr_meta_opt_item *omi = NULL;
	struct sr_meta_keydisk	*skm;
	struct sr_chunk		*key_disk = NULL;
	struct disklabel	label;
	struct vnode		*vn;
	char			devname[32];
	int			c, part, open = 0;

	/*
	 * Create a metadata structure on the key disk and store
	 * keying material in the optional metadata.
	 */

	sr_meta_getdevname(sc, dev, devname, sizeof(devname));

	/* Make sure chunk is not already in use. */
	c = sr_chunk_in_use(sc, dev);
	if (c != BIOC_SDINVALID && c != BIOC_SDOFFLINE) {
		sr_error(sc, "%s is already in use", devname);
		goto done;
	}

	/* Open device. */
	if (bdevvp(dev, &vn)) {
		sr_error(sc, "cannot open key disk %s", devname);
		goto done;
	}
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, curproc)) {
		DNPRINTF(SR_D_META,"%s: sr_crypto_create_key_disk cannot "
		    "open %s\n", DEVNAME(sc), devname);
		vput(vn);
		goto done;
	}
	open = 1; /* close dev on error */

	/* Get partition details. */
	part = DISKPART(dev);
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label,
	    FREAD, NOCRED, curproc)) {
		DNPRINTF(SR_D_META, "%s: sr_crypto_create_key_disk ioctl "
		    "failed\n", DEVNAME(sc));
		goto done;
	}
	if (label.d_partitions[part].p_fstype != FS_RAID) {
		sr_error(sc, "%s partition not of type RAID (%d)",
		    devname, label.d_partitions[part].p_fstype);
		goto done;
	}

	/*
	 * Create and populate chunk metadata.
	 */

	key_disk = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_WAITOK | M_ZERO);
	km = &key_disk->src_meta;

	key_disk->src_dev_mm = dev;
	key_disk->src_vn = vn;
	strlcpy(key_disk->src_devname, devname, sizeof(km->scmi.scm_devname));
	key_disk->src_size = 0;

	km->scmi.scm_volid = sd->sd_meta->ssdi.ssd_level;
	km->scmi.scm_chunk_id = 0;
	km->scmi.scm_size = 0;
	km->scmi.scm_coerced_size = 0;
	strlcpy(km->scmi.scm_devname, devname, sizeof(km->scmi.scm_devname));
	memcpy(&km->scmi.scm_uuid, &sd->sd_meta->ssdi.ssd_uuid,
	    sizeof(struct sr_uuid));

	sr_checksum(sc, km, &km->scm_checksum,
	    sizeof(struct sr_meta_chunk_invariant));

	km->scm_status = BIOC_SDONLINE;

	/*
	 * Create and populate our own discipline and metadata.
	 */

	sm = malloc(sizeof(struct sr_metadata), M_DEVBUF, M_WAITOK | M_ZERO);
	sm->ssdi.ssd_magic = SR_MAGIC;
	sm->ssdi.ssd_version = SR_META_VERSION;
	sm->ssd_ondisk = 0;
	sm->ssdi.ssd_vol_flags = 0;
	memcpy(&sm->ssdi.ssd_uuid, &sd->sd_meta->ssdi.ssd_uuid,
	    sizeof(struct sr_uuid));
	sm->ssdi.ssd_chunk_no = 1;
	sm->ssdi.ssd_volid = SR_KEYDISK_VOLID;
	sm->ssdi.ssd_level = SR_KEYDISK_LEVEL;
	sm->ssdi.ssd_size = 0;
	strlcpy(sm->ssdi.ssd_vendor, "OPENBSD", sizeof(sm->ssdi.ssd_vendor));
	snprintf(sm->ssdi.ssd_product, sizeof(sm->ssdi.ssd_product),
	    "SR %s", "KEYDISK");
	snprintf(sm->ssdi.ssd_revision, sizeof(sm->ssdi.ssd_revision),
	    "%03d", SR_META_VERSION);

	fakesd = malloc(sizeof(struct sr_discipline), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	fakesd->sd_sc = sd->sd_sc;
	fakesd->sd_meta = sm;
	fakesd->sd_meta_type = SR_META_F_NATIVE;
	fakesd->sd_vol_status = BIOC_SVONLINE;
	strlcpy(fakesd->sd_name, "KEYDISK", sizeof(fakesd->sd_name));
	SLIST_INIT(&fakesd->sd_meta_opt);

	/* Add chunk to volume. */
	fakesd->sd_vol.sv_chunks = malloc(sizeof(struct sr_chunk *), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	fakesd->sd_vol.sv_chunks[0] = key_disk;
	SLIST_INIT(&fakesd->sd_vol.sv_chunk_list);
	SLIST_INSERT_HEAD(&fakesd->sd_vol.sv_chunk_list, key_disk, src_link);

	/* Generate mask key. */
	arc4random_buf(sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey));

	/* Copy mask key to optional metadata area. */
	omi = malloc(sizeof(struct sr_meta_opt_item), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	omi->omi_som = malloc(sizeof(struct sr_meta_keydisk), M_DEVBUF,
	    M_WAITOK | M_ZERO);
	omi->omi_som->som_type = SR_OPT_KEYDISK;
	omi->omi_som->som_length = sizeof(struct sr_meta_keydisk);
	skm = (struct sr_meta_keydisk *)omi->omi_som;
	memcpy(&skm->skm_maskkey, sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(skm->skm_maskkey));
	SLIST_INSERT_HEAD(&fakesd->sd_meta_opt, omi, omi_link);
	fakesd->sd_meta->ssdi.ssd_opt_no++;

	/* Save metadata. */
	if (sr_meta_save(fakesd, SR_META_DIRTY)) {
		sr_error(sc, "could not save metadata to %s", devname);
		goto fail;
	}

	goto done;

fail:
	free(key_disk, M_DEVBUF, sizeof(struct sr_chunk));
	key_disk = NULL;

done:
	free(omi, M_DEVBUF, sizeof(struct sr_meta_opt_item));
	if (fakesd && fakesd->sd_vol.sv_chunks)
		free(fakesd->sd_vol.sv_chunks, M_DEVBUF,
		    sizeof(struct sr_chunk *));
	free(fakesd, M_DEVBUF, sizeof(struct sr_discipline));
	free(sm, M_DEVBUF, sizeof(struct sr_metadata));
	if (open) {
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
	}

	return key_disk;
}

struct sr_chunk *
sr_crypto_read_key_disk(struct sr_discipline *sd, dev_t dev)
{
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_metadata	*sm = NULL;
	struct sr_meta_opt_item *omi, *omi_next;
	struct sr_meta_opt_hdr	*omh;
	struct sr_meta_keydisk	*skm;
	struct sr_meta_opt_head som;
	struct sr_chunk		*key_disk = NULL;
	struct disklabel	label;
	struct vnode		*vn = NULL;
	char			devname[32];
	int			c, part, open = 0;

	/*
	 * Load a key disk and load keying material into memory.
	 */

	SLIST_INIT(&som);

	sr_meta_getdevname(sc, dev, devname, sizeof(devname));

	/* Make sure chunk is not already in use. */
	c = sr_chunk_in_use(sc, dev);
	if (c != BIOC_SDINVALID && c != BIOC_SDOFFLINE) {
		sr_error(sc, "%s is already in use", devname);
		goto done;
	}

	/* Open device. */
	if (bdevvp(dev, &vn)) {
		sr_error(sc, "cannot open key disk %s", devname);
		goto done;
	}
	if (VOP_OPEN(vn, FREAD, NOCRED, curproc)) {
		DNPRINTF(SR_D_META,"%s: sr_crypto_read_key_disk cannot "
		    "open %s\n", DEVNAME(sc), devname);
		vput(vn);
		goto done;
	}
	open = 1; /* close dev on error */

	/* Get partition details. */
	part = DISKPART(dev);
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD,
	    NOCRED, curproc)) {
		DNPRINTF(SR_D_META, "%s: sr_crypto_read_key_disk ioctl "
		    "failed\n", DEVNAME(sc));
		goto done;
	}
	if (label.d_partitions[part].p_fstype != FS_RAID) {
		sr_error(sc, "%s partition not of type RAID (%d)",
		    devname, label.d_partitions[part].p_fstype);
		goto done;
	}

	/*
	 * Read and validate key disk metadata.
	 */
	sm = malloc(SR_META_SIZE * DEV_BSIZE, M_DEVBUF, M_WAITOK | M_ZERO);
	if (sr_meta_native_read(sd, dev, sm, NULL)) {
		sr_error(sc, "native bootprobe could not read native metadata");
		goto done;
	}

	if (sr_meta_validate(sd, dev, sm, NULL)) {
		DNPRINTF(SR_D_META, "%s: invalid metadata\n",
		    DEVNAME(sc));
		goto done;
	}

	/* Make sure this is a key disk. */
	if (sm->ssdi.ssd_level != SR_KEYDISK_LEVEL) {
		sr_error(sc, "%s is not a key disk", devname);
		goto done;
	}

	/* Construct key disk chunk. */
	key_disk = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_WAITOK | M_ZERO);
	key_disk->src_dev_mm = dev;
	key_disk->src_vn = vn;
	key_disk->src_size = 0;

	memcpy(&key_disk->src_meta, (struct sr_meta_chunk *)(sm + 1),
	    sizeof(key_disk->src_meta));

	/* Read mask key from optional metadata. */
	sr_meta_opt_load(sc, sm, &som);
	SLIST_FOREACH(omi, &som, omi_link) {
		omh = omi->omi_som;
		if (omh->som_type == SR_OPT_KEYDISK) {
			skm = (struct sr_meta_keydisk *)omh;
			memcpy(sd->mds.mdd_crypto.scr_maskkey, &skm->skm_maskkey,
			    sizeof(sd->mds.mdd_crypto.scr_maskkey));
		} else if (omh->som_type == SR_OPT_CRYPTO) {
			/* Original keydisk format with key in crypto area. */
			memcpy(sd->mds.mdd_crypto.scr_maskkey,
			    omh + sizeof(struct sr_meta_opt_hdr),
			    sizeof(sd->mds.mdd_crypto.scr_maskkey));
		}
	}

	open = 0;

done:
	for (omi = SLIST_FIRST(&som); omi != NULL; omi = omi_next) {
		omi_next = SLIST_NEXT(omi, omi_link);
		free(omi->omi_som, M_DEVBUF, 0);
		free(omi, M_DEVBUF, 0);
	}

	free(sm, M_DEVBUF, SR_META_SIZE * DEV_BSIZE);

	if (vn && open) {
		VOP_CLOSE(vn, FREAD, NOCRED, curproc);
		vput(vn);
	}

	return key_disk;
}

static void
sr_crypto_free_sessions(struct sr_discipline *sd)
{
	u_int			i;

	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		if (sd->mds.mdd_crypto.scr_sid[i] != (u_int64_t)-1) {
			crypto_freesession(sd->mds.mdd_crypto.scr_sid[i]);
			sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;
		}
	}
}

int
sr_crypto_alloc_resources(struct sr_discipline *sd)
{
	struct sr_workunit	*wu;
	struct sr_crypto_wu	*crwu;
	struct cryptoini	cri;
	u_int			num_keys, i;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	sd->mds.mdd_crypto.scr_alg = CRYPTO_AES_XTS;
	switch (sd->mds.mdd_crypto.scr_meta->scm_alg) {
	case SR_CRYPTOA_AES_XTS_128:
		sd->mds.mdd_crypto.scr_klen = 256;
		break;
	case SR_CRYPTOA_AES_XTS_256:
		sd->mds.mdd_crypto.scr_klen = 512;
		break;
	default:
		sr_error(sd->sd_sc, "unknown crypto algorithm");
		return (EINVAL);
	}

	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++)
		sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;

	if (sr_wu_alloc(sd, sizeof(struct sr_crypto_wu))) {
		sr_error(sd->sd_sc, "unable to allocate work units");
		return (ENOMEM);
	}
	if (sr_ccb_alloc(sd)) {
		sr_error(sd->sd_sc, "unable to allocate CCBs");
		return (ENOMEM);
	}
	if (sr_crypto_decrypt_key(sd)) {
		sr_error(sd->sd_sc, "incorrect key or passphrase");
		return (EPERM);
	}

	/*
	 * For each work unit allocate the uio, iovec and crypto structures.
	 * These have to be allocated now because during runtime we cannot
	 * fail an allocation without failing the I/O (which can cause real
	 * problems).
	 */
	TAILQ_FOREACH(wu, &sd->sd_wu, swu_next) {
		crwu = (struct sr_crypto_wu *)wu;
		crwu->cr_uio.uio_iov = &crwu->cr_iov;
		crwu->cr_dmabuf = dma_alloc(MAXPHYS, PR_WAITOK);
		crwu->cr_crp = crypto_getreq(MAXPHYS >> DEV_BSHIFT);
		if (crwu->cr_crp == NULL)
			return (ENOMEM);
	}

	memset(&cri, 0, sizeof(cri));
	cri.cri_alg = sd->mds.mdd_crypto.scr_alg;
	cri.cri_klen = sd->mds.mdd_crypto.scr_klen;

	/* Allocate a session for every 2^SR_CRYPTO_KEY_BLKSHIFT blocks. */
	num_keys = ((sd->sd_meta->ssdi.ssd_size - 1) >>
	    SR_CRYPTO_KEY_BLKSHIFT) + 1;
	if (num_keys > SR_CRYPTO_MAXKEYS)
		return (EFBIG);
	for (i = 0; i < num_keys; i++) {
		cri.cri_key = sd->mds.mdd_crypto.scr_key[i];
		if (crypto_newsession(&sd->mds.mdd_crypto.scr_sid[i],
		    &cri, 0) != 0) {
			sr_crypto_free_sessions(sd);
			return (EINVAL);
		}
	}

	sr_hotplug_register(sd, sr_crypto_hotplug);

	return (0);
}

void
sr_crypto_free_resources(struct sr_discipline *sd)
{
	struct sr_workunit	*wu;
	struct sr_crypto_wu	*crwu;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_free_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sd->mds.mdd_crypto.key_disk != NULL) {
		explicit_bzero(sd->mds.mdd_crypto.key_disk,
		    sizeof(*sd->mds.mdd_crypto.key_disk));
		free(sd->mds.mdd_crypto.key_disk, M_DEVBUF,
		    sizeof(*sd->mds.mdd_crypto.key_disk));
	}

	sr_hotplug_unregister(sd, sr_crypto_hotplug);

	sr_crypto_free_sessions(sd);

	TAILQ_FOREACH(wu, &sd->sd_wu, swu_next) {
		crwu = (struct sr_crypto_wu *)wu;
		if (crwu->cr_dmabuf)
			dma_free(crwu->cr_dmabuf, MAXPHYS);
		if (crwu->cr_crp)
			crypto_freereq(crwu->cr_crp);
	}

	sr_wu_free(sd);
	sr_ccb_free(sd);
}

int
sr_crypto_ioctl(struct sr_discipline *sd, struct bioc_discipline *bd)
{
	struct sr_crypto_kdfpair kdfpair;
	struct sr_crypto_kdfinfo kdfinfo1, kdfinfo2;
	int			size, rv = 1;

	DNPRINTF(SR_D_IOCTL, "%s: sr_crypto_ioctl %u\n",
	    DEVNAME(sd->sd_sc), bd->bd_cmd);

	switch (bd->bd_cmd) {
	case SR_IOCTL_GET_KDFHINT:

		/* Get KDF hint for userland. */
		size = sizeof(sd->mds.mdd_crypto.scr_meta->scm_kdfhint);
		if (bd->bd_data == NULL || bd->bd_size > size)
			goto bad;
		if (copyout(sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    bd->bd_data, bd->bd_size))
			goto bad;

		rv = 0;

		break;

	case SR_IOCTL_CHANGE_PASSPHRASE:

		/* Attempt to change passphrase. */

		size = sizeof(kdfpair);
		if (bd->bd_data == NULL || bd->bd_size > size)
			goto bad;
		if (copyin(bd->bd_data, &kdfpair, size))
			goto bad;

		size = sizeof(kdfinfo1);
		if (kdfpair.kdfinfo1 == NULL || kdfpair.kdfsize1 > size)
			goto bad;
		if (copyin(kdfpair.kdfinfo1, &kdfinfo1, size))
			goto bad;

		size = sizeof(kdfinfo2);
		if (kdfpair.kdfinfo2 == NULL || kdfpair.kdfsize2 > size)
			goto bad;
		if (copyin(kdfpair.kdfinfo2, &kdfinfo2, size))
			goto bad;

		if (sr_crypto_change_maskkey(sd, &kdfinfo1, &kdfinfo2))
			goto bad;

		/* Save metadata to disk. */
		rv = sr_meta_save(sd, SR_META_DIRTY);

		break;
	}

bad:
	explicit_bzero(&kdfpair, sizeof(kdfpair));
	explicit_bzero(&kdfinfo1, sizeof(kdfinfo1));
	explicit_bzero(&kdfinfo2, sizeof(kdfinfo2));

	return (rv);
}

int
sr_crypto_meta_opt_handler(struct sr_discipline *sd, struct sr_meta_opt_hdr *om)
{
	int rv = EINVAL;

	if (om->som_type == SR_OPT_CRYPTO) {
		sd->mds.mdd_crypto.scr_meta = (struct sr_meta_crypto *)om;
		rv = 0;
	}

	return (rv);
}

int
sr_crypto_rw(struct sr_workunit *wu)
{
	struct sr_crypto_wu	*crwu;
	daddr_t			blkno;
	int			rv = 0;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw wu %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu);

	if (sr_validate_io(wu, &blkno, "sr_crypto_rw"))
		return (1);

	if (wu->swu_xs->flags & SCSI_DATA_OUT) {
		crwu = sr_crypto_prepare(wu, 1);
		crwu->cr_crp->crp_callback = sr_crypto_write;
		rv = crypto_dispatch(crwu->cr_crp);
		if (rv == 0)
			rv = crwu->cr_crp->crp_etype;
	} else
		rv = sr_crypto_dev_rw(wu, NULL);

	return (rv);
}

void
sr_crypto_write(struct cryptop *crp)
{
	struct sr_crypto_wu	*crwu = crp->crp_opaque;
	struct sr_workunit	*wu = &crwu->cr_wu;
	int			s;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_write: wu %p xs: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu, wu->swu_xs);

	if (crp->crp_etype) {
		/* fail io */
		wu->swu_xs->error = XS_DRIVER_STUFFUP;
		s = splbio();
		sr_scsi_done(wu->swu_dis, wu->swu_xs);
		splx(s);
	}

	sr_crypto_dev_rw(wu, crwu);
}

int
sr_crypto_dev_rw(struct sr_workunit *wu, struct sr_crypto_wu *crwu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
	struct uio		*uio;
	daddr_t			blkno;

	blkno = wu->swu_blk_start;

	ccb = sr_ccb_rw(sd, 0, blkno, xs->datalen, xs->data, xs->flags, 0);
	if (!ccb) {
		/* should never happen but handle more gracefully */
		printf("%s: %s: too many ccbs queued\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);
		goto bad;
	}
	if (!ISSET(xs->flags, SCSI_DATA_IN)) {
		uio = crwu->cr_crp->crp_buf;
		ccb->ccb_buf.b_data = uio->uio_iov->iov_base;
		ccb->ccb_opaque = crwu;
	}
	sr_wu_enqueue_ccb(wu, ccb);
	sr_schedule_wu(wu);

	return (0);

bad:
	/* wu is unwound by sr_wu_put */
	if (crwu)
		crwu->cr_crp->crp_etype = EINVAL;
	return (1);
}

void
sr_crypto_done(struct sr_workunit *wu)
{
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_crypto_wu	*crwu;
	int			s;

	/* If this was a successful read, initiate decryption of the data. */
	if (ISSET(xs->flags, SCSI_DATA_IN) && xs->error == XS_NOERROR) {
		crwu = sr_crypto_prepare(wu, 0);
		crwu->cr_crp->crp_callback = sr_crypto_read;
		DNPRINTF(SR_D_INTR, "%s: sr_crypto_done: crypto_dispatch %p\n",
		    DEVNAME(wu->swu_dis->sd_sc), crwu->cr_crp);
		crypto_dispatch(crwu->cr_crp);
		return;
	}

	s = splbio();
	sr_scsi_done(wu->swu_dis, wu->swu_xs);
	splx(s);
}

void
sr_crypto_read(struct cryptop *crp)
{
	struct sr_crypto_wu	*crwu = crp->crp_opaque;
	struct sr_workunit	*wu = &crwu->cr_wu;
	int			s;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_read: wu %p xs: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu, wu->swu_xs);

	if (crp->crp_etype)
		wu->swu_xs->error = XS_DRIVER_STUFFUP;

	s = splbio();
	sr_scsi_done(wu->swu_dis, wu->swu_xs);
	splx(s);
}

void
sr_crypto_hotplug(struct sr_discipline *sd, struct disk *diskp, int action)
{
	DNPRINTF(SR_D_MISC, "%s: sr_crypto_hotplug: %s %d\n",
	    DEVNAME(sd->sd_sc), diskp->dk_name, action);
}

#ifdef SR_DEBUG0
void
sr_crypto_dumpkeys(struct sr_discipline *sd)
{
	int			i, j;

	printf("sr_crypto_dumpkeys:\n");
	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		printf("\tscm_key[%d]: 0x", i);
		for (j = 0; j < SR_CRYPTO_KEYBYTES; j++) {
			printf("%02x",
			    sd->mds.mdd_crypto.scr_meta->scm_key[i][j]);
		}
		printf("\n");
	}
	printf("sr_crypto_dumpkeys: runtime data keys:\n");
	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		printf("\tscr_key[%d]: 0x", i);
		for (j = 0; j < SR_CRYPTO_KEYBYTES; j++) {
			printf("%02x",
			    sd->mds.mdd_crypto.scr_key[i][j]);
		}
		printf("\n");
	}
}
#endif	/* SR_DEBUG */
@


1.136
log
@Fix another long standing softraid crypto bug where if all 32 keys are in
use, when freeing crypto sessions we run straight off the end of the array
and start blatting memory - clearly no one has a softraid crypto volume
that exceeds 15.5TB in size...
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.135 2017/06/12 15:09:07 jsing Exp $ */
d140 7
a146 1
        }
@


1.135
log
@Factor out and reuse the code that frees the crypto sessions, instead of
duplicating it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.134 2017/06/12 14:46:00 jsing Exp $ */
d896 5
a900 3
	for (i = 0; sd->mds.mdd_crypto.scr_sid[i] != (u_int64_t)-1; i++) {
		crypto_freesession(sd->mds.mdd_crypto.scr_sid[i]);
		sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;
@


1.134
log
@Fix a long standing off-by-one bug in the softraid crypto number of keys
calculation - we allow one key per 0.5TB, which should allow up to 16TB
disks, however the disk size was treated like a block offset and shifted.
This meant that the maximum size was actually 16TB minus one block.

While here also calculate the number of keys as an absolute value, rather
than as the upper inclusive bound - adjust the logic in the associated for
and if statements to match.

ok krw@@ tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.133 2017/02/07 17:25:46 patrick Exp $ */
d891 11
d970 1
a970 7
			for (i = 0;
			     sd->mds.mdd_crypto.scr_sid[i] != (u_int64_t)-1;
			     i++) {
				crypto_freesession(
				    sd->mds.mdd_crypto.scr_sid[i]);
				sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;
			}
a984 1
	u_int			i;
d998 1
a998 4
	for (i = 0; sd->mds.mdd_crypto.scr_sid[i] != (u_int64_t)-1; i++) {
		crypto_freesession(sd->mds.mdd_crypto.scr_sid[i]);
		sd->mds.mdd_crypto.scr_sid[i] = (u_int64_t)-1;
	}
@


1.133
log
@Reduce the per-packet allocation costs for crypto operations (cryptop)
by pre-allocating two cryptodesc objects and storing them in an array
instead of a linked list.  If more than two cryptodesc objects are
required use mallocarray to fetch them.  Adapt the drivers to the new
API.

This change results in one pool-get per ESP packet instead of three.
It also simplifies softraid crypto where more cryptodesc objects are
allocated than used.

From, with and ok markus@@, ok bluhm@@
"looks sane" mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.132 2017/02/07 15:10:48 bluhm Exp $ */
d951 3
a953 2
	num_keys = sd->sd_meta->ssdi.ssd_size >> SR_CRYPTO_KEY_BLKSHIFT;
	if (num_keys >= SR_CRYPTO_MAXKEYS)
d955 1
a955 1
	for (i = 0; i <= num_keys; i++) {
@


1.132
log
@The return code of crp_callback is never checked, so it is not
useful to propagate the error.  When an error occurs in an asynchronous
network path, incrementing a counter is the right thing.  There are
four places where an error is not accounted, just add a comment for
now.
OK mpi@@ visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.131 2016/09/08 17:39:08 jsing Exp $ */
a66 1
	struct cryptodesc		*cr_descs;
d272 1
a272 1
	 * Since there may be less than that we need to tweak the linked list
d275 2
a276 6
	crd = crwu->cr_descs;
	for (i = 0; i < ((MAXPHYS >> DEV_BSHIFT) - n); i++) {
		crd = crd->crd_next;
		KASSERT(crd);
	}
	crwu->cr_crp->crp_desc = crd;
d295 2
a296 2
	for (i = 0, crd = crwu->cr_crp->crp_desc; crd;
	    i++, blkno++, crd = crd->crd_next) {
a943 1
		crwu->cr_descs = crwu->cr_crp->crp_desc;
d1002 1
a1002 2
		if (crwu->cr_crp) {
			crwu->cr_crp->crp_desc = crwu->cr_descs;
a1003 1
		}
@


1.131
log
@When changing the mask key, copy the new KDF hint to the metadata, if it
has been supplied. This allows for passphrase changes to use different
KDF configurations to what was used when the volume was created.

Similar diffs from djm@@ and halex@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.130 2016/05/31 15:11:26 jsing Exp $ */
d91 1
a91 1
int		sr_crypto_write(struct cryptop *);
d95 1
a95 1
int		sr_crypto_read(struct cryptop *);
d1120 1
a1120 1
int
d1138 1
a1138 1
	return (sr_crypto_dev_rw(wu, crwu));
d1198 1
a1198 1
int
a1213 2

	return (0);
@


1.130
log
@Ensure that softraid crypto is not run on the crypto taskq.

When softraid crypto was written, it was intended that all crypto
operations would be run by softraid. As such, it called crypto_invoke()
directly, rather than crypto_dispatch() which would queue the task for
later processing. However, r1.53 of crypto/crypto.c started running
completion callbacks as a separate task. This leads to deadlocks with the
crypto taskq blocking in biowait, when softraid crypto volumes are stacked
(often with vnds).

In order to avoid task queueing and ensure that the operations are run
within softraid, set the CRYPTO_F_NOQUEUE flag. With r1.62 of
crypto/crypto.c crypto_dispatch() also started respecting this flag, hence
we can also switch back to calling the standard crypto_dispatch()
interface, rather than calling crypto_invoke() directly.

Tested by Peter Wens (peter at wenka dot nl) - thanks!

ok krw@@ mlarkin@@ mikeb@@ tedu@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.129 2016/05/28 00:10:36 tedu Exp $ */
d568 11
@


1.129
log
@no need to open key disk for writing, from bytevolcano. ok jung
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.128 2016/05/21 14:19:03 jsing Exp $ */
d298 1
a298 1
	crwu->cr_crp->crp_flags = CRYPTO_F_IOV;
d1100 1
a1100 1
		rv = crypto_invoke(crwu->cr_crp);
d1176 1
a1176 1
		DNPRINTF(SR_D_INTR, "%s: sr_crypto_done: crypto_invoke %p\n",
d1178 1
a1178 1
		crypto_invoke(crwu->cr_crp);
@


1.128
log
@Remove another erroneous VOP_CLOSE/vput, which was missed with the last
commit. While here, also be consistent with the goto labels used.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.127 2016/05/17 19:28:59 tedu Exp $ */
d798 1
a798 1
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, curproc)) {
@


1.127
log
@remove VOP_CLOSE and vput that will be handled in the epilogue.
part of a diff by bytevolcano. ok jung
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.126 2016/04/12 16:26:54 krw Exp $ */
d639 1
a639 1
		goto fail;
d649 1
a649 1
		goto fail;
d654 1
a654 1
		goto fail;
a811 2
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
@


1.126
log
@No need to rescan chunks in each discipline to find appropriate
volume sector size.  Determine volume sector size in sr_meta_init().

Pointed out, tweaked and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.125 2016/04/04 18:48:39 krw Exp $ */
a648 2
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, curproc);
		vput(vn);
@


1.125
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.124 2015/12/29 04:46:28 mmcc Exp $ */
a181 1
	sd->sd_meta->ssdi.ssd_secsize = sd->sd_vol.sv_chunks[0]->src_secsize;
@


1.124
log
@Remove NULL-checks before free().

ok tb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.123 2015/11/05 20:03:04 naddy Exp $ */
d182 1
a653 5
	if (label.d_secsize != DEV_BSIZE) {
		sr_error(sc, "%s has unsupported sector size (%d)",
		    devname, label.d_secsize);
		goto fail;
	}
a816 5
		goto done;
	}
	if (label.d_secsize != DEV_BSIZE) {
		sr_error(sc, "%s has unsupported sector size (%d)",
		    devname, label.d_secsize);
@


1.123
log
@explicitly say that we use uio for our crypto operations; ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.122 2015/07/27 04:11:58 halex Exp $ */
d885 1
a885 2
		if (omi->omi_som)
			free(omi->omi_som, M_DEVBUF, 0);
@


1.122
log
@zap trailing linefeeds from sr_error() and panic() calls

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.121 2015/07/21 03:30:51 krw Exp $ */
d298 1
@


1.121
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.120 2015/07/19 17:20:15 krw Exp $ */
d658 1
a658 1
		sr_error(sc, "%s partition not of type RAID (%d)\n",
d828 1
a828 1
		sr_error(sc, "%s partition not of type RAID (%d)\n",
@


1.120
log
@Oops. Missed a file from offset commit.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.119 2015/07/19 16:12:10 krw Exp $ */
d253 1
a253 1
	daddr_t			blk;
d268 1
a268 1
	blk = wu->swu_blk_start;
d292 1
a292 1
	keyndx = blk >> SR_CRYPTO_KEY_BLKSHIFT;
d300 1
a300 1
	    i++, blk++, crd = crd->crd_next) {
d308 1
a308 1
		memcpy(crd->crd_iv, &blk, sizeof(blk));
d1102 1
a1102 1
	daddr_t			blk;
d1108 1
a1108 1
	if (sr_validate_io(wu, &blk, "sr_crypto_rw"))
d1151 1
a1151 1
	daddr_t			blk;
d1153 1
a1153 1
	blk = wu->swu_blk_start;
d1155 1
a1155 1
	ccb = sr_ccb_rw(sd, 0, blk, xs->datalen, xs->data, xs->flags, 0);
@


1.119
log
@Use DEV_BSIZE instead of 512 where appropriate. Use DL_SECTOBLK()
where appropriate. Noop for disks with 512-byte sectors. i.e. the
only kind currently allowed in softraid volumes. But starts laying
the groundwork to allow disks with other sector sizes.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.118 2015/07/05 20:51:33 mlarkin Exp $ */
a1153 1
	blk += sd->sd_meta->ssd_data_offset;
@


1.118
log
@
fix a format specifier used in SR_DEBUG printfs.

from Karel Gardas (gardask at gmail.com)
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.117 2015/03/14 03:38:46 jsg Exp $ */
d836 1
a836 1
	sm = malloc(SR_META_SIZE * 512, M_DEVBUF, M_WAITOK | M_ZERO);
d889 1
a889 1
	free(sm, M_DEVBUF, SR_META_SIZE * 512);
@


1.117
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.116 2014/12/19 17:15:16 tedu Exp $ */
d1130 1
a1130 1
	DNPRINTF(SR_D_INTR, "%s: sr_crypto_write: wu %x xs: %x\n",
d1209 1
a1209 1
	DNPRINTF(SR_D_INTR, "%s: sr_crypto_read: wu %x xs: %x\n",
@


1.116
log
@bcopy to memcpy. ok deraadt millert
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.115 2014/11/18 02:37:30 tedu Exp $ */
a44 1
#include <crypto/cryptosoft.h>
@


1.115
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.114 2014/10/30 17:26:23 tedu Exp $ */
d207 1
a207 1
		bcopy(data, sd->mds.mdd_crypto.scr_maskkey,
d265 1
a265 1
		bcopy(xs->data, crwu->cr_uio.uio_iov->iov_base, xs->datalen);
d309 1
a309 1
		bcopy(&blk, crd->crd_iv, sizeof(blk));
d340 2
a341 3
		bcopy(&kdfinfo->genkdf,
		    sd->mds.mdd_crypto.scr_meta->scm_kdfhint,
		    kdfinfo->genkdf.len);
d349 1
a349 1
		bcopy(&kdfinfo->maskkey, sd->mds.mdd_crypto.scr_maskkey,
d583 1
a583 1
	bcopy(check_digest, sd->mds.mdd_crypto.scr_meta->chk_hmac_sha1.sch_mac,
d681 1
a681 1
	bcopy(&sd->sd_meta->ssdi.ssd_uuid, &km->scmi.scm_uuid,
d698 1
a698 1
	bcopy(&sd->sd_meta->ssdi.ssd_uuid, &sm->ssdi.ssd_uuid,
d738 1
a738 1
	bcopy(sd->mds.mdd_crypto.scr_maskkey, &skm->skm_maskkey,
d861 1
a861 1
	bcopy((struct sr_meta_chunk *)(sm + 1), &key_disk->src_meta,
d870 1
a870 2
			bcopy(&skm->skm_maskkey,
			    sd->mds.mdd_crypto.scr_maskkey,
d874 2
a875 2
			bcopy(omh + sizeof(struct sr_meta_opt_hdr),
			    sd->mds.mdd_crypto.scr_maskkey,
@


1.114
log
@zero the correct size, then free it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.113 2014/10/30 17:23:45 tedu Exp $ */
a56 1
#include <dev/rndvar.h>
@


1.113
log
@add some sizes to free()
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.112 2014/09/14 14:17:24 jsg Exp $ */
d999 3
a1001 3
		    sizeof(sd->mds.mdd_crypto.key_disk));
		/* XXX correct size? XXX */
		free(sd->mds.mdd_crypto.key_disk, M_DEVBUF, 0);
@


1.112
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.111 2014/09/13 16:06:37 doug Exp $ */
d359 1
a359 1
	free(kdfinfo, M_DEVBUF, 0);
d593 1
a593 1
		free(p, M_DEVBUF, 0);
d754 1
a754 2
	if (key_disk)
		free(key_disk, M_DEVBUF, 0);
d758 1
a758 2
	if (omi)
		free(omi, M_DEVBUF, 0);
d760 4
a763 5
		free(fakesd->sd_vol.sv_chunks, M_DEVBUF, 0);
	if (fakesd)
		free(fakesd, M_DEVBUF, 0);
	if (sm)
		free(sm, M_DEVBUF, 0);
d893 1
a893 2
	if (sm)
		free(sm, M_DEVBUF, 0);
d998 3
a1000 2
		explicit_bzero(sd->mds.mdd_crypto.key_disk, sizeof
		    sd->mds.mdd_crypto.key_disk);
@


1.111
log
@Replace all queue *_END macro calls except CIRCLEQ_END with NULL.

CIRCLEQ_* is deprecated and not called in the tree.  The other queue types
have *_END macros which were added for symmetry with CIRCLEQ_END.  They are
defined as NULL.  There's no reason to keep the other *_END macro calls.

ok millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.110 2014/07/12 18:48:51 tedu Exp $ */
a27 1
#include <sys/proc.h>
@


1.110
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.109 2014/01/22 01:46:08 jsing Exp $ */
d890 1
a890 1
	for (omi = SLIST_FIRST(&som); omi != SLIST_END(&som); omi = omi_next) {
@


1.109
log
@Remove a pesky free that was supposed to be removed in an earlier commit.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.108 2014/01/21 06:38:11 jsing Exp $ */
d360 1
a360 1
	free(kdfinfo, M_DEVBUF);
d594 1
a594 1
		free(p, M_DEVBUF);
d756 1
a756 1
		free(key_disk, M_DEVBUF);
d761 1
a761 1
		free(omi, M_DEVBUF);
d763 1
a763 1
		free(fakesd->sd_vol.sv_chunks, M_DEVBUF);
d765 1
a765 1
		free(fakesd, M_DEVBUF);
d767 1
a767 1
		free(sm, M_DEVBUF);
d893 2
a894 2
			free(omi->omi_som, M_DEVBUF);
		free(omi, M_DEVBUF);
d898 1
a898 1
		free(sm, M_DEVBUF);
d1005 1
a1005 1
		free(sd->mds.mdd_crypto.key_disk, M_DEVBUF);
@


1.108
log
@Remove unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.107 2014/01/21 05:52:25 jsing Exp $ */
a1022 1
		free(crwu, M_DEVBUF);
@


1.107
log
@Do not bother calling splvm around crypto_invoke(), as crypto_invoke()
already calls splvm as necessary.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.106 2014/01/21 05:22:21 jsing Exp $ */
d1112 1
a1112 1
	int			s, rv = 0;
@


1.106
log
@Remove sr_crypto_finish_io - we can just call sr_scsi_done instead now.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.105 2014/01/21 05:11:12 jsing Exp $ */
a1122 1
		s = splvm();
a1125 1
		splx(s);
d1200 1
a1200 1
		DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: crypto_invoke %p\n",
a1201 1
		s = splvm();
a1202 1
		splx(s);
@


1.105
log
@Instead of maintaining a completely separate list of crypto work units,
simply allocate larger work units and include the normal work unit struct
in the top of the crypto work unit struct.

This greatly simplifies the code and removes possible failure cases.

Discussed with dlg@@

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.104 2014/01/21 04:23:14 jsing Exp $ */
a98 1
void		sr_crypto_finish_io(struct sr_workunit *);
d1148 1
a1148 1
		sr_crypto_finish_io(wu);
d1211 1
a1211 1
	sr_crypto_finish_io(wu);
a1214 17
void
sr_crypto_finish_io(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif /* SR_DEBUG */

	splassert(IPL_BIO);

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_finish_io: wu %x xs: %x\n",
	    DEVNAME(sc), wu, xs);

	sr_scsi_done(sd, xs);
}

d1229 1
a1229 1
	sr_crypto_finish_io(wu);
@


1.104
log
@Allow for variable sized work units.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.103 2014/01/21 03:21:38 jsing Exp $ */
d66 1
a66 1
	TAILQ_ENTRY(sr_crypto_wu)	 cr_link;
a70 1
	struct sr_workunit		*cr_wu;
d75 1
a75 2
struct sr_crypto_wu *sr_crypto_wu_get(struct sr_workunit *, int);
void		sr_crypto_wu_put(struct sr_crypto_wu *);
d250 1
a250 1
sr_crypto_wu_get(struct sr_workunit *wu, int encrypt)
d260 1
a260 1
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_wu_get wu %p encrypt %d\n",
d263 1
a263 7
	mtx_enter(&sd->mds.mdd_crypto.scr_mutex);
	if ((crwu = TAILQ_FIRST(&sd->mds.mdd_crypto.scr_wus)) != NULL)
		TAILQ_REMOVE(&sd->mds.mdd_crypto.scr_wus, crwu, cr_link);
	mtx_leave(&sd->mds.mdd_crypto.scr_mutex);
	if (crwu == NULL)
		panic("sr_crypto_wu_get: out of work units");

d299 1
a313 2
	crwu->cr_wu = wu;
	crwu->cr_crp->crp_opaque = crwu;
a317 14
void
sr_crypto_wu_put(struct sr_crypto_wu *crwu)
{
	struct sr_workunit	*wu = crwu->cr_wu;
	struct sr_discipline	*sd = wu->swu_dis;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_wu_put crwu: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), crwu);

	mtx_enter(&sd->mds.mdd_crypto.scr_mutex);
	TAILQ_INSERT_TAIL(&sd->mds.mdd_crypto.scr_wus, crwu, cr_link);
	mtx_leave(&sd->mds.mdd_crypto.scr_mutex);
}

d912 2
a914 1
	struct sr_crypto_wu	*crwu;
d936 1
a936 1
	if (sr_wu_alloc(sd, sizeof(struct sr_workunit))) {
d950 3
a952 3
	 * For each wu allocate the uio, iovec and crypto structures.
	 * these have to be allocated now because during runtime we can't
	 * fail an allocation without failing the io (which can cause real
d955 2
a956 12
	mtx_init(&sd->mds.mdd_crypto.scr_mutex, IPL_BIO);
	TAILQ_INIT(&sd->mds.mdd_crypto.scr_wus);
	for (i = 0; i < sd->sd_max_wu; i++) {
		crwu = malloc(sizeof(*crwu), M_DEVBUF,
		    M_WAITOK | M_ZERO | M_CANFAIL);
		if (crwu == NULL)
		    return (ENOMEM);
		/* put it on the list now so if we fail it'll be freed */
		mtx_enter(&sd->mds.mdd_crypto.scr_mutex);
		TAILQ_INSERT_TAIL(&sd->mds.mdd_crypto.scr_wus, crwu, cr_link);
		mtx_leave(&sd->mds.mdd_crypto.scr_mutex);

d969 1
a969 1
	/* Allocate a session for every 2^SR_CRYPTO_KEY_BLKSHIFT blocks */
d996 1
d1016 3
a1018 5
	mtx_enter(&sd->mds.mdd_crypto.scr_mutex);
	while ((crwu = TAILQ_FIRST(&sd->mds.mdd_crypto.scr_wus)) != NULL) {
		TAILQ_REMOVE(&sd->mds.mdd_crypto.scr_wus, crwu, cr_link);

		if (crwu->cr_dmabuf != NULL)
a1025 1
	mtx_leave(&sd->mds.mdd_crypto.scr_mutex);
d1122 1
a1122 3
		crwu = sr_crypto_wu_get(wu, 1);
		if (crwu == NULL)
			return (1);
d1139 1
a1139 1
	struct sr_workunit	*wu = crwu->cr_wu;
a1196 1
	struct sr_ccb		*ccb;
d1201 1
a1201 4
		/* only fails on implementation error */
		crwu = sr_crypto_wu_get(wu, 0);
		if (crwu == NULL)
			panic("sr_crypto_intr: no wu");
a1202 4
		ccb = TAILQ_FIRST(&wu->swu_ccb);
		if (ccb == NULL)
			panic("sr_crypto_done: no ccbs on workunit");
		ccb->ccb_opaque = crwu;
a1220 1
	struct sr_ccb		*ccb;
a1229 8
	if (wu->swu_cb_active == 1)
		panic("%s: sr_crypto_finish_io", DEVNAME(sd->sd_sc));
	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
		if (ccb->ccb_opaque == NULL)
			continue;
		sr_crypto_wu_put(ccb->ccb_opaque);
	}

d1237 1
a1237 1
	struct sr_workunit	*wu = crwu->cr_wu;
@


1.103
log
@Remove pointless validation - these cases cannot be hit as they have
already been checked in sr_crypto_alloc_resources and sr_validate_io.
Also document the known issue with per-block key selection.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.102 2014/01/20 10:54:54 jsing Exp $ */
d958 1
a958 1
	if (sr_wu_alloc(sd)) {
@


1.102
log
@Return a user friendly error if we ever encounter an unknown crypto
algorithm.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.101 2014/01/20 04:38:58 jsing Exp $ */
d297 7
a303 1
	/* Select crypto session based on block number */
a304 2
	if (keyndx >= SR_CRYPTO_MAXKEYS)
		goto unwind;
a305 2
	if (crwu->cr_crp->crp_sid == (u_int64_t)-1)
		goto unwind;
a324 3

unwind:
	return (NULL);
@


1.101
log
@Store the algorithm and key length in the discipline data structure,
instead of having multiple switch statements in various places.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.100 2014/01/20 04:16:29 jsing Exp $ */
d952 1
@


1.100
log
@Remove unused variable.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.99 2014/01/20 04:12:51 jsing Exp $ */
d314 2
a315 12
		crd->crd_alg = CRYPTO_AES_XTS;

		switch (sd->mds.mdd_crypto.scr_meta->scm_alg) {
		case SR_CRYPTOA_AES_XTS_128:
			crd->crd_klen = 256;
			break;
		case SR_CRYPTOA_AES_XTS_256:
			crd->crd_klen = 512;
			break;
		default:
			goto unwind;
		}
d943 12
d997 3
a999 12
	bzero(&cri, sizeof(cri));
	cri.cri_alg = CRYPTO_AES_XTS;
	switch (sd->mds.mdd_crypto.scr_meta->scm_alg) {
	case SR_CRYPTOA_AES_XTS_128:
		cri.cri_klen = 256;
		break;
	case SR_CRYPTOA_AES_XTS_256:
		cri.cri_klen = 512;
		break;
	default:
		return (EINVAL);
	}
@


1.99
log
@Do not bother setting crp_desc to NULL, since it does not really gain us
anything.

ok mikeb@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.98 2013/12/21 20:46:20 guenther Exp $ */
a340 1
	struct cryptop		*crp = crwu->cr_crp;
@


1.98
log
@Don't assign a literal number to a variable that otherwise holds an errno.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.97 2013/11/19 15:12:13 krw Exp $ */
a334 3
	/* steal the descriptors back from the cryptop */
	crwu->cr_crp->crp_desc = NULL;

a347 3
	/* steal the descriptors back from the cryptop */
	crp->crp_desc = NULL;

a992 1
		/* steal the list of cryptodescs */
a993 1
		crwu->cr_crp->crp_desc = NULL;
a1061 1
			/* twiddle cryptoreq back */
@


1.97
log
@Print daddr_t's with %lld, size_t's with %zu, int's with %d and
u_int32_t's with %u.

Translate DL_GETPSIZE() results to 512-byte-block values with
DL_SECTOBLK().

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.96 2013/11/04 21:02:57 deraadt Exp $ */
d1178 2
a1179 3
		if (crypto_invoke(crwu->cr_crp))
			rv = 1;
		else
@


1.96
log
@substantial namespace cleanup.  Might go a little bit too far, but we
can expose some of the kernel structures with split .h files if need be.
Discussed with various, including jsing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.95 2013/06/11 16:42:13 deraadt Exp $ */
d422 1
a422 1
		DNPRINTF(SR_D_DIS, "%s: unsupported encryption algorithm %u\n",
d448 1
a448 1
		DNPRINTF(SR_D_DIS, "%s: unsupported encryption algorithm %u\n",
@


1.95
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.94 2013/05/21 15:01:53 jsing Exp $ */
d37 1
@


1.94
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.93 2013/04/01 15:17:32 jsing Exp $ */
d258 1
a258 1
	daddr64_t		blk;
d1162 1
a1162 1
	daddr64_t		blk;
d1216 1
a1216 1
	daddr64_t		blk;
@


1.93
log
@Rename sr_crypto_rw2() to sr_crypto_dev_rw(), which actually reflects the
fact that it is used to generate I/O to the underlying device.

Input from/ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.92 2013/04/01 07:58:43 jsing Exp $ */
a1216 1
	int			s;
d1234 1
d1236 1
a1236 4
	s = splbio();

	if (sr_check_io_collision(wu))
		goto queued;
a1237 5
	sr_raid_startwu(wu);

queued:
	splx(s);
	return (0);
@


1.92
log
@Validate the I/O request when it is first received, rather than waiting
until disk I/O is performed. This avoids doing encryption for a write
that has an invalid I/O request. Additionally sr_crypto_wu_get() can
get the block number from the work unit, instead of decoding the SCSI
command (and failing to handle the invalid case).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.91 2013/03/31 15:44:52 jsing Exp $ */
d97 1
a97 1
int		sr_crypto_rw2(struct sr_workunit *, struct sr_crypto_wu *);
d1183 1
a1183 1
		rv = sr_crypto_rw2(wu, NULL);
d1206 1
a1206 1
	return (sr_crypto_rw2(wu, crwu));
d1210 1
a1210 1
sr_crypto_rw2(struct sr_workunit *wu, struct sr_crypto_wu *crwu)
@


1.91
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.90 2013/03/31 11:37:40 jsing Exp $ */
d258 1
a258 1
	daddr64_t		blk = 0;
d261 1
a261 1
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_wu_get wu: %p encrypt: %d\n",
d269 1
a269 1
		panic("sr_crypto_wu_get: out of wus");
d279 1
a279 7
	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);

d1162 1
d1165 1
a1165 1
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw wu: %p\n",
d1168 3
d1216 1
a1217 4
	daddr64_t		blk;

	if (sr_validate_io(wu, &blk, "sr_crypto_rw2"))
		goto bad;
d1219 1
@


1.90
log
@The return value of sd_free_resources() is never checked and all of the
implementations only ever returned zero. Change the return value from
int to void instead of pretending it might mean something.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.89 2013/03/30 02:02:14 jsing Exp $ */
d143 2
a144 1
		sr_error(sd->sd_sc, "CRYPTO requires exactly one chunk");
@


1.89
log
@Provide a default discipline interrupt handling function and migrate all of
the disciplines that now have the same interrupt code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.88 2013/03/29 11:46:45 jsing Exp $ */
d90 1
a90 1
int		sr_crypto_free_resources(struct sr_discipline *);
d1045 1
a1045 1
int
a1047 1
	int			rv = EINVAL;
a1083 3

	rv = 0;
	return (rv);
@


1.88
log
@sd_wu_pending is only decremented when scsi_done() or scsi_io_put() are
called. As a result, factor out the the sd_sync check/wakeup code and move
it to after the scsi_done() call in sr_scsi_done(). Perform the same
sd_sync check/wakeup after scsi_io_put() calls (including the addition of
some that were previously missed).

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.87 2013/03/02 12:50:01 jsing Exp $ */
a97 1
void		sr_crypto_intr(struct buf *);
a131 1
	sd->sd_scsi_intr = sr_crypto_intr;
a1257 19
}

void
sr_crypto_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
#ifdef SR_DEBUG
	struct sr_discipline	*sd = wu->swu_dis;
#endif
	int			s;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr bp %x xs %x\n",
	    DEVNAME(sd->sd_sc), bp, wu->swu_xs);

	s = splbio();
	sr_ccb_done(ccb);
	sr_wu_done(wu);
	splx(s);
@


1.87
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.86 2013/01/18 23:22:18 jsing Exp $ */
a1336 3

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
@


1.86
log
@Convert softraid crypto to the new ccb and workunit completion functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.85 2013/01/16 06:42:22 jsing Exp $ */
a962 3
	if (!sd)
		return (EINVAL);

a1052 3

	if (!sd)
		return (rv);
@


1.85
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.84 2013/01/15 09:28:29 jsing Exp $ */
d99 1
d134 1
d1237 1
a1237 3
	wu->swu_io_count = 1;

	ccb = sr_ccb_get(sd);
d1244 1
a1244 12

	ccb->ccb_buf.b_flags = B_CALL | B_PHYS;
	ccb->ccb_buf.b_iodone = sr_crypto_intr;
	ccb->ccb_buf.b_blkno = blk;
	ccb->ccb_buf.b_bcount = xs->datalen;
	ccb->ccb_buf.b_bufsize = xs->datalen;
	ccb->ccb_buf.b_resid = xs->datalen;

	if (xs->flags & SCSI_DATA_IN) {
		ccb->ccb_buf.b_flags |= B_READ;
		ccb->ccb_buf.b_data = xs->data;
	} else {
a1245 1
		ccb->ccb_buf.b_flags |= B_WRITE;
d1249 1
a1249 21

	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_wu = wu;
	ccb->ccb_target = 0;
	ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[0]->src_dev_mm;
	ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[0]->src_vn;
	if ((ccb->ccb_buf.b_flags & B_READ) == 0)
		ccb->ccb_buf.b_vp->v_numoutput++;

	LIST_INIT(&ccb->ccb_buf.b_dep);

	if (wu->swu_cb_active == 1)
		panic("%s: sr_crypto_rw2", DEVNAME(sd->sd_sc));
	TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

	DNPRINTF(SR_D_DIS, "%s: %s: sr_crypto_rw2: b_bcount: %d "
	    "b_blkno: %x b_flags 0x%0x b_data %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
d1272 2
a1273 1
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
d1275 2
a1276 4
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	struct sr_crypto_wu	*crwu;
	int			s, s2, pend;
d1278 2
a1279 6
	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr bp: %x xs: %x\n",
	    DEVNAME(sc), bp, wu->swu_xs);

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x\n", DEVNAME(sc), ccb->ccb_buf.b_bcount,
	    ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags);
d1282 4
d1287 7
a1293 24
	if (ccb->ccb_buf.b_flags & B_ERROR) {
		printf("%s: i/o error on block %lld\n", DEVNAME(sc),
		    ccb->ccb_buf.b_blkno);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: comp: %d count: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count);

	if (wu->swu_ios_complete == wu->swu_io_count) {
		if (wu->swu_ios_failed == wu->swu_ios_complete)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;
d1295 17
a1311 37
		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
		}

		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		if ((xs->flags & SCSI_DATA_IN) && (xs->error == XS_NOERROR)) {
			/* only fails on implementation error */
			crwu = sr_crypto_wu_get(wu, 0);
			if (crwu == NULL)
				panic("sr_crypto_intr: no wu");
			crwu->cr_crp->crp_callback = sr_crypto_read;
			ccb->ccb_opaque = crwu;
			DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: crypto_invoke "
			    "%p\n", DEVNAME(sc), crwu->cr_crp);
			s2 = splvm();
			crypto_invoke(crwu->cr_crp);
			splx(s2);
			goto done;
		}

		sr_crypto_finish_io(wu);
d1314 2
a1315 1
done:
@


1.84
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.83 2013/01/15 04:03:01 jsing Exp $ */
a1401 2

	xs->resid = 0;
@


1.83
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.82 2012/10/09 11:57:33 jsing Exp $ */
d117 1
a184 1
	strlcpy(sd->sd_name, "CRYPTO", sizeof(sd->sd_name));
@


1.82
log
@Provide a mechanism for the kernel to directly pass a mask key through to
a crypto volume when it is assembling it.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.81 2012/10/08 14:22:41 jsing Exp $ */
d131 1
@


1.81
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.79 2012/01/22 11:13:32 jsing Exp $ */
d207 5
a211 1
	if (bc->bc_key_disk != NODEV) {
d238 2
a239 2

	}
@


1.80
log
@Prevent softraid from being used with devices that do not have a sector
size of 512 bytes - any other size is not currently supported.

ok krw@@
@
text
@d88 1
a88 1
		    struct bioc_createraid *, int);
d197 1
a197 1
    int no_chunk)
@


1.79
log
@Convert softraid(4) to new bio(4) status interface. This allows bioctl(8)
to provide useful feedback, rather than reporting an ioctl failure and
leaving the user to consult dmesg. For now we continue to print most things
to the console, even if the message is a result of an ioctl.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.77 2011/12/26 14:54:52 jsing Exp $ */
d697 5
d868 5
@


1.78
log
@Move list initialisation to the start of the function - this prevents us
from walking an uninitialised list if we fail to read the key disk.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.76 2011/12/25 15:28:17 jsing Exp $ */
d140 2
a141 1
	if (no_chunk != 1)
d143 1
d609 1
d670 1
a670 1
		printf("%s: %s is already in use\n", DEVNAME(sc), devname);
d676 1
a676 1
		printf("%s: cannot open key disk %s\n", DEVNAME(sc), devname);
d698 2
a699 3
		printf("%s: %s partition not of type RAID (%d)\n",
		    DEVNAME(sc), devname,
		    label.d_partitions[part].p_fstype);
d784 1
a784 2
		printf("%s: could not save metadata to %s\n",
		    DEVNAME(sc), devname);
d838 1
a838 1
		printf("%s: %s is already in use\n", DEVNAME(sc), devname);
d844 1
a844 1
		printf("%s: cannot open key disk %s\n", DEVNAME(sc), devname);
d866 2
a867 3
		printf("%s: %s partition not of type RAID (%d)\n",
		    DEVNAME(sc), devname,
		    label.d_partitions[part].p_fstype);
d876 1
a876 2
		printf("%s: native bootprobe could not read native "
		    "metadata\n", DEVNAME(sc));
d888 1
a888 1
		printf("%s: %s is not a key disk\n", DEVNAME(sc), devname);
d955 2
a956 1
	if (sr_wu_alloc(sd))
d958 3
a960 1
	if (sr_ccb_alloc(sd))
d962 3
a964 1
	if (sr_crypto_decrypt_key(sd))
d966 2
d1141 1
@


1.77
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d830 2
a902 1
	SLIST_INIT(&som);
@


1.76
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.74 2011/09/20 12:19:22 jsing Exp $ */
a130 3
	/* XXX reuse raid 1 functions for now FIXME */
	sd->sd_set_chunk_state = sr_raid1_set_chunk_state;
	sd->sd_set_vol_state = sr_raid1_set_vol_state;
@


1.75
log
@Mark softraid crypto volumes as being capable of auto assembly, since they
are if used with a key disk.
@
text
@d123 3
a125 1
	/* Setup discipline pointers. */
a126 2
	sd->sd_assemble = sr_crypto_assemble;
	sd->sd_alloc_resources = sr_crypto_alloc_resources;
a127 1
	sd->sd_start_discipline = NULL;
a129 6
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
@


1.74
log
@Simplify the crypto descriptor handling by changing the list head, instead
of splitting and rejoining the list.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.73 2011/09/18 19:40:49 jsing Exp $ */
d117 1
a117 1
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK;
@


1.73
log
@Add support for variable length optional metadata in softraid(4). This
will allow new optional metadata types to be added without needing to
change the softraid metadata version.

Note that this commit changes the softraid metadata version, however
an upgrade from older metadata is handled automatically. A full backup
prior to upgrading is still strongly recommended.

With feedback from stsp@@ and marco.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.72 2011/09/18 13:11:08 jsing Exp $ */
d60 3
a62 4
 * the per-io data that we need to preallocate. We can't afford to allow io
 * to start failing when memory pressure kicks in.
 * We can store this in the WU because we assert that only one
 * ccb per WU will ever be active.
a251 1

d291 2
a292 2
	 * we preallocated enough crypto descs for up to MAXPHYS of io.
	 * since ios may be less than that we need to tweak the linked list
a293 2
	 * Otherwise crypto will get upset with us. So put n descs on the crp
	 * and keep the rest.
d296 1
a296 2
	i = 0;
	while (++i < n) {
d300 1
a300 4
	crwu->cr_crp->crp_desc = crwu->cr_descs;
	crwu->cr_descs = crd->crd_next;
	crd->crd_next = NULL;

d340 1
d343 1
a343 3
	crd = crwu->cr_crp->crp_desc;
	while (crd->crd_next != NULL)
		crd = crd->crd_next;
a344 4
	/* join the lists back again */
	crd->crd_next = crwu->cr_descs;
	crwu->cr_descs = crwu->cr_crp->crp_desc;
	crwu->cr_crp->crp_desc = NULL;
a353 1
	struct cryptodesc	*crd;
d358 1
a358 9
	/* steal the descrptions back from the cryptop */
	crd = crp->crp_desc;
	KASSERT(crd);
	while (crd->crd_next != NULL)
		crd = crd->crd_next;

	/* join the lists back again */
	crd->crd_next = crwu->cr_descs;
	crwu->cr_descs = crp->crp_desc;
a1067 1
		/* twiddle cryptoreq back */
d1069 1
@


1.72
log
@Rename the optional metadata handler function and factor out the optional
metadata handling code. This will simplify upcoming changes.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.70 2011/07/05 19:02:47 oga Exp $ */
d95 1
a95 1
		    struct sr_meta_opt *);
d157 4
a160 1
	omi->omi_om.somi.som_type = SR_OPT_CRYPTO;
d162 1
a162 1
	sd->mds.mdd_crypto.scr_meta = &omi->omi_om.somi.som_meta.smm_crypto;
d682 1
a799 1
	sm->ssdi.ssd_opt_no = 1;
d802 7
a808 4
	omi->omi_om.somi.som_type = SR_OPT_KEYDISK;
	bcopy(sd->mds.mdd_crypto.scr_maskkey,
	    omi->omi_om.somi.som_meta.smm_keydisk.skm_maskkey,
	    sizeof(omi->omi_om.somi.som_meta.smm_keydisk.skm_maskkey));
d810 1
d848 4
a851 1
	struct sr_meta_opt      *om;
d933 7
a939 5
	om = (struct sr_meta_opt *)((u_int8_t *)(sm + 1) +
	    sizeof(struct sr_meta_chunk) * sm->ssdi.ssd_chunk_no);
	for (c = 0; c < sm->ssdi.ssd_opt_no; c++) {
		if (om->somi.som_type == SR_OPT_KEYDISK) {
			bcopy(&om->somi.som_meta.smm_keydisk.skm_maskkey,
d942 3
a944 3
			break;
		} else if (om->somi.som_type == SR_OPT_CRYPTO) {
			bcopy(&om->somi.som_meta.smm_crypto,
a946 1
			break;
a947 1
		om++;
d953 7
d1170 1
a1170 1
sr_crypto_meta_opt_handler(struct sr_discipline *sd, struct sr_meta_opt *om)
d1174 2
a1175 2
	if (om->somi.som_type == SR_OPT_CRYPTO) {
		sd->mds.mdd_crypto.scr_meta =  &om->somi.som_meta.smm_crypto;
@


1.71
log
@only allocate and copyin the length of kdfinfo data.
ok deraadt matthew
@
text
@d94 1
a94 1
int		sr_crypto_meta_opt_load(struct sr_discipline *,
d131 1
a131 1
	sd->sd_meta_opt_load = sr_crypto_meta_opt_load;
d1153 1
a1153 1
sr_crypto_meta_opt_load(struct sr_discipline *sd, struct sr_meta_opt *om)
@


1.70
log
@ENOMEM causing EIO errors is bad juju. Softraid crypto did this.

Instead of allocating a crypto op and the optional dma buffer on each
and every io, preallocate a list of softraid crypto wus that contain a
buffer of the max size we will use (MAXPHYS). since we know the number
of openings we have in advance this means that on each io we just pick
one, shorten the list of crypto descs, init any values then do the io.

ok jsing (who provided many useful comments. he also provided a smarter way of
handling the cryptop lists which is not in this diff but will be implemented
soonish), marco@@.

dlg@@ pointed out that this should probably use iopools but letting
disciplines allocate their own iopool involves more softraid rejigging
that will have to be done first. For now this is sufficient.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.69 2011/06/18 23:35:21 matthew Exp $ */
d395 1
a395 1
	if (bc->bc_opaque_size < sizeof(*kdfinfo))
@


1.69
log
@Change sizeof(&kdfinfo2) to sizeof(kdfinfo2).

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.68 2011/06/17 07:06:46 mk Exp $ */
d59 19
a77 1
struct cryptop	*sr_crypto_getcryptop(struct sr_workunit *, int);
a78 1
void		*sr_crypto_putcryptop(struct cryptop *);
d98 1
a98 1
int		sr_crypto_rw2(struct sr_workunit *, struct cryptop *);
d250 3
a252 2
struct cryptop *
sr_crypto_getcryptop(struct sr_workunit *wu, int encrypt)
d256 1
a256 1
	struct cryptop		*crp = NULL;
d258 1
a258 2
	struct uio		*uio = NULL;
	int			flags, i, n, s;
d262 1
a262 1
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_getcryptop wu: %p encrypt: %d\n",
d265 6
a270 9
	s = splbio();
	uio = pool_get(&sd->mds.mdd_crypto.sr_uiopl, PR_ZERO | PR_NOWAIT);
	if (uio == NULL)
		goto poolunwind;
	uio->uio_iov = pool_get(&sd->mds.mdd_crypto.sr_iovpl,
	    PR_ZERO | PR_NOWAIT);
	if (uio->uio_iov == NULL)
		goto poolunwind;
	splx(s);
d272 2
a273 2
	uio->uio_iovcnt = 1;
	uio->uio_iov->iov_len = xs->datalen;
d275 2
a276 4
		uio->uio_iov->iov_base = dma_alloc(xs->datalen, PR_NOWAIT);
		if (uio->uio_iov->iov_base == NULL)
			goto unwind;
		bcopy(xs->data, uio->uio_iov->iov_base, xs->datalen);
d278 1
a278 1
		uio->uio_iov->iov_base = xs->data;
d288 18
a308 4
	crp = crypto_getreq(n);
	if (crp == NULL)
		goto unwind;

d313 2
a314 2
	crp->crp_sid = sd->mds.mdd_crypto.scr_sid[keyndx];
	if (crp->crp_sid == (u_int64_t)-1)
d317 5
a321 4
	crp->crp_ilen = xs->datalen;
	crp->crp_alloctype = M_DEVBUF;
	crp->crp_buf = uio;
	for (i = 0, crd = crp->crp_desc; crd; i++, blk++, crd = crd->crd_next) {
d341 2
d344 1
a344 3
	return (crp);
poolunwind:
	splx(s);
d346 9
a354 14
	if (crp)
		crypto_freereq(crp);
	if (uio && uio->uio_iov)
		if ((wu->swu_xs->flags & SCSI_DATA_OUT) &&
		    uio->uio_iov->iov_base)
			dma_free(uio->uio_iov->iov_base, uio->uio_iov->iov_len);

	s = splbio();
	if (uio && uio->uio_iov)
		pool_put(&sd->mds.mdd_crypto.sr_iovpl, uio->uio_iov);
	if (uio)
		pool_put(&sd->mds.mdd_crypto.sr_uiopl, uio);
	splx(s);

d358 2
a359 2
void *
sr_crypto_putcryptop(struct cryptop *crp)
d361 2
a362 2
	struct uio		*uio = crp->crp_buf;
	struct sr_workunit	*wu = crp->crp_opaque;
d364 1
a364 1
	int			s;
d366 2
a367 2
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_putcryptop crp: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), crp);
d369 14
a382 9
	if ((wu->swu_xs->flags & SCSI_DATA_OUT) && uio->uio_iov->iov_base)
		dma_free(uio->uio_iov->iov_base, uio->uio_iov->iov_len);
	s = splbio();
	pool_put(&sd->mds.mdd_crypto.sr_iovpl, uio->uio_iov);
	pool_put(&sd->mds.mdd_crypto.sr_uiopl, uio);
	splx(s);
	crypto_freereq(crp);

	return (wu);
d958 1
a966 5
	pool_init(&sd->mds.mdd_crypto.sr_uiopl, sizeof(struct uio), 0, 0, 0,
	    "sr_uiopl", NULL);
	pool_init(&sd->mds.mdd_crypto.sr_iovpl, sizeof(struct iovec), 0, 0, 0,
	    "sr_iovpl", NULL);

d976 27
d1045 1
d1067 15
a1084 5
	if (sd->mds.mdd_crypto.sr_uiopl.pr_serial != 0)
		pool_destroy(&sd->mds.mdd_crypto.sr_uiopl);
	if (sd->mds.mdd_crypto.sr_iovpl.pr_serial != 0)
		pool_destroy(&sd->mds.mdd_crypto.sr_iovpl);

d1168 1
a1168 1
	struct cryptop		*crp;
d1175 2
a1176 2
		crp = sr_crypto_getcryptop(wu, 1);
		if (crp == NULL)
d1178 1
a1178 2
		crp->crp_callback = sr_crypto_write;
		crp->crp_opaque = wu;
d1180 1
a1180 1
		if (crypto_invoke(crp))
d1183 1
a1183 1
			rv = crp->crp_etype;
d1194 2
a1196 1
	struct sr_workunit	*wu = crp->crp_opaque;
d1203 1
a1203 2
		((struct sr_workunit *)(crp->crp_opaque))->swu_xs->error =
		    XS_DRIVER_STUFFUP;
d1205 1
a1205 1
		sr_crypto_finish_io(crp->crp_opaque);
d1209 1
a1209 1
	return (sr_crypto_rw2(wu, crp));
d1213 1
a1213 1
sr_crypto_rw2(struct sr_workunit *wu, struct cryptop *crp)
d1248 1
a1248 1
		uio = crp->crp_buf;
d1251 1
a1251 1
		ccb->ccb_opaque = crp;
d1287 2
a1288 2
	if (crp)
		crp->crp_etype = EINVAL;
d1300 1
a1300 1
	struct cryptop		*crp;
d1359 6
a1364 6
			crp = sr_crypto_getcryptop(wu, 0);
			if (crp == NULL)
				panic("sr_crypto_intr: no crypto op");
			ccb->ccb_opaque = crp;
			crp->crp_callback = sr_crypto_read;
			crp->crp_opaque = wu;
d1366 1
a1366 1
			    "%p\n", DEVNAME(sc), crp);
d1368 1
a1368 1
			crypto_invoke(crp);
d1402 1
a1402 1
		sr_crypto_putcryptop(ccb->ccb_opaque);
d1414 2
a1416 1
	struct sr_workunit	*wu = crp->crp_opaque;
@


1.68
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.67 2011/06/05 11:09:00 stsp Exp $ */
d1087 1
a1087 1
	explicit_bzero(&kdfinfo2, sizeof(&kdfinfo2));
@


1.67
log
@Fix function names in debug printfs and use a more user-friendly error
message if the key disk cannot be opened. ok marco (some time ago)
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.66 2011/05/20 19:37:58 mikeb Exp $ */
d593 1
a593 1
	p = malloc(ksz, M_DEVBUF, M_WAITOK | M_ZERO);
@


1.66
log
@sr_scsi_cmd copes with failed i/o just fine so there's no need
to panic if we couldn't allocate memory for crypto descriptors;
tested by dcoppa, ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.65 2011/04/06 03:14:51 marco Exp $ */
d674 1
a674 2
		printf("%s:, sr_create_key_disk: can't allocate vnode\n",
		    DEVNAME(sc));
d678 2
a679 2
		DNPRINTF(SR_D_META,"%s: sr_create_key_disk cannot open %s\n",
		    DEVNAME(sc), devname);
d689 2
a690 2
		DNPRINTF(SR_D_META, "%s: sr_create_key_disk ioctl failed\n",
		    DEVNAME(sc));
d836 1
a836 2
		printf("%s:, sr_read_key_disk: can't allocate vnode\n",
		    DEVNAME(sc));
d840 2
a841 2
		DNPRINTF(SR_D_META,"%s: sr_read_key_disk cannot open %s\n",
		    DEVNAME(sc), devname);
d851 2
a852 2
		DNPRINTF(SR_D_META, "%s: sr_read_key_disk ioctl failed\n",
		    DEVNAME(sc));
@


1.65
log
@make crypto work with bigmem
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.64 2011/04/05 19:52:02 krw Exp $ */
d1118 1
a1118 1
			panic("sr_crypto_rw: no crypto op");
@


1.64
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.63 2011/03/06 21:41:57 stsp Exp $ */
d261 1
a261 2
		uio->uio_iov->iov_base = malloc(xs->datalen, M_DEVBUF,
		    M_NOWAIT);
d324 1
a324 1
			free(uio->uio_iov->iov_base, M_DEVBUF);
d348 1
a348 1
		free(uio->uio_iov->iov_base, M_DEVBUF);
@


1.63
log
@fix function name in error/debug messages; ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.62 2011/01/12 20:48:34 marco Exp $ */
a1347 2
	/* do not change the order of these 2 functions */
	sr_wu_put(wu);
@


1.62
log
@stray tab
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.61 2011/01/12 20:41:48 deraadt Exp $ */
d838 1
a838 1
		printf("%s:, sr_create_key_disk: can't allocate vnode\n",
d843 1
a843 1
		DNPRINTF(SR_D_META,"%s: sr_create_key_disk cannot open %s\n",
d854 1
a854 1
		DNPRINTF(SR_D_META, "%s: sr_create_key_disk ioctl failed\n",
@


1.61
log
@explicit zeroing of key information in the softraid ioctl code
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.60 2011/01/12 20:38:33 marco Exp $ */
d525 1
a525 1
	
@


1.60
log
@more explicit_bzero to delete keys.

prodded and ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.59 2011/01/12 19:45:03 deraadt Exp $ */
d1088 3
@


1.59
log
@lots of explicit_bzero for things which contain parts of keys
ok marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.58 2010/11/06 23:01:56 marco Exp $ */
d1006 3
a1008 1
	if (sd->mds.mdd_crypto.key_disk != NULL)
d1010 1
@


1.58
log
@Move raid1 and crypto io to a workq.  This is to avoid a potential VOP_
call while in interrupt context.

Contains an additional spl dance as found by thib.

Tested by many opn various arches.  Note that raid 0/4/5/6 have not been
moved over yet.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.57 2010/09/27 19:49:43 thib Exp $ */
d401 1
a401 1
	bzero(kdfinfo, bc->bc_opaque_size);
d429 1
a429 1
	bzero(&ctx, sizeof(ctx));
d455 1
a455 1
	bzero(&ctx, sizeof(ctx));
d481 3
a483 3
	bzero(check_key, sizeof(check_key));
	bzero(&hmacctx, sizeof(hmacctx));
	bzero(&shactx, sizeof(shactx));
d515 1
a515 1
		bzero(sd->mds.mdd_crypto.scr_key,
d523 1
a523 1
	bzero(&sd->mds.mdd_crypto.scr_maskkey,
d526 1
a526 1
	bzero(check_digest, sizeof(check_digest));
d564 2
a565 1
	bzero(sd->mds.mdd_crypto.scr_key, sizeof(sd->mds.mdd_crypto.scr_key));
d634 1
a634 1
		bzero(p, ksz);
d638 3
a640 3
	bzero(check_digest, sizeof(check_digest));
	bzero(&kdfinfo1->maskkey, sizeof(kdfinfo1->maskkey));
	bzero(&kdfinfo2->maskkey, sizeof(kdfinfo2->maskkey));
@


1.57
log
@A few M_ZEROs without any M_WAITOK/M_NOWAITs.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.56 2010/09/27 02:56:28 marco Exp $ */
d167 1
a167 1
 
d171 1
a171 1
 
a196 1

a201 1

a202 1

d218 1
a218 2
 		goto done;

a219 1

d251 3
a253 2
		goto unwind;
	uio->uio_iov = pool_get(&sd->mds.mdd_crypto.sr_iovpl, PR_NOWAIT);
d255 1
a255 1
		goto unwind;
d317 2
d323 2
a324 1
		if (wu->swu_xs->flags & SCSI_DATA_OUT)
d348 1
a348 1
	if (wu->swu_xs->flags & SCSI_DATA_OUT)
d785 1
a785 1
	
d869 1
a869 7
	sm = malloc(SR_META_SIZE * 512, M_DEVBUF, M_NOWAIT|M_ZERO);
	if (sm == NULL) {
		printf("%s: not enough memory for metadata buffer\n",
		    DEVNAME(sc));
		goto done;
	}

d878 1
a878 1
 		    DEVNAME(sc));
d889 1
a889 7
	key_disk = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_NOWAIT|M_ZERO);
	if (key_disk == NULL) {
		printf("%s: not enough memory for chunk\n",
		    DEVNAME(sc));
		goto done;
	}

d1096 2
a1097 2
	
	return rv;
d1112 1
a1112 1
			panic("sr_crypto_getcryptop");
d1201 2
d1297 1
a1297 1
				panic("sr_crypto_getcryptop");
d1333 2
@


1.56
log
@tedu's shiny new pool_get kassert found an instance of PR_NOWAIT or
PR_WAITOK not being set.  While here add a diagnostic check for malloc.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.55 2010/09/27 02:49:42 marco Exp $ */
d870 1
a870 1
	sm = malloc(SR_META_SIZE * 512, M_DEVBUF, M_ZERO);
d896 1
a896 1
	key_disk = malloc(sizeof(struct sr_chunk), M_DEVBUF, M_ZERO);
@


1.55
log
@The only sensible argument for VOP_* calls that take a struct proc pointer is
curproc. A bunch of callers were passing in 0 (not even NULL, 0) as this
pointer, which was fine until the called vnode function tried to do
something with it. Typically, this code was then copy/pasted to various
parts of the tree.

Accept the facts of life and switch all of these over to passing curproc
for now until the argument can be removed.

Discovered by stsp trying to create a softraid on top of a vnd, which
crashed with a NULL deref in vndioctl.

softraid bits tested by mikeb and jsing. raidframe bits tested by pea,
matthieu and naddy. The rest tested by at least thib, jsing and myself.

ok thib@@, jsing@@.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.54 2010/07/02 09:26:05 jsing Exp $ */
d254 1
a254 1
	uio = pool_get(&sd->mds.mdd_crypto.sr_uiopl, PR_ZERO);
d257 1
a257 1
	uio->uio_iov = pool_get(&sd->mds.mdd_crypto.sr_iovpl, 0);
d267 2
d1124 2
d1307 2
@


1.54
log
@Rename the volume specific flags variable.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.53 2010/07/02 09:20:26 jsing Exp $ */
d677 1
a677 1
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, 0)) {
d687 2
a688 1
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED, 0)) {
d691 1
a691 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d802 1
a802 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d840 1
a840 1
	if (VOP_OPEN(vn, FREAD | FWRITE, NOCRED, 0)) {
d850 2
a851 1
	if (VOP_IOCTL(vn, DIOCGDINFO, (caddr_t)&label, FREAD, NOCRED, 0)) {
d854 1
a854 1
		VOP_CLOSE(vn, FREAD | FWRITE, NOCRED, 0);
d933 1
a933 1
		VOP_CLOSE(vn, FREAD, NOCRED, 0);
@


1.53
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.51 2010/04/18 16:57:48 jsing Exp $ */
d734 1
a734 1
	sm->ssdi.ssd_flags = 0;
@


1.52
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1168 1
a1168 1
	blk += SR_DATA_OFFSET;
@


1.51
log
@Make key disks use their own optional metadata type, rather than reusing
crypto optional metadata.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.48 2010/03/26 11:20:34 jsing Exp $ */
d42 1
@


1.50
log
@Completely overhaul optional metadata handling, allowing for multiple
optional metadata per volume and discipline specific optional metadata
processing.

ok marco@@
@
text
@d770 1
a770 1
	omi->omi_om.somi.som_type = SR_OPT_CRYPTO;
d772 2
a773 2
	    &omi->omi_om.somi.som_meta.smm_crypto,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey));
d909 6
a914 1
		if (om->somi.som_type == SR_OPT_CRYPTO) {
d918 1
@


1.49
log
@Correctly initialise variables to prevent possible free without malloc in
error path.

Found by jsg@@ using the clang static analyser.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.46 2009/12/31 14:42:31 jsing Exp $ */
d76 2
d113 1
d130 2
a131 1
	int	rv = EINVAL;
d136 8
d191 4
d209 1
a209 1
		if (sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint) <
d213 1
a213 1
		if (copyout(sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
d303 1
a303 1
		switch (sd->mds.mdd_crypto.scr_meta.scm_alg) {
d379 1
a379 1
		if (sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint) <
d383 1
a383 1
		    sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
d492 1
a492 1
	if (sd->mds.mdd_crypto.scr_meta.scm_check_alg != SR_CRYPTOC_HMAC_SHA1)
d495 1
a495 1
	if (sr_crypto_decrypt((u_char *)sd->mds.mdd_crypto.scr_meta.scm_key,
d498 1
a498 1
	    sd->mds.mdd_crypto.scr_meta.scm_mask_alg) == -1)
d511 1
a511 1
	if (memcmp(sd->mds.mdd_crypto.scr_meta.chk_hmac_sha1.sch_mac,
d540 1
a540 1
	sd->mds.mdd_crypto.scr_meta.scm_alg = SR_CRYPTOA_AES_XTS_256;
d547 1
a547 1
	sd->mds.mdd_crypto.scr_meta.scm_mask_alg = SR_CRYPTOM_AES_ECB_256;
d549 1
a549 1
	    (u_char *)sd->mds.mdd_crypto.scr_meta.scm_key,
d551 1
a551 1
	    sd->mds.mdd_crypto.scr_meta.scm_mask_alg);
d554 1
a554 1
	sd->mds.mdd_crypto.scr_meta.scm_check_alg = SR_CRYPTOC_HMAC_SHA1;
d559 1
a559 1
	    sd->mds.mdd_crypto.scr_meta.chk_hmac_sha1.sch_mac);
d568 1
a568 1
	sd->mds.mdd_crypto.scr_meta.scm_flags = SR_CRYPTOF_KEY |
d586 1
a586 1
	if (sd->mds.mdd_crypto.scr_meta.scm_check_alg != SR_CRYPTOC_HMAC_SHA1)
d589 1
a589 1
	c = (u_char *)sd->mds.mdd_crypto.scr_meta.scm_key;
d596 1
a596 1
	    sd->mds.mdd_crypto.scr_meta.scm_mask_alg) == -1)
d605 1
a605 1
	if (memcmp(sd->mds.mdd_crypto.scr_meta.chk_hmac_sha1.sch_mac,
d612 1
a612 1
	c = (u_char *)sd->mds.mdd_crypto.scr_meta.scm_key;
d614 1
a614 1
	    sd->mds.mdd_crypto.scr_meta.scm_mask_alg) == -1)
d618 1
a618 1
	sd->mds.mdd_crypto.scr_meta.scm_check_alg = SR_CRYPTOC_HMAC_SHA1;
d624 2
a625 2
	bcopy(check_digest, sd->mds.mdd_crypto.scr_meta.chk_hmac_sha1.sch_mac,
	    sizeof(sd->mds.mdd_crypto.scr_meta.chk_hmac_sha1.sch_mac));
d649 1
a649 1
	struct sr_meta_opt      *om;
d753 1
d768 7
a774 6
	om = &key_disk->src_opt;
	om->somi.som_type = SR_OPT_CRYPTO;
	bcopy(sd->mds.mdd_crypto.scr_maskkey, &om->somi.som_meta.smm_crypto,
	    sizeof(om->somi.som_meta.smm_crypto));
	sr_checksum(sc, om, om->som_checksum,
	    sizeof(struct sr_meta_opt_invariant));
d791 2
d906 3
a908 9

	if (sm->ssdi.ssd_opt_no > 1)
		panic("not yet read > 1 optional metadata members");

	if (sm->ssdi.ssd_opt_no) {
		om = (struct sr_meta_opt *)((u_int8_t *)(sm + 1) +
		    sizeof(struct sr_meta_chunk) * sm->ssdi.ssd_chunk_no);
		bcopy(om, &key_disk->src_opt, sizeof(key_disk->src_opt));

d914 1
d960 1
a960 1
	switch (sd->mds.mdd_crypto.scr_meta.scm_alg) {
a1033 1
	struct sr_meta_opt	*im_so;
d1043 1
a1043 1
		size = sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint);
d1046 1
a1046 1
		if (copyout(sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
a1078 13
		/*
		 * Copy encrypted key/passphrase into metadata.
		 */

		/* Only one chunk in crypto volumes... */
		im_so = &sd->sd_vol.sv_chunks[0]->src_opt;
		bcopy(&sd->mds.mdd_crypto.scr_meta,
		    &im_so->somi.som_meta.smm_crypto,
		    sizeof(im_so->somi.som_meta.smm_crypto));

		sr_checksum(sd->sd_sc, im_so, im_so->som_checksum,
		    sizeof(struct sr_meta_opt_invariant));

d1090 13
d1380 1
a1380 1
			    sd->mds.mdd_crypto.scr_meta.scm_key[i][j]);
@


1.48
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d563 1
a563 1
	u_char			*p, *c;
d795 1
a795 1
	struct vnode		*vn;
@


1.47
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1147 1
a1147 1
	blk += SR_META_SIZE + SR_META_OFFSET;
@


1.46
log
@Assert copyright.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.45 2009/12/31 14:00:45 jsing Exp $ */
a1313 1
	xs->flags |= ITSDONE;
@


1.45
log
@Add support for key disks. This allows a crypto volume to be constructed
without using a passphrase - instead the encryption mask key is stored on
the specified key disk partition (ideally being one on a removable device).
This also enables automatic assembly of crypto volumes at boot time.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.43 2009/12/07 14:27:12 jsing Exp $ */
d6 1
@


1.44
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.41 2009/11/24 01:03:54 jsing Exp $ */
d131 16
a146 2
	/* no hint available yet */
	if (bc->bc_opaque_flags & BIOC_SOOUT) {
a149 1
	}
d151 1
a151 1
	if (!(bc->bc_flags & BIOC_SCNOAUTOASSEMBLE))
d153 3
a155 2

	if (sr_crypto_get_kdf(bc, sd))
d157 1
a157 1

d176 13
a188 2
	/* provide userland with kdf hint */
	if (bc->bc_opaque_flags & BIOC_SOOUT) {
a203 1
	}
d205 3
a207 2
	/* get kdf with maskkey from userland */
	if (bc->bc_opaque_flags & BIOC_SOIN)
d211 2
d404 1
a404 1
		    DEVNAME(sd->sd_sc), alg);
d430 1
a430 1
		    DEVNAME(sd->sd_sc), alg);
d625 290
d991 3
d1021 2
a1022 1
	DNPRINTF(SR_D_IOCTL, "%s: sr_crypto_ioctl %u\n", DEVNAME(sc), cmd);
@


1.43
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d67 4
d93 1
a97 1
	sd->sd_max_ccb_per_wu = sd->sd_meta->ssdi.ssd_chunk_no;
d100 3
d104 2
d122 71
d677 1
a677 2
		crypto_freesession(
		    sd->mds.mdd_crypto.scr_sid[i]);
d684 4
a687 2
	pool_destroy(&sd->mds.mdd_crypto.sr_uiopl);
	pool_destroy(&sd->mds.mdd_crypto.sr_iovpl);
@


1.42
log
@Allow the passphrase to be changed on softraid crypto volumes. Ensure that
you backup your data and lock up your pets prior to using this.

Tested by todd@@

ok marco@@
@
text
@d89 1
d92 1
@


1.41
log
@Factor out crypto code allowing for future reuse.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.39 2009/06/11 19:42:59 marco Exp $ */
d65 2
d69 2
d98 1
d449 68
d607 73
@


1.40
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d62 2
d73 2
a74 2
void		sr_crypto_calculate_check_hmac_sha1(struct sr_discipline *,
		   u_char[SHA1_DIGEST_LENGTH]);
d274 52
d327 2
a328 2
sr_crypto_calculate_check_hmac_sha1(struct sr_discipline *sd,
    u_char check_digest[SHA1_DIGEST_LENGTH])
d340 1
a340 2
	SHA1Update(&shactx, sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey));
d343 1
a343 1
	/* sch_mac = HMAC_SHA1_k(unencrypted scm_key) */
d345 1
a345 2
	HMAC_SHA1_Update(&hmacctx, (u_int8_t *)sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key));
a355 4
	rijndael_ctx		ctx;
	u_char			*p, *c;
	size_t			ksz;
	int			i, rv = 1;
d357 1
d364 5
a368 3
	c = (u_char *)sd->mds.mdd_crypto.scr_meta.scm_key;
	p = (u_char *)sd->mds.mdd_crypto.scr_key;
	ksz = sizeof(sd->mds.mdd_crypto.scr_key);
a369 14
	switch (sd->mds.mdd_crypto.scr_meta.scm_mask_alg) {
	case SR_CRYPTOM_AES_ECB_256:
		if (rijndael_set_key(&ctx, sd->mds.mdd_crypto.scr_maskkey,
		    256) != 0)
			goto out;
		for (i = 0; i < ksz; i += RIJNDAEL128_BLOCK_LEN)
			rijndael_decrypt(&ctx, &c[i], &p[i]);
		break;
	default:
		DNPRINTF(SR_D_DIS, "%s: unsuppored scm_mask_alg %u\n",
		    DEVNAME(sd->sd_sc),
		    sd->mds.mdd_crypto.scr_meta.scm_mask_alg);
		goto out;
	}
d374 6
a379 2
	/* Check that the key decrypted properly */
	sr_crypto_calculate_check_hmac_sha1(sd, check_digest);
a383 1
		bzero(check_digest, sizeof(check_digest));
a385 1
	bzero(check_digest, sizeof(check_digest));
d388 1
a388 1
 out:
d392 3
a394 1
	bzero(&ctx, sizeof(ctx));
a400 4
	rijndael_ctx		ctx;
	u_char			*p, *c;
	size_t			ksz;
	int			i;
d415 1
a415 1
	/* Mask the disk keys */
d417 4
a420 13
	if (rijndael_set_key_enc_only(&ctx, sd->mds.mdd_crypto.scr_maskkey,
	    256) != 0) {
		bzero(sd->mds.mdd_crypto.scr_key,
		    sizeof(sd->mds.mdd_crypto.scr_key));
		bzero(&ctx, sizeof(ctx));
		return (1);
	}
	p = (u_char *)sd->mds.mdd_crypto.scr_key;
	c = (u_char *)sd->mds.mdd_crypto.scr_meta.scm_key;
	ksz = sizeof(sd->mds.mdd_crypto.scr_key);
	for (i = 0; i < ksz; i += RIJNDAEL128_BLOCK_LEN)
		rijndael_encrypt(&ctx, &p[i], &c[i]);
	bzero(&ctx, sizeof(ctx));
d422 1
a422 1
	/* Prepare key decryption check code */
d424 4
a427 1
	sr_crypto_calculate_check_hmac_sha1(sd,
a431 1

@


1.39
log
@Create a hotplug callback mechanism.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.38 2009/06/11 02:59:06 marco Exp $ */
d600 3
a602 1
	ccb->ccb_buf.b_vp = NULL;
@


1.38
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.37 2009/06/09 23:17:35 chl Exp $ */
d73 1
d472 2
d489 2
d764 7
@


1.37
log
@fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.36 2009/06/03 17:39:27 ckuethe Exp $ */
d58 1
a58 1
int		 sr_crypto_create_keys(struct sr_discipline *);
d60 13
a72 13
int		 sr_crypto_get_kdf(struct bioc_createraid *,
		     struct sr_discipline *);
int		 sr_crypto_decrypt_key(struct sr_discipline *);
int		 sr_crypto_alloc_resources(struct sr_discipline *);
int		 sr_crypto_free_resources(struct sr_discipline *);
int		 sr_crypto_write(struct cryptop *);
int		 sr_crypto_rw(struct sr_workunit *);
int		 sr_crypto_rw2(struct sr_workunit *, struct cryptop *);
void		 sr_crypto_intr(struct buf *);
int		 sr_crypto_read(struct cryptop *);
void		 sr_crypto_finish_io(struct sr_workunit *);
void		 sr_crypto_calculate_check_hmac_sha1(struct sr_discipline *,
		    u_char[SHA1_DIGEST_LENGTH]);
a81 1

d226 2
a227 2
	struct sr_crypto_kdfinfo	*kdfinfo;
	int				 rv = EINVAL;
d275 3
a277 3
	u_char		check_key[SHA1_DIGEST_LENGTH];
	HMAC_SHA1_CTX	hmacctx;
	SHA1_CTX	shactx;
d303 5
a307 5
	rijndael_ctx	 ctx;
	u_char		*p, *c;
	size_t		 ksz;
	int		 i, rv = 1;
	u_char		check_digest[SHA1_DIGEST_LENGTH];
d359 4
a362 4
	rijndael_ctx	 ctx;
	u_char		*p, *c;
	size_t		 ksz;
	int		 i;
d416 1
a416 1
	u_int num_keys, i;
d477 2
a478 2
	int		rv = EINVAL;
	u_int		i;
d506 1
a506 1
	int			 s, rv = 0;
d530 1
a530 1
	int		 	 s;
d555 2
a556 2
	int			 s;
	daddr64_t		 blk;
d633 1
a633 1
	int			 s, s2, pend;
d745 1
a745 1
	int			 s;
d765 1
a765 1
	int	i, j;
@


1.36
log
@whitespace. "Sure" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.35 2009/06/02 21:23:11 marco Exp $ */
d188 3
a190 2
	if (wu->swu_xs->flags & SCSI_DATA_OUT)
		free(uio->uio_iov->iov_base, M_DEVBUF);
@


1.35
log
@Abuse bio layer a little less by marking fake buffers with B_PHYS.
From beck with lots of squealing and ear bleeds.
Issue originally reported by todd.

ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.34 2009/06/02 11:38:51 deraadt Exp $ */
d437 1
a437 1
		return (EPERM);	
d601 5
a605 5
        DNPRINTF(SR_D_DIS, "%s: %s: sr_crypto_rw2: b_bcount: %d "
            "b_blkno: %x b_flags 0x%0x b_data %p\n",
            DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
            ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
            ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
d635 2
a636 2
        DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr bp: %x xs: %x\n",
            DEVNAME(sc), bp, wu->swu_xs);
d638 3
a640 3
        DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: b_bcount: %d b_resid: %d"
            " b_flags: 0x%0x\n", DEVNAME(sc), ccb->ccb_buf.b_bcount,
            ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags);
d642 1
a642 1
        s = splbio();
@


1.34
log
@marco needs to learn how to do his range checks better, found by Parfait
ok oga guenther
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.33 2009/05/11 14:06:21 jsing Exp $ */
d573 1
a573 1
	ccb->ccb_buf.b_flags = B_CALL;
@


1.33
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.31 2008/09/22 19:44:00 miod Exp $ */
d154 1
a154 1
	if (keyndx > SR_CRYPTO_MAXKEYS)
@


1.32
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d78 26
@


1.31
log
@Make sure some possibly uninitialized local variables are assigned correct
values in all cases.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.30 2008/08/15 11:18:10 djm Exp $ */
d710 1
a710 1
	scsi_done(xs);
@


1.30
log
@use new shared HMAC_SHA1 code in crypto/hmac.[ch] rather than local
copy; ok hshoexer@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.29 2008/07/19 22:41:58 marco Exp $ */
d83 1
a83 1
	struct cryptop		*crp;
@


1.29
log
@Full rewrite of metadata handling.  This fixes power failures and crashes
that caused illegal checksums.  The new metadata code is more or less ready
to deal with other vendor's metadata formats.

While here clean up the name space.

Fix thib's pool mess by adding removing bad flags in interrupt context.

tested on macppc, amd64, i386, sparc64 & hppa

sparc64 has issues with crypto however those do not seem to be softraid
specific.

help from okan@@ ckuethe@@ Will Backman and others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.28 2008/06/25 17:43:09 thib Exp $ */
a19 19
/*-
 * sr_crypto_hmac_sha1
 *
 * Copyright (c) 2008 Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */


d45 1
d47 2
a70 2
void		 sr_crypto_hmac_sha1(const u_int8_t *, size_t, const u_int8_t *,
		    size_t, u_int8_t[SHA1_DIGEST_LENGTH]);
a244 44
/*
 * HMAC-SHA-1 (from RFC 2202).
 * XXX this really belongs in sys/crypto, but it needs to be done
 *      generically and so far, nothing else needs it.
 */
void
sr_crypto_hmac_sha1(const u_int8_t *text, size_t text_len, const u_int8_t *key,
    size_t key_len, u_int8_t digest[SHA1_DIGEST_LENGTH])
{
	SHA1_CTX ctx;
	u_int8_t k_pad[SHA1_BLOCK_LENGTH];
	u_int8_t tk[SHA1_DIGEST_LENGTH];
	int i;

	if (key_len > SHA1_BLOCK_LENGTH) {
		SHA1Init(&ctx);
		SHA1Update(&ctx, key, key_len);
		SHA1Final(tk, &ctx);

		key = tk;
		key_len = SHA1_DIGEST_LENGTH;
	}

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < SHA1_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x36;

	SHA1Init(&ctx);
	SHA1Update(&ctx, k_pad, SHA1_BLOCK_LENGTH);
	SHA1Update(&ctx, text, text_len);
	SHA1Final(digest, &ctx);

	bzero(k_pad, sizeof k_pad);
	bcopy(key, k_pad, key_len);
	for (i = 0; i < SHA1_BLOCK_LENGTH; i++)
		k_pad[i] ^= 0x5c;

	SHA1Init(&ctx);
	SHA1Update(&ctx, k_pad, SHA1_BLOCK_LENGTH);
	SHA1Update(&ctx, digest, SHA1_DIGEST_LENGTH);
	SHA1Final(digest, &ctx);
}

d250 1
d254 3
a262 1
	bzero(&shactx, sizeof(shactx));
d264 5
a268 4
	sr_crypto_hmac_sha1((u_char *)sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key),
	    check_key, sizeof(check_key),
	    check_digest);
d270 2
@


1.28
log
@
use pools for the uio and iovec allocations in sr_crypto_getcryptop()
instead of malloc;

OK hshoexer@@ and macro@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.27 2008/06/14 18:40:50 hshoexer Exp $ */
d103 4
a106 4
	struct uio		*uio;
	int			 flags, i, n;
	daddr64_t		 blk = 0;
	u_int			 keyndx;
d111 9
a119 2
	uio = pool_get(&sr_uiopl, PR_WAITOK|PR_ZERO);
	uio->uio_iov = pool_get(&sr_iovpl, PR_WAITOK);
d182 8
a189 2
	pool_put(&sr_iovpl, uio->uio_iov);
	pool_put(&sr_uiopl, uio);
d198 2
d206 4
a209 2
	pool_put(&sr_iovpl, uio->uio_iov);
	pool_put(&sr_uiopl, uio);
d454 5
d462 1
a462 1
	if (sr_alloc_wu(sd))
d464 1
a464 1
	if (sr_alloc_ccb(sd))
d483 1
a483 1
	num_keys = sd->sd_vol.sv_meta.svm_size >> SR_CRYPTO_KEY_BLKSHIFT;
d522 2
a523 2
	sr_free_wu(sd);
	sr_free_ccb(sd);
d525 2
a526 2
	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);
d595 1
a595 1
	ccb = sr_get_ccb(sd);
d599 1
a599 1
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
d633 1
a633 1
            DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d648 1
a648 1
	/* wu is unwound by sr_put_wu */
d765 1
a765 1
	sr_put_wu(wu);
@


1.27
log
@Provide a status field for operations on the bc_opaque data.  Now we're
able to distinguish cleanly an failing ioctl (ie. return value -1) from
trying to retrieve a KDF hint from a not yet initialized volume.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.26 2008/06/14 03:01:00 djm Exp $ */
d48 1
d111 2
a112 3
	/* XXX use pool */
	uio = malloc(sizeof(*uio), M_DEVBUF, M_NOWAIT | M_ZERO);
	uio->uio_iov = malloc(sizeof(*uio->uio_iov), M_DEVBUF, M_NOWAIT);
d175 2
a176 2
	free(uio->uio_iov, M_DEVBUF);
	free(uio, M_DEVBUF);
d191 2
a192 2
	free(uio->uio_iov, M_DEVBUF);
	free(uio, M_DEVBUF);
@


1.26
log
@Use multiple crypto keys per volume. Each key is used to encrypt at
most 0.5TB of disk. This is well below P1619-2007's recommendation
for AES-XTS of 1TB/key, but small enough so we can test that we
actually use multiple keys with inexpensive hardware.
We allocate 32 keys, so this will do for volumes up to 16TB.

Fix a crypto session leak in sr_crypto_free_resources()

much debugging help mshoexer@@; ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.25 2008/06/14 00:12:21 djm Exp $ */
d237 1
@


1.25
log
@implement a check code to determine whether the disk keys have
been correctly decrypted using the masking key.

The check code is a HMAC-SHA1 over the disk keys using a hash of
the masking key. It should be slow enough to provide no useful
brute force success oracle and should not leak significant data about
the masking key or disk keys.

ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.24 2008/06/13 22:08:17 djm Exp $ */
d105 1
d137 8
a144 1
	crp->crp_sid = sd->mds.mdd_crypto.scr_sid;
d428 1
d436 3
a442 1

a457 1
	cri.cri_key = sd->mds.mdd_crypto.scr_key[0];
d459 20
a478 1
	return (crypto_newsession(&sd->mds.mdd_crypto.scr_sid, &cri, 0));
d485 1
d492 6
@


1.24
log
@make the disk key masking algorithm a parameter and add some extra
reserved space in case we ever want to support a different scheme
ok hshoexer@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.23 2008/06/13 21:03:40 hshoexer Exp $ */
d5 1
d20 19
d63 1
d86 4
d237 67
d311 1
d315 3
a335 1
	rv = 0; /* Success */
d340 12
d374 3
d381 1
a381 3
	/* XXX 128 for now */
	sd->mds.mdd_crypto.scr_meta.scm_alg = SR_CRYPTOA_AES_XTS_128;

a389 1

a392 1

d396 7
d405 1
d430 1
a430 1
		return (ENOMEM);		/* XXX */
d433 1
a433 1
		return (1);			/* XXX */
d445 1
a445 1
		return (1);			/* XXX */
@


1.23
log
@Implement pbkdf2 in in bioctl to derive master key from a passphrase.

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.22 2008/06/13 18:26:59 hshoexer Exp $ */
d218 1
a218 1
	int		 i;
a221 8
	if (rijndael_set_key(&ctx, sd->mds.mdd_crypto.scr_maskkey, 128) != 0) {
		bzero(&ctx, sizeof(ctx));
		return (1);
	}
	/* we don't need the mask key anymore */
	bzero(&sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(sd->mds.mdd_crypto.scr_maskkey));

d226 15
a240 4
	for (i = 0; i < ksz; i += RIJNDAEL128_BLOCK_LEN)
		rijndael_decrypt(&ctx, &c[i], &p[i]);
	bzero(&ctx, sizeof(ctx));

d244 7
a250 1
	return (0);
d274 1
d276 1
a276 1
	    128) != 0) {
@


1.22
log
@When assembling an already initialized crytpo softraid, correctly copy in
mask key from userland.  Thus, modify sr_crypto_get_kdf() do correclty handle
copying kdf hint and/or mask key.

While there, remove superflous sr_read_meta().

ok marco djm
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.21 2008/06/12 18:23:29 hshoexer Exp $ */
d188 1
a188 1
		    kdfinfo->kdfhint.len)
d190 1
a190 1
		bcopy(&kdfinfo->kdfhint,
d192 1
a192 1
		    kdfinfo->kdfhint.len);
@


1.21
log
@Pass error code via the crypto descriptor (ie. crp_etype) from crypto
callback.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.20 2008/06/12 18:13:27 hshoexer Exp $ */
a183 3
	if (!(kdfinfo->flags & SR_CRYPTOKDF_KEY) ||
	    !(kdfinfo->flags & SR_CRYPTOKDF_HINT))
		goto out;
d186 8
a193 5
	if (sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint) <
	    kdfinfo->kdfhint.len)
		goto out;
	bcopy(&kdfinfo->kdfhint, sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
	    kdfinfo->kdfhint.len);
d196 7
a202 2
	bcopy(&kdfinfo->maskkey, sd->mds.mdd_crypto.scr_maskkey,
	    sizeof(kdfinfo->maskkey));
@


1.20
log
@Get mask keying for on-disk keys from user space and keep a "hint" for key
generation used by user space in the meta data.

Actually use the masking key for encryption and decryption of on-disk key
at run time.

ok djm marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.19 2008/06/11 00:26:18 hshoexer Exp $ */
d360 2
d461 2
@


1.19
log
@Move first pieces of crypto softraid into the tree.  Still totally
disabled, of course, and still work in progress.

help by djm@@, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.18 2008/02/23 19:46:00 marco Exp $ */
d54 2
d166 42
d217 1
a217 2
	if (rijndael_set_key(&ctx, sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
	    128) != 0) {
d221 3
a235 7
		
	/*
	 * XXX de-mask keys instead of bcopy
	 */
	bcopy(sd->mds.mdd_crypto.scr_meta.scm_key, sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_meta.scm_key));

a242 1
	u_int8_t	 kdfhint[SR_CRYPTO_KDFHINTBYTES];	/* XXX fake */
d250 2
a251 5
	/* XXX fake for now */
	memset(kdfhint, 0xdeadbeef, sizeof(kdfhint));

	bcopy(kdfhint, sd->mds.mdd_crypto.scr_meta.scm_kdfhint,
	    sizeof(sd->mds.mdd_crypto.scr_meta.scm_kdfhint));
d260 2
a261 1
	if (rijndael_set_key_enc_only(&ctx, kdfhint, 128) != 0) {
d370 2
a371 2
	int		 s;
struct sr_workunit	*wu = crp->crp_opaque;
@


1.18
log
@Oops to eager with the delete button.  prompted by deraadt.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.17 2008/02/23 19:38:29 marco Exp $ */
d4 1
d42 1
d51 111
a161 2
int			sr_crypto_decrypt_key(struct sr_discipline *);
int			sr_crypto_encrypt_key(struct sr_discipline *);
d166 5
d173 5
a177 2
	return (1);
}
d179 17
a195 4
int
sr_crypto_encrypt_key(struct sr_discipline *sd)
{
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_encrypt_key\n", DEVNAME(sd->sd_sc));
d197 1
a197 1
	return (1);
d200 1
a200 1
void
d203 5
a207 2
	u_int32_t		*pk1, *pk2, sz;
	int			i, x;
d212 6
d219 11
a229 8
	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		sz = sizeof(sd->mds.mdd_crypto.scr_key1[i]) / 4;
		pk1 = (u_int32_t *)sd->mds.mdd_crypto.scr_key1[i];
		pk2 = (u_int32_t *)sd->mds.mdd_crypto.scr_key2[i];
		for (x = 0; x < sz; x++) {
			*pk1++ = arc4random();
			*pk2++ = arc4random();
		}
d232 17
a248 14
	/* generate salt */
	sz = sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_salt) / 4;
	pk1 = (u_int32_t *)sd->mds.mdd_crypto.scr_meta[0].scm_salt;
	for (i = 0; i < sz; i++)
		*pk1++ = arc4random();

	sd->mds.mdd_crypto.scr_meta[0].scm_flags =
	    SR_CRYPTOF_KEY | SR_CRYPTOF_SALT;

	strlcpy(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase,
	    "my super secret passphrase ZOMGPASSWD",
	    sizeof(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase));
	sd->mds.mdd_crypto.scr_meta[1].scm_flags =
	    SR_CRYPTOF_PASSPHRASE;
d254 5
d262 23
a284 1
	return (EINVAL);
d290 5
d298 8
a305 1
	return (EINVAL);
d311 3
d317 106
d425 164
@


1.17
log
@Backout premature code.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.16 2008/02/22 23:00:04 hshoexer Exp $ */
d3 2
@


1.16
log
@Propper encryption of on-disk-keys, prodded/suggest by tedu@@ and djm@@
also use aes to generate proppper IVs

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.15 2008/02/19 03:28:28 marco Exp $ */
a2 5
 * Copyright (c) 2007 Ted Unangst <tedu@@openbsd.org>
 * Copyright (c) 2008 Marco Peereboom <marco@@openbsd.org>
 * Copyright (c) 2008 Chris Kuethe <ckuethe@@openbsd.org>
 * Copyright (c) 2008 Hans-Joerg Hoexer <hshoexer@@openbsd.org>
 *
a38 2
#include <crypto/sha1.h>
#include <crypto/rijndael.h>
a46 2
struct cryptop *	sr_crypto_getcryptop(struct sr_workunit *, int);
void			*sr_crypto_putcryptop(struct cryptop *);
a48 106
int			sr_crypto_write(struct cryptop *);
int			sr_crypto_rw2(struct sr_workunit *, struct cryptop *);
void			sr_crypto_intr(struct buf *);
int			sr_crypto_read(struct cryptop *);
void			sr_crypto_finish_io(struct sr_workunit *);
void			sr_crypto_prf(const u_int8_t *, int, const u_int8_t *,
			    int, u_int8_t *);
void			sr_crypto_xor(const u_int8_t *, u_int8_t *, int);
void			sr_crypto_prf_iterate(const u_int8_t *, int, const
			    u_int8_t *, int, int, int, u_int8_t *);
int			sr_crypto_pbkdf2(const u_int8_t *, int, const
			    u_int8_t *, int, int, int, u_int8_t **);

struct cryptop *
sr_crypto_getcryptop(struct sr_workunit *wu, int encrypt)
{
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_discipline	*sd = wu->swu_dis;
	struct cryptop		*crp;
	struct cryptodesc	*crd;
	struct uio		*uio;
	int			flags, i, n;
	daddr64_t		blk[2];
	rijndael_ctx		ctx;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_getcryptop wu: %p encrypt: %d\n",
	    DEVNAME(sd->sd_sc), wu, encrypt);

	/* XXX eliminate all malloc here, make either pool or pre-alloc */
	uio = malloc(sizeof(*uio), M_DEVBUF, M_NOWAIT | M_ZERO);
	uio->uio_iov = malloc(sizeof(*uio->uio_iov), M_DEVBUF, M_NOWAIT);
	uio->uio_iovcnt = 1;
	uio->uio_iov->iov_len = xs->datalen;
	if (xs->flags & SCSI_DATA_OUT) {
		uio->uio_iov->iov_base = malloc(xs->datalen, M_DEVBUF,
		    M_NOWAIT);
		bcopy(xs->data, uio->uio_iov->iov_base, xs->datalen);
	} else
		uio->uio_iov->iov_base = xs->data;

	blk[0] = 0;
	if (xs->cmdlen == 10)
		blk[1] = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		blk[1] = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk[1] = _3btol(((struct scsi_rw *)xs->cmd)->addr);

	n = xs->datalen >> DEV_BSHIFT;
	flags = (encrypt ? CRD_F_ENCRYPT : 0) |
	    CRD_F_IV_PRESENT | CRD_F_IV_EXPLICIT;

	crp = crypto_getreq(n);
	if (crp == NULL)
		goto unwind;

	if (rijndael_set_key_enc_only(&ctx,
	    sd->mds.mdd_crypto.scr_key1[blk[1] % SR_CRYPTO_MAXKEYS],
	    SR_CRYPTO_KEYBITS) != 0)
		goto unwind;

	crp->crp_sid = sd->mds.mdd_crypto.scr_sid;
	crp->crp_ilen = xs->datalen;
	crp->crp_alloctype = M_DEVBUF;
	crp->crp_buf = uio;
	for (i = 0, crd = crp->crp_desc; crd; i++, blk[1]++, crd = crd->crd_next) {
		crd->crd_skip = i << DEV_BSHIFT;
		crd->crd_len = DEV_BSIZE;
		crd->crd_inject = 0;
		crd->crd_flags = flags;
		crd->crd_alg = CRYPTO_AES_CBC;
		crd->crd_klen = SR_CRYPTO_KEYBITS;
		crd->crd_rnd = SR_CRYPTO_ROUNDS;
		crd->crd_key =
		    sd->mds.mdd_crypto.scr_key2[blk[1] % SR_CRYPTO_MAXKEYS];

		rijndael_encrypt(&ctx, (u_char *)blk, crd->crd_iv);
	}
	bzero(&ctx, sizeof(ctx));

	return (crp);
unwind:
	if (wu->swu_xs->flags & SCSI_DATA_OUT)
		free(uio->uio_iov->iov_base, M_DEVBUF);
	free(uio->uio_iov, M_DEVBUF);
	free(uio, M_DEVBUF);
	return (NULL);
}

void *
sr_crypto_putcryptop(struct cryptop *crp)
{
	struct uio		*uio = crp->crp_buf;
	struct sr_workunit	*wu = crp->crp_opaque;

	DNPRINTF(SR_D_DIS, "%s: sr_crypto_putcryptop crp: %p\n",
	    DEVNAME(wu->swu_dis->sd_sc), crp);

	if (wu->swu_xs->flags & SCSI_DATA_OUT)
		free(uio->uio_iov->iov_base, M_DEVBUF);
	free(uio->uio_iov, M_DEVBUF);
	free(uio, M_DEVBUF);
	crypto_freereq(crp);

	return (wu);
}
a52 4
	rijndael_ctx		ctx;
	u_int8_t		*dkkey, *pk1, *ck1, *pk2, *ck2;
	int			i, error = 0;

d55 1
a55 28
	/*  derive key from passphrase */
	if ((error = sr_crypto_pbkdf2(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase,
	    strlen(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase),
	    sd->mds.mdd_crypto.scr_meta[0].scm_salt,
	    sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_salt),
	    SR_CRYPTO_PBKDF2_ROUNDS, SR_CRYPTO_KEYBYTES, &dkkey)) != 0)
		goto out;

	if ((error = rijndael_set_key(&ctx, dkkey, SR_CRYPTO_KEYBITS)) != 0)
		goto out;
	
	/* recover key */
	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		pk1 = sd->mds.mdd_crypto.scr_key1[i];
		pk2 = sd->mds.mdd_crypto.scr_key2[i];
		ck1 = sd->mds.mdd_crypto.scr_meta[0].scm_key1[i];
		ck2 = sd->mds.mdd_crypto.scr_meta[0].scm_key2[i];

		/* note:  with aes-128 blocksize == keysize */
		rijndael_decrypt(&ctx, (u_char *)ck1, (u_char *)pk1);  
		rijndael_decrypt(&ctx, (u_char *)ck2, (u_char *)pk2);  
	}
out:
	bzero(&ctx, sizeof(ctx));
	bzero(dkkey, SR_CRYPTO_KEYBYTES);
	free(dkkey, M_DEVBUF);

	return (error);
a60 4
	rijndael_ctx		ctx;
	u_int8_t		*dkkey, *pk1, *pk2, *ck1, *ck2;
	int			i, error = 0;

d63 1
a63 29
	/*  derive key from passphrase */
	if ((error = sr_crypto_pbkdf2(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase,
	    strlen(sd->mds.mdd_crypto.scr_meta[1].scm_passphrase),
	    sd->mds.mdd_crypto.scr_meta[0].scm_salt,
	    sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_salt),
	    SR_CRYPTO_PBKDF2_ROUNDS, SR_CRYPTO_KEYBYTES, &dkkey)) != 0)
		goto out;

	if ((error = rijndael_set_key_enc_only(&ctx, dkkey,
	    SR_CRYPTO_KEYBITS)) != 0)
		goto out;

	/* encrypt keys */ 
	for (i = 0; i < SR_CRYPTO_MAXKEYS; i++) {
		pk1 = sd->mds.mdd_crypto.scr_key1[i];
		pk2 = sd->mds.mdd_crypto.scr_key2[i];
		ck1 = sd->mds.mdd_crypto.scr_meta[0].scm_key1[i];
		ck2 = sd->mds.mdd_crypto.scr_meta[0].scm_key2[i];

		/* note:  with aes-128 blocksize == keysize */
		rijndael_encrypt(&ctx, (u_char *)pk1, (u_char *)ck1);  
		rijndael_encrypt(&ctx, (u_char *)pk2, (u_char *)ck2);  
	}
out:
	bzero(&ctx, sizeof(ctx));
	bzero(dkkey, SR_CRYPTO_KEYBYTES);
	free(dkkey, M_DEVBUF);

	return (error);
a104 5
	struct cryptoini	cri;

	if (!sd)
		return (EINVAL);

d108 1
a108 20
	if (sr_alloc_wu(sd))
		return (ENOMEM);
	if (sr_alloc_ccb(sd))
		return (ENOMEM);

	if (sr_crypto_decrypt_key(sd)) {
		return (1);
	}

	bzero(&cri, sizeof(cri));
	cri.cri_alg = CRYPTO_AES_CBC;
	cri.cri_klen = SR_CRYPTO_KEYBITS;
	cri.cri_rnd = SR_CRYPTO_ROUNDS;
	cri.cri_key = sd->mds.mdd_crypto.scr_key2[0];

	/*
	 * XXX maybe we need to revisit the fact that we are only using one
	 * session even though we have 64 keys.
	 */
	return (crypto_newsession(&sd->mds.mdd_crypto.scr_sid, &cri, 0));
a113 5
	int			rv = EINVAL;

	if (!sd)
		return (rv);

d117 1
a117 13
	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta) {
		bzero(sd->mds.mdd_crypto.scr_key1,
		    sizeof(sd->mds.mdd_crypto.scr_key1));
		bzero(sd->mds.mdd_crypto.scr_key2,
		    sizeof(sd->mds.mdd_crypto.scr_key2));
		free(sd->sd_meta, M_DEVBUF);
	}

	rv = 0;
	return (rv);
a122 3
	struct cryptop		*crp;
	int			s, rv = 0;

a125 112
	if (wu->swu_xs->flags & SCSI_DATA_OUT) {
		crp = sr_crypto_getcryptop(wu, 1);
		crp->crp_callback = sr_crypto_write;
		crp->crp_opaque = wu;
		s = splvm();
		if (crypto_invoke(crp))
			rv = 1;
		splx(s);
	} else
		rv = sr_crypto_rw2(wu, NULL);

	return (rv);
}

int
sr_crypto_write(struct cryptop *crp)
{
	int			s;
#ifdef SR_DEBUG
	struct sr_workunit	*wu = crp->crp_opaque;
#endif /* SR_DEBUG */

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_write: wu %x xs: %x\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu, wu->swu_xs);

	if (crp->crp_etype) {
		/* fail io */
		((struct sr_workunit *)(crp->crp_opaque))->swu_xs->error =
		    XS_DRIVER_STUFFUP;
		s = splbio();
		sr_crypto_finish_io(crp->crp_opaque);
		splx(s);
	}

	return (sr_crypto_rw2(crp->crp_opaque, crp));
}

int
sr_crypto_rw2(struct sr_workunit *wu, struct cryptop *crp)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
	struct uio		*uio;
	int			s;
	daddr64_t		blk;

	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_crypto_rw2"))
		goto bad;

	/* calculate physical block */
	blk += SR_META_SIZE + SR_META_OFFSET;

	wu->swu_io_count = 1;

	ccb = sr_get_ccb(sd);
	if (!ccb) {
		/* should never happen but handle more gracefully */
		printf("%s: %s: too many ccbs queued\n",
		    DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	ccb->ccb_buf.b_flags = B_CALL;
	ccb->ccb_buf.b_iodone = sr_crypto_intr;
	ccb->ccb_buf.b_blkno = blk;
	ccb->ccb_buf.b_bcount = xs->datalen;
	ccb->ccb_buf.b_bufsize = xs->datalen;
	ccb->ccb_buf.b_resid = xs->datalen;

	if (xs->flags & SCSI_DATA_IN) {
		ccb->ccb_buf.b_flags |= B_READ;
		ccb->ccb_buf.b_data = xs->data;
	} else {
		uio = crp->crp_buf;
		ccb->ccb_buf.b_flags |= B_WRITE;
		ccb->ccb_buf.b_data = uio->uio_iov->iov_base;
		ccb->ccb_opaque = crp;
	}

	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_wu = wu;
	ccb->ccb_target = 0;
	ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[0]->src_dev_mm;
	ccb->ccb_buf.b_vp = NULL;

	LIST_INIT(&ccb->ccb_buf.b_dep);

	TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

	DNPRINTF(SR_D_DIS, "%s: %s: sr_crypto_rw2: b_bcount: %d "
	    "b_blkno: %x b_flags 0x%0x b_data %p\n",
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
	    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);


	s = splbio();

	if (sr_check_io_collision(wu))
		goto queued;

	sr_raid_startwu(wu);

queued:
	splx(s);
	return (0);
bad:
	/* wu is unwound by sr_put_wu */
a126 266
}

void
sr_crypto_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	struct cryptop		*crp;
	int			s, s2, pend;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr bp: %x xs: %x\n",
	    DEVNAME(sc), bp, wu->swu_xs);

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x\n", DEVNAME(sc), ccb->ccb_buf.b_bcount,
	    ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags);

	s = splbio();

	if (ccb->ccb_buf.b_flags & B_ERROR) {
		printf("%s: i/o error on block %lld\n", DEVNAME(sc),
		    ccb->ccb_buf.b_blkno);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: comp: %d count: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count);

	if (wu->swu_ios_complete == wu->swu_io_count) {
		if (wu->swu_ios_failed == wu->swu_ios_complete)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;

		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
		}

		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);

		/* do this after restarting other wus to shorten latency */
		if ((xs->flags & SCSI_DATA_IN) && (xs->error == XS_NOERROR)) {
			crp = sr_crypto_getcryptop(wu, 0);
			ccb->ccb_opaque = crp;
			crp->crp_callback = sr_crypto_read;
			crp->crp_opaque = wu;
			DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr: crypto_invoke "
			    "%p\n", DEVNAME(sc), crp);
			s2 = splvm();
			crypto_invoke(crp);
			splx(s2);
			goto done;
		}
		
		sr_crypto_finish_io(wu);
	}

done:
	splx(s);
}

void
sr_crypto_finish_io(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
#ifdef SR_DEBUG
	struct sr_softc		*sc = sd->sd_sc;
#endif /* SR_DEBUG */
	splassert(IPL_BIO);

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_finish_io: wu %x xs: %x\n",
	    DEVNAME(sc), wu, xs);

	xs->resid = 0;
	xs->flags |= ITSDONE;

	TAILQ_FOREACH(ccb, &wu->swu_ccb, ccb_link) {
		if (ccb->ccb_opaque == NULL)
			continue;
		sr_crypto_putcryptop(ccb->ccb_opaque);
	}

	/* do not change the order of these 2 functions */
	sr_put_wu(wu);
	scsi_done(xs);

	if (sd->sd_sync && sd->sd_wu_pending == 0)
		wakeup(sd);
}

int
sr_crypto_read(struct cryptop *crp)
{
	int			s;
	struct sr_workunit	*wu = crp->crp_opaque;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_read: wu %x xs: %x\n",
	    DEVNAME(wu->swu_dis->sd_sc), wu, wu->swu_xs);

	if (crp->crp_etype)
		wu->swu_xs->error = XS_DRIVER_STUFFUP;

	s = splbio();
	sr_crypto_finish_io(crp->crp_opaque);
	splx(s);

	return (0);
}

void
sr_crypto_prf(const u_int8_t *p, int plen, const u_int8_t *data, int datalen,
    u_int8_t *output)
{
	SHA1_CTX		ictx, octx;
	u_int8_t		tmp[SHA1_DIGEST_LENGTH];
	u_int8_t		*buf;
	int			i;

	/* Calculate a 160bit HMAC using SHA1 */

	buf = malloc(plen, M_DEVBUF, M_NOWAIT);

	/* apply ipad */
	for (i = 0; i < plen; i++)
		buf[i] = p[i] ^ HMAC_IPAD_VAL;
	
	/* inner hash */
	SHA1Init(&ictx);
	SHA1Update(&ictx, buf, plen);
	SHA1Update(&ictx, hmac_ipad_buffer, HMAC_BLOCK_LEN - plen);

	/* apply inner hash on text */
	SHA1Update(&ictx, data, datalen);
	SHA1Final(tmp, &ictx);

	/* apply opad, undo ipad */
	for (i = 0; i < plen; i++)
		buf[i] ^= (HMAC_IPAD_VAL ^ HMAC_OPAD_VAL);

	/* outer hash */
	SHA1Init(&octx);
	SHA1Update(&octx, buf, plen);
	SHA1Update(&octx, hmac_opad_buffer, HMAC_BLOCK_LEN - plen);

	bzero(buf, plen);
	free(buf, M_DEVBUF);

	/* apply outer hash on result of inner hash */
	SHA1Update(&octx, tmp, sizeof(tmp));
	SHA1Final(output, &octx);

	bzero(tmp, sizeof(tmp));
}

void
sr_crypto_xor(const u_int8_t *src, u_int8_t *dst, int len)
{
	int			i;

	for (i = 0; i < len; i++)
		dst[i] ^= src[i];
}

void
sr_crypto_prf_iterate(const u_int8_t *p, int plen, const u_int8_t *s, int slen,
    int c, int i, u_int8_t *dk)
{
	int			j, len;
	u_int8_t		buffer[SHA1_DIGEST_LENGTH];
	u_int8_t		*data;

	/*
	 * Concatenate salt with msb-encoded index i
	 */
	len = slen + sizeof(u_int32_t);
	data = malloc(slen + sizeof(int), M_DEVBUF, M_NOWAIT);
	bcopy(s, data, slen);
	*(u_int32_t *)(data + slen) = htonl(i);

	/*
	 * Calculate U1..c.  U1 is PRF(P, s||htonl(i)).  All other are
	 * Ux = PRF(P, Ux-1).  Return block T is U1 xor U2 xor ... Uc.
	 */
	for (j = 0; j < c; j++) {
		sr_crypto_prf(p, plen, data, len, buffer);

		if (j == 0) {
			bcopy(buffer, dk, SHA1_DIGEST_LENGTH);
			bzero(data, sizeof(data));
			free(data, M_DEVBUF);
			len = SHA1_DIGEST_LENGTH;
			data = malloc(len, M_DEVBUF, M_NOWAIT);
		} else
			sr_crypto_xor(buffer, dk, SHA1_DIGEST_LENGTH);
		bcopy(buffer, data, SHA1_DIGEST_LENGTH);
	}
	bzero(data, len);
	bzero(buffer, sizeof(buffer));
	free(data, M_DEVBUF);
}

int
sr_crypto_pbkdf2(const u_int8_t *p, int plen, const u_int8_t *s, int slen,
    int c, int dklen, u_int8_t **dk)
{
	int			l, i, rv = EINVAL;

	DNPRINTF(SR_D_DIS, "softraid0: sr_crypto_pbkdf2\n");

	if (dklen > HMAC_BLOCK_LEN) {
		DNPRINTF(SR_D_DIS, "softraid0: sr_crypto_pbkdf2: invalid "
		    "dklen\n");
		goto out;
	}

	/*
	 * Get a large enough buffer for the key, ie.
	 * dklen <= l * SHA1_DIGEST_LENGTH < dklen + SHA1_DIGEST_LENGTH
	 * This adds some extra bytes to *dk, which will be zeroed out,
	 * see below.
	 */
	l = (dklen + SHA1_DIGEST_LENGTH - 1) / SHA1_DIGEST_LENGTH;
	*dk = malloc(l * SHA1_DIGEST_LENGTH, M_DEVBUF, M_NOWAIT | M_ZERO);

	for (i = 0; i < l; i++)
		sr_crypto_prf_iterate(p, plen, s, slen, c, i, *dk +
		    i * SHA1_DIGEST_LENGTH);

	/* Zero out the extra bytes */
	bzero(*dk + dklen, l * SHA1_DIGEST_LENGTH - dklen);

	rv = 0;
out:
	return (rv);
@


1.15
log
@Cleanup, spacing and KNF.
Sprinkle some debug while here.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.14 2008/02/17 21:11:37 marco Exp $ */
d45 1
a45 1
#include <crypto/md5.h>
d80 2
a81 2
	daddr64_t		blk = 0;
	MD5_CTX			ctx;
d98 1
d100 1
a100 1
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
d102 1
a102 1
		blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
d104 1
a104 1
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
d114 5
d123 1
a123 1
	for (i = 0, crd = crp->crp_desc; crd; i++, blk++, crd = crd->crd_next) {
d132 1
a132 1
		    sd->mds.mdd_crypto.scr_key2[blk % SR_CRYPTO_MAXKEYS];
d134 1
a134 7
		/* use MD5 for IV because is exactly 16 bytes */
		MD5Init(&ctx);
		MD5Update(&ctx,
		    sd->mds.mdd_crypto.scr_key1[blk % SR_CRYPTO_MAXKEYS],
		    sizeof(sd->mds.mdd_crypto.scr_key1[0]));
		MD5Update(&ctx, (void *)&blk, sizeof blk);
		MD5Final(crd->crd_iv, &ctx);
d136 1
d168 1
d170 1
a170 1
	int			i, j, error = 0;
d182 3
d192 3
a194 4
		for (j = 0; j < SR_CRYPTO_KEYBYTES; j++) {
			pk1[j] = ck1[j] ^ dkkey[j];
			pk2[j] = ck2[j] ^ dkkey[j];
		}
d197 1
d207 1
d209 1
a209 1
	int			i, j, error = 0;
d221 5
a225 1
	/* mask keys */
d232 3
a234 4
		for (j = 0; j < SR_CRYPTO_KEYBYTES; j++) {
			ck1[j] = pk1[j] ^ dkkey[j];
			ck2[j] = pk2[j] ^ dkkey[j];
		}
d237 1
@


1.14
log
@Kill stray comment
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.13 2008/02/17 20:40:56 hshoexer Exp $ */
d167 2
a168 2
	u_int8_t	*dkkey, *pk1, *ck1, *pk2, *ck2;
	int		 i, j, error = 0;
d170 1
a170 2
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_decrypt_key\n",
	    DEVNAME(sd->sd_sc));
d202 2
a203 2
	u_int8_t	*dkkey, *pk1, *pk2, *ck1, *ck2;
	int	 	 i, j, error = 0;
d205 1
a205 2
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_encrypt_key\n",
	    DEVNAME(sd->sd_sc));
d596 4
a599 4
	SHA1_CTX	 ictx, octx;
	u_int8_t	 tmp[SHA1_DIGEST_LENGTH];
	u_int8_t	*buf;
	int		 i;
d640 1
a640 1
	int	i;
d650 3
a652 3
	int		 j, len;
	u_int8_t	 buffer[SHA1_DIGEST_LENGTH];
	u_int8_t	*data;
a681 2

	return;
d688 1
a688 1
	int	l, i;
d690 7
a696 2
	if (dklen > HMAC_BLOCK_LEN)
		return (EINVAL);
d714 3
a716 1
	return (0);
@


1.13
log
@add my copyright, too.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.12 2008/02/17 20:39:22 hshoexer Exp $ */
a19 1
/* RAID crypto functions */
@


1.12
log
@Add propper key encryption.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.11 2008/02/15 05:29:25 ckuethe Exp $ */
d6 1
@


1.11
log
@Add myself to the copyrights, ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.10 2008/02/14 22:04:34 ckuethe Exp $ */
d43 2
d57 1
d63 7
a163 1

d167 2
a168 1
	int			i;
d173 9
a181 1
	/* XXX decrypt for real! */
d183 9
a191 6
		bcopy(sd->mds.mdd_crypto.scr_meta[0].scm_key1[i],
		    sd->mds.mdd_crypto.scr_key1[i],
		    sizeof(sd->mds.mdd_crypto.scr_key1[i]));
		bcopy(sd->mds.mdd_crypto.scr_meta[0].scm_key2[i],
		    sd->mds.mdd_crypto.scr_key2[i],
		    sizeof(sd->mds.mdd_crypto.scr_key2[i]));
d193 3
d197 1
a197 1
	return (0);
d203 2
a204 1
	int			i;
d209 9
a217 1
	/* XXX encrypt for real! */
d219 9
a227 6
		bcopy(sd->mds.mdd_crypto.scr_key1[i],
		    sd->mds.mdd_crypto.scr_meta[0].scm_key1[i],
		    sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_key1[i]));
		bcopy(sd->mds.mdd_crypto.scr_key2[i],
		    sd->mds.mdd_crypto.scr_meta[0].scm_key2[i],
		    sizeof(sd->mds.mdd_crypto.scr_meta[0].scm_key2[i]));
d229 3
d233 1
a233 1
	return (0);
d258 1
a258 2
	pk1 = (u_int32_t *)
	    sd->mds.mdd_crypto.scr_meta[0].scm_salt;
d590 122
@


1.10
log
@Actually implement the crypto.
ok tedu@@ marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.9 2008/02/07 15:08:49 marco Exp $ */
d5 1
@


1.9
log
@Add optional metadata memebers.
Randomize Crypto password and add salt array.
Add mock key encryption functions.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.8 2008/02/05 16:49:25 marco Exp $ */
d42 1
d70 1
d94 1
a94 1
	n = xs->datalen >> 9;
d106 3
a108 3
	for (i = 0, crd = crp->crp_desc; crd; i++, crd = crd->crd_next) {
		crd->crd_skip = 512 * i;
		crd->crd_len = 512;
d112 12
a123 4
		crd->crd_klen = 256;
		crd->crd_rnd = 14;
		crd->crd_key = sd->mds.mdd_crypto.scr_key;
		memset(crd->crd_iv, blk + i, sizeof(crd->crd_iv));
d157 5
d163 8
a170 3
	bcopy(sd->mds.mdd_crypto.scr_meta[0].scm_key,
	    sd->mds.mdd_crypto.scr_key,
	    sizeof(sd->mds.mdd_crypto.scr_key));
d178 5
d184 8
a191 3
	bcopy(sd->mds.mdd_crypto.scr_key,
	    sd->mds.mdd_crypto.scr_meta[0].scm_key,
	    sizeof(sd->mds.mdd_crypto.scr_key));
d196 37
d255 8
a262 4
	cri.cri_klen = 256;
	cri.cri_rnd = 14;
	cri.cri_key = sd->mds.mdd_crypto.scr_key;

d281 4
a284 2
		bzero(sd->mds.mdd_crypto.scr_key,
		    sizeof(sd->mds.mdd_crypto.scr_key));
@


1.8
log
@Shave off a few more bytes by moving IO collision detection into a generic
fucntion.  Fix bug in the crypto code that could casuse data corruption as
a bonus, bad cut & past tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.7 2008/02/05 16:15:35 marco Exp $ */
d52 1
d100 1
a100 1
	crp->crp_sid = sd->mds.mdd_crypto.src_sid;
d112 1
a112 1
		crd->crd_key = sd->mds.mdd_crypto.src_key;
d143 23
d182 3
a184 3
	/* XXX we need a real key later */
	memset(sd->mds.mdd_crypto.src_key, 'k',
	    sizeof sd->mds.mdd_crypto.src_key);
d190 1
a190 1
	cri.cri_key = sd->mds.mdd_crypto.src_key;
d192 1
a192 1
	return (crypto_newsession(&sd->mds.mdd_crypto.src_sid, &cri, 0));
d209 3
a211 1
	if (sd->sd_meta)
d213 1
@


1.7
log
@Create a generic function to validate IO instead of copying and pasting
same code in all disciplines.  This shaves of a few bytes.

crypto 3185 -> 2690
raid 0 2843 -> 2378
raid 1 3474 -> 2689
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.6 2008/01/31 20:55:43 marco Exp $ */
a242 1
	struct sr_workunit	*wup;
a300 1
	/* walk queue backwards and fill in collider if we have one */
d302 2
a303 15
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
a304 1
	}
@


1.6
log
@Add me to copyright.

ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.5 2008/01/29 23:25:02 marco Exp $ */
a244 1
	struct sr_chunk		*scp;
d249 2
a250 30
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 wu: %p\n",
	    DEVNAME(sd->sd_sc), wu);

	if (sd->sd_vol.sv_meta.svm_status != BIOC_SVONLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}
	scp = sd->sd_vol.sv_chunks[0];
	if (scp->src_meta.scm_status != BIOC_SDONLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 disk offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
a251 18
	}

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 out of bounds "
		    "start: %lld end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
		goto bad;
	}
@


1.5
log
@Improve performance dramatically by preventing severeal context switches.
Decrypt only once on entry or exit instead of on in and out regardless of
direction.

There is still room for improvement but this is the first stab.

Tested by many ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.4 2008/01/27 15:02:28 marco Exp $ */
d4 1
@


1.4
log
@Oops forgot one function when adding 16 byte scsi commands.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.3 2008/01/26 19:29:55 marco Exp $ */
d50 3
a52 2
void *			sr_crypto_putcryptop(struct cryptop *);
int			sr_crypto_rw2(struct cryptop *);
d54 2
a55 1
int			sr_crypto_intr2(struct cryptop *);
d66 1
a66 1
	int			blk = 0;
d71 3
a73 2
	uio = malloc(sizeof(*uio), M_DEVBUF, M_WAITOK | M_ZERO);
	uio->uio_iov = malloc(sizeof(*uio->uio_iov), M_DEVBUF, M_WAITOK);
a74 1
	uio->uio_iov->iov_base = xs->data;
d76 6
d95 2
d115 6
d127 1
a127 1
	void			*opaque = crp->crp_opaque;
d129 2
a130 1
	DNPRINTF(SR_D_DIS, "sr_crypto_putcryptop crp: %p\n", crp);
d132 2
d138 1
a138 1
	return (opaque);
d195 1
d200 24
a223 4
	crp = sr_crypto_getcryptop(wu, 1);
	crp->crp_callback = sr_crypto_rw2;
	crp->crp_opaque = wu;
	crypto_dispatch(crp);
d225 10
a234 1
	return (0);
d238 1
a238 1
sr_crypto_rw2(struct cryptop *crp)
a239 1
	struct sr_workunit	*wu = sr_crypto_putcryptop(crp);
d245 2
a246 1
	int			s, rt;
d249 2
a250 2
	DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);
d252 8
a259 2
	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw device offline\n",
d286 2
a287 2
		DNPRINTF(SR_D_DIS, "%s: sr_crypto_rw2 out of bounds start: %lld "
		    "end: %lld length: %d\n", wu->swu_blk_start,
d313 2
a314 9
	if (xs->flags & SCSI_POLL) {
		panic("not yet, crypto poll");
		ccb->ccb_buf.b_flags = 0;
		ccb->ccb_buf.b_iodone = NULL;
	} else {
		ccb->ccb_buf.b_flags = B_CALL;
		ccb->ccb_buf.b_iodone = sr_crypto_intr;
	}

a318 4
	ccb->ccb_buf.b_data = xs->data;
	ccb->ccb_buf.b_error = 0;
	ccb->ccb_buf.b_proc = curproc;
	ccb->ccb_wu = wu;
d321 2
a322 23
		rt = 0;
ragain:
		scp = sd->sd_vol.sv_chunks[0];
		switch (scp->src_meta.scm_status) {
		case BIOC_SDONLINE:
		case BIOC_SDSCRUB:
			ccb->ccb_buf.b_flags |= B_READ;
			break;

		case BIOC_SDOFFLINE:
		case BIOC_SDREBUILD:
		case BIOC_SDHOTSPARE:
			if (rt++ < sd->sd_vol.sv_meta.svm_no_chunk)
				goto ragain;

			/* FALLTHROUGH */
		default:
			/* volume offline */
			printf("%s: is offline, can't read\n",
			    DEVNAME(sd->sd_sc));
			sr_put_ccb(ccb);
			goto bad;
		}
d324 5
a328 13
		scp = sd->sd_vol.sv_chunks[0];
		switch (scp->src_meta.scm_status) {
		case BIOC_SDONLINE:
		case BIOC_SDSCRUB:
		case BIOC_SDREBUILD:
			ccb->ccb_buf.b_flags |= B_WRITE;
			break;

		case BIOC_SDHOTSPARE: /* should never happen */
		case BIOC_SDOFFLINE:
			wu->swu_io_count--;
			sr_put_ccb(ccb);
			goto bad;
d330 3
a332 5
		default:
			goto bad;
		}

	}
d341 1
a341 1
	DNPRINTF(SR_D_DIS, "%s: %s: sr_crypto: b_bcount: %d "
a367 2
	/* XXX deal with polling */

d382 4
a385 1
	struct sr_workunit	*wu = ccb->ccb_wu;
d387 1
a387 3
#ifdef SR_DEBUG
	struct sr_softc		*sc = wu->swu_dis->sd_sc;
#endif
a395 20
	crp = sr_crypto_getcryptop(wu, 0);
	crp->crp_callback = sr_crypto_intr2;
	crp->crp_opaque = bp;
	crypto_dispatch(crp);
}

int
sr_crypto_intr2(struct cryptop *crp)
{
	struct buf		*bp = sr_crypto_putcryptop(crp);
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
	int			s, pend;

	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr2 crp: %x xs: %x\n",
	    DEVNAME(sc), crp, xs);

d414 1
a414 1
	DNPRINTF(SR_D_INTR, "%s: sr_crypto_intr2: comp: %d count: %d\n",
a422 3
		xs->resid = 0;
		xs->flags |= ITSDONE;

d446 16
a461 3
		/* do not change the order of these 2 functions */
		sr_put_wu(wu);
		scsi_done(xs);
d463 25
a487 2
		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
d490 22
@


1.3
log
@Remove duplicate protos
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.2 2008/01/24 17:50:17 marco Exp $ */
d217 2
@


1.2
log
@Bring softraid into the world of 16 byte commands; this allows for > 2TB disks
Fix bioctl size output which was off by *512; diagnosed by otto
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_crypto.c,v 1.1 2007/11/27 16:37:05 tedu Exp $ */
a50 3
int			sr_crypto_alloc_resources(struct sr_discipline *);
int			sr_crypto_free_resources(struct sr_discipline *);
int			sr_crypto_rw(struct sr_workunit *);
@


1.1
log
@split crypto functions out into their own file, so softraid.c is not such
a jungle.  ok deraadt marco
@
text
@d1 1
a1 1
/* $OpenBSD: softraid.c,v 1.86 2007/11/26 13:49:26 tedu Exp $ */
d80 2
@

