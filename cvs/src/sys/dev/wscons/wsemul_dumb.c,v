head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.6
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.12.0.8
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.6
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.12.0.4
	OPENBSD_5_6_BASE:1.12
	OPENBSD_5_5:1.11.0.4
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.10.0.12
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.10
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.8
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.6
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.7.0.10
	OPENBSD_4_6_BASE:1.7
	OPENBSD_4_5:1.7.0.6
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.4
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.2
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.4.0.4
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.2.0.20
	OPENBSD_4_0_BASE:1.2
	OPENBSD_3_9:1.2.0.18
	OPENBSD_3_9_BASE:1.2
	OPENBSD_3_8:1.2.0.16
	OPENBSD_3_8_BASE:1.2
	OPENBSD_3_7:1.2.0.14
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.12
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.10
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.8
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.2
	OPENBSD_3_3:1.2.0.6
	OPENBSD_3_3_BASE:1.2
	OPENBSD_3_2:1.2.0.4
	OPENBSD_3_2_BASE:1.2
	OPENBSD_3_1:1.2.0.2
	OPENBSD_3_1_BASE:1.2
	UBC_SYNC_B:1.2
	UBC:1.1.0.10
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.8
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.6
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.4
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	NdgfPIGUgJxQPnT7;

1.12
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.11;
commitid	OBNa5kfxQ2UXoiIw;

1.11
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.05.14.30.24;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.11.26.16.56.42;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.11.25.19.11.42;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2007.03.07.06.23.04;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches
	1.1.6.1
	1.1.10.1;
next	;

1.1.6.1
date	2001.05.14.22.26.30;	author niklas;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	;

1.1.10.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@fairly simple sizes for free(); ok tedu
@
text
@/* $OpenBSD: wsemul_dumb.c,v 1.12 2014/07/12 18:48:53 tedu Exp $ */
/* $NetBSD: wsemul_dumb.c,v 1.7 2000/01/05 11:19:36 drochner Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/ascii.h>

void	*wsemul_dumb_cnattach(const struct wsscreen_descr *, void *,
				   int, int, long);
void	*wsemul_dumb_attach(int, const struct wsscreen_descr *,
				 void *, int, int, void *, long);
u_int	wsemul_dumb_output(void *, const u_char *, u_int, int);
int	wsemul_dumb_translate(void *, kbd_t, keysym_t, const u_char **);
void	wsemul_dumb_detach(void *, u_int *, u_int *);
void	wsemul_dumb_resetop(void *, enum wsemul_resetops);

const struct wsemul_ops wsemul_dumb_ops = {
	"dumb",
	wsemul_dumb_cnattach,
	wsemul_dumb_attach,
	wsemul_dumb_output,
	wsemul_dumb_translate,
	wsemul_dumb_detach,
	wsemul_dumb_resetop
};

struct wsemul_dumb_emuldata {
	const struct wsdisplay_emulops *emulops;
	struct wsemul_abortstate abortstate;
	void *emulcookie;
	void *cbcookie;
	int crippled;
	u_int nrows, ncols, crow, ccol;
	long defattr;
};

struct wsemul_dumb_emuldata wsemul_dumb_console_emuldata;

void *
wsemul_dumb_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
{
	struct wsemul_dumb_emuldata *edp;
	const struct wsdisplay_emulops *emulops;

	edp = &wsemul_dumb_console_emuldata;

	edp->emulops = emulops = type->textops;
	edp->emulcookie = cookie;
	edp->nrows = type->nrows;
	edp->ncols = type->ncols;
	edp->crow = crow;
	edp->ccol = ccol;
	edp->defattr = defattr;
	edp->cbcookie = NULL;
	edp->crippled = emulops->cursor == NULL ||
	    emulops->copycols == NULL || emulops->copyrows == NULL ||
	    emulops->erasecols == NULL || emulops->eraserows == NULL;
	wsemul_reset_abortstate(&edp->abortstate);

	return (edp);
}

void *
wsemul_dumb_attach(int console, const struct wsscreen_descr *type, void *cookie,
    int ccol, int crow, void *cbcookie, long defattr)
{
	struct wsemul_dumb_emuldata *edp;

	if (console)
		edp = &wsemul_dumb_console_emuldata;
	else {
		edp = malloc(sizeof *edp, M_DEVBUF, M_WAITOK);

		edp->emulops = type->textops;
		edp->emulcookie = cookie;
		edp->nrows = type->nrows;
		edp->ncols = type->ncols;
		edp->crow = crow;
		edp->ccol = ccol;
		edp->defattr = defattr;
		wsemul_reset_abortstate(&edp->abortstate);
	}

	edp->cbcookie = cbcookie;

	return (edp);
}

u_int
wsemul_dumb_output(void *cookie, const u_char *data, u_int count, int kernel)
{
	struct wsemul_dumb_emuldata *edp = cookie;
	u_int processed = 0;
	u_char c;
	int n;
	int rc = 0;

	if (edp->crippled) {
		while (count-- > 0) {
			wsemul_resume_abort(&edp->abortstate);

			c = *data++;
			if (c == ASCII_BEL)
				wsdisplay_emulbell(edp->cbcookie);
			else {
				WSEMULOP(rc, edp, &edp->abortstate, putchar,
				    (edp->emulcookie, 0, 0, c, 0));
				if (rc != 0)
					break;
			}
			processed++;
		}
		if (rc != 0)
			wsemul_abort_other(&edp->abortstate);
		return processed;
	}

	switch (edp->abortstate.state) {
	case ABORT_FAILED_CURSOR:
		/*
		 * If we could not display the cursor back, we pretended not
		 * having been able to display the last character. But this
		 * is a lie, so compensate here.
		 */
		data++, count--;
		processed++;
		wsemul_reset_abortstate(&edp->abortstate);
		break;
	case ABORT_OK:
		/* remove cursor image */
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 0, edp->crow, edp->ccol);
		if (rc != 0)
			return 0;
		break;
	default:
		break;
	}

	while (count-- > 0) {
		wsemul_resume_abort(&edp->abortstate);

		c = *data++;
		switch (c) {
		case ASCII_BEL:
			wsdisplay_emulbell(edp->cbcookie);
			break;

		case ASCII_BS:
			if (edp->ccol > 0)
				edp->ccol--;
			break;

		case ASCII_CR:
			edp->ccol = 0;
			break;

		case ASCII_HT:
			n = min(8 - (edp->ccol & 7),
			    edp->ncols - edp->ccol - 1);
			WSEMULOP(rc, edp, &edp->abortstate, erasecols,
			     (edp->emulcookie, edp->crow, edp->ccol, n,
			      edp->defattr));
			if (rc != 0)
				break;
			edp->ccol += n;
			break;

		case ASCII_FF:
			WSEMULOP(rc, edp, &edp->abortstate, eraserows,
			    (edp->emulcookie, 0, edp->nrows, edp->defattr));
			if (rc != 0)
				break;
			edp->ccol = 0;
			edp->crow = 0;
			break;

		case ASCII_VT:
			if (edp->crow > 0)
				edp->crow--;
			break;

		default:
			WSEMULOP(rc, edp, &edp->abortstate, putchar,
			    (edp->emulcookie, edp->crow, edp->ccol, c,
			     edp->defattr));
			if (rc != 0)
				break;
			edp->ccol++;

			/* if cur col is still on cur line, done. */
			if (edp->ccol < edp->ncols)
				break;

			/* wrap the column around. */
			edp->ccol = 0;

                	/* FALLTHROUGH */

		case ASCII_LF:
	                /* if the cur line isn't the last, incr and leave. */
			if (edp->crow < edp->nrows - 1) {
				edp->crow++;
				break;
			}
			n = 1;		/* number of lines to scroll */
			WSEMULOP(rc, edp, &edp->abortstate, copyrows,
			    (edp->emulcookie, n, 0, edp->nrows - n));
			if (rc == 0)
				WSEMULOP(rc, edp, &edp->abortstate, eraserows,
				    (edp->emulcookie, edp->nrows - n, n,
				     edp->defattr));
			if (rc != 0) {
				/* undo wrap-at-eol processing if necessary */
				if (c != ASCII_LF)
					edp->ccol = edp->ncols - 1;
				break;
			}
			edp->crow -= n - 1;
			break;
		}
		if (rc != 0)
			break;
		processed++;
	}

	if (rc != 0)
		wsemul_abort_other(&edp->abortstate);
	else {
		/* put cursor image back */
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 1, edp->crow, edp->ccol);
		if (rc != 0) {
			/*
			 * Fail the last character output, remembering that
			 * only the cursor operation really needs to be done.
			 */
			wsemul_abort_cursor(&edp->abortstate);
			processed--;
		}
	}

	if (rc == 0)
		wsemul_reset_abortstate(&edp->abortstate);

	return processed;
}

int
wsemul_dumb_translate(void *cookie, kbd_t layout, keysym_t in,
    const u_char **out)
{
	return (0);
}

void
wsemul_dumb_detach(void *cookie, u_int *crowp, u_int *ccolp)
{
	struct wsemul_dumb_emuldata *edp = cookie;

	*crowp = edp->crow;
	*ccolp = edp->ccol;
	if (edp != &wsemul_dumb_console_emuldata)
		free(edp, M_DEVBUF, sizeof *edp);
}

void
wsemul_dumb_resetop(void *cookie, enum wsemul_resetops op)
{
	struct wsemul_dumb_emuldata *edp = cookie;

	if (edp->crippled)
		return;

	switch (op) {
	case WSEMUL_CLEARSCREEN:
		(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,
					   edp->defattr);
		edp->ccol = edp->crow = 0;
		(*edp->emulops->cursor)(edp->emulcookie, 1, 0, 0);
		break;
	case WSEMUL_CLEARCURSOR:
		(*edp->emulops->cursor)(edp->emulcookie, 0,
		    edp->crow, edp->ccol);
		break;
	default:
		break;
	}
}
@


1.12
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.11 2013/10/18 22:06:41 miod Exp $ */
d302 1
a302 1
		free(edp, M_DEVBUF, 0);
@


1.11
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.6 2007/11/26 16:56:42 miod Exp $ */
d302 1
a302 1
		free(edp, M_DEVBUF);
@


1.10
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.9 2009/09/05 14:49:20 miod Exp $ */
d50 1
a50 1
int	wsemul_dumb_translate(void *, keysym_t, const char **);
d288 2
a289 1
wsemul_dumb_translate(void *cookie, keysym_t in, const char **out)
@


1.9
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.8 2009/09/05 14:30:24 miod Exp $ */
d77 2
a78 5
wsemul_dumb_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d102 2
a103 7
wsemul_dumb_attach(console, type, cookie, ccol, crow, cbcookie, defattr)
	int console;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	void *cbcookie;
	long defattr;
d128 1
a128 5
wsemul_dumb_output(cookie, data, count, kernel)
	void *cookie;
	const u_char *data;
	u_int count;
	int kernel; /* ignored */
d288 1
a288 4
wsemul_dumb_translate(cookie, in, out)
	void *cookie;
	keysym_t in;
	const char **out;
d294 1
a294 3
wsemul_dumb_detach(cookie, crowp, ccolp)
	void *cookie;
	u_int *crowp, *ccolp;
d305 1
a305 3
wsemul_dumb_resetop(cookie, op)
	void *cookie;
	enum wsemul_resetops op;
@


1.8
log
@Make the output() wsemul_op return the number of characters processed and
check it in wsdisplaystart() to suspend output if not all characters have
been output; they will get reissued at the next tty rstrt_to timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.7 2007/11/27 16:37:27 miod Exp $ */
d47 1
a47 1
void	*wsemul_dumb_attach(int console, const struct wsscreen_descr *,
d66 1
d99 1
d127 1
d146 1
d150 2
a152 1

d155 6
a160 3
			else
				(*edp->emulops->putchar)(edp->emulcookie, 0,
				    0, c, 0);
d163 2
d168 22
a189 2
	/* XXX */
	(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow, edp->ccol);
d191 2
a193 1

d211 5
a215 2
			(*edp->emulops->erasecols)(edp->emulcookie,
			    edp->crow, edp->ccol, n, edp->defattr);
d220 4
a223 2
			(*edp->emulops->eraserows)(edp->emulcookie, 0,
			    edp->nrows, edp->defattr);
d234 5
a238 2
			(*edp->emulops->putchar)(edp->emulcookie, edp->crow,
			    edp->ccol, c, edp->defattr);
d257 12
a268 4
			(*edp->emulops->copyrows)(edp->emulcookie, n, 0,
			    edp->nrows - n);
			(*edp->emulops->eraserows)(edp->emulcookie,
			    edp->nrows - n, n, edp->defattr);
d272 2
d276 19
a294 2
	/* XXX */
	(*edp->emulops->cursor)(edp->emulcookie, 1, edp->crow, edp->ccol);
@


1.7
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.6 2007/11/26 16:56:42 miod Exp $ */
d49 3
a51 4
void	wsemul_dumb_output(void *cookie, const u_char *data, u_int count,
				int);
int	wsemul_dumb_translate(void *cookie, keysym_t, const char **);
void	wsemul_dumb_detach(void *cookie, u_int *crowp, u_int *ccolp);
d132 1
a132 1
void
d140 1
d153 1
d155 1
a155 1
		return;
d225 1
d229 2
@


1.6
log
@Constify the output of the emulops translate() function, as well as the
various tables they use.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.5 2007/11/25 19:11:42 miod Exp $ */
d223 1
a223 1
		}	
@


1.5
log
@Ask the emulation code to hide the cursor when leaving emulation mode. This
way we do not get a phantom cursor image when X exits.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.4 2007/03/07 06:23:04 miod Exp $ */
d51 1
a51 1
int	wsemul_dumb_translate(void *cookie, keysym_t, char **);
d233 1
a233 1
	char **out;
@


1.4
log
@For unsupported (yet) Expert3D style frame buffers, attach pcons and attach
a really dumb wsdisplay to pcons, so that wskbd/wsmouse input drivers can be
used for input, and prom for output.

This is a band-aid for the release, so that people with such frame buffers
do not need to unplug them or switch to serial console to install OpenBSD.

Probably not the best way to do this, but this one has a minimal footprint
and no tentacles in wscons.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.3 2007/02/14 01:12:16 jsg Exp $ */
a33 2
#include <sys/cdefs.h>

d267 4
@


1.3
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.2 2002/03/14 01:27:03 millert Exp $ */
d71 1
d86 1
d90 1
a90 1
	edp->emulops = type->textops;
d98 3
d146 13
d163 1
d259 3
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d191 1
a191 1
                	/* FALLTHRU */
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 9
a55 9
void	*wsemul_dumb_cnattach __P((const struct wsscreen_descr *, void *,
				   int, int, long));
void	*wsemul_dumb_attach __P((int console, const struct wsscreen_descr *,
				 void *, int, int, void *, long));
void	wsemul_dumb_output __P((void *cookie, const u_char *data, u_int count,
				int));
int	wsemul_dumb_translate __P((void *cookie, keysym_t, char **));
void	wsemul_dumb_detach __P((void *cookie, u_int *crowp, u_int *ccolp));
void	wsemul_dumb_resetop __P((void *, enum wsemul_resetops));
@


1.1.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d47 9
a55 9
void	*wsemul_dumb_cnattach(const struct wsscreen_descr *, void *,
				   int, int, long);
void	*wsemul_dumb_attach(int console, const struct wsscreen_descr *,
				 void *, int, int, void *, long);
void	wsemul_dumb_output(void *cookie, const u_char *data, u_int count,
				int);
int	wsemul_dumb_translate(void *cookie, keysym_t, char **);
void	wsemul_dumb_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_dumb_resetop(void *, enum wsemul_resetops);
@


1.1.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_dumb.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
@


1.1.6.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d47 9
a55 9
void	*wsemul_dumb_cnattach(const struct wsscreen_descr *, void *,
				   int, int, long);
void	*wsemul_dumb_attach(int console, const struct wsscreen_descr *,
				 void *, int, int, void *, long);
void	wsemul_dumb_output(void *cookie, const u_char *data, u_int count,
				int);
int	wsemul_dumb_translate(void *cookie, keysym_t, char **);
void	wsemul_dumb_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_dumb_resetop(void *, enum wsemul_resetops);
@


