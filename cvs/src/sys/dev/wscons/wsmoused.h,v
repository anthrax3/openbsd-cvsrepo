head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.12
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.8
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.6
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.4
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.22
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.8.0.18
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.8.0.16
	OPENBSD_5_3_BASE:1.8
	OPENBSD_5_2:1.8.0.14
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.8
	OPENBSD_5_1:1.8.0.12
	OPENBSD_5_0:1.8.0.10
	OPENBSD_5_0_BASE:1.8
	OPENBSD_4_9:1.8.0.8
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.6
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.2
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.4
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.7.0.10
	OPENBSD_4_5_BASE:1.7
	OPENBSD_4_4:1.7.0.8
	OPENBSD_4_4_BASE:1.7
	OPENBSD_4_3:1.7.0.6
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.5.0.4
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.2
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.4.0.16
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.14
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.12
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.4.0.10
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.8
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.1.0.8
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.6
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.10
date	2014.10.27.13.55.05;	author mpi;	state Exp;
branches;
next	1.9;
commitid	wJzi0sga39BzYaSt;

1.9
date	2014.05.14.18.11.24;	author shadchin;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.31.17.02.20;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.02.18.16.14;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2006.11.29.19.11.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2006.02.12.19.55.39;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.27.18.54.09;	author jbm;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.04.55.21;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.04.14.04.44.02;	author aaron;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2001.05.14.22.26.33;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	;

1.1.8.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@Stop supporting wsmoused and X in parallel.  This code is racy and
known to break mice upon resume.

ok shadchin@@
@
text
@/* $OpenBSD: wsmoused.h,v 1.9 2014/05/14 18:11:24 shadchin Exp $ */

/*
 * Copyright (c) 2001 Jean-Baptiste Marchand, Julien Montagne and Jerome Verdon
 *
 * All rights reserved.
 *
 * This code is for mouse console support under the wscons console driver.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by
 *	Hellmuth Michaelis, Brian Dunford-Shore, Joerg Wunsch, Scott Turner
 *	and Charles Hannum.
 * 4. The name authors may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

int	wsmoused(struct wsdisplay_softc *, caddr_t, int, struct proc *);

void	motion_event(struct wsscreen *, u_int, int);
void	button_event(struct wsscreen *, int, int);
int	ctrl_event(struct wsdisplay_softc *, u_int, int, struct proc *);

void	mouse_moverel(struct wsscreen *, int, int);

void	inverse_char(struct wsscreen *, u_int);
void	inverse_region(struct wsscreen *, u_int, u_int);

u_int	skip_spc_right(struct wsscreen *, int);
u_int	skip_spc_left(struct wsscreen *);
u_int	skip_char_right(struct wsscreen *, u_int);
u_int	skip_char_left(struct wsscreen *, u_int);
u_int	class_cmp(struct wsscreen *, u_int, u_int);

void	mouse_copy_start(struct wsscreen *);
void	mouse_copy_word(struct wsscreen *);
void	mouse_copy_line(struct wsscreen *);
void	mouse_copy_end(struct wsscreen *);
void	mouse_copy_extend(struct wsscreen *);
void	mouse_copy_extend_char(struct wsscreen *);
void	mouse_copy_extend_word(struct wsscreen *);
void	mouse_copy_extend_line(struct wsscreen *);
void	mouse_copy_extend_after(struct wsscreen *);
void	mouse_hide(struct wsscreen *);
void	remove_selection(struct wsscreen *);
void	mouse_copy_selection(struct wsscreen *);
void	mouse_paste(struct wsscreen *);

void	mouse_zaxis(struct wsscreen *, int);
void	allocate_copybuffer(struct wsdisplay_softc *);
void	mouse_remove(struct wsscreen *);

#define NO_BORDER 0
#define BORDER 1

#define N_COLS(dconf) 	((dconf)->scrdata->ncols)
#define N_ROWS(dconf) 	((dconf)->scrdata->nrows)

#define WS_NCOLS(scr)	N_COLS((scr)->scr_dconf)
#define WS_NROWS(scr)	N_ROWS((scr)->scr_dconf)

#define MAXCOL(dconf)	(N_COLS(dconf) - 1)
#define MAXROW(dconf)	(N_ROWS(dconf) - 1)

/* Shortcuts to the various display operations */
#define	GETCHAR(scr, pos, cellp) \
	((*(scr)->sc->sc_accessops->getchar) \
	    ((scr)->sc->sc_accesscookie, (pos) / N_COLS((scr)->scr_dconf), \
	     (pos) % N_COLS((scr)->scr_dconf), cellp))
#define PUTCHAR(dconf, pos, uc, attr) \
	((*(dconf)->emulops->putchar) \
	    ((dconf)->emulcookie, ((pos) / N_COLS(dconf)), \
	    ((pos) % N_COLS(dconf)), (uc), (attr)))

#define MOUSE_COPY_BUTTON 	0
#define MOUSE_PASTE_BUTTON 	1
#define MOUSE_EXTEND_BUTTON	2

#define IS_ALPHANUM(c) ((c) != ' ')
#define IS_SPACE(c) ((c) == ' ')
@


1.9
log
@wsmoused() called if cmd == WSDISPLAYIO_WSMOUSED only,
don't need check cmd twice.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.8 2009/05/31 17:02:20 miod Exp $ */
a71 2
void	wsmoused_release(struct wsdisplay_softc *);
void	wsmoused_wakeup(struct wsdisplay_softc *);
@


1.8
log
@The wsmouse support code has been written for pcvt long ago, then lifted
to work with wscons. Back then, the universe was simple and there was only
one single wsdisplay device, so that code would use global variables.

Overhaul this, and make sure the various routines take the wsscreen or
wsdisplay they operate on as arguments.

This will eventually allow multiple wsmoused to run, one per wsdisplay
device.

While there, use more appropriate integer types in that code, so that
unholy big displays do not cause integer overflows in coordinates
computations. As a bonus, this makes the code smaller.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.7 2006/12/02 18:16:14 miod Exp $ */
d38 1
a38 1
int	wsmoused(struct wsdisplay_softc *, u_long, caddr_t, int, struct proc *);
@


1.7
log
@Use a better strategy to make the mouse pointer visible in inverse_char();
also check the return value of alloc_attr() for failure.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.6 2006/11/29 19:11:17 miod Exp $ */
d5 1
a5 1
 * 
a35 2
 *
 *
d38 1
a38 1
struct wsdisplay_softc;
d40 34
a73 2
int wsmoused(struct wsdisplay_softc *, u_long, caddr_t, int,
		  struct proc *p);
a74 40
void motion_event(u_int, int);
void button_event(int, int);
int ctrl_event(u_int, int, struct wsdisplay_softc *, struct proc *);

void mouse_moverel(char, char);

void inverse_char(unsigned short c);
void inverse_region(unsigned short start, unsigned short end);

unsigned char skip_spc_right(char);
unsigned char skip_spc_left(void);
unsigned char skip_char_right(unsigned short);
unsigned char skip_char_left(unsigned short);
unsigned char class_cmp(unsigned short, unsigned short);

void mouse_copy_start(void);
void mouse_copy_word(void);
void mouse_copy_line(void);
void mouse_copy_end(void);
void mouse_copy_extend(void);
void mouse_copy_extend_char(void);
void mouse_copy_extend_word(void);
void mouse_copy_extend_line(void);
void mouse_hide(struct wsdisplay_softc *);
void mouse_copy_extend_after(void);
void remove_selection(struct wsdisplay_softc *);
void mouse_copy_selection(void);
void mouse_paste(void);

void mouse_zaxis(int);
void allocate_copybuffer(struct wsdisplay_softc *);
void mouse_remove(struct wsdisplay_softc *);
void wsmoused_release(struct wsdisplay_softc *);
void wsmoused_wakeup(struct wsdisplay_softc *);

extern char *Copybuffer; /* buffer that contains mouse selections */
extern u_int Copybuffer_size;
extern char Paste_avail; /* flag, to indicate whether a selection is in the
			 Copy buffer */
			      
d78 2
a79 2
#define WS_NCOLS(ws) ((ws)->scr_dconf->scrdata->ncols)
#define WS_NROWS(ws) ((ws)->scr_dconf->scrdata->nrows)
d81 2
a82 2
#define MAXCOL (WS_NCOLS(sc->sc_focus) - 1)
#define MAXROW (WS_NROWS(sc->sc_focus) - 1)
d84 2
a85 13
#define N_COLS 		(WS_NCOLS(sc->sc_focus))
#define N_ROWS 		(WS_NROWS(sc->sc_focus))
#define MOUSE 		(sc->sc_focus->mouse)
#define CURSOR 		(sc->sc_focus->cursor)
#define CPY_START	(sc->sc_focus->cpy_start)
#define CPY_END		(sc->sc_focus->cpy_end)
#define ORIG_START	(sc->sc_focus->orig_start)
#define ORIG_END	(sc->sc_focus->orig_end)
#define MOUSE_FLAGS	(sc->sc_focus->mouse_flags)

#define XY_TO_POS(col, row) (((row) * N_COLS) + (col))
#define POS_TO_X(pos) ((pos) % (N_COLS))
#define POS_TO_Y(pos) ((pos) / (N_COLS))
d88 8
a95 7
#define	GETCHAR(pos, cellp) \
	((*sc->sc_accessops->getchar) \
	    (sc->sc_accesscookie, (pos) / N_COLS, (pos) % N_COLS, cellp))
#define PUTCHAR(pos, uc, attr) \
	((*sc->sc_focus->scr_dconf->emulops->putchar) \
	    (sc->sc_focus->scr_dconf->emulcookie, ((pos) / N_COLS), \
	    ((pos) % N_COLS), (uc), (attr)))
@


1.6
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.5 2006/02/12 19:55:39 miod Exp $ */
a115 6
#define	UNPACKATTR(attr, fgp, bgp, ulp) \
	((*sc->sc_focus->scr_dconf->emulops->unpack_attr) \
	    (sc->sc_focus->scr_dconf->emulcookie, attr, fgp, bgp, ulp))
#define	ALLOCATTR(fg, bg, flags, attrp) \
	((*sc->sc_focus->scr_dconf->emulops->alloc_attr) \
	    (sc->sc_focus->scr_dconf->emulcookie, fg, bg, flags, attrp))
@


1.5
log
@Remove dead sysbeep driver and unused sysbeep() routine. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.4 2002/03/27 18:54:09 jbm Exp $ */
d108 14
a121 15
#define GET_FULLCHAR(pos)\
((*sc->sc_accessops->getchar)\
 (sc->sc_accesscookie,\
 ((pos) / N_COLS), ((pos) % N_COLS)))
 
#define GETCHAR(pos)\
(((*sc->sc_accessops->getchar)\
 (sc->sc_accesscookie,\
 ((pos) / N_COLS), ((pos) % N_COLS)))\
 & 0x000000FF)
 
#define PUTCHAR(pos, uc, attr)\
((*sc->sc_focus->scr_dconf->emulops->putchar)\
(sc->sc_focus->scr_dconf->emulcookie, ((pos) / N_COLS),\
 ((pos) % N_COLS), (uc), (attr))); 
d124 1
a124 1
#define MOUSE_PASTE_BUTTON 	1	
d127 1
a127 1
#define IS_ALPHANUM(pos) (GETCHAR((pos)) != ' ')
@


1.4
log
@Add X-Window support to wsmoused(8). This allows running wsmoused(8) and
X-Window at the same time, removing the need to kill wsmoused(8) before
starting X-Window.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.3 2002/03/14 04:55:21 mickey Exp $ */
a78 2

void sysbeep(int, int);
@


1.3
log
@initialized data cannot be common, dunno how it compiled before
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.2 2002/03/14 01:27:03 millert Exp $ */
d76 3
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.1 2001/04/14 04:44:02 aaron Exp $ */
d40 1
d79 3
a81 3
char *Copybuffer = NULL; /* buffer that contains mouse selections */
unsigned int Copybuffer_size = 0;
char Paste_avail = 0; /* flag, to indicate whether a selection is in the
@


1.1
log
@Kernel support for console mouse functionality which will be controlled by
the wsmoused daemon (replacement for moused which was used with PCVT). Adds
a "getchar" method to the display drivers which returns the value of the
character currently under the cursor (e.g., so it may be inversed). From jbm@@.

Still needs a bit of cleanup and improvement, especially X cohabitation
features. The pointer moves to fast as well. These sorts of issues will be
corrected in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d41 2
a42 2
int wsmoused __P((struct wsdisplay_softc *, u_long, caddr_t, int,
		  struct proc *p));
d44 28
a71 28
void motion_event __P((u_int, int));
void button_event __P((int, int));
int ctrl_event __P((u_int, int, struct wsdisplay_softc *, struct proc *));

void mouse_moverel __P((char, char));

void inverse_char __P((unsigned short c));
void inverse_region __P((unsigned short start, unsigned short end));

unsigned char skip_spc_right __P((char));
unsigned char skip_spc_left __P((void));
unsigned char skip_char_right __P((unsigned short));
unsigned char skip_char_left __P((unsigned short));
unsigned char class_cmp __P((unsigned short, unsigned short));

void mouse_copy_start __P((void));
void mouse_copy_word __P((void));
void mouse_copy_line __P((void));
void mouse_copy_end __P((void));
void mouse_copy_extend __P((void));
void mouse_copy_extend_char __P((void));
void mouse_copy_extend_word __P((void));
void mouse_copy_extend_line __P((void));
void mouse_hide __P((struct wsdisplay_softc *));
void mouse_copy_extend_after __P((void));
void remove_selection __P((struct wsdisplay_softc *));
void mouse_copy_selection __P((void));
void mouse_paste __P((void));
d73 2
a74 2
void mouse_zaxis __P((int));
void allocate_copybuffer __P((struct wsdisplay_softc *));
d76 1
a76 1
void sysbeep __P((int, int));
@


1.1.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.1 2001/04/14 04:44:02 aaron Exp $ */
a39 1
struct wsdisplay_softc;
d41 2
a42 2
int wsmoused(struct wsdisplay_softc *, u_long, caddr_t, int,
		  struct proc *p);
d44 37
a80 40
void motion_event(u_int, int);
void button_event(int, int);
int ctrl_event(u_int, int, struct wsdisplay_softc *, struct proc *);

void mouse_moverel(char, char);

void inverse_char(unsigned short c);
void inverse_region(unsigned short start, unsigned short end);

unsigned char skip_spc_right(char);
unsigned char skip_spc_left(void);
unsigned char skip_char_right(unsigned short);
unsigned char skip_char_left(unsigned short);
unsigned char class_cmp(unsigned short, unsigned short);

void mouse_copy_start(void);
void mouse_copy_word(void);
void mouse_copy_line(void);
void mouse_copy_end(void);
void mouse_copy_extend(void);
void mouse_copy_extend_char(void);
void mouse_copy_extend_word(void);
void mouse_copy_extend_line(void);
void mouse_hide(struct wsdisplay_softc *);
void mouse_copy_extend_after(void);
void remove_selection(struct wsdisplay_softc *);
void mouse_copy_selection(void);
void mouse_paste(void);

void mouse_zaxis(int);
void allocate_copybuffer(struct wsdisplay_softc *);
void mouse_remove(struct wsdisplay_softc *);
void wsmoused_release(struct wsdisplay_softc *);
void wsmoused_wakeup(struct wsdisplay_softc *);

void sysbeep(int, int);

extern char *Copybuffer; /* buffer that contains mouse selections */
extern u_int Copybuffer_size;
extern char Paste_avail; /* flag, to indicate whether a selection is in the
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsmoused.h,v 1.1 2001/04/14 04:44:02 aaron Exp $ */
@


1.1.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a39 1
struct wsdisplay_softc;
d41 2
a42 2
int wsmoused(struct wsdisplay_softc *, u_long, caddr_t, int,
		  struct proc *p);
d44 37
a80 37
void motion_event(u_int, int);
void button_event(int, int);
int ctrl_event(u_int, int, struct wsdisplay_softc *, struct proc *);

void mouse_moverel(char, char);

void inverse_char(unsigned short c);
void inverse_region(unsigned short start, unsigned short end);

unsigned char skip_spc_right(char);
unsigned char skip_spc_left(void);
unsigned char skip_char_right(unsigned short);
unsigned char skip_char_left(unsigned short);
unsigned char class_cmp(unsigned short, unsigned short);

void mouse_copy_start(void);
void mouse_copy_word(void);
void mouse_copy_line(void);
void mouse_copy_end(void);
void mouse_copy_extend(void);
void mouse_copy_extend_char(void);
void mouse_copy_extend_word(void);
void mouse_copy_extend_line(void);
void mouse_hide(struct wsdisplay_softc *);
void mouse_copy_extend_after(void);
void remove_selection(struct wsdisplay_softc *);
void mouse_copy_selection(void);
void mouse_paste(void);

void mouse_zaxis(int);
void allocate_copybuffer(struct wsdisplay_softc *);

void sysbeep(int, int);

extern char *Copybuffer; /* buffer that contains mouse selections */
extern u_int Copybuffer_size;
extern char Paste_avail; /* flag, to indicate whether a selection is in the
@


1.1.4.3
log
@Sync the SMP branch with 3.3
@
text
@a75 3
void mouse_remove(struct wsdisplay_softc *);
void wsmoused_release(struct wsdisplay_softc *);
void wsmoused_wakeup(struct wsdisplay_softc *);
@


