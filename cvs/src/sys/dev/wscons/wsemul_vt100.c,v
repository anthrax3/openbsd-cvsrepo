head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.2
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.33.0.8
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.4
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.32.0.8
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.6
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.4
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.29.0.2
	OPENBSD_5_4_BASE:1.29
	OPENBSD_5_3:1.28.0.8
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.6
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.4
	OPENBSD_5_0:1.28.0.2
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.27.0.2
	OPENBSD_4_9_BASE:1.27
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.23.0.6
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.2
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.22.0.4
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.2
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.18.0.4
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.6
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.4
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.9.0.2
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.8.0.6
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.4
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.2
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.8
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.36
date	2017.08.10.09.12.32;	author fcambus;	state Exp;
branches;
next	1.35;
commitid	fWexIgmyzkNaDHqF;

1.35
date	2017.04.11.14.43.49;	author dhill;	state Exp;
branches;
next	1.34;
commitid	zztPc3QpQPdWwQ6h;

1.34
date	2017.04.09.18.05.17;	author dhill;	state Exp;
branches;
next	1.33;
commitid	qFYN4Fi1MeDqwnL7;

1.33
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	NdgfPIGUgJxQPnT7;

1.32
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.31;
commitid	OBNa5kfxQ2UXoiIw;

1.31
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2013.10.18.13.54.09;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.06.16.19.04.20;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2011.08.04.04.18.42;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.01.21.17.16;	author nicm;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.05.14.30.24;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.05.13.43.58;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2009.01.12.20.43.53;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.25.19.11.43;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.18;

1.18
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.01.07.13.31.36;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2007.01.07.13.28.50;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.19.17.35.09;	author dim;	state Exp;
branches;
next	1.14;

1.14
date	2006.10.09.05.21.50;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2006.08.17.06.27.04;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.25.20.40.33;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.12.23.21.47.46;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.23.21.45.51;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.04.14.04.48.01;	author aaron;	state Exp;
branches
	1.6.4.1
	1.6.8.1;
next	1.5;

1.5
date	2001.03.07.17.51.29;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.20.05.40.23;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.02.10.19.42.06;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.26.31;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.36
log
@Remove some case statements which have been compiled out since 2000.

OK mpi@@
@
text
@/* $OpenBSD: wsemul_vt100.c,v 1.35 2017/04/11 14:43:49 dhill Exp $ */
/* $NetBSD: wsemul_vt100.c,v 1.13 2000/04/28 21:56:16 mycroft Exp $ */

/*
 * Copyright (c) 2007, 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>

#include <dev/wscons/wscons_features.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wsemul_vt100var.h>
#include <dev/wscons/ascii.h>

void	*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_vt100_attach(int, const struct wsscreen_descr *,
				  void *, int, int, void *, long);
u_int	wsemul_vt100_output(void *, const u_char *, u_int, int);
void	wsemul_vt100_detach(void *, u_int *, u_int *);
void	wsemul_vt100_resetop(void *, enum wsemul_resetops);

const struct wsemul_ops wsemul_vt100_ops = {
	"vt100",
	wsemul_vt100_cnattach,
	wsemul_vt100_attach,
	wsemul_vt100_output,
	wsemul_vt100_translate,
	wsemul_vt100_detach,
	wsemul_vt100_resetop
};

struct wsemul_vt100_emuldata wsemul_vt100_console_emuldata;

void	wsemul_vt100_init(struct wsemul_vt100_emuldata *,
	    const struct wsscreen_descr *, void *, int, int, long);
int	wsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *,
	    const u_char *, u_int, int);
int	wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *,
	    struct wsemul_inputstate *, int);
int	wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *,
	    struct wsemul_inputstate *, int);
int	wsemul_vt100_nextline(struct wsemul_vt100_emuldata *);

typedef int vt100_handler(struct wsemul_vt100_emuldata *, struct
	    wsemul_inputstate *);
vt100_handler
	wsemul_vt100_output_esc,
	wsemul_vt100_output_csi,
	wsemul_vt100_output_scs94,
	wsemul_vt100_output_scs94_percent,
	wsemul_vt100_output_scs96,
	wsemul_vt100_output_scs96_percent,
	wsemul_vt100_output_esc_hash,
	wsemul_vt100_output_esc_spc,
	wsemul_vt100_output_string,
	wsemul_vt100_output_string_esc,
	wsemul_vt100_output_dcs,
	wsemul_vt100_output_dcs_dollar,
	wsemul_vt100_output_esc_percent;

#define	VT100_EMUL_STATE_NORMAL		0	/* normal processing */
#define	VT100_EMUL_STATE_ESC		1	/* got ESC */
#define	VT100_EMUL_STATE_CSI		2	/* got CSI (ESC[) */
#define	VT100_EMUL_STATE_SCS94		3	/* got ESC{()*+} */
#define	VT100_EMUL_STATE_SCS94_PERCENT	4	/* got ESC{()*+}% */
#define	VT100_EMUL_STATE_SCS96		5	/* got ESC{-./} */
#define	VT100_EMUL_STATE_SCS96_PERCENT	6	/* got ESC{-./}% */
#define	VT100_EMUL_STATE_ESC_HASH	7	/* got ESC# */
#define	VT100_EMUL_STATE_ESC_SPC	8	/* got ESC<SPC> */
#define	VT100_EMUL_STATE_STRING		9	/* waiting for ST (ESC\) */
#define	VT100_EMUL_STATE_STRING_ESC	10	/* waiting for ST, got ESC */
#define	VT100_EMUL_STATE_DCS		11	/* got DCS (ESC P) */
#define	VT100_EMUL_STATE_DCS_DOLLAR	12	/* got DCS<p>$ */
#define	VT100_EMUL_STATE_ESC_PERCENT	13	/* got ESC% */

vt100_handler *vt100_output[] = {
	wsemul_vt100_output_esc,
	wsemul_vt100_output_csi,
	wsemul_vt100_output_scs94,
	wsemul_vt100_output_scs94_percent,
	wsemul_vt100_output_scs96,
	wsemul_vt100_output_scs96_percent,
	wsemul_vt100_output_esc_hash,
	wsemul_vt100_output_esc_spc,
	wsemul_vt100_output_string,
	wsemul_vt100_output_string_esc,
	wsemul_vt100_output_dcs,
	wsemul_vt100_output_dcs_dollar,
	wsemul_vt100_output_esc_percent,
};

void
wsemul_vt100_init(struct wsemul_vt100_emuldata *edp,
    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,
    long defattr)
{
	edp->emulops = type->textops;
	edp->emulcookie = cookie;
	edp->scrcapabilities = type->capabilities;
	edp->nrows = type->nrows;
	edp->ncols = type->ncols;
	edp->crow = crow;
	edp->ccol = ccol;
	edp->defattr = defattr;
	wsemul_reset_abortstate(&edp->abortstate);
}

void *
wsemul_vt100_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
{
	struct wsemul_vt100_emuldata *edp;
	int res;

	edp = &wsemul_vt100_console_emuldata;
	wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);
#ifdef DIAGNOSTIC
	edp->console = 1;
#endif
	edp->cbcookie = NULL;

#ifndef WS_KERNEL_FG
#define WS_KERNEL_FG WSCOL_WHITE
#endif
#ifndef WS_KERNEL_BG
#define WS_KERNEL_BG WSCOL_BLUE
#endif
#ifndef WS_KERNEL_COLATTR
#define WS_KERNEL_COLATTR 0
#endif
#ifndef WS_KERNEL_MONOATTR
#define WS_KERNEL_MONOATTR 0
#endif
	if (type->capabilities & WSSCREEN_WSCOLORS)
		res = (*edp->emulops->alloc_attr)(cookie,
		    WS_KERNEL_FG, WS_KERNEL_BG,
		    WS_KERNEL_COLATTR | WSATTR_WSCOLORS, &edp->kernattr);
	else
		res = (*edp->emulops->alloc_attr)(cookie, 0, 0,
		    WS_KERNEL_MONOATTR, &edp->kernattr);
	if (res)
		edp->kernattr = defattr;

	edp->tabs = NULL;
	edp->dblwid = NULL;
	edp->dw = 0;
	edp->dcsarg = 0;
	edp->isolatin1tab = edp->decgraphtab = edp->dectechtab = NULL;
	edp->nrctab = NULL;
	wsemul_vt100_reset(edp);
	return (edp);
}

void *
wsemul_vt100_attach(int console, const struct wsscreen_descr *type,
    void *cookie, int ccol, int crow, void *cbcookie, long defattr)
{
	struct wsemul_vt100_emuldata *edp;

	if (console) {
		edp = &wsemul_vt100_console_emuldata;
#ifdef DIAGNOSTIC
		KASSERT(edp->console == 1);
#endif
	} else {
		edp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);
		if (edp == NULL)
			return (NULL);
		wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr);
#ifdef DIAGNOSTIC
		edp->console = 0;
#endif
	}
	edp->cbcookie = cbcookie;

	edp->tabs = malloc(edp->ncols, M_DEVBUF, M_NOWAIT);
	edp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT | M_ZERO);
	edp->dw = 0;
	edp->dcsarg = malloc(DCS_MAXLEN, M_DEVBUF, M_NOWAIT);
	edp->isolatin1tab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->decgraphtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->dectechtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->nrctab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	vt100_initchartables(edp);
	wsemul_vt100_reset(edp);
	return (edp);
}

void
wsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp)
{
	struct wsemul_vt100_emuldata *edp = cookie;

	*crowp = edp->crow;
	*ccolp = edp->ccol;
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF, 0); ptr = NULL;}
	f(edp->tabs)
	f(edp->dblwid)
	f(edp->dcsarg)
	f(edp->isolatin1tab)
	f(edp->decgraphtab)
	f(edp->dectechtab)
	f(edp->nrctab)
#undef f
	if (edp != &wsemul_vt100_console_emuldata)
		free(edp, M_DEVBUF, sizeof *edp);
}

void
wsemul_vt100_resetop(void *cookie, enum wsemul_resetops op)
{
	struct wsemul_vt100_emuldata *edp = cookie;

	switch (op) {
	case WSEMUL_RESET:
		wsemul_vt100_reset(edp);
		break;
	case WSEMUL_SYNCFONT:
		vt100_initchartables(edp);
		break;
	case WSEMUL_CLEARSCREEN:
		(void)wsemul_vt100_ed(edp, 2);
		edp->ccol = edp->crow = 0;
		(*edp->emulops->cursor)(edp->emulcookie,
		    edp->flags & VTFL_CURSORON, 0, 0);
		break;
	case WSEMUL_CLEARCURSOR:
		(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,
		    edp->ccol);
		break;
	default:
		break;
	}
}

void
wsemul_vt100_reset(struct wsemul_vt100_emuldata *edp)
{
	int i;

	edp->state = VT100_EMUL_STATE_NORMAL;
	edp->flags = VTFL_DECAWM | VTFL_CURSORON;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_WHITE;
	edp->bgcol = WSCOL_BLACK;
	edp->scrreg_startrow = 0;
	edp->scrreg_nrows = edp->nrows;
	if (edp->tabs) {
		memset(edp->tabs, 0, edp->ncols);
		for (i = 8; i < edp->ncols; i += 8)
			edp->tabs[i] = 1;
	}
	edp->dcspos = 0;
	edp->dcstype = 0;
	edp->chartab_G[0] = NULL;
	edp->chartab_G[1] = edp->nrctab; /* ??? */
	edp->chartab_G[2] = edp->isolatin1tab;
	edp->chartab_G[3] = edp->isolatin1tab;
	edp->chartab0 = 0;
	edp->chartab1 = 2;
	edp->sschartab = 0;
}

/*
 * Move the cursor to the next line if possible. If the cursor is at
 * the bottom of the scroll area, then scroll it up. If the cursor is
 * at the bottom of the screen then don't move it down.
 */
int
wsemul_vt100_nextline(struct wsemul_vt100_emuldata *edp)
{
	int rc;

	if (ROWS_BELOW == 0) {
		/* Bottom of the scroll region. */
	  	rc = wsemul_vt100_scrollup(edp, 1);
	} else {
		if ((edp->crow+1) < edp->nrows)
			/* Cursor not at the bottom of the screen. */
			edp->crow++;
		CHECK_DW;
		rc = 0;
	}

	return rc;
}

/*
 * now all the state machine bits
 */

int
wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate, int kernel)
{
	u_int *ct, dc;
	u_char c;
	int oldsschartab = edp->sschartab;
	int rc = 0;

	if ((edp->flags & (VTFL_LASTCHAR | VTFL_DECAWM)) ==
	    (VTFL_LASTCHAR | VTFL_DECAWM)) {
		rc = wsemul_vt100_nextline(edp);
		if (rc != 0)
			return rc;
		edp->ccol = 0;
		edp->flags &= ~VTFL_LASTCHAR;
	}

#ifdef HAVE_UTF8_SUPPORT
	if (edp->flags & VTFL_UTF8) {
		(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &dc);
	} else
#endif
	{
		c = instate->inchar & 0xff;
		if (c & 0x80) {
			c &= 0x7f;
			ct = edp->chartab_G[edp->chartab1];
		} else {
			if (edp->sschartab) {
				ct = edp->chartab_G[edp->sschartab];
				edp->sschartab = 0;
			} else
				ct = edp->chartab_G[edp->chartab0];
		}
		dc = ct ? ct[c] : c;
	}

	if ((edp->flags & VTFL_INSERTMODE) && COLS_LEFT) {
		WSEMULOP(rc, edp, &edp->abortstate, copycols,
		    COPYCOLS(edp->ccol, edp->ccol + 1, COLS_LEFT));
		if (rc != 0) {
			/* undo potential sschartab update */
			edp->sschartab = oldsschartab;

			return rc;
		}
	}

	WSEMULOP(rc, edp, &edp->abortstate, putchar,
	    (edp->emulcookie, edp->crow, edp->ccol << edp->dw, dc,
	     kernel ? edp->kernattr : edp->curattr));
	if (rc != 0) {
		/* undo potential sschartab update */
		edp->sschartab = oldsschartab;

		return rc;
	}

	if (COLS_LEFT)
		edp->ccol++;
	else
		edp->flags |= VTFL_LASTCHAR;

	return 0;
}

int
wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate, int kernel)
{
	u_int n;
	int rc = 0;

	switch (instate->inchar) {
	case ASCII_NUL:
	default:
		/* ignore */
		break;
	case ASCII_BEL:
		if (edp->state == VT100_EMUL_STATE_STRING) {
			/* acts as an equivalent to the ``ESC \'' string end */
			wsemul_vt100_handle_dcs(edp);
			edp->state = VT100_EMUL_STATE_NORMAL;
		} else {
			wsdisplay_emulbell(edp->cbcookie);
		}
		break;
	case ASCII_BS:
		if (edp->ccol > 0) {
			edp->ccol--;
			edp->flags &= ~VTFL_LASTCHAR;
		}
		break;
	case ASCII_CR:
		edp->ccol = 0;
		break;
	case ASCII_HT:
		if (edp->tabs) {
			if (!COLS_LEFT)
				break;
			for (n = edp->ccol + 1; n < NCOLS - 1; n++)
				if (edp->tabs[n])
					break;
		} else {
			n = edp->ccol + min(8 - (edp->ccol & 7), COLS_LEFT);
		}
		edp->ccol = n;
		break;
	case ASCII_SO: /* LS1 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 1;
		break;
	case ASCII_SI: /* LS0 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 0;
		break;
	case ASCII_ESC:
		if (kernel) {
			printf("wsemul_vt100_output_c0c1: ESC in kernel "
			    "output ignored\n");
			break;	/* ignore the ESC */
		}

		if (edp->state == VT100_EMUL_STATE_STRING) {
			/* might be a string end */
			edp->state = VT100_EMUL_STATE_STRING_ESC;
		} else {
			/* XXX cancel current escape sequence */
			edp->state = VT100_EMUL_STATE_ESC;
		}
		break;
	case ASCII_CAN:
	case ASCII_SUB:
		/* cancel current escape sequence */
		edp->state = VT100_EMUL_STATE_NORMAL;
		break;
	case ASCII_LF:
	case ASCII_VT:
	case ASCII_FF:
		rc = wsemul_vt100_nextline(edp);
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	return rc;
}

int
wsemul_vt100_output_esc(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;
	int rc = 0;
	int i;

	switch (instate->inchar) {
	case '[': /* CSI */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->modif1 = edp->modif2 = '\0';
		newstate = VT100_EMUL_STATE_CSI;
		break;
	case '7': /* DECSC */
		edp->flags |= VTFL_SAVEDCURS;
		edp->savedcursor_row = edp->crow;
		edp->savedcursor_col = edp->ccol;
		edp->savedattr = edp->curattr;
		edp->savedbkgdattr = edp->bkgdattr;
		edp->savedattrflags = edp->attrflags;
		edp->savedfgcol = edp->fgcol;
		edp->savedbgcol = edp->bgcol;
		for (i = 0; i < 4; i++)
			edp->savedchartab_G[i] = edp->chartab_G[i];
		edp->savedchartab0 = edp->chartab0;
		edp->savedchartab1 = edp->chartab1;
		break;
	case '8': /* DECRC */
		if ((edp->flags & VTFL_SAVEDCURS) == 0)
			break;
		edp->crow = edp->savedcursor_row;
		edp->ccol = edp->savedcursor_col;
		edp->curattr = edp->savedattr;
		edp->bkgdattr = edp->savedbkgdattr;
		edp->attrflags = edp->savedattrflags;
		edp->fgcol = edp->savedfgcol;
		edp->bgcol = edp->savedbgcol;
		for (i = 0; i < 4; i++)
			edp->chartab_G[i] = edp->savedchartab_G[i];
		edp->chartab0 = edp->savedchartab0;
		edp->chartab1 = edp->savedchartab1;
		break;
	case '=': /* DECKPAM application mode */
		edp->flags |= VTFL_APPLKEYPAD;
		break;
	case '>': /* DECKPNM numeric mode */
		edp->flags &= ~VTFL_APPLKEYPAD;
		break;
	case 'E': /* NEL */
		edp->ccol = 0;
		/* FALLTHROUGH */
	case 'D': /* IND */
		rc = wsemul_vt100_nextline(edp);
		break;
	case 'H': /* HTS */
		if (edp->tabs != NULL)
			edp->tabs[edp->ccol] = 1;
		break;
	case '~': /* LS1R */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab1 = 1;
		break;
	case 'n': /* LS2 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 2;
		break;
	case '}': /* LS2R */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab1 = 2;
		break;
	case 'o': /* LS3 */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab0 = 3;
		break;
	case '|': /* LS3R */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab1 = 3;
		break;
	case 'N': /* SS2 */
		edp->flags &= ~VTFL_UTF8;
		edp->sschartab = 2;
		break;
	case 'O': /* SS3 */
		edp->flags &= ~VTFL_UTF8;
		edp->sschartab = 3;
		break;
	case 'M': /* RI */
		if (ROWS_ABOVE > 0) {
			edp->crow--;
			CHECK_DW;
			break;
		}
		rc = wsemul_vt100_scrolldown(edp, 1);
		break;
	case 'P': /* DCS */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		newstate = VT100_EMUL_STATE_DCS;
		break;
	case 'c': /* RIS */
		wsemul_vt100_reset(edp);
		rc = wsemul_vt100_ed(edp, 2);
		if (rc != 0)
			break;
		edp->ccol = edp->crow = 0;
		break;
	case '(': case ')': case '*': case '+': /* SCS */
		edp->designating = instate->inchar - '(';
		newstate = VT100_EMUL_STATE_SCS94;
		break;
	case '-': case '.': case '/': /* SCS */
		edp->designating = instate->inchar - '-' + 1;
		newstate = VT100_EMUL_STATE_SCS96;
		break;
	case '#':
		newstate = VT100_EMUL_STATE_ESC_HASH;
		break;
	case ' ': /* 7/8 bit */
		newstate = VT100_EMUL_STATE_ESC_SPC;
		break;
	case ']': /* OSC operating system command */
	case '^': /* PM privacy message */
	case '_': /* APC application program command */
		/* ignored */
		newstate = VT100_EMUL_STATE_STRING;
		break;
	case '<': /* exit VT52 mode - ignored */
		break;
	case '%': /* UTF-8 encoding sequences */
		newstate = VT100_EMUL_STATE_ESC_PERCENT;
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC %x unknown\n", instate->inchar);
#endif
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	if (rc != 0)
		return rc;

	edp->state = newstate;
	return 0;
}

int
wsemul_vt100_output_scs94(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;

	switch (instate->inchar) {
	case '%': /* probably DEC supplemental graphic */
		newstate = VT100_EMUL_STATE_SCS94_PERCENT;
		break;
	case 'A': /* british / national */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->nrctab;
		break;
	case 'B': /* ASCII */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = 0;
		break;
	case '<': /* user preferred supplemental */
		/* XXX not really "user" preferred */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	case '0': /* DEC special graphic */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->decgraphtab;
		break;
	case '>': /* DEC tech */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->dectechtab;
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c %x unknown\n", edp->designating + '(',
		    instate->inchar);
#endif
		break;
	}

	edp->state = newstate;
	return 0;
}

int
wsemul_vt100_output_scs94_percent(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case '5': /* DEC supplemental graphic */
		/* XXX there are differences */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%% %x unknown\n", edp->designating + '(',
		    instate->inchar);
#endif
		break;
	}

	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}

int
wsemul_vt100_output_scs96(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int newstate = VT100_EMUL_STATE_NORMAL;
	int nrc;

	switch (instate->inchar) {
	case '%': /* probably portuguese */
		newstate = VT100_EMUL_STATE_SCS96_PERCENT;
		break;
	case 'A': /* ISO-latin-1 supplemental */
		edp->flags &= ~VTFL_UTF8;
		edp->chartab_G[edp->designating] = edp->isolatin1tab;
		break;
	case '4': /* dutch */
		nrc = 1;
		goto setnrc;
	case '5': case 'C': /* finnish */
		nrc = 2;
		goto setnrc;
	case 'R': /* french */
		nrc = 3;
		goto setnrc;
	case 'Q': /* french canadian */
		nrc = 4;
		goto setnrc;
	case 'K': /* german */
		nrc = 5;
		goto setnrc;
	case 'Y': /* italian */
		nrc = 6;
		goto setnrc;
	case 'E': case '6': /* norwegian / danish */
		nrc = 7;
		goto setnrc;
	case 'Z': /* spanish */
		nrc = 9;
		goto setnrc;
	case '7': case 'H': /* swedish */
		nrc = 10;
		goto setnrc;
	case '=': /* swiss */
		nrc = 11;
setnrc:
		if (vt100_setnrc(edp, nrc) == 0) /* what table ??? */
			break;
		/* else FALLTHROUGH */
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c %x unknown\n", edp->designating + '-' - 1,
		    instate->inchar);
#endif
		break;
	}

	edp->state = newstate;
	return 0;
}

int
wsemul_vt100_output_scs96_percent(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case '6': /* portuguese */
		if (vt100_setnrc(edp, 8) == 0)
			break;
		/* else FALLTHROUGH */
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC%c%% %x unknown\n", edp->designating + '-' - 1,
		    instate->inchar);
#endif
		break;
	}

	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}

int
wsemul_vt100_output_esc_spc(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case 'F': /* 7-bit controls */
	case 'G': /* 8-bit controls */
#ifdef VT100_PRINTNOTIMPL
		printf("ESC<SPC> %x ignored\n", instate->inchar);
#endif
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC<SPC> %x unknown\n", instate->inchar);
#endif
		break;
	}

	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}

int
wsemul_vt100_output_string(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	if (edp->dcstype && edp->dcspos < DCS_MAXLEN) {
		if (instate->inchar & ~0xff) {
#ifdef VT100_PRINTUNKNOWN
			printf("unknown char %x in DCS\n", instate->inchar);
#endif
		} else
			edp->dcsarg[edp->dcspos++] = (char)instate->inchar;
	}

	edp->state = VT100_EMUL_STATE_STRING;
	return 0;
}

int
wsemul_vt100_output_string_esc(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	if (instate->inchar == '\\') { /* ST complete */
		wsemul_vt100_handle_dcs(edp);
		edp->state = VT100_EMUL_STATE_NORMAL;
	} else
		edp->state = VT100_EMUL_STATE_STRING;

	return 0;
}

int
wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int newstate = VT100_EMUL_STATE_DCS;

	switch (instate->inchar) {
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		/* argument digit */
		if (edp->nargs > VT100_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (instate->inchar - '0');
		break;
	case ';': /* argument terminator */
		edp->nargs++;
		break;
	default:
		edp->nargs++;
		if (edp->nargs > VT100_EMUL_NARGS) {
#ifdef VT100_DEBUG
			printf("vt100: too many arguments\n");
#endif
			edp->nargs = VT100_EMUL_NARGS;
		}
		newstate = VT100_EMUL_STATE_STRING;
		switch (instate->inchar) {
		case '$':
			newstate = VT100_EMUL_STATE_DCS_DOLLAR;
			break;
		case '{': /* DECDLD soft charset */	/* } */
		case '!': /* DECRQUPSS user preferred supplemental set */
			/* 'u' must follow - need another state */
		case '|': /* DECUDK program F6..F20 */
#ifdef VT100_PRINTNOTIMPL
			printf("DCS%c ignored\n", (char)instate->inchar);
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("DCS %x (%d, %d) unknown\n", instate->inchar,
			    ARG(0), ARG(1));
#endif
			break;
		}
	}

	edp->state = newstate;
	return 0;
}

int
wsemul_vt100_output_dcs_dollar(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case 'p': /* DECRSTS terminal state restore */
	case 'q': /* DECRQSS control function request */
#ifdef VT100_PRINTNOTIMPL
		printf("DCS$%c ignored\n", (char)instate->inchar);
#endif
		break;
	case 't': /* DECRSPS restore presentation state */
		switch (ARG(0)) {
		case 0: /* error */
			break;
		case 1: /* cursor information restore */
#ifdef VT100_PRINTNOTIMPL
			printf("DCS1$t ignored\n");
#endif
			break;
		case 2: /* tab stop restore */
			edp->dcspos = 0;
			edp->dcstype = DCSTYPE_TABRESTORE;
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("DCS%d$t unknown\n", ARG(0));
#endif
			break;
		}
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("DCS$ %x (%d, %d) unknown\n",
		    instate->inchar, ARG(0), ARG(1));
#endif
		break;
	}

	edp->state = VT100_EMUL_STATE_STRING;
	return 0;
}

int
wsemul_vt100_output_esc_percent(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
#ifdef HAVE_UTF8_SUPPORT
	case 'G':
		edp->flags |= VTFL_UTF8;
		edp->kstate.mbleft = edp->instate.mbleft = 0;
		break;
	case '@@':
		edp->flags &= ~VTFL_UTF8;
		break;
#endif
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC% %x unknown\n", instate->inchar);
#endif
		break;
	}
	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}

int
wsemul_vt100_output_esc_hash(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	int i;
	int rc = 0;

	switch (instate->inchar) {
	case '5': /*  DECSWL single width, single height */
		if (edp->dblwid != NULL && edp->dw != 0) {
			for (i = 0; i < edp->ncols / 2; i++) {
				WSEMULOP(rc, edp, &edp->abortstate, copycols,
				    (edp->emulcookie, edp->crow, 2 * i, i, 1));
				if (rc != 0)
					return rc;
			}
			WSEMULOP(rc, edp, &edp->abortstate, erasecols,
			    (edp->emulcookie, edp->crow, i, edp->ncols - i,
			     edp->bkgdattr));
			if (rc != 0)
				return rc;
			edp->dblwid[edp->crow] = 0;
			edp->dw = 0;
		}
		break;
	case '6': /*  DECDWL double width, single height */
	case '3': /*  DECDHL double width, double height, top half */
	case '4': /*  DECDHL double width, double height, bottom half */
		if (edp->dblwid != NULL && edp->dw == 0) {
			for (i = edp->ncols / 2 - 1; i >= 0; i--) {
				WSEMULOP(rc, edp, &edp->abortstate, copycols,
				    (edp->emulcookie, edp->crow, i, 2 * i, 1));
				if (rc != 0)
					return rc;
			}
			for (i = 0; i < edp->ncols / 2; i++) {
				WSEMULOP(rc, edp, &edp->abortstate, erasecols,
				    (edp->emulcookie, edp->crow, 2 * i + 1, 1,
				     edp->bkgdattr));
				if (rc != 0)
					return rc;
			}
			edp->dblwid[edp->crow] = 1;
			edp->dw = 1;
			if (edp->ccol > (edp->ncols >> 1) - 1)
				edp->ccol = (edp->ncols >> 1) - 1;
		}
		break;
	case '8': { /* DECALN */
		int i, j;
		for (i = 0; i < edp->nrows; i++)
			for (j = 0; j < edp->ncols; j++) {
				WSEMULOP(rc, edp, &edp->abortstate, putchar,
				    (edp->emulcookie, i, j, 'E', edp->curattr));
				if (rc != 0)
					return rc;
			}
		}
		edp->ccol = 0;
		edp->crow = 0;
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ESC# %x unknown\n", instate->inchar);
#endif
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	edp->state = VT100_EMUL_STATE_NORMAL;
	return 0;
}

int
wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int newstate = VT100_EMUL_STATE_CSI;
	int oargs;
	int rc = 0;

	switch (instate->inchar) {
	case '0': case '1': case '2': case '3': case '4':
	case '5': case '6': case '7': case '8': case '9':
		/* argument digit */
		if (edp->nargs > VT100_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (instate->inchar - '0');
		break;
	case ';': /* argument terminator */
		edp->nargs++;
		break;
	case '?': /* DEC specific */
	case '>': /* DA query */
		edp->modif1 = (char)instate->inchar;
		break;
	case '!':
	case '"':
	case '$':
	case '&':
		edp->modif2 = (char)instate->inchar;
		break;
	default: /* end of escape sequence */
		oargs = edp->nargs++;
		if (edp->nargs > VT100_EMUL_NARGS) {
#ifdef VT100_DEBUG
			printf("vt100: too many arguments\n");
#endif
			edp->nargs = VT100_EMUL_NARGS;
		}
		rc = wsemul_vt100_handle_csi(edp, instate);
		if (rc != 0) {
			edp->nargs = oargs;
			return rc;
		}
		newstate = VT100_EMUL_STATE_NORMAL;
		break;
	}

	if (COLS_LEFT != 0)
		edp->flags &= ~VTFL_LASTCHAR;

	edp->state = newstate;
	return 0;
}

u_int
wsemul_vt100_output(void *cookie, const u_char *data, u_int count, int kernel)
{
	struct wsemul_vt100_emuldata *edp = cookie;
	struct wsemul_inputstate *instate;
	u_int processed = 0;
#ifdef HAVE_JUMP_SCROLL
	int lines;
#endif
	int rc = 0;

#ifdef DIAGNOSTIC
	if (kernel && !edp->console)
		panic("wsemul_vt100_output: kernel output, not console");
#endif

	instate = kernel ? &edp->kstate : &edp->instate;

	switch (edp->abortstate.state) {
	case ABORT_FAILED_CURSOR:
		/*
		 * If we could not display the cursor back, we pretended not
		 * having been able to display the last character. But this
		 * is a lie, so compensate here.
		 */
		data++, count--;
		processed++;
		wsemul_reset_abortstate(&edp->abortstate);
		break;
	case ABORT_OK:
		/* remove cursor image if visible */
		if (edp->flags & VTFL_CURSORON) {
			rc = (*edp->emulops->cursor)
			    (edp->emulcookie, 0, edp->crow,
			     edp->ccol << edp->dw);
			if (rc != 0)
				return 0;
		}
		break;
	default:
		break;
	}

	for (;;) {
#ifdef HAVE_JUMP_SCROLL
		switch (edp->abortstate.state) {
		case ABORT_FAILED_JUMP_SCROLL:
			/*
			 * If we failed a previous jump scroll attempt, we
			 * need to try to resume it with the same distance.
			 * We can not recompute it since there might be more
			 * bytes in the tty ring, causing a different result.
			 */
			lines = edp->abortstate.lines;
			break;
		case ABORT_OK:
			/*
			 * If we are at the bottom of the scrolling area, count
			 * newlines until an escape sequence appears.
			 */
			if ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&
			    ROWS_BELOW == 0)
				lines = wsemul_vt100_jump_scroll(edp, data,
				    count, kernel);
			else
				lines = 0;
			break;
		default:
			/*
			 * If we are recovering a non-scrolling failure,
			 * do not try to scroll yet.
			 */
			lines = 0;
			break;
		}

		if (lines > 1) {
			wsemul_resume_abort(&edp->abortstate);
			rc = wsemul_vt100_scrollup(edp, lines);
			if (rc != 0) {
				wsemul_abort_jump_scroll(&edp->abortstate,
				    lines);
				return processed;
			}
			wsemul_reset_abortstate(&edp->abortstate);
			edp->crow -= lines;
		}
#endif

		wsemul_resume_abort(&edp->abortstate);

		if (wsemul_getchar(&data, &count, instate,
#ifdef HAVE_UTF8_SUPPORT
		    (edp->state == VT100_EMUL_STATE_NORMAL && !kernel) ?
		      edp->flags & VTFL_UTF8 : 0
#else
		    0
#endif
		    ) != 0)
			break;

		if (!(instate->inchar & ~0xff) &&
		    (instate->inchar & 0x7f) < 0x20) {
			rc = wsemul_vt100_output_c0c1(edp, instate, kernel);
			if (rc != 0)
				break;
			processed++;
 			continue;
 		}
 
		if (edp->state == VT100_EMUL_STATE_NORMAL || kernel) {
			rc = wsemul_vt100_output_normal(edp, instate, kernel);
			if (rc != 0)
				break;
			processed++;
			continue;
		}
#ifdef DIAGNOSTIC
		if (edp->state > nitems(vt100_output))
			panic("wsemul_vt100: invalid state %d", edp->state);
#endif
		rc = vt100_output[edp->state - 1](edp, instate);
		if (rc != 0)
			break;
		processed++;
	}

	if (rc != 0)
		wsemul_abort_other(&edp->abortstate);
	else {
		/* put cursor image back if visible */
		if (edp->flags & VTFL_CURSORON) {
			rc = (*edp->emulops->cursor)
			    (edp->emulcookie, 1, edp->crow,
			     edp->ccol << edp->dw);
			if (rc != 0) {
				/*
				 * Fail the last character output, remembering
				 * that only the cursor operation really needs
				 * to be done.
				 */
				wsemul_abort_cursor(&edp->abortstate);
				processed--;
			}
		}
	}

	if (rc == 0)
		wsemul_reset_abortstate(&edp->abortstate);

	return processed;
}

#ifdef HAVE_JUMP_SCROLL
int
wsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *edp, const u_char *data,
    u_int count, int kernel)
{
	struct wsemul_inputstate tmpstate;
	u_int pos, lines;

	lines = 0;
	pos = edp->ccol;
	tmpstate = kernel ? edp->kstate : edp->instate;	/* structure copy */

	while (wsemul_getchar(&data, &count, &tmpstate,
#ifdef HAVE_UTF8_SUPPORT
	    kernel ? 0 : edp->flags & VTFL_UTF8
#else
	    0
#endif
	    ) == 0) {
		/*
		 * Only char causing a transition from
		 * VT100_EMUL_STATE_NORMAL to another state, for now.
		 * Revisit this if this changes...
		 */
		if (tmpstate.inchar == ASCII_ESC)
			break;

		if (ISSET(edp->flags, VTFL_DECAWM))
			switch (tmpstate.inchar) {
			case ASCII_BS:
				if (pos > 0)
					pos--;
				break;
			case ASCII_CR:
				pos = 0;
				break;
			case ASCII_HT:
				if (edp->tabs) {
					pos++;
					while (pos < NCOLS - 1 &&
					    edp->tabs[pos] == 0)
						pos++;
				} else {
					pos = (pos + 7) & ~7;
					if (pos >= NCOLS)
						pos = NCOLS - 1;
				}
				break;
			default:
				if (!(tmpstate.inchar & ~0xff) &&
				    (tmpstate.inchar & 0x7f) < 0x20)
					break;
				if (pos++ >= NCOLS) {
					pos = 0;
					tmpstate.inchar = ASCII_LF;
				}
				break;
			}

		if (tmpstate.inchar == ASCII_LF ||
		    tmpstate.inchar == ASCII_VT ||
		    tmpstate.inchar == ASCII_FF) {
			if (++lines >= edp->scrreg_nrows - 1)
				break;
		}
	}

	return lines;
}
#endif
@


1.35
log
@Partially revert previous mallocarray conversions that contain
constants.

The consensus is that if both operands are constant, we don't need
mallocarray.  Reminded by tedu@@

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.34 2017/04/09 18:05:17 dhill Exp $ */
a474 19
#if 0
	case CSI: /* 8-bit */
		/* XXX cancel current escape sequence */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->modif1 = edp->modif2 = '\0';
		edp->state = VT100_EMUL_STATE_CSI;
		break;
	case DCS: /* 8-bit */
		/* XXX cancel current escape sequence */
		edp->nargs = 0;
		memset(edp->args, 0, sizeof (edp->args));
		edp->state = VT100_EMUL_STATE_DCS;
		break;
	case ST: /* string end 8-bit */
		/* XXX only in VT100_EMUL_STATE_STRING */
		wsemul_vt100_handle_dcs(edp);
		return (VT100_EMUL_STATE_NORMAL);
#endif
@


1.34
log
@Convert some malloc(9) to mallocarray(9)

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.33 2015/08/28 00:03:53 deraadt Exp $ */
d225 4
a228 4
	edp->isolatin1tab = mallocarray(128, sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->decgraphtab = mallocarray(128, sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->dectechtab = mallocarray(128, sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->nrctab = mallocarray(128, sizeof(u_int), M_DEVBUF, M_NOWAIT);
@


1.33
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.32 2014/07/12 18:48:53 tedu Exp $ */
d225 4
a228 4
	edp->isolatin1tab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->decgraphtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->dectechtab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
	edp->nrctab = malloc(128 * sizeof(u_int), M_DEVBUF, M_NOWAIT);
@


1.32
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.31 2013/10/18 22:06:41 miod Exp $ */
d251 1
a251 1
		free(edp, M_DEVBUF, 0);
@


1.31
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.30 2013/10/18 13:54:09 miod Exp $ */
d241 1
a241 1
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF); ptr = NULL;}
d251 1
a251 1
		free(edp, M_DEVBUF);
@


1.30
log
@Introduce a dedicated private header file to control the optional features
of wscons (which usually get disabled for installation kernels, to save
space), instead of duplicating parts of it to too many places.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.29 2013/06/16 19:04:20 miod Exp $ */
d5 16
d83 4
a86 2
int	wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char, int);
int	wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char, int);
d88 3
a90 1
typedef int vt100_handler(struct wsemul_vt100_emuldata *, u_char);
d103 2
a104 1
	wsemul_vt100_output_dcs_dollar;
d119 1
d134 1
d339 2
a340 2
wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *edp, u_char c,
    int kernel)
d343 1
d356 18
a373 9
	if (c & 0x80) {
		c &= 0x7f;
		ct = edp->chartab_G[edp->chartab1];
	} else {
		if (edp->sschartab) {
			ct = edp->chartab_G[edp->sschartab];
			edp->sschartab = 0;
		} else
			ct = edp->chartab_G[edp->chartab0];
a374 1
	dc = (ct ? ct[c] : c);
d406 2
a407 2
wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *edp, u_char c,
    int kernel)
d412 1
a412 1
	switch (c) {
d448 1
d452 1
d508 2
a509 1
wsemul_vt100_output_esc(struct wsemul_vt100_emuldata *edp, u_char c)
d515 1
a515 1
	switch (c) {
d568 1
d572 1
d576 1
d580 1
d584 1
d588 1
d592 1
d616 1
a616 1
		edp->designating = c - '(';
d620 1
a620 1
		edp->designating = c - '-' + 1;
d637 3
d642 1
a642 1
		printf("ESC%c unknown\n", c);
d658 2
a659 1
wsemul_vt100_output_scs94(struct wsemul_vt100_emuldata *edp, u_char c)
d663 1
a663 1
	switch (c) {
d668 1
d672 1
d677 1
d681 1
d685 1
d690 2
a691 1
		printf("ESC%c%c unknown\n", edp->designating + '(', c);
d701 2
a702 1
wsemul_vt100_output_scs94_percent(struct wsemul_vt100_emuldata *edp, u_char c)
d704 1
a704 1
	switch (c) {
d707 1
d712 2
a713 1
		printf("ESC%c%%%c unknown\n", edp->designating + '(', c);
d723 2
a724 1
wsemul_vt100_output_scs96(struct wsemul_vt100_emuldata *edp, u_char c)
d729 1
a729 1
	switch (c) {
d734 1
d772 2
a773 1
		printf("ESC%c%c unknown\n", edp->designating + '-' - 1, c);
d783 2
a784 1
wsemul_vt100_output_scs96_percent(struct wsemul_vt100_emuldata *edp, u_char c)
d786 1
a786 1
	switch (c) {
d793 2
a794 1
		printf("ESC%c%%%c unknown\n", edp->designating + '-' - 1, c);
d804 2
a805 1
wsemul_vt100_output_esc_spc(struct wsemul_vt100_emuldata *edp, u_char c)
d807 1
a807 1
	switch (c) {
d811 1
a811 1
		printf("ESC<SPC>%c ignored\n", c);
d816 1
a816 1
		printf("ESC<SPC>%c unknown\n", c);
d826 2
a827 1
wsemul_vt100_output_string(struct wsemul_vt100_emuldata *edp, u_char c)
d829 8
a836 2
	if (edp->dcstype && edp->dcspos < DCS_MAXLEN)
		edp->dcsarg[edp->dcspos++] = c;
d843 2
a844 1
wsemul_vt100_output_string_esc(struct wsemul_vt100_emuldata *edp, u_char c)
d846 1
a846 1
	if (c == '\\') { /* ST complete */
d856 2
a857 1
wsemul_vt100_output_dcs(struct wsemul_vt100_emuldata *edp, u_char c)
d861 1
a861 1
	switch (c) {
d868 1
a868 1
		    (c - '0');
d882 1
a882 1
		switch (c) {
d891 1
a891 1
			printf("DCS%c ignored\n", c);
d896 2
a897 1
			printf("DCS%c (%d, %d) unknown\n", c, ARG(0), ARG(1));
d908 2
a909 1
wsemul_vt100_output_dcs_dollar(struct wsemul_vt100_emuldata *edp, u_char c)
d911 1
a911 1
	switch (c) {
d915 1
a915 1
		printf("DCS$%c ignored\n", c);
d940 2
a941 1
		printf("DCS$%c (%d, %d) unknown\n", c, ARG(0), ARG(1));
d951 26
a976 1
wsemul_vt100_output_esc_hash(struct wsemul_vt100_emuldata *edp, u_char c)
d981 1
a981 1
	switch (c) {
d1037 1
a1037 1
		printf("ESC#%c unknown\n", c);
d1050 2
a1051 1
wsemul_vt100_output_csi(struct wsemul_vt100_emuldata *edp, u_char c)
d1057 1
a1057 1
	switch (c) {
d1064 1
a1064 1
		    (c - '0');
d1071 1
a1071 1
		edp->modif1 = c;
d1077 1
a1077 1
		edp->modif2 = c;
d1087 1
a1087 1
		rc = wsemul_vt100_handle_csi(edp, c);
d1107 1
a1108 1
	u_char c;
d1119 2
d1146 1
a1146 1
	for (; count > 0; data++, count--) {
d1194 13
a1206 3
		c = *data;
		if ((c & 0x7f) < 0x20) {
			rc = wsemul_vt100_output_c0c1(edp, c, kernel);
d1210 3
a1212 3
			continue;
		}

d1214 1
a1214 1
			rc = wsemul_vt100_output_normal(edp, c, kernel);
d1224 1
a1224 1
		rc = vt100_output[edp->state - 1](edp, c);
d1261 1
a1261 1
	u_char curchar;
d1266 9
a1274 2
	for (; count != 0; data++, count--) {
		curchar = *data;
d1280 1
a1280 1
		if (curchar == ASCII_ESC)
d1284 1
a1284 1
			switch (curchar) {
d1305 2
a1306 1
				if ((curchar & 0x7f) < 0x20)
d1310 1
a1310 1
					curchar = ASCII_LF;
d1315 3
a1317 3
		if (curchar == ASCII_LF ||
		    curchar == ASCII_VT ||
		    curchar == ASCII_FF) {
@


1.29
log
@Use (N * sizeof(u_int)) instead of (N * sizeof(int)) when malloc'ing u_int *.
Doesn't change anything, but silences a Clang warning; dhill@@bitrig
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.28 2011/08/04 04:18:42 miod Exp $ */
a29 4
#ifndef	SMALL_KERNEL
#define	JUMP_SCROLL
#endif

d36 1
d1010 1
a1010 1
#ifdef JUMP_SCROLL
d1046 1
a1046 1
#ifdef JUMP_SCROLL
d1145 1
a1145 1
#ifdef JUMP_SCROLL
@


1.28
log
@In `string' state, accept bell (^G) as an end of sequence in addition to
`ESC \', as supported by xterm; some third-party software such as
ncmpcpp rely upon this.
Noticed by dcoppa@@, based on a draft diff by nicm@@; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.27 2010/09/01 21:17:16 nicm Exp $ */
d205 4
a208 4
	edp->isolatin1tab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->decgraphtab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->dectechtab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
	edp->nrctab = malloc(128 * sizeof(int), M_DEVBUF, M_NOWAIT);
@


1.27
log
@After all escape sequence processing, check for being beyond the last
column and and clear VTFL_LASTCHAR if so.

This fixes the case where an escape sequence (originally noticed with
DECSTBM) moves the cursor and doesn't reset the flag - if it was set,
there would be a spurious line feed on the next input.

ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.26 2009/09/05 14:49:20 miod Exp $ */
d389 7
a395 1
		wsdisplay_emulbell(edp->cbcookie);
@


1.26
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.25 2009/09/05 14:30:24 miod Exp $ */
a398 1
		edp->flags &= ~VTFL_LASTCHAR;
d464 3
d599 3
d941 3
d993 3
@


1.25
log
@Make the output() wsemul_op return the number of characters processed and
check it in wsdisplaystart() to suspend output if not all characters have
been output; they will get reissued at the next tty rstrt_to timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.24 2009/09/05 13:43:58 miod Exp $ */
d70 4
a73 4
void	wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char, int);
void	wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char, int);
void	wsemul_vt100_nextline(struct wsemul_vt100_emuldata *);
typedef void vt100_handler(struct wsemul_vt100_emuldata *, u_char);
d130 1
d247 1
a247 1
		wsemul_vt100_ed(edp, 2);
d253 2
a254 2
		(*edp->emulops->cursor)(edp->emulcookie, 0,
		    edp->crow, edp->ccol);
d295 1
a295 1
void
d298 2
d302 1
a302 1
	  	wsemul_vt100_scrollup(edp, 1);
d308 1
d310 2
d318 1
a318 1
void
d323 2
d328 3
a330 1
		wsemul_vt100_nextline(edp);
d347 10
a356 2
	if ((edp->flags & VTFL_INSERTMODE) && COLS_LEFT)
		COPYCOLS(edp->ccol, edp->ccol + 1, COLS_LEFT);
d358 9
a366 2
	(*edp->emulops->putchar)(edp->emulcookie, edp->crow,
	    edp->ccol << edp->dw, dc, kernel ? edp->kernattr : edp->curattr);
d372 2
d376 1
a376 1
void
d381 1
d461 1
a461 1
		wsemul_vt100_nextline(edp);
d464 2
d468 1
a468 1
void
d472 1
d521 1
a521 1
		wsemul_vt100_nextline(edp);
d554 1
a554 1
		wsemul_vt100_scrolldown(edp, 1);
d563 3
a565 1
		wsemul_vt100_ed(edp, 2);
d597 3
d601 1
d604 1
a604 1
void
d637 1
d640 1
a640 1
void
d656 1
d659 1
a659 1
void
d713 1
d716 1
a716 1
void
d732 1
d735 1
a735 1
void
d753 1
d756 1
a756 1
void
d763 1
d766 1
a766 1
void
d774 2
d778 1
a778 1
void
d825 1
d828 1
a828 1
void
d866 1
d869 1
a869 1
void
d873 1
d878 11
a888 5
			for (i = 0; i < edp->ncols / 2; i++)
				(*edp->emulops->copycols)(edp->emulcookie,
				    edp->crow, 2 * i, i, 1);
			(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
			    i, edp->ncols - i, edp->bkgdattr);
d897 13
a909 6
			for (i = edp->ncols / 2 - 1; i >= 0; i--)
				(*edp->emulops->copycols)(edp->emulcookie,
				    edp->crow, i, 2 * i, 1);
			for (i = 0; i < edp->ncols / 2; i++)
				(*edp->emulops->erasecols)(edp->emulcookie,
				    edp->crow, 2 * i + 1, 1, edp->bkgdattr);
d919 6
a924 3
			for (j = 0; j < edp->ncols; j++)
				(*edp->emulops->putchar)(edp->emulcookie, i, j,
				    'E', edp->curattr);
d937 1
d940 1
a940 1
void
d944 2
d970 1
a970 1
		edp->nargs++;
d977 5
a981 1
		wsemul_vt100_handle_csi(edp, c);
d987 1
d999 1
d1006 24
a1029 3
	if (edp->flags & VTFL_CURSORON)
		(*edp->emulops->cursor)(edp->emulcookie, 0,
		    edp->crow, edp->ccol << edp->dw);
d1033 27
a1059 9
		/*
		 * If we are at the bottom of the scrolling area, count
		 * newlines until an escape sequence appears.
		 */
		if ((edp->state == VT100_EMUL_STATE_NORMAL || kernel) &&
		    ROWS_BELOW == 0)
			lines = wsemul_vt100_jump_scroll(edp, data,
			    count, kernel);
		else
d1061 2
d1065 8
a1072 1
			wsemul_vt100_scrollup(edp, lines);
d1077 2
d1081 3
a1083 1
			wsemul_vt100_output_c0c1(edp, c, kernel);
d1089 3
a1091 1
			wsemul_vt100_output_normal(edp, c, kernel);
d1099 3
a1101 1
		vt100_output[edp->state - 1](edp, c);
d1105 22
a1126 3
	if (edp->flags & VTFL_CURSORON)
		(*edp->emulops->cursor)(edp->emulcookie, 1,
		    edp->crow, edp->ccol << edp->dw);
@


1.24
log
@Rework internal interfaces in the wsdisplay emulation code to prepare for
upcoming changes. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.23 2009/01/12 20:43:53 miod Exp $ */
d50 1
a50 1
void	wsemul_vt100_output(void *, const u_char *, u_int, int);
d918 1
a918 1
void
d922 1
d959 1
d965 1
d973 1
d979 2
@


1.23
log
@Recognize CAN and SUB control characters, and cancel any current escape
sequence when they appear. Per VT100 manual via naddy@@, ok naddy@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.22 2007/11/27 16:37:27 miod Exp $ */
d48 1
a48 1
void	*wsemul_vt100_attach(int console, const struct wsscreen_descr *,
d50 2
a51 3
void	wsemul_vt100_output(void *cookie, const u_char *data, u_int count,
				 int);
void	wsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp);
d68 1
a68 1
void	wsemul_vt100_jump_scroll(struct wsemul_vt100_emuldata *,
d73 1
a73 1
typedef u_int vt100_handler(struct wsemul_vt100_emuldata *, u_char);
d438 1
a438 1
u_int
d564 1
a564 1
	return (newstate);
d567 1
a567 1
u_int
d598 2
a599 1
	return (newstate);
d602 1
a602 1
u_int
d616 2
a617 1
	return (VT100_EMUL_STATE_NORMAL);
d620 1
a620 1
u_int
d672 2
a673 1
	return (newstate);
d676 1
a676 1
u_int
d690 2
a691 1
	return (VT100_EMUL_STATE_NORMAL);
d694 1
a694 1
u_int
d710 2
a711 1
	return (VT100_EMUL_STATE_NORMAL);
d714 1
a714 1
u_int
d719 2
a720 1
	return (VT100_EMUL_STATE_STRING);
d723 1
a723 1
u_int
d728 1
a728 1
		return (VT100_EMUL_STATE_NORMAL);
d730 1
a730 1
		return (VT100_EMUL_STATE_STRING);
d733 1
a733 1
u_int
d763 1
a763 1
		case '{': /* DECDLD soft charset */
d779 1
a779 1
	return (newstate);
d782 1
a782 1
u_int
d818 2
a819 1
	return (VT100_EMUL_STATE_STRING);
d822 1
a822 1
u_int
d871 2
a872 1
	return (VT100_EMUL_STATE_NORMAL);
d875 1
a875 1
u_int
d914 2
a915 1
	return (newstate);
d922 4
d944 9
a952 1
			wsemul_vt100_jump_scroll(edp, data, count, kernel);
d955 3
a957 2
		if ((*data & 0x7f) < 0x20) {
			wsemul_vt100_output_c0c1(edp, *data, kernel);
d962 1
a962 1
			wsemul_vt100_output_normal(edp, *data, kernel);
d969 1
a969 1
		edp->state = vt100_output[edp->state - 1](edp, *data);
d978 1
a978 1
void
d1036 1
a1036 4
	if (lines > 1) {
		wsemul_vt100_scrollup(edp, lines);
		edp->crow -= lines;
	}
@


1.22
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.21 2007/11/25 19:11:43 miod Exp $ */
d407 5
d945 1
a945 1
		if (edp->state > sizeof(vt100_output) / sizeof(vt100_output[0]))
d969 3
a971 4
		 * Only char for which
		 * wsemul_vt100_output_c0c1() will switch
		 * to escape mode, for now.
		 * Revisit this when this changes...
@


1.21
log
@Ask the emulation code to hide the cursor when leaving emulation mode. This
way we do not get a phantom cursor image when X exits.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.20 2007/09/11 13:39:34 gilles Exp $ */
d67 7
a73 9
void wsemul_vt100_init(struct wsemul_vt100_emuldata *,
			    const struct wsscreen_descr *, void *, int, int,
			    long);

void wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char,
				     int);
void wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char,
				   int);
void wsemul_vt100_nextline(struct wsemul_vt100_emuldata *);
d76 12
a87 12
wsemul_vt100_output_esc,
wsemul_vt100_output_csi,
wsemul_vt100_output_scs94,
wsemul_vt100_output_scs94_percent,
wsemul_vt100_output_scs96,
wsemul_vt100_output_scs96_percent,
wsemul_vt100_output_esc_hash,
wsemul_vt100_output_esc_spc,
wsemul_vt100_output_string,
wsemul_vt100_output_string_esc,
wsemul_vt100_output_dcs,
wsemul_vt100_output_dcs_dollar;
d119 3
a121 6
wsemul_vt100_init(edp, type, cookie, ccol, crow, defattr)
	struct wsemul_vt100_emuldata *edp;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d134 2
a135 5
wsemul_vt100_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d161 2
a162 3
					    WS_KERNEL_FG, WS_KERNEL_BG,
					    WS_KERNEL_COLATTR | WSATTR_WSCOLORS,
					    &edp->kernattr);
d165 1
a165 2
					    WS_KERNEL_MONOATTR,
					    &edp->kernattr);
d180 2
a181 7
wsemul_vt100_attach(console, type, cookie, ccol, crow, cbcookie, defattr)
	int console;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	void *cbcookie;
	long defattr;
d215 1
a215 3
wsemul_vt100_detach(cookie, crowp, ccolp)
	void *cookie;
	u_int *crowp, *ccolp;
d235 1
a235 3
wsemul_vt100_resetop(cookie, op)
	void *cookie;
	enum wsemul_resetops op;
d250 1
a250 1
					edp->flags & VTFL_CURSORON, 0, 0);
d262 1
a262 2
wsemul_vt100_reset(edp)
	struct wsemul_vt100_emuldata *edp;
d307 1
a307 1
}	
d314 2
a315 4
wsemul_vt100_output_normal(edp, c, kernel)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
	int kernel;
d342 1
a342 2
				 edp->ccol << edp->dw, dc,
				 kernel ? edp->kernattr : edp->curattr);
d351 2
a352 4
wsemul_vt100_output_c0c1(edp, c, kernel)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
	int kernel;
d435 1
a435 3
wsemul_vt100_output_esc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d553 1
a553 1
	    default:
d564 1
a564 3
wsemul_vt100_output_scs94(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d588 1
a588 1
	    default:
d598 1
a598 3
wsemul_vt100_output_scs94_percent(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d605 1
a605 1
	    default:
d615 1
a615 3
wsemul_vt100_output_scs96(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d621 1
a621 1
	case '%': /* probably portugese */
d660 1
a660 1
	    default:
d670 1
a670 3
wsemul_vt100_output_scs96_percent(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d673 1
a673 1
	case '6': /* portugese */
d677 1
a677 1
	    default:
d687 1
a687 3
wsemul_vt100_output_esc_spc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d696 1
a696 1
	    default:
d706 1
a706 3
wsemul_vt100_output_string(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d714 1
a714 3
wsemul_vt100_output_string_esc(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d724 1
a724 3
wsemul_vt100_output_dcs(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d740 1
a740 1
	    default:
d761 1
a761 1
		    default:
d773 1
a773 3
wsemul_vt100_output_dcs_dollar(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d795 1
a795 1
		    default:
d802 1
a802 1
	    default:
d812 1
a812 3
wsemul_vt100_output_esc_hash(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d821 1
a821 2
							  edp->crow,
							  2 * i, i, 1);
d823 1
a823 2
						   i, edp->ncols - i,
						   edp->bkgdattr);
d834 1
a834 2
							  edp->crow,
							  i, 2 * i, 1);
d837 1
a837 3
							   edp->crow,
							   2 * i + 1, 1,
							   edp->bkgdattr);
d849 1
a849 1
							 'E', edp->curattr);
d854 1
a854 1
	    default:
d864 1
a864 3
wsemul_vt100_output_csi(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d890 1
a890 1
	    default: /* end of escape sequence */
d906 1
a906 5
wsemul_vt100_output(cookie, data, count, kernel)
	void *cookie;
	const u_char *data;
	u_int count;
	int kernel;
a908 5
#ifdef JUMP_SCROLL
	const u_char *eot;
	u_char curchar;
	u_int cnt, pos, lines;
#endif
d917 1
a917 1
				edp->crow, edp->ccol << edp->dw);
d926 2
a927 58
		    ROWS_BELOW == 0) {
			lines = 0;
			pos = edp->ccol;
			for (eot = data, cnt = count; cnt != 0; eot++, cnt--) {
				curchar = *eot;
				/*
				 * Only char for which
				 * wsemul_vt100_output_c0c1() will switch
				 * to escape mode, for now.
				 * Revisit this when this changes...
				 */
				if (curchar == ASCII_ESC)
					break;

				if (ISSET(edp->flags, VTFL_DECAWM))
				    switch (curchar) {
				    case ASCII_BS:
					if (pos > 0)
						pos--;
					break;
				    case ASCII_CR:
					pos = 0;
					break;
				    case ASCII_HT:
					if (edp->tabs) {
						pos++;
						while (pos < NCOLS - 1 &&
						    edp->tabs[pos] == 0)
							pos++;
					} else {
						pos = (pos + 7) & ~7;
						if (pos >= NCOLS)
							pos = NCOLS - 1;
					}
					break;
				    default:
					if ((curchar & 0x7f) < 0x20)
						break;
					if (pos++ >= NCOLS) {
						pos = 0;
						curchar = ASCII_LF;
					}
					break;
				    }

				if (curchar == ASCII_LF ||
				    curchar == ASCII_VT ||
				    curchar == ASCII_FF) {
					if (++lines >= edp->scrreg_nrows - 1)
						break;
				}
			}

			if (lines > 1) {
				wsemul_vt100_scrollup(edp, lines);
				edp->crow -= lines;
			}
		}
d948 1
a948 1
				edp->crow, edp->ccol << edp->dw);
d950 67
@


1.20
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.19 2007/09/10 19:49:31 gilles Exp $ */
d270 4
@


1.19
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.18 2007/02/14 01:12:16 jsg Exp $ */
d217 1
a217 1
	edp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT|M_ZERO);
@


1.18
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.17 2007/01/07 13:31:36 miod Exp $ */
d217 1
a217 3
	edp->dblwid = malloc(edp->nrows, M_DEVBUF, M_NOWAIT);
	if (edp->dblwid != NULL)
		memset(edp->dblwid, 0, edp->nrows);
@


1.17
log
@Some dynamically allocated elements are not considered of vital importance
for the vt100 emulation to work well enough for most cases (i.e. alternate
character set tables, non-default tab settings, etc).

However, code did not always check if these elements had been successfully
allocated before trying to use them, or worse, would explicitely panic in
DIAGNOSTIC kernels.

Change this to work in a degraded mode (by ignoring related escape sequences)
instead.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.16 2007/01/07 13:28:50 miod Exp $ */
d509 1
a509 1
		/* FALLTHRU */
@


1.16
log
@Change allocations to M_NOWAIT in attach methods, and return NULL if they fail.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.15 2006/10/19 17:35:09 dim Exp $ */
d179 2
a180 2
	edp->tabs = 0;
	edp->dblwid = 0;
d183 2
a184 2
	edp->isolatin1tab = edp->decgraphtab = edp->dectechtab = 0;
	edp->nrctab = 0;
d218 2
a219 1
	memset(edp->dblwid, 0, edp->nrows);
d240 1
a240 1
#define f(ptr) if (ptr) {free(ptr, M_DEVBUF); ptr = 0;}
d299 1
a299 1
	edp->chartab_G[0] = 0;
d380 2
a381 2
	    case ASCII_NUL:
	    default:
d384 1
a384 1
	    case ASCII_BEL:
d387 1
a387 1
	    case ASCII_BS:
d393 1
a393 1
	    case ASCII_CR:
d397 1
a397 1
	    case ASCII_HT:
d409 1
a409 1
	    case ASCII_SO: /* LS1 */
d412 1
a412 1
	    case ASCII_SI: /* LS0 */
d415 1
a415 1
	    case ASCII_ESC:
d431 1
a431 1
	    case CSI: /* 8-bit */
d438 1
a438 1
	    case DCS: /* 8-bit */
d444 1
a444 1
	    case ST: /* string end 8-bit */
d449 3
a451 3
	    case ASCII_LF:
	    case ASCII_VT:
	    case ASCII_FF:
d466 1
a466 1
	    case '[': /* CSI */
d472 1
a472 1
	    case '7': /* DECSC */
d486 1
a486 1
	    case '8': /* DECRC */
d501 1
a501 1
	    case '=': /* DECKPAM application mode */
d504 1
a504 1
	    case '>': /* DECKPNM numeric mode */
d507 1
a507 1
	    case 'E': /* NEL */
d510 1
a510 1
	    case 'D': /* IND */
d513 3
a515 3
	    case 'H': /* HTS */
		KASSERT(edp->tabs != 0);
		edp->tabs[edp->ccol] = 1;
d517 1
a517 1
	    case '~': /* LS1R */
d520 1
a520 1
	    case 'n': /* LS2 */
d523 1
a523 1
	    case '}': /* LS2R */
d526 1
a526 1
	    case 'o': /* LS3 */
d529 1
a529 1
	    case '|': /* LS3R */
d532 1
a532 1
	    case 'N': /* SS2 */
d535 1
a535 1
	    case 'O': /* SS3 */
d538 1
a538 1
	    case 'M': /* RI */
d546 1
a546 1
	    case 'P': /* DCS */
d551 1
a551 1
	    case 'c': /* RIS */
d556 1
a556 1
	    case '(': case ')': case '*': case '+': /* SCS */
d560 1
a560 1
	    case '-': case '.': case '/': /* SCS */
d564 1
a564 1
	    case '#':
d567 1
a567 1
	    case ' ': /* 7/8 bit */
d570 3
a572 3
	    case ']': /* OSC operating system command */
	    case '^': /* PM privacy message */
	    case '_': /* APC application program command */
d576 1
a576 1
	    case '<': /* exit VT52 mode - ignored */
d596 1
a596 1
	    case '%': /* probably DEC supplemental graphic */
d599 1
a599 1
	    case 'A': /* british / national */
d602 1
a602 1
	    case 'B': /* ASCII */
d605 1
a605 1
	    case '<': /* user preferred supplemental */
d609 1
a609 1
	    case '0': /* DEC special graphic */
d612 1
a612 1
	    case '>': /* DEC tech */
d630 1
a630 1
	    case '5': /* DEC supplemental graphic */
d652 1
a652 1
	    case '%': /* probably portugese */
d655 1
a655 1
	    case 'A': /* ISO-latin-1 supplemental */
d658 1
a658 1
	    case '4': /* dutch */
d661 1
a661 1
	    case '5': case 'C': /* finnish */
d664 1
a664 1
	    case 'R': /* french */
d667 1
a667 1
	    case 'Q': /* french canadian */
d670 1
a670 1
	    case 'K': /* german */
d673 1
a673 1
	    case 'Y': /* italian */
d676 1
a676 1
	    case 'E': case '6': /* norwegian / danish */
d679 1
a679 1
	    case 'Z': /* spanish */
d682 1
a682 1
	    case '7': case 'H': /* swedish */
d685 1
a685 1
	    case '=': /* swiss */
d688 3
a690 2
		vt100_setnrc(edp, nrc); /* what table ??? */
		break;
d706 4
a709 3
	    case '6': /* portugese */
		vt100_setnrc(edp, 8);
		break;
d712 1
a712 1
		printf("ESC%c%%%c unknown\n", edp->designating + '-', c);
d725 2
a726 2
	    case 'F': /* 7-bit controls */
	    case 'G': /* 8-bit controls */
d770 2
a771 2
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
d778 1
a778 1
	    case ';': /* argument terminator */
d791 1
a791 1
		    case '$':
d794 2
a795 2
		    case '{': /* DECDLD soft charset */
		    case '!': /* DECRQUPSS user preferred supplemental set */
d797 1
a797 1
		    case '|': /* DECUDK program F6..F20 */
d819 2
a820 2
	    case 'p': /* DECRSTS terminal state restore */
	    case 'q': /* DECRQSS control function request */
d825 1
a825 1
	    case 't': /* DECRSPS restore presentation state */
d827 1
a827 1
		    case 0: /* error */
d829 1
a829 1
		    case 1: /* cursor information restore */
d834 1
a834 1
		    case 2: /* tab stop restore */
d862 2
a863 2
	    case '5': /*  DECSWL single width, single height */
		if (edp->dw) {
d875 4
a878 4
	    case '6': /*  DECDWL double width, single height */
	    case '3': /*  DECDHL double width, double height, top half */
	    case '4': /*  DECDHL double width, double height, bottom half */
		if (!edp->dw) {
d894 1
a894 1
	    case '8': { /* DECALN */
d921 2
a922 2
	    case '0': case '1': case '2': case '3': case '4':
	    case '5': case '6': case '7': case '8': case '9':
d929 1
a929 1
	    case ';': /* argument terminator */
d932 2
a933 2
	    case '?': /* DEC specific */
	    case '>': /* DA query */
d936 4
a939 4
	    case '!':
	    case '"':
	    case '$':
	    case '&':
@


1.15
log
@Fix hopefully the last wscons jump scrolling glitch, which can occur
in case autowrapping is on, and control characters other than BS, CR,
HT are encountered.

Righto! miod@@, also verified by Paul Stoeber.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.14 2006/10/09 05:21:50 miod Exp $ */
d206 3
a208 1
		edp = malloc(sizeof *edp, M_DEVBUF, M_WAITOK);
@


1.14
log
@Fix jump scroll glitch, reported by dim@@ and Paul Stoeber.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.13 2006/08/17 06:27:04 miod Exp $ */
d1018 2
@


1.13
log
@Jump scroll support for vt100 and sun wscons emulations, helps macppc and
zaurus a lot, tested by many; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.12 2004/12/25 20:40:33 deraadt Exp $ */
d1018 1
a1018 1
					if (++pos >= NCOLS) {
@


1.12
log
@correct indent
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.11 2004/12/23 21:47:46 miod Exp $ */
d30 4
d960 5
d974 1
d976 64
d1044 1
d1055 1
@


1.11
log
@vt100 wscons crashes restoring cursor if it had never been saved before.

From NetBSD (wsemul_vt100.c 1.24, wsemul_vt100var.h 1.7)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.10 2004/12/23 21:45:51 miod Exp $ */
d963 1
a963 1
	(*edp->emulops->cursor)(edp->emulcookie, 0,
@


1.10
log
@Reliability fix, from NetBSD:
When moving the cursor down, only scroll up if cursor is exactly at
bottom of scroll region; don't scroll if below scroll region.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.9 2004/04/02 04:39:51 deraadt Exp $ */
d466 1
d480 2
@


1.9
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.8 2002/10/12 01:09:44 krw Exp $ */
d71 1
d73 1
a73 1
static vt100_handler
d302 19
d334 1
a334 5
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
		} else
			wsemul_vt100_scrollup(edp, 1);
d445 1
a445 5
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
		} else
			wsemul_vt100_scrollup(edp, 1);
d501 1
a501 6
		if (ROWS_BELOW > 0) {
			edp->crow++;
			CHECK_DW;
			break;
		}
		wsemul_vt100_scrollup(edp, 1);
@


1.8
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.7 2002/03/14 01:27:03 millert Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.6 2001/04/14 04:48:01 aaron Exp $ */
d972 1
a972 1
			panic("wsemul_vt100: invalid state %d\n", edp->state);
@


1.6
log
@Remove some static.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.5 2001/03/07 17:51:29 aaron Exp $ */
d48 8
a55 8
void	*wsemul_vt100_cnattach __P((const struct wsscreen_descr *, void *,
				  int, int, long));
void	*wsemul_vt100_attach __P((int console, const struct wsscreen_descr *,
				  void *, int, int, void *, long));
void	wsemul_vt100_output __P((void *cookie, const u_char *data, u_int count,
				 int));
void	wsemul_vt100_detach __P((void *cookie, u_int *crowp, u_int *ccolp));
void	wsemul_vt100_resetop __P((void *, enum wsemul_resetops));
d69 1
a69 1
void wsemul_vt100_init __P((struct wsemul_vt100_emuldata *,
d71 1
a71 1
			    long));
d73 5
a77 5
void wsemul_vt100_output_normal __P((struct wsemul_vt100_emuldata *, u_char,
				     int));
void wsemul_vt100_output_c0c1 __P((struct wsemul_vt100_emuldata *, u_char,
				   int));
typedef u_int vt100_handler __P((struct wsemul_vt100_emuldata *, u_char));
@


1.6.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.6 2001/04/14 04:48:01 aaron Exp $ */
d48 8
a55 8
void	*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_vt100_attach(int console, const struct wsscreen_descr *,
				  void *, int, int, void *, long);
void	wsemul_vt100_output(void *cookie, const u_char *data, u_int count,
				 int);
void	wsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_vt100_resetop(void *, enum wsemul_resetops);
d69 1
a69 1
void wsemul_vt100_init(struct wsemul_vt100_emuldata *,
d71 1
a71 1
			    long);
d73 5
a77 5
void wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char,
				     int);
void wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char,
				   int);
typedef u_int vt100_handler(struct wsemul_vt100_emuldata *, u_char);
@


1.6.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.6.8.1 2002/06/11 03:42:32 art Exp $ */
d972 1
a972 1
			panic("wsemul_vt100: invalid state %d", edp->state);
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.6 2001/04/14 04:48:01 aaron Exp $ */
@


1.6.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d48 8
a55 8
void	*wsemul_vt100_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_vt100_attach(int console, const struct wsscreen_descr *,
				  void *, int, int, void *, long);
void	wsemul_vt100_output(void *cookie, const u_char *data, u_int count,
				 int);
void	wsemul_vt100_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_vt100_resetop(void *, enum wsemul_resetops);
d69 1
a69 1
void wsemul_vt100_init(struct wsemul_vt100_emuldata *,
d71 1
a71 1
			    long);
d73 5
a77 5
void wsemul_vt100_output_normal(struct wsemul_vt100_emuldata *, u_char,
				     int);
void wsemul_vt100_output_c0c1(struct wsemul_vt100_emuldata *, u_char,
				   int);
typedef u_int vt100_handler(struct wsemul_vt100_emuldata *, u_char);
@


1.6.4.3
log
@Sync the SMP branch with 3.3
@
text
@d972 1
a972 1
			panic("wsemul_vt100: invalid state %d", edp->state);
@


1.6.4.4
log
@Merge with the trunk
@
text
@d16 6
@


1.5
log
@Instead of panic'ing when an ESC is found in kernel output, print a warning
and ignore it; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.4 2001/02/20 05:40:23 deraadt Exp $ */
d69 8
a76 8
static void wsemul_vt100_init __P((struct wsemul_vt100_emuldata *,
				   const struct wsscreen_descr *,
				   void *, int, int, long));

static void wsemul_vt100_output_normal __P((struct wsemul_vt100_emuldata *,
					    u_char, int));
static void wsemul_vt100_output_c0c1 __P((struct wsemul_vt100_emuldata *,
					  u_char, int));
d121 1
a121 1
static void
d310 1
a310 1
static void
d354 1
a354 1
static void
d444 1
a444 1
static u_int
d577 1
a577 1
static u_int
d613 1
a613 1
static u_int
d632 1
a632 1
static u_int
d688 1
a688 1
static u_int
d706 1
a706 1
static u_int
d727 1
a727 1
static u_int
d737 1
a737 1
static u_int
d749 1
a749 1
static u_int
d800 1
a800 1
static u_int
d841 1
a841 1
static u_int
d900 1
a900 1
static u_int
@


1.4
log
@default to kernel messages blue
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.3 2001/02/10 19:42:06 mickey Exp $ */
d399 6
a404 4
#ifdef DIAGNOSTIC
		if (kernel)
			panic("ESC in kernel output");
#endif
@


1.3
log
@sync w/ netbsd; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
a146 2
#if defined(WS_KERNEL_FG) || defined(WS_KERNEL_BG) || \
  defined(WS_KERNEL_COLATTR) || defined(WS_KERNEL_MONOATTR)
a147 1
#endif
a155 2
#if defined(WS_KERNEL_FG) || defined(WS_KERNEL_BG) || \
  defined(WS_KERNEL_COLATTR) || defined(WS_KERNEL_MONOATTR)
d178 1
a178 2
#endif
	edp->kernattr = defattr;
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d165 1
a165 1
#define WS_KERNEL_BG WSCOL_BLACK
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wsemul_vt100.c,v 1.12 1999/11/03 15:55:29 mycroft Exp $ */
d223 1
a223 1
	bzero(edp->dblwid, edp->nrows);
d297 1
a297 1
		bzero(edp->tabs, edp->ncols);
d421 1
a421 1
		bzero(edp->args, sizeof (edp->args));
d428 1
a428 1
		bzero(edp->args, sizeof (edp->args));
d459 1
a459 1
		bzero(edp->args, sizeof (edp->args));
d541 1
a541 1
		bzero(edp->args, sizeof (edp->args));
@

