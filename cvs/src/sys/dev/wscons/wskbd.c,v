head	1.87;
access;
symbols
	OPENBSD_6_1:1.85.0.4
	OPENBSD_6_1_BASE:1.85
	OPENBSD_6_0:1.83.0.4
	OPENBSD_6_0_BASE:1.83
	OPENBSD_5_9:1.83.0.2
	OPENBSD_5_9_BASE:1.83
	OPENBSD_5_8:1.81.0.6
	OPENBSD_5_8_BASE:1.81
	OPENBSD_5_7:1.81.0.4
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.80.0.4
	OPENBSD_5_6_BASE:1.80
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.72.0.4
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.72.0.2
	OPENBSD_5_3_BASE:1.72
	OPENBSD_5_2:1.70.0.4
	OPENBSD_5_2_BASE:1.70
	OPENBSD_5_1_BASE:1.70
	OPENBSD_5_1:1.70.0.2
	OPENBSD_5_0:1.69.0.2
	OPENBSD_5_0_BASE:1.69
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.62.0.2
	OPENBSD_4_8_BASE:1.62
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.60.0.6
	OPENBSD_4_6_BASE:1.60
	OPENBSD_4_5:1.60.0.2
	OPENBSD_4_5_BASE:1.60
	OPENBSD_4_4:1.58.0.4
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.56.0.2
	OPENBSD_4_2_BASE:1.56
	OPENBSD_4_1:1.53.0.4
	OPENBSD_4_1_BASE:1.53
	OPENBSD_4_0:1.53.0.2
	OPENBSD_4_0_BASE:1.53
	OPENBSD_3_9:1.46.0.4
	OPENBSD_3_9_BASE:1.46
	OPENBSD_3_8:1.46.0.2
	OPENBSD_3_8_BASE:1.46
	OPENBSD_3_7:1.41.0.4
	OPENBSD_3_7_BASE:1.41
	OPENBSD_3_6:1.41.0.2
	OPENBSD_3_6_BASE:1.41
	SMP_SYNC_A:1.40
	SMP_SYNC_B:1.40
	OPENBSD_3_5:1.39.0.2
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.36.0.2
	OPENBSD_3_4_BASE:1.36
	UBC_SYNC_A:1.34
	OPENBSD_3_3:1.34.0.2
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.33.0.2
	OPENBSD_3_2_BASE:1.33
	OPENBSD_3_1:1.31.0.2
	OPENBSD_3_1_BASE:1.31
	UBC_SYNC_B:1.33
	UBC:1.28.0.2
	UBC_BASE:1.28
	OPENBSD_3_0:1.26.0.2
	OPENBSD_3_0_BASE:1.26
	SMP:1.16.0.2
	OPENBSD_2_9_BASE:1.15
	OPENBSD_2_9:1.15.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.87
date	2017.05.12.09.16.55;	author mpi;	state Exp;
branches;
next	1.86;
commitid	X2MJ0BBsPUZMUK2x;

1.86
date	2017.04.30.16.45.46;	author mpi;	state Exp;
branches;
next	1.85;
commitid	2Gtqjzrin9LL2yHk;

1.85
date	2017.03.11.11.55.03;	author mpi;	state Exp;
branches;
next	1.84;
commitid	eXDj5wwfsbdFBB4L;

1.84
date	2016.09.30.12.05.46;	author kettenis;	state Exp;
branches;
next	1.83;
commitid	VUBzbivipKIEJKC3;

1.83
date	2015.12.12.12.30.18;	author jung;	state Exp;
branches;
next	1.82;
commitid	rTJn56JVqCI35b4N;

1.82
date	2015.09.10.18.14.52;	author mpi;	state Exp;
branches;
next	1.81;
commitid	yCNTJc2qmad1KZnd;

1.81
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.80;
commitid	20ZyHa9gTJxHxhwD;

1.80
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.79;
commitid	OBNa5kfxQ2UXoiIw;

1.79
date	2014.07.11.08.18.31;	author guenther;	state Exp;
branches;
next	1.78;
commitid	zJyOCNTjgsYVGLiw;

1.78
date	2014.05.15.09.29.38;	author mpi;	state Exp;
branches;
next	1.77;

1.77
date	2014.05.05.21.25.00;	author mpi;	state Exp;
branches;
next	1.76;

1.76
date	2014.01.26.17.48.08;	author miod;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.04.11.57.26;	author mpi;	state Exp;
branches;
next	1.74;

1.74
date	2013.10.18.22.06.42;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2013.10.18.13.54.09;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2013.01.06.18.07.07;	author ratchov;	state Exp;
branches;
next	1.71;

1.71
date	2012.10.17.00.48.23;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2011.11.09.14.27.52;	author shadchin;	state Exp;
branches;
next	1.69;

1.69
date	2011.06.24.19.47.49;	author naddy;	state Exp;
branches;
next	1.68;

1.68
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2011.06.06.06.13.46;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2011.04.14.19.25.54;	author shadchin;	state Exp;
branches;
next	1.65;

1.65
date	2011.04.13.18.16.33;	author shadchin;	state Exp;
branches;
next	1.64;

1.64
date	2010.11.20.20.52.11;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2010.11.20.20.47.38;	author miod;	state Exp;
branches;
next	1.62;

1.62
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.61;

1.61
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.60;

1.60
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.59;

1.59
date	2008.12.21.20.16.35;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2007.09.10.19.49.31;	author gilles;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.02.07.19.28;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.31.22.23.13;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.25.18.04.14;	author tedu;	state Exp;
branches;
next	1.53;

1.53
date	2006.08.14.17.41.08;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.08.14.15.56.02;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2006.08.06.11.36.35;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.05.16.59.57;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.08.01.23.36.52;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2006.07.31.21.54.46;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.29.20.23.13;	author miod;	state Exp;
branches;
next	1.46;

1.46
date	2005.08.14.11.00.15;	author miod;	state Exp;
branches;
next	1.45;

1.45
date	2005.07.08.02.26.07;	author marc;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.02.07.31.17;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.18.21.31.27;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2005.05.15.11.29.15;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.40;

1.40
date	2004.04.05.06.22.07;	author miod;	state Exp;
branches;
next	1.39;

1.39
date	2004.03.14.11.13.04;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2004.02.27.22.09.47;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.02.23.28.04;	author millert;	state Exp;
branches;
next	1.34;

1.34
date	2002.12.23.11.37.31;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.20.23.29.39;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.30.23.01.55;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2002.04.05.16.34.38;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.30.23.00.01;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	2001.10.30.05.15.37;	author mickey;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2001.10.25.14.30.43;	author drahn;	state Exp;
branches;
next	1.26;

1.26
date	2001.09.30.05.49.58;	author mickey;	state Exp;
branches;
next	1.25;

1.25
date	2001.09.26.01.21.37;	author jcs;	state Exp;
branches;
next	1.24;

1.24
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.06.11.22.48.14;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2001.06.11.20.56.57;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.09.01.56.07;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.09.01.43.51;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.09.01.39.31;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2001.06.08.03.23.26;	author mickey;	state Exp;
branches;
next	1.17;

1.17
date	2001.06.08.03.20.31;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.05.08.22.28.43;	author mickey;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.04.18.02.26.58;	author aaron;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.04.18.02.24.22;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.09.18.34.35;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.30.16.38.13;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.01.23.28.46;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.01.03.43.12;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.11.19.14.06;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2001.02.10.19.42.06;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.08.02.47.12;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.30.17.33.20;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.30.04.54.50;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.11.24.14.05.25;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.15.20.00.40;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.05.16.23.49.12;	author mickey;	state Exp;
branches;
next	;

1.2.2.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.15.2.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.16.2.1
date	2001.05.14.22.26.32;	author niklas;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2001.07.04.10.44.11;	author niklas;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.16.2.4;

1.16.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.16.2.5;

1.16.2.5
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.16.2.6;

1.16.2.6
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.16.2.7;

1.16.2.7
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.16.2.8;

1.16.2.8
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.16.2.9;

1.16.2.9
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.28.2.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.28.2.2;

1.28.2.2
date	2003.05.19.22.14.07;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Introduce a new keyboard console hook to enter ddb(4) and make ukbd(4)
use it.

Instead of defering every input of a USB console keyboard to a timeout
via a queue of one element, only differ entering ddb(4) once a matching
control sequenece has been typed.

This prevent loosing inputs when a USB console keyboard is "too fast".

Fix a problem reported by matthieu@@, Adam McDougall and Hrvoje Popovski.

ok stsp@@, dlg@@
@
text
@/* $OpenBSD: wskbd.c,v 1.86 2017/04/30 16:45:46 mpi Exp $ */
/* $NetBSD: wskbd.c,v 1.80 2005/05/04 01:52:16 augustss Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Keysym translator:
 * Contributed to The NetBSD Foundation by Juergen Hannken-Illjes.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)kbd.c	8.2 (Berkeley) 10/30/93
 */

/*
 * Keyboard driver (/dev/wskbd*).  Translates incoming bytes to ASCII or
 * to `wscons_events' and passes them up to the appropriate reader.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/malloc.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/poll.h>

#include <ddb/db_var.h>

#include <dev/wscons/wscons_features.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wscons_callbacks.h>

#include "audio.h"		/* NAUDIO (mixer tuning) */
#include "wsdisplay.h"
#include "wskbd.h"
#include "wsmux.h"

#ifdef WSKBD_DEBUG
#define DPRINTF(x)	if (wskbddebug) printf x
int	wskbddebug = 0;
#else
#define DPRINTF(x)
#endif

#include <dev/wscons/wsmuxvar.h>

struct wskbd_internal {
	const struct wskbd_consops *t_consops;
	void	*t_consaccesscookie;

	int	t_modifiers;
	int	t_composelen;		/* remaining entries in t_composebuf */
	keysym_t t_composebuf[2];

	int	t_flags;
#define WSKFL_METAESC 1

#define MAXKEYSYMSPERKEY 2 /* ESC <key> at max */
	keysym_t t_symbols[MAXKEYSYMSPERKEY];

	struct wskbd_softc *t_sc;	/* back pointer */

	struct wskbd_mapdata t_keymap;	/* translation map table and
					   current layout */
};

struct wskbd_softc {
	struct wsevsrc	sc_base;

	struct wskbd_internal *id;

	const struct wskbd_accessops *sc_accessops;
	void *sc_accesscookie;

	int	sc_ledstate;

	int	sc_isconsole;

	struct wskbd_bell_data sc_bell_data;
	struct wskbd_keyrepeat_data sc_keyrepeat_data;

	int	sc_repeating;		/* we've called timeout() */
	int	sc_repkey;
	struct timeout sc_repeat_ch;
	u_int	sc_repeat_type;
	int	sc_repeat_value;

	int	sc_translating;		/* xlate to chars for emulation */

	int	sc_maplen;		/* number of entries in sc_map */
	struct wscons_keymap *sc_map;	/* current translation map */

	int	sc_refcnt;
	u_char	sc_dying;		/* device is being detached */
};

#define MOD_SHIFT_L		(1 << 0)
#define MOD_SHIFT_R		(1 << 1)
#define MOD_SHIFTLOCK		(1 << 2)
#define MOD_CAPSLOCK		(1 << 3)
#define MOD_CONTROL_L		(1 << 4)
#define MOD_CONTROL_R		(1 << 5)
#define MOD_META_L		(1 << 6)
#define MOD_META_R		(1 << 7)
#define MOD_MODESHIFT		(1 << 8)
#define MOD_NUMLOCK		(1 << 9)
#define MOD_COMPOSE		(1 << 10)
#define MOD_HOLDSCREEN		(1 << 11)
#define MOD_COMMAND		(1 << 12)
#define MOD_COMMAND1		(1 << 13)
#define MOD_COMMAND2		(1 << 14)
#define MOD_MODELOCK		(1 << 15)

#define MOD_ANYSHIFT		(MOD_SHIFT_L | MOD_SHIFT_R | MOD_SHIFTLOCK)
#define MOD_ANYCONTROL		(MOD_CONTROL_L | MOD_CONTROL_R)
#define MOD_ANYMETA		(MOD_META_L | MOD_META_R)
#define MOD_ANYLED		(MOD_SHIFTLOCK | MOD_CAPSLOCK | MOD_NUMLOCK | \
				 MOD_COMPOSE | MOD_HOLDSCREEN)

#define MOD_ONESET(id, mask)	(((id)->t_modifiers & (mask)) != 0)
#define MOD_ALLSET(id, mask)	(((id)->t_modifiers & (mask)) == (mask))

keysym_t ksym_upcase(keysym_t);

int	wskbd_match(struct device *, void *, void *);
void	wskbd_attach(struct device *, struct device *, void *);
int	wskbd_detach(struct device *, int);
int	wskbd_activate(struct device *, int);

int	wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *);

void	update_leds(struct wskbd_internal *);
void	update_modifier(struct wskbd_internal *, u_int, int, int);
int	internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int	wskbd_translate(struct wskbd_internal *, u_int, int);
int	wskbd_enable(struct wskbd_softc *, int);
void	wskbd_debugger(struct wskbd_softc *);
#if NWSDISPLAY > 0
void	change_displayparam(struct wskbd_softc *, int, int, int);
#endif

int	wskbd_do_ioctl_sc(struct wskbd_softc *, u_long, caddr_t, int,
	    struct proc *);
void	wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value);

#if NWSMUX > 0
int	wskbd_mux_open(struct wsevsrc *, struct wseventvar *);
int	wskbd_mux_close(struct wsevsrc *);
#else
#define	wskbd_mux_open NULL
#define	wskbd_mux_close NULL
#endif

int	wskbd_do_open(struct wskbd_softc *, struct wseventvar *);
int	wskbd_do_ioctl(struct device *, u_long, caddr_t, int, struct proc *);

int	(*wskbd_get_backlight)(struct wskbd_backlight *);
int	(*wskbd_set_backlight)(struct wskbd_backlight *);

struct cfdriver wskbd_cd = {
	NULL, "wskbd", DV_TTY
};

struct cfattach wskbd_ca = {
	sizeof (struct wskbd_softc), wskbd_match, wskbd_attach,
	wskbd_detach, wskbd_activate
};

#if defined(__i386__) || defined(__amd64__)
extern int kbd_reset;
#endif

#ifndef WSKBD_DEFAULT_BELL_PITCH
#define	WSKBD_DEFAULT_BELL_PITCH	400	/* 400Hz */
#endif
#ifndef WSKBD_DEFAULT_BELL_PERIOD
#define	WSKBD_DEFAULT_BELL_PERIOD	100	/* 100ms */
#endif
#ifndef WSKBD_DEFAULT_BELL_VOLUME
#define	WSKBD_DEFAULT_BELL_VOLUME	50	/* 50% volume */
#endif

struct wskbd_bell_data wskbd_default_bell_data = {
	WSKBD_BELL_DOALL,
	WSKBD_DEFAULT_BELL_PITCH,
	WSKBD_DEFAULT_BELL_PERIOD,
	WSKBD_DEFAULT_BELL_VOLUME,
};

#ifndef WSKBD_DEFAULT_KEYREPEAT_DEL1
#define	WSKBD_DEFAULT_KEYREPEAT_DEL1	400	/* 400ms to start repeating */
#endif
#ifndef WSKBD_DEFAULT_KEYREPEAT_DELN
#define	WSKBD_DEFAULT_KEYREPEAT_DELN	100	/* 100ms to between repeats */
#endif

struct wskbd_keyrepeat_data wskbd_default_keyrepeat_data = {
	WSKBD_KEYREPEAT_DOALL,
	WSKBD_DEFAULT_KEYREPEAT_DEL1,
	WSKBD_DEFAULT_KEYREPEAT_DELN,
};

#if NWSMUX > 0 || NWSDISPLAY > 0
struct wssrcops wskbd_srcops = {
	WSMUX_KBD,
	wskbd_mux_open, wskbd_mux_close, wskbd_do_ioctl,
	wskbd_displayioctl,
#if NWSDISPLAY > 0
	wskbd_set_display
#else
	NULL
#endif
};
#endif

#if NWSDISPLAY > 0
void wskbd_repeat(void *v);
#endif

static int wskbd_console_initted;
static struct wskbd_softc *wskbd_console_device;
static struct wskbd_internal wskbd_console_data;

void	wskbd_update_layout(struct wskbd_internal *, kbd_t);

#if NAUDIO > 0
extern int wskbd_set_mixervolume(long, long);
#endif

void
wskbd_update_layout(struct wskbd_internal *id, kbd_t enc)
{
	if (enc & KB_METAESC)
		id->t_flags |= WSKFL_METAESC;
	else
		id->t_flags &= ~WSKFL_METAESC;

	id->t_keymap.layout = enc;
}

/*
 * Print function (for parent devices).
 */
int
wskbddevprint(void *aux, const char *pnp)
{
#if 0
	struct wskbddev_attach_args *ap = aux;
#endif

	if (pnp)
		printf("wskbd at %s", pnp);
#if 0
	printf(" console %d", ap->console);
#endif

	return (UNCONF);
}

int
wskbd_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct wskbddev_attach_args *ap = aux;

	if (cf->wskbddevcf_console != WSKBDDEVCF_CONSOLE_UNK) {
		/*
		 * If console-ness of device specified, either match
		 * exactly (at high priority), or fail.
		 */
		if (cf->wskbddevcf_console != 0 && ap->console != 0)
			return (10);
		else
			return (0);
	}

	/* If console-ness unspecified, it wins. */
	return (1);
}

void
wskbd_attach(struct device *parent, struct device *self, void *aux)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;
	struct wskbddev_attach_args *ap = aux;
	kbd_t layout;
#if NWSMUX > 0
	struct wsmux_softc *wsmux_sc;
	int mux, error;
#endif

	sc->sc_isconsole = ap->console;

#if NWSMUX > 0 || NWSDISPLAY > 0
	sc->sc_base.me_ops = &wskbd_srcops;
#endif
#if NWSMUX > 0
	mux = sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux;
	if (ap->console) {
		/* Ignore mux for console; it always goes to the console mux. */
		/* printf(" (mux %d ignored for console)", mux); */
		mux = -1;
	}
	if (mux >= 0) {
		printf(" mux %d", mux);
		wsmux_sc = wsmux_getmux(mux);
	} else
		wsmux_sc = NULL;
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux >= 0)
		printf(" (mux ignored)");
#endif
#endif	/* NWSMUX > 0 */

	if (ap->console) {
		sc->id = &wskbd_console_data;
	} else {
		sc->id = malloc(sizeof(struct wskbd_internal),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		bcopy(ap->keymap, &sc->id->t_keymap, sizeof(sc->id->t_keymap));
	}

#if NWSDISPLAY > 0
	timeout_set(&sc->sc_repeat_ch, wskbd_repeat, sc);
#endif

	sc->id->t_sc = sc;

	sc->sc_accessops = ap->accessops;
	sc->sc_accesscookie = ap->accesscookie;
	sc->sc_repeating = 0;
	sc->sc_translating = 1;
	sc->sc_ledstate = -1; /* force update */

	/*
	 * If this layout is the default choice of the driver (i.e. the
	 * driver doesn't know better), pick the existing layout of the
	 * current mux, if any.
	 */
	layout = sc->id->t_keymap.layout;
#if NWSMUX > 0
	if (layout & KB_DEFAULT) {
		if (wsmux_sc != NULL && wsmux_get_layout(wsmux_sc) != KB_NONE)
			layout = wsmux_get_layout(wsmux_sc);
	}
#endif
	for (;;) {
		if (wskbd_load_keymap(&sc->id->t_keymap, layout, &sc->sc_map,
		    &sc->sc_maplen) == 0)
			break;
#if NWSMUX > 0
		if (layout == sc->id->t_keymap.layout)
			panic("cannot load keymap");
		if (wsmux_sc != NULL && wsmux_get_layout(wsmux_sc) != KB_NONE) {
			printf("\n%s: cannot load keymap, "
			    "falling back to default\n%s",
			    sc->sc_base.me_dv.dv_xname,
			    sc->sc_base.me_dv.dv_xname);
			layout = wsmux_get_layout(wsmux_sc);
		} else
#endif
			panic("cannot load keymap");
	}
	wskbd_update_layout(sc->id, layout);

	/* set default bell and key repeat data */
	sc->sc_bell_data = wskbd_default_bell_data;
	sc->sc_keyrepeat_data = wskbd_default_keyrepeat_data;

	if (ap->console) {
		KASSERT(wskbd_console_initted); 
		KASSERT(wskbd_console_device == NULL);

		wskbd_console_device = sc;

		printf(": console keyboard");

#if NWSDISPLAY > 0
		wsdisplay_set_console_kbd(&sc->sc_base); /* sets sc_displaydv */
		if (sc->sc_displaydv != NULL)
			printf(", using %s", sc->sc_displaydv->dv_xname);
#endif
	}
	printf("\n");

#if NWSMUX > 0
	if (wsmux_sc != NULL) {
		error = wsmux_attach_sc(wsmux_sc, &sc->sc_base);
		if (error)
			printf("%s: attach error=%d\n",
			    sc->sc_base.me_dv.dv_xname, error);

		/*
		 * Try and set this encoding as the mux default if it
		 * hasn't any yet, and if this is not a driver default
		 * layout (i.e. parent driver pretends to know better).
		 * Note that wsmux_set_layout() rejects layouts with
		 * KB_DEFAULT set.
		 */
		if (wsmux_get_layout(wsmux_sc) == KB_NONE)
			wsmux_set_layout(wsmux_sc, layout);
	}
#endif

#if NWSDISPLAY > 0 && NWSMUX == 0
	if (ap->console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wsdisplay_cd;

		if (wsdisplay_cd.cd_ndevs != 0 && self->dv_unit == 0) {
			if (wskbd_set_display(self,
			    wsdisplay_cd.cd_devs[0]) == 0)
				wsdisplay_set_kbd(wsdisplay_cd.cd_devs[0],
				    (struct wsevsrc *)sc);
		}
	}
#endif
}

void    
wskbd_cnattach(const struct wskbd_consops *consops, void *conscookie,
    const struct wskbd_mapdata *mapdata)
{

	KASSERT(!wskbd_console_initted);

	bcopy(mapdata, &wskbd_console_data.t_keymap, sizeof(*mapdata));
	wskbd_update_layout(&wskbd_console_data, mapdata->layout);

	wskbd_console_data.t_consops = consops;
	wskbd_console_data.t_consaccesscookie = conscookie;

#if NWSDISPLAY > 0
	wsdisplay_set_cons_kbd(wskbd_cngetc, wskbd_cnpollc, wskbd_cnbell);
#endif

	wskbd_console_initted = 1;
}

void
wskbd_cndetach(void)
{
	KASSERT(wskbd_console_initted);

	wskbd_console_data.t_keymap.keydesc = NULL;
	wskbd_console_data.t_keymap.layout = KB_NONE;

	wskbd_console_data.t_consops = NULL;
	wskbd_console_data.t_consaccesscookie = NULL;

#if NWSDISPLAY > 0
	wsdisplay_unset_cons_kbd();
#endif

	wskbd_console_device = NULL;
	wskbd_console_initted = 0;
}

#if NWSDISPLAY > 0
void
wskbd_repeat(void *v)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)v;
	int s = spltty();

	if (sc->sc_repeating == 0) {
		/*
		 * race condition: a "key up" event came in when wskbd_repeat()
		 * was already called but not yet spltty()'d
		 */
		splx(s);
		return;
	}
	if (sc->sc_translating) {
		/* deliver keys */
		if (sc->sc_displaydv != NULL)
			wsdisplay_kbdinput(sc->sc_displaydv,
			    sc->id->t_keymap.layout,
			    sc->id->t_symbols, sc->sc_repeating);
	} else {
		/* queue event */
		wskbd_deliver_event(sc, sc->sc_repeat_type,
		    sc->sc_repeat_value);
	}
	if (sc->sc_keyrepeat_data.delN != 0)
		timeout_add_msec(&sc->sc_repeat_ch, sc->sc_keyrepeat_data.delN);
	splx(s);
}
#endif

int
wskbd_activate(struct device *self, int act)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;

	if (act == DVACT_DEACTIVATE)
		sc->sc_dying = 1;
	return (0);
}

/*
 * Detach a keyboard.  To keep track of users of the softc we keep
 * a reference count that's incremented while inside, e.g., read.
 * If the keyboard is active and the reference count is > 0 (0 is the
 * normal state) we post an event and then wait for the process
 * that had the reference to wake us up again.  Then we blow away the
 * vnode and return (which will deallocate the softc).
 */
int
wskbd_detach(struct device  *self, int flags)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)self;
	struct wseventvar *evar;
	int maj, mn;
	int s;

#if NWSMUX > 0
	/* Tell parent mux we're leaving. */
	if (sc->sc_base.me_parent != NULL)
		wsmux_detach_sc(&sc->sc_base);
#endif

#if NWSDISPLAY > 0
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}
#endif

	if (sc->sc_isconsole) {
		KASSERT(wskbd_console_device == sc);
		wskbd_cndetach();
	}

	evar = sc->sc_base.me_evp;
	if (evar != NULL && evar->io != NULL) {
		s = spltty();
		if (--sc->sc_refcnt >= 0) {
			/* Wake everyone by generating a dummy event. */
			if (++evar->put >= WSEVENT_QSIZE)
				evar->put = 0;
			WSEVENT_WAKEUP(evar);
			/* Wait for processes to go away. */
			if (tsleep(sc, PZERO, "wskdet", hz * 60))
				printf("wskbd_detach: %s didn't detach\n",
				       sc->sc_base.me_dv.dv_xname);
		}
		splx(s);
	}

	free(sc->sc_map, M_DEVBUF, 0);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wskbdopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

void
wskbd_input(struct device *dev, u_int type, int value)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dev; 
#if NWSDISPLAY > 0
	int num;
#endif

#if NWSDISPLAY > 0
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}

	/*
	 * If /dev/wskbdN is not connected in event mode translate and
	 * send upstream.
	 */
	if (sc->sc_translating) {
#ifdef HAVE_BURNER_SUPPORT
		if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_displaydv != NULL)
			wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_KBD);
#endif
		num = wskbd_translate(sc->id, type, value);
		if (num > 0) {
			if (sc->sc_displaydv != NULL) {
#ifdef HAVE_SCROLLBACK_SUPPORT
				/* XXX - Shift_R+PGUP(release) emits PrtSc */
				if (sc->id->t_symbols[0] != KS_Print_Screen) {
					wsscrollback(sc->sc_displaydv,
					    WSDISPLAY_SCROLL_RESET);
				}
#endif
				wsdisplay_kbdinput(sc->sc_displaydv,
				    sc->id->t_keymap.layout,
				    sc->id->t_symbols, num);
			}

			if (sc->sc_keyrepeat_data.del1 != 0) {
				sc->sc_repeating = num;
				timeout_add_msec(&sc->sc_repeat_ch,
				    sc->sc_keyrepeat_data.del1);
			}
		}
		return;
	}
#endif

	wskbd_deliver_event(sc, type, value);

#if NWSDISPLAY > 0
	/* Repeat key presses if enabled. */
	if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_keyrepeat_data.del1 != 0) {
		sc->sc_repeat_type = type;
		sc->sc_repeat_value = value;
		sc->sc_repeating = 1;
		timeout_add_msec(&sc->sc_repeat_ch, sc->sc_keyrepeat_data.del1);
	}
#endif
}

/*
 * Keyboard is generating events.  Turn this keystroke into an
 * event and put it in the queue.  If the queue is full, the
 * keystroke is lost (sorry!).
 */
void
wskbd_deliver_event(struct wskbd_softc *sc, u_int type, int value)
{
	struct wseventvar *evar;
	struct wscons_event *ev;
	int put;

	evar = sc->sc_base.me_evp;

	if (evar == NULL) {
		DPRINTF(("wskbd_input: not open\n"));
		return;
	}

#ifdef DIAGNOSTIC
	if (evar->q == NULL) {
		printf("wskbd_input: evar->q=NULL\n");
		return;
	}
#endif

	put = evar->put;
	ev = &evar->q[put];
	put = (put + 1) % WSEVENT_QSIZE;
	if (put == evar->get) {
		log(LOG_WARNING, "%s: event queue overflow\n",
		    sc->sc_base.me_dv.dv_xname);
		return;
	}
	ev->type = type;
	ev->value = value;
	nanotime(&ev->time);
	evar->put = put;
	WSEVENT_WAKEUP(evar);
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
void
wskbd_rawinput(struct device *dev, u_char *buf, int len)
{
#if NWSDISPLAY > 0
	struct wskbd_softc *sc = (struct wskbd_softc *)dev;

	if (sc->sc_displaydv != NULL)
		wsdisplay_rawkbdinput(sc->sc_displaydv, buf, len);
#endif
}
#endif /* WSDISPLAY_COMPAT_RAWKBD */

int
wskbd_enable(struct wskbd_softc *sc, int on)
{
	int error;

#if NWSDISPLAY > 0
	if (sc->sc_displaydv != NULL)
		return (0);

	/* Always cancel auto repeat when fiddling with the kbd. */
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}
#endif

	error = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);
	DPRINTF(("wskbd_enable: sc=%p on=%d res=%d\n", sc, on, error));
	return (error);
}

#if NWSMUX > 0
int
wskbd_mux_open(struct wsevsrc *me, struct wseventvar *evp)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	if (sc->sc_dying)
		return (EIO);

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return (wskbd_do_open(sc, evp));
}
#endif

int
wskbdopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wskbd_softc *sc;
	struct wseventvar *evar;
	int unit, error;

	unit = minor(dev);
	if (unit >= wskbd_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

#if NWSMUX > 0
	DPRINTF(("wskbdopen: %s mux=%p p=%p\n", sc->sc_base.me_dv.dv_xname,
		 sc->sc_base.me_parent, p));
#endif

	if (sc->sc_dying)
		return (EIO);

	if ((flags & (FREAD | FWRITE)) == FWRITE) {
		/* Not opening for read, only ioctl is available. */
		return (0);
	}

#if NWSMUX > 0
	if (sc->sc_base.me_parent != NULL) {
		/* Grab the keyboard out of the greedy hands of the mux. */
		DPRINTF(("wskbdopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
#endif

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p->p_p;

	error = wskbd_do_open(sc, evar);
	if (error) {
		DPRINTF(("wskbdopen: %s open failed\n",
			 sc->sc_base.me_dv.dv_xname));
		sc->sc_base.me_evp = NULL;
		wsevent_fini(evar);
	}
	return (error);
}

int
wskbd_do_open(struct wskbd_softc *sc, struct wseventvar *evp)
{
	sc->sc_base.me_evp = evp;
	sc->sc_translating = 0;

	return (wskbd_enable(sc, 1));
}

int
wskbdclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wskbd_softc *sc =
	    (struct wskbd_softc *)wskbd_cd.cd_devs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;

	if (evar == NULL)
		/* not open for read */
		return (0);

	sc->sc_base.me_evp = NULL;
	sc->sc_translating = 1;
	(void)wskbd_enable(sc, 0);
	wsevent_fini(evar);

#if NWSMUX > 0
	if (sc->sc_base.me_parent == NULL) {
		int mux, error;

		DPRINTF(("wskbdclose: attach\n"));
		mux = sc->sc_base.me_dv.dv_cfdata->wskbddevcf_mux;
		if (mux >= 0) {
			error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
			if (error)
				printf("%s: can't attach mux (error=%d)\n",
				    sc->sc_base.me_dv.dv_xname, error);
		}
	}
#endif

	return (0);
}

#if NWSMUX > 0
int
wskbd_mux_close(struct wsevsrc *me)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)me;

	sc->sc_base.me_evp = NULL;
	sc->sc_translating = 1;
	(void)wskbd_enable(sc, 0);

	return (0);
}
#endif

int
wskbdread(dev_t dev, struct uio *uio, int flags)
{
	struct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];
	int error;

	if (sc->sc_dying)
		return (EIO);

#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp == NULL) {
		printf("wskbdread: evp == NULL\n");
		return (EINVAL);
	}
#endif

	sc->sc_refcnt++;
	error = wsevent_read(&sc->sc_base.me_evar, uio, flags);
	if (--sc->sc_refcnt < 0) {
		wakeup(sc);
		error = EIO;
	}
	return (error);
}

int
wskbdioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	return (wskbd_do_ioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));
}

/* A wrapper around the ioctl() workhorse to make reference counting easy. */
int
wskbd_do_ioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
	int error;

	sc->sc_refcnt++;
	error = wskbd_do_ioctl_sc(sc, cmd, data, flag, p);
	if (--sc->sc_refcnt < 0)
		wakeup(sc);
	return (error);
}

int
wskbd_do_ioctl_sc(struct wskbd_softc *sc, u_long cmd, caddr_t data, int flag,
     struct proc *p)
{
	int error;

	/*      
	 * Try the generic ioctls that the wskbd interface supports.
	 */
	switch (cmd) {
	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);

	case FIOASYNC:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		sc->sc_base.me_evp->async = *(int *)data != 0;
		return (0);

	case FIOSETOWN:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (-*(int *)data != sc->sc_base.me_evp->io->ps_pgid &&
		    *(int *)data != sc->sc_base.me_evp->io->ps_pid)
			return (EPERM);
		return (0);
		   
	case TIOCSPGRP:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (*(int *)data != sc->sc_base.me_evp->io->ps_pgid)
			return (EPERM);
		return (0);
	}

	/*
	 * Try the keyboard driver for WSKBDIO ioctls.  It returns -1
	 * if it didn't recognize the request.
	 */
	error = wskbd_displayioctl(&sc->sc_base.me_dv, cmd, data, flag, p);
	return (error != -1 ? error : ENOTTY);
}

/*
 * WSKBDIO ioctls, handled in both emulation mode and in ``raw'' mode.
 * Some of these have no real effect in raw mode, however.
 */
int
wskbd_displayioctl(struct device *dev, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dev;
	struct wskbd_bell_data *ubdp, *kbdp;
	struct wskbd_keyrepeat_data *ukdp, *kkdp;
	struct wskbd_map_data *umdp;
	struct wskbd_encoding_data *uedp;
	kbd_t enc;
	void *buf;
	int len, error;
	int count, i;

	switch (cmd) {
	case WSKBDIO_BELL:
	case WSKBDIO_COMPLEXBELL:
	case WSKBDIO_SETBELL:
	case WSKBDIO_SETKEYREPEAT:
	case WSKBDIO_SETDEFAULTKEYREPEAT:
	case WSKBDIO_SETMAP:
	case WSKBDIO_SETENCODING:
	case WSKBDIO_SETBACKLIGHT:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
#define	SETBELL(dstp, srcp, dfltp)					\
    do {								\
	(dstp)->pitch = ((srcp)->which & WSKBD_BELL_DOPITCH) ?		\
	    (srcp)->pitch : (dfltp)->pitch;				\
	(dstp)->period = ((srcp)->which & WSKBD_BELL_DOPERIOD) ?	\
	    (srcp)->period : (dfltp)->period;				\
	(dstp)->volume = ((srcp)->which & WSKBD_BELL_DOVOLUME) ?	\
	    (srcp)->volume : (dfltp)->volume;				\
	(dstp)->which = WSKBD_BELL_DOALL;				\
    } while (0)

	case WSKBDIO_BELL:
		return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,
		    WSKBDIO_COMPLEXBELL, (caddr_t)&sc->sc_bell_data, flag, p));

	case WSKBDIO_COMPLEXBELL:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(ubdp, ubdp, &sc->sc_bell_data);
		return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie,
		    WSKBDIO_COMPLEXBELL, (caddr_t)ubdp, flag, p));

	case WSKBDIO_SETBELL:
		kbdp = &sc->sc_bell_data;
setbell:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(kbdp, ubdp, kbdp);
		return (0);

	case WSKBDIO_GETBELL:
		kbdp = &sc->sc_bell_data;
getbell:
		ubdp = (struct wskbd_bell_data *)data;
		SETBELL(ubdp, kbdp, kbdp);
		return (0);

	case WSKBDIO_SETDEFAULTBELL:
		if ((error = suser(p, 0)) != 0)
			return (error);
		kbdp = &wskbd_default_bell_data;
		goto setbell;


	case WSKBDIO_GETDEFAULTBELL:
		kbdp = &wskbd_default_bell_data;
		goto getbell;

#undef SETBELL

#define	SETKEYREPEAT(dstp, srcp, dfltp)					\
    do {								\
	(dstp)->del1 = ((srcp)->which & WSKBD_KEYREPEAT_DODEL1) ?	\
	    (srcp)->del1 : (dfltp)->del1;				\
	(dstp)->delN = ((srcp)->which & WSKBD_KEYREPEAT_DODELN) ?	\
	    (srcp)->delN : (dfltp)->delN;				\
	(dstp)->which = WSKBD_KEYREPEAT_DOALL;				\
    } while (0)

	case WSKBDIO_SETKEYREPEAT:
		kkdp = &sc->sc_keyrepeat_data;
setkeyrepeat:
		ukdp = (struct wskbd_keyrepeat_data *)data;
		SETKEYREPEAT(kkdp, ukdp, kkdp);
		return (0);

	case WSKBDIO_GETKEYREPEAT:
		kkdp = &sc->sc_keyrepeat_data;
getkeyrepeat:
		ukdp = (struct wskbd_keyrepeat_data *)data;
		SETKEYREPEAT(ukdp, kkdp, kkdp);
		return (0);

	case WSKBDIO_SETDEFAULTKEYREPEAT:
		if ((error = suser(p, 0)) != 0)
			return (error);
		kkdp = &wskbd_default_keyrepeat_data;
		goto setkeyrepeat;


	case WSKBDIO_GETDEFAULTKEYREPEAT:
		kkdp = &wskbd_default_keyrepeat_data;
		goto getkeyrepeat;

#undef SETKEYREPEAT

	case WSKBDIO_SETMAP:
		umdp = (struct wskbd_map_data *)data;
		if (umdp->maplen > WSKBDIO_MAXMAPLEN)
			return (EINVAL);

		buf = mallocarray(umdp->maplen, sizeof(struct wscons_keymap),
		    M_TEMP, M_WAITOK);
		len = umdp->maplen * sizeof(struct wscons_keymap);

		error = copyin(umdp->map, buf, len);
		if (error == 0) {
			wskbd_init_keymap(umdp->maplen,
					  &sc->sc_map, &sc->sc_maplen);
			memcpy(sc->sc_map, buf, len);
			/* drop the variant bits handled by the map */
			enc = KB_USER | (KB_VARIANT(sc->id->t_keymap.layout) &
			    KB_HANDLEDBYWSKBD);
			wskbd_update_layout(sc->id, enc);
		}
		free(buf, M_TEMP, 0);
		return(error);

	case WSKBDIO_GETMAP:
		umdp = (struct wskbd_map_data *)data;
		if (umdp->maplen > sc->sc_maplen)
			umdp->maplen = sc->sc_maplen;
		error = copyout(sc->sc_map, umdp->map,
				umdp->maplen*sizeof(struct wscons_keymap));
		return(error);

	case WSKBDIO_GETENCODING:
		*((kbd_t *)data) = sc->id->t_keymap.layout & ~KB_DEFAULT;
		return(0);

	case WSKBDIO_SETENCODING:
		enc = *((kbd_t *)data);
		if (KB_ENCODING(enc) == KB_USER) {
			/* user map must already be loaded */
			if (KB_ENCODING(sc->id->t_keymap.layout) != KB_USER)
				return (EINVAL);
			/* map variants make no sense */
			if (KB_VARIANT(enc) & ~KB_HANDLEDBYWSKBD)
				return (EINVAL);
		} else {
			error = wskbd_load_keymap(&sc->id->t_keymap, enc,
			    &sc->sc_map, &sc->sc_maplen);
			if (error)
				return (error);
		}
		wskbd_update_layout(sc->id, enc);
#if NWSMUX > 0
		/* Update mux default layout */
		if (sc->sc_base.me_parent != NULL)
			wsmux_set_layout(sc->sc_base.me_parent, enc);
#endif
		return (0);

	case WSKBDIO_GETENCODINGS:
		uedp = (struct wskbd_encoding_data *)data;
		for (count = 0; sc->id->t_keymap.keydesc[count].name; count++)
			;
		if (uedp->nencodings > count)
			uedp->nencodings = count;
		for (i = 0; i < uedp->nencodings; i++) {
			error = copyout(&sc->id->t_keymap.keydesc[i].name,
			    &uedp->encodings[i], sizeof(kbd_t));
			if (error)
				return (error);
		}
		return (0);

	case WSKBDIO_GETBACKLIGHT:
		if (wskbd_get_backlight != NULL)
			return (*wskbd_get_backlight)((struct wskbd_backlight *)data);
		error = ENOTTY;
		break;

	case WSKBDIO_SETBACKLIGHT:
		if (wskbd_set_backlight != NULL)
			return (*wskbd_set_backlight)((struct wskbd_backlight *)data);
		error = ENOTTY;
		break;
	}

	/*
	 * Try the keyboard driver for WSKBDIO ioctls.  It returns -1
	 * if it didn't recognize the request, and in turn we return
	 * -1 if we didn't recognize the request.
	 */
/* printf("kbdaccess\n"); */
	error = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
					   flag, p);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (!error && cmd == WSKBDIO_SETMODE && *(int *)data == WSKBD_RAW) {
		int s = spltty();
		sc->id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R
					 | MOD_CONTROL_L | MOD_CONTROL_R
					 | MOD_META_L | MOD_META_R
					 | MOD_COMMAND
					 | MOD_COMMAND1 | MOD_COMMAND2);
#if NWSDISPLAY > 0
		if (sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
#endif
		splx(s);
	}
#endif
	return (error);
}

int
wskbdpoll(dev_t dev, int events, struct proc *p)
{
	struct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (POLLERR);
	return (wsevent_poll(sc->sc_base.me_evp, events, p));
}

int
wskbdkqfilter(dev_t dev, struct knote *kn)
{
	struct wskbd_softc *sc = wskbd_cd.cd_devs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (ENXIO);
	return (wsevent_kqfilter(sc->sc_base.me_evp, kn));
}

#if NWSDISPLAY > 0

int
wskbd_pickfree(void)
{
	int i;
	struct wskbd_softc *sc;

	for (i = 0; i < wskbd_cd.cd_ndevs; i++) {
		if ((sc = wskbd_cd.cd_devs[i]) == NULL)
			continue;
		if (sc->sc_displaydv == NULL)
			return (i);
	}
	return (-1);
}

struct wsevsrc *
wskbd_set_console_display(struct device *displaydv, struct wsevsrc *me)
{
	struct wskbd_softc *sc = wskbd_console_device;

	if (sc == NULL)
		return (NULL);
	sc->sc_displaydv = displaydv;
#if NWSMUX > 0
	(void)wsmux_attach_sc((struct wsmux_softc *)me, &sc->sc_base);
#endif
	return (&sc->sc_base);
}

int
wskbd_set_display(struct device *dv, struct device *displaydv)
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
	struct device *odisplaydv;
	int error;

	DPRINTF(("wskbd_set_display: %s odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, sc->sc_displaydv, displaydv, 
		 sc->sc_isconsole));

	if (sc->sc_isconsole)
		return (EBUSY);

	if (displaydv != NULL) {
		if (sc->sc_displaydv != NULL)
			return (EBUSY);
	} else {
		if (sc->sc_displaydv == NULL)
			return (ENXIO);
	}

	odisplaydv = sc->sc_displaydv;
	sc->sc_displaydv = NULL;
	error = wskbd_enable(sc, displaydv != NULL);
	sc->sc_displaydv = displaydv;
	if (error) {
		sc->sc_displaydv = odisplaydv;
		return (error);
	}

	if (displaydv)
		printf("%s: connecting to %s\n",
		       sc->sc_base.me_dv.dv_xname, displaydv->dv_xname);
	else
		printf("%s: disconnecting from %s\n",
		       sc->sc_base.me_dv.dv_xname, odisplaydv->dv_xname);

	return (0);
}

#endif	/* NWSDISPLAY > 0 */

#if NWSMUX > 0
int
wskbd_add_mux(int unit, struct wsmux_softc *muxsc)
{
	struct wskbd_softc *sc;

	if (unit < 0 || unit >= wskbd_cd.cd_ndevs ||
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}
#endif

/*
 * Console interface.
 */
int
wskbd_cngetc(dev_t dev)
{
	static int num = 0;
	static int pos;
	u_int type;
	int data;
	keysym_t ks;

	if (!wskbd_console_initted)
		return 0;

	if (wskbd_console_device != NULL &&
	    !wskbd_console_device->sc_translating)
		return 0;

	for(;;) {
		if (num-- > 0) {
			ks = wskbd_console_data.t_symbols[pos++];
			if (KS_GROUP(ks) == KS_GROUP_Ascii)
				return (KS_VALUE(ks));	
		} else {
			(*wskbd_console_data.t_consops->getc)
				(wskbd_console_data.t_consaccesscookie,
				 &type, &data);
			num = wskbd_translate(&wskbd_console_data, type, data);
			pos = 0;
		}
	}
}

void
wskbd_cnpollc(dev_t dev, int poll)
{
	if (!wskbd_console_initted)
		return;

	if (wskbd_console_device != NULL &&
	    !wskbd_console_device->sc_translating)
		return;

	(*wskbd_console_data.t_consops->pollc)
	    (wskbd_console_data.t_consaccesscookie, poll);
}

void
wskbd_cnbell(dev_t dev, u_int pitch, u_int period, u_int volume)
{
	if (!wskbd_console_initted)
		return;

	if (wskbd_console_data.t_consops->bell != NULL)
		(*wskbd_console_data.t_consops->bell)
		    (wskbd_console_data.t_consaccesscookie, pitch, period,
			volume);
}

void
update_leds(struct wskbd_internal *id)
{
	int new_state;

	new_state = 0;
	if (id->t_modifiers & (MOD_SHIFTLOCK | MOD_CAPSLOCK))
		new_state |= WSKBD_LED_CAPS;
	if (id->t_modifiers & MOD_NUMLOCK)
		new_state |= WSKBD_LED_NUM;
	if (id->t_modifiers & MOD_COMPOSE)
		new_state |= WSKBD_LED_COMPOSE;
	if (id->t_modifiers & MOD_HOLDSCREEN)
		new_state |= WSKBD_LED_SCROLL;

	if (id->t_sc && new_state != id->t_sc->sc_ledstate) {
		(*id->t_sc->sc_accessops->set_leds)
		    (id->t_sc->sc_accesscookie, new_state);
		id->t_sc->sc_ledstate = new_state;
	}
}

void
update_modifier(struct wskbd_internal *id, u_int type, int toggle, int mask)
{
	if (toggle) {
		if (type == WSCONS_EVENT_KEY_DOWN)
			id->t_modifiers ^= mask;
	} else {
		if (type == WSCONS_EVENT_KEY_DOWN)
			id->t_modifiers |= mask;
		else
			id->t_modifiers &= ~mask;
	}
	if (mask & MOD_ANYLED)
		update_leds(id);
}

#if NWSDISPLAY > 0
void
change_displayparam(struct wskbd_softc *sc, int param, int updown,
    int wraparound)
{
	int res;
	struct wsdisplay_param dp;

	dp.param = param;
	res = wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_GETPARAM, &dp);

	if (res == EINVAL)
		return; /* no such parameter */

	dp.curval += updown;
	if (dp.max < dp.curval)
		dp.curval = wraparound ? dp.min : dp.max;
	else
	if (dp.curval < dp.min)
		dp.curval = wraparound ? dp.max : dp.min;
	wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_SETPARAM, &dp);
}
#endif

int
internal_command(struct wskbd_softc *sc, u_int *type, keysym_t ksym,
    keysym_t ksym2)
{
	switch (ksym) {
	case KS_Cmd:
		update_modifier(sc->id, *type, 0, MOD_COMMAND);
		ksym = ksym2;
		break;

	case KS_Cmd1:
		update_modifier(sc->id, *type, 0, MOD_COMMAND1);
		break;

	case KS_Cmd2:
		update_modifier(sc->id, *type, 0, MOD_COMMAND2);
		break;
	}

	if (*type != WSCONS_EVENT_KEY_DOWN)
		return (0);

#ifdef HAVE_SCROLLBACK_SUPPORT
#if NWSDISPLAY > 0
	switch (ksym) {
	case KS_Cmd_ScrollBack:
		if (MOD_ONESET(sc->id, MOD_ANYSHIFT)) {
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_BACKWARD);
			return (1);
		}
		break;

	case KS_Cmd_ScrollFwd:
		if (MOD_ONESET(sc->id, MOD_ANYSHIFT)) {
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_FORWARD);
			return (1);
		}
		break;
	}
#endif
#endif

	if (!MOD_ONESET(sc->id, MOD_COMMAND) &&
	    !MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2))
		return (0);

#ifdef DDB
	if (ksym == KS_Cmd_Debugger) {
		wskbd_debugger(sc);
		/* discard this key (ddb discarded command modifiers) */
		*type = WSCONS_EVENT_KEY_UP;
		return (1);
	}
#endif

#if NWSDISPLAY > 0
	if (sc->sc_displaydv == NULL)
		return (0);

	switch (ksym) {
	case KS_Cmd_Screen0:
	case KS_Cmd_Screen1:
	case KS_Cmd_Screen2:
	case KS_Cmd_Screen3:
	case KS_Cmd_Screen4:
	case KS_Cmd_Screen5:
	case KS_Cmd_Screen6:
	case KS_Cmd_Screen7:
	case KS_Cmd_Screen8:
	case KS_Cmd_Screen9:
	case KS_Cmd_Screen10:
	case KS_Cmd_Screen11:
		wsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);
		return (1);
	case KS_Cmd_ResetEmul:
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
		return (1);
	case KS_Cmd_ResetClose:
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
		return (1);
#if defined(__i386__) || defined(__amd64__)
	case KS_Cmd_KbdReset:
		switch (kbd_reset) {
#ifdef DDB
		case 2:
			wskbd_debugger(sc);
			/* discard this key (ddb discarded command modifiers) */
			*type = WSCONS_EVENT_KEY_UP;
			break;
#endif
		case 1:
			kbd_reset = 0;
			prsignal(initprocess, SIGUSR1);
			break;
		default:
			break;
		}
		return (1);
#endif
	case KS_Cmd_BacklightOn:
	case KS_Cmd_BacklightOff:
	case KS_Cmd_BacklightToggle:
		change_displayparam(sc, WSDISPLAYIO_PARAM_BACKLIGHT,
		    ksym == KS_Cmd_BacklightOff ? -1 : 1,
		    ksym == KS_Cmd_BacklightToggle ? 1 : 0);
		return (1);
	case KS_Cmd_BrightnessUp:
	case KS_Cmd_BrightnessDown:
	case KS_Cmd_BrightnessRotate:
		change_displayparam(sc, WSDISPLAYIO_PARAM_BRIGHTNESS,
		    ksym == KS_Cmd_BrightnessDown ? -1 : 1,
		    ksym == KS_Cmd_BrightnessRotate ? 1 : 0);
		return (1);
	case KS_Cmd_ContrastUp:
	case KS_Cmd_ContrastDown:
	case KS_Cmd_ContrastRotate:
		change_displayparam(sc, WSDISPLAYIO_PARAM_CONTRAST,
		    ksym == KS_Cmd_ContrastDown ? -1 : 1,
		    ksym == KS_Cmd_ContrastRotate ? 1 : 0);
		return (1);
	}
#endif
	return (0);
}

int
wskbd_translate(struct wskbd_internal *id, u_int type, int value)
{
	struct wskbd_softc *sc = id->t_sc;
	keysym_t ksym, res, *group;
	struct wscons_keymap kpbuf, *kp;
	int gindex, iscommand = 0;

	if (type == WSCONS_EVENT_ALL_KEYS_UP) {
#if NWSDISPLAY > 0
		if (sc != NULL && sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
#endif
		id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R |
		    MOD_CONTROL_L | MOD_CONTROL_R |
		    MOD_META_L | MOD_META_R |
		    MOD_MODESHIFT | MOD_MODELOCK |
		    MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);
		return (0);
	}

	if (sc != NULL) {
		if (value < 0 || value >= sc->sc_maplen) {
#ifdef DEBUG
			printf("wskbd_translate: keycode %d out of range\n",
			       value);
#endif
			return (0);
		}
		kp = sc->sc_map + value;
	} else {
		kp = &kpbuf;
		wskbd_get_mapentry(&id->t_keymap, value, kp);
	}

	/* if this key has a command, process it first */
	if (sc != NULL && kp->command != KS_voidSymbol)
		iscommand = internal_command(sc, &type, kp->command,
		    kp->group1[0]);

	/* Now update modifiers */
	switch (kp->group1[0]) {
	case KS_Shift_L:
		update_modifier(id, type, 0, MOD_SHIFT_L);
		break;

	case KS_Shift_R:
		update_modifier(id, type, 0, MOD_SHIFT_R);
		break;

	case KS_Shift_Lock:
		update_modifier(id, type, 1, MOD_SHIFTLOCK);
		break;

	case KS_Caps_Lock:
		update_modifier(id, type, 1, MOD_CAPSLOCK);
		break;

	case KS_Control_L:
		update_modifier(id, type, 0, MOD_CONTROL_L);
		break;

	case KS_Control_R:
		update_modifier(id, type, 0, MOD_CONTROL_R);
		break;

	case KS_Alt_L:
		update_modifier(id, type, 0, MOD_META_L);
		break;

	case KS_Alt_R:
		update_modifier(id, type, 0, MOD_META_R);
		break;

	case KS_Mode_switch:
		update_modifier(id, type, 0, MOD_MODESHIFT);
		break;

	case KS_Mode_Lock:
		update_modifier(id, type, 1, MOD_MODELOCK);
		break;

	case KS_Num_Lock:
		update_modifier(id, type, 1, MOD_NUMLOCK);
		break;

#if NWSDISPLAY > 0
	case KS_Hold_Screen:
		if (sc != NULL) {
			update_modifier(id, type, 1, MOD_HOLDSCREEN);
			if (sc->sc_displaydv != NULL)
				wsdisplay_kbdholdscreen(sc->sc_displaydv,
				    id->t_modifiers & MOD_HOLDSCREEN);
		}
		break;

	default:
		if (sc != NULL && sc->sc_repeating &&
		    ((type == WSCONS_EVENT_KEY_UP && value != sc->sc_repkey) ||
		     (type == WSCONS_EVENT_KEY_DOWN && value == sc->sc_repkey)))
			return (0);
		break;
#endif
	}

#if NWSDISPLAY > 0
	if (sc != NULL) {
		if (sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
		sc->sc_repkey = value;
	}
#endif

	/* If this is a key release or we are in command mode, we are done */
	if (type != WSCONS_EVENT_KEY_DOWN || iscommand)
		return (0);

	/* Get the keysym */
	if (id->t_modifiers & (MOD_MODESHIFT|MOD_MODELOCK) &&
	    !MOD_ONESET(id, MOD_ANYCONTROL))
		group = & kp->group2[0];
	else
		group = & kp->group1[0];

	if ((id->t_modifiers & MOD_NUMLOCK) &&
	    KS_GROUP(group[1]) == KS_GROUP_Keypad) {
		gindex = !MOD_ONESET(id, MOD_ANYSHIFT);
		ksym = group[gindex];
	} else {
		/* CAPS alone should only affect letter keys */
		if ((id->t_modifiers & (MOD_CAPSLOCK | MOD_ANYSHIFT)) ==
		    MOD_CAPSLOCK) {
			gindex = 0;
			ksym = ksym_upcase(group[0]);
		} else {
			gindex = MOD_ONESET(id, MOD_ANYSHIFT);
			ksym = group[gindex];
		}
	}

	/* Submit Audio keys for hotkey processing */
	if (KS_GROUP(ksym) == KS_GROUP_Function) {
		switch (ksym) {
#if NAUDIO > 0
		case KS_AudioMute:
			wskbd_set_mixervolume(0, 1);
			return (0);
		case KS_AudioLower:
			wskbd_set_mixervolume(-1, 1);
			return (0);
		case KS_AudioRaise:
			wskbd_set_mixervolume(1, 1);
			return (0);
#endif
		default:
			break;
		}
	}

	/* Process compose sequence and dead accents */
	res = KS_voidSymbol;

	switch (KS_GROUP(ksym)) {
	case KS_GROUP_Ascii:
	case KS_GROUP_Keypad:
	case KS_GROUP_Function:
		res = ksym;
		break;

	case KS_GROUP_Mod:
		if (ksym == KS_Multi_key) {
			update_modifier(id, 1, 0, MOD_COMPOSE);
			id->t_composelen = 2;
		}
		break;

	case KS_GROUP_Dead:
		if (id->t_composelen == 0) {
			update_modifier(id, 1, 0, MOD_COMPOSE);
			id->t_composelen = 1;
			id->t_composebuf[0] = ksym;
		} else
			res = ksym;
		break;
	}

	if (res == KS_voidSymbol)
		return (0);

	if (id->t_composelen > 0) {
		/*
		 * If the compose key also serves as AltGr (i.e. set to both
		 * KS_Multi_key and KS_Mode_switch), and would provide a valid,
		 * distinct combination as AltGr, leave compose mode.
	 	 */
		if (id->t_composelen == 2 && group == &kp->group2[0]) {
			if (kp->group1[gindex] != kp->group2[gindex])
				id->t_composelen = 0;
		}

		if (id->t_composelen != 0) {
			id->t_composebuf[2 - id->t_composelen] = res;
			if (--id->t_composelen == 0) {
				res = wskbd_compose_value(id->t_composebuf);
				update_modifier(id, 0, 0, MOD_COMPOSE);
			} else {
				return (0);
			}
		}
	}

	/* We are done, return the symbol */
	if (KS_GROUP(res) == KS_GROUP_Ascii) {
		if (MOD_ONESET(id, MOD_ANYCONTROL)) {
			if ((res >= KS_at && res <= KS_z) || res == KS_space)
				res = res & 0x1f;
			else if (res == KS_2)
				res = 0x00;
			else if (res >= KS_3 && res <= KS_7)
				res = KS_Escape + (res - KS_3);
			else if (res == KS_8)
				res = KS_Delete;
		}
		if (MOD_ONESET(id, MOD_ANYMETA)) {
			if (id->t_flags & WSKFL_METAESC) {
				id->t_symbols[0] = KS_Escape;
				id->t_symbols[1] = res;
				return (2);
			} else
				res |= 0x80;
		}
	}

	id->t_symbols[0] = res;
	return (1);
}

void
wskbd_debugger(struct wskbd_softc *sc)
{
#ifdef DDB
	if (sc->sc_isconsole && db_console) {
		if (sc->id->t_consops->debugger != NULL) {
			(*sc->id->t_consops->debugger)
				(sc->id->t_consaccesscookie);
		} else
			db_enter();
	}
#endif
}
@


1.86
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.85 2017/03/11 11:55:03 mpi Exp $ */
d214 1
d1507 1
a1507 2
		if (sc->sc_isconsole && db_console)
			db_enter();
d1544 1
a1544 2
			if (sc->sc_isconsole && db_console)
				db_enter();
d1823 14
@


1.85
log
@Introduce a new knob to force the first USB keyboard as console input.

By setting "machdep.forceukbd=1" you can now use your USB keyboard in
ddb(4) even if your BIOS emulates a pckbd(4).

ok tom@@, kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.84 2016/09/30 12:05:46 kettenis Exp $ */
d1507 1
a1507 1
			Debugger();
d1545 1
a1545 1
				Debugger();
@


1.84
log
@Add a WSKBDIO_GETENCODINGS ioctl that returns the supported keyboard
encodings.

ok deraadt@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.83 2015/12/12 12:30:18 jung Exp $ */
d520 1
a520 1
void    
d535 1
d612 1
a612 1
		wskbd_console_device = NULL;
a1368 1

@


1.83
log
@add new ioctls to control keyboard backlights

tested by Bryan Vyhmeister, krw, tb, and myself

ok jcs krw tb
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.82 2015/09/10 18:14:52 mpi Exp $ */
d1004 1
d1008 1
d1163 14
@


1.82
log
@kqueue(2) support for wsmouse(4), wskbd(4) and wsmux(4).

Needed for libinput port.

ok guenther@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.81 2014/12/13 21:05:33 doug Exp $ */
d233 3
d1016 1
d1162 12
@


1.81
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.80 2014/07/12 18:48:53 tedu Exp $ */
d1196 10
@


1.80
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.79 2014/07/11 08:18:31 guenther Exp $ */
d1107 2
d1110 1
a1110 1
		buf = malloc(len, M_TEMP, M_WAITOK);
@


1.79
log
@It's init as a process that's special, not init's original thread.
Remember initprocess instead of initproc.

ok matthew@@ blambert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.78 2014/05/15 09:29:38 mpi Exp $ */
d627 1
a627 1
	free(sc->sc_map, M_DEVBUF);
d1119 1
a1119 1
		free(buf, M_TEMP);
@


1.78
log
@Use a more appropriate malloc(9) type than M_TEMP for the keymap memory
since it is only freed when your keyboard is detached.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.77 2014/05/05 21:25:00 mpi Exp $ */
d1508 1
a1508 1
			psignal(initproc, SIGUSR1);
@


1.77
log
@Plug a memory leak, free the keymap's memory on detach.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.76 2014/01/26 17:48:08 miod Exp $ */
d627 1
a627 1
	free(sc->sc_map, M_TEMP);
@


1.76
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.75 2013/11/04 11:57:26 mpi Exp $ */
d626 2
@


1.75
log
@Convert wskbd_set_mixervolume() to use a task internally instead of
being called in a workq.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.74 2013/10/18 22:06:42 miod Exp $ */
a124 2
	const struct wskbd_mapdata *t_keymap;

d139 3
a168 1
	kbd_t	sc_layout; /* current layout */
d310 2
d359 1
d361 1
d377 1
a377 1
	if (mux >= 0)
d379 3
d394 1
a394 2
		sc->id->t_keymap = ap->keymap;
		wskbd_update_layout(sc->id, ap->keymap->layout);
d409 30
a438 5
	if (wskbd_load_keymap(sc->id->t_keymap,
	    &sc->sc_map, &sc->sc_maplen) != 0)
		panic("cannot load keymap");

	sc->sc_layout = sc->id->t_keymap->layout;
d461 2
a462 2
	if (mux >= 0) {
		error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
d466 10
a494 1

d504 1
a504 1
	wskbd_console_data.t_keymap = mapdata;
d522 2
a523 1
	wskbd_console_data.t_keymap = 0;
d525 2
a526 2
	wskbd_console_data.t_consops = 0;
	wskbd_console_data.t_consaccesscookie = 0;
d554 1
a554 1
			    sc->id->t_keymap->layout,
d673 1
a673 1
				    sc->id->t_keymap->layout,
a998 1
	struct wskbd_mapdata md;
d1113 3
a1115 3
			sc->sc_layout = KB_USER |
			      (KB_VARIANT(sc->sc_layout) & KB_HANDLEDBYWSKBD);
			wskbd_update_layout(sc->id, sc->sc_layout);
d1129 1
a1129 1
		*((kbd_t *) data) = sc->sc_layout;
d1136 1
a1136 1
			if (KB_ENCODING(sc->sc_layout) != KB_USER)
d1142 2
a1143 4
			md = *(sc->id->t_keymap); /* structure assignment */
			md.layout = enc;
			error = wskbd_load_keymap(&md, &sc->sc_map,
						  &sc->sc_maplen);
d1145 1
a1145 1
				return(error);
a1146 1
		sc->sc_layout = enc;
d1148 5
d1573 1
a1573 1
		wskbd_get_mapentry(id->t_keymap, value, kp);
@


1.74
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.73 2013/10/18 13:54:09 miod Exp $ */
a97 1
#include <sys/workq.h>
d300 1
a300 1
extern int wskbd_set_mixervolume(long dir, int out);
d1646 1
a1646 2
			workq_add_task(NULL, 0, (workq_fn)wskbd_set_mixervolume,
			    (void *)(long)0, (void *)(int)1);
d1649 1
a1649 2
			workq_add_task(NULL, 0, (workq_fn)wskbd_set_mixervolume,
			    (void *)(long)-1, (void*)(int)1);
d1652 1
a1652 2
			workq_add_task(NULL, 0, (workq_fn)wskbd_set_mixervolume,
			    (void *)(long)1, (void*)(int)1);
@


1.73
log
@Introduce a dedicated private header file to control the optional features
of wscons (which usually get disabled for installation kernels, to save
space), instead of duplicating parts of it to too many places.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.72 2013/01/06 18:07:07 ratchov Exp $ */
d514 1
d633 1
@


1.72
log
@don't propagate XF86XK_Audio{Lower,Raise}Volume keys to userspace,
otherwise volume may be adjusted twice: once by X apps and once in
the kernel.

feedback from many, ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.71 2012/10/17 00:48:23 jsg Exp $ */
d102 1
a115 5
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#endif

d617 1
a617 1
#ifdef BURNER_SUPPORT
d624 1
a624 1
#ifdef SCROLLBACK_SUPPORT
d1387 1
a1387 1
#ifdef SCROLLBACK_SUPPORT
@


1.71
log
@#if NWSDISPLAY > 0 not #if WSDISPLAY > 0
ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.70 2011/11/09 14:27:52 shadchin Exp $ */
d1651 1
a1651 1
			break;
d1655 1
a1655 1
			break;
@


1.70
log
@If directly open /dev/wskbdX, then wskbdX be removed from mux wskbd,
but if close wskbdX, wskbdX not returned to mux. Fix it.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.69 2011/06/24 19:47:49 naddy Exp $ */
d443 1
a443 1
#if WSDISPLAY > 0 && NWSMUX == 0
@


1.69
log
@machdep.kbdreset enables a shutdown by Ctrl-Alt-Del on amd64 and
i386.  Stop abusing it on other archs for controling a shutdown by
pressing the soft power button:

* Add a MI sysctl hw.allowpowerdown; if set to 1 (the default) it
  allows a power button shutdown.
* Make acpi(4)/acpibtn(4) honor hw.allowpowerdown.
* Switch the various power button intercepts on landisk, sgi, sparc64
  and zaurus over to hw.allowpowerdown.
* Garbage collect the machdep.kbdreset sysctl on all archs other than
  amd64 and i386.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.68 2011/06/23 16:31:16 deraadt Exp $ */
d827 15
@


1.68
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.67 2011/06/06 06:13:46 deraadt Exp $ */
d247 1
d249 1
@


1.67
log
@Microphone mute button support from acpithinkpad (or elsewhere).
The audio side is a bit lacking; it does not yet mute all types of
devices.
from Alexander Polakov
ok jakemsr
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.66 2011/04/14 19:25:54 shadchin Exp $ */
d481 1
a481 1
wskbd_cndetach()
d1141 1
a1141 1
wskbd_pickfree()
@


1.66
log
@Reducing number of call update_leds().
Updating state LED only when necessary.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.65 2011/04/13 18:16:33 shadchin Exp $ */
d303 1
a303 1
extern int wskbd_set_mixervolume(long dir);
d1633 1
a1633 1
			    (void *)(long)0, NULL);
d1637 1
a1637 1
			    (void *)(long)-1, NULL);
d1641 1
a1641 1
			    (void *)(long)1, NULL);
@


1.65
log
@wskbd_holdscreen() is not needed and can be removed

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.64 2010/11/20 20:52:11 miod Exp $ */
d199 2
d1324 2
a1502 1
		update_leds(id);
d1601 1
a1601 2
	if (type != WSCONS_EVENT_KEY_DOWN || iscommand) {
		update_leds(id);
a1602 1
	}
d1676 1
a1676 2
	if (res == KS_voidSymbol) {
		update_leds(id);
a1677 1
	}
a1699 2

	update_leds(id);
@


1.64
log
@Change wsdisplay_kbdinput() to get an aray of keysym_t and a count, instead of
a single keysym_t at a time - this means tty sanity checks will only happen
once.

Introduce wsdisplay_rawkbdinput() for raw mode input, since raw input is
a byte array. As a bonus this allows us to skip the `is this a KS_GROUP_Ascii
value' test in that case.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.63 2010/11/20 20:47:38 miod Exp $ */
a218 1
void	wskbd_holdscreen(struct wskbd_softc *, int);
a711 22
#if NWSDISPLAY > 0
void
wskbd_holdscreen(struct wskbd_softc *sc, int hold)
{
	int new_state;

	if (sc->sc_displaydv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_displaydv, hold);
		new_state = sc->sc_ledstate;
		if (hold)
			new_state |= WSKBD_LED_SCROLL;
		else
			new_state &= ~WSKBD_LED_SCROLL;
		if (new_state != sc->sc_ledstate) {
			(*sc->sc_accessops->set_leds)(sc->sc_accesscookie,
						      new_state);
			sc->sc_ledstate = new_state;
		}
	}
}
#endif

d1572 3
a1574 1
			wskbd_holdscreen(sc, id->t_modifiers & MOD_HOLDSCREEN);
@


1.63
log
@Replace all mentions of sc_base.me_dispdv with sc_displaydv. The latter is a
short #define for the former, and seeing both forms in this file is confusing.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.62 2010/07/26 01:56:27 guenther Exp $ */
d503 1
a503 1
	if (!sc->sc_repeating) {
d513 3
a515 6
		if (sc->sc_displaydv != NULL) {
			int i;
			for (i = 0; i < sc->sc_repeating; i++)
				wsdisplay_kbdinput(sc->sc_displaydv,
				    sc->id->t_symbols[i]);
		}
d604 1
a604 1
	int num, i;
d632 2
a633 4
				for (i = 0; i < num; i++) {
					wsdisplay_kbdinput(sc->sc_displaydv,
					    sc->id->t_symbols[i]);
				}
a705 1
	int i;
d708 1
a708 3
		for (i = 0; i < len; i++)
			wsdisplay_kbdinput(sc->sc_displaydv, buf[i]);
	/* this is KS_GROUP_Ascii */
@


1.62
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.61 2009/10/13 19:33:19 pirofti Exp $ */
d424 1
a424 1
		wsdisplay_set_console_kbd(&sc->sc_base); /* sets me_dispdv */
d513 1
a513 1
		if (sc->sc_base.me_dispdv != NULL) {
d516 1
a516 1
				wsdisplay_kbdinput(sc->sc_base.me_dispdv,
d627 1
a627 1
			if (sc->sc_base.me_dispdv != NULL) {
d631 1
a631 1
					wsscrollback(sc->sc_base.me_dispdv,
d636 1
a636 1
					wsdisplay_kbdinput(sc->sc_base.me_dispdv,
d713 1
a713 1
	if (sc->sc_base.me_dispdv != NULL)
d715 1
a715 1
			wsdisplay_kbdinput(sc->sc_base.me_dispdv, buf[i]);
d727 2
a728 2
	if (sc->sc_base.me_dispdv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_base.me_dispdv, hold);
d749 1
a749 1
	if (sc->sc_base.me_dispdv != NULL)
d1191 1
a1191 1
	sc->sc_base.me_dispdv = displaydv;
d1206 1
a1206 1
		 dv->dv_xname, sc->sc_base.me_dispdv, displaydv, 
d1213 1
a1213 1
		if (sc->sc_base.me_dispdv != NULL)
d1216 1
a1216 1
		if (sc->sc_base.me_dispdv == NULL)
d1220 2
a1221 2
	odisplaydv = sc->sc_base.me_dispdv;
	sc->sc_base.me_dispdv = NULL;
d1223 1
a1223 1
	sc->sc_base.me_dispdv = displaydv;
d1225 1
a1225 1
		sc->sc_base.me_dispdv = odisplaydv;
d1364 1
a1364 1
	res = wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_GETPARAM, &dp);
d1375 1
a1375 1
	wsdisplay_param(sc->sc_base.me_dispdv, WSDISPLAYIO_SETPARAM, &dp);
d1440 1
a1440 1
	if (sc->sc_base.me_dispdv == NULL)
@


1.61
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.60 2009/01/21 21:54:00 grange Exp $ */
d818 1
a818 1
	evar->io = p;
d940 2
a941 2
		if (-*(int *)data != sc->sc_base.me_evp->io->p_pgid &&
		    *(int *)data != sc->sc_base.me_evp->io->p_pid)
d948 1
a948 1
		if (*(int *)data != sc->sc_base.me_evp->io->p_pgid)
@


1.60
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.59 2008/12/21 20:16:35 dlg Exp $ */
d208 1
a208 1
int	wskbd_activate(struct device *, enum devact);
d531 1
a531 1
wskbd_activate(struct device *self, enum devact act)
@


1.59
log
@on i386 and amd64, let ctrl-alt-delete let you enter ddb if ddb.console=1
and machdep.kbdreset=2.

"i like it" deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.57 2007/09/10 19:49:31 gilles Exp $ */
d525 1
a525 2
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.delN) / 1000);
d643 2
a644 2
				timeout_add(&sc->sc_repeat_ch,
				    (hz * sc->sc_keyrepeat_data.del1) / 1000);
d659 1
a659 2
		timeout_add(&sc->sc_repeat_ch,
		    (hz * sc->sc_keyrepeat_data.del1) / 1000);
@


1.58
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1468 10
a1477 1
		if (kbd_reset == 1) {
d1480 3
@


1.57
log
@more MALLOC/FREE -> malloc/free and M_ZERO changes

ok pyr@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.56 2007/06/02 07:19:28 tedu Exp $ */
d388 1
a388 1
		    M_DEVBUF, M_WAITOK|M_ZERO);
@


1.56
log
@little fixes to get hotkeys working again.  from alexey vatchenko
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.55 2007/05/31 22:23:13 tedu Exp $ */
d388 1
a388 2
		    M_DEVBUF, M_WAITOK);
		bzero(sc->id, sizeof(struct wskbd_internal));
@


1.55
log
@switch wskbd hotkeys over to workq.  this eliminates quite a bit of code,
so remove the option too.  if you have audio and wskbd, you have hotkeys.
ok dlg
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.54 2007/03/25 18:04:14 tedu Exp $ */
d1652 1
a1652 1
			    (void *)(u_long)0, NULL);
d1656 1
a1656 1
			    (void *)(u_long)1, NULL);
d1660 1
a1660 1
			    (void *)(u_long)1, NULL);
@


1.54
log
@POLLERR is the correct return code for poll errors
ok art deraadt miod
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.53 2006/08/14 17:41:08 miod Exp $ */
d98 1
d115 1
a115 4
#ifdef	SMALL_KERNEL
#undef	NWSKBD_HOTKEY
#define	NWSKBD_HOTKEY 0
#else
d301 4
a457 3
#if NWSKBD_HOTKEY > 0
	wskbd_hotkey_init();
#endif
a1645 1
#if NWSKBD_HOTKEY > 0
d1651 3
d1655 3
d1659 2
a1660 1
			wskbd_hotkey_put(ksym);
a1666 1
#endif
@


1.53
log
@Really do what I intended on SMALL_KERNEL configurations.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.51 2006/08/06 11:36:35 miod Exp $ */
d97 1
d1167 1
a1167 1
		return (EINVAL);
@


1.52
log
@Add an attribute to the keyboard devices which can produce the keys the
wskbd hotkey thread knows about, and make this code conditional on this
attribute. No functional change, simply smaller kernels on a few platforms.
@
text
@d113 4
a116 1
#ifndef	SMALL_KERNEL
a118 2
#undef	NWSKBD_HOTKEY
#define	NWSKBD_HOTKEY 0
@


1.51
log
@Do not try and mate wskbd0 and wsdisplay0 if there is now wsdisplay in the
kernel; spotted by kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.50 2006/08/05 16:59:57 miod Exp $ */
a81 6
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#define	HOTKEY_SUPPORT
#endif

d110 1
d113 7
d454 1
a454 1
#ifdef HOTKEY_SUPPORT
d1645 1
a1645 1
#ifdef HOTKEY_SUPPORT
@


1.50
log
@On platforms which do not use wsmux (because they can't have more than one
keyboard at once), force wskbd0 to connect to wsdisplay0 even if they are
not console devices.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.49 2006/08/01 23:36:52 miod Exp $ */
d435 1
a435 1
#if NWSMUX == 0
@


1.49
log
@Avoid a few NULL dereferences, and boot -c works on vax with glass console.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.48 2006/07/31 21:54:46 miod Exp $ */
a208 5
#if NWSDISPLAY > 0
int	wskbd_set_display(struct device *, struct wsevsrc *);
#else
#define	wskbd_set_display NULL
#endif
d280 6
a285 1
	wskbd_displayioctl, wskbd_set_display
d435 17
d1199 1
a1199 1
wskbd_set_display(struct device *dv, struct wsevsrc *me)
a1201 1
	struct device *displaydv = me != NULL ? me->me_dispdv : NULL;
d1205 2
a1206 2
	DPRINTF(("wskbd_set_display: %s me=%p odisp=%p disp=%p cons=%d\n",
		 dv->dv_xname, me, sc->sc_base.me_dispdv, displaydv, 
@


1.48
log
@Kill autorepeat on ``all keys up'' event.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.47 2006/05/29 20:23:13 miod Exp $ */
d1492 1
a1492 1
		if (sc->sc_repeating) {
@


1.47
log
@Add support for the audio volume keys found on many laptops' builtin
keyboard. These specific keys are posted to a kernel thread which will
issue mixer commands if an audio device exists.

Written by Alexey Vatchenko <avv , mail zp ua> with tweaks by deraadt@@ and I.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.46 2005/08/14 11:00:15 miod Exp $ */
d1491 6
@


1.46
log
@Honor (the lack of) FWRITE in the various ioctl routines; with input from
fgs@@ and mickey@@; ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.45 2005/07/08 02:26:07 marc Exp $ */
d85 1
d114 1
d434 4
d1620 17
@


1.45
log
@ Fix mismatched brace and compile when NWSMUX and NWSDISPLAY not defined.
OK uwe@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.44 2005/06/02 07:31:17 miod Exp $ */
d956 12
a979 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a983 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a989 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1025 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1052 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
a1084 2
		if ((flag & FWRITE) == 0)
			return (EACCES);
@


1.44
log
@Do not compile scrollback support if option SMALL_KERNEL.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.43 2005/05/18 21:31:27 miod Exp $ */
a122 1
#if NWSMUX > 0 || NWSDISPLAY > 0
a123 1
#endif
d1471 1
a1472 1
	}
@


1.43
log
@Do not compile the screen burner code if SMALL_KERNEL, helps floppies.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.42 2005/05/15 11:29:15 miod Exp $ */
d84 1
d606 1
d612 1
d1381 1
d1402 1
@


1.42
log
@Partial sync to the NetBSD wscons code, bringing a better wsmux behaviour
and bugfixes (the kqueue code, /dev/wsmuxctl and screen border color changes
have not been picked), keeping local changes.

Tested by many on alpha/cats/hp300/i386/macppc/sparc/sparc64/zaurus if not more.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.41 2004/06/24 19:35:24 tholo Exp $ */
d82 4
d598 1
d601 1
@


1.41
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 2
a2 2
/* $OpenBSD: wskbd.c,v 1.40 2004/04/05 06:22:07 miod Exp $ */
/* $NetBSD: wskbd.c,v 1.38 2000/03/23 07:01:47 thorpej Exp $ */
a36 2
#include <sys/cdefs.h>

d104 1
a106 1
#include <dev/wscons/wsdisplayvar.h>
d132 1
a132 1
	int t_flags;
d142 1
a142 1
	struct device	sc_dv;
a150 2
	struct wseventvar sc_events;	/* event queue state */

a151 3
#if NWSDISPLAY > 0
	struct device	*sc_displaydv;
#endif
d159 2
d166 1
a166 1
	kbd_t sc_layout; /* current layout */
d168 2
a169 6
	int		sc_refcnt;
	u_char		sc_dying;	/* device is being detached */

#if NWSMUX > 0 || NWSDISPLAY > 0
	struct wsmux_softc *sc_mux;
#endif
a192 1
	/* these should result in precise 0 or 1, see wskbd_translate() XXX */
d203 31
a233 20
int wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *p);
int	wskbd_set_display(struct device *, struct wsmux_softc *);
int	wskbd_isset_display(struct device *);

inline void update_leds(struct wskbd_internal *);
inline void update_modifier(struct wskbd_internal *, u_int, int, int);
int internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int wskbd_translate(struct wskbd_internal *, u_int, int);
int wskbd_enable(struct wskbd_softc *, int);
#if NWSDISPLAY > 0
void change_displayparam(struct wskbd_softc *, int, int, int);
void wskbd_holdscreen(struct wskbd_softc *, int);
#endif

int	wskbd_do_ioctl(struct wskbd_softc *, u_long, caddr_t, 
			    int, struct proc *);

int	wskbddoclose(struct device *, int, int, struct proc *);
int	wskbddoioctl(struct device *, u_long, caddr_t, int, 
			  struct proc *);
a243 2
extern struct cfdriver wskbd_cd;

d277 4
a280 3
struct wsmuxops wskbd_muxops = {
	wskbdopen, wskbddoclose, wskbddoioctl, wskbd_displayioctl,
	wskbd_set_display, wskbd_isset_display
d292 1
a292 1
void wskbd_update_layout(struct wskbd_internal *, kbd_t);
d295 1
a295 3
wskbd_update_layout(id, enc)
	struct wskbd_internal *id;
	kbd_t enc;
a296 1

d307 1
a307 3
wskbddevprint(aux, pnp)
	void *aux;
	const char *pnp;
d323 1
a323 4
wskbd_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d344 1
a344 3
wskbd_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d348 2
a349 2
#if NWSMUX > 0 || NWSDISPLAY > 0
	int mux;
a351 3
#if NWSDISPLAY > 0
	sc->sc_displaydv = NULL;
#endif
d355 8
a362 4
	mux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;
	if (sc->sc_isconsole && mux != WSKBDDEVCF_MUX_DEFAULT) {
		printf(" (mux %d ignored for console)", mux);
		mux = WSKBDDEVCF_MUX_DEFAULT;
d364 1
a364 1
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
d366 4
d371 1
d377 1
a377 1
				M_DEVBUF, M_WAITOK);
a390 1
	sc->sc_events.io = NULL;			/* sanity */
d396 1
a396 1
			      &sc->sc_map, &sc->sc_maplen) != 0)
d414 2
a415 1
		if ((sc->sc_displaydv = wsdisplay_set_console_kbd(self)))
d422 5
a426 4
	if (mux != WSKBDDEVCF_MUX_DEFAULT) {
		wsmux_attach(mux, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
			     &sc->sc_mux, &wskbd_muxops);
		wsdisplay_set_console_kbd(self);
a428 1

d432 2
a433 4
wskbd_cnattach(consops, conscookie, mapdata)
	const struct wskbd_consops *consops;
	void *conscookie;
	const struct wskbd_mapdata *mapdata;
d470 1
a470 2
wskbd_repeat(v)
	void *v;
d483 16
a498 8
	if (sc->sc_displaydv != NULL) {
		int i;
		for (i = 0; i < sc->sc_repeating; i++)
			wsdisplay_kbdinput(sc->sc_displaydv,
					   sc->id->t_symbols[i]);
	}
	timeout_add(&sc->sc_repeat_ch,
	    (hz * sc->sc_keyrepeat_data.delN) / 1000);
d504 1
a504 3
wskbd_activate(self, act)
	struct device *self;
	enum devact act;
d506 4
a509 1
	/* XXX should we do something more? */
d522 1
a522 3
wskbd_detach(self, flags)
	struct device  *self;
	int flags;
a527 5
#if NWSMUX > 0
	int mux;
#endif

	sc->sc_dying = 1;
d530 3
a532 3
	mux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
		wsmux_detach(mux, &sc->sc_dv);
d547 2
a548 2
	evar = &sc->sc_events;
	if (evar->io) {
d558 1
a558 1
				       sc->sc_dv.dv_xname);
d576 1
a576 4
wskbd_input(dev, type, value)
	struct device *dev;
	u_int type;
	int value;
a578 2
	struct wscons_event *ev;
	struct wseventvar *evar;
a581 1
	int put;
d584 5
d590 1
a590 1
	 * If /dev/wskbd is not connected in event mode translate and
d598 1
a598 1
			if (sc->sc_displaydv != NULL) {
d601 1
a601 1
					wsscrollback(sc->sc_displaydv,
d605 1
a605 1
					wsdisplay_kbdinput(sc->sc_displaydv,
d610 5
a614 3
			sc->sc_repeating = num;
			timeout_add(&sc->sc_repeat_ch,
			    (hz * sc->sc_keyrepeat_data.del1) / 1000);
d620 27
a646 5
	/*
	 * Keyboard is generating events.  Turn this keystroke into an
	 * event and put it in the queue.  If the queue is full, the
	 * keystroke is lost (sorry!).
	 */
d648 2
a649 2
	/* no one to receive; punt!*/
	if (sc->sc_events.io == NULL)
d651 1
d653 5
a657 4
#if NWSMUX > 0
	if (sc->sc_mux)
		evar = &sc->sc_mux->sc_events;
	else
a658 1
		evar = &sc->sc_events;
d665 1
a665 1
		    sc->sc_dv.dv_xname);
d677 1
a677 4
wskbd_rawinput(dev, buf, len)
	struct device *dev;
	u_char *buf;
	int len;
d683 3
a685 2
	for (i = 0; i < len; i++)
		wsdisplay_kbdinput(sc->sc_displaydv, buf[i]);
d693 1
a693 3
wskbd_holdscreen(sc, hold)
	struct wskbd_softc *sc;
	int hold;
d697 2
a698 2
	if (sc->sc_displaydv != NULL) {
		wsdisplay_kbdholdscreen(sc->sc_displaydv, hold);
d714 1
a714 3
wskbd_enable(sc, on)
	struct wskbd_softc *sc;
	int on;
d716 1
a716 1
	int res;
a717 2
	/* XXX reference count? */
	if (!on && (!sc->sc_translating
d719 8
a726 1
		    || sc->sc_displaydv
d728 16
a743 1
		))
d746 1
a746 2
	res = (*sc->sc_accessops->enable)(sc->sc_accesscookie, on);
	return (res);
d748 1
d751 1
a751 4
wskbdopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d754 2
a755 1
	int unit;
d762 5
d770 1
a770 1
	if (!(flags & FREAD)) {
d776 5
a780 2
	if (sc->sc_mux)
		return (EBUSY);
d783 1
a783 1
	if (sc->sc_events.io)			/* and that it's not in use */
d786 3
a788 2
	sc->sc_events.io = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */
d790 8
a797 4
	sc->sc_translating = 0;

	wskbd_enable(sc, 1);
	return (0);
d801 1
a801 4
wskbdclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d803 4
a806 1
	return (wskbddoclose(wskbd_cd.cd_devs[minor(dev)], flags, mode, p));
d810 1
a810 4
wskbddoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
d812 3
a814 1
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;
d816 2
a817 2
	if (!(flags & FREAD)) {
		/* Nothing to do, because open didn't do anything. */
a818 1
	}
d820 1
d822 2
d825 12
a836 2
	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;
a837 1
	wskbd_enable(sc, 0);
d840 1
d843 1
a843 4
wskbdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d851 7
d859 1
a859 1
	error = wsevent_read(&sc->sc_events, uio, flags);
d868 1
a868 6
wskbdioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d870 1
a870 1
	return (wskbddoioctl(wskbd_cd.cd_devs[minor(dev)], cmd, data, flag,p));
d875 2
a876 6
wskbddoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d882 1
a882 1
	error = wskbd_do_ioctl(sc, cmd, data, flag, p);
d889 2
a890 6
wskbd_do_ioctl(sc, cmd, data, flag, p)
	struct wskbd_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d902 3
a904 1
		sc->sc_events.async = *(int *)data != 0;
d907 8
d916 3
a918 1
		if (*(int *)data != sc->sc_events.io->p_pgid)
d927 1
a927 1
	error = wskbd_displayioctl((struct device *)sc, cmd, data, flag, p);
d936 2
a937 6
wskbd_displayioctl(dev, cmd, data, flag, p)
	struct device *dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
a1017 5
		if ((ukdp->which & WSKBD_KEYREPEAT_DODEL1 &&
		     (hz * ukdp->del1) / 1000 <= 0) ||
		    (ukdp->which & WSKBD_KEYREPEAT_DODELN &&
		     (hz * ukdp->delN) / 1000 <= 0))
			return (EINVAL);
d1047 2
a1048 1
		len = umdp->maplen*sizeof(struct wscons_keymap);
d1088 5
a1092 5
				md.layout = enc;
				error = wskbd_load_keymap(&md, &sc->sc_map,
							  &sc->sc_maplen);
				if (error)
			return(error);
d1128 1
a1128 4
wskbdpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1132 3
a1134 1
	return (wsevent_poll(&sc->sc_events, events, p));
d1154 2
a1155 4
struct device *
wskbd_set_console_display(displaydv, muxsc)
	struct device *displaydv;
	struct wsmux_softc *muxsc;
d1159 7
a1165 6
	if (!sc)
		return (0);
	sc->sc_displaydv = displaydv;
	(void)wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
			      &sc->sc_mux, &wskbd_muxops);
	return (&sc->sc_dv);
d1169 1
a1169 3
wskbd_set_display(dv, muxsc)
	struct device *dv;
	struct wsmux_softc *muxsc;
d1172 1
a1172 1
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;
d1176 2
a1177 2
	DPRINTF(("wskbd_set_display: %s mux=%p disp=%p odisp=%p cons=%d\n",
		 dv->dv_xname, muxsc, sc->sc_displaydv, displaydv, 
d1183 2
a1184 2
	if (displaydv) {
		if (sc->sc_displaydv)
d1187 1
a1187 1
		if (sc->sc_displaydv == NULL)
d1191 2
a1192 3
	odisplaydv = sc->sc_displaydv;
	sc->sc_displaydv = displaydv;

d1194 1
d1196 1
a1196 1
		sc->sc_displaydv = odisplaydv;
d1202 1
a1202 1
		       sc->sc_dv.dv_xname, displaydv->dv_xname);
d1205 1
a1205 1
		       sc->sc_dv.dv_xname, odisplaydv->dv_xname);
d1210 1
a1210 11
int
wskbd_isset_display(dv)
	struct device *dv;
{
	struct wskbd_softc *sc = (struct wskbd_softc *)dv;

	if (sc->sc_displaydv != NULL)
		return (1);

	return (0);
}
d1212 1
d1214 1
a1214 3
wskbd_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
a1217 2
	DPRINTF(("wskbd_add_mux: %d %s %p\n", unit, muxsc->sc_dv.dv_xname,
		 muxsc->sc_displaydv));
d1222 1
a1222 1
	if (sc->sc_mux || sc->sc_events.io)
d1225 1
a1225 2
	return (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wskbd_muxops));
d1227 1
a1227 17

int
wskbd_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
{
	struct wskbd_softc *sc;

	DPRINTF(("wskbd_rem_mux: %d %s\n", unit, muxsc->sc_dv.dv_xname));
	if (unit < 0 || unit >= wskbd_cd.cd_ndevs ||
	    (sc = wskbd_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
}

#endif /* NWSDISPLAY > 0 */
d1233 1
a1233 2
wskbd_cngetc(dev)
	dev_t dev;
d1251 2
a1252 1
			return (KS_VALUE(ks));	
d1264 1
a1264 3
wskbd_cnpollc(dev, poll)
	dev_t dev;
	int poll;
d1279 1
a1279 3
wskbd_cnbell(dev, pitch, period, volume)
	dev_t dev;
	u_int pitch, period, volume;
d1290 2
a1291 3
inline void
update_leds(id)
	struct wskbd_internal *id;
d1312 2
a1313 6
inline void
update_modifier(id, type, toggle, mask)
	struct wskbd_internal *id;
	u_int type;
	int toggle;
	int mask;
d1328 2
a1329 3
change_displayparam(sc, param, updown, wraparound)
	struct wskbd_softc *sc;
	int param, updown, wraparound;
a1333 3
	if (sc->sc_displaydv == NULL)
		return;

d1335 1
a1335 1
	res = wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_GETPARAM, &dp);
d1346 1
a1346 1
	wsdisplay_param(sc->sc_displaydv, WSDISPLAYIO_SETPARAM, &dp);
d1351 2
a1352 4
internal_command(sc, type, ksym, ksym2)
	struct wskbd_softc *sc;
	u_int *type;
	keysym_t ksym, ksym2;
a1397 1
	switch (ksym) {
d1399 1
a1399 1
	case KS_Cmd_Debugger:
d1405 1
d1409 4
d1425 1
a1425 3
		if (sc->sc_displaydv != NULL)
			wsdisplay_switch(sc->sc_displaydv,
			    ksym - KS_Cmd_Screen0, 0);
d1428 1
a1428 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1431 1
a1431 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
d1445 2
a1446 2
				    ksym == KS_Cmd_BacklightOff ? -1 : 1,
				    ksym == KS_Cmd_BacklightToggle ? 1 : 0);
d1452 2
a1453 2
				    ksym == KS_Cmd_BrightnessDown ? -1 : 1,
				    ksym == KS_Cmd_BrightnessRotate ? 1 : 0);
d1459 2
a1460 2
				    ksym == KS_Cmd_ContrastDown ? -1 : 1,
				    ksym == KS_Cmd_ContrastRotate ? 1 : 0);
d1468 1
a1468 4
wskbd_translate(id, type, value)
	struct wskbd_internal *id;
	u_int type;
	int value;
d1476 5
a1480 5
		id->t_modifiers &= ~(MOD_SHIFT_L | MOD_SHIFT_R
				| MOD_CONTROL_L | MOD_CONTROL_R
				| MOD_META_L | MOD_META_R
				| MOD_MODESHIFT | MOD_MODELOCK
				| MOD_COMMAND | MOD_COMMAND1 | MOD_COMMAND2);
d1502 1
a1502 1
					     kp->group1[0]);
d1562 2
a1563 1
				return (0);
d1680 1
a1680 1
			res |= 0x80;
@


1.40
log
@Most of the non-US keyboard layouts define an ``AltGr'' key to access up
to two extra symbols per key; usually, this key also serves as the compose
key, if used with shift.

Because of this, accessing the fourth symbol of a key would work with a
sequence altgr-shift-key, but not with a sequence shift-altgr-key, since
it would trigger compose behaviour.

In order to be less confusing, let the AltGr behaviour win over the Compose
behaviour if AltGr would produce a different symbol. Since most of those
AltGr symbols are never part of compose rules, this is transparent.

Problem found by xsa@@; ok deraadt@@ otto@@ xsa@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.39 2004/03/14 11:13:04 miod Exp $ */
a588 1
	struct timeval xxxtime;
d651 1
a651 2
	microtime(&xxxtime);
	TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


1.39
log
@Caps lock should only affect the letter keys, rather than enforcing a shift
state. Fixes PR#2555
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.38 2004/02/27 22:09:47 deraadt Exp $ */
d1477 1
a1477 1
	int iscommand = 0;
d1594 4
a1597 3
	    KS_GROUP(group[1]) == KS_GROUP_Keypad)
		ksym = group[!MOD_ONESET(id, MOD_ANYSHIFT)];
	else {
d1601 1
d1603 4
a1606 2
		} else
			ksym = group[MOD_ONESET(id, MOD_ANYSHIFT)];
d1642 18
a1659 6
		id->t_composebuf[2 - id->t_composelen] = res;
		if (--id->t_composelen == 0) {
			res = wskbd_compose_value(id->t_composebuf);
			update_modifier(id, 0, 0, MOD_COMPOSE);
		} else {
			return (0);
@


1.38
log
@kbd_reset can work on amd64 too
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.37 2003/09/23 16:51:12 millert Exp $ */
d206 2
d1596 8
a1603 2
	else
		ksym = group[MOD_ONESET(id, MOD_CAPSLOCK|MOD_ANYSHIFT)];
@


1.37
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.36 2003/08/15 20:32:18 tedu Exp $ */
d1432 1
a1432 1
#ifdef __i386__
@


1.36
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.35 2003/06/02 23:28:04 millert Exp $ */
d1078 1
a1078 1
wskbdselect(dev, events, p)
@


1.35
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.34 2002/12/23 11:37:31 miod Exp $ */
d937 1
a937 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
d980 1
a980 1
		if ((error = suser(p->p_ucred, &p->p_acflag)) != 0)
@


1.34
log
@Repair minor indentation problem.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.33 2002/05/20 23:29:39 miod Exp $ */
d60 1
a60 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.33
log
@Do not blindly call wsdisplay routines if no wsdisplay device is active
and the user presses a magic key.
ok mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.32 2002/04/30 23:01:55 mickey Exp $ */
d1041 7
a1047 7
		md = *(sc->id->t_keymap); /* structure assignment */
			md.layout = enc;
			error = wskbd_load_keymap(&md, &sc->sc_map,
						  &sc->sc_maplen);
			if (error)
		return(error);
	}
@


1.32
log
@cdev_decl is done in conf.h, do not dupe here
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.31 2002/04/05 16:34:38 jason Exp $ */
d1424 3
a1426 1
		wsdisplay_switch(sc->sc_displaydv, ksym - KS_Cmd_Screen0, 0);
d1429 2
a1430 1
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1433 2
a1434 1
		wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
@


1.31
log
@protect another use of wskbd_repeat with #if NWSDISPLAY > 0
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.30 2002/03/30 23:00:01 mickey Exp $ */
a277 2

cdev_decl(wskbd);
@


1.30
log
@fix two evil bugs:
panic on absent wsdiplay on scrollback;
missing breaks.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.29 2002/03/14 01:27:03 millert Exp $ */
d391 1
d393 1
@


1.29
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.28 2001/10/30 05:15:37 mickey Exp $ */
d1379 3
a1381 2
			wsscrollback(sc->sc_displaydv,
			    WSDISPLAY_SCROLL_BACKWARD);
d1384 1
d1388 3
a1390 2
			wsscrollback(sc->sc_displaydv,
			    WSDISPLAY_SCROLL_FORWARD);
d1393 1
@


1.28
log
@do not allow setting autorepeat delays causing zero timeouts later.
pointed out for the case of del*=0 in pr@@2156 by
Juan Vera <juan@@coredump.com.ar>.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.27 2001/10/25 14:30:43 drahn Exp $ */
d210 14
a223 15
int	wskbd_match __P((struct device *, void *, void *));
void	wskbd_attach __P((struct device *, struct device *, void *));
int	wskbd_detach __P((struct device *, int));
int	wskbd_activate __P((struct device *, enum devact));

int wskbd_displayioctl
	    __P((struct device *, u_long, caddr_t, int, struct proc *p));
int	wskbd_set_display __P((struct device *, struct wsmux_softc *));
int	wskbd_isset_display __P((struct device *));

inline void update_leds __P((struct wskbd_internal *));
inline void update_modifier __P((struct wskbd_internal *, u_int, int, int));
int internal_command __P((struct wskbd_softc *, u_int *, keysym_t, keysym_t));
int wskbd_translate __P((struct wskbd_internal *, u_int, int));
int wskbd_enable __P((struct wskbd_softc *, int));
d225 2
a226 2
void change_displayparam __P((struct wskbd_softc *, int, int, int));
void wskbd_holdscreen __P((struct wskbd_softc *, int));
d229 2
a230 2
int	wskbd_do_ioctl __P((struct wskbd_softc *, u_long, caddr_t, 
			    int, struct proc *));
d232 3
a234 3
int	wskbddoclose __P((struct device *, int, int, struct proc *));
int	wskbddoioctl __P((struct device *, u_long, caddr_t, int, 
			  struct proc *));
d289 1
a289 1
void wskbd_repeat __P((void *v));
d296 1
a296 1
void wskbd_update_layout __P((struct wskbd_internal *, kbd_t));
@


1.28.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.28 2001/10/30 05:15:37 mickey Exp $ */
d210 15
a224 14
int	wskbd_match(struct device *, void *, void *);
void	wskbd_attach(struct device *, struct device *, void *);
int	wskbd_detach(struct device *, int);
int	wskbd_activate(struct device *, enum devact);

int wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *p);
int	wskbd_set_display(struct device *, struct wsmux_softc *);
int	wskbd_isset_display(struct device *);

inline void update_leds(struct wskbd_internal *);
inline void update_modifier(struct wskbd_internal *, u_int, int, int);
int internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int wskbd_translate(struct wskbd_internal *, u_int, int);
int wskbd_enable(struct wskbd_softc *, int);
d226 2
a227 2
void change_displayparam(struct wskbd_softc *, int, int, int);
void wskbd_holdscreen(struct wskbd_softc *, int);
d230 2
a231 2
int	wskbd_do_ioctl(struct wskbd_softc *, u_long, caddr_t, 
			    int, struct proc *);
d233 3
a235 3
int	wskbddoclose(struct device *, int, int, struct proc *);
int	wskbddoioctl(struct device *, u_long, caddr_t, int, 
			  struct proc *);
d280 2
d290 1
a290 1
void wskbd_repeat(void *v);
d297 1
a297 1
void wskbd_update_layout(struct wskbd_internal *, kbd_t);
a391 1
#if NWSDISPLAY > 0
a392 1
#endif
d1380 2
a1381 3
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_BACKWARD);
a1383 1
		break;
d1387 2
a1388 3
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_FORWARD);
a1390 1
		break;
d1421 1
a1421 3
		if (sc->sc_displaydv != NULL)
			wsdisplay_switch(sc->sc_displaydv,
			    ksym - KS_Cmd_Screen0, 0);
d1424 1
a1424 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1427 1
a1427 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
@


1.28.2.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1041 7
a1047 7
			md = *(sc->id->t_keymap); /* structure assignment */
				md.layout = enc;
				error = wskbd_load_keymap(&md, &sc->sc_map,
							  &sc->sc_maplen);
				if (error)
			return(error);
		}
@


1.27
log
@If the console keyboard goes away, reinit wskbd_console_device.
Will allow future console keyboard attaches to occur.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.26 2001/09/30 05:49:58 mickey Exp $ */
d969 5
@


1.26
log
@add mode_lock for mode_shift as the caps_lock is to shift; from Igor Grabin <violent@@death.kiev.ua>
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.25 2001/09/26 01:21:37 jcs Exp $ */
d549 5
@


1.25
log
@Connect USB keyboards to the display after attaching, no longer requiring
'wsconscfg -k' to be run.

Thanks to James Matthews for the extra keyboard.

aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.24 2001/09/16 00:42:44 millert Exp $ */
d200 1
d1468 1
a1468 1
				| MOD_MODESHIFT
d1531 4
d1572 2
a1573 1
	if (id->t_modifiers & MOD_MODESHIFT)
@


1.24
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.23 2001/06/11 22:48:14 mickey Exp $ */
d428 1
a428 1
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
d431 2
@


1.23
log
@good when it compiles
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.22 2001/06/11 20:56:57 mickey Exp $ */
d988 2
@


1.22
log
@follow x11 behaviour wrt caps^shift, even i like it this way, but deraadtified
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.21 2001/06/09 01:56:07 aaron Exp $ */
d1572 1
a1572 1
		ksym = group[MOD_ONESET(id, MOD_CAPSLOCK|MOD_ANYSHIFT);
@


1.21
log
@Set sc_dying in wskbd_detach, otherwise it's pointless.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.20 2001/06/09 01:43:51 aaron Exp $ */
d1572 1
a1572 2
		ksym = group[MOD_ONESET(id, MOD_CAPSLOCK) ^
		    MOD_ONESET(id, MOD_ANYSHIFT)];
@


1.20
log
@Remove sc_ready from the softc, we can just test sc_events.io instead.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.19 2001/06/09 01:39:31 aaron Exp $ */
d530 3
d534 1
@


1.19
log
@Allow wskbd_cngetc() to return any key pressed, not just ones in the ASCII
group; fixes PR/1787. This mimics the behavior of pccons and pcvt; mickey@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.18 2001/06/08 03:23:26 mickey Exp $ */
a156 1
	int	sc_ready;		/* accepting events */
d397 1
a397 1
	sc->sc_ready = 0;				/* sanity */
d623 1
a623 1
	if (!sc->sc_ready)
a743 1
	sc->sc_ready = 1;			/* start accepting events */
a770 1
	sc->sc_ready = 0;			/* stop accepting events */
@


1.18
log
@and add a note on result value importance
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.17 2001/06/08 03:20:31 mickey Exp $ */
a1224 1
		if (KS_GROUP(ks) == KS_GROUP_Ascii)
@


1.17
log
@invert caps w/ shifts, also cleanup the whole routine; pointed out by pvalchev@@;  aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.16 2001/05/08 22:28:43 mickey Exp $ */
d206 1
@


1.16
log
@inplement screen burner in screenblank(1) style (no program though).
disabled by default, also supports vsync blanking, disabled by default.
aaron@@ looked at it a while back and i fixed problems he had indicated.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.15 2001/04/18 02:26:58 aaron Exp $ */
d1491 1
a1491 1
		goto kbrep;
d1495 1
a1495 1
		goto kbrep;
d1499 1
a1499 1
		goto kbrep;
d1503 1
a1503 1
		goto kbrep;
d1507 1
a1507 1
		goto kbrep;
d1511 1
a1511 1
		goto kbrep;
d1515 1
a1515 1
		goto kbrep;
d1519 1
a1519 1
		goto kbrep;
d1523 1
a1523 1
		goto kbrep;
d1527 1
a1527 1
		goto kbrep;
d1535 7
a1541 1
		goto kbrep;
d1546 6
a1551 10
	if (sc != NULL && sc->sc_repeating) {
		if ((type == WSCONS_EVENT_KEY_UP && value != sc->sc_repkey) ||
		    (type == WSCONS_EVENT_KEY_DOWN && value == sc->sc_repkey))
			return (0);
	}

kbrep:
	if (sc != NULL && sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
a1552 4
	if (sc != NULL)
		sc->sc_repkey = value;
#else
kbrep:
d1567 6
a1572 23
	if ((id->t_modifiers & MOD_NUMLOCK) != 0 &&
	    KS_GROUP(group[1]) == KS_GROUP_Keypad) {
		if (MOD_ONESET(id, MOD_ANYSHIFT))
			ksym = group[0];
		else
			ksym = group[1];
	} else if (! MOD_ONESET(id, MOD_ANYSHIFT | MOD_CAPSLOCK)) {
		ksym = group[0];
	} else if (MOD_ONESET(id, MOD_CAPSLOCK)) {
		if (! MOD_ONESET(id, MOD_SHIFT_L | MOD_SHIFT_R))
			ksym = group[0];
		else
			ksym = group[1];
		if (ksym >= KS_a && ksym <= KS_z)
			ksym += KS_A - KS_a;
		else if (ksym >= KS_agrave && ksym <= KS_thorn &&
			 ksym != KS_division)
			ksym += KS_Agrave - KS_agrave;
	} else if (MOD_ONESET(id, MOD_ANYSHIFT)) {
		ksym = group[1];
	} else {
		ksym = group[0];
	}
d1637 1
a1637 1
	}
@


1.16.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d592 2
@


1.16.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.16.2.1 2001/05/14 22:26:32 niklas Exp $ */
d157 1
a205 1
	/* these should result in precise 0 or 1, see wskbd_translate() XXX */
d397 1
a397 1
	sc->sc_events.io = NULL;			/* sanity */
a529 3
#endif

	sc->sc_dying = 1;
a530 1
#if NWSMUX > 0
a591 2
		if (type == WSCONS_EVENT_KEY_DOWN && sc->sc_displaydv != NULL)
			wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_KBD);
d621 1
a621 1
	if (sc->sc_events.io == NULL)
d742 1
d770 1
d1222 1
d1489 1
a1489 1
		break;
d1493 1
a1493 1
		break;
d1497 1
a1497 1
		break;
d1501 1
a1501 1
		break;
d1505 1
a1505 1
		break;
d1509 1
a1509 1
		break;
d1513 1
a1513 1
		break;
d1517 1
a1517 1
		break;
d1521 1
a1521 1
		break;
d1525 1
a1525 1
		break;
d1533 1
a1533 7
		break;

	default:
		if (sc != NULL && sc->sc_repeating &&
		    ((type == WSCONS_EVENT_KEY_UP && value != sc->sc_repkey) ||
		     (type == WSCONS_EVENT_KEY_DOWN && value == sc->sc_repkey)))
				return (0);
d1538 12
a1549 5
	if (sc != NULL) {
		if (sc->sc_repeating) {
			sc->sc_repeating = 0;
			timeout_del(&sc->sc_repeat_ch);
		}
d1551 2
a1552 1
	}
d1567 23
a1589 5
	if ((id->t_modifiers & MOD_NUMLOCK) &&
	    KS_GROUP(group[1]) == KS_GROUP_Keypad)
		ksym = group[!MOD_ONESET(id, MOD_ANYSHIFT)];
	else
		ksym = group[MOD_ONESET(id, MOD_CAPSLOCK|MOD_ANYSHIFT)];
d1654 1
a1654 1
		}
@


1.16.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.16.2.2 2001/07/04 10:44:11 niklas Exp $ */
a199 1
#define MOD_MODELOCK		(1 << 15)
d428 1
a428 1
	if (mux != WSKBDDEVCF_MUX_DEFAULT) {
a430 2
		wsdisplay_set_console_kbd(self);
	}
a546 5
	if (sc->sc_isconsole) {
		KASSERT(wskbd_console_device == sc);
		wskbd_console_device = NULL;
	}

a987 2
		if (umdp->maplen > WSKBDIO_MAXMAPLEN)
			return (EINVAL);
d1463 1
a1463 1
				| MOD_MODESHIFT | MOD_MODELOCK
a1525 4
	case KS_Mode_Lock:
		update_modifier(id, type, 1, MOD_MODELOCK);
		break;

d1563 1
a1563 2
	if (id->t_modifiers & (MOD_MODESHIFT|MOD_MODELOCK) &&
	    !MOD_ONESET(id, MOD_ANYCONTROL))
@


1.16.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a968 5
		if ((ukdp->which & WSKBD_KEYREPEAT_DODEL1 &&
		     (hz * ukdp->del1) / 1000 <= 0) ||
		    (ukdp->which & WSKBD_KEYREPEAT_DODELN &&
		     (hz * ukdp->delN) / 1000 <= 0))
			return (EINVAL);
@


1.16.2.5
log
@Merge in -current from roughly a week ago
@
text
@d210 15
a224 14
int	wskbd_match(struct device *, void *, void *);
void	wskbd_attach(struct device *, struct device *, void *);
int	wskbd_detach(struct device *, int);
int	wskbd_activate(struct device *, enum devact);

int wskbd_displayioctl(struct device *, u_long, caddr_t, int, struct proc *p);
int	wskbd_set_display(struct device *, struct wsmux_softc *);
int	wskbd_isset_display(struct device *);

inline void update_leds(struct wskbd_internal *);
inline void update_modifier(struct wskbd_internal *, u_int, int, int);
int internal_command(struct wskbd_softc *, u_int *, keysym_t, keysym_t);
int wskbd_translate(struct wskbd_internal *, u_int, int);
int wskbd_enable(struct wskbd_softc *, int);
d226 2
a227 2
void change_displayparam(struct wskbd_softc *, int, int, int);
void wskbd_holdscreen(struct wskbd_softc *, int);
d230 2
a231 2
int	wskbd_do_ioctl(struct wskbd_softc *, u_long, caddr_t, 
			    int, struct proc *);
d233 3
a235 3
int	wskbddoclose(struct device *, int, int, struct proc *);
int	wskbddoioctl(struct device *, u_long, caddr_t, int, 
			  struct proc *);
d290 1
a290 1
void wskbd_repeat(void *v);
d297 1
a297 1
void wskbd_update_layout(struct wskbd_internal *, kbd_t);
@


1.16.2.6
log
@Sync the SMP branch with 3.3
@
text
@d279 2
a390 1
#if NWSDISPLAY > 0
a391 1
#endif
d1041 7
a1047 7
			md = *(sc->id->t_keymap); /* structure assignment */
				md.layout = enc;
				error = wskbd_load_keymap(&md, &sc->sc_map,
							  &sc->sc_maplen);
				if (error)
			return(error);
		}
d1379 2
a1380 3
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_BACKWARD);
a1382 1
		break;
d1386 2
a1387 3
			if (sc->sc_displaydv != NULL)
				wsscrollback(sc->sc_displaydv,
				    WSDISPLAY_SCROLL_FORWARD);
a1389 1
		break;
d1420 1
a1420 3
		if (sc->sc_displaydv != NULL)
			wsdisplay_switch(sc->sc_displaydv,
			    ksym - KS_Cmd_Screen0, 0);
d1423 1
a1423 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETEMUL);
d1426 1
a1426 2
		if (sc->sc_displaydv != NULL)
			wsdisplay_reset(sc->sc_displaydv, WSDISPLAY_RESETCLOSE);
@


1.16.2.7
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.16.2.6 2003/03/28 00:38:33 niklas Exp $ */
d60 5
a64 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.16.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d937 1
a937 1
		if ((error = suser(p, 0)) != 0)
d980 1
a980 1
		if ((error = suser(p, 0)) != 0)
d1078 1
a1078 1
wskbdpoll(dev, events, p)
@


1.16.2.9
log
@Merge with the trunk
@
text
@a205 2
keysym_t ksym_upcase(keysym_t);

d1432 1
a1432 1
#if defined(__i386__) || defined(__amd64__)
d1475 1
a1475 1
	int gindex, iscommand = 0;
d1592 4
a1595 14
	    KS_GROUP(group[1]) == KS_GROUP_Keypad) {
		gindex = !MOD_ONESET(id, MOD_ANYSHIFT);
		ksym = group[gindex];
	} else {
		/* CAPS alone should only affect letter keys */
		if ((id->t_modifiers & (MOD_CAPSLOCK | MOD_ANYSHIFT)) ==
		    MOD_CAPSLOCK) {
			gindex = 0;
			ksym = ksym_upcase(group[0]);
		} else {
			gindex = MOD_ONESET(id, MOD_ANYSHIFT);
			ksym = group[gindex];
		}
	}
d1630 6
a1635 18
		/*
		 * If the compose key also serves as AltGr (i.e. set to both
		 * KS_Multi_key and KS_Mode_switch), and would provide a valid,
		 * distinct combination as AltGr, leave compose mode.
	 	 */
		if (id->t_composelen == 2 && group == &kp->group2[0]) {
			if (kp->group1[gindex] != kp->group2[gindex])
				id->t_composelen = 0;
		}

		if (id->t_composelen != 0) {
			id->t_composebuf[2 - id->t_composelen] = res;
			if (--id->t_composelen == 0) {
				res = wskbd_compose_value(id->t_composebuf);
				update_modifier(id, 0, 0, MOD_COMPOSE);
			} else {
				return (0);
			}
@


1.15
log
@Oops -- adjust the comment as well.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.14 2001/04/18 02:24:22 aaron Exp $ */
d592 2
@


1.15.2.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.15 2001/04/18 02:26:58 aaron Exp $ */
a983 2
		if (umdp->maplen > WSKBDIO_MAXMAPLEN)
			return (EINVAL);
@


1.14
log
@Set the default bell pitch to 400, like X.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.13 2001/04/09 18:34:35 aaron Exp $ */
d250 1
a250 1
#define	WSKBD_DEFAULT_BELL_PITCH	400	/* 1500Hz */
@


1.13
log
@Honor the db_console sysctl variable, like PCVT did.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.12 2001/03/30 16:38:13 aaron Exp $ */
d250 1
a250 1
#define	WSKBD_DEFAULT_BELL_PITCH	1500	/* 1500Hz */
@


1.12
log
@Add a new wsmuxop, dissetdisplay, which wsmux uses to disocver whether a mux
device is connected to a display or not. Use it in wsmux_detach_sc(). This
fixes a problem I've been struggling with whereby the machine panics if I
detach a USB keyboard before disconnecting it from wsdisplay.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.11 2001/03/01 23:28:46 aaron Exp $ */
d104 2
d1383 1
a1383 1
		if (sc->sc_isconsole)
@


1.11
log
@Wrap KS_Cmd_KbdReset in #ifdef __i386__ for now; politely pointed to this by
drahn@@, snarked at by mickey@@ ;)
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.10 2001/03/01 03:43:12 aaron Exp $ */
d215 1
d282 1
a282 1
	wskbd_set_display
d1144 12
@


1.10
log
@Add CTRL-ALT-DEL machine reset support, like PCVT had, enabled by the
machdep.kbdreset sysctl as configured in /etc/sysctl.conf.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.9 2001/02/11 19:14:06 aaron Exp $ */
d1396 1
d1403 1
@


1.9
log
@Allow up to 12 virtual terminals (CTRL-ALT-F1 through CTRL-ALT-F12). Only
6 are enabled by default. After these changes, to enable more you must
change the "option WSDISPLAY_DEFAULTSCREENS" in the kernel config file and
edit /etc/ttys to switch the new ones from 'off' to 'on'.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.8 2001/02/10 19:42:06 mickey Exp $ */
d244 2
d1395 6
@


1.8
log
@sync w/ netbsd; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.7 2001/02/08 02:47:12 aaron Exp $ */
d1384 2
@


1.7
log
@Cause keypresses to reset the screen in case we are in scrollback (previously
the screen was only restored if a new character was actually displayed on the
screen); jcs@@rt.fm. This brings us closer to the behavior of PCVT. Also, while
I'm here, add some #ifdef so wskbd does not depend on wsdisplay (pointed out
to me by fgsch@@).
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.6 2001/01/30 17:33:20 aaron Exp $ */
d218 1
a218 1
int internal_command __P((struct wskbd_softc *, u_int *, keysym_t));
d222 1
d1289 28
d1318 1
a1318 1
internal_command(sc, type, ksym)
d1321 1
a1321 1
	keysym_t ksym;
d1326 1
d1392 21
d1455 2
a1456 1
		iscommand = internal_command(sc, &type, kp->command);
@


1.6
log
@- Add some checks for (sc != NULL). Missed by me previously. Fixes boot -c.
- Remove static.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.5 2001/01/30 04:54:50 aaron Exp $ */
d525 6
a534 4

	mux = sc->sc_dv.dv_cfdata->wskbddevcf_mux;
	if (mux != WSKBDDEVCF_MUX_DEFAULT)
		wsmux_detach(mux, &sc->sc_dv);
d589 9
a597 3
				for (i = 0; i < num; i++)
				wsdisplay_kbdinput(sc->sc_displaydv,
						sc->id->t_symbols[i]);
d1315 2
a1316 1
			wsscrollback(sc->sc_displaydv, WSCONS_SCROLL_BACKWARD);
d1322 2
a1323 1
			wsscrollback(sc->sc_displaydv, WSCONS_SCROLL_FORWARD);
d1458 1
d1472 3
@


1.5
log
@WSMOUSEDEVCF_MUX_DEFAULT -> WSKBDDEVCF_MUX_DEFAULT, although this didn't
matter much since they are the same value, but confusing nonetheless.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.4 2000/11/24 14:05:25 aaron Exp $ */
d212 1
a212 1
static int wskbd_displayioctl
d216 5
a220 5
static inline void update_leds __P((struct wskbd_internal *));
static inline void update_modifier __P((struct wskbd_internal *, u_int, int, int));
static int internal_command __P((struct wskbd_softc *, u_int *, keysym_t));
static int wskbd_translate __P((struct wskbd_internal *, u_int, int));
static int wskbd_enable __P((struct wskbd_softc *, int));
d222 1
a222 1
static void wskbd_holdscreen __P((struct wskbd_softc *, int));
d283 1
a283 1
static void wskbd_repeat __P((void *v));
d290 1
a290 1
static void wskbd_update_layout __P((struct wskbd_internal *, kbd_t));
d292 1
a292 1
static void
d469 1
a469 1
static void
d652 1
a652 1
static void
d675 1
a675 1
static int
d856 1
a856 1
static int
a1229 1

d1239 1
a1239 1
static inline void
d1262 1
a1262 1
static inline void
d1280 1
a1280 1
static int
d1357 1
a1357 1
static int
d1448 1
a1448 1
	if (sc->sc_repeating) {
d1455 1
a1455 1
	if (sc->sc_repeating) {
d1459 2
a1460 1
	sc->sc_repkey = value;
@


1.4
log
@Better key repeat logic. When we're in repeat mode, with the exception of
modifier keys (SHIFT, CTRL, ALT, etc.), and a key "up" event is received,
only delete the key repeat timeout if the key that generated the "up"
event is the key currently being repeated. When a key "down" event is
received, the opposite -- only delete the key repeat if the key that generated
the "down" event is _not_ the key currently being repeated.

Playing here is a bit dangerous since we are constraining the conditions in
which a timeout(9) is deleted (we don't want to mistakenly get stuck in a
non-legitamite key repeat).

Using timeout(9) for this is kind of gross. I guess it is done here to avoid
key repeat code in all of the actual hardware keyboard drivers.

There is still a bug here. If you have a key held down and detach your
keyboard (by either unplugging it or doing a KVM switch), the timeout is not
deleted and the key continues to repeat until it gets the keyboard back and
receives an interrupt. Perhaps we should not be ignoring typematic keys after
all?
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.3 2000/11/15 20:00:40 aaron Exp $ */
d531 1
a531 1
	if (mux != WSMOUSEDEVCF_MUX_DEFAULT)
@


1.3
log
@Support console scrollback in wscons through a new "scrollback" accessop that
hooks into the lower-level display driver. The updated vga(4) driver I'm about
to commit has support for this. This is a fairly unobtrusive way to implement
scrollback while maintaining the abstraction of the wscons system.
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
d167 1
d525 5
a578 5
	if (sc->sc_repeating) {
		sc->sc_repeating = 0;
		timeout_del(&sc->sc_repeat_ch);
	}

d1401 1
a1401 1
		break;
d1405 1
a1405 1
		break;
d1409 1
a1409 1
		break;
d1413 1
a1413 1
		break;
d1417 1
a1417 1
		break;
d1421 1
a1421 1
		break;
d1425 1
a1425 1
		break;
d1429 1
a1429 1
		break;
d1433 1
a1433 1
		break;
d1437 1
a1437 1
		break;
d1445 1
a1445 1
		break;
d1448 13
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.1 2000/05/16 23:49:12 mickey Exp $ */
d110 1
d1300 21
a1320 3
	if (*type != WSCONS_EVENT_KEY_DOWN ||
	    (! MOD_ONESET(sc->id, MOD_COMMAND) &&
	     ! MOD_ALLSET(sc->id, MOD_COMMAND1 | MOD_COMMAND2)))
@


1.2.2.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wskbd.c,v 1.24 2001/09/16 00:42:44 millert Exp $ */
a967 2
		if (umdp->maplen > WSKBDIO_MAXMAPLEN)
			return (EINVAL);
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wskbd.c,v 1.35 2000/01/05 11:19:37 drochner Exp $ */
d205 1
a205 1
int	wskbd_match __P((struct device *, struct cfdata *, void *));
d235 1
a235 1
	sizeof (struct wskbd_softc), (cfmatch_t)wskbd_match, wskbd_attach,
d239 2
d326 1
a326 1
	struct cfdata *match;
d329 1
d332 1
a332 1
	if (match->wskbddevcf_console != WSKBDDEVCF_CONSOLE_UNK) {
d337 1
a337 1
		if (match->wskbddevcf_console != 0 && ap->console != 0)
@

