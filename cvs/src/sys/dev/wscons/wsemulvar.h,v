head	1.16;
access;
symbols
	OPENBSD_6_1:1.16.0.2
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.15.0.12
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.2
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.10
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.8
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.6
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.4
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.13.0.14
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.13.0.12
	OPENBSD_5_3_BASE:1.13
	OPENBSD_5_2:1.13.0.10
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.8
	OPENBSD_5_0:1.13.0.6
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.10
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.6
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.4
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.2
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.7.0.4
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.2
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.6.0.20
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.18
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.4.0.2
	UBC_BASE:1.4
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.16
date	2017.03.06.09.08.45;	author mpi;	state Exp;
branches;
next	1.15;
commitid	rFkSHOfbRlLuAmfj;

1.15
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2013.10.18.14.17.23;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2010.07.01.02.33.06;	author maja;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2009.09.05.14.30.24;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2007.11.26.16.56.42;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.25.19.11.43;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2006.12.09.20.06.48;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2002.01.03.21.58.59;	author jason;	state Exp;
branches;
next	1.4;

1.4
date	2001.12.01.18.41.33;	author deraadt;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2001.03.14.02.49.23;	author mickey;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	2001.02.13.14.50.34;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.31;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2002.03.06.02.11.48;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	;

1.4.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Use 'inline' rather than _any of_ __the __other__ variants__.

ok bru@@
@
text
@/* $OpenBSD: wsemulvar.h,v 1.15 2013/10/18 22:06:41 miod Exp $ */
/* $NetBSD: wsemulvar.h,v 1.6 1999/01/17 15:46:15 drochner Exp $ */

/*
 * Copyright (c) 2009 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifdef	_KERNEL

#include <dev/wscons/wscons_features.h>

struct device;
struct wsdisplay_emulops;

enum wsemul_resetops {
	WSEMUL_RESET,
	WSEMUL_SYNCFONT,
	WSEMUL_CLEARSCREEN,
	WSEMUL_CLEARCURSOR
};

struct wsemul_ops {
	char name[WSEMUL_NAME_SIZE];

	void	*(*cnattach)(const struct wsscreen_descr *, void *,
				  int, int, long);
	void	*(*attach)(int, const struct wsscreen_descr *, void *,
				int, int, void *, long);
	u_int	(*output)(void *, const u_char *, u_int, int);
	int	(*translate)(void *, kbd_t, keysym_t, const u_char **);
	void	(*detach)(void *, u_int *, u_int *);
	void    (*reset)(void *, enum wsemul_resetops);
};

/*
 * Structure carrying the state of multi-byte character sequences
 * decoding.
 */
struct wsemul_inputstate {
	u_int32_t	inchar;	/* character being reconstructed */
	u_int		mbleft;	/* multibyte bytes left until char complete */
};

extern const struct wsemul_ops wsemul_dumb_ops;
extern const struct wsemul_ops wsemul_sun_ops;
extern const struct wsemul_ops wsemul_vt100_ops;

const struct wsemul_ops *wsemul_pick(const char *);
const char *wsemul_getname(int);

/*
 * Callbacks from the emulation code to the display interface driver.
 */
void	wsdisplay_emulbell(void *v);
void	wsdisplay_emulinput(void *v, const u_char *, u_int);

/*
 * Get characters from an input stream and update the input state.
 * Processing stops when the stream is empty, or a complete character
 * sequence has been recognized, in which case it returns zero.
 */
int	wsemul_getchar(const u_char **, u_int *, struct wsemul_inputstate *,
	    int);

/*
 * Keysym to UTF-8 sequence translation function.
 */
int	wsemul_utf8_translate(u_int32_t, kbd_t, u_char *, int);

/*
 * emulops failure abort/recovery state
 *
 * The tty layer needs a character output to be atomic.  Since this may
 * expand to multiple emulops operations, which may fail, it is necessary
 * for each emulation code to keep state of its current processing, so
 * that if an operation fails, the whole character from the tty layer is
 * reported as not having been output, while it has in fact been partly
 * processed.
 *
 * When the tty layer will try to retransmit the character, this state
 * information is used to not retrig the emulops which have been issued
 * succesfully already.
 *
 * In order to make things more confusing, there is a particular failure
 * case, when all characters have been processed successfully, but
 * displaying the cursor image fails.
 *
 * Since there might not be tty output in a while, we need to report
 * failure, so we pretend not having been able to issue the last character.
 * When the tty layer tries again to display this character (really to get
 * the cursor image back), it will directly be skipped. This is done with
 * a special state value.
 */

struct wsemul_abortstate {
	enum {
		ABORT_OK,
		ABORT_FAILED_CURSOR,
		ABORT_FAILED_JUMP_SCROLL,
		ABORT_FAILED_OTHER
	} state;
	int	skip;	/* emulops to skip before reaching resume point */
	int	done;	/* emulops completed */
	int	lines;	/* jump scroll lines */
};

/* start character processing, assuming cursor or jump scroll failure condition
   has been taken care of */
static inline void
wsemul_resume_abort(struct wsemul_abortstate *was)
{
	was->state = ABORT_OK;
	was->done = 0;
}

/* register processing failure points */
static inline void
wsemul_abort_cursor(struct wsemul_abortstate *was)
{
	was->state = ABORT_FAILED_CURSOR;
}

static inline void
wsemul_abort_jump_scroll(struct wsemul_abortstate *was, int lines)
{
	was->state = ABORT_FAILED_JUMP_SCROLL;
	was->skip = was->done;
	was->lines = lines;
}

static inline void
wsemul_abort_other(struct wsemul_abortstate *was)
{
	was->state = ABORT_FAILED_OTHER;
	was->skip = was->done;
}

/* initialize abortstate structure */
static inline void
wsemul_reset_abortstate(struct wsemul_abortstate *was)
{
	was->state = ABORT_OK;
	was->skip = 0;
	/* was->done = 0; */
}

/*
 * Wrapper macro to handle failing emulops calls consistently.
 */

#ifdef HAVE_RESTARTABLE_EMULOPS
#define	WSEMULOP(rc, edp, was, rutin, args) \
do { \
	if ((was)->skip != 0) { \
		(was)->skip--; \
		(rc) = 0; \
	} else { \
		(rc) = (*(edp)->emulops->rutin) args ; \
	} \
	if ((rc) == 0) \
		(was)->done++; \
} while (0)
#else
#define	WSEMULOP(rc, edp, was, rutin, args) \
do { \
	(void)(*(edp)->emulops->rutin) args ; \
	(rc) = 0; \
} while(0)
#endif

#endif	/* _KERNEL */
@


1.15
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.14 2013/10/18 14:17:23 miod Exp $ */
d150 1
a150 1
static __inline__ void
d158 1
a158 1
static __inline__ void
d164 1
a164 1
static __inline__ void
d172 1
a172 1
static __inline__ void
d180 1
a180 1
static __inline__ void
@


1.14
log
@Add a conditional to disable most of the `abort state' code in the emulation
code. Enable this if SMALL_KERNEL, since this code is currently only really
needed for udl(4) which is not on any tight (SMALL_KERNEL) installation media.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.13 2010/07/01 02:33:06 maja Exp $ */
d71 1
a71 1
	int	(*translate)(void *, keysym_t, const char **);
d76 9
d97 13
@


1.13
log
@Make it possible to get the screen types and emulations for a wsdisplay.
Information needed for wsconscfg. feedback and ok miod@@. -moj
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.12 2009/09/05 14:49:20 miod Exp $ */
d51 2
d170 1
d182 7
@


1.12
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.11 2009/09/05 14:30:24 miod Exp $ */
d79 1
@


1.11
log
@Make the output() wsemul_op return the number of characters processed and
check it in wsdisplaystart() to suspend output if not all characters have
been output; they will get reissued at the next tty rstrt_to timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.10 2007/11/27 16:37:27 miod Exp $ */
d5 15
d49 2
d85 95
@


1.10
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.9 2007/11/26 16:56:42 miod Exp $ */
d49 1
a49 1
	void	*(*attach)(int console, const struct wsscreen_descr *, void *,
d51 1
a51 2
	void	(*output)(void *cookie, const u_char *data, u_int count,
			       int);
d53 1
a53 1
	void	(*detach)(void *cookie, u_int *crow, u_int *ccol);
@


1.9
log
@Constify the output of the emulops translate() function, as well as the
various tables they use.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.8 2007/11/25 19:11:43 miod Exp $ */
d64 1
a64 1
/* 
d66 1
a66 1
 */     
@


1.8
log
@Ask the emulation code to hide the cursor when leaving emulation mode. This
way we do not get a phantom cursor image when X exits.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.7 2006/12/09 20:06:48 miod Exp $ */
d53 1
a53 1
	int	(*translate)(void *, keysym_t, char **);
@


1.7
log
@Do not make sun terminal emulation selected by the wsemul_sun frame buffer
attribute anymore; remove it and use option WSEMUL_SUN instead, which gets
added to all sparc* kernels.

While there, do not compile vt100 emulation on sparc* kernels, this saves 16+
KB of text.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.6 2002/03/14 01:27:03 millert Exp $ */
d40 2
a41 1
	WSEMUL_CLEARSCREEN
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.5 2002/01/03 21:58:59 jason Exp $ */
a56 1
#ifdef WSEMUL_DUMB
a57 2
#endif
#if defined(WSEMUL_SUN) || NWSEMUL_SUN > 0
a58 2
#endif
#ifndef WSEMUL_NO_VT100
a59 1
#endif
@


1.5
log
@define a new wsemul_sun attribute and add it to the sparc64 framebuffers
[This needs to be extended to the vt100 and dumb emulations too.. in time].
(This allows the removal of WSEMUL_SUN from sparc64/conf/GENERIC)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.4 2001/12/01 18:41:33 deraadt Exp $ */
d46 9
a54 9
	void	*(*cnattach) __P((const struct wsscreen_descr *, void *,
				  int, int, long));
	void	*(*attach) __P((int console, const struct wsscreen_descr *, void *,
				int, int, void *, long));
	void	(*output) __P((void *cookie, const u_char *data, u_int count,
			       int));
	int	(*translate) __P((void *, keysym_t, char **));
	void	(*detach) __P((void *cookie, u_int *crow, u_int *ccol));
	void    (*reset) __P((void *, enum wsemul_resetops));
d67 1
a67 1
const struct wsemul_ops *wsemul_pick __P((const char *));
d72 2
a73 2
void	wsdisplay_emulbell __P((void *v));
void	wsdisplay_emulinput __P((void *v, const u_char *, u_int));
@


1.4
log
@change to WSEMUL_NO_DUMB
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.3 2001/03/14 02:49:23 mickey Exp $ */
d60 1
a60 1
#ifdef WSEMUL_SUN
@


1.4.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.5 2002/01/03 21:58:59 jason Exp $ */
d60 1
a60 1
#if defined(WSEMUL_SUN) || NWSEMUL_SUN > 0
@


1.4.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.4.2.1 2002/01/31 22:55:39 niklas Exp $ */
d46 9
a54 9
	void	*(*cnattach)(const struct wsscreen_descr *, void *,
				  int, int, long);
	void	*(*attach)(int console, const struct wsscreen_descr *, void *,
				int, int, void *, long);
	void	(*output)(void *cookie, const u_char *data, u_int count,
			       int);
	int	(*translate)(void *, keysym_t, char **);
	void	(*detach)(void *cookie, u_int *crow, u_int *ccol);
	void    (*reset)(void *, enum wsemul_resetops);
d67 1
a67 1
const struct wsemul_ops *wsemul_pick(const char *);
d72 2
a73 2
void	wsdisplay_emulbell(void *v);
void	wsdisplay_emulinput(void *v, const u_char *, u_int);
@


1.3
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.2 2001/02/13 14:50:34 deraadt Exp $ */
d57 1
a57 1
#ifndef WSEMUL_NO_DUMB
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.3 2001/03/14 02:49:23 mickey Exp $ */
@


1.3.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d57 1
a57 1
#ifdef WSEMUL_DUMB
@


1.3.4.3
log
@Merge in trunk
@
text
@d60 1
a60 1
#if defined(WSEMUL_SUN) || NWSEMUL_SUN > 0
@


1.3.4.4
log
@Merge in -current from roughly a week ago
@
text
@d46 9
a54 9
	void	*(*cnattach)(const struct wsscreen_descr *, void *,
				  int, int, long);
	void	*(*attach)(int console, const struct wsscreen_descr *, void *,
				int, int, void *, long);
	void	(*output)(void *cookie, const u_char *data, u_int count,
			       int);
	int	(*translate)(void *, keysym_t, char **);
	void	(*detach)(void *cookie, u_int *crow, u_int *ccol);
	void    (*reset)(void *, enum wsemul_resetops);
d67 1
a67 1
const struct wsemul_ops *wsemul_pick(const char *);
d72 2
a73 2
void	wsdisplay_emulbell(void *v);
void	wsdisplay_emulinput(void *v, const u_char *, u_int);
@


1.2
log
@default more wscons options
@
text
@d1 1
a1 1
/* $OpenBSD: wsemulvar.h,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d44 1
a44 1
	const char *name;
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d63 1
a63 1
#ifdef WSEMUL_VT100
@

