head	1.32;
access;
symbols
	OPENBSD_6_1:1.32.0.4
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.31.0.2
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.6
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.10
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.6
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.4
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.2
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.4
	OPENBSD_5_0:1.22.0.2
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.21.0.2
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.20.0.8
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.4
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.6
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.2
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.19.0.8
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.6
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.4
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.15.0.8
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.6
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.4
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.2
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.14.0.4
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.2
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.4
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.2
	OPENBSD_3_0_BASE:1.9
	SMP:1.5.0.4
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.2
	OPENBSD_2_8_BASE:1.3;
locks; strict;
comment	@ * @;


1.32
date	2017.01.23.04.43.46;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	ZRaLvYTZkX86uQ5e;

1.31
date	2016.04.24.17.30.31;	author matthieu;	state Exp;
branches;
next	1.30;
commitid	ThLs9KTUyb0PPd5J;

1.30
date	2016.03.28.09.08.22;	author matthieu;	state Exp;
branches;
next	1.29;
commitid	znrndGT4GNRsPR36;

1.29
date	2016.03.03.18.00.49;	author naddy;	state Exp;
branches;
next	1.28;
commitid	RwKGSt1SVDRChFpz;

1.28
date	2015.09.08.11.13.20;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	cepoHqLZxiNNy2Sr;

1.27
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.25;
commitid	OBNa5kfxQ2UXoiIw;

1.25
date	2014.04.18.21.18.50;	author guenther;	state Exp;
branches;
next	1.24;

1.24
date	2012.03.28.22.26.10;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2012.03.28.20.18.32;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2011.04.05.12.50.15;	author guenther;	state Exp;
branches;
next	1.21;

1.21
date	2010.08.28.12.48.14;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.16.15.51.26;	author tom;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.29.12.52.40;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.30.21.34.47;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2003.08.11.17.43.05;	author millert;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.06.04.12.48.37;	author ho;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2001.05.16.19.40.05;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.16.12.51.50;	author ho;	state Exp;
branches;
next	1.6;

1.6
date	2001.05.16.05.07.51;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.04.14.04.48.00;	author aaron;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2001.02.10.19.42.06;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.05.22.50.11;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.26.30;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.44.10;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.5.4.4;

1.5.4.4
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.5.4.5;

1.5.4.5
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.5.4.6;

1.5.4.6
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.9.4.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.05.19.22.14.07;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Only allow change-setting ioctls when FWRITE is set on the descriptor.
ok I forget who
@
text
@/* $OpenBSD: wsdisplay_compat_usl.c,v 1.31 2016/04/24 17:30:31 matthieu Exp $ */
/* $NetBSD: wsdisplay_compat_usl.c,v 1.12 2000/03/23 07:01:47 thorpej Exp $ */

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/signalvar.h>
#include <sys/malloc.h>
#include <sys/errno.h>
#include <sys/fcntl.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wscons_callbacks.h>
#include <dev/wscons/wsdisplay_usl_io.h>

#ifdef WSDISPLAY_DEBUG
#define DPRINTF(x)	 if (wsdisplaydebug) printf x
int	wsdisplaydebug = 0;
#else
#define DPRINTF(x)
#endif

struct usl_syncdata {
	struct wsscreen *s_scr;
	struct process *s_process;
	pid_t s_pid;
	int s_flags;
#define SF_DETACHPENDING 1
#define SF_ATTACHPENDING 2
	int s_acqsig, s_relsig;
	int s_frsig; /* unused */
	void (*s_callback)(void *, int, int);
	void *s_cbarg;
	struct timeout s_attach_ch;
	struct timeout s_detach_ch;
};

int usl_sync_init(struct wsscreen *, struct usl_syncdata **,
		       struct process *, int, int, int);
void usl_sync_done(struct usl_syncdata *);
int usl_sync_check(struct usl_syncdata *);
struct usl_syncdata *usl_sync_get(struct wsscreen *);

int usl_detachproc(void *, int, void (*)(void *, int, int), void *);
int usl_detachack(struct usl_syncdata *, int);
void usl_detachtimeout(void *);
int usl_attachproc(void *, int, void (*)(void *, int, int), void *);
int usl_attachack(struct usl_syncdata *, int);
void usl_attachtimeout(void *);

static const struct wscons_syncops usl_syncops = {
	usl_detachproc,
	usl_attachproc,
#define _usl_sync_check ((int (*)(void *))usl_sync_check)
	_usl_sync_check,
#define _usl_sync_destroy ((void (*)(void *))usl_sync_done)
	_usl_sync_destroy
};

#ifndef WSCOMPAT_USL_SYNCTIMEOUT
#define WSCOMPAT_USL_SYNCTIMEOUT 5 /* seconds */
#endif
static int wscompat_usl_synctimeout = WSCOMPAT_USL_SYNCTIMEOUT;

int
usl_sync_init(struct wsscreen *scr, struct usl_syncdata **sdp,
    struct process *pr, int acqsig, int relsig, int frsig)
{
	struct usl_syncdata *sd;
	int res;

	if (acqsig <= 0 || acqsig >= NSIG || relsig <= 0 || relsig >= NSIG ||
	    frsig <= 0 || frsig >= NSIG)
		return (EINVAL);
	sd = malloc(sizeof(*sd), M_DEVBUF, M_NOWAIT);
	if (!sd)
		return (ENOMEM);
	sd->s_scr = scr;
	sd->s_process = pr;
	sd->s_pid = pr->ps_pid;
	sd->s_flags = 0;
	sd->s_acqsig = acqsig;
	sd->s_relsig = relsig;
	sd->s_frsig = frsig;
	timeout_set(&sd->s_attach_ch, usl_attachtimeout, sd);
	timeout_set(&sd->s_detach_ch, usl_detachtimeout, sd);
	res = wsscreen_attach_sync(scr, &usl_syncops, sd);
	if (res) {
		free(sd, M_DEVBUF, sizeof(*sd));
		return (res);
	}
	*sdp = sd;
	return (0);
}

void
usl_sync_done(struct usl_syncdata *sd)
{
	if (sd->s_flags & SF_DETACHPENDING) {
		timeout_del(&sd->s_detach_ch);
		(*sd->s_callback)(sd->s_cbarg, 0, 0);
	}
	if (sd->s_flags & SF_ATTACHPENDING) {
		timeout_del(&sd->s_attach_ch);
		(*sd->s_callback)(sd->s_cbarg, ENXIO, 0);
	}
	wsscreen_detach_sync(sd->s_scr);
	free(sd, M_DEVBUF, sizeof(*sd));
}

int
usl_sync_check(struct usl_syncdata *sd)
{
	if (sd->s_process == prfind(sd->s_pid))
		return (1);
	DPRINTF(("usl_sync_check: process %d died\n", sd->s_pid));
	usl_sync_done(sd);
	return (0);
}

struct usl_syncdata *
usl_sync_get(struct wsscreen *scr)
{
	struct usl_syncdata *sd;

	if (wsscreen_lookup_sync(scr, &usl_syncops, (void **)&sd))
		return (0);
	return (sd);
}

int
usl_detachproc(void *cookie, int waitok, void (*callback)(void *, int, int),
    void *cbarg)
{
	struct usl_syncdata *sd = cookie;

	if (!usl_sync_check(sd))
		return (0);

	/* we really need a callback */
	if (!callback)
		return (EINVAL);

	/*
	 * Normally, this is called from the controlling process.
	 * It is supposed to reply with a VT_RELDISP ioctl(), so
	 * it is not useful to tsleep() here.
	 */
	sd->s_callback = callback;
	sd->s_cbarg = cbarg;
	sd->s_flags |= SF_DETACHPENDING;
	prsignal(sd->s_process, sd->s_relsig);
	timeout_add_sec(&sd->s_detach_ch, wscompat_usl_synctimeout);

	return (EAGAIN);
}

int
usl_detachack(struct usl_syncdata *sd, int ack)
{
	if (!(sd->s_flags & SF_DETACHPENDING)) {
		DPRINTF(("usl_detachack: not detaching\n"));
		return (EINVAL);
	}

	timeout_del(&sd->s_detach_ch);
	sd->s_flags &= ~SF_DETACHPENDING;

	if (sd->s_callback)
		(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);

	return (0);
}

void
usl_detachtimeout(void *arg)
{
	struct usl_syncdata *sd = arg;

	DPRINTF(("usl_detachtimeout\n"));

	if (!(sd->s_flags & SF_DETACHPENDING)) {
		DPRINTF(("usl_detachtimeout: not detaching\n"));
		return;
	}

	sd->s_flags &= ~SF_DETACHPENDING;

	if (sd->s_callback)
		(*sd->s_callback)(sd->s_cbarg, EIO, 0);

	(void) usl_sync_check(sd);
}

int
usl_attachproc(void *cookie, int waitok, void (*callback)(void *, int, int),
    void *cbarg)
{
	struct usl_syncdata *sd = cookie;

	if (!usl_sync_check(sd))
		return (0);

	/* we really need a callback */
	if (!callback)
		return (EINVAL);

	sd->s_callback = callback;
	sd->s_cbarg = cbarg;
	sd->s_flags |= SF_ATTACHPENDING;
	prsignal(sd->s_process, sd->s_acqsig);
	timeout_add_sec(&sd->s_attach_ch, wscompat_usl_synctimeout);

	return (EAGAIN);
}

int
usl_attachack(struct usl_syncdata *sd, int ack)
{
	if (!(sd->s_flags & SF_ATTACHPENDING)) {
		DPRINTF(("usl_attachack: not attaching\n"));
		return (EINVAL);
	}

	timeout_del(&sd->s_attach_ch);
	sd->s_flags &= ~SF_ATTACHPENDING;

	if (sd->s_callback)
		(*sd->s_callback)(sd->s_cbarg, (ack ? 0 : EIO), 1);

	return (0);
}

void
usl_attachtimeout(void *arg)
{
	struct usl_syncdata *sd = arg;

	DPRINTF(("usl_attachtimeout\n"));

	if (!(sd->s_flags & SF_ATTACHPENDING)) {
		DPRINTF(("usl_attachtimeout: not attaching\n"));
		return;
	}

	sd->s_flags &= ~SF_ATTACHPENDING;

	if (sd->s_callback)
		(*sd->s_callback)(sd->s_cbarg, EIO, 0);

	(void) usl_sync_check(sd);
}

int
wsdisplay_usl_ioctl1(struct wsdisplay_softc *sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
{
	int idx, maxidx;

	switch (cmd) {
	    case VT_OPENQRY:
		maxidx = wsdisplay_maxscreenidx(sc);
		for (idx = 0; idx <= maxidx; idx++) {
			if (wsdisplay_screenstate(sc, idx) == 0) {
				*(int *)data = idx + 1;
				return (0);
			}
		}
		return (ENXIO);
	    case VT_GETACTIVE:
		idx = wsdisplay_getactivescreen(sc);
		*(int *)data = idx + 1;
		return (0);
	    case VT_ACTIVATE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		idx = *(int *)data - 1;
		if (idx < 0)
			return (EINVAL);
		return (wsdisplay_switch((struct device *)sc, idx, 1));
	    case VT_WAITACTIVE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		idx = *(int *)data - 1;
		if (idx < 0)
			return (EINVAL);
		return (wsscreen_switchwait(sc, idx));
	    case VT_GETSTATE:
#define ss ((struct vt_stat *)data)
		idx = wsdisplay_getactivescreen(sc);
		ss->v_active = idx + 1;
		ss->v_state = 0;
		maxidx = wsdisplay_maxscreenidx(sc);
		for (idx = 0; idx <= maxidx; idx++)
			if (wsdisplay_screenstate(sc, idx) == EBUSY)
				ss->v_state |= (1 << (idx + 1));
#undef ss
		return (0);

	    default:
		return (-1);
	}

	return (0);
}

int
wsdisplay_usl_ioctl2(struct wsdisplay_softc *sc, struct wsscreen *scr,
    u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int intarg, res;
	u_long req;
	void *arg;
	struct usl_syncdata *sd;
	struct wskbd_bell_data bd;

	switch (cmd) {
	    case VT_SETMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
#define newmode ((struct vt_mode *)data)
		if (newmode->mode == VT_PROCESS) {
			res = usl_sync_init(scr, &sd, p->p_p, newmode->acqsig,
					    newmode->relsig, newmode->frsig);
			if (res)
				return (res);
		} else {
			sd = usl_sync_get(scr);
			if (sd)
				usl_sync_done(sd);
		}
#undef newmode
		return (0);
	    case VT_GETMODE:
#define cmode ((struct vt_mode *)data)
		sd = usl_sync_get(scr);
		if (sd) {
			cmode->mode = VT_PROCESS;
			cmode->relsig = sd->s_relsig;
			cmode->acqsig = sd->s_acqsig;
			cmode->frsig = sd->s_frsig;
		} else
			cmode->mode = VT_AUTO;
#undef cmode
		return (0);
	    case VT_RELDISP:
		if ((flag & FWRITE) == 0)
			return (EACCES);
#define d (*(int *)data)
		sd = usl_sync_get(scr);
		if (!sd)
			return (EINVAL);
		switch (d) {
		    case VT_FALSE:
		    case VT_TRUE:
			return (usl_detachack(sd, (d == VT_TRUE)));
		    case VT_ACKACQ:
			return (usl_attachack(sd, 1));
		    default:
			return (EINVAL);
		}
#undef d
		return (0);

	    case KDENABIO:
	    case KDDISABIO:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		/*
		 * This is a lie, but non-x86 platforms are not supposed to
		 * issue these ioctls anyway.
		 */
		return (0);

	    case KDSETRAD:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		/* XXX ignore for now */
		return (0);

	    default:
		return (-1);

	    /*
	     * the following are converted to wsdisplay ioctls
	     */
	    case KDSETMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		req = WSDISPLAYIO_SMODE;
#define d (*(int *)data)
		switch (d) {
		    case KD_GRAPHICS:
			intarg = WSDISPLAYIO_MODE_MAPPED;
			break;
		    case KD_TEXT:
			intarg = WSDISPLAYIO_MODE_EMUL;
			break;
		    default:
			return (EINVAL);
		}
#undef d
		arg = &intarg;
		break;
	    case KDMKTONE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		req = WSKBDIO_COMPLEXBELL;
#define d (*(int *)data)
		if (d) {
#define PCVT_SYSBEEPF	1193182
			if (d >> 16) {
				bd.which = WSKBD_BELL_DOPERIOD;
			bd.period = d >> 16; /* ms */
			}
			else
				bd.which = 0;
			if (d & 0xffff) {
				bd.which |= WSKBD_BELL_DOPITCH;
				bd.pitch = PCVT_SYSBEEPF/(d & 0xffff); /* Hz */
			}
		} else
			bd.which = 0; /* default */
#undef d
		arg = &bd;
		break;
	    case KDSETLED:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		req = WSKBDIO_SETLEDS;
		intarg = 0;
#define d (*(int *)data)
		if (d & LED_CAP)
			intarg |= WSKBD_LED_CAPS;
		if (d & LED_NUM)
			intarg |= WSKBD_LED_NUM;
		if (d & LED_SCR)
			intarg |= WSKBD_LED_SCROLL;
#undef d
		arg = &intarg;
		break;
	    case KDGETLED:
		req = WSKBDIO_GETLEDS;
		arg = &intarg;
		break;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	    case KDSKBMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		req = WSKBDIO_SETMODE;
		switch (*(int *)data) {
		    case K_RAW:
			intarg = WSKBD_RAW;
			break;
		    case K_XLATE:
			intarg = WSKBD_TRANSLATED;
			break;
		    default:
			return (EINVAL);
		}
		arg = &intarg;
		break;
	    case KDGKBMODE:
		req = WSKBDIO_GETMODE;
		arg = &intarg;
		break;
#endif
	}

	res = wsdisplay_internal_ioctl(sc, scr, req, arg, flag, p);
	if (res)
		return (res);

	switch (cmd) {
	    case KDGETLED:
#define d (*(int *)data)
		d = 0;
		if (intarg & WSKBD_LED_CAPS)
			d |= LED_CAP;
		if (intarg & WSKBD_LED_NUM)
			d |= LED_NUM;
		if (intarg & WSKBD_LED_SCROLL)
			d |= LED_SCR;
#undef d
		break;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	    case KDGKBMODE:
		*(int *)data = (intarg == WSKBD_RAW ? K_RAW : K_XLATE);
		break;
#endif
	}

	return (0);
}
@


1.31
log
@Remove 'option COMPAT_PCVT' now that X doen't use it anymore.
An X server built after april 3 is needed to be able to start X with
the new kernel.
ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.30 2016/03/28 09:08:22 matthieu Exp $ */
d38 1
d304 2
d311 2
d348 2
d376 2
d396 2
d405 2
d417 2
d435 2
d457 2
d477 2
@


1.30
log
@OpenBSD has stopped using the SVr4 KDENABIO/KDDISABIO ioctls for at
least 10 years. No need for special treatement on i386.

ok deraadt@@, millert@@, jca@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.29 2016/03/03 18:00:49 naddy Exp $ */
a322 10

#ifdef WSDISPLAY_COMPAT_PCVT
	    case VGAPCVTID:
#define id ((struct pcvtid *)data)
		strlcpy(id->name, "pcvt", sizeof id->name);
		id->rmajor = 3;
		id->rminor = 32;
#undef id
		return (0);
#endif
@


1.29
log
@Remove WSDISPLAY_COMPAT_SYSCONS.  We no longer run FreeBSD binary X11
servers.  Pointed out by jmc@@, ok deraadt@@ millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.28 2015/09/08 11:13:20 deraadt Exp $ */
a394 8
#if defined(__i386__)
	    case KDENABIO:
		if (suser(p, 0) || securelevel > 0)
			return (EPERM);
		/* FALLTHROUGH */
	    case KDDISABIO:
		return (0);
#else
d402 1
a402 1
#endif
@


1.28
log
@sizes for free(); checked by semarie
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.27 2015/03/14 03:38:50 jsg Exp $ */
a330 5
		return (0);
#endif
#ifdef WSDISPLAY_COMPAT_SYSCONS
	    case CONS_GETVERS:
		*(int *)data = 0x200;    /* version 2.0 */
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.26 2014/07/12 18:48:53 tedu Exp $ */
d103 1
a103 1
	sd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_NOWAIT);
d117 1
a117 1
		free(sd, M_DEVBUF, 0);
d136 1
a136 1
	free(sd, M_DEVBUF, 0);
@


1.26
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.25 2014/04/18 21:18:50 guenther Exp $ */
a32 1
#include <sys/ioctl.h>
@


1.25
log
@For the WSDISPLAY_COMPAT_USL protocol, send the synchronizing signals to
the process, not just the thread.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.24 2012/03/28 22:26:10 deraadt Exp $ */
d118 1
a118 1
		free(sd, M_DEVBUF);
d137 1
a137 1
	free(sd, M_DEVBUF);
@


1.24
log
@guenther notes that s_pid must also move to match
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.23 2012/03/28 20:18:32 deraadt Exp $ */
d54 1
a54 1
	struct proc *s_proc;
d68 1
a68 1
		       struct proc *, int, int, int);
d95 2
a96 2
usl_sync_init(struct wsscreen *scr, struct usl_syncdata **sdp, struct proc *p,
    int acqsig, int relsig, int frsig)
d108 2
a109 2
	sd->s_proc = p->p_p->ps_mainproc;
	sd->s_pid = sd->s_proc->p_pid;
d143 1
a143 1
	if (sd->s_proc == pfind(sd->s_pid))
d181 1
a181 1
	psignal(sd->s_proc, sd->s_relsig);
d240 1
a240 1
	psignal(sd->s_proc, sd->s_acqsig);
d361 1
a361 1
			res = usl_sync_init(scr, &sd, p, newmode->acqsig,
@


1.23
log
@Yet another ioctl-related pid value.  Should be the master of the
thread, aka. p_p->ps_pid.
ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.22 2011/04/05 12:50:15 guenther Exp $ */
d108 2
a109 2
	sd->s_proc = p;
	sd->s_pid = p->p_p->ps_pid;
@


1.22
log
@Push COMPAT_FREEBSD in front of a whale.  Buggy, out of date, no
one has been weeding it, and it makes life harder.

Toasts of Brennivin for its passing from many; diff ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.21 2010/08/28 12:48:14 miod Exp $ */
d109 1
a109 1
	sd->s_pid = p->p_pid;
@


1.21
log
@ansify function definitions, and constify a few arrays while there.
no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.20 2008/09/10 14:01:23 blambert Exp $ */
a406 15
#if defined(COMPAT_FREEBSD)
		{
		struct trapframe *fp = (struct trapframe *)p->p_md.md_regs;
		extern struct emul emul_freebsd_aout;
		extern struct emul emul_freebsd_elf;

		if (p->p_emul == &emul_freebsd_aout ||
		    p->p_emul == &emul_freebsd_elf) {
			if (cmd == KDENABIO)
				fp->tf_eflags |= PSL_IOPL;
			else
				fp->tf_eflags &= ~PSL_IOPL;
			}
		}
#endif
@


1.20
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.19 2007/02/14 01:12:16 jsg Exp $ */
d95 2
a96 5
usl_sync_init(scr, sdp, p, acqsig, relsig, frsig)
	struct wsscreen *scr;
	struct usl_syncdata **sdp;
	struct proc *p;
	int acqsig, relsig, frsig;
d126 1
a126 2
usl_sync_done(sd)
	struct usl_syncdata *sd;
d141 1
a141 2
usl_sync_check(sd)
	struct usl_syncdata *sd;
d151 1
a151 2
usl_sync_get(scr)
	struct wsscreen *scr;
d161 2
a162 5
usl_detachproc(cookie, waitok, callback, cbarg)
	void *cookie;
	int waitok;
	void (*callback)(void *, int, int);
	void *cbarg;
d188 1
a188 3
usl_detachack(sd, ack)
	struct usl_syncdata *sd;
	int ack;
d205 1
a205 2
usl_detachtimeout(arg)
	void *arg;
d225 2
a226 5
usl_attachproc(cookie, waitok, callback, cbarg)
	void *cookie;
	int waitok;
	void (*callback)(void *, int, int);
	void *cbarg;
d247 1
a247 3
usl_attachack(sd, ack)
	struct usl_syncdata *sd;
	int ack;
d264 1
a264 2
usl_attachtimeout(arg)
	void *arg;
d284 2
a285 6
wsdisplay_usl_ioctl1(sc, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d348 2
a349 7
wsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
@


1.19
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.18 2006/10/16 15:51:26 tom Exp $ */
d191 1
a191 1
	timeout_add(&sd->s_detach_ch, wscompat_usl_synctimeout * hz);
d256 1
a256 1
	timeout_add(&sd->s_attach_ch, wscompat_usl_synctimeout * hz);
@


1.18
log
@Fix some more "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.17 2006/07/29 12:52:40 miod Exp $ */
d432 1
a432 1
		/* FALLTHRU */
@


1.17
log
@Do not fail KDENABIO and KDDISABIO ioctls on non-i386 platforms, this allows
older X servers to run; ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.16 2006/06/30 21:34:47 miod Exp $ */
d184 1
a184 1
	 * Is is supposed to reply with a VT_RELDISP ioctl(), so
@


1.16
log
@Make routines which may set PSL_IOPL consistent wrt the securelevel for
which this is allowed; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.15 2004/04/02 04:39:51 deraadt Exp $ */
d428 1
d434 1
a434 1
#if defined(__i386__) && defined(COMPAT_FREEBSD)
d437 10
a446 4
		if (cmd == KDENABIO)
			fp->tf_eflags |= PSL_IOPL;
		else
			fp->tf_eflags &= ~PSL_IOPL;
d450 9
@


1.15
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.14 2003/08/15 20:32:18 tedu Exp $ */
d344 1
a344 1
#undef s
d429 1
a429 1
		if (suser(p, 0) || securelevel > 1)
@


1.14
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.13 2003/08/11 17:43:05 millert Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@Add signal number sanity checking to usl_sync_init().  This is not
strictly required since the signal routines do their own sanity checks,
but this way the VT_SETMODE ioctl() gets a nice EINVAL.
Potential problem pointed out by Jacques Vidrine; deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.12 2003/04/27 11:22:54 ho Exp $ */
d435 1
a435 1
		if (suser(p->p_ucred, &p->p_acflag) || securelevel > 1)
@


1.12
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.11 2002/03/14 03:16:08 millert Exp $ */
d110 3
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.10 2002/03/14 01:27:03 millert Exp $ */
d353 1
a353 1
		strcpy(id->name, "pcvt");
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.9 2001/06/04 12:48:37 ho Exp $ */
d79 1
a79 1
int usl_detachproc __P((void *, int, void (*)(void *, int, int), void *));
d82 1
a82 1
int usl_attachproc __P((void *, int, void (*)(void *, int, int), void *));
@


1.9
log
@Don't print these messages unless debugging. mickey@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.8 2001/05/16 19:40:05 mickey Exp $ */
d67 1
a67 1
	void (*s_callback) __P((void *, int, int));
d73 5
a77 5
int usl_sync_init __P((struct wsscreen *, struct usl_syncdata **,
		       struct proc *, int, int, int));
void usl_sync_done __P((struct usl_syncdata *));
int usl_sync_check __P((struct usl_syncdata *));
struct usl_syncdata *usl_sync_get __P((struct wsscreen *));
d80 2
a81 2
int usl_detachack __P((struct usl_syncdata *, int));
void usl_detachtimeout __P((void *));
d83 2
a84 2
int usl_attachack __P((struct usl_syncdata *, int));
void usl_attachtimeout __P((void *));
d89 1
a89 1
#define _usl_sync_check ((int (*) __P((void *)))usl_sync_check)
d91 1
a91 1
#define _usl_sync_destroy ((void (*) __P((void *)))usl_sync_done)
d173 1
a173 1
	void (*callback) __P((void *, int, int));
d243 1
a243 1
	void (*callback) __P((void *, int, int));
@


1.9.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.9 2001/06/04 12:48:37 ho Exp $ */
d67 1
a67 1
	void (*s_callback)(void *, int, int);
d73 12
a84 12
int usl_sync_init(struct wsscreen *, struct usl_syncdata **,
		       struct proc *, int, int, int);
void usl_sync_done(struct usl_syncdata *);
int usl_sync_check(struct usl_syncdata *);
struct usl_syncdata *usl_sync_get(struct wsscreen *);

int usl_detachproc(void *, int, void (*)(void *, int, int), void *);
int usl_detachack(struct usl_syncdata *, int);
void usl_detachtimeout(void *);
int usl_attachproc(void *, int, void (*)(void *, int, int), void *);
int usl_attachack(struct usl_syncdata *, int);
void usl_attachtimeout(void *);
d89 1
a89 1
#define _usl_sync_check ((int (*)(void *))usl_sync_check)
d91 1
a91 1
#define _usl_sync_destroy ((void (*)(void *))usl_sync_done)
d173 1
a173 1
	void (*callback)(void *, int, int);
d243 1
a243 1
	void (*callback)(void *, int, int);
@


1.9.4.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d353 1
a353 1
		strlcpy(id->name, "pcvt", sizeof id->name);
@


1.8
log
@it is not right to malloc() w/ WAITOK at attach time, put back NULL check and change to NOWAIT
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.7 2001/05/16 12:51:50 ho Exp $ */
d51 7
d153 1
a153 1
	printf("usl_sync_check: process %d died\n", sd->s_pid);
d205 1
a205 1
		printf("usl_detachack: not detaching\n");
d224 1
a224 1
	printf("usl_detachtimeout\n");
d227 1
a227 1
		printf("usl_detachtimeout: not detaching\n");
d270 1
a270 1
		printf("usl_attachack: not attaching\n");
d289 1
a289 1
	printf("usl_attachtimeout\n");
d292 1
a292 1
		printf("usl_attachtimeout: not attaching\n");
@


1.7
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.6 2001/05/16 05:07:51 millert Exp $ */
d103 3
a105 1
	sd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_WAITOK);
@


1.6
log
@kill COMPAT_{09,10,11} kernel options.  We still need kern_info_09.c and kern_ipc_10.c for other compat modules.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.5 2001/04/14 04:48:00 aaron Exp $ */
a103 2
	if (!sd)
		return (ENOMEM);
@


1.5
log
@Remove some static.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.4 2001/02/10 19:42:06 mickey Exp $ */
d429 1
a429 2
#if defined(__i386__)
#if defined(COMPAT_10) || defined(COMPAT_11) || defined(COMPAT_FREEBSD)
a436 1
#endif
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.5 2001/04/14 04:48:00 aaron Exp $ */
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.5.4.1 2001/05/14 22:26:30 niklas Exp $ */
a50 7
#ifdef WSDISPLAY_DEBUG
#define DPRINTF(x)	 if (wsdisplaydebug) printf x
int	wsdisplaydebug = 0;
#else
#define DPRINTF(x)
#endif

d103 1
a103 1
	sd = malloc(sizeof(struct usl_syncdata), M_DEVBUF, M_NOWAIT);
d146 1
a146 1
	DPRINTF(("usl_sync_check: process %d died\n", sd->s_pid));
d198 1
a198 1
		DPRINTF(("usl_detachack: not detaching\n"));
d217 1
a217 1
	DPRINTF(("usl_detachtimeout\n"));
d220 1
a220 1
		DPRINTF(("usl_detachtimeout: not detaching\n"));
d263 1
a263 1
		DPRINTF(("usl_attachack: not attaching\n"));
d282 1
a282 1
	DPRINTF(("usl_attachtimeout\n"));
d285 1
a285 1
		DPRINTF(("usl_attachtimeout: not attaching\n"));
d429 2
a430 1
#if defined(__i386__) && defined(COMPAT_FREEBSD)
d438 1
@


1.5.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d67 1
a67 1
	void (*s_callback)(void *, int, int);
d73 12
a84 12
int usl_sync_init(struct wsscreen *, struct usl_syncdata **,
		       struct proc *, int, int, int);
void usl_sync_done(struct usl_syncdata *);
int usl_sync_check(struct usl_syncdata *);
struct usl_syncdata *usl_sync_get(struct wsscreen *);

int usl_detachproc(void *, int, void (*)(void *, int, int), void *);
int usl_detachack(struct usl_syncdata *, int);
void usl_detachtimeout(void *);
int usl_attachproc(void *, int, void (*)(void *, int, int), void *);
int usl_attachack(struct usl_syncdata *, int);
void usl_attachtimeout(void *);
d89 1
a89 1
#define _usl_sync_check ((int (*)(void *))usl_sync_check)
d91 1
a91 1
#define _usl_sync_destroy ((void (*)(void *))usl_sync_done)
d173 1
a173 1
	void (*callback)(void *, int, int);
d243 1
a243 1
	void (*callback)(void *, int, int);
@


1.5.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.5.4.3 2002/03/28 15:09:10 niklas Exp $ */
d353 1
a353 1
		strlcpy(id->name, "pcvt", sizeof id->name);
@


1.5.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a109 3
	if (acqsig <= 0 || acqsig >= NSIG || relsig <= 0 || relsig >= NSIG ||
	    frsig <= 0 || frsig >= NSIG)
		return (EINVAL);
d432 1
a432 1
		if (suser(p, 0) || securelevel > 1)
@


1.5.4.6
log
@Merge with the trunk
@
text
@d16 6
@


1.4
log
@sync w/ netbsd; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.3 2000/08/01 13:51:18 mickey Exp $ */
d66 12
a77 14
static int usl_sync_init __P((struct wsscreen *, struct usl_syncdata **,
			      struct proc *, int, int, int));
static void usl_sync_done __P((struct usl_syncdata *));
static int usl_sync_check __P((struct usl_syncdata *));
static struct usl_syncdata *usl_sync_get __P((struct wsscreen *));

static int usl_detachproc __P((void *, int,
			       void (*)(void *, int, int), void *));
static int usl_detachack __P((struct usl_syncdata *, int));
static void usl_detachtimeout __P((void *));
static int usl_attachproc __P((void *, int,
			       void (*)(void *, int, int), void *));
static int usl_attachack __P((struct usl_syncdata *, int));
static void usl_attachtimeout __P((void *));
d93 1
a93 1
static int
d124 1
a124 1
static void
d140 1
a140 1
static int
d151 1
a151 1
static struct usl_syncdata *
d162 1
a162 1
static int
d192 1
a192 1
static int
d211 1
a211 1
static void
d232 1
a232 1
static int
d257 1
a257 1
static int
d276 1
a276 1
static void
@


1.3
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.2 2000/07/05 22:50:11 mickey Exp $ */
d325 2
d330 2
d376 3
a378 1
	int res;
a379 1
	int req, intarg;
a380 1
	void *arg;
@


1.2
log
@oops, late night typo
@
text
@d1 2
a2 2
/* $OpenBSD: wsdisplay_compat_usl.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
/* $NetBSD: wsdisplay_compat_usl.c,v 1.11 1999/12/06 18:52:23 drochner Exp $ */
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d189 1
a189 1
	timeout_set(&sd->s_detach_ch, wscompat_usl_synctimeout * hz);
@

