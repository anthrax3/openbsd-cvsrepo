head	1.31;
access;
symbols
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.29.0.4
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.28.0.4
	OPENBSD_5_7_BASE:1.28
	OPENBSD_5_6:1.27.0.4
	OPENBSD_5_6_BASE:1.27
	OPENBSD_5_5:1.26.0.4
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.24.0.14
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.21.0.2
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.20.0.2
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.19.0.2
	OPENBSD_4_1_BASE:1.19
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.15.0.4
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.10.0.4
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.2
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.9.0.2
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.10
	UBC:1.6.0.8
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.6
	OPENBSD_3_0_BASE:1.6
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.31
date	2015.09.10.18.14.52;	author mpi;	state Exp;
branches;
next	1.30;
commitid	yCNTJc2qmad1KZnd;

1.30
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.29;
commitid	NdgfPIGUgJxQPnT7;

1.29
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.28;
commitid	p4LJxGKbi0BU2cG6;

1.28
date	2015.01.11.03.04.53;	author deraadt;	state Exp;
branches;
next	1.27;
commitid	XKc3pv7L3K3tKn1q;

1.27
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.26;
commitid	OBNa5kfxQ2UXoiIw;

1.26
date	2014.01.26.17.48.08;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2013.12.02.02.36.22;	author krw;	state Exp;
branches;
next	1.24;

1.24
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.23;

1.23
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.22;

1.22
date	2008.06.07.20.32.16;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.17.01.33.33;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.14.09.03.34;	author tedu;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2006.08.05.19.08.41;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.05.16.59.57;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.04.28.20.06.00;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.14.11.00.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.15.19.03.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.15.11.29.15;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.30.23.01.55;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.11.04.24.40;	author jason;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.30.16.38.14;	author aaron;	state Exp;
branches
	1.6.4.1
	1.6.8.1;
next	1.5;

1.5
date	2001.02.02.08.08.17;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.01.05.56.14;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.13.15.35.17;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.12;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.26.33;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2002.03.06.02.11.48;	author niklas;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.6.8.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.6.8.2;

1.6.8.2
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.6.8.3;

1.6.8.3
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.31
log
@kqueue(2) support for wsmouse(4), wskbd(4) and wsmux(4).

Needed for libinput port.

ok guenther@@, miod@@
@
text
@/*	$OpenBSD: wsmux.c,v 1.30 2015/08/28 00:03:53 deraadt Exp $	*/
/*      $NetBSD: wsmux.c,v 1.37 2005/04/30 03:47:12 augustss Exp $      */

/*
 * Copyright (c) 1998, 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * Author: Lennart Augustsson <augustss@@carlstedt.se>
 *         Carlstedt Research & Technology
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "wsmux.h"
#include "wsdisplay.h"
#include "wskbd.h"
#include "wsmouse.h"

/*
 * wscons mux device.
 *
 * The mux device is a collection of real mice and keyboards and acts as 
 * a merge point for all the events from the different real devices.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wsmuxvar.h>

#ifdef WSMUX_DEBUG
#define DPRINTF(x)	if (wsmuxdebug) printf x
#define DPRINTFN(n,x)	if (wsmuxdebug > (n)) printf x
int	wsmuxdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * The wsmux pseudo device is used to multiplex events from several wsmouse,
 * wskbd, and/or wsmux devices together.
 * The devices connected together form a tree with muxes in the interior
 * and real devices (mouse and kbd) at the leaves.  The special case of
 * a tree with one node (mux or other) is supported as well.
 * Only the device at the root of the tree can be opened (if a non-root
 * device is opened the subtree rooted at that point is severed from the
 * containing tree).  When the root is opened it allocates a wseventvar
 * struct which all the nodes in the tree will send their events too.
 * An ioctl() performed on the root is propagated to all the nodes.
 * There are also ioctl() operations to add and remove nodes from a tree.
 */

int	wsmux_mux_open(struct wsevsrc *, struct wseventvar *);
int	wsmux_mux_close(struct wsevsrc *);

void	wsmux_do_open(struct wsmux_softc *, struct wseventvar *);

void	wsmux_do_close(struct wsmux_softc *);
#if NWSDISPLAY > 0
int	wsmux_evsrc_set_display(struct device *, struct device *);
#else
#define wsmux_evsrc_set_display NULL
#endif

int	wsmux_do_displayioctl(struct device *dev, u_long cmd, caddr_t data,
	    int flag, struct proc *p);
int	wsmux_do_ioctl(struct device *, u_long, caddr_t,int,struct proc *);

int	wsmux_add_mux(int, struct wsmux_softc *);

void	wsmuxattach(int);

struct wssrcops wsmux_srcops = {
	WSMUX_MUX,
	wsmux_mux_open, wsmux_mux_close, wsmux_do_ioctl, wsmux_do_displayioctl,
	wsmux_evsrc_set_display
};

/* From upper level */
void
wsmuxattach(int n)
{
}

/* Keep track of all muxes that have been allocated */
int nwsmux = 0;
struct wsmux_softc **wsmuxdevs = NULL;

/* Return mux n, create if necessary */
struct wsmux_softc *
wsmux_getmux(int n)
{
	struct wsmux_softc *sc;
	struct wsmux_softc **new, **old;
	int i;

	/* Make sure there is room for mux n in the table */
	if (n >= nwsmux) {
		old = wsmuxdevs;
		new = mallocarray(n + 1, sizeof (*wsmuxdevs),
		    M_DEVBUF, M_NOWAIT);
		if (new == NULL) {
			printf("wsmux_getmux: no memory for mux %d\n", n);
			return (NULL);
		}
		if (old != NULL)
			bcopy(old, new, nwsmux * sizeof(*wsmuxdevs));
		for (i = nwsmux; i < (n + 1); i++)
			new[i] = NULL;
		wsmuxdevs = new;
		nwsmux = n + 1;
		if (old != NULL)
			free(old, M_DEVBUF, nwsmux * sizeof(*wsmuxdevs));
	}

	sc = wsmuxdevs[n];
	if (sc == NULL) {
		sc = wsmux_create("wsmux", n);
		if (sc == NULL)
			printf("wsmux: attach out of memory\n");
		wsmuxdevs[n] = sc;
	}
	return (sc);
}

/*
 * open() of the pseudo device from device table.
 */
int
wsmuxopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wsmux_softc *sc;
	struct wseventvar *evar;
	int unit;

	unit = minor(dev);
	sc = wsmux_getmux(unit);
	if (sc == NULL)
		return (ENXIO);

	DPRINTF(("wsmuxopen: %s: sc=%p p=%p\n", sc->sc_base.me_dv.dv_xname, sc, p));
	
	if ((flags & (FREAD | FWRITE)) == FWRITE) {
		/* Not opening for read, only ioctl is available. */
		return (0);
	}

	if (sc->sc_base.me_parent != NULL) {
		/* Grab the mux out of the greedy hands of the parent mux. */
		DPRINTF(("wsmuxopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}

	if (sc->sc_base.me_evp != NULL)
		/* Already open. */
		return (EBUSY);

	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p->p_p;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	sc->sc_rawkbd = 0;
#endif

	wsmux_do_open(sc, evar);

	return (0);
}

/*
 * Open of a mux via the parent mux.
 */
int
wsmux_mux_open(struct wsevsrc *me, struct wseventvar *evar)
{
	struct wsmux_softc *sc = (struct wsmux_softc *)me;

#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp != NULL) {
		printf("wsmux_mux_open: busy\n");
		return (EBUSY);
	}
	if (sc->sc_base.me_parent == NULL) {
		printf("wsmux_mux_open: no parent\n");
		return (EINVAL);
	}
#endif

	wsmux_do_open(sc, evar);

	return (0);
}

/* Common part of opening a mux. */
void
wsmux_do_open(struct wsmux_softc *sc, struct wseventvar *evar)
{
	struct wsevsrc *me;
#ifdef DIAGNOSTIC
	int error;
#endif

	sc->sc_base.me_evp = evar; /* remember event variable, mark as open */

	/* Open all children. */
	TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmuxopen: %s: m=%p dev=%s\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname));
#ifdef DIAGNOSTIC
		if (me->me_evp != NULL) {
			printf("wsmuxopen: dev already in use\n");
			continue;
		}
		if (me->me_parent != sc) {
			printf("wsmux_do_open: bad child=%p\n", me);
			continue;
		}
		error = wsevsrc_open(me, evar);
		if (error) {
			DPRINTF(("wsmuxopen: open failed %d\n", error));
		}
#else
		/* ignore errors, failing children will not be marked open */
		(void)wsevsrc_open(me, evar);
#endif
	}
}

/*
 * close() of the pseudo device from device table.
 */
int
wsmuxclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wsmux_softc *sc =
	    (struct wsmux_softc *)wsmuxdevs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;

	if (evar == NULL)
		/* Not open for read */
		return (0);

	wsmux_do_close(sc);
	sc->sc_base.me_evp = NULL;
	wsevent_fini(evar);
	return (0);
}

/*
 * Close of a mux via the parent mux.
 */
int
wsmux_mux_close(struct wsevsrc *me)
{
	me->me_evp = NULL;
	wsmux_do_close((struct wsmux_softc *)me);
	return (0);
}

/* Common part of closing a mux. */
void
wsmux_do_close(struct wsmux_softc *sc)
{
	struct wsevsrc *me;

	DPRINTF(("wsmuxclose: %s: sc=%p\n", sc->sc_base.me_dv.dv_xname, sc));

	/* Close all the children. */
	TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmuxclose %s: m=%p dev=%s\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname));
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmuxclose: bad child=%p\n", me);
			continue;
		}
#endif
		(void)wsevsrc_close(me);
		me->me_evp = NULL;
	}
}

/*
 * read() of the pseudo device from device table.
 */
int
wsmuxread(dev_t dev, struct uio *uio, int flags)
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];
	struct wseventvar *evar;
	int error;

	evar = sc->sc_base.me_evp;
	if (evar == NULL) {
#ifdef DIAGNOSTIC
		/* XXX can we get here? */
		printf("wsmuxread: not open\n");
#endif
		return (EINVAL);
	}

	DPRINTFN(5,("wsmuxread: %s event read evar=%p\n",
		    sc->sc_base.me_dv.dv_xname, evar));
	error = wsevent_read(evar, uio, flags);
	DPRINTFN(5,("wsmuxread: %s event read ==> error=%d\n",
		    sc->sc_base.me_dv.dv_xname, error));
	return (error);
}

/*
 * ioctl of the pseudo device from device table.
 */
int
wsmuxioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	return wsmux_do_ioctl(&wsmuxdevs[minor(dev)]->sc_base.me_dv, cmd, data, flag, p);
}

/*
 * ioctl of a mux via the parent mux, continuation of wsmuxioctl().
 */
int
wsmux_do_ioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsevsrc *me;
	int error, ok;
	int s, put, get, n;
	struct wseventvar *evar;
	struct wscons_event *ev;
	struct wsmux_device_list *l;

	DPRINTF(("wsmux_do_ioctl: %s: enter sc=%p, cmd=%08lx\n",
		 sc->sc_base.me_dv.dv_xname, sc, cmd));

	switch (cmd) {
	case WSMUXIO_INJECTEVENT:
	case WSMUXIO_ADD_DEVICE:
	case WSMUXIO_REMOVE_DEVICE:
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
#endif
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
	case WSMUXIO_INJECTEVENT:
		/* Inject an event, e.g., from moused. */
		DPRINTF(("%s: inject\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL) {
			/* No event sink, so ignore it. */
			DPRINTF(("wsmux_do_ioctl: event ignored\n"));
			return (0);
		}

		s = spltty();
		get = evar->get;
		put = evar->put;
		ev = &evar->q[put];
		if (++put % WSEVENT_QSIZE == get) {
			put--;
			splx(s);
			return (ENOSPC);
		}
		if (put >= WSEVENT_QSIZE)
			put = 0;
		*ev = *(struct wscons_event *)data;
		nanotime(&ev->time);
		evar->put = put;
		WSEVENT_WAKEUP(evar);
		splx(s);
		return (0);
	case WSMUXIO_ADD_DEVICE:
#define d ((struct wsmux_device *)data)
		DPRINTF(("%s: add type=%d, no=%d\n", sc->sc_base.me_dv.dv_xname,
			 d->type, d->idx));
		switch (d->type) {
#if NWSMOUSE > 0
		case WSMUX_MOUSE:
			return (wsmouse_add_mux(d->idx, sc));
#endif
#if NWSKBD > 0
		case WSMUX_KBD:
			return (wskbd_add_mux(d->idx, sc));
#endif
		case WSMUX_MUX:
			return (wsmux_add_mux(d->idx, sc));
		default:
			return (EINVAL);
		}
	case WSMUXIO_REMOVE_DEVICE:
		DPRINTF(("%s: rem type=%d, no=%d\n", sc->sc_base.me_dv.dv_xname,
			 d->type, d->idx));
		/* Locate the device */
		TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
			if (me->me_ops->type == d->type &&
			    me->me_dv.dv_unit == d->idx) {
				DPRINTF(("wsmux_do_ioctl: detach\n"));
				wsmux_detach_sc(me);
				return (0);
			}
		}
		return (EINVAL);
#undef d

	case WSMUXIO_LIST_DEVICES:
		DPRINTF(("%s: list\n", sc->sc_base.me_dv.dv_xname));
		l = (struct wsmux_device_list *)data;
		n = 0;
		TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
			if (n >= WSMUX_MAXDEV)
				break;
			l->devices[n].type = me->me_ops->type;
			l->devices[n].idx = me->me_dv.dv_unit;
			n++;
		}
		l->ndevices = n;
		return (0);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	case WSKBDIO_SETMODE:
		sc->sc_rawkbd = *(int *)data;
		DPRINTF(("wsmux_do_ioctl: save rawkbd = %d\n", sc->sc_rawkbd));
		break;
#endif
	case FIONBIO:
		DPRINTF(("%s: FIONBIO\n", sc->sc_base.me_dv.dv_xname));
		return (0);

	case FIOASYNC:
		DPRINTF(("%s: FIOASYNC\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		evar->async = *(int *)data != 0;
		return (0);
	case FIOSETOWN:
		DPRINTF(("%s: FIOSETOWN\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		if (-*(int *)data != evar->io->ps_pgid
		    && *(int *)data != evar->io->ps_pid)
			return (EPERM);
		return (0);
	case TIOCSPGRP:
		DPRINTF(("%s: TIOCSPGRP\n", sc->sc_base.me_dv.dv_xname));
		evar = sc->sc_base.me_evp;
		if (evar == NULL)
			return (EINVAL);
		if (*(int *)data != evar->io->ps_pgid)
			return (EPERM);
		return (0);
	default:
		DPRINTF(("%s: unknown\n", sc->sc_base.me_dv.dv_xname));
		break;
	}

	if (sc->sc_base.me_evp == NULL
#if NWSDISPLAY > 0
	    && sc->sc_displaydv == NULL
#endif
	    )
		return (EACCES);

	/* Return 0 if any of the ioctl() succeeds, otherwise the last error */
	error = 0;
	ok = 0;
	TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
#ifdef DIAGNOSTIC
		/* XXX check evp? */
		if (me->me_parent != sc) {
			printf("wsmux_do_ioctl: bad child %p\n", me);
			continue;
		}
#endif
		error = wsevsrc_ioctl(me, cmd, data, flag, p);
		DPRINTF(("wsmux_do_ioctl: %s: me=%p dev=%s ==> %d\n",
			 sc->sc_base.me_dv.dv_xname, me, me->me_dv.dv_xname,
			 error));
		if (!error)
			ok = 1;
	}
	if (ok)
		error = 0;

	return (error);
}

/*
 * poll() of the pseudo device from device table.
 */
int
wsmuxpoll(dev_t dev, int events, struct proc *p)
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];

	if (sc->sc_base.me_evp == NULL) {
#ifdef DIAGNOSTIC
		printf("wsmuxpoll: not open\n");
#endif
		return (POLLERR);
	}

	return (wsevent_poll(sc->sc_base.me_evp, events, p));
}

int
wsmuxkqfilter(dev_t dev, struct knote *kn)
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (ENXIO);
	return (wsevent_kqfilter(sc->sc_base.me_evp, kn));
}

/*
 * Add mux unit as a child to muxsc.
 */
int
wsmux_add_mux(int unit, struct wsmux_softc *muxsc)
{
	struct wsmux_softc *sc, *m;

	sc = wsmux_getmux(unit);
	if (sc == NULL)
		return (ENXIO);

	DPRINTF(("wsmux_add_mux: %s(%p) to %s(%p)\n",
		 sc->sc_base.me_dv.dv_xname, sc, muxsc->sc_base.me_dv.dv_xname,
		 muxsc));

	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);

	/* The mux we are adding must not be an ancestor of itself. */
	for (m = muxsc; m != NULL ; m = m->sc_base.me_parent)
		if (m == sc)
			return (EINVAL);

	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}

/* Create a new mux softc. */
struct wsmux_softc *
wsmux_create(const char *name, int unit)
{
	struct wsmux_softc *sc;

	DPRINTF(("wsmux_create: allocating\n"));
	sc = malloc(sizeof *sc, M_DEVBUF, M_NOWAIT | M_ZERO);
	if (sc == NULL)
		return (NULL);
	TAILQ_INIT(&sc->sc_cld);
	snprintf(sc->sc_base.me_dv.dv_xname, sizeof sc->sc_base.me_dv.dv_xname,
		 "%s%d", name, unit);
	sc->sc_base.me_dv.dv_unit = unit;
	sc->sc_base.me_ops = &wsmux_srcops;
	sc->sc_kbd_layout = KB_NONE;
	return (sc);
}

/* Attach me as a child to sc. */
int
wsmux_attach_sc(struct wsmux_softc *sc, struct wsevsrc *me)
{
	int error;

	if (sc == NULL)
		return (EINVAL);

	DPRINTF(("wsmux_attach_sc: %s(%p): type=%d\n",
		 sc->sc_base.me_dv.dv_xname, sc, me->me_ops->type));

#ifdef DIAGNOSTIC
	if (me->me_parent != NULL) {
		printf("wsmux_attach_sc: busy\n");
		return (EBUSY);
	}
#endif
	me->me_parent = sc;
	TAILQ_INSERT_TAIL(&sc->sc_cld, me, me_next);

	error = 0;
#if NWSDISPLAY > 0
	if (sc->sc_displaydv != NULL) {
		/* This is a display mux, so attach the new device to it. */
		DPRINTF(("wsmux_attach_sc: %s: set display %p\n",
			 sc->sc_base.me_dv.dv_xname, sc->sc_displaydv));
		if (me->me_ops->dsetdisplay != NULL) {
			error = wsevsrc_set_display(me, sc->sc_displaydv);
			/* Ignore that the console already has a display. */
			if (error == EBUSY)
				error = 0;
			if (!error) {
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_attach_sc: %s set rawkbd=%d\n",
					 me->me_dv.dv_xname, sc->sc_rawkbd));
				(void)wsevsrc_ioctl(me, WSKBDIO_SETMODE,
						    &sc->sc_rawkbd, FWRITE, 0);
#endif
			}
		}
	}
#endif
	if (sc->sc_base.me_evp != NULL) {
		/* Mux is open, so open the new subdevice */
		DPRINTF(("wsmux_attach_sc: %s: calling open of %s\n",
			 sc->sc_base.me_dv.dv_xname, me->me_dv.dv_xname));
		error = wsevsrc_open(me, sc->sc_base.me_evp);
	} else {
		DPRINTF(("wsmux_attach_sc: %s not open\n",
			 sc->sc_base.me_dv.dv_xname));
	}

	if (error) {
		me->me_parent = NULL;
		TAILQ_REMOVE(&sc->sc_cld, me, me_next);
	}

	DPRINTF(("wsmux_attach_sc: %s(%p) done, error=%d\n",
		 sc->sc_base.me_dv.dv_xname, sc, error));
	return (error);
}

/* Remove me from the parent. */
void
wsmux_detach_sc(struct wsevsrc *me)
{
	struct wsmux_softc *sc = me->me_parent;

	DPRINTF(("wsmux_detach_sc: %s(%p) parent=%p\n",
		 me->me_dv.dv_xname, me, sc));

#ifdef DIAGNOSTIC
	if (sc == NULL) {
		printf("wsmux_detach_sc: %s has no parent\n",
		       me->me_dv.dv_xname);
		return;
	}
#endif

#if NWSDISPLAY > 0
	if (sc->sc_displaydv != NULL) {
		if (me->me_ops->dsetdisplay != NULL)
			/* ignore error, there's nothing we can do */
			(void)wsevsrc_set_display(me, NULL);
	} else
#endif
		if (me->me_evp != NULL) {
		DPRINTF(("wsmux_detach_sc: close\n"));
		/* mux device is open, so close multiplexee */
		(void)wsevsrc_close(me);
	}

	TAILQ_REMOVE(&sc->sc_cld, me, me_next);
	me->me_parent = NULL;

	DPRINTF(("wsmux_detach_sc: done sc=%p\n", sc));
}

/*
 * Display ioctl() of a mux via the parent mux.
 */
int
wsmux_do_displayioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsevsrc *me;
	int error, ok;

	DPRINTF(("wsmux_displayioctl: %s: sc=%p, cmd=%08lx\n",
		 sc->sc_base.me_dv.dv_xname, sc, cmd));

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (cmd == WSKBDIO_SETMODE) {
		sc->sc_rawkbd = *(int *)data;
		DPRINTF(("wsmux_displayioctl: rawkbd = %d\n", sc->sc_rawkbd));
	}
#endif

	/*
	 * Return 0 if any of the ioctl() succeeds, otherwise the last error.
	 * Return -1 if no mux component accepts the ioctl.
	 */
	error = -1;
	ok = 0;
	TAILQ_FOREACH(me, &sc->sc_cld, me_next) {
		DPRINTF(("wsmux_displayioctl: me=%p\n", me));
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmux_displayioctl: bad child %p\n", me);
			continue;
		}
#endif
		if (me->me_ops->ddispioctl != NULL) {
			error = wsevsrc_display_ioctl(me, cmd, data, flag, p);
			DPRINTF(("wsmux_displayioctl: me=%p dev=%s ==> %d\n",
				 me, me->me_dv.dv_xname, error));
			if (!error)
				ok = 1;
		}
	}
	if (ok)
		error = 0;

	return (error);
}

#if NWSDISPLAY > 0
/*
 * Set display of a mux via the parent mux.
 */
int
wsmux_evsrc_set_display(struct device *dv, struct device *displaydv)
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;

	DPRINTF(("wsmux_evsrc_set_display: %s: displaydv=%p\n",
		 sc->sc_base.me_dv.dv_xname, displaydv));

	if (displaydv != NULL) {
		if (sc->sc_displaydv != NULL)
			return (EBUSY);
	} else {
		if (sc->sc_displaydv == NULL)
			return (ENXIO);
	}

	return wsmux_set_display(sc, displaydv);
}

int
wsmux_set_display(struct wsmux_softc *sc, struct device *displaydv)
{
	struct device *odisplaydv;
	struct wsevsrc *me;
	struct wsmux_softc *nsc = displaydv ? sc : NULL;
	int error, ok;

	odisplaydv = sc->sc_displaydv;
	sc->sc_displaydv = displaydv;

	if (displaydv) {
		DPRINTF(("%s: connecting to %s\n",
		       sc->sc_base.me_dv.dv_xname, displaydv->dv_xname));
	}
	ok = 0;
	error = 0;
	TAILQ_FOREACH(me, &sc->sc_cld,me_next) {
#ifdef DIAGNOSTIC
		if (me->me_parent != sc) {
			printf("wsmux_set_display: bad child parent %p\n", me);
			continue;
		}
#endif
		if (me->me_ops->dsetdisplay != NULL) {
			error = wsevsrc_set_display(me,
			    nsc ? nsc->sc_displaydv : NULL);
			DPRINTF(("wsmux_set_display: m=%p dev=%s error=%d\n",
				 me, me->me_dv.dv_xname, error));
			if (!error) {
				ok = 1;
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_set_display: %s set rawkbd=%d\n"
,
					 me->me_dv.dv_xname, sc->sc_rawkbd));
				(void)wsevsrc_ioctl(me, WSKBDIO_SETMODE,
						    &sc->sc_rawkbd, FWRITE, 0);
#endif
			}
		}
	}
	if (ok)
		error = 0;

	if (displaydv == NULL) {
		DPRINTF(("%s: disconnecting from %s\n",
		       sc->sc_base.me_dv.dv_xname, odisplaydv->dv_xname));
	}

	return (error);
}
#endif /* NWSDISPLAY > 0 */

uint32_t
wsmux_get_layout(struct wsmux_softc *sc)
{
	return sc->sc_kbd_layout;
}

void
wsmux_set_layout(struct wsmux_softc *sc, uint32_t layout)
{
	if ((layout & KB_DEFAULT) == 0)
		sc->sc_kbd_layout = layout;
}
@


1.30
log
@fairly simple sizes for free(); ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.29 2015/03/14 03:38:50 jsg Exp $	*/
d543 10
@


1.29
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.28 2015/01/11 03:04:53 deraadt Exp $	*/
d148 1
a148 1
			free(old, M_DEVBUF, 0);
@


1.28
log
@use mallocarray() when reallocating the mux table
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.27 2014/07/12 18:48:53 tedu Exp $	*/
a62 1
#include <dev/wscons/wscons_callbacks.h>
@


1.27
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.26 2014/01/26 17:48:08 miod Exp $	*/
d136 2
a137 2
		new = (struct wsmux_softc **)
		    malloc((n + 1) * sizeof (*wsmuxdevs), M_DEVBUF, M_NOWAIT);
@


1.26
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.25 2013/12/02 02:36:22 krw Exp $	*/
d149 1
a149 1
			free(old, M_DEVBUF);
@


1.25
log
@CIRCLEQ begone.

ok jsing@@ (who actually ok'd the systat one too, not millert@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.24 2010/07/26 01:56:27 guenther Exp $	*/
d522 1
a522 1
	if (ok) {
a523 5
		if (cmd == WSKBDIO_SETENCODING) {
			sc->sc_kbd_layout = *((kbd_t *)data);
		}

	}
a630 4
				if (sc->sc_kbd_layout != KB_NONE)
					(void)wsevsrc_ioctl(me,
					    WSKBDIO_SETENCODING,
					    &sc->sc_kbd_layout, FWRITE, 0);
d815 13
@


1.24
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.23 2008/06/26 05:42:19 ray Exp $	*/
d242 1
a242 1
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d305 1
a305 1
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d434 1
a434 1
		CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d449 1
a449 1
		CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d507 1
a507 1
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d588 1
a588 1
	CIRCLEQ_INIT(&sc->sc_cld);
d616 1
a616 1
	CIRCLEQ_INSERT_TAIL(&sc->sc_cld, me, me_next);
d656 1
a656 1
		CIRCLEQ_REMOVE(&sc->sc_cld, me, me_next);
d694 1
a694 1
	CIRCLEQ_REMOVE(&sc->sc_cld, me, me_next);
d727 1
a727 1
	CIRCLEQ_FOREACH(me, &sc->sc_cld, me_next) {
d789 1
a789 1
	CIRCLEQ_FOREACH(me, &sc->sc_cld,me_next) {
@


1.23
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.22 2008/06/07 20:32:16 miod Exp $	*/
d196 1
a196 1
	evar->io = p;
d480 2
a481 2
		if (-*(int *)data != evar->io->p_pgid
		    && *(int *)data != evar->io->p_pid)
d489 1
a489 1
		if (*(int *)data != evar->io->p_pgid)
@


1.22
log
@Do not stupidly dereference NULL in wsmux_set_display() is invoked with NULL
as the second parameter.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.21 2007/09/17 01:33:33 krw Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.21
log
@Only the most obvious bzero() -> M_ZERO changes. No cast changes, no
MALLOC/FREE, etc. Just adding M_ZERO to malloc() and deleting an
immediately adjacent bzero().
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.20 2007/05/14 09:03:34 tedu Exp $	*/
d765 1
a765 1
	DPRINTF(("wsmux_set_display: %s: displaydv=%p\n",
d804 2
a805 1
			error = wsevsrc_set_display(me, nsc->sc_displaydv);
@


1.20
log
@wsmouse.h is needed for the NWSMOUSE test to actually work
found by and ok art
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.19 2006/11/01 03:37:24 tedu Exp $	*/
d592 1
a592 1
	sc = malloc(sizeof *sc, M_DEVBUF, M_NOWAIT);
a594 1
	bzero(sc, sizeof *sc);
@


1.19
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.18 2006/08/05 19:08:41 miod Exp $	*/
d43 1
@


1.18
log
@Oops, forgot these changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.17 2006/08/05 16:59:57 miod Exp $	*/
d64 1
d551 1
a551 1
		return (EACCES);
@


1.17
log
@On platforms which do not use wsmux (because they can't have more than one
keyboard at once), force wskbd0 to connect to wsdisplay0 even if they are
not console devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.16 2006/04/28 20:06:00 miod Exp $	*/
d631 1
a631 1
			error = wsevsrc_set_display(me, &sc->sc_base);
a761 1
	struct wsmux_softc *muxsc = (struct wsmux_softc *)ame;
d803 1
a803 1
			error = wsevsrc_set_display(me, &nsc->sc_base);
@


1.16
log
@In wsmux_set_display(), pass FWRITE instead of 0 when invoking ioctl
WSKBDIO_SETMODE, or it will be ignored.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.15 2005/08/14 11:00:15 miod Exp $	*/
d101 1
a101 1
int	wsmux_evsrc_set_display(struct device *, struct wsevsrc *);
d760 1
a760 1
wsmux_evsrc_set_display(struct device *dv, struct wsevsrc *ame)
a763 1
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : NULL;
@


1.15
log
@Honor (the lack of) FWRITE in the various ioctl routines; with input from
fgs@@ and mickey@@; ok deraadt@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.14 2005/05/15 19:03:47 deraadt Exp $	*/
d815 1
a815 1
						    &sc->sc_rawkbd, 0, 0);
@


1.14
log
@only inside DIAGNOSTIC
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.13 2005/05/15 11:29:15 miod Exp $	*/
d380 11
a392 1

d640 1
a640 1
						    &sc->sc_rawkbd, 0, 0);
@


1.13
log
@Partial sync to the NetBSD wscons code, bringing a better wsmux behaviour
and bugfixes (the kqueue code, /dev/wsmuxctl and screen border color changes
have not been picked), keeping local changes.

Tested by many on alpha/cats/hp300/i386/macppc/sparc/sparc64/zaurus if not more.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.12 2004/06/24 19:35:24 tholo Exp $	*/
d240 1
d242 1
@


1.12
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 2
a2 2
/*	$OpenBSD: wsmux.c,v 1.11 2003/09/23 16:51:12 millert Exp $	*/
/*	$NetBSD: wsmux.c,v 1.9 2000/05/28 10:33:14 takemura Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
a43 2
#if NWSMUX > 0 || (NWSDISPLAY > 0 && NWSKBD > 0)

d66 1
d73 1
d77 1
d80 33
a112 10
struct wsplink {
	LIST_ENTRY(wsplink) next;
	int type;
	struct wsmux_softc *mux; /* our mux device */
	/* The rest of the fields reflect a value in the multiplexee. */
	struct device *sc;	/* softc */
	struct wseventvar *sc_mevents; /* event var */
	struct wsmux_softc **sc_muxp; /* pointer to us */
	struct wsmuxops *sc_ops;
};
d114 4
a117 10
int wsmuxdoclose(struct device *, int, int, struct proc *);
int wsmux_set_display(struct device *, struct wsmux_softc *);
int wsmux_isset_display(struct device *);

#if NWSMUX > 0
void wsmuxattach(int);

struct wsmuxops wsmux_muxops = {
	wsmuxopen, wsmuxdoclose, wsmuxdoioctl, wsmux_displayioctl,
	wsmux_set_display, wsmux_isset_display
d120 5
a124 1
void wsmux_setmax(int n);
d126 1
d130 3
a132 3
void
wsmux_setmax(n)
	int n;
d134 2
a136 1
	struct wsmux_softc **wsmuxdevs_tmp = NULL;
d138 1
d140 12
a151 20
		if (wsmuxdevs != NULL) {
			wsmuxdevs_tmp = malloc(nwsmux * sizeof(*wsmuxdevs_tmp),
			    M_DEVBUF, M_NOWAIT);
			if (wsmuxdevs_tmp == 0)
				panic("wsmux_setmax: no mem");
			for (i = 0; i < nwsmux; i++)
				wsmuxdevs_tmp[i] = wsmuxdevs[i];
			free(wsmuxdevs, M_DEVBUF);
		}

		wsmuxdevs = malloc((n + 1) * sizeof(*wsmuxdevs), 
		    M_DEVBUF, M_NOWAIT);
		if (wsmuxdevs == NULL)
			panic("wsmux_setmax: no memory");
		memset(wsmuxdevs, 0, (n + 1) * sizeof(*wsmuxdevs));
		if (wsmuxdevs_tmp != NULL) {
			for (i = 0; i < nwsmux; i++)
				wsmuxdevs[i] = wsmuxdevs_tmp[i];
			free(wsmuxdevs_tmp, M_DEVBUF);
		}
d153 2
a155 1
}
a156 30
/* From upper level */
void
wsmuxattach(n)
	int n;
{
	int i;

	wsmux_setmax(n);	/* Make sure we have room for all muxes. */

	/* Make sure all muxes are there. */
	for (i = 0; i < nwsmux; i++)
		if (wsmuxdevs[i] == NULL)
			wsmuxdevs[i] = wsmux_create("wsmux", i);
}

/* From mouse or keyboard. */
void
wsmux_attach(n, type, dsc, ev, psp, ops)
	int n;
	int type;
        struct device *dsc;
	struct wseventvar *ev;
	struct wsmux_softc **psp;
	struct wsmuxops *ops;
{
	struct wsmux_softc *sc;
	int error;

	DPRINTF(("wsmux_attach: n=%d\n", n));
	wsmux_setmax(n);
d158 1
a158 1
	if (sc == 0) {
d160 1
a160 1
		if (sc == 0) {
a161 2
			return;
		}
d164 1
a164 23
	error = wsmux_attach_sc(sc, type, dsc, ev, psp, ops);
	if (error)
		printf("wsmux_attach: error=%d\n", error);
}

/* From mouse or keyboard. */
void
wsmux_detach(n, dsc)
	int n;
        struct device *dsc;
{
#ifdef DIAGNOSTIC
	int error;

	if (n >= nwsmux || n < 0) {
		printf("wsmux_detach: detach is out of range\n");
		return;
	}
	if ((error = wsmux_detach_sc(wsmuxdevs[n], dsc)))
		printf("wsmux_detach: error=%d\n", error);
#else
	(void)wsmux_detach_sc(wsmuxdevs[n], dsc);
#endif
d167 3
d171 1
a171 4
wsmuxopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d174 2
a175 2
	struct wsplink *m;
	int unit, error, nopen, lasterror;
d178 2
a179 2
	if (unit >= nwsmux ||	/* make sure it was attached */
	    (sc = wsmuxdevs[unit]) == NULL)
d182 3
a184 2
	DPRINTF(("wsmuxopen: %s: sc=%p\n", sc->sc_dv.dv_xname, sc));
	if (!(flags & FREAD)) {
d189 8
a196 1
	if (sc->sc_events.io)
d199 6
a204 25
	sc->sc_events.io = p;
	sc->sc_flags = flags;
	sc->sc_mode = mode;
	sc->sc_p = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */

	nopen = 0;
	lasterror = 0;
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (!m->sc_mevents->io && !*m->sc_muxp) {
			DPRINTF(("wsmuxopen: %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			error = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),
						 flags, mode, p);
			if (error) {
				/* Ignore opens that fail */
				lasterror = error;
				DPRINTF(("wsmuxopen: open failed %d\n", 
					 error));
			} else {
				nopen++;
				*m->sc_muxp = sc;
			}
		}
	}
d206 1
a206 5
	if (nopen == 0 && lasterror != 0) {
		wsevent_fini(&sc->sc_events);
		sc->sc_events.io = NULL;
		return (lasterror);
	}
d211 3
d215 1
a215 4
wsmuxclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d217 1
a217 2
	return wsmuxdoclose(&wsmuxdevs[minor(dev)]->sc_dv, flags, mode, p);
}
d219 10
a228 7
int
wsmuxread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];
d230 1
a230 2
	if (!sc->sc_events.io)
		return (EACCES);
d232 1
a232 1
	return (wsevent_read(&sc->sc_events, uio, flags));
d235 3
a237 7
int
wsmuxioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d239 2
a240 2
	return wsmuxdoioctl(&wsmuxdevs[minor(dev)]->sc_dv, cmd, data, flag, p);
}
d242 1
a242 7
int
wsmuxpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	struct wsmux_softc *sc = wsmuxdevs[minor(dev)];
d244 22
a265 4
	if (!sc->sc_events.io)
		return (EACCES);

	return (wsevent_poll(&sc->sc_events, events, p));
d268 3
d272 1
a272 3
wsmux_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
d274 3
a276 1
	struct wsmux_softc *sc, *m;
d278 3
a280 2
	if (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)
		return (ENXIO);
d282 4
a285 13
	DPRINTF(("wsmux_add_mux: %s to %s\n", sc->sc_dv.dv_xname,
		 muxsc->sc_dv.dv_xname));

	if (sc->sc_mux || sc->sc_events.io)
		return (EBUSY);

	/* The mux we are adding must not be an ancestor of it. */
	for (m = muxsc->sc_mux; m; m = m->sc_mux)
		if (m == sc)
			return (EINVAL);

	return (wsmux_attach_sc(muxsc, WSMUX_MUX, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wsmux_muxops));
d288 3
d292 1
a292 3
wsmux_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
d294 3
a296 9
	struct wsmux_softc *sc;

	if (unit < 0 || unit >= nwsmux || (sc = wsmuxdevs[unit]) == NULL)
		return (ENXIO);
	
	DPRINTF(("wsmux_rem_mux: %s from %s\n", sc->sc_dv.dv_xname,
		 muxsc->sc_dv.dv_xname));

	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
d299 3
a301 6
#endif /* NWSMUX > 0 */

struct wsmux_softc *
wsmux_create(name, unit)
	const char *name;
	int unit;
d303 1
a303 1
	struct wsmux_softc *sc;
d305 1
a305 11
	DPRINTF(("wsmux_create: allocating\n"));
	sc = malloc(sizeof *sc, M_DEVBUF, M_NOWAIT);
	if (!sc)
		return (0);
	memset(sc, 0, sizeof *sc);
	LIST_INIT(&sc->sc_reals);
	snprintf(sc->sc_dv.dv_xname, sizeof sc->sc_dv.dv_xname,
		 "%s%d", name, unit);
	sc->sc_dv.dv_unit = unit;
	return (sc);
}
d307 9
a315 44
int
wsmux_attach_sc(sc, type, dsc, ev, psp, ops)
	struct wsmux_softc *sc;
	int type;
        struct device *dsc;
	struct wseventvar *ev;
	struct wsmux_softc **psp;
	struct wsmuxops *ops;
{
	struct wsplink *m;
	int error;

	DPRINTF(("wsmux_attach_sc: %s: type=%d dsc=%p, *psp=%p\n",
		 sc->sc_dv.dv_xname, type, dsc, *psp));
	m = malloc(sizeof *m, M_DEVBUF, M_NOWAIT);
	if (m == 0)
		return (ENOMEM);
	m->type = type;
	m->mux = sc;
	m->sc = dsc;
	m->sc_mevents = ev;
	m->sc_muxp = psp;
	m->sc_ops = ops;
	LIST_INSERT_HEAD(&sc->sc_reals, m, next);

	if (sc->sc_displaydv) {
		/* This is a display mux, so attach the new device to it. */
		DPRINTF(("wsmux_attach_sc: %s: set display %p\n", 
			 sc->sc_dv.dv_xname, sc->sc_displaydv));
		error = 0;
		if (m->sc_ops->dsetdisplay) {
			error = m->sc_ops->dsetdisplay(m->sc, sc);
			/* Ignore that the console already has a display. */
			if (error == EBUSY)
				error = 0;
			if (!error) {
				*m->sc_muxp = sc;
#ifdef WSDISPLAY_COMPAT_RAWKBD
				DPRINTF(("wsmux_attach_sc: on %s set rawkbd=%d\n",
					 m->sc->dv_xname, sc->sc_rawkbd));
				(void)m->sc_ops->dioctl(m->sc, 
					     WSKBDIO_SETMODE, 
					     (caddr_t)&sc->sc_rawkbd,
					     0, 0);
d317 2
a318 15
			}
		}
	} else if (sc->sc_events.io) {
		/* Mux is open, so open the new subdevice */
		DPRINTF(("wsmux_attach_sc: %s: calling open of %s\n",
			 sc->sc_dv.dv_xname, m->sc->dv_xname));
		/* mux already open, join in */
		error = m->sc_ops->dopen(makedev(0, m->sc->dv_unit),
					 sc->sc_flags, sc->sc_mode, sc->sc_p);
		if (!error)
			*m->sc_muxp = sc;
	} else {
		DPRINTF(("wsmux_attach_sc: %s not open\n",
			 sc->sc_dv.dv_xname));
		error = 0;
a319 4
	DPRINTF(("wsmux_attach_sc: done sc=%p psp=%p *psp=%p\n", 
		 sc, psp, *psp));

	return (error);
d322 3
d326 1
a326 3
wsmux_detach_sc(sc, dsc)
	struct wsmux_softc *sc;
        struct device *dsc;
d328 3
a330 2
	struct wsplink *m;
	int error = 0;
d332 2
a333 1
	DPRINTF(("wsmux_detach_sc: %s: dsc=%p\n", sc->sc_dv.dv_xname, dsc));
d335 2
a336 4
	if (sc == 0) {
		printf("wsmux_detach_sc: not allocated\n");
		return (ENXIO);
	}
d338 1
a338 23

	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (m->sc == dsc)
			break;
	}
#ifdef DIAGNOSTIC
	if (!m) {
		printf("wsmux_detach_sc: not found\n");
		return (ENXIO);
	}
#endif
	if (sc->sc_displaydv ||
	    (m->sc_ops->dissetdisplay && m->sc_ops->dissetdisplay(m->sc))) {
		if (m->sc_ops->dsetdisplay)
			error = m->sc_ops->dsetdisplay(m->sc, 0);
		if (error)
			return (error);
		*m->sc_muxp = 0;
	} else if (*m->sc_muxp) {
		DPRINTF(("wsmux_detach_sc: close\n"));
		/* mux device is open, so close multiplexee */
		m->sc_ops->dclose(m->sc, FREAD, 0, 0);
		*m->sc_muxp = 0;
d341 6
a346 5
	LIST_REMOVE(m, next);

	free(m, M_DEVBUF);
	DPRINTF(("wsmux_detach_sc: done sc=%p\n", sc));
	return (0);
d349 5
a353 4
int wsmuxdoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
d355 1
a355 22
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;
	struct wsplink *m;

	DPRINTF(("wsmuxclose: %s: sc=%p\n", sc->sc_dv.dv_xname, sc));
	if (!(flags & FREAD)) {
		/* Nothing to do, because open didn't do anything. */
		return (0);
	}

	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (*m->sc_muxp == sc) {
			DPRINTF(("wsmuxclose %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			m->sc_ops->dclose(m->sc, flags, mode, p);
			*m->sc_muxp = 0;
		}
	}

	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;

	return (0);
d358 3
d362 2
a363 6
wsmuxdoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d366 1
a366 1
	struct wsplink *m;
d373 2
a374 2
	DPRINTF(("wsmuxdoioctl: %s: sc=%p, cmd=%08lx\n", 
		 sc->sc_dv.dv_xname, sc, cmd));
d377 1
a377 1
	case WSMUX_INJECTEVENT:
d379 8
a386 2
		if (!sc->sc_events.io)
			return (EACCES);
a387 1
		evar = &sc->sc_events;
d391 1
a398 1
		ev = &evar->q[put];
d405 1
a405 1
	case WSMUX_ADD_DEVICE:
d407 2
a417 1
#if NWSMUX > 0
a419 1
#endif
d423 11
a433 16
	case WSMUX_REMOVE_DEVICE:
		switch (d->type) {
#if NWSMOUSE > 0
		case WSMUX_MOUSE:
			return (wsmouse_rem_mux(d->idx, sc));
#endif
#if NWSKBD > 0
		case WSMUX_KBD:
			return (wskbd_rem_mux(d->idx, sc));
#endif
#if NWSMUX > 0
		case WSMUX_MUX:
			return (wsmux_rem_mux(d->idx, sc));
#endif
		default:
			return (EINVAL);
d435 1
d437 3
a439 1
	case WSMUX_LIST_DEVICES:
d441 6
a446 5
		for (n = 0, m = LIST_FIRST(&sc->sc_reals);
		     n < WSMUX_MAXDEV && m != NULL;
		     m = LIST_NEXT(m, next)) {
			l->devices[n].type = m->type;
			l->devices[n].idx = m->sc->dv_unit;
d454 1
a454 1
		DPRINTF(("wsmuxdoioctl: save rawkbd = %d\n", sc->sc_rawkbd));
d457 4
d462 14
a475 1
		sc->sc_events.async = *(int *)data != 0;
d478 5
a482 1
		if (*(int *)data != sc->sc_events.io->p_pgid)
d486 1
d490 5
a494 1
	if (sc->sc_events.io == NULL && sc->sc_displaydv == NULL)
d500 6
a505 9
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		DPRINTF(("wsmuxdoioctl: m=%p *m->sc_muxp=%p sc=%p\n",
			 m, *m->sc_muxp, sc));
		if (*m->sc_muxp == sc) {
			DPRINTF(("wsmuxdoioctl: %s: m=%p dev=%s\n", 
				 sc->sc_dv.dv_xname, m, m->sc->dv_xname));
			error = m->sc_ops->dioctl(m->sc, cmd, data, flag, p);
			if (!error)
				ok = 1;
d507 7
d515 1
a515 1
	if (ok)
d517 5
d526 66
d593 107
a699 6
wsmux_displayioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d702 1
a702 1
	struct wsplink *m;
d705 2
a706 2
	DPRINTF(("wsmux_displayioctl: %s: sc=%p, cmd=%08lx\n", 
		 sc->sc_dv.dv_xname, sc, cmd));
d712 1
a712 1
	}		
d715 1
a715 1
	/* 
d721 12
a732 8
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		DPRINTF(("wsmux_displayioctl: m=%p sc=%p sc_muxp=%p\n", 
			 m, sc, *m->sc_muxp));
		if (m->sc_ops->ddispioctl && *m->sc_muxp == sc) {
			error = m->sc_ops->ddispioctl(m->sc, cmd, data,
						      flag, p);
			DPRINTF(("wsmux_displayioctl: m=%p dev=%s ==> %d\n", 
				 m, m->sc->dv_xname, error));
d743 4
d748 1
a748 3
wsmux_set_display(dv, muxsc)
	struct device *dv;
	struct wsmux_softc *muxsc;
d750 1
d752 1
a752 5
	struct wsmux_softc *nsc = muxsc ? sc : 0;
	struct device *displaydv = muxsc ? muxsc->sc_displaydv : 0;
	struct device *odisplaydv;
	struct wsplink *m;
	int error, ok;
d755 1
a755 1
		 sc->sc_dv.dv_xname, displaydv));
d757 2
a758 2
	if (displaydv) {
		if (sc->sc_displaydv)
d765 11
d779 4
a782 3
	if (displaydv)
		printf("%s: connecting to %s\n",
		       sc->sc_dv.dv_xname, displaydv->dv_xname);
d785 11
a795 7
	for (m = LIST_FIRST(&sc->sc_reals); m; m = LIST_NEXT(m, next)) {
		if (m->sc_ops->dsetdisplay &&
		    (nsc ? m->sc_mevents->io == 0 && *m->sc_muxp == 0 : 
		           *m->sc_muxp == sc)) {
			error = m->sc_ops->dsetdisplay(m->sc, nsc);
			DPRINTF(("wsmux_set_display: m=%p dev=%s error=%d\n", 
				 m, m->sc->dv_xname, error));
a797 1
				*m->sc_muxp = nsc;
d799 5
a803 6
				DPRINTF(("wsmux_set_display: on %s set rawkbd=%d\n",
					 m->sc->dv_xname, sc->sc_rawkbd));
				(void)m->sc_ops->dioctl(m->sc, 
					     WSKBDIO_SETMODE, 
					     (caddr_t)&sc->sc_rawkbd,
					     0, 0);
d811 4
a814 3
	if (displaydv == NULL)
		printf("%s: disconnecting from %s\n", 
		       sc->sc_dv.dv_xname, odisplaydv->dv_xname);
d818 1
a818 14

int
wsmux_isset_display(dv)
	struct device *dv;
{
	struct wsmux_softc *sc = (struct wsmux_softc *)dv;

	if (sc->sc_displaydv != NULL)
		return (1);

	return (0);
}

#endif /* NWSMUX > 0 || (NWSDISPLAY > 0 && NWSKBD > 0) */
@


1.11
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.10 2002/10/12 01:09:44 krw Exp $	*/
a528 1
	struct timeval xxxtime;
d553 1
a553 2
		microtime(&xxxtime);
		TIMEVAL_TO_TIMESPEC(&xxxtime, &ev->time);
@


1.10
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.9 2002/04/30 23:01:55 mickey Exp $	*/
d297 1
a297 1
wsmuxselect(dev, events, p)
@


1.9
log
@cdev_decl is done in conf.h, do not dupe here
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.8 2002/03/14 01:27:03 millert Exp $	*/
d119 1
a119 1
				panic("wsmux_setmax: no mem\n");
d128 1
a128 1
			panic("wsmux_setmax: no memory\n");
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.7 2002/01/11 04:24:40 jason Exp $	*/
a94 2
cdev_decl(wsmux);

@


1.7
log
@Get order of operations correct so that we clear the wsmux array and
initialize it correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.6 2001/03/30 16:38:14 aaron Exp $	*/
d90 3
a92 3
int wsmuxdoclose __P((struct device *, int, int, struct proc *));
int wsmux_set_display __P((struct device *, struct wsmux_softc *));
int wsmux_isset_display __P((struct device *));
d97 1
a97 1
void wsmuxattach __P((int));
d104 1
a104 1
void wsmux_setmax __P((int n));
@


1.6
log
@Add a new wsmuxop, dissetdisplay, which wsmux uses to disocver whether a mux
device is connected to a display or not. Use it in wsmux_detach_sc(). This
fixes a problem I've been struggling with whereby the machine panics if I
detach a USB keyboard before disconnecting it from wsdisplay.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.5 2001/02/02 08:08:17 aaron Exp $	*/
d113 1
a113 1
	int i = 0;
d122 1
a122 1
			for (; i < nwsmux; i++)
d127 1
a127 1
		wsmuxdevs = malloc(n + 1 * sizeof(*wsmuxdevs), 
d129 1
a129 1
		if (wsmuxdevs == 0)
d131 1
a131 2
		for (; i < n + 1; i++)
			wsmuxdevs[i] = 0;
d152 1
a152 1
		if (!wsmuxdevs[i])
@


1.6.8.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.7 2002/01/11 04:24:40 jason Exp $	*/
d113 1
a113 1
	int i;
d122 1
a122 1
			for (i = 0; i < nwsmux; i++)
d127 1
a127 1
		wsmuxdevs = malloc((n + 1) * sizeof(*wsmuxdevs), 
d129 1
a129 1
		if (wsmuxdevs == NULL)
d131 2
a132 1
		memset(wsmuxdevs, 0, (n + 1) * sizeof(*wsmuxdevs));
d153 1
a153 1
		if (wsmuxdevs[i] == NULL)
@


1.6.8.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.6.8.1 2002/01/31 22:55:39 niklas Exp $	*/
d90 3
a92 3
int wsmuxdoclose(struct device *, int, int, struct proc *);
int wsmux_set_display(struct device *, struct wsmux_softc *);
int wsmux_isset_display(struct device *);
d95 3
a97 1
void wsmuxattach(int);
d104 1
a104 1
void wsmux_setmax(int n);
@


1.6.8.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.6.8.2 2002/06/11 03:42:32 art Exp $	*/
d119 1
a119 1
				panic("wsmux_setmax: no mem");
d128 1
a128 1
			panic("wsmux_setmax: no memory");
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.6 2001/03/30 16:38:14 aaron Exp $	*/
@


1.6.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d113 1
a113 1
	int i;
d122 1
a122 1
			for (i = 0; i < nwsmux; i++)
d127 1
a127 1
		wsmuxdevs = malloc((n + 1) * sizeof(*wsmuxdevs), 
d129 1
a129 1
		if (wsmuxdevs == NULL)
d131 2
a132 1
		memset(wsmuxdevs, 0, (n + 1) * sizeof(*wsmuxdevs));
d153 1
a153 1
		if (wsmuxdevs[i] == NULL)
@


1.6.4.3
log
@Merge in -current from roughly a week ago
@
text
@d90 3
a92 3
int wsmuxdoclose(struct device *, int, int, struct proc *);
int wsmux_set_display(struct device *, struct wsmux_softc *);
int wsmux_isset_display(struct device *);
d97 1
a97 1
void wsmuxattach(int);
d104 1
a104 1
void wsmux_setmax(int n);
@


1.6.4.4
log
@Sync the SMP branch with 3.3
@
text
@d95 2
d121 1
a121 1
				panic("wsmux_setmax: no mem");
d130 1
a130 1
			panic("wsmux_setmax: no memory");
@


1.6.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d297 1
a297 1
wsmuxpoll(dev, events, p)
@


1.5
log
@Fix an uninitialized variable; henric@@aimnet.com
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.4 2001/02/01 05:56:14 aaron Exp $	*/
d92 1
d101 1
a101 1
	wsmux_set_display
d468 2
a469 1
	if (sc->sc_displaydv) {
d756 12
@


1.4
log
@Fix the wsmux_setmax() function. By the time wsmuxattach() runs (through hook
in ioconf.c created by the wsmux pseudo-device), an input device may have
already attached itself as a mux. We don't want to whack these pointers.

Net result: the PS/2 mouse on my laptop is now properly mux'd. Right now I
have my laptop's builtin keyboard and builtin mouse (ps/2), plus I have
attached a separate USB keyboard and USB mouse. All four devices are accepting
input at the same time. If I want to go mobile, I can unhook the USB devices
and my builtin devices will still work without changing X settings. Very cool.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.3 2000/11/13 15:35:17 aaron Exp $	*/
d112 1
a112 1
	int i;
d121 1
a121 1
			for (i = 0; i < nwsmux; i++)
@


1.3
log
@Make this compile under OpenBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.2 2000/08/01 13:51:18 mickey Exp $	*/
d113 1
d116 8
a123 5
		i = nwsmux;
		nwsmux = n + 1;
		if (nwsmux != 0) {
			if (wsmuxdevs)
				free(wsmuxdevs, M_DEVBUF);
d125 3
a127 2
		wsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), 
				   M_DEVBUF, M_NOWAIT);
d130 1
a130 1
		for (; i < nwsmux; i++)
d132 6
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wsmux.c,v 1.1 2000/05/16 23:49:12 mickey Exp $	*/
d106 1
a106 1
struct wsmux_softc **wsmuxdevs;
d117 6
a122 7
		if (nwsmux != 0)
			wsmuxdevs = realloc(wsmuxdevs, 
					    nwsmux * sizeof (*wsmuxdevs), 
					    M_DEVBUF, M_NOWAIT);
		else
			wsmuxdevs = malloc(nwsmux * sizeof (*wsmuxdevs), 
					   M_DEVBUF, M_NOWAIT);
d288 1
a288 1
wsmuxpoll(dev, events, p)
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: wsmux.c,v 1.8 1999/11/08 10:10:25 augustss Exp $	*/
d356 1
a356 1
	bzero(sc, sizeof *sc);
d604 7
@

