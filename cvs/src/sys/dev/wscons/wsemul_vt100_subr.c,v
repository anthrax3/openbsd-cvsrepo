head	1.21;
access;
symbols
	OPENBSD_6_2_BASE:1.21
	OPENBSD_6_1:1.21.0.8
	OPENBSD_6_1_BASE:1.21
	OPENBSD_6_0:1.21.0.4
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.21.0.2
	OPENBSD_5_9_BASE:1.21
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.8
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.14
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.12
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.10
	OPENBSD_5_0:1.17.0.8
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.6
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.4
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.2
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.15.0.10
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.15.0.6
	OPENBSD_4_5_BASE:1.15
	OPENBSD_4_4:1.15.0.4
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.15.0.2
	OPENBSD_4_3_BASE:1.15
	OPENBSD_4_2:1.14.0.4
	OPENBSD_4_2_BASE:1.14
	OPENBSD_4_1:1.14.0.2
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.13.0.6
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.11.0.2
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.10.0.4
	OPENBSD_3_5_BASE:1.10
	OPENBSD_3_4:1.10.0.2
	OPENBSD_3_4_BASE:1.10
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.6.0.4
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2015.09.05.08.26.43;	author miod;	state Exp;
branches;
next	1.20;
commitid	wWVC7p3JPe4HB9x2;

1.20
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2013.06.11.18.15.55;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.05.13.43.58;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.07.13.31.36;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.21.00.26.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.12.23.21.46.56;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2003.08.06.21.08.07;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.10.11.07.25;	author espie;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.04.14.04.48.01;	author aaron;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.03.14.02.49.23;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.07.17.55.43;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.15.17.27.18;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.6.4.1
date	2001.05.14.22.26.31;	author niklas;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.6.4.5;

1.6.4.5
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.6.4.6;

1.6.4.6
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.05.19.22.14.07;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Support for xterm-compatible SGR escapes 39 and 49 (reset fg/bg colour to
default). From Matthew Martin on tech@@
@
text
@/* $OpenBSD: wsemul_vt100_subr.c,v 1.20 2015/03/14 03:38:50 jsg Exp $ */
/* $NetBSD: wsemul_vt100_subr.c,v 1.7 2000/04/28 21:56:16 mycroft Exp $ */

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsksymvar.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wsemul_vt100var.h>

int	vt100_selectattribute(struct wsemul_vt100_emuldata *, int, int, int,
	    long *, long *);
int	vt100_ansimode(struct wsemul_vt100_emuldata *, int, int);
int	vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
#define VTMODE_SET 33
#define VTMODE_RESET 44
#define VTMODE_REPORT 55

/*
 * scroll up within scrolling region
 */
int
wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *edp, int n)
{
	int help;
	int rc;

	if (n > edp->scrreg_nrows)
		n = edp->scrreg_nrows;

	help = edp->scrreg_nrows - n;
	if (help > 0) {
		WSEMULOP(rc, edp, &edp->abortstate, copyrows,
		    (edp->emulcookie, edp->scrreg_startrow + n,
		     edp->scrreg_startrow, help));
		if (rc != 0)
			return rc;
	}
	WSEMULOP(rc, edp, &edp->abortstate, eraserows,
	    (edp->emulcookie, edp->scrreg_startrow + help, n, edp->bkgdattr));
	if (rc != 0)
		return rc;
	if (edp->dblwid) {
		if (help > 0)
			memmove(&edp->dblwid[edp->scrreg_startrow],
			    &edp->dblwid[edp->scrreg_startrow + n], help);
		memset(&edp->dblwid[edp->scrreg_startrow + help], 0, n);
	}
	CHECK_DW;

	return 0;
}

/*
 * scroll down within scrolling region
 */
int
wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *edp, int n)
{
	int help;
	int rc;

	if (n > edp->scrreg_nrows)
		n = edp->scrreg_nrows;

	help = edp->scrreg_nrows - n;
	if (help > 0) {
		WSEMULOP(rc, edp, &edp->abortstate, copyrows,
		    (edp->emulcookie, edp->scrreg_startrow,
		     edp->scrreg_startrow + n, help));
		if (rc != 0)
			return rc;
	}
	WSEMULOP(rc, edp, &edp->abortstate, eraserows,
	    (edp->emulcookie, edp->scrreg_startrow, n, edp->bkgdattr));
	if (rc != 0)
		return rc;
	if (edp->dblwid) {
		if (help > 0)
			memmove(&edp->dblwid[edp->scrreg_startrow + n],
			    &edp->dblwid[edp->scrreg_startrow], help);
		memset(&edp->dblwid[edp->scrreg_startrow], 0, n);
	}
	CHECK_DW;

	return 0;
}

/*
 * erase in display
 */
int
wsemul_vt100_ed(struct wsemul_vt100_emuldata *edp, int arg)
{
	int n;
	int rc;

	switch (arg) {
	case 0: /* cursor to end */
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr));
		if (rc != 0)
			break;
		n = edp->nrows - edp->crow - 1;
		if (n > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, eraserows,
			    (edp->emulcookie, edp->crow + 1, n, edp->bkgdattr));
			if (rc != 0)
				break;
			if (edp->dblwid)
				memset(&edp->dblwid[edp->crow + 1], 0, n);
		}
		break;
	case 1: /* beginning to cursor */
		if (edp->crow > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, eraserows,
			    (edp->emulcookie, 0, edp->crow, edp->bkgdattr));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(0, edp->ccol + 1, edp->bkgdattr));
		if (rc != 0)
			break;
		if (edp->dblwid) {
			if (edp->crow > 0)
				memset(&edp->dblwid[0], 0, edp->crow);
		}
		break;
	case 2: /* complete display */
		WSEMULOP(rc, edp, &edp->abortstate, eraserows,
		    (edp->emulcookie, 0, edp->nrows, edp->bkgdattr));
		if (rc != 0)
			break;
		if (edp->dblwid)
			memset(&edp->dblwid[0], 0, edp->nrows);
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ed(%d) unknown\n", arg);
#endif
		rc = 0;
		break;
	}
	if (rc != 0)
		return rc;

	CHECK_DW;

	return 0;
}

/*
 * erase in line
 */
int
wsemul_vt100_el(struct wsemul_vt100_emuldata *edp, int arg)
{
	int rc;

	switch (arg) {
	case 0: /* cursor to end */
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr));
		break;
	case 1: /* beginning to cursor */
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(0, edp->ccol + 1, edp->bkgdattr));
		break;
	case 2: /* complete line */
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    (edp->emulcookie, edp->crow, 0, edp->ncols, edp->bkgdattr));
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("el(%d) unknown\n", arg);
#endif
		rc = 0;
		break;
	}

	return rc;
}

/*
 * handle commands after CSI (ESC[)
 */
int
wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	int n, help, flags, fgcol, bgcol;
	long attr, bkgdattr;
	u_char c;
	int rc = 0;
 
	if (instate->inchar >= 0x100)
		c = 0x00;	/* cause the switch below to end in default: */
	else
		c = (u_char)instate->inchar;

#define A3(a, b, c) (((a) << 16) | ((b) << 8) | (c))
	switch (A3(edp->modif1, edp->modif2, c)) {
	case A3('>', '\0', 'c'): /* DA secondary */
		wsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID2,
		    sizeof(WSEMUL_VT_ID2));
		break;

	case A3('\0', '\0', 'J'): /* ED selective erase in display */
	case A3('?', '\0', 'J'): /* DECSED selective erase in display */
		rc = wsemul_vt100_ed(edp, ARG(0));
		break;
	case A3('\0', '\0', 'K'): /* EL selective erase in line */
	case A3('?', '\0', 'K'): /* DECSEL selective erase in line */
		rc = wsemul_vt100_el(edp, ARG(0));
		break;
	case A3('\0', '\0', 'h'): /* SM */
		for (n = 0; n < edp->nargs; n++)
			vt100_ansimode(edp, ARG(n), VTMODE_SET);
		break;
	case A3('?', '\0', 'h'): /* DECSM */
		for (n = 0; n < edp->nargs; n++) {
			rc = vt100_decmode(edp, ARG(n), VTMODE_SET);
			if (rc != 0)
				break;
		}
		break;
	case A3('\0', '\0', 'l'): /* RM */
		for (n = 0; n < edp->nargs; n++)
			vt100_ansimode(edp, ARG(n), VTMODE_RESET);
		break;
	case A3('?', '\0', 'l'): /* DECRM */
		for (n = 0; n < edp->nargs; n++) {
			rc = vt100_decmode(edp, ARG(n), VTMODE_RESET);
			if (rc != 0)
				break;
		}
		break;
	case A3('\0', '$', 'p'): /* DECRQM request mode ANSI */
		vt100_ansimode(edp, ARG(0), VTMODE_REPORT);
		break;
	case A3('?', '$', 'p'): /* DECRQM request mode DEC */
		rc = vt100_decmode(edp, ARG(0), VTMODE_REPORT);
		break;
	case A3('\0', '\0', 'i'): /* MC printer controller mode */
	case A3('?', '\0', 'i'): /* MC printer controller mode */
		switch (ARG(0)) {
		case 0: /* print screen */
		case 1: /* print cursor line */
		case 4: /* off */
		case 5: /* on */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI%di ignored\n", ARG(0));
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%di unknown\n", ARG(0));
#endif
			break;
		}
		break;

#define A2(a, b) (((a) << 8) | (b))
	case A2('!', 'p'): /* DECSTR soft reset VT300 only */
		wsemul_vt100_reset(edp);
		break;

	case A2('"', 'p'): /* DECSCL */
		switch (ARG(0)) {
		case 61: /* VT100 mode (no further arguments!) */
			break;
		case 62:
		case 63: /* VT300 mode */
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d\"p unknown\n", ARG(0));
#endif
			break;
		}
		switch (ARG(1)) {
		case 0:
		case 2: /* 8-bit controls */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI%d;%d\"p ignored\n", ARG(0), ARG(1));
#endif
			break;
		case 1: /* 7-bit controls */
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d;%d\"p unknown\n", ARG(0), ARG(1));
#endif
			break;
		}
		break;
	case A2('"', 'q'): /* DECSCA select character attribute VT300 */
		switch (ARG(0)) {
		case 0:
		case 1: /* erasable */
			break;
		case 2: /* not erasable */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI2\"q ignored\n");
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d\"q unknown\n", ARG(0));
#endif
			break;
		}
		break;

	case A2('$', 'u'): /* DECRQTSR request terminal status report */
		switch (ARG(0)) {
		case 0: /* ignored */
			break;
		case 1: /* terminal state report */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI1$u ignored\n");
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d$u unknown\n", ARG(0));
#endif
			break;
		}
		break;
	case A2('$', 'w'): /* DECRQPSR request presentation status report
				(VT300 only) */
		switch (ARG(0)) {
		case 0: /* error */
			break;
		case 1: /* cursor information report */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI1$w ignored\n");
#endif
			break;
		case 2: /* tab stop report */
		    {
			int i, n, ps = 0;
			char buf[20];

			wsdisplay_emulinput(edp->cbcookie, "\033P2$u", 5);
			if (edp->tabs != NULL)
			    for (i = 0; i < edp->ncols; i++)
				if (edp->tabs[i]) {
					n = snprintf(buf, sizeof buf, "%s%d",
					    (ps ? "/" : ""), i + 1);
					if (n == -1)
						n = 0;
					else if (n >= sizeof buf)
						n = sizeof buf - 1;
					wsdisplay_emulinput(edp->cbcookie,
					    buf, n);
					ps = 1;
				}
			wsdisplay_emulinput(edp->cbcookie, "\033\\", 2);
		    }
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d$w unknown\n", ARG(0));
#endif
			break;
		}
		break;
	/* gratuitous { for brace matching with the next line */
	case A2('$', '}'): /* DECSASD select active status display */
		switch (ARG(0)) {
		case 0: /* main display */
		case 1: /* status line */
#ifdef VT100_PRINTNOTIMPL	/* { */
			printf("CSI%d$} ignored\n", ARG(0));
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN	/* { */
			printf("CSI%d$} unknown\n", ARG(0));
#endif
			break;
		}
		break;
	case A2('$', '~'): /* DECSSDD select status line type */
		switch (ARG(0)) {
		case 0: /* none */
		case 1: /* indicator */
		case 2: /* host-writable */
#ifdef VT100_PRINTNOTIMPL
			printf("CSI%d$~ ignored\n", ARG(0));
#endif
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%d$~ unknown\n", ARG(0));
#endif
			break;
		}
		break;

	case A2('&', 'u'): /* DECRQUPSS request user preferred
				  supplemental set */
		wsdisplay_emulinput(edp->cbcookie, "\033P0!u%5\033\\", 9);
		break;

	case '@@': /* ICH insert character VT300 only */
		n = min(DEF1_ARG(0), COLS_LEFT + 1);
		help = NCOLS - (edp->ccol + n);
		if (help > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols,
			    COPYCOLS(edp->ccol, edp->ccol + n, help));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(edp->ccol, n, edp->bkgdattr));
		break;
	case 'A': /* CUU */
		edp->crow -= min(DEF1_ARG(0), ROWS_ABOVE);
		CHECK_DW;
		break;
	case 'B': /* CUD */
		edp->crow += min(DEF1_ARG(0), ROWS_BELOW);
		CHECK_DW;
		break;
	case 'C': /* CUF */
		edp->ccol += min(DEF1_ARG(0), COLS_LEFT);
		break;
	case 'D': /* CUB */
		edp->ccol -= min(DEF1_ARG(0), edp->ccol);
		edp->flags &= ~VTFL_LASTCHAR;
		break;
	case 'H': /* CUP */
	case 'f': /* HVP */
		if (edp->flags & VTFL_DECOM)
			edp->crow = edp->scrreg_startrow +
			    min(DEF1_ARG(0), edp->scrreg_nrows) - 1;
		else
			edp->crow = min(DEF1_ARG(0), edp->nrows) - 1;
		CHECK_DW;
		edp->ccol = min(DEF1_ARG(1), NCOLS) - 1;
		edp->flags &= ~VTFL_LASTCHAR;
		break;
	case 'L': /* IL insert line */
	case 'M': /* DL delete line */
	    {
		int savscrstartrow, savscrnrows;

		n = min(DEF1_ARG(0), ROWS_BELOW + 1);
		savscrstartrow = edp->scrreg_startrow;
		savscrnrows = edp->scrreg_nrows;
		edp->scrreg_nrows -= ROWS_ABOVE;
		edp->scrreg_startrow = edp->crow;
		if (c == 'L')
			rc = wsemul_vt100_scrolldown(edp, n);
		else
			rc = wsemul_vt100_scrollup(edp, n);
		edp->scrreg_startrow = savscrstartrow;
		edp->scrreg_nrows = savscrnrows;
	    }
		break;
	case 'P': /* DCH delete character */
		n = min(DEF1_ARG(0), COLS_LEFT + 1);
		help = NCOLS - (edp->ccol + n);
		if (help > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols,
			    COPYCOLS(edp->ccol + n, edp->ccol, help));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(NCOLS - n, n, edp->bkgdattr));
		break;
	case 'X': /* ECH erase character */
		n = min(DEF1_ARG(0), COLS_LEFT + 1);
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    ERASECOLS(edp->ccol, n, edp->bkgdattr));
		break;
	case 'c': /* DA primary */
		if (ARG(0) == 0)
			wsdisplay_emulinput(edp->cbcookie, WSEMUL_VT_ID1,
			    sizeof(WSEMUL_VT_ID1));
		break;
	case 'g': /* TBC */
		if (edp->tabs != NULL)
			switch (ARG(0)) {
			case 0:
				edp->tabs[edp->ccol] = 0;
				break;
			case 3:
				memset(edp->tabs, 0, edp->ncols);
				break;
			default:
#ifdef VT100_PRINTUNKNOWN
				printf("CSI%dg unknown\n", ARG(0));
#endif
				break;
			}
		break;
	case 'm': /* SGR select graphic rendition */
		flags = edp->attrflags;
		fgcol = edp->fgcol;
		bgcol = edp->bgcol;
		for (n = 0; n < edp->nargs; n++) {
			switch (ARG(n)) {
			case 0: /* reset */
				if (n == edp->nargs - 1) {
					edp->bkgdattr = edp->curattr = edp->defattr;
					edp->attrflags = 0;
					edp->fgcol = WSCOL_WHITE;
					edp->bgcol = WSCOL_BLACK;
					return 0;
				}
				flags = 0;
				fgcol = WSCOL_WHITE;
				bgcol = WSCOL_BLACK;
				break;
			case 1: /* bold */
				flags |= WSATTR_HILIT;
				break;
			case 4: /* underline */
				flags |= WSATTR_UNDERLINE;
				break;
			case 5: /* blink */
				flags |= WSATTR_BLINK;
				break;
			case 7: /* reverse */
				flags |= WSATTR_REVERSE;
				break;
			case 22: /* ~bold VT300 only */
				flags &= ~WSATTR_HILIT;
				break;
			case 24: /* ~underline VT300 only */
				flags &= ~WSATTR_UNDERLINE;
				break;
			case 25: /* ~blink VT300 only */
				flags &= ~WSATTR_BLINK;
				break;
			case 27: /* ~reverse VT300 only */
				flags &= ~WSATTR_REVERSE;
				break;
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
				/* fg color */
				flags |= WSATTR_WSCOLORS;
				fgcol = ARG(n) - 30;
				break;
			case 39:
				/* reset fg color */
				fgcol = WSCOL_WHITE;
				if (bgcol == WSCOL_BLACK)
					flags &= ~WSATTR_WSCOLORS;
				break;
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
				/* bg color */
				flags |= WSATTR_WSCOLORS;
				bgcol = ARG(n) - 40;
				break;
			case 49:
				/* reset bg color */
				bgcol = WSCOL_BLACK;
				if (fgcol == WSCOL_WHITE)
					flags &= ~WSATTR_WSCOLORS;
				break;
			default:
#ifdef VT100_PRINTUNKNOWN
				printf("CSI%dm unknown\n", ARG(n));
#endif
				break;
			}
		}
		if (vt100_selectattribute(edp, flags, fgcol, bgcol, &attr,
		    &bkgdattr)) {
#ifdef VT100_DEBUG
			printf("error allocating attr %d/%d/%x\n",
			       fgcol, bgcol, flags);
#endif
		} else {
			edp->curattr = attr;
			edp->bkgdattr = bkgdattr;
			edp->attrflags = flags;
			edp->fgcol = fgcol;
			edp->bgcol = bgcol;
		}
		break;
	case 'n': /* reports */
		switch (ARG(0)) {
		case 5: /* DSR operating status */
			/* 0 = OK, 3 = malfunction */
			wsdisplay_emulinput(edp->cbcookie, "\033[0n", 4);
			break;
		case 6: /* DSR cursor position report */
		    {
			char buf[20];
			int row;
			if (edp->flags & VTFL_DECOM)
				row = ROWS_ABOVE;
			else
				row = edp->crow;
			n = snprintf(buf, sizeof buf, "\033[%d;%dR",
				    row + 1, edp->ccol + 1);
			if (n == -1)
				n = 0;
			else if (n >= sizeof buf)
				n = sizeof buf - 1;
			wsdisplay_emulinput(edp->cbcookie, buf, n);
		    }
			break;
		case 15: /* DSR printer status */
			/* 13 = no printer, 10 = ready, 11 = not ready */
			wsdisplay_emulinput(edp->cbcookie, "\033[?13n", 6);
			break;
		case 25: /* UDK status - VT300 only */
			/* 20 = locked, 21 = unlocked */
			wsdisplay_emulinput(edp->cbcookie, "\033[?21n", 6);
			break;
		case 26: /* keyboard dialect */
			/* 1 = north american , 7 = german */
			wsdisplay_emulinput(edp->cbcookie, "\033[?27;1n", 8);
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%dn unknown\n", ARG(0));
#endif
			break;
		}
		break;
	case 'r': /* DECSTBM set top/bottom margins */
		help = min(DEF1_ARG(0), edp->nrows) - 1;
		n = min(DEFx_ARG(1, edp->nrows), edp->nrows) - help;
		if (n < 2) {
			/* minimal scrolling region has 2 lines */
			return 0;
		} else {
			edp->scrreg_startrow = help;
			edp->scrreg_nrows = n;
		}
		edp->crow = ((edp->flags & VTFL_DECOM) ?
			     edp->scrreg_startrow : 0);
		edp->ccol = 0;
		break;
	case 'y':
		switch (ARG(0)) {
		case 4: /* DECTST invoke confidence test */
			/* ignore */
			break;
		default:
#ifdef VT100_PRINTUNKNOWN
			printf("CSI%dy unknown\n", ARG(0));
#endif
			break;
		}
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("CSI %x (%d, %d) unknown\n",
		    instate->inchar, ARG(0), ARG(1));
#endif
		break;
	}

	return rc;
}

/*
 * get an attribute from the graphics driver,
 * try to find replacements if the desired appearance
 * is not supported
 */
int
vt100_selectattribute(struct wsemul_vt100_emuldata *edp, int flags, int fgcol,
    int bgcol, long *attr, long *bkgdattr)
{
	int error;

	if ((flags & WSATTR_WSCOLORS) &&
	    !(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {
		flags &= ~WSATTR_WSCOLORS;
#ifdef VT100_DEBUG
		printf("colors ignored (impossible)\n");
#endif
	}
	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
	    flags & WSATTR_WSCOLORS, bkgdattr);
	if (error)
		return (error);

	if ((flags & WSATTR_HILIT) &&
	    !(edp->scrcapabilities & WSSCREEN_HILIT)) {
		flags &= ~WSATTR_HILIT;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_RED;
			flags |= WSATTR_WSCOLORS;
		} else {
#ifdef VT100_DEBUG
			printf("bold ignored (impossible)\n");
#endif
		}
	}
	if ((flags & WSATTR_UNDERLINE) &&
	    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {
		flags &= ~WSATTR_UNDERLINE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_CYAN;
			flags &= ~WSATTR_UNDERLINE;
			flags |= WSATTR_WSCOLORS;
		} else {
#ifdef VT100_DEBUG
			printf("underline ignored (impossible)\n");
#endif
		}
	}
	if ((flags & WSATTR_BLINK) &&
	    !(edp->scrcapabilities & WSSCREEN_BLINK)) {
		flags &= ~WSATTR_BLINK;
#ifdef VT100_DEBUG
		printf("blink ignored (impossible)\n");
#endif
	}
	if ((flags & WSATTR_REVERSE) &&
	    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {
		flags &= ~WSATTR_REVERSE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			int help;
			help = bgcol;
			bgcol = fgcol;
			fgcol = help;
			flags |= WSATTR_WSCOLORS;
		} else {
#ifdef VT100_DEBUG
			printf("reverse ignored (impossible)\n");
#endif
		}
	}
	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags, attr);
	if (error)
		return (error);

	return (0);
}

/*
 * handle device control sequences if the main state machine
 * told so by setting edp->dcstype to a nonzero value
 */
void
wsemul_vt100_handle_dcs(struct wsemul_vt100_emuldata *edp)
{
	int i, pos;

	switch (edp->dcstype) {
	case 0: /* not handled */
		return;
	case DCSTYPE_TABRESTORE:
		if (edp->tabs != NULL) {
			memset(edp->tabs, 0, edp->ncols);
			pos = 0;
			for (i = 0; i < edp->dcspos; i++) {
				char c = edp->dcsarg[i];
				switch (c) {
				case '0': case '1': case '2': case '3':
				case '4': case '5': case '6': case '7':
				case '8': case '9':
					pos = pos * 10 + (edp->dcsarg[i] - '0');
					break;
				case '/':
					if (pos > 0)
						edp->tabs[pos - 1] = 1;
					pos = 0;
					break;
				default:
#ifdef VT100_PRINTUNKNOWN
					printf("unknown char %c in DCS\n", c);
#endif
					break;
				}
			}
			if (pos > 0)
				edp->tabs[pos - 1] = 1;
		}
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("wsemul_vt100_handle_dcs: bad type %d\n", edp->dcstype);
#endif
		break;
	}
	edp->dcstype = 0;
}

int
vt100_ansimode(struct wsemul_vt100_emuldata *edp, int nr, int op)
{
	int res = 0; /* default: unknown */

	switch (nr) {
	case 2: /* KAM keyboard locked/unlocked */
		break;
	case 3: /* CRM control representation */
		break;
	case 4: /* IRM insert/replace characters */
		if (op == VTMODE_SET)
			edp->flags |= VTFL_INSERTMODE;
		else if (op == VTMODE_RESET)
			edp->flags &= ~VTFL_INSERTMODE;
		res = ((edp->flags & VTFL_INSERTMODE) ? 1 : 2);
		break;
	case 10: /* HEM horizontal editing (permanently reset) */
		res = 4;
		break;
	case 12: /* SRM local echo off/on */
		res = 4; /* permanently reset ??? */
		break;
	case 20: /* LNM newline = newline/linefeed */
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("ANSI mode %d unknown\n", nr);
#endif
		break;
	}
	return (res);
}

int
vt100_decmode(struct wsemul_vt100_emuldata *edp, int nr, int op)
{
#if 0	/* res unused... return it by reference if ever necessary */
	int res = 0; /* default: unknown */
#endif
	int flags = edp->flags;
	int rc = 0;

	switch (nr) {
	case 1: /* DECCKM application/nomal cursor keys */
		if (op == VTMODE_SET)
			flags |= VTFL_APPLCURSOR;
		else if (op == VTMODE_RESET)
			flags &= ~VTFL_APPLCURSOR;
#if 0
		res = ((flags & VTFL_APPLCURSOR) ? 1 : 2);
#endif
		break;
	case 2: /* DECANM ANSI vt100/vt52 */
#if 0
		res = 3; /* permanently set ??? */
#endif
		break;
	case 3: /* DECCOLM 132/80 cols */
	case 4: /* DECSCLM smooth/jump scroll */
	case 5: /* DECSCNM light/dark background */
#if 0
		res = 4; /* all permanently reset ??? */
#endif
		break;
	case 6: /* DECOM move within/outside margins */
		if (op == VTMODE_SET)
			flags |= VTFL_DECOM;
		else if (op == VTMODE_RESET)
			flags &= ~VTFL_DECOM;
#if 0
		res = ((flags & VTFL_DECOM) ? 1 : 2);
#endif
		break;
	case 7: /* DECAWM autowrap */
		if (op == VTMODE_SET)
			flags |= VTFL_DECAWM;
		else if (op == VTMODE_RESET)
			flags &= ~VTFL_DECAWM;
#if 0
		res = ((flags & VTFL_DECAWM) ? 1 : 2);
#endif
		break;
	case 8: /* DECARM keyboard autorepeat */
		break;
	case 18: /* DECPFF print form feed */
		break;
	case 19: /* DECPEX printer extent: screen/scrolling region */
		break;
	case 25: /* DECTCEM text cursor on/off */
		if (op == VTMODE_SET)
			flags |= VTFL_CURSORON;
		else if (op == VTMODE_RESET)
			flags &= ~VTFL_CURSORON;
		if (flags != edp->flags)
			WSEMULOP(rc, edp, &edp->abortstate, cursor,
			    (edp->emulcookie, flags & VTFL_CURSORON, edp->crow,
			     edp->ccol));
#if 0
		res = ((flags & VTFL_CURSORON) ? 1 : 2);
#endif
		break;
	case 42: /* DECNRCM use 7-bit NRC /
		    7/8 bit from DEC multilingual or ISO-latin-1*/
		if (op == VTMODE_SET)
			flags |= VTFL_NATCHARSET;
		else if (op == VTMODE_RESET)
			flags &= ~VTFL_NATCHARSET;
#if 0
		res = ((flags & VTFL_NATCHARSET) ? 1 : 2);
#endif
		break;
	case 66: /* DECNKM numeric keypad */
		break;
	case 68: /* DECKBUM keyboard usage data processing/typewriter */
		break;
	default:
#ifdef VT100_PRINTUNKNOWN
		printf("DEC mode %d unknown\n", nr);
#endif
		break;
	}
	edp->flags = flags;

	return rc;
}
@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.19 2013/10/18 22:06:41 miod Exp $ */
d579 6
d590 6
@


1.19
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.18 2013/06/11 18:15:55 deraadt Exp $ */
a32 1
#include <dev/wscons/wscons_features.h>
@


1.18
log
@Replace all ovbcopy with memmove; swap the src and dst arguments too
ok otto
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.17 2009/09/05 14:49:20 miod Exp $ */
d33 1
d218 2
a219 1
wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *edp, u_char c)
d223 1
d225 5
d677 2
a678 1
		printf("CSI%c (%d, %d) unknown\n", c, ARG(0), ARG(1));
d805 4
a808 1
		panic("wsemul_vt100_handle_dcs: bad type %d", edp->dcstype);
@


1.17
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.16 2009/09/05 13:43:58 miod Exp $ */
d73 2
a74 2
			ovbcopy(&edp->dblwid[edp->scrreg_startrow + n],
			    &edp->dblwid[edp->scrreg_startrow], help);
d108 2
a109 2
			ovbcopy(&edp->dblwid[edp->scrreg_startrow],
			    &edp->dblwid[edp->scrreg_startrow + n], help);
@


1.16
log
@Rework internal interfaces in the wsdisplay emulation code to prepare for
upcoming changes. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.15 2007/11/27 16:37:27 miod Exp $ */
d42 1
a42 1
void	vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
d50 1
a50 1
void
d54 1
d61 13
a73 4
		(*edp->emulops->copyrows)(edp->emulcookie,
		    edp->scrreg_startrow + n, edp->scrreg_startrow, help);
		if (edp->dblwid)	/* XXX OVERLAPS */
			bcopy(&edp->dblwid[edp->scrreg_startrow + n],
d75 1
a76 4
	(*edp->emulops->eraserows)(edp->emulcookie,
	    edp->scrreg_startrow + help, n, edp->bkgdattr);
	if (edp->dblwid)
		memset(&edp->dblwid[edp->scrreg_startrow + help], 0, n);
d78 2
d85 1
a85 1
void
d89 1
d96 13
a108 4
		(*edp->emulops->copyrows)(edp->emulcookie,
		    edp->scrreg_startrow, edp->scrreg_startrow + n, help);
		if (edp->dblwid)	/* XXX OVERLAPS */
			bcopy(&edp->dblwid[edp->scrreg_startrow],
d110 1
a111 4
	(*edp->emulops->eraserows)(edp->emulcookie, edp->scrreg_startrow, n,
	    edp->bkgdattr);
	if (edp->dblwid)
		memset(&edp->dblwid[edp->scrreg_startrow], 0, n);
d113 2
d120 1
a120 1
void
d124 1
d128 4
a131 1
		ERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);
d134 4
a137 2
			(*edp->emulops->eraserows)(edp->emulcookie,
			    edp->crow + 1, n, edp->bkgdattr);
d144 11
a154 3
			(*edp->emulops->eraserows)(edp->emulcookie,
			    0, edp->crow, edp->bkgdattr);
			if (edp->dblwid)
a156 1
		ERASECOLS(0, edp->ccol + 1, edp->bkgdattr);
d159 4
a162 2
		(*edp->emulops->eraserows)(edp->emulcookie,
		    0, edp->nrows, edp->bkgdattr);
d170 1
d173 3
d177 2
d184 1
a184 1
void
d187 2
d191 2
a192 1
		ERASECOLS(edp->ccol, COLS_LEFT + 1, edp->bkgdattr);
d195 2
a196 1
		ERASECOLS(0, edp->ccol + 1, edp->bkgdattr);
d199 2
a200 2
		(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
		    0, edp->ncols, edp->bkgdattr);
d206 1
d209 2
d216 1
a216 1
void
d221 1
d232 1
a232 1
		wsemul_vt100_ed(edp, ARG(0));
d236 1
a236 1
		wsemul_vt100_el(edp, ARG(0));
d243 5
a247 2
		for (n = 0; n < edp->nargs; n++)
			vt100_decmode(edp, ARG(n), VTMODE_SET);
d254 5
a258 2
		for (n = 0; n < edp->nargs; n++)
			vt100_decmode(edp, ARG(n), VTMODE_RESET);
d264 1
a264 1
		vt100_decmode(edp, ARG(0), VTMODE_REPORT);
d392 1
d397 1
a397 1
#ifdef VT100_PRINTNOTIMPL
d402 1
a402 1
#ifdef VT100_PRINTUNKNOWN
d433 8
a440 3
		if (help > 0)
			COPYCOLS(edp->ccol, edp->ccol + n, help);
		ERASECOLS(edp->ccol, n, edp->bkgdattr);
d479 1
a479 1
			wsemul_vt100_scrolldown(edp, n);
d481 1
a481 1
			wsemul_vt100_scrollup(edp, n);
d489 8
a496 3
		if (help > 0)
			COPYCOLS(edp->ccol + n, edp->ccol, help);
		ERASECOLS(NCOLS - n, n, edp->bkgdattr);
d500 2
a501 1
		ERASECOLS(edp->ccol, n, edp->bkgdattr);
d536 1
a536 1
					return;
d646 1
a646 1
			return;
d673 2
d835 1
a835 1
void
d842 1
d896 3
a898 2
			(*edp->emulops->cursor)(edp->emulcookie,
			    flags & VTFL_CURSORON, edp->crow, edp->ccol);
d924 2
@


1.15
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.14 2007/01/07 13:31:36 miod Exp $ */
d42 1
a42 1
int	vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
d768 1
a768 1
int
d771 1
d773 2
a774 1
	int flags;
a775 1
	flags = edp->flags;
d782 1
d784 1
d787 1
d789 1
d794 1
d796 1
d803 1
d805 1
d812 1
d814 1
d830 1
d832 1
d840 1
d842 1
a854 2

	return (res);
@


1.14
log
@Some dynamically allocated elements are not considered of vital importance
for the vt100 emulation to work well enough for most cases (i.e. alternate
character set tables, non-default tab settings, etc).

However, code did not always check if these elements had been successfully
allocated before trying to use them, or worse, would explicitely panic in
DIAGNOSTIC kernels.

Change this to work in a degraded mode (by ignoring related escape sequences)
instead.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.13 2005/04/21 00:26:29 deraadt Exp $ */
d39 4
a42 4
int vt100_selectattribute(struct wsemul_vt100_emuldata *, int, int, int,
			       long *, long *);
int vt100_ansimode(struct wsemul_vt100_emuldata *, int, int);
int vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
d51 1
a51 3
wsemul_vt100_scrollup(edp, n)
	struct wsemul_vt100_emuldata *edp;
	int n;
d61 1
a61 3
					  edp->scrreg_startrow + n,
					  edp->scrreg_startrow,
					  help);
d64 1
a64 2
				&edp->dblwid[edp->scrreg_startrow],
				help);
d67 1
a67 2
				   edp->scrreg_startrow + help, n,
				   edp->bkgdattr);
d77 1
a77 3
wsemul_vt100_scrolldown(edp, n)
	struct wsemul_vt100_emuldata *edp;
	int n;
d87 1
a87 3
					  edp->scrreg_startrow,
					  edp->scrreg_startrow + n,
					  help);
d90 1
a90 2
				&edp->dblwid[edp->scrreg_startrow + n],
				help);
d92 2
a93 3
	(*edp->emulops->eraserows)(edp->emulcookie,
				   edp->scrreg_startrow, n,
				   edp->bkgdattr);
d103 1
a103 3
wsemul_vt100_ed(edp, arg)
	struct wsemul_vt100_emuldata *edp;
	int arg;
d108 1
a108 1
	    case 0: /* cursor to end */
d113 1
a113 2
						   edp->crow + 1, n,
						   edp->bkgdattr);
d118 1
a118 1
	    case 1: /* beginning to cursor */
d121 1
a121 2
						   0, edp->crow,
						   edp->bkgdattr);
d127 1
a127 1
	    case 2: /* complete display */
d129 1
a129 2
					   0, edp->nrows,
					   edp->bkgdattr);
d133 1
a133 1
	    default:
d146 1
a146 3
wsemul_vt100_el(edp, arg)
	struct wsemul_vt100_emuldata *edp;
	int arg;
d149 1
a149 1
	    case 0: /* cursor to end */
d152 1
a152 1
	    case 1: /* beginning to cursor */
d155 1
a155 1
	    case 2: /* complete line */
d157 1
a157 2
					   0, edp->ncols,
					   edp->bkgdattr);
d159 1
a159 1
	    default:
d171 1
a171 3
wsemul_vt100_handle_csi(edp, c)
	struct wsemul_vt100_emuldata *edp;
	u_char c;
d180 1
a180 1
				    sizeof(WSEMUL_VT_ID2));
d320 1
a320 1
						    (ps ? "/" : ""), i + 1);
d326 1
a326 1
							    buf, n);
d329 1
a330 1
			wsdisplay_emulinput(edp->cbcookie, "\033\\", 2);
d411 3
a414 2
		{
		int savscrstartrow, savscrnrows;
d425 1
a425 1
		}
d441 1
a441 1
					    sizeof(WSEMUL_VT_ID1));
d553 1
a553 1
				n = sizeof buf - 1;			
d616 2
a617 4
vt100_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)
	struct wsemul_vt100_emuldata *edp;
	int flags, fgcol, bgcol;
	long *attr, *bkgdattr;
d629 1
a629 1
					    flags & WSATTR_WSCOLORS, bkgdattr);
d693 1
a693 2
wsemul_vt100_handle_dcs(edp)
	struct wsemul_vt100_emuldata *edp;
d735 1
a735 3
vt100_ansimode(edp, nr, op)
	struct wsemul_vt100_emuldata *edp;
	int nr, op;
d740 1
a740 1
	    case 2: /* KAM keyboard locked/unlocked */
d742 1
a742 1
	    case 3: /* CRM control representation */
d744 1
a744 1
	    case 4: /* IRM insert/replace characters */
d751 1
a751 1
	    case 10: /* HEM horizontal editing (permanently reset) */
d754 1
a754 1
	    case 12: /* SRM local echo off/on */
d757 1
a757 1
	    case 20: /* LNM newline = newline/linefeed */
d759 1
a759 1
	    default:
d769 1
a769 3
vt100_decmode(edp, nr, op)
	struct wsemul_vt100_emuldata *edp;
	int nr, op;
d776 1
a776 1
	    case 1: /* DECCKM application/nomal cursor keys */
d783 1
a783 1
	    case 2: /* DECANM ANSI vt100/vt52 */
d786 3
a788 3
	    case 3: /* DECCOLM 132/80 cols */
	    case 4: /* DECSCLM smooth/jump scroll */
	    case 5: /* DECSCNM light/dark background */
d791 1
a791 1
	    case 6: /* DECOM move within/outside margins */
d798 1
a798 1
	    case 7: /* DECAWM autowrap */
d805 1
a805 1
	    case 8: /* DECARM keyboard autorepeat */
d807 1
a807 1
	    case 18: /* DECPFF print form feed */
d809 1
a809 1
	    case 19: /* DECPEX printer extent: screen/scrolling region */
d811 1
a811 1
	    case 25: /* DECTCEM text cursor on/off */
d818 1
a818 2
						flags & VTFL_CURSORON,
						edp->crow, edp->ccol);
d821 2
a822 2
	    case 42: /* DECNRCM use 7-bit NRC /
		      7/8 bit from DEC multilingual or ISO-latin-1*/
d829 1
a829 1
	    case 66: /* DECNKM numeric keypad */
d831 1
a831 1
	    case 68: /* DECKBUM keyboard usage data processing/typewriter */
d833 1
a833 1
	    default:
@


1.13
log
@correct idion for snprintf failure handling; ok cloder
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.12 2004/12/23 21:46:56 miod Exp $ */
d200 1
a200 1
	    case A3('>', '\0', 'c'): /* DA secondary */
d205 2
a206 2
	    case A3('\0', '\0', 'J'): /* ED selective erase in display */
	    case A3('?', '\0', 'J'): /* DECSED selective erase in display */
d209 2
a210 2
	    case A3('\0', '\0', 'K'): /* EL selective erase in line */
	    case A3('?', '\0', 'K'): /* DECSEL selective erase in line */
d213 1
a213 1
	    case A3('\0', '\0', 'h'): /* SM */
d217 1
a217 1
	    case A3('?', '\0', 'h'): /* DECSM */
d221 1
a221 1
	    case A3('\0', '\0', 'l'): /* RM */
d225 1
a225 1
	    case A3('?', '\0', 'l'): /* DECRM */
d229 1
a229 1
	    case A3('\0', '$', 'p'): /* DECRQM request mode ANSI */
d232 1
a232 1
	    case A3('?', '$', 'p'): /* DECRQM request mode DEC */
d235 2
a236 2
	    case A3('\0', '\0', 'i'): /* MC printer controller mode */
	    case A3('?', '\0', 'i'): /* MC printer controller mode */
d238 4
a241 4
		    case 0: /* print screen */
		    case 1: /* print cursor line */
		    case 4: /* off */
		    case 5: /* on */
d246 1
a246 1
		    default:
d255 1
a255 1
	    case A2('!', 'p'): /* DECSTR soft reset VT300 only */
d259 1
a259 1
	    case A2('"', 'p'): /* DECSCL */
d261 1
a261 1
		    case 61: /* VT100 mode (no further arguments!) */
d263 2
a264 2
		    case 62:
		    case 63: /* VT300 mode */
d266 1
a266 1
		    default:
d273 2
a274 2
		    case 0:
		    case 2: /* 8-bit controls */
d279 1
a279 1
		    case 1: /* 7-bit controls */
d281 1
a281 1
		    default:
d288 1
a288 1
	    case A2('"', 'q'): /* DECSCA select character attribute VT300 */
d290 2
a291 2
		    case 0:
		    case 1: /* erasable */
d293 1
a293 1
		    case 2: /* not erasable */
d298 1
a298 1
		    default:
d306 1
a306 1
	    case A2('$', 'u'): /* DECRQTSR request terminal status report */
d308 1
a308 1
		    case 0: /* ignored */
d310 1
a310 1
		    case 1: /* terminal state report */
d315 1
a315 1
		    default:
d322 1
a322 1
	    case A2('$', 'w'): /* DECRQPSR request presentation status report
d325 1
a325 1
		    case 0: /* error */
d327 1
a327 1
		    case 1: /* cursor information report */
d332 2
a333 2
		    case 2: /* tab stop report */
			{
d336 1
a336 1
			KASSERT(edp->tabs != 0);
d338 2
a339 1
			for (i = 0; i < edp->ncols; i++)
d351 1
a351 1
			}
d354 1
a354 1
		    default:
d361 1
a361 1
	    case A2('$', '}'): /* DECSASD select active status display */
d363 2
a364 2
		    case 0: /* main display */
		    case 1: /* status line */
d369 1
a369 1
		    default:
d376 1
a376 1
	    case A2('$', '~'): /* DECSSDD select status line type */
d378 3
a380 3
		    case 0: /* none */
		    case 1: /* indicator */
		    case 2: /* host-writable */
d385 1
a385 1
		    default:
d393 1
a393 1
	    case A2('&', 'u'): /* DECRQUPSS request user preferred
d398 1
a398 1
	    case '@@': /* ICH insert character VT300 only */
d405 1
a405 1
	    case 'A': /* CUU */
d409 1
a409 1
	    case 'B': /* CUD */
d413 1
a413 1
	    case 'C': /* CUF */
d416 1
a416 1
	    case 'D': /* CUB */
d420 2
a421 2
	    case 'H': /* CUP */
	    case 'f': /* HVP */
d431 2
a432 2
	    case 'L': /* IL insert line */
	    case 'M': /* DL delete line */
d448 1
a448 1
	    case 'P': /* DCH delete character */
d455 1
a455 1
	    case 'X': /* ECH erase character */
d459 1
a459 1
	    case 'c': /* DA primary */
d464 10
a473 10
	    case 'g': /* TBC */
		KASSERT(edp->tabs != 0);
		switch (ARG(0)) {
		    case 0:
			edp->tabs[edp->ccol] = 0;
			break;
		    case 3:
			memset(edp->tabs, 0, edp->ncols);
			break;
		    default:
d475 1
a475 1
			printf("CSI%dg unknown\n", ARG(0));
d477 2
a478 2
			break;
		}
d480 1
a480 1
	    case 'm': /* SGR select graphic rendition */
d486 1
a486 1
			    case 0: /* reset */
d498 1
a498 1
			    case 1: /* bold */
d501 1
a501 1
			    case 4: /* underline */
d504 1
a504 1
			    case 5: /* blink */
d507 1
a507 1
			    case 7: /* reverse */
d510 1
a510 1
			    case 22: /* ~bold VT300 only */
d513 1
a513 1
			    case 24: /* ~underline VT300 only */
d516 1
a516 1
			    case 25: /* ~blink VT300 only */
d519 1
a519 1
			    case 27: /* ~reverse VT300 only */
d522 2
a523 2
			    case 30: case 31: case 32: case 33:
			    case 34: case 35: case 36: case 37:
d528 2
a529 2
			    case 40: case 41: case 42: case 43:
			    case 44: case 45: case 46: case 47:
d534 1
a534 1
			    default:
d555 1
a555 1
	    case 'n': /* reports */
d557 1
a557 1
		    case 5: /* DSR operating status */
d561 2
a562 1
		    case 6: { /* DSR cursor position report */
d576 1
a576 1
			}
d578 1
a578 1
		    case 15: /* DSR printer status */
d582 1
a582 1
		    case 25: /* UDK status - VT300 only */
d586 1
a586 1
		    case 26: /* keyboard dialect */
d590 1
a590 1
		    default:
d597 1
a597 1
	    case 'r': /* DECSTBM set top/bottom margins */
d611 1
a611 1
	    case 'y':
d613 1
a613 1
		    case 4: /* DECTST invoke confidence test */
d616 1
a616 1
		    default:
d623 1
a623 1
	    default:
d722 1
a722 1
	    case 0: /* not handled */
d724 18
a741 17
	    case DCSTYPE_TABRESTORE:
		KASSERT(edp->tabs != 0);
		memset(edp->tabs, 0, edp->ncols);
		pos = 0;
		for (i = 0; i < edp->dcspos; i++) {
			char c = edp->dcsarg[i];
			switch (c) {
			    case '0': case '1': case '2': case '3': case '4':
			    case '5': case '6': case '7': case '8': case '9':
				pos = pos * 10 + (edp->dcsarg[i] - '0');
				break;
			    case '/':
				if (pos > 0)
					edp->tabs[pos - 1] = 1;
				pos = 0;
				break;
			    default:
d743 1
a743 1
				printf("unknown char %c in DCS\n", c);
d745 2
a746 1
				break;
d748 2
a750 2
		if (pos > 0)
			edp->tabs[pos - 1] = 1;
d752 1
a752 1
	    default:
@


1.12
log
@Fix crash due to wrong argument in the (almost useless) DECRQUPSS escape
sequence.

From NetBSD (1.13)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.11 2004/04/02 04:39:51 deraadt Exp $ */
d342 4
d569 4
@


1.11
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.10 2003/08/06 21:08:07 millert Exp $ */
d390 1
a390 1
		wsdisplay_emulinput(edp->emulcookie, "\033P0!u%5\033\\", 9);
@


1.10
log
@Remove some double semicolons (hmm, do two semis equal a maxi?).
I've skipped the GNU stuff for now.  From Patrick Latifi.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.9 2003/04/27 11:22:54 ho Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.9
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.8 2002/03/14 01:27:03 millert Exp $ */
d230 1
a230 1
		break;;
d234 1
a234 1
		break;;
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.7 2001/07/10 11:07:25 espie Exp $ */
d346 1
a346 1
					n = sprintf(buf, "%s%d",
d569 1
a569 1
			n = sprintf(buf, "\033[%d;%dR",
@


1.7
log
@ANSI C does not like labels: without a statement after that.
Restore missing breaks.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.6 2001/04/14 04:48:01 aaron Exp $ */
d45 4
a48 4
int vt100_selectattribute __P((struct wsemul_vt100_emuldata *, int, int, int,
			       long *, long *));
int vt100_ansimode __P((struct wsemul_vt100_emuldata *, int, int));
int vt100_decmode __P((struct wsemul_vt100_emuldata *, int, int));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.7 2001/07/10 11:07:25 espie Exp $ */
d45 4
a48 4
int vt100_selectattribute(struct wsemul_vt100_emuldata *, int, int, int,
			       long *, long *);
int vt100_ansimode(struct wsemul_vt100_emuldata *, int, int);
int vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
@


1.7.4.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d346 1
a346 1
					n = snprintf(buf, sizeof buf, "%s%d",
d569 1
a569 1
			n = snprintf(buf, sizeof buf, "\033[%d;%dR",
@


1.6
log
@Remove some static.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.5 2001/03/14 02:49:23 mickey Exp $ */
d539 1
@


1.6.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.6 2001/04/14 04:48:01 aaron Exp $ */
@


1.6.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.6.4.1 2001/05/14 22:26:31 niklas Exp $ */
a538 1
				break;
@


1.6.4.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d45 4
a48 4
int vt100_selectattribute(struct wsemul_vt100_emuldata *, int, int, int,
			       long *, long *);
int vt100_ansimode(struct wsemul_vt100_emuldata *, int, int);
int vt100_decmode(struct wsemul_vt100_emuldata *, int, int);
@


1.6.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.6.4.3 2002/03/28 15:09:10 niklas Exp $ */
d346 1
a346 1
					n = snprintf(buf, sizeof buf, "%s%d",
d569 1
a569 1
			n = snprintf(buf, sizeof buf, "\033[%d;%dR",
@


1.6.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d230 1
a230 1
		break;
d234 1
a234 1
		break;
@


1.6.4.6
log
@Merge with the trunk
@
text
@d16 6
@


1.5
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.4 2001/03/07 17:55:43 aaron Exp $ */
d45 4
a48 4
static int vt100_selectattribute __P((struct wsemul_vt100_emuldata *,
				      int, int, int, long *, long *));
static int vt100_ansimode __P((struct wsemul_vt100_emuldata *, int, int));
static int vt100_decmode __P((struct wsemul_vt100_emuldata *, int, int));
d631 1
a631 1
static int
d751 1
a751 1
static int
d787 1
a787 1
static int
@


1.4
log
@C requires labels to be followed by statements; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.3 2000/11/15 17:27:18 aaron Exp $ */
d39 1
@


1.3
log
@Brown is ugly.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
d621 1
d738 1
d781 1
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100_subr.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d665 1
a665 1
			bgcol = WSCOL_BROWN;
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wsemul_vt100_subr.c,v 1.6 2000/02/25 17:42:51 mycroft Exp $ */
d71 3
a73 3
		if (edp->dblwid)
			memmove(&edp->dblwid[edp->scrreg_startrow],
				&edp->dblwid[edp->scrreg_startrow + n],
d80 1
a80 1
		bzero(&edp->dblwid[edp->scrreg_startrow + help], n);
d103 3
a105 3
		if (edp->dblwid)
			memmove(&edp->dblwid[edp->scrreg_startrow + n],
				&edp->dblwid[edp->scrreg_startrow],
d112 1
a112 1
		bzero(&edp->dblwid[edp->scrreg_startrow], n);
d135 1
a135 1
				bzero(&edp->dblwid[edp->crow + 1], n);
d144 1
a144 1
				bzero(&edp->dblwid[0], edp->crow);
d153 1
a153 1
			bzero(&edp->dblwid[0], edp->nrows);
d471 1
a471 1
			bzero(edp->tabs, edp->ncols);
d696 6
a701 2
	return ((*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags, attr));
d719 1
a719 1
		bzero(edp->tabs, edp->ncols);
@

