head	1.10;
access;
symbols
	OPENBSD_6_2:1.10.0.18
	OPENBSD_6_2_BASE:1.10
	OPENBSD_6_1:1.10.0.16
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.12
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.2
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.10
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.8
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.6
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.9.0.16
	OPENBSD_5_4_BASE:1.9
	OPENBSD_5_3:1.9.0.14
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.9.0.12
	OPENBSD_5_2_BASE:1.9
	OPENBSD_5_1_BASE:1.9
	OPENBSD_5_1:1.9.0.10
	OPENBSD_5_0:1.9.0.8
	OPENBSD_5_0_BASE:1.9
	OPENBSD_4_9:1.9.0.6
	OPENBSD_4_9_BASE:1.9
	OPENBSD_4_8:1.9.0.4
	OPENBSD_4_8_BASE:1.9
	OPENBSD_4_7:1.9.0.2
	OPENBSD_4_7_BASE:1.9
	OPENBSD_4_6:1.8.0.10
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.6
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.4
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.6.0.4
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.2
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.5.0.8
	OPENBSD_4_0_BASE:1.5
	OPENBSD_3_9:1.5.0.6
	OPENBSD_3_9_BASE:1.5
	OPENBSD_3_8:1.5.0.4
	OPENBSD_3_8_BASE:1.5
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.10
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.8
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.6
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.4
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.10
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2007.11.26.16.56.42;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2007.01.07.13.31.36;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.23.21.47.47;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches
	1.2.6.1
	1.2.10.1;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.26.31;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.2.10.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@/* $OpenBSD: wsemul_vt100var.h,v 1.9 2009/09/05 14:49:20 miod Exp $ */
/* $NetBSD: wsemul_vt100var.h,v 1.5 2000/04/28 21:56:17 mycroft Exp $ */

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

#define	VT100_EMUL_NARGS	10	/* max # of args to a command */

struct wsemul_vt100_emuldata {
	const struct wsdisplay_emulops *emulops;
	struct wsemul_abortstate abortstate;
	void *emulcookie;
	int scrcapabilities;
	u_int nrows, ncols, crow, ccol;
	long defattr;			/* default attribute */

	long kernattr;			/* attribute for kernel output */
	void *cbcookie;
#ifdef DIAGNOSTIC
	int console;
#endif

	u_int state;			/* processing state */
	int flags;
#define VTFL_LASTCHAR	0x001	/* printed last char on line (below cursor) */
#define VTFL_INSERTMODE	0x002
#define VTFL_APPLKEYPAD	0x004
#define VTFL_APPLCURSOR	0x008
#define VTFL_DECOM	0x010	/* origin mode */
#define VTFL_DECAWM	0x020	/* auto wrap */
#define VTFL_CURSORON	0x040
#define VTFL_NATCHARSET	0x080	/* national replacement charset mode */
#define VTFL_SAVEDCURS	0x100	/* we have a saved cursor state */
#define VTFL_UTF8	0x200	/* utf-8 character set */
	long curattr, bkgdattr;		/* currently used attribute */
	int attrflags, fgcol, bgcol;	/* properties of curattr */
	u_int scrreg_startrow;
	u_int scrreg_nrows;
	char *tabs;
	char *dblwid;
	int dw;

	int chartab0, chartab1;
	u_int *chartab_G[4];
	u_int *isolatin1tab, *decgraphtab, *dectechtab;
	u_int *nrctab;
	int sschartab; /* single shift */

	int nargs;
	u_int args[VT100_EMUL_NARGS]; /* numeric command args (CSI/DCS) */

	char modif1;	/* {>?} in VT100_EMUL_STATE_CSI */
	char modif2;	/* {!"$&} in VT100_EMUL_STATE_CSI */

	int designating;	/* substate in VT100_EMUL_STATE_SCS* */

	int dcstype;		/* substate in VT100_EMUL_STATE_STRING */
	char *dcsarg;
	int dcspos;
#define DCS_MAXLEN 256 /* ??? */
#define DCSTYPE_TABRESTORE 1 /* DCS2$t */

	u_int savedcursor_row, savedcursor_col;
	long savedattr, savedbkgdattr;
	int savedattrflags, savedfgcol, savedbgcol;
	int savedchartab0, savedchartab1;
	u_int *savedchartab_G[4];

	struct wsemul_inputstate instate;	/* userland input state */
	struct wsemul_inputstate kstate;	/* kernel input state */

#ifdef HAVE_UTF8_SUPPORT
	u_char translatebuf[6];
#else
	u_char translatebuf[1];
#endif
};

/* some useful utility macros */
#define	ARG(n)			(edp->args[(n)])
#define	DEF1_ARG(n)		(ARG(n) ? ARG(n) : 1)
#define	DEFx_ARG(n, x)		(ARG(n) ? ARG(n) : (x))
/* the following two can be negative if we are outside the scrolling region */
#define ROWS_ABOVE	((int)edp->crow - (int)edp->scrreg_startrow)
#define ROWS_BELOW	((int)(edp->scrreg_startrow + edp->scrreg_nrows) \
					- (int)edp->crow - 1)
#define CHECK_DW do { \
	if (edp->dblwid && edp->dblwid[edp->crow]) { \
		edp->dw = 1; \
		if (edp->ccol > (edp->ncols >> 1) - 1) \
			edp->ccol = (edp->ncols >> 1) - 1; \
	} else \
		edp->dw = 0; \
} while (0)
#define NCOLS		(edp->ncols >> edp->dw)
#define	COLS_LEFT	(NCOLS - edp->ccol - 1)
#define COPYCOLS(f, t, n)	(edp->emulcookie, edp->crow, (f) << edp->dw, \
				 (t) << edp->dw, (n) << edp->dw)
#define ERASECOLS(f, n, a)	(edp->emulcookie, edp->crow, (f) << edp->dw, \
				 (n) << edp->dw, a)

/*
 * response to primary DA request
 * operating level: 61 = VT100, 62 = VT200, 63 = VT300
 * extensions: 1 = 132 cols, 2 = printer port, 6 = selective erase,
 *	7 = soft charset, 8 = UDKs, 9 = NRC sets
 * VT100 = "033[?1;2c"
 */
#define WSEMUL_VT_ID1 "\033[?62;6c"
/*
 * response to secondary DA request
 * ident code: 24 = VT320
 * firmware version
 * hardware options: 0 = no options
 */
#define WSEMUL_VT_ID2 "\033[>24;20;0c"

void	wsemul_vt100_reset(struct wsemul_vt100_emuldata *);
int	wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *, int);
int	wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *, int);
int	wsemul_vt100_ed(struct wsemul_vt100_emuldata *, int);
int	wsemul_vt100_el(struct wsemul_vt100_emuldata *, int);
int	wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *,
	    struct wsemul_inputstate *);
void	wsemul_vt100_handle_dcs(struct wsemul_vt100_emuldata *);

int	wsemul_vt100_translate(void *cookie, kbd_t, keysym_t, const u_char **);

void	vt100_initchartables(struct wsemul_vt100_emuldata *);
int	vt100_setnrc(struct wsemul_vt100_emuldata *, int);
@


1.9
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.8 2007/11/27 16:37:27 miod Exp $ */
d57 1
d91 9
d146 2
a147 1
int	wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *, u_char);
d150 1
a150 1
int	wsemul_vt100_translate(void *cookie, keysym_t, const char **);
@


1.8
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.7 2007/11/26 16:56:42 miod Exp $ */
d34 1
d110 4
a113 4
#define COPYCOLS(f, t, n) (*edp->emulops->copycols)(edp->emulcookie, \
	edp->crow, (f) << edp->dw, (t) << edp->dw, (n) << edp->dw)
#define ERASECOLS(f, n, a) (*edp->emulops->erasecols)(edp->emulcookie, \
	edp->crow, (f) << edp->dw, (n) << edp->dw, a)
d132 5
a136 5
void	wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *, int);
void	wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *, int);
void	wsemul_vt100_ed(struct wsemul_vt100_emuldata *, int);
void	wsemul_vt100_el(struct wsemul_vt100_emuldata *, int);
void	wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *, u_char);
@


1.7
log
@Constify the output of the emulops translate() function, as well as the
various tables they use.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.6 2007/01/07 13:31:36 miod Exp $ */
d130 7
a136 7
void wsemul_vt100_reset(struct wsemul_vt100_emuldata *);
void wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_ed(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_el(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *, u_char);
void wsemul_vt100_handle_dcs(struct wsemul_vt100_emuldata *);
d138 1
a138 1
int wsemul_vt100_translate(void *cookie, keysym_t, const char **);
d140 2
a141 2
void vt100_initchartables(struct wsemul_vt100_emuldata *);
int vt100_setnrc(struct wsemul_vt100_emuldata *, int);
@


1.6
log
@Some dynamically allocated elements are not considered of vital importance
for the vt100 emulation to work well enough for most cases (i.e. alternate
character set tables, non-default tab settings, etc).

However, code did not always check if these elements had been successfully
allocated before trying to use them, or worse, would explicitely panic in
DIAGNOSTIC kernels.

Change this to work in a degraded mode (by ignoring related escape sequences)
instead.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.5 2004/12/23 21:47:47 miod Exp $ */
d138 1
a138 1
int wsemul_vt100_translate(void *cookie, keysym_t, char **);
@


1.5
log
@vt100 wscons crashes restoring cursor if it had never been saved before.

From NetBSD (wsemul_vt100.c 1.24, wsemul_vt100var.h 1.7)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.4 2004/04/02 04:39:51 deraadt Exp $ */
d141 1
a141 1
void vt100_setnrc(struct wsemul_vt100_emuldata *, int);
@


1.4
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.3 2002/03/14 01:27:03 millert Exp $ */
d55 1
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d135 7
a141 7
void wsemul_vt100_reset __P((struct wsemul_vt100_emuldata *));
void wsemul_vt100_scrollup __P((struct wsemul_vt100_emuldata *, int));
void wsemul_vt100_scrolldown __P((struct wsemul_vt100_emuldata *, int));
void wsemul_vt100_ed __P((struct wsemul_vt100_emuldata *, int));
void wsemul_vt100_el __P((struct wsemul_vt100_emuldata *, int));
void wsemul_vt100_handle_csi __P((struct wsemul_vt100_emuldata *, u_char));
void wsemul_vt100_handle_dcs __P((struct wsemul_vt100_emuldata *));
d143 1
a143 1
int wsemul_vt100_translate __P((void *cookie, keysym_t, char **));
d145 2
a146 2
void vt100_initchartables __P((struct wsemul_vt100_emuldata *));
void vt100_setnrc __P((struct wsemul_vt100_emuldata *, int));
@


1.2.10.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
d135 7
a141 7
void wsemul_vt100_reset(struct wsemul_vt100_emuldata *);
void wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_ed(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_el(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *, u_char);
void wsemul_vt100_handle_dcs(struct wsemul_vt100_emuldata *);
d143 1
a143 1
int wsemul_vt100_translate(void *cookie, keysym_t, char **);
d145 2
a146 2
void vt100_initchartables(struct wsemul_vt100_emuldata *);
void vt100_setnrc(struct wsemul_vt100_emuldata *, int);
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_vt100var.h,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
@


1.2.6.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d135 7
a141 7
void wsemul_vt100_reset(struct wsemul_vt100_emuldata *);
void wsemul_vt100_scrollup(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_scrolldown(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_ed(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_el(struct wsemul_vt100_emuldata *, int);
void wsemul_vt100_handle_csi(struct wsemul_vt100_emuldata *, u_char);
void wsemul_vt100_handle_dcs(struct wsemul_vt100_emuldata *);
d143 1
a143 1
int wsemul_vt100_translate(void *cookie, keysym_t, char **);
d145 2
a146 2
void vt100_initchartables(struct wsemul_vt100_emuldata *);
void vt100_setnrc(struct wsemul_vt100_emuldata *, int);
@


1.2.6.3
log
@Merge with the trunk
@
text
@d16 6
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wsemul_vt100var.h,v 1.4 1998/12/04 20:48:04 drochner Exp $ */
@

