head	1.30;
access;
symbols
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.29.0.12
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.10
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.8
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.29.0.6
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.2
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.22.0.14
	OPENBSD_4_6_BASE:1.22
	OPENBSD_4_5:1.22.0.10
	OPENBSD_4_5_BASE:1.22
	OPENBSD_4_4:1.22.0.8
	OPENBSD_4_4_BASE:1.22
	OPENBSD_4_3:1.22.0.6
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.4
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.2
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.18.0.2
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.14.0.12
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.14.0.10
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.8
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.14.0.6
	OPENBSD_3_4_BASE:1.14
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.13.0.2
	OPENBSD_3_1_BASE:1.13
	UBC_SYNC_B:1.14
	UBC:1.10.0.6
	UBC_BASE:1.10
	OPENBSD_3_0:1.10.0.4
	OPENBSD_3_0_BASE:1.10
	SMP:1.10.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.30
date	2016.09.04.18.20.34;	author tedu;	state Exp;
branches;
next	1.29;
commitid	5vdSYy8ueEhs20To;

1.29
date	2013.11.04.05.45.04;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.20.21.24.01;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2013.08.20.17.44.36;	author kettenis;	state Exp;
branches;
next	1.26;

1.26
date	2013.07.06.14.35.45;	author kettenis;	state Exp;
branches;
next	1.25;

1.25
date	2013.07.05.21.18.32;	author kettenis;	state Exp;
branches;
next	1.24;

1.24
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.05.14.09.35;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.02.11.25.09;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.29.19.11.17;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.29.19.08.23;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2006.11.29.12.13.55;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.30.21.38.19;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.29.17.54.32;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.09.27.21.45.20;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.15.11.29.15;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.19.03.25;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2002.03.27.18.54.09;	author jbm;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.08.22.28.43;	author mickey;	state Exp;
branches
	1.10.2.1
	1.10.6.1;
next	1.9;

1.9
date	2001.04.14.04.44.02;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.14.02.49.22;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.10.19.42.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2001.02.08.02.47.12;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2001.01.31.16.38.02;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.31.02.12.29;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.15.20.00.39;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.26.30;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.44.11;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	;

1.10.6.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.10.6.2;

1.10.6.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.30
log
@remove some more sparc remnants. ok deraadt
@
text
@/* $OpenBSD: wsdisplayvar.h,v 1.29 2013/11/04 05:45:04 miod Exp $ */
/* $NetBSD: wsdisplayvar.h,v 1.30 2005/02/04 02:10:49 perry Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Default to white on black except on Sun hardware, where we default
 * to black on white to match the firmware console.
 */
#ifndef WS_DEFAULT_FG
#if defined(__sparc64__)
#define WS_DEFAULT_FG WSCOL_BLACK
#else
#define WS_DEFAULT_FG WSCOL_WHITE
#endif
#endif
#ifndef WS_DEFAULT_BG
#if defined(__sparc64__)
#define WS_DEFAULT_BG WSCOL_WHITE
#else
#define WS_DEFAULT_BG WSCOL_BLACK
#endif
#endif

struct device;

/*
 * WSDISPLAY interfaces
 */

#define WSDISPLAY_MAXSCREEN	12

/*
 * Emulation functions, for displays that can support glass-tty terminal
 * emulations.  These are character oriented, with row and column
 * numbers starting at zero in the upper left hand corner of the
 * screen.
 *
 * These are used only when emulating a terminal.  Therefore, displays
 * drivers which cannot emulate terminals do not have to provide them.
 *
 * There is a "void *" cookie provided by the display driver associated
 * with these functions, which is passed to them when they are invoked.
 */
struct wsdisplay_emulops {
	int	(*cursor)(void *c, int on, int row, int col);
	int	(*mapchar)(void *, int, unsigned int *);
	int	(*putchar)(void *c, int row, int col, u_int uc, long attr);
	int	(*copycols)(void *c, int row, int srccol, int dstcol,
		    int ncols);
	int	(*erasecols)(void *c, int row, int startcol, int ncols, long);
	int	(*copyrows)(void *c, int srcrow, int dstrow, int nrows);
	int	(*eraserows)(void *c, int row, int nrows, long attr);
	int	(*alloc_attr)(void *c, int fg, int bg, int flags, long *attrp);
	void	(*unpack_attr)(void *c, long attr, int *fg, int *bg, int *ul);
/* fg / bg values. Made identical to ANSI terminal color codes. */
#define WSCOL_BLACK	0
#define WSCOL_RED	1
#define WSCOL_GREEN	2
#define WSCOL_BROWN	3
#define WSCOL_BLUE	4
#define WSCOL_MAGENTA	5
#define WSCOL_CYAN	6
#define WSCOL_WHITE	7
/* flag values: */
#define WSATTR_REVERSE	1
#define WSATTR_HILIT	2
#define WSATTR_BLINK	4
#define WSATTR_UNDERLINE 8
#define WSATTR_WSCOLORS 16
	/* XXX need a free_attr() ??? */
};

#define	WSSCREEN_NAME_SIZE	16

struct wsscreen_descr {
	char name[WSSCREEN_NAME_SIZE];
	int ncols, nrows;
	const struct wsdisplay_emulops *textops;
	int fontwidth, fontheight;
	int capabilities;
#define WSSCREEN_WSCOLORS	1	/* minimal color capability */
#define WSSCREEN_REVERSE	2	/* can display reversed */
#define WSSCREEN_HILIT		4	/* can highlight (however) */
#define WSSCREEN_BLINK		8	/* can blink */
#define WSSCREEN_UNDERLINE	16	/* can underline */
};

/*
 * Character cell description (for emulation mode).
 */
struct wsdisplay_charcell {
	u_int	uc;
	long	attr;
};

struct wsdisplay_font;
/*
 * Display access functions, invoked by user-land programs which require
 * direct device access, such as X11.
 *
 * There is a "void *" cookie provided by the display driver associated
 * with these functions, which is passed to them when they are invoked.
 */
struct wsdisplay_accessops {
	int	(*ioctl)(void *v, u_long cmd, caddr_t data, int flag,
		    struct proc *p);
	paddr_t	(*mmap)(void *v, off_t off, int prot);
	int	(*alloc_screen)(void *, const struct wsscreen_descr *,
				     void **, int *, int *, long *);
	void	(*free_screen)(void *, void *);
	int	(*show_screen)(void *, void *, int,
			       void (*) (void *, int, int), void *);
	int	(*load_font)(void *, void *, struct wsdisplay_font *);
	int	(*list_font)(void *, struct wsdisplay_font *);
	void	(*scrollback)(void *, void *, int);
	int	(*getchar)(void *, int, int, struct wsdisplay_charcell *);
	void	(*burn_screen)(void *, u_int, u_int);
	void	(*pollc)(void *, int);
};

/* passed to wscons by the video driver to tell about its capabilities */
struct wsscreen_list {
	int nscreens;
	const struct wsscreen_descr **screens;
};

/*
 * Attachment information provided by wsemuldisplaydev devices when attaching
 * wsdisplay units.
 */
struct wsemuldisplaydev_attach_args {
	int	console;				/* is it console? */
	const struct wsscreen_list *scrdata;		/* screen cfg info */
	const struct wsdisplay_accessops *accessops;	/* access ops */
	void	*accesscookie;				/* access cookie */
	u_int	defaultscreens;				/* screens to create */
};

#define	WSEMULDISPLAYDEVCF_CONSOLE	0
#define	wsemuldisplaydevcf_console	cf_loc[WSEMULDISPLAYDEVCF_CONSOLE]	/* spec'd as console? */
#define	WSEMULDISPLAYDEVCF_CONSOLE_UNK	-1
#define	WSDISPLAYDEVCF_MUX		0
#define	wsdisplaydevcf_mux		cf_loc[WSDISPLAYDEVCF_MUX]
#define	WSEMULDISPLAYDEVCF_MUX		1
#define	wsemuldisplaydevcf_mux		cf_loc[WSEMULDISPLAYDEVCF_MUX]

struct wscons_syncops {
	int (*detach)(void *, int, void (*)(void *, int, int), void *);
	int (*attach)(void *, int, void (*)(void *, int, int), void *);
	int (*check)(void *);
	void (*destroy)(void *);
};

/*
 * Autoconfiguration helper functions.
 */
void	wsdisplay_cnattach(const struct wsscreen_descr *, void *,
				int, int, long);
int	wsemuldisplaydevprint(void *, const char *);
int	wsemuldisplaydevsubmatch(struct device *, void *, void *);

/*
 * Console interface.
 */
void	wsdisplay_cnputc(dev_t dev, int i);

/*
 * for use by compatibility code
 */
struct wsdisplay_softc;
struct wsscreen;
int wsscreen_attach_sync(struct wsscreen *,
			      const struct wscons_syncops *, void *);
int wsscreen_detach_sync(struct wsscreen *);
int wsscreen_lookup_sync(struct wsscreen *,
			      const struct wscons_syncops *, void **);

int wsdisplay_maxscreenidx(struct wsdisplay_softc *);
int wsdisplay_screenstate(struct wsdisplay_softc *, int);
int wsdisplay_getactivescreen(struct wsdisplay_softc *);
int wsscreen_switchwait(struct wsdisplay_softc *, int);

int wsdisplay_internal_ioctl(struct wsdisplay_softc *sc,
				  struct wsscreen *,
				  u_long cmd, caddr_t data,
				  int flag, struct proc *p);

int wsdisplay_usl_ioctl1(struct wsdisplay_softc *,
			     u_long, caddr_t, int, struct proc *);

int wsdisplay_usl_ioctl2(struct wsdisplay_softc *, struct wsscreen *,
			     u_long, caddr_t, int, struct proc *);

int wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc,
			     u_long cmd, caddr_t data,
			     int flag, struct proc *p);

/*
 * for general use
 */
#define WSDISPLAY_NULLSCREEN	-1
void wsdisplay_switchtoconsole(void);
void wsdisplay_suspend(void);
void wsdisplay_resume(void);
const struct wsscreen_descr *
    wsdisplay_screentype_pick(const struct wsscreen_list *, const char *);

/*
 * for use by wskbd
 */
void wsdisplay_burn(void *v, u_int flags);
void wsscrollback(void *v, int op);

#define WSDISPLAY_SCROLL_BACKWARD	0
#define WSDISPLAY_SCROLL_FORWARD	1
#define WSDISPLAY_SCROLL_RESET		2

/*
 * screen burner
 */
#define	WSDISPLAY_DEFBURNOUT	0	/* disabled */
#define	WSDISPLAY_DEFBURNIN	250	/* ms */

@


1.29
log
@Better defaults for the screen burner settings: all unblank actions enabled,
but burning still disabled by default. Setting display.screen_off to a nonzero
value with wsconsctl will be enough to enable screen blanking after the
given time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.28 2013/10/20 21:24:01 miod Exp $ */
d39 1
a39 1
#if defined(__sparc__) || defined(__sparc64__)
d46 1
a46 1
#if defined(__sparc__) || defined(__sparc64__)
@


1.28
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.27 2013/08/20 17:44:36 kettenis Exp $ */
d250 1
a250 1
#define	WSDISPLAY_DEFBURNOUT	600000	/* ms */
@


1.27
log
@Define WS_DEFAULT_FG and WS_DEFAULT_BG as default colors (black on white for
sparc/sparc64, white on black for everybody else), and use them to construct
a default color attribute in the rasops(4) code.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.26 2013/07/06 14:35:45 kettenis Exp $ */
a59 1
#define WSDISPLAY_MAXFONT	8
d143 1
@


1.26
log
@s/wsemuldisplaysubmatch/wsemuldisplaydevsubmatch/g
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.25 2013/07/05 21:18:32 kettenis Exp $ */
d33 19
@


1.25
log
@Add submatch function for use with config_found_sm(9).

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.24 2010/03/30 17:40:55 oga Exp $ */
d170 1
a170 1
int	wsemuldisplaysubmatch(struct device *, void *, void *);
@


1.24
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.23 2009/09/05 14:09:35 miod Exp $ */
d170 1
@


1.23
log
@Change the wsdisplay_emulops return types from void to int; emulops will now
return zero on success and nonzero on failure.
This commit only performs mechanical changes for the existing emulops to
always return zero.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.22 2006/12/02 11:25:09 miod Exp $ */
d212 2
@


1.22
log
@Fix ri_devcmap[] to allow WSCOL_BLACK and WSCOL_WHITE to not have to be
different for sparc{,64} systems.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.21 2006/11/29 19:11:17 miod Exp $ */
d56 1
a56 1
	void	(*cursor)(void *c, int on, int row, int col);
d58 2
a59 2
	void	(*putchar)(void *c, int row, int col, u_int uc, long attr);
	void	(*copycols)(void *c, int row, int srccol, int dstcol,
d61 3
a63 3
	void	(*erasecols)(void *c, int row, int startcol, int ncols, long);
	void	(*copyrows)(void *c, int srcrow, int dstrow, int nrows);
	void	(*eraserows)(void *c, int row, int nrows, long attr);
@


1.21
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.20 2006/11/29 19:08:23 miod Exp $ */
a66 5
/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
#define WSCOL_WHITE	0
#define WSCOL_BLACK	15
#else
a67 2
#define WSCOL_WHITE	7
#endif
d74 1
@


1.20
log
@Add an unpack_attr function to struct wsdisplay_emulops, to match the
existing alloc_attr function. This allows rasops_unpack_attr to be kept
private to rasops, yet available to the screen drivers.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.19 2006/11/29 12:13:55 miod Exp $ */
d105 8
d132 1
a132 1
	u_int16_t (*getchar)(void *, int, int);
@


1.19
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.18 2006/06/30 21:38:19 miod Exp $ */
d58 1
a58 2
	void	(*putchar)(void *c, int row, int col,
				u_int uc, long attr);
d61 5
a65 6
	void	(*erasecols)(void *c, int row, int startcol,
		    int ncols, long);
	void	(*copyrows)(void *c, int srcrow, int dstrow,
		    int nrows);
	void	(*eraserows)(void *c, int row, int nrows, long);
	int	(*alloc_attr)(void *c, int fg, int bg, int flags, long *);
@


1.18
log
@For 32bit sun frame buffers, tweak ri_devcmap to get the BoW palette instead
of needing different WSCOL_{BLACK,WHITE} values than 8bit frame buffers.

This allows us to not special case the alloc_attr() invocations depending
on the color depth, and to make WSCOL_{BLACK,WHITE} constants again in the
wsemul_sun land.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.17 2006/06/29 17:54:32 miod Exp $ */
d146 1
@


1.17
log
@No need to keep specific variables for the kernel messages colors on sun
emulation, we can reuse the existing WSCOL_xxx codes, and WSCOL_BLACK and
WSCOL_WHITE will point to variables anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.16 2005/09/27 21:45:20 miod Exp $ */
d71 2
a72 2
#define WSCOL_WHITE	wscol_white
#define WSCOL_BLACK	wscol_black
a90 5

/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
extern int wscol_white, wscol_black;
#endif
@


1.16
log
@More non-emulating wsdisplay tentacles removal.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.15 2005/05/15 11:29:15 miod Exp $ */
a94 1
extern int wskernel_fg, wskernel_bg;
@


1.15
log
@Partial sync to the NetBSD wscons code, bringing a better wsmux behaviour
and bugfixes (the kqueue code, /dev/wsmuxctl and screen border color changes
have not been picked), keeping local changes.

Tested by many on alpha/cats/hp300/i386/macppc/sparc/sparc64/zaurus if not more.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.14 2002/07/25 19:03:25 miod Exp $ */
a136 9
/*
 * Attachment information provided by wsdisplaydev devices when attaching
 * wsdisplay units.
 */
struct wsdisplaydev_attach_args {
	const struct wsdisplay_accessops *accessops;	/* access ops */
	void	*accesscookie;				/* access cookie */
};

a173 1
int	wsdisplaydevprint(void *, const char *);
@


1.14
log
@Rework the color usage in wsemul_sun displays, to match SunOS and Solaris
text mode colors.
This means black text on white background, even for the kernel messages.

Initially based on a patch from jason@@, then some tinkering by me.
@
text
@d1 2
a2 2
/* $OpenBSD: wsdisplayvar.h,v 1.13 2002/03/27 18:54:09 jbm Exp $ */
/* $NetBSD: wsdisplayvar.h,v 1.14.4.1 2000/06/30 16:27:53 simonb Exp $ */
d166 4
@


1.13
log
@Add X-Window support to wsmoused(8). This allows running wsmoused(8) and
X-Window at the same time, removing the need to kill wsmoused(8) before
starting X-Window.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.12 2002/03/14 03:16:08 millert Exp $ */
d69 5
d75 2
a82 1
#define WSCOL_WHITE	7
d91 6
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.11 2002/03/14 01:27:03 millert Exp $ */
d39 3
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.10 2001/05/08 22:28:43 mickey Exp $ */
d113 2
a114 2
	int	(*show_screen) __P((void *, void *, int,
				    void (*) (void *, int, int), void *));
d153 2
a154 2
	int (*detach) __P((void *, int, void (*)(void *, int, int), void *));
	int (*attach) __P((void *, int, void (*)(void *, int, int), void *));
@


1.10
log
@inplement screen burner in screenblank(1) style (no program though).
disabled by default, also supports vsync blanking, disabled by default.
aaron@@ looked at it a while back and i fixed problems he had indicated.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.9 2001/04/14 04:44:02 aaron Exp $ */
d53 12
a64 12
	void	(*cursor) __P((void *c, int on, int row, int col));
	int	(*mapchar) __P((void *, int, unsigned int *));
	void	(*putchar) __P((void *c, int row, int col,
				u_int uc, long attr));
	void	(*copycols) __P((void *c, int row, int srccol, int dstcol,
		    int ncols));
	void	(*erasecols) __P((void *c, int row, int startcol,
		    int ncols, long));
	void	(*copyrows) __P((void *c, int srcrow, int dstrow,
		    int nrows));
	void	(*eraserows) __P((void *c, int row, int nrows, long));
	int	(*alloc_attr) __P((void *c, int fg, int bg, int flags, long *));
d107 6
a112 6
	int	(*ioctl) __P((void *v, u_long cmd, caddr_t data, int flag,
		    struct proc *p));
	paddr_t	(*mmap) __P((void *v, off_t off, int prot));
	int	(*alloc_screen) __P((void *, const struct wsscreen_descr *,
				     void **, int *, int *, long *));
	void	(*free_screen) __P((void *, void *));
d115 5
a119 5
	int	(*load_font) __P((void *, void *, struct wsdisplay_font *));
	void	(*scrollback) __P((void *, void *, int));
	u_int16_t (*getchar) __P((void *, int, int));
	void	(*burn_screen) __P((void *, u_int, u_int));
	void	(*pollc) __P((void *, int));
d155 2
a156 2
	int (*check) __P((void *));
	void (*destroy) __P((void *));
d162 4
a165 4
void	wsdisplay_cnattach __P((const struct wsscreen_descr *, void *,
				int, int, long));
int	wsdisplaydevprint __P((void *, const char *));
int	wsemuldisplaydevprint __P((void *, const char *));
d170 1
a170 1
void	wsdisplay_cnputc __P((dev_t dev, int i));
d177 10
a186 10
int wsscreen_attach_sync __P((struct wsscreen *,
			      const struct wscons_syncops *, void *));
int wsscreen_detach_sync __P((struct wsscreen *));
int wsscreen_lookup_sync __P((struct wsscreen *,
			      const struct wscons_syncops *, void **));

int wsdisplay_maxscreenidx __P((struct wsdisplay_softc *));
int wsdisplay_screenstate __P((struct wsdisplay_softc *, int));
int wsdisplay_getactivescreen __P((struct wsdisplay_softc *));
int wsscreen_switchwait __P((struct wsdisplay_softc *, int));
d188 1
a188 1
int wsdisplay_internal_ioctl __P((struct wsdisplay_softc *sc,
d191 1
a191 1
				  int flag, struct proc *p));
d193 2
a194 2
int wsdisplay_usl_ioctl1 __P((struct wsdisplay_softc *,
			     u_long, caddr_t, int, struct proc *));
d196 2
a197 2
int wsdisplay_usl_ioctl2 __P((struct wsdisplay_softc *, struct wsscreen *,
			     u_long, caddr_t, int, struct proc *));
d199 1
a199 1
int wsdisplay_cfg_ioctl __P((struct wsdisplay_softc *sc,
d201 1
a201 1
			     int flag, struct proc *p));
d207 1
a207 1
void wsdisplay_switchtoconsole __P((void));
d209 1
a209 1
    wsdisplay_screentype_pick __P((const struct wsscreen_list *, const char *));
d214 2
a215 2
void wsdisplay_burn __P((void *v, u_int flags));
void wsscrollback __P((void *v, int op));
@


1.10.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.10 2001/05/08 22:28:43 mickey Exp $ */
a39 3
#define WSDISPLAY_MAXSCREEN	12
#define WSDISPLAY_MAXFONT	8

d53 12
a64 12
	void	(*cursor)(void *c, int on, int row, int col);
	int	(*mapchar)(void *, int, unsigned int *);
	void	(*putchar)(void *c, int row, int col,
				u_int uc, long attr);
	void	(*copycols)(void *c, int row, int srccol, int dstcol,
		    int ncols);
	void	(*erasecols)(void *c, int row, int startcol,
		    int ncols, long);
	void	(*copyrows)(void *c, int srcrow, int dstrow,
		    int nrows);
	void	(*eraserows)(void *c, int row, int nrows, long);
	int	(*alloc_attr)(void *c, int fg, int bg, int flags, long *);
d107 13
a119 13
	int	(*ioctl)(void *v, u_long cmd, caddr_t data, int flag,
		    struct proc *p);
	paddr_t	(*mmap)(void *v, off_t off, int prot);
	int	(*alloc_screen)(void *, const struct wsscreen_descr *,
				     void **, int *, int *, long *);
	void	(*free_screen)(void *, void *);
	int	(*show_screen)(void *, void *, int,
			       void (*) (void *, int, int), void *);
	int	(*load_font)(void *, void *, struct wsdisplay_font *);
	void	(*scrollback)(void *, void *, int);
	u_int16_t (*getchar)(void *, int, int);
	void	(*burn_screen)(void *, u_int, u_int);
	void	(*pollc)(void *, int);
d153 4
a156 4
	int (*detach)(void *, int, void (*)(void *, int, int), void *);
	int (*attach)(void *, int, void (*)(void *, int, int), void *);
	int (*check)(void *);
	void (*destroy)(void *);
d162 4
a165 4
void	wsdisplay_cnattach(const struct wsscreen_descr *, void *,
				int, int, long);
int	wsdisplaydevprint(void *, const char *);
int	wsemuldisplaydevprint(void *, const char *);
d170 1
a170 1
void	wsdisplay_cnputc(dev_t dev, int i);
d177 10
a186 10
int wsscreen_attach_sync(struct wsscreen *,
			      const struct wscons_syncops *, void *);
int wsscreen_detach_sync(struct wsscreen *);
int wsscreen_lookup_sync(struct wsscreen *,
			      const struct wscons_syncops *, void **);

int wsdisplay_maxscreenidx(struct wsdisplay_softc *);
int wsdisplay_screenstate(struct wsdisplay_softc *, int);
int wsdisplay_getactivescreen(struct wsdisplay_softc *);
int wsscreen_switchwait(struct wsdisplay_softc *, int);
d188 1
a188 1
int wsdisplay_internal_ioctl(struct wsdisplay_softc *sc,
d191 1
a191 1
				  int flag, struct proc *p);
d193 2
a194 2
int wsdisplay_usl_ioctl1(struct wsdisplay_softc *,
			     u_long, caddr_t, int, struct proc *);
d196 2
a197 2
int wsdisplay_usl_ioctl2(struct wsdisplay_softc *, struct wsscreen *,
			     u_long, caddr_t, int, struct proc *);
d199 1
a199 1
int wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc,
d201 1
a201 1
			     int flag, struct proc *p);
d207 1
a207 1
void wsdisplay_switchtoconsole(void);
d209 1
a209 1
    wsdisplay_screentype_pick(const struct wsscreen_list *, const char *);
d214 2
a215 2
void wsdisplay_burn(void *v, u_int flags);
void wsscrollback(void *v, int op);
@


1.10.6.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.10.6.1 2002/06/11 03:42:31 art Exp $ */
a68 5
/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
#define WSCOL_WHITE	wscol_white
#define WSCOL_BLACK	wscol_black
#else
a69 2
#define WSCOL_WHITE	7
#endif
d76 1
a84 6

/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
extern int wscol_white, wscol_black;
extern int wskernel_fg, wskernel_bg;
#endif
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d118 1
d214 2
a215 1
void wsscrollback __P((void *, int op));
d220 7
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.10.2.1 2001/05/14 22:26:30 niklas Exp $ */
a117 1
	void	(*burn_screen) __P((void *, u_int, u_int));
d213 1
a213 2
void wsdisplay_burn __P((void *v, u_int flags));
void wsscrollback __P((void *v, int op));
a217 7

/*
 * screen burner
 */
#define	WSDISPLAY_DEFBURNOUT	600000	/* ms */
#define	WSDISPLAY_DEFBURNIN	250	/* ms */

@


1.10.2.3
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d53 12
a64 12
	void	(*cursor)(void *c, int on, int row, int col);
	int	(*mapchar)(void *, int, unsigned int *);
	void	(*putchar)(void *c, int row, int col,
				u_int uc, long attr);
	void	(*copycols)(void *c, int row, int srccol, int dstcol,
		    int ncols);
	void	(*erasecols)(void *c, int row, int startcol,
		    int ncols, long);
	void	(*copyrows)(void *c, int srcrow, int dstrow,
		    int nrows);
	void	(*eraserows)(void *c, int row, int nrows, long);
	int	(*alloc_attr)(void *c, int fg, int bg, int flags, long *);
d107 13
a119 13
	int	(*ioctl)(void *v, u_long cmd, caddr_t data, int flag,
		    struct proc *p);
	paddr_t	(*mmap)(void *v, off_t off, int prot);
	int	(*alloc_screen)(void *, const struct wsscreen_descr *,
				     void **, int *, int *, long *);
	void	(*free_screen)(void *, void *);
	int	(*show_screen)(void *, void *, int,
			       void (*) (void *, int, int), void *);
	int	(*load_font)(void *, void *, struct wsdisplay_font *);
	void	(*scrollback)(void *, void *, int);
	u_int16_t (*getchar)(void *, int, int);
	void	(*burn_screen)(void *, u_int, u_int);
	void	(*pollc)(void *, int);
d153 4
a156 4
	int (*detach)(void *, int, void (*)(void *, int, int), void *);
	int (*attach)(void *, int, void (*)(void *, int, int), void *);
	int (*check)(void *);
	void (*destroy)(void *);
d162 4
a165 4
void	wsdisplay_cnattach(const struct wsscreen_descr *, void *,
				int, int, long);
int	wsdisplaydevprint(void *, const char *);
int	wsemuldisplaydevprint(void *, const char *);
d170 1
a170 1
void	wsdisplay_cnputc(dev_t dev, int i);
d177 10
a186 10
int wsscreen_attach_sync(struct wsscreen *,
			      const struct wscons_syncops *, void *);
int wsscreen_detach_sync(struct wsscreen *);
int wsscreen_lookup_sync(struct wsscreen *,
			      const struct wscons_syncops *, void **);

int wsdisplay_maxscreenidx(struct wsdisplay_softc *);
int wsdisplay_screenstate(struct wsdisplay_softc *, int);
int wsdisplay_getactivescreen(struct wsdisplay_softc *);
int wsscreen_switchwait(struct wsdisplay_softc *, int);
d188 1
a188 1
int wsdisplay_internal_ioctl(struct wsdisplay_softc *sc,
d191 1
a191 1
				  int flag, struct proc *p);
d193 2
a194 2
int wsdisplay_usl_ioctl1(struct wsdisplay_softc *,
			     u_long, caddr_t, int, struct proc *);
d196 2
a197 2
int wsdisplay_usl_ioctl2(struct wsdisplay_softc *, struct wsscreen *,
			     u_long, caddr_t, int, struct proc *);
d199 1
a199 1
int wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc,
d201 1
a201 1
			     int flag, struct proc *p);
d207 1
a207 1
void wsdisplay_switchtoconsole(void);
d209 1
a209 1
    wsdisplay_screentype_pick(const struct wsscreen_list *, const char *);
d214 2
a215 2
void wsdisplay_burn(void *v, u_int flags);
void wsscrollback(void *v, int op);
@


1.10.2.4
log
@Sync the SMP branch with 3.3
@
text
@a39 3
#define WSDISPLAY_MAXSCREEN	12
#define WSDISPLAY_MAXFONT	8

a65 5
/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
#define WSCOL_WHITE	wscol_white
#define WSCOL_BLACK	wscol_black
#else
a66 2
#define WSCOL_WHITE	7
#endif
d73 1
a81 6

/* XXX should be #if NWSEMUL_SUN > 1 */
#if defined(__sparc__) || defined(__sparc64__)
extern int wscol_white, wscol_black;
extern int wskernel_fg, wskernel_bg;
#endif
@


1.9
log
@Kernel support for console mouse functionality which will be controlled by
the wsmoused daemon (replacement for moused which was used with PCVT). Adds
a "getchar" method to the display drivers which returns the value of the
character currently under the cursor (e.g., so it may be inversed). From jbm@@.

Still needs a bit of cleanup and improvement, especially X cohabitation
features. The pointer moves to fast as well. These sorts of issues will be
corrected in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.8 2001/03/14 02:49:22 mickey Exp $ */
d118 1
d214 2
a215 1
void wsscrollback __P((void *, int op));
d220 7
@


1.8
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.7 2001/02/10 19:42:06 mickey Exp $ */
d117 1
@


1.7
log
@sync w/ netbsd; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.6 2001/02/08 02:47:12 aaron Exp $ */
d83 2
d86 1
a86 1
	char *name;
@


1.6
log
@Cause keypresses to reset the screen in case we are in scrollback (previously
the screen was only restored if a new character was actually displayed on the
screen); jcs@@rt.fm. This brings us closer to the behavior of PCVT. Also, while
I'm here, add some #ifdef so wskbd does not depend on wsdisplay (pointed out
to me by fgsch@@).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.5 2001/01/31 16:38:02 aaron Exp $ */
d115 1
d202 1
d204 2
@


1.5
log
@OpenBSD does have paddr_t, I can't explain why I thought it didn't; art@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.4 2001/01/31 02:12:29 aaron Exp $ */
d208 3
a210 2
#define WSCONS_SCROLL_BACKWARD	0
#define WSCONS_SCROLL_FORWARD	1
@


1.4
log
@Some int -> u_long (I incorrectly converted paddr_t to int when porting this).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.3 2000/11/15 20:00:39 aaron Exp $ */
d107 1
a107 1
	u_long	(*mmap) __P((void *v, off_t off, int prot));
@


1.3
log
@Support console scrollback in wscons through a new "scrollback" accessop that
hooks into the lower-level display driver. The updated vga(4) driver I'm about
to commit has support for this. This is a fairly unobtrusive way to implement
scrollback while maintaining the abstraction of the wscons system.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
d107 1
a107 1
	int	(*mmap) __P((void *v, off_t off, int prot));
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplayvar.h,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d114 1
d202 8
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wsdisplayvar.h,v 1.14 1999/12/06 18:52:23 drochner Exp $ */
@

