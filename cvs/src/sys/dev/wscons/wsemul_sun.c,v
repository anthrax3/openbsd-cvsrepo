head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.6
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.32.0.8
	OPENBSD_6_1_BASE:1.32
	OPENBSD_6_0:1.32.0.4
	OPENBSD_6_0_BASE:1.32
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.31.0.8
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.31.0.6
	OPENBSD_5_7_BASE:1.31
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.28.0.16
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.28.0.14
	OPENBSD_5_3_BASE:1.28
	OPENBSD_5_2:1.28.0.12
	OPENBSD_5_2_BASE:1.28
	OPENBSD_5_1_BASE:1.28
	OPENBSD_5_1:1.28.0.10
	OPENBSD_5_0:1.28.0.8
	OPENBSD_5_0_BASE:1.28
	OPENBSD_4_9:1.28.0.6
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.28.0.4
	OPENBSD_4_8_BASE:1.28
	OPENBSD_4_7:1.28.0.2
	OPENBSD_4_7_BASE:1.28
	OPENBSD_4_6:1.24.0.4
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.23.0.6
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.4
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.23.0.2
	OPENBSD_4_3_BASE:1.23
	OPENBSD_4_2:1.20.0.4
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.17.0.2
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.13.0.6
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.4
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.6
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.11
	UBC:1.3.0.8
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.6
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.32
date	2015.08.28.00.03.53;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	NdgfPIGUgJxQPnT7;

1.31
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.10.18.13.54.09;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.05.16.51.19;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.05.14.49.20;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.05.14.30.24;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.05.13.43.58;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2009.05.06.20.00.57;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2007.11.27.16.37.27;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.26.16.56.42;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.25.19.11.42;	author miod;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.14.01.12.16;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.01.07.13.28.50;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.12.02.11.25.09;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.08.17.06.27.04;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.01.16.16.53;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.30.21.38.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.29.17.54.32;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.09.17.48.41;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.24.22.07.58;	author miod;	state Exp;
branches;
next	1.11;

1.11
date	2002.09.23.18.10.09;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2002.09.15.12.54.49;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2002.09.09.22.14.42;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2002.09.05.17.12.03;	author jason;	state Exp;
branches;
next	1.7;

1.7
date	2002.08.29.22.19.33;	author miod;	state Exp;
branches;
next	1.6;

1.6
date	2002.07.25.19.03.25;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.30.18.25.44;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2001.04.14.04.48.00;	author aaron;	state Exp;
branches
	1.3.4.1
	1.3.8.1;
next	1.2;

1.2
date	2001.03.07.17.51.29;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.31;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2004.06.05.23.13.00;	author niklas;	state Exp;
branches;
next	;

1.3.8.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	1.3.8.2;

1.3.8.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.32
log
@fairly simple sizes for free(); ok tedu
@
text
@/* $OpenBSD: wsemul_sun.c,v 1.31 2014/07/12 18:48:53 tedu Exp $ */
/* $NetBSD: wsemul_sun.c,v 1.11 2000/01/05 11:19:36 drochner Exp $ */

/*
 * Copyright (c) 2007, 2013 Miodrag Vallat.
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice, this permission notice, and the disclaimer below
 * appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This file implements a sun terminal personality for wscons.
 *
 * Derived from old rcons code.
 * Color support from NetBSD's rcons color code, and wsemul_vt100.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/time.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>

#include <dev/wscons/wscons_features.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/ascii.h>

void	*wsemul_sun_cnattach(const struct wsscreen_descr *, void *,
    int, int, long);
void	*wsemul_sun_attach(int, const struct wsscreen_descr *,
    void *, int, int, void *, long);
u_int	wsemul_sun_output(void *, const u_char *, u_int, int);
int	wsemul_sun_translate(void *, kbd_t, keysym_t, const u_char **);
void	wsemul_sun_detach(void *, u_int *, u_int *);
void	wsemul_sun_resetop(void *, enum wsemul_resetops);

const struct wsemul_ops wsemul_sun_ops = {
	"sun",
	wsemul_sun_cnattach,
	wsemul_sun_attach,
	wsemul_sun_output,
	wsemul_sun_translate,
	wsemul_sun_detach,
	wsemul_sun_resetop
};

#define	SUN_EMUL_STATE_NORMAL	0	/* normal processing */
#define	SUN_EMUL_STATE_HAVEESC	1	/* seen start of ctl seq */
#define	SUN_EMUL_STATE_CONTROL	2	/* processing ESC [ ctl seq */
#define	SUN_EMUL_STATE_PERCENT	3	/* processing ESC % ctl seq */

#define	SUN_EMUL_FLAGS_UTF8	0x01	/* UTF-8 character set */

#define	SUN_EMUL_NARGS	2		/* max # of args to a command */

struct wsemul_sun_emuldata {
	const struct wsdisplay_emulops *emulops;
	struct wsemul_abortstate abortstate;
	void *emulcookie;
	void *cbcookie;
	int scrcapabilities;
	u_int nrows, ncols, crow, ccol;
	long defattr;			/* default attribute (rendition) */

	u_int state;			/* processing state */
	u_int flags;
	u_int args[SUN_EMUL_NARGS];	/* command args, if CONTROL */
	int nargs;			/* number of args */

	u_int scrolldist;		/* distance to scroll */
	long curattr, bkgdattr;		/* currently used attribute */
	long kernattr;			/* attribute for kernel output */
	int attrflags, fgcol, bgcol;	/* properties of curattr */

	struct wsemul_inputstate instate;	/* userland input state */
	struct wsemul_inputstate kstate;	/* kernel input state */

#ifdef HAVE_UTF8_SUPPORT
	u_char translatebuf[6];
#else
	u_char translatebuf[1];
#endif

#ifdef DIAGNOSTIC
	int console;
#endif
};

void	wsemul_sun_init(struct wsemul_sun_emuldata *,
	    const struct wsscreen_descr *, void *, int, int, long);
int	wsemul_sun_jump_scroll(struct wsemul_sun_emuldata *, const u_char *,
	    u_int, int);
void	wsemul_sun_reset(struct wsemul_sun_emuldata *);
int	wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *, int);
int	wsemul_sun_output_normal(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *, int);
int	wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *);
int	wsemul_sun_output_control(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *);
int	wsemul_sun_output_percent(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *);
int	wsemul_sun_control(struct wsemul_sun_emuldata *,
	    struct wsemul_inputstate *);
int	wsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,
	    long *, long *);
int	wsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);

struct wsemul_sun_emuldata wsemul_sun_console_emuldata;

/* some useful utility macros */
#define	ARG(n,c) \
	((n) >= edp->nargs ? 0 : edp->args[(n) + MAX(0, edp->nargs - (c))])
#define	NORMALIZE(arg)		((arg) != 0 ? (arg) : 1)
#define	COLS_LEFT		(edp->ncols - 1 - edp->ccol)
#define	ROWS_LEFT		(edp->nrows - 1 - edp->crow)

void
wsemul_sun_init(struct wsemul_sun_emuldata *edp,
    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,
    long defattr)
{
	edp->emulops = type->textops;
	edp->emulcookie = cookie;
	edp->scrcapabilities = type->capabilities;
	edp->nrows = type->nrows;
	edp->ncols = type->ncols;
	edp->crow = crow;
	edp->ccol = ccol;
	edp->defattr = defattr;
	wsemul_reset_abortstate(&edp->abortstate);
}

void
wsemul_sun_reset(struct wsemul_sun_emuldata *edp)
{
	edp->flags = 0;
	edp->state = SUN_EMUL_STATE_NORMAL;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_BLACK;
	edp->bgcol = WSCOL_WHITE;
	edp->scrolldist = 1;
	edp->instate.inchar = 0;
	edp->instate.mbleft = 0;
	edp->kstate.inchar = 0;
	edp->kstate.mbleft = 0;
}

void *
wsemul_sun_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
{
	struct wsemul_sun_emuldata *edp;
	int res;

	edp = &wsemul_sun_console_emuldata;
	wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);

#ifndef WS_KERNEL_FG
#define WS_KERNEL_FG WSCOL_BLACK
#endif
#ifndef WS_KERNEL_BG
#define WS_KERNEL_BG WSCOL_WHITE
#endif
#ifndef WS_KERNEL_COLATTR
#define WS_KERNEL_COLATTR 0
#endif
#ifndef WS_KERNEL_MONOATTR
#define WS_KERNEL_MONOATTR 0
#endif
	if (type->capabilities & WSSCREEN_WSCOLORS)
		res = (*edp->emulops->alloc_attr)(cookie,
					    WS_KERNEL_FG, WS_KERNEL_BG,
					    WS_KERNEL_COLATTR | WSATTR_WSCOLORS,
					    &edp->kernattr);
	else
		res = (*edp->emulops->alloc_attr)(cookie, 0, 0,
					    WS_KERNEL_MONOATTR,
					    &edp->kernattr);
	if (res)
		edp->kernattr = defattr;

	edp->cbcookie = NULL;

#ifdef DIAGNOSTIC
	edp->console = 1;
#endif

	wsemul_sun_reset(edp);
	return (edp);
}

void *
wsemul_sun_attach(int console, const struct wsscreen_descr *type, void *cookie,
    int ccol, int crow, void *cbcookie, long defattr)
{
	struct wsemul_sun_emuldata *edp;

	if (console) {
		edp = &wsemul_sun_console_emuldata;
#ifdef DIAGNOSTIC
		KASSERT(edp->console == 1);
#endif
	} else {
		edp = malloc(sizeof *edp, M_DEVBUF, M_NOWAIT);
		if (edp == NULL)
			return (NULL);
		wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);

#ifdef DIAGNOSTIC
		edp->console = 0;
#endif
	}

	edp->cbcookie = cbcookie;

	wsemul_sun_reset(edp);
	return (edp);
}

int
wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate, int kernel)
{
	u_int n;
	int rc = 0;

	switch (instate->inchar) {
	case ASCII_NUL:
	default:
		/* ignore */
		break;

	case ASCII_BEL:		/* "Bell (BEL)" */
		wsdisplay_emulbell(edp->cbcookie);
		break;

	case ASCII_BS:		/* "Backspace (BS)" */
		if (edp->ccol > 0)
			edp->ccol--;
		break;

	case ASCII_CR:		/* "Return (CR)" */
		edp->ccol = 0;
		break;

	case ASCII_HT:		/* "Tab (TAB)" */
		n = min(8 - (edp->ccol & 7), COLS_LEFT);
		if (n != 0) {
			WSEMULOP(rc, edp, &edp->abortstate, erasecols,
			    (edp->emulcookie, edp->crow, edp->ccol, n,
			     kernel ? edp->kernattr : edp->bkgdattr));
			if (rc != 0)
				break;
			edp->ccol += n;
		}
		break;

	case ASCII_FF:		/* "Form Feed (FF)" */
		WSEMULOP(rc, edp, &edp->abortstate, eraserows,
		    (edp->emulcookie, 0, edp->nrows, edp->bkgdattr));
		if (rc != 0)
			break;
		edp->ccol = edp->crow = 0;
		break;

	case ASCII_VT:		/* "Reverse Line Feed" */
		if (edp->crow > 0)
			edp->crow--;
		break;

	case ASCII_ESC:		/* "Escape (ESC)" */
		if (kernel) {
			printf("wsemul_sun_output_lowchars: ESC in kernel "
			    "output ignored\n");
			break;	/* ignore the ESC */
		}

		edp->state = SUN_EMUL_STATE_HAVEESC;
		break;

	case ASCII_LF:		/* "Line Feed (LF)" */
		/* if the cur line isn't the last, incr and leave. */
		if (ROWS_LEFT > 0)
			edp->crow++;
		else {
			rc = wsemul_sun_scrollup(edp, edp->scrolldist);
			if (rc != 0)
				break;
		}
		break;
	}

	return rc;
}

int
wsemul_sun_output_normal(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate, int kernel)
{
	int rc;
	u_int outchar;

	(*edp->emulops->mapchar)(edp->emulcookie, instate->inchar, &outchar);
	WSEMULOP(rc, edp, &edp->abortstate, putchar,
	    (edp->emulcookie, edp->crow, edp->ccol,
	     outchar, kernel ? edp->kernattr : edp->curattr));
	if (rc != 0)
		return rc;

	if (++edp->ccol >= edp->ncols) {
		/* if the cur line isn't the last, incr and leave. */
		if (ROWS_LEFT > 0)
			edp->crow++;
		else {
			rc = wsemul_sun_scrollup(edp, edp->scrolldist);
			if (rc != 0) {
				/* undo line wrap */
				edp->ccol--;

				return rc;
			}
		}
		edp->ccol = 0;
	}

	return 0;
}

int
wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case '[':		/* continuation of multi-char sequence */
		edp->nargs = 0;
		bzero(edp->args, sizeof (edp->args));
		edp->state = SUN_EMUL_STATE_CONTROL;
		break;
#ifdef HAVE_UTF8_SUPPORT
	case '%':
		edp->state = SUN_EMUL_STATE_PERCENT;
		break;
#endif
	default:
#ifdef DEBUG
		printf("ESC %x unknown\n", instate->inchar);
#endif
		edp->state = SUN_EMUL_STATE_NORMAL;	/* XXX is this wise? */
		break;
	}
	return 0;
}

int
wsemul_sun_control(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	u_int n, src, dst;
	int flags, fgcol, bgcol;
	long attr, bkgdattr;
	int rc = 0;

	switch (instate->inchar) {
	case '@@':		/* "Insert Character (ICH)" */
		n = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);
		src = edp->ccol;
		dst = edp->ccol + n;
		if (dst < edp->ncols) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols,
			    (edp->emulcookie, edp->crow, src, dst,
			     edp->ncols - dst));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    (edp->emulcookie, edp->crow, src, n, edp->bkgdattr));
		break;

	case 'A':		/* "Cursor Up (CUU)" */
		edp->crow -= min(NORMALIZE(ARG(0,1)), edp->crow);
		break;

	case 'E':		/* "Cursor Next Line (CNL)" */
		edp->ccol = 0;
		/* FALLTHROUGH */
	case 'B':		/* "Cursor Down (CUD)" */
		edp->crow += min(NORMALIZE(ARG(0,1)), ROWS_LEFT);
		break;

	case 'C':		/* "Cursor Forward (CUF)" */
		edp->ccol += min(NORMALIZE(ARG(0,1)), COLS_LEFT);
		break;

	case 'D':		/* "Cursor Backward (CUB)" */
		edp->ccol -= min(NORMALIZE(ARG(0,1)), edp->ccol);
		break;

	case 'f':		/* "Horizontal And Vertical Position (HVP)" */
	case 'H':		/* "Cursor Position (CUP)" */
		edp->crow = min(NORMALIZE(ARG(0,2)), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE(ARG(1,2)), edp->ncols) - 1;
		break;

	case 'J':		/* "Erase in Display (ED)" */
		if (ROWS_LEFT > 0) {
			WSEMULOP(rc, edp, &edp->abortstate, eraserows,
			    (edp->emulcookie, edp->crow + 1, ROWS_LEFT,
			     edp->bkgdattr));
			if (rc != 0)
				break;
		}
		/* FALLTHROUGH */
	case 'K':		/* "Erase in Line (EL)" */
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    (edp->emulcookie, edp->crow, edp->ccol, COLS_LEFT + 1,
		     edp->bkgdattr));
		break;

	case 'L':		/* "Insert Line (IL)" */
		n = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);
		src = edp->crow;
		dst = edp->crow + n;
		if (dst < edp->nrows) {
			WSEMULOP(rc, edp, &edp->abortstate, copyrows,
			    (edp->emulcookie, src, dst, edp->nrows - dst));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, eraserows,
		    (edp->emulcookie, src, n, edp->bkgdattr));
		break;

	case 'M':		/* "Delete Line (DL)" */
		n = min(NORMALIZE(ARG(0,1)), ROWS_LEFT + 1);
		src = edp->crow + n;
		dst = edp->crow;
		if (src < edp->nrows) {
			WSEMULOP(rc, edp, &edp->abortstate, copyrows,
			    (edp->emulcookie, src, dst, edp->nrows - src));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, eraserows,
		    (edp->emulcookie, dst + edp->nrows - src, n,
		     edp->bkgdattr));
		break;

	case 'P':		/* "Delete Character (DCH)" */
		n = min(NORMALIZE(ARG(0,1)), COLS_LEFT + 1);
		src = edp->ccol + n;
		dst = edp->ccol;
		if (src < edp->ncols) {
			WSEMULOP(rc, edp, &edp->abortstate, copycols,
			    (edp->emulcookie, edp->crow, src, dst,
			     edp->ncols - src));
			if (rc != 0)
				break;
		}
		WSEMULOP(rc, edp, &edp->abortstate, erasecols,
		    (edp->emulcookie, edp->crow, edp->ncols - n, n,
		     edp->bkgdattr));
		break;

	case 'm':		/* "Select Graphic Rendition (SGR)" */
		flags = edp->attrflags;
		fgcol = edp->fgcol;
		bgcol = edp->bgcol;

		for (n = 0; n < edp->nargs; n++) {
			switch (ARG(n,edp->nargs)) {
			/* Clear all attributes || End underline */
			case 0:
				if (n == edp->nargs - 1) {
					edp->bkgdattr =
					    edp->curattr = edp->defattr;
					edp->attrflags = 0;
					edp->fgcol = WSCOL_BLACK;
					edp->bgcol = WSCOL_WHITE;
					return 0;
				}
				flags = 0;
				fgcol = WSCOL_BLACK;
				bgcol = WSCOL_WHITE;
				break;
			/* Begin bold */
			case 1:
				flags |= WSATTR_HILIT;
				break;
			/* Begin underline */
			case 4:
				flags |= WSATTR_UNDERLINE;
				break;
			/* Begin reverse */
			case 7:
				flags |= WSATTR_REVERSE;
				break;
			/* ANSI foreground color */
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
				fgcol = ARG(n,edp->nargs) - 30;
				break;
			/* ANSI background color */
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
				bgcol = ARG(n,edp->nargs) - 40;
				break;
			}
		}
setattr:
		if (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr,
		    &bkgdattr)) {
#ifdef DEBUG
			printf("error allocating attr %d/%d/%x\n",
			    fgcol, bgcol, flags);
#endif
		} else {
			edp->curattr = attr;
			edp->bkgdattr = bkgdattr;
			edp->attrflags = flags;
			edp->fgcol = fgcol;
			edp->bgcol = bgcol;
		}
		break;

	case 'p':		/* "Black On White (SUNBOW)" */
		flags = 0;
		fgcol = WSCOL_BLACK;
		bgcol = WSCOL_WHITE;
		goto setattr;

	case 'q':		/* "White On Black (SUNWOB)" */
		flags = 0;
		fgcol = WSCOL_WHITE;
		bgcol = WSCOL_BLACK;
		goto setattr;

	case 'r':		/* "Set Scrolling (SUNSCRL)" */
		edp->scrolldist = min(ARG(0,1), edp->nrows);
		break;

	case 's':		/* "Reset Terminal Emulator (SUNRESET)" */
		wsemul_sun_reset(edp);
		break;
	}

	return rc;
}

int
wsemul_sun_output_control(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	int oargs;
	int rc;

	switch (instate->inchar) {
	case '0': case '1': case '2': case '3': case '4': /* argument digit */
	case '5': case '6': case '7': case '8': case '9':
		/*
		 * If we receive more arguments than we are expecting,
		 * discard the earliest arguments.
		 */
		if (edp->nargs > SUN_EMUL_NARGS - 1) {
			bcopy(edp->args + 1, edp->args,
			    (SUN_EMUL_NARGS - 1) * sizeof(edp->args[0]));
			edp->args[edp->nargs = SUN_EMUL_NARGS - 1] = 0;
		}
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (instate->inchar - '0');
		break;

	case ';':		/* argument terminator */
		edp->nargs++;
		break;

	default:		/* end of escape sequence */
		oargs = edp->nargs++;
		if (edp->nargs > SUN_EMUL_NARGS)
			edp->nargs = SUN_EMUL_NARGS;
		rc = wsemul_sun_control(edp, instate);
		if (rc != 0) {
			/* undo nargs progress */
			edp->nargs = oargs;

			return rc;
		}
		edp->state = SUN_EMUL_STATE_NORMAL;
		break;
	}

	return 0;
}

#ifdef HAVE_UTF8_SUPPORT
int
wsemul_sun_output_percent(struct wsemul_sun_emuldata *edp,
    struct wsemul_inputstate *instate)
{
	switch (instate->inchar) {
	case 'G':
		edp->flags |= SUN_EMUL_FLAGS_UTF8;
		edp->kstate.mbleft = edp->instate.mbleft = 0;
		break;
	case '@@':
		edp->flags &= ~SUN_EMUL_FLAGS_UTF8;
		break;
	}
	edp->state = SUN_EMUL_STATE_NORMAL;
	return 0;
}
#endif

u_int
wsemul_sun_output(void *cookie, const u_char *data, u_int count, int kernel)
{
	struct wsemul_sun_emuldata *edp = cookie;
	struct wsemul_inputstate *instate;
	u_int processed = 0;
#ifdef HAVE_JUMP_SCROLL
	int lines;
#endif
	int rc = 0;

#ifdef DIAGNOSTIC
	if (kernel && !edp->console)
		panic("wsemul_sun_output: kernel output, not console");
#endif

	instate = kernel ? &edp->kstate : &edp->instate;

	switch (edp->abortstate.state) {
	case ABORT_FAILED_CURSOR:
		/*
		 * If we could not display the cursor back, we pretended not
		 * having been able to display the last character. But this
		 * is a lie, so compensate here.
		 */
		data++, count--;
		processed++;
		wsemul_reset_abortstate(&edp->abortstate);
		break;
	case ABORT_OK:
		/* remove cursor image */
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 0, edp->crow, edp->ccol);
		if (rc != 0)
			return 0;
		break;
	default:
		break;
	}

	for (;;) {
#ifdef HAVE_JUMP_SCROLL
		switch (edp->abortstate.state) {
		case ABORT_FAILED_JUMP_SCROLL:
			/*
			 * If we failed a previous jump scroll attempt, we
			 * need to try to resume it with the same distance.
			 * We can not recompute it since there might be more
			 * bytes in the tty ring, causing a different result.
			 */
			lines = edp->abortstate.lines;
			break;
		case ABORT_OK:
			/*
			 * If scrolling is not disabled and we are the bottom of
			 * the screen, count newlines until an escape sequence
			 * appears.
			 */
			if ((edp->state == SUN_EMUL_STATE_NORMAL || kernel) &&
			    ROWS_LEFT == 0 && edp->scrolldist != 0)
				lines = wsemul_sun_jump_scroll(edp, data,
				    count, kernel);
			else
				lines = 0;
			break;
		default:
			/*
			 * If we are recovering a non-scrolling failure,
			 * do not try to scroll yet.
			 */
			lines = 0;
			break;
		}

		if (lines > 1) {
			wsemul_resume_abort(&edp->abortstate);
			rc = wsemul_sun_scrollup(edp, lines);
			if (rc != 0) {
				wsemul_abort_jump_scroll(&edp->abortstate,
				    lines);
				return processed;
			}
			wsemul_reset_abortstate(&edp->abortstate);
			edp->crow--;
		}
#endif

		wsemul_resume_abort(&edp->abortstate);

		if (wsemul_getchar(&data, &count, instate,
#ifdef HAVE_UTF8_SUPPORT
		    (edp->state == SUN_EMUL_STATE_NORMAL && !kernel) ?
		      edp->flags & SUN_EMUL_FLAGS_UTF8 : 0
#else
		    0
#endif
		    ) != 0)
			break;

		if (instate->inchar < ' ') {
			rc = wsemul_sun_output_lowchars(edp, instate, kernel);
			if (rc != 0)
				break;
			processed++;
			continue;
		}

		if (kernel) {
			rc = wsemul_sun_output_normal(edp, instate, 1);
			if (rc != 0)
				break;
			processed++;
			continue;
		}

		switch (edp->state) {
		case SUN_EMUL_STATE_NORMAL:
			rc = wsemul_sun_output_normal(edp, instate, 0);
			break;
		case SUN_EMUL_STATE_HAVEESC:
			rc = wsemul_sun_output_haveesc(edp, instate);
			break;
		case SUN_EMUL_STATE_CONTROL:
			rc = wsemul_sun_output_control(edp, instate);
			break;
#ifdef HAVE_UTF8_SUPPORT
		case SUN_EMUL_STATE_PERCENT:
			rc = wsemul_sun_output_percent(edp, instate);
			break;
#endif
		default:
#ifdef DIAGNOSTIC
			panic("wsemul_sun: invalid state %d", edp->state);
#else
			/* try to recover, if things get screwed up... */
			edp->state = SUN_EMUL_STATE_NORMAL;
			rc = wsemul_sun_output_normal(edp, instate, 0);
#endif
			break;
		}
		if (rc != 0)
			break;
		processed++;
	}

	if (rc != 0)
		wsemul_abort_other(&edp->abortstate);
	else {
		/* put cursor image back */
		rc = (*edp->emulops->cursor)
		    (edp->emulcookie, 1, edp->crow, edp->ccol);
		if (rc != 0) {
			/*
			 * Fail the last character output, remembering that
			 * only the cursor operation really needs to be done.
			 */
			wsemul_abort_cursor(&edp->abortstate);
			processed--;
		}
	}

	if (rc == 0)
		wsemul_reset_abortstate(&edp->abortstate);

	return processed;
}

#ifdef HAVE_JUMP_SCROLL
int
wsemul_sun_jump_scroll(struct wsemul_sun_emuldata *edp, const u_char *data,
    u_int count, int kernel)
{
	u_int pos, lines;
	struct wsemul_inputstate tmpstate;

	lines = 0;
	pos = edp->ccol;
	tmpstate = kernel ? edp->kstate : edp->instate;	/* structure copy */

	while (wsemul_getchar(&data, &count, &tmpstate,
#ifdef HAVE_UTF8_SUPPORT
	    kernel ? 0 : edp->flags & SUN_EMUL_FLAGS_UTF8
#else
	    0
#endif
	    ) == 0) {
		if (tmpstate.inchar == ASCII_FF ||
		    tmpstate.inchar == ASCII_VT ||
		    tmpstate.inchar == ASCII_ESC)
			break;

		switch (tmpstate.inchar) {
		case ASCII_BS:
			if (pos > 0)
				pos--;
			break;
		case ASCII_CR:
			pos = 0;
			break;
		case ASCII_HT:
			pos = (pos + 7) & ~7;
			if (pos >= edp->ncols)
				pos = edp->ncols - 1;
			break;
		case ASCII_LF:
			break;
		default:
			if (++pos >= edp->ncols) {
				pos = 0;
				tmpstate.inchar = ASCII_LF;
			}
			break;
		}
		if (tmpstate.inchar == ASCII_LF) {
			if (++lines >= edp->nrows - 1)
				break;
		}
	}

	return lines;
}
#endif

/*
 * Get an attribute from the graphics driver.
 * Try to find replacements if the desired appearance is not supported.
 */
int
wsemul_sun_selectattribute(struct wsemul_sun_emuldata *edp, int flags,
    int fgcol, int bgcol, long *attr, long *bkgdattr)
{
	int error;

	/*
	 * Rasops will force white on black as normal output colors, unless
	 * WSATTR_WSCOLORS is specified. Since Sun console is black on white,
	 * always use WSATTR_WSCOLORS and our colors, as we know better.
	 */
	if (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {
		flags &= ~WSATTR_WSCOLORS;
	} else {
		flags |= WSATTR_WSCOLORS;
	}

	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags & WSATTR_WSCOLORS, bkgdattr);
	if (error)
		return (error);

	if ((flags & WSATTR_HILIT) &&
	    !(edp->scrcapabilities & WSSCREEN_HILIT)) {
		flags &= ~WSATTR_HILIT;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_RED;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_UNDERLINE) &&
	    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {
		flags &= ~WSATTR_UNDERLINE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_CYAN;
			flags &= ~WSATTR_UNDERLINE;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_BLINK) &&
	    !(edp->scrcapabilities & WSSCREEN_BLINK)) {
		flags &= ~WSATTR_BLINK;
	}
	if ((flags & WSATTR_REVERSE) &&
	    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {
		flags &= ~WSATTR_REVERSE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			int help;
			help = bgcol;
			bgcol = fgcol;
			fgcol = help;
			flags |= WSATTR_WSCOLORS;
		}
	}
	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags, attr);
	if (error)
		return (error);

	return (0);
}

static const u_char *sun_fkeys[] = {
	"\033[224z",	/* F1 */
	"\033[225z",
	"\033[226z",
	"\033[227z",
	"\033[228z",
	"\033[229z",
	"\033[230z",
	"\033[231z",
	"\033[232z",
	"\033[233z",
	"\033[234z",
	"\033[235z",	/* F12 */
};

static const u_char *sun_lkeys[] = {
	"\033[207z",	/* KS_Help */
	NULL,		/* KS_Execute */
	"\033[200z",	/* KS_Find */
	NULL,		/* KS_Select */
	"\033[193z",	/* KS_Again */
	"\033[194z",	/* KS_Props */
	"\033[195z",	/* KS_Undo */
	"\033[196z",	/* KS_Front */
	"\033[197z",	/* KS_Copy */
	"\033[198z",	/* KS_Open */
	"\033[199z",	/* KS_Paste */
	"\033[201z",	/* KS_Cut */
};

int
wsemul_sun_translate(void *cookie, kbd_t layout, keysym_t in,
    const u_char **out)
{
	struct wsemul_sun_emuldata *edp = cookie;

	if (KS_GROUP(in) == KS_GROUP_Ascii) {
		*out = edp->translatebuf;
		return (wsemul_utf8_translate(KS_VALUE(in), layout,
		    edp->translatebuf, edp->flags & SUN_EMUL_FLAGS_UTF8));
	}

	if (KS_GROUP(in) == KS_GROUP_Keypad && (in & 0x80) == 0) {
		edp->translatebuf[0] = in & 0xff; /* turn into ASCII */
		*out = edp->translatebuf;
		return (1);
	}

	if (in >= KS_f1 && in <= KS_f12) {
		*out = sun_fkeys[in - KS_f1];
		return (6);
	}
	if (in >= KS_F1 && in <= KS_F12) {
		*out = sun_fkeys[in - KS_F1];
		return (6);
	}
	if (in >= KS_KP_F1 && in <= KS_KP_F4) {
		*out = sun_fkeys[in - KS_KP_F1];
		return (6);
	}
	if (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {
		*out = sun_lkeys[in - KS_Help];
		return (6);
	}

	switch (in) {
	case KS_Home:
	case KS_KP_Home:
	case KS_KP_Begin:
		*out = "\033[214z";
		return (6);
	case KS_End:
	case KS_KP_End:
		*out = "\033[220z";
		return (6);
	case KS_Insert:
	case KS_KP_Insert:
		*out = "\033[247z";
		return (6);
	case KS_Prior:
	case KS_KP_Prior:
		*out = "\033[216z";
		return (6);
	case KS_Next:
	case KS_KP_Next:
		*out = "\033[222z";
		return (6);
	case KS_Up:
	case KS_KP_Up:
		*out = "\033[A";
		return (3);
	case KS_Down:
	case KS_KP_Down:
		*out = "\033[B";
		return (3);
	case KS_Left:
	case KS_KP_Left:
		*out = "\033[D";
		return (3);
	case KS_Right:
	case KS_KP_Right:
		*out = "\033[C";
		return (3);
	case KS_KP_Delete:
		*out = "\177";
		return (1);
	}
	return (0);
}

void
wsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp)
{
	struct wsemul_sun_emuldata *edp = cookie;

	*crowp = edp->crow;
	*ccolp = edp->ccol;
	if (edp != &wsemul_sun_console_emuldata)
		free(edp, M_DEVBUF, sizeof *edp);
}

void
wsemul_sun_resetop(void *cookie, enum wsemul_resetops op)
{
	struct wsemul_sun_emuldata *edp = cookie;

	switch (op) {
	case WSEMUL_RESET:
		wsemul_sun_reset(edp);
		break;
	case WSEMUL_CLEARSCREEN:
		(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,
		    edp->bkgdattr);
		edp->ccol = edp->crow = 0;
		(*edp->emulops->cursor)(edp->emulcookie, 1, 0, 0);
		break;
	case WSEMUL_CLEARCURSOR:
		(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow,
		    edp->ccol);
		break;
	default:
		break;
	}
}

int
wsemul_sun_scrollup(struct wsemul_sun_emuldata *edp, u_int lines)
{
	int rc;

	/*
	 * if we're in wrap-around mode, go to the first
	 * line and clear it.
	 */
	if (lines == 0) {
		WSEMULOP(rc, edp, &edp->abortstate, eraserows,
		    (edp->emulcookie, 0, 1, edp->bkgdattr));
		if (rc != 0)
			return rc;

		edp->crow = 0;
		return 0;
	}

	/*
	 * If the scrolling distance is equal to the screen height
	 * (usually 34), clear the screen; otherwise, scroll by the
	 * scrolling distance.
	 */
	if (lines < edp->nrows) {
		WSEMULOP(rc, edp, &edp->abortstate, copyrows,
		    (edp->emulcookie, lines, 0, edp->nrows - lines));
		if (rc != 0)
			return rc;
	}
	WSEMULOP(rc, edp, &edp->abortstate, eraserows,
	    (edp->emulcookie, edp->nrows - lines, lines, edp->bkgdattr));
	if (rc != 0)
		return rc;

	edp->crow -= lines - 1;

	return 0;
}
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.30 2013/10/18 22:06:41 miod Exp $ */
d1065 1
a1065 1
		free(edp, M_DEVBUF, 0);
@


1.30
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.29 2013/10/18 13:54:09 miod Exp $ */
d1065 1
a1065 1
		free(edp, M_DEVBUF);
@


1.29
log
@Introduce a dedicated private header file to control the optional features
of wscons (which usually get disabled for installation kernels, to save
space), instead of duplicating parts of it to too many places.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.28 2009/09/05 16:51:19 miod Exp $ */
d5 16
d75 1
a75 1
int	wsemul_sun_translate(void *, keysym_t, const char **);
d91 4
a94 1
#define	SUN_EMUL_STATE_CONTROL	2	/* processing ctl seq */
d108 1
d117 9
d136 12
a147 5
int	wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, u_char, int);
int	wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char, int);
void	wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, u_char);
int	wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
int	wsemul_sun_control(struct wsemul_sun_emuldata *, u_char);
d180 1
d187 4
d266 2
a267 2
wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *edp, u_char c,
    int kernel)
d272 1
a272 1
	switch (c) {
d342 2
a343 1
wsemul_sun_output_normal(struct wsemul_sun_emuldata *edp, u_char c, int kernel)
d346 1
d348 1
d351 1
a351 1
	     c, kernel ? edp->kernattr : edp->curattr));
d374 3
a376 2
void
wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *edp, u_char c)
d378 1
a378 1
	switch (c) {
d384 5
a388 1

d391 1
a391 1
		printf("ESC%c unknown\n", c);
d396 1
d400 2
a401 1
wsemul_sun_control(struct wsemul_sun_emuldata *edp, u_char c)
d408 1
a408 1
	switch (c) {
d595 2
a596 1
wsemul_sun_output_control(struct wsemul_sun_emuldata *edp, u_char c)
d601 1
a601 1
	switch (c) {
d614 1
a614 1
		    (c - '0');
d625 1
a625 1
		rc = wsemul_sun_control(edp, c);
d639 19
d662 1
a663 1
	u_char c;
d674 2
d698 1
a698 1
	for (; count > 0; data++, count--) {
d747 12
a758 3
		c = *data;
		if (c < ' ') {
			rc = wsemul_sun_output_lowchars(edp, c, kernel);
d766 1
a766 1
			rc = wsemul_sun_output_normal(edp, c, 1);
d775 1
a775 1
			rc = wsemul_sun_output_normal(edp, c, 0);
d778 1
a778 1
			wsemul_sun_output_haveesc(edp, c);
d781 5
a785 1
			rc = wsemul_sun_output_control(edp, c);
d787 1
d794 1
a794 1
			rc = wsemul_sun_output_normal(edp, c, 0);
a829 1
	u_char curchar;
d831 1
d835 12
a846 4
	for (; count != 0; data++, count--) {
		curchar = *data;
		if (curchar == ASCII_FF ||
		    curchar == ASCII_VT || curchar == ASCII_ESC)
d849 1
a849 1
		switch (curchar) {
d867 1
a867 1
				curchar = ASCII_LF;
d871 1
a871 1
		if (curchar == ASCII_LF) {
d947 1
a947 1
static const char *sun_fkeys[] = {
d962 1
a962 1
static const char *sun_lkeys[] = {
d978 2
a979 1
wsemul_sun_translate(void *cookie, keysym_t in, const char **out)
d981 7
a987 1
	static char c;
d990 2
a991 2
		c = in & 0xff; /* turn into ASCII */
		*out = &c;
@


1.28
log
@Buglet crept in.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.27 2009/09/05 14:49:20 miod Exp $ */
a40 4
#ifndef	SMALL_KERNEL
#define	JUMP_SCROLL
#endif

d47 1
d593 1
a593 1
#ifdef JUMP_SCROLL
d626 1
a626 1
#ifdef JUMP_SCROLL
d738 1
a738 1
#ifdef JUMP_SCROLL
@


1.27
log
@Check the return value of all emulops in the emulation code, and abort
tty output as soon as we hit a failure.

Since the `output' of a character may cause several emulops to be called
(e.g. if it causes scrollup or if this is the end of an escape sequence),
all emulation code maintain a so-called `abort state', to be able to properly
recover when the character is tentatively output later, and not reissue
the emulops which did not fail the first time.

With help from mglocker@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.26 2009/09/05 14:30:24 miod Exp $ */
a628 2
		wsemul_resume_abort(&edp->abortstate);

@


1.26
log
@Make the output() wsemul_op return the number of characters processed and
check it in wsdisplaystart() to suspend output if not all characters have
been output; they will get reissued at the next tty rstrt_to timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.25 2009/09/05 13:43:58 miod Exp $ */
d84 1
d110 2
a111 2
void	wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, u_char, int);
void	wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char, int);
d113 2
a114 2
void	wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
void	wsemul_sun_control(struct wsemul_sun_emuldata *, u_char);
d117 1
a117 1
void	wsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);
d141 1
d227 1
a227 1
void
d232 1
d256 5
a260 3
			(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
			    edp->ccol, n,
			    kernel ? edp->kernattr : edp->bkgdattr);
d266 4
a269 2
		(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,
		    edp->bkgdattr);
d292 5
a296 2
		else
			wsemul_sun_scrollup(edp, edp->scrolldist);
d299 2
d303 1
a303 1
void
d306 1
d308 5
a312 2
	(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
	    c, kernel ? edp->kernattr : edp->curattr);
d318 9
a326 2
		else
			wsemul_sun_scrollup(edp, edp->scrolldist);
d329 2
d352 1
a352 1
void
d358 1
d366 5
a370 2
			(*edp->emulops->copycols)(edp->emulcookie, edp->crow,
			    src, dst, edp->ncols - dst);
d372 2
a373 2
		(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
		    src, n, edp->bkgdattr);
d403 5
a407 2
			(*edp->emulops->eraserows)(edp->emulcookie,
			     edp->crow + 1, ROWS_LEFT, edp->bkgdattr);
d411 3
a413 2
		(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
		    edp->ccol, COLS_LEFT + 1, edp->bkgdattr);
d421 4
a424 2
			(*edp->emulops->copyrows)(edp->emulcookie,
			    src, dst, edp->nrows - dst);
d426 2
a427 2
		(*edp->emulops->eraserows)(edp->emulcookie,
		    src, n, edp->bkgdattr);
d435 4
a438 2
			(*edp->emulops->copyrows)(edp->emulcookie,
			    src, dst, edp->nrows - src);
d440 3
a442 2
		(*edp->emulops->eraserows)(edp->emulcookie,
		    dst + edp->nrows - src, n, edp->bkgdattr);
d450 5
a454 2
			(*edp->emulops->copycols)(edp->emulcookie, edp->crow,
			    src, dst, edp->ncols - src);
d456 3
a458 2
		(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
		    edp->ncols - n, n, edp->bkgdattr);
d476 1
a476 1
					return;
d542 2
d546 1
a546 1
void
d549 3
d573 1
a573 1
		edp->nargs++;
d576 7
a582 1
		wsemul_sun_control(edp, c);
d586 2
d599 1
d606 21
a626 2
	/* XXX */
	(*edp->emulops->cursor)(edp->emulcookie, 0, edp->crow, edp->ccol);
d629 2
d632 28
a659 10
		/*
		 * If scrolling is not disabled and we are the bottom of
		 * the screen, count newlines until an escape sequence
		 * appears.
		 */
		if ((edp->state == SUN_EMUL_STATE_NORMAL || kernel) &&
		    ROWS_LEFT == 0 && edp->scrolldist != 0)
			lines = wsemul_sun_jump_scroll(edp, data,
			    count, kernel);
		else
d661 2
d665 8
a672 1
			wsemul_sun_scrollup(edp, lines);
d677 2
d681 3
a683 1
			wsemul_sun_output_lowchars(edp, c, kernel);
d689 3
a691 1
			wsemul_sun_output_normal(edp, c, 1);
d698 1
a698 1
			wsemul_sun_output_normal(edp, c, 0);
d704 1
a704 1
			wsemul_sun_output_control(edp, c);
d712 1
a712 1
			wsemul_sun_output_normal(edp, c, 0);
d716 2
d720 19
a738 2
	/* XXX */
	(*edp->emulops->cursor)(edp->emulcookie, 1, edp->crow, edp->ccol);
d987 2
a988 2
		(*edp->emulops->cursor)(edp->emulcookie, 0,
		    edp->crow, edp->ccol);
d995 1
a995 1
void
d998 2
d1005 5
d1011 1
a1011 3
		(*edp->emulops->eraserows)(edp->emulcookie, 0, 1,
		    edp->bkgdattr);
		return;
d1019 11
a1029 5
	if (lines < edp->nrows)
		(*edp->emulops->copyrows)(edp->emulcookie, lines, 0,
		    edp->nrows - lines);
	(*edp->emulops->eraserows)(edp->emulcookie,
	    edp->nrows - lines, lines, edp->bkgdattr);
d1031 2
@


1.25
log
@Rework internal interfaces in the wsdisplay emulation code to prepare for
upcoming changes. No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.24 2009/05/06 20:00:57 miod Exp $ */
d61 1
a61 1
void	wsemul_sun_output(void *, const u_char *, u_int, int);
d535 1
a535 1
void
d539 1
d576 1
d582 1
d606 1
d610 2
@


1.24
log
@When computing output result for jump scroll purposes, do not count LF
as moving the cursor one charcell right before scrolling.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.23 2007/11/27 16:37:27 miod Exp $ */
d106 1
a106 1
void	wsemul_sun_jump_scroll(struct wsemul_sun_emuldata *, const u_char *,
d111 2
a112 2
u_int	wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, u_char);
u_int	wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
d282 1
a282 1
                /* if the cur line isn't the last, incr and leave. */
d299 1
a299 1
                /* if the cur line isn't the last, incr and leave. */
d308 1
a308 1
u_int
a310 2
	u_int newstate;

d315 1
a315 1
		newstate = SUN_EMUL_STATE_CONTROL;
d322 1
a322 1
		newstate = SUN_EMUL_STATE_NORMAL;	/* XXX is this wise? */
a324 2

	return (newstate);
d502 1
a502 1
u_int
a504 2
	u_int newstate = SUN_EMUL_STATE_CONTROL;

d519 1
a519 1
                break;
d530 1
a530 1
		newstate = SUN_EMUL_STATE_NORMAL;
a532 1
	return (newstate);
d539 4
a542 1
	u_int newstate;
d561 9
a569 1
			wsemul_sun_jump_scroll(edp, data, count, kernel);
d572 3
a574 2
		if (*data < ' ') {
			wsemul_sun_output_lowchars(edp, *data, kernel);
d579 1
a579 1
			wsemul_sun_output_normal(edp, *data, 1);
d583 1
a583 1
		switch (newstate = edp->state) {
d585 1
a585 1
			wsemul_sun_output_normal(edp, *data, 0);
d588 1
a588 1
			newstate = wsemul_sun_output_haveesc(edp, *data);
d591 1
a591 1
			newstate = wsemul_sun_output_control(edp, *data);
d597 3
a599 3
                        /* try to recover, if things get screwed up... */
			newstate = SUN_EMUL_STATE_NORMAL;
			wsemul_sun_output_normal(edp, *data, 0);
d601 1
a601 1
                        break;
a602 1
		edp->state = newstate;
d609 1
a609 1
void
d652 1
a652 4
	if (lines > 1) {
		wsemul_sun_scrollup(edp, lines);
		edp->crow--;
	}
@


1.23
log
@Remove whitespace at EOL, KNF, ansify. Move jump scroll code to a separate
routine. No functional change (har, har)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.22 2007/11/26 16:56:42 miod Exp $ */
d632 2
@


1.22
log
@Constify the output of the emulops translate() function, as well as the
various tables they use.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.21 2007/11/25 19:11:42 miod Exp $ */
d104 13
a116 11
void wsemul_sun_init(struct wsemul_sun_emuldata *,
    const struct wsscreen_descr *, void *, int, int, long);
void wsemul_sun_reset(struct wsemul_sun_emuldata *);
void wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, u_char, int);
void wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char, int);
u_int wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, u_char);
u_int wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
void wsemul_sun_control(struct wsemul_sun_emuldata *, u_char);
int wsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,
    long *, long *);
void wsemul_sun_scrollup(struct wsemul_sun_emuldata *, u_int);
d128 3
a130 6
wsemul_sun_init(edp, type, cookie, ccol, crow, defattr)
	struct wsemul_sun_emuldata *edp;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d143 1
a143 2
wsemul_sun_reset(edp)
	struct wsemul_sun_emuldata *edp;
d154 2
a155 5
wsemul_sun_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d198 2
a199 7
wsemul_sun_attach(console, type, cookie, ccol, crow, cbcookie, defattr)
	int console;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	void *cbcookie;
	long defattr;
d226 2
a227 4
wsemul_sun_output_lowchars(edp, c, kernel)
	struct wsemul_sun_emuldata *edp;
	u_char c;
	int kernel;
d292 1
a292 4
wsemul_sun_output_normal(edp, c, kernel)
	struct wsemul_sun_emuldata *edp;
	u_char c;
	int kernel;
d309 1
a309 3
wsemul_sun_output_haveesc(edp, c)
	struct wsemul_sun_emuldata *edp;
	u_char c;
d332 1
a332 3
wsemul_sun_control(edp, c)
	struct wsemul_sun_emuldata *edp;
	u_char c;
d507 1
a507 3
wsemul_sun_output_control(edp, c)
	struct wsemul_sun_emuldata *edp;
	u_char c;
d543 1
a543 5
wsemul_sun_output(cookie, data, count, kernel)
	void *cookie;
	const u_char *data;
	u_int count;
	int kernel;
a546 5
#ifdef JUMP_SCROLL
	const u_char *eot;
	u_char curchar;
	u_int cnt, pos, lines;
#endif
d564 2
a565 40
		    ROWS_LEFT == 0 && edp->scrolldist != 0) {
			lines = 0;
			pos = edp->ccol;
			for (eot = data, cnt = count; cnt != 0; eot++, cnt--) {
				curchar = *eot;
				if (curchar == ASCII_FF ||
				    curchar == ASCII_VT || curchar == ASCII_ESC)
					break;

				switch (curchar) {
				case ASCII_BS:
					if (pos > 0)
						pos--;
					break;
				case ASCII_CR:
					pos = 0;
					break;
				case ASCII_HT:
					pos = (pos + 7) & ~7;
					if (pos >= edp->ncols)
						pos = edp->ncols - 1;
					break;
				default:
					if (++pos >= edp->ncols) {
						pos = 0;
						curchar = ASCII_LF;
					}
					break;
				}
				if (curchar == ASCII_LF) {
					if (++lines >= edp->nrows - 1)
						break;
				}
			}

			if (lines > 1) {
				wsemul_sun_scrollup(edp, lines);
				edp->crow--;
			}
		}
d604 48
d658 2
a659 4
wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)
	struct wsemul_sun_emuldata *edp;
	int flags, fgcol, bgcol;
	long *attr, *bkgdattr;
d750 1
a750 4
wsemul_sun_translate(cookie, in, out)
	void *cookie;
	keysym_t in;
	const char **out;
d823 1
a823 3
wsemul_sun_detach(cookie, crowp, ccolp)
	void *cookie;
	u_int *crowp, *ccolp;
d834 1
a834 3
wsemul_sun_resetop(cookie, op)
	void *cookie;
	enum wsemul_resetops op;
d858 1
a858 3
wsemul_sun_scrollup(edp, lines)
	struct wsemul_sun_emuldata *edp;
	u_int lines;
@


1.21
log
@Ask the emulation code to hide the cursor when leaving emulation mode. This
way we do not get a phantom cursor image when X exits.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.20 2007/02/14 01:12:16 jsg Exp $ */
d62 1
a62 1
int	wsemul_sun_translate(void *, keysym_t, char **);
d741 1
a741 1
static char *sun_fkeys[] = {
d756 1
a756 1
static char *sun_lkeys[] = {
d775 1
a775 1
	char **out;
@


1.20
log
@FALLTHRU -> FALLTHROUGH for consistency.
Suggested by miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.19 2007/01/07 13:28:50 miod Exp $ */
d876 4
@


1.19
log
@Change allocations to M_NOWAIT in attach methods, and return NULL if they fail.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.18 2006/12/02 11:25:09 miod Exp $ */
d376 1
a376 1
		/* FALLTHRU */
d400 1
a400 1
		/* FALLTHRU */
@


1.18
log
@Fix ri_devcmap[] to allow WSCOL_BLACK and WSCOL_WHITE to not have to be
different for sparc{,64} systems.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.17 2006/08/17 06:27:04 miod Exp $ */
d219 3
a221 1
		edp = malloc(sizeof *edp, M_DEVBUF, M_WAITOK);
@


1.17
log
@Jump scroll support for vt100 and sun wscons emulations, helps macppc and
zaurus a lot, tested by many; ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.16 2006/07/01 16:16:53 miod Exp $ */
d474 2
a475 5
			case 30:
				fgcol = WSCOL_BLACK;
				break;
			case 31: case 32: case 33:
			case 34: case 35: case 36:
a477 3
			case 37:
				fgcol = WSCOL_WHITE;
				break;
d479 2
a480 5
			case 40:
				bgcol = WSCOL_BLACK;
				break;
			case 41: case 42: case 43:
			case 44: case 45: case 46:
a481 3
				break;
			case 47:
				bgcol = WSCOL_WHITE;
@


1.16
log
@Make sure the color selection escape sequences use black for 0 and white for 7,
as on vt220.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.15 2006/06/30 21:38:19 miod Exp $ */
d41 3
a43 1
#include <sys/cdefs.h>
d114 1
a114 1
void wsemul_sun_scrollup(struct wsemul_sun_emuldata *);
d296 1
a296 1
			wsemul_sun_scrollup(edp);
d316 1
a316 1
			wsemul_sun_scrollup(edp);
d582 5
d595 1
d597 49
d893 1
a893 1
wsemul_sun_scrollup(edp)
d895 1
d901 1
a901 1
	if (edp->scrolldist == 0) {
d913 3
a915 3
	if (edp->scrolldist < edp->nrows)
		(*edp->emulops->copyrows)(edp->emulcookie, edp->scrolldist, 0,
		    edp->nrows - edp->scrolldist);
d917 2
a918 2
	    edp->nrows - edp->scrolldist, edp->scrolldist, edp->bkgdattr);
	edp->crow -= edp->scrolldist - 1;
@


1.15
log
@For 32bit sun frame buffers, tweak ri_devcmap to get the BoW palette instead
of needing different WSCOL_{BLACK,WHITE} values than 8bit frame buffers.

This allows us to not special case the alloc_attr() invocations depending
on the color depth, and to make WSCOL_{BLACK,WHITE} constants again in the
wsemul_sun land.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.14 2006/06/29 17:54:32 miod Exp $ */
d472 5
a476 2
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
d479 3
d483 5
a487 2
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
d489 3
@


1.14
log
@No need to keep specific variables for the kernel messages colors on sun
emulation, we can reuse the existing WSCOL_xxx codes, and WSCOL_BLACK and
WSCOL_WHITE will point to variables anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.13 2005/03/09 17:48:41 miod Exp $ */
a121 8

/*
 * wscons color codes
 * To compensate for Sun color choices on older framebuffers, these need to
 * be variables.
 */
int	wscol_white = 0;	/* 0 */
int	wscol_black = 7;	/* 255 */
@


1.13
log
@Make the sun emulation match what the old SunOS cons(4) manual page describes:
- Fix an uninitialized variable for ESC[p and ESC[q control sequences.
- Skip invoxing wscons accessops when we know they'll have nothing to do
  (e.g. scroll 0 lines, erase 0 lines, etc)
- Correctly handle spurious parameters in control sequences - the ones to
  take into account are the _last_ received, not the _first_. Which makes
  things pretty funny for control sequences requiring more than one parameter,
  since it is not mandatory to provide all parameters.

ok todd@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.12 2004/02/24 22:07:58 miod Exp $ */
a129 2
int	wskernel_bg = 7;	/* 0 */
int	wskernel_fg = 0;	/* 255 */
d175 1
a175 1
#define WS_KERNEL_FG wskernel_bg
d178 1
a178 1
#define WS_KERNEL_BG wskernel_fg
@


1.12
log
@Do not check for end of line too early, as this will confuse the cursor
position. Easily reproduceable using emacs, but no fully sane human being
would use emacs anyway.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.11 2002/09/23 18:10:09 miod Exp $ */
d117 3
a119 2
#define	ARG(n)			(edp->args[(n)])
#define	NORMALIZE_ARG(n)	(ARG(n) ? ARG(n) : 1)
d270 6
a275 4
		(*edp->emulops->erasecols)(edp->emulcookie, edp->crow,
				edp->ccol, n,
				kernel ? edp->kernattr : edp->bkgdattr);
		edp->ccol += n;
d365 1
a365 1
		n = min(NORMALIZE_ARG(0), COLS_LEFT + 1);
d377 1
a377 1
		edp->crow -= min(NORMALIZE_ARG(0), edp->crow);
d384 1
a384 1
		edp->crow += min(NORMALIZE_ARG(0), ROWS_LEFT);
d388 1
a388 1
		edp->ccol += min(NORMALIZE_ARG(0), COLS_LEFT);
d392 1
a392 1
		edp->ccol -= min(NORMALIZE_ARG(0), edp->ccol);
d397 2
a398 2
		edp->crow = min(NORMALIZE_ARG(0), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE_ARG(1), edp->ncols) - 1;
d413 1
a413 1
		n = min(NORMALIZE_ARG(0), ROWS_LEFT + 1);
d425 1
a425 1
		n = min(NORMALIZE_ARG(0), ROWS_LEFT + 1);
d437 1
a437 1
		n = min(NORMALIZE_ARG(0), COLS_LEFT + 1);
d454 1
a454 1
			switch (ARG(n)) {
d484 1
a484 1
				fgcol = ARG(n) - 30;
d489 1
a489 1
				bgcol = ARG(n) - 40;
d510 1
d516 1
d522 1
a522 1
		edp->scrolldist = min(ARG(0), edp->nrows);
d541 9
a549 2
		if (edp->nargs > SUN_EMUL_NARGS - 1)
			break;
d848 8
a855 3
	/* scroll by the scrolling distance. */
	(*edp->emulops->copyrows)(edp->emulcookie, edp->scrolldist, 0,
	    edp->nrows - edp->scrolldist);
@


1.11
log
@Fix the extra cursor image remaining in the upper left corner of the
screen after it has been cleared.

ok fgs@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.10 2002/09/15 12:54:49 fgsch Exp $ */
a91 3
	int flags;			/* current processing flags */
#define	SUNFL_LASTCHAR	0x0001		/* printed last char on line */

d119 2
a120 2
#define	COLS_LEFT		(edp->ncols - edp->ccol - 1)
#define	ROWS_LEFT		(edp->nrows - edp->crow - 1)
a154 1
	edp->flags = 0;
d259 1
a259 1
		if (edp->ccol > 0) {
a260 2
			CLR(edp->flags, SUNFL_LASTCHAR);
		}
a264 1
		CLR(edp->flags, SUNFL_LASTCHAR);
a272 2
		if (COLS_LEFT == 0)
			SET(edp->flags, SUNFL_LASTCHAR);
a278 1
		CLR(edp->flags, SUNFL_LASTCHAR);
d312 5
a316 1
	if (ISSET(edp->flags, SUNFL_LASTCHAR)) {
a322 1
		CLR(edp->flags, SUNFL_LASTCHAR);
a323 8

	(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
	    c, kernel ? edp->kernattr : edp->curattr);

	if (COLS_LEFT)
		edp->ccol++;
	else
		SET(edp->flags, SUNFL_LASTCHAR);
d418 1
a418 1
		    src, dst - src, edp->bkgdattr);
d430 1
a430 1
		    dst + edp->nrows - src, src - dst, edp->bkgdattr);
a523 5

	if (COLS_LEFT)
		CLR(edp->flags, SUNFL_LASTCHAR);
	else
		SET(edp->flags, SUNFL_LASTCHAR);
a813 1
		CLR(edp->flags, SUNFL_LASTCHAR);
@


1.10
log
@Add missing translations for End, Ins and f11-f12, indent the switch a bit
as well; miod@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.8 2002/09/05 17:12:03 jason Exp $ */
d285 4
a288 1
		wsemul_sun_resetop(edp, WSEMUL_CLEARSCREEN);
d832 1
a832 1
					   edp->bkgdattr);
@


1.9
log
@Rework the wsemul_sun behaviour, and add color support, from the current
wsemul_vt100 code and NetBSD's rcons. Misc cleaning in the process.
Use with TERM=rcons-color for color support for now.

Tested by jason@@ and matthieu@@
@
text
@d707 3
a709 1
	"\033[233z",	/* F10 */
d741 1
a741 1
	if (in >= KS_f1 && in <= KS_f10) {
d745 1
a745 1
	if (in >= KS_F1 && in <= KS_F10) {
d759 3
a761 3
	    case KS_Home:
	    case KS_KP_Home:
	    case KS_KP_Begin:
d764 10
a773 2
	    case KS_Prior:
	    case KS_KP_Prior:
d776 2
a777 2
	    case KS_Next:
	    case KS_KP_Next:
d780 2
a781 2
	    case KS_Up:
	    case KS_KP_Up:
d784 2
a785 2
	    case KS_Down:
	    case KS_KP_Down:
d788 2
a789 2
	    case KS_Left:
	    case KS_KP_Left:
d792 2
a793 2
	    case KS_Right:
	    case KS_KP_Right:
d796 1
a796 1
	    case KS_KP_Delete:
@


1.8
log
@Do not print the ASCII_ESC character.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.7 2002/08/29 22:19:33 miod Exp $ */
d34 6
a39 1
/* XXX DESCRIPTION/SOURCE OF INFORMATION */
d56 6
a61 7
				  int, int, long);
void	*wsemul_sun_attach(int console, const struct wsscreen_descr *,
				void *, int, int, void *, long);
void	wsemul_sun_output(void *cookie, const u_char *data, u_int count,
			       int);
int	wsemul_sun_translate(void *cookie, keysym_t, char **);
void	wsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp);
d86 1
d90 5
d96 1
a96 6
	long defattr;			/* default attribute (rendition) */
	long bowattr;			/* attribute for reversed mode */
	int rendflags;
#define REND_BOW 1
#define REND_SO 2
	long curattr;			/* currently used attribute */
d98 2
d105 5
a109 2
u_int wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char,
				    int);
d113 3
d135 3
a137 2
void *
wsemul_sun_cnattach(type, cookie, ccol, crow, defattr)
a142 5
	struct wsemul_sun_emuldata *edp;
	int res;

	edp = &wsemul_sun_console_emuldata;

d150 28
a177 1
	edp->curattr = edp->defattr = defattr;
a204 2
	edp->state = SUN_EMUL_STATE_NORMAL;
	edp->scrolldist = 1;
d208 2
d231 1
a232 11
		edp->emulops = type->textops;
		edp->emulcookie = cookie;
		edp->scrcapabilities = type->capabilities;
		edp->nrows = type->nrows;
		edp->ncols = type->ncols;
		edp->crow = crow;
		edp->ccol = ccol;
		edp->defattr = defattr;

		edp->state = SUN_EMUL_STATE_NORMAL;
		edp->scrolldist = 1;
d240 1
a240 15
	/* XXX This assumes that the default attribute is wob. */
	if ((!(edp->scrcapabilities & WSSCREEN_WSCOLORS) ||
		(*edp->emulops->alloc_attr)(edp->emulcookie,
					    WSCOL_WHITE, WSCOL_BLACK,
					    WSATTR_WSCOLORS,
					    &edp->bowattr)) &&
	    (!(edp->scrcapabilities & WSSCREEN_REVERSE) ||
		(*edp->emulops->alloc_attr)(edp->emulcookie, 0, 0,
					    WSATTR_REVERSE,
					    &edp->bowattr)))
		edp->bowattr = edp->defattr;

	edp->curattr = edp->defattr;
	edp->rendflags = 0;

d244 2
a245 2
inline u_int
wsemul_sun_output_normal(edp, c, kernel)
a249 1
	u_int newstate = SUN_EMUL_STATE_NORMAL;
d253 5
d263 1
a263 1
		if (edp->ccol > 0)
d265 2
d271 1
d278 1
a278 1
				kernel ? edp->kernattr : edp->curattr);
d280 2
d285 1
a285 5
		(*edp->emulops->eraserows)(edp->emulcookie, 0, edp->nrows,
				kernel ? edp->kernattr : edp->curattr);
				/* XXX possible in kernel output? */
		edp->ccol = 0;
		edp->crow = 0;
d295 1
a295 1
			printf("wsemul_sun_output_normal: ESC in kernel "
d300 1
a300 2
		if (edp->state == SUN_EMUL_STATE_NORMAL)
			newstate = SUN_EMUL_STATE_HAVEESC;
a302 14
	default:		/* normal character */
		(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
		    c, kernel ? edp->kernattr : edp->curattr);
		edp->ccol++;

		/* if cur col is still on cur line, done. */
		if (edp->ccol < edp->ncols)
			break;

		/* wrap the column around. */
		edp->ccol = 0;

               	/* FALLTHRU */

d305 1
a305 1
		if (edp->crow < edp->nrows - 1) {
d307 5
a311 2
			break;
		}
d313 15
a327 10
		/*
		 * if we're in wrap-around mode, go to the first
		 * line and clear it.
		 */
		if (edp->scrolldist == 0) {
			edp->crow = 0;
			(*edp->emulops->eraserows)(edp->emulcookie, 0, 1,
						   edp->curattr);
			break;
		}
d329 2
a330 9
		/* scroll by the scrolling distance. */
		(*edp->emulops->copyrows)(edp->emulcookie, edp->scrolldist, 0,
		    edp->nrows - edp->scrolldist);
		(*edp->emulops->eraserows)(edp->emulcookie,
		    edp->nrows - edp->scrolldist, edp->scrolldist,
					   edp->curattr);
		edp->crow -= edp->scrolldist - 1;
		break;
	}
d332 4
a335 1
	return (newstate);
d338 1
a338 1
inline u_int
d347 1
d353 4
a356 3
		/* spit out the escape char (???), then the new character */
		wsemul_sun_output_normal(edp, ASCII_ESC, 0);	/* ??? */
		newstate = wsemul_sun_output_normal(edp, c, 0);
d363 1
a363 1
inline void
d369 2
d382 1
a382 1
		    src, n, edp->curattr);
d406 2
a407 2
		edp->crow = min(NORMALIZE_ARG(1), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE_ARG(0), edp->ncols) - 1;
d413 1
a413 1
			     edp->crow + 1, ROWS_LEFT, edp->curattr);
d418 1
a418 1
		    edp->ccol, COLS_LEFT + 1, edp->curattr);
d430 1
a430 1
		    src, dst - src, edp->curattr);
d442 1
a442 1
		    dst + edp->nrows - src, src - dst, edp->curattr);
d454 1
a454 1
		    edp->ncols - n, n, edp->curattr);
d458 59
a516 5
		if (ARG(0))
			edp->rendflags |= REND_SO;
		else
			edp->rendflags &= ~REND_SO;
		goto setattr;
d519 2
a520 1
		edp->rendflags |= REND_BOW;
d524 2
a525 1
		edp->rendflags &= ~REND_BOW;
d533 1
a533 8
		edp->scrolldist = 1;
		edp->rendflags = 0;
setattr:
		if (((edp->rendflags & REND_BOW) != 0) ^
		    ((edp->rendflags & REND_SO) != 0))
			edp->curattr = edp->bowattr;
		else
			edp->curattr = edp->defattr;
d536 5
d543 1
a543 1
inline u_int
a548 1
	u_int i;
d553 4
a556 1
		edp->args[0] = (edp->args[0] * 10) + (c - '0');
d560 1
a560 3
		for (i = 1; i < SUN_EMUL_NARGS; i++)
			edp->args[i] = edp->args[i - 1];
		edp->args[0] = 0;
d564 3
d592 5
d601 2
a602 1
		switch (edp->state) {
d604 1
a604 2
			/* XXX SCAN INPUT FOR NEWLINES, DO PRESCROLLING */
			newstate = wsemul_sun_output_normal(edp, *data, 0);
d614 5
a618 1
			panic("wsemul_sun: invalid state %d\n", edp->state);
a619 2
                        /* try to recover, if things get screwed up... */
			newstate = wsemul_sun_output_normal(edp, *data, 0);
d628 69
d815 1
a815 4
		edp->state = SUN_EMUL_STATE_NORMAL;
		edp->scrolldist = 1;
		edp->rendflags = 0;
		edp->curattr = edp->defattr;
d819 1
a819 1
					   edp->defattr);
d821 1
d827 23
@


1.7
log
@Produce the same escape codes as SunOS with the L function keys in console.
(tested against Solaris 2.5)
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.6 2002/07/25 19:03:25 miod Exp $ */
d283 1
a283 1
		if (edp->state == SUN_EMUL_STATE_NORMAL) {
d285 1
a285 4
			break;
		}
		/* special case: fall through, we're printing one out */
		/* FALLTHRU */
@


1.6
log
@Rework the color usage in wsemul_sun displays, to match SunOS and Solaris
text mode colors.
This means black text on white background, even for the kernel messages.

Initially based on a patch from jason@@, then some tinkering by me.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.5 2002/05/30 18:25:44 fgsch Exp $ */
d570 15
d609 4
@


1.5
log
@remove silly ifdef's; mickey@@ jason@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.4 2002/03/14 01:27:03 millert Exp $ */
d112 10
d144 1
a144 1
#define WS_KERNEL_FG WSCOL_WHITE
d147 1
a147 1
#define WS_KERNEL_BG WSCOL_BLACK
d217 1
a217 1
					    WSCOL_BLACK, WSCOL_WHITE,
d375 1
a375 1
		    src, dst - src, edp->curattr);
d447 1
a447 1
		    dst + edp->ncols - src, src - dst, edp->curattr);
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.3 2001/04/14 04:48:00 aaron Exp $ */
d132 1
a132 2
#if defined(WS_KERNEL_FG) || defined(WS_KERNEL_BG) || \
  defined(WS_KERNEL_COLATTR) || defined(WS_KERNEL_MONOATTR)
d155 1
a155 4
#else
	res = 0; /* XXX gcc */
#endif
	edp->kernattr = defattr;
@


1.3
log
@Remove some static.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.2 2001/03/07 17:51:29 aaron Exp $ */
d50 9
a58 9
void	*wsemul_sun_cnattach __P((const struct wsscreen_descr *, void *,
				  int, int, long));
void	*wsemul_sun_attach __P((int console, const struct wsscreen_descr *,
				void *, int, int, void *, long));
void	wsemul_sun_output __P((void *cookie, const u_char *data, u_int count,
			       int));
int	wsemul_sun_translate __P((void *cookie, keysym_t, char **));
void	wsemul_sun_detach __P((void *cookie, u_int *crowp, u_int *ccolp));
void	wsemul_sun_resetop __P((void *, enum wsemul_resetops));
d98 5
a102 5
u_int wsemul_sun_output_normal __P((struct wsemul_sun_emuldata *, u_char,
				    int));
u_int wsemul_sun_output_haveesc __P((struct wsemul_sun_emuldata *, u_char));
u_int wsemul_sun_output_control __P((struct wsemul_sun_emuldata *, u_char));
void wsemul_sun_control __P((struct wsemul_sun_emuldata *, u_char));
@


1.3.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.3 2001/04/14 04:48:00 aaron Exp $ */
d50 9
a58 9
void	*wsemul_sun_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_sun_attach(int console, const struct wsscreen_descr *,
				void *, int, int, void *, long);
void	wsemul_sun_output(void *cookie, const u_char *data, u_int count,
			       int);
int	wsemul_sun_translate(void *cookie, keysym_t, char **);
void	wsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_sun_resetop(void *, enum wsemul_resetops);
d98 5
a102 5
u_int wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char,
				    int);
u_int wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, u_char);
u_int wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
void wsemul_sun_control(struct wsemul_sun_emuldata *, u_char);
d132 2
a133 1

d156 4
a159 1
		edp->kernattr = defattr;
@


1.3.8.2
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.3.8.1 2002/06/11 03:42:32 art Exp $ */
d34 1
a34 6
/*
 * This file implements a sun terminal personality for wscons.
 *
 * Derived from old rcons code.
 * Color support from NetBSD's rcons color code, and wsemul_vt100.
 */
d51 7
a57 6
    int, int, long);
void	*wsemul_sun_attach(int, const struct wsscreen_descr *,
    void *, int, int, void *, long);
void	wsemul_sun_output(void *, const u_char *, u_int, int);
int	wsemul_sun_translate(void *, keysym_t, char **);
void	wsemul_sun_detach(void *, u_int *, u_int *);
a81 1
	long defattr;			/* default attribute (rendition) */
a84 5
	int nargs;			/* number of args */

	int flags;			/* current processing flags */
#define	SUNFL_LASTCHAR	0x0001		/* printed last char on line */

d86 6
a91 1
	long curattr, bkgdattr;		/* currently used attribute */
a92 2
	int attrflags, fgcol, bgcol;	/* properties of curattr */

d98 2
a99 5
void wsemul_sun_init(struct wsemul_sun_emuldata *,
    const struct wsscreen_descr *, void *, int, int, long);
void wsemul_sun_reset(struct wsemul_sun_emuldata *);
void wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, u_char, int);
void wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char, int);
a102 3
int wsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,
    long *, long *);
void wsemul_sun_scrollup(struct wsemul_sun_emuldata *);
d112 2
a113 13
/*
 * wscons color codes
 * To compensate for Sun color choices on older framebuffers, these need to
 * be variables.
 */
int	wscol_white = 0;	/* 0 */
int	wscol_black = 7;	/* 255 */
int	wskernel_bg = 7;	/* 0 */
int	wskernel_fg = 0;	/* 255 */

void
wsemul_sun_init(edp, type, cookie, ccol, crow, defattr)
	struct wsemul_sun_emuldata *edp;
d119 5
d131 1
a131 28
	edp->defattr = defattr;
}

void
wsemul_sun_reset(edp)
	struct wsemul_sun_emuldata *edp;
{
	edp->state = SUN_EMUL_STATE_NORMAL;
	edp->flags = 0;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_BLACK;
	edp->bgcol = WSCOL_WHITE;
	edp->scrolldist = 1;
}

void *
wsemul_sun_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
{
	struct wsemul_sun_emuldata *edp;
	int res;

	edp = &wsemul_sun_console_emuldata;
	wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);
d134 1
a134 1
#define WS_KERNEL_FG wskernel_bg
d137 1
a137 1
#define WS_KERNEL_BG wskernel_fg
d159 2
a163 2

	wsemul_sun_reset(edp);
a184 1
		wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);
d186 11
d204 15
a218 1
	wsemul_sun_reset(edp);
d222 2
a223 2
void
wsemul_sun_output_lowchars(edp, c, kernel)
d228 1
a231 5
	case ASCII_NUL:
	default:
		/* ignore */
		break;

d237 1
a237 1
		if (edp->ccol > 0) {
a238 2
			CLR(edp->flags, SUNFL_LASTCHAR);
		}
a242 1
		CLR(edp->flags, SUNFL_LASTCHAR);
d249 1
a249 1
				kernel ? edp->kernattr : edp->bkgdattr);
a250 2
		if (COLS_LEFT == 0)
			SET(edp->flags, SUNFL_LASTCHAR);
d255 4
a258 3
		    edp->bkgdattr);
		edp->ccol = edp->crow = 0;
		CLR(edp->flags, SUNFL_LASTCHAR);
d268 1
a268 1
			printf("wsemul_sun_output_lowchars: ESC in kernel "
d273 20
a292 2
		edp->state = SUN_EMUL_STATE_HAVEESC;
		break;
d296 1
a296 1
		if (ROWS_LEFT > 0)
d298 21
a318 2
		else
			wsemul_sun_scrollup(edp);
a320 1
}
d322 1
a322 23
void
wsemul_sun_output_normal(edp, c, kernel)
	struct wsemul_sun_emuldata *edp;
	u_char c;
	int kernel;
{
	if (ISSET(edp->flags, SUNFL_LASTCHAR)) {
                /* if the cur line isn't the last, incr and leave. */
		if (ROWS_LEFT > 0)
			edp->crow++;
		else
			wsemul_sun_scrollup(edp);
		edp->ccol = 0;
		CLR(edp->flags, SUNFL_LASTCHAR);
	}

	(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
	    c, kernel ? edp->kernattr : edp->curattr);

	if (COLS_LEFT)
		edp->ccol++;
	else
		SET(edp->flags, SUNFL_LASTCHAR);
d325 1
a325 1
u_int
a333 1
		edp->nargs = 0;
d339 3
a341 4
#ifdef DEBUG
		printf("ESC%c unknown\n", c);
#endif
		newstate = SUN_EMUL_STATE_NORMAL;	/* XXX is this wise? */
d348 1
a348 1
void
a353 2
	int flags, fgcol, bgcol;
	long attr, bkgdattr;
d365 1
a365 1
		    src, n, edp->bkgdattr);
d389 2
a390 2
		edp->crow = min(NORMALIZE_ARG(0), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE_ARG(1), edp->ncols) - 1;
d396 1
a396 1
			     edp->crow + 1, ROWS_LEFT, edp->bkgdattr);
d401 1
a401 1
		    edp->ccol, COLS_LEFT + 1, edp->bkgdattr);
d413 1
a413 1
		    src, dst - src, edp->bkgdattr);
d425 1
a425 1
		    dst + edp->nrows - src, src - dst, edp->bkgdattr);
d437 1
a437 1
		    edp->ncols - n, n, edp->bkgdattr);
d441 5
a445 59
		flags = edp->attrflags;
		fgcol = edp->fgcol;
		bgcol = edp->bgcol;

		for (n = 0; n < edp->nargs; n++) {
			switch (ARG(n)) {
			/* Clear all attributes || End underline */
			case 0:
				if (n == edp->nargs - 1) {
					edp->bkgdattr =
					    edp->curattr = edp->defattr;
					edp->attrflags = 0;
					edp->fgcol = WSCOL_BLACK;
					edp->bgcol = WSCOL_WHITE;
					return;
				}
				flags = 0;
				fgcol = WSCOL_BLACK;
				bgcol = WSCOL_WHITE;
				break;
			/* Begin bold */
			case 1:
				flags |= WSATTR_HILIT;
				break;
			/* Begin underline */
			case 4:
				flags |= WSATTR_UNDERLINE;
				break;
			/* Begin reverse */
			case 7:
				flags |= WSATTR_REVERSE;
				break;
			/* ANSI foreground color */
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
				fgcol = ARG(n) - 30;
				break;
			/* ANSI background color */
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
				bgcol = ARG(n) - 40;
				break;
			}
		}
setattr:
		if (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr,
		    &bkgdattr)) {
#ifdef DEBUG
			printf("error allocating attr %d/%d/%x\n",
			    fgcol, bgcol, flags);
#endif
		} else {
			edp->curattr = attr;
			edp->bkgdattr = bkgdattr;
			edp->attrflags = flags;
			edp->fgcol = fgcol;
			edp->bgcol = bgcol;
		}
		break;
d448 1
a448 2
		fgcol = WSCOL_BLACK;
		bgcol = WSCOL_WHITE;
d452 1
a452 2
		fgcol = WSCOL_WHITE;
		bgcol = WSCOL_BLACK;
d460 8
a467 1
		wsemul_sun_reset(edp);
a469 5

	if (COLS_LEFT)
		CLR(edp->flags, SUNFL_LASTCHAR);
	else
		SET(edp->flags, SUNFL_LASTCHAR);
d472 1
a472 1
u_int
d478 1
d483 1
a483 4
		if (edp->nargs > SUN_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (c - '0');
d487 3
a489 1
		edp->nargs++;
a492 3
		edp->nargs++;
		if (edp->nargs > SUN_EMUL_NARGS)
			edp->nargs = SUN_EMUL_NARGS;
a517 5
		if (*data < ' ') {
			wsemul_sun_output_lowchars(edp, *data, kernel);
			continue;
		}

d522 1
a522 2

		switch (newstate = edp->state) {
d524 2
a525 1
			wsemul_sun_output_normal(edp, *data, 0);
d535 2
a536 2
			panic("wsemul_sun: invalid state %d", edp->state);
#else
d538 1
a538 3
			newstate = SUN_EMUL_STATE_NORMAL;
			wsemul_sun_output_normal(edp, *data, 0);
#endif
a546 69

/*
 * Get an attribute from the graphics driver.
 * Try to find replacements if the desired appearance is not supported.
 */
int
wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)
	struct wsemul_sun_emuldata *edp;
	int flags, fgcol, bgcol;
	long *attr, *bkgdattr;
{
	int error;

	/*
	 * Rasops will force white on black as normal output colors, unless
	 * WSATTR_WSCOLORS is specified. Since Sun console is black on white,
	 * always use WSATTR_WSCOLORS and our colors, as we know better.
	 */
	if (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {
		flags &= ~WSATTR_WSCOLORS;
	} else {
		flags |= WSATTR_WSCOLORS;
	}

	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags & WSATTR_WSCOLORS, bkgdattr);
	if (error)
		return (error);

	if ((flags & WSATTR_HILIT) &&
	    !(edp->scrcapabilities & WSSCREEN_HILIT)) {
		flags &= ~WSATTR_HILIT;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_RED;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_UNDERLINE) &&
	    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {
		flags &= ~WSATTR_UNDERLINE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_CYAN;
			flags &= ~WSATTR_UNDERLINE;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_BLINK) &&
	    !(edp->scrcapabilities & WSSCREEN_BLINK)) {
		flags &= ~WSATTR_BLINK;
	}
	if ((flags & WSATTR_REVERSE) &&
	    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {
		flags &= ~WSATTR_REVERSE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			int help;
			help = bgcol;
			bgcol = fgcol;
			fgcol = help;
			flags |= WSATTR_WSCOLORS;
		}
	}
	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags, attr);
	if (error)
		return (error);

	return (0);
}

d557 1
a557 18
	"\033[233z",
	"\033[234z",
	"\033[235z",	/* F12 */
};

static char *sun_lkeys[] = {
	"\033[207z",	/* KS_Help */
	NULL,		/* KS_Execute */
	"\033[200z",	/* KS_Find */
	NULL,		/* KS_Select */
	"\033[193z",	/* KS_Again */
	"\033[194z",	/* KS_Props */
	"\033[195z",	/* KS_Undo */
	"\033[196z",	/* KS_Front */
	"\033[197z",	/* KS_Copy */
	"\033[198z",	/* KS_Open */
	"\033[199z",	/* KS_Paste */
	"\033[201z",	/* KS_Cut */
d574 1
a574 1
	if (in >= KS_f1 && in <= KS_f12) {
d578 1
a578 1
	if (in >= KS_F1 && in <= KS_F12) {
a585 4
	if (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {
		*out = sun_lkeys[in - KS_Help];
		return (6);
	}
d588 3
a590 3
	case KS_Home:
	case KS_KP_Home:
	case KS_KP_Begin:
d593 2
a594 10
	case KS_End:
	case KS_KP_End:
		*out = "\033[220z";
		return (6);
	case KS_Insert:
	case KS_KP_Insert:
		*out = "\033[247z";
		return (6);
	case KS_Prior:
	case KS_KP_Prior:
d597 2
a598 2
	case KS_Next:
	case KS_KP_Next:
d601 2
a602 2
	case KS_Up:
	case KS_KP_Up:
d605 2
a606 2
	case KS_Down:
	case KS_KP_Down:
d609 2
a610 2
	case KS_Left:
	case KS_KP_Left:
d613 2
a614 2
	case KS_Right:
	case KS_KP_Right:
d617 1
a617 1
	case KS_KP_Delete:
d646 4
a649 1
		wsemul_sun_reset(edp);
d653 1
a653 1
		    edp->bkgdattr);
a654 1
		CLR(edp->flags, SUNFL_LASTCHAR);
a659 23
}

void
wsemul_sun_scrollup(edp)
	struct wsemul_sun_emuldata *edp;
{
	/*
	 * if we're in wrap-around mode, go to the first
	 * line and clear it.
	 */
	if (edp->scrolldist == 0) {
		edp->crow = 0;
		(*edp->emulops->eraserows)(edp->emulcookie, 0, 1,
		    edp->bkgdattr);
		return;
	}

	/* scroll by the scrolling distance. */
	(*edp->emulops->copyrows)(edp->emulcookie, edp->scrolldist, 0,
	    edp->nrows - edp->scrolldist);
	(*edp->emulops->eraserows)(edp->emulcookie,
	    edp->nrows - edp->scrolldist, edp->scrolldist, edp->bkgdattr);
	edp->crow -= edp->scrolldist - 1;
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.3 2001/04/14 04:48:00 aaron Exp $ */
@


1.3.4.2
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d50 9
a58 9
void	*wsemul_sun_cnattach(const struct wsscreen_descr *, void *,
				  int, int, long);
void	*wsemul_sun_attach(int console, const struct wsscreen_descr *,
				void *, int, int, void *, long);
void	wsemul_sun_output(void *cookie, const u_char *data, u_int count,
			       int);
int	wsemul_sun_translate(void *cookie, keysym_t, char **);
void	wsemul_sun_detach(void *cookie, u_int *crowp, u_int *ccolp);
void	wsemul_sun_resetop(void *, enum wsemul_resetops);
d98 5
a102 5
u_int wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char,
				    int);
u_int wsemul_sun_output_haveesc(struct wsemul_sun_emuldata *, u_char);
u_int wsemul_sun_output_control(struct wsemul_sun_emuldata *, u_char);
void wsemul_sun_control(struct wsemul_sun_emuldata *, u_char);
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@d34 1
a34 6
/*
 * This file implements a sun terminal personality for wscons.
 *
 * Derived from old rcons code.
 * Color support from NetBSD's rcons color code, and wsemul_vt100.
 */
d51 7
a57 6
    int, int, long);
void	*wsemul_sun_attach(int, const struct wsscreen_descr *,
    void *, int, int, void *, long);
void	wsemul_sun_output(void *, const u_char *, u_int, int);
int	wsemul_sun_translate(void *, keysym_t, char **);
void	wsemul_sun_detach(void *, u_int *, u_int *);
a81 1
	long defattr;			/* default attribute (rendition) */
a84 5
	int nargs;			/* number of args */

	int flags;			/* current processing flags */
#define	SUNFL_LASTCHAR	0x0001		/* printed last char on line */

d86 6
a91 1
	long curattr, bkgdattr;		/* currently used attribute */
a92 2
	int attrflags, fgcol, bgcol;	/* properties of curattr */

d98 2
a99 5
void wsemul_sun_init(struct wsemul_sun_emuldata *,
    const struct wsscreen_descr *, void *, int, int, long);
void wsemul_sun_reset(struct wsemul_sun_emuldata *);
void wsemul_sun_output_lowchars(struct wsemul_sun_emuldata *, u_char, int);
void wsemul_sun_output_normal(struct wsemul_sun_emuldata *, u_char, int);
a102 3
int wsemul_sun_selectattribute(struct wsemul_sun_emuldata *, int, int, int,
    long *, long *);
void wsemul_sun_scrollup(struct wsemul_sun_emuldata *);
d112 2
a113 13
/*
 * wscons color codes
 * To compensate for Sun color choices on older framebuffers, these need to
 * be variables.
 */
int	wscol_white = 0;	/* 0 */
int	wscol_black = 7;	/* 255 */
int	wskernel_bg = 7;	/* 0 */
int	wskernel_fg = 0;	/* 255 */

void
wsemul_sun_init(edp, type, cookie, ccol, crow, defattr)
	struct wsemul_sun_emuldata *edp;
d119 5
d131 3
a133 29
	edp->defattr = defattr;
}

void
wsemul_sun_reset(edp)
	struct wsemul_sun_emuldata *edp;
{
	edp->state = SUN_EMUL_STATE_NORMAL;
	edp->flags = 0;
	edp->bkgdattr = edp->curattr = edp->defattr;
	edp->attrflags = 0;
	edp->fgcol = WSCOL_BLACK;
	edp->bgcol = WSCOL_WHITE;
	edp->scrolldist = 1;
}

void *
wsemul_sun_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
{
	struct wsemul_sun_emuldata *edp;
	int res;

	edp = &wsemul_sun_console_emuldata;
	wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);

d135 1
a135 1
#define WS_KERNEL_FG wskernel_bg
d138 1
a138 1
#define WS_KERNEL_BG wskernel_fg
d156 4
a159 1
		edp->kernattr = defattr;
d163 2
a167 2

	wsemul_sun_reset(edp);
a188 1
		wsemul_sun_init(edp, type, cookie, ccol, crow, defattr);
d190 11
d208 15
a222 1
	wsemul_sun_reset(edp);
d226 2
a227 2
void
wsemul_sun_output_lowchars(edp, c, kernel)
d232 1
a235 5
	case ASCII_NUL:
	default:
		/* ignore */
		break;

d241 1
a241 1
		if (edp->ccol > 0) {
a242 2
			CLR(edp->flags, SUNFL_LASTCHAR);
		}
a246 1
		CLR(edp->flags, SUNFL_LASTCHAR);
d253 1
a253 1
				kernel ? edp->kernattr : edp->bkgdattr);
a254 2
		if (COLS_LEFT == 0)
			SET(edp->flags, SUNFL_LASTCHAR);
d259 4
a262 3
		    edp->bkgdattr);
		edp->ccol = edp->crow = 0;
		CLR(edp->flags, SUNFL_LASTCHAR);
d272 1
a272 1
			printf("wsemul_sun_output_lowchars: ESC in kernel "
d277 20
a296 2
		edp->state = SUN_EMUL_STATE_HAVEESC;
		break;
d300 1
a300 1
		if (ROWS_LEFT > 0)
d302 21
a322 2
		else
			wsemul_sun_scrollup(edp);
a324 1
}
d326 1
a326 23
void
wsemul_sun_output_normal(edp, c, kernel)
	struct wsemul_sun_emuldata *edp;
	u_char c;
	int kernel;
{
	if (ISSET(edp->flags, SUNFL_LASTCHAR)) {
                /* if the cur line isn't the last, incr and leave. */
		if (ROWS_LEFT > 0)
			edp->crow++;
		else
			wsemul_sun_scrollup(edp);
		edp->ccol = 0;
		CLR(edp->flags, SUNFL_LASTCHAR);
	}

	(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
	    c, kernel ? edp->kernattr : edp->curattr);

	if (COLS_LEFT)
		edp->ccol++;
	else
		SET(edp->flags, SUNFL_LASTCHAR);
d329 1
a329 1
u_int
a337 1
		edp->nargs = 0;
d343 3
a345 4
#ifdef DEBUG
		printf("ESC%c unknown\n", c);
#endif
		newstate = SUN_EMUL_STATE_NORMAL;	/* XXX is this wise? */
d352 1
a352 1
void
a357 2
	int flags, fgcol, bgcol;
	long attr, bkgdattr;
d369 1
a369 1
		    src, n, edp->bkgdattr);
d393 2
a394 2
		edp->crow = min(NORMALIZE_ARG(0), edp->nrows) - 1;
		edp->ccol = min(NORMALIZE_ARG(1), edp->ncols) - 1;
d400 1
a400 1
			     edp->crow + 1, ROWS_LEFT, edp->bkgdattr);
d405 1
a405 1
		    edp->ccol, COLS_LEFT + 1, edp->bkgdattr);
d417 1
a417 1
		    src, dst - src, edp->bkgdattr);
d429 1
a429 1
		    dst + edp->nrows - src, src - dst, edp->bkgdattr);
d441 1
a441 1
		    edp->ncols - n, n, edp->bkgdattr);
d445 5
a449 59
		flags = edp->attrflags;
		fgcol = edp->fgcol;
		bgcol = edp->bgcol;

		for (n = 0; n < edp->nargs; n++) {
			switch (ARG(n)) {
			/* Clear all attributes || End underline */
			case 0:
				if (n == edp->nargs - 1) {
					edp->bkgdattr =
					    edp->curattr = edp->defattr;
					edp->attrflags = 0;
					edp->fgcol = WSCOL_BLACK;
					edp->bgcol = WSCOL_WHITE;
					return;
				}
				flags = 0;
				fgcol = WSCOL_BLACK;
				bgcol = WSCOL_WHITE;
				break;
			/* Begin bold */
			case 1:
				flags |= WSATTR_HILIT;
				break;
			/* Begin underline */
			case 4:
				flags |= WSATTR_UNDERLINE;
				break;
			/* Begin reverse */
			case 7:
				flags |= WSATTR_REVERSE;
				break;
			/* ANSI foreground color */
			case 30: case 31: case 32: case 33:
			case 34: case 35: case 36: case 37:
				fgcol = ARG(n) - 30;
				break;
			/* ANSI background color */
			case 40: case 41: case 42: case 43:
			case 44: case 45: case 46: case 47:
				bgcol = ARG(n) - 40;
				break;
			}
		}
setattr:
		if (wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, &attr,
		    &bkgdattr)) {
#ifdef DEBUG
			printf("error allocating attr %d/%d/%x\n",
			    fgcol, bgcol, flags);
#endif
		} else {
			edp->curattr = attr;
			edp->bkgdattr = bkgdattr;
			edp->attrflags = flags;
			edp->fgcol = fgcol;
			edp->bgcol = bgcol;
		}
		break;
d452 1
a452 2
		fgcol = WSCOL_BLACK;
		bgcol = WSCOL_WHITE;
d456 1
a456 2
		fgcol = WSCOL_WHITE;
		bgcol = WSCOL_BLACK;
d464 8
a471 1
		wsemul_sun_reset(edp);
a473 5

	if (COLS_LEFT)
		CLR(edp->flags, SUNFL_LASTCHAR);
	else
		SET(edp->flags, SUNFL_LASTCHAR);
d476 1
a476 1
u_int
d482 1
d487 1
a487 4
		if (edp->nargs > SUN_EMUL_NARGS - 1)
			break;
		edp->args[edp->nargs] = (edp->args[edp->nargs] * 10) +
		    (c - '0');
d491 3
a493 1
		edp->nargs++;
a496 3
		edp->nargs++;
		if (edp->nargs > SUN_EMUL_NARGS)
			edp->nargs = SUN_EMUL_NARGS;
a521 5
		if (*data < ' ') {
			wsemul_sun_output_lowchars(edp, *data, kernel);
			continue;
		}

d526 1
a526 2

		switch (newstate = edp->state) {
d528 2
a529 1
			wsemul_sun_output_normal(edp, *data, 0);
d539 2
a540 2
			panic("wsemul_sun: invalid state %d", edp->state);
#else
d542 1
a542 3
			newstate = SUN_EMUL_STATE_NORMAL;
			wsemul_sun_output_normal(edp, *data, 0);
#endif
a550 69

/*
 * Get an attribute from the graphics driver.
 * Try to find replacements if the desired appearance is not supported.
 */
int
wsemul_sun_selectattribute(edp, flags, fgcol, bgcol, attr, bkgdattr)
	struct wsemul_sun_emuldata *edp;
	int flags, fgcol, bgcol;
	long *attr, *bkgdattr;
{
	int error;

	/*
	 * Rasops will force white on black as normal output colors, unless
	 * WSATTR_WSCOLORS is specified. Since Sun console is black on white,
	 * always use WSATTR_WSCOLORS and our colors, as we know better.
	 */
	if (!(edp->scrcapabilities & WSSCREEN_WSCOLORS)) {
		flags &= ~WSATTR_WSCOLORS;
	} else {
		flags |= WSATTR_WSCOLORS;
	}

	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags & WSATTR_WSCOLORS, bkgdattr);
	if (error)
		return (error);

	if ((flags & WSATTR_HILIT) &&
	    !(edp->scrcapabilities & WSSCREEN_HILIT)) {
		flags &= ~WSATTR_HILIT;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_RED;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_UNDERLINE) &&
	    !(edp->scrcapabilities & WSSCREEN_UNDERLINE)) {
		flags &= ~WSATTR_UNDERLINE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			fgcol = WSCOL_CYAN;
			flags &= ~WSATTR_UNDERLINE;
			flags |= WSATTR_WSCOLORS;
		}
	}
	if ((flags & WSATTR_BLINK) &&
	    !(edp->scrcapabilities & WSSCREEN_BLINK)) {
		flags &= ~WSATTR_BLINK;
	}
	if ((flags & WSATTR_REVERSE) &&
	    !(edp->scrcapabilities & WSSCREEN_REVERSE)) {
		flags &= ~WSATTR_REVERSE;
		if (edp->scrcapabilities & WSSCREEN_WSCOLORS) {
			int help;
			help = bgcol;
			bgcol = fgcol;
			fgcol = help;
			flags |= WSATTR_WSCOLORS;
		}
	}
	error = (*edp->emulops->alloc_attr)(edp->emulcookie, fgcol, bgcol,
					    flags, attr);
	if (error)
		return (error);

	return (0);
}

d561 1
a561 18
	"\033[233z",
	"\033[234z",
	"\033[235z",	/* F12 */
};

static char *sun_lkeys[] = {
	"\033[207z",	/* KS_Help */
	NULL,		/* KS_Execute */
	"\033[200z",	/* KS_Find */
	NULL,		/* KS_Select */
	"\033[193z",	/* KS_Again */
	"\033[194z",	/* KS_Props */
	"\033[195z",	/* KS_Undo */
	"\033[196z",	/* KS_Front */
	"\033[197z",	/* KS_Copy */
	"\033[198z",	/* KS_Open */
	"\033[199z",	/* KS_Paste */
	"\033[201z",	/* KS_Cut */
d578 1
a578 1
	if (in >= KS_f1 && in <= KS_f12) {
d582 1
a582 1
	if (in >= KS_F1 && in <= KS_F12) {
a589 4
	if (in >= KS_Help && in <= KS_Cut && sun_lkeys[in - KS_Help] != NULL) {
		*out = sun_lkeys[in - KS_Help];
		return (6);
	}
d592 3
a594 3
	case KS_Home:
	case KS_KP_Home:
	case KS_KP_Begin:
d597 2
a598 10
	case KS_End:
	case KS_KP_End:
		*out = "\033[220z";
		return (6);
	case KS_Insert:
	case KS_KP_Insert:
		*out = "\033[247z";
		return (6);
	case KS_Prior:
	case KS_KP_Prior:
d601 2
a602 2
	case KS_Next:
	case KS_KP_Next:
d605 2
a606 2
	case KS_Up:
	case KS_KP_Up:
d609 2
a610 2
	case KS_Down:
	case KS_KP_Down:
d613 2
a614 2
	case KS_Left:
	case KS_KP_Left:
d617 2
a618 2
	case KS_Right:
	case KS_KP_Right:
d621 1
a621 1
	case KS_KP_Delete:
d650 4
a653 1
		wsemul_sun_reset(edp);
d657 1
a657 1
		    edp->bkgdattr);
a658 1
		CLR(edp->flags, SUNFL_LASTCHAR);
a663 23
}

void
wsemul_sun_scrollup(edp)
	struct wsemul_sun_emuldata *edp;
{
	/*
	 * if we're in wrap-around mode, go to the first
	 * line and clear it.
	 */
	if (edp->scrolldist == 0) {
		edp->crow = 0;
		(*edp->emulops->eraserows)(edp->emulcookie, 0, 1,
		    edp->bkgdattr);
		return;
	}

	/* scroll by the scrolling distance. */
	(*edp->emulops->copyrows)(edp->emulcookie, edp->scrolldist, 0,
	    edp->nrows - edp->scrolldist);
	(*edp->emulops->eraserows)(edp->emulcookie,
	    edp->nrows - edp->scrolldist, edp->scrolldist, edp->bkgdattr);
	edp->crow -= edp->scrolldist - 1;
@


1.3.4.4
log
@Merge with the trunk
@
text
@d92 3
d122 2
a123 2
#define	COLS_LEFT		(edp->ncols - 1 - edp->ccol)
#define	ROWS_LEFT		(edp->nrows - 1 - edp->crow)
d158 1
d263 1
a263 1
		if (edp->ccol > 0)
d265 2
d271 1
d280 2
d288 1
d322 1
a322 5

	(*edp->emulops->putchar)(edp->emulcookie, edp->crow, edp->ccol,
	    c, kernel ? edp->kernattr : edp->curattr);

	if (++edp->ccol >= edp->ncols) {
d329 1
d331 8
d433 1
a433 1
		    src, n, edp->bkgdattr);
d445 1
a445 1
		    dst + edp->nrows - src, n, edp->bkgdattr);
d539 5
d834 1
@


1.2
log
@Instead of panic'ing when an ESC is found in kernel output, print a warning
and ignore it; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: wsemul_sun.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
d98 5
a102 7
static u_int	wsemul_sun_output_normal __P((struct wsemul_sun_emuldata *,
		    u_char, int));
static u_int	wsemul_sun_output_haveesc __P((struct wsemul_sun_emuldata *,
		    u_char));
static u_int	wsemul_sun_output_control __P((struct wsemul_sun_emuldata *,
		    u_char));
static void	wsemul_sun_control __P((struct wsemul_sun_emuldata *, u_char));
d226 1
a226 1
static inline u_int
d329 1
a329 1
static inline u_int
d352 1
a352 1
static inline void
d476 1
a476 1
static inline u_int
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d273 6
a278 4
#ifdef DIAGNOSTIC
		if (kernel)
			panic("ESC in kernel output");
#endif
@

