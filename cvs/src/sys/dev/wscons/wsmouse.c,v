head	1.38;
access;
symbols
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.4
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.23.0.6
	OPENBSD_5_4_BASE:1.23
	OPENBSD_5_3:1.23.0.4
	OPENBSD_5_3_BASE:1.23
	OPENBSD_5_2:1.23.0.2
	OPENBSD_5_2_BASE:1.23
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.2
	OPENBSD_5_0:1.21.0.6
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.4
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.12
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.8
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.6
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.18.0.2
	OPENBSD_4_1_BASE:1.18
	OPENBSD_4_0:1.17.0.6
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.4
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.2
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.13.0.4
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.13.0.2
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.2
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.10
	OPENBSD_3_3:1.10.0.4
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.2
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.10
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	SMP:1.6.0.2
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.38
date	2017.03.16.10.03.27;	author mpi;	state Exp;
branches;
next	1.37;
commitid	98yfHbLbz9JTRK0J;

1.37
date	2017.03.06.09.08.45;	author mpi;	state Exp;
branches;
next	1.36;
commitid	rFkSHOfbRlLuAmfj;

1.36
date	2017.02.27.15.59.56;	author bru;	state Exp;
branches;
next	1.35;
commitid	8SRGrIuLd7axW5SE;

1.35
date	2016.10.23.22.59.19;	author bru;	state Exp;
branches;
next	1.34;
commitid	m7Qv2drIZWfJ1bkB;

1.34
date	2016.08.18.21.12.35;	author bru;	state Exp;
branches;
next	1.33;
commitid	iOWfDm0VZFKSQJu6;

1.33
date	2016.07.13.15.41.51;	author deraadt;	state Exp;
branches;
next	1.32;
commitid	0nmkAvA6eAu3QzU3;

1.32
date	2016.07.12.22.02.53;	author bru;	state Exp;
branches;
next	1.31;
commitid	woGs3ru2vOmCXCwP;

1.31
date	2016.07.05.19.33.14;	author bru;	state Exp;
branches;
next	1.30;
commitid	dvrJh5yaezSulNQ8;

1.30
date	2016.06.06.22.32.47;	author bru;	state Exp;
branches;
next	1.29;
commitid	d2zsEZc9nwE8cAmi;

1.29
date	2016.03.30.23.34.12;	author bru;	state Exp;
branches;
next	1.28;
commitid	216Sb0C4sEs8CDdv;

1.28
date	2015.09.10.18.14.52;	author mpi;	state Exp;
branches;
next	1.27;
commitid	yCNTJc2qmad1KZnd;

1.27
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.10.27.13.55.05;	author mpi;	state Exp;
branches;
next	1.25;
commitid	wJzi0sga39BzYaSt;

1.25
date	2013.10.30.18.00.57;	author shadchin;	state Exp;
branches;
next	1.24;

1.24
date	2013.10.18.13.54.09;	author miod;	state Exp;
branches;
next	1.23;

1.23
date	2012.07.22.18.28.36;	author shadchin;	state Exp;
branches;
next	1.22;

1.22
date	2011.08.17.16.10.27;	author shadchin;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.14.11.00.15;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.06.01.18.50.30;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.18.21.31.27;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.15.11.29.15;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2004.06.24.19.35.24;	author tholo;	state Exp;
branches;
next	1.12;

1.12
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.02.23.28.04;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.30.23.01.55;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.27.18.54.09;	author jbm;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.04.19.37.52;	author mickey;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.05.08.22.28.43;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.03.30.16.38.14;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2001.02.18.15.18.49;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.30.19.51.43;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.01.13.51.18;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.12;	author mickey;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.32;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.44.13;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.42.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.38
log
@Simplify wstpad option handling:

- Remove unnecessary abstraction
- Make it possible to support new features/options without ABI break
- Remove some complexity and hard limits
- Simplify & keep documentation close to options

ok bru@@
@
text
@/* $OpenBSD: wsmouse.c,v 1.37 2017/03/06 09:08:45 mpi Exp $ */
/* $NetBSD: wsmouse.c,v 1.35 2005/02/27 00:27:52 perry Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This software was developed by the Computer Systems Engineering group
 * at Lawrence Berkeley Laboratory under DARPA contract BG 91-66 and
 * contributed to Berkeley.
 *
 * All advertising materials mentioning features or use of this software
 * must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Lawrence Berkeley Laboratory.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)ms.c	8.1 (Berkeley) 6/11/93
 */

/*
 * Copyright (c) 2015, 2016 Ulf Brosziewski
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Mouse driver.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/ioctl.h>
#include <sys/fcntl.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/device.h>
#include <sys/vnode.h>
#include <sys/poll.h>
#include <sys/malloc.h>

#include <dev/wscons/wscons_features.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wsmouseinput.h>
#include <dev/rndvar.h>

#include "wsmux.h"
#include "wsdisplay.h"
#include "wskbd.h"

#include <dev/wscons/wsmuxvar.h>

#if defined(WSMUX_DEBUG) && NWSMUX > 0
#define	DPRINTF(x)	if (wsmuxdebug) printf x
#define	DPRINTFN(n,x)	if (wsmuxdebug > (n)) printf x
extern int wsmuxdebug;
#else
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#endif

struct wsmouse_softc {
	struct wsevsrc	sc_base;

	const struct wsmouse_accessops *sc_accessops;
	void		*sc_accesscookie;

	struct wsmouseinput sc_input;

	int		sc_refcnt;
	u_char		sc_dying;	/* device is being detached */
};

int	wsmouse_match(struct device *, void *, void *);
void	wsmouse_attach(struct device *, struct device *, void *);
int	wsmouse_detach(struct device *, int);
int	wsmouse_activate(struct device *, int);

int	wsmouse_do_ioctl(struct wsmouse_softc *, u_long, caddr_t, 
			      int, struct proc *);

#if NWSMUX > 0
int	wsmouse_mux_open(struct wsevsrc *, struct wseventvar *);
int	wsmouse_mux_close(struct wsevsrc *);
#endif

int	wsmousedoioctl(struct device *, u_long, caddr_t, int, 
			    struct proc *);
int	wsmousedoopen(struct wsmouse_softc *, struct wseventvar *);

struct cfdriver wsmouse_cd = {
	NULL, "wsmouse", DV_TTY
};

struct cfattach wsmouse_ca = {
	sizeof (struct wsmouse_softc), wsmouse_match, wsmouse_attach,
	wsmouse_detach, wsmouse_activate
};

#if NWSMUX > 0
struct wssrcops wsmouse_srcops = {
	WSMUX_MOUSE,
	wsmouse_mux_open, wsmouse_mux_close, wsmousedoioctl, NULL, NULL
};
#endif

/*
 * Print function (for parent devices).
 */
int
wsmousedevprint(void *aux, const char *pnp)
{

	if (pnp)
		printf("wsmouse at %s", pnp);
	return (UNCONF);
}

int
wsmouse_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
wsmouse_attach(struct device *parent, struct device *self, void *aux)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
	struct wsmousedev_attach_args *ap = aux;
#if NWSMUX > 0
	int mux, error;
#endif

	sc->sc_accessops = ap->accessops;
	sc->sc_accesscookie = ap->accesscookie;

	sc->sc_input.evar = &sc->sc_base.me_evp;

#if NWSMUX > 0
	sc->sc_base.me_ops = &wsmouse_srcops;
	mux = sc->sc_base.me_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux >= 0) {
		error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
		if (error)
			printf(" attach error=%d", error);
		else
			printf(" mux %d", mux);
	}
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (sc->sc_base.me_dv.dv_cfdata->wsmousedevcf_mux >= 0)
		printf(" (mux ignored)");
#endif
#endif	/* NWSMUX > 0 */

	printf("\n");
}

int
wsmouse_activate(struct device *self, int act)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;

	if (act == DVACT_DEACTIVATE)
		sc->sc_dying = 1;
	return (0);
}

/*
 * Detach a mouse.  To keep track of users of the softc we keep
 * a reference count that's incremented while inside, e.g., read.
 * If the mouse is active and the reference count is > 0 (0 is the
 * normal state) we post an event and then wait for the process
 * that had the reference to wake us up again.  Then we blow away the
 * vnode and return (which will deallocate the softc).
 */
int
wsmouse_detach(struct device *self, int flags)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
	struct wseventvar *evar;
	int maj, mn;
	int s;

#if NWSMUX > 0
	/* Tell parent mux we're leaving. */
	if (sc->sc_base.me_parent != NULL) {
		DPRINTF(("wsmouse_detach:\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
#endif

	/* If we're open ... */
	evar = sc->sc_base.me_evp;
	if (evar != NULL && evar->io != NULL) {
		s = spltty();
		if (--sc->sc_refcnt >= 0) {
			/* Wake everyone by generating a dummy event. */
			if (++evar->put >= WSEVENT_QSIZE)
				evar->put = 0;
			WSEVENT_WAKEUP(evar);
			/* Wait for processes to go away. */
			if (tsleep(sc, PZERO, "wsmdet", hz * 60))
				printf("wsmouse_detach: %s didn't detach\n",
				       sc->sc_base.me_dv.dv_xname);
		}
		splx(s);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wsmouseopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	wsmouse_input_cleanup(&sc->sc_input);

	return (0);
}

int
wsmouseopen(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wsmouse_softc *sc;
	struct wseventvar *evar;
	int error, unit;

	unit = minor(dev);
	if (unit >= wsmouse_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

#if NWSMUX > 0
	DPRINTF(("wsmouseopen: %s mux=%p p=%p\n", sc->sc_base.me_dv.dv_xname,
		 sc->sc_base.me_parent, p));
#endif

	if (sc->sc_dying)
		return (EIO);

	if ((flags & (FREAD | FWRITE)) == FWRITE)
		return (0);			/* always allow open for write
						   so ioctl() is possible. */

#if NWSMUX > 0
	if (sc->sc_base.me_parent != NULL) {
		/* Grab the mouse out of the greedy hands of the mux. */
		DPRINTF(("wsmouseopen: detach\n"));
		wsmux_detach_sc(&sc->sc_base);
	}
#endif

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	evar = &sc->sc_base.me_evar;
	wsevent_init(evar);
	evar->io = p->p_p;

	error = wsmousedoopen(sc, evar);
	if (error) {
		DPRINTF(("wsmouseopen: %s open failed\n",
			 sc->sc_base.me_dv.dv_xname));
		sc->sc_base.me_evp = NULL;
		wsevent_fini(evar);
	}
	return (error);
}

int
wsmouseclose(dev_t dev, int flags, int mode, struct proc *p)
{
	struct wsmouse_softc *sc =
	    (struct wsmouse_softc *)wsmouse_cd.cd_devs[minor(dev)];
	struct wseventvar *evar = sc->sc_base.me_evp;

	if ((flags & (FREAD | FWRITE)) == FWRITE)
		return (0);			/* see wsmouseopen() */

	if (evar == NULL)
		/* not open for read */
		return (0);
	sc->sc_base.me_evp = NULL;
	(*sc->sc_accessops->disable)(sc->sc_accesscookie);
	wsevent_fini(evar);

#if NWSMUX > 0
	if (sc->sc_base.me_parent == NULL) {
		int mux, error;

		DPRINTF(("wsmouseclose: attach\n"));
		mux = sc->sc_base.me_dv.dv_cfdata->wsmousedevcf_mux;
		if (mux >= 0) {
			error = wsmux_attach_sc(wsmux_getmux(mux), &sc->sc_base);
			if (error)
				printf("%s: can't attach mux (error=%d)\n",
				    sc->sc_base.me_dv.dv_xname, error);
		}
	}
#endif

	return (0);
}

int
wsmousedoopen(struct wsmouse_softc *sc, struct wseventvar *evp)
{
	sc->sc_base.me_evp = evp;

	wsmouse_input_reset(&sc->sc_input);

	/* enable the device, and punt if that's not possible */
	return (*sc->sc_accessops->enable)(sc->sc_accesscookie);
}

int
wsmouseread(dev_t dev, struct uio *uio, int flags)
{
	struct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];
	int error;

	if (sc->sc_dying)
		return (EIO);

#ifdef DIAGNOSTIC
	if (sc->sc_base.me_evp == NULL) {
		printf("wsmouseread: evp == NULL\n");
		return (EINVAL);
	}
#endif

	sc->sc_refcnt++;
	error = wsevent_read(sc->sc_base.me_evp, uio, flags);
	if (--sc->sc_refcnt < 0) {
		wakeup(sc);
		error = EIO;
	}
	return (error);
}

int
wsmouseioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	return (wsmousedoioctl(wsmouse_cd.cd_devs[minor(dev)],
	    cmd, data, flag, p));
}

/* A wrapper around the ioctl() workhorse to make reference counting easy. */
int
wsmousedoioctl(struct device *dv, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)dv;
	int error;

	sc->sc_refcnt++;
	error = wsmouse_do_ioctl(sc, cmd, data, flag, p);
	if (--sc->sc_refcnt < 0)
		wakeup(sc);
	return (error);
}

int
wsmouse_param_ioctl(struct wsmouse_softc *sc,
    u_long cmd, struct wsmouse_param *params, u_int nparams)
{
	struct wsmouse_param *buf;
	int error, s, size;

	if (params == NULL || nparams > WSMOUSECFG_MAX)
		return (EINVAL);

	size = nparams * sizeof(struct wsmouse_param);
	buf = malloc(size, M_DEVBUF, M_WAITOK);
	if (buf == NULL)
		return (ENOMEM);

	if ((error = copyin(params, buf, size))) {
		free(buf, M_DEVBUF, size);
		return (error);
	}

	s = spltty();
	if (cmd == WSMOUSEIO_SETPARAMS) {
		if (wsmouse_set_params((struct device *) sc, buf, nparams))
			error = EINVAL;
	} else {
		if (wsmouse_get_params((struct device *) sc, buf, nparams))
			error = EINVAL;
		else
			error = copyout(buf, params, size);
	}
	splx(s);
	free(buf, M_DEVBUF, size);
	return (error);
}

int
wsmouse_do_ioctl(struct wsmouse_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	int error;

	if (sc->sc_dying)
		return (EIO);

	/*
	 * Try the generic ioctls that the wsmouse interface supports.
	 */

	switch (cmd) {
	case FIOASYNC:
	case FIOSETOWN:
	case TIOCSPGRP:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
	case FIONBIO:		/* we will remove this someday (soon???) */
		return (0);

	case FIOASYNC:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		sc->sc_base.me_evp->async = *(int *)data != 0;
		return (0);

	case FIOSETOWN:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (-*(int *)data != sc->sc_base.me_evp->io->ps_pgid
		    && *(int *)data != sc->sc_base.me_evp->io->ps_pid)
			return (EPERM);
		return (0);

	case TIOCSPGRP:
		if (sc->sc_base.me_evp == NULL)
			return (EINVAL);
		if (*(int *)data != sc->sc_base.me_evp->io->ps_pgid)
			return (EPERM);
		return (0);
	case WSMOUSEIO_GETPARAMS:
	case WSMOUSEIO_SETPARAMS:
		return (wsmouse_param_ioctl(sc, cmd,
		    ((struct wsmouse_parameters *) data)->params,
		    ((struct wsmouse_parameters *) data)->nparams));
	}

	/*
	 * Try the mouse driver for WSMOUSEIO ioctls.  It returns -1
	 * if it didn't recognize the request.
	 */
	error = (*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,
	    data, flag, p);
	return (error != -1 ? error : ENOTTY);
}

int
wsmousepoll(dev_t dev, int events, struct proc *p)
{
	struct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (POLLERR);
	return (wsevent_poll(sc->sc_base.me_evp, events, p));
}

int
wsmousekqfilter(dev_t dev, struct knote *kn)
{
	struct wsmouse_softc *sc = wsmouse_cd.cd_devs[minor(dev)];

	if (sc->sc_base.me_evp == NULL)
		return (ENXIO);
	return (wsevent_kqfilter(sc->sc_base.me_evp, kn));
}

#if NWSMUX > 0
int
wsmouse_mux_open(struct wsevsrc *me, struct wseventvar *evp)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)me;

	if (sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return wsmousedoopen(sc, evp);
}

int
wsmouse_mux_close(struct wsevsrc *me)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)me;

	sc->sc_base.me_evp = NULL;
	(*sc->sc_accessops->disable)(sc->sc_accesscookie);

	return (0);
}

int
wsmouse_add_mux(int unit, struct wsmux_softc *muxsc)
{
	struct wsmouse_softc *sc;

	if (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (sc->sc_base.me_parent != NULL || sc->sc_base.me_evp != NULL)
		return (EBUSY);

	return (wsmux_attach_sc(muxsc, &sc->sc_base));
}
#endif	/* NWSMUX > 0 */

void
wsmouse_buttons(struct device *sc, u_int buttons)
{
	struct btn_state *btn = &((struct wsmouse_softc *) sc)->sc_input.btn;

	if (btn->sync)
		/* Restore the old state. */
		btn->buttons ^= btn->sync;

	btn->sync = btn->buttons ^ buttons;
	btn->buttons = buttons;
}

void
wsmouse_motion(struct device *sc, int dx, int dy, int dz, int dw)
{
	struct motion_state *motion =
	    &((struct wsmouse_softc *) sc)->sc_input.motion;

	motion->dx = dx;
	motion->dy = dy;
	motion->dz = dz;
	motion->dw = dw;
	if (dx || dy || dz || dw)
		motion->sync |= SYNC_DELTAS;
}

/*
 * Handle absolute coordinates.
 *
 * x_delta/y_delta are used by touchpad code. The values are only
 * valid if the SYNC-flags are set, and will be cleared by update- or
 * conversion-functions if a touch shouldn't trigger pointer motion.
 */
void
wsmouse_position(struct device *sc, int x, int y)
{
	struct motion_state *motion =
	    &((struct wsmouse_softc *) sc)->sc_input.motion;
	int delta;

	delta = x - motion->x;
	if (delta) {
		motion->x = x;
		motion->sync |= SYNC_X;
		motion->x_delta = delta;
	}
	delta = y - motion->y;
	if (delta) {
		motion->y = y;
		motion->sync |= SYNC_Y;
		motion->y_delta = delta;
	}
}

static inline int
normalized_pressure(struct wsmouseinput *input, int pressure)
{
	int limit = imax(input->touch.min_pressure, 1);

	if (pressure >= limit)
		return pressure;
	else
		return (pressure < 0 ? limit : 0);
}

void
wsmouse_touch(struct device *sc, int pressure, int contacts)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct touch_state *touch = &input->touch;

	pressure = normalized_pressure(input, pressure);
	contacts = (pressure ? imax(contacts, 1) : 0);

	if (pressure == 0 || pressure != touch->pressure) {
		/*
		 * pressure == 0: Drivers may report possibly arbitrary
		 * coordinates in this case; touch_update will correct them.
		 */
		touch->pressure = pressure;
		touch->sync |= SYNC_PRESSURE;
	}
	touch->prev_contacts = touch->contacts;
	if (contacts != touch->contacts) {
		touch->contacts = contacts;
		touch->sync |= SYNC_CONTACTS;
	}
}

void
wsmouse_mtstate(struct device *sc, int slot, int x, int y, int pressure)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct mt_state *mt = &input->mt;
	struct mt_slot *mts;
	u_int bit;
	int initial;

	if (slot < 0 || slot >= mt->num_slots)
		return;

	bit = (1 << slot);
	mt->frame |= bit;

	/* Is this a new touch? */
	initial = ((mt->touches & bit) == (mt->sync[MTS_TOUCH] & bit));

	mts = &mt->slots[slot];
	if (x != mts->x || initial) {
		mts->x = x;
		mt->sync[MTS_X] |= bit;
	}
	if (y != mts->y || initial) {
		mts->y = y;
		mt->sync[MTS_Y] |= bit;
	}
	pressure = normalized_pressure(input, pressure);
	if (pressure != mts->pressure || initial) {
		mts->pressure = pressure;
		mt->sync[MTS_PRESSURE] |= bit;

		if (pressure) {
			if ((mt->touches & bit) == 0) {
				mt->num_touches++;
				mt->touches |= bit;
				mt->sync[MTS_TOUCH] |= bit;
			}
		} else if (mt->touches & bit) {
			mt->num_touches--;
			mt->touches ^= bit;
			mt->sync[MTS_TOUCH] |= bit;
		}
	}
}

void
wsmouse_set(struct device *sc, enum wsmouseval type, int value, int aux)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct mt_slot *mts;

	if (WSMOUSE_IS_MT_CODE(type)) {
		if (aux < 0 || aux >= input->mt.num_slots)
			return;
		mts = &input->mt.slots[aux];
	}

	switch (type) {
	case WSMOUSE_REL_X:
		value += input->motion.x; /* fall through */
	case WSMOUSE_ABS_X:
		wsmouse_position(sc, value, input->motion.y);
		return;
	case WSMOUSE_REL_Y:
		value += input->motion.y;
	case WSMOUSE_ABS_Y:
		wsmouse_position(sc, input->motion.x, value);
		return;
	case WSMOUSE_PRESSURE:
		wsmouse_touch(sc, value, input->touch.contacts);
		return;
	case WSMOUSE_CONTACTS:
		/* Contact counts can be overridden by wsmouse_touch. */
		if (value != input->touch.contacts) {
			input->touch.contacts = value;
			input->touch.sync |= SYNC_CONTACTS;
		}
		return;
	case WSMOUSE_TOUCH_WIDTH:
		if (value != input->touch.width) {
			input->touch.width = value;
			input->touch.sync |= SYNC_TOUCH_WIDTH;
		}
		return;
	case WSMOUSE_MT_REL_X:
		value += mts->x; /* fall through */
	case WSMOUSE_MT_ABS_X:
		wsmouse_mtstate(sc, aux, value, mts->y, mts->pressure);
		return;
	case WSMOUSE_MT_REL_Y:
		value += mts->y;
	case WSMOUSE_MT_ABS_Y:
		wsmouse_mtstate(sc, aux, mts->x, value, mts->pressure);
		return;
	case WSMOUSE_MT_PRESSURE:
		wsmouse_mtstate(sc, aux, mts->x, mts->y, value);
		return;
	}
}

/* Make touch and motion state consistent. */
void
wsmouse_touch_update(struct wsmouseinput *input)
{
	struct motion_state *motion = &input->motion;
	struct touch_state *touch = &input->touch;

	if (touch->pressure == 0) {
		/* Restore valid coordinates. */
		if (motion->sync & SYNC_X)
			motion->x -= motion->x_delta;
		if (motion->sync & SYNC_Y)
			motion->y -= motion->y_delta;
		/* Don't generate motion/position events. */
		motion->sync &= ~SYNC_POSITION;
	}
	if (touch->sync & SYNC_CONTACTS)
		/* Suppress pointer motion. */
		motion->x_delta = motion->y_delta = 0;

	if ((touch->sync & SYNC_PRESSURE) && touch->min_pressure) {
		if (touch->pressure >= input->filter.pressure_hi)
			touch->min_pressure = input->filter.pressure_lo;
		else if (touch->pressure < input->filter.pressure_lo)
			touch->min_pressure = input->filter.pressure_hi;
	}
}

/* Normalize multitouch state. */
void
wsmouse_mt_update(struct wsmouseinput *input)
{
	int i;

	/*
	 * The same as above: There may be arbitrary coordinates if
	 * (pressure == 0). Clear the sync flags for touches that have
	 * been released.
	 */
	if (input->mt.sync[MTS_TOUCH] & ~input->mt.touches) {
		for (i = MTS_X; i < MTS_SIZE; i++)
			input->mt.sync[i] &= input->mt.touches;
	}
}

/*
 * Select the pointer-controlling MT slot.
 *
 * Pointer-control is assigned to slots with non-zero motion deltas if
 * at least one such slot exists. This function doesn't impose any
 * restrictions on the way drivers use wsmouse_mtstate(), it covers
 * partial, unordered, and "delta-filtered" input.
 *
 * The "cycle" is the set of slots with X/Y updates in previous sync
 * operations; it will be cleared and rebuilt whenever a slot that is
 * being updated is already a member. If a cycle ends that doesn't
 * contain the pointer-controlling slot, a new slot will be selected.
 */
void
wsmouse_ptr_ctrl(struct mt_state *mt)
{
	u_int updates;
	int select, slot;

	mt->prev_ptr = mt->ptr;

	if (mt->num_touches <= 1) {
		mt->ptr = mt->touches;
		mt->ptr_cycle = mt->ptr;
		return;
	}

	/*
	 * If there is no pointer-controlling slot or it is inactive,
	 * select a new one.
	 */
	select = ((mt->ptr & mt->touches) == 0);

	/* Remove slots without X/Y deltas from the cycle. */
	updates = (mt->sync[MTS_X] | mt->sync[MTS_Y]) & ~mt->sync[MTS_TOUCH];
	mt->ptr_cycle &= ~(mt->frame ^ updates);

	if (mt->ptr_cycle & updates) {
		select |= ((mt->ptr_cycle & mt->ptr) == 0);
		mt->ptr_cycle = updates;
	} else {
		mt->ptr_cycle |= updates;
	}
	if (select) {
		slot = (mt->ptr_cycle
		    ? ffs(mt->ptr_cycle) - 1 : ffs(mt->touches) - 1);
		mt->ptr = (1 << slot);
	}
}

/* Derive touch and motion state from MT state. */
void
wsmouse_mt_convert(struct device *sc)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct mt_state *mt = &input->mt;
	struct mt_slot *mts;
	int slot, pressure;

	wsmouse_ptr_ctrl(mt);

	if (mt->ptr) {
		slot = ffs(mt->ptr) - 1;
		mts = &mt->slots[slot];
		wsmouse_position(sc, mts->x, mts->y);
		if (mt->ptr != mt->prev_ptr)
			/* Suppress pointer motion. */
			input->motion.x_delta = input->motion.y_delta = 0;
		pressure = mts->pressure;
	} else {
		pressure = 0;
	}

	wsmouse_touch(sc, pressure, mt->num_touches);
}

void
wsmouse_evq_put(struct evq_access *evq, int ev_type, int ev_value)
{
	struct wscons_event *ev;
	int space;

	space = evq->evar->get - evq->put;
	if (space != 1 && space != 1 - WSEVENT_QSIZE) {
		ev = &evq->evar->q[evq->put++];
		evq->put %= WSEVENT_QSIZE;
		ev->type = ev_type;
		ev->value = ev_value;
		memcpy(&ev->time, &evq->ts, sizeof(struct timespec));
		evq->result |= EVQ_RESULT_SUCCESS;
	} else {
		evq->result = EVQ_RESULT_OVERFLOW;
	}
}


void
wsmouse_btn_sync(struct btn_state *btn, struct evq_access *evq)
{
	int button, ev_type;
	u_int bit, sync;

	for (sync = btn->sync; sync; sync ^= bit) {
		button = ffs(sync) - 1;
		bit = (1 << button);
		ev_type = (btn->buttons & bit) ? BTN_DOWN_EV : BTN_UP_EV;
		wsmouse_evq_put(evq, ev_type, button);
	}
}

/*
 * Scale with a [*.12] fixed-point factor and a remainder:
 */
static inline int
scale(int val, int factor, int *rmdr)
{
	val = val * factor + *rmdr;
	if (val >= 0) {
		*rmdr = val & 0xfff;
		return (val >> 12);
	} else {
		*rmdr = -(-val & 0xfff);
		return -(-val >> 12);
	}
}

void
wsmouse_motion_sync(struct wsmouseinput *input, struct evq_access *evq)
{
	struct motion_state *motion = &input->motion;
	struct axis_filter *h = &input->filter.h;
	struct axis_filter *v = &input->filter.v;
	int x, y, dx, dy;

	if (motion->sync & SYNC_DELTAS) {
		dx = h->inv ? -motion->dx : motion->dx;
		dy = v->inv ? -motion->dy : motion->dy;
		if (h->scale)
			dx = scale(dx, h->scale, &h->rmdr);
		if (v->scale)
			dy = scale(dy, v->scale, &v->rmdr);
		if (dx)
			wsmouse_evq_put(evq, DELTA_X_EV(input), dx);
		if (dy)
			wsmouse_evq_put(evq, DELTA_Y_EV(input), dy);
		if (motion->dz)
			wsmouse_evq_put(evq, DELTA_Z_EV, motion->dz);
		if (motion->dw)
			wsmouse_evq_put(evq, DELTA_W_EV, motion->dw);
	}
	if (motion->sync & SYNC_POSITION) {
		if (motion->sync & SYNC_X) {
			x = (h->inv ? h->inv - motion->x : motion->x);
			wsmouse_evq_put(evq, ABS_X_EV(input), x);
		}
		if (motion->sync & SYNC_Y) {
			y = (v->inv ? v->inv - motion->y : motion->y);
			wsmouse_evq_put(evq, ABS_Y_EV(input), y);
		}
		if (motion->x_delta == 0 && motion->y_delta == 0
		    && (input->flags & TPAD_NATIVE_MODE))
			/* Suppress pointer motion. */
			wsmouse_evq_put(evq, WSCONS_EVENT_TOUCH_RESET, 0);
	}
}

void
wsmouse_touch_sync(struct wsmouseinput *input, struct evq_access *evq)
{
	struct touch_state *touch = &input->touch;

	if (touch->sync & SYNC_PRESSURE)
		wsmouse_evq_put(evq, ABS_Z_EV, touch->pressure);
	if (touch->sync & SYNC_CONTACTS)
		wsmouse_evq_put(evq, ABS_W_EV, touch->contacts);
	if ((touch->sync & SYNC_TOUCH_WIDTH)
	    && (input->flags & TPAD_NATIVE_MODE))
		wsmouse_evq_put(evq, WSCONS_EVENT_TOUCH_WIDTH, touch->width);
}

static inline void
clear_sync_flags(struct wsmouseinput *input)
{
	int i;

	input->btn.sync = 0;
	input->sbtn.sync = 0;
	input->motion.sync = 0;
	input->touch.sync = 0;
	if (input->mt.frame) {
		input->mt.frame = 0;
		for (i = 0; i < MTS_SIZE; i++)
			input->mt.sync[i] = 0;
	}
}

void
wsmouse_input_sync(struct device *sc)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct evq_access evq;

	evq.evar = *input->evar;
	if (evq.evar == NULL)
		return;
	evq.put = evq.evar->put;
	evq.result = EVQ_RESULT_NONE;
	getnanotime(&evq.ts);

	add_mouse_randomness(input->btn.buttons
	    ^ input->motion.dx ^ input->motion.dy
	    ^ input->motion.x ^ input->motion.y
	    ^ input->motion.dz ^ input->motion.dw);

	if (input->mt.frame) {
		wsmouse_mt_update(input);
		wsmouse_mt_convert(sc);
	}
	if (input->touch.sync)
		wsmouse_touch_update(input);

	if (input->flags & TPAD_COMPAT_MODE)
		wstpad_compat_convert(input, &evq);

	if (input->flags & RESYNC) {
		input->flags &= ~RESYNC;
		input->motion.sync &= SYNC_POSITION;
		input->motion.x_delta = input->motion.y_delta = 0;
	}

	if (input->btn.sync)
		wsmouse_btn_sync(&input->btn, &evq);
	if (input->sbtn.sync)
		wsmouse_btn_sync(&input->sbtn, &evq);
	if (input->motion.sync)
		wsmouse_motion_sync(input, &evq);
	if (input->touch.sync)
		wsmouse_touch_sync(input, &evq);
	/* No MT events are generated yet. */

	if (evq.result == EVQ_RESULT_SUCCESS) {
		wsmouse_evq_put(&evq, WSCONS_EVENT_SYNC, 0);
		if (evq.result == EVQ_RESULT_SUCCESS) {
			evq.evar->put = evq.put;
			WSEVENT_WAKEUP(evq.evar);
		}
	}

	if (evq.result != EVQ_RESULT_OVERFLOW)
		clear_sync_flags(input);
	else
		input->flags |= RESYNC;
}

int
wsmouse_id_to_slot(struct device *sc, int id)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct mt_state *mt = &input->mt;
	int slot;

	if (mt->num_slots == 0)
		return (-1);

	FOREACHBIT(mt->touches, slot) {
		if (mt->slots[slot].id == id)
			return slot;
	}
	slot = ffs(~(mt->touches | mt->frame)) - 1;
	if (slot >= 0 && slot < mt->num_slots) {
		mt->frame |= 1 << slot;
		mt->slots[slot].id = id;
		return (slot);
	} else {
		return (-1);
	}
}

/*
 * Find a minimum-weight matching for an m-by-n matrix.
 *
 * m must be greater than or equal to n. The size of the buffer must be
 * at least 3m + 3n.
 *
 * On return, the first m elements of the buffer contain the row-to-
 * column mappings, i.e., buffer[i] is the column index for row i, or -1
 * if there is no assignment for that row (which may happen if n < m).
 *
 * Wrong results because of overflows will not occur with input values
 * in the range of 0 to INT_MAX / 2 inclusive.
 *
 * The function applies the Dinic-Kronrod algorithm. It is not modern or
 * popular, but it seems to be a good choice for small matrices at least.
 * The original form of the algorithm is modified as follows: There is no
 * initial search for row minima, the initial assignments are in a
 * "virtual" column with the index -1 and zero values. This permits inputs
 * with n < m, and it simplifies the reassignments.
 */
void
wsmouse_matching(int *matrix, int m, int n, int *buffer)
{
	int i, j, k, d, e, row, col, delta;
	int *p;
	int *r2c = buffer;	/* row-to-column assignments */
	int *red = r2c + m;	/* reduced values of the assignments */
	int *mc = red + m;	/* row-wise minimal elements of cs */
	int *cs = mc + m;	/* the column set */
	int *c2r = cs + n;	/* column-to-row assignments in cs */
	int *cd = c2r + n;	/* column deltas (reduction) */

	for (p = r2c; p < red; *p++ = -1) {}
	for (; p < mc; *p++ = 0) {}
	for (col = 0; col < n; col++) {
		delta = INT_MAX;
		for (i = 0, p = matrix + col; i < m; i++, p += n) {
			d = *p - red[i];
			if (d < delta || (d == delta && r2c[i] < 0)) {
				delta = d;
				row = i;
			}
		}
		cd[col] = delta;
		if (r2c[row] < 0) {
			r2c[row] = col;
			continue;
		}
		for (p = mc; p < cs; *p++ = col) {}
		for (k = 0; (j = r2c[row]) >= 0;) {
			cs[k++] = j;
			c2r[j] = row;
			mc[row] -= n;
			delta = INT_MAX;
			for (i = 0, p = matrix; i < m; i++, p += n)
				if (mc[i] >= 0) {
					d = p[mc[i]] - cd[mc[i]];
					e = p[j] - cd[j];
					if (e < d) {
						d = e;
						mc[i] = j;
					}
					d -= red[i];
					if (d < delta || (d == delta
					    && r2c[i] < 0)) {
						delta = d;
						row = i;
					}
				}
			cd[col] += delta;
			for (i = 0; i < k; i++) {
				cd[cs[i]] += delta;
				red[c2r[cs[i]]] -= delta;
			}
		}
		for (j = mc[row]; (r2c[row] = j) != col;) {
			row = c2r[j];
			j = mc[row] + n;
		}
	}
}

void
wsmouse_mtframe(struct device *sc, struct mtpoint *pt, int size)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	struct mt_state *mt = &input->mt;
	int i, j, m, n, dx, dy, slot, maxdist;
	int *p, *r2c, *c2r;
	u_int touches;

	if (mt->num_slots == 0 || mt->matrix == NULL)
		return;

	size = imax(0, imin(size, mt->num_slots));
	p = mt->matrix;
	touches = mt->touches;
	if (mt->num_touches >= size) {
		FOREACHBIT(touches, slot)
			for (i = 0; i < size; i++) {
				dx = pt[i].x - mt->slots[slot].x;
				dy = pt[i].y - mt->slots[slot].y;
				*p++ = dx * dx + dy * dy;
			}
		m = mt->num_touches;
		n = size;
	} else {
		for (i = 0; i < size; i++)
			FOREACHBIT(touches, slot) {
				dx = pt[i].x - mt->slots[slot].x;
				dy = pt[i].y - mt->slots[slot].y;
				*p++ = dx * dx + dy * dy;
			}
		m = size;
		n = mt->num_touches;
	}
	wsmouse_matching(mt->matrix, m, n, p);

	r2c = p;
	c2r = p + m;
	maxdist = input->filter.tracking_maxdist;
	maxdist = (maxdist ? maxdist * maxdist : INT_MAX);
	for (i = 0, p = mt->matrix; i < m; i++, p += n)
		if ((j = r2c[i]) >= 0) {
			if (p[j] <= maxdist)
				c2r[j] = i;
			else
				c2r[j] = r2c[i] = -1;
		}

	p = (n == size ? c2r : r2c);
	for (i = 0; i < size; i++)
		if (*p++ < 0) {
			slot = ffs(~(mt->touches | mt->frame)) - 1;
			if (slot < 0 || slot >= mt->num_slots)
				break;
			wsmouse_mtstate(sc, slot,
			    pt[i].x, pt[i].y, pt[i].pressure);
			pt[i].slot = slot;
		}

	p = (n == size ? r2c : c2r);
	FOREACHBIT(touches, slot)
		if ((i = *p++) >= 0) {
			wsmouse_mtstate(sc, slot,
			    pt[i].x, pt[i].y, pt[i].pressure);
			pt[i].slot = slot;
		} else {
			wsmouse_mtstate(sc, slot, 0, 0, 0);
		}
}

static inline void
free_mt_slots(struct wsmouseinput *input)
{
	int n, size;

	if ((n = input->mt.num_slots)) {
		size = n * sizeof(struct mt_slot);
		if (input->flags & MT_TRACKING)
			size += MATRIX_SIZE(n);
		input->mt.num_slots = 0;
		free(input->mt.slots, M_DEVBUF, size);
		input->mt.slots = NULL;
		input->mt.matrix = NULL;
	}
}

/* Allocate the MT slots and, if necessary, the buffers for MT tracking. */
int
wsmouse_mt_init(struct device *sc, int num_slots, int tracking)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	int n, size;

	if (num_slots == input->mt.num_slots
	    && (!tracking == ((input->flags & MT_TRACKING) == 0)))
		return (0);

	free_mt_slots(input);

	if (tracking)
		input->flags |= MT_TRACKING;
	else
		input->flags &= ~MT_TRACKING;
	n = imin(imax(num_slots, 0), WSMOUSE_MT_SLOTS_MAX);
	if (n) {
		size = n * sizeof(struct mt_slot);
		if (input->flags & MT_TRACKING)
			size += MATRIX_SIZE(n);
		input->mt.slots = malloc(size, M_DEVBUF, M_WAITOK | M_ZERO);
		if (input->mt.slots != NULL) {
			if (input->flags & MT_TRACKING)
				input->mt.matrix = (int *)
				    (input->mt.slots + n);
			input->mt.num_slots = n;
			return (0);
		}
	}
	return (-1);
}

int
wsmouse_get_params(struct device *sc,
    struct wsmouse_param *params, u_int nparams)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	int i, key, error = 0;

	for (i = 0; i < nparams; i++) {
		key = params[i].key;
		switch (key) {
		case WSMOUSECFG_DX_SCALE:
			params[i].value = input->filter.h.scale;
			break;
		case WSMOUSECFG_DY_SCALE:
			params[i].value = input->filter.v.scale;
			break;
		case WSMOUSECFG_PRESSURE_LO:
			params[i].value = input->filter.pressure_lo;
			break;
		case WSMOUSECFG_PRESSURE_HI:
			params[i].value = input->filter.pressure_hi;
			break;
		case WSMOUSECFG_TRKMAXDIST:
			params[i].value = input->filter.tracking_maxdist;
			break;
		case WSMOUSECFG_SWAPXY:
			params[i].value = input->filter.swapxy;
			break;
		case WSMOUSECFG_X_INV:
			params[i].value = input->filter.h.inv;
			break;
		case WSMOUSECFG_Y_INV:
			params[i].value = input->filter.v.inv;
			break;
		case WSMOUSECFG_DX_MAX:
			params[i].value = input->filter.h.dmax;
			break;
		case WSMOUSECFG_DY_MAX:
			params[i].value = input->filter.v.dmax;
			break;
		case WSMOUSECFG_X_HYSTERESIS:
			params[i].value = input->filter.h.hysteresis;
			break;
		case WSMOUSECFG_Y_HYSTERESIS:
			params[i].value = input->filter.v.hysteresis;
			break;
		case WSMOUSECFG_DECELERATION:
			params[i].value = input->filter.dclr;
			break;
		default:
			error = wstpad_get_param(input, key, &params[i].value);
			if (error != 0)
				return (error);
			break;
		}
	}

	return (0);
}

int
wsmouse_set_params(struct device *sc,
    const struct wsmouse_param *params, u_int nparams)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	int i, val, key, needreset = 0, error = 0;

	for (i = 0; i < nparams; i++) {
		key = params[i].key;
		val = params[i].value;
		switch (params[i].key) {
		case WSMOUSECFG_PRESSURE_LO:
			input->filter.pressure_lo = val;
			if (val > input->filter.pressure_hi)
				input->filter.pressure_hi = val;
			input->touch.min_pressure = input->filter.pressure_hi;
			break;
		case WSMOUSECFG_PRESSURE_HI:
			input->filter.pressure_hi = val;
			if (val < input->filter.pressure_lo)
				input->filter.pressure_lo = val;
			input->touch.min_pressure = val;
			break;
		case WSMOUSECFG_X_HYSTERESIS:
			input->filter.h.hysteresis = val;
			input->filter.h.acc = 0;
			break;
		case WSMOUSECFG_Y_HYSTERESIS:
			input->filter.v.hysteresis = val;
			input->filter.v.acc = 0;
			break;
		case WSMOUSECFG_DECELERATION:
			input->filter.dclr = val;
			wstpad_init_deceleration(input);
			break;
		case WSMOUSECFG_DX_SCALE:
			input->filter.h.scale = val;
			break;
		case WSMOUSECFG_DY_SCALE:
			input->filter.v.scale = val;
			break;
		case WSMOUSECFG_TRKMAXDIST:
			input->filter.tracking_maxdist = val;
			break;
		case WSMOUSECFG_SWAPXY:
			input->filter.swapxy = val;
			break;
		case WSMOUSECFG_X_INV:
			input->filter.h.inv = val;
			break;
		case WSMOUSECFG_Y_INV:
			input->filter.v.inv = val;
			break;
		case WSMOUSECFG_DX_MAX:
			input->filter.h.dmax = val;
			break;
		case WSMOUSECFG_DY_MAX:
			input->filter.v.dmax = val;
			break;
		default:
			needreset = 1;
			error = wstpad_set_param(input, key, val);
			if (error != 0)
				return (error);
			break;
		}
	}

	/* Reset soft-states if touchpad parameters changed */
	if (needreset) {
		wstpad_reset(input);
		return (wstpad_configure(input));
	}

	return (0);
}

int
wsmouse_set_mode(struct device *sc, int mode)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;

	if (mode == WSMOUSE_COMPAT) {
		input->flags &= ~TPAD_NATIVE_MODE;
		input->flags |= TPAD_COMPAT_MODE;
		return (0);
	} else if (mode == WSMOUSE_NATIVE) {
		input->flags &= ~TPAD_COMPAT_MODE;
		input->flags |= TPAD_NATIVE_MODE;
		return (0);
	}
	return (-1);
}

struct wsmousehw *wsmouse_get_hw(struct device *sc)
{
	return &((struct wsmouse_softc *) sc)->sc_input.hw;
}

/*
 * Create a default configuration based on the hardware infos in the 'hw'
 * fields. The 'params' argument is optional, hardware drivers can use it
 * to modify the generic defaults. Up to now this function is only useful
 * for touchpads.
 */
int
wsmouse_configure(struct device *sc,
    struct wsmouse_param *params, u_int nparams)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->sc_input;
	int error;

	if (!(input->flags & CONFIGURED)) {
		if (input->hw.x_max && input->hw.y_max) {
			if (input->hw.flags & WSMOUSEHW_LR_DOWN) {
				input->filter.v.inv =
				    input->hw.y_max + input->hw.y_min;
			}
		}
		input->filter.ratio = 1 << 12;
		if (input->hw.h_res > 0 && input->hw.v_res > 0) {
			input->filter.ratio *= input->hw.h_res;
			input->filter.ratio /= input->hw.v_res;
		}
		if (wsmouse_mt_init(sc, input->hw.mt_slots,
		    (input->hw.flags & WSMOUSEHW_MT_TRACKING))) {
			printf("wsmouse_configure: "
			    "MT initialization failed.\n");
			return (-1);
		}
		if (IS_TOUCHPAD(input) && wstpad_configure(input)) {
			printf("wstpad_configure: "
			    "Initialization failed.\n");
			return (-1);
		}
		if (params != NULL) {
			if ((error = wsmouse_set_params(sc, params, nparams)))
				return (error);
		}
		input->flags |= CONFIGURED;
	}
	if (IS_TOUCHPAD(input))
		wsmouse_set_mode(sc, WSMOUSE_COMPAT);

	return (0);
}


void
wsmouse_input_reset(struct wsmouseinput *input)
{
	int num_slots, *matrix;
	struct mt_slot *slots;

	memset(&input->btn, 0, sizeof(struct btn_state));
	memset(&input->motion, 0, sizeof(struct motion_state));
	memset(&input->touch, 0, sizeof(struct touch_state));
	input->touch.min_pressure = input->filter.pressure_hi;
	if ((num_slots = input->mt.num_slots)) {
		slots = input->mt.slots;
		matrix = input->mt.matrix;
		memset(&input->mt, 0, sizeof(struct mt_state));
		memset(slots, 0, num_slots * sizeof(struct mt_slot));
		input->mt.num_slots = num_slots;
		input->mt.slots = slots;
		input->mt.matrix = matrix;
	}
	if (input->tp != NULL)
		wstpad_reset(input);
}

void
wsmouse_input_cleanup(struct wsmouseinput *input)
{
	free_mt_slots(input);
}
@


1.37
log
@Use 'inline' rather than _any of_ __the __other__ variants__.

ok bru@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.36 2017/02/27 15:59:56 bru Exp $ */
a175 31
static const size_t cfg_filter[] = {
	[WSMOUSECFG_DX_SCALE & 0xff] =
	    offsetof(struct wsmouseinput, filter.h.scale),
	[WSMOUSECFG_DY_SCALE & 0xff] =
	    offsetof(struct wsmouseinput, filter.v.scale),
	[WSMOUSECFG_PRESSURE_LO & 0xff] =
	    offsetof(struct wsmouseinput, filter.pressure_lo),
	[WSMOUSECFG_PRESSURE_HI & 0xff] =
	    offsetof(struct wsmouseinput, filter.pressure_hi),
	[WSMOUSECFG_TRKMAXDIST & 0xff] =
	    offsetof(struct wsmouseinput, filter.tracking_maxdist),
	[WSMOUSECFG_SWAPXY & 0xff] =
	    offsetof(struct wsmouseinput, filter.swapxy),
	[WSMOUSECFG_X_INV & 0xff] =
	    offsetof(struct wsmouseinput, filter.h.inv),
	[WSMOUSECFG_Y_INV & 0xff] =
	    offsetof(struct wsmouseinput, filter.v.inv),
	[WSMOUSECFG_DX_MAX & 0xff] =
	    offsetof(struct wsmouseinput, filter.h.dmax),
	[WSMOUSECFG_DY_MAX & 0xff] =
	    offsetof(struct wsmouseinput, filter.v.dmax),
	[WSMOUSECFG_X_HYSTERESIS & 0xff] =
	    offsetof(struct wsmouseinput, filter.h.hysteresis),
	[WSMOUSECFG_Y_HYSTERESIS & 0xff] =
	    offsetof(struct wsmouseinput, filter.v.hysteresis),
	[WSMOUSECFG_DECELERATION & 0xff] =
	    offsetof(struct wsmouseinput, filter.dclr),

	[WSMOUSECFG_FILTER_MAX & 0xff] = 0
};

d442 1
a442 1
	if (params == NULL || nparams > WSMOUSECFG_SIZE)
a1306 17
wsmouse_validate_keys(const struct wsmouse_param *params, u_int nparams)
{
	int i, k;

	if (params == NULL || nparams > WSMOUSECFG_SIZE)
		return (-1);
	for (i = 0; i < nparams; i++) {
		k = params[i].key;
		if (!IS_WSMOUSECFG_KEY(k)) {
			printf("wsmouse parameter: invalid key %d\n", k);
			return (-1);
		}
	}
	return (0);
}

int
d1311 1
a1311 5
	int i, key, delegate = 0;
	void *p;

	if (wsmouse_validate_keys(params, nparams))
		return (-1);
d1315 45
a1359 10
		if (WSMOUSECFG_MATCH(key, FILTER)) {
			p = input;
			p += cfg_filter[key & 0xff];
			if (p != input)
				params[i].value = *((int *) p);
			else
				printf("wsmouse_get_params: "
				    "ignoring key %d\n", key);
		} else {
			delegate = 1;
a1361 2
	if (delegate)
		return (wstpad_get_params(input, params, nparams));
d1371 1
a1371 5
	int i, key, val, delegate = 0;
	void *p;

	if (wsmouse_validate_keys(params, nparams))
		return (-1);
a1374 4
		if (!(WSMOUSECFG_MATCH(key, FILTER))) {
			delegate = 1;
			continue;
		}
d1376 1
a1376 1
		switch (key) {
d1381 2
a1382 3
			input->touch.min_pressure =
			    input->filter.pressure_hi;
			continue;
d1388 1
a1388 1
			continue;
d1392 1
a1392 1
			continue;
d1396 1
a1396 1
			continue;
d1400 25
a1424 1
			continue;
d1426 5
a1430 8
			p = input;
			p += cfg_filter[key & 0xff];
			if (p != input)
				*((int *) p) = val;
			else
				printf("wsmouse_set_params: "
				    "ignoring key %d\n", key);
			continue;
d1433 6
a1438 2
	if (delegate)
		return (wstpad_set_params(input, params, nparams));
d1476 1
d1501 4
a1504 2
		if (params != NULL)
			wsmouse_set_params(sc, params, nparams);
@


1.36
log
@Handle touchpad input in wsmouse.

The wstpad file contains the core of a touchpad-input driver that
is coupled with wsmouse. It is active in compat-mode if wsmouse has
been configured for it.

ok @@matthieu @@stsp @@mpi
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.35 2016/10/23 22:59:19 bru Exp $ */
d676 1
a676 1
static __inline int
d970 1
a970 1
static __inline int
d1037 1
a1037 1
static __inline void
d1287 1
a1287 1
static __inline void
@


1.35
log
@Improved parameter handling in wsmouse and new ioctls for reading and
setting parameter values.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.34 2016/08/18 21:12:35 bru Exp $ */
d112 1
a113 1
#include <dev/wscons/wseventvar.h>
d137 1
a137 1
	struct wsmouseinput input;
d176 1
a176 1
static const size_t cfg_fltr[] = {
d178 1
a178 1
	    offsetof(struct wsmouseinput, fltr.h.scale),
d180 1
a180 1
	    offsetof(struct wsmouseinput, fltr.v.scale),
d182 1
a182 1
	    offsetof(struct wsmouseinput, fltr.pressure_lo),
d184 1
a184 1
	    offsetof(struct wsmouseinput, fltr.pressure_hi),
d186 1
a186 1
	    offsetof(struct wsmouseinput, fltr.tracking_maxdist),
d188 1
a188 1
	    offsetof(struct wsmouseinput, fltr.swapxy),
d190 1
a190 1
	    offsetof(struct wsmouseinput, fltr.h.inv),
d192 1
a192 1
	    offsetof(struct wsmouseinput, fltr.v.inv),
d194 1
a194 1
	    offsetof(struct wsmouseinput, fltr.h.dmax),
d196 7
a202 1
	    offsetof(struct wsmouseinput, fltr.v.dmax),
d204 1
a204 1
	[WSMOUSECFG_FLTR_MAX & 0xff] = 0
d237 1
a237 1
	wsmouse_input_init(&sc->input, &sc->sc_base.me_evp);
d319 1
a319 1
	wsmouse_input_cleanup(&sc->input);
d413 1
a413 1
	wsmouse_input_reset(&sc->input);
d624 1
a624 2
	struct btn_state *btn =
	    &((struct wsmouse_softc *) sc)->input.btn;
d638 1
a638 1
	    &((struct wsmouse_softc *) sc)->input.motion;
d659 1
a659 1
	    &((struct wsmouse_softc *) sc)->input.motion;
d690 1
a690 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d704 1
d714 1
a714 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d760 1
a760 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d833 4
a836 4
		if (touch->pressure >= input->fltr.pressure_hi)
			touch->min_pressure = input->fltr.pressure_lo;
		else if (touch->pressure < input->fltr.pressure_lo)
			touch->min_pressure = input->fltr.pressure_hi;
d911 1
a911 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d954 1
a954 1
wsmouse_btn_sync(struct wsmouseinput *input, struct evq_access *evq)
a955 1
	struct btn_state *btn = &input->btn;
d987 2
a988 2
	struct axis_filter *h = &input->fltr.h;
	struct axis_filter *v = &input->fltr.v;
a1036 26
/*
 * Convert absolute touchpad input (compatibility mode).
 */
void
wsmouse_compat_convert(struct device *sc, struct evq_access *evq)
{
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
	struct axis_filter *h = &input->fltr.h;
	struct axis_filter *v = &input->fltr.v;
	int dx, dy, dz, dw;

	dx = (input->motion.sync & SYNC_X) ? input->motion.x_delta : 0;
	dy = (input->motion.sync & SYNC_Y) ? input->motion.y_delta : 0;
	dz = (input->motion.sync & SYNC_DELTAS) ? input->motion.dz : 0;
	dw = (input->motion.sync & SYNC_DELTAS) ? input->motion.dw : 0;

	if ((h->dmax && (abs(dx) > h->dmax))
	    || (v->dmax && (abs(dy) > v->dmax)))
		dx = dy = 0;

	wsmouse_motion(sc, dx, dy, dz, dw);

	input->motion.sync &= ~SYNC_POSITION;
	input->touch.sync = 0;
}

d1043 1
d1056 1
a1056 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d1079 1
a1079 1
		wsmouse_compat_convert(sc, &evq);
d1088 3
a1090 1
		wsmouse_btn_sync(input, &evq);
d1114 1
a1114 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d1139 1
a1139 1
 * at least 4m + 3n.
d1162 1
a1162 2
	int *alt = red + m;	/* alternative assignments */
	int *mc = alt + m;	/* row-wise minimal elements of cs */
d1168 1
a1168 1
	for (; p < alt; *p++ = 0) {}
d1183 1
a1183 2
		for (p = alt; p < mc; *p++ = -1) {}
		for (; p < cs; *p++ = col) {}
d1187 1
a1187 1
			alt[row] = mc[row];
d1190 1
a1190 1
				if (alt[i] < 0) {
d1212 1
a1212 1
			j = alt[row];
d1220 1
a1220 1
	struct wsmouseinput *input = &((struct wsmouse_softc *) sc)->input;
d1255 1
a1255 1
	maxdist = input->fltr.tracking_maxdist;
d1307 1
a1307 2
	struct wsmouseinput *input =
	    &((struct wsmouse_softc *) sc)->input;
d1358 1
a1358 2
	struct wsmouseinput *input =
	    &((struct wsmouse_softc *) sc)->input;
d1367 1
a1367 1
		if (WSMOUSECFG_MATCH(key, FLTR)) {
d1369 1
a1369 1
			p += cfg_fltr[key & 0xff];
d1380 1
a1380 1
		return (-1); /* not yet */
d1389 1
a1389 2
	struct wsmouseinput *input =
	    &((struct wsmouse_softc *) sc)->input;
d1398 1
a1398 1
		if (!(WSMOUSECFG_MATCH(key, FLTR))) {
d1405 3
a1407 3
			input->fltr.pressure_lo = val;
			if (val > input->fltr.pressure_hi)
				input->fltr.pressure_hi = val;
d1409 1
a1409 1
			    input->fltr.pressure_hi;
d1412 3
a1414 3
			input->fltr.pressure_hi = val;
			if (val < input->fltr.pressure_lo)
				input->fltr.pressure_lo = val;
d1417 12
d1431 1
a1431 1
			p += cfg_fltr[key & 0xff];
d1441 1
a1441 1
		return (-1); /* not yet */
d1449 1
a1449 2
	struct wsmouseinput *input =
	    &((struct wsmouse_softc *) sc)->input;
d1463 51
d1523 1
a1523 1
	input->touch.min_pressure = input->fltr.pressure_hi;
d1533 2
a1534 6
}

void
wsmouse_input_init(struct wsmouseinput *input, struct wseventvar **evar)
{
	input->evar = evar;
@


1.34
log
@Reset the input state completely when wsmouse is (re-)opened.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.33 2016/07/13 15:41:51 deraadt Exp $ */
d176 25
d461 35
d540 5
d827 4
a830 4
		if (touch->pressure >= input->params.pressure_hi)
			touch->min_pressure = input->params.pressure_lo;
		else if (touch->pressure < input->params.pressure_lo)
			touch->min_pressure = input->params.pressure_hi;
d982 2
a983 2
	struct wsmouseparams *params = &input->params;
	struct axis_filter *fltr;
d987 6
a992 8
		dx = params->x_inv ? -motion->dx : motion->dx;
		dy = params->y_inv ? -motion->dy : motion->dy;
		if (input->flags & SCALE_DELTAS) {
			fltr = &input->fltr.h;
			dx = scale(dx, fltr->scale, &fltr->rmdr);
			fltr = &input->fltr.v;
			dy = scale(dy, fltr->scale, &fltr->rmdr);
		}
d994 1
a994 1
			wsmouse_evq_put(evq, DELTA_X_EV(input->flags), dx);
d996 1
a996 1
			wsmouse_evq_put(evq, DELTA_Y_EV(input->flags), dy);
d1004 2
a1005 3
			x = (params->x_inv
			    ? params->x_inv - motion->x : motion->x);
			wsmouse_evq_put(evq, ABS_X_EV(input->flags), x);
d1008 2
a1009 3
			y = (params->y_inv
			    ? params->y_inv - motion->y : motion->y);
			wsmouse_evq_put(evq, ABS_Y_EV(input->flags), y);
d1039 2
a1040 1
	struct wsmouseparams *params = &input->params;
d1048 2
a1049 3
	if ((params->dx_max && abs(dx) > params->dx_max)
	    || (params->dy_max && abs(dy) > params->dy_max)) {

a1050 1
	}
d1275 1
a1275 1
	maxdist = input->params.tracking_maxdist;
d1358 2
a1359 2
void
wsmouse_init_scaling(struct wsmouseinput *input)
d1361 1
a1361 2
	struct wsmouseparams *params = &input->params;
	int m, n;
d1363 8
a1370 14
	if (params->dx_mul || params->dx_div
	    || params->dy_mul || params->dy_div) {
		/* Scale factors have a [*.12] fixed point format. */
		m = (params->dx_mul ? abs(params->dx_mul) : 1);
		n = (params->dx_div ? abs(params->dx_div) : 1);
		input->fltr.h.scale = (m << 12) / n;
		input->fltr.h.rmdr = 0;
		m = (params->dy_mul ? abs(params->dy_mul) : 1);
		n = (params->dy_div ? abs(params->dy_div): 1);
		input->fltr.v.scale = (m << 12) / n;
		input->fltr.v.rmdr = 0;
		input->flags |= SCALE_DELTAS;
	} else {
		input->flags &= ~SCALE_DELTAS;
d1372 1
d1375 3
a1377 2
void
wsmouse_set_param(struct device *sc, size_t param, int value)
d1381 5
a1385 2
	struct wsmouseparams *params = &input->params;
	int *p;
d1387 13
a1399 3
	if (param > WSMPARAM_LASTFIELD) {
		printf("wsmouse_set_param: invalid parameter type\n");
		return;
d1401 14
d1416 2
a1417 2
	p = (int *) (((void *) params) + param);
	*p = value;
d1419 31
a1449 15
	if (IS_WSMFLTR_PARAM(param)) {
		wsmouse_init_scaling(input);
	} else if (param == WSMPARAM_SWAPXY) {
		if (value)
			input->flags |= SWAPXY;
		else
			input->flags &= ~SWAPXY;
	} else if (param == WSMPARAM_PRESSURE_LO) {
		params->pressure_hi =
		    imax(params->pressure_lo, params->pressure_hi);
		input->touch.min_pressure = params->pressure_hi;
	} else if (param == WSMPARAM_PRESSURE_HI
	    && params->pressure_lo == 0) {
		params->pressure_lo = params->pressure_hi;
		input->touch.min_pressure = params->pressure_hi;
d1451 4
d1484 1
a1484 1
	input->touch.min_pressure = input->params.pressure_hi;
@


1.33
log
@remove <0 check for an unsigned variable
from tom
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.32 2016/07/12 22:02:53 bru Exp $ */
d382 2
d1271 4
a1275 1
	memset(&input->mt, 0, sizeof(struct mt_state));
d1371 21
@


1.32
log
@Reset the mt state completely in wsmouse_mt_init.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.31 2016/07/05 19:33:14 bru Exp $ */
d1324 1
a1324 1
	if (param < 0 || param > WSMPARAM_LASTFIELD) {
@


1.31
log
@Improve the tracking functions in wsmouse.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.30 2016/06/06 22:32:47 bru Exp $ */
a1268 4
	if (num_slots == input->mt.num_slots
	    && (!tracking == ((input->flags & MT_TRACKING) == 0)))
		return (0);

d1270 1
@


1.30
log
@Remove wsmouse_input.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.29 2016/03/30 23:34:12 bru Exp $ */
d1128 3
a1130 2
		for (i = 0, p = matrix + col; i < m; i++, p += n)
			if ((d = *p - red[i]) <= delta) {
d1134 1
d1156 2
a1157 1
					if (d <= delta) {
@


1.29
log
@Add support for multitouch input to wsmouse.

This change adds new input-processing functions to wsmouse and
adapts the touchpad drivers.

ok mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.28 2015/09/10 18:14:52 mpi Exp $ */
d75 16
a130 5
#define	INVALID_X	INT_MAX
#define	INVALID_Y	INT_MAX
#define	INVALID_Z	INT_MAX
#define	INVALID_W	INT_MAX

a136 11
	u_int		sc_mb;		/* mouse button state */
	u_int		sc_ub;		/* user button state */
	int		sc_dx;		/* delta-x */
	int		sc_dy;		/* delta-y */
	int		sc_dz;		/* delta-z */
	int		sc_dw;		/* delta-w */
	int		sc_x;		/* absolute-x */
	int		sc_y;		/* absolute-y */
	int		sc_z;		/* absolute-z */
	int		sc_w;		/* absolute-w */

a292 194
void
wsmouse_input(struct device *wsmousedev, u_int btns, /* 0 is up */
    int x, int y, int z, int w, u_int flags)
{
	struct wsmouse_softc *sc = (struct wsmouse_softc *)wsmousedev;
	struct wscons_event *ev;
	struct wseventvar *evar;
	int mb, ub, d, get, put, any;

	add_mouse_randomness(x ^ y ^ z ^ w ^ btns);

	/*
	 * Discard input if not ready.
	 */
	evar = sc->sc_base.me_evp;
	if (evar == NULL)
		return;

#ifdef DIAGNOSTIC
	if (evar->q == NULL) {
		printf("wsmouse_input: evar->q=NULL\n");
		return;
	}
#endif

#if NWSMUX > 0
	DPRINTFN(5,("wsmouse_input: %s mux=%p, evar=%p\n",
		    sc->sc_base.me_dv.dv_xname, sc->sc_base.me_parent, evar));
#endif

	sc->sc_mb = btns;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_X))
		sc->sc_dx += x;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_Y))
		sc->sc_dy += y;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_Z))
		sc->sc_dz += z;
	if (!(flags & WSMOUSE_INPUT_ABSOLUTE_W))
		sc->sc_dw += w;

	/*
	 * We have at least one event (mouse button, delta-X, or
	 * delta-Y; possibly all three, and possibly three separate
	 * button events).  Deliver these events until we are out
	 * of changes or out of room.  As events get delivered,
	 * mark them `unchanged'.
	 */
	ub = sc->sc_ub;
	any = 0;
	get = evar->get;
	put = evar->put;
	ev = &evar->q[put];

	/* NEXT prepares to put the next event, backing off if necessary */
#define	NEXT								\
	if ((++put) % WSEVENT_QSIZE == get) {				\
		put--;							\
		goto out;						\
	}
	/* ADVANCE completes the `put' of the event */
#define	ADVANCE								\
	ev++;								\
	if (put >= WSEVENT_QSIZE) {					\
		put = 0;						\
		ev = &evar->q[0];				\
	}								\
	any = 1
	/* TIMESTAMP sets `time' field of the event to the current time */
#define TIMESTAMP							\
	do {								\
		getnanotime(&ev->time);					\
	} while (0)

	if (flags & WSMOUSE_INPUT_ABSOLUTE_X) {
		if (sc->sc_x != x) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_X;
			ev->value = x;
			TIMESTAMP;
			ADVANCE;
			sc->sc_x = x;
		}
	} else {
		if (sc->sc_dx) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_X;
			ev->value = sc->sc_dx;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dx = 0;
		}
	}
	if (flags & WSMOUSE_INPUT_ABSOLUTE_Y) {
		if (sc->sc_y != y) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Y;
			ev->value = y;
			TIMESTAMP;
			ADVANCE;
			sc->sc_y = y;
		}
	} else {
		if (sc->sc_dy) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_Y;
			ev->value = sc->sc_dy;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dy = 0;
		}
	}
	if (flags & WSMOUSE_INPUT_ABSOLUTE_Z) {
		if (sc->sc_z != z) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_Z;
			ev->value = z;
			TIMESTAMP;
			ADVANCE;
			sc->sc_z = z;
		}
	} else {
		if (sc->sc_dz) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_Z;
			ev->value = sc->sc_dz;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dz = 0;
		}
	}
	if (flags & WSMOUSE_INPUT_ABSOLUTE_W) {
		if (sc->sc_w != w) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_ABSOLUTE_W;
			ev->value = w;
			TIMESTAMP;
			ADVANCE;
			sc->sc_w = w;
		}
	} else {
		if (sc->sc_dw) {
			NEXT;
			ev->type = WSCONS_EVENT_MOUSE_DELTA_W;
			ev->value = sc->sc_dw;
			TIMESTAMP;
			ADVANCE;
			sc->sc_dw = 0;
		}
	}

	mb = sc->sc_mb;
	while ((d = mb ^ ub) != 0) {
		/*
		 * Mouse button change.  Find the first change and drop
		 * it into the event queue.
		 */
		NEXT;
		ev->value = ffs(d) - 1;

		KASSERT(ev->value >= 0);

		d = 1 << ev->value;
		ev->type =
		    (mb & d) ? WSCONS_EVENT_MOUSE_DOWN : WSCONS_EVENT_MOUSE_UP;
		TIMESTAMP;
		ADVANCE;
		ub ^= d;
	}

	NEXT;
	ev->type = WSCONS_EVENT_SYNC;
	ev->value = 0;
	TIMESTAMP;
	ADVANCE;

#undef	TIMESTAMP
#undef	ADVANCE
#undef	NEXT

out:
	if (any) {
		sc->sc_ub = ub;
		evar->put = put;
		WSEVENT_WAKEUP(evar);
#ifdef HAVE_BURNER_SUPPORT
		/* wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_MOUSE); */
#endif
#if NWSMUX > 0
		DPRINTFN(5,("wsmouse_input: %s wakeup evar=%p\n",
			    sc->sc_base.me_dv.dv_xname, evar));
#endif
	}
}

a380 4
	sc->sc_x = INVALID_X;
	sc->sc_y = INVALID_Y;
	sc->sc_z = INVALID_Z;
	sc->sc_w = INVALID_W;
a546 1

@


1.28
log
@kqueue(2) support for wsmouse(4), wskbd(4) and wsmux(4).

Needed for libinput port.

ok guenther@@, miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.27 2015/03/14 03:38:50 jsg Exp $ */
d91 1
d96 1
d137 2
d206 2
d288 2
d745 833
@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.26 2014/10/27 13:55:05 mpi Exp $ */
d687 10
@


1.26
log
@Stop supporting wsmoused and X in parallel.  This code is racy and
known to break mice upon resume.

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.25 2013/10/30 18:00:57 shadchin Exp $ */
a95 1
#include <dev/wscons/wsdisplayvar.h>
@


1.25
log
@Fix jagged diagonal lines (kernel part)

Send WSCONS_EVENT_SYNC every time you call wsmouse_input(). Used to synchronize
and separate events into packets of input data changes occurring at the same
moment in time. For example, motion of a mouse may set the DELTA_X and DELTA_Y
values for one motion, then emit a SYNC.

ok matthieu@@. tested edd@@, Henri Kemppainen and Alf Schlichting.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.24 2013/10/18 13:54:09 miod Exp $ */
a459 9

	/* XXX fake wscons_event notifying wsmoused(8) to close mouse device */
	if (flags & WSMOUSE_INPUT_WSMOUSED_CLOSE) {
		NEXT;
		ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
		ev->value = 0;
		TIMESTAMP;
		ADVANCE;
	}
@


1.24
log
@Introduce a dedicated private header file to control the optional features
of wscons (which usually get disabled for installation kernels, to save
space), instead of duplicating parts of it to too many places.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.23 2012/07/22 18:28:36 shadchin Exp $ */
d455 5
a459 7
	if (flags & WSMOUSE_INPUT_SYNC) {
		NEXT;
		ev->type = WSCONS_EVENT_SYNC;
		ev->value = 0;
		TIMESTAMP;
		ADVANCE;
	}
@


1.23
log
@Fix for ClickPad. On issue pointed gilles@@ and matthieu@@

ok gilles@@, matthieu@@, mpi@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.22 2011/08/17 16:10:27 shadchin Exp $ */
a77 4
#ifndef	SMALL_KERNEL
#define	BURNER_SUPPORT
#endif

d92 1
d481 1
a481 1
#ifdef BURNER_SUPPORT
@


1.22
log
@Adding support Synaptics touchpad. Thanks all for test.

ok miod@@, matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.21 2010/07/26 01:56:27 guenther Exp $ */
d456 8
@


1.21
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.20 2009/10/13 19:33:19 pirofti Exp $ */
d510 8
d551 15
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.19 2007/04/10 22:37:17 miod Exp $ */
d515 1
a515 1
	evar->io = p;
d641 2
a642 2
		if (-*(int *)data != sc->sc_base.me_evp->io->p_pgid
		    && *(int *)data != sc->sc_base.me_evp->io->p_pid)
d649 1
a649 1
		if (*(int *)data != sc->sc_base.me_evp->io->p_pgid)
@


1.19
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.18 2006/11/01 03:37:24 tedu Exp $ */
d146 1
a146 1
int	wsmouse_activate(struct device *, enum devact);
d227 1
a227 1
wsmouse_activate(struct device *self, enum devact act)
@


1.18
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.17 2005/08/14 11:00:15 miod Exp $ */
d120 1
d133 1
d137 1
d291 1
a291 1
    int x, int y, int z, u_int flags)
d298 1
a298 1
	add_mouse_randomness(x ^ y ^ z ^ btns);
d326 2
d419 19
d554 1
@


1.17
log
@Honor (the lack of) FWRITE in the various ioctl routines; with input from
fgs@@ and mickey@@; ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.16 2005/06/01 18:50:30 miod Exp $ */
d94 1
d644 1
a644 1
		return (EINVAL);
@


1.16
log
@Do not kill the event sink when closing a wsmouse device opened in write-only
mode, thus only been used to issue ioctls.

This chunk was lost in r1.14; reported by Douglas Santos.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.15 2005/05/18 21:31:27 miod Exp $ */
d593 9
@


1.15
log
@Do not compile the screen burner code if SMALL_KERNEL, helps floppies.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.14 2005/05/15 11:29:15 miod Exp $ */
d508 3
@


1.14
log
@Partial sync to the NetBSD wscons code, bringing a better wsmux behaviour
and bugfixes (the kqueue code, /dev/wsmuxctl and screen border color changes
have not been picked), keeping local changes.

Tested by many on alpha/cats/hp300/i386/macppc/sparc/sparc64/zaurus if not more.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.13 2004/06/24 19:35:24 tholo Exp $ */
a33 2
#include <sys/cdefs.h>

d78 4
d451 1
d453 1
@


1.13
log
@This moves access to wall and uptime variables in MI code,
encapsulating all such access into wall-defined functions
that makes sure locking is done as needed.

It also cleans up some uses of wall time vs. uptime some
places, but there is sure to be more of these needed as
well, particularily in MD code.  Also, many current calls
to microtime() should probably be changed to getmicrotime(),
or to the {,get}microuptime() versions.

ok art@@ deraadt@@ aaron@@ matthieu@@ beck@@ sturm@@ millert@@ others
"Oh, that is not your problem!" from miod@@
@
text
@d1 2
a2 2
/* $OpenBSD: wsmouse.c,v 1.12 2003/09/23 16:51:12 millert Exp $ */
/* $NetBSD: wsmouse.c,v 1.12 2000/05/01 07:36:58 takemura Exp $ */
a98 1
#include "wsmouse.h"
a102 1
#if NWSMUX > 0
d104 8
d119 1
a119 1
	struct device	sc_dv;
a123 3
	int		sc_ready;	/* accepting events */
	struct wseventvar sc_events;	/* event queue state */

a134 4

#if NWSMUX > 0
	struct wsmux_softc *sc_mux;
#endif
d145 5
a149 1
int	wsmousedoclose(struct device *, int, int, struct proc *);
d152 1
a162 4
#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

d164 3
a166 2
struct wsmuxops wsmouse_muxops = {
	wsmouseopen, wsmousedoclose, wsmousedoioctl, 0, 0, 0
d174 1
a174 3
wsmousedevprint(aux, pnp)
	void *aux;
	const char *pnp;
d183 1
a183 4
wsmouse_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d189 1
a189 3
wsmouse_attach(parent, self, aux)
        struct device *parent, *self;
	void *aux;
d191 1
a191 1
        struct wsmouse_softc *sc = (struct wsmouse_softc *)self;
d194 1
a194 1
	int mux;
a198 1
	sc->sc_ready = 0;				/* sanity */
d201 8
a208 5
	mux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux != WSMOUSEDEVCF_MUX_DEFAULT) {
		wsmux_attach(mux, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events,
			     &sc->sc_mux, &wsmouse_muxops);
		printf(" mux %d", mux);
d210 4
d215 1
d221 1
a221 3
wsmouse_activate(self, act)
	struct device *self;
	enum devact act;
d223 4
a226 1
	/* XXX should we do something more? */
d239 1
a239 3
wsmouse_detach(self, flags)
	struct device  *self;
	int flags;
a244 5
#if NWSMUX > 0
	int mux;
#endif

	sc->sc_dying = 1;
d247 5
a251 3
	mux = sc->sc_dv.dv_cfdata->wsmousedevcf_mux;
	if (mux != WSMOUSEDEVCF_MUX_DEFAULT)
		wsmux_detach(mux, &sc->sc_dv);
d254 3
a256 2
	evar = &sc->sc_events;
	if (evar->io) {
d266 1
a266 1
				       sc->sc_dv.dv_xname);
d284 2
a285 5
wsmouse_input(wsmousedev, btns, x, y, z, flags)
	struct device *wsmousedev;
	u_int btns;			/* 0 is up */
	int x, y, z;
	u_int flags;
d292 7
a298 4
        /*
         * Discard input if not ready.
         */
	if (sc->sc_ready == 0)
d301 6
a306 1
	add_mouse_randomness(x ^ y ^ z ^ btns);
d309 2
a310 3
	if (sc->sc_mux)
		evar = &sc->sc_mux->sc_events;
	else
a311 1
		evar = &sc->sc_events;
d433 5
a437 5
			NEXT;
			ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
			ev->value = 0;
			TIMESTAMP;
			ADVANCE;
d440 4
d450 4
d458 1
a458 4
wsmouseopen(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
a459 1
#if NWSMOUSE > 0
d461 1
d469 5
d481 1
a481 6
#if NWSMUX > 0
	if (sc->sc_mux)
		return (EBUSY);
#endif

	if (sc->sc_events.io)			/* and that it's not in use */
d484 3
a486 7
	sc->sc_events.io = p;
	wsevent_init(&sc->sc_events);		/* may cause sleep */

	sc->sc_ready = 1;			/* start accepting events */
	sc->sc_x = INVALID_X;
	sc->sc_y = INVALID_Y;
	sc->sc_z = INVALID_Z;
d488 1
a488 2
	/* enable the device, and punt if that's not possible */
	error = (*sc->sc_accessops->enable)(sc->sc_accesscookie);
d490 4
a493 4
		sc->sc_ready = 0;		/* stop accepting events */
		wsevent_fini(&sc->sc_events);
		sc->sc_events.io = NULL;
		return (error);
d495 1
a495 5

	return (0);
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
d499 1
a499 4
wsmouseclose(dev, flags, mode, p)
	dev_t dev;
	int flags, mode;
	struct proc *p;
d501 12
a512 6
#if NWSMOUSE > 0
	return (wsmousedoclose(wsmouse_cd.cd_devs[minor(dev)], 
			       flags, mode, p));
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
a514 1
#if NWSMOUSE > 0
d516 1
a516 4
wsmousedoclose(dv, flags, mode, p)
	struct device *dv;
	int flags, mode;
	struct proc *p;
d518 4
a521 1
	struct wsmouse_softc *sc = (struct wsmouse_softc *)dv;
d523 2
a524 9
	if ((flags & (FREAD | FWRITE)) == FWRITE)
		return (0);			/* see wsmouseopen() */

	(*sc->sc_accessops->disable)(sc->sc_accesscookie);

	sc->sc_ready = 0;			/* stop accepting events */
	wsevent_fini(&sc->sc_events);
	sc->sc_events.io = NULL;
	return (0);
a525 1
#endif /* NWSMOUSE > 0 */
d528 1
a528 4
wsmouseread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
a529 1
#if NWSMOUSE > 0
d536 7
d544 1
a544 1
	error = wsevent_read(&sc->sc_events, uio, flags);
a549 3
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
d553 1
a553 6
wsmouseioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
a554 1
#if NWSMOUSE > 0
d556 1
a556 4
			       cmd, data, flag, p));
#else
	return (ENXIO);
#endif /* NWSMOUSE > 0 */
a558 1
#if NWSMOUSE > 0
d561 2
a562 6
wsmousedoioctl(dv, cmd, data, flag, p)
	struct device *dv;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d575 2
a576 6
wsmouse_do_ioctl(sc, cmd, data, flag, p)
	struct wsmouse_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d591 11
a601 1
		sc->sc_events.async = *(int *)data != 0;
d605 3
a607 1
		if (*(int *)data != sc->sc_events.io->p_pgid)
a619 1
#endif /* NWSMOUSE > 0 */
d622 1
a622 4
wsmousepoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
a623 1
#if NWSMOUSE > 0
d626 3
a628 4
	return (wsevent_poll(&sc->sc_events, events, p));
#else
	return (0);
#endif /* NWSMOUSE > 0 */
d633 1
a633 3
wsmouse_add_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
d635 7
a641 1
	struct wsmouse_softc *sc;
d643 4
a646 3
	if (unit < 0 || unit >= wsmouse_cd.cd_ndevs ||
	    (sc = wsmouse_cd.cd_devs[unit]) == NULL)
		return (ENXIO);
d648 2
a649 2
	if (sc->sc_mux || sc->sc_events.io)
		return (EBUSY);
d651 1
a651 2
	return (wsmux_attach_sc(muxsc, WSMUX_MOUSE, &sc->sc_dv, &sc->sc_events, 
				&sc->sc_mux, &wsmouse_muxops));
d655 1
a655 3
wsmouse_rem_mux(unit, muxsc)
	int unit;
	struct wsmux_softc *muxsc;
d663 4
a666 1
	return (wsmux_detach_sc(muxsc, &sc->sc_dv));
d668 1
a668 2

#endif
@


1.12
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.11 2003/06/02 23:28:04 millert Exp $ */
d350 1
a350 4
		int s;							\
		s = splhigh();						\
		TIMEVAL_TO_TIMESPEC(&time, &ev->time);			\
		splx(s);						\
@


1.11
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.10 2002/04/30 23:01:55 mickey Exp $ */
d641 1
a641 1
wsmouseselect(dev, events, p)
@


1.10
log
@cdev_decl is done in conf.h, do not dupe here
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.9 2002/03/27 18:54:09 jbm Exp $ */
d57 1
a57 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.9
log
@Add X-Window support to wsmoused(8). This allows running wsmoused(8) and
X-Window at the same time, removing the need to kill wsmoused(8) before
starting X-Window.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.8 2002/03/14 01:27:03 millert Exp $ */
a165 2

cdev_decl(wsmouse);
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.7 2001/10/04 19:37:52 mickey Exp $ */
d438 10
@


1.7
log
@supply entropy from here
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.6 2001/05/08 22:28:43 mickey Exp $ */
d142 11
a152 11
int	wsmouse_match __P((struct device *, void *, void *));
void	wsmouse_attach __P((struct device *, struct device *, void *));
int	wsmouse_detach __P((struct device *, int));
int	wsmouse_activate __P((struct device *, enum devact));

int	wsmouse_do_ioctl __P((struct wsmouse_softc *, u_long, caddr_t, 
			      int, struct proc *));

int	wsmousedoclose __P((struct device *, int, int, struct proc *));
int	wsmousedoioctl __P((struct device *, u_long, caddr_t, int, 
			    struct proc *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.7 2001/10/04 19:37:52 mickey Exp $ */
d142 11
a152 11
int	wsmouse_match(struct device *, void *, void *);
void	wsmouse_attach(struct device *, struct device *, void *);
int	wsmouse_detach(struct device *, int);
int	wsmouse_activate(struct device *, enum devact);

int	wsmouse_do_ioctl(struct wsmouse_softc *, u_long, caddr_t, 
			      int, struct proc *);

int	wsmousedoclose(struct device *, int, int, struct proc *);
int	wsmousedoioctl(struct device *, u_long, caddr_t, int, 
			    struct proc *);
d167 2
a437 10

	/* XXX fake wscons_event notifying wsmoused(8) to close mouse device */
	if (flags & WSMOUSE_INPUT_WSMOUSED_CLOSE) {
			NEXT;
			ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
			ev->value = 0;
			TIMESTAMP;
			ADVANCE;
	}

@


1.6
log
@inplement screen burner in screenblank(1) style (no program though).
disabled by default, also supports vsync blanking, disabled by default.
aaron@@ looked at it a while back and i fixed problems he had indicated.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.5 2001/03/30 16:38:14 aaron Exp $ */
d101 1
d308 2
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d100 1
d440 1
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.6.2.1 2001/05/14 22:26:32 niklas Exp $ */
a99 1
#include <dev/wscons/wsdisplayvar.h>
a438 1
		/* wsdisplay_burn(sc->sc_displaydv, WSDISPLAY_BURN_MOUSE); */
@


1.6.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.6.2.2 2001/07/04 10:44:13 niklas Exp $ */
a100 1
#include <dev/rndvar.h>
a306 2

	add_mouse_randomness(x ^ y ^ z ^ btns);
@


1.6.2.4
log
@Merge in -current from roughly a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d142 11
a152 11
int	wsmouse_match(struct device *, void *, void *);
void	wsmouse_attach(struct device *, struct device *, void *);
int	wsmouse_detach(struct device *, int);
int	wsmouse_activate(struct device *, enum devact);

int	wsmouse_do_ioctl(struct wsmouse_softc *, u_long, caddr_t, 
			      int, struct proc *);

int	wsmousedoclose(struct device *, int, int, struct proc *);
int	wsmousedoioctl(struct device *, u_long, caddr_t, int, 
			    struct proc *);
@


1.6.2.5
log
@Sync the SMP branch with 3.3
@
text
@d167 2
a437 10

	/* XXX fake wscons_event notifying wsmoused(8) to close mouse device */
	if (flags & WSMOUSE_INPUT_WSMOUSED_CLOSE) {
			NEXT;
			ev->type = WSCONS_EVENT_WSMOUSED_CLOSE;
			ev->value = 0;
			TIMESTAMP;
			ADVANCE;
	}

@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.6.2.5 2003/03/28 00:38:33 niklas Exp $ */
d57 5
a61 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d641 1
a641 1
wsmousepoll(dev, events, p)
@


1.5
log
@Add a new wsmuxop, dissetdisplay, which wsmux uses to disocver whether a mux
device is connected to a display or not. Use it in wsmux_detach_sc(). This
fixes a problem I've been struggling with whereby the machine panics if I
detach a USB keyboard before disconnecting it from wsdisplay.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.4 2001/02/18 15:18:49 aaron Exp $ */
d100 1
d440 1
@


1.4
log
@Fix an uninitialized variable which could cause corruption of the user
button state (and hence spurious mouse clicks) if the event queue filled
up; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.3 2001/01/30 19:51:43 aaron Exp $ */
d169 1
a169 1
	wsmouseopen, wsmousedoclose, wsmousedoioctl, 0, 0
@


1.3
log
@Pass the correct MUX type to wsmux_attach_sc().
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.2 2000/08/01 13:51:18 mickey Exp $ */
d329 1
a416 1
	ub = sc->sc_ub;
@


1.2
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsmouse.c,v 1.1 2000/05/16 23:49:12 mickey Exp $ */
d661 1
a661 1
	return (wsmux_attach_sc(muxsc, WSMUX_KBD, &sc->sc_dv, &sc->sc_events, 
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 2
a2 2
/* $OpenBSD$ */
/* $NetBSD: wsmouse.c,v 1.11 2000/01/08 02:57:24 takemura Exp $ */
d140 1
a140 1
int	wsmouse_match __P((struct device *, struct cfdata *, void *));
d157 1
a157 1
	sizeof (struct wsmouse_softc), (cfmatch_t)wsmouse_match, wsmouse_attach,
d161 4
d190 1
a190 1
	struct cfdata *match;
a192 1

@

