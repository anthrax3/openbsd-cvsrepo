head	1.129;
access;
symbols
	OPENBSD_6_1:1.126.0.4
	OPENBSD_6_1_BASE:1.126
	OPENBSD_6_0:1.124.0.4
	OPENBSD_6_0_BASE:1.124
	OPENBSD_5_9:1.124.0.2
	OPENBSD_5_9_BASE:1.124
	OPENBSD_5_8:1.123.0.4
	OPENBSD_5_8_BASE:1.123
	OPENBSD_5_7:1.121.0.4
	OPENBSD_5_7_BASE:1.121
	OPENBSD_5_6:1.119.0.4
	OPENBSD_5_6_BASE:1.119
	OPENBSD_5_5:1.117.0.4
	OPENBSD_5_5_BASE:1.117
	OPENBSD_5_4:1.112.0.2
	OPENBSD_5_4_BASE:1.112
	OPENBSD_5_3:1.106.0.4
	OPENBSD_5_3_BASE:1.106
	OPENBSD_5_2:1.106.0.2
	OPENBSD_5_2_BASE:1.106
	OPENBSD_5_1_BASE:1.105
	OPENBSD_5_1:1.105.0.4
	OPENBSD_5_0:1.105.0.2
	OPENBSD_5_0_BASE:1.105
	OPENBSD_4_9:1.103.0.2
	OPENBSD_4_9_BASE:1.103
	OPENBSD_4_8:1.102.0.2
	OPENBSD_4_8_BASE:1.102
	OPENBSD_4_7:1.97.0.2
	OPENBSD_4_7_BASE:1.97
	OPENBSD_4_6:1.92.0.4
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.89.0.2
	OPENBSD_4_5_BASE:1.89
	OPENBSD_4_4:1.86.0.2
	OPENBSD_4_4_BASE:1.86
	OPENBSD_4_3:1.85.0.2
	OPENBSD_4_3_BASE:1.85
	OPENBSD_4_2:1.81.0.2
	OPENBSD_4_2_BASE:1.81
	OPENBSD_4_1:1.77.0.2
	OPENBSD_4_1_BASE:1.77
	OPENBSD_4_0:1.69.0.2
	OPENBSD_4_0_BASE:1.69
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.63.0.2
	OPENBSD_3_8_BASE:1.63
	OPENBSD_3_7:1.56.0.2
	OPENBSD_3_7_BASE:1.56
	OPENBSD_3_6:1.53.0.4
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.53
	SMP_SYNC_B:1.53
	OPENBSD_3_5:1.53.0.2
	OPENBSD_3_5_BASE:1.53
	OPENBSD_3_4:1.50.0.4
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.50
	OPENBSD_3_3:1.50.0.2
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.48.0.2
	OPENBSD_3_2_BASE:1.48
	OPENBSD_3_1:1.42.0.2
	OPENBSD_3_1_BASE:1.42
	UBC_SYNC_B:1.49
	UBC:1.36.0.2
	UBC_BASE:1.36
	OPENBSD_3_0:1.34.0.2
	OPENBSD_3_0_BASE:1.34
	SMP:1.26.0.2
	OPENBSD_2_9_BASE:1.24
	OPENBSD_2_9:1.24.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6;
locks; strict;
comment	@ * @;


1.129
date	2017.07.19.20.12.54;	author kettenis;	state Exp;
branches;
next	1.128;
commitid	meqQg0akqN2lKP5x;

1.128
date	2017.07.19.14.34.10;	author kettenis;	state Exp;
branches;
next	1.127;
commitid	es0BDttRZ5dMyViE;

1.127
date	2017.07.18.21.27.50;	author kettenis;	state Exp;
branches;
next	1.126;
commitid	cVVuPTIjf2KLfCgB;

1.126
date	2017.01.11.08.21.33;	author fcambus;	state Exp;
branches
	1.126.4.1;
next	1.125;
commitid	TnqkAW95HF7ac1nP;

1.125
date	2016.11.07.00.26.33;	author guenther;	state Exp;
branches;
next	1.124;
commitid	W7ztnDZwvjCaeQTS;

1.124
date	2015.09.08.11.13.20;	author deraadt;	state Exp;
branches
	1.124.4.1;
next	1.123;
commitid	cepoHqLZxiNNy2Sr;

1.123
date	2015.05.08.19.17.20;	author miod;	state Exp;
branches;
next	1.122;
commitid	vlfEvW95SxPChTvc;

1.122
date	2015.05.07.00.16.25;	author jsg;	state Exp;
branches;
next	1.121;
commitid	pwvFWduUBypr4qPJ;

1.121
date	2014.10.27.13.55.05;	author mpi;	state Exp;
branches;
next	1.120;
commitid	wJzi0sga39BzYaSt;

1.120
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.119;
commitid	uzzBR7hz9ncd4O6G;

1.119
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.118;
commitid	OBNa5kfxQ2UXoiIw;

1.118
date	2014.05.14.18.11.24;	author shadchin;	state Exp;
branches;
next	1.117;

1.117
date	2013.11.04.05.45.04;	author miod;	state Exp;
branches;
next	1.116;

1.116
date	2013.10.20.21.24.01;	author miod;	state Exp;
branches;
next	1.115;

1.115
date	2013.10.20.13.20.14;	author miod;	state Exp;
branches;
next	1.114;

1.114
date	2013.10.18.22.06.41;	author miod;	state Exp;
branches;
next	1.113;

1.113
date	2013.10.18.13.54.08;	author miod;	state Exp;
branches;
next	1.112;

1.112
date	2013.07.06.14.35.45;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2013.07.05.21.18.32;	author kettenis;	state Exp;
branches;
next	1.110;

1.110
date	2013.06.15.21.35.15;	author kettenis;	state Exp;
branches;
next	1.109;

1.109
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2013.05.12.20.41.45;	author kettenis;	state Exp;
branches;
next	1.107;

1.107
date	2013.03.10.13.40.28;	author kettenis;	state Exp;
branches;
next	1.106;

1.106
date	2012.07.13.12.37.08;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2011.07.03.18.11.21;	author nicm;	state Exp;
branches;
next	1.104;

1.104
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.103;

1.103
date	2010.11.20.20.52.10;	author miod;	state Exp;
branches;
next	1.102;

1.102
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.101;

1.101
date	2010.07.01.02.33.05;	author maja;	state Exp;
branches;
next	1.100;

1.100
date	2010.06.28.14.13.35;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.98;

1.98
date	2010.03.30.17.40.55;	author oga;	state Exp;
branches;
next	1.97;

1.97
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.31.14.13.57;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.94;

1.94
date	2009.09.14.04.10.42;	author miod;	state Exp;
branches;
next	1.93;

1.93
date	2009.09.05.14.30.24;	author miod;	state Exp;
branches;
next	1.92;

1.92
date	2009.05.31.17.02.20;	author miod;	state Exp;
branches;
next	1.91;

1.91
date	2009.05.31.16.57.34;	author miod;	state Exp;
branches;
next	1.90;

1.90
date	2009.05.31.16.56.10;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2009.01.10.23.02.47;	author miod;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.10.17.46.04;	author miod;	state Exp;
branches;
next	1.87;

1.87
date	2008.10.06.18.31.02;	author miod;	state Exp;
branches;
next	1.86;

1.86
date	2008.06.07.20.34.36;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2008.01.23.16.37.55;	author jsing;	state Exp;
branches;
next	1.84;

1.84
date	2007.11.26.16.56.41;	author miod;	state Exp;
branches;
next	1.83;

1.83
date	2007.11.25.19.11.42;	author miod;	state Exp;
branches;
next	1.82;

1.82
date	2007.11.24.16.45.59;	author miod;	state Exp;
branches;
next	1.81;

1.81
date	2007.07.25.23.11.52;	author art;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.78;

1.78
date	2007.03.24.16.01.22;	author art;	state Exp;
branches;
next	1.77;

1.77
date	2007.03.07.06.23.04;	author miod;	state Exp;
branches;
next	1.76;

1.76
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2007.01.07.13.28.04;	author miod;	state Exp;
branches;
next	1.74;

1.74
date	2006.12.02.18.16.14;	author miod;	state Exp;
branches;
next	1.73;

1.73
date	2006.11.29.19.12.53;	author miod;	state Exp;
branches;
next	1.72;

1.72
date	2006.11.29.19.11.17;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2006.11.29.12.13.55;	author miod;	state Exp;
branches;
next	1.70;

1.70
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.69;

1.69
date	2006.08.05.16.59.57;	author miod;	state Exp;
branches;
next	1.68;

1.68
date	2006.07.11.05.57.20;	author miod;	state Exp;
branches;
next	1.67;

1.67
date	2006.04.16.20.43.36;	author miod;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.15.20.04.37;	author miod;	state Exp;
branches;
next	1.65;

1.65
date	2005.11.05.16.04.20;	author uwe;	state Exp;
branches;
next	1.64;

1.64
date	2005.09.27.21.45.20;	author miod;	state Exp;
branches;
next	1.63;

1.63
date	2005.08.20.17.09.45;	author matthieu;	state Exp;
branches;
next	1.62;

1.62
date	2005.08.14.11.00.15;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.17.10.43.24;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2005.06.02.07.34.14;	author miod;	state Exp;
branches;
next	1.59;

1.59
date	2005.06.02.07.31.17;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2005.05.18.21.31.27;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2005.05.15.11.29.15;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2004.11.05.09.38.04;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2004.11.04.21.58.32;	author miod;	state Exp;
branches;
next	1.54;

1.54
date	2004.09.21.18.36.23;	author miod;	state Exp;
branches;
next	1.53;

1.53
date	2004.03.09.22.41.57;	author miod;	state Exp;
branches
	1.53.2.1
	1.53.4.1;
next	1.52;

1.52
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2003.09.23.16.51.12;	author millert;	state Exp;
branches;
next	1.50;

1.50
date	2003.02.23.19.08.11;	author tedu;	state Exp;
branches
	1.50.4.1;
next	1.49;

1.49
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches;
next	1.48;

1.48
date	2002.08.21.16.51.27;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2002.07.01.18.53.00;	author mickey;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.08.02.43.56;	author drahn;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.05.17.16.39;	author matthieu;	state Exp;
branches;
next	1.44;

1.44
date	2002.04.30.23.07.48;	author mickey;	state Exp;
branches;
next	1.43;

1.43
date	2002.04.30.23.01.55;	author mickey;	state Exp;
branches;
next	1.42;

1.42
date	2002.03.31.17.34.15;	author jason;	state Exp;
branches;
next	1.41;

1.41
date	2002.03.27.18.54.09;	author jbm;	state Exp;
branches;
next	1.40;

1.40
date	2002.03.16.22.11.55;	author mickey;	state Exp;
branches;
next	1.39;

1.39
date	2002.03.14.04.55.20;	author mickey;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.27.03;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	2002.01.30.20.45.34;	author nordin;	state Exp;
branches;
next	1.36;

1.36
date	2001.11.26.16.02.30;	author mickey;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2001.11.01.12.13.47;	author art;	state Exp;
branches;
next	1.34;

1.34
date	2001.09.16.00.42.44;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2001.08.29.20.26.18;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	2001.08.29.20.20.26;	author mickey;	state Exp;
branches;
next	1.31;

1.31
date	2001.07.10.11.07.25;	author espie;	state Exp;
branches;
next	1.30;

1.30
date	2001.06.29.20.16.22;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.05.24.04.12.04;	author angelos;	state Exp;
branches;
next	1.28;

1.28
date	2001.05.16.19.38.27;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2001.05.16.12.51.50;	author ho;	state Exp;
branches;
next	1.26;

1.26
date	2001.05.08.22.28.43;	author mickey;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2001.05.01.02.23.22;	author aaron;	state Exp;
branches;
next	1.24;

1.24
date	2001.04.17.23.24.31;	author aaron;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.04.17.04.30.51;	author aaron;	state Exp;
branches;
next	1.22;

1.22
date	2001.04.16.15.00.49;	author jbm;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.14.13.25.09;	author aaron;	state Exp;
branches;
next	1.20;

1.20
date	2001.04.14.13.04.17;	author aaron;	state Exp;
branches;
next	1.19;

1.19
date	2001.04.14.04.44.01;	author aaron;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.14.06.18.48;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.14.02.49.22;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.05.22.16.41;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.03.01.20.54.33;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	2001.02.25.23.24.19;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.11.16.43.04;	author fgsch;	state Exp;
branches;
next	1.12;

1.12
date	2001.02.10.19.42.06;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.09.18.50.50;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.08.02.47.11;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.23.16.13.42;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.11.15.21.23.48;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.15.20.00.39;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.08.01.16.44.33;	author mickey;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.08.01.16.35.34;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	2000.08.01.13.51.17;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.19.13.58.17;	author art;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.05.20.22.31;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	2000.05.16.23.49.11;	author mickey;	state Exp;
branches;
next	;

1.6.2.1
date	2001.09.16.15.22.03;	author miod;	state Exp;
branches;
next	;

1.24.2.1
date	2001.10.14.20.44.49;	author jason;	state Exp;
branches;
next	;

1.26.2.1
date	2001.05.14.22.26.30;	author niklas;	state Exp;
branches;
next	1.26.2.2;

1.26.2.2
date	2001.07.04.10.44.09;	author niklas;	state Exp;
branches;
next	1.26.2.3;

1.26.2.3
date	2001.10.31.03.22.50;	author nate;	state Exp;
branches;
next	1.26.2.4;

1.26.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.26.2.5;

1.26.2.5
date	2001.12.05.01.02.39;	author niklas;	state Exp;
branches;
next	1.26.2.6;

1.26.2.6
date	2002.03.06.02.11.48;	author niklas;	state Exp;
branches;
next	1.26.2.7;

1.26.2.7
date	2002.03.28.15.09.10;	author niklas;	state Exp;
branches;
next	1.26.2.8;

1.26.2.8
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.26.2.9;

1.26.2.9
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.26.2.10;

1.26.2.10
date	2004.06.05.23.12.59;	author niklas;	state Exp;
branches;
next	;

1.36.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.36.2.4;

1.36.2.4
date	2003.05.19.22.14.07;	author tedu;	state Exp;
branches;
next	;

1.50.4.1
date	2004.11.02.02.14.04;	author brad;	state Exp;
branches;
next	;

1.53.2.1
date	2004.11.02.01.49.22;	author brad;	state Exp;
branches;
next	;

1.53.4.1
date	2004.11.02.01.32.22;	author brad;	state Exp;
branches;
next	;

1.124.4.1
date	2017.08.02.16.49.11;	author deraadt;	state Exp;
branches;
next	;
commitid	aKLOOEyvLGxRtqkh;

1.126.4.1
date	2017.08.01.22.32.39;	author bluhm;	state Exp;
branches;
next	;
commitid	U05WM879RwYLbAyP;


desc
@@


1.129
log
@Fix previous commit; check the enter_ddb function pointer instead of the
"accessops" pointer before calling it.
@
text
@/* $OpenBSD: wsdisplay.c,v 1.128 2017/07/19 14:34:10 kettenis Exp $ */
/* $NetBSD: wsdisplay.c,v 1.82 2005/02/27 00:27:52 perry Exp $ */

/*
 * Copyright (c) 1996, 1997 Christopher G. Demetriou.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Christopher G. Demetriou
 *	for the NetBSD Project.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/tty.h>
#include <sys/signalvar.h>
#include <sys/errno.h>
#include <sys/fcntl.h>
#include <sys/vnode.h>
#include <sys/timeout.h>
#include <sys/poll.h>

#include <dev/wscons/wscons_features.h>
#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsdisplayvar.h>
#include <dev/wscons/wsksymvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsemulvar.h>
#include <dev/wscons/wscons_callbacks.h>
#include <dev/cons.h>

#include "wsdisplay.h"
#include "wskbd.h"
#include "wsmux.h"

#if NWSKBD > 0
#include <dev/wscons/wseventvar.h>
#include <dev/wscons/wsmuxvar.h>
#endif

#include "wsmoused.h"

struct wsscreen_internal {
	const struct wsdisplay_emulops *emulops;
	void	*emulcookie;

	const struct wsscreen_descr *scrdata;

	const struct wsemul_ops *wsemul;
	void	*wsemulcookie;
};

struct wsscreen {
	struct wsscreen_internal *scr_dconf;

	struct tty *scr_tty;
	int	scr_hold_screen;		/* hold tty output */

	int scr_flags;
#define SCR_OPEN 1		/* is it open? */
#define SCR_WAITACTIVE 2	/* someone waiting on activation */
#define SCR_GRAPHICS 4		/* graphics mode, no text (emulation) output */
#define	SCR_DUMBFB 8		/* in use as dumb fb (iff SCR_GRAPHICS) */

#ifdef WSDISPLAY_COMPAT_USL
	const struct wscons_syncops *scr_syncops;
	void *scr_synccookie;
#endif

#ifdef WSDISPLAY_COMPAT_RAWKBD
	int scr_rawkbd;
#endif

	struct wsdisplay_softc *sc;

#ifdef HAVE_WSMOUSED_SUPPORT
	/* mouse console support via wsmoused(8) */
	u_int mouse;		/* mouse cursor position */
	u_int cursor;		/* selection cursor position (if
				   different from mouse cursor pos) */
	u_int cpy_start;	/* position of the copy start mark*/
	u_int cpy_end;		/* position of the copy end mark */
	u_int orig_start;	/* position of the original sel. start*/
	u_int orig_end;		/* position of the original sel. end */

	u_int mouse_flags;	/* flags, status of the mouse */
#define MOUSE_VISIBLE	0x01	/* flag, the mouse cursor is visible */
#define SEL_EXISTS	0x02	/* flag, a selection exists */
#define SEL_IN_PROGRESS 0x04	/* flag, a selection is in progress */
#define SEL_EXT_AFTER	0x08	/* flag, selection is extended after */
#define BLANK_TO_EOL	0x10	/* flag, there are only blanks
				   characters to eol */
#define SEL_BY_CHAR	0x20	/* flag, select character by character*/
#define SEL_BY_WORD	0x40	/* flag, select word by word */
#define SEL_BY_LINE	0x80	/* flag, select line by line */

#define IS_MOUSE_VISIBLE(scr)	((scr)->mouse_flags & MOUSE_VISIBLE)
#define IS_SEL_EXISTS(scr)	((scr)->mouse_flags & SEL_EXISTS)
#define IS_SEL_IN_PROGRESS(scr)	((scr)->mouse_flags & SEL_IN_PROGRESS)
#define IS_SEL_EXT_AFTER(scr)	((scr)->mouse_flags & SEL_EXT_AFTER)
#define IS_BLANK_TO_EOL(scr)	((scr)->mouse_flags & BLANK_TO_EOL)
#define IS_SEL_BY_CHAR(scr)	((scr)->mouse_flags & SEL_BY_CHAR)
#define IS_SEL_BY_WORD(scr)	((scr)->mouse_flags & SEL_BY_WORD)
#define IS_SEL_BY_LINE(scr)	((scr)->mouse_flags & SEL_BY_LINE)
#endif	/* HAVE_WSMOUSED_SUPPORT */
};

struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int, const char *,
	    const struct wsscreen_descr *, void *, int, int, long);
void	wsscreen_detach(struct wsscreen *);
int	wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *,
	    const char *);
int	wsdisplay_getscreen(struct wsdisplay_softc *,
	    struct wsdisplay_addscreendata *);
void	wsdisplay_resume_device(struct device *);
void	wsdisplay_suspend_device(struct device *);
void	wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void	wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int	wsdisplay_delscreen(struct wsdisplay_softc *, int, int);

void	wsdisplay_burner_setup(struct wsdisplay_softc *, struct wsscreen *);
void	wsdisplay_burner(void *v);

struct wsdisplay_softc {
	struct device sc_dv;

	const struct wsdisplay_accessops *sc_accessops;
	void	*sc_accesscookie;

	const struct wsscreen_list *sc_scrdata;

	struct wsscreen *sc_scr[WSDISPLAY_MAXSCREEN];
	int sc_focusidx;	/* available only if sc_focus isn't null */
	struct wsscreen *sc_focus;

#ifdef HAVE_BURNER_SUPPORT
	struct timeout sc_burner;
	int	sc_burnoutintvl;	/* delay before blanking */
	int	sc_burninintvl;		/* delay before unblanking */
	int	sc_burnout;		/* current sc_burner delay */
	int	sc_burnman;		/* nonzero if screen blanked */
	int	sc_burnflags;
#endif

	int	sc_isconsole;

	int sc_flags;
#define SC_SWITCHPENDING	0x01
#define	SC_PASTE_AVAIL		0x02
	int sc_screenwanted, sc_oldscreen; /* valid with SC_SWITCHPENDING */
	int sc_resumescreen; /* if set, can't switch until resume. */

#if NWSKBD > 0
	struct wsevsrc *sc_input;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	int sc_rawkbd;
#endif
#endif /* NWSKBD > 0 */

#ifdef HAVE_WSMOUSED_SUPPORT
	char *sc_copybuffer;
	u_int sc_copybuffer_size;
#endif
};

extern struct cfdriver wsdisplay_cd;

/* Autoconfiguration definitions. */
int	wsdisplay_emul_match(struct device *, void *, void *);
void	wsdisplay_emul_attach(struct device *, struct device *, void *);
int	wsdisplay_emul_detach(struct device *, int);

int	wsdisplay_activate(struct device *, int);

struct cfdriver wsdisplay_cd = {
	NULL, "wsdisplay", DV_TTY
};

struct cfattach wsdisplay_emul_ca = {
	sizeof(struct wsdisplay_softc), wsdisplay_emul_match,
	wsdisplay_emul_attach, wsdisplay_emul_detach, wsdisplay_activate
};

void	wsdisplaystart(struct tty *);
int	wsdisplayparam(struct tty *, struct termios *);

/* Internal macros, functions, and variables. */
#define	WSDISPLAYUNIT(dev)		(minor(dev) >> 8)
#define	WSDISPLAYSCREEN(dev)		(minor(dev) & 0xff)
#define ISWSDISPLAYCTL(dev)		(WSDISPLAYSCREEN(dev) == 255)
#define WSDISPLAYMINOR(unit, screen)	(((unit) << 8) | (screen))

#define	WSSCREEN_HAS_TTY(scr)		((scr)->scr_tty != NULL)

void	wsdisplay_common_attach(struct wsdisplay_softc *sc,
	    int console, int mux, const struct wsscreen_list *,
	    const struct wsdisplay_accessops *accessops,
	    void *accesscookie, u_int defaultscreens);
int	wsdisplay_common_detach(struct wsdisplay_softc *, int);
void	wsdisplay_kbdholdscr(struct wsscreen *, int);

#ifdef WSDISPLAY_COMPAT_RAWKBD
int	wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
#endif

int	wsdisplay_console_initted;
struct wsdisplay_softc *wsdisplay_console_device;
struct wsscreen_internal wsdisplay_console_conf;

int	wsdisplay_getc_dummy(dev_t);
void	wsdisplay_pollc(dev_t, int);

int	wsdisplay_cons_pollmode;
void	(*wsdisplay_cons_kbd_pollc)(dev_t, int);

struct consdev wsdisplay_cons = {
	NULL, NULL, wsdisplay_getc_dummy, wsdisplay_cnputc,
	    wsdisplay_pollc, NULL, NODEV, CN_LOWPRI
};

#ifndef WSDISPLAY_DEFAULTSCREENS
#define WSDISPLAY_DEFAULTSCREENS	1
#endif
int	wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;

int	wsdisplay_switch1(void *, int, int);
int	wsdisplay_switch2(void *, int, int);
int	wsdisplay_switch3(void *, int, int);

int	wsdisplay_clearonclose;

struct wsscreen *
wsscreen_attach(struct wsdisplay_softc *sc, int console, const char *emul,
    const struct wsscreen_descr *type, void *cookie, int ccol, int crow,
    long defattr)
{
	struct wsscreen_internal *dconf;
	struct wsscreen *scr;

	scr = malloc(sizeof(*scr), M_DEVBUF, M_ZERO | M_NOWAIT);
	if (!scr)
		return (NULL);

	if (console) {
		dconf = &wsdisplay_console_conf;
		/*
		 * Tell the emulation about the callback argument.
		 * The other stuff is already there.
		 */
		(void)(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
	} else { /* not console */
		dconf = malloc(sizeof(*dconf), M_DEVBUF, M_NOWAIT);
		if (dconf == NULL)
			goto fail;
		dconf->emulops = type->textops;
		dconf->emulcookie = cookie;
		if (dconf->emulops == NULL ||
		    (dconf->wsemul = wsemul_pick(emul)) == NULL)
			goto fail;
		dconf->wsemulcookie = (*dconf->wsemul->attach)(0, type, cookie,
		    ccol, crow, scr, defattr);
		if (dconf->wsemulcookie == NULL)
			goto fail;
		dconf->scrdata = type;
	}

	scr->scr_dconf = dconf;
	scr->scr_tty = ttymalloc(0);
	scr->sc = sc;
	return (scr);

fail:
	if (dconf != NULL)
		free(dconf, M_DEVBUF, sizeof(*dconf));
	free(scr, M_DEVBUF, sizeof(*scr));
	return (NULL);
}

void
wsscreen_detach(struct wsscreen *scr)
{
	int ccol, crow; /* XXX */

	if (WSSCREEN_HAS_TTY(scr)) {
		timeout_del(&scr->scr_tty->t_rstrt_to);
		ttyfree(scr->scr_tty);
	}
	(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,
	    &ccol, &crow);
	free(scr->scr_dconf, M_DEVBUF, sizeof(*scr->scr_dconf));
	free(scr, M_DEVBUF, sizeof(*scr));
}

const struct wsscreen_descr *
wsdisplay_screentype_pick(const struct wsscreen_list *scrdata, const char *name)
{
	int i;
	const struct wsscreen_descr *scr;

	KASSERT(scrdata->nscreens > 0);

	if (name == NULL || *name == '\0')
		return (scrdata->screens[0]);

	for (i = 0; i < scrdata->nscreens; i++) {
		scr = scrdata->screens[i];
		if (!strncmp(name, scr->name, WSSCREEN_NAME_SIZE))
			return (scr);
	}

	return (0);
}

/*
 * print info about attached screen
 */
void
wsdisplay_addscreen_print(struct wsdisplay_softc *sc, int idx, int count)
{
	printf("%s: screen %d", sc->sc_dv.dv_xname, idx);
	if (count > 1)
		printf("-%d", idx + (count-1));
	printf(" added (%s, %s emulation)\n",
	    sc->sc_scr[idx]->scr_dconf->scrdata->name,
	    sc->sc_scr[idx]->scr_dconf->wsemul->name);
}

int
wsdisplay_addscreen(struct wsdisplay_softc *sc, int idx,
    const char *screentype, const char *emul)
{
	const struct wsscreen_descr *scrdesc;
	int error;
	void *cookie;
	int ccol, crow;
	long defattr;
	struct wsscreen *scr;
	int s;

	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if (sc->sc_scr[idx] != NULL)
		return (EBUSY);

	scrdesc = wsdisplay_screentype_pick(sc->sc_scrdata, screentype);
	if (!scrdesc)
		return (ENXIO);
	error = (*sc->sc_accessops->alloc_screen)(sc->sc_accesscookie,
	    scrdesc, &cookie, &ccol, &crow, &defattr);
	if (error)
		return (error);

	scr = wsscreen_attach(sc, 0, emul, scrdesc,
	    cookie, ccol, crow, defattr);
	if (scr == NULL) {
		(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);
		return (ENXIO);
	}

	sc->sc_scr[idx] = scr;

	/* if no screen has focus yet, activate the first we get */
	s = spltty();
	if (!sc->sc_focus) {
		(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, 0, 0, 0);
		sc->sc_focusidx = idx;
		sc->sc_focus = scr;
	}
	splx(s);

#ifdef HAVE_WSMOUSED_SUPPORT
	allocate_copybuffer(sc); /* enlarge the copy buffer if necessary */
#endif
	return (0);
}

int
wsdisplay_getscreen(struct wsdisplay_softc *sc,
    struct wsdisplay_addscreendata *sd)
{
	struct wsscreen *scr;

	if (sd->idx < 0 && sc->sc_focus)
		sd->idx = sc->sc_focusidx;

	if (sd->idx < 0 || sd->idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);

	scr = sc->sc_scr[sd->idx];
	if (scr == NULL)
		return (ENXIO);

	strncpy(sd->screentype, scr->scr_dconf->scrdata->name,
	    WSSCREEN_NAME_SIZE);
	strncpy(sd->emul, scr->scr_dconf->wsemul->name, WSEMUL_NAME_SIZE);

	return (0);
}

void
wsdisplay_closescreen(struct wsdisplay_softc *sc, struct wsscreen *scr)
{
	int maj, mn, idx;

	/* hangup */
	if (WSSCREEN_HAS_TTY(scr)) {
		struct tty *tp = scr->scr_tty;
		(*linesw[tp->t_line].l_modem)(tp, 0);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == wsdisplayopen)
			break;
	/* locate the screen index */
	for (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++)
		if (scr == sc->sc_scr[idx])
			break;
#ifdef DIAGNOSTIC
	if (idx == WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_forceclose: bad screen");
#endif

	/* nuke the vnodes */
	mn = WSDISPLAYMINOR(sc->sc_dv.dv_unit, idx);
	vdevgone(maj, mn, mn, VCHR);
}

int
wsdisplay_delscreen(struct wsdisplay_softc *sc, int idx, int flags)
{
	struct wsscreen *scr;
	int s;
	void *cookie;

	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if ((scr = sc->sc_scr[idx]) == NULL)
		return (ENXIO);

	if (scr->scr_dconf == &wsdisplay_console_conf ||
#ifdef WSDISPLAY_COMPAT_USL
	    scr->scr_syncops ||
#endif
	    ((scr->scr_flags & SCR_OPEN) && !(flags & WSDISPLAY_DELSCR_FORCE)))
		return (EBUSY);

	wsdisplay_closescreen(sc, scr);

	/*
	 * delete pointers, so neither device entries
	 * nor keyboard input can reference it anymore
	 */
	s = spltty();
	if (sc->sc_focus == scr) {
		sc->sc_focus = NULL;
#ifdef WSDISPLAY_COMPAT_RAWKBD
		wsdisplay_update_rawkbd(sc, 0);
#endif
	}
	sc->sc_scr[idx] = NULL;
	splx(s);

	/*
	 * Wake up processes waiting for the screen to
	 * be activated. Sleepers must check whether
	 * the screen still exists.
	 */
	if (scr->scr_flags & SCR_WAITACTIVE)
		wakeup(scr);

	/* save a reference to the graphics screen */
	cookie = scr->scr_dconf->emulcookie;

	wsscreen_detach(scr);

	(*sc->sc_accessops->free_screen)(sc->sc_accesscookie, cookie);

	if ((flags & WSDISPLAY_DELSCR_QUIET) == 0)
		printf("%s: screen %d deleted\n", sc->sc_dv.dv_xname, idx);
	return (0);
}

/*
 * Autoconfiguration functions.
 */
int
wsdisplay_emul_match(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct wsemuldisplaydev_attach_args *ap = aux;

	if (cf->wsemuldisplaydevcf_console != WSEMULDISPLAYDEVCF_CONSOLE_UNK) {
		/*
		 * If console-ness of device specified, either match
		 * exactly (at high priority), or fail.
		 */
		if (cf->wsemuldisplaydevcf_console != 0 && ap->console != 0)
			return (10);
		else
			return (0);
	}

	/* If console-ness unspecified, it wins. */
	return (1);
}

void
wsdisplay_emul_attach(struct device *parent, struct device *self, void *aux)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;
	struct wsemuldisplaydev_attach_args *ap = aux;

	wsdisplay_common_attach(sc, ap->console,
	    sc->sc_dv.dv_cfdata->wsemuldisplaydevcf_mux, ap->scrdata,
	    ap->accessops, ap->accesscookie, ap->defaultscreens);

	if (ap->console && cn_tab == &wsdisplay_cons) {
		int maj;

		/* locate the major number */
		for (maj = 0; maj < nchrdev; maj++)
			if (cdevsw[maj].d_open == wsdisplayopen)
				break;

		cn_tab->cn_dev = makedev(maj, WSDISPLAYMINOR(self->dv_unit, 0));
	}
}

/*
 * Detach a display.
 */
int
wsdisplay_emul_detach(struct device *self, int flags)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;

	return (wsdisplay_common_detach(sc, flags));
}

int
wsdisplay_activate(struct device *self, int act)
{
	int ret = 0;

	switch (act) {
	case DVACT_POWERDOWN:
		wsdisplay_switchtoconsole();
		break;
	}

	return (ret);
}

int
wsdisplay_common_detach(struct wsdisplay_softc *sc, int flags)
{
	int i;
	int rc;

	/* We don't support detaching the console display yet. */
	if (sc->sc_isconsole)
		return (EBUSY);

	/* Delete all screens managed by this display */
	for (i = 0; i < WSDISPLAY_MAXSCREEN; i++)
		if (sc->sc_scr[i] != NULL) {
			if ((rc = wsdisplay_delscreen(sc, i,
			    WSDISPLAY_DELSCR_QUIET | (flags & DETACH_FORCE ?
			     WSDISPLAY_DELSCR_FORCE : 0))) != 0)
				return (rc);
		}

#ifdef HAVE_BURNER_SUPPORT
	timeout_del(&sc->sc_burner);
#endif

#if NWSKBD > 0
	if (sc->sc_input != NULL) {
#if NWSMUX > 0
		/*
		 * If we are the display of the mux we are attached to,
		 * disconnect all input devices from us.
		 */
		if (sc->sc_input->me_dispdv == &sc->sc_dv) {
			if ((rc = wsmux_set_display((struct wsmux_softc *)
						    sc->sc_input, NULL)) != 0)
				return (rc);
		}

		/*
		 * XXX
		 * If we created a standalone mux (dmux), we should destroy it
		 * there, but there is currently no support for this in wsmux.
		 */
#else
		if ((rc = wskbd_set_display((struct device *)sc->sc_input,
		    NULL)) != 0)
			return (rc);
#endif
	}
#endif

	return (0);
}

/* Print function (for parent devices). */
int
wsemuldisplaydevprint(void *aux, const char *pnp)
{
#if 0 /* -Wunused */
	struct wsemuldisplaydev_attach_args *ap = aux;
#endif

	if (pnp)
		printf("wsdisplay at %s", pnp);
#if 0 /* don't bother; it's ugly */
	printf(" console %d", ap->console);
#endif

	return (UNCONF);
}

/* Submatch function (for parent devices). */
int
wsemuldisplaydevsubmatch(struct device *parent, void *match, void *aux)
{
	extern struct cfdriver wsdisplay_cd;
	struct cfdata *cf = match;

	/* only allow wsdisplay to attach */
	if (cf->cf_driver == &wsdisplay_cd)
		return ((*cf->cf_attach->ca_match)(parent, match, aux));

	return (0);
}

void
wsdisplay_common_attach(struct wsdisplay_softc *sc, int console, int kbdmux,
    const struct wsscreen_list *scrdata,
    const struct wsdisplay_accessops *accessops, void *accesscookie,
    u_int defaultscreens)
{
	int i, start = 0;
#if NWSKBD > 0
	struct wsevsrc *kme;
#if NWSMUX > 0
	struct wsmux_softc *mux;

	if (kbdmux >= 0)
		mux = wsmux_getmux(kbdmux);
	else
		mux = wsmux_create("dmux", sc->sc_dv.dv_unit);
	/* XXX panic()ing isn't nice, but attach cannot fail */
	if (mux == NULL)
		panic("wsdisplay_common_attach: no memory");
	sc->sc_input = &mux->sc_base;

	if (kbdmux >= 0)
		printf(" mux %d", kbdmux);
#else
#if 0	/* not worth keeping, especially since the default value is not -1... */
	if (kbdmux >= 0)
		printf(" (mux ignored)");
#endif
#endif	/* NWSMUX > 0 */
#endif	/* NWSKBD > 0 */

	sc->sc_isconsole = console;
	sc->sc_resumescreen = WSDISPLAY_NULLSCREEN;

	if (console) {
		KASSERT(wsdisplay_console_initted);
		KASSERT(wsdisplay_console_device == NULL);

		sc->sc_scr[0] = wsscreen_attach(sc, 1, 0, 0, 0, 0, 0, 0);
		if (sc->sc_scr[0] == NULL)
			return;
		wsdisplay_console_device = sc;

		printf(": console (%s, %s emulation)",
		       wsdisplay_console_conf.scrdata->name,
		       wsdisplay_console_conf.wsemul->name);

#if NWSKBD > 0
		kme = wskbd_set_console_display(&sc->sc_dv, sc->sc_input);
		if (kme != NULL)
			printf(", using %s", kme->me_dv.dv_xname);
#if NWSMUX == 0
		sc->sc_input = kme;
#endif
#endif

		sc->sc_focusidx = 0;
		sc->sc_focus = sc->sc_scr[0];
		start = 1;
	}
	printf("\n");

#if NWSKBD > 0 && NWSMUX > 0
	/*
	 * If this mux did not have a display device yet, volunteer for
	 * the job.
	 */
	if (mux->sc_displaydv == NULL)
		wsmux_set_display(mux, &sc->sc_dv);
#endif

	sc->sc_accessops = accessops;
	sc->sc_accesscookie = accesscookie;
	sc->sc_scrdata = scrdata;

	/*
	 * Set up a number of virtual screens if wanted. The
	 * WSDISPLAYIO_ADDSCREEN ioctl is more flexible, so this code
	 * is for special cases like installation kernels, as well as
	 * sane multihead defaults.
	 */
	if (defaultscreens == 0)
		defaultscreens = wsdisplay_defaultscreens;
	for (i = start; i < defaultscreens; i++) {
		if (wsdisplay_addscreen(sc, i, 0, 0))
			break;
	}

	if (i > start)
		wsdisplay_addscreen_print(sc, start, i-start);

#ifdef HAVE_BURNER_SUPPORT
	sc->sc_burnoutintvl = (hz * WSDISPLAY_DEFBURNOUT) / 1000;
	sc->sc_burninintvl = (hz * WSDISPLAY_DEFBURNIN) / 1000;
	sc->sc_burnflags = WSDISPLAY_BURN_OUTPUT | WSDISPLAY_BURN_KBD |
	    WSDISPLAY_BURN_MOUSE;
	timeout_set(&sc->sc_burner, wsdisplay_burner, sc);
	sc->sc_burnout = sc->sc_burnoutintvl;
	wsdisplay_burn(sc, sc->sc_burnflags);
#endif

#if NWSKBD > 0 && NWSMUX == 0
	if (console == 0) {
		/*
		 * In the non-wsmux world, always connect wskbd0 and wsdisplay0
		 * together.
		 */
		extern struct cfdriver wskbd_cd;

		if (wskbd_cd.cd_ndevs != 0 && sc->sc_dv.dv_unit == 0) {
			if (wsdisplay_set_kbd(&sc->sc_dv,
			    (struct wsevsrc *)wskbd_cd.cd_devs[0]) == 0)
				wskbd_set_display(wskbd_cd.cd_devs[0],
				    &sc->sc_dv);
		}
	}
#endif
}

void
wsdisplay_cnattach(const struct wsscreen_descr *type, void *cookie, int ccol,
    int crow, long defattr)
{
	const struct wsemul_ops *wsemul;
	const struct wsdisplay_emulops *emulops;

	KASSERT(type->nrows > 0);
	KASSERT(type->ncols > 0);
	KASSERT(crow < type->nrows);
	KASSERT(ccol < type->ncols);

	wsdisplay_console_conf.emulops = emulops = type->textops;
	wsdisplay_console_conf.emulcookie = cookie;
	wsdisplay_console_conf.scrdata = type;

#ifdef WSEMUL_DUMB
	/*
	 * If the emulops structure is crippled, force a dumb emulation.
	 */
	if (emulops->cursor == NULL ||
	    emulops->copycols == NULL || emulops->copyrows == NULL ||
	    emulops->erasecols == NULL || emulops->eraserows == NULL)
		wsemul = wsemul_pick("dumb");
	else
#endif
		wsemul = wsemul_pick("");
	wsdisplay_console_conf.wsemul = wsemul;
	wsdisplay_console_conf.wsemulcookie =
	    (*wsemul->cnattach)(type, cookie, ccol, crow, defattr);

	if (!wsdisplay_console_initted)
		cn_tab = &wsdisplay_cons;

	wsdisplay_console_initted = 1;
}

/*
 * Tty and cdevsw functions.
 */
int
wsdisplayopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit, newopen, error;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	if (unit >= wsdisplay_cd.cd_ndevs ||	/* make sure it was attached */
	    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)
		return (ENXIO);

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)
		return (ENXIO);
	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		tp = scr->scr_tty;
		tp->t_oproc = wsdisplaystart;
		tp->t_param = wsdisplayparam;
		tp->t_dev = dev;
		newopen = (tp->t_state & TS_ISOPEN) == 0;
		if (newopen) {
			ttychars(tp);
			tp->t_iflag = TTYDEF_IFLAG;
			tp->t_oflag = TTYDEF_OFLAG;
			tp->t_cflag = TTYDEF_CFLAG;
			tp->t_lflag = TTYDEF_LFLAG;
			tp->t_ispeed = tp->t_ospeed = TTYDEF_SPEED;
			wsdisplayparam(tp, &tp->t_termios);
			ttsetwater(tp);
		} else if ((tp->t_state & TS_XCLUDE) != 0 &&
			   suser(p, 0) != 0)
			return (EBUSY);
		tp->t_state |= TS_CARR_ON;

		error = ((*linesw[tp->t_line].l_open)(dev, tp, p));
		if (error)
			return (error);

		if (newopen) {
			/* set window sizes as appropriate, and reset
			   the emulation */
			tp->t_winsize.ws_row = scr->scr_dconf->scrdata->nrows;
			tp->t_winsize.ws_col = scr->scr_dconf->scrdata->ncols;
		}
	}

	scr->scr_flags |= SCR_OPEN;
	return (0);
}

int
wsdisplayclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		if (scr->scr_hold_screen) {
			int s;

			/* XXX RESET KEYBOARD LEDS, etc. */
			s = spltty();	/* avoid conflict with keyboard */
			wsdisplay_kbdholdscr(scr, 0);
			splx(s);
		}
		tp = scr->scr_tty;
		(*linesw[tp->t_line].l_close)(tp, flag, p);
		ttyclose(tp);
	}

#ifdef WSDISPLAY_COMPAT_USL
	if (scr->scr_syncops)
		(*scr->scr_syncops->destroy)(scr->scr_synccookie);
#endif

	scr->scr_flags &= ~SCR_GRAPHICS;
	(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
					 WSEMUL_RESET);
	if (wsdisplay_clearonclose)
		(*scr->scr_dconf->wsemul->reset)
			(scr->scr_dconf->wsemulcookie, WSEMUL_CLEARSCREEN);

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (scr->scr_rawkbd) {
		int kbmode = WSKBD_TRANSLATED;
		(void) wsdisplay_internal_ioctl(sc, scr, WSKBDIO_SETMODE,
		    (caddr_t)&kbmode, FWRITE, p);
	}
#endif

	scr->scr_flags &= ~SCR_OPEN;

#ifdef HAVE_WSMOUSED_SUPPORT
	/* remove the selection at logout */
	if (sc->sc_copybuffer != NULL)
		explicit_bzero(sc->sc_copybuffer, sc->sc_copybuffer_size);
	CLR(sc->sc_flags, SC_PASTE_AVAIL);
#endif

	return (0);
}

int
wsdisplayread(dev_t dev, struct uio *uio, int flag)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (!WSSCREEN_HAS_TTY(scr))
		return (ENODEV);

	tp = scr->scr_tty;
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
}

int
wsdisplaywrite(dev_t dev, struct uio *uio, int flag)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (!WSSCREEN_HAS_TTY(scr))
		return (ENODEV);

	tp = scr->scr_tty;
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
}

struct tty *
wsdisplaytty(dev_t dev)
{
	struct wsdisplay_softc *sc;
	int unit;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

	if (ISWSDISPLAYCTL(dev))
		panic("wsdisplaytty() on ctl device");

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (NULL);

	return (scr->scr_tty);
}

int
wsdisplayioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct wsdisplay_softc *sc;
	struct tty *tp;
	int unit, error;
	struct wsscreen *scr;

	unit = WSDISPLAYUNIT(dev);
	sc = wsdisplay_cd.cd_devs[unit];

#ifdef WSDISPLAY_COMPAT_USL
	error = wsdisplay_usl_ioctl1(sc, cmd, data, flag, p);
	if (error >= 0)
		return (error);
#endif

	if (ISWSDISPLAYCTL(dev)) {
	       	if (cmd != WSDISPLAYIO_GTYPE)
			return (wsdisplay_cfg_ioctl(sc, cmd, data, flag, p));
		/* pass WSDISPLAYIO_GTYPE to the first screen */
		dev = makedev(major(dev), WSDISPLAYMINOR(unit, 0));
	}

	if (WSDISPLAYSCREEN(dev) >= WSDISPLAY_MAXSCREEN)
		return (ENODEV);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (WSSCREEN_HAS_TTY(scr)) {
		tp = scr->scr_tty;

/* printf("disc\n"); */
		/* do the line discipline ioctls first */
		error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
		if (error >= 0)
			return (error);

/* printf("tty\n"); */
		/* then the tty ioctls */
		error = ttioctl(tp, cmd, data, flag, p);
		if (error >= 0)
			return (error);
	}

#ifdef WSDISPLAY_COMPAT_USL
	error = wsdisplay_usl_ioctl2(sc, scr, cmd, data, flag, p);
	if (error >= 0)
		return (error);
#endif

	error = wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p);
	return (error != -1 ? error : ENOTTY);
}

int
wsdisplay_param(struct device *dev, u_long cmd, struct wsdisplay_param *dp)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;

	return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd,
	    (caddr_t)dp, 0, NULL));
}

int
wsdisplay_internal_ioctl(struct wsdisplay_softc *sc, struct wsscreen *scr,
    u_long cmd, caddr_t data, int flag, struct proc *p)
{
	int error;

#if NWSKBD > 0
	struct wsevsrc *inp;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	switch (cmd) {
	case WSKBDIO_SETMODE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
		scr->scr_rawkbd = (*(int *)data == WSKBD_RAW);
		return (wsdisplay_update_rawkbd(sc, scr));
	case WSKBDIO_GETMODE:
		*(int *)data = (scr->scr_rawkbd ?
				WSKBD_RAW : WSKBD_TRANSLATED);
		return (0);
	}
#endif
	inp = sc->sc_input;
	if (inp != NULL) {
		error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
		if (error >= 0)
			return (error);
	}
#endif /* NWSKBD > 0 */

	switch (cmd) {
	case WSDISPLAYIO_SMODE:
	case WSDISPLAYIO_USEFONT:
#ifdef HAVE_BURNER_SUPPORT
	case WSDISPLAYIO_SVIDEO:
	case WSDISPLAYIO_SBURNER:
#endif
	case WSDISPLAYIO_SETSCREEN:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	}

	switch (cmd) {
	case WSDISPLAYIO_GMODE:
		if (scr->scr_flags & SCR_GRAPHICS) {
			if (scr->scr_flags & SCR_DUMBFB)
				*(u_int *)data = WSDISPLAYIO_MODE_DUMBFB;
			else
				*(u_int *)data = WSDISPLAYIO_MODE_MAPPED;
		} else
			*(u_int *)data = WSDISPLAYIO_MODE_EMUL;
		return (0);

	case WSDISPLAYIO_SMODE:
#define d (*(int *)data)
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED &&
		    d != WSDISPLAYIO_MODE_DUMBFB)
			return (EINVAL);

		scr->scr_flags &= ~SCR_GRAPHICS;
		if (d == WSDISPLAYIO_MODE_MAPPED ||
		    d == WSDISPLAYIO_MODE_DUMBFB) {
			scr->scr_flags |= SCR_GRAPHICS |
			    ((d == WSDISPLAYIO_MODE_DUMBFB) ?  SCR_DUMBFB : 0);

			/* clear cursor */
			(*scr->scr_dconf->wsemul->reset)
			    (scr->scr_dconf->wsemulcookie, WSEMUL_CLEARCURSOR);
		}

#ifdef HAVE_BURNER_SUPPORT
		wsdisplay_burner_setup(sc, scr);
#endif

		(void)(*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
		    flag, p);

		return (0);
#undef d

	case WSDISPLAYIO_USEFONT:
#define d ((struct wsdisplay_font *)data)
		if (!sc->sc_accessops->load_font)
			return (EINVAL);
		d->data = NULL;
		error = (*sc->sc_accessops->load_font)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, d);
		if (!error)
			(*scr->scr_dconf->wsemul->reset)
			    (scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);
		return (error);
#undef d
#ifdef HAVE_BURNER_SUPPORT
	case WSDISPLAYIO_GVIDEO:
		*(u_int *)data = !sc->sc_burnman;
		break;

	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data != WSDISPLAYIO_VIDEO_OFF &&
		    *(u_int *)data != WSDISPLAYIO_VIDEO_ON)
			return (EINVAL);
		if (sc->sc_accessops->burn_screen == NULL)
			return (EOPNOTSUPP);
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		     *(u_int *)data, sc->sc_burnflags);
		sc->sc_burnman = *(u_int *)data == WSDISPLAYIO_VIDEO_OFF;
		break;

	case WSDISPLAYIO_GBURNER:
#define d ((struct wsdisplay_burner *)data)
		d->on  = sc->sc_burninintvl  * 1000 / hz;
		d->off = sc->sc_burnoutintvl * 1000 / hz;
		d->flags = sc->sc_burnflags;
		return (0);

	case WSDISPLAYIO_SBURNER:
	    {
		struct wsscreen *active;

		if (d->flags & ~(WSDISPLAY_BURN_VBLANK | WSDISPLAY_BURN_KBD |
		    WSDISPLAY_BURN_MOUSE | WSDISPLAY_BURN_OUTPUT))
			return EINVAL;

		error = 0;
		sc->sc_burnflags = d->flags;
		/* disable timeout if necessary */
		if ((sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
		    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) == 0) {
			if (sc->sc_burnout)
				timeout_del(&sc->sc_burner);
		}

		active = sc->sc_focus;
		if (active == NULL)
			active = scr;

		if (d->on) {
			sc->sc_burninintvl = hz * d->on / 1000;
			if (sc->sc_burnman) {
				sc->sc_burnout = sc->sc_burninintvl;
				/* reinit timeout if changed */
				if ((active->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
			}
		}
		if (d->off) {
			sc->sc_burnoutintvl = hz * d->off / 1000;
			if (!sc->sc_burnman) {
				sc->sc_burnout = sc->sc_burnoutintvl;
				/* reinit timeout if changed */
				if ((active->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
			}
		}
		return (error);
	    }
#undef d
#endif	/* HAVE_BURNER_SUPPORT */
	case WSDISPLAYIO_GETSCREEN:
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));

	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));

	case WSDISPLAYIO_GETSCREENTYPE:
#define d ((struct wsdisplay_screentype *)data)
		if (d->idx >= sc->sc_scrdata->nscreens)
			return(EINVAL);

		d->nidx = sc->sc_scrdata->nscreens;
		strncpy(d->name, sc->sc_scrdata->screens[d->idx]->name,
			WSSCREEN_NAME_SIZE);
		d->ncols = sc->sc_scrdata->screens[d->idx]->ncols;
		d->nrows = sc->sc_scrdata->screens[d->idx]->nrows;
		d->fontwidth = sc->sc_scrdata->screens[d->idx]->fontwidth;
		d->fontheight = sc->sc_scrdata->screens[d->idx]->fontheight;
		return (0);
#undef d
	case WSDISPLAYIO_GETEMULTYPE:
#define d ((struct wsdisplay_emultype *)data)
		if (wsemul_getname(d->idx) == NULL)
			return(EINVAL);
		strncpy(d->name, wsemul_getname(d->idx), WSEMUL_NAME_SIZE);
		return (0);
#undef d
        }

	/* check ioctls for display */
	return ((*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
	    flag, p));
}

int
wsdisplay_cfg_ioctl(struct wsdisplay_softc *sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
{
	int error;
	void *buf;
	size_t fontsz;
#if NWSKBD > 0
	struct wsevsrc *inp;
#endif

	switch (cmd) {
#ifdef HAVE_WSMOUSED_SUPPORT
	case WSDISPLAYIO_WSMOUSED:
		error = wsmoused(sc, data, flag, p);
		return (error);
#endif
	case WSDISPLAYIO_ADDSCREEN:
#define d ((struct wsdisplay_addscreendata *)data)
		if ((error = wsdisplay_addscreen(sc, d->idx,
		    d->screentype, d->emul)) == 0)
			wsdisplay_addscreen_print(sc, d->idx, 0);
		return (error);
#undef d
	case WSDISPLAYIO_DELSCREEN:
#define d ((struct wsdisplay_delscreendata *)data)
		return (wsdisplay_delscreen(sc, d->idx, d->flags));
#undef d
	case WSDISPLAYIO_GETSCREEN:
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));
	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));
	case WSDISPLAYIO_LDFONT:
#define d ((struct wsdisplay_font *)data)
		if (!sc->sc_accessops->load_font)
			return (EINVAL);
		if (d->fontheight > 64 || d->stride > 8) /* 64x64 pixels */
			return (EINVAL);
		if (d->numchars > 65536) /* unicode plane */
			return (EINVAL);
		fontsz = d->fontheight * d->stride * d->numchars;
		if (fontsz > WSDISPLAY_MAXFONTSZ)
			return (EINVAL);

		buf = malloc(fontsz, M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf, fontsz);
		if (error) {
			free(buf, M_DEVBUF, fontsz);
			return (error);
		}
		d->data = buf;
		error =
		  (*sc->sc_accessops->load_font)(sc->sc_accesscookie, 0, d);
		if (error)
			free(buf, M_DEVBUF, fontsz);
		return (error);

	case WSDISPLAYIO_LSFONT:
		if (!sc->sc_accessops->list_font)
			return (EINVAL);
		error =
		  (*sc->sc_accessops->list_font)(sc->sc_accesscookie, d);
		return (error);

	case WSDISPLAYIO_DELFONT:
		return (EINVAL);
#undef d

#if NWSKBD > 0
	case WSMUXIO_ADD_DEVICE:
#define d ((struct wsmux_device *)data)
		if (d->idx == -1 && d->type == WSMUX_KBD)
			d->idx = wskbd_pickfree();
#undef d
		/* FALLTHROUGH */
	case WSMUXIO_INJECTEVENT:
	case WSMUXIO_REMOVE_DEVICE:
	case WSMUXIO_LIST_DEVICES:
		inp = sc->sc_input;
		if (inp == NULL)
			return (ENXIO);
		return (wsevsrc_ioctl(inp, cmd, data, flag,p));
#endif /* NWSKBD > 0 */

	}
	return (EINVAL);
}

paddr_t
wsdisplaymmap(dev_t dev, off_t offset, int prot)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (-1);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (-1);

	if (!(scr->scr_flags & SCR_GRAPHICS))
		return (-1);

	/* pass mmap to display */
	return ((*sc->sc_accessops->mmap)(sc->sc_accesscookie, offset, prot));
}

int
wsdisplaypoll(dev_t dev, int events, struct proc *p)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (0);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (POLLERR);

	if (!WSSCREEN_HAS_TTY(scr))
		return (POLLERR);

	return (ttpoll(dev, events, p));
}

int
wsdisplaykqfilter(dev_t dev, struct knote *kn)
{
	struct wsdisplay_softc *sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(dev)];
	struct wsscreen *scr;

	if (ISWSDISPLAYCTL(dev))
		return (ENXIO);

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(dev)]) == NULL)
		return (ENXIO);

	if (!WSSCREEN_HAS_TTY(scr))
		return (ENXIO);

	return (ttkqfilter(dev, kn));
}

void
wsdisplaystart(struct tty *tp)
{
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
	int s, n, done, unit;
	u_char *buf;

	unit = WSDISPLAYUNIT(tp->t_dev);
	if (unit >= wsdisplay_cd.cd_ndevs ||
	    (sc = wsdisplay_cd.cd_devs[unit]) == NULL)
		return;

	s = spltty();
	if (tp->t_state & (TS_TIMEOUT | TS_BUSY | TS_TTSTOP)) {
		splx(s);
		return;
	}
	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_seltid == 0)
		goto low;

	if ((scr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)]) == NULL) {
		splx(s);
		return;
	}
	if (scr->scr_hold_screen) {
		tp->t_state |= TS_TIMEOUT;
		splx(s);
		return;
	}
	tp->t_state |= TS_BUSY;
	splx(s);

	/*
	 * Drain output from ring buffer.
	 * The output will normally be in one contiguous chunk, but when the
	 * ring wraps, it will be in two pieces.. one at the end of the ring,
	 * the other at the start.  For performance, rather than loop here,
	 * we output one chunk, see if there's another one, and if so, output
	 * it too.
	 */

	n = ndqb(&tp->t_outq, 0);
	buf = tp->t_outq.c_cf;

	if (!(scr->scr_flags & SCR_GRAPHICS)) {
#ifdef HAVE_BURNER_SUPPORT
		wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
#endif
#ifdef HAVE_WSMOUSED_SUPPORT
		if (scr == sc->sc_focus)
			mouse_remove(scr);
#endif
		done = (*scr->scr_dconf->wsemul->output)
		    (scr->scr_dconf->wsemulcookie, buf, n, 0);
	} else
		done = n;
	ndflush(&tp->t_outq, done);

	if (done == n) {
		if ((n = ndqb(&tp->t_outq, 0)) > 0) {
			buf = tp->t_outq.c_cf;

			if (!(scr->scr_flags & SCR_GRAPHICS)) {
				done = (*scr->scr_dconf->wsemul->output)
				    (scr->scr_dconf->wsemulcookie, buf, n, 0);
			} else
				done = n;
			ndflush(&tp->t_outq, done);
		}
	}

	s = spltty();
	tp->t_state &= ~TS_BUSY;
	/* Come back if there's more to do */
	if (tp->t_outq.c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);
	}
low:
	ttwakeupwr(tp);
	splx(s);
}

int
wsdisplaystop(struct tty *tp, int flag)
{
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY))
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	splx(s);

	return (0);
}

/* Set line parameters. */
int
wsdisplayparam(struct tty *tp, struct termios *t)
{

	tp->t_ispeed = t->c_ispeed;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;
	return (0);
}

/*
 * Callbacks for the emulation code.
 */
void
wsdisplay_emulbell(void *v)
{
	struct wsscreen *scr = v;

	if (scr == NULL)		/* console, before real attach */
		return;

	if (scr->scr_flags & SCR_GRAPHICS) /* can this happen? */
		return;

	(void) wsdisplay_internal_ioctl(scr->sc, scr, WSKBDIO_BELL, NULL,
	    FWRITE, NULL);
}

#if !defined(WSEMUL_NO_VT100)
void
wsdisplay_emulinput(void *v, const u_char *data, u_int count)
{
	struct wsscreen *scr = v;
	struct tty *tp;

	if (v == NULL)			/* console, before real attach */
		return;

	if (scr->scr_flags & SCR_GRAPHICS) /* XXX can't happen */
		return;
	if (!WSSCREEN_HAS_TTY(scr))
		return;

	tp = scr->scr_tty;
	while (count-- > 0)
		(*linesw[tp->t_line].l_rint)(*data++, tp);
}
#endif

/*
 * Calls from the keyboard interface.
 */
void
wsdisplay_kbdinput(struct device *dev, kbd_t layout, keysym_t *ks, int num)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;
	const u_char *dp;
	int count;
	struct tty *tp;

	scr = sc->sc_focus;
	if (!scr || !WSSCREEN_HAS_TTY(scr))
		return;


	tp = scr->scr_tty;
	for (; num > 0; num--) {
		count = (*scr->scr_dconf->wsemul->translate)
		    (scr->scr_dconf->wsemulcookie, layout, *ks++, &dp);
		while (count-- > 0)
			(*linesw[tp->t_line].l_rint)(*dp++, tp);
	}
}

#ifdef WSDISPLAY_COMPAT_RAWKBD
void
wsdisplay_rawkbdinput(struct device *dev, u_char *buf, int num)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;
	struct tty *tp;

	scr = sc->sc_focus;
	if (!scr || !WSSCREEN_HAS_TTY(scr))
		return;

	tp = scr->scr_tty;
	while (num-- > 0)
		(*linesw[tp->t_line].l_rint)(*buf++, tp);
}
int
wsdisplay_update_rawkbd(struct wsdisplay_softc *sc, struct wsscreen *scr)
{
#if NWSKBD > 0
	int s, raw, data, error;
	struct wsevsrc *inp;

	s = spltty();

	raw = (scr ? scr->scr_rawkbd : 0);

	if (scr != sc->sc_focus || sc->sc_rawkbd == raw) {
		splx(s);
		return (0);
	}

	data = raw ? WSKBD_RAW : WSKBD_TRANSLATED;
	inp = sc->sc_input;
	if (inp == NULL) {
		splx(s);
		return (ENXIO);
	}
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, FWRITE, 0);
	if (!error)
		sc->sc_rawkbd = raw;
	splx(s);
	return (error);
#else
	return (0);
#endif
}
#endif

int
wsdisplay_switch3(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

#ifdef WSDISPLAY_COMPAT_USL
	if (!ISSET(sc->sc_flags, SC_SWITCHPENDING)) {
		printf("wsdisplay_switch3: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch3: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch3: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		/* try to recover, avoid recursion */

		if (sc->sc_oldscreen == WSDISPLAY_NULLSCREEN) {
			printf("wsdisplay_switch3: giving up\n");
			sc->sc_focus = NULL;
#ifdef WSDISPLAY_COMPAT_RAWKBD
			wsdisplay_update_rawkbd(sc, 0);
#endif
			CLR(sc->sc_flags, SC_SWITCHPENDING);
			return (error);
		}

		sc->sc_screenwanted = sc->sc_oldscreen;
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(arg, 0, waitok));
	}
#else
	/*
	 * If we do not have syncops support, we come straight from
	 * wsdisplay_switch2 which has already validated our arguments
	 * and did not sleep.
	 */
	no = sc->sc_screenwanted;
	scr = sc->sc_scr[no];
#endif

	CLR(sc->sc_flags, SC_SWITCHPENDING);

#ifdef HAVE_BURNER_SUPPORT
	if (!error)
		wsdisplay_burner_setup(sc, scr);
#endif

	if (!error && (scr->scr_flags & SCR_WAITACTIVE))
		wakeup(scr);
	return (error);
}

int
wsdisplay_switch2(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

	if (!ISSET(sc->sc_flags, SC_SWITCHPENDING)) {
		printf("wsdisplay_switch2: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch2: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch2: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		/* try to recover, avoid recursion */

		if (sc->sc_oldscreen == WSDISPLAY_NULLSCREEN) {
			printf("wsdisplay_switch2: giving up\n");
			sc->sc_focus = NULL;
			CLR(sc->sc_flags, SC_SWITCHPENDING);
			return (error);
		}

		sc->sc_screenwanted = sc->sc_oldscreen;
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(arg, 0, waitok));
	}

	sc->sc_focusidx = no;
	sc->sc_focus = scr;

#ifdef WSDISPLAY_COMPAT_RAWKBD
	(void) wsdisplay_update_rawkbd(sc, scr);
#endif
	/* keyboard map??? */

#ifdef WSDISPLAY_COMPAT_USL
#define wsswitch_cb3 ((void (*)(void *, int, int))wsdisplay_switch3)
	if (scr->scr_syncops) {
		error = (*scr->scr_syncops->attach)(scr->scr_synccookie, waitok,
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb3, sc);
		if (error == EAGAIN) {
			/* switch will be done asynchronously */
			return (0);
		}
	}
#endif

	return (wsdisplay_switch3(sc, error, waitok));
}

int
wsdisplay_switch1(void *arg, int error, int waitok)
{
	struct wsdisplay_softc *sc = arg;
	int no;
	struct wsscreen *scr;

	if (!ISSET(sc->sc_flags, SC_SWITCHPENDING)) {
		printf("wsdisplay_switch1: not switching\n");
		return (EINVAL);
	}

	no = sc->sc_screenwanted;
	if (no == WSDISPLAY_NULLSCREEN) {
		CLR(sc->sc_flags, SC_SWITCHPENDING);
		if (!error) {
			sc->sc_focus = NULL;
		}
		wakeup(sc);
		return (error);
	}
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		panic("wsdisplay_switch1: invalid screen %d", no);
	scr = sc->sc_scr[no];
	if (!scr) {
		printf("wsdisplay_switch1: screen %d disappeared\n", no);
		error = ENXIO;
	}

	if (error) {
		CLR(sc->sc_flags, SC_SWITCHPENDING);
		return (error);
	}

#define wsswitch_cb2 ((void (*)(void *, int, int))wsdisplay_switch2)
	error = (*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
	    scr->scr_dconf->emulcookie, waitok,
	    sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);
	if (error == EAGAIN) {
		/* switch will be done asynchronously */
		return (0);
	}

	return (wsdisplay_switch2(sc, error, waitok));
}

int
wsdisplay_switch(struct device *dev, int no, int waitok)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	int s, res = 0;
	struct wsscreen *scr;

	if (no != WSDISPLAY_NULLSCREEN) {
		if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
			return (EINVAL);
		if (sc->sc_scr[no] == NULL)
			return (ENXIO);
	}

	s = spltty();

	while (sc->sc_resumescreen != WSDISPLAY_NULLSCREEN && res == 0)
		res = tsleep(&sc->sc_resumescreen, PCATCH, "wsrestore", 0);
	if (res) {
		splx(s);
		return (res);
	}

	if ((sc->sc_focus && no == sc->sc_focusidx) ||
	    (sc->sc_focus == NULL && no == WSDISPLAY_NULLSCREEN)) {
		splx(s);
		return (0);
	}

	if (ISSET(sc->sc_flags, SC_SWITCHPENDING)) {
		splx(s);
		return (EBUSY);
	}

	SET(sc->sc_flags, SC_SWITCHPENDING);
	sc->sc_screenwanted = no;

	splx(s);

	scr = sc->sc_focus;
	if (!scr) {
		sc->sc_oldscreen = WSDISPLAY_NULLSCREEN;
		return (wsdisplay_switch1(sc, 0, waitok));
	} else
		sc->sc_oldscreen = sc->sc_focusidx;

#ifdef WSDISPLAY_COMPAT_USL
#define wsswitch_cb1 ((void (*)(void *, int, int))wsdisplay_switch1)
	if (scr->scr_syncops) {
		res = (*scr->scr_syncops->detach)(scr->scr_synccookie, waitok,
		    sc->sc_isconsole && wsdisplay_cons_pollmode ?
		      0 : wsswitch_cb1, sc);
		if (res == EAGAIN) {
			/* switch will be done asynchronously */
			return (0);
		}
	} else if (scr->scr_flags & SCR_GRAPHICS) {
		/* no way to save state */
		res = EBUSY;
	}
#endif

#ifdef HAVE_WSMOUSED_SUPPORT
	mouse_remove(scr);
#endif

	return (wsdisplay_switch1(sc, res, waitok));
}

void
wsdisplay_reset(struct device *dev, enum wsdisplay_resetops op)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;

	scr = sc->sc_focus;

	if (!scr)
		return;

	switch (op) {
	case WSDISPLAY_RESETEMUL:
		(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
		    WSEMUL_RESET);
		break;
	case WSDISPLAY_RESETCLOSE:
		wsdisplay_closescreen(sc, scr);
		break;
	}
}

#ifdef WSDISPLAY_COMPAT_USL
/*
 * Interface for (external) VT switch / process synchronization code
 */
int
wsscreen_attach_sync(struct wsscreen *scr, const struct wscons_syncops *ops,
    void *cookie)
{
	if (scr->scr_syncops) {
		/*
		 * The screen is already claimed.
		 * Check if the owner is still alive.
		 */
		if ((*scr->scr_syncops->check)(scr->scr_synccookie))
			return (EBUSY);
	}
	scr->scr_syncops = ops;
	scr->scr_synccookie = cookie;
	return (0);
}

int
wsscreen_detach_sync(struct wsscreen *scr)
{
	if (!scr->scr_syncops)
		return (EINVAL);
	scr->scr_syncops = NULL;
	return (0);
}

int
wsscreen_lookup_sync(struct wsscreen *scr,
    const struct wscons_syncops *ops, /* used as ID */
    void **cookiep)
{
	if (!scr->scr_syncops || ops != scr->scr_syncops)
		return (EINVAL);
	*cookiep = scr->scr_synccookie;
	return (0);
}
#endif

/*
 * Interface to virtual screen stuff
 */
int
wsdisplay_maxscreenidx(struct wsdisplay_softc *sc)
{
	return (WSDISPLAY_MAXSCREEN - 1);
}

int
wsdisplay_screenstate(struct wsdisplay_softc *sc, int idx)
{
	if (idx < 0 || idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);
	if (!sc->sc_scr[idx])
		return (ENXIO);
	return ((sc->sc_scr[idx]->scr_flags & SCR_OPEN) ? EBUSY : 0);
}

int
wsdisplay_getactivescreen(struct wsdisplay_softc *sc)
{
	return (sc->sc_focus ? sc->sc_focusidx : WSDISPLAY_NULLSCREEN);
}

int
wsscreen_switchwait(struct wsdisplay_softc *sc, int no)
{
	struct wsscreen *scr;
	int s, res = 0;

	if (no == WSDISPLAY_NULLSCREEN) {
		s = spltty();
		while (sc->sc_focus && res == 0) {
			res = tsleep(sc, PCATCH, "wswait", 0);
		}
		splx(s);
		return (res);
	}

	if (no < 0 || no >= WSDISPLAY_MAXSCREEN)
		return (ENXIO);
	scr = sc->sc_scr[no];
	if (!scr)
		return (ENXIO);

	s = spltty();
	if (scr != sc->sc_focus) {
		scr->scr_flags |= SCR_WAITACTIVE;
		res = tsleep(scr, PCATCH, "wswait2", 0);
		if (scr != sc->sc_scr[no])
			res = ENXIO; /* disappeared in the meantime */
		else
			scr->scr_flags &= ~SCR_WAITACTIVE;
	}
	splx(s);
	return (res);
}

void
wsdisplay_kbdholdscr(struct wsscreen *scr, int hold)
{
	if (hold)
		scr->scr_hold_screen = 1;
	else {
		scr->scr_hold_screen = 0;
		timeout_add(&scr->scr_tty->t_rstrt_to, 0); /* "immediate" */
	}
}

void
wsdisplay_kbdholdscreen(struct device *dev, int hold)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;

	scr = sc->sc_focus;
	if (scr != NULL && WSSCREEN_HAS_TTY(scr))
		wsdisplay_kbdholdscr(scr, hold);
}

#if NWSKBD > 0
void
wsdisplay_set_console_kbd(struct wsevsrc *src)
{
	if (wsdisplay_console_device == NULL) {
		src->me_dispdv = NULL;
		return;
	}
#if NWSMUX > 0
	if (wsmux_attach_sc((struct wsmux_softc *)
			    wsdisplay_console_device->sc_input, src)) {
		src->me_dispdv = NULL;
		return;
	}
#else
	wsdisplay_console_device->sc_input = src;
#endif
	src->me_dispdv = &wsdisplay_console_device->sc_dv;
}

#if NWSMUX == 0
int
wsdisplay_set_kbd(struct device *disp, struct wsevsrc *kbd)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)disp;

	if (sc->sc_input != NULL)
		return (EBUSY);

	sc->sc_input = kbd;

	return (0);
}
#endif

#endif /* NWSKBD > 0 */

/*
 * Console interface.
 */
void
wsdisplay_cnputc(dev_t dev, int i)
{
	struct wsscreen_internal *dc;
	char c = i;

	if (!wsdisplay_console_initted)
		return;

	if (wsdisplay_console_device != NULL &&
	    (wsdisplay_console_device->sc_scr[0] != NULL) &&
	    (wsdisplay_console_device->sc_scr[0]->scr_flags & SCR_GRAPHICS))
		return;

	dc = &wsdisplay_console_conf;
#ifdef HAVE_BURNER_SUPPORT
	/*wsdisplay_burn(wsdisplay_console_device, WSDISPLAY_BURN_OUTPUT);*/
#endif
	(void)(*dc->wsemul->output)(dc->wsemulcookie, &c, 1, 1);
}

int
wsdisplay_getc_dummy(dev_t dev)
{
	/* panic? */
	return (0);
}

void
wsdisplay_pollc(dev_t dev, int on)
{

	wsdisplay_cons_pollmode = on;

	/* notify to fb drivers */
	if (wsdisplay_console_device != NULL &&
	    wsdisplay_console_device->sc_accessops->pollc != NULL)
		(*wsdisplay_console_device->sc_accessops->pollc)
		    (wsdisplay_console_device->sc_accesscookie, on);

	/* notify to kbd drivers */
	if (wsdisplay_cons_kbd_pollc)
		(*wsdisplay_cons_kbd_pollc)(dev, on);
}

void
wsdisplay_set_cons_kbd(int (*get)(dev_t), void (*poll)(dev_t, int),
    void (*bell)(dev_t, u_int, u_int, u_int))
{
	wsdisplay_cons.cn_getc = get;
	wsdisplay_cons.cn_bell = bell;
	wsdisplay_cons_kbd_pollc = poll;
}

void
wsdisplay_unset_cons_kbd(void)
{
	wsdisplay_cons.cn_getc = wsdisplay_getc_dummy;
	wsdisplay_cons.cn_bell = NULL;
	wsdisplay_cons_kbd_pollc = NULL;
}

/*
 * Switch the console display to its first screen.
 */
void
wsdisplay_switchtoconsole(void)
{
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;

	if (wsdisplay_console_device != NULL && cn_tab == &wsdisplay_cons) {
		sc = wsdisplay_console_device;
		if ((scr = sc->sc_scr[0]) == NULL)
			return;
		(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
		    scr->scr_dconf->emulcookie, 0, NULL, NULL);
	}
}

/*
 * Switch rhe console display to its ddb screen, avoiding locking
 * where we can.
 */
void
wsdisplay_enter_ddb(void)
{
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;

	if (wsdisplay_console_device != NULL && cn_tab == &wsdisplay_cons) {
		sc = wsdisplay_console_device;
		if ((scr = sc->sc_scr[0]) == NULL)
			return;
		if (sc->sc_accessops->enter_ddb) {
			(*sc->sc_accessops->enter_ddb)(sc->sc_accesscookie,
			    scr->scr_dconf->emulcookie);
		} else {
			(*sc->sc_accessops->show_screen)(sc->sc_accesscookie,
			    scr->scr_dconf->emulcookie, 0, NULL, NULL);
		}
	}
}

/*
 * Deal with the xserver doing driver in userland and thus screwing up suspend
 * and resume by switching away from it at suspend/resume time.
 *
 * these functions must be called from the MD suspend callback, since we may
 * need to sleep if we have a user (probably an X server) on a vt. therefore
 * this can't be a config_suspend() hook.
 */
void
wsdisplay_suspend(void)
{
	int	i;

	for (i = 0; i < wsdisplay_cd.cd_ndevs; i++)
		if (wsdisplay_cd.cd_devs[i] != NULL)
			wsdisplay_suspend_device(wsdisplay_cd.cd_devs[i]);
}

void
wsdisplay_suspend_device(struct device *dev)
{
	struct wsdisplay_softc	*sc = (struct wsdisplay_softc *)dev;
	struct wsscreen		*scr;
	int			 active, idx, ret = 0, s;
	
	if ((active = wsdisplay_getactivescreen(sc)) == WSDISPLAY_NULLSCREEN)
		return;

	scr = sc->sc_scr[active];
	/*
	 * We want to switch out of graphics mode for the suspend, but
	 * only if we're in WSDISPLAY_MODE_MAPPED.
	 */
retry:
	idx = WSDISPLAY_MAXSCREEN;
	if (scr->scr_flags & SCR_GRAPHICS &&
	    (scr->scr_flags & SCR_DUMBFB) == 0) {
		for (idx = 0; idx < WSDISPLAY_MAXSCREEN; idx++) {
			if (sc->sc_scr[idx] == NULL || sc->sc_scr[idx] == scr)
				continue;

			if ((sc->sc_scr[idx]->scr_flags & SCR_GRAPHICS) == 0)
				break;
		}
	}

	/* if we don't have anything to switch to, we can't do anything */
	if (idx == WSDISPLAY_MAXSCREEN)
		return;

	/*
	 * we do a lot of magic here because we need to know that the
	 * switch has completed before we return
	 */
	ret = wsdisplay_switch((struct device *)sc, idx, 1);
	if (ret == EBUSY) {
		/* XXX sleep on what's going on */
		goto retry;
	} else if (ret)
		return;

	s = spltty();
	sc->sc_resumescreen = active; /* block other vt switches until resume */
	splx(s);
	/*
	 * This will either return ENXIO (invalid (shouldn't happen) or
	 * wsdisplay disappeared (problem solved)), or EINTR/ERESTART.
	 * Not much we can do about the latter since we can't return to
	 * userland.
	 */
	(void)wsscreen_switchwait(sc, idx);
}

void
wsdisplay_resume(void)
{
	int	i;

	for (i = 0; i < wsdisplay_cd.cd_ndevs; i++)
		if (wsdisplay_cd.cd_devs[i] != NULL)
			wsdisplay_resume_device(wsdisplay_cd.cd_devs[i]);
}

void
wsdisplay_resume_device(struct device *dev)
{
	struct wsdisplay_softc	*sc = (struct wsdisplay_softc *)dev;
	int			 idx, s;

	if (sc->sc_resumescreen != WSDISPLAY_NULLSCREEN) {
		s = spltty();
		idx = sc->sc_resumescreen;
		sc->sc_resumescreen = WSDISPLAY_NULLSCREEN;
		wakeup(&sc->sc_resumescreen);
		splx(s);
		(void)wsdisplay_switch((struct device *)sc, idx, 1);
	}
}

#ifdef HAVE_SCROLLBACK_SUPPORT
void
wsscrollback(void *arg, int op)
{
	struct wsdisplay_softc *sc = arg;
	int lines;

	if (sc->sc_focus == NULL)
		return;

	if (op == WSDISPLAY_SCROLL_RESET)
		lines = 0;
	else {
		lines = sc->sc_focus->scr_dconf->scrdata->nrows - 1;
		if (op == WSDISPLAY_SCROLL_BACKWARD)
			lines = -lines;
	}

	if (sc->sc_accessops->scrollback) {
		(*sc->sc_accessops->scrollback)(sc->sc_accesscookie,
		    sc->sc_focus->scr_dconf->emulcookie, lines);
	}
}
#endif

#ifdef HAVE_BURNER_SUPPORT
/*
 * Update screen burner behaviour after either a screen focus change or
 * a screen mode change.
 * This is needed to allow X11 to manage screen blanking without any
 * interference from the kernel.
 */
void
wsdisplay_burner_setup(struct wsdisplay_softc *sc, struct wsscreen *scr)
{
	if (scr->scr_flags & SCR_GRAPHICS) {
		/* enable video _immediately_ if it needs to be... */
		if (sc->sc_burnman)
			wsdisplay_burner(sc);
		/* ...and disable the burner while X is running */
		if (sc->sc_burnout) {
			timeout_del(&sc->sc_burner);
			sc->sc_burnout = 0;
		}
	} else {
		/* reenable the burner after exiting from X */
		if (!sc->sc_burnman) {
			sc->sc_burnout = sc->sc_burnoutintvl;
			wsdisplay_burn(sc, sc->sc_burnflags);
		}
	}
}

void
wsdisplay_burn(void *v, u_int flags)
{
	struct wsdisplay_softc *sc = v;

	if ((flags & sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
	    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) &&
	    sc->sc_accessops->burn_screen) {
		if (sc->sc_burnout)
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		if (sc->sc_burnman)
			sc->sc_burnout = 0;
	}
}

void
wsdisplay_burner(void *v)
{
	struct wsdisplay_softc *sc = v;
	int s;

	if (sc->sc_accessops->burn_screen) {
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		    sc->sc_burnman, sc->sc_burnflags);
		s = spltty();
		if (sc->sc_burnman) {
			sc->sc_burnout = sc->sc_burnoutintvl;
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		} else
			sc->sc_burnout = sc->sc_burninintvl;
		sc->sc_burnman = !sc->sc_burnman;
		splx(s);
	}
}
#endif

#ifdef HAVE_WSMOUSED_SUPPORT
/*
 * wsmoused(8) support functions
 */

/*
 * Main function, called from wsdisplay_cfg_ioctl.
 */
int
wsmoused(struct wsdisplay_softc *sc, caddr_t data, int flag, struct proc *p)
{
	struct wscons_event mouse_event = *(struct wscons_event *)data;

	if (IS_MOTION_EVENT(mouse_event.type)) {
		if (sc->sc_focus != NULL)
			motion_event(sc->sc_focus, mouse_event.type,
			    mouse_event.value);
		return 0;
	}
	if (IS_BUTTON_EVENT(mouse_event.type)) {
		if (sc->sc_focus != NULL) {
			/* XXX tv_sec contains the number of clicks */
			if (mouse_event.type ==
			    WSCONS_EVENT_MOUSE_DOWN) {
				button_event(sc->sc_focus,
				    mouse_event.value,
				    mouse_event.time.tv_sec);
			} else
				button_event(sc->sc_focus,
				    mouse_event.value, 0);
		}
		return (0);
	}
	if (IS_CTRL_EVENT(mouse_event.type)) {
		return ctrl_event(sc, mouse_event.type,
		    mouse_event.value, p);
	}
	return -1;
}

/*
 * Mouse motion events
 */
void
motion_event(struct wsscreen *scr, u_int type, int value)
{
	switch (type) {
	case WSCONS_EVENT_MOUSE_DELTA_X:
		mouse_moverel(scr, value, 0);
		break;
	case WSCONS_EVENT_MOUSE_DELTA_Y:
		mouse_moverel(scr, 0, -value);
		break;
#ifdef HAVE_SCROLLBACK_SUPPORT
	case WSCONS_EVENT_MOUSE_DELTA_Z:
		mouse_zaxis(scr, value);
		break;
#endif
	default:
		break;
	}
}

/*
 * Button clicks events
 */
void
button_event(struct wsscreen *scr, int button, int clicks)
{
	switch (button) {
	case MOUSE_COPY_BUTTON:
		switch (clicks % 4) {
		case 0: /* button is up */
			mouse_copy_end(scr);
			mouse_copy_selection(scr);
			break;
		case 1: /* single click */
			mouse_copy_start(scr);
			mouse_copy_selection(scr);
			break;
		case 2: /* double click */
			mouse_copy_word(scr);
			mouse_copy_selection(scr);
			break;
		case 3: /* triple click */
			mouse_copy_line(scr);
			mouse_copy_selection(scr);
			break;
		}
		break;
	case MOUSE_PASTE_BUTTON:
		if (clicks != 0)
			mouse_paste(scr);
		break;
	case MOUSE_EXTEND_BUTTON:
		if (clicks != 0)
			mouse_copy_extend_after(scr);
		break;
	default:
		break;
	}
}

/*
 * Control events
 */
int
ctrl_event(struct wsdisplay_softc *sc, u_int type, int value, struct proc *p)
{
	struct wsscreen *scr;
	int i;

	switch (type) {
	case WSCONS_EVENT_WSMOUSED_OFF:
		CLR(sc->sc_flags, SC_PASTE_AVAIL);
		return (0);
	case WSCONS_EVENT_WSMOUSED_ON:
		if (!sc->sc_accessops->getchar)
			/* no wsmoused(8) support in the display driver */
			return (1);
		allocate_copybuffer(sc);
		CLR(sc->sc_flags, SC_PASTE_AVAIL);

		for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++)
			if ((scr = sc->sc_scr[i]) != NULL) {
				scr->mouse =
				    (WS_NCOLS(scr) * WS_NROWS(scr)) / 2;
				scr->cursor = scr->mouse;
				scr->cpy_start = 0;
				scr->cpy_end = 0;
				scr->orig_start = 0;
				scr->orig_end = 0;
				scr->mouse_flags = 0;
			}
		return (0);
	default:	/* can't happen, really */
		return 0;
	}
}

void
mouse_moverel(struct wsscreen *scr, int dx, int dy)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	u_int old_mouse = scr->mouse;
	int mouse_col = scr->mouse % N_COLS(dconf);
	int mouse_row = scr->mouse / N_COLS(dconf);

	/* update position */
	if (mouse_col + dx >= MAXCOL(dconf))
		mouse_col = MAXCOL(dconf);
	else {
		if (mouse_col + dx <= 0)
			mouse_col = 0;
		else
			mouse_col += dx;
	}
	if (mouse_row + dy >= MAXROW(dconf))
		mouse_row = MAXROW(dconf);
	else {
		if (mouse_row + dy <= 0)
			mouse_row = 0;
		else
			mouse_row += dy;
	}
	scr->mouse = mouse_row * N_COLS(dconf) + mouse_col;

	/* if we have moved */
	if (old_mouse != scr->mouse) {
		/* XXX unblank screen if display.ms_act */
		if (ISSET(scr->mouse_flags, SEL_IN_PROGRESS)) {
			/* selection in progress */
			mouse_copy_extend(scr);
		} else {
			inverse_char(scr, scr->mouse);
			if (ISSET(scr->mouse_flags, MOUSE_VISIBLE))
				inverse_char(scr, old_mouse);
			else
				SET(scr->mouse_flags, MOUSE_VISIBLE);
		}
	}
}

void
inverse_char(struct wsscreen *scr, u_int pos)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	int fg, bg, ul;
	int flags;
	int tmp;
	long attr;

	GETCHAR(scr, pos, &cell);

	(*dconf->emulops->unpack_attr)(dconf->emulcookie, cell.attr, &fg,
	    &bg, &ul);

	/*
	 * Display the mouse cursor as a color inverted cell whenever
	 * possible. If this is not possible, ask for the video reverse
	 * attribute.
	 */
	flags = 0;
	if (dconf->scrdata->capabilities & WSSCREEN_WSCOLORS) {
		flags |= WSATTR_WSCOLORS;
		tmp = fg;
		fg = bg;
		bg = tmp;
	} else if (dconf->scrdata->capabilities & WSSCREEN_REVERSE) {
		flags |= WSATTR_REVERSE;
	}
	if ((*dconf->emulops->alloc_attr)(dconf->emulcookie, fg, bg, flags |
	    (ul ? WSATTR_UNDERLINE : 0), &attr) == 0) {
		cell.attr = attr;
		PUTCHAR(dconf, pos, cell.uc, cell.attr);
	}
}

void
inverse_region(struct wsscreen *scr, u_int start, u_int end)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	u_int current_pos;
	u_int abs_end;

	/* sanity check, useful because 'end' can be (u_int)-1 */
	abs_end = N_COLS(dconf) * N_ROWS(dconf);
	if (end > abs_end)
		return;
	current_pos = start;
	while (current_pos <= end)
		inverse_char(scr, current_pos++);
}

/*
 * Return the number of contiguous blank characters between the right margin
 * if border == 1 or between the next non-blank character and the current mouse
 * cursor if border == 0
 */
u_int
skip_spc_right(struct wsscreen *scr, int border)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	u_int current = scr->cpy_end;
	u_int mouse_col = scr->cpy_end % N_COLS(dconf);
	u_int limit = current + (N_COLS(dconf) - mouse_col - 1);
	u_int res = 0;

	while (GETCHAR(scr, current, &cell) == 0 && cell.uc == ' ' &&
	    current <= limit) {
		current++;
		res++;
	}
	if (border == BORDER) {
		if (current > limit)
			return (res - 1);
		else
			return (0);
	} else {
		if (res != 0)
			return (res - 1);
		else
			return (res);
	}
}

/*
 * Return the number of contiguous blank characters between the first of the
 * contiguous blank characters and the current mouse cursor
 */
u_int
skip_spc_left(struct wsscreen *scr)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	u_int current = scr->cpy_start;
	u_int mouse_col = scr->mouse % N_COLS(dconf);
	u_int limit = current - mouse_col;
	u_int res = 0;

	while (GETCHAR(scr, current, &cell) == 0 && cell.uc == ' ' &&
	    current >= limit) {
		current--;
		res++;
	}
	if (res != 0)
		res--;
	return (res);
}

/*
 * Class of characters
 * Stolen from xterm sources of the Xfree project (see cvs tag below)
 * $TOG: button.c /main/76 1997/07/30 16:56:19 kaleb $
 */
static const int charClass[256] = {
/* NUL  SOH  STX  ETX  EOT  ENQ  ACK  BEL */
    32,   1,   1,   1,   1,   1,   1,   1,
/*  BS   HT   NL   VT   NP   CR   SO   SI */
     1,  32,   1,   1,   1,   1,   1,   1,
/* DLE  DC1  DC2  DC3  DC4  NAK  SYN  ETB */
     1,   1,   1,   1,   1,   1,   1,   1,
/* CAN   EM  SUB  ESC   FS   GS   RS   US */
     1,   1,   1,   1,   1,   1,   1,   1,
/*  SP    !    "    #    $    %    &    ' */
    32,  33,  34,  35,  36,  37,  38,  39,
/*   (    )    *    +    ,    -    .    / */
    40,  41,  42,  43,  44,  45,  46,  47,
/*   0    1    2    3    4    5    6    7 */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   8    9    :    ;    <    =    >    ? */
    48,  48,  58,  59,  60,  61,  62,  63,
/*   @@    A    B    C    D    E    F    G */
    64,  48,  48,  48,  48,  48,  48,  48,
/*   H    I    J    K    L    M    N    O */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   P    Q    R    S    T    U    V    W */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   X    Y    Z    [    \    ]    ^    _ */
    48,  48,  48,  91,  92,  93,  94,  48,
/*   `    a    b    c    d    e    f    g */
    96,  48,  48,  48,  48,  48,  48,  48,
/*   h    i    j    k    l    m    n    o */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   p    q    r    s    t    u    v    w */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   x    y    z    {    |    }    ~  DEL */
    48,  48,  48, 123, 124, 125, 126,   1,
/* x80  x81  x82  x83  IND  NEL  SSA  ESA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* HTS  HTJ  VTS  PLD  PLU   RI  SS2  SS3 */
     1,   1,   1,   1,   1,   1,   1,   1,
/* DCS  PU1  PU2  STS  CCH   MW  SPA  EPA */
     1,   1,   1,   1,   1,   1,   1,   1,
/* x98  x99  x9A  CSI   ST  OSC   PM  APC */
     1,   1,   1,   1,   1,   1,   1,   1,
/*   -    i   c/    L   ox   Y-    |   So */
   160, 161, 162, 163, 164, 165, 166, 167,
/*  ..   c0   ip   <<    _        R0    - */
   168, 169, 170, 171, 172, 173, 174, 175,
/*   o   +-    2    3    '    u   q|    . */
   176, 177, 178, 179, 180, 181, 182, 183,
/*   ,    1    2   >>  1/4  1/2  3/4    ? */
   184, 185, 186, 187, 188, 189, 190, 191,
/*  A`   A'   A^   A~   A:   Ao   AE   C, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  E`   E'   E^   E:   I`   I'   I^   I: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  D-   N~   O`   O'   O^   O~   O:    X */
    48,  48,  48,  48,  48,  48,  48, 216,
/*  O/   U`   U'   U^   U:   Y'    P    B */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  a`   a'   a^   a~   a:   ao   ae   c, */
    48,  48,  48,  48,  48,  48,  48,  48,
/*  e`   e'   e^   e:    i`  i'   i^   i: */
    48,  48,  48,  48,  48,  48,  48,  48,
/*   d   n~   o`   o'   o^   o~   o:   -: */
    48,  48,  48,  48,  48,  48,  48,  248,
/*  o/   u`   u'   u^   u:   y'    P   y: */
    48,  48,  48,  48,  48,  48,  48,  48
};

/*
 * Find the first blank beginning after the current cursor position
 */
u_int
skip_char_right(struct wsscreen *scr, u_int offset)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	u_int current = offset;
	u_int limit = current +
	    (N_COLS(dconf) - (scr->mouse % N_COLS(dconf)) - 1);
	u_int class;
	u_int res = 0;

	GETCHAR(scr, current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(scr, current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current <= limit) {
		current++;
		res++;
	}
	if (res != 0)
		res--;
	return (res);
}

/*
 * Find the first non-blank character before the cursor position
 */
u_int
skip_char_left(struct wsscreen *scr, u_int offset)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	u_int current = offset;
	u_int limit = current - (scr->mouse % N_COLS(dconf));
	u_int class;
	u_int res = 0;

	GETCHAR(scr, current, &cell);
	class = charClass[cell.uc & 0xff];
	while (GETCHAR(scr, current, &cell) == 0 &&
	    charClass[cell.uc & 0xff] == class && current >= limit) {
		current--;
		res++;
	}
	if (res != 0)
		res--;
	return (res);
}

/*
 * Compare character classes
 */
u_int
class_cmp(struct wsscreen *scr, u_int first, u_int second)
{
	struct wsdisplay_charcell cell;
	u_int first_class;
	u_int second_class;

	if (GETCHAR(scr, first, &cell) != 0)
		return (1);
	first_class = charClass[cell.uc & 0xff];
	if (GETCHAR(scr, second, &cell) != 0)
		return (1);
	second_class = charClass[cell.uc & 0xff];

	if (first_class != second_class)
		return (1);
	else
		return (0);
}

/*
 * Beginning of a copy operation
 */
void
mouse_copy_start(struct wsscreen *scr)
{
	u_int right;

	/* if no selection, then that's the first one */
	SET(scr->sc->sc_flags, SC_PASTE_AVAIL);

	/* remove the previous selection */
	if (ISSET(scr->mouse_flags, SEL_EXISTS))
		remove_selection(scr);

	/* initial show of the cursor */
	if (!ISSET(scr->mouse_flags, MOUSE_VISIBLE))
		inverse_char(scr, scr->mouse);

	scr->cpy_start = scr->cpy_end = scr->mouse;
	scr->orig_start = scr->cpy_start;
	scr->orig_end = scr->cpy_end;
	scr->cursor = scr->cpy_end + 1; /* init value */

	/* useful later, in mouse_copy_extend */
	right = skip_spc_right(scr, BORDER);
	if (right)
		SET(scr->mouse_flags, BLANK_TO_EOL);

	SET(scr->mouse_flags, SEL_IN_PROGRESS | SEL_EXISTS | SEL_BY_CHAR);
	CLR(scr->mouse_flags, SEL_BY_WORD | SEL_BY_LINE);
	CLR(scr->mouse_flags, MOUSE_VISIBLE); /* cursor hidden in selection */
}

/*
 * Copy of the word under the cursor
 */
void
mouse_copy_word(struct wsscreen *scr)
{
	struct wsdisplay_charcell cell;
	u_int right;
	u_int left;

	if (ISSET(scr->mouse_flags, SEL_EXISTS))
		remove_selection(scr);

	if (ISSET(scr->mouse_flags, MOUSE_VISIBLE))
		inverse_char(scr, scr->mouse);

	scr->cpy_start = scr->cpy_end = scr->mouse;

	if (GETCHAR(scr, scr->mouse, &cell) == 0 &&
	    IS_ALPHANUM(cell.uc)) {
		right = skip_char_right(scr, scr->cpy_end);
		left = skip_char_left(scr, scr->cpy_start);
	} else {
		right = skip_spc_right(scr, NO_BORDER);
		left = skip_spc_left(scr);
	}

	scr->cpy_start -= left;
	scr->cpy_end += right;
	scr->orig_start = scr->cpy_start;
	scr->orig_end = scr->cpy_end;
	scr->cursor = scr->cpy_end + 1; /* init value, never happen */
	inverse_region(scr, scr->cpy_start, scr->cpy_end);

	SET(scr->mouse_flags, SEL_IN_PROGRESS | SEL_EXISTS | SEL_BY_WORD);
	CLR(scr->mouse_flags, SEL_BY_CHAR | SEL_BY_LINE);
	/* mouse cursor hidden in the selection */
	CLR(scr->mouse_flags, BLANK_TO_EOL | MOUSE_VISIBLE);
}

/*
 * Copy of the current line
 */
void
mouse_copy_line(struct wsscreen *scr)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	u_int row = scr->mouse / N_COLS(dconf);

	if (ISSET(scr->mouse_flags, SEL_EXISTS))
		remove_selection(scr);

	if (ISSET(scr->mouse_flags, MOUSE_VISIBLE))
		inverse_char(scr, scr->mouse);

	scr->cpy_start = row * N_COLS(dconf);
	scr->cpy_end = scr->cpy_start + (N_COLS(dconf) - 1);
	scr->orig_start = scr->cpy_start;
	scr->orig_end = scr->cpy_end;
	scr->cursor = scr->cpy_end + 1;
	inverse_region(scr, scr->cpy_start, scr->cpy_end);

	SET(scr->mouse_flags, SEL_IN_PROGRESS | SEL_EXISTS | SEL_BY_LINE);
	CLR(scr->mouse_flags, SEL_BY_CHAR | SEL_BY_WORD);
	/* mouse cursor hidden in the selection */
	CLR(scr->mouse_flags, BLANK_TO_EOL | MOUSE_VISIBLE);
}

/*
 * End of a copy operation
 */
void
mouse_copy_end(struct wsscreen *scr)
{
	CLR(scr->mouse_flags, SEL_IN_PROGRESS);
	if (ISSET(scr->mouse_flags, SEL_BY_WORD) ||
	    ISSET(scr->mouse_flags, SEL_BY_LINE)) {
		if (scr->cursor != scr->cpy_end + 1)
			inverse_char(scr, scr->cursor);
		scr->cursor = scr->cpy_end + 1;
	}
}


/*
 * Generic selection extend function
 */
void
mouse_copy_extend(struct wsscreen *scr)
{
	if (ISSET(scr->mouse_flags, SEL_BY_CHAR))
		mouse_copy_extend_char(scr);
	if (ISSET(scr->mouse_flags, SEL_BY_WORD))
		mouse_copy_extend_word(scr);
	if (ISSET(scr->mouse_flags, SEL_BY_LINE))
		mouse_copy_extend_line(scr);
}

/*
 * Extend a selected region, character by character
 */
void
mouse_copy_extend_char(struct wsscreen *scr)
{
	u_int right;

	if (!ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		if (ISSET(scr->mouse_flags, BLANK_TO_EOL)) {
			/*
			 * First extension of selection. We handle special
			 * cases of blank characters to eol
			 */

			right = skip_spc_right(scr, BORDER);
			if (scr->mouse > scr->orig_start) {
				/* the selection goes to the lower part of
				   the screen */

				/* remove the previous cursor, start of
				   selection is now next line */
				inverse_char(scr, scr->cpy_start);
				scr->cpy_start += (right + 1);
				scr->cpy_end = scr->cpy_start;
				scr->orig_start = scr->cpy_start;
				/* simulate the initial mark */
				inverse_char(scr, scr->cpy_start);
			} else {
				/* the selection goes to the upper part
				   of the screen */
				/* remove the previous cursor, start of
				   selection is now at the eol */
				inverse_char(scr, scr->cpy_start);
				scr->orig_start += (right + 1);
				scr->cpy_start = scr->orig_start - 1;
				scr->cpy_end = scr->orig_start - 1;
				/* simulate the initial mark */
				inverse_char(scr, scr->cpy_start);
			}
			CLR(scr->mouse_flags, BLANK_TO_EOL);
		}

		if (scr->mouse < scr->orig_start &&
		    scr->cpy_end >= scr->orig_start) {
			/* we go to the upper part of the screen */

			/* reverse the old selection region */
			remove_selection(scr);
			scr->cpy_end = scr->orig_start - 1;
			scr->cpy_start = scr->orig_start;
		}
		if (scr->cpy_start < scr->orig_start &&
		    scr->mouse >= scr->orig_start) {
			/* we go to the lower part of the screen */

			/* reverse the old selection region */

			remove_selection(scr);
			scr->cpy_start = scr->orig_start;
			scr->cpy_end = scr->orig_start - 1;
		}
		/* restore flags cleared in remove_selection() */
		SET(scr->mouse_flags, SEL_IN_PROGRESS | SEL_EXISTS);
	}

	if (scr->mouse >= scr->orig_start) {
		/* lower part of the screen */
		if (scr->mouse > scr->cpy_end) {
			/* extending selection */
			inverse_region(scr, scr->cpy_end + 1, scr->mouse);
		} else {
			/* reducing selection */
			inverse_region(scr, scr->mouse + 1, scr->cpy_end);
		}
		scr->cpy_end = scr->mouse;
	} else {
		/* upper part of the screen */
		if (scr->mouse < scr->cpy_start) {
			/* extending selection */
			inverse_region(scr, scr->mouse, scr->cpy_start - 1);
		} else {
			/* reducing selection */
			inverse_region(scr, scr->cpy_start, scr->mouse - 1);
		}
		scr->cpy_start = scr->mouse;
	}
}

/*
 * Extend a selected region, word by word
 */
void
mouse_copy_extend_word(struct wsscreen *scr)
{
	u_int old_cpy_end;
	u_int old_cpy_start;

	if (!ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		/* remove cursor in selection (black one) */
		if (scr->cursor != scr->cpy_end + 1)
			inverse_char(scr, scr->cursor);

		/* now, switch between lower and upper part of the screen */
		if (scr->mouse < scr->orig_start &&
		    scr->cpy_end >= scr->orig_start) {
			/* going to the upper part of the screen */
			inverse_region(scr, scr->orig_end + 1, scr->cpy_end);
			scr->cpy_end = scr->orig_end;
		}

		if (scr->mouse > scr->orig_end &&
		    scr->cpy_start <= scr->orig_start) {
			/* going to the lower part of the screen */
			inverse_region(scr, scr->cpy_start,
			    scr->orig_start - 1);
			scr->cpy_start = scr->orig_start;
		}
	}

	if (scr->mouse >= scr->orig_start) {
		/* lower part of the screen */
		if (scr->mouse > scr->cpy_end) {
			/* extending selection */
			old_cpy_end = scr->cpy_end;
			scr->cpy_end = scr->mouse +
			    skip_char_right(scr, scr->mouse);
			inverse_region(scr, old_cpy_end + 1, scr->cpy_end);
		} else {
			if (class_cmp(scr, scr->mouse, scr->mouse + 1)) {
				/* reducing selection (remove last word) */
				old_cpy_end = scr->cpy_end;
				scr->cpy_end = scr->mouse;
				inverse_region(scr, scr->cpy_end + 1,
				    old_cpy_end);
			} else {
				old_cpy_end = scr->cpy_end;
				scr->cpy_end = scr->mouse +
				    skip_char_right(scr, scr->mouse);
				if (scr->cpy_end != old_cpy_end) {
					/* reducing selection, from the end of
					 * next word */
					inverse_region(scr, scr->cpy_end + 1,
					    old_cpy_end);
				}
			}
		}
	} else {
		/* upper part of the screen */
		if (scr->mouse < scr->cpy_start) {
			/* extending selection */
			old_cpy_start = scr->cpy_start;
			scr->cpy_start = scr->mouse -
			    skip_char_left(scr, scr->mouse);
			inverse_region(scr, scr->cpy_start, old_cpy_start - 1);
		} else {
			if (class_cmp(scr, scr->mouse - 1, scr->mouse)) {
				/* reducing selection (remove last word) */
				old_cpy_start = scr->cpy_start;
				scr->cpy_start = scr->mouse;
				inverse_region(scr, old_cpy_start,
				    scr->cpy_start - 1);
			} else {
				old_cpy_start = scr->cpy_start;
				scr->cpy_start = scr->mouse -
				    skip_char_left(scr, scr->mouse);
				if (scr->cpy_start != old_cpy_start) {
					inverse_region(scr, old_cpy_start,
					    scr->cpy_start - 1);
				}
			}
		}
	}

	if (!ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		/* display new cursor */
		scr->cursor = scr->mouse;
		inverse_char(scr, scr->cursor);
	}
}

/*
 * Extend a selected region, line by line
 */
void
mouse_copy_extend_line(struct wsscreen *scr)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	u_int old_row;
	u_int new_row;
	u_int old_cpy_start;
	u_int old_cpy_end;

	if (!ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		/* remove cursor in selection (black one) */
		if (scr->cursor != scr->cpy_end + 1)
			inverse_char(scr, scr->cursor);

		/* now, switch between lower and upper part of the screen */
		if (scr->mouse < scr->orig_start &&
		    scr->cpy_end >= scr->orig_start) {
			/* going to the upper part of the screen */
			inverse_region(scr, scr->orig_end + 1, scr->cpy_end);
			scr->cpy_end = scr->orig_end;
		}

		if (scr->mouse > scr->orig_end &&
		    scr->cpy_start <= scr->orig_start) {
			/* going to the lower part of the screen */
			inverse_region(scr, scr->cpy_start,
			    scr->orig_start - 1);
			scr->cpy_start = scr->orig_start;
		}
	}

	if (scr->mouse >= scr->orig_start) {
		/* lower part of the screen */
		if (scr->cursor == scr->cpy_end + 1)
			scr->cursor = scr->cpy_end;
		old_row = scr->cursor / N_COLS(dconf);
		new_row = scr->mouse / N_COLS(dconf);
		old_cpy_end = scr->cpy_end;
		scr->cpy_end = new_row * N_COLS(dconf) + MAXCOL(dconf);
		if (new_row > old_row)
			inverse_region(scr, old_cpy_end + 1, scr->cpy_end);
		else if (new_row < old_row)
			inverse_region(scr, scr->cpy_end + 1, old_cpy_end);
	} else {
		/* upper part of the screen */
		old_row = scr->cursor / N_COLS(dconf);
		new_row = scr->mouse / N_COLS(dconf);
		old_cpy_start = scr->cpy_start;
		scr->cpy_start = new_row * N_COLS(dconf);
		if (new_row < old_row)
			inverse_region(scr, scr->cpy_start, old_cpy_start - 1);
		else if (new_row > old_row)
			inverse_region(scr, old_cpy_start, scr->cpy_start - 1);
	}

	if (!ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		/* display new cursor */
		scr->cursor = scr->mouse;
		inverse_char(scr, scr->cursor);
	}
}

/*
 * Add an extension to a selected region, word by word
 */
void
mouse_copy_extend_after(struct wsscreen *scr)
{
	u_int start_dist;
	u_int end_dist;

	if (ISSET(scr->mouse_flags, SEL_EXISTS)) {
		SET(scr->mouse_flags, SEL_EXT_AFTER);
		mouse_hide(scr); /* hide current cursor */

		if (scr->cpy_start > scr->mouse)
			start_dist = scr->cpy_start - scr->mouse;
		else
			start_dist = scr->mouse - scr->cpy_start;
		if (scr->mouse > scr->cpy_end)
			end_dist = scr->mouse - scr->cpy_end;
		else
			end_dist = scr->cpy_end - scr->mouse;
		if (start_dist < end_dist) {
			/* upper part of the screen*/
			scr->orig_start = scr->mouse + 1;
			/* only used in mouse_copy_extend_line() */
			scr->cursor = scr->cpy_start;
		} else {
			/* lower part of the screen */
			scr->orig_start = scr->mouse;
			/* only used in mouse_copy_extend_line() */
			scr->cursor = scr->cpy_end;
		}
		if (ISSET(scr->mouse_flags, SEL_BY_CHAR))
			mouse_copy_extend_char(scr);
		if (ISSET(scr->mouse_flags, SEL_BY_WORD))
			mouse_copy_extend_word(scr);
		if (ISSET(scr->mouse_flags, SEL_BY_LINE))
			mouse_copy_extend_line(scr);
		mouse_copy_selection(scr);
	}
}

void
mouse_hide(struct wsscreen *scr)
{
	if (ISSET(scr->mouse_flags, MOUSE_VISIBLE)) {
		inverse_char(scr, scr->mouse);
		CLR(scr->mouse_flags, MOUSE_VISIBLE);
	}
}

/*
 * Remove a previously selected region
 */
void
remove_selection(struct wsscreen *scr)
{
	if (ISSET(scr->mouse_flags, SEL_EXT_AFTER)) {
		/* reset the flag indicating an extension of selection */
		CLR(scr->mouse_flags, SEL_EXT_AFTER);
	}
	inverse_region(scr, scr->cpy_start, scr->cpy_end);
	CLR(scr->mouse_flags, SEL_IN_PROGRESS | SEL_EXISTS);
}

/*
 * Put the current visual selection in the selection buffer
 */
void
mouse_copy_selection(struct wsscreen *scr)
{
	struct wsscreen_internal *dconf = scr->scr_dconf;
	struct wsdisplay_charcell cell;
	u_int current = 0;
	u_int blank = current;
	u_int buf_end = (N_COLS(dconf) + 1) * N_ROWS(dconf);
	u_int sel_cur;
	u_int sel_end;

	sel_cur = scr->cpy_start;
	sel_end = scr->cpy_end;

	while (sel_cur <= sel_end && current < buf_end - 1) {
		if (GETCHAR(scr, sel_cur, &cell) != 0)
			break;
		scr->sc->sc_copybuffer[current] = cell.uc;
		if (!IS_SPACE(cell.uc))
			blank = current + 1; /* first blank after non-blank */
		current++;
		if (sel_cur % N_COLS(dconf) == MAXCOL(dconf)) {
			/*
			 * If we are on the last column of the screen,
			 * insert a carriage return.
			 */
			scr->sc->sc_copybuffer[blank] = '\r';
			current = ++blank;
		}
		sel_cur++;
	}

	scr->sc->sc_copybuffer[current] = '\0';
}

/*
 * Paste the current selection
 */
void
mouse_paste(struct wsscreen *scr)
{
	char *current = scr->sc->sc_copybuffer;
	struct tty *tp;
	u_int len;

	if (ISSET(scr->sc->sc_flags, SC_PASTE_AVAIL)) {
		if (!WSSCREEN_HAS_TTY(scr))
			return;

		tp = scr->scr_tty;
		for (len = strlen(scr->sc->sc_copybuffer); len != 0; len--)
			(*linesw[tp->t_line].l_rint)(*current++, tp);
	}
}

#ifdef HAVE_SCROLLBACK_SUPPORT
/*
 * Handle the z axis.
 * The z axis (roller or wheel) is mapped by default to scrollback.
 */
void
mouse_zaxis(struct wsscreen *scr, int z)
{
	if (z < 0)
		wsscrollback(scr->sc, WSDISPLAY_SCROLL_BACKWARD);
	else
		wsscrollback(scr->sc, WSDISPLAY_SCROLL_FORWARD);
}
#endif

/*
 * Allocate the copy buffer. The size is:
 * (cols + 1) * (rows)
 * (+1 for '\n' at the end of lines),
 * where cols and rows are the maximum of column and rows of all screens.
 */
void
allocate_copybuffer(struct wsdisplay_softc *sc)
{
	int nscreens = sc->sc_scrdata->nscreens;
	int i, s;
	const struct wsscreen_descr **screens_list = sc->sc_scrdata->screens;
	const struct wsscreen_descr *current;
	u_int size = sc->sc_copybuffer_size;

	s = spltty();
	for (i = 0; i < nscreens; i++) {
		current = *screens_list;
		if ((current->ncols + 1) * current->nrows > size)
			size = (current->ncols + 1) * current->nrows;
		screens_list++;
	}
	if (size != sc->sc_copybuffer_size && sc->sc_copybuffer_size != 0) {
		bzero(sc->sc_copybuffer, sc->sc_copybuffer_size);
		free(sc->sc_copybuffer, M_DEVBUF, 0);
	}
	if ((sc->sc_copybuffer = (char *)malloc(size, M_DEVBUF, M_NOWAIT)) ==
	    NULL) {
		printf("%s: couldn't allocate copy buffer\n",
		    sc->sc_dv.dv_xname);
		size = 0;
	}
	sc->sc_copybuffer_size = size;
	splx(s);
}

/* Remove selection and cursor on current screen */
void
mouse_remove(struct wsscreen *scr)
{
	if (ISSET(scr->mouse_flags, SEL_EXISTS))
		remove_selection(scr);

	mouse_hide(scr);
}

#endif /* HAVE_WSMOUSED_SUPPORT */
@


1.128
log
@Add a enter_ddb() "accessop" to wsdisplay(4) to allow KMS drivers to bypass
the modeset lock when entering ddb.  This avoids triggering various asserts
when the kernel panics while running X.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.127 2017/07/18 21:27:50 kettenis Exp $ */
d2153 1
a2153 1
		if (sc->sc_accessops) {
@


1.127
log
@Prevent integer overflow in WSDISPLAYIO_LDFONT ioctl.

Issue found by Ilja van Sprundel.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.126 2017/01/11 08:21:33 fcambus Exp $ */
d2136 24
@


1.126
log
@Use explicit_bzero() to wipe copybuffer when logging out of the console.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.125 2016/11/07 00:26:33 guenther Exp $ */
d1307 4
@


1.126.4.1
log
@Prevent integer overflow in WSDISPLAYIO_LDFONT ioctl.
Issue found by Ilja van Sprundel.
errata 024
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.126 2017/01/11 08:21:33 fcambus Exp $ */
a1306 4
			return (EINVAL);
		if (d->fontheight > 64 || d->stride > 8) /* 64x64 pixels */
			return (EINVAL);
		if (d->numchars > 65536) /* unicode plane */
@


1.125
log
@Split PID from TID, giving processes a PID unrelated to the TID of their
initial thread

ok jsing@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.124 2015/09/08 11:13:20 deraadt Exp $ */
d938 1
a938 1
		bzero(sc->sc_copybuffer, sc->sc_copybuffer_size);
@


1.124
log
@sizes for free(); checked by semarie
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.123 2015/05/08 19:17:20 miod Exp $ */
d1429 1
a1429 1
	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_selpid == 0)
@


1.124.4.1
log
@Prevent integer overflow in WSDISPLAYIO_LDFONT ioctl.
Issue found by Ilja van Sprundel.
errata 37
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.124 2015/09/08 11:13:20 deraadt Exp $ */
a1306 4
			return (EINVAL);
		if (d->fontheight > 64 || d->stride > 8) /* 64x64 pixels */
			return (EINVAL);
		if (d->numchars > 65536) /* unicode plane */
@


1.123
log
@When changing screen saver parameters with wsconsctl (or any other way to
perform ioctls), check the flags of the currently displayed screen in order
to decide whether the screen saver needs to be retriggered, rather than the
flags of the device we are issuing the ioctl on.

wsconsctl will always use ttyC0, while the X server may run on another
virtual screen (such as ttyC4), and the kernel screen saver would then be
reenabled behind the X server's back.

While there, apply this `should the screen burner get reenabled or disabled?'
logic at the end of every virtual screen switch. The screen burner will now
get reenabled when switching from X11 to a virtual text console, and disabled
when switching back to X.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.122 2015/05/07 00:16:25 jsg Exp $ */
d267 1
a267 1
	scr = malloc(sizeof(struct wsscreen), M_DEVBUF, M_ZERO | M_NOWAIT);
d279 1
a279 2
		dconf = malloc(sizeof(struct wsscreen_internal),
		    M_DEVBUF, M_NOWAIT);
d301 2
a302 2
		free(dconf, M_DEVBUF, 0);
	free(scr, M_DEVBUF, 0);
d317 2
a318 2
	free(scr->scr_dconf, M_DEVBUF, 0);
	free(scr, M_DEVBUF, 0);
d1315 1
a1315 1
			free(buf, M_DEVBUF, 0);
d1322 1
a1322 1
			free(buf, M_DEVBUF, 0);
@


1.122
log
@remove a surplus tab
from miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.121 2014/10/27 13:55:05 mpi Exp $ */
d147 2
d165 4
a168 4
	int	sc_burnoutintvl;
	int	sc_burninintvl;
	int	sc_burnout;
	int	sc_burnman;
d485 1
a485 1
		sc->sc_focus = 0;
d490 1
a490 1
	sc->sc_scr[idx] = 0;
d1147 1
d1150 1
a1150 14
			/* enable video _immediately_ if it nedes to be... */
			if (sc->sc_burnman)
				wsdisplay_burner(sc);
			/* ...and disable the burner while X is running */
			if (sc->sc_burnout) {
				timeout_del(&sc->sc_burner);
				sc->sc_burnout = 0;
			}
		} else {
			/* reenable the burner after exiting from X */
			if (!sc->sc_burnman) {
				sc->sc_burnout = sc->sc_burnoutintvl;
				wsdisplay_burn(sc, sc->sc_burnflags);
			}
a1151 1
		}
d1163 1
a1163 1
		d->data = 0;
d1195 3
d1200 9
a1208 10
			error = EINVAL;
		else {
			error = 0;
			sc->sc_burnflags = d->flags;
			/* disable timeout if necessary */
			if ((sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
			    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) == 0) {
				if (sc->sc_burnout)
					timeout_del(&sc->sc_burner);
			}
d1210 5
a1215 1
			error = 0;
d1220 1
a1220 1
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
a1224 1
			error = 0;
d1229 1
a1229 1
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
d1234 1
d1662 1
a1662 1
			sc->sc_focus = 0;
d1686 5
d1722 1
a1722 1
			sc->sc_focus = 0;
d1772 1
a1772 1
			sc->sc_focus = 0;
d1919 1
a1919 1
	scr->scr_syncops = 0;
d2115 1
a2115 1
	wsdisplay_cons_kbd_pollc = 0;
d2261 27
@


1.121
log
@Stop supporting wsmoused and X in parallel.  This code is racy and
known to break mice upon resume.

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.120 2014/09/14 14:17:25 jsg Exp $ */
d3271 1
a3271 1
			screens_list++;
@


1.120
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.119 2014/07/12 18:48:53 tedu Exp $ */
a60 1
#include "wsmouse.h"
a67 4
#if NWSMOUSE > 0
#include <dev/wscons/wsmousevar.h>
#endif

a69 4
#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

a185 3
	dev_t wsmoused_dev; /* device opened by wsmoused(8), when active */
	int wsmoused_sleep; /* true when wsmoused(8) is sleeping */

a1141 8
#ifdef HAVE_WSMOUSED_SUPPORT
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is starting
			 */
			wsmoused_release(sc);
#endif

a1154 1
#endif
a1155 1
#ifdef HAVE_BURNER_SUPPORT
a1161 8

#ifdef HAVE_WSMOUSED_SUPPORT
			/*
			 * wsmoused cohabitation with X-Window support
			 * X-Window is ending
			 */
			wsmoused_wakeup(sc);
#endif
d1467 2
a1468 7
		if (scr == sc->sc_focus) {
			if (ISSET(scr->mouse_flags, SEL_EXISTS))
				/* hide a potential selection */
				remove_selection(scr);
			/* hide a potential mouse cursor */
			mouse_hide(scr);
		}
a1847 46

#ifdef HAVE_WSMOUSED_SUPPORT
	/*
	 *  wsmoused cohabitation with X-Window support
	 *
	 *  Detect switch from a graphic to text console and vice-versa
	 *  This only happen when switching from X-Window to text mode and
	 *  switching back from text mode to X-Window.
	 *
	 *  scr_flags is not yet flagged with SCR_GRAPHICS when X-Window starts
	 *  (KD_GRAPHICS ioctl happens after VT_ACTIVATE ioctl in
	 *  xf86OpenPcvt()). Conversely, scr_flags is no longer flagged with
	 *  SCR_GRAPHICS when X-Window stops. In this case, the first of the
	 *  three following 'if' statements is evaluated.
	 *  We handle wsmoused(8) events the WSDISPLAYIO_SMODE ioctl.
	 */

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (no == WSDISPLAY_NULLSCREEN ||
	     !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a text console to another text console */
		/* XXX evaluated when the X-server starts or stops, see above */

		/* remove a potential wsmoused(8) selection */
		mouse_remove(scr);
	}

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (no != WSDISPLAY_NULLSCREEN &&
	     (sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a text console to a graphic console */

		/* remove a potential wsmoused(8) selection */
		mouse_remove(scr);
		wsmoused_release(sc);
	}

	if ((scr->scr_flags & SCR_GRAPHICS) &&
	    (no == WSDISPLAY_NULLSCREEN ||
	     !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a graphic console to a text console */

		wsmoused_wakeup(sc);
	}
#endif	/* HAVE_WSMOUSED_SUPPORT */

d1864 4
d2350 1
d2354 1
d2407 1
a2407 1
	int i, error;
a2411 1
		sc->wsmoused_dev = 0;
a2412 8
	case WSCONS_EVENT_WSMOUSED_SLEEP:
		/* sleeping until next switch to text mode */
		sc->wsmoused_sleep = 1;
		error = 0;
		while (sc->wsmoused_sleep && error == 0)
			error = tsleep(&sc->wsmoused_sleep, PPAUSE,
			    "wsmoused_sleep", 0);
		return (error);
d2419 1
a2419 2
		sc->wsmoused_dev = value;
	
d3236 1
d3249 1
a3296 73
/* Send a wscons event to notify wsmoused(8) to release the mouse device */
void
wsmoused_release(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	struct device *wsms_dev = NULL;
	struct device **wsms_dev_list;
	int is_wsmouse = 0;
#if NWSMUX > 0
	int is_wsmux = 0;
#endif /* NWSMUX > 0 */

	if (sc->wsmoused_dev) {
		/* wsmoused(8) is running */

		wsms_dev_list = (struct device **) wsmouse_cd.cd_devs;
		if (!wsms_dev_list)
			/* no wsmouse device exists */
			return ;

		/* test whether device opened by wsmoused(8) is a wsmux device
		 * (/dev/wsmouse) or a wsmouse device (/dev/wsmouse{0..n} */

#if NWSMUX > 0
		/* obtain major of /dev/wsmouse multiplexor device */
		/* XXX first member of wsmux_softc is of type struct device */
		if (cdevsw[major(sc->wsmoused_dev)].d_open == wsmuxopen)
			is_wsmux = 1;

		if (is_wsmux && (minor(sc->wsmoused_dev) == WSMOUSEDEVCF_MUX)) {
			/* /dev/wsmouse case */
			/* XXX at least, wsmouse0 exist */
			wsms_dev = wsms_dev_list[0];
		}
#endif /* NWSMUX > 0 */

		/* obtain major of /dev/wsmouse{0..n} devices */
		if (wsmouse_cd.cd_ndevs > 0) {
			if (cdevsw[major(sc->wsmoused_dev)].d_open ==
			     wsmouseopen)
				is_wsmouse = 1;
		}

		if (is_wsmouse && (minor(sc->wsmoused_dev) <= NWSMOUSE)) {
			/* /dev/wsmouseX case */
			if (minor(sc->wsmoused_dev) < wsmouse_cd.cd_ndevs) {
				wsms_dev =
				    wsms_dev_list[minor(sc->wsmoused_dev)];
			}
			else
				/* no corresponding /dev/wsmouseX device */
				return;
		}

		/* inject event to notify wsmoused(8) to close mouse device */
		if (wsms_dev != NULL)
			wsmouse_input(wsms_dev, 0, 0, 0, 0, 0,
				      WSMOUSE_INPUT_WSMOUSED_CLOSE);
	}
#endif /* NWSMOUSE > 0 */
}

/* Wakeup wsmoused(8), so that the mouse device can be reopened */
void
wsmoused_wakeup(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	if (sc->wsmoused_dev) {
		sc->wsmoused_sleep = 0;
		wakeup(&sc->wsmoused_sleep);
	}
#endif /* NWSMOUSE > 0 */
}
@


1.119
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.118 2014/05/14 18:11:24 shadchin Exp $ */
a38 1
#include <sys/proc.h>
@


1.118
log
@wsmoused() called if cmd == WSDISPLAYIO_WSMOUSED only,
don't need check cmd twice.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.117 2013/11/04 05:45:04 miod Exp $ */
d313 2
a314 2
		free(dconf, M_DEVBUF);
	free(scr, M_DEVBUF);
d329 2
a330 2
	free(scr->scr_dconf, M_DEVBUF);
	free(scr, M_DEVBUF);
d1352 1
a1352 1
			free(buf, M_DEVBUF);
d1359 1
a1359 1
			free(buf, M_DEVBUF);
d3359 1
a3359 1
		free(sc->sc_copybuffer, M_DEVBUF);
@


1.117
log
@Better defaults for the screen burner settings: all unblank actions enabled,
but burning still disabled by default. Setting display.screen_off to a nonzero
value with wsconsctl will be enough to enable screen blanking after the
given time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.116 2013/10/20 21:24:01 miod Exp $ */
d1322 1
a1322 1
		error = wsmoused(sc, cmd, data, flag, p);
d2384 1
a2384 2
wsmoused(struct wsdisplay_softc *sc, u_long cmd, caddr_t data,
    int flag, struct proc *p)
d2388 17
a2404 24
	if (cmd == WSDISPLAYIO_WSMOUSED) {
		if (IS_MOTION_EVENT(mouse_event.type)) {
			if (sc->sc_focus != NULL)
				motion_event(sc->sc_focus, mouse_event.type,
				    mouse_event.value);
			return 0;
		}
		if (IS_BUTTON_EVENT(mouse_event.type)) {
			if (sc->sc_focus != NULL) {
				/* XXX tv_sec contains the number of clicks */
				if (mouse_event.type ==
				    WSCONS_EVENT_MOUSE_DOWN) {
					button_event(sc->sc_focus,
					    mouse_event.value,
					    mouse_event.time.tv_sec);
				} else
					button_event(sc->sc_focus,
					    mouse_event.value, 0);
			}
			return (0);
		}
		if (IS_CTRL_EVENT(mouse_event.type)) {
			return ctrl_event(sc, mouse_event.type,
			    mouse_event.value, p);
d2406 5
@


1.116
log
@No longer store fonts added with the WSDISPLAYIO_LDFONT ioctl into the
wsdisplay softc. Instead, since the knowledge about available fonts lies in
the parent driver itself, introduce a list_font wsdisplay_accessop which
queries a font index, suitable to use within the WSDISPLAYIO_LSFONT ioctl.

With this in place:
- there is no global wsdisplay limit on the number of fonts loaded. Such a
  limit will be enforced by the display drivers themselves.
- built-in kernel fonts will now appear in the list of fonts.

Grow a list_font accesop for rasops, which relies upon wsfont_enum(), which
is turned into something useful (and abortable if you do not need to iterate
further). Not used by any rasops driver yet.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.115 2013/10/20 13:20:14 miod Exp $ */
d771 3
a773 2
	sc->sc_burninintvl = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
	sc->sc_burnflags = 0;	/* off by default */
@


1.115
log
@Allow WSDISPLAYIO_GTYPE ioctl on the tty*cfg device (passing it back to tty*0).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.114 2013/10/18 22:06:41 miod Exp $ */
a179 2
	struct wsdisplay_font sc_fonts[WSDISPLAY_MAXFONT];

a1343 2
		if (d->index >= WSDISPLAY_MAXFONT)
			return (EINVAL);
a1358 2
		else if (d->index >= 0 || d->index < WSDISPLAY_MAXFONT)
			sc->sc_fonts[d->index] = *d;
d1362 1
a1362 1
		if (d->index < 0 || d->index >= WSDISPLAY_MAXFONT)
d1364 3
a1366 2
		*d = sc->sc_fonts[d->index];
		return (0);
@


1.114
log
@UTF-8 support for wsdisplay emulation modes. Both vt100 and sun emulation
will now recognize xterm-compatible escape sequences ESC % G and ESC % @@ to
enter and leave UTF-8 mode, respectively.

Not enabled on SMALL_KERNEL.

Most of this written during c2k7, completed during b2k13.

Note that the value of several international keysyms change, to switch from
ISO Latin-[257] values to the real Unicode values. Be sure to update your
includes and rebuild and install wsconsctl.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.113 2013/10/18 13:54:08 miod Exp $ */
d1042 6
a1047 2
	if (ISWSDISPLAYCTL(dev))
		return (wsdisplay_cfg_ioctl(sc, cmd, data, flag, p));
@


1.113
log
@Introduce a dedicated private header file to control the optional features
of wscons (which usually get disabled for installation kernels, to save
space), instead of duplicating parts of it to too many places.

No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.112 2013/07/06 14:35:45 kettenis Exp $ */
d1605 1
a1605 1
wsdisplay_kbdinput(struct device *dev, keysym_t *ks, int num)
d1609 1
a1609 1
	const char *dp;
d1619 5
a1623 9
	for (; num > 0; num--, ks++) {
		if (KS_GROUP(*ks) == KS_GROUP_Ascii)
			(*linesw[tp->t_line].l_rint)(KS_VALUE(*ks), tp);
		else {
			count = (*scr->scr_dconf->wsemul->translate)
			    (scr->scr_dconf->wsemulcookie, *ks, &dp);
			while (count-- > 0)
				(*linesw[tp->t_line].l_rint)(*dp++, tp);
		}
@


1.112
log
@s/wsemuldisplaysubmatch/wsemuldisplaydevsubmatch/g
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.111 2013/07/05 21:18:32 kettenis Exp $ */
a33 6
#ifndef	SMALL_KERNEL
#define WSMOUSED_SUPPORT
#define	BURNER_SUPPORT
#define	SCROLLBACK_SUPPORT
#endif

d51 1
d113 1
a113 1
#ifdef WSMOUSED_SUPPORT
d142 1
a142 1
#endif	/* WSMOUSED_SUPPORT */
d171 1
a171 1
#ifdef BURNER_SUPPORT
d197 1
a197 1
#ifdef WSMOUSED_SUPPORT
d413 1
a413 1
#ifdef WSMOUSED_SUPPORT
d616 1
a616 1
#ifdef BURNER_SUPPORT
d771 1
a771 1
#ifdef BURNER_SUPPORT
d948 1
a948 1
#ifdef WSMOUSED_SUPPORT
d1119 1
a1119 1
#ifdef BURNER_SUPPORT
d1152 1
a1152 1
#ifdef WSMOUSED_SUPPORT
d1164 1
a1164 1
#ifdef BURNER_SUPPORT
d1175 1
a1175 1
#ifdef BURNER_SUPPORT
d1183 1
a1183 1
#ifdef WSMOUSED_SUPPORT
d1210 1
a1210 1
#ifdef BURNER_SUPPORT
d1269 1
a1269 1
#endif	/* BURNER_SUPPORT */
d1317 1
a1317 1
#ifdef WSMOUSED_SUPPORT
d1494 1
a1494 1
#ifdef BURNER_SUPPORT
d1497 1
a1497 1
#ifdef WSMOUSED_SUPPORT
d1889 1
a1889 1
#ifdef WSMOUSED_SUPPORT
d1932 1
a1932 1
#endif	/* WSMOUSED_SUPPORT */
d2153 1
a2153 1
#ifdef BURNER_SUPPORT
d2317 1
a2317 1
#ifdef SCROLLBACK_SUPPORT
d2342 1
a2342 1
#ifdef BURNER_SUPPORT
d2379 1
a2379 1
#ifdef WSMOUSED_SUPPORT
d3461 1
a3461 1
#endif /* WSMOUSED_SUPPORT */
@


1.111
log
@Add submatch function for use with config_found_sm(9).

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.110 2013/06/15 21:35:15 kettenis Exp $ */
d673 1
a673 1
wsemuldisplaysubmatch(struct device *parent, void *match, void *aux)
@


1.110
log
@When we disable the burner when X is running, also set sc_burnout to 0 to
prevent us from accidentally reenabling the burner.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.109 2013/05/30 16:15:02 deraadt Exp $ */
d669 14
@


1.109
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.108 2013/05/12 20:41:45 kettenis Exp $ */
d1160 1
a1160 1
			if (sc->sc_burnout)
d1162 2
d1168 2
a1169 1
			if (!sc->sc_burnman)
d1171 1
@


1.108
log
@In wsdisplay_switchtoconsole(), make sure we really are the console before
attempting to switch screens.  On amd64/i386 the glass console gets
initialised early even if a serial console has been set up by the bootloader.
To add insult to injury, the glass console isn't properly "detached" and the
MI wsdisplay(4) driver continues to believe it is the console.  This should
really be fixed, but is a nasty can of worms.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.107 2013/03/10 13:40:28 kettenis Exp $ */
a158 1
void	wsdisplay_shutdownhook(void *);
d218 2
d226 1
a226 1
	    wsdisplay_emul_attach, wsdisplay_emul_detach
d589 14
a676 1
	static int hookset = 0;
a770 4
	if (hookset == 0)
		shutdownhook_establish(wsdisplay_shutdownhook, NULL);
	hookset = 1;

a2364 9

/*
 * Switch the console at shutdown.
 */
void
wsdisplay_shutdownhook(void *arg)
{
	wsdisplay_switchtoconsole();
}
@


1.107
log
@Make it possible to call wsdisplay_cnattach() to override an already attached
wsdisplay console later in the boot process.  Needed for upcoming KMS changes
where on i386/amd64 we will switch from vga text mode to a framebuffer console
when the KMS drm driver attaches.

ok miod@@, mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.106 2012/07/13 12:37:08 deraadt Exp $ */
d2186 1
a2186 1
	if (wsdisplay_console_device != NULL) {
@


1.106
log
@Try to avoid using the same wchan name twice.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.105 2011/07/03 18:11:21 nicm Exp $ */
a785 1
	KASSERT(!wsdisplay_console_initted);
d810 2
a811 1
	cn_tab = &wsdisplay_cons;
@


1.105
log
@Fix return values of wsdisplaykqfilter and move some code so it matches
wsdisplaypoll.

ok miod deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.104 2011/06/23 16:31:16 deraadt Exp $ */
d2043 1
a2043 1
		res = tsleep(scr, PCATCH, "wswait", 0);
@


1.104
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.103 2010/11/20 20:52:10 miod Exp $ */
d1414 1
a1414 1
		return (1);
d1417 4
a1420 1
		return (1);
d1422 1
a1422 4
	if (WSSCREEN_HAS_TTY(scr))
		return (ttkqfilter(dev, kn));
	else
		return (1);
@


1.103
log
@Change wsdisplay_kbdinput() to get an aray of keysym_t and a count, instead of
a single keysym_t at a time - this means tty sanity checks will only happen
once.

Introduce wsdisplay_rawkbdinput() for raw mode input, since raw input is
a byte array. As a bonus this allows us to skip the `is this a KS_GROUP_Ascii
value' test in that case.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.102 2010/07/02 17:27:01 nicm Exp $ */
d2170 1
a2170 1
wsdisplay_unset_cons_kbd()
d2181 1
a2181 1
wsdisplay_switchtoconsole()
@


1.102
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.101 2010/07/01 02:33:05 maja Exp $ */
d1582 1
a1582 1
wsdisplay_kbdinput(struct device *dev, keysym_t ks)
a1589 2
	KASSERT(sc != NULL);

a1590 1

d1594 1
d1596 9
a1604 8

	if (KS_GROUP(ks) == KS_GROUP_Ascii)
		(*linesw[tp->t_line].l_rint)(KS_VALUE(ks), tp);
	else {
		count = (*scr->scr_dconf->wsemul->translate)
		    (scr->scr_dconf->wsemulcookie, ks, &dp);
		while (count-- > 0)
			(*linesw[tp->t_line].l_rint)(*dp++, tp);
d1609 15
a1935 1
	KASSERT(sc != NULL);
@


1.101
log
@Make it possible to get the screen types and emulations for a wsdisplay.
Information needed for wsconscfg. feedback and ok miod@@. -moj
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.100 2010/06/28 14:13:35 deraadt Exp $ */
a1508 1
	if (tp->t_outq.c_cc <= tp->t_lowat) {
d1510 1
a1510 6
		if (tp->t_state & TS_ASLEEP) {
			tp->t_state &= ~TS_ASLEEP;
			wakeup((caddr_t)&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
	}
@


1.100
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.99 2010/04/12 12:57:52 tedu Exp $ */
d1253 23
a1275 1
	}
@


1.99
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.98 2010/03/30 17:40:55 oga Exp $ */
d313 1
a313 1
	scr->scr_tty = ttymalloc();
@


1.98
log
@Prevent the apmd/x races for good.

When we hit suspend time, go through all wsdisplays on the system. if
they are in mode MAPPED, but not MODE_DUMBFB then if possible do a full
vt switch to a !mapped vt, and prevent switching back until resume time.
This has to be called from MD code because this involves userland
running so that X can run the vt switch signal handler. This way, any
case where we are using the "poke registers from userland" model, we
will not be on the hardware when we go down, so the kernel can actually
handle thing properly.

Tested on several acpi laptops (by kettenis@@ and ian@@), x40 (me and
beck@@ at LEAST) and zaurus (me). Maybe others, but if so I forgot who at
this time..

Idea from deraadt somewhere over the Faroe Islands (I thought of a
similar thing myself a while ago). Much prompting from him. Ok and
comments miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.97 2009/11/09 17:53:39 nicm Exp $ */
d860 1
a860 1
		error = ((*linesw[tp->t_line].l_open)(dev, tp));
d903 1
a903 1
		(*linesw[tp->t_line].l_close)(tp, flag);
@


1.97
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.96 2009/10/31 14:13:57 deraadt Exp $ */
d157 2
d194 1
d689 1
d1805 7
d2163 99
@


1.96
log
@KNOTE() after selwakeup(); ok miod
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.95 2009/10/31 12:00:08 fgsch Exp $ */
a1489 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.95
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.94 2009/09/14 04:10:42 miod Exp $ */
d1490 1
@


1.94
log
@Correctly empty the tty rings in wsdisplaystart() if the display is
in SCR_GRAPHICS mode; spotted by martynas@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.93 2009/09/05 14:30:24 miod Exp $ */
d852 1
a852 1
			   p->p_ucred->cr_uid != 0)
@


1.93
log
@Make the output() wsemul_op return the number of characters processed and
check it in wsdisplaystart() to suspend output if not all characters have
been output; they will get reissued at the next tty rstrt_to timeout.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.92 2009/05/31 17:02:20 miod Exp $ */
d1459 2
a1460 1
	}
d1470 2
a1471 1
			}
@


1.92
log
@The wsmouse support code has been written for pcvt long ago, then lifted
to work with wscons. Back then, the universe was simple and there was only
one single wsdisplay device, so that code would use global variables.

Overhaul this, and make sure the various routines take the wsscreen or
wsdisplay they operate on as arguments.

This will eventually allow multiple wsmoused to run, one per wsdisplay
device.

While there, use more appropriate integer types in that code, so that
unholy big displays do not cause integer overflows in coordinates
computations. As a bonus, this makes the code smaller.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.91 2009/05/31 16:57:34 miod Exp $ */
d1404 1
a1404 1
	int s, n, unit;
d1457 2
a1458 2
		(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,
		    buf, n, 0);
d1460 1
a1460 1
	ndflush(&tp->t_outq, n);
d1462 9
a1470 9
	if ((n = ndqb(&tp->t_outq, 0)) > 0) {
		buf = tp->t_outq.c_cf;

		if (!(scr->scr_flags & SCR_GRAPHICS)) {
#ifdef BURNER_SUPPORT
			wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
#endif
			(*scr->scr_dconf->wsemul->output)
			    (scr->scr_dconf->wsemulcookie, buf, n, 0);
a1471 1
		ndflush(&tp->t_outq, n);
d2091 1
a2091 1
	(*dc->wsemul->output)(dc->wsemulcookie, &c, 1, 1);
@


1.91
log
@Do not access sc_scr[-1] from the wsmoused-related code if
wsdisplay_switch(..., WSDISPLAY_NULLSCREEN, ...).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.90 2009/05/31 16:56:10 miod Exp $ */
d120 27
a146 26
	unsigned short mouse;		/* mouse cursor position */
	unsigned short cursor;		/* selection cursor position (if
					different from mouse cursor pos) */
	unsigned short cpy_start;	/* position of the copy start mark*/
	unsigned short cpy_end;		/* position of the copy end mark */
	unsigned short orig_start;	/* position of the original sel. start*/
	unsigned short orig_end;	/* position of the original sel. end */
#define MOUSE_VISIBLE	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS	(1 << 1)	/* flag, a selection exists */
#define SEL_IN_PROGRESS (1 << 2)	/* flag, a selection is in progress */
#define SEL_EXT_AFTER	(1 << 3)	/* flag, selection is extended after */
#define BLANK_TO_EOL	(1 << 4)	/* flag, there are only blanks
					   characters to eol */
#define SEL_BY_CHAR	(1 << 5)	/* flag, select character by character*/
#define SEL_BY_WORD	(1 << 6)	/* flag, select word by word */
#define SEL_BY_LINE	(1 << 7)	/* flag, select line by line */

#define IS_MOUSE_VISIBLE(ws) ((ws)->mouse_flags & MOUSE_VISIBLE)
#define IS_SEL_EXISTS(ws) ((ws)->mouse_flags & SEL_EXISTS)
#define IS_SEL_IN_PROGRESS(ws) ((ws)->mouse_flags & SEL_IN_PROGRESS)
#define IS_SEL_EXT_AFTER(ws) ((ws)->mouse_flags & SEL_EXT_AFTER)
#define IS_BLANK_TO_EOL(ws) ((ws)->mouse_flags & BLANK_TO_EOL)
#define IS_SEL_BY_CHAR(ws) ((ws)->mouse_flags & SEL_BY_CHAR)
#define IS_SEL_BY_WORD(ws) ((ws)->mouse_flags & SEL_BY_WORD)
#define IS_SEL_BY_LINE(ws) ((ws)->mouse_flags & SEL_BY_LINE)
	unsigned char mouse_flags;	/* flags, status of the mouse */
d189 2
a190 1
#define SC_SWITCHPENDING 1
d203 3
a272 6
#ifdef WSMOUSED_SUPPORT
char *Copybuffer;
u_int Copybuffer_size;
char Paste_avail;
#endif

d281 1
a281 1
	scr = malloc(sizeof(struct wsscreen), M_DEVBUF, M_NOWAIT);
a309 1

a310 7
	scr->scr_hold_screen = 0;
	scr->scr_flags = 0;

#ifdef WSDISPLAY_COMPAT_USL
	scr->scr_syncops = NULL;
#endif

a311 6
#ifdef WSMOUSED_SUPPORT
	scr->mouse_flags = 0;
#endif
#ifdef WSDISPLAY_COMPAT_RAWKBD
	scr->scr_rawkbd = 0;
#endif
d415 1
a415 1
	allocate_copybuffer(sc); /* enlarge the copy buffer is necessary */
d927 3
a929 3
	if (Copybuffer)
		bzero(Copybuffer, Copybuffer_size);
	Paste_avail = 0;
d1450 1
a1450 1
			if (IS_SEL_EXISTS(sc->sc_focus))
d1452 1
a1452 1
				remove_selection(sc);
d1454 1
a1454 1
			mouse_hide(sc);
d1630 1
a1630 1
	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
d1653 1
a1653 1
			sc->sc_flags &= ~SC_SWITCHPENDING;
d1671 1
a1671 1
	sc->sc_flags &= ~SC_SWITCHPENDING;
d1685 1
a1685 1
	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
d1705 1
a1705 1
			sc->sc_flags &= ~SC_SWITCHPENDING;
d1745 1
a1745 1
	if (!(sc->sc_flags & SC_SWITCHPENDING)) {
d1752 1
a1752 1
		sc->sc_flags &= ~SC_SWITCHPENDING;
d1768 1
a1768 1
		sc->sc_flags &= ~SC_SWITCHPENDING;
d1806 1
a1806 1
	if (sc->sc_flags & SC_SWITCHPENDING) {
d1811 1
a1811 1
	sc->sc_flags |= SC_SWITCHPENDING;
d1847 1
a1847 1
		mouse_remove(sc);
d1856 1
a1856 1
		mouse_remove(sc);
a2229 3
/* XXX pointer to the current screen wsdisplay_softc structure */
static struct wsdisplay_softc *sc = NULL;

d2234 1
a2234 1
wsmoused(struct wsdisplay_softc *ws_sc, u_long cmd, caddr_t data,
a2236 1
	int error = -1;
d2241 2
a2242 2
			if (ws_sc->sc_focus != NULL)
				motion_event(mouse_event.type,
d2244 1
a2244 1
			return (0);
d2247 1
a2247 1
			if (ws_sc->sc_focus != NULL) {
d2251 2
a2252 1
					button_event(mouse_event.value,
d2255 2
a2256 1
					button_event(mouse_event.value, 0);
d2261 2
a2262 2
			return (ctrl_event(mouse_event.type, mouse_event.value,
			    ws_sc, p));
d2265 1
a2265 1
	return (error);
d2272 1
a2272 1
motion_event(u_int type, int value)
d2275 11
a2285 11
		case WSCONS_EVENT_MOUSE_DELTA_X:
			mouse_moverel(value, 0);
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Y:
			mouse_moverel(0, 0 - value);
			break;
		case WSCONS_EVENT_MOUSE_DELTA_Z:
			mouse_zaxis(value);
			break;
		default:
			break;
d2293 1
a2293 1
button_event(int button, int clicks)
d2299 2
a2300 2
			mouse_copy_end();
			mouse_copy_selection();
d2303 2
a2304 2
			mouse_copy_start();
			mouse_copy_selection();
d2307 2
a2308 2
			mouse_copy_word();
			mouse_copy_selection();
d2311 2
a2312 4
			mouse_copy_line();
			mouse_copy_selection();
			break;
		default:
a2315 1

d2317 2
a2318 7
		switch (clicks) {
		case 0: /* button is up */
			break;
		default: /* paste */
			mouse_paste();
			break;
		}
a2319 1

d2321 2
a2322 7
		switch (clicks) {
		case 0: /* button is up */
			break;
		default: /* extend the selection */
			mouse_copy_extend_after();
			break;
		}
a2323 1

d2333 1
a2333 1
ctrl_event(u_int type, int value, struct wsdisplay_softc *ws_sc, struct proc *p)
d2335 1
d2338 4
a2341 13
	if (type == WSCONS_EVENT_WSMOUSED_ON) {
		if (!ws_sc->sc_accessops->getchar)
			/* no wsmoused(8) support in the display driver */
			return (1);
		/* initialization of globals */
		sc = ws_sc;
		allocate_copybuffer(sc);
		Paste_avail = 0;
		ws_sc->wsmoused_dev = value;
	}
	if (type == WSCONS_EVENT_WSMOUSED_OFF) {
		Paste_avail = 0;
		ws_sc->wsmoused_dev = 0;
d2343 1
a2343 2
	}
	if (type == WSCONS_EVENT_WSMOUSED_SLEEP) {
d2345 1
a2345 1
		ws_sc->wsmoused_sleep = 1;
d2347 2
a2348 2
		while (ws_sc->wsmoused_sleep && error == 0)
			error = tsleep(&ws_sc->wsmoused_sleep, PPAUSE,
d2351 22
a2373 13
	for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++)
		if (sc->sc_scr[i]) {
			sc->sc_scr[i]->mouse =
				((WS_NCOLS(sc->sc_scr[i]) *
				  WS_NROWS(sc->sc_scr[i])) / 2);
			sc->sc_scr[i]->cursor = sc->sc_scr[i]->mouse;
			sc->sc_scr[i]->cpy_start = 0;
			sc->sc_scr[i]->cpy_end = 0;
			sc->sc_scr[i]->orig_start = 0;
			sc->sc_scr[i]->orig_end = 0;
			sc->sc_scr[i]->mouse_flags = 0;
		}
	return (0);
d2377 1
a2377 1
mouse_moverel(char dx, char dy)
d2379 4
a2382 13
	unsigned short old_mouse = MOUSE;
	unsigned char mouse_col = (MOUSE % N_COLS);
	unsigned char mouse_row = (MOUSE / N_COLS);

	/* wscons has support for screen saver via the WSDISPLAYIO_{G,S}VIDEO
	   with WSDISPLAY_VIDEO_OFF and WSDISPLAY_VIDEO_ON values.
	   However, none of the pc display driver (pcdisplay.c or vga.c)
	   support this ioctl. Only the alpha display driver (tga.c) support it.

	   When screen saver support is available, /usr/sbin/screenblank can be
	   used with the -m option, so that mice movements stop the screen
	   saver.
	 */
d2385 2
a2386 3

	if (mouse_col + dx >= MAXCOL)
		mouse_col = MAXCOL;
d2393 2
a2394 2
	if (mouse_row + dy >= MAXROW)
		mouse_row = MAXROW;
d2401 2
a2402 1
	MOUSE = XY_TO_POS(mouse_col, mouse_row);
d2404 3
a2406 2
	if (old_mouse != MOUSE) {
		if (IS_SEL_IN_PROGRESS(sc->sc_focus)) {
d2408 1
a2408 1
			mouse_copy_extend();
d2410 3
a2412 3
			inverse_char(MOUSE);
			if (IS_MOUSE_VISIBLE(sc->sc_focus))
				inverse_char(old_mouse);
d2414 1
a2414 1
				MOUSE_FLAGS |= MOUSE_VISIBLE;
d2420 1
a2420 1
inverse_char(unsigned short pos)
d2422 1
a2422 1
	struct wsscreen_internal *dconf;
d2429 1
a2429 3
	dconf = sc->sc_focus->scr_dconf;

	GETCHAR(pos, &cell);
d2451 1
a2451 1
		PUTCHAR(pos, cell.uc, cell.attr);
d2456 1
a2456 1
inverse_region(unsigned short start, unsigned short end)
d2458 3
a2460 2
	unsigned short current_pos;
	unsigned short abs_end;
d2462 2
a2463 2
	/* sanity check, useful because 'end' can be (0 - 1) = 65535 */
	abs_end = N_COLS * N_ROWS;
d2468 1
a2468 1
		inverse_char(current_pos++);
d2476 2
a2477 2
unsigned char
skip_spc_right(char border)
d2479 1
d2481 4
a2484 4
	unsigned short current = CPY_END;
	unsigned short mouse_col = (CPY_END % N_COLS);
	unsigned short limit = current + (N_COLS - mouse_col - 1);
	unsigned char res = 0;
d2486 1
a2486 1
	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
d2497 1
a2497 1
		if (res)
d2508 2
a2509 2
unsigned char
skip_spc_left(void)
d2511 1
d2513 4
a2516 4
	short current = CPY_START;
	unsigned short mouse_col = (MOUSE % N_COLS);
	unsigned short limit = current - mouse_col;
	unsigned char res = 0;
d2518 1
a2518 1
	while (GETCHAR(current, &cell) == 0 && cell.uc == ' ' &&
d2523 1
a2523 1
	if (res)
d2603 2
a2604 2
unsigned char
skip_char_right(unsigned short offset)
d2606 1
d2608 5
a2612 4
	unsigned short current = offset;
	unsigned short limit = current + (N_COLS - (MOUSE % N_COLS) - 1);
	unsigned char class;
	unsigned char res = 0;
d2614 1
a2614 1
	GETCHAR(current, &cell);
d2616 1
a2616 1
	while (GETCHAR(current, &cell) == 0 &&
d2621 1
a2621 1
	if (res)
d2629 2
a2630 2
unsigned char
skip_char_left(unsigned short offset)
d2632 1
d2634 4
a2637 4
	short current = offset;
	unsigned short limit = current - (MOUSE % N_COLS);
	unsigned char class;
	unsigned char res = 0;
d2639 1
a2639 1
	GETCHAR(current, &cell);
d2641 1
a2641 1
	while (GETCHAR(current, &cell) == 0 &&
d2646 1
a2646 1
	if (res)
d2654 2
a2655 2
unsigned char
class_cmp(unsigned short first, unsigned short second)
d2658 2
a2659 2
	unsigned char first_class;
	unsigned char second_class;
d2661 1
a2661 1
	if (GETCHAR(first, &cell) != 0)
d2664 1
a2664 1
	if (GETCHAR(second, &cell) != 0)
d2678 1
a2678 1
mouse_copy_start(void)
d2680 2
a2681 1
	unsigned char right;
d2683 1
a2683 3

	if (!Paste_avail)
		Paste_avail = 1;
d2686 2
a2687 3

	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);
d2690 2
a2691 2
	if (!IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);
d2693 4
a2696 5
	CPY_START = MOUSE;
	CPY_END = MOUSE;
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1; /* init value */
d2698 2
a2699 1
	right = skip_spc_right(BORDER); /* useful later, in mouse_copy_extend */
d2701 1
a2701 1
		MOUSE_FLAGS |= BLANK_TO_EOL;
d2703 3
a2705 6
	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS |= SEL_BY_CHAR; /* select by char */
	MOUSE_FLAGS &= ~SEL_BY_WORD;
	MOUSE_FLAGS &= ~SEL_BY_LINE;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE; /* cursor hidden in selection */
d2712 1
a2712 1
mouse_copy_word()
d2715 2
a2716 2
	unsigned char right;
	unsigned char left;
d2718 2
a2719 2
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);
d2721 2
a2722 2
	if (IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);
d2724 1
a2724 2
	CPY_START = MOUSE;
	CPY_END = MOUSE;
d2726 4
a2729 3
	if (GETCHAR(MOUSE, &cell) == 0 && IS_ALPHANUM(cell.uc)) {
		right = skip_char_right(CPY_END);
		left = skip_char_left(CPY_START);
d2731 2
a2732 2
		right = skip_spc_right(NO_BORDER);
		left = skip_spc_left();
d2735 6
a2740 12
	CPY_START -= left;
	CPY_END += right;
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1; /* init value, never happen */
	inverse_region(CPY_START, CPY_END);

	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS &= ~SEL_BY_CHAR;
	MOUSE_FLAGS |= SEL_BY_WORD;
	MOUSE_FLAGS &= ~SEL_BY_LINE;
d2742 2
d2745 1
a2745 2
	MOUSE_FLAGS &= ~BLANK_TO_EOL;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE;
d2752 1
a2752 1
mouse_copy_line(void)
d2754 2
a2755 1
	unsigned char row = MOUSE / N_COLS;
d2757 2
a2758 2
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);
d2760 9
a2768 15
	if (IS_MOUSE_VISIBLE(sc->sc_focus))
		inverse_char(MOUSE);

	CPY_START = row * N_COLS;
	CPY_END = CPY_START + (N_COLS - 1);
	ORIG_START = CPY_START;
	ORIG_END = CPY_END;
	CURSOR = CPY_END + 1;
	inverse_region(CPY_START, CPY_END);

	MOUSE_FLAGS |= SEL_IN_PROGRESS;
	MOUSE_FLAGS |= SEL_EXISTS;
	MOUSE_FLAGS &= ~SEL_BY_CHAR;
	MOUSE_FLAGS &= ~SEL_BY_WORD;
	MOUSE_FLAGS |= SEL_BY_LINE;
d2770 2
d2773 1
a2773 2
	MOUSE_FLAGS &= ~BLANK_TO_EOL;
	MOUSE_FLAGS &= ~MOUSE_VISIBLE;
d2780 1
a2780 1
mouse_copy_end(void)
d2782 6
a2787 5
	MOUSE_FLAGS &= ~(SEL_IN_PROGRESS);
	if (IS_SEL_BY_WORD(sc->sc_focus) || IS_SEL_BY_LINE(sc->sc_focus)) {
		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);
		CURSOR = CPY_END + 1;
d2796 1
a2796 1
mouse_copy_extend(void)
d2798 6
a2803 6
	if (IS_SEL_BY_CHAR(sc->sc_focus))
		mouse_copy_extend_char();
	if (IS_SEL_BY_WORD(sc->sc_focus))
		mouse_copy_extend_word();
	if (IS_SEL_BY_LINE(sc->sc_focus))
		mouse_copy_extend_line();
d2810 1
a2810 1
mouse_copy_extend_char()
d2812 1
a2812 3
	unsigned char right;

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
d2814 2
a2815 1
		if (IS_BLANK_TO_EOL(sc->sc_focus)) {
d2821 2
a2822 2
			right = skip_spc_right(BORDER);
			if (MOUSE > ORIG_START) {
d2828 4
a2831 4
				inverse_char(CPY_START);
				CPY_START += (right + 1);
				CPY_END = CPY_START;
				ORIG_START = CPY_START;
d2833 1
a2833 1
				inverse_char(CPY_START);
d2839 4
a2842 4
				inverse_char(CPY_START);
				ORIG_START += (right + 1);
				CPY_START = ORIG_START - 1;
				CPY_END = ORIG_START - 1;
d2844 1
a2844 1
				inverse_char(CPY_START);
d2846 1
a2846 1
			MOUSE_FLAGS &= ~ BLANK_TO_EOL;
d2849 2
a2850 1
		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
d2854 3
a2856 3
			remove_selection(sc);
			CPY_END = ORIG_START - 1;
			CPY_START = ORIG_START;
d2858 2
a2859 1
		if (CPY_START < ORIG_START && MOUSE >= ORIG_START) {
d2864 3
a2866 3
			remove_selection(sc);
			CPY_START = ORIG_START;
			CPY_END = ORIG_START - 1;
d2869 1
a2869 2
		MOUSE_FLAGS |= SEL_IN_PROGRESS;
		MOUSE_FLAGS |= SEL_EXISTS;
a2870 3
	/* beginning of common part */

	if (MOUSE >= ORIG_START) {
d2872 1
d2874 1
a2874 1
		if (MOUSE > CPY_END) {
d2876 1
a2876 1
			inverse_region(CPY_END + 1, MOUSE);
d2879 1
a2879 1
			inverse_region(MOUSE + 1, CPY_END);
d2881 1
a2881 1
		CPY_END = MOUSE;
d2884 1
a2884 1
		if (MOUSE < CPY_START) {
d2886 1
a2886 1
			inverse_region(MOUSE,CPY_START - 1);
d2889 1
a2889 1
			inverse_region(CPY_START,MOUSE - 1);
d2891 1
a2891 1
		CPY_START = MOUSE;
a2892 1
	/* end of common part */
d2899 1
a2899 1
mouse_copy_extend_word(void)
d2901 2
a2902 4
	unsigned short old_cpy_end;
	unsigned short old_cpy_start;

	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
d2904 1
d2906 2
a2907 3

		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);
d2910 2
a2911 2

		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
d2913 2
a2914 2
			inverse_region(ORIG_END + 1, CPY_END);
			CPY_END = ORIG_END;
d2917 2
a2918 1
		if (MOUSE > ORIG_END && CPY_START <= ORIG_START) {
d2920 3
a2922 2
			inverse_region(CPY_START, ORIG_START - 1);
			CPY_START = ORIG_START;
d2926 1
a2926 1
	if (MOUSE >= ORIG_START) {
d2928 1
a2928 2

		if (MOUSE > CPY_END) {
d2930 4
a2933 4

			old_cpy_end = CPY_END;
			CPY_END = MOUSE + skip_char_right(MOUSE);
			inverse_region(old_cpy_end + 1, CPY_END);
d2935 1
a2935 1
			if (class_cmp(MOUSE, MOUSE + 1)) {
d2937 4
a2940 3
				old_cpy_end = CPY_END;
				CPY_END = MOUSE;
				inverse_region(CPY_END + 1, old_cpy_end);
d2942 4
a2945 3
				old_cpy_end = CPY_END;
				CPY_END = MOUSE + skip_char_right(MOUSE);
				if (CPY_END != old_cpy_end) {
d2948 1
a2948 1
					inverse_region(CPY_END + 1,
d2955 1
a2955 1
		if (MOUSE < CPY_START) {
d2957 4
a2960 3
			old_cpy_start = CPY_START;
			CPY_START = MOUSE - skip_char_left(MOUSE);
			inverse_region(CPY_START, old_cpy_start - 1);
d2962 1
a2962 1
			if (class_cmp(MOUSE - 1, MOUSE)) {
d2964 4
a2967 4
				old_cpy_start = CPY_START;
				CPY_START = MOUSE;
				inverse_region(old_cpy_start,
				    CPY_START - 1);
d2969 6
a2974 5
				old_cpy_start = CPY_START;
				CPY_START = MOUSE - skip_char_left(MOUSE);
				if (CPY_START != old_cpy_start) {
					inverse_region(old_cpy_start,
					    CPY_START - 1);
d2980 1
a2980 1
	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
d2982 2
a2983 2
		CURSOR = MOUSE;
		inverse_char(CURSOR);
d2991 1
a2991 1
mouse_copy_extend_line(void)
d2993 5
a2997 4
	unsigned short old_row;
	unsigned short new_row;
	unsigned short old_cpy_start;
	unsigned short old_cpy_end;
d2999 1
a2999 1
	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
d3001 2
a3002 3

		if (CURSOR != (CPY_END + 1))
			inverse_char(CURSOR);
d3005 2
a3006 2

		if (MOUSE < ORIG_START && CPY_END >= ORIG_START) {
d3008 2
a3009 2
			inverse_region(ORIG_END + 1, CPY_END);
			CPY_END = ORIG_END;
d3012 2
a3013 1
		if (MOUSE > ORIG_END && CPY_START <= ORIG_START) {
d3015 3
a3017 2
			inverse_region(CPY_START, ORIG_START - 1);
			CPY_START = ORIG_START;
d3021 1
a3021 1
	if (MOUSE >= ORIG_START) {
d3023 6
a3028 6
		if (CURSOR == (CPY_END + 1))
			CURSOR = CPY_END;
		old_row = CURSOR / N_COLS;
		new_row = MOUSE / N_COLS;
		old_cpy_end = CPY_END;
		CPY_END = (new_row * N_COLS) + MAXCOL;
d3030 1
a3030 1
			inverse_region(old_cpy_end + 1, CPY_END);
d3032 1
a3032 1
			inverse_region(CPY_END + 1, old_cpy_end);
d3035 4
a3038 4
		old_row = CURSOR / N_COLS;
		new_row = MOUSE / N_COLS;
		old_cpy_start = CPY_START;
		CPY_START = new_row * N_COLS;
d3040 1
a3040 1
			inverse_region(CPY_START, old_cpy_start - 1);
d3042 1
a3042 1
			inverse_region(old_cpy_start, CPY_START - 1);
d3045 1
a3045 1
	if (!IS_SEL_EXT_AFTER(sc->sc_focus)) {
d3047 2
a3048 11
		CURSOR = MOUSE;
		inverse_char(CURSOR);
	}
}

void
mouse_hide(struct wsdisplay_softc *sc)
{
	if (IS_MOUSE_VISIBLE(sc->sc_focus)) {
		inverse_char(MOUSE);
		MOUSE_FLAGS &= ~MOUSE_VISIBLE;
d3056 1
a3056 1
mouse_copy_extend_after(void)
d3058 2
a3059 2
	unsigned short start_dist;
	unsigned short end_dist;
d3061 3
a3063 3
	if (IS_SEL_EXISTS(sc->sc_focus)) {
		MOUSE_FLAGS |= SEL_EXT_AFTER;
		mouse_hide(sc); /* hide current cursor */
d3065 2
a3066 2
		if (CPY_START > MOUSE)
			start_dist = CPY_START - MOUSE;
d3068 3
a3070 3
			start_dist = MOUSE - CPY_START;
		if (MOUSE > CPY_END)
			end_dist = MOUSE - CPY_END;
d3072 1
a3072 1
			end_dist = CPY_END - MOUSE;
d3075 1
a3075 1
			ORIG_START = MOUSE + 1;
d3077 1
a3077 1
			CURSOR = CPY_START;
d3080 1
a3080 1
			ORIG_START = MOUSE;
d3082 1
a3082 1
			CURSOR = CPY_END;
d3084 16
a3099 7
		if (IS_SEL_BY_CHAR(sc->sc_focus))
			mouse_copy_extend_char();
		if (IS_SEL_BY_WORD(sc->sc_focus))
			mouse_copy_extend_word();
		if (IS_SEL_BY_LINE(sc->sc_focus))
			mouse_copy_extend_line();
		mouse_copy_selection();
d3107 1
a3107 1
remove_selection(struct wsdisplay_softc *sc)
d3109 1
a3109 1
	if (IS_SEL_EXT_AFTER(sc->sc_focus)) {
d3111 1
a3111 1
		MOUSE_FLAGS &= ~SEL_EXT_AFTER;
d3113 2
a3114 3
	inverse_region(CPY_START, CPY_END);
	MOUSE_FLAGS &= ~SEL_IN_PROGRESS;
	MOUSE_FLAGS &= ~SEL_EXISTS;
d3121 1
a3121 1
mouse_copy_selection(void)
d3123 1
d3125 5
a3129 5
	unsigned short current = 0;
	unsigned short blank = current;
	unsigned short buf_end = ((N_COLS + 1) * N_ROWS);
	unsigned short sel_cur;
	unsigned short sel_end;
d3131 2
a3132 2
	sel_cur = CPY_START;
	sel_end = CPY_END;
d3135 1
a3135 1
		if (GETCHAR(sel_cur, &cell) != 0)
d3137 2
a3138 2
		Copybuffer[current] = cell.uc;
		if (!IS_SPACE(Copybuffer[current]))
d3141 7
a3147 6
		if (POS_TO_X(sel_cur) == MAXCOL) {
			/* we are on the last col of the screen */
			Copybuffer[blank] = '\r'; /* carriage return */
			current = blank + 1; /* restart just after the carriage
					       return in the buffer */
			blank = current;
d3152 1
a3152 1
	Copybuffer[current] = '\0';
d3159 1
a3159 1
mouse_paste(void)
d3161 3
a3163 2
	unsigned short len;
	unsigned char *current = Copybuffer;
d3165 7
a3171 5
	if (Paste_avail) {
		for (len = strlen(Copybuffer) ; len > 0; len--) {
			(*linesw[sc->sc_focus->scr_tty->t_line].l_rint)
			    (*current++, sc->sc_focus->scr_tty);
		}
d3180 1
a3180 1
mouse_zaxis(int z)
d3183 1
a3183 1
		wsscrollback(sc, WSDISPLAY_SCROLL_BACKWARD);
d3185 1
a3185 1
		wsscrollback(sc, WSDISPLAY_SCROLL_FORWARD);
d3198 1
a3198 1
	int i,s;
d3201 1
a3201 1
	unsigned short size = Copybuffer_size;
d3206 2
a3207 2
		if (( (current->ncols + 1) * current->nrows) > size)
			size = ((current->ncols + 1) * current->nrows);
d3210 9
a3218 7
	if ((size != Copybuffer_size) && (Copybuffer_size != 0)) {
		bzero(Copybuffer, Copybuffer_size);
		free(Copybuffer, M_DEVBUF);
	}
	if ((Copybuffer = (char *)malloc(size, M_DEVBUF, M_NOWAIT)) == NULL) {
		printf("wscons: copybuffer memory malloc failed\n");
		Copybuffer_size = 0;
d3220 1
a3220 1
	Copybuffer_size = size;
a3223 1

d3226 1
a3226 1
mouse_remove(struct wsdisplay_softc *sc)
d3228 2
a3229 2
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);
d3231 1
a3231 1
	mouse_hide(sc);
@


1.90
log
@Make sure wsdisplay_kbdholdscreen() checks whether the screen has a tty
before invoking wsdisplay_kbdholdscr(), which assumes it does.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.89 2009/01/10 23:02:47 miod Exp $ */
d1856 2
a1857 1
	    (!(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
d1866 2
a1867 1
	    (sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
d1876 2
a1877 1
	    !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
@


1.89
log
@Do not compile in wsdisplay_emulinput() if WSEMUL_NO_VT100 is #defined.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.88 2009/01/10 17:46:04 miod Exp $ */
d2042 1
a2042 1
	if (scr != NULL)
@


1.88
log
@When switching from emulation mode to mapped mode (i.e. X starts), it is not
enough to suspend the screen burner; the video has to be switched on if
the screen burner had run already.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.87 2008/10/06 18:31:02 miod Exp $ */
d1551 1
d1570 1
@


1.87
log
@Add missing checks for sc_focus being NULL. Found the hard way by
Jesus Sanchez.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.86 2008/06/07 20:34:36 miod Exp $ */
d1157 4
a1160 1
			/* disable the burner while X is running */
d1211 1
d1238 1
a1238 1
			if (sc->sc_burnman)
d1240 4
@


1.86
log
@Since wsmux is currently designed to act as a N inputs : 1 output device,
be more coherent when handling the attachment of output devices (displays):
- on attach, only claim the mux output if it has none already;
- on detach, only force detachment from the input devices from this display
  if we are the mux output.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.85 2008/01/23 16:37:55 jsing Exp $ */
d236 1
d910 1
a910 1
			wsdisplay_kbdholdscreen((struct device *)sc, 0);
d2015 1
a2015 1
wsdisplay_kbdholdscreen(struct device *dev, int hold)
a2016 5
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)dev;
	struct wsscreen *scr;

	scr = sc->sc_focus;

d2025 11
d2163 3
d2232 1
a2232 1
/* pointer to the current screen wsdisplay_softc structure */
d2247 3
a2249 1
			motion_event(mouse_event.type, mouse_event.value);
d2253 9
a2261 6
			/* XXX tv_sec contains the number of clicks */
			if (mouse_event.type == WSCONS_EVENT_MOUSE_DOWN) {
				button_event(mouse_event.value,
				    mouse_event.time.tv_sec);
			} else
				button_event(mouse_event.value, 0);
@


1.85
log
@Cleanup cn_pri. Change constants to more meaningful names, rather than
the hp300 related ones currently in use. CN_NORMAL becomes CN_LOWPRI,
CN_INTERNAL becomes CN_MIDPRI and CN_REMOTE becomes CN_HIGHPRI.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.83 2007/11/25 19:11:42 miod Exp $ */
d624 10
a633 1
		wsmux_detach_sc(sc->sc_input);	/* XXX not exactly correct */
d688 1
a688 1
	mux->sc_displaydv = &sc->sc_dv;
d730 6
a735 1
	wsmux_set_display(mux, &sc->sc_dv);
d1856 1
a1856 1
	
d1861 1
a1861 1
	
d3303 1
a3303 1
		if (wsms_dev != NULL) 
a3305 1
		
@


1.84
log
@Constify the output of the emulops translate() function, as well as the
various tables they use.
@
text
@d253 1
a253 1
	    wsdisplay_pollc, NULL, NODEV, CN_NORMAL
@


1.83
log
@Ask the emulation code to hide the cursor when leaving emulation mode. This
way we do not get a phantom cursor image when X exits.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.82 2007/11/24 16:45:59 miod Exp $ */
d1555 1
a1555 1
	char *dp;
@


1.82
log
@typo
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.81 2007/07/25 23:11:52 art Exp $ */
d1136 4
@


1.81
log
@Back out the tracking of procs in struct selinfo. There's one serious
bug in the code, but as soon as I try to fix it, it seems to trigger
some other bugs. Instead of trying to figure out what's going on
while everyone suffers, it's better to back out and figure out
the bugs outside the tree.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.77 2007/03/07 06:23:04 miod Exp $ */
d1839 1
a1839 1
		/* remote a potential wsmoused(8) selection */
@


1.80
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.79 2007/04/10 17:47:55 miod Exp $ */
d1405 1
a1405 1
	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_selproc == NULL)
@


1.79
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.78 2007/03/24 16:01:22 art Exp $ */
d3286 1
a3286 1
			wsmouse_input(wsms_dev, 0, 0, 0, 0,
@


1.78
log
@Kill the horrible hack of storing the pid in struct selinfo.

Instead, keep the proc pointer in it and put the selinfo on a list
in struct proc in selrecord. Then clean up the list when leaving
sys_select and sys_poll.

miod@@ ok, testing by many, including Bobs spamd boxes.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.77 2007/03/07 06:23:04 miod Exp $ */
d2114 1
a2114 1
 * Switch the console display to it's first screen.
@


1.77
log
@For unsupported (yet) Expert3D style frame buffers, attach pcons and attach
a really dumb wsdisplay to pcons, so that wskbd/wsmouse input drivers can be
used for input, and prom for output.

This is a band-aid for the release, so that people with such frame buffers
do not need to unplug them or switch to serial console to install OpenBSD.

Probably not the best way to do this, but this one has a minimal footprint
and no tentacles in wscons.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.76 2007/02/14 00:53:48 jsg Exp $ */
d1405 1
a1405 1
	if (tp->t_outq.c_cc == 0 && tp->t_wsel.si_selpid == 0)
@


1.76
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.75 2007/01/07 13:28:04 miod Exp $ */
d780 1
d788 1
a788 1
	wsdisplay_console_conf.emulops = type->textops;
d792 11
a802 1
	wsemul = wsemul_pick(""); /* default */
@


1.75
log
@In wsscreen_attach(), allow wsemul->attach to fail (returning NULL) if the
screen is not the console.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.74 2006/12/02 18:16:14 miod Exp $ */
d1307 1
a1307 1
		/* fall into */
@


1.74
log
@Use a better strategy to make the mouse pointer visible in inverse_char();
also check the return value of alloc_attr() for failure.
No functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.73 2006/11/29 19:12:53 miod Exp $ */
d291 1
a291 1
		(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d295 2
a296 4
		if (dconf == NULL) {
			free(scr, M_DEVBUF);
			return (NULL);
		}
d299 7
a305 10
		if (dconf->emulops != NULL &&
		    (dconf->wsemul = wsemul_pick(emul)) != NULL) {
			dconf->wsemulcookie =
			    (*dconf->wsemul->attach)(0, type, cookie,
				ccol, crow, scr, defattr);
		} else {
			free(dconf, M_DEVBUF);
			free(scr, M_DEVBUF);
			return (NULL);
		}
d327 6
@


1.73
log
@No need to include pcdisplay.h here anymore.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.72 2006/11/29 19:11:17 miod Exp $ */
d2404 1
d2407 5
a2413 1
	UNPACKATTR(cell.attr, &fg, &bg, &ul);
d2415 2
a2416 2
	ALLOCATTR(bg, fg, WSATTR_WSCOLORS | (ul ? WSATTR_UNDERLINE : 0),
	    &cell.attr);
d2418 19
a2436 1
	PUTCHAR(pos, cell.uc, cell.attr);
@


1.72
log
@Change the getchar wsdisplay_accessops function to not return a
display-dependent value, but instead fill a structure with the chaarcter
and a valid attribute, suitable for use with unpack_attr.

Adapt the wsmoused code to these changes, and remove all knowledge of
the text-mode style pc video attributes in it.

This will eventually allow wsmoused to be used on non-pcdisplay devices.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.71 2006/11/29 12:13:55 miod Exp $ */
a63 2

#include <dev/ic/pcdisplay.h>
@


1.71
log
@Add a new member to struct wsemuldisplaydev_attach_args, for a frame buffer
driver to be able to tell how many wscons screens to attach to it,
instead of WSDISPLAY_DEFAULTSCREENS which is a global setting.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.70 2006/11/01 03:37:24 tedu Exp $ */
d2406 2
a2407 2
	u_int16_t uc;
	u_int16_t attr;
d2409 2
a2410 2
	uc = GET_FULLCHAR(pos);
	attr = uc;
d2412 2
a2413 2
	if ((attr >> 8) == 0)
		attr = (FG_LIGHTGREY << 8);
d2415 1
a2415 3
	attr = (((attr >> 8) & 0x88) | ((((attr >> 8) >> 4) |
		((attr >> 8) << 4)) & 0x77)) ;
	PUTCHAR(pos, (u_int) (uc & 0x00FF), (long) attr);
d2441 1
d2447 2
a2448 1
	while ((GETCHAR(current) == ' ') && (current <= limit)) {
d2472 1
d2478 2
a2479 1
	while ((GETCHAR(current) == ' ') && (current >= limit)) {
d2566 1
d2569 1
a2569 1
	unsigned char class = charClass[GETCHAR(current)];
d2572 4
a2575 2
	while ((charClass[GETCHAR(current)] == class)
		&& (current <= limit)) {
d2590 1
d2593 1
a2593 1
	unsigned char class = charClass[GETCHAR(current)];
d2596 4
a2599 1
	while ((charClass[GETCHAR(current)] == class) && (current >= limit)) {
d2614 1
d2618 6
a2623 2
	first_class = charClass[GETCHAR(first)];
	second_class = charClass[GETCHAR(second)];
d2676 1
d2689 1
a2689 1
	if (IS_ALPHANUM(MOUSE)) {
d3092 1
d3103 3
a3105 1
		Copybuffer[current] = (GETCHAR(sel_cur));
@


1.70
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.69 2006/08/05 16:59:57 miod Exp $ */
d236 1
a236 1
	    void *accesscookie);
d574 1
a574 1
	    ap->accessops, ap->accesscookie);
d662 2
a663 1
    const struct wsdisplay_accessops *accessops, void *accesscookie)
d732 2
a733 1
	 * is for special cases like installation kernels.
d735 3
a737 1
	for (i = start; i < wsdisplay_defaultscreens; i++) {
@


1.69
log
@On platforms which do not use wsmux (because they can't have more than one
keyboard at once), force wskbd0 to connect to wsdisplay0 even if they are
not console devices.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.68 2006/07/11 05:57:20 miod Exp $ */
d55 1
d1347 1
a1347 1
		return (ENXIO);
d1350 1
a1350 1
		return (ENODEV);
@


1.68
log
@Compile out syncops support unless option WSDISPLAY_COMPAT_USL
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.67 2006/04/16 20:43:36 miod Exp $ */
a630 2
		extern int wskbd_set_display(struct device *, struct wsevsrc *);

d752 17
d2015 16
@


1.67
log
@Allow a non-console wsdisplay to be detached if necessary.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.66 2006/03/15 20:04:37 miod Exp $ */
d107 2
d111 1
d321 4
a324 1
	scr->scr_syncops = 0;
d499 1
d501 1
d873 1
d876 1
d1585 1
d1617 9
d1678 1
d1689 1
d1822 1
d1836 1
d1864 1
d1904 1
@


1.66
log
@Correct checks against cd_ndevs - valid numbers are strictly inferior to
cd_ndevs.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.65 2005/11/05 16:04:20 uwe Exp $ */
d207 1
d215 1
a215 1
	    wsdisplay_emul_attach,
d233 1
d495 1
a495 1
		return(EBUSY);
d528 2
a529 1
	printf("%s: screen %d deleted\n", sc->sc_dv.dv_xname, idx);
d577 56
@


1.65
log
@Check the screen number before using it as an index.
"correct" miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.64 2005/09/27 21:45:20 miod Exp $ */
d3103 1
a3103 1
			if (minor(sc->wsmoused_dev) <= wsmouse_cd.cd_ndevs) {
@


1.64
log
@More non-emulating wsdisplay tentacles removal.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.63 2005/08/20 17:09:45 matthieu Exp $ */
d922 3
@


1.63
log
@some wsdisplay devices don't have an input device attached.
Fixes multi-head on sparc. ok henning@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.62 2005/08/14 11:00:15 miod Exp $ */
a588 14

	return (UNCONF);
}

/* Print function (for parent devices). */
int
wsdisplaydevprint(void *aux, const char *pnp)
{
#if 0 /* -Wunused */
	struct wsdisplaydev_attach_args *ap = aux;
#endif

	if (pnp)
		printf("wsdisplay at %s", pnp);
@


1.62
log
@Honor (the lack of) FWRITE in the various ioctl routines; with input from
fgs@@ and mickey@@; ok deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.61 2005/07/17 10:43:24 miod Exp $ */
d998 5
a1002 5
	if (inp == NULL)
		return (ENXIO);
	error = wsevsrc_display_ioctl(inp, cmd, data, flag, p);
	if (error >= 0)
		return (error);
@


1.61
log
@Remove more non-emulating display code path and macros; no functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.60 2005/06/02 07:34:14 miod Exp $ */
d834 1
a834 1
		    (caddr_t)&kbmode, 0, p);
d986 3
a988 1
	    case WSKBDIO_SETMODE:
d991 1
a991 1
	    case WSKBDIO_GETMODE:
d1006 12
d1142 1
a1142 1
#endif
d1509 1
a1509 1
	error = wsevsrc_display_ioctl(inp, WSKBDIO_SETMODE, &data, 0, 0);
@


1.60
log
@Remove non-emulating wsdisplays - nothing uses them.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.59 2005/06/02 07:31:17 miod Exp $ */
a171 2
	struct wseventvar sc_evar;

a225 1
#define	WSSCREEN_HAS_EMULATOR(scr)	((scr)->scr_dconf->wsemul != NULL)
d284 1
a284 1
		 * If there's an emulation, tell it about the callback argument.
d287 1
a287 2
		if (dconf->wsemul != NULL)
			(*dconf->wsemul->attach)(1, 0, 0, 0, 0, scr, 0);
d297 2
a298 7
		if (dconf->emulops) {
			dconf->wsemul = wsemul_pick(emul);
			if (dconf->wsemul == NULL) {
				free(dconf, M_DEVBUF);
				free(scr, M_DEVBUF);
				return (NULL);
			}
d302 5
a306 2
		} else
			dconf->wsemul = NULL;
d314 1
a314 4
	if (WSSCREEN_HAS_EMULATOR(scr))
		scr->scr_flags = 0;
	else
		scr->scr_flags = SCR_GRAPHICS;
d336 2
a337 3
	if (WSSCREEN_HAS_EMULATOR(scr))
		(*scr->scr_dconf->wsemul->detach)(scr->scr_dconf->wsemulcookie,
		    &ccol, &crow);
d371 3
a373 6
	printf(" added (%s", sc->sc_scr[idx]->scr_dconf->scrdata->name);
	if (WSSCREEN_HAS_EMULATOR(sc->sc_scr[idx])) {
		printf(", %s emulation",
		    sc->sc_scr[idx]->scr_dconf->wsemul->name);
	}
	printf(")\n");
d777 1
a777 1
		if (newopen && WSSCREEN_HAS_EMULATOR(scr)) {
d779 1
a779 1
			 the emulation */
a781 2

			/* wsdisplay_set_emulation() */
d823 6
a828 9
	if (WSSCREEN_HAS_EMULATOR(scr)) {
		scr->scr_flags &= ~SCR_GRAPHICS;
		(*scr->scr_dconf->wsemul->reset)(scr->scr_dconf->wsemulcookie,
						 WSEMUL_RESET);
		if (wsdisplay_clearonclose)
			(*scr->scr_dconf->wsemul->reset)
				(scr->scr_dconf->wsemulcookie,
				 WSEMUL_CLEARSCREEN);
	}
d1021 5
a1025 7
	    if (WSSCREEN_HAS_EMULATOR(scr)) {
		    scr->scr_flags &= ~SCR_GRAPHICS;
		    if (d == WSDISPLAYIO_MODE_MAPPED ||
			d == WSDISPLAYIO_MODE_DUMBFB) {
			    scr->scr_flags |= SCR_GRAPHICS |
				((d == WSDISPLAYIO_MODE_DUMBFB) ?
				    SCR_DUMBFB : 0);
d1028 5
a1032 5
			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is starting
			     */
			    wsmoused_release(sc);
d1036 3
a1038 3
			    /* disable the burner while X is running */
			    if (sc->sc_burnout)
				    timeout_del(&sc->sc_burner);
d1040 1
a1040 2
		    }
		    else {
d1042 3
a1044 3
			    /* reenable the burner after exiting from X */
			    if (!sc->sc_burnman)
				    wsdisplay_burn(sc, sc->sc_burnflags);
d1048 7
a1054 10
			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is ending
			     */

			    wsmoused_wakeup(sc);
#endif
		    }
	    } else if (d == WSDISPLAYIO_MODE_EMUL)
		    return (EINVAL);
d1056 1
a1056 1
	    (void)(*sc->sc_accessops->ioctl)(sc->sc_accesscookie, cmd, data,
d1059 1
a1059 1
	    return (0);
d1069 1
a1069 1
		if (!error && WSSCREEN_HAS_EMULATOR(scr))
a1330 1
		KASSERT(WSSCREEN_HAS_EMULATOR(scr));
a1351 1
			KASSERT(WSSCREEN_HAS_EMULATOR(scr));
d1464 1
a1464 1
	else if (WSSCREEN_HAS_EMULATOR(scr)) {
a1768 2
		if (!WSSCREEN_HAS_EMULATOR(scr))
			break;
@


1.59
log
@Do not compile scrollback support if option SMALL_KERNEL.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.58 2005/05/18 21:31:27 miod Exp $ */
a208 2
int	wsdisplay_noemul_match(struct device *, void *, void *);
void	wsdisplay_noemul_attach(struct device *, struct device *, void *);
a218 5
struct cfattach wsdisplay_noemul_ca = {
	sizeof(struct wsdisplay_softc), wsdisplay_noemul_match,
	    wsdisplay_noemul_attach,
};

a603 22
}

int
wsdisplay_noemul_match(struct device *parent, void *match, void *aux)
{
#if 0 /* -Wunused */
	struct wsdisplaydev_attach_args *ap = aux;
#endif

	/* Always match. */
	return (1);
}

void
wsdisplay_noemul_attach(struct device *parent, struct device *self, void *aux)
{
	struct wsdisplay_softc *sc = (struct wsdisplay_softc *)self;
	struct wsdisplaydev_attach_args *ap = aux;

	wsdisplay_common_attach(sc, 0,
	    sc->sc_dv.dv_cfdata->wsemuldisplaydevcf_mux, NULL,
	    ap->accessops, ap->accesscookie);
@


1.58
log
@Do not compile the screen burner code if SMALL_KERNEL, helps floppies.
ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.57 2005/05/15 11:29:15 miod Exp $ */
d37 1
d2054 1
d2074 1
@


1.57
log
@Partial sync to the NetBSD wscons code, bringing a better wsmux behaviour
and bugfixes (the kqueue code, /dev/wsmuxctl and screen border color changes
have not been picked), keeping local changes.

Tested by many on alpha/cats/hp300/i386/macppc/sparc/sparc64/zaurus if not more.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.56 2004/11/05 09:38:04 miod Exp $ */
d36 1
d173 1
d180 1
d730 1
d737 1
d1083 1
d1087 1
d1090 1
d1094 1
d1126 1
d1180 1
d1384 1
d1386 1
d1406 1
d1408 1
d1988 1
d1990 1
d2073 1
d2108 1
@


1.56
log
@Better granularity between wsmouse support and wsmoused support, as one
could use wsmoused with a serial mouse; wsmoused support will now be
compiled regardless of wsmouse attachments, unless option SMALL_KERNEL.
Thanks to mickey@@ for pointing out my mistake.
@
text
@d1 2
a2 2
/* $OpenBSD: wsdisplay.c,v 1.55 2004/11/04 21:58:32 miod Exp $ */
/* $NetBSD: wsdisplay.c,v 1.37.4.1 2000/06/30 16:27:53 simonb Exp $ */
d64 1
d75 2
a76 2
#include "wsmousevar.h"
#endif /* NWSMOUSE > 0 */
d104 1
a104 1
#define	SCR_DUMBFB 8		/* in use as dumb framebuffer (iff SCR_GRAPHICS) */
d145 12
a156 10
struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int,
	const char *, const struct wsscreen_descr *, void *, int, int, long);
void wsscreen_detach(struct wsscreen *);
int wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *, const char *);
int wsdisplay_getscreen(struct wsdisplay_softc *, struct wsdisplay_addscreendata *);
void wsdisplay_shutdownhook(void *);
void wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void wsdisplay_burner(void *v);
d170 2
d188 1
a188 1
	struct wsmux_softc *sc_muxdv;
a200 3
#if NWSMUX > 0
extern struct wsmux_softc **wsmuxdevs;
#endif /* NWSMUX > 0 */
d203 4
a206 4
int wsdisplay_emul_match(struct device *, void *, void *);
void wsdisplay_emul_attach(struct device *, struct device *, void *);
int wsdisplay_noemul_match(struct device *, void *, void *);
void wsdisplay_noemul_attach(struct device *, struct device *, void *);
d222 2
a223 3
void wsdisplaystart(struct tty *);
int wsdisplayparam(struct tty *, struct termios *);

d234 2
a235 2
void wsdisplay_common_attach(struct wsdisplay_softc *sc,
	    int console, const struct wsscreen_list *,
d240 1
a240 1
int wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
d243 1
a243 1
int wsdisplay_console_initted;
d247 2
a248 2
int wsdisplay_getc_dummy(dev_t);
void wsdisplay_pollc(dev_t, int);
d250 2
a251 2
int wsdisplay_cons_pollmode;
void (*wsdisplay_cons_kbd_pollc)(dev_t, int);
d259 1
a259 1
# define WSDISPLAY_DEFAULTSCREENS	1
d261 1
a261 1
int wsdisplay_defaultscreens = WSDISPLAY_DEFAULTSCREENS;
d263 3
a265 3
int wsdisplay_switch1(void *, int, int);
int wsdisplay_switch2(void *, int, int);
int wsdisplay_switch3(void *, int, int);
d267 1
a267 1
int wsdisplay_clearonclose;
d276 3
a278 8
wsscreen_attach(sc, console, emul, type, cookie, ccol, crow, defattr)
	struct wsdisplay_softc *sc;
	int console;
	const char *emul;
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d285 1
a285 1
		return (scr);
d297 1
a297 1
			       M_DEVBUF, M_NOWAIT);
d312 2
a313 2
			  (*dconf->wsemul->attach)(0, type, cookie,
						   ccol, crow, scr, defattr);
d340 1
a340 2
wsscreen_detach(scr)
	struct wsscreen *scr;
d350 1
a350 1
						  &ccol, &crow);
d356 1
a356 3
wsdisplay_screentype_pick(scrdata, name)
	const struct wsscreen_list *scrdata;
	const char *name;
d379 1
a379 3
wsdisplay_addscreen_print(sc, idx, count)
	struct wsdisplay_softc *sc;
	int idx, count;
d387 1
a387 1
			sc->sc_scr[idx]->scr_dconf->wsemul->name);
d393 2
a394 4
wsdisplay_addscreen(sc, idx, screentype, emul)
	struct wsdisplay_softc *sc;
	int idx;
	const char *screentype, *emul;
d413 1
a413 1
			scrdesc, &cookie, &ccol, &crow, &defattr);
d418 1
a418 1
			      cookie, ccol, crow, defattr);
d420 1
a420 2
		(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,
						 cookie);
d430 1
a430 2
						 scr->scr_dconf->emulcookie,
						 0, 0, 0);
d443 2
a444 3
wsdisplay_getscreen(sc, sd)
	struct wsdisplay_softc *sc;
	struct wsdisplay_addscreendata *sd;
d466 1
a466 3
wsdisplay_closescreen(sc, scr)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
d495 1
a495 3
wsdisplay_delscreen(sc, idx, flags)
	struct wsdisplay_softc *sc;
	int idx, flags;
d503 1
a503 2
	scr = sc->sc_scr[idx];
	if (!scr)
d540 1
a540 2
	(*sc->sc_accessops->free_screen)(sc->sc_accesscookie,
					 cookie);
d550 1
a550 4
wsdisplay_emul_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d555 1
a555 2
	if (cf->wsemuldisplaydevcf_console !=
	    WSEMULDISPLAYDEVCF_CONSOLE_UNK) {
d560 1
a560 2
		if (cf->wsemuldisplaydevcf_console != 0 &&
		    ap->console != 0)
d571 1
a571 3
wsdisplay_emul_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d576 3
a578 2
	wsdisplay_common_attach(sc, ap->console, ap->scrdata,
				ap->accessops, ap->accesscookie);
d594 1
a594 3
wsemuldisplaydevprint(aux, pnp)
	void *aux;
	const char *pnp;
d610 1
a610 4
wsdisplay_noemul_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d621 1
a621 3
wsdisplay_noemul_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d626 3
a628 1
	wsdisplay_common_attach(sc, 0, NULL, ap->accessops, ap->accesscookie);
d633 1
a633 3
wsdisplaydevprint(aux, pnp)
	void *aux;
	const char *pnp;
d646 3
a648 6
wsdisplay_common_attach(sc, console, scrdata, accessops, accesscookie)
	struct wsdisplay_softc *sc;
	int console;
	const struct wsscreen_list *scrdata;
	const struct wsdisplay_accessops *accessops;
	void *accesscookie;
d653 3
a655 1
	struct device *dv;
d657 6
a662 2
	sc->sc_muxdv = wsmux_create("dmux", sc->sc_dv.dv_unit);
	if (!sc->sc_muxdv)
d664 8
a671 1
	sc->sc_muxdv->sc_displaydv = &sc->sc_dv;
d673 2
d692 6
a697 2
		if ((dv = wskbd_set_console_display(&sc->sc_dv, sc->sc_muxdv)))
			printf(", using %s", dv->dv_xname);
d706 4
d728 1
a728 1
	sc->sc_burninintvl  = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
d740 2
a741 5
wsdisplay_cnattach(type, cookie, ccol, crow, defattr)
	const struct wsscreen_descr *type;
	void *cookie;
	int ccol, crow;
	long defattr;
d757 2
a758 3
	wsdisplay_console_conf.wsemulcookie = (*wsemul->cnattach)(type, cookie,
								  ccol, crow,
								  defattr);
d769 1
a769 4
wsdisplayopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d786 1
a786 2
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
	if (!scr)
d828 1
a828 4
wsdisplayclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d841 2
a842 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d875 1
a875 1
						(caddr_t)&kbmode, 0, p);
d892 1
a892 4
wsdisplayread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d905 2
a906 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d916 1
a916 4
wsdisplaywrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d929 2
a930 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d940 1
a940 2
wsdisplaytty(dev)
	dev_t dev;
d952 2
a953 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d959 1
a959 6
wsdisplayioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d978 2
a979 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1008 1
a1008 4
wsdisplay_param(dev, cmd, dp)
	struct device *dev;
	u_long cmd;
	struct wsdisplay_param *dp;
d1011 1
d1013 1
a1013 1
					   (caddr_t)dp, 0, NULL));
d1017 2
a1018 7
wsdisplay_internal_ioctl(sc, scr, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1023 2
d1036 4
a1039 1
	error = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag, p);
d1184 2
a1185 6
wsdisplay_cfg_ioctl(sc, cmd, data, flag, p)
	struct wsdisplay_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d1190 2
a1191 2
#if defined(COMPAT_14) && NWSKBD > 0
	struct wsmux_device wsmuxdata;
d1252 1
a1252 28
#ifdef COMPAT_14
	case _O_WSDISPLAYIO_SETKEYBOARD:
#define d ((struct wsdisplay_kbddata *)data)
		switch (d->op) {
		case _O_WSDISPLAY_KBD_ADD:
			if (d->idx == -1) {
				d->idx = wskbd_pickfree();
				if (d->idx == -1)
					return (ENXIO);
			}
			wsmuxdata.type = WSMUX_KBD;
			wsmuxdata.idx = d->idx;
			return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,
					     WSMUX_ADD_DEVICE,
					     (caddr_t)&wsmuxdata, flag, p));
		case _O_WSDISPLAY_KBD_DEL:
			wsmuxdata.type = WSMUX_KBD;
			wsmuxdata.idx = d->idx;
			return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv,
					     WSMUX_REMOVE_DEVICE,
					     (caddr_t)&wsmuxdata, flag, p));
		default:
			return (EINVAL);
		}
#undef d
#endif

	case WSMUX_ADD_DEVICE:
d1258 7
a1264 4
	case WSMUX_INJECTEVENT:
	case WSMUX_REMOVE_DEVICE:
	case WSMUX_LIST_DEVICES:
		return (wsmuxdoioctl(&sc->sc_muxdv->sc_dv, cmd, data, flag,p));
d1272 1
a1272 4
wsdisplaymmap(dev, offset, prot)
	dev_t dev;
	off_t offset;
	int prot;
d1280 2
a1281 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1291 1
a1291 4
wsdisplaypoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1299 5
a1303 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1305 1
a1305 4
	if (WSSCREEN_HAS_TTY(scr))
		return (ttpoll(dev, events, p));
	else
		return (0);
d1309 1
a1309 3
wsdisplaykqfilter(dev, kn)
	dev_t dev;
	struct knote *kn;
d1317 2
a1318 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(dev)];
d1327 1
a1327 2
wsdisplaystart(tp)
	struct tty *tp;
d1347 4
a1350 1
	scr = sc->sc_scr[WSDISPLAYSCREEN(tp->t_dev)];
d1402 5
a1406 4

	tp->t_state |= TS_TIMEOUT;
	timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);

d1409 1
a1409 1
		if (tp->t_state&TS_ASLEEP) {
d1419 1
a1419 3
wsdisplaystop(tp, flag)
	struct tty *tp;
	int flag;
d1434 1
a1434 3
wsdisplayparam(tp, t)
	struct tty *tp;
	struct termios *t;
d1447 1
a1447 2
wsdisplay_emulbell(v)
	void *v;
d1458 1
a1458 1
					FWRITE, NULL);
d1462 1
a1462 4
wsdisplay_emulinput(v, data, count)
	void *v;
	const u_char *data;
	u_int count;
d1484 1
a1484 3
wsdisplay_kbdinput(dev, ks)
	struct device *dev;
	keysym_t ks;
d1513 1
a1513 3
wsdisplay_update_rawkbd(sc, scr)
	struct wsdisplay_softc *sc;
	struct wsscreen *scr;
d1515 1
d1517 2
d1523 1
a1523 2
	if (scr != sc->sc_focus ||
	    sc->sc_rawkbd == raw) {
d1529 6
a1534 2
	error = wsmux_displayioctl(&sc->sc_muxdv->sc_dv, WSKBDIO_SETMODE,
				   (caddr_t)&data, 0, 0);
d1539 3
d1546 1
a1546 3
wsdisplay_switch3(arg, error, waitok)
	void *arg;
	int error, waitok;
d1575 1
a1575 1
		sc->sc_flags &= ~SC_SWITCHPENDING;
d1592 1
a1592 3
wsdisplay_switch2(arg, error, waitok)
	void *arg;
	int error, waitok;
d1638 2
a1639 1
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb3, sc);
d1650 1
a1650 3
wsdisplay_switch1(arg, error, waitok)
	void *arg;
	int error, waitok;
d1685 2
a1686 3
						 scr->scr_dconf->emulcookie,
						 waitok,
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb2, sc);
d1696 1
a1696 3
wsdisplay_switch(dev, no, waitok)
	struct device *dev;
	int no, waitok;
d1702 6
a1707 4

	if (no != WSDISPLAY_NULLSCREEN &&
	    (no < 0 || no >= WSDISPLAY_MAXSCREEN || !sc->sc_scr[no]))
		return (ENXIO);
a1748 1
	 *
d1780 2
a1781 1
	  sc->sc_isconsole && wsdisplay_cons_pollmode ? 0 : wsswitch_cb1, sc);
d1795 1
a1795 3
wsdisplay_reset(dev, op)
	struct device *dev;
	enum wsdisplay_resetops op;
d1811 1
a1811 1
						 WSEMUL_RESET);
d1823 2
a1824 4
wsscreen_attach_sync(scr, ops, cookie)
	struct wsscreen *scr;
	const struct wscons_syncops *ops;
	void *cookie;
d1840 1
a1840 2
wsscreen_detach_sync(scr)
	struct wsscreen *scr;
d1849 3
a1851 4
wsscreen_lookup_sync(scr, ops, cookiep)
	struct wsscreen *scr;
	const struct wscons_syncops *ops; /* used as ID */
	void **cookiep;
d1863 1
a1863 2
wsdisplay_maxscreenidx(sc)
	struct wsdisplay_softc *sc;
d1869 1
a1869 3
wsdisplay_screenstate(sc, idx)
	struct wsdisplay_softc *sc;
	int idx;
d1879 1
a1879 2
wsdisplay_getactivescreen(sc)
	struct wsdisplay_softc *sc;
d1885 1
a1885 3
wsscreen_switchwait(sc, no)
	struct wsdisplay_softc *sc;
	int no;
d1919 1
a1919 3
wsdisplay_kbdholdscreen(dev, hold)
	struct device *dev;
	int hold;
d1935 2
a1936 3
struct device *
wsdisplay_set_console_kbd(kbddv)
	struct device *kbddv;
d1938 14
a1951 5
	if (!wsdisplay_console_device)
		return (0);
	if (wskbd_add_mux(kbddv->dv_unit, wsdisplay_console_device->sc_muxdv))
		return (0);
	return (&wsdisplay_console_device->sc_dv);
d1959 1
a1959 3
wsdisplay_cnputc(dev, i)
	dev_t dev;
	int i;
d1968 1
d1978 1
a1978 2
wsdisplay_getc_dummy(dev)
	dev_t dev;
d1985 1
a1985 3
wsdisplay_pollc(dev, on)
	dev_t dev;
	int on;
a1986 5
	struct wsdisplay_softc *sc = NULL;
	int unit = WSDISPLAYUNIT(dev);

	if (unit < wsdisplay_cd.cd_ndevs)
		sc = wsdisplay_cd.cd_devs[unit];
d1991 4
a1994 2
	if (sc != NULL && sc->sc_accessops->pollc != NULL)
		(*sc->sc_accessops->pollc)(sc->sc_accesscookie, on);
d2002 2
a2003 4
wsdisplay_set_cons_kbd(get, poll, bell)
	int (*get)(dev_t);
	void (*poll)(dev_t, int);
	void (*bell)(dev_t, u_int, u_int, u_int);
d2029 2
a2030 1
		scr = sc->sc_scr[0];
d2037 1
a2037 3
wsscrollback(arg, op)
	void *arg;
	int op;
d2057 1
a2057 3
wsdisplay_burn(v, flags)
	void *v;
	u_int flags;
d2072 1
a2072 2
wsdisplay_burner(v)
	void *v;
d2095 1
a2095 2
wsdisplay_shutdownhook(arg)
	void *arg;
d2113 1
a2113 1
		int flag, struct proc *p)
d2466 2
a2467 1
    48,  48,  48,  48,  48,  48,  48,  48};
@


1.55
log
@Only compile the mouse pasting code if wsmouse is configured in the kernel;
shaves a few dozens of KB on installation media.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.54 2004/09/21 18:36:23 miod Exp $ */
d34 3
a36 1
#include <sys/cdefs.h>
d113 1
a113 1
#if NWSMOUSE > 0
d141 1
a141 1
#endif	/* NWSMOUSE > 0 */
d189 1
a189 1
#if NWSMOUSE > 0
d192 1
a192 1
#endif	/* NWSMOUSE > 0 */
d268 1
a268 1
#if NWSMOUSE > 0
d334 1
a334 1
#if NWSMOUSE > 0
d449 1
a449 1
#if NWSMOUSE > 0
d904 1
a904 1
#if NWSMOUSE > 0
d1103 1
a1103 1
#if NWSMOUSE > 0
d1120 1
a1120 1
#if NWSMOUSE > 0
d1232 1
a1232 1
#if NWSMOUSE > 0
d1438 1
a1438 1
#if NWSMOUSE > 0
d1807 1
a1807 1
#if NWSMOUSE > 0
d1848 1
a1848 1
#endif	/* NWSMOUSE > 0 */
d2192 1
a2192 1
#if NWSMOUSE > 0
d3185 1
d3241 1
d3248 1
d3253 1
d3255 1
a3255 1
#endif /* NWSMOUSE > 0 */
@


1.54
log
@Do not retrigger the screen blanker if one change its settings through
wsconsctl, while running X11.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.53 2004/03/09 22:41:57 miod Exp $ */
d111 1
d139 1
d187 1
d190 1
d266 1
d270 1
d332 1
d334 1
d447 1
d449 1
d902 1
d907 1
d1101 1
d1107 1
d1118 1
d1125 1
d1230 1
d1234 1
d1436 1
d1444 1
d1805 1
d1846 1
d2190 1
a2194 1

a3178 2


a3182 1
#if NWSMOUSE > 0
a3237 1
#endif /* NWSMOUSE > 0 */
a3243 1
#if NWSMOUSE > 0
d3248 1
a3249 1
}
@


1.53
log
@Allow the screen blanker to be disabled; PR#3123
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.52 2003/10/03 16:44:51 miod Exp $ */
d1179 2
a1180 1
				wsdisplay_burn(sc, sc->sc_burnflags);
@


1.53.2.1
log
@MFC:
Fix by miod@@

Do not retrigger the screen blanker if one change its settings through
wsconsctl, while running X11.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.53 2004/03/09 22:41:57 miod Exp $ */
d1179 1
a1179 2
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
@


1.53.4.1
log
@MFC:
Fix by miod@@

Do not retrigger the screen blanker if one change its settings through
wsconsctl, while running X11.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.53 2004/03/09 22:41:57 miod Exp $ */
d1179 1
a1179 2
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
@


1.52
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.51 2003/09/23 16:51:12 millert Exp $ */
d1154 4
a1157 3
		error = EINVAL;
		if (d->flags & (WSDISPLAY_BURN_VBLANK | WSDISPLAY_BURN_KBD |
		    WSDISPLAY_BURN_MOUSE | WSDISPLAY_BURN_OUTPUT)) {
d1160 6
@


1.51
log
@Replace select backends with poll backends.  selscan() and pollscan()
now call the poll backend.  With this change we implement greater
poll(2) functionality instead of emulating it via the select backend.
Adapted from NetBSD and including some changes from FreeBSD.
Tested by many, deraadt@@ OK
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.50 2003/02/23 19:08:11 tedu Exp $ */
a317 1
	tty_attach(scr->scr_tty);
a340 1
		tty_detach(scr->scr_tty);
@


1.50
log
@initialize error

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.49 2002/10/12 01:09:44 krw Exp $ */
d1328 1
a1328 1
wsdisplayselect(dev, events, p)
d1342 1
a1342 1
		return (ttselect(dev, events, p));
@


1.50.4.1
log
@MFC:
Fix by miod@@

Do not retrigger the screen blanker if one change its settings through
wsconsctl, while running X11.

ok deraadt@@ miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.50 2003/02/23 19:08:11 tedu Exp $ */
d1174 1
a1174 2
				if ((scr->scr_flags & SCR_GRAPHICS) == 0)
					wsdisplay_burn(sc, sc->sc_burnflags);
@


1.49
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.48 2002/08/21 16:51:27 miod Exp $ */
d2304 1
d2308 1
a2308 4
		if (error)
			return error;
		else
			return (0);
@


1.48
log
@Attach one screen resource, by default, to every wsdisplay device,
instead of zero, if the kernel configuration file does not override
this setting.

This enables X11 to work on multihead sparc{,64} configurations
without the need for an explicit wsconscfg invocation first.

If a non-default emulation is requested, the user can still delete this
automatic resources and recreate it with wsconscfg.

ok mickey@@ jason@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.47 2002/07/01 18:53:00 mickey Exp $ */
d683 1
a683 1
		panic("wsdisplay_common_attach: no memory\n");
@


1.47
log
@repair burner after X, as seen on misc@@; from grange@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.46 2002/06/08 02:43:56 drahn Exp $ */
d252 1
a252 1
# define WSDISPLAY_DEFAULTSCREENS	0
@


1.46
log
@Disable the screen burner if it is enabled and X starts, and reinable upon
leaving X, if it was enabled. looked at by miod, mickey.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.45 2002/05/05 17:16:39 matthieu Exp $ */
d1103 2
a1104 2
			    if (sc->sc_burnout)
				    timeout_add(&sc->sc_burner, sc->sc_burnout);
@


1.45
log
@fix panic triggered by using a 3.0 wsmoused on a 3.1 kernel, by
checking that wsms_dev is not NULL before dereferencing it.
ok jbm@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.44 2002/04/30 23:07:48 mickey Exp $ */
d1096 4
d1102 4
@


1.44
log
@charClass is const and kill lotsa spaces
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.43 2002/04/30 23:01:55 mickey Exp $ */
d3202 4
a3205 2
		wsmouse_input(wsms_dev, 0, 0, 0, 0,
		    WSMOUSE_INPUT_WSMOUSED_CLOSE);
@


1.43
log
@cdev_decl is done in conf.h, do not dupe here
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.42 2002/03/31 17:34:15 jason Exp $ */
d112 1
a112 1
	unsigned short mouse; 		/* mouse cursor position */
d115 1
a115 1
	unsigned short cpy_start; 	/* position of the copy start mark*/
d119 2
a120 2
#define MOUSE_VISIBLE 	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS 	(1 << 1)	/* flag, a selection exists */
d122 1
a122 1
#define SEL_EXT_AFTER 	(1 << 3)	/* flag, selection is extended after */
d1091 3
a1093 3
			    /*  
			     * wsmoused cohabitation with X-Window support 
			     * X-Window is starting  
d1098 3
a1100 3
			    /*  
			     * wsmoused cohabitation with X-Window support 
			     * X-Window is ending  
d1740 1
d1771 3
a1773 3
	/* 
	 *  wsmoused cohabitation with X-Window support 
	 * 
d1780 1
a1780 1
	 *  xf86OpenPcvt()). Conversely, scr_flags is no longer flagged with 
d1782 1
a1782 1
	 *  three following 'if' statements is evaluated. 
d1787 1
a1787 1
	if (!(scr->scr_flags & SCR_GRAPHICS) && 
d1796 1
a1796 1
	if (!(scr->scr_flags & SCR_GRAPHICS) && 
d1805 1
a1805 1
	if ((scr->scr_flags & SCR_GRAPHICS) && 
d2296 1
a2296 1
		while (ws_sc->wsmoused_sleep && error == 0) 
d2299 1
a2299 1
		if (error) 
d2458 1
a2458 1
static int charClass[256] = {
d2604 1
a2604 1
    	CPY_START = MOUSE;
d2868 1
a2868 1
			       	if (CPY_END != old_cpy_end) {
d3185 1
a3185 1
			if (cdevsw[major(sc->wsmoused_dev)].d_open == 
d3193 1
a3193 1
				wsms_dev = 
d3202 1
a3202 1
		wsmouse_input(wsms_dev, 0, 0, 0, 0, 
@


1.42
log
@add a new mode to wsdisplay, WSDISPLAYIO_MODE_DUMBFB.  This mode is
functionally equivalent what used to be WSDISPLAYIO_MODE_MAPPED, which now
means a "native" mapping.
vgafb_mmap() returns pci relative mappings in WSDISPLAYIO_MODE_MAPPED and
linear framebuffer mappings in WSDISPLAYIO_MODE_DUMBFB
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.41 2002/03/27 18:54:09 jbm Exp $ */
a212 3

/* Exported tty- and cdevsw-related functions. */
cdev_decl(wsdisplay);
@


1.41
log
@Add X-Window support to wsmoused(8). This allows running wsmoused(8) and
X-Window at the same time, removing the need to kill wsmoused(8) before
starting X-Window.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.40 2002/03/16 22:11:55 mickey Exp $ */
d101 1
d1070 7
a1076 2
		*(u_int *)data = (scr->scr_flags & SCR_GRAPHICS ?
		    WSDISPLAYIO_MODE_MAPPED : WSDISPLAYIO_MODE_EMUL);
d1081 3
a1083 1
		if (d != WSDISPLAYIO_MODE_EMUL && d != WSDISPLAYIO_MODE_MAPPED)
d1088 6
a1093 2
		    if (d == WSDISPLAYIO_MODE_MAPPED) {
			    scr->scr_flags |= SCR_GRAPHICS;
@


1.40
log
@skip absent screens; from leonardo@@cefetpr.br
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.39 2002/03/14 04:55:20 mickey Exp $ */
d63 1
d71 4
d77 4
a149 3
#define WSDISPLAY_MAXSCREEN	12
#define WSDISPLAY_MAXFONT	8

d183 3
d189 3
d1080 1
a1080 1
		    if (d == WSDISPLAYIO_MODE_MAPPED)
d1082 14
d1760 42
a1814 6
	if (IS_SEL_EXISTS(sc->sc_focus))
		/* hide a potential selection */
		remove_selection(sc);

	mouse_hide(sc); /* hide a potential mouse cursor */

d2145 1
a2145 1
 * mouse console support functions
d2148 1
d2266 1
a2266 1
	int i;
d2270 1
a2270 1
			/* no wsmoused support in the display driver */
d2276 1
d2280 1
d2283 11
d3122 86
@


1.39
log
@initialized data cannot be common, dunno how it compiled before
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.38 2002/03/14 01:27:03 millert Exp $ */
d2218 12
a2229 11
	for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++) {
		sc->sc_scr[i]->mouse =
			((WS_NCOLS(sc->sc_scr[i]) *
			  WS_NROWS(sc->sc_scr[i])) / 2);
		sc->sc_scr[i]->cursor = sc->sc_scr[i]->mouse;
		sc->sc_scr[i]->cpy_start = 0;
		sc->sc_scr[i]->cpy_end = 0;
		sc->sc_scr[i]->orig_start = 0;
		sc->sc_scr[i]->orig_end = 0;
		sc->sc_scr[i]->mouse_flags = 0;
	}
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.37 2002/01/30 20:45:34 nordin Exp $ */
d251 4
@


1.37
log
@Move SET/CLR/ISSET macros to param.h. fgsch@@ and millert@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.36 2001/11/26 16:02:30 mickey Exp $ */
d130 10
a139 10
struct wsscreen *wsscreen_attach __P((struct wsdisplay_softc *, int,
	const char *, const struct wsscreen_descr *, void *, int, int, long));
void wsscreen_detach __P((struct wsscreen *));
int wsdisplay_addscreen __P((struct wsdisplay_softc *, int, const char *, const char *));
int wsdisplay_getscreen __P((struct wsdisplay_softc *, struct wsdisplay_addscreendata *));
void wsdisplay_shutdownhook __P((void *));
void wsdisplay_addscreen_print __P((struct wsdisplay_softc *, int, int));
void wsdisplay_closescreen __P((struct wsdisplay_softc *, struct wsscreen *));
int wsdisplay_delscreen __P((struct wsdisplay_softc *, int, int));
void wsdisplay_burner __P((void *v));
d182 4
a185 4
int wsdisplay_emul_match __P((struct device *, void *, void *));
void wsdisplay_emul_attach __P((struct device *, struct device *, void *));
int wsdisplay_noemul_match __P((struct device *, void *, void *));
void wsdisplay_noemul_attach __P((struct device *, struct device *, void *));
d204 2
a205 2
void wsdisplaystart __P((struct tty *));
int wsdisplayparam __P((struct tty *, struct termios *));
d217 1
a217 1
void wsdisplay_common_attach __P((struct wsdisplay_softc *sc,
d220 1
a220 1
	    void *accesscookie));
d223 1
a223 1
int wsdisplay_update_rawkbd __P((struct wsdisplay_softc *, struct wsscreen *));
d230 2
a231 2
int wsdisplay_getc_dummy __P((dev_t));
void wsdisplay_pollc __P((dev_t, int));
d234 1
a234 1
void (*wsdisplay_cons_kbd_pollc) __P((dev_t, int));
d246 3
a248 3
int wsdisplay_switch1 __P((void *, int, int));
int wsdisplay_switch2 __P((void *, int, int));
int wsdisplay_switch3 __P((void *, int, int));
d1630 1
a1630 1
#define wsswitch_cb3 ((void (*) __P((void *, int, int)))wsdisplay_switch3)
d1679 1
a1679 1
#define wsswitch_cb2 ((void (*) __P((void *, int, int)))wsdisplay_switch2)
d1730 1
a1730 1
#define wsswitch_cb1 ((void (*) __P((void *, int, int)))wsdisplay_switch1)
d1974 3
a1976 3
	int (*get) __P((dev_t));
	void (*poll) __P((dev_t, int));
	void (*bell) __P((dev_t, u_int, u_int, u_int));
@


1.36
log
@allow pasting chars w/ codes >127 w/ mouse; from Denis Afonin <dfa@@solo.ee>
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.35 2001/11/01 12:13:47 art Exp $ */
a208 4
#define	SET(t, f)	(t) |= (f)
#define	CLR(t, f)	(t) &= ~(f)
#define	ISSET(t, f)	((t) & (f))

@


1.36.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.37 2002/01/30 20:45:34 nordin Exp $ */
d209 4
@


1.36.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.36.2.1 2002/01/31 22:55:39 niklas Exp $ */
a62 1
#include "wsmouse.h"
a69 4
#if NWSMOUSE > 0
#include "wsmousevar.h"
#endif /* NWSMOUSE > 0 */

a71 4
#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

a91 1
#define	SCR_DUMBFB 8		/* in use as dumb framebuffer (iff SCR_GRAPHICS) */
d102 1
a102 1
	unsigned short mouse;		/* mouse cursor position */
d105 1
a105 1
	unsigned short cpy_start;	/* position of the copy start mark*/
d109 2
a110 2
#define MOUSE_VISIBLE	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS	(1 << 1)	/* flag, a selection exists */
d112 1
a112 1
#define SEL_EXT_AFTER	(1 << 3)	/* flag, selection is extended after */
d130 13
a142 10
struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int,
	const char *, const struct wsscreen_descr *, void *, int, int, long);
void wsscreen_detach(struct wsscreen *);
int wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *, const char *);
int wsdisplay_getscreen(struct wsdisplay_softc *, struct wsdisplay_addscreendata *);
void wsdisplay_shutdownhook(void *);
void wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void wsdisplay_burner(void *v);
a176 3

	dev_t wsmoused_dev; /* device opened by wsmoused(8), when active */
	int wsmoused_sleep; /* true when wsmoused(8) is sleeping */
a179 3
#if NWSMUX > 0
extern struct wsmux_softc **wsmuxdevs;
#endif /* NWSMUX > 0 */
d182 4
a185 4
int wsdisplay_emul_match(struct device *, void *, void *);
void wsdisplay_emul_attach(struct device *, struct device *, void *);
int wsdisplay_noemul_match(struct device *, void *, void *);
void wsdisplay_noemul_attach(struct device *, struct device *, void *);
d201 5
a205 2
void wsdisplaystart(struct tty *);
int wsdisplayparam(struct tty *, struct termios *);
d217 1
a217 1
void wsdisplay_common_attach(struct wsdisplay_softc *sc,
d220 1
a220 1
	    void *accesscookie);
d223 1
a223 1
int wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
d230 2
a231 2
int wsdisplay_getc_dummy(dev_t);
void wsdisplay_pollc(dev_t, int);
d234 1
a234 1
void (*wsdisplay_cons_kbd_pollc)(dev_t, int);
d246 3
a248 3
int wsdisplay_switch1(void *, int, int);
int wsdisplay_switch2(void *, int, int);
int wsdisplay_switch3(void *, int, int);
a251 4
char *Copybuffer;
u_int Copybuffer_size;
char Paste_avail;

d1053 2
a1054 7
		if (scr->scr_flags & SCR_GRAPHICS) {
			if (scr->scr_flags & SCR_DUMBFB)
				*(u_int *)data = WSDISPLAYIO_MODE_DUMBFB;
			else
				*(u_int *)data = WSDISPLAYIO_MODE_MAPPED;
		} else
			*(u_int *)data = WSDISPLAYIO_MODE_EMUL;
d1059 1
a1059 3
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED &&
		    d != WSDISPLAYIO_MODE_DUMBFB)
d1064 2
a1065 28
		    if (d == WSDISPLAYIO_MODE_MAPPED ||
			d == WSDISPLAYIO_MODE_DUMBFB) {
			    scr->scr_flags |= SCR_GRAPHICS |
				((d == WSDISPLAYIO_MODE_DUMBFB) ?
				    SCR_DUMBFB : 0);

			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is starting
			     */
			    wsmoused_release(sc);

			    /* disable the burner while X is running */
			    if (sc->sc_burnout)
				    timeout_del(&sc->sc_burner);
		    }
		    else {
			    /* reenable the burner after exiting from X */
			    if (sc->sc_burnout)
				    timeout_add(&sc->sc_burner, sc->sc_burnout);

			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is ending
			     */

			    wsmoused_wakeup(sc);
		    }
d1630 1
a1630 1
#define wsswitch_cb3 ((void (*)(void *, int, int))wsdisplay_switch3)
d1679 1
a1679 1
#define wsswitch_cb2 ((void (*)(void *, int, int))wsdisplay_switch2)
a1700 1

d1730 1
a1730 43

	/*
	 *  wsmoused cohabitation with X-Window support
	 *
	 *  Detect switch from a graphic to text console and vice-versa
	 *  This only happen when switching from X-Window to text mode and
	 *  switching back from text mode to X-Window.
	 *
	 *  scr_flags is not yet flagged with SCR_GRAPHICS when X-Window starts
	 *  (KD_GRAPHICS ioctl happens after VT_ACTIVATE ioctl in
	 *  xf86OpenPcvt()). Conversely, scr_flags is no longer flagged with
	 *  SCR_GRAPHICS when X-Window stops. In this case, the first of the
	 *  three following 'if' statements is evaluated.
	 *  We handle wsmoused(8) events the WSDISPLAYIO_SMODE ioctl.
	 *
	 */

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (!(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a text console to another text console */
		/* XXX evaluated when the X-server starts or stops, see above */

		/* remove a potential wsmoused(8) selection */
		mouse_remove(sc);
	}

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a text console to a graphic console */
	
		/* remote a potential wsmoused(8) selection */
		mouse_remove(sc);
		wsmoused_release(sc);
	}
	
	if ((scr->scr_flags & SCR_GRAPHICS) &&
	    !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a graphic console to a text console */

		wsmoused_wakeup(sc);
	}

#define wsswitch_cb1 ((void (*)(void *, int, int))wsdisplay_switch1)
d1743 6
d1974 3
a1976 3
	int (*get)(dev_t);
	void (*poll)(dev_t, int);
	void (*bell)(dev_t, u_int, u_int, u_int);
d2079 1
a2079 1
 * wsmoused(8) support functions
a2081 1

d2199 1
a2199 1
	int i, error;
d2203 1
a2203 1
			/* no wsmoused(8) support in the display driver */
a2208 1
		ws_sc->wsmoused_dev = value;
a2211 1
		ws_sc->wsmoused_dev = 0;
d2214 10
a2223 10
	if (type == WSCONS_EVENT_WSMOUSED_SLEEP) {
		/* sleeping until next switch to text mode */
		ws_sc->wsmoused_sleep = 1;
		while (ws_sc->wsmoused_sleep && error == 0)
			error = tsleep(&ws_sc->wsmoused_sleep, PPAUSE,
			    "wsmoused_sleep", 0);
		if (error)
			return error;
		else
			return (0);
a2224 12
	for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++)
		if (sc->sc_scr[i]) {
			sc->sc_scr[i]->mouse =
				((WS_NCOLS(sc->sc_scr[i]) *
				  WS_NROWS(sc->sc_scr[i])) / 2);
			sc->sc_scr[i]->cursor = sc->sc_scr[i]->mouse;
			sc->sc_scr[i]->cpy_start = 0;
			sc->sc_scr[i]->cpy_end = 0;
			sc->sc_scr[i]->orig_start = 0;
			sc->sc_scr[i]->orig_end = 0;
			sc->sc_scr[i]->mouse_flags = 0;
		}
d2367 1
a2367 1
static const int charClass[256] = {
d2513 1
a2513 1
	CPY_START = MOUSE;
d2777 1
a2777 1
				if (CPY_END != old_cpy_end) {
a3040 88
}


/* Remove selection and cursor on current screen */
void
mouse_remove(struct wsdisplay_softc *sc)
{
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	mouse_hide(sc);
}



/* Send a wscons event to notify wsmoused(8) to release the mouse device */
void
wsmoused_release(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	struct device *wsms_dev = NULL;
	struct device **wsms_dev_list;
	int is_wsmouse = 0;
#if NWSMUX > 0
	int is_wsmux = 0;
#endif /* NWSMUX > 0 */

	if (sc->wsmoused_dev) {
		/* wsmoused(8) is running */

		wsms_dev_list = (struct device **) wsmouse_cd.cd_devs;
		if (!wsms_dev_list)
			/* no wsmouse device exists */
			return ;

		/* test whether device opened by wsmoused(8) is a wsmux device
		 * (/dev/wsmouse) or a wsmouse device (/dev/wsmouse{0..n} */

#if NWSMUX > 0
		/* obtain major of /dev/wsmouse multiplexor device */
		/* XXX first member of wsmux_softc is of type struct device */
		if (cdevsw[major(sc->wsmoused_dev)].d_open == wsmuxopen)
			is_wsmux = 1;

		if (is_wsmux && (minor(sc->wsmoused_dev) == WSMOUSEDEVCF_MUX)) {
			/* /dev/wsmouse case */
			/* XXX at least, wsmouse0 exist */
			wsms_dev = wsms_dev_list[0];
		}
#endif /* NWSMUX > 0 */

		/* obtain major of /dev/wsmouse{0..n} devices */
		if (wsmouse_cd.cd_ndevs > 0) {
			if (cdevsw[major(sc->wsmoused_dev)].d_open ==
			     wsmouseopen)
				is_wsmouse = 1;
		}

		if (is_wsmouse && (minor(sc->wsmoused_dev) <= NWSMOUSE)) {
			/* /dev/wsmouseX case */
			if (minor(sc->wsmoused_dev) <= wsmouse_cd.cd_ndevs) {
				wsms_dev =
				    wsms_dev_list[minor(sc->wsmoused_dev)];
			}
			else
				/* no corresponding /dev/wsmouseX device */
				return;
		}

		/* inject event to notify wsmoused(8) to close mouse device */
		if (wsms_dev != NULL) 
			wsmouse_input(wsms_dev, 0, 0, 0, 0,
				      WSMOUSE_INPUT_WSMOUSED_CLOSE);
		
	}
#endif /* NWSMOUSE > 0 */
}

/* Wakeup wsmoused(8), so that the mouse device can be reopened */
void
wsmoused_wakeup(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	if (sc->wsmoused_dev) {
		sc->wsmoused_sleep = 0;
		wakeup(&sc->wsmoused_sleep);
	}
#endif /* NWSMOUSE > 0 */
@


1.36.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.36.2.2 2002/06/11 03:42:31 art Exp $ */
d252 1
a252 1
# define WSDISPLAY_DEFAULTSCREENS	1
d683 1
a683 1
		panic("wsdisplay_common_attach: no memory");
d1103 2
a1104 2
			    if (!sc->sc_burnman)
				    wsdisplay_burn(sc, sc->sc_burnflags);
@


1.36.2.4
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a2303 1
		error = 0;
d2307 4
a2310 1
		return (error);
@


1.35
log
@Change d_mmap in struct cdevsw from:
        int     (*d_mmap)       __P((dev_t, int, int));
to:
	paddr_t	(*d_mmap)	__P((dev_t, off_t, int));

This allows us to mmap devices past 4GB offsets.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.34 2001/09/16 00:42:44 millert Exp $ */
d2990 1
a2990 1
	char *current = Copybuffer;
@


1.34
log
@Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.33 2001/08/29 20:26:18 mickey Exp $ */
d1263 1
a1263 1
int
d1266 1
a1266 1
	int offset;		/* XXX */
@


1.33
log
@less defines
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.32 2001/08/29 20:20:26 mickey Exp $ */
d1159 1
d1190 6
a1195 4
		buf = malloc(d->fontheight * d->stride * d->numchars,
			     M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf,
			       d->fontheight * d->stride * d->numchars);
@


1.32
log
@make set/get screen work now
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.31 2001/07/10 11:07:25 espie Exp $ */
d1137 3
a1139 3
#define d ((struct wsdisplay_addscreendata *)data)
		return (wsdisplay_getscreen(sc, d));
#undef d
d1179 2
a1180 3
#define d ((struct wsdisplay_addscreendata *)data)
		return (wsdisplay_getscreen(sc, d));
#undef d
@


1.31
log
@ANSI C does not like labels: without a statement after that.
Restore missing breaks.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.30 2001/06/29 20:16:22 mickey Exp $ */
d1136 6
@


1.30
log
@implement get/set screen ioctls to fetch configured screen list
and switch focus out of comand line utility (to come soon).
also, fix duplicated ioctl numbers, so rebuild the ws* utils.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.29 2001/05/24 04:12:04 angelos Exp $ */
d2130 1
@


1.29
log
@Check malloc() return value, from tedu@@heorot.stanford.edu
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.28 2001/05/16 19:38:27 mickey Exp $ */
d134 1
d221 4
a224 4
void wsdisplay_common_attach __P((struct wsdisplay_softc *sc, int console,
				  const struct wsscreen_list *,
				  const struct wsdisplay_accessops *accessops,
				  void *accesscookie));
d435 24
d1172 6
@


1.28
log
@it is not right to malloc() w/ WAITOK at attach time, put back NULL check and change to NOWAIT
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.27 2001/05/16 12:51:50 ho Exp $ */
d283 4
@


1.27
log
@No need to check M_WAIT/M_WAITOK malloc return values. (art@@ ok)
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.26 2001/05/08 22:28:43 mickey Exp $ */
d268 3
a270 1
	scr = malloc(sizeof(struct wsscreen), M_DEVBUF, M_WAITOK);
d655 2
@


1.26
log
@inplement screen burner in screenblank(1) style (no program though).
disabled by default, also supports vsync blanking, disabled by default.
aaron@@ looked at it a while back and i fixed problems he had indicated.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.25 2001/05/01 02:23:22 aaron Exp $ */
a268 2
	if (!scr)
		return (NULL);
@


1.26.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.24 2001/04/17 23:24:31 aaron Exp $ */
d131 1
a131 3
				      const char *,
				      const struct wsscreen_descr *, void *,
				      int, int, long));
d133 1
a133 2
int wsdisplay_addscreen __P((struct wsdisplay_softc *, int, const char *,
			     const char *));
d138 1
d155 7
d229 3
a231 3
static int wsdisplay_console_initted;
static struct wsdisplay_softc *wsdisplay_console_device;
static struct wsscreen_internal wsdisplay_console_conf;
d236 1
a236 1
static int wsdisplay_cons_pollmode;
d239 1
a239 1
static struct consdev wsdisplay_cons = {
d689 7
d1009 9
a1017 9
		switch (cmd) {
		    case WSKBDIO_SETMODE:
			scr->scr_rawkbd = (*(int *)data == WSKBD_RAW);
			return (wsdisplay_update_rawkbd(sc, scr));
		    case WSKBDIO_GETMODE:
			*(int *)data = (scr->scr_rawkbd ?
					WSKBD_RAW : WSKBD_TRANSLATED);
			return (0);
		}
d1020 1
a1020 1
		if (error >= 0)
d1027 1
a1027 2
				  WSDISPLAYIO_MODE_MAPPED :
				  WSDISPLAYIO_MODE_EMUL);
d1032 1
a1032 2
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED)
d1054 1
a1054 1
					scr->scr_dconf->emulcookie, d);
d1057 46
a1102 1
				(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);
d1158 1
a1158 1
		if (error || d->index < 0)
d1160 1
a1160 1
		else
d1323 1
d1341 1
d1433 1
a1433 1
};
d1897 1
d1989 38
d2982 1
a2982 1
	s = splhigh();
@


1.26.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.26.2.1 2001/05/14 22:26:30 niklas Exp $ */
d131 3
a133 1
	const char *, const struct wsscreen_descr *, void *, int, int, long));
d135 2
a136 2
int wsdisplay_addscreen __P((struct wsdisplay_softc *, int, const char *, const char *));
int wsdisplay_getscreen __P((struct wsdisplay_softc *, struct wsdisplay_addscreendata *));
a140 1
void wsdisplay_burner __P((void *v));
a156 7
	struct timeout sc_burner;
	int	sc_burnoutintvl;
	int	sc_burninintvl;
	int	sc_burnout;
	int	sc_burnman;
	int	sc_burnflags;

d215 4
a218 4
void wsdisplay_common_attach __P((struct wsdisplay_softc *sc,
	    int console, const struct wsscreen_list *,
	    const struct wsdisplay_accessops *accessops,
	    void *accesscookie));
d224 3
a226 3
int wsdisplay_console_initted;
struct wsdisplay_softc *wsdisplay_console_device;
struct wsscreen_internal wsdisplay_console_conf;
d231 1
a231 1
int wsdisplay_cons_pollmode;
d234 1
a234 1
struct consdev wsdisplay_cons = {
d263 1
a263 1
	scr = malloc(sizeof(struct wsscreen), M_DEVBUF, M_NOWAIT);
d265 1
a265 1
		return (scr);
a277 4
		if (dconf == NULL) {
			free(scr, M_DEVBUF);
			return (NULL);
		}
a424 24
int
wsdisplay_getscreen(sc, sd)
	struct wsdisplay_softc *sc;
	struct wsdisplay_addscreendata *sd;
{
	struct wsscreen *scr;

	if (sd->idx < 0 && sc->sc_focus)
		sd->idx = sc->sc_focusidx;

	if (sd->idx < 0 || sd->idx >= WSDISPLAY_MAXSCREEN)
		return (EINVAL);

	scr = sc->sc_scr[sd->idx];
	if (scr == NULL)
		return (ENXIO);

	strncpy(sd->screentype, scr->scr_dconf->scrdata->name,
	    WSSCREEN_NAME_SIZE);
	strncpy(sd->emul, scr->scr_dconf->wsemul->name, WSEMUL_NAME_SIZE);

	return (0);
}

a649 2
		if (sc->sc_scr[0] == NULL)
			return;
a683 7
	sc->sc_burnoutintvl = (hz * WSDISPLAY_DEFBURNOUT) / 1000;
	sc->sc_burninintvl  = (hz * WSDISPLAY_DEFBURNIN ) / 1000;
	sc->sc_burnflags = 0;	/* off by default */
	timeout_set(&sc->sc_burner, wsdisplay_burner, sc);
	sc->sc_burnout = sc->sc_burnoutintvl;
	wsdisplay_burn(sc, sc->sc_burnflags);

d997 9
a1005 9
	switch (cmd) {
	    case WSKBDIO_SETMODE:
		scr->scr_rawkbd = (*(int *)data == WSKBD_RAW);
		return (wsdisplay_update_rawkbd(sc, scr));
	    case WSKBDIO_GETMODE:
		*(int *)data = (scr->scr_rawkbd ?
				WSKBD_RAW : WSKBD_TRANSLATED);
		return (0);
	}
d1008 1
a1008 1
	if (error >= 0)
d1015 2
a1016 1
		    WSDISPLAYIO_MODE_MAPPED : WSDISPLAYIO_MODE_EMUL);
d1021 2
a1022 1
		if (d != WSDISPLAYIO_MODE_EMUL && d != WSDISPLAYIO_MODE_MAPPED)
d1044 1
a1044 1
		    scr->scr_dconf->emulcookie, d);
d1047 1
a1047 46
			    (scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);
		return (error);
#undef d
	case WSDISPLAYIO_GVIDEO:
		*(u_int *)data = !sc->sc_burnman;
		break;

	case WSDISPLAYIO_SVIDEO:
		if (*(u_int *)data != WSDISPLAYIO_VIDEO_OFF &&
		    *(u_int *)data != WSDISPLAYIO_VIDEO_ON)
			return (EINVAL);
		if (sc->sc_accessops->burn_screen == NULL)
			return (EOPNOTSUPP);
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		     *(u_int *)data, sc->sc_burnflags);
		break;

	case WSDISPLAYIO_GBURNER:
#define d ((struct wsdisplay_burner *)data)
		d->on  = sc->sc_burninintvl  * 1000 / hz;
		d->off = sc->sc_burnoutintvl * 1000 / hz;
		d->flags = sc->sc_burnflags;
		return (0);

	case WSDISPLAYIO_SBURNER:
		error = EINVAL;
		if (d->flags & (WSDISPLAY_BURN_VBLANK | WSDISPLAY_BURN_KBD |
		    WSDISPLAY_BURN_MOUSE | WSDISPLAY_BURN_OUTPUT)) {
			error = 0;
			sc->sc_burnflags = d->flags;
		}
		if (d->on) {
			error = 0;
			sc->sc_burninintvl = hz * d->on / 1000;
			if (sc->sc_burnman)
				sc->sc_burnout = sc->sc_burninintvl;
		}
		if (d->off) {
			error = 0;
			sc->sc_burnoutintvl = hz * d->off / 1000;
			if (!sc->sc_burnman) {
				sc->sc_burnout = sc->sc_burnoutintvl;
				/* reinit timeout if changed */
				wsdisplay_burn(sc, sc->sc_burnflags);
			}
		}
a1085 6
	case WSDISPLAYIO_GETSCREEN:
#define d ((struct wsdisplay_addscreendata *)data)
		return (wsdisplay_getscreen(sc, d));
#undef d
	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));
d1103 1
a1103 1
		if (error)
d1105 1
a1105 1
		else if (d->index >= 0 || d->index < WSDISPLAY_MAXFONT)
a1267 1
		wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
a1284 1
			wsdisplay_burn(sc, WSDISPLAY_BURN_OUTPUT);
d1376 1
a1376 1
}
a1839 1
	/*wsdisplay_burn(wsdisplay_console_device, WSDISPLAY_BURN_OUTPUT);*/
a1930 38
void
wsdisplay_burn(v, flags)
	void *v;
	u_int flags;
{
	struct wsdisplay_softc *sc = v;

	if ((flags & sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
	    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) &&
	    sc->sc_accessops->burn_screen) {
		if (sc->sc_burnout)
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		if (sc->sc_burnman)
			sc->sc_burnout = 0;
	}
}

void
wsdisplay_burner(v)
	void *v;
{
	struct wsdisplay_softc *sc = v;
	int s;

	if (sc->sc_accessops->burn_screen) {
		(*sc->sc_accessops->burn_screen)(sc->sc_accesscookie,
		    sc->sc_burnman, sc->sc_burnflags);
		s = spltty();
		if (sc->sc_burnman) {
			sc->sc_burnout = sc->sc_burnoutintvl;
			timeout_add(&sc->sc_burner, sc->sc_burnout);
		} else
			sc->sc_burnout = sc->sc_burninintvl;
		sc->sc_burnman = !sc->sc_burnman;
		splx(s);
	}
}

d2886 1
a2886 1
	s = spltty();
@


1.26.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.26.2.2 2001/07/04 10:44:09 niklas Exp $ */
a1135 6
	case WSDISPLAYIO_GETSCREEN:
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));

	case WSDISPLAYIO_SETSCREEN:
		return (wsdisplay_switch((void *)sc, *(int *)data, 1));
a1152 1
	size_t fontsz;
d1173 3
a1175 2
		return (wsdisplay_getscreen(sc,
		    (struct wsdisplay_addscreendata *)data));
d1184 4
a1187 6
		fontsz = d->fontheight * d->stride * d->numchars;
		if (fontsz > WSDISPLAY_MAXFONTSZ)
			return (EINVAL);

		buf = malloc(fontsz, M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf, fontsz);
a2129 1
			break;
@


1.26.2.4
log
@Merge in -current
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d1263 1
a1263 1
paddr_t
d1266 1
a1266 1
	off_t offset;
@


1.26.2.5
log
@Merge in -current
@
text
@d2990 1
a2990 1
	unsigned char *current = Copybuffer;
@


1.26.2.6
log
@Merge in trunk
@
text
@d209 4
@


1.26.2.7
log
@Merge in -current from roughly a week ago
@
text
@d130 10
a139 10
struct wsscreen *wsscreen_attach(struct wsdisplay_softc *, int,
	const char *, const struct wsscreen_descr *, void *, int, int, long);
void wsscreen_detach(struct wsscreen *);
int wsdisplay_addscreen(struct wsdisplay_softc *, int, const char *, const char *);
int wsdisplay_getscreen(struct wsdisplay_softc *, struct wsdisplay_addscreendata *);
void wsdisplay_shutdownhook(void *);
void wsdisplay_addscreen_print(struct wsdisplay_softc *, int, int);
void wsdisplay_closescreen(struct wsdisplay_softc *, struct wsscreen *);
int wsdisplay_delscreen(struct wsdisplay_softc *, int, int);
void wsdisplay_burner(void *v);
d182 4
a185 4
int wsdisplay_emul_match(struct device *, void *, void *);
void wsdisplay_emul_attach(struct device *, struct device *, void *);
int wsdisplay_noemul_match(struct device *, void *, void *);
void wsdisplay_noemul_attach(struct device *, struct device *, void *);
d204 2
a205 2
void wsdisplaystart(struct tty *);
int wsdisplayparam(struct tty *, struct termios *);
d217 1
a217 1
void wsdisplay_common_attach(struct wsdisplay_softc *sc,
d220 1
a220 1
	    void *accesscookie);
d223 1
a223 1
int wsdisplay_update_rawkbd(struct wsdisplay_softc *, struct wsscreen *);
d230 2
a231 2
int wsdisplay_getc_dummy(dev_t);
void wsdisplay_pollc(dev_t, int);
d234 1
a234 1
void (*wsdisplay_cons_kbd_pollc)(dev_t, int);
d246 3
a248 3
int wsdisplay_switch1(void *, int, int);
int wsdisplay_switch2(void *, int, int);
int wsdisplay_switch3(void *, int, int);
a251 4
char *Copybuffer;
u_int Copybuffer_size;
char Paste_avail;

d1630 1
a1630 1
#define wsswitch_cb3 ((void (*)(void *, int, int))wsdisplay_switch3)
d1679 1
a1679 1
#define wsswitch_cb2 ((void (*)(void *, int, int))wsdisplay_switch2)
d1730 1
a1730 1
#define wsswitch_cb1 ((void (*)(void *, int, int))wsdisplay_switch1)
d1974 3
a1976 3
	int (*get)(dev_t);
	void (*poll)(dev_t, int);
	void (*bell)(dev_t, u_int, u_int, u_int);
d2214 11
a2224 12
	for (i = 0 ; i < WSDISPLAY_DEFAULTSCREENS ; i++)
		if (sc->sc_scr[i]) {
			sc->sc_scr[i]->mouse =
				((WS_NCOLS(sc->sc_scr[i]) *
				  WS_NROWS(sc->sc_scr[i])) / 2);
			sc->sc_scr[i]->cursor = sc->sc_scr[i]->mouse;
			sc->sc_scr[i]->cpy_start = 0;
			sc->sc_scr[i]->cpy_end = 0;
			sc->sc_scr[i]->orig_start = 0;
			sc->sc_scr[i]->orig_end = 0;
			sc->sc_scr[i]->mouse_flags = 0;
		}
@


1.26.2.8
log
@Sync the SMP branch with 3.3
@
text
@a62 1
#include "wsmouse.h"
a69 4
#if NWSMOUSE > 0
#include "wsmousevar.h"
#endif /* NWSMOUSE > 0 */

a71 4
#if NWSMOUSE > 0
extern struct cfdriver wsmouse_cd;
#endif /* NWSMOUSE > 0 */

a91 1
#define	SCR_DUMBFB 8		/* in use as dumb framebuffer (iff SCR_GRAPHICS) */
d102 1
a102 1
	unsigned short mouse;		/* mouse cursor position */
d105 1
a105 1
	unsigned short cpy_start;	/* position of the copy start mark*/
d109 2
a110 2
#define MOUSE_VISIBLE	(1 << 0)	/* flag, the mouse cursor is visible */
#define SEL_EXISTS	(1 << 1)	/* flag, a selection exists */
d112 1
a112 1
#define SEL_EXT_AFTER	(1 << 3)	/* flag, selection is extended after */
d141 3
a176 3

	dev_t wsmoused_dev; /* device opened by wsmoused(8), when active */
	int wsmoused_sleep; /* true when wsmoused(8) is sleeping */
a179 3
#if NWSMUX > 0
extern struct wsmux_softc **wsmuxdevs;
#endif /* NWSMUX > 0 */
d201 3
d242 1
a242 1
# define WSDISPLAY_DEFAULTSCREENS	1
d673 1
a673 1
		panic("wsdisplay_common_attach: no memory");
d1057 2
a1058 7
		if (scr->scr_flags & SCR_GRAPHICS) {
			if (scr->scr_flags & SCR_DUMBFB)
				*(u_int *)data = WSDISPLAYIO_MODE_DUMBFB;
			else
				*(u_int *)data = WSDISPLAYIO_MODE_MAPPED;
		} else
			*(u_int *)data = WSDISPLAYIO_MODE_EMUL;
d1063 1
a1063 3
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED &&
		    d != WSDISPLAYIO_MODE_DUMBFB)
d1068 2
a1069 28
		    if (d == WSDISPLAYIO_MODE_MAPPED ||
			d == WSDISPLAYIO_MODE_DUMBFB) {
			    scr->scr_flags |= SCR_GRAPHICS |
				((d == WSDISPLAYIO_MODE_DUMBFB) ?
				    SCR_DUMBFB : 0);

			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is starting
			     */
			    wsmoused_release(sc);

			    /* disable the burner while X is running */
			    if (sc->sc_burnout)
				    timeout_del(&sc->sc_burner);
		    }
		    else {
			    /* reenable the burner after exiting from X */
			    if (!sc->sc_burnman)
				    wsdisplay_burn(sc, sc->sc_burnflags);

			    /*
			     * wsmoused cohabitation with X-Window support
			     * X-Window is ending
			     */

			    wsmoused_wakeup(sc);
		    }
a1704 1

a1733 42

	/*
	 *  wsmoused cohabitation with X-Window support
	 *
	 *  Detect switch from a graphic to text console and vice-versa
	 *  This only happen when switching from X-Window to text mode and
	 *  switching back from text mode to X-Window.
	 *
	 *  scr_flags is not yet flagged with SCR_GRAPHICS when X-Window starts
	 *  (KD_GRAPHICS ioctl happens after VT_ACTIVATE ioctl in
	 *  xf86OpenPcvt()). Conversely, scr_flags is no longer flagged with
	 *  SCR_GRAPHICS when X-Window stops. In this case, the first of the
	 *  three following 'if' statements is evaluated.
	 *  We handle wsmoused(8) events the WSDISPLAYIO_SMODE ioctl.
	 *
	 */

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (!(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS))) {
		/* switching from a text console to another text console */
		/* XXX evaluated when the X-server starts or stops, see above */

		/* remove a potential wsmoused(8) selection */
		mouse_remove(sc);
	}

	if (!(scr->scr_flags & SCR_GRAPHICS) &&
	    (sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a text console to a graphic console */
	
		/* remote a potential wsmoused(8) selection */
		mouse_remove(sc);
		wsmoused_release(sc);
	}
	
	if ((scr->scr_flags & SCR_GRAPHICS) &&
	    !(sc->sc_scr[no]->scr_flags & SCR_GRAPHICS)) {
		/* switching from a graphic console to a text console */

		wsmoused_wakeup(sc);
	}

d1747 6
d2083 1
a2083 1
 * wsmoused(8) support functions
a2085 1

d2203 1
a2203 1
	int i, error;
d2207 1
a2207 1
			/* no wsmoused(8) support in the display driver */
a2212 1
		ws_sc->wsmoused_dev = value;
a2215 1
		ws_sc->wsmoused_dev = 0;
a2217 9
	if (type == WSCONS_EVENT_WSMOUSED_SLEEP) {
		/* sleeping until next switch to text mode */
		ws_sc->wsmoused_sleep = 1;
		error = 0;
		while (ws_sc->wsmoused_sleep && error == 0)
			error = tsleep(&ws_sc->wsmoused_sleep, PPAUSE,
			    "wsmoused_sleep", 0);
		return (error);
	}
d2372 1
a2372 1
static const int charClass[256] = {
d2518 1
a2518 1
	CPY_START = MOUSE;
d2782 1
a2782 1
				if (CPY_END != old_cpy_end) {
a3045 88
}


/* Remove selection and cursor on current screen */
void
mouse_remove(struct wsdisplay_softc *sc)
{
	if (IS_SEL_EXISTS(sc->sc_focus))
		remove_selection(sc);

	mouse_hide(sc);
}



/* Send a wscons event to notify wsmoused(8) to release the mouse device */
void
wsmoused_release(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	struct device *wsms_dev = NULL;
	struct device **wsms_dev_list;
	int is_wsmouse = 0;
#if NWSMUX > 0
	int is_wsmux = 0;
#endif /* NWSMUX > 0 */

	if (sc->wsmoused_dev) {
		/* wsmoused(8) is running */

		wsms_dev_list = (struct device **) wsmouse_cd.cd_devs;
		if (!wsms_dev_list)
			/* no wsmouse device exists */
			return ;

		/* test whether device opened by wsmoused(8) is a wsmux device
		 * (/dev/wsmouse) or a wsmouse device (/dev/wsmouse{0..n} */

#if NWSMUX > 0
		/* obtain major of /dev/wsmouse multiplexor device */
		/* XXX first member of wsmux_softc is of type struct device */
		if (cdevsw[major(sc->wsmoused_dev)].d_open == wsmuxopen)
			is_wsmux = 1;

		if (is_wsmux && (minor(sc->wsmoused_dev) == WSMOUSEDEVCF_MUX)) {
			/* /dev/wsmouse case */
			/* XXX at least, wsmouse0 exist */
			wsms_dev = wsms_dev_list[0];
		}
#endif /* NWSMUX > 0 */

		/* obtain major of /dev/wsmouse{0..n} devices */
		if (wsmouse_cd.cd_ndevs > 0) {
			if (cdevsw[major(sc->wsmoused_dev)].d_open ==
			     wsmouseopen)
				is_wsmouse = 1;
		}

		if (is_wsmouse && (minor(sc->wsmoused_dev) <= NWSMOUSE)) {
			/* /dev/wsmouseX case */
			if (minor(sc->wsmoused_dev) <= wsmouse_cd.cd_ndevs) {
				wsms_dev =
				    wsms_dev_list[minor(sc->wsmoused_dev)];
			}
			else
				/* no corresponding /dev/wsmouseX device */
				return;
		}

		/* inject event to notify wsmoused(8) to close mouse device */
		if (wsms_dev != NULL) 
			wsmouse_input(wsms_dev, 0, 0, 0, 0,
				      WSMOUSE_INPUT_WSMOUSED_CLOSE);
		
	}
#endif /* NWSMOUSE > 0 */
}

/* Wakeup wsmoused(8), so that the mouse device can be reopened */
void
wsmoused_wakeup(struct wsdisplay_softc *sc)
{
#if NWSMOUSE > 0
	if (sc->wsmoused_dev) {
		sc->wsmoused_sleep = 0;
		wakeup(&sc->wsmoused_sleep);
	}
#endif /* NWSMOUSE > 0 */
@


1.26.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d318 1
d342 1
d1328 1
a1328 1
wsdisplaypoll(dev, events, p)
d1342 1
a1342 1
		return (ttpoll(dev, events, p));
@


1.26.2.10
log
@Merge with the trunk
@
text
@d1154 3
a1156 4
		if (d->flags & ~(WSDISPLAY_BURN_VBLANK | WSDISPLAY_BURN_KBD |
		    WSDISPLAY_BURN_MOUSE | WSDISPLAY_BURN_OUTPUT))
			error = EINVAL;
		else {
a1158 6
			/* disable timeout if necessary */
			if ((sc->sc_burnflags & (WSDISPLAY_BURN_OUTPUT |
			    WSDISPLAY_BURN_KBD | WSDISPLAY_BURN_MOUSE)) == 0) {
				if (sc->sc_burnout)
					timeout_del(&sc->sc_burner);
			}
@


1.25
log
@splhigh -> spltty
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.24 2001/04/17 23:24:31 aaron Exp $ */
d131 1
a131 3
				      const char *,
				      const struct wsscreen_descr *, void *,
				      int, int, long));
d133 1
a133 2
int wsdisplay_addscreen __P((struct wsdisplay_softc *, int, const char *,
			     const char *));
d138 1
d155 7
d229 3
a231 3
static int wsdisplay_console_initted;
static struct wsdisplay_softc *wsdisplay_console_device;
static struct wsscreen_internal wsdisplay_console_conf;
d236 1
a236 1
static int wsdisplay_cons_pollmode;
d239 1
a239 1
static struct consdev wsdisplay_cons = {
d689 7
d1009 9
a1017 9
		switch (cmd) {
		    case WSKBDIO_SETMODE:
			scr->scr_rawkbd = (*(int *)data == WSKBD_RAW);
			return (wsdisplay_update_rawkbd(sc, scr));
		    case WSKBDIO_GETMODE:
			*(int *)data = (scr->scr_rawkbd ?
					WSKBD_RAW : WSKBD_TRANSLATED);
			return (0);
		}
d1020 1
a1020 1
		if (error >= 0)
d1027 1
a1027 2
				  WSDISPLAYIO_MODE_MAPPED :
				  WSDISPLAYIO_MODE_EMUL);
d1032 1
a1032 2
		if (d != WSDISPLAYIO_MODE_EMUL &&
		    d != WSDISPLAYIO_MODE_MAPPED)
d1054 1
a1054 1
					scr->scr_dconf->emulcookie, d);
d1057 46
a1102 1
				(scr->scr_dconf->wsemulcookie, WSEMUL_SYNCFONT);
d1158 1
a1158 1
		if (error || d->index < 0)
d1160 1
a1160 1
		else
d1323 1
d1341 1
d1433 1
a1433 1
};
d1897 1
d1986 38
@


1.24
log
@During a mouse motion event, inverse the new mouse position first, then the
old one, instead of the other way around. This makes the motion look much
more fluid on my laptop LCD.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.23 2001/04/17 04:30:51 aaron Exp $ */
d2886 1
a2886 1
	s = splhigh();
@


1.24.2.1
log
@MFS (from millert):
Add some missing lengths checks when passing data from userland to
kernel.  From based on NetBSD patches.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.24 2001/04/17 23:24:31 aaron Exp $ */
a1066 1
	size_t fontsz;
d1092 4
a1095 6
		fontsz = d->fontheight * d->stride * d->numchars;
		if (fontsz > WSDISPLAY_MAXFONTSZ)
			return (EINVAL);

		buf = malloc(fontsz, M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf, fontsz);
@


1.23
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.22 2001/04/16 15:00:49 jbm Exp $ */
a2127 4
		/* hide the previous cursor, if not in a selection */
		if (IS_MOUSE_VISIBLE(sc->sc_focus)
		    && (!IS_SEL_IN_PROGRESS(sc->sc_focus)))
			inverse_char(old_mouse);
d2133 4
a2136 1
			MOUSE_FLAGS |= MOUSE_VISIBLE;
@


1.22
log
@Don't remove the mouse cursor when output occurs on a virtual terminal different
from the current one.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.21 2001/04/14 13:25:09 aaron Exp $ */
d236 1
a236 1
	    wsdisplay_pollc, /* NULL, */ NODEV, CN_NORMAL
a1879 1
#if 0
a1880 1
#endif
a1887 1
#if 0
a1888 1
#endif
@


1.21
log
@KNF
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.20 2001/04/14 13:04:17 aaron Exp $ */
d1268 7
a1274 5
		if ((scr == sc->sc_focus) && (IS_SEL_EXISTS(sc->sc_focus)))
			/* hide a potential selection */
			remove_selection(sc);
		/* hide a potential mouse cursor */
		mouse_hide(sc);
@


1.20
log
@Remove non-portable sysbeep calls; deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.19 2001/04/14 04:44:01 aaron Exp $ */
d100 1
a100 1
	
d103 1
a103 1
	unsigned short cursor;		/* selection cursor position ( if 
d135 2
a136 1
int wsdisplay_addscreen __P((struct wsdisplay_softc *, int, const char *, const char *));
d186 2
a187 3
	sizeof (struct wsdisplay_softc),
	wsdisplay_emul_match,
	wsdisplay_emul_attach,
d189 1
a189 1
 
d191 2
a192 3
	sizeof (struct wsdisplay_softc),
	wsdisplay_noemul_match,
	wsdisplay_noemul_attach,
d194 1
a194 1
 
d236 1
a236 1
	wsdisplay_pollc, /*NULL,*/ NODEV, CN_NORMAL
d420 1
a420 1
	
d681 1
a681 1
	if (i > start) 
d683 1
a683 1
	
d764 1
a764 1
			return EBUSY;
d844 2
a845 2
	Paste_avail = 0;	
	
d1231 1
a1231 1
		
d1251 1
a1251 1
	tp->t_state |= TS_BUSY; 
d1253 1
a1253 1
	
d1256 4
a1259 4
	 * The output will normally be in one contiguous chunk, but when the 
	 * ring wraps, it will be in two pieces.. one at the end of the ring, 
	 * the other at the start.  For performance, rather than loop here, 
	 * we output one chunk, see if there's another one, and if so, output 
d1272 1
a1272 1
		mouse_hide(sc);	
d1332 1
a1332 1
	return 0;
d1643 1
a1643 1
	if (IS_SEL_EXISTS(sc->sc_focus)) 
d1646 1
a1646 1
	
d1648 1
a1648 1
	
d1943 1
a1943 1
/* 
d1950 2
a1951 2
/* 
 * Main function, called in wsdisplay_cfg_ioctl 
d1953 2
a1954 2
int 
wsmoused(struct wsdisplay_softc *ws_sc, u_long cmd, caddr_t data, 
d1963 1
a1963 1
			return 0;
d1967 1
a1967 1
			if (mouse_event.type == WSCONS_EVENT_MOUSE_DOWN)
d1969 2
a1970 2
						mouse_event.time.tv_sec);
			else
d1972 1
a1972 1
			return 0;
d1975 2
a1976 2
			return ctrl_event(mouse_event.type, mouse_event.value, 
					ws_sc, p);
d1982 2
a1983 2
/* 
 * Mouse motion events 
d2002 2
a2003 2
/* 
 * Button clicks events 
d2057 2
a2058 2
/* 
 * Control events 
d2064 1
a2064 1
	
d2068 1
a2068 1
			return 1;
d2070 2
a2071 2
		sc = ws_sc; 
		allocate_copybuffer(sc);	
d2079 1
a2079 1
		sc->sc_scr[i]->mouse = 
d2088 2
a2089 2
	}	
	return 0;
d2091 1
a2091 1
		
d2098 1
a2098 1
	
d2103 1
a2103 1
	   
d2107 1
a2107 1
	 */ 
d2110 1
a2110 1
	
d2113 1
a2113 1
	else
d2118 1
d2121 1
a2121 1
	else
d2126 1
d2131 2
a2132 2
		if (IS_MOUSE_VISIBLE(sc->sc_focus) 
		    && (!IS_SEL_IN_PROGRESS(sc->sc_focus))) 
d2137 1
a2137 2
		}
		else {
d2149 1
a2149 1
	
d2152 1
a2152 1
	
d2155 1
a2155 1
	
d2166 1
a2166 1
	
d2170 1
a2170 1
		return ;
d2172 1
a2172 1
	while (current_pos <= end) 
d2177 1
a2177 1
 * Return the number of contiguous blank characters between the right margin 
d2186 1
a2186 1
	unsigned short limit = current + (N_COLS - mouse_col - 1); 
d2188 1
a2188 1
		
d2198 1
a2198 2
	}
	else {
d2200 1
a2200 1
			return (res - 1);	
d2202 1
a2202 1
			return res;
d2206 2
a2207 2
/* 
 * Return the number of contiguous blank characters between the first of the 
d2217 1
a2217 1
	
d2226 3
a2228 3
	
/* 
 * Class of characters 
d2230 1
a2230 1
 * $TOG: button.c /main/76 1997/07/30 16:56:19 kaleb $ 
d2298 1
a2298 1
/* 
d2304 2
a2305 2
	unsigned short current = offset;	
	unsigned short limit = current + (N_COLS - (MOUSE % N_COLS) - 1); 
d2308 1
a2308 1
	
d2325 1
a2325 1
	short current = offset;	
d2329 1
a2329 1
	
d2339 1
a2339 1
/* 
d2342 2
a2343 3
unsigned char 
class_cmp(unsigned short first, 
	  unsigned short second)
d2347 1
a2347 1
		
d2351 1
a2351 1
	if (first_class != second_class) 
d2357 1
a2357 1
/* 
d2368 1
a2368 1
	
d2370 1
a2370 1
	
d2373 1
a2373 1
	
d2377 1
a2377 1
    
d2380 2
a2381 2
	ORIG_START = CPY_START; 
	ORIG_END = CPY_END; 
d2383 1
a2383 1
	
d2385 1
a2385 1
	if (right) 
d2387 1
a2387 1
	
d2397 1
a2397 1
 * Copy of the word under the cursor 
d2404 2
a2405 2
	
	if (IS_SEL_EXISTS(sc->sc_focus)) 
d2407 1
a2407 1
	
d2410 1
a2410 1
	
d2413 1
a2413 1
	
d2417 1
a2417 2
	}
	else {
d2421 1
a2421 1
	
d2428 1
a2428 1
	
d2434 1
a2434 1
	
d2440 1
a2440 1
/* 
d2443 1
a2443 1
void 
d2447 2
a2448 2
	
	if (IS_SEL_EXISTS(sc->sc_focus)) 
d2450 1
a2450 1
	
d2453 1
a2453 1
	
d2460 1
a2460 1
	
d2466 1
a2466 1
	
d2475 1
a2475 1
void 
d2497 1
a2497 1
	if (IS_SEL_BY_LINE(sc->sc_focus))		
d2500 2
a2501 2
				
/* 
d2510 1
a2510 1
	
d2512 5
a2516 5
			/* 
			 * First extension of selection. We handle special 
			 * cases of blank characters to eol 
			 */ 
			
d2530 1
a2530 2
			}
			else {
d2543 1
a2543 1
		}	
d2545 1
a2545 2
		if (MOUSE < ORIG_START 
				&& CPY_END >= ORIG_START) {
d2550 1
a2550 1
			CPY_END = ORIG_START - 1; 
d2553 1
a2553 2
		if (CPY_START < ORIG_START
				&& MOUSE >= ORIG_START) {
d2557 1
a2557 1
			
d2567 1
a2567 1
	
d2569 1
a2569 1
		
d2571 1
a2571 1
		if (MOUSE > CPY_END) 
d2574 1
a2574 1
		else 
d2577 1
d2579 1
a2579 2
	}
	else {
d2581 1
a2581 1
		if (MOUSE < CPY_START) 
d2584 1
a2584 1
		else 
d2587 1
d2601 1
a2601 1
	
d2603 1
a2603 1
	
d2606 1
a2606 1
		if (CURSOR != (CPY_END + 1)) 
d2611 1
a2611 2
		if (MOUSE < ORIG_START 
			&& CPY_END >= ORIG_START) {
d2617 1
a2617 2
		if (MOUSE > ORIG_END 
			&& CPY_START <= ORIG_START) {
d2623 1
a2623 1
	
d2633 1
a2633 2
		}
		else {
d2639 1
a2639 2
			}
			else {
d2641 1
a2641 2
				CPY_END = MOUSE +
					skip_char_right(MOUSE);
d2646 2
a2647 2
							old_cpy_end);
				}	
d2650 1
a2650 2
	}
	else {
d2657 1
a2657 2
		}
		else {
d2662 3
a2664 4
				inverse_region(old_cpy_start, 
					CPY_START - 1);
			}
			else {
d2666 2
a2667 3
				CPY_START = MOUSE -
					skip_char_left(MOUSE);
				if (CPY_START != old_cpy_start)
d2669 2
a2670 1
							CPY_START - 1);
d2674 1
a2674 1
	
d2676 1
a2676 1
		/* display new cursor */	
d2692 1
a2692 1
	
d2696 1
a2696 1
		if (CURSOR != (CPY_END + 1)) 
d2701 1
a2701 2
		if (MOUSE < ORIG_START 
			&& CPY_END >= ORIG_START) {
d2707 1
a2707 2
		if (MOUSE > ORIG_END 
			&& CPY_START <= ORIG_START) {
d2713 1
a2713 1
	
d2722 3
a2724 3
		if (new_row > old_row) 
			inverse_region(old_cpy_end + 1, CPY_END); 
		else if (new_row < old_row) 
d2726 1
a2726 2
	} 
	else {
d2739 1
a2739 1
		/* display new cursor */	
d2762 1
a2762 1
	
d2766 1
a2766 1
	
d2769 1
a2769 1
		else 
d2777 1
a2777 1
			ORIG_START = MOUSE + 1; 
d2780 3
a2782 4
		}
		else {
			/* lower part of the screen */		
			ORIG_START = MOUSE; 
d2790 1
a2790 1
		if (IS_SEL_BY_LINE(sc->sc_focus)) 
a2795 1

d2802 1
a2802 1
	if (IS_SEL_EXT_AFTER(sc->sc_focus)) 
d2805 1
d2811 1
a2811 1
/* 
d2822 1
a2822 1
		
d2825 1
a2825 1
	
d2828 1
a2828 1
		if (!IS_SPACE(Copybuffer[current])) 
d2840 1
a2840 1
	
d2856 1
a2856 1
				(*current++, sc->sc_focus->scr_tty);
a2860 1

d2862 2
a2863 2
 * Handle the z axis 
 * The z axis (roller or wheel) is mapped by default to scrollback
d2868 1
a2868 1
	if (z < 0)	
d2875 1
a2875 1
 * Allocate the copy buffer. The size is :
d2877 2
a2878 2
 * (+1 for '\n' at the end of lines), 
 * where cols and rows are the maximum of column and rows numbers of all screens
d2880 1
a2880 1
void 
d2888 1
a2888 1
	
d2890 1
a2890 1
	for ( i = 0 ; i < nscreens ; i++) {
d2899 1
a2899 1
	}	
d2906 1
a2906 1
}			
@


1.19
log
@Kernel support for console mouse functionality which will be controlled by
the wsmoused daemon (replacement for moused which was used with PCVT). Adds
a "getchar" method to the display drivers which returns the value of the
character currently under the cursor (e.g., so it may be inversed). From jbm@@.

Still needs a bit of cleanup and improvement, especially X cohabitation
features. The pointer moves to fast as well. These sorts of issues will be
corrected in-tree.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.18 2001/03/14 06:18:48 millert Exp $ */
a2810 3
	else  
		/* no selection yet! */
		sysbeep(1193182 /* PCVT_SYSBEEPF */ / 1500, hz / 4);
a2875 2
	else 
		sysbeep(1193182 /* PCVT_SYSBEEPF */ / 1500, hz / 4);
@


1.18
log
@Back out order change in conf.c and priority change in wscons_machdep.c
Add kludge to prevent wscons on i386 from stealing the console from
another source. wscons should really be fixed to not touch cn_tab...
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.17 2001/03/14 02:49:22 mickey Exp $ */
d60 2
d70 2
d100 28
d136 3
a138 4
static void wsdisplay_shutdownhook __P((void *));
static void wsdisplay_addscreen_print __P((struct wsdisplay_softc *, int, int));
static void wsdisplay_closescreen __P((struct wsdisplay_softc *,
				       struct wsscreen *));
d175 4
a178 6
static int wsdisplay_emul_match __P((struct device *, void *, void *));
static void wsdisplay_emul_attach __P((struct device *, struct device *,
	    void *));
static int wsdisplay_noemul_match __P((struct device *, void *, void *));
static void wsdisplay_noemul_attach __P((struct device *, struct device *,
	    void *));
d199 2
a200 2
static void wsdisplaystart __P((struct tty *));
static int wsdisplayparam __P((struct tty *, struct termios *));
d208 3
a210 3
#define	WSDISPLAYUNIT(dev)	(minor(dev) >> 8)
#define	WSDISPLAYSCREEN(dev)	(minor(dev) & 0xff)
#define ISWSDISPLAYCTL(dev)	(WSDISPLAYSCREEN(dev) == 255)
d214 1
a214 1
#define	WSSCREEN_HAS_TTY(scr)	((scr)->scr_tty != NULL)
d216 4
a219 4
static void wsdisplay_common_attach __P((struct wsdisplay_softc *sc,
	    int console, const struct wsscreen_list *,
	    const struct wsdisplay_accessops *accessops,
	    void *accesscookie));
d222 1
a222 2
int wsdisplay_update_rawkbd __P((struct wsdisplay_softc *,
				 struct wsscreen *));
d229 2
a230 2
static int wsdisplay_getc_dummy __P((dev_t));
static void wsdisplay_pollc __P((dev_t, int));
d233 1
a233 1
static void (*wsdisplay_cons_kbd_pollc) __P((dev_t, int));
d308 1
d358 1
a358 1
static void
d421 2
d426 1
a426 1
static void
d625 1
a625 1
static void
d634 1
a634 1
	int i, start=0;
d680 1
a680 1
}
d842 5
d1073 3
d1269 5
d1644 6
d1842 1
a1842 1
static int
d1850 1
a1850 1
static void
d1908 2
a1909 3
						 scr->scr_dconf->emulcookie,
						 0, NULL, NULL);
}
d1937 1
a1937 1
static void
d1943 987
@


1.17
log
@allow listing and soon deleting fonts; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.16 2001/03/05 22:16:41 millert Exp $ */
d522 1
a522 1
	if (ap->console) {
@


1.16
log
@Backs out changes to wsdisplay.c so alpha (and presumably others)
is happy again.  It also makes i386 serial console work by changing
the console priority in wscons_machdep.c from CN_INTERNAL to CN_NORMAL
and moves the com/pccom console attach routine for i386 to be the
first so it will be matched (consinit takes the first highest match).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.15 2001/03/01 20:54:33 provos Exp $ */
d110 2
a111 1
#define WSDISPLAY_MAXSCREEN 12
d125 2
d314 1
a314 1
	if (name == NULL)
d319 1
a319 1
		if (!strcmp(name, scr->name))
d678 1
a678 1
	wsemul = wsemul_pick(0); /* default */
a958 2
	char namebuf[16];
	struct wsdisplay_font fd;
d1004 1
a1004 1
#define d ((struct wsdisplay_usefontdata *)data)
d1007 1
a1007 8
		if (d->name) {
			error = copyinstr(d->name, namebuf, sizeof(namebuf), 0);
			if (error)
				return (error);
			fd.name = namebuf;
		} else
			fd.name = 0;
		fd.data = 0;
d1009 1
a1009 1
					scr->scr_dconf->emulcookie, &fd);
a1030 1
	char *type, typebuf[16], *emul, emulbuf[16];
d1039 2
a1040 17
		if (d->screentype) {
			error = copyinstr(d->screentype, typebuf,
					  sizeof(typebuf), 0);
			if (error)
				return (error);
			type = typebuf;
		} else
			type = 0;
		if (d->emul) {
			error = copyinstr(d->emul, emulbuf, sizeof(emulbuf), 0);
			if (error)
				return (error);
			emul = emulbuf;
		} else
			emul = 0;

		if ((error = wsdisplay_addscreen(sc, d->idx, type, emul)) == 0)
d1052 2
a1053 7
		if (d->name) {
			error = copyinstr(d->name, typebuf, sizeof(typebuf), 0);
			if (error)
				return (error);
			d->name = typebuf;
		} else
			d->name = "loaded"; /* ??? */
d1065 14
a1078 1
		free(buf, M_DEVBUF);
a1079 1
		return (error);
@


1.15
log
@port kqueue changes from freebsd, plus all required openbsd glue.
okay deraadt@@, millert@@
from jlemon@@freebsd.org:
extend kqueue down to the device layer, backwards compatible approach
suggested by peter@@freebsd.org
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.14 2001/02/25 23:24:19 aaron Exp $ */
d527 1
a527 4
		if (maj == major(cn_tab->cn_dev)) {
			cn_tab->cn_dev = makedev(maj,
			    WSDISPLAYMINOR(self->dv_unit, 0));
		}
d680 2
@


1.14
log
@Add wscons_machdep.c which is a constab-style wrapper driver for wscons on
i386. This fixes serial console. millert@@, mickey@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.13 2001/02/11 16:43:04 fgsch Exp $ */
d1180 19
@


1.13
log
@Change MAXSCREEN to 12 so ttyC8-b can be used. Previous behavior
only allowed 8 ttys as maximun, despite the WSDISPLAY_DEFAULTSCREENS
value. ttyCa-b can't be accessed now but a fix is on the way; aaron@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.12 2001/02/10 19:42:06 mickey Exp $ */
d527 4
a530 1
		cn_tab->cn_dev = makedev(maj, WSDISPLAYMINOR(self->dv_unit, 0));
a682 2

	cn_tab = &wsdisplay_cons;
@


1.12
log
@sync w/ netbsd; aaron@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.11 2001/02/09 18:50:50 aaron Exp $ */
d110 1
a110 1
#define WSDISPLAY_MAXSCREEN 8
@


1.11
log
@Fix an uninitialized variable.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.10 2001/02/08 02:47:11 aaron Exp $ */
a102 2
static const struct wsscreen_descr *
wsdisplay_screentype_pick __P((const struct wsscreen_list *, const char *));
d121 1
a121 1
	int sc_focusidx;
d301 1
a301 1
static const struct wsscreen_descr *
d936 11
d995 4
d1187 1
a1187 1
	int s, n;
d1190 5
a1202 1
	sc = wsdisplay_cd.cd_devs[WSDISPLAYUNIT(tp->t_dev)];
d1415 1
a1415 1
		if (sc->sc_oldscreen == -1) {
d1426 1
a1426 1
		sc->sc_oldscreen = -1;
d1463 1
a1463 1
		if (sc->sc_oldscreen == -1) {
d1471 1
a1471 1
		sc->sc_oldscreen = -1;
d1511 8
d1554 2
a1555 1
	if (no < 0 || no >= WSDISPLAY_MAXSCREEN || !sc->sc_scr[no])
d1560 2
a1561 1
	if (sc->sc_focus && no == sc->sc_focusidx) {
d1578 1
a1578 1
		sc->sc_oldscreen = -1;
d1685 1
a1685 1
	if (idx >= WSDISPLAY_MAXSCREEN)
d1696 1
a1696 1
	return (sc->sc_focusidx);
d1707 9
d1801 5
d1809 5
d1847 10
a1856 3
	if (wsdisplay_console_device != NULL)
		wsdisplay_switch((struct device *)wsdisplay_console_device, 
		    0, 0);
@


1.10
log
@Cause keypresses to reset the screen in case we are in scrollback (previously
the screen was only restored if a new character was actually displayed on the
screen); jcs@@rt.fm. This brings us closer to the behavior of PCVT. Also, while
I'm here, add some #ifdef so wskbd does not depend on wsdisplay (pointed out
to me by fgsch@@).
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.9 2000/11/23 16:13:42 aaron Exp $ */
d601 1
a601 1
	static int hookset;
@


1.9
log
@Make wsdisplaystart() a bit more like PCVT's pcstart() to avoid tty races when
switching virtual terminals.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.8 2000/11/15 21:23:48 aaron Exp $ */
d1814 7
a1820 3
	lines = sc->sc_focus->scr_dconf->scrdata->nrows - 1;
	if (op == WSCONS_SCROLL_BACKWARD)
		lines = -lines;
@


1.8
log
@Make sure not to null deref the function pointer for the scrollback accessop
(some hardware drivers do not support this yet, i.e., vgafb in powerpc);
mickey@@ ok
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.7 2000/11/15 20:00:39 aaron Exp $ */
d1182 3
d1210 1
a1210 1
						  buf, n, 0);
d1217 5
a1221 5
	if (!(scr->scr_flags & SCR_GRAPHICS)) {
		KASSERT(WSSCREEN_HAS_EMULATOR(scr));
		(*scr->scr_dconf->wsemul->output)(scr->scr_dconf->wsemulcookie,
		    buf, n, 0);
	}
d1227 4
a1230 5
	/* Come back if there's more to do */
	if (tp->t_outq.c_cc) {
		tp->t_state |= TS_TIMEOUT;
		timeout_add(&tp->t_rstrt_to, (hz > 128) ? (hz / 128) : 1);
	}
d1232 1
@


1.7
log
@Support console scrollback in wscons through a new "scrollback" accessop that
hooks into the lower-level display driver. The updated vga(4) driver I'm about
to commit has support for this. This is a fairly unobtrusive way to implement
scrollback while maintaining the abstraction of the wscons system.
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.6 2000/08/01 16:44:33 mickey Exp $ */
d1815 4
a1818 2
	(*sc->sc_accessops->scrollback)(sc->sc_accesscookie,
	    sc->sc_focus->scr_dconf->emulcookie, lines);
@


1.6
log
@no cn_bell yet; bad mickey, try #2
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.5 2000/08/01 16:35:34 mickey Exp $ */
d1500 1
a1500 1
	sc->sc_flags &= ~SC_SWITCHPENDING;
d1511 2
a1512 2
	return (0);
}
d1801 16
@


1.6.2.1
log
@MFC:
Add some missing lengths checks when passing data from userland to the
kernel. From NetBSD via millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.34 2001/09/16 00:42:44 millert Exp $ */
a1025 1
	size_t fontsz;
d1068 4
a1071 6
		fontsz = d->fontheight * d->stride * d->numchars;
		if (fontsz > WSDISPLAY_MAXFONTSZ)
			return (EINVAL);

		buf = malloc(fontsz, M_DEVBUF, M_WAITOK);
		error = copyin(d->data, buf, fontsz);
@


1.5
log
@no cn_bell yet; bad mickey
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.4 2000/08/01 13:51:17 mickey Exp $ */
d208 1
a208 1
	wsdisplay_pollc, NULL, NODEV, CN_NORMAL
@


1.4
log
@update wscons, nothing serious, mostly api fixes for us; from netbsd through aaron@@
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.3 2000/07/19 13:58:17 art Exp $ */
d1776 1
d1778 1
d1786 1
d1788 1
@


1.3
log
@Use the generic t_rstrt_to for ttrstrt timeout, instead of the local solution.
@
text
@d1 2
a2 2
/* $OpenBSD: wsdisplay.c,v 1.2 2000/07/05 20:22:31 mickey Exp $ */
/* $NetBSD: wsdisplay.c,v 1.36 2000/03/23 07:01:47 thorpej Exp $ */
d143 1
a143 2
static int wsdisplay_emul_match __P((struct device *, struct cfdata *,
	    void *));
d146 1
a146 2
static int wsdisplay_noemul_match __P((struct device *, struct cfdata *,
	    void *));
d156 1
a156 1
	(cfmatch_t)wsdisplay_emul_match,
d162 1
a162 1
	(cfmatch_t)wsdisplay_noemul_match,
d208 1
a208 1
	wsdisplay_pollc, NODEV, CN_NORMAL
d487 1
a487 1
	struct cfdata *match;
d490 1
d493 1
a493 1
	if (match->wsemuldisplaydevcf_console !=
d499 1
a499 1
		if (match->wsemuldisplaydevcf_console != 0 &&
d555 1
a555 1
	struct cfdata *match;
d1148 20
d1251 2
a1252 1
	return 0;
d1776 1
a1776 1
	/* wsdisplay_cons.cn_bell = bell; XXX */
d1784 2
a1785 2
	/* wsdisplay_cons.cn_bell = NULL; XXX */
	wsdisplay_cons_kbd_pollc = NULL;
@


1.2
log
@new timeouts
@
text
@d1 1
a1 1
/* $OpenBSD: wsdisplay.c,v 1.1 2000/05/16 23:49:11 mickey Exp $ */
a81 1
	struct timeout scr_rstrt;
a272 1
	timeout_set(&scr->scr_rstrt, ttrstrt, scr->scr_tty);
d294 1
a294 1
		timeout_del(&scr->scr_rstrt);
d1208 1
a1208 1
		timeout_add(&scr->scr_rstrt, (hz > 128) ? (hz / 128) : 1);
d1690 1
a1690 1
		timeout_add(&scr->scr_rstrt, 0);	/* "immediate" */
@


1.1
log
@import newer wscons source from netbsd.
art@@ said it will make his life easier in alpha
rhands@@ said it is not used in powerpc for now
bjc@@ said that it would make vax port easier
mickey@@ said other platforms can use it, and it's faster
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d50 1
d82 1
d274 1
d296 1
d1210 1
a1210 1
		timeout(ttrstrt, tp, (hz > 128) ? (hz / 128) : 1);
d1692 1
a1692 1
		timeout(ttrstrt, scr->scr_tty, 0);	/* "immediate" */
@

