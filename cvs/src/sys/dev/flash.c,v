head	1.32;
access;
symbols
	OPENBSD_6_2:1.32.0.2
	OPENBSD_6_2_BASE:1.32
	OPENBSD_6_1:1.31.0.8
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.31.0.4
	OPENBSD_6_0_BASE:1.31
	OPENBSD_5_9:1.31.0.2
	OPENBSD_5_9_BASE:1.31
	OPENBSD_5_8:1.30.0.8
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.30.0.6
	OPENBSD_5_7_BASE:1.30
	OPENBSD_5_6:1.30.0.4
	OPENBSD_5_6_BASE:1.30
	OPENBSD_5_5:1.29.0.4
	OPENBSD_5_5_BASE:1.29
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.20.0.2
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.15.0.2
	OPENBSD_4_8_BASE:1.15
	OPENBSD_4_7:1.14.0.2
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.12.0.4
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.9.0.4
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.2.0.2
	OPENBSD_4_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2017.05.04.22.47.27;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	h72QEcy0gESNuyF9;

1.31
date	2015.08.12.22.37.32;	author krw;	state Exp;
branches;
next	1.30;
commitid	hlnL1Ya0myk6Bukt;

1.30
date	2014.05.08.21.17.00;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.11.03.03.34;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2013.10.29.21.58.38;	author krw;	state Exp;
branches;
next	1.27;

1.27
date	2013.10.20.10.11.17;	author krw;	state Exp;
branches;
next	1.26;

1.26
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.30.16.15.01;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.06.04.49.36;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2011.06.19.04.55.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2011.06.19.04.35.03;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2010.09.24.18.27.43;	author jasper;	state Exp;
branches;
next	1.19;

1.19
date	2010.09.22.06.40.25;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.15;

1.15
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.14;

1.14
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.18.19.05.16;	author kili;	state Exp;
branches;
next	1.12;

1.12
date	2009.06.17.01.30.30;	author thib;	state Exp;
branches;
next	1.11;

1.11
date	2009.06.04.23.13.21;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2009.06.03.22.09.30;	author thib;	state Exp;
branches;
next	1.9;

1.9
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2007.06.07.05.29.43;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2007.06.05.00.38.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.2;

1.2
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.1;

1.1
date	2006.11.25.14.32.00;	author uwe;	state Exp;
branches;
next	;


desc
@@


1.32
log
@Also pass the blk offset to disk_unbusy(), so that it can pass it to
the random subsystem as entropy.  This value is pretty much unknown,
and anyways our entropy input ring does not saturate from knowns.
ok mikeb djm
@
text
@/*	$OpenBSD: flash.c,v 1.31 2015/08/12 22:37:32 krw Exp $	*/

/*
 * Copyright (c) 2005 Uwe Stuehler <uwe@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/dkio.h>
#include <sys/kernel.h>
#include <sys/stat.h>
#include <sys/systm.h>

#include <dev/flashvar.h>

#include <ufs/ffs/fs.h>		/* XXX */

/* Samsung command set */
#define SAMSUNG_CMD_PTRLO	0x00
#define SAMSUNG_CMD_PTRHI	0x01
#define SAMSUNG_CMD_PTROOB	0x50
#define SAMSUNG_CMD_READ	0x30
#define SAMSUNG_CMD_SEQIN	0x80
#define SAMSUNG_CMD_WRITE	0x10
#define SAMSUNG_CMD_ERASE0	0x60
#define SAMSUNG_CMD_ERASE1	0xd0
#define SAMSUNG_CMD_STATUS	0x70
#define  STATUS_FAIL		(1<<0)
#define  STATUS_READY		(1<<6)
#define  STATUS_NWP		(1<<7)
#define SAMSUNG_CMD_READID	0x90
#define SAMSUNG_CMD_RESET	0xff

int	 flash_wait_ready(struct flash_softc *);
int	 flash_wait_complete(struct flash_softc *);

/* XXX: these should go elsewhere */
cdev_decl(flash);
bdev_decl(flash);

#define flashlookup(unit) \
	(struct flash_softc *)device_lookup(&flash_cd, (unit))

void	flashminphys(struct buf *);
void	flashstart(struct flash_softc *);
void	_flashstart(struct flash_softc *, struct buf *);
void	flashdone(void *);

int	flashsafestrategy(struct flash_softc *, struct buf *);
void	flashgetdefaultlabel(dev_t, struct flash_softc *,
    struct disklabel *);
int	flashgetdisklabel(dev_t, struct flash_softc *, struct disklabel *, int);

/*
 * Driver attachment glue
 */

struct flashvendor {
	u_int8_t	 vendor;
	const char	*name;
};

static const struct flashvendor flashvendors[] = {
	{ FLASH_VENDOR_SAMSUNG, "Samsung" }
};
#define	FLASH_NVENDORS (sizeof(flashvendors) / sizeof(flashvendors[0]))

static const struct flashdev flashdevs[] = {
	{ FLASH_DEVICE_SAMSUNG_K9F2808U0C, "K9F2808U0C 16Mx8 3.3V",
	   512, 16, 32, 32768 },
	{ FLASH_DEVICE_SAMSUNG_K9F1G08U0A, "K9F1G08U0A 128Mx8 3.3V",
	  2048, 64, 64, 65536 },
};
#define	FLASH_NDEVS (sizeof(flashdevs) / sizeof(flashdevs[0]))

struct cfdriver flash_cd = {
	NULL, "flash", DV_DISK
};

void
flashattach(struct flash_softc *sc, struct flash_ctl_tag *tag,
    void *cookie)
{
	u_int8_t vendor, device;
	u_int16_t id;
	int i;

	sc->sc_tag = tag;
	sc->sc_cookie = cookie;

	if (sc->sc_maxwaitready <= 0)
		sc->sc_maxwaitready = 1000;      /* 1ms */
	if (sc->sc_maxwaitcomplete <= 0)
		sc->sc_maxwaitcomplete = 200000; /* 200ms */

	flash_chip_enable(sc);

	/* Identify the flash device. */
	if (flash_chip_identify(sc, &vendor, &device) != 0) {
		printf(": identification failed\n");
		flash_chip_disable(sc);
		return;
	}
	id = (vendor << 8) | device;

	/* Look up device characteristics, abort if not recognized. */
	for (i = 0; i < FLASH_NVENDORS; i++) {
		if (flashvendors[i].vendor == vendor) {
			printf(": %s", flashvendors[i].name);
			break;
		}
	}
	if (i == FLASH_NVENDORS)
		printf(": vendor 0x%02x", vendor);
	for (i = 0; i < FLASH_NDEVS; i++) {
		if (flashdevs[i].id == id) {
			printf(" %s\n", flashdevs[i].longname);
			break;
		}
	}
	if (i == FLASH_NDEVS) {
		/* Need to add this device to flashdevs first. */
		printf(" device 0x%02x\n", device);
		flash_chip_disable(sc);
		return;
	}
	sc->sc_flashdev = &flashdevs[i];

	/* Check if the device really works or fail early. */
	if (flash_chip_reset(sc) != 0) {
		printf("%s: reset failed\n", sc->sc_dev.dv_xname);
		flash_chip_disable(sc);
		return;
	}

	flash_chip_disable(sc);

	/*
	 * Initialize and attach the disk structure.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	bufq_init(&sc->sc_bufq, BUFQ_FIFO);
	disk_attach(&sc->sc_dev, &sc->sc_dk);

	/* XXX establish shutdown hook to finish any commands. */
}

int
flashdetach(struct device *self, int flags)
{
	struct flash_softc *sc = (struct flash_softc *)self;

	/* Detach disk. */
	disk_detach(&sc->sc_dk);

	/* XXX more resources need to be freed here. */
	return 0;
}

/*
 * Flash controller and chip functions
 */

u_int8_t
flash_reg8_read(struct flash_softc *sc, int reg)
{
	return sc->sc_tag->reg8_read(sc->sc_cookie, reg);
}

void
flash_reg8_read_page(struct flash_softc *sc, caddr_t data, caddr_t oob)
{
	int i;

	for (i = 0; i < sc->sc_flashdev->pagesize; i++)
		data[i] = flash_reg8_read(sc, FLASH_REG_DATA);

	if (oob != NULL)
		for (i = 0; i < sc->sc_flashdev->oobsize; i++)
			oob[i] = flash_reg8_read(sc, FLASH_REG_DATA);
}

void
flash_reg8_write(struct flash_softc *sc, int reg, u_int8_t value)
{
	sc->sc_tag->reg8_write(sc->sc_cookie, reg, value);
}

void
flash_reg8_write_page(struct flash_softc *sc, caddr_t data, caddr_t oob)
{
	int i;

	for (i = 0; i < sc->sc_flashdev->pagesize; i++)
		flash_reg8_write(sc, FLASH_REG_DATA, data[i]);

	if (oob != NULL)
		for (i = 0; i < sc->sc_flashdev->oobsize; i++)
			flash_reg8_write(sc, FLASH_REG_DATA, oob[i]);
}

/*
 * Wait for the "Ready/Busy" signal to go high, indicating that the
 * device is ready to accept another command.
 */
int
flash_wait_ready(struct flash_softc *sc)
{
	int timo = sc->sc_maxwaitready;
	u_int8_t ready;

	ready = flash_reg8_read(sc, FLASH_REG_READY);
	while (ready == 0 && timo-- > 0) {
		delay(1);
		ready = flash_reg8_read(sc, FLASH_REG_READY);
	}
	return (ready == 0 ? EIO : 0);
}

/*
 * Similar to flash_wait_ready() but looks at IO 6 and IO 0 signals
 * besides R/B to decide whether the last operation was successful.
 */
int
flash_wait_complete(struct flash_softc *sc)
{
	int timo = sc->sc_maxwaitcomplete;
	u_int8_t status;

	(void)flash_wait_ready(sc);

	flash_reg8_write(sc, FLASH_REG_CLE, 1);
	flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_STATUS);
	flash_reg8_write(sc, FLASH_REG_CLE, 0);

	status = flash_reg8_read(sc, FLASH_REG_DATA);
	while ((status & STATUS_READY) == 0 && timo-- > 0) {
		if (flash_reg8_read(sc, FLASH_REG_READY))
			break;
		delay(1);
		status = flash_reg8_read(sc, FLASH_REG_DATA);
	}

	status = flash_reg8_read(sc, FLASH_REG_DATA);
	return ((status & STATUS_FAIL) != 0 ? EIO : 0);
}

void
flash_chip_enable(struct flash_softc *sc)
{
	/* XXX aquire the lock. */
	flash_reg8_write(sc, FLASH_REG_CE, 1);
}

void
flash_chip_disable(struct flash_softc *sc)
{
	flash_reg8_write(sc, FLASH_REG_CE, 0);
	/* XXX release the lock. */
}

int
flash_chip_reset(struct flash_softc *sc)
{
	flash_reg8_write(sc, FLASH_REG_CLE, 1);
	flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_RESET);
	flash_reg8_write(sc, FLASH_REG_CLE, 0);

	return flash_wait_ready(sc);
}

int
flash_chip_identify(struct flash_softc *sc, u_int8_t *vendor,
    u_int8_t *device)
{
	int error;

	(void)flash_wait_ready(sc);

	flash_reg8_write(sc, FLASH_REG_CLE, 1);
	flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_READID);
	flash_reg8_write(sc, FLASH_REG_CLE, 0);

	error = flash_wait_ready(sc);
	if (error == 0) {
		*vendor = flash_reg8_read(sc, FLASH_REG_DATA);
		*device = flash_reg8_read(sc, FLASH_REG_DATA);
	}
	return error;
}

int
flash_chip_erase_block(struct flash_softc *sc, long blkno)
{
	long pageno = blkno * sc->sc_flashdev->blkpages;
	int error;

	(void)flash_wait_ready(sc);

	/* Disable write-protection. */
	flash_reg8_write(sc, FLASH_REG_WP, 0);

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_ERASE0);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno >> 8);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_ERASE1);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	error = flash_wait_complete(sc);

	/* Re-enable write-protection. */
	flash_reg8_write(sc, FLASH_REG_WP, 1);

	return error;
}

int
flash_chip_read_block(struct flash_softc *sc, long blkno, caddr_t data)
{
	long pageno;
	long blkend;
	int error;

	pageno = blkno * sc->sc_flashdev->blkpages;
	blkend = pageno + sc->sc_flashdev->blkpages;

	while (pageno < blkend) {
		error = flash_chip_read_page(sc, pageno, data, NULL);
		if (error != 0)
			return error;
		data += sc->sc_flashdev->pagesize;
		pageno++;
	}
	return 0;
}

int
flash_chip_read_page(struct flash_softc *sc, long pageno, caddr_t data,
    caddr_t oob)
{
	int error;

	(void)flash_wait_ready(sc);

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_PTRLO);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno >> 8);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_READ);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	if ((error = flash_wait_ready(sc)) != 0)
		return error;

	/* Support hardware ECC calculation. */
	if (sc->sc_tag->regx_read_page) {
		error = sc->sc_tag->regx_read_page(sc->sc_cookie, data,
		    oob);
		if (error != 0)
			return error;
	} else
		flash_reg8_read_page(sc, data, oob);

	return 0;
}

int
flash_chip_read_oob(struct flash_softc *sc, long pageno, caddr_t oob)
{
	u_int8_t *p = (u_int8_t *)oob;
	int error;
	int i;

	(void)flash_wait_ready(sc);

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_PTROOB);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_PTRLO);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_COL, 0x08);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno >> 8);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_READ);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	if ((error = flash_wait_ready(sc)) != 0)
		return error;

	for (i = 0; i < sc->sc_flashdev->oobsize; i++)
		p[i] = flash_reg8_read(sc, FLASH_REG_DATA);

	return 0;
}

int
flash_chip_write_block(struct flash_softc *sc, long blkno, caddr_t data,
    caddr_t oob)
{
	long pageno;
	long blkend;
	caddr_t p;
	int error;

	pageno = blkno * sc->sc_flashdev->blkpages;
	blkend = pageno + sc->sc_flashdev->blkpages;

	p = data;
	while (pageno < blkend) {
		error = flash_chip_write_page(sc, pageno, p, oob);
		if (error != 0)
			return error;
		p += sc->sc_flashdev->pagesize;
		pageno++;
	}

	/* Verify the newly written block. */
	return flash_chip_verify_block(sc, blkno, data, oob);
}

int
flash_chip_write_page(struct flash_softc *sc, long pageno, caddr_t data,
    caddr_t oob)
{
	int error;

	(void)flash_wait_ready(sc);

	/* Disable write-protection. */
	flash_reg8_write(sc, FLASH_REG_WP, 0);

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_PTRLO);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_SEQIN);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_COL, 0x00);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_ALE, 1);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno);
		flash_reg8_write(sc, FLASH_REG_ROW, pageno >> 8);
		flash_reg8_write(sc, FLASH_REG_ALE, 0);
		break;
	}

	/* Support hardware ECC calculation. */
	if (sc->sc_tag->regx_write_page) {
		error = sc->sc_tag->regx_write_page(sc->sc_cookie, data,
		    oob);
		if (error != 0)
			return error;
	} else
		flash_reg8_write_page(sc, data, oob);

	switch (sc->sc_flashdev->id) {
	case FLASH_DEVICE_SAMSUNG_K9F2808U0C:
	case FLASH_DEVICE_SAMSUNG_K9F1G08U0A:
		flash_reg8_write(sc, FLASH_REG_CLE, 1);
		flash_reg8_write(sc, FLASH_REG_CMD, SAMSUNG_CMD_WRITE);
		flash_reg8_write(sc, FLASH_REG_CLE, 0);
		break;
	}

	/*
	 * Wait for the write operation to complete although this can
	 * take up to 700 us for the K9F1G08U0A flash type.
	 */
	error = flash_wait_complete(sc);

	/* Re-enable write-protection. */
	flash_reg8_write(sc, FLASH_REG_WP, 1);

	return error;
}

int
flash_chip_verify_block(struct flash_softc *sc, long blkno, caddr_t data,
    caddr_t oob)
{
	long pageno;
	long blkend;
	int error;

	pageno = blkno * sc->sc_flashdev->blkpages;
	blkend = pageno + sc->sc_flashdev->blkpages;

	while (pageno < blkend) {
		error = flash_chip_verify_page(sc, pageno, data, oob);
		if (error != 0) {
			printf("block %ld page %ld verify failed\n",
			    blkno, pageno);
			return error;
		}
		data += sc->sc_flashdev->pagesize;
		pageno++;
	}
	return 0;
}

int
flash_chip_verify_page(struct flash_softc *sc, long pageno, caddr_t data,
    caddr_t oob)
{
	static u_char rbuf[FLASH_MAXPAGESIZE];
	static u_char roob[FLASH_MAXOOBSIZE];
	int error;

	error = flash_chip_read_page(sc, pageno, rbuf,
	    oob == NULL ? NULL : roob);
	if (error != 0)
		return error;

	if (memcmp((const void *)&rbuf[0], (const void *)data,
	    sc->sc_flashdev->pagesize) != 0)
		return EIO;

	if (oob != NULL && memcmp((const void *)&roob[0],
	    (const void *)oob, sc->sc_flashdev->oobsize) != 0)
		return EIO;

	return 0;
}

/*
 * Block device functions
 */

int
flashopen(dev_t dev, int oflags, int devtype, struct proc *p)
{
	struct flash_softc *sc;
	int error;
	int part;

	sc = flashlookup(flashunit(dev));
	if (sc == NULL)
		return ENXIO;

	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return error;
	}

	/*
	 * If no partition is open load the partition info if it is
	 * not already valid.  If partitions are already open, allow
	 * opens only for the same kind of device.
	 */
	if (sc->sc_dk.dk_openmask == 0) {
		if ((sc->sc_flags & FDK_LOADED) == 0 ||
		    ((sc->sc_flags & FDK_SAFE) == 0) !=
		    (flashsafe(dev) == 0)) {
			sc->sc_flags &= ~FDK_SAFE;
			sc->sc_flags |= FDK_LOADED;
			if (flashsafe(dev))
				sc->sc_flags |= FDK_SAFE;
			if ((error = flashgetdisklabel(dev, sc, 
			    sc->sc_dk.dk_label, 0)) != 0) {
				disk_unlock(&sc->sc_dk);
				device_unref(&sc->sc_dev);
				return error;
			}
		}
	} else if (((sc->sc_flags & FDK_SAFE) == 0) !=
	    (flashsafe(dev) == 0)) {
		disk_unlock(&sc->sc_dk);
		device_unref(&sc->sc_dev);
		return EBUSY;
	}

	/* Check that the partition exists. */
	part = flashpart(dev);
	if (part != RAW_PART &&
	    (part >= sc->sc_dk.dk_label->d_npartitions ||
	    sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		disk_unlock(&sc->sc_dk);
		device_unref(&sc->sc_dev);
		return ENXIO;
	}

	/* Prevent our unit from being deconfigured while open. */
	switch (devtype) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_dk.dk_openmask =
	    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;

	disk_unlock(&sc->sc_dk);
	device_unref(&sc->sc_dev);
	return 0;
}

int
flashclose(dev_t dev, int fflag, int devtype, struct proc *p)
{
	struct flash_softc *sc;
	int part;

	sc = flashlookup(flashunit(dev));
	if (sc == NULL)
		return ENXIO;

	disk_lock_nointr(&sc->sc_dk);

	/* Close one open partition. */
	part = flashpart(dev);
	switch (devtype) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask =
	    sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;

	if (sc->sc_dk.dk_openmask == 0) {
		/* XXX wait for I/O to complete? */
	}

	disk_unlock(&sc->sc_dk);
	device_unref(&sc->sc_dev);
	return 0;
}

/*
 * Queue the transfer of one or more flash pages.
 */
void
flashstrategy(struct buf *bp)
{
	struct flash_softc *sc;
	int s;

	sc = flashlookup(flashunit(bp->b_dev));
	if (sc == NULL) {
		bp->b_error = ENXIO;
		goto bad;
	}

	/* If the device has been invalidated, error out. */
	if ((sc->sc_flags & FDK_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}

	/* Translate logical block numbers to physical. */
	if (flashsafe(bp->b_dev) && flashsafestrategy(sc, bp) <= 0) {
		if (bp->b_flags & B_ERROR)
			bp->b_resid = bp->b_bcount;
		goto done;
	}

	/* Validate the request. */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) == -1)
		goto done;

	/* Queue the transfer. */
	bufq_queue(&sc->sc_bufq, bp);

	s = splbio();
	flashstart(sc);
	splx(s);

	device_unref(&sc->sc_dev);
	return;

 bad:
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount;
 done:
	s = splbio();
	biodone(bp);
	splx(s);
	if (sc != NULL)
		device_unref(&sc->sc_dev);
}

int
flashioctl(dev_t dev, u_long cmd, caddr_t data, int fflag, struct proc *p)
{
	struct flash_softc *sc;
	int error = 0;

	sc = flashlookup(flashunit(dev));
	if (sc == NULL)
		return ENXIO;

	if ((sc->sc_flags & FDK_LOADED) == 0) {
		device_unref(&sc->sc_dev);
		return EIO;
	}

	switch (cmd) {
	case DIOCGPDINFO:
		flashgetdisklabel(dev, sc, (struct disklabel *)data, 1);
		break;

	case DIOCGDINFO:
		*(struct disklabel *)data = *sc->sc_dk.dk_label;
		break;

	default:
		error = ENOTTY;
		break;
	}

	device_unref(&sc->sc_dev);
	return error;
}

int
flashdump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	printf("flashdump\n");
	return ENODEV;
}

daddr_t
flashsize(dev_t dev)
{
	printf("flashsize\n");
	return ENODEV;
}

void
flashstart(struct flash_softc *sc)
{
	struct buf *bp;

	while ((bp = bufq_dequeue(&sc->sc_bufq)) != NULL) {
		/* Transfer this buffer now. */
		_flashstart(sc, bp);
	}
}

void
_flashstart(struct flash_softc *sc, struct buf *bp)
{
	struct disklabel *lp;
	int part;
	daddr_t offset;
	long pgno;

	part = flashpart(bp->b_dev);

	lp = sc->sc_dk.dk_label;
	offset = DL_SECTOBLK(lp, DL_GETPOFFSET(&lp->d_partitions[part])) +
	    bp->b_blkno;
	pgno = offset / (sc->sc_flashdev->pagesize / DEV_BSIZE);

	/*
	 * If the requested page is exactly at the end of flash and it
	 * is an "unsafe" device, return EOF, else error out.
	 */
	if (!flashsafe(bp->b_dev) && pgno == sc->sc_flashdev->capacity) {
		bp->b_resid = bp->b_bcount;
		biodone(bp);
		return;
	} else if (pgno >= sc->sc_flashdev->capacity) {
		bp->b_error = EINVAL;
		bp->b_flags |= B_ERROR;
		biodone(bp);
		return;
	}

	sc->sc_bp = bp;

	/* Instrumentation. */
	disk_busy(&sc->sc_dk);

	/* XXX this should be done asynchronously. */
	flash_chip_enable(sc);
	if ((bp->b_flags & B_READ) != 0)
		bp->b_error = flash_chip_read_page(sc, pgno, bp->b_data,
		    NULL);
	else
		bp->b_error = flash_chip_write_page(sc, pgno, bp->b_data,
		    NULL);
	if (bp->b_error == 0)
		bp->b_resid = bp->b_bcount - sc->sc_flashdev->pagesize;
	flash_chip_disable(sc);
	flashdone(sc);
}

void
flashdone(void *v)
{
	struct flash_softc *sc = v;
	struct buf *bp = sc->sc_bp;

	/* Instrumentation. */
	disk_unbusy(&sc->sc_dk, bp->b_bcount - bp->b_resid,
	    bp->b_blkno, (bp->b_flags & B_READ) != 0);

	if (bp->b_error != 0)
		bp->b_flags |= B_ERROR;

	biodone(bp);
	flashstart(sc);
}

void
flashgetdefaultlabel(dev_t dev, struct flash_softc *sc,
    struct disklabel *lp)
{
	size_t len;

	bzero(lp, sizeof(struct disklabel));

	lp->d_type = 0;
	strncpy(lp->d_typename, "NAND flash", sizeof(lp->d_typename));

	/* Use the product name up to the first space. */
	strncpy(lp->d_packname, sc->sc_flashdev->longname,
	    sizeof(lp->d_packname));
	for (len = 0; len < sizeof(lp->d_packname); len++)
		if (lp->d_packname[len] == ' ') {
			lp->d_packname[len] = '\0';
			break;
		}

	/* Fake the disk geometry. */
	lp->d_ncylinders = 1;
	lp->d_ntracks = 16;
	lp->d_secsize = sc->sc_flashdev->pagesize;
	lp->d_nsectors = sc->sc_flashdev->capacity / lp->d_ntracks
	    / lp->d_ncylinders;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	DL_SETDSIZE(lp, (u_int64_t)lp->d_ncylinders * lp->d_secpercyl);

	lp->d_version = 1;

	/* XXX these values assume ffs. */
	lp->d_bbsize = BBSIZE;
	lp->d_sbsize = SBSIZE;

	/* Wrap it up. */
	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);
}

int
flashgetdisklabel(dev_t dev, struct flash_softc *sc,
    struct disklabel *lp, int spoofonly)
{
	dev_t labeldev;

	flashgetdefaultlabel(dev, sc, lp);

	if (sc->sc_tag->default_disklabel != NULL)
		sc->sc_tag->default_disklabel(sc->sc_cookie, dev, lp);

	/* Call the generic disklabel extraction routine. */
	labeldev = flashlabeldev(dev);
	return readdisklabel(labeldev, flashstrategy, lp, spoofonly);
}

/*
 * Character device functions
 */

void
flashminphys(struct buf *bp)
{
	struct flash_softc *sc;

	sc = flashlookup(flashunit(bp->b_dev));

	if (bp->b_bcount > sc->sc_flashdev->pagesize)
		bp->b_bcount = sc->sc_flashdev->pagesize;
}

int
flashread(dev_t dev, struct uio *uio, int ioflag)
{
	return physio(flashstrategy, dev, B_READ, flashminphys, uio);
}

int
flashwrite(dev_t dev, struct uio *uio, int ioflag)
{
	return physio(flashstrategy, dev, B_WRITE, flashminphys, uio);
}

/*
 * Physical access strategy "fixup" routines for transparent bad
 * blocks management, wear-leveling, etc.
 */

/*
 * Call the machine-specific routine if there is any or use just a
 * default strategy for bad blocks management.
 */
int
flashsafestrategy(struct flash_softc *sc, struct buf *bp)
{
	if (sc->sc_tag->safe_strategy) {
		return sc->sc_tag->safe_strategy(sc->sc_cookie, bp);
	}

	/* XXX no default bad blocks management strategy yet */
	return 1;
}

void dumppage(u_char *);
void dumppage(u_char *buf)
{
	int i;
	for (i = 0; i < 512; i++) {
		if ((i % 16) == 0)
			printf("%04x: ", i);
		if ((i % 16) == 8)
			printf(" ");
		printf(" %02x", buf[i]);
		if ((i % 16) == 15)
			printf("\n");
	}
	if ((i % 16) != 0)
		printf("\n");
}
@


1.31
log
@Remove last two 'uses' of d_subtype in tree. No point in setting
it to 0 immediately after a bzero() of the entire label. Nor in
swapping endianness since nobody looks at it. Don't touch the actual
field in disklabel. Yet.

ok deraadt@@ as part of larger diff that needs splitting up.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.30 2014/05/08 21:17:00 miod Exp $	*/
d934 1
a934 1
	    (bp->b_flags & B_READ) != 0);
@


1.30
log
@Format string fixes and removal of -Wno-format for arm kernels.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.29 2013/11/11 03:03:34 dlg Exp $	*/
a951 1
	lp->d_subtype = 0;
@


1.29
log
@replace disksort with bufqs.

i havent had any tests, so if there's any fallout ill deal with it when
people hit it. i wont feel guilty about it at all though.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.28 2013/10/29 21:58:38 krw Exp $	*/
d624 1
a624 1
			printf("block %d page %d verify failed\n",
@


1.28
log
@Don't add sectors to blocks. Use DL_SECTOBLK() to change DL_GETPOFFSET()
sector value to 512-byte-blocks before adding to b_blkno.

gcc tested on zaurus by matthieu@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.27 2013/10/20 10:11:17 krw Exp $	*/
d158 1
d799 2
a801 1
	disksort(&sc->sc_q, bp);
d804 1
d869 1
a869 9
	struct buf *dp, *bp;

	while (1) {
		/* Remove the next buffer from the queue or stop. */
		dp = &sc->sc_q;
		bp = dp->b_actf;
		if (bp == NULL)
			return;
		dp->b_actf = bp->b_actf;
d871 1
@


1.27
log
@(daddr_t) -> (u_int64_t) when multiplying ncylinders * secpercyl to
get disk size, since DL_SETDSIZE() takes disk sector values, not
512-byte block values.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.26 2013/06/11 16:42:13 deraadt Exp $	*/
d884 1
d890 3
a892 1
	offset = DL_GETPOFFSET(&sc->sc_dk.dk_label->d_partitions[part]) +
@


1.26
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.25 2013/05/30 16:15:01 deraadt Exp $	*/
d972 1
a972 1
	DL_SETDSIZE(lp, (daddr_t)lp->d_ncylinders * lp->d_secpercyl);
@


1.25
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.24 2011/07/06 04:49:36 matthew Exp $	*/
d850 1
a850 1
flashdump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
d856 1
a856 1
daddr64_t
d885 1
a885 1
	daddr64_t offset;
d972 1
a972 1
	DL_SETDSIZE(lp, (daddr64_t)lp->d_ncylinders * lp->d_secpercyl);
@


1.24
log
@Eliminate redundant buf validation checks in xxstrategy() methods now
that they're implemented consistently in bounds_check_with_label().

Also, per krw's request, change bounds_check_with_label() to return 0
if the checks succeed, and change the drivers to test == -1 instead of
<= 0.  (Man page update to follow; intentionally omitting
arch/vax/mba/hp.c from this commit because it doesn't even build
currently and miod@@ promises to kill it soon.)

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.23 2011/06/19 04:55:33 deraadt Exp $	*/
a171 7
	return 0;
}

int
flashactivate(struct device *self, int act)
{
	/* XXX anything to be done here? */
@


1.23
log
@Use disk_lock_nointr() in the xxclose() routines so that they cannot
be interrupted.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.22 2011/06/19 04:35:03 deraadt Exp $	*/
a786 6
	/* Transfer only a multiple of the flash page size. */
	if ((bp->b_bcount % sc->sc_flashdev->pagesize) != 0) {
		bp->b_error = EINVAL;
		goto bad;
	}

d794 3
a796 5
	if (flashsafe(bp->b_dev) && flashsafestrategy(sc, bp) <= 0)
		goto done;

	/* Return immediately if it is a null transfer. */
	if (bp->b_bcount == 0)
d798 1
d800 2
a801 2
	/* Do bounds checking on partitions. */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
d812 1
a812 1
bad:
d814 2
a815 3
done:
	if ((bp->b_flags & B_ERROR) != 0)
		bp->b_resid = bp->b_bcount;
@


1.22
log
@Use disk_lock/disk_unlock directly and in the same way in these drivers,
rather than using various wrappings.  Convert vnd to using the sc_dk
rwlock instead of using one of its own.
ok matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.21 2011/06/03 21:14:11 matthew Exp $	*/
a741 1
	int error;
d748 1
a748 4
	if ((error = disk_lock(&sc->sc_dk)) != 0) {
		device_unref(&sc->sc_dev);
		return error;
	}
@


1.21
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.20 2010/09/24 18:27:43 jasper Exp $	*/
a56 2
#define flashlock(sc) disk_lock(&(sc)->sc_dk)
#define flashunlock(sc) disk_unlock(&(sc)->sc_dk)
d679 1
a679 1
	if ((error = flashlock(sc)) != 0) {
d699 1
a699 1
				flashunlock(sc);
d706 1
a706 1
		flashunlock(sc);
d716 1
a716 1
		flashunlock(sc);
d733 1
a733 1
	flashunlock(sc);
d749 1
a749 1
	if ((error = flashlock(sc)) != 0) {
d771 1
a771 1
	flashunlock(sc);
@


1.20
log
@- missing semicolon from r@@undefined.ch
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.19 2010/09/22 06:40:25 krw Exp $	*/
d814 1
a814 1
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label, 0) <= 0)
@


1.19
log
@Add DIOCGPDINFO to drivers that were lacking it. Where there
is no easily available physical information outside of the stored
disklabel just make it a synonym for DIOCGDINFO.

Commit on the theory it is unlikely to harm, and fallout can be
addressed in the mass re-compile that will follow j2k10.

Should allow auto-allocation of disks to work with all devices.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.18 2010/09/22 01:18:57 matthew Exp $	*/
d855 1
a855 1
		break
@


1.18
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.17 2010/09/08 14:47:12 jsing Exp $	*/
d853 4
d860 1
@


1.17
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.15 2010/04/23 15:25:21 jsing Exp $	*/
d1036 1
a1036 1
	return physio(flashstrategy, NULL, dev, B_READ, flashminphys, uio);
d1042 1
a1042 1
	return physio(flashstrategy, NULL, dev, B_WRITE, flashminphys, uio);
@


1.16
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d160 1
a160 1
	disk_attach(&sc->sc_dk);
@


1.15
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.13 2009/08/18 19:05:16 kili Exp $	*/
a97 2
struct dkdriver flashdkdriver = { flashstrategy };

a158 1
	sc->sc_dk.dk_driver = &flashdkdriver;
@


1.14
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@a992 3
	/* Fake hardware characteristics. */
	lp->d_rpm = 3600;
	lp->d_interleave = 1;
@


1.13
log
@Fix after readdisklabel() change.

Looks fine to miod@@, who also reminded me to not forget to call
flashunlock(sc).
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.12 2009/06/17 01:30:30 thib Exp $	*/
d181 1
a181 1
flashactivate(struct device *self, enum devact act)
@


1.12
log
@Revert bufq's. this is inline with the major midlayer reverts that
have been going on. this appears to bring us back to stable state.

lots of testing by oga and ariane and my self.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.11 2009/06/04 23:13:21 deraadt Exp $	*/
d70 1
a70 1
void	flashgetdisklabel(dev_t, struct flash_softc *, struct disklabel *, int);
d702 6
a707 1
			flashgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
d1008 1
a1008 1
void
a1011 1
	char *errstring;
d1021 1
a1021 4
	errstring = readdisklabel(labeldev, flashstrategy, lp, spoofonly);
	if (errstring != NULL) {
		/*printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);*/
	}
@


1.11
log
@remove variable left behind by thib
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.10 2009/06/03 22:09:30 thib Exp $	*/
d817 1
a817 1
	BUFQ_ADD(sc->sc_dk.dk_bufq, bp);
d880 1
a880 1
	struct buf *bp;
d884 2
a885 1
		bp = BUFQ_GET(sc->sc_dk.dk_bufq);
d888 1
@


1.10
log
@add a flexible buffer queue (bufq) api, based on the never used
one by tedu@@. It doesn't do anything smart yet, it just uses
plain old disksort. we also keep the old method of queueing bufs
since some miods have crazy MD drivers that need some love.

ok beck@@, art@@
tested by many on many archs.
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.8 2007/06/20 18:15:46 deraadt Exp $	*/
d880 1
a880 1
	struct buf *dp, *bp;
@


1.9
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d817 1
a817 1
	disksort(&sc->sc_q, bp);
d884 1
a884 2
		dp = &sc->sc_q;
		bp = dp->b_actf;
a886 1
		dp->b_actf = bp->b_actf;
@


1.8
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.7 2007/06/08 05:27:58 deraadt Exp $	*/
d812 1
a812 2
	if (flashpart(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, sc->sc_dk.dk_label, 0) <= 0)
@


1.7
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.6 2007/06/07 05:29:43 deraadt Exp $	*/
d70 1
a70 2
void	flashgetdisklabel(dev_t, struct flash_softc *, struct disklabel *,
    struct cpu_disklabel *, int);
d702 1
a702 2
			flashgetdisklabel(dev, sc, sc->sc_dk.dk_label,
			    sc->sc_dk.dk_cpulabel, 0);
d813 1
a813 2
	    bounds_check_with_label(bp, sc->sc_dk.dk_label,
	    sc->sc_dk.dk_cpulabel, 0) <= 0)
d1006 1
a1006 1
    struct disklabel *lp, struct cpu_disklabel *clp, int spoofonly)
a1011 1
	bzero(clp, sizeof(struct cpu_disklabel));
d1014 1
a1014 1
		sc->sc_tag->default_disklabel(sc->sc_cookie, dev, lp, clp);
d1018 1
a1018 2
	errstring = readdisklabel(labeldev, flashstrategy, lp, clp,
	    spoofonly);
@


1.6
log
@in OpenBSD as all old BSD unix, RAW_PART always starts at 0, so no
need for special case code; ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.5 2007/06/06 17:15:13 deraadt Exp $	*/
d995 1
@


1.5
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.4 2007/06/05 00:38:20 deraadt Exp $	*/
d907 2
a908 6
	if (part != RAW_PART)
		offset = DL_GETPOFFSET(&sc->sc_dk.dk_label->d_partitions[part]);
	else
		offset = 0;

	offset = offset + bp->b_blkno;
@


1.4
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.3 2007/06/01 00:07:48 krw Exp $	*/
d868 1
a868 1
flashdump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
d874 1
a874 1
int
d903 1
a903 1
	long offset;
@


1.3
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.2 2007/02/15 00:53:26 krw Exp $	*/
d908 1
a908 1
		offset = sc->sc_dk.dk_label->d_partitions[part].p_offset;
d994 1
a994 1
	lp->d_secperunit = lp->d_ncylinders * lp->d_secpercyl;
@


1.2
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: flash.c,v 1.1 2006/11/25 14:32:00 uwe Exp $	*/
a1002 6

	/* Fake the partition information. */
	lp->d_npartitions = RAW_PART + 1;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
@


1.1
log
@Initial NAND flash support for Zaurus, not enabled yet; prodded by many.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1033 3
a1035 2
	if (errstring != NULL)
		printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);
@

