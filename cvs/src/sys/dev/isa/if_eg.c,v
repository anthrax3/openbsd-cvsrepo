head	1.49;
access;
symbols
	OPENBSD_6_1:1.47.0.4
	OPENBSD_6_1_BASE:1.47
	OPENBSD_6_0:1.46.0.2
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.45.0.2
	OPENBSD_5_9_BASE:1.45
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.36.0.4
	OPENBSD_5_7_BASE:1.36
	OPENBSD_5_6:1.34.0.6
	OPENBSD_5_6_BASE:1.34
	OPENBSD_5_5:1.34.0.4
	OPENBSD_5_5_BASE:1.34
	OPENBSD_5_4:1.32.0.18
	OPENBSD_5_4_BASE:1.32
	OPENBSD_5_3:1.32.0.16
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.14
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.12
	OPENBSD_5_0:1.32.0.10
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.32.0.8
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.32.0.6
	OPENBSD_4_8_BASE:1.32
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.32.0.4
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.31.0.2
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.30.0.8
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.30.0.6
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.4
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.6
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.26.0.4
	OPENBSD_3_7_BASE:1.26
	OPENBSD_3_6:1.26.0.2
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.25.0.4
	OPENBSD_3_5_BASE:1.25
	OPENBSD_3_4:1.25.0.2
	OPENBSD_3_4_BASE:1.25
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.4
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.23.0.2
	OPENBSD_3_1_BASE:1.23
	UBC_SYNC_B:1.23
	UBC:1.21.0.4
	UBC_BASE:1.21
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.18
	OPENBSD_2_9:1.18.0.2
	OPENBSD_2_8:1.16.0.2
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.15.0.4
	OPENBSD_2_7_BASE:1.15
	SMP:1.15.0.2
	SMP_BASE:1.15
	kame_19991208:1.15
	OPENBSD_2_6:1.14.0.4
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.2
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.4
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.12.0.2
	OPENBSD_2_1_BASE:1.12
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.49
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.48;
commitid	uRv5pa9QDlZaYgwD;

1.48
date	2017.06.04.19.23.20;	author naddy;	state Exp;
branches;
next	1.47;
commitid	Q0vaCVp5TFHWF0j9;

1.47
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.46;
commitid	VyLWTsbepAOk7VQM;

1.46
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.45;
commitid	QHiEhS9DHyE6oiIr;

1.45
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.44;
commitid	J9apD0jq2AjFmqZc;

1.44
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.43;
commitid	f4dx5ry1aOiKJw33;

1.43
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.42;
commitid	B0kwmVGiD5DVx4kv;

1.42
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.41;
commitid	5gdEnqVoJuTuwdTu;

1.41
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.40;
commitid	5DvsamK0GblTp8ww;

1.40
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.39;
commitid	SaArro4mM2Ab3ure;

1.39
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.38;
commitid	MVWrtktB46JRxFWT;

1.38
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.37;
commitid	0fL6zHGm3fqppVdw;

1.37
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.36;
commitid	hN5bFCE56DrAjl99;

1.36
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.35;
commitid	yM2VFFhpDTeFQlve;

1.35
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.34;
commitid	nYggAidK85QbUFh2;

1.34
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2013.08.07.01.06.32;	author bluhm;	state Exp;
branches;
next	1.32;

1.32
date	2009.03.29.21.53.52;	author sthen;	state Exp;
branches;
next	1.31;

1.31
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2007.01.07.15.15.58;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.16.16.30.56;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.21.18.16.40;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.10.10.11.24;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2003.01.27.19.09.12;	author jason;	state Exp;
branches;
next	1.23;

1.23
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.27.06.34.45;	author kjc;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	2001.06.25.04.44.28;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.23.21.54.49;	author fgsch;	state Exp;
branches;
next	1.18;

1.18
date	2001.04.06.08.04.05;	author fgsch;	state Exp;
branches;
next	1.17;

1.17
date	2001.02.20.19.39.39;	author mickey;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.05.20.56.20;	author niklas;	state Exp;
branches;
next	1.15;

1.15
date	99.11.30.23.48.07;	author aaron;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	99.02.28.03.23.37;	author jason;	state Exp;
branches;
next	1.13;

1.13
date	97.11.07.08.06.47;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.10.16.12.36.00;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.08.03.10.13.38;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.26.00.27.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.41.17;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.05.13.38.24;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.23.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.20.01.00.47;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.10.16;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.53;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	96.01.15.01.41.02;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.21;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.14.22.24.40;	author niklas;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.07.04.10.41.27;	author niklas;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.15.2.4;

1.15.2.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.15.2.5;

1.15.2.5
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	1.15.2.6;

1.15.2.6
date	2004.06.05.23.12.45;	author niklas;	state Exp;
branches;
next	;

1.21.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.49
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: if_eg.c,v 1.48 2017/06/04 19:23:20 naddy Exp $	*/
/*	$NetBSD: if_eg.c,v 1.26 1996/05/12 23:52:27 mycroft Exp $	*/

/*
 * Copyright (c) 1993 Dean Huxley <dean@@fsa.ca>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Dean Huxley.
 * 4. The name of Dean Huxley may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * Support for 3Com 3c505 Etherlink+ card.
 */

/* To do:
 * - multicast
 * - promiscuous
 */
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/systm.h>
#include <sys/selinfo.h>
#include <sys/device.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/isa/if_egreg.h>
#include <dev/isa/elink.h>

/* for debugging convenience */
#ifdef EGDEBUG
#define DPRINTF(x) printf x
#else
#define DPRINTF(x)
#endif

#define EG_INLEN  	10
#define EG_BUFLEN	0x0670

/*
 * Ethernet software status per interface.
 */
struct eg_softc {
	struct device sc_dev;
	void *sc_ih;
	bus_space_tag_t sc_bst;
	bus_space_handle_t sc_bsh;
	struct arpcom sc_arpcom;	/* Ethernet common part */
	u_char  eg_rom_major;		/* Cards ROM version (major number) */ 
	u_char  eg_rom_minor;		/* Cards ROM version (minor number) */ 
	short	eg_ram;			/* Amount of RAM on the card */
	u_char	eg_pcb[64];		/* Primary Command Block buffer */
	u_char  eg_incount;		/* Number of buffers currently used */
	u_char  *eg_inbuf;		/* Incoming packet buffer */
	u_char	*eg_outbuf;		/* Outgoing packet buffer */
};

int egprobe(struct device *, void *, void *);
void egattach(struct device *, struct device *, void *);

struct cfattach eg_ca = {
	sizeof(struct eg_softc), egprobe, egattach
};

struct cfdriver eg_cd = {
	NULL, "eg", DV_IFNET
};

int egintr(void *);
void eginit(struct eg_softc *);
int egioctl(struct ifnet *, u_long, caddr_t);
void egrecv(struct eg_softc *);
void egstart(struct ifnet *);
void egwatchdog(struct ifnet *);
void egreset(struct eg_softc *);
void egread(struct eg_softc *, caddr_t, int);
struct mbuf *egget(struct eg_softc *, caddr_t, int);
void egstop(struct eg_softc *);

static __inline void egprintpcb(struct eg_softc *);
static int egoutPCB(struct eg_softc *, u_char);
static int egreadPCBstat(struct eg_softc *, u_char);
static int egreadPCBready(struct eg_softc *);
static int egwritePCB(struct eg_softc *);
static int egreadPCB(struct eg_softc *);

/*
 * Support stuff
 */
	
static __inline void
egprintpcb(struct eg_softc *sc)
{
	int i;
	
	for (i = 0; i < sc->eg_pcb[1] + 2; i++)
		DPRINTF(("pcb[%2d] = %x\n", i, sc->eg_pcb[i]));
}


static int
egoutPCB(struct eg_softc *sc, u_char b)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int i;

	for (i = 0; i < 4000; i++) {
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HCRE) {
			bus_space_write_1(bst, bsh, EG_COMMAND, b);
			return 0;
		}
		delay(10);
	}
	DPRINTF(("egoutPCB failed\n"));
	return (1);
}
	
static int
egreadPCBstat(struct eg_softc *sc, u_char statb)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int i;

	for (i=0; i < 5000; i++) {
		if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) !=
		    EG_PCB_NULL) 
			break;
		delay(10);
	}
	if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) == statb) 
		return (0);
	return (1);
}

static int
egreadPCBready(struct eg_softc *sc)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int i;

	for (i=0; i < 10000; i++) {
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_ACRF)
			return (0);
		delay(5);
	}
	DPRINTF(("PCB read not ready status %02x\n",
	    bus_space_read_1(bst, bsh, EG_STATUS)));
	return (1);
}
	
static int
egwritePCB(struct eg_softc *sc)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int i;
	u_char len;

	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_NULL);

	len = sc->eg_pcb[1] + 2;
	for (i = 0; i < len; i++)
		egoutPCB(sc, sc->eg_pcb[i]);
	
	for (i=0; i < 4000; i++) {
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HCRE)
			break;
		delay(10);
	}

	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_DONE);

	egoutPCB(sc, len);

	if (egreadPCBstat(sc, EG_PCB_ACCEPT))
		return (1);
	return (0);
}	
	
static int
egreadPCB(struct eg_softc *sc)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int i;
	u_char b;
	
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_NULL);

	bzero(sc->eg_pcb, sizeof(sc->eg_pcb));

	if (egreadPCBready(sc))
		return (1);

	sc->eg_pcb[0] = bus_space_read_1(bst, bsh, EG_COMMAND);
	
	if (egreadPCBready(sc))
		return (1);

	sc->eg_pcb[1] = bus_space_read_1(bst, bsh, EG_COMMAND);

	if (sc->eg_pcb[1] > 62) {
		DPRINTF(("len %d too large\n", sc->eg_pcb[1]));
		return (1);
	}
	
	for (i = 0; i < sc->eg_pcb[1]; i++) {
		if (egreadPCBready(sc))
			return (1);
		sc->eg_pcb[2+i] = bus_space_read_1(bst, bsh, EG_COMMAND);
	}
	if (egreadPCBready(sc))
		return (1);
	if (egreadPCBstat(sc, EG_PCB_DONE))
		return (1);
	if ((b = bus_space_read_1(bst, bsh, EG_COMMAND)) != sc->eg_pcb[1] + 2) {
		DPRINTF(("%d != %d\n", b, sc->eg_pcb[1] + 2));
		return (1);
	}

	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_ACCEPT);

	return (0);
}	

/*
 * Real stuff
 */

int
egprobe(struct device *parent, void *match, void *aux)
{
	struct eg_softc *sc = match;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t bst = sc->sc_bst = ia->ia_iot;
	bus_space_handle_t bsh;
	int i;

	if ((ia->ia_iobase & ~0x07f0) != 0) {
		DPRINTF(("Weird iobase %x\n", ia->ia_iobase));
		return (0);
	}
	
	if (bus_space_map(bst, ia->ia_iobase, EG_IO_PORTS, 0, &bsh)) {
		DPRINTF(("%s: can't map i/o space\n", sc->sc_dev.dv_xname));
		return (0);
	}
	sc->sc_bsh = bsh;

	/* hard reset card */
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_RESET); 
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
	for (i = 0; i < 5000; i++) {
		delay(1000);
		if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) ==
		    EG_PCB_NULL) 
			break;
	}
	if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) !=
	    EG_PCB_NULL) {
		DPRINTF(("eg: Reset failed\n"));
		goto lose;
	}
	sc->eg_pcb[0] = EG_CMD_GETINFO; /* Get Adapter Info */
	sc->eg_pcb[1] = 0;
	if (egwritePCB(sc) != 0)
		goto lose;
	
	if (egreadPCB(sc) != 0) {
		egprintpcb(sc);
		goto lose;
	}

	if (sc->eg_pcb[0] != EG_RSP_GETINFO || /* Get Adapter Info Response */
	    sc->eg_pcb[1] != 0x0a) {
		egprintpcb(sc);
		goto lose;
	}
	sc->eg_rom_major = sc->eg_pcb[3];
	sc->eg_rom_minor = sc->eg_pcb[2];
	sc->eg_ram = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);
	
	ia->ia_iosize = 0x08;
	ia->ia_msize = 0;
	bus_space_unmap(bst, bsh, EG_IO_PORTS);
	return (1);

lose:
	bus_space_unmap(bst, bsh, EG_IO_PORTS);
	return (0);
}

void
egattach(struct device *parent, struct device *self, void *aux)
{
	struct eg_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t bst = sc->sc_bst = ia->ia_iot;
	bus_space_handle_t bsh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	
	if (bus_space_map(bst, ia->ia_iobase, EG_IO_PORTS, 0, &bsh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}
	sc->sc_bsh = bsh;

	egstop(sc);

	sc->eg_pcb[0] = EG_CMD_GETEADDR; /* Get Station address */
	sc->eg_pcb[1] = 0;
	if (egwritePCB(sc) != 0) {
		DPRINTF(("write error\n"));
		return;
	}	
	if (egreadPCB(sc) != 0) {
		DPRINTF(("read error\n"));
		egprintpcb(sc);
		return;
	}

	/* check Get station address response */
	if (sc->eg_pcb[0] != EG_RSP_GETEADDR || sc->eg_pcb[1] != 0x06) { 
		DPRINTF(("parse error\n"));
		egprintpcb(sc);
		return;
	}
	bcopy(&sc->eg_pcb[2], sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	printf(": ROM v%d.%02d %dk address %s\n",
	    sc->eg_rom_major, sc->eg_rom_minor, sc->eg_ram,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));

	sc->eg_pcb[0] = EG_CMD_SETEADDR; /* Set station address */
	if (egwritePCB(sc) != 0) {
		DPRINTF(("write error2\n"));
		return;
	}
	if (egreadPCB(sc) != 0) {
		DPRINTF(("read error2\n"));
		egprintpcb(sc);
		return;
	}
	if (sc->eg_pcb[0] != EG_RSP_SETEADDR || sc->eg_pcb[1] != 0x02 ||
	    sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0) {
		DPRINTF(("parse error2\n"));
		egprintpcb(sc);
		return;
	}

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = egstart;
	ifp->if_ioctl = egioctl;
	ifp->if_watchdog = egwatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX;
	
	/* Now we can attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);
	
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, egintr, sc, sc->sc_dev.dv_xname);
}

void
eginit(register struct eg_softc *sc)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	register struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	/* soft reset the board */
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_FLSH);
	delay(100);
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_ATTN);
	delay(100);
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
	delay(200);

	sc->eg_pcb[0] = EG_CMD_CONFIG82586; /* Configure 82586 */
	sc->eg_pcb[1] = 2;
	sc->eg_pcb[2] = 3; /* receive broadcast & multicast */
	sc->eg_pcb[3] = 0;
	if (egwritePCB(sc) != 0)
		DPRINTF(("write error3\n"));

	if (egreadPCB(sc) != 0) {
		DPRINTF(("read error3\n"));
		egprintpcb(sc);
	} else if (sc->eg_pcb[2] != 0 || sc->eg_pcb[3] != 0)
		printf("%s: configure card command failed\n",
		    sc->sc_dev.dv_xname);

	if (sc->eg_inbuf == 0)
		sc->eg_inbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);
	sc->eg_incount = 0;

	if (sc->eg_outbuf == 0)
		sc->eg_outbuf = malloc(EG_BUFLEN, M_TEMP, M_NOWAIT);

	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_CMDE);

	sc->eg_incount = 0;
	egrecv(sc);

	/* Interface is now `running', with no output active. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Attempt to start output, if any. */
	egstart(ifp);
}

void
egrecv(struct eg_softc *sc)
{
	while (sc->eg_incount < EG_INLEN) {
		sc->eg_pcb[0] = EG_CMD_RECVPACKET;
		sc->eg_pcb[1] = 0x08;
		sc->eg_pcb[2] = 0; /* address not used.. we send zero */
		sc->eg_pcb[3] = 0;
		sc->eg_pcb[4] = 0;
		sc->eg_pcb[5] = 0;
		sc->eg_pcb[6] = EG_BUFLEN & 0xff; /* our buffer size */
		sc->eg_pcb[7] = (EG_BUFLEN >> 8) & 0xff;
		sc->eg_pcb[8] = 0; /* timeout, 0 == none */
		sc->eg_pcb[9] = 0;
		if (egwritePCB(sc) != 0)
			break;
		sc->eg_incount++;
	}
}

void
egstart(struct ifnet *ifp)
{
	struct eg_softc *sc = ifp->if_softc;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	struct mbuf *m0, *m;
	caddr_t buffer;
	int len;
	u_short *ptr;
	u_int i;

	/* Don't transmit if interface is busy or not running */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

loop:
	/* Dequeue the next datagram. */
	IFQ_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == NULL)
		return;
	
	ifq_set_oactive(&ifp->if_snd);

	/* We need to use m->m_pkthdr.len, so require the header */
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("egstart: no header mbuf");
	len = max(m0->m_pkthdr.len, ETHER_MIN_LEN);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	sc->eg_pcb[0] = EG_CMD_SENDPACKET;
	sc->eg_pcb[1] = 0x06;
	sc->eg_pcb[2] = 0; /* address not used, we send zero */
	sc->eg_pcb[3] = 0;
	sc->eg_pcb[4] = 0;
	sc->eg_pcb[5] = 0;
	sc->eg_pcb[6] = len; /* length of packet */
	sc->eg_pcb[7] = len >> 8;
	if (egwritePCB(sc) != 0) {
		DPRINTF(("egwritePCB in egstart failed\n"));
		ifp->if_oerrors++;
		ifq_clr_oactive(&ifp->if_snd);
		m_freem(m0);
		goto loop;
	}

	buffer = sc->eg_outbuf;
	for (m = m0; m != 0; m = m->m_next) {
		bcopy(mtod(m, caddr_t), buffer, m->m_len);
		buffer += m->m_len;
	}
	if (len > m0->m_pkthdr.len)
		bzero(buffer, len - m0->m_pkthdr.len);

	/* set direction bit: host -> adapter */
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_CTL_DIR); 
	
	for (ptr = (u_short *)sc->eg_outbuf; len > 0; len -= 2) {
		bus_space_write_2(bst, bsh, EG_DATA, *ptr++);
		for (i = 10000; i != 0; i--) {
			if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HRDY)
				break;
			delay(10);
		}
		if (i == 0) {
			printf("%s: start failed\n", sc->sc_dev.dv_xname);
			break;
		}
	}
	
	m_freem(m0);
}

int
egintr(void *arg)
{
	struct eg_softc *sc = arg;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	int ret = 0;
	int i, len;
	u_short *ptr;

	while (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_ACRF) {
		ret = 1;
		egreadPCB(sc);
		switch (sc->eg_pcb[0]) {
		case EG_RSP_RECVPACKET:
			len = sc->eg_pcb[6] | (sc->eg_pcb[7] << 8);
	
			/* Set direction bit : Adapter -> host */
			bus_space_write_1(bst, bsh, EG_CONTROL,
			    bus_space_read_1(bst, bsh, EG_CONTROL) |
			    EG_CTL_DIR); 

			for (ptr = (u_short *)sc->eg_inbuf; len > 0; len -= 2) {
				for (i = 10000; i != 0; i--) {
					if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HRDY)
						break;
					delay(10);
				}
				if (i == 0) {
					printf("%s: receive failed\n",
					    sc->sc_dev.dv_xname);
					break;
				}
				*ptr++ = bus_space_read_2(bst, bsh, EG_DATA);
			}

			if (len <= 0) {
				len = sc->eg_pcb[8] | (sc->eg_pcb[9] << 8);
				egread(sc, sc->eg_inbuf, len);

				sc->eg_incount--;
				egrecv(sc);
			}
			break;

		case EG_RSP_SENDPACKET:
			if (sc->eg_pcb[6] || sc->eg_pcb[7]) {
				DPRINTF(("packet dropped\n"));
				sc->sc_arpcom.ac_if.if_oerrors++;
			}
			sc->sc_arpcom.ac_if.if_collisions +=
			    sc->eg_pcb[8] & 0xf;
			ifq_clr_oactive(&sc->sc_arpcom.ac_if.if_snd);
			egstart(&sc->sc_arpcom.ac_if);
			break;

		case EG_RSP_GETSTATS:
			DPRINTF(("Card Statistics\n"));
			bcopy(&sc->eg_pcb[2], &i, sizeof(i));
			DPRINTF(("Receive Packets %d\n", i));
			bcopy(&sc->eg_pcb[6], &i, sizeof(i));
			DPRINTF(("Transmit Packets %d\n", i));
			DPRINTF(("CRC errors %d\n", *(short *)&sc->eg_pcb[10]));
			DPRINTF(("alignment errors %d\n",
			    *(short *)&sc->eg_pcb[12]));
			DPRINTF(("no resources errors %d\n",
			    *(short *)&sc->eg_pcb[14]));
			DPRINTF(("overrun errors %d\n",
			    *(short *)&sc->eg_pcb[16]));
			break;
			
		default:
			DPRINTF(("egintr: Unknown response %x??\n",
			    sc->eg_pcb[0]));
			egprintpcb(sc);
			break;
		}
	}

	return (ret);
}

/*
 * Pass a packet up to the higher levels.
 */
void
egread(struct eg_softc *sc, caddr_t buf, int len)
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHER_MAX_LEN) {
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = egget(sc, buf, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * convert buf into mbufs
 */
struct mbuf *
egget(struct eg_softc *sc, caddr_t buf, int totlen)
{
	struct mbuf *top, **mp, *m;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (0);
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return (0);
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		bcopy((caddr_t)buf, mtod(m, caddr_t), len);
		buf += len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return (top);
}

int
egioctl(register struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct eg_softc *sc = ifp->if_softc;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		eginit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			egstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			eginit(sc);
		} else {
			sc->eg_pcb[0] = EG_CMD_GETSTATS;
			sc->eg_pcb[1] = 0;
			if (egwritePCB(sc) != 0)
				DPRINTF(("write error\n"));
			/*
			 * XXX deal with flags changes:
			 * IFF_MULTICAST, IFF_PROMISC,
			 * IFF_LINK0, IFF_LINK1,
			 */
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	splx(s);
	return (error);
}

void
egreset(struct eg_softc *sc)
{
	int s;

	DPRINTF(("egreset()\n"));
	s = splnet();
	egstop(sc);
	eginit(sc);
	splx(s);
}

void
egwatchdog(struct ifnet *ifp)
{
	struct eg_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	sc->sc_arpcom.ac_if.if_oerrors++;

	egreset(sc);
}

void
egstop(register struct eg_softc *sc)
{
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
	
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
}
@


1.48
log
@Remove unused function, as pointed out by clang.  ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.47 2017/01/22 10:17:38 dlg Exp $	*/
a42 1
#include <sys/types.h>
@


1.47
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.46 2016/04/13 10:49:26 mpi Exp $	*/
a120 1
static __inline void egprintstat(u_char);
a139 13

static __inline void
egprintstat(u_char b)
{
	DPRINTF(("%s %s %s %s %s %s %s\n", 
	    (b & EG_STAT_HCRE)?"HCRE":"",
	    (b & EG_STAT_ACRF)?"ACRF":"",
	    (b & EG_STAT_DIR )?"DIR ":"",
	    (b & EG_STAT_DONE)?"DONE":"",
	    (b & EG_STAT_ASF3)?"ASF3":"",
	    (b & EG_STAT_ASF2)?"ASF2":"",
	    (b & EG_STAT_ASF1)?"ASF1":""));
}
@


1.46
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.45 2015/12/08 13:34:22 tedu Exp $	*/
d628 1
a628 2
			} else
				sc->sc_arpcom.ac_if.if_opackets++;
@


1.45
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.44 2015/11/25 11:20:38 mpi Exp $	*/
a422 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.44
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.43 2015/11/25 03:09:59 dlg Exp $	*/
d422 1
a422 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;
@


1.43
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.42 2015/11/24 17:11:39 mpi Exp $	*/
a54 1
#include <net/netisr.h>
@


1.42
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.41 2015/11/24 13:33:17 mpi Exp $	*/
d477 1
a477 1
	ifp->if_flags &= ~IFF_OACTIVE;
d516 1
a516 1
	if ((ifp->if_flags & (IFF_RUNNING|IFF_OACTIVE)) != IFF_RUNNING)
d525 1
a525 1
	ifp->if_flags |= IFF_OACTIVE;
d548 1
a548 1
		ifp->if_flags &= ~IFF_OACTIVE;
d634 1
a634 1
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
@


1.41
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.40 2015/10/25 13:13:06 mpi Exp $	*/
a54 1
#include <net/if_dl.h>
@


1.40
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.39 2015/06/24 09:40:54 mpi Exp $	*/
a55 1
#include <net/if_types.h>
@


1.39
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.38 2015/05/19 11:24:01 mpi Exp $	*/
a740 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d748 1
a748 10

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			eginit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			eginit(sc);
			break;
		}
@


1.38
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.37 2015/05/13 10:42:46 jsg Exp $	*/
a690 1
	ifp->if_ipackets++;
a691 1

@


1.37
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.36 2014/12/22 02:28:51 tedu Exp $	*/
d673 1
d675 1
a675 1
	
d692 1
d694 1
a694 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
a702 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a708 1
	m->m_pkthdr.rcvif = ifp;
@


1.36
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.35 2014/08/11 12:45:45 mpi Exp $	*/
d524 1
a524 1
	if (m0 == 0)
d685 1
a685 1
	if (m == 0) {
d715 1
a715 1
	if (m == 0)
d726 1
a726 1
			if (m == 0) {
@


1.35
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.34 2013/11/15 16:46:27 brad Exp $	*/
a761 1
#ifdef INET
a765 1
#endif
@


1.34
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.33 2013/08/07 01:06:32 bluhm Exp $	*/
a58 1
#ifdef INET
a59 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a60 1
#endif
@


1.33
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.32 2009/03/29 21:53:52 sthen Exp $	*/
d140 1
a140 2
egprintpcb(sc)
	struct eg_softc *sc;
d150 1
a150 2
egprintstat(b)
	u_char b;
d163 1
a163 3
egoutPCB(sc, b)
	struct eg_softc *sc;
	u_char b;
d181 1
a181 3
egreadPCBstat(sc, statb)
	struct eg_softc *sc;
	u_char statb;
d199 1
a199 2
egreadPCBready(sc)
	struct eg_softc *sc;
d216 1
a216 2
egwritePCB(sc)
	struct eg_softc *sc;
d249 1
a249 2
egreadPCB(sc)
	struct eg_softc *sc;
d303 1
a303 3
egprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d366 1
a366 3
egattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d441 1
a441 2
eginit(sc)
	register struct eg_softc *sc;
d490 1
a490 2
egrecv(sc)
	struct eg_softc *sc;
a491 1

d510 1
a510 2
egstart(ifp)
	struct ifnet *ifp;
d588 1
a588 2
egintr(arg)
	void *arg;
d674 1
a674 4
egread(sc, buf, len)
	struct eg_softc *sc;
	caddr_t buf;
	int len;
d712 1
a712 4
egget(sc, buf, totlen)
	struct eg_softc *sc;
	caddr_t buf;
	int totlen;
d753 1
a753 4
egioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d816 1
a816 2
egreset(sc)
	struct eg_softc *sc;
d828 1
a828 2
egwatchdog(ifp)
	struct ifnet *ifp;
d839 1
a839 2
egstop(sc)
	register struct eg_softc *sc;
@


1.32
log
@make various strings ("can't map mem space" and similar) more consistent
between instances, saving space in the kernel. feedback from many (some
incorporated, some left for future work).

ok deraadt, kettenis, "why not" miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.31 2008/10/02 20:21:13 brad Exp $	*/
a61 1
#include <netinet/in_var.h>
@


1.31
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.30 2007/01/07 15:15:58 miod Exp $	*/
d329 1
a329 1
		DPRINTF(("%s: can't map I/O space\n", sc->sc_dev.dv_xname));
@


1.30
log
@Replace infinite loops with appropriate constructs to fail operation if it
takes much more time than it should.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.29 2006/04/16 16:30:56 miod Exp $	*/
a788 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

a789 1

d836 1
a836 2
		error = EINVAL;
		break;
@


1.29
log
@bus_space_handle_t and bus_space_tag_t being opaque, they can not necessarily
be assigned ``0'' (in egprobe() upon failure).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.28 2006/03/25 22:41:44 djm Exp $	*/
d80 1
a80 1
#define dprintf(x) printf x
d82 1
a82 1
#define dprintf(x)
d147 1
a147 1
		dprintf(("pcb[%2d] = %x\n", i, sc->eg_pcb[i]));
d155 1
a155 1
	dprintf(("%s %s %s %s %s %s %s\n", 
d174 1
a174 1
	for (i=0; i < 4000; i++) {
d181 1
a181 1
	dprintf(("egoutPCB failed\n"));
d218 2
a219 1
	dprintf(("PCB read not ready\n"));
d283 1
a283 1
		dprintf(("len %d too large\n", sc->eg_pcb[1]));
d296 2
a297 3
	if ((b = bus_space_read_1(bst, bsh, EG_COMMAND)) != sc->eg_pcb[1] + 2)
	    {
		dprintf(("%d != %d\n", b, sc->eg_pcb[1] + 2));
d324 1
a324 1
		dprintf(("Weird iobase %x\n", ia->ia_iobase));
d329 1
a329 1
		dprintf(("%s: can't map I/O space\n", sc->sc_dev.dv_xname));
d345 1
a345 1
		dprintf(("eg: Reset failed\n"));
d399 1
a399 1
		dprintf(("write error\n"));
d403 1
a403 1
		dprintf(("read error\n"));
d410 1
a410 1
		dprintf(("parse error\n"));
d422 1
a422 1
		dprintf(("write error2\n"));
d426 1
a426 1
		dprintf(("read error2\n"));
d432 1
a432 1
		dprintf(("parse error2\n"));
d475 1
a475 1
		dprintf(("write error3\n"));
d478 1
a478 1
		dprintf(("read error\n"));
d537 1
d570 1
a570 1
		dprintf(("egwritePCB in egstart failed\n"));
d591 9
a599 2
		while (!(bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HRDY))
			; /* XXX need timeout here */
d628 11
a638 5
			for (ptr = (u_short *)sc->eg_inbuf; len > 0; len -= 2)
			    {
				while (!(bus_space_read_1(bst, bsh,
				    EG_STATUS) & EG_STAT_HRDY))
					;
d642 3
a644 2
			len = sc->eg_pcb[8] | (sc->eg_pcb[9] << 8);
			egread(sc, sc->eg_inbuf, len);
d646 3
a648 2
			sc->eg_incount--;
			egrecv(sc);
d653 1
a653 1
				dprintf(("packet dropped\n"));
d664 1
a664 1
			dprintf(("Card Statistics\n"));
d666 1
a666 1
			dprintf(("Receive Packets %d\n", i));
d668 3
a670 3
			dprintf(("Transmit Packets %d\n", i));
			dprintf(("CRC errors %d\n", *(short *)&sc->eg_pcb[10]));
			dprintf(("alignment errors %d\n",
d672 1
a672 1
			dprintf(("no resources errors %d\n",
d674 1
a674 1
			dprintf(("overrun errors %d\n",
d679 1
a679 1
			dprintf(("egintr: Unknown response %x??\n",
d832 1
a832 1
				dprintf(("write error\n"));
d856 1
a856 1
	dprintf(("egreset()\n"));
@


1.28
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.27 2005/11/21 18:16:40 millert Exp $	*/
a372 1
	sc->sc_bst = sc->sc_bsh = 0;
@


1.27
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.26 2004/05/12 06:35:11 tedu Exp $	*/
d558 1
a558 1
		bpf_mtap(ifp->if_bpf, m0);
d709 1
a709 1
		bpf_mtap(ifp->if_bpf, m);
@


1.26
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.25 2003/04/10 10:11:24 miod Exp $	*/
d51 1
a51 1
#include <sys/select.h>
@


1.25
log
@Proper use of bus_space makes the need for <machine/pio.h> obsolete, which
is good since not all isa capable platforms provide such a file.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.24 2003/01/27 19:09:12 jason Exp $	*/
a68 1
#include <net/bpfdesc.h>
@


1.24
log
@Pad tx buffer with 0's on minimum sized frames; based on NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.23 2002/03/14 03:16:05 millert Exp $	*/
a73 1
#include <machine/pio.h>
@


1.23
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.22 2002/03/14 01:26:56 millert Exp $	*/
d584 2
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.21 2001/06/27 06:34:45 kjc Exp $	*/
d654 1
a654 1
			dprintf(("CRC errors %d\n", *(short*)&sc->eg_pcb[10]));
d656 1
a656 1
			    *(short*)&sc->eg_pcb[12]));
d658 1
a658 1
			    *(short*)&sc->eg_pcb[14]));
d660 1
a660 1
			    *(short*)&sc->eg_pcb[16]));
@


1.21
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.20 2001/06/25 04:44:28 fgsch Exp $	*/
d108 2
a109 2
int egprobe __P((struct device *, void *, void *));
void egattach __P((struct device *, struct device *, void *));
d119 18
a136 18
int egintr __P((void *));
void eginit __P((struct eg_softc *));
int egioctl __P((struct ifnet *, u_long, caddr_t));
void egrecv __P((struct eg_softc *));
void egstart __P((struct ifnet *));
void egwatchdog __P((struct ifnet *));
void egreset __P((struct eg_softc *));
void egread __P((struct eg_softc *, caddr_t, int));
struct mbuf *egget __P((struct eg_softc *, caddr_t, int));
void egstop __P((struct eg_softc *));

static __inline void egprintpcb __P((struct eg_softc *));
static __inline void egprintstat __P((u_char));
static int egoutPCB __P((struct eg_softc *, u_char));
static int egreadPCBstat __P((struct eg_softc *, u_char));
static int egreadPCBready __P((struct eg_softc *));
static int egwritePCB __P((struct eg_softc *));
static int egreadPCB __P((struct eg_softc *));
@


1.21.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.21 2001/06/27 06:34:45 kjc Exp $	*/
d108 2
a109 2
int egprobe(struct device *, void *, void *);
void egattach(struct device *, struct device *, void *);
d119 18
a136 18
int egintr(void *);
void eginit(struct eg_softc *);
int egioctl(struct ifnet *, u_long, caddr_t);
void egrecv(struct eg_softc *);
void egstart(struct ifnet *);
void egwatchdog(struct ifnet *);
void egreset(struct eg_softc *);
void egread(struct eg_softc *, caddr_t, int);
struct mbuf *egget(struct eg_softc *, caddr_t, int);
void egstop(struct eg_softc *);

static __inline void egprintpcb(struct eg_softc *);
static __inline void egprintstat(u_char);
static int egoutPCB(struct eg_softc *, u_char);
static int egreadPCBstat(struct eg_softc *, u_char);
static int egreadPCBready(struct eg_softc *);
static int egwritePCB(struct eg_softc *);
static int egreadPCB(struct eg_softc *);
d654 1
a654 1
			dprintf(("CRC errors %d\n", *(short *)&sc->eg_pcb[10]));
d656 1
a656 1
			    *(short *)&sc->eg_pcb[12]));
d658 1
a658 1
			    *(short *)&sc->eg_pcb[14]));
d660 1
a660 1
			    *(short *)&sc->eg_pcb[16]));
@


1.21.4.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d74 1
a583 2
	if (len > m0->m_pkthdr.len)
		bzero(buffer, len - m0->m_pkthdr.len);
@


1.20
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.19 2001/06/23 21:54:49 fgsch Exp $	*/
d447 1
d547 1
a547 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.19
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.18 2001/04/06 08:04:05 fgsch Exp $	*/
a683 1
	struct ether_header *eh;
a701 3
	/* We assume the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d711 1
a711 3
	/* We assume the header fit entirely in one mbuf. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.18
log
@Only print an error if I/O cannot be mapped at egprobe if EGDEBUG is set.
Don't panic if I/O cannot be mapped at egattach, print and return instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.17 2001/02/20 19:39:39 mickey Exp $	*/
a85 4

#define ETHER_MIN_LEN	64
#define ETHER_MAX_LEN	1518
#define ETHER_ADDR_LEN	6
@


1.17
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.16 2000/06/05 20:56:20 niklas Exp $	*/
d335 1
a335 1
		printf("%s: can't map I/O space\n", sc->sc_dev.dv_xname);
d395 4
a398 2
	if (bus_space_map(bst, ia->ia_iobase, EG_IO_PORTS, 0, &bsh))
		panic("%s: can't map I/O space", sc->sc_dev.dv_xname);
@


1.16
log
@Untested busification of this driver done years ago.
Noone ever answered my call for testers so here it goes.. helps ne problems
as ne at 0x300 gets a bit whacked by eg's probe
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.15 1999/11/30 23:48:07 aaron Exp $	*/
a453 4
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif

@


1.15
log
@Remove duplicate #include's.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.14 1999/02/28 03:23:37 jason Exp $	*/
d100 2
a102 4
	int eg_cmd;			/* Command register R/W */
	int eg_ctl;			/* Control register R/W (EG_CTL_*) */
	int eg_stat;			/* Status register R/O (EG_STAT_*) */
	int eg_data;			/* Data register R/W (16 bits) */
d134 2
a135 2
static inline void egprintpcb __P((struct eg_softc *));
static inline void egprintstat __P((u_char));
d146 1
a146 1
static inline void
d157 1
a157 1
static inline void
d162 7
a168 7
		 (b & EG_STAT_HCRE)?"HCRE":"",
		 (b & EG_STAT_ACRF)?"ACRF":"",
		 (b & EG_STAT_DIR )?"DIR ":"",
		 (b & EG_STAT_DONE)?"DONE":"",
		 (b & EG_STAT_ASF3)?"ASF3":"",
		 (b & EG_STAT_ASF2)?"ASF2":"",
		 (b & EG_STAT_ASF1)?"ASF1":""));
d176 2
d181 2
a182 2
		if (inb(sc->eg_stat) & EG_STAT_HCRE) {
			outb(sc->eg_cmd, b);
d188 1
a188 1
	return 1;
d196 2
d201 2
a202 1
		if ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) 
d206 3
a208 3
	if ((inb(sc->eg_stat) & EG_PCB_STAT) == statb) 
		return 0;
	return 1;
d215 2
d220 2
a221 2
		if (inb(sc->eg_stat) & EG_STAT_ACRF)
			return 0;
d225 1
a225 1
	return 1;
d232 2
d237 3
a239 1
	outb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);
d246 1
a246 1
		if (inb(sc->eg_stat) & EG_STAT_HCRE)
d251 3
a253 1
	outb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_DONE);
d258 2
a259 2
		return 1;
	return 0;
d266 2
d271 3
a273 1
	outb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_NULL);
d278 1
a278 1
		return 1;
d280 1
a280 1
	sc->eg_pcb[0] = inb(sc->eg_cmd);
d283 1
a283 1
		return 1;
d285 1
a285 1
	sc->eg_pcb[1] = inb(sc->eg_cmd);
d289 1
a289 1
		return 1;
d294 2
a295 2
			return 1;
		sc->eg_pcb[2+i] = inb(sc->eg_cmd);
d298 1
a298 1
		return 1;
d300 3
a302 2
		return 1;
	if ((b = inb(sc->eg_cmd)) != sc->eg_pcb[1] + 2) {
d304 1
a304 1
		return 1;
d307 3
a309 1
	outb(sc->eg_ctl, (inb(sc->eg_ctl) & ~EG_PCB_STAT) | EG_PCB_ACCEPT);
d311 1
a311 1
	return 0;
d325 2
d331 1
a331 1
		return 0;
d334 5
a338 4
	sc->eg_cmd = ia->ia_iobase + EG_COMMAND;
	sc->eg_ctl = ia->ia_iobase + EG_CONTROL;
	sc->eg_stat = ia->ia_iobase + EG_STATUS;
	sc->eg_data = ia->ia_iobase + EG_DATA;
d341 2
a342 2
	outb(sc->eg_ctl, EG_CTL_RESET); 
	outb(sc->eg_ctl, 0);
d345 2
a346 1
		if ((inb(sc->eg_stat) & EG_PCB_STAT) == EG_PCB_NULL) 
d349 2
a350 1
	if ((inb(sc->eg_stat) & EG_PCB_STAT) != EG_PCB_NULL) {
d352 1
a352 1
		return 0;
d357 1
a357 1
		return 0;
d361 1
a361 1
		return 0;
d367 1
a367 1
		return 0;
d375 7
a381 1
	return 1;
d391 2
d395 4
d466 2
d471 1
a471 1
	outb(sc->eg_ctl, EG_CTL_FLSH);
d473 1
a473 1
	outb(sc->eg_ctl, EG_CTL_ATTN);
d475 1
a475 1
	outb(sc->eg_ctl, 0);
d499 1
a499 1
	outb(sc->eg_ctl, EG_CTL_CMDE);
d538 3
a540 1
	register struct eg_softc *sc = ifp->if_softc;
d591 2
a592 1
	outb(sc->eg_ctl, inb(sc->eg_ctl) & ~EG_CTL_DIR); 
d594 3
a596 3
	for (ptr = (u_short *) sc->eg_outbuf; len > 0; len -= 2) {
		outw(sc->eg_data, *ptr++);
		while (!(inb(sc->eg_stat) & EG_STAT_HRDY))
d607 3
a609 1
	register struct eg_softc *sc = arg;
d614 1
a614 1
	while (inb(sc->eg_stat) & EG_STAT_ACRF) {
d622 8
a629 4
			outb(sc->eg_ctl, inb(sc->eg_ctl) | EG_CTL_DIR); 

			for (ptr = (u_short *) sc->eg_inbuf; len > 0; len -= 2) {
				while (!(inb(sc->eg_stat) & EG_STAT_HRDY))
d631 1
a631 1
				*ptr++ = inw(sc->eg_data);
d647 2
a648 1
			sc->sc_arpcom.ac_if.if_collisions += sc->eg_pcb[8] & 0xf;
d659 7
a665 4
			dprintf(("CRC errors %d\n", *(short*) &sc->eg_pcb[10]));
			dprintf(("alignment errors %d\n", *(short*) &sc->eg_pcb[12]));
			dprintf(("no resources errors %d\n", *(short*) &sc->eg_pcb[14]));
			dprintf(("overrun errors %d\n", *(short*) &sc->eg_pcb[16]));
d676 1
a676 1
	return ret;
d741 1
a741 1
		return 0;
d753 1
a753 1
				return 0;
d770 1
a770 1
	return top;
d787 1
a787 1
		return error;
d843 1
a843 1
	return error;
d875 2
d878 1
a878 1
	outb(sc->eg_ctl, 0);
@


1.15.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.18 2001/04/06 08:04:05 fgsch Exp $	*/
a99 2
	bus_space_tag_t sc_bst;
	bus_space_handle_t sc_bsh;
d101 4
d136 2
a137 2
static __inline void egprintpcb __P((struct eg_softc *));
static __inline void egprintstat __P((u_char));
d148 1
a148 1
static __inline void
d159 1
a159 1
static __inline void
d164 7
a170 7
	    (b & EG_STAT_HCRE)?"HCRE":"",
	    (b & EG_STAT_ACRF)?"ACRF":"",
	    (b & EG_STAT_DIR )?"DIR ":"",
	    (b & EG_STAT_DONE)?"DONE":"",
	    (b & EG_STAT_ASF3)?"ASF3":"",
	    (b & EG_STAT_ASF2)?"ASF2":"",
	    (b & EG_STAT_ASF1)?"ASF1":""));
a177 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d181 2
a182 2
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HCRE) {
			bus_space_write_1(bst, bsh, EG_COMMAND, b);
d188 1
a188 1
	return (1);
a195 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d199 1
a199 2
		if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) !=
		    EG_PCB_NULL) 
d203 3
a205 3
	if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) == statb) 
		return (0);
	return (1);
a211 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d215 2
a216 2
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_ACRF)
			return (0);
d220 1
a220 1
	return (1);
a226 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d230 1
a230 3
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_NULL);
d237 1
a237 1
		if (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HCRE)
d242 1
a242 3
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_DONE);
d247 2
a248 2
		return (1);
	return (0);
a254 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d258 1
a258 3
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_NULL);
d263 1
a263 1
		return (1);
d265 1
a265 1
	sc->eg_pcb[0] = bus_space_read_1(bst, bsh, EG_COMMAND);
d268 1
a268 1
		return (1);
d270 1
a270 1
	sc->eg_pcb[1] = bus_space_read_1(bst, bsh, EG_COMMAND);
d274 1
a274 1
		return (1);
d279 2
a280 2
			return (1);
		sc->eg_pcb[2+i] = bus_space_read_1(bst, bsh, EG_COMMAND);
d283 1
a283 1
		return (1);
d285 2
a286 3
		return (1);
	if ((b = bus_space_read_1(bst, bsh, EG_COMMAND)) != sc->eg_pcb[1] + 2)
	    {
d288 1
a288 1
		return (1);
d291 1
a291 3
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    (bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_PCB_STAT) |
	    EG_PCB_ACCEPT);
d293 1
a293 1
	return (0);
a306 2
	bus_space_tag_t bst = sc->sc_bst = ia->ia_iot;
	bus_space_handle_t bsh;
d311 1
a311 1
		return (0);
d314 4
a317 5
	if (bus_space_map(bst, ia->ia_iobase, EG_IO_PORTS, 0, &bsh)) {
		dprintf(("%s: can't map I/O space\n", sc->sc_dev.dv_xname));
		return (0);
	}
	sc->sc_bsh = bsh;
d320 2
a321 2
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_RESET); 
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
d324 1
a324 2
		if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) ==
		    EG_PCB_NULL) 
d327 1
a327 2
	if ((bus_space_read_1(bst, bsh, EG_STATUS) & EG_PCB_STAT) !=
	    EG_PCB_NULL) {
d329 1
a329 1
		goto lose;
d334 1
a334 1
		goto lose;
d338 1
a338 1
		goto lose;
d344 1
a344 1
		goto lose;
d352 1
a352 7
	bus_space_unmap(bst, bsh, EG_IO_PORTS);
	return (1);

lose:
	sc->sc_bst = sc->sc_bsh = 0;
	bus_space_unmap(bst, bsh, EG_IO_PORTS);
	return (0);
a361 2
	bus_space_tag_t bst = sc->sc_bst = ia->ia_iot;
	bus_space_handle_t bsh;
a363 6
	if (bus_space_map(bst, ia->ia_iobase, EG_IO_PORTS, 0, &bsh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}
	sc->sc_bsh = bsh;

d419 4
a430 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d434 1
a434 1
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_FLSH);
d436 1
a436 1
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_ATTN);
d438 1
a438 1
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
d462 1
a462 1
	bus_space_write_1(bst, bsh, EG_CONTROL, EG_CTL_CMDE);
d501 1
a501 3
	struct eg_softc *sc = ifp->if_softc;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d552 1
a552 2
	bus_space_write_1(bst, bsh, EG_CONTROL,
	    bus_space_read_1(bst, bsh, EG_CONTROL) & ~EG_CTL_DIR); 
d554 3
a556 3
	for (ptr = (u_short *)sc->eg_outbuf; len > 0; len -= 2) {
		bus_space_write_2(bst, bsh, EG_DATA, *ptr++);
		while (!(bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_HRDY))
d567 1
a567 3
	struct eg_softc *sc = arg;
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d572 1
a572 1
	while (bus_space_read_1(bst, bsh, EG_STATUS) & EG_STAT_ACRF) {
d580 4
a583 8
			bus_space_write_1(bst, bsh, EG_CONTROL,
			    bus_space_read_1(bst, bsh, EG_CONTROL) |
			    EG_CTL_DIR); 

			for (ptr = (u_short *)sc->eg_inbuf; len > 0; len -= 2)
			    {
				while (!(bus_space_read_1(bst, bsh,
				    EG_STATUS) & EG_STAT_HRDY))
d585 1
a585 1
				*ptr++ = bus_space_read_2(bst, bsh, EG_DATA);
d601 1
a601 2
			sc->sc_arpcom.ac_if.if_collisions +=
			    sc->eg_pcb[8] & 0xf;
d612 4
a615 7
			dprintf(("CRC errors %d\n", *(short*)&sc->eg_pcb[10]));
			dprintf(("alignment errors %d\n",
			    *(short*)&sc->eg_pcb[12]));
			dprintf(("no resources errors %d\n",
			    *(short*)&sc->eg_pcb[14]));
			dprintf(("overrun errors %d\n",
			    *(short*)&sc->eg_pcb[16]));
d626 1
a626 1
	return (ret);
d691 1
a691 1
		return (0);
d703 1
a703 1
				return (0);
d720 1
a720 1
	return (top);
d737 1
a737 1
		return (error);
d793 1
a793 1
	return (error);
a824 2
	bus_space_tag_t bst = sc->sc_bst;
	bus_space_handle_t bsh = sc->sc_bsh;
d826 1
a826 1
	bus_space_write_1(bst, bsh, EG_CONTROL, 0);
@


1.15.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.15.2.1 2001/05/14 22:24:40 niklas Exp $	*/
d87 4
a450 1
	IFQ_SET_READY(&ifp->if_snd);
d550 1
a550 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
d688 1
d707 3
d719 3
a721 1
	ether_input_mbuf(ifp, m);
@


1.15.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 2
a109 2
int egprobe(struct device *, void *, void *);
void egattach(struct device *, struct device *, void *);
d119 18
a136 18
int egintr(void *);
void eginit(struct eg_softc *);
int egioctl(struct ifnet *, u_long, caddr_t);
void egrecv(struct eg_softc *);
void egstart(struct ifnet *);
void egwatchdog(struct ifnet *);
void egreset(struct eg_softc *);
void egread(struct eg_softc *, caddr_t, int);
struct mbuf *egget(struct eg_softc *, caddr_t, int);
void egstop(struct eg_softc *);

static __inline void egprintpcb(struct eg_softc *);
static __inline void egprintstat(u_char);
static int egoutPCB(struct eg_softc *, u_char);
static int egreadPCBstat(struct eg_softc *, u_char);
static int egreadPCBready(struct eg_softc *);
static int egwritePCB(struct eg_softc *);
static int egreadPCB(struct eg_softc *);
d654 1
a654 1
			dprintf(("CRC errors %d\n", *(short *)&sc->eg_pcb[10]));
d656 1
a656 1
			    *(short *)&sc->eg_pcb[12]));
d658 1
a658 1
			    *(short *)&sc->eg_pcb[14]));
d660 1
a660 1
			    *(short *)&sc->eg_pcb[16]));
@


1.15.2.4
log
@Sync the SMP branch with 3.3
@
text
@a583 2
	if (len > m0->m_pkthdr.len)
		bzero(buffer, len - m0->m_pkthdr.len);
@


1.15.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.15.2.4 2003/03/28 00:38:15 niklas Exp $	*/
d74 1
@


1.15.2.6
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d69 1
@


1.14
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.13 1997/11/07 08:06:47 niklas Exp $	*/
a54 1
#include <net/netisr.h>
@


1.13
log
@$OpenBSD$
@
text
@d1 1
a1 1
/*	$OpenBSD: if_eg.c,v 1.26 1996/05/12 23:52:27 mycroft Exp $	*/
d668 1
a668 1
	if (ifp->if_bpf) {
a669 14

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@


1.12
log
@unused vars, protos
@
text
@d1 1
@


1.11
log
@two bugs pointed out by thorpe
@
text
@d49 1
d136 8
d309 1
a309 1
	if (ia->ia_iobase & ~0x07f0 != 0) {
a362 1
	int i;
a744 1
	struct ifreq *ifr = (struct ifreq *)data;
@


1.10
log
@sync 0521
@
text
@d533 1
d560 1
d565 1
d618 1
a618 1
	return 0;
@


1.9
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 1
a1 1
/*	$NetBSD: if_eg.c,v 1.25 1996/05/07 01:55:17 thorpej Exp $	*/
d72 1
@


1.8
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d1 1
a1 1
/*	$NetBSD: if_eg.c,v 1.24 1996/04/11 22:29:03 cgd Exp $	*/
d128 1
a128 1
void egwatchdog __P((int));
d399 2
a400 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = eg_cd.cd_name;
d478 2
a479 2
		sc->eg_pcb[6] = EG_BUFLEN; /* our buffer size */
		sc->eg_pcb[7] = EG_BUFLEN >> 8;
d492 1
a492 1
	register struct eg_softc *sc = eg_cd.cd_devs[ifp->if_unit];
d731 1
a731 1
	struct eg_softc *sc = eg_cd.cd_devs[ifp->if_unit];
d813 2
a814 2
egwatchdog(unit)
	int     unit;
d816 1
a816 1
	struct eg_softc *sc = eg_cd.cd_devs[unit];
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@a65 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d738 5
a753 17
#endif
#ifdef NS
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;
				
			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			eginit(sc);
			break;
		    }
@


1.6
log
@Fix back wrong patches.
@
text
@d1 1
a1 1
/*	$NetBSD: if_eg.c,v 1.22 1996/01/10 18:21:52 hpeyerl Exp $	*/
d120 6
a125 2
struct cfdriver egcd = {
	NULL, "eg", egprobe, egattach, DV_IFNET, sizeof(struct eg_softc)
d405 1
a405 1
	ifp->if_name = egcd.cd_name;
d419 2
a420 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_NET, egintr,
	    sc, sc->sc_dev.dv_xname);
d497 1
a497 1
	register struct eg_softc *sc = egcd.cd_devs[ifp->if_unit];
d736 1
a736 1
	struct eg_softc *sc = egcd.cd_devs[ifp->if_unit];
d833 1
a833 1
	struct eg_softc *sc = egcd.cd_devs[unit];
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d416 1
a416 1
	    sc);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d416 1
a416 1
	    sc, sc->sc_dev.dv_xname);
@


1.3
log
@update from netbsd
@
text
@d416 1
a416 1
	    sc);
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: if_eg.c,v 1.20 1995/07/24 04:12:45 mycroft Exp $	*/
d31 3
@


1.1
log
@Initial revision
@
text
@d412 2
a413 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_NET,
	    egintr, sc);
d734 1
a734 1
	s = splimp();
d816 1
a816 1
	s = splimp();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
