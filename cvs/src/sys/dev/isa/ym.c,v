head	1.19;
access;
symbols
	OPENBSD_6_0:1.19.0.8
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.18.0.8
	OPENBSD_5_6_BASE:1.18
	OPENBSD_5_5:1.18.0.6
	OPENBSD_5_5_BASE:1.18
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.17.0.12
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.10
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.8
	OPENBSD_5_0:1.17.0.6
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.4
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.2
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.14.0.6
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.8
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.13.0.6
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.13.0.4
	OPENBSD_4_1_BASE:1.13
	OPENBSD_4_0:1.13.0.2
	OPENBSD_4_0_BASE:1.13
	OPENBSD_3_9:1.12.0.12
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.10
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.8
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.6
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.11.0.6
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.4
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.11.0.2
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.11
	UBC:1.9.0.14
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.12
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.10
	OPENBSD_2_8:1.9.0.8
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.5.0.2
	OPENBSD_2_5_BASE:1.5
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.19
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.18;
commitid	uzzBR7hz9ncd4O6G;

1.18
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2010.07.31.11.25.38;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.31.11.00.08;	author ratchov;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.11.21.35;	author jakemsr;	state Exp;
branches;
next	1.14;

1.14
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2006.04.07.22.41.33;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.57;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	99.10.06.12.48.33;	author fgsch;	state Exp;
branches
	1.9.4.1
	1.9.14.1;
next	1.8;

1.8
date	99.08.05.05.32.41;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.07.21.16.19.55;	author provos;	state Exp;
branches;
next	1.6;

1.6
date	99.07.20.16.36.05;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	99.01.24.15.58.54;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	99.01.02.00.02.48;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	98.12.29.09.10.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.11.03.21.15.02;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	98.05.08.18.37.25;	author csapuntz;	state Exp;
branches;
next	;

1.9.4.1
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	;

1.9.14.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.9.14.2;

1.9.14.2
date	2003.05.19.22.08.46;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.19
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/* $OpenBSD: ym.c,v 1.18 2013/05/24 07:58:46 ratchov Exp $ */


/*
 * Copyright (c) 1998 Constantine Sapuntzakis. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "midi.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/ad1848reg.h>
#include <dev/isa/ad1848var.h>
#include <dev/ic/mpuvar.h>
#include <dev/isa/ymvar.h>

/*
 * YAMAHA YMF715x (OPL3 Single-chip Audio System 3; OPL3-SA3)
 * control register description
 *
 * Other ports (SBpro, WSS CODEC, MPU401, OPL3, etc.) are NOT listed here.
 */

/*
 * direct registers
 */

/* offset from the base address */
#define SA3_CTL_INDEX	0	/* Index port (R/W) */
#define SA3_CTL_DATA	1	/* Data register port (R/W) */

#define SA3_CTL_NPORT	2	/* number of ports */

/*
 * indirect registers
 */

#define SA3_PWR_MNG		0x01	/* Power management (R/W) */
#define   SA3_PWR_MNG_ADOWN	0x20	/* Analog Down */
#define   SA3_PWR_MNG_PSV	0x04	/* Power save */
#define   SA3_PWR_MNG_PDN	0x02	/* Power down */
#define   SA3_PWR_MNG_PDX	0x01	/* Oscillation stop */
#define SA3_PWR_MNG_DEFAULT	0x00	/* default value */

#define SA3_SYS_CTL		0x02	/* System control (R/W) */
#define   SA3_SYS_CTL_SBHE	0x80	/* 0: AT-bus, 1: XT-bus */
#define   SA3_SYS_CTL_YMODE	0x30	/* 3D Enhancement mode */
#define     SA3_SYS_CTL_YMODE0	0x00	/* Desktop mode  (speaker 5-12cm) */
#define     SA3_SYS_CTL_YMODE1	0x10	/* Notebook PC mode (1)  (3cm) */
#define     SA3_SYS_CTL_YMODE2	0x20	/* Notebook PC mode (2)  (1.5cm) */
#define     SA3_SYS_CTL_YMODE3	0x30	/* Hi-Fi mode            (16-38cm) */
#define   SA3_SYS_CTL_IDSEL	0x06	/* Specify DSP version of SBPro */
#define     SA3_SYS_CTL_IDSEL0	0x00	/* major 0x03, minor 0x01 */
#define     SA3_SYS_CTL_IDSEL1	0x02	/* major 0x02, minor 0x01 */
#define     SA3_SYS_CTL_IDSEL2	0x04	/* major 0x01, minor 0x05 */
#define     SA3_SYS_CTL_IDSEL3	0x06	/* major 0x00, minor 0x00 */
#define   SA3_SYS_CTL_VZE	0x01	/* ZV */
#define SA3_SYS_CTL_DEFAULT	0x00	/* default value */

#define SA3_IRQ_CONF		0x03	/* Interrupt Channel config (R/W) */
#define   SA3_IRQ_CONF_OPL3_B	0x80	/* OPL3 uses IRQ-B */
#define   SA3_IRQ_CONF_MPU_B	0x40	/* MPU401 uses IRQ-B */
#define   SA3_IRQ_CONF_SB_B	0x20	/* Sound Blaster uses IRQ-B */
#define   SA3_IRQ_CONF_WSS_B	0x10	/* WSS CODEC uses IRQ-B */
#define   SA3_IRQ_CONF_OPL3_A	0x08	/* OPL3 uses IRQ-A */
#define   SA3_IRQ_CONF_MPU_A	0x04	/* MPU401 uses IRQ-A */
#define   SA3_IRQ_CONF_SB_A	0x02	/* Sound Blaster uses IRQ-A */
#define   SA3_IRQ_CONF_WSS_A	0x01	/* WSS CODEC uses IRQ-A */
#define SA3_IRQ_CONF_DEFAULT	(SA3_IRQ_CONF_MPU_B | SA3_IRQ_CONF_SB_B | \
				 SA3_IRQ_CONF_OPL3_A | SA3_IRQ_CONF_WSS_A)

#define SA3_IRQA_STAT		0x04	/* Interrupt (IRQ-A) STATUS (RO) */
#define SA3_IRQB_STAT		0x05	/* Interrupt (IRQ-B) STATUS (RO) */
#define   SA3_IRQ_STAT_MV	0x40	/* Hardware Volume Interrupt */
#define   SA3_IRQ_STAT_OPL3	0x20	/* Internal FM-synthesizer timer */
#define   SA3_IRQ_STAT_MPU	0x10	/* MPU401 Interrupt */
#define   SA3_IRQ_STAT_SB	0x08	/* Sound Blaster Playback Interrupt */
#define   SA3_IRQ_STAT_TI	0x04	/* Timer Flag of CODEC */
#define   SA3_IRQ_STAT_CI	0x02	/* Recording Flag of CODEC */
#define   SA3_IRQ_STAT_PI	0x01	/* Playback Flag of CODEC */

#define SA3_DMA_CONF		0x06	/* DMA configuration (R/W) */
#define   SA3_DMA_CONF_SB_B	0x40	/* Sound Blaster playback uses DMA-B */
#define   SA3_DMA_CONF_WSS_R_B	0x20	/* WSS CODEC recording uses DMA-B */
#define   SA3_DMA_CONF_WSS_P_B	0x10	/* WSS CODEC playback uses DMA-B */
#define   SA3_DMA_CONF_SB_A	0x04	/* Sound Blaster playback uses DMA-A */
#define   SA3_DMA_CONF_WSS_R_A	0x02	/* WSS CODEC recording uses DMA-A */
#define   SA3_DMA_CONF_WSS_P_A	0x01	/* WSS CODEC playback uses DMA-A */
#define SA3_DMA_CONF_DEFAULT	(SA3_DMA_CONF_SB_B | SA3_DMA_CONF_WSS_R_B | \
				 SA3_DMA_CONF_WSS_P_A)

#define SA3_VOL_L		0x07	/* Master Volume Lch (R/W) */
#define SA3_VOL_R		0x08	/* Master Volume Rch (R/W) */
#define   SA3_VOL_MUTE		0x80	/* Mute the channel */
#define   SA3_VOL_MV		0x0f	/* Master Volume bits */
#define     SA3_VOL_MV_0	0x00	/*   0dB (maximum volume) */
#define     SA3_VOL_MV_2	0x01	/*  -2dB */
#define     SA3_VOL_MV_4	0x02	/*  -4dB */
#define     SA3_VOL_MV_6	0x03	/*  -6dB */
#define     SA3_VOL_MV_8	0x04	/*  -8dB */
#define     SA3_VOL_MV_10	0x05	/* -10dB */
#define     SA3_VOL_MV_12	0x06	/* -12dB */
#define     SA3_VOL_MV_14	0x07	/* -14dB (default) */
#define     SA3_VOL_MV_16	0x08	/* -16dB */
#define     SA3_VOL_MV_18	0x09	/* -18dB */
#define     SA3_VOL_MV_20	0x0a	/* -20dB */
#define     SA3_VOL_MV_22	0x0b	/* -22dB */
#define     SA3_VOL_MV_24	0x0c	/* -24dB */
#define     SA3_VOL_MV_26	0x0d	/* -26dB */
#define     SA3_VOL_MV_28	0x0e	/* -28dB */
#define     SA3_VOL_MV_30	0x0f	/* -30dB (minimum volume) */
#define SA3_VOL_DEFAULT		SA3_VOL_MV_14

#define SA3_MIC_VOL		0x09	/* MIC Volume (R/W) */
#define   SA3_MIC_MUTE		0x80	/* Mute Mic Volume */
#define   SA3_MIC_MCV		0x1f	/* Mic volume bits */
#define     SA3_MIC_MCV12	0x00	/* +12.0dB (maximum volume) */
#define     SA3_MIC_MCV10_5	0x01	/* +10.5dB */
#define     SA3_MIC_MCV9	0x02	/*  +9.0dB */
#define     SA3_MIC_MCV7_5	0x03	/*  +7.5dB */
#define     SA3_MIC_MCV6	0x04	/*  +6.0dB */
#define     SA3_MIC_MCV4_5	0x05	/*  +4.5dB */
#define     SA3_MIC_MCV3	0x06	/*  +3.0dB */
#define     SA3_MIC_MCV1_5	0x07	/*  +1.5dB */
#define     SA3_MIC_MCV_0	0x08	/*   0.0dB (default) */
#define     SA3_MIC_MCV_1_5	0x09	/*  -1.5dB */
#define     SA3_MIC_MCV_3_0	0x0a	/*  -3.0dB */
#define     SA3_MIC_MCV_4_5	0x0b	/*  -4.5dB */
#define     SA3_MIC_MCV_6	0x0c	/*  -6.0dB */
#define     SA3_MIC_MCV_7_5	0x0d	/*  -7.5dB */
#define     SA3_MIC_MCV_9	0x0e	/*  -9.0dB */
#define     SA3_MIC_MCV_10_5	0x0f	/* -10.5dB */
#define     SA3_MIC_MCV_12	0x10	/* -12.0dB */
#define     SA3_MIC_MCV_13_5	0x11	/* -13.5dB */
#define     SA3_MIC_MCV_15	0x12	/* -15.0dB */
#define     SA3_MIC_MCV_16_5	0x13	/* -16.5dB */
#define     SA3_MIC_MCV_18	0x14	/* -18.0dB */
#define     SA3_MIC_MCV_19_5	0x15	/* -19.5dB */
#define     SA3_MIC_MCV_21	0x16	/* -21.0dB */
#define     SA3_MIC_MCV_22_5	0x17	/* -22.5dB */
#define     SA3_MIC_MCV_24	0x18	/* -24.0dB */
#define     SA3_MIC_MCV_25_5	0x19	/* -25.5dB */
#define     SA3_MIC_MCV_27	0x1a	/* -27.0dB */
#define     SA3_MIC_MCV_28_5	0x1b	/* -28.5dB */
#define     SA3_MIC_MCV_30	0x1c	/* -30.0dB */
#define     SA3_MIC_MCV_31_5	0x1d	/* -31.5dB */
#define     SA3_MIC_MCV_33	0x1e	/* -33.0dB */
#define     SA3_MIC_MCV_34_5	0x1f	/* -34.5dB (minimum volume) */
#define SA3_MIC_VOL_DEFAULT	(SA3_MIC_MUTE | SA3_MIC_MCV_0)

#define SA3_MISC		0x0a	/* Miscellaneous */
#define   SA3_MISC_VEN		0x80	/* Enable hardware volume control */
#define   SA3_MISC_MCSW		0x10	/* A/D is connected to  0: Rch of Mic,
					   1: loopback of monaural output */
#define   SA3_MISC_MODE		0x08	/* 0: SB mode, 1: WSS mode (RO) */
#define   SA3_MISC_VER		0x07	/* Version of OPL3-SA3 (RO) */
					/*	(4 or 5?) */
/*#define SA3_MISC_DEFAULT	(SA3_MISC_VEN | (4 or 5?)) */

/* WSS DMA Base counters (R/W) used for suspend/resume */
#define SA3_DMA_CNT_PLAY_LOW	0x0b	/* Playback Base Counter (Low) */
#define SA3_DMA_CNT_PLAY_HIGH	0x0c	/* Playback Base Counter (High) */
#define SA3_DMA_CNT_REC_LOW	0x0d	/* Recording Base Counter (Low) */
#define SA3_DMA_CNT_REC_HIGH	0x0e	/* Recording Base Counter (High) */

#define SA3_WSS_INT_SCAN	0x0f	/* WSS Interrupt Scan out/in (R/W) */
#define   SA3_WSS_INT_SCAN_STI	0x04	/* 1: TI = "1" and IRQ active */
#define   SA3_WSS_INT_SCAN_SCI	0x02	/* 1: CI = "1" and IRQ active */
#define   SA3_WSS_INT_SCAN_SPI	0x01	/* 1: PI = "1" and IRQ active */
#define SA3_WSS_INT_DEFAULT	0x00	/* default value */

#define SA3_SB_SCAN		0x10	/* SB Internal State Scan out/in (R/W)*/
#define   SA3_SB_SCAN_SBPDA	0x80	/* Sound Blaster Power Down ack */
#define   SA3_SB_SCAN_SS	0x08	/* Scan Select */
#define   SA3_SB_SCAN_SM	0x04	/* Scan Mode 1: read out, 0: write in */
#define   SA3_SB_SCAN_SE	0x02	/* Scan Enable */
#define   SA3_SB_SCAN_SBPDR	0x01	/* Sound Blaster Power Down Request */
#define SA3_SB_SCAN_DEFAULT	0x00	/* default value */

#define SA3_SB_SCAN_DATA	0x11	/* SB Internal State Scan Data (R/W)*/

#define SA3_DPWRDWN		0x12	/* Digital Partial Power Down (R/W) */
#define   SA3_DPWRDWN_JOY	0x80	/* Joystick power down */
#define   SA3_DPWRDWN_MPU	0x40	/* MPU401 power down */
#define   SA3_DPWRDWN_MCLKO	0x20	/* Master Clock disable */
#define   SA3_DPWRDWN_FM	0x10	/* FM (OPL3) power down */
#define   SA3_DPWRDWN_WSS_R	0x08	/* WSS recording power down */
#define   SA3_DPWRDWN_WSS_P	0x04	/* WSS playback power down */
#define   SA3_DPWRDWN_SB	0x02	/* Sound Blaster power down */
#define   SA3_DPWRDWN_PNP	0x01	/* PnP power down */
#define SA3_DPWRDWN_DEFAULT	0x00	/* default value */

#define SA3_APWRDWN		0x13	/* Analog Partial Power Down (R/W) */
#define   SA3_APWRDWN_FMDAC	0x10	/* FMDAC for OPL3 power down */ 
#define   SA3_APWRDWN_AD	0x08	/* A/D for WSS recording power down */
#define   SA3_APWRDWN_DA	0x04	/* D/A for WSS playback power down */
#define   SA3_APWRDWN_SBDAC	0x02	/* D/A for SB power down */
#define   SA3_APWRDWN_WIDE	0x01	/* Wide Stereo power down */
#define SA3_APWRDWN_DEFAULT	0x00	/* default value */

#define SA3_3D_WIDE		0x14	/* 3D Enhanced control (WIDE) (R/W) */
#define   SA3_3D_WIDE_WIDER	0x70	/* Rch of wide 3D enhanced control */
#define   SA3_3D_WIDE_WIDEL	0x07	/* Lch of wide 3D enhanced control */
#define SA3_3D_WIDE_DEFAULT	0x00	/* default value */

#define SA3_3D_BASS		0x15	/* 3D Enhanced control (BASS) (R/W) */
#define   SA3_3D_BASS_BASSR	0x70	/* Rch of bass 3D enhanced control */
#define   SA3_3D_BASS_BASSL	0x07	/* Lch of bass 3D enhanced control */
#define SA3_3D_BASS_DEFAULT	0x00	/* default value */

#define SA3_3D_TREBLE		0x16	/* 3D Enhanced control (TREBLE) (R/W) */
#define   SA3_3D_TREBLE_TRER	0x70	/* Rch of treble 3D enhanced control */
#define   SA3_3D_TREBLE_TREL	0x07	/* Lch of treble 3D enhanced control */
#define SA3_3D_TREBLE_DEFAULT	0x00	/* default value */

/* common to the 3D enhance registers */
#define   SA3_3D_BITS		0x07
#define   SA3_3D_LSHIFT		0
#define   SA3_3D_RSHIFT		4

#define SA3_HVOL_INTR_CNF	0x17	/* Hardware Volume Intr Channel (R/W) */
#define   SA3_HVOL_INTR_CNF_B	0x20	/* Hardware Volume uses IRQ-B */
#define   SA3_HVOL_INTR_CNF_A	0x10	/* Hardware Volume uses IRQ-A */
#define SA3_HVOL_INTR_CNF_DEFAULT	0x00

#define SA3_MULTI_STAT		0x18	/* Multi-purpose Select Pin Stat (RO) */
#define   SA3_MULTI_STAT_SEL	0x70	/* State of SEL2-0 pins */

int ym_getdev(void *, struct audio_device *);
int ym_mixer_set_port(void *, mixer_ctrl_t *);
int ym_mixer_get_port(void *, mixer_ctrl_t *);
int ym_query_devinfo(void *, mixer_devinfo_t *);
int ym_intr(void *);

static void ym_mute(struct ym_softc *, int, int);
static void ym_set_master_gain(struct ym_softc *, struct ad1848_volume *);
static void ym_set_mic_gain(struct ym_softc *, int);
static void ym_set_3d(struct ym_softc *, mixer_ctrl_t *,
	struct ad1848_volume *, int);

struct audio_hw_if ym_hw_if = {
	ad1848_open,
	ad1848_close,
	NULL,
	ad1848_query_encoding,
	ad1848_set_params,
	ad1848_round_blocksize,
	ad1848_commit_settings,
	NULL,
	NULL,
	NULL,
	NULL,
	ad1848_halt_output,
	ad1848_halt_input,
	NULL,
	ym_getdev,
	NULL,
	ym_mixer_set_port,
	ym_mixer_get_port,
	ym_query_devinfo,
	ad1848_malloc,
	ad1848_free,
	ad1848_round,
	ad1848_mappage,
	ad1848_get_props,
	ad1848_trigger_output,
	ad1848_trigger_input,
	NULL
};


struct cfdriver ym_cd = {
	NULL, "ym", DV_DULL
};

struct audio_device ym_device = {
	"ym,ad1848",
	"",
	"ym"
};

static __inline int ym_read(struct ym_softc *, int);
static __inline void ym_write(struct ym_softc *, int, int);

#if NMIDI > 0
int	ym_mpu401_open(void *, int, void (*iintr)(void *, int),
	    void (*ointr)(void *), void *arg);
void	ym_mpu401_close(void *);
int	ym_mpu401_output(void *, int);
void	ym_mpu401_getinfo(void *, struct midi_info *);

struct midi_hw_if ym_mpu401_hw_if = {
	ym_mpu401_open,
	ym_mpu401_close,
	ym_mpu401_output,
	0,		/* flush */
	ym_mpu401_getinfo,
	0,		/* ioctl */
};
#endif

int
ym_intr(v)
	void   *v;
{
#if NMIDI > 0
	struct ym_softc *sc = v;

	if ( /* XXX && */ sc->sc_hasmpu)
		mpu_intr(&sc->sc_mpu_sc);
#endif
	return ad1848_intr(v);
}

void
ym_attach(sc)
	struct ym_softc *sc;

{
	struct ad1848_volume vol_mid = {220, 220};
#if NMIDI > 0
	struct midi_hw_if *mhw = &ym_mpu401_hw_if;
#endif

	sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->ym_irq,
	    IST_EDGE, IPL_AUDIO | IPL_MPSAFE,
	    ym_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);

	ad1848_attach(&sc->sc_ad1848);
	printf("\n");
	sc->sc_ad1848.parent = sc;

	/* Establish chip in well known mode */
	ym_set_master_gain(sc, &vol_mid);
	ym_set_mic_gain(sc, 0);
	sc->master_mute = 0;
	ym_mute(sc, SA3_VOL_L, sc->master_mute);
	ym_mute(sc, SA3_VOL_R, sc->master_mute);

	sc->mic_mute = 1;
	ym_mute(sc, SA3_MIC_VOL, sc->mic_mute);

#if NMIDI > 0
	sc->sc_hasmpu = 0;
	if (sc->sc_mpu_sc.iobase) {
		sc->sc_mpu_sc.iot = sc->sc_iot;
		if (mpu_find(&sc->sc_mpu_sc)) {
			sc->sc_hasmpu = 1;
			mhw = &ym_mpu401_hw_if;
		}
	}
	midi_attach_mi(mhw, sc, &sc->sc_dev);
#endif

	audio_attach_mi(&ym_hw_if, &sc->sc_ad1848, &sc->sc_dev);
}

static __inline int
ym_read(sc, reg)
	struct ym_softc *sc;
	int     reg;
{
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,
	    (reg & 0xff));
	return (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA));
}

static __inline void
ym_write(sc, reg, data)
	struct ym_softc *sc;
	int     reg;
	int     data;
{
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_INDEX,
	    (reg & 0xff));
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, SA3_CTL_DATA,
	    (data & 0xff));
}



int
ym_getdev(addr, retp)
	void   *addr;
	struct audio_device *retp;
{
	*retp = ym_device;
	return 0;
}


static ad1848_devmap_t mappings[] = {
	{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },
	{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },
	{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },
	{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },
	{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },
	{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },
	{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },
	{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },
	{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },
	{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },
	{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },
	{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },
	{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },
	{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1 }
};

#define NUMMAP	(sizeof(mappings) / sizeof(mappings[0]))


static void
ym_mute(sc, left_reg, mute)
	struct ym_softc *sc;
	int     left_reg;
	int     mute;
{
	u_int8_t reg;

	reg = ym_read(sc, left_reg);
	if (mute)
		ym_write(sc, left_reg, reg | 0x80);
	else
		ym_write(sc, left_reg, reg & ~0x80);
}

static void
ym_set_master_gain(sc, vol)
	struct ym_softc *sc;
	struct ad1848_volume *vol;
{
	u_int   atten;

	sc->master_gain = *vol;

	atten = ((AUDIO_MAX_GAIN - vol->left) * (SA3_VOL_MV + 1)) /
	   (AUDIO_MAX_GAIN + 1);

	ym_write(sc, SA3_VOL_L, (ym_read(sc, SA3_VOL_L) & ~SA3_VOL_MV) | atten);

	atten = ((AUDIO_MAX_GAIN - vol->right) * (SA3_VOL_MV + 1)) /
	   (AUDIO_MAX_GAIN + 1);

	ym_write(sc, SA3_VOL_R, (ym_read(sc, SA3_VOL_R) & ~SA3_VOL_MV) | atten);
}

static void
ym_set_mic_gain(sc, vol)
	struct ym_softc *sc;
	int vol;
{
	u_int   atten;

	sc->mic_gain = vol;

	atten = ((AUDIO_MAX_GAIN - vol) * (SA3_MIC_MCV + 1)) /
	    (AUDIO_MAX_GAIN + 1);

	ym_write(sc, SA3_MIC_VOL,
	    (ym_read(sc, SA3_MIC_VOL) & ~SA3_MIC_MCV) | atten);
}

static void
ym_set_3d(sc, cp, val, reg)
	struct ym_softc *sc;
	mixer_ctrl_t *cp;
	struct ad1848_volume *val;
	int reg;
{
	u_int8_t e;

	ad1848_to_vol(cp, val);

	e = (val->left * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /
		(AUDIO_MAX_GAIN + 1) << SA3_3D_LSHIFT |
	    (val->right * (SA3_3D_BITS + 1) + (SA3_3D_BITS + 1) / 2) /
		(AUDIO_MAX_GAIN + 1) << SA3_3D_RSHIFT;

	ym_write(sc, reg, e);
}

int
ym_mixer_set_port(addr, cp)
	void   *addr;
	mixer_ctrl_t *cp;
{
	struct ad1848_softc *ac = addr;
	struct ym_softc *sc = ac->parent;
	struct ad1848_volume vol;
	int     error = ad1848_mixer_set_port(ac, mappings, NUMMAP, cp);

	if (error != ENXIO)
		return (error);

	error = 0;

	switch (cp->dev) {
	case YM_OUTPUT_LVL:
		ad1848_to_vol(cp, &vol);
		ym_set_master_gain(sc, &vol);
		break;

	case YM_OUTPUT_MUTE:
		sc->master_mute = (cp->un.ord != 0);
		ym_mute(sc, SA3_VOL_L, sc->master_mute);
		ym_mute(sc, SA3_VOL_R, sc->master_mute);
		break;

	case YM_MIC_LVL:
		if (cp->un.value.num_channels != 1)
			error = EINVAL;
		else
			ym_set_mic_gain(sc,
			    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
		break;

	case YM_MASTER_EQMODE:
		sc->sc_eqmode = cp->un.ord & SA3_SYS_CTL_YMODE;
		ym_write(sc, SA3_SYS_CTL, (ym_read(sc, SA3_SYS_CTL) &
		    ~SA3_SYS_CTL_YMODE) | sc->sc_eqmode);
		break;

	case YM_MASTER_TREBLE:
		ym_set_3d(sc, cp, &sc->sc_treble, SA3_3D_TREBLE);
		break;

	case YM_MASTER_BASS:
		ym_set_3d(sc, cp, &sc->sc_bass, SA3_3D_BASS);
		break;

	case YM_MASTER_WIDE:
		ym_set_3d(sc, cp, &sc->sc_wide, SA3_3D_WIDE);
		break;

	case YM_MIC_MUTE:
		sc->mic_mute = (cp->un.ord != 0);
		ym_mute(sc, SA3_MIC_VOL, sc->mic_mute);
		break;

	default:
		return ENXIO;
		/* NOTREACHED */
	}

	return (error);
}

int
ym_mixer_get_port(addr, cp)
	void   *addr;
	mixer_ctrl_t *cp;
{
	struct ad1848_softc *ac = addr;
	struct ym_softc *sc = ac->parent;

	int     error = ad1848_mixer_get_port(ac, mappings, NUMMAP, cp);

	if (error != ENXIO)
		return (error);

	error = 0;

	switch (cp->dev) {
	case YM_OUTPUT_LVL:
		ad1848_from_vol(cp, &sc->master_gain);
		break;

	case YM_OUTPUT_MUTE:
		cp->un.ord = sc->master_mute;
		break;

	case YM_MIC_LVL:
		if (cp->un.value.num_channels != 1)
			error = EINVAL;
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = sc->mic_gain;	
		break;

	case YM_MASTER_EQMODE:
		cp->un.ord = sc->sc_eqmode;
		break;

	case YM_MASTER_TREBLE:
		ad1848_from_vol(cp, &sc->sc_treble);
		break;

	case YM_MASTER_BASS:
		ad1848_from_vol(cp, &sc->sc_bass);
		break;

	case YM_MASTER_WIDE:
		ad1848_from_vol(cp, &sc->sc_wide);
		break;

	case YM_MIC_MUTE:
		cp->un.ord = sc->mic_mute;
		break;

	default:
		error = ENXIO;
		break;
	}

	return (error);
}

static char *mixer_classes[] = {
	AudioCinputs, AudioCrecord, AudioCoutputs, AudioCmonitor,
	AudioCequalization
};

int
ym_query_devinfo(addr, dip)
	void   *addr;
	mixer_devinfo_t *dip;
{
	static char *mixer_port_names[] = { AudioNmidi, AudioNcd, AudioNdac,
		AudioNline, AudioNspeaker, AudioNmicrophone, AudioNmonitor
	};

	dip->next = dip->prev = AUDIO_MIXER_LAST;

	switch (dip->index) {
	case YM_INPUT_CLASS:	/* input class descriptor */
	case YM_OUTPUT_CLASS:
	case YM_MONITOR_CLASS:
	case YM_RECORD_CLASS:
	case YM_EQ_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = dip->index;
		strlcpy(dip->label.name,
		    mixer_classes[dip->index - YM_INPUT_CLASS],
		    sizeof dip->label.name);
		break;

	case YM_MIDI_LVL:
	case YM_CD_LVL:
	case YM_DAC_LVL:
	case YM_LINE_LVL:
	case YM_SPEAKER_LVL:
	case YM_MIC_LVL:
	case YM_MONITOR_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		if (dip->index == YM_MONITOR_LVL)
			dip->mixer_class = YM_MONITOR_CLASS;
		else
			dip->mixer_class = YM_INPUT_CLASS;

		dip->next = dip->index + 7;

		strlcpy(dip->label.name,
		    mixer_port_names[dip->index - YM_MIDI_LVL],
		    sizeof dip->label.name);

		if (dip->index == YM_SPEAKER_LVL ||
		    dip->index == YM_MIC_LVL)
			dip->un.v.num_channels = 1;
		else
			dip->un.v.num_channels = 2;

		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case YM_MIDI_MUTE:
	case YM_CD_MUTE:
	case YM_DAC_MUTE:
	case YM_LINE_MUTE:
	case YM_SPEAKER_MUTE:
	case YM_MIC_MUTE:
	case YM_MONITOR_MUTE:
		if (dip->index == YM_MONITOR_MUTE)
			dip->mixer_class = YM_MONITOR_CLASS;
		else
			dip->mixer_class = YM_INPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = dip->index - 7;
mute:
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;


	case YM_OUTPUT_LVL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = YM_OUTPUT_CLASS;
		dip->next = YM_OUTPUT_MUTE;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case YM_OUTPUT_MUTE:
		dip->mixer_class = YM_OUTPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = YM_OUTPUT_LVL;
		goto mute;

	case YM_REC_LVL:	/* record level */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = YM_RECORD_CLASS;
		dip->next = YM_RECORD_SOURCE;
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;


	case YM_RECORD_SOURCE:
		dip->mixer_class = YM_RECORD_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = YM_REC_LVL;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->un.e.num_mem = 4;
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = MIC_IN_PORT;
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = LINE_IN_PORT;
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = DAC_IN_PORT;
		strlcpy(dip->un.e.member[3].label.name, AudioNcd,
		    sizeof dip->un.e.member[3].label.name);
		dip->un.e.member[3].ord = AUX1_IN_PORT;
		break;

	case YM_MASTER_EQMODE:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = YM_EQ_CLASS;
		strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
		strlcpy(dip->un.v.units.name, AudioNmode,
		    sizeof dip->un.v.units.name);
		dip->un.e.num_mem = 4;
		strlcpy(dip->un.e.member[0].label.name, AudioNdesktop,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = SA3_SYS_CTL_YMODE0;
		strlcpy(dip->un.e.member[1].label.name, AudioNlaptop,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = SA3_SYS_CTL_YMODE1;
		strlcpy(dip->un.e.member[2].label.name, AudioNsubnote,
		    sizeof dip->un.e.member[2].label.name);
		dip->un.e.member[2].ord = SA3_SYS_CTL_YMODE2;
		strlcpy(dip->un.e.member[3].label.name, AudioNhifi,
		    sizeof dip->un.e.member[3].label.name);
		dip->un.e.member[3].ord = SA3_SYS_CTL_YMODE3;
		break;

	case YM_MASTER_TREBLE:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = YM_EQ_CLASS;
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
		break;

	case YM_MASTER_BASS:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = YM_EQ_CLASS;
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
		break;

	case YM_MASTER_WIDE:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = YM_EQ_CLASS;
		strlcpy(dip->label.name, AudioNsurround,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNsurround,
		    sizeof dip->un.v.units.name);
		break;

	default:
		return ENXIO;
		/* NOTREACHED */
	}

	return 0;
}
#if NMIDI > 0

#define YMMPU(a) (&((struct ym_softc *)addr)->sc_mpu_sc)

int
ym_mpu401_open(addr, flags, iintr, ointr, arg)
	void   *addr;
	int     flags;
	void    (*iintr)(void *, int);
	void    (*ointr)(void *);
	void   *arg;
{
	return mpu_open(YMMPU(addr), flags, iintr, ointr, arg);
}

int
ym_mpu401_output(addr, d)
	void   *addr;
	int     d;
{
	return mpu_output(YMMPU(addr), d);
}

void
ym_mpu401_close(addr)
	void   *addr;
{
	mpu_close(YMMPU(addr));
}

void
ym_mpu401_getinfo(addr, mi)
	void   *addr;
	struct midi_info *mi;
{
	mi->name = "YM MPU-401 UART";
	mi->props = 0;
}
#endif
@


1.18
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.17 2010/07/31 11:25:38 ratchov Exp $ */
a37 1
#include <sys/proc.h>
@


1.17
log
@add SA3_XXX macros removed by mistake with opl, but used by ym mixer
from mk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.16 2010/07/31 11:00:08 ratchov Exp $ */
d365 3
a367 2
	sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->ym_irq, IST_EDGE,
	    IPL_AUDIO, ym_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);
@


1.16
log
@unbreak ym.c, opl3sa3reg.h doesn't exist any longer
noticed by mk@@
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.15 2010/06/30 11:21:35 jakemsr Exp $ */
d56 212
@


1.15
log
@* use audio(9)'s DMA trigger methods instead of the init/start
  methods.  the AD1848 DMA engine runs continuously and doesn't
  need to be started/stopped or otherwise manipulated for each
  block.  makes the driver a bit more efficient.
* allow "Mode 2" capable chips such as the CS4231 to work in "Mode 1"
  when there is only one DMA channel, instead of forcing it into
  "Mode 2", which expects two DMA channels.  allows recording to
  work for "Mode 2" capable devices when there is only one DMA
  channel.
* service both playback and recording interrupts in full-duplex
  mode, instead of only playback interrupts.  allows "Mode 2"
  capable chips to work in full-duplex mode.
* fix checks for sample rate/format recalibration completion.  gets
  rid of busy loops that briefly "hang" the kernel when the device is
  opened and/or reconfigured.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.14 2008/04/21 00:32:42 jakemsr Exp $ */
a53 1
#include <dev/ic/opl3sa3reg.h>
@


1.14
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.13 2006/04/07 22:41:33 jsg Exp $ */
d78 6
a83 6
	ad1848_dma_init_output,
	ad1848_dma_init_input,
	ad1848_dma_output,
	ad1848_dma_input,
	ad1848_halt_out_dma,
	ad1848_halt_in_dma,
d95 2
a96 2
	NULL,
	NULL,
@


1.13
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.12 2003/04/27 11:22:53 ho Exp $ */
d95 1
@


1.12
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.11 2002/03/14 03:16:05 millert Exp $ */
d124 1
@


1.11
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.10 2002/03/14 01:26:57 millert Exp $ */
d456 3
a458 2
		strcpy(dip->label.name,
		    mixer_classes[dip->index - YM_INPUT_CLASS]);
d476 3
a478 1
		strcpy(dip->label.name, mixer_port_names[dip->index - YM_MIDI_LVL]);
d486 2
a487 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d504 1
a504 1
		strcpy(dip->label.name, AudioNmute);
d506 2
a507 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d509 2
a510 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d519 1
a519 1
		strcpy(dip->label.name, AudioNmaster);
d521 2
a522 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d535 1
a535 1
		strcpy(dip->label.name, AudioNrecord);
d537 2
a538 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d546 1
a546 1
		strcpy(dip->label.name, AudioNsource);
d548 2
a549 1
		strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d551 2
a552 1
		strcpy(dip->un.e.member[1].label.name, AudioNline);
d554 2
a555 1
		strcpy(dip->un.e.member[2].label.name, AudioNdac);
d557 2
a558 1
		strcpy(dip->un.e.member[3].label.name, AudioNcd);
d565 3
a567 2
		strcpy(dip->label.name, AudioNmode);
		strcpy(dip->un.v.units.name, AudioNmode);
d569 2
a570 1
		strcpy(dip->un.e.member[0].label.name, AudioNdesktop);
d572 2
a573 1
		strcpy(dip->un.e.member[1].label.name, AudioNlaptop);
d575 2
a576 1
		strcpy(dip->un.e.member[2].label.name, AudioNsubnote);
d578 2
a579 1
		strcpy(dip->un.e.member[3].label.name, AudioNhifi);
d586 1
a586 1
		strcpy(dip->label.name, AudioNtreble);
d588 2
a589 1
		strcpy(dip->un.v.units.name, AudioNtreble);
d595 1
a595 1
		strcpy(dip->label.name, AudioNbass);
d597 2
a598 1
		strcpy(dip->un.v.units.name, AudioNbass);
d604 2
a605 1
		strcpy(dip->label.name, AudioNsurround);
d607 2
a608 1
		strcpy(dip->un.v.units.name, AudioNsurround);
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.9 1999/10/06 12:48:33 fgsch Exp $ */
d114 2
a115 2
int	ym_mpu401_open __P((void *, int, void (*iintr)(void *, int),
	    void (*ointr)(void *), void *arg));
@


1.9
log
@Add support for bass, treble, surround and mode under equalization class.
Modify some code for simplicity and remove unused one; from NetBSD.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.8 1999/08/05 05:32:41 deraadt Exp $ */
d58 11
a68 11
int ym_getdev __P((void *, struct audio_device *));
int ym_mixer_set_port __P((void *, mixer_ctrl_t *));
int ym_mixer_get_port __P((void *, mixer_ctrl_t *));
int ym_query_devinfo __P((void *, mixer_devinfo_t *));
int ym_intr __P((void *));

static void ym_mute __P((struct ym_softc *, int, int));
static void ym_set_master_gain __P((struct ym_softc *, struct ad1848_volume *));
static void ym_set_mic_gain __P((struct ym_softc *, int));
static void ym_set_3d __P((struct ym_softc *, mixer_ctrl_t *,
	struct ad1848_volume *, int));
d110 2
a111 2
static __inline int ym_read __P((struct ym_softc *, int));
static __inline void ym_write __P((struct ym_softc *, int, int));
d114 5
a118 5
int	ym_mpu401_open __P((void *, int, void (*iintr) __P((void *, int)),
	    void (*ointr) __P((void *)), void *arg));
void	ym_mpu401_close __P((void *));
int	ym_mpu401_output __P((void *, int));
void	ym_mpu401_getinfo __P((void *, struct midi_info *));
d605 2
a606 2
	void    (*iintr) __P((void *, int));
	void    (*ointr) __P((void *));
@


1.9.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.9 1999/10/06 12:48:33 fgsch Exp $ */
d58 11
a68 11
int ym_getdev(void *, struct audio_device *);
int ym_mixer_set_port(void *, mixer_ctrl_t *);
int ym_mixer_get_port(void *, mixer_ctrl_t *);
int ym_query_devinfo(void *, mixer_devinfo_t *);
int ym_intr(void *);

static void ym_mute(struct ym_softc *, int, int);
static void ym_set_master_gain(struct ym_softc *, struct ad1848_volume *);
static void ym_set_mic_gain(struct ym_softc *, int);
static void ym_set_3d(struct ym_softc *, mixer_ctrl_t *,
	struct ad1848_volume *, int);
d110 2
a111 2
static __inline int ym_read(struct ym_softc *, int);
static __inline void ym_write(struct ym_softc *, int, int);
d114 5
a118 5
int	ym_mpu401_open(void *, int, void (*iintr)(void *, int),
	    void (*ointr)(void *), void *arg);
void	ym_mpu401_close(void *);
int	ym_mpu401_output(void *, int);
void	ym_mpu401_getinfo(void *, struct midi_info *);
d605 2
a606 2
	void    (*iintr)(void *, int);
	void    (*ointr)(void *);
@


1.9.14.2
log
@sync
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d456 2
a457 3
		strlcpy(dip->label.name,
		    mixer_classes[dip->index - YM_INPUT_CLASS],
		    sizeof dip->label.name);
d475 1
a475 3
		strlcpy(dip->label.name,
		    mixer_port_names[dip->index - YM_MIDI_LVL],
		    sizeof dip->label.name);
d483 1
a483 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d500 1
a500 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d502 1
a502 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d504 1
a504 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d513 1
a513 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d515 1
a515 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d528 1
a528 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d530 1
a530 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d538 1
a538 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d540 1
a540 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d542 1
a542 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d544 1
a544 2
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
		    sizeof dip->un.e.member[2].label.name);
d546 1
a546 2
		strlcpy(dip->un.e.member[3].label.name, AudioNcd,
		    sizeof dip->un.e.member[3].label.name);
d553 2
a554 3
		strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
		strlcpy(dip->un.v.units.name, AudioNmode,
		    sizeof dip->un.v.units.name);
d556 1
a556 2
		strlcpy(dip->un.e.member[0].label.name, AudioNdesktop,
		    sizeof dip->un.e.member[0].label.name);
d558 1
a558 2
		strlcpy(dip->un.e.member[1].label.name, AudioNlaptop,
		    sizeof dip->un.e.member[1].label.name);
d560 1
a560 2
		strlcpy(dip->un.e.member[2].label.name, AudioNsubnote,
		    sizeof dip->un.e.member[2].label.name);
d562 1
a562 2
		strlcpy(dip->un.e.member[3].label.name, AudioNhifi,
		    sizeof dip->un.e.member[3].label.name);
d569 1
a569 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d571 1
a571 2
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
d577 1
a577 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d579 1
a579 2
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
d585 1
a585 2
		strlcpy(dip->label.name, AudioNsurround,
		    sizeof dip->label.name);
d587 1
a587 2
		strlcpy(dip->un.v.units.name, AudioNsurround,
		    sizeof dip->un.v.units.name);
@


1.9.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d58 11
a68 11
int ym_getdev(void *, struct audio_device *);
int ym_mixer_set_port(void *, mixer_ctrl_t *);
int ym_mixer_get_port(void *, mixer_ctrl_t *);
int ym_query_devinfo(void *, mixer_devinfo_t *);
int ym_intr(void *);

static void ym_mute(struct ym_softc *, int, int);
static void ym_set_master_gain(struct ym_softc *, struct ad1848_volume *);
static void ym_set_mic_gain(struct ym_softc *, int);
static void ym_set_3d(struct ym_softc *, mixer_ctrl_t *,
	struct ad1848_volume *, int);
d110 2
a111 2
static __inline int ym_read(struct ym_softc *, int);
static __inline void ym_write(struct ym_softc *, int, int);
d114 5
a118 5
int	ym_mpu401_open(void *, int, void (*iintr)(void *, int),
	    void (*ointr)(void *), void *arg);
void	ym_mpu401_close(void *);
int	ym_mpu401_output(void *, int);
void	ym_mpu401_getinfo(void *, struct midi_info *);
d605 2
a606 2
	void    (*iintr)(void *, int);
	void    (*ointr)(void *);
@


1.9.4.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.9.4.1 2002/03/28 12:11:36 niklas Exp $ */
d456 2
a457 3
		strlcpy(dip->label.name,
		    mixer_classes[dip->index - YM_INPUT_CLASS],
		    sizeof dip->label.name);
d475 1
a475 3
		strlcpy(dip->label.name,
		    mixer_port_names[dip->index - YM_MIDI_LVL],
		    sizeof dip->label.name);
d483 1
a483 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d500 1
a500 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d502 1
a502 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d504 1
a504 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d513 1
a513 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d515 1
a515 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d528 1
a528 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d530 1
a530 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d538 1
a538 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d540 1
a540 2
		strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
		    sizeof dip->un.e.member[0].label.name);
d542 1
a542 2
		strlcpy(dip->un.e.member[1].label.name, AudioNline,
		    sizeof dip->un.e.member[1].label.name);
d544 1
a544 2
		strlcpy(dip->un.e.member[2].label.name, AudioNdac,
		    sizeof dip->un.e.member[2].label.name);
d546 1
a546 2
		strlcpy(dip->un.e.member[3].label.name, AudioNcd,
		    sizeof dip->un.e.member[3].label.name);
d553 2
a554 3
		strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
		strlcpy(dip->un.v.units.name, AudioNmode,
		    sizeof dip->un.v.units.name);
d556 1
a556 2
		strlcpy(dip->un.e.member[0].label.name, AudioNdesktop,
		    sizeof dip->un.e.member[0].label.name);
d558 1
a558 2
		strlcpy(dip->un.e.member[1].label.name, AudioNlaptop,
		    sizeof dip->un.e.member[1].label.name);
d560 1
a560 2
		strlcpy(dip->un.e.member[2].label.name, AudioNsubnote,
		    sizeof dip->un.e.member[2].label.name);
d562 1
a562 2
		strlcpy(dip->un.e.member[3].label.name, AudioNhifi,
		    sizeof dip->un.e.member[3].label.name);
d569 1
a569 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d571 1
a571 2
		strlcpy(dip->un.v.units.name, AudioNtreble,
		    sizeof dip->un.v.units.name);
d577 1
a577 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d579 1
a579 2
		strlcpy(dip->un.v.units.name, AudioNbass,
		    sizeof dip->un.v.units.name);
d585 1
a585 2
		strlcpy(dip->label.name, AudioNsurround,
		    sizeof dip->label.name);
d587 1
a587 2
		strlcpy(dip->un.v.units.name, AudioNsurround,
		    sizeof dip->un.v.units.name);
@


1.8
log
@mv isa/mpu401var.h ic/mpuvar.h
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.7 1999/07/21 16:19:55 provos Exp $ */
d54 1
a54 1
#include <dev/ic/opl3sa3.h>
d66 3
a68 3
static void ym_set_mic_gain __P((struct ym_softc *, struct ad1848_volume *));


a147 1
	struct ad1848_volume vol_0 = {0, 0};
d161 1
a161 1
	ym_set_mic_gain(sc, &vol_0);
d163 2
a164 2
	ym_mute(sc, SA3_LCH, sc->master_mute);
	ym_mute(sc, SA3_RCH, sc->master_mute);
d167 1
a167 1
	ym_mute(sc, SA3_MIC, sc->mic_mute);
d189 3
a191 3
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, 0x1d);
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, (reg & 0xff));
	return (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, 1));
d200 4
a203 3
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, 0x1d);
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, (reg & 0xff));
	bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 1, (data & 0xff));
d235 1
a235 1
static int nummap = sizeof(mappings) / sizeof(mappings[0]);
d244 1
a244 1
	u_char  reg;
d246 2
a247 2
	if (mute) {
		reg = ym_read(sc, left_reg);
d249 1
a249 2
	} else {
		reg = ym_read(sc, left_reg);
a250 1
	}
a252 3
#define MIC_ATTEN_BITS 0x1f
#define MASTER_ATTEN_BITS 0x0f

a257 1
	u_char  reg;
d262 2
a263 1
	atten = ((AUDIO_MAX_GAIN - vol->left) * MASTER_ATTEN_BITS) / AUDIO_MAX_GAIN;
d265 1
a265 1
	reg = ym_read(sc, SA3_LCH);
d267 2
a268 2
	reg &= ~(MASTER_ATTEN_BITS);
	reg |= atten;
d270 2
a271 1
	ym_write(sc, SA3_LCH, reg);
d273 6
a278 1
	atten = ((AUDIO_MAX_GAIN - vol->right) * MASTER_ATTEN_BITS) / AUDIO_MAX_GAIN;
d280 1
a280 2
	reg = ym_read(sc, SA3_RCH) & ~(MASTER_ATTEN_BITS);
	reg |= atten;
d282 5
a286 1
	ym_write(sc, SA3_RCH, reg);
d290 1
a290 1
ym_set_mic_gain(sc, vol)
d292 3
a294 1
	struct ad1848_volume *vol;
d296 1
a296 4
	u_char  reg;
	u_int   atten;

	sc->mic_gain = *vol;
d298 1
a298 1
	atten = ((AUDIO_MAX_GAIN - vol->left) * MIC_ATTEN_BITS) / AUDIO_MAX_GAIN;
d300 4
a303 2
	reg = ym_read(sc, SA3_MIC) & ~(MIC_ATTEN_BITS);
	reg |= atten;
d305 1
a305 1
	ym_write(sc, SA3_MIC, reg);
d316 1
a316 1
	int     error = ad1848_mixer_set_port(ac, mappings, nummap, cp);
d331 2
a332 2
		ym_mute(sc, SA3_LCH, sc->master_mute);
		ym_mute(sc, SA3_RCH, sc->master_mute);
d338 14
d353 6
a358 2
		ad1848_to_vol(cp, &vol);
		ym_set_mic_gain(sc, &vol);
d363 1
a363 1
		ym_mute(sc, SA3_MIC, sc->mic_mute);
d382 1
a382 1
	int     error = ad1848_mixer_get_port(ac, mappings, nummap, cp);
d401 14
d416 2
a417 1
		ad1848_from_vol(cp, &sc->mic_gain);
d432 4
a435 2
static char *mixer_classes[] = {AudioCinputs, AudioCrecord, AudioCoutputs,
AudioCmonitor};
d442 3
a444 4
	static char *mixer_port_names[] = {AudioNmidi, AudioNcd, AudioNdac,
		AudioNline, AudioNspeaker,
		AudioNmicrophone,
	AudioNmonitor};
d453 1
d548 40
@


1.7
log
@make it compile without midi.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.6 1999/07/20 16:36:05 deraadt Exp $ */
d55 1
a55 1
#include <dev/isa/mpu401var.h>
@


1.6
log
@first cut at isapnp and ym mpu
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.5 1999/01/24 15:58:54 mickey Exp $ */
d133 1
a135 1
#if NMIDI > 0
@


1.5
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.4 1999/01/02 00:02:48 niklas Exp $ */
d6 1
a6 1
 * 
d30 1
a30 1

d47 1
d55 1
d58 5
a62 5

int	ym_getdev __P((void *, struct audio_device *));
int	ym_mixer_set_port __P((void *, mixer_ctrl_t *));
int	ym_mixer_get_port __P((void *, mixer_ctrl_t *));
int	ym_query_devinfo __P((void *, mixer_devinfo_t *));
d101 1
a101 1
        NULL, "ym", DV_DULL
d113 29
d144 1
a144 1
    struct ym_softc *sc;
d147 34
a180 19
  struct ad1848_volume vol_mid = {220, 220};
  struct ad1848_volume vol_0   = {0, 0};
  
  sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->ym_irq, IST_EDGE, IPL_AUDIO,
			    ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);

  ad1848_attach(&sc->sc_ad1848);
  printf("\n");
  sc->sc_ad1848.parent = sc;

  /* Establish chip in well known mode */
  ym_set_master_gain(sc, &vol_mid);
  ym_set_mic_gain(sc, &vol_0);
  sc->master_mute = 0;
  ym_mute(sc, SA3_LCH, sc->master_mute);
  ym_mute(sc, SA3_RCH, sc->master_mute);

  sc->mic_mute = 1;
  ym_mute(sc, SA3_MIC, sc->mic_mute);
d182 1
a182 1
  audio_attach_mi(&ym_hw_if, &sc->sc_ad1848, &sc->sc_dev);
d187 2
a188 2
    struct ym_softc *sc;
    int reg;
d190 3
a192 3
  bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, 0x1d);
  bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, (reg & 0xff));
  return (bus_space_read_1(sc->sc_iot, sc->sc_controlioh, 1));
d197 7
a203 7
    struct ym_softc *sc;
    int reg;
    int data;
{
  bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, 0x1d);
  bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 0, (reg & 0xff));
  bus_space_write_1(sc->sc_iot, sc->sc_controlioh, 1, (data & 0xff));
d210 2
a211 2
    void *addr;
    struct audio_device *retp;
d213 2
a214 2
    *retp = ym_device;
    return 0;
d219 14
a232 14
{ YM_MIDI_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },
{ YM_CD_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },
{ YM_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },
{ YM_LINE_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL },
{ YM_SPEAKER_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },
{ YM_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL },
{ YM_MIDI_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },
{ YM_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },
{ YM_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },
{ YM_LINE_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL },
{ YM_SPEAKER_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL },
{ YM_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL },
{ YM_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },
{ YM_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}
d240 5
a244 3
  struct ym_softc *sc;
  int left_reg;
  int mute;
d246 7
a252 10
{
  u_char reg;

  if (mute) {
    reg = ym_read(sc, left_reg);
    ym_write (sc, left_reg, reg | 0x80);
  } else {
    reg = ym_read(sc, left_reg);
    ym_write (sc, left_reg, reg & ~0x80);
  }
a257 1

d260 2
a261 2
  struct ym_softc *sc;
  struct ad1848_volume *vol;
d263 2
a264 2
  u_char reg;
  u_int  atten;
d266 1
a266 1
  sc->master_gain = *vol;
d268 1
a268 1
  atten = ((AUDIO_MAX_GAIN - vol->left) * MASTER_ATTEN_BITS)/AUDIO_MAX_GAIN;
d270 1
a270 1
  reg = ym_read(sc, SA3_LCH);
d272 2
a273 2
  reg &= ~(MASTER_ATTEN_BITS);
  reg |= atten;
d275 1
a275 1
  ym_write (sc, SA3_LCH, reg);
d277 1
a277 1
  atten = ((AUDIO_MAX_GAIN - vol->right) * MASTER_ATTEN_BITS)/AUDIO_MAX_GAIN;
d279 2
a280 2
  reg = ym_read(sc, SA3_RCH) & ~(MASTER_ATTEN_BITS);
  reg |= atten;
d282 1
a282 1
  ym_write (sc, SA3_RCH, reg);
d287 2
a288 2
  struct ym_softc *sc;
  struct ad1848_volume *vol;
d290 2
a291 2
  u_char reg;
  u_int  atten;
d293 1
a293 1
  sc->mic_gain = *vol;
d295 1
a295 1
  atten = ((AUDIO_MAX_GAIN - vol->left) * MIC_ATTEN_BITS)/AUDIO_MAX_GAIN;
d297 2
a298 2
  reg = ym_read(sc, SA3_MIC) & ~(MIC_ATTEN_BITS);
  reg |= atten;
d300 1
a300 1
  ym_write (sc, SA3_MIC, reg);
d305 2
a306 2
    void *addr;
    mixer_ctrl_t *cp;
d308 41
a348 41
    struct ad1848_softc *ac = addr;
    struct ym_softc *sc = ac->parent;
    struct ad1848_volume vol;
    int error = ad1848_mixer_set_port(ac, mappings, nummap, cp);
    
    if (error != ENXIO)
      return (error);

    error = 0;

    switch (cp->dev) {
    case YM_OUTPUT_LVL:
      ad1848_to_vol(cp, &vol);
      ym_set_master_gain(sc, &vol);
      break;

    case YM_OUTPUT_MUTE:
      sc->master_mute = (cp->un.ord != 0);
      ym_mute(sc, SA3_LCH, sc->master_mute);
      ym_mute(sc, SA3_RCH, sc->master_mute);
      break;

    case YM_MIC_LVL:
      if (cp->un.value.num_channels != 1)
	error = EINVAL;

      ad1848_to_vol(cp, &vol);
      ym_set_mic_gain(sc, &vol);      
      break;

    case YM_MIC_MUTE:
      sc->mic_mute = (cp->un.ord != 0);
      ym_mute(sc, SA3_MIC, sc->mic_mute);
      break;

    default:
	    return ENXIO;
	    /*NOTREACHED*/
    }
    
    return (error);
d353 2
a354 2
    void *addr;
    mixer_ctrl_t *cp;
d356 2
a357 2
    struct ad1848_softc *ac = addr;
    struct ym_softc *sc = ac->parent;
d359 1
a359 1
    int error = ad1848_mixer_get_port(ac, mappings, nummap, cp);
d361 2
a362 2
    if (error != ENXIO)
      return (error);
d364 1
a364 1
    error = 0;
d366 4
a369 4
    switch (cp->dev) {
    case YM_OUTPUT_LVL:
      ad1848_from_vol(cp, &sc->master_gain);
      break;
d371 3
a373 3
    case YM_OUTPUT_MUTE:
      cp->un.ord = sc->master_mute;
      break;
d375 3
a377 3
    case YM_MIC_LVL:
      if (cp->un.value.num_channels != 1)
	error = EINVAL;
d379 2
a380 2
      ad1848_from_vol(cp, &sc->mic_gain);
      break;
d382 3
a384 3
    case YM_MIC_MUTE:
      cp->un.ord = sc->mic_mute;
      break;
d386 4
a389 4
    default:
	error = ENXIO;
	break;
    }
d391 1
a391 1
    return(error);
d394 2
a395 2
static char *mixer_classes[] = { AudioCinputs, AudioCrecord, AudioCoutputs,
				 AudioCmonitor };
d399 2
a400 2
    void *addr;
    mixer_devinfo_t *dip;
d402 57
a458 57
  static char *mixer_port_names[] = { AudioNmidi, AudioNcd, AudioNdac,
				       AudioNline, AudioNspeaker, 
				       AudioNmicrophone, 
                                       AudioNmonitor};

    dip->next = dip->prev = AUDIO_MIXER_LAST;

    switch(dip->index) {
    case YM_INPUT_CLASS:			/* input class descriptor */
    case YM_OUTPUT_CLASS:
    case YM_MONITOR_CLASS:
    case YM_RECORD_CLASS:
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = dip->index;
	strcpy(dip->label.name, 
	       mixer_classes[dip->index - YM_INPUT_CLASS]);
	break;

    case YM_MIDI_LVL:
    case YM_CD_LVL:
    case YM_DAC_LVL:
    case YM_LINE_LVL: 
    case YM_SPEAKER_LVL:
    case YM_MIC_LVL:
    case YM_MONITOR_LVL:
	dip->type = AUDIO_MIXER_VALUE;
	if (dip->index == YM_MONITOR_LVL)
	  dip->mixer_class = YM_MONITOR_CLASS;
	else
	  dip->mixer_class = YM_INPUT_CLASS;

	dip->next = dip->index + 7;

	strcpy(dip->label.name,mixer_port_names[dip->index - YM_MIDI_LVL]);

	if (dip->index == YM_SPEAKER_LVL ||
	    dip->index == YM_MIC_LVL)
	  dip->un.v.num_channels = 1;
	else
	  dip->un.v.num_channels = 2;

	strcpy(dip->un.v.units.name, AudioNvolume);
	break;

    case YM_MIDI_MUTE:
    case YM_CD_MUTE:
    case YM_DAC_MUTE:
    case YM_LINE_MUTE:
    case YM_SPEAKER_MUTE:
    case YM_MIC_MUTE:
    case YM_MONITOR_MUTE:
	if (dip->index == YM_MONITOR_MUTE)
	  dip->mixer_class = YM_MONITOR_CLASS;
	else
	  dip->mixer_class = YM_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = dip->index - 7;
d460 54
a513 54
	strcpy(dip->label.name, AudioNmute);
	dip->un.e.num_mem = 2;
	strcpy(dip->un.e.member[0].label.name, AudioNoff);
	dip->un.e.member[0].ord = 0;
	strcpy(dip->un.e.member[1].label.name, AudioNon);
	dip->un.e.member[1].ord = 1;
	break;


    case YM_OUTPUT_LVL:
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = YM_OUTPUT_CLASS;
	dip->next = YM_OUTPUT_MUTE;
	strcpy(dip->label.name, AudioNmaster);
	dip->un.v.num_channels = 2;
	strcpy(dip->un.v.units.name, AudioNvolume);
	break;

    case YM_OUTPUT_MUTE:
	dip->mixer_class = YM_OUTPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = YM_OUTPUT_LVL;
	goto mute;
      
    case YM_REC_LVL:	/* record level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = YM_RECORD_CLASS;
	dip->next = YM_RECORD_SOURCE;
	strcpy(dip->label.name, AudioNrecord);
	dip->un.v.num_channels = 2;
	strcpy(dip->un.v.units.name, AudioNvolume);
	break;
	

    case YM_RECORD_SOURCE:
	dip->mixer_class = YM_RECORD_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = YM_REC_LVL;
	strcpy(dip->label.name, AudioNsource);
	dip->un.e.num_mem = 4;
	strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
	dip->un.e.member[0].ord = MIC_IN_PORT;
	strcpy(dip->un.e.member[1].label.name, AudioNline);
	dip->un.e.member[1].ord = LINE_IN_PORT;
	strcpy(dip->un.e.member[2].label.name, AudioNdac);
	dip->un.e.member[2].ord = DAC_IN_PORT;
	strcpy(dip->un.e.member[3].label.name, AudioNcd);
	dip->un.e.member[3].ord = AUX1_IN_PORT;
	break;

    default:
	return ENXIO;
	/*NOTREACHED*/
    }
d515 39
a553 1
    return 0;
d555 1
@


1.4
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.3 1998/12/29 09:10:30 deraadt Exp $ */
a43 1
#include <machine/pio.h>
@


1.3
log
@work around some ugly glitches
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.2 1998/11/03 21:15:02 downsj Exp $ */
d137 1
a137 1
  audio_attach_mi(&ym_hw_if, 0, &sc->sc_ad1848, &sc->sc_dev);
@


1.2
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/* $OpenBSD: ym.c,v 1.1 1998/05/08 18:37:25 csapuntz Exp $ */
d124 1
@


1.1
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/* $OpenBSD: $ */
d94 2
@

