head	1.25;
access;
symbols
	OPENBSD_6_2:1.25.0.2
	OPENBSD_6_2_BASE:1.25
	OPENBSD_6_1:1.24.0.18
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.24.0.14
	OPENBSD_6_0_BASE:1.24
	OPENBSD_5_9:1.24.0.4
	OPENBSD_5_9_BASE:1.24
	OPENBSD_5_8:1.24.0.12
	OPENBSD_5_8_BASE:1.24
	OPENBSD_5_7:1.24.0.10
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.24.0.8
	OPENBSD_5_6_BASE:1.24
	OPENBSD_5_5:1.24.0.6
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.24.0.2
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.22.0.14
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.12
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.10
	OPENBSD_5_0:1.22.0.8
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.6
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.21.0.16
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.12
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.21.0.10
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.6
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.2
	UBC_BASE:1.16
	OPENBSD_3_0:1.15.0.2
	OPENBSD_3_0_BASE:1.15
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.4
	OPENBSD_2_8:1.14.0.2
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.11.0.2
	OPENBSD_2_7_BASE:1.11
	SMP:1.10.0.4
	SMP_BASE:1.10
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.2
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.25
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.24;
commitid	uRv5pa9QDlZaYgwD;

1.24
date	2013.07.14.15.18.36;	author kettenis;	state Exp;
branches;
next	1.23;

1.23
date	2013.03.08.18.35.46;	author miod;	state Exp;
branches;
next	1.22;

1.22
date	2009.07.23.15.58.37;	author miod;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.12.01.38.34;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.27.17.01.31;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2000.07.03.19.02.47;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	2000.07.03.02.59.24;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.06.20.17.56.24;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.08.05.50.53;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	99.08.11.12.02.07;	author niklas;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	99.07.11.16.22.21;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	99.03.31.05.48.25;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	99.02.15.06.59.58;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.01.03.10.05.47;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	98.12.31.09.17.44;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.12.27.00.27.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.12.19.15.58.24;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.08.02.50;	author fgsch;	state Exp;
branches;
next	;

1.10.4.1
date	2001.05.14.22.24.38;	author niklas;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.10.4.3;

1.10.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.10.4.4;

1.10.4.4
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.10.4.5;

1.10.4.5
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	;

1.16.2.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.25
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: i82365_isasubr.c,v 1.24 2013/07/14 15:18:36 kettenis Exp $	*/
/*	$NetBSD: i82365_isasubr.c,v 1.1 1998/06/07 18:28:31 sommerfe Exp $  */

/*
 * Copyright (c) 1998 Bill Sommerfeld.  All rights reserved.
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <dev/ic/i82365reg.h>
#include <dev/ic/i82365var.h>
#include <dev/isa/i82365_isavar.h>

/*****************************************************************************
 * Configurable parameters.
 *****************************************************************************/

/*
 * Default I/O allocation range.  If both are set to non-zero, these
 * values will be used instead.  Otherwise, the code attempts to probe
 * the bus width.
 */

#ifndef PCIC_ISA_ALLOC_IOBASE
#define	PCIC_ISA_ALLOC_IOBASE		0
#endif

#ifndef PCIC_ISA_ALLOC_IOSIZE
#define	PCIC_ISA_ALLOC_IOSIZE		0
#endif

int	pcic_isa_alloc_iobase = PCIC_ISA_ALLOC_IOBASE;
int	pcic_isa_alloc_iosize = PCIC_ISA_ALLOC_IOSIZE;

/*
 * I am well aware that some of later irqs below are not for real, but there
 * is a way to deal with that in the search loop.  For beauty's sake I want
 * this list to be a permutation of 0..15.
 */
char	pcic_isa_intr_list[] = {
	3, 4, 14, 9, 5, 12, 10, 11, 15, 13, 7, 1, 6, 2, 0, 8
};

struct pcic_ranges pcic_isa_addr[] = {
	{ 0x340, 0x030 },
	{ 0x300, 0x030 },
	{ 0x390, 0x020 },
	{ 0x400, 0xbff },
	{ 0, 0 },		/* terminator */
};


/*****************************************************************************
 * End of configurable parameters.
 *****************************************************************************/

#ifdef PCICISADEBUG
int	pcicsubr_debug = 1 /* XXX */ ;
#define	DPRINTF(arg) if (pcicsubr_debug) printf arg;
#else
#define	DPRINTF(arg)
#endif

static int pcic_intr_seen;

void
pcic_isa_bus_width_probe(sc, iot, ioh, base, length)
	struct pcic_softc *sc;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t base;
	u_int32_t length;
{
	bus_space_handle_t ioh_high;
	int i, iobuswidth, tmp1, tmp2;

	/*
	 * figure out how wide the isa bus is.  Do this by checking if the
	 * pcic controller is mirrored 0x400 above where we expect it to be.
	 *
	 * XXX some hardware doesn't seem to grok addresses in 0x400
	 * range-- apparently missing a bit or more of address lines.
	 * (e.g. CIRRUS_PD672X with Linksys EthernetCard ne2000 clone
	 * in TI TravelMate 5000 -- not clear which is at fault)
	 * 
	 * Add a kludge to detect 10 bit wide buses and deal with them,
	 * and also a config file option to override the probe.
	 */
	iobuswidth = 12;

	/* Map i/o space. */
	if (bus_space_map(iot, base + 0x400, length, 0, &ioh_high)) {
		printf("%s: can't map high i/o space\n", sc->dev.dv_xname);
		return;
	}

	for (i = 0; i < PCIC_NSLOTS; i++) {
		if (sc->handle[i].flags & PCIC_FLAG_SOCKETP) {
			/*
			 * read the ident flags from the normal space and
			 * from the mirror, and compare them
			 */
			bus_space_write_1(iot, ioh, PCIC_REG_INDEX,
			    sc->handle[i].sock + PCIC_IDENT);
			tmp1 = bus_space_read_1(iot, ioh, PCIC_REG_DATA);

			bus_space_write_1(iot, ioh_high, PCIC_REG_INDEX,
			    sc->handle[i].sock + PCIC_IDENT);
			tmp2 = bus_space_read_1(iot, ioh_high, PCIC_REG_DATA);

			if (tmp1 == tmp2)
				iobuswidth = 10;
		}
	}

	bus_space_unmap(iot, ioh_high, length);

	sc->ranges = pcic_isa_addr;
	if (iobuswidth == 10) {
		sc->iobase = 0x000;
		sc->iosize = 0x400;
	} else {
		sc->iobase = 0x0000;
		sc->iosize = 0x1000;
	}

	DPRINTF(("%s: bus_space_alloc range 0x%04lx-0x%04lx (probed)\n",
	    sc->dev.dv_xname, (long) sc->iobase,
	    (long) sc->iobase + sc->iosize));

	if (pcic_isa_alloc_iobase && pcic_isa_alloc_iosize) {
		sc->iobase = pcic_isa_alloc_iobase;
		sc->iosize = pcic_isa_alloc_iosize;

		DPRINTF(("%s: bus_space_alloc range 0x%04lx-0x%04lx "
		    "(config override)\n", sc->dev.dv_xname, (long) sc->iobase,
		    (long) sc->iobase + sc->iosize));
	}
}


void *
pcic_isa_chip_intr_establish(pch, pf, ipl, fct, arg, xname)
	pcmcia_chipset_handle_t pch;
	struct pcmcia_function *pf;
	int ipl;
	int (*fct)(void *);
	void *arg;
	char *xname;
{
	struct pcic_handle *h = (struct pcic_handle *)pch;
	struct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);
	isa_chipset_tag_t ic = sc->intr_est;
	int irq, ist, reg;

	if (pf->cfe->flags & PCMCIA_CFE_IRQLEVEL)
		ist = IST_LEVEL;
	else if (pf->cfe->flags & PCMCIA_CFE_IRQPULSE)
		ist = IST_PULSE;
	else
		ist = IST_EDGE;

	irq = pcic_intr_find(sc, ist);
	if (!irq)
		return (NULL);

	h->ih_irq = irq;
	reg = pcic_read(h, PCIC_INTR);
	reg &= ~(PCIC_INTR_IRQ_MASK | PCIC_INTR_ENABLE);
	pcic_write(h, PCIC_INTR, reg | irq);

	return isa_intr_establish(ic, irq, ist, ipl, fct, arg,
	    h->pcmcia->dv_xname);
}

void 
pcic_isa_chip_intr_disestablish(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
{
	struct pcic_handle *h = (struct pcic_handle *) pch;
	struct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);
	isa_chipset_tag_t ic = sc->intr_est;
	int reg;

	h->ih_irq = 0;

	isa_intr_disestablish(ic, ih);

	reg = pcic_read(h, PCIC_INTR);
	reg &= ~(PCIC_INTR_IRQ_MASK | PCIC_INTR_ENABLE);
	pcic_write(h, PCIC_INTR, reg);
}

const char *
pcic_isa_chip_intr_string(pch, ih)
	pcmcia_chipset_handle_t pch;
	void *ih;
{
	struct pcic_handle *h = (struct pcic_handle *)pch;
	static char irqstr[64];

	if (ih == NULL)
		snprintf(irqstr, sizeof(irqstr), "couldn't establish interrupt");
	else
		snprintf(irqstr, sizeof(irqstr), "irq %d", h->ih_irq);
	return (irqstr);
}

int
pcic_intr_probe(v)
	void *v;
{
	pcic_intr_seen = 1;
	return (1);
}

/*
 * Try to find a working interrupt, first by searching for a unique
 * irq that is known to work, verified by tickling the pcic, then
 * by searching for a shareable irq known to work.  If the pcic does
 * not allow tickling we then fallback to the same strategy but without
 * tickling just assuming the first usable irq found works.
 */
int
pcic_intr_find(sc, ist)
	struct pcic_softc *sc;
	int ist;
{
	struct pcic_handle *ph = &sc->handle[0];
	isa_chipset_tag_t ic = sc->intr_est;
	int i, tickle, check, irq, chosen_irq = 0, csc_touched = 0;
	void *ih;
	u_int8_t saved_csc_intr;

	/*
	 * First time, look for entirely free interrupts, last
	 * time accept shareable ones.
	 */
	for (tickle = 1; tickle >= 0; tickle--) {
		if (tickle)
			/*
			 * Remember card status change interrupt
			 * configuration.
			 */
			saved_csc_intr = pcic_read(ph, PCIC_CSC_INTR);

		for (check = 2; check; check--) {

			/* Walk over all possible interrupts. */
			for (i = 0; i < 16; i++) {
				irq = pcic_isa_intr_list[i];

				if (((1 << irq) &
				     PCIC_CSC_INTR_IRQ_VALIDMASK) == 0)
					continue;

				if (isa_intr_check(ic, irq, ist) < check)
					continue;

				if (!tickle) {
					chosen_irq = irq;
					goto out;
				}

				/*
				 * Prepare for an interrupt tickle.
				 * As this can be called from an
				 * IPL_TTY context (the card status
				 * change interrupt) we need to do
				 * higher.
				 */
				ih = isa_intr_establish(ic, irq, ist,
				    IPL_VM | IPL_MPSAFE, pcic_intr_probe,
				    0, sc->dev.dv_xname);
				if (ih == NULL)
					continue;
				pcic_intr_seen = 0;
				pcic_write(ph, PCIC_CSC_INTR,
				    (saved_csc_intr & ~PCIC_CSC_INTR_IRQ_MASK)
				    | PCIC_CSC_INTR_CD_ENABLE
				    | (irq << PCIC_CSC_INTR_IRQ_SHIFT));
				csc_touched = 1;

				/* Teehee, you tickle me! ;-) */
				pcic_write(ph, PCIC_CARD_DETECT,
				    pcic_read(ph, PCIC_CARD_DETECT) |
				    PCIC_CARD_DETECT_SW_INTR);

				/*
				 * Delay for 10 ms and then shut the
				 * probe off.  That should be plenty
				 * of time for the interrupt to be
				 * handled.
				 */
				delay(10000);

				/* Acknowledge the interrupt. */
				pcic_read(ph, PCIC_CSC);

				isa_intr_disestablish(ic, ih);

				if (pcic_intr_seen) {
					chosen_irq = irq;
					goto out;
				}
			}
		}
	}

out:
	if (csc_touched)
		/* Restore card detection bit. */
		pcic_write(ph, PCIC_CSC_INTR, saved_csc_intr);
	return (chosen_irq);
}
@


1.24
log
@The "probe" interrupt handler is mpsafe; mark it as such.

ok matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.23 2013/03/08 18:35:46 miod Exp $	*/
a34 1
#include <sys/types.h>
@


1.23
log
@In pcic_intr_find(), pass a correct device name to isa_intr_establish(), so
that we can get reasonable debug or panic messages when things go wrong.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.22 2009/07/23 15:58:37 miod Exp $	*/
d315 3
a317 2
				ih = isa_intr_establish(ic, irq, ist, IPL_VM,
				    pcic_intr_probe, 0, sc->dev.dv_xname);
@


1.22
log
@What gets allocated with bus_space_map() needs to be released with
bus_space_unmap(), not bus_space_free(). Fortunately this file is only
used on i386 where bus_space_free() simply invokes bus_space_unmap().
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.21 2006/03/12 01:38:34 brad Exp $	*/
d316 1
a316 1
				    pcic_intr_probe, 0, NULL);
@


1.21
log
@IPL_IMP -> IPL_VM
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.20 2005/01/27 17:03:23 millert Exp $	*/
d158 1
a158 1
	bus_space_free(iot, ioh_high, length);
@


1.20
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.18 2004/01/09 21:32:24 brad Exp $	*/
d315 1
a315 1
				ih = isa_intr_establish(ic, irq, ist, IPL_IMP,
@


1.19
log
@Make pcic_isa_chip_intr_establish() silent; irq printing will move
to the forthcoming pcmcia_intr_string().
@
text
@d237 15
@


1.18
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.17 2002/03/14 01:26:56 millert Exp $	*/
a196 1
	void *ih;
d214 1
a214 1
	ih = isa_intr_establish(ic, irq, ist, ipl, fct, arg,
a215 9
	if (!ih)
		return (NULL);

	if (xname) {
		printf("%s: irq %d", xname, irq);
		if (*xname)
			printf("\n");
	}
	return (ih);
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.16 2001/11/06 19:53:19 miod Exp $	*/
a40 2

#include <uvm/uvm_extern.h>
@


1.16
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.15 2001/08/17 21:52:16 deraadt Exp $	*/
d191 1
a191 1
	int (*fct) __P((void *));
@


1.16.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.16 2001/11/06 19:53:19 miod Exp $	*/
d191 1
a191 1
	int (*fct)(void *);
@


1.15
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.14 2000/07/03 19:02:47 niklas Exp $	*/
d42 1
a42 1
#include <vm/vm.h>
@


1.14
log
@Carefully reset pcic register; ok @@aaron
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.13 2000/07/03 02:59:24 aaron Exp $	*/
d187 1
a187 1
pcic_isa_chip_intr_establish(pch, pf, ipl, fct, arg)
d193 1
d222 5
a226 1
	printf(" irq %d", irq);
@


1.13
log
@From NetBSD:

- Fix an incorrect interrupt sharing type.
- Always clear PCIC_INTR_ENABLE; it doesn't do what one might think.
- Eliminate stray interrupts during the IRQ probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.12 2000/06/20 17:56:24 millert Exp $	*/
d266 1
a266 1
	int i, tickle, check, irq, chosen_irq = 0;
d316 1
a340 4

			if (tickle)
				/* Restore card detection bit. */
				pcic_write(ph, PCIC_CSC_INTR, saved_csc_intr);
d345 3
@


1.12
log
@Avoid using I/O port 0x370 since this is used by onboard audio on
some laptops.  Only seems to cause problems with some card, notably
wavelan and aironet.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.11 2000/04/08 05:50:53 aaron Exp $	*/
d197 1
a197 1
	int irq, ist;
d205 1
a205 1
		ist = IST_LEVEL;
d211 5
a220 4
	h->ih_irq = irq;
	pcic_write(h, PCIC_INTR,
	    (pcic_read(h, PCIC_INTR) & ~PCIC_INTR_IRQ_MASK) | irq);

d237 2
a241 2

	isa_intr_disestablish(ic, ih);
@


1.11
log
@Initial check-in for support of 32-bit CardBus PC Cards; from NetBSD. On many
machines, this code needs the new PCIBIOS* options enabled in the kernel config
file to work, but your mileage may vary. Included is a working 3c575 driver for
3Com 10/100 CardBus PC Card NICs (tested only with the 'C' revision). The 3c575
is the pccard version of the PCI EtherLink XL cards, and thus the xl driver has
been split into /sys/dev/ic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.10 1999/08/11 12:02:07 niklas Exp $	*/
d89 1
a89 1
	{ 0x340, 0x040 },
@


1.10
log
@New pcmcia irq prober that really tries to ensure the irq will work
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.9 1999/07/26 05:43:16 deraadt Exp $	*/
d195 2
a196 1
	isa_chipset_tag_t ic = h->sc->intr_est;
d207 1
a207 1
	irq = pcic_intr_find(h->sc, ist);
d230 2
a231 1
	isa_chipset_tag_t ic = h->sc->intr_est;
@


1.10.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.14 2000/07/03 19:02:47 niklas Exp $	*/
d89 1
a89 1
	{ 0x340, 0x030 },
d195 2
a196 3
	struct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);
	isa_chipset_tag_t ic = sc->intr_est;
	int irq, ist, reg;
d204 1
a204 1
		ist = IST_EDGE;
d206 1
a206 1
	irq = pcic_intr_find(sc, ist);
a209 5
	h->ih_irq = irq;
	reg = pcic_read(h, PCIC_INTR);
	reg &= ~(PCIC_INTR_IRQ_MASK | PCIC_INTR_ENABLE);
	pcic_write(h, PCIC_INTR, reg | irq);

d215 4
d229 1
a229 2
	struct pcic_softc *sc = (struct pcic_softc *)(h->ph_parent);
	isa_chipset_tag_t ic = sc->intr_est;
a233 2
	isa_intr_disestablish(ic, ih);

d237 2
d263 1
a263 1
	int i, tickle, check, irq, chosen_irq = 0, csc_touched = 0;
a312 1
				csc_touched = 1;
d337 4
a344 3
	if (csc_touched)
		/* Restore card detection bit. */
		pcic_write(ph, PCIC_CSC_INTR, saved_csc_intr);
@


1.10.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.10.4.1 2001/05/14 22:24:38 niklas Exp $	*/
d187 1
a187 1
pcic_isa_chip_intr_establish(pch, pf, ipl, fct, arg, xname)
a192 1
	char *xname;
d221 1
a221 5
	if (xname) {
		printf("%s: irq %d", xname, irq);
		if (*xname)
			printf("\n");
	}
@


1.10.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d42 1
a42 1
#include <uvm/uvm_extern.h>
@


1.10.4.4
log
@Merge in -current from about a week ago
@
text
@d191 1
a191 1
	int (*fct)(void *);
@


1.10.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d42 2
@


1.9
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.8 1999/07/11 16:22:21 niklas Exp $	*/
d79 9
a95 11
/*
 * Default IRQ allocation bitmask.  This defines the range of allowable
 * IRQs for PCMCIA slots.  Useful if order of probing would screw up other
 * devices, or if PCIC hardware/cards have trouble with certain interrupt
 * lines.
 */
char	pcic_isa_intr_list[] = {
	3, 4, 14, 9, 5, 12, 10, 11, 15, 13, 7
};
int	npcic_isa_intr_list =
	sizeof(pcic_isa_intr_list) / sizeof(pcic_isa_intr_list[0]);
d108 4
a111 1
void pcic_isa_bus_width_probe (sc, iot, ioh, base, length)
d194 1
a194 1
	struct pcic_handle *h = (struct pcic_handle *) pch;
a197 1
	int i, reg;
d206 2
a207 12
	for (i = 0; i < npcic_isa_intr_list; i++)
		if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) == 2)
			goto found;
	for (i = 0; i < npcic_isa_intr_list; i++)
		if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) == 1)
			goto found;
	return (NULL);

found:
	irq = pcic_isa_intr_list[i];
	if ((ih = isa_intr_establish(ic, irq, ist, ipl,
	    fct, arg, h->pcmcia->dv_xname)) == NULL)
d210 4
a213 4
	reg = pcic_read(h, PCIC_INTR);
	reg &= ~PCIC_INTR_IRQ_MASK;
	reg |= irq;
	pcic_write(h, PCIC_INTR, reg);
d216 3
d239 107
@


1.8
log
@Extend the pcmcia I/O space to what it should be
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.7 1999/03/31 05:48:25 deraadt Exp $	*/
d65 1
a65 2
 * the bus width.  Systems with 10 address bits should use 0x300 and 0xff.
 * Systems with 12 address bits (most) should use 0x400 and 0xbff.
d79 7
a92 1

a95 1

a98 9
struct pcic_ranges pcic_isa_addr[] = {
	{ 0x340, 0x040 },
	{ 0x300, 0x030 },
	{ 0x390, 0x020 },
	{ 0x400, 0xbff },
	{ 0, 0 },		/* terminator */
};


d123 8
a131 1

a145 1

a160 15
	/*
	 * XXX mycroft recommends I/O space range 0x400-0xfff .  I should put
	 * this in a header somewhere
	 */

	/*
	 * XXX some hardware doesn't seem to grok addresses in 0x400 range--
	 * apparently missing a bit or more of address lines. (e.g.
	 * CIRRUS_PD672X with Linksys EthernetCard ne2000 clone in TI
	 * TravelMate 5000--not clear which is at fault)
	 * 
	 * Add a kludge to detect 10 bit wide buses and deal with them,
	 * and also a config file option to override the probe.
	 */

a171 1

d226 1
a226 3

	printf("%s: card irq %d\n", h->pcmcia->dv_xname, irq);

@


1.7
log
@because of RAMDISK not having pms0, move irq 12 to later on; fgsch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.6 1999/02/15 06:59:58 fgsch Exp $	*/
d177 2
a178 2
		sc->iobase = 0x300;
		sc->iosize = 0x0ff;
d180 2
a181 16
#if 0
		/*
		 * This is what we'd like to use, but...
		 */
		sc->iobase = 0x400;
		sc->iosize = 0xbff;
#else
		/*
		 * ...the above bus width probe doesn't always work.
		 * So, experimentation has shown the following range
		 * to not lose on systems that 0x300-0x3ff loses on
		 * (e.g. the NEC Versa 6030X).
		 */
		sc->iobase = 0x330;
		sc->iosize = 0x0cf;
#endif
@


1.6
log
@Change 3rd range in pcic_ranges to use from 0x390 to 0x3b0.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.5 1999/01/03 10:05:47 deraadt Exp $	*/
d89 1
a89 1
	3, 4, 12, 14, 9, 5, 10, 11, 15, 13, 7
@


1.5
log
@provide pcmcia IO bus mapper with list of blocks where it should
preferentially map; idea by me, code by niklas
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.4 1998/12/31 09:17:44 deraadt Exp $	*/
d98 1
a98 1
	{ 0x390, 0x010 },
@


1.4
log
@semantic change: prefer unshared intr, settle for level shared. this will still fail in some cases
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.3 1998/12/27 00:27:18 deraadt Exp $	*/
d95 9
d175 1
@


1.3
log
@new priority mechanism for pcmcia interrupt allocation, ie. "best effort"
for machines low on interrupts. work by fgsch, and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.2 1998/12/19 15:58:24 fgsch Exp $	*/
d229 1
a229 1
		if (isa_intr_check(ic, pcic_isa_intr_list[i], ist))
@


1.2
log
@Remove irq 5 and 7 from irqmask. These are commonly used by soundcard devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isasubr.c,v 1.1 1998/09/11 08:02:50 fgsch Exp $	*/
d88 3
a90 3
#ifndef PCIC_ISA_INTR_ALLOC_MASK
#define	PCIC_ISA_INTR_ALLOC_MASK	0xff5f
#endif
d92 2
a93 1
int	pcic_isa_intr_alloc_mask = PCIC_ISA_INTR_ALLOC_MASK;
d216 1
a216 1
	int reg;
d225 10
a234 3
	if (isa_intr_alloc(ic,
	    PCIC_INTR_IRQ_VALIDMASK & pcic_isa_intr_alloc_mask, ist, &irq))
		return (NULL);
@


1.1
log
@ISA routines for the Intel 82365SL PCIC controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a85 3
 *
 * We disable IRQ 10 by default, since some common laptops (namely, the
 * NEC Versa series) reserve IRQ 10 for the docking station SCSI interface.
d89 1
a89 1
#define	PCIC_ISA_INTR_ALLOC_MASK	0xfbff
@

