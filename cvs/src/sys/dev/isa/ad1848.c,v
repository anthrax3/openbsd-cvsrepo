head	1.45;
access;
symbols
	OPENBSD_6_1:1.45.0.2
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.40.0.4
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.8
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.39.0.6
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.39.0.2
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.38.0.12
	OPENBSD_5_3_BASE:1.38
	OPENBSD_5_2:1.38.0.10
	OPENBSD_5_2_BASE:1.38
	OPENBSD_5_1_BASE:1.38
	OPENBSD_5_1:1.38.0.8
	OPENBSD_5_0:1.38.0.6
	OPENBSD_5_0_BASE:1.38
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.33.0.8
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.33.0.10
	OPENBSD_4_6_BASE:1.33
	OPENBSD_4_5:1.33.0.6
	OPENBSD_4_5_BASE:1.33
	OPENBSD_4_4:1.33.0.4
	OPENBSD_4_4_BASE:1.33
	OPENBSD_4_3:1.33.0.2
	OPENBSD_4_3_BASE:1.33
	OPENBSD_4_2:1.32.0.10
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.32.0.8
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.6
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.6
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.30
	SMP_SYNC_B:1.30
	OPENBSD_3_5:1.30.0.2
	OPENBSD_3_5_BASE:1.30
	OPENBSD_3_4:1.29.0.2
	OPENBSD_3_4_BASE:1.29
	UBC_SYNC_A:1.28
	OPENBSD_3_3:1.27.0.2
	OPENBSD_3_3_BASE:1.27
	OPENBSD_3_2:1.26.0.2
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.25.0.2
	OPENBSD_3_1_BASE:1.25
	UBC_SYNC_B:1.26
	UBC:1.23.0.2
	UBC_BASE:1.23
	OPENBSD_3_0:1.21.0.4
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.21
	OPENBSD_2_9:1.21.0.2
	OPENBSD_2_8:1.20.0.4
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.2
	OPENBSD_2_7_BASE:1.20
	SMP:1.19.0.4
	SMP_BASE:1.19
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.13.0.2
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.7.0.4
	OPENBSD_2_1_BASE:1.7
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.44;
commitid	pi1a9KN0itEngOc4;

1.44
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.43;
commitid	EA6IpjJSgQH2WTCf;

1.43
date	2015.05.11.06.52.35;	author ratchov;	state Exp;
branches;
next	1.42;
commitid	d72M2ifvvYynw0IH;

1.42
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	RaOGL5SyOGOZylwx;

1.41
date	2015.05.08.07.25.36;	author jsg;	state Exp;
branches;
next	1.40;
commitid	0QJR2LJg2gf7QRoE;

1.40
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.39;
commitid	uzzBR7hz9ncd4O6G;

1.39
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.38;

1.38
date	2010.07.31.08.08.18;	author ratchov;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.24.22.48.28;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2010.07.23.11.47.50;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2010.06.30.11.21.35;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.22.19.40.51;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.15.13.05.14;	author mickey;	state Exp;
branches;
next	1.30;

1.30
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2003.06.08.00.41.10;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.27;

1.27
date	2003.02.11.19.20.27;	author mickey;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.25;

1.25
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.23;

1.23
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.12.07.51.56;	author csapuntz;	state Exp;
branches;
next	1.20;

1.20
date	2000.03.02.23.02.48;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	99.07.29.09.45.04;	author niklas;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	99.07.19.19.47.05;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	99.05.03.18.50.01;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	99.01.24.15.58.53;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	99.01.07.06.14.46;	author niklas;	state Exp;
branches;
next	1.14;

1.14
date	98.12.29.09.10.29;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	98.07.16.22.37.44;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	98.07.15.22.18.22;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	98.05.08.18.37.18;	author csapuntz;	state Exp;
branches;
next	1.10;

1.10
date	98.04.26.21.02.38;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	98.01.18.18.58.36;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	97.07.10.23.06.31;	author provos;	state Exp;
branches;
next	1.7;

1.7
date	96.08.23.20.13.13;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.07.04.21.00.57;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.07.35.55;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.28;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.08.16.42.45;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.04;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches;
next	;

1.19.4.1
date	2000.03.24.09.09.11;	author niklas;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2001.05.14.22.24.28;	author niklas;	state Exp;
branches;
next	1.19.4.3;

1.19.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.19.4.4;

1.19.4.4
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.19.4.5;

1.19.4.5
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.19.4.6;

1.19.4.6
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.19.4.7;

1.19.4.7
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.19.4.8;

1.19.4.8
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;

1.23.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.23.2.2;

1.23.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	1.23.2.3;

1.23.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.23.2.4;

1.23.2.4
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: ad1848.c,v 1.43 2015/05/11 06:52:35 ratchov Exp $	*/
/*	$NetBSD: ad1848.c,v 1.45 1998/01/30 02:02:38 augustss Exp $	*/

/*
 * Copyright (c) 1994 John Brezak
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Copyright by Hannu Savolainen 1994
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer. 2.
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Portions of this code are from the VOXware support for the ad1848
 * by Hannu Savolainen <hannu@@voxware.pp.fi>
 * 
 * Portions also supplied from the SoundBlaster driver for NetBSD.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <machine/cpu.h>
#include <machine/bus.h>

#include <sys/audioio.h>

#include <dev/audio_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/ad1848reg.h>
#include <dev/ic/cs4231reg.h>
#include <dev/isa/ad1848var.h>
#include <dev/isa/cs4231var.h>

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	do { if (ad1848debug) printf x; } while (0);
int	ad1848debug = 0;
#else
#define DPRINTF(x)
#endif

/*
 * Initial values for the indirect registers of CS4248/AD1848.
 */
static int ad1848_init_values[] = {
	GAIN_12 | INPUT_MIC_GAIN_ENABLE,	/* Left Input Control */
	GAIN_12 | INPUT_MIC_GAIN_ENABLE,	/* Right Input Control */
	ATTEN_12,			/* Left Aux #1 Input Control */
	ATTEN_12,			/* Right Aux #1 Input Control */
	ATTEN_12,			/* Left Aux #2 Input Control */
	ATTEN_12,			/* Right Aux #2 Input Control */
	/* bits 5-0 are attenuation select */
	ATTEN_12,			/* Left DAC output Control */
	ATTEN_12,			/* Right DAC output Control */
	CLOCK_XTAL1 | FMT_PCM8,		/* Clock and Data Format */
	SINGLE_DMA | AUTO_CAL_ENABLE,	/* Interface Config */
	INTERRUPT_ENABLE,		/* Pin control */
	0x00,				/* Test and Init */
	MODE2,				/* Misc control */
	ATTEN_0 << 2,			/* Digital Mix Control */
	0,				/* Upper base Count */
	0,				/* Lower base Count */

	/* These are for CS4231 &c. only (additional registers): */
	0,				/* Alt feature 1 */
	0,				/* Alt feature 2 */
	ATTEN_12,			/* Left line in */
	ATTEN_12,			/* Right line in */
	0,				/* Timer low */
	0,				/* Timer high */
	0,				/* unused */
	0,				/* unused */
	0,				/* IRQ status */
	0,				/* unused */

	/* Mono input (a.k.a speaker) (mic) Control */
	MONO_INPUT_MUTE|ATTEN_6,	/* mute speaker by default */
	0,				/* unused */
	0,				/* record format */
	0,				/* Crystal Clock Select */
	0,				/* upper record count */
	0				/* lower record count */
};

static struct audio_params ad1848_audio_default =
	{48000, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 2};

void	ad1848_reset(struct ad1848_softc *);
int	ad1848_set_speed(struct ad1848_softc *, u_long *);
void	ad1848_mute_monitor(void *, int);

/* indirect register access */
static int ad_read(struct ad1848_softc *, int);
static void ad_write(struct ad1848_softc *, int, int);
static void ad_set_MCE(struct ad1848_softc *, int);
static void wait_for_calibration(struct ad1848_softc *);

/* direct register (AD1848_{IADDR,IDATA,STATUS} only) access */
#define ADREAD(sc, addr) bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, (sc)->sc_iooffs+(addr))
#define ADWRITE(sc, addr, data) bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (sc)->sc_iooffs+(addr), (data))

static int
ad_read(struct ad1848_softc *sc, int reg)
{
	int x;

	ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);
	x = ADREAD(sc, AD1848_IDATA);
	/*  printf("(%02x<-%02x) ", reg|sc->MCE_bit, x); */

	return x;
}

static void
ad_write(struct ad1848_softc *sc, int reg, int data)
{
	ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);
	ADWRITE(sc, AD1848_IDATA, data & 0xff);
	/* printf("(%02x->%02x) ", reg|sc->MCE_bit, data); */
}

static void
ad_set_MCE(struct ad1848_softc *sc, int state)
{
	if (state)
		sc->MCE_bit = MODE_CHANGE_ENABLE;
	else
		sc->MCE_bit = 0;

	ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);
}

static void
wait_for_calibration(struct ad1848_softc *sc)
{
	int timeout;

	DPRINTF(("ad1848: Auto calibration started.\n"));
	/*
	 * Wait until the auto calibration process has finished.
	 *
	 * 1) Wait until the chip becomes ready (reads don't return SP_IN_INIT).
	 * 2) Wait until the ACI bit of I11 goes hi and then lo.
	 *   a) With AD1848 alike, ACI goes hi within 5 sample cycles
	 *	  and remains hi for ~384 sample periods.
	 *   b) With CS4231 alike, ACI goes hi immediately and remains
	 *	  hi for at least 168 sample periods.
	 */
	timeout = AD1848_TIMO;
	while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
		timeout--;

	if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
		DPRINTF(("ad1848: Auto calibration timed out(1).\n"));

	if (!(sc->sc_flags & AD1848_FLAG_32REGS)) {
		timeout = AD1848_TIMO;
		while (timeout > 0 &&
	 	    !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))
			timeout--;

		if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {
			DPRINTF(("ad1848: Auto calibration timed out(2).\n"));
		}
	}

	timeout = AD1848_TIMO;
	while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)
		timeout--;
	if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)
		DPRINTF(("ad1848: Auto calibration timed out(3).\n"));
}

#ifdef AUDIO_DEBUG
void ad1848_dump_regs(struct ad1848_softc *);

void
ad1848_dump_regs(struct ad1848_softc *sc)
{
	int i;
	u_char r;
	
	printf("ad1848 status=%02x", ADREAD(sc, AD1848_STATUS));
	printf(" regs: ");
	for (i = 0; i < 16; i++) {
		r = ad_read(sc, i);
		printf("%02x ", r);
	}
	if (sc->mode == 2) {
		for (i = 16; i < 32; i++) {
			r = ad_read(sc, i);
			printf("%02x ", r);
		}
	}
	printf("\n");
}
#endif

/*
 * Map and probe for the ad1848 chip
 */
int
ad1848_mapprobe(struct ad1848_softc *sc, int iobase)
{
	if (!AD1848_BASE_VALID(iobase)) {
#ifdef AUDIO_DEBUG
		printf("ad1848: configured iobase %04x invalid\n", iobase);
#endif
		return 0;
	}

	sc->sc_iooffs = 0;
	/* Map the AD1848 ports */
	if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))
		return 0;

	if (!ad1848_probe(sc)) {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);
		return 0;
	} else
		return 1;
}

/*
 * Probe for the ad1848 chip
 */
int
ad1848_probe(struct ad1848_softc *sc)
{
	u_char tmp, tmp1 = 0xff, tmp2 = 0xff;
#if 0
	int i;
#endif

	/* Is there an ad1848 chip ? */
	sc->MCE_bit = MODE_CHANGE_ENABLE;
	sc->mode = 1;	/* MODE 1 = original ad1848/ad1846/cs4248 */
	sc->sc_flags = 0;

	/*
	 * Check that the I/O address is in use.
	 *
	 * The SP_IN_INIT bit of the base I/O port is known to be 0 after the
	 * chip has performed its power-on initialization. Just assume
	 * this has happened before the OS is starting.
	 *
	 * If the I/O address is unused, inb() typically returns 0xff.
	 */
	tmp = ADREAD(sc, AD1848_IADDR);
	if (tmp & SP_IN_INIT) { /* Not a AD1848 */
#if 0
		DPRINTF(("ad_detect_A %x\n", tmp));
#endif
		goto bad;
	}

	/*
	 * Test if it's possible to change contents of the indirect registers.
	 * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read
	 * only so try to avoid using it.
	 */
	ad_write(sc, 0, 0xaa);
	ad_write(sc, 1, 0x45);	/* 0x55 with bit 0x10 clear */

	if ((tmp1 = ad_read(sc, 0)) != 0xaa ||
	    (tmp2 = ad_read(sc, 1)) != 0x45) {
		DPRINTF(("ad_detect_B (%x/%x)\n", tmp1, tmp2));
		goto bad;
	}

	ad_write(sc, 0, 0x45);
	ad_write(sc, 1, 0xaa);

	if ((tmp1 = ad_read(sc, 0)) != 0x45 ||
	    (tmp2 = ad_read(sc, 1)) != 0xaa) {
		DPRINTF(("ad_detect_C (%x/%x)\n", tmp1, tmp2));
		goto bad;
	}

	/*
	 * The indirect register I12 has some read only bits. Lets
	 * try to change them.
	 */
	tmp = ad_read(sc, SP_MISC_INFO);
	ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);

	if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {
		DPRINTF(("ad_detect_D (%x)\n", tmp1));
		goto bad;
	}

	/*
	 * MSB and 4 LSBs of the reg I12 tell the chip revision.
	 *
	 * A preliminary version of the AD1846 data sheet stated that it
	 * used an ID field of 0x0B.  The current version, however,
	 * states that the AD1846 uses ID 0x0A, just like the AD1848K.
	 *
	 * this switch statement will need updating as newer clones arrive....
	 */
	switch (tmp1 & 0x8f) {
	case 0x09:
		sc->chip_name = "AD1848J";
		break;
	case 0x0A:
		sc->chip_name = "AD1848K";
		break;
#if 0	/* See above */
	case 0x0B:
		sc->chip_name = "AD1846";
		break;
#endif
	case 0x81:
		sc->chip_name = "CS4248revB"; /* or CS4231 rev B; see below */
		break;
	case 0x89:
		sc->chip_name = "CS4248";
		break;
	case 0x8A:
		sc->chip_name = "broken"; /* CS4231/AD1845; see below */
		break;
	default:
		sc->chip_name = "unknown";
		DPRINTF(("ad1848: unknown codec version %#02X\n", (tmp1 & 0x8f)));
	}	

#if 0
	/*
	 * XXX I don't know why, but this probe fails on an otherwise
	 * well-working AW35/pro card, so I'll just take it out for now.
	 * [niklas@@openbsd.org]
	 */

	/*
	 * The original AD1848/CS4248 has just 16 indirect registers. This
	 * means that I0 and I16 should return the same value (etc.).
	 * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test
	 * fails with CS4231, AD1845, etc.
	 */
	ad_write(sc, SP_MISC_INFO, 0);	/* Mode2 = disabled */

	for (i = 0; i < 16; i++) {
		if ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {
			if (i != SP_TEST_AND_INIT) {
				DPRINTF(("ad_detect_F(%d/%x/%x)\n", i, tmp1, tmp2));
				goto bad;
			}
		}
	}
#endif

	/*
	 * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit
	 * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.
	 */
	ad_write(sc, SP_MISC_INFO, MODE2);	/* Set mode2, clear 0x80 */

	tmp1 = ad_read(sc, SP_MISC_INFO);
	if ((tmp1 & 0xc0) == (0x80 | MODE2)) {
		/*
		 *	CS4231 or AD1845 detected - is it?
		 *
		 *	Verify that setting I2 doesn't change I18.
		 */
		ad_write(sc, 18, 0x88); /* Set I18 to known value */

		ad_write(sc, 2, 0x45);
		if ((tmp2 = ad_read(sc, 18)) != 0x45) {
			/* No change -> CS4231? */
			ad_write(sc, 2, 0xaa);
			if ((tmp2 = ad_read(sc, 18)) == 0xaa) {
				/* Rotten bits? */
				DPRINTF(("ad_detect_H(%x)\n", tmp2));
				goto bad;
			}

			/*
			 *  It's a CS4231, or another clone with 32 registers.
			 *  Let's find out which by checking I25.
			 */
			if ((tmp1 & 0x8f) == 0x8a) {
				tmp1 = ad_read(sc, CS_VERSION_ID);
				switch (tmp1 & 0xe7) {
				case 0xA0:
					sc->chip_name = "CS4231A";
					break;
				case 0x80:
					/* I25 no good, AD1845 same as CS4231 */
					sc->chip_name = "CS4231 or AD1845";
					break;
				case 0x82:
					sc->chip_name = "CS4232";
					break;
				case 0xa2:
					sc->chip_name = "CS4232C";
					break;
				case 0x03:
					sc->chip_name = "CS4236/CS4236B";
					break;
				}
			}
			sc->mode = 2;
			sc->sc_flags |= AD1848_FLAG_32REGS;
		}
	}

	/* Wait for 1848 to init */
	while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
		;

	/* Wait for 1848 to autocal */
	ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);
	while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)
		;

	return 1;
bad:
	return 0;
}

/* Unmap the I/O ports */
void
ad1848_unmap(struct ad1848_softc *sc)
{
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);
}

/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver .
 */
void
ad1848_attach(struct ad1848_softc *sc)
{
	int i;
	struct ad1848_volume vol_mid = {220, 220};
	struct ad1848_volume vol_0   = {0, 0};
	struct audio_params pparams, rparams;
	int timeout;

	sc->sc_playrun = 0;
	sc->sc_recrun = 0;

	if (sc->sc_drq != -1) {
		if (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,
		    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
			printf("ad1848_attach: can't create map for drq %d\n",
			    sc->sc_drq);
			return;
		}
	}
	if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {
		if (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,
		    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
			printf("ad1848_attach: can't create map for second drq %d\n",
			    sc->sc_recdrq);
			return;
		}
	}

	/* Initialize the ad1848... */
	for (i = 0; i < 0x10; i++) {
		ad_write(sc, i, ad1848_init_values[i]);
		timeout = AD1848_TIMO;
		while (timeout > 0 && ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
			timeout--;
	}
	/* need 2 separate drqs for mode 2 */
	if ((sc->mode == 2) &&
	    ((sc->sc_recdrq == -1) || (sc->sc_recdrq == sc->sc_drq))) {
		ad_write(sc, SP_MISC_INFO, ad_read(sc, SP_MISC_INFO) & ~MODE2);
		if (!(ad_read(sc, SP_MISC_INFO) & MODE2))
			sc->mode = 1;
	}
	/* ...and additional CS4231 stuff too */
	if (sc->mode == 2) {
		ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */
		for (i = 0x10; i < 0x20; i++) {
			if (ad1848_init_values[i] != 0) {
				ad_write(sc, i, ad1848_init_values[i]);
				timeout = AD1848_TIMO;
				while (timeout > 0 && 
				    ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
					timeout--;
			}
		}
	}
	ad1848_reset(sc);

	pparams = ad1848_audio_default;
	rparams = ad1848_audio_default;
	(void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0,
	    &pparams, &rparams);

	/* Set default gains */
	(void) ad1848_set_rec_gain(sc, &vol_mid);
	(void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);
	(void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);
	/* CD volume */
	(void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);
	if (sc->mode == 2) {
		 /* CD volume */
		(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid);
		(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);
		(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);
		sc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;
	} else
		(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);

	/* Set default port */
	(void) ad1848_set_rec_port(sc, MIC_IN_PORT);

	if (sc->chip_name)
		printf(": %s", sc->chip_name);
}

/*
 * Various routines to interface to higher level audio driver
 */
struct ad1848_mixerinfo {
	int left_reg;
	int right_reg;
	int atten_bits;
	int atten_mask;
} mixer_channel_info[] = {
	{ SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,
		AUX_INPUT_ATTEN_MASK },
	{ SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,
		AUX_INPUT_ATTEN_MASK },
	{ SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, OUTPUT_ATTEN_BITS,
		OUTPUT_ATTEN_MASK }, 
	{ CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,
		LINE_INPUT_ATTEN_MASK },
	{ CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },
	{ SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }
};

/*
 *  This function doesn't set the mute flags but does use them.
 *  The mute flags reflect the mutes that have been applied by the user.
 *  However, the driver occasionally wants to mute devices (e.g. when chaing
 *  sampling rate). These operations should not affect the mute flags.
 */
void 
ad1848_mute_channel(struct ad1848_softc *sc, int device, int mute)
{
	u_char reg;

	reg = ad_read(sc, mixer_channel_info[device].left_reg);

	if (mute & MUTE_LEFT) {
		if (device == AD1848_MONITOR_CHANNEL) {
			ad_write(sc, mixer_channel_info[device].left_reg,
			    reg & 0xFE);
		} else {
			ad_write(sc, mixer_channel_info[device].left_reg,
			    reg | 0x80);
		}
	} else if (!(sc->mute[device] & MUTE_LEFT)) {
		if (device == AD1848_MONITOR_CHANNEL) {
			ad_write(sc, mixer_channel_info[device].left_reg,
			    reg | 0x01);
		} else {
			ad_write(sc, mixer_channel_info[device].left_reg,
			    reg & ~0x80);
		}
	}

	if (!mixer_channel_info[device].right_reg) {
		return;
  	}

	reg = ad_read(sc, mixer_channel_info[device].right_reg);

	if (mute & MUTE_RIGHT) {
		ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);
	} else if (!(sc->mute[device] & MUTE_RIGHT)) {
		ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);
	}
}

int
ad1848_set_channel_gain(struct ad1848_softc *sc, int device,
    struct ad1848_volume *gp)
{
	struct ad1848_mixerinfo *info = &mixer_channel_info[device];
	u_char reg;
	u_int atten;

	sc->gains[device] = *gp;

	atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits) /
	    AUDIO_MAX_GAIN;

	reg = ad_read(sc, info->left_reg) & (info->atten_mask);
	if (device == AD1848_MONITOR_CHANNEL)
		reg |= ((atten & info->atten_bits) << 2);
	else
		reg |= ((atten & info->atten_bits));

	ad_write(sc, info->left_reg, reg);

	if (!info->right_reg)
		return 0;

	atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits) /
	    AUDIO_MAX_GAIN;
	reg = ad_read(sc, info->right_reg);
	reg &= (info->atten_mask);
	ad_write(sc, info->right_reg, (atten & info->atten_bits) | reg);

	return 0;
}

int
ad1848_get_device_gain(struct ad1848_softc *sc, int device,
    struct ad1848_volume *gp)
{
	*gp = sc->gains[device];
	return 0;
}

int
ad1848_get_rec_gain(struct ad1848_softc *sc, struct ad1848_volume *gp)
{
	*gp = sc->rec_gain;
	return 0;
}

int
ad1848_set_rec_gain(struct ad1848_softc *sc, struct ad1848_volume *gp)
{
	u_char reg, gain;
	
	DPRINTF(("ad1848_set_rec_gain: %d:%d\n", gp->left, gp->right));

	sc->rec_gain = *gp;

	gain = (gp->left * GAIN_22_5) / AUDIO_MAX_GAIN;
	reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
	reg &= INPUT_GAIN_MASK;
	ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain & 0x0f) | reg);

	gain = (gp->right * GAIN_22_5) / AUDIO_MAX_GAIN;
	reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);
	reg &= INPUT_GAIN_MASK;
	ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain & 0x0f) | reg);

	return 0;
}

void
ad1848_mute_monitor(void *addr, int mute)
{
	struct ad1848_softc *sc = addr;

	DPRINTF(("ad1848_mute_monitor: %smuting\n", mute ? "" : "un"));
	if (sc->mode == 2) {
		ad1848_mute_channel(sc, AD1848_DAC_CHANNEL,
		    mute ? MUTE_ALL : 0);
		ad1848_mute_channel(sc, AD1848_MONO_CHANNEL,
		    mute ? MUTE_MONO : 0);
		ad1848_mute_channel(sc, AD1848_LINE_CHANNEL,
		    mute ? MUTE_ALL : 0);
	}

	ad1848_mute_channel(sc, AD1848_AUX2_CHANNEL, mute ? MUTE_ALL : 0);
	ad1848_mute_channel(sc, AD1848_AUX1_CHANNEL, mute ? MUTE_ALL : 0);
}

int
ad1848_set_mic_gain(struct ad1848_softc *sc, struct ad1848_volume *gp)
{
	u_char reg;

	DPRINTF(("cs4231_set_mic_gain: %d\n", gp->left));

	if (gp->left > AUDIO_MAX_GAIN / 2) {
		sc->mic_gain_on = 1;
		reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
		ad_write(sc, SP_LEFT_INPUT_CONTROL,
		    reg | INPUT_MIC_GAIN_ENABLE);
	} else {
		sc->mic_gain_on = 0;
		reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
		ad_write(sc, SP_LEFT_INPUT_CONTROL,
		    reg & ~INPUT_MIC_GAIN_ENABLE);
	}

	return 0;
}

int
ad1848_get_mic_gain(struct ad1848_softc *sc, struct ad1848_volume *gp)
{
	if (sc->mic_gain_on)
		gp->left = gp->right = AUDIO_MAX_GAIN;
	else
		gp->left = gp->right = AUDIO_MIN_GAIN;

	return 0;
}


static ad1848_devmap_t *ad1848_mixer_find_dev(ad1848_devmap_t *, int, mixer_ctrl_t *);

static ad1848_devmap_t *
ad1848_mixer_find_dev(ad1848_devmap_t *map, int cnt, mixer_ctrl_t *cp)
{
	int idx;

	for (idx = 0; idx < cnt; idx++) {
		if (map[idx].id == cp->dev) {
			return &map[idx];
		}
  	}
	return NULL;
}

int
ad1848_mixer_get_port(struct ad1848_softc *ac, struct ad1848_devmap *map,
    int cnt, mixer_ctrl_t *cp)
{
	ad1848_devmap_t *entry;
	struct ad1848_volume vol;
	int error = EINVAL;
	int dev;

	if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))
		return (ENXIO);

	dev = entry->dev;
	mtx_enter(&audio_lock);
	switch (entry->kind) {
	case AD1848_KIND_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (dev < AD1848_AUX2_CHANNEL ||
		    dev > AD1848_MONITOR_CHANNEL)
	  		break;
		if (cp->un.value.num_channels != 1 &&
		    mixer_channel_info[dev].right_reg == 0) 
	  		break;
		error = ad1848_get_device_gain(ac, dev, &vol);
		if (!error)
			ad1848_from_vol(cp, &vol);
		break;

	case AD1848_KIND_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ac->mute[dev] ? 1 : 0;
		error = 0;
		break;

	case AD1848_KIND_RECORDGAIN:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		error = ad1848_get_rec_gain(ac, &vol);
		if (!error)
			ad1848_from_vol(cp, &vol);
		break;

	case AD1848_KIND_MICGAIN:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		error = ad1848_get_mic_gain(ac, &vol);
		if (!error)
			ad1848_from_vol(cp, &vol);
		break;

	case AD1848_KIND_RECORDSOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		cp->un.ord = ad1848_get_rec_port(ac);
		error = 0;
		break;

	default:
		printf("Invalid kind\n");
		break;
	}
	mtx_leave(&audio_lock);
	return error;
}

int	 
ad1848_mixer_set_port(struct ad1848_softc *ac, struct ad1848_devmap *map,
    int cnt, mixer_ctrl_t *cp)
{
	ad1848_devmap_t *entry;
	struct ad1848_volume vol;
	int error = EINVAL;
	int dev;

	if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))
		return (ENXIO);

  	dev = entry->dev;
	mtx_enter(&audio_lock);
	switch (entry->kind) {
	case AD1848_KIND_LVL:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		if (dev < AD1848_AUX2_CHANNEL ||
		    dev > AD1848_MONITOR_CHANNEL)
			break;
		if (cp->un.value.num_channels != 1 &&
		    mixer_channel_info[dev].right_reg == 0) 
			break;
		ad1848_to_vol(cp, &vol);
		error = ad1848_set_channel_gain(ac, dev, &vol);
		break;

	case AD1848_KIND_MUTE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);
		ad1848_mute_channel(ac, dev, ac->mute[dev]);
		error = 0;
		break;

	case AD1848_KIND_RECORDGAIN:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		ad1848_to_vol(cp, &vol);
		error = ad1848_set_rec_gain(ac, &vol);
		break;

	case AD1848_KIND_MICGAIN:
		if (cp->type != AUDIO_MIXER_VALUE)
			break;
		ad1848_to_vol(cp, &vol);
		error = ad1848_set_mic_gain(ac, &vol);
		break;

	case AD1848_KIND_RECORDSOURCE:
		if (cp->type != AUDIO_MIXER_ENUM)
			break;
		error = ad1848_set_rec_port(ac,  cp->un.ord);
		break;

	default:
		printf("Invalid kind\n");
		break;
	}
	mtx_leave(&audio_lock);
	return (error);
}

int
ad1848_set_params(void *addr, int setmode, int usemode, struct audio_params *p,
    struct audio_params *r)
{
	struct ad1848_softc *sc = addr;
	int error, bits, enc;

	DPRINTF(("ad1848_set_params: %d %d %d %ld\n", 
	     p->encoding, p->precision, p->channels, p->sample_rate));

	enc = p->encoding;
	switch (enc) {
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision == 8)
			return EINVAL;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		if (p->precision == 16)
			return EINVAL;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		if (p->precision == 16)
			return EINVAL;
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
		if (p->precision == 16)
			return EINVAL;
		break;
	}
	switch (enc) {
	case AUDIO_ENCODING_ULAW:
		p->precision = 8;
		bits = FMT_ULAW;
		break;
	case AUDIO_ENCODING_ALAW:
		p->precision = 8;
		bits = FMT_ALAW;
		break;
	case AUDIO_ENCODING_SLINEAR_LE:
		if (p->precision == 16)
			bits = FMT_TWOS_COMP;
		else
			return EINVAL;
		break;
	case AUDIO_ENCODING_SLINEAR_BE:
		if (p->precision == 16)
			bits = FMT_TWOS_COMP_BE;
		else
			return EINVAL;
		break;
	case AUDIO_ENCODING_ULINEAR_LE:
		if (p->precision == 8)
			bits = FMT_PCM8;
		else
			return EINVAL;
		break;
	default:
		return EINVAL;
	}

	if (p->channels < 1 || p->channels > 2)
		return EINVAL;

	error = ad1848_set_speed(sc, &p->sample_rate);
	if (error)
		return error;

	p->bps = AUDIO_BPS(p->precision);
	r->bps = AUDIO_BPS(r->precision);
	p->msb = 1;
	r->msb = 1;

	sc->format_bits = bits;
	sc->channels = p->channels;
	sc->precision = p->precision;
	sc->need_commit = 1;

	DPRINTF(("ad1848_set_params succeeded, bits=%x\n", bits));
	return (0);
}

int
ad1848_set_rec_port(struct ad1848_softc *sc, int port)
{
	u_char inp, reg;

	DPRINTF(("ad1848_set_rec_port: 0x%x\n", port));

	if (port == MIC_IN_PORT) {
		inp = MIC_INPUT;
	} else if (port == LINE_IN_PORT) {
		inp = LINE_INPUT;
	} else if (port == DAC_IN_PORT) {
		inp = MIXED_DAC_INPUT;
	} else if (sc->mode == 2 && port == AUX1_IN_PORT) {
		inp = AUX_INPUT;
	} else
		return EINVAL;

	reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
	reg &= INPUT_SOURCE_MASK;
	ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp | reg));

	reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);
	reg &= INPUT_SOURCE_MASK;
	ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp | reg));

	sc->rec_port = port;

	return 0;
}

int
ad1848_get_rec_port(struct ad1848_softc *sc)
{
	return sc->rec_port;
}

int
ad1848_round_blocksize(void *addr, int blk)
{
	/* Round to a multiple of the biggest sample size. */
	blk = (blk + 3) & -4;

	return blk;
}

int
ad1848_open(void *addr, int flags)
{
	struct ad1848_softc *sc = addr;

	DPRINTF(("ad1848_open: sc=%p\n", sc));

	sc->sc_pintr = sc->sc_parg = NULL;
	sc->sc_rintr = sc->sc_rarg = NULL;

	/* Enable interrupts */
	DPRINTF(("ad1848_open: enable intrs\n"));
	ad_write(sc, SP_PIN_CONTROL,
	    INTERRUPT_ENABLE | ad_read(sc, SP_PIN_CONTROL));

#ifdef AUDIO_DEBUG
	if (ad1848debug > 2)
		ad1848_dump_regs(sc);
#endif

	return 0;
}

/*
 * Close function is called at splaudio().
 */
void
ad1848_close(void *addr)
{
	struct ad1848_softc *sc = addr;
	u_char r;

	ad1848_halt_output(sc);
	ad1848_halt_input(sc);

	sc->sc_pintr = NULL;
	sc->sc_rintr = NULL;

	DPRINTF(("ad1848_close: stop DMA\n"));

	ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);
	ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);

	/* Disable interrupts */
	DPRINTF(("ad1848_close: disable intrs\n"));
	ad_write(sc, SP_PIN_CONTROL, 
	    ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);

	DPRINTF(("ad1848_close: disable capture and playback\n"));
	r = ad_read(sc, SP_INTERFACE_CONFIG);
	r &= ~(CAPTURE_ENABLE | PLAYBACK_ENABLE);
	ad_write(sc, SP_INTERFACE_CONFIG, r);

#ifdef AUDIO_DEBUG
	if (ad1848debug > 2)
		ad1848_dump_regs(sc);
#endif
}

/*
 * Lower-level routines
 */
int
ad1848_commit_settings(void *addr)
{
	struct ad1848_softc *sc = addr;
	int timeout;
	u_char fs;

	if (!sc->need_commit)
		return 0;

	mtx_enter(&audio_lock);

	ad1848_mute_monitor(sc, 1);

	/* Enables changes to the format select reg */
	ad_set_MCE(sc, 1);

	fs = sc->speed_bits | sc->format_bits;

	if (sc->channels == 2)
		fs |= FMT_STEREO;

	ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);

	/*
	 * If mode == 2 (CS4231), set I28 also. It's the capture format
	 * register.
	 */
	if (sc->mode == 2) {
		/* Gravis Ultrasound MAX SDK sources says something about
		 * errata sheets, with the implication that these inb()s
		 * are necessary.
		 */
		(void)ADREAD(sc, AD1848_IDATA);
		(void)ADREAD(sc, AD1848_IDATA);

		/*
		 * Write to I8 starts resynchronization. Wait until it
		 * completes.
		 */
		timeout = AD1848_TIMO;
		while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
			timeout--;

		ad_write(sc, CS_REC_FORMAT, fs);
		/* Gravis Ultrasound MAX SDK sources says something about
		 * errata sheets, with the implication that these inb()s
		 * are necessary.
		 */
		(void)ADREAD(sc, AD1848_IDATA);
		(void)ADREAD(sc, AD1848_IDATA);
		/* Now wait for resync for capture side of the house */
	}
	/*
	 * Write to I8 starts resynchronization. Wait until it completes.
	 */
	timeout = AD1848_TIMO;
	while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
		timeout--;

	if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
		printf("ad1848_commit: Auto calibration timed out\n");

	/*
	 * Starts the calibration process and enters playback mode after it.
	 */
	ad_set_MCE(sc, 0);
	wait_for_calibration(sc);

	ad1848_mute_monitor(sc, 0);

	mtx_leave(&audio_lock);
	
	sc->need_commit = 0;

	return 0;
}

void
ad1848_reset(struct ad1848_softc *sc)
{
	u_char r;

	DPRINTF(("ad1848_reset\n"));

	/* Clear the PEN and CEN bits */
	r = ad_read(sc, SP_INTERFACE_CONFIG);
	r &= ~(CAPTURE_ENABLE | PLAYBACK_ENABLE);
	ad_write(sc, SP_INTERFACE_CONFIG, r);

	/* Clear interrupt status */
	if (sc->mode == 2)
		ad_write(sc, CS_IRQ_STATUS, 0);
	ADWRITE(sc, AD1848_STATUS, 0);

#ifdef AUDIO_DEBUG
	if (ad1848debug > 2)
		ad1848_dump_regs(sc);
#endif
}

int
ad1848_set_speed(struct ad1848_softc *sc, u_long *argp)
{
	/*
	 * The sampling speed is encoded in the least significant nible of I8.
	 * The LSB selects the clock source (0=24.576 MHz, 1=16.9344 MHz) and
	 * other three bits select the divisor (indirectly):
	 *
	 * The available speeds are in the following table. Keep the speeds in
	 * the increasing order.
	 */
	typedef struct {
		int	speed;
		u_char	bits;
	} speed_struct;
	u_long arg = *argp;

	static speed_struct speed_table[] =  {
		{5510, (0 << 1) | 1},
		{5510, (0 << 1) | 1},
		{6620, (7 << 1) | 1},
		{8000, (0 << 1) | 0},
		{9600, (7 << 1) | 0},
		{11025, (1 << 1) | 1},
		{16000, (1 << 1) | 0},
		{18900, (2 << 1) | 1},
		{22050, (3 << 1) | 1},
		{27420, (2 << 1) | 0},
		{32000, (3 << 1) | 0},
		{33075, (6 << 1) | 1},
		{37800, (4 << 1) | 1},
		{44100, (5 << 1) | 1},
		{48000, (6 << 1) | 0}
	};

	int i, n, selected = -1;

	n = sizeof(speed_table) / sizeof(speed_struct);

	if (arg < speed_table[0].speed)
		selected = 0;
	if (arg > speed_table[n - 1].speed)
		selected = n - 1;

	for (i = 1 /*really*/ ; selected == -1 && i < n; i++)
		if (speed_table[i].speed == arg)
			selected = i;
		else if (speed_table[i].speed > arg) {
			int diff1, diff2;

		diff1 = arg - speed_table[i - 1].speed;
		diff2 = speed_table[i].speed - arg;

		if (diff1 < diff2)
			selected = i - 1;
		else
			selected = i;
	}

	if (selected == -1) {
		printf("ad1848: Can't find speed???\n");
		selected = 3;
	}

	sc->speed_bits = speed_table[selected].bits;
	sc->need_commit = 1;
	*argp = speed_table[selected].speed;

	return 0;
}

/*
 * Halt a DMA in progress.
 */
int
ad1848_halt_output(void *addr)
{
	struct ad1848_softc *sc = addr;
	u_char reg;

	DPRINTF(("ad1848: ad1848_halt_output\n"));
	mtx_enter(&audio_lock);
	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~PLAYBACK_ENABLE));

	if (sc->sc_playrun == 1) {
		isa_dmaabort(sc->sc_isa, sc->sc_drq);
		sc->sc_playrun = 0;
	}
	mtx_leave(&audio_lock);
	return 0;
}

int
ad1848_halt_input(void *addr)
{
	struct ad1848_softc *sc = addr;
	u_char reg;

	DPRINTF(("ad1848: ad1848_halt_input\n"));
	mtx_enter(&audio_lock);
	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~CAPTURE_ENABLE));

	if (sc->sc_recrun == 1) {
		isa_dmaabort(sc->sc_isa, sc->sc_recdrq);
		sc->sc_recrun = 0;
	}
	mtx_leave(&audio_lock);
	return 0;
}

int
ad1848_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct ad1848_softc *sc = addr;
	u_char reg;

	if (sc->sc_recdrq == -1) {
		DPRINTF(("ad1848_trigger_input: invalid recording drq\n"));
		return ENXIO;
	}
	mtx_enter(&audio_lock);
	isa_dmastart(sc->sc_isa, sc->sc_recdrq, start,
	    (char *)end - (char *)start, NULL, DMAMODE_READ | DMAMODE_LOOP,
	    BUS_DMA_NOWAIT);

	sc->sc_recrun = 1;
	sc->sc_rintr = intr;
	sc->sc_rarg = arg;

	blksize = (blksize * NBBY) / (param->precision * param->channels) - 1;

	if (sc->mode == 2) {
		ad_write(sc, CS_LOWER_REC_CNT, (blksize & 0xff));
		ad_write(sc, CS_UPPER_REC_CNT, ((blksize >> 8) & 0xff));
	} else {
		ad_write(sc, SP_LOWER_BASE_COUNT, blksize & 0xff);
		ad_write(sc, SP_UPPER_BASE_COUNT, (blksize >> 8) & 0xff);
	}

	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE | reg));

#ifdef AUDIO_DEBUG
	if (ad1848debug > 1)
		printf("ad1848_trigger_input: started capture\n");
#endif
	mtx_leave(&audio_lock);
	return 0;
}

int
ad1848_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct ad1848_softc *sc = addr;
	u_char reg;

	mtx_enter(&audio_lock);
	isa_dmastart(sc->sc_isa, sc->sc_drq, start,
	    (char *)end - (char *)start, NULL,
	    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);

	sc->sc_playrun = 1;
	sc->sc_pintr = intr;
	sc->sc_parg = arg;

	blksize = (blksize * NBBY) / (param->precision * param->channels) - 1;

	ad_write(sc, SP_LOWER_BASE_COUNT, blksize & 0xff);
	ad_write(sc, SP_UPPER_BASE_COUNT, (blksize >> 8) & 0xff);

	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE | reg));

#ifdef AUDIO_DEBUG
	if (ad1848debug > 1)
		printf("ad1848_trigger_output: started playback\n");
#endif
	mtx_leave(&audio_lock);
	return 0;
}

int
ad1848_intr(void *arg)
{
	struct ad1848_softc *sc = arg;
	int retval = 0;
	u_char status;

	mtx_enter(&audio_lock);
	/* Get intr status */
	status = ADREAD(sc, AD1848_STATUS);
	
#ifdef AUDIO_DEBUG
	if (ad1848debug > 1)
		printf("ad1848_intr: mode=%d pintr=%p prun=%d rintr=%p rrun=%d status=0x%x\n",
		    sc->mode, sc->sc_pintr, sc->sc_playrun, sc->sc_rintr, sc->sc_recrun, status);
#endif

	/* Handle interrupt */
	if ((status & INTERRUPT_STATUS) != 0) {
		if (sc->mode == 2) {
			status = ad_read(sc, CS_IRQ_STATUS);
#ifdef AUDIO_DEBUG
			if (ad1848debug > 2)
				printf("ad1848_intr: cs_irq_status=0x%x (play=0x%x rec0x%x)\n",
				    status, CS_IRQ_PI, CS_IRQ_CI);
#endif
			if ((status & CS_IRQ_PI) && sc->sc_playrun) {
				(*sc->sc_pintr)(sc->sc_parg);
				retval = 1;
			}
			if ((status & CS_IRQ_CI) && sc->sc_recrun) {
				(*sc->sc_rintr)(sc->sc_rarg);
				retval = 1;
			}
		} else {
			if (sc->sc_playrun) {
				(*sc->sc_pintr)(sc->sc_parg);
				retval = 1;
			} else if (sc->sc_recrun) {
				(*sc->sc_rintr)(sc->sc_rarg);
				retval = 1;
			}
		}
		/* clear interrupt */
		ADWRITE(sc, AD1848_STATUS, 0);
	}
	mtx_leave(&audio_lock);
	return(retval);
}

void *
ad1848_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct ad1848_softc *sc = addr;
	int drq;

	if (direction == AUMODE_PLAY)
		drq = sc->sc_drq;
	else
		drq = sc->sc_recdrq;

	return isa_malloc(sc->sc_isa, drq, size, pool, flags);
}

void
ad1848_free(void *addr, void *ptr, int pool)
{
	isa_free(ptr, pool);
}

size_t
ad1848_round(void *addr, int direction, size_t size)
{
	if (size > MAX_ISADMA)
		size = MAX_ISADMA;
	return size;
}

int
ad1848_get_props(void *addr)
{
	struct ad1848_softc *sc = addr;

	return AUDIO_PROP_MMAP |
	    (sc->mode == 2 ? AUDIO_PROP_FULLDUPLEX : 0);
}
@


1.44
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@a909 38
ad1848_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	default:
		return EINVAL;
		/*NOTREACHED*/
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a1459 6
}

paddr_t
ad1848_mappage(void *addr, void *mem, off_t off, int prot)
{
	return isa_mappage(mem, off, prot);
@


1.43
log
@Remove support for ADPCM encoding which isn't used nowadays and
not available to programs anyway.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.42 2015/05/11 06:46:21 ratchov Exp $	*/
d143 3
d548 2
a549 2
	pparams = audio_default;
	rparams = audio_default;
@


1.42
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.41 2015/05/08 07:25:36 jsg Exp $	*/
a980 3
		break;
	case AUDIO_ENCODING_ADPCM:
		bits = FMT_ADPCM;
@


1.41
log
@Fix the indentation.  While originally I thought this was an if statement
with missing braces ratchov checked the specs to see the current
behaviour is correct, just poorly formatted.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.40 2014/09/14 14:17:25 jsg Exp $	*/
a83 1
#include <dev/auconv.h>
a908 2
	struct ad1848_softc *sc = addr;

a933 34
	case 4: /* only on CS4231 */
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = sc->mode == 1 ? AUDIO_ENCODINGFLAG_EMULATED : 0;
		break;

	/* emulate some modes */
	case 5:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 8: /* only on CS4231 */
		if (sc->mode == 1)
			return EINVAL;
		strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ADPCM;
		fp->precision = 8;
		fp->flags = 0;
		break;
a949 2
	void (*pswcode)(void *, u_char *buf, int cnt);
	void (*rswcode)(void *, u_char *buf, int cnt);
a954 1
	pswcode = rswcode = 0;
d957 2
a958 4
		if (p->precision == 8) {
			enc = AUDIO_ENCODING_ULINEAR_LE;
			pswcode = rswcode = change_sign8;
		}
d961 2
a962 4
		if (p->precision == 16 && sc->mode == 1) {
			enc = AUDIO_ENCODING_SLINEAR_LE;
			pswcode = rswcode = swap_bytes;
		}
d965 2
a966 4
		if (p->precision == 16) {
			enc = AUDIO_ENCODING_SLINEAR_LE;
			pswcode = rswcode = change_sign16_le;
		}
d969 2
a970 5
		if (p->precision == 16) {
			enc = AUDIO_ENCODING_SLINEAR_LE;
			pswcode = swap_bytes_change_sign16_le;
			rswcode = change_sign16_swap_bytes_le;
		}
d974 2
a975 1
		case AUDIO_ENCODING_ULAW:
d979 1
a1013 2
	p->sw_code = pswcode;
	r->sw_code = rswcode;
@


1.40
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.39 2013/05/15 08:29:24 ratchov Exp $	*/
d1277 1
a1277 1
	ad_write(sc, CS_IRQ_STATUS, 0);
@


1.39
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.38 2010/07/31 08:08:18 ratchov Exp $	*/
a75 1
#include <sys/proc.h>
@


1.38
log
@fix typo preventing compilation with AUDIO_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.37 2010/07/24 22:48:28 jakemsr Exp $	*/
d162 1
a162 1
	int x, s;
a163 1
	s = splaudio();
a165 1
	splx(s);
a173 1
	int s = splaudio();
a175 1
	splx(s);
d790 1
a790 1

d840 1
a840 1

d857 1
a857 1

d904 1
a904 1

a1191 1
	int s;
d1196 1
a1196 1
	s = splaudio();
d1257 1
a1257 1
	splx(s);
d1368 1
a1368 1

d1376 1
a1376 1

d1387 1
a1387 1

d1395 1
a1395 1

d1410 1
a1410 1

d1436 1
a1436 1
	
d1447 1
d1468 1
a1468 1
	
d1479 1
d1518 1
a1518 1

@


1.37
log
@missed a couple indents in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.36 2010/07/23 11:47:50 jakemsr Exp $	*/
d239 1
a239 1
ad1848_dump_regs(ad1848_softc *sc)
@


1.36
log
@ANSI/style(9), no binary change
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.35 2010/07/15 03:43:11 jakemsr Exp $	*/
d187 1
a187 1
	sc->MCE_bit = MODE_CHANGE_ENABLE;
d189 1
a189 1
	sc->MCE_bit = 0;
d212 1
a212 1
	timeout--;
d215 1
a215 1
	DPRINTF(("ad1848: Auto calibration timed out(1).\n"));
@


1.35
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.34 2010/06/30 11:21:35 jakemsr Exp $	*/
d106 37
a142 40
			/* Left Input Control */
    GAIN_12|INPUT_MIC_GAIN_ENABLE,
			/* Right Input Control */
    GAIN_12|INPUT_MIC_GAIN_ENABLE,
    ATTEN_12,		/* Left Aux #1 Input Control */
    ATTEN_12,		/* Right Aux #1 Input Control */
    ATTEN_12,		/* Left Aux #2 Input Control */
    ATTEN_12,		/* Right Aux #2 Input Control */
    /* bits 5-0 are attenuation select */
    ATTEN_12,		/* Left DAC output Control */
    ATTEN_12,		/* Right DAC output Control */
			/* Clock and Data Format */
    CLOCK_XTAL1|FMT_PCM8,
			/* Interface Config */
    SINGLE_DMA|AUTO_CAL_ENABLE,
    INTERRUPT_ENABLE,	/* Pin control */
    0x00,		/* Test and Init */
    MODE2,		/* Misc control */
    ATTEN_0<<2,		/* Digital Mix Control */
    0,			/* Upper base Count */
    0,			/* Lower base Count */

    /* These are for CS4231 &c. only (additional registers): */
    0,			/* Alt feature 1 */
    0,			/* Alt feature 2 */
    ATTEN_12,		/* Left line in */
    ATTEN_12,		/* Right line in */
    0,			/* Timer low */
    0,			/* Timer high */
    0,			/* unused */
    0,			/* unused */
    0,			/* IRQ status */
    0,			/* unused */
			/* Mono input (a.k.a speaker) (mic) Control */
    MONO_INPUT_MUTE|ATTEN_6,		/* mute speaker by default */
    0,			/* unused */
    0,			/* record format */
    0,			/* Crystal Clock Select */
    0,			/* upper record count */
    0			/* lower record count */
d160 9
a168 11
ad_read(sc, reg)
    struct ad1848_softc *sc;
    int reg;
{
    int x, s;

    s = splaudio();
    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);
    x = ADREAD(sc, AD1848_IDATA);
    splx(s);
    /*  printf("(%02x<-%02x) ", reg|sc->MCE_bit, x); */
d170 1
a170 1
    return x;
d174 7
a180 10
ad_write(sc, reg, data)
    struct ad1848_softc *sc;
    int reg;
    int data;
{
    int s = splaudio();
    ADWRITE(sc, AD1848_IADDR, (reg & 0xff) | sc->MCE_bit);
    ADWRITE(sc, AD1848_IDATA, data & 0xff);
    splx(s);
    /* printf("(%02x->%02x) ", reg|sc->MCE_bit, data); */
d184 1
a184 3
ad_set_MCE(sc, state)
    struct ad1848_softc *sc;
    int state;
d186 1
a186 1
    if (state)
d188 1
a188 1
    else
d191 1
a191 1
    ADWRITE(sc, AD1848_IADDR, sc->MCE_bit);
d195 1
a195 2
wait_for_calibration(sc)
    struct ad1848_softc *sc;
d197 1
a197 1
    int timeout;
d199 13
a211 13
    DPRINTF(("ad1848: Auto calibration started.\n"));
    /*
     * Wait until the auto calibration process has finished.
     *
     * 1) Wait until the chip becomes ready (reads don't return SP_IN_INIT).
     * 2) Wait until the ACI bit of I11 goes hi and then lo.
     *   a) With AD1848 alike, ACI goes hi within 5 sample cycles
     *      and remains hi for ~384 sample periods.
     *   b) With CS4231 alike, ACI goes hi immediately and remains
     *      hi for at least 168 sample periods.
     */
    timeout = AD1848_TIMO;
    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
d214 1
a214 1
    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
d217 5
a221 5
    if (!(sc->sc_flags & AD1848_FLAG_32REGS)) {
	timeout = AD1848_TIMO;
	while (timeout > 0 &&
	 !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))
	    timeout--;
d223 3
a225 2
	if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {
	    DPRINTF(("ad1848: Auto calibration timed out(2).\n"));
a226 1
    }
d228 5
a232 5
    timeout = AD1848_TIMO;
    while (timeout > 0 && ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)
	timeout--;
    if (ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)
        DPRINTF(("ad1848: Auto calibration timed out(3).\n"));
d239 1
a239 2
ad1848_dump_regs(sc)
    struct ad1848_softc *sc;
d241 16
a256 16
    int i;
    u_char r;
    
    printf("ad1848 status=%02x", ADREAD(sc, AD1848_STATUS));
    printf(" regs: ");
    for (i = 0; i < 16; i++) {
	r = ad_read(sc, i);
	printf("%02x ", r);
    }
    if (sc->mode == 2) {
	    for (i = 16; i < 32; i++) {
		    r = ad_read(sc, i);
		    printf("%02x ", r);
	    }
    }
    printf("\n");
d264 1
a264 3
ad1848_mapprobe(sc, iobase)
    struct ad1848_softc *sc;
    int iobase;
d266 1
a266 1
    if (!AD1848_BASE_VALID(iobase)) {
d268 1
a268 1
	printf("ad1848: configured iobase %04x invalid\n", iobase);
d270 2
a271 7
	return 0;
    }

    sc->sc_iooffs = 0;
    /* Map the AD1848 ports */
    if (bus_space_map(sc->sc_iot, iobase, AD1848_NPORT, 0, &sc->sc_ioh))
	return 0;
d273 10
a282 5
    if (!ad1848_probe(sc)) {
	bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);
	return 0;
    } else
	return 1;
d289 1
a289 2
ad1848_probe(sc)
    struct ad1848_softc *sc;
d291 1
a291 1
    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;
d293 1
a293 1
    int i;
d295 17
a311 17
    
    /* Is there an ad1848 chip ? */
    sc->MCE_bit = MODE_CHANGE_ENABLE;
    sc->mode = 1;	/* MODE 1 = original ad1848/ad1846/cs4248 */
    sc->sc_flags = 0;
    
    /*
     * Check that the I/O address is in use.
     *
     * The SP_IN_INIT bit of the base I/O port is known to be 0 after the
     * chip has performed its power-on initialization. Just assume
     * this has happened before the OS is starting.
     *
     * If the I/O address is unused, inb() typically returns 0xff.
     */
    tmp = ADREAD(sc, AD1848_IADDR);
    if (tmp & SP_IN_INIT) { /* Not a AD1848 */
d313 1
a313 1
	DPRINTF(("ad_detect_A %x\n", tmp));
d315 10
a324 2
	goto bad;
    }
d326 43
a368 51
    /*
     * Test if it's possible to change contents of the indirect registers.
     * Registers 0 and 1 are ADC volume registers. The bit 0x10 is read only
     * so try to avoid using it.
     */
    ad_write(sc, 0, 0xaa);
    ad_write(sc, 1, 0x45);	/* 0x55 with bit 0x10 clear */

    if ((tmp1 = ad_read(sc, 0)) != 0xaa ||
	(tmp2 = ad_read(sc, 1)) != 0x45) {
	DPRINTF(("ad_detect_B (%x/%x)\n", tmp1, tmp2));
	goto bad;
    }

    ad_write(sc, 0, 0x45);
    ad_write(sc, 1, 0xaa);

    if ((tmp1 = ad_read(sc, 0)) != 0x45 ||
	(tmp2 = ad_read(sc, 1)) != 0xaa) {
	DPRINTF(("ad_detect_C (%x/%x)\n", tmp1, tmp2));
	goto bad;
    }

    /*
     * The indirect register I12 has some read only bits. Lets
     * try to change them.
     */
    tmp = ad_read(sc, SP_MISC_INFO);
    ad_write(sc, SP_MISC_INFO, (~tmp) & 0x0f);

    if ((tmp & 0x0f) != ((tmp1 = ad_read(sc, SP_MISC_INFO)) & 0x0f)) {
	DPRINTF(("ad_detect_D (%x)\n", tmp1));
	goto bad;
    }

    /*
     * MSB and 4 LSBs of the reg I12 tell the chip revision.
     *
     * A preliminary version of the AD1846 data sheet stated that it
     * used an ID field of 0x0B.  The current version, however,
     * states that the AD1846 uses ID 0x0A, just like the AD1848K.
     *
     * this switch statement will need updating as newer clones arrive....
     */
    switch (tmp1 & 0x8f) {
    case 0x09:
	sc->chip_name = "AD1848J";
	break;
    case 0x0A:
	sc->chip_name = "AD1848K";
	break;
d370 3
a372 3
    case 0x0B:
	sc->chip_name = "AD1846";
	break;
d374 14
a387 14
    case 0x81:
	sc->chip_name = "CS4248revB"; /* or CS4231 rev B; see below */
	break;
    case 0x89:
	sc->chip_name = "CS4248";
	break;
    case 0x8A:
	sc->chip_name = "broken"; /* CS4231/AD1845; see below */
	break;
    default:
	sc->chip_name = "unknown";
	DPRINTF(("ad1848: unknown codec version %#02X\n", (tmp1 & 0x8f)));
    }	
    
d389 21
a409 19
    /*
     * XXX I don't know why, but this probe fails on an otherwise well-working
     * AW35/pro card, so I'll just take it out for now. [niklas@@openbsd.org]
     */

    /*
     * The original AD1848/CS4248 has just 16 indirect registers. This means
     * that I0 and I16 should return the same value (etc.).
     * Ensure that the Mode2 enable bit of I12 is 0. Otherwise this test fails
     * with CS4231, AD1845, etc.
     */
    ad_write(sc, SP_MISC_INFO, 0);	/* Mode2 = disabled */

    for (i = 0; i < 16; i++)
	if ((tmp1 = ad_read(sc, i)) != (tmp2 = ad_read(sc, i + 16))) {
	    if (i != SP_TEST_AND_INIT) {
	        DPRINTF(("ad_detect_F(%d/%x/%x)\n", i, tmp1, tmp2));
	        goto bad;
	    }
a412 8
    /*
     * Try to switch the chip to mode2 (CS4231) by setting the MODE2 bit
     * The bit 0x80 is always 1 in CS4248, CS4231, and AD1845.
     */
    ad_write(sc, SP_MISC_INFO, MODE2);	/* Set mode2, clear 0x80 */

    tmp1 = ad_read(sc, SP_MISC_INFO);
    if ((tmp1 & 0xc0) == (0x80 | MODE2)) {
d414 2
a415 3
	 *      CS4231 or AD1845 detected - is it?
	 *
	 *	Verify that setting I2 doesn't change I18.
d417 1
a417 1
	ad_write(sc, 18, 0x88); /* Set I18 to known value */
d419 48
a466 7
	ad_write(sc, 2, 0x45);
	if ((tmp2 = ad_read(sc, 18)) != 0x45) { /* No change -> CS4231? */
	    ad_write(sc, 2, 0xaa);
	    if ((tmp2 = ad_read(sc, 18)) == 0xaa) {     /* Rotten bits? */
		DPRINTF(("ad_detect_H(%x)\n", tmp2));
		goto bad;
	    }
d468 8
a475 38
	    /*
	     *  It's a CS4231, or another clone with 32 registers.
	     *  Let's find out which by checking I25.
	     */
	    if ((tmp1 & 0x8f) == 0x8a) {
		tmp1 = ad_read(sc, CS_VERSION_ID);
		switch (tmp1 & 0xe7) {
		case 0xA0:
		    sc->chip_name = "CS4231A";
		    break;
		case 0x80:
		    /*  XXX I25 no good, AD1845 same as CS4231 */
		    sc->chip_name = "CS4231 or AD1845";
		    break;
		case 0x82:
		    sc->chip_name = "CS4232";
		    break;
		case 0xa2:
		    sc->chip_name = "CS4232C";
		    break;
		case 0x03:
		    sc->chip_name = "CS4236/CS4236B";
		    break;
		}
	    }
	    sc->mode = 2;
	    sc->sc_flags |= AD1848_FLAG_32REGS;
	}
    }

    /* Wait for 1848 to init */
    while(ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
        ;
	
    /* Wait for 1848 to autocal */
    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);
    while(ADREAD(sc, AD1848_IDATA) & AUTO_CAL_IN_PROG)
        ;
d477 1
a477 1
    return 1;
d479 1
a479 1
    return 0;
d484 1
a484 2
ad1848_unmap(sc)
    struct ad1848_softc *sc;
d486 1
a486 1
    bus_space_unmap(sc->sc_iot, sc->sc_ioh, AD1848_NPORT);
d494 1
a494 2
ad1848_attach(sc)
    struct ad1848_softc *sc;
d496 39
a534 15
    int i;
    struct ad1848_volume vol_mid = {220, 220};
    struct ad1848_volume vol_0   = {0, 0};
    struct audio_params pparams, rparams;
    int timeout;
    
    sc->sc_playrun = 0;
    sc->sc_recrun = 0;

    if (sc->sc_drq != -1) {
	if (isa_dmamap_create(sc->sc_isa, sc->sc_drq, MAX_ISADMA,
	    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
		printf("ad1848_attach: can't create map for drq %d\n",
		    sc->sc_drq);
		return;
d536 12
a547 7
    }
    if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {
	if (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq, MAX_ISADMA,
	    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
		printf("ad1848_attach: can't create map for second drq %d\n",
		    sc->sc_recdrq);
		return;
d549 1
a549 1
    }
d551 19
a569 44
    /* Initialize the ad1848... */
    for (i = 0; i < 0x10; i++) {
	ad_write(sc, i, ad1848_init_values[i]);
        timeout = AD1848_TIMO;
        while (timeout > 0 && ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
	    timeout--;
    }
    /* need 2 separate drqs for mode 2 */
    if ((sc->mode == 2) &&
      ((sc->sc_recdrq == -1) || (sc->sc_recdrq == sc->sc_drq))) {
	ad_write(sc, SP_MISC_INFO, ad_read(sc, SP_MISC_INFO) & ~MODE2);
	if (!(ad_read(sc, SP_MISC_INFO) & MODE2))
	    sc->mode = 1;
    }
    /* ...and additional CS4231 stuff too */
    if (sc->mode == 2) {
	    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA */
	    for (i = 0x10; i < 0x20; i++)
		    if (ad1848_init_values[i] != 0) {
			    ad_write(sc, i, ad1848_init_values[i]);
			    timeout = AD1848_TIMO;
    			    while (timeout > 0 && 
				   ADREAD(sc, AD1848_IADDR) & SP_IN_INIT)
				timeout--;
		    }
    }
    ad1848_reset(sc);

    pparams = audio_default;
    rparams = audio_default;
    (void) ad1848_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);

    /* Set default gains */
    (void) ad1848_set_rec_gain(sc, &vol_mid);
    (void) ad1848_set_channel_gain(sc, AD1848_DAC_CHANNEL, &vol_mid);
    (void) ad1848_set_channel_gain(sc, AD1848_MONITOR_CHANNEL, &vol_0);
    (void) ad1848_set_channel_gain(sc, AD1848_AUX1_CHANNEL, &vol_mid);	/* CD volume */
    if (sc->mode == 2) {
	(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_mid); /* CD volume */
	(void) ad1848_set_channel_gain(sc, AD1848_LINE_CHANNEL, &vol_mid);
	(void) ad1848_set_channel_gain(sc, AD1848_MONO_CHANNEL, &vol_0);
	sc->mute[AD1848_MONO_CHANNEL] = MUTE_ALL;
    } else
	(void) ad1848_set_channel_gain(sc, AD1848_AUX2_CHANNEL, &vol_0);
d571 2
a572 2
    /* Set default port */
    (void) ad1848_set_rec_port(sc, MIC_IN_PORT);
d574 2
a575 2
    if (sc->chip_name)
	printf(": %s", sc->chip_name);
d582 15
a596 15
  int  left_reg;
  int  right_reg;
  int  atten_bits;
  int  atten_mask;
} mixer_channel_info[] = 
{ { SP_LEFT_AUX2_CONTROL, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_ATTEN_BITS,
    AUX_INPUT_ATTEN_MASK },
  { SP_LEFT_AUX1_CONTROL, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_ATTEN_BITS,
    AUX_INPUT_ATTEN_MASK },
  { SP_LEFT_OUTPUT_CONTROL, SP_RIGHT_OUTPUT_CONTROL, 
    OUTPUT_ATTEN_BITS, OUTPUT_ATTEN_MASK }, 
  { CS_LEFT_LINE_CONTROL, CS_RIGHT_LINE_CONTROL, LINE_INPUT_ATTEN_BITS,
    LINE_INPUT_ATTEN_MASK },
  { CS_MONO_IO_CONTROL, 0, MONO_INPUT_ATTEN_BITS, MONO_INPUT_ATTEN_MASK },
  { SP_DIGITAL_MIX, 0, OUTPUT_ATTEN_BITS, MIX_ATTEN_MASK }
a604 1

d606 1
a606 4
ad1848_mute_channel(sc, device, mute) 
	struct ad1848_softc *sc;
	int device;
	int mute;
d608 1
a608 1
  u_char reg;
d610 1
a610 1
  reg = ad_read(sc, mixer_channel_info[device].left_reg);
d612 17
a628 11
  if (mute & MUTE_LEFT) {
    if (device == AD1848_MONITOR_CHANNEL)
        ad_write(sc, mixer_channel_info[device].left_reg, reg & 0xFE);
    else
        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x80);
  } else if (!(sc->mute[device] & MUTE_LEFT)) {
    if (device == AD1848_MONITOR_CHANNEL)
        ad_write(sc, mixer_channel_info[device].left_reg, reg | 0x01);
    else
        ad_write(sc, mixer_channel_info[device].left_reg, reg & ~0x80);
  }
d630 3
a632 3
  if (!mixer_channel_info[device].right_reg) {
    return;
  }
d634 1
a634 1
  reg = ad_read(sc, mixer_channel_info[device].right_reg);
d636 5
a640 5
  if (mute & MUTE_RIGHT)
    ad_write(sc, mixer_channel_info[device].right_reg, reg | 0x80);
  else if (!(sc->mute[device] & MUTE_RIGHT)) {
    ad_write(sc, mixer_channel_info[device].right_reg, reg & ~0x80);
  }
a642 1

d644 2
a645 4
ad1848_set_channel_gain(sc, device, gp)
    struct ad1848_softc *sc;
    int device;
    struct ad1848_volume *gp;
d647 3
a649 3
    struct ad1848_mixerinfo *info = &mixer_channel_info[device];
    u_char reg;
    u_int atten;
d651 1
a651 1
    sc->gains[device] = *gp;
d653 2
a654 1
    atten = ((AUDIO_MAX_GAIN - gp->left) * info->atten_bits)/AUDIO_MAX_GAIN;
d656 5
a660 5
    reg = ad_read(sc, info->left_reg) & (info->atten_mask);
    if (device == AD1848_MONITOR_CHANNEL)
      reg |= ((atten & info->atten_bits) << 2);
    else
      reg |= ((atten & info->atten_bits));
d662 1
a662 1
    ad_write(sc, info->left_reg, reg);
d664 2
a665 2
    if (!info->right_reg)
      return (0);
d667 5
a671 4
    atten = ((AUDIO_MAX_GAIN - gp->right) * info->atten_bits)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, info->right_reg);
    reg &= (info->atten_mask);
    ad_write(sc, info->right_reg, (atten& info->atten_bits)|reg);
d673 1
a673 1
    return(0);
a675 1

d677 2
a678 4
ad1848_get_device_gain(sc, device, gp)
    struct ad1848_softc *sc;
    int device;
    struct ad1848_volume *gp;
d680 2
a681 2
    *gp = sc->gains[device];
    return(0);
d685 1
a685 3
ad1848_get_rec_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
d687 2
a688 2
    *gp = sc->rec_gain;
    return(0);
d692 1
a692 3
ad1848_set_rec_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
d694 3
a696 3
    u_char reg, gain;
    
    DPRINTF(("ad1848_set_rec_gain: %d:%d\n", gp->left, gp->right));
d698 1
a698 1
    sc->rec_gain = *gp;
d700 9
a708 4
    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
    reg &= INPUT_GAIN_MASK;
    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);
d710 1
a710 6
    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);
    reg &= INPUT_GAIN_MASK;
    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);

    return(0);
a712 1

d714 1
a714 3
ad1848_mute_monitor(addr, mute)
	void *addr;
	int mute;
d720 6
a725 3
	        ad1848_mute_channel(sc, AD1848_DAC_CHANNEL, mute ? MUTE_ALL : 0);
		ad1848_mute_channel(sc, AD1848_MONO_CHANNEL, mute ? MUTE_MONO : 0);
		ad1848_mute_channel(sc, AD1848_LINE_CHANNEL, mute ? MUTE_ALL : 0);
d727 1
a727 1
		
d733 19
a751 19
ad1848_set_mic_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    u_char reg;
    
    DPRINTF(("cs4231_set_mic_gain: %d\n", gp->left));

    if (gp->left > AUDIO_MAX_GAIN/2) {
	    sc->mic_gain_on = 1;
	    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
	    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg | INPUT_MIC_GAIN_ENABLE);
    } else {
	    sc->mic_gain_on = 0;
	    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
	    ad_write(sc, SP_LEFT_INPUT_CONTROL, reg & ~INPUT_MIC_GAIN_ENABLE);
    }

    return(0);
d755 1
a755 3
ad1848_get_mic_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
d761 2
a762 1
	return(0);
d769 216
a984 248
ad1848_mixer_find_dev(map, cnt, cp)
  ad1848_devmap_t *map;
  int cnt;
  mixer_ctrl_t *cp;

{
  int idx;

  for (idx = 0; idx < cnt; idx++) {
    if (map[idx].id == cp->dev) {
      return (&map[idx]);
    }
  }
  return (NULL);
}

int     
ad1848_mixer_get_port(ac, map, cnt, cp)
  struct ad1848_softc *ac;
  struct ad1848_devmap *map;
  int cnt;
  mixer_ctrl_t *cp;
{
  ad1848_devmap_t *entry;
  struct ad1848_volume vol;
  int error = EINVAL;
  int dev;

  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))
    return (ENXIO);

  dev = entry->dev;

  switch (entry->kind) {
  case AD1848_KIND_LVL:
    if (cp->type != AUDIO_MIXER_VALUE)
      break;

    if (dev < AD1848_AUX2_CHANNEL ||
	dev > AD1848_MONITOR_CHANNEL)
      break;

    if (cp->un.value.num_channels != 1 &&
        mixer_channel_info[dev].right_reg == 0) 
      break;

    error = ad1848_get_device_gain(ac, dev, &vol);
    if (!error)
      ad1848_from_vol(cp, &vol);

    break;

  case AD1848_KIND_MUTE:
    if (cp->type != AUDIO_MIXER_ENUM) break;

    cp->un.ord = ac->mute[dev] ? 1 : 0;
    error = 0;
    break;

  case AD1848_KIND_RECORDGAIN:
    if (cp->type != AUDIO_MIXER_VALUE) break;

    error = ad1848_get_rec_gain(ac, &vol);
    if (!error)
      ad1848_from_vol(cp, &vol);

    break;

  case AD1848_KIND_MICGAIN:
    if (cp->type != AUDIO_MIXER_VALUE) break;

    error = ad1848_get_mic_gain(ac, &vol);
    if (!error)
      ad1848_from_vol(cp, &vol);

    break;

  case AD1848_KIND_RECORDSOURCE:
    if (cp->type != AUDIO_MIXER_ENUM) break;
    cp->un.ord = ad1848_get_rec_port(ac);
    error = 0;
    break;
  default:
    printf ("Invalid kind\n");
    break;
  }

  return (error);
}

int     
ad1848_mixer_set_port(ac, map, cnt, cp)
  struct ad1848_softc *ac;
  struct ad1848_devmap *map;
  int cnt;
  mixer_ctrl_t *cp;
{
  ad1848_devmap_t *entry;
  struct ad1848_volume vol;
  int error = EINVAL;
  int dev;

  if (!(entry = ad1848_mixer_find_dev(map, cnt, cp)))
    return (ENXIO);

  dev = entry->dev;

  switch (entry->kind) {
  case AD1848_KIND_LVL:
    if (cp->type != AUDIO_MIXER_VALUE)
      break;

    if (dev < AD1848_AUX2_CHANNEL ||
	dev > AD1848_MONITOR_CHANNEL)
      break;

    if (cp->un.value.num_channels != 1 &&
        mixer_channel_info[dev].right_reg == 0) 
      break;
    
    ad1848_to_vol(cp, &vol);
    error = ad1848_set_channel_gain(ac, dev, &vol);
    break;

  case AD1848_KIND_MUTE:
    if (cp->type != AUDIO_MIXER_ENUM) break;
    
    ac->mute[dev] = (cp->un.ord ? MUTE_ALL : 0);
    ad1848_mute_channel(ac, dev, ac->mute[dev]);
    error = 0;
    break;

  case AD1848_KIND_RECORDGAIN:
    if (cp->type != AUDIO_MIXER_VALUE) break;

    ad1848_to_vol(cp, &vol);
    error = ad1848_set_rec_gain(ac, &vol);
    break;

  case AD1848_KIND_MICGAIN:
    if (cp->type != AUDIO_MIXER_VALUE) break;

    ad1848_to_vol(cp, &vol);
    error = ad1848_set_mic_gain(ac, &vol);
    break;

  case AD1848_KIND_RECORDSOURCE:
    if (cp->type != AUDIO_MIXER_ENUM) break;

    error = ad1848_set_rec_port(ac,  cp->un.ord);
    break;
  default:
    printf ("Invalid kind\n");
    break;
  }

  return (error);
}


int
ad1848_query_encoding(addr, fp)
    void *addr;
    struct audio_encoding *fp;
{
    struct ad1848_softc *sc = addr;

    switch (fp->index) {
    case 0:
	strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ULAW;
	fp->precision = 8;
	fp->flags = 0;
	break;
    case 1:
	strlcpy(fp->name, AudioEalaw, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ALAW;
	fp->precision = 8;
	fp->flags = 0;
	break;
    case 2:
	strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
	fp->precision = 16;
	fp->flags = 0;
	break;
    case 3:
	strlcpy(fp->name, AudioEulinear, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ULINEAR;
	fp->precision = 8;
	fp->flags = 0;
	break;

    case 4: /* only on CS4231 */
	strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
	fp->precision = 16;
	fp->flags = sc->mode == 1 ? AUDIO_ENCODINGFLAG_EMULATED : 0;
	break;

    /* emulate some modes */
    case 5:
	strlcpy(fp->name, AudioEslinear, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_SLINEAR;
	fp->precision = 8;
	fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
	break;
    case 6:
	strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
	fp->precision = 16;
	fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
	break;
    case 7:
	strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
	fp->precision = 16;
	fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
	break;

    case 8: /* only on CS4231 */
	if (sc->mode == 1)
	    return EINVAL;
	strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
	fp->encoding = AUDIO_ENCODING_ADPCM;
	fp->precision = 8;
	fp->flags = 0;
	break;
    default:
	return EINVAL;
	/*NOTREACHED*/
    }
    fp->bps = AUDIO_BPS(fp->precision);
    fp->msb = 1;

    return (0);
}

int
ad1848_set_params(addr, setmode, usemode, p, r)
    void *addr;
    int setmode, usemode;
    struct audio_params *p, *r;
{
    struct ad1848_softc *sc = addr;
    int error, bits, enc;
    void (*pswcode)(void *, u_char *buf, int cnt);
    void (*rswcode)(void *, u_char *buf, int cnt);
d986 10
a995 1
    DPRINTF(("ad1848_set_params: %d %d %d %ld\n", 
d998 60
a1057 60
    enc = p->encoding;
    pswcode = rswcode = 0;
    switch (enc) {
    case AUDIO_ENCODING_SLINEAR_LE:
	if (p->precision == 8) {
	    enc = AUDIO_ENCODING_ULINEAR_LE;
	    pswcode = rswcode = change_sign8;
	}
	break;
    case AUDIO_ENCODING_SLINEAR_BE:
	if (p->precision == 16 && sc->mode == 1) {
	    enc = AUDIO_ENCODING_SLINEAR_LE;
	    pswcode = rswcode = swap_bytes;
	}
	break;
    case AUDIO_ENCODING_ULINEAR_LE:
	if (p->precision == 16) {
	    enc = AUDIO_ENCODING_SLINEAR_LE;
	    pswcode = rswcode = change_sign16_le;
	}
	break;
    case AUDIO_ENCODING_ULINEAR_BE:
	if (p->precision == 16) {
	    enc = AUDIO_ENCODING_SLINEAR_LE;
	    pswcode = swap_bytes_change_sign16_le;
	    rswcode = change_sign16_swap_bytes_le;
	}
	break;
    }
    switch (enc) {
    case AUDIO_ENCODING_ULAW:
	bits = FMT_ULAW;
	break;
    case AUDIO_ENCODING_ALAW:
	bits = FMT_ALAW;
	break;
    case AUDIO_ENCODING_ADPCM:
	bits = FMT_ADPCM;
	break;
    case AUDIO_ENCODING_SLINEAR_LE:
	if (p->precision == 16)
	    bits = FMT_TWOS_COMP;
	else
	    return EINVAL;
	break;
    case AUDIO_ENCODING_SLINEAR_BE:
	if (p->precision == 16)
	    bits = FMT_TWOS_COMP_BE;
	else
	    return EINVAL;
	break;
    case AUDIO_ENCODING_ULINEAR_LE:
	if (p->precision == 8)
	    bits = FMT_PCM8;
	else
	    return EINVAL;
	break;
    default:
	return EINVAL;
    }
d1059 2
a1060 2
    if (p->channels < 1 || p->channels > 2)
	return EINVAL;
d1062 3
a1064 3
    error = ad1848_set_speed(sc, &p->sample_rate);
    if (error)
	return error;
d1066 6
a1071 6
    p->sw_code = pswcode;
    r->sw_code = rswcode;
    p->bps = AUDIO_BPS(p->precision);
    r->bps = AUDIO_BPS(r->precision);
    p->msb = 1;
    r->msb = 1;
d1073 4
a1076 4
    sc->format_bits = bits;
    sc->channels = p->channels;
    sc->precision = p->precision;
    sc->need_commit = 1;
d1078 2
a1079 2
    DPRINTF(("ad1848_set_params succeeded, bits=%x\n", bits));
    return (0);
d1083 1
a1083 3
ad1848_set_rec_port(sc, port)
    struct ad1848_softc *sc;
    int port;
d1085 1
a1085 3
    u_char inp, reg;
    
    DPRINTF(("ad1848_set_rec_port: 0x%x\n", port));
d1087 1
a1087 14
    if (port == MIC_IN_PORT) {
	inp = MIC_INPUT;
    }
    else if (port == LINE_IN_PORT) {
	inp = LINE_INPUT;
    }
    else if (port == DAC_IN_PORT) {
	inp = MIXED_DAC_INPUT;
    }
    else if (sc->mode == 2 && port == AUX1_IN_PORT) {
	inp = AUX_INPUT;
    }
    else
	return(EINVAL);
d1089 10
a1098 3
    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
    reg &= INPUT_SOURCE_MASK;
    ad_write(sc, SP_LEFT_INPUT_CONTROL, (inp|reg));
d1100 3
a1102 3
    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);
    reg &= INPUT_SOURCE_MASK;
    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (inp|reg));
d1104 3
a1106 1
    sc->rec_port = port;
d1108 3
a1110 1
    return(0);
d1114 1
a1114 2
ad1848_get_rec_port(sc)
    struct ad1848_softc *sc;
d1116 1
a1116 1
    return(sc->rec_port);
d1120 1
a1120 3
ad1848_round_blocksize(addr, blk)
    void *addr;
    int blk;
d1122 2
a1123 2
    /* Round to a multiple of the biggest sample size. */
    blk = (blk + 3) & -4;
d1125 1
a1125 1
    return (blk);
d1129 1
a1129 3
ad1848_open(addr, flags)
    void *addr;
    int flags;
d1131 1
a1131 1
    struct ad1848_softc *sc = addr;
d1133 1
a1133 1
    DPRINTF(("ad1848_open: sc=%p\n", sc));
d1135 2
a1136 2
    sc->sc_pintr = sc->sc_parg = NULL;
    sc->sc_rintr = sc->sc_rarg = NULL;
d1138 4
a1141 3
    /* Enable interrupts */
    DPRINTF(("ad1848_open: enable intrs\n"));
    ad_write(sc, SP_PIN_CONTROL, INTERRUPT_ENABLE|ad_read(sc, SP_PIN_CONTROL));
d1144 2
a1145 2
    if (ad1848debug > 2)
	ad1848_dump_regs(sc);
d1148 1
a1148 1
    return 0;
d1155 1
a1155 2
ad1848_close(addr)
    void *addr;
d1157 2
a1158 2
    struct ad1848_softc *sc = addr;
    u_char r;
d1160 2
a1161 2
    ad1848_halt_output(sc);
    ad1848_halt_input(sc);
d1163 2
a1164 2
    sc->sc_pintr = NULL;
    sc->sc_rintr = NULL;
d1166 1
a1166 1
    DPRINTF(("ad1848_close: stop DMA\n"));
d1168 2
a1169 2
    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)0);
    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)0);
d1171 4
a1174 4
    /* Disable interrupts */
    DPRINTF(("ad1848_close: disable intrs\n"));
    ad_write(sc, SP_PIN_CONTROL, 
	     ad_read(sc, SP_PIN_CONTROL) & ~INTERRUPT_ENABLE);
d1176 4
a1179 4
    DPRINTF(("ad1848_close: disable capture and playback\n"));
    r = ad_read(sc, SP_INTERFACE_CONFIG);
    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);
    ad_write(sc, SP_INTERFACE_CONFIG, r);
d1182 2
a1183 2
    if (ad1848debug > 2)
	ad1848_dump_regs(sc);
d1191 1
a1191 2
ad1848_commit_settings(addr)
    void *addr;
d1193 7
a1199 4
    struct ad1848_softc *sc = addr;
    int timeout;
    u_char fs;
    int s;
d1201 13
a1213 2
    if (!sc->need_commit)
	return 0;
d1215 3
a1217 19
    s = splaudio();
    
    ad1848_mute_monitor(sc, 1);
    
    ad_set_MCE(sc, 1);		/* Enables changes to the format select reg */

    fs = sc->speed_bits | sc->format_bits;

    if (sc->channels == 2)
	fs |= FMT_STEREO;

    ad_write(sc, SP_CLOCK_DATA_FORMAT, fs);

    /*
     * If mode == 2 (CS4231), set I28 also. It's the capture format register.
     */
    if (sc->mode == 2) {
	/* Gravis Ultrasound MAX SDK sources says something about errata
	 * sheets, with the implication that these inb()s are necessary.
d1219 25
a1243 2
	(void)ADREAD(sc, AD1848_IDATA);
	(void)ADREAD(sc, AD1848_IDATA);
d1249 4
a1252 1
	    timeout--;
d1254 2
a1255 3
	ad_write(sc, CS_REC_FORMAT, fs);
	/* Gravis Ultrasound MAX SDK sources says something about errata
	 * sheets, with the implication that these inb()s are necessary.
d1257 4
a1260 10
	(void)ADREAD(sc, AD1848_IDATA);
	(void)ADREAD(sc, AD1848_IDATA);
	/* Now wait for resync for capture side of the house */
    }
    /*
     * Write to I8 starts resynchronization. Wait until it completes.
     */
    timeout = AD1848_TIMO;
    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
	timeout--;
d1262 3
a1264 2
    if (ADREAD(sc, AD1848_IADDR) == SP_IN_INIT)
	printf("ad1848_commit: Auto calibration timed out\n");
d1266 1
a1266 13
    /*
     * Starts the calibration process and
     * enters playback mode after it.
     */
    ad_set_MCE(sc, 0);
    wait_for_calibration(sc);

    ad1848_mute_monitor(sc, 0);

    splx(s);
    
    sc->need_commit = 0;
    return 0;
d1270 1
a1270 2
ad1848_reset(sc)
    struct ad1848_softc *sc;
d1272 8
a1279 8
    u_char r;
    
    DPRINTF(("ad1848_reset\n"));
    
    /* Clear the PEN and CEN bits */
    r = ad_read(sc, SP_INTERFACE_CONFIG);
    r &= ~(CAPTURE_ENABLE|PLAYBACK_ENABLE);
    ad_write(sc, SP_INTERFACE_CONFIG, r);
d1281 2
a1282 2
    /* Clear interrupt status */
    if (sc->mode == 2)
d1284 1
a1284 1
    ADWRITE(sc, AD1848_STATUS, 0);
d1287 2
a1288 2
    if (ad1848debug > 2)
	ad1848_dump_regs(sc);
d1293 57
a1349 68
ad1848_set_speed(sc, argp)
    struct ad1848_softc *sc;
    u_long *argp;
{
    /*
     * The sampling speed is encoded in the least significant nible of I8. The
     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 MHz) and other
     * three bits select the divisor (indirectly):
     *
     * The available speeds are in the following table. Keep the speeds in
     * the increasing order.
     */
    typedef struct {
	int	speed;
	u_char	bits;
    } speed_struct;
    u_long arg = *argp;

    static speed_struct speed_table[] =  {
	{5510, (0 << 1) | 1},
	{5510, (0 << 1) | 1},
	{6620, (7 << 1) | 1},
	{8000, (0 << 1) | 0},
	{9600, (7 << 1) | 0},
	{11025, (1 << 1) | 1},
	{16000, (1 << 1) | 0},
	{18900, (2 << 1) | 1},
	{22050, (3 << 1) | 1},
	{27420, (2 << 1) | 0},
	{32000, (3 << 1) | 0},
	{33075, (6 << 1) | 1},
	{37800, (4 << 1) | 1},
	{44100, (5 << 1) | 1},
	{48000, (6 << 1) | 0}
    };

    int i, n, selected = -1;

    n = sizeof(speed_table) / sizeof(speed_struct);

    if (arg < speed_table[0].speed)
	selected = 0;
    if (arg > speed_table[n - 1].speed)
	selected = n - 1;

    for (i = 1 /*really*/ ; selected == -1 && i < n; i++)
	if (speed_table[i].speed == arg)
	    selected = i;
	else if (speed_table[i].speed > arg) {
	    int diff1, diff2;

	    diff1 = arg - speed_table[i - 1].speed;
	    diff2 = speed_table[i].speed - arg;

	    if (diff1 < diff2)
		selected = i - 1;
	    else
		selected = i;
	}

    if (selected == -1) {
	printf("ad1848: Can't find speed???\n");
	selected = 3;
    }

    sc->speed_bits = speed_table[selected].bits;
    sc->need_commit = 1;
    *argp = speed_table[selected].speed;
d1351 10
a1360 1
    return (0);
d1367 1
a1367 2
ad1848_halt_output(addr)
    void *addr;
d1369 2
a1370 2
    struct ad1848_softc *sc = addr;
    u_char reg;
d1372 1
a1372 1
    DPRINTF(("ad1848: ad1848_halt_output\n"));
d1374 2
a1375 2
    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~PLAYBACK_ENABLE));
d1377 4
a1380 4
    if (sc->sc_playrun == 1) {
	isa_dmaabort(sc->sc_isa, sc->sc_drq);
	sc->sc_playrun = 0;
    }
d1382 1
a1382 1
    return(0);
d1386 1
a1386 2
ad1848_halt_input(addr)
    void *addr;
d1388 4
a1391 4
    struct ad1848_softc *sc = addr;
    u_char reg;
    
    DPRINTF(("ad1848: ad1848_halt_input\n"));
d1393 2
a1394 2
    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (reg & ~CAPTURE_ENABLE));
d1396 4
a1399 4
    if (sc->sc_recrun == 1) {
	isa_dmaabort(sc->sc_isa, sc->sc_recdrq);
	sc->sc_recrun = 0;
    }
d1401 1
a1401 1
    return(0);
d1405 10
a1414 32
ad1848_trigger_input(addr, start, end, blksize, intr, arg, param)
    void *addr;
    void *start, *end;
    int blksize;
    void (*intr)(void *);
    void *arg;
    struct audio_params *param;
{
    struct ad1848_softc *sc = addr;
    u_char reg;

    if (sc->sc_recdrq == -1) {
	DPRINTF(("ad1848_trigger_input: invalid recording drq\n"));
	return ENXIO;
    }
    
    isa_dmastart(sc->sc_isa, sc->sc_recdrq, start, (char *)end - (char *)start,
	NULL, DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);

    sc->sc_recrun = 1;
    sc->sc_rintr = intr;
    sc->sc_rarg = arg;

    blksize = (blksize * NBBY) / (param->precision * param->channels) - 1;

    if (sc->mode == 2) {
	ad_write(sc, CS_LOWER_REC_CNT, (blksize & 0xff));
	ad_write(sc, CS_UPPER_REC_CNT, ((blksize >> 8) & 0xff));
    } else {
        ad_write(sc, SP_LOWER_BASE_COUNT, blksize & 0xff);
        ad_write(sc, SP_UPPER_BASE_COUNT, (blksize >> 8) & 0xff);
    }
d1416 20
a1435 2
    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE|reg));
d1438 2
a1439 2
    if (ad1848debug > 1)
	    printf("ad1848_trigger_input: started capture\n");
d1441 2
a1442 2
    
    return 0;
d1446 2
a1447 7
ad1848_trigger_output(addr, start, end, blksize, intr, arg, param)
    void *addr;
    void *start, *end;
    int blksize;
    void (*intr)(void *);
    void *arg;
    struct audio_params *param;
d1449 2
a1450 5
    struct ad1848_softc *sc = addr;
    u_char reg;
    
    isa_dmastart(sc->sc_isa, sc->sc_drq, start, (char *)end - (char *)start,
      NULL, DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);
d1452 3
a1454 3
    sc->sc_playrun = 1;
    sc->sc_pintr = intr;
    sc->sc_parg = arg;
d1456 3
a1458 1
    blksize = (blksize * NBBY) / (param->precision * param->channels) - 1;
d1460 1
a1460 2
    ad_write(sc, SP_LOWER_BASE_COUNT, blksize & 0xff);
    ad_write(sc, SP_UPPER_BASE_COUNT, (blksize >> 8) & 0xff);
d1462 5
a1466 2
    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE|reg));
d1469 2
a1470 2
    if (ad1848debug > 1)
	    printf("ad1848_trigger_output: started playback\n");
d1472 2
a1473 2
    
    return 0;
d1477 1
a1477 2
ad1848_intr(arg)
	void *arg;
d1479 7
a1485 7
    struct ad1848_softc *sc = arg;
    int retval = 0;
    u_char status;
    
    /* Get intr status */
    status = ADREAD(sc, AD1848_STATUS);
    
d1487 3
a1489 3
    if (ad1848debug > 1)
	printf("ad1848_intr: mode=%d pintr=%p prun=%d rintr=%p rrun=%d status=0x%x\n",
	    sc->mode, sc->sc_pintr, sc->sc_playrun, sc->sc_rintr, sc->sc_recrun, status);
d1491 5
a1495 5
    
    /* Handle interrupt */
    if ((status & INTERRUPT_STATUS) != 0) {
	if (sc->mode == 2) {
		status = ad_read(sc, CS_IRQ_STATUS);
d1497 3
a1499 3
		if (ad1848debug > 2)
			printf("ad1848_intr: cs_irq_status=0x%x (play=0x%x rec0x%x)\n",
			    status, CS_IRQ_PI, CS_IRQ_CI);
d1501 16
a1516 15
		if ((status & CS_IRQ_PI) && sc->sc_playrun) {
			(*sc->sc_pintr)(sc->sc_parg);
			retval = 1;
		}
		if ((status & CS_IRQ_CI) && sc->sc_recrun) {
			(*sc->sc_rintr)(sc->sc_rarg);
			retval = 1;
		}
	} else {
		if (sc->sc_playrun) {
			(*sc->sc_pintr)(sc->sc_parg);
			retval = 1;
		} else if (sc->sc_recrun) {
			(*sc->sc_rintr)(sc->sc_rarg);
			retval = 1;
d1518 2
a1520 3
	/* clear interrupt */
	ADWRITE(sc, AD1848_STATUS, 0);
    }
d1522 1
a1522 1
    return(retval);
d1526 1
a1526 6
ad1848_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool;
	int flags;
d1540 1
a1540 4
ad1848_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d1546 1
a1546 4
ad1848_round(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
d1554 1
a1554 5
ad1848_mappage(addr, mem, off, prot)
	void *addr;
        void *mem;
        off_t off;
	int prot;
d1560 1
a1560 2
ad1848_get_props(addr)
	void *addr;
d1565 1
a1565 1
	       (sc->mode == 2 ? AUDIO_PROP_FULLDUPLEX : 0);
@


1.34
log
@* use audio(9)'s DMA trigger methods instead of the init/start
  methods.  the AD1848 DMA engine runs continuously and doesn't
  need to be started/stopped or otherwise manipulated for each
  block.  makes the driver a bit more efficient.
* allow "Mode 2" capable chips such as the CS4231 to work in "Mode 1"
  when there is only one DMA channel, instead of forcing it into
  "Mode 2", which expects two DMA channels.  allows recording to
  work for "Mode 2" capable devices when there is only one DMA
  channel.
* service both playback and recording interrupts in full-duplex
  mode, instead of only playback interrupts.  allows "Mode 2"
  capable chips to work in full-duplex mode.
* fix checks for sample rate/format recalibration completion.  gets
  rid of busy loops that briefly "hang" the kernel when the device is
  opened and/or reconfigured.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.33 2007/11/05 00:17:28 jakemsr Exp $	*/
d1017 3
d1107 4
@


1.33
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.32 2005/05/22 19:40:51 art Exp $	*/
d96 1
a96 1
#define DPRINTF(x)	if (ad1848debug) printf x
d152 1
d158 1
d214 6
a219 2
     * 1) Wait until the chip becomes ready (reads don't return 0x80).
     * 2) Wait until the ACI bit of I11 gets on and then off.
d221 1
a221 1
    timeout = 100000;
d228 4
a231 11
    ADWRITE(sc, AD1848_IADDR, SP_TEST_AND_INIT);
    timeout = 100000;
    while (timeout > 0 && ADREAD(sc, AD1848_IADDR) != SP_TEST_AND_INIT)
	timeout--;

    if (ADREAD(sc, AD1848_IADDR) == SP_TEST_AND_INIT)
	DPRINTF(("ad1848: Auto calibration timed out(1.5).\n"));

    if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG)) {
	timeout = 100000;
	while (timeout > 0 && !(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))
d234 1
a234 1
	if (!(ad_read(sc, SP_TEST_AND_INIT) & AUTO_CAL_IN_PROG))
d236 1
d239 1
a239 1
    timeout = 100000;
d314 1
d464 2
d467 1
a467 1
		    sc->chip_name = "CS4232";
d475 1
d515 2
a516 3
    sc->sc_locked = 0;
    sc->sc_playrun = NOTRUNNING;
    sc->sc_recrun = NOTRUNNING;
d529 1
a529 1
		printf("ad1848_attach: can't creape map for drq %d\n",
d538 2
a539 2
        timeout = 100000;
        while (timeout > 0 && ad_read(sc, AD1848_IADDR) & SP_IN_INIT)
d542 7
d555 1
a555 1
			    timeout = 100000;
d557 1
a557 1
				   ad_read(sc, AD1848_IADDR) & SP_IN_INIT)
a584 1
#undef WAITREADY
d1065 1
a1065 1
	bits = FMT_ULAW >> 5;
d1068 1
a1068 1
	bits = FMT_ALAW >> 5;
d1071 1
a1071 1
	bits = FMT_ADPCM >> 5;
d1075 1
a1075 1
	    bits = FMT_TWOS_COMP >> 5;
d1081 1
a1081 1
	    bits = FMT_TWOS_COMP_BE >> 5;
d1087 1
a1087 1
	    bits = FMT_PCM8 >> 5;
a1162 4
    struct ad1848_softc *sc = addr;

    sc->sc_lastcc = -1;

d1178 2
a1179 3
    sc->sc_intr = 0;
    sc->sc_lastcc = -1;
    sc->sc_locked = 0;
d1186 1
a1186 1
    if (ad1848debug)
d1202 6
a1207 2
    
    sc->sc_intr = 0;
d1210 1
a1210 8
    if (sc->sc_playrun != NOTRUNNING) {
	isa_dmaabort(sc->sc_isa, sc->sc_drq);
	sc->sc_playrun = NOTRUNNING;
    }
    if (sc->sc_recrun != NOTRUNNING) {
	isa_dmaabort(sc->sc_isa, sc->sc_recdrq);
	sc->sc_recrun = NOTRUNNING;
    }
d1225 1
a1225 1
    if (ad1848debug)
d1251 1
a1251 1
    fs = sc->speed_bits | (sc->format_bits << 5);
d1270 1
a1270 1
	timeout = 100000;
d1285 1
a1285 1
    timeout = 100000;
a1300 2
    sc->sc_lastcc = -1;

a1319 4
    if (sc->mode == 2) {
	    ADWRITE(sc, AD1848_IADDR, CS_IRQ_STATUS);
	    ADWRITE(sc, AD1848_IDATA, 0);
    }
d1321 2
d1324 1
d1326 1
a1326 1
    if (ad1848debug)
d1408 1
a1408 1
ad1848_halt_out_dma(addr)
d1413 2
a1414 2
	
    DPRINTF(("ad1848: ad1848_halt_out_dma\n"));
d1418 5
a1422 1
    sc->sc_locked = 0;
d1428 1
a1428 1
ad1848_halt_in_dma(addr)
d1434 1
a1434 1
    DPRINTF(("ad1848: ad1848_halt_in_dma\n"));
d1438 5
a1442 1
    sc->sc_locked = 0;
d1448 1
a1448 22
ad1848_dma_init_input(addr, buf, cc)
    void *addr;
    void *buf;
    int cc;
{
    struct ad1848_softc *sc = addr;

    sc->sc_recrun = DMARUNNING;
    sc->sc_dma_flags = DMAMODE_READ | DMAMODE_LOOP;
    sc->sc_dma_bp = buf;
    sc->sc_dma_cnt = cc;
    isa_dmastart(sc->sc_isa, sc->sc_recdrq, buf, cc, NULL,
		 sc->sc_dma_flags, BUS_DMA_NOWAIT);
    DPRINTF(("ad1848_dma_init_input: %p %d\n", buf, cc));
    return 0;
}

/*
 * DMA input/output are called at splaudio().
 */
int
ad1848_dma_input(addr, p, cc, intr, arg)
d1450 2
a1451 2
    void *p;
    int cc;
d1454 1
d1458 5
d1464 15
a1478 3
    if (sc->sc_locked) {
	DPRINTF(("ad1848_dma_input: locked\n"));
	return 0;
a1479 34
    
#ifdef AUDIO_DEBUG
    if (ad1848debug > 1)
	printf("ad1848_dma_input: cc=%d %p (%p)\n", cc, intr, arg);
#endif
    sc->sc_locked = 1;
    sc->sc_intr = intr;
    sc->sc_arg = arg;

    switch (sc->sc_recrun) {
    case NOTRUNNING:
	sc->sc_dma_flags = DMAMODE_READ;
	sc->sc_dma_bp = p;
	sc->sc_dma_cnt = cc;
	isa_dmastart(sc->sc_isa, sc->sc_recdrq, p, cc, NULL,
		     DMAMODE_READ, BUS_DMA_NOWAIT);
	goto startpcm;
    case DMARUNNING:
	sc->sc_recrun = PCMRUNNING;
    startpcm:
	if (sc->precision == 16)
	    cc >>= 1;
	if (sc->channels == 2)
	    cc >>= 1;
	cc--;
    
	if (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_RECORD) {
	    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));
	    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));

	    if (sc->mode == 2) {
		ad_write(sc, CS_LOWER_REC_CNT, (u_char)(cc & 0xff));
		ad_write(sc, CS_UPPER_REC_CNT, (u_char)((cc >> 8) & 0xff));
	    }
d1481 2
a1482 2
	    reg = ad_read(sc, SP_INTERFACE_CONFIG);
	    ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE|reg));
a1483 2
	    sc->sc_lastcc = cc;
	    sc->sc_mode = AUMODE_RECORD;
d1485 2
a1486 2
	    if (ad1848debug > 1)
		    printf("ad1848_dma_input: started capture\n");
a1487 4
	}
    case PCMRUNNING:
	break;
    }
d1493 1
a1493 1
ad1848_dma_init_output(addr, buf, cc)
d1495 2
a1496 20
    void *buf;
    int cc;
{
    struct ad1848_softc *sc = addr;

    sc->sc_playrun = DMARUNNING;
    sc->sc_dma_flags = DMAMODE_WRITE | DMAMODE_LOOP;
    sc->sc_dma_bp = buf;
    sc->sc_dma_cnt = cc;
    isa_dmastart(sc->sc_isa, sc->sc_drq, buf, cc, NULL,
		 sc->sc_dma_flags, BUS_DMA_NOWAIT);
    DPRINTF(("ad1848_dma_init_output: %p %d\n", buf, cc));
    return 0;
}

int
ad1848_dma_output(addr, p, cc, intr, arg)
    void *addr;
    void *p;
    int cc;
d1499 1
d1504 15
a1518 5
    if (sc->sc_locked) {
	DPRINTF(("ad1848_dma_output: locked\n"));
	return 0;
    }
    
d1520 2
a1521 2
    if (ad1848debug > 0)
	printf("ad1848_dma_output: cc=%d at %p %p (%p)\n", cc, p, intr, arg);
a1522 35
    sc->sc_locked = 1;
    sc->sc_intr = intr;
    sc->sc_arg = arg;

    switch (sc->sc_playrun) {
    case NOTRUNNING:
	sc->sc_dma_flags = DMAMODE_WRITE;
	sc->sc_dma_bp = p;
	sc->sc_dma_cnt = cc;
	isa_dmastart(sc->sc_isa, sc->sc_drq, p, cc, NULL,
		     DMAMODE_WRITE, BUS_DMA_NOWAIT);
	goto startpcm;
    case DMARUNNING:
	sc->sc_playrun = PCMRUNNING;
    startpcm:
	if (sc->precision == 16)
	    cc >>= 1;
	if (sc->channels == 2)
	    cc >>= 1;
	cc--;

	if (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_PLAY) {
	    ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));
	    ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));

	    reg = ad_read(sc, SP_INTERFACE_CONFIG);
	    ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE|reg));

	    sc->sc_lastcc = cc;
	    sc->sc_mode = AUMODE_PLAY;
	}
	break;
    case PCMRUNNING:
	break;
    }
d1540 2
a1541 1
	printf("ad1848_intr: intr=%p status=%x\n", sc->sc_intr, status);
a1542 2
    sc->sc_locked = 0;
    sc->sc_interrupts++;
d1545 27
a1571 7
    if (sc->sc_intr && (status & INTERRUPT_STATUS)) {
	/* ACK DMA read because it may be in a bounce buffer */
	/* XXX Do write to mask DMA ? */
	if ((sc->sc_dma_flags & DMAMODE_READ) && sc->sc_recrun == NOTRUNNING)
	    isa_dmadone(sc->sc_isa, sc->sc_recdrq);
	(*sc->sc_intr)(sc->sc_arg);
	retval = 1;
a1573 4
    /* clear interrupt */
    if (status & INTERRUPT_STATUS)
	ADWRITE(sc, AD1848_STATUS, 0);

d1588 2
a1589 2
	if (sc->sc_mode == AUMODE_RECORD)
		drq = sc->sc_recdrq == -1 ? sc->sc_drq : sc->sc_recdrq;
d1591 1
a1591 1
		drq = sc->sc_drq;
d1633 1
a1633 1
	       (sc->sc_drq != sc->sc_recdrq ? AUDIO_PROP_FULLDUPLEX : 0);
@


1.32
log
@remove "0x" in front of %p in printfs.

eyeballed by krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.31 2005/04/15 13:05:14 mickey Exp $	*/
d1043 1
a1043 1
	    pswcode = rswcode = change_sign16;
d1049 2
a1050 2
	    pswcode = swap_bytes_change_sign16;
	    rswcode = change_sign16_swap_bytes;
@


1.31
log
@make sure aligment does not return zero block size
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.30 2004/01/09 21:32:23 brad Exp $	*/
d1565 1
a1565 1
	printf("ad1848_dma_output: cc=%d at %p 0x%p (0x%p)\n", cc, p, intr, arg);
@


1.30
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.29 2003/06/08 00:41:10 miod Exp $	*/
d1159 1
a1159 1
    blk &= -4;
@


1.29
log
@Do not hardcode the dma channel to 1, use the softc settings instead.
mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.28 2003/04/27 11:22:53 ho Exp $	*/
a82 1
#include <uvm/uvm_extern.h>
@


1.28
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.27 2003/02/11 19:20:27 mickey Exp $	*/
d1651 1
d1653 6
a1658 1
	return isa_malloc(sc->sc_isa, 1, size, pool, flags);
@


1.27
log
@be consistant on Hz vs hz
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.26 2002/06/14 21:34:59 todd Exp $	*/
d946 1
a946 1
	strcpy(fp->name, AudioEmulaw);
d952 1
a952 1
	strcpy(fp->name, AudioEalaw);
d958 1
a958 1
	strcpy(fp->name, AudioEslinear_le);
d964 1
a964 1
	strcpy(fp->name, AudioEulinear);
d971 1
a971 1
	strcpy(fp->name, AudioEslinear_be);
d979 1
a979 1
	strcpy(fp->name, AudioEslinear);
d985 1
a985 1
	strcpy(fp->name, AudioEulinear_le);
d991 1
a991 1
	strcpy(fp->name, AudioEulinear_be);
d1000 1
a1000 1
	strcpy(fp->name, AudioEadpcm);
@


1.26
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.25 2002/03/14 01:26:56 millert Exp $	*/
d1341 1
a1341 1
     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 Mhz) and other
@


1.25
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.24 2002/01/20 19:56:53 ericj Exp $	*/
d1268 1
a1268 1
	 * Write to I8 starts resyncronization. Wait until it completes.
d1283 1
a1283 1
     * Write to I8 starts resyncronization. Wait until it completes.
@


1.24
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.23 2001/11/06 19:53:19 miod Exp $	*/
d149 8
a156 8
void	ad1848_reset __P((struct ad1848_softc *));
int	ad1848_set_speed __P((struct ad1848_softc *, u_long *));
void	ad1848_mute_monitor __P((void *, int));

static int ad_read __P((struct ad1848_softc *, int));
static void ad_write __P((struct ad1848_softc *, int, int));
static void ad_set_MCE __P((struct ad1848_softc *, int));
static void wait_for_calibration __P((struct ad1848_softc *));
d248 1
a248 1
void ad1848_dump_regs __P((struct ad1848_softc *));
d774 1
a774 1
static ad1848_devmap_t *ad1848_mixer_find_dev __P((ad1848_devmap_t *, int, mixer_ctrl_t *));
d1020 2
a1021 2
    void (*pswcode) __P((void *, u_char *buf, int cnt));
    void (*rswcode) __P((void *, u_char *buf, int cnt));
d1468 1
a1468 1
    void (*intr) __P((void *));
d1553 1
a1553 1
    void (*intr) __P((void *));
@


1.23
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.22 2001/10/31 11:00:24 art Exp $	*/
d1643 1
a1643 1
ad1848_malloc(addr, size, pool, flags)
d1645 2
a1646 1
	unsigned long size;
d1664 2
a1665 2
unsigned long
ad1848_round(addr, size)
d1667 2
a1668 1
	unsigned long size;
@


1.23.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.24 2002/01/20 19:56:53 ericj Exp $	*/
d1643 1
a1643 1
ad1848_malloc(addr, direction, size, pool, flags)
d1645 1
a1645 2
	int direction;
	size_t size;
d1663 2
a1664 2
size_t
ad1848_round(addr, direction, size)
d1666 1
a1666 2
	int direction;
	size_t size;
@


1.23.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.23.2.1 2002/01/31 22:55:32 niklas Exp $	*/
d149 8
a156 8
void	ad1848_reset(struct ad1848_softc *);
int	ad1848_set_speed(struct ad1848_softc *, u_long *);
void	ad1848_mute_monitor(void *, int);

static int ad_read(struct ad1848_softc *, int);
static void ad_write(struct ad1848_softc *, int, int);
static void ad_set_MCE(struct ad1848_softc *, int);
static void wait_for_calibration(struct ad1848_softc *);
d248 1
a248 1
void ad1848_dump_regs(struct ad1848_softc *);
d774 1
a774 1
static ad1848_devmap_t *ad1848_mixer_find_dev(ad1848_devmap_t *, int, mixer_ctrl_t *);
d1020 2
a1021 2
    void (*pswcode)(void *, u_char *buf, int cnt);
    void (*rswcode)(void *, u_char *buf, int cnt);
d1468 1
a1468 1
    void (*intr)(void *);
d1553 1
a1553 1
    void (*intr)(void *);
@


1.23.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.23.2.2 2002/06/11 03:42:20 art Exp $	*/
d1268 1
a1268 1
	 * Write to I8 starts resynchronization. Wait until it completes.
d1283 1
a1283 1
     * Write to I8 starts resynchronization. Wait until it completes.
@


1.23.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d946 1
a946 1
	strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d952 1
a952 1
	strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d958 1
a958 1
	strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d964 1
a964 1
	strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d971 1
a971 1
	strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d979 1
a979 1
	strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d985 1
a985 1
	strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d991 1
a991 1
	strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1000 1
a1000 1
	strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
d1341 1
a1341 1
     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 MHz) and other
@


1.22
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.21 2001/04/12 07:51:56 csapuntz Exp $	*/
d83 1
a83 1
#include <vm/vm.h>
@


1.21
log
@

Call isa_malloc with drq < 4, in case 8-bit DMA channels with more
restrictive boundaries are used
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.20 2000/03/02 23:02:48 mickey Exp $	*/
d1673 1
a1673 1
int
d1677 1
a1677 1
        int off;
@


1.20
log
@protect more reads and rights^Wwrites w/ spl; avoid inline which blows the code in twice
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.19 1999/07/29 09:45:04 niklas Exp $	*/
d1651 1
a1651 1
	return isa_malloc(sc->sc_isa, 4, size, pool, flags);
@


1.19
log
@A probe that fails on an otherwise working card, removed
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.18 1999/07/19 19:47:05 deraadt Exp $	*/
d154 1
a154 1
static __inline void ad_write __P((struct ad1848_softc *, int, int));
d166 1
a166 1
    int x;
d168 1
d171 1
d177 1
a177 1
static __inline void
d183 1
d186 1
@


1.19.4.1
log
@Sync with -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
a154 1
static void ad_write __P((struct ad1848_softc *, int, int));
d166 1
a166 1
    int x, s;
a167 1
    s = splaudio();
a169 1
    splx(s);
d175 1
a175 1
static void
a180 1
    int s = splaudio();
a182 1
    splx(s);
@


1.19.4.2
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.21 2001/04/12 07:51:56 csapuntz Exp $	*/
d1651 1
a1651 1
	return isa_malloc(sc->sc_isa, 1, size, pool, flags);
@


1.19.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
a83 1
#include <uvm/uvm_extern.h>
d1673 1
a1673 1
paddr_t
d1677 1
a1677 1
        off_t off;
@


1.19.4.4
log
@Merge in trunk
@
text
@d1643 1
a1643 1
ad1848_malloc(addr, direction, size, pool, flags)
d1645 1
a1645 2
	int direction;
	size_t size;
d1663 2
a1664 2
size_t
ad1848_round(addr, direction, size)
d1666 1
a1666 2
	int direction;
	size_t size;
@


1.19.4.5
log
@Merge in -current from about a week ago
@
text
@d149 8
a156 8
void	ad1848_reset(struct ad1848_softc *);
int	ad1848_set_speed(struct ad1848_softc *, u_long *);
void	ad1848_mute_monitor(void *, int);

static int ad_read(struct ad1848_softc *, int);
static void ad_write(struct ad1848_softc *, int, int);
static void ad_set_MCE(struct ad1848_softc *, int);
static void wait_for_calibration(struct ad1848_softc *);
d248 1
a248 1
void ad1848_dump_regs(struct ad1848_softc *);
d774 1
a774 1
static ad1848_devmap_t *ad1848_mixer_find_dev(ad1848_devmap_t *, int, mixer_ctrl_t *);
d1020 2
a1021 2
    void (*pswcode)(void *, u_char *buf, int cnt);
    void (*rswcode)(void *, u_char *buf, int cnt);
d1468 1
a1468 1
    void (*intr)(void *);
d1553 1
a1553 1
    void (*intr)(void *);
@


1.19.4.6
log
@Sync the SMP branch with 3.3
@
text
@d1268 1
a1268 1
	 * Write to I8 starts resynchronization. Wait until it completes.
d1283 1
a1283 1
     * Write to I8 starts resynchronization. Wait until it completes.
d1341 1
a1341 1
     * LSB selects the clock source (0=24.576 MHz, 1=16.9344 MHz) and other
@


1.19.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.19.4.6 2003/03/28 00:38:15 niklas Exp $	*/
d946 1
a946 1
	strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d952 1
a952 1
	strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d958 1
a958 1
	strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d964 1
a964 1
	strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d971 1
a971 1
	strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d979 1
a979 1
	strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d985 1
a985 1
	strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d991 1
a991 1
	strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1000 1
a1000 1
	strlcpy(fp->name, AudioEadpcm, sizeof fp->name);
@


1.19.4.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d83 1
a1650 1
	int drq;
d1652 1
a1652 6
	if (sc->sc_mode == AUMODE_RECORD)
		drq = sc->sc_recdrq == -1 ? sc->sc_drq : sc->sc_recdrq;
	else
		drq = sc->sc_drq;

	return isa_malloc(sc->sc_isa, drq, size, pool, flags);
@


1.18
log
@further fixes for strange wss isapnp cards; apollo@@slcnet.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.17 1999/05/03 18:50:01 deraadt Exp $	*/
d304 1
d306 1
d399 6
d420 1
@


1.17
log
@support another version of the chipset
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.16 1999/01/24 15:58:53 mickey Exp $	*/
d407 4
a410 2
	    DPRINTF(("ad_detect_F(%d/%x/%x)\n", i, tmp1, tmp2));
	    goto bad;
@


1.16
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.15 1999/01/07 06:14:46 niklas Exp $	*/
d441 1
a441 1
       		case 0xA0:
d444 1
a444 1
       		case 0x80:
d448 2
a449 1
       		case 0x82:
@


1.15
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.14 1998/12/29 09:10:29 deraadt Exp $	*/
a80 1
#include <machine/pio.h>
@


1.14
log
@work around some ugly glitches
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.13 1998/07/16 22:37:44 deraadt Exp $	*/
a269 27
#ifdef NEWCONFIG
void
ad1848_forceintr(sc)
    struct ad1848_softc *sc;
{
    static char dmabuf;

    /*
     * Set up a DMA read of one byte.
     * XXX Note that at this point we haven't called 
     * at_setup_dmachan().  This is okay because it just
     * allocates a buffer in case it needs to make a copy,
     * and it won't need to make a copy for a 1 byte buffer.
     * (I think that calling at_setup_dmachan() should be optional;
     * if you don't call it, it will be called the first time
     * it is needed (and you pay the latency).  Also, you might
     * never need the buffer anyway.)
     */
    isa_dmastart(sc->sc_isa, sc->sc_drq, &dmabuf, 1, NULL,
	DMAMODE_READ, BUS_DMA_NOWAIT);

    ad_write(sc, SP_LOWER_BASE_COUNT, 0);
    ad_write(sc, SP_UPPER_BASE_COUNT, 0);
    ad_write(sc, SP_INTERFACE_CONFIG, PLAYBACK_ENABLE);
}
#endif
    
@


1.13
log
@recognize CS4236B; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.12 1998/07/15 22:18:22 deraadt Exp $	*/
d586 2
a587 1
    printf(": %s", sc->chip_name);
@


1.12
log
@Fix the name of the ulinear_be mode; netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.11 1998/05/08 18:37:18 csapuntz Exp $	*/
d478 3
@


1.11
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.10 1998/04/26 21:02:38 provos Exp $	*/
d999 1
a999 1
	strcpy(fp->name, AudioEulinear_le);
@


1.10
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.9 1998/01/18 18:58:36 niklas Exp $	*/
d141 2
a142 2
			/* Mono input (mic) Control */
    MONO_INPUT_MUTE|ATTEN_6,		/* mute mic by default */
d569 3
a571 3
    (void) ad1848_set_out_gain(sc, &vol_mid);
    (void) ad1848_set_mon_gain(sc, &vol_0);
    (void) ad1848_set_aux1_gain(sc, &vol_mid);	/* CD volume */
d573 4
a576 4
	/* aux1 was really the DAC output */
	(void) ad1848_set_aux2_gain(sc, &vol_mid); /* CD volume */
	(void) cs4231_set_linein_gain(sc, &vol_mid);
	(void) cs4231_set_mono_gain(sc, &vol_0); /* mic */
d578 1
a578 1
	(void) ad1848_set_aux2_gain(sc, &vol_0);
d590 30
a619 4
int
ad1848_set_rec_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
d621 3
a623 3
    u_char reg, gain;
    
    DPRINTF(("ad1848_set_rec_gain: %d:%d\n", gp->left, gp->right));
d625 11
a635 1
    sc->rec_gain = *gp;
d637 3
a639 4
    gain = (gp->left * GAIN_22_5)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_LEFT_INPUT_CONTROL);
    reg &= INPUT_GAIN_MASK;
    ad_write(sc, SP_LEFT_INPUT_CONTROL, (gain&0x0f)|reg);
d641 1
a641 4
    gain = (gp->right * GAIN_22_5)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_RIGHT_INPUT_CONTROL);
    reg &= INPUT_GAIN_MASK;
    ad_write(sc, SP_RIGHT_INPUT_CONTROL, (gain&0x0f)|reg);
d643 5
a647 1
    return(0);
a649 8
int
ad1848_get_rec_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->rec_gain;
    return(0);
}
d652 1
a652 1
ad1848_set_out_gain(sc, gp)
d654 1
d657 1
a659 2
    
    DPRINTF(("ad1848_set_out_gain: %d:%d\n", gp->left, gp->right));
d661 14
a674 1
    sc->out_gain = *gp;
d676 4
a679 9
    atten = ((AUDIO_MAX_GAIN - gp->left) * OUTPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_LEFT_OUTPUT_CONTROL);
    reg &= OUTPUT_ATTEN_MASK;
    ad_write(sc, SP_LEFT_OUTPUT_CONTROL, (atten&0x3f)|reg);

    atten = ((AUDIO_MAX_GAIN - gp->right) * OUTPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_RIGHT_OUTPUT_CONTROL);
    reg &= OUTPUT_ATTEN_MASK;
    ad_write(sc, SP_RIGHT_OUTPUT_CONTROL, (atten&0x3f)|reg);
a683 8
int
ad1848_get_out_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->out_gain;
    return(0);
}
d686 1
a686 1
ad1848_set_mon_gain(sc, gp)		/* monitor gain */
d688 1
d691 1
a691 11
    u_char reg;
    u_int atten;
    
    DPRINTF(("ad1848_set_mon_gain: %d\n", gp->left));

    sc->mon_gain = *gp;

    atten = ((AUDIO_MAX_GAIN - gp->left) * OUTPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_DIGITAL_MIX);
    reg &= MIX_ATTEN_MASK;
    ad_write(sc, SP_DIGITAL_MIX, (atten&OUTPUT_ATTEN_BITS)|reg);
d696 1
a696 1
ad1848_get_mon_gain(sc, gp)
d700 1
a700 1
    *gp = sc->mon_gain;
d705 1
a705 1
cs4231_set_mono_gain(sc, gp)
d709 1
a709 2
    u_char reg, oreg;
    u_int atten;
d711 1
a711 1
    DPRINTF(("cs4231_set_mono_gain: %d\n", gp->left));
d713 11
a723 1
    sc->mono_gain = *gp;
a724 5
    atten = ((AUDIO_MAX_GAIN - gp->left) * MONO_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    oreg = reg = ad_read(sc, CS_MONO_IO_CONTROL);
    reg &= MONO_INPUT_ATTEN_MASK;
    ad_write(sc, CS_MONO_IO_CONTROL, (atten&MONO_INPUT_ATTEN_BITS)|reg);
    DPRINTF(("cs4231_set_mono_gain: was:%x\n", oreg));
d728 5
a732 4
int
cs4231_get_mono_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
d734 11
a744 2
    *gp = sc->mono_gain;
    return(0);
d781 9
a789 4
void
ad1848_mute_monitor(addr, mute)
	void *addr;
	int mute;
d791 1
a791 1
	struct ad1848_softc *sc = addr;
d793 6
a798 9
	DPRINTF(("ad1848_mute_monitor: %smuting\n", mute ? "" : "un"));
	if (sc->mode == 2) {
		cs4231_mute_monitor(sc, mute);
		cs4231_mute_mono(sc, mute);
		cs4231_mute_line(sc, mute);
	}
		
	ad1848_mute_aux1(sc, mute);
	ad1848_mute_aux2(sc, mute);
d801 6
a806 4
void
cs4231_mute_monitor(sc, mute)
	struct ad1848_softc *sc;
	int mute;
d808 53
a860 15
	u_char reg;
	if (mute) {
		DPRINTF(("cs4231_mute_monitor: muting\n"));
		reg = ad_read(sc, SP_LEFT_OUTPUT_CONTROL);
		ad_write(sc, SP_LEFT_OUTPUT_CONTROL, OUTPUT_MUTE|reg);
		reg = ad_read(sc, SP_RIGHT_OUTPUT_CONTROL);
		ad_write(sc, SP_RIGHT_OUTPUT_CONTROL, OUTPUT_MUTE|reg);
	} else if (!sc->mon_mute) {
		DPRINTF(("cs4231_mute_monitor: unmuting\n"));
		reg = ad_read(sc, SP_LEFT_OUTPUT_CONTROL);
		ad_write(sc, SP_LEFT_OUTPUT_CONTROL, reg & ~OUTPUT_MUTE);
		reg = ad_read(sc, SP_RIGHT_OUTPUT_CONTROL);
		ad_write(sc, SP_RIGHT_OUTPUT_CONTROL, reg & ~OUTPUT_MUTE);
	}
}
d862 9
a870 16
void
cs4231_mute_mono(sc, mute)
    struct ad1848_softc *sc;
    int mute;
{
	u_char reg;
	if (mute) {
		DPRINTF(("cs4231_mute_mono: muting\n"));
		reg = ad_read(sc, CS_MONO_IO_CONTROL);
		ad_write(sc, CS_MONO_IO_CONTROL, MONO_INPUT_MUTE|reg);
	} else if (!sc->mono_mute) {
		DPRINTF(("cs4231_mute_mono: unmuting\n"));
		reg = ad_read(sc, CS_MONO_IO_CONTROL);
		ad_write(sc, CS_MONO_IO_CONTROL, reg & ~MONO_INPUT_MUTE);
	}
}
d872 1
a872 19
void
cs4231_mute_line(sc, mute)
    struct ad1848_softc *sc;
    int mute;
{
	u_char reg;
	if (mute) {
		DPRINTF(("cs4231_mute_line: muting\n"));
		reg = ad_read(sc, CS_LEFT_LINE_CONTROL);
		ad_write(sc, CS_LEFT_LINE_CONTROL, LINE_INPUT_MUTE|reg);
		reg = ad_read(sc, CS_RIGHT_LINE_CONTROL);
		ad_write(sc, CS_RIGHT_LINE_CONTROL, LINE_INPUT_MUTE|reg);
	} else if (!sc->line_mute) {
		DPRINTF(("cs4231_mute_line: unmuting\n"));
		reg = ad_read(sc, CS_LEFT_LINE_CONTROL);
		ad_write(sc, CS_LEFT_LINE_CONTROL, reg & ~LINE_INPUT_MUTE);
		reg = ad_read(sc, CS_RIGHT_LINE_CONTROL);
		ad_write(sc, CS_RIGHT_LINE_CONTROL, reg & ~LINE_INPUT_MUTE);
	}
d875 6
a880 4
void
ad1848_mute_aux1(sc, mute)
    struct ad1848_softc *sc;
    int mute;
d882 4
a885 15
	u_char reg;
	if (mute) {
		DPRINTF(("ad1848_mute_aux1: muting\n"));
		reg = ad_read(sc, SP_LEFT_AUX1_CONTROL);
		ad_write(sc, SP_LEFT_AUX1_CONTROL, AUX_INPUT_MUTE|reg);
		reg = ad_read(sc, SP_RIGHT_AUX1_CONTROL);
		ad_write(sc, SP_RIGHT_AUX1_CONTROL, AUX_INPUT_MUTE|reg);
	} else if (!sc->aux1_mute) {
		DPRINTF(("ad1848_mute_aux1: unmuting\n"));
		reg = ad_read(sc, SP_LEFT_AUX1_CONTROL);
		ad_write(sc, SP_LEFT_AUX1_CONTROL, reg & ~AUX_INPUT_MUTE);
		reg = ad_read(sc, SP_RIGHT_AUX1_CONTROL);
		ad_write(sc, SP_RIGHT_AUX1_CONTROL, reg & ~AUX_INPUT_MUTE);
	}
}
d887 2
a888 20
void
ad1848_mute_aux2(sc, mute)
    struct ad1848_softc *sc;
    int mute;
{
	u_char reg;
	if (mute) {
		DPRINTF(("ad1848_mute_aux2: muting\n"));
		reg = ad_read(sc, SP_LEFT_AUX2_CONTROL);
		ad_write(sc, SP_LEFT_AUX2_CONTROL, AUX_INPUT_MUTE|reg);
		reg = ad_read(sc, SP_RIGHT_AUX2_CONTROL);
		ad_write(sc, SP_RIGHT_AUX2_CONTROL, AUX_INPUT_MUTE|reg);
	} else if (!sc->aux2_mute) {
		DPRINTF(("ad1848_mute_aux2: unmuting\n"));
		reg = ad_read(sc, SP_LEFT_AUX2_CONTROL);
		ad_write(sc, SP_LEFT_AUX2_CONTROL, reg & ~AUX_INPUT_MUTE);
		reg = ad_read(sc, SP_RIGHT_AUX2_CONTROL);
		ad_write(sc, SP_RIGHT_AUX2_CONTROL, reg & ~AUX_INPUT_MUTE);
	}
}
d890 1
a890 11
int
ad1848_set_aux1_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    u_char reg;
    u_int atten;
    
    DPRINTF(("ad1848_set_aux1_gain: %d:%d\n", gp->left, gp->right));
	
    sc->aux1_gain = *gp;
d892 4
a895 9
    atten = ((AUDIO_MAX_GAIN - gp->left) * AUX_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_LEFT_AUX1_CONTROL);
    reg &= ~(AUX_INPUT_ATTEN_BITS);
    ad_write(sc, SP_LEFT_AUX1_CONTROL, (atten&0x1f)|reg);

    atten = ((AUDIO_MAX_GAIN - gp->right) * AUX_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_RIGHT_AUX1_CONTROL);
    reg &= ~(AUX_INPUT_ATTEN_BITS);
    ad_write(sc, SP_RIGHT_AUX1_CONTROL, (atten&0x1f)|reg);
d897 3
a899 2
    return(0);
}
d901 7
a907 8
int
ad1848_get_aux1_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->aux1_gain;
    return(0);
}
d909 2
a910 7
int
cs4231_set_linein_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    u_char reg, oregl, oregr;
    u_int atten;
d912 7
a918 3
    DPRINTF(("ad1848_set_linein_gain: %d:%d\n", gp->left, gp->right));
	
    sc->line_gain = *gp;
d920 3
a922 9
    atten = ((AUDIO_MAX_GAIN - gp->left) * LINE_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    oregl = reg = ad_read(sc, CS_LEFT_LINE_CONTROL);
    reg &= ~(LINE_INPUT_ATTEN_BITS);
    ad_write(sc, CS_LEFT_LINE_CONTROL, (atten&LINE_INPUT_ATTEN_BITS)|reg);

    atten = ((AUDIO_MAX_GAIN - gp->right) * LINE_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    oregr = reg = ad_read(sc, CS_RIGHT_LINE_CONTROL);
    reg &= ~(LINE_INPUT_ATTEN_BITS);
    ad_write(sc, CS_RIGHT_LINE_CONTROL, (atten&LINE_INPUT_ATTEN_BITS)|reg);
d924 2
a925 3
    DPRINTF(("ad1848_set_linein_gain: was %x:%x\n", oregl, oregr));
    return(0);
}
d927 3
a929 8
int
cs4231_get_linein_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->line_gain;
    return(0);
}
d931 2
a932 11
int
ad1848_set_aux2_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    u_char reg;
    u_int atten;
    
    DPRINTF(("ad1848_set_aux2_gain: %d:%d\n", gp->left, gp->right));
	
    sc->aux2_gain = *gp;
d934 6
a939 9
    atten = ((AUDIO_MAX_GAIN - gp->left) * AUX_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_LEFT_AUX2_CONTROL);
    reg &= ~(AUX_INPUT_ATTEN_BITS);
    ad_write(sc, SP_LEFT_AUX2_CONTROL, (atten&0x1f)|reg);

    atten = ((AUDIO_MAX_GAIN - gp->right) * AUX_INPUT_ATTEN_BITS)/AUDIO_MAX_GAIN;
    reg = ad_read(sc, SP_RIGHT_AUX2_CONTROL);
    reg &= ~(AUX_INPUT_ATTEN_BITS);
    ad_write(sc, SP_RIGHT_AUX2_CONTROL, (atten&0x1f)|reg);
d941 1
a941 1
    return(0);
a943 8
int
ad1848_get_aux2_gain(sc, gp)
    struct ad1848_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->aux2_gain;
    return 0;
}
@


1.9
log
@move to current OpenBSD isadma API
@
text
@d1 2
a2 2
/*	$OpenBSD: ad1848.c,v 1.8 1997/07/10 23:06:31 provos Exp $	*/
/*	$NetBSD: ad1848.c,v 1.10 1996/04/29 20:02:32 christos Exp $	*/
a69 5
/*
 * Todo:
 * - Need datasheet for CS4231 (for use with GUS MAX)
 * - Use fast audio_dma
 */
d80 1
d84 2
d87 1
d98 1
a98 2
extern void Dprintf __P((const char *, ...));
#define DPRINTF(x)	if (ad1848debug) Dprintf x
d145 1
d151 1
a151 1
int	ad1848_set_speed __P((struct ad1848_softc *, u_long));
d159 2
d169 2
a170 2
    outb(sc->sc_iobase+AD1848_IADDR, (u_char) (reg & 0xff) | sc->MCE_bit);
    x = inb(sc->sc_iobase+AD1848_IDATA);
d182 2
a183 2
    outb(sc->sc_iobase+AD1848_IADDR, (u_char) (reg & 0xff) | sc->MCE_bit);
    outb(sc->sc_iobase+AD1848_IDATA, (u_char) (data & 0xff));
d197 1
a197 1
    outb(sc->sc_iobase+AD1848_IADDR, sc->MCE_bit);
d204 1
a204 1
    int timeout = 100000;
d213 2
a214 1
    while (timeout > 0 && inb(sc->sc_iobase+AD1848_IADDR) == SP_IN_INIT)
d217 1
a217 1
    if (inb(sc->sc_iobase+AD1848_IADDR) == SP_IN_INIT)
d220 1
a220 1
    outb(sc->sc_iobase+AD1848_IADDR, SP_TEST_AND_INIT);
d222 1
a222 1
    while (timeout > 0 && inb(sc->sc_iobase+AD1848_IADDR) != SP_TEST_AND_INIT)
d225 1
a225 1
    if (inb(sc->sc_iobase+AD1848_IADDR) == SP_TEST_AND_INIT)
d254 1
a254 1
    printf("ad1848 status=%02x", inb(sc->sc_iobase+AD1848_STATUS));
a264 1
	    printf("\n");
d266 1
d288 2
a289 1
    isadma_start(&dmabuf, 1, sc->sc_drq, DMAMODE_READ);
d298 1
a298 1
 * Probe for the ad1848 chip
d301 1
a301 1
ad1848_probe(sc)
d303 1
a304 4
    register int iobase = sc->sc_iobase;
    u_char tmp, tmp1 = 0xff, tmp2 = 0xff;
    int i;
    
d312 11
a322 1
    sc->sc_iobase = iobase;
d324 10
d347 2
a348 1
    if (((tmp = inb(iobase+AD1848_IADDR)) & SP_IN_INIT) != 0x00) { /* Not a AD1848 */
d352 1
a352 1
	return 0;
d366 1
a366 1
	return 0;
d375 1
a375 1
	return 0;
d387 1
a387 1
	return 0;
d436 1
a436 1
	    return 0;
d459 1
a459 1
		return 0;
d486 2
a487 1
    while(inb(sc->sc_iobase+AD1848_IADDR) & SP_IN_INIT);
d490 3
a492 2
    outb(sc->sc_iobase+AD1848_IADDR, SP_TEST_AND_INIT);
    while(inb(sc->sc_iobase+AD1848_IDATA) & AUTO_CAL_IN_PROG);
d495 10
d516 1
a516 1
    struct ad1848_volume vol_mid = {150, 150};
d518 2
d522 19
d543 1
a543 1
    for (i = 0; i < 16; i++)
d545 4
d552 2
a553 2
	    for (i = 0x10; i <= 0x1f; i++)
		    if (ad1848_init_values[i] != 0)
d555 5
d563 3
a565 5
    /* Set default parameters (mono, 8KHz, ULAW) */
    (void) ad1848_set_channels(sc, 1);
    (void) ad1848_set_speed(sc, 8000);
    (void) ad1848_set_format(sc, AUDIO_ENCODING_ULAW, 8);
    (void) ad1848_commit_settings(sc);
d584 1
d592 1
a592 1
    register struct ad1848_softc *sc;
d595 1
a595 1
    register u_char reg, gain;
d616 1
a616 1
    register struct ad1848_softc *sc;
d625 1
a625 1
    register struct ad1848_softc *sc;
d650 1
a650 1
    register struct ad1848_softc *sc;
d659 1
a659 1
    register struct ad1848_softc *sc;
d678 1
a678 1
    register struct ad1848_softc *sc;
d687 1
a687 1
    register struct ad1848_softc *sc;
d707 1
a707 1
    register struct ad1848_softc *sc;
d716 1
a716 1
    register struct ad1848_softc *sc;
d738 1
a738 1
    register struct ad1848_softc *sc;
d753 1
a753 1
	register struct ad1848_softc *sc = addr;
d768 1
a768 1
	register struct ad1848_softc *sc;
d789 1
a789 1
    register struct ad1848_softc *sc;
d806 1
a806 1
    register struct ad1848_softc *sc;
d827 1
a827 1
    register struct ad1848_softc *sc;
d848 1
a848 1
    register struct ad1848_softc *sc;
d869 1
a869 1
    register struct ad1848_softc *sc;
d894 1
a894 1
    register struct ad1848_softc *sc;
d903 1
a903 1
    register struct ad1848_softc *sc;
d929 1
a929 1
    register struct ad1848_softc *sc;
d938 1
a938 1
    register struct ad1848_softc *sc;
d963 1
a963 1
    register struct ad1848_softc *sc;
a970 42
ad1848_set_in_sr(addr, sr)
    void *addr;
    u_long sr;
{
    register struct ad1848_softc *sc = addr;

    DPRINTF(("ad1848_set_in_sr: %d\n", sr));

    return (ad1848_set_speed(sc, sr));
}

u_long
ad1848_get_in_sr(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;

    return (sc->speed);
}

int
ad1848_set_out_sr(addr, sr)
    void *addr;
    u_long sr;
{
    register struct ad1848_softc *sc = addr;

    DPRINTF(("ad1848_set_out_sr: %d\n", sr));

    return (ad1848_set_speed(sc, sr));
}

u_long
ad1848_get_out_sr(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;

    return (sc->speed);
}

int
d975 2
d980 3
a982 1
	fp->format_id = AUDIO_ENCODING_ULAW;
d986 3
a988 1
	fp->format_id = AUDIO_ENCODING_ALAW;
d991 4
a994 2
	strcpy(fp->name, AudioEpcm16);
	fp->format_id = AUDIO_ENCODING_PCM16;
d997 40
a1036 2
	strcpy(fp->name, AudioEpcm8);
	fp->format_id = AUDIO_ENCODING_PCM8;
d1039 1
a1039 1
	return(EINVAL);
d1046 1
a1046 1
ad1848_set_format(addr, encoding, precision)
d1048 2
a1049 1
    u_int encoding, precision;
d1051 38
a1088 13
    register struct ad1848_softc *sc = addr;
    static u_char format2bits[] =  {
      /* AUDIO_ENCODING_NONE */   0,
      /* AUDIO_ENCODING_ULAW */   FMT_ULAW >> 5,
      /* AUDIO_ENCODING_ALAW */   FMT_ALAW >> 5, 
      /* AUDIO_ENCODING_PCM16 */  FMT_TWOS_COMP >> 5,
      /* AUDIO_ENCODING_PCM8 */   FMT_PCM8 >> 5,
      /* AUDIO_ENCODING_ADPCM */  0,
    };

    DPRINTF(("ad1848_set_format: encoding=%d precision=%d\n", encoding, precision));
    
    switch (encoding) {
d1090 2
d1093 22
a1114 2
    case AUDIO_ENCODING_PCM16:
    case AUDIO_ENCODING_PCM8:
d1117 1
a1117 1
	return (EINVAL);
d1120 2
a1121 4
    sc->encoding = encoding;
    sc->precision = precision;
    sc->format_bits = format2bits[encoding];
    sc->need_commit = 1;
d1123 3
a1125 1
    DPRINTF(("ad1848_set_format: bits=%x\n", sc->format_bits));
d1127 2
a1128 29
    return (0);
}

int
ad1848_get_encoding(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;

    return (sc->encoding);
}

int
ad1848_get_precision(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;

    return (sc->precision);
}

int
ad1848_set_channels(addr, channels)
    void *addr;
    int channels;
{
    register struct ad1848_softc *sc = addr;
	
    DPRINTF(("ad1848_set_channels: %d\n", channels));
d1130 3
a1132 4
    if (channels != 1 && channels != 2)
	return (EINVAL);

    sc->channels = channels;
d1135 1
a1139 9
ad1848_get_channels(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;

    return (sc->channels);
}

int
d1141 1
a1141 1
    register struct ad1848_softc *sc;
d1178 1
a1178 1
    register struct ad1848_softc *sc;
d1188 1
a1188 1
    register struct ad1848_softc *sc = addr;
d1192 2
a1193 6
    /* Don't try to DMA too much at once. */
    if (blk > NBPG)
	blk = NBPG;

    /* Round to a multiple of the sample size. */
    blk &= -(sc->channels * sc->precision / 8);
d1199 2
a1200 3
ad1848_open(sc, dev, flags)
    struct ad1848_softc *sc;
    dev_t dev;
d1203 3
a1205 1
    DPRINTF(("ad1848_open: sc=0x%x\n", sc));
d1231 1
a1231 1
    register u_char r;
d1236 8
d1249 2
a1250 1
    ad_write(sc, SP_PIN_CONTROL, ad_read(sc, SP_PIN_CONTROL) & ~(INTERRUPT_ENABLE));
d1298 2
a1299 2
	(void) inb(sc->sc_iobase+AD1848_IDATA);
	(void) inb(sc->sc_iobase+AD1848_IDATA);
d1304 1
a1304 1
	while (timeout > 0 && inb(sc->sc_iobase+AD1848_IADDR) == SP_IN_INIT)
d1311 2
a1312 2
	(void) inb(sc->sc_iobase+AD1848_IDATA);
	(void) inb(sc->sc_iobase+AD1848_IDATA);
d1319 1
a1319 1
    while (timeout > 0 && inb(sc->sc_iobase+AD1848_IADDR) == SP_IN_INIT)
d1322 1
a1322 1
    if (inb(sc->sc_iobase+AD1848_IADDR) == SP_IN_INIT)
d1344 1
a1344 1
    register struct ad1848_softc *sc;
d1356 2
a1357 2
	    outb(sc->sc_iobase+AD1848_IADDR, CS_IRQ_STATUS);
	    outb(sc->sc_iobase+AD1848_IDATA, 0);
d1360 1
a1360 1
    outb(sc->sc_iobase+AD1848_STATUS, 0);
d1368 3
a1370 3
ad1848_set_speed(sc, arg)
    register struct ad1848_softc *sc;
    u_long arg;
d1384 1
a1432 1
    sc->speed = speed_table[selected].speed;
d1435 1
d1447 1
a1447 1
    register struct ad1848_softc *sc = addr;
d1463 1
a1463 1
    register struct ad1848_softc *sc = addr;
d1476 1
a1476 1
ad1848_cont_out_dma(addr)
d1478 2
d1481 1
a1481 4
    register struct ad1848_softc *sc = addr;
    u_char reg;
	
    DPRINTF(("ad1848: ad1848_cont_out_dma %s\n", sc->sc_locked?"(locked)":""));
d1483 8
a1490 19
    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (reg | PLAYBACK_ENABLE));

    return(0);
}

int
ad1848_cont_in_dma(addr)
    void *addr;
{
    register struct ad1848_softc *sc = addr;
    u_char reg;
	
    DPRINTF(("ad1848: ad1848_cont_in_dma %s\n", sc->sc_locked?"(locked)":""));

    reg = ad_read(sc, SP_INTERFACE_CONFIG);
    ad_write(sc, SP_INTERFACE_CONFIG, (reg | CAPTURE_ENABLE));

    return(0);
d1504 2
a1505 2
    register struct ad1848_softc *sc = addr;
    register u_char reg;
d1514 1
a1514 1
	Dprintf("ad1848_dma_input: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
a1518 4
    sc->sc_dma_flags = DMAMODE_READ;
    sc->sc_dma_bp = p;
    sc->sc_dma_cnt = cc;
    isadma_start(p, cc, sc->sc_recdrq, DMAMODE_READ);
d1520 25
a1544 10
    if (sc->precision == 16)
	cc >>= 1;
	
    if (sc->channels == 2)
	cc >>= 1;
    cc--;
    
    if (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_RECORD) {
	ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));
	ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));
d1546 2
a1547 4
	if (sc->mode == 2) {
	    ad_write(sc, CS_LOWER_REC_CNT, (u_char)(cc & 0xff));
	    ad_write(sc, CS_UPPER_REC_CNT, (u_char)((cc >> 8) & 0xff));
        }
d1549 9
a1557 5
	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (CAPTURE_ENABLE|reg));

	sc->sc_lastcc = cc;
	sc->sc_mode = AUMODE_RECORD;
d1564 18
d1589 2
a1590 2
    register struct ad1848_softc *sc = addr;
    register u_char reg;
d1598 2
a1599 2
    if (ad1848debug > 1)
	Dprintf("ad1848_dma_output: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
a1603 11
    sc->sc_dma_flags = DMAMODE_WRITE;
    sc->sc_dma_bp = p;
    sc->sc_dma_cnt = cc;
    isadma_start(p, cc, sc->sc_drq, DMAMODE_WRITE);
    
    if (sc->precision == 16)
	cc >>= 1;
	
    if (sc->channels == 2)
	cc >>= 1;
    cc--;
d1605 30
a1634 7
    if (sc->sc_lastcc != cc || sc->sc_mode != AUMODE_PLAY) {
	ad_write(sc, SP_LOWER_BASE_COUNT, (u_char)(cc & 0xff));
	ad_write(sc, SP_UPPER_BASE_COUNT, (u_char)((cc >> 8) & 0xff));
	reg = ad_read(sc, SP_INTERFACE_CONFIG);
	ad_write(sc, SP_INTERFACE_CONFIG, (PLAYBACK_ENABLE|reg));
	sc->sc_lastcc = cc;
	sc->sc_mode = AUMODE_PLAY;
d1644 1
a1644 1
    register struct ad1848_softc *sc = arg;
d1649 1
a1649 1
    status = inb(sc->sc_iobase+AD1848_STATUS);
d1653 1
a1653 1
	Dprintf("ad1848_intr: intr=0x%x status=%x\n", sc->sc_intr, status);
d1662 2
a1663 2
	if (sc->sc_dma_flags & DMAMODE_READ)
	    isadma_done(sc->sc_recdrq);
d1670 1
a1670 1
	outb(sc->sc_iobase+AD1848_STATUS, 0);
d1673 51
@


1.8
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.6 1996/07/04 21:00:57 deraadt Exp $	*/
d286 1
a286 1
    isa_dmastart(DMAMODE_READ, &dmabuf, 1, sc->sc_drq);
d1449 1
a1449 1
    isa_dmastart(DMAMODE_READ, p, cc, sc->sc_recdrq);
d1503 1
a1503 1
    isa_dmastart(DMAMODE_WRITE, p, cc, sc->sc_drq);
d1547 1
a1547 1
	    isa_dmadone(sc->sc_dma_flags, sc->sc_dma_bp, sc->sc_dma_cnt - 1, sc->sc_recdrq);
@


1.7
log
@silence probe more
@
text
@d110 1
a110 1
    			/* Left Input Control */
d112 1
a112 1
    			/* Right Input Control */
d119 3
a121 3
    0x19,		/* Left DAC output Control */
    0x19,		/* Right DAC output Control */
    			/* Clock and Data Format */
d123 1
a123 1
    			/* Interface Config */
d127 1
a127 1
    0xca,		/* Misc control */
d132 1
a132 1
    /* Thse are for CS4231 only (additional registers): */
d143 1
a143 1
    			/* Mono input (mic) Control */
d148 1
a148 2
    0,			/* lower record count */

d152 1
a152 2
int	ad1848_set_speed __P((struct ad1848_softc *, int));
int	ad1848_set_format __P((struct ad1848_softc *, int, int)); 
d243 2
d252 1
a252 1
    printf("ad1848 status=%x", inb(sc->sc_iobase+AD1848_STATUS));
d256 1
a256 1
	printf("%x ", r);
d258 1
a258 1
    if (sc->mode == 2)
d261 1
a261 1
		    printf("%x ", r);
d263 2
a264 1
    printf("\n");
d306 3
a308 1
	printf("ad1848: configured iobase %x invalid\n", iobase);
d493 2
a494 6
#if 0
	    ad_write(sc, SP_INTERFACE_CONFIG, 0); /* disable SINGLE_DMA feature */
#else
	    /* XXX SINGLE_DMA is cleared in ad1848_reset(), due to #if 0 */
#endif
	    for (i = 0x10; i <= 0x1F; i++)
d500 5
a504 7
    /* Set default encoding (ULAW) */
    sc->sc_irate = sc->sc_orate = 8000;
    sc->precision = 8;
    sc->channels = 1;
    sc->encoding = AUDIO_ENCODING_ULAW;
    (void) ad1848_set_in_sr(sc, sc->sc_irate);
    (void) ad1848_set_out_sr(sc, sc->sc_orate);
d917 1
a917 3
    sc->sc_irate = sc->sc_orate = ad1848_set_speed(sc, sr);

    return(0);
d926 1
a926 1
    return(sc->sc_irate);
d938 1
a938 3
    sc->sc_irate = sc->sc_orate = ad1848_set_speed(sc, sr);

    return(0);
d947 1
a947 1
    return(sc->sc_orate);
d980 1
a980 1
ad1848_set_encoding(addr, enc)
d982 1
a982 1
    u_int enc;
d985 8
a992 2
	
    DPRINTF(("ad1848_set_encoding: %d\n", enc));
d994 9
a1002 6
    if (sc->encoding != AUDIO_ENCODING_PCM8 &&
	sc->encoding != AUDIO_ENCODING_PCM16 &&
	sc->encoding != AUDIO_ENCODING_ALAW &&
	sc->encoding != AUDIO_ENCODING_ULAW) {

	sc->encoding = AUDIO_ENCODING_PCM8;
d1006 4
a1009 1
    sc->encoding = ad1848_set_format(sc, enc, sc->precision);
d1011 1
a1011 4
    if (sc->encoding == -1) {
	sc->encoding = AUDIO_ENCODING_PCM8;
	return (EINVAL);
    }
d1022 1
a1022 21
    return(sc->encoding);
}

int
ad1848_set_precision(addr, prec)
    void *addr;
    u_int prec;
{
    register struct ad1848_softc *sc = addr;
	
    DPRINTF(("ad1848_set_precision: %d\n", prec));

    sc->encoding = ad1848_set_format(sc, sc->encoding, prec);
    if (sc->encoding == -1) {
	sc->encoding = AUDIO_ENCODING_PCM16;
	sc->precision = 16;
	return (EINVAL);
    }
    sc->precision = prec;
	
    return (0);
d1031 1
a1031 1
    return(sc->precision);
d1035 1
a1035 1
ad1848_set_channels(addr, chans)
d1037 1
a1037 1
    int chans;
d1041 1
a1041 1
    DPRINTF(("ad1848_set_channels: %d\n", chans));
d1043 2
a1044 2
    if (chans < 1 || chans > 2)
	return(EINVAL);
d1046 2
a1047 1
    sc->channels = chans;
d1049 1
a1049 1
    return(0);
d1058 1
a1058 1
    return(sc->channels);
d1114 1
a1114 4
    /* Higher speeds need bigger blocks to avoid popping and silence gaps. */
    if ((sc->sc_orate > 8000 || sc->sc_irate > 8000) && blk < NBPG/2)
	    blk = NBPG/2;
    /* don't try to DMA too much at once, though. */
d1118 2
a1119 5
    if (sc->channels == 2)
	return (blk & ~1); /* must be even to preserve stereo separation */
    else
	return(blk);	/* Anything goes :-) */
}
d1121 1
a1121 24
u_int
ad1848_get_silence(enc)
    int enc;
{
#define ULAW_SILENCE	0x7f
#define ALAW_SILENCE	0x55
#define LINEAR_SILENCE	0
    u_int auzero;
    
    switch (enc) {
    case AUDIO_ENCODING_ULAW:
	auzero = ULAW_SILENCE; 
	break;
    case AUDIO_ENCODING_ALAW:
	auzero = ALAW_SILENCE;
	break;
    case AUDIO_ENCODING_PCM8:
    case AUDIO_ENCODING_PCM16:
    default:
	auzero = LINEAR_SILENCE;
	break;
    }

    return(auzero);
a1123 1

d1189 6
a1194 1
    int s = splaudio();
d1254 1
a1261 1
#if 0
a1262 1
#endif
a1266 1
#if 0
d1270 1
a1270 3
#else
    ad_write(sc, SP_INTERFACE_CONFIG, 0);
#endif
d1286 1
a1286 1
    int arg;
d1302 15
a1316 15
    {5510, (0 << 1) | 1},
    {5510, (0 << 1) | 1},
    {6620, (7 << 1) | 1},
    {8000, (0 << 1) | 0},
    {9600, (7 << 1) | 0},
    {11025, (1 << 1) | 1},
    {16000, (1 << 1) | 0},
    {18900, (2 << 1) | 1},
    {22050, (3 << 1) | 1},
    {27420, (2 << 1) | 0},
    {32000, (3 << 1) | 0},
    {33075, (6 << 1) | 1},
    {37800, (4 << 1) | 1},
    {44100, (5 << 1) | 1},
    {48000, (6 << 1) | 0}
d1350 1
d1352 1
a1352 39
    return sc->speed;
}

int
ad1848_set_format(sc, fmt, prec)
    register struct ad1848_softc *sc;
    int fmt, prec;
{
    static u_char format2bits[] =  {
      /* AUDIO_ENCODING_ULAW */   FMT_ULAW >> 5,
      /* AUDIO_ENCODING_ALAW */   FMT_ALAW >> 5, 
      /* AUDIO_ENCODING_PCM16 */  FMT_TWOS_COMP >> 5,
      /* AUDIO_ENCODING_PCM8 */   FMT_PCM8 >> 5
    };

    DPRINTF(("ad1848_set_format: fmt=%d prec=%d\n", fmt, prec));
    
    /* If not linear; force prec to 8bits */
    if (fmt != AUDIO_ENCODING_PCM16 && prec == 16)
	prec = 8;

    if (fmt < AUDIO_ENCODING_ULAW || fmt > AUDIO_ENCODING_PCM8)
	goto nogood;

    if (prec != 8 && prec != 16)
	goto nogood;
    
    sc->format_bits = format2bits[fmt-1];

    if (fmt == AUDIO_ENCODING_PCM16 && prec == 8)
	sc->format_bits = FMT_PCM8 >> 5;	/* signed vs. unsigned samples? */

    DPRINTF(("ad1848_set_format: bits=%x\n", sc->format_bits));

    return fmt;

 nogood:
    sc->format_bits = 0;
    return -1;
@


1.6
log
@fix recording; from jabaker@@grail.cba.csuohio.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.5 1996/05/07 07:35:55 deraadt Exp $	*/
d325 1
d327 1
@


1.5
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848.c,v 1.4 1996/04/18 23:47:28 niklas Exp $	*/
d122 1
a122 1
    CLOCK_XTAL1|FMT_PCM8|AUTO_CAL_ENABLE,
d124 1
a124 1
    SINGLE_DMA,
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: ad1848.c,v 1.3 1996/03/08 16:42:45 niklas Exp $	*/
/*	$NetBSD: ad1848.c,v 1.9 1996/03/01 04:08:24 mycroft Exp $	*/
a151 3
int	ad1848_probe();
void	ad1848_attach();

d154 8
d177 1
a177 1
static __inline__ void
a476 1
    register int iobase = sc->sc_iobase;
a658 1
    u_int atten;
a1055 1
    int mode;
d1301 1
d1303 1
d1509 1
a1509 1
    void (*intr)();
a1512 1
    register int iobase;
d1563 1
a1563 1
    void (*intr)();
a1566 1
    register int iobase;
@


1.3
log
@From NetBSD: merge of 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ad1848.c,v 1.8 1996/02/05 21:32:26 scottr Exp $	*/
d280 1
a280 1
    isa_dmastart(B_READ, &dmabuf, 1, sc->sc_drq);
d1524 1
a1524 1
    sc->sc_dma_flags = B_READ;
d1527 1
a1527 1
    isa_dmastart(B_READ, p, cc, sc->sc_recdrq);
d1579 1
a1579 1
    sc->sc_dma_flags = B_WRITE;
d1582 1
a1582 1
    isa_dmastart(B_WRITE, p, cc, sc->sc_drq);
d1625 1
a1625 1
	if (sc->sc_dma_flags & B_READ)
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d1 2
a2 1
/*	$NetBSD: ad1848.c,v 1.7 1995/11/10 04:30:36 mycroft Exp $	*/
d1128 1
a1128 2
    if ((sc->sc_orate > 8000 || sc->sc_irate > 8000) &&
	(blk > NBPG/2 || blk < NBPG/4))
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ad1848.c,v 1.6 1995/07/07 02:11:51 brezak Exp $	*/
d294 1
a294 1
    register u_short iobase = sc->sc_iobase;
d471 1
a471 1
    register u_short iobase = sc->sc_iobase;
d1509 1
a1509 1
    register u_short iobase;
d1564 1
a1564 1
    register u_short iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
