head	1.38;
access;
symbols
	SMP_SYNC_A:1.38
	SMP_SYNC_B:1.38
	UBC_SYNC_A:1.38
	UBC_SYNC_B:1.38
	SMP:1.38.0.2
	kame_19991208:1.37
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.36.0.2
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.27.0.2
	OPENBSD_2_3_BASE:1.27
	OPENBSD_2_2:1.23.0.2
	OPENBSD_2_2_BASE:1.23
	OPENBSD_2_1:1.18.0.2
	OPENBSD_2_1_BASE:1.18
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12;
locks; strict;
comment	@ * @;


1.38
date	99.12.11.21.25.07;	author csapuntz;	state dead;
branches;
next	1.37;

1.37
date	99.06.28.22.35.24;	author ho;	state Exp;
branches;
next	1.36;

1.36
date	99.01.11.01.57.52;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.09.15.01.40.08;	author downsj;	state Exp;
branches;
next	1.34;

1.34
date	98.09.14.01.55.52;	author downsj;	state Exp;
branches;
next	1.33;

1.33
date	98.08.08.23.01.06;	author downsj;	state Exp;
branches;
next	1.32;

1.32
date	98.07.23.04.40.12;	author csapuntz;	state Exp;
branches;
next	1.31;

1.31
date	98.07.09.05.37.21;	author downsj;	state Exp;
branches;
next	1.30;

1.30
date	98.07.07.19.15.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	98.07.05.07.20.02;	author downsj;	state Exp;
branches;
next	1.28;

1.28
date	98.04.28.05.41.08;	author angelos;	state Exp;
branches;
next	1.27;

1.27
date	98.02.22.00.38.40;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	98.01.18.18.48.40;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.12.10.23.02.01;	author rees;	state Exp;
branches;
next	1.24;

1.24
date	97.11.22.20.23.53;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	97.08.07.10.24.25;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	97.07.06.18.10.18;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	97.07.04.19.22.19;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	97.07.04.19.17.56;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	97.07.04.17.02.04;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	97.02.24.05.50.46;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	96.11.29.22.55.09;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.11.28.08.23.39;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	96.11.23.21.46.49;	author kstailey;	state Exp;
branches;
next	1.14;

1.14
date	96.11.12.20.30.45;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	96.11.06.09.43.10;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.09.22.09.02.33;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	96.09.22.05.16.40;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	96.09.16.02.38.20;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	96.09.16.02.36.08;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.09.11.07.27.03;	author downsj;	state Exp;
branches;
next	1.7;

1.7
date	96.09.09.05.29.16;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.09.04.00.51.15;	author downsj;	state Exp;
branches;
next	1.5;

1.5
date	96.08.17.06.24.54;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.08.12.05.21.20;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.08.07.01.53.02;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.09.08.59.56;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.08.09.12.45;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.38
log
@

Remove old IDE driver
@
text
@/*	$OpenBSD: wdc.c,v 1.37 1999/06/28 22:35:24 ho Exp $	*/
/*	$NetBSD: wd.c,v 1.150 1996/05/12 23:54:03 mycroft Exp $ */

/*
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * DMA and multi-sector PIO handling are derived from code contributed by
 * Onno van der Linden.
 *
 * Atapi support added by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "isadma.h"

/* #undef ATAPI_DEBUG_WDC */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/proc.h>

#include <vm/vm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#if NISADMA > 0
#include <dev/isa/isadmavar.h>
#endif /* NISADMA > 0 */
#include <dev/isa/wdreg.h>
#include <dev/isa/wdlink.h>

#include "wdc.h"

#include "atapibus.h"
#if NATAPIBUS > 0
#include <dev/atapi/atapilink.h>
#endif	/* NATAPIBUS */

#define	WAITTIME	(10 * hz)	/* time to wait for a completion */
	/* this is a lot for hard drives, but not for cdroms */
#define RECOVERYTIME hz/2
#define WDCDELAY	100
#define WDCNDELAY	100000	/* delay = 100us; so 10s for a controller state change */
#if 0
/* If you enable this, it will report any delays more than 100us * N long. */
#define WDCNDELAY_DEBUG	50
#endif

#define	WDIORETRIES	3		/* number of retries before giving up */

#define	WDPART(dev)			DISKPART(dev)

LIST_HEAD(xfer_free_list, wdc_xfer) xfer_free_list;

int	wdcprobe	__P((struct device *, void *, void *));
int	wdcprint	__P((void *, const char *));
void	wdcattach	__P((struct device *, struct device *, void *));
int	wdcintr		__P((void *));

#if NWDC_ISA
struct cfattach wdc_isa_ca = {
	sizeof(struct wdc_softc), wdcprobe, wdcattach
};
#endif

#if NWDC_ISAPNP
struct cfattach wdc_isapnp_ca = {
	sizeof(struct wdc_softc), wdcprobe, wdcattach
};
#endif

struct cfdriver wdc_cd = {
	NULL, "wdc", DV_DULL
};

enum wdcreset_mode { WDCRESET_VERBOSE, WDCRESET_SILENT };

#if NWD > 0
int	wdc_ata_intr	__P((struct wdc_softc *, struct wdc_xfer *));
void	wdc_ata_start	__P((struct wdc_softc *, struct wdc_xfer *));
void	wdc_ata_done	__P((struct wdc_softc *, struct wdc_xfer *));
__inline static void u_int16_to_string __P((u_int16_t *, char *, size_t));
#endif	/* NWD */
int	wait_for_phase	__P((struct wdc_softc *, int));
int	wait_for_unphase __P((struct wdc_softc *, int));
void	wdcstart	__P((struct wdc_softc *));
int	wdcreset	__P((struct wdc_softc *, enum wdcreset_mode));
void	wdcrestart	__P((void *arg));
void	wdcunwedge	__P((struct wdc_softc *));
void	wdctimeout	__P((void *arg));
int	wdccontrol	__P((struct wd_link *));
void	wdc_free_xfer	__P((struct wdc_xfer *));
void	wdcerror	__P((struct wdc_softc*, char *));
void	wdcbit_bucket	__P(( struct wdc_softc *, int));
#if NATAPIBUS > 0
void	wdc_atapi_start	__P((struct wdc_softc *,struct wdc_xfer *));
int	wdc_atapi_intr	__P((struct wdc_softc *, struct wdc_xfer *));
void	wdc_atapi_done	__P((struct wdc_softc *, struct wdc_xfer *));
#endif	/* NATAPIBUS */

#ifdef ATAPI_DEBUG
static int wdc_nxfer;
#endif

#ifdef WDDEBUG
#define WDDEBUG_PRINT(args)	printf args
#else
#define WDDEBUG_PRINT(args)
#endif

/* Macro for determining bus type. */
#if NWDC_ISAPNP
#define IS_ISAPNP(parent) \
	!strcmp((parent)->dv_cfdata->cf_driver->cd_name, "isapnp")
#else
#define IS_ISAPNP(parent) 0
#endif

int
wdcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_space_handle_t ioh_ctl;
	struct wdc_softc *wdc = match;
	struct isa_attach_args *ia = aux;
#ifdef notyet
	int err;
#endif

#if NISADMA == 0
	if (ia->ia_drq != DRQUNK) {
		printf("cannot support dma wdc devices\n");
		return 0;
	}
#endif

	wdc->sc_iot = iot = ia->ia_iot;
	if (IS_ISAPNP(parent)) {
		ioh = ia->ipa_io[0].h;
		ioh_ctl = ia->ipa_io[1].h;
	} else {
		if (bus_space_map(iot, ia->ia_iobase, 8, 0, &ioh))
			return 0;
		if (bus_space_map(iot, ia->ia_iobase + WDCTL_OFFSET,
				  1, 0, &ioh_ctl))
			return 0;
	}
	wdc->sc_ioh = ioh;
	wdc->sc_ioh_ctl = ioh_ctl;

	/* Check if we have registers that work. */
	/* Error register not writable, */
	bus_space_write_1(iot, ioh, wd_error, 0x5a);
	/* but all of cyl_lo are. */
	bus_space_write_1(iot, ioh, wd_cyl_lo, 0xa5);
	if (bus_space_read_1(iot, ioh, wd_error) == 0x5a ||
	    bus_space_read_1(iot, ioh, wd_cyl_lo) != 0xa5) {
		/*
		 * Test for a controller with no IDE master, just one
		 * ATAPI device. Select drive 1, and try again.
		 */
		bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | 0x10);
		bus_space_write_1(iot, ioh, wd_error, 0x5a);
		bus_space_write_1(iot, ioh, wd_cyl_lo, 0xa5);
		if (bus_space_read_1(iot, ioh, wd_error) == 0x5a ||
		    bus_space_read_1(iot, ioh, wd_cyl_lo) != 0xa5)
			goto nomatch;
		wdc->sc_flags |= WDCF_ONESLAVE;
	}

	if (wdcreset(wdc, WDCRESET_SILENT) != 0) {
		/*
		 * If the reset failed, there is no master. test for ATAPI
		 * signature on the slave device. If no ATAPI slave, wait 5s
		 * and retry a reset.
		 */
		bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | 0x10);	/* slave */
		if (bus_space_read_1(iot, ioh, wd_cyl_lo) != 0x14 ||
		    bus_space_read_1(iot, ioh, wd_cyl_hi) != 0xeb) {
			delay(500000);
			if (wdcreset(wdc, WDCRESET_SILENT) != 0)
				goto nomatch;
		}
		wdc->sc_flags |= WDCF_ONESLAVE;
	}

	/* Select drive 0 or ATAPI slave device */
	if (wdc->sc_flags & WDCF_ONESLAVE)
		bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | 0x10);
	else
		bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM);

	/* Wait for controller to become ready. */
	if (wait_for_unbusy(wdc) < 0)
		goto nomatch;

	/* Start drive diagnostics. */
	bus_space_write_1(iot, ioh, wd_command, WDCC_DIAGNOSE);

	/* Wait for command to complete. */
	if (wait_for_unbusy(wdc) < 0)
		goto nomatch;

#ifdef notyet
	/* See if the drive(s) are alive. */
	err = bus_space_read_1(iot, ioh, wd_error);
	if (err && (err != 0x01)) {
		if (err & 0x80) {
			/* Select drive 1. */
			bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | 0x10);
			(void) wait_for_unbusy(wdc);
		
			err = bus_space_read_1(iot, ioh, wd_error);
			if ((err != 0x01) && (err != 0x81))
				goto nomatch;
		} else
			goto nomatch;
	}
#endif

	ia->ia_iosize = 8;
	ia->ia_msize = 0;
	return 1;

nomatch:
	if (!IS_ISAPNP(parent)) {
		bus_space_unmap(iot, ioh, 8);
		bus_space_unmap(iot, ioh_ctl, 1);
	}
	return 0;
}

int
wdcprint(aux, wdc)
	void *aux;
	const char *wdc;
{
	struct wd_link *d_link = aux;

	if (!wdc)
		printf(" drive %d", d_link->sc_drive);
	return QUIET;
}

void
wdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wdc_softc *wdc = (void *)self;
	struct isa_attach_args *ia = aux;
#if NWD > 0
	int drive;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
#endif	/* NWD */

	TAILQ_INIT(&wdc->sc_xfer);
	wdc->sc_drq = ia->ia_drq;

	printf("\n");

	wdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, wdcintr, wdc, wdc->sc_dev.dv_xname);

	wdc->ctlr_link.flags = 0;
#ifdef ATAPI_DEBUG
	wdc_nxfer = 0;
#endif

#if NATAPIBUS > 0
	/*
	 * Attach an ATAPI bus, if configured.
	 */
	wdc->ab_link = malloc(sizeof(struct bus_link), M_DEVBUF, M_NOWAIT);
	if (wdc->ab_link == NULL) {
		printf("%s: can't allocate ATAPI link\n", self->dv_xname);
		return;
	}
	bzero(wdc->ab_link,sizeof(struct bus_link));
	wdc->ab_link->type = BUS;
	wdc->ab_link->wdc_softc = (caddr_t)wdc;
	wdc->ab_link->ctlr_link = &(wdc->ctlr_link);
	wdc->ab_link->ctrl = self->dv_unit;
	(void)config_found(self, (void *)wdc->ab_link, NULL);
#endif	/* NATAPIBUS */
#if NWD > 0
	/*
	 * Attach standard IDE/ESDI/etc. disks to the controller.
	 */
	for (drive = 0; drive < 2; drive++) {
		/* test for ATAPI signature on this drive */
		bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | (drive << 4));
		if (bus_space_read_1(iot, ioh, wd_cyl_lo) == 0x14 &&
		    bus_space_read_1(iot, ioh, wd_cyl_hi) == 0xeb) {
			continue;
		}
		/* controller active while autoconf */
		wdc->sc_flags |= WDCF_ACTIVE;

		if (wdccommandshort(wdc, drive, WDCC_RECAL) != 0 ||
            	    wait_for_ready(wdc) != 0) {
			wdc->d_link[drive] = NULL;
			wdc->sc_flags &= ~WDCF_ACTIVE;
		} else {
			wdc->sc_flags &= ~WDCF_ACTIVE;
			wdc->d_link[drive] = malloc(sizeof(struct wd_link),
			    M_DEVBUF, M_NOWAIT);
			if (wdc->d_link[drive] == NULL) {
				printf("%s: can't allocate link for drive %d\n",
				    self->dv_xname, drive);
				continue;
			}
			bzero(wdc->d_link[drive],sizeof(struct wd_link));
			wdc->d_link[drive]->type = DRIVE;
			wdc->d_link[drive]->wdc_softc =(caddr_t) wdc;
			wdc->d_link[drive]->ctlr_link = &(wdc->ctlr_link);
			wdc->d_link[drive]->sc_drive = drive;
#if NISADMA > 0
			if (wdc->sc_drq != DRQUNK)
				wdc->d_link[drive]->sc_mode = WDM_DMA;
			else
#endif	/* NISADMA */
				wdc->d_link[drive]->sc_mode = 0;

			(void)config_found(self, (void *)wdc->d_link[drive],
			    wdcprint);
		}
	}
#endif	/* NWD */
}

/*
 * Start I/O on a controller.  This does the calculation, and starts a read or
 * write operation.  Called to from wdstart() to start a transfer, from
 * wdcintr() to continue a multi-sector transfer or start the next transfer, or
 * wdcrestart() after recovering from an error.
 */
void
wdcstart(wdc)
	struct wdc_softc *wdc;
{
	struct wdc_xfer *xfer;

	if ((wdc->sc_flags & WDCF_ACTIVE) != 0 ) {
		WDDEBUG_PRINT(("wdcstart: already active\n"));
		return; /* controller aleady active */
	}
#ifdef DIAGNOSTIC
	if ((wdc->sc_flags & WDCF_IRQ_WAIT) != 0)
		panic("wdcstart: controller waiting for irq");
#endif
	/*
	 * XXX
	 * This is a kluge.  See comments in wd_get_parms().
	 */
	if ((wdc->sc_flags & WDCF_WANTED) != 0) {
#ifdef ATAPI_DEBUG_WDC
		printf("WDCF_WANTED\n");
#endif
		wdc->sc_flags &= ~WDCF_WANTED;
		wakeup(wdc);
		return;
	}
	/* is there a xfer ? */
	xfer = wdc->sc_xfer.tqh_first;
	if (xfer == NULL) {
#ifdef ATAPI_DEBUG2
		printf("wdcstart: null xfer\n");
#endif
		return;
	}
	wdc->sc_flags |= WDCF_ACTIVE;
#if NATAPIBUS > 0 && NWD > 0
	if (xfer->c_flags & C_ATAPI) {
#ifdef ATAPI_DEBUG_WDC
		printf("wdcstart: atapi\n");
#endif
		wdc_atapi_start(wdc, xfer);
	} else
		wdc_ata_start(wdc, xfer);
#else
#if NATAPIBUS > 0
#ifdef ATAPI_DEBUG_WDC
	printf("wdcstart: atapi\n");
#endif
	wdc_atapi_start(wdc, xfer);
#endif	/* NATAPIBUS */
#if NWD > 0
	wdc_ata_start(wdc, xfer);
#endif	/* NWD */
#endif	/* NATAPIBUS && NWD */
}

#if NWD > 0
void
wdc_ata_start(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
#ifdef WDDEBUG
	bus_space_handle_t ioh_ctl = wdc->sc_ioh_ctl;
#endif
	struct wd_link *d_link = xfer->d_link;
	struct buf *bp = xfer->c_bp;
	int nblks;

	if (xfer->c_errors >= WDIORETRIES) {
		wderror(d_link, bp, "wdcstart hard error");
		xfer->c_flags |= C_ERROR;
		wdc_ata_done(wdc, xfer);
		return;
	}

	/* Do control operations specially. */
	if (d_link->sc_state < READY) {
		/*
		 * Actually, we want to be careful not to mess with the control
		 * state if the device is currently busy, but we can assume
		 * that we never get to this point if that's the case.
		 */
		if (wdccontrol(d_link) == 0) {
			/* The drive is busy.  Wait. */
			return;
		}
	}

	/*
	 * WDCF_ERROR is set by wdcunwedge() and wdcintr() when an error is
	 * encountered.  If we are in multi-sector mode, then we switch to
	 * single-sector mode and retry the operation from the start.
	 */
	if (wdc->sc_flags & WDCF_ERROR) {
		wdc->sc_flags &= ~WDCF_ERROR;
		if ((wdc->sc_flags & WDCF_SINGLE) == 0) {
			wdc->sc_flags |= WDCF_SINGLE;
			xfer->c_skip = 0;
		}
	}


	/* When starting a transfer... */
	if (xfer->c_skip == 0) {
		struct buf *bp = xfer->c_bp;

		xfer->c_bcount = bp->b_bcount;
		xfer->c_blkno = (bp->b_blkno + xfer->c_p_offset) / (d_link->sc_lp->d_secsize / DEV_BSIZE);
		WDDEBUG_PRINT(("\n%s: wdc_ata_start %s %d@@%d; map ",
		    wdc->sc_dev.dv_xname,
		    (xfer->c_flags & B_READ) ? "read" : "write",
		    xfer->c_bcount, xfer->c_blkno));
	} else {
		WDDEBUG_PRINT((" %d)0x%x", xfer->c_skip,
		    bus_space_read_1(iot, ioh_ctl, wd_altsts)));
	}

	/*
	 * When starting a multi-sector transfer, or doing single-sector
	 * transfers...
	 */
	if (xfer->c_skip == 0 || (wdc->sc_flags & WDCF_SINGLE) != 0 ||
	    d_link->sc_mode == WDM_DMA) {
		daddr_t blkno = xfer->c_blkno;
		int cylin, head, sector;
		int command;

		if ((wdc->sc_flags & WDCF_SINGLE) != 0)
			nblks = 1;
#if NISADMA > 0
		else if (d_link->sc_mode != WDM_DMA)
			nblks = xfer->c_bcount / d_link->sc_lp->d_secsize;
		else
			nblks =
			    min(xfer->c_bcount / d_link->sc_lp->d_secsize, 8);
#else
		else
			nblks = xfer->c_bcount / d_link->sc_lp->d_secsize;
#endif

		/* Check for bad sectors and adjust transfer, if necessary. */
		if ((d_link->sc_lp->d_flags & D_BADSECT) != 0
#ifdef B_FORMAT
		    && (bp->b_flags & B_FORMAT) == 0
#endif
		    ) {
			int blkdiff;
			int i;

			for (i = 0;
			    (blkdiff = d_link->sc_badsect[i]) != -1; i++) {
				blkdiff -= blkno;
				if (blkdiff < 0)
					continue;
				if (blkdiff == 0) {
					/* Replace current block of xfer. */
					blkno = d_link->sc_lp->d_secperunit -
					    d_link->sc_lp->d_nsectors - i - 1;
				}
				if (blkdiff < nblks) {
					/* Bad block inside transfer. */
					wdc->sc_flags |= WDCF_SINGLE;
					nblks = 1;
				}
				break;
			}
			/* Tranfer is okay now. */
		}

		if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0) {
			sector = (blkno >> 0) & 0xff;
			cylin = (blkno >> 8) & 0xffff;
			head = (blkno >> 24) & 0xf;
			head |= WDSD_LBA;
		} else {
			sector = blkno % d_link->sc_lp->d_nsectors;
			sector++;	/* Sectors begin with 1, not 0. */
			blkno /= d_link->sc_lp->d_nsectors;
			head = blkno % d_link->sc_lp->d_ntracks;
			blkno /= d_link->sc_lp->d_ntracks;
			cylin = blkno;
			head |= WDSD_CHS;
		}

		if (d_link->sc_mode == WDM_PIOSINGLE ||
		    (wdc->sc_flags & WDCF_SINGLE) != 0)
			xfer->c_nblks = 1;
		else if (d_link->sc_mode == WDM_PIOMULTI)
			xfer->c_nblks = min(nblks, d_link->sc_multiple);
		else
			xfer->c_nblks = nblks;
		xfer->c_nbytes = xfer->c_nblks * d_link->sc_lp->d_secsize;

#ifdef B_FORMAT
		if (bp->b_flags & B_FORMAT) {
			sector = d_link->sc_lp->d_gap3;
			nblks = d_link->sc_lp->d_nsectors;
			command = WDCC_FORMAT;
		} else
#endif
		switch (d_link->sc_mode) {
#if NISADMA > 0
		case WDM_DMA:
			command = (xfer->c_flags & B_READ) ?
			    WDCC_READDMA : WDCC_WRITEDMA;
			/*
			 * Start the DMA channel and bounce the buffer if
			 * necessary.
			 */
			isadma_start(xfer->databuf + xfer->c_skip,
			    xfer->c_nbytes, wdc->sc_drq,
			    xfer->c_flags & B_READ ?
			    DMAMODE_READ : DMAMODE_WRITE);
			break;
#endif

		case WDM_PIOMULTI:
			command = (xfer->c_flags & B_READ) ?
			    WDCC_READMULTI : WDCC_WRITEMULTI;
			break;

		case WDM_PIOSINGLE:
			command = (xfer->c_flags & B_READ) ?
			    WDCC_READ : WDCC_WRITE;
			break;

		default:
#ifdef DIAGNOSTIC
			panic("bad wd mode");
#endif
			return;
		}

		/* Initiate command! */
		if (wdccommand(d_link, command, d_link->sc_drive,
		    cylin, head, sector, nblks) != 0) {
			wderror(d_link, NULL,
			    "wdc_ata_start: timeout waiting for unbusy");
			wdcunwedge(wdc);
			return;
		}

		WDDEBUG_PRINT(("sector %d cylin %d head %d addr %x sts %x\n",
		    sector, cylin, head, xfer->databuf,
		    bus_space_read_1(iot, ioh_ctl, wd_altsts)));

	} else if (xfer->c_nblks > 1) {
		/* The number of blocks in the last stretch may be smaller. */
		nblks = xfer->c_bcount / d_link->sc_lp->d_secsize;
		if (xfer->c_nblks > nblks) {
			xfer->c_nblks = nblks;
			xfer->c_nbytes = xfer->c_bcount;
		}
	}

	/* If this was a write and not using DMA, push the data. */
	if (d_link->sc_mode != WDM_DMA &&
	    (xfer->c_flags & (B_READ|B_WRITE)) == B_WRITE) {
		if (wait_for_drq(wdc) < 0) {
			wderror(d_link, NULL,
			    "wdc_ata_start: timeout waiting for drq");
			wdcunwedge(wdc);
			return;
		}

		/* Push out data. */
		if ((d_link->sc_flags & WDF_32BIT) == 0)
			bus_space_write_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes);
		else
			bus_space_write_raw_multi_4(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes);
	}

	wdc->sc_flags |= WDCF_IRQ_WAIT;
	WDDEBUG_PRINT(("wdc_ata_start: timeout "));
	timeout(wdctimeout, wdc, WAITTIME);
	WDDEBUG_PRINT(("done\n"));
}

int
wdc_ata_intr(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	struct wd_link *d_link = xfer->d_link;

	if (wait_for_unbusy(wdc) < 0) {
		wdcerror(wdc, "wdcintr: timeout waiting for unbusy");
		wdc->sc_status |= WDCS_ERR;	/* XXX */
	}

	untimeout(wdctimeout, wdc);

	/* Is it not a transfer, but a control operation? */
	if (d_link->sc_state < READY) {
		if (wdccontrol(d_link) == 0) {
			/* The drive is busy.  Wait. */
			return 1;
		}
		WDDEBUG_PRINT(
		    ("wdc_ata_start from wdc_ata_intr(open) flags %d\n",
		    wdc->sc_flags));
		wdc_ata_start(wdc,xfer);
		return 1;
	}

#if NISADMA > 0
	/* Turn off the DMA channel and unbounce the buffer. */
	if (d_link->sc_mode == WDM_DMA)
		isadma_done(wdc->sc_drq);
#endif

	/* Have we an error? */
	if (wdc->sc_status & WDCS_ERR) {
#ifdef WDDEBUG
		wderror(d_link, NULL, "wdc_ata_intr");
#endif
		if ((wdc->sc_flags & WDCF_SINGLE) == 0) {
			wdc->sc_flags |= WDCF_ERROR;
			goto restart;
		}

#ifdef B_FORMAT
		if (bp->b_flags & B_FORMAT)
			goto bad;
#endif

		if (++xfer->c_errors == (WDIORETRIES + 1) / 2) {
			wdcunwedge(wdc);
			return 1;
		}
		if (xfer->c_errors < WDIORETRIES)
			goto restart;

		wderror(d_link, xfer->c_bp, "hard error");

#ifdef B_FORMAT
	bad:
#endif
		xfer->c_flags |= C_ERROR;
		goto done;
	}

	/* If this was a read and not using DMA, fetch the data. */
	if (d_link->sc_mode != WDM_DMA &&
	    (xfer->c_flags & (B_READ|B_WRITE)) == B_READ) {
		if ((wdc->sc_status & (WDCS_DRDY | WDCS_DSC | WDCS_DRQ))
		    != (WDCS_DRDY | WDCS_DSC | WDCS_DRQ)) {
			wderror(d_link, NULL, "wdcintr: read intr before drq");
			wdcunwedge(wdc);
			return 1;
		}

		/* Pull in data. */
		if ((d_link->sc_flags & WDF_32BIT) == 0)
			bus_space_read_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes);
		else
			bus_space_read_raw_multi_4(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes);
	}

	/* If we encountered any abnormalities, flag it as a soft error. */
	if (xfer->c_errors > 0 ||
	    (wdc->sc_status & WDCS_CORR) != 0) {
		wderror(d_link, xfer->c_bp, "soft error (corrected)");
		xfer->c_errors = 0;
	}

	/* Adjust pointers for the next block, if any. */
	xfer->c_blkno += xfer->c_nblks;
	xfer->c_skip += xfer->c_nbytes;
	xfer->c_bcount -= xfer->c_nbytes;

	/* See if this transfer is complete. */
	if (xfer->c_bcount > 0)
		goto restart;

done:
	/* Done with this transfer, with or without error. */
	wdc_ata_done(wdc, xfer);
	return 0;

restart:
	/* Start the next operation */
	WDDEBUG_PRINT(("wdc_ata_start from wdcintr flags %d\n",
	    wdc->sc_flags));
	wdc_ata_start(wdc, xfer);

	return 1;
}

void
wdc_ata_done(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	struct buf *bp = xfer->c_bp;
	struct wd_link *d_link = xfer->d_link;
	int s;

	WDDEBUG_PRINT(("wdc_ata_done\n"));

	/* remove this command from xfer queue */
	s = splbio();
	TAILQ_REMOVE(&wdc->sc_xfer, xfer, c_xferchain);
	wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);
	if (bp) {
		if (xfer->c_flags & C_ERROR) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
		}
		bp->b_resid = xfer->c_bcount;
		wddone(d_link, bp);
		biodone(bp);
	} else {
		wakeup(xfer->databuf);
	}
	xfer->c_skip = 0;
	wdc_free_xfer(xfer);
	d_link->openings++;
	wdstart((void *)d_link->wd_softc);
	WDDEBUG_PRINT(("wdcstart from wdc_ata_done, flags %d\n",
	    wdc->sc_flags));
	wdcstart(wdc);
	splx(s);
}

/* decode IDE strings, stored as if the words are big-endian.  */
__inline static void
u_int16_to_string(from, to, cnt)
	u_int16_t *from;
	char *to;
	size_t cnt;
{
	size_t i;

	for (i = 0; i < cnt; i += 2) {
		*to++ = (char)(*from >> 8 & 0xff);
		*to++ = (char)(*from++ & 0xff);
	}
}

/*
 * Get the drive parameters, if ESDI or ATA, or create fake ones for ST506.
 */
int
wdc_get_parms(d_link)
	struct wd_link *d_link;
{
	struct wdc_softc *wdc = (struct wdc_softc *)d_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	u_int16_t tb[DEV_BSIZE / sizeof(u_int16_t)];
	int s, error;

	/*
	 * XXX
	 * The locking done here, and the length of time this may keep the rest
	 * of the system suspended, is a kluge.  This should be rewritten to
	 * set up a transfer and queue it through wdstart(), but it's called
	 * infrequently enough that this isn't a pressing matter.
	 */

	s = splbio();

	while ((wdc->sc_flags & WDCF_ACTIVE) != 0) {
		wdc->sc_flags |= WDCF_WANTED;
		error = tsleep(wdc, PRIBIO | PCATCH, "wdprm", 0);
		if (error != 0) {
			splx(s);
			return error;
		}
	}

	wdc->sc_flags |= WDCF_ACTIVE;

	if (wdccommandshort(wdc, d_link->sc_drive, WDCC_IDENTIFY) != 0 ||
	    wait_for_drq(wdc) != 0) {
		/*
		 * We `know' there's a drive here; just assume it's old.
		 * This geometry is only used to read the MBR and print a
		 * (false) attach message.
		 */
		strncpy(d_link->sc_lp->d_typename, "ST506",
		    sizeof d_link->sc_lp->d_typename);
		d_link->sc_lp->d_type = DTYPE_ST506;

		strncpy(d_link->sc_params.wdp_model, "ST506/MFM/RLL",
		    sizeof d_link->sc_params.wdp_model);
		d_link->sc_params.wdp_config = WD_CFG_FIXED;
		d_link->sc_params.wdp_cylinders = 1024;
		d_link->sc_params.wdp_heads = 8;
		d_link->sc_params.wdp_sectors = 17;
		d_link->sc_params.wdp_maxmulti = 0;
		d_link->sc_params.wdp_usedmovsd = 0;
		d_link->sc_params.wdp_capabilities = 0;
	} else {
		strncpy(d_link->sc_lp->d_typename, "ESDI/IDE",
		    sizeof d_link->sc_lp->d_typename);
		d_link->sc_lp->d_type = DTYPE_ESDI;

		/* Read in parameter block. */
		bus_space_read_multi_2(iot, ioh, wd_data, tb,
		    sizeof(tb) / sizeof(u_int16_t));
		d_link->sc_params.wdp_config = (u_int16_t)tb[0];
		d_link->sc_params.wdp_cylinders = (u_int16_t)tb[1];
		d_link->sc_params.wdp_heads = (u_int16_t)tb[3];
		d_link->sc_params.wdp_unfbytespertrk = (u_int16_t)tb[4];
		d_link->sc_params.wdp_unfbytespersec = (u_int16_t)tb[5];
		d_link->sc_params.wdp_sectors = (u_int16_t)tb[6];
		u_int16_to_string (tb + 7, d_link->sc_params.wdp_vendor1, 6);
		u_int16_to_string (tb + 10, d_link->sc_params.wdp_serial, 20);
		d_link->sc_params.wdp_buftype = (u_int16_t)tb[20];
		d_link->sc_params.wdp_bufsize = (u_int16_t)tb[21];
		d_link->sc_params.wdp_eccbytes = (u_int16_t)tb[22];
		u_int16_to_string (tb + 23, d_link->sc_params.wdp_revision, 8);
		u_int16_to_string (tb + 27, d_link->sc_params.wdp_model, 40);
		d_link->sc_params.wdp_maxmulti = (u_int8_t)(tb[47] & 0xff);
		d_link->sc_params.wdp_vendor2[0] = (u_int8_t)(tb[47] >> 8 &
		    0xff);
		d_link->sc_params.wdp_usedmovsd = (u_int16_t)tb[48];
		d_link->sc_params.wdp_vendor3[0] = (u_int8_t)(tb[49] & 0xff);
		d_link->sc_params.wdp_capabilities = (u_int8_t)(tb[49] >> 8 &
		    0xff);
		d_link->sc_params.wdp_vendor4[0] = (u_int8_t)(tb[50] & 0xff);
		d_link->sc_params.wdp_piotiming = (u_int8_t)(tb[50] >> 8 &
		    0xff);
		d_link->sc_params.wdp_vendor5[0] = (u_int8_t)(tb[51] & 0xff);
		d_link->sc_params.wdp_dmatiming = (u_int8_t)(tb[51] >> 8 &
		    0xff);
		d_link->sc_params.wdp_capvalid = (u_int16_t)tb[53];
		d_link->sc_params.wdp_curcyls = (u_int16_t)tb[54];
		d_link->sc_params.wdp_curheads = (u_int16_t)tb[55];
		d_link->sc_params.wdp_cursectors = (u_int16_t)tb[56];
		d_link->sc_params.wdp_curcapacity = ((u_int32_t)tb[58] << 16) + tb[57];
		d_link->sc_params.wdp_curmulti = (u_int8_t)(tb[59] & 0xff);
		d_link->sc_params.wdp_valmulti = (u_int8_t)(tb[59] >> 8 & 0xff);
		d_link->sc_params.wdp_lbacapacity = ((u_int32_t)tb[61] << 16) + tb[60];
		d_link->sc_params.wdp_dma1word = (u_int16_t)tb[62];
		d_link->sc_params.wdp_dmamword = (u_int16_t)tb[63];
		d_link->sc_params.wdp_eidepiomode = (u_int16_t)tb[64];
		d_link->sc_params.wdp_eidedmamin = (u_int16_t)tb[65];
		d_link->sc_params.wdp_eidedmatime = (u_int16_t)tb[66];
		d_link->sc_params.wdp_eidepiotime = (u_int16_t)tb[67];
		d_link->sc_params.wdp_eidepioiordy = (u_int16_t)tb[68];
	}

	/* Clear any leftover interrupt. */
	(void) bus_space_read_1(iot, ioh, wd_status);

	/* Restart the queue. */
	WDDEBUG_PRINT(("wdcstart from wdc_get_parms flags %d\n",
	    wdc->sc_flags));
	wdc->sc_flags &= ~WDCF_ACTIVE;
	wdcstart(wdc);

	splx(s);
	return 0;
}

/*
 * Implement operations needed before read/write.
 * Returns 0 if operation still in progress, 1 if completed.
 */
int
wdccontrol(d_link)
	struct wd_link *d_link;
{
	struct wdc_softc *wdc = (void *)d_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;

	WDDEBUG_PRINT(("wdccontrol\n"));

	switch (d_link->sc_state) {
	case RECAL:	/* Set SDH, step rate, do recal. */
		if (wdccommandshort(wdc, d_link->sc_drive, WDCC_RECAL) != 0) {
			wderror(d_link, NULL, "wdccontrol: recal failed (1)");
			goto bad;
		}
		d_link->sc_state = RECAL_WAIT;
		break;

	case RECAL_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(d_link, NULL, "wdccontrol: recal failed (2)");
			goto bad;
		}
		/* fall through */

	case GEOMETRY:
		if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0)
			goto multimode;
		if (wdsetctlr(d_link) != 0) {
			/* Already printed a message. */
			goto bad;
		}
		d_link->sc_state = GEOMETRY_WAIT;
		break;

	case GEOMETRY_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(d_link, NULL, "wdccontrol: geometry failed");
			goto bad;
		}
		/* fall through */

	case MULTIMODE:
	multimode:
		if (d_link->sc_mode != WDM_PIOMULTI)
			goto ready;
		bus_space_write_1(iot, ioh, wd_seccnt, d_link->sc_multiple);
		if (wdccommandshort(wdc, d_link->sc_drive,
		    WDCC_SETMULTI) != 0) {
			wderror(d_link, NULL,
			    "wdccontrol: setmulti failed (1)");
			goto bad;
		}
		d_link->sc_state = MULTIMODE_WAIT;
		break;

	case MULTIMODE_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(d_link, NULL,
			    "wdccontrol: setmulti failed (2)");
			goto bad;
		}
		/* fall through */

	case READY:
	ready:
		d_link->sc_state = READY;
		/*
		 * The rest of the initialization can be done by normal means.
		 */
		return 1;

	bad:
		wdcunwedge(wdc);
		return 0;
	}

	wdc->sc_flags |= WDCF_IRQ_WAIT;
	timeout(wdctimeout, wdc, WAITTIME);
	return 0;
}
#endif	/* NWD */

int
wait_for_phase(wdc, wphase)
	struct wdc_softc *wdc;
	int wphase;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int i, phase;

	for (i = 20000; i; i--) {
		phase = (bus_space_read_1(iot, ioh, wd_ireason) &
		    (WDCI_CMD | WDCI_IN)) |
		    (bus_space_read_1(iot, ioh, wd_status)
		    & WDCS_DRQ);
		if (phase == wphase)
			break;
		delay(10);
	}
	return (phase);
}

int
wait_for_unphase(wdc, wphase)
	struct wdc_softc *wdc;
	int wphase;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int i, phase;

	for (i = 20000; i; i--) {
		phase = (bus_space_read_1(iot, ioh, wd_ireason) &
		    (WDCI_CMD | WDCI_IN)) |
		    (bus_space_read_1(iot, ioh, wd_status)
		    & WDCS_DRQ);
		if (phase != wphase)
			break;
		delay(10);
	}
	return (phase);
}

#if NATAPIBUS > 0
void
wdc_atapi_start(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	struct atapi_command_packet *acp = xfer->atapi_cmd;

#ifdef ATAPI_DEBUG_WDC
	printf("wdc_atapi_start, acp flags %lx\n",acp->flags);
#endif
	if (xfer->c_errors >= WDIORETRIES) {
		acp->status |= ERROR;
		acp->error = bus_space_read_1(iot, ioh, wd_error);
		wdc_atapi_done(wdc, xfer);
		return;
	}
	if (wait_for_unbusy(wdc) != 0) {
		if ((wdc->sc_status & WDCS_ERR) == 0) {
			printf("wdc_atapi_start: not ready, st = %02x\n",
			    wdc->sc_status);
			acp->status = ERROR;
			return;
		}
	}

	if (wdccommand((struct wd_link*)xfer->d_link, ATAPI_PACKET_COMMAND,
	    acp->drive, acp->data_size, 0, 0, 0) != 0) {
		printf("wdc_atapi_start: can't send atapi paket command\n");
		acp->status = ERROR;
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		return;
	}
	if ((acp->flags & (ACAP_DRQ_INTR|ACAP_DRQ_ACCEL)) != ACAP_DRQ_INTR) {
		if (!(wdc->sc_flags & WDCF_BROKENPOLL)) {
			int phase = wait_for_phase(wdc, PHASE_CMDOUT);

			if (phase != PHASE_CMDOUT) {
				printf("wdc_atapi_start: timeout waiting "
				    "PHASE_CMDOUT, got 0x%x\n", phase);

				/* NEC SUCKS. */
				wdc->sc_flags |= WDCF_BROKENPOLL;
			}
		} else
			DELAY(10);	/* Simply pray for the data. */

		bus_space_write_raw_multi_2(iot, ioh, wd_data, acp->command,
		    acp->command_size);
	}
	wdc->sc_flags |= WDCF_IRQ_WAIT;

#ifdef ATAPI_DEBUG2
	printf("wdc_atapi_start: timeout\n");
#endif
	timeout(wdctimeout, wdc, WAITTIME);
	return;
}

int
wdc_atapi_get_params(ab_link, drive, id)
	struct bus_link *ab_link;
	u_int8_t drive;
	struct atapi_identify *id;
{
	struct wdc_softc *wdc = (void*)ab_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int status, len, excess = 0;
	int s, error;

	if (wdc->d_link[drive] != 0) {
#ifdef ATAPI_DEBUG_PROBE
		printf("wdc_atapi_get_params: WD drive %d\n", drive);

#endif
		return 0;
	}

	/*
	 * If there is only one ATAPI slave on the bus, don't probe
	 * drive 0 (master)
	 */

	if ((wdc->sc_flags & WDCF_ONESLAVE) && (drive != 1))
		return 0;

#ifdef ATAPI_DEBUG_PROBE
	printf("wdc_atapi_get_params: probing drive %d\n", drive);
#endif

	/*
	 * XXX
	 * The locking done here, and the length of time this may keep the rest
	 * of the system suspended, is a kluge.  This should be rewritten to
	 * set up a transfer and queue it through wdstart(), but it's called
	 * infrequently enough that this isn't a pressing matter.
	 */

	s = splbio();

	while ((wdc->sc_flags & WDCF_ACTIVE) != 0) {
		wdc->sc_flags |= WDCF_WANTED;
		if ((error = tsleep(wdc, PRIBIO | PCATCH, "atprm", 0)) != 0) {
			splx(s);
			return error;
		}
	}

	wdc->sc_flags |= WDCF_ACTIVE;
	error = 1;
	(void)wdcreset(wdc, WDCRESET_VERBOSE);
	if ((status = wdccommand((struct wd_link*)ab_link,
	    ATAPI_SOFT_RESET, drive, 0, 0, 0, 0)) != 0) {
#ifdef ATAPI_DEBUG
		printf("wdc_atapi_get_params: ATAPI_SOFT_RESET"
		    "failed for drive %d: status %d error %d\n",
		    drive, status, wdc->sc_error);
#endif
		error = 0;
		goto end;
	}
	if ((status = wait_for_unbusy(wdc)) != 0) {
#ifdef ATAPI_DEBUG
	printf("wdc_atapi_get_params: wait_for_unbusy failed "
	    "for drive %d: status %d error %d\n",
	    drive, status, wdc->sc_error);
#endif
		error = 0;
		goto end;
	}

	if (wdccommand((struct wd_link*)ab_link, ATAPI_IDENTIFY_DEVICE,
	    drive, sizeof(struct atapi_identify), 0, 0, 0) != 0 ||
	    atapi_ready(wdc) != 0) {
#ifdef ATAPI_DEBUG_PROBE
		printf("ATAPI_IDENTIFY_DEVICE failed for drive %d\n", drive);
#endif
		error = 0;
		goto end;
	}
	len = bus_space_read_1(iot, ioh, wd_cyl_lo) + 256 *
	    bus_space_read_1(iot, ioh, wd_cyl_hi);
	if (len != sizeof(struct atapi_identify)) {
		if (len < 142) {	/* XXX */
			printf("%s: drive %d returned %d/%d of identify device data, device unusuable\n",
			    wdc->sc_dev.dv_xname, drive, len,
			    sizeof(struct atapi_identify));

			error = 0;
			goto end;
		}

		excess = (len - sizeof(struct atapi_identify));
		if (excess < 0)
			excess = 0;
	}
	bus_space_read_raw_multi_2(iot, ioh, wd_data, (u_int8_t *)id,
	    sizeof(struct atapi_identify));
	wdcbit_bucket(wdc, excess);

 end:	/* Restart the queue. */
	WDDEBUG_PRINT(("wdcstart from wdc_atapi_get_params flags %d\n",
	    wdc->sc_flags));
	wdc->sc_flags &= ~WDCF_ACTIVE;
	wdcstart(wdc);
	splx(s);
	return error;
}

void
wdc_atapi_send_command_packet(ab_link, acp)
	struct bus_link *ab_link;
	struct atapi_command_packet *acp;
{
	struct wdc_softc *wdc = (void*)ab_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	bus_space_handle_t ioh_ctl = wdc->sc_ioh_ctl;
	struct wdc_xfer *xfer;
	u_int8_t flags = acp->flags & 0xff;

	if (flags & A_POLLED) {   /* Must use the queue and wdc_atapi_start */
		struct wdc_xfer xfer_s;
		int i, phase;

#ifdef ATAPI_DEBUG_WDC
		printf("wdc_atapi_send_cmd: "
		    "flags %ld drive %d cmdlen %d datalen %d",
		    acp->flags, acp->drive, acp->command_size, acp->data_size);
#endif
		xfer = &xfer_s;
		bzero(xfer, sizeof(xfer_s));
		xfer->c_flags = C_INUSE|C_ATAPI|acp->flags;
		xfer->d_link = (struct wd_link *)ab_link;
		xfer->c_link = ab_link->ctlr_link;
		xfer->c_bp = acp->bp;
		xfer->atapi_cmd = acp;
		xfer->c_blkno = 0;
		xfer->databuf = acp->databuf;
		xfer->c_bcount = acp->data_size;
		if (wait_for_unbusy (wdc) != 0)  {
			if ((wdc->sc_status & WDCS_ERR) == 0) {
				printf("wdc_atapi_send_command: not ready, "
				    "st = %02x\n", wdc->sc_status);
				acp->status = ERROR;
				return;
			}
		}

		/* Turn off interrupts.  */
		bus_space_write_1(iot, ioh_ctl, wd_ctlr, WDCTL_4BIT|WDCTL_IDS);
		delay(1000);

		if (wdccommand((struct wd_link*)ab_link,
		    ATAPI_PACKET_COMMAND, acp->drive, acp->data_size,
		    0, 0, 0) != 0) {
			printf("can't send atapi paket command\n");
			acp->status = ERROR;
			return;
		}

		/* Wait for cmd i/o phase. */
		phase = wait_for_phase(wdc, PHASE_CMDOUT);
		if (phase != PHASE_CMDOUT)
			printf("wdc_atapi_send_command_packet: "
			    "got wrong phase (0x%x) wanted cmd I/O\n",
			    phase);

		bus_space_write_raw_multi_2(iot, ioh, wd_data, acp->command,
		    acp->command_size);

		/* Wait for data i/o phase. */
		phase = wait_for_unphase(wdc, PHASE_CMDOUT);
		if (phase == PHASE_CMDOUT)
			printf("wdc_atapi_send_command_packet: "
			    "got wrong phase (0x%x) wanted data I/O\n",
			    phase);

		while (wdc_atapi_intr(wdc, xfer)) {
			for (i = 2000; i > 0; --i) {
				if ((bus_space_read_1(iot, ioh, wd_status) &
				    WDCS_DRQ) == 0)
					break;
				delay(10);
			}
#ifdef ATAPI_DEBUG_WDC
			printf("wdc_atapi_send_command_packet: i = %d\n", i);
#endif
		}

		/* Turn on interrupts again. */
		bus_space_write_1(iot, ioh_ctl, wd_ctlr, WDCTL_4BIT);
		delay(1000);

		wdc->sc_flags &= ~(WDCF_IRQ_WAIT | WDCF_SINGLE | WDCF_ERROR);
		xfer->c_errors = 0;
		xfer->c_skip = 0;
		return;
	} else {	/* POLLED */
		xfer = wdc_get_xfer(ab_link->ctlr_link,
		    flags & A_NOSLEEP ? IDE_NOSLEEP : 0);
		if (xfer == NULL) {
			acp->status = ERROR;
			return;
		}
		xfer->c_flags |= C_ATAPI|acp->flags;
		xfer->d_link = (struct wd_link*) ab_link;
		xfer->c_link = ab_link->ctlr_link;
		xfer->c_bp = acp->bp;
		xfer->atapi_cmd = acp;
		xfer->c_blkno = 0;
		xfer->databuf = acp->databuf;
		xfer->c_bcount = acp->data_size;
		wdc_exec_xfer((struct wd_link*)ab_link,xfer);
		return;
	}
}

int
wdc_atapi_intr(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	struct atapi_command_packet *acp = xfer->atapi_cmd;
	int len, phase, i, retries = 0;
	int err, st, ire;

	if (wait_for_unbusy(wdc) < 0) {
		printf("wdc_atapi_intr: controller busy\n");
		acp->status = ERROR;
		acp->error = bus_space_read_1(iot, ioh, wd_error);
		return 0;
	}

#ifdef ATAPI_DEBUG2
	printf("wdc_atapi_intr: %s\n", wdc->sc_dev.dv_xname);
#endif

again:
	len = bus_space_read_1(iot, ioh, wd_cyl_lo) +
	    256 * bus_space_read_1(iot, ioh, wd_cyl_hi);

	st = bus_space_read_1(iot, ioh, wd_status);
	err = bus_space_read_1(iot, ioh, wd_error);
	ire = bus_space_read_1(iot, ioh, wd_ireason);

	phase = (ire & (WDCI_CMD | WDCI_IN)) | (st & WDCS_DRQ);
#ifdef ATAPI_DEBUG_WDC
	printf("wdc_atapi_intr: len %d st %d err %d ire %d :",
	    len, st, err, ire);
#endif
	switch (phase) {
	case PHASE_CMDOUT:
		/* send packet command */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_CMDOUT\n");
#endif

#ifdef ATAPI_DEBUG_WDC
		{
			int i;
			char *c = (char *)acp->command;

			printf("wdc_atapi_intr: cmd ");
			for (i = 0; i < acp->command_size; i++)
				printf("0x%x ", c[i]);
			printf("\n");
		}
#endif

		wdc->sc_flags |= WDCF_IRQ_WAIT;
		bus_space_write_raw_multi_2(iot, ioh, wd_data, acp->command,
		    acp->command_size);
		return 1;

	case PHASE_DATAOUT:
		/* write data */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_DATAOUT\n");
#endif
		if ((acp->flags & (B_READ|B_WRITE)) != B_WRITE) {
			printf("wdc_atapi_intr: bad data phase\n");
			acp->status = ERROR;
			return 1;
		}
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		if (xfer->c_bcount < len) {
			printf("wdc_atapi_intr: warning: write only "
			    "%d of %d requested bytes\n", xfer->c_bcount, len);
			bus_space_write_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_bcount);
			for (i = xfer->c_bcount; i < len;
			    i += sizeof(u_int16_t))
				bus_space_write_2(iot, ioh, wd_data, 0);
			xfer->c_bcount = 0;
			return 1;
		} else {
			bus_space_write_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, len);
			xfer->c_skip += len;
			xfer->c_bcount -= len;
			return 1;
		}

	case PHASE_DATAIN:
		/* Read data */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_DATAIN\n");
#endif
		if ((acp->flags & (B_READ|B_WRITE)) != B_READ) {
			printf("wdc_atapi_intr: bad data phase\n");
			acp->status = ERROR;
			return 1;
		}
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		if (xfer->c_bcount < len) {
			printf("wdc_atapi_intr: warning: reading only "
			    "%d of %d bytes\n", xfer->c_bcount, len);
			bus_space_read_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_bcount);
			wdcbit_bucket(wdc, len - xfer->c_bcount);
			xfer->c_bcount = 0;
			return 1;
		} else {
			bus_space_read_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, len);
			xfer->c_skip += len;
			xfer->c_bcount -=len;
			return 1;
		}

	case PHASE_ABORTED:
	case PHASE_COMPLETED:
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_COMPLETED\n");
#endif
		if (st & WDCS_ERR) {
			acp->error = bus_space_read_1(iot, ioh, wd_error);
			acp->status = ERROR;
		}
#ifdef ATAPI_DEBUG_WDC
		if (xfer->c_bcount != 0) {
			printf("wdc_atapi_intr warning: bcount value "
			    "is %d after io\n", xfer->c_bcount);
		}
#endif
		break;

	default:
		if (++retries < 500) {
			DELAY(100);
			goto again;
		}
		printf("wdc_atapi_intr: unknown phase %d\n", phase);
		acp->status = ERROR;
	}

	wdc_atapi_done(wdc, xfer);
	return (0);
}


void
wdc_atapi_done(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	struct atapi_command_packet *acp = xfer->atapi_cmd;
	int s;

	acp->data_size = xfer->c_bcount;

	s = splbio();

	/* remove this command from xfer queue */
	xfer->c_skip = 0;
	if ((xfer->c_flags & A_POLLED) == 0) {
		untimeout(wdctimeout, wdc);
		TAILQ_REMOVE(&wdc->sc_xfer, xfer, c_xferchain);
		wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);
		wdc_free_xfer(xfer);
#ifdef ATAPI_DEBUG
		printf("wdc_atapi_done: atapi_done\n");
#endif
		atapi_done(acp);
#ifdef WDDEBUG
		printf("wdcstart from wdc_atapi_intr, flags %d\n",
		    wdc->sc_flags);
#endif
		wdcstart(wdc);
	} else
		wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);

	splx(s);
}
#endif	/* NATAPIBUS */

/*
 * Interrupt routine for the controller.  Acknowledge the interrupt, check for
 * errors on the current operation, mark it done if necessary, and start the
 * next request.  Also check for a partially done transfer, and continue with
 * the next chunk if so.
 */
int
wdcintr(arg)
	void *arg;
{
	struct wdc_softc *wdc = arg;
	struct wdc_xfer *xfer;

	/*
	 * It appears that some drives are causing the controller to
	 * interrupt too quickly.  It also appears that such drives do not
	 * conform to the MMC2 specifications.  This needs to be fixed
	 * correctly and the extra check for NULL removed from the following
	 * if().
	 */
	if (((wdc->sc_flags & WDCF_IRQ_WAIT) == 0)
	    || (wdc->sc_xfer.tqh_first == NULL)) {
		bus_space_tag_t iot = wdc->sc_iot;
		bus_space_handle_t ioh = wdc->sc_ioh;
		u_char s;
#ifdef ATAPI_DEBUG_WDC
		u_char e, i;
#endif
		DELAY(100);

		/* Clear the pending interrupt and abort. */
		s = bus_space_read_1(iot, ioh, wd_status);
		if (s != (WDCS_DRDY|WDCS_DSC)) {
#ifdef ATAPI_DEBUG_WDC
			e = bus_space_read_1(iot, ioh, wd_error);
			i = bus_space_read_1(iot, ioh, wd_seccnt);

			printf("wdcintr: inactive controller, "
			    "punting st=%02x er=%02x irr=%02x\n", s, e, i);
#else
			bus_space_read_1(iot, ioh, wd_error);
			bus_space_read_1(iot, ioh, wd_seccnt);
#endif

			if (s & WDCS_DRQ) {
				int len = 256 * bus_space_read_1(iot, ioh,
				    wd_cyl_hi) +
				    bus_space_read_1(iot, ioh, wd_cyl_lo);
#ifdef ATAPI_DEBUG_WDC
				printf("wdcintr: clearing up %d bytes\n", len);
#endif
				wdcbit_bucket(wdc, len);
			}
		}
		return 0;
	}

	WDDEBUG_PRINT(("wdcintr\n"));

	wdc->sc_flags &= ~WDCF_IRQ_WAIT;
	xfer = wdc->sc_xfer.tqh_first;
	if (xfer == NULL) {
#ifdef ATAPI_DEBUG
		printf("wdcintr: null xfer\n");
#endif
		return 0;
	}
#if NATAPIBUS > 0 && NWD > 0
	if (xfer->c_flags & C_ATAPI) {
		(void)wdc_atapi_intr(wdc, xfer);
		return 0;
	} else
		return wdc_ata_intr(wdc, xfer);
#else
#if NATAPIBUS > 0
	(void)wdc_atapi_intr(wdc, xfer);
	return 0;
#endif	/* NATAPIBUS */
#if NWD > 0
	return wdc_ata_intr(wdc, xfer);
#endif	/* NWD */
#endif	/* NATAPIBUS && NWD */
}

int
wdcreset(wdc, mode)
	struct wdc_softc *wdc;
	enum wdcreset_mode mode;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	bus_space_handle_t ioh_ctl = wdc->sc_ioh_ctl;

	/* Reset the device. */
	bus_space_write_1(iot, ioh_ctl, wd_ctlr, WDCTL_RST|WDCTL_IDS);
	delay(1000);
	bus_space_write_1(iot, ioh_ctl, wd_ctlr, WDCTL_IDS);
	delay(1000);
	(void) bus_space_read_1(iot, ioh, wd_error);
	bus_space_write_1(iot, ioh_ctl, wd_ctlr, WDCTL_4BIT);

	if (wait_for_unbusy(wdc) < 0) {
		if (mode != WDCRESET_SILENT)
			printf("%s: reset failed\n", wdc->sc_dev.dv_xname);
		return 1;
	}

	return 0;
}

void
wdcrestart(arg)
	void *arg;
{
	struct wdc_softc *wdc = arg;
	int s;

	s = splbio();
	wdcstart(wdc);
	splx(s);
}

/*
 * Unwedge the controller after an unexpected error.  We do this by resetting
 * it, marking all drives for recalibration, and stalling the queue for a short
 * period to give the reset time to finish.
 * NOTE: We use a timeout here, so this routine must not be called during
 * autoconfig or dump.
 */
void
wdcunwedge(wdc)
	struct wdc_softc *wdc;
{
	int unit;

#ifdef ATAPI_DEBUG
	printf("wdcunwedge\n");
#endif

	untimeout(wdctimeout, wdc);
	wdc->sc_flags &= ~WDCF_IRQ_WAIT;
	(void) wdcreset(wdc, WDCRESET_VERBOSE);

	/* Schedule recalibrate for all drives on this controller. */
	for (unit = 0; unit < 2; unit++) {
		if (!wdc->d_link[unit]) continue;
		if (wdc->d_link[unit]->sc_state > RECAL)
			wdc->d_link[unit]->sc_state = RECAL;
	}

	wdc->sc_flags |= WDCF_ERROR;

	/* Wake up in a little bit and restart the operation. */
	WDDEBUG_PRINT(("wdcrestart from wdcunwedge\n"));
	wdc->sc_flags &= ~WDCF_ACTIVE;
	timeout(wdcrestart, wdc, RECOVERYTIME);
}

int
wdcwait(wdc, mask)
	struct wdc_softc *wdc;
	int mask;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int timeout = 0;
	u_char status;
#ifdef WDCNDELAY_DEBUG
	extern int cold;
#endif

	WDDEBUG_PRINT(("wdcwait\n"));

	for (;;) {
		wdc->sc_status = status = bus_space_read_1(iot, ioh,
		    wd_status);
		/*
		 * If a single slave ATAPI device is attached, it may
		 * have released the bus. Select it and try again.
		 */
		if (status == 0xff && wdc->sc_flags & WDCF_ONESLAVE) {
			bus_space_write_1(iot, ioh, wd_sdh,
			    WDSD_IBM | 0x10);
			wdc->sc_status = status = bus_space_read_1(iot, ioh,
			    wd_status);
		}
		if ((status & WDCS_BSY) == 0 && (status & mask) == mask)
			break;
		if (++timeout > WDCNDELAY) {
#ifdef ATAPI_DEBUG2
			printf("wdcwait: timeout, status 0x%x\n", status);
#endif
			return -1;
		}
		delay(WDCDELAY);
	}
	if (status & WDCS_ERR) {
		wdc->sc_error = bus_space_read_1(iot, ioh, wd_error);
		return WDCS_ERR;
	}
#ifdef WDCNDELAY_DEBUG
	/* After autoconfig, there should be no long delays. */
	if (!cold && timeout > WDCNDELAY_DEBUG) {
		struct wdc_xfer *xfer = wdc->sc_xfer.tqh_first;
		if (xfer == NULL)
			printf("%s: warning: busy-wait took %dus\n",
	    		wdc->sc_dev.dv_xname, WDCDELAY * timeout);
		else
			printf("%s(%s): warning: busy-wait took %dus\n",
				wdc->sc_dev.dv_xname,
			    ((struct device*)xfer->d_link->wd_softc)->dv_xname,
				WDCDELAY * timeout);
	}
#endif
	return 0;
}

void
wdctimeout(arg)
	void *arg;
{
	struct wdc_softc *wdc = (struct wdc_softc *)arg;
	int s;

	WDDEBUG_PRINT(("wdctimeout\n"));

	s = splbio();
	if ((wdc->sc_flags & WDCF_IRQ_WAIT) != 0) {
		wdc->sc_flags &= ~WDCF_IRQ_WAIT;
		wdcerror(wdc, "lost interrupt");
		wdcunwedge(wdc);
	} else
		wdcerror(wdc, "missing untimeout");
	splx(s);
}

/*
 * Wait for the drive to become ready and send a command.
 * Return -1 if busy for too long or 0 otherwise.
 * Assumes interrupts are blocked.
 */
int
wdccommand(d_link, command, drive, cylin, head, sector, count)
        struct wd_link *d_link;
        int command;
        int drive, cylin, head, sector, count;
{
	struct wdc_softc *wdc = (void*)d_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
        int stat;

	WDDEBUG_PRINT(("wdccommand drive %d\n", drive));

#if defined(DIAGNOSTIC) && defined(WDCDEBUG)
	if ((wdc->sc_flags & WDCF_ACTIVE) == 0)
		printf("wdccommand: controler not active (drive %d)\n", drive);
#endif

        /* Select drive, head, and addressing mode. */
        bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | (drive << 4) | head);

        /* Wait for it to become ready to accept a command. */
        if (command == WDCC_IDP || d_link->type == BUS)
                stat = wait_for_unbusy(wdc);
        else
                stat = wdcwait(wdc, WDCS_DRDY);

        if (stat < 0) {
#ifdef ATAPI_DEBUG
		printf("wdcommand: xfer failed (wait_for_unbusy) status %d\n",
		    stat);
#endif
                return -1;
	}

        /* Load parameters. */
        if (d_link->type == DRIVE && d_link->sc_lp->d_type == DTYPE_ST506)
                bus_space_write_1(iot, ioh, wd_precomp,
		    d_link->sc_lp->d_precompcyl / 4);
        else
                bus_space_write_1(iot, ioh, wd_features, 0);
        bus_space_write_1(iot, ioh, wd_cyl_lo, cylin);
        bus_space_write_1(iot, ioh, wd_cyl_hi, cylin >> 8);
        bus_space_write_1(iot, ioh, wd_sector, sector);
        bus_space_write_1(iot, ioh, wd_seccnt, count);

        /* Send command. */
        bus_space_write_1(iot, ioh, wd_command, command);

        return 0;
}

/*
 * Simplified version of wdccommand().
 */
int
wdccommandshort(wdc, drive, command)
	struct wdc_softc *wdc;
        int drive;
        int command;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;

	WDDEBUG_PRINT(("wdccommandshort\n"));

#if defined(DIAGNOSTIC) && defined(WDCDEBUG)
	if ((wdc->sc_flags & WDCF_ACTIVE) == 0)
		printf("wdccommandshort: controller not active (drive %d)\n",
		    drive);
#endif

        /* Select drive. */
        bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM|(drive << 4));

        if (wdcwait(wdc, WDCS_DRDY) < 0)
                return -1;

        bus_space_write_1(iot, ioh, wd_command, command);

	return 0;
}

void
wdc_exec_xfer(d_link, xfer)
	struct wd_link *d_link;
	struct wdc_xfer *xfer;
{
	struct wdc_softc *wdc = (struct wdc_softc *)d_link->wdc_softc;
	int s;

	WDDEBUG_PRINT(("wdc_exec_xfer\n"));

	s = splbio();

	/* insert at the end of command list */
	TAILQ_INSERT_TAIL(&wdc->sc_xfer,xfer , c_xferchain);
	WDDEBUG_PRINT(("wdcstart from wdc_exec_xfer, flags %d\n",
	    wdc->sc_flags));
	wdcstart(wdc);
	splx(s);
}

struct wdc_xfer *
wdc_get_xfer(c_link,flags)
	struct wdc_link *c_link;
	int flags;
{
	struct wdc_xfer *xfer;
	int s;

	s = splbio();
	if ((xfer = xfer_free_list.lh_first) != NULL) {
		LIST_REMOVE(xfer, free_list);
		splx(s);
#ifdef DIAGNOSTIC
		if ((xfer->c_flags & C_INUSE) != 0)
			panic("wdc_get_xfer: xfer already in use");
#endif
	} else {
		splx(s);
#ifdef ATAPI_DEBUG
		printf("wdc:making xfer %d\n",wdc_nxfer);
#endif
		xfer = malloc(sizeof(*xfer), M_DEVBUF,
		    ((flags & IDE_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
		if (xfer == NULL)
			return 0;

#ifdef DIAGNOSTIC
		xfer->c_flags &= ~C_INUSE;
#endif
#ifdef ATAPI_DEBUG
		wdc_nxfer++;
#endif
	}
#ifdef DIAGNOSTIC
	if ((xfer->c_flags & C_INUSE) != 0)
		panic("wdc_get_xfer: xfer already in use");
#endif
	bzero(xfer, sizeof(struct wdc_xfer));
	xfer->c_flags = C_INUSE;
	xfer->c_link = c_link;
	return xfer;
}

void
wdc_free_xfer(xfer)
	struct wdc_xfer *xfer;
{
	int s;

	s = splbio();
	xfer->c_flags &= ~C_INUSE;
	LIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);
	splx(s);
}

void
wdcerror(wdc, msg)
	struct wdc_softc *wdc;
	char *msg;
{
	struct wdc_xfer *xfer = wdc->sc_xfer.tqh_first;
	if (xfer == NULL)
		printf("%s: %s\n", wdc->sc_dev.dv_xname, msg);
	else
		printf("%s(%s): %s\n", wdc->sc_dev.dv_xname,
		    ((struct device*)xfer->d_link->wd_softc)->dv_xname, msg);
}

/*
 * the bit bucket
 */
void
wdcbit_bucket(wdc, size)
	struct wdc_softc *wdc;
	int size;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int i;

	for (i = 0 ; i < size / 2 ; i++) {
		u_int16_t null;

		bus_space_read_multi_2(iot, ioh, wd_data, &null, 1);
	}

	if (size % 2)
		bus_space_read_1(iot, ioh, wd_data);
}
@


1.37
log
@typo; failed with WDDEBUG set
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.36 1999/01/11 01:57:52 millert Exp $	*/
@


1.36
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.35 1998/09/15 01:40:08 downsj Exp $	*/
d1877 1
a1877 1
	TAILQ_INSERT_TAIL(&wdc->sc_xfer,xfer , c_xferchain)
@


1.35
log
@It appears that some drives are causing the controller to
interrupt too quickly.  It also appears that such drives do not
conform to the MMC2 specifications.  This needs to be fixed
correctly and the extra check for NULL removed from the following
if(); but clearing the interrupt appears to be a valid work around.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.34 1998/09/14 01:55:52 downsj Exp $	*/
d393 1
a393 1
		panic("wdcstart: controller waiting for irq\n");
d1898 1
a1898 1
			panic("wdc_get_xfer: xfer already in use\n");
d1919 1
a1919 1
		panic("wdc_get_xfer: xfer already in use\n");
@


1.34
log
@avoid NULL deref for now
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.33 1998/08/08 23:01:06 downsj Exp $	*/
d1553 9
a1561 1
	if ((wdc->sc_flags & WDCF_IRQ_WAIT) == 0) {
@


1.33
log
@Split ioh allocations so that the devices no longer overlap.
Also disable the diag return check in wdc.c for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.32 1998/07/23 04:40:12 csapuntz Exp $	*/
d1593 6
@


1.32
log
@

Print LBA-based size as well as CHS size.

Fix some bugs in getting drive parameters into the wdparams array
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.31 1998/07/09 05:37:21 downsj Exp $	*/
d165 1
d168 1
d170 1
d181 2
a182 1
		ioh = ia->ia_ioh;
d186 3
d191 1
d246 1
d261 1
d268 1
a268 1
	if (!IS_ISAPNP(parent))
d270 2
d445 3
d498 1
a498 1
		    bus_space_read_1(iot, ioh, wd_altsts)));
d628 1
a628 1
		    bus_space_read_1(iot, ioh, wd_altsts)));
d1258 1
d1291 1
a1291 1
		bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_4BIT | WDCTL_IDS);
d1332 1
a1332 1
		bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_4BIT);
d1617 1
d1620 1
a1620 1
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_RST|WDCTL_IDS);
d1622 1
a1622 1
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_IDS);
d1625 1
a1625 1
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_4BIT);
@


1.31
log
@Don't unmap something that we didn't map...
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.30 1998/07/07 19:15:31 deraadt Exp $	*/
d903 15
a917 17
		d_link->sc_params.wdp_capvalid = (u_int16_t)tb[52];
		d_link->sc_params.wdp_curcyls = (u_int16_t)tb[53];
		d_link->sc_params.wdp_curheads = (u_int16_t)tb[54];
		d_link->sc_params.wdp_cursectors = (u_int16_t)tb[55];
		d_link->sc_params.wdp_curcapacity[0] = (u_int16_t)tb[56];
		d_link->sc_params.wdp_curcapacity[1] = (u_int16_t)tb[57];
		d_link->sc_params.wdp_curmulti = (u_int8_t)(tb[58] & 0xff);
		d_link->sc_params.wdp_valmulti = (u_int8_t)(tb[58] >> 8 & 0xff);
		d_link->sc_params.wdp_lbacapacity[0] = (u_int16_t)tb[59];
		d_link->sc_params.wdp_lbacapacity[1] = (u_int16_t)tb[60];
		d_link->sc_params.wdp_dma1word = (u_int16_t)tb[61];
		d_link->sc_params.wdp_dmamword = (u_int16_t)tb[62];
		d_link->sc_params.wdp_eidepiomode = (u_int16_t)tb[63];
		d_link->sc_params.wdp_eidedmamin = (u_int16_t)tb[64];
		d_link->sc_params.wdp_eidedmatime = (u_int16_t)tb[65];
		d_link->sc_params.wdp_eidepiotime = (u_int16_t)tb[66];
		d_link->sc_params.wdp_eidepioiordy = (u_int16_t)tb[67];
@


1.30
log
@put wd_error check back; without this machine boot times go well over 60 seconds
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.29 1998/07/05 07:20:02 downsj Exp $	*/
a254 4
#ifdef notyet
	/* when we are ready for it... */
	bus_space_unmap(iot, ioh, 8);
#endif
d258 2
a259 1
	bus_space_unmap(iot, ioh, 8);
@


1.29
log
@Add support for ISA PnP to wdc and associated config goo.  This does NOT work
with the Soundblaster; documentation is needed.

Also changes wdcprobe method slightly.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.28 1998/04/28 05:41:08 angelos Exp $	*/
d186 3
d190 2
a191 1
	if (bus_space_read_1(iot, ioh, wd_cyl_lo) == 0xff) {
d197 1
d199 2
a200 1
		if (bus_space_read_1(iot, ioh, wd_cyl_lo) == 0xff)
@


1.28
log
@Make kernel compile if we have IDE controller but no wd drive.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.27 1998/02/22 00:38:40 niklas Exp $	*/
d71 2
d99 2
a100 1
struct cfattach wdc_ca = {
d103 7
d150 8
d167 1
d177 6
a182 2
	if (bus_space_map(iot, ia->ia_iobase, 8, 0, &ioh))
		return 0;
a185 3
	/* Error register not writable, */
	bus_space_write_1(iot, ioh, wd_error, 0x5a);
	/* but all of cyl_lo are. */
d187 1
a187 2
	if (bus_space_read_1(iot, ioh, wd_error) == 0x5a ||
	    bus_space_read_1(iot, ioh, wd_cyl_lo) != 0xa5) {
a192 1
		bus_space_write_1(iot, ioh, wd_error, 0x5a);
d194 1
a194 2
		if (bus_space_read_1(iot, ioh, wd_error) == 0x5a ||
		    bus_space_read_1(iot, ioh, wd_cyl_lo) != 0xa5)
d201 1
a201 1
		 * if the reset failed,, there is no master. test for ATAPI
d232 15
d1226 1
a1226 1
	WDDEBUG_PRINT(("wdcstart from wdc_atapi_get_parms flags %d\n",
a1684 1
		 * XXX
@


1.27
log
@only get isadma stuff when we want them
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.26 1998/01/18 18:48:40 niklas Exp $	*/
a248 1
#endif	/* NWD */
d251 1
@


1.26
log
@move to current OpenBSD isadma API
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.25 1997/12/10 23:02:01 rees Exp $	*/
d65 1
d67 1
@


1.25
log
@Fix three bugs:
ata_start doesn't retry operation after unwedge
ata_start gets block number wrong on restarted op
infinite loop on hard disk error due to sc_errors reset in RECAL
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.24 1997/11/22 20:23:53 mickey Exp $	*/
d541 4
a544 4
			isa_dmastart(xfer->c_flags & B_READ ?
			    DMAMODE_READ : DMAMODE_WRITE,
			    xfer->databuf + xfer->c_skip,
			    xfer->c_nbytes, wdc->sc_drq);
d644 1
a644 4
		isa_dmadone(xfer->c_flags & B_READ ?
		    DMAMODE_READ : DMAMODE_WRITE,
		    xfer->databuf + xfer->c_skip, xfer->c_nbytes,
		    wdc->sc_drq);
@


1.24
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.23 1997/08/07 10:24:25 niklas Exp $	*/
d205 1
a205 1
    
d313 1
a313 1
			if (wdc->sc_drq != DRQUNK) 
d400 1
a400 1
	if (wdc->sc_errors >= WDIORETRIES) {
d436 1
a436 1
		daddr_t blkno;
d438 2
a443 3

		blkno = xfer->c_blkno+xfer->c_p_offset;
		xfer->c_blkno = blkno / (d_link->sc_lp->d_secsize / DEV_BSIZE);
d524 1
a524 1
    
d564 1
a564 1
	
d653 1
a653 1
		wderror(d_link, NULL, "wdc_ata_start");
d665 1
a665 2
		if (wdc->sc_errors == (WDIORETRIES + 1) / 2) {
			wderror(d_link, NULL, "wedgie");
d669 1
a669 1
		if (++wdc->sc_errors < WDIORETRIES)
d699 1
a699 1
    
d701 1
a701 1
	if (wdc->sc_errors > 0 ||
d704 1
a704 1
		wdc->sc_errors = 0;
d706 1
a706 1
    
a744 1
	wdc->sc_errors = 0;
a971 1
		wdc->sc_errors = 0;
d1044 1
a1044 1
	if (wdc->sc_errors >= WDIORETRIES) {
d1154 1
a1154 1
	} 
d1213 1
a1213 1
	
d1270 1
a1270 1
		
d1288 1
a1288 1
		wdc->sc_errors = 0;
d1340 1
a1340 1
	
d1356 1
a1356 1
			char *c = (char *)acp->command;   
d1398 1
a1398 1
	
d1443 1
a1443 1
	default: 
a1469 1
	wdc->sc_errors = 0;
a1627 1
	++wdc->sc_errors;
d1685 1
a1685 1
		else 
d1820 1
a1820 1
}   
d1878 1
a1878 1
wdcerror(wdc, msg) 
d1886 1
a1886 1
		printf("%s(%s): %s\n", wdc->sc_dev.dv_xname, 
d1890 1
a1890 1
/* 
d1895 1
a1895 1
	struct wdc_softc *wdc; 
d1903 1
a1903 1
		u_int16_t null; 
d1906 1
a1906 1
	} 
@


1.23
log
@pretty
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.22 1997/07/06 18:10:18 niklas Exp $	*/
d183 1
a183 1
		 * signature on the salve device. If no ATAPI slave, wait 5s
@


1.22
log
@get rid of long, and let alpha grok the bad sectoring
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.21 1997/07/04 19:22:19 downsj Exp $	*/
d106 2
a107 2
int	wdc_ata_intr	__P((struct wdc_softc *,struct wdc_xfer *));
void	wdc_ata_start	__P((struct wdc_softc *,struct wdc_xfer *));
d488 2
a489 3
					/* Replace current block of transfer. */
					blkno =
					    d_link->sc_lp->d_secperunit -
d1182 3
a1184 1
			printf("%s: drive %d returned %d/%d of identify device data, device unusuable\n", wdc->sc_dev.dv_xname, drive, len, sizeof(struct atapi_identify));
d1390 2
a1391 1
			for (i = xfer->c_bcount; i < len; i += sizeof(short))
@


1.21
log
@Slight fix to last, didn't see it quick enough.

Original log:

date: 1997/06/17 15:39:18;  author: bouyer;  state: Exp;  lines: +3 -2
wdcreset should return errors, even if !VERBOSE !
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.20 1997/07/04 19:17:56 downsj Exp $	*/
d457 1
a457 1
		long cylin, head, sector;
d479 1
a479 1
			long blkdiff;
@


1.20
log
@ASUS/Triton support, based on manuel's code (different, busified, should
still amount to the same thing, but I don't have such a board to test).

Original log:

date: 1997/06/16 13:43:57;  author: bouyer;  state: Exp;  lines: +27 -11
Support pour la nouvelle Asustek TX97-E (avec le nouveau chip Triton).
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.19 1997/07/04 17:02:04 downsj Exp $	*/
d1581 3
a1583 2
	if ((wait_for_unbusy(wdc) < 0) && mode != WDCRESET_SILENT) {
		printf("%s: reset failed\n", wdc->sc_dev.dv_xname);
@


1.19
log
@Support ATAPI devices without wd devices, based on manuel's code.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.18 1997/02/24 05:50:46 niklas Exp $	*/
d103 2
d114 1
a114 1
int	wdcreset	__P((struct wdc_softc *));
d180 14
a193 4
	if (wdcreset(wdc) != 0) {
		delay(500000);
		if (wdcreset(wdc) != 0)
			goto nomatch;
d248 2
d285 6
d1149 1
a1149 1
	(void)wdcreset(wdc);
d1566 1
a1566 1
wdcreset(wdc)
d1568 1
d1581 1
a1581 1
	if (wait_for_unbusy(wdc) < 0) {
d1620 1
a1620 1
	(void) wdcreset(wdc);
@


1.18
log
@We do NOT want interrupts when in polled mode.  Fixes ATAPI boot
failures.  THanks go to Angelos D. Keromytis for debugging this and devising
the final fix.  Also correct some diagnostic printfs.  Do some KNF and unmap
registers on probe failure.  add a delay(10) to a busy-wait loop solely
depending on CPU speed earlier.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.17 1996/11/29 22:55:09 niklas Exp $	*/
d69 2
d72 1
d103 1
a104 1
void	wdcstart	__P((struct wdc_softc *));
d106 3
d111 1
a111 1
void	wdc_atapi_start	__P((struct wdc_softc *,struct wdc_xfer *));
a116 1
void	wdc_ata_done	__P((struct wdc_softc *, struct wdc_xfer *));
d120 2
d124 1
d233 1
d235 1
d250 1
d265 2
a266 1

d296 1
a296 1
#endif
d303 1
d347 1
d352 14
a365 4
		wdc_atapi_start(wdc,xfer);
	} else {
		wdc_ata_start(wdc,xfer);
	}
d368 1
a368 1

d595 1
a595 166
wait_for_phase(wdc, wphase)
	struct wdc_softc *wdc;
	int wphase;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int i, phase;

	for (i = 20000; i; i--) {
		phase = (bus_space_read_1(iot, ioh, wd_ireason) &
		    (WDCI_CMD | WDCI_IN)) |
		    (bus_space_read_1(iot, ioh, wd_status)
		    & WDCS_DRQ);
		if (phase == wphase)
			break;
		delay(10);
	}
	return (phase);
}

int
wait_for_unphase(wdc, wphase)
	struct wdc_softc *wdc;
	int wphase;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int i, phase;

	for (i = 20000; i; i--) {
		phase = (bus_space_read_1(iot, ioh, wd_ireason) &
		    (WDCI_CMD | WDCI_IN)) |
		    (bus_space_read_1(iot, ioh, wd_status)
		    & WDCS_DRQ);
		if (phase != wphase)
			break;
		delay(10);
	}
	return (phase);
}

void
wdc_atapi_start(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	struct atapi_command_packet *acp = xfer->atapi_cmd;

#ifdef ATAPI_DEBUG_WDC
	printf("wdc_atapi_start, acp flags %lx\n",acp->flags);
#endif
	if (wdc->sc_errors >= WDIORETRIES) {
		acp->status |= ERROR;
		acp->error = bus_space_read_1(iot, ioh, wd_error);
		wdc_atapi_done(wdc, xfer);
		return;
	}
	if (wait_for_unbusy(wdc) != 0) {
		if ((wdc->sc_status & WDCS_ERR) == 0) {
			printf("wdc_atapi_start: not ready, st = %02x\n",
			    wdc->sc_status);
			acp->status = ERROR;
			return;
		}
	}

	if (wdccommand((struct wd_link*)xfer->d_link, ATAPI_PACKET_COMMAND,
	    acp->drive, acp->data_size, 0, 0, 0) != 0) {
		printf("wdc_atapi_start: can't send atapi paket command\n");
		acp->status = ERROR;
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		return;
	}
	if ((acp->flags & (ACAP_DRQ_INTR|ACAP_DRQ_ACCEL)) != ACAP_DRQ_INTR) {
		if (!(wdc->sc_flags & WDCF_BROKENPOLL)) {
			int phase = wait_for_phase(wdc, PHASE_CMDOUT);

			if (phase != PHASE_CMDOUT) {
				printf("wdc_atapi_start: timeout waiting "
				    "PHASE_CMDOUT, got 0x%x\n", phase);

				/* NEC SUCKS. */
				wdc->sc_flags |= WDCF_BROKENPOLL;
			}
		} else
			DELAY(10);	/* Simply pray for the data. */

		bus_space_write_raw_multi_2(iot, ioh, wd_data, acp->command,
		    acp->command_size);
	}
	wdc->sc_flags |= WDCF_IRQ_WAIT;

#ifdef ATAPI_DEBUG2
	printf("wdc_atapi_start: timeout\n");
#endif
	timeout(wdctimeout, wdc, WAITTIME);
	return;
}


/*
 * Interrupt routine for the controller.  Acknowledge the interrupt, check for
 * errors on the current operation, mark it done if necessary, and start the
 * next request.  Also check for a partially done transfer, and continue with
 * the next chunk if so.
 */
int
wdcintr(arg)
	void *arg;
{
	struct wdc_softc *wdc = arg;
	struct wdc_xfer *xfer;

	if ((wdc->sc_flags & WDCF_IRQ_WAIT) == 0) {
		bus_space_tag_t iot = wdc->sc_iot;
		bus_space_handle_t ioh = wdc->sc_ioh;
		u_char s;
#ifdef ATAPI_DEBUG_WDC
		u_char e, i;
#endif
		DELAY(100);

		/* Clear the pending interrupt and abort. */
		s = bus_space_read_1(iot, ioh, wd_status);
		if (s != (WDCS_DRDY|WDCS_DSC)) {
#ifdef ATAPI_DEBUG_WDC
			e = bus_space_read_1(iot, ioh, wd_error);
			i = bus_space_read_1(iot, ioh, wd_seccnt);

			printf("wdcintr: inactive controller, "
			    "punting st=%02x er=%02x irr=%02x\n", s, e, i);
#else
			bus_space_read_1(iot, ioh, wd_error);
			bus_space_read_1(iot, ioh, wd_seccnt);
#endif

			if (s & WDCS_DRQ) {
				int len = 256 * bus_space_read_1(iot, ioh,
				    wd_cyl_hi) +
				    bus_space_read_1(iot, ioh, wd_cyl_lo);
#ifdef ATAPI_DEBUG_WDC
				printf("wdcintr: clearing up %d bytes\n", len);
#endif
				wdcbit_bucket(wdc, len);
			}
		}
		return 0;
	}

	WDDEBUG_PRINT(("wdcintr\n"));

	wdc->sc_flags &= ~WDCF_IRQ_WAIT;
	xfer = wdc->sc_xfer.tqh_first;
	if (xfer->c_flags & C_ATAPI) {
		(void)wdc_atapi_intr(wdc, xfer);
		return 0;
	} else {
		return wdc_ata_intr(wdc, xfer);
	}
}


int
wdc_ata_intr(wdc,xfer)
d713 2
a714 2
int
wdcreset(wdc)
d716 1
d718 3
a720 2
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
d722 1
a722 7
	/* Reset the device. */
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_RST|WDCTL_IDS);
	delay(1000);
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_IDS);
	delay(1000);
	(void) bus_space_read_1(iot, ioh, wd_error);
	bus_space_write_1(iot, ioh, wd_ctlr, WDCTL_4BIT);
d724 15
a738 3
	if (wait_for_unbusy(wdc) < 0) {
		printf("%s: reset failed\n", wdc->sc_dev.dv_xname);
		return 1;
d740 8
a747 2

	return 0;
d750 6
a755 3
void
wdcrestart(arg)
	void *arg;
d757 1
a757 2
	struct wdc_softc *wdc = arg;
	int s;
d759 4
a762 3
	s = splbio();
	wdcstart(wdc);
	splx(s);
d766 1
a766 5
 * Unwedge the controller after an unexpected error.  We do this by resetting
 * it, marking all drives for recalibration, and stalling the queue for a short
 * period to give the reset time to finish.
 * NOTE: We use a timeout here, so this routine must not be called during
 * autoconfig or dump.
d768 3
a770 3
void
wdcunwedge(wdc)
	struct wdc_softc *wdc;
d772 5
a776 1
	int unit;
d778 7
a784 3
#ifdef ATAPI_DEBUG
	printf("wdcunwedge\n");
#endif
d786 1
a786 3
	untimeout(wdctimeout, wdc);
	wdc->sc_flags &= ~WDCF_IRQ_WAIT;
	(void) wdcreset(wdc);
d788 7
a794 5
	/* Schedule recalibrate for all drives on this controller. */
	for (unit = 0; unit < 2; unit++) {
		if (!wdc->d_link[unit]) continue;
		if (wdc->d_link[unit]->sc_state > RECAL)
			wdc->d_link[unit]->sc_state = RECAL;
d797 1
a797 2
	wdc->sc_flags |= WDCF_ERROR;
	++wdc->sc_errors;
d799 10
a808 5
	/* Wake up in a little bit and restart the operation. */
	WDDEBUG_PRINT(("wdcrestart from wdcunwedge\n"));
	wdc->sc_flags &= ~WDCF_ACTIVE;
	timeout(wdcrestart, wdc, RECOVERYTIME);
}
d810 13
a822 12
int
wdcwait(wdc, mask)
	struct wdc_softc *wdc;
	int mask;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;
	int timeout = 0;
	u_char status;
#ifdef WDCNDELAY_DEBUG
	extern int cold;
#endif
d824 46
a869 42
	WDDEBUG_PRINT(("wdcwait\n"));

	for (;;) {
		wdc->sc_status = status = bus_space_read_1(iot, ioh,
		    wd_status);
		/*
		 * XXX
		 * If a single slave ATAPI device is attached, it may
		 * have released the bus. Select it and try again.
		 */
		if (status == 0xff && wdc->sc_flags & WDCF_ONESLAVE) {
			bus_space_write_1(iot, ioh, wd_sdh,
			    WDSD_IBM | 0x10);
			wdc->sc_status = status = bus_space_read_1(iot, ioh,
			    wd_status);
		}
		if ((status & WDCS_BSY) == 0 && (status & mask) == mask)
			break;
		if (++timeout > WDCNDELAY) {
#ifdef ATAPI_DEBUG2
			printf("wdcwait: timeout, status 0x%x\n", status);
#endif
			return -1;
		}
		delay(WDCDELAY);
	}
	if (status & WDCS_ERR) {
		wdc->sc_error = bus_space_read_1(iot, ioh, wd_error);
		return WDCS_ERR;
	}
#ifdef WDCNDELAY_DEBUG
	/* After autoconfig, there should be no long delays. */
	if (!cold && timeout > WDCNDELAY_DEBUG) {
		struct wdc_xfer *xfer = wdc->sc_xfer.tqh_first;
		if (xfer == NULL)
			printf("%s: warning: busy-wait took %dus\n",
	    		wdc->sc_dev.dv_xname, WDCDELAY * timeout);
		else 
			printf("%s(%s): warning: busy-wait took %dus\n",
				wdc->sc_dev.dv_xname,
			    ((struct device*)xfer->d_link->wd_softc)->dv_xname,
				WDCDELAY * timeout);
a870 3
#endif
	return 0;
}
d872 2
a873 6
void
wdctimeout(arg)
	void *arg;
{
	struct wdc_softc *wdc = (struct wdc_softc *)arg;
	int s;
d875 5
a879 1
	WDDEBUG_PRINT(("wdctimeout\n"));
a880 7
	s = splbio();
	if ((wdc->sc_flags & WDCF_IRQ_WAIT) != 0) {
		wdc->sc_flags &= ~WDCF_IRQ_WAIT;
		wdcerror(wdc, "lost interrupt");
		wdcunwedge(wdc);
	} else
		wdcerror(wdc, "missing untimeout");
d882 1
d886 2
a887 3
 * Wait for the drive to become ready and send a command.
 * Return -1 if busy for too long or 0 otherwise.
 * Assumes interrupts are blocked.
d890 2
a891 4
wdccommand(d_link, command, drive, cylin, head, sector, count)
        struct wd_link *d_link;
        int command;
        int drive, cylin, head, sector, count;
d893 1
a893 1
	struct wdc_softc *wdc = (void*)d_link->wdc_softc;
a895 1
        int stat;
d897 1
a897 1
	WDDEBUG_PRINT(("wdccommand drive %d\n", drive));
d899 8
a906 4
#if defined(DIAGNOSTIC) && defined(WDCDEBUG)
	if ((wdc->sc_flags & WDCF_ACTIVE) == 0)
		printf("wdccommand: controler not active (drive %d)\n", drive);
#endif
d908 6
a913 2
        /* Select drive, head, and addressing mode. */
        bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM | (drive << 4) | head);
d915 9
a923 5
        /* Wait for it to become ready to accept a command. */
        if (command == WDCC_IDP || d_link->type == BUS)
                stat = wait_for_unbusy(wdc);
        else
                stat = wdcwait(wdc, WDCS_DRDY);
d925 6
a930 7
        if (stat < 0) {
#ifdef ATAPI_DEBUG
		printf("wdcommand: xfer failed (wait_for_unbusy) status %d\n",
		    stat);
#endif
                return -1;
	}
d932 1
a932 208
        /* Load parameters. */
        if (d_link->type == DRIVE && d_link->sc_lp->d_type == DTYPE_ST506)
                bus_space_write_1(iot, ioh, wd_precomp,
		    d_link->sc_lp->d_precompcyl / 4);
        else
                bus_space_write_1(iot, ioh, wd_features, 0);
        bus_space_write_1(iot, ioh, wd_cyl_lo, cylin);
        bus_space_write_1(iot, ioh, wd_cyl_hi, cylin >> 8);
        bus_space_write_1(iot, ioh, wd_sector, sector);
        bus_space_write_1(iot, ioh, wd_seccnt, count);

        /* Send command. */
        bus_space_write_1(iot, ioh, wd_command, command);

        return 0;
}

/*
 * Simplified version of wdccommand().
 */
int
wdccommandshort(wdc, drive, command)
	struct wdc_softc *wdc;
        int drive;
        int command;
{
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;

	WDDEBUG_PRINT(("wdccommandshort\n"));

#if defined(DIAGNOSTIC) && defined(WDCDEBUG)
	if ((wdc->sc_flags & WDCF_ACTIVE) == 0)
		printf("wdccommandshort: controller not active (drive %d)\n",
		    drive);
#endif

        /* Select drive. */
        bus_space_write_1(iot, ioh, wd_sdh, WDSD_IBM|(drive << 4));

        if (wdcwait(wdc, WDCS_DRDY) < 0)
                return -1;

        bus_space_write_1(iot, ioh, wd_command, command);

	return 0;
}

void
wdc_ata_done(wdc, xfer)
	struct wdc_softc *wdc;
	struct wdc_xfer *xfer;
{
	struct buf *bp = xfer->c_bp;
	struct wd_link *d_link = xfer->d_link;
	int s;

	WDDEBUG_PRINT(("wdc_ata_done\n"));

	/* remove this command from xfer queue */
	s = splbio();
	TAILQ_REMOVE(&wdc->sc_xfer, xfer, c_xferchain);
	wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);
	wdc->sc_errors = 0;
	if (bp) {
		if (xfer->c_flags & C_ERROR) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
		}
		bp->b_resid = xfer->c_bcount;
		wddone(d_link, bp);
		biodone(bp);
	} else {
		wakeup(xfer->databuf);
	}
	xfer->c_skip = 0;
	wdc_free_xfer(xfer);
	d_link->openings++;
	wdstart((void *)d_link->wd_softc);
	WDDEBUG_PRINT(("wdcstart from wdc_ata_done, flags %d\n",
	    wdc->sc_flags));
	wdcstart(wdc);
	splx(s);
}

void
wdc_exec_xfer(d_link, xfer)
	struct wd_link *d_link;
	struct wdc_xfer *xfer;
{
	struct wdc_softc *wdc = (struct wdc_softc *)d_link->wdc_softc;
	int s;

	WDDEBUG_PRINT(("wdc_exec_xfer\n"));

	s = splbio();

	/* insert at the end of command list */
	TAILQ_INSERT_TAIL(&wdc->sc_xfer,xfer , c_xferchain)
	WDDEBUG_PRINT(("wdcstart from wdc_exec_xfer, flags %d\n",
	    wdc->sc_flags));
	wdcstart(wdc);
	splx(s);
}   

struct wdc_xfer *
wdc_get_xfer(c_link,flags)
	struct wdc_link *c_link;
	int flags;
{
	struct wdc_xfer *xfer;
	int s;

	s = splbio();
	if ((xfer = xfer_free_list.lh_first) != NULL) {
		LIST_REMOVE(xfer, free_list);
		splx(s);
#ifdef DIAGNOSTIC
		if ((xfer->c_flags & C_INUSE) != 0)
			panic("wdc_get_xfer: xfer already in use\n");
#endif
	} else {
		splx(s);
#ifdef ATAPI_DEBUG
		printf("wdc:making xfer %d\n",wdc_nxfer);
#endif
		xfer = malloc(sizeof(*xfer), M_DEVBUF,
		    ((flags & IDE_NOSLEEP) != 0 ? M_NOWAIT : M_WAITOK));
		if (xfer == NULL)
			return 0;

#ifdef DIAGNOSTIC
		xfer->c_flags &= ~C_INUSE;
#endif
#ifdef ATAPI_DEBUG
		wdc_nxfer++;
#endif
	}
#ifdef DIAGNOSTIC
	if ((xfer->c_flags & C_INUSE) != 0)
		panic("wdc_get_xfer: xfer already in use\n");
#endif
	bzero(xfer, sizeof(struct wdc_xfer));
	xfer->c_flags = C_INUSE;
	xfer->c_link = c_link;
	return xfer;
}

void
wdc_free_xfer(xfer)
	struct wdc_xfer *xfer;
{
	int s;

	s = splbio();
	xfer->c_flags &= ~C_INUSE;
	LIST_INSERT_HEAD(&xfer_free_list, xfer, free_list);
	splx(s);
}

/*
 * Implement operations needed before read/write.
 * Returns 0 if operation still in progress, 1 if completed.
 */
int
wdccontrol(d_link)
	struct wd_link *d_link;
{
	struct wdc_softc *wdc = (void *)d_link->wdc_softc;
	bus_space_tag_t iot = wdc->sc_iot;
	bus_space_handle_t ioh = wdc->sc_ioh;

	WDDEBUG_PRINT(("wdccontrol\n"));

	switch (d_link->sc_state) {
	case RECAL:	/* Set SDH, step rate, do recal. */
		if (wdccommandshort(wdc, d_link->sc_drive, WDCC_RECAL) != 0) {
			wderror(d_link, NULL, "wdccontrol: recal failed (1)");
			goto bad;
		}
		d_link->sc_state = RECAL_WAIT;
		break;

	case RECAL_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(d_link, NULL, "wdccontrol: recal failed (2)");
			goto bad;
		}
		/* fall through */

	case GEOMETRY:
		if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0)
			goto multimode;
		if (wdsetctlr(d_link) != 0) {
			/* Already printed a message. */
			goto bad;
		}
		d_link->sc_state = GEOMETRY_WAIT;
		break;

	case GEOMETRY_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(d_link, NULL, "wdccontrol: geometry failed");
			goto bad;
		}
		/* fall through */

	case MULTIMODE:
d972 1
d974 4
a977 8
__inline static void u_int16_to_string __P((u_int16_t *, char *, size_t));

/* decode IDE strings, stored as if the words are big-endian.  */
__inline static void
u_int16_to_string(from, to, cnt)
	u_int16_t *from;
	char *to;
	size_t cnt;
d979 3
a981 1
	size_t i;
d983 8
a990 3
	for (i = 0; i < cnt; i += 2) {
		*to++ = (char)(*from >> 8 & 0xff);
		*to++ = (char)(*from++ & 0xff);
d992 1
a994 3
/*
 * Get the drive parameters, if ESDI or ATA, or create fake ones for ST506.
 */
d996 3
a998 2
wdc_get_parms(d_link)
	struct wd_link *d_link;
a999 1
	struct wdc_softc *wdc = (struct wdc_softc *)d_link->wdc_softc;
d1002 1
a1002 2
	u_int16_t tb[DEV_BSIZE / sizeof(u_int16_t)];
	int s, error;
d1004 11
a1014 7
	/*
	 * XXX
	 * The locking done here, and the length of time this may keep the rest
	 * of the system suspended, is a kluge.  This should be rewritten to
	 * set up a transfer and queue it through wdstart(), but it's called
	 * infrequently enough that this isn't a pressing matter.
	 */
d1016 9
a1024 1
	s = splbio();
d1026 15
a1040 6
	while ((wdc->sc_flags & WDCF_ACTIVE) != 0) {
		wdc->sc_flags |= WDCF_WANTED;
		error = tsleep(wdc, PRIBIO | PCATCH, "wdprm", 0);
		if (error != 0) {
			splx(s);
			return error;
d1044 10
a1053 1
	wdc->sc_flags |= WDCF_ACTIVE;
d1055 3
a1057 10
	if (wdccommandshort(wdc, d_link->sc_drive, WDCC_IDENTIFY) != 0 ||
	    wait_for_drq(wdc) != 0) {
		/*
		 * We `know' there's a drive here; just assume it's old.
		 * This geometry is only used to read the MBR and print a
		 * (false) attach message.
		 */
		strncpy(d_link->sc_lp->d_typename, "ST506",
		    sizeof d_link->sc_lp->d_typename);
		d_link->sc_lp->d_type = DTYPE_ST506;
d1059 5
a1063 13
		strncpy(d_link->sc_params.wdp_model, "ST506/MFM/RLL",
		    sizeof d_link->sc_params.wdp_model);
		d_link->sc_params.wdp_config = WD_CFG_FIXED;
		d_link->sc_params.wdp_cylinders = 1024;
		d_link->sc_params.wdp_heads = 8;
		d_link->sc_params.wdp_sectors = 17;
		d_link->sc_params.wdp_maxmulti = 0;
		d_link->sc_params.wdp_usedmovsd = 0;
		d_link->sc_params.wdp_capabilities = 0;
	} else {
		strncpy(d_link->sc_lp->d_typename, "ESDI/IDE",
		    sizeof d_link->sc_lp->d_typename);
		d_link->sc_lp->d_type = DTYPE_ESDI;
d1065 2
a1066 46
		/* Read in parameter block. */
		bus_space_read_multi_2(iot, ioh, wd_data, tb,
		    sizeof(tb) / sizeof(u_int16_t));
		d_link->sc_params.wdp_config = (u_int16_t)tb[0];
		d_link->sc_params.wdp_cylinders = (u_int16_t)tb[1];
		d_link->sc_params.wdp_heads = (u_int16_t)tb[3];
		d_link->sc_params.wdp_unfbytespertrk = (u_int16_t)tb[4];
		d_link->sc_params.wdp_unfbytespersec = (u_int16_t)tb[5];
		d_link->sc_params.wdp_sectors = (u_int16_t)tb[6];
		u_int16_to_string (tb + 7, d_link->sc_params.wdp_vendor1, 6);
		u_int16_to_string (tb + 10, d_link->sc_params.wdp_serial, 20);
		d_link->sc_params.wdp_buftype = (u_int16_t)tb[20];
		d_link->sc_params.wdp_bufsize = (u_int16_t)tb[21];
		d_link->sc_params.wdp_eccbytes = (u_int16_t)tb[22];
		u_int16_to_string (tb + 23, d_link->sc_params.wdp_revision, 8);
		u_int16_to_string (tb + 27, d_link->sc_params.wdp_model, 40);
		d_link->sc_params.wdp_maxmulti = (u_int8_t)(tb[47] & 0xff);
		d_link->sc_params.wdp_vendor2[0] = (u_int8_t)(tb[47] >> 8 &
		    0xff);
		d_link->sc_params.wdp_usedmovsd = (u_int16_t)tb[48];
		d_link->sc_params.wdp_vendor3[0] = (u_int8_t)(tb[49] & 0xff);
		d_link->sc_params.wdp_capabilities = (u_int8_t)(tb[49] >> 8 &
		    0xff);
		d_link->sc_params.wdp_vendor4[0] = (u_int8_t)(tb[50] & 0xff);
		d_link->sc_params.wdp_piotiming = (u_int8_t)(tb[50] >> 8 &
		    0xff);
		d_link->sc_params.wdp_vendor5[0] = (u_int8_t)(tb[51] & 0xff);
		d_link->sc_params.wdp_dmatiming = (u_int8_t)(tb[51] >> 8 &
		    0xff);
		d_link->sc_params.wdp_capvalid = (u_int16_t)tb[52];
		d_link->sc_params.wdp_curcyls = (u_int16_t)tb[53];
		d_link->sc_params.wdp_curheads = (u_int16_t)tb[54];
		d_link->sc_params.wdp_cursectors = (u_int16_t)tb[55];
		d_link->sc_params.wdp_curcapacity[0] = (u_int16_t)tb[56];
		d_link->sc_params.wdp_curcapacity[1] = (u_int16_t)tb[57];
		d_link->sc_params.wdp_curmulti = (u_int8_t)(tb[58] & 0xff);
		d_link->sc_params.wdp_valmulti = (u_int8_t)(tb[58] >> 8 & 0xff);
		d_link->sc_params.wdp_lbacapacity[0] = (u_int16_t)tb[59];
		d_link->sc_params.wdp_lbacapacity[1] = (u_int16_t)tb[60];
		d_link->sc_params.wdp_dma1word = (u_int16_t)tb[61];
		d_link->sc_params.wdp_dmamword = (u_int16_t)tb[62];
		d_link->sc_params.wdp_eidepiomode = (u_int16_t)tb[63];
		d_link->sc_params.wdp_eidedmamin = (u_int16_t)tb[64];
		d_link->sc_params.wdp_eidedmatime = (u_int16_t)tb[65];
		d_link->sc_params.wdp_eidepiotime = (u_int16_t)tb[66];
		d_link->sc_params.wdp_eidepioiordy = (u_int16_t)tb[67];
d1068 1
d1070 5
a1074 24
	/* Clear any leftover interrupt. */
	(void) bus_space_read_1(iot, ioh, wd_status);

	/* Restart the queue. */
	WDDEBUG_PRINT(("wdcstart from wdc_get_parms flags %d\n",
	    wdc->sc_flags));
	wdc->sc_flags &= ~WDCF_ACTIVE;
	wdcstart(wdc);

	splx(s);
	return 0;
}

void
wdcerror(wdc, msg) 
	struct wdc_softc *wdc;
	char *msg;
{
	struct wdc_xfer *xfer = wdc->sc_xfer.tqh_first;
	if (xfer == NULL)
		printf("%s: %s\n", wdc->sc_dev.dv_xname, msg);
	else
		printf("%s(%s): %s\n", wdc->sc_dev.dv_xname, 
		    ((struct device*)xfer->d_link->wd_softc)->dv_xname, msg);
d1294 4
a1297 8

/* 
 * the bit bucket
 */
void
wdcbit_bucket(wdc, size)
	struct wdc_softc *wdc; 
	int size;
d1301 39
a1339 1
	int i;
d1341 6
a1346 2
	for (i = 0 ; i < size / 2 ; i++) {
		u_int16_t null; 
d1348 4
a1351 6
		bus_space_read_multi_2(iot, ioh, wd_data, &null, 1);
	} 

	if (size % 2)
		bus_space_read_1(iot, ioh, wd_data);
}
d1353 403
d1757 1
a1757 1
wdc_atapi_intr(wdc, xfer)
d1759 2
a1760 1
	struct wdc_xfer *xfer;
a1763 3
	struct atapi_command_packet *acp = xfer->atapi_cmd;
	int len, phase, i, retries = 0;
	int err, st, ire;
d1765 1
a1765 6
	if (wait_for_unbusy(wdc) < 0) {
		printf("wdc_atapi_intr: controller busy\n");
		acp->status = ERROR;
		acp->error = bus_space_read_1(iot, ioh, wd_error);
		return 0;
	}
d1767 4
a1770 2
#ifdef ATAPI_DEBUG2
	printf("wdc_atapi_intr: %s\n", wdc->sc_dev.dv_xname);
d1773 18
a1790 3
again:
	len = bus_space_read_1(iot, ioh, wd_cyl_lo) +
	    256 * bus_space_read_1(iot, ioh, wd_cyl_hi);
d1792 1
a1792 15
	st = bus_space_read_1(iot, ioh, wd_status);
	err = bus_space_read_1(iot, ioh, wd_error);
	ire = bus_space_read_1(iot, ioh, wd_ireason);
	
	phase = (ire & (WDCI_CMD | WDCI_IN)) | (st & WDCS_DRQ);
#ifdef ATAPI_DEBUG_WDC
	printf("wdc_atapi_intr: len %d st %d err %d ire %d :",
	    len, st, err, ire);
#endif
	switch (phase) {
	case PHASE_CMDOUT:
		/* send packet command */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_CMDOUT\n");
#endif
d1794 1
a1794 4
#ifdef ATAPI_DEBUG_WDC
		{
			int i;
			char *c = (char *)acp->command;   
d1796 7
a1802 6
			printf("wdc_atapi_intr: cmd ");
			for (i = 0; i < acp->command_size; i++)
				printf("0x%x ", c[i]);
			printf("\n");
		}
#endif
d1804 7
a1810 4
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		bus_space_write_raw_multi_2(iot, ioh, wd_data, acp->command,
		    acp->command_size);
		return 1;
d1812 7
a1818 4
	case PHASE_DATAOUT:
		/* write data */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_DATAOUT\n");
d1820 4
a1823 27
		if ((acp->flags & (B_READ|B_WRITE)) != B_WRITE) {
			printf("wdc_atapi_intr: bad data phase\n");
			acp->status = ERROR;
			return 1;
		}
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		if (xfer->c_bcount < len) {
			printf("wdc_atapi_intr: warning: write only "
			    "%d of %d requested bytes\n", xfer->c_bcount, len);
			bus_space_write_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_bcount);
			for (i = xfer->c_bcount; i < len; i += sizeof(short))
				bus_space_write_2(iot, ioh, wd_data, 0);
			xfer->c_bcount = 0;
			return 1;
		} else {
			bus_space_write_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, len);
			xfer->c_skip += len;
			xfer->c_bcount -= len;
			return 1;
		}
	
	case PHASE_DATAIN:
		/* Read data */
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_DATAIN\n");
d1825 4
a1828 21
		if ((acp->flags & (B_READ|B_WRITE)) != B_READ) {
			printf("wdc_atapi_intr: bad data phase\n");
			acp->status = ERROR;
			return 1;
		}
		wdc->sc_flags |= WDCF_IRQ_WAIT;
		if (xfer->c_bcount < len) {
			printf("wdc_atapi_intr: warning: reading only "
			    "%d of %d bytes\n", xfer->c_bcount, len);
			bus_space_read_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_bcount);
			wdcbit_bucket(wdc, len - xfer->c_bcount);
			xfer->c_bcount = 0;
			return 1;
		} else {
			bus_space_read_raw_multi_2(iot, ioh, wd_data,
			    xfer->databuf + xfer->c_skip, len);
			xfer->c_skip += len;
			xfer->c_bcount -=len;
			return 1;
		}
d1830 5
a1834 4
	case PHASE_ABORTED:
	case PHASE_COMPLETED:
#ifdef ATAPI_DEBUG_WDC
		printf("PHASE_COMPLETED\n");
d1836 4
a1839 9
		if (st & WDCS_ERR) {
			acp->error = bus_space_read_1(iot, ioh, wd_error);
			acp->status = ERROR;
		}
#ifdef ATAPI_DEBUG_WDC
		if (xfer->c_bcount != 0) {
			printf("wdc_atapi_intr warning: bcount value "
			    "is %d after io\n", xfer->c_bcount);
		}
d1841 5
a1845 1
		break;
d1847 5
a1851 8
	default: 
		if (++retries < 500) {
			DELAY(100);
			goto again;
		}
		printf("wdc_atapi_intr: unknown phase %d\n", phase);
		acp->status = ERROR;
	}
d1853 4
a1856 2
	wdc_atapi_done(wdc, xfer);
	return (0);
a1858 1

d1860 1
a1860 1
wdc_atapi_done(wdc, xfer)
d1862 1
a1862 1
	struct wdc_xfer *xfer;
d1864 7
a1870 2
	struct atapi_command_packet *acp = xfer->atapi_cmd;
	int s;
d1872 11
a1882 1
	acp->data_size = xfer->c_bcount;
d1884 2
a1885 1
	s = splbio();
d1887 2
a1888 19
	/* remove this command from xfer queue */
	wdc->sc_errors = 0;
	xfer->c_skip = 0;
	if ((xfer->c_flags & A_POLLED) == 0) {
		untimeout(wdctimeout, wdc);
		TAILQ_REMOVE(&wdc->sc_xfer, xfer, c_xferchain);
		wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);
		wdc_free_xfer(xfer);
#ifdef ATAPI_DEBUG
		printf("wdc_atapi_done: atapi_done\n");
#endif
		atapi_done(acp);
#ifdef WDDEBUG
		printf("wdcstart from wdc_atapi_intr, flags %d\n",
		    wdc->sc_flags);
#endif
		wdcstart(wdc);
	} else
		wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR | WDCF_ACTIVE);
d1890 2
a1891 1
	splx(s);
@


1.17
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.16 1996/11/28 08:23:39 downsj Exp $	*/
d147 1
a147 1
		return (0);
d166 1
a166 1
			return 0;
d173 1
a173 1
			return 0;
d184 1
a184 1
		return 0;
d191 1
a191 1
		return 0;
d195 4
d200 4
d705 2
a706 2
			(void)bus_space_read_1(iot, ioh, wd_error);
			(void)bus_space_read_1(iot, ioh, wd_seccnt);
d714 1
a714 2
				printf ("wdcintr: clearing up %d bytes\n",
				    len);
d716 1
a716 1
				wdcbit_bucket (wdc, len);
d727 1
a727 1
		(void) wdc_atapi_intr(wdc, xfer);
d757 2
a758 1
		WDDEBUG_PRINT(("wdc_ata_start from wdc_ata_intr(open) flags %d\n",
d1591 4
d1606 2
a1607 1
			printf("wdc_atapi_intr: got wrong phase (0x%x)\n",
d1616 2
a1617 1
			printf("wdc_atapi_intr: got wrong phase (0x%x)\n",
d1621 1
a1621 1
			for (i = 2000; i > 0; --i)
d1625 2
d1628 1
a1628 1
			printf("wdc_atapi_intr: i = %d\n", i);
d1631 5
d1680 1
a1680 1
		(void)bus_space_read_1(iot, ioh, wd_data);
d1729 1
d1785 1
a1785 2
			    xfer->databuf + xfer->c_skip,
			    xfer->c_bcount);
@


1.16
log
@Pull in laptop changes from cgd, a couple from me, and a few slight formatting
nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.15 1996/11/23 21:46:49 kstailey Exp $	*/
d60 1
a60 1
#include <machine/bus.old.h>
d133 2
a134 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d145 2
a146 2
	wdc->sc_bc = bc = ia->ia_bc;
	if (bus_io_map(bc, ia->ia_iobase, 8, &ioh))
d152 1
a152 1
	bus_io_write_1(bc, ioh, wd_error, 0x5a);
d154 3
a156 3
	bus_io_write_1(bc, ioh, wd_cyl_lo, 0xa5);
	if (bus_io_read_1(bc, ioh, wd_error) == 0x5a ||
	    bus_io_read_1(bc, ioh, wd_cyl_lo) != 0xa5) {
d161 5
a165 5
		bus_io_write_1(bc, ioh, wd_sdh, WDSD_IBM | 0x10);
		bus_io_write_1(bc, ioh, wd_error, 0x5a);
		bus_io_write_1(bc, ioh, wd_cyl_lo, 0xa5);
		if (bus_io_read_1(bc, ioh, wd_error) == 0x5a ||
		    bus_io_read_1(bc, ioh, wd_cyl_lo) != 0xa5)
d178 1
a178 1
		bus_io_write_1(bc, ioh, wd_sdh, WDSD_IBM | 0x10);
d180 1
a180 1
		bus_io_write_1(bc, ioh, wd_sdh, WDSD_IBM);
d187 1
a187 1
	bus_io_write_1(bc, ioh, wd_command, WDCC_DIAGNOSE);
d342 2
a343 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d395 1
a395 1
		    bus_io_read_1(bc, ioh, wd_altsts)));
d526 1
a526 1
		    bus_io_read_1(bc, ioh, wd_altsts)));
d549 1
a549 1
			bus_io_write_raw_multi_2(bc, ioh, wd_data,
d552 1
a552 1
			bus_io_write_raw_multi_4(bc, ioh, wd_data,
d567 2
a568 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d572 1
a572 1
		phase = (bus_io_read_1(bc, ioh, wd_ireason) &
d574 1
a574 1
		    (bus_io_read_1(bc, ioh, wd_status)
d588 2
a589 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d593 1
a593 1
		phase = (bus_io_read_1(bc, ioh, wd_ireason) &
d595 1
a595 1
		    (bus_io_read_1(bc, ioh, wd_status)
d609 2
a610 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d618 1
a618 1
		acp->error = bus_io_read_1(bc, ioh, wd_error);
d643 2
a644 1
				printf("wdc_atapi_start: timeout waiting PHASE_CMDOUT, got 0x%x\n", phase);
d652 1
a652 1
		bus_io_write_raw_multi_2(bc, ioh, wd_data, acp->command,
d679 2
a680 2
		bus_chipset_tag_t bc = wdc->sc_bc;
		bus_io_handle_t ioh = wdc->sc_ioh;
d688 1
a688 1
		s = bus_io_read_1(bc, ioh, wd_status);
d691 2
a692 2
			e = bus_io_read_1(bc, ioh, wd_error);
			i = bus_io_read_1(bc, ioh, wd_seccnt);
d697 2
a698 2
			(void)bus_io_read_1(bc, ioh, wd_error);
			(void)bus_io_read_1(bc, ioh, wd_seccnt);
d702 3
a704 2
				int len = bus_io_read_1(bc, ioh, wd_cyl_lo) +
				    256 * bus_io_read_1(bc, ioh, wd_cyl_hi);
d706 2
a707 1
				printf ("wdcintr: clearing up %d bytes\n", len);
d733 2
a734 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d809 1
a809 1
			bus_io_read_raw_multi_2(bc, ioh, wd_data,
d812 1
a812 1
			bus_io_read_raw_multi_4(bc, ioh, wd_data,
d850 2
a851 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d854 1
a854 1
	bus_io_write_1(bc, ioh, wd_ctlr, WDCTL_RST|WDCTL_IDS);
d856 1
a856 1
	bus_io_write_1(bc, ioh, wd_ctlr, WDCTL_IDS);
d858 2
a859 2
	(void) bus_io_read_1(bc, ioh, wd_error);
	bus_io_write_1(bc, ioh, wd_ctlr, WDCTL_4BIT);
d923 2
a924 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d934 2
a935 1
		wdc->sc_status = status = bus_io_read_1(bc, ioh, wd_status);
d942 1
a942 1
			bus_io_write_1(bc, ioh, wd_sdh,
d944 1
a944 1
			wdc->sc_status = status = bus_io_read_1(bc, ioh,
d958 1
a958 1
		wdc->sc_error = bus_io_read_1(bc, ioh, wd_error);
d1009 2
a1010 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1021 1
a1021 1
        bus_io_write_1(bc, ioh, wd_sdh, WDSD_IBM | (drive << 4) | head);
d1039 1
a1039 1
                bus_io_write_1(bc, ioh, wd_precomp,
d1042 5
a1046 5
                bus_io_write_1(bc, ioh, wd_features, 0);
        bus_io_write_1(bc, ioh, wd_cyl_lo, cylin);
        bus_io_write_1(bc, ioh, wd_cyl_hi, cylin >> 8);
        bus_io_write_1(bc, ioh, wd_sector, sector);
        bus_io_write_1(bc, ioh, wd_seccnt, count);
d1049 1
a1049 1
        bus_io_write_1(bc, ioh, wd_command, command);
d1063 2
a1064 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1075 1
a1075 1
        bus_io_write_1(bc, ioh, wd_sdh, WDSD_IBM|(drive << 4));
d1080 1
a1080 1
        bus_io_write_1(bc, ioh, wd_command, command);
d1206 2
a1207 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1248 1
a1248 1
		bus_io_write_1(bc, ioh, wd_seccnt, d_link->sc_multiple);
d1310 2
a1311 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1362 1
a1362 1
		bus_io_read_multi_2(bc, ioh, wd_data, tb,
d1410 1
a1410 1
	(void) bus_io_read_1(bc, ioh, wd_status);
d1442 2
a1443 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1517 2
a1518 2
	len = bus_io_read_1(bc, ioh, wd_cyl_lo) + 256 *
	    bus_io_read_1(bc, ioh, wd_cyl_hi);
d1531 1
a1531 1
	bus_io_read_raw_multi_2(bc, ioh, wd_data, (u_int8_t *)id,
d1550 2
a1551 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1597 1
a1597 1
		bus_io_write_raw_multi_2(bc, ioh, wd_data, acp->command,
d1608 1
a1608 1
				if ((bus_io_read_1(bc, ioh, wd_status) &
d1648 2
a1649 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1654 2
a1655 1
		(void)bus_io_read_multi_2(bc, ioh, wd_data, &null, 1);
d1659 1
a1659 1
		(void)bus_io_read_1(bc, ioh, wd_data);
d1667 2
a1668 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d1676 1
a1676 1
		acp->error = bus_io_read_1(bc, ioh, wd_error);
d1685 2
a1686 2
	len = bus_io_read_1(bc, ioh, wd_cyl_lo) +
	    256 * bus_io_read_1(bc, ioh, wd_cyl_hi);
d1688 3
a1690 3
	st = bus_io_read_1(bc, ioh, wd_status);
	err = bus_io_read_1(bc, ioh, wd_error);
	ire = bus_io_read_1(bc, ioh, wd_ireason);
d1716 1
a1716 1
		bus_io_write_raw_multi_2(bc, ioh, wd_data, acp->command,
d1734 1
a1734 1
			bus_io_write_raw_multi_2(bc, ioh, wd_data,
d1737 1
a1737 1
				bus_io_write_2(bc, ioh, wd_data, 0);
d1741 1
a1741 1
			bus_io_write_raw_multi_2(bc, ioh, wd_data,
d1762 1
a1762 1
			bus_io_read_raw_multi_2(bc, ioh, wd_data,
d1769 1
a1769 1
			bus_io_read_raw_multi_2(bc, ioh, wd_data,
d1782 1
a1782 1
			acp->error = bus_io_read_1(bc, ioh, wd_error);
@


1.15
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.14 1996/11/12 20:30:45 niklas Exp $	*/
d344 1
a344 1
	struct wd_link *d_link;
a347 2
	d_link=xfer->d_link;

d349 1
a349 1
		wderror(d_link, bp, "hard error");
d356 1
a356 1
	if (d_link->sc_state < OPEN) {
a674 2
	bus_chipset_tag_t bc = wdc->sc_bc;
	bus_io_handle_t ioh = wdc->sc_ioh;
d678 2
d688 1
d690 2
a691 2
		e = bus_io_read_1(bc, ioh, wd_error);
		i = bus_io_read_1(bc, ioh, wd_seccnt);
d693 2
a694 2
		printf("wdcintr: inactive controller, "
		    "punting st=%02x er=%02x irr=%02x\n", s, e, i);
d696 2
a697 2
		(void)bus_io_read_1(bc, ioh, wd_error);
		(void)bus_io_read_1(bc, ioh, wd_seccnt);
d700 3
a702 3
		if (s & WDCS_DRQ) {
			int len = bus_io_read_1(bc, ioh, wd_cyl_lo) +
			    256 * bus_io_read_1(bc, ioh, wd_cyl_hi);
d704 1
a704 1
			printf ("wdcintr: clearing up %d bytes\n", len);
d706 2
a707 1
			wdcbit_bucket (wdc, len);
d717 1
a717 1
		(void) wdc_atapi_intr(wdc,xfer);
d720 1
a720 1
		return wdc_ata_intr(wdc,xfer);
d732 1
a732 3
	struct wd_link *d_link;

	d_link = xfer->d_link;
d742 1
a742 1
	if (d_link->sc_state < OPEN) {
d777 3
a779 2
		wdcunwedge(wdc);
		if (wdc->sc_errors < WDIORETRIES)
d781 3
d1123 1
a1123 1
	struct wdc_softc *wdc=(struct wdc_softc *)d_link->wdc_softc;
d1175 1
a1175 1
	bzero(xfer,sizeof(struct wdc_xfer));
d1243 1
a1243 1
			goto open;
d1262 2
a1263 2
	case OPEN:
	open:
d1265 1
a1265 1
		d_link->sc_state = OPEN;
@


1.14
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.13 1996/11/06 09:43:10 niklas Exp $	*/
d88 1
a88 1
int	wdcprint	__P((void *, char *));
d201 1
a201 1
	char *wdc;
@


1.13
log
@Correct ISADMA condition.  Now both amiga & arc can use IDE with >4k xfers
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.12 1996/09/22 09:02:33 downsj Exp $	*/
d60 1
a60 1
#include <machine/bus.h>
@


1.12
log
@Get some things ready for later.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.11 1996/09/22 05:16:40 downsj Exp $	*/
a415 1
#endif
d418 4
@


1.11
log
@add a slight delay
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.10 1996/09/16 02:38:20 downsj Exp $	*/
d679 4
d686 1
a686 1
		u_char s = bus_io_read_1(bc, ioh, wd_status);
d688 2
a689 2
		u_char e = bus_io_read_1(bc, ioh, wd_error);
		u_char i = bus_io_read_1(bc, ioh, wd_seccnt);
d1355 6
a1360 6
		d_link->sc_params.wdp_config = (int16_t)tb[0];
		d_link->sc_params.wdp_cylinders = (int16_t)tb[1];
		d_link->sc_params.wdp_heads = (int16_t)tb[3];
		d_link->sc_params.wdp_unfbytespertrk = (int16_t)tb[4];
		d_link->sc_params.wdp_unfbytespersec = (int16_t)tb[5];
		d_link->sc_params.wdp_sectors = (int16_t)tb[6];
d1363 3
a1365 3
		d_link->sc_params.wdp_buftype = (int16_t)tb[20];
		d_link->sc_params.wdp_bufsize = (int16_t)tb[21];
		d_link->sc_params.wdp_eccbytes = (int16_t)tb[22];
d1369 8
a1376 1
		d_link->sc_params.wdp_vendor2[0] = (int8_t)(tb[47] >> 8 &
d1378 2
a1379 3
		d_link->sc_params.wdp_usedmovsd = (int16_t)tb[48];
		d_link->sc_params.wdp_vendor3[0] = (int8_t)(tb[49] & 0xff);
		d_link->sc_params.wdp_capabilities = (int8_t)(tb[49] >> 8 &
d1381 17
a1397 4
		d_link->sc_params.wdp_vendor4[0] = (int8_t)(tb[50] & 0xff);
		d_link->sc_params.wdp_piotiming = (int8_t)(tb[50] >> 8 & 0xff);
		d_link->sc_params.wdp_vendor5[0] = (int8_t)(tb[51] & 0xff);
		d_link->sc_params.wdp_dmatiming = (int8_t)(tb[51] >> 8 & 0xff);
@


1.10
log
@theo the pendat
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.9 1996/09/16 02:36:08 downsj Exp $	*/
d679 2
@


1.9
log
@pretty pretty pointless support
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.8 1996/09/11 07:27:03 downsj Exp $	*/
d1332 1
a1332 1
		strncpy(d_link->sc_params.wdp_model, "ST506/MFM",
@


1.8
log
@Rearrange much of the polling code so really, really *busted* NEC hardware
mostly works, along with various other bits of cleanup.

Please, people, if you have any choice in the matter at all, avoid NEC
IDE CD-ROM drives like the plague upon mankind they are.  Especially DO
NOT connect a NEC and another brand ATAPI drive to the same controller!
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.7 1996/09/09 05:29:16 mickey Exp $	*/
d1312 2
a1313 1
		if ((error = tsleep(wdc, PRIBIO | PCATCH, "wdprm", 0)) != 0) {
d1332 1
a1332 1
		strncpy(d_link->sc_params.wdp_model, "unknown",
@


1.7
log
@iresolve constatnt to name combination, itsn't it more clear?
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.6 1996/09/04 00:51:15 downsj Exp $	*/
d103 2
d396 1
a396 1
		WDDEBUG_PRINT((" %d)%x", xfer->c_skip,
d561 42
d638 12
a649 17
		int i, phase;
		for (i=20000; i>0; --i) {
			phase = (bus_io_read_1(bc, ioh, wd_ireason) &
			    (WDCI_CMD | WDCI_IN)) |
			    (bus_io_read_1(bc, ioh, wd_status)
			    & WDCS_DRQ);
			if (phase == PHASE_CMDOUT)
				break;
			delay(10);
		}
		if (phase != PHASE_CMDOUT ) {
			printf("wdc_atapi_start: timout waiting PHASE_CMDOUT");
			printf("(0x%x)\n", phase);
			acp->status = ERROR;
			wdc_atapi_done(wdc, xfer);
			return;
		}
d936 1
a936 1
			printf("wdcwait: timeout, status %x\n", status);
d1421 1
a1421 1
	 * If there is only one ATAPI slave ion the bus,don't probe
d1425 1
a1425 1
	if (wdc->sc_flags & WDCF_ONESLAVE && drive != 1)
d1485 8
a1492 4
		printf("Warning drive %d returned %d/%d of "
		    "identify device data\n", drive, len,
		    sizeof(struct atapi_identify));
		excess = len - sizeof(struct atapi_identify);
d1522 2
a1523 1
		int i;
d1557 4
a1560 12
		for (i = 20000; i > 0; --i) {
			int phase;
			phase = (bus_io_read_1(bc, ioh, wd_ireason) &
			    (WDCI_CMD | WDCI_IN)) |
			    (bus_io_read_1(bc, ioh, wd_status) & WDCS_DRQ);
			if (phase == PHASE_CMDOUT)
				break;
			delay(10);
		}
#ifdef ATAPI_DEBUG_WDC
		printf("Wait for cmd i/o phase: i = %d\n", i);
#endif
d1566 5
a1570 13
		for ( i= 20000; i > 0; --i) {
			int phase;
			phase = (bus_io_read_1(bc, ioh, wd_ireason) &
			    (WDCI_CMD | WDCI_IN)) |
			    (bus_io_read_1(bc, ioh, wd_status) & WDCS_DRQ);
			if (phase != PHASE_CMDOUT)
				break;
			delay(10);
		}

#ifdef ATAPI_DEBUG_WDC
		printf("Wait for data i/o phase: i = %d\n", i);
#endif
d1674 1
a1674 1
				printf("%x ", c[i]);
@


1.6
log
@Pull in pieces of Manuel's patch6:

	- At Milton Ngan's request, wdc now probes for atapi devices first, and
	  then wd drives, because some old atapi devices were detected as ide
  	  drives.
  	- Integration of Milton Ngan's fix for some
	 'wdc_atapi_intr: unknown phase 1' due to a timing problem.

Some additional changes (like ADEV_* -> AQUIRK_*) for the sake of
compatibility.  Manuel's additional quirk type was added as well.

I'm not sure I like the retry change to wdc.c; please let me know if anyone
has any problems with their drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.5 1996/08/17 06:24:54 downsj Exp $	*/
d593 1
a593 1
	if ((acp->flags & 0x0300) != ACAP_DRQ_INTR) {
d606 1
@


1.5
log
@Don't increment sc_errors right after calling wdcunwedge().
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.4 1996/08/12 05:21:20 niklas Exp $	*/
d231 15
a280 15

	/*
	 * Attach an ATAPI bus, if configured.
	 */
	wdc->ab_link = malloc(sizeof(struct bus_link), M_DEVBUF, M_NOWAIT);
	if (wdc->ab_link == NULL) {
		printf("%s: can't allocate ATAPI link\n", self->dv_xname);
		return;
	}
	bzero(wdc->ab_link,sizeof(struct bus_link));
	wdc->ab_link->type = BUS;
	wdc->ab_link->wdc_softc = (caddr_t)wdc;
	wdc->ab_link->ctlr_link = &(wdc->ctlr_link);
	wdc->ab_link->ctrl = self->dv_unit;
	(void)config_found(self, (void *)wdc->ab_link, NULL);
d1605 1
a1605 1
	int len, phase, i;
d1619 1
d1729 4
@


1.4
log
@fixed typo
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.3 1996/08/07 01:53:02 downsj Exp $	*/
d731 1
a731 1
		if (++wdc->sc_errors < WDIORETRIES)
@


1.3
log
@bus.h using wd/wdc drivers, by niklas.  IDE now works on both i386 and amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc.c,v 1.2 1996/06/09 08:59:56 downsj Exp $	*/
d1446 1
a1446 1
		    "indentify device data\n", drive, len,
@


1.2
log
@acd.c: Removed some pointless code, cleaned up some more debug statements.
everything: added RCS ids.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d38 3
a40 1
#undef ATAPI_DEBUG_WDC
d60 1
a62 1
#include <machine/pio.h>
d88 1
d131 2
a134 1
	int iobase;
d136 11
a146 1
	wdc->sc_iobase = iobase = ia->ia_iobase;
d149 6
a154 3
	outb(iobase+wd_error, 0x5a);	/* Error register not writable, */
	outb(iobase+wd_cyl_lo, 0xa5);	/* but all of cyllo are. */
	if (inb(iobase+wd_error) == 0x5a || inb(iobase+wd_cyl_lo) != 0xa5) {
d159 5
a163 5
		outb(iobase+wd_sdh, WDSD_IBM | 0x10);
		outb(iobase+wd_error, 0x5a);
		outb(iobase+wd_cyl_lo, 0xa5);
		if (inb(iobase+wd_error) == 0x5a || inb(iobase+wd_cyl_lo)
		    != 0xa5)
d176 1
a176 1
		outb(iobase+wd_sdh, WDSD_IBM | 0x10);
d178 1
a178 1
		outb(iobase+wd_sdh, WDSD_IBM);
d185 1
a185 1
	outb(iobase+wd_command, WDCC_DIAGNOSE);
d197 1
a197 1
wdprint(aux, wdc)
d255 1
d259 1
d263 1
a263 1
			    wdprint);
d340 2
a347 2
loop:
    
d395 1
a395 1
		    inb(wdc->sc_iobase + wd_altsts)));
d410 1
d414 1
d480 1
d493 1
d523 1
a523 1
		    inb(wdc->sc_iobase + wd_altsts)));
d546 2
a547 3
			outsw(wdc->sc_iobase + wd_data,
			    xfer->databuf + xfer->c_skip,
			    xfer->c_nbytes >> 1);
d549 2
a550 3
			outsl(wdc->sc_iobase + wd_data,
			    xfer->databuf + xfer->c_skip,
			    xfer->c_nbytes >> 2);
d564 2
d573 1
a573 1
		acp->error = inb (wdc->sc_iobase + wd_error);
d596 1
a596 1
			phase = (inb(wdc->sc_iobase + wd_ireason) &
d598 2
a599 1
			    (inb(wdc->sc_iobase + wd_status) & WDCS_DRQ);
d610 2
a611 2
		outsw(wdc->sc_iobase + wd_data, acp->command,
		    acp->command_size / sizeof(short));
d634 2
d640 4
a643 3
		u_char s = inb(wdc->sc_iobase+wd_status);
		u_char e = inb(wdc->sc_iobase+wd_error);
		u_char i = inb(wdc->sc_iobase+wd_seccnt);
a644 1
#ifdef ATAPI_DEBUG_WDC
d647 3
d653 2
a654 2
			int len = inb (wdc->sc_iobase + wd_cyl_lo) +
			    256 * inb (wdc->sc_iobase + wd_cyl_hi);
d681 2
d701 1
a701 1
		    dc->sc_flags));
d706 1
d713 1
d755 2
a756 2
			insw(wdc->sc_iobase+wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes >> 1);
d758 2
a759 2
			insl(wdc->sc_iobase+wd_data,
			    xfer->databuf + xfer->c_skip, xfer->c_nbytes >> 2);
d796 2
a797 1
	int iobase = wdc->sc_iobase;
d800 1
a800 1
	outb(iobase+wd_ctlr, WDCTL_RST | WDCTL_IDS);
d802 1
a802 1
	outb(iobase+wd_ctlr, WDCTL_IDS);
d804 2
a805 2
	(void) inb(iobase+wd_error);
	outb(iobase+wd_ctlr, WDCTL_4BIT);
d869 2
a870 1
	int iobase = wdc->sc_iobase;
d880 1
a880 1
		wdc->sc_status = status = inb(iobase+wd_status);
d887 4
a890 2
			outb(iobase+wd_sdh, WDSD_IBM | 0x10);
			wdc->sc_status = status = inb(iobase+wd_status);
d903 1
a903 1
		wdc->sc_error = inb(iobase+wd_error);
d954 2
a955 1
        int iobase = wdc->sc_iobase;
d966 1
a966 1
        outb(iobase+wd_sdh, WDSD_IBM | (drive << 4) | head);
d984 2
a985 1
                outb(iobase + wd_precomp, d_link->sc_lp->d_precompcyl / 4);
d987 5
a991 5
                outb(iobase + wd_features, 0);
        outb(iobase + wd_cyl_lo, cylin);
        outb(iobase + wd_cyl_hi, cylin >> 8);
        outb(iobase + wd_sector, sector);
        outb(iobase + wd_seccnt, count);
d994 1
a994 1
        outb(iobase + wd_command, command);
d1008 2
a1009 1
	int iobase = wdc->sc_iobase;
d1015 1
a1015 1
		printf("wdccommandshort: controler not active (drive %d)\n",
d1020 1
a1020 1
        outb(iobase + wd_sdh, WDSD_IBM | (drive << 4));
d1025 1
a1025 1
        outb(iobase + wd_command, command);
d1060 1
a1060 1
	wdstart((void*)d_link->wd_softc);
d1096 1
a1096 1
	if (xfer = xfer_free_list.lh_first) {
d1151 2
d1193 1
a1193 1
		outb(wdc->sc_iobase + wd_seccnt, d_link->sc_multiple);
d1230 17
d1255 3
a1257 2
	int i;
	char tb[DEV_BSIZE];
d1306 26
a1331 9
		insw(wdc->sc_iobase + wd_data, tb, sizeof(tb) / sizeof(short));
		bcopy(tb, &d_link->sc_params, sizeof(struct wdparams));

		/* Shuffle string byte order. */
		for (i = 0; i < sizeof(d_link->sc_params.wdp_model); i += 2) {
			u_short *p;
			p = (u_short *)(d_link->sc_params.wdp_model + i);
			*p = ntohs(*p);
		}
d1335 1
a1335 1
	(void) inb(wdc->sc_iobase + wd_status);
d1367 2
d1375 1
d1442 2
a1443 2
	len = inb(wdc->sc_iobase + wd_cyl_lo) + 256 *
	    inb(wdc->sc_iobase + wd_cyl_hi);
d1452 2
a1453 2
	insw(wdc->sc_iobase + wd_data, id,
	    sizeof(struct atapi_identify)/sizeof(short));
d1471 2
a1474 1
	int s;
d1514 1
a1514 1
			phase = (inb(wdc->sc_iobase + wd_ireason) &
d1516 1
a1516 1
			    (inb(wdc->sc_iobase + wd_status) & WDCS_DRQ);
d1525 2
a1526 2
		outsw(wdc->sc_iobase + wd_data, acp->command,
		    acp->command_size/ sizeof (short));
d1531 1
a1531 1
			phase = (inb(wdc->sc_iobase + wd_ireason) &
d1533 1
a1533 1
			    (inb(wdc->sc_iobase + wd_status) & WDCS_DRQ);
d1544 2
a1545 2
				if ((inb(wdc->sc_iobase + wd_status)
				    & WDCS_DRQ) == 0)
d1584 2
a1585 1
	int iobase = wdc->sc_iobase; 
d1589 2
a1590 2
		short null; 
		(void)insw(iobase + wd_data, &null, 1);
d1594 1
a1594 1
		(void)inb(iobase + wd_data);
d1602 2
d1611 1
a1611 1
		acp->error = inb (wdc->sc_iobase + wd_error);
d1619 2
a1620 2
	len = inb(wdc->sc_iobase + wd_cyl_lo) +
	    256 * inb(wdc->sc_iobase + wd_cyl_hi);
d1622 3
a1624 3
	st = inb(wdc->sc_iobase + wd_status);
	err = inb(wdc->sc_iobase + wd_error);
	ire = inb(wdc->sc_iobase + wd_ireason);
d1650 2
a1651 2
		outsw(wdc->sc_iobase + wd_data, acp->command,
		    acp->command_size/ sizeof (short));
d1668 2
a1669 3
			outsw(wdc->sc_iobase + wd_data,
			    xfer->databuf + xfer->c_skip,
			    xfer->c_bcount / sizeof(short));
d1671 1
a1671 1
				outw(wdc->sc_iobase + wd_data, 0);
d1675 2
a1676 2
			outsw(wdc->sc_iobase + wd_data,
			    xfer->databuf + xfer->c_skip, len / sizeof(short));
d1696 1
a1696 1
			insw(wdc->sc_iobase + wd_data,
d1698 1
a1698 1
			    xfer->c_bcount / sizeof(short));
d1703 2
a1704 2
			insw(wdc->sc_iobase + wd_data,
			    xfer->databuf + xfer->c_skip, len / sizeof(short));
d1716 1
a1716 1
			acp->error = inb(wdc->sc_iobase + wd_error);
@


1.1
log
@Initial support ATAPI CD-ROMs.

Based on Manuel Bouyer's drivers.
@
text
@d1 1
@
