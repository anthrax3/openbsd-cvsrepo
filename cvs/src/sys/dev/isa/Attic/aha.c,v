head	1.82;
access;
symbols
	OPENBSD_6_0:1.81.0.2
	OPENBSD_6_0_BASE:1.81
	OPENBSD_5_9:1.80.0.2
	OPENBSD_5_9_BASE:1.80
	OPENBSD_5_8:1.80.0.6
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.80.0.4
	OPENBSD_5_7_BASE:1.80
	OPENBSD_5_6:1.76.0.4
	OPENBSD_5_6_BASE:1.76
	OPENBSD_5_5:1.75.0.8
	OPENBSD_5_5_BASE:1.75
	OPENBSD_5_4:1.75.0.4
	OPENBSD_5_4_BASE:1.75
	OPENBSD_5_3:1.75.0.2
	OPENBSD_5_3_BASE:1.75
	OPENBSD_5_2:1.74.0.6
	OPENBSD_5_2_BASE:1.74
	OPENBSD_5_1_BASE:1.74
	OPENBSD_5_1:1.74.0.4
	OPENBSD_5_0:1.74.0.2
	OPENBSD_5_0_BASE:1.74
	OPENBSD_4_9:1.73.0.4
	OPENBSD_4_9_BASE:1.73
	OPENBSD_4_8:1.73.0.2
	OPENBSD_4_8_BASE:1.73
	OPENBSD_4_7:1.66.0.2
	OPENBSD_4_7_BASE:1.66
	OPENBSD_4_6:1.63.0.4
	OPENBSD_4_6_BASE:1.63
	OPENBSD_4_5:1.62.0.2
	OPENBSD_4_5_BASE:1.62
	OPENBSD_4_4:1.58.0.4
	OPENBSD_4_4_BASE:1.58
	OPENBSD_4_3:1.58.0.2
	OPENBSD_4_3_BASE:1.58
	OPENBSD_4_2:1.57.0.2
	OPENBSD_4_2_BASE:1.57
	OPENBSD_4_1:1.56.0.2
	OPENBSD_4_1_BASE:1.56
	OPENBSD_4_0:1.55.0.4
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.55.0.2
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.53.0.4
	OPENBSD_3_8_BASE:1.53
	OPENBSD_3_7:1.53.0.2
	OPENBSD_3_7_BASE:1.53
	OPENBSD_3_6:1.51.0.6
	OPENBSD_3_6_BASE:1.51
	SMP_SYNC_A:1.51
	SMP_SYNC_B:1.51
	OPENBSD_3_5:1.51.0.4
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.51.0.2
	OPENBSD_3_4_BASE:1.51
	UBC_SYNC_A:1.51
	OPENBSD_3_3:1.49.0.2
	OPENBSD_3_3_BASE:1.49
	OPENBSD_3_2:1.47.0.2
	OPENBSD_3_2_BASE:1.47
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	UBC_SYNC_B:1.49
	UBC:1.41.0.2
	UBC_BASE:1.41
	OPENBSD_3_0:1.39.0.2
	OPENBSD_3_0_BASE:1.39
	OPENBSD_2_9_BASE:1.38
	OPENBSD_2_9:1.38.0.2
	OPENBSD_2_8:1.35.0.4
	OPENBSD_2_8_BASE:1.35
	OPENBSD_2_7:1.35.0.2
	OPENBSD_2_7_BASE:1.35
	SMP:1.34.0.4
	SMP_BASE:1.34
	kame_19991208:1.34
	OPENBSD_2_6:1.34.0.2
	OPENBSD_2_6_BASE:1.34
	OPENBSD_2_5:1.33.0.2
	OPENBSD_2_5_BASE:1.33
	OPENBSD_2_4:1.31.0.2
	OPENBSD_2_4_BASE:1.31
	OPENBSD_2_3:1.30.0.4
	OPENBSD_2_3_BASE:1.30
	OPENBSD_2_2:1.30.0.2
	OPENBSD_2_2_BASE:1.30
	OPENBSD_2_1:1.28.0.2
	OPENBSD_2_1_BASE:1.28
	OPENBSD_2_0:1.25.0.2
	OPENBSD_2_0_BASE:1.25
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.82
date	2016.09.03.21.37.29;	author tedu;	state dead;
branches;
next	1.81;
commitid	DGIJrTNYvP6n52WM;

1.81
date	2016.03.14.23.08.06;	author krw;	state Exp;
branches;
next	1.80;
commitid	kCz5QgxnxRMKOzNf;

1.80
date	2014.12.17.06.58.10;	author guenther;	state Exp;
branches;
next	1.79;
commitid	DImukoCWyTxwdbuh;

1.79
date	2014.12.15.02.24.23;	author guenther;	state Exp;
branches;
next	1.78;
commitid	ZxaujiOM0aYQRjFY;

1.78
date	2014.11.16.12.31.00;	author deraadt;	state Exp;
branches;
next	1.77;
commitid	yv0ECmCdICvq576h;

1.77
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.76;
commitid	uzzBR7hz9ncd4O6G;

1.76
date	2014.03.28.17.57.11;	author mpi;	state Exp;
branches;
next	1.75;

1.75
date	2013.01.06.22.06.54;	author martynas;	state Exp;
branches;
next	1.74;

1.74
date	2011.04.07.13.27.48;	author krw;	state Exp;
branches;
next	1.73;

1.73
date	2010.08.07.03.50.01;	author krw;	state Exp;
branches;
next	1.72;

1.72
date	2010.07.02.02.29.45;	author tedu;	state Exp;
branches;
next	1.71;

1.71
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.28.21.23.18;	author kettenis;	state Exp;
branches;
next	1.67;

1.67
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.66;

1.66
date	2010.01.10.00.40.25;	author krw;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.22.14.14.11;	author krw;	state Exp;
branches;
next	1.64;

1.64
date	2009.08.26.22.29.09;	author jasper;	state Exp;
branches;
next	1.63;

1.63
date	2009.04.14.16.01.04;	author oga;	state Exp;
branches;
next	1.62;

1.62
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.61;

1.61
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.58;

1.58
date	2007.10.09.17.06.18;	author gilles;	state Exp;
branches;
next	1.57;

1.57
date	2007.08.15.02.04.30;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2005.12.03.17.13.22;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.53;

1.53
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.29.06.20.02;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.50;

1.50
date	2003.04.10.10.11.24;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2002.10.07.18.35.57;	author mickey;	state Exp;
branches;
next	1.48;

1.48
date	2002.10.06.22.06.15;	author art;	state Exp;
branches;
next	1.47;

1.47
date	2002.06.08.17.09.48;	author niklas;	state Exp;
branches;
next	1.46;

1.46
date	2002.06.07.20.41.06;	author niklas;	state Exp;
branches;
next	1.45;

1.45
date	2002.06.07.01.25.07;	author niklas;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.42;

1.42
date	2002.01.24.22.38.03;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	2001.12.08.02.24.07;	author art;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.11.30.17.24.19;	author art;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.27.04.45.58;	author art;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.02.23.12.50;	author niklas;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.29.06.40.14;	author mickey;	state Exp;
branches;
next	1.36;

1.36
date	2000.11.13.13.43.01;	author niklas;	state Exp;
branches;
next	1.35;

1.35
date	2000.04.19.02.17.49;	author niklas;	state Exp;
branches;
next	1.34;

1.34
date	99.08.19.07.40.14;	author deraadt;	state Exp;
branches
	1.34.4.1;
next	1.33;

1.33
date	99.01.07.06.14.46;	author niklas;	state Exp;
branches;
next	1.32;

1.32
date	98.12.27.09.41.56;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	98.08.13.04.36.50;	author downsj;	state Exp;
branches;
next	1.30;

1.30
date	97.09.15.19.28.31;	author flipk;	state Exp;
branches;
next	1.29;

1.29
date	97.07.30.22.12.11;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	97.01.16.19.47.47;	author kstailey;	state Exp;
branches;
next	1.27;

1.27
date	96.11.23.21.46.35;	author kstailey;	state Exp;
branches;
next	1.26;

1.26
date	96.10.16.12.29.48;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	96.06.19.14.40.33;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	96.06.01.12.20.40;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	96.06.01.12.18.30;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.05.31.10.57.04;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	96.05.31.08.14.51;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.05.27.01.11.44;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	96.05.26.00.27.09;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.05.10.12.35.01;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.05.07.07.51.27;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.05.02.13.31.42;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.04.22.20.03.02;	author hannken;	state Exp;
branches;
next	1.14;

1.14
date	96.04.21.22.22.09;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.03.20.01.00.35;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.03.19.21.10.02;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.03.08.16.42.47;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.02.20.04.35.42;	author tholo;	state Exp;
branches;
next	1.9;

1.9
date	96.01.23.10.10.31;	author hannken;	state Exp;
branches;
next	1.8;

1.8
date	96.01.21.09.25.34;	author hannken;	state Exp;
branches;
next	1.7;

1.7
date	96.01.12.17.52.48;	author hannken;	state Exp;
branches;
next	1.6;

1.6
date	95.12.27.22.06.11;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	95.12.14.06.16.14;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.11.30.23.03.46;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.11.30.22.59.06;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.15.42;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches;
next	;

1.34.4.1
date	2001.05.14.22.24.28;	author niklas;	state Exp;
branches;
next	1.34.4.2;

1.34.4.2
date	2001.07.04.10.41.23;	author niklas;	state Exp;
branches;
next	1.34.4.3;

1.34.4.3
date	2001.12.05.00.43.29;	author niklas;	state Exp;
branches;
next	1.34.4.4;

1.34.4.4
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.34.4.5;

1.34.4.5
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.34.4.6;

1.34.4.6
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.34.4.7;

1.34.4.7
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	;

1.41.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.41.2.4;

1.41.2.4
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.82
log
@the src tree is growing too large. delete the aha and ahb drivers in
order to make room for llvm. er, the llvm makefiles. er, some of them.
@
text
@/*	$OpenBSD: aha.c,v 1.81 2016/03/14 23:08:06 krw Exp $	*/
/*	$NetBSD: aha.c,v 1.11 1996/05/12 23:51:23 mycroft Exp $	*/

#undef AHADIAG

/*
 * Copyright (c) 1994, 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Originally written by Julian Elischer (julian@@tfs.com)
 * for TRW Financial Systems for use under the MACH(2.5) operating system.
 *
 * TRW Financial Systems, in accordance with their agreement with Carnegie
 * Mellon University, makes this software available to CMU to distribute
 * or use in any manner that they see fit as long as this message is kept with
 * the software. For this reason TFS also grants any other persons or
 * organisations permission to use or modify this software.
 *
 * TFS supplies this software to be publicly redistributed
 * on the understanding that TFS is not responsible for the correct
 * functioning of this software in any circumstances.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/timeout.h>

#include <uvm/uvm_extern.h>

#include <machine/intr.h>
#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <dev/isa/ahareg.h>

/* XXX fixme:
 * on i386 at least, xfers to/from user memory
 * cannot be serviced at interrupt time.
 */
#ifdef __i386__
#define VOLATILE_XS(xs) \
	((xs)->datalen > 0 && (xs)->bp == NULL && \
	((xs)->flags & SCSI_POLL) == 0)
#else
#define VOLATILE_XS(xs)        0
#endif

/*
 * Mail box defs  etc.
 * these could be bigger but we need the aha_softc to fit on a single page..
 */
#define AHA_MBX_SIZE	16	/* mail box size */

#define	AHA_CCB_MAX	16	/* store up to 32 CCBs at one time */
#define	CCB_HASH_SIZE	16	/* hash table size for phystokv */
#define	CCB_HASH_SHIFT	9
#define	CCB_HASH(x)	((((long)(x))>>CCB_HASH_SHIFT) & (CCB_HASH_SIZE - 1))

#define aha_nextmbx(wmb, mbx, mbio) \
	if ((wmb) == &(mbx)->mbio[AHA_MBX_SIZE - 1])	\
		(wmb) = &(mbx)->mbio[0];		\
	else						\
		(wmb)++;

struct aha_mbx {
	struct aha_mbx_out mbo[AHA_MBX_SIZE];
	struct aha_mbx_in mbi[AHA_MBX_SIZE];
	struct aha_mbx_out *cmbo;	/* Collection Mail Box out */
	struct aha_mbx_out *tmbo;	/* Target Mail Box out */
	struct aha_mbx_in *tmbi;	/* Target Mail Box in */
};

struct aha_softc {
	struct device sc_dev;
	struct isadev sc_id;
	void *sc_ih;
	bus_dma_tag_t sc_dmat;

	int sc_iobase;
	int sc_irq, sc_drq;

	char sc_model[18],
	     sc_firmware[4];

	struct aha_mbx *sc_mbx;		/* all the mailboxes */
#define	wmbx	(sc->sc_mbx)
	struct aha_ccb *sc_ccbhash[CCB_HASH_SIZE];
	TAILQ_HEAD(, aha_ccb) sc_free_ccb, sc_waiting_ccb;
	int sc_numccbs, sc_mbofull;
	int sc_scsi_dev;		/* our scsi id */
	struct scsi_link sc_link;

	struct mutex		sc_ccb_mtx;
	struct scsi_iopool	sc_iopool;
};

#ifdef AHADEBUG
int	aha_debug = 1;
#endif /* AHADEBUG */

int aha_cmd(int, struct aha_softc *, int, u_char *, int, u_char *);
void aha_finish_ccbs(struct aha_softc *);
int ahaintr(void *);
void aha_reset_ccb(struct aha_softc *, struct aha_ccb *);
void aha_ccb_free(void *, void *);
int aha_init_ccb(struct aha_softc *, struct aha_ccb *, int);
void *aha_ccb_alloc(void *);
struct aha_ccb *aha_ccb_phys_kv(struct aha_softc *, u_long);
void aha_queue_ccb(struct aha_softc *, struct aha_ccb *);
void aha_collect_mbo(struct aha_softc *);
void aha_start_ccbs(struct aha_softc *);
void aha_done(struct aha_softc *, struct aha_ccb *);
int aha_find(struct isa_attach_args *, struct aha_softc *, int);
void aha_init(struct aha_softc *);
void aha_inquire_setup_information(struct aha_softc *);
void ahaminphys(struct buf *, struct scsi_link *);
void aha_scsi_cmd(struct scsi_xfer *);
int aha_poll(struct aha_softc *, struct scsi_xfer *, int);
void aha_timeout(void *arg);

struct scsi_adapter aha_switch = {
	aha_scsi_cmd,
	ahaminphys,
	0,
	0,
};

int	aha_isapnp_probe(struct device *, void *, void *);
int	ahaprobe(struct device *, void *, void *);
void	ahaattach(struct device *, struct device *, void *);

struct cfattach aha_isapnp_ca = {
	sizeof(struct aha_softc), aha_isapnp_probe, ahaattach
};

struct cfattach aha_isa_ca = {
	sizeof(struct aha_softc), ahaprobe, ahaattach
};

struct cfdriver aha_cd = {
	NULL, "aha", DV_DULL
};

#define AHA_RESET_TIMEOUT	2000	/* time to wait for reset (mSec) */
#define	AHA_ABORT_TIMEOUT	2000	/* time to wait for abort (mSec) */

#include "bha.h"

/*
 * aha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)
 *
 * Activate Adapter command
 *    icnt:   number of args (outbound bytes including opcode)
 *    ibuf:   argument buffer
 *    ocnt:   number of expected returned bytes
 *    obuf:   result buffer
 *    wait:   number of seconds to wait for response
 *
 * Performs an adapter command through the ports.  Not to be confused with a
 * scsi command, which is read in via the dma; one of the adapter commands
 * tells it to read in a scsi command.
 */
int
aha_cmd(iobase, sc, icnt, ibuf, ocnt, obuf)
	int iobase;
	struct aha_softc *sc;
	int icnt, ocnt;
	u_char *ibuf, *obuf;
{
	const char *name;
	register int i;
	int wait;
	u_char sts;
	u_char opcode = ibuf[0];

	if (sc != NULL)
		name = sc->sc_dev.dv_xname;
	else
		name = "(aha probe)";

	/*
	 * Calculate a reasonable timeout for the command.
	 */
	switch (opcode) {
	case AHA_INQUIRE_DEVICES:
		wait = 15 * 20000;
		break;
	default:
		wait = 1 * 20000;
		break;
	}

	/*
	 * Wait for the adapter to go idle, unless it's one of
	 * the commands which don't need this
	 */
	if (opcode != AHA_MBO_INTR_EN) {
		for (i = 20000; i; i--) {	/* 1 sec? */
			sts = inb(iobase + AHA_STAT_PORT);
			if (sts & AHA_STAT_IDLE)
				break;
			delay(50);
		}
		if (!i) {
			printf("%s: aha_cmd, host not idle(0x%x)\n",
			    name, sts);
			return (ENXIO);
		}
	}
	/*
	 * Now that it is idle, if we expect output, preflush the
	 * queue feeding to us.
	 */
	if (ocnt) {
		while ((inb(iobase + AHA_STAT_PORT)) & AHA_STAT_DF)
			inb(iobase + AHA_DATA_PORT);
	}
	/*
	 * Output the command and the number of arguments given
	 * for each byte, first check the port is empty.
	 */
	while (icnt--) {
		for (i = wait; i; i--) {
			sts = inb(iobase + AHA_STAT_PORT);
			if (!(sts & AHA_STAT_CDF))
				break;
			delay(50);
		}
		if (!i) {
			if (opcode != AHA_INQUIRE_REVISION)
				printf("%s: aha_cmd, cmd/data port full\n",
				    name);
			outb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);
			return (ENXIO);
		}
		outb(iobase + AHA_CMD_PORT, *ibuf++);
	}
	/*
	 * If we expect input, loop that many times, each time,
	 * looking for the data register to have valid data
	 */
	while (ocnt--) {
		for (i = wait; i; i--) {
			sts = inb(iobase + AHA_STAT_PORT);
			if (sts & AHA_STAT_DF)
				break;
			delay(50);
		}
		if (!i) {
			if (opcode != AHA_INQUIRE_REVISION)
				printf("%s: aha_cmd, cmd/data port empty %d\n",
				    name, ocnt);
			outb(iobase + AHA_CTRL_PORT, AHA_CTRL_SRST);
			return (ENXIO);
		}
		*obuf++ = inb(iobase + AHA_DATA_PORT);
	}
	/*
	 * Wait for the board to report a finished instruction.
	 * We may get an extra interrupt for the HACC signal, but this is
	 * unimportant.
	 */
	if (opcode != AHA_MBO_INTR_EN) {
		for (i = 20000; i; i--) {	/* 1 sec? */
			sts = inb(iobase + AHA_INTR_PORT);
			/* XXX Need to save this in the interrupt handler? */
			if (sts & AHA_INTR_HACC)
				break;
			delay(50);
		}
		if (!i) {
			printf("%s: aha_cmd, host not finished(0x%x)\n",
			    name, sts);
			return (ENXIO);
		}
	}
	outb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);
	return (0);
}

int
aha_isapnp_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return (1);
}


/*
 * Check if the device can be found at the port given
 * and if so, set it up ready for further work
 * as an argument, takes the isa_device structure from
 * autoconf.c
 */
int
ahaprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	register struct isa_attach_args *ia = aux;
#if NBHA > 0
	extern int btports[], nbtports;
	int i;

	for (i = 0; i < nbtports; i++)
		if (btports[i] == ia->ia_iobase)
			return (0);
#endif

	/* See if there is a unit at this location. */
	if (aha_find(ia, NULL, 0) != 0)
		return (0);

	ia->ia_msize = 0;
	ia->ia_iosize = 4;
	/* IRQ and DRQ set by aha_find(). */
	return (1);
}

/*
 * Attach all the sub-devices we can find
 */
void
ahaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isa_attach_args *ia = aux;
	struct aha_softc *sc = (void *)self;
	struct scsibus_attach_args saa;
	int isapnp = !strcmp(parent->dv_cfdata->cf_driver->cd_name, "isapnp");

	if (isapnp) {
		ia->ia_iobase = ia->ipa_io[0].base;
		isadma_cascade(ia->ia_drq);
	}

	if (aha_find(ia, sc, isapnp) != 0)
		panic("ahaattach: aha_find of %s failed", self->dv_xname);
	sc->sc_iobase = ia->ia_iobase;
	sc->sc_dmat = ia->ia_dmat;

	if (sc->sc_drq != DRQUNK && isapnp == 0)
		isadma_cascade(sc->sc_drq);

	aha_inquire_setup_information(sc);
	aha_init(sc);
	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_waiting_ccb);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, aha_ccb_alloc, aha_ccb_free);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_scsi_dev;
	sc->sc_link.adapter = &aha_switch;
	sc->sc_link.openings = 2;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	sc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,
	    IPL_BIO, ahaintr, sc, sc->sc_dev.dv_xname);

	/*
	 * ask the adapter what subunits are present
	 */
	config_found(self, &saa, scsiprint);
}

void
aha_finish_ccbs(sc)
	struct aha_softc *sc;
{
	struct aha_mbx_in *wmbi;
	struct aha_ccb *ccb;
	int i;

	wmbi = wmbx->tmbi;

	if (wmbi->stat == AHA_MBI_FREE) {
		for (i = 0; i < AHA_MBX_SIZE; i++) {
			if (wmbi->stat != AHA_MBI_FREE) {
				printf("%s: mbi not in round-robin order\n",
				    sc->sc_dev.dv_xname);
				goto AGAIN;
			}
			aha_nextmbx(wmbi, wmbx, mbi);
		}
#ifdef AHADIAGnot
		printf("%s: mbi interrupt with no full mailboxes\n",
		    sc->sc_dev.dv_xname);
#endif
		return;
	}

AGAIN:
	do {
		ccb = aha_ccb_phys_kv(sc, phystol(wmbi->ccb_addr));
		if (!ccb) {
			printf("%s: bad mbi ccb pointer; skipping\n",
			    sc->sc_dev.dv_xname);
			goto next;
		}

#ifdef AHADEBUG
		if (aha_debug) {
			u_char *cp = (u_char *)&ccb->scsi_cmd;
			printf("op=%x %x %x %x %x %x\n",
			    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
			printf("stat %x for mbi addr = 0x%08x, ",
			    wmbi->stat, wmbi);
			printf("ccb addr = 0x%x\n", ccb);
		}
#endif /* AHADEBUG */

		switch (wmbi->stat) {
		case AHA_MBI_OK:
		case AHA_MBI_ERROR:
			if ((ccb->flags & CCB_ABORT) != 0) {
				/*
				 * If we already started an abort, wait for it
				 * to complete before clearing the CCB.  We
				 * could instead just clear CCB_SENDING, but
				 * what if the mailbox was already received?
				 * The worst that happens here is that we clear
				 * the CCB a bit later than we need to.  BFD.
				 */
				goto next;
			}
			break;

		case AHA_MBI_ABORT:
		case AHA_MBI_UNKNOWN:
			/*
			 * Even if the CCB wasn't found, we clear it anyway.
			 * See preceding comment.
			 */
			break;

		default:
			printf("%s: bad mbi status %02x; skipping\n",
			    sc->sc_dev.dv_xname, wmbi->stat);
			goto next;
		}

		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout_del(&ccb->xs->stimeout);
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
		aha_done(sc, ccb);

	next:
		wmbi->stat = AHA_MBI_FREE;
		aha_nextmbx(wmbi, wmbx, mbi);
	} while (wmbi->stat != AHA_MBI_FREE);

	wmbx->tmbi = wmbi;
}

/*
 * Catch an interrupt from the adaptor
 */
int
ahaintr(arg)
	void *arg;
{
	struct aha_softc *sc = arg;
	int iobase = sc->sc_iobase;
	u_char sts;

#ifdef AHADEBUG
	if (aha_debug)
		printf("%s: ahaintr ", sc->sc_dev.dv_xname);
#endif /*AHADEBUG */

	/*
	 * First acknowledge the interrupt, Then if it's not telling about
	 * a completed operation just return.
	 */
	sts = inb(iobase + AHA_INTR_PORT);
	if ((sts & AHA_INTR_ANYINTR) == 0)
		return (0);
	outb(iobase + AHA_CTRL_PORT, AHA_CTRL_IRST);

#ifdef AHADIAG
	/* Make sure we clear CCB_SENDING before finishing a CCB. */
	aha_collect_mbo(sc);
#endif

	/* Mail box out empty? */
	if (sts & AHA_INTR_MBOA) {
		struct aha_toggle toggle;

		toggle.cmd.opcode = AHA_MBO_INTR_EN;
		toggle.cmd.enable = 0;
		aha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd,
		    0, NULL);
		aha_start_ccbs(sc);
	}

	/* Mail box in full? */
	if (sts & AHA_INTR_MBIF)
		aha_finish_ccbs(sc);

	return (1);
}

void
aha_reset_ccb(sc, ccb)
	struct aha_softc *sc;
	struct aha_ccb *ccb;
{

	ccb->flags = 0;
}

/*
 * A ccb is put onto the free list.
 */
void
aha_ccb_free(xsc, xccb)
	void *xsc, *xccb;
{
	struct aha_softc *sc = xsc;
	struct aha_ccb *ccb = xccb;
	int s, hashnum;
	struct aha_ccb **hashccb;

	s = splbio();

	if (ccb->ccb_dmam->dm_segs[0].ds_addr != 0)
		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmam);

	/* remove from hash table */

	hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
	hashccb = &sc->sc_ccbhash[hashnum];

	while (*hashccb) {
		if ((*hashccb)->ccb_dmam->dm_segs[0].ds_addr ==
		    ccb->ccb_dmam->dm_segs[0].ds_addr) {
			*hashccb = (*hashccb)->nexthash;
			break;
		}
		hashccb = &(*hashccb)->nexthash;
	}

	aha_reset_ccb(sc, ccb);

	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, chain);
	mtx_leave(&sc->sc_ccb_mtx);

	splx(s);
}

int
aha_init_ccb(sc, ccb, flags)
	struct aha_softc *sc;
	struct aha_ccb *ccb;
	int flags;
{
	int error, wait, state = 0;

	bzero(ccb, sizeof(struct aha_ccb));
	aha_reset_ccb(sc, ccb);

	wait = (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
	/* Create a DMA map for the data area.  */
	error = bus_dmamap_create(sc->sc_dmat, MAXPHYS, (MAXPHYS / NBPG) + 1,
	    MAXPHYS, 0, wait | BUS_DMA_ALLOCNOW, &ccb->dmam);
	if (error)
		goto fail;
	state++;

	/* Create a DMA map for the command control block.  */
	error = bus_dmamap_create(sc->sc_dmat, CCB_PHYS_SIZE, 1, CCB_PHYS_SIZE,
	    0, wait | BUS_DMA_ALLOCNOW, &ccb->ccb_dmam);
	if (error)
		goto fail;

	return (0);

 fail:
	if (state > 0)
		bus_dmamap_destroy(sc->sc_dmat, ccb->dmam);
	return (error);
}

/*
 * Get a free ccb
 *
 * If there are none, see if we can allocate a new one.  If so, put it in
 * the hash table too otherwise either return an error or sleep.
 */
void *
aha_ccb_alloc(xsc)
	void *xsc;
{
	struct aha_softc *sc = xsc;
	struct aha_ccb *ccb;
	int hashnum, s;

	s = splbio();

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb) {
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
		ccb->flags |= CCB_ALLOC;
		if (bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmam, ccb, CCB_PHYS_SIZE,
		    NULL, BUS_DMA_NOWAIT) != 0) {
			mtx_leave(&sc->sc_ccb_mtx);
			aha_ccb_free(sc, ccb);
			splx(s);
			return (NULL);
		} else {
			hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
			ccb->nexthash = sc->sc_ccbhash[hashnum];
			sc->sc_ccbhash[hashnum] = ccb;
		}
	}
	mtx_leave(&sc->sc_ccb_mtx);

	splx(s);
	return (ccb);
}

/*
 * Given a physical address, find the ccb that it corresponds to.
 */
struct aha_ccb *
aha_ccb_phys_kv(sc, ccb_phys)
	struct aha_softc *sc;
	u_long ccb_phys;
{
	int hashnum = CCB_HASH(ccb_phys);
	struct aha_ccb *ccb = sc->sc_ccbhash[hashnum];

	while (ccb) {
		if (ccb->ccb_dmam->dm_segs[0].ds_addr == ccb_phys)
			break;
		ccb = ccb->nexthash;
	}
	return (ccb);
}

/*
 * Queue a CCB to be sent to the controller, and send it if possible.
 */
void
aha_queue_ccb(sc, ccb)
	struct aha_softc *sc;
	struct aha_ccb *ccb;
{

	TAILQ_INSERT_TAIL(&sc->sc_waiting_ccb, ccb, chain);
	aha_start_ccbs(sc);
}

/*
 * Garbage collect mailboxes that are no longer in use.
 */
void
aha_collect_mbo(sc)
	struct aha_softc *sc;
{
	struct aha_mbx_out *wmbo;	/* Mail Box Out pointer */
#ifdef AHADIAG
	struct aha_ccb *ccb;
#endif

	wmbo = wmbx->cmbo;

	while (sc->sc_mbofull > 0) {
		if (wmbo->cmd != AHA_MBO_FREE)
			break;

#ifdef AHADIAG
		ccb = aha_ccb_phys_kv(sc, phystol(wmbo->ccb_addr));
		if (!ccb) {
			printf("%s: bad mbo ccb pointer; skipping\n",
			    sc->sc_dev.dv_xname);
		} else
			ccb->flags &= ~CCB_SENDING;
#endif

		--sc->sc_mbofull;
		aha_nextmbx(wmbo, wmbx, mbo);
	}

	wmbx->cmbo = wmbo;
}

/*
 * Send as many CCBs as we have empty mailboxes for.
 */
void
aha_start_ccbs(sc)
	struct aha_softc *sc;
{
	int iobase = sc->sc_iobase;
	struct aha_mbx_out *wmbo;	/* Mail Box Out pointer */
	struct aha_ccb *ccb;

	wmbo = wmbx->tmbo;

	while ((ccb = TAILQ_FIRST(&sc->sc_waiting_ccb)) != NULL) {
		if (sc->sc_mbofull >= AHA_MBX_SIZE) {
			aha_collect_mbo(sc);
			if (sc->sc_mbofull >= AHA_MBX_SIZE) {
				struct aha_toggle toggle;

				toggle.cmd.opcode = AHA_MBO_INTR_EN;
				toggle.cmd.enable = 1;
				aha_cmd(iobase, sc, sizeof(toggle.cmd),
				    (u_char *)&toggle.cmd, 0, NULL);
				break;
			}
		}

		TAILQ_REMOVE(&sc->sc_waiting_ccb, ccb, chain);
#ifdef AHADIAG
		ccb->flags |= CCB_SENDING;
#endif

		/* Link ccb to mbo. */
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		ltophys(ccb->ccb_dmam->dm_segs[0].ds_addr, wmbo->ccb_addr);
		if (ccb->flags & CCB_ABORT)
			wmbo->cmd = AHA_MBO_ABORT;
		else
			wmbo->cmd = AHA_MBO_START;

		/* Tell the card to poll immediately. */
		outb(iobase + AHA_CMD_PORT, AHA_START_SCSI);

		if ((ccb->xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->xs->stimeout, aha_timeout, ccb);
			timeout_add_msec(&ccb->xs->stimeout, ccb->timeout);
		}

		++sc->sc_mbofull;
		aha_nextmbx(wmbo, wmbx, mbo);
	}

	wmbx->tmbo = wmbo;
}

/*
 * We have a ccb which has been processed by the
 * adaptor, now we look to see how the operation
 * went. Wake up the owner if waiting
 */
void
aha_done(sc, ccb)
	struct aha_softc *sc;
	struct aha_ccb *ccb;
{
	struct scsi_sense_data *s1, *s2;
	struct scsi_xfer *xs = ccb->xs;

	SC_DEBUG(xs->sc_link, SDEV_DB2, ("aha_done\n"));
	/*
	 * Otherwise, put the results of the operation
	 * into the xfer and call whoever started it
	 */
#ifdef AHADIAG
	if (ccb->flags & CCB_SENDING)
		panic("%s: exiting ccb still in transit!", sc->sc_dev.dv_xname);
#endif
	if ((ccb->flags & CCB_ALLOC) == 0)
		panic("%s: exiting ccb not allocated!", sc->sc_dev.dv_xname);

	if (xs->error == XS_NOERROR) {
		if (ccb->host_stat != AHA_OK) {
			switch (ccb->host_stat) {
			case AHA_SEL_TIMEOUT:	/* No response */
				xs->error = XS_SELTIMEOUT;
				break;
			default:	/* Other scsi protocol messes */
				printf("%s: host_stat %x\n",
				    sc->sc_dev.dv_xname, ccb->host_stat);
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
		} else if (ccb->target_stat != SCSI_OK) {
			switch (ccb->target_stat) {
			case SCSI_CHECK:
				s1 = (struct scsi_sense_data *)
				    (((char *)(&ccb->scsi_cmd)) +
				    ccb->scsi_cmd_length);
				s2 = &xs->sense;
				*s2 = *s1;
				xs->error = XS_SENSE;
				break;
			case SCSI_BUSY:
				xs->error = XS_BUSY;
				break;
			default:
				printf("%s: target_stat %x\n",
				    sc->sc_dev.dv_xname, ccb->target_stat);
				xs->error = XS_DRIVER_STUFFUP;
				break;
			}
		} else
			xs->resid = 0;
	}

	if (VOLATILE_XS(xs)) {
		wakeup(ccb);
		return;
	}

	if (ccb->dmam->dm_nsegs > 0) {
		if (xs->flags & SCSI_DATA_IN)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
		if (xs->flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
	}
	scsi_done(xs);
}

/*
 * Find the board and find its irq/drq
 */
int
aha_find(ia, sc, isapnp)
	struct isa_attach_args *ia;
	struct aha_softc *sc;
	int isapnp;
{
	int iobase = ia->ia_iobase;
	int i;
	u_char sts;
	struct aha_config config;
	int irq, drq;

	/*
	 * reset board, If it doesn't respond, assume
	 * that it's not there.. good for the probe
	 */

	outb(iobase + AHA_CTRL_PORT, AHA_CTRL_HRST | AHA_CTRL_SRST);

	delay(100);
	for (i = AHA_RESET_TIMEOUT; i; i--) {
		sts = inb(iobase + AHA_STAT_PORT);
		if (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))
			break;
		delay(1000);	/* calibrated in msec */
	}
	if (!i) {
#ifdef AHADEBUG
		if (aha_debug)
			printf("aha_find: No answer from adaptec board\n");
#endif /* AHADEBUG */
		return (1);
	}

	/*
	 * setup dma channel from jumpers and save int
	 * level
	 */
	delay(1000);		/* for Bustek 545 */
	config.cmd.opcode = AHA_INQUIRE_CONFIG;
	aha_cmd(iobase, sc, sizeof(config.cmd), (u_char *)&config.cmd,
	    sizeof(config.reply), (u_char *)&config.reply);
	switch (config.reply.chan) {
	case EISADMA:
		drq = DRQUNK;	/* for EISA/VLB/PCI clones */
		break;
	case CHAN0:
		drq = 0;
		break;
	case CHAN5:
		drq = 5;
		break;
	case CHAN6:
		drq = 6;
		break;
	case CHAN7:
		drq = 7;
		break;
	default:
		printf("aha_find: illegal drq setting %x\n",
		    config.reply.chan);
		return (1);
	}
	if (isapnp)
		irq = ia->ia_irq;

	switch (config.reply.intr) {
	case INT9:
		irq = 9;
		break;
	case INT10:
		irq = 10;
		break;
	case INT11:
		irq = 11;
		break;
	case INT12:
		irq = 12;
		break;
	case INT14:
		irq = 14;
		break;
	case INT15:
		irq = 15;
		break;
	default:
		printf("aha_find: illegal irq setting %x\n",
		    config.reply.intr);
		return (EIO);
	}
	if (isapnp)
		drq = ia->ia_drq;

	if (sc != NULL) {
		/* who are we on the scsi bus? */
		sc->sc_scsi_dev = config.reply.scsi_dev;

		sc->sc_iobase = iobase;
		sc->sc_irq = irq;
		sc->sc_drq = drq;
	} else {
		if (isapnp)
			return (0);
		if (ia->ia_irq == IRQUNK)
			ia->ia_irq = irq;
		else if (ia->ia_irq != irq)
			return (1);
		if (ia->ia_drq == DRQUNK)
			ia->ia_drq = drq;
		else if (ia->ia_drq != drq)
			return (1);
	}

	return (0);
}

/*
 * Start the board, ready for normal operation
 */
void
aha_init(sc)
	struct aha_softc *sc;
{
	int iobase = sc->sc_iobase;
	struct aha_devices devices;
	struct aha_setup setup;
	struct aha_mailbox mailbox;
	struct pglist pglist;
	struct vm_page *pg;
	vaddr_t va;
	vsize_t size;
	int i;

	/*
	 * XXX
	 * If we are a 1542C or later, disable the extended BIOS so that the
	 * mailbox interface is unlocked.
	 * No need to check the extended BIOS flags as some of the
	 * extensions that cause us problems are not flagged in that byte.
	 */
	if (!strncmp(sc->sc_model, "1542C", 5)) {
		struct aha_extbios extbios;
		struct aha_unlock unlock;

		printf("%s: unlocking mailbox interface\n",
		    sc->sc_dev.dv_xname);
		extbios.cmd.opcode = AHA_EXT_BIOS;
		aha_cmd(iobase, sc, sizeof(extbios.cmd),
		    (u_char *)&extbios.cmd, sizeof(extbios.reply),
		    (u_char *)&extbios.reply);

#ifdef AHADEBUG
		printf("%s: flags=%02x, mailboxlock=%02x\n",
		    sc->sc_dev.dv_xname,
		    extbios.reply.flags, extbios.reply.mailboxlock);
#endif /* AHADEBUG */

		unlock.cmd.opcode = AHA_MBX_ENABLE;
		unlock.cmd.junk = 0;
		unlock.cmd.magic = extbios.reply.mailboxlock;
		aha_cmd(iobase, sc, sizeof(unlock.cmd), (u_char *)&unlock.cmd,
		    0, NULL);
	}

#if 0
	/*
	 * Change the bus on/off times to not clash with other dma users.
	 */
	aha_cmd(sc, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);
	aha_cmd(sc, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);
#endif

	/* Inquire Installed Devices (to force synchronous negotiation). */
	devices.cmd.opcode = AHA_INQUIRE_DEVICES;
	aha_cmd(iobase, sc, sizeof(devices.cmd), (u_char *)&devices.cmd,
	    sizeof(devices.reply), (u_char *)&devices.reply);

	/* Obtain setup information from. */
	setup.cmd.opcode = AHA_INQUIRE_SETUP;
	setup.cmd.len = sizeof(setup.reply);
	aha_cmd(iobase, sc, sizeof(setup.cmd), (u_char *)&setup.cmd,
	    sizeof(setup.reply), (u_char *)&setup.reply);

	printf("%s: %s, %s\n",
	    sc->sc_dev.dv_xname,
	    setup.reply.sync_neg ? "sync" : "async",
	    setup.reply.parity ? "parity" : "no parity");

	for (i = 0; i < 8; i++) {
		if (!setup.reply.sync[i].valid ||
		    (!setup.reply.sync[i].offset &&
		    !setup.reply.sync[i].period))
			continue;
		printf("%s targ %d: sync, offset %d, period %dnsec\n",
		    sc->sc_dev.dv_xname, i, setup.reply.sync[i].offset,
		    setup.reply.sync[i].period * 50 + 200);
	}

	/*
	 * Set up initial mail box for round-robin operation.
	 */

	/*
	 * XXX - this vm juggling is so wrong. use bus_dma instead!
	 */
	size = round_page(sizeof(struct aha_mbx));
	TAILQ_INIT(&pglist);
	if (uvm_pglistalloc(size, 0, 0xffffff, PAGE_SIZE, 0, &pglist, 1,
	    UVM_PLA_NOWAIT) || uvm_map(kernel_map, &va, size, NULL,
	    UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(PROT_MASK, PROT_MASK,
	    MAP_INHERIT_NONE, MADV_RANDOM, 0)))
		panic("aha_init: could not allocate mailbox");

	wmbx = (struct aha_mbx *)va;
	for (pg = TAILQ_FIRST(&pglist); pg != NULL;
	    pg = TAILQ_NEXT(pg, pageq)) {
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
		    PROT_READ | PROT_WRITE);
		va += PAGE_SIZE;
	}
	pmap_update(pmap_kernel());
	/*
	 * XXXEND
	 */

	for (i = 0; i < AHA_MBX_SIZE; i++) {
		wmbx->mbo[i].cmd = AHA_MBO_FREE;
		wmbx->mbi[i].stat = AHA_MBI_FREE;
	}
	wmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];
	wmbx->tmbi = &wmbx->mbi[0];
	sc->sc_mbofull = 0;

	/* Initialize mail box. */
	mailbox.cmd.opcode = AHA_MBX_INIT;
	mailbox.cmd.nmbx = AHA_MBX_SIZE;
	ltophys(vtophys((vaddr_t)wmbx), mailbox.cmd.addr);
	aha_cmd(iobase, sc, sizeof(mailbox.cmd), (u_char *)&mailbox.cmd,
	    0, NULL);
}

void
aha_inquire_setup_information(sc)
	struct aha_softc *sc;
{
	int iobase = sc->sc_iobase;
	struct aha_revision revision;
	u_char sts;
	int i;
	char *p;

	strlcpy(sc->sc_model, "unknown", sizeof sc->sc_model);

	/*
	 * Assume we have a board at this stage, do an adapter inquire
	 * to find out what type of controller it is.  If the command
	 * fails, we assume it's either a crusty board or an old 1542
	 * clone, and skip the board-specific stuff.
	 */
	revision.cmd.opcode = AHA_INQUIRE_REVISION;
	if (aha_cmd(iobase, sc, sizeof(revision.cmd), (u_char *)&revision.cmd,
	    sizeof(revision.reply), (u_char *)&revision.reply)) {
		/*
		 * aha_cmd() already started the reset.  It's not clear we
		 * even need to bother here.
		 */
		for (i = AHA_RESET_TIMEOUT; i; i--) {
			sts = inb(iobase + AHA_STAT_PORT);
			if (sts == (AHA_STAT_IDLE | AHA_STAT_INIT))
				break;
			delay(1000);
		}
		if (!i) {
#ifdef AHADEBUG
			printf("aha_init: soft reset failed\n");
#endif /* AHADEBUG */
			return;
		}
#ifdef AHADEBUG
		printf("aha_init: inquire command failed\n");
#endif /* AHADEBUG */
		goto noinquire;
	}

#ifdef AHADEBUG
	printf("%s: inquire %x, %x, %x, %x\n",
	    sc->sc_dev.dv_xname,
	    revision.reply.boardid, revision.reply.spec_opts,
	    revision.reply.revision_1, revision.reply.revision_2);
#endif /* AHADEBUG */

	switch (revision.reply.boardid) {
	case 0x31:
		strlcpy(sc->sc_model, "1540", sizeof sc->sc_model);
		break;
	case 0x41:
		strlcpy(sc->sc_model, "1540A/1542A/1542B", sizeof sc->sc_model);
		break;
	case 0x42:
		strlcpy(sc->sc_model, "1640", sizeof sc->sc_model);
		break;
	case 0x43:
	case 0x44:		/* Is this 1542C or -CF? */
		strlcpy(sc->sc_model, "1542C", sizeof sc->sc_model);
		break;
	case 0x45:
		strlcpy(sc->sc_model, "1542CF", sizeof sc->sc_model);
		break;
	case 0x46:
		strlcpy(sc->sc_model, "1542CP", sizeof sc->sc_model);
		break;
	}

	p = sc->sc_firmware;
	*p++ = revision.reply.revision_1;
	*p++ = '.';
	*p++ = revision.reply.revision_2;
	*p = '\0';

noinquire:
	printf(": model AHA-%s, firmware %s\n", sc->sc_model, sc->sc_firmware);
}

void
ahaminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((AHA_NSEG - 1) << PGSHIFT))
		bp->b_bcount = ((AHA_NSEG - 1) << PGSHIFT);
	minphys(bp);
}

/*
 * start a scsi operation given the command and the data address. Also needs
 * the unit, target and lu.
 */
void
aha_scsi_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *sc_link = xs->sc_link;
	struct aha_softc *sc = sc_link->adapter_softc;
	struct aha_ccb *ccb;
	struct aha_scat_gath *sg;
	int seg, flags;
	int s;

	SC_DEBUG(sc_link, SDEV_DB2, ("aha_scsi_cmd\n"));
	/*
	 * get a ccb to use. If the transfer
	 * is from a buf (possibly from interrupt time)
	 * then we can't allow it to sleep
	 */
	flags = xs->flags;
	ccb = xs->io;
	ccb->xs = xs;
	ccb->timeout = xs->timeout;

	/*
	 * Put all the arguments for the xfer in the ccb
	 */
	if (flags & SCSI_RESET) {
		ccb->opcode = AHA_RESET_CCB;
		ccb->scsi_cmd_length = 0;
	} else {
		/* can't use S/G if zero length */
		ccb->opcode =
		    (xs->datalen ? AHA_INIT_SCAT_GATH_CCB : AHA_INITIATOR_CCB);
		bcopy(xs->cmd, &ccb->scsi_cmd,
		    ccb->scsi_cmd_length = xs->cmdlen);
	}

	if (xs->datalen) {
		sg = ccb->scat_gath;
		seg = 0;

		/*
		 * Set up the scatter-gather block.
		 */
		if (bus_dmamap_load(sc->sc_dmat, ccb->dmam, xs->data,
		    xs->datalen, NULL, BUS_DMA_NOWAIT) != 0) {
			xs->error = XS_BUSY;
			scsi_done(xs);
			return;
		}
		for (seg = 0; seg < ccb->dmam->dm_nsegs; seg++) {
			ltophys(ccb->dmam->dm_segs[seg].ds_addr,
			    sg[seg].seg_addr);
			ltophys(ccb->dmam->dm_segs[seg].ds_len,
			    sg[seg].seg_len);
		}
		if (flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		if (flags & SCSI_DATA_IN)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREREAD);
		ltophys((unsigned)
		    ((struct aha_ccb *)(ccb->ccb_dmam->dm_segs[0].ds_addr))->
		    scat_gath,
		    ccb->data_addr);
		ltophys(ccb->dmam->dm_nsegs * sizeof(struct aha_scat_gath),
		    ccb->data_length);
	} else {		/* No data xfer, use non S/G values */
		ltophys(0, ccb->data_addr);
		ltophys(0, ccb->data_length);
	}

	ccb->data_out = 0;
	ccb->data_in = 0;
	ccb->target = sc_link->target;
	ccb->lun = sc_link->lun;
	ccb->req_sense_length = sizeof(ccb->scsi_sense);
	ccb->host_stat = 0x00;
	ccb->target_stat = 0x00;
	ccb->link_id = 0;
	ltophys(0, ccb->link_addr);

	s = splbio();
	aha_queue_ccb(sc, ccb);

	/*
	 * Usually return SUCCESSFULLY QUEUED
	 */
	SC_DEBUG(sc_link, SDEV_DB3, ("cmd_sent\n"));

	if (VOLATILE_XS(xs)) {
		while ((ccb->xs->flags & ITSDONE) == 0) {
			tsleep(ccb, PRIBIO, "ahawait", 0);
		}
		if (ccb->dmam->dm_nsegs > 0) {
			if (flags & SCSI_DATA_OUT)
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
			if (flags & SCSI_DATA_IN)
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
		}
		scsi_done(xs);
		splx(s);
		return;
	}
	splx(s);

	if ((flags & SCSI_POLL) == 0)
		return;

	/*
	 * If we can't use interrupts, poll on completion
	 */
	if (aha_poll(sc, xs, ccb->timeout)) {
		aha_timeout(ccb);
		if (aha_poll(sc, xs, ccb->timeout))
			aha_timeout(ccb);
	}
}

/*
 * Poll a particular unit, looking for a particular xs
 */
int
aha_poll(sc, xs, count)
	struct aha_softc *sc;
	struct scsi_xfer *xs;
	int count;
{
	int iobase = sc->sc_iobase;
	int s;

	/* timeouts are in msec, so we loop in 1000 usec cycles */
	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR) {
			s = splbio();
			ahaintr(sc);
			splx(s);
		}
		if (xs->flags & ITSDONE)
			return (0);
		delay(1000);	/* only happens in boot so ok */
		count--;
	}
	return (1);
}

void
aha_timeout(arg)
	void *arg;
{
	struct aha_ccb *ccb = arg;
	struct scsi_xfer *xs;
	struct scsi_link *sc_link;
	struct aha_softc *sc;
	int s;

	s = splbio();
	xs = ccb->xs;
	sc_link = xs->sc_link;
	sc = sc_link->adapter_softc;
	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
	    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);

	sc_print_addr(sc_link);
	printf("timed out");

#ifdef AHADIAG
	/*
	 * If The ccb's mbx is not free, then the board has gone south?
	 */
	aha_collect_mbo(sc);
	if (ccb->flags & CCB_SENDING)
		panic("%s: not taking commands!", sc->sc_dev.dv_xname);
#endif

	/*
	 * If it has been through before, then
	 * a previous abort has failed, don't
	 * try abort again
	 */
	if (ccb->flags & CCB_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");
		/* XXX Must reset! */
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		ccb->xs->error = XS_TIMEOUT;
		ccb->timeout = AHA_ABORT_TIMEOUT;
		ccb->flags |= CCB_ABORT;
		aha_queue_ccb(sc, ccb);
	}

	splx(s);
}

@


1.81
log
@Change a bunch of (<blah> *)0 to NULL.

ok beck@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.80 2014/12/17 06:58:10 guenther Exp $	*/
@


1.80
log
@Prefer MADV_* over POSIX_MADV_* in kernel for consistency: the latter
doesn't have all the values and therefore can't be used everywhere.

ok deraadt@@ kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.79 2014/12/15 02:24:23 guenther Exp $	*/
d539 1
a539 1
		    0, (u_char *)0);
d759 1
a759 1
				    (u_char *)&toggle.cmd, 0, (u_char *)0);
d1034 1
a1034 1
		    0, (u_char *)0);
d1111 1
a1111 1
	    0, (u_char *)0);
@


1.79
log
@Use MAP_INHERIT_* for the 'inh' argument to the UMV_MAPFLAG() macro,
eliminating the must-be-kept-in-sync UVM_INH_* macros

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.78 2014/11/16 12:31:00 deraadt Exp $	*/
d1083 1
a1083 1
	    MAP_INHERIT_NONE, POSIX_MADV_RANDOM, 0)))
@


1.78
log
@Replace a plethora of historical protection options with just
PROT_NONE, PROT_READ, PROT_WRITE, and PROT_EXEC from mman.h.
PROT_MASK is introduced as the one true way of extracting those bits.
Remove UVM_ADV_* wrapper, using the standard names.
ok doug guenther kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.77 2014/09/14 14:17:25 jsg Exp $	*/
d1083 1
a1083 1
	    UVM_INH_NONE, POSIX_MADV_RANDOM, 0)))
@


1.77
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.76 2014/03/28 17:57:11 mpi Exp $	*/
d1082 2
a1083 2
	    UVM_UNKNOWN_OFFSET, 0, UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL,
	    UVM_INH_NONE, UVM_ADV_RANDOM, 0)))
d1090 1
a1090 1
			VM_PROT_READ|VM_PROT_WRITE);
@


1.76
log
@Reduce uvm include madness.  Use <uvm/uvm_extern.h> instead of
<uvm/uvm.h> if possible and remove double inclusions.

ok beck@@, mlarkin@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.75 2013/01/06 22:06:54 martynas Exp $	*/
a58 1
#include <sys/proc.h>
@


1.75
log
@acknowlege -> acknowledge
compatability -> compatibility

OK jmc@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.74 2011/04/07 13:27:48 krw Exp $	*/
a61 1
#include <uvm/uvm.h>
@


1.74
log
@Iopoolification of another once common bus/device.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.73 2010/08/07 03:50:01 krw Exp $	*/
d521 1
a521 1
	 * First acknowlege the interrupt, Then if it's not telling about
@


1.73
log
@No "\n" needed at the end of panic() strings.

Bogus chunks pointed out by matthew@@ and miod@@. No cookies for
marco@@ and jasper@@.

ok deraadt@@ miod@@ matthew@@ jasper@@ macro@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.72 2010/07/02 02:29:45 tedu Exp $	*/
d131 3
d144 1
a144 1
void aha_free_ccb(struct aha_softc *, struct aha_ccb *);
d146 1
a146 1
struct aha_ccb *aha_get_ccb(struct aha_softc *, int);
d390 2
d400 1
d565 2
a566 3
aha_free_ccb(sc, ccb)
	struct aha_softc *sc;
	struct aha_ccb *ccb;
d568 2
d593 2
d596 1
a596 7

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (TAILQ_NEXT(ccb, chain) == NULL)
		wakeup(&sc->sc_free_ccb);
d640 3
a642 4
struct aha_ccb *
aha_get_ccb(sc, flags)
	struct aha_softc *sc;
	int flags;
d644 1
d650 15
a664 24
	/*
	 * If we can and have to, sleep waiting for one to come free
	 * but only if we can't allocate a new one.
	 */
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb) {
			TAILQ_REMOVE(&sc->sc_free_ccb, ccb, chain);
			break;
		}
		if (sc->sc_numccbs < AHA_CCB_MAX) {
			ccb = malloc(sizeof *ccb, M_DEVBUF,
			    (flags & SCSI_NOSLEEP) ? M_NOWAIT : M_WAITOK);
			if (ccb == NULL) {
				printf("%s: can't malloc ccb\n",
				    sc->sc_dev.dv_xname);
				goto out;
			}
			if (aha_init_ccb(sc, ccb, flags) == 0) {
				sc->sc_numccbs++;
				break;
			}
			free(ccb, M_DEVBUF);
			ccb = NULL;
a665 3
		if (flags & SCSI_NOSLEEP)
			goto out;
		tsleep(&sc->sc_free_ccb, PRIBIO, "ahaccb", 0);
d667 1
a668 12
	ccb->flags |= CCB_ALLOC;

	if (bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmam, ccb, CCB_PHYS_SIZE,
	    NULL, BUS_DMA_NOWAIT) != 0) {
		aha_free_ccb(sc, ccb);
		ccb = NULL;
	} else {
		hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
		ccb->nexthash = sc->sc_ccbhash[hashnum];
		sc->sc_ccbhash[hashnum] = ccb;
	}
out:
a868 1
	aha_free_ccb(sc, ccb);
d1228 1
a1228 5
	if ((ccb = aha_get_ccb(sc, flags)) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
d1255 1
a1255 2
			aha_free_ccb(sc, ccb);
			xs->error = XS_NO_CCB;
a1314 1
		aha_free_ccb(sc, ccb);
@


1.72
log
@some very obvious uninit bugs found when I turned off -Wno-uninitialized
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.71 2010/06/28 18:31:02 krw Exp $	*/
d1418 1
a1418 1
		panic("%s: not taking commands!\n", sc->sc_dev.dv_xname);
@


1.71
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.70 2010/06/26 23:24:44 guenther Exp $	*/
a1402 2
	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
	    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
d1406 2
@


1.70
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.69 2010/05/20 00:55:17 krw Exp $	*/
a163 8
/* the below structure is so we have a default dev struct for out link struct */
struct scsi_device aha_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

a393 1
	sc->sc_link.device = &aha_dev;
@


1.69
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.68 2010/04/28 21:23:18 kettenis Exp $	*/
a59 1
#include <sys/user.h>
@


1.68
log
@s/i386/__i386__/, no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.67 2010/03/23 01:57:20 krw Exp $	*/
a1260 1
		s = splbio();
a1261 1
		splx(s);
a1291 1
			s = splbio();
a1292 1
			splx(s);
@


1.67
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.66 2010/01/10 00:40:25 krw Exp $	*/
d80 1
a80 1
#ifdef i386
@


1.66
log
@A couple of missed ITSDONE setting before scsi_done().

seagate/trm/aha1742 were the only drivers paranoid enough to check
ITSDONE on getting the xs to execute. And optimistic enough to think
simply restting the flag would be a good thing. Have them chill out
like everyone else, reducing ITSDONE noise some more.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.65 2009/11/22 14:14:11 krw Exp $	*/
d154 1
a154 1
int aha_scsi_cmd(struct scsi_xfer *);
d1241 1
a1241 1
int
d1260 5
a1264 1
		return (NO_CCB);
d1293 5
a1297 1
			return (NO_CCB);
d1358 1
a1358 1
		return (COMPLETE);
d1363 1
a1363 1
		return (SUCCESSFULLY_QUEUED);
a1372 1
	return (COMPLETE);
@


1.65
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.64 2009/08/26 22:29:09 jasper Exp $	*/
a883 1
	xs->flags |= ITSDONE;
@


1.64
log
@directly calling Debugger() is bad. turn these printf();Debugger(); series
into panic()'s.

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.63 2009/04/14 16:01:04 oga Exp $	*/
d1290 1
a1290 2
			xs->error = XS_DRIVER_STUFFUP;
			return (TRY_AGAIN_LATER);
@


1.63
log
@Convert the waitok field of uvm_pglistalloc to "flags", more will be added soon.

For the possibility of sleeping, the first two flags are UVM_PLA_WAITOK
and UVM_PLA_NOWAIT. It is an error not to show intention, so assert that
one of the two is provided. Switch over every caller in the tree to
using the appropriate flag.

ok art@@, ariane@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.62 2009/02/16 21:19:07 miod Exp $	*/
a75 4
#ifndef DDB
#define Debugger() panic("should call debugger here (aha1542.c)")
#endif /* ! DDB */

d844 2
a845 6
	if (ccb->flags & CCB_SENDING) {
		printf("%s: exiting ccb still in transit!\n",
		    sc->sc_dev.dv_xname);
		Debugger();
		return;
	}
d847 3
a849 6
	if ((ccb->flags & CCB_ALLOC) == 0) {
		printf("%s: exiting ccb not allocated!\n",
		    sc->sc_dev.dv_xname);
		Debugger();
		return;
	}
d1426 2
a1427 4
	if (ccb->flags & CCB_SENDING) {
		printf("%s: not taking commands!\n", sc->sc_dev.dv_xname);
		Debugger();
	}
@


1.62
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.61 2009/01/21 21:54:00 grange Exp $	*/
d1125 4
a1128 4
	if (uvm_pglistalloc(size, 0, 0xffffff, PAGE_SIZE, 0, &pglist, 1, 0) ||
	    uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET, 0,
		UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_NONE,
			UVM_ADV_RANDOM, 0)))
@


1.61
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.60 2008/11/25 17:52:02 krw Exp $	*/
d157 1
a157 1
void ahaminphys(struct buf *);
d1242 1
a1242 2
ahaminphys(bp)
	struct buf *bp;
a1243 1

@


1.60
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.59 2008/09/12 11:14:04 miod Exp $	*/
d819 1
a819 1
			timeout_add(&ccb->xs->stimeout, (ccb->timeout * hz) / 1000);
@


1.59
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.58 2007/10/09 17:06:18 gilles Exp $	*/
d1274 1
a1274 1
		return (TRY_AGAIN_LATER);
@


1.58
log
@MALLOC -> malloc

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.57 2007/08/15 02:04:30 krw Exp $	*/
a1263 4
#ifdef	TFS
	struct iovec *iovp;
	int datalen;
#endif
d1296 15
a1310 34
#ifdef	TFS
		if (flags & SCSI_DATA_UIO) {
			iovp = ((struct uio *)xs->data)->uio_iov;
			datalen = ((struct uio *)xs->data)->uio_iovcnt;
			xs->datalen = 0;
			while (datalen && seg < AHA_NSEG) {
				ltophys(iovp->iov_base, sg->seg_addr);
				ltophys(iovp->iov_len, sg->seg_len);
				xs->datalen += iovp->iov_len;
				SC_DEBUGN(sc_link, SDEV_DB4, ("UIO(0x%x@@0x%x)",
				    iovp->iov_len, iovp->iov_base));
				sg++;
				iovp++;
				seg++;
				datalen--;
			}
		} else
#endif /* TFS */
		{
			/*
			 * Set up the scatter-gather block.
			 */
			if (bus_dmamap_load(sc->sc_dmat, ccb->dmam, xs->data,
			    xs->datalen, NULL, BUS_DMA_NOWAIT) != 0) {
				aha_free_ccb(sc, ccb);
				xs->error = XS_DRIVER_STUFFUP;
				return (TRY_AGAIN_LATER);
			}
			for (seg = 0; seg < ccb->dmam->dm_nsegs; seg++) {
				ltophys(ccb->dmam->dm_segs[seg].ds_addr,
				    sg[seg].seg_addr);
				ltophys(ccb->dmam->dm_segs[seg].ds_len,
				    sg[seg].seg_len);
			}
@


1.57
log
@When polling call ahaintr() at splbio(). Noticed by and fix tested by
todd@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.56 2006/11/28 23:59:45 dlg Exp $	*/
d672 1
a672 1
			MALLOC(ccb, struct aha_ccb *, sizeof *ccb, M_DEVBUF,
d683 1
a683 1
			FREE(ccb, M_DEVBUF);
@


1.56
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.55 2005/12/03 17:13:22 krw Exp $	*/
d1416 1
d1424 2
a1425 1
		if (inb(iobase + AHA_INTR_PORT) & AHA_INTR_ANYINTR)
d1427 2
@


1.55
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.54 2005/11/23 11:30:14 mickey Exp $	*/
d380 1
d410 3
d419 1
a419 1
	config_found(self, &sc->sc_link, scsiprint);
@


1.54
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.53 2004/12/26 21:22:13 miod Exp $	*/
a1273 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.53
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.52 2004/11/29 06:20:02 jsg Exp $	*/
d1150 1
a1150 1
	ltophys(vtophys(wmbx), mailbox.cmd.addr);
@


1.52
log
@Spell precede correctly.
'looks fine' millert@@, krw@@. ok jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.51 2003/04/27 11:22:53 ho Exp $	*/
d602 1
a602 1
	if (ccb->chain.tqe_next == 0)
d662 1
a662 1
		ccb = sc->sc_free_ccb.tqh_first;
d782 1
a782 1
	while ((ccb = sc->sc_waiting_ccb.tqh_first) != NULL) {
@


1.51
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.50 2003/04/10 10:11:24 miod Exp $	*/
d484 1
a484 1
			 * See preceeding comment.
@


1.50
log
@Proper use of bus_space makes the need for <machine/pio.h> obsolete, which
is good since not all isa capable platforms provide such a file.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.49 2002/10/07 18:35:57 mickey Exp $	*/
d1165 1
a1165 1
	strcpy(sc->sc_model, "unknown");
d1207 1
a1207 1
		strcpy(sc->sc_model, "1540");
d1210 1
a1210 1
		strcpy(sc->sc_model, "1540A/1542A/1542B");
d1213 1
a1213 1
		strcpy(sc->sc_model, "1640");
d1217 1
a1217 1
		strcpy(sc->sc_model, "1542C");
d1220 1
a1220 1
		strcpy(sc->sc_model, "1542CF");
d1223 1
a1223 1
		strcpy(sc->sc_model, "1542CP");
@


1.49
log
@this removes the functionality of adding allocated
pages into the queue already containing allocated pages.
breaks i386:setup_buffers() because of this.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.48 2002/10/06 22:06:15 art Exp $	*/
a66 1
#include <machine/pio.h>
@


1.48
log
@No more need to initialize the result list before uvm_pglistalloc.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.47 2002/06/08 17:09:48 niklas Exp $	*/
d1121 1
@


1.47
log
@KNF miss in my last commit
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.46 2002/06/07 20:41:06 niklas Exp $	*/
a1120 1
	TAILQ_INIT(&pglist);
@


1.46
log
@bus_dma-ify, now it works again, sorry for the inconvenience
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.45 2002/06/07 01:25:07 niklas Exp $	*/
d498 1
a498 1
			ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
@


1.45
log
@Add initialization of pglist, now attaches fine, but
bugs exist still in bounce buffering
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.44 2002/03/14 03:16:05 millert Exp $	*/
a4 1
#define integrate
d68 1
d122 1
d144 1
a144 1
integrate void aha_finish_ccbs(struct aha_softc *);
d146 1
a146 1
integrate void aha_reset_ccb(struct aha_softc *, struct aha_ccb *);
d148 1
a148 1
integrate void aha_init_ccb(struct aha_softc *, struct aha_ccb *);
d257 1
a257 1
			return ENXIO;
d284 1
a284 1
			return ENXIO;
d304 1
a304 1
			return ENXIO;
d324 1
a324 1
			return ENXIO;
d328 1
a328 1
	return 0;
d336 1
a336 1
	return 1;
d358 1
a358 1
			return 0;
d363 1
a363 1
		return 0;
d368 1
a368 1
	return 1;
d391 1
d419 1
a419 1
integrate void
d497 2
a498 2
		isadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE,
		    1, ccb->ccb_phys);
d531 1
a531 1
		return 0;
d554 1
a554 1
	return 1;
d557 1
a557 1
integrate void
d579 2
a580 2
	if (ccb->ccb_phys[0].addr)
	        isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);
d584 1
a584 1
	hashnum = CCB_HASH(ccb->ccb_phys[0].addr);
d588 2
a589 1
		if ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {
d609 2
a610 2
integrate void
aha_init_ccb(sc, ccb)
d613 1
d615 2
d619 21
d654 1
a654 1
	int hashnum, mflags, s;
a657 5
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;

d669 3
a671 3
			ccb = (struct aha_ccb *) malloc(sizeof(struct aha_ccb),
			    M_TEMP, M_NOWAIT);
			if (!ccb) {
d676 6
a681 3
			aha_init_ccb(sc, ccb);
			sc->sc_numccbs++;
			break;
d683 1
a683 1
		if ((flags & SCSI_NOSLEEP) != 0)
d690 6
a695 3
	if (isadma_map((caddr_t)ccb, CCB_PHYS_SIZE, ccb->ccb_phys,
	    mflags | ISADMA_MAP_CONTIG) == 1) {
		hashnum = CCB_HASH(ccb->ccb_phys[0].addr);
a697 4
	} else {
		ccb->ccb_phys[0].addr = 0;
		aha_free_ccb(sc, ccb);
		ccb = 0;
a698 1

d716 1
a716 1
		if (ccb->ccb_phys[0].addr == ccb_phys)
d720 1
a720 1
	return ccb;
d803 3
a805 3
		isadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE,
		    1, ccb->ccb_phys);
		ltophys(ccb->ccb_phys[0].addr, wmbo->ccb_addr);
d899 1
a899 1
	if (ccb->data_nseg) {
d901 6
a906 4
			isadma_copyfrombuf(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
		isadma_unmap(xs->data, xs->datalen,
		    ccb->data_nseg, ccb->data_phys);
d946 1
a946 1
		return 1;
d976 1
a976 1
		return 1;
d1003 1
a1003 1
		return EIO;
d1021 1
a1021 1
			return 1;
d1025 1
a1025 1
			return 1;
d1028 1
a1028 1
	return 0;
d1260 1
a1260 1
	int seg, flags, mflags;
a1273 4
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;
d1276 1
a1276 1
		return TRY_AGAIN_LATER;
d1320 8
a1327 4
			ccb->data_nseg = isadma_map(xs->data, xs->datalen,
			    ccb->data_phys, mflags);
			for (seg = 0; seg < ccb->data_nseg; seg++) {
				ltophys(ccb->data_phys[seg].addr,
d1329 1
a1329 1
				ltophys(ccb->data_phys[seg].length,
d1333 6
a1338 8
		/* end of iov/kv decision */
		if (ccb->data_nseg == 0) {
			printf("%s: aha_scsi_cmd, cannot map\n",
			    sc->sc_dev.dv_xname);
			goto bad;
		} else if (flags & SCSI_DATA_OUT)
			isadma_copytobuf(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
d1340 2
a1341 1
		    ((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath,
d1343 1
a1343 1
		ltophys(ccb->data_nseg * sizeof(struct aha_scat_gath),
d1372 5
a1376 1
		if (ccb->data_nseg) {
d1378 4
a1381 4
				isadma_copyfrombuf(xs->data, xs->datalen,
				    ccb->data_nseg, ccb->data_phys);
			isadma_unmap(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
d1386 1
a1386 1
		return COMPLETE;
d1391 1
a1391 1
		return SUCCESSFULLY_QUEUED;
d1401 1
a1401 6
	return COMPLETE;

bad:
	xs->error = XS_DRIVER_STUFFUP;
	aha_free_ccb(sc, ccb);
	return COMPLETE;
d1424 1
a1424 1
			return 0;
d1428 1
a1428 1
	return 1;
d1442 2
a1443 1
	isadma_copyfrombuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);
@


1.44
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.43 2002/03/14 01:26:56 millert Exp $	*/
d1096 1
d1104 2
a1105 1
	for (pg = TAILQ_FIRST(&pglist); pg != NULL;pg = TAILQ_NEXT(pg, pageq)) {
@


1.43
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.42 2002/01/24 22:38:03 mickey Exp $	*/
d454 1
a454 1
			u_char *cp = (u_char*)&ccb->scsi_cmd;
@


1.42
log
@bussified and bus-split bustec scsi ha driver.
original port done by chris@@ in '98 and pounded into
-current by me, plus support for wide mode.
tested on pci in both modes by me, on eisa (w/
half success, thus not enabled yet) by jason@@.
niklas@@, jason@@, millert@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.41 2001/12/08 02:24:07 art Exp $	*/
d142 19
a160 19
int aha_cmd __P((int, struct aha_softc *, int, u_char *, int, u_char *));
integrate void aha_finish_ccbs __P((struct aha_softc *));
int ahaintr __P((void *));
integrate void aha_reset_ccb __P((struct aha_softc *, struct aha_ccb *));
void aha_free_ccb __P((struct aha_softc *, struct aha_ccb *));
integrate void aha_init_ccb __P((struct aha_softc *, struct aha_ccb *));
struct aha_ccb *aha_get_ccb __P((struct aha_softc *, int));
struct aha_ccb *aha_ccb_phys_kv __P((struct aha_softc *, u_long));
void aha_queue_ccb __P((struct aha_softc *, struct aha_ccb *));
void aha_collect_mbo __P((struct aha_softc *));
void aha_start_ccbs __P((struct aha_softc *));
void aha_done __P((struct aha_softc *, struct aha_ccb *));
int aha_find __P((struct isa_attach_args *, struct aha_softc *, int));
void aha_init __P((struct aha_softc *));
void aha_inquire_setup_information __P((struct aha_softc *));
void ahaminphys __P((struct buf *));
int aha_scsi_cmd __P((struct scsi_xfer *));
int aha_poll __P((struct aha_softc *, struct scsi_xfer *, int));
void aha_timeout __P((void *arg));
d177 3
a179 3
int	aha_isapnp_probe __P((struct device *, void *, void *));
int	ahaprobe __P((struct device *, void *, void *));
void	ahaattach __P((struct device *, struct device *, void *));
@


1.41
log
@Sprinkle pmap_update calls where relevant and some other
misc pmap usage fixes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.40 2001/11/30 17:24:19 art Exp $	*/
d196 1
a196 1
#include "bt.h"
d351 1
a351 1
#if NBT > 0
@


1.41.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.42 2002/01/24 22:38:03 mickey Exp $	*/
d196 1
a196 1
#include "bha.h"
d351 1
a351 1
#if NBHA > 0
@


1.41.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.41.2.1 2002/01/31 22:55:32 niklas Exp $	*/
d5 1
a68 1
#include <machine/bus.h>
a121 1
	bus_dma_tag_t sc_dmat;
d142 19
a160 19
int aha_cmd(int, struct aha_softc *, int, u_char *, int, u_char *);
void aha_finish_ccbs(struct aha_softc *);
int ahaintr(void *);
void aha_reset_ccb(struct aha_softc *, struct aha_ccb *);
void aha_free_ccb(struct aha_softc *, struct aha_ccb *);
int aha_init_ccb(struct aha_softc *, struct aha_ccb *, int);
struct aha_ccb *aha_get_ccb(struct aha_softc *, int);
struct aha_ccb *aha_ccb_phys_kv(struct aha_softc *, u_long);
void aha_queue_ccb(struct aha_softc *, struct aha_ccb *);
void aha_collect_mbo(struct aha_softc *);
void aha_start_ccbs(struct aha_softc *);
void aha_done(struct aha_softc *, struct aha_ccb *);
int aha_find(struct isa_attach_args *, struct aha_softc *, int);
void aha_init(struct aha_softc *);
void aha_inquire_setup_information(struct aha_softc *);
void ahaminphys(struct buf *);
int aha_scsi_cmd(struct scsi_xfer *);
int aha_poll(struct aha_softc *, struct scsi_xfer *, int);
void aha_timeout(void *arg);
d177 3
a179 3
int	aha_isapnp_probe(struct device *, void *, void *);
int	ahaprobe(struct device *, void *, void *);
void	ahaattach(struct device *, struct device *, void *);
d256 1
a256 1
			return (ENXIO);
d283 1
a283 1
			return (ENXIO);
d303 1
a303 1
			return (ENXIO);
d323 1
a323 1
			return (ENXIO);
d327 1
a327 1
	return (0);
d335 1
a335 1
	return (1);
d357 1
a357 1
			return (0);
d362 1
a362 1
		return (0);
d367 1
a367 1
	return (1);
a389 1
	sc->sc_dmat = ia->ia_dmat;
d417 1
a417 1
void
d454 1
a454 1
			u_char *cp = (u_char *)&ccb->scsi_cmd;
d495 2
a496 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
d529 1
a529 1
		return (0);
d552 1
a552 1
	return (1);
d555 1
a555 1
void
d577 2
a578 2
	if (ccb->ccb_dmam->dm_segs[0].ds_addr != 0)
		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmam);
d582 1
a582 1
	hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
d586 1
a586 2
		if ((*hashccb)->ccb_dmam->dm_segs[0].ds_addr ==
		    ccb->ccb_dmam->dm_segs[0].ds_addr) {
d606 2
a607 2
int
aha_init_ccb(sc, ccb, flags)
a609 1
	int flags;
a610 2
	int error, wait, state = 0;

a612 21

	wait = (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
	/* Create a DMA map for the data area.  */
	error = bus_dmamap_create(sc->sc_dmat, MAXPHYS, (MAXPHYS / NBPG) + 1,
	    MAXPHYS, 0, wait | BUS_DMA_ALLOCNOW, &ccb->dmam);
	if (error)
		goto fail;
	state++;

	/* Create a DMA map for the command control block.  */
	error = bus_dmamap_create(sc->sc_dmat, CCB_PHYS_SIZE, 1, CCB_PHYS_SIZE,
	    0, wait | BUS_DMA_ALLOCNOW, &ccb->ccb_dmam);
	if (error)
		goto fail;

	return (0);

 fail:
	if (state > 0)
		bus_dmamap_destroy(sc->sc_dmat, ccb->dmam);
	return (error);
d627 1
a627 1
	int hashnum, s;
d631 5
d647 3
a649 3
			MALLOC(ccb, struct aha_ccb *, sizeof *ccb, M_DEVBUF,
			    (flags & SCSI_NOSLEEP) ? M_NOWAIT : M_WAITOK);
			if (ccb == NULL) {
d654 3
a656 6
			if (aha_init_ccb(sc, ccb, flags) == 0) {
				sc->sc_numccbs++;
				break;
			}
			FREE(ccb, M_DEVBUF);
			ccb = NULL;
d658 1
a658 1
		if (flags & SCSI_NOSLEEP)
d665 3
a667 6
	if (bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmam, ccb, CCB_PHYS_SIZE,
	    NULL, BUS_DMA_NOWAIT) != 0) {
		aha_free_ccb(sc, ccb);
		ccb = NULL;
	} else {
		hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
d670 4
d675 1
d693 1
a693 1
		if (ccb->ccb_dmam->dm_segs[0].ds_addr == ccb_phys)
d697 1
a697 1
	return (ccb);
d780 3
a782 3
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		ltophys(ccb->ccb_dmam->dm_segs[0].ds_addr, wmbo->ccb_addr);
d876 1
a876 1
	if (ccb->dmam->dm_nsegs > 0) {
d878 4
a881 6
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
		if (xs->flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
d921 1
a921 1
		return (1);
d951 1
a951 1
		return (1);
d978 1
a978 1
		return (EIO);
d996 1
a996 1
			return (1);
d1000 1
a1000 1
			return (1);
d1003 1
a1003 1
	return (0);
a1095 1
	TAILQ_INIT(&pglist);
d1103 1
a1103 2
	for (pg = TAILQ_FIRST(&pglist); pg != NULL;
	    pg = TAILQ_NEXT(pg, pageq)) {
d1233 1
a1233 1
	int seg, flags;
d1247 4
d1253 1
a1253 1
		return (TRY_AGAIN_LATER);
d1297 4
a1300 8
			if (bus_dmamap_load(sc->sc_dmat, ccb->dmam, xs->data,
			    xs->datalen, NULL, BUS_DMA_NOWAIT) != 0) {
				aha_free_ccb(sc, ccb);
				xs->error = XS_DRIVER_STUFFUP;
				return (TRY_AGAIN_LATER);
			}
			for (seg = 0; seg < ccb->dmam->dm_nsegs; seg++) {
				ltophys(ccb->dmam->dm_segs[seg].ds_addr,
d1302 1
a1302 1
				ltophys(ccb->dmam->dm_segs[seg].ds_len,
d1306 8
a1313 6
		if (flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		if (flags & SCSI_DATA_IN)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREREAD);
d1315 1
a1315 2
		    ((struct aha_ccb *)(ccb->ccb_dmam->dm_segs[0].ds_addr))->
		    scat_gath,
d1317 1
a1317 1
		ltophys(ccb->dmam->dm_nsegs * sizeof(struct aha_scat_gath),
d1346 1
a1346 5
		if (ccb->dmam->dm_nsegs > 0) {
			if (flags & SCSI_DATA_OUT)
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
d1348 4
a1351 4
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
d1356 1
a1356 1
		return (COMPLETE);
d1361 1
a1361 1
		return (SUCCESSFULLY_QUEUED);
d1371 6
a1376 1
	return (COMPLETE);
d1399 1
a1399 1
			return (0);
d1403 1
a1403 1
	return (1);
d1417 1
a1417 2
	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
	    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
@


1.41.2.3
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.41.2.2 2002/06/11 03:42:21 art Exp $	*/
@


1.41.2.4
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d67 1
d1166 1
a1166 1
	strlcpy(sc->sc_model, "unknown", sizeof sc->sc_model);
d1208 1
a1208 1
		strlcpy(sc->sc_model, "1540", sizeof sc->sc_model);
d1211 1
a1211 1
		strlcpy(sc->sc_model, "1540A/1542A/1542B", sizeof sc->sc_model);
d1214 1
a1214 1
		strlcpy(sc->sc_model, "1640", sizeof sc->sc_model);
d1218 1
a1218 1
		strlcpy(sc->sc_model, "1542C", sizeof sc->sc_model);
d1221 1
a1221 1
		strlcpy(sc->sc_model, "1542CF", sizeof sc->sc_model);
d1224 1
a1224 1
		strlcpy(sc->sc_model, "1542CP", sizeof sc->sc_model);
@


1.40
log
@Kill uvm_pagealloc_contig. The two drivers that still used it should have
been converted to bus_dma ages ago, but since noone haven't bothered to do that
I haven't bothered to do more than to test that the kernel still builds
with those changes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.39 2001/06/27 04:45:58 art Exp $	*/
d1108 1
@


1.39
log
@zap old vm
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.38 2001/04/02 23:12:50 niklas Exp $	*/
d64 3
d1017 4
d1092 8
a1099 4
	/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */
	wmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),
	    0, 0xffffff, PAGE_SIZE);
	if (wmbx == NULL)
d1101 10
@


1.38
log
@Do not delete timeouts when they are not set
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.37 2001/01/29 06:40:14 mickey Exp $	*/
a1085 1
#ifdef UVM
a1087 4
#else
	wmbx = (struct aha_mbx *)vm_page_alloc_contig(sizeof(struct aha_mbx),
	    0, 0xffffff, PAGE_SIZE);
#endif
@


1.37
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.36 2000/11/13 13:43:01 niklas Exp $	*/
d490 2
a491 1
		timeout_del(&ccb->xs->stimeout);
@


1.36
log
@make compile with !UVM
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.35 2000/04/19 02:17:49 niklas Exp $	*/
d62 1
d490 1
a490 1
		untimeout(aha_timeout, ccb);
d787 4
a790 2
		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout(aha_timeout, ccb, (ccb->timeout * hz) / 1000);
@


1.35
log
@Force mailbox to be under 16MB so the controller can see it
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.34 1999/08/19 07:40:14 deraadt Exp $	*/
d1086 1
a1086 1
	wmbx = (struct aha_mbx *)vm_pagealloc_contig(sizeof(struct aha_mbx),
@


1.34
log
@pnpdevs.h
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.33 1999/01/07 06:14:46 niklas Exp $	*/
d125 2
a126 2
	struct aha_mbx sc_mbx;		/* all the mailboxes */
#define	wmbx	(&sc->sc_mbx)
a1009 1
	struct isadma_seg mbx_phys[1];
d1080 12
d1103 1
a1103 4
	if (isadma_map((caddr_t)(wmbx), sizeof(struct aha_mbx),
	    mbx_phys, ISADMA_MAP_CONTIG) != 1)
		panic("aha_init: cannot map mail box");
	ltophys(mbx_phys[0].addr, mailbox.cmd.addr);
@


1.34.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.38 2001/04/02 23:12:50 niklas Exp $	*/
a61 1
#include <sys/timeout.h>
d125 2
a126 2
	struct aha_mbx *sc_mbx;		/* all the mailboxes */
#define	wmbx	(sc->sc_mbx)
d489 1
a489 2
		if ((ccb->xs->flags & SCSI_POLL) == 0)
			timeout_del(&ccb->xs->stimeout);
d786 2
a787 4
		if ((ccb->xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->xs->stimeout, aha_timeout, ccb);
			timeout_add(&ccb->xs->stimeout, (ccb->timeout * hz) / 1000);
		}
d1010 1
a1080 12

	/* XXX KLUDGE!  Should use bus_dmamem_alloc when busified.  */
#ifdef UVM
	wmbx = (struct aha_mbx *)uvm_pagealloc_contig(sizeof(struct aha_mbx),
	    0, 0xffffff, PAGE_SIZE);
#else
	wmbx = (struct aha_mbx *)vm_page_alloc_contig(sizeof(struct aha_mbx),
	    0, 0xffffff, PAGE_SIZE);
#endif
	if (wmbx == NULL)
		panic("aha_init: could not allocate mailbox");

d1092 4
a1095 1
	ltophys(vtophys(wmbx), mailbox.cmd.addr);
@


1.34.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.34.4.1 2001/05/14 22:24:28 niklas Exp $	*/
d1086 1
d1089 4
@


1.34.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.34.4.2 2001/07/04 10:41:23 niklas Exp $	*/
a63 3
#include <uvm/uvm.h>
#include <uvm/uvm_extern.h>

a1013 4
	struct pglist pglist;
	struct vm_page *pg;
	vaddr_t va;
	vsize_t size;
d1085 4
a1088 8
	/*
	 * XXX - this vm juggling is so wrong. use bus_dma instead!
	 */
	size = round_page(sizeof(struct aha_mbx));
	if (uvm_pglistalloc(size, 0, 0xffffff, PAGE_SIZE, 0, &pglist, 1, 0) ||
	    uvm_map(kernel_map, &va, size, NULL, UVM_UNKNOWN_OFFSET, 0,
		UVM_MAPFLAG(UVM_PROT_ALL, UVM_PROT_ALL, UVM_INH_NONE,
			UVM_ADV_RANDOM, 0)))
a1089 10

	wmbx = (struct aha_mbx *)va;
	for (pg = TAILQ_FIRST(&pglist); pg != NULL;pg = TAILQ_NEXT(pg, pageq)) {
		pmap_kenter_pa(va, VM_PAGE_TO_PHYS(pg),
			VM_PROT_READ|VM_PROT_WRITE);
		va += PAGE_SIZE;
	}
	/*
	 * XXXEND
	 */
@


1.34.4.4
log
@Merge in trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d196 1
a196 1
#include "bha.h"
d351 1
a351 1
#if NBHA > 0
a1107 1
	pmap_update(pmap_kernel());
@


1.34.4.5
log
@Merge in -current from about a week ago
@
text
@d142 19
a160 19
int aha_cmd(int, struct aha_softc *, int, u_char *, int, u_char *);
integrate void aha_finish_ccbs(struct aha_softc *);
int ahaintr(void *);
integrate void aha_reset_ccb(struct aha_softc *, struct aha_ccb *);
void aha_free_ccb(struct aha_softc *, struct aha_ccb *);
integrate void aha_init_ccb(struct aha_softc *, struct aha_ccb *);
struct aha_ccb *aha_get_ccb(struct aha_softc *, int);
struct aha_ccb *aha_ccb_phys_kv(struct aha_softc *, u_long);
void aha_queue_ccb(struct aha_softc *, struct aha_ccb *);
void aha_collect_mbo(struct aha_softc *);
void aha_start_ccbs(struct aha_softc *);
void aha_done(struct aha_softc *, struct aha_ccb *);
int aha_find(struct isa_attach_args *, struct aha_softc *, int);
void aha_init(struct aha_softc *);
void aha_inquire_setup_information(struct aha_softc *);
void ahaminphys(struct buf *);
int aha_scsi_cmd(struct scsi_xfer *);
int aha_poll(struct aha_softc *, struct scsi_xfer *, int);
void aha_timeout(void *arg);
d177 3
a179 3
int	aha_isapnp_probe(struct device *, void *, void *);
int	ahaprobe(struct device *, void *, void *);
void	ahaattach(struct device *, struct device *, void *);
d454 1
a454 1
			u_char *cp = (u_char *)&ccb->scsi_cmd;
@


1.34.4.6
log
@Sync the SMP branch with 3.3
@
text
@d5 1
a68 1
#include <machine/bus.h>
a121 1
	bus_dma_tag_t sc_dmat;
d143 1
a143 1
void aha_finish_ccbs(struct aha_softc *);
d145 1
a145 1
void aha_reset_ccb(struct aha_softc *, struct aha_ccb *);
d147 1
a147 1
int aha_init_ccb(struct aha_softc *, struct aha_ccb *, int);
d256 1
a256 1
			return (ENXIO);
d283 1
a283 1
			return (ENXIO);
d303 1
a303 1
			return (ENXIO);
d323 1
a323 1
			return (ENXIO);
d327 1
a327 1
	return (0);
d335 1
a335 1
	return (1);
d357 1
a357 1
			return (0);
d362 1
a362 1
		return (0);
d367 1
a367 1
	return (1);
a389 1
	sc->sc_dmat = ia->ia_dmat;
d417 1
a417 1
void
d495 2
a496 2
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
d529 1
a529 1
		return (0);
d552 1
a552 1
	return (1);
d555 1
a555 1
void
d577 2
a578 2
	if (ccb->ccb_dmam->dm_segs[0].ds_addr != 0)
		bus_dmamap_unload(sc->sc_dmat, ccb->ccb_dmam);
d582 1
a582 1
	hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
d586 1
a586 2
		if ((*hashccb)->ccb_dmam->dm_segs[0].ds_addr ==
		    ccb->ccb_dmam->dm_segs[0].ds_addr) {
d606 2
a607 2
int
aha_init_ccb(sc, ccb, flags)
a609 1
	int flags;
a610 2
	int error, wait, state = 0;

a612 21

	wait = (flags & SCSI_NOSLEEP) ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;
	/* Create a DMA map for the data area.  */
	error = bus_dmamap_create(sc->sc_dmat, MAXPHYS, (MAXPHYS / NBPG) + 1,
	    MAXPHYS, 0, wait | BUS_DMA_ALLOCNOW, &ccb->dmam);
	if (error)
		goto fail;
	state++;

	/* Create a DMA map for the command control block.  */
	error = bus_dmamap_create(sc->sc_dmat, CCB_PHYS_SIZE, 1, CCB_PHYS_SIZE,
	    0, wait | BUS_DMA_ALLOCNOW, &ccb->ccb_dmam);
	if (error)
		goto fail;

	return (0);

 fail:
	if (state > 0)
		bus_dmamap_destroy(sc->sc_dmat, ccb->dmam);
	return (error);
d627 1
a627 1
	int hashnum, s;
d631 5
d647 3
a649 3
			MALLOC(ccb, struct aha_ccb *, sizeof *ccb, M_DEVBUF,
			    (flags & SCSI_NOSLEEP) ? M_NOWAIT : M_WAITOK);
			if (ccb == NULL) {
d654 3
a656 6
			if (aha_init_ccb(sc, ccb, flags) == 0) {
				sc->sc_numccbs++;
				break;
			}
			FREE(ccb, M_DEVBUF);
			ccb = NULL;
d658 1
a658 1
		if (flags & SCSI_NOSLEEP)
d665 3
a667 6
	if (bus_dmamap_load(sc->sc_dmat, ccb->ccb_dmam, ccb, CCB_PHYS_SIZE,
	    NULL, BUS_DMA_NOWAIT) != 0) {
		aha_free_ccb(sc, ccb);
		ccb = NULL;
	} else {
		hashnum = CCB_HASH(ccb->ccb_dmam->dm_segs[0].ds_addr);
d670 4
d675 1
d693 1
a693 1
		if (ccb->ccb_dmam->dm_segs[0].ds_addr == ccb_phys)
d697 1
a697 1
	return (ccb);
d780 3
a782 3
		bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
		    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		ltophys(ccb->ccb_dmam->dm_segs[0].ds_addr, wmbo->ccb_addr);
d876 1
a876 1
	if (ccb->dmam->dm_nsegs > 0) {
d878 4
a881 6
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
		if (xs->flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_POSTWRITE);
		bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
d921 1
a921 1
		return (1);
d951 1
a951 1
		return (1);
d978 1
a978 1
		return (EIO);
d996 1
a996 1
			return (1);
d1000 1
a1000 1
			return (1);
d1003 1
a1003 1
	return (0);
a1095 1
	TAILQ_INIT(&pglist);
d1103 1
a1103 2
	for (pg = TAILQ_FIRST(&pglist); pg != NULL;
	    pg = TAILQ_NEXT(pg, pageq)) {
d1233 1
a1233 1
	int seg, flags;
d1247 4
d1253 1
a1253 1
		return (TRY_AGAIN_LATER);
d1297 4
a1300 8
			if (bus_dmamap_load(sc->sc_dmat, ccb->dmam, xs->data,
			    xs->datalen, NULL, BUS_DMA_NOWAIT) != 0) {
				aha_free_ccb(sc, ccb);
				xs->error = XS_DRIVER_STUFFUP;
				return (TRY_AGAIN_LATER);
			}
			for (seg = 0; seg < ccb->dmam->dm_nsegs; seg++) {
				ltophys(ccb->dmam->dm_segs[seg].ds_addr,
d1302 1
a1302 1
				ltophys(ccb->dmam->dm_segs[seg].ds_len,
d1306 8
a1313 6
		if (flags & SCSI_DATA_OUT)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREWRITE);
		if (flags & SCSI_DATA_IN)
			bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
			    ccb->dmam->dm_mapsize, BUS_DMASYNC_PREREAD);
d1315 1
a1315 2
		    ((struct aha_ccb *)(ccb->ccb_dmam->dm_segs[0].ds_addr))->
		    scat_gath,
d1317 1
a1317 1
		ltophys(ccb->dmam->dm_nsegs * sizeof(struct aha_scat_gath),
d1346 1
a1346 5
		if (ccb->dmam->dm_nsegs > 0) {
			if (flags & SCSI_DATA_OUT)
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTWRITE);
d1348 4
a1351 4
				bus_dmamap_sync(sc->sc_dmat, ccb->dmam, 0,
				    ccb->dmam->dm_mapsize,
				    BUS_DMASYNC_POSTREAD);
			bus_dmamap_unload(sc->sc_dmat, ccb->dmam);
d1356 1
a1356 1
		return (COMPLETE);
d1361 1
a1361 1
		return (SUCCESSFULLY_QUEUED);
d1371 6
a1376 1
	return (COMPLETE);
d1399 1
a1399 1
			return (0);
d1403 1
a1403 1
	return (1);
d1417 1
a1417 2
	bus_dmamap_sync(sc->sc_dmat, ccb->ccb_dmam, 0,
	    ccb->ccb_dmam->dm_mapsize, BUS_DMASYNC_POSTREAD);
@


1.34.4.7
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.34.4.6 2003/03/28 00:38:15 niklas Exp $	*/
d67 1
d1166 1
a1166 1
	strlcpy(sc->sc_model, "unknown", sizeof sc->sc_model);
d1208 1
a1208 1
		strlcpy(sc->sc_model, "1540", sizeof sc->sc_model);
d1211 1
a1211 1
		strlcpy(sc->sc_model, "1540A/1542A/1542B", sizeof sc->sc_model);
d1214 1
a1214 1
		strlcpy(sc->sc_model, "1640", sizeof sc->sc_model);
d1218 1
a1218 1
		strlcpy(sc->sc_model, "1542C", sizeof sc->sc_model);
d1221 1
a1221 1
		strlcpy(sc->sc_model, "1542CF", sizeof sc->sc_model);
d1224 1
a1224 1
		strlcpy(sc->sc_model, "1542CP", sizeof sc->sc_model);
@


1.33
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.32 1998/12/27 09:41:56 deraadt Exp $	*/
d378 1
a378 1
	if (isapnp)
d380 3
d387 1
a387 1
	if (sc->sc_drq != DRQUNK)
@


1.32
log
@non-working isapnp aha support
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.31 1998/08/13 04:36:50 downsj Exp $	*/
a355 5
#ifdef NEWCONFIG
	if (ia->ia_iobase == IOBASEUNK)
		return 0;
#endif

a400 3
#ifdef NEWCONFIG
	isa_establish(&sc->sc_id, &sc->sc_dev);
#endif
@


1.31
log
@Identify card 0x44 as a 1542C, not 1542CF: Robert Earl <rearl@@teleport.com>.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.30 1997/09/15 19:28:31 flipk Exp $	*/
d150 1
a150 1
int aha_find __P((struct isa_attach_args *, struct aha_softc *));
d173 1
d177 5
a181 1
struct cfattach aha_ca = {
d326 9
d362 1
a362 1
	if (aha_find(ia, NULL) != 0)
d381 1
d383 3
a385 1
	if (aha_find(ia, sc) != 0)
d889 1
a889 1
aha_find(ia, sc)
d892 1
d951 2
d978 2
d989 2
@


1.30
log
@AHADEBUG cleanliness
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.29 1997/07/30 22:12:11 niklas Exp $	*/
d1142 1
a1144 1
	case 0x44:
@


1.29
log
@KNF and other style nits
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.28 1997/01/16 19:47:47 kstailey Exp $	*/
d438 1
a438 1
			u_char *cp = &ccb->scsi_cmd;
d502 2
a503 1
	printf("%s: ahaintr ", sc->sc_dev.dv_xname);
@


1.28
log
@ahaprint() & btprint() -> scsiprint()
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.27 1996/11/23 21:46:35 kstailey Exp $	*/
d271 2
a272 1
				printf("%s: aha_cmd, cmd/data port full\n", name);
d525 2
a526 2
		aha_cmd(iobase, sc, sizeof(toggle.cmd), (u_char *)&toggle.cmd, 0,
		    (u_char *)0);
d803 2
a804 1
		printf("%s: exiting ccb still in transit!\n", sc->sc_dev.dv_xname);
d810 2
a811 1
		printf("%s: exiting ccb not allocated!\n", sc->sc_dev.dv_xname);
d830 2
a831 1
				s1 = (struct scsi_sense_data *) (((char *) (&ccb->scsi_cmd)) +
d928 2
a929 1
		printf("aha_find: illegal drq setting %x\n", config.reply.chan);
d953 2
a954 1
		printf("aha_find: illegal irq setting %x\n", config.reply.intr);
d1004 2
a1005 1
		printf("%s: unlocking mailbox interface\n", sc->sc_dev.dv_xname);
d1007 3
a1009 2
		aha_cmd(iobase, sc, sizeof(extbios.cmd), (u_char *)&extbios.cmd,
		    sizeof(extbios.reply), (u_char *)&extbios.reply);
d1050 2
a1051 1
		    (!setup.reply.sync[i].offset && !setup.reply.sync[i].period))
d1054 2
a1055 2
		    sc->sc_dev.dv_xname, i,
		    setup.reply.sync[i].offset, setup.reply.sync[i].period * 50 + 200);
d1217 2
a1218 2
		ccb->opcode = (xs->datalen ? AHA_INIT_SCAT_GATH_CCB
					   : AHA_INITIATOR_CCB);
d1249 1
a1249 1
						    ccb->data_phys, mflags);
d1252 1
a1252 1
				       sg[seg].seg_addr);
d1254 1
a1254 1
				       sg[seg].seg_len);
d1260 1
a1260 1
			       sc->sc_dev.dv_xname);
d1264 4
a1267 3
					 ccb->data_nseg, ccb->data_phys);
		ltophys((unsigned)((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath,
			ccb->data_addr);
d1269 1
a1269 1
			ccb->data_length);
@


1.27
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.26 1996/10/16 12:29:48 deraadt Exp $	*/
a174 1
int	ahaprint __P((void *, const char *));
a355 11
int
ahaprint(aux, name)
	void *aux;
	const char *name;
{

	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}

d397 1
a397 1
	config_found(self, &sc->sc_link, ahaprint);
@


1.26
log
@contextual usage only
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.25 1996/06/19 14:40:33 deraadt Exp $	*/
d175 1
a175 1
int	ahaprint __P((void *, char *));
d360 1
a360 1
	char *name;
@


1.25
log
@turn off *DIAG; something is miserably wrong with it and various people
have wasted weeks because of the crashes.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.24 1996/06/01 12:20:40 deraadt Exp $	*/
d714 1
d716 1
d1187 2
a1188 1
	int seg, datalen, flags, mflags;
d1190 2
@


1.24
log
@splbio over scsi_done; isdma_copyfrombuf() inside this block is not a real
performance issue VOLATILE_XS() means it is probably very small.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.22 1996/05/31 10:57:04 deraadt Exp $	*/
d4 1
a4 1
#define AHADIAG
@


1.23
log
@do not access sc_link before set
@
text
@a1293 1
		splx(s);
d1303 1
@


1.22
log
@fixes by hannken and deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.21 1996/05/31 08:14:51 deraadt Exp $	*/
a1363 3
	sc_print_addr(sc_link);
	printf("timed out");

d1369 3
@


1.21
log
@a cvs test
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.20 1996/05/27 01:11:44 deraadt Exp $	*/
d489 2
d771 2
a1283 1
	splx(s);
d1306 1
d1359 3
a1361 3
	struct scsi_xfer *xs = ccb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct aha_softc *sc = sc_link->adapter_softc;
d1368 4
@


1.20
log
@"aha + bt" kernels work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.19 1996/05/26 00:27:09 deraadt Exp $	*/
d1396 1
@


1.19
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: aha.c,v 1.18 1996/05/10 12:35:01 deraadt Exp $	*/
d188 2
d333 8
@


1.18
log
@AHA_MBO_FREE/AHA_MBI_FREE botch
@
text
@d1 2
a2 2
/*	$OpenBSD: aha.c,v 1.15 1996/04/22 20:03:02 hannken Exp $	*/
/*	$NetBSD: aha.c,v 1.10 1996/05/05 00:40:01 mycroft Exp $	*/
d63 1
@


1.17
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*	$NetBSD: aha.c,v 1.9 1996/04/29 20:28:40 christos Exp $	*/
d1049 1
a1049 1
		wmbx->mbi[i].stat = AHA_MBO_FREE;
@


1.16
log
@bizzare change in netbsd land
@
text
@d2 1
a2 1
/*	$NetBSD: aha.c,v 1.8 1996/04/25 18:54:45 is Exp $	*/
a734 1
	int i;
d738 1
a738 1
	while (ccb = sc->sc_waiting_ccb.tqh_first) {
@


1.15
log
@Update aha.c to use bounce buffers, fix typos in isadma.c, update bounce buffers
@
text
@d1 2
a2 2
/*	$OpenBSD: $	*/
/*	$NetBSD: aha.c,v 1.7 1996/04/11 22:27:59 cgd Exp $	*/
d214 1
a214 1
	if (sc == NULL)
d217 1
a217 1
		name = "(probe)";
@


1.14
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
d76 12
a112 2
#define KVTOPHYS(x)	vtophys(x)

d373 1
a373 1
		isa_dmacascade(sc->sc_drq);
d393 1
a393 1
	    IPL_BIO, ahaintr, sc);
d552 2
a553 1
	int s;
d557 16
a590 2
	int hashnum;

a591 8
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	ccb->hashkey = KVTOPHYS(ccb);
	hashnum = CCB_HASH(ccb->hashkey);
	ccb->nexthash = sc->sc_ccbhash[hashnum];
	sc->sc_ccbhash[hashnum] = ccb;
d607 1
a607 1
	int s;
d611 5
d645 11
d673 1
a673 1
		if (ccb->hashkey == ccb_phys)
d711 5
a715 1
		ccb->flags &= ~CCB_SENDING;
d759 1
a759 1
		ltophys(KVTOPHYS(ccb), wmbo->ccb_addr);
d841 14
a855 1
	xs->flags |= ITSDONE;
d980 1
d1059 4
a1062 1
	ltophys(KVTOPHYS(wmbx), mailbox.cmd.addr);
d1171 1
a1171 3
	int seg;		/* scatter gather seg being worked on */
	u_long thiskv, thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
d1182 4
d1232 7
a1238 52
			SC_DEBUG(sc_link, SDEV_DB4,
			    ("%d @@0x%x:- ", xs->datalen, xs->data));

			datalen = xs->datalen;
			thiskv = (int)xs->data;
			thisphys = KVTOPHYS(thiskv);

			while (datalen && seg < AHA_NSEG) {
				bytes_this_seg = 0;

				/* put in the base address */
				ltophys(thisphys, sg->seg_addr);

				SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the the last, just extend the
					 * length
					 */
					/* check it fits on the ISA bus */
					if (thisphys > 0xFFFFFF) {
						printf("%s: DMA beyond"
							" end of ISA\n",
							sc->sc_dev.dv_xname);
						goto bad;
					}
					/* how far to the end of the page */
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = KVTOPHYS(thiskv);
				}
				/*
				 * next page isn't contiguous, finish the seg
				 */
				SC_DEBUGN(sc_link, SDEV_DB4,
				    ("(0x%x)", bytes_this_seg));
				ltophys(bytes_this_seg, sg->seg_len);
				sg++;
				seg++;
d1242 3
a1244 7
		SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: aha_scsi_cmd, more than %d dma segs\n",
			    sc->sc_dev.dv_xname, AHA_NSEG);
d1246 7
a1252 3
		}
		ltophys(KVTOPHYS(ccb->scat_gath), ccb->data_addr);
		ltophys(seg * sizeof(struct aha_scat_gath), ccb->data_length);
d1276 18
@


1.13
log
@Fix back wrong patches.
@
text
@d1 4
a4 2
/*	$OpenBSD: aha1542.c,v 1.12 1996/03/19 21:10:02 mickey Exp $	*/
/*	$NetBSD: aha1542.c,v 1.55 1995/12/24 02:31:06 mycroft Exp $	*/
d7 1
a7 1
 * Copyright (c) 1994 Charles Hannum.  All rights reserved.
d19 1
a19 1
 *	This product includes software developed by Charles Hannum.
a49 4
/*
 * Ported to run under 386BSD by Julian Elischer (julian@@tfs.com) Sept 1992
 */

a51 1
#include <sys/syslog.h>
d64 3
d69 1
a69 2
#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
a74 43
/* XXX fixme:
 * on i386 at least, xfers to/from user memory
 * cannot be serviced at interrupt time.
 */
#ifdef i386
#define VOLATILE_XS(xs) \
	((xs)->datalen > 0 && (xs)->bp == NULL && \
	((xs)->flags & SCSI_POLL) == 0)
#else
#define VOLATILE_XS(xs)	0
#endif

#undef TUNE_1542	/* if bus speed check breaks the machine, undefine it */

/************************** board definitions *******************************/

/*
 * I/O Port Interface
 */
#define	AHA_BASE		aha->sc_iobase
#define	AHA_CTRL_STAT_PORT	(AHA_BASE + 0x0)	/* control & status */
#define	AHA_CMD_DATA_PORT	(AHA_BASE + 0x1)	/* cmds and datas */
#define	AHA_INTR_PORT		(AHA_BASE + 0x2)	/* Intr. stat */

/*
 * AHA_CTRL_STAT bits (write)
 */
#define AHA_HRST		0x80	/* Hardware reset */
#define AHA_SRST		0x40	/* Software reset */
#define AHA_IRST		0x20	/* Interrupt reset */
#define AHA_SCRST		0x10	/* SCSI bus reset */

/*
 * AHA_CTRL_STAT bits (read)
 */
#define AHA_STST		0x80	/* Self test in Progress */
#define AHA_DIAGF		0x40	/* Diagnostic Failure */
#define AHA_INIT		0x20	/* Mbx Init required */
#define AHA_IDLE		0x10	/* Host Adapter Idle */
#define AHA_CDF			0x08	/* cmd/data out port full */
#define AHA_DF			0x04	/* Data in port full */
#define AHA_INVDCMD		0x01	/* Invalid command */

d76 2
a77 35
 * AHA_CMD_DATA bits (write)
 */
#define	AHA_NOP			0x00	/* No operation */
#define AHA_MBX_INIT		0x01	/* Mbx initialization */
#define AHA_START_SCSI		0x02	/* start scsi command */
#define AHA_START_BIOS		0x03	/* start bios command */
#define AHA_INQUIRE		0x04	/* Adapter Inquiry */
#define AHA_MBO_INTR_EN		0x05	/* Enable MBO available interrupt */
#define AHA_SEL_TIMEOUT_SET	0x06	/* set selection time-out */
#define AHA_BUS_ON_TIME_SET	0x07	/* set bus-on time */
#define AHA_BUS_OFF_TIME_SET	0x08	/* set bus-off time */
#define AHA_SPEED_SET		0x09	/* set transfer speed */
#define AHA_DEV_GET		0x0a	/* return installed devices */
#define AHA_CONF_GET		0x0b	/* return configuration data */
#define AHA_TARGET_EN		0x0c	/* enable target mode */
#define AHA_SETUP_GET		0x0d	/* return setup data */
#define AHA_WRITE_CH2		0x1a	/* write channel 2 buffer */
#define AHA_READ_CH2		0x1b	/* read channel 2 buffer */
#define AHA_WRITE_FIFO		0x1c	/* write fifo buffer */
#define AHA_READ_FIFO		0x1d	/* read fifo buffer */
#define AHA_ECHO		0x1e	/* Echo command data */
#define AHA_EXT_BIOS		0x28	/* return extended bios info */
#define AHA_MBX_ENABLE		0x29	/* enable mail box interface */

/*
 * AHA_INTR_PORT bits (read)
 */
#define AHA_ANY_INTR		0x80	/* Any interrupt */
#define AHA_SCRD		0x08	/* SCSI reset detected */
#define AHA_HACC		0x04	/* Command complete */
#define AHA_MBOA		0x02	/* MBX out empty */
#define AHA_MBIF		0x01	/* MBX in full */

/*
 * Mail box defs
d81 2
a82 2
#define	AHA_CCB_MAX	32	/* store up to 32 CCBs at one time */
#define	CCB_HASH_SIZE	32	/* hash table size for phystokv */
a91 10
struct aha_mbx_out {
	u_char cmd;
	u_char ccb_addr[3];
};

struct aha_mbx_in {
	u_char stat;
	u_char ccb_addr[3];
};

d95 1
d100 1
a100 142
/*
 * mbo.cmd values
 */
#define AHA_MBO_FREE	0x0	/* MBO entry is free */
#define AHA_MBO_START	0x1	/* MBO activate entry */
#define AHA_MBO_ABORT	0x2	/* MBO abort entry */

/*
 * mbi.stat values
 */
#define AHA_MBI_FREE	0x0	/* MBI entry is free */
#define AHA_MBI_OK	0x1	/* completed without error */
#define AHA_MBI_ABORT	0x2	/* aborted ccb */
#define AHA_MBI_UNKNOWN	0x3	/* Tried to abort invalid CCB */
#define AHA_MBI_ERROR	0x4	/* Completed with error */

/* FOR OLD VERSIONS OF THE !%$@@ this may have to be 16 (yuk) */
#define	AHA_NSEG	17	/* Number of scatter gather segments <= 16 */
				/* allow 60 K i/o (min) */

struct aha_ccb {
	u_char opcode;
	u_char lun:3;
	u_char data_in:1;	/* must be 0 */
	u_char data_out:1;	/* must be 0 */
	u_char target:3;
	u_char scsi_cmd_length;
	u_char req_sense_length;
	u_char data_length[3];
	u_char data_addr[3];
	u_char link_addr[3];
	u_char link_id;
	u_char host_stat;
	u_char target_stat;
	u_char reserved[2];
	struct scsi_generic scsi_cmd;
	struct scsi_sense_data scsi_sense;
	struct aha_scat_gath {
		u_char seg_len[3];
		u_char seg_addr[3];
	} scat_gath[AHA_NSEG];
	/*----------------------------------------------------------------*/
#define CCB_PHYS_SIZE ((int)&((struct aha_ccb *)0)->chain)
	TAILQ_ENTRY(aha_ccb) chain;
	struct aha_ccb *nexthash;
	struct scsi_xfer *xs;		/* the scsi_xfer for this cmd */
	int flags;
#define CCB_FREE	0
#define CCB_ACTIVE	1
#define CCB_ABORTED	2
	struct aha_mbx_out *mbx;	/* pointer to mail box */
	struct isadma_seg ccb_phys[1];	/* phys segment of this ccb */
	struct isadma_seg data_phys[AHA_NSEG];	/* phys segments of data */
	int data_nseg;			/* number of phys segments of data */
};

/*
 * opcode fields
 */
#define AHA_INITIATOR_CCB	0x00	/* SCSI Initiator CCB */
#define AHA_TARGET_CCB		0x01	/* SCSI Target CCB */
#define AHA_INIT_SCAT_GATH_CCB	0x02	/* SCSI Initiator with scatter gather */
#define AHA_RESET_CCB		0x81	/* SCSI Bus reset */

/*
 * aha_ccb.host_stat values
 */
#define AHA_OK		0x00	/* cmd ok */
#define AHA_LINK_OK	0x0a	/* Link cmd ok */
#define AHA_LINK_IT	0x0b	/* Link cmd ok + int */
#define AHA_SEL_TIMEOUT	0x11	/* Selection time out */
#define AHA_OVER_UNDER	0x12	/* Data over/under run */
#define AHA_BUS_FREE	0x13	/* Bus dropped at unexpected time */
#define AHA_INV_BUS	0x14	/* Invalid bus phase/sequence */
#define AHA_BAD_MBO	0x15	/* Incorrect MBO cmd */
#define AHA_BAD_CCB	0x16	/* Incorrect ccb opcode */
#define AHA_BAD_LINK	0x17	/* Not same values of LUN for links */
#define AHA_INV_TARGET	0x18	/* Invalid target direction */
#define AHA_CCB_DUP	0x19	/* Duplicate CCB received */
#define AHA_INV_CCB	0x1a	/* Invalid CCB or segment list */
#define AHA_ABORTED	42

struct aha_setup {
	u_char  sync_neg:1;
	u_char  parity:1;
		u_char:6;
	u_char  speed;
	u_char  bus_on;
	u_char  bus_off;
	u_char  num_mbx;
	u_char  mbx[3];
	struct {
		u_char  offset:4;
		u_char  period:3;
		u_char  valid:1;
	} sync[8];
	u_char  disc_sts;
};

struct aha_config {
	u_char  chan;
	u_char  intr;
	u_char  scsi_dev:3;
		u_char:5;
};

struct aha_inquire {
	u_char	boardid;	/* type of board */
				/* 0x31 = AHA-1540 */
				/* 0x41 = AHA-1540A/1542A/1542B */
				/* 0x42 = AHA-1640 */
				/* 0x43 = AHA-1542C */
				/* 0x44 = AHA-1542CF */
				/* 0x45 = AHA-1542CF, BIOS v2.01 */
	u_char	spec_opts;	/* special options ID */
				/* 0x41 = Board is standard model */
	u_char	revision_1;	/* firmware revision [0-9A-Z] */
	u_char	revision_2;	/* firmware revision [0-9A-Z] */
};

struct aha_extbios {
	u_char	flags;		/* Bit 3 == 1 extended bios enabled */
	u_char	mailboxlock;	/* mail box lock code to unlock it */
};

#define INT9	0x01
#define INT10	0x02
#define INT11	0x04
#define INT12	0x08
#define INT14	0x20
#define INT15	0x40

#define CHAN0	0x01
#define CHAN5	0x20
#define CHAN6	0x40
#define CHAN7	0x80

/*********************************** end of board definitions***************/

#ifdef	AHADEBUG
int	aha_debug = 1;
#endif /*AHADEBUG */
d110 9
a118 5
	struct aha_mbx aha_mbx;		/* all the mailboxes */
	struct aha_ccb *ccbhash[CCB_HASH_SIZE];
	TAILQ_HEAD(, aha_ccb) free_ccb;
	int numccbs;
	int aha_scsi_dev;		/* our scsi id */
d122 6
a127 1
int aha_cmd();	/* XXX must be varargs to prototype */
d129 3
a131 1
void aha_free_ccb __P((struct aha_softc *, struct aha_ccb *, int));
d134 3
a136 1
struct aha_mbx_out *aha_send_mbo __P((struct aha_softc *, int, struct aha_ccb *));
d138 1
a138 1
int aha_find __P((struct aha_softc *));
d140 1
a143 2
int aha_set_bus_speed __P((struct aha_softc *));
int aha_bus_speed_check __P((struct aha_softc *, int));
d165 6
a170 2
struct cfdriver ahacd = {
	NULL, "aha", ahaprobe, ahaattach, DV_DULL, sizeof(struct aha_softc)
d174 1
d177 2
a178 1
 * aha_cmd(aha,icnt, ocnt,wait, retval, opcode, args)
d180 2
a181 1
 *    icnt:   number of args (outbound bytes written after opcode)
d183 1
a184 3
 *    retval: buffer where to place returned bytes
 *    opcode: opcode AHA_NOP, AHA_MBX_INIT, AHA_START_SCSI ...
 *    args:   parameters
d186 3
a188 4
 * Performs an adapter command through the ports. Not to be confused
 * with a scsi command, which is read in via the dma.  One of the adapter
 * commands tells it to read in a scsi command but that one is done
 * separately.  This is only called during set-up.
d191 19
a209 16
aha_cmd(aha, icnt, ocnt, wait, retval, opcode, args)
	struct aha_softc *aha;
	int icnt, ocnt, wait;
	u_char *retval;
	unsigned opcode;
	u_char  args;
{
	unsigned *ic = &opcode;
	u_char oc;
	register i;
	int sts;

	/*
	 * multiply the wait argument by a big constant
	 * zero defaults to 1 sec..
	 * all wait loops are in 50uSec cycles
d211 9
a219 4
	if (wait)
		wait *= 20000;
	else
		wait = 20000;
d224 4
a227 5
	if (opcode != AHA_MBX_INIT && opcode != AHA_START_SCSI) {
		i = 20000;	/*do this for upto about a second */
		while (--i) {
			sts = inb(AHA_CTRL_STAT_PORT);
			if (sts & AHA_IDLE)
d233 1
a233 1
				aha->sc_dev.dv_xname, sts);
d242 2
a243 2
		while ((inb(AHA_CTRL_STAT_PORT)) & AHA_DF)
			inb(AHA_CMD_DATA_PORT);
a248 2
	icnt++;
	/* include the command */
a249 1
		sts = inb(AHA_CTRL_STAT_PORT);
d251 2
a252 2
			sts = inb(AHA_CTRL_STAT_PORT);
			if (!(sts & AHA_CDF))
d257 3
a259 4
			if (opcode != AHA_INQUIRE)
				printf("%s: aha_cmd, cmd/data port full\n",
				    aha->sc_dev.dv_xname);
			outb(AHA_CTRL_STAT_PORT, AHA_SRST);
d262 1
a262 1
		outb(AHA_CMD_DATA_PORT, (u_char) (*ic++));
a268 1
		sts = inb(AHA_CTRL_STAT_PORT);
d270 2
a271 2
			sts = inb(AHA_CTRL_STAT_PORT);
			if (sts & AHA_DF)
d276 1
a276 1
			if (opcode != AHA_INQUIRE)
d278 2
a279 2
					aha->sc_dev.dv_xname, ocnt);
			outb(AHA_CTRL_STAT_PORT, AHA_SRST);
d282 1
a282 3
		oc = inb(AHA_CMD_DATA_PORT);
		if (retval)
			*retval++ = oc;
d285 17
a301 8
	 * Wait for the board to report a finised instruction
	 */
	i = 20000;
	while (--i) {
		sts = inb(AHA_INTR_PORT);
		if (sts & AHA_HACC)
			break;
		delay(50);
d303 1
a303 6
	if (!i) {
		printf("%s: aha_cmd, host not finished(0x%x)\n",
			aha->sc_dev.dv_xname, sts);
		return ENXIO;
	}
	outb(AHA_CTRL_STAT_PORT, AHA_IRST);
d318 1
a318 2
	struct aha_softc *aha = match;
	struct isa_attach_args *ia = aux;
d325 2
a326 7
	aha->sc_iobase = ia->ia_iobase;

	/*
	 * Try initialise a unit at this location
	 * sets up dma and bus speed, loads aha->sc_irq
	 */
	if (aha_find(aha) != 0)
a328 18
	if (ia->ia_irq != IRQUNK) {
		if (ia->ia_irq != aha->sc_irq) {
			printf("%s: irq mismatch; kernel configured %d != board configured %d\n",
			    aha->sc_dev.dv_xname, ia->ia_irq, aha->sc_irq);
			return 0;
		}
	} else
		ia->ia_irq = aha->sc_irq;

	if (ia->ia_drq != DRQUNK) {
		if (ia->ia_drq != aha->sc_drq) {
			printf("%s: drq mismatch; kernel configured %d != board configured %d\n",
			    aha->sc_dev.dv_xname, ia->ia_drq, aha->sc_drq);
			return 0;
		}
	} else
		ia->ia_drq = aha->sc_drq;

d331 1
d340 1
d355 1
a355 4
	struct aha_softc *aha = (void *)self;

	if (ia->ia_drq != DRQUNK)
		isadma_cascade(ia->ia_drq);
d357 11
a367 2
	aha_init(aha);
	TAILQ_INIT(&aha->free_ccb);
d372 5
a376 7
	aha->sc_link.adapter_softc = aha;
	aha->sc_link.adapter_target = aha->aha_scsi_dev;
	aha->sc_link.adapter = &aha_switch;
	aha->sc_link.device = &aha_dev;
	aha->sc_link.openings = 2;

	printf("\n");
d379 1
a379 1
	isa_establish(&aha->sc_id, &aha->sc_dev);
d381 2
a382 2
	aha->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_BIO, ahaintr,
	    aha, aha->sc_dev.dv_xname);
d387 1
a387 1
	config_found(self, &aha->sc_link, ahaprint);
d390 3
a392 6
/*
 * Catch an interrupt from the adaptor
 */
int
ahaintr(arg)
	void *arg;
a393 1
	struct aha_softc *aha = arg;
a394 1
	struct aha_mbx *wmbx;
a395 1
	u_char stat;
a396 1
	int found = 0;
d398 1
a398 3
#ifdef AHADEBUG
	printf("%s: ahaintr ", aha->sc_dev.dv_xname);
#endif /*AHADEBUG */
d400 8
a407 18
	/*
	 * First acknowlege the interrupt, Then if it's not telling about
	 * a completed operation just return.
	 */
	stat = inb(AHA_INTR_PORT);
	if ((stat & (AHA_MBOA | AHA_MBIF)) == 0) {
		outb(AHA_CTRL_STAT_PORT, AHA_IRST);
		return -1;	/* XXX */
	}

	/* Mail box out empty? */
	if (stat & AHA_MBOA) {
		/* Disable MBO available interrupt. */
		outb(AHA_CMD_DATA_PORT, AHA_MBO_INTR_EN);
		for (i = 100000; i; i--) {
			if (!(inb(AHA_CTRL_STAT_PORT) & AHA_CDF))
				break;
			delay(10);
d409 5
a413 8
		if (!i) {
			printf("%s: ahaintr, cmd/data port full\n",
			    aha->sc_dev.dv_xname);
			outb(AHA_CTRL_STAT_PORT, AHA_SRST);
			return 1;
		}
		outb(AHA_CMD_DATA_PORT, 0x00);	/* Disable */
		wakeup(&aha->aha_mbx);
a415 5
	/* Mail box in full? */
	if ((stat & AHA_MBIF) == 0)
		return 1;
	wmbx = &aha->aha_mbx;
	wmbi = wmbx->tmbi;
d417 2
a418 2
	while (wmbi->stat != AHA_MBI_FREE) {
		ccb = aha_ccb_phys_kv(aha, _3btol(wmbi->ccb_addr));
d420 13
a432 3
			wmbi->stat = AHA_MBI_FREE;
			printf("%s: BAD CCB ADDR!\n", aha->sc_dev.dv_xname);
			continue;
d434 2
a435 1
		found++;
d439 11
a452 3
			ccb->host_stat = AHA_ABORTED;
			break;

d454 4
a457 1
			ccb = 0;
d461 3
a463 1
			panic("Impossible mbxi status");
d465 5
a469 11
#ifdef AHADEBUG
		if (aha_debug && ccb) {
			u_char *cp = &ccb->scsi_cmd;
			printf("op=%x %x %x %x %x %x\n",
			    cp[0], cp[1], cp[2],
			    cp[3], cp[4], cp[5]);
			printf("stat %x for mbi addr = 0x%08x, ",
			    wmbi->stat, wmbi);
			printf("ccb addr = 0x%x\n", ccb);
		}
#endif /* AHADEBUG */
a470 4
		if (ccb) {
			untimeout(aha_timeout, ccb);
			aha_done(aha, ccb);
		}
d472 32
a503 13
	}
	if (!found) {
		for (i = 0; i < AHA_MBX_SIZE; i++) {
			if (wmbi->stat != AHA_MBI_FREE) {
				found++;
				break;
			}
			aha_nextmbx(wmbi, wmbx, mbi);
		}
		if (!found) {
#if 0
			printf("%s: mbi interrupt with no full mailboxes\n",
			    aha->sc_dev.dv_xname);
d505 10
a514 4
		} else {
			found = 0;
			goto AGAIN;
		}
d516 5
a520 2
	wmbx->tmbi = wmbi;
	outb(AHA_CTRL_STAT_PORT, AHA_IRST);
d524 9
d534 1
a534 2
 * A ccb (and hence a mbx-out is put onto the
 * free list.
d537 2
a538 2
aha_free_ccb(aha, ccb, flags)
	struct aha_softc *aha;
a539 1
	int flags;
d541 1
a541 2
	int s, hashnum;
	struct aha_ccb **hashccb;
d545 2
a546 18
	if (ccb->ccb_phys[0].addr)
		isadma_unmap((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);

	/* remove from hash table */

	hashnum = CCB_HASH(ccb->ccb_phys[0].addr);
	hashccb = &aha->ccbhash[hashnum];

	while (*hashccb) {
		if ((*hashccb)->ccb_phys[0].addr == ccb->ccb_phys[0].addr) {
			*hashccb = (*hashccb)->nexthash;
			break;
		}
		hashccb = &(*hashccb)->nexthash;
 	}

	ccb->flags = CCB_FREE;
	TAILQ_INSERT_HEAD(&aha->free_ccb, ccb, chain);
d553 1
a553 1
		wakeup(&aha->free_ccb);
d558 3
a560 3
static inline void
aha_init_ccb(aha, ccb)
	struct aha_softc *aha;
d563 2
d566 9
a574 8
}

static inline void
aha_reset_ccb(aha, ccb)
	struct aha_softc *aha;
	struct aha_ccb *ccb;
{

d579 3
d584 2
a585 2
aha_get_ccb(aha, flags)
	struct aha_softc *aha;
d589 1
a589 1
	int hashnum, mflags, s;
a592 5
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;

d594 2
a595 2
	 * If we can and have to, sleep waiting for one
	 * to come free
d598 1
a598 1
		ccb = aha->free_ccb.tqh_first;
d600 1
a600 1
			TAILQ_REMOVE(&aha->free_ccb, ccb, chain);
d603 4
a606 6
		if (aha->numccbs < AHA_CCB_MAX) {
			if (ccb = (struct aha_ccb *) malloc(sizeof(struct aha_ccb),
			    M_TEMP, M_NOWAIT)) {
				aha_init_ccb(aha, ccb);
				aha->numccbs++;
			} else {
d608 1
a608 1
				    aha->sc_dev.dv_xname);
d611 2
d617 1
a617 1
		tsleep(&aha->free_ccb, PRIBIO, "ahaccb", 0);
d620 1
a620 13
	aha_reset_ccb(aha, ccb);
	ccb->flags = CCB_ACTIVE;

	if (isadma_map((caddr_t)ccb, CCB_PHYS_SIZE, ccb->ccb_phys,
	    mflags | ISADMA_MAP_CONTIG) == 1) {
		hashnum = CCB_HASH(ccb->ccb_phys[0].addr);
		ccb->nexthash = aha->ccbhash[hashnum];
		aha->ccbhash[hashnum] = ccb;
	} else {
		ccb->ccb_phys[0].addr = 0;
		aha_free_ccb(aha, ccb, flags);
		ccb = 0;
	}
d628 1
a628 1
 * given a physical address, find the ccb that it corresponds to.
d631 2
a632 2
aha_ccb_phys_kv(aha, ccb_phys)
	struct aha_softc *aha;
d636 1
a636 1
	struct aha_ccb *res = aha->ccbhash[hashnum];
d638 2
a639 2
	while (res) {
		if (res->ccb_phys[0].addr == ccb_phys)
d641 1
a641 1
		res = res->nexthash;
d643 11
d655 2
a656 1
	return res;
d660 1
a660 1
 * Get a mbo and send the ccb.
d662 5
a666 4
struct aha_mbx_out *
aha_send_mbo(aha, cmd, ccb)
	struct aha_softc *aha;
	int cmd;
d668 25
d694 1
d696 1
a696 1
	struct aha_mbx *wmbx;		/* Mail Box pointer specified unit */
a698 2
	/* Get the target out mail box pointer and increment. */
	wmbx = &aha->aha_mbx;
a699 1
	aha_nextmbx(wmbx->tmbo, wmbx, mbo);
d701 10
a710 9
	/*
	 * Check the outmail box is free or not.
	 * Note: Under the normal operation, it shuld NOT happen to wait.
	 */
	while (wmbo->cmd != AHA_MBO_FREE) {
		/* Enable mbo available interrupt. */
		outb(AHA_CMD_DATA_PORT, AHA_MBO_INTR_EN);
		for (i = 100000; i; i--) {
			if (!(inb(AHA_CTRL_STAT_PORT) & AHA_CDF))
d712 1
a712 1
			delay(10);
a713 9
		if (!i) {
			printf("%s: aha_send_mbo, cmd/data port full\n",
			    aha->sc_dev.dv_xname);
			outb(AHA_CTRL_STAT_PORT, AHA_SRST);
			return NULL;
		}
		outb(AHA_CMD_DATA_PORT, 0x01);	/* Enable */
		tsleep(wmbx, PRIBIO, "ahasnd", 0);/*XXX can't do this */
	}
d715 17
a731 4
	/* Link ccb to mbo. */
	lto3b(ccb->ccb_phys[0].addr, wmbo->ccb_addr);
	ccb->mbx = wmbo;
	wmbo->cmd = cmd;
d733 3
a735 2
	/* Sent it! */
	outb(AHA_CMD_DATA_PORT, AHA_START_SCSI);
d737 1
a737 1
	return wmbo;
d746 2
a747 2
aha_done(aha, ccb)
	struct aha_softc *aha;
d758 3
a760 2
	if ((xs->flags & INUSE) == 0) {
		printf("%s: exiting but not in use!\n", aha->sc_dev.dv_xname);
d762 7
a772 3
			case AHA_ABORTED:
				xs->error = XS_DRIVER_STUFFUP;
				break;
d778 1
a778 1
				    aha->sc_dev.dv_xname, ccb->host_stat);
d780 1
d796 1
a796 1
				    aha->sc_dev.dv_xname, ccb->target_stat);
d798 1
d803 1
a804 14

	if (VOLATILE_XS(xs)) {
		wakeup(ccb);
		return;
	}

	if (ccb->data_nseg) {
		if (xs->flags & SCSI_DATA_IN)
			isadma_copyfrombuf(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
		isadma_unmap(xs->data, xs->datalen,
		    ccb->data_nseg, ccb->data_phys);
	}
	aha_free_ccb(aha, ccb, xs->flags);
d812 3
a814 2
aha_find(aha)
	struct aha_softc *aha;
d816 5
a820 4
	volatile int i, sts;
	struct aha_config conf;
	struct aha_inquire inquire;
	struct aha_extbios extbios;
d827 1
a827 1
	outb(AHA_CTRL_STAT_PORT, AHA_HRST | AHA_SRST);
d829 1
d831 2
a832 2
		sts = inb(AHA_CTRL_STAT_PORT);
		if (sts == (AHA_IDLE | AHA_INIT))
d837 1
a837 1
#ifdef	AHADEBUG
a839 24
#endif /*AHADEBUG */
		return ENXIO;
	}

	/*
	 * Assume we have a board at this stage, do an adapter inquire
	 * to find out what type of controller it is.  If the command
	 * fails, we assume it's either a crusty board or an old 1542
	 * clone, and skip the board-specific stuff.
	 */
	if (aha_cmd(aha, 0, sizeof(inquire), 1, &inquire, AHA_INQUIRE)) {
		/*
		 * aha_cmd() already started the reset.  It's not clear we
		 * even need to bother here.
		 */
		for (i = AHA_RESET_TIMEOUT; i; i--) {
			sts = inb(AHA_CTRL_STAT_PORT);
			if (sts == (AHA_IDLE | AHA_INIT))
				break;
			delay(1000);
		}
		if (!i) {
#ifdef AHADEBUG
			printf("aha_init: soft reset failed\n");
d841 1
a841 6
			return ENXIO;
		}
#ifdef AHADEBUG
		printf("aha_init: inquire command failed\n");
#endif /* AHADEBUG */
		goto noinquire;
a842 25
#ifdef AHADEBUG
	printf("%s: inquire %x, %x, %x, %x\n",
		aha->sc_dev.dv_xname,
		inquire.boardid, inquire.spec_opts,
		inquire.revision_1, inquire.revision_2);
#endif	/* AHADEBUG */
	/*
	 * If we are a 1542C or 1542CF disable the extended bios so that the
	 * mailbox interface is unlocked.
	 * No need to check the extended bios flags as some of the
	 * extensions that cause us problems are not flagged in that byte.
	 */
	if (inquire.boardid == 0x43 || inquire.boardid == 0x44 ||
	    inquire.boardid == 0x45) {
		aha_cmd(aha, 0, sizeof(extbios), 0, &extbios, AHA_EXT_BIOS);
#ifdef	AHADEBUG
		printf("%s: extended bios flags %x\n", aha->sc_dev.dv_xname,
			extbios.flags);
#endif	/* AHADEBUG */
		printf("%s: 1542C/CF detected, unlocking mailbox\n",
			aha->sc_dev.dv_xname);
		aha_cmd(aha, 2, 0, 0, 0, AHA_MBX_ENABLE,
			0, extbios.mailboxlock);
	}
noinquire:
d849 7
a855 2
	aha_cmd(aha, 0, sizeof(conf), 0, &conf, AHA_CONF_GET);
	switch (conf.chan) {
d857 1
a857 1
		aha->sc_drq = 0;
d860 1
a860 1
		aha->sc_drq = 5;
d863 1
a863 1
		aha->sc_drq = 6;
d866 1
a866 1
		aha->sc_drq = 7;
d869 2
a870 3
		printf("%s: illegal drq setting %x\n", aha->sc_dev.dv_xname,
		    conf.chan);
		return EIO;
d873 1
a873 1
	switch (conf.intr) {
d875 1
a875 1
		aha->sc_irq = 9;
d878 1
a878 1
		aha->sc_irq = 10;
d881 1
a881 1
		aha->sc_irq = 11;
d884 1
a884 1
		aha->sc_irq = 12;
d887 1
a887 1
		aha->sc_irq = 14;
d890 1
a890 1
		aha->sc_irq = 15;
d893 1
a893 2
		printf("%s: illegal irq setting %x\n", aha->sc_dev.dv_xname,
		    conf.intr);
d897 17
a913 8
	/* who are we on the scsi bus? */
	aha->aha_scsi_dev = conf.scsi_dev;

	/*
	 * Change the bus on/off times to not clash with other dma users.
	 */
	aha_cmd(aha, 1, 0, 0, 0, AHA_BUS_ON_TIME_SET, 7);
	aha_cmd(aha, 1, 0, 0, 0, AHA_BUS_OFF_TIME_SET, 4);
d922 2
a923 2
aha_init(aha)
	struct aha_softc *aha;
d925 4
a928 2
	u_char ad[3];
	struct isadma_seg mbx_phys[1];
a930 1
#ifdef TUNE_1542
d932 5
a936 2
	 * Initialize memory transfer speed
	 * Not compiled in by default because it breaks some machines
d938 14
a951 3
	if (!aha_set_bus_speed(aha))
		panic("aha_init: cannot set bus speed");
#endif /* TUNE_1542 */
d953 8
d962 1
a962 1
	 * Initialize mail box. This mapping will never be undone.
d964 3
a966 4
	if (isadma_map((caddr_t)(&aha->aha_mbx), sizeof(struct aha_mbx),
	    mbx_phys, ISADMA_MAP_CONTIG) != 1)
		panic("aha_init: cannot map mail box");
	lto3b(mbx_phys[0].addr, ad);
d968 24
a991 2
	aha_cmd(aha, 4, 0, 0, 0, AHA_MBX_INIT, AHA_MBX_SIZE,
	    ad[0], ad[1], ad[2]);
d993 3
d997 2
a998 2
		aha->aha_mbx.mbo[i].cmd = AHA_MBO_FREE;
		aha->aha_mbx.mbi[i].stat = AHA_MBO_FREE;
d1000 23
d1025 4
a1028 1
	 * Set up initial mail box for round-robin operation.
d1030 62
a1091 2
	aha->aha_mbx.tmbo = &aha->aha_mbx.mbo[0];
	aha->aha_mbx.tmbi = &aha->aha_mbx.mbi[0];
d1113 1
a1113 1
	struct aha_softc *aha = sc_link->adapter_softc;
d1116 3
a1118 1
	int seg, datalen, flags, mflags;
a1119 1
	struct aha_mbx_out *mbo;
d1129 1
a1129 10
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;
	if ((flags & (ITSDONE|INUSE)) != INUSE) {
		printf("%s: done or not in use?\n", aha->sc_dev.dv_xname);
		xs->flags &= ~ITSDONE;
		xs->flags |= INUSE;
	}
	if ((ccb = aha_get_ccb(aha, flags)) == NULL) {
d1134 1
d1141 1
d1146 2
a1148 9
	ccb->data_out = 0;
	ccb->data_in = 0;
	ccb->target = sc_link->target;
	ccb->lun = sc_link->lun;
	ccb->scsi_cmd_length = xs->cmdlen;
	ccb->req_sense_length = sizeof(ccb->scsi_sense);
	ccb->host_stat = 0x00;
	ccb->target_stat = 0x00;
	ccb->data_nseg = 0;
d1150 1
a1150 3
	if (xs->datalen && (flags & SCSI_RESET) == 0) {
		sg = ((struct aha_ccb *)(ccb->ccb_phys[0].addr))->scat_gath;
		lto3b((vm_offset_t)sg, ccb->data_addr);
d1159 2
a1160 2
				lto3b(iovp->iov_base, sg->seg_addr);
				lto3b(iovp->iov_len, sg->seg_len);
d1170 1
a1170 1
#endif /*TFS_ONLY */
d1173 1
a1173 1
			 * Set up the scatter gather block
d1175 12
d1188 39
a1226 7
			ccb->data_nseg = isadma_map(xs->data, xs->datalen,
			    ccb->data_phys, mflags);
			for (seg = 0; seg < ccb->data_nseg; seg++) {
				lto3b(ccb->data_phys[seg].addr,
				    sg[seg].seg_addr);
				lto3b(ccb->data_phys[seg].length,
				    sg[seg].seg_len);
d1229 12
a1240 10
		lto3b(ccb->data_nseg * sizeof(struct aha_scat_gath), ccb->data_length);
		if (ccb->data_nseg == 0) {
			printf("%s: aha_scsi_cmd, cannot map\n",
			    aha->sc_dev.dv_xname);
			xs->error = XS_DRIVER_STUFFUP;
			aha_free_ccb(aha, ccb, flags);
			return COMPLETE;
		} else if (flags & SCSI_DATA_OUT)
			isadma_copytobuf(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
d1242 2
a1243 2
		lto3b(0, ccb->data_addr);
		lto3b(0, ccb->data_length);
d1245 8
d1254 1
a1254 7
	lto3b(0, ccb->link_addr);

	/*
	 * Put the scsi command in the ccb and start it
	 */
	if ((flags & SCSI_RESET) == 0)
		bcopy(xs->cmd, &ccb->scsi_cmd, ccb->scsi_cmd_length);
d1257 2
a1258 12

	isadma_copytobuf((caddr_t)ccb, CCB_PHYS_SIZE, 1, ccb->ccb_phys);

	if (aha_send_mbo(aha, AHA_MBO_START, ccb) == NULL) {
		splx(s);
		xs->error = XS_DRIVER_STUFFUP;
		if (ccb->data_nseg)
			isadma_unmap(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
		aha_free_ccb(aha, ccb, flags);
		return TRY_AGAIN_LATER;
	}
d1264 1
a1264 22

	if (VOLATILE_XS(xs)) {
		timeout(aha_timeout, ccb, (xs->timeout * hz) / 1000);
		while ((ccb->xs->flags & ITSDONE) == 0) {
			tsleep(ccb, PRIBIO, "ahawait", 0);
		}
		splx(s);
		if (ccb->data_nseg) {
			if (flags & SCSI_DATA_IN)
				isadma_copyfrombuf(xs->data, xs->datalen,
				    ccb->data_nseg, ccb->data_phys);
			isadma_unmap(xs->data, xs->datalen,
			    ccb->data_nseg, ccb->data_phys);
		}
		aha_free_ccb(aha, ccb, xs->flags);
		scsi_done(xs);
		return COMPLETE;
	}

	if ((flags & SCSI_POLL) == 0) {
		timeout(aha_timeout, ccb, (xs->timeout * hz) / 1000);
		splx(s);
a1265 3
	}

	splx(s);
d1270 1
a1270 1
	if (aha_poll(aha, xs, xs->timeout)) {
d1272 1
a1272 1
		if (aha_poll(aha, xs, 2000))
d1276 5
d1287 2
a1288 2
aha_poll(aha, xs, count)
	struct aha_softc *aha;
d1292 1
d1300 2
a1301 2
		if (inb(AHA_INTR_PORT) & AHA_ANY_INTR)
			ahaintr(aha);
a1309 135
#ifdef TUNE_1542
/*
 * Try all the speeds from slowest to fastest.. if it finds a
 * speed that fails, back off one notch from the last working
 * speed (unless there is no other notch).
 * Returns the nSEC value of the time used
 * or 0 if it could get a working speed (or the NEXT speed
 * failed)
 */
static struct bus_speed {
	u_char arg;
	int nsecs;
} aha_bus_speeds[] = {
	{0x88, 100},
	{0x99, 150},
	{0xaa, 200},
	{0xbb, 250},
	{0xcc, 300},
	{0xdd, 350},
	{0xee, 400},
	{0xff, 450}
};

int
aha_set_bus_speed(aha)
	struct aha_softc *aha;
{
	int speed;
	int lastworking;

	lastworking = -1;
	for (speed = 7; speed >= 0; speed--) {
		if (!aha_bus_speed_check(aha, speed))
			break;
		lastworking = speed;
	}
	if (lastworking == -1) {
		printf(" no working bus speed");
		return 0;
	}
	printf(", %d nsec ", aha_bus_speeds[lastworking].nsecs);
	if (lastworking == 7)	/* is slowest already */
		printf("marginal");
	else {
		lastworking++;
		printf("ok, using %d nsec", aha_bus_speeds[lastworking].nsecs);
	}
	if (!aha_bus_speed_check(aha, lastworking)) {
		printf("test retry failed.. aborting.");
		return 0;
	}
	return 1;
}

/*
 * Set the DMA speed to the Nth speed and try an xfer. If it
 * fails return 0, if it succeeds return the nSec value selected
 * If there is no such speed return COMPLETE.
 */
char aha_scratch_buf[256];
char aha_test_string[] =
    "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890abcdefghijklmnopqrstuvwxyz!@@";

int
aha_bus_speed_check(aha, speed)
	struct aha_softc *aha;
	int speed;
{
	int numspeeds = sizeof(aha_bus_speeds) / sizeof(struct bus_speed);
	int result, loopcount;
	struct isadma_seg test_phys[1], scratch_phys[1];
	u_char ad[3];

	result = 1;

	if (isadma_map(aha_scratch_buf, sizeof(aha_scratch_buf),
	    scratch_phys, ISADMA_MAP_CONTIG) != 1)
		return 0;
	if (isadma_map(aha_test_string, sizeof(aha_test_string), 
	    test_phys, ISADMA_MAP_CONTIG) != 1) {
		isadma_unmap(aha_scratch_buf, sizeof(aha_scratch_buf),
		    1, scratch_phys);
		return 0;
	}
	isadma_copytobuf(aha_test_string, sizeof(aha_test_string),
	    1, test_phys);

	/*
	 * Set the dma-speed
	 */
	aha_cmd(aha, 1, 0, 0, 0, AHA_SPEED_SET, aha_bus_speeds[speed].arg);

	/*
	 * put the test data into the buffer and calculate
	 * it's address. Read it onto the board
	 */
	for (loopcount = 100; loopcount; loopcount--) {
		lto3b(test_phys[0].addr, ad);
		aha_cmd(aha, 3, 0, 0, 0, AHA_WRITE_FIFO, ad[0], ad[1], ad[2]);

		/*
		 * Clear the buffer then copy the contents back from the
		 * board.
		 */
		bzero(aha_scratch_buf, 54);
		isadma_copytobuf(aha_scratch_buf, sizeof(aha_scratch_buf),
				 1, scratch_phys);

		lto3b(scratch_phys[0].addr, ad);
		aha_cmd(aha, 3, 0, 0, 0, AHA_READ_FIFO, ad[0], ad[1], ad[2]);
		isadma_copyfrombuf(aha_scratch_buf, sizeof(aha_scratch_buf),
				   1, scratch_phys);

		/*
		 * Compare the original data and the final data and return the
		 * correct value depending upon the result.  We only check the
		 * first 54 bytes, because that's all the board copies during
		 * WRITE_FIFO and READ_FIFO.
		 */
		if (bcmp(aha_test_string, aha_scratch_buf, 54)) {
			result = 0; /* failed test */
			break;
		}
	}

	isadma_unmap(aha_scratch_buf, sizeof(aha_scratch_buf),
	    1, scratch_phys);
	isadma_unmap(aha_test_string, sizeof(aha_test_string),
	    1, test_phys);

	/* copy succeeded; assume speed ok */
	return result;
}
#endif /* TUNE_1542 */

d1317 1
a1317 1
	struct aha_softc *aha = sc_link->adapter_softc;
d1325 1
d1329 3
a1331 3
	if (aha_ccb_phys_kv(aha, _3btol(ccb->mbx->ccb_addr)) == ccb &&
	    ccb->mbx->cmd != AHA_MBO_FREE) {
		printf("%s: not taking commands!\n", aha->sc_dev.dv_xname);
d1334 1
d1341 1
a1341 1
	if (ccb->flags == CCB_ABORTED) {
d1344 1
a1344 2
		ccb->xs->retries = 0;
		aha_done(aha, ccb);
d1349 3
a1351 5
		ccb->flags = CCB_ABORTED;
		aha_send_mbo(aha, AHA_MBO_ABORT, ccb);
		/* 2 secs for the abort */
		if ((xs->flags & SCSI_POLL) == 0)
			timeout(aha_timeout, ccb, 2 * hz);
@


1.12
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: aha1542.c,v 1.11 1996/03/08 16:42:47 niklas Exp $	*/
d607 1
a607 1
	    aha);
@


1.11
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d607 1
a607 1
	    aha, aha->sc_dev.dv_xname);
@


1.10
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: aha1542.c,v 1.53 1995/10/03 20:58:56 mycroft Exp $	*/
@


1.9
log
@Removed extra brace.
@
text
@d606 1
a606 1
	    aha);
@


1.8
log
@Corrected typo when removing CCB's from the hash list.
@
text
@a762 2
 
	}
@


1.7
log
@Remove CCB from hash list when it gets unmapped, not the first time looked up.
@
text
@d761 3
a763 1
		(*hashccb) = (*hashccb)->nexthash;
@


1.6
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d2 1
a79 1
#include <machine/vmparam.h>
d226 1
a227 1
	/*----------------------------------------------------------------*/
d238 1
a238 1
	int data_nseg;
d743 2
a744 1
	int s;
d751 13
a781 2
	int hashnum;

d866 1
a866 1
	struct aha_ccb *res, **ccb = &aha->ccbhash[hashnum];
d868 2
a869 2
	while (*ccb) {
		if ((*ccb)->ccb_phys[0].addr == ccb_phys)
d871 1
a871 1
		(*ccb) = (*ccb)->nexthash;
a873 3
	if (res = *ccb)
		*ccb = (*ccb)->nexthash;

d1345 1
a1345 2
			tsleep(ccb, PRIBIO, "ahawait",
			    (xs->timeout * hz) / 1000);
@


1.5
log
@from netbsd; print illegal setting messages nicer
@
text
@d605 2
a606 2
	aha->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_BIO,
	    ahaintr, aha);
@


1.4
log
@properly catch cases where buffers are on the kstack, from hannken@@eis.cs.tu-bs.de
@
text
@d1100 2
a1101 1
		printf("illegal dma setting %x\n", conf.chan);
d1125 2
a1126 1
		printf("illegal int setting %x\n", conf.intr);
@


1.3
log
@correct way to call tsleep is almost always "while (condition) tsleep(...)"
@
text
@d81 1
a81 2
	((xs)->datalen > 0 && \
	((vm_offset_t)((xs)->data) < VM_MIN_KERNEL_ADDRESS) && \
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
ultra14f does not bounce properly yet.
@
text
@d74 4
a77 3
/* XXX fixme: */
/* on i386 at least xfers from/to user memory */
/* cannot be serviced at interrupt time. */
d1333 4
a1336 3
		if (tsleep(ccb, PRIBIO, "ahawait", (xs->timeout * hz) / 1000)) {
			aha_timeout(ccb);
			tsleep(ccb, PRIBIO, "ahawait1", 2000);
@


1.1
log
@Initial revision
@
text
@a1 1

d52 1
d66 1
d74 15
d203 1
a203 1
				/* allow 64 K i/o (min) */
d226 1
a229 1
	long hashkey;
d236 3
a323 2
#define KVTOPHYS(x)	vtophys(x)

d569 1
a569 1
	if (name != NULL)       
d586 1
a586 1
		isa_dmacascade(ia->ia_drq);
d747 3
a770 8
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	ccb->hashkey = KVTOPHYS(ccb);
	hashnum = CCB_HASH(ccb->hashkey);
	ccb->nexthash = aha->ccbhash[hashnum];
	aha->ccbhash[hashnum] = ccb;
d790 1
a790 1
	int s;
d794 5
d829 11
d854 1
a854 1
	struct aha_ccb *ccb = aha->ccbhash[hashnum];
d856 2
a857 2
	while (ccb) {
		if (ccb->hashkey == ccb_phys)
d859 1
a859 1
		ccb = ccb->nexthash;
d861 5
a865 1
	return ccb;
d909 1
a909 1
	lto3b(KVTOPHYS(ccb), wmbo->ccb_addr);
d976 13
a999 1
	u_char ad[3];
a1136 10
#ifdef TUNE_1542
#error XXX Must deal with configuring the DRQ channel if we do this.
	/*
	 * Initialize memory transfer speed
	 * Not compiled in by default because it breaks some machines
	 */
	if (!aha_set_bus_speed(aha))
		return EIO;
#endif /* TUNE_1542 */

d1148 1
d1151 1
d1153 2
a1154 1
	 * Initialize mail box
d1156 11
a1166 1
	lto3b(KVTOPHYS(&aha->aha_mbx), ad);
d1205 1
a1205 4
	int seg;		/* scatter gather seg being worked on */
	int thiskv;
	u_long thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
d1217 4
d1250 1
d1253 2
a1254 1
		lto3b(KVTOPHYS(ccb->scat_gath), ccb->data_addr);
d1280 7
a1286 53
			SC_DEBUG(sc_link, SDEV_DB4,
				("%d @@0x%x:- ", xs->datalen, xs->data));
			datalen = xs->datalen;
			thiskv = (int) xs->data;
			thisphys = KVTOPHYS(thiskv);

			while (datalen && seg < AHA_NSEG) {
				bytes_this_seg = 0;

				/* put in the base address */
				lto3b(thisphys, sg->seg_addr);

				SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the the last, just extend the
					 * length
					 */
					/* check it fits on the ISA bus */
					if (thisphys > 0xFFFFFF) {
						printf("%s: DMA beyond"
							" end of ISA\n",
							aha->sc_dev.dv_xname);
						xs->error = XS_DRIVER_STUFFUP;
						aha_free_ccb(aha, ccb, flags);
						return COMPLETE;
					}
					/** how far to the end of the page ***/
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = KVTOPHYS(thiskv);
				}
				/*
				 * next page isn't contiguous, finish the seg
				 */
				SC_DEBUGN(sc_link, SDEV_DB4,
				    ("(0x%x)", bytes_this_seg));
				lto3b(bytes_this_seg, sg->seg_len);
				sg++;
				seg++;
d1289 4
a1292 8
		lto3b(seg * sizeof(struct aha_scat_gath), ccb->data_length);
		SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: aha_scsi_cmd, more than %d dma segs\n",
			    aha->sc_dev.dv_xname, AHA_NSEG);
d1296 3
a1298 1
		}
d1314 2
d1319 3
d1330 19
d1431 1
a1431 1
		printf("no working bus speed\n");
d1434 1
a1434 1
	printf("%d nsec ", aha_bus_speeds[lastworking].nsecs);
d1436 1
a1436 1
		printf("marginal\n");
d1439 1
a1439 2
		printf("ok, using %d nsec\n",
		    aha_bus_speeds[lastworking].nsecs);
d1442 1
a1442 1
		printf("test retry failed.. aborting.\n");
d1463 2
a1464 1
	int loopcount;
d1467 14
d1491 1
a1491 1
		lto3b(KVTOPHYS(aha_test_string), ad);
d1499 2
d1502 1
a1502 1
		lto3b(KVTOPHYS(aha_scratch_buf), ad);
d1504 2
d1513 4
a1516 2
		if (bcmp(aha_test_string, aha_scratch_buf, 54))
			return 0; /* failed test */
d1519 5
d1525 1
a1525 1
	return 1;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
