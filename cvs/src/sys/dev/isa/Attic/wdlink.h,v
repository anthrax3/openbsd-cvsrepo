head	1.11;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	UBC_SYNC_A:1.11
	UBC_SYNC_B:1.11
	SMP:1.11.0.2
	kame_19991208:1.10
	OPENBSD_2_6:1.10.0.6
	OPENBSD_2_6_BASE:1.10
	OPENBSD_2_5:1.10.0.4
	OPENBSD_2_5_BASE:1.10
	OPENBSD_2_4:1.10.0.2
	OPENBSD_2_4_BASE:1.10
	OPENBSD_2_3:1.9.0.2
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.8.0.2
	OPENBSD_2_2_BASE:1.8
	OPENBSD_2_1:1.6.0.2
	OPENBSD_2_1_BASE:1.6
	OPENBSD_2_0:1.4.0.2
	OPENBSD_2_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.11
date	99.12.11.21.25.08;	author csapuntz;	state dead;
branches;
next	1.10;

1.10
date	98.08.08.23.01.11;	author downsj;	state Exp;
branches;
next	1.9;

1.9
date	97.12.10.23.11.13;	author rees;	state Exp;
branches;
next	1.8;

1.8
date	97.07.06.18.10.19;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	97.07.04.17.02.04;	author downsj;	state Exp;
branches;
next	1.6;

1.6
date	96.11.29.22.55.10;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.11.28.08.23.40;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.09.11.07.27.04;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.08.07.01.53.03;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.06.09.08.59.57;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	96.06.08.09.12.46;	author downsj;	state Exp;
branches;
next	;


desc
@@


1.11
log
@

Remove old IDE driver
@
text
@/*	$OpenBSD: wdlink.h,v 1.10 1998/08/08 23:01:11 downsj Exp $	*/

/*
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * DMA and multi-sector PIO handling are derived from code contributed by
 * Onno van der Linden.
 *
 * Atapi support added by Manuel Bouyer.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *  This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/* #undef WDDEBUG */
/* #undef DIAGNOSTIC */

#include "wd.h"

struct wdc_link {
	int flags;
	int openings;
};

struct wdc_softc {
	struct device sc_dev;
	void *sc_ih;
	struct wd_link *d_link[2];
	struct bus_link *ab_link;
	struct wdc_link ctlr_link;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh;
	bus_space_handle_t sc_ioh_ctl;
	int sc_drq;			/* DMA channel */

	TAILQ_HEAD(xferhead, wdc_xfer) sc_xfer;
	int sc_flags;
#define	WDCF_ACTIVE		0x01	/* controller is active */
#define	WDCF_SINGLE		0x02	/* sector at a time mode */
#define	WDCF_ERROR		0x04	/* processing a disk error */
#define	WDCF_WANTED		0x08	/* XXX locking for wd_get_parms() */
#define	WDCF_IRQ_WAIT		0x10	/* controller is waiting for irq */
#define	WDCF_ONESLAVE		0x20	/* ctrl. has one ATAPI slave attached */
#define WDCF_BROKENPOLL		0x40	/* or, generally fucked up */
	u_char sc_status;		/* copy of status register */
	u_char sc_error;		/* copy of error register */
};

struct wd_link {
	u_char type;  
#define DRIVE 0
#define BUS 1
	caddr_t wdc_softc;
	caddr_t wd_softc;
	struct wdc_link *ctlr_link;
	struct wdparams sc_params;

	/* Long-term state: */
	u_int8_t openings;
	int sc_drive;			/* physical unit number */
	int sc_state;			/* control state */
#define RECAL		0		/* recalibrate */
#define RECAL_WAIT	1		/* done recalibrating */
#define GEOMETRY	2		/* upload geometry */
#define GEOMETRY_WAIT	3		/* done uploading geometry */
#define MULTIMODE	4		/* set multiple mode */
#define MULTIMODE_WAIT	5		/* done setting multiple mode */
#define READY		6		/* done with open */
	int sc_mode;			/* transfer mode */
#define WDM_PIOSINGLE	0		/* single-sector PIO */
#define WDM_PIOMULTI	1		/* multi-sector PIO */
#define WDM_DMA		2		/* DMA */
	int sc_multiple;		/* multiple for WDM_PIOMULTI */
	int sc_flags;			/* drive characteistics found */
#define WDF_LOCKED	0x01
#define WDF_WANTED	0x02
#define WDF_WLABEL	0x04		/* label is writable */
#define WDF_LABELLING	0x08		/* writing label */

/*
 * XXX Nothing resets this yet, but disk change sensing will when ATAPI is
 * implemented.
 */
#define WDF_LOADED	0x10		/* parameters loaded */
#define WDF_32BIT	0x20		/* can do 32-bit transfer */
#define WDF_WAIT	0x40		/* waiting for resourses */

	daddr_t sc_badsect[127];	/* 126 plus trailing -1 marker */
	struct disklabel *sc_lp;	/* label info for this disk */
};

struct wdc_xfer {
	struct wdc_link *c_link;	/* controller structure info */
	struct wd_link *d_link;		/* drive/bus structure info */
	volatile int c_flags;		/* handle also B_READ and B_WRITE */
#define C_INUSE 0x01
#define C_ATAPI 0x02
#define C_ERROR 0x04

	/* Information about the current transfer  */
	struct buf *c_bp;
	void *atapi_cmd;
	void *databuf;
	daddr_t c_blkno;	/* starting block number */
	int c_bcount;		/* byte count left */
	int c_skip;		/* bytes already transferred */
	int c_nblks;		/* number of blocks currently transferring */
	int c_nbytes;		/* number of bytes currently transferring */
	u_int32_t c_p_offset;	/* offset of the partition */
	int c_errors;		/* errors during current transfer */
	TAILQ_ENTRY(wdc_xfer) c_xferchain;
	LIST_ENTRY(wdc_xfer) free_list;
};

void	wdc_exec_xfer		__P((struct wd_link *, struct wdc_xfer *));
struct	wdc_xfer *wdc_get_xfer	__P((struct wdc_link *, int));
int	wdc_get_parms		__P((struct wd_link *));
int	wdccommandshort		__P((struct wdc_softc *, int, int));
int	wdcwait			__P((struct wdc_softc *, int));
int	wdccommand		__P((struct wd_link *, int, int, int, int, int, int));

#if NWD > 0
void	wderror			__P((struct wd_link* , struct buf *, char *));
int	wdsetctlr		__P((struct wd_link *));
void	wdstart			__P((void *));
void	wddone			__P((struct wd_link*, struct buf*));
#endif	/* NWD */

/*
 * ST506 spec says that if READY or SEEKCMPLT go off, then the read or write
 * command is aborted.
 */
#define	wait_for_drq(d)		wdcwait(d, WDCS_DRDY | WDCS_DSC | WDCS_DRQ)
#define	wait_for_unbusy(d)	wdcwait(d, 0)
#define	wait_for_ready(d)	wdcwait(d, WDCS_DRDY | WDCS_DSC)
#define	atapi_ready(d)		wdcwait(d, WDCS_DRQ)

#define IDE_NOSLEEP 0x01
@


1.10
log
@Split ioh allocations so that the devices no longer overlap.
Also disable the diag return check in wdc.c for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.9 1997/12/10 23:11:13 rees Exp $	*/
@


1.9
log
@move error count to xfer struct
(see bug list in wdc.c change log)
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.8 1997/07/06 18:10:19 niklas Exp $	*/
d55 1
@


1.8
log
@get rid of long, and let alpha grok the bad sectoring
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.7 1997/07/04 17:02:04 downsj Exp $	*/
a65 1
	int sc_errors;			/* errors during current transfer */
d131 1
@


1.7
log
@Support ATAPI devices without wd devices, based on manuel's code.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.6 1996/11/29 22:55:10 niklas Exp $	*/
d117 1
a117 1
	volatile long c_flags;		/* handle also B_READ and B_WRITE */
d131 1
a131 1
	u_long c_p_offset;	/* offset of the partition */
@


1.6
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.5 1996/11/28 08:23:40 downsj Exp $	*/
d40 2
d139 5
d148 1
a148 3
int	wdccommand		__P((struct wd_link *, int, int, int, int, int, int));
int	wdccommandshort		__P((struct wdc_softc *, int, int));
int	wdcwait			__P((struct wdc_softc *, int));
@


1.5
log
@Pull in laptop changes from cgd, a couple from me, and a few slight formatting
nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.4 1996/09/11 07:27:04 downsj Exp $	*/
d51 2
a52 2
	bus_chipset_tag_t sc_bc;
	bus_io_handle_t sc_ioh;
@


1.4
log
@Rearrange much of the polling code so really, really *busted* NEC hardware
mostly works, along with various other bits of cleanup.

Please, people, if you have any choice in the matter at all, avoid NEC
IDE CD-ROM drives like the plague upon mankind they are.  Especially DO
NOT connect a NEC and another brand ATAPI drive to the same controller!
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.3 1996/08/07 01:53:03 downsj Exp $	*/
d88 1
a88 1
#define OPEN		6		/* done with open */
@


1.3
log
@bus.h using wd/wdc drivers, by niklas.  IDE now works on both i386 and amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: wdlink.h,v 1.2 1996/06/09 08:59:57 downsj Exp $	*/
d63 1
@


1.2
log
@acd.c: Removed some pointless code, cleaned up some more debug statements.
everything: added RCS ids.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d37 1
a37 2

#undef WDDEBUG
d51 2
a52 1
	int sc_iobase;			/* I/O port base */
d137 2
@


1.1
log
@Initial support ATAPI CD-ROMs.

Based on Manuel Bouyer's drivers.
@
text
@d1 1
a1 1
/*	$NetBSD: $	*/
@
