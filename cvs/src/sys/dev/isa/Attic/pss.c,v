head	1.26;
access;
symbols
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.20
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.18
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.16
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.14
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.12
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.10
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.20.0.6
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.4
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.2
	OPENBSD_2_8:1.19.0.8
	OPENBSD_2_8_BASE:1.19
	OPENBSD_2_7:1.19.0.6
	OPENBSD_2_7_BASE:1.19
	SMP:1.19.0.4
	SMP_BASE:1.19
	kame_19991208:1.19
	OPENBSD_2_6:1.19.0.2
	OPENBSD_2_6_BASE:1.19
	OPENBSD_2_5:1.18.0.2
	OPENBSD_2_5_BASE:1.18
	OPENBSD_2_4:1.15.0.2
	OPENBSD_2_4_BASE:1.15
	OPENBSD_2_3:1.12.0.4
	OPENBSD_2_3_BASE:1.12
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.10.0.4
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.10.0.2
	OPENBSD_2_0_BASE:1.10
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2011.06.29.17.48.22;	author tedu;	state dead;
branches;
next	1.25;

1.25
date	2011.06.29.12.17.40;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.30.11.21.35;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2001.02.03.05.26.47;	author mickey;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	99.07.30.17.12.56;	author deraadt;	state Exp;
branches
	1.19.4.1;
next	1.18;

1.18
date	99.01.07.06.14.49;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	99.01.02.00.02.46;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	98.11.03.21.15.01;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	98.05.13.10.25.07;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	98.05.08.18.37.22;	author csapuntz;	state Exp;
branches;
next	1.13;

1.13
date	98.04.26.21.02.55;	author provos;	state Exp;
branches;
next	1.12;

1.12
date	97.07.12.01.42.08;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	97.07.10.23.06.36;	author provos;	state Exp;
branches;
next	1.10;

1.10
date	96.05.26.00.27.27;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.07.37.33;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.24.26;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.01.00.59;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.10.29;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.16.43.11;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.36.04;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.33;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.09;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches;
next	;

1.19.4.1
date	2001.05.14.22.24.50;	author niklas;	state Exp;
branches;
next	1.19.4.2;

1.19.4.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.19.4.3;

1.19.4.3
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	;

1.20.6.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2003.05.19.22.08.46;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@dmesg@@ says pss has never been seen in the wild and the manpage says it
doesn't work.  goodbye.  ok miod
@
text
@/*	$OpenBSD: pss.c,v 1.25 2011/06/29 12:17:40 tedu Exp $ */
/*	$NetBSD: pss.c,v 1.38 1998/01/12 09:43:44 thorpej Exp $	*/

/*
 * Copyright (c) 1994 John Brezak
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * Copyright (c) 1993 Analog Devices Inc. All rights reserved
 *
 * Portions provided by Marc.Hoffman@@analog.com and
 * Greg.Yukna@@analog.com .
 *
 */

/*
 * Todo:
 *	- Provide PSS driver to access DSP
 *	- Provide MIDI driver to access MPU
 *	- Finish support for CD drive (Sony and SCSI)
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/proc.h>
#include <sys/buf.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/isa/ad1848var.h>
#include <dev/isa/wssreg.h>
#include <dev/isa/pssreg.h>

/* XXX Default WSS base */
#define WSS_BASE_ADDRESS 0x0530

/*
 * Mixer devices
 */
#define PSS_MIC_IN_LVL		0
#define PSS_LINE_IN_LVL		1
#define PSS_DAC_LVL		2
#define PSS_REC_LVL		3
#define PSS_MON_LVL		4
#define PSS_MASTER_VOL		5
#define PSS_MASTER_TREBLE	6
#define PSS_MASTER_BASS		7
#define PSS_MIC_IN_MUTE		8
#define PSS_LINE_IN_MUTE	9
#define PSS_DAC_MUTE		10

#define PSS_OUTPUT_MODE		11
#define 	PSS_SPKR_MONO	0
#define 	PSS_SPKR_STEREO	1
#define 	PSS_SPKR_PSEUDO	2
#define 	PSS_SPKR_SPATIAL 3

#define PSS_RECORD_SOURCE	12

/* Classes */
#define PSS_INPUT_CLASS		13
#define PSS_RECORD_CLASS	14
#define PSS_MONITOR_CLASS	15
#define PSS_OUTPUT_CLASS	16


struct pss_softc {
	struct	device sc_dev;		/* base device */
	void	*sc_ih;			/* interrupt vectoring */

	int	sc_iobase;		/* I/O port base address */
	int	sc_drq;			/* dma channel */

	struct	ad1848_softc *ad1848_sc;

	int	out_port;

	struct	ad1848_volume master_volume;
	int	master_mode;

	int	monitor_treble;
	int	monitor_bass;

	int	mic_mute, cd_mute, dac_mute;
};

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (pssdebug) printf x
int	pssdebug = 0;
#else
#define DPRINTF(x)
#endif

int	pssprobe(struct device *, void *, void *);
void	pssattach(struct device *, struct device *, void *);

int	spprobe(struct device *, void *, void *);
void	spattach(struct device *, struct device *, void *);

int	pssintr(void *);

int	pss_speaker_ctl(void *, int);

int	pss_getdev(void *, struct audio_device *);

int	pss_mixer_set_port(void *, mixer_ctrl_t *);
int	pss_mixer_get_port(void *, mixer_ctrl_t *);
int	pss_query_devinfo(void *, mixer_devinfo_t *);

#ifdef PSS_DSP
void	pss_dspwrite(struct pss_softc *, int);
#endif
void	pss_setaddr(int, int);
int	pss_setint(int, int);
int	pss_setdma(int, int);
int	pss_testirq(struct pss_softc *, int);
int	pss_testdma(struct pss_softc *, int);
#ifdef AUDIO_DEBUG
void	pss_dump_regs(struct pss_softc *);
#endif
int	pss_set_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_set_master_mode(struct pss_softc *, int);
int	pss_set_treble(struct pss_softc *, u_int);
int	pss_set_bass(struct pss_softc *, u_int);
int	pss_get_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_get_master_mode(struct pss_softc *, u_int *);
int	pss_get_treble(struct pss_softc *, u_char *);
int	pss_get_bass(struct pss_softc *, u_char *);

#ifdef AUDIO_DEBUG
void	wss_dump_regs(struct ad1848_softc *);
#endif

/*
 * Define our interface to the higher level audio driver.
 */

struct audio_hw_if pss_audio_if = {
	ad1848_open,
	ad1848_close,
	NULL,
	ad1848_query_encoding,
	ad1848_set_params,
	ad1848_round_blocksize,
	ad1848_commit_settings,
	NULL,
	NULL,
	NULL,
	NULL,
	ad1848_halt_output,
	ad1848_halt_input,
	pss_speaker_ctl,
	pss_getdev,
	NULL,
	pss_mixer_set_port,
	pss_mixer_get_port,
	pss_query_devinfo,
	ad1848_malloc,
	ad1848_free,
	ad1848_round,
	ad1848_mappage,
	ad1848_get_props,
	ad1848_trigger_output,
	ad1848_trigger_input,
	NULL
};


/* Interrupt translation for WSS config */
static u_char wss_interrupt_bits[16] = {
    0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0x08,
    0xff, 0x10, 0x18, 0x20,
    0xff, 0xff, 0xff, 0xff
};
/* ditto for WSS DMA channel */
static u_char wss_dma_bits[4] = {1, 2, 0, 3};

struct cfattach pss_ca = {
	sizeof(struct pss_softc), pssprobe, pssattach
};

struct cfdriver pss_cd = {
	NULL, "pss", DV_DULL, 1
};

struct cfattach sp_ca = {
	sizeof(struct ad1848_softc), spprobe, spattach
};

struct cfdriver sp_cd = {
	NULL, "sp", DV_DULL
};

struct audio_device pss_device = {
	"pss,ad1848",
	"",
	"PSS"
};

#ifdef PSS_DSP
void
pss_dspwrite(sc, data)
	struct pss_softc *sc;
	int data;
{
    int i;
    int pss_base = sc->sc_iobase;

    /*
     * Note! the i<5000000 is an emergency exit. The dsp_command() is sometimes
     * called while interrupts are disabled. This means that the timer is
     * disabled also. However the timeout situation is a abnormal condition.
     * Normally the DSP should be ready to accept commands after just couple of
     * loops.
     */
    for (i = 0; i < 5000000; i++) {
	if (inw(pss_base+PSS_STATUS) & PSS_WRITE_EMPTY) {
	    outw(pss_base+PSS_DATA, data);
	    return;
	}
    }
    printf ("pss: DSP Command (%04x) Timeout.\n", data);
}
#endif /* PSS_DSP */

void
pss_setaddr(addr, configAddr)
	int addr;
	int configAddr;
{
    int val;

    val = inw(configAddr);
    val &= ADDR_MASK;
    val |= (addr << 4);
    outw(configAddr,val);
}

/* pss_setint
 * This function sets the correct bits in the
 * configuration register to
 * enable the chosen interrupt.
 */
int
pss_setint(intNum, configAddress)
	int intNum;
	int configAddress;
{
    int val;

    switch(intNum) {
    case 3:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_3_BITS;
	break;
    case 5:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_5_BITS;
	break;
    case 7:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_7_BITS;
	break;
    case 9:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_9_BITS;
	break;
    case 10:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_10_BITS;
	break;
    case 11:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_11_BITS;
	break;
    case 12:
	val = inw(configAddress);
	val &= INT_MASK;
	val |= INT_12_BITS;
	break;
    default:
	DPRINTF(("pss_setint: invalid irq (%d)\n", intNum));
	return 1;
    }
    outw(configAddress,val);
    return 0;
}

int
pss_setdma(dmaNum, configAddress)
	int dmaNum;
	int configAddress;
{
    int val;

    switch(dmaNum) {
    case 0:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_0_BITS;
	break;
    case 1:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_1_BITS;
	break;
    case 3:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_3_BITS;
	break;
    case 5:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_5_BITS;
	break;
    case 6:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_6_BITS;
	break;
    case 7:
	val = inw(configAddress);
	val &= DMA_MASK;
	val |= DMA_7_BITS;
	break;
    default:
	DPRINTF(("pss_setdma: invalid drq (%d)\n", dmaNum));
	return 1;
    }
    outw(configAddress, val);
    return 0;
}

/*
 * This function tests an interrupt number to see if
 * it is available. It takes the interrupt button
 * as its argument and returns TRUE if the interrupt
 * is ok.
*/
int
pss_testirq(struct pss_softc *sc, int intNum)
{
    int config = sc->sc_iobase + PSS_CONFIG;
    int val;
    int ret;
    int i;

    /* Set the interrupt bits */
    switch(intNum) {
    case 3:
	val = inw(config);
	val &= INT_MASK;	/* Special: 0 */
	break;
    case 5:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_5_BITS;
	break;
    case 7:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_7_BITS;
	break;
    case 9:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_9_BITS;
	break;
    case 10:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_10_BITS;
	break;
    case 11:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_11_BITS;
	break;
    case 12:
	val = inw(config);
	val &= INT_MASK;
	val |= INT_TEST_BIT | INT_12_BITS;
	break;
    default:
	DPRINTF(("pss_testirq: invalid irq (%d)\n", intNum));
	return 0;
    }
    outw(config, val);

    /* Check if the interrupt is in use */
    /* Do it a few times in case there is a delay */
    ret = 0;
    for (i = 0; i < 5; i++) {
	val = inw(config);
	if (val & INT_TEST_PASS) {
	    ret = 1;
	    break;
	}
    }

    /* Clear the Test bit and the interrupt bits */
    val = inw(config);
    val &= INT_TEST_BIT_MASK & INT_MASK;
    outw(config, val);
    return(ret);
}

/*
 * This function tests a dma channel to see if
 * it is available. It takes the DMA channel button
 * as its argument and returns TRUE if the channel
 * is ok.
 */
int
pss_testdma(sc, dmaNum)
	struct pss_softc *sc;
	int dmaNum;
{
    int config = sc->sc_iobase + PSS_CONFIG;
    int val;
    int i, ret;

    switch (dmaNum) {
    case 0:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_0_BITS;
	break;
    case 1:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_1_BITS;
	break;
    case 3:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_3_BITS;
	break;
    case 5:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_5_BITS;
	break;
    case 6:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_6_BITS;
	break;
    case 7:
	val = inw(config);
	val &= DMA_MASK;
	val |= DMA_TEST_BIT | DMA_7_BITS;
	break;
    default:
	DPRINTF(("pss_testdma: invalid drq (%d)\n", dmaNum));
	return 0;
    }
    outw(config, val);

    /* Check if the DMA channel is in use */
    /* Do it a few times in case there is a delay */
    ret = 0;
    for (i = 0; i < 3; i++) {
	val = inw(config);
	if (val & DMA_TEST_PASS) {
	    ret = 1;
	    break;
	}
    }

    /* Clear the Test bit and the DMA bits */
    val = inw(config);
    val &= DMA_TEST_BIT_MASK & DMA_MASK;
    outw(config, val);
    return(ret);
}

#ifdef AUDIO_DEBUG
void
wss_dump_regs(sc)
	struct ad1848_softc *sc;
{

    printf("WSS reg: status=%02x\n",
	   (u_char)inb(sc->sc_iobase-WSS_CODEC+WSS_STATUS));
}

void
pss_dump_regs(sc)
	struct pss_softc *sc;
{

    printf("PSS regs: status=%04x vers=%04x ",
	   (u_short)inw(sc->sc_iobase+PSS_STATUS),
	   (u_short)inw(sc->sc_iobase+PSS_ID_VERS));

    printf("config=%04x wss_config=%04x\n",
	   (u_short)inw(sc->sc_iobase+PSS_CONFIG),
	   (u_short)inw(sc->sc_iobase+PSS_WSS_CONFIG));
}
#endif

/*
 * Probe for the PSS hardware.
 */
int
pssprobe(parent, self, aux)
    struct device *parent;
    void *self;
    void *aux;
{
    struct pss_softc *sc = self;
    struct isa_attach_args *ia = aux;
    int iobase = ia->ia_iobase;

    if (!PSS_BASE_VALID(iobase)) {
	DPRINTF(("pss: configured iobase %x invalid\n", iobase));
	return 0;
    }

    /* Need to probe for iobase when IOBASEUNK {0x220 0x240} */
    if (iobase == IOBASEUNK) {

	iobase = 0x220;
	if ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)
	    goto pss_found;

	iobase = 0x240;
	if ((inw(iobase+PSS_ID_VERS) & 0xff00) == 0x4500)
	    goto pss_found;

	DPRINTF(("pss: no PSS found (at 0x220 or 0x240)\n"));
	return 0;
    }
    else if ((inw(iobase+PSS_ID_VERS) & 0xff00) != 0x4500) {
	DPRINTF(("pss: not a PSS - %x\n", inw(iobase+PSS_ID_VERS)));
	return 0;
    }

pss_found:
    sc->sc_iobase = iobase;

    /* Clear WSS config */
    pss_setaddr(WSS_BASE_ADDRESS, sc->sc_iobase+PSS_WSS_CONFIG); /* XXX! */
    outb(WSS_BASE_ADDRESS+WSS_CONFIG, 0);

    /* Clear config registers (POR reset state) */
    outw(sc->sc_iobase+PSS_CONFIG, 0);
    outw(sc->sc_iobase+PSS_WSS_CONFIG, 0);
    outw(sc->sc_iobase+SB_CONFIG, 0);
    outw(sc->sc_iobase+MIDI_CONFIG, 0);
    outw(sc->sc_iobase+CD_CONFIG, 0);

    if (ia->ia_irq == IRQUNK) {
	int i;
	for (i = 0; i < 16; i++) {
	    if (pss_testirq(sc, i) != 0)
		break;
	}
	if (i == 16) {
	    DPRINTF(("pss: unable to locate free IRQ channel\n"));
	    return 0;
	}
	else {
	    ia->ia_irq = i;
	    DPRINTF(("pss: found IRQ %d free\n", i));
	}
    }
    else {
	if (pss_testirq(sc, ia->ia_irq) == 0) {
	    DPRINTF(("pss: configured IRQ unavailable (%d)\n", ia->ia_irq));
	    return 0;
	}
    }

    /* XXX Need to deal with DRQUNK */
    if (pss_testdma(sc, ia->ia_drq) == 0) {
	DPRINTF(("pss: configured DMA channel unavailable (%d)\n", ia->ia_drq));
	return 0;
    }

    ia->ia_iosize = PSS_NPORT;

    /* Initialize PSS irq and dma */
    pss_setint(ia->ia_irq, sc->sc_iobase+PSS_CONFIG);
    pss_setdma(sc->sc_drq, sc->sc_iobase+PSS_CONFIG);

    return 1;
}

/*
 * Probe for the Soundport (ad1848)
 */
int
spprobe(parent, match, aux)
    struct device *parent;
    void *match, *aux;
{
    struct ad1848_softc *sc = match;
    struct pss_softc *pc = (void *) parent;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;
    struct isa_attach_args *ia = aux;
    u_char bits;
    int i;

    sc->sc_iot = ia->ia_iot;
    sc->sc_iobase = cf->cf_iobase + WSS_CODEC;

    /* Set WSS io address */
    pss_setaddr(cf->cf_iobase, pc->sc_iobase+PSS_WSS_CONFIG);

    /* Is there an ad1848 chip at the WSS iobase ? */
    if (ad1848_probe(sc) == 0) {
	DPRINTF(("sp: no ad1848 ? iobase=%x\n", sc->sc_iobase));
	return 0;
    }

    /* Setup WSS interrupt and DMA if auto */
    if (cf->cf_irq == IRQUNK) {

	/* Find unused IRQ for WSS */
	for (i = 0; i < 12; i++) {
	    if (wss_interrupt_bits[i] != 0xff) {
		if (pss_testirq(pc, i))
		    break;
	    }
	}
	if (i == 12) {
	    DPRINTF(("sp: unable to locate free IRQ for WSS\n"));
	    return 0;
	}
	else {
	    cf->cf_irq = i;
	    sc->sc_irq = i;
	    DPRINTF(("sp: found IRQ %d free\n", i));
	}
    }
    else {
	sc->sc_irq = cf->cf_irq;
	if (pss_testirq(pc, sc->sc_irq) == 0) {
	    DPRINTF(("sp: configured IRQ unavailable (%d)\n", sc->sc_irq));
	    return 0;
	}
    }

    if (cf->cf_drq == DRQUNK) {
	/* Find unused DMA channel for WSS */
	for (i = 0; i < 4; i++) {
	    if (wss_dma_bits[i]) {
		if (pss_testdma(pc, i))
		    break;
	    }
	}
	if (i == 4) {
	    DPRINTF(("sp: unable to locate free DMA channel for WSS\n"));
	    return 0;
	}
	else {
	    sc->sc_drq = cf->cf_drq = i;
	    DPRINTF(("sp: found DMA %d free\n", i));
	}
    }
    else {
	if (pss_testdma(pc, sc->sc_drq) == 0) {
	    DPRINTF(("sp: configured DMA channel unavailable (%d)\n", sc->sc_drq));
	    return 0;
	}
	sc->sc_drq = cf->cf_drq;
    }
    sc->sc_recdrq = sc->sc_drq;

    /* Set WSS config registers */
    if ((bits = wss_interrupt_bits[sc->sc_irq]) == 0xff) {
	DPRINTF(("sp: invalid interrupt configuration (irq=%d)\n", sc->sc_irq));
	return 0;
    }

    outb(sc->sc_iobase+WSS_CONFIG, (bits | 0x40));
    if ((inb(sc->sc_iobase+WSS_STATUS) & 0x40) == 0)	/* XXX What do these bits mean ? */
	DPRINTF(("sp: IRQ %x\n", inb(sc->sc_iobase+WSS_STATUS)));

    outb(sc->sc_iobase+WSS_CONFIG, (bits | wss_dma_bits[sc->sc_drq]));

    pc->ad1848_sc = sc;
    sc->parent = pc;

    return 1;
}

/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver .
 */
void
pssattach(parent, self, aux)
    struct device *parent, *self;
    void *aux;
{
    struct pss_softc *sc = (struct pss_softc *)self;
    struct isa_attach_args *ia = (struct isa_attach_args *)aux;
    int iobase = ia->ia_iobase;
    u_char vers;
    struct ad1848_volume vol = {150, 150};

    sc->sc_iobase = iobase;
    sc->sc_drq = ia->ia_drq;

    /* Setup interrupt handler for PSS */
    sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, IPL_AUDIO,
	pssintr, sc, sc->sc_dev.dv_xname);

    vers = (inw(sc->sc_iobase+PSS_ID_VERS)&0xff) - 1;
    printf(": ESC614%c\n", (vers > 0)?'A'+vers:' ');

    (void)config_found(self, ia->ia_ic, NULL);		/* XXX */

    sc->out_port = PSS_MASTER_VOL;

    (void)pss_set_master_mode(sc, PSS_SPKR_STEREO);
    (void)pss_set_master_gain(sc, &vol);
    (void)pss_set_treble(sc, AUDIO_MAX_GAIN/2);
    (void)pss_set_bass(sc, AUDIO_MAX_GAIN/2);

    audio_attach_mi(&pss_audio_if, sc->ad1848_sc, &sc->ad1848_sc->sc_dev);
}

void
spattach(parent, self, aux)
    struct device *parent, *self;
    void *aux;
{
    struct ad1848_softc *sc = (struct ad1848_softc *)self;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;
    isa_chipset_tag_t ic = aux;				/* XXX */
    int iobase = cf->cf_iobase;

    sc->sc_iobase = iobase;
    sc->sc_drq = cf->cf_drq;

    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,
	ad1848_intr, sc, sc->sc_dev.dv_xname);

    sc->sc_isa = parent->dv_parent;

    ad1848_attach(sc);

    printf("\n");
}

int
pss_set_master_gain(sc, gp)
    struct pss_softc *sc;
    struct ad1848_volume *gp;
{
    DPRINTF(("pss_set_master_gain: %d:%d\n", gp->left, gp->right));

#ifdef PSS_DSP
    if (gp->left > PHILLIPS_VOL_MAX)
	gp->left = PHILLIPS_VOL_MAX;
    if (gp->left < PHILLIPS_VOL_MIN)
	gp->left = PHILLIPS_VOL_MIN;
    if (gp->right > PHILLIPS_VOL_MAX)
	gp->right = PHILLIPS_VOL_MAX;
    if (gp->right < PHILLIPS_VOL_MIN)
	gp->right = PHILLIPS_VOL_MIN;

    pss_dspwrite(sc, SET_MASTER_COMMAND);
    pss_dspwrite(sc, MASTER_VOLUME_LEFT|(PHILLIPS_VOL_CONSTANT + gp->left / PHILLIPS_VOL_STEP));
    pss_dspwrite(sc, SET_MASTER_COMMAND);
    pss_dspwrite(sc, MASTER_VOLUME_RIGHT|(PHILLIPS_VOL_CONSTANT + gp->right / PHILLIPS_VOL_STEP));
#endif

    sc->master_volume = *gp;
    return(0);
}

int
pss_set_master_mode(sc, mode)
    struct pss_softc *sc;
    int mode;
{
    short phillips_mode;

    DPRINTF(("pss_set_master_mode: %d\n", mode));

    if (mode == PSS_SPKR_STEREO)
	phillips_mode = PSS_STEREO;
    else if (mode == PSS_SPKR_PSEUDO)
	phillips_mode = PSS_PSEUDO;
    else if (mode == PSS_SPKR_SPATIAL)
	phillips_mode = PSS_SPATIAL;
    else if (mode == PSS_SPKR_MONO)
	phillips_mode = PSS_MONO;
    else
	return (EINVAL);

#ifdef PSS_DSP
    pss_dspwrite(sc, SET_MASTER_COMMAND);
    pss_dspwrite(sc, MASTER_SWITCH | mode);
#endif

    sc->master_mode = mode;

    return(0);
}

int
pss_set_treble(sc, treb)
    struct pss_softc *sc;
    u_int treb;
{
    DPRINTF(("pss_set_treble: %d\n", treb));

#ifdef PSS_DSP
    if (treb > PHILLIPS_TREBLE_MAX)
	treb = PHILLIPS_TREBLE_MAX;
    if (treb < PHILLIPS_TREBLE_MIN)
	treb = PHILLIPS_TREBLE_MIN;
    pss_dspwrite(sc, SET_MASTER_COMMAND);
    pss_dspwrite(sc, MASTER_TREBLE|(PHILLIPS_TREBLE_CONSTANT + treb / PHILLIPS_TREBLE_STEP));
#endif

    sc->monitor_treble = treb;

    return(0);
}

int
pss_set_bass(sc, bass)
    struct pss_softc *sc;
    u_int bass;
{
    DPRINTF(("pss_set_bass: %d\n", bass));

#ifdef PSS_DSP
    if (bass > PHILLIPS_BASS_MAX)
	bass = PHILLIPS_BASS_MAX;
    if (bass < PHILLIPS_BASS_MIN)
	bass = PHILLIPS_BASS_MIN;
    pss_dspwrite(sc, SET_MASTER_COMMAND);
    pss_dspwrite(sc, MASTER_BASS|(PHILLIPS_BASS_CONSTANT + bass / PHILLIPS_BASS_STEP));
#endif

    sc->monitor_bass = bass;

    return(0);
}

int
pss_get_master_gain(sc, gp)
    struct pss_softc *sc;
    struct ad1848_volume *gp;
{
    *gp = sc->master_volume;
    return(0);
}

int
pss_get_master_mode(sc, mode)
    struct pss_softc *sc;
    u_int *mode;
{
    *mode = sc->master_mode;
    return(0);
}

int
pss_get_treble(sc, tp)
    struct pss_softc *sc;
    u_char *tp;
{
    *tp = sc->monitor_treble;
    return(0);
}

int
pss_get_bass(sc, bp)
    struct pss_softc *sc;
    u_char *bp;
{
    *bp = sc->monitor_bass;
    return(0);
}

int
pss_speaker_ctl(addr, newstate)
    void *addr;
    int newstate;
{
    return(0);
}

int
pssintr(arg)
	void *arg;
{
    struct pss_softc *sc = arg;
    u_short sr;

    sr = inw(sc->sc_iobase+PSS_STATUS);

    DPRINTF(("pssintr: sc=%p st=%x\n", sc, sr));

    /* Acknowledge intr */
    outw(sc->sc_iobase+PSS_IRQ_ACK, 0);

    /* Is it one of ours ? */
    if (sr & (PSS_WRITE_EMPTY|PSS_READ_FULL|PSS_IRQ|PSS_DMQ_TC)) {
	/* XXX do something */
	return 1;
    }

    return 0;
}

int
pss_getdev(addr, retp)
    void *addr;
    struct audio_device *retp;
{
    DPRINTF(("pss_getdev: retp=%p\n", retp));

    *retp = pss_device;
    return 0;
}

static ad1848_devmap_t mappings[] = {
{ PSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },
{ PSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },
{ PSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },
{ PSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },
{ PSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },
{ PSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },
{ PSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },
{ PSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },
{ PSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}
};

static int nummap = sizeof(mappings) / sizeof(mappings[0]);

int
pss_mixer_set_port(addr, cp)
    void *addr;
    mixer_ctrl_t *cp;
{
    struct ad1848_softc *ac = addr;
    struct pss_softc *sc = ac->parent;
    struct ad1848_volume vol;
    int error = ad1848_mixer_set_port(ac, mappings, nummap, cp);

    if (error != ENXIO)
      return (error);

    switch (cp->dev) {
    case PSS_MASTER_VOL:	/* master volume */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (ad1848_to_vol(cp, &vol))
		error = pss_set_master_gain(sc, &vol);
	}
	break;

    case PSS_OUTPUT_MODE:
	if (cp->type == AUDIO_MIXER_ENUM)
	    error = pss_set_master_mode(sc, cp->un.ord);
	break;

    case PSS_MASTER_TREBLE:	/* master treble */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)
	    error = pss_set_treble(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
	break;

    case PSS_MASTER_BASS:	/* master bass */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1)
	    error = pss_set_bass(sc, (u_char)cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
	break;

    default:
	    return ENXIO;
	    /*NOTREACHED*/
    }

    return 0;
}

int
pss_mixer_get_port(addr, cp)
    void *addr;
    mixer_ctrl_t *cp;
{
    struct ad1848_softc *ac = addr;
    struct pss_softc *sc = ac->parent;
    struct ad1848_volume vol;
    u_char eq;
    int error = ad1848_mixer_get_port(ac, mappings, nummap, cp);

    if (error != ENXIO)
      return (error);

    error = EINVAL;

    switch (cp->dev) {
    case PSS_MASTER_VOL:	/* master volume */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = pss_get_master_gain(sc, &vol);
	    if (!error)
		ad1848_from_vol(cp, &vol);
	}
	break;

    case PSS_MASTER_TREBLE:	/* master treble */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    error = pss_get_treble(sc, &eq);
	    if (!error)
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;
	}
	break;

    case PSS_MASTER_BASS:	/* master bass */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    error = pss_get_bass(sc, &eq);
	    if (!error)
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = eq;
	}
	break;

    case PSS_OUTPUT_MODE:
	if (cp->type == AUDIO_MIXER_ENUM)
	    error = pss_get_master_mode(sc, &cp->un.ord);
	break;

    default:
	error = ENXIO;
	break;
    }

    return(error);
}

int
pss_query_devinfo(addr, dip)
    void *addr;
    mixer_devinfo_t *dip;
{
    DPRINTF(("pss_query_devinfo: index=%d\n", dip->index));

    switch(dip->index) {
    case PSS_MIC_IN_LVL:	/* Microphone */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = PSS_MIC_IN_MUTE;
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_LINE_IN_LVL:	/* line/CD */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = PSS_LINE_IN_MUTE;
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_DAC_LVL:		/*  dacout */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = PSS_DAC_MUTE;
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_REC_LVL:	/* record level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_RECORD_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = PSS_RECORD_SOURCE;
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_MON_LVL:	/* monitor level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_MONITOR_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_MASTER_VOL:	/* master volume */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_OUTPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = PSS_OUTPUT_MODE;
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_MASTER_TREBLE:	/* master treble */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_OUTPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNtreble,
	    sizeof dip->un.v.units.name);
	break;

    case PSS_MASTER_BASS:	/* master bass */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = PSS_OUTPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
	break;

    case PSS_OUTPUT_CLASS:			/* output class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = PSS_OUTPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
	break;

    case PSS_INPUT_CLASS:			/* input class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
	break;

    case PSS_MONITOR_CLASS:			/* monitor class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = PSS_MONITOR_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
	break;

    case PSS_RECORD_CLASS:			/* record source class */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = PSS_RECORD_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
	break;

    case PSS_MIC_IN_MUTE:
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = PSS_MIC_IN_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case PSS_LINE_IN_MUTE:
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = PSS_LINE_IN_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case PSS_DAC_MUTE:
	dip->mixer_class = PSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = PSS_DAC_LVL;
	dip->next = AUDIO_MIXER_LAST;
    mute:
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
	dip->un.e.num_mem = 2;
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = 0;
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = 1;
	break;

    case PSS_OUTPUT_MODE:
	dip->mixer_class = PSS_OUTPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = PSS_MASTER_VOL;
	dip->next = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
	dip->un.e.num_mem = 4;
	strlcpy(dip->un.e.member[0].label.name, AudioNmono,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = PSS_SPKR_MONO;
	strlcpy(dip->un.e.member[1].label.name, AudioNstereo,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = PSS_SPKR_STEREO;
	strlcpy(dip->un.e.member[2].label.name, AudioNpseudo,
	    sizeof dip->un.e.member[2].label.name);
	dip->un.e.member[2].ord = PSS_SPKR_PSEUDO;
	strlcpy(dip->un.e.member[3].label.name, AudioNspatial,
	    sizeof dip->un.e.member[3].label.name);
	dip->un.e.member[3].ord = PSS_SPKR_SPATIAL;
	break;

    case PSS_RECORD_SOURCE:
	dip->mixer_class = PSS_RECORD_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = PSS_REC_LVL;
	dip->next = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
	dip->un.e.num_mem = 3;
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = PSS_MIC_IN_LVL;
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = PSS_LINE_IN_LVL;
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
	dip->un.e.member[2].ord = PSS_DAC_LVL;
	break;

    default:
	return ENXIO;
	/*NOTREACHED*/
    }
    DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));

    return 0;
}
@


1.25
log
@notyet, notever.  delete a bunch of code we won't be using.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.24 2010/06/30 11:21:35 jakemsr Exp $ */
@


1.24
log
@* use audio(9)'s DMA trigger methods instead of the init/start
  methods.  the AD1848 DMA engine runs continuously and doesn't
  need to be started/stopped or otherwise manipulated for each
  block.  makes the driver a bit more efficient.
* allow "Mode 2" capable chips such as the CS4231 to work in "Mode 1"
  when there is only one DMA channel, instead of forcing it into
  "Mode 2", which expects two DMA channels.  allows recording to
  work for "Mode 2" capable devices when there is only one DMA
  channel.
* service both playback and recording interrupts in full-duplex
  mode, instead of only playback interrupts.  allows "Mode 2"
  capable chips to work in full-duplex mode.
* fix checks for sample rate/format recalibration completion.  gets
  rid of busy loops that briefly "hang" the kernel when the device is
  opened and/or reconfigured.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.23 2008/04/21 00:32:42 jakemsr Exp $ */
a129 18
#ifdef notyet
struct mpu_softc {
	struct	device sc_dev;		/* base device */
	void	*sc_ih;			/* interrupt vectoring */

	int	sc_iobase;		/* MIDI I/O port base address */
	int	sc_irq;			/* MIDI interrupt */
};

struct pcd_softc {
	struct	device sc_dev;		/* base device */
	void	*sc_ih;			/* interrupt vectoring */

	int	sc_iobase;		/* CD I/O port base address */
	int	sc_irq;			/* CD interrupt */
};
#endif

a142 8
#ifdef notyet
int	mpuprobe(struct device *, void *, void *);
void	mpuattach(struct device *, struct device *, void *);

int	pcdprobe(struct device *, void *, void *);
void	pcdattach(struct device *, struct device *, void *);
#endif

a143 3
#ifdef notyet
int	mpuintr(void *);
#endif
a160 4
#ifdef notyet
int	pss_reset_dsp(struct pss_softc *);
int	pss_download_dsp(struct pss_softc *, u_char *, int);
#endif
a237 18
#ifdef notyet
struct cfattach mpu_ca = {
	sizeof(struct mpu_softc), mpuprobe, mpuattach
};

struct cfdriver mpu_cd = {
	NULL, "mpu", DV_DULL
};

struct cfattach pcd_ca = {
	sizeof(struct pcd_softc), pcdprobe, pcdattach
};

struct cfdriver pcd_cd = {
	NULL, "pcd", DV_DULL
};
#endif

a528 103
#ifdef notyet
int
pss_reset_dsp(sc)
	struct pss_softc *sc;
{
    u_long i;
    int pss_base = sc->sc_iobase;

    outw(pss_base+PSS_CONTROL, PSS_RESET);

    for (i = 0; i < 32768; i++)
	inw(pss_base+PSS_CONTROL);

    outw(pss_base+PSS_CONTROL, 0);

    return 1;
}

/*
 * This function loads an image into the PSS
 * card.  The function loads the file by
 * resetting the dsp and feeding it the boot bytes.
 * First you feed the ASIC the first byte of
 * the boot sequence. The ASIC waits until it
 * detects a BMS and RD and asserts BR
 * and outputs the byte.  The host must poll for
 * the BG signal. It then feeds the ASIC another
 * byte which removes BR.
 */
int
pss_download_dsp(sc, block, size)
	struct pss_softc *sc;
	u_char *block;
	int size;
{
    int i, val, count;
    int pss_base = sc->sc_iobase;

    DPRINTF(("pss: downloading boot code..."));

    /* Warn DSP software that a boot is coming */
    outw(pss_base+PSS_DATA, 0x00fe);

    for (i = 0; i < 32768; i++)
	if (inw(pss_base+PSS_DATA) == 0x5500)
	    break;
    outw(pss_base+PSS_DATA, *block++);

    pss_reset_dsp(sc);

    DPRINTF(("start "));

    count = 1;
    while(1) {
	int j;
	for (j=0; j<327670; j++) {
	    /* Wait for BG to appear */
	    if (inw(pss_base+PSS_STATUS) & PSS_FLAG3)
		break;
	}

	if (j==327670) {
	    /* It's ok we timed out when the file was empty */
	    if (count >= size)
		break;
	    else {
		printf("\npss: DownLoad timeout problems, byte %d=%d\n",
		       count, size);
		return 0;
	    }
	}
	/* Send the next byte */
	outw(pss_base+PSS_DATA, *block++);
	count++;
    }

    outw(pss_base+PSS_DATA, 0);
    for (i = 0; i < 32768; i++)
	(void) inw(pss_base+PSS_STATUS);

    DPRINTF(("downloaded\n"));

    for (i = 0; i < 32768; i++) {
	val = inw(pss_base+PSS_STATUS);
	if (val & PSS_READ_FULL)
	    break;
    }

    /* now read the version */
    for (i = 0; i < 32000; i++) {
	val = inw(pss_base+PSS_STATUS);
	if (val & PSS_READ_FULL)
	    break;
    }
    if (i == 32000)
	return 0;

    (void) inw(pss_base+PSS_DATA);

    return 1;
}
#endif /* notyet */

a638 13
#ifdef notyet
    /* Setup the Game port */
#ifdef PSS_GAMEPORT
    DPRINTF(("Turning Game Port On.\n"));
    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) | GAME_BIT);
#else
    outw(sc->sc_iobase+PSS_STATUS, inw(sc->sc_iobase+PSS_STATUS) & GAME_BIT_MASK);
#endif

    /* Reset DSP */
    pss_reset_dsp(sc);
#endif /* notyet */

a740 98
#ifdef notyet
int
mpuprobe(parent, match, aux)
    struct device *parent;
    void *match, *aux;
{
    struct mpu_softc *sc = match;
    struct pss_softc *pc = (void *) parent;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;

    /* Check if midi is enabled; if it is check the interrupt */
    sc->sc_iobase = cf->cf_iobase;

    if (cf->cf_irq == IRQUNK) {
	int i;
	for (i = 0; i < 16; i++) {
	    if (pss_testirq(pc, i) != 0)
		break;
	}
	if (i == 16) {
	    printf("mpu: unable to locate free IRQ channel for MIDI\n");
	    return 0;
	}
	else {
	    cf->cf_irq = i;
	    sc->sc_irq = i;
	    DPRINTF(("mpu: found IRQ %d free\n", i));
	}
    }
    else {
	sc->sc_irq = cf->cf_irq;

	if (pss_testirq(pc, sc->sc_irq) == 0) {
	    printf("pss: configured MIDI IRQ unavailable (%d)\n", sc->sc_irq);
	    return 0;
	}
    }

    outw(pc->sc_iobase+MIDI_CONFIG,0);
    DPRINTF(("pss: mpu port 0x%x irq %d\n", sc->sc_iobase, sc->sc_irq));
    pss_setaddr(sc->sc_iobase, pc->sc_iobase+MIDI_CONFIG);
    pss_setint(sc->sc_irq, pc->sc_iobase+MIDI_CONFIG);

    return 1;
}

int
pcdprobe(parent, match, aux)
    struct device *parent;
    void *match, *aux;
{
    struct pcd_softc *sc = match;
    struct pss_softc *pc = (void *) parent;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;
    u_short val;

    sc->sc_iobase = cf->cf_iobase;

    pss_setaddr(sc->sc_iobase, pc->sc_iobase+CD_CONFIG);

    /* Set the correct irq polarity. */
    val = inw(pc->sc_iobase+CD_CONFIG);
    outw(pc->sc_iobase+CD_CONFIG, 0);
    val &= CD_POL_MASK;
    val |= CD_POL_BIT;	/* XXX if (pol) */
    outw(pc->sc_iobase+CD_CONFIG, val);

    if (cf->cf_irq == IRQUNK) {
	int i;
	for (i = 0; i < 16; i++) {
	    if (pss_testirq(pc, i) != 0)
		break;
	}
	if (i == 16) {
	    printf("pcd: unable to locate free IRQ channel for CD\n");
	    return 0;
	}
	else {
	    cf->cf_irq = i;
	    sc->sc_irq = i;
	    DPRINTF(("pcd: found IRQ %d free\n", i));
	}
    }
    else {
	sc->sc_irq = cf->cf_irq;

	if (pss_testirq(pc, sc->sc_irq) == 0) {
	    printf("pcd: configured CD IRQ unavailable (%d)\n", sc->sc_irq);
	    return 0;
	}
	return 1;
    }
    pss_setint(sc->sc_irq, pc->sc_iobase+CD_CONFIG);

    return 1;
}
#endif /* notyet */

a800 44
#ifdef notyet
void
mpuattach(parent, self, aux)
    struct device *parent, *self;
    void *aux;
{
    struct mpu_softc *sc = (struct mpu_softc *)self;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;
    isa_chipset_tag_t ic = aux;				/* XXX */
    int iobase = cf->cf_iobase;

    sc->sc_iobase = iobase;

    sc->sc_ih = isa_intr_establish(ic, cf->cf_irq, IST_EDGE, IPL_AUDIO,
	mpuintr, sc, sc->sc_dev.dv_xname);

    /* XXX might use pssprint func ?? */
    printf(" port 0x%x/%d irq %d\n",
	   sc->sc_iobase, MIDI_NPORT, cf->cf_irq);
}

void
pcdattach(parent, self, aux)
    struct device *parent, *self;
    void *aux;
{
    struct pcd_softc *sc = (struct pcd_softc *)self;
    struct cfdata *cf = (void *)sc->sc_dev.dv_cfdata;
    int iobase = cf->cf_iobase;

    /*
     * The pss driver simply enables the cd interface. The CD
     * appropriate driver - scsi (aic6360) or Sony needs to be
     * used after this to handle the device.
     */
    sc->sc_iobase = iobase;

    /* XXX might use pssprint func ?? */
    printf(" port 0x%x/%d irq %d\n",
	   sc->sc_iobase, 2, cf->cf_irq);
}
#endif /* notyet */


a965 17

#ifdef notyet
int
mpuintr(arg)
	void *arg;
{
    struct mpu_softc *sc = arg;
    u_char sr;

    sr = inb(sc->sc_iobase+MIDI_STATUS_REG);

    printf("mpuintr: sc=%p sr=%x\n", sc, sr);

    /* XXX Need to clear intr */
    return 1;
}
#endif
@


1.23
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.22 2003/04/27 11:22:53 ho Exp $ */
d222 6
a227 6
	ad1848_dma_init_output,
	ad1848_dma_init_input,
	ad1848_dma_output,
	ad1848_dma_input,
	ad1848_halt_out_dma,
	ad1848_halt_in_dma,
d239 2
a240 2
	NULL,
	NULL,
@


1.22
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.21 2002/03/14 01:26:56 millert Exp $ */
d239 1
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.20 2001/02/03 05:26:47 mickey Exp $ */
d1428 1
a1428 1
	strcpy(dip->label.name, AudioNmicrophone);
d1430 2
a1431 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1439 1
a1439 1
	strcpy(dip->label.name, AudioNcd);
d1441 2
a1442 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1450 1
a1450 1
	strcpy(dip->label.name, AudioNdac);
d1452 2
a1453 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1461 1
a1461 1
	strcpy(dip->label.name, AudioNrecord);
d1463 2
a1464 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1471 1
a1471 1
	strcpy(dip->label.name, AudioNmonitor);
d1473 2
a1474 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1482 1
a1482 1
	strcpy(dip->label.name, AudioNmaster);
d1484 2
a1485 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d1492 1
a1492 1
	strcpy(dip->label.name, AudioNtreble);
d1494 2
a1495 1
	strcpy(dip->un.v.units.name, AudioNtreble);
d1502 1
a1502 1
	strcpy(dip->label.name, AudioNbass);
d1504 1
a1504 1
	strcpy(dip->un.v.units.name, AudioNbass);
d1511 1
a1511 1
	strcpy(dip->label.name, AudioCoutputs);
d1518 1
a1518 1
	strcpy(dip->label.name, AudioCinputs);
d1525 1
a1525 1
	strcpy(dip->label.name, AudioCmonitor);
d1532 1
a1532 1
	strcpy(dip->label.name, AudioCrecord);
d1555 1
a1555 1
	strcpy(dip->label.name, AudioNmute);
d1557 2
a1558 1
	strcpy(dip->un.e.member[0].label.name, AudioNoff);
d1560 2
a1561 1
	strcpy(dip->un.e.member[1].label.name, AudioNon);
d1570 1
a1570 1
	strcpy(dip->label.name, AudioNmode);
d1572 2
a1573 1
	strcpy(dip->un.e.member[0].label.name, AudioNmono);
d1575 2
a1576 1
	strcpy(dip->un.e.member[1].label.name, AudioNstereo);
d1578 2
a1579 1
	strcpy(dip->un.e.member[2].label.name, AudioNpseudo);
d1581 2
a1582 1
	strcpy(dip->un.e.member[3].label.name, AudioNspatial);
d1591 1
a1591 1
	strcpy(dip->label.name, AudioNsource);
d1593 2
a1594 1
	strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d1596 2
a1597 1
	strcpy(dip->un.e.member[1].label.name, AudioNcd);
d1599 2
a1600 1
	strcpy(dip->un.e.member[2].label.name, AudioNdac);
@


1.20
log
@no machine/pio.h is needed, space police
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.19 1999/07/30 17:12:56 deraadt Exp $ */
d155 2
a156 2
int	pssprobe __P((struct device *, void *, void *));
void	pssattach __P((struct device *, struct device *, void *));
d158 2
a159 2
int	spprobe __P((struct device *, void *, void *));
void	spattach __P((struct device *, struct device *, void *));
d162 2
a163 2
int	mpuprobe __P((struct device *, void *, void *));
void	mpuattach __P((struct device *, struct device *, void *));
d165 2
a166 2
int	pcdprobe __P((struct device *, void *, void *));
void	pcdattach __P((struct device *, struct device *, void *));
d169 1
a169 1
int	pssintr __P((void *));
d171 1
a171 1
int	mpuintr __P((void *));
d174 1
a174 1
int	pss_speaker_ctl __P((void *, int));
d176 1
a176 1
int	pss_getdev __P((void *, struct audio_device *));
d178 3
a180 3
int	pss_mixer_set_port __P((void *, mixer_ctrl_t *));
int	pss_mixer_get_port __P((void *, mixer_ctrl_t *));
int	pss_query_devinfo __P((void *, mixer_devinfo_t *));
d183 1
a183 1
void	pss_dspwrite __P((struct pss_softc *, int));
d185 5
a189 5
void	pss_setaddr __P((int, int));
int	pss_setint __P((int, int));
int	pss_setdma __P((int, int));
int	pss_testirq __P((struct pss_softc *, int));
int	pss_testdma __P((struct pss_softc *, int));
d191 2
a192 2
int	pss_reset_dsp __P((struct pss_softc *));
int	pss_download_dsp __P((struct pss_softc *, u_char *, int));
d195 1
a195 1
void	pss_dump_regs __P((struct pss_softc *));
d197 8
a204 8
int	pss_set_master_gain __P((struct pss_softc *, struct ad1848_volume *));
int	pss_set_master_mode __P((struct pss_softc *, int));
int	pss_set_treble __P((struct pss_softc *, u_int));
int	pss_set_bass __P((struct pss_softc *, u_int));
int	pss_get_master_gain __P((struct pss_softc *, struct ad1848_volume *));
int	pss_get_master_mode __P((struct pss_softc *, u_int *));
int	pss_get_treble __P((struct pss_softc *, u_char *));
int	pss_get_bass __P((struct pss_softc *, u_char *));
d207 1
a207 1
void	wss_dump_regs __P((struct ad1848_softc *));
@


1.20.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.20 2001/02/03 05:26:47 mickey Exp $ */
d155 2
a156 2
int	pssprobe(struct device *, void *, void *);
void	pssattach(struct device *, struct device *, void *);
d158 2
a159 2
int	spprobe(struct device *, void *, void *);
void	spattach(struct device *, struct device *, void *);
d162 2
a163 2
int	mpuprobe(struct device *, void *, void *);
void	mpuattach(struct device *, struct device *, void *);
d165 2
a166 2
int	pcdprobe(struct device *, void *, void *);
void	pcdattach(struct device *, struct device *, void *);
d169 1
a169 1
int	pssintr(void *);
d171 1
a171 1
int	mpuintr(void *);
d174 1
a174 1
int	pss_speaker_ctl(void *, int);
d176 1
a176 1
int	pss_getdev(void *, struct audio_device *);
d178 3
a180 3
int	pss_mixer_set_port(void *, mixer_ctrl_t *);
int	pss_mixer_get_port(void *, mixer_ctrl_t *);
int	pss_query_devinfo(void *, mixer_devinfo_t *);
d183 1
a183 1
void	pss_dspwrite(struct pss_softc *, int);
d185 5
a189 5
void	pss_setaddr(int, int);
int	pss_setint(int, int);
int	pss_setdma(int, int);
int	pss_testirq(struct pss_softc *, int);
int	pss_testdma(struct pss_softc *, int);
d191 2
a192 2
int	pss_reset_dsp(struct pss_softc *);
int	pss_download_dsp(struct pss_softc *, u_char *, int);
d195 1
a195 1
void	pss_dump_regs(struct pss_softc *);
d197 8
a204 8
int	pss_set_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_set_master_mode(struct pss_softc *, int);
int	pss_set_treble(struct pss_softc *, u_int);
int	pss_set_bass(struct pss_softc *, u_int);
int	pss_get_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_get_master_mode(struct pss_softc *, u_int *);
int	pss_get_treble(struct pss_softc *, u_char *);
int	pss_get_bass(struct pss_softc *, u_char *);
d207 1
a207 1
void	wss_dump_regs(struct ad1848_softc *);
@


1.20.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1428 1
a1428 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d1430 1
a1430 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1438 1
a1438 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1440 1
a1440 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1448 1
a1448 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1450 1
a1450 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1458 1
a1458 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1460 1
a1460 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1467 1
a1467 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d1469 1
a1469 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1477 1
a1477 1
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1479 1
a1479 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1486 1
a1486 1
	strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d1488 1
a1488 2
	strlcpy(dip->un.v.units.name, AudioNtreble,
	    sizeof dip->un.v.units.name);
d1495 1
a1495 1
	strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d1497 1
a1497 1
	strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
d1504 1
a1504 1
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1511 1
a1511 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1518 1
a1518 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d1525 1
a1525 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1548 1
a1548 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1550 1
a1550 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d1552 1
a1552 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d1561 1
a1561 1
	strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
d1563 1
a1563 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmono,
	    sizeof dip->un.e.member[0].label.name);
d1565 1
a1565 2
	strlcpy(dip->un.e.member[1].label.name, AudioNstereo,
	    sizeof dip->un.e.member[1].label.name);
d1567 1
a1567 2
	strlcpy(dip->un.e.member[2].label.name, AudioNpseudo,
	    sizeof dip->un.e.member[2].label.name);
d1569 1
a1569 2
	strlcpy(dip->un.e.member[3].label.name, AudioNspatial,
	    sizeof dip->un.e.member[3].label.name);
d1578 1
a1578 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1580 1
a1580 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
d1582 1
a1582 2
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
d1584 1
a1584 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
@


1.19
log
@print ports as 0x%x/%d start/len instead of start-end
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.18 1999/01/07 06:14:49 niklas Exp $ */
d49 3
a51 3
 * 	- Provide PSS driver to access DSP
 * 	- Provide MIDI driver to access MPU
 * 	- Finish support for CD drive (Sony and SCSI)
a65 1
#include <machine/pio.h>
d118 1
a118 1
	
d120 1
a120 1
	
d123 1
a123 1
	
d134 1
a134 1
    
d237 1
a237 1
        ad1848_mappage,
d326 1
a326 1
    
d334 2
a335 2
 * This function sets the correct bits in the 
 * configuration register to 
d395 1
a395 1
    
d591 1
a591 1
 
d598 1
a598 1
 * This function loads an image into the PSS 
d601 1
a601 1
 * First you feed the ASIC the first byte of 
d616 1
a616 1
    
d638 2
a639 2
 	}
 
d648 2
a649 2
 	    }
 	}
d700 1
a700 1
	
d719 1
a719 1
    
d785 1
a785 1
      
d825 1
a825 1
    
d834 1
a834 1
	
d898 1
a898 1
    
d903 1
a903 1
    
d938 1
a938 1
    
d962 1
a962 1
    
d973 1
a973 1
    
d1000 1
a1000 1
    
d1019 1
a1019 1
    
d1029 1
a1029 1
    
d1079 1
a1079 1
        mpuintr, sc, sc->sc_dev.dv_xname);
d1094 1
a1094 1
    
d1115 1
a1115 1
	
d1144 1
a1144 1
	
d1155 1
a1155 1
    
d1207 1
a1207 1
	
d1258 1
a1258 1
    
d1260 1
a1260 1
    
d1265 1
a1265 1
    
d1271 1
a1271 1
    
d1282 1
a1282 1
    
d1326 1
a1326 1
    
d1357 1
a1357 1
    
d1520 1
a1520 1
	    
d1527 1
a1527 1
	
d1534 1
a1534 1
	
d1541 1
a1541 1
	
@


1.19.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.20 2001/02/03 05:26:47 mickey Exp $ */
d49 3
a51 3
 *	- Provide PSS driver to access DSP
 *	- Provide MIDI driver to access MPU
 *	- Finish support for CD drive (Sony and SCSI)
d66 1
d119 1
a119 1

d121 1
a121 1

d124 1
a124 1

d135 1
a135 1

d238 1
a238 1
	ad1848_mappage,
d327 1
a327 1

d335 2
a336 2
 * This function sets the correct bits in the
 * configuration register to
d396 1
a396 1

d592 1
a592 1

d599 1
a599 1
 * This function loads an image into the PSS
d602 1
a602 1
 * First you feed the ASIC the first byte of
d617 1
a617 1

d639 2
a640 2
	}

d649 2
a650 2
	    }
	}
d701 1
a701 1

d720 1
a720 1

d786 1
a786 1

d826 1
a826 1

d835 1
a835 1

d899 1
a899 1

d904 1
a904 1

d939 1
a939 1

d963 1
a963 1

d974 1
a974 1

d1001 1
a1001 1

d1020 1
a1020 1

d1030 1
a1030 1

d1080 1
a1080 1
	mpuintr, sc, sc->sc_dev.dv_xname);
d1095 1
a1095 1

d1116 1
a1116 1

d1145 1
a1145 1

d1156 1
a1156 1

d1208 1
a1208 1

d1259 1
a1259 1

d1261 1
a1261 1

d1266 1
a1266 1

d1272 1
a1272 1

d1283 1
a1283 1

d1327 1
a1327 1

d1358 1
a1358 1

d1521 1
a1521 1

d1528 1
a1528 1

d1535 1
a1535 1

d1542 1
a1542 1

@


1.19.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d155 2
a156 2
int	pssprobe(struct device *, void *, void *);
void	pssattach(struct device *, struct device *, void *);
d158 2
a159 2
int	spprobe(struct device *, void *, void *);
void	spattach(struct device *, struct device *, void *);
d162 2
a163 2
int	mpuprobe(struct device *, void *, void *);
void	mpuattach(struct device *, struct device *, void *);
d165 2
a166 2
int	pcdprobe(struct device *, void *, void *);
void	pcdattach(struct device *, struct device *, void *);
d169 1
a169 1
int	pssintr(void *);
d171 1
a171 1
int	mpuintr(void *);
d174 1
a174 1
int	pss_speaker_ctl(void *, int);
d176 1
a176 1
int	pss_getdev(void *, struct audio_device *);
d178 3
a180 3
int	pss_mixer_set_port(void *, mixer_ctrl_t *);
int	pss_mixer_get_port(void *, mixer_ctrl_t *);
int	pss_query_devinfo(void *, mixer_devinfo_t *);
d183 1
a183 1
void	pss_dspwrite(struct pss_softc *, int);
d185 5
a189 5
void	pss_setaddr(int, int);
int	pss_setint(int, int);
int	pss_setdma(int, int);
int	pss_testirq(struct pss_softc *, int);
int	pss_testdma(struct pss_softc *, int);
d191 2
a192 2
int	pss_reset_dsp(struct pss_softc *);
int	pss_download_dsp(struct pss_softc *, u_char *, int);
d195 1
a195 1
void	pss_dump_regs(struct pss_softc *);
d197 8
a204 8
int	pss_set_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_set_master_mode(struct pss_softc *, int);
int	pss_set_treble(struct pss_softc *, u_int);
int	pss_set_bass(struct pss_softc *, u_int);
int	pss_get_master_gain(struct pss_softc *, struct ad1848_volume *);
int	pss_get_master_mode(struct pss_softc *, u_int *);
int	pss_get_treble(struct pss_softc *, u_char *);
int	pss_get_bass(struct pss_softc *, u_char *);
d207 1
a207 1
void	wss_dump_regs(struct ad1848_softc *);
@


1.19.4.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.19.4.2 2002/03/28 12:11:35 niklas Exp $ */
d1428 1
a1428 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d1430 1
a1430 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1438 1
a1438 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1440 1
a1440 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1448 1
a1448 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1450 1
a1450 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1458 1
a1458 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d1460 1
a1460 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1467 1
a1467 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d1469 1
a1469 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1477 1
a1477 1
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1479 1
a1479 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d1486 1
a1486 1
	strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d1488 1
a1488 2
	strlcpy(dip->un.v.units.name, AudioNtreble,
	    sizeof dip->un.v.units.name);
d1495 1
a1495 1
	strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d1497 1
a1497 1
	strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
d1504 1
a1504 1
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1511 1
a1511 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1518 1
a1518 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d1525 1
a1525 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d1548 1
a1548 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d1550 1
a1550 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d1552 1
a1552 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d1561 1
a1561 1
	strlcpy(dip->label.name, AudioNmode, sizeof dip->label.name);
d1563 1
a1563 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmono,
	    sizeof dip->un.e.member[0].label.name);
d1565 1
a1565 2
	strlcpy(dip->un.e.member[1].label.name, AudioNstereo,
	    sizeof dip->un.e.member[1].label.name);
d1567 1
a1567 2
	strlcpy(dip->un.e.member[2].label.name, AudioNpseudo,
	    sizeof dip->un.e.member[2].label.name);
d1569 1
a1569 2
	strlcpy(dip->un.e.member[3].label.name, AudioNspatial,
	    sizeof dip->un.e.member[3].label.name);
d1578 1
a1578 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1580 1
a1580 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
d1582 1
a1582 2
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
d1584 1
a1584 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
@


1.18
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.17 1999/01/02 00:02:46 niklas Exp $ */
d1083 2
a1084 3
    printf(" port 0x%x-0x%x irq %d\n",
	   sc->sc_iobase, sc->sc_iobase+MIDI_NPORT,
	   cf->cf_irq);
d1104 2
a1105 3
    printf(" port 0x%x-0x%x irq %d\n",
	   sc->sc_iobase, sc->sc_iobase+2,
	   cf->cf_irq);
@


1.17
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.16 1998/11/03 21:15:01 downsj Exp $ */
a112 3
#ifdef NEWCONFIG
	struct	isadev sc_id;		/* ISA device */
#endif
a133 3
#ifdef NEWCONFIG
	struct	isadev sc_id;		/* ISA device */
#endif
a141 3
#ifdef NEWCONFIG
	struct	isadev sc_id;		/* ISA device */
#endif
a1023 4
#ifdef NEWCONFIG
    isa_establish(&sc->sc_id, &sc->sc_dev);
#endif

a1055 4
#ifdef NEWCONFIG
    isa_establish(&sc->sc_id, &sc->sc_dev);
#endif

a1078 4
#ifdef NEWCONFIG
    isa_establish(&sc->sc_id, &sc->sc_dev);
#endif

a1102 4

#ifdef NEWCONFIG
    isa_establish(&sc->sc_id, &sc->sc_dev);
#endif
@


1.16
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.15 1998/05/13 10:25:07 provos Exp $ */
d1053 1
a1053 1
    audio_attach_mi(&pss_audio_if, 0, sc->ad1848_sc, &sc->ad1848_sc->sc_dev);
@


1.15
log
@don't printf in probe routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.14 1998/05/08 18:37:22 csapuntz Exp $ */
d7 1
a7 1
 * All rightOAs reserved.
d9 1
a9 1
x * Redistribution and use in source and binary forms, with or without
d249 2
@


1.14
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.13 1998/04/26 21:02:55 provos Exp $ */
d729 1
a729 1
	printf("pss: configured iobase %x invalid\n", iobase);
d773 1
a773 1
	    printf("pss: unable to locate free IRQ channel\n");
d778 1
a778 1
	    printf("pss: found IRQ %d free\n", i);
d783 1
a783 1
	    printf("pss: configured IRQ unavailable (%d)\n", ia->ia_irq);
d790 1
a790 1
	printf("pss: configured DMA channel unavailable (%d)\n", ia->ia_drq);
d854 1
a854 1
	    printf("sp: unable to locate free IRQ for WSS\n");
d866 1
a866 1
	    printf("sp: configured IRQ unavailable (%d)\n", sc->sc_irq);
d880 1
a880 1
	    printf("sp: unable to locate free DMA channel for WSS\n");
d890 1
a890 1
	    printf("sp: configured DMA channel unavailable (%d)\n", sc->sc_drq);
d899 1
a899 1
	printf("sp: invalid interrupt configuration (irq=%d)\n", sc->sc_irq);
@


1.13
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.12 1997/07/12 01:42:08 millert Exp $ */
d7 1
a7 1
 * All rights reserved.
d9 1
a9 1
 * Redistribution and use in source and binary forms, with or without
a215 3
static int pss_to_vol __P((mixer_ctrl_t *, struct ad1848_volume *));
static int pss_from_vol __P((mixer_ctrl_t *, struct ad1848_volume *));

a1133 33
static int
pss_to_vol(cp, vol)
    mixer_ctrl_t *cp;
    struct ad1848_volume *vol;
{
    if (cp->un.value.num_channels == 1) {
	vol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	return(1);
    }
    else if (cp->un.value.num_channels == 2) {
	vol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
	return(1);
    }
    return(0);
}

static int
pss_from_vol(cp, vol)
    mixer_ctrl_t *cp;
    struct ad1848_volume *vol;
{
    if (cp->un.value.num_channels == 1) {
	cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;
	return(1);
    }
    else if (cp->un.value.num_channels == 2) {
	cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;
	cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;
	return(1);
    }
    return(0);
}
d1329 14
d1351 1
a1351 1
    int error = EINVAL;
d1353 2
a1354 1
    DPRINTF(("pss_mixer_set_port: dev=%d type=%d\n", cp->dev, cp->type));
a1356 67
    case PSS_MIC_IN_LVL:	/* Microphone */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (pss_to_vol(cp, &vol))
		error = ad1848_set_aux2_gain(ac, &vol);
	}
	break;
	
    case PSS_MIC_IN_MUTE:	/* Microphone */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->mic_mute = cp->un.ord;
	    DPRINTF(("mic mute %d\n", cp->un.ord));
	    ad1848_mute_aux2(ac, cp->un.ord);
	    error = 0;
	}
	break;

    case PSS_LINE_IN_LVL:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (pss_to_vol(cp, &vol))
		error = ad1848_set_aux1_gain(ac, &vol);
	}
	break;
	
    case PSS_LINE_IN_MUTE:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->cd_mute = cp->un.ord;
	    DPRINTF(("CD mute %d\n", cp->un.ord));
	    ad1848_mute_aux1(ac, cp->un.ord);
	    error = 0;
	}
	break;

    case PSS_DAC_LVL:		/* dac out */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (pss_to_vol(cp, &vol))
		error = ad1848_set_out_gain(ac, &vol);
	}
	break;
	
    case PSS_DAC_MUTE:		/* dac out */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->dac_mute = cp->un.ord;
	    DPRINTF(("DAC mute %d\n", cp->un.ord));
	    error = 0;
	}
	break;

    case PSS_REC_LVL:		/* record level */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (pss_to_vol(cp, &vol))
		error = ad1848_set_rec_gain(ac, &vol);
	}
	break;
	
    case PSS_RECORD_SOURCE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    error = ad1848_set_rec_port(ac, cp->un.ord);
	}
	break;

    case PSS_MON_LVL:
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    vol.left  = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	    error = ad1848_set_mon_gain(ac, &vol);
	}
	break;

d1359 1
a1359 1
	    if (pss_to_vol(cp, &vol))
d1396 1
a1396 3
    int error = EINVAL;
    
    DPRINTF(("pss_mixer_get_port: port=%d\n", cp->dev));
d1398 2
a1399 8
    switch (cp->dev) {
    case PSS_MIC_IN_LVL:	/* Microphone */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_aux2_gain(ac, &vol);
	    if (!error)
		pss_from_vol(cp, &vol);
	}
	break;
d1401 1
a1401 59
    case PSS_MIC_IN_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->mic_mute;
	    error = 0;
	}
	break;

    case PSS_LINE_IN_LVL:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_aux1_gain(ac, &vol);
	    if (!error)
		pss_from_vol(cp, &vol);
	}
	break;

    case PSS_LINE_IN_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->cd_mute;
	    error = 0;
	}
	break;

    case PSS_DAC_LVL:		/* dac out */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_out_gain(ac, &vol);
	    if (!error)
		pss_from_vol(cp, &vol);
	}
	break;

    case PSS_DAC_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->dac_mute;
	    error = 0;
	}
	break;

    case PSS_REC_LVL:		/* record level */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_rec_gain(ac, &vol);
	    if (!error)
		pss_from_vol(cp, &vol);
	}
	break;

    case PSS_RECORD_SOURCE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = ad1848_get_rec_port(ac);
	    error = 0;
	}
	break;

    case PSS_MON_LVL:		/* monitor level */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    error = ad1848_get_mon_gain(ac, &vol);
	    if (!error)
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol.left;
	}
	break;
d1403 1
d1408 1
a1408 1
		pss_from_vol(cp, &vol);
@


1.12
log
@Add missing sc->sc_dev.dv_xname arg to isa_intr_establish().
@
text
@d1 2
a2 2
/*	$OpenBSD: pss.c,v 1.11 1997/07/10 23:06:36 provos Exp $ */
/*	$NetBSD: pss.c,v 1.15 1996/05/12 23:53:23 mycroft Exp $	*/
d65 1
d159 1
a159 2
extern void Dprintf __P((const char *, ...));
#define DPRINTF(x)	if (pssdebug) Dprintf x
a178 2
int	spopen __P((dev_t, int));

a186 1
int	pss_setfd __P((void *, int));
a187 4
int	pss_set_out_port __P((void *, int));
int	pss_get_out_port __P((void *));
int	pss_set_in_port __P((void *, int));
int	pss_get_in_port __P((void *));
d228 1
a228 1
	spopen,
a230 4
	ad1848_set_in_sr,
	ad1848_get_in_sr,
	ad1848_set_out_sr,
	ad1848_get_out_sr,
d232 1
a232 5
	ad1848_set_format,
	ad1848_get_encoding,
	ad1848_get_precision,
	ad1848_set_channels,
	ad1848_get_channels,
a233 4
	pss_set_out_port,
	pss_get_out_port,
	pss_set_in_port,
	pss_get_in_port,
d235 2
a236 2
	NULL,
	NULL,
a240 2
	ad1848_cont_out_dma,
	ad1848_cont_in_dma,
d243 1
a243 1
	pss_setfd,
d247 5
a251 2
	0,	/* not full-duplex */
	0
d830 1
d834 1
a1029 1
    int err;
d1054 1
a1054 2
    if ((err = audio_hardware_attach(&pss_audio_if, sc->ad1848_sc)) != 0)
	printf("pss: could not attach to audio pseudo-device driver (%d)\n", err);
d1077 1
a1077 4
    /* XXX might use pssprint func ?? */
    printf(" port 0x%x-0x%x irq %d drq %d",
	   sc->sc_iobase, sc->sc_iobase+AD1848_NPORT,
	   cf->cf_irq, cf->cf_drq);
a1171 18
spopen(dev, flags)
    dev_t dev;
    int flags;
{
    struct ad1848_softc *sc;
    int unit = AUDIOUNIT(dev);
    
    if (unit >= sp_cd.cd_ndevs)
	return ENODEV;
    
    sc = sp_cd.cd_devs[unit];
    if (!sc)
	return ENXIO;
    
    return ad1848_open(sc, dev, flags);
}

int
d1173 1
a1173 1
    register struct pss_softc *sc;
d1200 1
a1200 1
    register struct pss_softc *sc;
d1230 1
a1230 1
    register struct pss_softc *sc;
d1251 1
a1251 1
    register struct pss_softc *sc;
d1272 1
a1272 1
    register struct pss_softc *sc;
d1281 1
a1281 1
    register struct pss_softc *sc;
d1290 1
a1290 1
    register struct pss_softc *sc;
d1299 1
a1299 1
    register struct pss_softc *sc;
d1318 1
a1318 1
    register struct pss_softc *sc = arg;
d1323 1
a1323 1
    DPRINTF(("pssintr: sc=%x st=%x\n", sc, sr));
d1342 1
a1342 1
    register struct mpu_softc *sc = arg;
d1359 1
a1359 1
    DPRINTF(("pss_getdev: retp=0x%x\n", retp));
a1365 90
pss_setfd(addr, flag)
    void *addr;
    int flag;
{
    /* Can't do full-duplex */
    return(ENOTTY);
}

int
pss_set_out_port(addr, port)
    void *addr;
    int port;
{
    register struct ad1848_softc *ac = addr;
    register struct pss_softc *sc = ac->parent;
	
    DPRINTF(("pss_set_out_port: %d\n", port));

    if (port != PSS_MASTER_VOL)
	return(EINVAL);
    
    sc->out_port = port;

    return(0);
}

int
pss_get_out_port(addr)
    void *addr;
{
    register struct ad1848_softc *ac = addr;
    register struct pss_softc *sc = ac->parent;

    DPRINTF(("pss_get_out_port: %d\n", sc->out_port));

    return(sc->out_port);
}

int
pss_set_in_port(addr, port)
    void *addr;
    int port;
{
    register struct ad1848_softc *ac = addr;
	
    DPRINTF(("pss_set_in_port: %d\n", port));

    switch(port) {
    case PSS_MIC_IN_LVL:
	port = MIC_IN_PORT;
	break;
    case PSS_LINE_IN_LVL:
	port = LINE_IN_PORT;
	break;
    case PSS_DAC_LVL:
	port = DAC_IN_PORT;
	break;
    default:
	return(EINVAL);
	/*NOTREACHED*/
    }
    
    return(ad1848_set_rec_port(ac, port));
}

int
pss_get_in_port(addr)
    void *addr;
{
    register struct ad1848_softc *ac = addr;
    int port = PSS_MIC_IN_LVL;
    
    switch(ad1848_get_rec_port(ac)) {
    case MIC_IN_PORT:
	port = PSS_MIC_IN_LVL;
	break;
    case LINE_IN_PORT:
	port = PSS_LINE_IN_LVL;
	break;
    case DAC_IN_PORT:
	port = PSS_DAC_LVL;
	break;
    }

    DPRINTF(("pss_get_in_port: %d\n", port));

    return(port);
}

int
d1370 2
a1371 2
    register struct ad1848_softc *ac = addr;
    register struct pss_softc *sc = ac->parent;
d1480 2
a1481 2
    register struct ad1848_softc *ac = addr;
    register struct pss_softc *sc = ac->parent;
d1597 1
a1597 1
    register mixer_devinfo_t *dip;
d1656 1
a1656 1
	strcpy(dip->label.name, AudioNvolume);
d1683 1
a1683 1
	strcpy(dip->label.name, AudioNspeaker);
d1690 1
a1690 1
	strcpy(dip->label.name, AudioCInputs);
d1697 1
a1697 1
	strcpy(dip->label.name, AudioNmonitor);
d1704 1
a1704 1
	strcpy(dip->label.name, AudioNrecord);
@


1.11
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.9 1996/05/07 07:37:33 deraadt Exp $ */
d1093 1
a1093 1
	ad1848_intr, sc);
d1123 1
a1123 1
        mpuintr, sc);
@


1.10
log
@sync 0521
@
text
@d77 3
d112 1
d114 1
d133 1
d136 1
d138 1
d145 1
a145 1
struct cd_softc {
d147 1
d149 1
d155 1
d171 1
d177 1
d182 1
d184 1
d199 1
d201 1
d205 1
d207 1
d210 2
d213 1
d226 1
d228 1
d243 1
a243 1
	ad1848_set_encoding,
a244 1
	ad1848_set_precision,
a253 1
	ad1848_get_silence,
d274 1
a274 1
static u_char wss_interrupt_bits[12] = {
d277 2
a278 1
    0xff, 0x10, 0x18, 0x20
a282 4
#ifndef NEWCONFIG
#define at_dma(flags, ptr, cc, chan)	isa_dmastart(flags, ptr, cc, chan)
#endif

d299 1
d309 1
a309 1
	sizeof(struct cd_softc), pcdprobe, pcdattach
d315 1
d323 1
d347 1
d373 1
a374 5
    case 0:
	val = inw(configAddress);
	val &= INT_MASK;
	outw(configAddress,val);
	break;
a378 1
	outw(configAddress,val);
a383 1
	outw(configAddress,val);
a388 1
	outw(configAddress,val);
a393 1
	outw(configAddress,val);
a398 1
	outw(configAddress,val);
a403 1
	outw(configAddress,val);
a408 1
	outw(configAddress,val);
d411 1
a411 1
	printf("pss_setint unkown int\n");
d414 1
a429 1
	outw(configAddress,val);
a434 1
	outw(configAddress,val);
a439 1
	outw(configAddress,val);
a444 1
	outw(configAddress,val);
a449 1
	outw(configAddress,val);
a454 1
	outw(configAddress,val);
d457 1
a457 1
	printf("PSS ERROR! pss_setdma: unknown_dma\n");
d460 1
d466 2
a467 2
 * it is availible. It takes the interrupt button
 * as it's argument and returns TRUE if the interrupt
d470 1
a470 1
static int
d473 1
a473 1
    int iobase = sc->sc_iobase;
d481 1
a481 1
	val = inw(iobase+PSS_CONFIG);
a482 1
	outw(iobase+PSS_CONFIG, val);
d485 1
a485 1
	val = inw(iobase+PSS_CONFIG);
d487 1
a487 2
	val |= INT_5_BITS;
	outw(iobase+PSS_CONFIG,val);
d490 1
a490 1
	val = inw(iobase+PSS_CONFIG);
d492 1
a492 2
	val |= INT_7_BITS;
	outw(iobase+PSS_CONFIG,val);
d495 1
a495 1
	val = inw(iobase+PSS_CONFIG);
d497 1
a497 2
	val |= INT_9_BITS;
	outw(iobase+PSS_CONFIG,val);
d500 1
a500 1
	val = inw(iobase+PSS_CONFIG);
d502 1
a502 2
	val |= INT_10_BITS;
	outw(iobase+PSS_CONFIG,val);
d505 1
a505 1
	val = inw(iobase+PSS_CONFIG);
d507 1
a507 2
	val |= INT_11_BITS;
	outw(iobase+PSS_CONFIG,val);
d510 1
a510 1
	val = inw(iobase+PSS_CONFIG);
d512 1
a512 2
	val |= INT_12_BITS;
	outw(iobase+PSS_CONFIG,val);
d515 1
a515 1
	DPRINTF(("pss: unknown IRQ (%d)\n", intNum));
d518 1
a518 5

    /* Set the interrupt test bit */
    val = inw(iobase+PSS_CONFIG);
    val |= INT_TEST_BIT;
    outw(iobase+PSS_CONFIG,val);
d524 1
a524 1
	val = inw(iobase+PSS_CONFIG);
d532 3
a534 4
    val = inw(iobase+PSS_CONFIG);
    val &= INT_TEST_BIT_MASK;
    val &= INT_MASK;
    outw(iobase+PSS_CONFIG,val);
d540 2
a541 2
 * it is availible. It takes the DMA channel button
 * as it's argument and returns TRUE if the channel
d549 1
a549 1
    int iobase = sc->sc_iobase;
d551 1
a551 1
    int i,ret;
d555 1
a555 1
	val = inw(iobase+PSS_CONFIG);
d557 1
a557 2
	val |= DMA_0_BITS;
	outw(iobase+PSS_CONFIG,val);
d560 1
a560 1
	val = inw(iobase+PSS_CONFIG);
d562 1
a562 2
	val |= DMA_1_BITS;
	outw(iobase+PSS_CONFIG,val);
d565 1
a565 1
	val = inw(iobase+PSS_CONFIG);
d567 1
a567 2
	val |= DMA_3_BITS;
	outw(iobase+PSS_CONFIG,val);
d570 1
a570 1
	val = inw(iobase+PSS_CONFIG);
d572 1
a572 2
	val |= DMA_5_BITS;
	outw(iobase+PSS_CONFIG,val);
d575 1
a575 1
	val = inw(iobase+PSS_CONFIG);
d577 1
a577 2
	val |= DMA_6_BITS;
	outw(iobase+PSS_CONFIG,val);
d580 1
a580 1
	val = inw(iobase+PSS_CONFIG);
d582 1
a582 2
	val |= DMA_7_BITS;
	outw(iobase+PSS_CONFIG,val);
d585 1
a585 1
	DPRINTF(("pss: unknown DMA channel (%d)\n", dmaNum));
d588 1
a588 5

    /* Set the DMA test bit */
    val = inw(iobase+PSS_CONFIG);
    val |= DMA_TEST_BIT;
    outw(iobase+PSS_CONFIG,val);
d594 1
a594 1
	val = inw(iobase+PSS_CONFIG);
d602 3
a604 4
    val = inw(iobase+PSS_CONFIG);
    val &= DMA_TEST_BIT_MASK;
    val &= DMA_MASK;
    outw(iobase+PSS_CONFIG,val);
d608 1
d628 2
a629 2
 * card.  The function loads the file by putting
 * reseting the dsp and feeding it the boot bytes.
d709 1
d711 1
d716 3
a718 3
    printf("WSS regs: config=%x version=%x\n",
	   (u_char)inb(sc->sc_iobase+WSS_CONFIG),
	   (u_char)inb(sc->sc_iobase+WSS_STATUS));
d725 2
a726 1
    printf("PSS regs: status=%x vers=%x ",
d730 1
a730 1
    printf("config=%x wss_config=%x\n",
d734 1
d777 1
a777 1
    pss_setaddr(WSS_BASE_ADDRESS, sc->sc_iobase+PSS_WSS_CONFIG);
d821 1
a821 1
	
d832 1
d851 1
a851 1
    sc->sc_iobase = cf->cf_iobase;
d854 1
a854 1
    pss_setaddr(sc->sc_iobase, pc->sc_iobase+PSS_WSS_CONFIG);
d934 1
d985 1
a985 1
    struct cd_softc *sc = match;
d1030 1
d1093 1
a1093 1
	ad1848_intr, sc, sc->sc_dev.dv_xname);
d1105 1
d1123 1
a1123 1
        mpuintr, sc, sc->sc_dev.dv_xname);
d1136 1
a1136 1
    struct cd_softc *sc = (struct cd_softc *)self;
d1156 1
d1376 1
d1391 1
@


1.9
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pss.c,v 1.8 1996/04/21 22:24:26 deraadt Exp $ */
/*	$NetBSD: pss.c,v 1.14 1996/04/29 20:00:39 christos Exp $	*/
d64 1
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: pss.c,v 1.7 1996/03/20 01:00:59 mickey Exp $ */
/*	$NetBSD: pss.c,v 1.13 1996/04/11 22:29:52 cgd Exp $	*/
d153 1
a153 1
int	pssprobe();
d156 1
a156 1
int	spprobe();
d159 1
a159 1
int	mpuprobe();
d162 1
a162 1
int	pcdprobe();
d183 22
d302 3
a304 1
pss_dspwrite(struct pss_softc *sc, int data)
d326 3
a328 1
pss_setaddr(int addr, int configAddr)
d344 3
a346 1
pss_setint(int intNum, int configAddress)
d405 3
a407 1
pss_setdma(int dmaNum, int configAddress)
d548 3
a550 1
pss_testdma(struct pss_softc *sc, int dmaNum)
d623 2
a624 1
pss_reset_dsp(struct pss_softc *sc)
d651 4
a654 1
pss_download_dsp(struct pss_softc *sc, u_char *block, int size)
d724 2
a725 1
wss_dump_regs(struct ad1848_softc *sc)
d733 2
a734 1
pss_dump_regs(struct pss_softc *sc)
d750 2
a751 1
    struct device *parent, *self;
d754 1
a754 1
    struct pss_softc *sc = (void *)self;
a756 1
    int i;
d853 2
a854 2
    struct ad1848_softc *sc = (void *)match;
    struct pss_softc *pc = (void *)parent;
d947 2
a948 2
    struct mpu_softc *sc = (void *)match;
    struct pss_softc *pc = (void *)parent;
d992 2
a993 2
    struct cd_softc *sc = (void *)match;
    struct pss_softc *pc = (void *)parent;
d1005 1
a1005 1
    val | CD_POL_BIT;	/* XXX if (pol) */
d1274 1
a1274 1
    u_char treb;
d1389 1
a1389 1
    printf("mpuintr: sc=%x sr=%x\n", sc, sr);
a1450 1
    register struct pss_softc *sc = ac->parent;
a1476 1
    register struct pss_softc *sc = ac->parent;
a1503 1
    u_char eq;
a1729 3
    register struct ad1848_softc *ac = addr;
    register struct pss_softc *sc = ac->parent;

@


1.7
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: pss.c,v 1.6 1996/03/19 21:10:29 mickey Exp $ */
/*	$NetBSD: pss.c,v 1.11 1995/12/24 02:31:45 mycroft Exp $ */
d241 2
a242 2
struct cfdriver psscd = {
	NULL, "pss", pssprobe, pssattach, DV_DULL, sizeof(struct pss_softc), 1
d245 2
a246 2
struct cfdriver spcd = {
	NULL, "sp", spprobe, spattach, DV_DULL, sizeof(struct ad1848_softc)
d249 2
a250 2
struct cfdriver mpucd = {
	NULL, "mpu", mpuprobe, mpuattach, DV_DULL, sizeof(struct mpu_softc)
d253 18
a270 2
struct cfdriver pcdcd = {
	NULL, "pcd", pcdprobe, pcdattach, DV_DULL, sizeof(struct cd_softc)
d1024 2
a1025 2
    sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_AUDIO, pssintr,
	sc, sc->sc_dev.dv_xname);
d1030 1
a1030 1
    (void)config_found(self, NULL, NULL);
d1050 1
d1060 2
a1061 2
    sc->sc_ih = isa_intr_establish(cf->cf_irq, IST_EDGE, IPL_AUDIO, ad1848_intr,
	sc, sc->sc_dev.dv_xname);
d1080 1
d1089 2
a1090 2
    sc->sc_ih = isa_intr_establish(cf->cf_irq, IST_EDGE, IPL_AUDIO, mpuintr,
	sc, sc->sc_dev.dv_xname);
d1166 1
a1166 1
    if (unit >= spcd.cd_ndevs)
d1169 1
a1169 1
    sc = spcd.cd_devs[unit];
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: pss.c,v 1.5 1996/03/08 16:43:11 niklas Exp $ */
d1009 1
a1009 1
	sc);
@


1.5
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1009 1
a1009 1
	sc, sc->sc_dev.dv_xname);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: pss.c,v 1.10 1995/11/10 04:30:49 mycroft Exp $	*/
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1008 1
a1008 1
	sc);
d1043 1
a1043 1
	sc);
d1071 1
a1071 1
	sc);
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d1007 2
a1008 2
    sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
				   pssintr, sc);
d1042 2
a1043 2
    sc->sc_ih = isa_intr_establish(cf->cf_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
	ad1848_intr, sc);
d1070 2
a1071 2
    sc->sc_ih = isa_intr_establish(cf->cf_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
	mpuintr, sc);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pss.c,v 1.9 1995/08/12 22:37:58 mycroft Exp $	*/
d110 2
a111 2
	u_short	sc_iobase;		/* I/O port base address */
	u_short	sc_drq;			/* dma channel */
d131 2
a132 2
	u_short	sc_iobase;		/* MIDI I/O port base address */
	u_short	sc_irq;			/* MIDI interrupt */
d140 2
a141 2
	u_short	sc_iobase;		/* CD I/O port base address */
	u_short	sc_irq;			/* CD interrupt */
d266 1
a266 1
    u_short pss_base = sc->sc_iobase;
d417 1
a417 1
    u_short iobase = sc->sc_iobase;
d503 1
a503 1
    u_short iobase = sc->sc_iobase;
d577 1
a577 1
    u_short pss_base = sc->sc_iobase;
d604 1
a604 1
    u_short pss_base = sc->sc_iobase;
d700 1
a700 1
    u_short iobase = ia->ia_iobase;
d709 1
a709 1
    if (iobase == (u_short)IOBASEUNK) {
d994 1
a994 1
    u_short iobase = ia->ia_iobase;
d1033 1
a1033 1
    u_short iobase = cf->cf_iobase;
d1062 1
a1062 1
    u_short iobase = cf->cf_iobase;
d1086 1
a1086 1
    u_short iobase = cf->cf_iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
