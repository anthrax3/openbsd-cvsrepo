head	1.42;
access;
symbols
	SMP_SYNC_A:1.42
	SMP_SYNC_B:1.42
	UBC_SYNC_A:1.42
	UBC_SYNC_B:1.42
	SMP:1.42.0.2
	kame_19991208:1.41
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.39.0.2
	OPENBSD_2_5_BASE:1.39
	OPENBSD_2_4:1.38.0.2
	OPENBSD_2_4_BASE:1.38
	OPENBSD_2_3:1.32.0.2
	OPENBSD_2_3_BASE:1.32
	OPENBSD_2_2:1.31.0.2
	OPENBSD_2_2_BASE:1.31
	OPENBSD_2_1:1.25.0.2
	OPENBSD_2_1_BASE:1.25
	OPENBSD_2_0:1.19.0.2
	OPENBSD_2_0_BASE:1.19
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.42
date	99.12.11.21.25.07;	author csapuntz;	state dead;
branches;
next	1.41;

1.41
date	99.08.10.23.09.49;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	99.05.09.20.40.43;	author weingart;	state Exp;
branches;
next	1.39;

1.39
date	99.02.25.17.14.12;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	98.10.04.01.46.42;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	98.10.03.21.19.00;	author millert;	state Exp;
branches;
next	1.36;

1.36
date	98.10.01.04.23.54;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.08.06.09.57.09;	author downsj;	state Exp;
branches;
next	1.34;

1.34
date	98.07.23.05.27.37;	author csapuntz;	state Exp;
branches;
next	1.33;

1.33
date	98.07.23.04.40.11;	author csapuntz;	state Exp;
branches;
next	1.32;

1.32
date	97.12.10.23.09.37;	author rees;	state Exp;
branches;
next	1.31;

1.31
date	97.10.18.21.09.57;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	97.10.18.10.37.14;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	97.09.13.14.18.44;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	97.08.08.22.00.10;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	97.08.08.21.47.03;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.07.06.18.10.17;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	97.04.18.06.12.23;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	97.01.04.08.50.24;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	96.11.29.22.55.08;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	96.11.28.08.23.38;	author downsj;	state Exp;
branches;
next	1.21;

1.21
date	96.11.23.21.46.48;	author kstailey;	state Exp;
branches;
next	1.20;

1.20
date	96.11.12.20.30.43;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.09.22.09.02.32;	author downsj;	state Exp;
branches;
next	1.18;

1.18
date	96.09.16.02.36.10;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	96.08.07.01.53.01;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	96.06.09.08.59.55;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	96.06.08.09.12.44;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	96.06.01.09.35.36;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.26.00.27.31;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.07.07.37.58;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.04.29.14.17.00;	author hvozda;	state Exp;
branches;
next	1.10;

1.10
date	96.04.21.22.24.40;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.23.47.51;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.03.20.01.01.05;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.19.21.10.34;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.02.20.04.36.09;	author tholo;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.20.21.21;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.01.05.02.49.41;	author dm;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.38;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.15.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.38;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.42
log
@

Remove old IDE driver
@
text
@/*	$OpenBSD: wd.c,v 1.41 1999/08/10 23:09:49 deraadt Exp $	*/
/*	$NetBSD: wd.c,v 1.150 1996/05/12 23:54:03 mycroft Exp $ */

/*
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * DMA and multi-sector PIO handling are derived from code contributed by
 * Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include "isadma.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/stat.h>
#include <sys/ioctl.h>
#include <sys/buf.h>
#include <sys/uio.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/syslog.h>
#include <sys/proc.h>

#include <vm/vm.h>

#include <machine/bus.h>
#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/isa/wdreg.h>
#include <dev/isa/wdlink.h>

#define	WDUNIT(dev)			DISKUNIT(dev)
#define	WDPART(dev)			DISKPART(dev)
#define	MAKEWDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define	WDLABELDEV(dev)	(MAKEWDDEV(major(dev), WDUNIT(dev), RAW_PART))

#ifdef WDDEBUG
#define WDDEBUG_PRINT(args)		printf args
#else
#define WDDEBUG_PRINT(args)
#endif

struct wd_softc {
	struct device sc_dev;
	struct disk sc_dk;
	struct wd_link *d_link;
	struct buf sc_q;
};

int	wdprobe		__P((struct device *, void *, void *));
void	wdattach	__P((struct device *, struct device *, void *));
int	wdprint		__P((void *, const char *));

struct cfattach wd_ca = {
	sizeof(struct wd_softc), wdprobe, wdattach
};

struct cfdriver wd_cd = {
	NULL, "wd", DV_DISK
};

void	wdgetdisklabel __P((dev_t, struct wd_softc *, struct disklabel *,
			    struct cpu_disklabel *, int));
int	wd_get_parms	__P((struct wd_softc *));
void	wdstrategy	__P((struct buf *));

struct dkdriver wddkdriver = { wdstrategy };

/* XXX: these should go elsewhere */
cdev_decl(wd);
bdev_decl(wd);

void	wdfinish	__P((struct wd_softc *, struct buf *));
int	wdsetctlr	__P((struct wd_link *));
#ifdef DKBAD
static void bad144intern __P((struct wd_softc *));
#endif
int	wdlock		__P((struct wd_link *));
void	wdunlock	__P((struct wd_link *));

int
wdprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct wd_link *d_link = aux;
	int drive;
	
	if (d_link == NULL)
		return 0;
	if (d_link->type != DRIVE)
		return 0;

	drive = d_link->sc_drive;
	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != drive)
		return 0;

	return 1;
}

void
wdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wd_softc *wd = (void *)self;
	struct wd_link *d_link= aux;
	int i, blank;
	char buf[41], c, *p, *q;

	wd->d_link = d_link;
	d_link->openings = 1;
	d_link->wd_softc = (caddr_t)wd;

	/*
	 * Initialize and attach the disk structure.
	 */
	wd->sc_dk.dk_driver = &wddkdriver;
	wd->sc_dk.dk_name = wd->sc_dev.dv_xname;
	disk_attach(&wd->sc_dk);

	dk_establish(&wd->sc_dk, &wd->sc_dev);

	d_link->sc_lp = wd->sc_dk.dk_label;

	wdc_get_parms(d_link);
	for (blank = 0, p = d_link->sc_params.wdp_model, q = buf, i = 0;
	     i < sizeof(d_link->sc_params.wdp_model); i++) {
		c = *p++;
		if (c == '\0')
			break;
		if (c != ' ') {
			if (blank) {
				*q++ = ' ';
				blank = 0;
			}
			*q++ = c;
		} else
			blank = 1;
	}
	*q++ = '\0';

	printf(": <%s>\n", buf);
	if (d_link->sc_lp->d_type != DTYPE_ST506) {
		if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0) {
			printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec, %d sec total\n",
				self->dv_xname,
				d_link->sc_params.wdp_lbacapacity / 2048,
				d_link->sc_params.wdp_cylinders,
				d_link->sc_params.wdp_heads,
				d_link->sc_params.wdp_sectors,
				DEV_BSIZE, /* XXX */
				d_link->sc_params.wdp_lbacapacity);
		} else {
			printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec, %d sec total\n",
				self->dv_xname,
				d_link->sc_params.wdp_cylinders *
					(d_link->sc_params.wdp_heads *
					 d_link->sc_params.wdp_sectors) / (1048576 / DEV_BSIZE),
				d_link->sc_params.wdp_cylinders,
				d_link->sc_params.wdp_heads,
				d_link->sc_params.wdp_sectors,
				DEV_BSIZE, /* XXX */
				d_link->sc_params.wdp_cylinders *
					(d_link->sc_params.wdp_heads *
					 d_link->sc_params.wdp_sectors));
		}
	}

#if NISADMA > 0
	if ((d_link->sc_params.wdp_capabilities & WD_CAP_DMA) != 0 &&
	    d_link->sc_mode == WDM_DMA) {
		d_link->sc_mode = WDM_DMA;
	} else
#endif
		if (d_link->sc_params.wdp_maxmulti > 1) {
			d_link->sc_mode = WDM_PIOMULTI;
			d_link->sc_multiple = min(d_link->sc_params.wdp_maxmulti, 16);
		} else {
			d_link->sc_mode = WDM_PIOSINGLE;
			d_link->sc_multiple = 1;
		}

	printf("%s: using", wd->sc_dev.dv_xname);
#if NISADMA > 0
	if (d_link->sc_mode == WDM_DMA)
		printf(" dma transfers,");
	else
#endif
		printf(" %d-sector %d-bit pio transfers,",
		       d_link->sc_multiple,
		       (d_link->sc_flags & WDF_32BIT) == 0 ? 16 : 32);
	if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0)
		printf(" lba addressing");
	else
		printf(" chs addressing");
	if (d_link->sc_params.wdp_bufsize > 0)
		printf(" (%dKB cache)", d_link->sc_params.wdp_bufsize / 2);
	printf("\n");
}

/*
 * Read/write routine for a buffer.  Validates the arguments and schedules the
 * transfer.  Does not wait for the transfer to complete.
 */
void
wdstrategy(bp)
	struct buf *bp;
{
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(bp->b_dev)];
	struct wd_link *d_link= wd->d_link;
	int s;
    
	/* Valid request?  */
	if (bp->b_blkno < 0 ||
	    (bp->b_bcount % wd->sc_dk.dk_label->d_secsize) != 0 ||
	    (bp->b_bcount / wd->sc_dk.dk_label->d_secsize) >= (1 << NBBY)) {
		bp->b_error = EINVAL;
		goto bad;
	}
    
	/* If device invalidated (e.g. media change, door open), error. */
	if ((d_link->sc_flags & WDF_LOADED) == 0) {
		bp->b_error = EIO;
		goto bad;
	}

	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
		goto done;

	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (WDPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, wd->sc_dk.dk_label,
	    wd->sc_dk.dk_cpulabel,
	    (d_link->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)
		goto done;
    
	/* Queue transfer on drive, activate drive and controller if idle. */
	s = splbio();
	disksort(&wd->sc_q, bp);
	wdstart(wd);
	splx(s);
	return;
    
bad:
	bp->b_flags |= B_ERROR;
done:
	/* Toss transfer; we're done early. */
	bp->b_resid = bp->b_bcount;
	biodone(bp);
}

/*
 * Queue a drive for I/O.
 */
void
wdstart(vp)
	void *vp;
{
	struct wd_softc *wd = vp;
	struct buf *dp, *bp=0;
	struct wd_link *d_link = wd->d_link;
	struct wdc_link *ctlr_link = d_link->ctlr_link;
	struct wdc_xfer *xfer;
	u_int32_t p_offset; 

	while (d_link->openings > 0) {

		/* Is there a buf for us ? */
		dp = &wd->sc_q;
		if ((bp = dp->b_actf) == NULL)  /* yes, an assign */
                 	return;
		dp->b_actf = bp->b_actf;
		
		/* 
		 * Make the command. First lock the device
		 */
		d_link->openings--;
		if (WDPART(bp->b_dev) != RAW_PART)
			p_offset =
		  wd->sc_dk.dk_label->d_partitions[WDPART(bp->b_dev)].p_offset;
		else
			p_offset = 0;

		xfer = wdc_get_xfer(ctlr_link, 0);
		if (xfer == NULL)
			panic("wdc_xfer");

		xfer->d_link = d_link;
		xfer->c_bp = bp;
		xfer->c_p_offset = p_offset;
		xfer->databuf = bp->b_data;
		xfer->c_flags |= bp->b_flags & (B_READ|B_WRITE);
		xfer->c_skip = 0;
		xfer->c_errors = 0;
		/* count and blkno are filled in by wdcstart */

		/* Instrumentation. */
		disk_busy(&wd->sc_dk);
		wdc_exec_xfer(wd->d_link,xfer);
	}
}

int
wdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	WDDEBUG_PRINT(("wdread\n"));
	return (physio(wdstrategy, NULL, dev, B_READ, minphys, uio));
}

int
wdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	WDDEBUG_PRINT(("wdwrite\n"));
	return (physio(wdstrategy, NULL, dev, B_WRITE, minphys, uio));
}

/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
wdlock(d_link)
	struct wd_link *d_link;
{
	int error;
	int s;

	WDDEBUG_PRINT(("wdlock\n"));

	s = splbio();

	while ((d_link->sc_flags & WDF_LOCKED) != 0) {
		d_link->sc_flags |= WDF_WANTED;
		if ((error = tsleep(d_link, PRIBIO | PCATCH,
		    "wdlck", 0)) != 0) {
			splx(s);
			return error;
		}
	}
	d_link->sc_flags |= WDF_LOCKED;
	splx(s);
	return 0;
}

/*
 * Unlock and wake up any waiters.
 */
void
wdunlock(d_link)
	struct wd_link *d_link;
{

	WDDEBUG_PRINT(("wdunlock"));

	d_link->sc_flags &= ~WDF_LOCKED;
	if ((d_link->sc_flags & WDF_WANTED) != 0) {
		d_link->sc_flags &= ~WDF_WANTED;
		wakeup(d_link);
	}
}

int
wdopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct wd_softc *wd;
	struct wd_link *d_link;
	int unit, part;
	int error;

	WDDEBUG_PRINT(("wdopen\n"));

	unit = WDUNIT(dev);
	if (unit >= wd_cd.cd_ndevs)
		return ENXIO;
	wd = wd_cd.cd_devs[unit];
	if (wd == 0)
		return ENXIO;
    
	d_link = wd->d_link;
	if ((error = wdlock(d_link)) != 0)
		return error;

	if (wd->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((d_link->sc_flags & WDF_LOADED) == 0) {
			error = EIO;
			goto bad3;
		}
	} else {
		if ((d_link->sc_flags & WDF_LOADED) == 0) {
			d_link->sc_flags |= WDF_LOADED;

			/* Load the physical device parameters. */
			if (wdc_get_parms(d_link) != 0) {
				error = ENXIO;
				goto bad2;
			}

			/* Load the partition info if not already loaded. */
			wdgetdisklabel(dev, wd, wd->sc_dk.dk_label,
			    wd->sc_dk.dk_cpulabel, 0);
		}
	}

	part = WDPART(dev);

	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= wd->sc_dk.dk_label->d_npartitions ||
	     wd->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
		goto bad;
	}
    
	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	wd->sc_dk.dk_openmask = wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;

	wdunlock(d_link);
	return 0;

bad2:
	d_link->sc_flags &= ~WDF_LOADED;

bad:
	if (wd->sc_dk.dk_openmask == 0) {
	}

bad3:
	wdunlock(d_link);
	return error;
}

int
wdclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(dev)];
	int part = WDPART(dev);
	int error;
    
	if ((error = wdlock(wd->d_link)) != 0)
		return error;

	switch (fmt) {
	case S_IFCHR:
		wd->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		wd->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	wd->sc_dk.dk_openmask = wd->sc_dk.dk_copenmask | wd->sc_dk.dk_bopenmask;

	if (wd->sc_dk.dk_openmask == 0) {
		/* XXXX Must wait for I/O to complete! */
	}

	wdunlock(wd->d_link);
	return 0;
}

/*
 * Fabricate a default disk label, and try to read the correct one.
 */
void
wdgetdisklabel(dev, wd, lp, clp, spoofonly)
	dev_t dev;
	struct wd_softc *wd;
	struct disklabel *lp;
	struct cpu_disklabel *clp;
	int spoofonly;
{
	struct wd_link *d_link = wd->d_link;
	char *errstring;

	WDDEBUG_PRINT(("wdgetdisklabel\n"));

	bzero(lp, sizeof(struct disklabel));
	bzero(clp, sizeof(struct cpu_disklabel));

	lp->d_secsize = DEV_BSIZE;
	lp->d_ntracks = d_link->sc_params.wdp_heads;
	lp->d_nsectors = d_link->sc_params.wdp_sectors;
	lp->d_ncylinders = d_link->sc_params.wdp_cylinders;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;

	strncpy(lp->d_packname, d_link->sc_params.wdp_model, 16);
	if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA)) {
		lp->d_secperunit = d_link->sc_params.wdp_lbacapacity;
		strncpy(lp->d_typename, "ESDI/IDE disk", 16);
		lp->d_type = DTYPE_ESDI;
	} else {
		lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
		strncpy(lp->d_typename, "ST506/MFM/RLL", 16);
		lp->d_type = DTYPE_ST506;
	}

	lp->d_rpm = 3600;
	lp->d_interleave = 1;
	lp->d_flags = 0;

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	d_link->sc_badsect[0] = -1;

	if (d_link->sc_state > RECAL)
		d_link->sc_state = RECAL;

	/*
	 * Call the generic disklabel extraction routine
	 */
	errstring = readdisklabel(WDLABELDEV(dev), wdstrategy, lp, clp,
	    spoofonly);
	if (errstring) {
		/*
		 * This probably happened because the drive's default
		 * geometry doesn't match the DOS geometry.  We
		 * assume the DOS geometry is now in the label and try
		 * again.  XXX This is a kluge.
		 */
		if (d_link->sc_state > GEOMETRY)
			d_link->sc_state = GEOMETRY;
		errstring = readdisklabel(WDLABELDEV(dev), wdstrategy, lp, clp,
		    spoofonly);
	}
	if (errstring) {
		/*printf("%s: %s\n", wd->sc_dev.dv_xname, errstring);*/
		return;
	}

	if (d_link->sc_state > GEOMETRY)
		d_link->sc_state = GEOMETRY;
#ifdef DKBAD
	if ((lp->d_flags & D_BADSECT) != 0)
		bad144intern(wd);
#endif
}

/*
 * Tell the drive what geometry to use.
 */
int
wdsetctlr(d_link)
	struct wd_link *d_link;
{
	struct wd_softc *wd=(struct wd_softc *)d_link->wd_softc;

	WDDEBUG_PRINT(("wd(%d,%d) C%dH%dS%d\n", wd->sc_dev.dv_unit,
	    d_link->sc_drive, wd->sc_dk.dk_label->d_ncylinders,
	    wd->sc_dk.dk_label->d_ntracks, wd->sc_dk.dk_label->d_nsectors));

	if (wdccommand(d_link, WDCC_IDP, d_link->sc_drive,
	    wd->sc_dk.dk_label->d_ncylinders,
	    wd->sc_dk.dk_label->d_ntracks - 1, 0,
	    wd->sc_dk.dk_label->d_nsectors) != 0) {
		wderror(d_link, NULL, "wdsetctlr: geometry upload failed");
		return -1;
	}

	return 0;
}

int
wdioctl(dev, xfer, addr, flag, p)
	dev_t dev;
	u_long xfer;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct wd_softc *wd = wd_cd.cd_devs[WDUNIT(dev)];
	struct wd_link *d_link = wd->d_link;
	int error;

	WDDEBUG_PRINT(("wdioctl\n"));

	if ((d_link->sc_flags & WDF_LOADED) == 0)
		return EIO;

	switch (xfer) {
#ifdef DKBAD
	case DIOCSBAD:
		if ((flag & FWRITE) == 0)
			return EBADF;
		DKBAD(wd->sc_dk.dk_cpulabel) = *(struct dkbad *)addr;
		wd->sc_dk.dk_label->d_flags |= D_BADSECT;
		bad144intern(wd);
		return 0;
#endif

	case DIOCRLDINFO:
		wdgetdisklabel(dev, wd, wd->sc_dk.dk_label,
		    wd->sc_dk.dk_cpulabel, 0);
		return 0;
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			wdgetdisklabel(dev, wd, (struct disklabel *)addr,
			    &osdep, 1);
			return 0;
		}
	case DIOCGDINFO:
		*(struct disklabel *)addr = *(wd->sc_dk.dk_label);
		return 0;
	
	case DIOCGPART:
		((struct partinfo *)addr)->disklab = wd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &wd->sc_dk.dk_label->d_partitions[WDPART(dev)];
		return 0;
	
	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		if ((error = wdlock(wd->d_link)) != 0)
			return error;
		d_link->sc_flags |= WDF_LABELLING;

		error = setdisklabel(wd->sc_dk.dk_label,
		    (struct disklabel *)addr, /*wd->sc_dk.dk_openmask : */0,
		    wd->sc_dk.dk_cpulabel);
		if (error == 0) {
			if (d_link->sc_state > GEOMETRY)
				d_link->sc_state = GEOMETRY;
			if (xfer == DIOCWDINFO)
				error = writedisklabel(WDLABELDEV(dev),
				    wdstrategy, wd->sc_dk.dk_label,
				    wd->sc_dk.dk_cpulabel);
		}

		d_link->sc_flags &= ~WDF_LABELLING;
		wdunlock(d_link);
		return error;
	
	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return EBADF;
		if (*(int *)addr)
			d_link->sc_flags |= WDF_WLABEL;
		else
			d_link->sc_flags &= ~WDF_WLABEL;
		return 0;
	
#ifdef notyet
	case DIOCWFORMAT:
		if ((flag & FWRITE) == 0)
			return EBADF;
	{
		register struct format_op *fop;
		struct iovec aiov;
		struct uio auio;
	    
		fop = (struct format_op *)addr;
		aiov.iov_base = fop->df_buf;
		aiov.iov_len = fop->df_count;
		auio.uio_iov = &aiov;
		auio.uio_iovcnt = 1;
		auio.uio_resid = fop->df_count;
		auio.uio_segflg = 0;
		auio.uio_offset =
		    fop->df_startblk * wd->sc_dk.dk_label->d_secsize;
		auio.uio_procp = p;
		error = physio(wdformat, NULL, dev, B_WRITE, minphys,
		    &auio);
		fop->df_count -= auio.uio_resid;
		fop->df_reg[0] = wdc->sc_status;
		fop->df_reg[1] = wdc->sc_error;
		return error;
	}
#endif
	
	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("wdioctl: impossible");
#endif
}

#ifdef B_FORMAT
int
wdformat(struct buf *bp)
{

	bp->b_flags |= B_FORMAT;
	return wdstrategy(bp);
}
#endif

int
wdsize(dev)
	dev_t dev;
{
	struct wd_softc *wd;
	int part, unit, omask;
	int size;

	WDDEBUG_PRINT(("wdsize\n"));

	unit = WDUNIT(dev);
	if (unit >= wd_cd.cd_ndevs)
		return -1;
	wd = wd_cd.cd_devs[unit];
	if (wd == NULL)
		return -1;

	part = WDPART(dev);
	omask = wd->sc_dk.dk_openmask & (1 << part);

	if (omask == 0 && wdopen(dev, 0, S_IFBLK, NULL) != 0)
		return -1;
	else if (wd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
		size = -1;
	else
		size = wd->sc_dk.dk_label->d_partitions[part].p_size *
			(wd->sc_dk.dk_label->d_secsize / DEV_BSIZE);

	if (omask == 0 && wdclose(dev, 0, S_IFBLK, NULL) != 0)
		return -1;
	return size;
}


#ifndef __BDEVSW_DUMP_OLD_TYPE
/* #define WD_DUMP_NOT_TRUSTED if you just want to watch */
static int wddoingadump;
static int wddumprecalibrated;

/*
 * Dump core after a system crash.
 *
 * XXX:  This needs work!  Currently, it's a major hack: the
 * use of wdc_softc is very bad and should go away.
 */
int
wddump(dev, blkno, va, size)
        dev_t dev;
        daddr_t blkno;
        caddr_t va;
        size_t size;
{
	struct wd_softc *wd;	/* disk unit to do the I/O */
	struct wdc_softc *wdc;	/* disk controller to do the I/O */
	struct disklabel *lp;	/* disk's disklabel */
	struct wd_link *d_link;
	int	unit, part;
	int	nblks;		/* total number of sectors left to write */

	/* Check if recursive dump; if so, punt. */
	if (wddoingadump)
		return EFAULT;
	wddoingadump = 1;

	unit = WDUNIT(dev);
	if (unit >= wd_cd.cd_ndevs)
		return ENXIO;
	wd = wd_cd.cd_devs[unit];
	if (wd == (struct wd_softc *)0)
		return ENXIO;
	d_link = wd->d_link;

	part = WDPART(dev);

	/* Make sure it was initialized. */
	if (d_link->sc_state < READY)
		return ENXIO;

	wdc = (void *)wd->sc_dev.dv_parent;

        /* Convert to disk sectors.  Request must be a multiple of size. */
	lp = wd->sc_dk.dk_label;
	if ((size % lp->d_secsize) != 0)
		return EFAULT;
	nblks = size / lp->d_secsize;
	blkno = blkno / (lp->d_secsize / DEV_BSIZE);

	/* Check transfer bounds against partition size. */
	if ((blkno < 0) || ((blkno + nblks) > lp->d_partitions[part].p_size))
		return EINVAL;  

	/* Offset block number to start of partition. */
	blkno += lp->d_partitions[part].p_offset;

	/* Recalibrate, if first dump transfer. */
	if (wddumprecalibrated == 0) {
		wddumprecalibrated = 1;
		if (wdccommandshort(wdc, d_link->sc_drive, WDCC_RECAL) != 0 ||
		    wait_for_ready(wdc) != 0 || wdsetctlr(d_link) != 0 ||
		    wait_for_ready(wdc) != 0) {
			wderror(d_link, NULL, "wddump: recal failed");
			return EIO;
		}
	}
   
	while (nblks > 0) {
		daddr_t xlt_blkno = blkno;
		int cylin, head, sector;

		if ((lp->d_flags & D_BADSECT) != 0) {
			int blkdiff;
			int i;

			for (i = 0; (blkdiff = d_link->sc_badsect[i]) != -1; i++) {
				blkdiff -= xlt_blkno;
				if (blkdiff < 0)
					continue;
				if (blkdiff == 0) {
					/* Replace current block of transfer. */
					xlt_blkno = lp->d_secperunit -
					    lp->d_nsectors - i - 1;
				}
				break;
			}
			/* Tranfer is okay now. */
		}

		if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA) != 0) {
			sector = (xlt_blkno >> 0) & 0xff;
			cylin = (xlt_blkno >> 8) & 0xffff;
			head = (xlt_blkno >> 24) & 0xf;
			head |= WDSD_LBA;
		} else {
			sector = xlt_blkno % lp->d_nsectors;
			sector++;	/* Sectors begin with 1, not 0. */
			xlt_blkno /= lp->d_nsectors;
			head = xlt_blkno % lp->d_ntracks;
			xlt_blkno /= lp->d_ntracks;
			cylin = xlt_blkno;
			head |= WDSD_CHS;
		}

#ifndef WD_DUMP_NOT_TRUSTED
		if (wdccommand(d_link, WDCC_WRITE, d_link->sc_drive, cylin,
		    head, sector, 1) != 0 ||
		    wait_for_drq(wdc) != 0) {
			wderror(d_link, NULL, "wddump: write failed");
			return EIO;
		}
	
		/* XXX XXX XXX */
		bus_space_write_multi_2(wdc->sc_iot, wdc->sc_ioh, wd_data,
		    (u_int16_t *)va, lp->d_secsize >> 1);
	
		/* Check data request (should be done). */
		if (wait_for_ready(wdc) != 0) {
			wderror(d_link, NULL,
			    "wddump: timeout waiting for ready");
			return EIO;
		}
#else	/* WD_DUMP_NOT_TRUSTED */
		/* Let's just talk about this first... */
		printf("wd%d: dump addr 0x%x, cylin %d, head %d, sector %d\n",
		    unit, va, cylin, head, sector);
		delay(500 * 1000);	/* half a second */
#endif

		/* update block count */
		nblks -= 1;
		blkno += 1;
		va += lp->d_secsize;
	}

	wddoingadump = 0;
	return 0;
}
#else /* __BDEVSW_DUMP_NEW_TYPE */


int
wddump(dev, blkno, va, size)
        dev_t dev;
        daddr_t blkno;
        caddr_t va;
        size_t size;
{

	/* Not implemented. */
	return ENXIO;
}
#endif /* __BDEVSW_DUMP_NEW_TYPE */

#ifdef DKBAD
/*
 * Internalize the bad sector table.
 */
void
bad144intern(wd)
	struct wd_softc *wd;
{
	struct dkbad *bt = &DKBAD(wd->sc_dk.dk_cpulabel);
	struct disklabel *lp = wd->sc_dk.dk_label;
	struct wd_link *d_link = wd->d_link;
	int i = 0;

	WDDEBUG_PRINT(("bad144intern\n"));

	for (; i < 126; i++) {
		if (bt->bt_bad[i].bt_cyl == 0xffff)
			break;
		d_link->sc_badsect[i] =
		    bt->bt_bad[i].bt_cyl * lp->d_secpercyl +
		    (bt->bt_bad[i].bt_trksec >> 8) * lp->d_nsectors +
		    (bt->bt_bad[i].bt_trksec & 0xff);
	}
	for (; i < 127; i++)
		d_link->sc_badsect[i] = -1;
}
#endif

void
wderror(d_link, bp, msg)
	struct wd_link *d_link;
	struct buf *bp;
	char *msg;
{
	struct wd_softc *wd = (struct wd_softc *)d_link->wd_softc;

	if (bp) {
		diskerr(bp, "wd", msg, LOG_PRINTF, bp->b_bcount,
		    wd->sc_dk.dk_label);
		printf("\n");
	} else
		printf("%s: %s\n", wd->sc_dev.dv_xname, msg);
}

void
wddone(d_link, bp)
	struct wd_link *d_link;
	struct buf *bp;
{
	struct wd_softc *wd = (void *)d_link->wd_softc;

	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));
}
@


1.41
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.40 1999/05/09 20:40:43 weingart Exp $	*/
@


1.40
log
@Fix wdsize() to not call wdopen/wdclose unless it is needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.39 1999/02/25 17:14:12 millert Exp $	*/
d664 4
@


1.39
log
@Fix autosetting of d_type and d_typename that I introduced in rev
1.36.  Checking wdp_config for WD_CFG_FIXED is incorrect.  Default
to ESDI/IDE if WD_CAP_LBA is set in wdp_capabilities instead.  Also,
set d_typename for non-IDE/ESDI to "ST506/MFM/RLL" not "ST506/MFM/RLL
di" (the latter caused by truncation to 16 characters).
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.38 1998/10/04 01:46:42 millert Exp $	*/
d767 1
a767 1
	int part;
d772 5
a776 1
	if (wdopen(dev, 0, S_IFBLK, NULL) != 0)
d778 1
a778 1
	wd = wd_cd.cd_devs[WDUNIT(dev)];
d780 5
a784 1
	if (wd->sc_dk.dk_label->d_partitions[part].p_fstype != FS_SWAP)
d787 4
a790 2
		size = wd->sc_dk.dk_label->d_partitions[part].p_size;
	if (wdclose(dev, 0, S_IFBLK, NULL) != 0)
@


1.38
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.37 1998/10/03 21:19:00 millert Exp $	*/
d552 3
a554 4
	if (d_link->sc_params.wdp_config == WD_CFG_FIXED) {
		strncpy(lp->d_typename, "ST506/MFM/RLL disk", 16);
		lp->d_type = DTYPE_ST506;
	} else {
d557 4
a561 5
	strncpy(lp->d_packname, d_link->sc_params.wdp_model, 16);
	if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA))
		lp->d_secperunit = d_link->sc_params.wdp_lbacapacity;
	else 
		lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
@


1.37
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.36 1998/10/01 04:23:54 millert Exp $	*/
d95 2
a96 1
void	wdgetdisklabel	__P((dev_t, struct wd_softc *));
d455 2
a456 1
			wdgetdisklabel(dev, wd);
d531 1
a531 1
wdgetdisklabel(dev, wd)
d534 3
a537 1
	struct disklabel *lp = wd->sc_dk.dk_label;
d544 1
a544 1
	bzero(wd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d583 6
a588 2
	errstring = readdisklabel(WDLABELDEV(dev), wdstrategy, lp,
	    wd->sc_dk.dk_cpulabel, 0);
d598 2
a599 2
		errstring = readdisklabel(WDLABELDEV(dev), wdstrategy, lp,
		    wd->sc_dk.dk_cpulabel, 0);
a613 1

d666 7
@


1.36
log
@Set d_type properly in spoofed labels
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.35 1998/08/06 09:57:09 downsj Exp $	*/
d580 1
a580 1
	    wd->sc_dk.dk_cpulabel);
d591 1
a591 1
		    wd->sc_dk.dk_cpulabel);
@


1.35
log
@Use single line geometry printing.  Looks just like sd, now.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.34 1998/07/23 05:27:37 csapuntz Exp $	*/
d548 7
a554 4
#if 0
	strncpy(lp->d_typename, "ST506 disk", 16);
	lp->d_type = DTYPE_ST506;
#endif
d556 4
a559 4
	if ((d_link->sc_params.wdp_capabilities & WD_CAP_LBA)) {
	  lp->d_secperunit = d_link->sc_params.wdp_lbacapacity;
	} else 
	  lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
@


1.34
log
@

Support drives > 8.4GB

For LBA-capable drives, return the number of LBA sectors as secperunit, not
the number you get from CHS.

Note, DOS partition tables are limited to 8.4GB. The interactive
disklabel editor will notice that the OpenBSD partition ends at 8.4GB and
limit the user to that size unless the user explicitly specifies the bounds.
This should probably be changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.33 1998/07/23 04:40:11 csapuntz Exp $	*/
d179 10
a188 9

			printf("%s: %dMB, %d sec, %d bytes/sec (%dKB cache)\n",
			       self->dv_xname,
			       d_link->sc_params.wdp_lbacapacity / 2048,
			       d_link->sc_params.wdp_lbacapacity,
			       DEV_BSIZE, /* XXX */
			       d_link->sc_params.wdp_bufsize / 2);

			printf ("%s: %d cyl, %d head, %d sec\n",
d190 3
d195 5
a199 13
				d_link->sc_params.wdp_sectors);
		}
		else {
			printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec (%dKB cache)\n",
			       self->dv_xname,
			       d_link->sc_params.wdp_cylinders *
			       (d_link->sc_params.wdp_heads *
				d_link->sc_params.wdp_sectors) / (1048576 / DEV_BSIZE),
			       d_link->sc_params.wdp_cylinders,
			       d_link->sc_params.wdp_heads,
			       d_link->sc_params.wdp_sectors,
			       DEV_BSIZE,
			       d_link->sc_params.wdp_bufsize / 2);
d227 1
a227 1
		printf(" lba addressing\n");
d229 4
a232 1
		printf(" chs addressing\n");
@


1.33
log
@

Print LBA-based size as well as CHS size.

Fix some bugs in getting drive parameters into the wdparams array
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.32 1997/12/10 23:09:37 rees Exp $	*/
d554 5
a558 1
	lp->d_secperunit = lp->d_secpercyl * lp->d_ncylinders;
@


1.32
log
@Compute blkno in ata_start routine instead of wdstart
(see bug list in wdc.c change log)
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.31 1997/10/18 21:09:57 deraadt Exp $	*/
d178 27
a204 10
		printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec (%dKB cache)\n",
		    self->dv_xname,
		    d_link->sc_params.wdp_cylinders *
		    (d_link->sc_params.wdp_heads *
		     d_link->sc_params.wdp_sectors) / (1048576 / DEV_BSIZE),
		    d_link->sc_params.wdp_cylinders,
		    d_link->sc_params.wdp_heads,
		    d_link->sc_params.wdp_sectors,
		    DEV_BSIZE,
		    d_link->sc_params.wdp_bufsize / 2);
d213 7
a219 7
	if (d_link->sc_params.wdp_maxmulti > 1) {
		d_link->sc_mode = WDM_PIOMULTI;
		d_link->sc_multiple = min(d_link->sc_params.wdp_maxmulti, 16);
	} else {
		d_link->sc_mode = WDM_PIOSINGLE;
		d_link->sc_multiple = 1;
	}
d228 2
a229 2
		    d_link->sc_multiple,
		    (d_link->sc_flags & WDF_32BIT) == 0 ? 16 : 32);
@


1.31
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.30 1997/10/18 10:37:14 deraadt Exp $	*/
a313 1
		xfer->c_bcount = bp->b_bcount;
d315 3
a317 1
		xfer->c_blkno = bp->b_blkno;
@


1.30
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.29 1997/09/13 14:18:44 niklas Exp $	*/
d570 1
a570 1
		*/printf("%s: %s\n", wd->sc_dev.dv_xname, errstring);*/
@


1.29
log
@move int error out of ifdef DKBAD, it was used elsewhere
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.28 1997/08/08 22:00:10 niklas Exp $	*/
d570 1
a570 1
		printf("%s: %s\n", wd->sc_dev.dv_xname, errstring);
@


1.28
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.27 1997/08/08 21:47:03 niklas Exp $	*/
a616 1
#ifdef DKBAD
a617 1
#endif
@


1.27
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.26 1997/07/06 18:10:17 niklas Exp $	*/
d255 1
a255 1
	    wdd->sc_dk.dk_cpulabel,
@


1.26
log
@get rid of long, and let alpha grok the bad sectoring
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.25 1997/04/18 06:12:23 niklas Exp $	*/
d107 1
a107 1
#if !defined(amiga)
d255 1
d576 1
a576 1
#if !defined(amiga)
d617 1
a617 1
#ifndef amiga
d627 1
a627 1
#if !defined(amiga)
d631 1
a631 1
		wd->sc_dk.dk_cpulabel->bad = *(struct dkbad *)addr;
a646 1
#ifndef amiga
a707 1
#endif
d910 1
a910 1
#if !defined(amiga)
d918 1
a918 1
	struct dkbad *bt = &wd->sc_dk.dk_cpulabel->bad;
@


1.25
log
@alpha is like amiga in the sense it doesn't support bad block lists.
This ought to be done differently, but for now this will suffice.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.24 1997/01/04 08:50:24 deraadt Exp $	*/
d107 1
a107 1
#if !defined(amiga) && !defined(alpha)
d285 1
a285 1
	u_long p_offset; 
d575 1
a575 1
#if !defined(amiga) && !defined(alpha)
d626 1
a626 1
#if !defined(amiga) && !defined(alpha)
d826 1
a826 1
		long cylin, head, sector;
d829 1
a829 1
			long blkdiff;
d911 1
a911 1
#if !defined(amiga) && !defined(alpha)
@


1.24
log
@readdisklabel() with correct dev_t
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.23 1996/11/29 22:55:08 niklas Exp $	*/
d107 1
a107 1
#ifndef amiga
d575 1
a575 1
#ifndef amiga
d626 1
a626 1
#ifndef amiga
d911 1
a911 1
#ifndef amiga
@


1.23
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.22 1996/11/28 08:23:38 downsj Exp $	*/
d95 1
a95 1
void	wdgetdisklabel	__P((struct wd_softc *));
d436 1
a436 1
			wdgetdisklabel(wd);
d511 2
a512 1
wdgetdisklabel(wd)
d554 2
a555 2
	errstring = readdisklabel(MAKEWDDEV(0, wd->sc_dev.dv_unit, RAW_PART),
	    wdstrategy, lp, wd->sc_dk.dk_cpulabel);
d565 2
a566 2
		errstring = readdisklabel(MAKEWDDEV(0, wd->sc_dev.dv_unit, RAW_PART),
		    wdstrategy, lp, wd->sc_dk.dk_cpulabel);
@


1.22
log
@Pull in laptop changes from cgd, a couple from me, and a few slight formatting
nits.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.21 1996/11/23 21:46:48 kstailey Exp $	*/
d56 1
a56 1
#include <machine/bus.old.h>
d861 2
a862 1
		if (wdccommand(d_link, WDCC_WRITE, d_link->sc_drive, cylin, head, sector, 1) != 0 ||
d869 1
a869 1
		bus_io_write_multi_2(wdc->sc_bc, wdc->sc_ioh, wd_data,
@


1.21
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.20 1996/11/12 20:30:43 niklas Exp $	*/
d793 1
a793 1
	if (d_link->sc_state < OPEN)
@


1.20
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.19 1996/09/22 09:02:32 downsj Exp $	*/
d85 1
a85 1
int	wdprint		__P((void *, char *));
@


1.19
log
@Get some things ready for later.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.18 1996/09/16 02:36:10 downsj Exp $	*/
d56 1
a56 1
#include <machine/bus.h>
@


1.18
log
@pretty pretty pointless support
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.17 1996/08/07 01:53:01 downsj Exp $	*/
d178 1
a178 1
		printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
d186 2
a187 1
		    DEV_BSIZE);
@


1.17
log
@bus.h using wd/wdc drivers, by niklas.  IDE now works on both i386 and amiga.
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.16 1996/06/09 08:59:55 downsj Exp $	*/
d177 11
a187 9
	printf("%s: %dMB, %d cyl, %d head, %d sec, %d bytes/sec\n",
	    self->dv_xname,
	    d_link->sc_params.wdp_cylinders *
	    (d_link->sc_params.wdp_heads * d_link->sc_params.wdp_sectors) /
	    (1048576 / DEV_BSIZE),
	    d_link->sc_params.wdp_cylinders,
	    d_link->sc_params.wdp_heads,
	    d_link->sc_params.wdp_sectors,
	    DEV_BSIZE);
@


1.16
log
@acd.c: Removed some pointless code, cleaned up some more debug statements.
everything: added RCS ids.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d36 2
d56 1
a58 1
#include <machine/pio.h>
a97 1
void	wdstart		__P((struct wd_softc *));
d107 1
d109 1
a117 1
	caddr_t *wdc = (void *)parent;
a139 1
	struct caddr_t *wdc = (void *)parent;
d187 1
d191 3
a193 1
	} else if (d_link->sc_params.wdp_maxmulti > 1) {
d202 1
d206 1
d274 2
a275 2
wdstart(wd)
	struct wd_softc *wd;
d277 1
a281 1
	int blkno, nblks;
d571 1
d574 1
d612 1
d614 1
d622 1
d630 1
d642 1
d704 1
d865 2
a866 1
		outsw(wdc->sc_iobase + wd_data, va, lp->d_secsize >> 1);
d906 1
d932 1
@


1.15
log
@Initial support ATAPI CD-ROMs.

Based on Manuel Bouyer's drivers.
@
text
@d1 1
@


1.14
log
@all ports have dk_establish()
@
text
@d1 1
a1 2
/*	$OpenBSD: wd.c,v 1.13 1996/05/26 00:27:31 deraadt Exp $	*/
/*	$NetBSD: wd.c,v 1.150 1996/05/12 23:54:03 mycroft Exp $	*/
a57 1
#include <dev/isa/isadmavar.h>
d59 1
a59 13

#define	WAITTIME	(8 * hz)	/* time to wait for a completion
					   (long enough for disk spin-ups) */
#define	RECOVERYTIME	(hz / 2)	/* time to recover from an error */

#define WDCDELAY	100
#define WDCNDELAY	100000		/* delay = 100us; so 10s for a controller state change */
#if 0
/* If you enable this, it will report any delays more than 100us * N long. */
#define WDCNDELAY_DEBUG	10
#endif

#define	WDIORETRIES	3		/* number of retries before giving up */
d67 6
d76 1
a76 37

	/* Information about the current transfer: */
	daddr_t sc_blkno;	/* starting block number */
	int sc_bcount;		/* byte count left */
	int sc_skip;		/* bytes already transferred */
	int sc_nblks;		/* number of blocks currently transferring */
	int sc_nbytes;		/* number of bytes currently transferring */

	/* Long-term state: */
	int sc_drive;			/* physical unit number */
	int sc_state;			/* control state */
#define	RECAL		0		/* recalibrate */
#define	RECAL_WAIT	1		/* done recalibrating */
#define	GEOMETRY	2		/* upload geometry */
#define	GEOMETRY_WAIT	3		/* done uploading geometry */
#define	MULTIMODE	4		/* set multiple mode */
#define	MULTIMODE_WAIT	5		/* done setting multiple mode */
#define	OPEN		6		/* done with open */
	int sc_mode;			/* transfer mode */
#define	WDM_PIOSINGLE	0		/* single-sector PIO */
#define	WDM_PIOMULTI	1		/* multi-sector PIO */
#define	WDM_DMA		2		/* DMA */
	int sc_multiple;		/* multiple for WDM_PIOMULTI */
	int sc_flags;			/* drive characteistics found */
#define	WDF_LOCKED	0x01
#define	WDF_WANTED	0x02
#define	WDF_WLABEL	0x04		/* label is writable */
#define	WDF_LABELLING	0x08		/* writing label */
/* XXX Nothing resets this yet, but disk change sensing will when ATAPI is
   implemented. */
#define	WDF_LOADED	0x10		/* parameters loaded */
#define	WDF_32BIT	0x20		/* can do 32-bit transfer */

	struct wdparams sc_params;	/* ESDI/ATA drive parameters */
	daddr_t	sc_badsect[127];	/* 126 plus trailing -1 marker */

	TAILQ_ENTRY(wd_softc) sc_drivechain;
d80 3
a82 33
struct wdc_softc {
	struct device sc_dev;
	void *sc_ih;

	int sc_iobase;			/* I/O port base */
	int sc_drq;			/* DMA channel */

	TAILQ_HEAD(drivehead, wd_softc) sc_drives;
	int sc_flags;
#define	WDCF_ACTIVE	0x01		/* controller is active */
#define	WDCF_SINGLE	0x02		/* sector at a time mode */
#define	WDCF_ERROR	0x04		/* processing a disk error */
#define	WDCF_WANTED	0x08		/* XXX locking for wd_get_parms() */
	int sc_errors;			/* errors during current transfer */
	u_char sc_status;		/* copy of status register */
	u_char sc_error;		/* copy of error register */
};

int	wdcprobe 	__P((struct device *, void *, void *));
void	wdcattach 	__P((struct device *, struct device *, void *));
int	wdcintr		__P((void *));

struct cfattach wdc_ca = {
	sizeof(struct wdc_softc), wdcprobe, wdcattach
};

struct cfdriver wdc_cd = {
	NULL, "wdc", DV_DULL
};

int wdprobe __P((struct device *, void *, void *));
void wdattach __P((struct device *, struct device *, void *));
int wdprint __P((void *, char *));
d104 1
a104 6
int 	dcintr		__P((void *));
void	wdcstart	__P((struct wdc_softc *));
int	wdcommand	__P((struct wd_softc *, int, int, int, int, int));
int	wdcommandshort	__P((struct wdc_softc *, int, int));
int	wdcontrol	__P((struct wd_softc *));
int	wdsetctlr	__P((struct wd_softc *));
d106 2
a107 14
int	wdcreset	__P((struct wdc_softc *));
void	wdcrestart	__P((void *arg));
void	wdcunwedge	__P((struct wdc_softc *));
void	wdctimeout	__P((void *arg));
void	wderror		__P((void *, struct buf *, char *));
int	wdcwait		__P((struct wdc_softc *, int));
int	wdlock		__P((struct wd_softc *));
void	wdunlock	__P((struct wd_softc *));

/* ST506 spec says that if READY or SEEKCMPLT go off, then the read or write
   command is aborted. */
#define	wait_for_drq(d)		wdcwait(d, WDCS_DRDY | WDCS_DSC | WDCS_DRQ)
#define	wait_for_ready(d)	wdcwait(d, WDCS_DRDY | WDCS_DSC)
#define	wait_for_unbusy(d)	wdcwait(d, 0)
d110 1
a110 1
wdcprobe(parent, match, aux)
d114 6
a119 10
	struct wdc_softc *wdc = match;
	struct isa_attach_args *ia = aux;
	int iobase;

	wdc->sc_iobase = iobase = ia->ia_iobase;

	/* Check if we have registers that work. */
	outb(iobase+wd_error, 0x5a);	/* Error register not writable, */
	outb(iobase+wd_cyl_lo, 0xa5);	/* but all of cyllo are. */
	if (inb(iobase+wd_error) == 0x5a || inb(iobase+wd_cyl_lo) != 0xa5)
d121 1
a121 19

	if (wdcreset(wdc) != 0) {
		delay(500000);
		if (wdcreset(wdc) != 0)
			return 0;
	}

	/* Select drive 0. */
	outb(iobase+wd_sdh, WDSD_IBM | 0);

	/* Wait for controller to become ready. */
	if (wait_for_unbusy(wdc) < 0)
		return 0;
    
	/* Start drive diagnostics. */
	outb(iobase+wd_command, WDCC_DIAGNOSE);

	/* Wait for command to complete. */
	if (wait_for_unbusy(wdc) < 0)
d124 1
a124 52
	ia->ia_iosize = 8;
	ia->ia_msize = 0;
	return 1;
}

struct wdc_attach_args {
	int wa_drive;
};

int
wdprint(aux, wdc)
	void *aux;
	char *wdc;
{
	struct wdc_attach_args *wa = aux;

	if (!wdc)
		printf(" drive %d", wa->wa_drive);
	return QUIET;
}

void
wdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wdc_softc *wdc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct wdc_attach_args wa;

	TAILQ_INIT(&wdc->sc_drives);
	wdc->sc_drq = ia->ia_drq;

	printf("\n");

	wdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, wdcintr, wdc, wdc->sc_dev.dv_xname);

	for (wa.wa_drive = 0; wa.wa_drive < 2; wa.wa_drive++)
		(void)config_found(self, (void *)&wa, wdprint);
}

int
wdprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct wdc_softc *wdc = (void *)parent;
	struct cfdata *cf = match;
	struct wdc_attach_args *wa = aux;
	int drive = wa->wa_drive;

a126 4
	
	if (wdcommandshort(wdc, drive, WDCC_RECAL) != 0 ||
	    wait_for_ready(wdc) != 0)
		return 0;
d137 2
a138 2
	struct wdc_softc *wdc = (void *)parent;
	struct wdc_attach_args *wa = aux;
d142 3
a144 1
	wd->sc_drive = wa->wa_drive;
d155 5
a159 3
	wd_get_parms(wd);
	for (blank = 0, p = wd->sc_params.wdp_model, q = buf, i = 0;
	     i < sizeof(wd->sc_params.wdp_model); i++) {
d174 5
a178 3
	printf(": %dMB, %d cyl, %d head, %d sec, %d bytes/sec <%s>\n",
	    wd->sc_params.wdp_cylinders *
	    (wd->sc_params.wdp_heads * wd->sc_params.wdp_sectors) /
d180 11
a190 12
	    wd->sc_params.wdp_cylinders,
	    wd->sc_params.wdp_heads,
	    wd->sc_params.wdp_sectors,
	    DEV_BSIZE,
	    buf);

	if ((wd->sc_params.wdp_capabilities & WD_CAP_DMA) != 0 &&
	    wdc->sc_drq != DRQUNK) {
		wd->sc_mode = WDM_DMA;
	} else if (wd->sc_params.wdp_maxmulti > 1) {
		wd->sc_mode = WDM_PIOMULTI;
		wd->sc_multiple = min(wd->sc_params.wdp_maxmulti, 16);
d192 2
a193 2
		wd->sc_mode = WDM_PIOSINGLE;
		wd->sc_multiple = 1;
d197 1
a197 1
	if (wd->sc_mode == WDM_DMA)
d201 3
a203 2
		    wd->sc_multiple, (wd->sc_flags & WDF_32BIT) == 0 ? 16 : 32);
	if ((wd->sc_params.wdp_capabilities & WD_CAP_LBA) != 0)
d218 1
d230 1
a230 1
	if ((wd->sc_flags & WDF_LOADED) == 0) {
d245 1
a245 1
	    (wd->sc_flags & (WDF_WLABEL|WDF_LABELLING)) != 0) <= 0)
d251 1
a251 11
	if (!wd->sc_q.b_active)
		wdstart(wd);
#if 0
	else {
		struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
		if ((wdc->sc_flags & (WDCF_ACTIVE|WDCF_ERROR)) == 0) {
			printf("wdstrategy: controller inactive\n");
			wdcstart(wdc);
		}
	}
#endif
d270 24
a293 2
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
	int active = wdc->sc_drives.tqh_first != 0;
d295 11
a305 5
	/* Link onto controller queue. */
	wd->sc_q.b_active = 1;
	TAILQ_INSERT_TAIL(&wdc->sc_drives, wd, sc_drivechain);
    
	disk_busy(&wd->sc_dk);
d307 3
a309 28
	/* If controller not already active, start it. */
	if (!active)
		wdcstart(wdc);
}

/*
 * Finish an I/O operation.  Clean up the drive and controller state, set the
 * residual count, and inform the upper layers that the operation is complete.
 */
void
wdfinish(wd, bp)
	struct wd_softc *wd;
	struct buf *bp;
{
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;

	wdc->sc_flags &= ~(WDCF_SINGLE | WDCF_ERROR);
	wdc->sc_errors = 0;
	/*
	 * Move this drive to the end of the queue to give others a `fair'
	 * chance.
	 */
	if (wd->sc_drivechain.tqe_next) {
		TAILQ_REMOVE(&wdc->sc_drives, wd, sc_drivechain);
		if (bp->b_actf) {
			TAILQ_INSERT_TAIL(&wdc->sc_drives, wd, sc_drivechain);
		} else
			wd->sc_q.b_active = 0;
a310 13
	bp->b_resid = wd->sc_bcount;
	wd->sc_skip = 0;
	wd->sc_q.b_actf = bp->b_actf;

	disk_unbusy(&wd->sc_dk, (bp->b_bcount - bp->b_resid));

	if (!wd->sc_q.b_actf) {
		TAILQ_REMOVE(&wdc->sc_drives, wd, sc_drivechain);
		wd->sc_q.b_active = 0;
	} else
		disk_busy(&wd->sc_dk);

	biodone(bp);
d320 1
d331 1
a335 361
 * Start I/O on a controller.  This does the calculation, and starts a read or
 * write operation.  Called to from wdstart() to start a transfer, from
 * wdcintr() to continue a multi-sector transfer or start the next transfer, or
 * wdcrestart() after recovering from an error.
 */
void
wdcstart(wdc)
	struct wdc_softc *wdc;
{
	struct wd_softc *wd;
	struct buf *bp;
	struct disklabel *lp;
	int nblks;

#ifdef DIAGNOSTIC
	if ((wdc->sc_flags & WDCF_ACTIVE) != 0)
		panic("wdcstart: controller still active");
#endif

	/*
	 * XXX
	 * This is a kluge.  See comments in wd_get_parms().
	 */
	if ((wdc->sc_flags & WDCF_WANTED) != 0) {
		wdc->sc_flags &= ~WDCF_WANTED;
		wakeup(wdc);
		return;
	}

loop:
	/* Is there a drive for the controller to do a transfer with? */
	wd = wdc->sc_drives.tqh_first;
	if (wd == NULL)
		return;
    
	/* Is there a transfer to this drive?  If not, deactivate drive. */
	bp = wd->sc_q.b_actf;
    
	if (wdc->sc_errors >= WDIORETRIES) {
		wderror(wd, bp, "hard error");
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		wdfinish(wd, bp);
		goto loop;
	}

	/* Do control operations specially. */
	if (wd->sc_state < OPEN) {
		/*
		 * Actually, we want to be careful not to mess with the control
		 * state if the device is currently busy, but we can assume
		 * that we never get to this point if that's the case.
		 */
		if (wdcontrol(wd) == 0) {
			/* The drive is busy.  Wait. */
			return;
		}
	}

	/*
	 * WDCF_ERROR is set by wdcunwedge() and wdcintr() when an error is
	 * encountered.  If we are in multi-sector mode, then we switch to
	 * single-sector mode and retry the operation from the start.
	 */
	if (wdc->sc_flags & WDCF_ERROR) {
		wdc->sc_flags &= ~WDCF_ERROR;
		if ((wdc->sc_flags & WDCF_SINGLE) == 0) {
			wdc->sc_flags |= WDCF_SINGLE;
			wd->sc_skip = 0;
		}
	}

	lp = wd->sc_dk.dk_label;

	/* When starting a transfer... */
	if (wd->sc_skip == 0) {
		int part = WDPART(bp->b_dev);
		daddr_t blkno;

#ifdef WDDEBUG
		printf("\n%s: wdcstart %s %d@@%d; map ", wd->sc_dev.dv_xname,
		    (bp->b_flags & B_READ) ? "read" : "write", bp->b_bcount,
		    bp->b_blkno);
#endif
		wd->sc_bcount = bp->b_bcount;
		blkno = bp->b_blkno;
		if (part != RAW_PART)
			blkno += lp->d_partitions[part].p_offset;
		wd->sc_blkno = blkno / (lp->d_secsize / DEV_BSIZE);
	} else {
#ifdef WDDEBUG
		printf(" %d)%x", wd->sc_skip, inb(wdc->sc_iobase+wd_altsts));
#endif
	}

	/* When starting a multi-sector transfer, or doing single-sector
	    transfers... */
	if (wd->sc_skip == 0 || (wdc->sc_flags & WDCF_SINGLE) != 0 ||
	    wd->sc_mode == WDM_DMA) {
		daddr_t blkno = wd->sc_blkno;
		long cylin, head, sector;
		int command;

		if ((wdc->sc_flags & WDCF_SINGLE) != 0)
			nblks = 1;
		else if (wd->sc_mode != WDM_DMA)
			nblks = wd->sc_bcount / lp->d_secsize;
		else
			nblks = min(wd->sc_bcount / lp->d_secsize, 8);

		/* Check for bad sectors and adjust transfer, if necessary. */
		if ((lp->d_flags & D_BADSECT) != 0
#ifdef B_FORMAT
		    && (bp->b_flags & B_FORMAT) == 0
#endif
		    ) {
			long blkdiff;
			int i;

			for (i = 0; (blkdiff = wd->sc_badsect[i]) != -1; i++) {
				blkdiff -= blkno;
				if (blkdiff < 0)
					continue;
				if (blkdiff == 0) {
					/* Replace current block of transfer. */
					blkno =
					    lp->d_secperunit - lp->d_nsectors - i - 1;
				}
				if (blkdiff < nblks) {
					/* Bad block inside transfer. */
					wdc->sc_flags |= WDCF_SINGLE;
					nblks = 1;
				}
				break;
			}
			/* Tranfer is okay now. */
		}

		if ((wd->sc_params.wdp_capabilities & WD_CAP_LBA) != 0) {
			sector = (blkno >> 0) & 0xff;
			cylin = (blkno >> 8) & 0xffff;
			head = (blkno >> 24) & 0xf;
			head |= WDSD_LBA;
		} else {
			sector = blkno % lp->d_nsectors;
			sector++;	/* Sectors begin with 1, not 0. */
			blkno /= lp->d_nsectors;
			head = blkno % lp->d_ntracks;
			blkno /= lp->d_ntracks;
			cylin = blkno;
			head |= WDSD_CHS;
		}

		if (wd->sc_mode == WDM_PIOSINGLE ||
		    (wdc->sc_flags & WDCF_SINGLE) != 0)
			wd->sc_nblks = 1;
		else if (wd->sc_mode == WDM_PIOMULTI)
			wd->sc_nblks = min(nblks, wd->sc_multiple);
		else
			wd->sc_nblks = nblks;
		wd->sc_nbytes = wd->sc_nblks * lp->d_secsize;
    
#ifdef B_FORMAT
		if (bp->b_flags & B_FORMAT) {
			sector = lp->d_gap3;
			nblks = lp->d_nsectors;
			command = WDCC_FORMAT;
		} else
#endif
		switch (wd->sc_mode) {
		case WDM_DMA:
			command = (bp->b_flags & B_READ) ?
			    WDCC_READDMA : WDCC_WRITEDMA;
			/* Start the DMA channel and bounce the buffer if
			   necessary. */
			isa_dmastart(
			    bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE,
			    bp->b_data + wd->sc_skip,
			    wd->sc_nbytes, wdc->sc_drq);
			break;
		case WDM_PIOMULTI:
			command = (bp->b_flags & B_READ) ?
			    WDCC_READMULTI : WDCC_WRITEMULTI;
			break;
		case WDM_PIOSINGLE:
			command = (bp->b_flags & B_READ) ?
			    WDCC_READ : WDCC_WRITE;
			break;
		default:
#ifdef DIAGNOSTIC
			panic("bad wd mode");
#endif
			return;
		}
	
		/* Initiate command! */
		if (wdcommand(wd, command, cylin, head, sector, nblks) != 0) {
			wderror(wd, NULL,
			    "wdcstart: timeout waiting for unbusy");
			wdcunwedge(wdc);
			return;
		}

#ifdef WDDEBUG
		printf("sector %d cylin %d head %d addr %x sts %x\n", sector,
		    cylin, head, bp->b_data, inb(wdc->sc_iobase+wd_altsts));
#endif
	} else if (wd->sc_nblks > 1) {
		/* The number of blocks in the last stretch may be smaller. */
		nblks = wd->sc_bcount / lp->d_secsize;
		if (wd->sc_nblks > nblks) {
			wd->sc_nblks = nblks;
			wd->sc_nbytes = wd->sc_bcount;
		}
	}

	/* If this was a write and not using DMA, push the data. */
	if (wd->sc_mode != WDM_DMA &&
	    (bp->b_flags & (B_READ|B_WRITE)) == B_WRITE) {
		if (wait_for_drq(wdc) < 0) {
			wderror(wd, NULL, "wdcstart: timeout waiting for drq");
			wdcunwedge(wdc);
			return;
		}

		/* Push out data. */
		if ((wd->sc_flags & WDF_32BIT) == 0)
			outsw(wdc->sc_iobase+wd_data, bp->b_data + wd->sc_skip,
			    wd->sc_nbytes >> 1);
		else
			outsl(wdc->sc_iobase+wd_data, bp->b_data + wd->sc_skip,
			    wd->sc_nbytes >> 2);
	}

	wdc->sc_flags |= WDCF_ACTIVE;
	timeout(wdctimeout, wdc, WAITTIME);
}

/*
 * Interrupt routine for the controller.  Acknowledge the interrupt, check for
 * errors on the current operation, mark it done if necessary, and start the
 * next request.  Also check for a partially done transfer, and continue with
 * the next chunk if so.
 */
int
wdcintr(arg)
	void *arg;
{
	struct wdc_softc *wdc = arg;
	struct wd_softc *wd;
	struct buf *bp;

	if ((wdc->sc_flags & WDCF_ACTIVE) == 0)
		/* leave it alone if we didn't ask for this interrupt */
		return 0;

	wdc->sc_flags &= ~WDCF_ACTIVE;
	untimeout(wdctimeout, wdc);

	wd = wdc->sc_drives.tqh_first;
	bp = wd->sc_q.b_actf;

#ifdef WDDEBUG
	printf("I%s ", wdc->sc_dev.dv_xname);
#endif

	if (wait_for_unbusy(wdc) < 0) {
		wderror(wd, NULL, "wdcintr: timeout waiting for unbusy");
		wdc->sc_status |= WDCS_ERR;	/* XXX */
	}
    
	/* Is it not a transfer, but a control operation? */
	if (wd->sc_state < OPEN) {
		if (wdcontrol(wd) == 0) {
			/* The drive is busy.  Wait. */
			return 1;
		}
		wdcstart(wdc);
		return 1;
	}

	/* Turn off the DMA channel and unbounce the buffer. */
	if (wd->sc_mode == WDM_DMA)
		isa_dmadone(bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE,
		    bp->b_data + wd->sc_skip, wd->sc_nbytes, wdc->sc_drq);

	/* Have we an error? */
	if (wdc->sc_status & WDCS_ERR) {
#ifdef WDDEBUG
		wderror(wd, NULL, "wdcintr");
#endif
		if ((wdc->sc_flags & WDCF_SINGLE) == 0) {
			wdc->sc_flags |= WDCF_ERROR;
			goto restart;
		}

#ifdef B_FORMAT
		if (bp->b_flags & B_FORMAT)
			goto bad;
#endif
	
		wdcunwedge(wdc);
		if (wdc->sc_errors < WDIORETRIES)
			return 1;
		wderror(wd, bp, "hard error");

#ifdef B_FORMAT
	bad:
#endif
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		goto done;
	}

	/* If this was a read and not using DMA, fetch the data. */
	if (wd->sc_mode != WDM_DMA &&
	    (bp->b_flags & (B_READ|B_WRITE)) == B_READ) {
		if ((wdc->sc_status & (WDCS_DRDY | WDCS_DSC | WDCS_DRQ))
		    != (WDCS_DRDY | WDCS_DSC | WDCS_DRQ)) {
			wderror(wd, NULL, "wdcintr: read intr before drq");
			wdcunwedge(wdc);
			return 1;
		}

		/* Pull in data. */
		if ((wd->sc_flags & WDF_32BIT) == 0)
			insw(wdc->sc_iobase+wd_data, bp->b_data + wd->sc_skip, 
			    wd->sc_nbytes >> 1);
		else
			insl(wdc->sc_iobase+wd_data, bp->b_data + wd->sc_skip, 
			    wd->sc_nbytes >> 2);
	}
    
	/* If we encountered any abnormalities, flag it as a soft error. */
	if (wdc->sc_errors > 0 ||
	    (wdc->sc_status & WDCS_CORR) != 0) {
		wderror(wd, bp, "soft error (corrected)");
		wdc->sc_errors = 0;
	}
    
	/* Adjust pointers for the next block, if any. */
	wd->sc_blkno += wd->sc_nblks;
	wd->sc_skip += wd->sc_nbytes;
	wd->sc_bcount -= wd->sc_nbytes;

	/* See if this transfer is complete. */
	if (wd->sc_bcount > 0)
		goto restart;

done:
	/* Done with this transfer, with or without error. */
	wdfinish(wd, bp);

restart:
	/* Start the next operation, if any. */
	wdcstart(wdc);

	return 1;
}

/*
d342 2
a343 2
wdlock(wd)
	struct wd_softc *wd;
d346 3
d350 7
a356 3
	while ((wd->sc_flags & WDF_LOCKED) != 0) {
		wd->sc_flags |= WDF_WANTED;
		if ((error = tsleep(wd, PRIBIO | PCATCH, "wdlck", 0)) != 0)
d358 1
d360 2
a361 1
	wd->sc_flags |= WDF_LOCKED;
d369 2
a370 2
wdunlock(wd)
	struct wd_softc *wd;
d373 6
a378 4
	wd->sc_flags &= ~WDF_LOCKED;
	if ((wd->sc_flags & WDF_WANTED) != 0) {
		wd->sc_flags &= ~WDF_WANTED;
		wakeup(wd);
d389 1
d392 3
a394 1
    
d402 2
a403 1
	if ((error = wdlock(wd)) != 0)
d411 1
a411 1
		if ((wd->sc_flags & WDF_LOADED) == 0) {
d416 2
a417 2
		if ((wd->sc_flags & WDF_LOADED) == 0) {
			wd->sc_flags |= WDF_LOADED;
d420 1
a420 1
			if (wd_get_parms(wd) != 0) {
d451 1
a451 1
	wdunlock(wd);
d455 1
a455 1
	wd->sc_flags &= ~WDF_LOADED;
d462 1
a462 1
	wdunlock(wd);
d476 1
a476 1
	if ((error = wdlock(wd)) != 0)
d493 1
a493 1
	wdunlock(wd);
d505 1
d508 2
d514 3
a516 3
	lp->d_ntracks = wd->sc_params.wdp_heads;
	lp->d_nsectors = wd->sc_params.wdp_sectors;
	lp->d_ncylinders = wd->sc_params.wdp_cylinders;
d523 1
a523 1
	strncpy(lp->d_packname, wd->sc_params.wdp_model, 16);
d539 1
a539 1
	wd->sc_badsect[0] = -1;
d541 2
a542 2
	if (wd->sc_state > RECAL)
		wd->sc_state = RECAL;
d552 2
a553 2
		if (wd->sc_state > GEOMETRY)
			wd->sc_state = GEOMETRY;
d562 2
a563 2
	if (wd->sc_state > GEOMETRY)
		wd->sc_state = GEOMETRY;
a567 77
/*
 * Implement operations needed before read/write.
 * Returns 0 if operation still in progress, 1 if completed.
 */
int
wdcontrol(wd)
	struct wd_softc *wd;
{
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
    
	switch (wd->sc_state) {
	case RECAL:			/* Set SDH, step rate, do recal. */
		if (wdcommandshort(wdc, wd->sc_drive, WDCC_RECAL) != 0) {
			wderror(wd, NULL, "wdcontrol: recal failed (1)");
			goto bad;
		}
		wd->sc_state = RECAL_WAIT;
		break;

	case RECAL_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(wd, NULL, "wdcontrol: recal failed (2)");
			goto bad;
		}
		/* fall through */
	case GEOMETRY:
		if ((wd->sc_params.wdp_capabilities & WD_CAP_LBA) != 0)
			goto multimode;
		if (wdsetctlr(wd) != 0) {
			/* Already printed a message. */
			goto bad;
		}
		wd->sc_state = GEOMETRY_WAIT;
		break;

	case GEOMETRY_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(wd, NULL, "wdcontrol: geometry failed");
			goto bad;
		}
		/* fall through */
	case MULTIMODE:
	multimode:
		if (wd->sc_mode != WDM_PIOMULTI)
			goto open;
		outb(wdc->sc_iobase+wd_seccnt, wd->sc_multiple);
		if (wdcommandshort(wdc, wd->sc_drive, WDCC_SETMULTI) != 0) {
			wderror(wd, NULL, "wdcontrol: setmulti failed (1)");
			goto bad;
		}
		wd->sc_state = MULTIMODE_WAIT;
		break;

	case MULTIMODE_WAIT:
		if (wdc->sc_status & WDCS_ERR) {
			wderror(wd, NULL, "wdcontrol: setmulti failed (2)");
			goto bad;
		}
		/* fall through */
	case OPEN:
	open:
		wdc->sc_errors = 0;
		wd->sc_state = OPEN;
		/*
		 * The rest of the initialization can be done by normal means.
		 */
		return 1;

	bad:
		wdcunwedge(wdc);
		return 0;
	}

	wdc->sc_flags |= WDCF_ACTIVE;
	timeout(wdctimeout, wdc, WAITTIME);
	return 0;
}
d570 1
a570 3
 * Wait for the drive to become ready and send a command.
 * Return -1 if busy for too long or 0 otherwise.
 * Assumes interrupts are blocked.
d573 2
a574 44
wdcommand(wd, command, cylin, head, sector, count)
	struct wd_softc *wd;
	int command;
	int cylin, head, sector, count;
{
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
	int iobase = wdc->sc_iobase;
	int stat;
    
	/* Select drive, head, and addressing mode. */
	outb(iobase+wd_sdh, WDSD_IBM | (wd->sc_drive << 4) | head);

	/* Wait for it to become ready to accept a command. */
	if (command == WDCC_IDP)
		stat = wait_for_unbusy(wdc);
	else
		stat = wdcwait(wdc, WDCS_DRDY);
	if (stat < 0)
		return -1;
    
	/* Load parameters. */
	if (wd->sc_dk.dk_label->d_type == DTYPE_ST506)
		outb(iobase+wd_precomp, wd->sc_dk.dk_label->d_precompcyl / 4);
	else
		outb(iobase+wd_features, 0);
	outb(iobase+wd_cyl_lo, cylin);
	outb(iobase+wd_cyl_hi, cylin >> 8);
	outb(iobase+wd_sector, sector);
	outb(iobase+wd_seccnt, count);

	/* Send command. */
	outb(iobase+wd_command, command);

	return 0;
}

/*
 * Simplified version of wdcommand().
 */
int
wdcommandshort(wdc, drive, command)
	struct wdc_softc *wdc;
	int drive;
	int command;
d576 1
a576 4
	int iobase = wdc->sc_iobase;

	/* Select drive. */
	outb(iobase+wd_sdh, WDSD_IBM | (drive << 4));
d578 3
a580 7
	if (wdcwait(wdc, WDCS_DRDY) < 0)
		return -1;

	outb(iobase+wd_command, command);

	return 0;
}
d582 2
a583 15
/*
 * Tell the drive what geometry to use.
 */
int
wdsetctlr(wd)
	struct wd_softc *wd;
{

#ifdef WDDEBUG
	printf("wd(%d,%d) C%dH%dS%d\n", wd->sc_dev.dv_unit, wd->sc_drive,
	    wd->sc_dk.dk_label->d_ncylinders, wd->sc_dk.dk_label->d_ntracks,
	    wd->sc_dk.dk_label->d_nsectors);
#endif
    
	if (wdcommand(wd, WDCC_IDP, wd->sc_dk.dk_label->d_ncylinders,
d586 1
a586 1
		wderror(wd, NULL, "wdsetctlr: geometry upload failed");
a592 3
/*
 * Get the drive parameters, if ESDI or ATA, or create fake ones for ST506.
 */
d594 1
a594 75
wd_get_parms(wd)
	struct wd_softc *wd;
{
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
	int i;
	char tb[DEV_BSIZE];
	int s, error;

	/*
	 * XXX
	 * The locking done here, and the length of time this may keep the rest
	 * of the system suspended, is a kluge.  This should be rewritten to
	 * set up a transfer and queue it through wdstart(), but it's called
	 * infrequently enough that this isn't a pressing matter.
	 */

	s = splbio();

	while ((wdc->sc_flags & WDCF_ACTIVE) != 0) {
		wdc->sc_flags |= WDCF_WANTED;
		if ((error = tsleep(wdc, PRIBIO | PCATCH, "wdprm", 0)) != 0) {
			splx(s);
			return error;
		}
	}

	if (wdcommandshort(wdc, wd->sc_drive, WDCC_IDENTIFY) != 0 ||
	    wait_for_drq(wdc) != 0) {
		/*
		 * We `know' there's a drive here; just assume it's old.
		 * This geometry is only used to read the MBR and print a
		 * (false) attach message.
		 */
		strncpy(wd->sc_dk.dk_label->d_typename, "ST506",
		    sizeof wd->sc_dk.dk_label->d_typename);
		wd->sc_dk.dk_label->d_type = DTYPE_ST506;

		strncpy(wd->sc_params.wdp_model, "unknown",
		    sizeof wd->sc_params.wdp_model);
		wd->sc_params.wdp_config = WD_CFG_FIXED;
		wd->sc_params.wdp_cylinders = 1024;
		wd->sc_params.wdp_heads = 8;
		wd->sc_params.wdp_sectors = 17;
		wd->sc_params.wdp_maxmulti = 0;
		wd->sc_params.wdp_usedmovsd = 0;
		wd->sc_params.wdp_capabilities = 0;
	} else {
		strncpy(wd->sc_dk.dk_label->d_typename, "ESDI/IDE",
		    sizeof wd->sc_dk.dk_label->d_typename);
		wd->sc_dk.dk_label->d_type = DTYPE_ESDI;

		/* Read in parameter block. */
		insw(wdc->sc_iobase+wd_data, tb, sizeof(tb) / sizeof(short));
		bcopy(tb, &wd->sc_params, sizeof(struct wdparams));

		/* Shuffle string byte order. */
		for (i = 0; i < sizeof(wd->sc_params.wdp_model); i += 2) {
			u_short *p;
			p = (u_short *)(wd->sc_params.wdp_model + i);
			*p = ntohs(*p);
		}
	}

	/* Clear any leftover interrupt. */
	(void) inb(wdc->sc_iobase+wd_status);

	/* Restart the queue. */
	wdcstart(wdc);

	splx(s);
	return 0;
}

int
wdioctl(dev, cmd, addr, flag, p)
d596 1
a596 1
	u_long cmd;
d602 1
d604 4
a607 2
    
	if ((wd->sc_flags & WDF_LOADED) == 0)
d610 1
a610 1
	switch (cmd) {
d634 1
a634 1
		if ((error = wdlock(wd)) != 0)
d636 1
a636 1
		wd->sc_flags |= WDF_LABELLING;
d642 3
a644 3
			if (wd->sc_state > GEOMETRY)
				wd->sc_state = GEOMETRY;
			if (cmd == DIOCWDINFO)
d650 2
a651 2
		wd->sc_flags &= ~WDF_LABELLING;
		wdunlock(wd);
d658 1
a658 1
			wd->sc_flags |= WDF_WLABEL;
d660 1
a660 1
			wd->sc_flags &= ~WDF_WLABEL;
d717 3
a719 1
    
d741 3
d755 1
d768 1
a768 1
	if (wd == 0)
d770 1
d775 1
a775 1
	if (wd->sc_state < OPEN)
d797 2
a798 2
		if (wdcommandshort(wdc, wd->sc_drive, WDCC_RECAL) != 0 ||
		    wait_for_ready(wdc) != 0 || wdsetctlr(wd) != 0 ||
d800 1
a800 1
			wderror(wd, NULL, "wddump: recal failed");
d813 1
a813 1
			for (i = 0; (blkdiff = wd->sc_badsect[i]) != -1; i++) {
d827 1
a827 1
		if ((wd->sc_params.wdp_capabilities & WD_CAP_LBA) != 0) {
d843 1
a843 1
		if (wdcommand(wd, WDCC_WRITE, cylin, head, sector, 1) != 0 ||
d845 1
a845 1
			wderror(wd, NULL, "wddump: write failed");
d849 2
a850 1
		outsw(wdc->sc_iobase+wd_data, va, lp->d_secsize >> 1);
d854 2
a855 1
			wderror(wd, NULL, "wddump: timeout waiting for ready");
d875 2
d899 1
d902 2
d907 1
a907 1
		wd->sc_badsect[i] =
d913 1
a913 23
		wd->sc_badsect[i] = -1;
}

int
wdcreset(wdc)
	struct wdc_softc *wdc;
{
	int iobase = wdc->sc_iobase;

	/* Reset the device. */
	outb(iobase+wd_ctlr, WDCTL_RST | WDCTL_IDS);
	delay(1000);
	outb(iobase+wd_ctlr, WDCTL_IDS);
	delay(1000);
	(void) inb(iobase+wd_error);
	outb(iobase+wd_ctlr, WDCTL_4BIT);

	if (wait_for_unbusy(wdc) < 0) {
		printf("%s: reset failed\n", wdc->sc_dev.dv_xname);
		return 1;
	}

	return 0;
d917 4
a920 2
wdcrestart(arg)
	void *arg;
d922 1
a922 2
	struct wdc_softc *wdc = arg;
	int s;
d924 4
a927 89
	s = splbio();
	wdcstart(wdc);
	splx(s);
}

/*
 * Unwedge the controller after an unexpected error.  We do this by resetting
 * it, marking all drives for recalibration, and stalling the queue for a short
 * period to give the reset time to finish.
 * NOTE: We use a timeout here, so this routine must not be called during
 * autoconfig or dump.
 */
void
wdcunwedge(wdc)
	struct wdc_softc *wdc;
{
	int unit;

	untimeout(wdctimeout, wdc);
	(void) wdcreset(wdc);

	/* Schedule recalibrate for all drives on this controller. */
	for (unit = 0; unit < wd_cd.cd_ndevs; unit++) {
		struct wd_softc *wd = wd_cd.cd_devs[unit];
		if (!wd || (void *)wd->sc_dev.dv_parent != wdc)
			continue;
		if (wd->sc_state > RECAL)
			wd->sc_state = RECAL;
	}

	wdc->sc_flags |= WDCF_ERROR;
	++wdc->sc_errors;

	/* Wake up in a little bit and restart the operation. */
	timeout(wdcrestart, wdc, RECOVERYTIME);
}

int
wdcwait(wdc, mask)
	struct wdc_softc *wdc;
	int mask;
{
	int iobase = wdc->sc_iobase;
	int timeout = 0;
	u_char status;
#ifdef WDCNDELAY_DEBUG
	extern int cold;
#endif

	for (;;) {
		wdc->sc_status = status = inb(iobase+wd_status);
		if ((status & WDCS_BSY) == 0 && (status & mask) == mask)
			break;
		if (++timeout > WDCNDELAY)
			return -1;
		delay(WDCDELAY);
	}
	if (status & WDCS_ERR) {
		wdc->sc_error = inb(iobase+wd_error);
		return WDCS_ERR;
	}
#ifdef WDCNDELAY_DEBUG
	/* After autoconfig, there should be no long delays. */
	if (!cold && timeout > WDCNDELAY_DEBUG)
		printf("%s: warning: busy-wait took %dus\n",
		    wdc->sc_dev.dv_xname, WDCDELAY * timeout);
#endif
	return 0;
}

void
wdctimeout(arg)
	void *arg;
{
	struct wdc_softc *wdc = (struct wdc_softc *)arg;
	int s;

	s = splbio();
	if ((wdc->sc_flags & WDCF_ACTIVE) != 0) {
		struct wd_softc *wd = wdc->sc_drives.tqh_first;
		struct buf *bp = wd->sc_q.b_actf;

		wdc->sc_flags &= ~WDCF_ACTIVE;
		wderror(wdc, NULL, "lost interrupt");
		printf("%s: lost interrupt: %sing %d@@%s:%d\n",
		    wdc->sc_dev.dv_xname,
		    (bp->b_flags & B_READ) ? "read" : "writ",
		    wd->sc_nblks, wd->sc_dev.dv_xname, wd->sc_blkno);
		wdcunwedge(wdc);
d929 1
a929 2
		wderror(wdc, NULL, "missing untimeout");
	splx(s);
d933 2
a934 2
wderror(dev, bp, msg)
	void *dev;
a935 1
	char *msg;
d937 1
a937 2
	struct wd_softc *wd = dev;
	struct wdc_softc *wdc = dev;
d939 1
a939 7
	if (bp) {
		diskerr(bp, "wd", msg, LOG_PRINTF, wd->sc_skip / DEV_BSIZE,
		    wd->sc_dk.dk_label);
		printf("\n");
	} else
		printf("%s: %s: status %b error %b\n", wdc->sc_dev.dv_xname,
		    msg, wdc->sc_status, WDCS_BITS, wdc->sc_error, WDERR_BITS);
@


1.13
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.12 1996/05/07 07:37:58 deraadt Exp $	*/
d318 2
@


1.12
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: wd.c,v 1.10 1996/04/21 22:24:40 deraadt Exp $	*/
/*	$NetBSD: wd.c,v 1.149 1996/04/29 19:50:47 christos Exp $	*/
d55 1
@


1.11
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d2 1
a2 1
/*	$NetBSD: wd.c,v 1.148 1996/04/11 22:30:31 cgd Exp $	*/
d50 1
d141 3
a143 2
int wdcprobe __P((struct device *, void *, void *));
void wdcattach __P((struct device *, struct device *, void *));
d155 1
d165 4
a168 4
void wdgetdisklabel __P((struct wd_softc *));
int wd_get_parms __P((struct wd_softc *));
void wdstrategy __P((struct buf *));
void wdstart __P((struct wd_softc *));
d172 11
a182 7
void wdfinish __P((struct wd_softc *, struct buf *));
int wdcintr __P((void *));
void wdcstart __P((struct wdc_softc *));
int wdcommand __P((struct wd_softc *, int, int, int, int, int));
int wdcommandshort __P((struct wdc_softc *, int, int));
int wdcontrol __P((struct wd_softc *));
int wdsetctlr __P((struct wd_softc *));
d184 9
a192 6
int wdcreset __P((struct wdc_softc *));
void wdcrestart __P((void *arg));
void wdcunwedge __P((struct wdc_softc *));
void wdctimeout __P((void *arg));
void wderror __P((void *, struct buf *, char *));
int wdcwait __P((struct wdc_softc *, int));
d492 1
a492 1
wdread(dev, uio)
d495 1
d502 1
a502 1
wdwrite(dev, uio)
d505 1
d700 5
d818 1
d820 1
d909 1
a909 1
wdopen(dev, flag, fmt)
d912 1
d925 1
a925 1
	if (error = wdlock(wd))
d989 1
a989 1
wdclose(dev, flag, fmt)
d992 1
d998 1
a998 1
	if (error = wdlock(wd))
a1235 1
	struct wdc_softc *wdc = (void *)wd->sc_dev.dv_parent;
d1368 1
a1368 1
		if (error = wdlock(wd))
d1452 1
a1452 1
	if (wdopen(dev, 0, S_IFBLK) != 0)
d1460 1
a1460 1
	if (wdclose(dev, 0, S_IFBLK) != 0)
d1710 1
d1712 1
@


1.10
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: wd.c,v 1.9 1996/04/18 23:47:51 niklas Exp $	*/
d60 2
a61 1
#define	WAITTIME	(4 * hz)	/* time to wait for a completion */
d71 1
a71 1
#define	WDIORETRIES	5		/* number of retries before giving up */
d591 1
a591 1
		printf(" %d)%x", wd->sc_skip, inb(wd->sc_iobase+wd_altsts));
d700 1
a700 1
		    cylin, head, bp->b_data, inb(wd->sc_iobase+wd_altsts));
d747 2
a748 3
	if ((wdc->sc_flags & WDCF_ACTIVE) == 0) {
		/* Clear the pending interrupt and abort. */
		(void) inb(wdc->sc_iobase+wd_status);
a749 1
	}
d758 1
a758 1
	printf("I%d ", ctrlr);
a782 1
	lose:
d796 3
a798 2
		if (++wdc->sc_errors < WDIORETRIES)
			goto restart;
@


1.9
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: wd.c,v 1.146 1996/03/01 04:08:51 mycroft Exp $	*/
d142 6
a147 2
struct cfdriver wdccd = {
	NULL, "wdc", wdcprobe, wdcattach, DV_DULL, sizeof(struct wdc_softc)
d153 6
a158 2
struct cfdriver wdcd = {
	NULL, "wd", wdprobe, wdattach, DV_DISK, sizeof(struct wd_softc)
d260 2
a261 2
	wdc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_BIO, wdcintr,
	    wdc, wdc->sc_dev.dv_xname);
d365 1
a365 1
	struct wd_softc *wd = wdcd.cd_devs[WDUNIT(bp->b_dev)];
d900 1
a900 1
	if (unit >= wdcd.cd_ndevs)
d902 1
a902 1
	wd = wdcd.cd_devs[unit];
d974 1
a974 1
	struct wd_softc *wd = wdcd.cd_devs[WDUNIT(dev)];
d1319 1
a1319 1
	struct wd_softc *wd = wdcd.cd_devs[WDUNIT(dev)];
d1435 1
a1435 1
	wd = wdcd.cd_devs[WDUNIT(dev)];
d1474 1
a1474 1
	if (unit >= wdcd.cd_ndevs)
d1476 1
a1476 1
	wd = wdcd.cd_devs[unit];
d1668 2
a1669 2
	for (unit = 0; unit < wdcd.cd_ndevs; unit++) {
		struct wd_softc *wd = wdcd.cd_devs[unit];
@


1.8
log
@Fix back wrong patches.
@
text
@d1 2
a2 1
/*	$NetBSD: wd.c,v 1.145 1996/01/08 21:21:56 mycroft Exp $	*/
d666 2
a667 1
			isa_dmastart(bp->b_flags & B_READ,
d771 2
a772 2
		isa_dmadone(bp->b_flags & B_READ, bp->b_data + wd->sc_skip,
		    wd->sc_nbytes, wdc->sc_drq);
@


1.7
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d252 1
a252 1
	    wdc);
@


1.6
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d252 1
a252 1
	    wdc, wdc->sc_dev.dv_xname);
@


1.5
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d252 1
a252 1
	    wdc);
@


1.4
log
@included isadmavar.h
@
text
@d1 1
a1 1
/*	$NetBSD: wd.c,v 1.142 1995/08/05 23:50:23 mycroft Exp $	*/
a34 2
#define	INSTRUMENT	/* instrumentation stuff by Brad Parker */

d79 1
a79 1
	struct dkdevice sc_dk;
d291 7
a345 2

	wd->sc_dk.dk_driver = &wddkdriver;
d361 2
a362 2
	    (bp->b_bcount % wd->sc_dk.dk_label.d_secsize) != 0 ||
	    (bp->b_bcount / wd->sc_dk.dk_label.d_secsize) >= (1 << NBBY)) {
d382 1
a382 1
	    bounds_check_with_label(bp, &wd->sc_dk.dk_label,
d425 2
d459 9
a526 5
	if (bp == NULL) {
		TAILQ_REMOVE(&wdc->sc_drives, wd, sc_drivechain);
		wd->sc_q.b_active = 0;
		goto loop;
	}
d562 1
a562 1
	lp = &wd->sc_dk.dk_label;
d927 2
a928 2
	    (part >= wd->sc_dk.dk_label.d_npartitions ||
	     wd->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d996 1
a996 1
	struct disklabel *lp = &wd->sc_dk.dk_label;
d1000 1
a1000 1
	bzero(&wd->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d1033 1
a1033 1
	    wdstrategy, lp, &wd->sc_dk.dk_cpulabel);
d1044 1
a1044 1
		    wdstrategy, lp, &wd->sc_dk.dk_cpulabel);
d1162 2
a1163 2
	if (wd->sc_dk.dk_label.d_type == DTYPE_ST506)
		outb(iobase+wd_precomp, wd->sc_dk.dk_label.d_precompcyl / 4);
d1210 2
a1211 2
	    wd->sc_dk.dk_label.d_ncylinders, wd->sc_dk.dk_label.d_ntracks,
	    wd->sc_dk.dk_label.d_nsectors);
d1214 3
a1216 3
	if (wdcommand(wd, WDCC_IDP, wd->sc_dk.dk_label.d_ncylinders,
	    wd->sc_dk.dk_label.d_ntracks - 1, 0, wd->sc_dk.dk_label.d_nsectors)
	    != 0) {
d1261 3
a1263 3
		strncpy(wd->sc_dk.dk_label.d_typename, "ST506",
		    sizeof wd->sc_dk.dk_label.d_typename);
		wd->sc_dk.dk_label.d_type = DTYPE_ST506;
d1275 3
a1277 3
		strncpy(wd->sc_dk.dk_label.d_typename, "ESDI/IDE",
		    sizeof wd->sc_dk.dk_label.d_typename);
		wd->sc_dk.dk_label.d_type = DTYPE_ESDI;
d1319 2
a1320 2
		wd->sc_dk.dk_cpulabel.bad = *(struct dkbad *)addr;
		wd->sc_dk.dk_label.d_flags |= D_BADSECT;
d1325 1
a1325 1
		*(struct disklabel *)addr = wd->sc_dk.dk_label;
d1329 1
a1329 1
		((struct partinfo *)addr)->disklab = &wd->sc_dk.dk_label;
d1331 1
a1331 1
		    &wd->sc_dk.dk_label.d_partitions[WDPART(dev)];
d1343 1
a1343 1
		error = setdisklabel(&wd->sc_dk.dk_label,
d1345 1
a1345 1
		    &wd->sc_dk.dk_cpulabel);
d1351 2
a1352 2
				    wdstrategy, &wd->sc_dk.dk_label,
				    &wd->sc_dk.dk_cpulabel);
d1385 1
a1385 1
		    fop->df_startblk * wd->sc_dk.dk_label.d_secsize;
d1427 1
a1427 1
	if (wd->sc_dk.dk_label.d_partitions[part].p_fstype != FS_SWAP)
d1430 1
a1430 1
		size = wd->sc_dk.dk_label.d_partitions[part].p_size;
d1479 1
a1479 1
	lp = &wd->sc_dk.dk_label;
d1591 2
a1592 2
	struct dkbad *bt = &wd->sc_dk.dk_cpulabel.bad;
	struct disklabel *lp = &wd->sc_dk.dk_label;
d1713 3
d1718 4
d1739 1
a1739 1
		    &wd->sc_dk.dk_label);
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d58 1
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
ultra14f does not bounce properly yet.
@
text
@a57 1
#include <dev/isa/isadmavar.h>
d252 2
a253 2
	wdc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_BIO,
	    wdcintr, wdc);
@


1.1
log
@Initial revision
@
text
@d58 1
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
