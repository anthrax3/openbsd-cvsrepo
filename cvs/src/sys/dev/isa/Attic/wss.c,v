head	1.29;
access;
symbols
	OPENBSD_6_0:1.28.0.6
	OPENBSD_6_0_BASE:1.28
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28
	OPENBSD_5_8:1.28.0.4
	OPENBSD_5_8_BASE:1.28
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.12
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.10
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.8
	OPENBSD_5_0:1.24.0.6
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.4
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.2
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.23.0.6
	OPENBSD_4_7_BASE:1.23
	OPENBSD_4_6:1.23.0.8
	OPENBSD_4_6_BASE:1.23
	OPENBSD_4_5:1.23.0.4
	OPENBSD_4_5_BASE:1.23
	OPENBSD_4_4:1.23.0.2
	OPENBSD_4_4_BASE:1.23
	OPENBSD_4_3:1.22.0.20
	OPENBSD_4_3_BASE:1.22
	OPENBSD_4_2:1.22.0.18
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.22.0.16
	OPENBSD_4_1_BASE:1.22
	OPENBSD_4_0:1.22.0.14
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.12
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.22.0.10
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.22.0.8
	OPENBSD_3_7_BASE:1.22
	OPENBSD_3_6:1.22.0.6
	OPENBSD_3_6_BASE:1.22
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.22
	OPENBSD_3_5:1.22.0.4
	OPENBSD_3_5_BASE:1.22
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.20.0.16
	UBC_BASE:1.20
	OPENBSD_3_0:1.20.0.14
	OPENBSD_3_0_BASE:1.20
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.12
	OPENBSD_2_8:1.20.0.10
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.8
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.6
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.4
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.4
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.13.0.2
	OPENBSD_2_0_BASE:1.13
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.08.31.12.46.45;	author tedu;	state dead;
branches;
next	1.28;
commitid	O7a4qUcwjFJJ3AGe;

1.28
date	2015.05.09.10.27.32;	author jsg;	state Exp;
branches;
next	1.27;
commitid	FvxeWjK5uKNgli7i;

1.27
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.26;
commitid	uzzBR7hz9ncd4O6G;

1.26
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.24;

1.24
date	2010.06.30.11.21.35;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	99.01.24.15.58.54;	author mickey;	state Exp;
branches
	1.20.6.1
	1.20.16.1;
next	1.19;

1.19
date	99.01.11.01.57.53;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	99.01.02.00.02.48;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.11.03.21.15.01;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	98.05.08.18.37.24;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	98.04.26.21.03.03;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.07.10.23.06.40;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	96.06.23.13.44.50;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.29.08.18.01;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	96.05.26.00.27.32;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.07.07.38.08;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.24.16.51.15;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.24.49;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.01.01.06;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.10.36;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.16.43.17;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.36.10;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.39;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.10;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.38;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.38;	author deraadt;	state Exp;
branches;
next	;

1.20.6.1
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	;

1.20.16.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.20.16.2;

1.20.16.2
date	2003.05.19.22.08.46;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@remove some ISA drivers for devices not recently seen in the wild.
@
text
@/*	$OpenBSD: wss.c,v 1.28 2015/05/09 10:27:32 jsg Exp $	*/
/*	$NetBSD: wss.c,v 1.42 1998/01/19 22:18:23 augustss Exp $	*/

/*
 * Copyright (c) 1994 John Brezak
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/ad1848reg.h>
#include <dev/isa/ad1848var.h>
#include <dev/isa/wssreg.h>
#include <dev/isa/wssvar.h>
#include <dev/isa/madreg.h>

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (wssdebug) printf x
int	wssdebug = 0;
#else
#define DPRINTF(x)
#endif

struct audio_device wss_device = {
	"wss,ad1848",
	"",
	"WSS"
};

int	wss_getdev(void *, struct audio_device *);

int	wss_mixer_set_port(void *, mixer_ctrl_t *);
int	wss_mixer_get_port(void *, mixer_ctrl_t *);
int	wss_query_devinfo(void *, mixer_devinfo_t *);

/*
 * Define our interface to the higher level audio driver.
 */

struct audio_hw_if wss_hw_if = {
	ad1848_open,
	ad1848_close,
	NULL,
	ad1848_query_encoding,
	ad1848_set_params,
	ad1848_round_blocksize,
	ad1848_commit_settings,
	NULL,
	NULL,
	NULL,
	NULL,
	ad1848_halt_output,
	ad1848_halt_input,
	NULL,
	wss_getdev,
	NULL,
	wss_mixer_set_port,
	wss_mixer_get_port,
	wss_query_devinfo,
	ad1848_malloc,
	ad1848_free,
	ad1848_round,
	ad1848_mappage,
	ad1848_get_props,
	ad1848_trigger_output,
	ad1848_trigger_input,
	NULL
};

/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver .
 */
void
wssattach(sc)
    struct wss_softc *sc;
{
    int version;
    
    madattach(sc);

    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq,
	IST_EDGE, IPL_AUDIO | IPL_MPSAFE,
        ad1848_intr, &sc->sc_ad1848, sc->sc_dev.dv_xname);

    ad1848_attach(&sc->sc_ad1848);
    
    version = bus_space_read_1(sc->sc_iot, sc->sc_ioh, WSS_STATUS) & WSS_VERSMASK;
    printf(" (vers %d)", version);
    switch(sc->mad_chip_type) {
    case MAD_82C928:
	printf(", 82C928");
	break;
    case MAD_OTI601D:
	printf(", OTI-601D");
	break;
    case MAD_82C929:
	printf(", 82C929");
	break;
    case MAD_82C931:
	printf(", 82C931");
	break;
    default:
	break;
    }
    printf("\n");

    sc->sc_ad1848.parent = sc;

    audio_attach_mi(&wss_hw_if, &sc->sc_ad1848, &sc->sc_dev);
}

int
wss_getdev(addr, retp)
    void *addr;
    struct audio_device *retp;
{
    *retp = wss_device;
    return 0;
}

static ad1848_devmap_t mappings[] = {
{ WSS_MIC_IN_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL },
{ WSS_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL },
{ WSS_DAC_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL },
{ WSS_MON_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL },
{ WSS_MIC_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL },
{ WSS_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL },
{ WSS_DAC_MUTE, AD1848_KIND_MUTE, AD1848_DAC_CHANNEL },
{ WSS_REC_LVL, AD1848_KIND_RECORDGAIN, -1 },
{ WSS_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}
};

static int nummap = sizeof(mappings) / sizeof(mappings[0]);

int
wss_mixer_set_port(addr, cp)
    void *addr;
    mixer_ctrl_t *cp;
{
    struct ad1848_softc *ac = addr;

    return (ad1848_mixer_set_port(ac, mappings, nummap, cp));
}

int
wss_mixer_get_port(addr, cp)
    void *addr;
    mixer_ctrl_t *cp;
{
    struct ad1848_softc *ac = addr;

    return (ad1848_mixer_get_port(ac, mappings, nummap, cp));
}

int
wss_query_devinfo(addr, dip)
    void *addr;
    mixer_devinfo_t *dip;
{
    DPRINTF(("wss_query_devinfo: index=%d\n", dip->index));

    switch(dip->index) {
    case WSS_MIC_IN_LVL:	/* Microphone */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = WSS_MIC_IN_MUTE;
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case WSS_LINE_IN_LVL:	/* line/CD */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = WSS_LINE_IN_MUTE;
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case WSS_DAC_LVL:		/*  dacout */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = WSS_DAC_MUTE;
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case WSS_REC_LVL:	/* record level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = WSS_RECORD_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = WSS_RECORD_SOURCE;
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case WSS_MON_LVL:	/* monitor level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = WSS_MONITOR_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case WSS_INPUT_CLASS:			/* input class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
	break;

    case WSS_MONITOR_CLASS:			/* monitor class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = WSS_MONITOR_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
	break;
	    
    case WSS_RECORD_CLASS:			/* record source class */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = WSS_RECORD_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
	break;
	
    case WSS_MIC_IN_MUTE:
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = WSS_MIC_IN_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;
	
    case WSS_LINE_IN_MUTE:
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = WSS_LINE_IN_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;
	
    case WSS_DAC_MUTE:
	dip->mixer_class = WSS_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = WSS_DAC_LVL;
	dip->next = AUDIO_MIXER_LAST;
    mute:
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
	dip->un.e.num_mem = 2;
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = 0;
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = 1;
	break;

    case WSS_RECORD_SOURCE:
	dip->mixer_class = WSS_RECORD_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = WSS_REC_LVL;
	dip->next = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
	dip->un.e.num_mem = 3;
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = WSS_MIC_IN_LVL;
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = WSS_LINE_IN_LVL;
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
	dip->un.e.member[2].ord = WSS_DAC_LVL;
	break;

    default:
	return ENXIO;
	/*NOTREACHED*/
    }
    DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));

    return 0;
}


/*
 * Copyright by Hannu Savolainen 1994
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: 1. Redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer. 2.
 * Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * Initialization code for OPTi MAD16 compatible audio chips. Including
 *
 *      OPTi 82C928     MAD16           (replaced by C929)
 *      OAK OTI-601D    Mozart
 *      OPTi 82C929     MAD16 Pro
 *
 */

u_int
mad_read(sc, port)
    struct wss_softc *sc;
    int port;
{
    u_int tmp;
    int pwd;
    
    switch (sc->mad_chip_type) {	/* Output password */
    case MAD_82C928:
    case MAD_OTI601D:
	pwd = M_PASSWD_928;
	break;
    case MAD_82C929:
	pwd = M_PASSWD_929;
	break;
    case MAD_82C931:
	pwd = M_PASSWD_931;
	break;
    default:
	panic("mad_read: Bad chip type=%d", sc->mad_chip_type);
    }
    mtx_enter(&audio_lock);		/* don't want an interrupt between outb&inb */
    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);
    tmp = bus_space_read_1(sc->sc_iot, sc->mad_ioh, port);
    mtx_leave(&audio_lock);
    return tmp;
}

void
mad_write(sc, port, value)
    struct wss_softc *sc;
    int port;
    int value;
{
    int pwd;

    switch (sc->mad_chip_type) {	/* Output password */
    case MAD_82C928:
    case MAD_OTI601D:
	pwd = M_PASSWD_928;
	break;
    case MAD_82C929:
	pwd = M_PASSWD_929;
	break;
    case MAD_82C931:
	pwd = M_PASSWD_931;
	break;
    default:
	panic("mad_write: Bad chip type=%d", sc->mad_chip_type);
    }
    mtx_enter(&audio_lock);
    bus_space_write_1(sc->sc_iot, sc->mad_ioh, MC_PASSWD_REG, pwd);
    bus_space_write_1(sc->sc_iot, sc->mad_ioh, port, value & 0xff);
    mtx_leave(&audio_lock);
}

void
madattach(sc)
    struct wss_softc *sc;
{
    unsigned char cs4231_mode;
    int joy;

    if (sc->mad_chip_type == MAD_NONE)
        return;

    /* Do we want the joystick disabled? */
    joy = sc->sc_dev.dv_cfdata->cf_flags & 2 ? MC1_JOYDISABLE : 0;

    /* enable WSS emulation at the I/O port */
    mad_write(sc, MC1_PORT, M_WSS_PORT_SELECT(sc->mad_ioindex) | joy);
    mad_write(sc, MC2_PORT, 0x03); /* ? */
    mad_write(sc, MC3_PORT, 0xf0); /* Disable SB */

    cs4231_mode = 
	strncmp(sc->sc_ad1848.chip_name, "CS4248", 6) == 0 ||
	strncmp(sc->sc_ad1848.chip_name, "CS4231", 6) == 0 ? 0x02 : 0;

    if (sc->mad_chip_type == MAD_82C929) {
	mad_write(sc, MC4_PORT, 0x92);
	mad_write(sc, MC5_PORT, 0xA5 | cs4231_mode);
	mad_write(sc, MC6_PORT, 0x03);	/* Disable MPU401 */
    } else {
	mad_write(sc, MC4_PORT, 0x02);
	mad_write(sc, MC5_PORT, 0x30 | cs4231_mode);
    }

#ifdef AUDIO_DEBUG
    if (wssdebug) {
	int i;
	for (i = MC1_PORT; i <= MC7_PORT; i++)
	    DPRINTF(("port %03x after init = %02x\n", i, mad_read(sc, i)));
    }
#endif
}
@


1.28
log
@Fix an occurance of mtx_enter() that should have been mtx_leave().
This line was originally an splx() before being converted to a mutex.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.27 2014/09/14 14:17:25 jsg Exp $	*/
@


1.27
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.26 2013/05/24 07:58:46 ratchov Exp $	*/
d425 1
a425 1
    mtx_enter(&audio_lock);
@


1.26
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.25 2013/05/15 08:29:24 ratchov Exp $	*/
a44 1
#include <sys/proc.h>
@


1.25
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.24 2010/06/30 11:21:35 jakemsr Exp $	*/
d129 2
a130 1
    sc->sc_ih = isa_intr_establish(sc->sc_ic, sc->wss_irq, IST_EDGE, IPL_AUDIO,
@


1.24
log
@* use audio(9)'s DMA trigger methods instead of the init/start
  methods.  the AD1848 DMA engine runs continuously and doesn't
  need to be started/stopped or otherwise manipulated for each
  block.  makes the driver a bit more efficient.
* allow "Mode 2" capable chips such as the CS4231 to work in "Mode 1"
  when there is only one DMA channel, instead of forcing it into
  "Mode 2", which expects two DMA channels.  allows recording to
  work for "Mode 2" capable devices when there is only one DMA
  channel.
* service both playback and recording interrupts in full-duplex
  mode, instead of only playback interrupts.  allows "Mode 2"
  capable chips to work in full-duplex mode.
* fix checks for sample rate/format recalibration completion.  gets
  rid of busy loops that briefly "hang" the kernel when the device is
  opened and/or reconfigured.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.23 2008/04/21 00:32:42 jakemsr Exp $	*/
a377 1
    int s;
d393 1
a393 1
    s = splaudio();		/* don't want an interrupt between outb&inb */
d396 1
a396 1
    splx(s);
a406 1
    int s;
d422 1
a422 1
    s = splaudio();
d425 1
a425 1
    splx(s);
@


1.23
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.22 2003/04/27 11:22:53 ho Exp $	*/
d95 6
a100 6
	ad1848_dma_init_output,
	ad1848_dma_init_input,
	ad1848_dma_output,
	ad1848_dma_input,
	ad1848_halt_out_dma,
	ad1848_halt_in_dma,
d112 2
a113 2
	NULL,
	NULL,
@


1.22
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.21 2002/03/14 01:26:56 millert Exp $	*/
d112 1
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.20 1999/01/24 15:58:54 mickey Exp $	*/
d214 1
a214 1
	strcpy(dip->label.name, AudioNmicrophone);
d216 1
a216 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d224 1
a224 1
	strcpy(dip->label.name, AudioNcd);
d226 1
a226 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d234 1
a234 1
	strcpy(dip->label.name, AudioNdac);
d236 1
a236 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d244 1
a244 1
	strcpy(dip->label.name, AudioNrecord);
d246 1
a246 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d253 1
a253 1
	strcpy(dip->label.name, AudioNmonitor);
d255 1
a255 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d262 1
a262 1
	strcpy(dip->label.name, AudioCinputs);
d269 1
a269 1
	strcpy(dip->label.name, AudioCmonitor);
d276 1
a276 1
	strcpy(dip->label.name, AudioCrecord);
d299 1
a299 1
	strcpy(dip->label.name, AudioNmute);
d301 2
a302 1
	strcpy(dip->un.e.member[0].label.name, AudioNoff);
d304 2
a305 1
	strcpy(dip->un.e.member[1].label.name, AudioNon);
d314 1
a314 1
	strcpy(dip->label.name, AudioNsource);
d316 2
a317 1
	strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d319 2
a320 1
	strcpy(dip->un.e.member[1].label.name, AudioNcd);
d322 2
a323 1
	strcpy(dip->un.e.member[2].label.name, AudioNdac);
@


1.20
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.19 1999/01/11 01:57:53 millert Exp $	*/
d77 1
a77 1
int	wss_getdev __P((void *, struct audio_device *));
d79 3
a81 3
int	wss_mixer_set_port __P((void *, mixer_ctrl_t *));
int	wss_mixer_get_port __P((void *, mixer_ctrl_t *));
int	wss_query_devinfo __P((void *, mixer_devinfo_t *));
@


1.20.16.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.20 1999/01/24 15:58:54 mickey Exp $	*/
d77 1
a77 1
int	wss_getdev(void *, struct audio_device *);
d79 3
a81 3
int	wss_mixer_set_port(void *, mixer_ctrl_t *);
int	wss_mixer_get_port(void *, mixer_ctrl_t *);
int	wss_query_devinfo(void *, mixer_devinfo_t *);
@


1.20.16.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d214 1
a214 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d216 1
a216 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d224 1
a224 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d226 1
a226 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d234 1
a234 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d236 1
a236 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d244 1
a244 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d246 1
a246 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d253 1
a253 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d255 1
a255 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d262 1
a262 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d269 1
a269 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d276 1
a276 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d299 1
a299 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d301 1
a301 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d303 1
a303 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d312 1
a312 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d314 1
a314 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
d316 1
a316 2
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
d318 1
a318 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
@


1.20.6.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d77 1
a77 1
int	wss_getdev(void *, struct audio_device *);
d79 3
a81 3
int	wss_mixer_set_port(void *, mixer_ctrl_t *);
int	wss_mixer_get_port(void *, mixer_ctrl_t *);
int	wss_query_devinfo(void *, mixer_devinfo_t *);
@


1.20.6.2
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.20.6.1 2002/03/28 12:11:36 niklas Exp $	*/
d214 1
a214 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d216 1
a216 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d224 1
a224 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d226 1
a226 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d234 1
a234 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d236 1
a236 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d244 1
a244 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d246 1
a246 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d253 1
a253 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d255 1
a255 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d262 1
a262 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d269 1
a269 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d276 1
a276 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d299 1
a299 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d301 1
a301 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d303 1
a303 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d312 1
a312 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d314 1
a314 2
	strlcpy(dip->un.e.member[0].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[0].label.name);
d316 1
a316 2
	strlcpy(dip->un.e.member[1].label.name, AudioNcd,
	    sizeof dip->un.e.member[1].label.name);
d318 1
a318 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
@


1.19
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.18 1999/01/02 00:02:48 niklas Exp $	*/
a50 1
#include <machine/pio.h>
@


1.18
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.17 1998/11/03 21:15:01 downsj Exp $	*/
d387 1
a387 1
	panic("mad_read: Bad chip type=%d\n", sc->mad_chip_type);
d417 1
a417 1
	panic("mad_write: Bad chip type=%d\n", sc->mad_chip_type);
@


1.17
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.16 1998/05/08 18:37:24 csapuntz Exp $	*/
d156 1
a156 1
    audio_attach_mi(&wss_hw_if, 0, &sc->sc_ad1848, &sc->sc_dev);
@


1.16
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.15 1998/04/26 21:03:03 provos Exp $	*/
d113 2
@


1.15
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.14 1997/07/10 23:06:40 provos Exp $	*/
a83 3
static int wss_to_vol __P((mixer_ctrl_t *, struct ad1848_volume *));
static int wss_from_vol __P((mixer_ctrl_t *, struct ad1848_volume *));

a156 34
static int
wss_to_vol(cp, vol)
    mixer_ctrl_t *cp;
    struct ad1848_volume *vol;
{
    if (cp->un.value.num_channels == 1) {
	vol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	return(1);
    }
    else if (cp->un.value.num_channels == 2) {
	vol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
	return(1);
    }
    return(0);
}

static int
wss_from_vol(cp, vol)
    mixer_ctrl_t *cp;
    struct ad1848_volume *vol;
{
    if (cp->un.value.num_channels == 1) {
	cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;
	return(1);
    }
    else if (cp->un.value.num_channels == 2) {
	cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;
	cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;
	return(1);
    }
    return(0);
}

d166 14
a185 64
    struct wss_softc *sc = ac->parent;
    struct ad1848_volume vol;
    int error = EINVAL;
    
    DPRINTF(("wss_mixer_set_port: dev=%d type=%d\n", cp->dev, cp->type));

    switch (cp->dev) {
    case WSS_MIC_IN_LVL:	/* Microphone */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (wss_to_vol(cp, &vol))
		error = ad1848_set_aux2_gain(ac, &vol);
	}
	break;
	
    case WSS_MIC_IN_MUTE:	/* Microphone */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->mic_mute = cp->un.ord;
	    DPRINTF(("mic mute %d\n", cp->un.ord));
	    error = 0;
	}
	break;

    case WSS_LINE_IN_LVL:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (wss_to_vol(cp, &vol))
		error = ad1848_set_aux1_gain(ac, &vol);
	}
	break;
	
    case WSS_LINE_IN_MUTE:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->cd_mute = cp->un.ord;
	    DPRINTF(("CD mute %d\n", cp->un.ord));
	    error = 0;
	}
	break;

    case WSS_DAC_LVL:		/* dac out */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (wss_to_vol(cp, &vol))
		error = ad1848_set_out_gain(ac, &vol);
	}
	break;
	
    case WSS_DAC_MUTE:		/* dac out */
	if (cp->type == AUDIO_MIXER_ENUM) {
	    sc->dac_mute = cp->un.ord;
	    DPRINTF(("DAC mute %d\n", cp->un.ord));
	    error = 0;
	}
	break;

    case WSS_REC_LVL:		/* record level */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    if (wss_to_vol(cp, &vol))
		error = ad1848_set_rec_gain(ac, &vol);
	}
	break;
	
    case WSS_RECORD_SOURCE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    error = ad1848_set_rec_port(ac, cp->un.ord);
	}
	break;
d187 1
a187 13
    case WSS_MON_LVL:
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    vol.left  = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
	    error = ad1848_set_mon_gain(ac, &vol);
	}
	break;

    default:
	    return ENXIO;
	    /*NOTREACHED*/
    }
    
    return 0;
a195 79
    struct wss_softc *sc = ac->parent;
    struct ad1848_volume vol;
    int error = EINVAL;
    
    DPRINTF(("wss_mixer_get_port: port=%d\n", cp->dev));

    switch (cp->dev) {
    case WSS_MIC_IN_LVL:	/* Microphone */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_aux2_gain(ac, &vol);
	    if (!error)
		wss_from_vol(cp, &vol);
	}
	break;

    case WSS_MIC_IN_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->mic_mute;
	    error = 0;
	}
	break;

    case WSS_LINE_IN_LVL:	/* linein/CD */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_aux1_gain(ac, &vol);
	    if (!error)
		wss_from_vol(cp, &vol);
	}
	break;

    case WSS_LINE_IN_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->cd_mute;
	    error = 0;
	}
	break;

    case WSS_DAC_LVL:		/* dac out */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_out_gain(ac, &vol);
	    if (!error)
		wss_from_vol(cp, &vol);
	}
	break;

    case WSS_DAC_MUTE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = sc->dac_mute;
	    error = 0;
	}
	break;

    case WSS_REC_LVL:		/* record level */
	if (cp->type == AUDIO_MIXER_VALUE) {
	    error = ad1848_get_rec_gain(ac, &vol);
	    if (!error)
		wss_from_vol(cp, &vol);
	}
	break;

    case WSS_RECORD_SOURCE:
	if (cp->type == AUDIO_MIXER_ENUM) {
	    cp->un.ord = ad1848_get_rec_port(ac);
	    error = 0;
	}
	break;

    case WSS_MON_LVL:		/* monitor level */
	if (cp->type == AUDIO_MIXER_VALUE && cp->un.value.num_channels == 1) {
	    error = ad1848_get_mon_gain(ac, &vol);
	    if (!error)
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol.left;
	}
	break;

    default:
	error = ENXIO;
	break;
    }
d197 1
a197 1
    return(error);
@


1.14
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 2
a2 2
/*	$OpenBSD: wss.c,v 1.12 1996/05/29 08:18:01 mickey Exp $	*/
/*	$NetBSD: wss.c,v 1.13 1996/05/12 23:54:16 mycroft Exp $	*/
d50 1
d62 2
a63 20
#include <dev/isa/opti.h>

/*
 * Mixer devices
 */
#define WSS_MIC_IN_LVL		0
#define WSS_LINE_IN_LVL		1
#define WSS_DAC_LVL		2
#define WSS_REC_LVL		3
#define WSS_MON_LVL		4
#define WSS_MIC_IN_MUTE		5
#define WSS_LINE_IN_MUTE	6
#define WSS_DAC_MUTE		7

#define WSS_RECORD_SOURCE	8

/* Classes */
#define WSS_INPUT_CLASS		9
#define WSS_RECORD_CLASS	10
#define WSS_MONITOR_CLASS	11
a71 12
struct wss_softc {
	struct	device sc_dev;		/* base device */
	struct	isadev sc_id;		/* ISA device */
	void	*sc_ih;			/* interrupt vectoring */

	struct  ad1848_softc sc_ad1848;
#define wss_irq    sc_ad1848.sc_irq
#define wss_drq    sc_ad1848.sc_drq

	int 	mic_mute, cd_mute, dac_mute;
};

a77 1
int	wssopen __P((dev_t, int));
a78 1
int	wss_setfd __P((void *, int));
a79 4
int	wss_set_out_port __P((void *, int));
int	wss_get_out_port __P((void *));
int	wss_set_in_port __P((void *, int));
int	wss_get_in_port __P((void *));
d86 1
d92 1
a92 1
	wssopen,
a94 4
	ad1848_set_in_sr,
	ad1848_get_in_sr,
	ad1848_set_out_sr,
	ad1848_get_out_sr,
d96 1
a96 5
	ad1848_set_format,
	ad1848_get_encoding,
	ad1848_get_precision,
	ad1848_set_channels,
	ad1848_get_channels,
a97 4
	wss_set_out_port,
	wss_get_out_port,
	wss_set_in_port,
	wss_get_in_port,
d99 2
a100 2
	NULL,
	NULL,
a104 2
	ad1848_cont_out_dma,
	ad1848_cont_in_dma,
d107 1
a107 1
	wss_setfd,
d111 5
a115 2
	0,	/* not full-duplex */
	0
a117 80
int	wssprobe __P((struct device *, void *, void *));
void	wssattach __P((struct device *, struct device *, void *));

struct cfattach wss_ca = {
	sizeof(struct wss_softc), wssprobe, wssattach
};

struct cfdriver wss_cd = {
	NULL, "wss", DV_DULL
};

/*
 * Probe for the Microsoft Sound System hardware.
 */
int
wssprobe(parent, match, aux)
    struct device *parent;
    void *match, *aux;
{
    register struct wss_softc *sc = match;
    register struct isa_attach_args *ia = aux;
    register int iobase = ia->ia_iobase;
    static u_char interrupt_bits[12] = {
	-1, -1, -1, -1, -1, -1, -1, 0x08, -1, 0x10, 0x18, 0x20
    };
    static u_char dma_bits[4] = {1, 2, 0, 3};
    
    if (!WSS_BASE_VALID(ia->ia_iobase)) {
	DPRINTF(("wss: configured iobase %x invalid\n", ia->ia_iobase));
	return 0;
    }

    if( !opti_snd_setup( OPTI_WSS, iobase, ia->ia_irq, ia->ia_drq ) )
       DPRINTF(("ad_detect_A: could not setup OPTi chipset.\n"));

    sc->sc_ad1848.sc_iobase = iobase + WSS_CODEC;

    /* Is there an ad1848 chip at the WSS iobase ? */
    if (ad1848_probe(&sc->sc_ad1848) == 0) {
#if 0
	DPRINTF(("ad_detect_A: no ad1848 found.\n"));
#endif
	return 0;
    }
	
    ia->ia_iosize = WSS_NPORT;

    /* Setup WSS interrupt and DMA */
    if (!WSS_DRQ_VALID(ia->ia_drq)) {
	DPRINTF(("wss: configured dma chan %d invalid\n", ia->ia_drq));
	return 0;
    }
    sc->wss_drq = ia->ia_drq;

#ifdef NEWCONFIG
    /*
     * If the IRQ wasn't compiled in, auto-detect it.
     */
    if (ia->ia_irq == IRQUNK) {
	ia->ia_irq = isa_discoverintr(ad1848_forceintr, &sc->sc_ad1848);
	if (!WSS_IRQ_VALID(ia->ia_irq)) {
	    printf("wss: couldn't auto-detect interrupt\n");
	    return 0;
	}
    }
    else
#endif
    if (!WSS_IRQ_VALID(ia->ia_irq)) {
	DPRINTF(("wss: configured interrupt %d invalid\n", ia->ia_irq));
	return 0;
    }

    sc->wss_irq = ia->ia_irq;

    outb(iobase+WSS_CONFIG,
	 (interrupt_bits[ia->ia_irq] | dma_bits[ia->ia_drq]));

    return 1;
}

d123 2
a124 3
wssattach(parent, self, aux)
    struct device *parent, *self;
    void *aux;
d126 1
a126 4
    register struct wss_softc *sc = (struct wss_softc *)self;
    struct isa_attach_args *ia = (struct isa_attach_args *)aux;
    register int iobase = ia->ia_iobase;
    int err;
d128 1
a128 1
    sc->sc_ad1848.sc_recdrq = ia->ia_drq;
d130 1
a130 4
#ifdef NEWCONFIG
    isa_establish(&sc->sc_id, &sc->sc_dev);
#endif
    sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE, IPL_AUDIO,
d135 18
a152 1
    printf(" (vers %d)", inb(iobase+WSS_STATUS) & WSS_VERSMASK);
d157 1
a157 2
    if ((err = audio_hardware_attach(&wss_hw_if, &sc->sc_ad1848)) != 0)
	printf("wss: could not attach to audio pseudo-device driver (%d)\n", err);
a194 18
wssopen(dev, flags)
    dev_t dev;
    int flags;
{
    struct wss_softc *sc;
    int unit = AUDIOUNIT(dev);
    
    if (unit >= wss_cd.cd_ndevs)
	return ENODEV;
    
    sc = wss_cd.cd_devs[unit];
    if (!sc)
	return ENXIO;
    
    return ad1848_open(&sc->sc_ad1848, dev, flags);
}

int
a203 78
wss_setfd(addr, flag)
    void *addr;
    int flag;
{
    /* Can't do full-duplex */
    return(ENOTTY);
}


int
wss_set_out_port(addr, port)
    void *addr;
    int port;
{
    DPRINTF(("wss_set_out_port:\n"));
    return(EINVAL);
}

int
wss_get_out_port(addr)
    void *addr;
{
    DPRINTF(("wss_get_out_port:\n"));
    return(WSS_DAC_LVL);
}

int
wss_set_in_port(addr, port)
    void *addr;
    int port;
{
    register struct ad1848_softc *ac = addr;
	
    DPRINTF(("wss_set_in_port: %d\n", port));

    switch(port) {
    case WSS_MIC_IN_LVL:
	port = MIC_IN_PORT;
	break;
    case WSS_LINE_IN_LVL:
	port = LINE_IN_PORT;
	break;
    case WSS_DAC_LVL:
	port = DAC_IN_PORT;
	break;
    default:
	return(EINVAL);
	/*NOTREACHED*/
    }
    
    return(ad1848_set_rec_port(ac, port));
}

int
wss_get_in_port(addr)
    void *addr;
{
    register struct ad1848_softc *ac = addr;
    int port = WSS_MIC_IN_LVL;
    
    switch(ad1848_get_rec_port(ac)) {
    case MIC_IN_PORT:
	port = WSS_MIC_IN_LVL;
	break;
    case LINE_IN_PORT:
	port = WSS_LINE_IN_LVL;
	break;
    case DAC_IN_PORT:
	port = WSS_DAC_LVL;
	break;
    }

    DPRINTF(("wss_get_in_port: %d\n", port));

    return(port);
}

int
d208 2
a209 2
    register struct ad1848_softc *ac = addr;
    register struct wss_softc *sc = ac->parent;
d294 2
a295 2
    register struct ad1848_softc *ac = addr;
    register struct wss_softc *sc = ac->parent;
d381 1
a381 1
    register mixer_devinfo_t *dip;
d439 1
a439 1
	strcpy(dip->label.name, AudioCInputs);
d446 1
a446 1
	strcpy(dip->label.name, AudioNmonitor);
d453 1
a453 1
	strcpy(dip->label.name, AudioNrecord);
d506 133
@


1.13
log
@probe must be silent if no device
@
text
@d134 1
a134 1
	ad1848_set_encoding,
a135 1
	ad1848_set_precision,
a144 1
	ad1848_get_silence,
a162 4
#ifndef NEWCONFIG
#define at_dma(flags, ptr, cc, chan)	isa_dmastart(flags, ptr, cc, chan)
#endif

d191 1
a191 1
	printf("wss: configured iobase %x invalid\n", ia->ia_iobase);
d196 1
a196 5
#ifdef DEBUG
       printf("ad_detect_A: could not setup OPTi chipset.\n");
#else
       ;
#endif
d198 1
a198 1
    sc->sc_ad1848.sc_iobase = iobase;
d203 1
a203 1
	printf("ad_detect_A: no ad1848 found.\n");
d212 1
a212 1
	printf("wss: configured dma chan %d invalid\n", ia->ia_drq);
d231 1
a231 1
	printf("wss: configured interrupt %d invalid\n", ia->ia_irq);
d361 1
a361 1
    return(EINVAL);
@


1.12
log
@show "OPTi not found" message in debug mode only.
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.11 1996/05/26 00:27:32 deraadt Exp $	*/
d212 1
d214 1
@


1.11
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.10 1996/05/07 07:38:08 deraadt Exp $	*/
d202 1
d204 3
@


1.10
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: wss.c,v 1.8 1996/04/21 22:24:49 deraadt Exp $	*/
/*	$NetBSD: wss.c,v 1.12 1996/04/29 19:46:09 christos Exp $	*/
d49 1
@


1.9
log
@Add OPTi 82C929 chipset support for sound(wss,sb)/cd(mcd,scd,pcd,atapi)
card. This is software programable card.
Missing:	SB support (no srcs available, and dos's exe is too big ;)
Not tested:	pcd(panasonic cd)(no driver); mcd,atapi(have no hw).
@
text
@d2 1
a2 1
/*	$NetBSD: wss.c,v 1.11 1996/04/11 22:30:46 cgd Exp $	*/
d118 2
a372 1
    register struct wss_softc *sc = ac->parent;
a398 1
    register struct wss_softc *sc = ac->parent;
a425 1
    u_char eq;
a511 1
    u_char eq;
a597 3
    register struct ad1848_softc *ac = addr;
    register struct wss_softc *sc = ac->parent;

@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.7 1996/03/20 01:01:06 mickey Exp $	*/
d60 1
d198 3
d204 2
a205 1
    if (ad1848_probe(&sc->sc_ad1848) == 0)
d207 1
@


1.7
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: wss.c,v 1.6 1996/03/19 21:10:36 mickey Exp $	*/
/*	$NetBSD: wss.c,v 1.9 1996/02/16 08:18:36 mycroft Exp $	*/
d168 6
a173 2
struct cfdriver wsscd = {
	NULL, "wss", wssprobe, wssattach, DV_DULL, sizeof(struct wss_softc)
d257 2
a258 2
    sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_AUDIO, ad1848_intr,
				   &sc->sc_ad1848, sc->sc_dev.dv_xname);
d313 1
a313 1
    if (unit >= wsscd.cd_ndevs)
d316 1
a316 1
    sc = wsscd.cd_devs[unit];
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: wss.c,v 1.5 1996/03/08 16:43:17 niklas Exp $	*/
d254 1
a254 1
				   &sc->sc_ad1848);
@


1.5
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d254 1
a254 1
				   &sc->sc_ad1848, sc->sc_dev.dv_xname);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: wss.c,v 1.7 1995/11/10 04:30:52 mycroft Exp $	*/
a104 2
int	wssprobe();
void	wssattach();
a105 1

d165 3
d176 3
a178 3
wssprobe(parent, self, aux)
    struct device *parent, *self;
    void *aux;
d180 1
a180 1
    register struct wss_softc *sc = (void *)self;
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d252 2
a253 1
    sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_AUDIO, ad1848_intr,	&sc->sc_ad1848);
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d252 1
a252 2
    sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
				   ad1848_intr, &sc->sc_ad1848);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: wss.c,v 1.6 1995/07/07 02:15:12 brezak Exp $	*/
d181 1
a181 1
    register u_short iobase = ia->ia_iobase;
d244 1
a244 1
    register u_short iobase = ia->ia_iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
