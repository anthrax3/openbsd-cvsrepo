head	1.11;
access;
symbols
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	UBC_SYNC_A:1.11
	UBC_SYNC_B:1.11
	SMP:1.11.0.2
	OPENBSD_2_3:1.10.0.6
	OPENBSD_2_3_BASE:1.10
	OPENBSD_2_2:1.10.0.4
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.10.0.2
	OPENBSD_2_1_BASE:1.10
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.11
date	98.09.11.11.08.17;	author fgsch;	state dead;
branches;
next	1.10;

1.10
date	97.03.01.22.42.57;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.29.22.55.05;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.21.46.44;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.10.18.15.43.06;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.10.17.21.45.28;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.17.21.43.52;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.10.16.12.36.02;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.03.07.59.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.04.29.14.16.47;	author hvozda;	state Exp;
branches;
next	1.1;

1.1
date	96.01.16.20.13.01;	author hvozda;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Remove unneeded files from the previous pcmcia framework.
@
text
@/*	$OpenBSD: pcmcia_isa.c,v 1.10 1997/03/01 22:42:57 niklas Exp $	*/
/*
 * Copyright (c) 1995,1996 John T. Kohl.  All rights reserved.
 * Copyright (c) 1994 Stefan Grefen.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

/* TODO add modload support and loadable lists of devices */
/* How to do cards with more than one function (modem/ethernet ..) */
#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <vm/vm.h>

#include <machine/bus.h>

#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciareg.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/i8042reg.h>
#include <i386/isa/isa_machdep.h>       /* XXX USES ISA HOLE DIRECTLY */

#ifdef IBM_WD
#define PCMCIA_ISA_DEBUG
#endif

#ifdef PCMCIA_ISA_DEBUG
#define STATIC
#else
#define STATIC static
#endif

STATIC int pcmcia_isa_init __P((struct device *, struct cfdata *,
				void *, struct pcmcia_adapter *, int));
STATIC int pcmcia_isa_search __P((struct device *, void *, cfprint_t));
STATIC int pcmcia_isa_probe __P((struct device *, void *,
				 void *, struct pcmcia_link *));
STATIC int pcmcia_isa_config __P((struct pcmcia_link *, struct device *,
				  struct pcmcia_conf *, struct cfdata *));
STATIC int pcmcia_isa_unconfig __P((struct pcmcia_link *));

struct pcmciabus_link pcmcia_isa_link = {
	pcmcia_isa_config,
	pcmcia_isa_unconfig,
	pcmcia_isa_probe,
	pcmcia_isa_search,
	pcmcia_isa_init
};

/* copy out the addr and length from machine specific attach struct */
STATIC int
pcmcia_isa_init(parent, cf, aux, pca, flag)
	struct device  *parent;
	struct cfdata  *cf;
	void           *aux;
	struct pcmcia_adapter *pca;
	int             flag;
{
	struct pcmciabus_attach_args *pa = aux;

#ifdef PCMCIA_ISA_DEBUG
	if (parent != NULL)
		printf("PARENT %s\n", parent->dv_xname);
#endif
	if (flag == 0) {		/* match */
		pca->scratch_memsiz = pa->pba_msize;
		pca->scratch_memh = pa->pba_memh;
		pca->pa_memt = pa->pba_memt;
#ifdef PCMCIA_ISA_DEBUG
		printf("pbaaddr %p maddr %x msize %x\n",
		    pa, pa->pba_maddr, pa->pba_msize);
		printf("PCA %p mem %p size %d memt %x memh %x\n",
		    pca, pca->scratch_mem, pca->scratch_memsiz,
		    pca->pa_memt, pca->scratch_memh);
#endif
	}
	return 1;
}

/* Ease some typing by providing a nice typedef. */
typedef int (*probe_t) __P((struct device *, void *, void *,
    struct pcmcia_link *));

/* probe and attach a device, the has to be configured already */
STATIC int
pcmcia_isa_probe(parent, match, aux, pc_link)
	struct device  *parent;
	void	       *match;
	void           *aux;
	struct pcmcia_link *pc_link;
{
	struct device *dev = match;
	struct cfdata  *cf = aux;
	struct isa_attach_args ia;
	struct pcmciadevs *pcs = pc_link->device;
	probe_t probe = (pcs != NULL) ? pcs->dev->pcmcia_probe : NULL;

	if (cf->cf_loc[6] != -1 && cf->cf_loc[6] != pc_link->slot) {
#ifdef PCMCIA_ISA_DEBUG
	    printf("- isa probe slot mismatch: cf %d <> link %d\n",
		   cf->cf_loc[6], pc_link->slot);
#endif
	    return 0;
	}
#if 0
	if (pcs == NULL || pcs->dev->pcmcia_probe == NULL) {
#ifdef PCMCIA_ISA_DEBUG
		printf("- isa probe null proberoutine %p\n", pcs);
#endif
		return 0;
	}
#endif
	ia.ia_iobase = cf->cf_loc[0];
	ia.ia_iosize = cf->cf_loc[1] == -1 ? 0x666 : cf->cf_loc[1];
	ia.ia_maddr = cf->cf_loc[2];
	ia.ia_msize = cf->cf_loc[3];
	ia.ia_irq = cf->cf_loc[4] == 2 ? 9 : cf->cf_loc[4] ;
	ia.ia_drq = cf->cf_loc[5];
	ia.ia_iot = pc_link->bus->sc_iot;
	ia.ia_memt = pc_link->bus->sc_memt;

#ifdef PCMCIA_ISA_DEBUG
	printf("pcmcia probe %x %x %p\n", ia.ia_iobase, ia.ia_irq,
	    probe == NULL ? cf->cf_attach->ca_match : probe);
	printf("parentname = %s\n", parent->dv_xname);
	printf("devname = %s\n", dev->dv_xname);
	printf("driver name = %s\n", cf->cf_driver->cd_name);
#endif
	if ((probe == NULL ? (*cf->cf_attach->ca_match)(parent, dev, &ia) :
	    (*probe)(parent, dev, &ia, pc_link)) > 0) {
		extern int isaprint __P((void *, const char *));

		config_attach(parent, dev, &ia, isaprint);
#ifdef PCMCIA_ISA_DEBUG
		printf("biomask %x netmask %x ttymask %x\n",
		       (u_short) imask[IPL_BIO], (u_short) imask[IPL_NET],
		       (u_short) imask[IPL_TTY]);
#endif
		return 1;
	}
	else if (parent->dv_cfdata->cf_driver->cd_indirect == 0)
		free(dev, M_DEVBUF);
	return 0;
}

/*
 * Modify a pcmcia_conf struct to match the config entry. Pc_cf was filled
 * with config data from the card and may be modified before and after the
 * call to pcmcia_isa_config. Unless the FIXED_WIN flag is set we assume
 * contiguous windows and shift according to the offset for the first not
 * fixed window
 */
STATIC int
pcmcia_isa_config(pc_link, self, pc_cf, cf)
	struct pcmcia_link *pc_link;
	struct device  *self;
	struct pcmcia_conf *pc_cf;
	struct cfdata  *cf;
{
	struct isa_attach_args ia;
	struct pcmciadevs *pcs = pc_link->device;

	ia.ia_iobase = cf->cf_loc[0];
	ia.ia_iosize = 0x666;
	ia.ia_maddr = cf->cf_loc[2];
	ia.ia_msize = cf->cf_loc[3];
	ia.ia_irq = cf->cf_loc[4];
	ia.ia_drq = cf->cf_loc[5];
#ifdef PCMCIA_ISA_DEBUG
	printf("pcmcia_isa_config iobase=%x maddr=%x msize=%x irq=%d drq=%d slot=%d\n",
	       ia.ia_iobase, ISA_HOLE_VADDR(ia.ia_maddr), ia.ia_msize,
	       ia.ia_irq, ia.ia_drq, cf->cf_loc[6]);
#endif

	if (pcs && strcmp(pcs->devname, self->dv_cfdata->cf_driver->cd_name)) {
#ifdef PCMCIA_ISA_DEBUG
		printf("- wrong driver %s vs %s\n", pcs->devname,
		       self->dv_cfdata->cf_driver->cd_name);
#endif
		return ENODEV;
	}

	if (ia.ia_irq != IRQUNK) {
		int             irq = 1 << ia.ia_irq;
		/*
		 * This is tricky irq 9 must match irq 2 in a device mask and
		 * configured  irq 9 must match irq 2
		 */
#ifdef PCMCIA_ISA_DEBUG
		printf("pcmcia_isa_config irq=%x num=%x mask=%x and=%x\n", irq,
		       1 << pc_cf->irq_num, pc_cf->irq_mask,
		       irq & pc_cf->irq_mask);
#endif
		if (irq != (1 << pc_cf->irq_num) &&
		    !(irq == (1 << 9) && pc_cf->irq_num == 2)) {
			if (irq == (1 << 9) || irq == (1 << 2))
				irq = (1 << 9) | (1 << 2);
			if ((irq & pc_cf->irq_mask) == 0) {
				printf("%s: slot %d requested irq %d, avail_mask %x\n",
				       self->dv_parent->dv_xname,
				       pc_link->slot,
				       ia.ia_irq,
				       pc_cf->irq_mask);
				return ENODEV;
			}
			/* 2 is 9 is 2 ... */
			irq&=~(1 << 2);
			cf->cf_loc[4] = pc_cf->irq_num = ffs(irq) - 1;
#ifdef PCMCIA_ISA_DEBUG
			printf("pcmcia_isa_config modify num=%x\n",
			       pc_cf->irq_num);
#endif
		}
	}
	if (ia.ia_iobase != IOBASEUNK) {
		int             i;
		int             offs = 0;
		if (pc_cf->iowin == 0)
			return 0;
		for (i = 0; i < pc_cf->iowin; i++) {
			if (pc_cf->io[i].flags & PCMCIA_FIXED_WIN)
				continue;
			if (offs == 0) {
				if (pc_cf->io[i].start != ia.ia_iobase) {
					offs = ia.ia_iobase - 
					       pc_cf->io[i].start;
				} else
					break;
			}
			pc_cf->io[i].start += offs;
		}
	} else
		pc_cf->iowin = 0;
	if (ia.ia_maddr != MADDRUNK && ia.ia_msize) {
		int             i;
		unsigned long   offs = 0;
		int             mlen = ia.ia_msize;
		int		maddr = (int) ISA_HOLE_VADDR(ia.ia_maddr);

		if (pc_cf->memwin == 0)
			return ENODEV;

#ifdef PCMCIA_ISA_DEBUG
		printf("Doing ia=%x ma=%x ms=%d\n", ia.ia_maddr,
		       maddr, ia.ia_msize);
#endif
		for (i = 0; i < pc_cf->memwin && mlen > 0; i++) {
#ifdef PCMCIA_ISA_DEBUG
		printf("Doing i=%d st=%x len=%d, flags=%x offs=%d mlen=%d\n",
		       i, pc_cf->mem[i].start, pc_cf->mem[i].len,
		       pc_cf->mem[i].flags, offs, mlen);
#endif
			if (pc_cf->mem[i].flags & PCMCIA_FIXED_WIN)
				continue;
			if (offs == 0) {
				if (pc_cf->mem[i].start != maddr) {
					offs = maddr - pc_cf->mem[i].start;
				} else
					break;
			}
			mlen -= pc_cf->mem[i].len;
			if (mlen < 0)
				pc_cf->mem[i].len += mlen;
			pc_cf->mem[i].start += offs;
		}
	} else
		pc_cf->memwin = 0;
	return 0;
}


STATIC int
pcmcia_isa_unconfig(pc_link)
	struct pcmcia_link *pc_link;
{
#if 0
	if (pc_link && pc_link->intr > 0) {
		/* THIS IS A GUESS ... TODO check all possible drivers */
		struct softc {
			struct device   sc_dev;
			void *sc_ih;
			bus_space_tag_t sc_iot;
			bus_space_tag_t sc_memt;
		} *sc = pc_link->devp;
		if (sc)
			isa_intr_disestablish(sc->sc_ic, sc->sc_ih);
	}
#endif
	return 0;
}

/* Searches for for configured devices on the pcmciabus */
STATIC int
pcmcia_isa_search(parent, aux, print)
	struct device  *parent;
	void           *aux;
	cfprint_t       print;
{
	static char    *msgs[3] = {"", " not configured\n", " unsupported\n"};

#ifdef PCMCIA_ISA_DEBUG
	printf("pcmcia_isa_search\n");
#endif
	if (config_search(pcmcia_configure, parent, aux) != NULL)
		return 1;

	if (print) {
		int i;
		i = (*print) (aux, parent->dv_xname);
		printf(msgs[i]);
	}
	return 0;
}
@


1.10
log
@Corrected ISA memory mapping errors that caused PCMCIA to be broken.
Thanks to Angelos who helped my debug this.
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_isa.c,v 1.9 1996/11/29 22:55:05 niklas Exp $	*/
@


1.9
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_isa.c,v 1.8 1996/11/23 21:46:44 kstailey Exp $	*/
a88 1
	bus_space_handle_t memh;
a94 3
		if (bus_space_map(pa->pba_memt, pa->pba_maddr, pa->pba_msize,
		    0, &memh))
			return 0;
d96 1
a96 1
		pca->scratch_memh = memh;
@


1.8
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_isa.c,v 1.7 1996/10/18 15:43:06 deraadt Exp $	*/
d42 2
d89 1
a89 1
	bus_mem_handle_t memh;
d96 2
a97 2
		if (bus_mem_map(pa->pba_bc, pa->pba_maddr, pa->pba_msize, 0,
				&memh))
d101 1
a101 1
		pca->pa_bc = pa->pba_bc;
d104 4
a107 4
		       pa, pa->pba_maddr, pa->pba_msize);
		printf("PCA %p mem %p size %d chip %x memh %x\n",
		       pca, pca->scratch_mem, pca->scratch_memsiz,
		       pca->pa_bc, pca->scratch_memh);
d152 2
a153 1
	ia.ia_bc = pc_link->bus->sc_bc;
d315 2
a316 1
			bus_chipset_tag_t sc_bc;
d319 1
a319 1
			isa_intr_disestablish(sc->sc_bc, sc->sc_ih);
@


1.7
log
@extern isaprint
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_isa.c,v 1.6 1996/10/17 21:45:28 niklas Exp $	*/
d161 1
a161 1
		extern int isaprint __P((void *, char *));
@


1.6
log
@Oops, forgot a pair of parenthesis
@
text
@d1 1
a1 1
/*	$OpenBSD: pcmcia_isa.c,v 1.4 1996/10/16 12:36:02 deraadt Exp $	*/
d161 2
@


1.5
log
@-Wall happiness
@
text
@d159 2
a160 2
	if (probe == NULL ? (*cf->cf_attach->ca_match)(parent, dev, &ia) :
	    (*probe)(parent, dev, &ia, pc_link) > 0) {
@


1.4
log
@unused vars, protos
@
text
@d1 1
a1 1
/*	$Id: pcmcia_isa.c,v 1.3 1996/05/03 07:59:36 deraadt Exp $	*/
d111 4
d127 1
a127 1
	int (*probe) () = (pcs != NULL) ? pcs->dev->pcmcia_probe : NULL;
a150 2
	if (probe == NULL)
		probe = cf->cf_attach->ca_match;
d153 2
a154 1
	printf("pcmcia probe %x %x %p\n", ia.ia_iobase, ia.ia_irq, probe);
d159 2
a160 2
	if ((*probe) (parent, dev, &ia, pc_link) > 0) {
		extern isaprint();
@


1.3
log
@prettier printf messages
@
text
@d1 1
a1 1
/*	$Id: pcmcia_isa.c,v 1.2 1996/04/29 14:16:47 hvozda Exp $	*/
a87 1
	vm_offset_t physaddr;
@


1.2
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@d1 1
a1 1
/*	$Id: pcmcia_isa.c,v 1.14 1996/04/15 23:55:15 jtk Exp $	*/
d106 1
a106 1
		       pca->scratch_chipset, pca->scratch_memh);
@


1.1
log
@Last of the glue and devices for for PCMCIA support from Stefan Grefen
<grefen@@convex.com> with modifications by John Kohl <jtk@@kolvir.blrc.ma.us>
@
text
@d1 1
d3 1
a30 1
 *      $Id: pcmcia_isa.c,v 1.2 1995/10/08 03:12:32 jtkohl Exp $
d40 1
d42 2
a43 2
#include <dev/pcmcia/pcmcia.h>
#include <dev/pcmcia/pcmciabus.h>
d54 7
a60 1
static int pcmcia_isa_init __P((struct device *, struct cfdata *,
d62 2
a63 2
static int pcmcia_isa_search __P((struct device *, void *, cfprint_t));
static int pcmcia_isa_probe __P((struct device *, void *,
d65 1
a65 1
static int pcmcia_isa_config __P((struct pcmcia_link *, struct device *,
d67 1
a67 1
static int pcmcia_isa_unconfig __P((struct pcmcia_link *));
d78 1
a78 1
static int
d86 3
a88 1
	struct isa_attach_args *ia = aux;
d94 14
a107 3
	if (flag) {		/* attach */
		pca->scratch_mem = (caddr_t) ISA_HOLE_VADDR(ia->ia_maddr);
		pca->scratch_memsiz = ia->ia_msize;
a108 1
	ia->ia_iosize = 0;
d113 1
a113 1
static int
d126 15
d142 1
a142 1
	ia.ia_iosize = 0x666;
d145 1
a145 1
	ia.ia_irq = cf->cf_loc[4];
d147 1
d149 1
a149 1
		probe = cf->cf_driver->cd_match;
d152 1
a152 1
	printf("pcmcia probe %x %x %x\n", ia.ia_iobase, ia.ia_irq, probe);
d158 1
a158 1
		extern          isaprint();
d167 1
a167 1
	else
d179 1
a179 1
static int
d187 1
d196 1
a196 1
	printf("pcmcia_isa_config iobase=%x maddr=%x msize=%x irq=%x drq=%x\n",
d198 1
a198 1
	       ia.ia_irq, ia.ia_drq);
d201 8
d225 4
a228 1
				printf("irq %d mask %x\n", ia.ia_irq,
d298 1
a298 1
static int
d302 1
d308 1
d311 1
a311 1
			isa_intr_disestablish(sc->sc_ih);
d313 1
d318 1
a318 1
static int
@
