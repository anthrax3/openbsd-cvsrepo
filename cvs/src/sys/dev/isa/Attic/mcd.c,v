head	1.61;
access;
symbols
	OPENBSD_4_9:1.56.0.2
	OPENBSD_4_9_BASE:1.56
	OPENBSD_4_8:1.53.0.2
	OPENBSD_4_8_BASE:1.53
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.51.0.6
	OPENBSD_4_6_BASE:1.51
	OPENBSD_4_5:1.51.0.2
	OPENBSD_4_5_BASE:1.51
	OPENBSD_4_4:1.50.0.2
	OPENBSD_4_4_BASE:1.50
	OPENBSD_4_3:1.49.0.4
	OPENBSD_4_3_BASE:1.49
	OPENBSD_4_2:1.49.0.2
	OPENBSD_4_2_BASE:1.49
	OPENBSD_4_1:1.41.0.2
	OPENBSD_4_1_BASE:1.41
	OPENBSD_4_0:1.40.0.2
	OPENBSD_4_0_BASE:1.40
	OPENBSD_3_9:1.35.0.2
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.34.0.6
	OPENBSD_3_8_BASE:1.34
	OPENBSD_3_7:1.34.0.4
	OPENBSD_3_7_BASE:1.34
	OPENBSD_3_6:1.34.0.2
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.34
	SMP_SYNC_B:1.34
	OPENBSD_3_5:1.33.0.2
	OPENBSD_3_5_BASE:1.33
	OPENBSD_3_4:1.32.0.2
	OPENBSD_3_4_BASE:1.32
	UBC_SYNC_A:1.32
	OPENBSD_3_3:1.31.0.4
	OPENBSD_3_3_BASE:1.31
	OPENBSD_3_2:1.31.0.2
	OPENBSD_3_2_BASE:1.31
	OPENBSD_3_1:1.30.0.2
	OPENBSD_3_1_BASE:1.30
	UBC_SYNC_B:1.31
	UBC:1.29.0.6
	UBC_BASE:1.29
	OPENBSD_3_0:1.29.0.4
	OPENBSD_3_0_BASE:1.29
	OPENBSD_2_9_BASE:1.29
	OPENBSD_2_9:1.29.0.2
	OPENBSD_2_8:1.28.0.8
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.28.0.6
	OPENBSD_2_7_BASE:1.28
	SMP:1.28.0.4
	SMP_BASE:1.28
	kame_19991208:1.28
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.27.0.4
	OPENBSD_2_5_BASE:1.27
	OPENBSD_2_4:1.27.0.2
	OPENBSD_2_4_BASE:1.27
	OPENBSD_2_3:1.23.0.2
	OPENBSD_2_3_BASE:1.23
	OPENBSD_2_2:1.22.0.2
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.19.0.2
	OPENBSD_2_1_BASE:1.19
	OPENBSD_2_0:1.17.0.2
	OPENBSD_2_0_BASE:1.17
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.61
date	2011.06.26.23.19.11;	author tedu;	state dead;
branches;
next	1.60;

1.60
date	2011.06.20.08.47.59;	author matthew;	state Exp;
branches;
next	1.59;

1.59
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.58;

1.58
date	2011.06.03.21.14.11;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.06.03.18.22.25;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.52;

1.52
date	2009.08.24.08.51.18;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2008.11.27.22.59.52;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2008.06.15.00.36.41;	author krw;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.18.20.55.52;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.05.00.38.21;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2007.05.04.22.14.36;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2007.04.29.22.22.34;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.40;

1.40
date	2006.08.13.16.24.13;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2006.03.10.18.13.10;	author miod;	state Exp;
branches;
next	1.37;

1.37
date	2006.03.09.23.06.20;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.03.09.23.05.18;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2006.01.02.05.21.40;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.05.01.23.23.13;	author millert;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.32;

1.32
date	2003.04.06.15.28.25;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2002.05.24.13.31.11;	author art;	state Exp;
branches;
next	1.30;

1.30
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.11.23.55.57;	author mickey;	state Exp;
branches
	1.29.6.1;
next	1.28;

1.28
date	99.08.10.23.09.49;	author deraadt;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	98.10.05.00.39.27;	author millert;	state Exp;
branches;
next	1.26;

1.26
date	98.10.04.21.25.41;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	98.10.03.21.19.00;	author millert;	state Exp;
branches;
next	1.24;

1.24
date	98.04.26.21.02.49;	author provos;	state Exp;
branches;
next	1.23;

1.23
date	97.11.30.22.33.21;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	97.10.18.10.37.12;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	97.09.29.12.01.27;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	97.08.08.21.47.02;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	97.01.04.08.50.25;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.12.05.13.15.28;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	96.09.20.06.08.10;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.06.10.00.48.05;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.06.09.19.40.12;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.06.01.09.35.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.27.07.57.34;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.05.26.00.27.25;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.07.07.37.20;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.04.24.16.51.16;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.22.24.21;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.03.20.01.00.56;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.19.21.10.25;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.08.16.43.09;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.36.01;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.12.20.21.20;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.01.12.20.14.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.31;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches;
next	;

1.28.4.1
date	2001.05.14.22.24.46;	author niklas;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.28.4.3;

1.28.4.3
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.28.4.4;

1.28.4.4
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	1.28.4.5;

1.28.4.5
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;

1.29.6.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.29.6.2;

1.29.6.2
date	2003.05.19.22.08.30;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.61
log
@kill mcd dead.  ok krw matthew millert thib
@
text
@/*	$OpenBSD: mcd.c,v 1.60 2011/06/20 08:47:59 matthew Exp $ */
/*	$NetBSD: mcd.c,v 1.60 1998/01/14 12:14:41 drochner Exp $	*/

/*
 * Copyright (c) 1993, 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * Copyright 1993 by Holger Veit (data part)
 * Copyright 1993 by Brian Moore (audio part)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This software was developed by Holger Veit and Brian Moore
 *      for use with "386BSD" and similar operating systems.
 *    "Similar operating systems" includes mainly non-profit oriented
 *    systems for research and education, including but not restricted to
 *    "NetBSD", "FreeBSD", "Mach" (by CMU).
 * 4. Neither the name of the developer(s) nor the name "386BSD"
 *    may be used to endorse or promote products derived from this
 *    software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE DEVELOPER(S) ``AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE DEVELOPER(S) BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY,
 * OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
 * OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*static char COPYRIGHT[] = "mcd-driver (C)1993 by H.Veit & B.Moore";*/

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <sys/stat.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <sys/dkio.h>
#include <sys/mtio.h>
#include <sys/cdio.h>
#include <sys/errno.h>
#include <sys/disklabel.h>
#include <sys/device.h>
#include <sys/disk.h>
#include <sys/timeout.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/isa/mcdreg.h>
#include <dev/isa/opti.h>

#ifndef MCDDEBUG
#define MCD_TRACE(fmt,a,b,c,d)
#else
#define MCD_TRACE(fmt,a,b,c,d)	{if (sc->debug) {printf("%s: st=%02x: ", sc->sc_dev.dv_xname, sc->status); printf(fmt,a,b,c,d);}}
#endif

/* toc */
#define MCD_MAXTOCS	104	/* from the Linux driver */

struct mcd_mbx {
	int		retry, count;
	struct buf	*bp;
	daddr64_t		blkno;
	int		nblk;
	int		sz;
	u_long		skip;
	int		state;
#define	MCD_S_IDLE	0
#define MCD_S_BEGIN	1
#define MCD_S_WAITMODE	2
#define MCD_S_WAITREAD	3
	int		mode;
};

struct mcd_softc {
	struct	device sc_dev;
	struct	disk sc_dk;
	void *sc_ih;
	struct timeout sc_pi_tmo;

	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;

	int	irq, drq;

	char	*type;
	int	flags;
#define	MCDF_LOADED	0x10	/* parameters loaded */
#define	MCDF_EJECTING	0x20	/* please eject at close */
	short	status;
	short	audio_status;
	int	blksize;
	u_long	disksize;
	struct	mcd_volinfo volinfo;
	union	mcd_qchninfo toc[MCD_MAXTOCS];
	struct	mcd_command lastpb;
	struct	mcd_mbx mbx;
	int	lastmode;
#define	MCD_MD_UNKNOWN	-1
	int	lastupc;
#define	MCD_UPC_UNKNOWN	-1
	struct	buf buf_queue;
	u_char	readcmd;
	u_char	debug;
	u_char	probe;
};

/* prototypes */
/* XXX does not belong here */
cdev_decl(mcd);
bdev_decl(mcd);

u_int8_t const __bcd2bin[] = {
	0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 0, 0, 0, 0, 0, 0,
	10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 0, 0, 0, 0, 0,
	20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 0, 0, 0, 0, 0, 0,
	30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 0, 0, 0, 0, 0, 0,
	40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 0, 0, 0, 0, 0, 0,
	50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 0, 0, 0, 0, 0, 0,
	60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 0, 0, 0, 0, 0, 0,
	70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 0, 0, 0, 0, 0, 0,
	80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 0, 0, 0, 0, 0, 0,
	90, 91, 92, 93, 94, 95, 96, 97, 98, 99
};

u_int8_t const __bin2bcd[] = {
	0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09,
	0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
	0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29,
	0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39,
	0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49,
	0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59,
	0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69,
	0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79,
	0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89,
	0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99
};
#define	bcd2bin(b)	(__bcd2bin[(b)&0xff])
#define	bin2bcd(b)	(__bin2bcd[(b)&0xff])

static void hsg2msf(int, bcd_t *);
static daddr64_t msf2hsg(bcd_t *, int);

int mcd_playtracks(struct mcd_softc *, struct ioc_play_track *);
int mcd_playmsf(struct mcd_softc *, struct ioc_play_msf *);
int mcd_playblocks(struct mcd_softc *, struct ioc_play_blocks *);
int mcd_stop(struct mcd_softc *);
int mcd_eject(struct mcd_softc *);
int mcd_read_subchannel(struct mcd_softc *, struct ioc_read_subchannel *);
int mcd_pause(struct mcd_softc *);
int mcd_resume(struct mcd_softc *);
int mcd_toc_header(struct mcd_softc *, struct ioc_toc_header *);
int mcd_toc_entries(struct mcd_softc *, struct ioc_read_toc_entry *);

int mcd_getreply(struct mcd_softc *);
int mcd_getstat(struct mcd_softc *);
int mcd_getresult(struct mcd_softc *, struct mcd_result *);
void mcd_setflags(struct mcd_softc *);
int mcd_get(struct mcd_softc *, char *, int);
int mcd_send(struct mcd_softc *, struct mcd_mbox *, int);
int mcdintr(void *);
void mcd_soft_reset(struct mcd_softc *);
int mcd_hard_reset(struct mcd_softc *);
int mcd_setmode(struct mcd_softc *, int);
int mcd_setupc(struct mcd_softc *, int);
int mcd_read_toc(struct mcd_softc *);
int mcd_getqchan(struct mcd_softc *, union mcd_qchninfo *, int);
int mcd_setlock(struct mcd_softc *, int);

int mcd_find(bus_space_tag_t, bus_space_handle_t, struct mcd_softc *);
int mcdprobe(struct device *, void *, void *);
void mcdattach(struct device *, struct device *, void *);

struct cfattach mcd_ca = {
	sizeof(struct mcd_softc), mcdprobe, mcdattach
};

struct cfdriver mcd_cd = {
	NULL, "mcd", DV_DISK
};

int	mcdgetdisklabel(dev_t, struct mcd_softc *, struct disklabel *, int);
int	mcd_get_parms(struct mcd_softc *);
void	mcdstrategy(struct buf *);
void	mcdstart(struct mcd_softc *);
void	mcd_pseudointr(void *);

#define MCD_RETRIES	3
#define MCD_RDRETRIES	3

/* several delays */
#define RDELAY_WAITMODE	300
#define RDELAY_WAITREAD	800

#define	DELAY_GRANULARITY	25	/* 25us */
#define DELAY_GETREPLY		100000	/* 100000 * 25us */

void
mcdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct mcd_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	struct mcd_mbox mbx;

	/* Map i/o space */
	if (bus_space_map(iot, ia->ia_iobase, MCD_NPORT, 0, &ioh)) {
		printf(": can't map i/o space\n");
		return;
	}

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;

	sc->probe = 0;
	sc->debug = 0;

	if (!mcd_find(iot, ioh, sc)) {
		printf(": mcd_find failed\n");
		return;
	}

	timeout_set(&sc->sc_pi_tmo, mcd_pseudointr, sc);

	/*
	 * Initialize and attach the disk structure.
	 */
	sc->sc_dk.dk_name = sc->sc_dev.dv_xname;
	disk_attach(&sc->sc_dev, &sc->sc_dk);

	printf(": model %s\n", sc->type != 0 ? sc->type : "unknown");

	(void) mcd_setlock(sc, MCD_LK_UNLOCK);

	mbx.cmd.opcode = MCD_CMDCONFIGDRIVE;
	mbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;
	mbx.cmd.data.config.subcommand = MCD_CF_IRQENABLE;
	mbx.cmd.data.config.data1 = 0x01;
	mbx.res.length = 0;
	(void) mcd_send(sc, &mbx, 0);

	mcd_soft_reset(sc);

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, mcdintr, sc, sc->sc_dev.dv_xname);
}

int
mcdopen(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	int error;
	int unit, part;
	struct mcd_softc *sc;

	unit = DISKUNIT(dev);
	if (unit >= mcd_cd.cd_ndevs)
		return ENXIO;
	sc = mcd_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

	if ((error = disk_lock(&sc->sc_dk)) != 0)
		return error;

	if (sc->sc_dk.dk_openmask != 0) {
		/*
		 * If any partition is open, but the disk has been invalidated,
		 * disallow further opens.
		 */
		if ((sc->flags & MCDF_LOADED) == 0) {
			error = EIO;
			goto bad3;
		}
	} else {
		/*
		 * Lock the drawer.  This will also notice any pending disk
		 * change or door open indicator and clear the MCDF_LOADED bit
		 * if necessary.
		 */
		(void) mcd_setlock(sc, MCD_LK_LOCK);

		if ((sc->flags & MCDF_LOADED) == 0) {
			/* Partially reset the state. */
			sc->lastmode = MCD_MD_UNKNOWN;
			sc->lastupc = MCD_UPC_UNKNOWN;

			sc->flags |= MCDF_LOADED;

			/* Set the mode, causing the disk to spin up. */
			if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
				goto bad2;

			/* Load the physical device parameters. */
			if (mcd_get_parms(sc) != 0) {
				error = ENXIO;
				goto bad2;
			}

			/* Read the table of contents. */
			if ((error = mcd_read_toc(sc)) != 0)
				goto bad2;

			/* Fabricate a disk label. */
			mcdgetdisklabel(dev, sc, sc->sc_dk.dk_label, 0);
		}
	}

	MCD_TRACE("open: partition=%d disksize=%d blksize=%d\n", part,
	    sc->disksize, sc->blksize, 0);

	part = DISKPART(dev);
	
	/* Check that the partition exists. */
	if (part != RAW_PART &&
	    (part >= sc->sc_dk.dk_label->d_npartitions ||
	     sc->sc_dk.dk_label->d_partitions[part].p_fstype == FS_UNUSED)) {
		error = ENXIO;
		goto bad;
	}

	/* Insure only one open at a time. */
	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask |= (1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask |= (1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;

	disk_unlock(&sc->sc_dk);
	return 0;

bad2:
	sc->flags &= ~MCDF_LOADED;

bad:
	if (sc->sc_dk.dk_openmask == 0) {
#if 0
		(void) mcd_setmode(sc, MCD_MD_SLEEP);
#endif
		(void) mcd_setlock(sc, MCD_LK_UNLOCK);
	}

bad3:
	disk_unlock(&sc->sc_dk);
	return error;
}

int
mcdclose(dev, flag, fmt, p)
	dev_t dev;
	int flag, fmt;
	struct proc *p;
{
	struct mcd_softc *sc = mcd_cd.cd_devs[DISKUNIT(dev)];
	int part = DISKPART(dev);
	
	MCD_TRACE("close: partition=%d\n", part, 0, 0, 0);

	disk_lock_nointr(&sc->sc_dk);

	switch (fmt) {
	case S_IFCHR:
		sc->sc_dk.dk_copenmask &= ~(1 << part);
		break;
	case S_IFBLK:
		sc->sc_dk.dk_bopenmask &= ~(1 << part);
		break;
	}
	sc->sc_dk.dk_openmask = sc->sc_dk.dk_copenmask | sc->sc_dk.dk_bopenmask;

	if (sc->sc_dk.dk_openmask == 0) {
		/* XXXX Must wait for I/O to complete! */

#if 0
		(void) mcd_setmode(sc, MCD_MD_SLEEP);
#endif
		(void) mcd_setlock(sc, MCD_LK_UNLOCK);
		if (sc->flags & MCDF_EJECTING) {
			mcd_eject(sc);
			sc->flags &= ~MCDF_EJECTING;
		}
	}
	disk_unlock(&sc->sc_dk);
	return 0;
}

void
mcdstrategy(bp)
	struct buf *bp;
{
	struct mcd_softc *sc = mcd_cd.cd_devs[DISKUNIT(bp->b_dev)];
	int s;
	
	/* Test validity. */
	MCD_TRACE("strategy: buf=0x%lx blkno=%lld bcount=%ld\n", bp,
	    bp->b_blkno, bp->b_bcount, 0);
	if (bp->b_blkno < 0 ||
	    (bp->b_bcount % sc->blksize) != 0) {
		printf("%s: strategy: blkno = %lld bcount = %ld\n",
		    sc->sc_dev.dv_xname, bp->b_blkno, bp->b_bcount);
		bp->b_error = EINVAL;
		goto bad;
	}

	/* If device invalidated (e.g. media change, door open), error. */
	if ((sc->flags & MCDF_LOADED) == 0) {
		MCD_TRACE("strategy: drive not valid\n", 0, 0, 0, 0);
		bp->b_error = EIO;
		goto bad;
	}

	/* No data to read. */
	if (bp->b_bcount == 0)
		goto done;
	
	/*
	 * Do bounds checking, adjust transfer. if error, process.
	 * If end of partition, just return.
	 */
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label) <= 0)
		goto done;
	
	/* Queue it. */
	s = splbio();
	disksort(&sc->buf_queue, bp);
	splx(s);
	if (!sc->buf_queue.b_active)
		mcdstart(sc);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	bp->b_resid = bp->b_bcount;
	s = splbio();
	biodone(bp);
	splx(s);
}

void
mcdstart(sc)
	struct mcd_softc *sc;
{
	struct buf *bp, *dp = &sc->buf_queue;
	int s;
	
loop:
	s = splbio();

	bp = dp->b_actf;
	if (bp == NULL) {
		/* Nothing to do. */
		dp->b_active = 0;
		splx(s);
		return;
	}

	/* Block found to process; dequeue. */
	MCD_TRACE("start: found block bp=0x%x\n", bp, 0, 0, 0);
	dp->b_actf = bp->b_actf;
	splx(s);

	/* Changed media? */
	if ((sc->flags & MCDF_LOADED) == 0) {
		MCD_TRACE("start: drive not valid\n", 0, 0, 0, 0);
		bp->b_error = EIO;
		bp->b_flags |= B_ERROR;
		s = splbio();
		biodone(bp);
		splx(s);
		goto loop;
	}

	dp->b_active = 1;

	/* Instrumentation. */
	s = splbio();
	disk_busy(&sc->sc_dk);
	splx(s);

	sc->mbx.retry = MCD_RDRETRIES;
	sc->mbx.bp = bp;
	sc->mbx.blkno = bp->b_blkno / (sc->blksize / DEV_BSIZE);
	if (DISKPART(bp->b_dev) != RAW_PART) {
		struct partition *p;
		p = &sc->sc_dk.dk_label->d_partitions[DISKPART(bp->b_dev)];
		sc->mbx.blkno += DL_GETPOFFSET(p);
	}
	sc->mbx.nblk = bp->b_bcount / sc->blksize;
	sc->mbx.sz = sc->blksize;
	sc->mbx.skip = 0;
	sc->mbx.state = MCD_S_BEGIN;
	sc->mbx.mode = MCD_MD_COOKED;

	s = splbio();
	(void) mcdintr(sc);
	splx(s);
}

int
mcdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(mcdstrategy, dev, B_READ, minphys, uio));
}

int
mcdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
{

	return (physio(mcdstrategy, dev, B_WRITE, minphys, uio));
}

int
mcdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
{
	struct mcd_softc *sc = mcd_cd.cd_devs[DISKUNIT(dev)];
	struct disklabel *lp;
	int error;
	
	MCD_TRACE("ioctl: cmd=0x%x\n", cmd, 0, 0, 0);

	if ((sc->flags & MCDF_LOADED) == 0)
		return EIO;

	switch (cmd) {
	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		mcdgetdisklabel(dev, sc, lp, 0);
		bcopy(lp, sc->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP);
		return 0;

	case DIOCGDINFO:
	case DIOCGPDINFO:
		*(struct disklabel *)addr = *(sc->sc_dk.dk_label);
		return 0;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = sc->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &sc->sc_dk.dk_label->d_partitions[DISKPART(dev)];
		return 0;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		if ((error = disk_lock(&sc->sc_dk)) != 0)
			return error;

		error = setdisklabel(sc->sc_dk.dk_label,
		    (struct disklabel *)addr, /*sc->sc_dk.dk_openmask : */0);
		if (error == 0) {
		}

		disk_unlock(&sc->sc_dk);
		return error;

	case CDIOCPLAYTRACKS:
		return mcd_playtracks(sc, (struct ioc_play_track *)addr);
	case CDIOCPLAYMSF:
		return mcd_playmsf(sc, (struct ioc_play_msf *)addr);
	case CDIOCPLAYBLOCKS:
		return mcd_playblocks(sc, (struct ioc_play_blocks *)addr);
	case CDIOCREADSUBCHANNEL:
		return mcd_read_subchannel(sc, (struct ioc_read_subchannel *)addr);
	case CDIOREADTOCHEADER:
		return mcd_toc_header(sc, (struct ioc_toc_header *)addr);
	case CDIOREADTOCENTRYS:
		return mcd_toc_entries(sc, (struct ioc_read_toc_entry *)addr);
	case CDIOCSETPATCH:
	case CDIOCGETVOL:
	case CDIOCSETVOL:
	case CDIOCSETMONO:
	case CDIOCSETSTEREO:
	case CDIOCSETMUTE:
	case CDIOCSETLEFT:
	case CDIOCSETRIGHT:
		return EINVAL;
	case CDIOCRESUME:
		return mcd_resume(sc);
	case CDIOCPAUSE:
		return mcd_pause(sc);
	case CDIOCSTART:
		return EINVAL;
	case CDIOCSTOP:
		return mcd_stop(sc);
	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
		/* FALLTHROUGH */
	case CDIOCEJECT: /* FALLTHROUGH */
	case DIOCEJECT:
		sc->flags |= MCDF_EJECTING;
		return (0);
	case CDIOCALLOW:
		return mcd_setlock(sc, MCD_LK_UNLOCK);
	case CDIOCPREVENT:
		return mcd_setlock(sc, MCD_LK_LOCK);
	case DIOCLOCK:
		return mcd_setlock(sc,
		    (*(int *)addr) ? MCD_LK_LOCK : MCD_LK_UNLOCK);
	case CDIOCSETDEBUG:
		sc->debug = 1;
		return 0;
	case CDIOCCLRDEBUG:
		sc->debug = 0;
		return 0;
	case CDIOCRESET:
		return mcd_hard_reset(sc);

	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("mcdioctl: impossible");
#endif
}

int
mcdgetdisklabel(dev, sc, lp, spoofonly)
	dev_t dev;
	struct mcd_softc *sc;
	struct disklabel *lp;
	int spoofonly;
{
	bzero(lp, sizeof(struct disklabel));

	lp->d_secsize = sc->blksize;
	lp->d_ntracks = 1;
	lp->d_nsectors = 100;
	lp->d_ncylinders = (sc->disksize / 100) + 1;
	lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
	if (lp->d_secpercyl == 0) {
		lp->d_secpercyl = 100;
		/* as long as it's not 0 - readdisklabel divides by it */
	}

	strncpy(lp->d_typename, "Mitsumi CD-ROM", sizeof lp->d_typename);
	lp->d_type = DTYPE_SCSI;	/* XXX */
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
	DL_SETDSIZE(lp, sc->disksize);
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Call the generic disklabel extraction routine
	 */
	return (readdisklabel(DISKLABELDEV(dev), mcdstrategy, lp, spoofonly));
}

int
mcd_get_parms(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;
	daddr64_t size;
	int error;

	/* Send volume info command. */
	mbx.cmd.opcode = MCD_CMDGETVOLINFO;
	mbx.cmd.length = 0;
	mbx.res.length = sizeof(mbx.res.data.volinfo);
	if ((error = mcd_send(sc, &mbx, 1)) != 0)
		return error;

	if (mbx.res.data.volinfo.trk_low == 0x00 &&
	    mbx.res.data.volinfo.trk_high == 0x00)
		return EINVAL;

	/* Volinfo is OK. */
	sc->volinfo = mbx.res.data.volinfo;
	sc->blksize = MCD_BLKSIZE_COOKED;
	size = msf2hsg(sc->volinfo.vol_msf, 0);
	sc->disksize = size * (MCD_BLKSIZE_COOKED / DEV_BSIZE);
	return 0;
}

daddr64_t
mcdsize(dev)
	dev_t dev;
{

	/* CD-ROMs are read-only. */
	return -1;
}

int
mcddump(dev, blkno, va, size)
	dev_t dev;
	daddr64_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
}

/*
 * Find the board and fill in the softc.
 */
int
mcd_find(iot, ioh, sc)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct mcd_softc *sc;
{
	int i;
	struct mcd_mbox mbx;

        sc->sc_iot = iot;
	sc->sc_ioh = ioh;

	/* Send a reset. */
	bus_space_write_1(iot, ioh, MCD_RESET, 0);
	delay(1000000);
	/* Get any pending status and throw away. */
	for (i = 10; i; i--)
		bus_space_read_1(iot, ioh, MCD_STATUS);
	delay(1000);

	/* Send get status command. */
	mbx.cmd.opcode = MCD_CMDGETSTAT;
	mbx.cmd.length = 0;
	mbx.res.length = 0;
	if (mcd_send(sc, &mbx, 0) != 0)
		return 0;

	/* Get info about the drive. */
	mbx.cmd.opcode = MCD_CMDCONTINFO;
	mbx.cmd.length = 0;
	mbx.res.length = sizeof(mbx.res.data.continfo);
	if (mcd_send(sc, &mbx, 0) != 0)
		return 0;

	/*
	 * The following is code which is not guaranteed to work for all
	 * drives, because the meaning of the expected 'M' is not clear
	 * (M_itsumi is an obvious assumption, but I don't trust that).
	 * Also, the original hack had a bogus condition that always
	 * returned true.
	 *
	 * Note:  Which models support interrupts?  >=LU005S?
	 */
	sc->readcmd = MCD_CMDREADSINGLESPEED;
	switch (mbx.res.data.continfo.code) {
	case 'M':
		if (mbx.res.data.continfo.version <= 2)
			sc->type = "LU002S";
		else if (mbx.res.data.continfo.version <= 5)
			sc->type = "LU005S";
		else
			sc->type = "LU006S";
		break;
	case 'F':
		sc->type = "FX001";
		break;
	case 'D':
		sc->type = "FX001D";
		sc->readcmd = MCD_CMDREADDOUBLESPEED;
		break;
	default:
#ifdef MCDDEBUG
		printf("%s: unrecognized drive version %c%02x; will try to use it anyway\n",
		    sc->sc_dev.dv_xname,
		    mbx.res.data.continfo.code, mbx.res.data.continfo.version);
#endif
		sc->type = 0;
		break;
	}

	return 1;

}

int
mcdprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct isa_attach_args *ia = aux;
	struct mcd_softc sc;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;

	/* Disallow wildcarded i/o address. */
	if (ia->ia_iobase == -1 /*ISACF_PORT_DEFAULT*/)
		return (0);

	/* Map i/o space */
	if (bus_space_map(iot, ia->ia_iobase, MCD_NPORT, 0, &ioh))
		return 0;

	if (!opti_cd_setup(OPTI_MITSUMI, ia->ia_iobase, ia->ia_irq, ia->ia_drq))
		/* printf("mcdprobe: could not setup OPTi chipset.\n") */;

	bzero(&sc, sizeof sc);
	sc.debug = 0;
	sc.probe = 1;

	rv = mcd_find(iot, ioh, &sc);

	bus_space_unmap(iot, ioh, MCD_NPORT);

	if (rv)	{
		ia->ia_iosize = MCD_NPORT;
		ia->ia_msize = 0;
	}

	return (rv);
}

int
mcd_getreply(sc)
	struct mcd_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	/* Wait until xfer port senses data ready. */
	for (i = DELAY_GETREPLY; i; i--) {
		if ((bus_space_read_1(iot, ioh, MCD_XFER) &
		    MCD_XF_STATUSUNAVAIL) == 0)
			break;
		delay(DELAY_GRANULARITY);
	}
	if (!i)
		return -1;

	/* Get the data. */
	return bus_space_read_1(iot, ioh, MCD_STATUS);
}

int
mcd_getstat(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;

	mbx.cmd.opcode = MCD_CMDGETSTAT;
	mbx.cmd.length = 0;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}

int
mcd_getresult(sc, res)
	struct mcd_softc *sc;
	struct mcd_result *res;
{
	int i, x;

	if (sc->debug)
		printf("%s: mcd_getresult: %d", sc->sc_dev.dv_xname,
		    res->length);

	if ((x = mcd_getreply(sc)) < 0) {
		if (sc->debug)
			printf(" timeout\n");
		else if (sc->probe == 0)
			printf("%s: timeout in getresult\n", sc->sc_dev.dv_xname);
		return EIO;
	}
	if (sc->debug)
		printf(" %02x", (u_int)x);
	sc->status = x;
	mcd_setflags(sc);

	if ((sc->status & MCD_ST_CMDCHECK) != 0)
		return EINVAL;

	for (i = 0; i < res->length; i++) {
		if ((x = mcd_getreply(sc)) < 0) {
			if (sc->debug)
				printf(" timeout\n");
			else
				printf("%s: timeout in getresult\n", sc->sc_dev.dv_xname);
			return EIO;
		}
		if (sc->debug)
			printf(" %02x", (u_int)x);
		res->data.raw.data[i] = x;
	}

	if (sc->debug)
		printf(" succeeded\n");

#ifdef MCDDEBUG
	delay(10);
	while ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_XFER) &
	    MCD_XF_STATUSUNAVAIL) == 0) {
		x = bus_space_read_1(sc->sc_iot, sc->sc_ioh, MCD_STATUS);
		printf("%s: got extra byte %02x during getstatus\n",
		    sc->sc_dev.dv_xname, (u_int)x);
		delay(10);
	}
#endif

	return 0;
}

void
mcd_setflags(sc)
	struct mcd_softc *sc;
{

	/* Check flags. */
	if ((sc->flags & MCDF_LOADED) != 0 &&
	    (sc->status & (MCD_ST_DSKCHNG | MCD_ST_DSKIN | MCD_ST_DOOROPEN)) !=
	    MCD_ST_DSKIN) {
		if ((sc->status & MCD_ST_DOOROPEN) != 0)
			printf("%s: door open\n", sc->sc_dev.dv_xname);
		else if ((sc->status & MCD_ST_DSKIN) == 0)
			printf("%s: no disk present\n", sc->sc_dev.dv_xname);
		else if ((sc->status & MCD_ST_DSKCHNG) != 0)
			printf("%s: media change\n", sc->sc_dev.dv_xname);
		sc->flags &= ~MCDF_LOADED;
	}

	if ((sc->status & MCD_ST_AUDIOBSY) != 0)
		sc->audio_status = CD_AS_PLAY_IN_PROGRESS;
	else if (sc->audio_status == CD_AS_PLAY_IN_PROGRESS ||
		 sc->audio_status == CD_AS_AUDIO_INVALID)
		sc->audio_status = CD_AS_PLAY_COMPLETED;
}

int
mcd_send(sc, mbx, diskin)
	struct mcd_softc *sc;
	struct mcd_mbox *mbx;
	int diskin;
{
	int retry, i, error;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	
	if (sc->debug) {
		printf("%s: mcd_send: %d %02x", sc->sc_dev.dv_xname,
		    mbx->cmd.length, (u_int)mbx->cmd.opcode);
		for (i = 0; i < mbx->cmd.length; i++)
			printf(" %02x", (u_int)mbx->cmd.data.raw.data[i]);
		printf("\n");
	}

	for (retry = MCD_RETRIES; retry; retry--) {
		bus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.opcode);
		for (i = 0; i < mbx->cmd.length; i++)
			bus_space_write_1(iot, ioh, MCD_COMMAND, mbx->cmd.data.raw.data[i]);
		if ((error = mcd_getresult(sc, &mbx->res)) == 0)
			break;
		if (error == EINVAL)
			return error;
	}
	if (!retry)
		return error;
	if (diskin && (sc->flags & MCDF_LOADED) == 0)
		return EIO;

	return 0;
}

static void
hsg2msf(hsg, msf)
	int hsg;
	bcd_t *msf;
{

	hsg += 150;
	F_msf(msf) = bin2bcd(hsg % 75);
	hsg /= 75;
	S_msf(msf) = bin2bcd(hsg % 60);
	hsg /= 60;
	M_msf(msf) = bin2bcd(hsg);
}

static daddr64_t
msf2hsg(msf, relative)
	bcd_t *msf;
	int relative;
{
	daddr64_t blkno;

	blkno = bcd2bin(M_msf(msf)) * 75 * 60 +
		bcd2bin(S_msf(msf)) * 75 +
		bcd2bin(F_msf(msf));
	if (!relative)
		blkno -= 150;
	return blkno;
}

void
mcd_pseudointr(v)
	void *v;
{
	struct mcd_softc *sc = v;
	int s;

	s = splbio();
	(void) mcdintr(sc);
	splx(s);
}

/*
 * State machine to process read requests.
 * Initialize with MCD_S_BEGIN: calculate sizes, and set mode
 * MCD_S_WAITMODE: waits for status reply from set mode, set read command
 * MCD_S_WAITREAD: wait for read ready, read data.
 */
int
mcdintr(arg)
	void *arg;
{
	struct mcd_softc *sc = arg;
	struct mcd_mbx *mbx = &sc->mbx;
	struct buf *bp = mbx->bp;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	int i;
	u_char x;
	bcd_t msf[3];

	switch (mbx->state) {
	case MCD_S_IDLE:
		return 0;

	case MCD_S_BEGIN:
	tryagain:
		if (mbx->mode == sc->lastmode)
			goto firstblock;

		sc->lastmode = MCD_MD_UNKNOWN;
		bus_space_write_1(iot, ioh, MCD_COMMAND, MCD_CMDSETMODE);
		bus_space_write_1(iot, ioh, MCD_COMMAND, mbx->mode);

		mbx->count = RDELAY_WAITMODE;
		mbx->state = MCD_S_WAITMODE;

	case MCD_S_WAITMODE:
		timeout_del(&sc->sc_pi_tmo);
		for (i = 20; i; i--) {
			x = bus_space_read_1(iot, ioh, MCD_XFER);
			if ((x & MCD_XF_STATUSUNAVAIL) == 0)
				break;
			delay(50);
		}
		if (i == 0)
			goto hold;
		sc->status = bus_space_read_1(iot, ioh, MCD_STATUS);
		mcd_setflags(sc);
		if ((sc->flags & MCDF_LOADED) == 0)
			goto changed;
		MCD_TRACE("doread: got WAITMODE delay=%d\n",
		    RDELAY_WAITMODE - mbx->count, 0, 0, 0);

		sc->lastmode = mbx->mode;

	firstblock:
		MCD_TRACE("doread: read blkno=%lld for bp=0x%x\n", mbx->blkno,
		    bp, 0, 0);

		/* Build parameter block. */
		hsg2msf(mbx->blkno, msf);

		/* Send the read command. */
		bus_space_write_1(iot, ioh, MCD_COMMAND, sc->readcmd);
		bus_space_write_1(iot, ioh, MCD_COMMAND, msf[0]);
		bus_space_write_1(iot, ioh, MCD_COMMAND, msf[1]);
		bus_space_write_1(iot, ioh, MCD_COMMAND, msf[2]);
		bus_space_write_1(iot, ioh, MCD_COMMAND, 0);
		bus_space_write_1(iot, ioh, MCD_COMMAND, 0);
		bus_space_write_1(iot, ioh, MCD_COMMAND, mbx->nblk);

		mbx->count = RDELAY_WAITREAD;
		mbx->state = MCD_S_WAITREAD;

	case MCD_S_WAITREAD:
		timeout_del(&sc->sc_pi_tmo);
	nextblock:
	loop:
		for (i = 20; i; i--) {
			x = bus_space_read_1(iot, ioh, MCD_XFER);
			if ((x & MCD_XF_DATAUNAVAIL) == 0)
				goto gotblock;
			if ((x & MCD_XF_STATUSUNAVAIL) == 0)
				break;
			delay(50);
		}
		if (i == 0)
			goto hold;
		sc->status = bus_space_read_1(iot, ioh, MCD_STATUS);
		mcd_setflags(sc);
		if ((sc->flags & MCDF_LOADED) == 0)
			goto changed;
#if 0
		printf("%s: got status byte %02x during read\n",
		    sc->sc_dev.dv_xname, (u_int)sc->status);
#endif
		goto loop;

	gotblock:
		MCD_TRACE("doread: got data delay=%d\n",
		    RDELAY_WAITREAD - mbx->count, 0, 0, 0);

		/* Data is ready. */
		bus_space_write_1(iot, ioh, MCD_CTL2, 0x04);	/* XXX */
		bus_space_read_multi_1(iot, ioh, MCD_RDATA,
		    bp->b_data + mbx->skip, mbx->sz);
		bus_space_write_1(iot, ioh, MCD_CTL2, 0x0c);	/* XXX */
		mbx->blkno += 1;
		mbx->skip += mbx->sz;
		if (--mbx->nblk > 0)
			goto nextblock;

		mbx->state = MCD_S_IDLE;

		/* Return buffer. */
		bp->b_resid = 0;
		disk_unbusy(&sc->sc_dk, bp->b_bcount, (bp->b_flags & B_READ));
		biodone(bp);

		mcdstart(sc);
		return 1;

	hold:
		if (mbx->count-- < 0) {
			printf("%s: timeout in state %d",
			    sc->sc_dev.dv_xname, mbx->state);
			goto readerr;
		}

#if 0
		printf("%s: sleep in state %d\n", sc->sc_dev.dv_xname,
		    mbx->state);
#endif
		timeout_add(&sc->sc_pi_tmo, hz / 100);
		return -1;
	}

readerr:
	if (mbx->retry-- > 0) {
		printf("; retrying\n");
		goto tryagain;
	} else
		printf("; giving up\n");

changed:
	/* Invalidate the buffer. */
	bp->b_flags |= B_ERROR;
	bp->b_resid = bp->b_bcount - mbx->skip;
	disk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
	biodone(bp);

	mcdstart(sc);
	return -1;

#ifdef notyet
	printf("%s: unit timeout; resetting\n", sc->sc_dev.dv_xname);
	bus_space_write_1(iot, ioh, MCD_RESET, MCD_CMDRESET);
	delay(300000);
	(void) mcd_getstat(sc, 1);
	(void) mcd_getstat(sc, 1);
	/*sc->status &= ~MCD_ST_DSKCHNG; */
	sc->debug = 1; /* preventive set debug mode */
#endif
}

void
mcd_soft_reset(sc)
	struct mcd_softc *sc;
{

	sc->debug = 0;
	sc->flags = 0;
	sc->lastmode = MCD_MD_UNKNOWN;
	sc->lastupc = MCD_UPC_UNKNOWN;
	sc->audio_status = CD_AS_AUDIO_INVALID;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, MCD_CTL2, 0x0c); /* XXX */
}

int
mcd_hard_reset(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;

	mcd_soft_reset(sc);

	mbx.cmd.opcode = MCD_CMDRESET;
	mbx.cmd.length = 0;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 0);
}
	
int
mcd_setmode(sc, mode)
	struct mcd_softc *sc;
	int mode;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->lastmode == mode)
		return 0;
	if (sc->debug)
		printf("%s: setting mode to %d\n", sc->sc_dev.dv_xname, mode);
	sc->lastmode = MCD_MD_UNKNOWN;

	mbx.cmd.opcode = MCD_CMDSETMODE;
	mbx.cmd.length = sizeof(mbx.cmd.data.datamode);
	mbx.cmd.data.datamode.mode = mode;
	mbx.res.length = 0;
	if ((error = mcd_send(sc, &mbx, 1)) != 0)
		return error;

	sc->lastmode = mode;
	return 0;
}

int
mcd_setupc(sc, upc)
	struct mcd_softc *sc;
	int upc;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->lastupc == upc)
		return 0;
	if (sc->debug)
		printf("%s: setting upc to %d\n", sc->sc_dev.dv_xname, upc);
	sc->lastupc = MCD_UPC_UNKNOWN;

	mbx.cmd.opcode = MCD_CMDCONFIGDRIVE;
	mbx.cmd.length = sizeof(mbx.cmd.data.config) - 1;
	mbx.cmd.data.config.subcommand = MCD_CF_READUPC;
	mbx.cmd.data.config.data1 = upc;
	mbx.res.length = 0;
	if ((error = mcd_send(sc, &mbx, 1)) != 0)
		return error;

	sc->lastupc = upc;
	return 0;
}

int
mcd_toc_header(sc, th)
	struct mcd_softc *sc;
	struct ioc_toc_header *th;
{

	if (sc->debug)
		printf("%s: mcd_toc_header: reading toc header\n",
		    sc->sc_dev.dv_xname);

	th->len = msf2hsg(sc->volinfo.vol_msf, 0);
	th->starting_track = bcd2bin(sc->volinfo.trk_low);
	th->ending_track = bcd2bin(sc->volinfo.trk_high);

	return 0;
}

int
mcd_read_toc(sc)
	struct mcd_softc *sc;
{
	struct ioc_toc_header th;
	union mcd_qchninfo q;
	int error, trk, idx, retry;

	if ((error = mcd_toc_header(sc, &th)) != 0)
		return error;

	if ((error = mcd_stop(sc)) != 0)
		return error;

	if (sc->debug)
		printf("%s: read_toc: reading qchannel info\n",
		    sc->sc_dev.dv_xname);

	for (trk = th.starting_track; trk <= th.ending_track; trk++)
		sc->toc[trk].toc.idx_no = 0x00;
	trk = th.ending_track - th.starting_track + 1;
	for (retry = 300; retry && trk > 0; retry--) {
		if (mcd_getqchan(sc, &q, CD_TRACK_INFO) != 0)
			break;
		if (q.toc.trk_no != 0x00 || q.toc.idx_no == 0x00)
			continue;
		idx = bcd2bin(q.toc.idx_no);
		if (idx < MCD_MAXTOCS &&
		    sc->toc[idx].toc.idx_no == 0x00) {
			sc->toc[idx] = q;
			trk--;
		}
	}

	/* Inform the drive that we're finished so it turns off the light. */
	if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
		return error;

	if (trk != 0)
		return EINVAL;

	/* Add a fake last+1 for mcd_playtracks(). */
	idx = th.ending_track + 1;
	sc->toc[idx].toc.control = sc->toc[idx-1].toc.control;
	sc->toc[idx].toc.addr_type = sc->toc[idx-1].toc.addr_type;
	sc->toc[idx].toc.trk_no = 0x00;
	sc->toc[idx].toc.idx_no = 0xaa;
	sc->toc[idx].toc.absolute_pos[0] = sc->volinfo.vol_msf[0];
	sc->toc[idx].toc.absolute_pos[1] = sc->volinfo.vol_msf[1];
	sc->toc[idx].toc.absolute_pos[2] = sc->volinfo.vol_msf[2];

	return 0;
}

int
mcd_toc_entries(sc, te)
	struct mcd_softc *sc;
	struct ioc_read_toc_entry *te;
{
	int len = te->data_len;
	struct ret_toc {
		struct ioc_toc_header header;
		struct cd_toc_entry entries[MCD_MAXTOCS];
	} data;
	u_char trk;
	daddr64_t lba;
	int error, n;

	if (len > sizeof(data.entries) ||
	    len < sizeof(struct cd_toc_entry))
		return EINVAL;
	if (te->address_format != CD_MSF_FORMAT &&
	    te->address_format != CD_LBA_FORMAT)
		return EINVAL;

	/* Copy the TOC header. */
	if ((error = mcd_toc_header(sc, &data.header)) != 0)
		return error;

	/* Verify starting track. */
	trk = te->starting_track;
	if (trk == 0x00)
		trk = data.header.starting_track;
	else if (trk == 0xaa)
		trk = data.header.ending_track + 1;
	else if (trk < data.header.starting_track ||
		 trk > data.header.ending_track + 1)
		return EINVAL;

	/* Copy the TOC data. */
	for (n = 0; trk <= data.header.ending_track + 1; trk++) {
		if (sc->toc[trk].toc.idx_no == 0x00)
			continue;
		data.entries[n].control = sc->toc[trk].toc.control;
		data.entries[n].addr_type = sc->toc[trk].toc.addr_type;
		data.entries[n].track = bcd2bin(sc->toc[trk].toc.idx_no);
		switch (te->address_format) {
		case CD_MSF_FORMAT:
			data.entries[n].addr.addr[0] = 0;
			data.entries[n].addr.addr[1] =
			    bcd2bin(sc->toc[trk].toc.absolute_pos[0]);
			data.entries[n].addr.addr[2] =
			    bcd2bin(sc->toc[trk].toc.absolute_pos[1]);
			data.entries[n].addr.addr[3] =
			    bcd2bin(sc->toc[trk].toc.absolute_pos[2]);
			break;
		case CD_LBA_FORMAT:
			lba = msf2hsg(sc->toc[trk].toc.absolute_pos, 0);
			data.entries[n].addr.addr[0] = lba >> 24;
			data.entries[n].addr.addr[1] = lba >> 16;
			data.entries[n].addr.addr[2] = lba >> 8;
			data.entries[n].addr.addr[3] = lba;
			break;
		}
		n++;
	}

	len = min(len, n * sizeof(struct cd_toc_entry));

	/* Copy the data back. */
	return copyout(&data.entries[0], te->data, len);
}

int
mcd_stop(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->debug)
		printf("%s: mcd_stop: stopping play\n", sc->sc_dev.dv_xname);

	mbx.cmd.opcode = MCD_CMDSTOPAUDIO;
	mbx.cmd.length = 0;
	mbx.res.length = 0;
	if ((error = mcd_send(sc, &mbx, 1)) != 0)
		return error;

	sc->audio_status = CD_AS_PLAY_COMPLETED;
	return 0;
}

int
mcd_getqchan(sc, q, qchn)
	struct mcd_softc *sc;
	union mcd_qchninfo *q;
	int qchn;
{
	struct mcd_mbox mbx;
	int error;

	if (qchn == CD_TRACK_INFO) {
		if ((error = mcd_setmode(sc, MCD_MD_TOC)) != 0)
			return error;
	} else {
		if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
			return error;
	}
	if (qchn == CD_MEDIA_CATALOG) {
		if ((error = mcd_setupc(sc, MCD_UPC_ENABLE)) != 0)
			return error;
	} else {
		if ((error = mcd_setupc(sc, MCD_UPC_DISABLE)) != 0)
			return error;
	}

	mbx.cmd.opcode = MCD_CMDGETQCHN;
	mbx.cmd.length = 0;
	mbx.res.length = sizeof(mbx.res.data.qchninfo);
	if ((error = mcd_send(sc, &mbx, 1)) != 0)
		return error;

	*q = mbx.res.data.qchninfo;
	return 0;
}

int
mcd_read_subchannel(sc, ch)
	struct mcd_softc *sc;
	struct ioc_read_subchannel *ch;
{
	int len = ch->data_len;
	union mcd_qchninfo q;
	struct cd_sub_channel_info data;
	daddr64_t lba;
	int error;

	if (sc->debug)
		printf("%s: subchan: af=%d df=%d\n", sc->sc_dev.dv_xname,
		    ch->address_format, ch->data_format);

	if (len > sizeof(data) ||
	    len < sizeof(struct cd_sub_channel_header))
		return EINVAL;
	if (ch->address_format != CD_MSF_FORMAT &&
	    ch->address_format != CD_LBA_FORMAT)
		return EINVAL;
	if (ch->data_format != CD_CURRENT_POSITION &&
	    ch->data_format != CD_MEDIA_CATALOG)
		return EINVAL;

	if ((error = mcd_getqchan(sc, &q, ch->data_format)) != 0)
		return error;

	data.header.audio_status = sc->audio_status;
	data.what.media_catalog.data_format = ch->data_format;

	switch (ch->data_format) {
	case CD_MEDIA_CATALOG:
		data.what.media_catalog.mc_valid = 1;
#if 0
		data.what.media_catalog.mc_number = 
#endif
		break;

	case CD_CURRENT_POSITION:
		data.what.position.track_number = bcd2bin(q.current.trk_no);
		data.what.position.index_number = bcd2bin(q.current.idx_no);
		switch (ch->address_format) {
		case CD_MSF_FORMAT:
			data.what.position.reladdr.addr[0] = 0;
			data.what.position.reladdr.addr[1] =
			    bcd2bin(q.current.relative_pos[0]);
			data.what.position.reladdr.addr[2] =
			    bcd2bin(q.current.relative_pos[1]);
			data.what.position.reladdr.addr[3] =
			    bcd2bin(q.current.relative_pos[2]);
			data.what.position.absaddr.addr[0] = 0;
			data.what.position.absaddr.addr[1] =
			    bcd2bin(q.current.absolute_pos[0]);
			data.what.position.absaddr.addr[2] =
			    bcd2bin(q.current.absolute_pos[1]);
			data.what.position.absaddr.addr[3] =
			    bcd2bin(q.current.absolute_pos[2]);
			break;
		case CD_LBA_FORMAT:
			lba = msf2hsg(q.current.relative_pos, 1);
			/*
			 * Pre-gap has index number of 0, and decreasing MSF
			 * address.  Must be converted to negative LBA, per
			 * SCSI spec.
			 */
			if (data.what.position.index_number == 0x00)
				lba = -lba;
			data.what.position.reladdr.addr[0] = lba >> 24;
			data.what.position.reladdr.addr[1] = lba >> 16;
			data.what.position.reladdr.addr[2] = lba >> 8;
			data.what.position.reladdr.addr[3] = lba;
			lba = msf2hsg(q.current.absolute_pos, 0);
			data.what.position.absaddr.addr[0] = lba >> 24;
			data.what.position.absaddr.addr[1] = lba >> 16;
			data.what.position.absaddr.addr[2] = lba >> 8;
			data.what.position.absaddr.addr[3] = lba;
			break;
		}
		break;
	}

	return copyout(&data, ch->data, len);
}

int
mcd_playtracks(sc, p)
	struct mcd_softc *sc;
	struct ioc_play_track *p;
{
	struct mcd_mbox mbx;
	int a = p->start_track;
	int z = p->end_track;
	int error;

	if (sc->debug)
		printf("%s: playtracks: from %d:%d to %d:%d\n",
		    sc->sc_dev.dv_xname,
		    a, p->start_index, z, p->end_index);

	if (a < bcd2bin(sc->volinfo.trk_low) ||
	    a > bcd2bin(sc->volinfo.trk_high) ||
	    a > z ||
	    z < bcd2bin(sc->volinfo.trk_low) ||
	    z > bcd2bin(sc->volinfo.trk_high))
		return EINVAL;

	if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
		return error;

	mbx.cmd.opcode = MCD_CMDREADSINGLESPEED;
	mbx.cmd.length = sizeof(mbx.cmd.data.play);
	mbx.cmd.data.play.start_msf[0] = sc->toc[a].toc.absolute_pos[0];
	mbx.cmd.data.play.start_msf[1] = sc->toc[a].toc.absolute_pos[1];
	mbx.cmd.data.play.start_msf[2] = sc->toc[a].toc.absolute_pos[2];
	mbx.cmd.data.play.end_msf[0] = sc->toc[z+1].toc.absolute_pos[0];
	mbx.cmd.data.play.end_msf[1] = sc->toc[z+1].toc.absolute_pos[1];
	mbx.cmd.data.play.end_msf[2] = sc->toc[z+1].toc.absolute_pos[2];
	sc->lastpb = mbx.cmd;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}

int
mcd_playmsf(sc, p)
	struct mcd_softc *sc;
	struct ioc_play_msf *p;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->debug)
		printf("%s: playmsf: from %d:%d.%d to %d:%d.%d\n",
		    sc->sc_dev.dv_xname,
		    p->start_m, p->start_s, p->start_f,
		    p->end_m, p->end_s, p->end_f);

	if ((p->start_m * 60 * 75 + p->start_s * 75 + p->start_f) >=
	    (p->end_m * 60 * 75 + p->end_s * 75 + p->end_f))
		return EINVAL;

	if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
		return error;

	mbx.cmd.opcode = MCD_CMDREADSINGLESPEED;
	mbx.cmd.length = sizeof(mbx.cmd.data.play);
	mbx.cmd.data.play.start_msf[0] = bin2bcd(p->start_m);
	mbx.cmd.data.play.start_msf[1] = bin2bcd(p->start_s);
	mbx.cmd.data.play.start_msf[2] = bin2bcd(p->start_f);
	mbx.cmd.data.play.end_msf[0] = bin2bcd(p->end_m);
	mbx.cmd.data.play.end_msf[1] = bin2bcd(p->end_s);
	mbx.cmd.data.play.end_msf[2] = bin2bcd(p->end_f);
	sc->lastpb = mbx.cmd;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}

int
mcd_playblocks(sc, p)
	struct mcd_softc *sc;
	struct ioc_play_blocks *p;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->debug)
		printf("%s: playblocks: blkno %lld length %d\n",
		    sc->sc_dev.dv_xname, p->blk, p->len);

	if (p->blk > sc->disksize || p->len > sc->disksize ||
	    (p->blk + p->len) > sc->disksize)
		return 0;

	if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
		return error;

	mbx.cmd.opcode = MCD_CMDREADSINGLESPEED;
	mbx.cmd.length = sizeof(mbx.cmd.data.play);
	hsg2msf(p->blk, mbx.cmd.data.play.start_msf);
	hsg2msf(p->blk + p->len, mbx.cmd.data.play.end_msf);
	sc->lastpb = mbx.cmd;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}

int
mcd_pause(sc)
	struct mcd_softc *sc;
{
	union mcd_qchninfo q;
	int error;

	/* Verify current status. */
	if (sc->audio_status != CD_AS_PLAY_IN_PROGRESS)	{
		printf("%s: pause: attempted when not playing\n",
		    sc->sc_dev.dv_xname);
		return EINVAL;
	}

	/* Get the current position. */
	if ((error = mcd_getqchan(sc, &q, CD_CURRENT_POSITION)) != 0)
		return error;

	/* Copy it into lastpb. */
	sc->lastpb.data.seek.start_msf[0] = q.current.absolute_pos[0];
	sc->lastpb.data.seek.start_msf[1] = q.current.absolute_pos[1];
	sc->lastpb.data.seek.start_msf[2] = q.current.absolute_pos[2];

	/* Stop playing. */
	if ((error = mcd_stop(sc)) != 0)
		return error;

	/* Set the proper status and exit. */
	sc->audio_status = CD_AS_PLAY_PAUSED;
	return 0;
}

int
mcd_resume(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;
	int error;

	if (sc->audio_status != CD_AS_PLAY_PAUSED)
		return EINVAL;

	if ((error = mcd_setmode(sc, MCD_MD_COOKED)) != 0)
		return error;

	mbx.cmd = sc->lastpb;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}

int
mcd_eject(sc)
	struct mcd_softc *sc;
{
	struct mcd_mbox mbx;

	mbx.cmd.opcode = MCD_CMDEJECTDISK;
	mbx.cmd.length = 0;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 0);
}

int
mcd_setlock(sc, mode)
	struct mcd_softc *sc;
	int mode;
{
	struct mcd_mbox mbx;
	
	mbx.cmd.opcode = MCD_CMDSETLOCK;
	mbx.cmd.length = sizeof(mbx.cmd.data.lockmode);
	mbx.cmd.data.lockmode.mode = mode;
	mbx.res.length = 0;
	return mcd_send(sc, &mbx, 1);
}
@


1.60
log
@Update mcd(4) to use disk_lock, etc. instead of its own tsleep(9)
based locking.

ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.59 2011/06/05 18:40:33 matthew Exp $ */
@


1.59
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.58 2011/06/03 21:14:11 matthew Exp $ */
a123 2
#define	MCDF_LOCKED	0x01
#define	MCDF_WANTED	0x02
a221 2
int	mcdlock(struct mcd_softc *);
void	mcdunlock(struct mcd_softc *);
a286 36
/*
 * Wait interruptibly for an exclusive lock.
 *
 * XXX
 * Several drivers do this; it should be abstracted and made MP-safe.
 */
int
mcdlock(sc)
	struct mcd_softc *sc;
{
	int error;

	while ((sc->flags & MCDF_LOCKED) != 0) {
		sc->flags |= MCDF_WANTED;
		if ((error = tsleep(sc, PRIBIO | PCATCH, "mcdlck", 0)) != 0)
			return error;
	}
	sc->flags |= MCDF_LOCKED;
	return 0;
}

/*
 * Unlock and wake up any waiters.
 */
void
mcdunlock(sc)
	struct mcd_softc *sc;
{

	sc->flags &= ~MCDF_LOCKED;
	if ((sc->flags & MCDF_WANTED) != 0) {
		sc->flags &= ~MCDF_WANTED;
		wakeup(sc);
	}
}

d304 1
a304 1
	if ((error = mcdlock(sc)) != 0)
d374 1
a374 1
	mcdunlock(sc);
d389 1
a389 1
	mcdunlock(sc);
a400 1
	int error;
d404 1
a404 2
	if ((error = mcdlock(sc)) != 0)
		return error;
d428 1
a428 1
	mcdunlock(sc);
d606 1
a606 1
		if ((error = mcdlock(sc)) != 0)
d614 1
a614 1
		mcdunlock(sc);
@


1.58
log
@Get rid of the wlabel argument to bounds_check_with_label().  It's
never done anything in OpenBSD and just clutters disk drivers with
silly flag handling.

More cleanup to follow.

ok deraadt@@, millert@@; no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.57 2011/06/03 18:22:25 matthew Exp $ */
a125 2
#define	MCDF_WLABEL	0x04	/* label is writable */
#define	MCDF_LABELLING	0x08	/* writing label */
a649 1
		sc->flags |= MCDF_LABELLING;
a655 1
		sc->flags &= ~MCDF_LABELLING;
a657 3

	case DIOCWLABEL:
		return EBADF;
@


1.57
log
@Fix two compile errors in mcd(4) due to bitrot:

  1. Need to include <sys/dkio.h> since <sys/ioctl.h> no longer
     includes it.

  2. readdisklabel() returns an int, not an error string, so update
     mcdgetdisklabel() accordingly.  The return value is just ignored
     currently, but that's no worse than cdgetdisklabel() in cd(4)...

Apparently no one has needed mcd(4) in the last two years.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.56 2010/09/22 01:18:57 matthew Exp $ */
d509 1
a509 2
	if (bounds_check_with_label(bp, sc->sc_dk.dk_label,
	    (sc->flags & (MCDF_WLABEL|MCDF_LABELLING)) != 0) <= 0)
@


1.56
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.55 2010/09/08 14:47:12 jsing Exp $ */
d70 1
d222 1
a222 1
void	mcdgetdisklabel(dev_t, struct mcd_softc *, struct disklabel *, int);
d729 1
a729 1
void
a735 2
	char *errstring;
	
d761 1
a761 5
	errstring = readdisklabel(DISKLABELDEV(dev), mcdstrategy, lp, spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);*/
		return;
	}
@


1.55
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.53 2010/04/23 15:25:21 jsing Exp $ */
d596 1
a596 1
	return (physio(mcdstrategy, NULL, dev, B_READ, minphys, uio));
d606 1
a606 1
	return (physio(mcdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.54
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d273 1
a273 1
	disk_attach(&sc->sc_dk);
@


1.53
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.51 2008/11/27 22:59:52 miod Exp $ */
a228 2
struct dkdriver mcddkdriver = { mcdstrategy };

a271 1
	sc->sc_dk.dk_driver = &mcddkdriver;
@


1.52
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@a755 2
	lp->d_rpm = 300;
	lp->d_interleave = 1;
@


1.51
log
@Needs explicit <sys/malloc.h> include; Georg Schwarz
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.50 2008/06/15 00:36:41 krw Exp $ */
d486 1
a486 1
	MCD_TRACE("strategy: buf=0x%lx blkno=%ld bcount=%ld\n", bp,
d490 1
a490 1
		printf("%s: strategy: blkno = %d bcount = %ld\n",
d1185 1
a1185 1
		MCD_TRACE("doread: read blkno=%d for bp=0x%x\n", mbx->blkno,
d1733 1
a1733 1
		printf("%s: playblocks: blkno %d length %d\n",
@


1.50
log
@Don't bypass partition bounds check for RAW_PART. We now guarantee that
RAW_PART will always be 0 -> disksize, so the bounds check will always
pass for i/o's to valid addresses. Now the i/o will be properly truncated
if it goes past the end of the device. This prevents various adverse
impacts of issuing i/o's for data past the end of the device.

Repeatedly requested by todd@@.

ok weingart@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.49 2007/06/20 18:15:46 deraadt Exp $ */
d65 1
@


1.49
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.48 2007/06/18 20:55:52 deraadt Exp $ */
d510 1
a510 2
	if (DISKPART(bp->b_dev) != RAW_PART &&
	    bounds_check_with_label(bp, sc->sc_dk.dk_label,
@


1.48
log
@avoid modification race in DIOCRLDINFO; ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.47 2007/06/08 05:27:58 deraadt Exp $ */
d220 1
a220 2
void	mcdgetdisklabel(dev_t, struct mcd_softc *, struct disklabel *,
			     struct cpu_disklabel *, int);
d389 1
a389 2
			mcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,
			    sc->sc_dk.dk_cpulabel, 0);
a511 1
	    sc->sc_dk.dk_cpulabel,
d632 1
a632 1
		mcdgetdisklabel(dev, sc, lp, sc->sc_dk.dk_cpulabel, 0);
d658 1
a658 2
		    (struct disklabel *)addr, /*sc->sc_dk.dk_openmask : */0,
		    sc->sc_dk.dk_cpulabel);
d732 1
a732 1
mcdgetdisklabel(dev, sc, lp, clp, spoofonly)
a735 1
	struct cpu_disklabel *clp;
a740 1
	bzero(clp, sizeof(struct cpu_disklabel));
d767 1
a767 2
	errstring = readdisklabel(DISKLABELDEV(dev), mcdstrategy, lp, clp,
	    spoofonly);
@


1.47
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.46 2007/06/06 17:15:13 deraadt Exp $ */
d624 1
d634 4
a637 2
		mcdgetdisklabel(dev, sc, sc->sc_dk.dk_label,
		    sc->sc_dk.dk_cpulabel, 0);
d639 1
@


1.46
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.45 2007/06/05 00:38:21 deraadt Exp $ */
d760 1
@


1.45
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.44 2007/06/01 00:07:48 krw Exp $ */
d97 1
a97 1
	daddr_t		blkno;
d180 1
a180 1
static daddr_t msf2hsg(bcd_t *, int);
d781 1
a781 1
	daddr_t size;
d803 1
a803 1
int
d815 1
a815 1
	daddr_t blkno;
d1104 1
a1104 1
static daddr_t
d1109 1
a1109 1
	daddr_t blkno;
d1457 1
a1457 1
	daddr_t lba;
d1577 1
a1577 1
	daddr_t lba;
@


1.44
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.43 2007/05/04 22:14:36 deraadt Exp $ */
d582 1
a582 1
		sc->mbx.blkno += p->p_offset;
d757 1
a757 1
	lp->d_secperunit = sc->disksize;
@


1.43
log
@move bcd tables to the only place that uses them (the unused mcd driver);
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.42 2007/04/29 22:22:34 krw Exp $ */
a759 5

	lp->d_partitions[RAW_PART].p_offset = 0;
	lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
	lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
	lp->d_npartitions = RAW_PART + 1;
@


1.42
log
@MCDUNIT/etc -> DISKUNIT/etc. No change to mcd.o.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.41 2006/09/26 23:33:04 krw Exp $ */
d150 28
@


1.41
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.40 2006/08/13 16:24:13 krw Exp $ */
a90 6
#define	MCDPART(dev)	DISKPART(dev)
#define	MCDUNIT(dev)	DISKUNIT(dev)
#define	MAKEMCDDEV(maj, unit, part)	MAKEDISKDEV(maj, unit, part)

#define	MCDLABELDEV(dev) (MAKEMCDDEV(major(dev), MCDUNIT(dev), RAW_PART))

d313 1
a313 1
	unit = MCDUNIT(dev);
d370 1
a370 1
	part = MCDPART(dev);
d416 2
a417 2
	struct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];
	int part = MCDPART(dev);
d455 1
a455 1
	struct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(bp->b_dev)];
d484 1
a484 1
	if (MCDPART(bp->b_dev) != RAW_PART &&
d551 1
a551 1
	if (MCDPART(bp->b_dev) != RAW_PART) {
d553 1
a553 1
		p = &sc->sc_dk.dk_label->d_partitions[MCDPART(bp->b_dev)];
d595 1
a595 1
	struct mcd_softc *sc = mcd_cd.cd_devs[MCDUNIT(dev)];
d616 1
a616 1
		    &sc->sc_dk.dk_label->d_partitions[MCDPART(dev)];
d745 1
a745 1
	errstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp, clp,
@


1.40
log
@RAW_PART p_size on floppies and mcd's should be in sectors.

Only 'Japanese 1.2MB' floppies have sectors that are not 512 bytes, according
to isa/fd.c's fd_types[].

SCSI/ATAPI cd's already use sectors, and mcd cd's should be no different.

So there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.39 2006/03/15 20:20:41 miod Exp $ */
a737 1
	lp->d_flags = D_REMOVABLE;
@


1.39
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.38 2006/03/10 18:13:10 miod Exp $ */
d741 1
a741 2
	lp->d_partitions[RAW_PART].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.38
log
@Silence mcd during probe, as in 1.13 but accidentally lost in 1.24.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.37 2006/03/09 23:06:20 miod Exp $ */
a254 2

	dk_establish(&sc->sc_dk, &sc->sc_dev);
@


1.37
log
@Do not include <lib/libkern/libkern.h> explicitely, get it via <sys/systm.h>.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.36 2006/03/09 23:05:18 miod Exp $ */
a911 1
	strlcpy(sc.sc_dev.dv_xname, "mcd", sizeof(sc.sc_dev.dv_xname));
d975 1
a975 1
		else if (sc->probe)
@


1.36
log
@Zero-fill the fake softc during probe, and put a plausible dv_xname, so that
probe failures don't display garbage in their messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.35 2006/01/02 05:21:40 brad Exp $ */
a83 2

#include <lib/libkern/libkern.h>
@


1.35
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.34 2004/05/01 23:23:13 millert Exp $ */
d913 2
@


1.34
log
@Fix a disk_unbusy() that was missing the 3rd argument; Georg Schwarz
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.33 2004/02/15 02:45:47 tedu Exp $ */
a188 2
#define __BROKEN_INDIRECT_CONFIG
#ifdef __BROKEN_INDIRECT_CONFIG
a189 3
#else
int mcdprobe(struct device *, struct cfdata *, void *);
#endif
a892 1
#ifdef __BROKEN_INDIRECT_CONFIG
a893 3
#else
	struct cfdata *match;
#endif
@


1.33
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.32 2003/04/06 15:28:25 krw Exp $ */
d1276 2
a1277 1
	disk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid));
@


1.32
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.31 2002/05/24 13:31:11 art Exp $ */
d1244 1
a1244 1
		disk_unbusy(&sc->sc_dk, bp->b_bcount);
@


1.31
log
@More splbio around biodone protection.
In these drivers I'm probably using more paranoia than necessary.
If you really need to squeeze out the last drop of performance from the
fd driver, call me.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.30 2002/03/14 01:26:56 millert Exp $ */
d741 1
a741 1
	strncpy(lp->d_typename, "Mitsumi CD-ROM", 16);
d743 1
a743 1
	strncpy(lp->d_packname, "fictitious", 16);
@


1.30
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.29 2000/11/11 23:55:57 mickey Exp $ */
d517 1
d519 1
d550 1
d552 1
@


1.29
log
@new timeouts; compiles
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.28 1999/08/10 23:09:49 deraadt Exp $ */
d159 2
a160 2
static void hsg2msf __P((int, bcd_t *));
static daddr_t msf2hsg __P((bcd_t *, int));
d162 25
a186 25
int mcd_playtracks __P((struct mcd_softc *, struct ioc_play_track *));
int mcd_playmsf __P((struct mcd_softc *, struct ioc_play_msf *));
int mcd_playblocks __P((struct mcd_softc *, struct ioc_play_blocks *));
int mcd_stop __P((struct mcd_softc *));
int mcd_eject __P((struct mcd_softc *));
int mcd_read_subchannel __P((struct mcd_softc *, struct ioc_read_subchannel *));
int mcd_pause __P((struct mcd_softc *));
int mcd_resume __P((struct mcd_softc *));
int mcd_toc_header __P((struct mcd_softc *, struct ioc_toc_header *));
int mcd_toc_entries __P((struct mcd_softc *, struct ioc_read_toc_entry *));

int mcd_getreply __P((struct mcd_softc *));
int mcd_getstat __P((struct mcd_softc *));
int mcd_getresult __P((struct mcd_softc *, struct mcd_result *));
void mcd_setflags __P((struct mcd_softc *));
int mcd_get __P((struct mcd_softc *, char *, int));
int mcd_send __P((struct mcd_softc *, struct mcd_mbox *, int));
int mcdintr __P((void *));
void mcd_soft_reset __P((struct mcd_softc *));
int mcd_hard_reset __P((struct mcd_softc *));
int mcd_setmode __P((struct mcd_softc *, int));
int mcd_setupc __P((struct mcd_softc *, int));
int mcd_read_toc __P((struct mcd_softc *));
int mcd_getqchan __P((struct mcd_softc *, union mcd_qchninfo *, int));
int mcd_setlock __P((struct mcd_softc *, int));
d188 1
a188 1
int mcd_find __P((bus_space_tag_t, bus_space_handle_t, struct mcd_softc *));
d191 1
a191 1
int mcdprobe __P((struct device *, void *, void *));
d193 1
a193 1
int mcdprobe __P((struct device *, struct cfdata *, void *));
d195 1
a195 1
void mcdattach __P((struct device *, struct device *, void *));
d205 8
a212 8
void	mcdgetdisklabel __P((dev_t, struct mcd_softc *, struct disklabel *,
			     struct cpu_disklabel *, int));
int	mcd_get_parms __P((struct mcd_softc *));
void	mcdstrategy __P((struct buf *));
void	mcdstart __P((struct mcd_softc *));
int	mcdlock __P((struct mcd_softc *));
void	mcdunlock __P((struct mcd_softc *));
void	mcd_pseudointr __P((void *));
@


1.29.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.29 2000/11/11 23:55:57 mickey Exp $ */
d159 2
a160 2
static void hsg2msf(int, bcd_t *);
static daddr_t msf2hsg(bcd_t *, int);
d162 25
a186 25
int mcd_playtracks(struct mcd_softc *, struct ioc_play_track *);
int mcd_playmsf(struct mcd_softc *, struct ioc_play_msf *);
int mcd_playblocks(struct mcd_softc *, struct ioc_play_blocks *);
int mcd_stop(struct mcd_softc *);
int mcd_eject(struct mcd_softc *);
int mcd_read_subchannel(struct mcd_softc *, struct ioc_read_subchannel *);
int mcd_pause(struct mcd_softc *);
int mcd_resume(struct mcd_softc *);
int mcd_toc_header(struct mcd_softc *, struct ioc_toc_header *);
int mcd_toc_entries(struct mcd_softc *, struct ioc_read_toc_entry *);

int mcd_getreply(struct mcd_softc *);
int mcd_getstat(struct mcd_softc *);
int mcd_getresult(struct mcd_softc *, struct mcd_result *);
void mcd_setflags(struct mcd_softc *);
int mcd_get(struct mcd_softc *, char *, int);
int mcd_send(struct mcd_softc *, struct mcd_mbox *, int);
int mcdintr(void *);
void mcd_soft_reset(struct mcd_softc *);
int mcd_hard_reset(struct mcd_softc *);
int mcd_setmode(struct mcd_softc *, int);
int mcd_setupc(struct mcd_softc *, int);
int mcd_read_toc(struct mcd_softc *);
int mcd_getqchan(struct mcd_softc *, union mcd_qchninfo *, int);
int mcd_setlock(struct mcd_softc *, int);
d188 1
a188 1
int mcd_find(bus_space_tag_t, bus_space_handle_t, struct mcd_softc *);
d191 1
a191 1
int mcdprobe(struct device *, void *, void *);
d193 1
a193 1
int mcdprobe(struct device *, struct cfdata *, void *);
d195 1
a195 1
void mcdattach(struct device *, struct device *, void *);
d205 8
a212 8
void	mcdgetdisklabel(dev_t, struct mcd_softc *, struct disklabel *,
			     struct cpu_disklabel *, int);
int	mcd_get_parms(struct mcd_softc *);
void	mcdstrategy(struct buf *);
void	mcdstart(struct mcd_softc *);
int	mcdlock(struct mcd_softc *);
void	mcdunlock(struct mcd_softc *);
void	mcd_pseudointr(void *);
a516 1
	s = splbio();
a517 1
	splx(s);
a547 1
		s = splbio();
a548 1
		splx(s);
@


1.29.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d741 1
a741 1
	strncpy(lp->d_typename, "Mitsumi CD-ROM", sizeof lp->d_typename);
d743 1
a743 1
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.28
log
@support DIOCRLDINFO
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.27 1998/10/05 00:39:27 millert Exp $ */
d75 1
d121 1
d254 2
d1161 1
a1161 1
		untimeout(mcd_pseudointr, sc);
d1199 1
a1199 1
		untimeout(mcd_pseudointr, sc);
d1257 1
a1257 1
		timeout(mcd_pseudointr, sc, hz / 100);
@


1.28.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.29 2000/11/11 23:55:57 mickey Exp $ */
a74 1
#include <sys/timeout.h>
a119 1
	struct timeout sc_pi_tmo;
a251 2
	timeout_set(&sc->sc_pi_tmo, mcd_pseudointr, sc);

d1157 1
a1157 1
		timeout_del(&sc->sc_pi_tmo);
d1195 1
a1195 1
		timeout_del(&sc->sc_pi_tmo);
d1253 1
a1253 1
		timeout_add(&sc->sc_pi_tmo, hz / 100);
@


1.28.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d159 2
a160 2
static void hsg2msf(int, bcd_t *);
static daddr_t msf2hsg(bcd_t *, int);
d162 25
a186 25
int mcd_playtracks(struct mcd_softc *, struct ioc_play_track *);
int mcd_playmsf(struct mcd_softc *, struct ioc_play_msf *);
int mcd_playblocks(struct mcd_softc *, struct ioc_play_blocks *);
int mcd_stop(struct mcd_softc *);
int mcd_eject(struct mcd_softc *);
int mcd_read_subchannel(struct mcd_softc *, struct ioc_read_subchannel *);
int mcd_pause(struct mcd_softc *);
int mcd_resume(struct mcd_softc *);
int mcd_toc_header(struct mcd_softc *, struct ioc_toc_header *);
int mcd_toc_entries(struct mcd_softc *, struct ioc_read_toc_entry *);

int mcd_getreply(struct mcd_softc *);
int mcd_getstat(struct mcd_softc *);
int mcd_getresult(struct mcd_softc *, struct mcd_result *);
void mcd_setflags(struct mcd_softc *);
int mcd_get(struct mcd_softc *, char *, int);
int mcd_send(struct mcd_softc *, struct mcd_mbox *, int);
int mcdintr(void *);
void mcd_soft_reset(struct mcd_softc *);
int mcd_hard_reset(struct mcd_softc *);
int mcd_setmode(struct mcd_softc *, int);
int mcd_setupc(struct mcd_softc *, int);
int mcd_read_toc(struct mcd_softc *);
int mcd_getqchan(struct mcd_softc *, union mcd_qchninfo *, int);
int mcd_setlock(struct mcd_softc *, int);
d188 1
a188 1
int mcd_find(bus_space_tag_t, bus_space_handle_t, struct mcd_softc *);
d191 1
a191 1
int mcdprobe(struct device *, void *, void *);
d193 1
a193 1
int mcdprobe(struct device *, struct cfdata *, void *);
d195 1
a195 1
void mcdattach(struct device *, struct device *, void *);
d205 8
a212 8
void	mcdgetdisklabel(dev_t, struct mcd_softc *, struct disklabel *,
			     struct cpu_disklabel *, int);
int	mcd_get_parms(struct mcd_softc *);
void	mcdstrategy(struct buf *);
void	mcdstart(struct mcd_softc *);
int	mcdlock(struct mcd_softc *);
void	mcdunlock(struct mcd_softc *);
void	mcd_pseudointr(void *);
@


1.28.4.3
log
@Sync the SMP branch with 3.3
@
text
@a516 1
	s = splbio();
a517 1
	splx(s);
a547 1
		s = splbio();
a548 1
		splx(s);
@


1.28.4.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.28.4.3 2003/03/28 00:38:16 niklas Exp $ */
d741 1
a741 1
	strncpy(lp->d_typename, "Mitsumi CD-ROM", sizeof lp->d_typename);
d743 1
a743 1
	strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.28.4.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d1244 1
a1244 1
		disk_unbusy(&sc->sc_dk, bp->b_bcount, (bp->b_flags & B_READ));
d1276 1
a1276 2
	disk_unbusy(&sc->sc_dk, (bp->b_bcount - bp->b_resid),
	    (bp->b_flags & B_READ));
@


1.27
log
@make DIOCGPDINFO equivalent to DIOCGDINFO for cd's
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.26 1998/10/04 21:25:41 millert Exp $ */
d611 4
@


1.26
log
@Add DIOCGPDINFO support
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.25 1998/10/03 21:19:00 millert Exp $ */
a610 7
	case DIOCGPDINFO: {
			struct cpu_disklabel osdep;

			mcdgetdisklabel(dev, sc, (struct disklabel *)addr,
			    &osdep, 1);
			return 0;
		}
d612 1
@


1.25
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.24 1998/04/26 21:02:49 provos Exp $ */
d203 2
a204 2
void	mcdgetdefaultlabel __P((dev_t, struct mcd_softc *, struct disklabel *));
void	mcdgetdisklabel __P((dev_t, struct mcd_softc *));
d373 2
a374 1
			mcdgetdisklabel(dev, sc);
d611 7
a649 4
/*	case DIOCGDEFLABEL:
		mcdgetdefaultlabel(dev, sc, (struct disklabel *)addr);
		return 0;
*/
d713 1
a713 1
mcdgetdefaultlabel(dev, sc, lp)
d717 2
d723 1
d732 1
a732 1
		/* as long as it's not 0 - readdisklabel divides by it (?) */
d756 2
a757 2
	errstring = readdisklabel(MCDLABELDEV(dev), mcdstrategy, lp,
	    sc->sc_dk.dk_cpulabel, 0);
a761 16
}

/*
 * This could have been taken from scsi/cd.c, but it is not clear
 * whether the scsi cd driver is linked in.
 */
void
mcdgetdisklabel(dev, sc)
        dev_t dev;
	struct mcd_softc *sc;
{
	struct disklabel *lp = sc->sc_dk.dk_label;
	
	bzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));

	mcdgetdefaultlabel(dev, sc, lp);
@


1.24
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.23 1997/11/30 22:33:21 mickey Exp $ */
d750 1
a750 1
	    sc->sc_dk.dk_cpulabel);
@


1.23
log
@use libkern's bcd convs
@
text
@d1 2
a2 2
/*	$OpenBSD: mcd.c,v 1.22 1997/10/18 10:37:12 deraadt Exp $ */
/*	$NetBSD: mcd.c,v 1.49 1996/05/12 23:53:11 mycroft Exp $	*/
d78 1
a78 1
#include <machine/pio.h>
d121 3
a123 1
	int	iobase;
a126 2
	u_char	readcmd;
	u_char	attached;
a145 1
	int	debug;
d147 3
d186 3
d190 3
d203 1
d231 2
d235 17
d642 4
a707 4
/*
 * This could have been taken from scsi/cd.c, but it is not clear
 * whether the scsi cd driver is linked in.
 */
d709 1
a709 1
mcdgetdisklabel(dev, sc)
d712 1
a713 1
	struct disklabel *lp = sc->sc_dk.dk_label;
a716 1
	bzero(sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d741 1
a741 1
	
d757 16
d821 3
d825 4
a828 3
mcdprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
a829 3
	struct mcd_softc *sc = match;
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;
d833 2
a834 4
	sc->iobase = iobase;

	if( !opti_cd_setup( OPTI_MITSUMI, iobase, ia->ia_irq, ia->ia_drq ) )
		/* printf("mcdprobe: could not setup OPTi chipset.\n") */;
d837 1
a837 1
	outb(iobase + MCD_RESET, 0);
d841 1
a841 1
		inb(iobase + MCD_STATUS);
a893 3
	sc->attached = 1;
	ia->ia_iosize = 4;
	ia->ia_msize = 0;
d895 43
d944 2
a945 1
	int iobase = sc->iobase;
d950 2
a951 1
		if ((inb(iobase + MCD_XFER) & MCD_XF_STATUSUNAVAIL) == 0)
d959 1
a959 1
	return inb(iobase + MCD_STATUS);
d988 1
a988 1
		else if (sc->attached)
d1018 3
a1020 2
	while ((inb(sc->iobase + MCD_XFER) & MCD_XF_STATUSUNAVAIL) == 0) {
		x = inb(sc->iobase + MCD_STATUS);
a1060 1
	int iobase = sc->iobase;
d1062 2
d1074 1
a1074 1
		outb(iobase + MCD_COMMAND, mbx->cmd.opcode);
d1076 1
a1076 1
			outb(iobase + MCD_COMMAND, mbx->cmd.data.raw.data[i]);
a1142 1
	int iobase = sc->iobase;
d1144 2
d1161 2
a1162 2
		outb(iobase + MCD_COMMAND, MCD_CMDSETMODE);
		outb(iobase + MCD_COMMAND, mbx->mode);
d1170 1
a1170 1
			x = inb(iobase + MCD_XFER);
d1177 1
a1177 1
		sc->status = inb(iobase + MCD_STATUS);
d1194 7
a1200 7
		outb(iobase + MCD_COMMAND, sc->readcmd);
		outb(iobase + MCD_COMMAND, msf[0]);
		outb(iobase + MCD_COMMAND, msf[1]);
		outb(iobase + MCD_COMMAND, msf[2]);
		outb(iobase + MCD_COMMAND, 0);
		outb(iobase + MCD_COMMAND, 0);
		outb(iobase + MCD_COMMAND, mbx->nblk);
d1210 1
a1210 1
			x = inb(iobase + MCD_XFER);
d1219 1
a1219 1
		sc->status = inb(iobase + MCD_STATUS);
d1234 4
a1237 3
		outb(iobase + MCD_CTL2, 0x04);	/* XXX */
		insb(iobase + MCD_RDATA, bp->b_data + mbx->skip, mbx->sz);
		outb(iobase + MCD_CTL2, 0x0c);	/* XXX */
d1287 1
a1287 1
	outb(mbx->iobase + MCD_RESET, MCD_CMDRESET);
d1306 1
a1306 1
	outb(sc->iobase + MCD_CTL2, 0x0c);	/* XXX */
@


1.22
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.21 1997/09/29 12:01:27 mickey Exp $ */
d84 2
a154 2
static int bcd2bin __P((bcd_t));
static bcd_t bin2bcd __P((int));
a1001 16
}

static int
bcd2bin(b)
	bcd_t b;
{

	return (b >> 4) * 10 + (b & 15);
}

static bcd_t
bin2bcd(b)
	int b;
{

	return ((b / 10) << 4) | (b % 10);
@


1.21
log
@<sys/types.h> OR <sys/param.h>, BUT NOT both
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.20 1997/08/08 21:47:02 niklas Exp $ */
d725 1
a725 1
		printf("%s: %s\n", sc->sc_dev.dv_xname, errstring);
@


1.20
log
@Change the bounds_check_with_label API to also take a cpu_disklabel
reference for making transferral of meta-information possible from
readdisklabel to bounds_check_with_label.  The first (and maybe only)
thing that will use this is the multi-disklabel-format code on the
alpha where the labelsector is passed via cpu_disklabel so the label
write-protection can work correctly no matter what label was found.

Also use a new macro DKBAD to get at the dkbad field of the cpu_disklabel
implementations that contain it.  This too is for multi-disklabel
architectures where the "bad" field can be inside a union.  Use this
macro as a means for a driver to check if an architecture supports
dkbad constructs.

Remove proto of bounds_check_with_label from all MD disklabel.h as it
is in sys/disklabel.h.

I have not been able to test the changes everywhere, if I break anything
I apologize, and promise to fix it as soon as I become aware of it.
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.19 1997/01/04 08:50:25 deraadt Exp $ */
a58 1
#include <sys/types.h>
@


1.19
log
@readdisklabel() with correct dev_t
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.18 1996/12/05 13:15:28 deraadt Exp $ */
d469 1
@


1.18
log
@call readdisklabel() in the same fashion as sd.c does
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.17 1996/09/20 06:08:10 deraadt Exp $ */
d95 2
d196 1
a196 1
void	mcdgetdisklabel __P((struct mcd_softc *));
d346 1
a346 1
			mcdgetdisklabel(sc);
d681 2
a682 1
mcdgetdisklabel(sc)
d722 2
a723 2
	errstring = readdisklabel(MAKEMCDDEV(0, sc->sc_dev.dv_unit, RAW_PART),
	    mcdstrategy, lp, sc->sc_dk.dk_cpulabel);
@


1.17
log
@silent probe, silent attach; netbsd pr#2108, mike.long@@analog.com
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.16 1996/06/10 00:48:05 deraadt Exp $ */
d93 1
d683 1
d693 4
d699 1
a699 1
	lp->d_type = 0;	/* XXX */
a705 4
	lp->d_partitions[0].p_offset = 0;
	lp->d_partitions[0].p_size =
	    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
	lp->d_partitions[0].p_fstype = FS_ISO9660;
d709 1
a709 1
	lp->d_partitions[RAW_PART].p_fstype = FS_ISO9660;
d715 10
@


1.16
log
@enqueue eject for mcdclose()
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.15 1996/06/09 19:40:12 deraadt Exp $ */
d828 1
d832 1
@


1.15
log
@support MTIOCTOP's MTOFFL to mean "eject"
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.14 1996/06/01 09:35:35 deraadt Exp $ */
d129 1
d422 4
a426 1

d646 2
a647 1
		return mcd_eject(sc);
@


1.14
log
@all ports have dk_establish()
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.13 1996/05/27 07:57:34 deraadt Exp $ */
d70 1
d636 4
@


1.13
log
@silence getresult during probe
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.12 1996/05/26 00:27:25 deraadt Exp $ */
d226 2
@


1.12
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.11 1996/05/07 07:37:20 deraadt Exp $ */
d121 1
d823 1
d875 1
a875 1
		else
@


1.11
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: mcd.c,v 1.9 1996/04/21 22:24:21 deraadt Exp $ */
/*	$NetBSD: mcd.c,v 1.48 1996/04/29 20:28:44 christos Exp $	*/
d77 1
@


1.10
log
@Add OPTi 82C929 chipset support for sound(wss,sb)/cd(mcd,scd,pcd,atapi)
card. This is software programable card.
Missing:	SB support (no srcs available, and dos's exe is too big ;)
Not tested:	pcd(panasonic cd)(no driver); mcd,atapi(have no hw).
@
text
@d2 1
a2 1
/*	$NetBSD: mcd.c,v 1.47 1996/04/11 22:29:43 cgd Exp $	*/
d143 3
a145 4
int mcdopen __P((dev_t, int, int, struct proc *));
int mcdclose __P((dev_t, int, int));
int mcdioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int mcdsize __P((dev_t));
d189 7
a195 4
void mcdgetdisklabel __P((struct mcd_softc *));
int mcd_get_parms __P((struct mcd_softc *));
void mcdstrategy __P((struct buf *));
void mcdstart __P((struct mcd_softc *));
d295 1
a295 1
	if (error = mcdlock(sc))
d385 1
a385 1
mcdclose(dev, flag, fmt)
d388 1
d396 1
a396 1
	if (error = mcdlock(sc))
d434 1
a434 1
		printf("%s: strategy: blkno = %d bcount = %d\n",
d534 1
a534 1
mcdread(dev, uio)
d537 1
d544 1
a544 1
mcdwrite(dev, uio)
d547 1
d585 1
a585 1
		if (error = mcdlock(sc))
d1018 2
a1019 2
mcd_pseudointr(sc)
	struct mcd_softc *sc;
d1021 1
a1171 1
harderr:
@


1.9
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.8 1996/03/20 01:00:56 mickey Exp $ */
d81 1
d756 3
@


1.8
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: mcd.c,v 1.7 1996/03/19 21:10:25 mickey Exp $ */
/*	$NetBSD: mcd.c,v 1.45 1996/01/30 18:28:05 thorpej Exp $ */
d181 6
a186 2
struct cfdriver mcdcd = {
	NULL, "mcd", mcdprobe, mcdattach, DV_DISK, sizeof(struct mcd_softc)
d235 2
a236 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_BIO, mcdintr,
	    sc, sc->sc_dev.dv_xname);
d286 1
a286 1
	if (unit >= mcdcd.cd_ndevs)
d288 1
a288 1
	sc = mcdcd.cd_devs[unit];
d386 1
a386 1
	struct mcd_softc *sc = mcdcd.cd_devs[MCDUNIT(dev)];
d422 1
a422 1
	struct mcd_softc *sc = mcdcd.cd_devs[MCDUNIT(bp->b_dev)];
d555 1
a555 1
	struct mcd_softc *sc = mcdcd.cd_devs[MCDUNIT(dev)];
@


1.7
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: mcd.c,v 1.6 1996/03/08 16:43:09 niklas Exp $ */
d232 1
a232 1
	    sc);
@


1.6
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d232 1
a232 1
	    sc, sc->sc_dev.dv_xname);
@


1.5
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: mcd.c,v 1.44 1996/01/07 22:03:37 thorpej Exp $	*/
d621 2
a622 1
	case CDIOCEJECT:
d628 3
@


1.4
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@d231 1
a231 1
	    sc);
@


1.3
log
@update to new cdio.h
@
text
@d1 1
a1 1
/*	$NetBSD: mcd.c,v 1.42 1995/08/05 23:47:52 mycroft Exp $	*/
d110 1
a110 1
	struct	dkdevice sc_dk;
d210 7
a229 2
	sc->sc_dk.dk_driver = &mcddkdriver;

d340 2
a341 2
	    (part >= sc->sc_dk.dk_label.d_npartitions ||
	     sc->sc_dk.dk_label.d_partitions[part].p_fstype == FS_UNUSED)) {
d447 1
a447 1
	    bounds_check_with_label(bp, &sc->sc_dk.dk_label,
d500 5
d510 1
a510 1
		p = &sc->sc_dk.dk_label.d_partitions[MCDPART(bp->b_dev)];
d560 1
a560 1
		*(struct disklabel *)addr = sc->sc_dk.dk_label;
d564 1
a564 1
		((struct partinfo *)addr)->disklab = &sc->sc_dk.dk_label;
d566 1
a566 1
		    &sc->sc_dk.dk_label.d_partitions[MCDPART(dev)];
d578 1
a578 1
		error = setdisklabel(&sc->sc_dk.dk_label,
d580 1
a580 1
		    &sc->sc_dk.dk_cpulabel);
d652 1
a652 1
	struct disklabel *lp = &sc->sc_dk.dk_label;
d655 1
a655 1
	bzero(&sc->sc_dk.dk_cpulabel, sizeof(struct cpu_disklabel));
d1124 1
d1157 1
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1355 7
a1361 4
			data.entries[n].addr[0] = 0;
			data.entries[n].addr[1] = bcd2bin(sc->toc[trk].toc.absolute_pos[0]);
			data.entries[n].addr[2] = bcd2bin(sc->toc[trk].toc.absolute_pos[1]);
			data.entries[n].addr[3] = bcd2bin(sc->toc[trk].toc.absolute_pos[2]);
d1365 4
a1368 4
			data.entries[n].addr[0] = lba >> 24;
			data.entries[n].addr[1] = lba >> 16;
			data.entries[n].addr[2] = lba >> 8;
			data.entries[n].addr[3] = lba;
d1478 14
a1491 8
			data.what.position.reladdr[0] = 0;
			data.what.position.reladdr[1] = bcd2bin(q.current.relative_pos[0]);
			data.what.position.reladdr[2] = bcd2bin(q.current.relative_pos[1]);
			data.what.position.reladdr[3] = bcd2bin(q.current.relative_pos[2]);
			data.what.position.absaddr[0] = 0;
			data.what.position.absaddr[1] = bcd2bin(q.current.absolute_pos[0]);
			data.what.position.absaddr[2] = bcd2bin(q.current.absolute_pos[1]);
			data.what.position.absaddr[3] = bcd2bin(q.current.absolute_pos[2]);
d1502 4
a1505 4
			data.what.position.reladdr[0] = lba >> 24;
			data.what.position.reladdr[1] = lba >> 16;
			data.what.position.reladdr[2] = lba >> 8;
			data.what.position.reladdr[3] = lba;
d1507 4
a1510 4
			data.what.position.absaddr[0] = lba >> 24;
			data.what.position.absaddr[1] = lba >> 16;
			data.what.position.absaddr[2] = lba >> 8;
			data.what.position.absaddr[3] = lba;
@


1.1
log
@Initial revision
@
text
@d225 2
a226 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_BIO,
	    mcdintr, sc);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
