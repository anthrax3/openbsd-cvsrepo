head	1.59;
access;
symbols
	OPENBSD_4_1:1.57.0.4
	OPENBSD_4_1_BASE:1.57
	OPENBSD_4_0:1.57.0.2
	OPENBSD_4_0_BASE:1.57
	OPENBSD_3_9:1.55.0.4
	OPENBSD_3_9_BASE:1.55
	OPENBSD_3_8:1.55.0.2
	OPENBSD_3_8_BASE:1.55
	OPENBSD_3_7:1.54.0.2
	OPENBSD_3_7_BASE:1.54
	OPENBSD_3_6:1.53.0.2
	OPENBSD_3_6_BASE:1.53
	SMP_SYNC_A:1.53
	SMP_SYNC_B:1.53
	OPENBSD_3_5:1.51.0.2
	OPENBSD_3_5_BASE:1.51
	OPENBSD_3_4:1.50.0.6
	OPENBSD_3_4_BASE:1.50
	UBC_SYNC_A:1.50
	OPENBSD_3_3:1.50.0.4
	OPENBSD_3_3_BASE:1.50
	OPENBSD_3_2:1.50.0.2
	OPENBSD_3_2_BASE:1.50
	OPENBSD_3_1:1.49.0.2
	OPENBSD_3_1_BASE:1.49
	UBC_SYNC_B:1.50
	UBC:1.48.0.4
	UBC_BASE:1.48
	OPENBSD_3_0:1.48.0.2
	OPENBSD_3_0_BASE:1.48
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_8:1.41.0.10
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.41.0.8
	OPENBSD_2_7_BASE:1.41
	SMP:1.41.0.6
	SMP_BASE:1.41
	kame_19991208:1.41
	OPENBSD_2_6:1.41.0.4
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.41.0.2
	OPENBSD_2_5_BASE:1.41
	OPENBSD_2_4:1.40.0.2
	OPENBSD_2_4_BASE:1.40
	OPENBSD_2_3:1.37.0.2
	OPENBSD_2_3_BASE:1.37
	OPENBSD_2_2:1.33.0.2
	OPENBSD_2_2_BASE:1.33
	OPENBSD_2_1:1.29.0.2
	OPENBSD_2_1_BASE:1.29
	OPENBSD_2_0:1.20.0.2
	OPENBSD_2_0_BASE:1.20
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.59
date	2007.06.08.17.48.04;	author henning;	state dead;
branches;
next	1.58;

1.58
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.56;

1.56
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.55;

1.55
date	2005.04.03.10.20.47;	author brad;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.53;

1.53
date	2004.06.06.17.56.36;	author mcbride;	state Exp;
branches;
next	1.52;

1.52
date	2004.05.12.06.35.10;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2003.11.07.10.16.45;	author jmc;	state Exp;
branches;
next	1.50;

1.50
date	2002.06.03.20.01.37;	author deraadt;	state Exp;
branches;
next	1.49;

1.49
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.48;

1.48
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches
	1.48.4.1;
next	1.47;

1.47
date	2001.08.25.10.13.29;	author art;	state Exp;
branches;
next	1.46;

1.46
date	2001.07.08.23.38.07;	author fgsch;	state Exp;
branches;
next	1.45;

1.45
date	2001.06.27.06.34.44;	author kjc;	state Exp;
branches;
next	1.44;

1.44
date	2001.06.25.04.44.27;	author fgsch;	state Exp;
branches;
next	1.43;

1.43
date	2001.06.23.21.54.47;	author fgsch;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.20.19.39.39;	author mickey;	state Exp;
branches;
next	1.41;

1.41
date	99.02.28.03.23.37;	author jason;	state Exp;
branches
	1.41.6.1;
next	1.40;

1.40
date	98.08.11.03.28.37;	author millert;	state Exp;
branches;
next	1.39;

1.39
date	98.07.31.18.02.05;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	98.06.03.18.50.45;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	98.03.17.10.55.24;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	98.03.17.10.50.33;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	98.03.16.10.41.39;	author downsj;	state Exp;
branches;
next	1.34;

1.34
date	98.02.15.01.49.58;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	97.10.06.20.53.03;	author mickey;	state Exp;
branches;
next	1.32;

1.32
date	97.08.20.03.46.31;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	97.08.01.07.40.10;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	97.06.20.20.25.27;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	97.04.14.02.06.22;	author millert;	state Exp;
branches;
next	1.28;

1.28
date	97.04.13.04.52.31;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	97.03.20.23.59.58;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	97.02.21.10.52.09;	author niklas;	state Exp;
branches;
next	1.25;

1.25
date	96.11.29.22.54.58;	author niklas;	state Exp;
branches;
next	1.24;

1.24
date	96.11.12.20.30.34;	author niklas;	state Exp;
branches;
next	1.23;

1.23
date	96.11.07.11.25.10;	author niklas;	state Exp;
branches;
next	1.22;

1.22
date	96.11.07.08.36.50;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	96.10.16.12.34.36;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	96.10.05.00.08.39;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.09.26.21.07.16;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	96.08.02.11.15.52;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	96.07.31.01.51.49;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	96.05.26.00.27.17;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.10.12.41.16;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.07.07.36.47;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.05.05.13.38.19;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	96.04.29.14.16.31;	author hvozda;	state Exp;
branches;
next	1.11;

1.11
date	96.04.27.22.19.59;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.04.21.22.23.41;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.18.23.47.37;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.03.20.01.00.46;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.03.19.21.10.14;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.08.16.42.59;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.02.20.04.35.52;	author tholo;	state Exp;
branches;
next	1.4;

1.4
date	96.01.16.20.12.59;	author hvozda;	state Exp;
branches;
next	1.3;

1.3
date	96.01.10.16.26.17;	author chuck;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.20;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches;
next	;

1.41.6.1
date	2001.05.14.22.24.39;	author niklas;	state Exp;
branches;
next	1.41.6.2;

1.41.6.2
date	2001.07.04.10.41.25;	author niklas;	state Exp;
branches;
next	1.41.6.3;

1.41.6.3
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.41.6.4;

1.41.6.4
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.41.6.5;

1.41.6.5
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.41.6.6;

1.41.6.6
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	1.41.6.7;

1.41.6.7
date	2004.06.05.23.12.45;	author niklas;	state Exp;
branches;
next	1.41.6.8;

1.41.6.8
date	2004.06.07.20.41.23;	author niklas;	state Exp;
branches;
next	;

1.48.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.59
log
@remove:
-entry for ix nic in files.isa, not even in tree
-ep nic driver, replaced by ne ages ago
-hp nic driver, broken for ages
from brad, ok matthieu krw theo miod
@
text
@/*	$OpenBSD: if_ed.c,v 1.58 2007/04/10 17:47:55 miod Exp $	*/
/*	$NetBSD: if_ed.c,v 1.105 1996/10/21 22:40:45 thorpej Exp $	*/

/*
 * Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 * adapters.
 *
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Copyright (C) 1993, David Greenman.  This software may be used, modified,
 * copied, distributed, and sold, in both source and binary form provided that
 * the above copyright and these terms are retained.  Under no circumstances is
 * the author responsible for the proper functioning of this software, nor does
 * the author assume any responsibility for damages incurred with its use.
 *
 * Currently supports the Western Digital/SMC 8003 and 8013 series, the SMC
 * Elite Ultra (8216), the 3Com 3c503, the NE1000 and NE2000, and a variety of
 * similar clones.
 */

#include "bpfilter.h"
#include "ed.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_types.h>
#include <net/netisr.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
#endif

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/ic/dp8390reg.h>
#include <dev/isa/if_edreg.h>

/*
 * ed_softc: per line info and status
 */
struct ed_softc {
	struct	device sc_dev;
	void	*sc_ih;

	struct	arpcom sc_arpcom;	/* ethernet common */
	void	*sc_sh;			/* shutdown hook */

	char	*type_str;	/* pointer to type string */
	u_char	vendor;		/* interface vendor */
	u_char	type;		/* interface type code */
	u_int16_t	spec_flags;
#define ED_REATTACH	0x0001	/* Reattach */
#define ED_NOTPRESENT 	0x0002	/* card not present; do not allow
				   reconfiguration */

	bus_space_tag_t sc_iot; /* bus identifier */
	bus_space_tag_t sc_memt;
	bus_space_handle_t sc_ioh;   /* io handle */
	bus_space_handle_t sc_delaybah; /* io handle for `delay port' */
	bus_space_handle_t sc_memh; /* bus memory handle */
	isa_chipset_tag_t sc_ic;

	bus_size_t	asic_base;	/* offset of ASIC I/O port */
	bus_size_t	nic_base;	/* offset of NIC (DS8390) I/O port */

/*
 * The following 'proto' variable is part of a work-around for 8013EBT asics
 * being write-only.  It's sort of a prototype/shadow of the real thing.
 */
	u_char	wd_laar_proto;
/*
 * This `proto' variable is so we can turn MENB on and off without reading
 * the value back from the card all the time.
 */
	u_char	wd_msr_proto;
	u_char	cr_proto;	/* values always set in CR */
	u_char	isa16bit;	/* width of access to card 0=8 or 1=16 */
	u_char	is790;		/* set by probe if NIC is a 790 */

	int	mem_start;	/* offset of NIC memory */
	int	mem_end;	/* offset of NIC memory end */
	int	mem_size;	/* total NIC memory size */
	int	mem_ring;	/* offset of RX ring-buffer (in NIC mem) */

	u_char	mem_shared;	/* NIC memory is shared with host */
	u_char	txb_cnt;	/* number of transmit buffers */
	u_char	txb_inuse;	/* number of transmit buffers active */

	u_char 	txb_new;	/* pointer to where new buffer will be added */
	u_char	txb_next_tx;	/* pointer to next buffer ready to xmit */
	u_int16_t	txb_len[8];	/* buffered xmit buffer lengths */
	u_char	tx_page_start;	/* first page of TX buffer area */
	u_char	rec_page_start;	/* first page of RX ring-buffer */
	u_char	rec_page_stop;	/* last page of RX ring-buffer */
	u_char	next_packet;	/* pointer to next unread RX packet */
};

int edprobe(struct device *, void *, void *);
void edattach(struct device *, struct device *, void *);
int ed_find(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_probe_generic8390(bus_space_tag_t, bus_space_handle_t, int);
int ed_find_WD80x3(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_3Com(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_Novell(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int edintr(void *);
int edioctl(struct ifnet *, u_long, caddr_t);
void edstart(struct ifnet *);
void edwatchdog(struct ifnet *);
void edreset(struct ed_softc *);
void edinit(struct ed_softc *);
void edstop(struct ed_softc *);

void ed_shared_writemem(struct ed_softc *, caddr_t, int, int);
void ed_shared_readmem(struct ed_softc *, int, caddr_t, int);

#define inline	/* XXX for debugging porpoises */

void ed_getmcaf(struct arpcom *, u_int32_t *);
void edread(struct ed_softc *, int, int);
struct mbuf *edget(struct ed_softc *, int, int);
static __inline void ed_rint(struct ed_softc *);
static __inline void ed_xmit(struct ed_softc *);
static __inline int ed_ring_copy(struct ed_softc *, int, caddr_t,
					u_int16_t);

void ed_pio_readmem(struct ed_softc *, u_int16_t, caddr_t, u_int16_t);
void ed_pio_writemem(struct ed_softc *, caddr_t, u_int16_t, u_int16_t);
u_int16_t ed_pio_write_mbufs(struct ed_softc *, struct mbuf *, u_int16_t);

#if NED_ISA > 0
struct cfattach ed_isa_ca = {
	sizeof(struct ed_softc), edprobe, edattach
};
#endif

struct cfdriver ed_cd = {
	NULL, "ed", DV_IFNET
};

#define	NIC_PUT(t, bah, nic, reg, val)	\
	bus_space_write_1((t), (bah), ((nic) + (reg)), (val))
#define	NIC_GET(t, bah, nic, reg)	\
	bus_space_read_1((t), (bah), ((nic) + (reg)))

#if NED_PCMCIA > 0 
#include <dev/pcmcia/pcmciavar.h>

int ed_pcmcia_match(struct device *, void *, void *);
void ed_pcmcia_attach(struct device *, struct device *, void *);
int ed_pcmcia_detach(struct device *);

struct cfattach ed_pcmcia_ca = {
	sizeof(struct ed_softc), ed_pcmcia_match, edattach, ed_pcmcia_detach
};

int ed_pcmcia_isa_attach(struct device *, void *, void *,
    struct pcmcia_link *);
int edmod(struct pcmcia_link *, struct device *, struct pcmcia_conf *,
    struct cfdata *cf);
int ed_remove(struct pcmcia_link *, struct device *);

/* additional setup needed for pcmcia devices */
int
ed_pcmcia_isa_attach(parent, match, aux, pc_link)
	struct device *parent;
	void *match;
	void *aux;
	struct pcmcia_link *pc_link;
{
	struct ed_softc *sc = match;
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
	struct isa_attach_args *ia = aux;
	struct pcmciadevs *dev=pc_link->device;
	int err;
	u_char enaddr[ETHER_ADDR_LEN];

	if ((int)dev->param != -1)
		err = pcmcia_read_cis(pc_link, enaddr, 
				      (int) dev->param, ETHER_ADDR_LEN);
	else
		err = 0;
	if (err)
		printf("%s: attaching ed: cannot read cis info %d\n",
		       parent->dv_xname, err);

	if (ed_find_Novell(sc, cf, ia)) {
		delay(100);
		if ((int)dev->param != -1) {
		    err = pcmcia_read_cis(pc_link, sc->sc_arpcom.ac_enaddr,
				      (int) dev->param, ETHER_ADDR_LEN);
		    if (err) {
			    printf("Cannot read cis info %d\n", err);
			    return 0;
		    }
		    if (bcmp(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN)) {
			    printf("ENADDR MISMATCH %s ",
				   ether_sprintf(sc->sc_arpcom.ac_enaddr));
			    printf("- %s\n", ether_sprintf(enaddr));
			    bcopy(enaddr,sc->sc_arpcom.ac_enaddr,
					    ETHER_ADDR_LEN);
		    }
		}
		/* clear ED_NOTPRESENT, set ED_REATTACH if needed */
		sc->spec_flags=pc_link->flags&PCMCIA_REATTACH?ED_REATTACH:0;
		sc->type_str = dev->model;
		sc->sc_ic = ia->ia_ic;
		return 1;
	} else
	    return 0;
}

/* modify config entry */
int
edmod(pc_link, self, pc_cf, cf) 
	struct pcmcia_link *pc_link;
	struct device *self;
	struct pcmcia_conf *pc_cf;
	struct cfdata *cf;
{
	int err;
/*	struct pcmciadevs *dev=pc_link->device;*/
/*	struct ed_softc *sc = (void *)self;*/
	int svec_card =  pc_cf->memwin  == 5;
	int de650_0 = (pc_cf->memwin != 0) && !svec_card;
	err = PCMCIA_BUS_CONFIG(pc_link->adapter, pc_link, self, pc_cf, cf);
	if (err)
		return err;

	if (svec_card) {
		pc_cf->memwin = 0;
#if 0
		pc_cf->cfgid = 32;  /* Try this if it still doesn't work */
		pc_cf->cfgid |= 32;  /* or Try this if it still doesn't work */
#endif
	}
	if (de650_0) {
		pc_cf->io[0].flags =
		    (pc_cf->io[0].flags&~PCMCIA_MAP_16)|PCMCIA_MAP_8;
		pc_cf->memwin = 0;
		pc_cf->cfgtype = DOSRESET|1;
	}
	else {
		/* still wrong in CIS; fix it here */
		pc_cf->io[0].flags = PCMCIA_MAP_8|PCMCIA_MAP_16;
		pc_cf->cfgtype = 1;
	}

	return err;
}

int
ed_remove(pc_link,self) 
	struct pcmcia_link *pc_link;
	struct device *self;
{
	struct ed_softc *sc = (void *)self;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	if_down(ifp);
	edstop(sc);
	if (sc->sc_sh != NULL)
		shutdownhook_disestablish(sc->sc_sh);
	ifp->if_flags &= ~(IFF_RUNNING|IFF_UP);
	sc->spec_flags |= ED_NOTPRESENT;
	isa_intr_disestablish(sc->sc_ic, sc->sc_ih);
	return PCMCIA_BUS_UNCONFIG(pc_link->adapter, pc_link);
}

static struct pcmcia_dlink {
	struct pcmcia_device pcd;
} pcmcia_dlink = {
	{"PCMCIA Novell compatible", edmod, ed_pcmcia_isa_attach,
	 NULL, ed_remove}
};

struct pcmciadevs pcmcia_ed_devs[]={
      { "ed", 0, "D-Link", "DE-650", "Ver 01.00", NULL, (void *) -1,
	(void *)&pcmcia_dlink },
      { "ed", 0, "D-Link", "DE-650", "", NULL, (void *) 0x40,
	(void *)&pcmcia_dlink },
      { "ed", 0, "LINKSYS", "E-CARD", "Ver 01.00", NULL, (void *)-1,
        (void *)&pcmcia_dlink },
      { "ed", 0, "IBM Corp.", "Ethernet", "0933495", NULL, (void *) 0xff0,
	(void *)&pcmcia_dlink },
      { "ed", 0, "Socket Communications Inc",
	"Socket EA PCMCIA LAN Adapter Revision D", "Ethernet ID 000000000000",
	NULL, (void *) -1,
	(void *)&pcmcia_dlink },
      /* something screwed up in ports requested */
      { "ed", 0, "SVEC", "FD605 PCMCIA EtherNet Card", "V1-1", NULL,
	(void *)-1, (void *)&pcmcia_dlink },
      { "ed", 0, "Ethernet", "Adapter", "2.0", NULL, (void *) -1,
	(void *)&pcmcia_dlink },
#if 0
      /* not quite right for ethernet address */
      { "ed", 0, "PMX   ", "PE-200", "ETHERNET", "R01", (void *)-1,
        (void *)&pcmcia_dlink },
#endif
      { NULL }
};

#define ned_pcmcia_devs sizeof(pcmcia_ed_devs)/sizeof(pcmcia_ed_devs[0])

int
ed_pcmcia_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return pcmcia_slave_match(parent, match, aux, pcmcia_ed_devs,
				  ned_pcmcia_devs);
}

void
ed_pcmcia_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcmcia_attach_args *paa = aux;
	
	printf("ed_pcmcia_attach %p %p %p\n", parent, self, aux);
	delay(2000000);
	if (!pcmcia_configure(parent, self, paa->paa_link)) {
		struct ed_softc *sc = (void *)self;
		sc->spec_flags |= ED_NOTPRESENT;
		printf(": not attached\n");
	}
}

/*
 * No detach; network devices are too well linked into the rest of the
 * kernel.
 */
int
ed_pcmcia_detach(self)
	struct device *self;
{
	return EBUSY;
}

#endif

#if NED_PCI > 0 

#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#include <dev/pci/pcidevs.h>

#define PCI_CBIO		0x10	/* Configuration Base IO Address */

int	ed_pci_match(struct device *, void *, void *);
void	ed_pci_attach(struct device *, struct device *, void *);

struct cfattach ed_pci_ca = {
	sizeof(struct ed_softc), ed_pci_match, ed_pci_attach
};

static struct ed_pci_devs {
	pci_vendor_id_t vendor;
	pci_product_id_t product;
} ed_pci_devs[] = {
	{ PCI_VENDOR_REALTEK, PCI_PRODUCT_REALTEK_RT8029 },
	{ PCI_VENDOR_WINBOND, PCI_PRODUCT_WINBOND_W89C940F },
	{ PCI_VENDOR_WINBOND2, PCI_PRODUCT_WINBOND2_W89C940 },
	{ PCI_VENDOR_NETVIN, PCI_PRODUCT_NETVIN_NV5000 },
	{ PCI_VENDOR_COMPEX, PCI_PRODUCT_COMPEX_COMPEXE },
	{ PCI_VENDOR_KTI, PCI_PRODUCT_KTI_KTIE },
	{ PCI_VENDOR_SURECOM, PCI_PRODUCT_SURECOM_NE34 },
	{ PCI_VENDOR_VIATECH, PCI_PRODUCT_VIATECH_VT86C926 },
};

int
ed_pci_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pci_attach_args *pa = aux;
	int i;
	
	for (i = 0; i < sizeof(ed_pci_devs)/sizeof(ed_pci_devs[0]); i++)
		if (ed_pci_devs[i].vendor == PCI_VENDOR(pa->pa_id) &&
		    ed_pci_devs[i].product == PCI_PRODUCT(pa->pa_id))
			return (1);
	return (0);
}

/*
 * XXX - Note that we pretend this is a 16bit card until the rest
 * of the driver can deal with a 32bit bus (isa16bit -> bus_width)
 */
void
ed_pci_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ed_softc *sc = (void *)self;
	struct pci_attach_args *pa = aux;
	pci_chipset_tag_t pc = pa->pa_pc;
	pci_intr_handle_t ih;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_addr_t iobase;
	bus_size_t iosize, asicbase, nicbase;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_char romdata[32], tmp;
	const char *intrstr;
	int i;

	iot = pa->pa_iot;

	if (pci_io_find(pc, pa->pa_tag, PCI_CBIO, &iobase, &iosize)) {
		printf("%s: can't find I/O base\n", sc->sc_dev.dv_xname);
		return;
	}

	if (bus_space_map(iot, iobase, iosize, 0, &ioh)) {
		printf("%s: can't map I/O space\n", sc->sc_dev.dv_xname);
		return;
	}

	sc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;
	sc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;
	sc->vendor = ED_VENDOR_NOVELL;
	sc->mem_shared = 0;
	sc->cr_proto = ED_CR_RD2;
	sc->type = ED_TYPE_NE2000;
	sc->type_str = "NE2000";

	/* Reset the board. */
	tmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);

	/* Put the board into 16-bit mode (XXX - someday do 32-bit) */
	sc->isa16bit = 1;
	NIC_PUT(iot, ioh, nicbase, ED_P0_DCR,
	    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);
	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);
	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);

	/*
	 * NIC memory doesn't start at zero on an NE board.
	 * The start address (and size) is tied to the bus width.
	 * XXX - these should be 32K but the driver doesn't grok > 16bit
	 */
	sc->mem_size = 16384;		/* XXX - should be 8K x bus width */
	sc->mem_start = 16384;		/*     - and this as well */
	sc->mem_end = sc->mem_start + sc->mem_size;
	sc->tx_page_start = sc->mem_size >> ED_PAGE_SHIFT;
	sc->txb_cnt = sc->mem_size / 8192;
	sc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;
	sc->rec_page_stop = sc->tx_page_start + (sc->mem_size >> ED_PAGE_SHIFT);
	sc->mem_ring =
	    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);
	sc->sc_delaybah = 0;			/* unused */
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;

	/* Get ethernet address (XXX - size field should be "8 * buswidth") */
	ed_pio_readmem(sc, 0, romdata, sizeof(romdata));
	/* XXX - change to (i * buswidth) when driver does 32bit */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->sc_arpcom.ac_enaddr[i] = romdata[i * 2];

	/* Clear any pending interrupts that might have occurred above. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);

	/* Set interface to stopped condition (reset). */
	edstop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = edstart;
	ifp->if_ioctl = edioctl;
	ifp->if_watchdog = edwatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
	IFQ_SET_READY(&ifp->if_snd);

	/* Attach the interface. */
	if ((sc->spec_flags & ED_REATTACH) == 0)
		if_attach(ifp);
	ether_ifattach(ifp);

	/* Print additional info when attached. */
	printf(": address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	if (sc->type_str)
		printf("type %s ", sc->type_str);
	else
		printf("type unknown (0x%x) ", sc->type);
	printf("%s", sc->isa16bit ? "(16-bit)" : "(8-bit)");	/* XXX */

	/* Map and establish the interrupt. */
	if (pci_intr_map(pa, &ih)) {
		printf("\n%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
		return;
	}
	intrstr = pci_intr_string(pc, ih);
	sc->sc_ih = pci_intr_establish(pc, ih, IPL_NET, edintr,
	    sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("\n%s: couldn't establish interrupt",
		    sc->sc_dev.dv_xname);
		if (intrstr != NULL)
			printf(" at %s", intrstr);
		printf("\n");
		return;
	}
	printf(", %s\n", intrstr);
}

#endif

/*
 * Determine if the device is present.
 */
int
edprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct ed_softc *sc = match;

	return (ed_find(match, sc->sc_dev.dv_cfdata, aux));
}

/*
 * Fill in softc (if given), based on device type, cfdata and attach args.
 * Return 1 if successful, 0 otherwise.
 */
int
ed_find(sc, cf, ia)
	struct ed_softc *sc;
	struct cfdata *cf;
	struct isa_attach_args *ia;
{

	if (ed_find_WD80x3(sc, cf, ia))
		return (1);
	if (ed_find_3Com(sc, cf, ia))
		return (1);
	if (ed_find_Novell(sc, cf, ia))
		return (1);
	return (0);
}

/*
 * Generic probe routine for testing for the existance of a DS8390.  Must be
 * called after the NIC has just been reset.  This routine works by looking at
 * certain register values that are guaranteed to be initialized a certain way
 * after power-up or reset.  Seems not to currently work on the 83C690.
 *
 * Specifically:
 *
 *	Register			reset bits	set bits
 *	Command Register (CR)		TXP, STA	RD2, STP
 *	Interrupt Status (ISR)				RST
 *	Interrupt Mask (IMR)		All bits
 *	Data Control (DCR)				LAS
 *	Transmit Config. (TCR)		LB1, LB0
 *
 * We only look at the CR and ISR registers, however, because looking at the
 * others would require changing register pages (which would be intrusive if
 * this isn't an 8390).
 *
 * Return 1 if 8390 was found, 0 if not.
 */
int
ed_probe_generic8390(t, bah, nicbase)
	bus_space_tag_t t;
	bus_space_handle_t bah;
	int nicbase;
{

	if ((NIC_GET(t, bah, nicbase, ED_P0_CR) &
	     (ED_CR_RD2 | ED_CR_TXP | ED_CR_STA | ED_CR_STP)) !=
	    (ED_CR_RD2 | ED_CR_STP))
		return (0);
	if ((NIC_GET(t, bah, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)
		return (0);

	return (1);
}

int ed_wd584_irq[] = { 9, 3, 5, 7, 10, 11, 15, 4 };
int ed_wd790_irq[] = { IRQUNK, 9, 3, 5, 7, 10, 11, 15 };

/*
 * Probe and vendor-specific initialization routine for SMC/WD80x3 boards.
 */
int
ed_find_WD80x3(sc, cf, ia)
	struct ed_softc *sc;
	struct cfdata *cf;
	struct isa_attach_args *ia;
{
	bus_space_tag_t iot;
	bus_space_tag_t memt;
	bus_space_handle_t ioh;
	bus_space_handle_t delaybah = ia->ia_delaybah;
	bus_space_handle_t memh;
	u_int memsize;
	u_char iptr, isa16bit, sum, wd790rev;
	int i, rv, memfail, mapped_mem = 0;
	int asicbase, nicbase;

	iot = ia->ia_iot;
	memt = ia->ia_memt;
	rv = 0;

	/* Set initial values for width/size. */
	memsize = 8192;
	isa16bit = 0;

	if (bus_space_map(iot, ia->ia_iobase, ED_WD_IO_PORTS, 0, &ioh))
		return (0);

	sc->asic_base = asicbase = 0;
	sc->nic_base = nicbase = asicbase + ED_WD_NIC_OFFSET;
	sc->is790 = 0;

#ifdef TOSH_ETHER
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);
	delay(10000);
#endif

	/*
	 * Attempt to do a checksum over the station address PROM.  If it
	 * fails, it's probably not a SMC/WD board.  There is a problem with
	 * this, though: some clone WD boards don't pass the checksum test.
	 * Danpex boards for one.
	 */
	for (sum = 0, i = 0; i < 8; ++i)
		sum += bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);

	if (sum != ED_WD_ROM_CHECKSUM_TOTAL) {
		/*
		 * Checksum is invalid.  This often happens with cheap WD8003E
		 * clones.  In this case, the checksum byte (the eighth byte)
		 * seems to always be zero.
		 */
		if (bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID) !=
		    ED_TYPE_WD8003E ||
		    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + 7) != 0)
			goto out;
	}

	/* Reset card to force it into a known state. */
#ifdef TOSH_ETHER
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
	    ED_WD_MSR_RST | ED_WD_MSR_POW);
#else
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);
#endif
	delay(100);
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
	    bus_space_read_1(iot, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);
	/* Wait in the case this card is reading its EEROM. */
	delay(5000);

	sc->vendor = ED_VENDOR_WD_SMC;
	sc->type = bus_space_read_1(iot, ioh, asicbase + ED_WD_CARD_ID);

	switch (sc->type) {
	case ED_TYPE_WD8003S:
		sc->type_str = "WD8003S";
		break;
	case ED_TYPE_WD8003E:
		sc->type_str = "WD8003E";
		break;
	case ED_TYPE_WD8003EB:
		sc->type_str = "WD8003EB";
		break;
	case ED_TYPE_WD8003W:
		sc->type_str = "WD8003W";
		break;
	case ED_TYPE_WD8013EBT:
		sc->type_str = "WD8013EBT";
		memsize = 16384;
		isa16bit = 1;
		break;
	case ED_TYPE_WD8013W:
		sc->type_str = "WD8013W";
		memsize = 16384;
		isa16bit = 1;
		break;
	case ED_TYPE_WD8013EP:		/* also WD8003EP */
		if (bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR)
		    & ED_WD_ICR_16BIT) {
			isa16bit = 1;
			memsize = 16384;
			sc->type_str = "WD8013EP";
		} else
			sc->type_str = "WD8003EP";
		break;
	case ED_TYPE_WD8013WC:
		sc->type_str = "WD8013WC";
		memsize = 16384;
		isa16bit = 1;
		break;
	case ED_TYPE_WD8013EBP:
		sc->type_str = "WD8013EBP";
		memsize = 16384;
		isa16bit = 1;
		break;
	case ED_TYPE_WD8013EPC:
		sc->type_str = "WD8013EPC";
		memsize = 16384;
		isa16bit = 1;
		break;
	case ED_TYPE_SMC8216C:
	case ED_TYPE_SMC8216T:
		wd790rev = bus_space_read_1(iot, ioh, asicbase + ED_WD790_REV);
		if (wd790rev < ED_WD795)
			sc->type_str = (sc->type == ED_TYPE_SMC8216C) ?
			    "SMC8216/SMC8216C" : "SMC8216T";
		else {
			sc->type_str = "SMC8416C/SMC8416BT";
			if (bus_space_read_1(iot, ioh,
					     asicbase + ED_WD795_PIO)) {
				printf ("%s: detected SMC8416 in PIO mode, unsupported hardware configuration.\n", sc->sc_dev.dv_xname);
				goto out;
			}
		}

		bus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,
		    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR)
		    | ED_WD790_HWR_SWH);
		switch (bus_space_read_1(iot, ioh, asicbase + ED_WD790_RAR) &
		    ED_WD790_RAR_SZ64) {
		case ED_WD790_RAR_SZ64:
			memsize = 65536;
			break;
		case ED_WD790_RAR_SZ32:
			memsize = 32768;
			break;
		case ED_WD790_RAR_SZ16:
			memsize = 16384;
			break;
		case ED_WD790_RAR_SZ8:
			memsize = 8192;
			break;
		}
		bus_space_write_1(iot, ioh, asicbase + ED_WD790_HWR,
		    bus_space_read_1(iot, ioh, asicbase + ED_WD790_HWR) &
		    ~ED_WD790_HWR_SWH);

		isa16bit = 1;
		sc->is790 = 1;
		break;
#ifdef TOSH_ETHER
	case ED_TYPE_TOSHIBA1:
		sc->type_str = "Toshiba1";
		memsize = 32768;
		isa16bit = 1;
		break;
	case ED_TYPE_TOSHIBA4:
		sc->type_str = "Toshiba4";
		memsize = 32768;
		isa16bit = 1;
		break;
#endif
	default:
		sc->type_str = NULL;
		break;
	}
	/*
	 * Make some adjustments to initial values depending on what is found
	 * in the ICR.
	 */
	if (isa16bit && (sc->type != ED_TYPE_WD8013EBT) &&
#ifdef TOSH_ETHER
	    (sc->type != ED_TYPE_TOSHIBA1) && (sc->type != ED_TYPE_TOSHIBA4) &&
#endif
	    ((bus_space_read_1(iot, ioh, asicbase + ED_WD_ICR) &
	    ED_WD_ICR_16BIT) == 0)) {
		isa16bit = 0;
		memsize = 8192;
	}

#ifdef ED_DEBUG
	printf("type=%x type_str=%s isa16bit=%d memsize=%d id_msize=%d\n",
	    sc->type, sc->type_str ?: "unknown", isa16bit, memsize,
	    ia->ia_msize);
	for (i = 0; i < 8; i++)
		printf("%x -> %x\n", i, bus_space_read_1(iot, ioh,
		    asicbase + i));
#endif
	/* Allow the user to override the autoconfiguration. */
	if (ia->ia_msize)
		memsize = ia->ia_msize;
	/*
	 * (Note that if the user specifies both of the following flags that
	 * '8-bit' mode intentionally has precedence.)
	 */
	if (cf->cf_flags & ED_FLAGS_FORCE_16BIT_MODE)
		isa16bit = 1;
	if (cf->cf_flags & ED_FLAGS_FORCE_8BIT_MODE)
		isa16bit = 0;

	/*
	 * If possible, get the assigned interrupt number from the card and
	 * use it.
	 */
	if (sc->is790) {
		u_char x;

		/* Assemble together the encoded interrupt number. */
		bus_space_write_1(iot, ioh, ED_WD790_HWR,
		    bus_space_read_1(iot, ioh, ED_WD790_HWR) |
		    ED_WD790_HWR_SWH);
		x = bus_space_read_1(iot, ioh, ED_WD790_GCR);
		iptr = ((x & ED_WD790_GCR_IR2) >> 4) |
		    ((x & (ED_WD790_GCR_IR1|ED_WD790_GCR_IR0)) >> 2);
		bus_space_write_1(iot, ioh, ED_WD790_HWR,
		    bus_space_read_1(iot, ioh, ED_WD790_HWR) &
		    ~ED_WD790_HWR_SWH);
		/*
		 * Translate it using translation table, and check for
		 * correctness.
		 */
		if (ia->ia_irq != IRQUNK) {
			if (ia->ia_irq != ed_wd790_irq[iptr]) {
				printf("%s: irq mismatch; kernel configured %d != board configured %d\n",
				    sc->sc_dev.dv_xname, ia->ia_irq,
				    ed_wd790_irq[iptr]);
				goto out;
			}
		} else
			ia->ia_irq = ed_wd790_irq[iptr];
		/* Enable the interrupt. */
		bus_space_write_1(iot, ioh, ED_WD790_ICR,
		    bus_space_read_1(iot, ioh, ED_WD790_ICR) |
		    ED_WD790_ICR_EIL);
	} else if (sc->type & ED_WD_SOFTCONFIG) {
		/* Assemble together the encoded interrupt number. */
		iptr = (bus_space_read_1(iot, ioh, ED_WD_ICR) &
		    ED_WD_ICR_IR2) |
		    ((bus_space_read_1(iot, ioh, ED_WD_IRR) &
		      (ED_WD_IRR_IR0 | ED_WD_IRR_IR1)) >> 5);
		/*
		 * Translate it using translation table, and check for
		 * correctness.
		 */
		if (ia->ia_irq != IRQUNK) {
			if (ia->ia_irq != ed_wd584_irq[iptr]) {
				printf("%s: irq mismatch; kernel configured %d != board configured %d\n",
				    sc->sc_dev.dv_xname, ia->ia_irq,
				    ed_wd584_irq[iptr]);
				goto out;
			}
		} else
			ia->ia_irq = ed_wd584_irq[iptr];
		/* Enable the interrupt. */
		bus_space_write_1(iot, ioh, ED_WD_IRR,
		    bus_space_read_1(iot, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);
	} else {
		if (ia->ia_irq == IRQUNK) {
			printf("%s: %s does not have soft configuration\n",
			    sc->sc_dev.dv_xname, sc->type_str);
			goto out;
		}
	}

	/* XXX Figure out the shared memory address. */

	if (ia->ia_maddr == MADDRUNK)
		goto out;
	sc->isa16bit = isa16bit;
	sc->mem_shared = 1;
	ia->ia_msize = memsize;
	if (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))
		goto out;
	mapped_mem = 1;
	sc->mem_start = 0;	/* offset */

	/* Allocate one xmit buffer if < 16k, two buffers otherwise. */
	if ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))
		sc->txb_cnt = 1;
	else
		sc->txb_cnt = 2;

	sc->tx_page_start = ED_WD_PAGE_OFFSET;
	sc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;
	sc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);
	sc->mem_ring = sc->mem_start + (sc->rec_page_start << ED_PAGE_SHIFT);
	sc->mem_size = memsize;
	sc->mem_end = sc->mem_start + memsize;

	/* Get station address from on-board ROM. */
	for (i = 0; i < ETHER_ADDR_LEN; ++i)
		sc->sc_arpcom.ac_enaddr[i] =
		    bus_space_read_1(iot, ioh, asicbase + ED_WD_PROM + i);

	/*
	 * Set upper address bits and 8/16 bit access to shared memory.
	 */
	if (isa16bit) {
		if (sc->is790) {
			sc->wd_laar_proto =
			    bus_space_read_1(iot, ioh, asicbase + ED_WD_LAAR) &
			    ~ED_WD_LAAR_M16EN;
		} else {
			sc->wd_laar_proto = ED_WD_LAAR_L16EN |
			    ((ia->ia_maddr >> 19) & ED_WD_LAAR_ADDRHI);
		}
		bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
		    sc->wd_laar_proto | ED_WD_LAAR_M16EN);
	} else  {
		if ((sc->type & ED_WD_SOFTCONFIG) ||
#ifdef TOSH_ETHER
		    (sc->type == ED_TYPE_TOSHIBA1) ||
		    (sc->type == ED_TYPE_TOSHIBA4) ||
#endif
		    ((sc->type == ED_TYPE_WD8013EBT) && !sc->is790)) {
			sc->wd_laar_proto =
			    ((ia->ia_maddr >> 19) &
			    ED_WD_LAAR_ADDRHI);
			bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
			    sc->wd_laar_proto);
		}
	}

	/*
	 * Set address and enable interface shared memory.
	 */
	if (!sc->is790) {
#ifdef TOSH_ETHER
		bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 1,
		    ((ia->ia_maddr >> 8) & 0xe0) | 4);
		bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR + 2,
		    ((ia->ia_maddr >> 16) & 0x0f));
		sc->wd_msr_proto = ED_WD_MSR_POW;
#else
		sc->wd_msr_proto =
		    (ia->ia_maddr >> 13) & ED_WD_MSR_ADDR;
#endif
		sc->cr_proto = ED_CR_RD2;
	} else {
		bus_space_write_1(iot, ioh, asicbase + 0x04,
		    bus_space_read_1(iot, ioh, asicbase + 0x04) | 0x80);
		bus_space_write_1(iot, ioh, asicbase + 0x0b,
		    ((ia->ia_maddr >> 13) & 0x0f) |
		    ((ia->ia_maddr >> 11) & 0x40) |
		    (bus_space_read_1(iot, ioh, asicbase + 0x0b) & 0xb0));
		bus_space_write_1(iot, ioh, asicbase + 0x04,
		    bus_space_read_1(iot, ioh, asicbase + 0x04) & ~0x80);
		sc->wd_msr_proto = 0x00;
		sc->cr_proto = 0;
	}
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
	    sc->wd_msr_proto | ED_WD_MSR_MENB);

	(void) bus_space_read_1(iot, delaybah, 0);
	(void) bus_space_read_1(iot, delaybah, 0);

	/* Now zero memory and verify that it is clear. */
	if (isa16bit) {
		for (i = 0; i < memsize; i += 2)
			bus_space_write_2(memt, memh, sc->mem_start + i, 0);
	} else {
		for (i = 0; i < memsize; ++i)
			bus_space_write_1(memt, memh, sc->mem_start + i, 0);
	}

	memfail = 0;
	if (isa16bit) {
		for (i = 0; i < memsize; i += 2) {
			if (bus_space_read_2(memt, memh, sc->mem_start + i)) {
				memfail = 1;
				break;
			}
		}
	} else {
		for (i = 0; i < memsize; ++i) {
			if (bus_space_read_1(memt, memh, sc->mem_start + i)) {
				memfail = 1;
				break;
			}
		}
	}

	if (memfail) {
		printf("%s: failed to clear shared memory at %x - "
		    "check configuration\n",
		    sc->sc_dev.dv_xname,
		    (ia->ia_maddr + sc->mem_start + i));

		/* Disable 16 bit access to shared memory. */
		bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
		    sc->wd_msr_proto);
		if (isa16bit)
			bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
			    sc->wd_laar_proto);
		(void) bus_space_read_1(iot, delaybah, 0);
		(void) bus_space_read_1(iot, delaybah, 0);
		goto out;
	}

	/*
	 * Disable 16bit access to shared memory - we leave it disabled
	 * so that 1) machines reboot properly when the board is set 16
	 * 16 bit mode and there are conflicting 8bit devices/ROMS in
	 * the same 128k address space as this boards shared memory,
	 * and 2) so that other 8 bit devices with shared memory can be
	 * used in this 128k region, too.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);
	if (isa16bit)
		bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
		    sc->wd_laar_proto);
	(void) bus_space_read_1(iot, delaybah, 0);
	(void) bus_space_read_1(iot, delaybah, 0);

	ia->ia_iosize = ED_WD_IO_PORTS;
	rv = 1;

 out:
	/*
	 * XXX Should always unmap, but we can't yet.
	 * XXX Need to squish "indirect" first.
	 */
	if (rv == 0) {
		bus_space_unmap(iot, ioh, ED_WD_IO_PORTS);
		if (mapped_mem)
			bus_space_unmap(memt, memh, memsize);
	} else {
		/* XXX this is all "indirect" brokenness */
		sc->sc_iot = iot;
		sc->sc_memt = memt;
		sc->sc_ioh = ioh;
		sc->sc_memh = memh;
	}
	return (rv);
}

int ed_3com_iobase[] =
    {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};
int ed_3com_maddr[] = {
    MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000
};
#if 0
int ed_3com_irq[] = {IRQUNK, IRQUNK, IRQUNK, IRQUNK, 9, 3, 4, 5};
#endif

/*
 * Probe and vendor-specific initialization routine for 3Com 3c503 boards.
 */
int
ed_find_3Com(sc, cf, ia)
	struct ed_softc *sc;
	struct cfdata *cf;
	struct isa_attach_args *ia;
{
	bus_space_tag_t iot;
	bus_space_tag_t memt;
	bus_space_handle_t ioh;
	bus_space_handle_t memh;
	int i;
	u_int memsize, memfail;
	u_char isa16bit, x;
	int ptr, asicbase, nicbase;

	/*
	 * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window
	 * to it.
	 */
	memsize = 8192;

	iot = ia->ia_iot;
	memt = ia->ia_memt;

	if (bus_space_map(iot, ia->ia_iobase, ED_3COM_IO_PORTS, 0, &ioh))
		return (0);

	sc->asic_base = asicbase = ED_3COM_ASIC_OFFSET;
	sc->nic_base = nicbase = ED_3COM_NIC_OFFSET;

	/*
	 * Verify that the kernel configured I/O address matches the board
	 * configured address.
	 *
	 * This is really only useful to see if something that looks like the
	 * board is there; after all, we are already talking it at that
	 * address.
	 */
	x = bus_space_read_1(iot, ioh, asicbase + ED_3COM_BCFR);
	if (x == 0 || (x & (x - 1)) != 0)
		goto err;
	ptr = ffs(x) - 1;
	if (ia->ia_iobase != IOBASEUNK) {
		if (ia->ia_iobase != ed_3com_iobase[ptr]) {
			printf("%s: %s mismatch; kernel configured %x != board configured %x\n",
			    "iobase", sc->sc_dev.dv_xname, ia->ia_iobase,
			    ed_3com_iobase[ptr]);
			goto err;
		}
	} else
		ia->ia_iobase = ed_3com_iobase[ptr];	/* XXX --thorpej */

	x = bus_space_read_1(iot, ioh, asicbase + ED_3COM_PCFR);
	if (x == 0 || (x & (x - 1)) != 0) {
		printf("%s: The 3c503 is not currently supported with memory "
		       "mapping disabled.\n%s: Reconfigure the card to "
		       "enable memory mapping.\n",
		       sc->sc_dev.dv_xname, sc->sc_dev.dv_xname);
		goto err;
	}
	ptr = ffs(x) - 1;
	if (ia->ia_maddr != MADDRUNK) {
		if (ia->ia_maddr != ed_3com_maddr[ptr]) {
			printf("%s: %s mismatch; kernel configured %x != board configured %x\n",
			    "maddr", sc->sc_dev.dv_xname, ia->ia_maddr,
			    ed_3com_maddr[ptr]);
			goto err;
		}
	} else
		ia->ia_maddr = ed_3com_maddr[ptr];

#if 0
	x = bus_space_read_1(iot, ioh, asicbase + ED_3COM_IDCFR) &
	    ED_3COM_IDCFR_IRQ;
	if (x == 0 || (x & (x - 1)) != 0)
		goto out;
	ptr = ffs(x) - 1;
	if (ia->ia_irq != IRQUNK) {
		if (ia->ia_irq != ed_3com_irq[ptr]) {
			printf("%s: irq mismatch; kernel configured %d != board configured %d\n",
			    sc->sc_dev.dv_xname, ia->ia_irq,
			    ed_3com_irq[ptr]);
			goto err;
		}
	} else
		ia->ia_irq = ed_3com_irq[ptr];
#endif

	/*
	 * Reset NIC and ASIC.  Enable on-board transceiver throughout reset
	 * sequence because it'll lock up if the cable isn't connected if we
	 * don't.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,
	    ED_3COM_CR_RST | ED_3COM_CR_XSEL);

	/* Wait for a while, then un-reset it. */
	delay(50);

	/*
	 * The 3Com ASIC defaults to rather strange settings for the CR after a
	 * reset - it's important to set it again after the following outb
	 * (this is done when we map the PROM below).
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);

	/* Wait a bit for the NIC to recover from the reset. */
	delay(5000);

	sc->vendor = ED_VENDOR_3COM;
	sc->type_str = "3c503";
	sc->mem_shared = 1;
	sc->cr_proto = ED_CR_RD2;

	/*
	 * Get station address from on-board ROM.
	 *
	 * First, map ethernet address PROM over the top of where the NIC
	 * registers normally appear.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,
	    ED_3COM_CR_EALO | ED_3COM_CR_XSEL);

	for (i = 0; i < ETHER_ADDR_LEN; ++i)
		sc->sc_arpcom.ac_enaddr[i] = NIC_GET(iot, ioh, nicbase, i);

	/*
	 * Unmap PROM - select NIC registers.  The proper setting of the
	 * transceiver is set in edinit so that the attach code is given a
	 * chance to set the default based on a compile-time config option.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);

	/* Determine if this is an 8bit or 16bit board. */

	/* Select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);

	/*
	 * Attempt to clear WTS bit.  If it doesn't clear, then this is a
	 * 16-bit board.
	 */
	NIC_PUT(iot, ioh, nicbase, ED_P0_DCR, 0);

	/* Select page 2 registers. */
	NIC_PUT(iot, ioh, nicbase,
	    ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);

	/* The 3c503 forces the WTS bit to a one if this is a 16bit board. */
	if (NIC_GET(iot, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)
		isa16bit = 1;
	else
		isa16bit = 0;

	/* Select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P2_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);

	if (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))
		goto err;
	sc->mem_start = 0;		/* offset */
	sc->mem_size = memsize;
	sc->mem_end = sc->mem_start + memsize;

	/*
	 * We have an entire 8k window to put the transmit buffers on the
	 * 16-bit boards.  But since the 16bit 3c503's shared memory is only
	 * fast enough to overlap the loading of one full-size packet, trying
	 * to load more than 2 buffers can actually leave the transmitter idle
	 * during the load.  So 2 seems the best value.  (Although a mix of
	 * variable-sized packets might change this assumption.  Nonetheless,
	 * we optimize for linear transfers of same-size packets.)
	 */
	if (isa16bit) {
 		if (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING)
			sc->txb_cnt = 1;
		else
			sc->txb_cnt = 2;

		sc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_16BIT;
		sc->rec_page_start = ED_3COM_RX_PAGE_OFFSET_16BIT;
		sc->rec_page_stop =
		    (memsize >> ED_PAGE_SHIFT) + ED_3COM_RX_PAGE_OFFSET_16BIT;
		sc->mem_ring = sc->mem_start;
	} else {
		sc->txb_cnt = 1;
		sc->tx_page_start = ED_3COM_TX_PAGE_OFFSET_8BIT;
		sc->rec_page_start =
		    ED_TXBUF_SIZE + ED_3COM_TX_PAGE_OFFSET_8BIT;
		sc->rec_page_stop =
		    (memsize >> ED_PAGE_SHIFT) + ED_3COM_TX_PAGE_OFFSET_8BIT;
		sc->mem_ring =
		    sc->mem_start + (ED_TXBUF_SIZE << ED_PAGE_SHIFT);
	}

	sc->isa16bit = isa16bit;

	/*
	 * Initialize GA page start/stop registers.  Probably only needed if
	 * doing DMA, but what the Hell.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);

	/* Set IRQ.  3c503 only allows a choice of irq 3-5 or 9. */
	switch (ia->ia_irq) {
	case 9:
		bus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,
		    ED_3COM_IDCFR_IRQ2);
		break;
	case 3:
		bus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,
		    ED_3COM_IDCFR_IRQ3);
		break;
	case 4:
		bus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,
		    ED_3COM_IDCFR_IRQ4);
		break;
	case 5:
		bus_space_write_1(iot, ioh, asicbase + ED_3COM_IDCFR,
		    ED_3COM_IDCFR_IRQ5);
		break;
	default:
		printf("%s: invalid irq configuration (%d) must be 3-5 or 9 for 3c503\n",
		    sc->sc_dev.dv_xname, ia->ia_irq);
		goto out;
	}

	/*
	 * Initialize GA configuration register.  Set bank and enable shared
	 * mem.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_GACFR,
	    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);

	/*
	 * Initialize "Vector Pointer" registers. These gawd-awful things are
	 * compared to 20 bits of the address on ISA, and if they match, the
	 * shared memory is disabled. We set them to 0xffff0...allegedly the
	 * reset vector.
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR2, 0xff);
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR1, 0xff);
	bus_space_write_1(iot, ioh, asicbase + ED_3COM_VPTR0, 0x00);

	/* Now zero memory and verify that it is clear. */
	if (isa16bit) {
		for (i = 0; i < memsize; i += 2)
			bus_space_write_2(memt, memh, sc->mem_start + i, 0);
	} else {
		for (i = 0; i < memsize; ++i)
			bus_space_write_1(memt, memh, sc->mem_start + i, 0);
	}

	memfail = 0;
	if (isa16bit) {
		for (i = 0; i < memsize; i += 2) {
			if (bus_space_read_2(memt, memh, sc->mem_start + i)) {
				memfail = 1;
				break;
			}
		}
	} else {
		for (i = 0; i < memsize; ++i) {
			if (bus_space_read_1(memt, memh, sc->mem_start + i)) {
				memfail = 1;
				break;
			}
		}
	}

	if (memfail) {
		printf("%s: failed to clear shared memory at %x - "
		    "check configuration\n",
		    sc->sc_dev.dv_xname,
		    (ia->ia_maddr + sc->mem_start + i));
		goto out;
	}

	ia->ia_msize = memsize;
	ia->ia_iosize = ED_3COM_IO_PORTS;

	/*
	 * XXX Sould always unmap, but we can't yet.
	 * XXX Need to squish "indirect" first.
	 */
	sc->sc_iot = iot;
	sc->sc_memt = memt;
	sc->sc_ioh = ioh;
	sc->sc_memh = memh;
	return 1;

 out:
	bus_space_unmap(memt, memh, memsize);
 err:
	bus_space_unmap(iot, ioh, ED_3COM_IO_PORTS);
	return 0;
}

/*
 * Probe and vendor-specific initialization routine for NE1000/2000 boards.
 */
int
ed_find_Novell(sc, cf, ia)
	struct ed_softc *sc;
	struct cfdata *cf;
	struct isa_attach_args *ia;
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_int memsize, n;
	u_char romdata[16], tmp;
	static u_char test_pattern[32] = "THIS is A memory TEST pattern";
	u_char test_buffer[32];
	int asicbase, nicbase;

	iot = ia->ia_iot;

	if (bus_space_map(iot, ia->ia_iobase, ED_NOVELL_IO_PORTS, 0, &ioh))
		return (0);

	sc->asic_base = asicbase = ED_NOVELL_ASIC_OFFSET;
	sc->nic_base = nicbase = ED_NOVELL_NIC_OFFSET;

	/* XXX - do Novell-specific probe here */

	/* Reset the board. */
#ifdef GWETHER
	bus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, 0);
	delay(200);
#endif /* GWETHER */
	tmp = bus_space_read_1(iot, ioh, asicbase + ED_NOVELL_RESET);

	/*
	 * I don't know if this is necessary; probably cruft leftover from
	 * Clarkson packet driver code. Doesn't do a thing on the boards I've
	 * tested. -DG [note that a outb(0x84, 0) seems to work here, and is
	 * non-invasive...but some boards don't seem to reset and I don't have
	 * complete documentation on what the 'right' thing to do is...so we do
	 * the invasive thing for now.  Yuck.]
	 */
	bus_space_write_1(iot, ioh, asicbase + ED_NOVELL_RESET, tmp);
	delay(5000);

	/*
	 * This is needed because some NE clones apparently don't reset the NIC
	 * properly (or the NIC chip doesn't reset fully on power-up)
	 * XXX - this makes the probe invasive! ...Done against my better
	 * judgement.  -DLG
	 */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);

	delay(5000);

	/* Make sure that we really have an 8390 based board. */
	if (!ed_probe_generic8390(iot, ioh, nicbase))
		goto out;

	sc->vendor = ED_VENDOR_NOVELL;
	sc->mem_shared = 0;
	sc->cr_proto = ED_CR_RD2;
	ia->ia_msize = 0;

	/*
	 * Test the ability to read and write to the NIC memory.  This has the
	 * side affect of determining if this is an NE1000 or an NE2000.
	 */

	/*
	 * This prevents packets from being stored in the NIC memory when the
	 * readmem routine turns on the start bit in the CR.
	 */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);

	/* Temporarily initialize DCR for byte operations. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);

	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);
	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);

	sc->isa16bit = 0;

	/*
	 * XXX indirect brokenness, used by ed_pio{read,write}mem()
	 */
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;

	/*
	 * Write a test pattern in byte mode.  If this fails, then there
	 * probably isn't any memory at 8k - which likely means that the board
	 * is an NE2000.
	 */
	ed_pio_writemem(sc, test_pattern, 8192, sizeof(test_pattern));
	ed_pio_readmem(sc, 8192, test_buffer, sizeof(test_pattern));

	if (bcmp(test_pattern, test_buffer, sizeof(test_pattern))) {
		/* not an NE1000 - try NE2000 */

		NIC_PUT(iot, ioh, nicbase, ED_P0_DCR,
		    ED_DCR_WTS | ED_DCR_FT1 | ED_DCR_LS);
		NIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);
		NIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);

		sc->isa16bit = 1;

		/*
		 * Write a test pattern in word mode.  If this also fails, then
		 * we don't know what this board is.
		 */
		ed_pio_writemem(sc, test_pattern, 16384, sizeof(test_pattern));
		ed_pio_readmem(sc, 16384, test_buffer, sizeof(test_pattern));

		if (bcmp(test_pattern, test_buffer, sizeof(test_pattern)))
			goto out; /* not an NE2000 either */

		sc->type = ED_TYPE_NE2000;
		sc->type_str = "NE2000";
	} else {
		sc->type = ED_TYPE_NE1000;
		sc->type_str = "NE1000";
	}

	if (ia->ia_irq == IRQUNK) {
		printf("%s: %s does not have soft configuration\n",
		    sc->sc_dev.dv_xname, sc->type_str);
		goto out;
	}

	/* 8k of memory plus an additional 8k if 16-bit. */
	memsize = 8192 + sc->isa16bit * 8192;

#if 0 /* probably not useful - NE boards only come two ways */
	/* Allow kernel config file overrides. */
	if (ia->ia_msize)
		memsize = ia->ia_msize;
#endif

	/* NIC memory doesn't start at zero on an NE board. */
	/* The start address is tied to the bus width. */
	sc->mem_start = (8192 + sc->isa16bit * 8192);
	sc->tx_page_start = memsize >> ED_PAGE_SHIFT;

#ifdef GWETHER
	{
		int x, i, mstart = 0;
		char pbuf0[ED_PAGE_SIZE], pbuf[ED_PAGE_SIZE], tbuf[ED_PAGE_SIZE];

		for (i = 0; i < ED_PAGE_SIZE; i++)
			pbuf0[i] = 0;

		/* Search for the start of RAM. */
		for (x = 1; x < 256; x++) {
			ed_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);
			ed_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);
			if (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {
				for (i = 0; i < ED_PAGE_SIZE; i++)
					pbuf[i] = 255 - x;
				ed_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);
				ed_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);
				if (!bcmp(pbuf, tbuf, ED_PAGE_SIZE)) {
					mstart = x << ED_PAGE_SHIFT;
					memsize = ED_PAGE_SIZE;
					break;
				}
			}
		}

		if (mstart == 0) {
			printf("%s: cannot find start of RAM\n",
			    sc->sc_dev.dv_xname);
			goto err;
		}

		/* Search for the end of RAM. */
		for (++x; x < 256; x++) {
			ed_pio_writemem(sc, pbuf0, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);
			ed_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);
			if (!bcmp(pbuf0, tbuf, ED_PAGE_SIZE)) {
				for (i = 0; i < ED_PAGE_SIZE; i++)
					pbuf[i] = 255 - x;
				ed_pio_writemem(sc, pbuf, x << ED_PAGE_SHIFT, ED_PAGE_SIZE);
				ed_pio_readmem(sc, x << ED_PAGE_SHIFT, tbuf, ED_PAGE_SIZE);
				if (!bcmp(pbuf, tbuf, ED_PAGE_SIZE))
					memsize += ED_PAGE_SIZE;
				else
					break;
			} else
				break;
		}

		printf("%s: RAM start %x, size %d\n",
		    sc->sc_dev.dv_xname, mstart, memsize);

		sc->mem_start = (caddr_t)mstart;
		sc->tx_page_start = mstart >> ED_PAGE_SHIFT;
	}
#endif /* GWETHER */

	sc->mem_size = memsize;
	sc->mem_end = sc->mem_start + memsize;

	/*
	 * Use one xmit buffer if < 16k, two buffers otherwise (if not told
	 * otherwise).
	 */
	if ((memsize < 16384) || (cf->cf_flags & ED_FLAGS_NO_MULTI_BUFFERING))
		sc->txb_cnt = 1;
	else
		sc->txb_cnt = 2;

	sc->rec_page_start = sc->tx_page_start + sc->txb_cnt * ED_TXBUF_SIZE;
	sc->rec_page_stop = sc->tx_page_start + (memsize >> ED_PAGE_SHIFT);

	sc->mem_ring =
	    sc->mem_start + ((sc->txb_cnt * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);

	ed_pio_readmem(sc, 0, romdata, 16);
	for (n = 0; n < ETHER_ADDR_LEN; n++)
		sc->sc_arpcom.ac_enaddr[n] = romdata[n*(sc->isa16bit+1)];

#ifdef GWETHER
	if (sc->arpcom.ac_enaddr[2] == 0x86)
		sc->type_str = "Gateway AT";
#endif /* GWETHER */

	/* Clear any pending interrupts that might have occurred above. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);

	ia->ia_iosize = ED_NOVELL_IO_PORTS;

	/*
	 * XXX Sould always unmap, but we can't yet.
	 * XXX Need to squish "indirect" first.
	 */
	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	/* sc_memh is not used by this driver */
	return 1;
 out:
	bus_space_unmap(iot, ioh, ED_NOVELL_IO_PORTS);

	return 0;
}

/*
 * Install interface into kernel networking data structures.
 */
void
edattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct ed_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int asicbase;

	/*
	 * XXX Should re-map io and mem, but can't
	 * XXX until we squish "indirect" brokenness.
	 */
	iot = sc->sc_iot;		/* XXX */
	ioh = sc->sc_ioh;		/* XXX */

	asicbase = sc->asic_base;
	sc->sc_delaybah = ia->ia_delaybah;

	/* Set interface to stopped condition (reset). */
	edstop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = edstart;
	ifp->if_ioctl = edioctl;
	ifp->if_watchdog = edwatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
	IFQ_SET_READY(&ifp->if_snd);

	/*
	 * Set default state for LINK0 flag (used to disable the transceiver
	 * for AUI operation), based on compile-time config option.
	 */
	switch (sc->vendor) {
	case ED_VENDOR_3COM:
		if (cf->cf_flags & ED_FLAGS_DISABLE_TRANSCEIVER)
			ifp->if_flags |= IFF_LINK0;
		break;
	case ED_VENDOR_WD_SMC:
		if ((sc->type & ED_WD_SOFTCONFIG) == 0)
			break;
		if ((bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR) &
		    ED_WD_IRR_OUT2) == 0)
			ifp->if_flags |= IFF_LINK0;
		break;
	}

	/* Attach the interface. */
	if ((sc->spec_flags & ED_REATTACH) == 0) {
		if_attach(ifp);
		ether_ifattach(ifp);
	}
	ether_ifattach(ifp);

	/* Print additional info when attached. */
	printf(": address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	if (sc->type_str)
		printf("type %s ", sc->type_str);
	else
		printf("type unknown (0x%x) ", sc->type);

	printf("%s", sc->isa16bit ? "(16-bit)" : "(8-bit)");

	switch (sc->vendor) {
	case ED_VENDOR_WD_SMC:
		if ((sc->type & ED_WD_SOFTCONFIG) == 0)
			break;
	case ED_VENDOR_3COM:
		if (ifp->if_flags & IFF_LINK0)
			printf(" aui");
		else
			printf(" bnc");
		break;
	}

	printf("\n");

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, edintr, sc, sc->sc_dev.dv_xname);
	sc->sc_sh = shutdownhook_establish((void (*)(void *))edstop, sc);
}

/*
 * Reset interface.
 */
void
edreset(sc)
	struct ed_softc *sc;
{
	int s;

	s = splnet();
	edstop(sc);
	edinit(sc);
	splx(s);
}

/*
 * Take interface offline.
 */
void
edstop(sc)
	struct ed_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int nicbase = sc->nic_base;
	int n = 5000;

	/* Stop everything on the interface, and select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	/*
	 * Wait for interface to enter stopped state, but limit # of checks to
	 * 'n' (about 5ms).  It shouldn't even take 5us on modern DS8390's, but
	 * just in case it's an old one.
	 */
	while (((NIC_GET(iot, ioh, nicbase,
	    ED_P0_ISR) & ED_ISR_RST) == 0) && --n);
}

/*
 * Device timeout/watchdog routine.  Entered if the device neglects to generate
 * an interrupt after a transmit has been started on it.
 */
void
edwatchdog(ifp)
	struct ifnet *ifp;
{
	struct ed_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	++sc->sc_arpcom.ac_if.if_oerrors;

	edreset(sc);
}

/*
 * Initialize device.
 */
void
edinit(sc)
	struct ed_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int nicbase = sc->nic_base, asicbase = sc->asic_base;
	int i;
	u_int32_t mcaf[2];

	/*
	 * Initialize the NIC in the exact order outlined in the NS manual.
	 * This init procedure is "mandatory"...don't change what or when
	 * things happen.
	 */

	/* Reset transmitter flags. */
	ifp->if_timer = 0;

	sc->txb_inuse = 0;
	sc->txb_new = 0;
	sc->txb_next_tx = 0;

	/* Set interface for page 0, remote DMA complete, stopped. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	if (sc->isa16bit) {
		/*
		 * Set FIFO threshold to 8, No auto-init Remote DMA, byte
		 * order=80x86, word-wide DMA xfers,
		 */
		NIC_PUT(iot, ioh, nicbase, ED_P0_DCR,
		    ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
	} else {
		/* Same as above, but byte-wide DMA xfers. */
		NIC_PUT(iot, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
	}

	/* Clear remote byte count registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, 0);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, 0);

	/* Tell RCR to do nothing for now. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);

	/* Place NIC in internal loopback mode. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);

	/* Set lower bits of byte addressable framing to 0. */
	if (sc->is790)
		NIC_PUT(iot, ioh, nicbase, 0x09, 0);

	/* Initialize receive buffer ring. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);
	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);
	NIC_PUT(iot, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);

	/*
	 * Clear all interrupts.  A '1' in each bit position clears the
	 * corresponding flag.
	 */
	NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, 0xff);

	/*
	 * Enable the following interrupts: receive/transmit complete,
	 * receive/transmit error, and Receiver OverWrite.
	 *
	 * Counter overflow and Remote DMA complete are *not* enabled.
	 */
	NIC_PUT(iot, ioh, nicbase, ED_P0_IMR,
	    ED_IMR_PRXE | ED_IMR_PTXE | ED_IMR_RXEE | ED_IMR_TXEE |
	    ED_IMR_OVWE);

	/* Program command register for page 1. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);

	/* Copy out our station address. */
	for (i = 0; i < ETHER_ADDR_LEN; ++i)
		NIC_PUT(iot, ioh, nicbase, ED_P1_PAR0 + i,
		    sc->sc_arpcom.ac_enaddr[i]);

	/* Set multicast filter on chip. */
	ed_getmcaf(&sc->sc_arpcom, mcaf);
	for (i = 0; i < 8; i++)
		NIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i,
		    ((u_char *)mcaf)[i]);

	/*
	 * Set current page pointer to one page after the boundary pointer, as
	 * recommended in the National manual.
	 */
	sc->next_packet = sc->rec_page_start + 1;
	NIC_PUT(iot, ioh, nicbase, ED_P1_CURR, sc->next_packet);

	/* Program command register for page 0. */
	NIC_PUT(iot, ioh, nicbase, ED_P1_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);

	i = ED_RCR_AB | ED_RCR_AM;
	if (ifp->if_flags & IFF_PROMISC) {
		/*
		 * Set promiscuous mode.  Multicast filter was set earlier so
		 * that we should receive all multicast packets.
		 */
		i |= ED_RCR_PRO | ED_RCR_AR | ED_RCR_SEP;
	}
	NIC_PUT(iot, ioh, nicbase, ED_P0_RCR, i);

	/* Take interface out of loopback. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_TCR, 0);

	/*
	 * If this is a 3Com board, the transceiver must be software enabled
	 * (there is no settable hardware default).
	 */
	switch (sc->vendor) {
		u_char x;
	case ED_VENDOR_3COM:
		if (ifp->if_flags & IFF_LINK0)
			bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR, 0);
		else
			bus_space_write_1(iot, ioh, asicbase + ED_3COM_CR,
			    ED_3COM_CR_XSEL);
		break;
	case ED_VENDOR_WD_SMC:
		if ((sc->type & ED_WD_SOFTCONFIG) == 0)
			break;
		x = bus_space_read_1(iot, ioh, asicbase + ED_WD_IRR);
		if (ifp->if_flags & IFF_LINK0)
			x &= ~ED_WD_IRR_OUT2;
		else
			x |= ED_WD_IRR_OUT2;
		bus_space_write_1(iot, ioh, asicbase + ED_WD_IRR, x);
		break;
	}

	/* Fire up the interface. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	/* Set 'running' flag, and clear output active flag. */
	ifp->if_flags |= IFF_RUNNING;
	ifp->if_flags &= ~IFF_OACTIVE;

	/* ...and attempt to start output. */
	edstart(ifp);
}

/*
 * This routine actually starts the transmission on the interface.
 */
static __inline void
ed_xmit(sc)
	struct ed_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int nicbase = sc->nic_base;
	u_int16_t len;

	len = sc->txb_len[sc->txb_next_tx];

	/* Set NIC for page 0 register access. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	/* Set TX buffer start page. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +
	    sc->txb_next_tx * ED_TXBUF_SIZE);

	/* Set TX length. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_TBCR0, len);
	NIC_PUT(iot, ioh, nicbase, ED_P0_TBCR1, len >> 8);

	/* Set page 0, remote DMA complete, transmit packet, and *start*. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);

	/* Point to next transmit buffer slot and wrap if necessary. */
	sc->txb_next_tx++;
	if (sc->txb_next_tx == sc->txb_cnt)
		sc->txb_next_tx = 0;

	/* Set a timer just in case we never hear from the board again. */
	ifp->if_timer = 2;
}

/*
 * Start output on interface.
 * We make two assumptions here:
 *  1) that the current priority is set to splnet _before_ this code
 *     is called *and* is returned to the appropriate priority after
 *     return
 *  2) that the IFF_OACTIVE flag is checked before this code is called
 *     (i.e. that the output part of the interface is idle)
 */
void
edstart(ifp)
	struct ifnet *ifp;
{
	struct ed_softc *sc = ifp->if_softc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct mbuf *m0, *m;
	int buffer;
	int asicbase = sc->asic_base;
	int len;

	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
		return;

outloop:
	/* See if there is room to put another packet in the buffer. */
	if (sc->txb_inuse == sc->txb_cnt) {
		/* No room.  Indicate this to the outside world and exit. */
		ifp->if_flags |= IFF_OACTIVE;
		return;
	}

	IFQ_DEQUEUE(&ifp->if_snd, m0);
	if (m0 == 0)
		return;

	/* We need to use m->m_pkthdr.len, so require the header */
	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("edstart: no header mbuf");

#if NBPFILTER > 0
	/* Tap off here if there is a BPF listener. */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	/* txb_new points to next open buffer slot. */
	buffer = sc->mem_start +
	    ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);

	if (sc->mem_shared) {
		/* Special case setup for 16 bit boards... */
		switch (sc->vendor) {
		/*
		 * For 16bit 3Com boards (which have 16k of memory), we
		 * have the xmit buffers in a different page of memory
		 * ('page 0') - so change pages.
		 */
		case ED_VENDOR_3COM:
			if (sc->isa16bit)
				bus_space_write_1(iot, ioh,
				    asicbase + ED_3COM_GACFR,
				    ED_3COM_GACFR_RSEL);
			break;
		/*
		 * Enable 16bit access to shared memory on WD/SMC
		 * boards.
		 */
		case ED_VENDOR_WD_SMC:
			if (sc->isa16bit)
				bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
				    sc->wd_laar_proto | ED_WD_LAAR_M16EN);
			bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
			    sc->wd_msr_proto | ED_WD_MSR_MENB);
			(void) bus_space_read_1(iot, sc->sc_delaybah, 0);
			(void) bus_space_read_1(iot, sc->sc_delaybah, 0);
			break;
		}

		for (m = m0; m != 0; m = m->m_next) {
			ed_shared_writemem(sc, mtod(m, caddr_t), buffer,
			    m->m_len);
			buffer += m->m_len;
		}
		len = m0->m_pkthdr.len;

		/* Restore previous shared memory access. */
		switch (sc->vendor) {
		case ED_VENDOR_3COM:
			if (sc->isa16bit)
				bus_space_write_1(iot, ioh,
				    asicbase + ED_3COM_GACFR,
				    ED_3COM_GACFR_RSEL | ED_3COM_GACFR_MBS0);
			break;
		case ED_VENDOR_WD_SMC:
			bus_space_write_1(iot, ioh, asicbase + ED_WD_MSR,
			    sc->wd_msr_proto);
			if (sc->isa16bit)
				bus_space_write_1(iot, ioh, asicbase + ED_WD_LAAR,
				    sc->wd_laar_proto);
			(void) bus_space_read_1(iot, sc->sc_delaybah, 0);
			(void) bus_space_read_1(iot, sc->sc_delaybah, 0);
			break;
		}
	} else
		len = ed_pio_write_mbufs(sc, m0, (u_int16_t)buffer);

	m_freem(m0);
	sc->txb_len[sc->txb_new] = max(len, ETHER_MIN_LEN);

	/* Start the first packet transmitting. */
	if (sc->txb_inuse == 0)
		ed_xmit(sc);

	/* Point to next buffer slot and wrap if necessary. */
	if (++sc->txb_new == sc->txb_cnt)
		sc->txb_new = 0;
	sc->txb_inuse++;

	/* Loop back to the top to possibly buffer more packets. */
	goto outloop;
}

/*
 * Ethernet interface receiver interrupt.
 */
static __inline void
ed_rint(sc)
	struct ed_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int nicbase = sc->nic_base;
	u_int8_t boundary, current;
	u_int16_t len;
	u_int8_t nlen;
	u_int8_t next_packet;		/* pointer to next packet */
	u_int16_t count;		/* bytes in packet (length + 4) */
	u_int8_t packet_hdr[ED_RING_HDRSZ];
	int packet_ptr;

loop:
	/* Set NIC to page 1 registers to get 'current' pointer. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);

	/*
	 * 'sc->next_packet' is the logical beginning of the ring-buffer - i.e.
	 * it points to where new data has been buffered.  The 'CURR' (current)
	 * register points to the logical end of the ring-buffer - i.e. it
	 * points to where additional new data will be added.  We loop here
	 * until the logical beginning equals the logical end (or in other
	 * words, until the ring-buffer is empty).
	 */
	current = NIC_GET(iot, ioh, nicbase, ED_P1_CURR);
	if (sc->next_packet == current)
		return;

	/* Set NIC to page 0 registers to update boundary register. */
	NIC_PUT(iot, ioh, nicbase, ED_P1_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	do {
		/* Get pointer to this buffer's header structure. */
		packet_ptr = sc->mem_ring +
		    ((sc->next_packet - sc->rec_page_start) << ED_PAGE_SHIFT);

		/*
		 * The byte count includes a 4 byte header that was added by
		 * the NIC.
		 */
		if (sc->mem_shared)
			ed_shared_readmem(sc, packet_ptr, packet_hdr,
			    sizeof(packet_hdr));
		else
			ed_pio_readmem(sc, (u_int16_t)packet_ptr, packet_hdr,
			    sizeof(packet_hdr));
		next_packet = packet_hdr[ED_RING_NEXT_PACKET];
		len = count = packet_hdr[ED_RING_COUNT] +
		    256 * packet_hdr[ED_RING_COUNT + 1];

		/*
		 * Try do deal with old, buggy chips that sometimes duplicate
		 * the low byte of the length into the high byte.  We do this
		 * by simply ignoring the high byte of the length and always
		 * recalculating it.
		 *
		 * NOTE: sc->next_packet is pointing at the current packet.
		 */
		if (next_packet >= sc->next_packet)
			nlen = (next_packet - sc->next_packet);
		else
			nlen = ((next_packet - sc->rec_page_start) +
				(sc->rec_page_stop - sc->next_packet));
		--nlen;
		if ((len & ED_PAGE_MASK) + sizeof(packet_hdr) > ED_PAGE_SIZE)
			--nlen;
		len = (len & ED_PAGE_MASK) | (nlen << ED_PAGE_SHIFT);
#ifdef DIAGNOSTIC
		if (len != count) {
			printf("%s: length does not match next packet pointer\n",
			    sc->sc_dev.dv_xname);
			printf("%s: len %04x nlen %04x start %02x first %02x curr %02x next %02x stop %02x\n",
			    sc->sc_dev.dv_xname, count, len,
			    sc->rec_page_start, sc->next_packet, current,
			    next_packet, sc->rec_page_stop);
		}
#endif

		/*
		 * Be fairly liberal about what we allow as a "reasonable"
		 * length so that a [crufty] packet will make it to BPF (and
		 * can thus be analyzed).  Note that all that is really
		 * important is that we have a length that will fit into one
		 * mbuf cluster or less; the upper layer protocols can then
		 * figure out the length from their own length field(s).
		 */
		if (len <= MCLBYTES &&
		    next_packet >= sc->rec_page_start &&
		    next_packet < sc->rec_page_stop) {
			/* Go get packet. */
			edread(sc, packet_ptr + ED_RING_HDRSZ,
			    len - ED_RING_HDRSZ);
		} else {
			/* Really BAD.  The ring pointers are corrupted. */
			log(LOG_ERR,
			    "%s: NIC memory corrupt - invalid packet length %d\n",
			    sc->sc_dev.dv_xname, len);
			++sc->sc_arpcom.ac_if.if_ierrors;
			edreset(sc);
			return;
		}

		/* Update next packet pointer. */
		sc->next_packet = next_packet;

		/*
		 * Update NIC boundary pointer - being careful to keep it one
		 * buffer behind (as recommended by NS databook).
		 */
		boundary = sc->next_packet - 1;
		if (boundary < sc->rec_page_start)
			boundary = sc->rec_page_stop - 1;
		NIC_PUT(iot, ioh, nicbase, ED_P0_BNRY, boundary);
	} while (sc->next_packet != current);

	goto loop;
}

/* Ethernet interface interrupt processor. */
int
edintr(arg)
	void *arg;
{
	struct ed_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int nicbase = sc->nic_base, asicbase = sc->asic_base;
	u_char isr;

	/* Set NIC to page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

	isr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);
	if (!isr)
		return (0);

	/* Loop until there are no more new interrupts. */
	for (;;) {
		/*
		 * Reset all the bits that we are 'acknowledging' by writing a
		 * '1' to each bit position that was set.
		 * (Writing a '1' *clears* the bit.)
		 */
		NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, isr);

		/*
		 * Handle transmitter interrupts.  Handle these first because
		 * the receiver will reset the board under some conditions.
		 */
		if (isr & (ED_ISR_PTX | ED_ISR_TXE)) {
			u_char collisions = NIC_GET(iot, ioh, nicbase,
			    ED_P0_NCR) & 0x0f;

			/*
			 * Check for transmit error.  If a TX completed with an
			 * error, we end up throwing the packet away.  Really
			 * the only error that is possible is excessive
			 * collisions, and in this case it is best to allow the
			 * automatic mechanisms of TCP to backoff the flow.  Of
			 * course, with UDP we're screwed, but this is expected
			 * when a network is heavily loaded.
			 */
			(void) NIC_GET(iot, ioh, nicbase, ED_P0_TSR);
			if (isr & ED_ISR_TXE) {
				/*
				 * Excessive collisions (16).
				 */
				if ((NIC_GET(iot, ioh, nicbase, ED_P0_TSR) &
				    ED_TSR_ABT) && (collisions == 0)) {
					/*
					 * When collisions total 16, the P0_NCR
					 * will indicate 0, and the TSR_ABT is
					 * set.
					 */
					collisions = 16;
				}

				/* Update output errors counter. */
				++ifp->if_oerrors;
			} else {
				/*
				 * Update total number of successfully
				 * transmitted packets.
				 */
				++ifp->if_opackets;
			}

			/* Done with the buffer. */
			sc->txb_inuse--;

			/* Clear watchdog timer. */
			ifp->if_timer = 0;
			ifp->if_flags &= ~IFF_OACTIVE;

			/*
			 * Add in total number of collisions on last
			 * transmission.
			 */
			ifp->if_collisions += collisions;

			/*
			 * Decrement buffer in-use count if not zero (can only
			 * be zero if a transmitter interrupt occurred while not
			 * actually transmitting).
			 * If data is ready to transmit, start it transmitting,
			 * otherwise defer until after handling receiver.
			 */
			if (sc->txb_inuse > 0)
				ed_xmit(sc);
		}

		/* Handle receiver interrupts. */
		if (isr & (ED_ISR_PRX | ED_ISR_RXE | ED_ISR_OVW)) {
			/*
			 * Overwrite warning.  In order to make sure that a
			 * lockup of the local DMA hasn't occurred, we reset
			 * and re-init the NIC.  The NSC manual suggests only a
			 * partial reset/re-init is necessary - but some chips
			 * seem to want more.  The DMA lockup has been seen
			 * only with early rev chips - Methinks this bug was
			 * fixed in later revs.  -DG
			 */
			if (isr & ED_ISR_OVW) {
				++ifp->if_ierrors;
#ifdef DIAGNOSTIC
				log(LOG_WARNING,
				    "%s: warning - receiver ring buffer overrun\n",
				    sc->sc_dev.dv_xname);
#endif
				/* Stop/reset/re-init NIC. */
				edreset(sc);
			} else {
				/*
				 * Receiver Error.  One or more of: CRC error,
				 * frame alignment error FIFO overrun, or
				 * missed packet.
				 */
				if (isr & ED_ISR_RXE) {
					++ifp->if_ierrors;
#ifdef ED_DEBUG
					printf("%s: receive error %x\n",
					    sc->sc_dev.dv_xname,
					    NIC_GET(iot,ioh,nicbase,ED_P0_RSR));
#endif
				}

				/*
				 * Go get the packet(s).
				 * XXX - Doing this on an error is dubious
				 * because there shouldn't be any data to get
				 * (we've configured the interface to not
				 * accept packets with errors).
				 */

				/*
				 * Enable 16bit access to shared memory first
				 * on WD/SMC boards.
				 */
				if (sc->vendor == ED_VENDOR_WD_SMC) {
					if (sc->isa16bit)
						bus_space_write_1(iot, ioh,
						    asicbase + ED_WD_LAAR,
						    sc->wd_laar_proto |
						    ED_WD_LAAR_M16EN);
					bus_space_write_1(iot, ioh,
					    asicbase + ED_WD_MSR,
					    sc->wd_msr_proto | ED_WD_MSR_MENB);
					(void) bus_space_read_1(iot,
					    sc->sc_delaybah, 0);
					(void) bus_space_read_1(iot,
					    sc->sc_delaybah, 0);
				}

				ed_rint(sc);

				/* Disable 16-bit access. */
				if (sc->vendor == ED_VENDOR_WD_SMC) {
					bus_space_write_1(iot, ioh,
					    asicbase + ED_WD_MSR,
					    sc->wd_msr_proto);
					if (sc->isa16bit)
						bus_space_write_1(iot, ioh,
						    asicbase + ED_WD_LAAR,
						    sc->wd_laar_proto);
					(void) bus_space_read_1(iot,
					    sc->sc_delaybah, 0);
					(void) bus_space_read_1(iot,
					    sc->sc_delaybah, 0);
				}
			}
		}

		/*
		 * If it looks like the transmitter can take more data,	attempt
		 * to start output on the interface.  This is done after
		 * handling the receiver to give the receiver priority.
		 */
		edstart(ifp);

		/*
		 * Return NIC CR to standard state: page 0, remote DMA
		 * complete, start (toggling the TXP bit off, even if was just
		 * set in the transmit routine, is *okay* - it is 'edge'
		 * triggered from low to high).
		 */
		NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
		    sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);

		/*
		 * If the Network Talley Counters overflow, read them to reset
		 * them.  It appears that old 8390's won't clear the ISR flag
		 * otherwise - resulting in an infinite loop.
		 */
		if (isr & ED_ISR_CNT) {
			(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR0);
			(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR1);
			(void) NIC_GET(iot, ioh, nicbase, ED_P0_CNTR2);
		}

		isr = NIC_GET(iot, ioh, nicbase, ED_P0_ISR);
		if (!isr)
			return (1);
	}
}

/*
 * Process an ioctl request.  This code needs some work - it looks pretty ugly.
 */
int
edioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ed_softc *sc = ifp->if_softc;
	register struct ifaddr *ifa = (struct ifaddr *)data;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();
	if ((sc->spec_flags & ED_NOTPRESENT) != 0) {
		if_down(ifp);
		printf("%s: device offline\n", sc->sc_dev.dv_xname);
		splx(s);
		return ENXIO;		/* may be ignored, oh well. */
	}

	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

	switch (cmd) {

	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			edinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
#endif
		default:
			edinit(sc);
			break;
		}
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			edstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			edinit(sc);
		} else {
			/*
			 * Reset the interface to pick up changes in any other
			 * flags that affect hardware registers.
			 */
			edstop(sc);
			edinit(sc);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		/* Update our multicast list. */
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware filter
			 * accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING) {
				edstop(sc);	/* XXX for ds_setmcaf? */
				edinit(sc);
			}
			error = 0;
		}
		break;

	default:
		error = EINVAL;
		break;
	}

	splx(s);
	return (error);
}

/*
 * Retreive packet from shared memory and send to the next level up via
 * ether_input_mbuf().  If there is a BPF listener, give a copy to BPF, too.
 */
void
edread(sc, buf, len)
	struct ed_softc *sc;
	int buf, len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *m;

	/* Pull packet off interface. */
	m = edget(sc, buf, len);
	if (m == 0) {
		ifp->if_ierrors++;
		return;
	}

	ifp->if_ipackets++;

#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
}

/*
 * Supporting routines.
 */

/*
 * Given a NIC memory source address and a host memory destination address,
 * copy 'amount' from NIC to host using Programmed I/O.  The 'amount' is
 * rounded up to a word - okay as long as mbufs are word sized.
 * This routine is currently Novell-specific.
 */
void
ed_pio_readmem(sc, src, dst, amount)
	struct ed_softc *sc;
	u_int16_t src;
	caddr_t dst;
	u_int16_t amount;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int nicbase = sc->nic_base;

	/* Select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);

	/* Round up to a word. */
	if (amount & 1)
		++amount;

	/* Set up DMA byte count. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, amount);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, amount >> 8);

	/* Set up source address in NIC mem. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, src);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, src >> 8);

	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);

	if (sc->isa16bit)
		bus_space_read_raw_multi_2(iot, ioh,
		    sc->asic_base + ED_NOVELL_DATA, dst, amount);
	else
		bus_space_read_multi_1(iot, ioh,
		    sc->asic_base + ED_NOVELL_DATA, dst, amount);
}

/*
 * Stripped down routine for writing a linear buffer to NIC memory.  Only used
 * in the probe routine to test the memory.  'len' must be even.
 */
void
ed_pio_writemem(sc, src, dst, len)
	struct ed_softc *sc;
	caddr_t src;
	u_int16_t dst;
	u_int16_t len;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int nicbase = sc->nic_base;
	int maxwait = 100; /* about 120us */

	/* Select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);

	/* Reset remote DMA complete flag. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);

	/* Set up DMA byte count. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);

	/* Set up destination address in NIC mem. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);

	/* Set remote DMA write. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);

	if (sc->isa16bit)
		bus_space_write_raw_multi_2(iot, ioh,
		    sc->asic_base + ED_NOVELL_DATA, src, len);
	else
		bus_space_write_multi_1(iot, ioh,
		    sc->asic_base + ED_NOVELL_DATA, src, len);

	/*
	 * Wait for remote DMA complete.  This is necessary because on the
	 * transmit side, data is handled internally by the NIC in bursts and
	 * we can't start another remote DMA until this one completes.  Not
	 * waiting causes really bad things to happen - like the NIC
	 * irrecoverably jamming the ISA bus.
	 */
	while (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=
	    ED_ISR_RDC) && --maxwait);
}

/*
 * Write an mbuf chain to the destination NIC memory address using programmed
 * I/O.
 */
u_int16_t
ed_pio_write_mbufs(sc, m, dst)
	struct ed_softc *sc;
	struct mbuf *m;
	u_int16_t dst;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int nicbase = sc->nic_base, asicbase = sc->asic_base;
	u_int16_t len;
	int maxwait = 100; /* about 120us */

	len = m->m_pkthdr.len;

	/* Select page 0 registers. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);

	/* Reset remote DMA complete flag. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);

	/* Set up DMA byte count. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR0, len);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RBCR1, len >> 8);

	/* Set up destination address in NIC mem. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(iot, ioh, nicbase, ED_P0_RSAR1, dst >> 8);

	/* Set remote DMA write. */
	NIC_PUT(iot, ioh, nicbase, ED_P0_CR,
	    ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);

	/*
	 * Transfer the mbuf chain to the NIC memory.
	 * 16-bit cards require that data be transferred as words, and only
	 * words, so that case requires some extra code to patch over
	 * odd-length mbufs.
	 */
	if (!sc->isa16bit) {
		/* NE1000s are easy. */
		for (; m != 0; m = m->m_next) {
			if (m->m_len) {
				bus_space_write_multi_1(iot, ioh,
				    asicbase + ED_NOVELL_DATA,
				    mtod(m, u_char *), m->m_len);
			}
		}
	} else {
		/* NE2000s are a bit trickier. */
		u_int8_t *data, savebyte[2];
		int len, wantbyte;

		wantbyte = 0;
		for (; m != 0; m = m->m_next) {
			len = m->m_len;
			if (len == 0)
				continue;
			data = mtod(m, u_int8_t *);
			/* Finish the last word. */
			if (wantbyte) {
				savebyte[1] = *data;
				bus_space_write_raw_multi_2(iot, ioh,
				    asicbase + ED_NOVELL_DATA, savebyte, 2);
				data++;
				len--;
				wantbyte = 0;
			}
			/* Output contiguous words. */
			if (len > 1) {
				bus_space_write_raw_multi_2(iot, ioh,
				    asicbase + ED_NOVELL_DATA, data, len & ~1);
			}
			/* Save last byte, if necessary. */
			if (len & 1) {
				data += len & ~1;
				savebyte[0] = *data;
				wantbyte = 1;
			}
		}

		if (wantbyte) {
			savebyte[1] = 0;
			bus_space_write_raw_multi_2(iot, ioh,
			    asicbase + ED_NOVELL_DATA, savebyte, 2);
		}
	}

	/*
	 * Wait for remote DMA complete.  This is necessary because on the
	 * transmit side, data is handled internally by the NIC in bursts and
	 * we can't start another remote DMA until this one completes. 	Not
	 * waiting causes really bad things to happen - like the NIC
	 * irrecoverably jamming the ISA bus.
	 */
	while (((NIC_GET(iot, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=
	    ED_ISR_RDC) && --maxwait);

	if (!maxwait) {
		log(LOG_WARNING,
		    "%s: remote transmit DMA failed to complete\n",
		    sc->sc_dev.dv_xname);
		edreset(sc);
	}

	return (len);
}

/*
 * Given a source and destination address, copy 'amount' of a packet from the
 * ring buffer into a linear destination buffer.  Takes into account ring-wrap.
 */
static __inline int
ed_ring_copy(sc, src, dst, amount)
	struct ed_softc *sc;
	int src;
	caddr_t dst;
	u_int16_t amount;
{
	u_int16_t tmp_amount;

	/* Does copy wrap to lower addr in ring buffer? */
	if (src + amount > sc->mem_end) {
		tmp_amount = sc->mem_end - src;

		/* Copy amount up to end of NIC memory. */
		if (sc->mem_shared)
			ed_shared_readmem(sc, src, dst, tmp_amount);
		else
			ed_pio_readmem(sc, (u_int16_t)src, dst, tmp_amount);

		amount -= tmp_amount;
		src = sc->mem_ring;
		dst += tmp_amount;
	}

	if (sc->mem_shared)
		ed_shared_readmem(sc, src, dst, amount);
	else
		ed_pio_readmem(sc, (u_int16_t)src, dst, amount);

	return (src + amount);
}

/*
 * Copy data from receive buffer to end of mbuf chain allocate additional mbufs
 * as needed.  Return pointer to last mbuf in chain.
 * sc = ed info (softc)
 * src = pointer in ed ring buffer
 * totlen = maximum packet size
 */
struct mbuf *
edget(sc, src, totlen)
	struct ed_softc *sc;
	int src;
	int totlen;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf *top, **mp, *m;
	int len, pad;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == 0)
		return 0;

	m->m_pkthdr.rcvif = ifp;
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN - pad;
	top = 0;
	mp = &top;

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == 0) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		src = ed_ring_copy(sc, src, mtod(m, caddr_t), len);
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	return top;
}

/*
 * Compute the multicast address filter from the list of multicast addresses we
 * need to listen to.
 */
void
ed_getmcaf(ac, af)
	struct arpcom *ac;
	u_int32_t *af;
{
	struct ifnet *ifp = &ac->ac_if;
	struct ether_multi *enm;
	register u_int32_t crc;
	register int i;
	struct ether_multistep step;

	/*
	 * Set up multicast address filter by passing all multicast addresses
	 * through a crc generator, and then using the high order 6 bits as an
	 * index into the 64 bit logical address filter.  The high order bit
	 * selects the word, while the rest of the bits select the bit within
	 * the word.
	 */

	if (ifp->if_flags & IFF_PROMISC) {
		ifp->if_flags |= IFF_ALLMULTI;
		af[0] = af[1] = 0xffffffff;
		return;
	}

	af[0] = af[1] = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (bcmp(enm->enm_addrlo, enm->enm_addrhi,
		    sizeof(enm->enm_addrlo)) != 0) {
			/*
			 * We must listen to a range of multicast addresses.
			 * For now, just accept all multicasts, rather than
			 * trying to set only those filter bits needed to match
			 * the range.  (At this time, the only use of address
			 * ranges is for IP multicast routing, for which the
			 * range is big enough to require all bits set.)
			 */
			ifp->if_flags |= IFF_ALLMULTI;
			af[0] = af[1] = 0xffffffff;
			return;
		}

		/* Just want the 6 most significant bits. */
		crc = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;

		/* Turn on the corresponding bit in the filter. */
		af[crc >> 5] |= 1 << ((crc & 0x1f) ^ 0);

		ETHER_NEXT_MULTI(step, enm);
	}
	ifp->if_flags &= ~IFF_ALLMULTI;
}

void
ed_shared_writemem(sc, from, card, len)
	struct ed_softc *sc;
	caddr_t from;
	int card, len;
{
	bus_space_tag_t memt = sc->sc_memt;
	bus_space_handle_t memh = sc->sc_memh;
	u_int16_t word;

	/*
	 * For 16-bit cards, 16-bit memory access has already
	 * been set up.  Note that some cards are really picky
	 * about enforcing 16-bit access to memory, so we
	 * have to be careful.
	 */
	if (sc->isa16bit) {
		/*
		 * If writing to an odd location, we need to align first.
		 * This requires a read-modify-write cycle as we should
		 * keep accesses 16-bit wide.
		 */
		if (len > 0 && (card & 1)) {
			word = bus_space_read_2(memt, memh, card & ~1);
			word = (word & 0xff) | (*from << 8);
			bus_space_write_2(memt, memh, card & ~1, word);
			from++;
			card++;
			len--;
		}
		/* XXX I think maybe a bus_space_write_raw_region is needed. */
		while (len > 1) {
			word = (u_int8_t)from[0] | (u_int8_t)from[1] << 8;
			bus_space_write_2(memt, memh, card, word);
			from += 2;
			card += 2;
			len -= 2;
		}
		if (len == 1) {
			word = *from;
			bus_space_write_2(memt, memh, card, word);
		}
	} else {
		while (len--)
			bus_space_write_1(memt, memh, card++, *from++);
	}
}

void
ed_shared_readmem(sc, card, to, len)
	struct ed_softc *sc;
	caddr_t to;
	int card, len;
{
	bus_space_tag_t memt = sc->sc_memt;
	bus_space_handle_t memh = sc->sc_memh;
	u_int16_t word;

	/*
	 * See comment above re. 16-bit cards.
	 */
	if (sc->isa16bit) {
		/* XXX I think maybe a bus_space_read_raw_region is needed.  */
		while (len > 1) {
			word = bus_space_read_2(memt, memh, card);
			*to++ = word & 0xff;
			*to++ = word >> 8 & 0xff;
			card += 2;
			len -= 2;
		}
		if (len == 1)
			*to = bus_space_read_2(memt, memh, card) & 0xff;
	} else {
		while (len--)
			*to++ = bus_space_read_1(memt, memh, card++);
	}
}
@


1.58
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.57 2006/05/22 20:35:12 krw Exp $	*/
@


1.57
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.56 2006/03/25 22:41:44 djm Exp $	*/
d681 1
a681 1
	/* Wait in the case this card is reading it's EEROM. */
@


1.56
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.55 2005/04/03 10:20:47 brad Exp $	*/
d285 2
a286 1
	shutdownhook_disestablish(sc->sc_sh);
@


1.55
log
@fix comment
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.54 2005/01/15 05:24:11 brad Exp $	*/
d2004 1
a2004 1
		bpf_mtap(ifp->if_bpf, m0);
d2546 1
a2546 1
		bpf_mtap(ifp->if_bpf, m);
@


1.54
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.53 2004/06/06 17:56:36 mcbride Exp $	*/
d2521 1
a2521 1
 * ether_input().  If there is a BPF listener, give a copy to BPF, too.
@


1.53
log
@Multicast cleanups
- make multicast ranges work
- replace handrolled crc code with ether_crc32_{be,le}()
- add missing calls to ether_{add,del}multi()

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.52 2004/05/12 06:35:10 tedu Exp $	*/
d2502 4
a2505 2
			edstop(sc); /* XXX for ds_setmcaf? */
			edinit(sc);
@


1.52
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.51 2003/11/07 10:16:45 jmc Exp $	*/
a2862 1
	register u_char *cp, c;
d2864 1
a2864 1
	register int i, len;
a2898 14
		cp = enm->enm_addrlo;
		crc = 0xffffffff;
		for (len = sizeof(enm->enm_addrlo); --len >= 0;) {
			c = *cp++;
			for (i = 8; --i >= 0;) {
				if (((crc & 0x80000000) ? 1 : 0)
				    ^ (c & 0x01)) {
					crc <<= 1;
					crc ^= 0x04c11db6 | 1;
				} else
					crc <<= 1;
				c >>= 1;
			}
		}
d2900 1
a2900 1
		crc >>= 26;
@


1.51
log
@adress -> address, and a few more; all from Jonathon Gray;

(mvme68k/mvme88k) vs.c and (vax) if_le.c ok miod@@
isakmpd ones ok ho@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.50 2002/06/03 20:01:37 deraadt Exp $	*/
a47 1
#include <net/bpfdesc.h>
@


1.50
log
@spell transceiver correctly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.49 2002/03/14 01:26:56 millert Exp $	*/
d319 1
a319 1
      /* not quite right for ethernet adress */
@


1.49
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.48 2001/09/20 17:02:31 mpech Exp $	*/
d1200 1
a1200 1
	 * tranceiver is set in edinit so that the attach code is given a
d1659 1
a1659 1
	 * Set default state for LINK0 flag (used to disable the tranceiver
d1664 1
a1664 1
		if (cf->cf_flags & ED_FLAGS_DISABLE_TRANCEIVER)
d1886 1
a1886 1
	 * If this is a 3Com board, the tranceiver must be software enabled
@


1.48
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.47 2001/08/25 10:13:29 art Exp $	*/
d120 18
a137 18
int edprobe __P((struct device *, void *, void *));
void edattach __P((struct device *, struct device *, void *));
int ed_find __P((struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia));
int ed_probe_generic8390 __P((bus_space_tag_t, bus_space_handle_t, int));
int ed_find_WD80x3 __P((struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia));
int ed_find_3Com __P((struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia));
int ed_find_Novell __P((struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia));
int edintr __P((void *));
int edioctl __P((struct ifnet *, u_long, caddr_t));
void edstart __P((struct ifnet *));
void edwatchdog __P((struct ifnet *));
void edreset __P((struct ed_softc *));
void edinit __P((struct ed_softc *));
void edstop __P((struct ed_softc *));
d139 2
a140 2
void ed_shared_writemem __P((struct ed_softc *, caddr_t, int, int));
void ed_shared_readmem __P((struct ed_softc *, int, caddr_t, int));
d144 11
a154 11
void ed_getmcaf __P((struct arpcom *, u_int32_t *));
void edread __P((struct ed_softc *, int, int));
struct mbuf *edget __P((struct ed_softc *, int, int));
static __inline void ed_rint __P((struct ed_softc *));
static __inline void ed_xmit __P((struct ed_softc *));
static __inline int ed_ring_copy __P((struct ed_softc *, int, caddr_t,
					u_int16_t));

void ed_pio_readmem __P((struct ed_softc *, u_int16_t, caddr_t, u_int16_t));
void ed_pio_writemem __P((struct ed_softc *, caddr_t, u_int16_t, u_int16_t));
u_int16_t ed_pio_write_mbufs __P((struct ed_softc *, struct mbuf *, u_int16_t));
d174 3
a176 3
int ed_pcmcia_match __P((struct device *, void *, void *));
void ed_pcmcia_attach __P((struct device *, struct device *, void *));
int ed_pcmcia_detach __P((struct device *));
d182 5
a186 5
int ed_pcmcia_isa_attach __P((struct device *, void *, void *,
    struct pcmcia_link *));
int edmod __P((struct pcmcia_link *, struct device *, struct pcmcia_conf *,
    struct cfdata *cf));
int ed_remove __P((struct pcmcia_link *, struct device *));
d374 2
a375 2
int	ed_pci_match __P((struct device *, void *, void *));
void	ed_pci_attach __P((struct device *, struct device *, void *));
@


1.48.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.48 2001/09/20 17:02:31 mpech Exp $	*/
d120 18
a137 18
int edprobe(struct device *, void *, void *);
void edattach(struct device *, struct device *, void *);
int ed_find(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_probe_generic8390(bus_space_tag_t, bus_space_handle_t, int);
int ed_find_WD80x3(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_3Com(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_Novell(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int edintr(void *);
int edioctl(struct ifnet *, u_long, caddr_t);
void edstart(struct ifnet *);
void edwatchdog(struct ifnet *);
void edreset(struct ed_softc *);
void edinit(struct ed_softc *);
void edstop(struct ed_softc *);
d139 2
a140 2
void ed_shared_writemem(struct ed_softc *, caddr_t, int, int);
void ed_shared_readmem(struct ed_softc *, int, caddr_t, int);
d144 11
a154 11
void ed_getmcaf(struct arpcom *, u_int32_t *);
void edread(struct ed_softc *, int, int);
struct mbuf *edget(struct ed_softc *, int, int);
static __inline void ed_rint(struct ed_softc *);
static __inline void ed_xmit(struct ed_softc *);
static __inline int ed_ring_copy(struct ed_softc *, int, caddr_t,
					u_int16_t);

void ed_pio_readmem(struct ed_softc *, u_int16_t, caddr_t, u_int16_t);
void ed_pio_writemem(struct ed_softc *, caddr_t, u_int16_t, u_int16_t);
u_int16_t ed_pio_write_mbufs(struct ed_softc *, struct mbuf *, u_int16_t);
d174 3
a176 3
int ed_pcmcia_match(struct device *, void *, void *);
void ed_pcmcia_attach(struct device *, struct device *, void *);
int ed_pcmcia_detach(struct device *);
d182 5
a186 5
int ed_pcmcia_isa_attach(struct device *, void *, void *,
    struct pcmcia_link *);
int edmod(struct pcmcia_link *, struct device *, struct pcmcia_conf *,
    struct cfdata *cf);
int ed_remove(struct pcmcia_link *, struct device *);
d374 2
a375 2
int	ed_pci_match(struct device *, void *, void *);
void	ed_pci_attach(struct device *, struct device *, void *);
d1200 1
a1200 1
	 * transceiver is set in edinit so that the attach code is given a
d1659 1
a1659 1
	 * Set default state for LINK0 flag (used to disable the transceiver
d1664 1
a1664 1
		if (cf->cf_flags & ED_FLAGS_DISABLE_TRANSCEIVER)
d1886 1
a1886 1
	 * If this is a 3Com board, the transceiver must be software enabled
@


1.47
log
@Change pci_intr_map to take pci_attach_args as an argument.
All callers actually took all arguments to pci_intr_map from pci_attach_args
structs, so this simplifies code.
This also allows more complicated interrupt assignment schemes like the one
on sparc64.

This makes sparc64 pci interrupts work.

Inspired by the same change in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.46 2001/07/08 23:38:07 fgsch Exp $	*/
d2297 1
a2297 1
			 * be zero if a transmitter interrupt occured while not
@


1.46
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.45 2001/06/27 06:34:44 kjc Exp $	*/
d517 1
a517 2
	if (pci_intr_map(pc, pa->pa_intrtag, pa->pa_intrpin,
	    pa->pa_intrline, &ih)) {
@


1.45
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.44 2001/06/25 04:44:27 fgsch Exp $	*/
a200 1
	extern int ifqmaxlen;
a231 1
		IFQ_SET_MAXLEN(&sc->sc_arpcom.ac_if.if_snd, ifqmaxlen);
@


1.44
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.43 2001/06/23 21:54:47 fgsch Exp $	*/
d233 1
a233 1
		sc->sc_arpcom.ac_if.if_snd.ifq_maxlen=ifqmaxlen;
d502 1
d1659 1
d1997 1
a1997 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.43
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.42 2001/02/20 19:39:39 mickey Exp $	*/
a2529 1
	struct ether_header *eh;
a2539 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d2549 1
a2549 3
	/* We assume that the header fit entirely in one mbuf. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.42
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.41 1999/02/28 03:23:37 jason Exp $	*/
a164 4

#define	ETHER_MIN_LEN	64
#define ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6
@


1.41
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.40 1998/08/11 03:28:37 millert Exp $	*/
a520 6
#if NBPFILTER > 0
        if ((sc->spec_flags & ED_REATTACH) == 0)
		bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
		    sizeof(struct ether_header));
#endif

a1710 6

#if NBPFILTER > 0
	if ((sc->spec_flags & ED_REATTACH) == 0)
		bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
			  sizeof(struct ether_header));
#endif
@


1.41.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.42 2001/02/20 19:39:39 mickey Exp $	*/
d521 6
d1717 6
@


1.41.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.41.6.1 2001/05/14 22:24:39 niklas Exp $	*/
d166 4
d237 1
a237 1
		IFQ_SET_MAXLEN(&sc->sc_arpcom.ac_if.if_snd, ifqmaxlen);
a505 1
	IFQ_SET_READY(&ifp->if_snd);
a1661 1
	IFQ_SET_READY(&ifp->if_snd);
d1999 1
a1999 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
d2534 1
d2545 3
d2557 3
a2559 1
	ether_input_mbuf(ifp, m);
@


1.41.6.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.41.6.2 2001/07/04 10:41:25 niklas Exp $	*/
d201 1
d233 1
d519 2
a520 1
	if (pci_intr_map(pa, &ih)) {
d2300 1
a2300 1
			 * be zero if a transmitter interrupt occurred while not
@


1.41.6.4
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 18
a137 18
int edprobe(struct device *, void *, void *);
void edattach(struct device *, struct device *, void *);
int ed_find(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_probe_generic8390(bus_space_tag_t, bus_space_handle_t, int);
int ed_find_WD80x3(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_3Com(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int ed_find_Novell(struct ed_softc *, struct cfdata *,
    struct isa_attach_args *ia);
int edintr(void *);
int edioctl(struct ifnet *, u_long, caddr_t);
void edstart(struct ifnet *);
void edwatchdog(struct ifnet *);
void edreset(struct ed_softc *);
void edinit(struct ed_softc *);
void edstop(struct ed_softc *);
d139 2
a140 2
void ed_shared_writemem(struct ed_softc *, caddr_t, int, int);
void ed_shared_readmem(struct ed_softc *, int, caddr_t, int);
d144 11
a154 11
void ed_getmcaf(struct arpcom *, u_int32_t *);
void edread(struct ed_softc *, int, int);
struct mbuf *edget(struct ed_softc *, int, int);
static __inline void ed_rint(struct ed_softc *);
static __inline void ed_xmit(struct ed_softc *);
static __inline int ed_ring_copy(struct ed_softc *, int, caddr_t,
					u_int16_t);

void ed_pio_readmem(struct ed_softc *, u_int16_t, caddr_t, u_int16_t);
void ed_pio_writemem(struct ed_softc *, caddr_t, u_int16_t, u_int16_t);
u_int16_t ed_pio_write_mbufs(struct ed_softc *, struct mbuf *, u_int16_t);
d174 3
a176 3
int ed_pcmcia_match(struct device *, void *, void *);
void ed_pcmcia_attach(struct device *, struct device *, void *);
int ed_pcmcia_detach(struct device *);
d182 5
a186 5
int ed_pcmcia_isa_attach(struct device *, void *, void *,
    struct pcmcia_link *);
int edmod(struct pcmcia_link *, struct device *, struct pcmcia_conf *,
    struct cfdata *cf);
int ed_remove(struct pcmcia_link *, struct device *);
d374 2
a375 2
int	ed_pci_match(struct device *, void *, void *);
void	ed_pci_attach(struct device *, struct device *, void *);
@


1.41.6.5
log
@Sync the SMP branch with 3.3
@
text
@d1200 1
a1200 1
	 * transceiver is set in edinit so that the attach code is given a
d1659 1
a1659 1
	 * Set default state for LINK0 flag (used to disable the transceiver
d1664 1
a1664 1
		if (cf->cf_flags & ED_FLAGS_DISABLE_TRANSCEIVER)
d1886 1
a1886 1
	 * If this is a 3Com board, the transceiver must be software enabled
@


1.41.6.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d319 1
a319 1
      /* not quite right for ethernet address */
@


1.41.6.7
log
@Merge with the trunk
@
text
@d48 1
@


1.41.6.8
log
@sync to head
@
text
@d2863 1
d2865 1
a2865 1
	register int i;
d2900 14
d2915 1
a2915 1
		crc = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
@


1.40
log
@put irq number on the line with the other info, not on its own line
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.39 1998/07/31 18:02:05 millert Exp $	*/
d2565 1
a2565 1
	if (ifp->if_bpf) {
a2566 14

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@


1.39
log
@Match generic SVEC pcmcia NE2000 clone that identifies itself as 'Ethernet Adapter 2.0'.  You just don't get any more generic than that do you?  These boards are dirt cheap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.38 1998/06/03 18:50:45 deraadt Exp $	*/
d519 1
a519 1
	printf("%s\n", sc->isa16bit ? "(16-bit)" : "(8-bit)");	/* XXX */
d530 1
a530 1
		printf("%s: couldn't map interrupt\n", sc->sc_dev.dv_xname);
d537 1
a537 1
		printf("%s: couldn't establish interrupt",
d544 1
a544 1
	printf("%s: interrupting at %s\n", sc->sc_dev.dv_xname, intrstr);
@


1.38
log
@table driven pci match; simplify prints
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.37 1998/03/17 10:55:24 deraadt Exp $	*/
d226 1
a226 1
		    if(bcmp(enaddr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN)) {
d322 2
@


1.37
log
@add a VIATECH card too
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.36 1998/03/17 10:50:33 deraadt Exp $	*/
d385 14
d405 6
a410 19

	/* We don't check the vendor here since many make NE2000 clones */
	if ((PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8029) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_WINBOND &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_WINBOND_W89C940F) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_WINBOND2 &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_WINBOND2_W89C940) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_NETVIN &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETVIN_NV5000) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_COMPEX &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_COMPEX_COMPEXE) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_KTI &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_KTI_KTIE) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_SURECOM &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SURECOM_NE34) ||
	    (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_VIATECH &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_VIATECH_VT86C926))
		return (1);
a446 2

	printf(": NE2000 compatible PCI ethernet controller");
@


1.36
log
@support a few more NE2000 PCI cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.35 1998/03/16 10:41:39 downsj Exp $	*/
d400 1
a400 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_NETVIN_VN5000) ||
d406 3
a408 1
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_SURECOM_NE34))
@


1.35
log
@slightly improved SMC autodetection
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.34 1998/02/15 01:49:58 deraadt Exp $	*/
d393 14
a406 2
	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_REALTEK &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_REALTEK_RT8029)
a407 5

	if (PCI_VENDOR(pa->pa_id) == PCI_VENDOR_WINBOND &&
	    PCI_PRODUCT(pa->pa_id) == PCI_PRODUCT_WINBOND_W89C940F)
		return (1);

@


1.34
log
@new pci ethernet card
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.33 1997/10/06 20:53:03 mickey Exp $	*/
d628 1
a628 1
	u_char iptr, isa16bit, sum;
d738 13
a750 2
		sc->type_str = (sc->type == ED_TYPE_SMC8216C) ?
		    "SMC8216/SMC8216C" : "SMC8216T";
a765 3
			/* 8216 has 16K shared mem -- 8416 has 8K */
			sc->type_str = (sc->type == ED_TYPE_SMC8216C) ?
				"SMC8416C/SMC8416BT" : "SMC8416T";
@


1.33
log
@make it comple w/ ED_DEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.32 1997/08/20 03:46:31 millert Exp $	*/
a375 1
#define PCI_PRODUCT_NE2000	0x8029
d393 7
a399 2
	if (PCI_PRODUCT(pa->pa_id) != PCI_PRODUCT_NE2000)
		return (0);
d401 1
a401 1
	return (1);
@


1.32
log
@Fix for some stupid ne2000 clones that get into a weird state and
are probed as WD instead.  From Martin Husemann <martin@@rumolt.teuto.de>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.31 1997/08/01 07:40:10 deraadt Exp $	*/
d2332 1
a2332 1
					    NIC_GET(nicbase, ED_P0_RSR));
@


1.31
log
@squish into one line
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.30 1997/06/20 20:25:27 mickey Exp $	*/
d880 2
@


1.30
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.29 1997/04/14 02:06:22 millert Exp $	*/
d499 1
a499 2
	printf("\n%s: address %s, ", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
d1671 1
a1671 2
	printf("\n%s: address %s, ", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_arpcom.ac_enaddr));
@


1.29
log
@Correct some bogus casts and change u_short -> u_int16_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.28 1997/04/13 04:52:31 millert Exp $	*/
d1032 1
a1032 1
	 * XXX Sould always unmap, but we can't yet.
@


1.28
log
@Add support for PCI NE2000 clones.  I finally got around to doing this :-)
Tested on alpha, should work on i386 as well.  Note that we treat
a PCI NE2000 as a 16-bit card for now since the driver can not
deal with > 16 bit cards.  To fix this isa16bit in ed_softc needs to
be changed to bus_width (in bytes).  I plan to do this as part
of the split ed driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.27 1997/03/20 23:59:58 niklas Exp $	*/
d73 1
a73 1
	u_short	spec_flags;
d113 1
a113 1
	u_short	txb_len[8];	/* buffered xmit buffer lengths */
d150 1
a150 1
					u_short));
d152 3
a154 3
void ed_pio_readmem __P((struct ed_softc *, u_short, caddr_t, u_short));
void ed_pio_writemem __P((struct ed_softc *, caddr_t, u_short, u_short));
u_short ed_pio_write_mbufs __P((struct ed_softc *, struct mbuf *, u_short));
d1928 1
a1928 1
	u_short len;
d2062 1
a2062 1
		len = ed_pio_write_mbufs(sc, m0, (long)buffer);
d2132 1
a2132 1
			ed_pio_readmem(sc, (long)packet_ptr, packet_hdr,
d2579 1
a2579 1
	u_short src;
d2581 1
a2581 1
	u_short amount;
d2622 2
a2623 2
	u_short dst;
	u_short len;
d2671 1
a2671 1
u_short
d2675 1
a2675 1
	u_short dst;
d2680 1
a2680 1
	u_short len;
d2788 1
a2788 1
	u_short	amount;
d2790 1
a2790 1
	u_short	tmp_amount;
d2800 1
a2800 1
			ed_pio_readmem(sc, (long)src, dst, tmp_amount);
d2810 1
a2810 1
		ed_pio_readmem(sc, (long)src, dst, amount);
@


1.27
log
@64-bit clean.  if_ed.c now works on alpha.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.26 1997/02/21 10:52:09 niklas Exp $	*/
d170 5
d370 165
a534 4
#define	NIC_PUT(t, bah, nic, reg, val)	\
	bus_space_write_1((t), (bah), ((nic) + (reg)), (val))
#define	NIC_GET(t, bah, nic, reg)	\
	bus_space_read_1((t), (bah), ((nic) + (reg)))
@


1.26
log
@We do not use the rsr field
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.25 1996/11/29 22:54:58 niklas Exp $	*/
d144 1
a144 1
void ed_getmcaf __P((struct arpcom *, u_long *));
d1609 1
a1609 1
	u_long mcaf[2];
d1687 2
a1688 1
		NIC_PUT(iot, ioh, nicbase, ED_P1_MAR0 + i, ((u_char *)mcaf)[i]);
d2709 1
a2709 1
	u_long *af;
d2714 1
a2714 1
	register u_long crc;
d2755 2
a2756 1
				if (((crc & 0x80000000) ? 1 : 0) ^ (c & 0x01)) {
@


1.25
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.24 1996/11/12 20:30:34 niklas Exp $	*/
a1926 1
	u_int8_t rsr;			/* receiver status */
a1966 1
		rsr = packet_hdr[ED_RING_RSR];
@


1.24
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ed.c,v 1.23 1996/11/07 11:25:10 niklas Exp $	*/
/*	$NetBSD: if_ed.c,v 1.100 1996/05/12 23:52:19 mycroft Exp $	*/
d52 1
a52 1
#include <machine/bus.old.h>
d65 1
a65 1
	void *sc_ih;
d68 1
a68 1
	void *sc_sh;			/* shutdown hook */
d78 6
a83 4
	bus_chipset_tag_t sc_bc;  /* bus identifier */
	bus_io_handle_t sc_ioh;   /* io handle */
	bus_io_handle_t sc_delayioh; /* io handle for `delay port' */
	bus_mem_handle_t sc_memh; /* bus memory handle */
d85 2
a86 2
	bus_io_size_t	asic_base;	/* offset of ASIC I/O port */
	bus_io_size_t	nic_base;	/* offset of NIC (DS8390) I/O port */
d124 1
a124 1
int ed_probe_generic8390 __P((bus_chipset_tag_t, bus_io_handle_t, int));
d147 3
a149 3
static inline void ed_rint __P((struct ed_softc *));
static inline void ed_xmit __P((struct ed_softc *));
static inline int ed_ring_copy __P((struct ed_softc *, int, caddr_t,
d181 5
a185 7
static int ed_pcmcia_isa_attach __P((struct device *, void *,
				     void *, struct pcmcia_link *));

static int edmod __P((struct pcmcia_link *, struct device *,
		      struct pcmcia_conf *, struct cfdata *cf));

static int ed_remove __P((struct pcmcia_link *, struct device *));
d188 1
a188 1
static int
d233 1
d240 1
a240 1
static int
d278 1
a278 2

static int
d290 1
a290 1
	isa_intr_disestablish(sc->sc_bc, sc->sc_ih);
d365 4
a368 4
#define	NIC_PUT(bc, ioh, nic, reg, val)	\
	bus_io_write_1((bc), (ioh), ((nic) + (reg)), (val))
#define	NIC_GET(bc, ioh, nic, reg)	\
	bus_io_read_1((bc), (ioh), ((nic) + (reg)))
d425 3
a427 3
ed_probe_generic8390(bc, ioh, nicbase)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d431 1
a431 1
	if ((NIC_GET(bc, ioh, nicbase, ED_P0_CR) &
d435 1
a435 1
	if ((NIC_GET(bc, ioh, nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)
d453 5
a457 4
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	bus_io_handle_t delayioh = ia->ia_delayioh;
	bus_mem_handle_t memh;
d463 2
a464 1
	bc = ia->ia_bc;
d471 1
a471 1
	if (bus_io_map(bc, ia->ia_iobase, ED_WD_IO_PORTS, &ioh))
d479 1
a479 1
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_POW);
d490 1
a490 1
		sum += bus_io_read_1(bc, ioh, asicbase + ED_WD_PROM + i);
d498 1
a498 1
		if (bus_io_read_1(bc, ioh, asicbase + ED_WD_CARD_ID) !=
d500 1
a500 1
		    bus_io_read_1(bc, ioh, asicbase + ED_WD_PROM + 7) != 0)
d506 1
a506 1
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
d509 1
a509 1
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR, ED_WD_MSR_RST);
d512 2
a513 2
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
	    bus_io_read_1(bc, ioh, asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);
d518 1
a518 1
	sc->type = bus_io_read_1(bc, ioh, asicbase + ED_WD_CARD_ID);
d544 1
a544 1
		if (bus_io_read_1(bc, ioh, asicbase + ED_WD_ICR)
d570 5
a574 5
				"SMC8216/SMC8216C" : "SMC8216T";
		bus_io_write_1(bc, ioh, asicbase + ED_WD790_HWR,
			bus_io_read_1(bc, ioh, asicbase + ED_WD790_HWR)
			| ED_WD790_HWR_SWH);
		switch (bus_io_read_1(bc, ioh, asicbase + ED_WD790_RAR) &
d592 3
a594 3
		bus_io_write_1(bc, ioh, asicbase + ED_WD790_HWR,
			bus_io_read_1(bc, ioh,
			asicbase + ED_WD790_HWR) & ~ED_WD790_HWR_SWH);
d623 2
a624 2
	    ((bus_io_read_1(bc, ioh,
	      asicbase + ED_WD_ICR) & ED_WD_ICR_16BIT) == 0)) {
d634 2
a635 1
		printf("%x -> %x\n", i, inb(asicbase + i));
d655 1
d657 4
a660 3
		bus_io_write_1(bc, ioh, ED_WD790_HWR,
		    bus_io_read_1(bc, ioh, ED_WD790_HWR) | ED_WD790_HWR_SWH);
		x = bus_io_read_1(bc, ioh, ED_WD790_GCR);
d663 3
a665 2
		bus_io_write_1(bc, ioh, ED_WD790_HWR,
		    bus_io_read_1(bc, ioh, ED_WD790_HWR) & ~ED_WD790_HWR_SWH);
d680 3
a682 2
		bus_io_write_1(bc, ioh, ED_WD790_ICR,
		    bus_io_read_1(bc, ioh, ED_WD790_ICR) | ED_WD790_ICR_EIL);
d685 3
a687 2
		iptr = (bus_io_read_1(bc, ioh, ED_WD_ICR) & ED_WD_ICR_IR2) |
		    ((bus_io_read_1(bc, ioh, ED_WD_IRR) &
d703 2
a704 2
		bus_io_write_1(bc, ioh, ED_WD_IRR,
		    bus_io_read_1(bc, ioh, ED_WD_IRR) | ED_WD_IRR_IEN);
d718 1
a718 1
	if (bus_mem_map(bc, ia->ia_maddr, memsize, 0, &memh))
d739 1
a739 1
		    bus_io_read_1(bc, ioh, asicbase + ED_WD_PROM + i);
d747 1
a747 1
			    bus_io_read_1(bc, ioh, asicbase + ED_WD_LAAR) &
d750 2
a751 4
			sc->wd_laar_proto =
			    ED_WD_LAAR_L16EN |
			    ((ia->ia_maddr >> 19) &
			    ED_WD_LAAR_ADDRHI);
d753 1
a753 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d765 1
a765 1
			bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d775 1
a775 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR + 1,
d777 1
a777 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR + 2,
d786 3
a788 3
		bus_io_write_1(bc, ioh, asicbase + 0x04,
		    bus_io_read_1(bc, ioh, asicbase + 0x04) | 0x80);
		bus_io_write_1(bc, ioh, asicbase + 0x0b,
d791 3
a793 3
		    (bus_io_read_1(bc, ioh, asicbase + 0x0b) & 0xb0));
		bus_io_write_1(bc, ioh, asicbase + 0x04,
		    bus_io_read_1(bc, ioh, asicbase + 0x04) & ~0x80);
d797 1
a797 1
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
d800 2
a801 2
	(void) bus_io_read_1(bc, delayioh, 0);
	(void) bus_io_read_1(bc, delayioh, 0);
d806 1
a806 1
			bus_mem_write_2(bc, memh, sc->mem_start + i, 0);
d809 1
a809 1
			bus_mem_write_1(bc, memh, sc->mem_start + i, 0);
d815 1
a815 1
			if (bus_mem_read_2(bc, memh, sc->mem_start + i)) {
d822 1
a822 1
			if (bus_mem_read_1(bc, memh, sc->mem_start + i)) {
d836 1
a836 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
d839 1
a839 1
			bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d841 2
a842 2
		(void) bus_io_read_1(bc, delayioh, 0);
		(void) bus_io_read_1(bc, delayioh, 0);
d854 1
a854 1
	bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR, sc->wd_msr_proto);
d856 1
a856 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d858 2
a859 2
	(void) bus_io_read_1(bc, delayioh, 0);
	(void) bus_io_read_1(bc, delayioh, 0);
d870 1
a870 1
		bus_io_unmap(bc, ioh, ED_WD_IO_PORTS);
d872 1
a872 1
			bus_mem_unmap(bc, memh, memsize);
d875 2
a876 1
		sc->sc_bc = bc;
d883 5
a887 2
int ed_3com_iobase[] = {0x2e0, 0x2a0, 0x280, 0x250, 0x350, 0x330, 0x310, 0x300};
int ed_3com_maddr[] = {MADDRUNK, MADDRUNK, MADDRUNK, MADDRUNK, 0xc8000, 0xcc000, 0xd8000, 0xdc000};
d901 4
a904 3
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	bus_mem_handle_t memh;
d916 2
a917 1
	bc = ia->ia_bc;
d919 1
a919 1
	if (bus_io_map(bc, ia->ia_iobase, ED_WD_IO_PORTS, &ioh))
d933 1
a933 1
	x = bus_io_read_1(bc, ioh, asicbase + ED_3COM_BCFR);
d947 6
a952 2
	x = bus_io_read_1(bc, ioh, asicbase + ED_3COM_PCFR);
	if (x == 0 || (x & (x - 1)) != 0)
d954 1
d967 1
a967 1
	x = bus_io_read_1(bc, ioh, asicbase + ED_3COM_IDCFR) &
d988 1
a988 1
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR,
d999 1
a999 1
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);
d1015 1
a1015 1
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR,
d1019 1
a1019 1
		sc->sc_arpcom.ac_enaddr[i] = NIC_GET(bc, ioh, nicbase, i);
d1026 1
a1026 1
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);
d1031 1
a1031 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1038 1
a1038 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_DCR, 0);
d1041 1
a1041 1
	NIC_PUT(bc, ioh, nicbase,
d1045 1
a1045 1
	if (NIC_GET(bc, ioh, nicbase, ED_P2_DCR) & ED_DCR_WTS)
d1051 1
a1051 1
	NIC_PUT(bc, ioh, nicbase, ED_P2_CR,
d1054 1
a1054 1
	if (bus_mem_map(bc, ia->ia_maddr, memsize, 0, &memh))
d1097 2
a1098 2
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_PSTR, sc->rec_page_start);
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_PSPR, sc->rec_page_stop);
d1103 1
a1103 1
		bus_io_write_1(bc, ioh, asicbase + ED_3COM_IDCFR,
d1107 1
a1107 1
		bus_io_write_1(bc, ioh, asicbase + ED_3COM_IDCFR,
d1111 1
a1111 1
		bus_io_write_1(bc, ioh, asicbase + ED_3COM_IDCFR,
d1115 1
a1115 1
		bus_io_write_1(bc, ioh, asicbase + ED_3COM_IDCFR,
d1128 1
a1128 1
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_GACFR,
d1137 3
a1139 3
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_VPTR2, 0xff);
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_VPTR1, 0xff);
	bus_io_write_1(bc, ioh, asicbase + ED_3COM_VPTR0, 0x00);
d1144 1
a1144 1
			bus_mem_write_2(bc, memh, sc->mem_start + i, 0);
d1147 1
a1147 1
			bus_mem_write_1(bc, memh, sc->mem_start + i, 0);
d1153 1
a1153 1
			if (bus_mem_read_2(bc, memh, sc->mem_start + i)) {
d1160 1
a1160 1
			if (bus_mem_read_1(bc, memh, sc->mem_start + i)) {
d1182 2
a1183 1
	sc->sc_bc = bc;
d1189 1
a1189 1
	bus_mem_unmap(bc, memh, memsize);
d1191 1
a1191 1
	bus_io_unmap(bc, ioh, ED_3COM_IO_PORTS);
d1204 2
a1205 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d1212 1
a1212 1
	bc = ia->ia_bc;
d1214 1
a1214 1
	if (bus_io_map(bc, ia->ia_iobase, ED_NOVELL_IO_PORTS, &ioh))
d1224 1
a1224 1
	bus_io_write_1(bc, ioh, asicbase + ED_NOVELL_RESET, 0);
d1227 1
a1227 1
	tmp = bus_io_read_1(bc, ioh, asicbase + ED_NOVELL_RESET);
d1237 1
a1237 1
	bus_io_write_1(bc, ioh, asicbase + ED_NOVELL_RESET, tmp);
d1246 1
a1246 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1252 1
a1252 1
	if (!ed_probe_generic8390(bc, ioh, nicbase))
d1269 1
a1269 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);
d1272 1
a1272 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1274 2
a1275 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);
	NIC_PUT(bc, ioh, nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);
d1282 1
a1282 1
	sc->sc_bc = bc;
d1296 1
a1296 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_DCR,
d1298 2
a1299 2
		NIC_PUT(bc, ioh, nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);
		NIC_PUT(bc, ioh, nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);
d1424 1
a1424 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_ISR, 0xff);
d1432 1
a1432 1
	sc->sc_bc = bc;
d1437 1
a1437 1
	bus_io_unmap(bc, ioh, ED_NOVELL_IO_PORTS);
d1450 2
a1451 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d1462 1
a1462 1
	bc = sc->sc_bc;			/* XXX */
d1466 1
a1466 1
	sc->sc_delayioh = ia->ia_delayioh;
d1492 1
a1492 1
		if ((bus_io_read_1(bc, ioh, asicbase + ED_WD_IRR) &
d1563 2
a1564 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1569 1
a1569 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1577 1
a1577 1
	while (((NIC_GET(bc, ioh, nicbase,
d1604 2
a1605 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1625 1
a1625 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1633 1
a1633 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_DCR,
d1637 1
a1637 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1641 2
a1642 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR0, 0);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR1, 0);
d1645 1
a1645 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_RCR, ED_RCR_MON);
d1648 1
a1648 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_TCR, ED_TCR_LB0);
d1652 1
a1652 1
		NIC_PUT(bc, ioh, nicbase, 0x09, 0);
d1655 3
a1657 3
	NIC_PUT(bc, ioh, nicbase, ED_P0_BNRY, sc->rec_page_start);
	NIC_PUT(bc, ioh, nicbase, ED_P0_PSTART, sc->rec_page_start);
	NIC_PUT(bc, ioh, nicbase, ED_P0_PSTOP, sc->rec_page_stop);
d1663 1
a1663 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_ISR, 0xff);
d1671 1
a1671 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_IMR,
d1676 1
a1676 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1681 1
a1681 1
		NIC_PUT(bc, ioh, nicbase, ED_P1_PAR0 + i,
d1687 1
a1687 1
		NIC_PUT(bc, ioh, nicbase, ED_P1_MAR0 + i, ((u_char *)mcaf)[i]);
d1694 1
a1694 1
	NIC_PUT(bc, ioh, nicbase, ED_P1_CURR, sc->next_packet);
d1697 1
a1697 1
	NIC_PUT(bc, ioh, nicbase, ED_P1_CR,
d1708 1
a1708 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_RCR, i);
d1711 1
a1711 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_TCR, 0);
d1721 1
a1721 1
			bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR, 0);
d1723 1
a1723 1
			bus_io_write_1(bc, ioh, asicbase + ED_3COM_CR,
d1729 1
a1729 1
		x = bus_io_read_1(bc, ioh, asicbase + ED_WD_IRR);
d1734 1
a1734 1
		bus_io_write_1(bc, ioh, asicbase + ED_WD_IRR, x);
d1739 1
a1739 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1753 1
a1753 1
static inline void
d1757 2
a1758 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1766 1
a1766 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1770 1
a1770 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_TPSR, sc->tx_page_start +
d1774 2
a1775 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_TBCR0, len);
	NIC_PUT(bc, ioh, nicbase, ED_P0_TBCR1, len >> 8);
d1778 1
a1778 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1804 2
a1805 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1850 1
a1850 1
				bus_io_write_1(bc, ioh,
d1860 1
a1860 1
				bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d1862 1
a1862 1
			bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
d1864 2
a1865 2
			(void) bus_io_read_1(bc, sc->sc_delayioh, 0);
			(void) bus_io_read_1(bc, sc->sc_delayioh, 0);
d1880 1
a1880 1
				bus_io_write_1(bc, ioh,
d1885 1
a1885 1
			bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
d1888 1
a1888 1
				bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
d1890 2
a1891 2
			(void) bus_io_read_1(bc, sc->sc_delayioh, 0);
			(void) bus_io_read_1(bc, sc->sc_delayioh, 0);
d1916 1
a1916 1
static inline void
d1920 2
a1921 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1934 1
a1934 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d1945 1
a1945 1
	current = NIC_GET(bc, ioh, nicbase, ED_P1_CURR);
d1950 1
a1950 1
	NIC_PUT(bc, ioh, nicbase, ED_P1_CR,
d2035 1
a2035 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_BNRY, boundary);
d2047 2
a2048 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d2054 1
a2054 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2057 1
a2057 1
	isr = NIC_GET(bc, ioh, nicbase, ED_P0_ISR);
d2068 1
a2068 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_ISR, isr);
d2075 1
a2075 1
			u_char collisions = NIC_GET(bc, ioh, nicbase,
d2087 1
a2087 1
			(void) NIC_GET(bc, ioh, nicbase, ED_P0_TSR);
d2092 1
a2092 1
				if ((NIC_GET(bc, ioh, nicbase, ED_P0_TSR) &
d2185 1
a2185 1
						bus_io_write_1(bc, ioh,
d2189 1
a2189 1
					bus_io_write_1(bc, ioh,
d2192 4
a2195 4
					(void) bus_io_read_1(bc,
					    sc->sc_delayioh, 0);
					(void) bus_io_read_1(bc,
					    sc->sc_delayioh, 0);
d2202 1
a2202 1
					bus_io_write_1(bc, ioh,
d2206 1
a2206 1
						bus_io_write_1(bc, ioh,
d2209 4
a2212 4
					(void) bus_io_read_1(bc,
					    sc->sc_delayioh, 0);
					(void) bus_io_read_1(bc,
					    sc->sc_delayioh, 0);
d2230 1
a2230 1
		NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2239 3
a2241 3
			(void) NIC_GET(bc, ioh, nicbase, ED_P0_CNTR0);
			(void) NIC_GET(bc, ioh, nicbase, ED_P0_CNTR1);
			(void) NIC_GET(bc, ioh, nicbase, ED_P0_CNTR2);
d2244 1
a2244 1
		isr = NIC_GET(bc, ioh, nicbase, ED_P0_ISR);
d2418 2
a2419 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d2423 1
a2423 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2431 2
a2432 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR0, amount);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR1, amount >> 8);
d2435 2
a2436 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR0, src);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR1, src >> 8);
d2438 1
a2438 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2442 1
a2442 1
		bus_io_read_raw_multi_2(bc, ioh,
d2445 2
a2446 2
		bus_io_read_multi_1(bc, ioh, sc->asic_base + ED_NOVELL_DATA,
		    dst, amount);
d2460 2
a2461 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d2466 1
a2466 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2470 1
a2470 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);
d2473 2
a2474 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR0, len);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR1, len >> 8);
d2477 2
a2478 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR1, dst >> 8);
d2481 1
a2481 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2485 1
a2485 1
		bus_io_write_raw_multi_2(bc, ioh,
d2488 2
a2489 2
		bus_io_write_multi_1(bc, ioh, sc->asic_base + ED_NOVELL_DATA,
		    src, len);
d2498 1
a2498 1
	while (((NIC_GET(bc, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=
d2512 2
a2513 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d2521 1
a2521 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2525 1
a2525 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_ISR, ED_ISR_RDC);
d2528 2
a2529 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR0, len);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RBCR1, len >> 8);
d2532 2
a2533 2
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(bc, ioh, nicbase, ED_P0_RSAR1, dst >> 8);
d2536 1
a2536 1
	NIC_PUT(bc, ioh, nicbase, ED_P0_CR,
d2549 1
a2549 1
				bus_io_write_multi_1(bc, ioh,
d2568 1
a2568 1
				bus_io_write_raw_multi_2(bc, ioh,
d2576 1
a2576 1
				bus_io_write_raw_multi_2(bc, ioh,
d2589 1
a2589 1
			bus_io_write_raw_multi_2(bc, ioh,
d2601 1
a2601 1
	while (((NIC_GET(bc, ioh, nicbase, ED_P0_ISR) & ED_ISR_RDC) !=
d2618 1
a2618 1
static inline int
d2781 2
a2782 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_mem_handle_t memh = sc->sc_memh;
d2798 1
a2798 1
			word = bus_mem_read_2(bc, memh, card & ~1);
d2800 1
a2800 1
			bus_mem_write_2(bc, memh, card & ~1, word);
d2805 1
d2808 1
a2808 1
			bus_mem_write_2(bc, memh, card, word);
d2815 1
a2815 1
			bus_mem_write_2(bc, memh, card, word);
d2819 1
a2819 1
			bus_mem_write_1(bc, memh, card++, *from++);
d2829 2
a2830 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_mem_handle_t memh = sc->sc_memh;
d2837 1
d2839 1
a2839 1
			word = bus_mem_read_2(bc, memh, card);
d2846 1
a2846 1
			*to = bus_mem_read_2(bc, memh, card) & 0xff;
d2849 1
a2849 1
			*to++ = bus_mem_read_1(bc, memh, card++);
@


1.23
log
@Parenthesize bit ops in last change (-Wall fix)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.22 1996/11/07 08:36:50 niklas Exp $	*/
d52 1
a52 1
#include <machine/bus.h>
@


1.22
log
@Handle odd-aligned mbufs in 16 bit mode so strict alignment is enforced
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.21 1996/10/16 12:34:36 deraadt Exp $	*/
d2781 1
a2781 1
			word = word & 0xff | (*from << 8);
@


1.21
log
@unused vars
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.20 1996/10/05 00:08:39 niklas Exp $	*/
d2774 13
@


1.20
log
@Avoid odd aligned 16-bit entities for mips sake
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.19 1996/09/26 21:07:16 niklas Exp $	*/
d894 1
a894 1
	int i, rv, mapped_mem = 0;
@


1.19
log
@Fix alignment for mips & other strict architectures, mostly used lance stuff.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.18 1996/08/02 11:15:52 niklas Exp $	*/
d2781 4
a2784 2
		if (len == 1)
			bus_mem_write_2(bc, memh, card, (u_int16_t)*from);
@


1.18
log
@DOH! transmit got broken in the last commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.17 1996/07/31 01:51:49 niklas Exp $	*/
d2637 1
a2637 2
 * dst = pointer to last mbuf in mbuf chain to copy to
 * amount = amount of data to copy
d2640 1
a2640 1
edget(sc, src, total_len)
d2643 1
a2643 1
	u_short total_len;
d2647 1
a2647 1
	int len;
d2652 1
d2654 4
a2657 2
	m->m_pkthdr.len = total_len;
	len = MHLEN;
d2661 1
a2661 1
	while (total_len > 0) {
d2670 1
a2670 1
		if (total_len >= MINCLSIZE) {
d2675 1
a2675 1
		m->m_len = len = min(total_len, len);
d2677 1
a2677 1
		total_len -= len;
@


1.17
log
@Drop the ed_ring structure in favour of a byte-array and offset constants.
Makes the code much more robust agains MD paddings.  Use new bus.h.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.16 1996/05/26 00:27:17 deraadt Exp $	*/
a2771 1
		word = from[0] + from[1] * 256;
d2773 1
@


1.16
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.15 1996/05/10 12:41:16 deraadt Exp $	*/
a56 1
#define ED_BYTE_ORDER LITTLE_ENDIAN
d1905 7
a1911 4
	u_char boundary, current;
	u_short len;
	u_char nlen;
	struct ed_ring packet_hdr;
d1945 1
a1945 1
			ed_shared_readmem(sc, packet_ptr, (caddr_t)&packet_hdr,
d1948 6
a1953 3
			ed_pio_readmem(sc, (long)packet_ptr,
			    (caddr_t)&packet_hdr, sizeof(packet_hdr));
		len = bus_to_host_2(bc, packet_hdr.count);
d1963 2
a1964 2
		if (packet_hdr.next_packet >= sc->next_packet)
			nlen = (packet_hdr.next_packet - sc->next_packet);
d1966 1
a1966 1
			nlen = ((packet_hdr.next_packet - sc->rec_page_start) +
d1973 1
a1973 1
		if (len != packet_hdr.count) {
d1977 1
a1977 1
			    sc->sc_dev.dv_xname, packet_hdr.count, len,
d1979 1
a1979 1
			    packet_hdr.next_packet, sc->rec_page_stop);
d1992 2
a1993 2
		    packet_hdr.next_packet >= sc->rec_page_start &&
		    packet_hdr.next_packet < sc->rec_page_stop) {
d1995 2
a1996 2
			edread(sc, packet_ptr + sizeof(struct ed_ring),
			    len - sizeof(struct ed_ring));
d2008 1
a2008 1
		sc->next_packet = packet_hdr.next_packet;
d2424 2
a2425 2
		bus_io_read_multi_2(bc, ioh, sc->asic_base + ED_NOVELL_DATA,
		    dst, amount / 2);
d2467 2
a2468 2
		bus_io_write_multi_2(bc, ioh, sc->asic_base + ED_NOVELL_DATA,
		    src, len / 2);
d2550 2
a2551 3
				bus_io_write_2(bc, ioh,
				    asicbase + ED_NOVELL_DATA,
				    *(u_int16_t *)savebyte);
d2558 2
a2559 3
				bus_io_write_multi_2(bc, ioh,
				    asicbase + ED_NOVELL_DATA,
				    data, len >> 1);
d2571 2
a2572 2
			bus_io_write_2(bc, ioh, asicbase + ED_NOVELL_DATA,
			    *(u_int16_t *)savebyte);
d2763 1
d2772 1
d2774 1
a2774 2
			bus_mem_write_2(bc, memh, card,
			    *((u_int16_t *)from));
d2780 1
a2780 1
			bus_mem_write_2(bc, memh, card, (u_int16_t)(*from));
d2795 1
d2802 3
a2804 2
			*((u_int16_t *)to) = bus_mem_read_2(bc, memh, card);
			to += 2;
@


1.15
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ed.c,v 1.10 1996/04/21 22:23:41 deraadt Exp $	*/
/*	$NetBSD: if_ed.c,v 1.98 1996/05/07 01:55:13 thorpej Exp $	*/
d53 1
d460 1
a460 1
	int i, rv, mapped_mem = 0;
d799 7
a805 2
	for (i = 0; i < memsize; ++i)
		bus_mem_write_1(bc, memh, sc->mem_start + i, 0);
d807 16
a822 5
	for (i = 0; i < memsize; ++i)
		if (bus_mem_read_1(bc, memh, sc->mem_start + i)) {
			printf("%s: failed to clear shared memory at %x - check configuration\n",
			    sc->sc_dev.dv_xname,
			    (ia->ia_maddr + sc->mem_start + i));
d824 16
a839 10
			/* Disable 16 bit access to shared memory. */
			bus_io_write_1(bc, ioh, asicbase + ED_WD_MSR,
			    sc->wd_msr_proto);
			if (isa16bit)
				bus_io_write_1(bc, ioh, asicbase + ED_WD_LAAR,
				    sc->wd_laar_proto);
			(void) bus_io_read_1(bc, delayioh, 0);
			(void) bus_io_read_1(bc, delayioh, 0);
			goto out;
		}
d895 2
a896 2
	int i;
	u_int memsize;
a905 1

d1125 23
a1147 10
	/* Zero memory and verify that it is clear. */
	for (i = 0; i < memsize; ++i)
		bus_mem_write_1(bc, memh, sc->mem_start + i, 0);

	for (i = 0; i < memsize; ++i)
		if (bus_mem_read_1(bc, memh, sc->mem_start + i)) {
			printf("%s: failed to clear shared memory at %x - check configuration\n",
			    sc->sc_dev.dv_xname,
			    (ia->ia_maddr + sc->mem_start + i));
			goto out;
d1149 9
d2753 1
a2753 1
ed_shared_writemem(sc, buf, card, len)
d2755 1
a2755 1
	caddr_t buf;
a2759 2
	u_int8_t *ptr = (u_int8_t *)buf;
	int i;
d2761 20
a2780 4
	/* XXX should have bus_mem_copyout_{1,2,4,8}() */

	for (i = 0; i < len; ++i)
		bus_mem_write_1(bc, memh, card + i, ptr[i]);
d2784 1
a2784 1
ed_shared_readmem(sc, card, buf, len)
d2786 1
a2786 1
	caddr_t buf;
a2790 2
	u_int8_t *ptr = (u_int8_t *)buf;
	int i;
d2792 16
a2807 4
	/* XXX should have bus_mem_copyin_{1,2,4,8}() */

	for (i = 0; i < len; ++i)
		ptr[i] = bus_mem_read_1(bc, memh, card + i);
@


1.14
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*	$NetBSD: if_ed.c,v 1.96 1996/05/03 19:05:30 christos Exp $	*/
d80 1
d132 1
a132 1
void edwatchdog __P((int));
d455 1
d542 2
a543 1
		if (inb(asicbase + ED_WD_ICR) & ED_WD_ICR_16BIT) {
d794 2
a795 2
	(void) bus_io_read_1(bc, ioh, 0x84);		/* XXX */
	(void) bus_io_read_1(bc, ioh, 0x84);		/* XXX */
d813 2
a814 2
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
d830 2
a831 2
	(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
	(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
d1405 1
d1411 2
a1412 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = ed_cd.cd_name;
d1525 2
a1526 2
edwatchdog(unit)
	int unit;
d1528 1
a1528 1
	struct ed_softc *sc = ed_cd.cd_devs[unit];
d1742 1
a1742 1
	struct ed_softc *sc = ed_cd.cd_devs[ifp->if_unit];
d1803 2
a1804 2
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
d1829 2
a1830 2
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
			(void) bus_io_read_1(bc, ioh, 0x84);	/* XXX */
d2125 4
a2128 3
					/* XXX */
					(void) bus_io_read_1(bc, ioh, 0x84);
					(void) bus_io_read_1(bc, ioh, 0x84);
d2142 4
a2145 3
					/* XXX */
					(void) bus_io_read_1(bc, ioh, 0x84);
					(void) bus_io_read_1(bc, ioh, 0x84);
d2192 1
a2192 1
	struct ed_softc *sc = ed_cd.cd_devs[ifp->if_unit];
@


1.13
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d2 1
a2 1
/*	$NetBSD: if_ed.c,v 1.93 1996/04/11 22:28:55 cgd Exp $	*/
a377 2
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
	struct isa_attach_args *ia = aux;
d463 4
a515 3
	/* Set initial values for width/size. */
	memsize = 8192;
	isa16bit = 0;
d752 1
a752 1
		    (sc->type == ED_TYPE_WD8013EBT) && !sc->is790) {
d869 1
a869 1
	int i, rv, mapped_mem = 0;
d871 1
a871 1
	u_char isa16bit, sum, x;
d874 7
a881 1
	rv = 0;
d899 1
a899 1
		goto out;
d906 1
a906 1
			goto out;
d913 1
a913 1
		goto out;
d920 1
a920 1
			goto out;
d936 1
a936 1
			goto out;
a968 6
	 * Hmmm...a 16bit 3Com board has 16k of memory, but only an 8k window
	 * to it.
	 */
	memsize = 8192;

	/*
d1014 1
a1014 2
		goto out;
	mapped_mem = 1;
a1113 1
	rv = 1;
a1114 1
 out:
d1119 10
a1128 11
	if (rv == 0) {
		bus_io_unmap(bc, ioh, ED_3COM_IO_PORTS);
		if (mapped_mem)
			bus_mem_unmap(bc, memh, memsize);
	} else {
		/* XXX this is all "indirect" brokenness */
		sc->sc_bc = bc;
		sc->sc_ioh = ioh;
		sc->sc_memh = memh;
	}
	return (rv);
a1141 1
	bus_mem_handle_t memh;
d1143 1
a1143 1
	u_char romdata[16], isa16bit = 0, tmp;
d1146 1
a1146 1
	int rv, asicbase, nicbase;
a1148 1
	rv = 0;
d1304 1
a1304 1
			goto out;
a1362 1
	rv = 1;
a1363 1
 out:
d1368 8
a1375 9
	if (rv == 0)
		bus_io_unmap(bc, ioh, ED_NOVELL_IO_PORTS);
	else {
		/* XXX this is all "indirect" brokenness */
		sc->sc_bc = bc;
		sc->sc_ioh = ioh;
		sc->sc_memh = memh;
	}
	return (rv);
d1744 1
a1744 1
	int len, i;
@


1.12
log
@Pull in John Kohl's [jtk@@netbsd.org] most recent (15Apr96) APM and PCMCIA work
(original PCMCIA framework  by Stefan Grefen [grefen@@convex.com]).
@
text
@a45 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d2209 5
a2224 18
#endif
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			edinit(sc);
			break;
		    }
@


1.11
log
@Extend the bus.h interface with endian conversion functions and use
where relevant.
@
text
@d22 1
d158 2
a159 1
struct cfattach ed_ca = {
d162 1
d172 2
a173 4
#define	NIC_PUT(bc, ioh, nic, reg, val)	\
	bus_io_write_1((bc), (ioh), ((nic) + (reg)), (val))
#define	NIC_GET(bc, ioh, nic, reg)	\
	bus_io_read_1((bc), (ioh), ((nic) + (reg)))
d175 3
a177 2
/*#include "pcmciabus.h"*/
#if NPCMCIABUS > 0 
d179 6
a184 3
#include <dev/pcmcia/pcmciabus.h>
static int ed_probe_pcmcia_ne __P((struct device *, void *,
				   void *, struct pcmcia_link *));
d193 1
a193 1
ed_probe_pcmcia_ne(parent, match, aux, pc_link)
d207 1
a207 1
	if ((int)dev->param >= 0)
d213 2
a214 1
		printf("Cannot read cis info %d\n", err);
d216 1
a216 1
	if (ed_probe_Novell(sc, cf, ia)) {
d218 1
a218 1
		if ((int)dev->param >= 0) {
d238 2
a239 2
	}
	return 0;
d251 3
a253 3
	struct pcmciadevs *dev=pc_link->device;
	struct ed_softc *sc = (void *)self;
	int svec_card = strcmp(dev->manufacturer, "SVEC") == 0;
d255 1
a255 1
	err = pc_link->adapter->bus_link->bus_config(pc_link, self, pc_cf, cf);
d261 4
d294 2
a295 1
	return pc_link->adapter->bus_link->bus_unconfig(pc_link); 
d300 3
a302 2
} pcmcia_dlink= {
	"PCMCIA Novell compatible", edmod, ed_probe_pcmcia_ne, NULL, ed_remove
d318 1
a318 2
	/* probably not right for ethernet address--card does not seem to
	   have it anywhere. */
d320 6
a325 3
	(void *)0xb4, (void *)&pcmcia_dlink },
      { "ed", 0, "PMX   ", "PE-200", "ETHERNET", "R01", (void *) 0x110,
        (void *)&pcmcia_dlink }, /* 0x110 is a guess */
d328 39
d369 4
a1558 1
	u_char command;
a2470 1
	struct mbuf *mp;
@


1.10
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.9 1996/04/18 23:47:37 niklas Exp $	*/
d1858 2
a1859 2
			    (caddr_t) &packet_hdr, sizeof(packet_hdr));
		len = packet_hdr.count;
@


1.9
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ed.c,v 1.8 1996/03/20 01:00:46 mickey Exp $	*/
/*	$NetBSD: if_ed.c,v 1.90 1996/03/16 07:24:15 cgd Exp $	*/
a20 1
#include "pcmciabus.h"
d56 1
a56 1
#include <machine/pio.h>
a59 1
#include <i386/isa/isa_machdep.h>	/* XXX USES ISA HOLE DIRECTLY */
d82 6
a87 2
	int	asic_base;	/* Base ASIC I/O port */
	int	nic_base;	/* Base NIC (DS8390) I/O port */
d103 4
a106 4
	caddr_t	mem_start;	/* NIC memory start address */
	caddr_t	mem_end;	/* NIC memory end address */
	u_long	mem_size;	/* total NIC memory size */
	caddr_t	mem_ring;	/* start of RX ring-buffer (in NIC mem) */
d125 1
a125 1
int ed_probe_generic8390 __P((int));
d140 3
d146 2
a147 2
void edread __P((struct ed_softc *, caddr_t, int));
struct mbuf *edget __P((struct ed_softc *, caddr_t, int));
d150 1
a150 1
static inline caddr_t ed_ring_copy __P((struct ed_softc *, caddr_t, caddr_t,
d157 6
a162 2
struct cfdriver edcd = {
	NULL, "ed", edprobe, edattach, DV_IFNET, sizeof(struct ed_softc)
d169 4
a172 2
#define	NIC_PUT(base, off, val)	outb((base) + (off), (val))
#define	NIC_GET(base, off)	inb((base) + (off))
d174 1
d374 3
a376 1
ed_probe_generic8390(nicbase)
d380 1
a380 1
	if ((NIC_GET(nicbase, ED_P0_CR) &
d384 1
a384 1
	if ((NIC_GET(nicbase, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)
d402 3
a404 1
	int i;
d407 1
d410 7
a416 1
	sc->asic_base = asicbase = ia->ia_iobase;
d421 1
a421 1
	outb(asicbase + ED_WD_MSR, ED_WD_MSR_POW);
d432 1
a432 1
		sum += inb(asicbase + ED_WD_PROM + i);
d440 4
a443 3
		if (inb(asicbase + ED_WD_CARD_ID) != ED_TYPE_WD8003E ||
		    inb(asicbase + ED_WD_PROM + 7) != 0)
			return (0);
d448 2
a449 1
	outb(asicbase + ED_WD_MSR, ED_WD_MSR_RST | ED_WD_MSR_POW);
d451 1
a451 1
	outb(asicbase + ED_WD_MSR, ED_WD_MSR_RST);
d454 2
a455 2
	outb(asicbase + ED_WD_MSR,
	    inb(asicbase + ED_WD_MSR) & ~ED_WD_MSR_RST);
d460 1
a460 1
	sc->type = inb(asicbase + ED_WD_CARD_ID);
d515 5
a519 3
		outb(asicbase + ED_WD790_HWR,
			inb(asicbase + ED_WD790_HWR) | ED_WD790_HWR_SWH);
		switch (inb(asicbase + ED_WD790_RAR) & ED_WD790_RAR_SZ64) {
d536 3
a538 2
		outb(asicbase + ED_WD790_HWR,
			inb(asicbase + ED_WD790_HWR) & ~ED_WD790_HWR_SWH);
d567 2
a568 1
	    ((inb(asicbase + ED_WD_ICR) & ED_WD_ICR_16BIT) == 0)) {
d599 3
a601 3
		outb(ia->ia_iobase + ED_WD790_HWR,
		    inb(ia->ia_iobase + ED_WD790_HWR) | ED_WD790_HWR_SWH);
		x = inb(ia->ia_iobase + ED_WD790_GCR);
d604 2
a605 2
		outb(ia->ia_iobase + ED_WD790_HWR,
		    inb(ia->ia_iobase + ED_WD790_HWR) & ~ED_WD790_HWR_SWH);
d615 1
a615 1
				return (0);
d620 2
a621 2
		outb(ia->ia_iobase + ED_WD790_ICR,
		    inb(ia->ia_iobase + ED_WD790_ICR) | ED_WD790_ICR_EIL);
d624 2
a625 2
		iptr = (inb(ia->ia_iobase + ED_WD_ICR) & ED_WD_ICR_IR2) |
		    ((inb(ia->ia_iobase + ED_WD_IRR) &
d636 1
a636 1
				return (0);
d641 2
a642 2
		outb(ia->ia_iobase + ED_WD_IRR,
		    inb(ia->ia_iobase + ED_WD_IRR) | ED_WD_IRR_IEN);
d647 1
a647 1
			return (0);
d656 4
a659 1
	sc->mem_start = ISA_HOLE_VADDR(ia->ia_maddr);
d677 1
a677 1
		    inb(asicbase + ED_WD_PROM + i);
d685 1
a685 1
			    inb(asicbase + ED_WD_LAAR) &
d690 1
a690 1
			    ((kvtop(sc->mem_start) >> 19) &
d693 1
a693 1
		outb(asicbase + ED_WD_LAAR,
d703 1
a703 1
			    ((kvtop(sc->mem_start) >> 19) &
d705 1
a705 1
			outb(asicbase + ED_WD_LAAR,
d715 4
a718 4
		outb(asicbase + ED_WD_MSR + 1,
		    ((kvtop(sc->mem_start) >> 8) & 0xe0) | 4);
		outb(asicbase + ED_WD_MSR + 2,
		    ((kvtop(sc->mem_start) >> 16) & 0x0f));
d722 1
a722 1
		    (kvtop(sc->mem_start) >> 13) & ED_WD_MSR_ADDR;
d726 8
a733 8
		outb(asicbase + 0x04,
		    inb(asicbase + 0x04) | 0x80);
		outb(asicbase + 0x0b,
		    ((kvtop(sc->mem_start) >> 13) & 0x0f) |
		    ((kvtop(sc->mem_start) >> 11) & 0x40) |
		    (inb(asicbase + 0x0b) & 0xb0));
		outb(asicbase + 0x04,
		    inb(asicbase + 0x04) & ~0x80);
d737 1
a737 1
	outb(asicbase + ED_WD_MSR,
d740 2
a741 2
	(void) inb(0x84);
	(void) inb(0x84);
d744 2
a745 1
	bzero(sc->mem_start, memsize);
d748 1
a748 1
		if (sc->mem_start[i]) {
d751 1
a751 1
			    kvtop(sc->mem_start + i));
d754 1
a754 1
			outb(asicbase + ED_WD_MSR,
d757 1
a757 1
				outb(asicbase + ED_WD_LAAR,
d759 3
a761 3
			(void) inb(0x84);
			(void) inb(0x84);
			return (0);
d772 1
a772 1
	outb(asicbase + ED_WD_MSR, sc->wd_msr_proto);
d774 4
a777 3
		outb(asicbase + ED_WD_LAAR, sc->wd_laar_proto);
	(void) inb(0x84);
	(void) inb(0x84);
d780 18
a797 1
	return (1);
d815 4
a818 1
	int i;
d823 8
a830 2
	sc->asic_base = asicbase = ia->ia_iobase + ED_3COM_ASIC_OFFSET;
	sc->nic_base = nicbase = ia->ia_iobase + ED_3COM_NIC_OFFSET;
d840 1
a840 1
	x = inb(asicbase + ED_3COM_BCFR);
d842 1
a842 1
		return (0);
d849 1
a849 1
			return (0);
d852 1
a852 1
		ia->ia_iobase = ed_3com_iobase[ptr];
d854 1
a854 1
	x = inb(asicbase + ED_3COM_PCFR);
d856 1
a856 1
		return (0);
d863 1
a863 1
			return (0);
d869 2
a870 1
	x = inb(asicbase + ED_3COM_IDCFR) & ED_3COM_IDCFR_IRQ;
d872 1
a872 1
		return (0);
d879 1
a879 1
			return (0);
d890 2
a891 1
	outb(asicbase + ED_3COM_CR, ED_3COM_CR_RST | ED_3COM_CR_XSEL);
d901 1
a901 1
	outb(asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);
d923 2
a924 1
	outb(asicbase + ED_3COM_CR, ED_3COM_CR_EALO | ED_3COM_CR_XSEL);
d927 1
a927 1
		sc->sc_arpcom.ac_enaddr[i] = NIC_GET(nicbase, i);
d934 1
a934 1
	outb(asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);
d939 2
a940 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d946 1
a946 1
	NIC_PUT(nicbase, ED_P0_DCR, 0);
d949 2
a950 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);
d953 1
a953 1
	if (NIC_GET(nicbase, ED_P2_DCR) & ED_DCR_WTS)
d959 2
a960 1
	NIC_PUT(nicbase, ED_P2_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d962 4
a965 1
	sc->mem_start = ISA_HOLE_VADDR(ia->ia_maddr);
d1006 2
a1007 2
	outb(asicbase + ED_3COM_PSTR, sc->rec_page_start);
	outb(asicbase + ED_3COM_PSPR, sc->rec_page_stop);
d1012 2
a1013 1
		outb(asicbase + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ2);
d1016 2
a1017 1
		outb(asicbase + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ3);
d1020 2
a1021 1
		outb(asicbase + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ4);
d1024 2
a1025 1
		outb(asicbase + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ5);
d1030 1
a1030 1
		return (0);
d1037 1
a1037 1
	outb(asicbase + ED_3COM_GACFR,
d1046 3
a1048 3
	outb(asicbase + ED_3COM_VPTR2, 0xff);
	outb(asicbase + ED_3COM_VPTR1, 0xff);
	outb(asicbase + ED_3COM_VPTR0, 0x00);
d1051 2
a1052 1
	bzero(sc->mem_start, memsize);
d1055 1
a1055 1
		if (sc->mem_start[i]) {
d1057 3
a1059 2
			    sc->sc_dev.dv_xname, kvtop(sc->mem_start + i));
			return (0);
d1064 18
a1081 1
	return (1);
d1093 3
d1100 7
a1106 1
	int asicbase, nicbase;
d1108 2
a1109 2
	sc->asic_base = asicbase = ia->ia_iobase + ED_NOVELL_ASIC_OFFSET;
	sc->nic_base = nicbase = ia->ia_iobase + ED_NOVELL_NIC_OFFSET;
d1115 1
a1115 1
	outb(asicbase + ED_NOVELL_RESET, 0);
d1118 1
a1118 1
	tmp = inb(asicbase + ED_NOVELL_RESET);
d1128 1
a1128 1
	outb(asicbase + ED_NOVELL_RESET, tmp);
d1137 2
a1138 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d1143 2
a1144 2
	if (!ed_probe_generic8390(nicbase))
		return (0);
d1160 1
a1160 1
	NIC_PUT(nicbase, ED_P0_RCR, ED_RCR_MON);
d1163 1
a1163 1
	NIC_PUT(nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1165 2
a1166 2
	NIC_PUT(nicbase, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);
	NIC_PUT(nicbase, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);
d1171 6
d1187 1
a1187 1
		NIC_PUT(nicbase, ED_P0_DCR,
d1189 2
a1190 2
		NIC_PUT(nicbase, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);
		NIC_PUT(nicbase, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);
d1202 1
a1202 1
			return (0); /* not an NE2000 either */
d1214 1
a1214 1
		return (0);
d1228 1
a1228 1
	sc->mem_start = (caddr_t)(8192 + sc->isa16bit * 8192);
d1259 1
a1259 1
			return (0);
d1315 1
a1315 1
	NIC_PUT(nicbase, ED_P0_ISR, 0xff);
d1318 16
a1333 1
	return (1);
d1344 2
d1352 6
d1366 1
a1366 1
	ifp->if_name = edcd.cd_name;
d1385 2
a1386 1
		if ((inb(asicbase + ED_WD_IRR) & ED_WD_IRR_OUT2) == 0)
d1399 2
a1400 1
	printf(": address %s, ", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d1429 2
a1430 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_NET, edintr,
	    sc, sc->sc_dev.dv_xname);
d1456 2
d1462 2
a1463 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1470 2
a1471 1
	while (((NIC_GET(nicbase, ED_P0_ISR) & ED_ISR_RST) == 0) && --n);
d1482 1
a1482 1
	struct ed_softc *sc = edcd.cd_devs[unit];
d1497 2
d1519 2
a1520 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1527 1
a1527 1
		NIC_PUT(nicbase, ED_P0_DCR,
d1531 1
a1531 1
		NIC_PUT(nicbase, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1535 2
a1536 2
	NIC_PUT(nicbase, ED_P0_RBCR0, 0);
	NIC_PUT(nicbase, ED_P0_RBCR1, 0);
d1539 1
a1539 1
	NIC_PUT(nicbase, ED_P0_RCR, ED_RCR_MON);
d1542 1
a1542 1
	NIC_PUT(nicbase, ED_P0_TCR, ED_TCR_LB0);
d1546 1
a1546 1
		NIC_PUT(nicbase, 0x09, 0);
d1549 3
a1551 3
	NIC_PUT(nicbase, ED_P0_BNRY, sc->rec_page_start);
	NIC_PUT(nicbase, ED_P0_PSTART, sc->rec_page_start);
	NIC_PUT(nicbase, ED_P0_PSTOP, sc->rec_page_stop);
d1557 1
a1557 1
	NIC_PUT(nicbase, ED_P0_ISR, 0xff);
d1565 1
a1565 1
	NIC_PUT(nicbase, ED_P0_IMR,
d1570 2
a1571 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);
d1575 2
a1576 1
		NIC_PUT(nicbase, ED_P1_PAR0 + i, sc->sc_arpcom.ac_enaddr[i]);
d1581 1
a1581 1
		NIC_PUT(nicbase, ED_P1_MAR0 + i, ((u_char *)mcaf)[i]);
d1588 1
a1588 1
	NIC_PUT(nicbase, ED_P1_CURR, sc->next_packet);
d1591 2
a1592 1
	NIC_PUT(nicbase, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1602 1
a1602 1
	NIC_PUT(nicbase, ED_P0_RCR, i);
d1605 1
a1605 1
	NIC_PUT(nicbase, ED_P0_TCR, 0);
d1615 1
a1615 1
			outb(asicbase + ED_3COM_CR, 0);
d1617 2
a1618 1
			outb(asicbase + ED_3COM_CR, ED_3COM_CR_XSEL);
d1623 1
a1623 1
		x = inb(asicbase + ED_WD_IRR);
d1628 1
a1628 1
		outb(asicbase + ED_WD_IRR, x);
d1633 2
a1634 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1651 2
d1660 2
a1661 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1664 1
a1664 1
	NIC_PUT(nicbase, ED_P0_TPSR, sc->tx_page_start +
d1668 2
a1669 2
	NIC_PUT(nicbase, ED_P0_TBCR0, len);
	NIC_PUT(nicbase, ED_P0_TBCR1, len >> 8);
d1672 1
a1672 1
	NIC_PUT(nicbase, ED_P0_CR,
d1697 3
a1699 1
	struct ed_softc *sc = edcd.cd_devs[ifp->if_unit];
d1701 1
a1701 1
	caddr_t buffer;
d1703 1
a1703 1
	int len;
d1731 2
a1732 1
	buffer = sc->mem_start + ((sc->txb_new * ED_TXBUF_SIZE) << ED_PAGE_SHIFT);
d1744 2
a1745 1
				outb(asicbase + ED_3COM_GACFR,
d1754 1
a1754 1
				outb(asicbase + ED_WD_LAAR,
d1756 1
a1756 1
			outb(asicbase + ED_WD_MSR,
d1758 2
a1759 2
			(void) inb(0x84);
			(void) inb(0x84);
d1764 2
a1765 1
			bcopy(mtod(m, caddr_t), buffer, m->m_len);
d1774 2
a1775 1
				outb(asicbase + ED_3COM_GACFR,
d1779 1
a1779 1
			outb(asicbase + ED_WD_MSR,
d1782 1
a1782 1
				outb(asicbase + ED_WD_LAAR,
d1784 2
a1785 2
			(void) inb(0x84);
			(void) inb(0x84);
d1814 2
d1821 1
a1821 1
	caddr_t packet_ptr;
d1825 2
a1826 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);
d1836 1
a1836 1
	current = NIC_GET(nicbase, ED_P1_CURR);
d1841 2
a1842 1
	NIC_PUT(nicbase, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1854 2
a1855 1
			packet_hdr = *(struct ed_ring *)packet_ptr;
d1923 1
a1923 1
		NIC_PUT(nicbase, ED_P0_BNRY, boundary);
d1935 2
d1942 2
a1943 1
	NIC_PUT(nicbase, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1945 1
a1945 1
	isr = NIC_GET(nicbase, ED_P0_ISR);
d1956 1
a1956 1
		NIC_PUT(nicbase, ED_P0_ISR, isr);
d1963 2
a1964 1
			u_char collisions = NIC_GET(nicbase, ED_P0_NCR) & 0x0f;
d1975 1
a1975 1
			(void) NIC_GET(nicbase, ED_P0_TSR);
d1980 2
a1981 2
				if ((NIC_GET(nicbase, ED_P0_TSR) & ED_TSR_ABT)
				    && (collisions == 0)) {
d2073 6
a2078 3
						outb(asicbase + ED_WD_LAAR,
						    sc->wd_laar_proto | ED_WD_LAAR_M16EN);
					outb(asicbase + ED_WD_MSR,
d2080 3
a2082 2
					(void) inb(0x84);
					(void) inb(0x84);
d2089 2
a2090 1
					outb(asicbase + ED_WD_MSR,
d2093 2
a2094 1
						outb(asicbase + ED_WD_LAAR,
d2096 3
a2098 2
					(void) inb(0x84);
					(void) inb(0x84);
d2116 1
a2116 1
		NIC_PUT(nicbase, ED_P0_CR,
d2125 3
a2127 3
			(void) NIC_GET(nicbase, ED_P0_CNTR0);
			(void) NIC_GET(nicbase, ED_P0_CNTR1);
			(void) NIC_GET(nicbase, ED_P0_CNTR2);
d2130 1
a2130 1
		isr = NIC_GET(nicbase, ED_P0_ISR);
d2145 1
a2145 1
	struct ed_softc *sc = edcd.cd_devs[ifp->if_unit];
d2254 1
a2254 2
	caddr_t buf;
	int len;
d2317 2
d2322 2
a2323 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2330 2
a2331 2
	NIC_PUT(nicbase, ED_P0_RBCR0, amount);
	NIC_PUT(nicbase, ED_P0_RBCR1, amount >> 8);
d2334 2
a2335 2
	NIC_PUT(nicbase, ED_P0_RSAR0, src);
	NIC_PUT(nicbase, ED_P0_RSAR1, src >> 8);
d2337 2
a2338 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);
d2341 2
a2342 1
		insw(sc->asic_base + ED_NOVELL_DATA, dst, amount / 2);
d2344 2
a2345 1
		insb(sc->asic_base + ED_NOVELL_DATA, dst, amount);
d2359 2
d2365 2
a2366 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2369 1
a2369 1
	NIC_PUT(nicbase, ED_P0_ISR, ED_ISR_RDC);
d2372 2
a2373 2
	NIC_PUT(nicbase, ED_P0_RBCR0, len);
	NIC_PUT(nicbase, ED_P0_RBCR1, len >> 8);
d2376 2
a2377 2
	NIC_PUT(nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(nicbase, ED_P0_RSAR1, dst >> 8);
d2380 2
a2381 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
d2384 2
a2385 1
		outsw(sc->asic_base + ED_NOVELL_DATA, src, len / 2);
d2387 2
a2388 1
		outsb(sc->asic_base + ED_NOVELL_DATA, src, len);
d2397 2
a2398 2
	while (((NIC_GET(nicbase, ED_P0_ISR) & ED_ISR_RDC) != ED_ISR_RDC) &&
	    --maxwait);
d2411 2
d2421 2
a2422 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2425 1
a2425 1
	NIC_PUT(nicbase, ED_P0_ISR, ED_ISR_RDC);
d2428 2
a2429 2
	NIC_PUT(nicbase, ED_P0_RBCR0, len);
	NIC_PUT(nicbase, ED_P0_RBCR1, len >> 8);
d2432 2
a2433 2
	NIC_PUT(nicbase, ED_P0_RSAR0, dst);
	NIC_PUT(nicbase, ED_P0_RSAR1, dst >> 8);
d2436 2
a2437 1
	NIC_PUT(nicbase, ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
d2449 2
a2450 1
				outsb(asicbase + ED_NOVELL_DATA,
d2456 1
a2456 1
		u_char *data, savebyte[2];
d2464 1
a2464 1
			data = mtod(m, u_char *);
d2468 3
a2470 2
				outw(asicbase + ED_NOVELL_DATA,
				    *(u_short *)savebyte);
d2476 3
a2478 2
			if (len > 1)
				outsw(asicbase + ED_NOVELL_DATA,
d2480 1
d2491 2
a2492 1
			outw(asicbase + ED_NOVELL_DATA, *(u_short *)savebyte);
d2503 2
a2504 2
	while (((NIC_GET(nicbase, ED_P0_ISR) & ED_ISR_RDC) != ED_ISR_RDC) &&
	    --maxwait);
d2520 1
a2520 1
static inline caddr_t
d2523 2
a2524 1
	caddr_t src, dst;
d2535 1
a2535 1
			bcopy(src, dst, tmp_amount);
d2545 1
a2545 1
		bcopy(src, dst, amount);
d2563 1
a2563 1
	caddr_t src;
d2673 34
@


1.8
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_ed.c,v 1.7 1996/03/19 21:10:14 mickey Exp $	*/
/*	$NetBSD: if_ed.c,v 1.87 1996/01/10 16:49:25 chuck Exp $	*/
d84 2
a85 2
	int	asic_addr;	/* ASIC I/O bus address */
	int	nic_addr;	/* NIC (DS8390) I/O bus address */
d121 9
d160 2
a161 2
#define	NIC_PUT(sc, off, val)	outb(sc->nic_addr + off, val)
#define	NIC_GET(sc, off)	inb(sc->nic_addr + off)
d317 15
a331 1
	if (ed_probe_WD80x3(sc, cf, ia))
d333 1
a333 1
	if (ed_probe_3Com(sc, cf, ia))
d335 1
a335 1
	if (ed_probe_Novell(sc, cf, ia))
d362 2
a363 2
ed_probe_generic8390(sc)
	struct ed_softc *sc;
d366 1
a366 1
	if ((NIC_GET(sc, ED_P0_CR) &
d370 1
a370 1
	if ((NIC_GET(sc, ED_P0_ISR) & ED_ISR_RST) != ED_ISR_RST)
d383 1
a383 1
ed_probe_WD80x3(sc, cf, ia)
d391 1
d393 2
a394 2
	sc->asic_addr = ia->ia_iobase;
	sc->nic_addr = sc->asic_addr + ED_WD_NIC_OFFSET;
d398 1
a398 1
	outb(sc->asic_addr + ED_WD_MSR, ED_WD_MSR_POW);
d409 1
a409 1
		sum += inb(sc->asic_addr + ED_WD_PROM + i);
d417 2
a418 2
		if (inb(sc->asic_addr + ED_WD_CARD_ID) != ED_TYPE_WD8003E ||
		    inb(sc->asic_addr + ED_WD_PROM + 7) != 0)
d424 1
a424 1
	outb(sc->asic_addr + ED_WD_MSR, ED_WD_MSR_RST | ED_WD_MSR_POW);
d426 1
a426 1
	outb(sc->asic_addr + ED_WD_MSR, ED_WD_MSR_RST);
d429 2
a430 2
	outb(sc->asic_addr + ED_WD_MSR,
	    inb(sc->asic_addr + ED_WD_MSR) & ~ED_WD_MSR_RST);
d435 1
a435 1
	sc->type = inb(sc->asic_addr + ED_WD_CARD_ID);
d464 1
a464 1
		if (inb(sc->asic_addr + ED_WD_ICR) & ED_WD_ICR_16BIT) {
d490 3
a492 3
		outb(sc->asic_addr + ED_WD790_HWR,
			inb(sc->asic_addr + ED_WD790_HWR) | ED_WD790_HWR_SWH);
		switch (inb(sc->asic_addr + ED_WD790_RAR) & ED_WD790_RAR_SZ64) {
d509 2
a510 2
		outb(sc->asic_addr + ED_WD790_HWR,
			inb(sc->asic_addr + ED_WD790_HWR) & ~ED_WD790_HWR_SWH);
d539 1
a539 1
	    ((inb(sc->asic_addr + ED_WD_ICR) & ED_WD_ICR_16BIT) == 0)) {
d549 1
a549 1
		printf("%x -> %x\n", i, inb(sc->asic_addr + i));
d645 1
a645 1
		    inb(sc->asic_addr + ED_WD_PROM + i);
d653 1
a653 1
			    inb(sc->asic_addr + ED_WD_LAAR) &
d661 1
a661 1
		outb(sc->asic_addr + ED_WD_LAAR,
d673 1
a673 1
			outb(sc->asic_addr + ED_WD_LAAR,
d683 1
a683 1
		outb(sc->asic_addr + ED_WD_MSR + 1,
d685 1
a685 1
		outb(sc->asic_addr + ED_WD_MSR + 2,
d694 3
a696 3
		outb(sc->asic_addr + 0x04,
		    inb(sc->asic_addr + 0x04) | 0x80);
		outb(sc->asic_addr + 0x0b,
d699 3
a701 3
		    (inb(sc->asic_addr + 0x0b) & 0xb0));
		outb(sc->asic_addr + 0x04,
		    inb(sc->asic_addr + 0x04) & ~0x80);
d705 1
a705 1
	outb(sc->asic_addr + ED_WD_MSR,
d721 1
a721 1
			outb(sc->asic_addr + ED_WD_MSR,
d724 1
a724 1
				outb(sc->asic_addr + ED_WD_LAAR,
d739 1
a739 1
	outb(sc->asic_addr + ED_WD_MSR, sc->wd_msr_proto);
d741 1
a741 1
		outb(sc->asic_addr + ED_WD_LAAR, sc->wd_laar_proto);
d759 1
a759 1
ed_probe_3Com(sc, cf, ia)
d767 1
a767 1
	int ptr;
d769 2
a770 2
	sc->asic_addr = ia->ia_iobase + ED_3COM_ASIC_OFFSET;
	sc->nic_addr = ia->ia_iobase + ED_3COM_NIC_OFFSET;
d780 1
a780 1
	x = inb(sc->asic_addr + ED_3COM_BCFR);
d794 1
a794 1
	x = inb(sc->asic_addr + ED_3COM_PCFR);
d809 1
a809 1
	x = inb(sc->asic_addr + ED_3COM_IDCFR) & ED_3COM_IDCFR_IRQ;
d829 1
a829 1
	outb(sc->asic_addr + ED_3COM_CR, ED_3COM_CR_RST | ED_3COM_CR_XSEL);
d839 1
a839 1
	outb(sc->asic_addr + ED_3COM_CR, ED_3COM_CR_XSEL);
d861 1
a861 1
	outb(sc->asic_addr + ED_3COM_CR, ED_3COM_CR_EALO | ED_3COM_CR_XSEL);
d864 1
a864 1
		sc->sc_arpcom.ac_enaddr[i] = NIC_GET(sc, i);
d871 1
a871 1
	outb(sc->asic_addr + ED_3COM_CR, ED_3COM_CR_XSEL);
d876 1
a876 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d882 1
a882 1
	NIC_PUT(sc, ED_P0_DCR, 0);
d885 1
a885 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_2 | ED_CR_STP);
d888 1
a888 1
	if (NIC_GET(sc, ED_P2_DCR) & ED_DCR_WTS)
d894 1
a894 1
	NIC_PUT(sc, ED_P2_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d937 2
a938 2
	outb(sc->asic_addr + ED_3COM_PSTR, sc->rec_page_start);
	outb(sc->asic_addr + ED_3COM_PSPR, sc->rec_page_stop);
d943 1
a943 1
		outb(sc->asic_addr + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ2);
d946 1
a946 1
		outb(sc->asic_addr + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ3);
d949 1
a949 1
		outb(sc->asic_addr + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ4);
d952 1
a952 1
		outb(sc->asic_addr + ED_3COM_IDCFR, ED_3COM_IDCFR_IRQ5);
d964 1
a964 1
	outb(sc->asic_addr + ED_3COM_GACFR,
d973 3
a975 3
	outb(sc->asic_addr + ED_3COM_VPTR2, 0xff);
	outb(sc->asic_addr + ED_3COM_VPTR1, 0xff);
	outb(sc->asic_addr + ED_3COM_VPTR0, 0x00);
d996 1
a996 1
ed_probe_Novell(sc, cf, ia)
d1005 1
d1007 2
a1008 2
	sc->asic_addr = ia->ia_iobase + ED_NOVELL_ASIC_OFFSET;
	sc->nic_addr = ia->ia_iobase + ED_NOVELL_NIC_OFFSET;
d1014 1
a1014 1
	outb(sc->asic_addr + ED_NOVELL_RESET, 0);
d1017 1
a1017 1
	tmp = inb(sc->asic_addr + ED_NOVELL_RESET);
d1027 1
a1027 1
	outb(sc->asic_addr + ED_NOVELL_RESET, tmp);
d1036 1
a1036 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STP);
d1041 1
a1041 1
	if (!ed_probe_generic8390(sc))
d1058 1
a1058 1
	NIC_PUT(sc, ED_P0_RCR, ED_RCR_MON);
d1061 1
a1061 1
	NIC_PUT(sc, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1063 2
a1064 2
	NIC_PUT(sc, ED_P0_PSTART, 8192 >> ED_PAGE_SHIFT);
	NIC_PUT(sc, ED_P0_PSTOP, 16384 >> ED_PAGE_SHIFT);
d1079 1
a1079 1
		NIC_PUT(sc, ED_P0_DCR,
d1081 2
a1082 2
		NIC_PUT(sc, ED_P0_PSTART, 16384 >> ED_PAGE_SHIFT);
		NIC_PUT(sc, ED_P0_PSTOP, 32768 >> ED_PAGE_SHIFT);
d1207 1
a1207 1
	NIC_PUT(sc, ED_P0_ISR, 0xff);
d1225 4
d1254 1
a1254 1
		if ((inb(sc->asic_addr + ED_WD_IRR) & ED_WD_IRR_OUT2) == 0)
d1323 1
d1327 1
a1327 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1334 1
a1334 1
	while (((NIC_GET(sc, ED_P0_ISR) & ED_ISR_RST) == 0) && --n);
d1361 1
d1380 1
a1380 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1387 2
a1388 1
		NIC_PUT(sc, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_WTS | ED_DCR_LS);
d1391 1
a1391 1
		NIC_PUT(sc, ED_P0_DCR, ED_DCR_FT1 | ED_DCR_LS);
d1395 2
a1396 2
	NIC_PUT(sc, ED_P0_RBCR0, 0);
	NIC_PUT(sc, ED_P0_RBCR1, 0);
d1399 1
a1399 1
	NIC_PUT(sc, ED_P0_RCR, ED_RCR_MON);
d1402 1
a1402 1
	NIC_PUT(sc, ED_P0_TCR, ED_TCR_LB0);
d1406 1
a1406 1
		NIC_PUT(sc, 0x09, 0);
d1409 3
a1411 3
	NIC_PUT(sc, ED_P0_BNRY, sc->rec_page_start);
	NIC_PUT(sc, ED_P0_PSTART, sc->rec_page_start);
	NIC_PUT(sc, ED_P0_PSTOP, sc->rec_page_stop);
d1417 1
a1417 1
	NIC_PUT(sc, ED_P0_ISR, 0xff);
d1425 1
a1425 1
	NIC_PUT(sc, ED_P0_IMR,
d1430 1
a1430 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STP);
d1434 1
a1434 1
		NIC_PUT(sc, ED_P1_PAR0 + i, sc->sc_arpcom.ac_enaddr[i]);
d1439 1
a1439 1
		NIC_PUT(sc, ED_P1_MAR0 + i, ((u_char *)mcaf)[i]);
d1446 1
a1446 1
	NIC_PUT(sc, ED_P1_CURR, sc->next_packet);
d1449 1
a1449 1
	NIC_PUT(sc, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STP);
d1459 1
a1459 1
	NIC_PUT(sc, ED_P0_RCR, i);
d1462 1
a1462 1
	NIC_PUT(sc, ED_P0_TCR, 0);
d1472 1
a1472 1
			outb(sc->asic_addr + ED_3COM_CR, 0);
d1474 1
a1474 1
			outb(sc->asic_addr + ED_3COM_CR, ED_3COM_CR_XSEL);
d1479 1
a1479 1
		x = inb(sc->asic_addr + ED_WD_IRR);
d1484 1
a1484 1
		outb(sc->asic_addr + ED_WD_IRR, x);
d1489 1
a1489 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1507 1
d1513 1
a1513 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1516 1
a1516 1
	NIC_PUT(sc, ED_P0_TPSR, sc->tx_page_start +
d1520 2
a1521 2
	NIC_PUT(sc, ED_P0_TBCR0, len);
	NIC_PUT(sc, ED_P0_TBCR1, len >> 8);
d1524 2
a1525 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_TXP | ED_CR_STA);
d1552 1
d1593 1
a1593 1
				outb(sc->asic_addr + ED_3COM_GACFR,
d1602 1
a1602 1
				outb(sc->asic_addr + ED_WD_LAAR,
d1604 1
a1604 1
			outb(sc->asic_addr + ED_WD_MSR,
d1621 1
a1621 1
				outb(sc->asic_addr + ED_3COM_GACFR,
d1625 1
a1625 1
			outb(sc->asic_addr + ED_WD_MSR,
d1628 1
a1628 1
				outb(sc->asic_addr + ED_WD_LAAR,
d1660 1
d1669 1
a1669 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_1 | ED_CR_STA);
d1679 1
a1679 1
	current = NIC_GET(sc, ED_P1_CURR);
d1684 1
a1684 1
	NIC_PUT(sc, ED_P1_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1764 1
a1764 1
		NIC_PUT(sc, ED_P0_BNRY, boundary);
d1777 1
d1781 1
a1781 1
	NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1783 1
a1783 1
	isr = NIC_GET(sc, ED_P0_ISR);
d1794 1
a1794 1
		NIC_PUT(sc, ED_P0_ISR, isr);
d1801 1
a1801 1
			u_char collisions = NIC_GET(sc, ED_P0_NCR) & 0x0f;
d1812 1
a1812 1
			(void) NIC_GET(sc, ED_P0_TSR);
d1817 1
a1817 1
				if ((NIC_GET(sc, ED_P0_TSR) & ED_TSR_ABT)
d1892 1
a1892 1
					    NIC_GET(sc, ED_P0_RSR));
d1910 1
a1910 1
						outb(sc->asic_addr + ED_WD_LAAR,
d1912 1
a1912 1
					outb(sc->asic_addr + ED_WD_MSR,
d1922 1
a1922 1
					outb(sc->asic_addr + ED_WD_MSR,
d1925 1
a1925 1
						outb(sc->asic_addr + ED_WD_LAAR,
d1946 2
a1947 1
		NIC_PUT(sc, ED_P0_CR, sc->cr_proto | ED_CR_PAGE_0 | ED_CR_STA);
d1955 3
a1957 3
			(void) NIC_GET(sc, ED_P0_CNTR0);
			(void) NIC_GET(sc, ED_P0_CNTR1);
			(void) NIC_GET(sc, ED_P0_CNTR2);
d1960 1
a1960 1
		isr = NIC_GET(sc, ED_P0_ISR);
d2088 1
a2088 1
    	struct mbuf *m;
d2148 2
d2151 1
a2151 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2158 2
a2159 2
	NIC_PUT(sc, ED_P0_RBCR0, amount);
	NIC_PUT(sc, ED_P0_RBCR1, amount >> 8);
d2162 2
a2163 2
	NIC_PUT(sc, ED_P0_RSAR0, src);
	NIC_PUT(sc, ED_P0_RSAR1, src >> 8);
d2165 1
a2165 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD0 | ED_CR_PAGE_0 | ED_CR_STA);
d2168 1
a2168 1
		insw(sc->asic_addr + ED_NOVELL_DATA, dst, amount / 2);
d2170 1
a2170 1
		insb(sc->asic_addr + ED_NOVELL_DATA, dst, amount);
d2184 1
d2188 1
a2188 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2191 1
a2191 1
	NIC_PUT(sc, ED_P0_ISR, ED_ISR_RDC);
d2194 2
a2195 2
	NIC_PUT(sc, ED_P0_RBCR0, len);
	NIC_PUT(sc, ED_P0_RBCR1, len >> 8);
d2198 2
a2199 2
	NIC_PUT(sc, ED_P0_RSAR0, dst);
	NIC_PUT(sc, ED_P0_RSAR1, dst >> 8);
d2202 1
a2202 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
d2205 1
a2205 1
		outsw(sc->asic_addr + ED_NOVELL_DATA, src, len / 2);
d2207 1
a2207 1
		outsb(sc->asic_addr + ED_NOVELL_DATA, src, len);
d2216 2
a2217 1
	while (((NIC_GET(sc, ED_P0_ISR) & ED_ISR_RDC) != ED_ISR_RDC) && --maxwait);
d2230 1
d2238 1
a2238 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD2 | ED_CR_PAGE_0 | ED_CR_STA);
d2241 1
a2241 1
	NIC_PUT(sc, ED_P0_ISR, ED_ISR_RDC);
d2244 2
a2245 2
	NIC_PUT(sc, ED_P0_RBCR0, len);
	NIC_PUT(sc, ED_P0_RBCR1, len >> 8);
d2248 2
a2249 2
	NIC_PUT(sc, ED_P0_RSAR0, dst);
	NIC_PUT(sc, ED_P0_RSAR1, dst >> 8);
d2252 1
a2252 1
	NIC_PUT(sc, ED_P0_CR, ED_CR_RD1 | ED_CR_PAGE_0 | ED_CR_STA);
d2264 1
a2264 1
				outsb(sc->asic_addr + ED_NOVELL_DATA,
d2282 1
a2282 1
				outw(sc->asic_addr + ED_NOVELL_DATA,
d2290 1
a2290 1
				outsw(sc->asic_addr + ED_NOVELL_DATA,
d2302 1
a2302 2
			outw(sc->asic_addr + ED_NOVELL_DATA,
			    *(u_short *)savebyte);
d2313 2
a2314 1
	while (((NIC_GET(sc, ED_P0_ISR) & ED_ISR_RDC) != ED_ISR_RDC) && --maxwait);
@


1.7
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ed.c,v 1.6 1996/03/08 16:42:59 niklas Exp $	*/
d1268 1
a1268 1
	    sc);
@


1.6
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1268 1
a1268 1
	    sc, sc->sc_dev.dv_xname);
@


1.5
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: if_ed.c,v 1.85 1995/07/25 05:11:11 mycroft Exp $	*/
d62 1
@


1.4
log
@Last of the glue and devices for for PCMCIA support from Stefan Grefen
<grefen@@convex.com> with modifications by John Kohl <jtk@@kolvir.blrc.ma.us>
@
text
@d1266 1
a1266 1
	    sc);
@


1.3
log
@Imported from FreeBSD:
	Add support for the SMC8416 (EtherEZ) ISA ethernet card.
	The 8416 has an 8K shared mem (the old driver assumed 16K
	and failed at attach time).
@
text
@d20 1
d72 1
d77 4
d152 142
d1229 4
a1232 1
	if_attach(ifp);
d1260 3
a1262 1
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
d1267 1
d1941 6
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@a312 5
		sc->type_str = "SMC8216/SMC8216C";
		memsize = 16384;
		isa16bit = 1;
		sc->is790 = 1;
		break;
d314 24
a337 2
		sc->type_str = "SMC8216T";
		memsize = 16384;
@


1.1
log
@Initial revision
@
text
@d1095 2
a1096 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_NET,
	    edintr, sc);
d1108 1
a1108 1
	s = splimp();
d1332 1
a1332 1
 *  1) that the current priority is set to splimp _before_ this code
d1769 1
a1769 1
	s = splimp();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

