head	1.15;
access;
symbols
	OPENBSD_6_1:1.15.0.4
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.14.0.22
	OPENBSD_6_0_BASE:1.14
	OPENBSD_5_9:1.14.0.12
	OPENBSD_5_9_BASE:1.14
	OPENBSD_5_8:1.14.0.20
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.18
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.16
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.14
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.10
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.8
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.14.0.6
	OPENBSD_5_2_BASE:1.14
	OPENBSD_5_1_BASE:1.14
	OPENBSD_5_1:1.14.0.4
	OPENBSD_5_0:1.14.0.2
	OPENBSD_5_0_BASE:1.14
	OPENBSD_4_9:1.13.0.4
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.2
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.12.0.32
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.12.0.34
	OPENBSD_4_6_BASE:1.12
	OPENBSD_4_5:1.12.0.30
	OPENBSD_4_5_BASE:1.12
	OPENBSD_4_4:1.12.0.28
	OPENBSD_4_4_BASE:1.12
	OPENBSD_4_3:1.12.0.26
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.24
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.22
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.20
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.12.0.18
	OPENBSD_3_9_BASE:1.12
	OPENBSD_3_8:1.12.0.16
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.12.0.14
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.12
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.10
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.8
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.6
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.12.0.4
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.12.0.2
	OPENBSD_3_1_BASE:1.12
	UBC_SYNC_B:1.12
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.14
	OPENBSD_3_0_BASE:1.8
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.12
	OPENBSD_2_8:1.8.0.10
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.8
	OPENBSD_2_7_BASE:1.8
	SMP:1.8.0.6
	SMP_BASE:1.8
	kame_19991208:1.8
	OPENBSD_2_6:1.8.0.4
	OPENBSD_2_6_BASE:1.8
	OPENBSD_2_5:1.8.0.2
	OPENBSD_2_5_BASE:1.8
	OPENBSD_2_4:1.7.0.2
	OPENBSD_2_4_BASE:1.7
	OPENBSD_2_3:1.5.0.2
	OPENBSD_2_3_BASE:1.5
	OPENBSD_2_2:1.4.0.2
	OPENBSD_2_2_BASE:1.4
	OPENBSD_2_1:1.3.0.4
	OPENBSD_2_1_BASE:1.3
	OPENBSD_2_0:1.3.0.2
	OPENBSD_2_0_BASE:1.3
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.14;
commitid	pi1a9KN0itEngOc4;

1.14
date	2011.06.29.17.48.22;	author tedu;	state Exp;
branches;
next	1.13;

1.13
date	2010.06.30.11.21.35;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.11;

1.11
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.10;

1.10
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	99.01.07.06.14.46;	author niklas;	state Exp;
branches
	1.8.6.1;
next	1.7;

1.7
date	98.05.08.18.37.20;	author csapuntz;	state Exp;
branches;
next	1.6;

1.6
date	98.04.26.21.02.39;	author provos;	state Exp;
branches;
next	1.5;

1.5
date	97.11.07.08.06.42;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	97.07.10.23.06.32;	author provos;	state Exp;
branches;
next	1.3;

1.3
date	96.05.07.07.36.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.05;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.33;	author deraadt;	state Exp;
branches;
next	;

1.8.6.1
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.8.6.2;

1.8.6.2
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.8.6.3;

1.8.6.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.06.11.03.42.20;	author art;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: ad1848var.h,v 1.13 2010/06/30 11:21:35 jakemsr Exp $	*/
/*	$NetBSD: ad1848var.h,v 1.22 1998/01/19 22:18:26 augustss Exp $	*/

/*
 * Copyright (c) 1994 John Brezak
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

#define AD1848_NPORT	4
#define	AD1848_TIMO	1000000

struct ad1848_volume {
	u_char	left;
	u_char	right;
};

struct ad1848_softc {
	struct	device sc_dev;		/* base device */
	struct	isadev sc_id;		/* ISA device */
	void	*sc_ih;			/* interrupt vectoring */
	bus_space_tag_t sc_iot;		/* tag */
	bus_space_handle_t sc_ioh;	/* handle */
	int	sc_iooffs;		/* offset from handle */

	void	*parent;
	struct	device *sc_isa;		/* ISA bus's device */

	char	sc_playrun;		/* running in continuous mode */
	char	sc_recrun;		/* running in continuous mode */

	int	sc_irq;			/* interrupt */
	int	sc_drq;			/* DMA */
	int	sc_recdrq;		/* record/capture DMA */
	
	int	sc_flags;
#define AD1848_FLAG_32REGS	0x01	/* newer chip (cs4231 compatible) */

	/* We keep track of these */
        struct ad1848_volume gains[6];

	struct ad1848_volume rec_gain;

	int	rec_port;		/* recording port */

	/* ad1848 */
	u_char	MCE_bit;
	char	mic_gain_on;		/* CS4231 only */
        char    mute[6];

	char	*chip_name;
	int	mode;
	
	u_int	precision;		/* 8/16 bits */
	int	channels;
	
	u_char	speed_bits;
	u_char	format_bits;
	u_char	need_commit;

	void	(*sc_pintr)(void *);	/* play dma completion intr handler */
	void	(*sc_rintr)(void *);	/* rec dma completion intr handler */
	void	*sc_parg;		/* play arg for sc_intr() */
	void	*sc_rarg;		/* rec arg for sc_intr() */

	int	sc_iobase;
};

#define MUTE_LEFT       1
#define MUTE_RIGHT      2
#define MUTE_ALL        (MUTE_LEFT | MUTE_RIGHT)
#define MUTE_MONO       MUTE_ALL

/* Don't change this ordering without seriously looking around.
   These are indexes into mute[] array and into a register information
   array */
#define AD1848_AUX2_CHANNEL        0
#define AD1848_AUX1_CHANNEL        1
#define AD1848_DAC_CHANNEL         2
#define AD1848_LINE_CHANNEL        3
#define AD1848_MONO_CHANNEL        4
#define AD1848_MONITOR_CHANNEL     5    /* Doesn't seem to be on all later chips */

/*
 * Ad1848 ports
 */
#define MIC_IN_PORT	0
#define LINE_IN_PORT	1
#define AUX1_IN_PORT	2
#define DAC_IN_PORT	3

#ifdef _KERNEL

#define AD1848_KIND_LVL   0
#define AD1848_KIND_MUTE  1
#define AD1848_KIND_RECORDGAIN 2
#define AD1848_KIND_MICGAIN 3
#define AD1848_KIND_RECORDSOURCE 4

typedef struct ad1848_devmap {
  int  id;
  int  kind;
  int  dev;
} ad1848_devmap_t;

static __inline int ad1848_to_vol(mixer_ctrl_t *, struct ad1848_volume *);
static __inline int ad1848_from_vol(mixer_ctrl_t *, struct ad1848_volume *);

static __inline int
ad1848_to_vol(cp, vol)
	mixer_ctrl_t *cp;
	struct ad1848_volume *vol;
{
	if (cp->un.value.num_channels == 1) {
		vol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		return(1);
	}
	else if (cp->un.value.num_channels == 2) {
		vol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		return(1);
	}
	return(0);
}

static __inline int
ad1848_from_vol(cp, vol)
	mixer_ctrl_t *cp;
	struct ad1848_volume *vol;
{
	if (cp->un.value.num_channels == 1) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;
		return(1);
	}
	else if (cp->un.value.num_channels == 2) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;
		return(1);
	}
	return(0);
}


int     ad1848_mixer_get_port(struct ad1848_softc *, ad1848_devmap_t *, int cnt, mixer_ctrl_t *);
int     ad1848_mixer_set_port(struct ad1848_softc *, ad1848_devmap_t *, int, mixer_ctrl_t *);
int	ad1848_mapprobe(struct ad1848_softc *, int);
int	ad1848_probe(struct ad1848_softc *);
void	ad1848_unmap(struct ad1848_softc *);
void	ad1848_attach(struct ad1848_softc *);

int	ad1848_open(void *, int);
void	ad1848_close(void *);
    
void	ad1848_forceintr(struct ad1848_softc *);

int	ad1848_set_params(void *, int, int, struct audio_params *, struct audio_params *);

int	ad1848_round_blocksize(void *, int);

int	ad1848_trigger_input(void *, void *, void *, int, void (*)(void *),
	void *, struct audio_params *);
int	ad1848_trigger_output(void *, void *, void *, int, void (*)(void *),
	void *, struct audio_params *);

int	ad1848_commit_settings(void *);

int	ad1848_halt_input(void *);
int	ad1848_halt_output(void *);

int	ad1848_intr(void *);

int	ad1848_set_rec_port(struct ad1848_softc *, int);
int	ad1848_get_rec_port(struct ad1848_softc *);

int	ad1848_set_channel_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_get_device_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_set_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
/* Note: The mic pre-MUX gain is not a variable gain, it's 20dB or 0dB */
int	ad1848_set_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
void     ad1848_mute_channel(struct ad1848_softc *, int device, int mute);

void   *ad1848_malloc(void *, int, size_t, int, int);
void	ad1848_free(void *, void *, int);
size_t	ad1848_round(void *, int, size_t);

int	ad1848_get_props(void *);

#endif
@


1.14
log
@dmesg@@ says pss has never been seen in the wild and the manpage says it
doesn't work.  goodbye.  ok miod
@
text
@a184 1
int	ad1848_query_encoding(void *, struct audio_encoding *);
a215 1
paddr_t	ad1848_mappage(void *, void *, off_t, int);
@


1.13
log
@* use audio(9)'s DMA trigger methods instead of the init/start
  methods.  the AD1848 DMA engine runs continuously and doesn't
  need to be started/stopped or otherwise manipulated for each
  block.  makes the driver a bit more efficient.
* allow "Mode 2" capable chips such as the CS4231 to work in "Mode 1"
  when there is only one DMA channel, instead of forcing it into
  "Mode 2", which expects two DMA channels.  allows recording to
  work for "Mode 2" capable devices when there is only one DMA
  channel.
* service both playback and recording interrupts in full-duplex
  mode, instead of only playback interrupts.  allows "Mode 2"
  capable chips to work in full-duplex mode.
* fix checks for sample rate/format recalibration completion.  gets
  rid of busy loops that briefly "hang" the kernel when the device is
  opened and/or reconfigured.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.12 2002/03/14 03:16:05 millert Exp $	*/
a94 1
	/* Only used by pss XXX */
@


1.12
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.11 2002/03/14 01:26:56 millert Exp $	*/
d40 1
a57 8
	u_short	sc_locked;		/* true when doing HS DMA  */
	u_int	sc_lastcc;		/* size of last DMA xfer */
	int	sc_mode;		/* half-duplex record/play */
	
	int	sc_dma_flags;
	void	*sc_dma_bp;
	u_int	sc_dma_cnt;

a59 3
#define NOTRUNNING 0
#define DMARUNNING 1
#define PCMRUNNING 2
d65 3
d90 4
a93 3
	u_long	sc_interrupts;		/* number of interrupts taken */
	void	(*sc_intr)(void *);	/* dma completion intr handler */
	void	*sc_arg;		/* arg for sc_intr() */
d191 4
a194 4
int	ad1848_dma_init_output(void *, void *, int);
int	ad1848_dma_init_input(void *, void *, int);
int	ad1848_dma_output(void *, void *, int, void (*)(void *), void *);
int	ad1848_dma_input(void *, void *, int, void (*)(void *), void *);
d198 2
a199 2
int	ad1848_halt_in_dma(void *);
int	ad1848_halt_out_dma(void *);
@


1.11
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.10 2002/01/20 19:56:53 ericj Exp $	*/
d199 2
a200 2
int	ad1848_dma_output __P((void *, void *, int, void (*)(void *), void*));
int	ad1848_dma_input __P((void *, void *, int, void (*)(void *), void*));
@


1.10
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.9 2001/10/31 11:00:24 art Exp $	*/
d142 2
a143 2
static __inline int ad1848_to_vol __P((mixer_ctrl_t *, struct ad1848_volume *));
static __inline int ad1848_from_vol __P((mixer_ctrl_t *, struct ad1848_volume *));
d180 6
a185 6
int     ad1848_mixer_get_port __P((struct ad1848_softc *, ad1848_devmap_t *, int cnt, mixer_ctrl_t *));
int     ad1848_mixer_set_port __P((struct ad1848_softc *, ad1848_devmap_t *, int, mixer_ctrl_t *));
int	ad1848_mapprobe __P((struct ad1848_softc *, int));
int	ad1848_probe __P((struct ad1848_softc *));
void	ad1848_unmap __P((struct ad1848_softc *));
void	ad1848_attach __P((struct ad1848_softc *));
d187 2
a188 2
int	ad1848_open __P((void *, int));
void	ad1848_close __P((void *));
d190 1
a190 1
void	ad1848_forceintr __P((struct ad1848_softc *));
d192 2
a193 2
int	ad1848_query_encoding __P((void *, struct audio_encoding *));
int	ad1848_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
d195 1
a195 1
int	ad1848_round_blocksize __P((void *, int));
d197 2
a198 2
int	ad1848_dma_init_output __P((void *, void *, int));
int	ad1848_dma_init_input __P((void *, void *, int));
d202 1
a202 1
int	ad1848_commit_settings __P((void *));
d204 2
a205 2
int	ad1848_halt_in_dma __P((void *));
int	ad1848_halt_out_dma __P((void *));
d207 1
a207 1
int	ad1848_intr __P((void *));
d209 2
a210 2
int	ad1848_set_rec_port __P((struct ad1848_softc *, int));
int	ad1848_get_rec_port __P((struct ad1848_softc *));
d212 4
a215 4
int	ad1848_set_channel_gain __P((struct ad1848_softc *, int, struct ad1848_volume *));
int	ad1848_get_device_gain __P((struct ad1848_softc *, int, struct ad1848_volume *));
int	ad1848_set_rec_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_rec_gain __P((struct ad1848_softc *, struct ad1848_volume *));
d217 8
a224 8
int	ad1848_set_mic_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_mic_gain __P((struct ad1848_softc *, struct ad1848_volume *));
void     ad1848_mute_channel __P((struct ad1848_softc *, int device, int mute));

void   *ad1848_malloc __P((void *, int, size_t, int, int));
void	ad1848_free __P((void *, void *, int));
size_t	ad1848_round __P((void *, int, size_t));
paddr_t	ad1848_mappage __P((void *, void *, off_t, int));
d226 1
a226 1
int	ad1848_get_props __P((void *));
@


1.9
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.8 1999/01/07 06:14:46 niklas Exp $	*/
d221 1
a221 1
void   *ad1848_malloc __P((void *, unsigned long, int, int));
d223 1
a223 1
unsigned long ad1848_round __P((void *, unsigned long));
@


1.9.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.10 2002/01/20 19:56:53 ericj Exp $	*/
d221 1
a221 1
void   *ad1848_malloc __P((void *, int, size_t, int, int));
d223 1
a223 1
size_t	ad1848_round __P((void *, int, size_t));
@


1.9.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.9.2.1 2002/01/31 22:55:32 niklas Exp $	*/
d142 2
a143 2
static __inline int ad1848_to_vol(mixer_ctrl_t *, struct ad1848_volume *);
static __inline int ad1848_from_vol(mixer_ctrl_t *, struct ad1848_volume *);
d180 6
a185 6
int     ad1848_mixer_get_port(struct ad1848_softc *, ad1848_devmap_t *, int cnt, mixer_ctrl_t *);
int     ad1848_mixer_set_port(struct ad1848_softc *, ad1848_devmap_t *, int, mixer_ctrl_t *);
int	ad1848_mapprobe(struct ad1848_softc *, int);
int	ad1848_probe(struct ad1848_softc *);
void	ad1848_unmap(struct ad1848_softc *);
void	ad1848_attach(struct ad1848_softc *);
d187 2
a188 2
int	ad1848_open(void *, int);
void	ad1848_close(void *);
d190 1
a190 1
void	ad1848_forceintr(struct ad1848_softc *);
d192 2
a193 2
int	ad1848_query_encoding(void *, struct audio_encoding *);
int	ad1848_set_params(void *, int, int, struct audio_params *, struct audio_params *);
d195 1
a195 1
int	ad1848_round_blocksize(void *, int);
d197 4
a200 4
int	ad1848_dma_init_output(void *, void *, int);
int	ad1848_dma_init_input(void *, void *, int);
int	ad1848_dma_output(void *, void *, int, void (*)(void *), void *);
int	ad1848_dma_input(void *, void *, int, void (*)(void *), void *);
d202 1
a202 1
int	ad1848_commit_settings(void *);
d204 2
a205 2
int	ad1848_halt_in_dma(void *);
int	ad1848_halt_out_dma(void *);
d207 1
a207 1
int	ad1848_intr(void *);
d209 2
a210 2
int	ad1848_set_rec_port(struct ad1848_softc *, int);
int	ad1848_get_rec_port(struct ad1848_softc *);
d212 4
a215 4
int	ad1848_set_channel_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_get_device_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_set_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
d217 8
a224 8
int	ad1848_set_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
void     ad1848_mute_channel(struct ad1848_softc *, int device, int mute);

void   *ad1848_malloc(void *, int, size_t, int, int);
void	ad1848_free(void *, void *, int);
size_t	ad1848_round(void *, int, size_t);
paddr_t	ad1848_mappage(void *, void *, off_t, int);
d226 1
a226 1
int	ad1848_get_props(void *);
@


1.8
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.7 1998/05/08 18:37:20 csapuntz Exp $	*/
d224 1
a224 1
int	ad1848_mappage __P((void *, void *, int, int));
@


1.8.6.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d224 1
a224 1
paddr_t	ad1848_mappage __P((void *, void *, off_t, int));
@


1.8.6.2
log
@Merge in trunk
@
text
@d221 1
a221 1
void   *ad1848_malloc __P((void *, int, size_t, int, int));
d223 1
a223 1
size_t	ad1848_round __P((void *, int, size_t));
@


1.8.6.3
log
@Merge in -current from about a week ago
@
text
@d142 2
a143 2
static __inline int ad1848_to_vol(mixer_ctrl_t *, struct ad1848_volume *);
static __inline int ad1848_from_vol(mixer_ctrl_t *, struct ad1848_volume *);
d180 6
a185 6
int     ad1848_mixer_get_port(struct ad1848_softc *, ad1848_devmap_t *, int cnt, mixer_ctrl_t *);
int     ad1848_mixer_set_port(struct ad1848_softc *, ad1848_devmap_t *, int, mixer_ctrl_t *);
int	ad1848_mapprobe(struct ad1848_softc *, int);
int	ad1848_probe(struct ad1848_softc *);
void	ad1848_unmap(struct ad1848_softc *);
void	ad1848_attach(struct ad1848_softc *);
d187 2
a188 2
int	ad1848_open(void *, int);
void	ad1848_close(void *);
d190 1
a190 1
void	ad1848_forceintr(struct ad1848_softc *);
d192 2
a193 2
int	ad1848_query_encoding(void *, struct audio_encoding *);
int	ad1848_set_params(void *, int, int, struct audio_params *, struct audio_params *);
d195 1
a195 1
int	ad1848_round_blocksize(void *, int);
d197 4
a200 4
int	ad1848_dma_init_output(void *, void *, int);
int	ad1848_dma_init_input(void *, void *, int);
int	ad1848_dma_output(void *, void *, int, void (*)(void *), void *);
int	ad1848_dma_input(void *, void *, int, void (*)(void *), void *);
d202 1
a202 1
int	ad1848_commit_settings(void *);
d204 2
a205 2
int	ad1848_halt_in_dma(void *);
int	ad1848_halt_out_dma(void *);
d207 1
a207 1
int	ad1848_intr(void *);
d209 2
a210 2
int	ad1848_set_rec_port(struct ad1848_softc *, int);
int	ad1848_get_rec_port(struct ad1848_softc *);
d212 4
a215 4
int	ad1848_set_channel_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_get_device_gain(struct ad1848_softc *, int, struct ad1848_volume *);
int	ad1848_set_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_rec_gain(struct ad1848_softc *, struct ad1848_volume *);
d217 8
a224 8
int	ad1848_set_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
int	ad1848_get_mic_gain(struct ad1848_softc *, struct ad1848_volume *);
void     ad1848_mute_channel(struct ad1848_softc *, int device, int mute);

void   *ad1848_malloc(void *, int, size_t, int, int);
void	ad1848_free(void *, void *, int);
size_t	ad1848_round(void *, int, size_t);
paddr_t	ad1848_mappage(void *, void *, off_t, int);
d226 1
a226 1
int	ad1848_get_props(void *);
@


1.7
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.6 1998/04/26 21:02:39 provos Exp $	*/
a60 1
#ifndef NEWCONFIG
a63 1
#endif
@


1.6
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: ad1848var.h,v 1.5 1997/11/07 08:06:42 niklas Exp $	*/
d78 3
a80 1
	struct ad1848_volume rec_gain, aux1_gain, aux2_gain, out_gain, mon_gain, line_gain, mono_gain;
d87 2
a88 1
	char	mono_mute, aux1_mute, aux2_mute, line_mute, mon_mute;
d107 15
d131 53
d214 2
a215 6
int	ad1848_set_aux1_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_aux1_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_set_aux2_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_aux2_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_set_out_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_out_gain __P((struct ad1848_softc *, struct ad1848_volume *));
a217 2
int	ad1848_set_mon_gain __P((struct ad1848_softc *, struct ad1848_volume *));
int	ad1848_get_mon_gain __P((struct ad1848_softc *, struct ad1848_volume *));
d221 1
a221 2
void	ad1848_mute_aux1 __P((struct ad1848_softc *, int /* onoff */));
void	ad1848_mute_aux2 __P((struct ad1848_softc *, int /* onoff */));
@


1.5
log
@$OpenBSD$
@
text
@d1 2
a2 2
/*	$OpenBSD: ad1848var.h,v 1.8 1996/04/29 20:02:37 christos Exp $	*/
/*	$NetBSD: ad1848var.h,v 1.8 1996/04/29 20:02:37 christos Exp $	*/
d39 1
a39 1
#define AD1848_NPORT	8
d50 3
d55 2
a56 1
	
d67 6
a72 1
	int	sc_iobase;		/* I/O port base address */
a88 2
	u_long	speed;
	u_int	encoding;		/* ulaw/linear -- keep track */
d99 3
d113 1
d115 1
d118 1
a118 1
int	ad1848_open __P((struct ad1848_softc *, dev_t, int));
a122 4
int	ad1848_set_in_sr __P((void *, u_long));
u_long	ad1848_get_in_sr __P((void *));
int	ad1848_set_out_sr __P((void *, u_long));
u_long	ad1848_get_out_sr __P((void *));
d124 1
a124 5
int	ad1848_set_format __P((void *, u_int, u_int));
int	ad1848_get_encoding __P((void *));
int	ad1848_get_precision __P((void *));
int	ad1848_set_channels __P((void *, int));
int	ad1848_get_channels __P((void *));
d128 2
a136 2
int	ad1848_cont_in_dma __P((void *));
int	ad1848_cont_out_dma __P((void *));
d158 8
@


1.4
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
@


1.3
log
@sync with 0504 -- prototypes and bus.h
@
text
@a66 3
	u_long	sc_irate;		/* Sample rate for input */
	u_long	sc_orate;		/* ...and output */

a69 3
	u_int	encoding;		/* ulaw/linear -- keep track */
	u_int	precision;		/* 8/16 bits */
	
a71 2
	int	channels;

d79 5
a83 1
	int	speed;
d86 1
d115 1
a115 1
int	ad1848_set_encoding __P((void *, u_int));
a116 1
int	ad1848_set_precision __P((void *, u_int));
a126 2

u_int	ad1848_get_silence __P((int));
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d1 1
a1 1
/*	$NetBSD: ad1848var.h,v 1.7 1995/11/10 04:30:40 mycroft Exp $	*/
d127 2
a128 2
int	ad1848_dma_output __P((void *, void *, int, void (*)(), void*));
int	ad1848_dma_input __P((void *, void *, int, void (*)(), void*));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: ad1848var.h,v 1.6 1995/07/07 02:11:56 brezak Exp $	*/
d62 4
a65 4
	u_short sc_iobase;		/* I/O port base address */
	u_short sc_irq;			/* interrupt */
	u_short sc_drq;			/* DMA */
	u_short sc_recdrq;		/* record/capture DMA */
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
