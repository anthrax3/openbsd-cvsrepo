head	1.9;
access;
symbols
	OPENBSD_6_1:1.9.0.12
	OPENBSD_6_1_BASE:1.9
	OPENBSD_6_0:1.9.0.10
	OPENBSD_6_0_BASE:1.9
	OPENBSD_5_9:1.9.0.2
	OPENBSD_5_9_BASE:1.9
	OPENBSD_5_8:1.9.0.8
	OPENBSD_5_8_BASE:1.9
	OPENBSD_5_7:1.9.0.6
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.9.0.4
	OPENBSD_5_6_BASE:1.9
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.14
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.12
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.10
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.7
	OPENBSD_5_1:1.7.0.8
	OPENBSD_5_0:1.7.0.6
	OPENBSD_5_0_BASE:1.7
	OPENBSD_4_9:1.7.0.4
	OPENBSD_4_9_BASE:1.7
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.6.0.30
	OPENBSD_4_7_BASE:1.6
	OPENBSD_4_6:1.6.0.32
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.28
	OPENBSD_4_5_BASE:1.6
	OPENBSD_4_4:1.6.0.26
	OPENBSD_4_4_BASE:1.6
	OPENBSD_4_3:1.6.0.24
	OPENBSD_4_3_BASE:1.6
	OPENBSD_4_2:1.6.0.22
	OPENBSD_4_2_BASE:1.6
	OPENBSD_4_1:1.6.0.20
	OPENBSD_4_1_BASE:1.6
	OPENBSD_4_0:1.6.0.18
	OPENBSD_4_0_BASE:1.6
	OPENBSD_3_9:1.6.0.16
	OPENBSD_3_9_BASE:1.6
	OPENBSD_3_8:1.6.0.14
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.12
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.4
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.5.0.2
	OPENBSD_3_1_BASE:1.5
	UBC_SYNC_B:1.6
	UBC:1.4.0.20
	UBC_BASE:1.4
	OPENBSD_3_0:1.4.0.18
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.16
	OPENBSD_2_8:1.4.0.14
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.12
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.10
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.8
	OPENBSD_2_6_BASE:1.4
	OPENBSD_2_5:1.4.0.6
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.4.0.4
	OPENBSD_2_4_BASE:1.4
	OPENBSD_2_3:1.4.0.2
	OPENBSD_2_3_BASE:1.4;
locks; strict;
comment	@ * @;


1.9
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.8;
commitid	I19imNlAX05zJOED;

1.8
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2010.06.24.21.17.59;	author jasper;	state Exp;
branches;
next	1.6;

1.6
date	2002.06.30.16.05.59;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	97.12.26.23.43.51;	author deraadt;	state Exp;
branches
	1.4.10.1
	1.4.20.1;
next	1.3;

1.3
date	97.12.25.10.32.16;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	97.12.25.09.22.42;	author downsj;	state Exp;
branches;
next	1.1;

1.1
date	97.12.21.14.41.26;	author downsj;	state Exp;
branches;
next	;

1.4.10.1
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.4.10.2;

1.4.10.2
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	;

1.4.20.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.4.20.2;

1.4.20.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	;


desc
@@


1.9
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@/*	$OpenBSD: isapnpres.c,v 1.8 2013/11/15 16:46:27 brad Exp $	*/
/*	$NetBSD: isapnpres.c,v 1.7.4.1 1997/11/20 07:46:13 mellon Exp $	*/

/*
 * Copyright (c) 1996 Christos Zoulas.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Resource parser for Plug and Play cards.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/isa/isapnpreg.h>

#include <dev/isa/isavar.h>

int isapnp_wait_status(struct isapnp_softc *);
struct isa_attach_args *
    isapnp_newdev(struct isa_attach_args *);
struct isa_attach_args *
    isapnp_newconf(struct isa_attach_args *);
void isapnp_merge(struct isa_attach_args *,
    const struct isa_attach_args *);
struct isa_attach_args *
    isapnp_flatten(struct isa_attach_args *);
int isapnp_process_tag(u_char, u_char, u_char *,
    struct isa_attach_args **, struct isa_attach_args **,
    struct isa_attach_args **);

#ifdef DEBUG_ISAPNP
# define DPRINTF(a) printf a
#else
# define DPRINTF(a)
#endif

/* isapnp_wait_status():
 *	Wait for the next byte of resource data to become available
 */
int
isapnp_wait_status(struct isapnp_softc *sc)
{
	int i;

	/* wait up to 1 ms for each resource byte */
	for (i = 0; i < 10; i++) {
		if (isapnp_read_reg(sc, ISAPNP_STATUS) & 1)
			return 0;
		DELAY(100);
	}
	return 1;
}


/* isapnp_newdev():
 *	Add a new logical device to the current card; expand the configuration
 *	resources of the current card if needed.
 */
struct isa_attach_args *
isapnp_newdev(struct isa_attach_args *card)
{
	struct isa_attach_args *ipa, *dev = malloc(sizeof(*dev), M_DEVBUF, M_WAITOK);

	ISAPNP_CLONE_SETUP(dev, card);

	dev->ipa_pref = ISAPNP_DEP_ACCEPTABLE;
	bcopy(card->ipa_devident, dev->ipa_devident,
	    sizeof(card->ipa_devident));

	if (card->ipa_child == NULL)
		card->ipa_child = dev;
	else {
		for (ipa = card->ipa_child; ipa->ipa_sibling != NULL; 
		    ipa = ipa->ipa_sibling)
			continue;
		ipa->ipa_sibling = dev;
	}


	return dev;
}


/* isapnp_newconf():
 *	Add a new alternate configuration to a logical device
 */
struct isa_attach_args *
isapnp_newconf(struct isa_attach_args *dev)
{
	struct isa_attach_args *ipa, *conf = malloc(sizeof(*conf), M_DEVBUF, M_WAITOK);

	ISAPNP_CLONE_SETUP(conf, dev);

	bcopy(dev->ipa_devident, conf->ipa_devident,
	    sizeof(conf->ipa_devident));
	bcopy(dev->ipa_devlogic, conf->ipa_devlogic,
	    sizeof(conf->ipa_devlogic));
	bcopy(dev->ipa_devcompat, conf->ipa_devcompat,
	    sizeof(conf->ipa_devcompat));
	bcopy(dev->ipa_devclass, conf->ipa_devclass,
	    sizeof(conf->ipa_devclass));

	if (dev->ipa_child == NULL)
		dev->ipa_child = conf;
	else {
		for (ipa = dev->ipa_child; ipa->ipa_sibling;
		    ipa = ipa->ipa_sibling)
			continue;
		ipa->ipa_sibling = conf;
	}

	return conf;
}


/* isapnp_merge():
 *	Merge the common device configurations to the subconfigurations
 */
void
isapnp_merge(struct isa_attach_args *c, const struct isa_attach_args *d)
{
	int i;

	for (i = 0; i < d->ipa_nio; i++)
		c->ipa_io[c->ipa_nio++] = d->ipa_io[i];

	for (i = 0; i < d->ipa_nmem; i++)
		c->ipa_mem[c->ipa_nmem++] = d->ipa_mem[i];

	for (i = 0; i < d->ipa_nmem32; i++)
		c->ipa_mem32[c->ipa_nmem32++] = d->ipa_mem32[i];

	for (i = 0; i < d->ipa_nirq; i++)
		c->ipa_irq[c->ipa_nirq++] = d->ipa_irq[i];

	for (i = 0; i < d->ipa_ndrq; i++)
		c->ipa_drq[c->ipa_ndrq++] = d->ipa_drq[i];
}


/* isapnp_flatten():
 *	Flatten the tree to a list of config entries.
 */
struct isa_attach_args *
isapnp_flatten(struct isa_attach_args *card)
{
	struct isa_attach_args *dev, *conf, *d, *c, *pa;

	dev = card->ipa_child;
	free(card, M_DEVBUF, 0);

	for (conf = c = NULL, d = dev; d; d = dev) {
		dev = d->ipa_sibling;
		if (d->ipa_child == NULL) {
			/*
			 * No subconfigurations; all configuration info
			 * is in the device node.
			 */
			d->ipa_sibling = NULL;
			pa = d;
		}
		else {
			/*
			 * Push down device configuration info to the
			 * subconfigurations
			 */
			for (pa = d->ipa_child; pa; pa = pa->ipa_sibling)
				isapnp_merge(pa, d);

			pa = d->ipa_child;
			free(d, M_DEVBUF, 0);
		}

		if (c == NULL)
			c = conf = pa;
		else
			c->ipa_sibling = pa;

		while (c->ipa_sibling)
			c = c->ipa_sibling;
	}
	return conf;
}


/* isapnp_process_tag():
 *	Process a resource tag
 */
int
isapnp_process_tag(u_char tag, u_char len, u_char *buf,
    struct isa_attach_args **card, struct isa_attach_args **dev,
    struct isa_attach_args **conf)
{
	char str[64];
	struct isapnp_region *r;
	struct isapnp_pin *p;
	struct isa_attach_args *pa;

#define COPY(a, b) strncpy((a), (b), sizeof(a)), (a)[sizeof(a) - 1] = '\0'

	switch (tag) {
	case ISAPNP_TAG_VERSION_NUM:
		DPRINTF(("PnP version %d.%d, Vendor version %d.%d\n",
		    buf[0] >> 4, buf[0] & 0xf, buf[1] >> 4,  buf[1] & 0xf));
		return 0;

	case ISAPNP_TAG_LOGICAL_DEV_ID:
		(void) isapnp_id_to_vendor(str, buf);
		DPRINTF(("Logical device id %s\n", str));

		*dev = isapnp_newdev(*card);
		COPY((*dev)->ipa_devlogic, str);
		return 0;

	case ISAPNP_TAG_COMPAT_DEV_ID:
		(void) isapnp_id_to_vendor(str, buf);
		DPRINTF(("Compatible device id %s\n", str));

		if (*dev == NULL)
			return -1;

		if (*(*dev)->ipa_devcompat == '\0')
			COPY((*dev)->ipa_devcompat, str);
		return 0;

	case ISAPNP_TAG_DEP_START:
		if (len == 0)
			buf[0] = ISAPNP_DEP_ACCEPTABLE;

		if (*dev == NULL)
			return -1;

		*conf = isapnp_newconf(*dev);
		(*conf)->ipa_pref = buf[0];
#ifdef DEBUG_ISAPNP
		isapnp_print_dep_start(">>> Start dependent function ",
		    (*conf)->ipa_pref);
#endif
		return 0;
		
	case ISAPNP_TAG_DEP_END:
		DPRINTF(("<<<End dependent functions\n"));
		*conf = NULL;
		return 0;

	case ISAPNP_TAG_ANSI_IDENT_STRING:
		buf[len] = '\0';
		DPRINTF(("ANSI Ident: %s\n", buf));
		if (*dev == NULL)
			COPY((*card)->ipa_devident, buf);
		else
			COPY((*dev)->ipa_devclass, buf);
		return 0;

	case ISAPNP_TAG_END:
		*dev = NULL;
		return 0;

	default:
		/* Handled below */
		break;
	}


	/*
	 * Decide which configuration we add the tag to
	 */
	if (*conf)
		pa = *conf;
	else if (*dev)
		pa = *dev;
	else
		/* error */
		return -1;

	switch (tag) {
	case ISAPNP_TAG_IRQ_FORMAT:
		if (len < 2)
			break;

		if (len != 3)
			buf[2] = ISAPNP_IRQTYPE_EDGE_PLUS;

		p = &pa->ipa_irq[pa->ipa_nirq++];
		p->bits = buf[0] | (buf[1] << 8);
		p->flags = buf[2];
#ifdef DEBUG_ISAPNP
		isapnp_print_irq("", p);
#endif
		break;

	case ISAPNP_TAG_DMA_FORMAT:
		if (buf[0] == 0)
			break;

		p = &pa->ipa_drq[pa->ipa_ndrq++];
		p->bits = buf[0];
		p->flags = buf[1];
#ifdef DEBUG_ISAPNP
		isapnp_print_drq("", p);
#endif
		break;


	case ISAPNP_TAG_IO_PORT_DESC:
		r = &pa->ipa_io[pa->ipa_nio++];
		r->flags = buf[0];
		r->minbase = (buf[2] << 8) | buf[1];
		r->maxbase = (buf[4] << 8) | buf[3];
		r->align = buf[5];
		r->length = buf[6];
#ifdef DEBUG_ISAPNP
		isapnp_print_io("", r);
#endif
		break;

	case ISAPNP_TAG_FIXED_IO_PORT_DESC:
		r = &pa->ipa_io[pa->ipa_nio++];
		r->flags = 0;
		r->minbase = (buf[1] << 8) | buf[0];
		r->maxbase = r->minbase;
		r->align = 1;
		r->length = buf[2];
#ifdef DEBUG_ISAPNP
		isapnp_print_io("FIXED ", r);
#endif
		break;

	case ISAPNP_TAG_VENDOR_DEF:
		DPRINTF(("Vendor defined (short)\n"));
		break;

	case ISAPNP_TAG_MEM_RANGE_DESC:
		r = &pa->ipa_mem[pa->ipa_nmem++];
		r->flags = buf[0];
		r->minbase = (buf[2] << 16) | (buf[1] << 8);
		r->maxbase = (buf[4] << 16) | (buf[3] << 8);
		r->align = (buf[6] << 8) | buf[5];
		r->length = (buf[8] << 16) | (buf[7] << 8);
#ifdef DEBUG_ISAPNP
		isapnp_print_mem("", r);
#endif
		break;


	case ISAPNP_TAG_UNICODE_IDENT_STRING:
		DPRINTF(("Unicode Ident\n"));
		break;

	case ISAPNP_TAG_VENDOR_DEFINED:
		DPRINTF(("Vendor defined (long)\n"));
		break;

	case ISAPNP_TAG_MEM32_RANGE_DESC:
		r = &pa->ipa_mem32[pa->ipa_nmem32++];
		r->flags = buf[0];
		r->minbase = (buf[4] << 24) | (buf[3] << 16) |
		    (buf[2] << 8) | buf[1];
		r->maxbase = (buf[8] << 24) | (buf[7] << 16) |
		    (buf[6] << 8) | buf[5];
		r->align = (buf[12] << 24) | (buf[11] << 16) | 
		    (buf[10] << 8) | buf[9];
		r->length = (buf[16] << 24) | (buf[15] << 16) |
		    (buf[14] << 8) | buf[13];
#ifdef DEBUG_ISAPNP
		isapnp_print_mem("32-bit ", r);
#endif
		break;

	case ISAPNP_TAG_FIXED_MEM32_RANGE_DESC:
		r = &pa->ipa_mem32[pa->ipa_nmem32++];
		r->flags = buf[0];
		r->minbase = (buf[4] << 24) | (buf[3] << 16) |
		    (buf[2] << 8) | buf[1];
		r->maxbase = r->minbase;
		r->align = 1;
		r->length = (buf[8] << 24) | (buf[7] << 16) |
		    (buf[6] << 8) | buf[5];
#ifdef DEBUG_ISAPNP
		isapnp_print_mem("FIXED 32-bit ", r);
#endif
		break;

	default:
#ifdef DEBUG_ISAPNP
		{
			int i;
			printf("tag %.2x, len %d: ", tag, len);
			for (i = 0; i < len; i++)
				printf("%.2x ", buf[i]);
			printf("\n");
		}
#endif
		break;
	}
	return 0;
}


/* isapnp_get_resource():
 *	Read the resources for card c
 */
struct isa_attach_args *
isapnp_get_resource(struct isapnp_softc *sc, int c,
    struct isa_attach_args *template)
{
	u_char d, tag;
	u_short len;
	int i;
	int warned = 0;
	struct isa_attach_args *card, *dev = NULL, *conf = NULL;
	u_char buf[ISAPNP_MAX_TAGSIZE], *p;

	bzero(buf, sizeof(buf));

	card = malloc(sizeof(*card), M_DEVBUF, M_WAITOK);
	ISAPNP_CLONE_SETUP(card, template);

#define NEXT_BYTE \
		if (isapnp_wait_status(sc)) \
			goto bad; \
		d = isapnp_read_reg(sc, ISAPNP_RESOURCE_DATA)

	for (i = 0; i < ISAPNP_SERIAL_SIZE; i++) {
		NEXT_BYTE;

		if (d != sc->sc_id[c][i] && i != ISAPNP_SERIAL_SIZE - 1) {
			if (!warned) {
				printf("%s: card %d violates PnP spec; byte %d\n",
				    sc->sc_dev.dv_xname, c + 1, i);
				warned++;
			}
			if (i == 0) {
				/*
				 * Magic! If this is the first byte, we
				 * assume that the tag data begins here.
				 */
				goto parse;
			}
		}
	}

	do {
		NEXT_BYTE;
parse:

		if (d & ISAPNP_LARGE_TAG) {
			tag = d;
			NEXT_BYTE;
			buf[0] = d;
			NEXT_BYTE;
			buf[1] = d;
			len = (buf[1] << 8) | buf[0];
		}
		else {
			tag = (d >> 3) & 0xf;
			len = d & 0x7;
		}

		for (p = buf, i = 0; i < len; i++) {
			NEXT_BYTE;
			if (i < ISAPNP_MAX_TAGSIZE)
				*p++ = d;
		}

		if (len >= ISAPNP_MAX_TAGSIZE) {
			printf("%s: Maximum tag size exceeded, card %d\n",
			    sc->sc_dev.dv_xname, c + 1);
			len = ISAPNP_MAX_TAGSIZE;
			if (++warned == 10)
				goto bad;
		}

		if (isapnp_process_tag(tag, len, buf, &card, &dev, &conf) == -1) {
			printf("%s: No current device for tag, card %d\n",
			    sc->sc_dev.dv_xname, c + 1);
			if (++warned == 10)
				goto bad;
		}
	}
	while (tag != ISAPNP_TAG_END);
	return isapnp_flatten(card);

bad:
	for (card = isapnp_flatten(card); card; ) {
		dev = card->ipa_sibling;
		free(card, M_DEVBUF, 0);
		card = dev;
	}
	printf("%s: %s, card %d\n", sc->sc_dev.dv_xname,
	    warned >= 10 ? "Too many tag errors" : "Resource timeout", c + 1);
	return NULL;
}
@


1.8
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.7 2010/06/24 21:17:59 jasper Exp $	*/
d180 1
a180 1
	free(card, M_DEVBUF);
d201 1
a201 1
			free(d, M_DEVBUF);
d517 1
a517 1
		free(card, M_DEVBUF);
@


1.7
log
@- remove ISAPNP_FREE and ISAPNP_MALLOC macro's and just use them inline.

ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.6 2002/06/30 16:05:59 miod Exp $	*/
d71 1
a71 2
isapnp_wait_status(sc)
	struct isapnp_softc *sc;
d90 1
a90 2
isapnp_newdev(card)
	struct isa_attach_args *card;
d118 1
a118 2
isapnp_newconf(dev)
	struct isa_attach_args *dev;
d150 1
a150 3
isapnp_merge(c, d)
	struct isa_attach_args *c;
	const struct isa_attach_args *d;
d175 1
a175 2
isapnp_flatten(card)
	struct isa_attach_args *card;
d220 3
a222 3
isapnp_process_tag(tag, len, buf, card, dev, conf)
	u_char tag, len, *buf;
	struct isa_attach_args **card, **dev, **conf;
d434 2
a435 4
isapnp_get_resource(sc, c, template)
	struct isapnp_softc *sc;
	int c;
	struct isa_attach_args *template;
@


1.6
log
@When duplicating isa_attach_args structures to build several attachement
possibilities for isapnp devices, make sure to carry the original ia_ic
member. Although mostly unused on i386, it is vital on alpha.

This makes isapnp on alpha attach without panicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.5 2002/03/14 01:26:56 millert Exp $	*/
d94 1
a94 1
	struct isa_attach_args *ipa, *dev = ISAPNP_MALLOC(sizeof(*dev));
d123 1
a123 1
	struct isa_attach_args *ipa, *conf = ISAPNP_MALLOC(sizeof(*conf));
d186 1
a186 1
	ISAPNP_FREE(card);
d207 1
a207 1
			ISAPNP_FREE(d);
d454 1
a454 1
	card = ISAPNP_MALLOC(sizeof(*card));
d525 1
a525 1
		ISAPNP_FREE(card);
@


1.5
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.4 1997/12/26 23:43:51 deraadt Exp $	*/
d96 1
a96 1
	bzero(dev, sizeof(*dev));
d125 1
a125 1
	bzero(conf, sizeof(*conf));
d440 1
a440 1
isapnp_get_resource(sc, c)
d443 1
d455 1
a455 1
	bzero(card, sizeof(*card));
@


1.4
log
@use bcopy
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.3 1997/12/25 10:32:16 downsj Exp $	*/
d48 1
a48 1
int isapnp_wait_status __P((struct isapnp_softc *));
d50 1
a50 1
    isapnp_newdev __P((struct isa_attach_args *));
d52 3
a54 3
    isapnp_newconf __P((struct isa_attach_args *));
void isapnp_merge __P((struct isa_attach_args *,
    const struct isa_attach_args *));
d56 2
a57 2
    isapnp_flatten __P((struct isa_attach_args *));
int isapnp_process_tag __P((u_char, u_char, u_char *,
d59 1
a59 1
    struct isa_attach_args **));
@


1.4.20.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.4 1997/12/26 23:43:51 deraadt Exp $	*/
d48 1
a48 1
int isapnp_wait_status(struct isapnp_softc *);
d50 1
a50 1
    isapnp_newdev(struct isa_attach_args *);
d52 3
a54 3
    isapnp_newconf(struct isa_attach_args *);
void isapnp_merge(struct isa_attach_args *,
    const struct isa_attach_args *);
d56 2
a57 2
    isapnp_flatten(struct isa_attach_args *);
int isapnp_process_tag(u_char, u_char, u_char *,
d59 1
a59 1
    struct isa_attach_args **);
@


1.4.20.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.4.20.1 2002/06/11 03:42:21 art Exp $	*/
d96 1
a96 1
	ISAPNP_CLONE_SETUP(dev, card);
d125 1
a125 1
	ISAPNP_CLONE_SETUP(conf, dev);
d440 1
a440 1
isapnp_get_resource(sc, c, template)
a442 1
	struct isa_attach_args *template;
d454 1
a454 1
	ISAPNP_CLONE_SETUP(card, template);
@


1.4.10.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d48 1
a48 1
int isapnp_wait_status(struct isapnp_softc *);
d50 1
a50 1
    isapnp_newdev(struct isa_attach_args *);
d52 3
a54 3
    isapnp_newconf(struct isa_attach_args *);
void isapnp_merge(struct isa_attach_args *,
    const struct isa_attach_args *);
d56 2
a57 2
    isapnp_flatten(struct isa_attach_args *);
int isapnp_process_tag(u_char, u_char, u_char *,
d59 1
a59 1
    struct isa_attach_args **);
@


1.4.10.2
log
@Sync the SMP branch with 3.3
@
text
@d96 1
a96 1
	ISAPNP_CLONE_SETUP(dev, card);
d125 1
a125 1
	ISAPNP_CLONE_SETUP(conf, dev);
d440 1
a440 1
isapnp_get_resource(sc, c, template)
a442 1
	struct isa_attach_args *template;
d454 1
a454 1
	ISAPNP_CLONE_SETUP(card, template);
@


1.3
log
@Avoid infinite loop with busted cards.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.2 1997/12/25 09:22:42 downsj Exp $	*/
d99 1
a99 1
	memcpy(dev->ipa_devident, card->ipa_devident,
d127 1
a127 1
	memcpy(conf->ipa_devident, dev->ipa_devident,
d129 1
a129 1
	memcpy(conf->ipa_devlogic, dev->ipa_devlogic,
d131 1
a131 1
	memcpy(conf->ipa_devcompat, dev->ipa_devcompat,
d133 1
a133 1
	memcpy(conf->ipa_devclass, dev->ipa_devclass,
@


1.2
log
@New ISA/ISA PnP configuration infrastructure:

isa_attach_args and isapnp_attach_args have been merged.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnpres.c,v 1.1 1997/12/21 14:41:26 downsj Exp $	*/
d511 1
a511 1
		if (isapnp_process_tag(tag, len, buf, &card, &dev, &conf) == -1)
d514 3
@


1.1
log
@Obliterate old PnP `code' and outright replace with christos' code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a43 2
#include <dev/isa/isavar.h>

a44 1
#include <dev/isa/isapnpvar.h>
d46 1
d49 8
a56 8
struct isapnp_attach_args *
    isapnp_newdev __P((struct isapnp_attach_args *));
struct isapnp_attach_args *
    isapnp_newconf __P((struct isapnp_attach_args *));
void isapnp_merge __P((struct isapnp_attach_args *,
    const struct isapnp_attach_args *));
struct isapnp_attach_args *
    isapnp_flatten __P((struct isapnp_attach_args *));
d58 2
a59 2
    struct isapnp_attach_args **, struct isapnp_attach_args **,
    struct isapnp_attach_args **));
d61 5
d90 1
a90 1
struct isapnp_attach_args *
d92 1
a92 1
	struct isapnp_attach_args *card;
d94 1
a94 1
	struct isapnp_attach_args *ipa, *dev = ISAPNP_MALLOC(sizeof(*dev));
d96 1
a96 1
	memset(dev, 0, sizeof(*dev));
d119 1
a119 1
struct isapnp_attach_args *
d121 1
a121 1
	struct isapnp_attach_args *dev;
d123 1
a123 1
	struct isapnp_attach_args *ipa, *conf = ISAPNP_MALLOC(sizeof(*conf));
d125 1
a125 1
	memset(conf, 0, sizeof(*conf));
d154 2
a155 2
	struct isapnp_attach_args *c;
	const struct isapnp_attach_args *d;
d179 1
a179 1
struct isapnp_attach_args *
d181 1
a181 1
	struct isapnp_attach_args *card;
d183 1
a183 1
	struct isapnp_attach_args *dev, *conf, *d, *c, *pa;
d228 1
a228 1
	struct isapnp_attach_args **card, **dev, **conf;
d233 1
a233 1
	struct isapnp_attach_args *pa;
d439 1
a439 1
struct isapnp_attach_args *
d448 1
a448 1
	struct isapnp_attach_args *card, *dev = NULL, *conf = NULL;
d451 1
a451 1
	memset(buf, 0, sizeof(buf));
d454 1
a454 1
	memset(card, 0, sizeof(*card));
@
