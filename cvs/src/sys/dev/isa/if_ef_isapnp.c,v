head	1.39;
access;
symbols
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.2
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.30.0.4
	OPENBSD_5_8_BASE:1.30
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.25.0.6
	OPENBSD_5_6_BASE:1.25
	OPENBSD_5_5:1.25.0.4
	OPENBSD_5_5_BASE:1.25
	OPENBSD_5_4:1.24.0.20
	OPENBSD_5_4_BASE:1.24
	OPENBSD_5_3:1.24.0.18
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.16
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.14
	OPENBSD_5_0:1.24.0.12
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.10
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.24.0.8
	OPENBSD_4_8_BASE:1.24
	OPENBSD_4_7:1.24.0.4
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.24.0.6
	OPENBSD_4_6_BASE:1.24
	OPENBSD_4_5:1.24.0.2
	OPENBSD_4_5_BASE:1.24
	OPENBSD_4_4:1.21.0.10
	OPENBSD_4_4_BASE:1.21
	OPENBSD_4_3:1.21.0.8
	OPENBSD_4_3_BASE:1.21
	OPENBSD_4_2:1.21.0.6
	OPENBSD_4_2_BASE:1.21
	OPENBSD_4_1:1.21.0.4
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.21.0.2
	OPENBSD_4_0_BASE:1.21
	OPENBSD_3_9:1.20.0.2
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.18.0.4
	OPENBSD_3_8_BASE:1.18
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.16.0.2
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.6
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.4
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.14
	UBC:1.13.0.4
	UBC_BASE:1.13
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.8.0.2
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.5.0.4
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.39
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.38;
commitid	VyLWTsbepAOk7VQM;

1.38
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.37;
commitid	QHiEhS9DHyE6oiIr;

1.37
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.36;
commitid	J9apD0jq2AjFmqZc;

1.36
date	2015.11.25.11.20.38;	author mpi;	state Exp;
branches;
next	1.35;
commitid	f4dx5ry1aOiKJw33;

1.35
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.34;
commitid	B0kwmVGiD5DVx4kv;

1.34
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5gdEnqVoJuTuwdTu;

1.33
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.32;
commitid	5DvsamK0GblTp8ww;

1.32
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.31;
commitid	eYnPulzvLjDImPCa;

1.31
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.30;
commitid	SaArro4mM2Ab3ure;

1.30
date	2015.07.08.07.21.50;	author mpi;	state Exp;
branches;
next	1.29;
commitid	9ERVupAoYqW4Iok9;

1.29
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.28;
commitid	MVWrtktB46JRxFWT;

1.28
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.27;
commitid	0fL6zHGm3fqppVdw;

1.27
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.26;
commitid	yM2VFFhpDTeFQlve;

1.26
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.25;
commitid	nYggAidK85QbUFh2;

1.25
date	2013.08.07.01.06.31;	author bluhm;	state Exp;
branches;
next	1.24;

1.24
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2008.09.10.14.01.22;	author blambert;	state Exp;
branches;
next	1.21;

1.21
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.20;

1.20
date	2005.11.21.18.16.40;	author millert;	state Exp;
branches;
next	1.19;

1.19
date	2005.11.09.05.46.21;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.15.05.24.11;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2004.09.28.01.02.14;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.02.19.08.58;	author jason;	state Exp;
branches;
next	1.14;

1.14
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.27.06.34.45;	author kjc;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2001.06.25.04.44.28;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.23.21.54.48;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2001.02.20.19.39.41;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2000.11.11.23.49.20;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2000.10.16.17.08.07;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.07.02.48.22;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.05.26.16.24.30;	author jason;	state Exp;
branches;
next	1.5;

1.5
date	99.12.02.20.55.06;	author jason;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	99.08.08.19.16.08;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	99.08.05.18.06.28;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	99.08.04.23.14.38;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	99.08.04.03.29.27;	author jason;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.24.40;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.41.26;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2004.06.05.23.12.45;	author niklas;	state Exp;
branches;
next	;

1.5.4.1
date	2000.05.27.20.14.50;	author jason;	state Exp;
branches;
next	;

1.13.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.39
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_ef_isapnp.c,v 1.38 2016/04/13 10:49:26 mpi Exp $	*/

/*
 * Copyright (c) 1999 Jason L. Wright (jason@@thought.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/ioctl.h>
#include <sys/errno.h>
#include <sys/syslog.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/mii/mii.h>
#include <dev/mii/miivar.h>
#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <dev/ic/elink3reg.h>

#undef EF_DEBUG

struct ef_softc {
	struct device		sc_dv;
	bus_space_tag_t		sc_iot;
	bus_space_handle_t	sc_ioh;
	struct arpcom		sc_arpcom;
	struct mii_data		sc_mii;
	struct timeout		sc_tick_tmo;
	void *			sc_ih;
	int			sc_tx_start_thresh;
	int			sc_tx_succ_ok;
	int			sc_busmaster;
};

#define	EF_W0_EEPROM_COMMAND	0x200a
#define    EF_EEPROM_BUSY	(1 << 9)
#define    EF_EEPROM_READ	(1 << 7)
#define	EF_W0_EEPROM_DATA	0x200c

#define	EF_W1_TX_PIO_WR_1	0x10
#define	EF_W1_RX_PIO_RR_1	0x10
#define	EF_W1_RX_ERRORS		0x14
#define	EF_W1_RX_STATUS		0x18
#define	EF_W1_TX_STATUS		0x1b
#define	EF_W1_FREE_TX		0x1c

#define	EF_W4_MEDIA		0x0a
#define    EF_MEDIA_SQE		0x0008		/* sqe error for aui */
#define	   EF_MEDIA_TP		0x00c0		/* link/jabber, 10baseT */
#define	   EF_MEDIA_LNK		0x0080		/* linkbeat, 100baseTX/FX */
#define	   EF_MEDIA_LNKBEAT	0x0800

/* Window 4: EP_W4_CTRLR_STATUS: mii manipulation */
#define	EF_MII_CLK		0x01		/* clock bit */
#define	EF_MII_DATA		0x02		/* data bit */
#define	EF_MII_DIR		0x04		/* direction */

int ef_isapnp_match(struct device *, void *, void *);
void ef_isapnp_attach(struct device *, struct device *, void *);

void efstart(struct ifnet *);
int efioctl(struct ifnet *, u_long, caddr_t);
void efwatchdog(struct ifnet *);
void efreset(struct ef_softc *);
void efstop(struct ef_softc *);
void efsetmulti(struct ef_softc *);
int efbusyeeprom(struct ef_softc *);
int efintr(void *);
void efinit(struct ef_softc *);
void efcompletecmd(struct ef_softc *, u_int, u_int);
void eftxstat(struct ef_softc *);
void efread(struct ef_softc *);
struct mbuf *efget(struct ef_softc *, int totlen);

void ef_miibus_writereg(struct device *, int, int, int);
void ef_miibus_statchg(struct device *);
int ef_miibus_readreg(struct device *, int, int);
void ef_mii_writeb(struct ef_softc *, int);
void ef_mii_sync(struct ef_softc *);
int ef_ifmedia_upd(struct ifnet *);
void ef_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void ef_tick(void *);

struct cfdriver ef_cd = {
	NULL, "ef", DV_IFNET
};

struct cfattach ef_isapnp_ca = {
	sizeof(struct ef_softc), ef_isapnp_match, ef_isapnp_attach
};

int
ef_isapnp_match(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	return (1);
}

void
ef_isapnp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct ef_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int i;
	u_int16_t x;
	u_int32_t cfg;

	sc->sc_iot = iot = ia->ia_iot;
	sc->sc_ioh = ioh = ia->ipa_io[0].h;

	efcompletecmd(sc, EP_COMMAND, GLOBAL_RESET);
	DELAY(1500);

	for (i = 0; i < 3; i++) {
		if (efbusyeeprom(sc))
			return;

		bus_space_write_2(iot, ioh, EF_W0_EEPROM_COMMAND,
		    EF_EEPROM_READ | i);

		if (efbusyeeprom(sc))
			return;

		x = bus_space_read_2(iot, ioh, EF_W0_EEPROM_DATA);

		sc->sc_arpcom.ac_enaddr[(i << 1)] = x >> 8;
		sc->sc_arpcom.ac_enaddr[(i << 1) + 1] = x;
	}

	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	GO_WINDOW(3);
	cfg = bus_space_read_4(iot, ioh, EP_W3_INTERNAL_CONFIG);
	cfg &= ~(0x00f00000);
	cfg |= (0x06 << 20);
	bus_space_write_4(iot, ioh, EP_W3_INTERNAL_CONFIG, cfg);

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, efintr, sc, sc->sc_dv.dv_xname);

	if (ia->ia_drq != DRQUNK)
		isadma_cascade(ia->ia_drq);

	timeout_set(&sc->sc_tick_tmo, ef_tick, sc);

	bcopy(sc->sc_dv.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = efstart;
	ifp->if_ioctl = efioctl;
	ifp->if_watchdog = efwatchdog;
	ifp->if_flags =
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;

	sc->sc_mii.mii_ifp = ifp;
	sc->sc_mii.mii_readreg = ef_miibus_readreg;
	sc->sc_mii.mii_writereg = ef_miibus_writereg;
	sc->sc_mii.mii_statchg = ef_miibus_statchg;
	ifmedia_init(&sc->sc_mii.mii_media, 0, ef_ifmedia_upd, ef_ifmedia_sts);
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
	if (LIST_FIRST(&sc->sc_mii.mii_phys) == NULL) {
		ifmedia_add(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE, 0, NULL);
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_NONE);
	} else
		ifmedia_set(&sc->sc_mii.mii_media, IFM_ETHER|IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);

	sc->sc_tx_start_thresh = 20;

	efcompletecmd(sc, EP_COMMAND, RX_RESET);
	efcompletecmd(sc, EP_COMMAND, TX_RESET);
}

void
efstart(ifp)
	struct ifnet *ifp;
{
	struct ef_softc *sc = ifp->if_softc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct mbuf *m, *m0;
	int s, len, pad, i;
	int fillcnt = 0;
	u_int32_t filler = 0;

	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

startagain:
	m0 = ifq_deq_begin(&ifp->if_snd);
	if (m0 == NULL)
		return;

	if ((m0->m_flags & M_PKTHDR) == 0)
		panic("efstart: no header mbuf");
	len = m0->m_pkthdr.len;
	pad = (4 - len) & 3;

	if (len + pad > ETHER_MAX_LEN) {
		ifp->if_oerrors++;
		ifq_deq_commit(&ifp->if_snd, m0);
		m_freem(m0);
		goto startagain;
	}

	if (bus_space_read_2(iot, ioh, EF_W1_FREE_TX) < len + pad + 4) {
		bus_space_write_2(iot, ioh, EP_COMMAND,
		    SET_TX_AVAIL_THRESH | ((len + pad) >> 2));
		ifq_deq_rollback(&ifp->if_snd, m0);
		ifq_set_oactive(&ifp->if_snd);
		return;
	} else {
		bus_space_write_2(iot, ioh, EP_COMMAND,
		    SET_TX_AVAIL_THRESH | EP_THRESH_DISABLE);
	}

	bus_space_write_2(iot, ioh, EP_COMMAND, SET_TX_START_THRESH |
	    ((len / 4 + sc->sc_tx_start_thresh)));

#if NBPFILTER
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

	ifq_deq_commit(&ifp->if_snd, m0);
	if (m0 == NULL) /* XXX not needed */
		return;

	s = splhigh();

	bus_space_write_4(iot, ioh, EF_W1_TX_PIO_WR_1, len);
	for (m = m0; m; ) {
		if (fillcnt) {
			while (m->m_len && fillcnt < 4) {
				fillcnt++;
				filler >>= 8;
				filler |= m->m_data[0] << 24;
				m->m_data++;
				m->m_len--;
			}
			if (fillcnt == 4) {
				bus_space_write_4(iot, ioh,
				    EF_W1_TX_PIO_WR_1, filler);
				filler = 0;
				fillcnt = 0;
			}
		}

		if (m->m_len & ~3)
			bus_space_write_multi_4(iot, ioh,
			    EF_W1_TX_PIO_WR_1, (u_int32_t *)m->m_data,
			    m->m_len >> 2);
		for (i = 0; i < (m->m_len & 3); i++) {
			fillcnt++;
			filler >>= 8;
			filler |= m->m_data[(m->m_len & ~3) + i] << 24;
		}
		m0 = m_free(m);
		m = m0;
	}

	if (fillcnt) {
		bus_space_write_4(iot, ioh, EF_W1_TX_PIO_WR_1,
		    filler >> (32 - (8 * fillcnt)));
		fillcnt = 0;
		filler = 0;
	}

	splx(s);

	goto startagain;
}

int
efioctl(ifp, cmd, data)
	struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct ef_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		efinit(sc);
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;
	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			efstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
			   (ifp->if_flags & IFF_RUNNING) == 0) {
			efinit(sc);
		}
		efsetmulti(sc);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING) {
			efreset(sc);
			efsetmulti(sc);
		}
		error = 0;
	}

	splx(s);
	return (error);
}

void
efinit(sc)
	struct ef_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i, s;

	s = splnet();

	efstop(sc);

	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;

	GO_WINDOW(2);
	for (i = 0; i < 6; i++)
		bus_space_write_1(iot, ioh, EP_W2_ADDR_0 + i,
		    sc->sc_arpcom.ac_enaddr[i]);
	for (i = 0; i < 3; i += 2)
		bus_space_write_2(iot, ioh, EP_W2_RECVMASK_0 + (i * 2), 0);

	efcompletecmd(sc, EP_COMMAND, RX_RESET);
	efcompletecmd(sc, EP_COMMAND, TX_RESET);

	bus_space_write_2(iot, ioh, EP_COMMAND,
	    SET_TX_AVAIL_THRESH | (ETHER_MAX_DIX_LEN >> 2));

	efsetmulti(sc);

	bus_space_write_2(iot, ioh, EP_COMMAND, STATUS_ENABLE | 0);

	GO_WINDOW(6);
	for (i = 0; i < 10; i++)
		(void)bus_space_read_1(iot, ioh, i);
	(void)bus_space_read_2(iot, ioh, 10);
	(void)bus_space_read_2(iot, ioh, 12);
	GO_WINDOW(4);
	(void)bus_space_read_1(iot, ioh, 12);
	bus_space_write_2(iot, ioh, EP_W4_NET_DIAG, 0x0040);

	GO_WINDOW(7);

	efsetmulti(sc);

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_ENABLE);
	bus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);

	bus_space_write_2(iot, ioh, EP_COMMAND, STATUS_ENABLE |
	    S_CARD_FAILURE | S_INT_RQD | S_UPD_STATS | S_TX_COMPLETE |
	    S_TX_AVAIL | S_RX_COMPLETE |
	    (sc->sc_busmaster ? S_DMA_DONE : 0));
	bus_space_write_2(iot, ioh, EP_COMMAND, ACK_INTR |
	    S_INTR_LATCH | S_TX_AVAIL | S_RX_EARLY | S_INT_RQD);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK |
	    S_INTR_LATCH | S_TX_AVAIL | S_RX_COMPLETE | S_UPD_STATS |
	    (sc->sc_busmaster ? S_DMA_DONE : 0) | S_UP_COMPLETE |
	    S_DOWN_COMPLETE | S_CARD_FAILURE | S_TX_COMPLETE);

	mii_mediachg(&sc->sc_mii);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->sc_tick_tmo, 1);

	efstart(ifp);
}

void
efreset(sc)
	struct ef_softc *sc;
{
	int s;

	s = splnet();
	efstop(sc);
	efinit(sc);
	splx(s);
}

void
efstop(sc)
	struct ef_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->sc_tick_tmo);

	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISABLE);
	efcompletecmd(sc, EP_COMMAND, RX_DISCARD_TOP_PACK);

	bus_space_write_2(iot, ioh, EP_COMMAND, TX_DISABLE);
	bus_space_write_2(iot, ioh, EP_COMMAND, STOP_TRANSCEIVER);

	efcompletecmd(sc, EP_COMMAND, RX_RESET);
	efcompletecmd(sc, EP_COMMAND, TX_RESET);

	bus_space_write_2(iot, ioh, EP_COMMAND, C_INTR_LATCH);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_RD_0_MASK);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_INTR_MASK);
	bus_space_write_2(iot, ioh, EP_COMMAND, SET_RX_FILTER);
}

void
efcompletecmd(sc, cmd, arg)
	struct ef_softc *sc;
	u_int cmd, arg;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	bus_space_write_2(iot, ioh, cmd, arg);
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
}

int
efintr(vsc)
	void *vsc;
{
	struct ef_softc *sc = vsc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	u_int16_t status;
	int r = 0;

	status = bus_space_read_2(iot, ioh, EP_STATUS);

	do {
		if (status & S_RX_COMPLETE) {
			r = 1;
			bus_space_write_2(iot, ioh, EP_STATUS, C_RX_COMPLETE);
			efread(sc);
		}
		if (status & S_TX_AVAIL) {
			bus_space_write_2(iot, ioh, EP_STATUS, C_TX_AVAIL);
			r = 1;
			ifq_clr_oactive(&sc->sc_arpcom.ac_if.if_snd);
			efstart(&sc->sc_arpcom.ac_if);
		}
		if (status & S_CARD_FAILURE) {
			r = 1;
			efreset(sc);
			printf("%s: adapter failure (%x)\n",
			   sc->sc_dv.dv_xname, status);
			bus_space_write_2(iot, ioh, EP_COMMAND,
					  C_CARD_FAILURE);
			return (1);
		}
		if (status & S_TX_COMPLETE) {
			r = 1;
			eftxstat(sc);
			efstart(ifp);
		}
		bus_space_write_2(iot, ioh, EP_COMMAND,
		    C_INTR_LATCH | C_INT_RQD);
	} while ((status = bus_space_read_2(iot, ioh, EP_STATUS)) &
	    (S_INT_RQD | S_RX_COMPLETE));

	return (r);
}

void
eftxstat(sc)
	struct ef_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	while ((i = bus_space_read_1(iot, ioh, EF_W1_TX_STATUS)) &
	   TXS_COMPLETE) {
		bus_space_write_1(iot, ioh, EF_W1_TX_STATUS, 0);

		if (i & TXS_JABBER) {
			sc->sc_arpcom.ac_if.if_oerrors++;
#ifdef EF_DEBUG
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("%s: jabber (%x)\n",
				    sc->sc_dv.dv_xname, i);
#endif
			efreset(sc);
		}
		else if (i & TXS_UNDERRUN) {
			sc->sc_arpcom.ac_if.if_oerrors++;
#ifdef EF_DEBUG
			if (sc->sc_arpcom.ac_if.if_flags & IFF_DEBUG)
				printf("%s: fifo underrun (%x) @@%d\n",
				    sc->sc_dv.dv_xname, i,
				    sc->sc_tx_start_thresh);
#endif
			if (sc->sc_tx_succ_ok < 100)
				sc->sc_tx_start_thresh = min(ETHER_MAX_LEN,
				    sc->sc_tx_start_thresh + 20);
			sc->sc_tx_succ_ok = 0;
			efreset(sc);
		}
		else if (i & TXS_MAX_COLLISION) {
			sc->sc_arpcom.ac_if.if_collisions++;
			bus_space_write_2(iot, ioh, EP_COMMAND, TX_ENABLE);
			ifq_clr_oactive(&sc->sc_arpcom.ac_if.if_snd);
		}
		else
			sc->sc_tx_succ_ok = (sc->sc_tx_succ_ok + 1) & 127;
	}
}

int
efbusyeeprom(sc)
	struct ef_softc *sc;
{
	int i = 100, j;

	while (i--) {
		j = bus_space_read_2(sc->sc_iot, sc->sc_ioh,
				     EF_W0_EEPROM_COMMAND);
		if (j & EF_EEPROM_BUSY)
			delay(100);
		else
			break;
	}
	if (i == 0) {
		printf("%s: eeprom failed to come ready\n",
		   sc->sc_dv.dv_xname);
		return (1);
	}

	return (0);
}

void
efwatchdog(ifp)
	struct ifnet *ifp;
{
	struct ef_softc *sc = ifp->if_softc;

	printf("%s: device timeout\n", sc->sc_dv.dv_xname);
	sc->sc_arpcom.ac_if.if_oerrors++;
	efreset(sc);
}

void
efsetmulti(sc)
	struct ef_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct arpcom *ac = &sc->sc_arpcom;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int16_t cmd = SET_RX_FILTER | FIL_INDIVIDUAL | FIL_BRDCST;
	int mcnt = 0;

	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		mcnt++;
		ETHER_NEXT_MULTI(step, enm);
	}
	if (mcnt || ifp->if_flags & IFF_ALLMULTI)
		cmd |= FIL_MULTICAST;

	if (ifp->if_flags & IFF_PROMISC)
		cmd |= FIL_PROMISC;

	bus_space_write_2(iot, ioh, EP_COMMAND, cmd);
}

void
efread(sc)
	struct ef_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	int len;

	len = bus_space_read_2(iot, ioh, EF_W1_RX_STATUS);

#ifdef EF_DEBUG
	if (ifp->if_flags & IFF_DEBUG) {
		int err = len & ERR_MASK;
		char *s = NULL;

		if (len & ERR_INCOMPLETE)
			s = "incomplete packet";
		else if (err == ERR_OVERRUN)
			s = "packet overrun";
		else if (err == ERR_RUNT)
			s = "runt packet";
		else if (err == ERR_ALIGNMENT)
			s = "bad alignment";
		else if (err == ERR_CRC)
			s = "bad crc";
		else if (err == ERR_OVERSIZE)
			s = "oversized packet";
		else if (err == ERR_DRIBBLE)
			s = "dribble bits";

		if (s)
			printf("%s: %s\n", sc->sc_dv.dv_xname, s);
	}
#endif

	if (len & ERR_INCOMPLETE)
		return;

	if (len & ERR_RX) {
		ifp->if_ierrors++;
		efcompletecmd(sc, EP_COMMAND, RX_DISCARD_TOP_PACK);
		return;
	}

	len &= RX_BYTES_MASK;
	m = efget(sc, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		efcompletecmd(sc, EP_COMMAND, RX_DISCARD_TOP_PACK);
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

struct mbuf *
efget(sc, totlen)
	struct ef_softc *sc;
	int totlen;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct mbuf *top, **mp, *m;
	int len, pad, s;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);
	m->m_pkthdr.len = totlen;
	pad = ALIGN(sizeof(struct ether_header)) - sizeof(struct ether_header);
	m->m_data += pad;
	len = MHLEN -pad;
	top = 0;
	mp = &top;

	s = splhigh();

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				splx(s);
				return (NULL);
			}
			len = MLEN;
		}
		if (top && totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		len = min(totlen, len);
		if (len > 1) {
			len &= ~1;
			bus_space_read_raw_multi_2(iot, ioh,
			    EF_W1_RX_PIO_RR_1, mtod(m, u_int8_t *),
			    len);
		} else
			*(mtod(m, u_int8_t *)) =
			    bus_space_read_1(iot, ioh, EF_W1_RX_PIO_RR_1);

		m->m_len = len;
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	efcompletecmd(sc, EP_COMMAND, RX_DISCARD_TOP_PACK);

	splx(s);

	return (top);
}

#define MII_SET(sc, x) \
	bus_space_write_2((sc)->sc_iot, (sc)->sc_ioh, EP_W4_CTRLR_STATUS, \
	    bus_space_read_2((sc)->sc_iot, (sc)->sc_ioh, EP_W4_CTRLR_STATUS) \
	    | (x))

#define MII_CLR(sc, x) \
	bus_space_write_2((sc)->sc_iot, (sc)->sc_ioh, EP_W4_CTRLR_STATUS, \
	    bus_space_read_2((sc)->sc_iot, (sc)->sc_ioh, EP_W4_CTRLR_STATUS) \
	    & (~(x)))

void
ef_mii_writeb(sc, b)
	struct ef_softc *sc;
	int b;
{
	MII_CLR(sc, EF_MII_CLK);

	if (b)
		MII_SET(sc, EF_MII_DATA);
	else
		MII_CLR(sc, EF_MII_DATA);

	MII_CLR(sc, EF_MII_CLK);
	DELAY(1);
	MII_SET(sc, EF_MII_CLK);
	DELAY(1);
}

void
ef_mii_sync(sc)
	struct ef_softc *sc;
{
	int i;

	for (i = 0; i < 32; i++)
		ef_mii_writeb(sc, 1);
}

int
ef_miibus_readreg(dev, phy, reg)
	struct device *dev;
	int phy, reg;
{
	struct ef_softc *sc = (struct ef_softc *)dev;
	int i, ack, s, val = 0;

	s = splnet();

	GO_WINDOW(4);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_CTRLR_STATUS, 0);

	/* Turn on xmit */
	MII_SET(sc, EF_MII_DIR);
	MII_CLR(sc, EF_MII_CLK);

	ef_mii_sync(sc);

	/* Transmit start sequence */
	ef_mii_writeb(sc, 0);
	ef_mii_writeb(sc, 1);

	/* Transmit read sequence */
	ef_mii_writeb(sc, 1);
	ef_mii_writeb(sc, 0);

	/* Transmit phy addr */
	for (i = 0x10; i; i >>= 1)
		ef_mii_writeb(sc, (phy & i) ? 1 : 0);

	/* Transmit reg addr */
	for (i = 0x10; i; i >>= 1)
		ef_mii_writeb(sc, (reg & i) ? 1 : 0);

	/* First cycle of turnaround */
	MII_CLR(sc, EF_MII_CLK | EF_MII_DATA);
	DELAY(1);
	MII_SET(sc, EF_MII_CLK);
	DELAY(1);

	/* Turn off xmit */
	MII_CLR(sc, EF_MII_DIR);

	/* Second cycle of turnaround */
	MII_CLR(sc, EF_MII_CLK);
	DELAY(1);
	MII_SET(sc, EF_MII_CLK);
	DELAY(1);
	ack = bus_space_read_2(sc->sc_iot, sc->sc_ioh, EP_W4_CTRLR_STATUS) &
	    EF_MII_DATA;

	/* Read 16bit data */
	for (i = 0x8000; i; i >>= 1) {
		MII_CLR(sc, EF_MII_CLK);
		DELAY(1);
		if (bus_space_read_2(sc->sc_iot, sc->sc_ioh,
				     EP_W4_CTRLR_STATUS) & EF_MII_DATA)
			val |= i;
		MII_SET(sc, EF_MII_CLK);
		DELAY(1);
	}

	MII_CLR(sc, EF_MII_CLK);
	DELAY(1);
	MII_SET(sc, EF_MII_CLK);
	DELAY(1);

	splx(s);

	return (val);
}

void
ef_miibus_writereg(dev, phy, reg, val)
	struct device *dev;
	int phy, reg, val;
{
	struct ef_softc *sc = (struct ef_softc *)dev;
	int s, i;

	s = splnet();

	GO_WINDOW(4);
	bus_space_write_2(sc->sc_iot, sc->sc_ioh, EP_W4_CTRLR_STATUS, 0);

	/* Turn on xmit */
	MII_SET(sc, EF_MII_DIR);

	ef_mii_sync(sc);

	ef_mii_writeb(sc, 0);
	ef_mii_writeb(sc, 1);
	ef_mii_writeb(sc, 0);
	ef_mii_writeb(sc, 1);

	for (i = 0x10; i; i >>= 1)
		ef_mii_writeb(sc, (phy & i) ? 1 : 0);

	for (i = 0x10; i; i >>= 1)
		ef_mii_writeb(sc, (reg & i) ? 1 : 0);

	ef_mii_writeb(sc, 1);
	ef_mii_writeb(sc, 0);

	for (i = 0x8000; i; i >>= 1)
		ef_mii_writeb(sc, (val & i) ? 1 : 0);

	splx(s);
}

int
ef_ifmedia_upd(ifp)
	struct ifnet *ifp;
{
	struct ef_softc *sc = ifp->if_softc;

	mii_mediachg(&sc->sc_mii);
	return (0);
}

void
ef_ifmedia_sts(ifp, ifmr)
	struct ifnet *ifp;
	struct ifmediareq *ifmr;
{
	struct ef_softc *sc = ifp->if_softc;

	mii_pollstat(&sc->sc_mii);
	ifmr->ifm_status = sc->sc_mii.mii_media_status;
	ifmr->ifm_active = sc->sc_mii.mii_media_active;
}

void
ef_miibus_statchg(self)
	struct device *self;
{
	struct ef_softc *sc = (struct ef_softc *)self;
	int s;

	s = splnet();
	GO_WINDOW(3);
	/* Set duplex bit appropriately */
	if ((sc->sc_mii.mii_media_active & IFM_GMASK) == IFM_FDX)
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    EP_W3_MAC_CONTROL, 0x20);
	else
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    EP_W3_MAC_CONTROL, 0x00);
	GO_WINDOW(7);
	splx(s);
}

void
ef_tick(v)
	void *v;
{
	struct ef_softc *sc = v;
	int s;

	s = splnet();
	mii_tick(&sc->sc_mii);
	splx(s);
	timeout_add_sec(&sc->sc_tick_tmo, 1);
}
@


1.38
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.37 2015/12/08 13:34:22 tedu Exp $	*/
a321 2

	ifp->if_opackets++;
@


1.37
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.36 2015/11/25 11:20:38 mpi Exp $	*/
a202 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.36
log
@Network drivers should not include <net/route.h> or <net/netisr.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.35 2015/11/25 03:09:59 dlg Exp $	*/
d202 1
a202 1
	    IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS | IFF_MULTICAST;
@


1.35
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.34 2015/11/24 17:11:39 mpi Exp $	*/
a44 1
#include <net/netisr.h>
@


1.34
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.33 2015/11/24 13:33:17 mpi Exp $	*/
d240 1
a240 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d264 1
a264 1
		ifp->if_flags |= IFF_OACTIVE;
d442 1
a442 1
	ifp->if_flags &= ~IFF_OACTIVE;
d472 2
a473 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d527 1
a527 1
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
d590 1
a590 1
			sc->sc_arpcom.ac_if.if_flags &= ~IFF_OACTIVE;
@


1.33
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.32 2015/11/20 03:35:23 dlg Exp $	*/
a44 1
#include <net/if_dl.h>
@


1.32
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.31 2015/10/25 13:13:06 mpi Exp $	*/
a45 1
#include <net/if_types.h>
@


1.31
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.30 2015/07/08 07:21:50 mpi Exp $	*/
d246 1
a246 1
	IFQ_POLL(&ifp->if_snd, m0);
d257 1
a257 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d265 1
d281 1
a281 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.30
log
@MFREE(9) is dead, long live m_freem(9)!

ok bluhm@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.29 2015/06/24 09:40:54 mpi Exp $	*/
a337 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d346 1
a346 9
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			efinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			efinit(sc);
			break;
		}
@


1.29
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.28 2015/05/19 11:24:01 mpi Exp $	*/
d313 1
a313 1
		MFREE(m, m0);
@


1.28
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.27 2014/12/22 02:28:51 tedu Exp $	*/
a721 1
	ifp->if_ipackets++;
a722 1

@


1.27
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.26 2014/08/11 12:45:45 mpi Exp $	*/
d674 1
d723 1
d725 1
a725 6
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
a734 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a740 1
	m->m_pkthdr.rcvif = ifp;
@


1.26
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.25 2013/08/07 01:06:31 bluhm Exp $	*/
a347 1
#ifdef INET
a351 1
#endif
@


1.25
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.24 2008/11/28 02:44:17 brad Exp $	*/
a49 1
#ifdef INET
a50 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a51 1
#endif
@


1.24
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.23 2008/10/02 20:21:13 brad Exp $	*/
a52 1
#include <netinet/in_var.h>
@


1.23
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.22 2008/09/10 14:01:22 blambert Exp $	*/
a379 13
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_arpcom) :
		    ether_delmulti(ifr, &sc->sc_arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				efreset(sc);
			error = 0;
		}
		efsetmulti(sc);
		break;
d382 8
@


1.22
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.21 2006/03/25 22:41:44 djm Exp $	*/
a348 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d394 1
a394 2
		error = EINVAL;
		break;
@


1.21
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.20 2005/11/21 18:16:40 millert Exp $	*/
d474 1
a474 1
	timeout_add(&sc->sc_tick_tmo, hz);
d1012 1
a1012 1
	timeout_add(&sc->sc_tick_tmo, hz);
@


1.20
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.19 2005/11/09 05:46:21 brad Exp $	*/
d282 1
a282 1
		bpf_mtap(ifp->if_bpf, m0);
d743 1
a743 1
		bpf_mtap(ifp->if_bpf, m);
@


1.19
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.18 2005/01/15 05:24:11 brad Exp $	*/
d38 1
a38 1
#include <sys/select.h>
@


1.18
log
@make sure interface is in RUNNING state before touching the multicast filters

From NetBSD

NetBSD PR 27678 for details

ok mcbride@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.17 2004/09/28 01:02:14 brad Exp $	*/
d347 1
a347 1
	s = splimp();
d416 1
a416 1
	s = splimp();
d857 1
a857 1
	s = splimp();
d930 1
a930 1
	s = splimp();
d989 1
a989 1
	s = splimp();
d1009 1
a1009 1
	s = splimp();
@


1.17
log
@Use ETHER_MAX_DIX_LEN
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.16 2004/05/12 06:35:11 tedu Exp $	*/
d390 1
d392 2
a393 1
			efreset(sc);
@


1.16
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.15 2003/06/02 19:08:58 jason Exp $	*/
d432 1
a432 1
	    SET_TX_AVAIL_THRESH | (1536 >> 2));
@


1.15
log
@nuke clase 3 & 4
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.14 2002/03/14 01:26:56 millert Exp $	*/
a59 1
#include <net/bpfdesc.h>
@


1.14
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.13 2001/06/27 06:34:45 kjc Exp $	*/
a14 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Jason L. Wright
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.13
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.12 2001/06/25 04:44:28 fgsch Exp $	*/
d116 2
a117 2
int ef_isapnp_match	__P((struct device *, void *, void *));
void ef_isapnp_attach	__P((struct device *, struct device *, void *));
d119 22
a140 22
void efstart		__P((struct ifnet *));
int efioctl		__P((struct ifnet *, u_long, caddr_t));
void efwatchdog		__P((struct ifnet *));
void efreset		__P((struct ef_softc *));
void efstop		__P((struct ef_softc *));
void efsetmulti		__P((struct ef_softc *));
int efbusyeeprom	__P((struct ef_softc *));
int efintr		__P((void *));
void efinit		__P((struct ef_softc *));
void efcompletecmd	__P((struct ef_softc *, u_int, u_int));
void eftxstat		__P((struct ef_softc *));
void efread		__P((struct ef_softc *));
struct mbuf *efget	__P((struct ef_softc *, int totlen));

void ef_miibus_writereg	__P((struct device *, int, int, int));
void ef_miibus_statchg	__P((struct device *));
int ef_miibus_readreg	__P((struct device *, int, int));
void ef_mii_writeb	__P((struct ef_softc *, int));
void ef_mii_sync	__P((struct ef_softc *));
int ef_ifmedia_upd	__P((struct ifnet *));
void ef_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
void ef_tick		__P((void *));
@


1.13.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.13 2001/06/27 06:34:45 kjc Exp $	*/
d116 2
a117 2
int ef_isapnp_match(struct device *, void *, void *);
void ef_isapnp_attach(struct device *, struct device *, void *);
d119 22
a140 22
void efstart(struct ifnet *);
int efioctl(struct ifnet *, u_long, caddr_t);
void efwatchdog(struct ifnet *);
void efreset(struct ef_softc *);
void efstop(struct ef_softc *);
void efsetmulti(struct ef_softc *);
int efbusyeeprom(struct ef_softc *);
int efintr(void *);
void efinit(struct ef_softc *);
void efcompletecmd(struct ef_softc *, u_int, u_int);
void eftxstat(struct ef_softc *);
void efread(struct ef_softc *);
struct mbuf *efget(struct ef_softc *, int totlen);

void ef_miibus_writereg(struct device *, int, int, int);
void ef_miibus_statchg(struct device *);
int ef_miibus_readreg(struct device *, int, int);
void ef_mii_writeb(struct ef_softc *, int);
void ef_mii_sync(struct ef_softc *);
int ef_ifmedia_upd(struct ifnet *);
void ef_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void ef_tick(void *);
@


1.12
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.11 2001/06/23 21:54:48 fgsch Exp $	*/
d217 1
d257 1
a257 1
	m0 = ifp->if_snd.ifq_head;
d268 1
a268 1
		IF_DEQUEUE(&ifp->if_snd, m0);
d291 1
a291 1
	IF_DEQUEUE(&ifp->if_snd, m0);
@


1.11
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.10 2001/02/20 19:39:41 mickey Exp $	*/
a695 1
	struct ether_header *eh;
a743 2
	eh = mtod(m, struct ether_header *);

d749 1
a749 2
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.10
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.9 2000/11/11 23:49:20 mickey Exp $	*/
a91 4

#define	ETHER_MIN_LEN		64
#define	ETHER_MAX_LEN		1518
#define	ETHER_ADDR_LEN		6
@


1.9
log
@new timeouts; jason@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.8 2000/10/16 17:08:07 aaron Exp $	*/
a236 5

#if NBPFILTER > 0
	bpfattach(&sc->sc_arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
	   sizeof(struct ether_header));
#endif
@


1.8
log
@Use mii_attach() directly instead of mii_phy_probe().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.7 2000/06/07 02:48:22 aaron Exp $	*/
d47 1
d86 1
d212 2
d486 1
a486 1
	timeout(ef_tick, sc, hz);
d514 1
a514 1
	untimeout(ef_tick, sc);
d1028 1
a1028 1
	timeout(ef_tick, sc, hz);
@


1.7
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.6 2000/05/26 16:24:30 jason Exp $	*/
d223 2
a224 1
	mii_phy_probe(self, &sc->sc_mii, 0xffffffff);
@


1.6
log
@add missing 'break'
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.5 1999/12/02 20:55:06 jason Exp $	*/
d118 2
a119 2
int ef_isapnp_match __P((struct device *, void *, void *));
void ef_isapnp_attach __P((struct device *, struct device *, void *));
d121 22
a142 22
void efstart __P((struct ifnet *));
int efioctl __P((struct ifnet *, u_long, caddr_t));
void efwatchdog __P((struct ifnet *));
void efreset __P((struct ef_softc *));
void efstop __P((struct ef_softc *));
void efsetmulti __P((struct ef_softc *));
int efbusyeeprom __P((struct ef_softc *));
int efintr __P((void *));
void efinit __P((struct ef_softc *));
void efcompletecmd __P((struct ef_softc *, u_int, u_int));
void eftxstat __P((struct ef_softc *));
void efread __P((struct ef_softc *));
struct mbuf *efget __P((struct ef_softc *, int totlen));

void ef_miibus_writereg __P((struct device *, int, int, int));
void ef_miibus_statchg __P((struct device *));
int ef_miibus_readreg __P((struct device *, int, int));
void ef_mii_writeb __P((struct ef_softc *, int));
void ef_mii_sync __P((struct ef_softc *));
int ef_ifmedia_upd __P((struct ifnet *));
void ef_ifmedia_sts __P((struct ifnet *, struct ifmediareq *));
void ef_tick __P((void *));
@


1.5
log
@add proper media handling and use dev/mii
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.4 1999/08/08 19:16:08 deraadt Exp $	*/
d356 1
a356 1
	s = splnet();
d377 1
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.10 2001/02/20 19:39:41 mickey Exp $	*/
a46 1
#include <sys/timeout.h>
a84 1
	struct timeout		sc_tick_tmo;
d118 2
a119 2
int ef_isapnp_match	__P((struct device *, void *, void *));
void ef_isapnp_attach	__P((struct device *, struct device *, void *));
d121 22
a142 22
void efstart		__P((struct ifnet *));
int efioctl		__P((struct ifnet *, u_long, caddr_t));
void efwatchdog		__P((struct ifnet *));
void efreset		__P((struct ef_softc *));
void efstop		__P((struct ef_softc *));
void efsetmulti		__P((struct ef_softc *));
int efbusyeeprom	__P((struct ef_softc *));
int efintr		__P((void *));
void efinit		__P((struct ef_softc *));
void efcompletecmd	__P((struct ef_softc *, u_int, u_int));
void eftxstat		__P((struct ef_softc *));
void efread		__P((struct ef_softc *));
struct mbuf *efget	__P((struct ef_softc *, int totlen));

void ef_miibus_writereg	__P((struct device *, int, int, int));
void ef_miibus_statchg	__P((struct device *));
int ef_miibus_readreg	__P((struct device *, int, int));
void ef_mii_writeb	__P((struct ef_softc *, int));
void ef_mii_sync	__P((struct ef_softc *));
int ef_ifmedia_upd	__P((struct ifnet *));
void ef_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));
void ef_tick		__P((void *));
a209 2
	timeout_set(&sc->sc_tick_tmo, ef_tick, sc);

d223 1
a223 2
	mii_attach(self, &sc->sc_mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY,
	    0);
d233 5
d356 1
a356 1
	s = splimp();
a376 1
		break;
d480 1
a480 1
	timeout_add(&sc->sc_tick_tmo, hz);
d508 1
a508 1
	timeout_del(&sc->sc_tick_tmo);
d1022 1
a1022 1
	timeout_add(&sc->sc_tick_tmo, hz);
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.5.2.1 2001/05/14 22:24:40 niklas Exp $	*/
d93 4
a220 1
	IFQ_SET_READY(&ifp->if_snd);
d260 1
a260 1
	IFQ_POLL(&ifp->if_snd, m0);
d271 1
a271 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d294 1
a294 1
	IFQ_DEQUEUE(&ifp->if_snd, m0);
d700 1
d749 2
d756 2
a757 1
	ether_input_mbuf(ifp, m);
@


1.5.2.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d116 2
a117 2
int ef_isapnp_match(struct device *, void *, void *);
void ef_isapnp_attach(struct device *, struct device *, void *);
d119 22
a140 22
void efstart(struct ifnet *);
int efioctl(struct ifnet *, u_long, caddr_t);
void efwatchdog(struct ifnet *);
void efreset(struct ef_softc *);
void efstop(struct ef_softc *);
void efsetmulti(struct ef_softc *);
int efbusyeeprom(struct ef_softc *);
int efintr(void *);
void efinit(struct ef_softc *);
void efcompletecmd(struct ef_softc *, u_int, u_int);
void eftxstat(struct ef_softc *);
void efread(struct ef_softc *);
struct mbuf *efget(struct ef_softc *, int totlen);

void ef_miibus_writereg(struct device *, int, int, int);
void ef_miibus_statchg(struct device *);
int ef_miibus_readreg(struct device *, int, int);
void ef_mii_writeb(struct ef_softc *, int);
void ef_mii_sync(struct ef_softc *);
int ef_ifmedia_upd(struct ifnet *);
void ef_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void ef_tick(void *);
@


1.5.2.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.5.2.3 2002/03/28 12:11:35 niklas Exp $	*/
d15 5
@


1.5.2.5
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 1
@


1.5.4.1
log
@Pull in patch from current:
Errata:
The ef(4) driver will complain when adding an address with
ifconfig (ifconfig: SIOCAIFADDR: Invalid argument).
Fix:
add missing 'break'
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.6 2000/05/26 16:24:30 jason Exp $	*/
d356 1
a356 1
	s = splimp();
a376 1
		break;
@


1.4
log
@ioh is a bus_space_handle_t not a bus_space_tag_t
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.3 1999/08/05 18:06:28 jason Exp $	*/
d46 1
d71 2
d84 1
d135 3
a137 6
#if 0
/*
 * XXX not used (yet)
 */
int ef_mii_write __P((struct ef_softc *, int, int, int));
int ef_mii_read __P((struct ef_softc *, int, int));
d139 4
a142 1
#endif
a197 3
	/*
	 * XXX this assumes there is an MII transceiver
	 */
d218 12
a376 1
#if 0
d379 1
a379 1
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_media, cmd);
a380 1
#endif
d420 3
a422 1
	int i;
d473 2
d478 4
d501 1
d505 5
a820 4
#if 0
/*
 * XXX not used (yet)
 */
d849 10
d860 2
a861 2
ef_mii_read(sc, phy, reg)
	struct ef_softc *sc;
d864 1
d876 1
a876 3
	/* Transmit idle sequence */
	for (i = 0; i < 32; i++)
		ef_mii_writeb(sc, 1);
d932 3
a934 3
int
ef_mii_write(sc, phy, reg, val)
	struct ef_softc *sc;
d937 1
d948 1
a948 2
	for (i = 0; i < 32; i++)
		ef_mii_writeb(sc, 1);
d968 1
d970 7
d979 45
a1023 1
#endif
@


1.3
log
@more shaving...
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.2 1999/08/04 23:14:38 jason Exp $	*/
d408 1
a408 1
	bus_space_tag_t ioh = sc->sc_ioh;
@


1.2
log
@remove some unnecessary stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ef_isapnp.c,v 1.1 1999/08/04 03:29:27 jason Exp $	*/
d74 2
a84 1
	int			sc_full_duplex;
d131 4
d138 1
a191 7
	if (efbusyeeprom(sc))
		return;
	bus_space_write_2(iot, ioh, EF_W0_EEPROM_COMMAND, EF_EEPROM_READ | 16);
	if (efbusyeeprom(sc))
		return;
	x = bus_space_read_2(iot, ioh, EF_W0_EEPROM_DATA);

d243 1
a243 1
	if ((ifp->if_flags & IFF_RUNNING) == 0)
d486 1
a486 3
	bus_space_write_2(iot, ioh, EP_COMMAND, RX_DISCARD_TOP_PACK);
	while (bus_space_read_2(iot, ioh, EP_STATUS) & S_COMMAND_IN_PROGRESS)
		;
d574 1
d578 1
d583 1
d588 1
d679 1
d702 1
d796 4
d941 1
@


1.1
log
@Driver for the 3c515 FastEtherlink ISA
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a81 2
	int			sc_tx_busmaster;
	int			sc_rx_busmaster;
a85 18
struct ef_media_types {
	char		*efm_name;
	u_int16_t	efm_media_bits;	/* bits to set in Wn4_Media reg */
	u_int8_t	efm_mask;	/* xcvr present bit in W3 config */
	u_int8_t	efm_next;	/* next media type */
	int		efm_media;
} ef_media_types[] = {
	{ "10BaseT",	0x00c0,	0x08,	3,	IFM_ETHER|IFM_10_T	},
	{ "10Base5",	0x0008,	0x20,	8,	IFM_ETHER|IFM_10_5	},
	{ "undefined",	0x0000,	0x80,	0,	IFM_ETHER|IFM_NONE	},
	{ "10Base2",	0x0000,	0x10,	1,	IFM_ETHER|IFM_10_2	},
	{ "100BaseTX",	0x0080,	0x02,	5,	IFM_ETHER|IFM_100_TX	},
	{ "100BaseFX",	0x0080,	0x04,	6,	IFM_ETHER|IFM_100_FX	},
	{ "MII",	0x0000,	0x40,	0,	IFM_ETHER|IFM_AUTO	},
	{ "100BaseT4",	0x0000,	0x01,	0,	IFM_ETHER|IFM_100_T4	},
	{ "Default",	0x0000,	0xff,	0,	IFM_ETHER|IFM_AUTO	},
};

a119 1
void efshutdown __P((void *));
d160 1
a160 1
	int i, prt;
a169 2
	printf(":");

a191 4
	sc->sc_tx_busmaster = (x & 0x20) ? 1 : 0;
	sc->sc_rx_busmaster = (x & 0x20) ? 1 : 0;

	printf(" address %s", ether_sprintf(sc->sc_arpcom.ac_enaddr));
d193 1
a193 18
	GO_WINDOW(3);
	cfg = bus_space_read_4(iot, ioh, EP_W3_INTERNAL_CONFIG);
	x = bus_space_read_2(iot, ioh, EP_W3_RESET_OPTIONS);
	printf(" media ");
	prt = 0;
	if (cfg & 0x01000000) {
		printf("autoselect");
		prt = 1;
	}

	for (i = 0; i < 8; i++) {
		if (x & ef_media_types[i].efm_mask) {
			printf("%s%s", prt ? "/" : "",
			    ef_media_types[i].efm_name);
			prt = 1;
		}
	}
	printf("\n");
d198 2
a227 2
	shutdownhook_establish(efshutdown, sc);

d320 2
a321 12
		if (fillcnt == 1)
			bus_space_write_4(iot, ioh,
			    EF_W1_TX_PIO_WR_1, filler >> 24);
		else if (fillcnt == 2)
			bus_space_write_4(iot, ioh,
			    EF_W1_TX_PIO_WR_1, filler >> 16);
		else if (fillcnt == 3)
			bus_space_write_4(iot, ioh,
			    EF_W1_TX_PIO_WR_1, filler >> 8);
		else
			bus_space_write_4(iot, ioh,
			    EF_W1_TX_PIO_WR_1, filler);
d452 1
a452 2
	    (sc->sc_tx_busmaster ? S_DOWN_COMPLETE : S_TX_AVAIL) |
	    (sc->sc_rx_busmaster ? S_UP_COMPLETE : S_RX_COMPLETE) |
a500 10
}

void
efshutdown(vsc)
	void *vsc;
{
	struct ef_softc *sc = vsc;

	efstop(sc);
	efcompletecmd(sc, EP_COMMAND, GLOBAL_RESET);
@

