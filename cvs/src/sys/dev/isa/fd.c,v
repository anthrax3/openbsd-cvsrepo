head	1.103;
access;
symbols
	OPENBSD_6_1:1.103.0.6
	OPENBSD_6_1_BASE:1.103
	OPENBSD_6_0:1.103.0.4
	OPENBSD_6_0_BASE:1.103
	OPENBSD_5_9:1.103.0.2
	OPENBSD_5_9_BASE:1.103
	OPENBSD_5_8:1.102.0.4
	OPENBSD_5_8_BASE:1.102
	OPENBSD_5_7:1.101.0.4
	OPENBSD_5_7_BASE:1.101
	OPENBSD_5_6:1.100.0.4
	OPENBSD_5_6_BASE:1.100
	OPENBSD_5_5:1.98.0.4
	OPENBSD_5_5_BASE:1.98
	OPENBSD_5_4:1.94.0.2
	OPENBSD_5_4_BASE:1.94
	OPENBSD_5_3:1.92.0.8
	OPENBSD_5_3_BASE:1.92
	OPENBSD_5_2:1.92.0.6
	OPENBSD_5_2_BASE:1.92
	OPENBSD_5_1_BASE:1.92
	OPENBSD_5_1:1.92.0.4
	OPENBSD_5_0:1.92.0.2
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.90.0.2
	OPENBSD_4_9_BASE:1.90
	OPENBSD_4_8:1.85.0.2
	OPENBSD_4_8_BASE:1.85
	OPENBSD_4_7:1.83.0.2
	OPENBSD_4_7_BASE:1.83
	OPENBSD_4_6:1.76.0.4
	OPENBSD_4_6_BASE:1.76
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.74.0.2
	OPENBSD_4_4_BASE:1.74
	OPENBSD_4_3:1.68.0.2
	OPENBSD_4_3_BASE:1.68
	OPENBSD_4_2:1.67.0.2
	OPENBSD_4_2_BASE:1.67
	OPENBSD_4_1:1.60.0.2
	OPENBSD_4_1_BASE:1.60
	OPENBSD_4_0:1.55.0.2
	OPENBSD_4_0_BASE:1.55
	OPENBSD_3_9:1.52.0.2
	OPENBSD_3_9_BASE:1.52
	OPENBSD_3_8:1.50.0.4
	OPENBSD_3_8_BASE:1.50
	OPENBSD_3_7:1.50.0.2
	OPENBSD_3_7_BASE:1.50
	OPENBSD_3_6:1.48.0.4
	OPENBSD_3_6_BASE:1.48
	SMP_SYNC_A:1.48
	SMP_SYNC_B:1.48
	OPENBSD_3_5:1.48.0.2
	OPENBSD_3_5_BASE:1.48
	OPENBSD_3_4:1.47.0.2
	OPENBSD_3_4_BASE:1.47
	UBC_SYNC_A:1.46
	OPENBSD_3_3:1.45.0.4
	OPENBSD_3_3_BASE:1.45
	OPENBSD_3_2:1.45.0.2
	OPENBSD_3_2_BASE:1.45
	OPENBSD_3_1:1.44.0.2
	OPENBSD_3_1_BASE:1.44
	UBC_SYNC_B:1.45
	UBC:1.43.0.2
	UBC_BASE:1.43
	OPENBSD_3_0:1.42.0.4
	OPENBSD_3_0_BASE:1.42
	OPENBSD_2_9_BASE:1.42
	OPENBSD_2_9:1.42.0.2
	OPENBSD_2_8:1.41.0.8
	OPENBSD_2_8_BASE:1.41
	OPENBSD_2_7:1.41.0.6
	OPENBSD_2_7_BASE:1.41
	SMP:1.41.0.4
	SMP_BASE:1.41
	kame_19991208:1.41
	OPENBSD_2_6:1.41.0.2
	OPENBSD_2_6_BASE:1.41
	OPENBSD_2_5:1.40.0.2
	OPENBSD_2_5_BASE:1.40
	OPENBSD_2_4:1.39.0.2
	OPENBSD_2_4_BASE:1.39
	OPENBSD_2_3:1.37.0.2
	OPENBSD_2_3_BASE:1.37
	OPENBSD_2_2:1.35.0.2
	OPENBSD_2_2_BASE:1.35
	OPENBSD_2_1:1.34.0.2
	OPENBSD_2_1_BASE:1.34
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.103
date	2015.11.25.04.49.10;	author tedu;	state Exp;
branches;
next	1.102;
commitid	uHekxfoYO9oEdolX;

1.102
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.101;
commitid	p4LJxGKbi0BU2cG6;

1.101
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.100;
commitid	uzzBR7hz9ncd4O6G;

1.100
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.99;
commitid	I19imNlAX05zJOED;

1.99
date	2014.06.15.11.43.24;	author sf;	state Exp;
branches;
next	1.98;
commitid	Y0AWLKcfCeF28jP4;

1.98
date	2013.12.28.03.39.16;	author deraadt;	state Exp;
branches;
next	1.97;

1.97
date	2013.11.21.00.13.33;	author dlg;	state Exp;
branches;
next	1.96;

1.96
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.95;

1.95
date	2013.11.01.11.40.20;	author dlg;	state Exp;
branches;
next	1.94;

1.94
date	2013.06.11.16.42.15;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.04.05.41.48;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	2011.06.05.18.40.33;	author matthew;	state Exp;
branches;
next	1.90;

1.90
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.89;

1.89
date	2010.09.23.13.11.37;	author jsing;	state Exp;
branches;
next	1.88;

1.88
date	2010.09.22.01.18.57;	author matthew;	state Exp;
branches;
next	1.87;

1.87
date	2010.09.08.14.47.12;	author jsing;	state Exp;
branches;
next	1.86;

1.86
date	2010.08.28.20.23.22;	author matthew;	state Exp;
branches;
next	1.85;

1.85
date	2010.05.18.04.41.14;	author dlg;	state Exp;
branches;
next	1.84;

1.84
date	2010.04.23.15.25.21;	author jsing;	state Exp;
branches;
next	1.83;

1.83
date	2009.09.12.01.23.30;	author krw;	state Exp;
branches;
next	1.82;

1.82
date	2009.09.06.20.32.01;	author krw;	state Exp;
branches;
next	1.81;

1.81
date	2009.08.24.08.51.18;	author jasper;	state Exp;
branches;
next	1.80;

1.80
date	2009.08.24.08.31.50;	author jasper;	state Exp;
branches;
next	1.79;

1.79
date	2009.08.23.15.02.21;	author jasper;	state Exp;
branches;
next	1.78;

1.78
date	2009.08.13.15.23.12;	author deraadt;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.05.13.45.29;	author blambert;	state Exp;
branches;
next	1.76;

1.76
date	2009.06.02.12.32.08;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.74;

1.74
date	2008.06.12.06.58.39;	author deraadt;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.11.12.35.45;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.10.20.50.23;	author beck;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.22.22.54.42;	author krw;	state Exp;
branches;
next	1.70;

1.70
date	2008.03.21.20.30.02;	author krw;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.20.00.59.37;	author krw;	state Exp;
branches;
next	1.68;

1.68
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.67;

1.67
date	2007.06.20.18.15.46;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.06.08.05.27.58;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.06.17.15.13;	author deraadt;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.05.00.38.21;	author deraadt;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.01.00.07.48;	author krw;	state Exp;
branches;
next	1.62;

1.62
date	2007.05.08.20.59.39;	author deraadt;	state Exp;
branches;
next	1.61;

1.61
date	2007.04.27.22.20.01;	author krw;	state Exp;
branches;
next	1.60;

1.60
date	2007.02.15.00.53.26;	author krw;	state Exp;
branches;
next	1.59;

1.59
date	2007.02.14.00.53.48;	author jsg;	state Exp;
branches;
next	1.58;

1.58
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.57;

1.57
date	2006.11.29.12.24.17;	author miod;	state Exp;
branches;
next	1.56;

1.56
date	2006.09.26.23.33.04;	author krw;	state Exp;
branches;
next	1.55;

1.55
date	2006.08.13.16.24.12;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2006.08.13.03.36.24;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2006.03.15.20.20.41;	author miod;	state Exp;
branches;
next	1.52;

1.52
date	2006.01.22.00.40.02;	author miod;	state Exp;
branches;
next	1.51;

1.51
date	2005.09.19.01.28.04;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2005.03.16.19.58.40;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2004.02.15.02.45.47;	author tedu;	state Exp;
branches;
next	1.47;

1.47
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.46;

1.46
date	2003.04.06.15.28.25;	author krw;	state Exp;
branches;
next	1.45;

1.45
date	2002.05.24.13.31.10;	author art;	state Exp;
branches;
next	1.44;

1.44
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.43;

1.43
date	2001.10.26.01.28.06;	author nate;	state Exp;
branches
	1.43.2.1;
next	1.42;

1.42
date	2001.03.06.13.55.02;	author ho;	state Exp;
branches;
next	1.41;

1.41
date	99.10.07.18.47.19;	author downsj;	state Exp;
branches
	1.41.4.1;
next	1.40;

1.40
date	99.01.07.06.14.48;	author niklas;	state Exp;
branches;
next	1.39;

1.39
date	98.10.03.21.19.00;	author millert;	state Exp;
branches;
next	1.38;

1.38
date	98.08.08.23.01.13;	author downsj;	state Exp;
branches;
next	1.37;

1.37
date	98.01.18.18.48.41;	author niklas;	state Exp;
branches;
next	1.36;

1.36
date	97.11.12.07.33.10;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	97.10.18.10.37.09;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	97.04.07.22.48.08;	author rees;	state Exp;
branches;
next	1.33;

1.33
date	96.12.05.17.40.01;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	96.12.05.17.22.40;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	96.12.05.17.16.05;	author deraadt;	state Exp;
branches;
next	1.30;

1.30
date	96.12.05.13.13.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	96.11.29.22.54.55;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	96.11.12.20.30.31;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	96.10.28.00.36.18;	author downsj;	state Exp;
branches;
next	1.26;

1.26
date	96.10.28.00.06.20;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	96.10.26.08.07.24;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	96.10.26.06.22.37;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	96.10.16.12.46.22;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	96.09.23.15.31.53;	author mickey;	state Exp;
branches;
next	1.21;

1.21
date	96.09.01.20.58.26;	author downsj;	state Exp;
branches;
next	1.20;

1.20
date	96.08.29.18.03.27;	author downsj;	state Exp;
branches;
next	1.19;

1.19
date	96.08.07.15.54.41;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	96.06.20.07.51.37;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	96.06.09.19.40.28;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.06.01.09.36.52;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.05.25.22.17.48;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.05.07.07.22.16;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.04.21.22.16.52;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.04.18.17.12.13;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.03.20.00.31.02;	author mickey;	state Exp;
branches;
next	1.10;

1.10
date	96.03.19.21.09.32;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	96.02.20.12.07.04;	author hannken;	state Exp;
branches;
next	1.8;

1.8
date	96.02.20.04.35.29;	author tholo;	state Exp;
branches;
next	1.7;

1.7
date	96.02.02.19.28.41;	author dm;	state Exp;
branches;
next	1.6;

1.6
date	96.01.15.00.58.16;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.01.12.20.20.23;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	95.12.30.08.25.42;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.10.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.43.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.50.37;	author deraadt;	state Exp;
branches;
next	;

1.41.4.1
date	2001.05.14.22.24.32;	author niklas;	state Exp;
branches;
next	1.41.4.2;

1.41.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.41.4.3;

1.41.4.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.41.4.4;

1.41.4.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.41.4.5;

1.41.4.5
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	1.41.4.6;

1.41.4.6
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.41.4.7;

1.41.4.7
date	2004.06.05.23.12.45;	author niklas;	state Exp;
branches;
next	;

1.43.2.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.43.2.2;

1.43.2.2
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.103
log
@add size to free
@
text
@/*	$OpenBSD: fd.c,v 1.102 2015/03/14 03:38:47 jsg Exp $	*/
/*	$NetBSD: fd.c,v 1.90 1996/05/12 23:12:03 mycroft Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995, 1996 Charles Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Don Ahn.
 *
 * Portions Copyright (c) 1993, 1994 by
 *  jc@@irbs.UUCP (John Capo)
 *  vak@@zebub.msk.su (Serge Vakulenko)
 *  ache@@astral.msk.su (Andrew A. Chernov)
 *  joerg_wunsch@@uriah.sax.de (Joerg Wunsch)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fd.c	7.4 (Berkeley) 5/25/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/mtio.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/stat.h>
#include <sys/timeout.h>
#include <sys/dkio.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/intr.h>
#include <machine/ioctl_fd.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <dev/isa/fdreg.h>

#if defined(__i386__) || defined(__amd64__)	/* XXX */
#include <i386/isa/nvram.h>
#endif

#include <dev/isa/fdlink.h>

/* XXX misuse a flag to identify format operation */
#define B_FORMAT B_XXX

/* fd_type struct now in ioctl_fd.h */

/* The order of entries in the following table is important -- BEWARE! */
struct fd_type fd_types[] = {
        { 18,2,36,2,0xff,0xcf,0x1b,0x6c,80,2880,1,FDC_500KBPS,"1.44MB"    }, /* 1.44MB diskette */
        { 15,2,30,2,0xff,0xdf,0x1b,0x54,80,2400,1,FDC_500KBPS, "1.2MB"    }, /* 1.2 MB AT-diskettes */
        {  9,2,18,2,0xff,0xdf,0x23,0x50,40, 720,2,FDC_300KBPS, "360KB/AT" }, /* 360kB in 1.2MB drive */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,1,FDC_250KBPS, "360KB/PC" }, /* 360kB PC diskettes */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,80,1440,1,FDC_250KBPS, "720KB"    }, /* 3.5" 720kB diskette */
        {  9,2,18,2,0xff,0xdf,0x23,0x50,80,1440,1,FDC_300KBPS, "720KB/x"  }, /* 720kB in 1.2MB drive */
        {  9,2,18,2,0xff,0xdf,0x2a,0x50,40, 720,2,FDC_250KBPS, "360KB/x"  }, /* 360kB in 720kB drive */
	{ 36,2,72,2,0xff,0xaf,0x1b,0x54,80,5760,1,FDC_500KBPS,"2.88MB"    },  /* 2.88MB diskette */
	{  8,2,16,3,0xff,0xdf,0x35,0x74,77,1232,1,FDC_500KBPS,"1.2MB/[1024bytes/sector]" }	/* 1.2 MB japanese format */
};

/* software state, per disk (with up to 4 disks per ctlr) */
struct fd_softc {
	struct device sc_dev;
	struct disk sc_dk;

	struct fd_type *sc_deftype;	/* default type descriptor */
	struct fd_type *sc_type;	/* current type descriptor */

	daddr_t	sc_blkno;	/* starting block number */
	int sc_bcount;		/* byte count left */
 	int sc_opts;			/* user-set options */
	int sc_skip;		/* bytes already transferred */
	int sc_nblks;		/* number of blocks currently transferring */
	int sc_nbytes;		/* number of bytes currently transferring */

	int sc_drive;		/* physical unit number */
	int sc_flags;
#define	FD_OPEN		0x01		/* it's open */
#define	FD_MOTOR	0x02		/* motor should be on */
#define	FD_MOTOR_WAIT	0x04		/* motor coming up */
	int sc_cylin;		/* where we think the head is */

	TAILQ_ENTRY(fd_softc) sc_drivechain;
	int sc_ops;		/* I/O ops since last switch */
	struct bufq sc_bufq;	/* pending I/O */
	struct buf *sc_bp;	/* the current I/O */
	struct timeout fd_motor_on_to;
	struct timeout fd_motor_off_to;
	struct timeout fdtimeout_to;
};

/* floppy driver configuration */
int fdprobe(struct device *, void *, void *);
void fdattach(struct device *, struct device *, void *);
int fdactivate(struct device *, int);

struct cfattach fd_ca = {
	sizeof(struct fd_softc), fdprobe, fdattach, NULL, fdactivate
};

struct cfdriver fd_cd = {
	NULL, "fd", DV_DISK
};

int fdgetdisklabel(dev_t, struct fd_softc *, struct disklabel *, int);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdintr(struct fdc_softc *);

void fd_set_motor(struct fdc_softc *fdc, int reset);
void fd_motor_off(void *arg);
void fd_motor_on(void *arg);
void fdfinish(struct fd_softc *fd, struct buf *bp);
int fdformat(dev_t, struct fd_formb *, struct proc *);
static __inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
void fdretry(struct fd_softc *);
void fdtimeout(void *);

int
fdgetdisklabel(dev_t dev, struct fd_softc *fd, struct disklabel *lp,
    int spoofonly)
{
	bzero(lp, sizeof(struct disklabel));

	lp->d_type = DTYPE_FLOPPY;
	lp->d_secsize = FD_BSIZE(fd);
	lp->d_secpercyl = fd->sc_type->seccyl;
	lp->d_nsectors = fd->sc_type->sectrac;
	lp->d_ncylinders = fd->sc_type->tracks;
	lp->d_ntracks = fd->sc_type->heads;	/* Go figure... */
	DL_SETDSIZE(lp, fd->sc_type->size);

	strncpy(lp->d_typename, "floppy disk", sizeof(lp->d_typename));
	strncpy(lp->d_packname, "fictitious", sizeof(lp->d_packname));
	lp->d_version = 1;

	lp->d_magic = DISKMAGIC;
	lp->d_magic2 = DISKMAGIC;
	lp->d_checksum = dkcksum(lp);

	/*
	 * Call the generic disklabel extraction routine.  If there's
	 * not a label there, fake it.
	 */
	return readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, spoofonly);
}

int
fdprobe(struct device *parent, void *match, void *aux)
{
	struct fdc_softc *fdc = (void *)parent;
	struct cfdata *cf = match;
	struct fdc_attach_args *fa = aux;
	int drive = fa->fa_drive;
	bus_space_tag_t iot = fdc->sc_iot;
	bus_space_handle_t ioh = fdc->sc_ioh;
	int n;

	if (cf->cf_loc[0] != -1 && cf->cf_loc[0] != drive)
		return 0;
	/*
	 * XXX
	 * This is to work around some odd interactions between this driver
	 * and SMC Ethernet cards.
	 */
	if (cf->cf_loc[0] == -1 && drive >= 2)
		return 0;

	/*
	 * We want to keep the flags config gave us.
	 */
	fa->fa_flags = cf->cf_flags;

	/* select drive and turn on motor */
	bus_space_write_1(iot, ioh, fdout, drive | FDO_FRST | FDO_MOEN(drive));
	/* wait for motor to spin up */
	delay(250000);
	out_fdc(iot, ioh, NE7CMD_RECAL);
	out_fdc(iot, ioh, drive);
	/* wait for recalibrate */
	delay(2000000);
	out_fdc(iot, ioh, NE7CMD_SENSEI);
	n = fdcresult(fdc);
#ifdef FD_DEBUG
	{
		int i;
		printf("fdprobe: status");
		for (i = 0; i < n; i++)
			printf(" %x", fdc->sc_status[i]);
		printf("\n");
	}
#endif

	/* turn off motor */
	delay(250000);
	bus_space_write_1(iot, ioh, fdout, FDO_FRST);

	/* flags & 0x20 forces the drive to be found even if it won't probe */
	if (!(fa->fa_flags & 0x20) && (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20))
		return 0;

	return 1;
}

/*
 * Controller is working, and drive responded.  Attach it.
 */
void
fdattach(struct device *parent, struct device *self, void *aux)
{
	struct fdc_softc *fdc = (void *)parent;
	struct fd_softc *fd = (void *)self;
	struct fdc_attach_args *fa = aux;
	struct fd_type *type = fa->fa_deftype;
	int drive = fa->fa_drive;

	if (!type || (fa->fa_flags & 0x10)) {
		/* The config has overridden this. */
		switch (fa->fa_flags & 0x07) {
		case 1:	/* 2.88MB */
			type = &fd_types[7];
			break;
		case 2:	/* 1.44MB */
			type = &fd_types[0];
			break;
		case 3: /* 1.2MB */
			type = &fd_types[1];
			break;
		case 4: /* 720K */
			type = &fd_types[4];
			break;
		case 5: /* 360K */
			type = &fd_types[3];
			break;
		case 6:	/* 1.2 MB japanese format */
			type = &fd_types[8];
			break;
#ifdef __alpha__
		default:
			/* 1.44MB, how to detect others?
			 * idea from NetBSD -- jay@@rootaction.net
                         */
			type = &fd_types[0];
#endif
		}
	}

	if (type)
		printf(": %s %d cyl, %d head, %d sec\n", type->name,
		    type->tracks, type->heads, type->sectrac);
	else
		printf(": density unknown\n");

	fd->sc_cylin = -1;
	fd->sc_drive = drive;
	fd->sc_deftype = type;
	fdc->sc_type[drive] = FDC_TYPE_DISK;
	fdc->sc_link.fdlink.sc_fd[drive] = fd;

	/*
	 * Initialize and attach the disk structure.
	 */
	fd->sc_dk.dk_flags = DKF_NOLABELREAD;
	fd->sc_dk.dk_name = fd->sc_dev.dv_xname;
	bufq_init(&fd->sc_bufq, BUFQ_DEFAULT);
	disk_attach(&fd->sc_dev, &fd->sc_dk);

	/* Setup timeout structures */
	timeout_set(&fd->fd_motor_on_to, fd_motor_on, fd);
	timeout_set(&fd->fd_motor_off_to, fd_motor_off, fd);
	timeout_set(&fd->fdtimeout_to, fdtimeout, fd);
}

int
fdactivate(struct device *self, int act)
{
	struct fd_softc *fd = (void *)self;
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		if (fdc->sc_state != DEVIDLE) {
			timeout_del(&fd->fd_motor_on_to);
			timeout_del(&fd->fd_motor_off_to);
			timeout_del(&fd->fdtimeout_to);
			fdc->sc_state = IOTIMEDOUT;
			fdc->sc_errors = 4;
		}
		break;
	case DVACT_POWERDOWN:
		fd_motor_off(self);
		break;
	}

	return (rv);
}

/*
 * Translate nvram type into internal data structure.  Return NULL for
 * none/unknown/unusable.
 */
struct fd_type *
fd_nvtotype(char *fdc, int nvraminfo, int drive)
{
#ifdef __alpha__
	/* Alpha:  assume 1.44MB, idea from NetBSD sys/dev/isa/fd.c
	 * -- jay@@rootaction.net
	 */
	return &fd_types[0]; /* 1.44MB */
#else
	int type;

	type = (drive == 0 ? nvraminfo : nvraminfo << 4) & 0xf0;
	switch (type) {
	case NVRAM_DISKETTE_NONE:
		return NULL;
	case NVRAM_DISKETTE_12M:
		return &fd_types[1];
	case NVRAM_DISKETTE_TYPE5:
	case NVRAM_DISKETTE_TYPE6:
		return &fd_types[7];
	case NVRAM_DISKETTE_144M:
		return &fd_types[0];
	case NVRAM_DISKETTE_360K:
		return &fd_types[3];
	case NVRAM_DISKETTE_720K:
		return &fd_types[4];
	default:
		printf("%s: drive %d: unknown device type 0x%x\n",
		    fdc, drive, type);
		return NULL;
	}
#endif
}

static __inline struct fd_type *
fd_dev_to_type(struct fd_softc *fd, dev_t dev)
{
	int type = FDTYPE(dev);

	if (type > (sizeof(fd_types) / sizeof(fd_types[0])))
		return NULL;
	return type ? &fd_types[type - 1] : fd->sc_deftype;
}

void
fdstrategy(struct buf *bp)
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(bp->b_dev)];
	int sz;
 	int s;
	int fd_bsize = FD_BSIZE(fd);
	int bf = fd_bsize / DEV_BSIZE;

	/* Valid unit, controller, and request? */
	if (bp->b_blkno < 0 ||
	    (((bp->b_blkno % bf) != 0 ||
	      (bp->b_bcount % fd_bsize) != 0) &&
	     (bp->b_flags & B_FORMAT) == 0)) {
		bp->b_error = EINVAL;
		goto bad;
	}

	/* If it's a null transfer, return immediately. */
	if (bp->b_bcount == 0)
		goto done;

	sz = howmany(bp->b_bcount, DEV_BSIZE);

	if (bp->b_blkno + sz > fd->sc_type->size * bf) {
		sz = fd->sc_type->size * bf - bp->b_blkno;
		if (sz == 0)
			/* If exactly at end of disk, return EOF. */
			goto done;
		if (sz < 0) {
			/* If past end of disk, return EINVAL. */
			bp->b_error = EINVAL;
			goto bad;
		}
		/* Otherwise, truncate request. */
		bp->b_bcount = sz << DEV_BSHIFT;
	}

	bp->b_resid = bp->b_bcount;

#ifdef FD_DEBUG
	printf("fdstrategy: b_blkno %lld b_bcount %d blkno %lld sz %d\n",
	    (long long)bp->b_blkno, bp->b_bcount,
	    (long long)fd->sc_blkno, sz);
#endif

	/* Queue I/O */
	bufq_queue(&fd->sc_bufq, bp);

	/* Queue transfer on drive, activate drive and controller if idle. */
	s = splbio();
	timeout_del(&fd->fd_motor_off_to); /* a good idea */
	if (fd->sc_bp == NULL)
		fdstart(fd);
#ifdef DIAGNOSTIC
	else {
		struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
		if (fdc->sc_state == DEVIDLE) {
			printf("fdstrategy: controller inactive\n");
			fdcstart(fdc);
		}
	}
#endif
	splx(s);
	return;

bad:
	bp->b_flags |= B_ERROR;
done:
	/* Toss transfer; we're done early. */
	bp->b_resid = bp->b_bcount;
	s = splbio();
	biodone(bp);
	splx(s);
}

void
fdstart(struct fd_softc *fd)
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int active = !TAILQ_EMPTY(&fdc->sc_link.fdlink.sc_drives);

	/* Link into controller queue. */
	fd->sc_bp = bufq_dequeue(&fd->sc_bufq);
	TAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);

	/* If controller not already active, start it. */
	if (!active)
		fdcstart(fdc);
}

void
fdfinish(struct fd_softc *fd, struct buf *bp)
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;

	splassert(IPL_BIO);

	fd->sc_skip = 0;
	fd->sc_bp = bufq_dequeue(&fd->sc_bufq);

	/*
	 * Move this drive to the end of the queue to give others a `fair'
	 * chance.  We only force a switch if N operations are completed while
	 * another drive is waiting to be serviced, since there is a long motor
	 * startup delay whenever we switch.
	 */
	if (TAILQ_NEXT(fd, sc_drivechain) != NULL && ++fd->sc_ops >= 8) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);
		if (fd->sc_bp != NULL) {
			TAILQ_INSERT_TAIL(&fdc->sc_link.fdlink.sc_drives, fd,
					  sc_drivechain);
		}
	}

	biodone(bp);
	/* turn off motor 5s from now */
	timeout_add_sec(&fd->fd_motor_off_to, 5);
	fdc->sc_state = DEVIDLE;
}

int
fdread(dev_t dev, struct uio *uio, int flags)
{
	return (physio(fdstrategy, dev, B_READ, minphys, uio));
}

int
fdwrite(dev_t dev, struct uio *uio, int flags)
{
	return (physio(fdstrategy, dev, B_WRITE, minphys, uio));
}

void
fd_set_motor(struct fdc_softc *fdc, int reset)
{
	struct fd_softc *fd;
	u_char status;
	int n;

	if ((fd = TAILQ_FIRST(&fdc->sc_link.fdlink.sc_drives)) != NULL)
		status = fd->sc_drive;
	else
		status = 0;
	if (!reset)
		status |= FDO_FRST | FDO_FDMAEN;
	for (n = 0; n < 4; n++)
		if ((fd = fdc->sc_link.fdlink.sc_fd[n])
		    && (fd->sc_flags & FD_MOTOR))
			status |= FDO_MOEN(n);
	bus_space_write_1(fdc->sc_iot, fdc->sc_ioh, fdout, status);
}

void
fd_motor_off(void *arg)
{
	struct fd_softc *fd = arg;
	int s;

	s = splbio();
	fd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
	fd_set_motor((struct fdc_softc *)fd->sc_dev.dv_parent, 0);
	splx(s);
}

void
fd_motor_on(void *arg)
{
	struct fd_softc *fd = arg;
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int s;

	s = splbio();
	fd->sc_flags &= ~FD_MOTOR_WAIT;
	if ((TAILQ_FIRST(&fdc->sc_link.fdlink.sc_drives) == fd)
	    && (fdc->sc_state == MOTORWAIT))
		(void) fdintr(fdc);
	splx(s);
}

int
fdopen(dev_t dev, int flags, int fmt, struct proc *p)
{
 	int unit, pmask;
	struct fd_softc *fd;
	struct fd_type *type;

	unit = FDUNIT(dev);
	if (unit >= fd_cd.cd_ndevs)
		return ENXIO;
	fd = fd_cd.cd_devs[unit];
	if (fd == 0)
		return ENXIO;
	type = fd_dev_to_type(fd, dev);
	if (type == NULL)
		return ENXIO;

	if ((fd->sc_flags & FD_OPEN) != 0 &&
	    fd->sc_type != type)
		return EBUSY;

	fd->sc_type = type;
	fd->sc_cylin = -1;
	fd->sc_flags |= FD_OPEN;

	/*
	 * Only update the disklabel if we're not open anywhere else.
	 */
	if (fd->sc_dk.dk_openmask == 0)
		fdgetdisklabel(dev, fd, fd->sc_dk.dk_label, 0);

	pmask = (1 << FDPART(dev));

	switch (fmt) {
	case S_IFCHR:
		fd->sc_dk.dk_copenmask |= pmask;
		break;

	case S_IFBLK:
		fd->sc_dk.dk_bopenmask |= pmask;
		break;
	}
	fd->sc_dk.dk_openmask =
	    fd->sc_dk.dk_copenmask | fd->sc_dk.dk_bopenmask;

	return 0;
}

int
fdclose(dev_t dev, int flags, int fmt, struct proc *p)
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	int pmask = (1 << FDPART(dev));

	fd->sc_flags &= ~FD_OPEN;
	fd->sc_opts &= ~FDOPT_NORETRY;

	switch (fmt) {
	case S_IFCHR:
		fd->sc_dk.dk_copenmask &= ~pmask;
		break;

	case S_IFBLK:
		fd->sc_dk.dk_bopenmask &= ~pmask;
		break;
	}
	fd->sc_dk.dk_openmask =
	    fd->sc_dk.dk_copenmask | fd->sc_dk.dk_bopenmask;

	return (0);
}

daddr_t
fdsize(dev_t dev)
{
	/* Swapping to floppies would not make sense. */
	return -1;
}

int
fddump(dev_t dev, daddr_t blkno, caddr_t va, size_t size)
{
	/* Not implemented. */
	return ENXIO;
}

/*
 * Called from the controller.
 */
int
fdintr(struct fdc_softc *fdc)
{
#define	st0	fdc->sc_status[0]
#define	cyl	fdc->sc_status[1]
	struct fd_softc *fd;
	struct buf *bp;
	bus_space_tag_t iot = fdc->sc_iot;
	bus_space_handle_t ioh = fdc->sc_ioh;
	bus_space_handle_t ioh_ctl = fdc->sc_ioh_ctl;
	int read, head, sec, i, nblks, cylin;
	struct fd_type *type;
	struct fd_formb *finfo = NULL;
	int fd_bsize;

loop:
	/* Is there a transfer to this drive?  If not, deactivate drive. */
	fd = TAILQ_FIRST(&fdc->sc_link.fdlink.sc_drives);
	if (fd == NULL) {
		fdc->sc_state = DEVIDLE;
		return 1;
	}
	fd_bsize = FD_BSIZE(fd);

	bp = fd->sc_bp;
	if (bp == NULL) {
		fd->sc_ops = 0;
		TAILQ_REMOVE(&fdc->sc_link.fdlink.sc_drives, fd, sc_drivechain);
		goto loop;
	}

	if (bp->b_flags & B_FORMAT)
	    finfo = (struct fd_formb *)bp->b_data;

	cylin = ((bp->b_blkno * DEV_BSIZE) + (bp->b_bcount - bp->b_resid)) /
	    (fd_bsize * fd->sc_type->seccyl);

	switch (fdc->sc_state) {
	case DEVIDLE:
		fdc->sc_errors = 0;
		fd->sc_skip = 0;
		fd->sc_bcount = bp->b_bcount;
		fd->sc_blkno = bp->b_blkno / (fd_bsize / DEV_BSIZE);
		timeout_del(&fd->fd_motor_off_to);
		if ((fd->sc_flags & FD_MOTOR_WAIT) != 0) {
			fdc->sc_state = MOTORWAIT;
			return 1;
		}
		if ((fd->sc_flags & FD_MOTOR) == 0) {
			/* Turn on the motor, being careful about pairing. */
			struct fd_softc *ofd =
				fdc->sc_link.fdlink.sc_fd[fd->sc_drive ^ 1];
			if (ofd && ofd->sc_flags & FD_MOTOR) {
				timeout_del(&ofd->fd_motor_off_to);
				ofd->sc_flags &= ~(FD_MOTOR | FD_MOTOR_WAIT);
			}
			fd->sc_flags |= FD_MOTOR | FD_MOTOR_WAIT;
			fd_set_motor(fdc, 0);
			fdc->sc_state = MOTORWAIT;
			/* Allow .25s for motor to stabilize. */
			timeout_add_msec(&fd->fd_motor_on_to, 250);
			return 1;
		}
		/* Make sure the right drive is selected. */
		fd_set_motor(fdc, 0);

		/* FALLTHROUGH */
	case DOSEEK:
	doseek:
		if (fd->sc_cylin == cylin)
			goto doio;

		out_fdc(iot, ioh, NE7CMD_SPECIFY);/* specify command */
		out_fdc(iot, ioh, fd->sc_type->steprate);
		out_fdc(iot, ioh, 6);		/* XXX head load time == 6ms */

		out_fdc(iot, ioh, NE7CMD_SEEK);	/* seek function */
		out_fdc(iot, ioh, fd->sc_drive);	/* drive number */
		out_fdc(iot, ioh, cylin * fd->sc_type->step);

		fd->sc_cylin = -1;
		fdc->sc_state = SEEKWAIT;

		fd->sc_dk.dk_seek++;
		disk_busy(&fd->sc_dk);

		timeout_add_sec(&fd->fdtimeout_to, 4);
		return 1;

	case DOIO:
	doio:
		type = fd->sc_type;
		if (finfo)
		    fd->sc_skip = (char *)&(finfo->fd_formb_cylno(0)) -
			(char *)finfo;
		sec = fd->sc_blkno % type->seccyl;
		nblks = type->seccyl - sec;
		nblks = min(nblks, fd->sc_bcount / fd_bsize);
		nblks = min(nblks, FDC_MAXIOSIZE / fd_bsize);
		fd->sc_nblks = nblks;
		fd->sc_nbytes = finfo ? bp->b_bcount : nblks * fd_bsize;
		head = sec / type->sectrac;
		sec -= head * type->sectrac;
#ifdef DIAGNOSTIC
		{int block;
		 block = (fd->sc_cylin * type->heads + head) * type->sectrac + sec;
		 if (block != fd->sc_blkno) {
			 panic("fdintr: block %d != blkno %llu", block, fd->sc_blkno);
		 }}
#endif
		read = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;
		isadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq, read);
		bus_space_write_1(iot, ioh_ctl, fdctl, type->rate);
#ifdef FD_DEBUG
		printf("fdintr: %s drive %d track %d head %d sec %d nblks %d\n",
		    read ? "read" : "write", fd->sc_drive, fd->sc_cylin, head,
		    sec, nblks);
#endif
		if (finfo) {
                        /* formatting */
			if (out_fdc(iot, ioh, NE7CMD_FORMAT) < 0) {
			    fdc->sc_errors = 4;
			    fdretry(fd);
			    goto loop;
			}
                        out_fdc(iot, ioh, (head << 2) | fd->sc_drive);
                        out_fdc(iot, ioh, finfo->fd_formb_secshift);
                        out_fdc(iot, ioh, finfo->fd_formb_nsecs);
                        out_fdc(iot, ioh, finfo->fd_formb_gaplen);
                        out_fdc(iot, ioh, finfo->fd_formb_fillbyte);
		} else {
			if (read)
				out_fdc(iot, ioh, NE7CMD_READ);	/* READ */
			else
				out_fdc(iot, ioh, NE7CMD_WRITE);/* WRITE */
			out_fdc(iot, ioh, (head << 2) | fd->sc_drive);
			out_fdc(iot, ioh, fd->sc_cylin);	/* track */
			out_fdc(iot, ioh, head);
			out_fdc(iot, ioh, sec + 1);		/* sec +1 */
			out_fdc(iot, ioh, type->secsize);	/* sec size */
			out_fdc(iot, ioh, type->sectrac);	/* secs/track */
			out_fdc(iot, ioh, type->gap1);		/* gap1 size */
			out_fdc(iot, ioh, type->datalen);	/* data len */
		}
		fdc->sc_state = IOCOMPLETE;

		disk_busy(&fd->sc_dk);

		/* allow 2 seconds for operation */
		timeout_add_sec(&fd->fdtimeout_to, 2);
		return 1;				/* will return later */

	case SEEKWAIT:
		timeout_del(&fd->fdtimeout_to);
		fdc->sc_state = SEEKCOMPLETE;
		/* allow 1/50 second for heads to settle */
		timeout_add_msec(&fdc->fdcpseudointr_to, 20);
		return 1;

	case SEEKCOMPLETE:
		disk_unbusy(&fd->sc_dk, 0, 0);	/* no data on seek */

		/* Make sure seek really happened. */
		out_fdc(iot, ioh, NE7CMD_SENSEI);
		if (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 ||
		    cyl != cylin * fd->sc_type->step) {
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 2, "seek failed");
#endif
			fdretry(fd);
			goto loop;
		}
		fd->sc_cylin = cylin;
		goto doio;

	case IOTIMEDOUT:
		isadma_abort(fdc->sc_drq);
	case SEEKTIMEDOUT:
	case RECALTIMEDOUT:
	case RESETTIMEDOUT:
		fdretry(fd);
		goto loop;

	case IOCOMPLETE: /* IO DONE, post-analyze */
		timeout_del(&fd->fdtimeout_to);

		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid),
		    (bp->b_flags & B_READ));

		if (fdcresult(fdc) != 7 || (st0 & 0xf8) != 0) {
			isadma_abort(fdc->sc_drq);
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 7, bp->b_flags & B_READ ?
			    "read failed" : "write failed");
			printf("blkno %lld nblks %d\n",
			    (long long)fd->sc_blkno, fd->sc_nblks);
#endif
			fdretry(fd);
			goto loop;
		}
		read = bp->b_flags & B_READ ? DMAMODE_READ : DMAMODE_WRITE;
		isadma_done(fdc->sc_drq);
		if (fdc->sc_errors) {
			diskerr(bp, "fd", "soft error", LOG_PRINTF,
			    fd->sc_skip / fd_bsize, (struct disklabel *)NULL);
			printf("\n");
			fdc->sc_errors = 0;
		}

		fd->sc_blkno += fd->sc_nblks;
		fd->sc_skip += fd->sc_nbytes;
		fd->sc_bcount -= fd->sc_nbytes;
		bp->b_resid -= fd->sc_nbytes;
		if (!finfo && fd->sc_bcount > 0) {
			cylin = fd->sc_blkno / fd->sc_type->seccyl;
			goto doseek;
		}
		fdfinish(fd, bp);
		goto loop;

	case DORESET:
		/* try a reset, keep motor on */
		fd_set_motor(fdc, 1);
		delay(100);
		fd_set_motor(fdc, 0);
		fdc->sc_state = RESETCOMPLETE;
		timeout_add_msec(&fd->fdtimeout_to, 500);
		return 1;			/* will return later */

	case RESETCOMPLETE:
		timeout_del(&fd->fdtimeout_to);
		/* clear the controller output buffer */
		for (i = 0; i < 4; i++) {
			out_fdc(iot, ioh, NE7CMD_SENSEI);
			(void) fdcresult(fdc);
		}

		/* FALLTHROUGH */
	case DORECAL:
		out_fdc(iot, ioh, NE7CMD_RECAL);	/* recal function */
		out_fdc(iot, ioh, fd->sc_drive);
		fdc->sc_state = RECALWAIT;
		timeout_add_sec(&fd->fdtimeout_to, 5);
		return 1;			/* will return later */

	case RECALWAIT:
		timeout_del(&fd->fdtimeout_to);
		fdc->sc_state = RECALCOMPLETE;
		/* allow 1/30 second for heads to settle */
		timeout_add(&fdc->fdcpseudointr_to, hz / 30);
		return 1;			/* will return later */

	case RECALCOMPLETE:
		out_fdc(iot, ioh, NE7CMD_SENSEI);
		if (fdcresult(fdc) != 2 || (st0 & 0xf8) != 0x20 || cyl != 0) {
#ifdef FD_DEBUG
			fdcstatus(&fd->sc_dev, 2, "recalibrate failed");
#endif
			fdretry(fd);
			goto loop;
		}
		fd->sc_cylin = 0;
		goto doseek;

	case MOTORWAIT:
		if (fd->sc_flags & FD_MOTOR_WAIT)
			return 1;		/* time's not up yet */
		goto doseek;

	default:
		fdcstatus(&fd->sc_dev, 0, "stray interrupt");
		return 1;
	}
#ifdef DIAGNOSTIC
	panic("fdintr: impossible");
#endif
#undef	st0
#undef	cyl
}

void
fdtimeout(void *arg)
{
	struct fd_softc *fd = arg;
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	int s;

	s = splbio();
#ifdef DEBUG
	log(LOG_ERR,"fdtimeout: state %d\n", fdc->sc_state);
#endif
	fdcstatus(&fd->sc_dev, 0, "timeout");

	if (fd->sc_bp != NULL)
		fdc->sc_state++;
	else
		fdc->sc_state = DEVIDLE;

	(void) fdintr(fdc);
	splx(s);
}

void
fdretry(struct fd_softc *fd)
{
	struct fdc_softc *fdc = (void *)fd->sc_dev.dv_parent;
	struct buf *bp = fd->sc_bp;

	if (fd->sc_opts & FDOPT_NORETRY)
	    goto fail;
	switch (fdc->sc_errors) {
	case 0:
		/* try again */
		fdc->sc_state = DOSEEK;
		break;

	case 1: case 2: case 3:
		/* didn't work; try recalibrating */
		fdc->sc_state = DORECAL;
		break;

	case 4:
		/* still no go; reset the bastard */
		fdc->sc_state = DORESET;
		break;

	default:
	fail:
		diskerr(bp, "fd", "hard error", LOG_PRINTF,
		    fd->sc_skip / FD_BSIZE(fd), (struct disklabel *)NULL);
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);

		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		bp->b_resid = bp->b_bcount;
		fdfinish(fd, bp);
	}
	fdc->sc_errors++;
}

int
fdioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct disklabel *lp;
	int error;

	switch (cmd) {
	case MTIOCTOP:
		if (((struct mtop *)addr)->mt_op != MTOFFL)
			return EIO;
		return (0);

	case DIOCRLDINFO:
		lp = malloc(sizeof(*lp), M_TEMP, M_WAITOK);
		fdgetdisklabel(dev, fd, lp, 0);
		bcopy(lp, fd->sc_dk.dk_label, sizeof(*lp));
		free(lp, M_TEMP, sizeof(*lp));
		return 0;

	case DIOCGPDINFO:
		fdgetdisklabel(dev, fd, (struct disklabel *)addr, 1);
		return 0;

	case DIOCGDINFO:
		*(struct disklabel *)addr = *(fd->sc_dk.dk_label);
		return 0;

	case DIOCGPART:
		((struct partinfo *)addr)->disklab = fd->sc_dk.dk_label;
		((struct partinfo *)addr)->part =
		    &fd->sc_dk.dk_label->d_partitions[FDPART(dev)];
		return 0;

	case DIOCWDINFO:
	case DIOCSDINFO:
		if ((flag & FWRITE) == 0)
			return EBADF;

		error = setdisklabel(fd->sc_dk.dk_label,
		    (struct disklabel *)addr, 0);
		if (error == 0) {
			if (cmd == DIOCWDINFO)
				error = writedisklabel(DISKLABELDEV(dev),
				    fdstrategy, fd->sc_dk.dk_label);
		}
		return error;

        case FD_FORM:
                if((flag & FWRITE) == 0)
                        return EBADF;  /* must be opened for writing */
                else if(((struct fd_formb *)addr)->format_version !=
                        FD_FORMAT_VERSION)
                        return EINVAL; /* wrong version of formatting prog */
                else
                        return fdformat(dev, (struct fd_formb *)addr, p);
                break;

        case FD_GTYPE:                  /* get drive type */
                *(struct fd_type *)addr = *fd->sc_type;
		return 0;

        case FD_GOPTS:                  /* get drive options */
                *(int *)addr = fd->sc_opts;
                return 0;
                
        case FD_SOPTS:                  /* set drive options */
                fd->sc_opts = *(int *)addr;
		return 0;

	default:
		return ENOTTY;
	}

#ifdef DIAGNOSTIC
	panic("fdioctl: impossible");
#endif
}

int
fdformat(dev_t dev, struct fd_formb *finfo, struct proc *p)
{
        int rv = 0;
	struct fd_softc *fd = fd_cd.cd_devs[FDUNIT(dev)];
	struct fd_type *type = fd->sc_type;
        struct buf *bp;
	int fd_bsize = FD_BSIZE(fd);

        /* set up a buffer header for fdstrategy() */
        bp = malloc(sizeof(*bp), M_TEMP, M_NOWAIT | M_ZERO);
        if (bp == NULL)
                return ENOBUFS;

        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT | B_RAW;
        bp->b_proc = p;
        bp->b_dev = dev;

        /*
         * calculate a fake blkno, so fdstrategy() would initiate a
         * seek to the requested cylinder
         */
        bp->b_blkno = (finfo->cyl * (type->sectrac * type->heads)
                + finfo->head * type->sectrac) * fd_bsize / DEV_BSIZE;

        bp->b_bcount = sizeof(struct fd_idfield_data) * finfo->fd_formb_nsecs;
        bp->b_data = (caddr_t)finfo;
        
#ifdef DEBUG
	printf("fdformat: blkno %llx count %lx\n", bp->b_blkno, bp->b_bcount);
#endif

        /* now do the format */
        fdstrategy(bp);

        /* ...and wait for it to complete */
	rv = biowait(bp);
        free(bp, M_TEMP, sizeof(*bp));
        return (rv);
}
@


1.102
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.101 2014/09/14 14:17:25 jsg Exp $	*/
d1015 1
a1015 1
		free(lp, M_TEMP, 0);
d1114 1
a1114 1
        free(bp, M_TEMP, 0);
@


1.101
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.100 2014/07/12 18:48:17 tedu Exp $	*/
a64 1
#include <machine/conf.h>
@


1.100
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.99 2014/06/15 11:43:24 sf Exp $	*/
a56 1
#include <sys/proc.h>
@


1.99
log
@Fix a few format string bugs with -DDEBUG
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.98 2013/12/28 03:39:16 deraadt Exp $	*/
d1017 1
a1017 1
		free(lp, M_TEMP);
d1116 1
a1116 1
        free(bp, M_TEMP);
@


1.98
log
@Attempt to approximate what should happen on a suspend/resume cycle.
If the driver was doing some IO, we remove the timeouts, and force the
fdc state machine into IOTIMEDOUT state with the final timeout count
before a clean retry.  In theory upon resume it should freak out quietly,
and try the operation again.
Noone has stepped forward to test this yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.98 2013/12/09 19:49:22 deraadt Exp $	*/
d1108 1
a1108 1
	printf("fdformat: blkno %x count %x\n", bp->b_blkno, bp->b_bcount);
@


1.97
log
@remove the #define b_cylinder b_resid from bufs. i hated the
overloading of that thing.

the only hardware that seems to care about cylinders in our tree
are floppy drives, and the drivers for those calculate their own
cylinders from logical block addresses and ignore whatever the rest
of the kernel thought b_cylinders should be.

most of this diff is moving the floppy drivers to using b_resid as
a resid and using that as part of the calculation for real cylinder
values.

the rest of the diff is getting rid of the useless assignments to
b_cylinder that dont get used by anything (now that disksort is
gone).

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.96 2013/11/01 17:36:19 krw Exp $	*/
d315 2
d320 9
@


1.96
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.95 2013/11/01 11:40:20 dlg Exp $	*/
d412 1
a412 1
 	bp->b_cylinder = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;
d415 3
a417 3
	printf("fdstrategy: b_blkno %lld b_bcount %d blkno %lld cylin %d "
	    "sz %d\n", (long long)bp->b_blkno, bp->b_bcount,
	    (long long)fd->sc_blkno, bp->b_cylinder, sz);
a471 1
	bp->b_resid = fd->sc_bcount;
d654 1
a654 1
	int read, head, sec, i, nblks;
d678 3
d713 1
a713 1
		if (fd->sc_cylin == bp->b_cylinder)
d722 1
a722 1
		out_fdc(iot, ioh, bp->b_cylinder * fd->sc_type->step);
d810 1
a810 1
		    cyl != bp->b_cylinder * fd->sc_type->step) {
d817 1
a817 1
		fd->sc_cylin = bp->b_cylinder;
d853 1
d857 1
d859 1
a859 1
			bp->b_cylinder = fd->sc_blkno / fd->sc_type->seccyl;
d983 1
@


1.95
log
@move fd(4) from directly using disksort to using bufqs.

tested by me and rapha@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.94 2013/06/11 16:42:15 deraadt Exp $	*/
d415 3
a417 2
	printf("fdstrategy: b_blkno %lld b_bcount %d blkno %lld cylin %d sz %d\n",
	    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylinder, sz);
d838 1
a838 1
			    fd->sc_blkno, fd->sc_nblks);
@


1.94
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.93 2013/05/30 16:15:02 deraadt Exp $	*/
d122 2
a123 1
	struct buf sc_q;	/* head of buf chain */
d303 1
d419 3
a423 1
	disksort(&fd->sc_q, bp);
d425 1
a425 1
	if (!fd->sc_q.b_active)
d456 1
a456 1
	fd->sc_q.b_active = 1;
d471 4
d484 1
a484 1
		if (bp->b_actf) {
d487 1
a487 2
		} else
			fd->sc_q.b_active = 0;
a488 3
	bp->b_resid = fd->sc_bcount;
	fd->sc_skip = 0;
	fd->sc_q.b_actf = bp->b_actf;
d668 1
a668 1
	bp = fd->sc_q.b_actf;
a671 1
		fd->sc_q.b_active = 0;
d933 1
a933 1
	if (fd->sc_q.b_actf)
d946 1
a946 1
	struct buf *bp = fd->sc_q.b_actf;
@


1.93
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.92 2011/07/04 05:41:48 matthew Exp $	*/
d106 1
a106 1
	daddr64_t	sc_blkno;	/* starting block number */
d623 1
a623 1
daddr64_t
d631 1
a631 1
fddump(dev_t dev, daddr64_t blkno, caddr_t va, size_t size)
@


1.92
log
@Convert to ANSI.

ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.91 2011/06/05 18:40:33 matthew Exp $	*/
a119 2
	void *sc_sdhook;	/* saved shutdown hook for drive. */

d131 1
d134 1
a134 1
	sizeof(struct fd_softc), fdprobe, fdattach
a303 3
	/* Needed to power off if the motor is on when we halt. */
	fd->sc_sdhook = shutdownhook_establish(fd_motor_off, fd);

d308 14
@


1.91
log
@Drop kernel support for the useless DIOCWLABEL ioctl and prune a lot
of silly flag twiddling code in various disk drivers.

ok deraadt@@, miod@@

N.B., users will need a -current disklabel(8) to be able to write new
disklabels to disk now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.90 2010/11/18 21:13:19 miod Exp $	*/
d187 1
a187 3
fdprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d247 1
a247 3
fdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d319 1
a319 3
fd_nvtotype(fdc, nvraminfo, drive)
	char *fdc;
	int nvraminfo, drive;
d353 1
a353 3
fd_dev_to_type(fd, dev)
	struct fd_softc *fd;
	dev_t dev;
d363 1
a363 2
fdstrategy(bp)
	register struct buf *bp;	/* IO operation to perform */
d436 1
a436 2
fdstart(fd)
	struct fd_softc *fd;
d451 1
a451 3
fdfinish(fd, bp)
	struct fd_softc *fd;
	struct buf *bp;
d483 1
a483 4
fdread(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
a484 1

d489 1
a489 4
fdwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
a490 1

d495 1
a495 3
fd_set_motor(fdc, reset)
	struct fdc_softc *fdc;
	int reset;
d515 1
a515 2
fd_motor_off(arg)
	void *arg;
d527 1
a527 2
fd_motor_on(arg)
	void *arg;
d542 1
a542 5
fdopen(dev, flags, fmt, p)
	dev_t dev;
	int flags;
	int fmt;
	struct proc *p;
d590 1
a590 5
fdclose(dev, flags, fmt, p)
	dev_t dev;
	int flags;
	int fmt;
	struct proc *p;
d614 1
a614 2
fdsize(dev)
	dev_t dev;
a615 1

d621 1
a621 5
fddump(dev, blkno, va, size)
	dev_t dev;
	daddr64_t blkno;
	caddr_t va;
	size_t size;
a622 1

d631 1
a631 2
fdintr(fdc)
	struct fdc_softc *fdc;
d908 1
a908 2
fdtimeout(arg)
	void *arg;
d930 1
a930 2
fdretry(fd)
	struct fd_softc *fd;
d971 1
a971 6
fdioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d1050 1
a1050 4
fdformat(dev, finfo, p)
        dev_t dev;
        struct fd_formb *finfo;
        struct proc *p;
@


1.90
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.89 2010/09/23 13:11:37 jsing Exp $	*/
a1048 6
		return 0;

	case DIOCWLABEL:
		if ((flag & FWRITE) == 0)
			return EBADF;
		/* XXX do something */
@


1.89
log
@Introduce a DKF_NOLABELREAD flag, which is used by a device to prevent
automatic reading of disklabel on attach.

ok deraadt@@ miod@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.87 2010/09/08 14:47:12 jsing Exp $	*/
a51 1
#include <sys/dkstat.h>
@


1.88
log
@All users of physio(9) now pass NULL as the buf pointer argument, so
no point in keeping it around.

"i like this" thib@@ (a while back); ok krw@@ and oga@@; reminder to
update the man page and tweaks jmc@@
@
text
@d306 1
@


1.87
log
@Store a struct device pointer within struct disk and populate this when
disk_attach() is called by the device driver. We will be building on
this shortly.

ok deraadt@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.85 2010/05/18 04:41:14 dlg Exp $	*/
d501 1
a501 1
	return (physio(fdstrategy, NULL, dev, B_READ, minphys, uio));
d511 1
a511 1
	return (physio(fdstrategy, NULL, dev, B_WRITE, minphys, uio));
@


1.86
log
@Garbage collect struct dkdriver.

ok miod@@; "please go ahead" jsing@@
@
text
@d307 1
a307 1
	disk_attach(&fd->sc_dk);
@


1.85
log
@dont let sys/ioctl.h imply that you get the ioctls in dkio.h. this
gets rid of #include <sys/dkio.h> in sys/ioctl.h and adds #include
<sys/dkio.h> to the places that actually want and use the disk
ioctls.

this became an issue when krw@@'s X build failed when he was testing
a change to dkio.h.
tested by krw@@
help from and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.84 2010/04/23 15:25:21 jsing Exp $	*/
a148 2
struct dkdriver fddkdriver = { fdstrategy };

a306 1
	fd->sc_dk.dk_driver = &fddkdriver;
@


1.84
log
@Recycle unused disklabel fields in order to create a disklabel unique
identifier, allowing the disk to be identified without relying on the
device name.

ok deraadt@@ krw@@ beck@@ marco@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.82 2009/09/06 20:32:01 krw Exp $	*/
d63 1
@


1.83
log
@Add DIOCSDINFO support to the three fd drivers. No change to existing
behaviour.
@
text
@a171 1
	lp->d_rpm = 300;	/* XXX like it matters... */
a174 1
	lp->d_interleave = 1;
@


1.82
log
@Don't pass uninitialized stack memory to setdisklabel() as the 'old'
label. Use the existing label, since we now check and reuse some
values in it. And that's what all other drivers do. Bonus: we don't
need that label on the stack anymore.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.81 2009/08/24 08:51:18 jasper Exp $	*/
d1062 1
d1066 7
a1072 6
		error = setdisklabel(fd->sc_dk.dk_label, (struct disklabel *)addr, 0);
		if (error)
			return error;

		error = writedisklabel(DISKLABELDEV(dev), fdstrategy,
		    fd->sc_dk.dk_label);
@


1.81
log
@- fix format strings for values that are daddr64_t

ok otto@@, agreed by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.80 2009/08/24 08:31:50 jasper Exp $	*/
d1025 1
a1025 1
	struct disklabel dl, *lp = &dl;
d1065 1
a1065 1
		error = setdisklabel(lp, (struct disklabel *)addr, 0);
d1069 2
a1070 1
		error = writedisklabel(DISKLABELDEV(dev), fdstrategy, lp);
@


1.80
log
@- remove double \n in panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.79 2009/08/23 15:02:21 jasper Exp $	*/
d416 1
a416 1
	printf("fdstrategy: b_blkno %d b_bcount %d blkno %d cylin %d sz %d\n",
d867 1
a867 1
			printf("blkno %d nblks %d\n",
@


1.79
log
@- turn a printf(), which predated a panic()-function that could take printf-like arguments,
into panic() and remove call to Debugger()

hint and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.78 2009/08/13 15:23:12 deraadt Exp $	*/
d779 1
a779 1
			 panic("fdintr: block %d != blkno %llu\n", block, fd->sc_blkno);
@


1.78
log
@Replace the error strings that were being passed around with much simpler
errnos.  Note that the error strings are being ignored, since we long ago
decided to not spam the console, and there is no other nice way to use the
errors (without changing the ioctls to pass it back)
The errno is now useful, since we can pass b_error from failing IO up, and
the drive can decide how to use that
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.77 2009/08/05 13:45:29 blambert Exp $	*/
d779 1
a779 4
			 printf("fdintr: block %d != blkno %llu\n", block, fd->sc_blkno);
#ifdef DDB
			 Debugger();
#endif
@


1.77
log
@timeout_add -> timeout_add_msec

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.76 2009/06/02 12:32:08 deraadt Exp $	*/
d142 1
a142 1
void fdgetdisklabel(dev_t, struct fd_softc *, struct disklabel *, int);
d159 1
a159 1
void
a162 2
	char *errstring;

d187 1
a187 4
	errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, spoofonly);
	if (errstring) {
		/*printf("%s: %s\n", fd->sc_dev.dv_xname, errstring);*/
	}
@


1.76
log
@Fix some minor format string problems found in a maze of false positives
provided by Parfait
ok oga
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.75 2008/10/15 19:12:18 blambert Exp $	*/
d737 1
a737 1
			timeout_add(&fd->fd_motor_on_to, hz / 4);
d837 1
a837 1
		timeout_add(&fdc->fdcpseudointr_to, hz / 50);
d905 1
a905 1
		timeout_add(&fd->fdtimeout_to, hz / 2);
@


1.75
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.74 2008/06/12 06:58:39 deraadt Exp $	*/
d784 1
a784 1
			 printf("fdintr: block %d != blkno %d\n", block, fd->sc_blkno);
@


1.74
log
@Bring biomem diff back into the tree after the nfs_bio.c fix went in.
ok thib beck art
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.72 2008/06/10 20:50:23 beck Exp $	*/
d499 1
a499 1
	timeout_add(&fd->fd_motor_off_to, 5 * hz);
d763 1
a763 1
		timeout_add(&fd->fdtimeout_to, 4 * hz);
d830 1
a830 1
		timeout_add(&fd->fdtimeout_to, 2 * hz);
d921 1
a921 1
		timeout_add(&fd->fdtimeout_to, 5 * hz);
@


1.73
log
@back out biomem diff since it is not right yet.  Doing very large
file copies to nfsv2 causes the system to eventually peg the console.
On the console ^T indicates that the load is increasing rapidly, ddb
indicates many calls to getbuf, there is some very slow nfs traffic
making none (or extremely slow) progress.  Eventually some machines
seize up entirely.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.71 2008/03/22 22:54:42 krw Exp $	*/
d1128 1
a1128 1
        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;
@


1.72
log
@Fix buffer cache pending read statistics by ensuring we can identify
biowait() reads that do *not* come from the buffer cache - we use the
B_RAW flag to identify these at art's suggestion - since it makes sense
and the flag was not being used. this just flags all these buffers with
B_RAW - biodone already ignores returned buffers marked B_RAW.
ok art@@
@
text
@d1128 1
a1128 1
        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT | B_RAW;
@


1.71
log
@Add support for DIOCRLDINFO, DIOCGPDINFO, DIOCGPART to the fd
driver(s). Adapted from sd driver.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.70 2008/03/21 20:30:02 krw Exp $	*/
d1128 1
a1128 1
        bp->b_flags = B_BUSY | B_PHYS | B_FORMAT;
@


1.70
log
@Fix typo/pasto in commented out debug printf(). sc_dv -> sc_dev.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.69 2008/03/20 00:59:37 krw Exp $	*/
d1041 12
d1054 7
a1060 2
		fdgetdisklabel(dev, fd, lp, 0);
		*(struct disklabel *)addr = *lp;
@


1.69
log
@Bring isa/fd.c into line with sparc/sparc64 fd code and prepare all
for the addition of missing disklabel related ioctl's.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.68 2007/10/01 15:34:48 krw Exp $	*/
d191 1
a191 1
		/*printf("%s: %s\n", fd->sc_dv.dv_xname, errstring);*/
@


1.68
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.67 2007/06/20 18:15:46 deraadt Exp $	*/
d61 1
d142 1
a142 1
void fdgetdisklabel(struct fd_softc *);
d159 36
d575 1
a575 1
fdopen(dev, flags, mode, p)
d578 1
a578 1
	int mode;
d581 1
a581 1
 	int unit;
d603 20
d627 1
a627 1
fdclose(dev, flags, mode, p)
d630 1
a630 1
	int mode;
d634 1
d638 14
a651 1
	return 0;
a1033 1
	char *errstring;
d1042 1
a1042 25
		bzero(lp, sizeof(*lp));

		lp->d_secsize = FD_BSIZE(fd);
		lp->d_secpercyl = fd->sc_type->seccyl;
		lp->d_ntracks = fd->sc_type->heads;
		lp->d_nsectors = fd->sc_type->sectrac;
		lp->d_ncylinders = fd->sc_type->tracks;

		strncpy(lp->d_typename, "floppy disk", sizeof lp->d_typename);
		lp->d_type = DTYPE_FLOPPY;
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
		DL_SETDSIZE(lp, fd->sc_type->size);
		lp->d_rpm = 300;
		lp->d_interleave = 1;
		lp->d_version = 1;

		lp->d_magic = DISKMAGIC;
		lp->d_magic2 = DISKMAGIC;
		lp->d_checksum = dkcksum(lp);

		errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp, 0);
		if (errstring) {
			/*printf("%s: %s\n", fd->sc_dev.dv_xname, errstring);*/
		}

@


1.67
log
@b_cylinder does not need to be set on the callpath down into drivers.
cpu_disklabel can go away, since nothing anymore needs to use it; ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.66 2007/06/08 05:27:58 deraadt Exp $	*/
d1061 1
a1061 1
        bp = (struct buf *)malloc(sizeof(struct buf), M_TEMP, M_NOWAIT);
a1064 1
        bzero((void *)bp, sizeof(struct buf));
@


1.66
log
@all drivers should spoof version 1 labels
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.65 2007/06/06 17:15:13 deraadt Exp $	*/
a962 1
	struct cpu_disklabel cdl;
a972 1
		bzero(&cdl, sizeof(struct cpu_disklabel));
d992 1
a992 2
		errstring = readdisklabel(DISKLABELDEV(dev), fdstrategy, lp,
		    &cdl, 0);
d1010 1
a1010 1
		error = setdisklabel(lp, (struct disklabel *)addr, 0, NULL);
d1014 1
a1014 1
		error = writedisklabel(DISKLABELDEV(dev), fdstrategy, lp, NULL);
@


1.65
log
@now that all partition size/offsets are potentially 64-bit, change the
type of all variables to daddr64_t.  this includes the APIs for XXsize()
and XXdump(), all range checks inside bio drivers, internal variables
for disklabel handling, and even uvm's swap offsets.  re-read numerous
times by otto, miod, krw, thib to look for errors
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.64 2007/06/05 00:38:21 deraadt Exp $	*/
d988 1
@


1.64
log
@use six new macros to access & store the 48-bit disklabel fields related
to size.  tested on almost all machines, double checked by miod and krw
next comes the type handling surrounding these values
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.63 2007/06/01 00:07:48 krw Exp $	*/
d105 1
a105 1
	daddr_t	sc_blkno;	/* starting block number */
d583 1
a583 1
int
d595 1
a595 1
	daddr_t blkno;
@


1.63
log
@Don't initialize d_partitions[RAW_DISK] just before calling
readdisklabel(), since all readdisklabel()'s do that already.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.62 2007/05/08 20:59:39 deraadt Exp $	*/
d985 1
a985 1
		lp->d_secperunit = fd->sc_type->size;
@


1.62
log
@2nd one found:  If you really wish to make a function __inline (which will
be called once), please also make it static so that the compiler does not
generate a 2nd one to export to outside callers!  that is a stupid waste
of space.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.61 2007/04/27 22:20:01 krw Exp $	*/
a987 5

		lp->d_partitions[RAW_PART].p_offset = 0;
		lp->d_partitions[RAW_PART].p_size = lp->d_secperunit;
		lp->d_partitions[RAW_PART].p_fstype = FS_UNUSED;
		lp->d_npartitions = RAW_PART + 1;
@


1.61
log
@Even floppies should use DISKLABELDEV() on the dev_t parameter to
readdisklabel/writedisklabel.

ok deraadt@@ weingart@@ conceptual ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.60 2007/02/15 00:53:26 krw Exp $	*/
d154 1
a154 1
__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
d330 1
a330 1
__inline struct fd_type *
@


1.60
log
@Don't print the error strings returned by readdisklabel().  If you
need the debug info uncomment the printf's you need. Crude but
effective way to suppress 'no disklabel' errors that pop up at the
most innconvenient times to frighten users. More elegant method,
DPRINTF-like constructs or something, later.

"Yay!" marco@@ ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.59 2007/02/14 00:53:48 jsg Exp $	*/
d998 2
a999 1
		errstring = readdisklabel(dev, fdstrategy, lp, &cdl, 0);
d1021 1
a1021 1
		error = writedisklabel(dev, fdstrategy, lp, NULL);
@


1.59
log
@Consistently spell FALLTHROUGH to appease lint.
ok kettenis@@ cloder@@ tom@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.58 2006/12/21 02:28:47 krw Exp $	*/
d1000 1
a1000 1
			/*printf("%s: %s\n", fd->sc_dev.dv_xname, errstring); */
@


1.58
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.57 2006/11/29 12:24:17 miod Exp $	*/
d672 1
a672 1
		/* fall through */
d845 1
a845 1
		/* fall through */
@


1.57
log
@Kernel stack can be swapped. This means that stuff that's on the stack
should never be referenced outside the context of the process to which
this stack belongs unless we do the PHOLD/PRELE dance. Loads of code
doesn't follow the rules here. Instead of trying to track down all
offenders and fix this hairy situation, it makes much more sense
to not swap kernel stacks.

From art@@, tested by many some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.56 2006/09/26 23:33:04 krw Exp $	*/
d109 2
a110 2
	int sc_nblks;		/* number of blocks currently tranferring */
	int sc_nbytes;		/* number of bytes currently tranferring */
@


1.56
log
@Zap D_REMOVABLE flag from disklabel. If you didn't already know that
floppies and cd's were removable, displaying that fact in disklabel
output was unlikely to help. And the display in disklabel was the only
use of D_REMOVABLE in the tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.55 2006/08/13 16:24:12 krw Exp $	*/
a1070 1
	PHOLD(p);
a1094 1
	PRELE(p);
@


1.55
log
@RAW_PART p_size on floppies and mcd's should be in sectors.

Only 'Japanese 1.2MB' floppies have sectors that are not 512 bytes, according
to isa/fd.c's fd_types[].

SCSI/ATAPI cd's already use sectors, and mcd cd's should be no different.

So there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.54 2006/08/13 03:36:24 krw Exp $	*/
a987 1
		lp->d_flags = D_REMOVABLE;
@


1.54
log
@Define and use FD_BSIZE, similar to FD_BSIZE from sparc and sparc64
fd. Eliminate unused variable and FDC_BSIZE which was only used to
set value of the unused variable.

No change to object file.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.53 2006/03/15 20:20:41 miod Exp $	*/
d991 1
a991 2
		lp->d_partitions[RAW_PART].p_size =
		    lp->d_secperunit * (lp->d_secsize / DEV_BSIZE);
@


1.53
log
@Nuke dk_establish(), no longer used.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.52 2006/01/22 00:40:02 miod Exp $	*/
d349 1
a349 1
	int fd_bsize = 128 << fd->sc_type->secsize;
d621 1
a621 1
	int fd_bsize, bf;
d630 1
a630 2
	fd_bsize = 128 << fd->sc_type->secsize;
	bf = fd_bsize / FDC_BSIZE;
d939 1
a939 2
		    fd->sc_skip / (128 << fd->sc_type->secsize),
		    (struct disklabel *)NULL);
d976 1
a976 1
		lp->d_secsize = 128 << fd->sc_type->secsize;
d1066 1
a1066 1
	int fd_bsize = 128 << fd->sc_type->secsize;
@


1.52
log
@b_cylin -> b_cylinder; no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.51 2005/09/19 01:28:04 deraadt Exp $	*/
a280 1
	dk_establish(&fd->sc_dk, &fd->sc_dev);
@


1.51
log
@floppy support; form@@openbsd.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.50 2005/03/16 19:58:40 miod Exp $	*/
a81 2
#define b_cylin b_resid

d382 1
a382 1
 	bp->b_cylin = bp->b_blkno / (fd_bsize / DEV_BSIZE) / fd->sc_type->seccyl;
d386 1
a386 1
	    bp->b_blkno, bp->b_bcount, fd->sc_blkno, bp->b_cylin, sz);
d677 1
a677 1
		if (fd->sc_cylin == bp->b_cylin)
d686 1
a686 1
		out_fdc(iot, ioh, bp->b_cylin * fd->sc_type->step);
d777 1
a777 1
		    cyl != bp->b_cylin * fd->sc_type->step) {
d784 1
a784 1
		fd->sc_cylin = bp->b_cylin;
d824 1
a824 1
			bp->b_cylin = fd->sc_blkno / fd->sc_type->seccyl;
@


1.50
log
@Use biowait() instead of rolling our own.

tested krw@@ moritz@@, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.49 2004/12/26 21:22:13 miod Exp $	*/
d73 1
a73 1
#if defined(i386)
@


1.49
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.48 2004/02/15 02:45:47 tedu Exp $	*/
d1067 1
a1067 1
        int rv = 0, s;
d1075 1
a1075 1
        if(bp == 0)
d1077 2
d1102 2
a1103 18
        s = splbio();
        while(!(bp->b_flags & B_DONE))
        {
                rv = tsleep((caddr_t)bp, PRIBIO, "fdform", 0);
                if(rv == EWOULDBLOCK)
		    /*break*/;
        }
        splx(s);
        
        if(rv == EWOULDBLOCK) {
                /* timed out */
                rv = EIO;
		/* XXX what to do to the buf? it will eventually fall
		   out as finished, but ... ?*/
		/*biodone(bp);*/
	}
        if(bp->b_flags & B_ERROR)
                rv = bp->b_error;
d1105 1
a1105 1
        return rv;
@


1.48
log
@new arg to disk_unbusy, to record separate read/write statistics.
looked at by various, testing henning@@ mcbride@@ dan weeks
mostly from netbsd via Pedro Martelletto <pbastos@@rdc.puc-rio.br>
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.47 2003/06/02 23:28:02 millert Exp $	*/
d424 1
a424 1
	int active = (fdc->sc_link.fdlink.sc_drives.tqh_first != NULL);
d450 1
a450 1
	if (fd->sc_drivechain.tqe_next && ++fd->sc_ops >= 8) {
d498 1
a498 1
	if ((fd = fdc->sc_link.fdlink.sc_drives.tqh_first) != NULL)
d534 1
a534 1
	if ((fdc->sc_link.fdlink.sc_drives.tqh_first == fd)
d628 1
a628 1
	fd = fdc->sc_link.fdlink.sc_drives.tqh_first;
@


1.47
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.46 2003/04/06 15:28:25 krw Exp $	*/
d774 1
a774 1
		disk_unbusy(&fd->sc_dk, 0);	/* no data on seek */
d800 2
a801 1
		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));
@


1.46
log
@Some easy strcpy elimination.

a) strcpy -> strncpy for copies into disklabel fields d_packname and
d_typename.

b) '16' -> 'sizeof d_packname' or 'sizeof d_typename' in existing
strncpy's.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.45 2002/05/24 13:31:10 art Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.45
log
@More splbio around biodone protection.
In these drivers I'm probably using more paranoia than necessary.
If you really need to squeeze out the last drop of performance from the
fd driver, call me.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.44 2002/03/14 01:26:56 millert Exp $	*/
d990 1
a990 1
		strncpy(lp->d_typename, "floppy disk", 16);
d992 1
a992 1
		strncpy(lp->d_packname, "fictitious", 16);
@


1.44
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.43 2001/10/26 01:28:06 nate Exp $	*/
d418 1
d420 1
d445 2
@


1.43
log
@First cut at a port of isadma and floppy driver.  ok art@@
From NetBSD via jay@@rootaction.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.42 2001/03/06 13:55:02 ho Exp $	*/
d136 2
a137 2
int fdprobe __P((struct device *, void *, void *));
void fdattach __P((struct device *, struct device *, void *));
d147 5
a151 5
void fdgetdisklabel __P((struct fd_softc *));
int fd_get_parms __P((struct fd_softc *));
void fdstrategy __P((struct buf *));
void fdstart __P((struct fd_softc *));
int fdintr __P((struct fdc_softc *));
d155 8
a162 8
void fd_set_motor __P((struct fdc_softc *fdc, int reset));
void fd_motor_off __P((void *arg));
void fd_motor_on __P((void *arg));
void fdfinish __P((struct fd_softc *fd, struct buf *bp));
int fdformat __P((dev_t, struct fd_formb *, struct proc *));
__inline struct fd_type *fd_dev_to_type __P((struct fd_softc *, dev_t));
void fdretry __P((struct fd_softc *));
void fdtimeout __P((void *));
@


1.43.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.43 2001/10/26 01:28:06 nate Exp $	*/
d136 2
a137 2
int fdprobe(struct device *, void *, void *);
void fdattach(struct device *, struct device *, void *);
d147 5
a151 5
void fdgetdisklabel(struct fd_softc *);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdintr(struct fdc_softc *);
d155 8
a162 8
void fd_set_motor(struct fdc_softc *fdc, int reset);
void fd_motor_off(void *arg);
void fd_motor_on(void *arg);
void fdfinish(struct fd_softc *fd, struct buf *bp);
int fdformat(dev_t, struct fd_formb *, struct proc *);
__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
void fdretry(struct fd_softc *);
void fdtimeout(void *);
a417 1
	s = splbio();
a418 1
	splx(s);
a442 2

	splassert(IPL_BIO);
@


1.43.2.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d990 1
a990 1
		strncpy(lp->d_typename, "floppy disk", sizeof lp->d_typename);
d992 1
a992 1
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.42
log
@Convert to new timeout API. mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.41 1999/10/07 18:47:19 downsj Exp $	*/
d258 7
d306 6
d334 1
@


1.41
log
@Add a delay() before turning the motor off; some controllers don't see it
otherwise.  Also move the motor off up so that it always gets performed,
even if the probe is overridden via config flags.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.40 1999/01/07 06:14:48 niklas Exp $	*/
d65 1
d130 3
d283 5
d384 1
a384 1
	untimeout(fd_motor_off, fd); /* a good idea */
d451 1
a451 1
	timeout(fd_motor_off, fd, 5 * hz);
d639 1
a639 1
		untimeout(fd_motor_off, fd);
d649 1
a649 1
				untimeout(fd_motor_off, ofd);
d656 1
a656 1
			timeout(fd_motor_on, fd, hz / 4);
d682 1
a682 1
		timeout(fdtimeout, fd, 4 * hz);
d749 1
a749 1
		timeout(fdtimeout, fd, 2 * hz);
d753 1
a753 1
		untimeout(fdtimeout, fd);
d756 1
a756 1
		timeout(fdcpseudointr, fdc, hz / 50);
d784 1
a784 1
		untimeout(fdtimeout, fd);
d823 1
a823 1
		timeout(fdtimeout, fd, hz / 2);
d827 1
a827 1
		untimeout(fdtimeout, fd);
d839 1
a839 1
		timeout(fdtimeout, fd, 5 * hz);
d843 1
a843 1
		untimeout(fdtimeout, fd);
d846 1
a846 1
		timeout(fdcpseudointr, fdc, hz / 30);
@


1.41.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.42 2001/03/06 13:55:02 ho Exp $	*/
a64 1
#include <sys/timeout.h>
a128 3
	struct timeout fd_motor_on_to;
	struct timeout fd_motor_off_to;
	struct timeout fdtimeout_to;
a278 5

	/* Setup timeout structures */
	timeout_set(&fd->fd_motor_on_to, fd_motor_on, fd);
	timeout_set(&fd->fd_motor_off_to, fd_motor_off, fd);
	timeout_set(&fd->fdtimeout_to, fdtimeout, fd);
d375 1
a375 1
	timeout_del(&fd->fd_motor_off_to); /* a good idea */
d442 1
a442 1
	timeout_add(&fd->fd_motor_off_to, 5 * hz);
d630 1
a630 1
		timeout_del(&fd->fd_motor_off_to);
d640 1
a640 1
				timeout_del(&ofd->fd_motor_off_to);
d647 1
a647 1
			timeout_add(&fd->fd_motor_on_to, hz / 4);
d673 1
a673 1
		timeout_add(&fd->fdtimeout_to, 4 * hz);
d740 1
a740 1
		timeout_add(&fd->fdtimeout_to, 2 * hz);
d744 1
a744 1
		timeout_del(&fd->fdtimeout_to);
d747 1
a747 1
		timeout_add(&fdc->fdcpseudointr_to, hz / 50);
d775 1
a775 1
		timeout_del(&fd->fdtimeout_to);
d814 1
a814 1
		timeout_add(&fd->fdtimeout_to, hz / 2);
d818 1
a818 1
		timeout_del(&fd->fdtimeout_to);
d830 1
a830 1
		timeout_add(&fd->fdtimeout_to, 5 * hz);
d834 1
a834 1
		timeout_del(&fd->fdtimeout_to);
d837 1
a837 1
		timeout_add(&fdc->fdcpseudointr_to, hz / 30);
@


1.41.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.41.4.1 2001/05/14 22:24:32 niklas Exp $	*/
a257 7
#ifdef __alpha__
		default:
			/* 1.44MB, how to detect others?
			 * idea from NetBSD -- jay@@rootaction.net
                         */
			type = &fd_types[0];
#endif
a298 6
#ifdef __alpha__
	/* Alpha:  assume 1.44MB, idea from NetBSD sys/dev/isa/fd.c
	 * -- jay@@rootaction.net
	 */
	return &fd_types[0]; /* 1.44MB */
#else
a320 1
#endif
@


1.41.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d136 2
a137 2
int fdprobe(struct device *, void *, void *);
void fdattach(struct device *, struct device *, void *);
d147 5
a151 5
void fdgetdisklabel(struct fd_softc *);
int fd_get_parms(struct fd_softc *);
void fdstrategy(struct buf *);
void fdstart(struct fd_softc *);
int fdintr(struct fdc_softc *);
d155 8
a162 8
void fd_set_motor(struct fdc_softc *fdc, int reset);
void fd_motor_off(void *arg);
void fd_motor_on(void *arg);
void fdfinish(struct fd_softc *fd, struct buf *bp);
int fdformat(dev_t, struct fd_formb *, struct proc *);
__inline struct fd_type *fd_dev_to_type(struct fd_softc *, dev_t);
void fdretry(struct fd_softc *);
void fdtimeout(void *);
@


1.41.4.4
log
@Sync the SMP branch with 3.3
@
text
@a417 1
	s = splbio();
a418 1
	splx(s);
a442 2

	splassert(IPL_BIO);
@


1.41.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.41.4.4 2003/03/28 00:38:15 niklas Exp $	*/
d990 1
a990 1
		strncpy(lp->d_typename, "floppy disk", sizeof lp->d_typename);
d992 1
a992 1
		strncpy(lp->d_packname, "fictitious", sizeof lp->d_packname);
@


1.41.4.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.41.4.5 2003/05/13 19:35:03 ho Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.41.4.7
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d774 1
a774 1
		disk_unbusy(&fd->sc_dk, 0, 0);	/* no data on seek */
d800 1
a800 2
		disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid),
		    (bp->b_flags & B_READ));
@


1.40
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.39 1998/10/03 21:19:00 millert Exp $	*/
d207 5
a214 2
	/* turn off motor */
	bus_space_write_1(iot, ioh, fdout, FDO_FRST);
@


1.39
log
@Add a "spoofonly" argument to readdisklabel() which will be used to
implement an ioctl to get a spoofed label even for disks that have
a label on them.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.38 1998/08/08 23:01:13 downsj Exp $	*/
a697 4
#ifdef NEWCONFIG
		at_dma(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
#else
a699 1
#endif
a763 3
#ifdef NEWCONFIG
		at_dma_abort(fdc->sc_drq);
#else
a764 1
#endif
a776 3
#ifdef NEWCONFIG
			at_dma_abort(fdc->sc_drq);
#else
a777 1
#endif
a786 3
#ifdef NEWCONFIG
		at_dma_terminate(fdc->sc_drq);
#else
a788 1
#endif
@


1.38
log
@Split ioh allocations so that the devices no longer overlap.
Also disable the diag return check in wdc.c for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.37 1998/01/18 18:48:41 niklas Exp $	*/
d995 1
a995 1
		errstring = readdisklabel(dev, fdstrategy, lp, &cdl);
@


1.37
log
@move to current OpenBSD isadma API
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.36 1997/11/12 07:33:10 deraadt Exp $	*/
d594 1
d705 1
a705 1
		bus_space_write_1(iot, ioh, fdctl, type->rate);
@


1.36
log
@fix argh disklabel problem, pr#346
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.35 1997/10/18 10:37:09 deraadt Exp $	*/
d701 2
a702 2
		isa_dmastart(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
d771 1
a771 1
		isa_dmaabort(fdc->sc_drq);
d788 1
a788 1
			isa_dmaabort(fdc->sc_drq);
d803 1
a803 2
		isa_dmadone(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
@


1.35
log
@avoid "no disklabel" error messages
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.34 1997/04/07 22:48:08 rees Exp $	*/
a997 1
			return 0;
@


1.34
log
@cf_flags & 0x20 forces device to be found even if it won't probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.33 1996/12/05 17:40:01 deraadt Exp $	*/
d996 4
a999 2
		if (errstring)
			printf("%s: %s\n", fd->sc_dev.dv_xname, errstring);
@


1.33
log
@let us get this right finally...
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.32 1996/12/05 17:22:40 deraadt Exp $	*/
d207 2
a208 1
	if (n != 2 || (fdc->sc_status[0] & 0xf8) != 0x20)
@


1.32
log
@whoops, correct d_nsectors
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.31 1996/12/05 17:16:05 deraadt Exp $	*/
d995 1
a995 1
		if (errstring) {
a996 2
			return;
		}
@


1.31
log
@remove duplicate code; nice readdisklabel warning messages
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.30 1996/12/05 13:13:05 deraadt Exp $	*/
d973 1
a973 1
		lp->d_nsectors = fd->sc_type->seccyl;
@


1.30
log
@call readdisklabel() in the same fashion as sd.c does
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.29 1996/11/29 22:54:55 niklas Exp $	*/
d958 1
a958 1
	char *msg;
a974 1
		lp->d_secpercyl = lp->d_ntracks * lp->d_nsectors;
d994 5
a998 2
		if ((msg = readdisklabel(dev, fdstrategy, lp, &cdl)) != NULL)
			printf("readdisklabel: %s\n", msg);
@


1.29
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.28 1996/11/12 20:30:31 niklas Exp $	*/
d956 3
a958 1
	struct disklabel buffer;
d967 2
a968 1
		bzero(&buffer, sizeof(buffer));
d970 24
a993 3
		buffer.d_secpercyl = fd->sc_type->seccyl;
		buffer.d_type = DTYPE_FLOPPY;
		buffer.d_secsize = 128 << fd->sc_type->secsize;
d995 2
a996 2
		if (readdisklabel(dev, fdstrategy, &buffer, NULL) != NULL)
			return EINVAL;
d998 1
a998 1
		*(struct disklabel *)addr = buffer;
d1011 1
a1011 1
		error = setdisklabel(&buffer, (struct disklabel *)addr, 0, NULL);
d1015 1
a1015 1
		error = writedisklabel(dev, fdstrategy, &buffer, NULL);
@


1.28
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.27 1996/10/28 00:36:18 downsj Exp $	*/
d67 1
a67 1
#include <machine/bus.old.h>
d169 2
a170 2
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
d189 1
a189 1
	bus_io_write_1(bc, ioh, fdout, drive | FDO_FRST | FDO_MOEN(drive));
d192 2
a193 2
	out_fdc(bc, ioh, NE7CMD_RECAL);
	out_fdc(bc, ioh, drive);
d196 1
a196 1
	out_fdc(bc, ioh, NE7CMD_SENSEI);
d210 1
a210 1
	bus_io_write_1(bc, ioh, fdout, FDO_FRST);
d481 1
a481 1
	bus_io_write_1(fdc->sc_bc, fdc->sc_ioh, fdout, status);
d591 2
a592 2
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
d654 7
a660 7
		out_fdc(bc, ioh, NE7CMD_SPECIFY);/* specify command */
		out_fdc(bc, ioh, fd->sc_type->steprate);
		out_fdc(bc, ioh, 6);		/* XXX head load time == 6ms */

		out_fdc(bc, ioh, NE7CMD_SEEK);	/* seek function */
		out_fdc(bc, ioh, fd->sc_drive);	/* drive number */
		out_fdc(bc, ioh, bp->b_cylin * fd->sc_type->step);
d703 1
a703 1
		bus_io_write_1(bc, ioh, fdctl, type->rate);
d711 1
a711 1
			if (out_fdc(bc, ioh, NE7CMD_FORMAT) < 0) {
d716 5
a720 5
                        out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
                        out_fdc(bc, ioh, finfo->fd_formb_secshift);
                        out_fdc(bc, ioh, finfo->fd_formb_nsecs);
                        out_fdc(bc, ioh, finfo->fd_formb_gaplen);
                        out_fdc(bc, ioh, finfo->fd_formb_fillbyte);
d723 1
a723 1
				out_fdc(bc, ioh, NE7CMD_READ);	/* READ */
d725 9
a733 9
				out_fdc(bc, ioh, NE7CMD_WRITE);	/* WRITE */
			out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
			out_fdc(bc, ioh, fd->sc_cylin);		/* track */
			out_fdc(bc, ioh, head);
			out_fdc(bc, ioh, sec + 1);		/* sector +1 */
			out_fdc(bc, ioh, type->secsize);	/* sector size */
			out_fdc(bc, ioh, type->sectrac);	/* sectors/track */
			out_fdc(bc, ioh, type->gap1);		/* gap1 size */
			out_fdc(bc, ioh, type->datalen);	/* data length */
d754 1
a754 1
		out_fdc(bc, ioh, NE7CMD_SENSEI);
d834 1
a834 1
			out_fdc(bc, ioh, NE7CMD_SENSEI);
d840 2
a841 2
		out_fdc(bc, ioh, NE7CMD_RECAL);	/* recalibrate function */
		out_fdc(bc, ioh, fd->sc_drive);
d854 1
a854 1
		out_fdc(bc, ioh, NE7CMD_SENSEI);
@


1.27
log
@Change block size handling and add untested support for Japanese 1.2mb
floppies.  From <minoura@@kw.netlaputa.or.jp>.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.26 1996/10/28 00:06:20 downsj Exp $	*/
d67 1
a67 1
#include <machine/bus.h>
@


1.26
log
@Merge in old/latest code.  Untested support for 2.88mb floppy drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.23 1996/10/16 12:46:22 deraadt Exp $	*/
d98 2
a99 1
	{ 36,2,72,2,0xff,0xaf,0x1b,0x54,80,5760,1,FDC_500KBPS,"2.88MB"    }  /* 2.88MB diskette */
d247 3
d329 2
d334 2
a335 1
	    ((bp->b_bcount % FDC_BSIZE) != 0 &&
d345 1
a345 1
	sz = howmany(bp->b_bcount, FDC_BSIZE);
d347 2
a348 2
	if (bp->b_blkno + sz > fd->sc_type->size) {
		sz = fd->sc_type->size - bp->b_blkno;
d361 1
a361 1
 	bp->b_cylin = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE) / fd->sc_type->seccyl;
d596 1
d605 2
d624 1
a624 1
		fd->sc_blkno = bp->b_blkno / (FDC_BSIZE / DEV_BSIZE);
d679 2
a680 2
		nblks = min(nblks, fd->sc_bcount / FDC_BSIZE);
		nblks = min(nblks, FDC_MAXIOSIZE / FDC_BSIZE);
d682 1
a682 1
		fd->sc_nbytes = finfo ? bp->b_bcount : nblks * FDC_BSIZE;
d807 1
a807 1
			    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);
d932 2
a933 1
		    fd->sc_skip / FDC_BSIZE, (struct disklabel *)NULL);
d969 1
a969 1
		buffer.d_secsize = FDC_BSIZE;
d1035 1
d1051 1
a1051 1
                + finfo->head * type->sectrac) * FDC_BSIZE / DEV_BSIZE;
@


1.25
log
@more move changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.24 1996/10/26 06:22:37 downsj Exp $	*/
d5 1
a5 1
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.
d98 1
d231 3
a233 1
		/* 1 is reserved for 2.88MB */
d258 2
a259 1
	fdc->sc_fd[drive] = fd;
a281 1
#if defined(i386)
d292 1
a292 1
		/* XXX We really ought to handle 2.88MB format. */
a303 3
#else
	return NULL;
#endif
d322 1
a322 2
	struct fd_softc *fd;
	int unit = FDUNIT(bp->b_dev);
d327 1
a327 3
	if (unit >= fd_cd.cd_ndevs ||
	    (fd = fd_cd.cd_devs[unit]) == 0 ||
	    bp->b_blkno < 0 ||
d392 1
a392 1
	int active = fdc->sc_drives.tqh_first != 0;
d396 1
a396 1
	TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);
d418 1
a418 1
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
d420 2
a421 1
			TAILQ_INSERT_TAIL(&fdc->sc_drives, fd, sc_drivechain);
d464 1
a464 1
	if ((fd = fdc->sc_drives.tqh_first) != NULL)
d471 2
a472 1
		if ((fd = fdc->sc_fd[n]) && (fd->sc_flags & FD_MOTOR))
d500 2
a501 1
	if ((fdc->sc_drives.tqh_first == fd) && (fdc->sc_state == MOTORWAIT))
d592 1
a592 1
	fd = fdc->sc_drives.tqh_first;
d601 1
a601 1
		TAILQ_REMOVE(&fdc->sc_drives, fd, sc_drivechain);
d622 2
a623 1
			struct fd_softc *ofd = fdc->sc_fd[fd->sc_drive ^ 1];
@


1.24
log
@move related trivial changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.23 1996/10/16 12:46:22 deraadt Exp $	*/
a76 1
#include <dev/ic/mc146818reg.h>			/* for NVRAM access */
d278 1
d301 3
@


1.23
log
@the Wall thing, you know
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.22 1996/09/23 15:31:53 mickey Exp $	*/
d74 1
a74 1
#include <i386/isa/fdreg.h>
d76 1
d79 1
d81 1
a81 1
#include <i386/isa/fdlink.h>
@


1.22
log
@propagte FD{UNIT,PART} definitions.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.21 1996/09/01 20:58:26 downsj Exp $	*/
d62 1
d144 1
@


1.21
log
@initial commit of split fdc/fd drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.20 1996/08/29 18:03:27 downsj Exp $	*/
a78 3

#define FDUNIT(dev)	(minor(dev) / 8)
#define FDTYPE(dev)	(minor(dev) % 8)
@


1.20
log
@Add `flags' specification to floppy devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.19 1996/08/07 15:54:41 deraadt Exp $	*/
d78 2
a87 53
enum fdc_state {
	DEVIDLE = 0,
	MOTORWAIT,
	DOSEEK,
	SEEKWAIT,
	SEEKTIMEDOUT,
	SEEKCOMPLETE,
	DOIO,
	IOCOMPLETE,
	IOTIMEDOUT,
	DORESET,
	RESETCOMPLETE,
	RESETTIMEDOUT,
	DORECAL,
	RECALWAIT,
	RECALTIMEDOUT,
	RECALCOMPLETE,
};

/* software state, per controller */
struct fdc_softc {
	struct device sc_dev;		/* boilerplate */
	struct isadev sc_id;
	void *sc_ih;

	bus_chipset_tag_t sc_bc;	/* ISA chipset identifier */
	bus_io_handle_t   sc_ioh;	/* ISA io handle */

	int sc_drq;

	struct fd_softc *sc_fd[4];	/* pointers to children */
	TAILQ_HEAD(drivehead, fd_softc) sc_drives;
	enum fdc_state sc_state;
	int sc_errors;			/* number of retries so far */
	u_char sc_status[7];		/* copy of registers */
};

/* controller driver configuration */
int fdcprobe __P((struct device *, void *, void *));
int fdprint __P((void *, char *));
#ifdef NEWCONFIG
void fdcforceintr __P((void *));
#endif
void fdcattach __P((struct device *, struct device *, void *));

struct cfattach fdc_ca = {
	sizeof(struct fdc_softc), fdcprobe, fdcattach
};

struct cfdriver fdc_cd = {
	NULL, "fdc", DV_DULL
};

a148 1
struct fd_type *fd_nvtotype __P((char *, int, int));
a151 8
int fdcresult __P((struct fdc_softc *fdc));
int out_fdc __P((bus_chipset_tag_t bc, bus_io_handle_t ioh, u_char x));
void fdcstart __P((struct fdc_softc *fdc));
void fdcstatus __P((struct device *dv, int n, char *s));
void fdctimeout __P((void *arg));
void fdcpseudointr __P((void *arg));
int fdcintr __P((void *));
void fdcretry __P((struct fdc_softc *fdc));
d155 2
a156 156

int
fdcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	register struct isa_attach_args *ia = aux;
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	int rv;

	bc = ia->ia_bc;
	rv = 0;

	/* Map the i/o space. */
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
		return 0;

	/* reset */
	bus_io_write_1(bc, ioh, fdout, 0);
	delay(100);
	bus_io_write_1(bc, ioh, fdout, FDO_FRST);

	/* see if it can handle a command */
	if (out_fdc(bc, ioh, NE7CMD_SPECIFY) < 0)
		goto out;
	out_fdc(bc, ioh, 0xdf);
	out_fdc(bc, ioh, 2);

#ifdef NEWCONFIG
	if (ia->ia_iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
		return 0;

	if (ia->ia_irq == IRQUNK) {
		ia->ia_irq = isa_discoverintr(fdcforceintr, aux);
		if (ia->ia_irq == IRQNONE)
			goto out;

		/* reset it again */
		bus_io_write_1(bc, ioh, fdout, 0);
		delay(100);
		bus_io_write_1(bc, ioh, fdout, FDO_FRST);
	}
#endif

	rv = 1;
	ia->ia_iosize = FDC_NPORT;
	ia->ia_msize = 0;

 out:
	bus_io_unmap(bc, ioh, FDC_NPORT);
	return rv;
}

#ifdef NEWCONFIG
/*
 * XXX This is broken, and needs fixing.  In general, the interface needs
 * XXX to change.
 */
void
fdcforceintr(aux)
	void *aux;
{
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;

	/* the motor is off; this should generate an error with or
	   without a disk drive present */
	out_fdc(bc, ioh, NE7CMD_SEEK);
	out_fdc(bc, ioh, 0);
	out_fdc(bc, ioh, 0);
}
#endif

/*
 * Arguments passed between fdcattach and fdprobe.
 */
struct fdc_attach_args {
	int fa_drive;
	int fa_flags;
	struct fd_type *fa_deftype;
};

/*
 * Print the location of a disk drive (called just before attaching the
 * the drive).  If `fdc' is not NULL, the drive was found but was not
 * in the system config file; print the drive name as well.
 * Return QUIET (config_find ignores this if the device was configured) to
 * avoid printing `fdN not configured' messages.
 */
int
fdprint(aux, fdc)
	void *aux;
	char *fdc;
{
	register struct fdc_attach_args *fa = aux;

	if (!fdc)
		printf(" drive %d", fa->fa_drive);
	return QUIET;
}

void
fdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct fdc_softc *fdc = (void *)self;
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	struct isa_attach_args *ia = aux;
	struct fdc_attach_args fa;
	int type;

	bc = ia->ia_bc;

	/* Re-map the I/O space. */
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
		panic("fdcattach: couldn't map I/O ports");

	fdc->sc_bc = bc;
	fdc->sc_ioh = ioh;

	fdc->sc_drq = ia->ia_drq;
	fdc->sc_state = DEVIDLE;
	TAILQ_INIT(&fdc->sc_drives);

	printf("\n");

#ifdef NEWCONFIG
	at_setup_dmachan(fdc->sc_drq, FDC_MAXIOSIZE);
	isa_establish(&fdc->sc_id, &fdc->sc_dev);
#endif
	fdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, fdcintr, fdc, fdc->sc_dev.dv_xname);

	/*
	 * The NVRAM info only tells us about the first two disks on the
	 * `primary' floppy controller.
	 */
	if (fdc->sc_dev.dv_unit == 0)
		type = mc146818_read(NULL, NVRAM_DISKETTE); /* XXX softc */
	else
		type = -1;

	/* physical limit: four drives per controller. */
	for (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {
		fa.fa_flags = 0;
		if (type >= 0 && fa.fa_drive < 2)
			fa.fa_deftype = fd_nvtotype(fdc->sc_dev.dv_xname,
			    type, fa.fa_drive);
		else
			fa.fa_deftype = NULL;		/* unknown */
		(void)config_found(self, (void *)&fa, fdprint);
	}
}
d498 1
a498 1
		(void) fdcintr(fdc);
a502 45
fdcresult(fdc)
	struct fdc_softc *fdc;
{
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
	u_char i;
	int j = 100000,
	    n = 0;

	for (; j; j--) {
		i = bus_io_read_1(bc, ioh, fdsts) &
		    (NE7_DIO | NE7_RQM | NE7_CB);
		if (i == NE7_RQM)
			return n;
		if (i == (NE7_DIO | NE7_RQM | NE7_CB)) {
			if (n >= sizeof(fdc->sc_status)) {
				log(LOG_ERR, "fdcresult: overrun\n");
				return -1;
			}
			fdc->sc_status[n++] = bus_io_read_1(bc, ioh, fddata);
		}
	}
	log(LOG_ERR, "fdcresult: timeout\n");
	return -1;
}

int
out_fdc(bc, ioh, x)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
	u_char x;
{
	int i = 100000;

	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_DIO) && i-- > 0);
	if (i <= 0)
		return -1;
	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);
	if (i <= 0)
		return -1;
	bus_io_write_1(bc, ioh, fddata, x);
	return 0;
}

int
d548 3
a550 3
void
fdcstart(fdc)
	struct fdc_softc *fdc;
d553 2
a554 9
#ifdef DIAGNOSTIC
	/* only got here if controller's drive queue was inactive; should
	   be in idle state */
	if (fdc->sc_state != DEVIDLE) {
		printf("fdcstart: not idle\n");
		return;
	}
#endif
	(void) fdcintr(fdc);
d557 6
a562 5
void
fdcstatus(dv, n, s)
	struct device *dv;
	int n;
	char *s;
a563 1
	struct fdc_softc *fdc = (void *)dv->dv_parent;
d565 2
a566 65
	if (n == 0) {
		out_fdc(fdc->sc_bc, fdc->sc_ioh, NE7CMD_SENSEI);
		(void) fdcresult(fdc);
		n = 2;
	}

	printf("%s: %s", dv->dv_xname, s);

	switch (n) {
	case 0:
		printf("\n");
		break;
	case 2:
		printf(" (st0 %b cyl %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1]);
		break;
	case 7:
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);
		break;
#ifdef DIAGNOSTIC
	default:
		printf("\nfdcstatus: weird size");
		break;
#endif
	}
}

void
fdctimeout(arg)
	void *arg;
{
	struct fdc_softc *fdc = arg;
	struct fd_softc *fd = fdc->sc_drives.tqh_first;
	int s;

	s = splbio();
#ifdef DEBUG
	log(LOG_ERR,"fdctimeout: state %d\n", fdc->sc_state);
#endif
	fdcstatus(&fd->sc_dev, 0, "timeout");

	if (fd->sc_q.b_actf)
		fdc->sc_state++;
	else
		fdc->sc_state = DEVIDLE;

	(void) fdcintr(fdc);
	splx(s);
}

void
fdcpseudointr(arg)
	void *arg;
{
	int s;

	/* Just ensure it has the right spl. */
	s = splbio();
	(void) fdcintr(arg);
	splx(s);
d569 3
d573 2
a574 2
fdcintr(arg)
	void *arg;
a575 1
	struct fdc_softc *fdc = arg;
d587 1
a587 1
	/* Is there a drive for the controller to do a transfer with? */
d591 1
a591 1
 		return 1;
a593 1
	/* Is there a transfer to this drive?  If not, deactivate drive. */
d653 1
a653 1
		timeout(fdctimeout, fdc, 4 * hz);
d674 1
a674 1
			 printf("fdcintr: block %d != blkno %d\n", block, fd->sc_blkno);
d690 1
a690 1
		printf("fdcintr: %s drive %d track %d head %d sec %d nblks %d\n",
d698 1
a698 1
			    fdcretry(fdc);
d725 1
a725 1
		timeout(fdctimeout, fdc, 2 * hz);
d729 1
a729 1
		untimeout(fdctimeout, fdc);
d745 1
a745 1
			fdcretry(fdc);
d760 1
a760 1
		fdcretry(fdc);
d764 1
a764 1
		untimeout(fdctimeout, fdc);
d780 1
a780 1
			fdcretry(fdc);
d812 1
a812 1
		timeout(fdctimeout, fdc, hz / 2);
d816 1
a816 1
		untimeout(fdctimeout, fdc);
d828 1
a828 1
		timeout(fdctimeout, fdc, 5 * hz);
d832 1
a832 1
		untimeout(fdctimeout, fdc);
d844 1
a844 1
			fdcretry(fdc);
d860 1
a860 1
	panic("fdcintr: impossible");
d867 2
a868 2
fdcretry(fdc)
	struct fdc_softc *fdc;
d870 21
d892 3
a894 4
	struct buf *bp;

	fd = fdc->sc_drives.tqh_first;
	bp = fd->sc_q.b_actf;
a928 21
}

int
fdsize(dev)
	dev_t dev;
{

	/* Swapping to floppies would not make sense. */
	return -1;
}

int
fddump(dev, blkno, va, size)
	dev_t dev;
	daddr_t blkno;
	caddr_t va;
	size_t size;
{

	/* Not implemented. */
	return ENXIO;
@


1.19
log
@correct b_resid handling; pointed out by banshee@@gabriella.abattoir.com
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.18 1996/06/20 07:51:37 downsj Exp $	*/
d294 1
d362 1
d395 5
d441 18
a458 1
	/* XXX Allow `flags' to override device type? */
@


1.18
log
@fdformat support:
	patches taken from jtk's dosemu for NetBSD 1.1 and updated for
	the current driver.  Some of the code is based an older FreeBSD
	version of the driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.17 1996/06/09 19:40:28 deraadt Exp $	*/
d531 1
a531 1
		if (sz == 0) {
a532 1
			bp->b_resid = bp->b_bcount;
a533 1
		}
d572 1
@


1.17
log
@support MTIOCTOP's MTOFFL to mean "eject"
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.16 1996/06/01 09:36:52 deraadt Exp $	*/
d12 6
d59 1
d69 1
d81 3
d139 1
a139 19
/*
 * Floppies come in various flavors, e.g., 1.2MB vs 1.44MB; here is how
 * we tell them apart.
 */
struct fd_type {
	int	sectrac;	/* sectors per track */
	int	heads;		/* number of heads */
	int	seccyl;		/* sectors per cylinder */
	int	secsize;	/* size code for sectors */
	int	datalen;	/* data len when secsize = 0 */
	int	steprate;	/* step rate and head unload time */
	int	gap1;		/* gap len between sectors */
	int	gap2;		/* formatting gap */
	int	tracks;		/* total num of tracks */
	int	size;		/* size of disk in sectors */
	int	step;		/* steps per cylinder */
	int	rate;		/* transfer speed code */
	char	*name;
};
d162 1
d213 1
d517 2
a518 1
	    (bp->b_bcount % FDC_BSIZE) != 0) {
d780 1
d849 3
d888 1
d907 3
d964 3
d972 1
a972 1
		fd->sc_nbytes = nblks * FDC_BSIZE;
d999 26
a1024 12
		if (read)
			out_fdc(bc, ioh, NE7CMD_READ);	/* READ */
		else
			out_fdc(bc, ioh, NE7CMD_WRITE);	/* WRITE */
		out_fdc(bc, ioh, (head << 2) | fd->sc_drive);
		out_fdc(bc, ioh, fd->sc_cylin);		/* track */
		out_fdc(bc, ioh, head);
		out_fdc(bc, ioh, sec + 1);		/* sector +1 */
		out_fdc(bc, ioh, type->secsize);	/* sector size */
		out_fdc(bc, ioh, type->sectrac);	/* sectors/track */
		out_fdc(bc, ioh, type->gap1);		/* gap1 size */
		out_fdc(bc, ioh, type->datalen);	/* data length */
d1104 1
a1104 1
		if (fd->sc_bcount > 0) {
d1181 2
d1200 1
d1284 22
d1313 60
@


1.16
log
@all ports have dk_establish()
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.15 1996/05/25 22:17:48 deraadt Exp $	*/
d54 1
d1226 4
@


1.15
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.14 1996/05/07 07:22:16 deraadt Exp $	*/
a457 2
#ifdef NEWCONFIG
	/* XXX Need to do some more fiddling with sc_dk. */
a458 1
#endif
@


1.14
log
@sync with 0504; prototype changes
@
text
@d1 2
a2 2
/*	$OpenBSD: fd.c,v 1.13 1996/04/21 22:16:52 deraadt Exp $	*/
/*	$NetBSD: fd.c,v 1.88 1996/05/03 19:14:53 christos Exp $	*/
d58 1
a58 1
#include <machine/pio.h>
d60 1
d99 3
a101 1
	int sc_iobase;
d210 1
a210 1
int out_fdc __P((int iobase, u_char x));
d226 10
a235 1
	int iobase = ia->ia_iobase;
d238 1
a238 1
	outb(iobase + fdout, 0);
d240 1
a240 1
	outb(iobase + fdout, FDO_FRST);
d243 4
a246 4
	if (out_fdc(iobase, NE7CMD_SPECIFY) < 0)
		return 0;
	out_fdc(iobase, 0xdf);
	out_fdc(iobase, 2);
d249 1
a249 1
	if (iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
d255 1
a255 1
			return 0;
d258 1
a258 1
		outb(iobase + fdout, 0);
d260 1
a260 1
		outb(iobase + fdout, FDO_FRST);
d264 1
d267 4
a270 1
	return 1;
d274 4
d287 3
a289 3
	out_fdc(iobase, NE7CMD_SEEK);
	out_fdc(iobase, 0);
	out_fdc(iobase, 0);
d326 2
d332 9
a340 1
	fdc->sc_iobase = ia->ia_iobase;
d383 2
a384 1
	int iobase = fdc->sc_iobase;
d398 1
a398 1
	outb(iobase + fdout, drive | FDO_FRST | FDO_MOEN(drive));
d401 2
a402 2
	out_fdc(iobase, NE7CMD_RECAL);
	out_fdc(iobase, drive);
d405 1
a405 1
	out_fdc(iobase, NE7CMD_SENSEI);
d419 1
a419 1
	outb(iobase + fdout, FDO_FRST);
d668 1
a668 1
	outb(fdc->sc_iobase + fdout, status);
d703 2
a704 1
	int iobase = fdc->sc_iobase;
d710 2
a711 1
		i = inb(iobase + fdsts) & (NE7_DIO | NE7_RQM | NE7_CB);
d719 1
a719 1
			fdc->sc_status[n++] = inb(iobase + fddata);
d727 3
a729 2
out_fdc(iobase, x)
	int iobase;
d734 1
a734 1
	while ((inb(iobase + fdsts) & NE7_DIO) && i-- > 0);
d737 1
a737 1
	while ((inb(iobase + fdsts) & NE7_RQM) == 0 && i-- > 0);
d740 1
a740 1
	outb(iobase + fddata, x);
d814 1
a814 1
		out_fdc(fdc->sc_iobase, NE7CMD_SENSEI);
d886 2
a887 1
	int iobase = fdc->sc_iobase;
d942 7
a948 7
		out_fdc(iobase, NE7CMD_SPECIFY);/* specify command */
		out_fdc(iobase, fd->sc_type->steprate);
		out_fdc(iobase, 6);		/* XXX head load time == 6ms */

		out_fdc(iobase, NE7CMD_SEEK);	/* seek function */
		out_fdc(iobase, fd->sc_drive);	/* drive number */
		out_fdc(iobase, bp->b_cylin * fd->sc_type->step);
d988 1
a988 1
		outb(iobase + fdctl, type->rate);
d995 1
a995 1
			out_fdc(iobase, NE7CMD_READ);	/* READ */
d997 9
a1005 9
			out_fdc(iobase, NE7CMD_WRITE);	/* WRITE */
		out_fdc(iobase, (head << 2) | fd->sc_drive);
		out_fdc(iobase, fd->sc_cylin);		/* track */
		out_fdc(iobase, head);
		out_fdc(iobase, sec + 1);		/* sector +1 */
		out_fdc(iobase, type->secsize);		/* sector size */
		out_fdc(iobase, type->sectrac);		/* sectors/track */
		out_fdc(iobase, type->gap1);		/* gap1 size */
		out_fdc(iobase, type->datalen);		/* data length */
d1025 1
a1025 1
		out_fdc(iobase, NE7CMD_SENSEI);
d1105 1
a1105 1
			out_fdc(iobase, NE7CMD_SENSEI);
d1111 2
a1112 2
		out_fdc(iobase, NE7CMD_RECAL);	/* recalibrate function */
		out_fdc(iobase, fd->sc_drive);
d1125 1
a1125 1
		out_fdc(iobase, NE7CMD_SENSEI);
@


1.13
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: fd.c,v 1.12 1996/04/18 17:12:13 niklas Exp $	*/
/*	$NetBSD: fd.c,v 1.87 1996/04/11 22:15:16 cgd Exp $	*/
a45 1
#include <sys/conf.h>
d59 1
d110 1
d215 1
d468 1
a468 1
inline struct fd_type *
d600 1
a600 1
fdread(dev, uio)
d603 1
d610 1
a610 1
fdwrite(dev, uio)
d613 1
d628 1
a628 1
	if (fd = fdc->sc_drives.tqh_first)
d711 1
a711 1
Fdopen(dev, flags)
d714 2
d743 1
a743 1
fdclose(dev, flags)
d746 2
a777 1
	int iobase = fdc->sc_iobase;
d853 1
a853 1
	int read, head, trac, sec, i, s, nblks;
d1181 1
a1181 1
fdioctl(dev, cmd, addr, flag)
d1186 1
@


1.12
log
@Merge of NetBSD 960317
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: fd.c,v 1.85 1996/03/04 04:01:03 mycroft Exp $	*/
d115 6
a120 2
struct cfdriver fdccd = {
	NULL, "fdc", fdcprobe, fdcattach, DV_DULL, sizeof(struct fdc_softc)
d186 6
a191 2
struct cfdriver fdcd = {
	NULL, "fd", fdprobe, fdattach, DV_DISK, sizeof(struct fd_softc)
d319 2
a320 2
	fdc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_BIO, fdcintr,
	    fdc, fdc->sc_dev.dv_xname);
d488 2
a489 2
	if (unit >= fdcd.cd_ndevs ||
	    (fd = fdcd.cd_devs[unit]) == 0 ||
d716 1
a716 1
	if (unit >= fdcd.cd_ndevs)
d718 1
a718 1
	fd = fdcd.cd_devs[unit];
d741 1
a741 1
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
d1180 1
a1180 1
	struct fd_softc *fd = fdcd.cd_devs[FDUNIT(dev)];
@


1.11
log
@Fix back wrong patches.
@
text
@d1 2
a2 1
/*	$NetBSD: fd.c,v 1.84 1996/02/10 18:31:13 thorpej Exp $	*/
d930 1
a930 1
		read = bp->b_flags & B_READ;
d1022 1
a1022 1
		read = bp->b_flags & B_READ;
@


1.10
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d311 1
a311 1
	    fdc);
@


1.9
log
@Fix disk_unbusy panic (from NetBSD)
@
text
@d311 1
a311 1
	    fdc, fdc->sc_dev.dv_xname);
d934 2
a935 2
		isadma_start(bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq, read ? ISADMA_START_READ : ISADMA_START_WRITE);
d990 1
a990 1
		isadma_abort(fdc->sc_drq);
d1007 1
a1007 1
			isadma_abort(fdc->sc_drq);
d1021 3
a1023 1
		isadma_done(fdc->sc_drq);
@


1.8
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 1
a1 1
/*	$NetBSD: fd.c,v 1.82 1996/01/07 22:02:28 thorpej Exp $	*/
d1112 1
a1112 2
		fdc->sc_state = SEEKCOMPLETE;
		disk_busy(&fd->sc_dk);
@


1.7
log
@hannken: Fix disk_unbusy panic when booting from floppies
@
text
@d311 1
a311 1
	    fdc);
@


1.6
log
@from netbsd:
Balance calls to disk_busy() and disk_unbusy() properly to avoid
dk_busy < 0 panics.  Count seeks.
@
text
@d1113 1
@


1.5
log
@from netbsd;
New generic disk framework.  Highlights:
New metrics handling.  Metrics are now kept in the new `struct disk'.
Busy time is now stored as a timeval, and transfer count in bytes.
Storage for disklabels is now dynamically allocated, so that the size
of the disk structure is not machine-dependent.
Several new functions for attaching and detaching disks, and handling
metrics calculation.
Old-style instrumentation is still supported in drivers that did it
before.  However, old-style instrumentation is being deprecated, and
will go away once the userland utilities are updated for the new
framework.
For usage and architectural details, see the forthcoming disk(9)
manual page.
@
text
@a551 3
	/* Instrumentation. */
	disk_busy(&fd->sc_dk);

a581 2
	disk_unbusy(&fd->sc_dk, (bp->b_bcount - bp->b_resid));

d901 4
d956 3
d971 2
d1000 3
@


1.4
log
@from perry:
fixed my own pr 1758 -- the floppy drive motor was not being turned off
at halt time, especially if a floppy was mounted. Added a shutdown hook
to turn off the motor. Per a request by mycroft, the cookie from the hook
is saved in a new member I added to the fd_softc structure.
@
text
@d1 1
a1 1
/*	$NetBSD: fd.c,v 1.79 1995/08/21 06:56:14 mycroft Exp $	*/
d152 1
a152 1
	struct dkdevice sc_dk;
d408 5
d414 2
d552 3
d584 3
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
@
text
@d170 2
d413 2
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
@
text
@d308 2
a309 2
	fdc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_BIO,
	    fdcintr, fdc);
@


1.1
log
@Initial revision
@
text
@d918 2
a919 2
		isa_dmastart(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
d969 1
a969 1
		isa_dmaabort(fdc->sc_drq);
d983 1
a983 1
			isa_dmaabort(fdc->sc_drq);
d997 1
a997 3
		read = bp->b_flags & B_READ;
		isa_dmadone(read, bp->b_data + fd->sc_skip, fd->sc_nbytes,
		    fdc->sc_drq);
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
