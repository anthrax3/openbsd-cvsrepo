head	1.37;
access;
symbols
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.34.0.4
	OPENBSD_5_7_BASE:1.34
	OPENBSD_5_6:1.33.0.8
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.33.0.6
	OPENBSD_5_5_BASE:1.33
	OPENBSD_5_4:1.33.0.2
	OPENBSD_5_4_BASE:1.33
	OPENBSD_5_3:1.32.0.4
	OPENBSD_5_3_BASE:1.32
	OPENBSD_5_2:1.32.0.2
	OPENBSD_5_2_BASE:1.32
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.8
	OPENBSD_5_0:1.31.0.6
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.4
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.2
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.27.0.10
	OPENBSD_4_6_BASE:1.27
	OPENBSD_4_5:1.27.0.6
	OPENBSD_4_5_BASE:1.27
	OPENBSD_4_4:1.27.0.4
	OPENBSD_4_4_BASE:1.27
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.25.0.4
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.25.0.2
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.24.0.6
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.4
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.6
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.23.0.4
	OPENBSD_3_6_BASE:1.23
	SMP_SYNC_A:1.23
	SMP_SYNC_B:1.23
	OPENBSD_3_5:1.23.0.2
	OPENBSD_3_5_BASE:1.23
	OPENBSD_3_4:1.22.0.2
	OPENBSD_3_4_BASE:1.22
	UBC_SYNC_A:1.22
	OPENBSD_3_3:1.21.0.6
	OPENBSD_3_3_BASE:1.21
	OPENBSD_3_2:1.21.0.4
	OPENBSD_3_2_BASE:1.21
	OPENBSD_3_1:1.21.0.2
	OPENBSD_3_1_BASE:1.21
	UBC_SYNC_B:1.21
	UBC:1.18.0.2
	UBC_BASE:1.18
	OPENBSD_3_0:1.16.0.4
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.16
	OPENBSD_2_9:1.16.0.2
	OPENBSD_2_8:1.14.0.8
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.6
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.4
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.2
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.13.0.2
	OPENBSD_2_5_BASE:1.13
	OPENBSD_2_4:1.12.0.2
	OPENBSD_2_4_BASE:1.12
	OPENBSD_2_3:1.11.0.2
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.10.0.2
	OPENBSD_2_2_BASE:1.10
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.36;
commitid	pi1a9KN0itEngOc4;

1.36
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.35;
commitid	EA6IpjJSgQH2WTCf;

1.35
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.34;
commitid	RaOGL5SyOGOZylwx;

1.34
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.33;
commitid	uzzBR7hz9ncd4O6G;

1.33
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.31;

1.31
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.30;

1.30
date	2010.04.03.23.22.42;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2009.07.31.22.53.04;	author sthen;	state Exp;
branches;
next	1.28;

1.28
date	2009.07.31.20.43.31;	author blambert;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.14.01.25.50;	author jakemsr;	state Exp;
branches;
next	1.26;

1.26
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.29.13.04.37;	author pedro;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.15.13.05.14;	author mickey;	state Exp;
branches;
next	1.23;

1.23
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.21;

1.21
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.20;

1.20
date	2002.02.12.22.31.01;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.18;

1.18
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.16;

1.16
date	2001.04.12.07.46.46;	author csapuntz;	state Exp;
branches;
next	1.15;

1.15
date	2001.02.03.05.22.24;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.07.20.16.36.05;	author deraadt;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	99.01.02.00.02.47;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	98.04.26.21.02.59;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	98.01.18.18.58.39;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	97.07.10.23.06.38;	author provos;	state Exp;
branches;
next	1.9;

1.9
date	97.01.03.00.09.59;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.11.02.01.09.37;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	96.09.16.15.39.44;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.05.26.00.27.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.05.07.07.37.41;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.04.18.23.47.47;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.03.08.16.43.14;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches;
next	;

1.14.4.1
date	2001.05.14.22.24.50;	author niklas;	state Exp;
branches;
next	1.14.4.2;

1.14.4.2
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.14.4.3;

1.14.4.3
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.14.4.4;

1.14.4.4
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	1.14.4.5;

1.14.4.5
date	2003.05.13.19.35.04;	author ho;	state Exp;
branches;
next	1.14.4.6;

1.14.4.6
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	;

1.18.2.1
date	2002.01.31.22.55.33;	author niklas;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2003.05.19.22.08.46;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@/*	$OpenBSD: sbdsp.c,v 1.35 2015/05/11 06:46:21 ratchov Exp $	*/

/*
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * SoundBlaster Pro code provided by John Kohl, based on lots of
 * information he gleaned from Steve Haehnichen <steve@@vigra.com>'s
 * SBlast driver for 386BSD and DOS driver code from Daniel Sachs
 * <sachs@@meibm15.cen.uiuc.edu>.
 * Lots of rewrites by Lennart Augustsson <augustss@@cs.chalmers.se>
 * with information from SB "Hardware Programming Guide" and the
 * Linux drivers.
 */

#include "midi.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/buf.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/isa/sbreg.h>
#include <dev/isa/sbdspvar.h>


#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (sbdspdebug) printf x
#define DPRINTFN(n,x)	if (sbdspdebug >= (n)) printf x
int	sbdspdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#ifndef SBDSP_NPOLL
#define SBDSP_NPOLL 3000
#endif

struct {
	int wdsp;
	int rdsp;
	int wmidi;
} sberr;

/*
 * Time constant routines follow.  See SBK, section 12.
 * Although they don't come out and say it (in the docs),
 * the card clearly uses a 1MHz countdown timer, as the
 * low-speed formula (p. 12-4) is:
 *	tc = 256 - 10^6 / sr
 * In high-speed mode, the constant is the upper byte of a 16-bit counter,
 * and a 256MHz clock is used:
 *	tc = 65536 - 256 * 10^ 6 / sr
 * Since we can only use the upper byte of the HS TC, the two formulae
 * are equivalent.  (Why didn't they say so?)  E.g.,
 *	(65536 - 256 * 10 ^ 6 / x) >> 8 = 256 - 10^6 / x
 *
 * The crossover point (from low- to high-speed modes) is different
 * for the SBPRO and SB20.  The table on p. 12-5 gives the following data:
 *
 *				SBPRO			SB20
 *				-----			--------
 * input ls min			4	KHz		4	KHz
 * input ls max			23	KHz		13	KHz
 * input hs max			44.1	KHz		15	KHz
 * output ls min		4	KHz		4	KHz
 * output ls max		23	KHz		23	KHz
 * output hs max		44.1	KHz		44.1	KHz
 */
/* XXX Should we round the tc?
#define SB_RATE_TO_TC(x) (((65536 - 256 * 1000000 / (x)) + 128) >> 8)
*/
#define SB_RATE_TO_TC(x) (256 - 1000000 / (x))
#define SB_TC_TO_RATE(tc) (1000000 / (256 - (tc)))

struct sbmode {
	short	model;
	u_char	channels;
	u_char	precision;
	u_short	lowrate, highrate;
	u_char	cmd;
	u_char	cmdchan;
};
static struct sbmode sbpmodes[] = {
 { SB_1,    1,  8,  4000, 22727, SB_DSP_WDMA      },
 { SB_20,   1,  8,  4000, 22727, SB_DSP_WDMA_LOOP },
 { SB_2x,   1,  8,  4000, 22727, SB_DSP_WDMA_LOOP },
 { SB_2x,   1,  8, 22727, 45454, SB_DSP_HS_OUTPUT },
 { SB_PRO,  1,  8,  4000, 22727, SB_DSP_WDMA_LOOP },
 { SB_PRO,  1,  8, 22727, 45454, SB_DSP_HS_OUTPUT },
 { SB_PRO,  2,  8, 11025, 22727, SB_DSP_HS_OUTPUT },
 /* Yes, we write the record mode to set 16-bit playback mode. weird, huh? */
 { SB_JAZZ, 1,  8,  4000, 22727, SB_DSP_WDMA_LOOP, SB_DSP_RECORD_MONO },
 { SB_JAZZ, 1,  8, 22727, 45454, SB_DSP_HS_OUTPUT, SB_DSP_RECORD_MONO },
 { SB_JAZZ, 2,  8, 11025, 22727, SB_DSP_HS_OUTPUT, SB_DSP_RECORD_STEREO },
 { SB_JAZZ, 1, 16,  4000, 22727, SB_DSP_WDMA_LOOP, JAZZ16_RECORD_MONO },
 { SB_JAZZ, 1, 16, 22727, 45454, SB_DSP_HS_OUTPUT, JAZZ16_RECORD_MONO },
 { SB_JAZZ, 2, 16, 11025, 22727, SB_DSP_HS_OUTPUT, JAZZ16_RECORD_STEREO },
 { SB_16,   1,  8,  5000, 45000, SB_DSP16_WDMA_8  },
 { SB_16,   2,  8,  5000, 45000, SB_DSP16_WDMA_8  },
#define PLAY16 15 /* must be the index of the next entry in the table */
 { SB_16,   1, 16,  5000, 45000, SB_DSP16_WDMA_16 },
 { SB_16,   2, 16,  5000, 45000, SB_DSP16_WDMA_16 },
 { -1 }
};
static struct sbmode sbrmodes[] = {
 { SB_1,    1,  8,  4000, 12987, SB_DSP_RDMA      },
 { SB_20,   1,  8,  4000, 12987, SB_DSP_RDMA_LOOP },
 { SB_2x,   1,  8,  4000, 12987, SB_DSP_RDMA_LOOP },
 { SB_2x,   1,  8, 12987, 14925, SB_DSP_HS_INPUT  },
 { SB_PRO,  1,  8,  4000, 22727, SB_DSP_RDMA_LOOP, SB_DSP_RECORD_MONO },
 { SB_PRO,  1,  8, 22727, 45454, SB_DSP_HS_INPUT,  SB_DSP_RECORD_MONO },
 { SB_PRO,  2,  8, 11025, 22727, SB_DSP_HS_INPUT,  SB_DSP_RECORD_STEREO },
 { SB_JAZZ, 1,  8,  4000, 22727, SB_DSP_RDMA_LOOP, SB_DSP_RECORD_MONO },
 { SB_JAZZ, 1,  8, 22727, 45454, SB_DSP_HS_INPUT,  SB_DSP_RECORD_MONO },
 { SB_JAZZ, 2,  8, 11025, 22727, SB_DSP_HS_INPUT,  SB_DSP_RECORD_STEREO },
 { SB_JAZZ, 1, 16,  4000, 22727, SB_DSP_RDMA_LOOP, JAZZ16_RECORD_MONO },
 { SB_JAZZ, 1, 16, 22727, 45454, SB_DSP_HS_INPUT,  JAZZ16_RECORD_MONO },
 { SB_JAZZ, 2, 16, 11025, 22727, SB_DSP_HS_INPUT,  JAZZ16_RECORD_STEREO },
 { SB_16,   1,  8,  5000, 45000, SB_DSP16_RDMA_8  },
 { SB_16,   2,  8,  5000, 45000, SB_DSP16_RDMA_8  },
 { SB_16,   1, 16,  5000, 45000, SB_DSP16_RDMA_16 },
 { SB_16,   2, 16,  5000, 45000, SB_DSP16_RDMA_16 },
 { -1 }
};

static struct audio_params sbdsp_audio_default =
	{44100, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 2};

void	sbversion(struct sbdsp_softc *);
void	sbdsp_jazz16_probe(struct sbdsp_softc *);
void	sbdsp_set_mixer_gain(struct sbdsp_softc *sc, int port);
void	sbdsp_to(void *);
void	sbdsp_pause(struct sbdsp_softc *);
int	sbdsp_set_timeconst(struct sbdsp_softc *, int);
int	sbdsp16_set_rate(struct sbdsp_softc *, int, int);
int	sbdsp_set_in_ports(struct sbdsp_softc *, int);
void	sbdsp_set_ifilter(void *, int);
int	sbdsp_get_ifilter(void *);

int	sbdsp_block_output(void *);
int	sbdsp_block_input(void *);
static	int sbdsp_adjust(int, int);

int	sbdsp_midi_intr(void *);

#ifdef AUDIO_DEBUG
void	sb_printsc(struct sbdsp_softc *);

void
sb_printsc(sc)
	struct sbdsp_softc *sc;
{
	int i;

	printf("open %d dmachan %d/%d %d/%d iobase 0x%x irq %d\n",
	    (int)sc->sc_open, sc->sc_i.run, sc->sc_o.run,
	    sc->sc_drq8, sc->sc_drq16,
	    sc->sc_iobase, sc->sc_irq);
	printf("irate %d itc %x orate %d otc %x\n",
	    sc->sc_i.rate, sc->sc_i.tc,
	    sc->sc_o.rate, sc->sc_o.tc);
	printf("spkron %u nintr %lu\n",
	    sc->spkr_state, sc->sc_interrupts);
	printf("intr8 %p arg8 %p\n",
	    sc->sc_intr8, sc->sc_arg16);
	printf("intr16 %p arg16 %p\n",
	    sc->sc_intr8, sc->sc_arg16);
	printf("gain:");
	for (i = 0; i < SB_NDEVS; i++)
		printf(" %u,%u", sc->gain[i][SB_LEFT], sc->gain[i][SB_RIGHT]);
	printf("\n");
}
#endif /* AUDIO_DEBUG */

/*
 * Probe / attach routines.
 */

/*
 * Probe for the soundblaster hardware.
 */
int
sbdsp_probe(sc)
	struct sbdsp_softc *sc;
{

	if (sbdsp_reset(sc) < 0) {
		DPRINTF(("sbdsp: couldn't reset card\n"));
		return 0;
	}
	/* if flags set, go and probe the jazz16 stuff */
	if (sc->sc_dev.dv_cfdata->cf_flags & 1)
		sbdsp_jazz16_probe(sc);
	else
		sbversion(sc);
	if (sc->sc_model == SB_UNK) {
		/* Unknown SB model found. */
		DPRINTF(("sbdsp: unknown SB model found\n"));
		return 0;
	}
	return 1;
}

/*
 * Try add-on stuff for Jazz16.
 */
void
sbdsp_jazz16_probe(sc)
	struct sbdsp_softc *sc;
{
	static u_char jazz16_irq_conf[16] = {
	    -1, -1, 0x02, 0x03,
	    -1, 0x01, -1, 0x04,
	    -1, 0x02, 0x05, -1,
	    -1, -1, -1, 0x06};
	static u_char jazz16_drq_conf[8] = {
	    -1, 0x01, -1, 0x02,
	    -1, 0x03, -1, 0x04};

	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;

	sbversion(sc);

	DPRINTF(("jazz16 probe\n"));

	if (bus_space_map(iot, JAZZ16_CONFIG_PORT, 1, 0, &ioh)) {
		DPRINTF(("bus map failed\n"));
		return;
	}

	if (jazz16_drq_conf[sc->sc_drq8] == (u_char)-1 ||
	    jazz16_irq_conf[sc->sc_irq] == (u_char)-1) {
		DPRINTF(("drq/irq check failed\n"));
		goto done;		/* give up, we can't do it. */
	}

	bus_space_write_1(iot, ioh, 0, JAZZ16_WAKEUP);
	delay(10000);			/* delay 10 ms */
	bus_space_write_1(iot, ioh, 0, JAZZ16_SETBASE);
	bus_space_write_1(iot, ioh, 0, sc->sc_iobase & 0x70);

	if (sbdsp_reset(sc) < 0) {
		DPRINTF(("sbdsp_reset check failed\n"));
		goto done;		/* XXX? what else could we do? */
	}

	if (sbdsp_wdsp(sc, JAZZ16_READ_VER)) {
		DPRINTF(("read16 setup failed\n"));
		goto done;
	}

	if (sbdsp_rdsp(sc) != JAZZ16_VER_JAZZ) {
		DPRINTF(("read16 failed\n"));
		goto done;
	}

	/* XXX set both 8 & 16-bit drq to same channel, it works fine. */
	sc->sc_drq16 = sc->sc_drq8;
	if (sbdsp_wdsp(sc, JAZZ16_SET_DMAINTR) ||
	    sbdsp_wdsp(sc, (jazz16_drq_conf[sc->sc_drq16] << 4) |
		jazz16_drq_conf[sc->sc_drq8]) ||
	    sbdsp_wdsp(sc, jazz16_irq_conf[sc->sc_irq])) {
		DPRINTF(("sbdsp: can't write jazz16 probe stuff\n"));
	} else {
		DPRINTF(("jazz16 detected!\n"));
		sc->sc_model = SB_JAZZ;
		sc->sc_mixer_model = SBM_CT1345; /* XXX really? */
	}

done:
	bus_space_unmap(iot, ioh, 1);
}

/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver .
 */
void
sbdsp_attach(sc)
	struct sbdsp_softc *sc;
{
	struct audio_params pparams, rparams;
        int i;
        u_int v;

	/*
	 * Create our DMA maps.
	 */
	if (sc->sc_drq8 != -1) {
		if (isa_dmamap_create(sc->sc_isa, sc->sc_drq8,
		    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
			printf("%s: can't create map for drq %d\n",
			    sc->sc_dev.dv_xname, sc->sc_drq8);
			return;
		}
	}
	if (sc->sc_drq16 != -1 && sc->sc_drq16 != sc->sc_drq8) {
		if (isa_dmamap_create(sc->sc_isa, sc->sc_drq16,
		    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
			printf("%s: can't create map for drq %d\n",
			    sc->sc_dev.dv_xname, sc->sc_drq16);
			return;
		}
	}

	pparams = sbdsp_audio_default;
	rparams = sbdsp_audio_default;
        sbdsp_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);

	sbdsp_set_in_ports(sc, 1 << SB_MIC_VOL);

	if (sc->sc_mixer_model != SBM_NONE) {
		/* Reset the mixer.*/
		sbdsp_mix_write(sc, SBP_MIX_RESET, SBP_MIX_RESET);
                /* And set our own default values */
		for (i = 0; i < SB_NDEVS; i++) {
			switch(i) {
			case SB_MIC_VOL:
			case SB_LINE_IN_VOL:
				v = 0;
				break;
			case SB_BASS:
			case SB_TREBLE:
				v = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN/2);
				break;
			case SB_CD_IN_MUTE:
			case SB_MIC_IN_MUTE:
			case SB_LINE_IN_MUTE:
			case SB_MIDI_IN_MUTE:
			case SB_CD_SWAP:
			case SB_MIC_SWAP:
			case SB_LINE_SWAP:
			case SB_MIDI_SWAP:
			case SB_CD_OUT_MUTE:
			case SB_MIC_OUT_MUTE:
			case SB_LINE_OUT_MUTE:
				v = 0;
				break;
			default:
				v = SB_ADJUST_GAIN(sc, AUDIO_MAX_GAIN / 2);
				break;
			}
			sc->gain[i][SB_LEFT] = sc->gain[i][SB_RIGHT] = v;
			sbdsp_set_mixer_gain(sc, i);
		}
		sc->in_filter = 0;	/* no filters turned on, please */
	}

	printf(": dsp v%d.%02d%s\n",
	       SBVER_MAJOR(sc->sc_version), SBVER_MINOR(sc->sc_version),
	       sc->sc_model == SB_JAZZ ? ": <Jazz16>" : "");

	timeout_set(&sc->sc_tmo, sbdsp_to, sbdsp_to);
	sc->sc_fullduplex = ISSB16CLASS(sc) &&
		sc->sc_drq8 != -1 && sc->sc_drq16 != -1 &&
		sc->sc_drq8 != sc->sc_drq16;
}

void
sbdsp_mix_write(sc, mixerport, val)
	struct sbdsp_softc *sc;
	int mixerport;
	int val;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	mtx_enter(&audio_lock);
	bus_space_write_1(iot, ioh, SBP_MIXER_ADDR, mixerport);
	delay(20);
	bus_space_write_1(iot, ioh, SBP_MIXER_DATA, val);
	delay(30);
	mtx_leave(&audio_lock);
}

int
sbdsp_mix_read(sc, mixerport)
	struct sbdsp_softc *sc;
	int mixerport;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int val;

	mtx_enter(&audio_lock);
	bus_space_write_1(iot, ioh, SBP_MIXER_ADDR, mixerport);
	delay(20);
	val = bus_space_read_1(iot, ioh, SBP_MIXER_DATA);
	delay(30);
	mtx_leave(&audio_lock);
	return val;
}

/*
 * Various routines to interface to higher level audio driver
 */

int
sbdsp_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
{
	struct sbdsp_softc *sc = addr;
	struct sbmode *m;
	u_int rate, tc, bmode;
	int model;
	int chan;
	struct audio_params *p;
	int mode;

	if (sc->sc_open == SB_OPEN_MIDI)
		return EBUSY;

	model = sc->sc_model;
	if (model > SB_16)
		model = SB_16;	/* later models work like SB16 */

	/*
	 * Prior to the SB16, we have only one clock, so make the sample
	 * rates match.
	 */
	if (!ISSB16CLASS(sc) &&
	    play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
		} else
			return (EINVAL);
	}

	/* Set first record info, then play info */
	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		switch (model) {
		case SB_1:
		case SB_20:
			if (mode == AUMODE_PLAY) {
				if (p->sample_rate < 4000)
					p->sample_rate = 4000;
				else if (p->sample_rate > 22727)
					p->sample_rate = 22727; /* 22050 ? */
			} else {
				if (p->sample_rate < 4000)
					p->sample_rate = 4000;
				else if (p->sample_rate > 12987)
					p->sample_rate = 12987;
			}
			break;
		case SB_2x:
			if (mode == AUMODE_PLAY) {
				if (p->sample_rate < 4000)
					p->sample_rate = 4000;
				else if (p->sample_rate > 45454)
					p->sample_rate = 45454; /* 44100 ? */
			} else {
				if (p->sample_rate < 4000)
					p->sample_rate = 4000;
				else if (p->sample_rate > 14925)
					p->sample_rate = 14925; /* ??? */
			}
			break;
		case SB_PRO:
		case SB_JAZZ:
			if (p->channels == 2) {
				if (p->sample_rate < 11025)
					p->sample_rate = 11025;
				else if (p->sample_rate > 22727)
					p->sample_rate = 22727; /* 22050 ? */
			} else {
				if (p->sample_rate < 4000)
					p->sample_rate = 4000;
				else if (p->sample_rate > 45454)
					p->sample_rate = 45454; /* 44100 ? */
			}
			break;
		case SB_16:
			if (p->sample_rate < 5000)
				p->sample_rate = 5000;
			else if (p->sample_rate > 45000)
				p->sample_rate = 45000; /* 44100 ? */
			break;
		}

		/* Locate proper commands */
		for(m = mode == AUMODE_PLAY ? sbpmodes : sbrmodes;
		    m->model != -1; m++) {
			if (model == m->model &&
			    p->channels == m->channels &&
			    p->precision == m->precision &&
			    p->sample_rate >= m->lowrate &&
			    p->sample_rate <= m->highrate)
				break;
		}
		if (m->model == -1)
			return EINVAL;
		rate = p->sample_rate;
		tc = 1;
		bmode = -1;
		if (model == SB_16) {
			switch (p->encoding) {
			case AUDIO_ENCODING_SLINEAR_BE:
				if (p->precision == 16)
					return EINVAL;
				/* fall into */
			case AUDIO_ENCODING_SLINEAR_LE:
				bmode = SB_BMODE_SIGNED;
				break;
			case AUDIO_ENCODING_ULINEAR_BE:
				if (p->precision == 16)
					return EINVAL;
				/* fall into */
			case AUDIO_ENCODING_ULINEAR_LE:
				bmode = SB_BMODE_UNSIGNED;
				break;
			default:
				return EINVAL;
			}
			if (p->channels == 2)
				bmode |= SB_BMODE_STEREO;
		} else if (m->model == SB_JAZZ && m->precision == 16) {
			switch (p->encoding) {
			case AUDIO_ENCODING_SLINEAR_LE:
				break;
			default:
				return EINVAL;
			}
			tc = SB_RATE_TO_TC(p->sample_rate * p->channels);
			p->sample_rate = SB_TC_TO_RATE(tc) / p->channels;
		} else {
			switch (p->encoding) {
			case AUDIO_ENCODING_ULINEAR_BE:
			case AUDIO_ENCODING_ULINEAR_LE:
				break;
			default:
				return EINVAL;
			}
			tc = SB_RATE_TO_TC(p->sample_rate * p->channels);
			p->sample_rate = SB_TC_TO_RATE(tc) / p->channels;
		}

		chan = m->precision == 16 ? sc->sc_drq16 : sc->sc_drq8;
		if (mode == AUMODE_PLAY) {
			sc->sc_o.rate = rate;
			sc->sc_o.tc = tc;
			sc->sc_o.modep = m;
			sc->sc_o.bmode = bmode;
			sc->sc_o.dmachan = chan;
		} else {
			sc->sc_i.rate = rate;
			sc->sc_i.tc = tc;
			sc->sc_i.modep = m;
			sc->sc_i.bmode = bmode;
			sc->sc_i.dmachan = chan;
		}

		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
		DPRINTF(("sbdsp_set_params: model=%d, mode=%d, rate=%ld, prec=%d, chan=%d, enc=%d -> tc=%02x, cmd=%02x, bmode=%02x, cmdchan=%02x\n",
			 sc->sc_model, mode, p->sample_rate, p->precision, p->channels,
			 p->encoding, tc, m->cmd, bmode, m->cmdchan));

	}

	/*
	 * XXX
	 * Should wait for chip to be idle.
	 */
	sc->sc_i.run = SB_NOTRUNNING;
	sc->sc_o.run = SB_NOTRUNNING;

	if (sc->sc_fullduplex &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD) &&
	    sc->sc_i.dmachan == sc->sc_o.dmachan) {
		DPRINTF(("sbdsp_set_params: fd=%d, usemode=%d, idma=%d, odma=%d\n", sc->sc_fullduplex, usemode, sc->sc_i.dmachan, sc->sc_o.dmachan));
		return EINVAL;
	}
	DPRINTF(("sbdsp_set_params ichan=%d, ochan=%d\n",
		 sc->sc_i.dmachan, sc->sc_o.dmachan));

	return 0;
}

void
sbdsp_set_ifilter(addr, which)
	void *addr;
	int which;
{
	struct sbdsp_softc *sc = addr;
	int mixval;

	mixval = sbdsp_mix_read(sc, SBP_INFILTER) & ~SBP_IFILTER_MASK;
	switch (which) {
	case 0:
		mixval |= SBP_FILTER_OFF;
		break;
	case SB_TREBLE:
		mixval |= SBP_FILTER_ON | SBP_IFILTER_HIGH;
		break;
	case SB_BASS:
		mixval |= SBP_FILTER_ON | SBP_IFILTER_LOW;
		break;
	default:
		return;
	}
	sc->in_filter = mixval & SBP_IFILTER_MASK;
	sbdsp_mix_write(sc, SBP_INFILTER, mixval);
}

int
sbdsp_get_ifilter(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;

	sc->in_filter =
		sbdsp_mix_read(sc, SBP_INFILTER) & SBP_IFILTER_MASK;
	switch (sc->in_filter) {
	case SBP_FILTER_ON|SBP_IFILTER_HIGH:
		return SB_TREBLE;
	case SBP_FILTER_ON|SBP_IFILTER_LOW:
		return SB_BASS;
	default:
		return 0;
	}
}

int
sbdsp_set_in_ports(sc, mask)
	struct sbdsp_softc *sc;
	int mask;
{
	int bitsl, bitsr;
	int sbport;

	if (sc->sc_open == SB_OPEN_MIDI)
		return EBUSY;

	DPRINTF(("sbdsp_set_in_ports: model=%d, mask=%x\n",
		 sc->sc_mixer_model, mask));

	switch(sc->sc_mixer_model) {
	case SBM_NONE:
		return EINVAL;
	case SBM_CT1335:
		if (mask != (1 << SB_MIC_VOL))
			return EINVAL;
		break;
	case SBM_CT1345:
		switch (mask) {
		case 1 << SB_MIC_VOL:
			sbport = SBP_FROM_MIC;
			break;
		case 1 << SB_LINE_IN_VOL:
			sbport = SBP_FROM_LINE;
			break;
		case 1 << SB_CD_VOL:
			sbport = SBP_FROM_CD;
			break;
		default:
			return (EINVAL);
		}
		sbdsp_mix_write(sc, SBP_RECORD_SOURCE, sbport | sc->in_filter);
		break;
	case SBM_CT1XX5:
	case SBM_CT1745:
		if (mask & ~((1<<SB_MIDI_VOL) | (1<<SB_LINE_IN_VOL) |
			     (1<<SB_CD_VOL) | (1<<SB_MIC_VOL)))
			return EINVAL;
		bitsr = 0;
		if (mask & (1<<SB_MIDI_VOL))    bitsr |= SBP_MIDI_SRC_R;
		if (mask & (1<<SB_LINE_IN_VOL)) bitsr |= SBP_LINE_SRC_R;
		if (mask & (1<<SB_CD_VOL))      bitsr |= SBP_CD_SRC_R;
		bitsl = SB_SRC_R_TO_L(bitsr);
		if (mask & (1<<SB_MIC_VOL)) {
			bitsl |= SBP_MIC_SRC;
			bitsr |= SBP_MIC_SRC;
		}
		sbdsp_mix_write(sc, SBP_RECORD_SOURCE_L, bitsl);
		sbdsp_mix_write(sc, SBP_RECORD_SOURCE_R, bitsr);
		break;
	}
	sc->in_mask = mask;

	return 0;
}

int
sbdsp_speaker_ctl(addr, newstate)
	void *addr;
	int newstate;
{
	struct sbdsp_softc *sc = addr;

	if (sc->sc_open == SB_OPEN_MIDI)
		return EBUSY;

	if ((newstate == SPKR_ON) &&
	    (sc->spkr_state == SPKR_OFF)) {
		sbdsp_spkron(sc);
		sc->spkr_state = SPKR_ON;
	}
	if ((newstate == SPKR_OFF) &&
	    (sc->spkr_state == SPKR_ON)) {
		sbdsp_spkroff(sc);
		sc->spkr_state = SPKR_OFF;
	}
	return 0;
}

int
sbdsp_round_blocksize(addr, blk)
	void *addr;
	int blk;
{
	return (blk + 3) & -4;	/* round to biggest sample size */
}

int
sbdsp_open(addr, flags)
	void *addr;
	int flags;
{
	struct sbdsp_softc *sc = addr;

        DPRINTF(("sbdsp_open: sc=%p\n", sc));

	if (sc->sc_open != SB_CLOSED)
		return EBUSY;
	if (sbdsp_reset(sc) != 0)
		return EIO;

	sc->sc_open = SB_OPEN_AUDIO;
	sc->sc_openflags = flags;
	sc->sc_intrm = 0;
	if (ISSBPRO(sc) &&
	    sbdsp_wdsp(sc, SB_DSP_RECORD_MONO) < 0) {
		DPRINTF(("sbdsp_open: can't set mono mode\n"));
		/* we'll readjust when it's time for DMA. */
	}

	/*
	 * Leave most things as they were; users must change things if
	 * the previous process didn't leave it they way they wanted.
	 * Looked at another way, it's easy to set up a configuration
	 * in one program and leave it for another to inherit.
	 */
	DPRINTF(("sbdsp_open: opened\n"));

	return 0;
}

void
sbdsp_close(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;

        DPRINTF(("sbdsp_close: sc=%p\n", sc));

	sc->sc_open = SB_CLOSED;
	sbdsp_spkroff(sc);
	sc->spkr_state = SPKR_OFF;
	sc->sc_intr8 = 0;
	sc->sc_intr16 = 0;
	sc->sc_intrm = 0;
	sbdsp_haltdma(sc);

	DPRINTF(("sbdsp_close: closed\n"));
}

/*
 * Lower-level routines
 */

/*
 * Reset the card.
 * Return non-zero if the card isn't detected.
 */
int
sbdsp_reset(sc)
	struct sbdsp_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	sc->sc_intr8 = 0;
	sc->sc_intr16 = 0;
	if (sc->sc_i.run != SB_NOTRUNNING) {
		isa_dmaabort(sc->sc_isa, sc->sc_i.dmachan);
		sc->sc_i.run = SB_NOTRUNNING;
	}
	if (sc->sc_o.run != SB_NOTRUNNING) {
		isa_dmaabort(sc->sc_isa, sc->sc_o.dmachan);
		sc->sc_o.run = SB_NOTRUNNING;
	}

	/*
	 * See SBK, section 11.3.
	 * We pulse a reset signal into the card.
	 * Gee, what a brilliant hardware design.
	 */
	bus_space_write_1(iot, ioh, SBP_DSP_RESET, 1);
	delay(10);
	bus_space_write_1(iot, ioh, SBP_DSP_RESET, 0);
	delay(30);
	if (sbdsp_rdsp(sc) != SB_MAGIC)
		return -1;

	return 0;
}

/*
 * Write a byte to the dsp.
 * We are at the mercy of the card as we use a
 * polling loop and wait until it can take the byte.
 */
int
sbdsp_wdsp(sc, v)
	struct sbdsp_softc *sc;
	int v;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;
	u_char x;

	for (i = SBDSP_NPOLL; --i >= 0; ) {
		x = bus_space_read_1(iot, ioh, SBP_DSP_WSTAT);
		delay(10);
		if ((x & SB_DSP_BUSY) == 0) {
			bus_space_write_1(iot, ioh, SBP_DSP_WRITE, v);
			delay(10);
			return 0;
		}
	}
	++sberr.wdsp;
	return -1;
}

/*
 * Read a byte from the DSP, using polling.
 */
int
sbdsp_rdsp(sc)
	struct sbdsp_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;
	u_char x;

	for (i = SBDSP_NPOLL; --i >= 0; ) {
		x = bus_space_read_1(iot, ioh, SBP_DSP_RSTAT);
		delay(10);
		if (x & SB_DSP_READY) {
			x = bus_space_read_1(iot, ioh, SBP_DSP_READ);
			delay(10);
			return x;
		}
	}
	++sberr.rdsp;
	return -1;
}

/*
 * Doing certain things (like toggling the speaker) make
 * the SB hardware go away for a while, so pause a little.
 */
void
sbdsp_to(arg)
	void *arg;
{
	wakeup(arg);
}

void
sbdsp_pause(sc)
	struct sbdsp_softc *sc;
{
	timeout_add_msec(&sc->sc_tmo, 125);	/* 8x per second */
	(void)tsleep(sbdsp_to, PWAIT, "sbpause", 0);
}

/*
 * Turn on the speaker.  The SBK documention says this operation
 * can take up to 1/10 of a second.  Higher level layers should
 * probably let the task sleep for this amount of time after
 * calling here.  Otherwise, things might not work (because
 * sbdsp_wdsp() and sbdsp_rdsp() will probably timeout.)
 *
 * These engineers had their heads up their ass when
 * they designed this card.
 */
void
sbdsp_spkron(sc)
	struct sbdsp_softc *sc;
{
	(void)sbdsp_wdsp(sc, SB_DSP_SPKR_ON);
	sbdsp_pause(sc);
}

/*
 * Turn off the speaker; see comment above.
 */
void
sbdsp_spkroff(sc)
	struct sbdsp_softc *sc;
{
	(void)sbdsp_wdsp(sc, SB_DSP_SPKR_OFF);
	sbdsp_pause(sc);
}

/*
 * Read the version number out of the card.
 * Store version information in the softc.
 */
void
sbversion(sc)
	struct sbdsp_softc *sc;
{
	int v;

	sc->sc_model = SB_UNK;
	sc->sc_version = 0;
	if (sbdsp_wdsp(sc, SB_DSP_VERSION) < 0)
		return;
	v = sbdsp_rdsp(sc) << 8;
	v |= sbdsp_rdsp(sc);
	if (v < 0)
		return;
	sc->sc_version = v;
	switch(SBVER_MAJOR(v)) {
	case 1:
		sc->sc_mixer_model = SBM_NONE;
		sc->sc_model = SB_1;
		break;
	case 2:
		/* Some SB2 have a mixer, some don't. */
		sbdsp_mix_write(sc, SBP_1335_MASTER_VOL, 0x04);
		sbdsp_mix_write(sc, SBP_1335_MIDI_VOL,   0x06);
		/* Check if we can read back the mixer values. */
		if ((sbdsp_mix_read(sc, SBP_1335_MASTER_VOL) & 0x0e) == 0x04 &&
		    (sbdsp_mix_read(sc, SBP_1335_MIDI_VOL)   & 0x0e) == 0x06)
			sc->sc_mixer_model = SBM_CT1335;
		else
			sc->sc_mixer_model = SBM_NONE;
		if (SBVER_MINOR(v) == 0)
			sc->sc_model = SB_20;
		else
			sc->sc_model = SB_2x;
		break;
	case 3:
		sc->sc_mixer_model = SBM_CT1345;
		sc->sc_model = SB_PRO;
		break;
	case 4:
#if 0
/* XXX This does not work */
		/* Most SB16 have a tone controls, but some don't. */
		sbdsp_mix_write(sc, SB16P_TREBLE_L, 0x80);
		/* Check if we can read back the mixer value. */
		if ((sbdsp_mix_read(sc, SB16P_TREBLE_L) & 0xf0) == 0x80)
			sc->sc_mixer_model = SBM_CT1745;
		else
			sc->sc_mixer_model = SBM_CT1XX5;
#else
		sc->sc_mixer_model = SBM_CT1745;
#endif
#if 0
/* XXX figure out a good way of determining the model */
		/* XXX what about SB_32 */
		if (SBVER_MINOR(v) == 16)
			sc->sc_model = SB_64;
		else
#endif
			sc->sc_model = SB_16;
		break;
	}
}

/*
 * Halt a DMA in progress.
 */
int
sbdsp_haltdma(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;

	DPRINTF(("sbdsp_haltdma: sc=%p\n", sc));

	mtx_enter(&audio_lock);
	sbdsp_reset(sc);
	mtx_leave(&audio_lock);
	return 0;
}

int
sbdsp_set_timeconst(sc, tc)
	struct sbdsp_softc *sc;
	int tc;
{
	DPRINTF(("sbdsp_set_timeconst: sc=%p tc=%d\n", sc, tc));

	if (sbdsp_wdsp(sc, SB_DSP_TIMECONST) < 0 ||
	    sbdsp_wdsp(sc, tc) < 0)
		return EIO;

	return 0;
}

int
sbdsp16_set_rate(sc, cmd, rate)
	struct sbdsp_softc *sc;
	int cmd, rate;
{
	DPRINTF(("sbdsp16_set_rate: sc=%p cmd=0x%02x rate=%d\n", sc, cmd, rate));

	if (sbdsp_wdsp(sc, cmd) < 0 ||
	    sbdsp_wdsp(sc, rate >> 8) < 0 ||
	    sbdsp_wdsp(sc, rate) < 0)
		return EIO;
	return 0;
}

int
sbdsp_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct sbdsp_softc *sc = addr;
	int stereo = param->channels == 2;
	int width = param->precision;
	int filter;
	int rc;

#ifdef DIAGNOSTIC
	if (stereo && (blksize & 1)) {
		DPRINTF(("stereo record odd bytes (%d)\n", blksize));
		return (EIO);
	}
#endif

	sc->sc_intrr = intr;
	sc->sc_argr = arg;

	if (width == 8) {
#ifdef DIAGNOSTIC
		if (sc->sc_i.dmachan != sc->sc_drq8) {
			printf("sbdsp_trigger_input: width=%d bad chan %d\n",
			    width, sc->sc_i.dmachan);			
			return (EIO);
		}
#endif
		sc->sc_intr8 = sbdsp_block_input;
		sc->sc_arg8 = addr;
	} else {
#ifdef DIAGNOSTIC
		if (sc->sc_i.dmachan != sc->sc_drq16) {
			printf("sbdsp_trigger_input: width=%d bad chan %d\n",
			    width, sc->sc_i.dmachan);
			return (EIO);
		}
#endif
		sc->sc_intr16 = sbdsp_block_input;
		sc->sc_arg16 = addr;
	}

	if ((sc->sc_model == SB_JAZZ) ? (sc->sc_i.dmachan > 3) : (width == 16))
		blksize >>= 1;
	--blksize;
	sc->sc_i.blksize = blksize;

	if (ISSBPRO(sc)) {
		if (sbdsp_wdsp(sc, sc->sc_i.modep->cmdchan) < 0)
			return (EIO);
		filter = stereo ? SBP_FILTER_OFF : sc->in_filter;
		sbdsp_mix_write(sc, SBP_INFILTER,
		    (sbdsp_mix_read(sc, SBP_INFILTER) & ~SBP_IFILTER_MASK) |
		    filter);
	}

	if (ISSB16CLASS(sc)) {
		if (sbdsp16_set_rate(sc, SB_DSP16_INPUTRATE, sc->sc_i.rate)) {
			DPRINTF(("sbdsp_trigger_input: rate=%d set failed\n",
				 sc->sc_i.rate));
			return (EIO);
		}
	} else {
		if (sbdsp_set_timeconst(sc, sc->sc_i.tc)) {
			DPRINTF(("sbdsp_trigger_input: tc=%d set failed\n",
				 sc->sc_i.rate));
			return (EIO);
		}
	}

	DPRINTF(("sbdsp: dma start loop input start=%p end=%p chan=%d\n",
	    start, end, sc->sc_i.dmachan));
	mtx_enter(&audio_lock);
	isa_dmastart(sc->sc_isa, sc->sc_i.dmachan, start, (char *)end -
	    (char *)start, NULL, DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);
	rc = sbdsp_block_input(addr);
	mtx_leave(&audio_lock);
	return rc;
}

int
sbdsp_block_input(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;
	int cc = sc->sc_i.blksize;

	DPRINTFN(2, ("sbdsp_block_input: sc=%p cc=%d\n", addr, cc));

	if (sc->sc_i.run != SB_NOTRUNNING)
		sc->sc_intrr(sc->sc_argr);

	if (sc->sc_model == SB_1) {
		/* Non-looping mode, start DMA */
		if (sbdsp_wdsp(sc, sc->sc_i.modep->cmd) < 0 ||
		    sbdsp_wdsp(sc, cc) < 0 ||
		    sbdsp_wdsp(sc, cc >> 8) < 0) {
			DPRINTF(("sbdsp_block_input: SB1 DMA start failed\n"));
			return (EIO);
		}
		sc->sc_i.run = SB_RUNNING;
	} else if (sc->sc_i.run == SB_NOTRUNNING) {
		/* Initialize looping PCM */
		if (ISSB16CLASS(sc)) {
			DPRINTFN(3, ("sbdsp16 input command cmd=0x%02x bmode=0x%02x cc=%d\n",
			    sc->sc_i.modep->cmd, sc->sc_i.bmode, cc));
			if (sbdsp_wdsp(sc, sc->sc_i.modep->cmd) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_i.bmode) < 0 ||
			    sbdsp_wdsp(sc, cc) < 0 ||
			    sbdsp_wdsp(sc, cc >> 8) < 0) {
				DPRINTF(("sbdsp_block_input: SB16 DMA start failed\n"));
				return (EIO);
			}
		} else {
			DPRINTF(("sbdsp_block_input: set blocksize=%d\n", cc));
			if (sbdsp_wdsp(sc, SB_DSP_BLOCKSIZE) < 0 ||
			    sbdsp_wdsp(sc, cc) < 0 ||
			    sbdsp_wdsp(sc, cc >> 8) < 0) {
				DPRINTF(("sbdsp_block_input: SB2 DMA blocksize failed\n"));
				return (EIO);
			}
			if (sbdsp_wdsp(sc, sc->sc_i.modep->cmd) < 0) {
				DPRINTF(("sbdsp_block_input: SB2 DMA start failed\n"));
				return (EIO);
			}
		}
		sc->sc_i.run = SB_LOOPING;
	}

	return (0);
}

int
sbdsp_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
{
	struct sbdsp_softc *sc = addr;
	int stereo = param->channels == 2;
	int width = param->precision;
	int cmd;
	int rc;

#ifdef DIAGNOSTIC
	if (stereo && (blksize & 1)) {
		DPRINTF(("stereo playback odd bytes (%d)\n", blksize));
		return (EIO);
	}
#endif

	sc->sc_intrp = intr;
	sc->sc_argp = arg;

	if (width == 8) {
#ifdef DIAGNOSTIC
		if (sc->sc_o.dmachan != sc->sc_drq8) {
			printf("sbdsp_trigger_output: width=%d bad chan %d\n",
			    width, sc->sc_o.dmachan);
			return (EIO);
		}
#endif
		sc->sc_intr8 = sbdsp_block_output;
		sc->sc_arg8 = addr;
	} else {
#ifdef DIAGNOSTIC
		if (sc->sc_o.dmachan != sc->sc_drq16) {
			printf("sbdsp_trigger_output: width=%d bad chan %d\n",
			    width, sc->sc_o.dmachan);
			return (EIO);
		}
#endif
		sc->sc_intr16 = sbdsp_block_output;
		sc->sc_arg16 = addr;
	}

	if ((sc->sc_model == SB_JAZZ) ? (sc->sc_o.dmachan > 3) : (width == 16))
		blksize >>= 1;
	--blksize;
	sc->sc_o.blksize = blksize;

	if (ISSBPRO(sc)) {
		/* make sure we re-set stereo mixer bit when we start output. */
		sbdsp_mix_write(sc, SBP_STEREO,
		    (sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK) |
		    (stereo ?  SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
		cmd = sc->sc_o.modep->cmdchan;
		if (cmd && sbdsp_wdsp(sc, cmd) < 0)
			return (EIO);
	}

	if (ISSB16CLASS(sc)) {
		if (sbdsp16_set_rate(sc, SB_DSP16_OUTPUTRATE, sc->sc_o.rate)) {
			DPRINTF(("sbdsp_trigger_output: rate=%d set failed\n",
				 sc->sc_o.rate));
			return (EIO);
		}
	} else {
		if (sbdsp_set_timeconst(sc, sc->sc_o.tc)) {
			DPRINTF(("sbdsp_trigger_output: tc=%d set failed\n",
				 sc->sc_o.rate));
			return (EIO);
		}
	}

	DPRINTF(("sbdsp: dma start loop output start=%p end=%p chan=%d\n",
	    start, end, sc->sc_o.dmachan));
	mtx_enter(&audio_lock);
	isa_dmastart(sc->sc_isa, sc->sc_o.dmachan, start, (char *)end -
	    (char *)start, NULL, DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);
	rc = sbdsp_block_output(addr);
	mtx_leave(&audio_lock);
	return rc;
}

int
sbdsp_block_output(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;
	int cc = sc->sc_o.blksize;

	DPRINTFN(2, ("sbdsp_block_output: sc=%p cc=%d\n", addr, cc));

	if (sc->sc_o.run != SB_NOTRUNNING)
		sc->sc_intrp(sc->sc_argp);

	if (sc->sc_model == SB_1) {
		/* Non-looping mode, initialized. Start DMA and PCM */
		if (sbdsp_wdsp(sc, sc->sc_o.modep->cmd) < 0 ||
		    sbdsp_wdsp(sc, cc) < 0 ||
		    sbdsp_wdsp(sc, cc >> 8) < 0) {
			DPRINTF(("sbdsp_block_output: SB1 DMA start failed\n"));
			return (EIO);
		}
		sc->sc_o.run = SB_RUNNING;
	} else if (sc->sc_o.run == SB_NOTRUNNING) {
		/* Initialize looping PCM */
		if (ISSB16CLASS(sc)) {
			DPRINTF(("sbdsp_block_output: SB16 cmd=0x%02x bmode=0x%02x cc=%d\n",
			    sc->sc_o.modep->cmd,sc->sc_o.bmode, cc));
			if (sbdsp_wdsp(sc, sc->sc_o.modep->cmd) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_o.bmode) < 0 ||
			    sbdsp_wdsp(sc, cc) < 0 ||
			    sbdsp_wdsp(sc, cc >> 8) < 0) {
				DPRINTF(("sbdsp_block_output: SB16 DMA start failed\n"));
				return (EIO);
			}
		} else {
			DPRINTF(("sbdsp_block_output: set blocksize=%d\n", cc));
			if (sbdsp_wdsp(sc, SB_DSP_BLOCKSIZE) < 0 ||
			    sbdsp_wdsp(sc, cc) < 0 ||
			    sbdsp_wdsp(sc, cc >> 8) < 0) {
				DPRINTF(("sbdsp_block_output: SB2 DMA blocksize failed\n"));
				return (EIO);
			}
			if (sbdsp_wdsp(sc, sc->sc_o.modep->cmd) < 0) {
				DPRINTF(("sbdsp_block_output: SB2 DMA start failed\n"));
				return (EIO);
			}
		}
		sc->sc_o.run = SB_LOOPING;
	}

	return (0);
}

/*
 * Only the DSP unit on the sound blaster generates interrupts.
 * There are three cases of interrupt: reception of a midi byte
 * (when mode is enabled), completion of dma transmission, or
 * completion of a dma reception.
 *
 * If there is interrupt sharing or a spurious interrupt occurs
 * there is no way to distinguish this on an SB2.  So if you have
 * an SB2 and experience problems, buy an SB16 (it's only $40).
 */
int
sbdsp_intr(arg)
	void *arg;
{
	struct sbdsp_softc *sc = arg;
	u_char irq;

	mtx_enter(&audio_lock);
	DPRINTFN(2, ("sbdsp_intr: intr8=%p, intr16=%p\n",
		   sc->sc_intr8, sc->sc_intr16));
	if (ISSB16CLASS(sc)) {		
		bus_space_write_1(sc->sc_iot, sc->sc_ioh,
		    SBP_MIXER_ADDR, SBP_IRQ_STATUS);
		delay(20);
		irq = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    SBP_MIXER_DATA);
		delay(30);
		if ((irq & (SBP_IRQ_DMA8 | SBP_IRQ_DMA16 | SBP_IRQ_MPU401)) == 0) {
			DPRINTF(("sbdsp_intr: Spurious interrupt 0x%x\n", irq));
			mtx_leave(&audio_lock);
			return 0;
		}
	} else {
		/* XXXX CHECK FOR INTERRUPT */
		irq = SBP_IRQ_DMA8;
	}

	sc->sc_interrupts++;
	delay(10);		/* XXX why? */

	/* clear interrupt */
	if (irq & SBP_IRQ_DMA8) {
		bus_space_read_1(sc->sc_iot, sc->sc_ioh, SBP_DSP_IRQACK8);
		if (sc->sc_intr8)
			sc->sc_intr8(sc->sc_arg8);
	}
	if (irq & SBP_IRQ_DMA16) {
		bus_space_read_1(sc->sc_iot, sc->sc_ioh, SBP_DSP_IRQACK16);
		if (sc->sc_intr16)
			sc->sc_intr16(sc->sc_arg16);
	}
#if NMIDI > 0
	if ((irq & SBP_IRQ_MPU401) && sc->sc_hasmpu) {
		mpu_intr(&sc->sc_mpu_sc);
	}
#endif
	mtx_leave(&audio_lock);
	return 1;
}

/* Like val & mask, but make sure the result is correctly rounded. */
#define MAXVAL 256
static int
sbdsp_adjust(val, mask)
	int val, mask;
{
	val += (MAXVAL - mask) >> 1;
	if (val >= MAXVAL)
		val = MAXVAL-1;
	return val & mask;
}

void
sbdsp_set_mixer_gain(sc, port)
	struct sbdsp_softc *sc;
	int port;
{
	int src, gain;

	switch(sc->sc_mixer_model) {
	case SBM_NONE:
		return;
	case SBM_CT1335:
		gain = SB_1335_GAIN(sc->gain[port][SB_LEFT]);
		switch(port) {
		case SB_MASTER_VOL:
			src = SBP_1335_MASTER_VOL;
			break;
		case SB_MIDI_VOL:
			src = SBP_1335_MIDI_VOL;
			break;
		case SB_CD_VOL:
			src = SBP_1335_CD_VOL;
			break;
		case SB_VOICE_VOL:
			src = SBP_1335_VOICE_VOL;
			gain = SB_1335_MASTER_GAIN(sc->gain[port][SB_LEFT]);
			break;
		default:
			return;
		}
		sbdsp_mix_write(sc, src, gain);
		break;
	case SBM_CT1345:
		gain = SB_STEREO_GAIN(sc->gain[port][SB_LEFT],
				      sc->gain[port][SB_RIGHT]);
		switch (port) {
		case SB_MIC_VOL:
			src = SBP_MIC_VOL;
			gain = SB_MIC_GAIN(sc->gain[port][SB_LEFT]);
			break;
		case SB_MASTER_VOL:
			src = SBP_MASTER_VOL;
			break;
		case SB_LINE_IN_VOL:
			src = SBP_LINE_VOL;
			break;
		case SB_VOICE_VOL:
			src = SBP_VOICE_VOL;
			break;
		case SB_MIDI_VOL:
			src = SBP_MIDI_VOL;
			break;
		case SB_CD_VOL:
			src = SBP_CD_VOL;
			break;
		default:
			return;
		}
		sbdsp_mix_write(sc, src, gain);
		break;
	case SBM_CT1XX5:
	case SBM_CT1745:
		switch (port) {
		case SB_MIC_VOL:
			src = SB16P_MIC_L;
			break;
		case SB_MASTER_VOL:
			src = SB16P_MASTER_L;
			break;
		case SB_LINE_IN_VOL:
			src = SB16P_LINE_L;
			break;
		case SB_VOICE_VOL:
			src = SB16P_VOICE_L;
			break;
		case SB_MIDI_VOL:
			src = SB16P_MIDI_L;
			break;
		case SB_CD_VOL:
			src = SB16P_CD_L;
			break;
		case SB_INPUT_GAIN:
			src = SB16P_INPUT_GAIN_L;
			break;
		case SB_OUTPUT_GAIN:
			src = SB16P_OUTPUT_GAIN_L;
			break;
		case SB_TREBLE:
			src = SB16P_TREBLE_L;
			break;
		case SB_BASS:
			src = SB16P_BASS_L;
			break;
		case SB_PCSPEAKER:
			sbdsp_mix_write(sc, SB16P_PCSPEAKER, sc->gain[port][SB_LEFT]);
			return;
		default:
			return;
		}
		sbdsp_mix_write(sc, src, sc->gain[port][SB_LEFT]);
		sbdsp_mix_write(sc, SB16P_L_TO_R(src), sc->gain[port][SB_RIGHT]);
		break;
	}
}

int
sbdsp_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
{
	struct sbdsp_softc *sc = addr;
	int lgain, rgain;
	int mask, bits;
	int lmask, rmask, lbits, rbits;
	int mute, swap;

	if (sc->sc_open == SB_OPEN_MIDI)
		return EBUSY;

	DPRINTF(("sbdsp_mixer_set_port: port=%d num_channels=%d\n", cp->dev,
	    cp->un.value.num_channels));

	if (sc->sc_mixer_model == SBM_NONE)
		return EINVAL;

	switch (cp->dev) {
	case SB_TREBLE:
	case SB_BASS:
		if (sc->sc_mixer_model == SBM_CT1345 ||
                    sc->sc_mixer_model == SBM_CT1XX5) {
			if (cp->type != AUDIO_MIXER_ENUM)
				return EINVAL;
			switch (cp->dev) {
			case SB_TREBLE:
				sbdsp_set_ifilter(addr, cp->un.ord ? SB_TREBLE : 0);
				return 0;
			case SB_BASS:
				sbdsp_set_ifilter(addr, cp->un.ord ? SB_BASS : 0);
				return 0;
			}
		}
	case SB_PCSPEAKER:
	case SB_INPUT_GAIN:
	case SB_OUTPUT_GAIN:
		if (!ISSBM1745(sc))
			return EINVAL;
	case SB_MIC_VOL:
	case SB_LINE_IN_VOL:
		if (sc->sc_mixer_model == SBM_CT1335)
			return EINVAL;
	case SB_VOICE_VOL:
	case SB_MIDI_VOL:
	case SB_CD_VOL:
	case SB_MASTER_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return EINVAL;

		/*
		 * All the mixer ports are stereo except for the microphone.
		 * If we get a single-channel gain value passed in, then we
		 * duplicate it to both left and right channels.
		 */

		switch (cp->dev) {
		case SB_MIC_VOL:
			if (cp->un.value.num_channels != 1)
				return EINVAL;

			lgain = rgain = SB_ADJUST_MIC_GAIN(sc,
			  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		case SB_PCSPEAKER:
			if (cp->un.value.num_channels != 1)
				return EINVAL;
			/* fall into */
		case SB_INPUT_GAIN:
		case SB_OUTPUT_GAIN:
			lgain = rgain = SB_ADJUST_2_GAIN(sc,
			  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		default:
			switch (cp->un.value.num_channels) {
			case 1:
				lgain = rgain = SB_ADJUST_GAIN(sc,
				  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
				break;
			case 2:
				if (sc->sc_mixer_model == SBM_CT1335)
					return EINVAL;
				lgain = SB_ADJUST_GAIN(sc,
				  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
				rgain = SB_ADJUST_GAIN(sc,
				  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
				break;
			default:
				return EINVAL;
			}
			break;
		}
		sc->gain[cp->dev][SB_LEFT]  = lgain;
		sc->gain[cp->dev][SB_RIGHT] = rgain;

		sbdsp_set_mixer_gain(sc, cp->dev);
		break;

	case SB_RECORD_SOURCE:
		if (ISSBM1745(sc)) {
			if (cp->type != AUDIO_MIXER_SET)
				return EINVAL;
			return sbdsp_set_in_ports(sc, cp->un.mask);
		} else {
			if (cp->type != AUDIO_MIXER_ENUM)
				return EINVAL;
			sc->in_port = cp->un.ord;
			return sbdsp_set_in_ports(sc, 1 << cp->un.ord);
		}
		break;

	case SB_AGC:
		if (!ISSBM1745(sc) || cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;
		sbdsp_mix_write(sc, SB16P_AGC, cp->un.ord & 1);
		break;

	case SB_CD_OUT_MUTE:
		mask = SB16P_SW_CD;
		goto omute;
	case SB_MIC_OUT_MUTE:
		mask = SB16P_SW_MIC;
		goto omute;
	case SB_LINE_OUT_MUTE:
		mask = SB16P_SW_LINE;
	omute:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;
		bits = sbdsp_mix_read(sc, SB16P_OSWITCH);
		sc->gain[cp->dev][SB_LR] = cp->un.ord != 0;
		if (cp->un.ord)
			bits = bits & ~mask;
		else
			bits = bits | mask;
		sbdsp_mix_write(sc, SB16P_OSWITCH, bits);
		break;

	case SB_MIC_IN_MUTE:
	case SB_MIC_SWAP:
		lmask = rmask = SB16P_SW_MIC;
		goto imute;
	case SB_CD_IN_MUTE:
	case SB_CD_SWAP:
		lmask = SB16P_SW_CD_L;
		rmask = SB16P_SW_CD_R;
		goto imute;
	case SB_LINE_IN_MUTE:
	case SB_LINE_SWAP:
		lmask = SB16P_SW_LINE_L;
		rmask = SB16P_SW_LINE_R;
		goto imute;
	case SB_MIDI_IN_MUTE:
	case SB_MIDI_SWAP:
		lmask = SB16P_SW_MIDI_L;
		rmask = SB16P_SW_MIDI_R;
	imute:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;
		mask = lmask | rmask;
		lbits = sbdsp_mix_read(sc, SB16P_ISWITCH_L) & ~mask;
		rbits = sbdsp_mix_read(sc, SB16P_ISWITCH_R) & ~mask;
		sc->gain[cp->dev][SB_LR] = cp->un.ord != 0;
		if (SB_IS_IN_MUTE(cp->dev)) {
			mute = cp->dev;
			swap = mute - SB_CD_IN_MUTE + SB_CD_SWAP;
		} else {
			swap = cp->dev;
			mute = swap + SB_CD_IN_MUTE - SB_CD_SWAP;
		}
		if (sc->gain[swap][SB_LR]) {
			mask = lmask;
			lmask = rmask;
			rmask = mask;
		}
		if (!sc->gain[mute][SB_LR]) {
			lbits = lbits | lmask;
			rbits = rbits | rmask;
		}
		sbdsp_mix_write(sc, SB16P_ISWITCH_L, lbits);
		sbdsp_mix_write(sc, SB16P_ISWITCH_L, rbits);
		break;

	default:
		return EINVAL;
	}

	return 0;
}

int
sbdsp_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
{
	struct sbdsp_softc *sc = addr;

	if (sc->sc_open == SB_OPEN_MIDI)
		return EBUSY;

	DPRINTF(("sbdsp_mixer_get_port: port=%d\n", cp->dev));

	if (sc->sc_mixer_model == SBM_NONE)
		return EINVAL;

	switch (cp->dev) {
	case SB_TREBLE:
	case SB_BASS:
		if (sc->sc_mixer_model == SBM_CT1345 ||
                    sc->sc_mixer_model == SBM_CT1XX5) {
			switch (cp->dev) {
			case SB_TREBLE:
				cp->un.ord = sbdsp_get_ifilter(addr) == SB_TREBLE;
				return 0;
			case SB_BASS:
				cp->un.ord = sbdsp_get_ifilter(addr) == SB_BASS;
				return 0;
			}
		}
	case SB_PCSPEAKER:
	case SB_INPUT_GAIN:
	case SB_OUTPUT_GAIN:
		if (!ISSBM1745(sc))
			return EINVAL;
	case SB_MIC_VOL:
	case SB_LINE_IN_VOL:
		if (sc->sc_mixer_model == SBM_CT1335)
			return EINVAL;
	case SB_VOICE_VOL:
	case SB_MIDI_VOL:
	case SB_CD_VOL:
	case SB_MASTER_VOL:
		switch (cp->dev) {
		case SB_MIC_VOL:
		case SB_PCSPEAKER:
			if (cp->un.value.num_channels != 1)
				return EINVAL;
			/* fall into */
		default:
			switch (cp->un.value.num_channels) {
			case 1:
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
					sc->gain[cp->dev][SB_LEFT];
				break;
			case 2:
				cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
					sc->gain[cp->dev][SB_LEFT];
				cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
					sc->gain[cp->dev][SB_RIGHT];
				break;
			default:
				return EINVAL;
			}
			break;
		}
		break;

	case SB_RECORD_SOURCE:
		if (ISSBM1745(sc))
			cp->un.mask = sc->in_mask;
		else
			cp->un.ord = sc->in_port;
		break;

	case SB_AGC:
		if (!ISSBM1745(sc))
			return EINVAL;
		cp->un.ord = sbdsp_mix_read(sc, SB16P_AGC);
		break;

	case SB_CD_IN_MUTE:
	case SB_MIC_IN_MUTE:
	case SB_LINE_IN_MUTE:
	case SB_MIDI_IN_MUTE:
	case SB_CD_SWAP:
	case SB_MIC_SWAP:
	case SB_LINE_SWAP:
	case SB_MIDI_SWAP:
	case SB_CD_OUT_MUTE:
	case SB_MIC_OUT_MUTE:
	case SB_LINE_OUT_MUTE:
		cp->un.ord = sc->gain[cp->dev][SB_LR];
		break;

	default:
		return EINVAL;
	}

	return 0;
}

int
sbdsp_mixer_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
{
	struct sbdsp_softc *sc = addr;
	int chan, class, is1745;

	DPRINTF(("sbdsp_mixer_query_devinfo: model=%d index=%d\n",
		 sc->sc_mixer_model, dip->index));

	if (dip->index < 0)
		return ENXIO;

	if (sc->sc_mixer_model == SBM_NONE)
		return ENXIO;

	chan = sc->sc_mixer_model == SBM_CT1335 ? 1 : 2;
	is1745 = ISSBM1745(sc);
	class = is1745 ? SB_INPUT_CLASS : SB_OUTPUT_CLASS;

	switch (dip->index) {
	case SB_MASTER_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SB_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = chan;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;
	case SB_MIDI_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = class;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = is1745 ? SB_MIDI_IN_MUTE : AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth, sizeof dip->label.name);
		dip->un.v.num_channels = chan;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;
	case SB_CD_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = class;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = is1745 ? SB_CD_IN_MUTE : AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->un.v.num_channels = chan;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;
	case SB_VOICE_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = class;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->un.v.num_channels = chan;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;
	case SB_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SB_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		return 0;
	}

	if (sc->sc_mixer_model == SBM_CT1335)
		return ENXIO;

	switch (dip->index) {
	case SB_MIC_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = class;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = is1745 ? SB_MIC_IN_MUTE : AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;

	case SB_LINE_IN_VOL:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = class;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = is1745 ? SB_LINE_IN_MUTE : AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;

	case SB_RECORD_SOURCE:
		dip->mixer_class = SB_RECORD_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		if (ISSBM1745(sc)) {
			dip->type = AUDIO_MIXER_SET;
			dip->un.s.num_mem = 4;
			strlcpy(dip->un.s.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.s.member[0].label.name);
			dip->un.s.member[0].mask = 1 << SB_MIC_VOL;
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNcd, sizeof dip->un.s.member[1].label.name);
			dip->un.s.member[1].mask = 1 << SB_CD_VOL;
			strlcpy(dip->un.s.member[2].label.name,
			    AudioNline, sizeof dip->un.s.member[2].label.name);
			dip->un.s.member[2].mask = 1 << SB_LINE_IN_VOL;
			strlcpy(dip->un.s.member[3].label.name,
			    AudioNfmsynth,
			    sizeof dip->un.s.member[3].label.name);
			dip->un.s.member[3].mask = 1 << SB_MIDI_VOL;
		} else {
			dip->type = AUDIO_MIXER_ENUM;
			dip->un.e.num_mem = 3;
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
			dip->un.e.member[0].ord = SB_MIC_VOL;
			strlcpy(dip->un.e.member[1].label.name, AudioNcd,
			    sizeof dip->un.e.member[1].label.name);
			dip->un.e.member[1].ord = SB_CD_VOL;
			strlcpy(dip->un.e.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
			dip->un.e.member[2].ord = SB_LINE_IN_VOL;
		}
		return 0;

	case SB_BASS:
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
		if (sc->sc_mixer_model == SBM_CT1745) {
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_EQUALIZATION_CLASS;
			dip->un.v.num_channels = 2;
			strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
		} else {
			dip->type = AUDIO_MIXER_ENUM;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->un.e.num_mem = 2;
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
			dip->un.e.member[0].ord = 0;
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
			dip->un.e.member[1].ord = 1;
		}
		return 0;

	case SB_TREBLE:
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
		if (sc->sc_mixer_model == SBM_CT1745) {
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_EQUALIZATION_CLASS;
			dip->un.v.num_channels = 2;
			strlcpy(dip->un.v.units.name, AudioNtreble, sizeof dip->un.v.units.name);
		} else {
			dip->type = AUDIO_MIXER_ENUM;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->un.e.num_mem = 2;
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
			dip->un.e.member[0].ord = 0;
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
			dip->un.e.member[1].ord = 1;
		}
		return 0;

	case SB_RECORD_CLASS:			/* record source class */
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SB_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		return 0;

	case SB_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SB_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		return 0;

	}

	if (sc->sc_mixer_model == SBM_CT1345)
		return ENXIO;

	switch(dip->index) {
	case SB_PCSPEAKER:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SB_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;

	case SB_INPUT_GAIN:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SB_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;

	case SB_OUTPUT_GAIN:
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = SB_OUTPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
		return 0;

	case SB_AGC:
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = SB_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return 0;

	case SB_EQUALIZATION_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SB_EQUALIZATION_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCequalization, sizeof dip->label.name);
		return 0;

	case SB_CD_IN_MUTE:
		dip->prev = SB_CD_VOL;
		dip->next = SB_CD_SWAP;
		dip->mixer_class = SB_INPUT_CLASS;
		goto mute;

	case SB_MIC_IN_MUTE:
		dip->prev = SB_MIC_VOL;
		dip->next = SB_MIC_SWAP;
		dip->mixer_class = SB_INPUT_CLASS;
		goto mute;

	case SB_LINE_IN_MUTE:
		dip->prev = SB_LINE_IN_VOL;
		dip->next = SB_LINE_SWAP;
		dip->mixer_class = SB_INPUT_CLASS;
		goto mute;

	case SB_MIDI_IN_MUTE:
		dip->prev = SB_MIDI_VOL;
		dip->next = SB_MIDI_SWAP;
		dip->mixer_class = SB_INPUT_CLASS;
		goto mute;

	case SB_CD_SWAP:
		dip->prev = SB_CD_IN_MUTE;
		dip->next = SB_CD_OUT_MUTE;
		goto swap;

	case SB_MIC_SWAP:
		dip->prev = SB_MIC_IN_MUTE;
		dip->next = SB_MIC_OUT_MUTE;
		goto swap;

	case SB_LINE_SWAP:
		dip->prev = SB_LINE_IN_MUTE;
		dip->next = SB_LINE_OUT_MUTE;
		goto swap;

	case SB_MIDI_SWAP:
		dip->prev = SB_MIDI_IN_MUTE;
		dip->next = AUDIO_MIXER_LAST;
	swap:
		dip->mixer_class = SB_INPUT_CLASS;
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
		goto mute1;

	case SB_CD_OUT_MUTE:
		dip->prev = SB_CD_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = SB_OUTPUT_CLASS;
		goto mute;

	case SB_MIC_OUT_MUTE:
		dip->prev = SB_MIC_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = SB_OUTPUT_CLASS;
		goto mute;

	case SB_LINE_OUT_MUTE:
		dip->prev = SB_LINE_SWAP;
		dip->next = AUDIO_MIXER_LAST;
		dip->mixer_class = SB_OUTPUT_CLASS;
	mute:
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
	mute1:
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return 0;

	}

	return ENXIO;
}

void *
sb_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool;
	int flags;
{
	struct sbdsp_softc *sc = addr;
	int drq;

	/* 8-bit has more restrictive alignment */
	if (sc->sc_drq8 != -1)
		drq = sc->sc_drq8;
	else
		drq = sc->sc_drq16;

	return isa_malloc(sc->sc_isa, drq, size, pool, flags);
}

void
sb_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
{
	isa_free(ptr, pool);
}

size_t
sb_round(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
{
	if (size > MAX_ISADMA)
		size = MAX_ISADMA;
	return size;
}

int
sbdsp_get_props(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;
	return AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT |
	       (sc->sc_fullduplex ? AUDIO_PROP_FULLDUPLEX : 0);
}

#if NMIDI > 0
/*
 * MIDI related routines.
 */

int
sbdsp_midi_open(addr, flags, iintr, ointr, arg)
	void *addr;
	int flags;
	void (*iintr)(void *, int);
	void (*ointr)(void *);
	void *arg;
{
	struct sbdsp_softc *sc = addr;

        DPRINTF(("sbdsp_midi_open: sc=%p\n", sc));

	if (sc->sc_open != SB_CLOSED)
		return EBUSY;
	if (sbdsp_reset(sc) != 0)
		return EIO;

	if (sc->sc_model >= SB_20)
		if (sbdsp_wdsp(sc, SB_MIDI_UART_INTR)) /* enter UART mode */
			return EIO;
	sc->sc_open = SB_OPEN_MIDI;
	sc->sc_openflags = flags;
	sc->sc_intr8 = sbdsp_midi_intr;
	sc->sc_arg8 = addr;
	sc->sc_intrm = iintr;
	sc->sc_argm = arg;
	return 0;
}

void
sbdsp_midi_close(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;

        DPRINTF(("sbdsp_midi_close: sc=%p\n", sc));

	if (sc->sc_model >= SB_20)
		sbdsp_reset(sc); /* exit UART mode */
	sc->sc_open = SB_CLOSED;
	sc->sc_intrm = 0;
}

int
sbdsp_midi_output(addr, d)
	void *addr;
	int d;
{
	struct sbdsp_softc *sc = addr;

	if (sc->sc_model < SB_20 && sbdsp_wdsp(sc, SB_MIDI_WRITE))
		return 1;
	(void)sbdsp_wdsp(sc, d);
	return 1;
}

void
sbdsp_midi_getinfo(addr, mi)
	void *addr;
	struct midi_info *mi;
{
	struct sbdsp_softc *sc = addr;

	mi->name = sc->sc_model < SB_20 ? "SB MIDI cmd" : "SB MIDI UART";
	mi->props = MIDI_PROP_CAN_INPUT;
}

int
sbdsp_midi_intr(addr)
	void *addr;
{
	struct sbdsp_softc *sc = addr;

	sc->sc_intrm(sc->sc_argm, sbdsp_rdsp(sc));
	return (0);
}

#endif
@


1.36
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@a446 80
sbdsp_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
{
	struct sbdsp_softc *sc = addr;
	int emul, found = 0;

	emul = ISSB16CLASS(sc) ? 0 : AUDIO_ENCODINGFLAG_EMULATED;

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		found = 1;
		break;
	case 1:
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		found = 1;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		found = 1;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = emul;
		found = 1;
		break;
        }
	if (found) {
		fp->bps = 1;
		fp->msb = 1;
		return 0;
	} else if (!ISSB16CLASS(sc) && sc->sc_model != SB_JAZZ)
		return EINVAL;

        switch(fp->index) {
        case 4:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = emul;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	default:
		return EINVAL;
	}
	fp->bps = 2;
	fp->msb = 1;
	return 0;
}

int
a2182 10
}

paddr_t
sb_mappage(addr, mem, off, prot)
	void *addr;
        void *mem;
        off_t off;
	int prot;
{
	return isa_mappage(mem, off, prot);
@


1.35
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.34 2014/09/14 14:17:25 jsg Exp $	*/
d173 3
d354 2
a355 2
	pparams = audio_default;
	rparams = audio_default;
@


1.34
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.33 2013/05/15 08:29:24 ratchov Exp $	*/
a63 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a531 2
	void (*swcode)(void *, u_char *buf, int cnt);
	int factor;
a631 2
		swcode = 0;
		factor = 1;
d638 1
a638 1
					swcode = swap_bytes;
d645 1
a645 1
					swcode = swap_bytes;
a649 18
			case AUDIO_ENCODING_ULAW:
				if (mode == AUMODE_PLAY) {
					swcode = mulaw_to_ulinear16_le;
					factor = 2;
					m = &sbpmodes[PLAY16];
				} else
					swcode = ulinear8_to_mulaw;
				bmode = SB_BMODE_UNSIGNED;
				break;
			case AUDIO_ENCODING_ALAW:
				if (mode == AUMODE_PLAY) {
					swcode = alaw_to_ulinear16_le;
					factor = 2;
					m = &sbpmodes[PLAY16];
				} else
					swcode = ulinear8_to_alaw;
				bmode = SB_BMODE_UNSIGNED;
				break;
a658 18
			case AUDIO_ENCODING_ULINEAR_LE:
				swcode = change_sign16_le;
				break;
			case AUDIO_ENCODING_SLINEAR_BE:
				swcode = swap_bytes;
				break;
			case AUDIO_ENCODING_ULINEAR_BE:
				swcode = mode == AUMODE_PLAY ?
					swap_bytes_change_sign16_le : change_sign16_swap_bytes_le;
				break;
			case AUDIO_ENCODING_ULAW:
				swcode = mode == AUMODE_PLAY ?
					mulaw_to_ulinear8 : ulinear8_to_mulaw;
				break;
			case AUDIO_ENCODING_ALAW:
				swcode = mode == AUMODE_PLAY ?
					alaw_to_ulinear8 : ulinear8_to_alaw;
				break;
a665 4
			case AUDIO_ENCODING_SLINEAR_BE:
			case AUDIO_ENCODING_SLINEAR_LE:
				swcode = change_sign8;
				break;
a668 8
			case AUDIO_ENCODING_ULAW:
				swcode = mode == AUMODE_PLAY ?
					mulaw_to_ulinear8 : ulinear8_to_mulaw;
				break;
			case AUDIO_ENCODING_ALAW:
				swcode = mode == AUMODE_PLAY ?
					alaw_to_ulinear8 : ulinear8_to_alaw;
				break;
a690 2
		p->sw_code = swcode;
		p->factor = factor;
d693 1
a693 1
		DPRINTF(("sbdsp_set_params: model=%d, mode=%d, rate=%ld, prec=%d, chan=%d, enc=%d -> tc=%02x, cmd=%02x, bmode=%02x, cmdchan=%02x, swcode=%p, factor=%d\n",
d695 1
a695 1
			 p->encoding, tc, m->cmd, bmode, m->cmdchan, swcode, factor));
d710 1
a710 9
		if (sc->sc_o.dmachan == sc->sc_drq8) {
			/* Use 16 bit DMA for playing by expanding the samples. */
			play->sw_code = linear8_to_linear16_le;
			play->factor = 2;
			sc->sc_o.modep = &sbpmodes[PLAY16];
			sc->sc_o.dmachan = sc->sc_drq16;
		} else {
			return EINVAL;
		}
d1172 1
a1172 1
	int width = param->precision * param->factor;
d1309 1
a1309 1
	int width = param->precision * param->factor;
@


1.33
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.32 2012/03/30 08:18:19 ratchov Exp $	*/
a54 1
#include <sys/proc.h>
@


1.32
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.31 2010/07/15 03:43:11 jakemsr Exp $	*/
a414 1
	int s;
d416 1
a416 1
	s = splaudio();
d421 1
a421 1
	splx(s);
a431 1
	int s;
d433 1
a433 1
	s = splaudio();
d438 1
a438 1
	splx(s);
d1192 1
d1194 1
d1239 1
d1255 1
a1255 1
			    width, sc->sc_i.dmachan);
d1303 1
d1306 3
a1308 2

	return sbdsp_block_input(addr);
d1376 1
d1441 1
d1444 3
a1446 2

	return sbdsp_block_output(addr);
d1518 1
d1521 7
a1527 2
	if (ISSB16CLASS(sc)) {
		irq = sbdsp_mix_read(sc, SBP_IRQ_STATUS);
d1530 1
d1557 1
@


1.31
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.30 2010/04/03 23:22:42 jakemsr Exp $	*/
d2388 3
a2390 4
		return EIO;
	if (sbdsp_wdsp(sc, d))
		return EIO;
	return 0;
@


1.30
log
@instead of returning EINVAL if an unsupported sample rate was
requested, just use a supported sample rate.  makes paramter
negotiation much easier.  problem noted and patch tested on
several sb(4) devices by J.C Roberts, thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.29 2009/07/31 22:53:04 sthen Exp $	*/
d454 1
a454 1
	int emul;
d464 2
a465 1
		return 0;
d471 2
a472 1
		return 0;
d478 2
a479 1
		return 0;
d485 6
d492 1
a492 2
        }
        if (!ISSB16CLASS(sc) && sc->sc_model != SB_JAZZ)
d501 1
a501 1
		return 0;
d507 1
a507 1
		return 0;
d513 1
a513 1
		return 0;
d519 1
a519 1
		return 0;
d523 2
d750 2
@


1.29
log
@remove unused variable definition; unbreaks kernel build.
"do it" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.28 2009/07/31 20:43:31 blambert Exp $	*/
d565 51
@


1.28
log
@timeout_add -> timeout_add_msec

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.27 2008/01/14 01:25:50 jakemsr Exp $	*/
a1018 2
	extern int hz;

@


1.27
log
@return earlier if the device index is negative

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.26 2007/11/05 00:17:28 jakemsr Exp $	*/
d1021 1
a1021 1
	timeout_add(&sc->sc_tmo, hz/8);
@


1.26
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.25 2006/12/29 13:04:37 pedro Exp $	*/
d1904 3
@


1.25
log
@Avoid void * arithmetic, okay deraadt@@, suggestions from millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.24 2005/04/15 13:05:14 mickey Exp $	*/
d600 1
a600 1
					swcode = mulaw_to_ulinear16;
d609 1
a609 1
					swcode = alaw_to_ulinear16;
d626 1
a626 1
				swcode = change_sign16;
d633 1
a633 1
					swap_bytes_change_sign16 : change_sign16_swap_bytes;
d708 1
a708 1
			play->sw_code = linear8_to_linear16;
@


1.24
log
@make sure aligment does not return zero block size
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.23 2004/01/09 21:32:24 brad Exp $	*/
d1241 2
a1242 2
	isa_dmastart(sc->sc_isa, sc->sc_i.dmachan, start, end - start,
	    NULL, DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);
d1376 2
a1377 2
	isa_dmastart(sc->sc_isa, sc->sc_o.dmachan, start, end - start,
	    NULL, DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);
@


1.23
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.22 2003/04/27 11:22:53 ho Exp $	*/
d854 1
a854 1
	return blk & -4;	/* round to biggest sample size */
@


1.22
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.21 2002/03/14 01:26:56 millert Exp $	*/
a56 1
#include <uvm/uvm_extern.h>
@


1.21
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.20 2002/02/12 22:31:01 fgsch Exp $	*/
d461 1
a461 1
		strcpy(fp->name, AudioEulinear);
d467 1
a467 1
		strcpy(fp->name, AudioEmulaw);
d473 1
a473 1
		strcpy(fp->name, AudioEalaw);
d479 1
a479 1
		strcpy(fp->name, AudioEslinear);
d490 1
a490 1
		strcpy(fp->name, AudioEslinear_le);
d496 1
a496 1
		strcpy(fp->name, AudioEulinear_le);
d502 1
a502 1
		strcpy(fp->name, AudioEslinear_be);
d508 1
a508 1
		strcpy(fp->name, AudioEulinear_be);
d1918 1
a1918 1
		strcpy(dip->label.name, AudioNmaster);
d1920 1
a1920 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1927 1
a1927 1
		strcpy(dip->label.name, AudioNfmsynth);
d1929 1
a1929 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1936 1
a1936 1
		strcpy(dip->label.name, AudioNcd);
d1938 1
a1938 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1945 1
a1945 1
		strcpy(dip->label.name, AudioNdac);
d1947 1
a1947 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1953 1
a1953 1
		strcpy(dip->label.name, AudioCoutputs);
d1966 2
a1967 1
		strcpy(dip->label.name, AudioNmicrophone);
d1969 1
a1969 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1977 1
a1977 1
		strcpy(dip->label.name, AudioNline);
d1979 1
a1979 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1985 1
a1985 1
		strcpy(dip->label.name, AudioNsource);
d1989 3
a1991 1
			strcpy(dip->un.s.member[0].label.name, AudioNmicrophone);
d1993 2
a1994 1
			strcpy(dip->un.s.member[1].label.name, AudioNcd);
d1996 2
a1997 1
			strcpy(dip->un.s.member[2].label.name, AudioNline);
d1999 3
a2001 1
			strcpy(dip->un.s.member[3].label.name, AudioNfmsynth);
d2006 3
a2008 1
			strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d2010 2
a2011 1
			strcpy(dip->un.e.member[1].label.name, AudioNcd);
d2013 2
a2014 1
			strcpy(dip->un.e.member[2].label.name, AudioNline);
d2021 1
a2021 1
		strcpy(dip->label.name, AudioNbass);
d2026 1
a2026 1
			strcpy(dip->un.v.units.name, AudioNbass);
d2031 2
a2032 1
			strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2034 2
a2035 1
			strcpy(dip->un.e.member[1].label.name, AudioNon);
d2042 1
a2042 1
		strcpy(dip->label.name, AudioNtreble);
d2047 1
a2047 1
			strcpy(dip->un.v.units.name, AudioNtreble);
d2052 2
a2053 1
			strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2055 2
a2056 1
			strcpy(dip->un.e.member[1].label.name, AudioNon);
d2065 1
a2065 1
		strcpy(dip->label.name, AudioCrecord);
d2072 1
a2072 1
		strcpy(dip->label.name, AudioCinputs);
d2085 1
a2085 1
		strcpy(dip->label.name, "pc_speaker");
d2087 1
a2087 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2094 1
a2094 1
		strcpy(dip->label.name, AudioNinput);
d2096 1
a2096 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2103 1
a2103 1
		strcpy(dip->label.name, AudioNoutput);
d2105 1
a2105 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2112 1
a2112 1
		strcpy(dip->label.name, "agc");
d2114 2
a2115 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2117 2
a2118 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d2126 1
a2126 1
		strcpy(dip->label.name, AudioCequalization);
d2173 1
a2173 1
		strcpy(dip->label.name, AudioNswap);
d2193 1
a2193 1
		strcpy(dip->label.name, AudioNmute);
d2197 2
a2198 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2200 2
a2201 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
@


1.20
log
@accept sample rates <= highrate.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.19 2002/01/20 19:56:53 ericj Exp $	*/
d177 14
a190 14
void	sbversion __P((struct sbdsp_softc *));
void	sbdsp_jazz16_probe __P((struct sbdsp_softc *));
void	sbdsp_set_mixer_gain __P((struct sbdsp_softc *sc, int port));
void	sbdsp_to __P((void *));
void	sbdsp_pause __P((struct sbdsp_softc *));
int	sbdsp_set_timeconst __P((struct sbdsp_softc *, int));
int	sbdsp16_set_rate __P((struct sbdsp_softc *, int, int));
int	sbdsp_set_in_ports __P((struct sbdsp_softc *, int));
void	sbdsp_set_ifilter __P((void *, int));
int	sbdsp_get_ifilter __P((void *));

int	sbdsp_block_output __P((void *));
int	sbdsp_block_input __P((void *));
static	int sbdsp_adjust __P((int, int));
d192 1
a192 1
int	sbdsp_midi_intr __P((void *));
d195 1
a195 1
void	sb_printsc __P((struct sbdsp_softc *));
d528 1
a528 1
	void (*swcode) __P((void *, u_char *buf, int cnt));
d1171 1
a1171 1
	void (*intr) __P((void *));
d1305 1
a1305 1
	void (*intr) __P((void *));
d2259 2
a2260 2
	void (*iintr)__P((void *, int));
	void (*ointr)__P((void *));
@


1.19
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.18 2001/11/06 19:53:19 miod Exp $	*/
d573 1
a573 1
			    p->sample_rate < m->highrate)
@


1.18
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.17 2001/10/31 11:00:24 art Exp $	*/
d2192 1
a2192 1
sb_malloc(addr, size, pool, flags)
d2194 2
a2195 1
	unsigned long size;
d2220 2
a2221 2
unsigned long
sb_round(addr, size)
d2223 2
a2224 1
	unsigned long size;
@


1.18.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.19 2002/01/20 19:56:53 ericj Exp $	*/
d2192 1
a2192 1
sb_malloc(addr, direction, size, pool, flags)
d2194 1
a2194 2
	int direction;
	size_t size;
d2219 2
a2220 2
size_t
sb_round(addr, direction, size)
d2222 1
a2222 2
	int direction;
	size_t size;
@


1.18.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.18.2.1 2002/01/31 22:55:33 niklas Exp $	*/
d177 14
a190 14
void	sbversion(struct sbdsp_softc *);
void	sbdsp_jazz16_probe(struct sbdsp_softc *);
void	sbdsp_set_mixer_gain(struct sbdsp_softc *sc, int port);
void	sbdsp_to(void *);
void	sbdsp_pause(struct sbdsp_softc *);
int	sbdsp_set_timeconst(struct sbdsp_softc *, int);
int	sbdsp16_set_rate(struct sbdsp_softc *, int, int);
int	sbdsp_set_in_ports(struct sbdsp_softc *, int);
void	sbdsp_set_ifilter(void *, int);
int	sbdsp_get_ifilter(void *);

int	sbdsp_block_output(void *);
int	sbdsp_block_input(void *);
static	int sbdsp_adjust(int, int);
d192 1
a192 1
int	sbdsp_midi_intr(void *);
d195 1
a195 1
void	sb_printsc(struct sbdsp_softc *);
d528 1
a528 1
	void (*swcode)(void *, u_char *buf, int cnt);
d573 1
a573 1
			    p->sample_rate <= m->highrate)
d1171 1
a1171 1
	void (*intr)(void *);
d1305 1
a1305 1
	void (*intr)(void *);
d2259 2
a2260 2
	void (*iintr)(void *, int);
	void (*ointr)(void *);
@


1.18.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d461 1
a461 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d467 1
a467 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d473 1
a473 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d479 1
a479 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d490 1
a490 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d496 1
a496 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d502 1
a502 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d508 1
a508 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1918 1
a1918 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1920 1
a1920 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1927 1
a1927 1
		strlcpy(dip->label.name, AudioNfmsynth, sizeof dip->label.name);
d1929 1
a1929 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1936 1
a1936 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1938 1
a1938 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1945 1
a1945 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1947 1
a1947 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1953 1
a1953 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1966 1
a1966 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1968 1
a1968 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1976 1
a1976 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1978 1
a1978 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1984 1
a1984 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1988 1
a1988 3
			strlcpy(dip->un.s.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.s.member[0].label.name);
d1990 1
a1990 2
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNcd, sizeof dip->un.s.member[1].label.name);
d1992 1
a1992 2
			strlcpy(dip->un.s.member[2].label.name,
			    AudioNline, sizeof dip->un.s.member[2].label.name);
d1994 1
a1994 3
			strlcpy(dip->un.s.member[3].label.name,
			    AudioNfmsynth,
			    sizeof dip->un.s.member[3].label.name);
d1999 1
a1999 3
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
d2001 1
a2001 2
			strlcpy(dip->un.e.member[1].label.name, AudioNcd,
			    sizeof dip->un.e.member[1].label.name);
d2003 1
a2003 2
			strlcpy(dip->un.e.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
d2010 1
a2010 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d2015 1
a2015 1
			strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
d2020 1
a2020 2
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
d2022 1
a2022 2
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
d2029 1
a2029 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d2034 1
a2034 1
			strlcpy(dip->un.v.units.name, AudioNtreble, sizeof dip->un.v.units.name);
d2039 1
a2039 2
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
d2041 1
a2041 2
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
d2050 1
a2050 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d2057 1
a2057 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d2070 1
a2070 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d2072 1
a2072 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2079 1
a2079 1
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
d2081 1
a2081 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2088 1
a2088 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d2090 1
a2090 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2097 1
a2097 1
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
d2099 1
a2099 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2101 1
a2101 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d2109 1
a2109 1
		strlcpy(dip->label.name, AudioCequalization, sizeof dip->label.name);
d2156 1
a2156 1
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
d2176 1
a2176 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d2180 1
a2180 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2182 1
a2182 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.17
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.16 2001/04/12 07:46:46 csapuntz Exp $	*/
d57 1
a57 1
#include <vm/vm.h>
@


1.16
log
@

The old code was broken and always allocated for a 16-bit DMA channel,
which has different alignment restrictions than the 8-bit DMA channel.

Fix from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.15 2001/02/03 05:22:24 mickey Exp $	*/
d2229 1
a2229 1
int
d2233 1
a2233 1
        int off;
@


1.15
log
@new timeouts, space control
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.14 1999/07/20 16:36:05 deraadt Exp $	*/
d2199 1
d2201 7
a2207 1
	return isa_malloc(sc->sc_isa, 4, size, pool, flags);
@


1.14
log
@first cut at isapnp and ym mpu
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.13 1999/01/02 00:02:47 niklas Exp $	*/
d106 1
a106 1
 * 	(65536 - 256 * 10 ^ 6 / x) >> 8 = 256 - 10^6 / x
d202 1
a202 1
    
d204 1
a204 1
	    (int)sc->sc_open, sc->sc_i.run, sc->sc_o.run, 
d362 1
a362 1
        	/* Reset the mixer.*/
d402 2
a403 1
	sc->sc_fullduplex = ISSB16CLASS(sc) && 
d539 1
a539 1
	if (model > SB_16) 
d560 1
a560 1
	for (mode = AUMODE_RECORD; mode != -1; 
d567 1
a567 1
		for(m = mode == AUMODE_PLAY ? sbpmodes : sbrmodes; 
d572 1
a572 1
			    p->sample_rate >= m->lowrate && 
d637 1
a637 1
				swcode = mode == AUMODE_PLAY ? 
d641 1
a641 1
				swcode = mode == AUMODE_PLAY ? 
d659 1
a659 1
				swcode = mode == AUMODE_PLAY ? 
d663 1
a663 1
				swcode = mode == AUMODE_PLAY ? 
d690 1
a690 1
		DPRINTF(("sbdsp_set_params: model=%d, mode=%d, rate=%ld, prec=%d, chan=%d, enc=%d -> tc=%02x, cmd=%02x, bmode=%02x, cmdchan=%02x, swcode=%p, factor=%d\n", 
d717 1
a717 1
	DPRINTF(("sbdsp_set_params ichan=%d, ochan=%d\n", 
d740 1
a740 1
		mixval |= SBP_FILTER_ON | SBP_IFILTER_LOW; 
d754 1
a754 1
	
d1022 1
a1022 1
	timeout(sbdsp_to, sbdsp_to, hz/8);
d1148 1
a1148 1
	    
d1225 1
a1225 1
	
d1240 1
a1240 1
	DPRINTF(("sbdsp: dma start loop input start=%p end=%p chan=%d\n", 
d1254 1
a1254 1
	
d1274 1
a1274 1
			if (sbdsp_wdsp(sc, sc->sc_i.modep->cmd) < 0 || 
d1360 1
a1360 1
	
d1389 1
a1389 1
	
d1407 1
a1407 1
			DPRINTF(("sbdsp_block_output: SB16 cmd=0x%02x bmode=0x%02x cc=%d\n", 
d1409 1
a1409 1
			if (sbdsp_wdsp(sc, sc->sc_o.modep->cmd) < 0 || 
d1438 1
a1438 1
 * (when mode is enabled), completion of dma transmission, or 
d1613 1
a1613 1
    
d1666 1
a1666 1
			lgain = rgain = SB_ADJUST_MIC_GAIN(sc, 
d1675 1
a1675 1
			lgain = rgain = SB_ADJUST_2_GAIN(sc, 
d1681 1
a1681 1
				lgain = rgain = SB_ADJUST_GAIN(sc, 
d1687 1
a1687 1
				lgain = SB_ADJUST_GAIN(sc, 
d1689 1
a1689 1
				rgain = SB_ADJUST_GAIN(sc, 
d1800 1
a1800 1
    
d1845 1
a1845 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
d1849 1
a1849 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 
d1851 1
a1851 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 
d1903 1
a1903 1
	DPRINTF(("sbdsp_mixer_query_devinfo: model=%d index=%d\n", 
d2026 1
a2026 1
		
d2045 1
a2045 1
		
@


1.14.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.16 2001/04/12 07:46:46 csapuntz Exp $	*/
d106 1
a106 1
 *	(65536 - 256 * 10 ^ 6 / x) >> 8 = 256 - 10^6 / x
d202 1
a202 1

d204 1
a204 1
	    (int)sc->sc_open, sc->sc_i.run, sc->sc_o.run,
d362 1
a362 1
		/* Reset the mixer.*/
d402 1
a402 2
	timeout_set(&sc->sc_tmo, sbdsp_to, sbdsp_to);
	sc->sc_fullduplex = ISSB16CLASS(sc) &&
d538 1
a538 1
	if (model > SB_16)
d559 1
a559 1
	for (mode = AUMODE_RECORD; mode != -1;
d566 1
a566 1
		for(m = mode == AUMODE_PLAY ? sbpmodes : sbrmodes;
d571 1
a571 1
			    p->sample_rate >= m->lowrate &&
d636 1
a636 1
				swcode = mode == AUMODE_PLAY ?
d640 1
a640 1
				swcode = mode == AUMODE_PLAY ?
d658 1
a658 1
				swcode = mode == AUMODE_PLAY ?
d662 1
a662 1
				swcode = mode == AUMODE_PLAY ?
d689 1
a689 1
		DPRINTF(("sbdsp_set_params: model=%d, mode=%d, rate=%ld, prec=%d, chan=%d, enc=%d -> tc=%02x, cmd=%02x, bmode=%02x, cmdchan=%02x, swcode=%p, factor=%d\n",
d716 1
a716 1
	DPRINTF(("sbdsp_set_params ichan=%d, ochan=%d\n",
d739 1
a739 1
		mixval |= SBP_FILTER_ON | SBP_IFILTER_LOW;
d753 1
a753 1

d1021 1
a1021 1
	timeout_add(&sc->sc_tmo, hz/8);
d1147 1
a1147 1

d1224 1
a1224 1

d1239 1
a1239 1
	DPRINTF(("sbdsp: dma start loop input start=%p end=%p chan=%d\n",
d1253 1
a1253 1

d1273 1
a1273 1
			if (sbdsp_wdsp(sc, sc->sc_i.modep->cmd) < 0 ||
d1359 1
a1359 1

d1388 1
a1388 1

d1406 1
a1406 1
			DPRINTF(("sbdsp_block_output: SB16 cmd=0x%02x bmode=0x%02x cc=%d\n",
d1408 1
a1408 1
			if (sbdsp_wdsp(sc, sc->sc_o.modep->cmd) < 0 ||
d1437 1
a1437 1
 * (when mode is enabled), completion of dma transmission, or
d1612 1
a1612 1

d1665 1
a1665 1
			lgain = rgain = SB_ADJUST_MIC_GAIN(sc,
d1674 1
a1674 1
			lgain = rgain = SB_ADJUST_2_GAIN(sc,
d1680 1
a1680 1
				lgain = rgain = SB_ADJUST_GAIN(sc,
d1686 1
a1686 1
				lgain = SB_ADJUST_GAIN(sc,
d1688 1
a1688 1
				rgain = SB_ADJUST_GAIN(sc,
d1799 1
a1799 1

d1844 1
a1844 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
d1848 1
a1848 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
d1850 1
a1850 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
d1902 1
a1902 1
	DPRINTF(("sbdsp_mixer_query_devinfo: model=%d index=%d\n",
d2025 1
a2025 1

d2044 1
a2044 1

a2197 7
	int drq;

	/* 8-bit has more restrictive alignment */
	if (sc->sc_drq8 != -1)
		drq = sc->sc_drq8;
	else
		drq = sc->sc_drq16;
d2199 1
a2199 1
	return isa_malloc(sc->sc_isa, drq, size, pool, flags);
@


1.14.4.2
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
a57 1
#include <uvm/uvm_extern.h>
d2229 1
a2229 1
paddr_t
d2233 1
a2233 1
        off_t off;
@


1.14.4.3
log
@Merge in trunk
@
text
@d573 1
a573 1
			    p->sample_rate <= m->highrate)
d2192 1
a2192 1
sb_malloc(addr, direction, size, pool, flags)
d2194 1
a2194 2
	int direction;
	size_t size;
d2219 2
a2220 2
size_t
sb_round(addr, direction, size)
d2222 1
a2222 2
	int direction;
	size_t size;
@


1.14.4.4
log
@Merge in -current from about a week ago
@
text
@d177 14
a190 14
void	sbversion(struct sbdsp_softc *);
void	sbdsp_jazz16_probe(struct sbdsp_softc *);
void	sbdsp_set_mixer_gain(struct sbdsp_softc *sc, int port);
void	sbdsp_to(void *);
void	sbdsp_pause(struct sbdsp_softc *);
int	sbdsp_set_timeconst(struct sbdsp_softc *, int);
int	sbdsp16_set_rate(struct sbdsp_softc *, int, int);
int	sbdsp_set_in_ports(struct sbdsp_softc *, int);
void	sbdsp_set_ifilter(void *, int);
int	sbdsp_get_ifilter(void *);

int	sbdsp_block_output(void *);
int	sbdsp_block_input(void *);
static	int sbdsp_adjust(int, int);
d192 1
a192 1
int	sbdsp_midi_intr(void *);
d195 1
a195 1
void	sb_printsc(struct sbdsp_softc *);
d528 1
a528 1
	void (*swcode)(void *, u_char *buf, int cnt);
d1171 1
a1171 1
	void (*intr)(void *);
d1305 1
a1305 1
	void (*intr)(void *);
d2259 2
a2260 2
	void (*iintr)(void *, int);
	void (*ointr)(void *);
@


1.14.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.14.4.4 2002/03/28 12:11:36 niklas Exp $	*/
d461 1
a461 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d467 1
a467 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d473 1
a473 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d479 1
a479 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d490 1
a490 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d496 1
a496 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d502 1
a502 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d508 1
a508 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1918 1
a1918 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1920 1
a1920 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1927 1
a1927 1
		strlcpy(dip->label.name, AudioNfmsynth, sizeof dip->label.name);
d1929 1
a1929 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1936 1
a1936 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1938 1
a1938 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1945 1
a1945 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1947 1
a1947 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1953 1
a1953 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d1966 1
a1966 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1968 1
a1968 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1976 1
a1976 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1978 1
a1978 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d1984 1
a1984 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d1988 1
a1988 3
			strlcpy(dip->un.s.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.s.member[0].label.name);
d1990 1
a1990 2
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNcd, sizeof dip->un.s.member[1].label.name);
d1992 1
a1992 2
			strlcpy(dip->un.s.member[2].label.name,
			    AudioNline, sizeof dip->un.s.member[2].label.name);
d1994 1
a1994 3
			strlcpy(dip->un.s.member[3].label.name,
			    AudioNfmsynth,
			    sizeof dip->un.s.member[3].label.name);
d1999 1
a1999 3
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
d2001 1
a2001 2
			strlcpy(dip->un.e.member[1].label.name, AudioNcd,
			    sizeof dip->un.e.member[1].label.name);
d2003 1
a2003 2
			strlcpy(dip->un.e.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
d2010 1
a2010 1
		strlcpy(dip->label.name, AudioNbass, sizeof dip->label.name);
d2015 1
a2015 1
			strlcpy(dip->un.v.units.name, AudioNbass, sizeof dip->un.v.units.name);
d2020 1
a2020 2
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
d2022 1
a2022 2
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
d2029 1
a2029 1
		strlcpy(dip->label.name, AudioNtreble, sizeof dip->label.name);
d2034 1
a2034 1
			strlcpy(dip->un.v.units.name, AudioNtreble, sizeof dip->un.v.units.name);
d2039 1
a2039 2
			strlcpy(dip->un.e.member[0].label.name, AudioNoff,
			    sizeof dip->un.e.member[0].label.name);
d2041 1
a2041 2
			strlcpy(dip->un.e.member[1].label.name, AudioNon,
			    sizeof dip->un.e.member[1].label.name);
d2050 1
a2050 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d2057 1
a2057 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d2070 1
a2070 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d2072 1
a2072 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2079 1
a2079 1
		strlcpy(dip->label.name, AudioNinput, sizeof dip->label.name);
d2081 1
a2081 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2088 1
a2088 1
		strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d2090 1
a2090 1
		strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d2097 1
a2097 1
		strlcpy(dip->label.name, "agc", sizeof dip->label.name);
d2099 1
a2099 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2101 1
a2101 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d2109 1
a2109 1
		strlcpy(dip->label.name, AudioCequalization, sizeof dip->label.name);
d2156 1
a2156 1
		strlcpy(dip->label.name, AudioNswap, sizeof dip->label.name);
d2176 1
a2176 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d2180 1
a2180 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2182 1
a2182 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.14.4.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d57 1
@


1.13
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.12 1998/04/26 21:02:59 provos Exp $	*/
d1480 1
a1480 1
		mpu401_intr(&sc->sc_mpu_sc);
@


1.12
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 2
/*	$OpenBSD: sbdsp.c,v 1.11 1998/01/18 18:58:39 niklas Exp $	*/
/*	$NetBSD: sbdsp.c,v 1.78 1998/01/30 11:55:36 bouyer Exp $	*/
d47 2
d65 1
d75 1
d78 1
d82 1
d188 2
a189 2
static	int sbdsp_dma_setup_input __P((struct sbdsp_softc *sc));
static	int sbdsp_dma_setup_output __P((struct sbdsp_softc *sc));
d192 2
d195 1
a195 1
void sb_printsc __P((struct sbdsp_softc *));
d534 3
d541 17
d559 2
a560 2
	for(mode = AUMODE_RECORD; mode != -1; 
	    mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
d694 1
d703 1
a703 1
	    (usemode & (AUMODE_PLAY | AUMODE_RECORD)) == (AUMODE_PLAY | AUMODE_RECORD) &&
d705 1
a705 1
		DPRINTF(("sbdsp_commit: fd=%d, usemode=%d, idma=%d, odma=%d\n", sc->sc_fullduplex, usemode, sc->sc_i.dmachan, sc->sc_o.dmachan));
d716 2
a717 1
	DPRINTF(("sbdsp_set_params ichan=%d, ochan=%d\n", sc->sc_i.dmachan, sc->sc_o.dmachan));
d774 3
a820 1

d833 3
d854 1
a854 2
	blk &= -4;		/* round to biggest sample size */
	return blk;
d866 4
a869 2
	if (sc->sc_open != 0 || sbdsp_reset(sc) != 0)
		return ENXIO;
d871 1
a871 1
	sc->sc_open = 1;
d873 1
a873 1
	sc->sc_mintr = 0;
d899 1
a899 1
	sc->sc_open = 0;
d904 1
a904 1
	sc->sc_mintr = 0;
d1117 1
a1117 1
		sc->sc_model = SB_16;
d1166 1
a1166 1
sbdsp_dma_init_input(addr, buf, cc)
d1168 5
a1172 2
	void *buf;
	int cc;
d1175 13
d1189 21
a1209 9
	if (sc->sc_model == SB_1)
		return 0;
	sc->sc_i.run = SB_DMARUNNING;
	DPRINTF(("sbdsp: dma start loop input addr=%p cc=%d chan=%d\n", 
		 buf, cc, sc->sc_i.dmachan));
	isa_dmastart(sc->sc_isa, sc->sc_i.dmachan, buf,
		     cc, NULL, DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);
	return 0;
}
d1211 4
a1214 6
static int
sbdsp_dma_setup_input(sc)
	struct sbdsp_softc *sc;
{
	int stereo = sc->sc_i.modep->channels == 2;
	int filter;
a1215 1
	/* Initialize the PCM */
d1218 1
a1218 1
			return 0;
d1221 2
a1222 2
				(sbdsp_mix_read(sc, SBP_INFILTER) &
				 ~SBP_IFILTER_MASK) | filter);
d1226 2
a1227 3
		if (sbdsp16_set_rate(sc, SB_DSP16_INPUTRATE, 
				     sc->sc_i.rate)) {
			DPRINTF(("sbdsp_dma_setup_input: rate=%d set failed\n",
d1229 1
a1229 1
			return 0;
d1233 1
a1233 1
			DPRINTF(("sbdsp_dma_setup_input: tc=%d set failed\n",
d1235 1
a1235 1
			return 0;
d1238 7
a1244 1
	return 1;
d1248 1
a1248 1
sbdsp_dma_input(addr, p, cc, intr, arg)
a1249 4
	void *p;
	int cc;
	void (*intr) __P((void *));
	void *arg;
d1252 1
d1254 4
a1257 11
#ifdef AUDIO_DEBUG
	if (sbdspdebug > 1)
		printf("sbdsp_dma_input: sc=%p buf=%p cc=%d intr=%p(%p)\n", 
		       addr, p, cc, intr, arg);
#endif
#ifdef DIAGNOSTIC
	if (sc->sc_i.modep->channels == 2 && (cc & 1)) {
		DPRINTF(("stereo record odd bytes (%d)\n", cc));
		return EIO;
	}
#endif
d1259 1
a1259 30
	if (sc->sc_i.modep->precision == 8) {
#ifdef DIAGNOSTIC
		if (sc->sc_i.dmachan != sc->sc_drq8) {
			printf("sbdsp_dma_input: prec=%d bad chan %d\n",
			       sc->sc_i.modep->precision, sc->sc_i.dmachan);
			return EIO;
		}
#endif
		sc->sc_intr8 = intr;
		sc->sc_arg8 = arg;
	} else {
#ifdef DIAGNOSTIC
		if (sc->sc_i.dmachan != sc->sc_drq16) {
			printf("sbdsp_dma_input: prec=%d bad chan %d\n",
			       sc->sc_i.modep->precision, sc->sc_i.dmachan);
			return EIO;
		}
#endif
		sc->sc_intr16 = intr;
		sc->sc_arg16 = arg;
	}
		
	switch(sc->sc_i.run) {
	case SB_NOTRUNNING:
		/* Non-looping mode, not initialized */
		sc->sc_i.run = SB_RUNNING;
		if (!sbdsp_dma_setup_input(sc))
			goto giveup;
		/* fall into */
	case SB_RUNNING:
a1260 13
#ifdef AUDIO_DEBUG
		if (sbdspdebug > 2)
			printf("sbdsp_dma_input: dmastart buf=%p cc=%d chan=%d\n", 
			       p, cc, sc->sc_i.dmachan);
#endif
		isa_dmastart(sc->sc_isa, sc->sc_i.dmachan, p,
			     cc, NULL, DMAMODE_READ, BUS_DMA_NOWAIT);

		/* Start PCM in non-looping mode */
		if ((sc->sc_model == SB_JAZZ && sc->sc_i.dmachan > 3) ||
		    (sc->sc_model != SB_JAZZ && sc->sc_i.modep->precision == 16))
			cc >>= 1;
		--cc;
d1264 2
a1265 2
			DPRINTF(("sbdsp_dma_input: SB1 DMA start failed\n"));
			goto giveup;
d1267 2
a1268 10
		break;
	case SB_DMARUNNING:
		/* Looping mode, not initialized */
		sc->sc_i.run = SB_PCMRUNNING;
		if (!sbdsp_dma_setup_input(sc))
			goto giveup;
		if ((sc->sc_model == SB_JAZZ && sc->sc_i.dmachan > 3) ||
		    (sc->sc_model != SB_JAZZ && sc->sc_i.modep->precision == 16))
			cc >>= 1;
		--cc;
d1271 2
a1272 5
#ifdef AUDIO_DEBUG
			if (sbdspdebug > 2)
				printf("sbdsp16 input command cmd=0x%02x bmode=0x%02x cc=%d\n",
				       sc->sc_i.modep->cmd, sc->sc_i.bmode, cc);
#endif
d1277 2
a1278 4
				DPRINTF(("sbdsp_dma_input: SB16 DMA start failed\n"));
				DPRINTF(("sbdsp16 input command cmd=0x%02x bmode=0x%02x cc=%d\n",
					 sc->sc_i.modep->cmd, sc->sc_i.bmode, cc));
				goto giveup;
d1281 1
a1281 1
			DPRINTF(("sbdsp_dma_input: set blocksize=%d\n", cc));
d1285 2
a1286 2
				DPRINTF(("sbdsp_dma_input: SB2 DMA blocksize failed\n"));
				goto giveup;
d1289 2
a1290 2
				DPRINTF(("sbdsp_dma_input: SB2 DMA start failed\n"));
				goto giveup;
d1293 1
a1293 4
		break;
	case SB_PCMRUNNING:
		/* Looping mode, nothing to do */
		break;
a1294 1
	return 0;
d1296 1
a1296 3
giveup:
	sbdsp_reset(sc);
	return EIO;
d1300 1
a1300 1
sbdsp_dma_init_output(addr, buf, cc)
d1302 5
a1306 2
	void *buf;
	int cc;
d1309 13
d1323 21
a1343 9
	if (sc->sc_model == SB_1)
		return 0;
	sc->sc_o.run = SB_DMARUNNING;
	DPRINTF(("sbdsp: dma start loop output buf=%p cc=%d chan=%d\n",
		 buf, cc, sc->sc_o.dmachan));
	isa_dmastart(sc->sc_isa, sc->sc_o.dmachan, buf,
		     cc, NULL, DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);
	return 0;
}
d1345 4
a1348 6
static int
sbdsp_dma_setup_output(sc)
	struct sbdsp_softc *sc;
{
	int stereo = sc->sc_o.modep->channels == 2;
	int cmd;
d1353 2
a1354 2
				(sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK) |
				(stereo ?  SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
d1357 1
a1357 1
			return 0;
d1361 2
a1362 3
		if (sbdsp16_set_rate(sc, SB_DSP16_OUTPUTRATE,
				     sc->sc_o.rate)) {
			DPRINTF(("sbdsp_dma_setup_output: rate=%d set failed\n",
d1364 1
a1364 1
			return 0;
d1368 1
a1368 1
			DPRINTF(("sbdsp_dma_setup_output: tc=%d set failed\n",
d1370 1
a1370 1
			return 0;
d1373 7
a1379 1
	return 1;
d1383 1
a1383 1
sbdsp_dma_output(addr, p, cc, intr, arg)
a1384 4
	void *p;
	int cc;
	void (*intr) __P((void *));
	void *arg;
d1387 1
d1389 1
a1389 10
#ifdef AUDIO_DEBUG
	if (sbdspdebug > 1)
		printf("sbdsp_dma_output: sc=%p buf=%p cc=%d intr=%p(%p)\n", addr, p, cc, intr, arg);
#endif
#ifdef DIAGNOSTIC
	if (sc->sc_o.modep->channels == 2 && (cc & 1)) {
		DPRINTF(("stereo playback odd bytes (%d)\n", cc));
		return EIO;
	}
#endif
d1391 2
a1392 21
	if (sc->sc_o.modep->precision == 8) {
#ifdef DIAGNOSTIC
		if (sc->sc_o.dmachan != sc->sc_drq8) {
			printf("sbdsp_dma_output: prec=%d bad chan %d\n",
			       sc->sc_o.modep->precision, sc->sc_o.dmachan);
			return EIO;
		}
#endif
		sc->sc_intr8 = intr;
		sc->sc_arg8 = arg;
	} else {
#ifdef DIAGNOSTIC
		if (sc->sc_o.dmachan != sc->sc_drq16) {
			printf("sbdsp_dma_output: prec=%d bad chan %d\n",
			       sc->sc_o.modep->precision, sc->sc_o.dmachan);
			return EIO;
		}
#endif
		sc->sc_intr16 = intr;
		sc->sc_arg16 = arg;
	}
d1394 1
a1394 8
	switch(sc->sc_o.run) {
	case SB_NOTRUNNING:
		/* Non-looping mode, not initialized */
		sc->sc_o.run = SB_RUNNING;
		if (!sbdsp_dma_setup_output(sc))
			goto giveup;
		/* fall into */
	case SB_RUNNING:
a1395 11
#ifdef AUDIO_DEBUG
		if (sbdspdebug > 2)
			printf("sbdsp: start dma out addr=%p, cc=%d, chan=%d\n",
			       p, cc, sc->sc_o.dmachan);
#endif
		isa_dmastart(sc->sc_isa, sc->sc_o.dmachan, p,
			     cc, NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);
		if ((sc->sc_model == SB_JAZZ && sc->sc_o.dmachan > 3) ||
		    (sc->sc_model != SB_JAZZ && sc->sc_o.modep->precision == 16))
			cc >>= 1;
		--cc;
d1399 2
a1400 2
			DPRINTF(("sbdsp_dma_output: SB1 DMA start failed\n"));
			goto giveup;
d1402 2
a1403 10
		break;
	case SB_DMARUNNING:
		/* Looping mode, not initialized */
		sc->sc_o.run = SB_PCMRUNNING;
		if (!sbdsp_dma_setup_output(sc))
			goto giveup;
		if ((sc->sc_model == SB_JAZZ && sc->sc_o.dmachan > 3) ||
		    (sc->sc_model != SB_JAZZ && sc->sc_o.modep->precision == 16))
			cc >>= 1;
		--cc;
d1406 2
a1407 2
			DPRINTF(("sbdsp_dma_output: SB16 cmd=0x%02x bmode=0x%02x cc=%d\n", 
				 sc->sc_o.modep->cmd,sc->sc_o.bmode, cc));
d1412 2
a1413 2
				DPRINTF(("sbdsp_dma_output: SB16 DMA start failed\n"));
				goto giveup;
d1416 1
a1416 1
			DPRINTF(("sbdsp_dma_output: set blocksize=%d\n", cc));
d1420 2
a1421 2
				DPRINTF(("sbdsp_dma_output: SB2 DMA blocksize failed\n"));
				goto giveup;
d1424 2
a1425 2
				DPRINTF(("sbdsp_dma_output: SB2 DMA start failed\n"));
				goto giveup;
d1428 1
a1428 4
		break;
	case SB_PCMRUNNING:
		/* Looping mode, nothing to do */
		break;
a1429 1
	return 0;
d1431 1
a1431 3
giveup:
	sbdsp_reset(sc);
	return EIO;
a1448 1
	int loop = sc->sc_model != SB_1;
d1451 2
a1452 5
#ifdef AUDIO_DEBUG
	if (sbdspdebug > 1)
		printf("sbdsp_intr: intr8=%p, intr16=%p\n",
		       sc->sc_intr8, sc->sc_intr16);
#endif
d1455 1
a1455 1
		if ((irq & (SBP_IRQ_DMA8 | SBP_IRQ_DMA16)) == 0) {
d1460 1
a1460 2
		if (!loop && !isa_dmafinished(sc->sc_isa, sc->sc_drq8))
			return 0;
d1463 1
a1465 10
#if 0
	if (sc->sc_mintr != 0) {
		x = sbdsp_rdsp(sc);
		(*sc->sc_mintr)(sc->sc_arg, x);
	} else
#endif
	if (sc->sc_intr8 == 0 && sc->sc_intr16 == 0) {
		DPRINTF(("sbdsp_intr: Unexpected interrupt 0x%x\n", irq));
		/* XXX return 0;*/	/* Did not expect an interrupt */
	}
a1469 2
		if (!loop)
			isa_dmadone(sc->sc_isa, sc->sc_drq8);
d1471 1
a1471 1
			(*sc->sc_intr8)(sc->sc_arg8);
d1476 1
a1476 1
			(*sc->sc_intr16)(sc->sc_arg16);
d1478 5
d1486 1
a1486 40
#if 0
/*
 * Enter midi uart mode and arrange for read interrupts
 * to vector to `intr'.  This puts the card in a mode
 * which allows only midi I/O; the card must be reset
 * to leave this mode.  Unfortunately, the card does not
 * use transmit interrupts, so bytes must be output
 * using polling.  To keep the polling overhead to a
 * minimum, output should be driven off a timer.
 * This is a little tricky since only 320us separate
 * consecutive midi bytes.
 */
void
sbdsp_set_midi_mode(sc, intr, arg)
	struct sbdsp_softc *sc;
	void (*intr)();
	void *arg;
{

	sbdsp_wdsp(sc, SB_MIDI_UART_INTR);
	sc->sc_mintr = intr;
	sc->sc_intr = 0;
	sc->sc_arg = arg;
}

/*
 * Write a byte to the midi port, when in midi uart mode.
 */
void
sbdsp_midi_output(sc, v)
	struct sbdsp_softc *sc;
	int v;
{

	if (sbdsp_wdsp(sc, v) < 0)
		++sberr.wmidi;
}
#endif

/* Mask a value 0-255, but round it first */
d1613 3
d1800 3
d2096 1
a2096 1
		strcpy(dip->label.name, "AGC");
d2236 1
a2236 1
	return AUDIO_PROP_MMAP | 
d2239 85
@


1.11
log
@move to current OpenBSD isadma API
@
text
@d1 2
a2 2
/*	$OpenBSD: sbdsp.c,v 1.10 1997/07/10 23:06:38 provos Exp $	*/
/*	$NetBSD: sbdsp.c,v 1.30 1996/10/25 07:25:48 fvdl Exp $	*/
d43 3
d60 1
a60 1
#include <machine/pio.h>
d64 2
a68 1
#include <i386/isa/icu.h>			/* XXX BROKEN; WHY? */
d74 1
a74 2
extern void Dprintf __P((const char *, ...));
#define DPRINTF(x)	if (sbdspdebug) Dprintf x
a89 4
int sbdsp_srtotc __P((struct sbdsp_softc *sc, int sr, int isdac,
		      int *tcp, int *modep));
u_int sbdsp_jazz16_probe __P((struct sbdsp_softc *));

d115 60
a174 10
#define SB_LS_MIN	0x06	/* 4000 Hz */
#define	SB_8K		0x83	/* 8000 Hz */
#define SBPRO_ADC_LS_MAX	0xd4	/* 22727 Hz */
#define SBPRO_ADC_HS_MAX	0xea	/* 45454 Hz */
#define SBCLA_ADC_LS_MAX	0xb3	/* 12987 Hz */
#define SBCLA_ADC_HS_MAX	0xbd	/* 14925 Hz */
#define SB_DAC_LS_MAX	0xd4	/* 22727 Hz */
#define SB_DAC_HS_MAX	0xea	/* 45454 Hz */

int	sbdsp16_wait __P((struct sbdsp_softc *));
a176 2
int	sbdsp16_setrate __P((struct sbdsp_softc *, int, int, int *));
int	sbdsp_tctosr __P((struct sbdsp_softc *, int));
d178 8
a188 1
#endif
a189 1
#ifdef AUDIO_DEBUG
d196 14
a209 10
	printf("open %d dmachan %d/%d/%d iobase %x\n",
	    sc->sc_open, sc->dmachan, sc->sc_drq8, sc->sc_drq16, sc->sc_iobase);
	printf("irate %d itc %d imode %d orate %d otc %d omode %d encoding %x\n",
	    sc->sc_irate, sc->sc_itc, sc->sc_imode,
	    sc->sc_orate, sc->sc_otc, sc->sc_omode, sc->sc_encoding);
	printf("outport %d inport %d spkron %d nintr %lu\n",
	    sc->out_port, sc->in_port, sc->spkr_state, sc->sc_interrupts);
	printf("precision %d channels %d intr %p arg %p\n",
	    sc->sc_precision, sc->sc_channels, sc->sc_intr, sc->sc_arg);
	printf("gain: ");
d211 1
a211 1
		printf("%d ", sc->gain[i]);
d214 1
a214 1
#endif
d233 8
a240 4
	if (sc->sc_dev.dv_cfdata->cf_flags != 0) {
		sc->sc_model = sbdsp_jazz16_probe(sc);
	} else {
		sc->sc_model = sbversion(sc);
a241 1

d248 1
a248 1
u_int
a260 1
	u_int rval = sbversion(sc);
d264 2
d270 1
a270 1
		return rval;
d308 2
a309 1
		rval |= MODEL_JAZZ16;
a313 1
	return rval;
d324 23
d348 3
a350 10
	/* Set defaults */
	if (ISSB16CLASS(sc))
		sc->sc_irate = sc->sc_orate = 8000;
	else if (ISSBPROCLASS(sc))
		sc->sc_itc = sc->sc_otc = SB_8K;
  	else
		sc->sc_itc = sc->sc_otc = SB_8K;
	sc->sc_encoding = AUDIO_ENCODING_ULAW;
	sc->sc_precision = 8;
	sc->sc_channels = 1;
d352 1
a352 2
	(void) sbdsp_set_in_port(sc, SB_MIC_PORT);
	(void) sbdsp_set_out_port(sc, SB_SPEAKER);
d354 2
a355 5
	if (ISSBPROCLASS(sc)) {
		int i;
	    
		/* set mixer to default levels, by sending a mixer
                   reset command. */
d357 31
a387 11
		/* then some adjustments :) */
		sbdsp_mix_write(sc, SBP_CD_VOL,
				sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL));
		sbdsp_mix_write(sc, SBP_DAC_VOL,
				sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL));
		sbdsp_mix_write(sc, SBP_MASTER_VOL,
				sbdsp_stereo_vol(SBP_MAXVOL/2, SBP_MAXVOL/2));
		sbdsp_mix_write(sc, SBP_LINE_VOL,
				sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL));
		for (i = 0; i < SB_NDEVS; i++)
			sc->gain[i] = sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL);
d392 6
a397 2
	       SBVER_MAJOR(sc->sc_model), SBVER_MINOR(sc->sc_model),
	       ISJAZZ16(sc) ? ": <Jazz16>" : "");
a399 4
/*
 * Various routines to interface to higher level audio driver
 */

d408 1
d410 1
d412 1
a412 1
	delay(10);
d415 1
d425 2
d428 1
d430 5
a434 2
	delay(10);
	return bus_space_read_1(iot, ioh, SBP_MIXER_DATA);
d437 3
a439 24
int
sbdsp_set_in_sr(addr, sr)
	void *addr;
	u_long sr;
{
	register struct sbdsp_softc *sc = addr;

	if (ISSB16CLASS(sc))
		return (sbdsp16_setrate(sc, sr, SB_INPUT_RATE, &sc->sc_irate));
	else
		return (sbdsp_srtotc(sc, sr, SB_INPUT_RATE, &sc->sc_itc, &sc->sc_imode));
}

u_long
sbdsp_get_in_sr(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;

	if (ISSB16CLASS(sc))
		return (sc->sc_irate);
	else
		return (sbdsp_tctosr(sc, sc->sc_itc));
}
d442 1
a442 1
sbdsp_set_out_sr(addr, sr)
d444 1
a444 1
	u_long sr;
d446 2
a447 7
	register struct sbdsp_softc *sc = addr;

	if (ISSB16CLASS(sc))
		return (sbdsp16_setrate(sc, sr, SB_OUTPUT_RATE, &sc->sc_orate));
	else
		return (sbdsp_srtotc(sc, sr, SB_OUTPUT_RATE, &sc->sc_otc, &sc->sc_omode));
}
d449 1
a449 11
u_long
sbdsp_get_out_sr(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;

	if (ISSB16CLASS(sc))
		return (sc->sc_orate);
	else
		return (sbdsp_tctosr(sc, sc->sc_otc));
}
a450 5
int
sbdsp_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
{
d453 6
d460 19
a478 11
		fp->format_id = AUDIO_ENCODING_ULAW;
		break;
	case 1:
		strcpy(fp->name, AudioEpcm16);
		fp->format_id = AUDIO_ENCODING_PCM16;
		break;
	default:
		return (EINVAL);
	}
	return (0);
}
d480 25
a504 12
int
sbdsp_set_format(addr, encoding, precision)
	void *addr;
	u_int encoding, precision;
{
	register struct sbdsp_softc *sc = addr;
	
	switch (encoding) {
	case AUDIO_ENCODING_ULAW:
	case AUDIO_ENCODING_PCM16:
	case AUDIO_ENCODING_PCM8:
		break;
d506 1
a506 1
		return (EINVAL);
d508 1
a508 9

	if (precision == 16)
		if (!ISSB16CLASS(sc) && !ISJAZZ16(sc))
			return (EINVAL);

	sc->sc_encoding = encoding;
	sc->sc_precision = precision;

	return (0);
d512 1
a512 1
sbdsp_get_encoding(addr)
d514 2
d517 19
a535 1
	register struct sbdsp_softc *sc = addr;
d537 107
a643 2
	return (sc->sc_encoding);
}
d645 14
a658 5
int
sbdsp_get_precision(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;
d660 5
a664 2
	return (sc->sc_precision);
}
d666 7
a672 6
int
sbdsp_set_channels(addr, channels)
	void *addr;
	int channels;
{
	register struct sbdsp_softc *sc = addr;
d674 13
a686 14
	if (ISSBPROCLASS(sc)) {
		if (channels != 1 && channels != 2)
			return (EINVAL);
		sc->sc_channels = channels;
		sc->sc_dmadir = SB_DMA_NONE;
		/*
		 * XXXX
		 * With 2 channels, SBPro can't do more than 22kHz.
		 * No framework to check this.
		 */
	} else {
		if (channels != 1)
			return (EINVAL);
		sc->sc_channels = channels;
d688 1
a688 3
	
	return (0);
}
d690 1
a690 7
int
sbdsp_get_channels(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;
	
	return (sc->sc_channels);
d693 1
a693 1
int
d698 1
a698 1
	register struct sbdsp_softc *sc = addr;
d701 16
a716 21
	/* XXXX SB16 */
	if (ISSBPROCLASS(sc)) {
		mixval = sbdsp_mix_read(sc, SBP_INFILTER) & ~SBP_IFILTER_MASK;
		switch (which) {
		case 0:
			mixval |= SBP_FILTER_OFF;
			break;
		case SBP_TREBLE_EQ:
			mixval |= SBP_FILTER_ON | SBP_IFILTER_HIGH;
			break;
		case SBP_BASS_EQ:
			mixval |= SBP_FILTER_ON | SBP_IFILTER_LOW; 
			break;
		default:
			return (EINVAL);
		}
		sc->in_filter = mixval & SBP_IFILTER_MASK;
		sbdsp_mix_write(sc, SBP_INFILTER, mixval);
		return (0);
	} else
		return (EINVAL);
d723 1
a723 1
	register struct sbdsp_softc *sc = addr;
d725 10
a734 15
	/* XXXX SB16 */
	if (ISSBPROCLASS(sc)) {
		sc->in_filter =
		    sbdsp_mix_read(sc, SBP_INFILTER) & SBP_IFILTER_MASK;
		switch (sc->in_filter) {
		case SBP_FILTER_ON|SBP_IFILTER_HIGH:
			return (SBP_TREBLE_EQ);
		case SBP_FILTER_ON|SBP_IFILTER_LOW:
			return (SBP_BASS_EQ);
		case SBP_FILTER_OFF:
		default:
			return (0);
		}
	} else
		return (0);
d738 3
a740 3
sbdsp_set_out_port(addr, port)
	void *addr;
	int port;
d742 2
a743 3
	register struct sbdsp_softc *sc = addr;
	
	sc->out_port = port; /* Just record it */
d745 2
a746 2
	return (0);
}
d748 10
a757 21
int
sbdsp_get_out_port(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;

	return (sc->out_port);
}


int
sbdsp_set_in_port(addr, port)
	void *addr;
	int port;
{
	register struct sbdsp_softc *sc = addr;
	int mixport, sbport;
	
	if (ISSBPROCLASS(sc)) {
		switch (port) {
		case SB_MIC_PORT:
a758 1
			mixport = SBP_MIC_VOL;
d760 1
a760 1
		case SB_LINE_IN_PORT:
a761 1
			mixport = SBP_LINE_VOL;
d763 1
a763 1
		case SB_CD_PORT:
a764 1
			mixport = SBP_CD_VOL;
a765 2
		case SB_DAC_PORT:
		case SB_FM_PORT:
d769 15
a783 8
	} else {
		switch (port) {
		case SB_MIC_PORT:
			sbport = SBP_FROM_MIC;
			mixport = SBP_MIC_VOL;
			break;
		default:
			return (EINVAL);
d785 3
a787 11
	}	    

	sc->in_port = port;	/* Just record it */

	/* XXXX SB16 */
	if (ISSBPROCLASS(sc)) {
		/* record from that port */
		sbdsp_mix_write(sc, SBP_RECORD_SOURCE,
		    SBP_RECORD_FROM(sbport, SBP_FILTER_OFF, SBP_IFILTER_HIGH));
		/* fetch gain from that port */
		sc->gain[port] = sbdsp_mix_read(sc, mixport);
d790 1
a790 2
	return (0);
}
d792 1
a792 7
int
sbdsp_get_in_port(addr)
	void *addr;
{
	register struct sbdsp_softc *sc = addr;

	return (sc->in_port);
a794 1

d800 1
a800 1
	register struct sbdsp_softc *sc = addr;
d812 1
a812 1
	return(0);
d820 2
a821 12
	register struct sbdsp_softc *sc = addr;

	sc->sc_last_hs_size = 0;

	/* Don't try to DMA too much at once. */
	if (blk > NBPG)
		blk = NBPG;

	/* Round to a multiple of the sample size. */
	blk &= -(sc->sc_channels * sc->sc_precision / 8);

	return (blk);
d825 1
a825 1
sbdsp_commit_settings(addr)
d827 1
d829 1
a829 44
	register struct sbdsp_softc *sc = addr;

	/* due to potentially unfortunate ordering in the above layers,
	   re-do a few sets which may be important--input gains
	   (adjust the proper channels), number of input channels (hit the
	   record rate and set mode) */

	if (ISSBPRO(sc)) {
		/*
		 * With 2 channels, SBPro can't do more than 22kHz.
		 * Whack the rates down to speed if necessary.
		 * Reset the time constant anyway
		 * because it may have been adjusted with a different number
		 * of channels, which means it might have computed the wrong
		 * mode (low/high speed).
		 */
		if (sc->sc_channels == 2 &&
		    sbdsp_tctosr(sc, sc->sc_itc) > 22727) {
			sbdsp_srtotc(sc, 22727, SB_INPUT_RATE,
				     &sc->sc_itc, &sc->sc_imode);
		} else
			sbdsp_srtotc(sc, sbdsp_tctosr(sc, sc->sc_itc),
				     SB_INPUT_RATE, &sc->sc_itc,
				     &sc->sc_imode);

		if (sc->sc_channels == 2 &&
		    sbdsp_tctosr(sc, sc->sc_otc) > 22727) {
			sbdsp_srtotc(sc, 22727, SB_OUTPUT_RATE,
				     &sc->sc_otc, &sc->sc_omode);
		} else
			sbdsp_srtotc(sc, sbdsp_tctosr(sc, sc->sc_otc),
				     SB_OUTPUT_RATE, &sc->sc_otc,
				     &sc->sc_omode);
	}

	/*
	 * XXX
	 * Should wait for chip to be idle.
	 */
	sc->sc_dmadir = SB_DMA_NONE;

	return 0;
}

d831 1
a831 7
int
sbdsp_open(sc, dev, flags)
	register struct sbdsp_softc *sc;
	dev_t dev;
	int flags;
{
        DPRINTF(("sbdsp_open: sc=0x%x\n", sc));
d837 1
d839 1
a839 1
	if (ISSBPROCLASS(sc) &&
d862 1
a862 1
        DPRINTF(("sbdsp_close: sc=0x%x\n", sc));
d867 2
d885 1
a885 1
	register struct sbdsp_softc *sc;
d890 9
a898 4
	sc->sc_intr = 0;
	if (sc->sc_dmadir != SB_DMA_NONE) {
		isadma_abort(sc->dmachan);
		sc->sc_dmadir = SB_DMA_NONE;
a899 1
	sc->sc_last_hs_size = 0;
d916 5
d922 1
a922 1
sbdsp16_wait(sc)
d924 1
d928 2
a929 1
	register int i;
a931 1
		register u_char x;
d934 6
a939 32
		if ((x & SB_DSP_BUSY) == 0)
			continue;
		return 0;
	}
	++sberr.wdsp;
	return -1;
}

/*
 * Write a byte to the dsp.
 * XXX We are at the mercy of the card as we use a
 * polling loop and wait until it can take the byte.
 */
int
sbdsp_wdsp(sc, v)
	struct sbdsp_softc *sc;
	int v;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	register int i;

	for (i = SBDSP_NPOLL; --i >= 0; ) {
		register u_char x;
		x = bus_space_read_1(iot, ioh, SBP_DSP_WSTAT);
		delay(10);
		if ((x & SB_DSP_BUSY) != 0)
			continue;
		bus_space_write_1(iot, ioh, SBP_DSP_WRITE, v);
		delay(10);
		return 0;
	}
d953 2
a954 1
	register int i;
a956 1
		register u_char x;
d959 5
a963 5
		if ((x & SB_DSP_READY) == 0)
			continue;
		x = bus_space_read_1(iot, ioh, SBP_DSP_READ);
		delay(10);
		return x;
d1020 2
a1021 2
 * Read the version number out of the card.  Return major code
 * in high byte, and minor code in low byte.
d1023 1
a1023 1
short
d1027 1
a1027 1
	short v;
d1029 2
d1032 1
a1032 1
		return 0;
d1035 50
a1084 1
	return ((v >= 0) ? v : 0);
d1088 1
a1088 2
 * Halt a DMA in progress.  A low-speed transfer can be
 * resumed with sbdsp_contdma().
d1094 1
a1094 1
	register struct sbdsp_softc *sc = addr;
d1096 1
a1096 1
	DPRINTF(("sbdsp_haltdma: sc=0x%x\n", sc));
d1103 3
a1105 2
sbdsp_contdma(addr)
	void *addr;
d1107 8
a1114 1
	register struct sbdsp_softc *sc = addr;
d1116 6
a1121 1
	DPRINTF(("sbdsp_contdma: sc=0x%x\n", sc));
d1123 5
a1127 3
	/* XXX how do we reinitialize the DMA controller state?  do we care? */
	(void)sbdsp_wdsp(sc, SB_DSP_CONT);
	return(0);
d1131 4
a1134 5
sbdsp16_setrate(sc, sr, isdac, ratep)
	register struct sbdsp_softc *sc;
	int sr;
	int isdac;
	int *ratep;
d1136 1
d1138 8
a1145 8
	/*
	 * XXXX
	 * More checks here?
	 */
	if (sr < 5000 || sr > 45454)
		return (EINVAL);
	*ratep = sr;
	return (0);
d1148 3
a1150 14
/*
 * Convert a linear sampling rate into the DAC time constant.
 * Set *mode to indicate the high/low-speed DMA operation.
 * Because of limitations of the card, not all rates are possible.
 * We return the time constant of the closest possible rate.
 * The sampling rate limits are different for the DAC and ADC,
 * so isdac indicates output, and !isdac indicates input.
 */
int
sbdsp_srtotc(sc, sr, isdac, tcp, modep)
	register struct sbdsp_softc *sc;
	int sr;
	int isdac;
	int *tcp, *modep;
d1152 2
a1153 1
	int tc, realtc, mode;
d1155 8
a1162 9
	/*
	 * Don't forget to compute which mode we'll be in based on whether
	 * we need to double the rate for stereo on SBPRO.
	 */
	 
	if (sr == 0) {
		tc = SB_LS_MIN;
		mode = SB_ADAC_LS;
		goto out;
a1163 8

	tc = 256 - (1000000 / sr);

	if (sc->sc_channels == 2 && ISSBPRO(sc))
		/* compute based on 2x sample rate when needed */
		realtc = 256 - ( 500000 / sr);
	else
		realtc = tc;
d1165 6
a1170 12
	if (tc < SB_LS_MIN) {
		tc = SB_LS_MIN;
		mode = SB_ADAC_LS;	/* NB: 2x minimum speed is still low
					 * speed mode. */
		goto out;
	} else if (isdac) {
		if (realtc <= SB_DAC_LS_MAX)
			mode = SB_ADAC_LS;
		else {
			mode = SB_ADAC_HS;
			if (tc > SB_DAC_HS_MAX)
				tc = SB_DAC_HS_MAX;
d1173 4
a1176 18
		int adc_ls_max, adc_hs_max;

		/* XXX use better rounding--compare distance to nearest tc on both
		   sides of requested speed */
		if (ISSBPROCLASS(sc)) {
			adc_ls_max = SBPRO_ADC_LS_MAX;
			adc_hs_max = SBPRO_ADC_HS_MAX;
		} else {
			adc_ls_max = SBCLA_ADC_LS_MAX;
			adc_hs_max = SBCLA_ADC_HS_MAX;
		}
	    
		if (realtc <= adc_ls_max)
			mode = SB_ADAC_LS;
		else {
			mode = SB_ADAC_HS;
			if (tc > adc_hs_max)
				tc = adc_hs_max;
d1179 1
a1179 48

out:
	*tcp = tc;
	*modep = mode;
	return (0);
}

/*
 * Convert a DAC time constant to a sampling rate.
 * See SBK, section 12.
 */
int
sbdsp_tctosr(sc, tc)
	register struct sbdsp_softc *sc;
	int tc;
{
	int adc;

	if (ISSBPROCLASS(sc))
		adc = SBPRO_ADC_HS_MAX;
	else
		adc = SBCLA_ADC_HS_MAX;
	
	if (tc > adc)
		tc = adc;
	
	return (1000000 / (256 - tc));
}

int
sbdsp_set_timeconst(sc, tc)
	register struct sbdsp_softc *sc;
	int tc;
{
	/*
	 * A SBPro in stereo mode uses time constants at double the
	 * actual rate.
	 */
	if (ISSBPRO(sc) && sc->sc_channels == 2)
		tc = 256 - ((256 - tc) / 2);

	DPRINTF(("sbdsp_set_timeconst: sc=%p tc=%d\n", sc, tc));

	if (sbdsp_wdsp(sc, SB_DSP_TIMECONST) < 0 ||
	    sbdsp_wdsp(sc, tc) < 0)
		return (EIO);
	    
	return (0);
d1190 1
a1190 1
	register struct sbdsp_softc *sc = addr;
d1194 2
a1195 1
		Dprintf("sbdsp_dma_input: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
d1197 3
a1199 2
	if (sc->sc_channels == 2 && (cc & 1)) {
		DPRINTF(("sbdsp_dma_input: stereo input, odd bytecnt\n"));
d1202 1
d1204 6
a1209 27
	if (sc->sc_dmadir != SB_DMA_IN) {
		if (ISSBPRO(sc)) {
			if (sc->sc_channels == 2) {
				if (ISJAZZ16(sc) && sc->sc_precision == 16) {
					if (sbdsp_wdsp(sc,
						       JAZZ16_RECORD_STEREO) < 0) {
						goto badmode;
					} 
				} else if (sbdsp_wdsp(sc,
						      SB_DSP_RECORD_STEREO) < 0)
					goto badmode;
				sbdsp_mix_write(sc, SBP_INFILTER,
				    (sbdsp_mix_read(sc, SBP_INFILTER) &
				    ~SBP_IFILTER_MASK) | SBP_FILTER_OFF);
			} else {
				if (ISJAZZ16(sc) && sc->sc_precision == 16) {
					if (sbdsp_wdsp(sc,
						       JAZZ16_RECORD_MONO) < 0)
					{
						goto badmode;
					}
				} else if (sbdsp_wdsp(sc, SB_DSP_RECORD_MONO) < 0)
					goto badmode;
				sbdsp_mix_write(sc, SBP_INFILTER,
				    (sbdsp_mix_read(sc, SBP_INFILTER) &
				    ~SBP_IFILTER_MASK) | sc->in_filter);
			}
d1211 3
a1213 13

		if (ISSB16CLASS(sc)) {
			if (sbdsp_wdsp(sc, SB_DSP16_INPUTRATE) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_irate >> 8) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_irate) < 0)
				goto giveup;
		} else
			sbdsp_set_timeconst(sc, sc->sc_itc);

		sc->sc_dmadir = SB_DMA_IN;
		sc->dmaflags = DMAMODE_READ;
		if (ISSB2CLASS(sc))
			sc->dmaflags |= DMAMODE_LOOP;
d1215 9
a1223 3
		/* Already started; just return. */
		if (ISSB2CLASS(sc))
			return 0;
d1225 17
d1243 6
a1248 16
	sc->dmaaddr = p;
	sc->dmacnt = ISSB2CLASS(sc) ? (NBPG/cc)*cc : cc;
	sc->dmachan = sc->sc_precision == 16 ? sc->sc_drq16 : sc->sc_drq8;
	isadma_start(sc->dmaaddr, sc->dmacnt, sc->dmachan, sc->dmaflags);
	sc->sc_intr = intr;
	sc->sc_arg = arg;

	if (sc->sc_precision == 16)
		cc >>= 1;
	--cc;
	if (ISSB16CLASS(sc)) {
		if (sbdsp_wdsp(sc, sc->sc_precision == 16 ? SB_DSP16_RDMA_16 :
							    SB_DSP16_RDMA_8) < 0 ||
		    sbdsp_wdsp(sc, (sc->sc_precision == 16 ? 0x10 : 0x00) |
				       (sc->sc_channels == 2 ? 0x20 : 0x00)) < 0 ||
		    sbdsp16_wait(sc) ||
d1251 1
a1251 1
			DPRINTF(("sbdsp_dma_input: SB16 DMA start failed\n"));
d1254 28
a1281 2
	} else if (ISSB2CLASS(sc)) {
		if (cc != sc->sc_last_hs_size) {
d1285 4
a1291 14
			sc->sc_last_hs_size = cc;
		}
		if (sbdsp_wdsp(sc,
		    sc->sc_imode == SB_ADAC_LS ? SB_DSP_RDMA_LOOP :
						 SB_DSP_HS_INPUT) < 0) {
			DPRINTF(("sbdsp_dma_input: SB2 DMA restart failed\n"));
			goto giveup;
		}
	} else {
		if (sbdsp_wdsp(sc, SB_DSP_RDMA) < 0 ||
		    sbdsp_wdsp(sc, cc) < 0 ||
		    sbdsp_wdsp(sc, cc >> 8) < 0) {
		        DPRINTF(("sbdsp_dma_input: SB1 DMA start failed\n"));
			goto giveup;
d1293 4
d1303 26
d1330 25
a1354 4
badmode:
	DPRINTF(("sbdsp_dma_input: can't set %s mode\n",
		 sc->sc_channels == 2 ? "stereo" : "mono"));
	return EIO;
d1365 1
a1365 1
	register struct sbdsp_softc *sc = addr;
d1369 1
a1369 1
		Dprintf("sbdsp_dma_output: cc=%d 0x%x (0x%x)\n", cc, intr, arg);
d1371 2
a1372 1
	if (sc->sc_channels == 2 && (cc & 1)) {
d1376 1
d1378 6
a1383 22
	if (sc->sc_dmadir != SB_DMA_OUT) {
		if (ISSBPRO(sc)) {
			/* make sure we re-set stereo mixer bit when we start
			   output. */
			sbdsp_mix_write(sc, SBP_STEREO,
			    (sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK) |
			    (sc->sc_channels == 2 ?  SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
			if (ISJAZZ16(sc)) {
				/* Yes, we write the record mode to set
				   16-bit playback mode. weird, huh? */
				if (sc->sc_precision == 16) {
					sbdsp_wdsp(sc,
						   sc->sc_channels == 2 ?
						   JAZZ16_RECORD_STEREO :
						   JAZZ16_RECORD_MONO);
				} else {
					sbdsp_wdsp(sc,
						   sc->sc_channels == 2 ?
						   SB_DSP_RECORD_STEREO :
						   SB_DSP_RECORD_MONO);
				}
			}
d1385 3
a1387 13

		if (ISSB16CLASS(sc)) {
			if (sbdsp_wdsp(sc, SB_DSP16_OUTPUTRATE) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_orate >> 8) < 0 ||
			    sbdsp_wdsp(sc, sc->sc_orate) < 0)
				goto giveup;
		} else
			sbdsp_set_timeconst(sc, sc->sc_otc);

		sc->sc_dmadir = SB_DMA_OUT;
		sc->dmaflags = DMAMODE_WRITE;
		if (ISSB2CLASS(sc))
			sc->dmaflags |= DMAMODE_LOOP;
d1389 9
a1397 3
		/* Already started; just return. */
		if (ISSB2CLASS(sc))
			return 0;
d1400 21
a1420 16
	sc->dmaaddr = p;
	sc->dmacnt = ISSB2CLASS(sc) ? (NBPG/cc)*cc : cc;
	sc->dmachan = sc->sc_precision == 16 ? sc->sc_drq16 : sc->sc_drq8;
	isadma_start(sc->dmaaddr, sc->dmacnt, sc->dmachan, sc->dmaflags);
	sc->sc_intr = intr;
	sc->sc_arg = arg;

	if (sc->sc_precision == 16)
		cc >>= 1;
	--cc;
	if (ISSB16CLASS(sc)) {
		if (sbdsp_wdsp(sc, sc->sc_precision == 16 ? SB_DSP16_WDMA_16 :
							    SB_DSP16_WDMA_8) < 0 ||
		    sbdsp_wdsp(sc, (sc->sc_precision == 16 ? 0x10 : 0x00) |
				       (sc->sc_channels == 2 ? 0x20 : 0x00)) < 0 ||
		    sbdsp16_wait(sc) ||
d1423 1
a1423 1
			DPRINTF(("sbdsp_dma_output: SB16 DMA start failed\n"));
d1426 23
a1448 2
	} else if (ISSB2CLASS(sc)) {
		if (cc != sc->sc_last_hs_size) {
d1452 4
a1458 14
			sc->sc_last_hs_size = cc;
		}
		if (sbdsp_wdsp(sc,
		    sc->sc_omode == SB_ADAC_LS ? SB_DSP_WDMA_LOOP :
						 SB_DSP_HS_OUTPUT) < 0) {
			DPRINTF(("sbdsp_dma_output: SB2 DMA restart failed\n"));
			goto giveup;
		}
	} else {
		if (sbdsp_wdsp(sc, SB_DSP_WDMA) < 0 ||
		    sbdsp_wdsp(sc, cc) < 0 ||
		    sbdsp_wdsp(sc, cc >> 8) < 0) {
		        DPRINTF(("sbdsp_dma_output: SB1 DMA start failed\n"));
			goto giveup;
d1460 4
d1476 5
a1480 2
 * completion of a dma reception.  The three modes are mutually
 * exclusive so we know a priori which event has occurred.
d1486 3
a1488 2
	register struct sbdsp_softc *sc = arg;
	u_char x;
d1492 2
a1493 1
		Dprintf("sbdsp_intr: intr=0x%x\n", sc->sc_intr);
d1496 7
a1502 2
		x = sbdsp_mix_read(sc, SBP_IRQ_STATUS);
		if ((x & 3) == 0)
d1504 1
a1505 1
	/* isadma_finished() moved to isadma.c */
d1507 1
a1507 1
	delay(10);
d1514 17
a1530 10
	if (sc->sc_intr != 0) {
		/* clear interrupt */
		x = bus_space_read_1(sc->sc_iot, sc->sc_ioh,
		    sc->sc_precision == 16 ? SBP_DSP_IRQACK16 :
					     SBP_DSP_IRQACK8);
		if (!ISSB2CLASS(sc))
			isadma_done(sc->dmachan);
		(*sc->sc_intr)(sc->sc_arg);
	} else {
		return 0;
d1574 10
a1583 7
int
sbdsp_setfd(addr, flag)
	void *addr;
	int flag;
{
	/* Can't do full-duplex */
	return(ENOTTY);
d1586 4
a1589 4
int
sbdsp_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
a1590 1
	register struct sbdsp_softc *sc = addr;
a1591 3
    
	DPRINTF(("sbdsp_mixer_set_port: port=%d num_channels=%d\n", cp->dev,
	    cp->un.value.num_channels));
d1593 8
a1600 32
	if (!ISSBPROCLASS(sc))
		return EINVAL;

	/*
	 * Everything is a value except for SBPro BASS/TREBLE and
	 * RECORD_SOURCE
	 */
	switch (cp->dev) {
	case SB_SPEAKER:
		cp->dev = SB_MASTER_VOL;
	case SB_MIC_PORT:
	case SB_LINE_IN_PORT:
	case SB_DAC_PORT:
	case SB_FM_PORT:
	case SB_CD_PORT:
	case SB_MASTER_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return EINVAL;

		/*
		 * All the mixer ports are stereo except for the microphone.
		 * If we get a single-channel gain value passed in, then we
		 * duplicate it to both left and right channels.
		 */

		switch (cp->dev) {
		case SB_MIC_PORT:
			if (cp->un.value.num_channels != 1)
				return EINVAL;

			/* handle funny microphone gain */
			gain = SBP_AGAIN_TO_MICGAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
d1602 9
a1610 16
		case SB_LINE_IN_PORT:
		case SB_DAC_PORT:
		case SB_FM_PORT:
		case SB_CD_PORT:
		case SB_MASTER_VOL:
			switch (cp->un.value.num_channels) {
			case 1:
				gain = sbdsp_mono_vol(SBP_AGAIN_TO_SBGAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]));
				break;
			case 2:
				gain = sbdsp_stereo_vol(SBP_AGAIN_TO_SBGAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]),
							SBP_AGAIN_TO_SBGAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]));
				break;
			default:
				return EINVAL;
			}
d1613 1
a1613 1
			return EINVAL;
d1615 7
a1621 3

		switch (cp->dev) {
		case SB_MIC_PORT:
d1623 1
d1628 1
a1628 1
		case SB_LINE_IN_PORT:
d1631 2
a1632 2
		case SB_DAC_PORT:
			src = SBP_DAC_VOL;
d1634 2
a1635 2
		case SB_FM_PORT:
			src = SBP_FM_VOL;
d1637 1
a1637 1
		case SB_CD_PORT:
d1641 1
a1641 1
			return EINVAL;
a1642 1

a1643 1
		sc->gain[cp->dev] = gain;
d1645 44
d1690 18
d1710 77
d1788 27
d1817 8
d1826 40
a1865 7
		switch (cp->dev) {
		case SB_TREBLE:
			return sbdsp_set_ifilter(addr, cp->un.ord ? SBP_TREBLE_EQ : 0);
		case SB_BASS:
			return sbdsp_set_ifilter(addr, cp->un.ord ? SBP_BASS_EQ : 0);
		case SB_RECORD_SOURCE:
			return sbdsp_set_in_port(addr, cp->un.ord);
d1867 2
a1868 1

d1875 1
a1875 1
	return (0);
d1883 1
a1883 2
	register struct sbdsp_softc *sc = addr;
	int gain;
d1885 1
a1885 1
	DPRINTF(("sbdsp_mixer_get_port: port=%d", cp->dev));
d1887 1
a1887 1
	if (!ISSBPROCLASS(sc))
d1891 25
a1915 7
	case SB_SPEAKER:
		cp->dev = SB_MASTER_VOL;
	case SB_MIC_PORT:
	case SB_LINE_IN_PORT:
	case SB_DAC_PORT:
	case SB_FM_PORT:
	case SB_CD_PORT:
a1916 2
		gain = sc->gain[cp->dev];

d1918 2
a1919 1
		case SB_MIC_PORT:
d1922 2
a1923 8

			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = SBP_MICGAIN_TO_AGAIN(gain);
			break;
		case SB_LINE_IN_PORT:
		case SB_DAC_PORT:
		case SB_FM_PORT:
		case SB_CD_PORT:
		case SB_MASTER_VOL:
d1926 2
a1927 1
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = SBP_SBGAIN_TO_AGAIN(gain);
d1930 4
a1933 2
				cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = SBP_LEFTGAIN(gain);
				cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = SBP_RIGHTGAIN(gain);
d1940 1
d1942 5
d1949 5
a1953 14
	case SB_TREBLE:
	case SB_BASS:
	case SB_RECORD_SOURCE:
		switch (cp->dev) {
		case SB_TREBLE:
			cp->un.ord = sbdsp_get_ifilter(addr) == SBP_TREBLE_EQ;
			return 0;
		case SB_BASS:
			cp->un.ord = sbdsp_get_ifilter(addr) == SBP_BASS_EQ;
			return 0;
		case SB_RECORD_SOURCE:
			cp->un.ord = sbdsp_get_in_port(addr);
			return 0;
		}
d1955 12
d1973 1
a1973 1
	return (0);
d1979 1
a1979 1
	register mixer_devinfo_t *dip;
d1981 8
a1988 1
	register struct sbdsp_softc *sc = addr;
d1990 3
a1992 1
	DPRINTF(("sbdsp_mixer_query_devinfo: index=%d\n", dip->index));
d1995 9
a2003 1
	case SB_MIC_PORT:
d2005 10
a2014 1
		dip->mixer_class = SB_INPUT_CLASS;
d2016 3
a2018 3
		dip->next = AUDIO_MIXER_LAST;
		strcpy(dip->label.name, AudioNmicrophone);
		dip->un.v.num_channels = 1;
d2021 1
a2021 2

	case SB_SPEAKER:
d2023 1
a2023 1
		dip->mixer_class = SB_OUTPUT_CLASS;
d2026 2
a2027 2
		strcpy(dip->label.name, AudioNspeaker);
		dip->un.v.num_channels = 1;
a2029 8

	case SB_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = SB_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strcpy(dip->label.name, AudioCInputs);
		return 0;

d2034 1
a2034 1
		strcpy(dip->label.name, AudioCOutputs);
d2038 2
a2039 11
	if (ISSBPROCLASS(sc)) {
		switch (dip->index) {
		case SB_LINE_IN_PORT:
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNline);
			dip->un.v.num_channels = 2;
			strcpy(dip->un.v.units.name, AudioNvolume);
			return 0;
d2041 10
a2050 9
		case SB_DAC_PORT:
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNdac);
			dip->un.v.num_channels = 2;
			strcpy(dip->un.v.units.name, AudioNvolume);
			return 0;
d2052 9
a2060 9
		case SB_CD_PORT:
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNcd);
			dip->un.v.num_channels = 2;
			strcpy(dip->un.v.units.name, AudioNvolume);
			return 0;
d2062 16
a2077 22
		case SB_FM_PORT:
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_INPUT_CLASS;
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNfmsynth);
			dip->un.v.num_channels = 2;
			strcpy(dip->un.v.units.name, AudioNvolume);
			return 0;

		case SB_MASTER_VOL:
			dip->type = AUDIO_MIXER_VALUE;
			dip->mixer_class = SB_OUTPUT_CLASS;
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNvolume);
			dip->un.v.num_channels = 2;
			strcpy(dip->un.v.units.name, AudioNvolume);
			return 0;

		case SB_RECORD_SOURCE:
			dip->mixer_class = SB_RECORD_CLASS;
a2078 3
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNsource);
d2081 1
a2081 1
			dip->un.e.member[0].ord = SB_MIC_PORT;
d2083 1
a2083 1
			dip->un.e.member[1].ord = SB_CD_PORT;
d2085 3
a2087 2
			dip->un.e.member[2].ord = SB_LINE_IN_PORT;
			return 0;
d2089 9
a2097 1
		case SB_BASS:
a2099 3
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNbass);
d2105 12
a2116 3
			return 0;

		case SB_TREBLE:
a2118 3
			dip->prev = AUDIO_MIXER_LAST;
			dip->next = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioNtreble);
d2124 142
a2265 1
			return 0;
a2266 7
		case SB_RECORD_CLASS:			/* record source class */
			dip->type = AUDIO_MIXER_CLASS;
			dip->mixer_class = SB_RECORD_CLASS;
			dip->next = dip->prev = AUDIO_MIXER_LAST;
			strcpy(dip->label.name, AudioCRecord);
			return 0;
		} 
d2270 50
@


1.10
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.9 1997/01/03 00:09:59 kstailey Exp $	*/
d774 1
a774 1
		isa_dmaabort(sc->dmachan);
d1170 1
a1170 1
	isa_dmastart(sc->dmaflags, sc->dmaaddr, sc->dmacnt, sc->dmachan);
d1288 1
a1288 1
	isa_dmastart(sc->dmaflags, sc->dmaaddr, sc->dmacnt, sc->dmachan);
d1360 1
a1360 1
	/* isa_dmafinished() moved to isadma.c */
d1375 1
a1375 2
			isa_dmadone(sc->dmaflags, sc->dmaaddr, sc->dmacnt,
			    sc->dmachan);
@


1.9
log
@end of pesky log message, thanks to Go Watanabe <go@@cclub.tutcc.tut.ac.jp>
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.8 1996/11/02 01:09:37 millert Exp $	*/
d37 1
d125 1
a125 1
int	sbdsp16_wait __P((int));
d128 1
a128 1
int	sbdsp_setrate __P((struct sbdsp_softc *, int, int, int *));
d143 2
a144 2
	printf("open %d dmachan %d iobase %x\n",
	    sc->sc_open, sc->sc_drq, sc->sc_iobase);
d147 1
a147 1
	    sc->sc_orate, sc->sc_otc, sc->sc_omode, sc->encoding);
d176 1
a176 1
	if (sc->sc_dev.dv_cfdata->cf_flags != 0)
d178 1
a178 1
	else
d180 1
d202 2
a203 1
	register int iobase = sc->sc_iobase;
d205 14
a218 4
	if (jazz16_drq_conf[sc->sc_drq] == (u_char)-1 ||
	    jazz16_irq_conf[sc->sc_irq] == (u_char)-1)
		return rval;		/* give up, we can't do it. */
	outb(JAZZ16_CONFIG_PORT, JAZZ16_WAKEUP);
d220 2
a221 2
	outb(JAZZ16_CONFIG_PORT, JAZZ16_SETBASE);
	outb(JAZZ16_CONFIG_PORT, iobase & 0x70);
d223 4
a226 2
	if (sbdsp_reset(sc) < 0)
		return rval;		/* XXX? what else could we do? */
d228 9
a236 4
	if (sbdsp_wdsp(iobase, JAZZ16_READ_VER))
		return rval;
	if (sbdsp_rdsp(iobase) != JAZZ16_VER_JAZZ)
		return rval;
d238 10
a247 8
	if (sbdsp_wdsp(iobase, JAZZ16_SET_DMAINTR) ||
	    /* set both 8 & 16-bit drq to same channel, it works fine. */
	    sbdsp_wdsp(iobase,
		       (jazz16_drq_conf[sc->sc_drq] << 4) |
		       jazz16_drq_conf[sc->sc_drq]) ||
	    sbdsp_wdsp(iobase, jazz16_irq_conf[sc->sc_irq])) {
		DPRINTF(("sbdsp: can't write jazz16 probe stuff"));
		return rval;
d249 4
a252 1
	return (rval | MODEL_JAZZ16);
d271 1
a273 1
	sc->encoding = AUDIO_ENCODING_ULAW;
a300 12

#ifdef notyet
	sbdsp_mix_write(sc, SBP_SET_IRQ, 0x04);
	sbdsp_mix_write(sc, SBP_SET_DRQ, 0x22);

	printf("sbdsp_attach: irq=%02x, drq=%02x\n",
	    sbdsp_mix_read(sc, SBP_SET_IRQ),
	    sbdsp_mix_read(sc, SBP_SET_DRQ));
#else
	if (ISSB16CLASS(sc))
		sc->sc_model = 0x0300;
#endif
d313 4
a316 2
	int iobase = sc->sc_iobase;
	outb(iobase + SBP_MIXER_ADDR, mixerport);
d318 1
a318 1
	outb(iobase + SBP_MIXER_DATA, val);
d327 4
a330 2
	int iobase = sc->sc_iobase;
	outb(iobase + SBP_MIXER_ADDR, mixerport);
d332 1
a332 1
	return inb(iobase + SBP_MIXER_DATA);
d343 1
a343 1
		return (sbdsp_setrate(sc, sr, SB_INPUT_RATE, &sc->sc_irate));
d368 1
a368 1
		return (sbdsp_setrate(sc, sr, SB_OUTPUT_RATE, &sc->sc_orate));
d406 1
a406 1
sbdsp_set_encoding(addr, encoding)
d408 1
a408 1
	u_int encoding;
d414 2
a415 4
		sc->encoding = AUDIO_ENCODING_ULAW;
		break;
	case AUDIO_ENCODING_LINEAR:
		sc->encoding = AUDIO_ENCODING_LINEAR;
d421 7
d437 1
a437 21
	return (sc->encoding);
}

int
sbdsp_set_precision(addr, precision)
	void *addr;
	u_int precision;
{
	register struct sbdsp_softc *sc = addr;

	if (ISSB16CLASS(sc) || ISJAZZ16(sc)) {
		if (precision != 16 && precision != 8)
			return (EINVAL);
		sc->sc_precision = precision;
	} else {
		if (precision != 8)
			return (EINVAL);
		sc->sc_precision = precision;
	}

	return (0);
d492 1
d521 1
d600 1
d651 1
a651 11
	/* Higher speeds need bigger blocks to avoid popping and silence gaps. */
	if (blk < NBPG/4 || blk > NBPG/2) {
		if (ISSB16CLASS(sc)) {
			if (sc->sc_orate > 8000 || sc->sc_irate > 8000)
				blk = NBPG/2;
		} else {
			if (sc->sc_otc > SB_8K || sc->sc_itc > SB_8K)
				blk = NBPG/2;
		}
	}
	/* don't try to DMA too much at once, though. */
d654 5
a658 4
	if (sc->sc_channels == 2)
		return (blk & ~1); /* must be even to preserve stereo separation */
	else
		return (blk);	/* Anything goes :-) */
d699 1
a699 7
	if (ISSB16CLASS(sc) || ISJAZZ16(sc)) {
		if (sc->encoding == AUDIO_ENCODING_ULAW &&
		    sc->sc_precision == 16) {
			sc->sc_precision = 8;
			return EINVAL;	/* XXX what should we really do? */
		}
	}
d724 1
a724 1
	    sbdsp_wdsp(sc->sc_iobase, SB_DSP_RECORD_MONO) < 0) {
d769 2
a770 1
	register int iobase = sc->sc_iobase;
d774 1
a774 1
		isa_dmaabort(sc->sc_drq);
d784 1
a784 1
	outb(iobase + SBP_DSP_RESET, 1);
d786 1
a786 1
	outb(iobase + SBP_DSP_RESET, 0);
d788 1
a788 1
	if (sbdsp_rdsp(iobase) != SB_MAGIC)
d795 2
a796 2
sbdsp16_wait(iobase)
	int iobase;
d798 2
d804 1
a804 1
		x = inb(iobase + SBP_DSP_WSTAT);
d820 3
a822 1
sbdsp_wdsp(int iobase, int v)
d824 2
d830 1
a830 1
		x = inb(iobase + SBP_DSP_WSTAT);
d834 1
a834 1
		outb(iobase + SBP_DSP_WRITE, v);
d846 2
a847 1
sbdsp_rdsp(int iobase)
d849 2
d855 1
a855 1
		x = inb(iobase + SBP_DSP_RSTAT);
d859 1
a859 1
		x = inb(iobase + SBP_DSP_READ);
d902 1
a902 1
	(void)sbdsp_wdsp(sc->sc_iobase, SB_DSP_SPKR_ON);
d913 1
a913 1
	(void)sbdsp_wdsp(sc->sc_iobase, SB_DSP_SPKR_OFF);
a924 1
	register int iobase = sc->sc_iobase;
d927 1
a927 1
	if (sbdsp_wdsp(iobase, SB_DSP_VERSION) < 0)
d929 2
a930 2
	v = sbdsp_rdsp(iobase) << 8;
	v |= sbdsp_rdsp(iobase);
d959 1
a959 1
	(void)sbdsp_wdsp(sc->sc_iobase, SB_DSP_CONT);
d964 1
a964 1
sbdsp_setrate(sc, sr, isdac, ratep)
d975 1
a975 1
	if (sr < 5000 || sr > 44100)
a1084 2
	register int iobase;

d1094 2
a1095 3
	iobase = sc->sc_iobase;
	if (sbdsp_wdsp(iobase, SB_DSP_TIMECONST) < 0 ||
	    sbdsp_wdsp(iobase, tc) < 0)
a1109 1
	register int iobase;
a1119 1
	iobase = sc->sc_iobase;
d1124 1
a1124 1
					if (sbdsp_wdsp(iobase,
d1128 1
a1128 1
				} else if (sbdsp_wdsp(iobase,
d1136 1
a1136 1
					if (sbdsp_wdsp(iobase,
d1141 1
a1141 1
				} else if (sbdsp_wdsp(iobase, SB_DSP_RECORD_MONO) < 0)
d1150 3
a1152 3
			if (sbdsp_wdsp(iobase, SB_DSP16_INPUTRATE) < 0 ||
			    sbdsp_wdsp(iobase, sc->sc_irate >> 8) < 0 ||
			    sbdsp_wdsp(iobase, sc->sc_irate) < 0)
d1156 1
d1158 7
d1167 4
a1170 1
	isa_dmastart(DMAMODE_READ, p, cc, sc->sc_drq);
a1172 3
	sc->dmaflags = DMAMODE_READ;
	sc->dmaaddr = p;
	sc->dmacnt = cc;		/* DMA controller is strange...? */
d1174 1
a1174 2
	if ((ISSB16CLASS(sc) && sc->sc_precision == 16) ||
	    (ISJAZZ16(sc) && sc->sc_drq > 3))
d1178 3
a1180 3
		if (sbdsp_wdsp(iobase, sc->sc_precision == 16 ? SB_DSP16_RDMA_16 :
								SB_DSP16_RDMA_8) < 0 ||
		    sbdsp_wdsp(iobase, (sc->sc_precision == 16 ? 0x10 : 0x00) |
d1182 3
a1184 3
		    sbdsp16_wait(iobase) ||
		    sbdsp_wdsp(iobase, cc) < 0 ||
		    sbdsp_wdsp(iobase, cc >> 8) < 0) {
d1188 1
a1188 8
	} else if (sc->sc_imode == SB_ADAC_LS) {
		if (sbdsp_wdsp(iobase, SB_DSP_RDMA) < 0 ||
		    sbdsp_wdsp(iobase, cc) < 0 ||
		    sbdsp_wdsp(iobase, cc >> 8) < 0) {
		        DPRINTF(("sbdsp_dma_input: LS DMA start failed\n"));
			goto giveup;
		}
	} else {
d1190 4
a1193 4
			if (sbdsp_wdsp(iobase, SB_DSP_BLOCKSIZE) < 0 ||
			    sbdsp_wdsp(iobase, cc) < 0 ||
			    sbdsp_wdsp(iobase, cc >> 8) < 0) {
				DPRINTF(("sbdsp_dma_input: HS DMA start failed\n"));
d1198 11
a1208 2
		if (sbdsp_wdsp(iobase, SB_DSP_HS_INPUT) < 0) {
			DPRINTF(("sbdsp_dma_input: HS DMA restart failed\n"));
a1232 1
	register int iobase;
a1242 1
	iobase = sc->sc_iobase;
d1254 1
a1254 1
					sbdsp_wdsp(iobase,
d1259 1
a1259 1
					sbdsp_wdsp(iobase,
d1268 3
a1270 3
			if (sbdsp_wdsp(iobase, SB_DSP16_OUTPUTRATE) < 0 ||
			    sbdsp_wdsp(iobase, sc->sc_orate >> 8) < 0 ||
			    sbdsp_wdsp(iobase, sc->sc_orate) < 0)
d1274 1
d1276 7
d1285 4
a1288 1
	isa_dmastart(DMAMODE_WRITE, p, cc, sc->sc_drq);
a1290 3
	sc->dmaflags = DMAMODE_WRITE;
	sc->dmaaddr = p;
	sc->dmacnt = cc;	/* a vagary of how DMA works, apparently. */
d1292 1
a1292 2
	if ((ISSB16CLASS(sc) && sc->sc_precision == 16) ||
	    (ISJAZZ16(sc) && sc->sc_drq > 3))
d1296 3
a1298 3
		if (sbdsp_wdsp(iobase, sc->sc_precision == 16 ? SB_DSP16_WDMA_16 :
								SB_DSP16_WDMA_8) < 0 ||
		    sbdsp_wdsp(iobase, (sc->sc_precision == 16 ? 0x10 : 0x00) |
d1300 3
a1302 3
		    sbdsp16_wait(iobase) ||
		    sbdsp_wdsp(iobase, cc) < 0 ||
		    sbdsp_wdsp(iobase, cc >> 8) < 0) {
d1306 1
a1306 8
	} else if (sc->sc_omode == SB_ADAC_LS) {
		if (sbdsp_wdsp(iobase, SB_DSP_WDMA) < 0 ||
		    sbdsp_wdsp(iobase, cc) < 0 ||
		    sbdsp_wdsp(iobase, cc >> 8) < 0) {
		        DPRINTF(("sbdsp_dma_output: LS DMA start failed\n"));
			goto giveup;
		}
	} else {
d1308 4
a1311 4
			if (sbdsp_wdsp(iobase, SB_DSP_BLOCKSIZE) < 0 ||
			    sbdsp_wdsp(iobase, cc) < 0 ||
			    sbdsp_wdsp(iobase, cc >> 8) < 0) {
				DPRINTF(("sbdsp_dma_output: HS DMA start failed\n"));
d1316 11
a1326 2
		if (sbdsp_wdsp(iobase, SB_DSP_HS_OUTPUT) < 0) {
			DPRINTF(("sbdsp_dma_output: HS DMA restart failed\n"));
d1355 5
a1361 6
	/* clear interrupt */
#ifdef notyet
	x = sbdsp_mix_read(sc, 0x82);
	x = inb(sc->sc_iobase + 15);
#endif
	x = inb(sc->sc_iobase + SBP_DSP_RSTAT);
d1365 1
a1365 1
		x = sbdsp_rdsp(sc->sc_iobase);
d1370 7
a1376 1
		isa_dmadone(sc->dmaflags, sc->dmaaddr, sc->dmacnt, sc->sc_drq);
d1378 2
a1380 2
	else
		return 0;
d1403 1
a1403 1
	sbdsp_wdsp(sc->sc_iobase, SB_MIDI_UART_INTR);
d1418 1
a1418 1
	if (sbdsp_wdsp(sc->sc_iobase, v) < 0)
a1421 21

u_int
sbdsp_get_silence(encoding)
	int encoding;
{
#define ULAW_SILENCE	0x7f
#define LINEAR_SILENCE	0
	u_int auzero;
    
	switch (encoding) {
	case AUDIO_ENCODING_ULAW:
		auzero = ULAW_SILENCE; 
		break;
	case AUDIO_ENCODING_PCM16:
	default:
		auzero = LINEAR_SILENCE;
		break;
	}

	return (auzero);
}
@


1.8
log
@Only print 'not finished' if AUDIO_DEBUG defined.  Also fix up some
printf types.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.7 1996/09/16 15:39:44 mickey Exp $	*/
d1345 1
a1345 6
	if (!isa_dmafinished(sc->sc_drq)) {
#ifdef AUDIO_DEBUG
		printf("sbdsp_intr: not finished\n");
#endif
		return 0;
	}
@


1.7
log
@fix a typo.
from netbsd-pr port-i386/2587 <rvb@@cs.cmu.edu>
@
text
@d1 2
a2 2
/*	$OpenBSD: sbdsp.c,v 1.6 1996/05/26 00:27:29 deraadt Exp $	*/
/*	$NetBSD: sbdsp.c,v 1.26 1996/05/12 23:53:38 mycroft Exp $	*/
d147 1
a147 1
	printf("outport %d inport %d spkron %d nintr %d\n",
d149 1
a149 1
	printf("precision %d channels %d intr %x arg %x\n",
d1346 1
d1348 1
@


1.6
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: sbdsp.c,v 1.5 1996/05/07 07:37:41 deraadt Exp $	*/
d652 1
a652 1
			if (sc->sc_otc > SB_8K || sc->sc_itc < SB_8K)
@


1.5
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: sbdsp.c,v 1.4 1996/04/18 23:47:47 niklas Exp $	*/
/*	$NetBSD: sbdsp.c,v 1.25 1996/04/29 20:03:31 christos Exp $	*/
d55 1
@


1.4
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: sbdsp.c,v 1.3 1996/03/08 16:43:14 niklas Exp $	*/
/*	$NetBSD: sbdsp.c,v 1.24 1996/03/16 04:00:11 jtk Exp $	*/
d123 11
d136 2
a137 1
sb_printsc(struct sbdsp_softc *sc)
a167 1
	register int iobase = sc->sc_iobase;
a236 1
	register int iobase = sc->sc_iobase;
a371 2
	register struct sbdsp_softc *sc = addr;

d487 1
a487 1
	int rval, mixval;
d1109 1
a1109 1
	void (*intr)();
d1225 1
a1225 1
	void (*intr)();
d1501 2
d1524 2
@


1.3
log
@From NetBSD: merge of 960217
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: sbdsp.c,v 1.16 1996/02/16 10:10:21 mycroft Exp $	*/
d85 4
d131 3
a133 2
	printf("itc %d imode %d otc %d omode %d encoding %x\n",
	    sc->sc_itc, sc->sc_imode, sc->sc_otc, sc->sc_omode, sc->encoding);
d136 2
a137 2
	printf("chans %x intr %x arg %x\n",
	    sc->sc_chans, sc->sc_intr, sc->sc_arg);
d162 5
a166 1
	sc->sc_model = sbversion(sc);
d172 47
d229 4
a232 2
	if (ISSBPROCLASS(sc))
		sc->sc_itc = sc->sc_otc = SBPRO_ADC_HS_MAX;
d234 4
a237 3
		sc->sc_itc = sc->sc_otc = SBCLA_ADC_HS_MAX;
	sc->sc_chans = 1;
	sc->encoding = AUDIO_ENCODING_LINEAR;
d254 1
a254 1
				sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL));
d259 1
d262 15
a276 2
	printf(": dsp v%d.%02d\n",
	       SBVER_MAJOR(sc->sc_model), SBVER_MINOR(sc->sc_model));
d314 4
a317 1
	return (sbdsp_srtotc(sc, sr, SB_INPUT_RATE, &sc->sc_itc, &sc->sc_imode));
d326 4
a329 1
	return (sbdsp_tctosr(sc, sc->sc_itc));
d339 4
a342 1
	return (sbdsp_srtotc(sc, sr, SB_OUTPUT_RATE, &sc->sc_otc, &sc->sc_omode));
d351 4
a354 1
	return (sbdsp_tctosr(sc, sc->sc_otc));
d380 1
a380 1
sbdsp_set_encoding(addr, enc)
d382 1
a382 1
	u_int enc;
d386 1
a386 1
	switch(enc){
d396 1
d410 1
a410 1
sbdsp_set_precision(addr, prec)
d412 1
a412 1
	u_int prec;
d414 11
a425 2
	if (prec != 8)
		return (EINVAL);
d433 3
a435 1
	return (8);
d439 1
a439 1
sbdsp_set_channels(addr, chans)
d441 1
a441 1
	int chans;
d446 1
a446 1
		if (chans != 1 && chans != 2)
d448 7
a454 13
		sc->sc_chans = chans;

#if 0
		if (rval = sbdsp_set_in_sr_real(addr, sc->sc_irate))
			return rval;
#endif

		sbdsp_mix_write(sc, SBP_STEREO,
				(sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK) |
				(chans == 2 ? SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
		/* recording channels needs to be done right when we start
		   DMA recording.  Just record number of channels for now
		   and set stereo when ready. */
d456 1
a456 1
		if (chans != 1)
d458 1
a458 1
		sc->sc_chans = chans;
d470 11
a480 2
#if 0
	/* recording stereo may frob the mixer output */
d482 17
a498 4
		if ((sbdsp_mix_read(sc, SBP_STEREO) & SBP_PLAYMODE_MASK) == SBP_PLAYMODE_STEREO)
			sc->sc_chans = 2;
		else
			sc->sc_chans = 1;
d500 2
a501 2
		sc->sc_chans = 1;
#endif
d503 20
a522 1
	return (sc->sc_chans);
d590 1
a590 2
				SBP_RECORD_FROM(sbport, SBP_FILTER_OFF,
						SBP_FILTER_HIGH));
d638 9
a646 3
	if ((sc->sc_otc > SB_8K || sc->sc_itc > SB_8K) &&
	    (blk > NBPG/2 || blk < NBPG/4))
		blk = NBPG/2;
d650 1
a650 1
	if (sc->sc_chans == 2)
d667 34
d794 18
d955 18
d988 1
a988 1
	int tc, mode;
d990 5
d1002 6
d1011 2
a1012 1
		mode = SB_ADAC_LS;
d1015 1
a1015 1
		if (tc <= SB_DAC_LS_MAX)
d1035 1
a1035 1
		if (tc <= adc_ls_max)
d1073 1
a1073 1
sbdsp_set_tc(sc, tc)
d1083 1
a1083 1
	if (ISSBPRO(sc) && sc->sc_chans == 2)
d1086 1
a1086 1
	DPRINTF(("sbdsp_set_tc: sc=%p tc=%d\n", sc, tc));
d1111 1
a1111 1
	if (sc->sc_chans == 2 && (cc & 1)) {
d1118 9
a1126 3
		if (ISSBPROCLASS(sc)) {
			if (sc->sc_chans == 2) {
				if (sbdsp_wdsp(iobase, SB_DSP_RECORD_STEREO) < 0)
d1129 2
a1130 1
				    sbdsp_mix_read(sc, SBP_INFILTER) | SBP_FILTER_OFF);
d1132 7
a1138 1
				if (sbdsp_wdsp(iobase, SB_DSP_RECORD_MONO) < 0)
d1140 3
a1142 3
				sbdsp_mix_write(sc, SBP_INFILTER, sc->sc_itc > SB_8K ? 
				    sbdsp_mix_read(sc, SBP_INFILTER) | SBP_FILTER_OFF :
				    sbdsp_mix_read(sc, SBP_INFILTER) & ~SBP_FILTER_MASK);
d1146 7
a1152 1
		sbdsp_set_tc(sc, sc->sc_itc);
d1156 1
a1156 1
	isa_dmastart(B_READ, p, cc, sc->sc_drq);
d1159 1
a1159 1
	sc->dmaflags = B_READ;
d1161 1
a1161 1
	sc->dmacnt = --cc;		/* DMA controller is strange...? */
d1163 16
a1178 1
	if (sc->sc_imode == SB_ADAC_LS) {
d1185 1
a1185 2
	}
	else {
d1208 1
a1208 1
		 sc->sc_chans == 2 ? "stereo" : "mono"));
d1227 1
a1227 1
	if (sc->sc_chans == 2 && (cc & 1)) {
d1234 1
a1234 1
		if (ISSBPROCLASS(sc)) {
d1239 16
a1254 1
			    (sc->sc_chans == 2 ?  SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
d1257 7
a1263 1
		sbdsp_set_tc(sc, sc->sc_otc);
d1267 1
a1267 1
	isa_dmastart(B_WRITE, p, cc, sc->sc_drq);
d1270 1
a1270 1
	sc->dmaflags = B_WRITE;
d1272 1
a1272 1
	sc->dmacnt = --cc;	/* a vagary of how DMA works, apparently. */
d1274 16
a1289 1
	if (sc->sc_omode == SB_ADAC_LS) {
d1296 1
a1296 2
	}
	else {
d1336 4
d1342 4
a1348 6
	if ((x & SB_DSP_READY) == 0) {
		printf("sbdsp_intr: still busy\n");
		return 0;
	}
#endif
#if 0
d1355 1
a1355 11
		/*
		 * The SBPro used to develop and test this driver often
		 * generated dma underruns--it interrupted to signal
		 * completion of the DMA input recording block, but the
		 * ISA DMA controller didn't think the channel was
		 * finished.  Maybe this is just a bus speed issue, I dunno,
		 * but it seems strange and leads to channel-flipping with
		 * stereo recording.  Sigh.
		 */
		isa_dmadone(sc->dmaflags, sc->dmaaddr, sc->dmacnt,
			    sc->sc_drq);
d1403 2
a1404 2
sbdsp_get_silence(enc)
    int enc;
d1408 1
a1408 1
    u_int auzero;
d1410 9
a1418 9
    switch (enc) {
    case AUDIO_ENCODING_ULAW:
	auzero = ULAW_SILENCE; 
	break;
    case AUDIO_ENCODING_PCM16:
    default:
	auzero = LINEAR_SILENCE;
	break;
    }
d1420 1
a1420 1
    return(auzero);
d1434 2
a1435 2
    void *addr;
    mixer_ctrl_t *cp;
d1437 2
a1438 4
    register struct sbdsp_softc *sc = addr;
    int error = 0;
    int src, gain;
    int left, right;
d1440 5
a1444 1
    DPRINTF(("sbdsp_mixer_set_port: port=%d num_channels=%d\n", cp->dev, cp->un.value.num_channels));
a1445 10
    /*
     * Everything is a value except for SBPro special OUTPUT_MODE and
     * RECORD_SOURCE
     */
    if (cp->type != AUDIO_MIXER_VALUE) {
	if (!ISSBPROCLASS(sc) || (cp->dev != SB_OUTPUT_MODE &&
				  cp->dev != SB_RECORD_SOURCE))
	    return EINVAL;
    }
    else {
d1447 2
a1448 17
	 * All the mixer ports are stereo except for the microphone.
	 * If we get a single-channel gain value passed in, then we
	 * duplicate it to both left and right channels.
	 */
    if (cp->un.value.num_channels == 2) {
	left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
	right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
    }
    else
	    left = right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
    }    
    
    if (ISSBPROCLASS(sc)) {
	/* The _PORT things are all signal inputs to the mixer.
	 * Here we are tweaking their mixing level.
	 *
	 * We can also tweak the output stage volume (MASTER_VOL)
d1450 1
a1450 23
	gain = sbdsp_stereo_vol(SBP_AGAIN_TO_SBGAIN(left),
				SBP_AGAIN_TO_SBGAIN(right));
	switch(cp->dev) {
        case SB_MIC_PORT:
	    src = SBP_MIC_VOL;
	    if (cp->un.value.num_channels != 1)
		error = EINVAL;
	    else
		/* handle funny microphone gain */
		gain = SBP_AGAIN_TO_MICGAIN(left);
	    break;
        case SB_LINE_IN_PORT:
	    src = SBP_LINE_VOL;
	    break;
        case SB_DAC_PORT:
	    src = SBP_DAC_VOL;
	    break;
        case SB_FM_PORT:
	    src = SBP_FM_VOL;
	    break;
        case SB_CD_PORT:
	    src = SBP_CD_VOL;
	    break;
d1452 70
a1521 10
	    cp->dev = SB_MASTER_VOL;
        case SB_MASTER_VOL:
	    src = SBP_MASTER_VOL;
	    break;
#if 0
	case SB_OUTPUT_MODE:
	    if (cp->type == AUDIO_MIXER_ENUM)
		return sbdsp_set_channels(addr, cp->un.ord);
	    /* fall through...carefully! */
#endif
d1523 13
a1535 15
	    if (cp->type == AUDIO_MIXER_ENUM)
		return sbdsp_set_in_port(addr, cp->un.ord);
	    /* else fall through: bad input */
        case SB_TREBLE:
        case SB_BASS:
        default:
	    error =  EINVAL;
	    break;
	}
	if (!error)
	sbdsp_mix_write(sc, src, gain);
    }    
    else if (cp->dev != SB_MIC_PORT &&
	     cp->dev != SB_SPEAKER)
	error = EINVAL;
d1537 3
a1539 2
    if (!error)
	sc->gain[cp->dev] = gain;
d1541 1
a1541 1
    return(error);
d1546 2
a1547 2
    void *addr;
    mixer_ctrl_t *cp;
d1549 2
a1550 3
    register struct sbdsp_softc *sc = addr;
    int error = 0;
    int done = 0;
d1552 1
a1552 1
    DPRINTF(("sbdsp_mixer_get_port: port=%d", cp->dev));
d1554 1
a1554 9
    if (ISSBPROCLASS(sc))
    switch(cp->dev) {
    case SB_MIC_PORT:
	    if (cp->un.value.num_channels == 1) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		    SBP_MICGAIN_TO_AGAIN(sc->gain[cp->dev]);
		return 0;
    }
	    else
d1556 5
a1560 1
	    break;
d1562 32
a1593 18
        case SB_DAC_PORT:
        case SB_FM_PORT:
        case SB_CD_PORT:
        case SB_MASTER_VOL:
	    break;
	case SB_SPEAKER:
	    cp->dev = SB_MASTER_VOL;
	    break;
        default:
	    error =  EINVAL;
	    break;
	}
    else {
	if (cp->un.value.num_channels != 1) /* no stereo on SB classic */
	    error = EINVAL;
    else
	    switch(cp->dev) {
	    case SB_MIC_PORT:
d1595 16
a1610 1
	    case SB_SPEAKER:
d1612 6
a1617 19
	    default:
	error = EINVAL;
		break;
	    }
    }
    if (error == 0) {
	if (cp->un.value.num_channels == 1) {
	    cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
		SBP_SBGAIN_TO_AGAIN(sc->gain[cp->dev]);
	}
	else if (cp->un.value.num_channels == 2) {
	    cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
		SBP_LEFTGAIN(sc->gain[cp->dev]);
	    cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
		SBP_RIGHTGAIN(sc->gain[cp->dev]);
	} else
	    return EINVAL;
    }
    return(error);
d1622 2
a1623 2
    void *addr;
    register mixer_devinfo_t *dip;
d1625 39
a1663 2
    register struct sbdsp_softc *sc = addr;
    int done = 0;
d1665 21
a1685 1
    DPRINTF(("sbdsp_mixer_query_devinfo: index=%d\n", dip->index));
d1687 9
a1695 122
    switch (dip->index) {
    case SB_MIC_PORT:
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = SB_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = AUDIO_MIXER_LAST;
	strcpy(dip->label.name, AudioNmicrophone);
	dip->un.v.num_channels = 1;
	strcpy(dip->un.v.units.name, AudioNvolume);
	done = 1;
	break;
    case SB_SPEAKER:
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = SB_OUTPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = AUDIO_MIXER_LAST;
	strcpy(dip->label.name, AudioNspeaker);
	dip->un.v.num_channels = 1;
	strcpy(dip->un.v.units.name, AudioNvolume);
	done = 1;
	break;
    case SB_INPUT_CLASS:
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = SB_INPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strcpy(dip->label.name, AudioCInputs);
	done = 1;
	break;
    case SB_OUTPUT_CLASS:
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = SB_OUTPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strcpy(dip->label.name, AudioCOutputs);
	done = 1;
	break;
    }

    if (!done) {
    if (ISSBPROCLASS(sc))
	switch(dip->index) {
	case SB_LINE_IN_PORT:
	    dip->type = AUDIO_MIXER_VALUE;
	    dip->mixer_class = SB_INPUT_CLASS;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNline);
	    dip->un.v.num_channels = 2;
	    strcpy(dip->un.v.units.name, AudioNvolume);
	    break;
	case SB_DAC_PORT:
	    dip->type = AUDIO_MIXER_VALUE;
	    dip->mixer_class = SB_OUTPUT_CLASS;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNdac);
	    dip->un.v.num_channels = 2;
	    strcpy(dip->un.v.units.name, AudioNvolume);
	    break;
	case SB_CD_PORT:
	    dip->type = AUDIO_MIXER_VALUE;
	    dip->mixer_class = SB_INPUT_CLASS;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNcd);
	    dip->un.v.num_channels = 2;
	    strcpy(dip->un.v.units.name, AudioNvolume);
	    break;
	case SB_FM_PORT:
	    dip->type = AUDIO_MIXER_VALUE;
	    dip->mixer_class = SB_OUTPUT_CLASS;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNfmsynth);
	    dip->un.v.num_channels = 2;
	    strcpy(dip->un.v.units.name, AudioNvolume);
	    break;
	case SB_MASTER_VOL:
	    dip->type = AUDIO_MIXER_VALUE;
	    dip->mixer_class = SB_OUTPUT_CLASS;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = /*TREBLE, BASS not handled, nor is SB_OUTPUT_MODE*/SB_RECORD_SOURCE;
	    strcpy(dip->label.name, AudioNvolume);
	    dip->un.v.num_channels = 2;
	    strcpy(dip->un.v.units.name, AudioNvolume);
	    break;
#if 0
	case SB_OUTPUT_MODE:
	    dip->mixer_class = SB_OUTPUT_CLASS;
	    dip->type = AUDIO_MIXER_ENUM;
	    dip->prev = SB_MASTER_VOL;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNmode);
	    dip->un.e.num_mem = 2;
	    strcpy(dip->un.e.member[0].label.name, AudioNmono);
	    dip->un.e.member[0].ord = 1; /* nchans */
	    strcpy(dip->un.e.member[1].label.name, AudioNstereo);
	    dip->un.e.member[1].ord = 2; /* nchans */
	    break;
#endif
	case SB_RECORD_SOURCE:
	    dip->mixer_class = SB_RECORD_CLASS;
	    dip->type = AUDIO_MIXER_ENUM;
	    dip->prev = AUDIO_MIXER_LAST;
	    dip->next = AUDIO_MIXER_LAST;
	    strcpy(dip->label.name, AudioNsource);
	    dip->un.e.num_mem = 3;
	    strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
	    dip->un.e.member[0].ord = SB_MIC_PORT;
	    strcpy(dip->un.e.member[1].label.name, AudioNcd);
	    dip->un.e.member[1].ord = SB_CD_PORT;
	    strcpy(dip->un.e.member[2].label.name, AudioNline);
	    dip->un.e.member[2].ord = SB_LINE_IN_PORT;
	    break;
	case SB_BASS:
	case SB_TREBLE:
	default:
	    return ENXIO;
	    /*NOTREACHED*/
	} 
    else
	return ENXIO;
    }
d1697 69
a1765 1
    DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));
d1767 1
a1767 1
    return 0;
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d1 2
a2 1
/*	$NetBSD: sbdsp.c,v 1.14 1995/11/10 05:01:06 mycroft Exp $	*/
d85 34
d125 4
a128 4
	printf("open %d dmachan %d iobase %x locked %d\n", sc->sc_open, sc->sc_drq,
		sc->sc_iobase, sc->sc_locked);
	printf("hispeed %d irate %d orate %d encoding %x\n",
		sc->sc_adacmode, sc->sc_irate, sc->sc_orate, sc->encoding);
d130 3
a132 3
		sc->out_port, sc->in_port, sc->spkr_state, sc->sc_interrupts);
	printf("tc %x chans %x scintr %x arg %x\n", sc->sc_adactc, sc->sc_chans,
		sc->sc_intr, sc->sc_arg);
d135 1
a135 1
	    printf("%d ", sc->gain[i]);
a171 2
	sc->sc_locked = 0;

d174 1
a174 1
	    sc->sc_irate = sc->sc_orate = 45454;
d176 1
a176 1
	    sc->sc_irate = sc->sc_orate = 14925;
a179 3
	(void) sbdsp_set_in_sr_real(sc, sc->sc_irate);
	(void) sbdsp_set_out_sr_real(sc, sc->sc_orate);

d199 1
a199 1
		    sc->gain[i] = sbdsp_stereo_vol(SBP_MAXVOL, SBP_MAXVOL);
d201 1
d241 1
a241 19
	sc->sc_irate = sr;

	return 0;
}

int
sbdsp_set_in_sr_real(addr, sr)
	void *addr;
	u_long sr;
{
	register struct sbdsp_softc *sc = addr;
	int rval;

	if (rval = sbdsp_set_sr(sc, &sr, SB_INPUT_RATE))
		return rval;
	sc->sc_irate = sr;
	sc->sc_dmain_inprogress = 0;		/* do it again on next DMA out */
	sc->sc_dmaout_inprogress = 0;
	return(0);
d250 1
a250 1
	return(sc->sc_irate);
d260 1
a260 17
	sc->sc_orate = sr;
	return(0);
}

int
sbdsp_set_out_sr_real(addr, sr)
	void *addr;
	u_long sr;
{
	register struct sbdsp_softc *sc = addr;
	int rval;

	if (rval = sbdsp_set_sr(sc, &sr, SB_OUTPUT_RATE))
		return rval;
	sc->sc_orate = sr;
	sc->sc_dmain_inprogress = 0;		/* do it again on next DMA out */
	return(0);
d269 1
a269 1
	return(sc->sc_orate);
d274 2
a275 2
    void *addr;
    struct audio_encoding *fp;
d277 1
a277 1
    register struct sbdsp_softc *sc = addr;
d279 13
a291 14
    switch (fp->index) {
    case 0:
	strcpy(fp->name, AudioEmulaw);
	fp->format_id = AUDIO_ENCODING_ULAW;
	break;
    case 1:
	strcpy(fp->name, AudioEpcm16);
	fp->format_id = AUDIO_ENCODING_PCM16;
	break;
    default:
	return(EINVAL);
	/*NOTREACHED*/
    }
    return (0);
d320 1
a320 1
	return(sc->encoding);
d330 2
a331 2
		return(EINVAL);
	return(0);
d338 1
a338 1
	return(8);
a346 1
	int rval;
d350 2
a351 1
			return(EINVAL);
d353 1
a353 1
		sc->sc_chans = chans;
d355 3
a357 1
		    return rval;
d364 1
a364 2
	}
	else {
d366 2
a367 2
			return(EINVAL);
		sc->sc_chans = 1;
d370 1
a370 1
	return(0);
d382 1
a382 1
		if ((sbdsp_mix_read(sc, SBP_STEREO) & SBP_PLAYMODE_MASK) == SBP_PLAYMODE_STEREO) {
d384 1
a384 2
		}
		else {
d386 1
a386 3
		}
	}
	else {
a387 1
	}
d390 1
a390 1
	return(sc->sc_chans);
d402 1
a402 1
	return(0);
d411 1
a411 1
	return(sc->out_port);
d424 27
a450 30
	    switch (port) {
	    case SB_MIC_PORT:
		sbport = SBP_FROM_MIC;
		mixport = SBP_MIC_VOL;
		break;
	    case SB_LINE_IN_PORT:
		sbport = SBP_FROM_LINE;
		mixport = SBP_LINE_VOL;
		break;
	    case SB_CD_PORT:
		sbport = SBP_FROM_CD;
		mixport = SBP_CD_VOL;
		break;
	    case SB_DAC_PORT:
	    case SB_FM_PORT:
	    default:
		return(EINVAL);
		/*NOTREACHED*/
	    }
	}
	else {
	    switch (port) {
	    case SB_MIC_PORT:
		sbport = SBP_FROM_MIC;
		mixport = SBP_MIC_VOL;
		break;
	    default:
		return(EINVAL);
		/*NOTREACHED*/
	    }
d464 1
a464 1
	return(0);
d473 1
a473 1
	return(sc->in_port);
d504 1
a504 1
	sc->sc_last_hsr_size = sc->sc_last_hsw_size = 0;
d507 1
a507 1
	if ((sc->sc_orate > 8000 || sc->sc_irate > 8000) &&
d511 2
a512 1
	if (blk > NBPG) blk = NBPG;
d516 1
a516 1
		return(blk);	/* Anything goes :-) */
d523 2
d530 5
a534 1
	register struct sbdsp_softc *sc = addr;
d536 1
a536 5
	sbdsp_set_out_sr_real(addr, sc->sc_orate);
	sbdsp_set_in_sr_real(addr, sc->sc_irate);

	sc->sc_last_hsw_size = sc->sc_last_hsr_size = 0;
	return(0);
a552 3
	sc->sc_intr = 0;
	sc->sc_arg = 0;
	sc->sc_locked = 0;
a557 2
	sc->sc_dmain_inprogress = 0;
	sc->sc_dmaout_inprogress = 0;
a580 1
	sc->sc_intr = 0;
d582 1
a582 2
	/* XXX this will turn off any dma */
	sbdsp_reset(sc);
d601 7
a607 4
	/*
	 * erase any memory of last transfer size.
	 */
	sc->sc_last_hsr_size = sc->sc_last_hsw_size = 0;
d614 1
a614 1
	delay(3);
d616 1
d619 1
d634 5
a638 3
		if ((inb(iobase + SBP_DSP_WSTAT) & SB_DSP_BUSY) != 0) {
			delay(10); continue;
		}
d640 1
d656 4
a659 1
		if ((inb(iobase + SBP_DSP_RSTAT) & SB_DSP_READY) == 0)
d661 3
a663 1
		return inb(iobase + SBP_DSP_READ);
d749 2
a750 12
	if (sc->sc_locked)
		sbdsp_reset(sc);
	else
		(void)sbdsp_wdsp(sc->sc_iobase, SB_DSP_HALT);

	isa_dmaabort(sc->sc_drq);
	sc->dmaaddr = 0;
	sc->dmacnt = 0;
	sc->sc_locked = 0;
	sc->dmaflags = 0;
	sc->sc_dmain_inprogress = sc->sc_dmaout_inprogress = 0;
	return(0);
a766 33
 * Time constant routines follow.  See SBK, section 12.
 * Although they don't come out and say it (in the docs),
 * the card clearly uses a 1MHz countdown timer, as the
 * low-speed formula (p. 12-4) is:
 *	tc = 256 - 10^6 / sr
 * In high-speed mode, the constant is the upper byte of a 16-bit counter,
 * and a 256MHz clock is used:
 *	tc = 65536 - 256 * 10^ 6 / sr
 * Since we can only use the upper byte of the HS TC, the two formulae
 * are equivalent.  (Why didn't they say so?)  E.g.,
 * 	(65536 - 256 * 10 ^ 6 / x) >> 8 = 256 - 10^6 / x
 *
 * The crossover point (from low- to high-speed modes) is different
 * for the SBPRO and SB20.  The table on p. 12-5 gives the following data:
 *
 *				SBPRO			SB20
 *				-----			--------
 * input ls min			4	KHz		4	KHz
 * input ls max			23	KHz		13	KHz
 * input hs max			44.1	KHz		15	KHz
 * output ls min		4	KHz		4	KHz
 * output ls max		23	KHz		23	KHz
 * output hs max		44.1	KHz		44.1	KHz
 */
#define SB_LS_MIN	0x06	/* 4000 Hz */
#define SBPRO_ADC_LS_MAX	0xd4	/* 22727 Hz */
#define SBPRO_ADC_HS_MAX	0xea	/* 45454 Hz */
#define SBCLA_ADC_LS_MAX	0xb3	/* 12987 Hz */
#define SBCLA_ADC_HS_MAX	0xbd	/* 14925 Hz */
#define SB_DAC_LS_MAX	0xd4	/* 22727 Hz */
#define SB_DAC_HS_MAX	0xea	/* 45454 Hz */

/*
d775 1
a775 1
sbdsp_srtotc(sc, sr, mode, isdac)
a777 1
	int *mode;
d779 1
d781 1
a781 2
	int adc_ls_max, adc_hs_max;
	register int tc;
d784 3
a786 2
		*mode = SB_ADAC_LS;
		return SB_LS_MIN;
d788 2
a789 1
	tc = 256 - 1000000 / sr;
a790 11
	/* XXX use better rounding--compare distance to nearest tc on both
	   sides of requested speed */
	if (ISSBPROCLASS(sc)) {
		adc_ls_max = SBPRO_ADC_LS_MAX;
		adc_hs_max = SBPRO_ADC_HS_MAX;
	}
	else {
		adc_ls_max = SBCLA_ADC_LS_MAX;
		adc_hs_max = SBCLA_ADC_HS_MAX;
	}
	    
d793 2
a794 1
		*mode = SB_ADAC_LS;
d797 1
a797 1
			*mode = SB_ADAC_LS;
d799 1
a799 1
			*mode = SB_ADAC_HS;
d804 12
d817 1
a817 1
			*mode = SB_ADAC_LS;
d819 1
a819 1
			*mode = SB_ADAC_HS;
d824 5
a828 1
	return tc;
d854 1
a854 1
sbdsp_set_sr(sc, srp, isdac)
d856 1
a856 2
	u_long *srp;
	int isdac;
a857 3
	register int tc;
	int mode;
	int sr = *srp;
d864 2
a865 9
	if (ISSBPRO(sc) && sc->sc_chans == 2) {
		if (sr > 22727)
			sr = 22727;	/* Can't bounce it...order of
					   operations may yield bogus
					   sr here. */
		sr *= 2;
	}
	else if (!ISSBPROCLASS(sc) && sc->sc_chans != 1)
		return EINVAL;
d867 1
a867 2
	tc = sbdsp_srtotc(sc, sr, &mode, isdac);
	DPRINTF(("sbdsp_set_sr: sc=0x%x sr=%d mode=0x%x\n", sc, sr, mode));
d872 1
a872 1
		return EIO;
d874 1
a874 9
	sr = sbdsp_tctosr(sc, tc);
	if (ISSBPRO(sc) && sc->sc_chans == 2)
		*srp = sr / 2;
	else
		*srp = sr;

	sc->sc_adacmode = mode;
	sc->sc_adactc = tc;
	return 0;
d896 1
d898 14
a911 8
	if (ISSBPROCLASS(sc) && !sc->sc_dmain_inprogress) {
		if (sc->sc_chans == 2) {
			if (sbdsp_wdsp(iobase, SB_DSP_RECORD_STEREO) < 0)
				goto badmode;
			sbdsp_mix_write(sc, SBP_STEREO,
					sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK);
			sbdsp_mix_write(sc, SBP_INFILTER,
					sbdsp_mix_read(sc, SBP_INFILTER) | SBP_FILTER_OFF);
d913 3
a915 12
		else {
			if (sbdsp_wdsp(iobase, SB_DSP_RECORD_MONO) < 0)
				goto badmode;
			sbdsp_mix_write(sc, SBP_STEREO,
					sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK);
			sbdsp_mix_write(sc, SBP_INFILTER,
					sc->sc_irate <= 8000 ? 
					sbdsp_mix_read(sc, SBP_INFILTER) & ~SBP_FILTER_MASK :
					sbdsp_mix_read(sc, SBP_INFILTER) | SBP_FILTER_OFF);
		}
		sc->sc_dmain_inprogress = 1;
		sc->sc_last_hsr_size = 0;	/* restarting */
a916 1
	sc->sc_dmaout_inprogress = 0;
d924 2
a925 1
	if (sc->sc_adacmode == SB_ADAC_LS) {
d929 1
d934 1
a934 1
		if (cc != sc->sc_last_hsr_size) {
d937 2
a938 1
			    sbdsp_wdsp(iobase, cc >> 8) < 0)
d940 2
d943 2
a944 1
		if (sbdsp_wdsp(iobase, SB_DSP_HS_INPUT) < 0)
d946 1
a946 2
		sc->sc_last_hsr_size = cc;
		sc->sc_locked = 1;
a950 1
	isa_dmaabort(sc->sc_drq);
a951 2
	sc->sc_intr = 0;
	sc->sc_arg = 0;
d953 1
d975 1
a975 1
	if (sc->sc_chans == 2 && cc & 1) {
d980 12
a991 9
	if (ISSBPROCLASS(sc) && !sc->sc_dmaout_inprogress) {
		/* make sure we re-set stereo mixer bit when we start
		   output. */
		sbdsp_mix_write(sc, SBP_STEREO,
				(sbdsp_mix_read(sc, SBP_STEREO) & ~SBP_PLAYMODE_MASK) |
				(sc->sc_chans == 2 ?
				 SBP_PLAYMODE_STEREO : SBP_PLAYMODE_MONO));
		sc->sc_dmaout_inprogress = 1;
		sc->sc_last_hsw_size = 0;	/* restarting */
d993 1
a993 1
	sc->sc_dmain_inprogress = 0;
d1001 1
a1001 2
	iobase = sc->sc_iobase;
	if (sc->sc_adacmode == SB_ADAC_LS) {
d1010 3
a1012 10
		if (cc != sc->sc_last_hsw_size) {
			if (sbdsp_wdsp(iobase, SB_DSP_BLOCKSIZE) < 0) {
				/* sometimes fails initial startup?? */
				delay(100);
				if (sbdsp_wdsp(iobase, SB_DSP_BLOCKSIZE) < 0) {
					DPRINTF(("sbdsp_dma_output: BLOCKSIZE failed\n"));
					goto giveup;
				}
			}
			if (sbdsp_wdsp(iobase, cc) < 0 ||
d1017 1
a1017 1
			sc->sc_last_hsw_size = cc;
d1020 2
a1021 5
			delay(100);
			if (sbdsp_wdsp(iobase, SB_DSP_HS_OUTPUT) < 0) {
				DPRINTF(("sbdsp_dma_output: HS DMA restart failed\n"));
				goto giveup;
			}
a1022 1
		sc->sc_locked = 1;
a1023 1

d1026 1
a1026 2
 giveup:
	isa_dmaabort(sc->sc_drq);
a1027 2
	sc->sc_intr = 0;
	sc->sc_arg = 0;
d1043 1
a1049 1
	sc->sc_locked = 0;
d1051 8
a1058 1
	inb(sc->sc_iobase + SBP_DSP_RSTAT);
d1061 2
a1062 2
		int c = sbdsp_rdsp(sc->sc_iobase);
		(*sc->sc_mintr)(sc->sc_arg, c);
d1066 9
a1074 9
	    /*
	     * The SBPro used to develop and test this driver often
	     * generated dma underruns--it interrupted to signal
	     * completion of the DMA input recording block, but the
	     * ISA DMA controller didn't think the channel was
	     * finished.  Maybe this is just a bus speed issue, I dunno,
	     * but it seems strange and leads to channel-flipping with stereo
	     * recording.  Sigh.
	     */
a1076 3
		sc->dmaflags = 0;
		sc->dmaaddr = 0;
		sc->dmacnt = 0;
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: sbdsp.c,v 1.13 1995/07/19 19:58:54 brezak Exp $	*/
d116 1
a116 1
	register u_short iobase = sc->sc_iobase;
d135 1
a135 1
	register u_short iobase = sc->sc_iobase;
d613 1
a613 1
	register u_short iobase = sc->sc_iobase;
d638 1
a638 1
sbdsp_wdsp(u_short iobase, int v)
d657 1
a657 1
sbdsp_rdsp(u_short iobase)
d728 1
a728 1
	register u_short iobase = sc->sc_iobase;
d899 1
a899 1
	register u_short iobase;
d943 1
a943 2
	register u_short iobase;
	u_int phys;
d1026 1
a1026 1
	register u_short iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
