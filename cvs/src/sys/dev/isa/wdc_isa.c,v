head	1.16;
access;
symbols
	OPENBSD_6_2:1.16.0.2
	OPENBSD_6_2_BASE:1.16
	OPENBSD_6_1:1.15.0.26
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.22
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.15.0.12
	OPENBSD_5_9_BASE:1.15
	OPENBSD_5_8:1.15.0.20
	OPENBSD_5_8_BASE:1.15
	OPENBSD_5_7:1.15.0.18
	OPENBSD_5_7_BASE:1.15
	OPENBSD_5_6:1.15.0.16
	OPENBSD_5_6_BASE:1.15
	OPENBSD_5_5:1.15.0.14
	OPENBSD_5_5_BASE:1.15
	OPENBSD_5_4:1.15.0.10
	OPENBSD_5_4_BASE:1.15
	OPENBSD_5_3:1.15.0.8
	OPENBSD_5_3_BASE:1.15
	OPENBSD_5_2:1.15.0.6
	OPENBSD_5_2_BASE:1.15
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.13.0.12
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.13.0.10
	OPENBSD_4_8_BASE:1.13
	OPENBSD_4_7:1.13.0.6
	OPENBSD_4_7_BASE:1.13
	OPENBSD_4_6:1.13.0.8
	OPENBSD_4_6_BASE:1.13
	OPENBSD_4_5:1.13.0.4
	OPENBSD_4_5_BASE:1.13
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.8
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.12.0.6
	OPENBSD_4_2_BASE:1.12
	OPENBSD_4_1:1.12.0.4
	OPENBSD_4_1_BASE:1.12
	OPENBSD_4_0:1.12.0.2
	OPENBSD_4_0_BASE:1.12
	OPENBSD_3_9:1.11.0.10
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.11.0.8
	OPENBSD_3_8_BASE:1.11
	OPENBSD_3_7:1.11.0.6
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.11.0.4
	OPENBSD_3_6_BASE:1.11
	SMP_SYNC_A:1.11
	SMP_SYNC_B:1.11
	OPENBSD_3_5:1.11.0.2
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.9.0.8
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.9.0.6
	OPENBSD_3_3_BASE:1.9
	OPENBSD_3_2:1.9.0.4
	OPENBSD_3_2_BASE:1.9
	OPENBSD_3_1:1.9.0.2
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.9
	UBC:1.7.0.6
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.16
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.15;
commitid	uRv5pa9QDlZaYgwD;

1.15
date	2011.06.20.01.09.25;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2006.08.26.14.55.35;	author jsg;	state Exp;
branches;
next	1.11;

1.11
date	2004.01.15.17.51.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.17.08.14.09;	author grange;	state Exp;
branches;
next	1.9;

1.9
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.25.13.11.58;	author csapuntz;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	2001.01.29.00.20.17;	author csapuntz;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.20.19.15.22;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.03.42.04;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.08.05.00.12.09;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	99.07.22.04.32.38;	author csapuntz;	state Exp;
branches;
next	1.1;

1.1
date	99.07.18.21.25.18;	author csapuntz;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.24.53;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2004.02.19.10.56.23;	author niklas;	state Exp;
branches;
next	;

1.7.6.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.16
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*      $OpenBSD: wdc_isa.c,v 1.15 2011/06/20 01:09:25 matthew Exp $     */
/*	$NetBSD: wdc_isa.c,v 1.15 1999/05/19 14:41:25 bouyer Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ata/atavar.h>
#include <dev/ic/wdcvar.h>

#include "isadma.h"

#define	WDC_ISA_REG_NPORTS	8
#define	WDC_ISA_AUXREG_OFFSET	0x206
#define	WDC_ISA_AUXREG_NPORTS	1 /* XXX "fdc" owns ports 0x3f7/0x377 */

/* options passed via the 'flags' config keyword */
#define WDC_OPTIONS_32	0x01 /* try to use 32bit data I/O */

struct wdc_isa_softc {
	struct	wdc_softc sc_wdcdev;
	struct	channel_softc *wdc_chanptr;
	struct	channel_softc wdc_channel;
	struct  device *sc_isa;
	isa_chipset_tag_t sc_ic;
	void	*sc_ih;
	int	sc_drq;
};

int	wdc_isa_probe(struct device *, void *, void *);
void	wdc_isa_attach(struct device *, struct device *, void *);

struct cfattach wdc_isa_ca = {
	sizeof(struct wdc_isa_softc), wdc_isa_probe, wdc_isa_attach
};

#if NISADMA > 0
static void	wdc_isa_dma_setup(struct wdc_isa_softc *);
static int	wdc_isa_dma_init(void *, int, int, void *, size_t, int);
static void 	wdc_isa_dma_start(void *, int, int);
static int	wdc_isa_dma_finish(void *, int, int, int);
#endif	/* NISADMA > 0 */

int
wdc_isa_probe(struct device *parent, void *match, void *aux)
{
	struct channel_softc ch;
	struct isa_attach_args *ia = aux;
	struct cfdata *cf = ((struct device *)match)->dv_cfdata;
	int result = 0;

	bzero(&ch, sizeof ch);
	ch.cmd_iot = ia->ia_iot;
	if (bus_space_map(ch.cmd_iot, ia->ia_iobase, WDC_ISA_REG_NPORTS, 0,
	    &ch.cmd_ioh))
		goto out;

	ch.ctl_iot = ia->ia_iot;
	if (bus_space_map(ch.ctl_iot, ia->ia_iobase + WDC_ISA_AUXREG_OFFSET,
	    WDC_ISA_AUXREG_NPORTS, 0, &ch.ctl_ioh))
		goto outunmap;

	if (cf->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		ch.ch_flags |= WDCF_VERBOSE_PROBE;

	result = wdcprobe(&ch);
	if (result) {
		ia->ia_iosize = WDC_ISA_REG_NPORTS;
		ia->ia_msize = 0;
	}

	bus_space_unmap(ch.ctl_iot, ch.ctl_ioh, WDC_ISA_AUXREG_NPORTS);
outunmap:
	bus_space_unmap(ch.cmd_iot, ch.cmd_ioh, WDC_ISA_REG_NPORTS);
out:
	return (result);
}

void
wdc_isa_attach(struct device *parent, struct device *self, void *aux)
{
	struct wdc_isa_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;

	printf("\n");

	sc->wdc_channel.cmd_iot = ia->ia_iot;
	sc->wdc_channel.ctl_iot = ia->ia_iot;
	sc->sc_ic = ia->ia_ic;
	sc->sc_isa = parent;

	if (bus_space_map(sc->wdc_channel.cmd_iot, ia->ia_iobase,
	    WDC_ISA_REG_NPORTS, 0, &sc->wdc_channel.cmd_ioh) ||
	    bus_space_map(sc->wdc_channel.ctl_iot,
	      ia->ia_iobase + WDC_ISA_AUXREG_OFFSET, WDC_ISA_AUXREG_NPORTS,
	      0, &sc->wdc_channel.ctl_ioh)) {
		printf("%s: couldn't map registers\n",
		    sc->sc_wdcdev.sc_dev.dv_xname);
	}
	sc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;
	sc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, wdcintr, &sc->wdc_channel, sc->sc_wdcdev.sc_dev.dv_xname);

	if (ia->ia_drq != DRQUNK) {
#if NISADMA > 0
		sc->sc_drq = ia->ia_drq;

		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DMA;
		sc->sc_wdcdev.dma_arg = sc;
		sc->sc_wdcdev.dma_init = wdc_isa_dma_init;
		sc->sc_wdcdev.dma_start = wdc_isa_dma_start;
		sc->sc_wdcdev.dma_finish = wdc_isa_dma_finish;
		wdc_isa_dma_setup(sc);
#else	/* NISADMA > 0 */
		printf("%s: ignoring drq, isa dma not supported",
		    sc->sc_wdcdev.sc_dev.dv_xname);
#endif	/* NISADMA > 0 */
	}
	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_PREATA;
	if (sc->sc_wdcdev.sc_dev.dv_cfdata->cf_flags & WDC_OPTIONS_32)
		sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA32;
	sc->sc_wdcdev.PIO_cap = 0;
	sc->wdc_chanptr = &sc->wdc_channel;
	sc->sc_wdcdev.channels = &sc->wdc_chanptr;
	sc->sc_wdcdev.nchannels = 1;
	sc->wdc_channel.channel = 0;
	sc->wdc_channel.wdc = &sc->sc_wdcdev;
	sc->wdc_channel.ch_queue = wdc_alloc_queue();
	if (sc->wdc_channel.ch_queue == NULL) {
		printf("%s: cannot allocate channel queue",
		    sc->sc_wdcdev.sc_dev.dv_xname);
		return;
	}
	wdcattach(&sc->wdc_channel);
	wdc_print_current_modes(&sc->wdc_channel);
}

#if NISADMA > 0
static void
wdc_isa_dma_setup(struct wdc_isa_softc *sc)
{
	if (isa_dmamap_create(sc->sc_isa, sc->sc_drq,
	    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {			      
		printf("%s: can't create map for drq %d\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);
		sc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;
	}
}

static int
wdc_isa_dma_init(void *v, int channel, int drive, void *databuf, size_t datalen,
    int read)
{
	struct wdc_isa_softc *sc = v;

	isa_dmastart(sc->sc_isa, sc->sc_drq, databuf, datalen, NULL,
	    (read ? DMAMODE_READ : DMAMODE_WRITE),
	    BUS_DMA_NOWAIT);

	return 0;
}

static void
wdc_isa_dma_start(void *v, int channel, int drive)
{
	/* nothing to do */
}

static int
wdc_isa_dma_finish(void *v, int channel, int drive, int force)
{
	struct wdc_isa_softc *sc = v;

	isa_dmadone(sc->sc_isa, sc->sc_drq);

	return 0;
}
#endif	/* NISADMA > 0 */
@


1.15
log
@isa(4) is an indirect bus, which means that drivers that attach to it
need to provide an xxxprobe() method instead of an xxxmatch() method.
The critical difference is xxxprobe() is given a device softc for the
second argument, whereas a xxxmatch() is given the cfdata as the
second argument.

This commit fixes the handful of ISA device drivers that incorrectly
cast the second argument to a "struct cfdata *" instead of a "struct
device *".  (Minor complication: unlike isa(4), isapnp(4) is a direct
bus, and if_we.c used the same probe/match code for both; now separate
we_probe and we_match methods are used as appropriate.)

"makes sense to me" krw@@; ok miod@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.14 2011/05/09 22:33:54 matthew Exp $     */
a32 1
#include <sys/types.h>
@


1.14
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.13 2008/06/26 05:42:16 ray Exp $     */
d86 1
a86 1
	struct cfdata *cf = match;
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.12 2006/08/26 14:55:35 jsg Exp $     */
d167 1
a167 2
	sc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),
	    M_DEVBUF, M_NOWAIT);
d169 1
a169 1
		printf("%s: can't allocate memory for command queue",
@


1.12
log
@Remove ifdef/ifndef __OpenBSD__ maze so only what we use is left.
Convert to ansi function declarations while here.
No binary change.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.11 2004/01/15 17:51:42 miod Exp $     */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@Provide explicit function argument declarations.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.10 2003/10/17 08:14:09 grange Exp $     */
a54 1
#ifdef __OpenBSD__
a55 3
#else
#define NISADMA 1
#endif
a67 1
#ifdef __OpenBSD__
a68 1
#endif
a73 3
#ifndef __OpenBSD__
int	wdc_isa_probe(struct device *, struct cfdata *, void *);
#else
a74 1
#endif
d89 1
a89 8
wdc_isa_probe(parent, match, aux)
	struct device *parent;
#ifndef __OpenBSD__
	struct cfdata *match;
#else
	void *match;
#endif
	void *aux;
d124 1
a124 3
wdc_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d135 1
a146 1
#ifdef __OpenBSD__
d149 1
a149 4
#else
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, wdcintr, &sc->wdc_channel);
#endif
d187 1
a187 2
wdc_isa_dma_setup(sc)
	struct wdc_isa_softc *sc;
a188 4
#ifndef __OpenBSD__
	if (isa_dmamap_create(sc->sc_ic, sc->sc_drq,
	    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
#else
a190 1
#endif
d198 2
a199 6
wdc_isa_dma_init(v, channel, drive, databuf, datalen, read)
	void *v;
	int channel, drive;
	void *databuf;
	size_t datalen;
	int read;
a202 5
#ifndef __OpenBSD__
	isa_dmastart(sc->sc_ic, sc->sc_drq, databuf, datalen, NULL,
	    (read ? DMAMODE_READ : DMAMODE_WRITE) | DMAMODE_DEMAND,
	    BUS_DMA_NOWAIT);
#else
d206 1
a206 1
#endif
d211 1
a211 3
wdc_isa_dma_start(v, channel, drive)
	void *v;
	int channel, drive;
d217 1
a217 4
wdc_isa_dma_finish(v, channel, drive, force)
	void *v;
	int channel, drive;
	int force;
a220 3
#ifndef __OpenBSD__
	isa_dmadone(sc->sc_ic, sc->sc_drq);
#else
d222 1
a222 1
#endif
@


1.10
log
@Merge an old fix from NetBSD:
- do not stop/unload current DMA operation if an IRQ was not detected
  by DMA engine unless the force flag was given, fixes DMA problems
  in shared IRQ setups;
- ack interrupt before entering DMA codepath

Tested by many.
Work by niklas@@ but he doesn't want to commit it for some reason.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.9 2002/03/14 03:16:05 millert Exp $     */
d228 1
@


1.9
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.8 2002/03/14 01:26:56 millert Exp $     */
d95 1
a95 1
static int	wdc_isa_dma_finish(void *, int, int);
d255 1
a255 1
wdc_isa_dma_finish(v, channel, drive)
d258 1
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.7 2001/03/25 13:11:58 csapuntz Exp $     */
d93 3
a95 3
static int	wdc_isa_dma_init(void*, int, int, void *, size_t, int);
static void 	wdc_isa_dma_start(void*, int, int);
static int	wdc_isa_dma_finish(void*, int, int);
@


1.7
log
@Minor mods to DMA interface - get rid of unnecessary args. Allow DMA functions to return status flags.

Note: Changing code to have DMA interface indicate when I/O is done (a la NetBSD) was considered. It was rejected due to questionable backward compatability
with ISA DMA and MAC obio DMA

Added irqack from NetBSD (though this feature should really be in the
PCI interrupt handlers)

Use pool
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.6 2001/01/29 00:20:17 csapuntz Exp $     */
d81 1
a81 1
int	wdc_isa_probe	__P((struct device *, struct cfdata *, void *));
d83 1
a83 1
int	wdc_isa_probe	__P((struct device *, void *, void *));
d85 1
a85 1
void	wdc_isa_attach	__P((struct device *, struct device *, void *));
d92 4
a95 4
static void	wdc_isa_dma_setup __P((struct wdc_isa_softc *));
static int	wdc_isa_dma_init __P((void*, int, int, void *, size_t, int));
static void 	wdc_isa_dma_start __P((void*, int, int));
static int	wdc_isa_dma_finish __P((void*, int, int));
@


1.7.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.7 2001/03/25 13:11:58 csapuntz Exp $     */
d81 1
a81 1
int	wdc_isa_probe(struct device *, struct cfdata *, void *);
d83 1
a83 1
int	wdc_isa_probe(struct device *, void *, void *);
d85 1
a85 1
void	wdc_isa_attach(struct device *, struct device *, void *);
d92 4
a95 4
static void	wdc_isa_dma_setup(struct wdc_isa_softc *);
static int	wdc_isa_dma_init(void *, int, int, void *, size_t, int);
static void 	wdc_isa_dma_start(void *, int, int);
static int	wdc_isa_dma_finish(void *, int, int);
@


1.6
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.5 2000/07/20 19:15:22 csapuntz Exp $     */
d94 2
a95 2
static void 	wdc_isa_dma_start __P((void*, int, int, int));
static int	wdc_isa_dma_finish __P((void*, int, int, int));
d247 1
a247 1
wdc_isa_dma_start(v, channel, drive, read)
d255 1
a255 1
wdc_isa_dma_finish(v, channel, drive, read)
a257 1
	int read;
@


1.5
log
@

chp->wdc can be NULL on probe.

Propagate verbose flag from cf_data to channel
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.4 1999/10/09 03:42:04 csapuntz Exp $     */
d204 1
@


1.4
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.3 1999/08/05 00:12:09 niklas Exp $     */
d110 1
d123 3
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.7 2001/03/25 13:11:58 csapuntz Exp $     */
d94 2
a95 2
static void 	wdc_isa_dma_start __P((void*, int, int));
static int	wdc_isa_dma_finish __P((void*, int, int));
a109 1
	struct cfdata *cf = match;
a122 3
	if (cf->cf_flags & WDC_OPTION_PROBE_VERBOSE)
		ch.ch_flags |= WDCF_VERBOSE_PROBE;

a199 1
	wdc_print_current_modes(&sc->wdc_channel);
d242 1
a242 1
wdc_isa_dma_start(v, channel, drive)
d250 1
a250 1
wdc_isa_dma_finish(v, channel, drive)
d253 1
@


1.4.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*      $OpenBSD$     */
d81 1
a81 1
int	wdc_isa_probe(struct device *, struct cfdata *, void *);
d83 1
a83 1
int	wdc_isa_probe(struct device *, void *, void *);
d85 1
a85 1
void	wdc_isa_attach(struct device *, struct device *, void *);
d92 4
a95 4
static void	wdc_isa_dma_setup(struct wdc_isa_softc *);
static int	wdc_isa_dma_init(void *, int, int, void *, size_t, int);
static void 	wdc_isa_dma_start(void *, int, int);
static int	wdc_isa_dma_finish(void *, int, int);
@


1.4.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d95 1
a95 1
static int	wdc_isa_dma_finish(void *, int, int, int);
a227 1
	int channel, drive;
d255 1
a255 1
wdc_isa_dma_finish(v, channel, drive, force)
a257 1
	int force;
@


1.3
log
@Make IDE compile on alpha again:
use b* instead of mem* functions, adhere to NISADMA for DMA support.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.2 1999/07/22 04:32:38 csapuntz Exp $     */
a199 1
	wdc_final_attach(&sc->wdc_channel);
@


1.2
log
@

Fix isa_dmamap_* calls to take the correct first argument.
@
text
@d1 1
a1 1
/*      $OpenBSD: wdc_isa.c,v 1.1 1999/07/18 21:25:18 csapuntz Exp $     */
d55 6
d91 1
d96 1
d108 1
a108 1
	struct channel_softc ch = { 0 };
d112 1
d169 1
d178 4
d196 1
a196 1
		sc->sc_wdcdev.sc_dev.dv_xname);
d203 1
d265 1
@


1.1
log
@

Import of NetBSD ATA/IDE stuff.

Introduction of home-grown

To enable this stuff in your configuration, look at the NEWATA conf file
and go through

dev/isa/files.isa
dev/pci/files.pci
conf/files
arch/i386/conf/files.i386

and follow the instructions on commenting/uncommenting stuff
@
text
@d1 1
a1 1
/*      $OpenBSD: $     */
d66 3
d140 1
d193 1
d196 4
d215 1
d217 6
a222 5
	    (read ? DMAMODE_READ : DMAMODE_WRITE)
#ifndef __OpenBSD__
| DMAMODE_DEMAND,
#else 
,
a223 1
	    BUS_DMA_NOWAIT);
d243 1
d245 3
@

