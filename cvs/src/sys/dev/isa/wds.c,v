head	1.42;
access;
symbols
	OPENBSD_6_1_BASE:1.42
	OPENBSD_6_0:1.42.0.8
	OPENBSD_6_0_BASE:1.42
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.6
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.42.0.4
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.4
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.39.0.10
	OPENBSD_5_4_BASE:1.39
	OPENBSD_5_3:1.39.0.8
	OPENBSD_5_3_BASE:1.39
	OPENBSD_5_2:1.39.0.6
	OPENBSD_5_2_BASE:1.39
	OPENBSD_5_1_BASE:1.39
	OPENBSD_5_1:1.39.0.4
	OPENBSD_5_0:1.39.0.2
	OPENBSD_5_0_BASE:1.39
	OPENBSD_4_9:1.37.0.4
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.32.0.2
	OPENBSD_4_7_BASE:1.32
	OPENBSD_4_6:1.28.0.6
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.2
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.24.0.4
	OPENBSD_4_4_BASE:1.24
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.23.0.4
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.22.0.4
	OPENBSD_4_0_BASE:1.22
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.20.0.4
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.12
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.10
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.8
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.6
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.4
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.18.0.2
	OPENBSD_3_1_BASE:1.18
	UBC_SYNC_B:1.18
	UBC:1.17.0.6
	UBC_BASE:1.17
	OPENBSD_3_0:1.17.0.4
	OPENBSD_3_0_BASE:1.17
	OPENBSD_2_9_BASE:1.17
	OPENBSD_2_9:1.17.0.2
	OPENBSD_2_8:1.16.0.10
	OPENBSD_2_8_BASE:1.16
	OPENBSD_2_7:1.16.0.8
	OPENBSD_2_7_BASE:1.16
	SMP:1.16.0.6
	SMP_BASE:1.16
	kame_19991208:1.16
	OPENBSD_2_6:1.16.0.4
	OPENBSD_2_6_BASE:1.16
	OPENBSD_2_5:1.16.0.2
	OPENBSD_2_5_BASE:1.16
	OPENBSD_2_4:1.13.0.4
	OPENBSD_2_4_BASE:1.13
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.2
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.42
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.41;
commitid	uzzBR7hz9ncd4O6G;

1.41
date	2014.04.28.10.06.37;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2011.06.29.12.17.40;	author tedu;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.03.12.42.36;	author krw;	state Exp;
branches;
next	1.37;

1.37
date	2010.07.02.02.29.45;	author tedu;	state Exp;
branches;
next	1.36;

1.36
date	2010.06.28.18.31.02;	author krw;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.34;

1.34
date	2010.05.20.00.55.17;	author krw;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.23.01.57.20;	author krw;	state Exp;
branches;
next	1.32;

1.32
date	2010.01.10.00.10.23;	author krw;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.24.19.48.50;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.05.11.49.36;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2009.08.26.22.29.09;	author jasper;	state Exp;
branches;
next	1.28;

1.28
date	2009.02.16.21.19.07;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.25;

1.25
date	2008.09.12.11.14.04;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2007.11.05.17.12.41;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.12.03.17.13.22;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.17.18.07.36;	author jfb;	state Exp;
branches;
next	1.19;

1.19
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.29.07.04.10;	author mickey;	state Exp;
branches
	1.17.6.1;
next	1.16;

1.16
date	99.02.13.00.59.28;	author fgsch;	state Exp;
branches
	1.16.6.1;
next	1.15;

1.15
date	99.01.24.15.58.54;	author mickey;	state Exp;
branches;
next	1.14;

1.14
date	99.01.07.06.14.49;	author niklas;	state Exp;
branches;
next	1.13;

1.13
date	98.01.18.18.48.40;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.07.07.17.02.07;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.11.29.22.55.10;	author niklas;	state Exp;
branches;
next	1.10;

1.10
date	96.11.23.21.46.49;	author kstailey;	state Exp;
branches;
next	1.9;

1.9
date	96.11.12.20.30.46;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.09.08.40.53;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.10.25.08.04.20;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.16.12.33.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.06.19.14.40.35;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.05.26.00.27.32;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.05.10.12.36.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.05.07.07.38.03;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.04.21.22.24.45;	author deraadt;	state Exp;
branches;
next	;

1.16.6.1
date	2001.05.14.22.24.54;	author niklas;	state Exp;
branches;
next	1.16.6.2;

1.16.6.2
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	;

1.17.6.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.42
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@/*	$OpenBSD: wds.c,v 1.41 2014/04/28 10:06:37 jsg Exp $	*/
/*	$NetBSD: wds.c,v 1.13 1996/11/03 16:20:31 mycroft Exp $	*/

#undef	WDSDIAG
#ifdef DDB
#define	integrate
#else
#define	integrate	static inline
#endif

/*
 * XXX
 * sense data
 * aborts
 * resets
 */

/*
 * Copyright (c) 1994, 1995 Julian Highfield.  All rights reserved.
 * Portions copyright (c) 1994, 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Julian Highfield.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * This driver is for the WD7000 family of SCSI controllers:
 *   the WD7000-ASC, a bus-mastering DMA controller,
 *   the WD7000-FASST2, an -ASC with new firmware and scatter-gather,
 *   and the WD7000-ASE, which was custom manufactured for Apollo
 *      workstations and seems to include an -ASC as well as floppy
 *      and ESDI interfaces.
 *
 * Loosely based on Theo Deraadt's unfinished attempt says the NetBSD group
 * so they decided to delete the copyright that file had on it.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/buf.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <dev/isa/wdsreg.h>

#define WDS_MBX_SIZE	16

#define WDS_SCB_MAX	32
#define	SCB_HASH_SIZE	32	/* hash table size for phystokv */
#define	SCB_HASH_SHIFT	9
#define	SCB_HASH(x)	((((long)(x))>>SCB_HASH_SHIFT) & (SCB_HASH_SIZE - 1))

#define	wds_nextmbx(wmb, mbx, mbio) \
	if ((wmb) == &(mbx)->mbio[WDS_MBX_SIZE - 1])	\
		(wmb) = &(mbx)->mbio[0];		\
	else						\
		(wmb)++;

struct wds_mbx {
	struct wds_mbx_out mbo[WDS_MBX_SIZE];
	struct wds_mbx_in mbi[WDS_MBX_SIZE];
	struct wds_mbx_out *cmbo;	/* Collection Mail Box out */
	struct wds_mbx_out *tmbo;	/* Target Mail Box out */
	struct wds_mbx_in *tmbi;	/* Target Mail Box in */
};

#define	KVTOPHYS(x)	vtophys((vaddr_t)(x))

struct wds_softc {
	struct device sc_dev;
	struct isadev sc_id;
	void *sc_ih;

	bus_space_tag_t sc_iot;		/* bus identifier */
	bus_space_handle_t sc_ioh;	/* io handle */
	int sc_irq, sc_drq;

	int sc_revision;

	struct wds_mbx sc_mbx;
#define	wmbx	(&sc->sc_mbx)
	struct wds_scb *sc_scbhash[SCB_HASH_SIZE];
	TAILQ_HEAD(, wds_scb) sc_free_scb, sc_waiting_scb;
	int sc_numscbs, sc_mbofull;
	int sc_scsi_dev;
	struct scsi_link sc_link;	/* prototype for subdevs */

	struct mutex		sc_scb_mtx;
	struct scsi_iopool	sc_iopool;
};

/* Define the bounce buffer length... */
#define BUFLEN (64*1024)
/* ..and how many there are. One per device! Non-FASST boards need these. */
#define BUFCNT 8
/* The macro for deciding whether the board needs a buffer. */
#define NEEDBUFFER(sc)	(sc->sc_revision < 0x800)

struct wds_buf {
	u_char data[BUFLEN];
	int    busy;
	TAILQ_ENTRY(wds_buf) chain;
} wds_buffer[BUFCNT];

TAILQ_HEAD(, wds_buf) wds_free_buffer;

#ifdef WDSDEBUG
int wds_debug = WDSDEBUG;
#endif

integrate void    wds_wait(bus_space_tag_t, bus_space_handle_t, int, int, int);
int     wds_cmd(struct wds_softc *, u_char *, int);
integrate void wds_finish_scbs(struct wds_softc *);
int     wdsintr(void *);
integrate void wds_reset_scb(struct wds_softc *, struct wds_scb *);
void    wds_scb_free(void *, void *);
void	wds_free_buf(struct wds_softc *, struct wds_buf *);
integrate void wds_init_scb(struct wds_softc *, struct wds_scb *);
void *wds_scb_alloc(void *);
struct	wds_buf *wds_get_buf(struct wds_softc *, int);
struct	wds_scb *wds_scb_phys_kv(struct wds_softc *, u_long);
void	wds_queue_scb(struct wds_softc *, struct wds_scb *);
void	wds_collect_mbo(struct wds_softc *);
void	wds_start_scbs(struct wds_softc *);
void    wds_done(struct wds_softc *, struct wds_scb *, u_char);
int	wds_find(struct isa_attach_args *, struct wds_softc *);
void	wds_init(struct wds_softc *);
void	wds_inquire_setup_information(struct wds_softc *);
void    wdsminphys(struct buf *, struct scsi_link *);
void    wds_scsi_cmd(struct scsi_xfer *);
void	wds_sense(struct wds_softc *, struct wds_scb *);
int	wds_poll(struct wds_softc *, struct scsi_xfer *, int);
int	wds_ipoll(struct wds_softc *, struct wds_scb *, int);
void	wds_timeout(void *);
int	wdsprint(void *, const char *);

struct scsi_adapter wds_switch = {
	wds_scsi_cmd,
	wdsminphys,
	0,
	0,
};

int	wdsprobe(struct device *, void *, void *);
void	wdsattach(struct device *, struct device *, void *);

struct cfattach wds_ca = {
	sizeof(struct wds_softc), wdsprobe, wdsattach
};

struct cfdriver wds_cd = {
	NULL, "wds", DV_DULL
};

#define	WDS_ABORT_TIMEOUT	2000	/* time to wait for abort (mSec) */

integrate void
wds_wait(bus_space_tag_t iot, bus_space_handle_t ioh, int port, int mask,
    int val)
{
	while ((bus_space_read_1(iot, ioh, port) & mask) != val)
		;
}

/*
 * Write a command to the board's I/O ports.
 */
int
wds_cmd(struct wds_softc *sc,  u_int8_t *ibuf, int icnt)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_int8_t c;

	wds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);

	while (icnt--) {
		bus_space_write_1(iot, ioh, WDS_CMD, *ibuf++);
		wds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);
		c = bus_space_read_1(iot, ioh, WDS_STAT);
		if (c & WDSS_REJ)
			return 1;
	}

	return 0;
}

/*
 * Check for the presence of a WD7000 SCSI controller.
 */
int
wdsprobe(struct device *parent, void *match, void *aux)
{
	register struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;

	if (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh))
		return (0);

	/* See if there is a unit at this location. */
	rv = wds_find(ia, NULL);

	bus_space_unmap(iot, ioh, WDS_IO_PORTS);

	if (rv) {
		ia->ia_msize = 0;
		ia->ia_iosize = WDS_IO_PORTS;
	}

	return (rv);
}

int
wdsprint(void *aux, const char *name)
{
	if (name != NULL)
		printf("%s: scsibus ", name);
	return UNCONF;
}

/*
 * Attach all available units.
 */
void
wdsattach(struct device *parent, struct device *self, void *aux)
{
	struct isa_attach_args *ia = aux;
	struct wds_softc *sc = (void *)self;
	struct scsibus_attach_args saa;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;

	if (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh)) {
		printf("%s: can't map i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

	if (!wds_find(ia, sc))
		panic("wdsattach: wds_find of %s failed", self->dv_xname);
	wds_init(sc);

	if (sc->sc_drq != DRQUNK)
		isadma_cascade(sc->sc_drq);

	TAILQ_INIT(&sc->sc_free_scb);
	TAILQ_INIT(&sc->sc_waiting_scb);
	mtx_init(&sc->sc_scb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, wds_scb_alloc, wds_scb_free);

	wds_inquire_setup_information(sc);

	/*
	 * fill in the prototype scsi_link.
	 */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter_target = sc->sc_scsi_dev;
	sc->sc_link.adapter = &wds_switch;
	/* XXX */
	/* I don't think the -ASE can handle openings > 1. */
	/* It gives Vendor Error 26 whenever I try it.     */
	sc->sc_link.openings = 1;
	sc->sc_link.pool = &sc->sc_iopool;

	sc->sc_ih = isa_intr_establish(ia->ia_ic, sc->sc_irq, IST_EDGE,
	    IPL_BIO, wdsintr, sc, sc->sc_dev.dv_xname);

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	/*
	 * ask the adapter what subunits are present
	 */
	config_found(self, &saa, wdsprint);
}

integrate void
wds_finish_scbs(struct wds_softc *sc)
{
	struct wds_mbx_in *wmbi;
	struct wds_scb *scb;
	int i;

	wmbi = wmbx->tmbi;

	if (wmbi->stat == WDS_MBI_FREE) {
		for (i = 0; i < WDS_MBX_SIZE; i++) {
			if (wmbi->stat != WDS_MBI_FREE) {
				printf("%s: mbi not in round-robin order\n",
				    sc->sc_dev.dv_xname);
				goto AGAIN;
			}
			wds_nextmbx(wmbi, wmbx, mbi);
		}
#ifdef WDSDIAGnot
		printf("%s: mbi interrupt with no full mailboxes\n",
		    sc->sc_dev.dv_xname);
#endif
		return;
	}

AGAIN:
	do {
		scb = wds_scb_phys_kv(sc, phystol(wmbi->scb_addr));
		if (!scb) {
			printf("%s: bad mbi scb pointer; skipping\n",
			    sc->sc_dev.dv_xname);
			goto next;
		}

#ifdef WDSDEBUG
		if (wds_debug) {
			u_int8_t *cp = (u_int8_t *)&scb->cmd.scb;
			printf("op=%x %x %x %x %x %x\n",
			    cp[0], cp[1], cp[2], cp[3], cp[4], cp[5]);
			printf("stat %x for mbi addr = 0x%08x, ",
			    wmbi->stat, wmbi);
			printf("scb addr = 0x%x\n", scb);
		}
#endif /* WDSDEBUG */

		timeout_del(&scb->xs->stimeout);
		wds_done(sc, scb, wmbi->stat);

	next:
		wmbi->stat = WDS_MBI_FREE;
		wds_nextmbx(wmbi, wmbx, mbi);
	} while (wmbi->stat != WDS_MBI_FREE);

	wmbx->tmbi = wmbi;
}

/*
 * Process an interrupt.
 */
int
wdsintr(void *arg)
{
	struct wds_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char c;

	/* Was it really an interrupt from the board? */
	if ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) == 0)
		return 0;

	/* Get the interrupt status byte. */
	c = bus_space_read_1(iot, ioh, WDS_IRQSTAT) & WDSI_MASK;

	/* Acknowledge (which resets) the interrupt. */
	bus_space_write_1(iot, ioh, WDS_IRQACK, 0x00);

	switch (c) {
	case WDSI_MSVC:
		wds_finish_scbs(sc);
		break;

	case WDSI_MFREE:
		wds_start_scbs(sc);
		break;

	default:
		printf("%s: unrecognized interrupt type %02x",
		    sc->sc_dev.dv_xname, c);
		break;
	}

	return 1;
}

integrate void
wds_reset_scb(struct wds_softc *sc, struct wds_scb *scb)
{
	scb->flags = 0;
}

/*
 * Free the command structure, the outgoing mailbox and the data buffer.
 */
void
wds_scb_free(void *xsc, void *xscb)
{
	struct wds_softc *sc = xsc;
	struct wds_scb *scb = xscb;

	if (scb->buf) {
		wds_free_buf(sc, scb->buf);
		scb->buf = NULL;
	}

	wds_reset_scb(sc, scb);
	mtx_enter(&sc->sc_scb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_scb, scb, chain);
	mtx_leave(&sc->sc_scb_mtx);
}

void
wds_free_buf(struct wds_softc *sc, struct wds_buf *buf)
{
	int s;

	s = splbio();

	buf->busy = 0;
	TAILQ_INSERT_HEAD(&wds_free_buffer, buf, chain);

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (TAILQ_NEXT(buf, chain) == NULL)
		wakeup(&wds_free_buffer);

	splx(s);
}

integrate void
wds_init_scb(struct wds_softc *sc, struct wds_scb *scb)
{
	int hashnum;

	bzero(scb, sizeof(struct wds_scb));
	/*
	 * put in the phystokv hash table
	 * Never gets taken out.
	 */
	scb->hashkey = KVTOPHYS(scb);
	hashnum = SCB_HASH(scb->hashkey);
	scb->nexthash = sc->sc_scbhash[hashnum];
	sc->sc_scbhash[hashnum] = scb;
	wds_reset_scb(sc, scb);
}

/*
 * Get a free scb
 */
void *
wds_scb_alloc(void *xsc)
{
	struct wds_softc *sc = xsc;
	struct wds_scb *scb;

	mtx_enter(&sc->sc_scb_mtx);
	scb = TAILQ_FIRST(&sc->sc_free_scb);
	if (scb) {
		TAILQ_REMOVE(&sc->sc_free_scb, scb, chain);
		scb->flags |= SCB_ALLOC;
	}
	mtx_leave(&sc->sc_scb_mtx);

	return (scb);
}

struct wds_buf *
wds_get_buf(struct wds_softc *sc, int flags)
{
	struct wds_buf *buf;
	int s;

	s = splbio();

	for (;;) {
		buf = TAILQ_FIRST(&wds_free_buffer);
		if (buf) {
			TAILQ_REMOVE(&wds_free_buffer, buf, chain);
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;
		tsleep(&wds_free_buffer, PRIBIO, "wdsbuf", 0);
	}

	buf->busy = 1;

out:
	splx(s);
	return (buf);
}

struct wds_scb *
wds_scb_phys_kv(struct wds_softc *sc, u_long scb_phys)
{
	int hashnum = SCB_HASH(scb_phys);
	struct wds_scb *scb = sc->sc_scbhash[hashnum];

	while (scb) {
		if (scb->hashkey == scb_phys)
			break;
		/* XXX Check to see if it matches the sense command block. */
		if (scb->hashkey == (scb_phys - sizeof(struct wds_cmd)))
			break;
		scb = scb->nexthash;
	}
	return scb;
}

/*
 * Queue a SCB to be sent to the controller, and send it if possible.
 */
void
wds_queue_scb(struct wds_softc *sc, struct wds_scb *scb)
{
	TAILQ_INSERT_TAIL(&sc->sc_waiting_scb, scb, chain);
	wds_start_scbs(sc);
}

/*
 * Garbage collect mailboxes that are no longer in use.
 */
void
wds_collect_mbo(struct wds_softc *sc)
{
	struct wds_mbx_out *wmbo;	/* Mail Box Out pointer */
#ifdef WDSDIAG
	struct wds_scb *scb;
#endif

	wmbo = wmbx->cmbo;

	while (sc->sc_mbofull > 0) {
		if (wmbo->cmd != WDS_MBO_FREE)
			break;

#ifdef WDSDIAG
		scb = wds_scb_phys_kv(sc, phystol(wmbo->scb_addr));
		scb->flags &= ~SCB_SENDING;
#endif

		--sc->sc_mbofull;
		wds_nextmbx(wmbo, wmbx, mbo);
	}

	wmbx->cmbo = wmbo;
}

/*
 * Send as many SCBs as we have empty mailboxes for.
 */
void
wds_start_scbs(struct wds_softc *sc)
{
	struct wds_mbx_out *wmbo;	/* Mail Box Out pointer */
	struct wds_scb *scb;
	u_char c;

	wmbo = wmbx->tmbo;

	while ((scb = TAILQ_FIRST(&sc->sc_waiting_scb)) != NULL) {
		if (sc->sc_mbofull >= WDS_MBX_SIZE) {
			wds_collect_mbo(sc);
			if (sc->sc_mbofull >= WDS_MBX_SIZE) {
				c = WDSC_IRQMFREE;
				wds_cmd(sc, &c, sizeof c);
				break;
			}
		}

		TAILQ_REMOVE(&sc->sc_waiting_scb, scb, chain);
#ifdef WDSDIAG
		scb->flags |= SCB_SENDING;
#endif
		timeout_set(&scb->xs->stimeout, wds_timeout, scb);

		/* Link scb to mbo. */
		if (scb->flags & SCB_SENSE)
			ltophys(KVTOPHYS(&scb->sense), wmbo->scb_addr);
		else
			ltophys(KVTOPHYS(&scb->cmd), wmbo->scb_addr);
		/* XXX What about aborts? */
		wmbo->cmd = WDS_MBO_START;

		/* Tell the card to poll immediately. */
		c = WDSC_MSTART(wmbo - wmbx->mbo);
		wds_cmd(sc, &c, sizeof c);

		if ((scb->flags & SCB_POLLED) == 0)
			timeout_add_msec(&scb->xs->stimeout, scb->timeout);

		++sc->sc_mbofull;
		wds_nextmbx(wmbo, wmbx, mbo);
	}

	wmbx->tmbo = wmbo;
}

/*
 * Process the result of a SCSI command.
 */
void
wds_done(struct wds_softc *sc, struct wds_scb *scb, u_int8_t stat)
{
	struct scsi_xfer *xs = scb->xs;

	/* XXXXX */

	/* Don't release the SCB if it was an internal command. */
	if (xs == 0) {
		scb->flags |= SCB_DONE;
		return;
	}

	/* Sense handling. */
	if (xs->error == XS_SENSE) {
		bcopy(&scb->sense_data, &xs->sense, sizeof (struct scsi_sense_data));
	} else {
		if (xs->error == XS_NOERROR) {
			/* If all went well, or an error is acceptable. */
			if (stat == WDS_MBI_OK) {
				/* OK, set the result */
				xs->resid = 0;
			} else {
				/* Check the mailbox status. */
				switch (stat) {
				case WDS_MBI_OKERR:
					/* SCSI error recorded in scb, counts as WDS_MBI_OK */
					switch (scb->cmd.venderr) {
					case 0x00:
						printf("%s: Is this an error?\n", sc->sc_dev.dv_xname);
						xs->error = XS_DRIVER_STUFFUP; /* Experiment */
						break;
					case 0x01:
						/*printf("%s: OK, see SCSI error field.\n", sc->sc_dev.dv_xname);*/
						if (scb->cmd.stat == SCSI_CHECK) {
							/* Do sense. */
							wds_sense (sc, scb);
							return;
						} else if (scb->cmd.stat == SCSI_BUSY) {
							xs->error = XS_BUSY;
						}
						break;
					case 0x40:
						/*printf("%s: DMA underrun!\n", sc->sc_dev.dv_xname);*/
						/* Hits this if the target returns fewer that datalen bytes (eg my CD-ROM,
						which returns a short version string, or if DMA is turned off etc. */
						xs->resid = 0;
						break;
					default:
						printf("%s: VENDOR ERROR %02x, scsi %02x\n", sc->sc_dev.dv_xname, scb->cmd.venderr, scb->cmd.stat);
						xs->error = XS_DRIVER_STUFFUP; /* Experiment */
						break;
					}
					break;
				case WDS_MBI_ETIME:
					/*
					 * The documentation isn't clear on
					 * what conditions might generate this,
					 * but selection timeouts are the only
					 * one I can think of.
					 */
					xs->error = XS_SELTIMEOUT;
					break;
				case WDS_MBI_ERESET:
				case WDS_MBI_ETARCMD:
				case WDS_MBI_ERESEL:
				case WDS_MBI_ESEL:
				case WDS_MBI_EABORT:
				case WDS_MBI_ESRESET:
				case WDS_MBI_EHRESET:
					xs->error = XS_DRIVER_STUFFUP;
					break;
				}
			}
		} /* else sense */

		if (NEEDBUFFER(sc) && xs->datalen) {
			if (xs->flags & SCSI_DATA_IN)
				bcopy(scb->buf->data, xs->data, xs->datalen);
		}
	} /* XS_NOERROR */

	scsi_done(xs);
}

int
wds_find(struct isa_attach_args *ia, struct wds_softc *sc)
{
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh = ia->ia_ioh;
	u_char c;
	int i;

	/*
	 * Sending a command causes the CMDRDY bit to clear.
	 */
	c = bus_space_read_1(iot, ioh, WDS_STAT);
	for (i = 0; i < 4; i++) {
		if ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0)
			goto ready;
		delay(10);
	}
	return (0);

ready:
	bus_space_write_1(iot, ioh, WDS_CMD, WDSC_NOOP);
	if (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY)
		return (0);

	bus_space_write_1(iot, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);
	delay(10000);
	bus_space_write_1(iot, ioh, WDS_HCR, 0x00);
	delay(500000);
	wds_wait(iot, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);
	if (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 1)
		if (bus_space_read_1(iot, ioh, WDS_IRQSTAT) != 7)
			printf("%s: failed reset!!! %2x\n",
			    sc ? sc->sc_dev.dv_xname : "wds?",
			    bus_space_read_1(iot, ioh, WDS_IRQSTAT));

	if ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {
		printf("%s: waiting for controller to become ready.",
		    sc ? sc->sc_dev.dv_xname : "wds?");
		for (i = 0; i < 20; i++) {
			if ((bus_space_read_1(iot, ioh, WDS_STAT) &
			    (WDSS_RDY)) == WDSS_RDY)
				break;
			printf(".");
			delay(10000);
		}
		if ((bus_space_read_1(iot, ioh, WDS_STAT) & (WDSS_RDY)) !=
		    WDSS_RDY) {
			printf(" failed\n");
			return (0);
		}
		printf("\n");
	}

	if (sc != NULL) {
		/* XXX Can we do this better? */
		/* who are we on the scsi bus? */
		sc->sc_scsi_dev = 7;

		sc->sc_iot = iot;
		sc->sc_ioh = ioh;
		sc->sc_irq = ia->ia_irq;
		sc->sc_drq = ia->ia_drq;
	}

	return (1);
}

/*
 * Initialise the board and driver.
 */
void
wds_init(struct wds_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct wds_setup init;
	u_char c;
	int i;

	/*
	 * Set up initial mail box for round-robin operation.
	 */
	for (i = 0; i < WDS_MBX_SIZE; i++) {
		wmbx->mbo[i].cmd = WDS_MBO_FREE;
		wmbx->mbi[i].stat = WDS_MBI_FREE;
	}
	wmbx->cmbo = wmbx->tmbo = &wmbx->mbo[0];
	wmbx->tmbi = &wmbx->mbi[0];
	sc->sc_mbofull = 0;

	/* Clear the buffers. */
	TAILQ_INIT(&wds_free_buffer);
	for (i = 0; i < BUFCNT; i++) {
		wds_buffer[i].busy = 0;
		TAILQ_INSERT_HEAD(&wds_free_buffer, &wds_buffer[i], chain);
	}

	init.opcode = WDSC_INIT;
	init.scsi_id = sc->sc_scsi_dev;
	/* Record scsi id of controller for use in scsi_attach */
	sc->sc_scsi_dev = init.scsi_id;
	init.buson_t = 48;
	init.busoff_t = 24;
	init.xx = 0;
	ltophys(KVTOPHYS(wmbx), init.mbaddr);
	init.nomb = init.nimb = WDS_MBX_SIZE;
	wds_cmd(sc, (u_char *)&init, sizeof init);

	wds_wait(iot, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);

	c = WDSC_DISUNSOL;
	wds_cmd(sc, &c, sizeof c);

	bus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);
}

/*
 * Read the board's firmware revision information.
 */
void
wds_inquire_setup_information(struct wds_softc *sc)
{
	struct wds_scb *scb;
	u_char *j;
	int s;

	scb = scsi_io_get(&sc->sc_iopool, SCSI_NOSLEEP);
	if (scb == NULL) {
		printf("%s: no request slot available in getvers()!\n",
		    sc->sc_dev.dv_xname);
		return;
	}
	scb->xs = NULL;
	scb->timeout = 40;

	bzero(&scb->cmd, sizeof scb->cmd);
	scb->cmd.write = 0x80;
	scb->cmd.opcode = WDSX_GETFIRMREV;

	/* Will poll card, await result. */
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);
	scb->flags |= SCB_POLLED;

	s = splbio();
	wds_queue_scb(sc, scb);
	splx(s);

	if (wds_ipoll(sc, scb, scb->timeout))
		goto out;

	/* Print the version number. */
	printf(": version %x.%02x ", scb->cmd.targ, scb->cmd.scb.opcode);
	sc->sc_revision = (scb->cmd.targ << 8) | scb->cmd.scb.opcode;
	/* Print out the version string. */
	j = 2 + &(scb->cmd.targ);
	while ((*j >= 32) && (*j < 128)) {
		printf("%c", *j);
		j++;
	}

out:
	printf("\n");
	scsi_io_put(&sc->sc_iopool, scb);
}

void
wdsminphys(struct buf *bp, struct scsi_link *sl)
{
	if (bp->b_bcount > ((WDS_NSEG - 1) << PGSHIFT))
		bp->b_bcount = ((WDS_NSEG - 1) << PGSHIFT);
	minphys(bp);
}

/*
 * Send a SCSI command.
 */
void
wds_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *sc_link = xs->sc_link;
	struct wds_softc *sc = sc_link->adapter_softc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct wds_scb *scb;
	struct wds_scat_gath *sg;
	int seg;
	u_long thiskv, thisphys, nextphys;
	int bytes_this_seg, bytes_this_page, datalen, flags;
	int s;

	if (xs->flags & SCSI_RESET) {
		/* XXX Fix me! */
		printf("%s: reset!\n", sc->sc_dev.dv_xname);
		wds_init(sc);
		scsi_done(xs);
		return;
	}

	flags = xs->flags;
	scb = xs->io;
	scb->xs = xs;
	scb->timeout = xs->timeout;

	/* Zero out the command structure. */
	bzero(&scb->cmd, sizeof scb->cmd);
	bcopy(xs->cmd, &scb->cmd.scb, xs->cmdlen < 12 ? xs->cmdlen : 12);

	/* Set up some of the command fields. */
	scb->cmd.targ = (xs->sc_link->target << 5) | xs->sc_link->lun;

	/* NOTE: cmd.write may be OK as 0x40 (disable direction checking)
	 * on boards other than the WD-7000V-ASE. Need this for the ASE:
	 */
	scb->cmd.write = (xs->flags & SCSI_DATA_IN) ? 0x80 : 0x00;

	if (!NEEDBUFFER(sc) && xs->datalen) {
		sg = scb->scat_gath;
		seg = 0;

		/*
		 * Set up the scatter-gather block.
		 */
		SC_DEBUG(sc_link, SDEV_DB4,
		    ("%d @@0x%x:- ", xs->datalen, xs->data));

		datalen = xs->datalen;
		thiskv = (int)xs->data;
		thisphys = KVTOPHYS(xs->data);

		while (datalen && seg < WDS_NSEG) {
			bytes_this_seg = 0;

			/* put in the base address */
			ltophys(thisphys, sg->seg_addr);

			SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));

			/* do it at least once */
			nextphys = thisphys;
			while (datalen && thisphys == nextphys) {
				/*
				 * This page is contiguous (physically)
				 * with the last, just extend the
				 * length
				 */
				/* check it fits on the ISA bus */
				if (thisphys > 0xFFFFFF) {
					printf("%s: DMA beyond"
						" end of ISA\n",
						sc->sc_dev.dv_xname);
					goto bad;
				}
				/* how far to the end of the page */
				nextphys = (thisphys & ~PGOFSET) + NBPG;
				bytes_this_page = nextphys - thisphys;
				/**** or the data ****/
				bytes_this_page = min(bytes_this_page,
						      datalen);
				bytes_this_seg += bytes_this_page;
				datalen -= bytes_this_page;

				/* get more ready for the next page */
				thiskv = (thiskv & ~PGOFSET) + NBPG;
				if (datalen)
					thisphys = KVTOPHYS(thiskv);
			}
			/*
			 * next page isn't contiguous, finish the seg
			 */
			SC_DEBUGN(sc_link, SDEV_DB4,
			    ("(0x%x)", bytes_this_seg));
			ltophys(bytes_this_seg, sg->seg_len);
			sg++;
			seg++;
		}

		SC_DEBUGN(sc_link, SDEV_DB4, ("\n"));
		if (datalen) {
			/*
			 * there's still data, must have run out of segs!
			 */
			printf("%s: wds_scsi_cmd, more than %d dma segs\n",
			    sc->sc_dev.dv_xname, WDS_NSEG);
			goto bad;
		}
		scb->cmd.opcode = WDSX_SCSISG;
		ltophys(KVTOPHYS(scb->scat_gath), scb->cmd.data);
		ltophys(seg * sizeof(struct wds_scat_gath), scb->cmd.len);
	} else if (xs->datalen > 0) {
		/* The board is an ASC or ASE. Do not use scatter/gather. */
		if (xs->datalen > BUFLEN) {
			printf("%s: wds_scsi_cmd, I/O too large for bounce buffer\n",
			    sc->sc_dev.dv_xname);
			goto bad;
		}
		if (xs->flags & SCSI_DATA_OUT)
			bcopy(xs->data, scb->buf->data, xs->datalen);
		else
			bzero(scb->buf->data, xs->datalen);
		scb->cmd.opcode = WDSX_SCSICMD;
		ltophys(KVTOPHYS(scb->buf->data), scb->cmd.data);
		ltophys(xs->datalen, scb->cmd.len);
	} else {
		scb->cmd.opcode = WDSX_SCSICMD;
		ltophys(0, scb->cmd.data);
		ltophys(0, scb->cmd.len);
	}

	scb->cmd.stat = 0x00;
	scb->cmd.venderr = 0x00;
	ltophys(0, scb->cmd.link);

	/* XXX Do we really want to do this? */
	if (flags & SCSI_POLL) {
		/* Will poll card, await result. */
		bus_space_write_1(iot, ioh, WDS_HCR, WDSH_DRQEN);
		scb->flags |= SCB_POLLED;
	} else {
		/* Will send command, let interrupt routine handle result. */
		bus_space_write_1(iot, ioh, WDS_HCR, WDSH_IRQEN | WDSH_DRQEN);
	}

	s = splbio();
	wds_queue_scb(sc, scb);

	splx(s);

	if ((flags & SCSI_POLL) == 0)
		return;

	if (wds_poll(sc, xs, scb->timeout)) {
		wds_timeout(scb);
		if (wds_poll(sc, xs, scb->timeout))
			wds_timeout(scb);
	}
	return;

bad:
	xs->error = XS_DRIVER_STUFFUP;
}

/*
 * Send a sense request.
 */
void
wds_sense(struct wds_softc *sc, struct wds_scb *scb)
{
	struct scsi_xfer *xs = scb->xs;
	struct scsi_sense *ss = (void *)&scb->sense.scb;
	int s;

	/* XXXXX */

	/* Send sense request SCSI command. */
	xs->error = XS_SENSE;
	scb->flags |= SCB_SENSE;

	/* First, save the return values */
	if (NEEDBUFFER(sc) && xs->datalen) {
		if (xs->flags & SCSI_DATA_IN)
			bcopy(scb->buf->data, xs->data, xs->datalen);
	}

	/* Next, setup a request sense command block */
	bzero(ss, sizeof(*ss));
	ss->opcode = REQUEST_SENSE;
	ss->byte2 = xs->sc_link->lun << 5;
	ss->length = sizeof(struct scsi_sense_data);

	/* Set up some of the command fields. */
	scb->sense.targ = scb->cmd.targ;
	scb->sense.write = 0x80;
	scb->sense.opcode = WDSX_SCSICMD;
	ltophys(KVTOPHYS(&scb->sense_data), scb->sense.data);
	ltophys(sizeof(struct scsi_sense_data), scb->sense.len);

	s = splbio();
	wds_queue_scb(sc, scb);
	splx(s);

	/*
	 * There's no reason for us to poll here.  There are two cases:
	 * 1) If it's a polling operation, then we're called from the interrupt
	 *    handler, and we return and continue polling.
	 * 2) If it's an interrupt-driven operation, then it gets completed
	 *    later on when the REQUEST SENSE finishes.
	 */
}

/*
 * Poll a particular unit, looking for a particular scb
 */
int
wds_poll(struct wds_softc *sc, struct scsi_xfer *xs,  int count)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s;

	/* timeouts are in msec, so we loop in 1000 usec cycles */
	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) {
			s = splbio();
			wdsintr(sc);
			splx(s);
		}
		if (xs->flags & ITSDONE)
			return 0;
		delay(1000);	/* only happens in boot so ok */
		count--;
	}
	return 1;
}

/*
 * Poll a particular unit, looking for a particular scb
 */
int
wds_ipoll(struct wds_softc *sc, struct wds_scb *scb, int count)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int s;

	/* timeouts are in msec, so we loop in 1000 usec cycles */
	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ) {
			s = splbio();
			wdsintr(sc);
			splx(s);
		}
		if (scb->flags & SCB_DONE)
			return 0;
		delay(1000);	/* only happens in boot so ok */
		count--;
	}
	return 1;
}

void
wds_timeout(void *arg)
{
	struct wds_scb *scb = arg;
	struct scsi_xfer *xs;
	struct scsi_link *sc_link;
	struct wds_softc *sc;
	int s;

	s = splbio();
	xs = scb->xs;
	sc_link = xs->sc_link;
	sc = sc_link->adapter_softc;

	sc_print_addr(sc_link);
	printf("timed out");

#ifdef WDSDIAG
	/*
	 * If The scb's mbx is not free, then the board has gone south?
	 */
	wds_collect_mbo(sc);
	if (scb->flags & SCB_SENDING)
		panic("%s: not taking commands!", sc->sc_dev.dv_xname);
#endif

	/*
	 * If it has been through before, then
	 * a previous abort has failed, don't
	 * try abort again
	 */
	if (scb->flags & SCB_ABORT) {
		/* abort timed out */
		printf(" AGAIN\n");
		/* XXX Must reset! */
	} else {
		/* abort the operation that has timed out */
		printf("\n");
		scb->xs->error = XS_TIMEOUT;
		scb->timeout = WDS_ABORT_TIMEOUT;
		scb->flags |= SCB_ABORT;
		wds_queue_scb(sc, scb);
	}

	splx(s);
}
@


1.41
log
@Move an opening brace so a loop that delays while waiting
for hardware to set a ready bit actually delays.

ok krw@@ deraadt@@ 'sounds correct' miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.40 2013/11/15 16:46:27 brad Exp $	*/
a68 1
#include <sys/proc.h>
@


1.40
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.39 2011/06/29 12:17:40 tedu Exp $	*/
d724 2
a725 2
	for (i = 0; i < 4; i++)
		if ((bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_RDY) != 0) {
@


1.39
log
@notyet, notever.  delete a bunch of code we won't be using.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.38 2011/04/03 12:42:36 krw Exp $	*/
d194 2
a195 6
wds_wait(iot, ioh, port, mask, val)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	int port;
	int mask;
	int val;
d205 1
a205 4
wds_cmd(sc, ibuf, icnt)
	struct wds_softc *sc;
	u_int8_t *ibuf;
	int icnt;
d228 1
a228 3
wdsprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d252 1
a252 3
wdsprint(aux, name)
	void *aux;
	const char *name;
a253 1

d263 1
a263 3
wdsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d315 1
a315 2
wds_finish_scbs(sc)
	struct wds_softc *sc;
d374 1
a374 2
wdsintr(arg)
	void *arg;
d410 1
a410 3
wds_reset_scb(sc, scb)
	struct wds_softc *sc;
	struct wds_scb *scb;
a411 1

d419 1
a419 2
wds_scb_free(xsc, xscb)
	void *xsc, *xscb;
d436 1
a436 3
wds_free_buf(sc, buf)
	struct wds_softc *sc;
	struct wds_buf *buf;
d456 1
a456 3
wds_init_scb(sc, scb)
	struct wds_softc *sc;
	struct wds_scb *scb;
d476 1
a476 2
wds_scb_alloc(xsc)
	void *xsc;
d493 1
a493 3
wds_get_buf(sc, flags)
	struct wds_softc *sc;
	int flags;
d519 1
a519 3
wds_scb_phys_kv(sc, scb_phys)
	struct wds_softc *sc;
	u_long scb_phys;
d539 1
a539 3
wds_queue_scb(sc, scb)
	struct wds_softc *sc;
	struct wds_scb *scb;
a540 1

d549 1
a549 2
wds_collect_mbo(sc)
	struct wds_softc *sc;
d578 1
a578 2
wds_start_scbs(sc)
	struct wds_softc *sc;
d628 1
a628 4
wds_done(sc, scb, stat)
	struct wds_softc *sc;
	struct wds_scb *scb;
	u_int8_t stat;
d713 1
a713 3
wds_find(ia, sc)
	struct isa_attach_args *ia;
	struct wds_softc *sc;
d783 1
a783 2
wds_init(sc)
	struct wds_softc *sc;
d832 1
a832 2
wds_inquire_setup_information(sc)
	struct wds_softc *sc;
d889 1
a889 2
wds_scsi_cmd(xs)
	struct scsi_xfer *xs;
d1057 1
a1057 3
wds_sense(sc, scb)
	struct wds_softc *sc;
	struct wds_scb *scb;
d1105 1
a1105 4
wds_poll(sc, xs, count)
	struct wds_softc *sc;
	struct scsi_xfer *xs;
	int count;
d1134 1
a1134 4
wds_ipoll(sc, scb, count)
	struct wds_softc *sc;
	struct wds_scb *scb;
	int count;
d1160 1
a1160 2
wds_timeout(arg)
	void *arg;
@


1.38
log
@Iopoolification of some less common scsi drivers.

ok dlg@@ ("miod will not object" dlg@@)
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.37 2010/07/02 02:29:45 tedu Exp $	*/
a306 3
#ifdef notyet
	sc->sc_link.channel = SCSI_CHANNEL_ONLY_ONE;
#endif
a374 4
#ifdef notyet
		isadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE,
		    1, scb->scb_phys);
#endif
a636 5
#ifdef notyet
		isadma_copytobuf((caddr_t)scb, SCB_PHYS_SIZE,
		    1, scb->scb_phys);
		ltophys(scb->scb_phys[0].addr, wmbo->scb_addr);
#else
a640 1
#endif
a745 9
#ifdef notyet
	if (scb->data_nseg) {
		if (xs->flags & SCSI_DATA_IN)
			isadma_copyfrombuf(xs->data, xs->datalen,
			    scb->data_nseg, scb->data_phys);
		isadma_unmap(xs->data, xs->datalen,
		    scb->data_nseg, scb->data_phys);
	}
#endif
a829 3
#ifdef notyet
	struct isadma_seg mbx_phys[1];
#endif
a855 6
#ifdef notyet
	if (isadma_map((caddr_t)(wmbx), sizeof(struct wds_mbx),
	    mbx_phys, ISADMA_MAP_CONTIG) != 1)
		panic("wds_init: cannot map mail box");
	ltophys(mbx_phys[0].addr, init.mbaddr);
#else
a856 1
#endif
a942 3
#ifdef notyet
	int mflags;
#endif
a952 6
#ifdef notyet
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;
#endif
a978 10
#ifdef notyet
		scb->data_nseg = isadma_map(xs->data, xs->datalen,
					    scb->data_phys, mflags);
		for (seg = 0; seg < scb->data_nseg; seg++) {
			ltophys(scb->data_phys[seg].addr,
			       sg[seg].seg_addr);
			ltophys(scb->data_phys[seg].length,
			       sg[seg].seg_len);
		}
#else
a1027 1
#endif
a1038 13
#ifdef notyet
		if (scb->data_nseg == 0) {
			printf("%s: wds_scsi_cmd, cannot map\n",
			       sc->sc_dev.dv_xname);
			goto bad;
		} else if (flags & SCSI_DATA_OUT)
			isadma_copytobuf(xs->data, xs->datalen,
					 scb->data_nseg, scb->data_phys);
		ltophys((unsigned)((struct wds_scb *)(scb->scb_phys[0].addr))->scat_gath,
			scb->data_addr);
		ltophys(scb->data_nseg * sizeof(struct wds_scat_gath),
			scb->data_length);
#else
a1041 1
#endif
a1078 17
#ifdef notyet
	if (VOLATILE_XS(xs)) {
		while ((scb->xs->flags & ITSDONE) == 0) {
			tsleep(scb, PRIBIO, "wdswait", 0);
		}
		if (scb->data_nseg) {
			if (flags & SCSI_DATA_IN)
				isadma_copyfrombuf(xs->data, xs->datalen,
				    scb->data_nseg, scb->data_phys);
			isadma_unmap(xs->data, xs->datalen,
			    scb->data_nseg, scb->data_phys);
		}
		scsi_done(xs);
		splx(s);
		return;
	}
#endif
a1219 3
#ifdef notyet
	isadma_copyfrombuf((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);
#endif
@


1.37
log
@some very obvious uninit bugs found when I turned off -Wno-uninitialized
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.36 2010/06/28 18:31:02 krw Exp $	*/
d123 3
d152 1
a152 1
void    wds_free_scb(struct wds_softc *, struct wds_scb *);
d155 1
a155 1
struct	wds_scb *wds_get_scb(struct wds_softc *, int, int);
d299 3
d317 1
d445 2
a446 3
wds_free_scb(sc, scb)
	struct wds_softc *sc;
	struct wds_scb *scb;
d448 2
a449 1
	int s;
d451 1
a451 1
	if (scb->buf != 0) {
d453 1
a453 1
		scb->buf = 0;
a455 7
	s = splbio();

#ifdef notyet
	if (scb->scb_phys[0].addr)
	        isadma_unmap((caddr_t)scb, SCB_PHYS_SIZE, 1, scb->scb_phys);
#endif

d457 1
d459 1
a459 9

	/*
	 * If there were none, wake anybody waiting for one to come free,
	 * starting with queued entries.
	 */
	if (TAILQ_NEXT(scb, chain) == NULL)
		wakeup(&sc->sc_free_scb);

	splx(s);
a504 3
 *
 * If there are none, see if we can allocate a new one.  If so, put it in
 * the hash table too otherwise either return an error or sleep.
d506 3
a508 5
struct wds_scb *
wds_get_scb(sc, flags, needbuffer)
	struct wds_softc *sc;
	int flags;
	int needbuffer;
d510 1
a511 6
	int s;
#ifdef notyet
	int mflags, hashnum;
#endif

	s = splbio();
d513 5
a517 32
#ifdef notyet
	if (flags & SCSI_NOSLEEP)
		mflags = ISADMA_MAP_BOUNCE;
	else
		mflags = ISADMA_MAP_BOUNCE | ISADMA_MAP_WAITOK;
#endif

	/*
	 * If we can and have to, sleep waiting for one to come free
	 * but only if we can't allocate a new one.
	 */
	for (;;) {
		scb = TAILQ_FIRST(&sc->sc_free_scb);
		if (scb) {
			TAILQ_REMOVE(&sc->sc_free_scb, scb, chain);
			break;
		}
		if (sc->sc_numscbs < WDS_SCB_MAX) {
			scb = (struct wds_scb *) malloc(sizeof(struct wds_scb),
			    M_TEMP, M_NOWAIT);
			if (!scb) {
				printf("%s: can't malloc scb\n",
				    sc->sc_dev.dv_xname);
				goto out;
			}
			wds_init_scb(sc, scb);
			sc->sc_numscbs++;
			break;
		}
		if ((flags & SCSI_NOSLEEP) != 0)
			goto out;
		tsleep(&sc->sc_free_scb, PRIBIO, "wdsscb", 0);
d519 1
a520 26
	scb->flags |= SCB_ALLOC;

#ifdef notyet
	if (isadma_map((caddr_t)scb, SCB_PHYS_SIZE, scb->scb_phys,
	    mflags | ISADMA_MAP_CONTIG) == 1) {
		hashnum = SCB_HASH(scb->scb_phys[0].addr);
		scb->nexthash = sc->sc_scbhash[hashnum];
		sc->sc_scbhash[hashnum] = ccb;
	} else {
		scb->scb_phys[0].addr = 0;
		wds_free_scb(sc, scb);
		scb = 0;
	}
#else
	if (needbuffer) {
		scb->buf = wds_get_buf(sc, flags);
		if (scb->buf == 0) {
			wds_free_scb(sc, scb);
			scb = 0;
		}
	}
#endif


out:
	splx(s);
a767 1
	wds_free_scb(sc, scb);
d911 2
a912 1
	if ((scb = wds_get_scb(sc, SCSI_NOSLEEP, 0)) == NULL) {
d947 1
a947 1
	wds_free_scb(sc, scb);
d994 1
a994 5
	if ((scb = wds_get_scb(sc, flags, NEEDBUFFER(sc))) == NULL) {
		xs->error = XS_NO_CCB;
		scsi_done(xs);
		return;
	}
a1156 1
		wds_free_scb(sc, scb);
a1175 1
	wds_free_scb(sc, scb);
@


1.36
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.35 2010/06/26 23:24:44 guenther Exp $	*/
d847 1
a847 1
	bus_space_handle_t ioh;
@


1.35
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.34 2010/05/20 00:55:17 krw Exp $	*/
a176 8
/* the below structure is so we have a default dev struct for our link struct */
struct scsi_device wds_dev = {
	NULL,			/* Use default error handler */
	NULL,			/* have a queue, served by this */
	NULL,			/* have no async handler */
	NULL,			/* Use default 'done' routine */
};

a306 1
	sc->sc_link.device = &wds_dev;
@


1.34
log
@New scsi code seems to be stable. Pluck previously identified
low-hanging splbio/splx pairs that are no longer needed and see if
this reveals any hidden scsi flaws.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.33 2010/03/23 01:57:20 krw Exp $	*/
d70 1
a70 1
#include <sys/user.h>
@


1.33
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.32 2010/01/10 00:10:23 krw Exp $	*/
a1060 1
		s = splbio();
a1061 1
		splx(s);
a1073 1
		s = splbio();
a1074 1
		splx(s);
@


1.32
log
@Set ITSDONE in scsi_done() and zap trivial instances of setting it
in the drivers just before calling scsi_done().

ok dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.31 2009/09/24 19:48:50 miod Exp $	*/
d163 1
a163 1
int     wds_scsi_cmd(struct scsi_xfer *);
d1039 1
a1039 1
int
d1064 1
a1064 1
		return COMPLETE;
d1075 5
a1079 1
		return (NO_CCB);
d1246 1
a1246 1
		return COMPLETE;
d1252 1
a1252 1
		return SUCCESSFULLY_QUEUED;
d1259 1
a1259 1
	return COMPLETE;
a1263 1
	return COMPLETE;
@


1.31
log
@Make sure the scsi_xfer timeout always get initialized with timeout_set(),
since the scsi_done() wrapper will timeout_del() unconditionnaly and the
scsi midlayer no longer provides scsi_xfer with zeroed struct timeout.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.30 2009/09/05 11:49:36 dlg Exp $	*/
a846 1
	xs->flags |= ITSDONE;
@


1.30
log
@scsi_done before COMPLETE.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.29 2009/08/26 22:29:09 jasper Exp $	*/
d719 1
d739 1
a739 2
		if ((scb->flags & SCB_POLLED) == 0) {
			timeout_set(&scb->xs->stimeout, wds_timeout, scb);
a740 1
		}
@


1.29
log
@directly calling Debugger() is bad. turn these printf();Debugger(); series
into panic()'s.

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.28 2009/02/16 21:19:07 miod Exp $	*/
d1063 3
@


1.28
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.27 2009/01/21 21:54:00 grange Exp $	*/
a81 4
#ifndef DDB
#define Debugger() panic("should call debugger here (wds.c)")
#endif /* ! DDB */

d1402 2
a1403 4
	if (scb->flags & SCB_SENDING) {
		printf("%s: not taking commands!\n", sc->sc_dev.dv_xname);
		Debugger();
	}
@


1.27
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.26 2008/11/25 17:52:02 krw Exp $	*/
d166 1
a166 1
void    wdsminphys(struct buf *);
d1035 1
a1035 2
wdsminphys(bp)
	struct buf *bp;
@


1.26
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.25 2008/09/12 11:14:04 miod Exp $	*/
d744 1
a744 1
			timeout_add(&scb->xs->stimeout, (scb->timeout * hz) / 1000);
@


1.25
log
@SCSI_DATA_UIO is never used. Code which checks for it is either dead or
commented out, remove it. Unifdef TFS while there.

ok marco@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.24 2007/11/05 17:12:41 krw Exp $	*/
d1079 1
a1079 1
		return TRY_AGAIN_LATER;
@


1.24
log
@More scsi_done() at SPLBIO. If you poll by manually calling the
interrupt function, wrap the call in splbio/splx!
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.23 2006/11/28 23:59:45 dlg Exp $	*/
a1058 3
#ifdef TFS
	struct iovec *iovp;
#endif
a1083 8
	if (xs->flags & SCSI_DATA_UIO) {
		/* XXX Fix me! */
		/* Let's not worry about UIO. There isn't any code for the *
		 * non-SG boards anyway! */
		printf("%s: UIO is untested and disabled!\n", sc->sc_dev.dv_xname);
		goto bad;
	}

d1099 6
a1104 24
#ifdef TFS
		if (flags & SCSI_DATA_UIO) {
			iovp = ((struct uio *)xs->data)->uio_iov;
			datalen = ((struct uio *)xs->data)->uio_iovcnt;
			xs->datalen = 0;
			while (datalen && seg < WDS_NSEG) {
				ltophys(iovp->iov_base, sg->seg_addr);
				ltophys(iovp->iov_len, sg->seg_len);
				xs->datalen += iovp->iov_len;
				SC_DEBUGN(sc_link, SDEV_DB4, ("UIO(0x%x@@0x%x)",
				    iovp->iov_len, iovp->iov_base));
				sg++;
				iovp++;
				seg++;
				datalen--;
			}
		} else
#endif /* TFS */
		{
			/*
			 * Set up the scatter-gather block.
			 */
			SC_DEBUG(sc_link, SDEV_DB4,
			    ("%d @@0x%x:- ", xs->datalen, xs->data));
d1107 8
a1114 8
			scb->data_nseg = isadma_map(xs->data, xs->datalen,
						    scb->data_phys, mflags);
			for (seg = 0; seg < scb->data_nseg; seg++) {
				ltophys(scb->data_phys[seg].addr,
				       sg[seg].seg_addr);
				ltophys(scb->data_phys[seg].length,
				       sg[seg].seg_len);
			}
d1116 3
a1118 3
			datalen = xs->datalen;
			thiskv = (int)xs->data;
			thisphys = KVTOPHYS(xs->data);
d1120 2
a1121 2
			while (datalen && seg < WDS_NSEG) {
				bytes_this_seg = 0;
d1123 2
a1124 2
				/* put in the base address */
				ltophys(thisphys, sg->seg_addr);
d1126 1
a1126 1
				SC_DEBUGN(sc_link, SDEV_DB4, ("0x%x", thisphys));
d1128 3
a1130 29
				/* do it at least once */
				nextphys = thisphys;
				while (datalen && thisphys == nextphys) {
					/*
					 * This page is contiguous (physically)
					 * with the last, just extend the
					 * length
					 */
					/* check it fits on the ISA bus */
					if (thisphys > 0xFFFFFF) {
						printf("%s: DMA beyond"
							" end of ISA\n",
							sc->sc_dev.dv_xname);
						goto bad;
					}
					/* how far to the end of the page */
					nextphys = (thisphys & ~PGOFSET) + NBPG;
					bytes_this_page = nextphys - thisphys;
					/**** or the data ****/
					bytes_this_page = min(bytes_this_page,
							      datalen);
					bytes_this_seg += bytes_this_page;
					datalen -= bytes_this_page;

					/* get more ready for the next page */
					thiskv = (thiskv & ~PGOFSET) + NBPG;
					if (datalen)
						thisphys = KVTOPHYS(thiskv);
				}
d1132 3
a1134 1
				 * next page isn't contiguous, finish the seg
d1136 29
a1164 5
				SC_DEBUGN(sc_link, SDEV_DB4,
				    ("(0x%x)", bytes_this_seg));
				ltophys(bytes_this_seg, sg->seg_len);
				sg++;
				seg++;
a1165 1
			}
d1167 1
a1167 1
		/* end of iov/kv decision */
@


1.23
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.22 2005/12/03 17:13:22 krw Exp $	*/
d1358 1
d1366 2
a1367 1
		if (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)
d1369 2
d1390 1
d1398 2
a1399 1
		if (bus_space_read_1(iot, ioh, WDS_STAT) & WDSS_IRQ)
d1401 2
@


1.22
log
@The first thing done when XXX_scsi_cmd() returns TRY_AGAIN_LATER is
to set xs->error to XS_BUSY. So it is pointless and misleading to
set xs->error to XS_TIMEOUT, XS_DRIVER_STUFFUP or XS_BUSY just before
returning TRY_AGAIN_LATER.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.21 2005/11/23 11:30:14 mickey Exp $	*/
d290 1
d328 3
d334 1
a334 1
	config_found(self, &sc->sc_link, wdsprint);
@


1.21
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.20 2005/02/17 18:07:36 jfb Exp $	*/
a1077 1
		xs->error = XS_DRIVER_STUFFUP;
@


1.20
log
@miscellaneous typo fixes:
- sturct -> struct (spotted by pedro)
- elimination of consecutive 'the' words

ok jmc@@, henning@@, krw@@, robert@@, some whining by jolan@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.19 2004/12/26 21:22:13 miod Exp $	*/
d107 1
a107 1
#define	KVTOPHYS(x)	vtophys(x)
@


1.19
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.18 2002/03/14 01:26:56 millert Exp $	*/
d1159 1
a1159 1
					 * with the the last, just extend the
@


1.18
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.17 2001/01/29 07:04:10 mickey Exp $	*/
d472 1
a472 1
	if (scb->chain.tqe_next == 0)
d494 1
a494 1
	if (buf->chain.tqe_next == 0)
d551 1
a551 1
		scb = sc->sc_free_scb.tqh_first;
d613 1
a613 1
		buf = wds_free_buffer.tqh_first;
d705 1
a705 1
	while ((scb = sc->sc_waiting_scb.tqh_first) != NULL) {
@


1.17
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.16 1999/02/13 00:59:28 fgsch Exp $	*/
d148 25
a172 26
integrate void    wds_wait
    __P((bus_space_tag_t, bus_space_handle_t, int, int, int));
int     wds_cmd __P((struct wds_softc *, u_char *, int));
integrate void wds_finish_scbs __P((struct wds_softc *));
int     wdsintr __P((void *));
integrate void wds_reset_scb __P((struct wds_softc *, struct wds_scb *));
void    wds_free_scb __P((struct wds_softc *, struct wds_scb *));
void	wds_free_buf __P((struct wds_softc *, struct wds_buf *));
integrate void wds_init_scb __P((struct wds_softc *, struct wds_scb *));
struct	wds_scb *wds_get_scb __P((struct wds_softc *, int, int));
struct	wds_buf *wds_get_buf __P((struct wds_softc *, int));
struct	wds_scb *wds_scb_phys_kv __P((struct wds_softc *, u_long));
void	wds_queue_scb __P((struct wds_softc *, struct wds_scb *));
void	wds_collect_mbo __P((struct wds_softc *));
void	wds_start_scbs __P((struct wds_softc *));
void    wds_done __P((struct wds_softc *, struct wds_scb *, u_char));
int	wds_find __P((struct isa_attach_args *, struct wds_softc *));
void	wds_init __P((struct wds_softc *));
void	wds_inquire_setup_information __P((struct wds_softc *));
void    wdsminphys __P((struct buf *));
int     wds_scsi_cmd __P((struct scsi_xfer *));
void	wds_sense  __P((struct wds_softc *, struct wds_scb *));
int	wds_poll __P((struct wds_softc *, struct scsi_xfer *, int));
int	wds_ipoll __P((struct wds_softc *, struct wds_scb *, int));
void	wds_timeout __P((void *));
int	wdsprint __P((void *, const char *));
d189 2
a190 2
int	wdsprobe __P((struct device *, void *, void *));
void	wdsattach __P((struct device *, struct device *, void *));
@


1.17.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.17 2001/01/29 07:04:10 mickey Exp $	*/
d148 26
a173 25
integrate void    wds_wait(bus_space_tag_t, bus_space_handle_t, int, int, int);
int     wds_cmd(struct wds_softc *, u_char *, int);
integrate void wds_finish_scbs(struct wds_softc *);
int     wdsintr(void *);
integrate void wds_reset_scb(struct wds_softc *, struct wds_scb *);
void    wds_free_scb(struct wds_softc *, struct wds_scb *);
void	wds_free_buf(struct wds_softc *, struct wds_buf *);
integrate void wds_init_scb(struct wds_softc *, struct wds_scb *);
struct	wds_scb *wds_get_scb(struct wds_softc *, int, int);
struct	wds_buf *wds_get_buf(struct wds_softc *, int);
struct	wds_scb *wds_scb_phys_kv(struct wds_softc *, u_long);
void	wds_queue_scb(struct wds_softc *, struct wds_scb *);
void	wds_collect_mbo(struct wds_softc *);
void	wds_start_scbs(struct wds_softc *);
void    wds_done(struct wds_softc *, struct wds_scb *, u_char);
int	wds_find(struct isa_attach_args *, struct wds_softc *);
void	wds_init(struct wds_softc *);
void	wds_inquire_setup_information(struct wds_softc *);
void    wdsminphys(struct buf *);
int     wds_scsi_cmd(struct scsi_xfer *);
void	wds_sense(struct wds_softc *, struct wds_scb *);
int	wds_poll(struct wds_softc *, struct scsi_xfer *, int);
int	wds_ipoll(struct wds_softc *, struct wds_scb *, int);
void	wds_timeout(void *);
int	wdsprint(void *, const char *);
d190 2
a191 2
int	wdsprobe(struct device *, void *, void *);
void	wdsattach(struct device *, struct device *, void *);
@


1.16
log
@If the card is not present be sure to always call bus_space_unmap on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.15 1999/01/24 15:58:54 mickey Exp $	*/
d380 1
a380 1
		untimeout(wds_timeout, scb);
d739 4
a742 2
		if ((scb->flags & SCB_POLLED) == 0)
			timeout(wds_timeout, scb, (scb->timeout * hz) / 1000);
d865 1
a865 1
 	 */
d1102 1
a1102 1
 	 */
@


1.16.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.17 2001/01/29 07:04:10 mickey Exp $	*/
d380 1
a380 1
		timeout_del(&scb->xs->stimeout);
d739 2
a740 4
		if ((scb->flags & SCB_POLLED) == 0) {
			timeout_set(&scb->xs->stimeout, wds_timeout, scb);
			timeout_add(&scb->xs->stimeout, (scb->timeout * hz) / 1000);
		}
d863 1
a863 1
	 */
d1100 1
a1100 1
	 */
@


1.16.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d148 26
a173 25
integrate void    wds_wait(bus_space_tag_t, bus_space_handle_t, int, int, int);
int     wds_cmd(struct wds_softc *, u_char *, int);
integrate void wds_finish_scbs(struct wds_softc *);
int     wdsintr(void *);
integrate void wds_reset_scb(struct wds_softc *, struct wds_scb *);
void    wds_free_scb(struct wds_softc *, struct wds_scb *);
void	wds_free_buf(struct wds_softc *, struct wds_buf *);
integrate void wds_init_scb(struct wds_softc *, struct wds_scb *);
struct	wds_scb *wds_get_scb(struct wds_softc *, int, int);
struct	wds_buf *wds_get_buf(struct wds_softc *, int);
struct	wds_scb *wds_scb_phys_kv(struct wds_softc *, u_long);
void	wds_queue_scb(struct wds_softc *, struct wds_scb *);
void	wds_collect_mbo(struct wds_softc *);
void	wds_start_scbs(struct wds_softc *);
void    wds_done(struct wds_softc *, struct wds_scb *, u_char);
int	wds_find(struct isa_attach_args *, struct wds_softc *);
void	wds_init(struct wds_softc *);
void	wds_inquire_setup_information(struct wds_softc *);
void    wdsminphys(struct buf *);
int     wds_scsi_cmd(struct scsi_xfer *);
void	wds_sense(struct wds_softc *, struct wds_scb *);
int	wds_poll(struct wds_softc *, struct scsi_xfer *, int);
int	wds_ipoll(struct wds_softc *, struct wds_scb *, int);
void	wds_timeout(void *);
int	wdsprint(void *, const char *);
d190 2
a191 2
int	wdsprobe(struct device *, void *, void *);
void	wdsattach(struct device *, struct device *, void *);
@


1.15
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.14 1999/01/07 06:14:49 niklas Exp $	*/
d250 6
d258 8
a265 2
	if (wds_find(ia, NULL) != 0)
		return 0;
d267 1
a267 3
	ia->ia_msize = 0;
	ia->ia_iosize = WDS_IO_PORTS;
	return 1;
d291 2
d294 6
a299 1
	if (wds_find(ia, sc) != 0)
a860 5
	/* XXXXX */

	if (bus_space_map(iot, ia->ia_iobase, WDS_IO_PORTS, 0, &ioh))
		return (1);

d870 1
a870 1
	return (1);
d875 1
a875 1
		return 1;
d901 1
a901 1
			return (1);
d915 1
a915 2
	} else
		bus_space_unmap(iot, ioh, WDS_IO_PORTS);
d917 1
a917 1
	return (0);
@


1.14
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.13 1998/01/18 18:48:40 niklas Exp $	*/
a73 1
#include <machine/pio.h>
@


1.13
log
@move to current OpenBSD isadma API
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.12 1997/07/07 17:02:07 niklas Exp $	*/
a251 5
#ifdef NEWCONFIG
	if (ia->ia_iobase == IOBASEUNK)
		return 0;
#endif

a308 3
#ifdef NEWCONFIG
	isa_establish(&sc->sc_id, &sc->sc_dev);
#endif
@


1.12
log
@Sanity
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.11 1996/11/29 22:55:10 niklas Exp $	*/
d293 1
a293 1
		isa_dmacascade(sc->sc_drq);
@


1.11
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.10 1996/11/23 21:46:49 kstailey Exp $	*/
d856 1
a856 1
		return (0);
d867 1
a867 1
	return 1;
d898 1
a898 1
			return 1;
d915 1
a915 1
	return 0;
@


1.10
log
@added const to second parameter of cfprint_t routines
@
text
@d1 2
a2 2
/*	$OpenBSD: wds.c,v 1.9 1996/11/12 20:30:46 niklas Exp $	*/
/*	$NetBSD: wds.c,v 1.7 1996/05/12 23:54:09 mycroft Exp $	*/
d5 1
d7 3
d72 1
a72 1
#include <machine/bus.old.h>
d115 2
a116 2
	bus_chipset_tag_t sc_bc;  /* bus identifier */
	bus_io_handle_t sc_ioh;   /* io handle */
d150 1
a150 1
    __P((bus_chipset_tag_t, bus_io_handle_t, int, int, int));
d174 1
a192 1
int	wdsprint __P((void *, const char *));
d205 3
a207 3
wds_wait(bc, ioh, port, mask, val)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d212 1
a212 1
	while ((bus_io_read_1(bc, ioh, port) & mask) != val)
d225 2
a226 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d229 1
a229 1
	wds_wait(bc, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);
d232 3
a234 3
		bus_io_write_1(bc, ioh, WDS_CMD, *ibuf++);
		wds_wait(bc, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);
		c = bus_io_read_1(bc, ioh, WDS_STAT);
d302 3
d395 2
a396 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d400 1
a400 1
	if ((bus_io_read_1(bc, ioh, WDS_STAT) & WDSS_IRQ) == 0)
d404 1
a404 1
	c = bus_io_read_1(bc, ioh, WDS_IRQSTAT) & WDSI_MASK;
d407 1
a407 1
	bus_io_write_1(bc, ioh, WDS_IRQACK, 0x00);
d848 2
a849 2
	bus_chipset_tag_t bc = ia->ia_bc;
	bus_io_handle_t ioh;
d855 1
a855 1
	if (bus_io_map(bc, ia->ia_iobase, WDS_IO_PORTS, &ioh))
d861 1
a861 1
	c = bus_io_read_1(bc, ioh, WDS_STAT);
d863 1
a863 1
		if ((bus_io_read_1(bc, ioh, WDS_STAT) & WDSS_RDY) != 0) {
d870 2
a871 2
	bus_io_write_1(bc, ioh, WDS_CMD, WDSC_NOOP);
	if (bus_io_read_1(bc, ioh, WDS_STAT) & WDSS_RDY)
d874 1
a874 1
	bus_io_write_1(bc, ioh, WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);
d876 1
a876 1
	bus_io_write_1(bc, ioh, WDS_HCR, 0x00);
d878 3
a880 3
	wds_wait(bc, ioh, WDS_STAT, WDSS_RDY, WDSS_RDY);
	if (bus_io_read_1(bc, ioh, WDS_IRQSTAT) != 1)
		if (bus_io_read_1(bc, ioh, WDS_IRQSTAT) != 7)
d883 1
a883 1
			    bus_io_read_1(bc, ioh, WDS_IRQSTAT));
d885 1
a885 1
	if ((bus_io_read_1(bc, ioh, WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {
d889 2
a890 2
			if ((bus_io_read_1(bc, ioh, WDS_STAT) & (WDSS_RDY)) ==
			    WDSS_RDY)
d895 1
a895 1
		if ((bus_io_read_1(bc, ioh, WDS_STAT) & (WDSS_RDY)) !=
d908 1
a908 1
		sc->sc_bc = bc;
d913 1
a913 1
		bus_io_unmap(bc, ioh, WDS_IO_PORTS);
d925 2
a926 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d970 1
a970 1
	wds_wait(bc, ioh, WDS_STAT, WDSS_INIT, WDSS_INIT);
d975 1
a975 1
	bus_io_write_1(bc, ioh, WDS_HCR, WDSH_DRQEN);
d1002 1
a1002 1
	bus_io_write_1(sc->sc_bc, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);
a1030 1

d1045 2
a1046 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1245 1
a1245 1
		bus_io_write_1(bc, ioh, WDS_HCR, WDSH_DRQEN);
d1249 1
a1249 1
		bus_io_write_1(bc, ioh, WDS_HCR, WDSH_IRQEN | WDSH_DRQEN);
d1350 2
a1351 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1359 1
a1359 1
		if (bus_io_read_1(bc, ioh, WDS_STAT) & WDSS_IRQ)
d1378 2
a1379 2
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;
d1387 1
a1387 1
		if (bus_io_read_1(bc, ioh, WDS_STAT) & WDSS_IRQ)
@


1.9
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.8 1996/11/09 08:40:53 niklas Exp $	*/
d188 1
a188 1
int	wdsprint __P((void *, char *));
d265 1
a265 1
	char *name;
@


1.8
log
@Altered wds_wait's interface as the current one didn't have a chance to work
in early probe code under the bus.h system.  Make debugging runtime
configurable.  Some s/u_char/u_int8_t/ work.  Set ia_iosize to a sane value.
Move wds_init up before the setting of the DMA machinery to cascade mode (from
Charles Hannum).  Add ISA bounce-buffering code inside #ifdef notyet.  In the
-ASC case buffers could never be gotten due to forgetting some braces, added
them.  Removed a possibility of a NULL deref in some diagnostic printouts.
Unmap the I/O area after the probe.  Cache the bustag and the iohandle in
wds_init.  Did set WDS_IO_PORTS to 8 as some code indicated it might take up
that much even though I only know of three ports in there..  This might be
changed down later again.
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.7 1996/10/25 08:04:20 niklas Exp $	*/
d68 1
a68 1
#include <machine/bus.h>
@


1.7
log
@Busified
@
text
@d1 1
a1 1
/*	$OpenBSD: wds.c,v 1.7 1996/05/12 23:54:09 mycroft Exp $	*/
d141 6
a146 1
integrate void    wds_wait __P((struct wds_softc *, int, int, int));
d201 3
a203 2
wds_wait(sc, port, mask, val)
	struct wds_softc *sc;
a207 3
	bus_chipset_tag_t bc = sc->sc_bc;
	bus_io_handle_t ioh = sc->sc_ioh;

d218 1
a218 1
	u_char *ibuf;
d223 1
a223 1
	u_char c;
d225 1
a225 1
	wds_wait(sc, WDS_STAT, WDSS_RDY, WDSS_RDY);
d229 1
a229 1
		wds_wait(sc, WDS_STAT, WDSS_RDY, WDSS_RDY);
d258 1
a258 1
	ia->ia_iosize = 8;
d286 1
a290 1
	wds_init(sc);
d356 1
a356 1
			u_char *cp = &scb->scsi_cmd;
d366 4
d446 5
d519 3
d525 7
d561 12
d575 1
a575 1
		if (scb->buf == 0)
d577 2
a578 1
		scb = 0;
d580 2
d707 5
d716 1
d741 1
a741 1
	u_char stat;
d822 9
d871 1
a871 1
	wds_wait(sc, WDS_STAT, WDSS_RDY, WDSS_RDY);
d875 1
a875 1
			    sc->sc_dev.dv_xname,
d880 1
a880 1
		    sc->sc_dev.dv_xname);
d905 2
a906 1
	}
d918 2
d923 3
d952 6
d959 1
d963 1
a963 1
	wds_wait(sc, WDS_STAT, WDSS_INIT, WDSS_INIT);
d968 1
a968 1
	bus_io_write_1(sc->sc_bc, sc->sc_ioh, WDS_HCR, WDSH_DRQEN);
d1050 3
d1062 6
d1123 10
d1182 1
d1195 13
d1211 1
d1248 19
d1396 3
a1398 3
	struct scsi_xfer *xs = scb->xs;
	struct scsi_link *sc_link = xs->sc_link;
	struct wds_softc *sc = sc_link->adapter_softc;
d1401 8
a1410 2

	s = splbio();
@


1.6
log
@contextual usage
@
text
@d1 1
d68 1
d111 2
a112 1
	int sc_iobase;
d141 2
a142 2
integrate void    wds_wait __P((int, int, int));
int     wds_cmd __P((int, u_char *, int));
d196 2
a197 1
wds_wait(port, mask, val)
d202 2
d205 1
a205 1
	while ((inb(port) & mask) != val)
d213 2
a214 2
wds_cmd(iobase, ibuf, icnt)
	int iobase;
d218 2
d222 1
a222 1
	wds_wait(iobase + WDS_STAT, WDSS_RDY, WDSS_RDY);
d225 3
a227 3
		outb(iobase + WDS_CMD, *ibuf++);
		wds_wait(iobase + WDS_STAT, WDSS_RDY, WDSS_RDY);
		c = inb(iobase + WDS_STAT);
a282 1
	sc->sc_iobase = ia->ia_iobase;
d381 2
a382 1
	int iobase = sc->sc_iobase;
d386 1
a386 1
	if ((inb(iobase + WDS_STAT) & WDSS_IRQ) == 0)
d390 1
a390 1
	c = inb(iobase + WDS_IRQSTAT) & WDSI_MASK;
d393 1
a393 1
	outb(iobase + WDS_IRQACK, 0x00);
a647 1
	int iobase = sc->sc_iobase;
d659 1
a659 1
				wds_cmd(iobase, &c, sizeof c);
d679 1
a679 1
		wds_cmd(sc->sc_iobase, &c, sizeof c);
d789 2
a790 1
	int iobase = ia->ia_iobase;
d796 3
d802 1
a802 1
	c = inb(iobase + WDS_STAT);
d804 1
a804 1
		if ((inb(iobase+WDS_STAT) & WDSS_RDY) != 0) {
d811 2
a812 2
	outb(iobase + WDS_CMD, WDSC_NOOP);
	if (inb(iobase + WDS_STAT) & WDSS_RDY)
d815 1
a815 1
	outb(iobase + WDS_HCR, WDSH_SCSIRESET|WDSH_ASCRESET);
d817 1
a817 1
	outb(iobase + WDS_HCR, 0x00);
d819 6
a824 4
	wds_wait(iobase + WDS_STAT, WDSS_RDY, WDSS_RDY);
	if (inb(iobase + WDS_IRQSTAT) != 1)
		if (inb(iobase + WDS_IRQSTAT) != 7)
			printf("%s: failed reset!!! %2x\n", sc->sc_dev.dv_xname, inb(iobase + WDS_IRQSTAT));
d826 3
a828 2
	if ((inb(iobase + WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {
		printf("%s: waiting for controller to become ready.", sc->sc_dev.dv_xname);
d830 2
a831 1
			if ((inb(iobase + WDS_STAT) & (WDSS_RDY)) == WDSS_RDY)
d836 2
a837 1
		if ((inb(iobase + WDS_STAT) & (WDSS_RDY)) != WDSS_RDY) {
d849 2
a850 1
		sc->sc_iobase = iobase;
a864 1
	int iobase = sc->sc_iobase;
d896 1
a896 1
	wds_cmd(iobase, (u_char *)&init, sizeof init);
d898 1
a898 1
	wds_wait(iobase + WDS_STAT, WDSS_INIT, WDSS_INIT);
d901 1
a901 1
	wds_cmd(iobase, &c, sizeof c);
d903 1
a903 1
	outb(iobase + WDS_HCR, WDSH_DRQEN);
a913 1
	int iobase;
a916 2
	iobase = sc->sc_iobase;

d918 2
a919 1
		printf("%s: no request slot available in getvers()!\n", sc->sc_dev.dv_xname);
d930 1
a930 1
	outb(iobase + WDS_HCR, WDSH_DRQEN);
d974 2
a985 4
	int iobase;

	iobase = sc->sc_iobase;

d1140 1
a1140 1
		outb(iobase + WDS_HCR, WDSH_DRQEN);
d1144 1
a1144 1
		outb(iobase + WDS_HCR, WDSH_IRQEN | WDSH_DRQEN);
d1226 2
a1227 1
	int iobase = sc->sc_iobase;
d1235 1
a1235 1
		if (inb(iobase + WDS_STAT) & WDSS_IRQ)
d1254 2
a1255 1
	int iobase = sc->sc_iobase;
d1263 1
a1263 1
		if (inb(iobase + WDS_STAT) & WDSS_IRQ)
@


1.5
log
@turn off *DIAG; something is miserably wrong with it and various people
have wasted weeks because of the crashes.
@
text
@d611 1
d613 1
@


1.4
log
@sync 0521
@
text
@d3 1
a3 1
#define	WDSDIAG
d51 2
a52 1
 * Loosely based on Theo Deraadt's unfinished attempt.
@


1.3
log
@WDS_MBO_FREE/WDS_MBI_FREE botch
@
text
@d1 1
a1 1
/*	$NetBSD: wds.c,v 1.6 1996/05/05 00:40:03 mycroft Exp $	*/
d66 1
@


1.2
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 1
a1 1
/*	$NetBSD: wds.c,v 1.5 1996/04/29 19:48:26 christos Exp $	*/
d854 1
a854 1
		wmbx->mbi[i].stat = WDS_MBO_FREE;
@


1.1
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$NetBSD: wds.c,v 1.4 1996/04/11 22:30:38 cgd Exp $	*/
d373 1
a373 5
	u_char sts;

	struct wds_mbx_in *in;
	struct wds_scb *scb;
	u_char stat, c;
d395 2
a396 1
		printf("%s: unrecognized interrupt type %02x", c);
a638 1
	int i;
d643 1
a643 1
	while (scb = sc->sc_waiting_scb.tqh_first) {
a672 1
	next:
a689 1
	int i, x;
d961 1
d963 1
a1161 2
	u_char c;
	int i;
@
