head	1.41;
access;
symbols
	OPENBSD_6_2_BASE:1.41
	OPENBSD_6_1:1.41.0.14
	OPENBSD_6_1_BASE:1.41
	OPENBSD_6_0:1.41.0.10
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.8
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.41.0.6
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.40.0.14
	OPENBSD_5_5_BASE:1.40
	OPENBSD_5_4:1.40.0.10
	OPENBSD_5_4_BASE:1.40
	OPENBSD_5_3:1.40.0.8
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.6
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.4
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.37.0.4
	OPENBSD_4_9_BASE:1.37
	OPENBSD_4_8:1.37.0.2
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.36.0.6
	OPENBSD_4_7_BASE:1.36
	OPENBSD_4_6:1.36.0.8
	OPENBSD_4_6_BASE:1.36
	OPENBSD_4_5:1.36.0.4
	OPENBSD_4_5_BASE:1.36
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.35.0.20
	OPENBSD_4_3_BASE:1.35
	OPENBSD_4_2:1.35.0.18
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.35.0.16
	OPENBSD_4_1_BASE:1.35
	OPENBSD_4_0:1.35.0.14
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.35.0.12
	OPENBSD_3_9_BASE:1.35
	OPENBSD_3_8:1.35.0.10
	OPENBSD_3_8_BASE:1.35
	OPENBSD_3_7:1.35.0.8
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.35.0.6
	OPENBSD_3_6_BASE:1.35
	SMP_SYNC_A:1.35
	SMP_SYNC_B:1.35
	OPENBSD_3_5:1.35.0.4
	OPENBSD_3_5_BASE:1.35
	OPENBSD_3_4:1.35.0.2
	OPENBSD_3_4_BASE:1.35
	UBC_SYNC_A:1.35
	OPENBSD_3_3:1.34.0.4
	OPENBSD_3_3_BASE:1.34
	OPENBSD_3_2:1.34.0.2
	OPENBSD_3_2_BASE:1.34
	OPENBSD_3_1:1.32.0.2
	OPENBSD_3_1_BASE:1.32
	UBC_SYNC_B:1.34
	UBC:1.31.0.4
	UBC_BASE:1.31
	OPENBSD_3_0:1.31.0.2
	OPENBSD_3_0_BASE:1.31
	OPENBSD_2_9_BASE:1.30
	OPENBSD_2_9:1.30.0.2
	OPENBSD_2_8:1.28.0.8
	OPENBSD_2_8_BASE:1.28
	OPENBSD_2_7:1.28.0.6
	OPENBSD_2_7_BASE:1.28
	SMP:1.28.0.4
	SMP_BASE:1.28
	kame_19991208:1.28
	OPENBSD_2_6:1.28.0.2
	OPENBSD_2_6_BASE:1.28
	OPENBSD_2_5:1.25.0.2
	OPENBSD_2_5_BASE:1.25
	OPENBSD_2_4:1.20.0.2
	OPENBSD_2_4_BASE:1.20
	OPENBSD_2_3:1.17.0.2
	OPENBSD_2_3_BASE:1.17
	OPENBSD_2_2:1.11.0.2
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9
	OPENBSD_2_0:1.5.0.2
	OPENBSD_2_0_BASE:1.5;
locks; strict;
comment	@ * @;


1.41
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.40;
commitid	I19imNlAX05zJOED;

1.40
date	2011.06.29.12.17.40;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.38;

1.38
date	2011.04.05.19.54.35;	author jasper;	state Exp;
branches;
next	1.37;

1.37
date	2010.06.24.21.17.59;	author jasper;	state Exp;
branches;
next	1.36;

1.36
date	2008.05.21.19.20.08;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.34;

1.34
date	2002.07.07.18.20.00;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2002.06.30.16.05.58;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches
	1.31.4.1;
next	1.30;

1.30
date	2001.01.29.06.16.14;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2001.01.29.05.51.00;	author mickey;	state Exp;
branches;
next	1.28;

1.28
date	99.08.22.06.13.10;	author deraadt;	state Exp;
branches
	1.28.4.1;
next	1.27;

1.27
date	99.08.11.17.18.47;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	99.08.10.22.00.43;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	99.03.04.22.14.35;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	99.03.04.08.57.34;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	99.01.11.01.57.53;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	98.12.28.09.38.48;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	98.11.30.10.44.55;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.07.28.15.25.40;	author csapuntz;	state Exp;
branches;
next	1.19;

1.19
date	98.07.28.13.26.50;	author csapuntz;	state Exp;
branches;
next	1.18;

1.18
date	98.06.02.18.23.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	98.01.20.18.40.31;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.12.30.07.00.39;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	97.12.26.09.35.38;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	97.12.25.12.06.48;	author downsj;	state Exp;
branches;
next	1.13;

1.13
date	97.12.25.09.22.38;	author downsj;	state Exp;
branches;
next	1.12;

1.12
date	97.12.21.14.41.24;	author downsj;	state Exp;
branches;
next	1.11;

1.11
date	97.07.13.22.27.04;	author weingart;	state Exp;
branches;
next	1.10;

1.10
date	97.07.12.23.22.01;	author weingart;	state Exp;
branches;
next	1.9;

1.9
date	96.11.29.22.55.03;	author niklas;	state Exp;
branches;
next	1.8;

1.8
date	96.11.23.21.46.42;	author kstailey;	state Exp;
branches;
next	1.7;

1.7
date	96.11.12.20.30.39;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.10.18.15.39.34;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.08.16.08.35.01;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	96.08.15.17.28.40;	author shawn;	state Exp;
branches;
next	1.3;

1.3
date	96.08.15.06.33.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	96.08.15.05.31.43;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.08.14.14.36.15;	author shawn;	state Exp;
branches;
next	;

1.28.4.1
date	2001.05.14.22.24.45;	author niklas;	state Exp;
branches;
next	1.28.4.2;

1.28.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.28.4.3;

1.28.4.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.28.4.4;

1.28.4.4
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.28.4.5;

1.28.4.5
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	;

1.31.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.31.4.2;

1.31.4.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.31.4.3;

1.31.4.3
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.41
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@/*	$OpenBSD: isapnp.c,v 1.40 2011/06/29 12:17:40 tedu Exp $	*/
/*	$NetBSD: isapnp.c,v 1.9.4.3 1997/10/29 00:40:43 thorpej Exp $	*/

/*
 * Copyright (c) 1996 Christos Zoulas.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Christos Zoulas.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * ISA PnP bus autoconfiguration.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/isa/isapnpreg.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/isa/pnpdevs.h>

#include "isadma.h"

void isapnp_init(struct isapnp_softc *);
static __inline u_char isapnp_shift_bit(struct isapnp_softc *);
int isapnp_findcard(struct isapnp_softc *);
void isapnp_free_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_irq(isa_chipset_tag_t, struct isapnp_pin *);
int isapnp_alloc_drq(struct device *, struct isapnp_pin *);
int isapnp_testconfig(bus_space_tag_t, bus_space_tag_t,
    struct isa_attach_args *, int);
struct isa_attach_args *isapnp_bestconfig(struct device *,
    struct isapnp_softc *, struct isa_attach_args **);
void isapnp_print_region(const char *, struct isapnp_region *,
    size_t);
void isapnp_configure(struct isapnp_softc *,
    const struct isa_attach_args *);
void isapnp_print_pin(const char *, struct isapnp_pin *, size_t);
int isapnp_print(void *, const char *);
int isapnp_submatch(struct device *, void *, void *);
int isapnp_com_submatch(struct device *, void *, void *);
int isapnp_find(struct isapnp_softc *, int);
int isapnp_match(struct device *, void *, void *);
void isapnp_attach(struct device *, struct device *, void *);

#ifdef DEBUG_ISAPNP
# define DPRINTF(a) printf a
#else
# define DPRINTF(a)
#endif

struct cfattach isapnp_ca = {
	sizeof(struct isapnp_softc), isapnp_match, isapnp_attach
};

struct cfdriver isapnp_cd = {
	NULL, "isapnp", DV_DULL
};


/* isapnp_init():
 *	Write the PNP initiation key to wake up the cards...
 */
void
isapnp_init(sc)
	struct isapnp_softc *sc;
{
	int i;
	u_char v = ISAPNP_LFSR_INIT;

	/* First write 0's twice to enter the Wait for Key state */
	ISAPNP_WRITE_ADDR(sc, 0);
	ISAPNP_WRITE_ADDR(sc, 0);

	/* Send the 32 byte sequence to awake the logic */
	for (i = 0; i < ISAPNP_LFSR_LENGTH; i++) {
		ISAPNP_WRITE_ADDR(sc, v);
		v = ISAPNP_LFSR_NEXT(v);
	}
}


/* isapnp_shift_bit():
 *	Read a bit at a time from the config card.
 */
static __inline u_char
isapnp_shift_bit(sc)
	struct isapnp_softc *sc;
{
	u_char c1, c2;

	DELAY(250);
	c1 = ISAPNP_READ_DATA(sc);
	DELAY(250);
	c2 = ISAPNP_READ_DATA(sc);

	if (c1 == 0x55 && c2 == 0xAA)
		return 0x80;
	else
		return 0;
}


/* isapnp_findcard():
 *	Attempt to read the vendor/serial/checksum for a card
 *	If a card is found [the checksum matches], assign the
 *	next card number to it and return 1
 */
int
isapnp_findcard(sc)
	struct isapnp_softc *sc;
{
	u_char v = ISAPNP_LFSR_INIT, csum, w;
	int i, b;

	if (sc->sc_ncards == ISAPNP_MAX_CARDS) {
		printf("%s: Too many pnp cards\n", sc->sc_dev.dv_xname);
		return 0;
	}

	/* Set the read port */
	isapnp_write_reg(sc, ISAPNP_WAKE, 0);
	isapnp_write_reg(sc, ISAPNP_SET_RD_PORT, sc->sc_read_port >> 2);
	sc->sc_read_port |= 3;
	DELAY(1000);

	ISAPNP_WRITE_ADDR(sc, ISAPNP_SERIAL_ISOLATION);
	DELAY(1000);

	/* Read the 8 bytes of the Vendor ID and Serial Number */
	for(i = 0; i < 8; i++) {
		/* Read each bit separately */
		for (w = 0, b = 0; b < 8; b++) {
			u_char neg = isapnp_shift_bit(sc);

			w >>= 1;
			w |= neg;
			v = ISAPNP_LFSR_NEXT(v) ^ neg;
		}
		sc->sc_id[sc->sc_ncards][i] = w;
	}

	/* Read the remaining checksum byte */
	for (csum = 0, b = 0; b < 8; b++) {
		u_char neg = isapnp_shift_bit(sc);

		csum >>= 1;
		csum |= neg;
	}
	sc->sc_id[sc->sc_ncards][8] = csum;

	if (csum == v) {
		sc->sc_ncards++;
		isapnp_write_reg(sc, ISAPNP_CARD_SELECT_NUM, sc->sc_ncards);
		return 1;
	}
	return 0;
}


/* isapnp_free_region():
 *	Free a region
 */
void
isapnp_free_region(t, r)
	bus_space_tag_t t;
	struct isapnp_region *r;
{
	if (r->length == 0)
		return;

	bus_space_unmap(t, r->h, r->length);
	r->h = 0;
}


/* isapnp_alloc_region():
 *	Allocate a single region if possible
 */
int
isapnp_alloc_region(t, r)
	bus_space_tag_t t;
	struct isapnp_region *r;
{
	int error = 0;

	if (r->length == 0)
		return 0;

	r->h = 0;
	for (r->base = r->minbase; r->base <= r->maxbase;
	     r->base += r->align) {
		error = bus_space_map(t, r->base, r->length, 0, &r->h);
		if (error == 0)
			return 0;
	}
	return error;
}


/* isapnp_alloc_irq():
 *	Allocate an irq
 */
int
isapnp_alloc_irq(ic, i)
	isa_chipset_tag_t ic;
	struct isapnp_pin *i;
{
	int irq;
#define LEVEL_IRQ (ISAPNP_IRQTYPE_LEVEL_PLUS|ISAPNP_IRQTYPE_LEVEL_MINUS)
	i->type = (i->flags & LEVEL_IRQ) ? IST_LEVEL : IST_EDGE;

	if (i->bits == 0) {
		i->num = 0;
		return 0;
	}

	if (isa_intr_alloc(ic, i->bits, i->type, &irq) == 0) {
		i->num = irq;
		return 0;
	}

	return EINVAL;
}

/* isapnp_alloc_drq():
 *	Allocate a drq
 */
int
isapnp_alloc_drq(isa, i)
	struct device *isa;
	struct isapnp_pin *i;
{
#if NISADMA > 0
	int b;

	if (i->bits == 0) {
		i->num = 0;
		return 0;
	}

	for (b = 0; b < 16; b++)
		if ((i->bits & (1 << b)) && isa_drq_isfree(isa, b)) {
			i->num = b;
			return 0;
		}
#endif

	return EINVAL;
}

/* isapnp_testconfig():
 *	Test/Allocate the regions used
 */
int
isapnp_testconfig(iot, memt, ipa, alloc)
	bus_space_tag_t iot, memt;
	struct isa_attach_args *ipa;
	int alloc;
{
	int nio = 0, nmem = 0, nmem32 = 0, nirq = 0, ndrq = 0;
	int error = 0;

#ifdef DEBUG_ISAPNP
	isapnp_print_attach(ipa);
#endif

	for (; nio < ipa->ipa_nio; nio++) {
		error = isapnp_alloc_region(iot, &ipa->ipa_io[nio]);
		if (error)
			goto bad;
	}

	for (; nmem < ipa->ipa_nmem; nmem++) {
		error = isapnp_alloc_region(memt, &ipa->ipa_mem[nmem]);
		if (error)
			goto bad;
	}

	for (; nmem32 < ipa->ipa_nmem32; nmem32++) {
		error = isapnp_alloc_region(memt, &ipa->ipa_mem32[nmem32]);
		if (error)
			goto bad;
	}

	for (; nirq < ipa->ipa_nirq; nirq++) {
		error = isapnp_alloc_irq(ipa->ia_ic, &ipa->ipa_irq[nirq]);
		if (error)
			goto bad;
	}

	for (; ndrq < ipa->ipa_ndrq; ndrq++) {
		error = isapnp_alloc_drq(ipa->ia_isa, &ipa->ipa_drq[ndrq]);
		if (error)
			goto bad;
	}

	if (alloc)
		return error;

bad:
	for (nmem32--; nmem32 >= 0; nmem32--)
		isapnp_free_region(memt, &ipa->ipa_mem32[nmem32]);

	for (nmem--; nmem >= 0; nmem--)
		isapnp_free_region(memt, &ipa->ipa_mem[nmem]);

	for (nio--; nio >= 0; nio--)
		isapnp_free_region(iot, &ipa->ipa_io[nio]);

	return error;
}


/* isapnp_config():
 *	Test/Allocate the regions used
 */
int
isapnp_config(iot, memt, ipa)
	bus_space_tag_t iot, memt;
	struct isa_attach_args *ipa;
{
	return isapnp_testconfig(iot, memt, ipa, 1);
}


/* isapnp_unconfig():
 *	Free the regions used
 */
void
isapnp_unconfig(iot, memt, ipa)
	bus_space_tag_t iot, memt;
	struct isa_attach_args *ipa;
{
	int i;

	for (i = 0; i < ipa->ipa_nmem32; i++)
		isapnp_free_region(memt, &ipa->ipa_mem32[i]);

	for (i = 0; i < ipa->ipa_nmem; i++)
		isapnp_free_region(memt, &ipa->ipa_mem[i]);

	for (i = 0; i < ipa->ipa_nio; i++)
		isapnp_free_region(iot, &ipa->ipa_io[i]);
}


/* isapnp_bestconfig():
 *	Return the best configuration for each logical device, remove and
 *	free all other configurations.
 */
struct isa_attach_args *
isapnp_bestconfig(isa, sc, ipa)
	struct device *isa;
	struct isapnp_softc *sc;
	struct isa_attach_args **ipa;
{
	struct isa_attach_args *c, *best, *f = *ipa;
	int error;

	for (;;) {
		if (f == NULL)
			return NULL;

#define SAMEDEV(a, b) (strcmp((a)->ipa_devlogic, (b)->ipa_devlogic) == 0)

		/* Find the best config */
		for (best = c = f; c != NULL; c = c->ipa_sibling) {
			if (!SAMEDEV(c, f))
				continue;
			if (c->ipa_pref < best->ipa_pref)
				best = c;
		}

		best->ia_isa = isa;
		/* Test the best config */
		error = isapnp_testconfig(sc->sc_iot, sc->sc_memt, best, 0);

		/* Remove this config from the list */
		if (best == f)
			f = f->ipa_sibling;
		else {
			for (c = f; c->ipa_sibling != best; c = c->ipa_sibling)
				continue;
			c->ipa_sibling = best->ipa_sibling;
		}

		if (error) {
			best->ipa_pref = ISAPNP_DEP_CONFLICTING;

			for (c = f; c != NULL; c = c->ipa_sibling)
				if (c != best && SAMEDEV(c, best))
					break;
			/* Last config for this logical device is conflicting */
			if (c == NULL) {
				*ipa = f;
				return best;
			}

			free(best, M_DEVBUF, 0);
			continue;
		}
		else {
			/* Remove all other configs for this device */
			struct isa_attach_args *l = NULL, *n = NULL, *d;

			for (c = f; c; ) {
				if (c == best)
					continue;
				d = c->ipa_sibling;
				if (SAMEDEV(c, best))
					free(c, M_DEVBUF, 0);
				else {
					if (n)
						n->ipa_sibling = c;

					else
						l = c;
					n = c;
					c->ipa_sibling = NULL;
				}
				c = d;
			}
			f = l;
		}
		*ipa = f;
		return best;
	}
}


/* isapnp_id_to_vendor():
 *	Convert a pnp ``compressed ascii'' vendor id to a string
 */
char *
isapnp_id_to_vendor(v, id)
	char   *v;
	const u_char *id;
{
	static const char hex[] = "0123456789ABCDEF";
	char *p = v;

	*p++ = 'A' + (id[0] >> 2) - 1;
	*p++ = 'A' + ((id[0] & 3) << 3) + (id[1] >> 5) - 1;
	*p++ = 'A' + (id[1] & 0x1f) - 1;
	*p++ = hex[id[2] >> 4];
	*p++ = hex[id[2] & 0x0f];
	*p++ = hex[id[3] >> 4];
	*p++ = hex[id[3] & 0x0f];
	*p = '\0';

	return v;
}


/* isapnp_print_region():
 *	Print a region allocation
 */
void
isapnp_print_region(str, r, n)
	const char *str;
	struct isapnp_region *r;
	size_t n;
{
	size_t i;

	if (n == 0)
		return;

	printf(" %s ", str);
	for (i = 0; i < n; i++, r++) {
		printf("0x%x", r->base);
		if (r->length)
			printf("/%d", r->length);
		if (i != n - 1)
			printf(",");
	}
}


/* isapnp_print_pin():
 *	Print an irq/drq assignment
 */
void
isapnp_print_pin(str, p, n)
	const char *str;
	struct isapnp_pin *p;
	size_t n;
{
	size_t i;

	if (n == 0)
		return;

	printf(" %s ", str);
	for (i = 0; i < n; i++, p++) {
		printf("%d", p->num);
		if (i != n - 1)
			printf(",");
	}
}

/* isapnp_print():
 *	Print the configuration line for an ISA PnP card.
 */
int
isapnp_print(aux, str)
	void *aux;
	const char *str;
{
	struct isa_attach_args *ipa = aux;

	if (!str)
		printf(" ");
	printf("\"%s, %s, %s, %s\"", ipa->ipa_devident,
	    ipa->ipa_devlogic, ipa->ipa_devcompat, ipa->ipa_devclass);

	if (str)
		printf(" at %s", str);

	isapnp_print_region("port", ipa->ipa_io, ipa->ipa_nio);
	isapnp_print_region("mem", ipa->ipa_mem, ipa->ipa_nmem);
	isapnp_print_region("mem32", ipa->ipa_mem32, ipa->ipa_nmem32);
	isapnp_print_pin("irq", ipa->ipa_irq, ipa->ipa_nirq);
	isapnp_print_pin("drq", ipa->ipa_drq, ipa->ipa_ndrq);
	return UNCONF;
}


/* isapnp_submatch():
 * Special case.
 * A lot of com devices do not have the PNPxxx identifiers
 * they should have.  If it looks like a modem..... let's try it.
 */
int
isapnp_com_submatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct isa_attach_args *ipa = aux;

	if (strcmp("com", cf->cf_driver->cd_name) == 0 &&
	    ipa->ipa_nio == 1 && ipa->ipa_nirq == 1 &&
	    ipa->ipa_ndrq == 0 && ipa->ipa_nmem == 0 &&
	    ipa->ipa_io[0].length == 8) {
		if (isapnp_config(ipa->ia_iot, ipa->ia_memt, ipa)) {
			printf("%s: error in region allocation\n",
			    cf->cf_driver->cd_name);
			return (0);
		}
		return ((*cf->cf_attach->ca_match)(parent, match, ipa));
	}
	return (0);
}

/* isapnp_submatch():
 *	Probe the logical device...
 */
int
isapnp_submatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct isa_attach_args *ipa = aux;
	const char *dname;
	int i;

	for (i = 0; i < nitems(isapnp_knowndevs); i++) {
		dname = NULL;

		if (strcmp(isapnp_knowndevs[i].pnpid, ipa->ipa_devlogic) == 0)
			dname = isapnp_knowndevs[i].driver;
		else if (strcmp(isapnp_knowndevs[i].pnpid, ipa->ipa_devcompat) == 0)
			dname = isapnp_knowndevs[i].driver;

		if (dname && strcmp(dname, cf->cf_driver->cd_name) == 0) {
			/*
			 * We found a match.  Configure the card and call the
			 * ISA probe...
			 */
			if (isapnp_config(ipa->ia_iot, ipa->ia_memt, ipa)) {
				printf("%s: error in region allocation\n",
				    cf->cf_driver->cd_name);
				return (0);
			}

			return ((*cf->cf_attach->ca_match)(parent, match, ipa));
		}
	}

	return (0);
}

/* isapnp_find():
 *	Probe and add cards
 */
int
isapnp_find(sc, all)
	struct isapnp_softc *sc;
	int all;
{
	int p;

	isapnp_init(sc);

	isapnp_write_reg(sc, ISAPNP_CONFIG_CONTROL, ISAPNP_CC_RESET_DRV);
	DELAY(2000);

	isapnp_init(sc);
	DELAY(2000);

	for (p = ISAPNP_RDDATA_MIN; p <= ISAPNP_RDDATA_MAX; p += 4) {
		sc->sc_read_port = p;
		if (isapnp_map_readport(sc))
			continue;
		DPRINTF(("%s: Trying port %x\n", sc->sc_dev.dv_xname, p));
		if (isapnp_findcard(sc))
			break;
		isapnp_unmap_readport(sc);
	}

	if (p > ISAPNP_RDDATA_MAX) {
		sc->sc_read_port = 0;
		return 0;
	}

	if (all)
		while (isapnp_findcard(sc))
			continue;

	return 1;
}


/* isapnp_configure():
 *	Configure a PnP card
 *	XXX: The memory configuration code is wrong. We need to check the
 *	     range/length bit an do appropriate sets.
 */
void
isapnp_configure(sc, ipa)
	struct isapnp_softc *sc;
	const struct isa_attach_args *ipa;
{
	int i;
	static u_char isapnp_mem_range[] = ISAPNP_MEM_DESC;
	static u_char isapnp_io_range[] = ISAPNP_IO_DESC;
	static u_char isapnp_irq_range[] = ISAPNP_IRQ_DESC;
	static u_char isapnp_drq_range[] = ISAPNP_DRQ_DESC;
	static u_char isapnp_mem32_range[] = ISAPNP_MEM32_DESC;
	const struct isapnp_region *r;
	const struct isapnp_pin *p;
	struct isapnp_region rz;
	struct isapnp_pin pz;

	bzero(&pz, sizeof(pz));
	bzero(&rz, sizeof(rz));

#define B0(a) ((a) & 0xff)
#define B1(a) (((a) >> 8) & 0xff)
#define B2(a) (((a) >> 16) & 0xff)
#define B3(a) (((a) >> 24) & 0xff)

	for (i = 0; i < sizeof(isapnp_io_range); i++) {
		if (i < ipa->ipa_nio)
			r = &ipa->ipa_io[i];
		else
			r = &rz;

		isapnp_write_reg(sc,
		    isapnp_io_range[i] + ISAPNP_IO_BASE_15_8, B1(r->base));
		isapnp_write_reg(sc,
		    isapnp_io_range[i] + ISAPNP_IO_BASE_7_0, B0(r->base));
	}

	for (i = 0; i < sizeof(isapnp_mem_range); i++) {
		if (i < ipa->ipa_nmem)
			r = &ipa->ipa_mem[i];
		else
			r = &rz;

		isapnp_write_reg(sc,
		    isapnp_mem_range[i] + ISAPNP_MEM_BASE_23_16, B2(r->base));
		isapnp_write_reg(sc,
		    isapnp_mem_range[i] + ISAPNP_MEM_BASE_15_8, B1(r->base));

		isapnp_write_reg(sc,
		    isapnp_mem_range[i] + ISAPNP_MEM_LRANGE_23_16,
		    B2(r->length));
		isapnp_write_reg(sc,
		    isapnp_mem_range[i] + ISAPNP_MEM_LRANGE_15_8,
		    B1(r->length));
	}

	for (i = 0; i < sizeof(isapnp_irq_range); i++) {
		u_char v;

		if (i < ipa->ipa_nirq)
			p = &ipa->ipa_irq[i];
		else
			p = &pz;

		isapnp_write_reg(sc,
		    isapnp_irq_range[i] + ISAPNP_IRQ_NUMBER, p->num);

		switch (p->flags) {
		case ISAPNP_IRQTYPE_LEVEL_PLUS:
			v = ISAPNP_IRQ_LEVEL|ISAPNP_IRQ_HIGH;
			break;

		case ISAPNP_IRQTYPE_EDGE_PLUS:
			v = ISAPNP_IRQ_HIGH;
			break;

		case ISAPNP_IRQTYPE_LEVEL_MINUS:
			v = ISAPNP_IRQ_LEVEL;
			break;

		default:
		case ISAPNP_IRQTYPE_EDGE_MINUS:
			v = 0;
			break;
		}
		isapnp_write_reg(sc,
		    isapnp_irq_range[i] + ISAPNP_IRQ_CONTROL, v);
	}

	for (i = 0; i < sizeof(isapnp_drq_range); i++) {
		u_char v;

		if (i < ipa->ipa_ndrq)
			v = ipa->ipa_drq[i].num;
		else
			v = 4;

		isapnp_write_reg(sc, isapnp_drq_range[i], v);
	}

	for (i = 0; i < sizeof(isapnp_mem32_range); i++) {
		if (i < ipa->ipa_nmem32)
			r = &ipa->ipa_mem32[i];
		else
			r = &rz;

		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_BASE_31_24,
		    B3(r->base));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_BASE_23_16,
		    B2(r->base));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_BASE_15_8,
		    B1(r->base));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_BASE_7_0,
		    B0(r->base));

		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_LRANGE_31_24,
		    B3(r->length));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_LRANGE_23_16,
		    B2(r->length));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_LRANGE_15_8,
		    B1(r->length));
		isapnp_write_reg(sc,
		    isapnp_mem32_range[i] + ISAPNP_MEM32_LRANGE_7_0,
		    B0(r->length));
	}
}


/*
 * Some BIOSes take the liberty of configuring our ISA cards for us.
 * This code undoes the PNP card configuration.
 */

void
isapnp_isa_attach_hook(isa_sc)
	struct isa_softc *isa_sc;

{
	struct isapnp_softc sc;

	bzero(&sc, sizeof sc);
	sc.sc_iot = isa_sc->sc_iot;
	sc.sc_ncards = 0;

	if (isapnp_map(&sc))
		return;

	isapnp_init(&sc);

	isapnp_write_reg(&sc, ISAPNP_CONFIG_CONTROL, ISAPNP_CC_RESET_DRV);
	DELAY(2000);

	isapnp_unmap(&sc);
}

/* isapnp_match():
 *	Probe routine
 */
int
isapnp_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	int rv;
	struct isapnp_softc sc;
	struct isa_attach_args *ia = aux;

	sc.sc_iot = ia->ia_iot;
	sc.sc_ncards = 0;
	(void) strlcpy(sc.sc_dev.dv_xname, "(isapnp probe)",
	     sizeof sc.sc_dev.dv_xname);

	if (isapnp_map(&sc))
		return 0;

	rv = isapnp_find(&sc, 0);
	ia->ia_iobase = ISAPNP_ADDR;
	ia->ia_iosize = 1;

	isapnp_unmap(&sc);
	if (rv)
		isapnp_unmap_readport(&sc);

	return (rv);
}


/* isapnp_attach
 *	Find and attach PnP cards.
 */
void
isapnp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isapnp_softc *sc = (struct isapnp_softc *) self;
	struct isa_attach_args *ia = aux;
	void *match;
	int c, d;

	sc->sc_iot = ia->ia_iot;
	sc->sc_memt = ia->ia_memt;
#if NISADMA > 0
	sc->sc_dmat = ia->ia_dmat;
#endif
	sc->sc_ncards = 0;

	if (isapnp_map(sc))
		panic("%s: bus map failed", sc->sc_dev.dv_xname);

	if (!isapnp_find(sc, 1)) {
		printf(": no cards found\n");
		return;
	}

	printf(": read port 0x%x\n", sc->sc_read_port);

	for (c = 0; c < sc->sc_ncards; c++) {
		struct isa_attach_args *ipa, *lpa;

		/* Good morning card c */
		isapnp_write_reg(sc, ISAPNP_WAKE, c + 1);

		if ((ipa = isapnp_get_resource(sc, c, ia)) == NULL)
			continue;

		DPRINTF(("Selecting attachments\n"));
		for (d = 0;
		    (lpa = isapnp_bestconfig(parent, sc, &ipa)) != NULL; d++) {
			isapnp_write_reg(sc, ISAPNP_LOGICAL_DEV_NUM, d);
			isapnp_configure(sc, lpa);
#ifdef DEBUG_ISAPNP
			{
				struct isa_attach_args pa;

				isapnp_get_config(sc, &pa);
				isapnp_print_config(&pa);
			}
#endif

			DPRINTF(("%s: configuring <%s, %s, %s, %s>\n",
			    sc->sc_dev.dv_xname,
			    lpa->ipa_devident, lpa->ipa_devlogic,
			    lpa->ipa_devcompat, lpa->ipa_devclass));
			if (lpa->ipa_pref == ISAPNP_DEP_CONFLICTING) {
				isapnp_print(lpa, self->dv_xname);
				printf(" resource conflict\n");
				free(lpa, M_DEVBUF, 0);
				continue;
			}

			lpa->ia_ic = ia->ia_ic;
			lpa->ia_iot = ia->ia_iot;
			lpa->ia_memt = ia->ia_memt;
#if NISADMA > 0
			lpa->ia_dmat = ia->ia_dmat;
#endif
			lpa->ia_delaybah = ia->ia_delaybah;

			isapnp_write_reg(sc, ISAPNP_ACTIVATE, 1);

			if ((match = config_search(isapnp_submatch,
			    self, lpa)))
				config_attach(self, match, lpa, isapnp_print);
			else if ((match = config_search(isapnp_com_submatch,
			    self, lpa)))
				config_attach(self, match, lpa, isapnp_print);
			else {
				isapnp_print(lpa, self->dv_xname);
				printf(" not configured\n");
				isapnp_write_reg(sc, ISAPNP_ACTIVATE, 0);
			}
			free(lpa, M_DEVBUF, 0);
		}
		isapnp_write_reg(sc, ISAPNP_WAKE, 0);    /* Good night cards */
	}
}
@


1.40
log
@notyet, notever.  delete a bunch of code we won't be using.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.39 2011/04/07 15:30:16 miod Exp $	*/
d430 1
a430 1
			free(best, M_DEVBUF);
d442 1
a442 1
					free(c, M_DEVBUF);
d926 1
a926 1
				free(lpa, M_DEVBUF);
d951 1
a951 1
			free(lpa, M_DEVBUF);
@


1.39
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.38 2011/04/05 19:54:35 jasper Exp $	*/
a331 8
#ifdef notyet
	for (ndrq--; ndrq >= 0; ndrq--)
		isapnp_free_pin(&ipa->ipa_drq[ndrq]);

	for (nirq--; nirq >= 0; nirq--)
		isapnp_free_pin(&ipa->ipa_irq[nirq]);
#endif

a365 8

#ifdef notyet
	for (i = 0; i < ipa->ipa_ndrq; i++)
		isapnp_free_pin(&ipa->ipa_drq[i]);

	for (i = 0; i < ipa->ipa_nirq; i++)
		isapnp_free_pin(&ipa->ipa_irq[i]);
#endif
@


1.38
log
@- use nitems() no binary change on amd64

"reads OK" claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.37 2010/06/24 21:17:59 jasper Exp $	*/
d203 1
a203 1
	r->h = NULL;
d220 1
a220 1
	r->h = NULL;
@


1.37
log
@- remove ISAPNP_FREE and ISAPNP_MALLOC macro's and just use them inline.

ok thib@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.36 2008/05/21 19:20:08 miod Exp $	*/
d616 1
a616 1
	for (i = 0; i < sizeof(isapnp_knowndevs)/sizeof(isapnp_knowndevs[0]); i++) {
@


1.36
log
@More pccom references
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.35 2003/04/27 11:22:53 ho Exp $	*/
d446 1
a446 1
			ISAPNP_FREE(best);
d458 1
a458 1
					ISAPNP_FREE(c);
d942 1
a942 1
				ISAPNP_FREE(lpa);
d967 1
a967 1
			ISAPNP_FREE(lpa);
@


1.35
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.34 2002/07/07 18:20:00 miod Exp $	*/
d578 1
a578 1
 * A lot of com/pccom devices do not have the PNPxxx identifiers
d589 1
a589 2
	if ((strcmp("com", cf->cf_driver->cd_name) == 0 ||
	    strcmp("pccom", cf->cf_driver->cd_name) == 0) &&
@


1.34
log
@Allow isapnp to compile without isadma configured. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.33 2002/06/30 16:05:58 miod Exp $	*/
d865 2
a866 1
	(void) strcpy(sc.sc_dev.dv_xname, "(isapnp probe)");
@


1.33
log
@When duplicating isa_attach_args structures to build several attachement
possibilities for isapnp devices, make sure to carry the original ia_ic
member. Although mostly unused on i386, it is vital on alpha.

This makes isapnp on alpha attach without panicing.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.32 2002/03/14 01:26:56 millert Exp $	*/
d51 2
d264 1
d277 1
@


1.32
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.31 2001/09/21 17:55:43 miod Exp $	*/
d914 1
a914 1
		if ((ipa = isapnp_get_resource(sc, c)) == NULL)
@


1.31
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.30 2001/01/29 06:16:14 mickey Exp $	*/
d51 22
a72 22
void isapnp_init __P((struct isapnp_softc *));
static __inline u_char isapnp_shift_bit __P((struct isapnp_softc *));
int isapnp_findcard __P((struct isapnp_softc *));
void isapnp_free_region __P((bus_space_tag_t, struct isapnp_region *));
int isapnp_alloc_region __P((bus_space_tag_t, struct isapnp_region *));
int isapnp_alloc_irq __P((isa_chipset_tag_t, struct isapnp_pin *));
int isapnp_alloc_drq __P((struct device *, struct isapnp_pin *));
int isapnp_testconfig __P((bus_space_tag_t, bus_space_tag_t,
    struct isa_attach_args *, int));
struct isa_attach_args *isapnp_bestconfig __P((struct device *,
    struct isapnp_softc *, struct isa_attach_args **));
void isapnp_print_region __P((const char *, struct isapnp_region *,
    size_t));
void isapnp_configure __P((struct isapnp_softc *,
    const struct isa_attach_args *));
void isapnp_print_pin __P((const char *, struct isapnp_pin *, size_t));
int isapnp_print __P((void *, const char *));
int isapnp_submatch __P((struct device *, void *, void *));
int isapnp_com_submatch __P((struct device *, void *, void *));
int isapnp_find __P((struct isapnp_softc *, int));
int isapnp_match __P((struct device *, void *, void *));
void isapnp_attach __P((struct device *, struct device *, void *));
@


1.31.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.31 2001/09/21 17:55:43 miod Exp $	*/
d51 22
a72 22
void isapnp_init(struct isapnp_softc *);
static __inline u_char isapnp_shift_bit(struct isapnp_softc *);
int isapnp_findcard(struct isapnp_softc *);
void isapnp_free_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_irq(isa_chipset_tag_t, struct isapnp_pin *);
int isapnp_alloc_drq(struct device *, struct isapnp_pin *);
int isapnp_testconfig(bus_space_tag_t, bus_space_tag_t,
    struct isa_attach_args *, int);
struct isa_attach_args *isapnp_bestconfig(struct device *,
    struct isapnp_softc *, struct isa_attach_args **);
void isapnp_print_region(const char *, struct isapnp_region *,
    size_t);
void isapnp_configure(struct isapnp_softc *,
    const struct isa_attach_args *);
void isapnp_print_pin(const char *, struct isapnp_pin *, size_t);
int isapnp_print(void *, const char *);
int isapnp_submatch(struct device *, void *, void *);
int isapnp_com_submatch(struct device *, void *, void *);
int isapnp_find(struct isapnp_softc *, int);
int isapnp_match(struct device *, void *, void *);
void isapnp_attach(struct device *, struct device *, void *);
@


1.31.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.31.4.1 2002/06/11 03:42:21 art Exp $	*/
a50 2
#include "isadma.h"

a261 1
#if NISADMA > 0
a273 1
#endif
d914 1
a914 1
		if ((ipa = isapnp_get_resource(sc, c, ia)) == NULL)
@


1.31.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d865 1
a865 2
	(void) strlcpy(sc.sc_dev.dv_xname, "(isapnp probe)",
	     sizeof sc.sc_dev.dv_xname);
@


1.30
log
@even shorter
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.29 2001/01/29 05:51:00 mickey Exp $	*/
d902 1
a902 1
		printf(": no cards found\n", sc->sc_dev.dv_xname);
@


1.29
log
@fix isadma-less compile, new pnpdevs, space control
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.28 1999/08/22 06:13:10 deraadt Exp $	*/
d613 1
a613 1
	for (i = 0; isapnp_knowndevs[i].pnpid[0]; i++) {
@


1.28
log
@make isapnp_print() use canonical format
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.27 1999/08/11 17:18:47 deraadt Exp $	*/
d60 1
a60 1
struct isa_attach_args *isapnp_bestconfig __P((struct device *, 
d458 1
a458 1
				
d484 1
a484 1
	
d613 1
a613 1
	for (i = 0; isapnp_knowndevs[i].pnpid; i++) {
d724 1
a724 1
		else 
d787 1
a787 1
		else 
d830 1
a830 1
	
d893 1
d895 1
d945 1
d947 1
@


1.28.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.30 2001/01/29 06:16:14 mickey Exp $	*/
d60 1
a60 1
struct isa_attach_args *isapnp_bestconfig __P((struct device *,
d458 1
a458 1

d484 1
a484 1

d613 1
a613 1
	for (i = 0; i < sizeof(isapnp_knowndevs)/sizeof(isapnp_knowndevs[0]); i++) {
d724 1
a724 1
		else
d787 1
a787 1
		else
d830 1
a830 1

a892 1
#if NISADMA > 0
a893 1
#endif
a942 1
#if NISADMA > 0
a943 1
#endif
@


1.28.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.28.4.1 2001/05/14 22:24:45 niklas Exp $	*/
d902 1
a902 1
		printf(": no cards found\n");
@


1.28.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d51 22
a72 22
void isapnp_init(struct isapnp_softc *);
static __inline u_char isapnp_shift_bit(struct isapnp_softc *);
int isapnp_findcard(struct isapnp_softc *);
void isapnp_free_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_region(bus_space_tag_t, struct isapnp_region *);
int isapnp_alloc_irq(isa_chipset_tag_t, struct isapnp_pin *);
int isapnp_alloc_drq(struct device *, struct isapnp_pin *);
int isapnp_testconfig(bus_space_tag_t, bus_space_tag_t,
    struct isa_attach_args *, int);
struct isa_attach_args *isapnp_bestconfig(struct device *,
    struct isapnp_softc *, struct isa_attach_args **);
void isapnp_print_region(const char *, struct isapnp_region *,
    size_t);
void isapnp_configure(struct isapnp_softc *,
    const struct isa_attach_args *);
void isapnp_print_pin(const char *, struct isapnp_pin *, size_t);
int isapnp_print(void *, const char *);
int isapnp_submatch(struct device *, void *, void *);
int isapnp_com_submatch(struct device *, void *, void *);
int isapnp_find(struct isapnp_softc *, int);
int isapnp_match(struct device *, void *, void *);
void isapnp_attach(struct device *, struct device *, void *);
@


1.28.4.4
log
@Sync the SMP branch with 3.3
@
text
@a50 2
#include "isadma.h"

a261 1
#if NISADMA > 0
a273 1
#endif
d914 1
a914 1
		if ((ipa = isapnp_get_resource(sc, c, ia)) == NULL)
@


1.28.4.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.28.4.4 2003/03/28 00:38:16 niklas Exp $	*/
d865 1
a865 2
	(void) strlcpy(sc.sc_dev.dv_xname, "(isapnp probe)",
	     sizeof sc.sc_dev.dv_xname);
@


1.27
log
@if we cannot match a device by name, check to see if it looks like a
com/pccom device, and try that.  this catches more than 90% of failing
isapnp devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.26 1999/08/10 22:00:43 deraadt Exp $	*/
a544 1

d555 3
a557 3
	if (str != NULL)
		printf("%s:", str);
	printf(" <%s, %s, %s, %s>", ipa->ipa_devident,
d560 3
d935 1
a935 1
				printf(" resouce conflict\n");
@


1.26
log
@we only run this insid the kernel now
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.25 1999/03/04 22:14:35 deraadt Exp $	*/
d69 1
d571 28
d886 1
d932 2
a933 5
				printf("%s: <%s, %s, %s, %s> ignored; %s\n",
				    sc->sc_dev.dv_xname,
				    lpa->ipa_devident, lpa->ipa_devlogic,
				    lpa->ipa_devcompat, lpa->ipa_devclass,
				    "resource conflict");
d945 10
a954 2
			if (config_found_sm(self, lpa, isapnp_print,
			    isapnp_submatch) == NULL)
d956 1
@


1.25
log
@simplify cs4232 handling; apollo@@slcnet.net
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.23 1999/01/11 01:57:53 millert Exp $	*/
a67 1
#ifdef _KERNEL
a68 1
#endif
a198 1
#ifdef _KERNEL
a199 1
#endif
a219 1
#ifdef _KERNEL
a220 1
#endif
a568 1
#ifdef _KERNEL
a606 2
#endif

a917 1
#ifdef _KERNEL
a920 4
#else
			isapnp_print(lpa, NULL);
			printf("\n");
#endif
@


1.24
log
@cs4232 hack
@
text
@a50 4
#ifdef CONFIG_CS4232
#include <dev/isa/cs4232.h>
#endif

a815 32
#ifdef CONFIG_CS4232
	/*
	 * XXX XXX
	 * This a totally disgusting hack, but I can't figure out another way.
	 * It seems that many CS audio chips have a bug (as far as I can
	 * understand).  The reset below does not really reset the chip, it
	 * remains in a catatonic state and will not respond when probed.
	 * The chip can be used both as a WSS and as a SB device, and a
	 * single read at the WSS address (0x534) takes it out of this
	 * non-responsive state.
	 * The read has to happen at this point in time (or earlier) so
	 * it cannot be moved to the wss_isapnp.c driver.
	 * (BTW, We're not alone in having problems with these chips: 
	 * Windoze 98 couldn't detect the sound chip on a Dell when I tried.)
	 *
	 *     Lennart Augustsson <augustss@@netbsd.org>
	 *
	 * (Implementation from John Kohl <jtk@@kolvir.arlington.ma.us>)
	 */
	{
		bus_space_handle_t ioh;
		int rv;
	
		if ((rv = bus_space_map(sc.sc_iot, 0x534, 1, 0, &ioh)) == 0) {
			DPRINTF(("wss probe kludge\n"));
			(void)bus_space_read_1(sc.sc_iot, ioh, 0);
			bus_space_unmap(sc.sc_iot, ioh, 1);
		} else {
			DPRINTF(("wss probe kludge failed to map: %d\n", rv));
		}
	}
#endif
a840 3
#ifdef CONFIG_CS4232
	probe_cs4232();
#endif
@


1.23
log
@panic prints a newline for you, don't do it in the panic string
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.22 1998/12/28 09:38:48 deraadt Exp $	*/
d51 4
d820 32
d877 3
@


1.22
log
@carefully clear r->h, and avoid a panic
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.21 1998/11/30 10:44:55 deraadt Exp $	*/
d874 1
a874 1
		panic("%s: bus map failed\n", sc->sc_dev.dv_xname);
@


1.21
log
@clear the isapnp softc
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.20 1998/07/28 15:25:40 csapuntz Exp $	*/
d204 1
d221 1
d876 4
a879 2
	if (!isapnp_find(sc, 1))
		panic("%s: no cards found\n", sc->sc_dev.dv_xname);
@


1.20
log
@

Fix indentation problems.

Remove annoying printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.19 1998/07/28 13:26:50 csapuntz Exp $	*/
d807 1
@


1.19
log
@

Disable ISA PNP devices before ISA scan
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.18 1998/06/02 18:23:33 deraadt Exp $	*/
d797 1
a797 3
 * 
 * Disable this so that ISA scan doesn't detect ISAPNP cards
 *
a811 2

	printf ("isapnp: putting PNP cards to sleep\n");
@


1.18
log
@indent
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.17 1998/01/20 18:40:31 niklas Exp $	*/
d794 30
@


1.17
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.16 1997/12/30 07:00:39 deraadt Exp $	*/
d601 1
a601 1
				printf ("%s: error in region allocation\n",
@


1.16
log
@pretty printing
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.15 1997/12/26 09:35:38 deraadt Exp $	*/
d841 1
d892 1
@


1.15
log
@print pnp device id in isapnp_print
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.14 1997/12/25 12:06:48 downsj Exp $	*/
d560 3
a562 3
		printf("%s: <%s, %s, %s, %s>",
		    str, ipa->ipa_devident, ipa->ipa_devlogic,
		    ipa->ipa_devcompat, ipa->ipa_devclass);
a568 3

	printf(" <%s, %s>", ipa->ipa_devident, ipa->ipa_devclass);

@


1.14
log
@Real DRQ usage tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.13 1997/12/25 09:22:38 downsj Exp $	*/
d569 2
@


1.13
log
@New ISA/ISA PnP configuration infrastructure:

isa_attach_args and isapnp_attach_args have been merged.
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.12 1997/12/21 14:41:24 downsj Exp $	*/
d273 1
a273 1
		if ((i->bits & (1 << b)) && isadma_isdrqfree(b)) {
@


1.12
log
@Obliterate old PnP `code' and outright replace with christos' code.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d44 2
a48 3
#include <dev/isa/isapnpreg.h>
#include <dev/isa/isapnpvar.h>

d59 3
a61 3
    struct isapnp_attach_args *, int));
struct isapnp_attach_args *isapnp_bestconfig __P((struct device *, 
    struct isapnp_softc *, struct isapnp_attach_args **));
d65 1
a65 1
    const struct isapnp_attach_args *));
d75 6
d198 3
d217 3
d287 1
a287 1
	struct isapnp_attach_args *ipa;
d316 1
a316 1
		error = isapnp_alloc_irq(ipa->ipa_ic, &ipa->ipa_irq[nirq]);
d322 1
a322 1
		error = isapnp_alloc_drq(ipa->ipa_isa, &ipa->ipa_drq[ndrq]);
d358 1
a358 1
	struct isapnp_attach_args *ipa;
d370 1
a370 1
	struct isapnp_attach_args *ipa;
d397 1
a397 1
struct isapnp_attach_args *
d401 1
a401 1
	struct isapnp_attach_args **ipa;
d403 1
a403 1
	struct isapnp_attach_args *c, *best, *f = *ipa;
d420 1
a420 1
		best->ipa_isa = isa;
d450 1
a450 1
			struct isapnp_attach_args *l = NULL, *n = NULL, *d;
d557 1
a557 1
	struct isapnp_attach_args *ipa = aux;
d584 1
a584 1
	struct isapnp_attach_args *ipa = aux;
d601 1
a601 1
			if (isapnp_config(ipa->ipa_iot, ipa->ipa_memt, ipa)) {
d665 1
a665 1
	const struct isapnp_attach_args *ipa;
d678 2
a679 2
	memset(&pz, 0, sizeof(pz));
	memset(&rz, 0, sizeof(rz));
d853 1
a853 1
		struct isapnp_attach_args *ipa, *lpa;
d868 1
a868 1
				struct isapnp_attach_args pa;
d889 4
a892 4
			lpa->ipa_ic = ia->ia_ic;
			lpa->ipa_iot = ia->ia_iot;
			lpa->ipa_memt = ia->ia_memt;
			lpa->ipa_delaybah = ia->ia_delaybah;
@


1.11
log
@Get rid of pause
@
text
@d1 2
a2 1
/*	$OpenBSD: isapnp.c,v 1.10 1997/07/12 23:22:01 weingart Exp $	*/
d5 1
a5 2
 * Copyright (c) 1996, Shawn Hsiao <shawn@@alpha.secc.fju.edu.tw>
 * All rights reserved.
d15 5
d21 10
a30 11
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d34 1
a34 27
 * Note: Most of the basic code was originally written by Sujal M. Patel,
 *       plus some code takes from his pnpinfo(8).
 */
/*
 * Copyright (c) 1996, Sujal M. Patel
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
d41 1
a41 2
#include <sys/queue.h>
#include <sys/extent.h>
d45 1
d49 1
d52 27
a78 2
#define SEND(d, r)	{ bus_space_write_1(sc->iot, sc->addrh, 0, d); \
                          bus_space_write_1(sc->iot, sc->wdh,   0, r); }
d80 2
a81 8
int isapnpmatch __P((struct device *, void *, void *));
void isapnpattach __P((struct device *, struct device *, void *));
int isapnpprint __P((void *aux, const char *pnp));
int isapnpsubmatch __P((struct device *parent, void *match, void *aux));

/* XXX */
struct emap {
	int whatever;
a83 3
void add_extent __P((struct emap *, long, int));
struct emap *find_emap __P((char *));
int probe_extent __P((struct emap *, int, int));
d85 13
a97 3
struct isapnp_softc {
	struct device sc_dev;
	struct device *parent;
d99 6
a104 4
	bus_space_tag_t iot;
	bus_space_handle_t addrh;
	bus_space_handle_t wdh;
	bus_space_handle_t rdh;
a105 1
	int rd_port;
d107 8
a114 2
	TAILQ_HEAD(, cardinfo) q_card;
};
d116 4
a119 3
struct cfattach isapnp_ca = {
	sizeof(struct isapnp_softc), isapnpmatch, isapnpattach
};
d121 5
a125 3
struct cfdriver isapnp_cd = {
	NULL, "isapnp", DV_DULL, 1
};
a126 18
int isapnpquery __P((struct isapnp_softc *, u_int32_t,
	struct isa_attach_args *));
void send_Initiation_LFSR __P((struct isapnp_softc *));
int get_serial __P((struct isapnp_softc *, unsigned char *));
int isolation_protocol __P((struct isapnp_softc *));
void read_config __P((struct isapnp_softc *, struct cardinfo *, int));
int get_resource_info __P((struct isapnp_softc *, u_char *, int));
void config_device __P((struct isapnp_softc *, struct isa_attach_args *));
int find_free_irq __P((int));
int find_free_drq __P((int));
int find_free_io  __P((struct isapnp_softc *, int, int, int, int,
	int, int));
void postisapnpattach __P((struct device *, struct device *, void *));
char *searchpnpdevtab __P((char *));
char *makepnpname __P((u_int32_t));
void isapnpextent __P((struct isa_attach_args *));
int handle_small_res __P((unsigned char *, int, int, struct cardinfo *));
void handle_large_res __P((unsigned char *, int, int, struct cardinfo *));
d128 5
d134 2
a135 3
isapnpmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d137 13
a149 1
	struct isa_attach_args *ia = aux;
d151 2
a152 4
	/* sure we exist */
	ia->ia_iosize = 0;
	return(1);
}
d154 5
a158 9
void
isapnpattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isa_softc *isc = (void *)parent;
	struct isapnp_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	int num_pnp_devs;
d160 3
a162 38
	/*
	 * a reference to corresponding isapnp_softc
	 */
	isc->pnpsc = sc;

	sc->iot = ia->ia_iot;
	sc->parent = parent;
	TAILQ_INIT(&sc->q_card);

	/* The bus_space_*() stuff needs to be done differently.
	 * With PNP you want to be able to allocate a region,
	 * but not necessarily map it.  Why?  The drivers themselves
	 * should really map the bus regions they need.  So, which
	 * way should this be done?
	 *
	 * Me thinks to seperate the resource allocation and mapping
	 * of said resources.
	 */

	/* ADDRESS and WRITE_DATA ports are static */
	if (bus_space_map(sc->iot, ADDRESS, 1, 0, &(sc->addrh)))
		panic("isapnpattach: io mapping for ADDRESS port failed");
	if (bus_space_map(sc->iot, WRITE_DATA, 1, 0, &(sc->wdh)))
		panic("isapnpattach: io mapping for WRITE_DATA port failed");

	/* Try various READ_DATA ports from 0x203-0x3ff
	 * We try in increments of 16.  Note that the rd_port
	 * figure is really port number ((rd_port << 2) | 0x3).
	 */
	for (sc->rd_port = 0x80; (sc->rd_port < 0xff); sc->rd_port += 0x10) {
		int real_port = (sc->rd_port << 2) | 0x3;

		/* Try to map a READ_DATA port */
		if (bus_space_map(sc->iot, real_port, 1, 0, &(sc->rdh))) {
#ifdef DEBUG
			printf("\nisapnpattach:  READ_PORT 0x%x failed", real_port);
#endif
			continue;
d164 2
d167 6
a172 7
		/* Try isolation protocol on this port */
		num_pnp_devs = isolation_protocol(sc);
		if (num_pnp_devs)
			break;
		
		/* isolation protocol failed for this port */
		bus_space_unmap(sc->iot, real_port, 1);
d174 1
a174 3
	printf(": readport 0x%x, %d devices\n",
	    (sc->rd_port << 2) | 0x3, num_pnp_devs);
}
d176 6
a181 10
char *
searchpnpdevtab(name)
	char *name;
{
	int i;

	for (i = 0; pnp_knowndevs[i].pnpid; i++)
		if (strcmp(pnp_knowndevs[i].pnpid, name) == 0)
			return (pnp_knowndevs[i].driver);
	return (NULL);
a183 15
char *
makepnpname(id)
	u_int32_t id;
{
	static char name[8];
	u_char info[4];
	
	bcopy(&id, info, sizeof id);
	sprintf(name, "%c%c%c%02x%02x",
	    ((info[0] & 0x7c) >> 2) + 64,
	    (((info[0] & 0x03) << 3) | ((info[1] & 0xe0) >> 5)) + 64,
	    (info[1] & 0x1f) + 64,
	    info[2], info[3]);
	return (name);
}
d185 3
d189 3
a191 3
postisapnpattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d193 2
a194 8
	struct isa_softc *isc = (struct isa_softc *)self;
	struct isapnp_softc *sc = (struct isapnp_softc *)isc->pnpsc;
	struct isabus_attach_args *iba = aux;
	struct cardinfo *card;
	struct devinfo *dev;
	struct device *r;
#if 0
	extern char *msgs[];
d196 1
a196 1
	void *match;
a197 29
	printf("postisapnpattach:\n");
	for (card = sc->q_card.tqh_first; card; card = card->card_link.tqe_next) {
		for (dev = card->q_dev.tqh_first; dev; dev = dev->dev_link.tqe_next) {
			struct isa_attach_args ia;

			bzero(&ia, sizeof(ia));
			ia.ia_iot = iba->iba_iot;
			ia.ia_ic = iba->iba_ic;
			ia.id = dev->id;
			ia.comp_id = dev->comp_id;
			ia.csn = card->csn;
			ia.ldn = dev->ldn;

			if (!isapnpquery(sc, ia.id, &ia)) {
				printf("isapnpquery failed\n");
				goto bail;
			}
			printf("id %x comp_id %x csn %x ldn %x\n", ia.id,
			    ia.comp_id, ia.csn, ia.ldn);
			printf("io %x/%x mem %x/%x irq %x drq %x\n",
				ia.ia_iobase, ia.ia_iosize, ia.ia_maddr,
				ia.ia_msize, ia.ia_irq, ia.ia_drq);
			match = config_search(isapnpsubmatch, self, &ia);
			printf("config search %x\n", match);

			if (match) {
				r = config_attach(self, match, &ia, NULL);
				printf("config attach %x\n", r);
			}
d199 14
a212 4
			if (match == NULL || r == NULL) {
bail:
#if 0
				printf(msgs[isapnpprint(&ia, self->dv_xname)]);
d214 2
a215 15
#if 1
				/*
				 * XXX does this shut down devices we
				 * are using??
				 * supplied configuration fails,
				 * disable the device.
				 */
				SEND(WAKE, ia.csn);
				SEND(SET_LDN, ia.ldn);
				SEND(ACTIVATE, 0);
#endif
			}
		}

		delay(1000*500);
d217 1
d220 4
d225 3
a227 3
isapnpprint(aux, pnp)
	void *aux;
	const char *pnp;
d229 3
a231 1
	register struct isa_attach_args *ia = aux;
d233 3
a235 18
	if (pnp) {
		printf("device ");
		if (ia->comp_id)
			printf("<%s> ", makepnpname(ia->comp_id));
		printf("<%s> at %s", makepnpname(ia->id), pnp);
	} else {
		if (ia->ia_iosize)
			printf(" port 0x%x", ia->ia_iobase);
		if (ia->ia_iosize > 1)
			printf("-0x%x", ia->ia_iobase + ia->ia_iosize - 1);
		if (ia->ia_msize)
			printf(" iomem 0x%x", ia->ia_maddr);
		if (ia->ia_msize > 1)
			printf("-0x%x", ia->ia_maddr + ia->ia_msize - 1);
		if (ia->ia_irq != IRQUNK)
			printf(" irq %d", ia->ia_irq);
		if (ia->ia_drq != DRQUNK)
			printf(" drq %d", ia->ia_drq);
d237 7
a243 1
	return(UNCONF);
d246 3
a248 2
/* XXX */
/* Always return success */
d250 3
a252 3
probe_extent(ext, s, l)
	struct emap *ext;
	int s, l;
d254 12
a265 2
	return(0);
}
d267 1
a267 7
/* XXX */
/* Return bogus map */
struct emap *
find_emap(key)
	char *key;
{
	return(NULL);
d270 8
a277 7
/* XXX */
/* Do nothing at all */
void
add_extent(m, base, size)
	struct emap *m;
	long base;
	int size;
d279 2
a280 1
}
d282 3
a284 5
void
isapnpextent(ia)
	struct isa_attach_args *ia;
{
	struct emap *io_map, *mem_map, *irq_map, *drq_map;
d286 5
a290 14
	io_map = find_emap("io");
	mem_map = find_emap("mem");
	irq_map = find_emap("irq");
	drq_map = find_emap("drq");

	if (ia->ia_iosize > 0)
		add_extent(io_map, ia->ia_iobase, ia->ia_iosize);
	if (ia->ia_msize > 0)
		add_extent(mem_map, ia->ia_maddr, ia->ia_msize);
	if (ia->ia_irq != IRQUNK)
		add_extent(irq_map, ia->ia_irq, 1);
	if (ia->ia_drq != DRQUNK)
		add_extent(drq_map, ia->ia_drq, 1);
}
d292 5
a296 10
int
isapnpsubmatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct device *dev = match;
	struct cfdata *cf = dev->dv_cfdata;
	struct isa_attach_args *ia = aux;
	char *name, *dname;
	int ret = 0;
d298 4
a301 6
	/* XXX should check for id/comp_id being 0 */
	if (cf->cf_pnpid != 0 &&
	    (ia->id == cf->cf_pnpid || ia->comp_id == cf->cf_pnpid)) {
		printf("isapnpsubmatch going\n");
		ret = (*cf->cf_attach->ca_match)(parent, match, aux);
		goto done;
d304 4
a307 7
	if (ia->comp_id) {
		name = makepnpname(ia->comp_id);
		dname = searchpnpdevtab(name);
		if (dname && strcmp(dname, cf->cf_driver->cd_name) == 0) {
			ret = (*cf->cf_attach->ca_match)(parent, match, aux);
			goto done;
		}
a308 11
	name = makepnpname(ia->id);
	dname = searchpnpdevtab(name);
	if (dname && strcmp(dname, cf->cf_driver->cd_name) == 0) {
		printf("match %s\n", dname);
		ret = (*cf->cf_attach->ca_match)(parent, match, aux);
	}
done:
	if (ret)
		isapnpextent(ia);
	return (ret);
}
d310 4
a313 21
/*
 * given the logical device ID, return 1 if found and configured.
 */
int
isapnpquery(sc, dev_id, ipa)
	struct isapnp_softc *sc;
	u_int32_t dev_id;
	struct isa_attach_args *ipa;
{
	struct cardinfo *card;
	struct devinfo *dev;
	struct confinfo *conf;
	struct isa_attach_args *tmp;
	int c, i, j, fail, success = 0;

/* XXX - Wait for character */
#if 0
	{
		char resp[10];
		printf("isapnpquery? ");
		getsn(resp, sizeof resp);
a314 92
#endif
	for (card = sc->q_card.tqh_first; card; card = card->card_link.tqe_next) {
		for (dev = card->q_dev.tqh_first; dev; dev = dev->dev_link.tqe_next) {
			if (dev_id != dev->id && dev_id != dev->comp_id)
				continue;
			tmp = malloc(sizeof(*tmp), M_DEVBUF, M_WAITOK);
			bzero(tmp, sizeof(*tmp));
			SEND(WAKE, card->csn);
			SEND(SET_LDN, dev->ldn);

			/* Find a usable and acceptable configuration */
			for (conf = dev->q_conf.tqh_first; conf;
			    conf = conf->conf_link.tqe_next) {
				/*
				 *  BASIC CONFIGURATION
				 */
				if (conf->prio == BASIC_CONFIGURATION) {
					for (c=0; c < 2; c++) {
						ipa->irq[c].num = -1;
						if (conf->irq[c] == 0)
							continue;
#if 0
						printf("irq %d %d %d\n", c,
						    conf->irq[c]->num,
						    conf->irq[c]->info);
#endif
						i = conf->irq[c]->num;
						if (i == 0)
							continue;
						j = find_free_irq(i);
						if (j != 0)
							continue;
						ipa->irq[c].num = j;

						/*
						 * XXX if the interrupt cannot
						 * be configured as low true
						 * level-triggered then set it
						 * to high true edge-triggered.
						 */
						if (conf->irq[c]->info & 0x08)
							ipa->irq[c].type = 0x01;
						else
							ipa->irq[c].type = 0x10;
					}
					for (c=0; c < 2; c++) {
						ipa->drq[c] = -1;
						if (conf->dma[c] == 0)
							continue;
#if 0
						printf("dma %d %d\n", c,
						    conf->dma[c]->channel);
#endif
						i = conf->dma[c]->channel;
						if (i == 0)
							continue;
						j = find_free_drq(i);
						if (j)
							ipa->drq[c] = j;
					}
					for (c=0; c < 8; c++) {
						if (conf->io[c] == 0)
							continue;
#if 0
						printf("io %d %d %d %d %d %d\n",
						    c, conf->io[c]->min_base,
						    conf->io[c]->max_base,
						    conf->io[c]->size,
						    conf->io[c]->alignment,
						    dev->io_range_check);
#endif
						ipa->port[c] = find_free_io(sc,
						    c, conf->io[c]->min_base,
						    conf->io[c]->max_base,
						    conf->io[c]->size,
						    conf->io[c]->alignment,
						    dev->io_range_check);
					}
					for (c=0; c < 4; c++) {
						if (conf->mem[c] == 0)
							continue;
#if 0
						printf("mem %d %d %d\n", c,
						    conf->mem[c]->min_base,
						    conf->mem[c]->size);
#endif
						ipa->mem[c].base =
						    conf->mem[c]->min_base;
						ipa->mem[c].range =
						    conf->mem[c]->size;
					}
				}
d316 10
a325 21
				/*
				 *  DEPENDENT FUNCTION
				 */
				fail = 0;
				success = 1;
				for (c=0; conf->irq[c] && c < 2; c++) {
					i = conf->irq[c]->num;
					tmp->irq[c].num = -1;
					if (i == 0)
						continue;
					j = find_free_irq(i);
					if (j) {
						tmp->irq[c].num = j;
						if (conf->irq[c]->info & 0x08)
							tmp->irq[c].type = 0x01;
						else
							tmp->irq[c].type = 0x10;
					} else {
						fail = 1;
#if 0
						printf("irq bail\n");
a326 21
						success = 0;
						break;
					}
				}
				for (c=0; conf->dma[c] && c < 2; c++) {
					i = conf->dma[c]->channel;
					tmp->drq[c] = -1;
					if (i == 0)
						continue;
					j = find_free_drq(i);
					if (j)
						tmp->drq[c] = j;
					else {
						fail = 1;
#if 0
						printf("dma bail\n");
#endif
						success = 0;
						break;
					}
				}
d328 2
a329 27
#if 0
				printf("ports:");
#endif
				for (c=0; conf->io[c] && c < 8; c++) {
#if 0
					printf("%x/%x ", conf->io[c]->min_base,
					    conf->io[c]->size);
#endif
					if (conf->io[c]->size == 0)
						continue;
					tmp->port[c] = find_free_io(sc, c,
					    conf->io[c]->min_base,
					    conf->io[c]->max_base,
					    conf->io[c]->size,
					    conf->io[c]->alignment,
					    dev->io_range_check);
					if (tmp->port[c] == NULL) {
						fail = 1;
#if 0
						printf("io bail\n");
#endif
						success = 0;
						break;
					}
				}
#if 0
				printf("\n");
d331 2
a332 29
				printf("mem:");
#endif
				for (c=0; conf->mem[c] && c < 4; c++) {
#if 0
					printf("%x/%x ", conf->mem[c]->min_base,
					    conf->mem[c]->size);
#endif
					if (conf->mem[c]->size == 0)
						continue;
					tmp->mem[c].base =
					    conf->mem[c]->min_base;
					tmp->mem[c].range =
					    conf->mem[c]->size;
					if (tmp->mem[c].base == NULL) {
						fail = 1;
#if 0
						printf("mem bail\n");
#endif
						success = 0;
						break;
					}
				}
#if 0
				printf("\n");
#endif
		
				if (fail) {
					continue;
				}
d334 2
a335 8
				if (!success) {
					free(tmp, M_DEVBUF);
#if 0
					printf("bailing\n");
#endif
					return(0);
				}
			}
d337 2
a339 15
			/* Copy usable configuration */
			for (c = 0; c < 2; c++) {
				if (tmp->irq[c].num) {
					  ipa->irq[c].num = tmp->irq[c].num;
					  ipa->irq[c].type = tmp->irq[c].type;
				}
			}
			for (c = 0; c < 8; c++) {
				if (tmp->port[c])
					ipa->port[c] = tmp->port[c];
			}
			for (c = 0; c < 4; c++) {
				if (tmp->mem[c].base)
					ipa->mem[c].base = tmp->mem[c].base;
			}
d341 9
a349 11
			/* Configure device */
			config_device(sc, ipa);
			ipa->ia_iobase = ipa->port[0];
			ipa->ia_iosize = 16;		/* XXX */
			ipa->ia_irq = ipa->irq[0].num;
			ipa->ia_drq = ipa->drq[0];
			free(tmp, M_DEVBUF);
			return(1);
		}
	}
	return(0);
d352 3
a354 3
/*
 * Send Initiation LFSR as described in "Plug and Play ISA Specification,
 * Intel May 94."
d357 3
a359 2
send_Initiation_LFSR(sc)
	struct isapnp_softc *sc;
d361 18
a378 15
	bus_space_tag_t iot = sc->iot;
	bus_space_handle_t addrh = sc->addrh;
	int cur, i;

	/* Reset the LSFR */
	bus_space_write_1(iot, addrh, 0, 0);
	bus_space_write_1(iot, addrh, 0, 0);

	cur = 0x6a;
	bus_space_write_1(iot, addrh, 0, cur);

	for (i = 1; i < 32; i++) {
		cur = (cur >> 1) | (((cur ^ (cur >> 1)) << 7) & 0xff);
		bus_space_write_1(iot, addrh, 0, cur);
	}
d381 4
a384 2
/*
 * Get the device's serial number.  Returns 1 if the serial is valid.
d386 3
a388 2
int
get_serial(sc, data)
d390 1
a390 1
	unsigned char *data;
d392 2
a393 2
	bus_space_tag_t iot = sc->iot;
	bus_space_handle_t rdh = sc->rdh;
d395 3
a397 1
	int i, bit, valid = 0, sum = 0x6a;
d399 1
a399 1
	bzero(data, sizeof(char) * 9);
d401 7
d409 12
a420 3
	for (i = 0; i < 72; i++) {
		bit = bus_space_read_1(iot, rdh, 0) == 0x55;
		delay(250);	/* Delay 250 usec */
d422 2
a423 3
		/* Can't Short Circuit the next evaluation, so 'and' is last */
		bit = (bus_space_read_1(iot, rdh, 0) == 0xaa) && bit;
		delay(250);	/* Delay 250 usec */
d425 8
a432 1
		valid = valid || bit;
d434 6
a439 3
		if (i < 64)
			sum = (sum >> 1) |
				(((sum ^ (sum >> 1) ^ bit) << 7) & 0xff);
d441 21
a461 1
		data[i / 8] = (data[i / 8] >> 1) | (bit ? 0x80 : 0);
d463 2
d466 19
a484 1
	valid = valid && (data[8] == sum);
d486 1
a486 1
	return valid;
d489 9
a497 5
int
get_resource_info(sc, buffer, len)
	struct isapnp_softc *sc;
	u_char *buffer;
	int len;
d499 1
a499 1
	int i, j;
d501 2
a502 17
#if 0
	printf("gri: ");
#endif
	for (i = 0; i < len; i++) {
		bus_space_write_1(sc->iot, sc->addrh, 0, STATUS);
		for (j = 0; j < 100; j++) {
			if ((bus_space_read_1(sc->iot, sc->rdh, 0)) & 0x1)
				break;
			delay(1);
		}
		if (j == 100) {
			printf("isapnp: %s failed to report resource data\n",
			       sc->sc_dev.dv_xname);
			return 0;
		}
		bus_space_write_1(sc->iot, sc->addrh, 0, RESOURCE_DATA);
		buffer[i] = bus_space_read_1(sc->iot, sc->rdh, 0);
d504 7
a510 3
#if 0
		printf("%2x ", buffer[i]);
#endif
a511 4
#if 0
	printf("\n");
#endif
	return 1;
d514 3
a516 8
/*
 *  Small Resource Tag Handler
 *
 *  Returns 1 if checksum was valid (and an END_TAG was received).
 *  Returns -1 if checksum was invalid (and an END_TAG was received).
 *  Returns 0 for other tags.
 *
 *  XXX checksum is ignored now ...
d518 5
a522 5
int
handle_small_res(resinfo, item, len, card)
	unsigned char *resinfo;
	int item, len;
	struct cardinfo *card;
d524 4
a527 1
	int i;
d529 5
a533 121
	switch (item) {
	case PNP_VERSION:
		bcopy(resinfo, card->pnp_version, 2);
		break;
	case LOG_DEVICE_ID:
		card->dev = malloc(sizeof(struct devinfo), M_DEVBUF, M_WAITOK);
		bzero(card->dev, sizeof(struct devinfo));
		TAILQ_INSERT_TAIL(&card->q_dev, card->dev, dev_link);
		card->dev->id = *(u_int32_t *)resinfo;
		card->dev->ldn = card->num_ld;
		card->dev->io_range_check = resinfo[4] & 0x2 ? 1 : 0;
		TAILQ_INIT(&card->dev->q_conf);

		/*
		 * if the resource data is not enclosed in a START_DEPEND_FUNC and
		 * a END_DEPEND_FUNC, it's the basic configuration.
		 *
		 * we simply treat it as a special case.
		 */
		card->dev->basic = malloc(sizeof(struct confinfo), M_DEVBUF, M_WAITOK);
		TAILQ_INSERT_TAIL(&card->dev->q_conf, card->dev->basic, conf_link);
		card->dev->basic->prio = BASIC_CONFIGURATION;
		bzero(card->dev->basic->irq, 2*sizeof(void *));
		bzero(card->dev->basic->dma, 2*sizeof(void *));
		bzero(card->dev->basic->io, 8*sizeof(void *));
		bzero(card->dev->basic->mem, 4*sizeof(void *));
		card->dev->conf = card->dev->basic;

		card->num_ld++;
		break;
	case COMP_DEVICE_ID:
		card->dev->comp_id = *(u_int32_t *)resinfo;
		break;
	case IRQ_FORMAT:
		for (i = 0; card->dev->conf->irq[i]; i++)
			;
		card->dev->conf->irq[i] = malloc(sizeof(struct irq_format),
		    M_DEVBUF, M_WAITOK);
		card->dev->conf->irq[i]->num = resinfo[0] | (resinfo[1] << 8);
		if (len == 3)
			card->dev->conf->irq[i]->info = resinfo[2];
		else
			card->dev->conf->irq[i]->info = 0;
		break;
	case DMA_FORMAT:
		for (i = 0; card->dev->conf->dma[i]; i++)
			;
		card->dev->conf->dma[i] = malloc(sizeof(struct dma_format),
		    M_DEVBUF, M_WAITOK);
		card->dev->conf->dma[i]->channel = resinfo[0];
		card->dev->conf->dma[i]->info = resinfo[1];
		break;
	case START_DEPEND_FUNC:
		card->dev->conf = malloc(sizeof(struct confinfo),
		    M_DEVBUF, M_WAITOK);
		TAILQ_INSERT_TAIL(&card->dev->q_conf, card->dev->conf,
		    conf_link);
		card->dev->conf->prio = ACCEPTABLE_CONFIGURATION;
		bzero(card->dev->conf->irq, 2*sizeof(void *));
		bzero(card->dev->conf->dma, 2*sizeof(void *));
		bzero(card->dev->conf->io, 8*sizeof(void *));
		bzero(card->dev->conf->mem, 4*sizeof(void *));

		if (len == 1) {
			switch (resinfo[0]) {
			case GOOD_CONFIGURATION:
				card->dev->conf->prio =
				    GOOD_CONFIGURATION;
				break;
			case ACCEPTABLE_CONFIGURATION:
				card->dev->conf->prio =
				    ACCEPTABLE_CONFIGURATION;
				break;
			case SUBOPTIMAL_CONFIGURATION:
				card->dev->conf->prio =
				    SUBOPTIMAL_CONFIGURATION;
				break;
			default:
				card->dev->conf->prio =
				    RESERVED_CONFIGURATION;
				break;
			}
		}
		break;
	case END_DEPEND_FUNC:
		break;
	case IO_PORT_DESC:
		for (i = 0; card->dev->conf->io[i]; i++)
			;
		card->dev->conf->io[i] = malloc(sizeof(struct io_descriptor),
		    M_DEVBUF, M_WAITOK);
		card->dev->conf->io[i]->type = 0; /* 0 for normal I/O desc. */
		card->dev->conf->io[i]->info = resinfo[0];
		card->dev->conf->io[i]->min_base =
		    resinfo[1] | (resinfo[2] << 8);
		card->dev->conf->io[i]->max_base =
		    resinfo[3] | (resinfo[4] << 8);
		card->dev->conf->io[i]->alignment = resinfo[5];
		card->dev->conf->io[i]->size = resinfo[6];
		break;
	case FIXED_IO_PORT_DESC:
		for (i = 0; card->dev->conf->io[i]; i++) ;
		card->dev->conf->io[i] = malloc(sizeof(struct io_descriptor),
		    M_DEVBUF, M_WAITOK);
		card->dev->conf->io[i]->type = 1; /* 1 for fixed I/O desc. */
		card->dev->conf->io[i]->info = 0;
		card->dev->conf->io[i]->min_base =
		    resinfo[0] | (resinfo[1] & 0x3) << 8;
		card->dev->conf->io[i]->max_base =
		    card->dev->conf->io[i]->min_base;
		card->dev->conf->io[i]->alignment = 0;
		card->dev->conf->io[i]->size = resinfo[2];
		break;
	case END_TAG:
		/*
		 * XXX checksum is ignored
		 */
#if 0
		printf("end of res\n");
#endif
		return(1);
d535 1
a536 2
	return(0);
}
d538 7
a544 5
void
handle_large_res(resinfo, item, len, card)
	unsigned char *resinfo;
	int item, len;
	struct cardinfo *card;
d546 12
a557 1
	int i;
d559 1
a559 53
	switch (item) {
	case MEMORY_RANGE_DESC:
		for (i = 0; card->dev->conf->mem[i]; i++)
			;
		card->dev->conf->mem[i] = malloc(sizeof(struct mem_descriptor),
		    M_DEVBUF, M_WAITOK);
		card->dev->conf->mem[i]->type = 0; /* 0 for 24bit mem desc. */
		card->dev->conf->mem[i]->info = resinfo[0];
		card->dev->conf->mem[i]->min_base =
		    (resinfo[1] | (resinfo[2] << 8)) << 8;
		card->dev->conf->mem[i]->max_base =
		    (resinfo[3] | (resinfo[4] << 8)) << 8;
		card->dev->conf->mem[i]->alignment =
		    resinfo[5] | (resinfo[6] << 8);
		if (!card->dev->conf->mem[i]->alignment)
		    card->dev->conf->mem[i]->alignment = 1 << 16;
		card->dev->conf->mem[i]->size =
		    (resinfo[7] | (resinfo[8] << 8)) << 8;
		break;
	case ID_STRING_ANSI:
		if (card->dev) {
			card->dev->id_string = (char *)malloc(len+1, M_DEVBUF,
			    M_WAITOK);
			strncpy(card->dev->id_string, resinfo, len+1);
			card->dev->id_string[len] = '\0';
#if 0
			printf("ID_STRING_ANSI: %s\n", card->dev->id_string);
#endif
		} else {
			card->id_string = (char *)malloc(len+1, M_DEVBUF,
			    M_WAITOK);
			strncpy(card->id_string, resinfo, len+1);
			card->id_string[len] = '\0';
#if 0
			printf("ID_STRING_ANSI: %s\n", card->id_string);
#endif
		}
		break;
	case ID_STRING_UNICODE:
		break;
	case LG_VENDOR_DEFINED:
		break;
	case _32BIT_MEM_RANGE_DESC:
		break;
	case _32BIT_FIXED_LOC_DESC:
		break;

	/* XXX - Check how this is defined!  Bogus!!! */
	case LG_RES_RESERVED:
		break;
	default:
		break;
	}
d562 9
a570 5
void
read_config(sc, card, csn)
	struct isapnp_softc *sc;
	struct cardinfo *card;
	int csn;
d572 3
a574 2
	u_char tag, *resinfo;
	u_short large_len;
d577 2
a578 6
#if 0
	/*
	 * set card with csn to Config state
	 */
	SEND(SET_CSN, csn);
#endif
d580 4
a583 24
	/*
	 * since we are in the card isolation process, so theres no reason
	 * to rewind and skip the first 9 bytes
	 */

	/* allow up to 1KB of resource info, should be plenty */
	for (i = 0; i < 4096; i++) {
		if (!get_resource_info(sc, &tag, 1))
			return;

#define TYPE   (tag >> 7)
#define S_ITEM (tag >> 3)
#define S_LEN  (tag & 0x7)
#define L_ITEM (tag & 0x7f)

		if (TYPE == 0) {
#if 0
			printf("small %d %d\n", S_ITEM, S_LEN);
#endif
			resinfo = malloc(S_LEN, M_TEMP, M_WAITOK);
			if (!get_resource_info(sc, resinfo, S_LEN)) {
				printf("bail getting small info\n");
				return;
			}
d585 9
a593 14
			if (handle_small_res(resinfo, S_ITEM, S_LEN, card) == 1)
				return;
			free(resinfo, M_TEMP);
		} else {
			large_len = 0;
			if (!get_resource_info(sc, (char *)&large_len, 2)) {
				printf("bail getting large info\n");
				return;
			}
			resinfo = malloc(large_len, M_TEMP, M_WAITOK);
			if (!get_resource_info(sc, resinfo, large_len)) {
				printf("bail sadf info\n");
				free(resinfo, M_TEMP);
				return;
d596 1
a596 5
#if 0
			printf("large %d %d\n", L_ITEM, large_len);
#endif
			handle_large_res(resinfo, L_ITEM, large_len, card);
			free(resinfo, M_TEMP);
d599 2
d602 1
d604 3
a606 4
/*
 * Run the isolaion protocol. Use rd_port as the READ_DATA port value (caller
 * should try multiple READ_DATA locations before giving up). Upon exiting,
 * all cards are aware that they should use rd_port as the READ_DATA port;
d609 1
a609 1
isolation_protocol(sc)
d611 1
d613 1
a613 2
	int csn;
	unsigned char data[9];
d615 14
a628 41
	/* Reset CSN for All Cards */
	/* Well, all cards who are *NOT* in Wait for Key state:
	 *
	 * 0x01 - Reset command.  (READ_PORT, CSN, PNP state preserved)
	 * 0x02 - Wait for Key.  (Everything preserved)
	 * 0x04 - Reset CSN.  (Nuke CSN goto wait for key state)
	 *
	 * Use 0x08 for the equivelant to RESET_DRV.
	 */
	SEND(CONFIG_CONTROL, 0x05);

	/* Move all PNP cards from WFK state to sleep state */
	send_Initiation_LFSR(sc);

	/* We should do the following until we do not
	 * find anymore PNP cards, with the max being
	 * 255 cards.  This is faster
	 */
	for (csn = 1; (csn < MAX_CARDS); csn++) {
		/* Wake up cards without a CSN */
		SEND(WAKE, 0);
		SEND(SET_RD_DATA, sc->rd_port);
		bus_space_write_1(sc->iot, sc->addrh, 0, SERIAL_ISOLATION);
		delay(1000);	/* Delay 1 msec */

		if (get_serial(sc, data)) {
			struct cardinfo *card;

			/* Move card into config state */
			SEND(SET_CSN, csn);
			card = malloc(sizeof(struct cardinfo), M_DEVBUF, M_WAITOK);
			bzero(card, sizeof(struct cardinfo));
			TAILQ_INSERT_TAIL(&sc->q_card, card, card_link);
			bcopy(data, card->serial, 9);
			card->csn = csn;
			TAILQ_INIT(&card->q_dev);
			/*
			 * read card's resource data
			 */
			read_config(sc, card, csn);
		} else
d630 6
d637 6
a642 1
	return csn - 1;
d645 5
a649 2
/*
 * Configure PNP devices, given a set of configuration data
d652 1
a652 1
config_device(sc, data)
d654 1
a654 1
	struct isa_attach_args *data;
d657 23
d681 23
a703 2
	if (data->csn <= 0) {
		return;
d706 10
a715 5
#if 1
	printf ("%s: configuring CSN %x (LDN %x)\n",
		sc->sc_dev.dv_xname, data->csn,
		data->ldn != -1 ? data->ldn : 0);
#endif
d717 4
a720 13
	/* Wake up card, set LDN */
	SEND(WAKE, data->csn);
	if (data->ldn > 0)
		SEND (SET_LDN, data->ldn);

	/* Config IO */
	for (i = 0; i < 8; i++)
		if (data->port[i] > 0) {
			SEND (IO_CONFIG_BASE + i * 2,
			      data->port[i] >> 8);
			SEND (IO_CONFIG_BASE + i * 2 + 1,
			      data->port[i] & 0xff);
		}
d722 3
a724 7
	/* Config IRQ */
	for (i = 0; i < 2; i++)
		if (data->irq[i].num > 0) {
			SEND (IRQ_CONFIG + i * 2, data->irq[i].num);
			if (data->irq[i].type >= 0)
				SEND (IRQ_CONFIG + i * 2 + 1, data->irq[i].type);
		}
d726 3
a728 5
	/* Config DRQ */
	for (i = 0; i < 2; i++)
		if (data->drq[i] > 0) {
			SEND (DRQ_CONFIG + i, data->drq[i]);
		}
d730 4
a733 21
	/* Config MEM */
	for (i = 0; i < 4; i++)
		if (data->mem[i].base > 0) {
			SEND (MEM_CONFIG + i * 8,
			      data->mem[i].base >> 16);
			SEND (MEM_CONFIG + i * 8 + 1,
			      (data->mem[i].base >> 8) &
			      0xff);
			/*
			 * This needs to be handled better for
			 * the user's sake. XXX
			 */
			if (data->mem[i].control >= 0) {
				SEND (MEM_CONFIG + i * 8 + 2,
				      data->mem[i].control);
			}
			SEND (MEM_CONFIG + i * 8 + 3,
			      data->mem[i].range >> 16);
			SEND (MEM_CONFIG + i * 8 + 4,
			      (data->mem[i].range >> 8) &
			      0xff);
d735 3
d739 2
a740 4
	/* Disable RANGE_CHECK & ACTIVATE logical device */
	SEND (IO_RANGE_CHECK, 0);
	SEND (ACTIVATE, 1);
}
d742 4
a745 6
int
find_free_irq(irq_mask)
	int irq_mask;
{
	struct emap *irq_map;
	int i, j;
d747 2
a748 2
	irq_map = find_emap("irq");
	i = irq_mask;
d750 31
a780 8
	while (1) {
		j = ffs(i);
		if (j == 0)
			return(0);
		j--;
		if (!probe_extent(irq_map, j, 1))
			return(j);
		i &= ~(0x1 << j);
d782 1
a783 2
	return(0);
}
d785 3
d789 4
a792 2
find_free_drq(drq_mask)
	int drq_mask;
d794 10
a803 2
	struct emap *drq_map;
	int i, j;
d805 3
a807 2
	drq_map = find_emap("drq");
	i = drq_mask;
d809 3
a811 9
	while (1) {
		j = ffs(i);
		if (j == 0)
			return(0);
		j--;
		if (!probe_extent(drq_map, j, 1))
			return(j);
		i &= ~(0x1 << j);
	}
d813 1
a813 1
	return(0);
d816 3
a818 6
/*
 * find free I/O space.
 * if device is capable of doing I/O range check, then use it.
 * else, try to find free region from extent map.
 *
 * assume caller has set csn and ldn properly.
d820 4
a823 4
int
find_free_io(sc, desc, min_addr, max_addr, size, alignment, range_check)
	struct isapnp_softc *sc;
	int desc, min_addr, max_addr, size, alignment, range_check;
d825 36
a860 18
	int addr, i, success = 0;
	bus_space_handle_t data;
	struct emap *io_map;

	if (range_check) {
		for (addr = min_addr; addr <= max_addr; addr += alignment) {
			SEND(ACTIVATE, 0);
			SEND(IO_CONFIG_BASE + desc * 2, addr >> 8);
			SEND(IO_CONFIG_BASE + desc * 2 + 1, addr & 0xff);
			SEND(IO_RANGE_CHECK, 0x2);
			bus_space_map(sc->iot, addr, size, 0, &data);
			i = 0;
			for (i = 0; i < size; i++) {
				if (bus_space_read_1(sc->iot, data, i) !=
				    0xAA) {
					bus_space_unmap(sc->iot, data, size);
					break;
				}
d862 14
a875 4
			if (i == size) {
				success = 1;
				bus_space_unmap(sc->iot, data, size);
				break;
a876 1
		}
d878 15
a892 5
		if (success) {
			return(addr);
		}
		else {
			return(0);
d894 1
a894 9
	} else {
#if 0
		printf("%x len %x\n", addr, size);
#endif
		io_map = find_emap("io");
		addr = min_addr;
		if (!probe_extent(io_map, addr, size))
			return(addr);
		return (0);
@


1.10
log
@Add PnP stuff.  Should compile, doubt if it works 100%.  Worked for
my SB at one point, but it's been a while...

Thanks Theo for giving me this code.  It still needs a lot of work,
all my fault... ;-)
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.9 1996/11/29 22:55:03 niklas Exp $	*/
d435 2
d442 1
@


1.9
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.8 1996/11/23 21:46:42 kstailey Exp $	*/
d69 3
a71 2
#include "isapnpreg.h"
#include "isapnpvar.h"
d81 9
a97 1
	int rd_offset;
d112 18
a129 22
void postisapnpattach __P((struct device *parent,
			   struct device *self, void *aux));
static int isapnpquery __P((struct isapnp_softc *sc,
			    u_int32_t dev_id, struct isa_attach_args *ia));
static void send_Initiation_LFSR __P((struct isapnp_softc *sc));
static int get_serial __P((struct isapnp_softc *sc, unsigned char *data));
static int isolation_protocol __P((struct isapnp_softc *sc));
static void read_config __P((struct isapnp_softc *sc,
			     struct cardinfo *card, int csn));
static int get_resource_info __P((struct isapnp_softc *sc,
				  char *buffer, int len));
static void config_device __P((struct isapnp_softc *sc,
			       struct isa_attach_args *data));
static int find_free_irq __P((int irq_mask));
static int find_free_drq __P((int drq_mask));
static int find_free_io  __P((struct isapnp_softc *sc, int desc,
			      int min_addr, int max_addr, int size,
			      int alignment, int range_check));
static int handle_small_res __P((unsigned char *resinfo,
				 int item, int len, struct cardinfo *card));
static void handle_large_res __P((unsigned char *resinfo,
				  int item, int len, struct cardinfo *card));
a150 4
#ifdef notdef
	struct cardinfo *card;
	int iobase;
#endif
d162 8
a169 4
	/*
	 * WRITE_DATA port is located at fixed offset (0x0800)
	 * from ADDRESS port,
	 * and valid READ_DATA ports are from 0x203 to 0x3ff.
a170 4
	if (bus_space_map(sc->iot, ADDRESS, 1, 0, &(sc->addrh)) ||
	    bus_space_map(sc->iot, ADDRESS+0x0800, 1, 0, &(sc->wdh)) ||
	    bus_space_map(sc->iot, 0x0200, 0x200, 0, &(sc->rdh)))
		panic("isapnpattach: io mapping failed");
d172 10
a181 1
	/* Try various READ_DATA ports from 0x203-0x3ff */
d183 11
d195 1
a195 3
		if (num_pnp_devs) {
			printf(": readport 0x%x, %d devices",
			    (sc->rd_port << 2) | 0x3, num_pnp_devs);
d197 3
a199 1
		}
d201 30
a230 3
	if (num_pnp_devs == 0)
		printf(": 0 devices");
	printf("\n");
d243 5
d249 3
a251 4
	for (card = sc->q_card.tqh_first; card;
	    card = card->card_link.tqe_next) {
		for (dev = card->q_dev.tqh_first; dev;
		    dev = dev->dev_link.tqe_next) {
a260 1
			ia.ia_delayioh = isc->sc_delayioh;
d262 23
a284 3
			isapnpquery(sc, ia.id, &ia);
			if (!config_found_sm(self, &ia, isapnpprint,
			    isapnpsubmatch)) {
d286 2
d294 1
d297 2
a307 2
	unsigned char info[4];
	struct emap *io_map, *mem_map, *irq_map, *drq_map;
a308 6
	io_map = find_emap("io");
	mem_map = find_emap("mem");
	irq_map = find_emap("irq");
	drq_map = find_emap("drq");

	bcopy(&ia->id, info, 4);
d310 5
a314 8
		printf("device <%c%c%c%02x%02x> at %s",
		       ((info[0] & 0x7c) >> 2) + 64,
		       (((info[0] & 0x03) << 3) |
			((info[1] & 0xe0) >> 5)) + 64,
		       (info[1] & 0x1f) + 64,
		       info[2], info[3], pnp);
	}
	if (!pnp) {
d317 2
a318 5
		if (ia->ia_iosize > 1) {
			printf("-0x%x",
			       ia->ia_iobase + ia->ia_iosize - 1);
			add_extent(io_map, ia->ia_iobase, ia->ia_iosize);
		}
d321 3
a323 6
		if (ia->ia_msize > 1) {
			printf("-0x%x",
			       ia->ia_maddr + ia->ia_msize - 1);
			add_extent(mem_map, ia->ia_maddr, ia->ia_msize);
		}
		if (ia->ia_irq != IRQUNK) {
d325 1
a325 3
			add_extent(irq_map, ia->ia_irq, 1);
		}
		if (ia->ia_drq != DRQUNK) {
a326 2
			add_extent(drq_map, ia->ia_drq, 1);
		}
d331 50
d389 2
a390 1
	int ret;
d392 4
a395 2
	if (cf->cf_pnpid == ia->id ||
	    cf->cf_pnpid == ia->comp_id) {
d397 1
a397 1
		return (ret);
d399 19
a417 1
	return (0);
d433 58
a490 2
#ifdef notdef
	int irq, drq, iobase, mbase;
d492 39
a530 1
	int c, i, j, fail, success;
d532 71
a602 10
	for (card = sc->q_card.tqh_first; card;
	     card = card->card_link.tqe_next) {
	  for (dev = card->q_dev.tqh_first; dev;
	       dev = dev->dev_link.tqe_next) {
	    if (dev_id == dev->id ||
		dev_id == dev->comp_id) {
	      tmp = malloc(sizeof(struct isa_attach_args), M_DEVBUF, M_WAITOK);
	      bzero(tmp, sizeof(struct isa_attach_args));
	      SEND(WAKE, card->csn);
	      SEND(SET_LDN, dev->ldn);
d604 37
a640 23
	      for (conf = dev->q_conf.tqh_first; conf;
		   conf = conf->conf_link.tqe_next) {
		/*
		 *  BASIC CONFIGURATION
		 */
		if (conf->prio == BASIC_CONFIGURATION) {
		  if (conf->irq[0]) {
		    for (c = 0; conf->irq[c] && c < 2; c++) {
		      i = conf->irq[c]->num;
		      j = find_free_irq(i);
		      if (j) {
			ipa->irq[c].num = j;
			/*
			 * if the interrupt can not be configured as
			 * low true level-triggered,
			 * then set it to high true edge-triggered.
			 * XXX needs rework
			 */
			if (conf->irq[c]->info & 0x08) {
			  ipa->irq[c].type = 0x01;
			}
			else {
			  ipa->irq[c].type = 0x10;
a641 30
		      }
		    }
		  }
		  if (conf->dma[0]) {
		    for (c = 0; conf->dma[c] && c < 2; c++) {
		      i = conf->dma[c]->channel;
		      j = find_free_drq(i);
		      if (j) {
			ipa->drq[c] = j;
		      }
		    }
		  }
		  if (conf->io[0]){
		    for (c = 0; conf->io[c] && c < 8; c++) {
		      ipa->port[c] = find_free_io(sc, c,
						 conf->io[c]->min_base,
						 conf->io[c]->max_base,
						 conf->io[c]->size,
						 conf->io[c]->alignment,
						 dev->io_range_check);
		    }
		  }
		  /* XXX mem */
		  if (conf->mem[0]) {
		    for (c = 0; conf->mem[c] && c < 4; c++) {
		      ipa->mem[c].base = conf->mem[c]->min_base;
		      ipa->mem[c].range = conf->mem[c]->size;
		    }
		  }
		}
a642 71
		/*
		 *  DEPENDENT FUNCTION
		 */
		fail = 0; success = 1;
		if (conf->irq[0]) {
		  for (c = 0; conf->irq[c] && c < 2; c++) {
		    i = conf->irq[c]->num;
		    j = find_free_irq(i);
		    if (j) {
		      tmp->irq[c].num = j;
		      /*
		       * if the interrupt can not be
		       * low true level-triggered,
		       * then set it to high true edge-triggered.
		       * XXX rework
		       */
		      if (conf->irq[c]->info & 0x08) {
			tmp->irq[c].type = 0x01;
		      }
		      else {
			tmp->irq[c].type = 0x10;
		      }
		    }
		    else {
		      fail = 1;
		      success = 0;
		      break;
		    }
		  }
		}
		if (conf->dma[0]) {
		  for (c = 0; conf->dma[c] && c < 2; c++) {
		    i = conf->dma[c]->channel;
		    j = find_free_drq(i);
		    if (j) {
		      tmp->drq[c] = j;
		    }
		    else {
		      fail = 1;
		      success = 0;
		      break;
		    }
		  }
		}
		if (conf->io[0]) {
		  for (c = 0; conf->io[c] && c < 8; c++) {
		    tmp->port[c] = find_free_io(sc, c,
						conf->io[c]->min_base,
						conf->io[c]->max_base,
						conf->io[c]->size,
						conf->io[c]->alignment,
						dev->io_range_check);
		    if (!tmp->port[c]) {
		      fail = 1;
		      success = 0;
		      break;
		    }
		  }
		}
		if (conf->mem[0]) {
		  for (c = 0; conf->mem[c] && c < 4; c++) {
		    tmp->mem[c].base = conf->mem[c]->min_base;
		    tmp->mem[c].range = conf->mem[c]->size;

		    if (!tmp->mem[c].base) {
		      fail = 1;
		      success = 0;
		      break;
		    }
		  }
		}
d644 15
a658 4
		if (fail) {
		  continue;
		}
	      }
d660 8
a667 13
	      if (!success) {
		return(0);
	      }

	      for (c = 0; c < 2; c++) {
		if (tmp->irq[c].num) {
		  ipa->irq[c].num = tmp->irq[c].num;
		  ipa->irq[c].type = tmp->irq[c].type;
		}
	      }
	      for (c = 0; c < 8; c++) {
	        if (tmp->port[c]) {
		  ipa->port[c] = tmp->port[c];
a668 14
	      }
	      for (c = 0; c < 4; c++) {
		if (tmp->mem[c].base) {
		  ipa->mem[c].base = tmp->mem[c].base;
		}
	      }
	      config_device(sc, ipa);
	      ipa->ia_iobase = ipa->port[0];
	      ipa->ia_irq = ipa->irq[0].num;
	      ipa->ia_drq = ipa->drq[0];
	      free(tmp, M_DEVBUF);
	      return(1);
	    }
	  }
d677 1
a677 1
static void
d701 1
a701 1
static int
a712 1
	sc->rd_offset = ((sc->rd_port - 0x80) << 2) | 0x3;
d715 1
a715 1
		bit = bus_space_read_1(iot, rdh, sc->rd_offset) == 0x55;
d719 1
a719 2
		bit = (bus_space_read_1(iot, rdh, sc->rd_offset) == 0xaa) &&
		    bit;
d736 1
a736 1
static int
d739 1
a739 1
	char *buffer;
d744 3
d750 1
a750 2
			if ((bus_space_read_1(sc->iot, sc->rdh, sc->rd_offset))
			    & 0x1)
d755 1
a755 1
			printf("%s: failed to report resource data\n",
d760 5
a764 1
		buffer[i] = bus_space_read_1(sc->iot, sc->rdh, sc->rd_offset);
d766 3
d781 1
a781 1
static int
d806 1
a806 1
		 * we simple treat is as a special case.
d823 2
a824 1
		for (i = 0; card->dev->conf->irq[i]; i++) ;
d826 3
a828 3
						 M_DEVBUF, M_WAITOK);
		card->dev->conf->irq[i]->num = resinfo[0] | resinfo[1] << 8;
		if (len == 3) {
d830 1
a830 2
		}
		else {
a831 1
		}
d834 2
a835 1
		for (i = 0; card->dev->conf->dma[i]; i++) ;
d837 1
a837 1
						 M_DEVBUF, M_WAITOK);
d843 1
a843 1
					 M_DEVBUF, M_WAITOK);
d845 1
a845 1
				  conf_link);
d856 1
a856 1
					GOOD_CONFIGURATION;
d860 1
a860 1
					ACCEPTABLE_CONFIGURATION;
d864 1
a864 1
					SUBOPTIMAL_CONFIGURATION;
d868 1
a868 1
					RESERVED_CONFIGURATION;
d876 2
a877 1
		for (i = 0; card->dev->conf->io[i]; i++) ;
d879 1
a879 1
						M_DEVBUF, M_WAITOK);
d883 1
a883 1
			resinfo[1] | resinfo[2] << 8;
d885 1
a885 1
			resinfo[3] | resinfo[4] << 8;
d892 1
a892 1
						M_DEVBUF, M_WAITOK);
d896 1
a896 1
			resinfo[0] | (resinfo[1] & 0x3) << 8;
d898 1
a898 1
			card->dev->conf->io[i]->min_base;
d906 3
d915 1
a915 1
static void
d925 2
a926 1
		for (i = 0; card->dev->conf->mem[i]; i++) ;
d928 1
a928 1
						 M_DEVBUF, M_WAITOK);
d932 1
a932 1
			(resinfo[1] | resinfo[2] << 8) << 8;
d934 1
a934 1
			(resinfo[3] | resinfo[4] << 8) << 8;
d936 1
a936 1
			(resinfo[5] | resinfo[6] << 8);
d938 1
a938 1
			card->dev->conf->mem[i]->alignment = 1 << 16;
d940 1
a940 1
			(resinfo[7] | resinfo[8] << 8) << 8;
d944 2
a945 2
			card->dev->id_string =
				(char *)malloc(len+1, M_DEVBUF, M_WAITOK);
d948 3
d952 2
a953 2
			card->id_string = 
				(char *)malloc(len+1, M_DEVBUF, M_WAITOK);
d956 3
d969 2
d973 2
d978 1
a978 1
static void
a983 3
#ifdef notdef
	u_char serial[9];
#endif
d985 2
a986 1
	int i, large_len;
d988 1
d993 1
d996 1
a996 1
	 * since we are in the card isolation process, so ther's no reason
d1000 2
a1001 3
	/*
	 * allow up to 1KB of resource info, should be plenty */
	for (i = 0; i < 1024; i++) {
d1011 3
d1015 2
a1016 1
			if (!get_resource_info(sc, resinfo, S_LEN))
d1018 1
d1025 2
a1026 1
			if (!get_resource_info(sc, (char *)&large_len, 2))
d1028 1
a1028 1

d1030 3
a1032 1
			if (!get_resource_info(sc, resinfo, large_len))
d1034 1
d1036 3
d1050 1
a1050 1
static int
d1058 8
d1068 1
d1071 4
d1085 1
d1087 1
a1087 2
			card = malloc(sizeof(struct cardinfo),
				      M_DEVBUF, M_WAITOK);
d1097 1
a1097 2
		}
		else
d1104 1
a1104 1
 * Configure PnP devices, given a set of configuration data
d1106 1
a1106 1
static void
d1117 3
a1119 4
#if 0
	printf ("%s: configuring CSN %x (logical device %x)\n",
		sc->sc_dev.dv_xname,
		data->csn,
d1123 1
d1128 1
d1137 1
d1145 1
d1151 1
d1173 2
d1179 1
a1179 1
static int
d1183 1
a1184 1
	struct emap *irq_map;
d1191 1
a1191 1
		if (!j) {
d1193 2
a1194 6
		}
		/*
		 * irq_mask is starting from 0
		 */
		j --;
		if (!probe_extent(irq_map, j, 1)) {
a1195 1
		}
d1198 2
d1206 1
a1207 1
	struct emap *drq_map;
d1214 1
a1214 1
		if (!j) {
d1216 2
a1217 6
		}
		/*
		 * drq_mask is starting from 0
		 */
		j --;
		if (!probe_extent(drq_map, j, 1)) {
a1218 1
		}
d1221 2
d1232 1
a1232 1
static int
d1269 4
a1272 2
	}
	else {
d1275 1
a1275 1
		if (!probe_extent(io_map, addr, size)) {
d1277 1
a1277 2
		}
		return(0);
@


1.8
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.7 1996/11/12 20:30:39 niklas Exp $	*/
d65 1
a65 1
#include <machine/bus.old.h>
d72 2
a73 2
#define SEND(d, r)	{ bus_io_write_1(sc->bc, sc->addrh, 0, d); \
                          bus_io_write_1(sc->bc, sc->wdh,   0, r); }
d84 4
a87 4
	bus_chipset_tag_t bc;
	bus_io_handle_t addrh;
	bus_io_handle_t wdh;
	bus_io_handle_t rdh;
d157 1
a157 1
	sc->bc = ia->ia_bc;
d166 3
a168 3
	if (bus_io_map(sc->bc, ADDRESS, 1, &(sc->addrh)) ||
	    bus_io_map(sc->bc, ADDRESS+0x0800, 1, &(sc->wdh))   ||
	    bus_io_map(sc->bc, 0x0200, 0x200, &(sc->rdh)))
d203 1
a203 1
			ia.ia_bc = iba->iba_bc;
d495 2
a496 2
	bus_chipset_tag_t bc = sc->bc;
	bus_io_handle_t addrh = sc->addrh;
d500 2
a501 2
	bus_io_write_1(bc, addrh, 0, 0);
	bus_io_write_1(bc, addrh, 0, 0);
d504 1
a504 1
	bus_io_write_1(bc, addrh, 0, cur);
d508 1
a508 1
		bus_io_write_1(bc, addrh, 0, cur);
d520 2
a521 2
	bus_chipset_tag_t bc = sc->bc;
	bus_io_handle_t rdh = sc->rdh;
d530 1
a530 1
		bit = bus_io_read_1(bc, rdh, sc->rd_offset) == 0x55;
d534 2
a535 1
		bit = (bus_io_read_1(bc, rdh, sc->rd_offset) == 0xaa) && bit;
d561 1
a561 1
		bus_io_write_1(sc->bc, sc->addrh, 0, STATUS);
d563 1
a563 1
			if ((bus_io_read_1(sc->bc, sc->rdh, sc->rd_offset))
d573 2
a574 2
		bus_io_write_1(sc->bc, sc->addrh, 0, RESOURCE_DATA);
		buffer[i] = bus_io_read_1(sc->bc, sc->rdh, sc->rd_offset);
d847 1
a847 1
		bus_io_write_1(sc->bc, sc->addrh, 0, SERIAL_ISOLATION);
d1007 1
a1007 1
	bus_io_handle_t data;
d1016 1
a1016 1
			bus_io_map(sc->bc, addr, size, &data);
d1019 3
a1021 2
				if (bus_io_read_1(sc->bc, data, i) != 0xAA) {
					bus_io_unmap(sc->bc, data, size);
d1027 1
a1027 1
				bus_io_unmap(sc->bc, data, size);
@


1.7
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.6 1996/10/18 15:39:34 mickey Exp $	*/
d77 1
a77 1
int isapnpprint __P((void *aux, char *pnp));
d229 1
a229 1
	char *pnp;
@


1.6
log
@-Wall happiness.
i suppose i may hurt someone editing this file, but i need a fresh kernel (:
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.5 1996/08/16 08:35:01 deraadt Exp $	*/
d65 1
a65 1
#include <machine/bus.h>
@


1.5
log
@: 0 devices
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.4 1996/08/15 17:28:40 shawn Exp $	*/
d103 2
d121 4
d146 1
d149 1
d307 1
d309 1
d775 4
a778 1
	u_char serial[9], tag, *resinfo;
@


1.4
log
@make use of compatiable device id; delete redundant argument
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.3 1996/08/15 06:33:28 deraadt Exp $	*/
d172 2
@


1.3
log
@pass in sc_delayioh too
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.2 1996/08/15 05:31:43 deraadt Exp $	*/
d168 1
a168 2
			    sc->sc_dev.dv_xname, (sc->rd_port << 2) | 0x3,
			    num_pnp_devs);
d196 1
d276 2
a277 1
	if (cf->cf_pnpid == ia->id) {
@


1.2
log
@perfect attach messages, use bcopy/bzero
@
text
@d1 1
a1 1
/*	$OpenBSD: isapnp.c,v 1.1 1996/08/14 14:36:15 shawn Exp $	*/
d168 1
a168 1
			    sc->sc_dev.dv_xname, (sc->rd_port << 2) | 0x3);
d199 2
d280 1
a280 2

	return(0);
@


1.1
log
@rudimentary plug-and-play support, see pnp(4)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a162 3
	printf("\n%s: Checking for ISA Plug-n-Play devices... ",
	       sc->sc_dev.dv_xname);

d167 3
a169 4
			printf("\n%s: Plug-n-Play Read_Port at 0x%x, ",
			       sc->sc_dev.dv_xname,
			       (sc->rd_port << 2) | 0x3);
			printf("%d devices were found\n", num_pnp_devs);
d173 1
a173 5
	if (!num_pnp_devs) {
		printf("\n%s: No Plug-n-Play devices were found\n",
		       sc->sc_dev.dv_xname);
		return;
	}
d188 3
a190 4
	     card = card->card_link.tqe_next) {
		for (dev = card->q_dev.tqh_first;
		     dev;
		     dev = dev->dev_link.tqe_next) {
d193 1
a193 1
			memset(&ia, 0, sizeof(ia));
d201 1
a201 1
					     isapnpsubmatch)) {
d276 1
a276 1
		return(ret);
d305 1
a305 1
	      memset(tmp, 0, sizeof(struct isa_attach_args));
d583 1
a583 1
		memcpy(card->pnp_version, resinfo, 2);
d840 1
a840 1
			memcpy(card->serial, data, 9);
d869 1
a869 1
	printf ("%s:    Configuring CSN %x (Logical Device %x)\n",
@
