head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.8
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.10
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.6
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.42.0.6
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.42.0.4
	OPENBSD_5_6_BASE:1.42
	OPENBSD_5_5:1.41.0.6
	OPENBSD_5_5_BASE:1.41
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.40.0.12
	OPENBSD_5_3_BASE:1.40
	OPENBSD_5_2:1.40.0.10
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.8
	OPENBSD_5_0:1.40.0.6
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.4
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.26
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.28
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.24
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.39.0.22
	OPENBSD_4_4_BASE:1.39
	OPENBSD_4_3:1.39.0.20
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.39.0.18
	OPENBSD_4_2_BASE:1.39
	OPENBSD_4_1:1.39.0.16
	OPENBSD_4_1_BASE:1.39
	OPENBSD_4_0:1.39.0.14
	OPENBSD_4_0_BASE:1.39
	OPENBSD_3_9:1.39.0.12
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.39.0.10
	OPENBSD_3_8_BASE:1.39
	OPENBSD_3_7:1.39.0.8
	OPENBSD_3_7_BASE:1.39
	OPENBSD_3_6:1.39.0.6
	OPENBSD_3_6_BASE:1.39
	SMP_SYNC_A:1.39
	SMP_SYNC_B:1.39
	OPENBSD_3_5:1.39.0.4
	OPENBSD_3_5_BASE:1.39
	OPENBSD_3_4:1.39.0.2
	OPENBSD_3_4_BASE:1.39
	UBC_SYNC_A:1.38
	OPENBSD_3_3:1.38.0.6
	OPENBSD_3_3_BASE:1.38
	OPENBSD_3_2:1.38.0.4
	OPENBSD_3_2_BASE:1.38
	OPENBSD_3_1:1.38.0.2
	OPENBSD_3_1_BASE:1.38
	UBC_SYNC_B:1.38
	UBC:1.37.0.14
	UBC_BASE:1.37
	OPENBSD_3_0:1.37.0.12
	OPENBSD_3_0_BASE:1.37
	OPENBSD_2_9_BASE:1.37
	OPENBSD_2_9:1.37.0.10
	OPENBSD_2_8:1.37.0.8
	OPENBSD_2_8_BASE:1.37
	OPENBSD_2_7:1.37.0.6
	OPENBSD_2_7_BASE:1.37
	SMP:1.37.0.4
	SMP_BASE:1.37
	kame_19991208:1.37
	OPENBSD_2_6:1.37.0.2
	OPENBSD_2_6_BASE:1.37
	OPENBSD_2_5:1.36.0.2
	OPENBSD_2_5_BASE:1.36
	OPENBSD_2_4:1.35.0.2
	OPENBSD_2_4_BASE:1.35
	OPENBSD_2_3:1.31.0.2
	OPENBSD_2_3_BASE:1.31
	OPENBSD_2_2:1.22.0.4
	OPENBSD_2_2_BASE:1.22
	OPENBSD_2_1:1.22.0.2
	OPENBSD_2_1_BASE:1.22
	OPENBSD_2_0:1.17.0.2
	OPENBSD_2_0_BASE:1.17
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2015.05.25.15.19.22;	author miod;	state Exp;
branches;
next	1.45;
commitid	DqQIixx3cCaVHwy5;

1.45
date	2015.05.24.15.25.34;	author miod;	state Exp;
branches;
next	1.44;
commitid	L4Bnw05dR7Lil3l0;

1.44
date	2015.05.21.19.29.31;	author miod;	state Exp;
branches;
next	1.43;
commitid	Ew1SB4We0M9FNPSi;

1.43
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.41;
commitid	I19imNlAX05zJOED;

1.41
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.08.20.18.32;	author deraadt;	state Exp;
branches;
next	1.39;

1.39
date	2003.06.03.21.09.02;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.37;

1.37
date	99.07.30.17.12.56;	author deraadt;	state Exp;
branches
	1.37.4.1
	1.37.14.1;
next	1.36;

1.36
date	99.02.07.00.54.46;	author millert;	state Exp;
branches;
next	1.35;

1.35
date	98.07.28.13.26.48;	author csapuntz;	state Exp;
branches;
next	1.34;

1.34
date	98.06.29.05.51.13;	author downsj;	state Exp;
branches;
next	1.33;

1.33
date	98.06.29.02.14.23;	author downsj;	state Exp;
branches;
next	1.32;

1.32
date	98.04.26.21.02.47;	author provos;	state Exp;
branches;
next	1.31;

1.31
date	98.01.20.21.42.25;	author niklas;	state Exp;
branches;
next	1.30;

1.30
date	98.01.20.20.39.31;	author niklas;	state Exp;
branches;
next	1.29;

1.29
date	98.01.20.19.05.05;	author niklas;	state Exp;
branches;
next	1.28;

1.28
date	98.01.20.18.40.28;	author niklas;	state Exp;
branches;
next	1.27;

1.27
date	97.12.25.13.33.03;	author downsj;	state Exp;
branches;
next	1.26;

1.26
date	97.12.25.13.28.45;	author downsj;	state Exp;
branches;
next	1.25;

1.25
date	97.12.25.13.18.07;	author downsj;	state Exp;
branches;
next	1.24;

1.24
date	97.12.25.12.06.47;	author downsj;	state Exp;
branches;
next	1.23;

1.23
date	97.12.21.14.41.23;	author downsj;	state Exp;
branches;
next	1.22;

1.22
date	97.01.04.14.14.55;	author niklas;	state Exp;
branches;
next	1.21;

1.21
date	96.12.09.09.27.06;	author niklas;	state Exp;
branches;
next	1.20;

1.20
date	96.11.29.22.55.01;	author niklas;	state Exp;
branches;
next	1.19;

1.19
date	96.11.23.21.46.41;	author kstailey;	state Exp;
branches;
next	1.18;

1.18
date	96.10.31.01.05.08;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	96.08.15.07.38.56;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	96.08.15.05.30.45;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	96.08.15.05.26.19;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	96.08.15.04.46.49;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	96.08.15.01.51.08;	author shawn;	state Exp;
branches;
next	1.12;

1.12
date	96.08.14.14.36.15;	author shawn;	state Exp;
branches;
next	1.11;

1.11
date	96.07.02.22.21.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.26.00.27.23;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.10.12.37.45;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.07.07.37.07;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.05.04.09.39.22;	author niklas;	state Exp;
branches;
next	1.6;

1.6
date	96.04.21.22.24.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.18.23.47.41;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.03.08.16.43.06;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.27.10.31.32;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.29;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches;
next	;

1.37.4.1
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.37.4.2;

1.37.4.2
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	;

1.37.14.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Initialize ipa_ndrq in isascan() too...
@
text
@/*	$OpenBSD: isa.c,v 1.45 2015/05/24 15:25:34 miod Exp $	*/
/*	$NetBSD: isa.c,v 1.85 1996/05/14 00:31:04 thorpej Exp $	*/

/*
 * Copyright (c) 1997, Jason Downs.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR(S) ``AS IS'' AND ANY EXPRESS
 * OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR(S) BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1993, 1994 Charles Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/conf.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/extent.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/isa/isadmareg.h>

int isamatch(struct device *, void *, void *);
void isaattach(struct device *, struct device *, void *);

extern int autoconf_verbose;

struct cfattach isa_ca = {
	sizeof(struct isa_softc), isamatch, isaattach
};

struct cfdriver isa_cd = {
	NULL, "isa", DV_DULL, 1
};

int
isamatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct cfdata *cf = match;
	struct isabus_attach_args *iba = aux;

	if (strcmp(iba->iba_busname, cf->cf_driver->cd_name))
		return (0);

	/* XXX check other indicators */

        return (1);
}

void
isaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isa_softc *sc = (struct isa_softc *)self;
	struct isabus_attach_args *iba = aux;

	isa_attach_hook(parent, self, iba);
	printf("\n");

	sc->sc_iot = iba->iba_iot;
	sc->sc_memt = iba->iba_memt;
#if NISADMA > 0
	sc->sc_dmat = iba->iba_dmat;
#endif /* NISADMA > 0 */
	sc->sc_ic = iba->iba_ic;

#if NISAPNP > 0
	isapnp_isa_attach_hook(sc);
#endif

#if NISADMA > 0
	/*
	 * Map the registers used by the ISA DMA controller.
	 * XXX Should be done in the isadmaattach routine.. but the delay
	 * XXX port makes it troublesome.  Note that these aren't really
	 * XXX valid on ISA busses without DMA.
	 */
	if (bus_space_map(sc->sc_iot, IO_DMA1, DMA1_IOSIZE, 0, &sc->sc_dma1h))
		panic("isaattach: can't map DMA controller #1");
	if (bus_space_map(sc->sc_iot, IO_DMA2, DMA2_IOSIZE, 0, &sc->sc_dma2h))
		panic("isaattach: can't map DMA controller #2");
	if (bus_space_map(sc->sc_iot, IO_DMAPG, 0xf, 0, &sc->sc_dmapgh))
		panic("isaattach: can't map DMA page registers");

	/*
  	 * Map port 0x84, which causes a 1.25us delay when read.
  	 * We do this now, since several drivers need it.
	 * XXX this port doesn't exist on all ISA busses...
	 */
	if (bus_space_subregion(sc->sc_iot, sc->sc_dmapgh, 0x04, 1,
	    &sc->sc_delaybah))
#else /* NISADMA > 0 */
	if (bus_space_map(sc->sc_iot, IO_DMAPG + 0x4, 0x1, 0,
	    &sc->sc_delaybah))
#endif /* NISADMA > 0 */
		panic("isaattach: can't map `delay port'");	/* XXX */

	TAILQ_INIT(&sc->sc_subdevs);
	config_scan(isascan, self);
}

int
isaprint(aux, isa)
	void *aux;
	const char *isa;
{
	struct isa_attach_args *ia = aux;
	int irq, nirq;
	int dma, ndma;

	if (ia->ia_iosize)
		printf(" port 0x%x", ia->ia_iobase);
	if (ia->ia_iosize > 1)
		printf("/%d", ia->ia_iosize);

	if (ia->ia_msize)
		printf(" iomem 0x%x", ia->ia_maddr);
	if (ia->ia_msize > 1)
		printf("/%d", ia->ia_msize);

	nirq = ia->ipa_nirq;
	if (nirq < 0 || nirq > nitems(ia->ipa_irq))
		nirq = 1;
	for (irq = 0; irq < nirq; irq++)
		if (ia->ipa_irq[irq].num != IRQUNK)
			printf(" irq %d", ia->ipa_irq[irq].num);

	ndma = ia->ipa_ndrq;
	if (ndma < 0 || ndma > nitems(ia->ipa_drq))
		ndma = 2;
	for (dma = 0; dma < ndma; dma++)
		if (ia->ipa_drq[dma].num != DRQUNK) {
			if (dma == 0)
				printf(" drq");
			else
				printf(" drq%d", dma + 1);
			printf(" %d", ia->ipa_drq[dma].num);
		}

	return (UNCONF);
}

void
isascan(parent, match)
	struct device *parent;
	void *match;
{
	struct isa_softc *sc = (struct isa_softc *)parent;
	struct device *dev = match;
	struct cfdata *cf = dev->dv_cfdata;
	struct isa_attach_args ia;

	ia.ia_iot = sc->sc_iot;
	ia.ia_memt = sc->sc_memt;
#if NISADMA > 0
	ia.ia_dmat = sc->sc_dmat;
#endif /* NISADMA > 0 */
	ia.ia_ic = sc->sc_ic;
	ia.ia_iobase = cf->cf_iobase;
	ia.ia_iosize = 0x666;
	ia.ia_maddr = cf->cf_maddr;
	ia.ia_msize = cf->cf_msize;
	ia.ia_irq = cf->cf_irq == 2 ? 9 : cf->cf_irq;
	ia.ipa_nirq = ia.ia_irq == IRQUNK ? 0 : 1;
	ia.ia_drq = cf->cf_drq;
	ia.ia_drq2 = cf->cf_drq2;
	ia.ipa_ndrq = 2;
	ia.ia_delaybah = sc->sc_delaybah;

	if (cf->cf_fstate == FSTATE_STAR) {
		struct isa_attach_args ia2 = ia;

		if (autoconf_verbose)
			printf(">>> probing for %s*\n",
			    cf->cf_driver->cd_name);
		while ((*cf->cf_attach->ca_match)(parent, dev, &ia2) > 0) {
#if !defined(__NO_ISA_INTR_CHECK)
			if ((ia2.ia_irq != IRQUNK) &&
			    !isa_intr_check(sc->sc_ic, ia2.ia_irq, IST_EDGE)) {
				printf("%s%d: irq %d already in use\n",
				    cf->cf_driver->cd_name, cf->cf_unit,
				    ia2.ia_irq);
				ia2 = ia;
				break;
			}
#endif

			if (autoconf_verbose)
				printf(">>> probe for %s* clone into %s%d\n",
				    cf->cf_driver->cd_name,
				    cf->cf_driver->cd_name, cf->cf_unit);
			if (ia2.ia_iosize == 0x666) {
				printf("%s: iosize not repaired by driver\n",
				    sc->sc_dev.dv_xname);
				ia2.ia_iosize = 0;
			}
			config_attach(parent, dev, &ia2, isaprint);
			dev = config_make_softc(parent, cf);
#if NISADMA > 0
			if (ia2.ia_drq != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq);
			if (ia2.ia_drq2 != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia2.ia_drq2);
#endif /* NISAMDA > 0 */
			ia2 = ia;
		}
		if (autoconf_verbose)
			printf(">>> probing for %s* finished\n",
			    cf->cf_driver->cd_name);
		free(dev, M_DEVBUF, 0);
		return;
	}

	if (autoconf_verbose)
		printf(">>> probing for %s%d\n", cf->cf_driver->cd_name,
		    cf->cf_unit);
	if ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0) {
#if !defined(__NO_ISA_INTR_CHECK)
		if ((ia.ia_irq != IRQUNK) &&
		    !isa_intr_check(sc->sc_ic, ia.ia_irq, IST_EDGE)) {
			printf("%s%d: irq %d already in use\n",
			    cf->cf_driver->cd_name, cf->cf_unit, ia.ia_irq);
			free(dev, M_DEVBUF, 0);
		} else {
#endif
			if (autoconf_verbose)
				printf(">>> probing for %s%d succeeded\n",
				    cf->cf_driver->cd_name, cf->cf_unit);
			config_attach(parent, dev, &ia, isaprint);

#if NISADMA > 0
			if (ia.ia_drq != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq);
			if (ia.ia_drq2 != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq2);
#endif /* NISAMDA > 0 */
#if !defined(__NO_ISA_INTR_CHECK)
		}
#endif
	} else {
		if (autoconf_verbose)
			printf(">>> probing for %s%d failed\n",
			    cf->cf_driver->cd_name, cf->cf_unit);
		free(dev, M_DEVBUF, 0);
	}
}

char *
isa_intr_typename(type)
	int type;
{

	switch (type) {
        case IST_NONE:
		return ("none");
        case IST_PULSE:
		return ("pulsed");
        case IST_EDGE:
		return ("edge-triggered");
        case IST_LEVEL:
		return ("level-triggered");
	default:
		panic("isa_intr_typename: invalid type %d", type);
	}
}
@


1.45
log
@Initialize ipa_nirq in isascan(). Gets rid of spurious irq locators being
printed for isadma(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.44 2015/05/21 19:29:31 miod Exp $	*/
d217 1
@


1.44
log
@Report all valid interrupt locators in isaprint() - although config(8) stanzas
only allow one irq for isa devices, there is actually support for more since
we got isapnp(4) support, and upcoming changes will actually have regular isa(4)
devices claim more than one irq in their indirect match function.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.43 2015/03/14 03:38:47 jsg Exp $	*/
d214 1
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.42 2014/07/12 18:48:18 tedu Exp $	*/
d158 2
d165 1
d170 20
a189 6
	if (ia->ia_irq != IRQUNK)
		printf(" irq %d", ia->ia_irq);
	if (ia->ia_drq != DRQUNK)
		printf(" drq %d", ia->ia_drq);
	if (ia->ia_drq2 != DRQUNK)
		printf(" drq2 %d", ia->ia_drq2);
@


1.42
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.41 2013/05/30 16:15:02 deraadt Exp $	*/
a64 2

#include <machine/intr.h>
@


1.41
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.40 2010/07/08 20:18:32 deraadt Exp $	*/
d243 1
a243 1
		free(dev, M_DEVBUF);
d256 1
a256 1
			free(dev, M_DEVBUF);
d277 1
a277 1
		free(dev, M_DEVBUF);
@


1.40
log
@use config_activate_children to activate children that might need it
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.39 2003/06/03 21:09:02 deraadt Exp $	*/
d78 1
a78 2
	sizeof(struct isa_softc), isamatch, isaattach, NULL,
	config_activate_children
@


1.39
log
@terms 3 & 4 cleanup based on "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.38 2002/03/14 01:26:56 millert Exp $	*/
d78 2
a79 1
	sizeof(struct isa_softc), isamatch, isaattach
@


1.38
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.37 1999/07/30 17:12:56 deraadt Exp $	*/
a14 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by Jason Downs for the
 *      OpenBSD system.
 * 4. Neither the name(s) of the author(s) nor the name OpenBSD
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
@


1.37
log
@print ports as 0x%x/%d start/len instead of start-end
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.36 1999/02/07 00:54:46 millert Exp $	*/
d79 2
a80 2
int isamatch __P((struct device *, void *, void *));
void isaattach __P((struct device *, struct device *, void *));
@


1.37.14.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.37 1999/07/30 17:12:56 deraadt Exp $	*/
d79 2
a80 2
int isamatch(struct device *, void *, void *);
void isaattach(struct device *, struct device *, void *);
@


1.37.4.1
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d79 2
a80 2
int isamatch(struct device *, void *, void *);
void isaattach(struct device *, struct device *, void *);
@


1.37.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.37.4.1 2002/03/28 12:11:35 niklas Exp $	*/
d15 7
@


1.36
log
@Break out of loop in isa_intr_check() if we know what IRQ we want but isa_intr_check() says we can't have it.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.35 1998/07/28 13:26:48 csapuntz Exp $	*/
d171 1
a171 1
		printf("-0x%x", ia->ia_iobase + ia->ia_iosize - 1);
d175 1
a175 1
		printf("-0x%x", ia->ia_maddr + ia->ia_msize - 1);
@


1.35
log
@

Disable ISA PNP devices before ISA scan
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.34 1998/06/29 05:51:13 downsj Exp $	*/
d224 1
a224 1
				continue;
@


1.34
log
@Only use isa_intr_check() if __NO_ISA_INTR_CHECK isn't #defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.33 1998/06/29 02:14:23 downsj Exp $	*/
d125 4
@


1.33
log
@Use isa_intr_check() to prevent attachment of drivers that won't get an
interrupt.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.32 1998/04/26 21:02:47 provos Exp $	*/
d213 1
d222 1
d254 1
d261 1
d273 1
d275 1
@


1.32
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.31 1998/01/20 21:42:25 niklas Exp $	*/
d213 9
a232 2
			ia2 = ia;

d234 4
a237 4
			if (ia.ia_drq != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq);
			if (ia.ia_drq2 != DRQUNK)
				ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq2);
d239 1
d252 10
a261 4
		if (autoconf_verbose)
			printf(">>> probing for %s%d succeeded\n",
			    cf->cf_driver->cd_name, cf->cf_unit);
		config_attach(parent, dev, &ia, isaprint);
d264 4
a267 4
		if (ia.ia_drq != DRQUNK)
			ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq);
		if (ia.ia_drq2 != DRQUNK)
			ISA_DRQ_ALLOC((struct device *)sc, ia.ia_drq2);
d269 1
@


1.31
log
@missed some conditions on autoconf_verbose
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.30 1998/01/20 20:39:31 niklas Exp $	*/
d176 2
d197 1
a197 1
	ia.ia_iobase = cf->cf_loc[0];
d199 5
a203 4
	ia.ia_maddr = cf->cf_loc[2];
	ia.ia_msize = cf->cf_loc[3];
	ia.ia_irq = cf->cf_loc[4] == 2 ? 9 : cf->cf_loc[4];
	ia.ia_drq = cf->cf_loc[5];
d229 2
d252 2
@


1.30
log
@rev 1.29 really was the version 1.28 should have been, and 1.28 already
contained the diffs 1.29 was said to have.  So this is a revert to 1.28
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.28 1998/01/20 18:40:28 niklas Exp $	*/
d239 3
a241 2
		printf(">>> probing for %s%d succeeded\n",
		    cf->cf_driver->cd_name, cf->cf_unit);
d249 3
a251 2
		printf(">>> probing for %s%d failed\n",
		    cf->cf_driver->cd_name, cf->cf_unit);
@


1.29
log
@Provide a way to debug probes.  set autoconf_verbose via DDB, or
option AUTOCONF_VERBOSE=1
in your kernel config.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.27 1997/12/25 13:33:03 downsj Exp $	*/
d82 2
d206 3
d210 4
d228 3
d235 3
d239 2
d247 3
a249 1
	} else
d251 1
@


1.28
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@a81 2
extern int autoconf_verbose;

a203 3
		if (autoconf_verbose)
			printf(">>> probing for %s*\n",
			    cf->cf_driver->cd_name);
a204 4
			if (autoconf_verbose)
				printf(">>> probe for %s* clone into %s%d\n",
				    cf->cf_driver->cd_name,
				    cf->cf_driver->cd_name, cf->cf_unit);
a218 3
		if (autoconf_verbose)
			printf(">>> probing for %s* finished\n",
			    cf->cf_driver->cd_name);
a222 3
	if (autoconf_verbose)
		printf(">>> probing for %s%d\n", cf->cf_driver->cd_name,
		    cf->cf_unit);
a223 2
		printf(">>> probing for %s%d succeeded\n",
		    cf->cf_driver->cd_name, cf->cf_unit);
d230 1
a230 3
	} else {
		printf(">>> probing for %s%d failed\n",
		    cf->cf_driver->cd_name, cf->cf_unit);
a231 1
	}
@


1.27
log
@argh, typo.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.26 1997/12/25 13:28:45 downsj Exp $	*/
d77 1
d82 2
d121 3
d126 14
d141 2
a142 2
	 * Map port 0x84, which causes a 1.25us delay when read.
	 * We do this now, since several drivers need it.
d145 6
a150 1
	if (bus_space_map(sc->sc_iot, 0x84, 1, 0, &sc->sc_delaybah))
d191 3
d206 3
d210 4
d223 1
d225 2
a226 1
				isa_drq_alloc(sc, ia.ia_drq);
d228 3
d235 3
d239 2
d243 1
d245 5
a249 2
			isa_drq_alloc(sc, ia.ia_drq);
	} else
d251 1
a271 41

#ifdef DIAGNOSTIC
void
isa_drq_alloc(vsp, drq)
	void *vsp;
	int drq;
{
	struct isa_softc *sc = vsp;

	if (drq < 0 || drq > 7)
		panic("isa_drq_alloc: drq %d out of range\n", drq);

	sc->sc_drq |= (1 << drq);
}

void
isa_drq_free(vsp, drq)
	void *vsp;
	int drq;
{
	struct isa_softc *sc = vsp;

	if (drq < 0 || drq > 7)
		panic("isa_drq_free: drq %d out of range\n", drq);

	sc->sc_drq &= ~(1 << drq);
}

int
isa_drq_isfree(vsp, drq)
	void *vsp;
	int drq;
{
	struct isa_softc *sc = vsp;

	if (drq < 0 || drq > 7)
		panic("isa_drq_isfree: drq %d out of range\n", drq);

	return (!((sc->sc_drq << drq) & 1));
}
#endif	/* DIAGNOSTIC */
@


1.26
log
@fix DRQUNK case
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.25 1997/12/25 13:18:07 downsj Exp $	*/
d260 1
a260 1
	return (!(sc->sc_drq << drq) & 1);
@


1.25
log
@Use functions for DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.24 1997/12/25 12:06:47 downsj Exp $	*/
d188 2
a189 1
			isa_drq_alloc(sc, ia.ia_drq);
d198 2
a199 1
		isa_drq_alloc(sc, ia.ia_drq);
@


1.24
log
@Real DRQ usage tracking.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.23 1997/12/21 14:41:23 downsj Exp $	*/
d4 32
d220 41
@


1.23
log
@Obliterate old PnP `code' and outright replace with christos' code.
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.22 1997/01/04 14:14:55 niklas Exp $	*/
d155 2
d162 1
a162 1
	if ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0)
d164 3
a166 1
	else
@


1.22
log
@Add XXX comment about the delay port
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.21 1996/12/09 09:27:06 niklas Exp $	*/
a45 2
#include "isapnp.h"

a79 3
#if NISAPNP > 0
	void postisapnpattach __P((struct device *, struct device *, void *));
#endif /* NISAPNP > 0 */
a97 4

#if NISAPNP > 0
	postisapnpattach(parent, self, aux);
#endif /* NISAPNP > 0 */
a130 13
#if 0
	struct emap *io_map, *mem_map, *irq_map, *drq_map;
#endif

	if (cf->cf_loc[6] != -1)	/* pnp device, scanned later */
		return;

#if 0
	io_map = find_emap("io");
	mem_map = find_emap("mem");
	irq_map = find_emap("irq");
	drq_map = find_emap("drq");
#endif
a151 10
#if 0
			if (ia2.ia_iobase != -1 && ia2.ia_iosize > 0)
				add_extent(io_map, ia2.ia_iobase, ia2.ia_iosize);
			if (ia.ia_maddr != -1 && ia.ia_msize > 0)
				add_extent(mem_map, ia2.ia_maddr, ia2.ia_msize);
			if (ia2.ia_irq != -1)
				add_extent(irq_map, ia2.ia_irq, 1);
			if (ia2.ia_drq != -1)
				add_extent(drq_map, ia2.ia_drq, 1);
#endif
d160 1
a160 11
	if ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0) {
#if 0
		if (ia.ia_iobase > 0 && ia.ia_iosize > 0)
			add_extent(io_map, ia.ia_iobase, ia.ia_iosize);
		if (ia.ia_maddr > 0 && ia.ia_msize > 0)
			add_extent(mem_map, ia.ia_maddr, ia.ia_msize);
		if (ia.ia_irq > 0)
			add_extent(irq_map, ia.ia_irq, 1);
		if (ia.ia_drq > 0)
			add_extent(drq_map, ia.ia_drq, 1);
#endif
a161 1
	}
@


1.21
log
@Import extent manager from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.20 1996/11/29 22:55:01 niklas Exp $	*/
d96 1
@


1.20
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.19 1996/11/23 21:46:41 kstailey Exp $	*/
d139 1
d141 1
d146 1
d151 1
d173 1
d182 1
d192 1
d201 1
@


1.19
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.18 1996/10/31 01:05:08 niklas Exp $	*/
d89 2
a90 1
	sc->sc_bc = iba->iba_bc;
d97 1
a97 1
	if (bus_io_map(sc->sc_bc, 0x84, 1, &sc->sc_delayioh))
d149 2
a150 1
	ia.ia_bc = sc->sc_bc;
d158 1
a158 1
	ia.ia_delayioh = sc->sc_delayioh;
@


1.18
log
@-Wall fixes needed by alpha
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.17 1996/08/15 07:38:56 deraadt Exp $	*/
d110 1
a110 1
	char *isa;
@


1.17
log
@whoops, i made a fatal typo
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.16 1996/08/15 05:30:45 deraadt Exp $	*/
a49 1
int isaprint __P((void *, char *));
@


1.16
log
@do not attempt to isamatch pnp devices
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.15 1996/08/15 05:26:19 deraadt Exp $	*/
d141 1
a141 1
	if (cf->cf_loc[6] == -1)	/* pnp device, scanned later */
@


1.15
log
@repair proto
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.14 1996/08/15 04:46:49 deraadt Exp $	*/
d140 3
@


1.14
log
@warn about 0x666 thingy; use correct isa_attach_args for extent maps
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.13 1996/08/15 01:51:08 shawn Exp $	*/
d84 1
a84 1
	void postisapnpattach(struct device *, struct device *, void *);
@


1.13
log
@oops, forgot to exclude those unused extents before adding to map
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.12 1996/08/14 14:36:15 shawn Exp $	*/
d160 13
a172 8
			if (ia.ia_iobase > 0 && ia.ia_iosize > 0)
				add_extent(io_map, ia.ia_iobase, ia.ia_iosize);
			if (ia.ia_maddr > 0 && ia.ia_msize > 0)
				add_extent(mem_map, ia.ia_maddr, ia.ia_msize);
			if (ia.ia_irq > 0)
				add_extent(irq_map, ia.ia_irq, 1);
			if (ia.ia_drq > 0)
				add_extent(drq_map, ia.ia_drq, 1);
@


1.12
log
@rudimentary plug-and-play support, see pnp(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.11 1996/07/02 22:21:15 deraadt Exp $	*/
d160 8
a167 4
			add_extent(io_map, ia.ia_iobase, ia.ia_iosize);
			add_extent(mem_map, ia.ia_maddr, ia.ia_msize);
			add_extent(irq_map, ia.ia_irq, 1);
			add_extent(drq_map, ia.ia_drq, 1);
d177 8
a184 4
		add_extent(io_map, ia.ia_iobase, ia.ia_iosize);
		add_extent(mem_map, ia.ia_maddr, ia.ia_msize);
		add_extent(irq_map, ia.ia_irq, 1);
		add_extent(drq_map, ia.ia_drq, 1);
@


1.11
log
@support FSTATE_STAR by repetition
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.10 1996/05/26 00:27:23 deraadt Exp $	*/
d39 1
d46 2
d83 3
d102 4
d139 6
d160 4
d172 5
a176 1
	if ((*cf->cf_attach->ca_match)(parent, dev, &ia) > 0)
d178 1
@


1.10
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.9 1996/05/10 12:37:45 deraadt Exp $	*/
a129 3
	if (cf->cf_fstate == FSTATE_STAR)
		panic("clone devices not supported on ISA bus");

d139 12
@


1.9
log
@map delay port
@
text
@d1 2
a2 2
/*	$OpenBSD: isa.c,v 1.6 1996/04/21 22:24:12 deraadt Exp $	*/
/*	$NetBSD: isa.c,v 1.82 1996/05/05 01:14:07 thorpej Exp $	*/
d39 1
a39 1
#ifndef i386							/* XXX */
a40 1
#endif								/* XXX */
d88 1
a88 1
	 * Map port 0x84, which causes a 2.5us delay when read.
@


1.8
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*	$NetBSD: isa.c,v 1.81 1996/04/29 20:03:24 christos Exp $	*/
d88 7
d142 1
@


1.7
log
@Just update the $OpenBSD$ tag, it seems to have got in during the
LOCALID was lost.
@
text
@d2 1
a2 1
/*	$NetBSD: isa.c,v 1.80 1996/04/11 22:25:44 cgd Exp $	*/
d48 1
@


1.6
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: isa.c,v 1.5 1996/04/18 23:47:41 niklas Exp $	*/
@


1.5
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: isa.c,v 1.4 1996/03/08 16:43:06 niklas Exp $	*/
/*	$NetBSD: isa.c,v 1.78 1996/03/08 20:36:21 cgd Exp $	*/
d39 3
d49 6
a54 2
struct cfdriver isacd = {
	NULL, "isa", isamatch, isaattach, DV_DULL, sizeof(struct isa_softc), 1
d81 1
d85 1
d127 1
d135 1
a135 1
	if ((*cf->cf_driver->cd_match)(parent, dev, &ia) > 0)
@


1.4
log
@From NetBSD: merge of 960217
@
text
@d1 2
a2 2
/*	$OpenBSD: isa.c,v 1.3 1996/02/27 10:31:32 niklas Exp $	*/
/*	$NetBSD: isa.c,v 1.76 1996/01/16 07:52:38 mycroft Exp $ */
d43 39
d109 1
d117 1
@


1.3
log
@Removed extraneous space
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: isa.c,v 1.74 1995/06/07 06:46:04 cgd Exp $	*/
d75 1
a75 1
		panic("not bloody likely");
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d1 1
d96 1
a96 1
        case IST_NONE :
@


1.1
log
@Initial revision
@
text
@d91 1
a91 1
	isa_intrtype type;
d95 1
a95 1
        case ISA_IST_NONE :
d97 1
a97 1
        case ISA_IST_PULSE:
d99 1
a99 1
        case ISA_IST_EDGE:
d101 1
a101 1
        case ISA_IST_LEVEL:
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
