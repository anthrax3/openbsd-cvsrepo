head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.6
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.4
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.27.0.8
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.27.0.2
	OPENBSD_5_9_BASE:1.27
	OPENBSD_5_8:1.27.0.6
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.27.0.4
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.8
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.26.0.6
	OPENBSD_5_5_BASE:1.26
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.25.0.20
	OPENBSD_5_3_BASE:1.25
	OPENBSD_5_2:1.25.0.18
	OPENBSD_5_2_BASE:1.25
	OPENBSD_5_1_BASE:1.25
	OPENBSD_5_1:1.25.0.16
	OPENBSD_5_0:1.25.0.14
	OPENBSD_5_0_BASE:1.25
	OPENBSD_4_9:1.25.0.12
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.25.0.10
	OPENBSD_4_8_BASE:1.25
	OPENBSD_4_7:1.25.0.6
	OPENBSD_4_7_BASE:1.25
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.20
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.24.0.18
	OPENBSD_4_2_BASE:1.24
	OPENBSD_4_1:1.24.0.16
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.14
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.24.0.12
	OPENBSD_3_9_BASE:1.24
	OPENBSD_3_8:1.24.0.10
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.24.0.8
	OPENBSD_3_7_BASE:1.24
	OPENBSD_3_6:1.24.0.6
	OPENBSD_3_6_BASE:1.24
	SMP_SYNC_A:1.24
	SMP_SYNC_B:1.24
	OPENBSD_3_5:1.24.0.4
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.24.0.2
	OPENBSD_3_4_BASE:1.24
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.23.0.4
	OPENBSD_3_3_BASE:1.23
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.22.0.2
	OPENBSD_3_1_BASE:1.22
	UBC_SYNC_B:1.23
	UBC:1.21.0.4
	UBC_BASE:1.21
	OPENBSD_3_0:1.21.0.2
	OPENBSD_3_0_BASE:1.21
	OPENBSD_2_9_BASE:1.20
	OPENBSD_2_9:1.20.0.12
	OPENBSD_2_8:1.20.0.10
	OPENBSD_2_8_BASE:1.20
	OPENBSD_2_7:1.20.0.8
	OPENBSD_2_7_BASE:1.20
	SMP:1.20.0.6
	SMP_BASE:1.20
	kame_19991208:1.20
	OPENBSD_2_6:1.20.0.4
	OPENBSD_2_6_BASE:1.20
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.16.0.2
	OPENBSD_2_4_BASE:1.16
	OPENBSD_2_3:1.14.0.4
	OPENBSD_2_3_BASE:1.14
	OPENBSD_2_2:1.14.0.2
	OPENBSD_2_2_BASE:1.14
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	OPENBSD_2_0:1.12.0.2
	OPENBSD_2_0_BASE:1.12
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.29
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.28;
commitid	qGgYgJTgEFuAoGj4;

1.28
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.27;
commitid	pi1a9KN0itEngOc4;

1.27
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.26;
commitid	uzzBR7hz9ncd4O6G;

1.26
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.25;

1.25
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.14.21.34.59;	author todd;	state Exp;
branches;
next	1.22;

1.22
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.21;

1.21
date	2001.06.06.10.18.57;	author d;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	99.01.24.15.58.54;	author mickey;	state Exp;
branches
	1.20.6.1;
next	1.19;

1.19
date	99.01.07.06.14.48;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	99.01.02.00.02.46;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.11.03.21.15.00;	author downsj;	state Exp;
branches;
next	1.16;

1.16
date	98.05.13.10.25.11;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	98.04.26.21.02.51;	author provos;	state Exp;
branches;
next	1.14;

1.14
date	97.07.10.23.06.36;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	96.10.16.12.33.39;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	96.08.24.05.03.18;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.05.26.00.27.26;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.07.07.37.25;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.22.24.23;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.18.23.47.44;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.01.00.57;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.10.27;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.16.43.10;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.36.02;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.32;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.52;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.37;	author deraadt;	state Exp;
branches;
next	;

1.20.6.1
date	2001.07.04.10.41.34;	author niklas;	state Exp;
branches;
next	1.20.6.2;

1.20.6.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.20.6.3;

1.20.6.3
date	2003.03.28.00.38.16;	author niklas;	state Exp;
branches;
next	1.20.6.4;

1.20.6.4
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	;

1.21.4.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2002.10.29.00.33.26;	author art;	state Exp;
branches;
next	1.21.4.3;

1.21.4.3
date	2003.05.19.22.08.46;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: pas.c,v 1.28 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: pas.c,v 1.37 1998/01/12 09:43:43 thorpej Exp $	*/

/*
 * Copyright (c) 1991-1993 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the Computer Systems
 *	Engineering Group at Lawrence Berkeley Laboratory.
 * 4. Neither the name of the University nor of the Laboratory may be used
 *    to endorse or promote products derived from this software without
 *    specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */
/*
 * jfw 7/13/97 - The soundblaster code requires the generic bus-space 
 * structures to be set up properly.  Rather than go to the effort of making
 * code for a dead line fully generic, properly set up the SB structures and
 * leave the rest x86/ISA/default-configuration specific.  If you have a
 * REAL computer, go buy a REAL sound card.
 */
/*
 * Todo:
 * 	- look at other PAS drivers (for PAS native support)
 * 	- use common sb.c once emulation is setup
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>
#include <dev/midi_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/isa/sbdspvar.h>
#include <dev/isa/sbreg.h>

#define DEFINE_TRANSLATIONS
#include <dev/isa/pasreg.h>

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (pasdebug) printf x
int	pasdebug = 0;
#else
#define DPRINTF(x)
#endif

/*
 * Software state, per SoundBlaster card.
 * The soundblaster has multiple functionality, which we must demultiplex.
 * One approach is to have one major device number for the soundblaster card,
 * and use different minor numbers to indicate which hardware function
 * we want.  This would make for one large driver.  Instead our approach
 * is to partition the design into a set of drivers that share an underlying
 * piece of hardware.  Most things are hard to share, for example, the audio
 * and midi ports.  For audio, we might want to mix two processes' signals,
 * and for midi we might want to merge streams (this is hard due to
 * running status).  Moreover, we should be able to re-use the high-level
 * modules with other kinds of hardware.  In this module, we only handle the
 * most basic communications with the sb card.
 */
struct pas_softc {
	struct sbdsp_softc sc_sbdsp;	/* use sc_dev, sc_id, sc_ih,
					 *     sc_iobase, sc_irq, sc_drq
					 * from here */
	int model;	/* unique to PAS */
	int rev;

};

void	pasconf(int, int, int, int);


/*
 * Define our interface to the higher level audio driver.
 */

struct audio_hw_if pas_hw_if = {
	sbdsp_open,
	sbdsp_close,
	sbdsp_set_params,
	sbdsp_round_blocksize,
	0,
	0,
	0,
	0,
	0,
	sbdsp_haltdma,
	sbdsp_haltdma,
	sbdsp_speaker_ctl,
	0,
	sbdsp_mixer_set_port,
	sbdsp_mixer_get_port,
	sbdsp_mixer_query_devinfo,
	sb_malloc,
	sb_free,
	sb_round,
	sbdsp_get_props,
	sbdsp_trigger_output,
	sbdsp_trigger_input
};

/* The Address Translation code is used to convert I/O register addresses to
   be relative to the given base -register */

static char *pasnames[] = {
	"",
	"Plus",
	"CDPC",
	"16",
	"16Basic"
};

/*XXX assume default I/O base address */
#define pasread(p) inb(p)
#define paswrite(d, p) outb(p, d)

void
pasconf(model, sbbase, sbirq, sbdrq)
	int model;
	int sbbase;
	int sbirq;
	int sbdrq;
{
	paswrite(0x00, INTERRUPT_MASK);
	/* Local timer control register */
	paswrite(0x36, SAMPLE_COUNTER_CONTROL);
	/* Sample rate timer (16 bit) */
	paswrite(0x36, SAMPLE_RATE_TIMER);
	paswrite(0, SAMPLE_RATE_TIMER);
	/* Local timer control register */
	paswrite(0x74, SAMPLE_COUNTER_CONTROL);
	/* Sample count register (16 bit) */
	paswrite(0x74, SAMPLE_BUFFER_COUNTER);
	paswrite(0, SAMPLE_BUFFER_COUNTER);

	paswrite(P_C_PCM_MONO | P_C_PCM_DAC_MODE |
		  P_C_MIXER_CROSS_L_TO_L | P_C_MIXER_CROSS_R_TO_R,
		  PCM_CONTROL);
	paswrite(S_M_PCM_RESET | S_M_FM_RESET |
		  S_M_SB_RESET | S_M_MIXER_RESET, SERIAL_MIXER);

/*XXX*/
	paswrite(I_C_1_BOOT_RESET_ENABLE|1, IO_CONFIGURATION_1);

	paswrite(I_C_2_PCM_DMA_DISABLED, IO_CONFIGURATION_2);
	paswrite(I_C_3_PCM_IRQ_DISABLED, IO_CONFIGURATION_3);
	
#ifdef BROKEN_BUS_CLOCK 
	paswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND |
		  S_C_1_FM_EMULATE_CLOCK, SYSTEM_CONFIGURATION_1);
#else
	paswrite(S_C_1_PCS_ENABLE | S_C_1_PCS_STEREO | S_C_1_PCS_REALSOUND,
		  SYSTEM_CONFIGURATION_1);     
#endif

	/*XXX*/
	paswrite(0, SYSTEM_CONFIGURATION_2);
	paswrite(0, SYSTEM_CONFIGURATION_3);

	/* Sets mute off and selects filter rate of 17.897 kHz */
	paswrite(F_F_MIXER_UNMUTE | 0x01, FILTER_FREQUENCY);

	if (model == PAS_16 || model == PAS_16BASIC)
		paswrite(8, PRESCALE_DIVIDER);
	else
		paswrite(0, PRESCALE_DIVIDER);

	paswrite(P_M_MV508_ADDRESS | P_M_MV508_PCM, PARALLEL_MIXER);
	paswrite(5, PARALLEL_MIXER);
		
	/*
	 * Setup SoundBlaster emulation.
	 */
	paswrite((sbbase >> 4) & 0xf, EMULATION_ADDRESS);
	paswrite(E_C_SB_IRQ_translate[sbirq] | E_C_SB_DMA_translate[sbdrq],
		 EMULATION_CONFIGURATION);
	paswrite(C_E_SB_ENABLE, COMPATIBILITY_ENABLE);

	/*
	 * Set mid-range levels.
	 */
	paswrite(P_M_MV508_ADDRESS | P_M_MV508_MODE, PARALLEL_MIXER);
	paswrite(P_M_MV508_LOUDNESS | P_M_MV508_ENHANCE_NONE, PARALLEL_MIXER);	

	paswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_A, PARALLEL_MIXER);
	paswrite(50, PARALLEL_MIXER);
	paswrite(P_M_MV508_ADDRESS | P_M_MV508_MASTER_B, PARALLEL_MIXER);
	paswrite(50, PARALLEL_MIXER);

	paswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_SB, PARALLEL_MIXER);
	paswrite(P_M_MV508_OUTPUTMIX | 30, PARALLEL_MIXER);

	paswrite(P_M_MV508_ADDRESS | P_M_MV508_MIXER | P_M_MV508_MIC, PARALLEL_MIXER);
	paswrite(P_M_MV508_INPUTMIX | 30, PARALLEL_MIXER);
}

int	pasprobe(struct device *, void *, void *);
void	pasattach(struct device *, struct device *, void *);

struct cfattach pas_ca = {
	sizeof(struct pas_softc), pasprobe, pasattach
};

struct cfdriver pas_cd = {
	NULL, "pas", DV_DULL
};

/*
 * Probe / attach routines.
 */

/*
 * Probe for the soundblaster hardware.
 */
int
pasprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct pas_softc *sc = match;
	struct isa_attach_args *ia = aux;
	int iobase;
	u_char id, t;

        /* ensure we can set this up as a sound blaster */
       	if (!SB_BASE_VALID(ia->ia_iobase)) {
		DPRINTF(("pas: configured SB iobase 0x%x invalid\n", ia->ia_iobase));
		return 0;
	}

	/*
	 * WARNING: Setting an option like W:1 or so that disables
	 * warm boot reset of the card will screw up this detect code
	 * something fierce.  Adding code to handle this means possibly
	 * interfering with other cards on the bus if you have something
	 * on base port 0x388.  SO be forewarned. 
	 */
	/* Talk to first board */
	outb(MASTER_DECODE, 0xbc);
	/* Set base address */

#if 0
	/* XXX Need to setup pseudo device */
	/* XXX What are good io addrs ? */
	if (iobase != PAS_DEFAULT_BASE) {
		DPRINTF(("pas: configured iobase %d invalid\n", iobase));
		return 0;
	}
#else
	/* Start out talking to native PAS */
	iobase = PAS_DEFAULT_BASE;
#endif

	outb(MASTER_DECODE, iobase >> 2);
	/* One wait-state */
	paswrite(1, WAIT_STATE);

	id = pasread(INTERRUPT_MASK);
	if (id == 0xff || id == 0xfe) {
		/* sanity */
		DPRINTF(("pas: bogus card id\n"));
		return 0;
	}
	/*
	 * We probably have a PAS-series board, now check for a
	 * PAS2-series board by trying to change the board revision
	 * bits.  PAS2-series hardware won't let you do this because
	 * the bits are read-only.
	 */
	t = id ^ 0xe0;
	paswrite(t, INTERRUPT_MASK);
	t = inb(INTERRUPT_MASK);
	paswrite(id, INTERRUPT_MASK);

	if (t != id) {
		/* Not a PAS2 */
		DPRINTF(("pas: detected card but PAS2 test failed\n"));
		return 0;
	}
	/*XXX*/
	t = pasread(OPERATION_MODE_1) & 0xf;
	sc->model = O_M_1_to_card[t];
	if (sc->model != 0) {
		sc->rev = pasread(BOARD_REV_ID);
	}
	else {
		DPRINTF(("pas: bogus model id\n"));
		return 0;
	}

        if (sc->model >= 0) {
                if (ia->ia_irq == IRQUNK) {
                        DPRINTF(("pas: sb emulation requires known irq\n"));
                        return (0);
                } 
                pasconf(sc->model, ia->ia_iobase, ia->ia_irq, 1);
        } else {
                DPRINTF(("pas: could not probe pas\n"));
                return (0);
        }

	/* Now a SoundBlaster, so set up proper bus-space hooks
         * appropriately
         */

	sc->sc_sbdsp.sc_iobase = ia->ia_iobase;
	sc->sc_sbdsp.sc_iot = ia->ia_iot;

	/* Map i/o space [we map 24 ports which is the max of the sb and pro */
	if (bus_space_map(sc->sc_sbdsp.sc_iot, ia->ia_iobase, SBP_NPORT, 0,
	    &sc->sc_sbdsp.sc_ioh)) {
		DPRINTF(("pas: can't map i/o space 0x%x/%d in probe\n",
		    ia->ia_iobase, SBP_NPORT));
		return 0;
	}

	if (sbdsp_reset(&sc->sc_sbdsp) < 0) {
		DPRINTF(("pas: couldn't reset card\n"));
		goto unmap;
	}

	/*
	 * Cannot auto-discover DMA channel.
	 */
	if (!SB_DRQ_VALID(ia->ia_drq)) {
		DPRINTF(("pas: configured dma chan %d invalid\n", ia->ia_drq));
		goto unmap;
	}
	if (!SB_IRQ_VALID(ia->ia_irq)) {
		DPRINTF(("pas: configured irq chan %d invalid\n", ia->ia_irq));
		goto unmap;
	}

	sc->sc_sbdsp.sc_irq = ia->ia_irq;
	sc->sc_sbdsp.sc_drq8 = ia->ia_drq;
	sc->sc_sbdsp.sc_drq16 = -1; /* XXX */
	sc->sc_sbdsp.sc_ic = ia->ia_ic;
	
	if (sbdsp_probe(&sc->sc_sbdsp) == 0) {
		DPRINTF(("pas: sbdsp probe failed\n"));
		goto unmap;
	}

	ia->ia_iosize = SB_NPORT;
	return 1;

 unmap:
	bus_space_unmap(sc->sc_sbdsp.sc_iot, sc->sc_sbdsp.sc_ioh, SBP_NPORT);
	return 0;
}

/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver .
 */
void
pasattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pas_softc *sc = (struct pas_softc *)self;
	struct isa_attach_args *ia = (struct isa_attach_args *)aux;
	int iobase = ia->ia_iobase;
	
	sc->sc_sbdsp.sc_isa = parent;
	sc->sc_sbdsp.sc_iobase = iobase;
	sc->sc_sbdsp.sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
	    IST_EDGE, IPL_AUDIO | IPL_MPSAFE,
	    sbdsp_intr, &sc->sc_sbdsp, sc->sc_sbdsp.sc_dev.dv_xname);

	printf(" ProAudio Spectrum %s [rev %d] ", pasnames[sc->model], sc->rev);
	
	sbdsp_attach(&sc->sc_sbdsp);

	audio_attach_mi(&pas_hw_if, &sc->sc_sbdsp, &sc->sc_sbdsp.sc_dev);
}
@


1.28
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.26 2013/05/24 07:58:46 ratchov Exp $	*/
a103 1
int	pas_getdev(void *, struct audio_device *);
a123 1
	pas_getdev,
a146 6
static struct audio_device pas_device = {
	"PAS,??",
	"",
	"pas"
};

a408 5
	snprintf(pas_device.name, sizeof pas_device.name, "pas,%s",
	    pasnames[sc->model]);
	snprintf(pas_device.version, sizeof pas_device.version, "%d",
	    sc->rev);

a409 9
}

int
pas_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
{
	*retp = pas_device;
	return 0;
@


1.27
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@a114 2
	0,
	sbdsp_query_encoding,
a132 1
        sb_mappage,
d135 1
a135 2
	sbdsp_trigger_input,
	NULL
@


1.26
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.25 2008/04/21 00:32:42 jakemsr Exp $	*/
a55 1
#include <sys/proc.h>
@


1.25
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.24 2003/04/27 11:22:53 ho Exp $	*/
d414 3
a416 2
	sc->sc_sbdsp.sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_AUDIO, sbdsp_intr, &sc->sc_sbdsp, sc->sc_sbdsp.sc_dev.dv_xname);
@


1.24
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.23 2002/06/14 21:34:59 todd Exp $	*/
d139 2
a140 1
	sbdsp_trigger_input
@


1.23
log
@spelling; from Brian Poole <raj@@cerias.purdue.edu>
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.22 2002/03/14 01:26:56 millert Exp $	*/
d420 4
a423 2
	sprintf(pas_device.name, "pas,%s", pasnames[sc->model]);
	sprintf(pas_device.version, "%d", sc->rev);
@


1.22
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.21 2001/06/06 10:18:57 d Exp $	*/
d46 1
a46 1
 * 	- look at other PAS drivers (for PAS native suport)
@


1.21
log
@missing bus linkage. ok, niklas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.20 1999/01/24 15:58:54 mickey Exp $	*/
d105 2
a106 2
int	pas_getdev __P((void *, struct audio_device *));
void	pasconf __P((int, int, int, int));
d243 2
a244 2
int	pasprobe __P((struct device *, void *, void *));
void	pasattach __P((struct device *, struct device *, void *));
@


1.21.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.21 2001/06/06 10:18:57 d Exp $	*/
d105 2
a106 2
int	pas_getdev(void *, struct audio_device *);
void	pasconf(int, int, int, int);
d243 2
a244 2
int	pasprobe(struct device *, void *, void *);
void	pasattach(struct device *, struct device *, void *);
@


1.21.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.21.4.1 2002/06/11 03:42:22 art Exp $	*/
d46 1
a46 1
 * 	- look at other PAS drivers (for PAS native support)
@


1.21.4.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d420 2
a421 4
	snprintf(pas_device.name, sizeof pas_device.name, "pas,%s",
	    pasnames[sc->model]);
	snprintf(pas_device.version, sizeof pas_device.version, "%d",
	    sc->rev);
@


1.20
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.19 1999/01/07 06:14:48 niklas Exp $	*/
d383 1
d411 1
@


1.20.6.1
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.20 1999/01/24 15:58:54 mickey Exp $	*/
a382 1
	sc->sc_sbdsp.sc_ic = ia->ia_ic;
a409 1
	sc->sc_sbdsp.sc_isa = parent;
@


1.20.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d105 2
a106 2
int	pas_getdev(void *, struct audio_device *);
void	pasconf(int, int, int, int);
d243 2
a244 2
int	pasprobe(struct device *, void *, void *);
void	pasattach(struct device *, struct device *, void *);
@


1.20.6.3
log
@Sync the SMP branch with 3.3
@
text
@d46 1
a46 1
 * 	- look at other PAS drivers (for PAS native support)
@


1.20.6.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.20.6.3 2003/03/28 00:38:16 niklas Exp $	*/
d420 2
a421 4
	snprintf(pas_device.name, sizeof pas_device.name, "pas,%s",
	    pasnames[sc->model]);
	snprintf(pas_device.version, sizeof pas_device.version, "%d",
	    sc->rev);
@


1.19
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.18 1999/01/02 00:02:46 niklas Exp $	*/
a60 1
#include <machine/pio.h>
@


1.18
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.17 1998/11/03 21:15:00 downsj Exp $	*/
a375 13
#ifdef NEWCONFIG
	/*
	 * If the IRQ wasn't compiled in, auto-detect it.
	 */
	if (ia->ia_irq == IRQUNK) {
		ia->ia_irq = isa_discoverintr(pasforceintr, aux);
		sbdsp_reset(&sc->sc_sbdsp);
		if (!SB_IRQ_VALID(ia->ia_irq)) {
			DPRINTF(("pas: couldn't auto-detect interrupt"));
			goto unmap;
		}
	} else
#endif
a396 28

#ifdef NEWCONFIG
void
pasforceintr(aux)
	void *aux;
{
	static char dmabuf;
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;

	/*
	 * Set up a DMA read of one byte.
	 * XXX Note that at this point we haven't called 
	 * at_setup_dmachan().  This is okay because it just
	 * allocates a buffer in case it needs to make a copy,
	 * and it won't need to make a copy for a 1 byte buffer.
	 * (I think that calling at_setup_dmachan() should be optional;
	 * if you don't call it, it will be called the first time
	 * it is needed (and you pay the latency).  Also, you might
	 * never need the buffer anyway.)
	 */
	at_dma(DMAMODE_READ, &dmabuf, 1, ia->ia_drq);
	if (pas_wdsp(iobase, SB_DSP_RDMA) == 0) {
		(void)pas_wdsp(iobase, 0);
		(void)pas_wdsp(iobase, 0);
	}
}
#endif
@


1.17
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.16 1998/05/13 10:25:11 provos Exp $	*/
d65 1
d117 1
a117 1
	NULL,
d121 5
a125 5
	NULL,
	sbdsp_dma_init_output,
	sbdsp_dma_init_input,
	sbdsp_dma_output,
	sbdsp_dma_input,
d130 1
a130 1
	NULL,
d139 2
a140 2
	NULL,
	NULL
d463 1
a463 1
	audio_attach_mi(&pas_hw_if, 0, &sc->sc_sbdsp, &sc->sc_sbdsp.sc_dev);
@


1.16
log
@don't printf in probe routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.15 1998/04/26 21:02:51 provos Exp $	*/
d116 1
a116 1
	0,
d120 1
a120 1
	0,
d129 1
a129 1
	0,
d138 2
@


1.15
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.14 1997/07/10 23:06:36 provos Exp $	*/
d271 1
a271 1
		printf("pas: configured SB iobase 0x%x invalid\n", ia->ia_iobase);
d290 1
a290 1
		printf("pas: configured iobase %d invalid\n", iobase);
d321 1
a321 1
		printf("pas: detected card but PAS2 test failed\n");
d337 1
a337 1
                        printf("pas: sb emulation requires known irq\n");
d356 2
a357 2
		printf("pas: can't map i/o space 0x%x/%d in probe\n",
		    ia->ia_iobase, SBP_NPORT);
d370 1
a370 1
		printf("pas: configured dma chan %d invalid\n", ia->ia_drq);
d381 1
a381 1
			printf("pas: couldn't auto-detect interrupt");
d387 1
a387 1
		printf("pas: configured irq chan %d invalid\n", ia->ia_irq);
@


1.14
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 2
a2 2
/*	$OpenBSD: pas.c,v 1.13 1996/10/16 12:33:39 deraadt Exp $	*/
/*	$NetBSD: pas.c,v 1.17 1996/05/12 23:53:18 mycroft Exp $	*/
d38 7
d60 1
a64 1
#include <dev/mulaw.h>
a104 1
int	pasopen __P((dev_t, int));
d114 1
a114 1
	pasopen,
d116 1
a116 5
	NULL,
	sbdsp_set_in_sr,
	sbdsp_get_in_sr,
	sbdsp_set_out_sr,
	sbdsp_get_out_sr,
d118 1
a118 5
	sbdsp_set_format,
	sbdsp_get_encoding,
	sbdsp_get_precision,
	sbdsp_set_channels,
	sbdsp_get_channels,
d120 3
a122 7
	sbdsp_set_out_port,
	sbdsp_get_out_port,
	sbdsp_set_in_port,
	sbdsp_get_in_port,
	sbdsp_commit_settings,
	mulaw_expand,
	mulaw_compress,
a126 2
	sbdsp_contdma,
	sbdsp_contdma,
d129 1
a129 1
	sbdsp_setfd,
d133 5
a137 2
	0,	/* not full-duplex */
	0
d264 3
a266 3
	register struct pas_softc *sc = match;
	register struct isa_attach_args *ia = aux;
	register int iobase;
d269 6
d346 4
a349 1
	/* Now a SoundBlaster */
d351 10
d363 1
a363 1
		return 0;
d371 1
a371 1
		return 0;
d382 1
a382 1
			return 0;
d388 1
a388 1
		return 0;
d397 1
a397 1
		return 0;
d402 4
d445 1
a445 1
	register struct pas_softc *sc = (struct pas_softc *)self;
d447 1
a447 2
	register int iobase = ia->ia_iobase;
	int err;
d460 1
a460 20
	if ((err = audio_hardware_attach(&pas_hw_if, &sc->sc_sbdsp)) != 0)
		printf("pas: could not attach to audio pseudo-device driver (%d)\n", err);
}

int
pasopen(dev, flags)
    dev_t dev;
    int flags;
{
    struct pas_softc *sc;
    int unit = AUDIOUNIT(dev);
    
    if (unit >= pas_cd.cd_ndevs)
	return ENODEV;
    
    sc = pas_cd.cd_devs[unit];
    if (!sc)
	return ENXIO;
    
    return sbdsp_open(&sc->sc_sbdsp, dev, flags);
@


1.13
log
@missing */
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.12 1996/08/24 05:03:18 deraadt Exp $	*/
d116 1
a116 1
	sbdsp_set_encoding,
a117 1
	sbdsp_set_precision,
a126 1
	sbdsp_get_silence,
a345 2
/*	sc->sc_iobase = ia->ia_iobase; */
	/* and set the SB iobase into the DSP as well ... */
d378 2
a379 1
	sc->sc_sbdsp.sc_drq = ia->ia_drq;
@


1.12
log
@probe-time fix provided by jfw@@jfwhome.funhouse.com
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.11 1996/05/26 00:27:26 deraadt Exp $	*/
d348 1
a348 1
/*	sc->sc_iobase = ia->ia_iobase;
@


1.11
log
@sync 0521
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.10 1996/05/07 07:37:25 deraadt Exp $	*/
d90 4
a93 9
	struct	device sc_dev;		/* base device */
	struct	isadev sc_id;		/* ISA device */
	void	*sc_ih;			/* interrupt vectoring */

	int	sc_iobase;		/* PAS iobase */
	int	sc_irq;			/* PAS irq */
	int	sc_drq;			/* PAS drq */

	int model;
a95 1
	struct sbdsp_softc sc_sbdsp;
d348 1
a348 1
	sc->sc_iobase = ia->ia_iobase;
d435 3
a437 3
	sc->sc_iobase = iobase;
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_AUDIO, sbdsp_intr, &sc->sc_sbdsp, sc->sc_dev.dv_xname);
@


1.10
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: pas.c,v 1.9 1996/04/21 22:24:23 deraadt Exp $	*/
/*	$NetBSD: pas.c,v 1.16 1996/04/29 20:03:28 christos Exp $	*/
d52 1
@


1.9
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: pas.c,v 1.8 1996/04/18 23:47:44 niklas Exp $	*/
/*	$NetBSD: pas.c,v 1.15 1996/04/11 22:29:48 cgd Exp $	*/
d105 1
d174 5
a178 1
pasconf(int model, int sbbase, int sbirq, int sbdrq)
a179 2
	int i;

@


1.8
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: pas.c,v 1.7 1996/03/20 01:00:57 mickey Exp $	*/
/*	$NetBSD: pas.c,v 1.13 1996/03/01 04:08:43 mycroft Exp $	*/
d253 6
a258 2
struct cfdriver pascd = {
	NULL, "pas", pasprobe, pasattach, DV_DULL, sizeof(struct pas_softc)
d438 2
a439 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_AUDIO,
				       sbdsp_intr, &sc->sc_sbdsp, sc->sc_dev.dv_xname);
d460 1
a460 1
    if (unit >= pascd.cd_ndevs)
d463 1
a463 1
    sc = pascd.cd_devs[unit];
@


1.7
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: pas.c,v 1.6 1996/03/19 21:10:27 mickey Exp $	*/
/*	$NetBSD: pas.c,v 1.12 1996/02/16 08:18:34 mycroft Exp $	*/
d411 1
a411 1
	at_dma(1, &dmabuf, 1, ia->ia_drq);
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: pas.c,v 1.5 1996/03/08 16:43:10 niklas Exp $	*/
d435 1
a435 1
				       sbdsp_intr, &sc->sc_sbdsp);
@


1.5
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d435 1
a435 2
				       sbdsp_intr, &sc->sc_sbdsp,
				       sc->sc_dev.dv_xname);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: pas.c,v 1.10 1995/11/10 05:05:18 mycroft Exp $	*/
a103 4

int	pasprobe();
void	pasattach();

d250 3
d265 3
a267 3
pasprobe(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d269 1
a269 1
	register struct pas_softc *sc = (void *)self;
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d435 2
a436 1
				       sbdsp_intr, &sc->sc_sbdsp);
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d434 1
a434 1
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: pas.c,v 1.9 1995/07/19 19:58:51 brezak Exp $	*/
d92 3
a94 3
	u_short sc_iobase;		/* PAS iobase */
	u_short sc_irq;			/* PAS irq */
	u_short sc_drq;			/* PAS drq */
d271 1
a271 1
	register u_short iobase;
d335 1
a335 2
                int irq = ia->ia_irq;
                if (irq == IRQUNK) {
d339 1
a339 2
                irq = ia->ia_irq;
                pasconf(sc->model, ia->ia_iobase, irq, 1);
d375 1
a375 2
		int irq = ia->ia_irq;
		printf("pas: configured irq %d invalid\n", irq);
d398 1
a398 1
	u_short iobase = ia->ia_iobase;
d430 1
a430 1
	register u_short iobase = ia->ia_iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
