head	1.22;
access;
symbols
	OPENBSD_6_2:1.22.0.4
	OPENBSD_6_2_BASE:1.22
	OPENBSD_6_1:1.20.0.10
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.6
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.19.0.18
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.19.0.16
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.14
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.19.0.10
	OPENBSD_5_4_BASE:1.19
	OPENBSD_5_3:1.19.0.8
	OPENBSD_5_3_BASE:1.19
	OPENBSD_5_2:1.19.0.6
	OPENBSD_5_2_BASE:1.19
	OPENBSD_5_1_BASE:1.19
	OPENBSD_5_1:1.19.0.4
	OPENBSD_5_0:1.19.0.2
	OPENBSD_5_0_BASE:1.19
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.17.0.20
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.16
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.18
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.14
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.12
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.17.0.10
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.17.0.8
	OPENBSD_4_2_BASE:1.17
	OPENBSD_4_1:1.17.0.6
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.2
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.16.0.10
	OPENBSD_3_8_BASE:1.16
	OPENBSD_3_7:1.16.0.8
	OPENBSD_3_7_BASE:1.16
	OPENBSD_3_6:1.16.0.6
	OPENBSD_3_6_BASE:1.16
	SMP_SYNC_A:1.16
	SMP_SYNC_B:1.16
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.6
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.4
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.2
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.14.0.6
	UBC_BASE:1.14
	OPENBSD_3_0:1.14.0.4
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.13.0.2
	OPENBSD_2_8_BASE:1.13
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.2
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.9.0.6
	OPENBSD_2_3_BASE:1.9
	OPENBSD_2_2:1.9.0.4
	OPENBSD_2_2_BASE:1.9
	OPENBSD_2_1:1.9.0.2
	OPENBSD_2_1_BASE:1.9;
locks; strict;
comment	@ * @;


1.22
date	2017.09.08.08.37.52;	author sf;	state Exp;
branches;
next	1.21;
commitid	WDjhHAKL4WDECyOu;

1.21
date	2017.09.03.20.03.58;	author sf;	state Exp;
branches;
next	1.20;
commitid	ifQLpfFs5RQLBTN9;

1.20
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.19;
commitid	p4LJxGKbi0BU2cG6;

1.19
date	2011.07.04.05.41.48;	author matthew;	state Exp;
branches;
next	1.18;

1.18
date	2010.11.18.21.13.19;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2005.09.19.01.28.04;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.06.13.55.02;	author ho;	state Exp;
branches
	1.14.6.1;
next	1.13;

1.13
date	2000.07.18.01.28.12;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	99.01.07.06.14.48;	author niklas;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	98.08.08.23.01.15;	author downsj;	state Exp;
branches;
next	1.10;

1.10
date	98.08.08.22.39.10;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	96.11.30.09.34.42;	author downsj;	state Exp;
branches;
next	1.8;

1.8
date	96.11.29.22.54.55;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.11.23.21.46.40;	author kstailey;	state Exp;
branches;
next	1.6;

1.6
date	96.11.12.20.30.32;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	96.10.28.00.06.21;	author downsj;	state Exp;
branches;
next	1.4;

1.4
date	96.10.26.08.07.26;	author downsj;	state Exp;
branches;
next	1.3;

1.3
date	96.10.26.06.22.38;	author downsj;	state Exp;
branches;
next	1.2;

1.2
date	96.10.16.12.46.25;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	96.09.01.20.58.26;	author downsj;	state Exp;
branches;
next	;

1.12.6.1
date	2001.05.14.22.24.33;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	;

1.14.6.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.22
log
@fdc: Print warning if kthread_create fails

Other drivers do this, too. Fixes coverity CID 1455436.
@
text
@/*	$OpenBSD: fdc.c,v 1.21 2017/09/03 20:03:58 sf Exp $	*/
/*	$NetBSD: fd.c,v 1.90 1996/05/12 23:12:03 mycroft Exp $	*/

/*-
 * Copyright (c) 1993, 1994, 1995 Charles Hannum.
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Don Ahn.
 *
 * Portions Copyright (c) 1993, 1994 by
 *  jc@@irbs.UUCP (John Capo)
 *  vak@@zebub.msk.su (Serge Vakulenko)
 *  ache@@astral.msk.su (Andrew A. Chernov)
 *  joerg_wunsch@@uriah.sax.de (Joerg Wunsch)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)fd.c	7.4 (Berkeley) 5/25/91
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/disklabel.h>
#include <sys/disk.h>
#include <sys/buf.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/mtio.h>
#include <sys/syslog.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/kthread.h>

#include <machine/cpu.h>
#include <machine/bus.h>
#include <machine/conf.h>
#include <machine/intr.h>
#include <machine/ioctl_fd.h>

#include <dev/isa/isavar.h>
#include <dev/isa/fdreg.h>

#if defined(__i386__) || defined(__amd64__)	/* XXX */
#include <dev/ic/mc146818reg.h>			/* for NVRAM access */
#include <i386/isa/nvram.h>
#endif

#include <dev/isa/fdlink.h>

#include "fd.h"

/* controller driver configuration */
int fdcprobe(struct device *, void *, void *);
void fdcattach(struct device *, struct device *, void *);
void fdcattach_deferred(void *);
void fdc_create_kthread(void *);

struct cfattach fdc_ca = {
	sizeof(struct fdc_softc), fdcprobe, fdcattach
};

struct cfdriver fdc_cd = {
	NULL, "fdc", DV_DULL
};

int fddprint(void *, const char *);
int fdcintr(void *);

int
fdcprobe(struct device *parent, void *match, void *aux)
{
	register struct isa_attach_args *ia = aux;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_space_handle_t ioh_ctl;
	int rv;

	iot = ia->ia_iot;
	rv = 0;

	/* Map the i/o space. */
	if (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh))
		return 0;
	if (bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,
			  FDCTL_NPORT, 0, &ioh_ctl))
		return 0;

	/* reset */
	bus_space_write_1(iot, ioh, fdout, 0);
	delay(100);
	bus_space_write_1(iot, ioh, fdout, FDO_FRST);

	/* see if it can handle a command */
	if (out_fdc(iot, ioh, NE7CMD_SPECIFY) < 0)
		goto out;
	out_fdc(iot, ioh, 0xdf);
	out_fdc(iot, ioh, 2);

	rv = 1;
	ia->ia_iosize = FDC_NPORT;
	ia->ia_msize = 0;

 out:
	bus_space_unmap(iot, ioh, FDC_NPORT);
	bus_space_unmap(iot, ioh_ctl, FDCTL_NPORT);
	return rv;
}

void
fdcattach(struct device *parent, struct device *self, void *aux)
{
	struct fdc_softc *fdc = (void *)self;
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_space_handle_t ioh_ctl;
	struct isa_attach_args *ia = aux;

	iot = ia->ia_iot;

	/* Re-map the I/O space. */
	if (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh) ||
	    bus_space_map(iot, ia->ia_iobase + FDCTL_OFFSET,
			  FDCTL_NPORT, 0, &ioh_ctl))
		panic("fdcattach: couldn't map I/O ports");

	fdc->sc_iot = iot;
	fdc->sc_ioh = ioh;
	fdc->sc_ioh_ctl = ioh_ctl;

	fdc->sc_drq = ia->ia_drq;
	fdc->sc_state = DEVIDLE;
	TAILQ_INIT(&fdc->sc_link.fdlink.sc_drives);	/* XXX */

	printf("\n");

	fdc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_BIO, fdcintr, fdc, fdc->sc_dev.dv_xname);

	kthread_create_deferred(fdc_create_kthread, fdc);
}

void
fdc_create_kthread(void *arg)
{
	struct fdc_softc *sc = arg;
	if (kthread_create(fdcattach_deferred, arg, NULL, "fdcattach") != 0) {
		printf("%s: failed to create kernel thread, disabled\n",
                    sc->sc_dev.dv_xname);
	}
}

void
fdcattach_deferred(void *arg)
{
	struct fdc_softc *fdc = arg;
	struct fdc_attach_args fa;
	int type;

#if defined(__i386__) || defined(__amd64__)
	/*
	 * The NVRAM info only tells us about the first two disks on the
	 * `primary' floppy controller.
	 */
	if (fdc->sc_dev.dv_unit == 0)
		type = mc146818_read(NULL, NVRAM_DISKETTE); /* XXX softc */
	else
#endif
		type = -1;

	timeout_set(&fdc->fdcpseudointr_to, fdcpseudointr, fdc);

	/* physical limit: four drives per controller. */
	for (fa.fa_drive = 0; fa.fa_drive < 4; fa.fa_drive++) {
		fa.fa_flags = 0;
		fa.fa_type = 0;
#if NFD > 0
		if (type >= 0 && fa.fa_drive < 2)
			fa.fa_deftype = fd_nvtotype(fdc->sc_dev.dv_xname,
			    type, fa.fa_drive);
		else
#endif
			fa.fa_deftype = NULL;		/* unknown */
		(void)config_found(&fdc->sc_dev, (void *)&fa, fddprint);
	}
	kthread_exit(0);
}

/*
 * Print the location of a disk/tape drive (called just before attaching the
 * the drive).  If `fdc' is not NULL, the drive was found but was not
 * in the system config file; print the drive name as well.
 * Return QUIET (config_find ignores this if the device was configured) to
 * avoid printing `fdN not configured' messages.
 */
int
fddprint(void *aux, const char *fdc)
{
	register struct fdc_attach_args *fa = aux;

	if (!fdc)
		printf(" drive %d", fa->fa_drive);
	return QUIET;
}

int
fdcresult(struct fdc_softc *fdc)
{
	bus_space_tag_t iot = fdc->sc_iot;
	bus_space_handle_t ioh = fdc->sc_ioh;
	u_char i;
	int j = 100000, n = 0;

	for (; j; j--) {
		i = bus_space_read_1(iot, ioh, fdsts) &
		    (NE7_DIO | NE7_RQM | NE7_CB);
		if (i == NE7_RQM)
			return n;
		if (i == (NE7_DIO | NE7_RQM | NE7_CB)) {
			if (n >= sizeof(fdc->sc_status)) {
				log(LOG_ERR, "fdcresult: overrun\n");
				return -1;
			}
			fdc->sc_status[n++] =
			    bus_space_read_1(iot, ioh, fddata);
		}
		delay(10);
	}
	return -1;
}

int
out_fdc(bus_space_tag_t iot, bus_space_handle_t ioh, u_char x)
{
	int i = 100000;

	while ((bus_space_read_1(iot, ioh, fdsts) & NE7_DIO) && i-- > 0);
	if (i <= 0)
		return -1;
	while ((bus_space_read_1(iot, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);
	if (i <= 0)
		return -1;
	bus_space_write_1(iot, ioh, fddata, x);
	return 0;
}

void
fdcstart(struct fdc_softc *fdc)
{

#ifdef DIAGNOSTIC
	/* only got here if controller's drive queue was inactive; should
	   be in idle state */
	if (fdc->sc_state != DEVIDLE) {
		printf("fdcstart: not idle\n");
		return;
	}
#endif
	(void) fdcintr(fdc);
}

void
fdcstatus(struct device *dv, int n, char *s)
{
	struct fdc_softc *fdc = (void *)dv->dv_parent;

	if (n == 0) {
		out_fdc(fdc->sc_iot, fdc->sc_ioh, NE7CMD_SENSEI);
		(void) fdcresult(fdc);
		n = 2;
	}

	printf("%s: %s", dv->dv_xname, s);

	switch (n) {
	case 0:
		printf("\n");
		break;
	case 2:
		printf(" (st0 %b cyl %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1]);
		break;
	case 7:
		printf(" (st0 %b st1 %b st2 %b cyl %d head %d sec %d)\n",
		    fdc->sc_status[0], NE7_ST0BITS,
		    fdc->sc_status[1], NE7_ST1BITS,
		    fdc->sc_status[2], NE7_ST2BITS,
		    fdc->sc_status[3], fdc->sc_status[4], fdc->sc_status[5]);
		break;
#ifdef DIAGNOSTIC
	default:
		printf("\nfdcstatus: weird size");
		break;
#endif
	}
}

void
fdcpseudointr(void *arg)
{
	int s;

	/* Just ensure it has the right spl. */
	s = splbio();
	(void) fdcintr(arg);
	splx(s);
}

int
fdcintr(void *arg)
{
#if NFD > 0
	struct fdc_softc *fdc = arg;
	extern int fdintr(struct fdc_softc *);

	/* Will switch on device type, shortly. */
	return (fdintr(fdc));
#else
	printf("fdcintr: got interrupt, but no devices!\n");
	return (1);
#endif
}
@


1.21
log
@fdc: defer probing of floppy drives

Defer probing of the drives to a kthread. This avoids several seconds of
delay() during boot. However, drives may now appear only after init has
started. But this does not affect installs from floppy. In that case the root
ramdisk is linked into the kernel and loaded by the boot loader.

Approach suggested by deraadt@@, tested by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.20 2015/03/14 03:38:47 jsg Exp $	*/
d173 5
a177 1
	kthread_create(fdcattach_deferred, arg, NULL, "fdcattach");
@


1.20
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.19 2011/07/04 05:41:48 matthew Exp $	*/
d60 1
d83 2
a144 2
	struct fdc_attach_args fa;
	int type;
d167 16
d207 1
a207 1
		(void)config_found(self, (void *)&fa, fddprint);
d209 1
@


1.19
log
@Convert to ANSI.

ok md5
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.18 2010/11/18 21:13:19 miod Exp $	*/
a67 1
#include <dev/isa/isadmavar.h>
@


1.18
log
@Do not #include <sys/dkstat.h> if you don't need anything from it.
ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.17 2005/09/19 01:28:04 deraadt Exp $	*/
d96 1
a96 3
fdcprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d136 1
a136 3
fdcattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d203 1
a203 3
fddprint(aux, fdc)
	void *aux;
	const char *fdc;
d213 1
a213 2
fdcresult(fdc)
	struct fdc_softc *fdc;
d239 1
a239 4
out_fdc(iot, ioh, x)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	u_char x;
d254 1
a254 2
fdcstart(fdc)
	struct fdc_softc *fdc;
d269 1
a269 4
fdcstatus(dv, n, s)
	struct device *dv;
	int n;
	char *s;
d306 1
a306 2
fdcpseudointr(arg)
	void *arg;
d317 1
a317 2
fdcintr(arg)
	void *arg;
@


1.17
log
@floppy support; form@@openbsd.ru
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.16 2003/06/02 23:28:02 millert Exp $	*/
a51 1
#include <sys/dkstat.h>
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.15 2002/03/14 01:26:56 millert Exp $	*/
d72 1
a72 1
#if defined(i386)
d172 1
a172 1
#if defined(i386)
@


1.15
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.14 2001/03/06 13:55:02 ho Exp $	*/
d26 1
a26 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@Convert to new timeout API. mickey@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.13 2000/07/18 01:28:12 deraadt Exp $	*/
d86 2
a87 2
int fdcprobe __P((struct device *, void *, void *));
void fdcattach __P((struct device *, struct device *, void *));
d97 2
a98 2
int fddprint __P((void *, const char *));
int fdcintr __P((void *));
d342 1
a342 1
	extern int fdintr __P((struct fdc_softc *));
@


1.14.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.14 2001/03/06 13:55:02 ho Exp $	*/
d86 2
a87 2
int fdcprobe(struct device *, void *, void *);
void fdcattach(struct device *, struct device *, void *);
d97 2
a98 2
int fddprint(void *, const char *);
int fdcintr(void *);
d342 1
a342 1
	extern int fdintr(struct fdc_softc *);
@


1.13
log
@be a bit more silent during fdc timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.12 1999/01/07 06:14:48 niklas Exp $	*/
d64 1
d186 2
@


1.12
log
@Die, NEWCONFIG
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.11 1998/08/08 23:01:15 downsj Exp $	*/
a243 1
	log(LOG_ERR, "fdcresult: timeout\n");
@


1.12.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.14 2001/03/06 13:55:02 ho Exp $	*/
a63 1
#include <sys/timeout.h>
a185 2
	timeout_set(&fdc->fdcpseudointr_to, fdcpseudointr, fdc);

d244 1
@


1.12.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d86 2
a87 2
int fdcprobe(struct device *, void *, void *);
void fdcattach(struct device *, struct device *, void *);
d97 2
a98 2
int fddprint(void *, const char *);
int fdcintr(void *);
d342 1
a342 1
	extern int fdintr(struct fdc_softc *);
@


1.12.6.3
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.12.6.2 2002/03/28 12:11:35 niklas Exp $	*/
d26 5
a30 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.11
log
@Split ioh allocations so that the devices no longer overlap.
Also disable the diag return check in wdc.c for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.10 1998/08/08 22:39:10 millert Exp $	*/
a85 3
#ifdef NEWCONFIG
void fdcforceintr __P((void *));
#endif
a112 5
#ifdef NEWCONFIG
	if (ia->ia_iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
		return 0;
#endif

a130 13
#ifdef NEWCONFIG
	if (ia->ia_irq == IRQUNK) {
		ia->ia_irq = isa_discoverintr(fdcforceintr, aux);
		if (ia->ia_irq == IRQNONE)
			goto out;

		/* reset it again */
		bus_space_write_1(iot, ioh, fdout, 0);
		delay(100);
		bus_space_write_1(iot, ioh, fdout, FDO_FRST);
	}
#endif

a140 20
#ifdef NEWCONFIG
/*
 * XXX This is broken, and needs fixing.  In general, the interface needs
 * XXX to change.
 */
void
fdcforceintr(aux)
	void *aux;
{
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;

	/* the motor is off; this should generate an error with or
	   without a disk drive present */
	out_fdc(iot, ioh, NE7CMD_SEEK);
	out_fdc(iot, ioh, 0);
	out_fdc(iot, ioh, 0);
}
#endif

a171 4
#ifdef NEWCONFIG
	at_setup_dmachan(fdc->sc_drq, FDC_MAXIOSIZE);
	isa_establish(&fdc->sc_id, &fdc->sc_dev);
#endif
@


1.10
log
@compile when fd is not listed in config file; andrew@@creep.net
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.9 1996/11/30 09:34:42 downsj Exp $	*/
d110 1
d124 3
d158 1
d190 1
d198 3
a200 1
	if (bus_space_map(iot, ia->ia_iobase, FDC_NPORT, 0, &ioh))
d205 1
@


1.9
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.8 1996/11/29 22:54:55 niklas Exp $	*/
d374 1
a375 2

#if NFD > 0
d382 1
@


1.8
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.7 1996/11/23 21:46:40 kstailey Exp $	*/
d275 2
a276 1
			fdc->sc_status[n++] = bus_space_read_1(iot, ioh, fddata);
d278 1
@


1.7
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.6 1996/11/12 20:30:32 niklas Exp $	*/
d66 1
a66 1
#include <machine/bus.old.h>
d108 2
a109 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d112 1
a112 1
	bc = ia->ia_bc;
d115 5
d121 1
a121 1
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
d125 1
a125 1
	bus_io_write_1(bc, ioh, fdout, 0);
d127 1
a127 1
	bus_io_write_1(bc, ioh, fdout, FDO_FRST);
d130 1
a130 1
	if (out_fdc(bc, ioh, NE7CMD_SPECIFY) < 0)
d132 2
a133 2
	out_fdc(bc, ioh, 0xdf);
	out_fdc(bc, ioh, 2);
a135 3
	if (ia->ia_iobase == IOBASEUNK || ia->ia_drq == DRQUNK)
		return 0;

d142 1
a142 1
		bus_io_write_1(bc, ioh, fdout, 0);
d144 1
a144 1
		bus_io_write_1(bc, ioh, fdout, FDO_FRST);
d153 1
a153 1
	bus_io_unmap(bc, ioh, FDC_NPORT);
d171 3
a173 3
	out_fdc(bc, ioh, NE7CMD_SEEK);
	out_fdc(bc, ioh, 0);
	out_fdc(bc, ioh, 0);
d183 2
a184 2
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d189 1
a189 1
	bc = ia->ia_bc;
d192 1
a192 1
	if (bus_io_map(bc, ia->ia_iobase, FDC_NPORT, &ioh))
d195 1
a195 1
	fdc->sc_bc = bc;
d260 2
a261 2
	bus_chipset_tag_t bc = fdc->sc_bc;
	bus_io_handle_t ioh = fdc->sc_ioh;
d266 1
a266 1
		i = bus_io_read_1(bc, ioh, fdsts) &
d275 1
a275 1
			fdc->sc_status[n++] = bus_io_read_1(bc, ioh, fddata);
d283 3
a285 3
out_fdc(bc, ioh, x)
	bus_chipset_tag_t bc;
	bus_io_handle_t ioh;
d290 1
a290 1
	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_DIO) && i-- > 0);
d293 1
a293 1
	while ((bus_io_read_1(bc, ioh, fdsts) & NE7_RQM) == 0 && i-- > 0);
d296 1
a296 1
	bus_io_write_1(bc, ioh, fddata, x);
d325 1
a325 1
		out_fdc(fdc->sc_bc, fdc->sc_ioh, NE7CMD_SENSEI);
@


1.6
log
@s/bus.h/bus.old.h/ to make the transit to the bus_space bus.h an easy road
possibly taken in small steps
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.5 1996/10/28 00:06:21 downsj Exp $	*/
d99 1
a99 1
int fddprint __P((void *, char *));
d245 1
a245 1
	char *fdc;
@


1.5
log
@Merge in old/latest code.  Untested support for 2.88mb floppy drives.
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.4 1996/10/26 08:07:26 downsj Exp $	*/
d66 1
a66 1
#include <machine/bus.h>
@


1.4
log
@more move changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.3 1996/10/26 06:22:38 downsj Exp $	*/
d198 1
a198 1
	TAILQ_INIT(&fdc->sc_drives);
d223 1
d261 1
a261 2
	int j = 100000,
	    n = 0;
@


1.3
log
@move related trivial changes
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.2 1996/10/16 12:46:25 deraadt Exp $	*/
d209 1
d217 1
@


1.2
log
@the Wall thing, you know
@
text
@d1 1
a1 1
/*	$OpenBSD: fdc.c,v 1.1 1996/09/01 20:58:26 downsj Exp $	*/
d73 1
a73 1
#include <i386/isa/fdreg.h>
d75 1
d78 1
d80 1
a80 1
#include <i386/isa/fdlink.h>
@


1.1
log
@initial commit of split fdc/fd drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: fd.c,v 1.20 1996/08/29 18:03:27 downsj Exp $	*/
d369 2
@
