head	1.34;
access;
symbols
	OPENBSD_6_2_BASE:1.34
	OPENBSD_6_1:1.34.0.10
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.6
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.34.0.4
	OPENBSD_5_8_BASE:1.34
	OPENBSD_5_7:1.33.0.4
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.31.0.26
	OPENBSD_5_5_BASE:1.31
	OPENBSD_5_4:1.31.0.22
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.20
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.18
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.16
	OPENBSD_5_0:1.31.0.14
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.31.0.12
	OPENBSD_4_9_BASE:1.31
	OPENBSD_4_8:1.31.0.10
	OPENBSD_4_8_BASE:1.31
	OPENBSD_4_7:1.31.0.6
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.31.0.8
	OPENBSD_4_6_BASE:1.31
	OPENBSD_4_5:1.31.0.4
	OPENBSD_4_5_BASE:1.31
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.30.0.8
	OPENBSD_4_3_BASE:1.30
	OPENBSD_4_2:1.30.0.6
	OPENBSD_4_2_BASE:1.30
	OPENBSD_4_1:1.30.0.4
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.30.0.2
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.27.0.8
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.6
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.27
	SMP_SYNC_B:1.27
	OPENBSD_3_5:1.27.0.2
	OPENBSD_3_5_BASE:1.27
	OPENBSD_3_4:1.26.0.8
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.26
	OPENBSD_3_3:1.26.0.6
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.26.0.4
	OPENBSD_3_2_BASE:1.26
	OPENBSD_3_1:1.26.0.2
	OPENBSD_3_1_BASE:1.26
	UBC_SYNC_B:1.26
	UBC:1.25.0.2
	UBC_BASE:1.25
	OPENBSD_3_0:1.22.0.14
	OPENBSD_3_0_BASE:1.22
	OPENBSD_2_9_BASE:1.22
	OPENBSD_2_9:1.22.0.12
	OPENBSD_2_8:1.22.0.10
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.22.0.8
	OPENBSD_2_7_BASE:1.22
	SMP:1.22.0.6
	SMP_BASE:1.22
	kame_19991208:1.22
	OPENBSD_2_6:1.22.0.4
	OPENBSD_2_6_BASE:1.22
	OPENBSD_2_5:1.22.0.2
	OPENBSD_2_5_BASE:1.22
	OPENBSD_2_4:1.19.0.4
	OPENBSD_2_4_BASE:1.19
	OPENBSD_2_3:1.19.0.2
	OPENBSD_2_3_BASE:1.19
	OPENBSD_2_2:1.13.0.4
	OPENBSD_2_2_BASE:1.13
	OPENBSD_2_1:1.13.0.2
	OPENBSD_2_1_BASE:1.13
	NIKLAS:1.11.0.2
	OPENBSD_2_0:1.7.0.2
	OPENBSD_2_0_BASE:1.7
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.33;
commitid	p4LJxGKbi0BU2cG6;

1.33
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.32;
commitid	uzzBR7hz9ncd4O6G;

1.32
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.31;
commitid	I19imNlAX05zJOED;

1.31
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2006.04.27.15.17.19;	author mickey;	state Exp;
branches;
next	1.29;

1.29
date	2005.11.23.10.00.12;	author mpf;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.21.14.25.09;	author mickey;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.13.22.09.40;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.25;

1.25
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2001.11.05.17.25.58;	author art;	state Exp;
branches;
next	1.23;

1.23
date	2001.10.31.11.00.24;	author art;	state Exp;
branches;
next	1.22;

1.22
date	99.01.11.01.49.00;	author millert;	state Exp;
branches
	1.22.6.1;
next	1.21;

1.21
date	98.11.20.16.04.01;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	98.11.20.15.57.20;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	98.03.02.07.02.08;	author todd;	state Exp;
branches;
next	1.18;

1.18
date	98.01.21.14.17.13;	author niklas;	state Exp;
branches;
next	1.17;

1.17
date	98.01.20.18.40.29;	author niklas;	state Exp;
branches;
next	1.16;

1.16
date	97.12.25.12.06.47;	author downsj;	state Exp;
branches;
next	1.15;

1.15
date	97.12.21.14.41.23;	author downsj;	state Exp;
branches;
next	1.14;

1.14
date	97.11.04.10.32.51;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	96.12.12.00.21.59;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	96.12.11.22.38.06;	author niklas;	state Exp;
branches;
next	1.11;

1.11
date	96.12.11.12.57.31;	author niklas;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	96.11.29.22.55.01;	author niklas;	state Exp;
branches;
next	1.9;

1.9
date	96.11.23.21.46.41;	author kstailey;	state Exp;
branches;
next	1.8;

1.8
date	96.10.16.12.32.36;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.06.16.10.31.27;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.05.07.07.37.10;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	96.04.22.20.03.05;	author hannken;	state Exp;
branches;
next	1.4;

1.4
date	96.04.21.22.24.14;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	96.04.18.23.47.41;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	95.11.28.16.15.44;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches;
next	;

1.11.2.1
date	96.12.17.15.05.30;	author niklas;	state Exp;
branches;
next	;

1.22.6.1
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.22.6.2;

1.22.6.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.22.6.3;

1.22.6.3
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	;

1.25.2.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: isadma.c,v 1.33 2014/09/14 14:17:25 jsg Exp $	*/
/*	$NetBSD: isadma.c,v 1.32 1997/09/05 01:48:33 thorpej Exp $	*/

/*-
 * Copyright (c) 1997 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Device driver for the ISA on-board DMA controller.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>

#include <uvm/uvm_extern.h>

#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <dev/isa/isadmareg.h>

#ifdef __ISADMA_COMPAT
/* XXX ugly, but will go away soon... */
struct device *isa_dev;

bus_dmamap_t isadma_dmam[8];
#endif

/* Used by isa_malloc() */
#include <sys/malloc.h>
struct isa_mem {
	struct device *isadev;
	int chan;
	bus_size_t size;
	bus_addr_t addr;
	caddr_t kva;
	struct isa_mem *next;
} *isa_mem_head = 0;

/*
 * High byte of DMA address is stored in this DMAPG register for
 * the Nth DMA channel.
 */
static int dmapageport[2][4] = {
	{0x7, 0x3, 0x1, 0x2},
	{0xf, 0xb, 0x9, 0xa}
};

static u_int8_t dmamode[4] = {
	DMA37MD_READ | DMA37MD_SINGLE,
	DMA37MD_WRITE | DMA37MD_SINGLE,
	DMA37MD_READ | DMA37MD_SINGLE | DMA37MD_LOOP,
	DMA37MD_WRITE | DMA37MD_SINGLE | DMA37MD_LOOP
};

int isadmamatch(struct device *, void *, void *);
void isadmaattach(struct device *, struct device *, void *);

struct cfattach isadma_ca = {
	sizeof(struct device), isadmamatch, isadmaattach
};

struct cfdriver isadma_cd = {
	NULL, "isadma", DV_DULL, 1
};

int
isadmamatch(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct isa_attach_args *ia = aux;

	/* Sure we exist */
	ia->ia_iosize = 0;
	return (1);
}

void
isadmaattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
#ifdef __ISADMA_COMPAT
	int i, sz;
	struct isa_softc *sc = (struct isa_softc *)parent;

	/* XXX ugly, but will go away soon... */
	isa_dev = parent;

	for (i = 0; i < 8; i++) {
		sz = (i & 4) ? 1 << 17 : 1 << 16;
		if ((bus_dmamap_create(sc->sc_dmat, sz, 1, sz, sz,
		    BUS_DMA_24BIT|BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW,
		    &isadma_dmam[i])) != 0)
			panic("isadmaattach: can not create DMA map");
	}
#endif

	/* XXX I'd like to map the DMA ports here, see isa.c why not... */

	printf("\n");
}

static inline void isa_dmaunmask(struct isa_softc *, int);
static inline void isa_dmamask(struct isa_softc *, int);

static inline void
isa_dmaunmask(sc, chan)
	struct isa_softc *sc;
	int chan;
{
	int ochan = chan & 3;

	/* set dma channel mode, and set dma channel mode */
	if ((chan & 4) == 0)
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h,
		    DMA1_SMSK, ochan | DMA37SM_CLEAR);
	else
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h,
		    DMA2_SMSK, ochan | DMA37SM_CLEAR);
}

static inline void
isa_dmamask(sc, chan)
	struct isa_softc *sc;
	int chan;
{
	int ochan = chan & 3;

	/* set dma channel mode, and set dma channel mode */
	if ((chan & 4) == 0) {
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h,
		    DMA1_SMSK, ochan | DMA37SM_SET);
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h,
		    DMA1_FFC, 0);
	} else {
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h,
		    DMA2_SMSK, ochan | DMA37SM_SET);
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h,
		    DMA2_FFC, 0);
	}
}

/*
 * isa_dmacascade(): program 8237 DMA controller channel to accept
 * external dma control by a board.
 */
void
isa_dmacascade(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	int ochan = chan & 3;

	if (chan < 0 || chan > 7) {
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	if (ISA_DRQ_ISFREE(sc, chan) == 0) {
		printf("%s: DRQ %d is not free\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	ISA_DRQ_ALLOC(sc, chan);

	/* set dma channel mode, and set dma channel mode */
	if ((chan & 4) == 0)
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h,
		    DMA1_MODE, ochan | DMA37MD_CASCADE);
	else
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h,
		    DMA2_MODE, ochan | DMA37MD_CASCADE);

	isa_dmaunmask(sc, chan);
	return;

 lose:
	panic("isa_dmacascade");
}

int
isa_dmamap_create(isadev, chan, size, flags)
	struct device *isadev;
	int chan;
	bus_size_t size;
	int flags;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_size_t maxsize;

	if (chan < 0 || chan > 7) {
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	if (chan & 4)
		maxsize = (1 << 17);
	else
		maxsize = (1 << 16);

	if (size > maxsize)
		return (EINVAL);

	if (ISA_DRQ_ISFREE(sc, chan) == 0) {
		printf("%s: drq %d is not free\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	ISA_DRQ_ALLOC(sc, chan);

	return (bus_dmamap_create(sc->sc_dmat, size, 1, size, maxsize,
	    flags, &sc->sc_dmamaps[chan]));

 lose:
	panic("isa_dmamap_create");
}

void
isa_dmamap_destroy(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;

	if (chan < 0 || chan > 7) {
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	if (ISA_DRQ_ISFREE(sc, chan)) {
		printf("%s: drq %d is already free\n",
		    sc->sc_dev.dv_xname, chan);
		goto lose;
	}

	ISA_DRQ_FREE(sc, chan);

	bus_dmamap_destroy(sc->sc_dmat, sc->sc_dmamaps[chan]);
	return;

 lose:
	panic("isa_dmamap_destroy");
}

/*
 * isa_dmastart(): program 8237 DMA controller channel and set it
 * in motion.
 */
int
isa_dmastart(isadev, chan, addr, nbytes, p, flags, busdmaflags)
	struct device *isadev;
	int chan;
	void *addr;
	bus_size_t nbytes;
	struct proc *p;
	int flags;
	int busdmaflags;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dmamap_t dmam;
	bus_addr_t dmaaddr;
	int waport;
	int ochan = chan & 3;
	int error;
#ifdef __ISADMA_COMPAT
	int compat = busdmaflags & BUS_DMA_BUS1;

	busdmaflags &= ~BUS_DMA_BUS1;
#endif /* __ISADMA_COMPAT */

	if (chan < 0 || chan > 7) {
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		goto lose;
	}

#ifdef ISADMA_DEBUG
	printf("isa_dmastart: drq %d, addr %p, nbytes 0x%lx, p %p, "
	    "flags 0x%x, dmaflags 0x%x\n",
	    chan, addr, nbytes, p, flags, busdmaflags);
#endif

	if (chan & 4) {
		if (nbytes > (1 << 17) || nbytes & 1 || (u_long)addr & 1) {
			printf("%s: drq %d, nbytes 0x%lx, addr %p\n",
			    sc->sc_dev.dv_xname, chan, nbytes, addr);
			goto lose;
		}
	} else {
		if (nbytes > (1 << 16)) {
			printf("%s: drq %d, nbytes 0x%lx\n",
			    sc->sc_dev.dv_xname, chan, nbytes);
			goto lose;
		}
	}

	dmam = sc->sc_dmamaps[chan];
	if (dmam == NULL) {
#ifdef __ISADMA_COMPAT
		if (compat)
			dmam = sc->sc_dmamaps[chan] = isadma_dmam[chan];
		else
#endif /* __ISADMA_COMPAT */
		panic("isa_dmastart: no DMA map for chan %d", chan);
	}

	error = bus_dmamap_load(sc->sc_dmat, dmam, addr, nbytes, p,
	    busdmaflags);
	if (error)
		return (error);

#ifdef ISADMA_DEBUG
	__asm(".globl isa_dmastart_afterload ; isa_dmastart_afterload:");
#endif

	if (flags & DMAMODE_READ) {
		bus_dmamap_sync(sc->sc_dmat, dmam, 0, dmam->dm_mapsize,
		    BUS_DMASYNC_PREREAD);
		sc->sc_dmareads |= (1 << chan);
	} else {
		bus_dmamap_sync(sc->sc_dmat, dmam, 0, dmam->dm_mapsize,
		    BUS_DMASYNC_PREWRITE);
		sc->sc_dmareads &= ~(1 << chan);
	}

	dmaaddr = dmam->dm_segs[0].ds_addr;

#ifdef ISADMA_DEBUG
	printf("     dmaaddr 0x%lx\n", dmaaddr);

	__asm(".globl isa_dmastart_aftersync ; isa_dmastart_aftersync:");
#endif

	sc->sc_dmalength[chan] = nbytes;

	isa_dmamask(sc, chan);
	sc->sc_dmafinished &= ~(1 << chan);

	if ((chan & 4) == 0) {
		/* set dma channel mode */
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h, DMA1_MODE,
		    ochan | dmamode[flags]);

		/* send start address */
		waport = DMA1_CHN(ochan);
		bus_space_write_1(sc->sc_iot, sc->sc_dmapgh,
		    dmapageport[0][ochan], (dmaaddr >> 16) & 0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,
		    dmaaddr & 0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport,
		    (dmaaddr >> 8) & 0xff);

		/* send count */
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,
		    (--nbytes) & 0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_dma1h, waport + 1,
		    (nbytes >> 8) & 0xff);
	} else {
		/* set dma channel mode */
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h, DMA2_MODE,
		    ochan | dmamode[flags]);

		/* send start address */
		waport = DMA2_CHN(ochan);
		bus_space_write_1(sc->sc_iot, sc->sc_dmapgh,
		    dmapageport[1][ochan], (dmaaddr >> 16) & 0xff);
		dmaaddr >>= 1;
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,
		    dmaaddr & 0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport,
		    (dmaaddr >> 8) & 0xff);

		/* send count */
		nbytes >>= 1;
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,
		    (--nbytes) & 0xff);
		bus_space_write_1(sc->sc_iot, sc->sc_dma2h, waport + 2,
		    (nbytes >> 8) & 0xff);
	}

	isa_dmaunmask(sc, chan);
	return (0);

 lose:
	panic("isa_dmastart");
}

void
isa_dmaabort(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;

	if (chan < 0 || chan > 7) {
		panic("isa_dmaabort: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	isa_dmamask(sc, chan);
	bus_dmamap_unload(sc->sc_dmat, sc->sc_dmamaps[chan]);
	sc->sc_dmareads &= ~(1 << chan);
}

bus_size_t
isa_dmacount(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	int waport;
	bus_size_t nbytes;
	int ochan = chan & 3;

	if (chan < 0 || chan > 7) {
		panic("isa_dmacount: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	isa_dmamask(sc, chan);

	/*
	 * We have to shift the byte count by 1.  If we're in auto-initialize
	 * mode, the count may have wrapped around to the initial value.  We
	 * can't use the TC bit to check for this case, so instead we compare
	 * against the original byte count.
	 * If we're not in auto-initialize mode, then the count will wrap to
	 * -1, so we also handle that case.
	 */
	if ((chan & 4) == 0) {
		waport = DMA1_CHN(ochan);
		nbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma1h,
		    waport + 1) + 1;
		nbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma1h,
		    waport + 1) << 8;
		nbytes &= 0xffff;
	} else {
		waport = DMA2_CHN(ochan);
		nbytes = bus_space_read_1(sc->sc_iot, sc->sc_dma2h,
		    waport + 2) + 1;
		nbytes += bus_space_read_1(sc->sc_iot, sc->sc_dma2h,
		    waport + 2) << 8;
		nbytes <<= 1;
		nbytes &= 0x1ffff;
	}

	if (nbytes == sc->sc_dmalength[chan])
		nbytes = 0;

	isa_dmaunmask(sc, chan);
	return (nbytes);
}

int
isa_dmafinished(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;

	if (chan < 0 || chan > 7) {
		panic("isa_dmafinished: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	/* check that the terminal count was reached */
	if ((chan & 4) == 0)
		sc->sc_dmafinished |= bus_space_read_1(sc->sc_iot,
		    sc->sc_dma1h, DMA1_SR) & 0x0f;
	else
		sc->sc_dmafinished |= (bus_space_read_1(sc->sc_iot,
		    sc->sc_dma2h, DMA2_SR) & 0x0f) << 4;

	return ((sc->sc_dmafinished & (1 << chan)) != 0);
}

void
isa_dmadone(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dmamap_t dmam;

	if (chan < 0 || chan > 7) {
		panic("isa_dmadone: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	dmam = sc->sc_dmamaps[chan];

	isa_dmamask(sc, chan);

	if (isa_dmafinished(isadev, chan) == 0)
		printf("%s: isa_dmadone: channel %d not finished\n",
		    sc->sc_dev.dv_xname, chan);

	bus_dmamap_sync(sc->sc_dmat, dmam, 0, dmam->dm_mapsize,
	    (sc->sc_dmareads & (1 << chan)) ? BUS_DMASYNC_POSTREAD :
	    BUS_DMASYNC_POSTWRITE);

	bus_dmamap_unload(sc->sc_dmat, dmam);
	sc->sc_dmareads &= ~(1 << chan);
}

int
isa_dmamem_alloc(isadev, chan, size, addrp, flags)
	struct device *isadev;
	int chan;
	bus_size_t size;
	bus_addr_t *addrp;
	int flags;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dma_segment_t seg;
	int error, boundary, rsegs;

	if (chan < 0 || chan > 7) {
		panic("isa_dmamem_alloc: %s: bogus drq %d",
		    sc->sc_dev.dv_xname, chan);
	}

	boundary = (chan & 4) ? (1 << 17) : (1 << 16);

	size = round_page(size);

	error = bus_dmamem_alloc(sc->sc_dmat, size, NBPG, boundary,
	    &seg, 1, &rsegs, flags);
	if (error)
		return (error);

	*addrp = seg.ds_addr;
	return (0);
}

void
isa_dmamem_free(isadev, chan, addr, size)
	struct device *isadev;
	int chan;
	bus_addr_t addr;
	bus_size_t size;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dma_segment_t seg;

	if (chan < 0 || chan > 7) {
		panic("isa_dmamem_free: %s: bogus drq %d",
		    sc->sc_dev.dv_xname, chan);
	}

	seg.ds_addr = addr;
	seg.ds_len = size;

	bus_dmamem_free(sc->sc_dmat, &seg, 1);
}

int
isa_dmamem_map(isadev, chan, addr, size, kvap, flags)
	struct device *isadev;
	int chan;
	bus_addr_t addr;
	bus_size_t size;
	caddr_t *kvap;
	int flags;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dma_segment_t seg;

	if (chan < 0 || chan > 7) {
		panic("isa_dmamem_map: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	seg.ds_addr = addr;
	seg.ds_len = size;

	return (bus_dmamem_map(sc->sc_dmat, &seg, 1, size, kvap, flags));
}

void
isa_dmamem_unmap(isadev, chan, kva, size)
	struct device *isadev;
	int chan;
	caddr_t kva;
	size_t size;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;

	if (chan < 0 || chan > 7) {
		panic("isa_dmamem_unmap: %s: bogus drq %d",
		    sc->sc_dev.dv_xname, chan);
	}

	bus_dmamem_unmap(sc->sc_dmat, kva, size);
}

int
isa_dmamem_mmap(isadev, chan, addr, size, off, prot, flags)
	struct device *isadev;
	int chan;
	bus_addr_t addr;
	bus_size_t size;
	int off, prot, flags;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	bus_dma_segment_t seg;

	if (chan < 0 || chan > 7) {
		panic("isa_dmamem_mmap: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}

	if (off < 0)
		return (-1);

	seg.ds_addr = addr;
	seg.ds_len = size;

	return (bus_dmamem_mmap(sc->sc_dmat, &seg, 1, off, prot, flags));
}

int
isa_drq_isfree(isadev, chan)
	struct device *isadev;
	int chan;
{
	struct isa_softc *sc = (struct isa_softc *)isadev;
	if (chan < 0 || chan > 7) {
		panic("isa_drq_isfree: %s: bogus drq %d", sc->sc_dev.dv_xname,
		    chan);
	}
	return ISA_DRQ_ISFREE(sc, chan);
}

void *
isa_malloc(isadev, chan, size, pool, flags)
	struct device *isadev;
	int chan;
	size_t size;
	int pool;
	int flags;
{
	bus_addr_t addr;
	caddr_t kva;
	int bflags;
	struct isa_mem *m;

	bflags = flags & M_NOWAIT ? BUS_DMA_NOWAIT : BUS_DMA_WAITOK;

	if (isa_dmamem_alloc(isadev, chan, size, &addr, bflags))
		return 0;
	if (isa_dmamem_map(isadev, chan, addr, size, &kva, bflags)) {
		isa_dmamem_free(isadev, chan, addr, size);
		return 0;
	}
	m = malloc(sizeof(*m), pool, flags);
	if (m == 0) {
		isa_dmamem_unmap(isadev, chan, kva, size);
		isa_dmamem_free(isadev, chan, addr, size);
		return 0;
	}
	m->isadev = isadev;
	m->chan = chan;
	m->size = size;
	m->addr = addr;
	m->kva = kva;
	m->next = isa_mem_head;
	isa_mem_head = m;
	return (void *)kva;
}

void
isa_free(addr, pool)
	void *addr;
	int pool;
{
	struct isa_mem **mp, *m;
	caddr_t kva = (caddr_t)addr;

	for(mp = &isa_mem_head; *mp && (*mp)->kva != kva; mp = &(*mp)->next)
		;
	m = *mp;
	if (!m) {
		printf("isa_free: freeing unallocated memory\n");
		return;
	}
	*mp = m->next;
	isa_dmamem_unmap(m->isadev, m->chan, kva, m->size);
	isa_dmamem_free(m->isadev, m->chan, m->addr, m->size);
	free(m, pool, 0);
}

paddr_t
isa_mappage(mem, off, prot)
	void *mem;
	off_t off;
	int prot;
{
	struct isa_mem *m;

	for(m = isa_mem_head; m && m->kva != (caddr_t)mem; m = m->next)
		;
	if (!m) {
		printf("isa_mappage: mapping unallocated memory\n");
		return -1;
	}
	return (isa_dmamem_mmap(m->isadev, m->chan, m->addr, m->size, off,
	    prot, BUS_DMA_WAITOK));
}
@


1.33
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.32 2014/07/12 18:48:18 tedu Exp $	*/
a45 1
#include <dev/isa/isareg.h>
@


1.32
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.31 2008/06/26 05:42:16 ray Exp $	*/
a39 1
#include <sys/proc.h>
@


1.31
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.30 2006/04/27 15:17:19 mickey Exp $	*/
d722 1
a722 1
	free(m, pool);
@


1.30
log
@from PAE work:
add a BUS_DMA_24BIT flag to signify that dmamap being created
is for the isadma use (thus already backed up by the bounce
buffers). later also to be used for dmamem allocation.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.29 2005/11/23 10:00:12 mpf Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.29
log
@Correct malloc flag handling.
OK deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.28 2005/11/21 14:25:09 mickey Exp $	*/
d131 2
a132 1
		    BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW, &isadma_dmam[i])) != 0)
@


1.28
log
@some wacky indentation fixens
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.27 2004/01/13 22:09:40 deraadt Exp $	*/
d686 1
a686 1
	bflags = flags & M_WAITOK ? BUS_DMA_WAITOK : BUS_DMA_NOWAIT;
@


1.27
log
@spelling
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.26 2002/03/14 01:26:56 millert Exp $	*/
d355 2
a356 3
		bus_dmamap_sync(sc->sc_dmat, dmam, 0,
		dmam->dm_mapsize,
		BUS_DMASYNC_PREREAD);
d359 2
a360 3
		bus_dmamap_sync(sc->sc_dmat, dmam, 0,
		dmam->dm_mapsize,
		BUS_DMASYNC_PREWRITE);
d536 1
a536 2
	bus_dmamap_sync(sc->sc_dmat, dmam, 0,
	    dmam->dm_mapsize,
@


1.26
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.25 2001/11/06 19:53:19 miod Exp $	*/
d725 1
a725 1
		printf("isa_free: freeing unallocted memory\n");
d745 1
a745 1
		printf("isa_mappage: mapping unallocted memory\n");
@


1.25
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.24 2001/11/05 17:25:58 art Exp $	*/
d93 2
a94 2
int isadmamatch __P((struct device *, void *, void *));
void isadmaattach __P((struct device *, struct device *, void *));
d141 2
a142 2
static inline void isa_dmaunmask __P((struct isa_softc *, int));
static inline void isa_dmamask __P((struct isa_softc *, int));
@


1.25.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.25 2001/11/06 19:53:19 miod Exp $	*/
d93 2
a94 2
int isadmamatch(struct device *, void *, void *);
void isadmaattach(struct device *, struct device *, void *);
d141 2
a142 2
static inline void isa_dmaunmask(struct isa_softc *, int);
static inline void isa_dmamask(struct isa_softc *, int);
@


1.24
log
@Switch everything to the new bus_dmamap_sync API.
Most work by Wilbern Cobb <vedge@@csoft.org> with some fixes from me, mickey@@
and drahn@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.23 2001/10/31 11:00:24 art Exp $	*/
d50 1
a50 1
#include <vm/vm.h>
@


1.23
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.22 1999/01/11 01:49:00 millert Exp $	*/
d355 3
a357 1
		bus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREREAD);
d360 3
a362 1
		bus_dmamap_sync(sc->sc_dmat, dmam, BUS_DMASYNC_PREWRITE);
d538 2
a539 1
	bus_dmamap_sync(sc->sc_dmat, dmam,
@


1.22
log
@shave a few byes by combining a printf and panic that are consecutive
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.21 1998/11/20 16:04:01 deraadt Exp $	*/
d729 1
a729 1
int
d732 1
a732 1
	int off;
@


1.22.6.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d50 1
a50 1
#include <uvm/uvm_extern.h>
d355 1
a355 3
		bus_dmamap_sync(sc->sc_dmat, dmam, 0,
		dmam->dm_mapsize,
		BUS_DMASYNC_PREREAD);
d358 1
a358 3
		bus_dmamap_sync(sc->sc_dmat, dmam, 0,
		dmam->dm_mapsize,
		BUS_DMASYNC_PREWRITE);
d534 1
a534 2
	bus_dmamap_sync(sc->sc_dmat, dmam, 0,
	    dmam->dm_mapsize,
d729 1
a729 1
paddr_t
d732 1
a732 1
	off_t off;
@


1.22.6.2
log
@Merge in -current from about a week ago
@
text
@d93 2
a94 2
int isadmamatch(struct device *, void *, void *);
void isadmaattach(struct device *, struct device *, void *);
d141 2
a142 2
static inline void isa_dmaunmask(struct isa_softc *, int);
static inline void isa_dmamask(struct isa_softc *, int);
@


1.22.6.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d725 1
a725 1
		printf("isa_free: freeing unallocated memory\n");
d745 1
a745 1
		printf("isa_mappage: mapping unallocated memory\n");
@


1.21
log
@oops
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.20 1998/11/20 15:57:20 deraadt Exp $	*/
d342 1
a342 1
		panic("isa_dmastart: no DMA map for chan %d\n", chan);
d432 2
a433 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmaabort");
d452 2
a453 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmacount");
d498 2
a499 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmafinished");
d522 2
a523 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmadone");
d555 2
a556 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmamem_alloc");
d583 2
a584 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmamem_free");
d606 2
a607 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmamem_map");
d626 2
a627 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmamem_unmap");
d645 2
a646 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_dmamem_mmap");
d665 2
a666 2
		printf("%s: bogus drq %d\n", sc->sc_dev.dv_xname, chan);
		panic("isa_drq_isfree");
@


1.20
log
@careful off handling in mmap routines
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.19 1998/03/02 07:02:08 todd Exp $	*/
a586 3
	if (off < 0)
		return (-1);

d648 3
@


1.19
log
@Please GCC 2.8 -Wall
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.18 1998/01/21 14:17:13 niklas Exp $	*/
d586 3
@


1.18
log
@typo
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.17 1998/01/20 18:40:29 niklas Exp $	*/
d336 1
a336 1
	if (dmam == NULL)
d343 1
@


1.17
log
@Merge bus_dma support from NetBSD, mostly by Jason Thorpe.  Only i386 uses it
 so far, the other archs gets placeholders for now.  I wrote a compatibility
layer for OpenBSD's old isadma code so we can still use our old
driver sources.  They will however get changed to native bus_dma use,
on a case by case basis.   Oh yes, I almost forgot, I kept our notion
of isadma being a device so DMA-less ISA-busses still work
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.32 1997/09/05 01:48:33 thorpej Exp $	*/
d132 1
a132 1
			panic("isa_dmastart: can not create DMA map");
@


1.16
log
@Real DRQ usage tracking.
@
text
@d1 43
a43 2
/*	$OpenBSD: isadma.c,v 1.15 1997/12/21 14:41:23 downsj Exp $	*/
/*	$NetBSD: isadma.c,v 1.19 1996/04/29 20:03:26 christos Exp $	*/
d47 1
a48 5
#include <sys/file.h>
#include <sys/buf.h>
#include <sys/syslog.h>
#include <sys/malloc.h>
#include <sys/uio.h>
d52 1
a52 1
#include <machine/pio.h>
d59 6
a64 9
struct dma_info {
	int flags;
	int active;
	int inuse;
	int bounced;
	caddr_t addr;
	vm_size_t nbytes;
	struct isadma_seg phys[1];
};
d66 10
a75 2
static struct dma_info dma_info[8];
static u_int8_t dma_finished;
d77 4
a80 1
/* high byte of address is stored in this port for i-th dma channel */
d82 2
a83 2
	{0x87, 0x83, 0x81, 0x82},
	{0x8f, 0x8b, 0x89, 0x8a}
a94 1
int isadmaprint __P((void *, const char *));
d121 17
d141 40
d182 2
a183 2
 * Register a DMA channel's usage.  Usually called from a device driver
 * in open() or during it's initialization.
d185 3
a187 2
int
isadma_acquire(chan)
d190 2
a191 5
	struct dma_info *di;
#ifdef DIAGNOSTIC
	if (chan < 0 || chan > 7)
		panic("isadma_acquire: channel out of range");
#endif
d193 4
a196 1
	di = dma_info + chan;
d198 3
a200 3
	if (di->inuse) {
		log(LOG_ERR, "isadma_acquire: channel %d already in use\n", chan);
		return (EBUSY);
a201 1
	di->inuse = 1;
d203 15
a217 1
	return (0);
d220 3
a222 6
/*
 * Unregister a DMA channel's usage.  Usually called from a device driver
 * during close() or during it's shutdown.
 */
void
isadma_release(chan)
d224 2
d227 15
a241 6
	struct dma_info *di;
#ifdef DIAGNOSTIC
	if (chan < 0 || chan > 7)
		panic("isadma_release: channel out of range");
#endif
	di = dma_info + chan;
d243 3
a245 3
	if (!di->inuse) {
		log(LOG_ERR, "isadma_release: channel %d not in use\n", chan);
		return;
d248 1
a248 2
	if (di->active)
		isadma_abort(chan);
d250 5
a254 1
	di->inuse = 0;
a256 4
/*
 * isadma_cascade(): program 8237 DMA controller channel to accept
 * external dma control by a board.
 */
d258 2
a259 1
isadma_cascade(chan)
d262 6
a267 1
	struct dma_info *di;
d269 5
a273 5
#ifdef ISADMA_DEBUG
	if (chan < 0 || chan > 7)
		panic("isadma_cascade: impossible request"); 
#endif
	di = dma_info + chan;
d275 1
a275 6
	/* set dma channel mode, and set dma channel mode */
	if ((chan & 4) == 0) {
		outb(DMA1_MODE, chan | DMA37MD_CASCADE);
		outb(DMA1_SMSK, chan);
	} else {
		chan &= 3;
d277 2
a278 3
		outb(DMA2_MODE, chan | DMA37MD_CASCADE);
		outb(DMA2_SMSK, chan);
	}
d280 2
a281 3
	/* Mark it as in use, if needed.  XXX */
	if (!di->inuse)
		di->inuse = 1;
d285 2
a286 2
 * isadma_start(): program 8237 DMA controller channel, avoid page alignment
 * problems by using a bounce buffer.
d288 3
a290 4
void
isadma_start(addr, nbytes, chan, flags)
	caddr_t addr;
	vm_size_t nbytes;
d292 3
d296 1
d298 3
a300 1
	struct dma_info *di;
d302 12
a313 1
	int mflags;
d316 3
a318 6
	if (chan < 0 || chan > 7 ||
	    (((flags & DMAMODE_READ) != 0) + ((flags & DMAMODE_WRITE) != 0) +
	    ((flags & DMAMODE_LOOP) != 0) != 1) ||
	    ((chan & 4) ? (nbytes >= (1<<17) || nbytes & 1 || (u_int)addr & 1) :
	    (nbytes >= (1<<16))))
		panic("isadma_start: impossible request"); 
d321 12
a332 4
	di = dma_info+chan;
	if (di->active) {
		log(LOG_ERR,"isadma_start: old request active on %d\n",chan);
		isadma_abort(chan);
d335 13
a347 4
	di->flags = flags;
	di->active = 1;
	di->addr = addr;
	di->nbytes = nbytes;
d349 3
a351 2
	mflags = ISADMA_MAP_WAITOK | ISADMA_MAP_CONTIG;
	mflags |= (chan & 4) ? ISADMA_MAP_16BIT : ISADMA_MAP_8BIT;
d353 7
a359 2
	if (isadma_map(addr, nbytes, di->phys, mflags) != 1) {
		mflags |= ISADMA_MAP_BOUNCE;
d361 1
a361 2
		if (isadma_map(addr, nbytes, di->phys, mflags) != 1)
			panic("isadma_start: cannot map");
d363 2
a364 1
		di->bounced = 1;
d366 2
a367 2
		if ((flags & DMAMODE_READ) == 0)
			isadma_copytobuf(addr, nbytes, 1, di->phys);
d369 1
a369 4
		/* XXX Will this do what we want with DMAMODE_LOOP?  */
		if ((flags & DMAMODE_READ) == 0)
			isadma_copytobuf(addr, nbytes, 1, di->phys);
        }
d371 2
a372 1
	dma_finished &= ~(1 << chan);
d375 3
a377 7
		/*
		 * Program one of DMA channels 0..3.  These are
		 * byte mode channels.
		 */
		/* set dma channel mode, and reset address ff */
		outb(DMA1_MODE, chan | dmamode[flags]);
		outb(DMA1_FFC, 0);
d380 7
a386 4
		waport = DMA1_CHN(chan);
		outb(dmapageport[0][chan], di->phys[0].addr>>16);
		outb(waport, di->phys[0].addr);
		outb(waport, di->phys[0].addr>>8);
d389 4
a392 5
		outb(waport + 1, --nbytes);
		outb(waport + 1, nbytes>>8);

		/* unmask channel */
		outb(DMA1_SMSK, chan | DMA37SM_CLEAR);
d394 3
a396 7
		/*
		 * Program one of DMA channels 4..7.  These are
		 * word mode channels.
		 */
		/* set dma channel mode, and reset address ff */
		outb(DMA2_MODE, (chan & 3) | dmamode[flags]);
		outb(DMA2_FFC, 0);
d399 8
a406 4
		waport = DMA2_CHN(chan & 3);
		outb(dmapageport[1][chan & 3], di->phys[0].addr>>16);
		outb(waport, di->phys[0].addr>>1);
		outb(waport, di->phys[0].addr>>9);
d410 8
a417 2
		outb(waport + 2, --nbytes);
		outb(waport + 2, nbytes>>8);
d419 14
a432 2
		/* unmask channel */
		outb(DMA2_SMSK, (chan & 3) | DMA37SM_CLEAR);
d434 4
d440 3
a442 2
void
isadma_abort(chan)
d445 9
a453 1
	struct dma_info *di;
d455 1
a455 4
#ifdef ISADMA_DEBUG
	if (chan < 0 || chan > 7)
		panic("isadma_abort: impossible request");
#endif
d457 23
a479 4
	di = dma_info+chan;
	if (! di->active) {
		log(LOG_ERR,"isadma_abort: no request active on %d\n",chan);
		return;
d482 2
a483 5
	/* mask channel */
	if ((chan & 4) == 0)
		outb(DMA1_SMSK, DMA37SM_SET | chan);
	else
		outb(DMA2_SMSK, DMA37SM_SET | (chan & 3));
d485 2
a486 3
	isadma_unmap(di->addr, di->nbytes, 1, di->phys);
	di->active = 0;
	di->bounced = 0;
d490 2
a491 1
isadma_finished(chan)
d494 1
d496 4
a499 4
#ifdef ISADMA_DEBUG
	if (chan < 0 || chan > 7)
		panic("isadma_finished: impossible request");
#endif
d503 2
a504 1
		dma_finished |= inb(DMA1_SR) & 0x0f;
d506 26
a531 1
		dma_finished |= (inb(DMA2_SR) & 0x0f) << 4;
d533 36
a568 1
	return ((dma_finished & (1 << chan)) != 0);
d572 23
a594 1
isadma_done(chan)
d596 4
d601 2
a602 2
	struct dma_info *di;
	u_char tc;
d604 107
a710 4
#ifdef DIAGNOSTIC
	if (chan < 0 || chan > 7)
		panic("isadma_done: impossible request");
#endif
d712 5
a716 3
	di = dma_info+chan;
	if (! di->active) {
		log(LOG_ERR,"isadma_done: no request active on %d\n",chan);
d719 5
d725 7
a731 8
	/* check that the terminal count was reached */
	if ((chan & 4) == 0)
		tc = inb(DMA1_SR) & (1 << chan);
	else
		tc = inb(DMA2_SR) & (1 << (chan & 3));
	if (tc == 0)
		/* XXX probably should panic or something */
		log(LOG_ERR, "dma channel %d not finished\n", chan);
d733 8
a740 13
	/* mask channel */
	if ((chan & 4) == 0)
		outb(DMA1_SMSK, DMA37SM_SET | chan);
	else
		outb(DMA2_SMSK, DMA37SM_SET | (chan & 3));

	/* XXX Will this do what we want with DMAMODE_LOOP?  */
	if (di->bounced & (di->flags & DMAMODE_READ))
		isadma_copyfrombuf(di->addr, di->nbytes, 1, di->phys);

	isadma_unmap(di->addr, di->nbytes, 1, di->phys);
	di->active = 0;
	di->bounced = 0;
@


1.15
log
@Obliterate old PnP `code' and outright replace with christos' code.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.14 1997/11/04 10:32:51 provos Exp $	*/
a128 14
}

int
isadma_isdrqfree(chan)
	int chan;
{
	struct dma_info *di;
#ifdef DIAGNOSTIC
	if (chan < 0 || chan > 7)
		panic("isadma_release: channel out of range");
#endif
	di = dma_info + chan;

	return (di->inuse);
@


1.14
log
@fix autodma and high dma, also copy data only when using bounce
buffers.
semantics for isadma_acquire and isadma_release from freebsd.
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.13 1996/12/12 00:21:59 niklas Exp $	*/
d131 14
d153 1
d159 1
d171 4
@


1.13
log
@Revert to non-bus.h versions for the time being
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.9 1996/11/23 21:46:41 kstailey Exp $	*/
d25 2
d44 2
a45 2
	DMA37MD_READ | DMA37MD_LOOP,
	DMA37MD_WRITE | DMA37MD_LOOP
d81 51
d192 1
a192 1
	mflags = ISADMA_MAP_WAITOK | ISADMA_MAP_BOUNCE | ISADMA_MAP_CONTIG;
d195 2
a196 2
	if (isadma_map(addr, nbytes, di->phys, mflags) != 1)
		panic("isadma_start: cannot map");
d198 12
a209 3
	/* XXX Will this do what we want with DMAMODE_LOOP?  */
	if ((flags & DMAMODE_READ) == 0)
		isadma_copytobuf(addr, nbytes, 1, di->phys);
d245 1
a245 1
		outb(dmapageport[1][chan], di->phys[0].addr>>16);
d284 1
d340 1
a340 1
	if (di->flags & DMAMODE_READ)
d345 1
@


1.12
log
@Slight optimizations
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.11 1996/12/11 12:57:31 niklas Exp $	*/
a14 1
#include <machine/bus.h>
a29 1
static struct isadma_softc *isadma_sc;	/*XXX ugly */
d33 4
a36 7
/*
 * high byte of address is stored in this port (offset IO_DMAPG) for i-th
 * dma channel
 */
static short dmapageport[2][4] = {
	{0x7, 0x3, 0x1, 0x2},
	{0xf, 0xb, 0x9, 0xa}
a49 8
struct isadma_softc {
	struct device sc_dev;
	bus_space_tag_t sc_iot;
	bus_space_handle_t sc_ioh1;
	bus_space_handle_t sc_ioh2;
	bus_space_handle_t sc_dmapageioh[2][4];
};

a74 5
	struct isadma_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot;
	int i;

a75 13
	iot = sc->sc_iot = ia->ia_iot;
	if (bus_space_map(iot, IO_DMA1, DMA_NREGS(1), 0, &sc->sc_ioh1))
	    	panic("isadmaattach: couldn't map I/O ports at IO_DMA1");
	if (bus_space_map(iot, IO_DMA2, DMA_NREGS(2), 0, &sc->sc_ioh2))
		panic("isadmaattach: couldn't map I/O ports at IO_DMA2");

	/* XXX the constants below is a bit ugly, I know... */
	for (i = 0; i < 8; i++) {
		if (bus_space_map(iot, IO_DMAPG + dmapageport[i % 2][i / 2], 1,
		    0, &sc->sc_dmapageioh[i % 2][i / 2]))
			panic("isadmaattach: couldn't map DMA page I/O port");
	}
	isadma_sc = sc;
a85 4
	struct isadma_softc *sc = isadma_sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;
	int dma_unit;
d94 2
a95 2
		ioh = sc->sc_ioh1;
		dma_unit = 1;
a96 1
		ioh = sc->sc_ioh2;
d98 3
a100 1
		dma_unit = 2;
a101 3
	bus_space_write_1(iot, ioh, DMA_MODE(dma_unit),
	    chan | DMA37MD_CASCADE);
	bus_space_write_1(iot, ioh, DMA_SMSK(dma_unit), chan);
a114 3
	struct isadma_softc *sc = isadma_sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;
a117 1
	int dma_unit;
d156 16
a171 2
		ioh = sc->sc_ioh1;
		dma_unit = 1;
d177 11
a187 3
		ioh = sc->sc_ioh2;
		dma_unit = 2;
		chan &= 3;
d189 5
a194 17
       	/* set dma channel mode, and reset address ff */
	bus_space_write_1(iot, ioh, DMA_MODE(dma_unit), chan | dmamode[flags]);
	bus_space_write_1(iot, ioh, DMA_FFC(dma_unit), 0);

	/* send start address */
	waport = DMA_CHN(dma_unit, chan);
	bus_space_write_1(iot, sc->sc_dmapageioh[dma_unit - 1][chan], 0,
	    di->phys[0].addr>>16);
	bus_space_write_1(iot, ioh, waport, di->phys[0].addr);
	bus_space_write_1(iot, ioh, waport, di->phys[0].addr>>8);

	/* send count */
	bus_space_write_1(iot, ioh, waport + dma_unit, --nbytes & 0xff);
	bus_space_write_1(iot, ioh, waport + dma_unit, nbytes >> 8);

	/* unmask channel */
	bus_space_write_1(iot, ioh, DMA_SMSK(dma_unit), chan | DMA37SM_CLEAR);
a200 3
	struct isadma_softc *sc = isadma_sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;
a201 1
	int dma_unit;
d215 5
a219 9
	if ((chan & 4) == 0) {
		ioh = sc->sc_ioh1;
		dma_unit = 1;
	} else {
		ioh = sc->sc_ioh2;
		chan &= 3;
		dma_unit = 2;
	}
	bus_space_write_1(iot, ioh, DMA_SMSK(dma_unit), DMA37SM_SET | chan);
a227 4
	struct isadma_softc *sc = isadma_sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;
	int dma_unit;
d235 5
a239 9
	if ((chan & 4) == 0) {
		ioh = sc->sc_ioh1;
		dma_unit = 1;
	} else {
		ioh = sc->sc_ioh2;
		chan &= 3;
		dma_unit = 2;
	}
	dma_finished |= bus_space_read_1(iot, ioh, DMA_SR(dma_unit)) & 0x0f;
a246 4
	struct isadma_softc *sc = isadma_sc;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh;
	int dma_unit;
d262 4
a265 10
	if ((chan & 4) == 0) {
		ioh = sc->sc_ioh1;
		dma_unit = 1;
	} else {
		ioh = sc->sc_ioh2;
		chan &= 3;
		dma_unit = 2;
	}
	tc = bus_space_read_1(iot, ioh, DMA_SR(dma_unit)) & (1 << chan);

d268 1
a268 2
		log(LOG_ERR, "dma channel %d not finished\n",
		    dma_unit == 1 ? chan : (chan | 4));
d271 4
a274 1
	bus_space_write_1(iot, ioh, DMA_SMSK(dma_unit), DMA37SM_SET | chan);
@


1.11
log
@Do not allocate all of ports 0x80 - 0x8f for isadma (hint: delay)
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.10 1996/11/29 22:55:01 niklas Exp $	*/
d35 5
a39 2
/* high byte of address is stored in this port for i-th dma channel */
static bus_addr_t dmapageport[2][4] = {
a90 1
	bus_space_handle_t ioh;
d95 1
a95 1
	if (bus_space_map(iot, IO_DMA1, DMA_NREGS(1), 0, &ioh))
d97 1
a97 2
	sc->sc_ioh1 = ioh;
	if (bus_space_map(iot, IO_DMA2, DMA_NREGS(2), 0, &ioh))
a98 1
	sc->sc_ioh2 = ioh;
@


1.11.2.1
log
@Tagged wrong version, brought in the changes from 1.12 int the branch
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.12 1996/12/11 22:38:06 niklas Exp $	*/
d35 2
a36 5
/*
 * high byte of address is stored in this port (offset IO_DMAPG) for i-th
 * dma channel
 */
static short dmapageport[2][4] = {
d88 1
d93 1
a93 1
	if (bus_space_map(iot, IO_DMA1, DMA_NREGS(1), 0, &sc->sc_ioh1))
d95 2
a96 1
	if (bus_space_map(iot, IO_DMA2, DMA_NREGS(2), 0, &sc->sc_ioh2))
d98 1
@


1.10
log
@Missing pieces of new bus.h that CVS lost behind my back
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.10 1996/11/23 21:46:55 kstailey Exp $	*/
d36 1
a36 1
static int dmapageport[2][4] = {
d57 1
a57 1
	bus_space_handle_t sc_iohpg;
d89 1
d99 7
a105 3
	if (bus_space_map(iot, IO_DMAPG, 16 /* XXX */, 0, &ioh))
		panic("isadmaattach: couldn't map I/O ports at IO_DMAPG");
	sc->sc_iohpg = ioh;
d215 2
a216 2
	bus_space_write_1(iot, sc->sc_iohpg,
	    dmapageport[dma_unit - 1][chan], di->phys[0].addr>>16);
@


1.9
log
@added const to second parameter of cfprint_t routines
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.8 1996/10/16 12:32:36 deraadt Exp $	*/
d15 1
d31 1
d37 2
a38 2
	{0x87, 0x83, 0x81, 0x82},
	{0x8f, 0x8b, 0x89, 0x8a}
d52 8
d85 5
d91 11
d112 4
d124 2
a125 2
		outb(DMA1_MODE, chan | DMA37MD_CASCADE);
		outb(DMA1_SMSK, chan);
d127 1
d129 1
a129 3

		outb(DMA2_MODE, chan | DMA37MD_CASCADE);
		outb(DMA2_SMSK, chan);
d131 3
d147 3
d153 1
d192 2
a193 16
		/* set dma channel mode, and reset address ff */
		outb(DMA1_MODE, chan | dmamode[flags]);
		outb(DMA1_FFC, 0);

		/* send start address */
		waport = DMA1_CHN(chan);
		outb(dmapageport[0][chan], di->phys[0].addr>>16);
		outb(waport, di->phys[0].addr);
		outb(waport, di->phys[0].addr>>8);

		/* send count */
		outb(waport + 1, --nbytes);
		outb(waport + 1, nbytes>>8);

		/* unmask channel */
		outb(DMA1_SMSK, chan | DMA37SM_CLEAR);
d199 3
a201 11
		/* set dma channel mode, and reset address ff */
		outb(DMA2_MODE, (chan & 3) | dmamode[flags]);
		outb(DMA2_FFC, 0);

		/* send start address */
		waport = DMA2_CHN(chan & 3);
		outb(dmapageport[1][chan], di->phys[0].addr>>16);
		outb(waport, di->phys[0].addr>>1);
		outb(waport, di->phys[0].addr>>9);

		/* send count */
d203 15
a217 2
		outb(waport + 2, --nbytes);
		outb(waport + 2, nbytes>>8);
d219 2
a220 3
		/* unmask channel */
		outb(DMA2_SMSK, (chan & 3) | DMA37SM_CLEAR);
	}
d227 3
d231 1
d245 9
a253 5
	if ((chan & 4) == 0)
		outb(DMA1_SMSK, DMA37SM_SET | chan);
	else
		outb(DMA2_SMSK, DMA37SM_SET | (chan & 3));

d262 4
d273 9
a281 5
	if ((chan & 4) == 0)
		dma_finished |= inb(DMA1_SR) & 0x0f;
	else
		dma_finished |= (inb(DMA2_SR) & 0x0f) << 4;

d289 4
d308 10
a317 4
	if ((chan & 4) == 0)
		tc = inb(DMA1_SR) & (1 << chan);
	else
		tc = inb(DMA2_SR) & (1 << (chan & 3));
d320 2
a321 1
		log(LOG_ERR, "dma channel %d not finished\n", chan);
d324 1
a324 4
	if ((chan & 4) == 0)
		outb(DMA1_SMSK, DMA37SM_SET | chan);
	else
		outb(DMA2_SMSK, DMA37SM_SET | (chan & 3));
@


1.8
log
@fix proto, unused var
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.7 1996/06/16 10:31:27 deraadt Exp $	*/
d48 1
a48 1
int isadmaprint __P((void *, char *));
@


1.7
log
@isadma is now a real driver, so that ports can choose to use it or not
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.6 1996/05/07 07:37:10 deraadt Exp $	*/
d58 1
a117 1
	vm_size_t size;
@


1.6
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.5 1996/04/22 20:03:05 hannken Exp $	*/
d6 1
d18 1
d45 31
@


1.5
log
@Update aha.c to use bounce buffers, fix typos in isadma.c, update bounce buffers
@
text
@d1 2
a2 2
/*	$OpenBSD: isadma.c,v 1.4 1996/04/21 22:24:14 deraadt Exp $	*/
/*	$NetBSD: isadma.c,v 1.18 1996/03/31 20:51:43 mycroft Exp $	*/
@


1.4
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*	$OpenBSD: isadma.c,v 1.3 1996/04/18 23:47:41 niklas Exp $	*/
d22 1
d96 1
a96 1
	if (di->flags != 0) {
d102 1
d176 1
a176 1
	if (di->flags == 0) {
d188 1
a188 1
	di->flags = 0;
d223 1
a223 1
	if (di->flags == 0) {
d248 1
a248 1
	di->flags = 0;
@


1.3
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: isadma.c,v 1.17 1996/03/01 04:35:27 mycroft Exp $	*/
d31 3
a33 2
static int dmapageport[8] = {
	0x87, 0x83, 0x81, 0x82, 0x8f, 0x8b, 0x89, 0x8a
d127 1
a127 1
		outb(dmapageport[chan], di->phys[0].addr>>16);
d148 1
a148 1
		outb(dmapageport[chan], di->phys[0].addr>>16);
@


1.2
log
@i386 isa bounce buffers by hannken@@eis.cs.tu-bs.de
ultra14f does not bounce properly yet.
@
text
@d1 2
a2 1
/*	$NetBSD: isadma.c,v 1.12 1995/04/17 12:09:11 cgd Exp $	*/
d28 1
d31 10
a40 2
static int dmapageport[8] =
	{ 0x87, 0x83, 0x81, 0x82, 0x8f, 0x8b, 0x89, 0x8a };
d51 1
a51 1
#ifdef DIAGNOSTIC
d58 1
a58 1
		outb(DMA1_MODE, DMA37MD_CASCADE | chan);
d61 4
a64 2
		outb(DMA2_MODE, DMA37MD_CASCADE | (chan & 3));
		outb(DMA2_SMSK, chan & 3);
d84 1
a84 1
#ifdef DIAGNOSTIC
d86 2
a87 1
	    ((flags & ISADMA_START_READ) == 0) == ((flags & ISADMA_START_WRITE) == 0) ||
d109 2
a110 1
	if ((flags & ISADMA_START_READ) == 0)
d113 2
d121 1
a121 4
		if (flags & ISADMA_START_READ)
			outb(DMA1_MODE, chan | DMA37MD_SINGLE | DMA37MD_WRITE);
		else
			outb(DMA1_MODE, chan | DMA37MD_SINGLE | DMA37MD_READ);
d125 2
a126 1
		waport =  DMA1_CHN(chan);
a128 1
		outb(dmapageport[chan], di->phys[0].addr>>16);
d142 1
a142 4
		if (flags & ISADMA_START_READ)
			outb(DMA2_MODE, (chan & 3) | DMA37MD_SINGLE | DMA37MD_WRITE);
		else
			outb(DMA2_MODE, (chan & 3) | DMA37MD_SINGLE | DMA37MD_READ);
d147 1
a149 1
		outb(dmapageport[chan], di->phys[0].addr>>16);
d167 1
a167 1
#ifdef DIAGNOSTIC
d188 19
d240 2
a241 1
	if (di->flags & ISADMA_START_READ)
@


1.1
log
@Initial revision
@
text
@d19 8
a26 5
/* region of physical memory known to be contiguous */
vm_offset_t isaphysmem;
static caddr_t dma_bounce[8];		/* XXX */
static char bounced[8];		/* XXX */
#define MAXDMASZ 512		/* XXX */
d33 1
a33 1
 * isa_dmacascade(): program 8237 DMA controller channel to accept
d37 1
a37 1
isa_dmacascade(chan)
d43 1
a43 1
		panic("isa_dmacascade: impossible request"); 
d57 1
a57 1
 * isa_dmastart(): program 8237 DMA controller channel, avoid page alignment
d61 1
a61 2
isa_dmastart(flags, addr, nbytes, chan)
	int flags;
d65 1
d67 1
a67 1
	vm_offset_t phys;
d69 2
a70 1
	caddr_t newaddr;
d74 1
d77 1
a77 1
		panic("isa_dmastart: impossible request"); 
d80 4
a83 12
	if (isa_dmarangecheck(addr, nbytes, chan)) {
		if (dma_bounce[chan] == 0)
			dma_bounce[chan] =
			    /*(caddr_t)malloc(MAXDMASZ, M_TEMP, M_WAITOK);*/
			    (caddr_t) isaphysmem + NBPG*chan;
		bounced[chan] = 1;
		newaddr = dma_bounce[chan];
		*(int *) newaddr = 0;	/* XXX */
		/* copy bounce buffer on write */
		if ((flags & B_READ) == 0)
			bcopy(addr, newaddr, nbytes);
		addr = newaddr;
d86 12
a97 2
	/* translate to physical */
	phys = pmap_extract(pmap_kernel(), (vm_offset_t)addr);
d105 1
a105 1
		if (flags & B_READ)
d113 3
a115 3
		outb(waport, phys);
		outb(waport, phys>>8);
		outb(dmapageport[chan], phys>>16);
d129 1
a129 1
		if (flags & B_READ)
d137 3
a139 3
		outb(waport, phys>>1);
		outb(waport, phys>>9);
		outb(dmapageport[chan], phys>>16);
d152 1
a152 1
isa_dmaabort(chan)
d155 1
d159 1
a159 1
		panic("isa_dmaabort: impossible request");
d162 5
a166 1
	bounced[chan] = 0;
d173 3
d179 1
a179 4
isa_dmadone(flags, addr, nbytes, chan)
	int flags;
	caddr_t addr;
	vm_size_t nbytes;
d182 1
d187 1
a187 1
		panic("isa_dmadone: impossible request");
d190 6
d211 2
a212 6
	/* copy bounce buffer on read */
	if (bounced[chan]) {
		bcopy(dma_bounce[chan], addr, nbytes);
		bounced[chan] = 0;
	}
}
d214 2
a215 74
/*
 * Check for problems with the address range of a DMA transfer
 * (non-contiguous physical pages, outside of bus address space,
 * crossing DMA page boundaries).
 * Return true if special handling needed.
 */
int
isa_dmarangecheck(va, length, chan)
	vm_offset_t va;
	u_long length;
	int chan;
{
	vm_offset_t phys, priorpage = 0, endva;
	u_int dma_pgmsk = (chan & 4) ?  ~(128*1024-1) : ~(64*1024-1);

	endva = round_page(va + length);
	for (; va < endva ; va += NBPG) {
		phys = trunc_page(pmap_extract(pmap_kernel(), va));
		if (phys == 0)
			panic("isa_dmacheck: no physical page present");
		if (phys >= (1<<24)) 
			return 1;
		if (priorpage) {
			if (priorpage + NBPG != phys)
				return 1;
			/* check if crossing a DMA page boundary */
			if ((priorpage ^ phys) & dma_pgmsk)
				return 1;
		}
		priorpage = phys;
	}
	return 0;
}

/* head of queue waiting for physmem to become available */
struct buf isa_physmemq;

/* blocked waiting for resource to become free for exclusive use */
static isaphysmemflag;
/* if waited for and call requested when free (B_CALL) */
static void (*isaphysmemunblock)(); /* needs to be a list */

/*
 * Allocate contiguous physical memory for transfer, returning
 * a *virtual* address to region. May block waiting for resource.
 * (assumed to be called at splbio())
 */
caddr_t
isa_allocphysmem(caddr_t va, unsigned length, void (*func)()) {
	
	isaphysmemunblock = func;
	while (isaphysmemflag & B_BUSY) {
		isaphysmemflag |= B_WANTED;
		sleep((caddr_t)&isaphysmemflag, PRIBIO);
	}
	isaphysmemflag |= B_BUSY;

	return((caddr_t)isaphysmem);
}

/*
 * Free contiguous physical memory used for transfer.
 * (assumed to be called at splbio())
 */
void
isa_freephysmem(caddr_t va, unsigned length) {

	isaphysmemflag &= ~B_BUSY;
	if (isaphysmemflag & B_WANTED) {
		isaphysmemflag &= B_WANTED;
		wakeup((caddr_t)&isaphysmemflag);
		if (isaphysmemunblock)
			(*isaphysmemunblock)();
	}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@

