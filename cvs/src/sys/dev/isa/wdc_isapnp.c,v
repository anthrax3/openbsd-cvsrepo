head	1.10;
access;
symbols
	OPENBSD_6_1:1.10.0.24
	OPENBSD_6_1_BASE:1.10
	OPENBSD_6_0:1.10.0.22
	OPENBSD_6_0_BASE:1.10
	OPENBSD_5_9:1.10.0.12
	OPENBSD_5_9_BASE:1.10
	OPENBSD_5_8:1.10.0.20
	OPENBSD_5_8_BASE:1.10
	OPENBSD_5_7:1.10.0.18
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.16
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.14
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.10
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.10.0.8
	OPENBSD_5_3_BASE:1.10
	OPENBSD_5_2:1.10.0.6
	OPENBSD_5_2_BASE:1.10
	OPENBSD_5_1_BASE:1.10
	OPENBSD_5_1:1.10.0.4
	OPENBSD_5_0:1.10.0.2
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.8.0.12
	OPENBSD_4_9_BASE:1.8
	OPENBSD_4_8:1.8.0.10
	OPENBSD_4_8_BASE:1.8
	OPENBSD_4_7:1.8.0.6
	OPENBSD_4_7_BASE:1.8
	OPENBSD_4_6:1.8.0.8
	OPENBSD_4_6_BASE:1.8
	OPENBSD_4_5:1.8.0.4
	OPENBSD_4_5_BASE:1.8
	OPENBSD_4_4:1.8.0.2
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.7.0.26
	OPENBSD_4_3_BASE:1.7
	OPENBSD_4_2:1.7.0.24
	OPENBSD_4_2_BASE:1.7
	OPENBSD_4_1:1.7.0.22
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.20
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.18
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.8
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.4.0.6
	OPENBSD_2_7_BASE:1.4
	SMP:1.4.0.4
	SMP_BASE:1.4
	kame_19991208:1.4
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.10
date	2011.06.29.12.17.40;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2011.05.09.22.33.54;	author matthew;	state Exp;
branches;
next	1.8;

1.8
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.08.06.41.37;	author fgsch;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.01.29.00.20.17;	author csapuntz;	state Exp;
branches;
next	1.4;

1.4
date	99.10.09.03.42.04;	author csapuntz;	state Exp;
branches
	1.4.4.1;
next	1.3;

1.3
date	99.07.21.12.39.22;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	99.07.21.03.52.54;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	99.07.21.03.50.10;	author deraadt;	state Exp;
branches;
next	;

1.4.4.1
date	2001.05.14.22.24.54;	author niklas;	state Exp;
branches;
next	1.4.4.2;

1.4.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.4.4.3;

1.4.4.3
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.10
log
@notyet, notever.  delete a bunch of code we won't be using.
@
text
@/*	$OpenBSD: wdc_isapnp.c,v 1.9 2011/05/09 22:33:54 matthew Exp $	*/
/*	$NetBSD: wdc_isapnp.c,v 1.13 1999/03/22 10:00:12 mycroft Exp $	*/

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum and by Onno van der Linden.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ata/atavar.h>
#include <dev/ic/wdcreg.h>
#include <dev/ic/wdcvar.h>

struct wdc_isapnp_softc {
	struct	wdc_softc sc_wdcdev;
	struct	channel_softc *wdc_chanptr;
	struct	channel_softc wdc_channel;
	isa_chipset_tag_t sc_ic;
	void	*sc_ih;
	int	sc_drq;
};

int	wdc_isapnp_match(struct device *, void *, void *);
void	wdc_isapnp_attach(struct device *, struct device *, void *);

struct cfattach wdc_isapnp_ca = {
	sizeof(struct wdc_isapnp_softc), wdc_isapnp_match, wdc_isapnp_attach
};

int
wdc_isapnp_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct isa_attach_args *ipa = aux;

	if (ipa->ipa_nio != 2 ||
	    ipa->ipa_nmem != 0 ||
	    ipa->ipa_nmem32 != 0 ||
	    ipa->ipa_nirq != 1 ||
	    ipa->ipa_ndrq > 1)
		return 0;

	return (1);
}

void
wdc_isapnp_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct wdc_isapnp_softc *sc = (void *)self;
	struct isa_attach_args *ipa = aux;


	sc->wdc_channel.cmd_iot = ipa->ia_iot;
	sc->wdc_channel.ctl_iot = ipa->ia_iot;

	/*
	 * An IDE controller can feed us the regions in any order. Pass
	 * them along with the 8-byte region in sc_ad.ioh, and the other
	 * (2 byte) region in auxioh.
	 */
	if (ipa->ipa_io[0].length == 8) {
		sc->wdc_channel.cmd_ioh = ipa->ipa_io[0].h;
		sc->wdc_channel.ctl_ioh = ipa->ipa_io[1].h;
	} else {
		sc->wdc_channel.cmd_ioh = ipa->ipa_io[1].h;
		sc->wdc_channel.ctl_ioh = ipa->ipa_io[0].h;
	}
	sc->wdc_channel.data32iot = sc->wdc_channel.cmd_iot;
	sc->wdc_channel.data32ioh = sc->wdc_channel.cmd_ioh;

	sc->sc_ic = ipa->ia_ic;
	sc->sc_ih = isa_intr_establish(ipa->ia_ic, ipa->ipa_irq[0].num,
	    ipa->ipa_irq[0].type, IPL_BIO, wdcintr, &sc->wdc_channel,
	    sc->sc_wdcdev.sc_dev.dv_xname);

	sc->sc_wdcdev.cap |= WDC_CAPABILITY_DATA16 | WDC_CAPABILITY_DATA32;
	sc->sc_wdcdev.PIO_cap = 0;
	sc->wdc_chanptr = &sc->wdc_channel;
	sc->sc_wdcdev.channels = &sc->wdc_chanptr;
	sc->sc_wdcdev.nchannels = 1;
	sc->wdc_channel.channel = 0;
	sc->wdc_channel.wdc = &sc->sc_wdcdev;
	sc->wdc_channel.ch_queue = wdc_alloc_queue();
	if (sc->wdc_channel.ch_queue == NULL) {
		printf(": cannot allocate channel queue\n");
		return;
	}

	printf("\n");
	wdcattach(&sc->wdc_channel);
	wdc_print_current_modes(&sc->wdc_channel);
}
@


1.9
log
@Refactor queue allocation and initialization into a wdc_alloc_queue()
function, and let attachment code calls this rather than malloc(9).
This prevents re-initialization of the queue in shared queue chipsets.
Also, add wdc_free_queue() as a complementary function.

Earlier version (without wdc_free_queue()) tested by sthen@@ and Amit
Kulkarni on various pciide(4) chips.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_isapnp.c,v 1.8 2008/06/26 05:42:16 ray Exp $	*/
a64 6
#ifdef notyet
static void	wdc_isapnp_dma_setup(struct wdc_isapnp_softc *);
static void	wdc_isapnp_dma_start(void *, void *, size_t, int);
static void	wdc_isapnp_dma_finish(void *);
#endif

a114 10
#ifdef notyet
	if (ipa->ipa_ndrq > 0) {
		sc->sc_drq = ipa->ipa_drq[0].num;

		sc->sc_ad.cap |= WDC_CAPABILITY_DMA;
		sc->sc_ad.dma_start = &wdc_isapnp_dma_start;
		sc->sc_ad.dma_finish = &wdc_isapnp_dma_finish;
		wdc_isapnp_dma_setup(sc);
	}
#endif
a131 37

#ifdef notyet
static void
wdc_isapnp_dma_setup(sc)
	struct wdc_isapnp_softc *sc;
{

	if (isa_dmamap_create(sc->sc_ic, sc->sc_drq,
	    MAXPHYS, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
		printf("%s: can't create map for drq %d\n",
		    sc->sc_wdcdev.sc_dev.dv_xname, sc->sc_drq);
		sc->sc_wdcdev.cap &= ~WDC_CAPABILITY_DMA;
	}
}

static void
wdc_isapnp_dma_start(scv, buf, size, read)
	void *scv, *buf;
	size_t size;
	int read;
{
	struct wdc_isapnp_softc *sc = scv;

	isa_dmastart(sc->sc_ic, sc->sc_drq, buf, size, NULL,
	    (read ? DMAMODE_READ : DMAMODE_WRITE) | DMAMODE_DEMAND,
	    BUS_DMA_NOWAIT);
}

static void
wdc_isapnp_dma_finish(scv)
	void *scv;
{
	struct wdc_isapnp_softc *sc = scv;

	isa_dmadone(sc->sc_ic, sc->sc_drq);
}
#endif
@


1.8
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_isapnp.c,v 1.7 2002/03/14 01:26:56 millert Exp $	*/
d138 1
a138 2
	sc->wdc_channel.ch_queue = malloc(sizeof(struct channel_queue),
	    M_DEVBUF, M_NOWAIT);
d140 1
a140 1
		printf(": can't allocate memory for command queue\n");
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_isapnp.c,v 1.6 2001/07/08 06:41:37 fgsch Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.6
log
@OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 2
a66 2
int	wdc_isapnp_match 	__P((struct device *, void *, void *));
void	wdc_isapnp_attach 	__P((struct device *, struct device *, void *));
d73 3
a75 3
static void	wdc_isapnp_dma_setup __P((struct wdc_isapnp_softc *));
static void	wdc_isapnp_dma_start __P((void *, void *, size_t, int));
static void	wdc_isapnp_dma_finish __P((void *));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: wdc_isapnp.c,v 1.6 2001/07/08 06:41:37 fgsch Exp $	*/
d65 2
a66 2
int	wdc_isapnp_match(struct device *, void *, void *);
void	wdc_isapnp_attach(struct device *, struct device *, void *);
d73 3
a75 3
static void	wdc_isapnp_dma_setup(struct wdc_isapnp_softc *);
static void	wdc_isapnp_dma_start(void *, void *, size_t, int);
static void	wdc_isapnp_dma_finish(void *);
@


1.5
log
@


Add wdc_print_current_modes to print current transfer modes set on the
devices. Print after attach in wdc_isa, wdc_isapnp, wdc_pcmcia.
pciide_print_modes rewritten to use wdc_print_current_modes.

Disable wdc_print_caps since it's not as useful.

Inspired by NetBSD. Thanks to Dale and Theo for pointing out this improvement.
@
text
@d1 1
@


1.4
log
@

wdc layer work:
Separate wdc_probe_caps into wdc_probe_caps and wdc_print_caps for more
flexibility in printing capability information.

Get rid of wdc_final_attach.

Include name of device (e.g. cd0), if possible, on errors.

atapiscsi layer work:
Put a pointer to the SCSI device into ata_drive_datas' drv_softc field

Simplify, simplify, simplify. Got rid of a bunch of fields in atapiscsi_softc

Delay printing capabilities until we know the real device name (e.g. st0)
@
text
@d153 1
@


1.4.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@a152 1
	wdc_print_current_modes(&sc->wdc_channel);
@


1.4.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@a0 1
/*	$OpenBSD$	*/
@


1.4.4.3
log
@Merge in -current from about a week ago
@
text
@d65 2
a66 2
int	wdc_isapnp_match(struct device *, void *, void *);
void	wdc_isapnp_attach(struct device *, struct device *, void *);
d73 3
a75 3
static void	wdc_isapnp_dma_setup(struct wdc_isapnp_softc *);
static void	wdc_isapnp_dma_start(void *, void *, size_t, int);
static void	wdc_isapnp_dma_finish(void *);
@


1.3
log
@do resource requirement checking in match(), not attach()
@
text
@a152 1
	wdc_final_attach(&sc->wdc_channel);
@


1.2
log
@support ATAPI; csapuntz
@
text
@d83 8
a102 8
	if (ipa->ipa_nio != 2 ||
	    ipa->ipa_nmem != 0 ||
	    ipa->ipa_nmem32 != 0 ||
	    ipa->ipa_nirq != 1 ||
	    ipa->ipa_ndrq > 1) {
		printf(": unexpected configuration\n");
		return;
	}
@


1.1
log
@isapnp wdc works
@
text
@d153 1
@

