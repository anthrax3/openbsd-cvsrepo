head	1.23;
access;
symbols
	OPENBSD_6_2:1.23.0.4
	OPENBSD_6_2_BASE:1.23
	OPENBSD_6_1:1.22.0.28
	OPENBSD_6_1_BASE:1.22
	OPENBSD_6_0:1.22.0.24
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.14
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.22
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.22.0.20
	OPENBSD_5_7_BASE:1.22
	OPENBSD_5_6:1.22.0.18
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.16
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.22.0.12
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.22.0.10
	OPENBSD_5_3_BASE:1.22
	OPENBSD_5_2:1.22.0.8
	OPENBSD_5_2_BASE:1.22
	OPENBSD_5_1_BASE:1.22
	OPENBSD_5_1:1.22.0.6
	OPENBSD_5_0:1.22.0.4
	OPENBSD_5_0_BASE:1.22
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.21.0.2
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.20.0.18
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.20
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.16
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.14
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.12
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.10
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.8
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.6
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.19.0.2
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.8
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.6
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.4
	OPENBSD_2_8:1.12.0.2
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.9.0.6
	OPENBSD_2_7_BASE:1.9
	SMP:1.9.0.4
	SMP_BASE:1.9
	kame_19991208:1.9
	OPENBSD_2_6:1.9.0.2
	OPENBSD_2_6_BASE:1.9
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.1.0.2
	OPENBSD_2_4_BASE:1.1;
locks; strict;
comment	@ * @;


1.23
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.22;
commitid	uRv5pa9QDlZaYgwD;

1.22
date	2010.09.07.16.21.43;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.02.04.23.15;	author blambert;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.25.16.41.18;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.27.17.03.23;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2004.01.09.21.32.23;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.09.21.17.55.43;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2001.08.17.21.52.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.03.02.59.24;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.28.17.48.10;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.23.16.53.08;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	99.08.11.12.02.07;	author niklas;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	99.07.26.05.43.16;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	99.01.28.07.51.36;	author fgsch;	state Exp;
branches;
next	1.6;

1.6
date	99.01.07.02.28.15;	author niklas;	state Exp;
branches;
next	1.5;

1.5
date	99.01.01.08.05.46;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	98.12.31.12.09.02;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	98.12.31.09.17.43;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.12.27.00.27.18;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	98.09.11.08.02.50;	author fgsch;	state Exp;
branches;
next	;

1.9.4.1
date	2001.05.14.22.24.37;	author niklas;	state Exp;
branches;
next	1.9.4.2;

1.9.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.9.4.3;

1.9.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.9.4.4;

1.9.4.4
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.9.4.5;

1.9.4.5
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.23
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: i82365_isa.c,v 1.22 2010/09/07 16:21:43 deraadt Exp $	*/
/*	$NetBSD: i82365_isa.c,v 1.11 1998/06/09 07:25:00 thorpej Exp $	*/

/*
 * Copyright (c) 1997 Marc Horowitz.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Marc Horowitz.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/extent.h>
#include <sys/malloc.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/pcmcia/pcmciareg.h>
#include <dev/pcmcia/pcmciavar.h>
#include <dev/pcmcia/pcmciachip.h>

#include <dev/ic/i82365reg.h>
#include <dev/ic/i82365var.h>
#include <dev/isa/i82365_isavar.h>

#ifdef PCICISADEBUG
#define	DPRINTF(arg)	printf arg;
#else
#define	DPRINTF(arg)
#endif

int	pcic_isa_probe(struct device *, void *, void *);
void	pcic_isa_attach(struct device *, struct device *, void *);

struct cfattach pcic_isa_ca = {
	sizeof(struct pcic_softc), pcic_isa_probe, pcic_isa_attach
};

static struct pcmcia_chip_functions pcic_isa_functions = {
	pcic_chip_mem_alloc,
	pcic_chip_mem_free,
	pcic_chip_mem_map,
	pcic_chip_mem_unmap,

	pcic_chip_io_alloc,
	pcic_chip_io_free,
	pcic_chip_io_map,
	pcic_chip_io_unmap,

	pcic_isa_chip_intr_establish,
	pcic_isa_chip_intr_disestablish,
	pcic_isa_chip_intr_string,

	pcic_chip_socket_enable,
	pcic_chip_socket_disable,
};

int
pcic_isa_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct isa_attach_args *ia = aux;
	bus_space_tag_t memt = ia->ia_memt, iot = ia->ia_iot;
	bus_space_handle_t ioh, memh;
	bus_size_t msize;
	int val, found;

	/* Disallow wildcarded i/o address. */
	if (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)
		return (0);

	if (bus_space_map(iot, ia->ia_iobase, PCIC_IOSIZE, 0, &ioh))
		return (0);

	if (ia->ia_msize == -1)
		ia->ia_msize = PCIC_MEMSIZE;

	msize = ia->ia_msize;
	if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {
		if (ia->ia_msize > PCIC_MEMSIZE &&
		    !bus_space_map(memt, ia->ia_maddr, PCIC_MEMSIZE, 0, &memh))
			msize = PCIC_MEMSIZE;
		else
			return (0);
	}
	found = 0;

	/*
	 * this could be done with a loop, but it would violate the
	 * abstraction
	 */

	bus_space_write_1(iot, ioh, PCIC_REG_INDEX, C0SA + PCIC_IDENT);
	val = bus_space_read_1(iot, ioh, PCIC_REG_DATA);
	if (pcic_ident_ok(val))
		found++;

	bus_space_write_1(iot, ioh, PCIC_REG_INDEX, C0SB + PCIC_IDENT);
	val = bus_space_read_1(iot, ioh, PCIC_REG_DATA);
	if (pcic_ident_ok(val))
		found++;

	bus_space_write_1(iot, ioh, PCIC_REG_INDEX, C1SA + PCIC_IDENT);
	val = bus_space_read_1(iot, ioh, PCIC_REG_DATA);
	if (pcic_ident_ok(val))
		found++;

	bus_space_write_1(iot, ioh, PCIC_REG_INDEX, C1SB + PCIC_IDENT);
	val = bus_space_read_1(iot, ioh, PCIC_REG_DATA);
	if (pcic_ident_ok(val))
		found++;

	bus_space_unmap(iot, ioh, PCIC_IOSIZE);
	bus_space_unmap(memt, memh, msize);

	if (!found)
		return (0);
	ia->ia_iosize = PCIC_IOSIZE;
	ia->ia_msize = msize;
	return (1);
}

void
pcic_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct pcic_softc *sc = (void *)self;
	struct pcic_handle *h;
	struct isa_attach_args *ia = aux;
	isa_chipset_tag_t ic = ia->ia_ic;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_tag_t memt = ia->ia_memt;
	bus_space_handle_t ioh;
	bus_space_handle_t memh;
	int irq, i;

	/* Map i/o space. */
	if (bus_space_map(iot, ia->ia_iobase, ia->ia_iosize, 0, &ioh)) {
		printf(": can't map i/o space\n");
		return;
	}

	/* Map mem space. */
	if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {
		printf(": can't map mem space\n");
		return;
	}

	sc->membase = ia->ia_maddr;
	sc->subregionmask = (1 << (ia->ia_msize / PCIC_MEM_PAGESIZE)) - 1;

	sc->intr_est = ic;
	sc->pct = (pcmcia_chipset_tag_t)&pcic_isa_functions;

	sc->iot = iot;
	sc->ioh = ioh;
	sc->memt = memt;
	sc->memh = memh;

	printf("\n");

	pcic_attach(sc);
	pcic_isa_bus_width_probe(sc, iot, ioh, ia->ia_iobase, ia->ia_iosize);
	pcic_attach_sockets(sc);

	/*
	 * Allocate an irq.  It will be used by both controllers.  I could
	 * use two different interrupts, but interrupts are relatively
	 * scarce, shareable, and for PCIC controllers, very infrequent.
	 */
	irq = ia->ia_irq;
	if (irq == IRQUNK)
		irq = pcic_intr_find(sc, IST_EDGE);

	if (irq) {
		sc->ih = isa_intr_establish(ic, irq, IST_EDGE, IPL_TTY,
		    pcic_intr, sc, sc->dev.dv_xname);
		if (!sc->ih)
			irq = 0;
	}
	sc->irq = irq;

	if (irq) {
		printf("%s: irq %d, ", sc->dev.dv_xname, irq);

		/* Set up the pcic to interrupt on card detect. */
		for (i = 0; i < PCIC_NSLOTS; i++) {
			h = &sc->handle[i];
			if (h->flags & PCIC_FLAG_SOCKETP) {
				pcic_write(h, PCIC_CSC_INTR,
				    (sc->irq << PCIC_CSC_INTR_IRQ_SHIFT) |
				    PCIC_CSC_INTR_CD_ENABLE);
			}
		}
	} else
		printf("%s: no irq, ", sc->dev.dv_xname);

	printf("polling enabled\n");
	if (sc->poll_established == 0) {
		timeout_set(&sc->poll_timeout, pcic_poll_intr, sc);
		timeout_add_msec(&sc->poll_timeout, 500);
		sc->poll_established = 1;
	}
}
@


1.22
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.21 2010/07/02 04:23:15 blambert Exp $	*/
a32 1
#include <sys/types.h>
@


1.21
log
@timeout_add -> timeout_add_msec
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.20 2005/03/25 16:41:18 mickey Exp $	*/
a223 1
				powerhook_establish(pcic_power, h);
@


1.20
log
@during probe test for a mem window reduction in case there is not enough space in the hole for a large one (ie generic now boots same as ramdisk on some machinesw/ lots of bios); found and testing by niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.19 2005/01/27 17:03:23 millert Exp $	*/
d233 1
a233 1
		timeout_add(&sc->poll_timeout, hz / 2);
@


1.19
log
@Add pcmcia_intr_string() to format the intr string for pcmcia attach
routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.18 2004/01/09 21:32:23 brad Exp $	*/
d93 1
a93 1
	bus_space_tag_t iot = ia->ia_iot;
d95 1
d108 8
a115 2
	if (bus_space_map(ia->ia_memt, ia->ia_maddr, ia->ia_msize, 0, &memh))
		return (0);
d144 1
a144 1
	bus_space_unmap(ia->ia_memt, memh, ia->ia_msize);
d149 1
@


1.18
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.17 2002/03/14 03:16:05 millert Exp $	*/
a63 4
void	*pcic_isa_chip_intr_establish(pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *);
void	pcic_isa_chip_intr_disestablish(pcmcia_chipset_handle_t, void *);

d81 1
@


1.17
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.16 2002/03/14 01:26:56 millert Exp $	*/
a39 2

#include <uvm/uvm_extern.h>
@


1.16
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.15 2001/11/06 19:53:19 miod Exp $	*/
d66 2
a67 2
void	*pcic_isa_chip_intr_establish __P((pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *));
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.14 2001/09/21 17:55:43 miod Exp $	*/
d63 2
a64 2
int	pcic_isa_probe __P((struct device *, void *, void *));
void	pcic_isa_attach __P((struct device *, struct device *, void *));
d68 1
a68 1
void	pcic_isa_chip_intr_disestablish __P((pcmcia_chipset_handle_t, void *));
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.15 2001/11/06 19:53:19 miod Exp $	*/
d63 2
a64 2
int	pcic_isa_probe(struct device *, void *, void *);
void	pcic_isa_attach(struct device *, struct device *, void *);
d66 3
a68 3
void	*pcic_isa_chip_intr_establish(pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *);
void	pcic_isa_chip_intr_disestablish(pcmcia_chipset_handle_t, void *);
@


1.14
log
@Correct some pryntf() usage: get the correct number of arguments in the
correct order.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.13 2001/08/17 21:52:16 deraadt Exp $	*/
d41 1
a41 1
#include <vm/vm.h>
@


1.13
log
@quieten pcmcia/cardbus interrupt handling at unsuspend time
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.12 2000/07/03 02:59:24 aaron Exp $	*/
d227 1
a227 1
	printf("polling enabled\n", sc->dev.dv_xname);
@


1.12
log
@From NetBSD:

- Fix an incorrect interrupt sharing type.
- Always clear PCIC_INTR_ENABLE; it doesn't do what one might think.
- Eliminate stray interrupts during the IRQ probe.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.11 2000/06/28 17:48:10 aaron Exp $	*/
d67 1
a67 1
	    struct pcmcia_function *, int, int (*) (void *), void *));
@


1.11
log
@Make suspend -> eject card -> resume work.

On suspend, the apm code calls each function in its powerhook list. This list
contains pointers to functions that are to be executed on PWR_SUSPEND and
PWR_RESUME. One of these functions is pcmcia_power() which calls xxx_activate()
for each PC Card that is connected with the action DVACT_ACTIVATE (where xxx
is the name of the driver for the PC Card). On resume, the same thing happens,
except the action is DVACT_ACTIVATE.

Clearly, if a card is gone when we resume, trying to activate it is a bad idea.
This commit adds a pcic_power() function that runs before pcmcia_power(). On
resume, it uses pcic_intr_socket() to detect any events that occurred while we
were suspended. (I had to split pcic_event_thread() into a threaded part and
a non-threaded part, since the thread will not run when we are in interrupt
context, but I need the events to be processed before pcmcia_power() runs.) So,
by the time pcic_power() is through, all events that occurred during suspend
have been processed, and pcmcia_power() will not try to activate cards that are
not there since they have already been completely and properly detached.

Note that event handling for card removals first calls the deactivate functions
on the card then the detach functions. When we suspend, apm does the deactivate
for us. So on resume, if we detect a card has been removed, we skip the
deactivation step and just detach. We use the DVF_ACTIVE bit to determine
whether or not deactivation has already occurred. Deactivating a device that
has already been deactivated causes a panic.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.10 2000/06/23 16:53:08 aaron Exp $	*/
d225 1
a225 1
		printf("%s: no irq, ");
@


1.10
log
@Implement PCMCIA event polling. This will either complement interrupt-driven
event notification from the pcic (if an interrupt is available) or allow the
insertion and removal of PCMCIA devices even if there is no IRQ for the pcic.
Each socket is checked for status change every 0.5 seconds using art's timeout
code. Insertion and removal events should no longer ever go unnoticed.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.9 1999/08/11 12:02:07 niklas Exp $	*/
d221 1
@


1.9
log
@New pcmcia irq prober that really tries to ensure the irq will work
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.8 1999/07/26 05:43:16 deraadt Exp $	*/
d36 1
d212 1
a212 1
		printf("%s: irq %d\n", sc->dev.dv_xname, irq);
d224 8
a231 1
		printf("%s: no irq\n", sc->dev.dv_xname);
@


1.9.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.12 2000/07/03 02:59:24 aaron Exp $	*/
a35 1
#include <sys/kernel.h>
d211 1
a211 1
		printf("%s: irq %d, ", sc->dev.dv_xname, irq);
a219 1
				powerhook_establish(pcic_power, h);
d223 1
a223 8
		printf("%s: no irq, ", sc->dev.dv_xname);

	printf("polling enabled\n", sc->dev.dv_xname);
	if (sc->poll_established == 0) {
		timeout_set(&sc->poll_timeout, pcic_poll_intr, sc);
		timeout_add(&sc->poll_timeout, hz / 2);
		sc->poll_established = 1;
	}
@


1.9.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.9.4.1 2001/05/14 22:24:37 niklas Exp $	*/
d67 1
a67 1
	    struct pcmcia_function *, int, int (*) (void *), void *, char *));
d227 1
a227 1
	printf("polling enabled\n");
@


1.9.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#include <uvm/uvm_extern.h>
@


1.9.4.4
log
@Merge in -current from about a week ago
@
text
@d63 2
a64 2
int	pcic_isa_probe(struct device *, void *, void *);
void	pcic_isa_attach(struct device *, struct device *, void *);
d66 3
a68 3
void	*pcic_isa_chip_intr_establish(pcmcia_chipset_handle_t,
	    struct pcmcia_function *, int, int (*) (void *), void *, char *);
void	pcic_isa_chip_intr_disestablish(pcmcia_chipset_handle_t, void *);
@


1.9.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d41 2
@


1.8
log
@shrink code, cleanup port printouts, repairs various comments
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.7 1999/01/28 07:51:36 fgsch Exp $	*/
d154 2
a155 1
	struct pcic_softc *sc = (void *) self;
d162 1
a162 1
	int i;
d180 1
a180 1
	sc->pct = (pcmcia_chipset_tag_t) & pcic_isa_functions;
d190 1
a190 1
	pcic_isa_bus_width_probe (sc, iot, ioh, ia->ia_iobase, ia->ia_iosize);
a193 4
	 * We allocate the card event IRQ late because it is more important
	 * that the cards will get their interrupt than that we get a
	 * card event interrupt vector that works.
	 *
d198 11
d210 2
a211 14
	if ((sc->irq = ia->ia_irq) == IRQUNK) {
		for (i = 0; i < npcic_isa_intr_list; i++)
			if (isa_intr_check(ic, pcic_isa_intr_list[i],
			    IST_EDGE) == 2)
				goto found;
		for (i = 0; i < npcic_isa_intr_list; i++)
			if (isa_intr_check(ic, pcic_isa_intr_list[i],
			    IST_EDGE) == 1)
				goto found;
		printf("%s: no irq\n", sc->dev.dv_xname);
		return;
found:
		sc->irq = pcic_isa_intr_list[i];
	}
d213 10
a222 5
	sc->ih = isa_intr_establish(ic, sc->irq, IST_EDGE, IPL_TTY,
	    pcic_intr, sc, sc->dev.dv_xname);
	if (sc->ih)
		printf("%s: irq %d\n", sc->dev.dv_xname, sc->irq);
	else
@


1.7
log
@Remove unused vars.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.6 1999/01/07 02:28:15 niklas Exp $	*/
a112 1

a120 1

a121 1

a124 1

a125 1

a126 1

a129 1

a130 1

a131 1

a134 1

a135 1

a136 1

a139 1

a144 1

a145 1

@


1.6
log
@Delayed irq allocation for pcic, gives pccard devices better chance of getting
working interrupts on laptops where some are not wired to the pccard controller
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.5 1999/01/01 08:05:46 fgsch Exp $	*/
d57 1
a57 2
int	pcicisa_debug = 1 /* XXX */ ;
#define	DPRINTF(arg) if (pcicisa_debug) printf arg;
a217 2
		int ist = IST_EDGE;

d219 2
a220 2
			if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) ==
			    2)
d223 2
a224 2
			if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) ==
			    1)
@


1.5
log
@Don't print irq twice if it's defined in the config-file.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.4 1998/12/31 12:09:02 fgsch Exp $	*/
d202 6
d209 5
a213 1
	 * allocate an irq.  it will be used by both controllers.  I could
d222 2
a223 1
			if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) == 2)
d226 2
a227 1
			if (isa_intr_check(ic, pcic_isa_intr_list[i], ist) == 1)
d229 1
a229 1
		printf("\n%s: can't allocate interrupt\n", sc->dev.dv_xname);
a232 1
		printf(" irq %d", sc->irq);
a234 6
	printf("\n");

	pcic_attach(sc);

	pcic_isa_bus_width_probe (sc, iot, ioh, ia->ia_iobase, ia->ia_iosize);

d237 4
a240 6
	if (sc->ih == NULL) {
		printf("%s: can't establish interrupt\n", sc->dev.dv_xname);
		return;
	}

	pcic_attach_sockets(sc);
@


1.4
log
@Don't panic if the pcic irq is defined in the config-file.
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.3 1998/12/31 09:17:43 deraadt Exp $	*/
d221 1
a222 2

	printf(": using irq %d", sc->irq);
@


1.3
log
@semantic change: prefer unshared intr, settle for level shared. this will still fail in some cases
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.2 1998/12/27 00:27:18 deraadt Exp $	*/
d219 2
a221 3

found:
	sc->irq = pcic_isa_intr_list[i];
@


1.2
log
@new priority mechanism for pcmcia interrupt allocation, ie. "best effort"
for machines low on interrupts. work by fgsch, and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: i82365_isa.c,v 1.1 1998/09/11 08:02:50 fgsch Exp $	*/
d215 1
a215 1
			if (isa_intr_check(ic, pcic_isa_intr_list[i], ist))
@


1.1
log
@ISA routines for the Intel 82365SL PCIC controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d177 1
d209 10
a218 8
		if (isa_intr_alloc(ic,
		    PCIC_CSC_INTR_IRQ_VALIDMASK & pcic_isa_intr_alloc_mask,
		    IST_EDGE, &sc->irq)) {
			printf("\n%s: can't allocate interrupt\n",
			    sc->dev.dv_xname);
			return;
		}
		printf(": using irq %d", sc->irq);
d220 6
@

