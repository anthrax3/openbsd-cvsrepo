head	1.13;
access;
symbols
	OPENBSD_6_2_BASE:1.13
	OPENBSD_6_1:1.12.0.12
	OPENBSD_6_1_BASE:1.12
	OPENBSD_6_0:1.12.0.8
	OPENBSD_6_0_BASE:1.12
	OPENBSD_5_9:1.12.0.2
	OPENBSD_5_9_BASE:1.12
	OPENBSD_5_8:1.12.0.6
	OPENBSD_5_8_BASE:1.12
	OPENBSD_5_7:1.12.0.4
	OPENBSD_5_7_BASE:1.12
	OPENBSD_5_6:1.11.0.20
	OPENBSD_5_6_BASE:1.11
	OPENBSD_5_5:1.11.0.18
	OPENBSD_5_5_BASE:1.11
	OPENBSD_5_4:1.11.0.14
	OPENBSD_5_4_BASE:1.11
	OPENBSD_5_3:1.11.0.12
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.10
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.8
	OPENBSD_5_0:1.11.0.6
	OPENBSD_5_0_BASE:1.11
	OPENBSD_4_9:1.11.0.4
	OPENBSD_4_9_BASE:1.11
	OPENBSD_4_8:1.11.0.2
	OPENBSD_4_8_BASE:1.11
	OPENBSD_4_7:1.10.0.2
	OPENBSD_4_7_BASE:1.10
	OPENBSD_4_6:1.9.0.6
	OPENBSD_4_6_BASE:1.9
	OPENBSD_4_5:1.9.0.2
	OPENBSD_4_5_BASE:1.9
	OPENBSD_4_4:1.8.0.6
	OPENBSD_4_4_BASE:1.8
	OPENBSD_4_3:1.8.0.4
	OPENBSD_4_3_BASE:1.8
	OPENBSD_4_2:1.8.0.2
	OPENBSD_4_2_BASE:1.8
	OPENBSD_4_1:1.7.0.6
	OPENBSD_4_1_BASE:1.7
	OPENBSD_4_0:1.7.0.4
	OPENBSD_4_0_BASE:1.7
	OPENBSD_3_9:1.7.0.2
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.6.0.16
	OPENBSD_3_8_BASE:1.6
	OPENBSD_3_7:1.6.0.14
	OPENBSD_3_7_BASE:1.6
	OPENBSD_3_6:1.6.0.12
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.10
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.8
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	OPENBSD_3_3:1.6.0.6
	OPENBSD_3_3_BASE:1.6
	OPENBSD_3_2:1.6.0.4
	OPENBSD_3_2_BASE:1.6
	OPENBSD_3_1:1.6.0.2
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.6
	UBC:1.5.0.6
	UBC_BASE:1.5
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.3.0.14
	OPENBSD_2_8_BASE:1.3
	OPENBSD_2_7:1.3.0.12
	OPENBSD_2_7_BASE:1.3
	SMP:1.3.0.10
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.8
	OPENBSD_2_6_BASE:1.3
	OPENBSD_2_5:1.3.0.6
	OPENBSD_2_5_BASE:1.3
	OPENBSD_2_4:1.3.0.4
	OPENBSD_2_4_BASE:1.3
	OPENBSD_2_3:1.3.0.2
	OPENBSD_2_3_BASE:1.3
	OPENBSD_2_2:1.2.0.4
	OPENBSD_2_2_BASE:1.2
	OPENBSD_2_1:1.2.0.2
	OPENBSD_2_1_BASE:1.2;
locks; strict;
comment	@ * @;


1.13
date	2017.09.08.05.36.52;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	uRv5pa9QDlZaYgwD;

1.12
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.11;
commitid	uzzBR7hz9ncd4O6G;

1.11
date	2010.06.26.23.24.44;	author guenther;	state Exp;
branches;
next	1.10;

1.10
date	2009.08.26.22.29.09;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2009.01.21.21.54.00;	author grange;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.11.23.11.30.14;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.5;

1.5
date	2001.02.03.07.29.29;	author mickey;	state Exp;
branches
	1.5.6.1;
next	1.4;

1.4
date	2001.01.29.07.10.14;	author mickey;	state Exp;
branches;
next	1.3;

1.3
date	98.01.18.18.58.39;	author niklas;	state Exp;
branches
	1.3.10.1;
next	1.2;

1.2
date	97.04.13.20.22.42;	author mickey;	state Exp;
branches;
next	1.1;

1.1
date	96.11.29.23.51.14;	author niklas;	state Exp;
branches;
next	;

1.3.10.1
date	2001.05.14.22.24.52;	author niklas;	state Exp;
branches;
next	1.3.10.2;

1.3.10.2
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	;

1.5.6.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.13
log
@If you use sys/param.h, you don't need sys/types.h
@
text
@/*	$OpenBSD: uha_isa.c,v 1.12 2014/09/14 14:17:25 jsg Exp $	*/
/*	$NetBSD: uha_isa.c,v 1.5 1996/10/21 22:41:21 thorpej Exp $	*/

/*
 * Copyright (c) 1994, 1996 Charles M. Hannum.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Charles M. Hannum.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <uvm/uvm_extern.h>

#include <machine/bus.h>
#include <machine/intr.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/uhareg.h>
#include <dev/ic/uhavar.h>

#define	UHA_ISA_IOSIZE	16

int	uha_isa_probe(struct device *, void *, void *);
void	uha_isa_attach(struct device *, struct device *, void *);

struct cfattach uha_isa_ca = {
	sizeof(struct uha_softc), uha_isa_probe, uha_isa_attach
};

#define KVTOPHYS(x)	vtophys((vaddr_t)(x))

int u14_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u14_start_mbox(struct uha_softc *, struct uha_mscp *);
int u14_poll(struct uha_softc *, struct scsi_xfer *, int);
int u14_intr(void *);
void u14_init(struct uha_softc *);

/*
 * Check the slots looking for a board we recognise
 * If we find one, note its address (slot) and call
 * the actual probe routine to check it out.
 */
int
uha_isa_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct isa_attach_args *ia = aux;
	struct uha_softc sc;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	int rv;

	if (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))
		return (0);

	rv = u14_find(iot, ioh, &sc);

	bus_space_unmap(iot, ioh, UHA_ISA_IOSIZE);

	if (rv) {
		if (ia->ia_irq != -1 && ia->ia_irq != sc.sc_irq)
			return (0);
		if (ia->ia_drq != -1 && ia->ia_drq != sc.sc_drq)
			return (0);
		ia->ia_irq = sc.sc_irq;
		ia->ia_drq = sc.sc_drq;
		ia->ia_msize = 0;
		ia->ia_iosize = UHA_ISA_IOSIZE;
	}
	return (rv);
}

/*
 * Attach all the sub-devices we can find
 */
void
uha_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct isa_attach_args *ia = aux;
	struct uha_softc *sc = (void *)self;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;
	isa_chipset_tag_t ic = ia->ia_ic;

	printf("\n");

	if (bus_space_map(iot, ia->ia_iobase, UHA_ISA_IOSIZE, 0, &ioh))
		panic("uha_attach: bus_space_map failed!");

	sc->sc_iot = iot;
	sc->sc_ioh = ioh;
	if (!u14_find(iot, ioh, sc))
		panic("uha_attach: u14_find failed!");

	if (sc->sc_drq != -1)
		isadma_cascade(sc->sc_drq);

	sc->sc_ih = isa_intr_establish(ic, sc->sc_irq, IST_EDGE, IPL_BIO,
	    u14_intr, sc, sc->sc_dev.dv_xname);
	if (sc->sc_ih == NULL) {
		printf("%s: couldn't establish interrupt\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* Save function pointers for later use. */
	sc->start_mbox = u14_start_mbox;
	sc->poll = u14_poll;
	sc->init = u14_init;

	uha_attach(sc);
}

/*
 * Start the board, ready for normal operation
 */
int
u14_find(iot, ioh, sc)
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	struct uha_softc *sc;
{
	u_int16_t model, config;
	int irq, drq;
	int resetcount = 4000;	/* 4 secs? */

	model = (bus_space_read_1(iot, ioh, U14_ID + 0) << 8) |
		(bus_space_read_1(iot, ioh, U14_ID + 1) << 0);
	if ((model & 0xfff0) != 0x5640)
		return (0);

	config = (bus_space_read_1(iot, ioh, U14_CONFIG + 0) << 8) |
		 (bus_space_read_1(iot, ioh, U14_CONFIG + 1) << 0);

	switch (model & 0x000f) {
	case 0x0000:
		switch (config & U14_DMA_MASK) {
		case U14_DMA_CH5:
			drq = 5;
			break;
		case U14_DMA_CH6:
			drq = 6;
			break;
		case U14_DMA_CH7:
			drq = 7;
			break;
		default:
			printf("u14_find: illegal drq setting %x\n",
			    config & U14_DMA_MASK);
			return (0);
		}
		break;
	case 0x0001:
		/* This is a 34f, and doesn't need an ISA DMA channel. */
		drq = -1;
		break;
	default:
		printf("u14_find: unknown model %x\n", model);
		return (0);
	}

	switch (config & U14_IRQ_MASK) {
	case U14_IRQ10:
		irq = 10;
		break;
	case U14_IRQ11:
		irq = 11;
		break;
	case U14_IRQ14:
		irq = 14;
		break;
	case U14_IRQ15:
		irq = 15;
		break;
	default:
		printf("u14_find: illegal irq setting %x\n",
		    config & U14_IRQ_MASK);
		return (0);
	}

	bus_space_write_1(iot, ioh, U14_LINT, UHA_ASRST);

	while (--resetcount) {
		if (bus_space_read_1(iot, ioh, U14_LINT))
			break;
		delay(1000);	/* 1 mSec per loop */
	}
	if (!resetcount) {
		printf("u14_find: board timed out during reset\n");
		return (0);
	}

	/* if we want to fill in softc, do so now */
	if (sc != NULL) {
		sc->sc_irq = irq;
		sc->sc_drq = drq;
		sc->sc_scsi_dev = config & U14_HOSTID_MASK;
	}

	return (1);
}

/*
 * Function to send a command out through a mailbox
 */
void
u14_start_mbox(sc, mscp)
	struct uha_softc *sc;
	struct uha_mscp *mscp;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int spincount = 100000;	/* 1s should be enough */

	while (--spincount) {
		if ((bus_space_read_1(iot, ioh, U14_LINT) & U14_LDIP) == 0)
			break;
		delay(100);
	}
	if (!spincount)
		panic("%s: uha_start_mbox, board not responding",
		    sc->sc_dev.dv_xname);

	bus_space_write_4(iot, ioh, U14_OGMPTR, KVTOPHYS(mscp));
	if (mscp->flags & MSCP_ABORT)
		bus_space_write_1(iot, ioh, U14_LINT, U14_ABORT);
	else
		bus_space_write_1(iot, ioh, U14_LINT, U14_OGMFULL);

	if ((mscp->xs->flags & SCSI_POLL) == 0)
		timeout_add_msec(&mscp->xs->stimeout, mscp->timeout);
}

/*
 * Function to poll for command completion when in poll mode.
 *
 *	wait = timeout in msec
 */
int
u14_poll(sc, xs, count)
	struct uha_softc *sc;
	struct scsi_xfer *xs;
	int count;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	while (count) {
		/*
		 * If we had interrupts enabled, would we
		 * have got an interrupt?
		 */
		if (bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP)
			u14_intr(sc);
		if (xs->flags & ITSDONE)
			return (0);
		delay(1000);
		count--;
	}
	return (1);
}

/*
 * Catch an interrupt from the adaptor
 */
int
u14_intr(arg)
	void *arg;
{
	struct uha_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	struct uha_mscp *mscp;
	u_char uhastat;
	u_long mboxval;

#ifdef	UHADEBUG
	printf("%s: uhaintr ", sc->sc_dev.dv_xname);
#endif /*UHADEBUG */

	if ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)
		return (0);

	for (;;) {
		/*
		 * First get all the information and then
		 * acknowledge the interrupt
		 */
		uhastat = bus_space_read_1(iot, ioh, U14_SINT);
		mboxval = bus_space_read_4(iot, ioh, U14_ICMPTR);
		/* XXX Send an ABORT_ACK instead? */
		bus_space_write_1(iot, ioh, U14_SINT, U14_ICM_ACK);

#ifdef	UHADEBUG
		printf("status = 0x%x ", uhastat);
#endif /*UHADEBUG*/

		/*
		 * Process the completed operation
		 */
		mscp = uha_mscp_phys_kv(sc, mboxval);
		if (!mscp) {
			printf("%s: BAD MSCP RETURNED!\n",
			    sc->sc_dev.dv_xname);
			continue;	/* whatever it was, it'll timeout */
		}

		timeout_del(&mscp->xs->stimeout);
		uha_done(sc, mscp);

		if ((bus_space_read_1(iot, ioh, U14_SINT) & U14_SDIP) == 0)
			return (1);
	}
}

void
u14_init(sc)
	struct uha_softc *sc;
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	/* make sure interrupts are enabled */
#ifdef UHADEBUG
	printf("u14_init: lmask=%02x, smask=%02x\n",
	    bus_space_read_1(iot, ioh, U14_LMASK),
	    bus_space_read_1(iot, ioh, U14_SMASK));
#endif
	bus_space_write_1(iot, ioh, U14_LMASK, 0xd1);	/* XXX */
	bus_space_write_1(iot, ioh, U14_SMASK, 0x91);	/* XXX */
}
@


1.12
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.11 2010/06/26 23:24:44 guenther Exp $	*/
a32 1
#include <sys/types.h>
@


1.11
log
@Don't #include <sys/user.h> into files that don't need the stuff
it defines.  In some cases, this means pulling in uvm.h or pcb.h
instead, but most of the inclusions were just noise.  Tested on
alpha, amd64, armish, hppa, i386, macpcc, sgi, sparc64, and vax,
mostly by krw and naddy.
ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.10 2009/08/26 22:29:09 jasper Exp $	*/
a37 1
#include <sys/proc.h>
@


1.10
log
@directly calling Debugger() is bad. turn these printf();Debugger(); series
into panic()'s.

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.9 2009/01/21 21:54:00 grange Exp $	*/
d39 1
a39 1
#include <sys/user.h>
@


1.9
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.8 2007/04/10 17:47:55 miod Exp $	*/
a54 4
#ifndef DDB
#define	Debugger() panic("should call debugger here (uha_isa.c)")
#endif

d255 2
a256 2
	if (!spincount) {
		printf("%s: uha_start_mbox, board not responding\n",
a257 2
		Debugger();
	}
@


1.8
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.7 2005/11/23 11:30:14 mickey Exp $	*/
d272 1
a272 1
		timeout_add(&mscp->xs->stimeout, (mscp->timeout * hz) / 1000);
@


1.7
log
@assume vtophys(vaddr_t) just what all the other archs expect; no functional change
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.6 2002/03/14 01:26:56 millert Exp $	*/
d76 1
a76 1
 * If we find one, note it's address (slot) and call
@


1.6
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.5 2001/02/03 07:29:29 mickey Exp $	*/
d66 1
a66 1
#define KVTOPHYS(x)	vtophys(x)
@


1.5
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.4 2001/01/29 07:10:14 mickey Exp $	*/
d59 2
a60 2
int	uha_isa_probe __P((struct device *, void *, void *));
void	uha_isa_attach __P((struct device *, struct device *, void *));
d68 5
a72 5
int u14_find __P((bus_space_tag_t, bus_space_handle_t, struct uha_softc *));
void u14_start_mbox __P((struct uha_softc *, struct uha_mscp *));
int u14_poll __P((struct uha_softc *, struct scsi_xfer *, int));
int u14_intr __P((void *));
void u14_init __P((struct uha_softc *));
@


1.5.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.5 2001/02/03 07:29:29 mickey Exp $	*/
d59 2
a60 2
int	uha_isa_probe(struct device *, void *, void *);
void	uha_isa_attach(struct device *, struct device *, void *);
d68 5
a72 5
int u14_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u14_start_mbox(struct uha_softc *, struct uha_mscp *);
int u14_poll(struct uha_softc *, struct scsi_xfer *, int);
int u14_intr(void *);
void u14_init(struct uha_softc *);
@


1.4
log
@new timeouts
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.3 1998/01/18 18:58:39 niklas Exp $	*/
d271 1
a271 2
	if ((mscp->xs->flags & SCSI_POLL) == 0) {
		timeout_set(&mscp->xs->stimeout, uha_timeout, mscp);
a272 1
	}
@


1.3
log
@move to current OpenBSD isadma API
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.2 1997/04/13 20:22:42 mickey Exp $	*/
d271 4
a274 2
	if ((mscp->xs->flags & SCSI_POLL) == 0)
		timeout(uha_timeout, mscp, (mscp->timeout * hz) / 1000);
d351 1
a351 1
		untimeout(uha_timeout, mscp);
@


1.3.10.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.5 2001/02/03 07:29:29 mickey Exp $	*/
d272 1
a272 1
		timeout_add(&mscp->xs->stimeout, (mscp->timeout * hz) / 1000);
d349 1
a349 1
		timeout_del(&mscp->xs->stimeout);
@


1.3.10.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d59 2
a60 2
int	uha_isa_probe(struct device *, void *, void *);
void	uha_isa_attach(struct device *, struct device *, void *);
d68 5
a72 5
int u14_find(bus_space_tag_t, bus_space_handle_t, struct uha_softc *);
void u14_start_mbox(struct uha_softc *, struct uha_mscp *);
int u14_poll(struct uha_softc *, struct scsi_xfer *, int);
int u14_intr(void *);
void u14_init(struct uha_softc *);
@


1.2
log
@no Debugger() w/ no DDB defined
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.1 1996/11/29 23:51:14 niklas Exp $	*/
d135 1
a135 1
		isa_dmacascade(sc->sc_drq);
@


1.1
log
@Missed in last bus.h commit
@
text
@d1 1
a1 1
/*	$OpenBSD: uha_isa.c,v 1.5 1996/10/21 22:41:21 thorpej Exp $	*/
d54 4
@
