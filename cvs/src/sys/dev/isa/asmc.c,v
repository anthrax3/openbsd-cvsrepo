head	1.31;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.2
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.28.0.2
	OPENBSD_5_9_BASE:1.28;
locks; strict;
comment	@ * @;


1.31
date	2017.02.14.15.47.12;	author jcs;	state Exp;
branches;
next	1.30;
commitid	YpQLZlKJsjGifPtt;

1.30
date	2016.04.22.20.45.53;	author jung;	state Exp;
branches;
next	1.29;
commitid	f1QGODsghBDn967d;

1.29
date	2016.04.19.19.35.06;	author jung;	state Exp;
branches;
next	1.28;
commitid	BWX0yiE8RZFDIupO;

1.28
date	2015.12.27.20.54.53;	author jung;	state Exp;
branches;
next	1.27;
commitid	RvjsEjXx8fuL4HgD;

1.27
date	2015.12.27.20.42.33;	author jung;	state Exp;
branches;
next	1.26;
commitid	UjDeLnHrSxJeZrY8;

1.26
date	2015.12.27.20.26.55;	author jung;	state Exp;
branches;
next	1.25;
commitid	rqAsvdwZXfBxUWrd;

1.25
date	2015.12.27.20.17.39;	author jung;	state Exp;
branches;
next	1.24;
commitid	QGQJNNA6mdt06S4Y;

1.24
date	2015.12.27.20.05.05;	author jung;	state Exp;
branches;
next	1.23;
commitid	aRCgGjlSLqhQjrUJ;

1.23
date	2015.12.27.19.50.14;	author jung;	state Exp;
branches;
next	1.22;
commitid	KzoPyR4CgnfStbLW;

1.22
date	2015.12.22.19.04.42;	author kettenis;	state Exp;
branches;
next	1.21;
commitid	ydJuGFN4oGPlUWST;

1.21
date	2015.12.15.20.58.22;	author jung;	state Exp;
branches;
next	1.20;
commitid	TxTTTHqGf61WU2Wg;

1.20
date	2015.12.15.20.34.33;	author jung;	state Exp;
branches;
next	1.19;
commitid	ByYJgvAllCYEvbdZ;

1.19
date	2015.12.15.20.05.25;	author jung;	state Exp;
branches;
next	1.18;
commitid	BBaz4lVA5qRRdKDK;

1.18
date	2015.12.15.19.46.14;	author jung;	state Exp;
branches;
next	1.17;
commitid	TWfIsc3lR16u8LAX;

1.17
date	2015.12.12.12.34.05;	author jung;	state Exp;
branches;
next	1.16;
commitid	EWH5LX7VXjdB34jy;

1.16
date	2015.12.11.20.36.32;	author jung;	state Exp;
branches;
next	1.15;
commitid	q6ul7KFR1qCZ0mOw;

1.15
date	2015.12.11.20.15.50;	author jung;	state Exp;
branches;
next	1.14;
commitid	NoyaEykY6VAInuNZ;

1.14
date	2015.12.11.20.06.48;	author jung;	state Exp;
branches;
next	1.13;
commitid	05liz1JnevABw3bO;

1.13
date	2015.10.29.13.29.04;	author jung;	state Exp;
branches;
next	1.12;
commitid	eqI1RLk6Otys4GGK;

1.12
date	2015.10.25.19.26.43;	author jung;	state Exp;
branches;
next	1.11;
commitid	l3MwSWTdkfaNth41;

1.11
date	2015.10.15.01.14.33;	author jsg;	state Exp;
branches;
next	1.10;
commitid	AHGTkXOdcGknLyqg;

1.10
date	2015.10.10.12.05.47;	author jung;	state Exp;
branches;
next	1.9;
commitid	S4ZHgbYZpUMClMAe;

1.9
date	2015.10.10.11.57.20;	author jung;	state Exp;
branches;
next	1.8;
commitid	OxgKzVJJrfo1HDNR;

1.8
date	2015.10.04.20.00.50;	author jung;	state Exp;
branches;
next	1.7;
commitid	oEraPJxpLwuFHIfs;

1.7
date	2015.10.04.12.07.58;	author jung;	state Exp;
branches;
next	1.6;
commitid	aloXWFi1INujYE7Q;

1.6
date	2015.10.04.11.41.24;	author jung;	state Exp;
branches;
next	1.5;
commitid	iTC8YSppDGCSCyMu;

1.5
date	2015.10.01.18.41.06;	author jung;	state Exp;
branches;
next	1.4;
commitid	FWYnBUcklEbnZKrs;

1.4
date	2015.10.01.18.31.40;	author jung;	state Exp;
branches;
next	1.3;
commitid	LfQIjvDNDIMJGnAi;

1.3
date	2015.10.01.18.24.28;	author jung;	state Exp;
branches;
next	1.2;
commitid	daftZQwBpkPggP8S;

1.2
date	2015.10.01.15.57.08;	author jsg;	state Exp;
branches;
next	1.1;
commitid	N0w0woDN5IsYDxEO;

1.1
date	2015.09.30.12.15.12;	author jung;	state Exp;
branches;
next	;
commitid	tnJF04bSjCp5bcQB;


desc
@@


1.31
log
@asmc: on system resume, restore the keyboard backlight value

ok various
@
text
@/*	$OpenBSD: asmc.c,v 1.30 2016/04/22 20:45:53 jung Exp $	*/
/*
 * Copyright (c) 2015 Joerg Jung <jung@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Driver for Apple's System Management Controller (SMC) an H8S/2117 chip
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/task.h>
#include <sys/sensors.h>

#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/wscons/wsconsio.h>

#define ASMC_BASE	0x300	/* SMC base address */
#define ASMC_IOSIZE	32	/* I/O region size 0x300-0x31f */

#define ASMC_DATA	0x00	/* SMC data port offset */
#define ASMC_COMMAND	0x04	/* SMC command port offset */
#define ASMC_STATUS	0x1e	/* SMC status port offset */
#define ASMC_INTERRUPT	0x1f	/* SMC interrupt port offset */

#define ASMC_READ	0x10	/* SMC read command */
#define ASMC_WRITE	0x11	/* SMC write command */
#define ASMC_INFO	0x13	/* SMC info/type command */

#define ASMC_OBF	0x01	/* Output buffer full */
#define ASMC_IBF	0x02	/* Input buffer full */
#define ASMC_ACCEPT	0x04

#define ASMC_RETRY	3
#define ASMC_MAXLEN	32	/* SMC maximum data size len */
#define ASMC_NOTFOUND	0x84	/* SMC status key not found */

#define ASMC_MAXTEMP	101	/* known asmc_prods temperature sensor keys */
#define ASMC_MAXFAN	10	/* fan keys with digits 0-9 */
#define ASMC_MAXLIGHT	2	/* left and right light sensor */
#define ASMC_MAXMOTION	3	/* x y z axis motion sensors */

struct asmc_prod {
	const char	*pr_name;
	uint8_t		 pr_light;
	const char	*pr_temp[ASMC_MAXTEMP];
};

struct asmc_softc {
	struct device		 sc_dev;

	bus_space_tag_t		 sc_iot;
	bus_space_handle_t	 sc_ioh;

	struct asmc_prod	*sc_prod;
	uint8_t			 sc_nfans;	/* number of fans */
	uint8_t			 sc_lightlen;	/* light data len */
	uint8_t			 sc_backlight;	/* keyboard backlight value */

	struct rwlock		 sc_lock;
	struct task		 sc_task_backlight;

	struct ksensor		 sc_sensor_temp[ASMC_MAXTEMP];
	struct ksensor		 sc_sensor_fan[ASMC_MAXFAN];
	struct ksensor		 sc_sensor_light[ASMC_MAXLIGHT];
	struct ksensor		 sc_sensor_motion[ASMC_MAXMOTION];
	struct ksensordev	 sc_sensor_dev;
	struct sensor_task	*sc_sensor_task;
};

int	asmc_try(struct asmc_softc *, int, const char *, uint8_t *, uint8_t);
void	asmc_init(struct asmc_softc *);
void	asmc_update(void *);

int	asmc_match(struct device *, void *, void *);
void	asmc_attach(struct device *, struct device *, void *);
int 	asmc_detach(struct device *, int);
int	asmc_activate(struct device *, int);

/* wskbd hook functions */
void	asmc_backlight(void *);
int	asmc_get_backlight(struct wskbd_backlight *);
int	asmc_set_backlight(struct wskbd_backlight *);
extern int (*wskbd_get_backlight)(struct wskbd_backlight *);
extern int (*wskbd_set_backlight)(struct wskbd_backlight *);

const struct cfattach asmc_ca = {
	sizeof(struct asmc_softc), asmc_match, asmc_attach, NULL, asmc_activate
};

struct cfdriver asmc_cd = {
	NULL, "asmc", DV_DULL
};

static struct asmc_prod asmc_prods[] = {
	{ "MacBookAir", 1, {
		"TB0T", "TB1S", "TB1T", "TB2S", "TB2T", "TBXT", "TC0C", "TC0D",
		"TC0E", "TC0F", "TC0P", "TC1C", "TC1E", "TC2C", "TCFP", "TCGC",
		"TCHP", "TCMX", "TCSA", "TCXC", "TCZ3", "TCZ4", "TCZ5", "TG0E",
		"TG1E", "TG2E", "TGZ3", "TGZ4", "TGZ5", "TH0A", "TH0B", "TH0V",
		"TH0a", "TH0b", "THSP", "TM0P", "TN0D", "TPCD", "TS2P", "TTF0",
		"TV0P", "TVFP", "TW0P", "Ta0P", "Th0H", "Th0P", "Th1H", "Tm0P",
		"Tm1P", "Tp0P", "Tp1P", "TpFP", "Ts0P", "Ts0S", NULL }
	},
	{ "MacBookPro", 1, {
		"TA0P", "TA1P", "TALP", "TB0T", "TB1T", "TB2T", "TB3T", "TBXT",
		"TC0C", "TC0D", "TC0E", "TC0F", "TC0P", "TC1C", "TC2C", "TC3C",
		"TC4C", "TCGC", "TCSA", "TCXC", "TG0D", "TG0F", "TG0H", "TG0P",
		"TG0T", "TG1D", "TG1F", "TG1H", "TG1d", "TH0A", "TH0B", "TH0F",
		"TH0R", "TH0V", "TH0a", "TH0b", "TH0c", "TH0x", "THSP", "TM0P",
		"TM0S", "TMCD", "TN0D", "TN0P", "TN0S", "TN1D", "TN1F", "TN1G",
		"TN1S", "TP0P", "TPCD", "TTF0", "TW0P", "Ta0P", "TaSP", "Th0H",
		"Th1H", "Th2H", "Tm0P", "Ts0P", "Ts0S", "Ts1P", "Ts1S", NULL }
	},
	{ "MacBook", 0, {
		"TB0T", "TB1T", "TB2T", "TB3T", "TC0D", "TC0P", "TM0P", "TN0D",
		"TN0P", "TN1P", "TTF0", "TW0P", "Th0H", "Th0S", "Th1H", "ThFH",
		"Ts0P", "Ts0S", NULL }
	},
	{ "MacPro", 0, {
		"TA0P", "TC0C", "TC0D", "TC0P", "TC1C", "TC1D", "TC2C", "TC2D",
		"TC3C", "TC3D", "TCAC", "TCAD", "TCAG", "TCAH", "TCAS", "TCBC",
		"TCBD", "TCBG", "TCBH", "TCBS", "TH0P", "TH1F", "TH1P", "TH1V",
		"TH2F", "TH2P", "TH2V", "TH3F", "TH3P", "TH3V", "TH4F", "TH4P",
		"TH4V", "THPS", "THTG", "TM0P", "TM0S", "TM1P", "TM1S", "TM2P",
		"TM2S", "TM2V", "TM3P", "TM3S", "TM3V", "TM4P", "TM5P", "TM6P",
		"TM6V", "TM7P", "TM7V", "TM8P", "TM8S", "TM8V", "TM9P", "TM9S",
		"TM9V", "TMA1", "TMA2", "TMA3", "TMA4", "TMAP", "TMAS", "TMB1",
		"TMB2", "TMB3", "TMB4", "TMBS", "TMHS", "TMLS", "TMPS", "TMPV",
		"TMTG", "TN0C", "TN0D", "TN0H", "TNTG", "TS0C", "Te1F", "Te1P",
		"Te1S", "Te2F", "Te2S", "Te3F", "Te3S", "Te4F", "Te4S", "Te5F",
		"Te5S", "TeGG", "TeGP", "TeRG", "TeRP", "TeRV", "Tp0C", "Tp1C",
		"TpPS", "TpTG", "Tv0S", "Tv1S", NULL }
	},
	{ "MacMini", 0, {
		"TC0D", "TC0H", "TC0P", "TH0P", "TN0D", "TN0P", "TN1P", "TW0P",
		NULL }
	},
	{ "iMac", 0, {
		"TA0P", "TC0D", "TC0H", "TC0P", "TG0D", "TG0H", "TG0P", "TH0P",
		"TL0P", "TN0D", "TN0H", "TN0P", "TO0P", "TW0P", "Tm0P", "Tp0C",
		"Tp0P", NULL }
	},
	{ NULL, 0, { NULL } }
};

static const char *asmc_temp_desc[][2] = {
	{ "TA0P", "ambient" }, { "TA0P", "hdd bay 1" },
	{ "TA0S", "pci slot 1 pos 1" }, { "TA1P", "ambient 2" },
	{ "TA1S", "pci slot 1 pos 2" }, { "TA2S", "pci slot 2 pos 1" },
	{ "TA3S", "pci slot 2 pos 2" },
	{ "TB0T", "enclosure bottom" }, { "TB1T", "enclosure bottom 2" },
	{ "TB2T", "enclosure bottom 3" }, { "TB3T", "enclosure bottom 4" },
	{ "TC0D", "cpu0 die core" }, { "TC0H", "cpu0 heatsink" },
	{ "TC0P", "cpu0 proximity" },
	{ "TC1D", "cpu1" }, { "TC2D", "cpu2" }, { "TC3D", "cpu3" },
	{ "TCAH", "cpu0" }, { "TCBH", "cpu1" }, { "TCCH", "cpu2" },
	{ "TCDH", "cpu3" },
	{ "TG0D", "gpu0 diode" }, { "TG0H", "gpu0 heatsink" },
	{ "TG0P", "gpu0 proximity" },
	{ "TG1H", "gpu heatsink 2" },
	{ "TH0P", "hdd bay 1" }, { "TH1P", "hdd bay 2" },
	{ "TH2P", "hdd bay 3" }, { "TH3P", "hdd bay 4" },
	{ "TL0P", "lcd proximity"},
	{ "TM0P", "mem bank a1" }, { "TM0S", "mem module a1" },
	{ "TM1P", "mem bank a2" }, { "TM1S", "mem module a2" },
	{ "TM2P", "mem bank a3" }, { "TM2S", "mem module a3" },
	{ "TM3P", "mem bank a4" }, { "TM3S", "mem module a4" },
	{ "TM4P", "mem bank a5" }, { "TM4S", "mem module a5" },
	{ "TM5P", "mem bank a6" }, { "TM5S", "mem module a6" },
	{ "TM6P", "mem bank a7" }, { "TM6S", "mem module a7" },
	{ "TM7P", "mem bank a8" }, { "TM7S", "mem module a8" },
	{ "TM8P", "mem bank b1" }, { "TM8S", "mem module b1" },
	{ "TM9P", "mem bank b2" }, { "TM9S", "mem module b2" },
	{ "TMA1", "ram a1" }, { "TMA2", "ram a2" },
	{ "TMA3", "ram a3" }, { "TMA4", "ram a4" },
	{ "TMB1", "ram b1" }, { "TMB2", "ram b2" },
	{ "TMB3", "ram b3" }, { "TMB4", "ram b4" },
	{ "TMAP", "mem bank b3" }, { "TMAS", "mem module b3" },
	{ "TMBP", "mem bank b4" }, { "TMBS", "mem module b4" },
	{ "TMCP", "mem bank b5" }, { "TMCS", "mem module b5" },
	{ "TMDP", "mem bank b6" }, { "TMDS", "mem module b6" },
	{ "TMEP", "mem bank b7" }, { "TMES", "mem module b7" },
	{ "TMFP", "mem bank b8" }, { "TMFS", "mem module b8" },
	{ "TN0D", "northbridge die core" }, { "TN0H", "northbridge" },
	{ "TN0P", "northbridge proximity" }, { "TN1P", "northbridge 2" },
	{ "TO0P", "optical drive" }, { "TS0C", "expansion slots" },
	{ "TW0P", "wireless airport card" },
	{ "Th0H", "main heatsink a" }, { "Th1H", "main heatsink b" },
	{ "Th2H", "main heatsink c" },
	{ "Tm0P", "memory controller" },
	{ "Tp0C", "power supply 1" }, { "Tp0P", "power supply 1" },
	{ "Tp1C", "power supply 2" }, { "Tp1P", "power supply 2" },
	{ "Tp2P", "power supply 3" }, { "Tp3P", "power supply 4" },
	{ "Tp4P", "power supply 5" }, { "Tp5P", "power supply 6" },
	{ NULL, NULL }
};

static const char *asmc_fan_loc[] = {
	"left lower front", "center lower front", "right lower front",
	"left mid front",   "center mid front",   "right mid front",
	"left upper front", "center upper front", "right upper front",
	"left lower rear",  "center lower rear",  "right lower rear",
	"left mid rear",    "center mid rear",    "right mid rear",
	"left upper rear",  "center upper rear",  "right upper rear"
};

static const char *asmc_light_desc[ASMC_MAXLIGHT] = {
	"left", "right"
};

extern char *hw_vendor, *hw_prod;

int
asmc_match(struct device *parent, void *match, void *aux)
{
	struct asmc_softc *sc = match;
	struct isa_attach_args *ia = aux;
	bus_space_handle_t ioh;
	int i;

	if (!hw_vendor || !hw_prod || strncmp(hw_vendor, "Apple", 5))
		return 0;

	for (i = 0; asmc_prods[i].pr_name && !sc->sc_prod; i++)
		if (!strncasecmp(asmc_prods[i].pr_name, hw_prod,
		    strlen(asmc_prods[i].pr_name)))
			sc->sc_prod = &asmc_prods[i];
	if (!sc->sc_prod)
		return 0;

	if (ia->ia_iobase != ASMC_BASE ||
	    bus_space_map(ia->ia_iot, ia->ia_iobase, ASMC_IOSIZE, 0, &ioh))
		return 0;

	bus_space_unmap(ia->ia_iot, ioh, ASMC_IOSIZE);
	ia->ia_iosize = ASMC_IOSIZE;
	ia->ipa_nio = 1;
	ia->ipa_nmem = 0;
	ia->ipa_nirq = 0;
	ia->ipa_ndrq = 0;

	return 1;
}

void
asmc_attach(struct device *parent, struct device *self, void *aux)
{
	struct asmc_softc *sc = (struct asmc_softc *)self;
	struct isa_attach_args *ia = aux;
	uint8_t buf[6];
	int i, r;

	if (bus_space_map(ia->ia_iot, ia->ia_iobase, ia->ia_iosize, 0,
	    &sc->sc_ioh)) {
		printf(": can't map i/o space\n");
		return;
	}
	sc->sc_iot = ia->ia_iot;

	rw_init(&sc->sc_lock, sc->sc_dev.dv_xname);

	if ((r = asmc_try(sc, ASMC_READ, "REV ", buf, 6))) {
		printf(": revision failed (0x%x)\n", r);
		bus_space_unmap(ia->ia_iot, ia->ia_iobase, ASMC_IOSIZE);
		return;
	}
	printf(": rev %x.%x%x%x", buf[0], buf[1], buf[2],
	    ntohs(*(uint16_t *)buf + 4));

	if ((r = asmc_try(sc, ASMC_READ, "#KEY", buf, 4))) {
		printf(", no of keys failed (0x%x)\n", r);
		bus_space_unmap(ia->ia_iot, ia->ia_iobase, ASMC_IOSIZE);
		return;
	}
	printf(", %u key%s\n", ntohl(*(uint32_t *)buf),
	    (ntohl(*(uint32_t *)buf) == 1) ? "" : "s");

	/* keyboard backlight led is optional */
	sc->sc_backlight = buf[0] = 127, buf[1] = 0;
	if ((r = asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2))) {
		if (r != ASMC_NOTFOUND)
			printf("%s: keyboard backlight failed (0x%x)\n",
			    sc->sc_dev.dv_xname, r);
	} else {
		wskbd_get_backlight = asmc_get_backlight;
		wskbd_set_backlight = asmc_set_backlight;
	}
	task_set(&sc->sc_task_backlight, asmc_backlight, sc);

	strlcpy(sc->sc_sensor_dev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensor_dev.xname));
	for (i = 0; i < ASMC_MAXTEMP; i++) {
		sc->sc_sensor_temp[i].flags |= SENSOR_FINVALID;
		sc->sc_sensor_temp[i].flags |= SENSOR_FUNKNOWN;
	}
	for (i = 0; i < ASMC_MAXFAN; i++) {
		sc->sc_sensor_fan[i].flags |= SENSOR_FINVALID;
		sc->sc_sensor_fan[i].flags |= SENSOR_FUNKNOWN;
	}
	for (i = 0; i < ASMC_MAXLIGHT; i++) {
		sc->sc_sensor_light[i].flags |= SENSOR_FINVALID;
		sc->sc_sensor_light[i].flags |= SENSOR_FUNKNOWN;
	}
	for (i = 0; i < ASMC_MAXMOTION; i++) {
		sc->sc_sensor_motion[i].flags |= SENSOR_FINVALID;
		sc->sc_sensor_motion[i].flags |= SENSOR_FUNKNOWN;
	}
	asmc_init(sc);

	if (!(sc->sc_sensor_task = sensor_task_register(sc, asmc_update, 5))) {
		printf("%s: unable to register task\n", sc->sc_dev.dv_xname);
		bus_space_unmap(ia->ia_iot, ia->ia_iobase, ASMC_IOSIZE);
		return;
	}
	sensordev_install(&sc->sc_sensor_dev);
}

int
asmc_detach(struct device *self, int flags)
{
	struct asmc_softc *sc = (struct asmc_softc *)self;
	uint8_t buf[2] = { (sc->sc_backlight = 0), 0 };
	int i;

	if (sc->sc_sensor_task) {
		sensor_task_unregister(sc->sc_sensor_task);
		sc->sc_sensor_task = NULL;
	}
	sensordev_deinstall(&sc->sc_sensor_dev);
	for (i = 0; i < ASMC_MAXMOTION; i++)
		sensor_detach(&sc->sc_sensor_dev, &sc->sc_sensor_motion[i]);
	for (i = 0; i < ASMC_MAXLIGHT; i++)
		sensor_detach(&sc->sc_sensor_dev, &sc->sc_sensor_light[i]);
	for (i = 0; i < ASMC_MAXFAN; i++)
		sensor_detach(&sc->sc_sensor_dev, &sc->sc_sensor_fan[i]);
	for (i = 0; i < ASMC_MAXTEMP; i++)
		sensor_detach(&sc->sc_sensor_dev, &sc->sc_sensor_temp[i]);

	task_del(systq, &sc->sc_task_backlight);
	asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2);
	return 0;
}

int
asmc_activate(struct device *self, int act)
{
	struct asmc_softc *sc = (struct asmc_softc *)self;

	switch (act) {
	case DVACT_WAKEUP:
		asmc_backlight(sc);
		break;
	}

	return 0;
}

void
asmc_backlight(void *arg)
{
	struct asmc_softc *sc = arg;
	uint8_t buf[2] = { sc->sc_backlight, 0 };
	int r;

	if ((r = asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2)))
		printf("%s: keyboard backlight failed (0x%x)\n",
		    sc->sc_dev.dv_xname, r);
}

int
asmc_get_backlight(struct wskbd_backlight *kbl)
{
	struct asmc_softc *sc = asmc_cd.cd_devs[0];

	KASSERT(sc != NULL);
	kbl->min = 0;
	kbl->max = 0xff;
	kbl->curval = sc->sc_backlight;
	return 0;
}

int
asmc_set_backlight(struct wskbd_backlight *kbl)
{
	struct asmc_softc *sc = asmc_cd.cd_devs[0];

	KASSERT(sc != NULL);
	if (kbl->curval > 0xff)
		return EINVAL;
	sc->sc_backlight = kbl->curval;
	task_add(systq, &sc->sc_task_backlight);
	return 0;
}

static uint8_t
asmc_status(struct asmc_softc *sc)
{
	return bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_STATUS);
}

static int
asmc_wait(struct asmc_softc *sc, uint8_t mask, uint8_t val)
{
	int i;

	for (i = 0; i < 500; i++) { /* wait up to 5 ms */
		if ((bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_COMMAND) &
		    mask) == val)
			return 0;
		delay(10);
	}
	return ETIMEDOUT;
}

static int
asmc_write(struct asmc_softc *sc, uint8_t off, uint8_t val)
{
	if (asmc_wait(sc, ASMC_IBF, 0))
		return 1;
	bus_space_write_1(sc->sc_iot, sc->sc_ioh, off, val);
	if (asmc_wait(sc, ASMC_ACCEPT, ASMC_ACCEPT))
		return 1;
	return 0;
}

static int
asmc_read(struct asmc_softc *sc, uint8_t off, uint8_t *buf)
{
	if (asmc_wait(sc, ASMC_OBF, ASMC_OBF))
		return 1;
	*buf = bus_space_read_1(sc->sc_iot, sc->sc_ioh, off);
	return 0;
}

static int
asmc_command(struct asmc_softc *sc, int cmd, const char *key, uint8_t *buf,
    uint8_t len)
{
	int i;

	if (len > ASMC_MAXLEN)
		return 1;
	if (asmc_write(sc, ASMC_COMMAND, cmd))
		return 1;
	for (i = 0; i < 4; i++)
		if (asmc_write(sc, ASMC_DATA, key[i]))
			return 1;
	if (asmc_write(sc, ASMC_DATA, len))
		return 1;
	if (cmd == ASMC_READ || cmd == ASMC_INFO) {
		for (i = 0; i < len; i++)
			if (asmc_read(sc, ASMC_DATA, &buf[i]))
				return 1;
	} else if (cmd == ASMC_WRITE) {
		for (i = 0; i < len; i++)
			if (asmc_write(sc, ASMC_DATA, buf[i]))
				return 1;
	} else
		return 1;
	return 0;
}

int
asmc_try(struct asmc_softc *sc, int cmd, const char *key, uint8_t *buf,
    uint8_t len)
{
	uint8_t s;
	int i, r;

	rw_enter_write(&sc->sc_lock);
	for (i = 0; i < ASMC_RETRY; i++)
		if (!(r = asmc_command(sc, cmd, key, buf, len)))
			break;
	if (r && (s = asmc_status(sc)))
		r = s;
	rw_exit_write(&sc->sc_lock);

	return r;
}

static uint32_t
asmc_uk(uint8_t *buf)
{
	/* spe78: floating point, signed, 7 bits exponent, 8 bits fraction */
	return (((int16_t)ntohs(*(uint16_t *)buf)) >> 8) * 1000000 + 273150000;
}

static uint16_t
asmc_rpm(uint8_t *buf)
{
	/* fpe2: floating point, unsigned, 14 bits exponent, 2 bits fraction */
	return ntohs(*(uint16_t *)buf) >> 2;
}

static uint32_t
asmc_lux(uint8_t *buf, uint8_t lightlen)
{
	/* newer macbooks report a 10 bit big endian value */
	return (lightlen == 10) ?
	    /* fp18.14: floating point, 18 bits exponent, 14 bits fraction */
	    (ntohl(*(uint32_t *)(buf + 6)) >> 14) * 1000000 :
	    /*
	     * todo: calculate lux from ADC raw data
	     * buf[1] true/false for high/low gain chan reads
	     * chan 0: ntohs(*(uint16_t *)(buf + 2));
	     * chan 1: ntohs(*(uint16_t *)(buf + 4));
	     */
	    ntohs(*(uint16_t *)(buf + 2)) * 1000000;
}

static int
asmc_temp(struct asmc_softc *sc, uint8_t idx, int init)
{
	uint8_t buf[2];
	uint32_t uk;
	int i, r;

	if ((r = asmc_try(sc, ASMC_READ, sc->sc_prod->pr_temp[idx], buf, 2)))
		return r;
	if ((uk = asmc_uk(buf)) < 253150000) /* ignore unlikely values */
		return 0;
	sc->sc_sensor_temp[idx].value = uk;
	sc->sc_sensor_temp[idx].flags &= ~SENSOR_FUNKNOWN;

	if (!init)
		return 0;

	strlcpy(sc->sc_sensor_temp[idx].desc, sc->sc_prod->pr_temp[idx],
	    sizeof(sc->sc_sensor_temp[idx].desc));
	for (i = 0; asmc_temp_desc[i][0]; i++)
		if (!strcmp(asmc_temp_desc[i][0], sc->sc_prod->pr_temp[idx]))
			break;
	if (asmc_temp_desc[i][0]) {
		strlcat(sc->sc_sensor_temp[idx].desc, " ",
		    sizeof(sc->sc_sensor_temp[idx].desc));
		strlcat(sc->sc_sensor_temp[idx].desc, asmc_temp_desc[i][1],
		    sizeof(sc->sc_sensor_temp[idx].desc));
	}
	sc->sc_sensor_temp[idx].type = SENSOR_TEMP;
	sc->sc_sensor_temp[idx].flags &= ~SENSOR_FINVALID;
	sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_temp[idx]);
	return 0;
}

static int
asmc_fan(struct asmc_softc *sc, uint8_t idx, int init)
{
	char key[5];
	uint8_t buf[17], *end;
	int r;

	snprintf(key, sizeof(key), "F%dAc", idx);
	if ((r = asmc_try(sc, ASMC_READ, key, buf, 2)))
		return r;
	sc->sc_sensor_fan[idx].value = asmc_rpm(buf);
	sc->sc_sensor_fan[idx].flags &= ~SENSOR_FUNKNOWN;

	if (!init)
		return 0;

	snprintf(key, sizeof(key), "F%dID", idx);
	if ((r = asmc_try(sc, ASMC_READ, key, buf, 16)))
		return r;
	buf[16] = '\0';
	end = buf + 4 + strlen((char *)buf + 4) - 1;
	while (buf + 4 < end && *end == ' ') /* trim trailing spaces */
		*end-- = '\0';
	strlcpy(sc->sc_sensor_fan[idx].desc, buf + 4,
	    sizeof(sc->sc_sensor_fan[idx].desc));
	if (buf[2] < nitems(asmc_fan_loc)) {
		strlcat(sc->sc_sensor_fan[idx].desc, ", ",
		    sizeof(sc->sc_sensor_fan[idx].desc));
		strlcat(sc->sc_sensor_fan[idx].desc, asmc_fan_loc[buf[2]],
		    sizeof(sc->sc_sensor_fan[idx].desc));
	}
	sc->sc_sensor_fan[idx].type = SENSOR_FANRPM;
	sc->sc_sensor_fan[idx].flags &= ~SENSOR_FINVALID;
	sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_fan[idx]);
	return 0;
}

static int
asmc_light(struct asmc_softc *sc, uint8_t idx, int init)
{
	char key[5];
	uint8_t buf[10];
	int r;

	snprintf(key, sizeof(key), "ALV%d", idx);
	if (!sc->sc_lightlen) {
		if ((r = asmc_try(sc, ASMC_INFO, key, buf, 6)))
			return r;
		if ((sc->sc_lightlen = buf[0]) > 10)
			return 1;
	}
	if ((r = asmc_try(sc, ASMC_READ, key, buf, sc->sc_lightlen)))
		return r;
	if (!buf[0]) /* valid data? */
		return 0;
	sc->sc_sensor_light[idx].value = asmc_lux(buf, sc->sc_lightlen);
	sc->sc_sensor_light[idx].flags &= ~SENSOR_FUNKNOWN;

	if (!init)
		return 0;

	strlcpy(sc->sc_sensor_light[idx].desc, asmc_light_desc[idx],
	    sizeof(sc->sc_sensor_light[idx].desc));
	sc->sc_sensor_light[idx].type = SENSOR_LUX;
	sc->sc_sensor_light[idx].flags &= ~SENSOR_FINVALID;
	sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_light[idx]);
	return 0;
}

#if 0 /* todo: implement motion sensors update and initialization */
static int
asmc_motion(struct asmc_softc *sc, uint8_t idx, int init)
{
	char key[5];
	uint8_t buf[2];
	int r;

	snprintf(key, sizeof(key), "MO_%c", 88 + idx); /* X, Y, Z */
	if ((r = asmc_try(sc, ASMC_READ, key, buf, 2)))
		return r;
	sc->sc_sensor_motion[idx].value = 0;
	sc->sc_sensor_motion[idx].flags &= ~SENSOR_FUNKNOWN;

	if (!init)
		return 0;

	/* todo: setup and attach sensors and description */
	strlcpy(sc->sc_sensor_motion[idx].desc, 120 + idx, /* x, y, z */
	    sizeof(sc->sc_sensor_motion[idx].desc));
	strlcat(sc->sc_sensor_motion[idx].desc, "-axis",
	    sizeof(sc->sc_sensor_motion[idx].desc));
	sc->sc_sensor_motion[idx].type = SENSOR_ACCEL;
	sc->sc_sensor_motion[idx].flags &= ~SENSOR_FINVALID;
	sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_motion[idx]);
	return 0;
}
#endif

void
asmc_init(struct asmc_softc *sc)
{
	uint8_t buf[2];
	int i, r;

	/* number of temperature sensors depends on product */
	for (i = 0; sc->sc_prod->pr_temp[i] && i < ASMC_MAXTEMP; i++)
		if ((r = asmc_temp(sc, i, 1)) && r != ASMC_NOTFOUND)
			printf("%s: read temp %d failed (0x%x)\n",
			    sc->sc_dev.dv_xname, i, r);
	/* number of fan sensors depends on product */
	if ((r = asmc_try(sc, ASMC_READ, "FNum", buf, 1)))
		printf("%s: read FNum failed (0x%x)\n",
		    sc->sc_dev.dv_xname, r);
	else
		sc->sc_nfans = buf[0];
	for (i = 0; i < sc->sc_nfans && i < ASMC_MAXFAN; i++)
		if ((r = asmc_fan(sc, i, 1)) && r != ASMC_NOTFOUND)
			printf("%s: read fan %d failed (0x%x)\n",
			    sc->sc_dev.dv_xname, i, r);
	/* left and right light sensors are optional */
	for (i = 0; sc->sc_prod->pr_light && i < ASMC_MAXLIGHT; i++)
		if ((r = asmc_light(sc, i, 1)) && r != ASMC_NOTFOUND)
			printf("%s: read light %d failed (0x%x)\n",
			    sc->sc_dev.dv_xname, i, r);
	/* motion sensors are optional */
	if ((r = asmc_try(sc, ASMC_READ, "MOCN", buf, 2)) &&
	    r != ASMC_NOTFOUND)
		printf("%s: read MOCN failed (0x%x)\n",
		    sc->sc_dev.dv_xname, r);
#if 0 /* todo: initialize sudden motion sensors and setup interrupt handling */
	buf[0] = 0xe0, buf[1] = 0xf8;
	if ((r = asmc_try(sc, ASMC_WRITE, "MOCN", buf, 2)))
		printf("%s write MOCN failed (0x%x)\n",
		    sc->sc_dev.dv_xname, r);
	for (i = 0; i < ASMC_MAXMOTION; i++)
		if ((r = asmc_motion(sc, i, 1)) && r != ASMC_NOTFOUND)
			printf("%s: read motion %d failed (0x%x)\n",
			    sc->sc_dev.dv_xname, i, r);
#endif
}

void
asmc_update(void *arg)
{
	struct asmc_softc *sc = arg;
	int i;

	for (i = 0; sc->sc_prod->pr_temp[i] && i < ASMC_MAXTEMP; i++)
		if (!(sc->sc_sensor_temp[i].flags & SENSOR_FINVALID))
			asmc_temp(sc, i, 0);
	for (i = 0; i < sc->sc_nfans && i < ASMC_MAXFAN; i++)
		if (!(sc->sc_sensor_fan[i].flags & SENSOR_FINVALID))
			asmc_fan(sc, i, 0);
	for (i = 0; i < ASMC_MAXLIGHT; i++)
		if (!(sc->sc_sensor_light[i].flags & SENSOR_FINVALID))
			asmc_light(sc, i, 0);
#if 0
	for (i = 0; i < ASMC_MAXMOTION; i++)
		if (!(sc->sc_sensor_motion[i].flags & SENSOR_FINVALID))
			asmc_motion(sc, i, 0);
#endif
}
@


1.30
log
@do not try to probe light sensors for machines with none available, this was
already fixed in -r1.7 (for kettenis macmini), but since then the code was
heavily shuffled and moved around and this regression was re-introduced

choose a different fix now and introduce a light sensor flag for the different
models to allow or avoid the probing

prodded by landry (macmini again)
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.29 2016/04/19 19:35:06 jung Exp $	*/
d95 1
d105 1
a105 1
	sizeof(struct asmc_softc), asmc_match, asmc_attach
d359 14
@


1.29
log
@lower case temperature descriptions and separate fan description from fan
location by a comma to avoid ambiguity with newer models

hint from kettenis (last year)
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.28 2015/12/27 20:54:53 jung Exp $	*/
d62 1
d112 1
a112 1
	{ "MacBookAir", {
d121 1
a121 1
	{ "MacBookPro", {
d131 1
a131 1
	{ "MacBook", {
d136 1
a136 1
	{ "MacPro", {
d151 1
a151 1
	{ "MacMini", {
d155 1
a155 1
	{ "iMac", {
d160 1
a160 1
	{ NULL, { NULL } }
d668 1
a668 1
	for (i = 0; i < ASMC_MAXLIGHT; i++)
@


1.28
log
@set sensor type later on init
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.27 2015/12/27 20:42:33 jung Exp $	*/
d163 48
a210 48
	{ "TA0P", "Ambient" }, { "TA0P", "HDD Bay 1" },
	{ "TA0S", "PCI Slot 1 Pos 1" }, { "TA1P", "Ambient 2" },
	{ "TA1S", "PCI Slot 1 Pos 2" }, { "TA2S", "PCI Slot 2 Pos 1" },
	{ "TA3S", "PCI Slot 2 Pos 2" },
	{ "TB0T", "Enclosure Bottom" }, { "TB1T", "Enclosure Bottom 2" },
	{ "TB2T", "Enclosure Bottom 3" }, { "TB3T", "Enclosure Bottom 4" },
	{ "TC0D", "CPU0 Die Core" }, { "TC0H", "CPU0 Heatsink" },
	{ "TC0P", "CPU0 Proximity" },
	{ "TC1D", "CPU1" }, { "TC2D", "CPU2" }, { "TC3D", "CPU3" },
	{ "TCAH", "CPU0" }, { "TCBH", "CPU1" }, { "TCCH", "CPU2" },
	{ "TCDH", "CPU3" },
	{ "TG0D", "GPU0 Diode" }, { "TG0H", "GPU0 Heatsink" },
	{ "TG0P", "GPU0 Proximity" },
	{ "TG1H", "GPU Heatsink 2" },
	{ "TH0P", "HDD Bay 1" }, { "TH1P", "HDD Bay 2" },
	{ "TH2P", "HDD Bay 3" }, { "TH3P", "HDD Bay 4" },
	{ "TL0P", "LCD Proximity"},
	{ "TM0P", "Mem Bank A1" }, { "TM0S", "Mem module A1" },
	{ "TM1P", "Mem Bank A2" }, { "TM1S", "Mem module A2" },
	{ "TM2P", "Mem Bank A3" }, { "TM2S", "Mem module A3" },
	{ "TM3P", "Mem Bank A4" }, { "TM3S", "Mem module A4" },
	{ "TM4P", "Mem Bank A5" }, { "TM4S", "Mem module A5" },
	{ "TM5P", "Mem Bank A6" }, { "TM5S", "Mem module A6" },
	{ "TM6P", "Mem Bank A7" }, { "TM6S", "Mem module A7" },
	{ "TM7P", "Mem Bank A8" }, { "TM7S", "Mem module A8" },
	{ "TM8P", "Mem Bank B1" }, { "TM8S", "Mem module B1" },
	{ "TM9P", "Mem Bank B2" }, { "TM9S", "Mem module B2" },
	{ "TMA1", "RAM A1" }, { "TMA2", "RAM A2" },
	{ "TMA3", "RAM A3" }, { "TMA4", "RAM A4" },
	{ "TMB1", "RAM B1" }, { "TMB2", "RAM B2" },
	{ "TMB3", "RAM B3" }, { "TMB4", "RAM B4" },
	{ "TMAP", "Mem Bank B3" }, { "TMAS", "Mem module B3" },
	{ "TMBP", "Mem Bank B4" }, { "TMBS", "Mem module B4" },
	{ "TMCP", "Mem Bank B5" }, { "TMCS", "Mem module B5" },
	{ "TMDP", "Mem Bank B6" }, { "TMDS", "Mem module B6" },
	{ "TMEP", "Mem Bank B7" }, { "TMES", "Mem module B7" },
	{ "TMFP", "Mem Bank B8" }, { "TMFS", "Mem module B8" },
	{ "TN0D", "Northbridge Die Core" }, { "TN0H", "Northbridge" },
	{ "TN0P", "Northbridge Proximity" }, { "TN1P", "Northbridge 2" },
	{ "TO0P", "Optical Drive" }, { "TS0C", "Expansion Slots" },
	{ "TW0P", "Wireless Airport Card" },
	{ "Th0H", "Main Heatsink A" }, { "Th1H", "Main Heatsink B" },
	{ "Th2H", "Main Heatsink C" },
	{ "Tm0P", "Memory Controller" },
	{ "Tp0C", "Power supply 1" }, { "Tp0P", "Power supply 1" },
	{ "Tp1C", "Power supply 2" }, { "Tp1P", "Power supply 2" },
	{ "Tp2P", "Power supply 3" }, { "Tp3P", "Power supply 4" },
	{ "Tp4P", "Power supply 5" }, { "Tp5P", "Power supply 6" },
d573 1
a573 1
		strlcat(sc->sc_sensor_fan[idx].desc, " ",
@


1.27
log
@fold for loops back into a wait function in a similar manner as acpiec does
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.26 2015/12/27 20:26:55 jung Exp $	*/
a308 1
		sc->sc_sensor_temp[i].type = SENSOR_TEMP;
a312 1
		sc->sc_sensor_fan[i].type = SENSOR_FANRPM;
a316 1
		sc->sc_sensor_light[i].type = SENSOR_LUX;
a320 1
		sc->sc_sensor_motion[i].type = SENSOR_ACCEL;
d541 1
d578 1
d610 1
d638 1
@


1.26
log
@rename kbdled to backlight and mention chip model in comment
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.25 2015/12/27 20:17:39 jung Exp $	*/
d408 1
a408 1
asmc_write(struct asmc_softc *sc, uint8_t off, uint8_t val)
a409 1
	uint8_t str;
d412 4
a415 4
	for (i = 500; i > 0; i--) {
		str = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_COMMAND);
		if ((str & ASMC_IBF) == 0)
			break;
d418 2
a419 2
	if (i == 0)
		return ETIMEDOUT;
d421 5
d427 2
a428 10

	for (i = 500; i > 0; i--) {
		str = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_COMMAND);
		if (str & ASMC_ACCEPT)
			break;
		delay(10);
	}
	if (i == 0)
		return ETIMEDOUT;

d435 2
a436 12
	uint8_t str;
	int i;

	for (i = 500; i > 0; i--) {
		str = bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_COMMAND);
		if (str & ASMC_OBF)
			break;
		delay(10);
	}
	if (i == 0)
		return ETIMEDOUT;

@


1.25
log
@extra taskq is gone, so also remove the no longer needed init variable
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.24 2015/12/27 20:05:05 jung Exp $	*/
d19 1
a19 1
 * Driver for Apple's System Management Controller (SMC)
d74 1
a74 1
	uint8_t			 sc_kbdled;	/* backlight led value */
d96 1
a96 1
void	asmc_kbdled(void *);
d295 1
a295 1
	sc->sc_kbdled = buf[0] = 127, buf[1] = 0;
d304 1
a304 1
	task_set(&sc->sc_task_backlight, asmc_kbdled, sc);
d342 1
a342 1
	uint8_t buf[2] = { (sc->sc_kbdled = 0), 0 };
d365 1
a365 1
asmc_kbdled(void *arg)
d368 1
a368 1
	uint8_t buf[2] = { sc->sc_kbdled, 0 };
d384 1
a384 1
	kbl->curval = sc->sc_kbdled;
d396 1
a396 1
	sc->sc_kbdled = kbl->curval;
@


1.24
log
@simplify and unify keyboard backlight hooks, doing the same kassert instead of
for-loop as acpithinkpad does
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.23 2015/12/27 19:50:14 jung Exp $	*/
a71 1
	uint8_t			 sc_init;	/* initialization done? */
d532 1
a532 1
asmc_temp(struct asmc_softc *sc, uint8_t idx)
d545 1
a545 1
	if (sc->sc_init)
d565 1
a565 1
asmc_fan(struct asmc_softc *sc, uint8_t idx)
d577 1
a577 1
	if (sc->sc_init)
d601 1
a601 1
asmc_light(struct asmc_softc *sc, uint8_t idx)
d621 1
a621 1
	if (sc->sc_init)
d633 1
a633 1
asmc_motion(struct asmc_softc *sc, uint8_t idx)
d645 1
a645 1
	if (sc->sc_init)
d667 1
a667 1
		if ((r = asmc_temp(sc, i)) && r != ASMC_NOTFOUND)
d677 1
a677 1
		if ((r = asmc_fan(sc, i)) && r != ASMC_NOTFOUND)
d682 1
a682 1
		if ((r = asmc_light(sc, i)) && r != ASMC_NOTFOUND)
d696 1
a696 1
		if ((r = asmc_motion(sc, i)) && r != ASMC_NOTFOUND)
a699 1
	sc->sc_init = 1;
d710 1
a710 1
			asmc_temp(sc, i);
d713 1
a713 1
			asmc_fan(sc, i);
d716 1
a716 1
			asmc_light(sc, i);
d720 1
a720 1
			asmc_motion(sc, i);
@


1.23
log
@with Mark's fix in previous commit the extra taskq for delayed initialization
and updates is no longer needed and can be removed, so simplify things and
initialize the sensors on attach and update them through the sensors task
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.22 2015/12/22 19:04:42 kettenis Exp $	*/
d380 1
a380 8
	struct asmc_softc *sc = NULL;
	int i;

	for (i = 0; i < asmc_cd.cd_ndevs && !sc; i++)
		if (asmc_cd.cd_devs[i])
			sc = (struct asmc_softc *)asmc_cd.cd_devs[i];
	if (!sc)
		return -1;
d382 1
d392 1
a392 8
	struct asmc_softc *sc = NULL;
	int i;

	for (i = 0; i < asmc_cd.cd_ndevs && !sc; i++)
		if (asmc_cd.cd_devs[i])
			sc = (struct asmc_softc *)asmc_cd.cd_devs[i];
	if (!sc)
		return -1;
d394 1
@


1.22
log
@The Apple SMC is implemented on a H8S/2117 chip.  Communication with the chip
becomes much more reliably if we pay attention to the IBF and OBF flags.
This removes the need for excessive delays and retries, making operations
complete in microseconds instead of seconds.

This diff also removes flushing the read buffer after a read operations.  This
doesn't seem to be necessary, but we might need to put that back if the
length of a reply changes for some keys.

ok jung@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.21 2015/12/15 20:58:22 jung Exp $	*/
a77 3
	struct taskq		*sc_taskq;
	struct task		 sc_task_init;
	struct task		 sc_task_refresh;
d89 1
a89 3

void	asmc_init(void *);
void	asmc_refresh(void *);
a304 8

	if (!(sc->sc_taskq = taskq_create("asmc", 1, IPL_NONE, 0))) {
		printf("%s: can't create task queue\n", sc->sc_dev.dv_xname);
		bus_space_unmap(ia->ia_iot, ia->ia_iobase, ASMC_IOSIZE);
		return;
	}
	task_set(&sc->sc_task_init, asmc_init, sc);
	task_set(&sc->sc_task_refresh, asmc_refresh, sc);
d329 2
a332 1
		taskq_destroy(sc->sc_taskq);
a336 1
	task_add(sc->sc_taskq, &sc->sc_task_init);
a360 6
	if (sc->sc_taskq) {
		task_del(sc->sc_taskq, &sc->sc_task_refresh);
		task_del(sc->sc_taskq, &sc->sc_task_init);
		taskq_destroy(sc->sc_taskq);
	}

d673 1
a673 1
asmc_init(void *arg)
a674 1
	struct asmc_softc *sc = arg;
d717 1
a717 1
asmc_refresh(void *arg)
a735 9
}

void
asmc_update(void *arg)
{
	struct asmc_softc *sc = arg;

	if (sc->sc_init)
		task_add(sc->sc_taskq, &sc->sc_task_refresh);
@


1.21
log
@ignore unlikely temperature values like -127 degC
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.20 2015/12/15 20:34:33 jung Exp $	*/
d47 5
a51 1
#define ASMC_RETRY	10
a391 1
#if 0 /* todo: write error, as no 0x04 wait status, but led is changed */
a393 2
#endif
		;
d440 1
a440 1
asmc_wait(struct asmc_softc *sc, uint8_t m)
d442 2
a443 1
	int us;
d445 5
a449 6
	for (us = (2 << 4); us < (2 << 16); us *= 2) { /* wait up to 128 ms */
		(!sc->sc_sensor_task) ? delay(us) :
		    tsleep(&sc->sc_taskq, 0, "asmc",
		        (us * hz + 999999) / 1000000 + 1);
		if (bus_space_read_1(sc->sc_iot, sc->sc_ioh, ASMC_COMMAND) & m)
			return 1;
d451 2
a452 2
	return 0;
}
a453 3
static int
asmc_write(struct asmc_softc *sc, uint8_t off, uint8_t val)
{
d455 11
a465 3
	if (asmc_wait(sc, 0x04)) /* write accepted? */
		return 0;
	return 1;
d471 8
a478 3
	if (asmc_wait(sc, 0x01)) { /* ready for read? */
		*buf = bus_space_read_1(sc->sc_iot, sc->sc_ioh, off);
		return 0;
d480 5
a484 1
	return 1;
a490 1
	uint8_t n;
a505 3
		for (i = 0; i < ASMC_MAXLEN; i++) /* sanity flush */
			if (asmc_read(sc, ASMC_DATA, &n))
				break;
d529 1
a529 3
	if (sc->sc_sensor_task) /* give kbdled a chance to grab the lock */
		tsleep(&sc->sc_taskq, 0, "asmc",
		    (1 * hz + 999999) / 1000000 + 1);
@


1.20
log
@add 2 more temperature keys found in macbook pro (10,2)
found via key dump diff, run by Bryan Vyhmeister

also remove 3 temperature keys which likely do not return useful values
verified with help from macbook pro output of tb (4,1 and 5,5),
kettenis (12,1), and Cristoph R. Murauer (9,1) via misc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.19 2015/12/15 20:05:25 jung Exp $	*/
d558 1
d563 3
a565 1
	sc->sc_sensor_temp[idx].value = asmc_uk(buf);
@


1.19
log
@add more temperature keys found in newer macbook airs (6,1 and 7,2)

encountered via key dump diff, run by Bryan Vyhmeister
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.18 2015/12/15 19:46:14 jung Exp $	*/
d123 8
a130 9
		"TA0P", "TALP", "TB0T", "TB1T", "TB2T", "TB3T", "TBXT", "TC0C",
		"TC0D", "TC0E", "TC0F", "TC0P", "TC1C", "TC2C", "TC3C", "TC4C",
		"TCFC", "TCGC", "TCSA", "TCTD", "TCXC", "TG0D", "TG0F", "TG0H",
		"TG0P", "TG0T", "TG1D", "TG1F", "TG1H", "TG1d", "TH0A", "TH0B",
		"TH0F", "TH0R", "TH0V", "TH0a", "TH0b", "TH0c", "THSP", "TM0P",
		"TM0S", "TMBS", "TMCD", "TN0D", "TN0P", "TN0S", "TN1D", "TN1F",
		"TN1G", "TN1S", "TP0P", "TPCD", "TTF0", "TW0P", "Ta0P", "TaSP",
		"Th0H", "Th1H", "Th2H", "Tm0P", "Ts0P", "Ts0S", "Ts1P", "Ts1S",
		NULL }
@


1.18
log
@make sure the read fan description is always nul terminated
hint from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.17 2015/12/12 12:34:05 jung Exp $	*/
d114 7
a120 6
		"TB0T", "TB1S", "TB1T", "TB2S", "TB2T", "TC0C", "TC0D", "TC0E",
		"TC0F", "TC0P", "TC1C", "TC1E", "TC2C", "TCFP", "TCGC", "TCSA",
		"TCZ3", "TCZ4", "TCZ5", "TG0E", "TG1E", "TG2E", "TGZ3", "TGZ4",
		"TGZ5", "THSP", "TM0P", "TN0D", "TPCD", "TTF0", "TV0P", "TVFP",
		"TW0P", "Ta0P", "Th0H", "Th0P", "Th1H", "Tm0P", "Tm1P", "Tp0P",
		"Tp1P", "TpFP", "Ts0P", "Ts0S", NULL }
@


1.17
log
@enable keyboard backlight support via wskbd(4) hooks

tested by Bryan Vyhmeister, krw, tb, and myself

ok krw tb
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.16 2015/12/11 20:36:32 jung Exp $	*/
d588 1
a588 1
	uint8_t buf[16], *end;
d603 1
@


1.16
log
@remove wrapper function and call LKSB key write directly
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.15 2015/12/11 20:15:50 jung Exp $	*/
d26 1
d33 1
d71 1
d73 1
d77 1
d97 7
d278 2
d297 1
a297 1
	buf[0] = 127, buf[1] = 0;
d302 3
d314 1
d352 1
a352 1
	uint8_t buf[2] = { 0, 0 };
d369 1
d377 41
d419 10
d511 1
d517 4
@


1.15
log
@remove no longer needed prototype
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.14 2015/12/11 20:06:48 jung Exp $	*/
a82 1
void	asmc_kbdled(struct asmc_softc *, uint8_t);
d282 7
a288 1
	asmc_kbdled(sc, 127);
d334 1
d357 1
a357 1
	asmc_kbdled(sc, 0);
a601 14

void
asmc_kbdled(struct asmc_softc *sc, uint8_t b)
{
	uint8_t buf[2] = { b, 0 };
	int r;

	/* keyboard backlight led is optional */
	if ((r = asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2))) {
		if (r != ASMC_NOTFOUND)
			printf("%s: keyboard backlight failed (0x%x)\n",
			    sc->sc_dev.dv_xname, r);
	}
}
@


1.14
log
@instead of checking the status everywhere do it directly after (trying) the
command and propagate the result
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.13 2015/10/29 13:29:04 jung Exp $	*/
a81 1
uint8_t	asmc_status(struct asmc_softc *);
d356 1
a356 1
uint8_t
@


1.13
log
@enable keyboard backlight led earlier to avoid race
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.12 2015/10/25 19:26:43 jung Exp $	*/
d259 1
a259 1
	int i;
d268 2
a269 2
	if (asmc_try(sc, ASMC_READ, "REV ", buf, 6)) {
		printf(": revision failed (0x%x)\n", asmc_status(sc));
d276 2
a277 2
	if (asmc_try(sc, ASMC_READ, "#KEY", buf, 4)) {
		printf(", no of keys failed (0x%x)\n", asmc_status(sc));
d433 2
a434 1
	int i;
d437 5
a441 3
		if (!asmc_command(sc, cmd, key, buf, len))
			return 0;
	return 1;
d478 1
a478 1
	int i;
d480 2
a481 2
	if (asmc_try(sc, ASMC_READ, sc->sc_prod->pr_temp[idx], buf, 2))
		return 1;
d509 1
d512 2
a513 2
	if (asmc_try(sc, ASMC_READ, key, buf, 2))
		return 1;
d521 2
a522 2
	if (asmc_try(sc, ASMC_READ, key, buf, 16))
		return 1;
d544 1
d548 2
a549 2
		if (asmc_try(sc, ASMC_INFO, key, buf, 6))
			return 1;
d553 2
a554 2
	if (asmc_try(sc, ASMC_READ, key, buf, sc->sc_lightlen))
		return 1;
d576 1
d579 2
a580 2
	if (asmc_try(sc, ASMC_READ, key, buf, 2))
		return 1;
d601 2
a602 1
	uint8_t buf[2] = { b, 0 }, s;
d605 2
a606 2
	if (asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2)) {
		if ((s = asmc_status(sc)) != ASMC_NOTFOUND)
d608 1
a608 1
			    sc->sc_dev.dv_xname, s);
d616 2
a617 2
	uint8_t buf[2], s;
	int i;
d621 1
a621 1
		if (asmc_temp(sc, i) && (s = asmc_status(sc)) != ASMC_NOTFOUND)
d623 1
a623 1
			    sc->sc_dev.dv_xname, i, s);
d625 3
a627 3
	if (asmc_try(sc, ASMC_READ, "FNum", buf, 1))
		printf("%s: read FNum failed (0x%x)\n", sc->sc_dev.dv_xname,
		    asmc_status(sc));
d631 1
a631 1
		if (asmc_fan(sc, i) && (s = asmc_status(sc)) != ASMC_NOTFOUND)
d633 1
a633 1
			    sc->sc_dev.dv_xname, i, s);
d636 1
a636 2
		if (asmc_light(sc, i) &&
		    (s = asmc_status(sc)) != ASMC_NOTFOUND)
d638 1
a638 1
			    sc->sc_dev.dv_xname, i, s);
d640 2
a641 2
	if (asmc_try(sc, ASMC_READ, "MOCN", buf, 2) &&
	    (s = asmc_status(sc)) != ASMC_NOTFOUND)
d643 1
a643 1
		    sc->sc_dev.dv_xname, s);
d646 3
a648 3
	if (asmc_try(sc, ASMC_WRITE, "MOCN", buf, 2))
		printf("%s write MOCN failed (0x%x)\n", sc->sc_dev.dv_xname,
		    asmc_status(sc));
d650 1
a650 2
		if (asmc_motion(sc, i) &&
		    (s = asmc_status(sc)) != ASMC_NOTFOUND)
d652 1
a652 1
			    sc->sc_dev.dv_xname, i, s);
@


1.12
log
@refactor to use a taskq and postpone the long running initial sensor probing,
also avoid excessive tsleep()s for updates within the sensor task,
moreover this should fix some seldom seen 'comm collision' errors
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.11 2015/10/15 01:14:33 jsg Exp $	*/
d281 1
a281 1
	printf(", %u key%s", ntohl(*(uint32_t *)buf),
d284 2
d287 1
a287 1
		printf(", can't create task queue\n");
d317 1
a317 1
		printf(", unable to register sensor task\n");
a321 4
	printf("\n");

	asmc_kbdled(sc, 127);

d332 1
a332 1
	if (sc->sc_sensor_task)
d334 2
d351 3
@


1.11
log
@avoid using a var uninitialised
ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.10 2015/10/10 12:05:47 jung Exp $	*/
d26 1
d66 7
a72 1
	uint8_t		 	 sc_lightlen;	/* light data len */
d82 6
a87 1
int	asmc_init(struct asmc_softc *);
d258 2
d268 7
a274 1
	printf("\n");
d276 7
a282 2
	strlcpy(sc->sc_sensor_dev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensor_dev.xname));
d284 2
a285 2
	if (asmc_init(sc)) {
		printf("%s: unable to initialize\n", sc->sc_dev.dv_xname);
d289 2
d292 25
a316 2
	if (!(sc->sc_sensor_task = sensor_task_register(sc, asmc_update, 8))) {
		printf("%s: unable to register task\n", sc->sc_dev.dv_xname);
d320 4
d325 1
a333 2
	wakeup(&sc->sc_sensor_task);
	sensordev_deinstall(&sc->sc_sensor_dev);
d336 1
a336 1

a338 1

a340 1

a342 1

d346 5
d354 1
a354 1
static uint8_t
d367 1
a367 1
		    tsleep(&sc->sc_sensor_task, 0, "asmc",
d378 3
a380 7
	int i;

	for (i = 0; i < ASMC_RETRY; i++) {
		bus_space_write_1(sc->sc_iot, sc->sc_ioh, off, val);
		if (asmc_wait(sc, 0x04)) /* write accepted? */
			return 0;
	}
d426 1
a426 1
static int
d438 2
a439 2
static int
asmc_temps(struct asmc_softc *sc, uint8_t *n)
d441 3
a443 2
	uint8_t buf[2], s;
	int i, j;
d445 6
a450 5
	for (i = 0, *n = 0; i < ASMC_MAXTEMP; i++) {
		sc->sc_sensor_temp[i].type = SENSOR_TEMP;
		sc->sc_sensor_temp[i].flags |= SENSOR_FINVALID;
		if (!sc->sc_prod->pr_temp[i])
			continue;
d452 14
a465 28
		s = 0;
		if (asmc_try(sc, ASMC_READ, sc->sc_prod->pr_temp[i], buf, 2) &&
		    (s = asmc_status(sc)) != ASMC_NOTFOUND) {
			printf(", read %s failed (0x%x)",
			    sc->sc_prod->pr_temp[i], s);
			continue; /*return 1;*/
		}
		if (s == ASMC_NOTFOUND)
			continue;

		(*n)++;
		strlcpy(sc->sc_sensor_temp[i].desc, sc->sc_prod->pr_temp[i],
		    sizeof(sc->sc_sensor_temp[i].desc));
		for (j = 0; asmc_temp_desc[j][0]; j++)
			if (!strcmp(asmc_temp_desc[j][0],
			    sc->sc_prod->pr_temp[i]))
				break;
		if (asmc_temp_desc[j][0]) {
			strlcat(sc->sc_sensor_temp[i].desc, " ",
			    sizeof(sc->sc_sensor_temp[i].desc));
			strlcat(sc->sc_sensor_temp[i].desc,
			    asmc_temp_desc[j][1],
			    sizeof(sc->sc_sensor_temp[i].desc));
		}
		sc->sc_sensor_temp[i].flags &= ~SENSOR_FINVALID;
		sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_temp[i]);
	}
	return 0;
d469 1
a469 1
asmc_fans(struct asmc_softc *sc, uint8_t *n)
d471 1
a471 2
	char key[5];
	uint8_t buf[16], *end;
d474 1
a474 3
	*n = 0;
	if (asmc_try(sc, ASMC_READ, "FNum", buf, 1)) {
		printf(", read FNum failed (0x%x)", asmc_status(sc));
d476 2
a477 2
	}
	*n = buf[0];
d479 2
a480 5
	for (i = 0; i < ASMC_MAXFAN; i++) {
		sc->sc_sensor_fan[i].type = SENSOR_FANRPM;
		sc->sc_sensor_fan[i].flags |= SENSOR_FINVALID;
		if (i >= *n)
			continue;
d482 10
a491 20
		snprintf(key, sizeof(key), "F%dID", i);
		if (asmc_try(sc, ASMC_READ, key, buf, 16)) {
			printf(", read %s failed (0x%x)", key,
			    asmc_status(sc));
			return 1;
		}
		end = buf + 4 + strlen((char *)buf + 4) - 1;
		while (buf + 4 < end && *end == ' ') /* trim trailing spaces */
			*end-- = '\0';
		strlcpy(sc->sc_sensor_fan[i].desc, buf + 4,
		    sizeof(sc->sc_sensor_fan[i].desc));
		if (buf[2] < nitems(asmc_fan_loc)) {
			strlcat(sc->sc_sensor_fan[i].desc, " ",
			    sizeof(sc->sc_sensor_fan[i].desc));
			strlcat(sc->sc_sensor_fan[i].desc,
			    asmc_fan_loc[buf[2]],
			    sizeof(sc->sc_sensor_fan[i].desc));
		}
		sc->sc_sensor_fan[i].flags &= ~SENSOR_FINVALID;
		sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_fan[i]);
d493 2
d499 1
a499 1
asmc_lights(struct asmc_softc *sc, uint8_t *n)
d502 10
a511 2
	uint8_t buf[6], s;
	int i;
d513 13
a525 26
	for (i = 0, *n = 0; i < ASMC_MAXLIGHT; i++) {
		sc->sc_sensor_light[i].type = SENSOR_LUX;
		sc->sc_sensor_light[i].flags |= SENSOR_FINVALID;
		s = 0;
		snprintf(key, sizeof(key), "ALV%d", i);
		if (asmc_try(sc, ASMC_READ, key, buf, 6) &&
		    (s = asmc_status(sc)) != ASMC_NOTFOUND) {
			printf(", read %s failed (0x%x)", key, s);
			return 1;
		}
		if (s == ASMC_NOTFOUND || !buf[0]) /* valid data? */
			continue;

		(*n)++;
		if (!sc->sc_lightlen) {
			if (asmc_try(sc, ASMC_INFO, key, buf, 6)) {
				printf(", info %s failed (0x%x)", key,
				    asmc_status(sc));
				return 1;
			}
			sc->sc_lightlen = buf[0];
		}
		strlcpy(sc->sc_sensor_light[i].desc, asmc_light_desc[i],
		    sizeof(sc->sc_sensor_light[i].desc));
		sc->sc_sensor_light[i].flags &= ~SENSOR_FINVALID;
		sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_light[i]);
d527 2
d533 1
a533 1
asmc_motions(struct asmc_softc *sc, uint8_t *n)
d535 2
a536 2
	uint8_t buf[2], s;
	int i;
d538 8
a545 5
	*n = 0;
	s = 0;
	if (asmc_try(sc, ASMC_READ, "MOCN", buf, 2) &&
	    (s = asmc_status(sc)) != ASMC_NOTFOUND) {
		printf(", read MOCN failed (0x%x)", s);
d547 1
a547 2
	}
	if (s == ASMC_NOTFOUND)
d549 2
d552 1
a552 5
	*n = 1;
#if 0 /* todo: initialize sudden motion sensors and setup interrupt handling */
	buf[0] = 0xe0, buf[1] = 0xf8;
	if (asmc_try(sc, ASMC_WRITE, "MOCN", buf, 2)) {
		printf(", write MOCN failed (0x%x)", asmc_status(sc));
a553 5
	}
#endif
	for (i = 0; i < ASMC_MAXMOTION; i++) {
		sc->sc_sensor_motion[i].type = SENSOR_ACCEL;
		sc->sc_sensor_motion[i].flags |= SENSOR_FINVALID;
d555 4
a558 9
#if 0 /* todo: setup and attach sensors and description */
		strlcpy(sc->sc_sensor_motion[i].desc, 120 + i, /* x, y, z */
		    sizeof(sc->sc_sensor_motion[i].desc));
		strlcat(sc->sc_sensor_motion[i].desc, "-axis",
		    sizeof(sc->sc_sensor_motion[i].desc));
		sc->sc_sensor_motion[i].flags &= ~SENSOR_FINVALID;
		sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_motion[i]);
#endif
	}
d562 3
a564 2
int
asmc_init(struct asmc_softc *sc)
d566 2
a567 1
	uint8_t buf[6], n, s;
d569 2
a570 4
	printf("%s:", sc->sc_dev.dv_xname);

	if (asmc_try(sc, ASMC_READ, "REV ", buf, 6)) {
		printf(" revision failed (0x%x)\n", asmc_status(sc));
d572 2
a573 3
	}
	printf(" rev %x.%x%x%x", buf[0], buf[1], buf[2],
	    ntohs(*(uint16_t *)buf + 4));
d575 2
a576 6
	if (asmc_try(sc, ASMC_READ, "#KEY", buf, 4)) {
		printf(", no of keys failed (0x%x)\n", asmc_status(sc));
		return 1;
	}
	printf(", %u key%s", ntohl(*(uint32_t *)buf),
	    (ntohl(*(uint32_t *)buf) == 1) ? "" : "s");
d578 10
a587 5
	if (asmc_temps(sc, &n)) { /* temperature sensors depend on product */
		printf(", temperature sensors failed\n");
		return 1;
	}
	printf(", %u temperature%s", n, (n == 1) ? "" : "s");
d589 4
a592 11
	if (asmc_fans(sc, &n)) { /* fan sensors depend on product */
		printf(", fan sensors failed\n");
		return 1;
	}
	printf(", %u fan%s", n, (n == 1) ? "" : "s");

	if (asmc_lights(sc, &n)) { /* l/r light sensors are optional */
		printf(", light sensors failed\n");
		return 1;
	}
	printf("%s", n ? ", lights" : "");
d594 5
a598 3
	if (asmc_motions(sc, &n)) { /* motion sensors are optional */
		printf(", sudden motion sensors failed\n");
		return 1;
d600 1
a600 1
	printf("%s", n ? ", motions" : "");
d602 6
a607 7
	buf[0] = 127, buf[1] = 0; /* keyboard backlight led is optional */
	if (asmc_try(sc, ASMC_WRITE, "LKSB", buf, 2) &&
	    (s = asmc_status(sc)) != ASMC_NOTFOUND) {
		printf(", keyboard backlight failed (0x%x)\n", s);
		return 1;
	}
	printf("\n");
d609 38
a646 1
	return 0;
d650 1
a650 1
asmc_update(void *arg)
a652 2
	char key[5];
	uint8_t buf[10];
d655 15
a669 8
	/* spe78: floating point, signed, 7 bits exponent, 8 bits fraction */
	for (i = 0; i < ASMC_MAXTEMP; i++) {
		if (!(sc->sc_sensor_temp[i].flags & SENSOR_FINVALID) &&
		    !asmc_try(sc, ASMC_READ, sc->sc_prod->pr_temp[i], buf, 2))
			sc->sc_sensor_temp[i].value =
			    (((int16_t)ntohs(*(uint16_t *)buf)) >> 8) *
			    1000000 + 273150000;
	}
d671 4
a674 30
	/* fpe2: floating point, unsigned, 14 bits exponent, 2 bits fraction */
	for (i = 0; i < ASMC_MAXFAN; i++) {
		snprintf(key, sizeof(key), "F%dAc", i);
		if (!(sc->sc_sensor_fan[i].flags & SENSOR_FINVALID) &&
		    !asmc_try(sc, ASMC_READ, key, buf, 2))
			sc->sc_sensor_fan[i].value =
			    ntohs(*(uint16_t *)buf) >> 2;
	}

	for (i = 0; i < ASMC_MAXLIGHT; i++) {
		snprintf(key, sizeof(key), "ALV%d", i);
		if (!(sc->sc_sensor_light[i].flags & SENSOR_FINVALID) &&
		    !asmc_try(sc, ASMC_READ, key, buf, sc->sc_lightlen))
			/* newer macbooks report an 10 bit big endian value */
			sc->sc_sensor_light[i].value =
			    (sc->sc_lightlen == 10) ?
			    /*
			     * fp18.14: floating point,
			     * 18 bits exponent, 14 bits fraction
			     */
			    (ntohl(*(uint32_t *)(buf + 6)) >> 14) * 1000000 :
			    /*
			     * todo: calculate lux from ADC raw data:
			     * buf[1] true/false for high/low gain chan reads
			     * chan 0: ntohs(*(uint16_t *)(buf + 2));
			     * chan 1: ntohs(*(uint16_t *)(buf + 4));
			     */
			    ((sc->sc_sensor_light[i].flags |=
			        SENSOR_FUNKNOWN), 0);
	}
d676 2
a677 8
#if 0 /* todo: implement motion sensors update */
	for (i = 0; i < ASMC_MAXMOTION; i++) {
		snprintf(key, sizeof(key), "MO_%c", 88 + i); /* X, Y, Z */
		if (!(sc->sc_sensor_motion[i].flags & SENSOR_FINVALID) &&
		    !asmc_try(sc, ASMC_READ, key, buf, 2))
			sc->sc_sensor_motion[i].value = 0;
	}
#endif
@


1.10
log
@add location to the fan description
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.9 2015/10/10 11:57:20 jung Exp $	*/
d517 1
@


1.9
log
@fix wrong brackets in if statement
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.8 2015/10/04 20:00:50 jung Exp $	*/
d194 9
d460 7
@


1.8
log
@tweak initial output a bit: do not show number of light sensors, just show if
some is found or not, also remove kbdled output as there is no (known) way to
test if (not) available at all
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.7 2015/10/04 12:07:58 jung Exp $	*/
d470 1
a470 1
		    (s = asmc_status(sc) != ASMC_NOTFOUND)) {
@


1.7
log
@a macmini has no light sensor, but reading from light sensor keys is
successful, while info/type reading from same keys fails and avoids
initialization;
so check the validity flag earlier and do not try to attach invalid
(non-existing) keys

debugged with help from kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.6 2015/10/04 11:41:24 jung Exp $	*/
d570 1
a570 1
	printf(", %u light%s", n, (n == 1) ? "" : "s");
d584 1
a584 1
	printf("%s\n", (s == ASMC_NOTFOUND) ? "" : ", kbdled");
@


1.6
log
@remove duplicate key, found by kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.5 2015/10/01 18:41:06 jung Exp $	*/
d474 1
a474 1
		if (s == ASMC_NOTFOUND)
d618 1
a618 6
		    !asmc_try(sc, ASMC_READ, key, buf, sc->sc_lightlen)) {
			if (!buf[0]) { /* check if found data is valid */
				sc->sc_sensor_light[i].flags |=
				    SENSOR_FINVALID;
				continue;
			}
a634 1
		}
@


1.5
log
@relax vendor comparison to match variations found in older
models for example macmini1,1
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.4 2015/10/01 18:31:40 jung Exp $	*/
d131 2
a132 2
		"TC0D", "TC0H", "TC0P", "TH0P", "TN0D", "TN0P", "TN0P", "TN1P",
		"TW0P", NULL }
@


1.4
log
@add const, prodded by mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.3 2015/10/01 18:24:28 jung Exp $	*/
d208 1
a208 1
	if (!hw_vendor || !hw_prod || strcmp(hw_vendor, "Apple Inc."))
@


1.3
log
@remove superfluous sensor_attach() added for debug reasons
@
text
@d1 1
a1 1
/*	$OpenBSD: asmc.c,v 1.2 2015/10/01 15:57:08 jsg Exp $	*/
d82 1
a82 1
struct cfattach asmc_ca = {
@


1.2
log
@fix semicolon after if statement
ok jung@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a453 1
	sensor_attach(&sc->sc_sensor_dev, &sc->sc_sensor_fan[3]);
@


1.1
log
@add a (disabled) driver for the Apple System Management Controller (SMC) as
found in Apple Intel based devices

"go at it" deraadt@@
@
text
@d1 1
d507 1
a507 1
	if (s == ASMC_NOTFOUND);
@

