head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.2
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.2
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.39.0.4
	OPENBSD_5_8_BASE:1.39
	OPENBSD_5_7:1.37.0.4
	OPENBSD_5_7_BASE:1.37
	OPENBSD_5_6:1.36.0.20
	OPENBSD_5_6_BASE:1.36
	OPENBSD_5_5:1.36.0.18
	OPENBSD_5_5_BASE:1.36
	OPENBSD_5_4:1.36.0.14
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.36.0.12
	OPENBSD_5_3_BASE:1.36
	OPENBSD_5_2:1.36.0.10
	OPENBSD_5_2_BASE:1.36
	OPENBSD_5_1_BASE:1.36
	OPENBSD_5_1:1.36.0.8
	OPENBSD_5_0:1.36.0.6
	OPENBSD_5_0_BASE:1.36
	OPENBSD_4_9:1.36.0.4
	OPENBSD_4_9_BASE:1.36
	OPENBSD_4_8:1.36.0.2
	OPENBSD_4_8_BASE:1.36
	OPENBSD_4_7:1.35.0.4
	OPENBSD_4_7_BASE:1.35
	OPENBSD_4_6:1.35.0.6
	OPENBSD_4_6_BASE:1.35
	OPENBSD_4_5:1.35.0.2
	OPENBSD_4_5_BASE:1.35
	OPENBSD_4_4:1.32.0.4
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.32.0.2
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.15.0.4
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.2
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.10.0.2
	OPENBSD_3_7_BASE:1.10
	OPENBSD_3_6:1.8.0.12
	OPENBSD_3_6_BASE:1.8
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.10
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.8.0.8
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.8
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.7.0.4
	UBC_BASE:1.7
	OPENBSD_3_0:1.7.0.2
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.6
	OPENBSD_2_9:1.6.0.2
	OPENBSD_2_8:1.5.0.8
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.6
	OPENBSD_2_7_BASE:1.5
	SMP:1.5.0.4
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5
	OPENBSD_2_5:1.4.0.2
	OPENBSD_2_5_BASE:1.4
	OPENBSD_2_4:1.2.0.4
	OPENBSD_2_4_BASE:1.2
	OPENBSD_2_3:1.2.0.2
	OPENBSD_2_3_BASE:1.2
	OPENBSD_2_2:1.1.0.2
	OPENBSD_2_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.06.04.20.28.05;	author naddy;	state Exp;
branches;
next	1.45;
commitid	g1OhNd7zpqxkX0Jj;

1.45
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.44;
commitid	VyLWTsbepAOk7VQM;

1.44
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.43;
commitid	QHiEhS9DHyE6oiIr;

1.43
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.42;
commitid	B0kwmVGiD5DVx4kv;

1.42
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.41;
commitid	eYnPulzvLjDImPCa;

1.41
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.40;
commitid	SaArro4mM2Ab3ure;

1.40
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.39;
commitid	6vhYvh5CxZAHMnsN;

1.39
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.38;
commitid	MVWrtktB46JRxFWT;

1.38
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.37;
commitid	0fL6zHGm3fqppVdw;

1.37
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.36;
commitid	yM2VFFhpDTeFQlve;

1.36
date	2010.07.02.02.29.45;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.28.02.44.17;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.22.13.14.35;	author oga;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.21.03.02.09;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2007.10.21.02.25.27;	author brad;	state Exp;
branches;
next	1.30;

1.30
date	2007.10.21.00.55.55;	author brad;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.18.04.52.37;	author brad;	state Exp;
branches;
next	1.28;

1.28
date	2007.10.06.06.35.57;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.20.05.48.46;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.19.07.29.04;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2007.09.19.07.11.18;	author brad;	state Exp;
branches;
next	1.24;

1.24
date	2007.09.19.06.44.57;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2007.09.19.06.28.38;	author brad;	state Exp;
branches;
next	1.22;

1.22
date	2007.09.19.06.14.24;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2007.09.19.05.29.47;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2007.09.19.05.09.09;	author brad;	state Exp;
branches;
next	1.19;

1.19
date	2007.09.19.04.52.15;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2007.09.19.03.55.05;	author brad;	state Exp;
branches;
next	1.17;

1.17
date	2007.09.17.01.20.03;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.06.09.44.30;	author henning;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.09.05.46.21;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.03.10.29.12;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.04.02.03.20.26;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2004.12.26.21.22.13;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2004.09.23.17.45.16;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2001.06.27.06.34.46;	author kjc;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2001.02.20.19.39.40;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	99.04.19.07.10.06;	author fgsch;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	99.02.28.03.23.38;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	99.02.13.01.02.21;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	97.11.09.22.21.22;	author gene;	state Exp;
branches;
next	1.1;

1.1
date	97.09.11.21.30.49;	author gene;	state Exp;
branches;
next	;

1.5.4.1
date	2001.05.14.22.24.42;	author niklas;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2001.07.04.10.41.28;	author niklas;	state Exp;
branches;
next	1.5.4.3;

1.5.4.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	;

1.7.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	;


desc
@@


1.46
log
@fix a bungled logical/bitwise expression pointed out by clang; ok deraadt@@
@
text
@/*	$OpenBSD: if_ex.c,v 1.45 2017/01/22 10:17:38 dlg Exp $	*/
/*
 * Copyright (c) 1997, Donald A. Schmidt
 * Copyright (c) 1996, Javier Martín Rueda (jmrueda@@diatel.upm.es)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * Intel EtherExpress Pro/10 Ethernet driver
 *
 * Revision history:
 *
 * 30-Oct-1996: first beta version. Inet and BPF supported, but no multicast.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h> 

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/isa/if_exreg.h>

#ifdef EX_DEBUG
#define Start_End 1
#define Rcvd_Pkts 2
#define Sent_Pkts 4
#define Status    8
static int debug_mask = 0;
static int exintr_count = 0;
#define DODEBUG(level, action) if (level & debug_mask) action
#else
#define DODEBUG(level, action)
#endif

struct ex_softc {
  	struct arpcom arpcom;	/* Ethernet common data */
	struct ifmedia ifmedia;
	int iobase;		/* I/O base address. */
	u_short irq_no; 	/* IRQ number. */
	u_int mem_size;		/* Total memory size, in bytes. */
	u_int rx_mem_size;	/* Rx memory size (by default, first 3/4 of 
				   total memory). */
  	u_int rx_lower_limit, 
	      rx_upper_limit; 	/* Lower and upper limits of receive buffer. */
  	u_int rx_head; 		/* Head of receive ring buffer. */
	u_int tx_mem_size;	/* Tx memory size (by default, last quarter of 
				   total memory). */
  	u_int tx_lower_limit, 
	      tx_upper_limit;	/* Lower and upper limits of transmit buffer. */
  	u_int tx_head, tx_tail; /* Head and tail of transmit ring buffer. */
  	u_int tx_last; 		/* Pointer to beginning of last frame in the 
				   chain. */
	bus_space_tag_t sc_iot;	/* ISA i/o space tag */
	bus_space_handle_t sc_ioh; /* ISA i/o space handle */
	void *sc_ih;		/* Device interrupt handler */
};

static char irq2eemap[] = { -1, -1, 0, 1, -1, 2, -1, -1, -1, 0, 3, 4, -1, -1, 
			    -1, -1 };
static u_char ee2irqmap[] = { 9, 3, 5, 10, 11, 0, 0, 0 };

int ex_probe(struct device *, void *, void *);
void ex_attach(struct device *, struct device *, void *);
void ex_init(struct ex_softc *);
void ex_start(struct ifnet *);
void ex_stop(struct ex_softc *);
int ex_ioctl(struct ifnet *, u_long, caddr_t);
void ex_setmulti(struct ex_softc *);
void ex_reset(struct ex_softc *);
void ex_watchdog(struct ifnet *);
uint64_t ex_get_media(struct ex_softc *);

int ex_ifmedia_upd(struct ifnet *);
void ex_ifmedia_sts(struct ifnet *, struct ifmediareq *);

u_short ex_eeprom_read(struct ex_softc *, int);
int ex_look_for_card(struct isa_attach_args *, struct ex_softc *sc);

int ex_intr(void *);
void ex_tx_intr(struct ex_softc *);
void ex_rx_intr(struct ex_softc *);

struct cfattach ex_ca = {
	sizeof(struct ex_softc), ex_probe, ex_attach
};

struct cfdriver ex_cd = {
	NULL, "ex", DV_IFNET
};

#define CSR_READ_1(sc, off) \
	bus_space_read_1((sc)->sc_iot, (sc)->sc_ioh, (off))
#define CSR_READ_2(sc, off) \
	bus_space_read_2((sc)->sc_iot, (sc)->sc_ioh, (off))
#define CSR_READ_MULTI_2(sc, off, addr, count) \
	bus_space_read_multi_2((sc)->sc_iot, (sc)->sc_ioh, (off),	\
	    (u_int16_t *)(addr), (count))

#define CSR_WRITE_1(sc, off, value) \
	bus_space_write_1((sc)->sc_iot, (sc)->sc_ioh, (off), (value))
#define CSR_WRITE_2(sc, off, value) \
	bus_space_write_2((sc)->sc_iot, (sc)->sc_ioh, (off), (value))
#define CSR_WRITE_MULTI_2(sc, off, addr, count) \
	bus_space_write_multi_2((sc)->sc_iot, (sc)->sc_ioh, (off),	\
	    (u_int16_t *)(addr), (count))

int 
ex_look_for_card(struct isa_attach_args *ia, struct ex_softc *sc)
{
	int count1, count2;

	/*
	 * Check for the i82595 signature, and check that the round robin
	 * counter actually advances.
	 */
	if (((count1 = CSR_READ_1(sc, ID_REG)) & Id_Mask) != Id_Sig)
		return(0);
	count2 = CSR_READ_1(sc, ID_REG);
	count2 = CSR_READ_1(sc, ID_REG);
	count2 = CSR_READ_1(sc, ID_REG);
	if ((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits))
		return(1);
	else
		return(0);
}

int 
ex_probe(struct device *parent, void *match, void *aux)
{
	struct ex_softc *sc = match;
	struct isa_attach_args *ia = aux;
	u_short eaddr_tmp;
	int tmp;

	DODEBUG(Start_End, printf("ex_probe: start\n"););

	if ((ia->ia_iobase >= 0x200) && (ia->ia_iobase <= 0x3a0)) {
		sc->sc_iot = ia->ia_iot;
		if(bus_space_map(sc->sc_iot, ia->ia_iobase, EX_IOSIZE, 0,
		    &sc->sc_ioh))
			return(0);

		if (!ex_look_for_card(ia, sc)) {
			bus_space_unmap(sc->sc_iot, sc->sc_ioh, EX_IOSIZE);
			return(0); 
		}
	} else
		return(0);

	ia->ia_iosize = EX_IOSIZE;

	/*
	 * Reset the card.
	 */
	CSR_WRITE_1(sc, CMD_REG, Reset_CMD);
	delay(200);

	/*
	 * Fill in several fields of the softc structure:
	 *	- I/O base address.
	 *	- Hardware Ethernet address.
	 *	- IRQ number (if not supplied in config file, read it from 
	 *	  EEPROM).
	 */
	sc->iobase = ia->ia_iobase;
	eaddr_tmp = ex_eeprom_read(sc, EE_Eth_Addr_Lo);
	sc->arpcom.ac_enaddr[5] = eaddr_tmp & 0xff;
	sc->arpcom.ac_enaddr[4] = eaddr_tmp >> 8;
	eaddr_tmp = ex_eeprom_read(sc, EE_Eth_Addr_Mid);
	sc->arpcom.ac_enaddr[3] = eaddr_tmp & 0xff;
	sc->arpcom.ac_enaddr[2] = eaddr_tmp >> 8;
	eaddr_tmp = ex_eeprom_read(sc, EE_Eth_Addr_Hi);
	sc->arpcom.ac_enaddr[1] = eaddr_tmp & 0xff;
	sc->arpcom.ac_enaddr[0] = eaddr_tmp >> 8;
	tmp = ex_eeprom_read(sc, EE_IRQ_No) & IRQ_No_Mask;
	if (ia->ia_irq > 0) {
		if (ee2irqmap[tmp] != ia->ia_irq)
			printf("ex: WARING: board's EEPROM is configured for IRQ %d, using %d\n", ee2irqmap[tmp], ia->ia_irq);
		sc->irq_no = ia->ia_irq;
	}
	else {
		sc->irq_no = ee2irqmap[tmp];
		ia->ia_irq = sc->irq_no;
	}
	if (sc->irq_no == 0) {
		printf("ex: invalid IRQ.\n");
		return(0);
	}

	sc->mem_size = CARD_RAM_SIZE;	/* XXX This should be read from the card
					       itself. */

	DODEBUG(Start_End, printf("ex_probe: finish\n"););
	return(1);
}

void
ex_attach(struct device *parent, struct device *self, void *aux)
{
	struct ex_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ifmedia *ifm;
	int temp;

	DODEBUG(Start_End, printf("ex_attach: start\n"););

	ifp->if_softc = sc;
	bcopy(self->dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_start = ex_start;
	ifp->if_ioctl = ex_ioctl;
	ifp->if_watchdog = ex_watchdog;
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST | IFF_MULTICAST;

	ifmedia_init(&sc->ifmedia, 0, ex_ifmedia_upd, ex_ifmedia_sts);

	temp = ex_eeprom_read(sc, EE_W5);
	if (temp & EE_W5_PORT_TPE)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_T, 0, NULL);
	if (temp & EE_W5_PORT_BNC)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_2, 0, NULL);
	if (temp & EE_W5_PORT_AUI)
		ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_10_5, 0, NULL);

	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_AUTO, 0, NULL);
	ifmedia_add(&sc->ifmedia, IFM_ETHER|IFM_NONE, 0, NULL);
	ifmedia_set(&sc->ifmedia, ex_get_media(sc));

	ifm = &sc->ifmedia;
	ifm->ifm_media = ifm->ifm_cur->ifm_media;
	ex_ifmedia_upd(ifp);

	if_attach(ifp);
	ether_ifattach(ifp);
	printf(": address %s\n",
	    ether_sprintf(sc->arpcom.ac_enaddr));

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, ex_intr, sc, self->dv_xname);
	ex_init(sc);

	DODEBUG(Start_End, printf("ex_attach: finish\n"););
}

void 
ex_init(struct ex_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int s, i;
	unsigned short temp_reg;

	DODEBUG(Start_End, printf("ex_init: start\n"););

	s = splnet();
	sc->arpcom.ac_if.if_timer = 0;

	/*
	 * Load the ethernet address into the card.
	 */
	CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
	temp_reg = CSR_READ_1(sc, EEPROM_REG);
	if (temp_reg & Trnoff_Enable)
		CSR_WRITE_1(sc, EEPROM_REG, temp_reg & ~Trnoff_Enable);
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		CSR_WRITE_1(sc, I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);
	/*
	 * - Setup transmit chaining and discard bad received frames.
	 * - Match broadcast.
	 * - Clear test mode.
	 * - Set receiving mode.
	 * - Set IRQ number.
	 */
	CSR_WRITE_1(sc, REG1, CSR_READ_1(sc, REG1) | Tx_Chn_Int_Md |
	    Tx_Chn_ErStp | Disc_Bad_Fr);
	CSR_WRITE_1(sc, REG2, CSR_READ_1(sc, REG2) | No_SA_Ins |
	    RX_CRC_InMem);
	CSR_WRITE_1(sc, REG3, (CSR_READ_1(sc, REG3) & 0x3f));
	CSR_WRITE_1(sc, CMD_REG, Bank1_Sel);
	CSR_WRITE_1(sc, INT_NO_REG, (CSR_READ_1(sc, INT_NO_REG) & 0xf8) | 
	    irq2eemap[sc->irq_no]);

	/*
	 * Divide the available memory in the card into rcv and xmt buffers.
	 * By default, I use the first 3/4 of the memory for the rcv buffer,
	 * and the remaining 1/4 of the memory for the xmt buffer.
	 */
	sc->rx_mem_size = sc->mem_size * 3 / 4;
	sc->tx_mem_size = sc->mem_size - sc->rx_mem_size;
	sc->rx_lower_limit = 0x0000;
	sc->rx_upper_limit = sc->rx_mem_size - 2;
	sc->tx_lower_limit = sc->rx_mem_size;
	sc->tx_upper_limit = sc->mem_size - 2;
 	CSR_WRITE_1(sc, RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);
	CSR_WRITE_1(sc, RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);
	CSR_WRITE_1(sc, XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);
	CSR_WRITE_1(sc, XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);

	/*
	 * Enable receive and transmit interrupts, and clear any pending int.
	 */
	CSR_WRITE_1(sc, REG1, CSR_READ_1(sc, REG1) | TriST_INT);
	CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);
	CSR_WRITE_1(sc, MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
	CSR_WRITE_1(sc, STATUS_REG, All_Int);

	/*
	 * Initialize receive and transmit ring buffers.
	 */
	CSR_WRITE_2(sc, RCV_BAR, sc->rx_lower_limit);
	sc->rx_head = sc->rx_lower_limit;
	CSR_WRITE_2(sc, RCV_STOP_REG, sc->rx_upper_limit | 0xfe);
	CSR_WRITE_2(sc, XMT_BAR, sc->tx_lower_limit);
	sc->tx_head = sc->tx_tail = sc->tx_lower_limit;

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	DODEBUG(Status, printf("OIDLE init\n"););

	ex_setmulti(sc);

	/*
	 * Final reset of the board, and enable operation.
	 */
	CSR_WRITE_1(sc, CMD_REG, Sel_Reset_CMD);
	delay(2);
	CSR_WRITE_1(sc, CMD_REG, Rcv_Enable_CMD);

	ex_start(ifp);
	splx(s);

	DODEBUG(Start_End, printf("ex_init: finish\n"););
}

void 
ex_start(struct ifnet *ifp)
{
	struct ex_softc *sc = ifp->if_softc;
	int i, len, data_len, avail, dest, next;
	unsigned char tmp16[2];
	struct mbuf *opkt;
	struct mbuf *m;

	DODEBUG(Start_End, printf("ex_start: start\n"););

	/*
 	 * Main loop: send outgoing packets to network card until there are no
 	 * more packets left, or the card cannot accept any more yet.
 	 */
	while (!ifq_is_oactive(&ifp->if_snd)) {
		opkt = ifq_deq_begin(&ifp->if_snd);
		if (opkt == NULL)
			break;

		/*
		 * Ensure there is enough free transmit buffer space for this 
		 * packet, including its header. Note: the header cannot wrap 
		 * around the end of the transmit buffer and must be kept 
		 * together, so we allow space for twice the length of the 
		 * header, just in case.
		 */
		for (len = 0, m = opkt; m != NULL; m = m->m_next)
 			len += m->m_len;
    		data_len = len;
   		DODEBUG(Sent_Pkts, printf("1. Sending packet with %d data bytes. ", data_len););
		if (len & 1)
   			len += XMT_HEADER_LEN + 1;
		else
			len += XMT_HEADER_LEN;
		if ((i = sc->tx_tail - sc->tx_head) >= 0)
			avail = sc->tx_mem_size - i;
		else
			avail = -i;
		DODEBUG(Sent_Pkts, printf("i=%d, avail=%d\n", i, avail););
    		if (avail >= len + XMT_HEADER_LEN) {
      			ifq_deq_commit(&ifp->if_snd, opkt);

#ifdef EX_PSA_INTR      
			/*
 			 * Disable rx and tx interrupts, to avoid corruption of
			 * the host address register by interrupt service 
			 * routines. XXX Is this necessary with splnet() 
			 * enabled?
			 */
			CSR_WRITE_2(sc, MASK_REG, All_Int);
#endif

      			/* 
			 * Compute the start and end addresses of this frame 
			 * in the tx buffer.
			 */
      			dest = sc->tx_tail;
			next = dest + len;
			if (next > sc->tx_upper_limit) {
				if ((sc->tx_upper_limit + 2 - sc->tx_tail) <= 
				    XMT_HEADER_LEN) {
	  				dest = sc->tx_lower_limit;
	  				next = dest + len;
				} else
	  				next = sc->tx_lower_limit + next - 
					    sc->tx_upper_limit - 2;
      			}

			/* Build the packet frame in the card's ring buffer. */
			DODEBUG(Sent_Pkts, printf("2. dest=%d, next=%d. ", dest, next););
			CSR_WRITE_2(sc, HOST_ADDR_REG, dest);
			CSR_WRITE_2(sc, IO_PORT_REG, Transmit_CMD);
			CSR_WRITE_2(sc, IO_PORT_REG, 0);
			CSR_WRITE_2(sc, IO_PORT_REG, next);
			CSR_WRITE_2(sc, IO_PORT_REG, data_len);

			/*
 			 * Output the packet data to the card. Ensure all 
			 * transfers are 16-bit wide, even if individual mbufs 
			 * have odd length.
			 */

			for (m = opkt, i = 0; m != NULL; m = m->m_next) {
				DODEBUG(Sent_Pkts, printf("[%d]", m->m_len););
				if (i) {
					tmp16[1] = *(mtod(m, caddr_t));
					CSR_WRITE_MULTI_2(sc, IO_PORT_REG, tmp16, 1);
				}
				CSR_WRITE_MULTI_2(sc, IO_PORT_REG, mtod(m, caddr_t) 
				    + i, (m->m_len - i) / 2);
				if ((i = (m->m_len - i) & 1))
					tmp16[0] = *(mtod(m, caddr_t) + 
					    m->m_len - 1);
			}
			if (i)
				CSR_WRITE_MULTI_2(sc, IO_PORT_REG, tmp16, 1);

      			/*
			 * If there were other frames chained, update the 
			 * chain in the last one.
			 */
			if (sc->tx_head != sc->tx_tail) {
				if (sc->tx_tail != dest) {
					CSR_WRITE_2(sc, HOST_ADDR_REG, 
					    sc->tx_last + XMT_Chain_Point);
					CSR_WRITE_2(sc, IO_PORT_REG, dest);
				}
				CSR_WRITE_2(sc, HOST_ADDR_REG, sc->tx_last + 
				    XMT_Byte_Count);
				i = CSR_READ_2(sc, IO_PORT_REG);
				CSR_WRITE_2(sc, HOST_ADDR_REG, sc->tx_last + 
				    XMT_Byte_Count);
				CSR_WRITE_2(sc, IO_PORT_REG, i | Ch_bit);
      			}

      			/*
			 * Resume normal operation of the card:
			 * -Make a dummy read to flush the DRAM write pipeline.
			 * -Enable receive and transmit interrupts.
			 * -Send Transmit or Resume_XMT command, as appropriate.
			 */
			CSR_READ_2(sc, IO_PORT_REG);
#ifdef EX_PSA_INTR
			CSR_WRITE_2(sc, MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
#endif
			if (sc->tx_head == sc->tx_tail) {
				CSR_WRITE_2(sc, XMT_BAR, dest);
				CSR_WRITE_1(sc, CMD_REG, Transmit_CMD);
				sc->tx_head = dest;
				DODEBUG(Sent_Pkts, printf("Transmit\n"););
			} else {
				CSR_WRITE_1(sc, CMD_REG, Resume_XMT_List_CMD);
				DODEBUG(Sent_Pkts, printf("Resume\n"););
			}
			sc->tx_last = dest;
			sc->tx_tail = next;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, opkt,
				    BPF_DIRECTION_OUT);
#endif
			ifp->if_timer = 2;
			m_freem(opkt);
		} else {
			ifq_deq_rollback(&ifp->if_snd, opkt);
			ifq_set_oactive(&ifp->if_snd);
			DODEBUG(Status, printf("OACTIVE start\n"););
		}
	}

	DODEBUG(Start_End, printf("ex_start: finish\n"););
}

void 
ex_stop(struct ex_softc *sc)
{
	DODEBUG(Start_End, printf("ex_stop: start\n"););

	/*
	 * Disable card operation:
 	 * - Disable the interrupt line.
	 * - Flush transmission and disable reception.
	 * - Mask and clear all interrupts.
  	 * - Reset the 82595.
	 */
	CSR_WRITE_1(sc, CMD_REG, Bank1_Sel);
	CSR_WRITE_1(sc, REG1, CSR_READ_1(sc, REG1) & ~TriST_INT);
	CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);
	CSR_WRITE_1(sc, CMD_REG, Rcv_Stop);
	sc->tx_head = sc->tx_tail = sc->tx_lower_limit;
	sc->tx_last = 0; /* XXX I think these two lines are not necessary, 
				because ex_init will always be called again 
				to reinit the interface. */
	CSR_WRITE_1(sc, MASK_REG, All_Int);
	CSR_WRITE_1(sc, STATUS_REG, All_Int);
	CSR_WRITE_1(sc, CMD_REG, Reset_CMD);
	delay(200);

	DODEBUG(Start_End, printf("ex_stop: finish\n"););
}


int 
ex_intr(void *arg)
{
	struct ex_softc *sc = arg;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int int_status, send_pkts;
	int handled = 0;

	DODEBUG(Start_End, printf("exintr: start\n"););

#ifdef EX_DEBUG
	if (++exintr_count != 1)
		printf("WARNING: nested interrupt (%d). Mail the author.\n", 
	 	    exintr_count);
#endif

	send_pkts = 0;
	while ((int_status = CSR_READ_1(sc, STATUS_REG)) & (Tx_Int | Rx_Int)) {
		if (int_status & Rx_Int) {
			CSR_WRITE_1(sc, STATUS_REG, Rx_Int);
			handled = 1;
			ex_rx_intr(sc);
		} else if (int_status & Tx_Int) {
			CSR_WRITE_1(sc, STATUS_REG, Tx_Int);
			handled = 1;
			ex_tx_intr(sc);
			send_pkts = 1;
		}
   	}

  	/*
	 * If any packet has been transmitted, and there are queued packets to
 	 * be sent, attempt to send more packets to the network card.
	 */

	if (send_pkts && IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		ex_start(ifp);
#ifdef EX_DEBUG
	exintr_count--;
#endif
	DODEBUG(Start_End, printf("exintr: finish\n"););

	return handled;
}

void 
ex_tx_intr(struct ex_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	int tx_status;

	DODEBUG(Start_End, printf("ex_tx_intr: start\n"););
	/*
	 * - Cancel the watchdog.
	 * For all packets transmitted since last transmit interrupt:
	 * - Advance chain pointer to next queued packet.
	 * - Update statistics.
	 */
	ifp->if_timer = 0;
	while (sc->tx_head != sc->tx_tail) {
		CSR_WRITE_2(sc, HOST_ADDR_REG, sc->tx_head);
		if (!(CSR_READ_2(sc, IO_PORT_REG) & Done_bit))
			break;
		tx_status = CSR_READ_2(sc, IO_PORT_REG);
		sc->tx_head = CSR_READ_2(sc, IO_PORT_REG);
		if (!ISSET(tx_status, TX_OK_bit))
			ifp->if_oerrors++;
		ifp->if_collisions += tx_status & No_Collisions_bits;
	}

	/* The card should be ready to accept more packets now. */
	ifq_clr_oactive(&ifp->if_snd);
	DODEBUG(Status, printf("OIDLE tx_intr\n"););

	DODEBUG(Start_End, printf("ex_tx_intr: finish\n"););
}

void 
ex_rx_intr(struct ex_softc *sc)
{
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	int rx_status, pkt_len, QQQ;
	struct mbuf *m, *ipkt;

	DODEBUG(Start_End, printf("ex_rx_intr: start\n"););
	/*
	 * For all packets received since last receive interrupt:
	 * - If packet ok, read it into a new mbuf and queue it to interface,
	 *   updating statistics.
	 * - If packet bad, just discard it, and update statistics.
	 * Finally, advance receive stop limit in card's memory to new location.
	 */
	CSR_WRITE_2(sc, HOST_ADDR_REG, sc->rx_head);
	while (CSR_READ_2(sc, IO_PORT_REG) == RCV_Done) {
		rx_status = CSR_READ_2(sc, IO_PORT_REG);
		sc->rx_head = CSR_READ_2(sc, IO_PORT_REG);
		QQQ = pkt_len = CSR_READ_2(sc, IO_PORT_REG);
		if (rx_status & RCV_OK_bit) {
			MGETHDR(m, M_DONTWAIT, MT_DATA);
			ipkt = m;
			if (ipkt == NULL)
				ifp->if_iqdrops++;
			else {
				ipkt->m_pkthdr.len = pkt_len;
				ipkt->m_len = MHLEN;
				while (pkt_len > 0) {
					if (pkt_len >= MINCLSIZE) {
						MCLGET(m, M_DONTWAIT);
						if (m->m_flags & M_EXT)
							m->m_len = MCLBYTES;
						else {
							m_freem(ipkt);
							ifp->if_iqdrops++;
							goto rx_another;
						}
					}
					m->m_len = min(m->m_len, pkt_len);
					/*
					 * NOTE: I'm assuming that all mbufs 
					 * allocated are of even length, except
					 * for the last one in an odd-length 
					 * packet.
					 */
					CSR_READ_MULTI_2(sc, IO_PORT_REG,
					    mtod(m, caddr_t), m->m_len / 2);
					if (m->m_len & 1)
						*(mtod(m, caddr_t) + 
						    m->m_len - 1) = 
						    CSR_READ_1(sc, IO_PORT_REG);
					pkt_len -= m->m_len;
					if (pkt_len > 0) {
						MGET(m->m_next, M_DONTWAIT, 
						    MT_DATA);
					if (m->m_next == NULL) {
						m_freem(ipkt);
						ifp->if_iqdrops++;
						goto rx_another;
					}
					m = m->m_next;
					m->m_len = MLEN;
				}
			}
#ifdef EX_DEBUG
			if (debug_mask & Rcvd_Pkts) {
				if ((eh->ether_dhost[5] != 0xff) || 
				    (eh->ether_dhost[0] != 0xff)) {
					printf("Receive packet with %d data bytes: %6D -> ", QQQ, eh->ether_shost, ":");
					printf("%6D\n", eh->ether_dhost, ":");
				} /* QQQ */
			}
#endif
			ml_enqueue(&ml, ipkt);
      		}
    	} else
      		ifp->if_ierrors++;
		CSR_WRITE_2(sc, HOST_ADDR_REG, sc->rx_head);
		rx_another: ;
  	}
	if (sc->rx_head < sc->rx_lower_limit + 2)
		CSR_WRITE_2(sc, RCV_STOP_REG, sc->rx_upper_limit);
	else
		CSR_WRITE_2(sc, RCV_STOP_REG, sc->rx_head - 2);

	if_input(ifp, &ml);

	DODEBUG(Start_End, printf("ex_rx_intr: finish\n"););
}	

int 
ex_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ex_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *) data;
	int s, error = 0;

	DODEBUG(Start_End, printf("ex_ioctl: start "););

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		DODEBUG(Start_End, printf("SIOCSIFADDR"););
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			ex_init(sc);
		break;
	case SIOCSIFFLAGS:
		DODEBUG(Start_End, printf("SIOCSIFFLAGS"););
		if ((ifp->if_flags & IFF_UP) == 0 && ifp->if_flags & IFF_RUNNING) {
			ifp->if_flags &= ~IFF_RUNNING;
			ex_stop(sc);
		} else
			ex_init(sc);
		break;
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->ifmedia, cmd);
		break;
	default:
		error = ether_ioctl(ifp, &sc->arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			ex_init(sc);
		error = 0;
	}

	splx(s);
	DODEBUG(Start_End, printf("\nex_ioctl: finish\n"););
	return(error);
}

void
ex_setmulti(struct ex_softc *sc)
{
	struct arpcom *ac = &sc->arpcom;
	struct ifnet *ifp = &sc->arpcom.ac_if;
	struct ether_multi *enm;
	struct ether_multistep step;
	uint16_t *addr;
	int count, timeout, status;

	ifp->if_flags &= ~IFF_ALLMULTI;

	count = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		count++;
		ETHER_NEXT_MULTI(step, enm);
	}

	if (count > 63 || ac->ac_multirangecnt > 0)
		ifp->if_flags |= IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ifp->if_flags & IFF_ALLMULTI) {
		/*
		 * Interface is in promiscuous mode, there are too many
		 * multicast addresses for the card to handle or there
		 * is a multicast range
		 */
		CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
		CSR_WRITE_1(sc, REG2, CSR_READ_1(sc, REG2) | Promisc_Mode);
		CSR_WRITE_1(sc, REG3, CSR_READ_1(sc, REG3));
		CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);
	} else if (ifp->if_flags & IFF_MULTICAST && count > 0) {
		/* Program multicast addresses plus our MAC address
		 * into the filter */
		CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
		CSR_WRITE_1(sc, REG2, CSR_READ_1(sc, REG2) | Multi_IA);
		CSR_WRITE_1(sc, REG3, CSR_READ_1(sc, REG3));
		CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);

		/* Borrow space from TX buffer; this should be safe
		 * as this is only called from ex_init */
		
		CSR_WRITE_2(sc, HOST_ADDR_REG, sc->tx_lower_limit);
		CSR_WRITE_2(sc, IO_PORT_REG, MC_Setup_CMD);
		CSR_WRITE_2(sc, IO_PORT_REG, 0);
		CSR_WRITE_2(sc, IO_PORT_REG, 0);
		CSR_WRITE_2(sc, IO_PORT_REG, (count + 1) * 6);

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			addr = (uint16_t*)enm->enm_addrlo;
			CSR_WRITE_2(sc, IO_PORT_REG, *addr++);
			CSR_WRITE_2(sc, IO_PORT_REG, *addr++);
			CSR_WRITE_2(sc, IO_PORT_REG, *addr++);
			ETHER_NEXT_MULTI(step, enm);
		}

		/* Program our MAC address as well */
		/* XXX: Is this necessary?  The Linux driver does this
		 * but the NetBSD driver does not */
		addr = (uint16_t*) sc->arpcom.ac_enaddr;
		CSR_WRITE_2(sc, IO_PORT_REG, *addr++);
		CSR_WRITE_2(sc, IO_PORT_REG, *addr++);
		CSR_WRITE_2(sc, IO_PORT_REG, *addr++);

		CSR_READ_2(sc, IO_PORT_REG);
		CSR_WRITE_2(sc, XMT_BAR, sc->tx_lower_limit);
		CSR_WRITE_1(sc, CMD_REG, MC_Setup_CMD);

		sc->tx_head = sc->tx_lower_limit;
		sc->tx_tail = sc->tx_head + XMT_HEADER_LEN + (count + 1) * 6;

		for (timeout = 0; timeout < 100; timeout++) {
			DELAY(2);
			if ((CSR_READ_1(sc, STATUS_REG) & Exec_Int) == 0)
				continue;

			status = CSR_READ_1(sc, CMD_REG);
			CSR_WRITE_1(sc, STATUS_REG, Exec_Int);
			break;
		}

		sc->tx_head = sc->tx_tail;
	} else {
		/* No multicast or promiscuous mode */
		CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
		CSR_WRITE_1(sc, REG2, CSR_READ_1(sc, REG2) & 0xDE);
			/* ~(Multi_IA | Promisc_Mode) */
		CSR_WRITE_1(sc, REG3, CSR_READ_1(sc, REG3));
		CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);
	}
}

void 
ex_reset(struct ex_softc *sc)
{
	int s;

	DODEBUG(Start_End, printf("ex_reset: start\n"););
  
	s = splnet();
	ex_stop(sc);
	ex_init(sc);
	splx(s);

	DODEBUG(Start_End, printf("ex_reset: finish\n"););
}

void 
ex_watchdog(struct ifnet *ifp)
{
	struct ex_softc *sc = ifp->if_softc;

	DODEBUG(Start_End, printf("ex_watchdog: start\n"););

	ifq_clr_oactive(&ifp->if_snd);
	DODEBUG(Status, printf("OIDLE watchdog\n"););
	ifp->if_oerrors++;
	ex_reset(sc);
	ex_start(ifp);

	DODEBUG(Start_End, printf("ex_watchdog: finish\n"););
}

uint64_t
ex_get_media(struct ex_softc *sc)
{
	int	current, media;

	media = ex_eeprom_read(sc, EE_W5);

	CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
	current = CSR_READ_1(sc, REG3);
	CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);

	if ((current & TPE_bit) && (media & EE_W5_PORT_TPE))
		return(IFM_ETHER|IFM_10_T);
	if ((current & BNC_bit) && (media & EE_W5_PORT_BNC))
		return(IFM_ETHER|IFM_10_2);

	if (media & EE_W5_PORT_AUI)
		return (IFM_ETHER|IFM_10_5);

	return (IFM_ETHER|IFM_AUTO);
}

int
ex_ifmedia_upd (struct ifnet *ifp)
{
	struct ex_softc *sc = ifp->if_softc;

	if (IFM_TYPE(sc->ifmedia.ifm_media) != IFM_ETHER)
		return (EINVAL);

	return (0);
}

void
ex_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct ex_softc *sc = ifp->if_softc;

	ifmr->ifm_status = IFM_AVALID | IFM_ACTIVE;
	ifmr->ifm_active = ex_get_media(sc);
}

u_short 
ex_eeprom_read(struct ex_softc *sc, int location)
{
	int i;
	u_short data = 0;
	int read_cmd = location | EE_READ_CMD;
	short ctrl_val = EECS;

	CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
	CSR_WRITE_1(sc, EEPROM_REG, EECS);
	for (i = 8; i >= 0; i--) {
		short outval = (read_cmd & (1 << i)) ? ctrl_val | EEDI : 
		    ctrl_val;
		CSR_WRITE_1(sc, EEPROM_REG, outval);
		CSR_WRITE_1(sc, EEPROM_REG, outval | EESK);
		delay(3);
		CSR_WRITE_1(sc, EEPROM_REG, outval);
		delay(2);
	}
	CSR_WRITE_1(sc, EEPROM_REG, ctrl_val);
	for (i = 16; i > 0; i--) {
		CSR_WRITE_1(sc, EEPROM_REG, ctrl_val | EESK);
		delay(3);
		data = (data << 1) | ((CSR_READ_1(sc, EEPROM_REG) & EEDO) ? 1 : 0);
		CSR_WRITE_1(sc, EEPROM_REG, ctrl_val);
		delay(2);
	}
	ctrl_val &= ~EECS;
	CSR_WRITE_1(sc, EEPROM_REG, ctrl_val | EESK);
	delay(3);
	CSR_WRITE_1(sc, EEPROM_REG, ctrl_val);
	delay(2);
	CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);
	return(data);
}
@


1.45
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.44 2016/04/13 10:49:26 mpi Exp $	*/
d619 1
a619 1
		if (!CSR_READ_2(sc, IO_PORT_REG) & Done_bit)
@


1.44
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.43 2015/11/25 03:09:59 dlg Exp $	*/
a517 1
			ifp->if_opackets++;
d623 1
a623 3
		if (tx_status & TX_OK_bit)
			ifp->if_opackets++;
		else
@


1.43
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.42 2015/11/20 03:35:23 dlg Exp $	*/
a254 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.42
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.41 2015/10/25 13:13:06 mpi Exp $	*/
d358 1
a358 1
	ifp->if_flags &= ~IFF_OACTIVE;
d391 1
a391 1
	while (!(ifp->if_flags & IFF_OACTIVE)) {
d523 1
a523 1
			ifp->if_flags |= IFF_OACTIVE;
d633 1
a633 1
	ifp->if_flags &= ~IFF_OACTIVE;
d892 1
a892 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.41
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.40 2015/09/11 13:02:28 stsp Exp $	*/
d392 1
a392 1
		IFQ_POLL(&ifp->if_snd, opkt);
d417 1
a417 1
      			IFQ_DEQUEUE(&ifp->if_snd, opkt);
d522 1
@


1.40
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.39 2015/06/24 09:40:54 mpi Exp $	*/
a733 1
	struct ifaddr *ifa = (struct ifaddr *) data;
a746 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.39
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.38 2015/05/19 11:24:01 mpi Exp $	*/
d112 1
a112 1
int ex_get_media(struct ex_softc *);
d903 1
a903 1
int
@


1.38
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.37 2014/12/22 02:28:51 tedu Exp $	*/
a712 1
			ifp->if_ipackets++;
@


1.37
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.36 2010/07/02 02:29:45 tedu Exp $	*/
d642 1
a664 1
				ipkt->m_pkthdr.rcvif = ifp;
a712 6
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, ipkt,
				    BPF_DIRECTION_IN);
#endif
			ether_input_mbuf(ifp, ipkt);
d714 1
d725 2
@


1.36
log
@some very obvious uninit bugs found when I turned off -Wno-uninitialized
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.35 2008/11/28 02:44:17 brad Exp $	*/
a50 1
#ifdef INET
a52 1
#endif
a751 1
#ifdef INET
a753 1
#endif
@


1.35
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.34 2008/11/22 13:14:35 oga Exp $	*/
d567 1
a567 1
	int handled;
d588 1
a588 2
  		} else
			handled = 0;
@


1.34
log
@cast pointer to correct type before passing it to bus space. Noticed while
de-inlining i386 bus_space.

ok weingart@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.33 2008/10/02 20:21:13 brad Exp $	*/
d740 1
a741 1
	struct ex_softc *sc = ifp->if_softc;
a767 19
	case SIOCSIFMTU:
		DODEBUG(Start_End, printf("SIOCSIFMTU"););
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI)
			? ether_addmulti(ifr, &sc->arpcom)
			: ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				ex_init(sc);
			error = 0;
		}
		break;
d774 6
@


1.33
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.32 2007/10/21 03:02:09 brad Exp $	*/
d139 2
a140 1
	bus_space_read_multi_2((sc)->sc_iot, (sc)->sc_ioh, (off), (addr), (count))
d147 2
a148 1
	bus_space_write_multi_2((sc)->sc_iot, (sc)->sc_ioh, (off), (addr), (count))
@


1.32
log
@Remove a bogus and unnecessary check for if_addrlist from ex_init().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.31 2007/10/21 02:25:27 brad Exp $	*/
a746 5
	if ((error = ether_ioctl(ifp, &sc->arpcom, cmd, data)) > 0) {
		splx(s);
		return (error);
	}

d790 1
a790 3
		DODEBUG(Start_End, printf("unknown"););
		error = ENOTTY;
		break;
a793 1

@


1.31
log
@Add multicast support.

Tested by todd@@ with IPv6.

Based on similar changes to the FreeBSD driver.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.30 2007/10/21 00:55:55 brad Exp $	*/
a295 2
	if (TAILQ_EMPTY(&ifp->if_addrlist))
		return;
@


1.30
log
@Add ifmedia support.

Tested by todd@@

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.29 2007/10/18 04:52:37 brad Exp $	*/
d111 1
d254 1
a254 2
	ifp->if_flags = IFF_SIMPLEX | IFF_BROADCAST; /* XXX not done yet. 
						       | IFF_MULTICAST */
d362 3
a364 1
	
a780 1
		DODEBUG(Start_End, printf("SIOCADDMULTI"););
d782 9
a790 3
		DODEBUG(Start_End, printf("SIOCDELMULTI"););
		/* XXX Support not done yet. */
		error = EINVAL;
d806 94
@


1.29
log
@Eliminate unnecessary resets when calling the SIOCSIFADDR ioctl.

Tested by todd@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.28 2007/10/06 06:35:57 brad Exp $	*/
d49 1
a77 4
#define Conn_BNC 1
#define Conn_TPE 2
#define Conn_AUI 3

d80 1
a81 1
	u_short connector;	/* Connector type. */
d113 4
a203 1
	 *	- Connector type.
d229 1
a229 8
	CSR_WRITE_1(sc, CMD_REG, Bank2_Sel);
	tmp = CSR_READ_1(sc, REG3);
	if (tmp & TPE_bit)
		sc->connector = Conn_TPE;
	else if (tmp & BNC_bit)
		sc->connector = Conn_BNC;
	else
		sc->connector = Conn_AUI;
a232 2
	CSR_WRITE_1(sc, CMD_REG, Bank0_Sel);

d243 2
d257 18
d277 1
a277 1
	printf(": address %s, connecter ", 
a278 6
	switch(sc->connector) {
		case Conn_TPE: printf("TPE\n"); break;
		case Conn_BNC: printf("BNC\n"); break;
		case Conn_AUI: printf("AUI\n"); break;
		default: printf("???\n");
	}
d785 4
d830 42
@


1.28
log
@Rename bus_space macros. ISA_GET/PUT -> CSR_READ/WRITE

Tested by todd@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.27 2007/09/20 05:48:46 brad Exp $	*/
d751 2
a752 2

		switch(ifa->ifa_addr->sa_family) {
d754 3
a756 9
			case AF_INET:
				ex_init(sc);
				arp_ifinit((struct arpcom *) ifp, ifa);
				break;
#endif
			default:
				ex_init(sc);
				break;
		}
@


1.27
log
@replace the BANK_SEL bus space macro usage with the ISA_PUT macro and remove
BANK_SEL.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.26 2007/09/19 07:29:04 brad Exp $	*/
d132 13
a144 11
#define ISA_GET(offset) bus_space_read_1(sc->sc_iot, sc->sc_ioh, (offset))
#define ISA_PUT(offset, value) bus_space_write_1(sc->sc_iot, sc->sc_ioh, \
 	(offset), (value))	
#define ISA_GET_2(offset) bus_space_read_2(sc->sc_iot, sc->sc_ioh, \
	(offset))
#define ISA_PUT_2(offset, value) bus_space_write_2(sc->sc_iot, sc->sc_ioh, \
	(offset), (value))
#define ISA_GET_2_MULTI(offset, addr, count) bus_space_read_multi_2( \
	sc->sc_iot, sc->sc_ioh, (offset), (addr), (count))
#define ISA_PUT_2_MULTI(offset, addr, count) bus_space_write_multi_2( \
	sc->sc_iot, sc->sc_ioh, (offset), (addr), (count))
d155 1
a155 1
	if (((count1 = ISA_GET(ID_REG)) & Id_Mask) != Id_Sig)
d157 3
a159 3
	count2 = ISA_GET(ID_REG);
	count2 = ISA_GET(ID_REG);
	count2 = ISA_GET(ID_REG);
d194 1
a194 1
	ISA_PUT(CMD_REG, Reset_CMD);
d229 2
a230 2
	ISA_PUT(CMD_REG, Bank2_Sel);
	tmp = ISA_GET(REG3);
d240 1
a240 1
	ISA_PUT(CMD_REG, Bank0_Sel);
d299 2
a300 2
	ISA_PUT(CMD_REG, Bank2_Sel);
	temp_reg = ISA_GET(EEPROM_REG);
d302 1
a302 1
		ISA_PUT(EEPROM_REG, temp_reg & ~Trnoff_Enable);
d304 1
a304 1
		ISA_PUT(I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);
d312 7
a318 6
	ISA_PUT(REG1, ISA_GET(REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp | 
	    Disc_Bad_Fr);
	ISA_PUT(REG2, ISA_GET(REG2) | No_SA_Ins | RX_CRC_InMem);
	ISA_PUT(REG3, (ISA_GET(REG3) & 0x3f));
	ISA_PUT(CMD_REG, Bank1_Sel);
	ISA_PUT(INT_NO_REG, (ISA_GET(INT_NO_REG) & 0xf8) | 
d332 5
a336 5
 	ISA_PUT(RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);
        ISA_PUT(RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);
        ISA_PUT(XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);
	ISA_PUT(XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);
	
d340 4
a343 4
	ISA_PUT(REG1, ISA_GET(REG1) | TriST_INT);
	ISA_PUT(CMD_REG, Bank0_Sel);
	ISA_PUT(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
	ISA_PUT(STATUS_REG, All_Int);
d348 1
a348 1
	ISA_PUT_2(RCV_BAR, sc->rx_lower_limit);
d350 2
a351 2
	ISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit | 0xfe);
	ISA_PUT_2(XMT_BAR, sc->tx_lower_limit);
d361 1
a361 1
	ISA_PUT(CMD_REG, Sel_Reset_CMD);
d363 1
a363 1
	ISA_PUT(CMD_REG, Rcv_Enable_CMD);
d421 1
a421 1
			ISA_WRITE(MASK_REG, All_Int);
d442 5
a446 5
			ISA_PUT_2(HOST_ADDR_REG, dest);
			ISA_PUT_2(IO_PORT_REG, Transmit_CMD);
			ISA_PUT_2(IO_PORT_REG, 0);
			ISA_PUT_2(IO_PORT_REG, next);
			ISA_PUT_2(IO_PORT_REG, data_len);
d458 1
a458 1
					ISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);
d460 1
a460 1
				ISA_PUT_2_MULTI(IO_PORT_REG, mtod(m, caddr_t) 
d467 1
a467 1
				ISA_PUT_2_MULTI(IO_PORT_REG, tmp16, 1);
d475 1
a475 1
					ISA_PUT_2(HOST_ADDR_REG, 
d477 1
a477 1
					ISA_PUT_2(IO_PORT_REG, dest);
d479 1
a479 1
				ISA_PUT_2(HOST_ADDR_REG, sc->tx_last + 
d481 2
a482 2
				i = ISA_GET_2(IO_PORT_REG);
				ISA_PUT_2(HOST_ADDR_REG, sc->tx_last + 
d484 1
a484 1
				ISA_PUT_2(IO_PORT_REG, i | Ch_bit);
d493 1
a493 1
			ISA_GET_2(IO_PORT_REG);
d495 1
a495 1
			ISA_PUT_2(MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
d498 2
a499 2
				ISA_PUT_2(XMT_BAR, dest);
				ISA_PUT(CMD_REG, Transmit_CMD);
d503 1
a503 1
				ISA_PUT(CMD_REG, Resume_XMT_List_CMD);
d537 4
a540 4
	ISA_PUT(CMD_REG, Bank1_Sel);
	ISA_PUT(REG1, ISA_GET(REG1) & ~TriST_INT);
	ISA_PUT(CMD_REG, Bank0_Sel);
	ISA_PUT(CMD_REG, Rcv_Stop);
d545 3
a547 3
	ISA_PUT(MASK_REG, All_Int);
	ISA_PUT(STATUS_REG, All_Int);
	ISA_PUT(CMD_REG, Reset_CMD);
d571 1
a571 1
	while ((int_status = ISA_GET(STATUS_REG)) & (Tx_Int | Rx_Int)) {
d573 1
a573 1
			ISA_PUT(STATUS_REG, Rx_Int);
d577 1
a577 1
			ISA_PUT(STATUS_REG, Tx_Int);
d615 2
a616 2
		ISA_PUT_2(HOST_ADDR_REG, sc->tx_head);
		if (! ISA_GET_2(IO_PORT_REG) & Done_bit)
d618 2
a619 2
		tx_status = ISA_GET_2(IO_PORT_REG);
		sc->tx_head = ISA_GET_2(IO_PORT_REG);
d649 5
a653 5
	ISA_PUT_2(HOST_ADDR_REG, sc->rx_head);
	while (ISA_GET_2(IO_PORT_REG) == RCV_Done) {
		rx_status = ISA_GET_2(IO_PORT_REG);
		sc->rx_head = ISA_GET_2(IO_PORT_REG);
		QQQ = pkt_len = ISA_GET_2(IO_PORT_REG);
d681 1
a681 1
					ISA_GET_2_MULTI(IO_PORT_REG,
d686 1
a686 1
						    ISA_GET(IO_PORT_REG);
d719 1
a719 1
		ISA_PUT_2(HOST_ADDR_REG, sc->rx_head);
d723 1
a723 1
		ISA_PUT_2(RCV_STOP_REG, sc->rx_upper_limit);
d725 1
a725 1
		ISA_PUT_2(RCV_STOP_REG, sc->rx_head - 2);
d837 2
a838 2
	ISA_PUT(CMD_REG, Bank2_Sel);
	ISA_PUT(EEPROM_REG, EECS);
d842 2
a843 2
		ISA_PUT(EEPROM_REG, outval);
		ISA_PUT(EEPROM_REG, outval | EESK);
d845 1
a845 1
		ISA_PUT(EEPROM_REG, outval);
d848 1
a848 1
	ISA_PUT(EEPROM_REG, ctrl_val);
d850 1
a850 1
		ISA_PUT(EEPROM_REG, ctrl_val | EESK);
d852 2
a853 2
		data = (data << 1) | ((ISA_GET(EEPROM_REG) & EEDO) ? 1 : 0);
		ISA_PUT(EEPROM_REG, ctrl_val);
d857 1
a857 1
	ISA_PUT(EEPROM_REG, ctrl_val | EESK);
d859 1
a859 1
	ISA_PUT(EEPROM_REG, ctrl_val);
d861 1
a861 1
	ISA_PUT(CMD_REG, Bank0_Sel);
@


1.26
log
@a little more cleaning. removing some useless comments.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.25 2007/09/19 07:11:18 brad Exp $	*/
a131 2
#define BANK_SEL(X) bus_space_write_1(sc->sc_iot, sc->sc_ioh, CMD_REG, \
	(X))
d227 1
a227 1
	BANK_SEL(Bank2_Sel);
d238 1
a238 1
	BANK_SEL(Bank0_Sel);
d297 1
a297 1
	BANK_SEL(Bank2_Sel);
d314 1
a314 1
	BANK_SEL(Bank1_Sel);
d338 1
a338 1
	BANK_SEL(Bank0_Sel);
d534 1
a534 1
	BANK_SEL(Bank1_Sel);
d536 1
a536 1
	BANK_SEL(Bank0_Sel);
d834 1
a834 1
	BANK_SEL(Bank2_Sel);
d858 1
a858 1
	BANK_SEL(Bank0_Sel);
@


1.25
log
@In ex_rx_intr() allocate an mbuf cluster if the pkt_len is >= MINCLSIZE.

From FreeBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.24 2007/09/19 06:44:57 brad Exp $	*/
a123 1

a252 3
	/* struct ifaddr *ifa; 	XXX what are these for? */
	/* struct sockaddr_dl *sdl; */

a254 4
	/*
	 * Initialize the ifnet structure.

	 */
a263 3
	/*
	 * Attach the interface.
	 */
@


1.24
log
@sprinkle a few tabs on ex_ioctl() to make things easier on the eyes.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.23 2007/09/19 06:28:38 brad Exp $	*/
d674 1
a674 1
					if (pkt_len > MINCLSIZE) {
@


1.23
log
@call ether_ioctl() from within ex_ioctl().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.22 2007/09/19 06:14:24 brad Exp $	*/
d758 5
a762 5
		case SIOCSIFADDR:
			DODEBUG(Start_End, printf("SIOCSIFADDR"););
			ifp->if_flags |= IFF_UP;
    
			switch(ifa->ifa_addr->sa_family) {
d764 37
a800 38
				case AF_INET:
					ex_init(sc);
					arp_ifinit((struct arpcom *) ifp, ifa);
					break;
#endif
    default:
      ex_init(sc);
      break;
    }
    break;
  case SIOCSIFFLAGS:
    DODEBUG(Start_End, printf("SIOCSIFFLAGS"););
    if ((ifp->if_flags & IFF_UP) == 0 && ifp->if_flags & IFF_RUNNING) {
      ifp->if_flags &= ~IFF_RUNNING;
      ex_stop(sc);
    }
    else
      ex_init(sc);
    break;
  case SIOCSIFMTU:
    DODEBUG(Start_End, printf("SIOCSIFMTU"););
    if (ifr->ifr_mtu > ETHERMTU || ifr->ifr_mtu < ETHERMIN) {
      error = EINVAL;
    } else if (ifp->if_mtu != ifr->ifr_mtu) {
      ifp->if_mtu = ifr->ifr_mtu;
    }
    break;
  case SIOCADDMULTI:
    DODEBUG(Start_End, printf("SIOCADDMULTI"););
  case SIOCDELMULTI:
    DODEBUG(Start_End, printf("SIOCDELMULTI"););
    /* XXX Support not done yet. */
    error = EINVAL;
    break;
  default:
    DODEBUG(Start_End, printf("unknown"););
    error = ENOTTY;
  }
d802 1
a802 1
  splx(s);
d804 2
a805 2
  DODEBUG(Start_End, printf("\nex_ioctl: finish\n"););
  return(error);
@


1.22
log
@remove the SIOCGIFADDR ioctl handler and return ENOTTY instead of EINVAL
upon error in ex_ioctl().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.21 2007/09/19 05:29:47 brad Exp $	*/
d751 5
@


1.21
log
@rename a few functions.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.20 2007/09/19 05:09:09 brad Exp $	*/
a768 10
  case SIOCGIFADDR:
    {
      struct sockaddr *sa;

      DODEBUG(Start_End, printf("SIOCGIFADDR"););
      sa = (struct sockaddr *) &ifr->ifr_data;
      bcopy((caddr_t) sc->arpcom.ac_enaddr, (caddr_t) sa->sa_data, 
	    ETHER_ADDR_LEN);
    }
  break;
d795 1
a795 1
    error = EINVAL;
@


1.20
log
@don't need to wrap the code in #if NEX > 0

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.19 2007/09/19 04:52:15 brad Exp $	*/
d65 1
a65 2

#ifdef EXDEBUG
a76 1

d117 4
a120 3
u_short eeprom_read(struct ex_softc *, int);
int look_for_card(struct isa_attach_args *, struct ex_softc *sc);
int exintr(void *);
d148 1
a148 1
look_for_card(struct isa_attach_args *ia, struct ex_softc *sc)
d183 1
a183 1
		if (!look_for_card(ia, sc)) {
d207 1
a207 1
	eaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Lo);
d210 1
a210 1
	eaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Mid);
d213 1
a213 1
	eaddr_tmp = eeprom_read(sc, EE_Eth_Addr_Hi);
d216 1
a216 1
	tmp = eeprom_read(sc, EE_IRQ_No) & IRQ_No_Mask;
d287 1
a287 1
	    IPL_NET, exintr, sc, self->dv_xname);
d565 1
a565 1
exintr(void *arg)
d574 1
a574 1
#ifdef EXDEBUG
d602 1
a602 1
#ifdef EXDEBUG
d710 1
a710 1
#ifdef EXDEBUG
d846 1
a846 1
eeprom_read(struct ex_softc *sc, int location)
@


1.19
log
@ex_start() is always called at splnet, so remove the unnecessary splnet.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.18 2007/09/19 03:55:05 brad Exp $	*/
a37 2
#include "ex.h"
#if NEX > 0
a880 2

#endif /* NEX > 0 */
@


1.18
log
@de-static

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.17 2007/09/17 01:20:03 brad Exp $	*/
d388 1
a388 1
	int i, s, len, data_len, avail, dest, next;
a394 2
	s = splnet();

a533 2

	splx(s);
@


1.17
log
@A little cleaning..
- de-register
- ANSI functions
- remove a commented out and bogus ioctl

Tested by todd@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.16 2007/06/06 09:44:30 henning Exp $	*/
d112 14
a125 14
static int ex_probe(struct device *, void *, void *);
static void ex_attach(struct device *, struct device *, void *);
static void ex_init(struct ex_softc *);
static void ex_start(struct ifnet *);
static void ex_stop(struct ex_softc *);
static int ex_ioctl(struct ifnet *, u_long, caddr_t);
static void ex_reset(struct ex_softc *);
static void ex_watchdog(struct ifnet *);

static u_short eeprom_read(struct ex_softc *, int);
static int look_for_card(struct isa_attach_args *, struct ex_softc *sc);
static int exintr(void *);
static void ex_tx_intr(struct ex_softc *);
static void ex_rx_intr(struct ex_softc *);
d150 1
a150 1
static int 
d852 1
a852 1
static u_short 
@


1.16
log
@remove never used #ifdef IPX_NOTYET code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.15 2006/03/25 22:41:44 djm Exp $	*/
a107 3
/* static struct ex_softc ex_sc[NEX]; XXX would it be better to malloc(3) 
					the memory? */

a148 1
	
d151 1
a151 3
look_for_card(ia, sc)
	struct isa_attach_args *ia;
	struct ex_softc *sc;
a169 1

d171 1
a171 3
ex_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
a249 1

d251 1
a251 3
ex_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a295 1

d297 1
a297 2
ex_init(sc)
	struct ex_softc *sc;
a383 1

d385 1
a385 2
ex_start(ifp)
	struct ifnet *ifp;
d387 1
a387 1
	register struct ex_softc *sc = ifp->if_softc;
d391 1
a391 1
	register struct mbuf *m;
a541 1

d543 1
a543 2
ex_stop(sc)
	struct ex_softc *sc;
d572 1
a572 2
exintr(arg)
	void *arg;
a616 1

d618 1
a618 2
ex_tx_intr(sc)
	struct ex_softc *sc;
d620 1
a620 1
	register struct ifnet *ifp = &sc->arpcom.ac_if;
a650 1

d652 1
a652 2
ex_rx_intr(sc)
	struct ex_softc *sc;
d654 1
a654 1
	register struct ifnet *ifp = &sc->arpcom.ac_if;
d656 1
a656 1
	register struct mbuf *m, *ipkt;
a746 1

d748 1
a748 4
ex_ioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
d750 1
a750 1
	register struct ifaddr *ifa = (struct ifaddr *) data;
a794 6
#ifdef NODEF
  case SIOCGHWADDR:
    DODEBUG(Start_End, printf("SIOCGHWADDR"););
    bcopy((caddr_t) sc->sc_addr, (caddr_t) &ifr->ifr_data, sizeof(sc->sc_addr));
    break;
#endif
a820 1

d822 1
a822 2
ex_reset(sc)
	struct ex_softc *sc;
a835 1

d837 1
a837 2
ex_watchdog(ifp)
	struct ifnet *ifp;
a851 1

d853 1
a853 3
eeprom_read(sc, location)
	struct ex_softc *sc;
	int location;
@


1.15
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.14 2005/11/09 05:46:21 brad Exp $	*/
a56 5
#ifdef IPX
#include <netipx/ipx.h>
#include <netipx/ipx_if.h>
#endif

a796 22
#endif
#ifdef IPX_NOTYET
				case AF_IPX:
				{
					register struct ipx_addr *ina = 
					    &(IA_SIPX(ifa)->sipx_addr);

					if (ipx_nullhost(*ina))
					ina->x_host = *(union ipx_host *) 
					    (sc->arpcom.ac_enaddr);
					else {
	  					ifp->if_flags &= ~IFF_RUNNING;
	  					bcopy((caddr_t) 
						    ina->x_host.c_host,
						    (caddr_t) 
						    sc->arpcom.ac_enaddr, 
						    sizeof(sc->arpcom.ac_enaddr)
						    );
					}
					ex_init(sc);
					break;
     				}
@


1.14
log
@splimp -> splnet
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.13 2005/06/08 17:03:00 henning Exp $	*/
d546 2
a547 1
				bpf_mtap(ifp->if_bpf, opkt);
d756 2
a757 1
				bpf_mtap(ifp->if_bpf, ipkt);
@


1.13
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.12 2005/04/03 10:29:12 brad Exp $	*/
d326 1
a326 1
	s = splimp();
d416 1
a416 1
	s = splimp();
d454 1
a454 1
			 * routines. XXX Is this necessary with splimp() 
d787 1
a787 1
	s = splimp();
d888 1
a888 1
	s = splimp();
@


1.12
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.11 2005/04/02 03:20:26 brad Exp $	*/
a61 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a821 16
#endif
#ifdef NS
				case AF_NS:
      				{
	register struct ns_addr *ina = &(IA_SNS(ifa)->sns_addr);

	if (ns_nullhost(*ina))
	  ina->x_host = *(union ns_host *) (sc->arpcom.ac_enaddr);
	else {
	  ifp->if_flags &= ~IFF_RUNNING;
	  bcopy((caddr_t) ina->x_host.c_host, (caddr_t) sc->arpcom.ac_enaddr, 
		sizeof(sc->arpcom.ac_enaddr));
	}
	ex_init(sc);
	break;
      }
@


1.11
log
@support setting the MTU
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.10 2004/12/26 21:22:13 miod Exp $	*/
a688 1
	struct ether_header *eh;
a748 1
			eh = mtod(ipkt, struct ether_header *);
d762 1
a762 2
			m_adj(ipkt, sizeof(struct ether_header));
			ether_input(ifp, eh, ipkt);
@


1.10
log
@Use list and queue macros where applicable to make the code easier to read;
no change in compiler assembly output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.9 2004/09/23 17:45:16 brad Exp $	*/
a876 1
#if 0						/* XXX can we do this? */
d879 1
a879 1
    if (ifr->if_mtu > ETHERMTU)
d881 1
a881 1
    else
d883 1
a884 1
#endif 
@


1.9
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.8 2002/03/14 01:26:56 millert Exp $	*/
d329 1
a329 1
	if (ifp->if_addrlist.tqh_first == NULL)
@


1.8
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.7 2001/06/27 06:34:46 kjc Exp $	*/
a289 1
	ifp->if_output = ether_output;
a292 1
	ifp->if_mtu = ETHERMTU;
@


1.7
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.6 2001/02/20 19:39:40 mickey Exp $	*/
d125 14
a138 14
static int ex_probe __P((struct device *, void *, void *));
static void ex_attach __P((struct device *, struct device *, void *));
static void ex_init __P((struct ex_softc *));
static void ex_start __P((struct ifnet *));
static void ex_stop __P((struct ex_softc *));
static int ex_ioctl __P((struct ifnet *, u_long, caddr_t));
static void ex_reset __P((struct ex_softc *));
static void ex_watchdog __P((struct ifnet *));

static u_short eeprom_read __P((struct ex_softc *, int));
static int look_for_card __P((struct isa_attach_args *, struct ex_softc *sc));
static int exintr __P((void *));
static void ex_tx_intr __P((struct ex_softc *));
static void ex_rx_intr __P((struct ex_softc *));
@


1.7.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.7 2001/06/27 06:34:46 kjc Exp $	*/
d125 14
a138 14
static int ex_probe(struct device *, void *, void *);
static void ex_attach(struct device *, struct device *, void *);
static void ex_init(struct ex_softc *);
static void ex_start(struct ifnet *);
static void ex_stop(struct ex_softc *);
static int ex_ioctl(struct ifnet *, u_long, caddr_t);
static void ex_reset(struct ex_softc *);
static void ex_watchdog(struct ifnet *);

static u_short eeprom_read(struct ex_softc *, int);
static int look_for_card(struct isa_attach_args *, struct ex_softc *sc);
static int exintr(void *);
static void ex_tx_intr(struct ex_softc *);
static void ex_rx_intr(struct ex_softc *);
@


1.6
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.5 1999/04/19 07:10:06 fgsch Exp $	*/
d297 1
d429 4
a432 2
	while (((opkt = ifp->if_snd.ifq_head) != NULL) && 
	    !(ifp->if_flags & IFF_OACTIVE)) {
d455 1
a455 1
      			IF_DEQUEUE(&ifp->if_snd, opkt);
d637 1
a637 1
	if (send_pkts && (ifp->if_snd.ifq_head != NULL))
@


1.5
log
@Fix a bug that prevents the correct detection of the card.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.4 1999/02/28 03:23:38 jason Exp $	*/
a310 8

	/*
	 * If BPF is in the kernel, call the attach for it
	 */
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, 
	    sizeof(struct ether_header));
#endif
@


1.5.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.6 2001/02/20 19:39:40 mickey Exp $	*/
d311 8
@


1.5.4.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.5.4.1 2001/05/14 22:24:42 niklas Exp $	*/
a296 1
	IFQ_SET_READY(&ifp->if_snd);
d428 2
a429 4
	while (!(ifp->if_flags & IFF_OACTIVE)) {
		IFQ_POLL(&ifp->if_snd, opkt);
		if (opkt == NULL)
			break;
d452 1
a452 1
      			IFQ_DEQUEUE(&ifp->if_snd, opkt);
d634 1
a634 1
	if (send_pkts && IFQ_IS_EMPTY(&ifp->if_snd) == 0)
@


1.5.4.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 14
a138 14
static int ex_probe(struct device *, void *, void *);
static void ex_attach(struct device *, struct device *, void *);
static void ex_init(struct ex_softc *);
static void ex_start(struct ifnet *);
static void ex_stop(struct ex_softc *);
static int ex_ioctl(struct ifnet *, u_long, caddr_t);
static void ex_reset(struct ex_softc *);
static void ex_watchdog(struct ifnet *);

static u_short eeprom_read(struct ex_softc *, int);
static int look_for_card(struct isa_attach_args *, struct ex_softc *sc);
static int exintr(void *);
static void ex_tx_intr(struct ex_softc *);
static void ex_rx_intr(struct ex_softc *);
@


1.4
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.3 1999/02/13 01:02:21 fgsch Exp $	*/
a193 4
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh;

	int iobase;
d199 4
a202 4
	iobase = ia->ia_iobase;

	if ((iobase >= 0x200) && (iobase <= 0x3a0)) {
		if(bus_space_map(iot, iobase, EX_IOSIZE, 0, &ioh))
d206 1
a206 1
			bus_space_unmap(iot, ioh, EX_IOSIZE);
d228 1
a228 1
	sc->iobase = iobase;
@


1.3
log
@If the card is not present be sure to always call bus_space_unmap on exit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.2 1997/11/09 22:21:22 gene Exp $	*/
d772 1
a772 1
			if (ifp->if_bpf != NULL) {
a773 17
				/*
 				 * Note that the interface cannot be in 
				 * promiscuous mode if there are no BPF 
				 * listeners. And if we are in promiscuous 
 				 * mode, we have to check if this packet is 
				 * really ours.
 				 */
				if ((ifp->if_flags & IFF_PROMISC) &&
		    		    (eh->ether_dhost[0] & 1) == 0 &&
		    		    bcmp(eh->ether_dhost, sc->arpcom.ac_enaddr, 
			 	    sizeof(eh->ether_dhost)) != 0 &&
		    		    bcmp(eh->ether_dhost, etherbroadcastaddr, 
			 	    sizeof(eh->ether_dhost)) != 0) {
					m_freem(ipkt);
					goto rx_another;
				}
			}
@


1.2
log
@Sweeping changes from Don Schmidt (yensid@@imsa.edu) to busify this driver.
Add copyright for this amount of rewrite.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ex.c,v 1.1 1997/09/11 21:30:49 gene Exp $	*/
a170 4
	sc->sc_ioh = ia->ia_iot;
	if(bus_space_map(ia->ia_iot, ia->ia_iobase, EX_IOSIZE, 0, &sc->sc_ioh)) 
		return(0);

d182 1
a182 2
	else {
		bus_space_unmap(sc->sc_iot, sc->sc_ioh, EX_IOSIZE);
a183 1
	}
d194 2
d206 5
a210 1
		if (look_for_card(ia, sc) == 0)
d212 1
a216 1
/*	ia->ia_iobase = iobase; */
@


1.1
log
@Driver for ISA EtherExpress Pro/10 ethernet card.
This is ported from the FreeBSD driver, and all porting work (and testing)
was done by Don Schmidt (yensid@@imsa.edu).
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d3 1
d72 1
a72 1
#include <machine/pio.h>  /* XXX convert */
d113 2
d134 2
a135 2
static u_short eeprom_read __P((int, int));
static int look_for_card __P((u_int));
d149 15
d165 3
a167 2
look_for_card(iobase)
	u_int iobase;
d171 4
d179 9
a187 1
	if (((count1 = inb(iobase + ID_REG)) & Id_Mask) != Id_Sig)
d189 1
a189 4
	count2 = inb(iobase + ID_REG);
	count2 = inb(iobase + ID_REG);
	count2 = inb(iobase + ID_REG);
	return((count2 & Counter_bits) == ((count1 + 0xc0) & Counter_bits));
d210 1
a210 1
		if (look_for_card(iobase) == 0)
a211 11
	}
	else if (iobase == IOBASEUNK) {	
		tmp = 0;
	for (iobase = 0x200; iobase <= 0x3a0; iobase += EX_IOSIZE) {
			if (look_for_card(iobase) == 1) {
				tmp = 1;
				break;	
			}
		}
		if (tmp != 1)
			return(0);
d216 1
a216 1
	ia->ia_iobase = iobase;
d221 1
a221 1
	outb(iobase + CMD_REG, Reset_CMD);
d233 1
a233 1
	eaddr_tmp = eeprom_read(iobase, EE_Eth_Addr_Lo);
d236 1
a236 1
	eaddr_tmp = eeprom_read(iobase, EE_Eth_Addr_Mid);
d239 1
a239 1
	eaddr_tmp = eeprom_read(iobase, EE_Eth_Addr_Hi);
d242 1
a242 1
	tmp = eeprom_read(iobase, EE_IRQ_No) & IRQ_No_Mask;
d256 2
a257 2
	outb(iobase + CMD_REG, Bank2_Sel);
	tmp = inb(iobase + REG3);
d267 1
a267 1
	outb(iobase + CMD_REG, Bank0_Sel);
a337 1
	register int iobase = sc->iobase;
d350 2
a351 2
	outb(iobase + CMD_REG, Bank2_Sel);
	temp_reg = inb(iobase + EEPROM_REG);
d353 1
a353 1
		outb(iobase + EEPROM_REG, temp_reg & ~Trnoff_Enable);
d355 1
a355 1
		outb(iobase + I_ADDR_REG0 + i, sc->arpcom.ac_enaddr[i]);
d363 1
a363 1
	outb(iobase + REG1, inb(iobase + REG1) | Tx_Chn_Int_Md | Tx_Chn_ErStp |
d365 4
a368 4
	outb(iobase + REG2, inb(iobase + REG2) | No_SA_Ins | RX_CRC_InMem);
	outb(iobase + REG3, inb(iobase + REG3) & 0x3f /* XXX constants. */ );
	outb(iobase + CMD_REG, Bank1_Sel);
	outb(iobase + INT_NO_REG, (inb(iobase + INT_NO_REG) & 0xf8) | 
d382 4
a385 4
	outb(iobase + RCV_LOWER_LIMIT_REG, sc->rx_lower_limit >> 8);
	outb(iobase + RCV_UPPER_LIMIT_REG, sc->rx_upper_limit >> 8);
	outb(iobase + XMT_LOWER_LIMIT_REG, sc->tx_lower_limit >> 8);
	outb(iobase + XMT_UPPER_LIMIT_REG, sc->tx_upper_limit >> 8);
d390 4
a393 4
	outb(iobase + REG1, inb(iobase + REG1) | TriST_INT);
	outb(iobase + CMD_REG, Bank0_Sel);
	outb(iobase + MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
	outb(iobase + STATUS_REG, All_Int);
d398 1
a398 1
	outw(iobase + RCV_BAR, sc->rx_lower_limit);
d400 2
a401 2
	outw(iobase + RCV_STOP_REG, sc->rx_upper_limit | 0xfe);
	outw(iobase + XMT_BAR, sc->tx_lower_limit);
d411 1
a411 1
	outb(iobase + CMD_REG, Sel_Reset_CMD);
d413 1
a413 1
	outb(iobase + CMD_REG, Rcv_Enable_CMD);
a426 1
	register int iobase = sc->iobase;
d473 1
a473 1
			outb(iobase + MASK_REG, All_Int);
d494 5
a498 5
			outw(iobase + HOST_ADDR_REG, dest);
			outw(iobase + IO_PORT_REG, Transmit_CMD);
			outw(iobase + IO_PORT_REG, 0);
			outw(iobase + IO_PORT_REG, next);
			outw(iobase + IO_PORT_REG, data_len);
d510 1
a510 1
					outsw(iobase + IO_PORT_REG, tmp16, 1);
d512 1
a512 1
				outsw(iobase + IO_PORT_REG, mtod(m, caddr_t) 
d519 1
a519 1
				outsw(iobase + IO_PORT_REG, tmp16, 1);
d527 1
a527 1
					outw(iobase + HOST_ADDR_REG, 
d529 1
a529 1
					outw(iobase + IO_PORT_REG, dest);
d531 1
a531 1
				outw(iobase + HOST_ADDR_REG, sc->tx_last + 
d533 2
a534 2
				i = inw(iobase + IO_PORT_REG);
				outw(iobase + HOST_ADDR_REG, sc->tx_last + 
d536 1
a536 1
				outw(iobase + IO_PORT_REG, i | Ch_bit);
d545 1
a545 1
			inw(iobase + IO_PORT_REG);
d547 1
a547 1
			outb(iobase + MASK_REG, All_Int & ~(Rx_Int | Tx_Int));
d550 2
a551 2
				outw(iobase + XMT_BAR, dest);
				outb(iobase + CMD_REG, Transmit_CMD);
d555 1
a555 1
				outb(iobase + CMD_REG, Resume_XMT_List_CMD);
a582 2
	int iobase = sc->iobase;

d592 4
a595 4
	outb(iobase + CMD_REG, Bank1_Sel);
	outb(iobase + REG1, inb(iobase + REG1) & ~TriST_INT);
	outb(iobase + CMD_REG, Bank0_Sel);
	outb(iobase + CMD_REG, Rcv_Stop);
d600 3
a602 3
	outb(iobase + MASK_REG, All_Int);
	outb(iobase + STATUS_REG, All_Int);
	outb(iobase + CMD_REG, Reset_CMD);
a614 1
	int iobase = sc->iobase;
d627 1
a627 1
	while ((int_status = inb(iobase + STATUS_REG)) & (Tx_Int | Rx_Int)) {
d629 1
a629 1
			outb(iobase + STATUS_REG, Rx_Int);
d633 1
a633 1
			outb(iobase + STATUS_REG, Tx_Int);
a661 1
	register int iobase = sc->iobase;
d673 2
a674 2
		outw(iobase + HOST_ADDR_REG, sc->tx_head);
		if (! inw(iobase + IO_PORT_REG) & Done_bit)
d676 2
a677 2
		tx_status = inw(iobase + IO_PORT_REG);
		sc->tx_head = inw(iobase + IO_PORT_REG);
a697 1
	register int iobase = sc->iobase;
d710 5
a714 5
	outw(iobase + HOST_ADDR_REG, sc->rx_head);
	while (inw(iobase + IO_PORT_REG) == RCV_Done) {
		rx_status = inw(iobase + IO_PORT_REG);
		sc->rx_head = inw(iobase + IO_PORT_REG);
		QQQ = pkt_len = inw(iobase + IO_PORT_REG);
d742 1
a742 1
					insw(iobase + IO_PORT_REG,
d746 2
a747 2
						    m->m_len - 1) = inb(iobase +
						    IO_PORT_REG);
d798 1
a798 1
		outw(iobase + HOST_ADDR_REG, sc->rx_head);
d802 1
a802 1
		outw(iobase + RCV_STOP_REG, sc->rx_upper_limit);
d804 1
a804 1
		outw(iobase + RCV_STOP_REG, sc->rx_head - 2);
d969 2
a970 2
eeprom_read(iobase, location)
	int iobase;
a974 1
	int ee_addr;
d978 2
a979 3
	ee_addr = iobase + EEPROM_REG;
	outb(iobase + CMD_REG, Bank2_Sel);
	outb(ee_addr, EECS);
d983 2
a984 2
		outb(ee_addr, outval);
		outb(ee_addr, outval | EESK);
d986 1
a986 1
		outb(ee_addr, outval);
d989 1
a989 1
	outb(ee_addr, ctrl_val);
d991 1
a991 1
		outb(ee_addr, ctrl_val | EESK);
d993 2
a994 2
		data = (data << 1) | ((inb(ee_addr) & EEDO) ? 1 : 0);
		outb(ee_addr, ctrl_val);
d998 1
a998 1
	outb(ee_addr, ctrl_val | EESK);
d1000 1
a1000 1
	outb(ee_addr, ctrl_val);
d1002 1
a1002 1
	outb(iobase + CMD_REG, Bank0_Sel);
@
