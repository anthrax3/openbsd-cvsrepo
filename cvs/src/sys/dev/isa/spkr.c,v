head	1.21;
access;
symbols
	OPENBSD_6_0:1.21.0.2
	OPENBSD_6_0_BASE:1.21
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.19.0.6
	OPENBSD_5_8_BASE:1.19
	OPENBSD_5_7:1.19.0.4
	OPENBSD_5_7_BASE:1.19
	OPENBSD_5_6:1.16.0.4
	OPENBSD_5_6_BASE:1.16
	OPENBSD_5_5:1.14.0.8
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.14.0.4
	OPENBSD_5_4_BASE:1.14
	OPENBSD_5_3:1.14.0.2
	OPENBSD_5_3_BASE:1.14
	OPENBSD_5_2:1.13.0.6
	OPENBSD_5_2_BASE:1.13
	OPENBSD_5_1_BASE:1.13
	OPENBSD_5_1:1.13.0.4
	OPENBSD_5_0:1.13.0.2
	OPENBSD_5_0_BASE:1.13
	OPENBSD_4_9:1.12.0.6
	OPENBSD_4_9_BASE:1.12
	OPENBSD_4_8:1.12.0.4
	OPENBSD_4_8_BASE:1.12
	OPENBSD_4_7:1.12.0.2
	OPENBSD_4_7_BASE:1.12
	OPENBSD_4_6:1.10.0.16
	OPENBSD_4_6_BASE:1.10
	OPENBSD_4_5:1.10.0.12
	OPENBSD_4_5_BASE:1.10
	OPENBSD_4_4:1.10.0.10
	OPENBSD_4_4_BASE:1.10
	OPENBSD_4_3:1.10.0.8
	OPENBSD_4_3_BASE:1.10
	OPENBSD_4_2:1.10.0.6
	OPENBSD_4_2_BASE:1.10
	OPENBSD_4_1:1.10.0.4
	OPENBSD_4_1_BASE:1.10
	OPENBSD_4_0:1.10.0.2
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.16
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.14
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.7.0.12
	OPENBSD_3_6_BASE:1.7
	SMP_SYNC_A:1.7
	SMP_SYNC_B:1.7
	OPENBSD_3_5:1.7.0.10
	OPENBSD_3_5_BASE:1.7
	OPENBSD_3_4:1.7.0.8
	OPENBSD_3_4_BASE:1.7
	UBC_SYNC_A:1.7
	OPENBSD_3_3:1.7.0.6
	OPENBSD_3_3_BASE:1.7
	OPENBSD_3_2:1.7.0.4
	OPENBSD_3_2_BASE:1.7
	OPENBSD_3_1:1.7.0.2
	OPENBSD_3_1_BASE:1.7
	UBC_SYNC_B:1.7
	UBC:1.6.0.4
	UBC_BASE:1.6
	OPENBSD_3_0:1.6.0.2
	OPENBSD_3_0_BASE:1.6
	OPENBSD_2_9_BASE:1.5
	OPENBSD_2_9:1.5.0.2
	OPENBSD_2_8:1.4.0.2
	OPENBSD_2_8_BASE:1.4
	OPENBSD_2_7:1.2.0.8
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.6
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.4
	OPENBSD_2_6_BASE:1.2
	OPENBSD_2_5:1.2.0.2
	OPENBSD_2_5_BASE:1.2;
locks; strict;
comment	@ * @;


1.21
date	2016.03.19.11.34.22;	author mpi;	state Exp;
branches;
next	1.20;
commitid	15xZY6veDWwRM6Iq;

1.20
date	2015.11.25.04.49.10;	author tedu;	state Exp;
branches;
next	1.19;
commitid	uHekxfoYO9oEdolX;

1.19
date	2015.02.10.22.50.12;	author miod;	state Exp;
branches;
next	1.18;
commitid	92j86sjjanyIVT3d;

1.18
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.17;
commitid	C5iGb36LQxjM60Q3;

1.17
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.16;
commitid	uzzBR7hz9ncd4O6G;

1.16
date	2014.07.12.18.48.18;	author tedu;	state Exp;
branches;
next	1.15;
commitid	I19imNlAX05zJOED;

1.15
date	2014.07.10.14.21.20;	author deraadt;	state Exp;
branches;
next	1.14;
commitid	Jjzk0Y0KSLF2oro4;

1.14
date	2012.11.10.23.36.52;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2009.12.04.09.49.21;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2009.10.31.01.13.00;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.09.22.35.23;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2006.03.09.22.27.53;	author miod;	state Exp;
branches;
next	1.8;

1.8
date	2006.01.02.05.21.40;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.31.22.08.14;	author pvalchev;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2001.04.17.04.30.50;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.29.23.39.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.29.23.23.38;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	99.01.02.00.58.12;	author niklas;	state Exp;
branches
	1.2.6.1;
next	1.1;

1.1
date	99.01.02.00.02.43;	author niklas;	state Exp;
branches;
next	;

1.2.6.1
date	2001.05.14.22.24.52;	author niklas;	state Exp;
branches;
next	1.2.6.2;

1.2.6.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.2.6.3;

1.2.6.3
date	2002.03.28.12.11.36;	author niklas;	state Exp;
branches;
next	;

1.6.4.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.21
log
@Reduces the noise around the global ``ticks'' variable by renaming
all the local ones to ``nticks''.

ok stefan@@, deraadt@@
@
text
@/*	$OpenBSD: spkr.c,v 1.20 2015/11/25 04:49:10 tedu Exp $	*/
/*	$NetBSD: spkr.c,v 1.1 1998/04/15 20:26:18 drochner Exp $	*/

/*
 * Copyright (c) 1990 Eric S. Raymond (esr@@snark.thyrsus.com)
 * Copyright (c) 1990 Andrew A. Chernov (ache@@astral.msk.su)
 * Copyright (c) 1990 Lennart Augustsson (lennart@@augustsson.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Eric S. Raymond
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * spkr.c -- device driver for console speaker on 80386
 *
 * v1.1 by Eric S. Raymond (esr@@snark.thyrsus.com) Feb 1990
 *      modified for 386bsd by Andrew A. Chernov <ache@@astral.msk.su>
 *      386bsd only clean version, all SYSV stuff removed
 *      use hz value from param.c
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/errno.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/uio.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/file.h>

#include <dev/isa/pcppivar.h>

#include <dev/isa/spkrio.h>

cdev_decl(spkr);

int spkrprobe(struct device *, void *, void *);
void spkrattach(struct device *, struct device *, void *);

struct cfattach spkr_ca = {
	sizeof(struct device), spkrprobe, spkrattach
};

struct cfdriver spkr_cd = {
	NULL, "spkr", DV_DULL
};

static pcppi_tag_t ppicookie;

#define SPKRPRI (PZERO - 1)

static void tone(u_int, u_int);
static void rest(int);
static void playinit(void);
static void playtone(int, int, int);
static void playstring(char *, size_t);

/* emit tone of frequency hz for given number of ticks */
static void
tone(hz, nticks)
	u_int hz, nticks;
{
	pcppi_bell(ppicookie, hz, nticks, PCPPI_BELL_SLEEP);
}

/* rest for given number of ticks */
static void
rest(nticks)
	int nticks;
{
	/*
	 * Set timeout to endrest function, then give up the timeslice.
	 * This is so other processes can execute while the rest is being
	 * waited out.
	 */
#ifdef SPKRDEBUG
	printf("rest: %d\n", nticks);
#endif /* SPKRDEBUG */
	if (nticks > 0)
		tsleep(rest, SPKRPRI | PCATCH, "rest", nticks);
}

/**************** PLAY STRING INTERPRETER BEGINS HERE **********************
 *
 * Play string interpretation is modelled on IBM BASIC 2.0's PLAY statement;
 * M[LNS] are missing and the ~ synonym and octave-tracking facility is added.
 * Requires tone(), rest(), and endtone(). String play is not interruptible
 * except possibly at physical block boundaries.
 */

#define toupper(c)	((c) - ' ' * (((c) >= 'a') && ((c) <= 'z')))
#define isdigit(c)	(((c) >= '0') && ((c) <= '9'))
#define dtoi(c)		((c) - '0')

static int octave;	/* currently selected octave */
static int whole;	/* whole-note time at current tempo, in ticks */
static int value;	/* whole divisor for note time, quarter note = 1 */
static int fill;	/* controls spacing of notes */
static int octtrack;	/* octave-tracking on? */
static int octprefix;	/* override current octave-tracking state? */

/*
 * Magic number avoidance...
 */
#define SECS_PER_MIN	60	/* seconds per minute */
#define WHOLE_NOTE	4	/* quarter notes per whole note */
#define MIN_VALUE	64	/* the most we can divide a note by */
#define DFLT_VALUE	4	/* default value (quarter-note) */
#define FILLTIME	8	/* for articulation, break note in parts */
#define STACCATO	6	/* 6/8 = 3/4 of note is filled */
#define NORMAL		7	/* 7/8ths of note interval is filled */
#define LEGATO		8	/* all of note interval is filled */
#define DFLT_OCTAVE	4	/* default octave */
#define MIN_TEMPO	32	/* minimum tempo */
#define DFLT_TEMPO	120	/* default tempo */
#define MAX_TEMPO	255	/* max tempo */
#define NUM_MULT	3	/* numerator of dot multiplier */
#define DENOM_MULT	2	/* denominator of dot multiplier */

/* letter to half-tone:  A   B  C  D  E  F  G */
static int notetab[8] = { 9, 11, 0, 2, 4, 5, 7 };

/*
 * This is the American Standard A440 Equal-Tempered scale with frequencies
 * rounded to nearest integer. Thank Goddess for the good ol' CRC Handbook...
 * our octave 0 is standard octave 2.
 */
#define OCTAVE_NOTES	12	/* semitones per octave */
static int pitchtab[] =
{
/*        C     C#    D     D#    E     F     F#    G     G#    A     A#    B*/
/* 0 */   65,   69,   73,   78,   82,   87,   93,   98,  103,  110,  117,  123,
/* 1 */  131,  139,  147,  156,  165,  175,  185,  196,  208,  220,  233,  247,
/* 2 */  262,  277,  294,  311,  330,  349,  370,  392,  415,  440,  466,  494,
/* 3 */  523,  554,  587,  622,  659,  698,  740,  784,  831,  880,  932,  988,
/* 4 */ 1047, 1109, 1175, 1245, 1319, 1397, 1480, 1568, 1661, 1760, 1865, 1975,
/* 5 */ 2093, 2217, 2349, 2489, 2637, 2794, 2960, 3136, 3322, 3520, 3729, 3951,
/* 6 */ 4186, 4435, 4698, 4978, 5274, 5588, 5920, 6272, 6644, 7040, 7459, 7902,
};
#define NOCTAVES (sizeof(pitchtab) / sizeof(pitchtab[0]) / OCTAVE_NOTES)

static void
playinit(void)
{
	octave = DFLT_OCTAVE;
	whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;
	fill = NORMAL;
	value = DFLT_VALUE;
	octtrack = 0;
	octprefix = 1;	/* act as though there was an initial O(n) */
}

/* play tone of proper duration for current rhythm signature */
static void
playtone(int pitch, int value, int sustain)
{
	int sound, silence, snum = 1, sdenom = 1;

	/* this weirdness avoids floating-point arithmetic */
	for (; sustain; sustain--) {
		snum *= NUM_MULT;
		sdenom *= DENOM_MULT;
	}

	if (pitch == -1)
		rest(whole * snum / (value * sdenom));
	else if (pitch >= 0 &&
	    pitch < (sizeof(pitchtab) / sizeof(pitchtab[0]))) {
		sound = (whole * snum) / (value * sdenom) -
		    (whole * (FILLTIME - fill)) / (value * FILLTIME);
		silence = whole * (FILLTIME-fill) * snum /
		    (FILLTIME * value * sdenom);

#ifdef SPKRDEBUG
		printf("playtone: pitch %d for %d ticks, rest for %d ticks\n",
		    pitch, sound, silence);
#endif /* SPKRDEBUG */

		tone(pitchtab[pitch], sound);
		if (fill != LEGATO)
			rest(silence);
	}
}

/* interpret and play an item from a notation string */
static void
playstring(char *cp, size_t slen)
{
	int pitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;

#define GETNUM(cp, v) \
do { \
	for (v = 0; slen > 0 && isdigit(cp[1]); ) { \
		v = v * 10 + (*++cp - '0'); \
		slen--; \
	} \
} while (0)

	for (; slen--; cp++) {
		int sustain, timeval, tempo;
		char c = toupper(*cp);

#ifdef SPKRDEBUG
		printf("playstring: %c (%x)\n", c, c);
#endif /* SPKRDEBUG */

		switch (c) {
		case 'A':
		case 'B':
		case 'C':
		case 'D':
		case 'E':
		case 'F':
		case 'G':
			/* compute pitch */
			pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;

			/* this may be followed by an accidental sign */
			if (slen > 0 && (cp[1] == '#' || cp[1] == '+')) {
				++pitch;
				++cp;
				slen--;
			} else if (slen > 0 && cp[1] == '-') {
				--pitch;
				++cp;
				slen--;
			}

			/*
			 * If octave-tracking mode is on, and there has been
			 * no octave-setting prefix, find the version of the
			 * current letter note closest to the last regardless
			 * of octave.
			 */
			if (octtrack && !octprefix) {
				if (abs(pitch - lastpitch) >
				    abs(pitch + OCTAVE_NOTES - lastpitch)) {
					++octave;
					pitch += OCTAVE_NOTES;
				}

				if (abs(pitch - lastpitch) >
				    abs(pitch - OCTAVE_NOTES - lastpitch)) {
					--octave;
					pitch -= OCTAVE_NOTES;
				}
			}
			octprefix = 0;
			lastpitch = pitch;

			/*
			 * ...which may in turn be followed by an override
			 * time value
			 */
			GETNUM(cp, timeval);
			if (timeval <= 0 || timeval > MIN_VALUE)
				timeval = value;

			/* ...and/or sustain dots */
			for (sustain = 0; slen > 0 && cp[1] == '.'; cp++) {
				slen--;
				sustain++;
			}

			/* time to emit the actual tone */
			playtone(pitch, timeval, sustain);
			break;

		case 'O':
			if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n')) {
				octprefix = octtrack = 0;
				++cp;
				slen--;
			} else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l')) {
				octtrack = 1;
				++cp;
				slen--;
			} else {
				GETNUM(cp, octave);
				if (octave >= NOCTAVES)
					octave = DFLT_OCTAVE;
				octprefix = 1;
			}
			break;

		case '>':
			if (octave < NOCTAVES - 1)
				octave++;
			octprefix = 1;
			break;

		case '<':
			if (octave > 0)
				octave--;
			octprefix = 1;
			break;

		case 'N':
			GETNUM(cp, pitch);
			for (sustain = 0; slen > 0 && cp[1] == '.'; cp++) {
				slen--;
				sustain++;
			}
			playtone(pitch - 1, value, sustain);
			break;

		case 'L':
			GETNUM(cp, value);
			if (value <= 0 || value > MIN_VALUE)
				value = DFLT_VALUE;
			break;

		case 'P':
		case '~':
			/* this may be followed by an override time value */
			GETNUM(cp, timeval);
			if (timeval <= 0 || timeval > MIN_VALUE)
				timeval = value;
			for (sustain = 0; slen > 0 && cp[1] == '.'; cp++) {
				slen--;
				sustain++;
			}
			playtone(-1, timeval, sustain);
			break;

		case 'T':
			GETNUM(cp, tempo);
			if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)
				tempo = DFLT_TEMPO;
			whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;
			break;

		case 'M':
			if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n')) {
				fill = NORMAL;
				++cp;
				slen--;
			} else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l')) {
				fill = LEGATO;
				++cp;
				slen--;
			} else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's')) {
				fill = STACCATO;
				++cp;
				slen--;
			}
			break;
		}
	}
}

/******************* UNIX DRIVER HOOKS BEGIN HERE **************************
 *
 * This section implements driver hooks to run playstring() and the tone(),
 * endtone(), and rest() functions defined above.
 */

static int spkr_active;	/* exclusion flag */
static void *spkr_inbuf;

static int spkr_attached = 0;

int
spkrprobe(struct device *parent, void *match, void *aux)
{
	return (!spkr_attached);
}

void
spkrattach(struct device *parent, struct device *self, void *aux)
{
	printf("\n");
	ppicookie = ((struct pcppi_attach_args *)aux)->pa_cookie;
	spkr_attached = 1;
}

int
spkropen(dev_t dev, int flags, int mode, struct proc *p)
{
#ifdef SPKRDEBUG
	printf("spkropen: entering with dev = %x\n", dev);
#endif /* SPKRDEBUG */

	if (minor(dev) != 0 || !spkr_attached)
		return (ENXIO);
	else if (spkr_active)
		return (EBUSY);
	else {
		playinit();
		spkr_inbuf = malloc(DEV_BSIZE, M_DEVBUF, M_WAITOK);
		spkr_active = 1;
	}
	return (0);
}

int
spkrwrite(dev_t dev, struct uio *uio, int flags)
{
	size_t n;
	int error;
#ifdef SPKRDEBUG
	printf("spkrwrite: entering with dev = %x, count = %d\n",
	    dev, uio->uio_resid);
#endif /* SPKRDEBUG */

	if (minor(dev) != 0)
		return (ENXIO);
	else {
		n = ulmin(DEV_BSIZE, uio->uio_resid);
		error = uiomove(spkr_inbuf, n, uio);
		if (!error)
			playstring((char *)spkr_inbuf, n);
		return (error);
	}
}

int
spkrclose(dev_t dev, int flags, int mode, struct proc *p)
{
#ifdef SPKRDEBUG
	printf("spkrclose: entering with dev = %x\n", dev);
#endif /* SPKRDEBUG */

	if (minor(dev) != 0)
		return (ENXIO);
	else {
		tone(0, 0);
		free(spkr_inbuf, M_DEVBUF, DEV_BSIZE);
		spkr_active = 0;
	}
	return (0);
}

int
spkrioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	tone_t *tp, ttp;
	int error;

#ifdef SPKRDEBUG
	printf("spkrioctl: entering with dev = %x, cmd = %lx\n", dev, cmd);
#endif /* SPKRDEBUG */

	if (minor(dev) != 0)
		return (ENXIO);

	switch (cmd) {
	case SPKRTONE:
	case SPKRTUNE:
		if ((flag & FWRITE) == 0)
			return (EACCES);
	default:
		break;
	}

	switch (cmd) {
	case SPKRTONE:
		tp = (tone_t *)data;

		if (tp->frequency == 0)
			rest(tp->duration);
		else
			tone(tp->frequency, tp->duration);
		break;
	case SPKRTUNE:
		tp = (tone_t *)(*(caddr_t *)data);

		for (; ; tp++) {
			error = copyin(tp, &ttp, sizeof(tone_t));
			if (error)
				return (error);
			if (ttp.duration == 0)
				break;
			if (ttp.frequency == 0)
				rest(ttp.duration);
			else
				tone(ttp.frequency, ttp.duration);
		}
		break;
	default:
		return (ENOTTY);
	}

	return (0);
}
@


1.20
log
@add size to free
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.19 2015/02/10 22:50:12 miod Exp $	*/
d86 2
a87 2
tone(hz, ticks)
	u_int hz, ticks;
d89 1
a89 1
	pcppi_bell(ppicookie, hz, ticks, PCPPI_BELL_SLEEP);
d94 2
a95 2
rest(ticks)
	int ticks;
d103 1
a103 1
	printf("rest: %d\n", ticks);
d105 2
a106 2
	if (ticks > 0)
		tsleep(rest, SPKRPRI | PCATCH, "rest", ticks);
@


1.19
log
@Trivial conversion to uiomove()
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.17 2014/09/14 14:17:25 jsg Exp $	*/
d454 1
a454 1
		free(spkr_inbuf, M_DEVBUF, 0);
@


1.18
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d82 1
a82 1
static void playstring(char *, int);
d213 1
a213 1
playstring(char *cp, int slen)
d425 1
a425 1
	int n;
d435 2
a436 2
		n = min(DEV_BSIZE, uio->uio_resid);
		error = uiomovei(spkr_inbuf, n, uio);
@


1.17
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.16 2014/07/12 18:48:18 tedu Exp $	*/
d436 1
a436 1
		error = uiomove(spkr_inbuf, n, uio);
@


1.16
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.15 2014/07/10 14:21:20 deraadt Exp $	*/
a52 1
#include <sys/proc.h>
@


1.15
log
@remove most of the boolean_t infection outside uvm/ddb/pmap; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.14 2012/11/10 23:36:52 jsg Exp $	*/
d455 1
a455 1
		free(spkr_inbuf, M_DEVBUF);
@


1.14
log
@use boolean_t not bool for a local boolean type so this won't
clash with a c99 style bool type.

ok millert@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.13 2011/06/23 16:31:16 deraadt Exp $	*/
a117 4
typedef int	boolean_t;
#define TRUE	1
#define FALSE	0

d126 2
a127 2
static boolean_t octtrack;	/* octave-tracking on? */
static boolean_t octprefix;	/* override current octave-tracking state? */
d176 2
a177 2
	octtrack = FALSE;
	octprefix = TRUE;	/* act as though there was an initial O(n) */
d275 1
a275 1
			octprefix = FALSE;
d298 1
a298 1
				octprefix = octtrack = FALSE;
d302 1
a302 1
				octtrack = TRUE;
d309 1
a309 1
				octprefix = TRUE;
d316 1
a316 1
			octprefix = TRUE;
d322 1
a322 1
			octprefix = TRUE;
@


1.13
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.12 2009/12/04 09:49:21 jasper Exp $	*/
d118 1
a118 1
typedef int	bool;
d130 2
a131 2
static bool octtrack;	/* octave-tracking on? */
static bool octprefix;	/* override current octave-tracking state? */
@


1.12
log
@ansify.
ok md5@@
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.11 2009/10/31 01:13:00 fgsch Exp $	*/
d174 1
a174 1
playinit()
@


1.11
log
@Make sure the descriptor is writable for some operations.
Pointed out and ok by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.10 2006/03/09 22:35:23 miod Exp $	*/
d186 1
a186 2
playtone(pitch, value, sustain)
	int pitch, value, sustain;
d218 1
a218 3
playstring(cp, slen)
	char *cp;
	int slen;
d395 1
a395 4
spkrprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d401 1
a401 4
spkrattach(parent, self, aux)
	struct device *parent;
	struct device *self;
	void *aux;
d409 1
a409 5
spkropen(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d428 1
a428 4
spkrwrite(dev, uio, flags)
	dev_t dev;
	struct uio *uio;
	int flags;
d449 1
a449 5
spkrclose(dev, flags, mode, p)
	dev_t dev;
	int flags;
	int mode;
	struct proc *p;
d466 1
a466 6
spkrioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
@


1.10
log
@Unimplemented ioctl commands should return ENOTTY, not EINVAL.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.8 2006/01/02 05:21:40 brad Exp $	*/
d56 1
d502 9
@


1.9
log
@KNF, deregister, no functional change.
@
text
@a65 4
struct spkr_softc {
	struct device sc_dev;
};

d67 1
a67 1
	sizeof(struct spkr_softc), spkrprobe, spkrattach
d492 3
d501 4
a504 2
	else if (cmd == SPKRTONE) {
		tone_t *tp = (tone_t *)data;
d510 3
a512 4
	} else if (cmd == SPKRTUNE) {
		tone_t *tp = (tone_t *)(*(caddr_t *)data);
		tone_t ttp;
		int error;
d525 4
a528 2
	} else
		return (EINVAL);
@


1.8
log
@remove last traces of __BROKEN_INDIRECT_CONFIG.

Thanks to aanriot@@ and Michael Knudsen for checking that alpha/i386/macppc
kernels still compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.7 2002/03/14 01:26:56 millert Exp $	*/
a87 2
static
void tone(hz, ticks)
d89 3
a91 1
    u_int hz, ticks;
d96 1
d99 1
a99 2
/* rest for given number of ticks */
    int	ticks;
d101 5
a105 5
    /*
     * Set timeout to endrest function, then give up the timeslice.
     * This is so other processes can execute while the rest is being
     * waited out.
     */
d107 1
a107 1
    printf("rest: %d\n", ticks);
d109 2
a110 2
    if (ticks > 0)
	    tsleep(rest, SPKRPRI | PCATCH, "rest", ticks);
d155 1
a155 1
static int notetab[8] = {9, 11, 0, 2, 4, 5, 7};
d179 6
a184 6
    octave = DFLT_OCTAVE;
    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / DFLT_TEMPO;
    fill = NORMAL;
    value = DFLT_VALUE;
    octtrack = FALSE;
    octprefix = TRUE;	/* act as though there was an initial O(n) */
d187 1
d190 1
a190 2
/* play tone of proper duration for current rhythm signature */
    int	pitch, value, sustain;
d192 7
a198 1
    register int	sound, silence, snum = 1, sdenom = 1;
d200 8
a207 14
    /* this weirdness avoids floating-point arithmetic */
    for (; sustain; sustain--)
    {
	snum *= NUM_MULT;
	sdenom *= DENOM_MULT;
    }

    if (pitch == -1)
	rest(whole * snum / (value * sdenom));
    else if (pitch >= 0 && pitch < (sizeof(pitchtab) / sizeof(pitchtab[0])))
    {
	sound = (whole * snum) / (value * sdenom)
		- (whole * (FILLTIME - fill)) / (value * FILLTIME);
	silence = whole * (FILLTIME-fill) * snum / (FILLTIME * value * sdenom);
d210 2
a211 2
	printf("playtone: pitch %d for %d ticks, rest for %d ticks\n",
	    pitch, sound, silence);
d214 4
a217 4
	tone(pitchtab[pitch], sound);
	if (fill != LEGATO)
	    rest(silence);
    }
d220 1
d223 2
a224 3
/* interpret and play an item from a notation string */
    char	*cp;
    int		slen;
d226 1
a226 1
    int		pitch, lastpitch = OCTAVE_NOTES * DFLT_OCTAVE;
d228 11
a238 6
#define GETNUM(cp, v)	for(v=0; slen > 0 && isdigit(cp[1]); ) \
				{v = v * 10 + (*++cp - '0'); slen--;}
    for (; slen--; cp++)
    {
	int		sustain, timeval, tempo;
	register char	c = toupper(*cp);
d241 1
a241 1
	printf("playstring: %c (%x)\n", c, c);
d244 141
a384 32
	switch (c)
	{
	case 'A':  case 'B': case 'C': case 'D': case 'E': case 'F': case 'G':

	    /* compute pitch */
	    pitch = notetab[c - 'A'] + octave * OCTAVE_NOTES;

	    /* this may be followed by an accidental sign */
	    if (slen > 0 && (cp[1] == '#' || cp[1] == '+'))
	    {
		++pitch;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && cp[1] == '-')
	    {
		--pitch;
		++cp;
		slen--;
	    }

	    /*
	     * If octave-tracking mode is on, and there has been no octave-
	     * setting prefix, find the version of the current letter note
	     * closest to the last regardless of octave.
	     */
	    if (octtrack && !octprefix)
	    {
		if (abs(pitch-lastpitch) > abs(pitch+OCTAVE_NOTES-lastpitch))
		{
		    ++octave;
		    pitch += OCTAVE_NOTES;
a385 117

		if (abs(pitch-lastpitch) > abs((pitch-OCTAVE_NOTES)-lastpitch))
		{
		    --octave;
		    pitch -= OCTAVE_NOTES;
		}
	    }
	    octprefix = FALSE;
	    lastpitch = pitch;

	    /* ...which may in turn be followed by an override time value */
	    GETNUM(cp, timeval);
	    if (timeval <= 0 || timeval > MIN_VALUE)
		timeval = value;

	    /* ...and/or sustain dots */
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }

	    /* time to emit the actual tone */
	    playtone(pitch, timeval, sustain);
	    break;

	case 'O':
	    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))
	    {
		octprefix = octtrack = FALSE;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))
	    {
		octtrack = TRUE;
		++cp;
		slen--;
	    }
	    else
	    {
		GETNUM(cp, octave);
		if (octave >= NOCTAVES)
		    octave = DFLT_OCTAVE;
		octprefix = TRUE;
	    }
	    break;

	case '>':
	    if (octave < NOCTAVES - 1)
		octave++;
	    octprefix = TRUE;
	    break;

	case '<':
	    if (octave > 0)
		octave--;
	    octprefix = TRUE;
	    break;

	case 'N':
	    GETNUM(cp, pitch);
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }
	    playtone(pitch - 1, value, sustain);
	    break;

	case 'L':
	    GETNUM(cp, value);
	    if (value <= 0 || value > MIN_VALUE)
		value = DFLT_VALUE;
	    break;

	case 'P':
	case '~':
	    /* this may be followed by an override time value */
	    GETNUM(cp, timeval);
	    if (timeval <= 0 || timeval > MIN_VALUE)
		timeval = value;
	    for (sustain = 0; slen > 0 && cp[1] == '.'; cp++)
	    {
		slen--;
		sustain++;
	    }
	    playtone(-1, timeval, sustain);
	    break;

	case 'T':
	    GETNUM(cp, tempo);
	    if (tempo < MIN_TEMPO || tempo > MAX_TEMPO)
		tempo = DFLT_TEMPO;
	    whole = (hz * SECS_PER_MIN * WHOLE_NOTE) / tempo;
	    break;

	case 'M':
	    if (slen > 0 && (cp[1] == 'N' || cp[1] == 'n'))
	    {
		fill = NORMAL;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'L' || cp[1] == 'l'))
	    {
		fill = LEGATO;
		++cp;
		slen--;
	    }
	    else if (slen > 0 && (cp[1] == 'S' || cp[1] == 's'))
	    {
		fill = STACCATO;
		++cp;
		slen--;
	    }
	    break;
a386 1
    }
d401 1
a401 1
spkrprobe (parent, match, aux)
d422 4
a425 4
    dev_t dev;
    int	flags;
    int mode;
    struct proc *p;
d428 1
a428 1
    printf("spkropen: entering with dev = %x\n", dev);
d431 10
a440 11
    if (minor(dev) != 0 || !spkr_attached)
	return(ENXIO);
    else if (spkr_active)
	return(EBUSY);
    else
    {
	playinit();
	spkr_inbuf = malloc(DEV_BSIZE, M_DEVBUF, M_WAITOK);
	spkr_active = 1;
    }
    return(0);
d445 3
a447 3
    dev_t dev;
    struct uio *uio;
    int flags;
d449 2
a450 2
    register int n;
    int error;
d452 2
a453 2
    printf("spkrwrite: entering with dev = %x, count = %d\n",
		dev, uio->uio_resid);
d456 17
a472 17
    if (minor(dev) != 0)
	return(ENXIO);
    else
    {
	n = min(DEV_BSIZE, uio->uio_resid);
	error = uiomove(spkr_inbuf, n, uio);
	if (!error)
		playstring((char *)spkr_inbuf, n);
	return(error);
    }
}

int spkrclose(dev, flags, mode, p)
    dev_t	dev;
    int flags;
    int mode;
    struct proc *p;
d475 1
a475 1
    printf("spkrclose: entering with dev = %x\n", dev);
d478 17
a494 17
    if (minor(dev) != 0)
	return(ENXIO);
    else
    {
	tone(0, 0);
	free(spkr_inbuf, M_DEVBUF);
	spkr_active = 0;
    }
    return(0);
}

int spkrioctl(dev, cmd, data, flag, p)
    dev_t dev;
    u_long cmd;
    caddr_t data;
    int	flag;
    struct proc *p;
d497 1
a497 1
    printf("spkrioctl: entering with dev = %x, cmd = %lx\n", dev, cmd);
d500 27
a526 16
    if (minor(dev) != 0)
	return(ENXIO);
    else if (cmd == SPKRTONE)
    {
	tone_t	*tp = (tone_t *)data;

	if (tp->frequency == 0)
	    rest(tp->duration);
	else
	    tone(tp->frequency, tp->duration);
    }
    else if (cmd == SPKRTUNE)
    {
	tone_t  *tp = (tone_t *)(*(caddr_t *)data);
	tone_t ttp;
	int error;
d528 1
a528 15
	for (; ; tp++) {
	    error = copyin(tp, &ttp, sizeof(tone_t));
	    if (error)
		    return(error);
	    if (ttp.duration == 0)
		    break;
	    if (ttp.frequency == 0)
		rest(ttp.duration);
	    else
		tone(ttp.frequency, ttp.duration);
	}
    }
    else
	return(EINVAL);
    return(0);
a529 2

/* spkr.c ends here */
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.6 2001/07/31 22:08:14 pvalchev Exp $	*/
a62 2
#define __BROKEN_INDIRECT_CONFIG /* XXX */
#ifdef __BROKEN_INDIRECT_CONFIG
a63 3
#else
int spkrprobe(struct device *, struct cfdata *, void *);
#endif
a406 1
#ifdef __BROKEN_INDIRECT_CONFIG
a407 3
#else
	struct cfdata *match;
#endif
@


1.6
log
@License clarification from Eric S. Raymond.
In an email sent to us, he authorized us to change it.  It is now
BSD-licensed.
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.5 2001/04/17 04:30:50 aaron Exp $	*/
d65 1
a65 1
int spkrprobe __P((struct device *, void *, void *));
d67 1
a67 1
int spkrprobe __P((struct device *, struct cfdata *, void *));
d69 1
a69 1
void spkrattach __P((struct device *, struct device *, void *));
d87 5
a91 5
static void tone __P((u_int, u_int));
static void rest __P((int));
static void playinit __P((void));
static void playtone __P((int, int, int));
static void playstring __P((char *, int));
@


1.6.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.6 2001/07/31 22:08:14 pvalchev Exp $	*/
d65 1
a65 1
int spkrprobe(struct device *, void *, void *);
d67 1
a67 1
int spkrprobe(struct device *, struct cfdata *, void *);
d69 1
a69 1
void spkrattach(struct device *, struct device *, void *);
d87 5
a91 5
static void tone(u_int, u_int);
static void rest(int);
static void playinit(void);
static void playtone(int, int, int);
static void playstring(char *, int);
@


1.5
log
@Implement cnbell(), an optional entrypoint that rings the console bell; from
NetBSD. deraadt@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.4 2000/09/29 23:39:08 miod Exp $	*/
d3 33
@


1.4
log
@Oops, time to learn how to count
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.3 2000/09/29 23:23:38 miod Exp $	*/
d65 1
a65 1
	pcppi_bell(ppicookie, hz, ticks, 1);
@


1.3
log
@Check N command operand value to prevent a panic with large values.
Problem found by Thomas Coffy <karma@@bsdfr.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.2 1999/01/02 00:58:12 niklas Exp $	*/
d175 1
a175 1
    else if (pitch >= 0 && pitch < sizeof(pitchtab))
@


1.2
log
@OpenBSDify
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.1 1999/01/02 00:02:43 niklas Exp $	*/
d175 1
a175 1
    else
@


1.2.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.5 2001/04/17 04:30:50 aaron Exp $	*/
d65 1
a65 1
	pcppi_bell(ppicookie, hz, ticks, PCPPI_BELL_SLEEP);
d175 1
a175 1
    else if (pitch >= 0 && pitch < (sizeof(pitchtab) / sizeof(pitchtab[0])))
@


1.2.6.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.2.6.1 2001/05/14 22:24:52 niklas Exp $	*/
a2 33

/*
 * Copyright (c) 1990 Eric S. Raymond (esr@@snark.thyrsus.com)
 * Copyright (c) 1990 Andrew A. Chernov (ache@@astral.msk.su)
 * Copyright (c) 1990 Lennart Augustsson (lennart@@augustsson.net)
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Eric S. Raymond
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
@


1.2.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d65 1
a65 1
int spkrprobe(struct device *, void *, void *);
d67 1
a67 1
int spkrprobe(struct device *, struct cfdata *, void *);
d69 1
a69 1
void spkrattach(struct device *, struct device *, void *);
d87 5
a91 5
static void tone(u_int, u_int);
static void rest(int);
static void playinit(void);
static void playtone(int, int, int);
static void playstring(char *, int);
@


1.1
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: spkr.c,v 1.1 1998/04/15 20:26:18 drochner Exp $	*/
d30 4
d35 1
d46 4
d379 3
d383 1
@

