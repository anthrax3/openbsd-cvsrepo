head	1.24;
access;
symbols
	OPENBSD_6_1_BASE:1.24
	OPENBSD_6_0:1.22.0.6
	OPENBSD_6_0_BASE:1.22
	OPENBSD_5_9:1.22.0.2
	OPENBSD_5_9_BASE:1.22
	OPENBSD_5_8:1.22.0.4
	OPENBSD_5_8_BASE:1.22
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.2
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.16.0.12
	OPENBSD_5_3_BASE:1.16
	OPENBSD_5_2:1.16.0.10
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.16
	OPENBSD_5_1:1.16.0.8
	OPENBSD_5_0:1.16.0.6
	OPENBSD_5_0_BASE:1.16
	OPENBSD_4_9:1.16.0.4
	OPENBSD_4_9_BASE:1.16
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.14.0.4
	OPENBSD_4_7_BASE:1.14
	OPENBSD_4_6:1.14.0.6
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.2
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.8
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.6
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.11.0.4
	OPENBSD_4_0_BASE:1.11
	OPENBSD_3_9:1.11.0.2
	OPENBSD_3_9_BASE:1.11
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.9.0.8
	OPENBSD_3_7_BASE:1.9
	OPENBSD_3_6:1.9.0.6
	OPENBSD_3_6_BASE:1.9
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.9
	OPENBSD_3_3:1.8.0.6
	OPENBSD_3_3_BASE:1.8
	OPENBSD_3_2:1.8.0.4
	OPENBSD_3_2_BASE:1.8
	OPENBSD_3_1:1.8.0.2
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.8
	UBC:1.5.0.2
	UBC_BASE:1.5
	OPENBSD_3_0:1.4.0.2
	OPENBSD_3_0_BASE:1.4
	OPENBSD_2_9_BASE:1.3
	OPENBSD_2_9:1.3.0.2
	OPENBSD_2_8:1.2.0.8
	OPENBSD_2_8_BASE:1.2
	OPENBSD_2_7:1.2.0.6
	OPENBSD_2_7_BASE:1.2
	SMP:1.2.0.4
	SMP_BASE:1.2
	kame_19991208:1.2
	OPENBSD_2_6:1.2.0.2
	OPENBSD_2_6_BASE:1.2;
locks; strict;
comment	@ * @;


1.24
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.23;
commitid	qGgYgJTgEFuAoGj4;

1.23
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.22;
commitid	pi1a9KN0itEngOc4;

1.22
date	2015.06.25.06.43.46;	author ratchov;	state Exp;
branches;
next	1.21;
commitid	EA6IpjJSgQH2WTCf;

1.21
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.20;
commitid	RaOGL5SyOGOZylwx;

1.20
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.19;
commitid	uzzBR7hz9ncd4O6G;

1.19
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.17;

1.17
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.16;

1.16
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.15;

1.15
date	2010.06.30.20.39.02;	author blambert;	state Exp;
branches;
next	1.14;

1.14
date	2008.10.25.22.30.43;	author jakemsr;	state Exp;
branches;
next	1.13;

1.13
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.11;

1.11
date	2006.02.22.19.43.42;	author miod;	state Exp;
branches;
next	1.10;

1.10
date	2005.04.15.13.05.14;	author mickey;	state Exp;
branches;
next	1.9;

1.9
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.8;

1.8
date	2002.03.14.03.16.05;	author millert;	state Exp;
branches;
next	1.7;

1.7
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.6;

1.6
date	2002.01.20.19.56.53;	author ericj;	state Exp;
branches;
next	1.5;

1.5
date	2001.10.31.11.00.24;	author art;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.07.18.21.37.52;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2001.01.29.06.27.59;	author mickey;	state Exp;
branches;
next	1.2;

1.2
date	99.09.30.22.13.52;	author kstailey;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.06.22.16.20.03;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.24.31;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2002.03.06.02.11.44;	author niklas;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.2.4.6;

1.2.4.6
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	;

1.5.2.1
date	2002.01.31.22.55.32;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.24
log
@Remove unused getdev() audio driver functions.
@
text
@/*	$OpenBSD: ess.c,v 1.23 2016/09/14 06:12:19 ratchov Exp $	*/
/*	$NetBSD: ess.c,v 1.44.4.1 1999/06/21 01:18:00 thorpej Exp $	*/

/*
 * Copyright 1997
 * Digital Equipment Corporation. All rights reserved.
 *
 * This software is furnished under license and may be used and
 * copied only in accordance with the following terms and conditions.
 * Subject to these conditions, you may download, copy, install,
 * use, modify and distribute this software in source and/or binary
 * form. No title or ownership is transferred hereby.
 *
 * 1) Any source code used, modified or distributed must reproduce
 *    and retain this copyright notice and list of conditions as
 *    they appear in the source file.
 *
 * 2) No right is granted to use any trade name, trademark, or logo of
 *    Digital Equipment Corporation. Neither the "Digital Equipment
 *    Corporation" name nor any trademark or logo of Digital Equipment
 *    Corporation may be used to endorse or promote products derived
 *    from this software without the prior written permission of
 *    Digital Equipment Corporation.
 *
 * 3) This software is provided "AS-IS" and any express or implied
 *    warranties, including but not limited to, any implied warranties
 *    of merchantability, fitness for a particular purpose, or
 *    non-infringement are disclaimed. In no event shall DIGITAL be
 *    liable for any damages whatsoever, and in particular, DIGITAL
 *    shall not be liable for special, indirect, consequential, or
 *    incidental damages or damages for lost profits, loss of
 *    revenue or loss of use, whether such damages arise in contract,
 *    negligence, tort, under statute, in equity, at law or otherwise,
 *    even if advised of the possibility of such damage.
 */

/*
**++
**
**  ess.c
**
**  FACILITY:
**
**	DIGITAL Network Appliance Reference Design (DNARD)
**
**  MODULE DESCRIPTION:
**
**	This module contains the device driver for the ESS
**	Technologies 1888/1887/888 sound chip. The code in sbdsp.c was
**	used as a reference point when implementing this driver.
**
**  AUTHORS:
**
**	Blair Fidler	Software Engineering Australia
**			Gold Coast, Australia.
**
**  CREATION DATE:
**
**	March 10, 1997.
**
**  MODIFICATION HISTORY:
**
**	Heavily modified by Lennart Augustsson and Charles M. Hannum for
**	bus_dma, changes to audio interface, and many bug fixes.
**	ESS1788 support by Nathan J. Williams and Charles M. Hannum.
**--
*/

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/isa/essvar.h>
#include <dev/isa/essreg.h>

#ifdef AUDIO_DEBUG
#define DPRINTF(x)	if (essdebug) printf x
#define DPRINTFN(n,x)	if (essdebug>(n)) printf x
int	essdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#if 0
unsigned uuu;
#define EREAD1(t, h, a) (uuu=bus_space_read_1(t, h, a),printf("EREAD  %02x=%02x\n", ((int)h&0xfff)+a, uuu),uuu)
#define EWRITE1(t, h, a, d) (printf("EWRITE %02x=%02x\n", ((int)h & 0xfff)+a, d), bus_space_write_1(t, h, a, d))
#else
#define EREAD1(t, h, a) bus_space_read_1(t, h, a)
#define EWRITE1(t, h, a, d) bus_space_write_1(t, h, a, d)
#endif

struct cfdriver ess_cd = {
	NULL, "ess", DV_DULL
};

struct audio_params ess_audio_default =
	{44100, AUDIO_ENCODING_SLINEAR_LE, 16, 2, 1, 2};

int	ess_setup_sc(struct ess_softc *, int);

int	ess_open(void *, int);
void	ess_1788_close(void *);
void	ess_1888_close(void *);

int	ess_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);

int	ess_round_blocksize(void *, int);

int	ess_audio1_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio2_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_trigger_input(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_halt(void *);
int	ess_audio2_halt(void *);
int	ess_audio1_intr(void *);
int	ess_audio2_intr(void *);
void	ess_audio1_poll(void *);
void	ess_audio2_poll(void *);

int	ess_speaker_ctl(void *, int);

int	ess_set_port(void *, mixer_ctrl_t *);
int	ess_get_port(void *, mixer_ctrl_t *);

void   *ess_malloc(void *, int, size_t, int, int);
void	ess_free(void *, void *, int);
size_t	ess_round_buffersize(void *, int, size_t);


int	ess_query_devinfo(void *, mixer_devinfo_t *);
int	ess_1788_get_props(void *);
int	ess_1888_get_props(void *);

void	ess_speaker_on(struct ess_softc *);
void	ess_speaker_off(struct ess_softc *);

int	ess_config_addr(struct ess_softc *);
void	ess_config_irq(struct ess_softc *);
void	ess_config_drq(struct ess_softc *);
void	ess_setup(struct ess_softc *);
int	ess_identify(struct ess_softc *);

int	ess_reset(struct ess_softc *);
void	ess_set_gain(struct ess_softc *, int, int);
int	ess_set_in_port(struct ess_softc *, int);
int	ess_set_in_ports(struct ess_softc *, int);
u_int	ess_srtotc(u_int);
u_int	ess_srtofc(u_int);
u_char	ess_get_dsp_status(struct ess_softc *);
u_char	ess_dsp_read_ready(struct ess_softc *);
u_char	ess_dsp_write_ready(struct ess_softc *);
int	ess_rdsp(struct ess_softc *);
int	ess_wdsp(struct ess_softc *, u_char);
u_char	ess_read_x_reg(struct ess_softc *, u_char);
int	ess_write_x_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_xreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_xreg_bits(struct ess_softc *, u_char, u_char);
u_char	ess_read_mix_reg(struct ess_softc *, u_char);
void	ess_write_mix_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_read_multi_mix_reg(struct ess_softc *, u_char, u_int8_t *, bus_size_t);

static char *essmodel[] = {
	"unsupported",
	"1888",
	"1887",
	"888",
	"1788",
	"1869",
	"1879",
	"1868",
	"1878",
};

/*
 * Define our interface to the higher level audio driver.
 */

struct audio_hw_if ess_1788_hw_if = {
	ess_open,
	ess_1788_close,
	ess_set_params,
	ess_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	ess_audio1_halt,
	ess_audio1_halt,
	ess_speaker_ctl,
	NULL,
	ess_set_port,
	ess_get_port,
	ess_query_devinfo,
	ess_malloc,
	ess_free,
	ess_round_buffersize,
	ess_1788_get_props,
	ess_audio1_trigger_output,
	ess_audio1_trigger_input
};

struct audio_hw_if ess_1888_hw_if = {
	ess_open,
	ess_1888_close,
	ess_set_params,
	ess_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	ess_audio2_halt,
	ess_audio1_halt,
	ess_speaker_ctl,
	NULL,
	ess_set_port,
	ess_get_port,
	ess_query_devinfo,
	ess_malloc,
	ess_free,
	ess_round_buffersize,
	ess_1888_get_props,
	ess_audio2_trigger_output,
	ess_audio1_trigger_input
};

#ifdef AUDIO_DEBUG
void ess_printsc(struct ess_softc *);
void ess_dump_mixer(struct ess_softc *);

void
ess_printsc(struct ess_softc *sc)
{
	int i;

	printf("open %d iobase 0x%x outport %u inport %u speaker %s\n",
	       (int)sc->sc_open, sc->sc_iobase, sc->out_port,
	       sc->in_port, sc->spkr_state ? "on" : "off");

	printf("audio1: dmachan %d irq %d nintr %lu intr %p arg %p\n",
	       sc->sc_audio1.drq, sc->sc_audio1.irq, sc->sc_audio1.nintr,
	       sc->sc_audio1.intr, sc->sc_audio1.arg);

	if (!ESS_USE_AUDIO1(sc->sc_model)) {
		printf("audio2: dmachan %d irq %d nintr %lu intr %p arg %p\n",
		       sc->sc_audio2.drq, sc->sc_audio2.irq, sc->sc_audio2.nintr,
		       sc->sc_audio2.intr, sc->sc_audio2.arg);
	}

	printf("gain:");
	for (i = 0; i < sc->ndevs; i++)
		printf(" %u,%u", sc->gain[i][ESS_LEFT], sc->gain[i][ESS_RIGHT]);
	printf("\n");
}

void
ess_dump_mixer(struct ess_softc *sc)
{
	printf("ESS_DAC_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x7C, ess_read_mix_reg(sc, 0x7C));
	printf("ESS_MIC_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x1A, ess_read_mix_reg(sc, 0x1A));
	printf("ESS_LINE_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x3E, ess_read_mix_reg(sc, 0x3E));
	printf("ESS_SYNTH_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x36, ess_read_mix_reg(sc, 0x36));
	printf("ESS_CD_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x38, ess_read_mix_reg(sc, 0x38));
	printf("ESS_AUXB_PLAY_VOL: mix reg 0x%02x=0x%02x\n",
	       0x3A, ess_read_mix_reg(sc, 0x3A));
	printf("ESS_MASTER_VOL: mix reg 0x%02x=0x%02x\n",
	       0x32, ess_read_mix_reg(sc, 0x32));
	printf("ESS_PCSPEAKER_VOL: mix reg 0x%02x=0x%02x\n",
	       0x3C, ess_read_mix_reg(sc, 0x3C));
	printf("ESS_DAC_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x69, ess_read_mix_reg(sc, 0x69));
	printf("ESS_MIC_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x68, ess_read_mix_reg(sc, 0x68));
	printf("ESS_LINE_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x6E, ess_read_mix_reg(sc, 0x6E));
	printf("ESS_SYNTH_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x6B, ess_read_mix_reg(sc, 0x6B));
	printf("ESS_CD_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x6A, ess_read_mix_reg(sc, 0x6A));
	printf("ESS_AUXB_REC_VOL: mix reg 0x%02x=0x%02x\n",
	       0x6C, ess_read_mix_reg(sc, 0x6C));
	printf("ESS_RECORD_VOL: x reg 0x%02x=0x%02x\n",
	       0xB4, ess_read_x_reg(sc, 0xB4));
	printf("Audio 1 play vol (unused): mix reg 0x%02x=0x%02x\n",
	       0x14, ess_read_mix_reg(sc, 0x14));

	printf("ESS_MIC_PREAMP: x reg 0x%02x=0x%02x\n",
	       ESS_XCMD_PREAMP_CTRL, ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL));
	printf("ESS_RECORD_MONITOR: x reg 0x%02x=0x%02x\n",
	       ESS_XCMD_AUDIO_CTRL, ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL));
	printf("Record source: mix reg 0x%02x=0x%02x, 0x%02x=0x%02x\n",
	       ESS_MREG_ADC_SOURCE, ess_read_mix_reg(sc, ESS_MREG_ADC_SOURCE),
	       ESS_MREG_AUDIO2_CTRL2, ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2));
}

#endif

/*
 * Configure the ESS chip for the desired audio base address.
 */
int
ess_config_addr(struct ess_softc *sc)
{
	int iobase = sc->sc_iobase;
	bus_space_tag_t iot = sc->sc_iot;

	/*
	 * Configure using the System Control Register method.  This
	 * method is used when the AMODE line is tied high, which is
	 * the case for the Shark, but not for the evaluation board.
	 */

	bus_space_handle_t scr_access_ioh;
	bus_space_handle_t scr_ioh;
	u_short scr_value;

	/*
	 * Set the SCR bit to enable audio.
	 */
	scr_value = ESS_SCR_AUDIO_ENABLE;

	/*
	 * Set the SCR bits necessary to select the specified audio
	 * base address.
	 */
	switch(iobase) {
	case 0x220:
		scr_value |= ESS_SCR_AUDIO_220;
		break;
	case 0x230:
		scr_value |= ESS_SCR_AUDIO_230;
		break;
	case 0x240:
		scr_value |= ESS_SCR_AUDIO_240;
		break;
	case 0x250:
		scr_value |= ESS_SCR_AUDIO_250;
		break;
	default:
		printf("ess: configured iobase 0x%x invalid\n", iobase);
		return (1);
		break;
	}

	/*
	 * Get a mapping for the System Control Register (SCR) access
	 * registers and the SCR data registers.
	 */
	if (bus_space_map(iot, ESS_SCR_ACCESS_BASE, ESS_SCR_ACCESS_PORTS,
			  0, &scr_access_ioh)) {
		printf("ess: can't map SCR access registers\n");
		return (1);
	}
	if (bus_space_map(iot, ESS_SCR_BASE, ESS_SCR_PORTS,
			  0, &scr_ioh)) {
		printf("ess: can't map SCR registers\n");
		bus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);
		return (1);
	}

	/* Unlock the SCR. */
	EWRITE1(iot, scr_access_ioh, ESS_SCR_UNLOCK, 0);

	/* Write the base address information into SCR[0]. */
	EWRITE1(iot, scr_ioh, ESS_SCR_INDEX, 0);
	EWRITE1(iot, scr_ioh, ESS_SCR_DATA, scr_value);

	/* Lock the SCR. */
	EWRITE1(iot, scr_access_ioh, ESS_SCR_LOCK, 0);

	/* Unmap the SCR access ports and the SCR data ports. */
	bus_space_unmap(iot, scr_access_ioh, ESS_SCR_ACCESS_PORTS);
	bus_space_unmap(iot, scr_ioh, ESS_SCR_PORTS);

	return 0;
}


/*
 * Configure the ESS chip for the desired IRQ and DMA channels.
 * ESS  ISA
 * --------
 * IRQA irq9
 * IRQB irq5
 * IRQC irq7
 * IRQD irq10
 * IRQE irq15
 *
 * DRQA drq0
 * DRQB drq1
 * DRQC drq3
 * DRQD drq5
 */
void
ess_config_irq(struct ess_softc *sc)
{
	int v;

	DPRINTFN(2,("ess_config_irq\n"));

	if (sc->sc_model == ESS_1887 &&
	    sc->sc_audio1.irq == sc->sc_audio2.irq &&
	    sc->sc_audio1.irq != -1) {
		/* Use new method, both interrupts are the same. */
		v = ESS_IS_SELECT_IRQ;	/* enable intrs */
		switch (sc->sc_audio1.irq) {
		case 5:
			v |= ESS_IS_INTRB;
			break;
		case 7:
			v |= ESS_IS_INTRC;
			break;
		case 9:
			v |= ESS_IS_INTRA;
			break;
		case 10:
			v |= ESS_IS_INTRD;
			break;
		case 15:
			v |= ESS_IS_INTRE;
			break;
#ifdef DIAGNOSTIC
		default:
			printf("ess_config_irq: configured irq %d not supported for Audio 1\n",
			       sc->sc_audio1.irq);
			return;
#endif
		}
		/* Set the IRQ */
		ess_write_mix_reg(sc, ESS_MREG_INTR_ST, v);
		return;
	}

	if (sc->sc_model == ESS_1887) {
		/* Tell the 1887 to use the old interrupt method. */
		ess_write_mix_reg(sc, ESS_MREG_INTR_ST, ESS_IS_ES1888);
	}

	if (sc->sc_audio1.polled) {
		/* Turn off Audio1 interrupts. */
		v = 0;
	} else {
		/* Configure Audio 1 for the appropriate IRQ line. */
		v = ESS_IRQ_CTRL_MASK | ESS_IRQ_CTRL_EXT; /* All intrs on */
		switch (sc->sc_audio1.irq) {
		case 5:
			v |= ESS_IRQ_CTRL_INTRB;
			break;
		case 7:
			v |= ESS_IRQ_CTRL_INTRC;
			break;
		case 9:
			v |= ESS_IRQ_CTRL_INTRA;
			break;
		case 10:
			v |= ESS_IRQ_CTRL_INTRD;
			break;
#ifdef DIAGNOSTIC
		default:
			printf("ess: configured irq %d not supported for Audio 1\n",
			       sc->sc_audio1.irq);
			return;
#endif
		}
	}
	ess_write_x_reg(sc, ESS_XCMD_IRQ_CTRL, v);

	if (ESS_USE_AUDIO1(sc->sc_model))
		return;

	if (sc->sc_audio2.polled) {
		/* Turn off Audio2 interrupts. */
		ess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
				    ESS_AUDIO2_CTRL2_IRQ2_ENABLE);
	} else {
		/* Audio2 is hardwired to INTRE in this mode. */
		ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
				  ESS_AUDIO2_CTRL2_IRQ2_ENABLE);
	}
}


void
ess_config_drq(struct ess_softc *sc)
{
	int v;

	DPRINTFN(2,("ess_config_drq\n"));

	/* Configure Audio 1 (record) for DMA on the appropriate channel. */
	v = ESS_DRQ_CTRL_PU | ESS_DRQ_CTRL_EXT;
	switch (sc->sc_audio1.drq) {
	case 0:
		v |= ESS_DRQ_CTRL_DRQA;
		break;
	case 1:
		v |= ESS_DRQ_CTRL_DRQB;
		break;
	case 3:
		v |= ESS_DRQ_CTRL_DRQC;
		break;
#ifdef DIAGNOSTIC
	default:
		printf("ess_config_drq: configured dma chan %d not supported for Audio 1\n",
		       sc->sc_audio1.drq);
		return;
#endif
	}
	/* Set DRQ1 */
	ess_write_x_reg(sc, ESS_XCMD_DRQ_CTRL, v);

	if (ESS_USE_AUDIO1(sc->sc_model))
		return;

	/* Configure DRQ2 */
	v = ESS_AUDIO2_CTRL3_DRQ_PD;
	switch (sc->sc_audio2.drq) {
	case 0:
		v |= ESS_AUDIO2_CTRL3_DRQA;
		break;
	case 1:
		v |= ESS_AUDIO2_CTRL3_DRQB;
		break;
	case 3:
		v |= ESS_AUDIO2_CTRL3_DRQC;
		break;
	case 5:
		v |= ESS_AUDIO2_CTRL3_DRQD;
		break;
#ifdef DIAGNOSTIC
	default:
		printf("ess_config_drq: configured dma chan %d not supported for Audio 2\n",
		       sc->sc_audio2.drq);
		return;
#endif
	}
	ess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL3, v);
	/* Enable DMA 2 */
	ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
			  ESS_AUDIO2_CTRL2_DMA_ENABLE);
}

/*
 * Set up registers after a reset.
 */
void
ess_setup(struct ess_softc *sc)
{
	ess_config_irq(sc);
	ess_config_drq(sc);

	DPRINTFN(2,("ess_setup: done\n"));
}

/*
 * Determine the model of ESS chip we are talking to.  Currently we
 * only support ES1888, ES1887 and ES888.  The method of determining
 * the chip is based on the information on page 27 of the ES1887 data
 * sheet.
 *
 * This routine sets the values of sc->sc_model and sc->sc_version.
 */
int
ess_identify(struct ess_softc *sc)
{
	u_char reg1;
	u_char reg2;
	u_char reg3;
	u_int8_t ident[4];

	sc->sc_model = ESS_UNSUPPORTED;
	sc->sc_version = 0;

	memset(ident, 0, sizeof(ident));

	/*
	 * 1. Check legacy ID bytes.  These should be 0x68 0x8n, where
	 *    n >= 8 for an ES1887 or an ES888.  Other values indicate
	 *    earlier (unsupported) chips.
	 */
	ess_wdsp(sc, ESS_ACMD_LEGACY_ID);

	if ((reg1 = ess_rdsp(sc)) != 0x68) {
		printf("ess: First ID byte wrong (0x%02x)\n", reg1);
		return 1;
	}

	reg2 = ess_rdsp(sc);
	if (((reg2 & 0xf0) != 0x80) ||
	    ((reg2 & 0x0f) < 8)) {
		printf("ess: Second ID byte wrong (0x%02x)\n", reg2);
		return 1;
	}

	/*
	 * Store the ID bytes as the version.
	 */
	sc->sc_version = (reg1 << 8) + reg2;


	/*
	 * 2. Verify we can change bit 2 in mixer register 0x64.  This
	 *    should be possible on all supported chips.
	 */
	reg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);
	reg2 = reg1 ^ 0x04;  /* toggle bit 2 */

	ess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);

	if (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) != reg2) {
		printf("ess: Hardware error (unable to toggle bit 2 of mixer register 0x64)\n");
		return 1;
	}

	/*
	 * Restore the original value of mixer register 0x64.
	 */
	ess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);


	/*
	 * 3. Verify we can change the value of mixer register
	 *    ESS_MREG_SAMPLE_RATE.
	 *    This is possible on the 1888/1887/888, but not on the 1788.
	 *    It is not necessary to restore the value of this mixer register.
	 */
	reg1 = ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE);
	reg2 = reg1 ^ 0xff;  /* toggle all bits */

	ess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, reg2);

	if (ess_read_mix_reg(sc, ESS_MREG_SAMPLE_RATE) != reg2) {
		/* If we got this far before failing, it's a 1788. */
		sc->sc_model = ESS_1788;

		/*
		 * Identify ESS model for ES18[67]8.
		 */
		ess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));
		if(ident[0] == 0x18) {
			switch(ident[1]) {
			case 0x68:
				sc->sc_model = ESS_1868;
				break;
			case 0x78:
				sc->sc_model = ESS_1878;
				break;
			}
		}
	} else {
		/*
		 * 4. Determine if we can change bit 5 in mixer register 0x64.
		 *    This determines whether we have an ES1887:
		 *
		 *    - can change indicates ES1887
		 *    - can't change indicates ES1888 or ES888
		 */
		reg1 = ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL);
		reg2 = reg1 ^ 0x20;  /* toggle bit 5 */

		ess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg2);

		if (ess_read_mix_reg(sc, ESS_MREG_VOLUME_CTRL) == reg2) {
			sc->sc_model = ESS_1887;

			/*
			 * Restore the original value of mixer register 0x64.
			 */
			ess_write_mix_reg(sc, ESS_MREG_VOLUME_CTRL, reg1);

			/*
			 * Identify ESS model for ES18[67]9.
			 */
			ess_read_multi_mix_reg(sc, 0x40, ident, sizeof(ident));
			if(ident[0] == 0x18) {
				switch(ident[1]) {
				case 0x69:
					sc->sc_model = ESS_1869;
					break;
				case 0x79:
					sc->sc_model = ESS_1879;
					break;
				}
			}
		} else {
			/*
			 * 5. Determine if we can change the value of mixer
			 *    register 0x69 independently of mixer register
			 *    0x68. This determines which chip we have:
			 *
			 *    - can modify idependently indicates ES888
			 *    - register 0x69 is an alias of 0x68 indicates ES1888
			 */
			reg1 = ess_read_mix_reg(sc, 0x68);
			reg2 = ess_read_mix_reg(sc, 0x69);
			reg3 = reg2 ^ 0xff;  /* toggle all bits */

			/*
			 * Write different values to each register.
			 */
			ess_write_mix_reg(sc, 0x68, reg2);
			ess_write_mix_reg(sc, 0x69, reg3);

			if (ess_read_mix_reg(sc, 0x68) == reg2 &&
			    ess_read_mix_reg(sc, 0x69) == reg3)
				sc->sc_model = ESS_888;
			else
				sc->sc_model = ESS_1888;

			/*
			 * Restore the original value of the registers.
			 */
			ess_write_mix_reg(sc, 0x68, reg1);
			ess_write_mix_reg(sc, 0x69, reg2);
		}
	}

	return 0;
}


int
ess_setup_sc(struct ess_softc *sc, int doinit)
{
	/* Reset the chip. */
	if (ess_reset(sc) != 0) {
		DPRINTF(("ess_setup_sc: couldn't reset chip\n"));
		return (1);
	}

	/* Identify the ESS chip, and check that it is supported. */
	if (ess_identify(sc)) {
		DPRINTF(("ess_setup_sc: couldn't identify\n"));
		return (1);
	}

	return (0);
}

/*
 * Probe for the ESS hardware.
 */
int
essmatch(struct ess_softc *sc)
{
	if (!ESS_BASE_VALID(sc->sc_iobase)) {
		printf("ess: configured iobase 0x%x invalid\n", sc->sc_iobase);
		return (0);
	}

	/* Configure the ESS chip for the desired audio base address. */
	if (ess_config_addr(sc))
		return (0);

	if (ess_setup_sc(sc, 1))
		return (0);

	if (sc->sc_model == ESS_UNSUPPORTED) {
		DPRINTF(("ess: Unsupported model\n"));
		return (0);
	}

	/* Check that requested DMA channels are valid and different. */
	if (!ESS_DRQ1_VALID(sc->sc_audio1.drq)) {
		printf("ess: record drq %d invalid\n", sc->sc_audio1.drq);
		return (0);
	}
	if (!isa_drq_isfree(sc->sc_isa, sc->sc_audio1.drq))
		return (0);
	if (!ESS_USE_AUDIO1(sc->sc_model)) {
		if (!ESS_DRQ2_VALID(sc->sc_audio2.drq)) {
			printf("ess: play drq %d invalid\n", sc->sc_audio2.drq);
			return (0);
		}
		if (sc->sc_audio1.drq == sc->sc_audio2.drq) {
			printf("ess: play and record drq both %d\n",
			       sc->sc_audio1.drq);
			return (0);
		}
		if (!isa_drq_isfree(sc->sc_isa, sc->sc_audio2.drq))
			return (0);
	}

	/*
	 * The 1887 has an additional IRQ mode where both channels are mapped
	 * to the same IRQ.
	 */
	if (sc->sc_model == ESS_1887 &&
	    sc->sc_audio1.irq == sc->sc_audio2.irq &&
	    sc->sc_audio1.irq != -1 &&
	    ESS_IRQ12_VALID(sc->sc_audio1.irq))
		goto irq_not1888;

	/* Check that requested IRQ lines are valid and different. */
	if (sc->sc_audio1.irq != -1 &&
	    !ESS_IRQ1_VALID(sc->sc_audio1.irq)) {
		printf("ess: record irq %d invalid\n", sc->sc_audio1.irq);
		return (0);
	}
	if (!ESS_USE_AUDIO1(sc->sc_model)) {
		if (sc->sc_audio2.irq != -1 &&
		    !ESS_IRQ2_VALID(sc->sc_audio2.irq)) {
			printf("ess: play irq %d invalid\n", sc->sc_audio2.irq);
			return (0);
		}
		if (sc->sc_audio1.irq == sc->sc_audio2.irq &&
		    sc->sc_audio1.irq != -1) {
			printf("ess: play and record irq both %d\n",
			       sc->sc_audio1.irq);
			return (0);
		}
	}

irq_not1888:
	/* XXX should we check IRQs as well? */

	return (1);
}


/*
 * Attach hardware to driver, attach hardware driver to audio
 * pseudo-device driver.
 */
void
essattach(struct ess_softc *sc)
{
	struct audio_attach_args arg;
	struct audio_params pparams, rparams;
	int i;
	u_int v;

	if (ess_setup_sc(sc, 0)) {
		printf(": setup failed\n");
		return;
	}

	printf(": ESS Technology ES%s [version 0x%04x]\n",
	       essmodel[sc->sc_model], sc->sc_version);

	sc->sc_audio1.polled = sc->sc_audio1.irq == -1;
	if (!sc->sc_audio1.polled) {
		sc->sc_audio1.ih = isa_intr_establish(sc->sc_ic,
		    sc->sc_audio1.irq, sc->sc_audio1.ist,
		    IPL_AUDIO | IPL_MPSAFE,
		    ess_audio1_intr, sc, sc->sc_dev.dv_xname);
		printf("%s: audio1 interrupting at irq %d\n",
		    sc->sc_dev.dv_xname, sc->sc_audio1.irq);
	} else
		printf("%s: audio1 polled\n", sc->sc_dev.dv_xname);
	if (isa_dmamap_create(sc->sc_isa, sc->sc_audio1.drq,
	    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
		printf("%s: can't create map for drq %d\n",
		       sc->sc_dev.dv_xname, sc->sc_audio1.drq);
		return;
	}

	if (!ESS_USE_AUDIO1(sc->sc_model)) {
		sc->sc_audio2.polled = sc->sc_audio2.irq == -1;
		if (!sc->sc_audio2.polled) {
			sc->sc_audio2.ih = isa_intr_establish(sc->sc_ic,
			    sc->sc_audio2.irq, sc->sc_audio2.ist,
			    IPL_AUDIO | IPL_MPSAFE,
			    ess_audio2_intr, sc, sc->sc_dev.dv_xname);
			printf("%s: audio2 interrupting at irq %d\n",
			    sc->sc_dev.dv_xname, sc->sc_audio2.irq);
		} else
			printf("%s: audio2 polled\n", sc->sc_dev.dv_xname);
		if (isa_dmamap_create(sc->sc_isa, sc->sc_audio2.drq,
		    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
			printf("%s: can't create map for drq %d\n",
			       sc->sc_dev.dv_xname, sc->sc_audio2.drq);
			return;
		}
	}

	timeout_set(&sc->sc_tmo1, ess_audio1_poll, sc);
	timeout_set(&sc->sc_tmo2, ess_audio2_poll, sc);

	/*
	 * Set record and play parameters to default values defined in
	 * generic audio driver.
	 */
	pparams = ess_audio_default;
	rparams = ess_audio_default;
	ess_set_params(sc, AUMODE_RECORD|AUMODE_PLAY, 0, &pparams, &rparams);

	/* Do a hardware reset on the mixer. */
	ess_write_mix_reg(sc, ESS_MIX_RESET, ESS_MIX_RESET);

	/*
	 * Set volume of Audio 1 to zero and disable Audio 1 DAC input
	 * to playback mixer, since playback is always through Audio 2.
	 */
	if (!ESS_USE_AUDIO1(sc->sc_model))
		ess_write_mix_reg(sc, ESS_MREG_VOLUME_VOICE, 0);
	ess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);

	if (ESS_USE_AUDIO1(sc->sc_model)) {
		ess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIC);
		sc->in_port = ESS_SOURCE_MIC;
		sc->ndevs = ESS_1788_NDEVS;
	} else {
		/*
		 * Set hardware record source to use output of the record
		 * mixer. We do the selection of record source in software by
		 * setting the gain of the unused sources to zero. (See
		 * ess_set_in_ports.)
		 */
		ess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ESS_SOURCE_MIXER);
		sc->in_mask = 1 << ESS_MIC_REC_VOL;
		sc->ndevs = ESS_1888_NDEVS;
		ess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x10);
		ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 0x08);
	}

	/*
	 * Set gain on each mixer device to a sensible value.
	 * Devices not normally used are turned off, and other devices
	 * are set to 50% volume.
	 */
	for (i = 0; i < sc->ndevs; i++) {
		switch (i) {
		case ESS_MIC_PLAY_VOL:
		case ESS_LINE_PLAY_VOL:
		case ESS_CD_PLAY_VOL:
		case ESS_AUXB_PLAY_VOL:
		case ESS_DAC_REC_VOL:
		case ESS_LINE_REC_VOL:
		case ESS_SYNTH_REC_VOL:
		case ESS_CD_REC_VOL:
		case ESS_AUXB_REC_VOL:
			v = 0;
			break;
		default:
			v = ESS_4BIT_GAIN(AUDIO_MAX_GAIN / 2);
			break;
		}
		sc->gain[i][ESS_LEFT] = sc->gain[i][ESS_RIGHT] = v;
		ess_set_gain(sc, i, 1);
	}

	ess_setup(sc);

	/* Disable the speaker until the device is opened.  */
	ess_speaker_off(sc);
	sc->spkr_state = SPKR_OFF;

	if (ESS_USE_AUDIO1(sc->sc_model))
		audio_attach_mi(&ess_1788_hw_if, sc, &sc->sc_dev);
	else
		audio_attach_mi(&ess_1888_hw_if, sc, &sc->sc_dev);

	arg.type = AUDIODEV_TYPE_OPL;
	arg.hwif = 0;
	arg.hdl = 0;
	(void)config_found(&sc->sc_dev, &arg, audioprint);

#ifdef AUDIO_DEBUG
	if (essdebug > 0)
		ess_printsc(sc);
#endif
}

/*
 * Various routines to interface to higher level audio driver
 */

int
ess_open(void *addr, int flags)
{
	struct ess_softc *sc = addr;

	DPRINTF(("ess_open: sc=%p\n", sc));

	if (sc->sc_open != 0 || ess_reset(sc) != 0)
		return ENXIO;

	ess_setup(sc);		/* because we did a reset */

	sc->sc_open = 1;

	DPRINTF(("ess_open: opened\n"));

	return (0);
}

void
ess_1788_close(void *addr)
{
	struct ess_softc *sc = addr;

	DPRINTF(("ess_1788_close: sc=%p\n", sc));

	ess_speaker_off(sc);
	sc->spkr_state = SPKR_OFF;

	ess_audio1_halt(sc);

	sc->sc_open = 0;
	DPRINTF(("ess_1788_close: closed\n"));
}

void
ess_1888_close(void *addr)
{
	struct ess_softc *sc = addr;

	DPRINTF(("ess_1888_close: sc=%p\n", sc));

	ess_speaker_off(sc);
	sc->spkr_state = SPKR_OFF;

	ess_audio1_halt(sc);
	ess_audio2_halt(sc);

	sc->sc_open = 0;
	DPRINTF(("ess_1888_close: closed\n"));
}

/* XXX should use reference count */
int
ess_speaker_ctl(void *addr, int newstate)
{
	struct ess_softc *sc = addr;

	if ((newstate == SPKR_ON) && (sc->spkr_state == SPKR_OFF)) {
		ess_speaker_on(sc);
		sc->spkr_state = SPKR_ON;
	}
	if ((newstate == SPKR_OFF) && (sc->spkr_state == SPKR_ON)) {
		ess_speaker_off(sc);
		sc->spkr_state = SPKR_OFF;
	}
	return (0);
}

int
ess_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct ess_softc *sc = addr;
	struct audio_params *p;
	int mode;
	int rate;

	DPRINTF(("ess_set_params: set=%d use=%d\n", setmode, usemode));

	/*
	 * The ES1887 manual (page 39, `Full-Duplex DMA Mode') claims that in
	 * full-duplex operation the sample rates must be the same for both
	 * channels.  This appears to be false; the only bit in common is the
	 * clock source selection.  However, we'll be conservative here.
	 * - mycroft
	 */
	if (play->sample_rate != rec->sample_rate &&
	    usemode == (AUMODE_PLAY | AUMODE_RECORD)) {
		if (setmode == AUMODE_PLAY) {
			rec->sample_rate = play->sample_rate;
			setmode |= AUMODE_RECORD;
		} else if (setmode == AUMODE_RECORD) {
			play->sample_rate = rec->sample_rate;
			setmode |= AUMODE_PLAY;
		} else
			return (EINVAL);
	}

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		if (p->sample_rate < ESS_MINRATE)
			p->sample_rate = ESS_MINRATE;
		if (p->sample_rate > ESS_MAXRATE)
			p->sample_rate = ESS_MAXRATE;
		if (p->precision > 16)
			p->precision = 16;
		if (p->channels > 2)
			p->channels = 2;

		switch (p->encoding) {
		case AUDIO_ENCODING_SLINEAR_BE:
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision != 8)
				return EINVAL;
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
		case AUDIO_ENCODING_ULINEAR_LE:
			break;
		default:
			return (EINVAL);
		}
		p->bps = AUDIO_BPS(p->precision);
		p->msb = 1;
	}

	if (usemode == AUMODE_RECORD)
		rate = rec->sample_rate;
	else
		rate = play->sample_rate;

	ess_write_x_reg(sc, ESS_XCMD_SAMPLE_RATE, ess_srtotc(rate));
	ess_write_x_reg(sc, ESS_XCMD_FILTER_CLOCK, ess_srtofc(rate));

	if (!ESS_USE_AUDIO1(sc->sc_model)) {
		ess_write_mix_reg(sc, ESS_MREG_SAMPLE_RATE, ess_srtotc(rate));
		ess_write_mix_reg(sc, ESS_MREG_FILTER_CLOCK, ess_srtofc(rate));
	}

	return (0);
}

int
ess_audio1_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct ess_softc *sc = addr;
	u_int8_t reg;

	mtx_enter(&audio_lock);
	DPRINTFN(1, ("ess_audio1_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n",
	    addr, start, end, blksize, intr, arg));

	if (sc->sc_audio1.active)
		panic("ess_audio1_trigger_output: already running");

	sc->sc_audio1.active = 1;
	sc->sc_audio1.intr = intr;
	sc->sc_audio1.arg = arg;
	if (sc->sc_audio1.polled) {
		sc->sc_audio1.dmapos = 0;
		sc->sc_audio1.buffersize = (char *)end - (char *)start;
		sc->sc_audio1.dmacount = 0;
		sc->sc_audio1.blksize = blksize;
		timeout_add_msec(&sc->sc_tmo1, 1000/30);
	}

	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);
	if (param->channels == 2) {
		reg &= ~ESS_AUDIO_CTRL_MONO;
		reg |= ESS_AUDIO_CTRL_STEREO;
	} else {
		reg |= ESS_AUDIO_CTRL_MONO;
		reg &= ~ESS_AUDIO_CTRL_STEREO;
	}
	ess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);

	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);
	if (param->precision == 16)
		reg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;
	if (param->channels == 2)
		reg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;
	if (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_LE)
		reg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;
	reg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;
	ess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);

	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start,
		     (char *)end - (char *)start, NULL,
	    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);

	/* Program transfer count registers with 2's complement of count. */
	blksize = -blksize;
	ess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);
	ess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);

	/* Use 4 bytes per output DMA. */
	ess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);

	/* Start auto-init DMA */
	ess_wdsp(sc, ESS_ACMD_ENABLE_SPKR);
	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);
	reg &= ~(ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE);
	reg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;
	ess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);
	mtx_leave(&audio_lock);
	return (0);
}

int
ess_audio2_trigger_output(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct ess_softc *sc = addr;
	u_int8_t reg;

	mtx_enter(&audio_lock);
	DPRINTFN(1, ("ess_audio2_trigger_output: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n",
	    addr, start, end, blksize, intr, arg));

	if (sc->sc_audio2.active)
		panic("ess_audio2_trigger_output: already running");

	sc->sc_audio2.active = 1;
	sc->sc_audio2.intr = intr;
	sc->sc_audio2.arg = arg;
	if (sc->sc_audio2.polled) {
		sc->sc_audio2.dmapos = 0;
		sc->sc_audio2.buffersize = (char *)end - (char *)start;
		sc->sc_audio2.dmacount = 0;
		sc->sc_audio2.blksize = blksize;
		timeout_add_msec(&sc->sc_tmo2, 1000/30);
	}

	reg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);
	if (param->precision == 16)
		reg |= ESS_AUDIO2_CTRL2_FIFO_SIZE;
	else
		reg &= ~ESS_AUDIO2_CTRL2_FIFO_SIZE;
	if (param->channels == 2)
		reg |= ESS_AUDIO2_CTRL2_CHANNELS;
	else
		reg &= ~ESS_AUDIO2_CTRL2_CHANNELS;
	if (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_LE)
		reg |= ESS_AUDIO2_CTRL2_FIFO_SIGNED;
	else
		reg &= ~ESS_AUDIO2_CTRL2_FIFO_SIGNED;
	ess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);

	isa_dmastart(sc->sc_isa, sc->sc_audio2.drq, start,
		     (char *)end - (char *)start, NULL,
	    DMAMODE_WRITE | DMAMODE_LOOP, BUS_DMA_NOWAIT);

	if (IS16BITDRQ(sc->sc_audio2.drq))
		blksize >>= 1;	/* use word count for 16 bit DMA */
	/* Program transfer count registers with 2's complement of count. */
	blksize = -blksize;
	ess_write_mix_reg(sc, ESS_MREG_XFER_COUNTLO, blksize);
	ess_write_mix_reg(sc, ESS_MREG_XFER_COUNTHI, blksize >> 8);

	reg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1);
	if (IS16BITDRQ(sc->sc_audio2.drq))
		reg |= ESS_AUDIO2_CTRL1_XFER_SIZE;
	else
		reg &= ~ESS_AUDIO2_CTRL1_XFER_SIZE;
	reg |= ESS_AUDIO2_CTRL1_DEMAND_8;
	reg |= ESS_AUDIO2_CTRL1_DAC_ENABLE | ESS_AUDIO2_CTRL1_FIFO_ENABLE |
	       ESS_AUDIO2_CTRL1_AUTO_INIT;
	ess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL1, reg);
	mtx_leave(&audio_lock);
	return (0);
}

int
ess_audio1_trigger_input(void *addr, void *start, void *end, int blksize,
    void (*intr)(void *), void *arg, struct audio_params *param)
{
	struct ess_softc *sc = addr;
	u_int8_t reg;

	mtx_enter(&audio_lock);
	DPRINTFN(1, ("ess_audio1_trigger_input: sc=%p start=%p end=%p blksize=%d intr=%p(%p)\n",
	    addr, start, end, blksize, intr, arg));

	if (sc->sc_audio1.active)
		panic("ess_audio1_trigger_input: already running");

	sc->sc_audio1.active = 1;
	sc->sc_audio1.intr = intr;
	sc->sc_audio1.arg = arg;
	if (sc->sc_audio1.polled) {
		sc->sc_audio1.dmapos = 0;
		sc->sc_audio1.buffersize = (char *)end - (char *)start;
		sc->sc_audio1.dmacount = 0;
		sc->sc_audio1.blksize = blksize;
		timeout_add_msec(&sc->sc_tmo1, 1000/30);
	}

	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL);
	if (param->channels == 2) {
		reg &= ~ESS_AUDIO_CTRL_MONO;
		reg |= ESS_AUDIO_CTRL_STEREO;
	} else {
		reg |= ESS_AUDIO_CTRL_MONO;
		reg &= ~ESS_AUDIO_CTRL_STEREO;
	}
	ess_write_x_reg(sc, ESS_XCMD_AUDIO_CTRL, reg);

	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1);
	if (param->precision == 16)
		reg |= ESS_AUDIO1_CTRL1_FIFO_SIZE;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_SIZE;
	if (param->channels == 2)
		reg |= ESS_AUDIO1_CTRL1_FIFO_STEREO;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_STEREO;
	if (param->encoding == AUDIO_ENCODING_SLINEAR_BE ||
	    param->encoding == AUDIO_ENCODING_SLINEAR_LE)
		reg |= ESS_AUDIO1_CTRL1_FIFO_SIGNED;
	else
		reg &= ~ESS_AUDIO1_CTRL1_FIFO_SIGNED;
	reg |= ESS_AUDIO1_CTRL1_FIFO_CONNECT;
	ess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL1, reg);

	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start,
		     (char *)end - (char *)start, NULL,
	    DMAMODE_READ | DMAMODE_LOOP, BUS_DMA_NOWAIT);

	/* Program transfer count registers with 2's complement of count. */
	blksize = -blksize;
	ess_write_x_reg(sc, ESS_XCMD_XFER_COUNTLO, blksize);
	ess_write_x_reg(sc, ESS_XCMD_XFER_COUNTHI, blksize >> 8);

	/* Use 4 bytes per input DMA. */
	ess_set_xreg_bits(sc, ESS_XCMD_DEMAND_CTRL, ESS_DEMAND_CTRL_DEMAND_4);

	/* Start auto-init DMA */
	ess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);
	reg = ess_read_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2);
	reg |= ESS_AUDIO1_CTRL2_DMA_READ | ESS_AUDIO1_CTRL2_ADC_ENABLE;
	reg |= ESS_AUDIO1_CTRL2_FIFO_ENABLE | ESS_AUDIO1_CTRL2_AUTO_INIT;
	ess_write_x_reg(sc, ESS_XCMD_AUDIO1_CTRL2, reg);
	mtx_leave(&audio_lock);
	return (0);
}

int
ess_audio1_halt(void *addr)
{
	struct ess_softc *sc = addr;

	DPRINTF(("ess_audio1_halt: sc=%p\n", sc));
	mtx_enter(&audio_lock);
	if (sc->sc_audio1.active) {
		ess_clear_xreg_bits(sc, ESS_XCMD_AUDIO1_CTRL2,
		    ESS_AUDIO1_CTRL2_FIFO_ENABLE);
		isa_dmaabort(sc->sc_isa, sc->sc_audio1.drq);
		if (sc->sc_audio1.polled)
			timeout_del(&sc->sc_tmo1);
		sc->sc_audio1.active = 0;
	}
	mtx_leave(&audio_lock);
	return (0);
}

int
ess_audio2_halt(void *addr)
{
	struct ess_softc *sc = addr;

	DPRINTF(("ess_audio2_halt: sc=%p\n", sc));
	mtx_enter(&audio_lock);
	if (sc->sc_audio2.active) {
		ess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL1,
		    ESS_AUDIO2_CTRL1_DAC_ENABLE |
		    ESS_AUDIO2_CTRL1_FIFO_ENABLE);
		isa_dmaabort(sc->sc_isa, sc->sc_audio2.drq);
		if (sc->sc_audio2.polled)
			timeout_del(&sc->sc_tmo2);
		sc->sc_audio2.active = 0;
	}
	mtx_leave(&audio_lock);
	return (0);
}

int
ess_audio1_intr(void *arg)
{
	struct ess_softc *sc = arg;
	u_int8_t reg;

	DPRINTFN(1,("ess_audio1_intr: intr=%p\n", sc->sc_audio1.intr));

	mtx_enter(&audio_lock);
	/* Check and clear interrupt on Audio1. */
	reg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS);
	if ((reg & ESS_DSP_READ_OFLOW) == 0) {
		mtx_leave(&audio_lock);
		return (0);
	}
	reg = EREAD1(sc->sc_iot, sc->sc_ioh, ESS_CLEAR_INTR);

	sc->sc_audio1.nintr++;

	if (sc->sc_audio1.active) {
		(*sc->sc_audio1.intr)(sc->sc_audio1.arg);
		mtx_leave(&audio_lock);
		return (1);
	} else {
		mtx_leave(&audio_lock);
		return (0);
	}
}

int
ess_audio2_intr(void *arg)
{
	struct ess_softc *sc = arg;
	u_int8_t reg;

	DPRINTFN(1,("ess_audio2_intr: intr=%p\n", sc->sc_audio2.intr));

	mtx_enter(&audio_lock);
	/* Check and clear interrupt on Audio2. */
	reg = ess_read_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2);
	if ((reg & ESS_AUDIO2_CTRL2_IRQ_LATCH) == 0) {
		mtx_leave(&audio_lock);
		return (0);
	}
	reg &= ~ESS_AUDIO2_CTRL2_IRQ_LATCH;
	ess_write_mix_reg(sc, ESS_MREG_AUDIO2_CTRL2, reg);

	sc->sc_audio2.nintr++;

	if (sc->sc_audio2.active) {
		(*sc->sc_audio2.intr)(sc->sc_audio2.arg);
		mtx_leave(&audio_lock);
		return (1);
	} else {
		mtx_leave(&audio_lock);
		return (0);
	}
}

void
ess_audio1_poll(void *addr)
{
	struct ess_softc *sc = addr;
	int dmapos, dmacount;

	if (!sc->sc_audio1.active)
		return;

	mtx_enter(&audio_lock);
	sc->sc_audio1.nintr++;

	dmapos = isa_dmacount(sc->sc_isa, sc->sc_audio1.drq);
	dmacount = sc->sc_audio1.dmapos - dmapos;
	if (dmacount < 0)
		dmacount += sc->sc_audio1.buffersize;
	sc->sc_audio1.dmapos = dmapos;
#if 1
	dmacount += sc->sc_audio1.dmacount;
	while (dmacount > sc->sc_audio1.blksize) {
		dmacount -= sc->sc_audio1.blksize;
		(*sc->sc_audio1.intr)(sc->sc_audio1.arg);
	}
	sc->sc_audio1.dmacount = dmacount;
#else
	(*sc->sc_audio1.intr)(sc->sc_audio1.arg, dmacount);
#endif
	timeout_add_msec(&sc->sc_tmo1, 1000/30);
	mtx_leave(&audio_lock);
}

void
ess_audio2_poll(void *addr)
{
	struct ess_softc *sc = addr;
	int dmapos, dmacount;

	if (!sc->sc_audio2.active)
		return;

	mtx_enter(&audio_lock);
	sc->sc_audio2.nintr++;

	dmapos = isa_dmacount(sc->sc_isa, sc->sc_audio2.drq);
	dmacount = sc->sc_audio2.dmapos - dmapos;
	if (dmacount < 0)
		dmacount += sc->sc_audio2.buffersize;
	sc->sc_audio2.dmapos = dmapos;
#if 1
	dmacount += sc->sc_audio2.dmacount;
	while (dmacount > sc->sc_audio2.blksize) {
		dmacount -= sc->sc_audio2.blksize;
		(*sc->sc_audio2.intr)(sc->sc_audio2.arg);
	}
	sc->sc_audio2.dmacount = dmacount;
#else
	(*sc->sc_audio2.intr)(sc->sc_audio2.arg, dmacount);
#endif
	timeout_add_msec(&sc->sc_tmo2, 1000/30);
	mtx_leave(&audio_lock);
}

int
ess_round_blocksize(void *addr, int blk)
{
	return ((blk + 7) & -8);	/* round for max DMA size */
}

int
ess_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct ess_softc *sc = addr;
	int lgain, rgain;

	DPRINTFN(5,("ess_set_port: port=%d num_channels=%d\n",
		    cp->dev, cp->un.value.num_channels));

	switch (cp->dev) {
	/*
	 * The following mixer ports are all stereo. If we get a
	 * single-channel gain value passed in, then we duplicate it
	 * to both left and right channels.
	 */
	case ESS_MASTER_VOL:
	case ESS_DAC_PLAY_VOL:
	case ESS_MIC_PLAY_VOL:
	case ESS_LINE_PLAY_VOL:
	case ESS_SYNTH_PLAY_VOL:
	case ESS_CD_PLAY_VOL:
	case ESS_AUXB_PLAY_VOL:
	case ESS_RECORD_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return EINVAL;

		switch (cp->un.value.num_channels) {
		case 1:
			lgain = rgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		case 2:
			lgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
			rgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
			break;
		default:
			return EINVAL;
		}

		sc->gain[cp->dev][ESS_LEFT]  = lgain;
		sc->gain[cp->dev][ESS_RIGHT] = rgain;
		ess_set_gain(sc, cp->dev, 1);
		return (0);

	/*
	 * The PC speaker port is mono. If we get a stereo gain value
	 * passed in, then we return EINVAL.
	 */
	case ESS_PCSPEAKER_VOL:
		if (cp->un.value.num_channels != 1)
			return EINVAL;

		sc->gain[cp->dev][ESS_LEFT] = sc->gain[cp->dev][ESS_RIGHT] =
		  ESS_3BIT_GAIN(cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
		ess_set_gain(sc, cp->dev, 1);
		return (0);

	case ESS_RECORD_SOURCE:
		if (ESS_USE_AUDIO1(sc->sc_model)) {
			if (cp->type == AUDIO_MIXER_ENUM)
				return (ess_set_in_port(sc, cp->un.ord));
			else
				return (EINVAL);
		} else {
			if (cp->type == AUDIO_MIXER_SET)
				return (ess_set_in_ports(sc, cp->un.mask));
			else
				return (EINVAL);
		}
		return (0);

	case ESS_RECORD_MONITOR:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;

		if (cp->un.ord)
			/* Enable monitor */
			ess_set_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,
					  ESS_AUDIO_CTRL_MONITOR);
		else
			/* Disable monitor */
			ess_clear_xreg_bits(sc, ESS_XCMD_AUDIO_CTRL,
					    ESS_AUDIO_CTRL_MONITOR);
		return (0);
	}

	if (ESS_USE_AUDIO1(sc->sc_model))
		return (EINVAL);

	switch (cp->dev) {
	case ESS_DAC_REC_VOL:
	case ESS_MIC_REC_VOL:
	case ESS_LINE_REC_VOL:
	case ESS_SYNTH_REC_VOL:
	case ESS_CD_REC_VOL:
	case ESS_AUXB_REC_VOL:
		if (cp->type != AUDIO_MIXER_VALUE)
			return EINVAL;

		switch (cp->un.value.num_channels) {
		case 1:
			lgain = rgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_MONO]);
			break;
		case 2:
			lgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT]);
			rgain = ESS_4BIT_GAIN(
			  cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT]);
			break;
		default:
			return EINVAL;
		}

		sc->gain[cp->dev][ESS_LEFT]  = lgain;
		sc->gain[cp->dev][ESS_RIGHT] = rgain;
		ess_set_gain(sc, cp->dev, 1);
		return (0);

	case ESS_MIC_PREAMP:
		if (cp->type != AUDIO_MIXER_ENUM)
			return EINVAL;

		if (cp->un.ord)
			/* Enable microphone preamp */
			ess_set_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,
					  ESS_PREAMP_CTRL_ENABLE);
		else
			/* Disable microphone preamp */
			ess_clear_xreg_bits(sc, ESS_XCMD_PREAMP_CTRL,
					  ESS_PREAMP_CTRL_ENABLE);
		return (0);
	}

	return (EINVAL);
}

int
ess_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct ess_softc *sc = addr;

	DPRINTFN(5,("ess_get_port: port=%d\n", cp->dev));

	switch (cp->dev) {
	case ESS_MASTER_VOL:
	case ESS_DAC_PLAY_VOL:
	case ESS_MIC_PLAY_VOL:
	case ESS_LINE_PLAY_VOL:
	case ESS_SYNTH_PLAY_VOL:
	case ESS_CD_PLAY_VOL:
	case ESS_AUXB_PLAY_VOL:
	case ESS_RECORD_VOL:
		switch (cp->un.value.num_channels) {
		case 1:
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
				sc->gain[cp->dev][ESS_LEFT];
			break;
		case 2:
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
				sc->gain[cp->dev][ESS_LEFT];
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
				sc->gain[cp->dev][ESS_RIGHT];
			break;
		default:
			return EINVAL;
		}
		return (0);

	case ESS_PCSPEAKER_VOL:
		if (cp->un.value.num_channels != 1)
			return EINVAL;

		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
			sc->gain[cp->dev][ESS_LEFT];
		return (0);

	case ESS_RECORD_SOURCE:
		if (ESS_USE_AUDIO1(sc->sc_model))
			cp->un.ord = sc->in_port;
		else
			cp->un.mask = sc->in_mask;
		return (0);

	case ESS_RECORD_MONITOR:
		cp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_AUDIO_CTRL) &
			      ESS_AUDIO_CTRL_MONITOR) ? 1 : 0;
		return (0);
	}

	if (ESS_USE_AUDIO1(sc->sc_model))
		return (EINVAL);

	switch (cp->dev) {
	case ESS_DAC_REC_VOL:
	case ESS_MIC_REC_VOL:
	case ESS_LINE_REC_VOL:
	case ESS_SYNTH_REC_VOL:
	case ESS_CD_REC_VOL:
	case ESS_AUXB_REC_VOL:
		switch (cp->un.value.num_channels) {
		case 1:
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
				sc->gain[cp->dev][ESS_LEFT];
			break;
		case 2:
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
				sc->gain[cp->dev][ESS_LEFT];
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
				sc->gain[cp->dev][ESS_RIGHT];
			break;
		default:
			return EINVAL;
		}
		return (0);

	case ESS_MIC_PREAMP:
		cp->un.ord = (ess_read_x_reg(sc, ESS_XCMD_PREAMP_CTRL) &
			      ESS_PREAMP_CTRL_ENABLE) ? 1 : 0;
		return (0);
	}

	return (EINVAL);
}

int
ess_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct ess_softc *sc = addr;

	DPRINTFN(5,("ess_query_devinfo: model=%d index=%d\n",
		    sc->sc_model, dip->index));

	/*
	 * REVISIT: There are some slight differences between the
	 *          mixers on the different ESS chips, which can
	 *          be sorted out using the chip model rather than a
	 *          separate mixer model.
	 *          This is currently coded assuming an ES1887; we
	 *          need to work out which bits are not applicable to
	 *          the other models (1888 and 888).
	 */
	switch (dip->index) {
	case ESS_DAC_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_MIC_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		if (ESS_USE_AUDIO1(sc->sc_model))
			dip->next = AUDIO_MIXER_LAST;
		else
			dip->next = ESS_MIC_PREAMP;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_LINE_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_SYNTH_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_CD_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_AUXB_PLAY_VOL:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_INPUT_CLASS:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		return (0);

	case ESS_MASTER_VOL:
		dip->mixer_class = ESS_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_PCSPEAKER_VOL:
		dip->mixer_class = ESS_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 1;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_OUTPUT_CLASS:
		dip->mixer_class = ESS_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		return (0);

	case ESS_RECORD_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_RECORD_SOURCE:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		if (ESS_USE_AUDIO1(sc->sc_model)) {
			/*
			 * The 1788 doesn't use the input mixer control that
			 * the 1888 uses, because it's a pain when you only
			 * have one mixer.
			 * Perhaps it could be emulated by keeping both sets of
			 * gain values, and doing a `context switch' of the
			 * mixer registers when shifting from playing to
			 * recording.
			 */
			dip->type = AUDIO_MIXER_ENUM;
			dip->un.e.num_mem = 4;
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
			dip->un.e.member[0].ord = ESS_SOURCE_MIC;
			strlcpy(dip->un.e.member[1].label.name, AudioNline,
			    sizeof dip->un.e.member[1].label.name);
			dip->un.e.member[1].ord = ESS_SOURCE_LINE;
			strlcpy(dip->un.e.member[2].label.name, AudioNcd,
			    sizeof dip->un.e.member[2].label.name);
			dip->un.e.member[2].ord = ESS_SOURCE_CD;
			strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
			    sizeof dip->un.e.member[3].label.name);
			dip->un.e.member[3].ord = ESS_SOURCE_MIXER;
		} else {
			dip->type = AUDIO_MIXER_SET;
			dip->un.s.num_mem = 6;
			strlcpy(dip->un.s.member[0].label.name, AudioNdac,
			    sizeof dip->un.e.member[0].label.name);
			dip->un.s.member[0].mask = 1 << ESS_DAC_REC_VOL;
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[1].label.name);
			dip->un.s.member[1].mask = 1 << ESS_MIC_REC_VOL;
			strlcpy(dip->un.s.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
			dip->un.s.member[2].mask = 1 << ESS_LINE_REC_VOL;
			strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
			    sizeof dip->un.e.member[3].label.name);
			dip->un.s.member[3].mask = 1 << ESS_SYNTH_REC_VOL;
			strlcpy(dip->un.s.member[4].label.name, AudioNcd,
			    sizeof dip->un.e.member[4].label.name);
			dip->un.s.member[4].mask = 1 << ESS_CD_REC_VOL;
			strlcpy(dip->un.s.member[5].label.name, "auxb",
			    sizeof dip->un.e.member[5].label.name);
			dip->un.s.member[5].mask = 1 << ESS_AUXB_REC_VOL;
		}
		return (0);

	case ESS_RECORD_CLASS:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		return (0);

	case ESS_RECORD_MONITOR:
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = ESS_MONITOR_CLASS;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return (0);

	case ESS_MONITOR_CLASS:
		dip->mixer_class = ESS_MONITOR_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_CLASS;
		return (0);
	}

	if (ESS_USE_AUDIO1(sc->sc_model))
		return (ENXIO);

	switch (dip->index) {
	case ESS_DAC_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_MIC_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_LINE_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_SYNTH_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_CD_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_AUXB_REC_VOL:
		dip->mixer_class = ESS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
		dip->type = AUDIO_MIXER_VALUE;
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		return (0);

	case ESS_MIC_PREAMP:
		dip->mixer_class = ESS_INPUT_CLASS;
		dip->prev = ESS_MIC_PLAY_VOL;
		dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
		dip->type = AUDIO_MIXER_ENUM;
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		return (0);
	}

	return (ENXIO);
}

void *
ess_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct ess_softc *sc = addr;
	int drq;

	if (!ESS_USE_AUDIO1(sc->sc_model))
		drq = sc->sc_audio2.drq;
	else
		drq = sc->sc_audio1.drq;
	return (isa_malloc(sc->sc_isa, drq, size, pool, flags));
}

void
ess_free(void *addr, void *ptr, int pool)
{
	isa_free(ptr, pool);
}

size_t
ess_round_buffersize(void *addr, int direction, size_t size)
{
	if (size > MAX_ISADMA)
		size = MAX_ISADMA;
	return (size);
}

int
ess_1788_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT);
}

int
ess_1888_get_props(void *addr)
{
	return (AUDIO_PROP_MMAP | AUDIO_PROP_INDEPENDENT | AUDIO_PROP_FULLDUPLEX);
}

/* ============================================
 * Generic functions for ess, not used by audio h/w i/f
 * =============================================
 */

/*
 * Reset the chip.
 * Return non-zero if the chip isn't detected.
 */
int
ess_reset(struct ess_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	sc->sc_audio1.active = 0;
	sc->sc_audio2.active = 0;

	EWRITE1(iot, ioh, ESS_DSP_RESET, ESS_RESET_EXT);
	delay(10000);
	EWRITE1(iot, ioh, ESS_DSP_RESET, 0);
	if (ess_rdsp(sc) != ESS_MAGIC)
		return (1);

	/* Enable access to the ESS extension commands. */
	ess_wdsp(sc, ESS_ACMD_ENABLE_EXT);

	return (0);
}

void
ess_set_gain(sc, port, on)
	struct ess_softc *sc;
	int port;
	int on;
{
	int gain, left, right;
	int mix;
	int src;
	int stereo;

	/*
	 * Most gain controls are found in the mixer registers and
	 * are stereo. Any that are not, must set mix and stereo as
	 * required.
	 */
	mix = 1;
	stereo = 1;

	switch (port) {
	case ESS_MASTER_VOL:
		src = ESS_MREG_VOLUME_MASTER;
		break;
	case ESS_DAC_PLAY_VOL:
		if (ESS_USE_AUDIO1(sc->sc_model))
			src = ESS_MREG_VOLUME_VOICE;
		else
			src = 0x7C;
		break;
	case ESS_MIC_PLAY_VOL:
		src = ESS_MREG_VOLUME_MIC;
		break;
	case ESS_LINE_PLAY_VOL:
		src = ESS_MREG_VOLUME_LINE;
		break;
	case ESS_SYNTH_PLAY_VOL:
		src = ESS_MREG_VOLUME_SYNTH;
		break;
	case ESS_CD_PLAY_VOL:
		src = ESS_MREG_VOLUME_CD;
		break;
	case ESS_AUXB_PLAY_VOL:
		src = ESS_MREG_VOLUME_AUXB;
		break;
	case ESS_PCSPEAKER_VOL:
		src = ESS_MREG_VOLUME_PCSPKR;
		stereo = 0;
		break;
	case ESS_DAC_REC_VOL:
		src = 0x69;
		break;
	case ESS_MIC_REC_VOL:
		src = 0x68;
		break;
	case ESS_LINE_REC_VOL:
		src = 0x6E;
		break;
	case ESS_SYNTH_REC_VOL:
		src = 0x6B;
		break;
	case ESS_CD_REC_VOL:
		src = 0x6A;
		break;
	case ESS_AUXB_REC_VOL:
		src = 0x6C;
		break;
	case ESS_RECORD_VOL:
		src = ESS_XCMD_VOLIN_CTRL;
		mix = 0;
		break;
	default:
		return;
	}

	/* 1788 doesn't have a separate recording mixer */
	if (ESS_USE_AUDIO1(sc->sc_model) && mix && src > 0x62)
		return;

	if (on) {
		left = sc->gain[port][ESS_LEFT];
		right = sc->gain[port][ESS_RIGHT];
	} else {
		left = right = 0;
	}

	if (stereo)
		gain = ESS_STEREO_GAIN(left, right);
	else
		gain = ESS_MONO_GAIN(left);

	if (mix)
		ess_write_mix_reg(sc, src, gain);
	else
		ess_write_x_reg(sc, src, gain);
}

/* Set the input device on devices without an input mixer. */
int
ess_set_in_port(struct ess_softc *sc, int ord)
{
	mixer_devinfo_t di;
	int i;

	DPRINTF(("ess_set_in_port: ord=0x%x\n", ord));

	/*
	 * Get the device info for the record source control,
	 * including the list of available sources.
	 */
	di.index = ESS_RECORD_SOURCE;
	if (ess_query_devinfo(sc, &di))
		return EINVAL;

	/* See if the given ord value was anywhere in the list. */
	for (i = 0; i < di.un.e.num_mem; i++) {
		if (ord == di.un.e.member[i].ord)
			break;
	}
	if (i == di.un.e.num_mem)
		return EINVAL;

	ess_write_mix_reg(sc, ESS_MREG_ADC_SOURCE, ord);

	sc->in_port = ord;
	return (0);
}

/* Set the input device levels on input-mixer-enabled devices. */
int
ess_set_in_ports(struct ess_softc *sc, int mask)
{
	mixer_devinfo_t di;
	int i, port;

	DPRINTF(("ess_set_in_ports: mask=0x%x\n", mask));

	/*
	 * Get the device info for the record source control,
	 * including the list of available sources.
	 */
	di.index = ESS_RECORD_SOURCE;
	if (ess_query_devinfo(sc, &di))
		return EINVAL;

	/*
	 * Set or disable the record volume control for each of the
	 * possible sources.
	 */
	for (i = 0; i < di.un.s.num_mem; i++) {
		/*
		 * Calculate the source port number from its mask.
		 */
		port = ffs(di.un.s.member[i].mask);

		/*
		 * Set the source gain:
		 *	to the current value if source is enabled
		 *	to zero if source is disabled
		 */
		ess_set_gain(sc, port, mask & di.un.s.member[i].mask);
	}

	sc->in_mask = mask;
	return (0);
}

void
ess_speaker_on(struct ess_softc *sc)
{
	/* Unmute the DAC. */
	ess_set_gain(sc, ESS_DAC_PLAY_VOL, 1);
}

void
ess_speaker_off(struct ess_softc *sc)
{
	/* Mute the DAC. */
	ess_set_gain(sc, ESS_DAC_PLAY_VOL, 0);
}

/*
 * Calculate the time constant for the requested sampling rate.
 */
u_int
ess_srtotc(u_int rate)
{
	u_int tc;

	/* The following formulae are from the ESS data sheet. */
	if (rate <= 22050)
		tc = 128 - 397700L / rate;
	else
		tc = 256 - 795500L / rate;

	return (tc);
}


/*
 * Calculate the filter constant for the reuqested sampling rate.
 */
u_int
ess_srtofc(u_int rate)
{
	/*
	 * The following formula is derived from the information in
	 * the ES1887 data sheet, based on a roll-off frequency of
	 * 87%.
	 */
	return (256 - 200279L / rate);
}


/*
 * Return the status of the DSP.
 */
u_char
ess_get_dsp_status(struct ess_softc *sc)
{
	return (EREAD1(sc->sc_iot, sc->sc_ioh, ESS_DSP_RW_STATUS));
}


/*
 * Return the read status of the DSP:	1 -> DSP ready for reading
 *					0 -> DSP not ready for reading
 */
u_char
ess_dsp_read_ready(struct ess_softc *sc)
{
	return ((ess_get_dsp_status(sc) & ESS_DSP_READ_READY) ? 1 : 0);
}


/*
 * Return the write status of the DSP:	1 -> DSP ready for writing
 *					0 -> DSP not ready for writing
 */
u_char
ess_dsp_write_ready(struct ess_softc *sc)
{
	return ((ess_get_dsp_status(sc) & ESS_DSP_WRITE_BUSY) ? 0 : 1);
}


/*
 * Read a byte from the DSP.
 */
int
ess_rdsp(struct ess_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	for (i = ESS_READ_TIMEOUT; i > 0; --i) {
		if (ess_dsp_read_ready(sc)) {
			i = EREAD1(iot, ioh, ESS_DSP_READ);
			DPRINTFN(8,("ess_rdsp() = 0x%02x\n", i));
			return i;
		} else
			delay(10);
	}

	DPRINTF(("ess_rdsp: timed out\n"));
	return (-1);
}

/*
 * Write a byte to the DSP.
 */
int
ess_wdsp(struct ess_softc *sc, u_char v)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	int i;

	DPRINTFN(8,("ess_wdsp(0x%02x)\n", v));

	for (i = ESS_WRITE_TIMEOUT; i > 0; --i) {
		if (ess_dsp_write_ready(sc)) {
			EWRITE1(iot, ioh, ESS_DSP_WRITE, v);
			return (0);
		} else
			delay(10);
	}

	DPRINTF(("ess_wdsp(0x%02x): timed out\n", v));
	return (-1);
}

/*
 * Write a value to one of the ESS extended registers.
 */
int
ess_write_x_reg(struct ess_softc *sc, u_char reg, u_char val)
{
	int error;

	DPRINTFN(2,("ess_write_x_reg: %02x=%02x\n", reg, val));
	if ((error = ess_wdsp(sc, reg)) == 0)
		error = ess_wdsp(sc, val);

	return error;
}

/*
 * Read the value of one of the ESS extended registers.
 */
u_char
ess_read_x_reg(struct ess_softc *sc, u_char reg)
{
	int error;
	int val;

	if ((error = ess_wdsp(sc, 0xC0)) == 0)
		error = ess_wdsp(sc, reg);
	if (error)
		DPRINTF(("Error reading extended register 0x%02x\n", reg));
/* REVISIT: what if an error is returned above? */
	val = ess_rdsp(sc);
	DPRINTFN(2,("ess_read_x_reg: %02x=%02x\n", reg, val));
	return val;
}

void
ess_clear_xreg_bits(struct ess_softc *sc, u_char reg, u_char mask)
{
	if (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) & ~mask) == -1)
		DPRINTF(("Error clearing bits in extended register 0x%02x\n",
			 reg));
}

void
ess_set_xreg_bits(struct ess_softc *sc, u_char reg, u_char mask)
{
	if (ess_write_x_reg(sc, reg, ess_read_x_reg(sc, reg) | mask) == -1)
		DPRINTF(("Error setting bits in extended register 0x%02x\n",
			 reg));
}


/*
 * Write a value to one of the ESS mixer registers.
 */
void
ess_write_mix_reg(struct ess_softc *sc, u_char reg, u_char val)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	DPRINTFN(2,("ess_write_mix_reg: %x=%x\n", reg, val));

	mtx_enter(&audio_lock);
	EWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);
	EWRITE1(iot, ioh, ESS_MIX_REG_DATA, val);
	mtx_leave(&audio_lock);
}

/*
 * Read the value of one of the ESS mixer registers.
 */
u_char
ess_read_mix_reg(struct ess_softc *sc, u_char reg)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;
	u_char val;

	mtx_enter(&audio_lock);
	EWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);
	val = EREAD1(iot, ioh, ESS_MIX_REG_DATA);
	mtx_leave(&audio_lock);

	DPRINTFN(2,("ess_read_mix_reg: %x=%x\n", reg, val));
	return val;
}

void
ess_clear_mreg_bits(struct ess_softc *sc, u_char reg, u_char mask)
{
	ess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) & ~mask);
}

void
ess_set_mreg_bits(struct ess_softc *sc, u_char reg, u_char mask)
{
	ess_write_mix_reg(sc, reg, ess_read_mix_reg(sc, reg) | mask);
}

void
ess_read_multi_mix_reg(struct ess_softc *sc, u_char reg, u_int8_t *datap,
    bus_size_t count)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	mtx_enter(&audio_lock);
	EWRITE1(iot, ioh, ESS_MIX_REG_SELECT, reg);
	bus_space_read_multi_1(iot, ioh, ESS_MIX_REG_DATA, datap, count);
	mtx_leave(&audio_lock);
}
@


1.23
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.21 2015/05/11 06:46:21 ratchov Exp $	*/
a120 1
int	ess_getdev(void *, struct audio_device *);
a141 2
int	ess_getdev(void *, struct audio_device *);

a195 6
struct audio_device ess_device = {
	"ESS Technology",
	"x",
	"ess"
};

a212 1
	ess_getdev,
a237 1
	ess_getdev,
a976 5
	snprintf(ess_device.name, sizeof ess_device.name, "ES%s",
	    essmodel[sc->sc_model]);
	snprintf(ess_device.version, sizeof ess_device.version, "0x%04x",
	    sc->sc_version);

a1062 7
	return (0);
}

int
ess_getdev(void *addr, struct audio_device *retp)
{
	*retp = ess_device;
@


1.22
log
@Reimplement the audio driver in a simpler way, removing unused/unusable
functionality. Same API and ABI except for the removed bits and no
behaviour change for programs using libsndio. With help from armani@@
and mpi@@, thanks.
@
text
@a121 3
int	ess_drain(void *);

int	ess_query_encoding(void *, struct audio_encoding *);
a150 1
paddr_t	ess_mappage(void *, void *, off_t, int);
a211 2
	ess_drain,
	ess_query_encoding,
a229 1
	ess_mappage,
d232 1
a232 2
	ess_audio1_trigger_input,
	NULL
a237 2
	ess_drain,
	ess_query_encoding,
a255 1
	ess_mappage,
d258 1
a258 2
	ess_audio1_trigger_input,
	NULL
a1064 11
/*
 * Wait for FIFO to drain, and analog section to settle.
 * XXX should check FIFO empty bit.
 */
int
ess_drain(void *addr)
{
	tsleep(addr, PWAIT | PCATCH, "essdr", hz/20); /* XXX */
	return (0);
}

a1089 39
ess_query_encoding(void *addr, struct audio_encoding *fp)
{
	/*struct ess_softc *sc = addr;*/

	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return EINVAL;
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

int
a2094 6
}

paddr_t
ess_mappage(void *addr, void *mem, off_t off, int prot)
{
	return (isa_mappage(mem, off, prot));
@


1.21
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.20 2014/09/14 14:17:25 jsg Exp $	*/
d113 3
d935 2
a936 2
	pparams = audio_default;
	rparams = audio_default;
@


1.20
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.19 2013/11/15 16:46:27 brad Exp $	*/
a83 2
#include <dev/auconv.h>
#include <dev/mulaw.h>
a1121 12
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
d1127 1
a1127 1
	case 4:
d1133 1
a1133 1
	case 5:
a1138 12
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
a1193 2
		p->factor = 1;
		p->sw_code = 0;
d1197 2
a1198 2
			if (p->precision == 16)
				p->sw_code = swap_bytes;
a1202 14
		case AUDIO_ENCODING_ULAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = mulaw_to_ulinear16_le;
			} else
				p->sw_code = ulinear8_to_mulaw;
			break;
		case AUDIO_ENCODING_ALAW:
			if (mode == AUMODE_PLAY) {
				p->factor = 2;
				p->sw_code = alaw_to_ulinear16_le;
			} else
				p->sw_code = ulinear8_to_alaw;
			break;
d1262 1
a1262 1
	if (param->precision * param->factor == 16)
d1326 1
a1326 1
	if (param->precision * param->factor == 16)
d1401 1
a1401 1
	if (param->precision * param->factor == 16)
@


1.19
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.18 2013/05/24 07:58:46 ratchov Exp $	*/
a74 1
#include <sys/proc.h>
@


1.18
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.17 2013/05/15 08:29:24 ratchov Exp $	*/
d278 1
a278 2
ess_printsc(sc)
	struct ess_softc *sc;
d303 1
a303 2
ess_dump_mixer(sc)
	struct ess_softc *sc;
d353 1
a353 2
ess_config_addr(sc)
	struct ess_softc *sc;
d446 1
a446 2
ess_config_irq(sc)
	struct ess_softc *sc;
d535 1
a535 2
ess_config_drq(sc)
	struct ess_softc *sc;
d598 1
a598 2
ess_setup(sc)
	struct ess_softc *sc;
a599 1

d615 1
a615 2
ess_identify(sc)
	struct ess_softc *sc;
d774 1
a774 3
ess_setup_sc(sc, doinit)
	struct ess_softc *sc;
	int doinit;
d795 1
a795 2
essmatch(sc)
	struct ess_softc *sc;
d877 1
a877 2
essattach(sc)
	struct ess_softc *sc;
d1026 1
a1026 3
ess_open(addr, flags)
	void *addr;
	int flags;
d1045 1
a1045 2
ess_1788_close(addr)
	void *addr;
d1061 1
a1061 2
ess_1888_close(addr)
	void *addr;
d1082 1
a1082 2
ess_drain(addr)
	void *addr;
d1090 1
a1090 3
ess_speaker_ctl(addr, newstate)
	void *addr;
	int newstate;
d1106 1
a1106 3
ess_getdev(addr, retp)
	void *addr;
	struct audio_device *retp;
d1113 1
a1113 3
ess_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d1176 2
a1177 4
ess_set_params(addr, setmode, usemode, play, rec)
	void *addr;
	int setmode, usemode;
	struct audio_params *play, *rec;
d1270 2
a1271 7
ess_audio1_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1344 2
a1345 7
ess_audio2_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1409 2
a1410 7
ess_audio1_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr)(void *);
	void *arg;
	struct audio_params *param;
d1483 1
a1483 2
ess_audio1_halt(addr)
	void *addr;
d1502 1
a1502 2
ess_audio2_halt(addr)
	void *addr;
d1522 1
a1522 2
ess_audio1_intr(arg)
	void *arg;
d1551 1
a1551 2
ess_audio2_intr(arg)
	void *arg;
d1581 1
a1581 2
ess_audio1_poll(addr)
	void *addr;
d1612 1
a1612 2
ess_audio2_poll(addr)
	void *addr;
d1643 1
a1643 3
ess_round_blocksize(addr, blk)
	void *addr;
	int blk;
d1649 1
a1649 3
ess_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1788 1
a1788 3
ess_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1876 1
a1876 3
ess_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d2173 1
a2173 5
ess_malloc(addr, direction, size, pool, flags)
	void *addr;
	int direction;
	size_t size;
	int pool, flags;
d2186 1
a2186 4
ess_free(addr, ptr, pool)
	void *addr;
	void *ptr;
	int pool;
d2192 1
a2192 4
ess_round_buffersize(addr, direction, size)
	void *addr;
	int direction;
	size_t size;
d2200 1
a2200 5
ess_mappage(addr, mem, off, prot)
	void *addr;
	void *mem;
	off_t off;
	int prot;
d2206 1
a2206 2
ess_1788_get_props(addr)
	void *addr;
a2207 1

d2212 1
a2212 2
ess_1888_get_props(addr)
	void *addr;
a2213 1

d2227 1
a2227 2
ess_reset(sc)
	struct ess_softc *sc;
d2345 1
a2345 3
ess_set_in_port(sc, ord)
	struct ess_softc *sc;
	int ord;
d2376 1
a2376 3
ess_set_in_ports(sc, mask)
	struct ess_softc *sc;
	int mask;
d2414 1
a2414 2
ess_speaker_on(sc)
	struct ess_softc *sc;
d2421 1
a2421 2
ess_speaker_off(sc)
	struct ess_softc *sc;
d2431 1
a2431 2
ess_srtotc(rate)
	u_int rate;
d2449 1
a2449 2
ess_srtofc(rate)
	u_int rate;
d2464 1
a2464 2
ess_get_dsp_status(sc)
	struct ess_softc *sc;
d2475 1
a2475 2
ess_dsp_read_ready(sc)
	struct ess_softc *sc;
d2486 1
a2486 2
ess_dsp_write_ready(sc)
	struct ess_softc *sc;
d2496 1
a2496 2
ess_rdsp(sc)
	struct ess_softc *sc;
d2519 1
a2519 3
ess_wdsp(sc, v)
	struct ess_softc *sc;
	u_char v;
d2543 1
a2543 4
ess_write_x_reg(sc, reg, val)
	struct ess_softc *sc;
	u_char reg;
	u_char val;
d2558 1
a2558 3
ess_read_x_reg(sc, reg)
	struct ess_softc *sc;
	u_char reg;
d2574 1
a2574 4
ess_clear_xreg_bits(sc, reg, mask)
	struct ess_softc *sc;
	u_char reg;
	u_char mask;
d2582 1
a2582 4
ess_set_xreg_bits(sc, reg, mask)
	struct ess_softc *sc;
	u_char reg;
	u_char mask;
d2594 1
a2594 4
ess_write_mix_reg(sc, reg, val)
	struct ess_softc *sc;
	u_char reg;
	u_char val;
d2611 1
a2611 3
ess_read_mix_reg(sc, reg)
	struct ess_softc *sc;
	u_char reg;
d2627 1
a2627 4
ess_clear_mreg_bits(sc, reg, mask)
	struct ess_softc *sc;
	u_char reg;
	u_char mask;
d2633 1
a2633 4
ess_set_mreg_bits(sc, reg, mask)
	struct ess_softc *sc;
	u_char reg;
	u_char mask;
d2639 2
a2640 5
ess_read_multi_mix_reg(sc, reg, datap, count)
	struct ess_softc *sc;
	u_char reg;
	u_int8_t *datap;
	bus_size_t count;
@


1.17
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.16 2010/07/15 03:43:11 jakemsr Exp $	*/
d907 2
a908 1
		    sc->sc_audio1.irq, sc->sc_audio1.ist, IPL_AUDIO,
d925 2
a926 1
			    sc->sc_audio2.irq, sc->sc_audio2.ist, IPL_AUDIO,
@


1.16
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.15 2010/06/30 20:39:02 blambert Exp $	*/
d1304 1
d1367 1
a1367 1

d1383 1
d1437 1
a1437 1

d1453 1
d1516 1
a1516 1

d1527 1
a1527 1

d1536 1
a1536 1

d1547 1
a1547 1

d1557 1
a1557 1

d1570 1
d1573 2
a1574 1
	if ((reg & ESS_DSP_READ_OFLOW) == 0)
d1576 1
d1583 1
d1585 2
a1586 1
	} else
d1588 1
d1600 1
d1603 2
a1604 1
	if ((reg & ESS_AUDIO2_CTRL2_IRQ_LATCH) == 0)
d1606 1
d1614 1
d1616 2
a1617 1
	} else
d1619 1
d1632 1
a1649 1

d1651 1
d1664 1
a1681 1

d1683 1
a2696 1
	int s;
d2700 1
a2700 1
	s = splaudio();
d2703 1
a2703 1
	splx(s);
a2715 1
	int s;
d2718 1
a2718 1
	s = splaudio();
d2721 1
a2721 1
	splx(s);
a2753 1
	int s;
d2755 1
a2755 1
	s = splaudio();
d2758 1
a2758 1
	splx(s);
@


1.15
log
@timeout_add -> timeout_add_msec

ok jakemsr@@, who promises to deal with any fallout, because he's a stand-up guy
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.14 2008/10/25 22:30:43 jakemsr Exp $	*/
d1144 1
a1144 1
		return (0);
d1150 1
a1150 1
		return (0);
d1156 1
a1156 1
		return (0);
d1162 1
a1162 1
		return (0);
d1168 1
a1168 1
		return (0);
d1174 1
a1174 1
		return (0);
d1180 1
a1180 1
		return (0);
d1186 1
a1186 1
		return (0);
d1190 3
d1272 2
@


1.14
log
@
audio(9) says low level drivers are allowed to change the requested
values of the audio_params structure during AUDIO_SETINFO if the
hardware cannot be set to exactly the requested mode.

some drivers do this sometimes.  others always return EINVAL if there
isn't an exact match.

be more consistent.  only return EINVAL if an absurd parameter was
requested, otherwise return a supported set of parameters, as close
as possible to what was requested.

with/ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.13 2008/04/21 00:32:42 jakemsr Exp $	*/
d1313 1
a1313 1
		timeout_add(&sc->sc_tmo1, hz/30);
d1391 1
a1391 1
		timeout_add(&sc->sc_tmo2, hz/30);
d1460 1
a1460 1
		timeout_add(&sc->sc_tmo1, hz/30);
d1630 1
a1630 1
	timeout_add(&sc->sc_tmo1, hz/30);
d1661 1
a1661 1
	timeout_add(&sc->sc_tmo2, hz/30);
@


1.13
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.12 2007/11/05 00:17:28 jakemsr Exp $	*/
d1232 8
a1239 5
		if (p->sample_rate < ESS_MINRATE ||
		    p->sample_rate > ESS_MAXRATE ||
		    (p->precision != 8 && p->precision != 16) ||
		    (p->channels != 1 && p->channels != 2))
			return (EINVAL);
@


1.12
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.11 2006/02/22 19:43:42 miod Exp $	*/
d240 1
d270 1
@


1.11
log
@Fix size in snprintf() call; previous value turned out to be correct by luck.
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.10 2005/04/15 13:05:14 mickey Exp $	*/
d1250 1
a1250 1
				p->sw_code = mulaw_to_ulinear16;
d1257 1
a1257 1
				p->sw_code = alaw_to_ulinear16;
@


1.10
log
@make sure aligment does not return zero block size
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.9 2003/04/27 11:22:53 ho Exp $	*/
d1010 1
a1010 1
	snprintf(ess_device.version, sizeof ess_device.name, "0x%04x",
@


1.9
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.8 2002/03/14 03:16:05 millert Exp $	*/
d1664 1
a1664 1
	return (blk & -8);	/* round for max DMA size */
@


1.8
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.7 2002/03/14 01:26:56 millert Exp $	*/
d1008 4
a1011 2
	sprintf(ess_device.name, "ES%s", essmodel[sc->sc_model]);
	sprintf(ess_device.version, "0x%04x", sc->sc_version);
d1138 1
a1138 1
		strcpy(fp->name, AudioEulinear);
d1144 1
a1144 1
		strcpy(fp->name, AudioEmulaw);
d1150 1
a1150 1
		strcpy(fp->name, AudioEalaw);
d1156 1
a1156 1
		strcpy(fp->name, AudioEslinear);
d1162 1
a1162 1
		strcpy(fp->name, AudioEslinear_le);
d1168 1
a1168 1
		strcpy(fp->name, AudioEulinear_le);
d1174 1
a1174 1
		strcpy(fp->name, AudioEslinear_be);
d1180 1
a1180 1
		strcpy(fp->name, AudioEulinear_be);
d1921 1
a1921 1
		strcpy(dip->label.name, AudioNdac);
d1924 2
a1925 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1935 2
a1936 1
		strcpy(dip->label.name, AudioNmicrophone);
d1939 2
a1940 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1946 1
a1946 1
		strcpy(dip->label.name, AudioNline);
d1949 2
a1950 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1956 2
a1957 1
		strcpy(dip->label.name, AudioNfmsynth);
d1960 2
a1961 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1967 1
a1967 1
		strcpy(dip->label.name, AudioNcd);
d1970 2
a1971 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1977 1
a1977 1
		strcpy(dip->label.name, "auxb");
d1980 2
a1981 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d1987 1
a1987 1
		strcpy(dip->label.name, AudioCinputs);
d1994 1
a1994 1
		strcpy(dip->label.name, AudioNmaster);
d1997 2
a1998 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2004 1
a2004 1
		strcpy(dip->label.name, "pc_speaker");
d2007 2
a2008 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2014 1
a2014 1
		strcpy(dip->label.name, AudioCoutputs);
d2021 1
a2021 1
		strcpy(dip->label.name, AudioNrecord);
d2024 2
a2025 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2031 1
a2031 1
		strcpy(dip->label.name, AudioNsource);
d2044 3
a2046 1
			strcpy(dip->un.e.member[0].label.name, AudioNmicrophone);
d2048 2
a2049 1
			strcpy(dip->un.e.member[1].label.name, AudioNline);
d2051 2
a2052 1
			strcpy(dip->un.e.member[2].label.name, AudioNcd);
d2054 2
a2055 1
			strcpy(dip->un.e.member[3].label.name, AudioNmixerout);
d2060 2
a2061 1
			strcpy(dip->un.s.member[0].label.name, AudioNdac);
d2063 3
a2065 1
			strcpy(dip->un.s.member[1].label.name, AudioNmicrophone);
d2067 2
a2068 1
			strcpy(dip->un.s.member[2].label.name, AudioNline);
d2070 2
a2071 1
			strcpy(dip->un.s.member[3].label.name, AudioNfmsynth);
d2073 2
a2074 1
			strcpy(dip->un.s.member[4].label.name, AudioNcd);
d2076 2
a2077 1
			strcpy(dip->un.s.member[5].label.name, "auxb");
d2085 1
a2085 1
		strcpy(dip->label.name, AudioCrecord);
d2091 1
a2091 1
		strcpy(dip->label.name, AudioNmute);
d2095 2
a2096 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2098 2
a2099 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d2106 2
a2107 1
		strcpy(dip->label.name, AudioCmonitor);
d2119 1
a2119 1
		strcpy(dip->label.name, AudioNdac);
d2122 2
a2123 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2129 2
a2130 1
		strcpy(dip->label.name, AudioNmicrophone);
d2133 2
a2134 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2140 1
a2140 1
		strcpy(dip->label.name, AudioNline);
d2143 2
a2144 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2150 2
a2151 1
		strcpy(dip->label.name, AudioNfmsynth);
d2154 2
a2155 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2161 1
a2161 1
		strcpy(dip->label.name, AudioNcd);
d2164 2
a2165 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2171 1
a2171 1
		strcpy(dip->label.name, "auxb");
d2174 2
a2175 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d2182 1
a2182 1
		strcpy(dip->label.name, AudioNpreamp);
d2185 2
a2186 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d2188 2
a2189 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
@


1.7
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.6 2002/01/20 19:56:53 ericj Exp $	*/
d131 6
a136 6
int	ess_audio1_trigger_output __P((void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *));
int	ess_audio2_trigger_output __P((void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *));
int	ess_audio1_trigger_input __P((void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *));
@


1.6
log
@
make all audio drivers use the new allocm and round_buffersize decl's.
will ease porting, and generally cleans up a bit
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.5 2001/10/31 11:00:24 art Exp $	*/
d116 1
a116 1
int	ess_setup_sc __P((struct ess_softc *, int));
d118 5
a122 5
int	ess_open __P((void *, int));
void	ess_1788_close __P((void *));
void	ess_1888_close __P((void *));
int	ess_getdev __P((void *, struct audio_device *));
int	ess_drain __P((void *));
d124 1
a124 1
int	ess_query_encoding __P((void *, struct audio_encoding *));
d126 2
a127 2
int	ess_set_params __P((void *, int, int, struct audio_params *,
	    struct audio_params *));
d129 1
a129 1
int	ess_round_blocksize __P((void *, int));
d137 53
a189 53
int	ess_audio1_halt __P((void *));
int	ess_audio2_halt __P((void *));
int	ess_audio1_intr __P((void *));
int	ess_audio2_intr __P((void *));
void	ess_audio1_poll __P((void *));
void	ess_audio2_poll __P((void *));

int	ess_speaker_ctl __P((void *, int));

int	ess_getdev __P((void *, struct audio_device *));

int	ess_set_port __P((void *, mixer_ctrl_t *));
int	ess_get_port __P((void *, mixer_ctrl_t *));

void   *ess_malloc __P((void *, int, size_t, int, int));
void	ess_free __P((void *, void *, int));
size_t	ess_round_buffersize __P((void *, int, size_t));
paddr_t	ess_mappage __P((void *, void *, off_t, int));


int	ess_query_devinfo __P((void *, mixer_devinfo_t *));
int	ess_1788_get_props __P((void *));
int	ess_1888_get_props __P((void *));

void	ess_speaker_on __P((struct ess_softc *));
void	ess_speaker_off __P((struct ess_softc *));

int	ess_config_addr __P((struct ess_softc *));
void	ess_config_irq __P((struct ess_softc *));
void	ess_config_drq __P((struct ess_softc *));
void	ess_setup __P((struct ess_softc *));
int	ess_identify __P((struct ess_softc *));

int	ess_reset __P((struct ess_softc *));
void	ess_set_gain __P((struct ess_softc *, int, int));
int	ess_set_in_port __P((struct ess_softc *, int));
int	ess_set_in_ports __P((struct ess_softc *, int));
u_int	ess_srtotc __P((u_int));
u_int	ess_srtofc __P((u_int));
u_char	ess_get_dsp_status __P((struct ess_softc *));
u_char	ess_dsp_read_ready __P((struct ess_softc *));
u_char	ess_dsp_write_ready __P((struct ess_softc *));
int	ess_rdsp __P((struct ess_softc *));
int	ess_wdsp __P((struct ess_softc *, u_char));
u_char	ess_read_x_reg __P((struct ess_softc *, u_char));
int	ess_write_x_reg __P((struct ess_softc *, u_char, u_char));
void	ess_clear_xreg_bits __P((struct ess_softc *, u_char, u_char));
void	ess_set_xreg_bits __P((struct ess_softc *, u_char, u_char));
u_char	ess_read_mix_reg __P((struct ess_softc *, u_char));
void	ess_write_mix_reg __P((struct ess_softc *, u_char, u_char));
void	ess_clear_mreg_bits __P((struct ess_softc *, u_char, u_char));
void	ess_set_mreg_bits __P((struct ess_softc *, u_char, u_char));
void	ess_read_multi_mix_reg __P((struct ess_softc *, u_char, u_int8_t *, bus_size_t));
d272 2
a273 2
void ess_printsc __P((struct ess_softc *));
void ess_dump_mixer __P((struct ess_softc *));
d1285 1
a1285 1
	void (*intr) __P((void *));
d1363 1
a1363 1
	void (*intr) __P((void *));
d1432 1
a1432 1
	void (*intr) __P((void *));
@


1.5
log
@Change the audio_hm_if->mappage interface to return paddr_t and take off_t
as the mmap offset.
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.4 2001/07/18 21:37:52 deraadt Exp $	*/
d151 1
a151 1
void   *ess_malloc __P((void *, unsigned long, int, int));
d153 1
a153 1
unsigned long ess_round_buffersize __P((void *, unsigned long));
d2160 1
a2160 1
ess_malloc(addr, size, pool, flags)
d2162 2
a2163 1
	unsigned long size;
d2185 2
a2186 2
unsigned long
ess_round_buffersize(addr, size)
d2188 2
a2189 1
	unsigned long size;
@


1.5.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.6 2002/01/20 19:56:53 ericj Exp $	*/
d151 1
a151 1
void   *ess_malloc __P((void *, int, size_t, int, int));
d153 1
a153 1
size_t	ess_round_buffersize __P((void *, int, size_t));
d2160 1
a2160 1
ess_malloc(addr, direction, size, pool, flags)
d2162 1
a2162 2
	int direction;
	size_t size;
d2184 2
a2185 2
size_t
ess_round_buffersize(addr, direction, size)
d2187 1
a2187 2
	int direction;
	size_t size;
@


1.5.2.2
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.5.2.1 2002/01/31 22:55:32 niklas Exp $	*/
d116 1
a116 1
int	ess_setup_sc(struct ess_softc *, int);
d118 72
a189 72
int	ess_open(void *, int);
void	ess_1788_close(void *);
void	ess_1888_close(void *);
int	ess_getdev(void *, struct audio_device *);
int	ess_drain(void *);

int	ess_query_encoding(void *, struct audio_encoding *);

int	ess_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);

int	ess_round_blocksize(void *, int);

int	ess_audio1_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio2_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_trigger_input(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_halt(void *);
int	ess_audio2_halt(void *);
int	ess_audio1_intr(void *);
int	ess_audio2_intr(void *);
void	ess_audio1_poll(void *);
void	ess_audio2_poll(void *);

int	ess_speaker_ctl(void *, int);

int	ess_getdev(void *, struct audio_device *);

int	ess_set_port(void *, mixer_ctrl_t *);
int	ess_get_port(void *, mixer_ctrl_t *);

void   *ess_malloc(void *, int, size_t, int, int);
void	ess_free(void *, void *, int);
size_t	ess_round_buffersize(void *, int, size_t);
paddr_t	ess_mappage(void *, void *, off_t, int);


int	ess_query_devinfo(void *, mixer_devinfo_t *);
int	ess_1788_get_props(void *);
int	ess_1888_get_props(void *);

void	ess_speaker_on(struct ess_softc *);
void	ess_speaker_off(struct ess_softc *);

int	ess_config_addr(struct ess_softc *);
void	ess_config_irq(struct ess_softc *);
void	ess_config_drq(struct ess_softc *);
void	ess_setup(struct ess_softc *);
int	ess_identify(struct ess_softc *);

int	ess_reset(struct ess_softc *);
void	ess_set_gain(struct ess_softc *, int, int);
int	ess_set_in_port(struct ess_softc *, int);
int	ess_set_in_ports(struct ess_softc *, int);
u_int	ess_srtotc(u_int);
u_int	ess_srtofc(u_int);
u_char	ess_get_dsp_status(struct ess_softc *);
u_char	ess_dsp_read_ready(struct ess_softc *);
u_char	ess_dsp_write_ready(struct ess_softc *);
int	ess_rdsp(struct ess_softc *);
int	ess_wdsp(struct ess_softc *, u_char);
u_char	ess_read_x_reg(struct ess_softc *, u_char);
int	ess_write_x_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_xreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_xreg_bits(struct ess_softc *, u_char, u_char);
u_char	ess_read_mix_reg(struct ess_softc *, u_char);
void	ess_write_mix_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_read_multi_mix_reg(struct ess_softc *, u_char, u_int8_t *, bus_size_t);
d272 2
a273 2
void ess_printsc(struct ess_softc *);
void ess_dump_mixer(struct ess_softc *);
d1285 1
a1285 1
	void (*intr)(void *);
d1363 1
a1363 1
	void (*intr)(void *);
d1432 1
a1432 1
	void (*intr)(void *);
@


1.5.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d1008 2
a1009 4
	snprintf(ess_device.name, sizeof ess_device.name, "ES%s",
	    essmodel[sc->sc_model]);
	snprintf(ess_device.version, sizeof ess_device.name, "0x%04x",
	    sc->sc_version);
d1136 1
a1136 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1142 1
a1142 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1148 1
a1148 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1154 1
a1154 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1160 1
a1160 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1166 1
a1166 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1172 1
a1172 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1178 1
a1178 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1919 1
a1919 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1922 1
a1922 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1932 1
a1932 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1935 1
a1935 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1941 1
a1941 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1944 1
a1944 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1950 1
a1950 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1953 1
a1953 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1959 1
a1959 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1962 1
a1962 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1968 1
a1968 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1971 1
a1971 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1977 1
a1977 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1984 1
a1984 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1987 1
a1987 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1993 1
a1993 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d1996 1
a1996 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2002 1
a2002 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d2009 1
a2009 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d2012 1
a2012 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2018 1
a2018 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d2031 1
a2031 3
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
d2033 1
a2033 2
			strlcpy(dip->un.e.member[1].label.name, AudioNline,
			    sizeof dip->un.e.member[1].label.name);
d2035 1
a2035 2
			strlcpy(dip->un.e.member[2].label.name, AudioNcd,
			    sizeof dip->un.e.member[2].label.name);
d2037 1
a2037 2
			strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
			    sizeof dip->un.e.member[3].label.name);
d2042 1
a2042 2
			strlcpy(dip->un.s.member[0].label.name, AudioNdac,
			    sizeof dip->un.e.member[0].label.name);
d2044 1
a2044 3
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[1].label.name);
d2046 1
a2046 2
			strlcpy(dip->un.s.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
d2048 1
a2048 2
			strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
			    sizeof dip->un.e.member[3].label.name);
d2050 1
a2050 2
			strlcpy(dip->un.s.member[4].label.name, AudioNcd,
			    sizeof dip->un.e.member[4].label.name);
d2052 1
a2052 2
			strlcpy(dip->un.s.member[5].label.name, "auxb",
			    sizeof dip->un.e.member[5].label.name);
d2060 1
a2060 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d2066 1
a2066 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d2070 1
a2070 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2072 1
a2072 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d2079 1
a2079 2
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
d2091 1
a2091 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d2094 1
a2094 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2100 1
a2100 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d2103 1
a2103 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2109 1
a2109 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d2112 1
a2112 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2118 1
a2118 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d2121 1
a2121 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2127 1
a2127 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d2130 1
a2130 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2136 1
a2136 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d2139 1
a2139 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2146 1
a2146 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d2149 1
a2149 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2151 1
a2151 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.4
log
@do not reset the volume after playback; landy@@alumni.caltech.edu
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.3 2001/01/29 06:27:59 mickey Exp $	*/
d154 1
a154 1
int	ess_mappage __P((void *, void *, int, int));
d2194 1
a2194 1
int
d2198 1
a2198 1
	int off;
@


1.3
log
@new timeouts; spaces
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.2 1999/09/30 22:13:52 kstailey Exp $	*/
d2425 2
a2426 3
	/* Disable mute on left- and right-master volume. */
	ess_clear_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);
	ess_clear_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);
d2433 2
a2434 3
	/* Enable mute on left- and right-master volume. */
	ess_set_mreg_bits(sc, ESS_MREG_VOLUME_LEFT, ESS_VOLUME_MUTE);
	ess_set_mreg_bits(sc, ESS_MREG_VOLUME_RIGHT, ESS_VOLUME_MUTE);
@


1.2
log
@Sync w/NetBSD.  Add support for ES18[67][89] - Nonaka Kimihiro + muting control fix
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.1 1999/06/22 16:20:03 niklas Exp $	*/
d48 2
a49 2
**      This module contains the device driver for the ESS
**      Technologies 1888/1887/888 sound chip. The code in sbdsp.c was
d57 1
a57 1
**  CREATION DATE:  
d77 1
d123 1
a123 1
	
d126 1
a126 1
int	ess_set_params __P((void *, int, int, struct audio_params *, 
d147 1
a147 1
	
d280 1
a280 1
    
d419 1
a419 1
	
d477 1
a477 1
			printf("ess_config_irq: configured irq %d not supported for Audio 1\n", 
d513 1
a513 1
			printf("ess: configured irq %d not supported for Audio 1\n", 
d526 1
a526 1
		ess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 
d530 1
a530 1
		ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 
d558 1
a558 1
		printf("ess_config_drq: configured dma chan %d not supported for Audio 1\n", 
d586 1
a586 1
		printf("ess_config_drq: configured dma chan %d not supported for Audio 2\n", 
d593 1
a593 1
	ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2, 
d597 2
a598 2
/* 
 * Set up registers after a reset. 
d615 1
a615 1
 * sheet. 
d664 1
a664 1
	
d666 1
a666 1
	
d679 1
a679 1
	 * 3. Verify we can change the value of mixer register 
d688 1
a688 1
	
d717 1
a717 1
	
d719 1
a719 1
	
d766 1
a766 1
		
d815 1
a815 1
	if (ess_setup_sc(sc, 1)) 
d843 2
a844 2
	
	/* 
d899 1
a899 1
	printf(": ESS Technology ES%s [version 0x%04x]\n", 
d936 4
a939 1
	/* 
d1039 1
a1039 1
    
d1221 1
a1221 1
	for (mode = AUMODE_RECORD; mode != -1; 
d1306 1
a1306 1
		timeout(ess_audio1_poll, sc, hz/30);
d1336 1
a1336 1
	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, 
d1349 1
a1349 1
  	ess_wdsp(sc, ESS_ACMD_ENABLE_SPKR);
d1384 1
a1384 1
		timeout(ess_audio2_poll, sc, hz/30);
d1403 1
a1403 1
	isa_dmastart(sc->sc_isa, sc->sc_audio2.drq, start, 
d1453 1
a1453 1
		timeout(ess_audio1_poll, sc, hz/30);
d1483 1
a1483 1
	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start, 
d1496 1
a1496 1
  	ess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);
d1518 1
a1518 1
			untimeout(ess_audio1_poll, sc);
d1539 1
a1539 1
			untimeout(ess_audio2_poll, sc);
d1623 1
a1623 1
	timeout(ess_audio1_poll, sc, hz/30);
d1654 1
a1654 1
	timeout(ess_audio2_poll, sc, hz/30);
d1672 1
a1672 1
    
d1812 1
a1812 1
    
d1826 1
a1826 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
d1830 1
a1830 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 
d1832 1
a1832 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 
d1844 1
a1844 1
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
d1873 1
a1873 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = 
d1877 1
a1877 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = 
d1879 1
a1879 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = 
d1903 1
a1903 1
	DPRINTFN(5,("ess_query_devinfo: model=%d index=%d\n", 
d2023 1
a2023 1
			 * have one mixer. 
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.3 2001/01/29 06:27:59 mickey Exp $	*/
d48 2
a49 2
**	This module contains the device driver for the ESS
**	Technologies 1888/1887/888 sound chip. The code in sbdsp.c was
d57 1
a57 1
**  CREATION DATE:
a76 1
#include <sys/timeout.h>
d122 1
a122 1

d125 1
a125 1
int	ess_set_params __P((void *, int, int, struct audio_params *,
d146 1
a146 1

d279 1
a279 1

d418 1
a418 1

d476 1
a476 1
			printf("ess_config_irq: configured irq %d not supported for Audio 1\n",
d512 1
a512 1
			printf("ess: configured irq %d not supported for Audio 1\n",
d525 1
a525 1
		ess_clear_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
d529 1
a529 1
		ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
d557 1
a557 1
		printf("ess_config_drq: configured dma chan %d not supported for Audio 1\n",
d585 1
a585 1
		printf("ess_config_drq: configured dma chan %d not supported for Audio 2\n",
d592 1
a592 1
	ess_set_mreg_bits(sc, ESS_MREG_AUDIO2_CTRL2,
d596 2
a597 2
/*
 * Set up registers after a reset.
d614 1
a614 1
 * sheet.
d663 1
a663 1

d665 1
a665 1

d678 1
a678 1
	 * 3. Verify we can change the value of mixer register
d687 1
a687 1

d716 1
a716 1

d718 1
a718 1

d765 1
a765 1

d814 1
a814 1
	if (ess_setup_sc(sc, 1))
d842 2
a843 2

	/*
d898 1
a898 1
	printf(": ESS Technology ES%s [version 0x%04x]\n",
d935 1
a935 4
	timeout_set(&sc->sc_tmo1, ess_audio1_poll, sc);
	timeout_set(&sc->sc_tmo2, ess_audio2_poll, sc);

	/*
d1035 1
a1035 1

d1217 1
a1217 1
	for (mode = AUMODE_RECORD; mode != -1;
d1302 1
a1302 1
		timeout_add(&sc->sc_tmo1, hz/30);
d1332 1
a1332 1
	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start,
d1345 1
a1345 1
	ess_wdsp(sc, ESS_ACMD_ENABLE_SPKR);
d1380 1
a1380 1
		timeout_add(&sc->sc_tmo2, hz/30);
d1399 1
a1399 1
	isa_dmastart(sc->sc_isa, sc->sc_audio2.drq, start,
d1449 1
a1449 1
		timeout_add(&sc->sc_tmo1, hz/30);
d1479 1
a1479 1
	isa_dmastart(sc->sc_isa, sc->sc_audio1.drq, start,
d1492 1
a1492 1
	ess_wdsp(sc, ESS_ACMD_DISABLE_SPKR);
d1514 1
a1514 1
			timeout_del(&sc->sc_tmo1);
d1535 1
a1535 1
			timeout_del(&sc->sc_tmo2);
d1619 1
a1619 1
	timeout_add(&sc->sc_tmo1, hz/30);
d1650 1
a1650 1
	timeout_add(&sc->sc_tmo2, hz/30);
d1668 1
a1668 1

d1808 1
a1808 1

d1822 1
a1822 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
d1826 1
a1826 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
d1828 1
a1828 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
d1840 1
a1840 1
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
d1869 1
a1869 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
d1873 1
a1873 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] =
d1875 1
a1875 1
			cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] =
d1899 1
a1899 1
	DPRINTFN(5,("ess_query_devinfo: model=%d index=%d\n",
d2019 1
a2019 1
			 * have one mixer.
@


1.2.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.2.4.1 2001/05/14 22:24:31 niklas Exp $	*/
d2425 3
a2427 2
	/* Unmute the DAC. */
	ess_set_gain(sc, ESS_DAC_PLAY_VOL, 1);
d2434 3
a2436 2
	/* Mute the DAC. */
	ess_set_gain(sc, ESS_DAC_PLAY_VOL, 0);
@


1.2.4.3
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d154 1
a154 1
paddr_t	ess_mappage __P((void *, void *, off_t, int));
d2194 1
a2194 1
paddr_t
d2198 1
a2198 1
	off_t off;
@


1.2.4.4
log
@Merge in trunk
@
text
@d151 1
a151 1
void   *ess_malloc __P((void *, int, size_t, int, int));
d153 1
a153 1
size_t	ess_round_buffersize __P((void *, int, size_t));
d2160 1
a2160 1
ess_malloc(addr, direction, size, pool, flags)
d2162 1
a2162 2
	int direction;
	size_t size;
d2184 2
a2185 2
size_t
ess_round_buffersize(addr, direction, size)
d2187 1
a2187 2
	int direction;
	size_t size;
@


1.2.4.5
log
@Merge in -current from about a week ago
@
text
@d116 1
a116 1
int	ess_setup_sc(struct ess_softc *, int);
d118 72
a189 72
int	ess_open(void *, int);
void	ess_1788_close(void *);
void	ess_1888_close(void *);
int	ess_getdev(void *, struct audio_device *);
int	ess_drain(void *);

int	ess_query_encoding(void *, struct audio_encoding *);

int	ess_set_params(void *, int, int, struct audio_params *,
	    struct audio_params *);

int	ess_round_blocksize(void *, int);

int	ess_audio1_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio2_trigger_output(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_trigger_input(void *, void *, void *, int,
	    void (*)(void *), void *, struct audio_params *);
int	ess_audio1_halt(void *);
int	ess_audio2_halt(void *);
int	ess_audio1_intr(void *);
int	ess_audio2_intr(void *);
void	ess_audio1_poll(void *);
void	ess_audio2_poll(void *);

int	ess_speaker_ctl(void *, int);

int	ess_getdev(void *, struct audio_device *);

int	ess_set_port(void *, mixer_ctrl_t *);
int	ess_get_port(void *, mixer_ctrl_t *);

void   *ess_malloc(void *, int, size_t, int, int);
void	ess_free(void *, void *, int);
size_t	ess_round_buffersize(void *, int, size_t);
paddr_t	ess_mappage(void *, void *, off_t, int);


int	ess_query_devinfo(void *, mixer_devinfo_t *);
int	ess_1788_get_props(void *);
int	ess_1888_get_props(void *);

void	ess_speaker_on(struct ess_softc *);
void	ess_speaker_off(struct ess_softc *);

int	ess_config_addr(struct ess_softc *);
void	ess_config_irq(struct ess_softc *);
void	ess_config_drq(struct ess_softc *);
void	ess_setup(struct ess_softc *);
int	ess_identify(struct ess_softc *);

int	ess_reset(struct ess_softc *);
void	ess_set_gain(struct ess_softc *, int, int);
int	ess_set_in_port(struct ess_softc *, int);
int	ess_set_in_ports(struct ess_softc *, int);
u_int	ess_srtotc(u_int);
u_int	ess_srtofc(u_int);
u_char	ess_get_dsp_status(struct ess_softc *);
u_char	ess_dsp_read_ready(struct ess_softc *);
u_char	ess_dsp_write_ready(struct ess_softc *);
int	ess_rdsp(struct ess_softc *);
int	ess_wdsp(struct ess_softc *, u_char);
u_char	ess_read_x_reg(struct ess_softc *, u_char);
int	ess_write_x_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_xreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_xreg_bits(struct ess_softc *, u_char, u_char);
u_char	ess_read_mix_reg(struct ess_softc *, u_char);
void	ess_write_mix_reg(struct ess_softc *, u_char, u_char);
void	ess_clear_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_set_mreg_bits(struct ess_softc *, u_char, u_char);
void	ess_read_multi_mix_reg(struct ess_softc *, u_char, u_int8_t *, bus_size_t);
d272 2
a273 2
void ess_printsc(struct ess_softc *);
void ess_dump_mixer(struct ess_softc *);
d1285 1
a1285 1
	void (*intr)(void *);
d1363 1
a1363 1
	void (*intr)(void *);
d1432 1
a1432 1
	void (*intr)(void *);
@


1.2.4.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ess.c,v 1.2.4.5 2002/03/28 12:11:35 niklas Exp $	*/
d1008 2
a1009 4
	snprintf(ess_device.name, sizeof ess_device.name, "ES%s",
	    essmodel[sc->sc_model]);
	snprintf(ess_device.version, sizeof ess_device.name, "0x%04x",
	    sc->sc_version);
d1136 1
a1136 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d1142 1
a1142 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d1148 1
a1148 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d1154 1
a1154 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d1160 1
a1160 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d1166 1
a1166 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d1172 1
a1172 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d1178 1
a1178 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d1919 1
a1919 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d1922 1
a1922 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1932 1
a1932 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d1935 1
a1935 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1941 1
a1941 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d1944 1
a1944 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1950 1
a1950 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d1953 1
a1953 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1959 1
a1959 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d1962 1
a1962 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1968 1
a1968 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d1971 1
a1971 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1977 1
a1977 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d1984 1
a1984 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d1987 1
a1987 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d1993 1
a1993 1
		strlcpy(dip->label.name, "pc_speaker", sizeof dip->label.name);
d1996 1
a1996 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2002 1
a2002 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d2009 1
a2009 1
		strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d2012 1
a2012 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2018 1
a2018 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d2031 1
a2031 3
			strlcpy(dip->un.e.member[0].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[0].label.name);
d2033 1
a2033 2
			strlcpy(dip->un.e.member[1].label.name, AudioNline,
			    sizeof dip->un.e.member[1].label.name);
d2035 1
a2035 2
			strlcpy(dip->un.e.member[2].label.name, AudioNcd,
			    sizeof dip->un.e.member[2].label.name);
d2037 1
a2037 2
			strlcpy(dip->un.e.member[3].label.name, AudioNmixerout,
			    sizeof dip->un.e.member[3].label.name);
d2042 1
a2042 2
			strlcpy(dip->un.s.member[0].label.name, AudioNdac,
			    sizeof dip->un.e.member[0].label.name);
d2044 1
a2044 3
			strlcpy(dip->un.s.member[1].label.name,
			    AudioNmicrophone,
			    sizeof dip->un.e.member[1].label.name);
d2046 1
a2046 2
			strlcpy(dip->un.s.member[2].label.name, AudioNline,
			    sizeof dip->un.e.member[2].label.name);
d2048 1
a2048 2
			strlcpy(dip->un.s.member[3].label.name, AudioNfmsynth,
			    sizeof dip->un.e.member[3].label.name);
d2050 1
a2050 2
			strlcpy(dip->un.s.member[4].label.name, AudioNcd,
			    sizeof dip->un.e.member[4].label.name);
d2052 1
a2052 2
			strlcpy(dip->un.s.member[5].label.name, "auxb",
			    sizeof dip->un.e.member[5].label.name);
d2060 1
a2060 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d2066 1
a2066 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d2070 1
a2070 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2072 1
a2072 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d2079 1
a2079 2
		strlcpy(dip->label.name, AudioCmonitor,
		    sizeof dip->label.name);
d2091 1
a2091 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d2094 1
a2094 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2100 1
a2100 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d2103 1
a2103 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2109 1
a2109 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d2112 1
a2112 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2118 1
a2118 2
		strlcpy(dip->label.name, AudioNfmsynth,
		    sizeof dip->label.name);
d2121 1
a2121 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2127 1
a2127 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d2130 1
a2130 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2136 1
a2136 1
		strlcpy(dip->label.name, "auxb", sizeof dip->label.name);
d2139 1
a2139 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d2146 1
a2146 1
		strlcpy(dip->label.name, AudioNpreamp, sizeof dip->label.name);
d2149 1
a2149 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d2151 1
a2151 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
@


1.1
log
@ESS audio driver ported from NetBSD, some mixer problems with X-based mixers
otherwise OK (mixerctl works quite OK, very strange).
At the moment it is polled only, but it works quite OK that way too.
@
text
@d1 2
a2 2
/*	$OpenBSD: ess.c,v 1.44 1999/03/19 12:40:21 mycroft Exp $	*/
/*	$NetBSD: ess.c,v 1.44 1999/03/19 12:40:21 mycroft Exp $	*/
d177 1
a177 1
u_char	ess_dsp_write_ready __P((struct ess_softc *sc));
d188 1
d195 5
a199 1
	"1788"
d288 1
a288 1
	if (sc->sc_model != ESS_1788) {
d520 1
a520 1
	if (sc->sc_model == ESS_1788)
d565 1
a565 1
	if (sc->sc_model == ESS_1788)
d625 1
d630 1
d691 15
d726 15
d829 1
a829 1
	if (sc->sc_model != ESS_1788) {
d859 1
a859 1
	if (sc->sc_model != ESS_1788) {
a899 3
	
	sc->sc_audio1.irq = -1;
	sc->sc_audio2.irq = -1;
d917 1
a917 1
	if (sc->sc_model != ESS_1788) {
d950 1
a950 1
	if (sc->sc_model != ESS_1788)
d954 1
a954 1
	if (sc->sc_model == ESS_1788) {
d1007 1
a1007 1
	if (sc->sc_model == ESS_1788)
d1268 1
a1268 1
	if (sc->sc_model != ESS_1788) {
d1723 1
a1723 1
		if (sc->sc_model == ESS_1788) {
d1751 1
a1751 1
	if (sc->sc_model == ESS_1788)
d1845 1
a1845 1
		if (sc->sc_model == ESS_1788)
d1857 1
a1857 1
	if (sc->sc_model == ESS_1788)
d1924 1
a1924 1
		if (sc->sc_model == ESS_1788)
d2015 1
a2015 1
		if (sc->sc_model == ESS_1788) {
d2062 1
a2062 1
		strcpy(dip->label.name, AudioNmonitor);
d2080 1
a2080 1
	if (sc->sc_model == ESS_1788)
d2164 1
a2164 1
	if (sc->sc_model != ESS_1788)
d2271 1
a2271 1
		if (sc->sc_model == ESS_1788)
d2322 1
a2322 1
	if (sc->sc_model == ESS_1788 && mix && src > 0x62)
d2676 17
@

