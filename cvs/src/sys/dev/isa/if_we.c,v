head	1.26;
access;
symbols
	OPENBSD_6_1:1.26.0.8
	OPENBSD_6_1_BASE:1.26
	OPENBSD_6_0:1.26.0.4
	OPENBSD_6_0_BASE:1.26
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.23.0.6
	OPENBSD_5_8_BASE:1.23
	OPENBSD_5_7:1.23.0.4
	OPENBSD_5_7_BASE:1.23
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.10
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.8
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.6
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.4
	OPENBSD_5_0:1.21.0.2
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.20.0.12
	OPENBSD_4_9_BASE:1.20
	OPENBSD_4_8:1.20.0.10
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.6
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.14.0.2
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.13.0.4
	OPENBSD_3_9_BASE:1.13
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.12.0.4
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.12.0.2
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.11.0.4
	OPENBSD_3_5_BASE:1.11
	OPENBSD_3_4:1.11.0.2
	OPENBSD_3_4_BASE:1.11
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.10.0.6
	OPENBSD_3_3_BASE:1.10
	OPENBSD_3_2:1.10.0.4
	OPENBSD_3_2_BASE:1.10
	OPENBSD_3_1:1.10.0.2
	OPENBSD_3_1_BASE:1.10
	UBC_SYNC_B:1.10
	UBC:1.9.0.6
	UBC_BASE:1.9
	OPENBSD_3_0:1.9.0.4
	OPENBSD_3_0_BASE:1.9
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.8.0.4
	OPENBSD_2_8_BASE:1.8
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.7.0.6
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.7.0.4
	OPENBSD_2_6_BASE:1.7
	OPENBSD_2_5:1.7.0.2
	OPENBSD_2_5_BASE:1.7
	OPENBSD_2_4:1.2.0.2
	OPENBSD_2_4_BASE:1.2;
locks; strict;
comment	@ * @;


1.26
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.25;
commitid	5gdEnqVoJuTuwdTu;

1.25
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.24;
commitid	5DvsamK0GblTp8ww;

1.24
date	2015.09.11.13.02.28;	author stsp;	state Exp;
branches;
next	1.23;
commitid	6vhYvh5CxZAHMnsN;

1.23
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.22;
commitid	nYggAidK85QbUFh2;

1.22
date	2013.08.07.01.06.33;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2011.06.20.01.09.25;	author matthew;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.08.15.56.56;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.20.17.02.24;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2006.10.20.16.54.01;	author brad;	state Exp;
branches;
next	1.15;

1.15
date	2006.10.01.20.51.36;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.29.11.31.21;	author miod;	state Exp;
branches;
next	1.13;

1.13
date	2005.06.08.17.03.00;	author henning;	state Exp;
branches;
next	1.12;

1.12
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.17.03.49.52;	author drahn;	state Exp;
branches;
next	1.10;

1.10
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.12.05.37.00;	author aaron;	state Exp;
branches
	1.9.6.1;
next	1.8;

1.8
date	2000.04.03.07.43.53;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	98.12.23.07.58.26;	author aaron;	state Exp;
branches
	1.7.6.1;
next	1.6;

1.6
date	98.12.23.06.02.19;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	98.12.23.00.33.29;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	98.11.28.02.29.29;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	98.11.28.01.29.05;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	98.10.04.22.28.14;	author niklas;	state Exp;
branches;
next	1.1;

1.1
date	98.09.22.06.33.19;	author fgsch;	state Exp;
branches;
next	;

1.7.6.1
date	2001.05.14.22.24.44;	author niklas;	state Exp;
branches;
next	1.7.6.2;

1.7.6.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.7.6.3;

1.7.6.3
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	1.7.6.4;

1.7.6.4
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;

1.9.6.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.9.6.2;

1.9.6.2
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.26
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_we.c,v 1.25 2015/11/24 13:33:17 mpi Exp $	*/
/*	$NetBSD: if_we.c,v 1.11 1998/07/05 06:49:14 jonathan Exp $	*/

/*-
 * Copyright (c) 1997, 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Jason R. Thorpe of the Numerical Aerospace Simulation Facility,
 * NASA Ames Research Center.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Device driver for National Semiconductor DS8390/WD83C690 based ethernet
 * adapters.
 *
 * Copyright (c) 1994, 1995 Charles M. Hannum.  All rights reserved.
 *
 * Copyright (C) 1993, David Greenman.  This software may be used, modified,
 * copied, distributed, and sold, in both source and binary form provided that
 * the above copyright and these terms are retained.  Under no circumstances is
 * the author responsible for the proper functioning of this software, nor does
 * the author assume any responsibility for damages incurred with its use.
 */

/*
 * Device driver for the Western Digital/SMC 8003 and 8013 series,
 * and the SMC Elite Ultra (8216).
 */

#include "bpfilter.h"
#include "we.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/socket.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/ic/dp8390reg.h>
#include <dev/ic/dp8390var.h>

#include <dev/isa/if_wereg.h>

#ifndef __BUS_SPACE_HAS_STREAM_METHODS
#define	bus_space_read_region_stream_2	bus_space_read_region_2
#define	bus_space_write_stream_2	bus_space_write_2
#define	bus_space_write_region_stream_2	bus_space_write_region_2
#endif

struct we_softc {
	struct dp8390_softc sc_dp8390;

	bus_space_tag_t sc_asict;	/* space tag for ASIC */
	bus_space_handle_t sc_asich;	/* space handle for ASIC */

	u_int8_t sc_laar_proto;
	u_int8_t sc_msr_proto;

	u_int8_t sc_type;		/* our type */

	int sc_16bitp;			/* are we 16 bit? */

	void *sc_ih;			/* interrupt handle */
};

int	we_probe(struct device *, void *, void *);
int	we_match(struct device *, void *, void *);
void	we_attach(struct device *, struct device *, void *);

struct cfattach we_isa_ca = {
	sizeof(struct we_softc), we_probe, we_attach
};

#if NWE_ISAPNP
struct cfattach we_isapnp_ca = {
	sizeof(struct we_softc), we_match, we_attach
};
#endif /* NWE_ISAPNP */

struct cfdriver we_cd = {
	NULL, "we", DV_IFNET
};

const char *we_params(bus_space_tag_t, bus_space_handle_t, u_int8_t *,
	    bus_size_t *, int *, int *);

void	we_media_init(struct dp8390_softc *);

int	we_mediachange(struct dp8390_softc *);
void	we_mediastatus(struct dp8390_softc *, struct ifmediareq *);

void	we_recv_int(struct dp8390_softc *);
int	we_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	we_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	we_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	we_test_mem(struct dp8390_softc *);

__inline void we_readmem(struct we_softc *, int, u_int8_t *, int);

static const int we_584_irq[] = {
	9, 3, 5, 7, 10, 11, 15, 4,
};
#define	NWE_584_IRQ	(sizeof(we_584_irq) / sizeof(we_584_irq[0]))

static const int we_790_irq[] = {
	IRQUNK, 9, 3, 5, 7, 10, 11, 15,
};
#define	NWE_790_IRQ	(sizeof(we_790_irq) / sizeof(we_790_irq[0]))

/*
 * Delay needed when switching 16-bit access to shared memory.
 */
#define	WE_DELAY(wsc) delay(3)

/*
 * Enable card RAM, and 16-bit access.
 */
#define	WE_MEM_ENABLE(wsc) \
do { \
	if ((wsc)->sc_16bitp) \
		bus_space_write_1((wsc)->sc_asict, (wsc)->sc_asich, \
		    WE_LAAR, (wsc)->sc_laar_proto | WE_LAAR_M16EN); \
	bus_space_write_1((wsc)->sc_asict, (wsc)->sc_asich, \
	    WE_MSR, wsc->sc_msr_proto | WE_MSR_MENB); \
	WE_DELAY((wsc)); \
} while (0)

/*
 * Disable card RAM, and 16-bit access.
 */
#define	WE_MEM_DISABLE(wsc) \
do { \
	bus_space_write_1((wsc)->sc_asict, (wsc)->sc_asich, \
	    WE_MSR, (wsc)->sc_msr_proto); \
	if ((wsc)->sc_16bitp) \
		bus_space_write_1((wsc)->sc_asict, (wsc)->sc_asich, \
		    WE_LAAR, (wsc)->sc_laar_proto); \
	WE_DELAY((wsc)); \
} while (0)

int
we_probe(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = ((struct device *)match)->dv_cfdata;

	return (we_match(parent, cf, aux));
}

int
we_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	struct cfdata *cf = match;
	bus_space_tag_t asict, memt;
	bus_space_handle_t asich, memh;
	bus_size_t memsize;
	int asich_valid, memh_valid;
	int i, is790, rv = 0;
	u_int8_t x, type;

	asict = ia->ia_iot;
	memt = ia->ia_memt;

	asich_valid = memh_valid = 0;

	/* Disallow wildcarded i/o addresses. */
	if (ia->ia_iobase == -1 /* ISACF_PORT_DEFAULT */)
		return (0);

	/* Disallow wildcarded mem address. */
	if (ia->ia_maddr == -1 /* ISACF_IOMEM_DEFAULT */)
		return (0);

	/* Attempt to map the device. */
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isapnp") && ia->ia_ioh)
		asich = ia->ia_ioh;
	else {
		if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich))
			goto out;
		asich_valid = 1;
	}

#ifdef TOSH_ETHER
	bus_space_write_1(asict, asich, WE_MSR, WE_MSR_POW);
#endif

	/*
	 * Attempt to do a checksum over the station address PROM.
	 * If it fails, it's probably not a WD/SMC board.  There is
	 * a problem with this, though.  Some clone WD8003E boards
	 * (e.g. Danpex) won't pass the checksum.  In this case,
	 * the checksum byte always seems to be 0.
	 */
	for (x = 0, i = 0; i < 8; i++)
		x += bus_space_read_1(asict, asich, WE_PROM + i);

	if (x != WE_ROM_CHECKSUM_TOTAL) {
		/* Make sure it's an 8003E clone... */
		if (bus_space_read_1(asict, asich, WE_CARD_ID) !=
		    WE_TYPE_WD8003E)
			goto out;

		/* Check the checksum byte. */
		if (bus_space_read_1(asict, asich, WE_PROM + 7) != 0)
			goto out;
	}

	/*
	 * Reset the card to force it into a known state.
	 */
#ifdef TOSH_ETHER
	bus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST | WE_MSR_POW);
#else
	bus_space_write_1(asict, asich, WE_MSR, WE_MSR_RST);
#endif
	delay(100);

	bus_space_write_1(asict, asich, WE_MSR,
	    bus_space_read_1(asict, asich, WE_MSR) & ~WE_MSR_RST);

	/* Wait in case the card is reading its EEPROM. */
	delay(5000);

	/*
	 * Get parameters.
	 */
	if (we_params(asict, asich, &type, &memsize, NULL, &is790) == NULL)
		goto out;

	/* Allow user to override probed value. */
	if (ia->ia_msize)
		memsize = ia->ia_msize;

	/* Attempt to map the memory space. */
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isapnp") && ia->ia_memh)
		memh = ia->ia_memh;
	else {
		if (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))
			goto out;
		memh_valid = 1;
	}

	/*
	 * If possible, get the assigned interrupt number from the card
	 * and use it.
	 */
	if (is790) {
		u_int8_t hwr;

		/* Assemble together the encoded interrupt number. */
		hwr = bus_space_read_1(asict, asich, WE790_HWR);
		bus_space_write_1(asict, asich, WE790_HWR,
		    hwr | WE790_HWR_SWH);

		x = bus_space_read_1(asict, asich, WE790_GCR);
		i = ((x & WE790_GCR_IR2) >> 4) |
		    ((x & (WE790_GCR_IR1|WE790_GCR_IR0)) >> 2);
		bus_space_write_1(asict, asich, WE790_HWR,
		    hwr & ~WE790_HWR_SWH);

		if (ia->ia_irq != IRQUNK && ia->ia_irq != we_790_irq[i])
			printf("%s%d: changing IRQ %d to %d\n",
			    we_cd.cd_name, cf->cf_unit, ia->ia_irq,
			    we_790_irq[i]);
		ia->ia_irq = we_790_irq[i];
	} else if (type & WE_SOFTCONFIG) {
		/* Assemble together the encoded interrupt number. */
		i = (bus_space_read_1(asict, asich, WE_ICR) & WE_ICR_IR2) |
		    ((bus_space_read_1(asict, asich, WE_IRR) &
		      (WE_IRR_IR0 | WE_IRR_IR1)) >> 5);

		if (ia->ia_irq != IRQUNK && ia->ia_irq != we_584_irq[i])
			printf("%s%d: changing IRQ %d to %d\n",
			    we_cd.cd_name, cf->cf_unit, ia->ia_irq,
			    we_584_irq[i]);
		ia->ia_irq = we_584_irq[i];
	}

	/* So, we say we've found it! */
	ia->ia_iosize = WE_NPORTS;
	ia->ia_msize = memsize;
	rv = 1;

 out:
	if (asich_valid)
		bus_space_unmap(asict, asich, WE_NPORTS);
	if (memh_valid)
		bus_space_unmap(memt, memh, memsize);
	return (rv);
}

void
we_attach(struct device *parent, struct device *self, void *aux)
{
	struct we_softc *wsc = (struct we_softc *)self;
	struct dp8390_softc *sc = &wsc->sc_dp8390;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t nict, asict, memt;
	bus_space_handle_t nich, asich, memh;
	const char *typestr;
	u_int8_t x;
	int i;

	printf("\n");

	nict = asict = ia->ia_iot;
	memt = ia->ia_memt;

	/* Map the device. */
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isapnp") && ia->ia_ioh)
		asich = ia->ia_ioh;
	else if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich)) {
		printf("%s: can't map nic i/o space\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	if (bus_space_subregion(asict, asich, WE_NIC_OFFSET, WE_NIC_NPORTS,
	    &nich)) {
		printf("%s: can't subregion i/o space\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	typestr = we_params(asict, asich, &wsc->sc_type, NULL,
	    &wsc->sc_16bitp, &sc->is790);
	if (typestr == NULL) {
		printf("%s: where did the card go?\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Map memory space.  Note we use the size that might have
	 * been overridden by the user.
	 */
	if (!strcmp(parent->dv_cfdata->cf_driver->cd_name, "isapnp") && ia->ia_memh)
		memh = ia->ia_memh;
	else if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {
		printf("%s: can't map shared memory\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Allow user to override 16-bit mode.  8-bit takes precedence.
	 */
	if (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_16BIT_MODE)
		wsc->sc_16bitp = 1;
	if (self->dv_cfdata->cf_flags & WE_FLAGS_FORCE_8BIT_MODE)
		wsc->sc_16bitp = 0;

	wsc->sc_asict = asict;
	wsc->sc_asich = asich;

	sc->sc_regt = nict;
	sc->sc_regh = nich;

	sc->sc_buft = memt;
	sc->sc_bufh = memh;

	/* Interface is always enabled. */
	sc->sc_enabled = 1;

	/* Registers are linear. */
	for (i = 0; i < 16; i++)
		sc->sc_reg_map[i] = i;

	/* Now we can use the NIC_{GET,PUT}() macros. */

	printf("%s: %s (%s-bit)", sc->sc_dev.dv_xname, typestr,
	    wsc->sc_16bitp ? "16" : "8");

	/* Get station address from EEPROM. */
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		sc->sc_arpcom.ac_enaddr[i] =
		    bus_space_read_1(asict, asich, WE_PROM + i);

	/*
	 * Set upper address bits and 8/16 bit access to shared memory.
	 */
	if (sc->is790) {
		wsc->sc_laar_proto =
		    bus_space_read_1(asict, asich, WE_LAAR) &
		    ~WE_LAAR_M16EN;
		bus_space_write_1(asict, asich, WE_LAAR,
		    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));
	} else if ((wsc->sc_type & WE_SOFTCONFIG) ||
#ifdef TOSH_ETHER
	    (wsc->sc_type == WE_TYPE_TOSHIBA1) ||
	    (wsc->sc_type == WE_TYPE_TOSHIBA4) ||
#endif
	    (wsc->sc_type == WE_TYPE_WD8013EBT)) {
		wsc->sc_laar_proto = (ia->ia_maddr >> 19) & WE_LAAR_ADDRHI;
		if (wsc->sc_16bitp)
			wsc->sc_laar_proto |= WE_LAAR_L16EN;
		bus_space_write_1(asict, asich, WE_LAAR,
		    wsc->sc_laar_proto | (wsc->sc_16bitp ? WE_LAAR_M16EN : 0));
	}

	/*
	 * Set address and enable interface shared memory.
	 */
	if (sc->is790) {
		/* XXX MAGIC CONSTANTS XXX */
		x = bus_space_read_1(asict, asich, 0x04);
		bus_space_write_1(asict, asich, 0x04, x | 0x80);
		bus_space_write_1(asict, asich, 0x0b,
		    ((ia->ia_maddr >> 13) & 0x0f) |
		    ((ia->ia_maddr >> 11) & 0x40) |
		    (bus_space_read_1(asict, asich, 0x0b) & 0xb0));
		bus_space_write_1(asict, asich, 0x04, x);
		wsc->sc_msr_proto = 0x00;
		sc->cr_proto = 0x00;
	} else {
#ifdef TOSH_ETHER
		if (wsc->sc_type == WE_TYPE_TOSHIBA1 ||
		    wsc->sc_type == WE_TYPE_TOSHIBA4) {
			bus_space_write_1(asict, asich, WE_MSR + 1,
			    ((ia->ia_maddr >> 8) & 0xe0) | 0x04);
			bus_space_write_1(asict, asich, WE_MSR + 2,
			    ((ia->ia_maddr >> 16) & 0x0f));
			wsc->sc_msr_proto = WE_MSR_POW;
		} else
#endif
			wsc->sc_msr_proto = (ia->ia_maddr >> 13) &
			    WE_MSR_ADDR;

		sc->cr_proto = ED_CR_RD2;
	}

	bus_space_write_1(asict, asich, WE_MSR,
	    wsc->sc_msr_proto | WE_MSR_MENB);
	WE_DELAY(wsc);

	/*
	 * DCR gets:
	 *
	 *	FIFO threshold to 8, No auto-init Remote DMA,
	 *	byte order=80x86.
	 *
	 * 16-bit cards also get word-wide DMA transfers.
	 */
	sc->dcr_reg = ED_DCR_FT1 | ED_DCR_LS |
	    (wsc->sc_16bitp ? ED_DCR_WTS : 0);

	sc->test_mem = we_test_mem;
	sc->ring_copy = we_ring_copy;
	sc->write_mbuf = we_write_mbuf;
	sc->read_hdr = we_read_hdr;
	sc->recv_int = we_recv_int;

	sc->sc_mediachange = we_mediachange;
	sc->sc_mediastatus = we_mediastatus;

	sc->mem_start = 0;
	sc->mem_size = ia->ia_msize;

	sc->sc_flags = self->dv_cfdata->cf_flags;

	/* Do generic parts of attach. */
	if (wsc->sc_type & WE_SOFTCONFIG)
		sc->sc_media_init = we_media_init;
	else
		sc->sc_media_init = dp8390_media_init;
	if (dp8390_config(sc)) {
		printf(": configuration failed\n");
		return;
	}

	/*
	 * Disable 16-bit access to shared memory - we leave it disabled
	 * so that:
	 *
	 *	(1) machines reboot properly when the board is set to
	 *	    16-bit mode and there are conflicting 8-bit devices
	 *	    within the same 128k address space as this board's
	 *	    shared memory, and
	 *
	 *	(2) so that other 8-bit devices with shared memory
	 *	    in this same 128k address space will work.
	 */
	WE_MEM_DISABLE(wsc);

	/*
	 * Enable the configured interrupt.
	 */
	if (sc->is790)
		bus_space_write_1(asict, asich, WE790_ICR,
		    bus_space_read_1(asict, asich, WE790_ICR) |
		    WE790_ICR_EIL);
	else if (wsc->sc_type & WE_SOFTCONFIG)
		bus_space_write_1(asict, asich, WE_IRR,
		    bus_space_read_1(asict, asich, WE_IRR) | WE_IRR_IEN);
	else if (ia->ia_irq == IRQUNK) {
		printf("%s: can't wildcard IRQ on a %s\n",
		    sc->sc_dev.dv_xname, typestr);
		return;
	}

	/* Establish interrupt handler. */
	wsc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, dp8390_intr, sc, sc->sc_dev.dv_xname);
	if (wsc->sc_ih == NULL)
		printf("%s: can't establish interrupt\n", sc->sc_dev.dv_xname);
}

int
we_test_mem(struct dp8390_softc *sc)
{
	struct we_softc *wsc = (struct we_softc *)sc;
	bus_space_tag_t memt = sc->sc_buft;
	bus_space_handle_t memh = sc->sc_bufh;
	bus_size_t memsize = sc->mem_size;
	int i;

	if (wsc->sc_16bitp)
		bus_space_set_region_2(memt, memh, 0, 0, memsize >> 1);
	else
		bus_space_set_region_1(memt, memh, 0, 0, memsize);

	if (wsc->sc_16bitp) {
		for (i = 0; i < memsize; i += 2) {
			if (bus_space_read_2(memt, memh, i) != 0)
				goto fail;
		}
	} else {
		for (i = 0; i < memsize; i++) {
			if (bus_space_read_1(memt, memh, i) != 0)
				goto fail;
		}
	}

	return (0);

 fail:
	printf("%s: failed to clear shared memory at offset 0x%x\n",
	    sc->sc_dev.dv_xname, i);
	WE_MEM_DISABLE(wsc);
	return (1);
}

/*
 * Given a NIC memory source address and a host memory destination address,
 * copy 'len' from NIC to host using shared memory.  The 'len' is rounded
 * up to a word - ok as long as mbufs are word-sized.
 */
__inline void
we_readmem(struct we_softc *wsc, int from, u_int8_t *to, int len)
{
	bus_space_tag_t memt = wsc->sc_dp8390.sc_buft;
	bus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;

	if (len & 1)
		++len;

	if (wsc->sc_16bitp)
		bus_space_read_region_stream_2(memt, memh, from,
		    (u_int16_t *)to, len >> 1);
	else
		bus_space_read_region_1(memt, memh, from,
		    to, len);
}

int
we_write_mbuf(struct dp8390_softc *sc, struct mbuf *m, int buf)
{
	struct we_softc *wsc = (struct we_softc *)sc;
	bus_space_tag_t memt = wsc->sc_dp8390.sc_buft;
	bus_space_handle_t memh = wsc->sc_dp8390.sc_bufh;
	u_int8_t *data, savebyte[2];
	int savelen, len, leftover;
#ifdef DIAGNOSTIC
	u_int8_t *lim;
#endif

	savelen = m->m_pkthdr.len;

	WE_MEM_ENABLE(wsc);

	/*
	 * 8-bit boards are simple; no alignment tricks are necessary.
	 */
	if (wsc->sc_16bitp == 0) {
		for (; m != NULL; buf += m->m_len, m = m->m_next)
			bus_space_write_region_1(memt, memh,
			    buf, mtod(m, u_int8_t *), m->m_len);
		goto out;
	}

	/* Start out with no leftover data. */
	leftover = 0;
	savebyte[0] = savebyte[1] = 0;

	for (; m != NULL; m = m->m_next) {
		len = m->m_len;
		if (len == 0)
			continue;
		data = mtod(m, u_int8_t *);
#ifdef DIAGNOSTIC
		lim = data + len;
#endif
		while (len > 0) {
			if (leftover) {
				/*
				 * Data left over (from mbuf or realignment).
				 * Buffer the next byte, and write it and
				 * the leftover data out.
				 */
				savebyte[1] = *data++;
				len--;
				bus_space_write_stream_2(memt, memh, buf,
				    *(u_int16_t *)savebyte);
				buf += 2;
				leftover = 0;
			} else if (ALIGNED_POINTER(data, u_int16_t) == 0) {
				/*
				 * Unaligned dta; buffer the next byte.
				 */
				savebyte[0] = *data++;
				len--;
				leftover = 1;
			} else {
				/*
				 * Aligned data; output contiguous words as
				 * much as we can, then buffer the remaining
				 * byte, if any.
				 */
				leftover = len & 1;
				len &= ~1;
				bus_space_write_region_stream_2(memt, memh,
				    buf, (u_int16_t *)data, len >> 1);
				data += len;
				buf += len;
				if (leftover)
					savebyte[0] = *data++;
				len = 0;
			}
		}
		if (len < 0)
			panic("we_write_mbuf: negative len");
#ifdef DIAGNOSTIC
		if (data != lim)
			panic("we_write_mbuf: data != lim");
#endif
	}
	if (leftover) {
		savebyte[1] = 0;
		bus_space_write_stream_2(memt, memh, buf,
		    *(u_int16_t *)savebyte);
	}

 out:
	WE_MEM_DISABLE(wsc);

	return (savelen);
}

int
we_ring_copy(struct dp8390_softc *sc, int src, caddr_t dst, u_short amount)
{
	struct we_softc *wsc = (struct we_softc *)sc;
	u_short tmp_amount;

	/* Does copy wrap to lower addr in ring buffer? */
	if (src + amount > sc->mem_end) {
		tmp_amount = sc->mem_end - src;

		/* Copy amount up to end of NIC memory. */
		we_readmem(wsc, src, dst, tmp_amount);

		amount -= tmp_amount;
		src = sc->mem_ring;
		dst += tmp_amount;
	}

	we_readmem(wsc, src, dst, amount);

	return (src + amount);
}

void
we_read_hdr(struct dp8390_softc *sc, int packet_ptr,
    struct dp8390_ring *packet_hdrp)
{
	struct we_softc *wsc = (struct we_softc *)sc;

	we_readmem(wsc, packet_ptr, (u_int8_t *)packet_hdrp,
	    sizeof(struct dp8390_ring));
#if BYTE_ORDER == BIG_ENDIAN
	packet_hdrp->count = swap16(packet_hdrp->count);
#endif
}

void
we_recv_int(struct dp8390_softc *sc)
{
	struct we_softc *wsc = (struct we_softc *)sc;

	WE_MEM_ENABLE(wsc);
	dp8390_rint(sc);
	WE_MEM_DISABLE(wsc);
}

void
we_media_init(struct dp8390_softc *sc)
{
	struct we_softc *wsc = (void *)sc;
	uint64_t defmedia = IFM_ETHER;
	u_int8_t x;

	if (sc->is790) {
		x = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR);
		bus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR,
		    x | WE790_HWR_SWH);
		if (bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE790_GCR) &
		    WE790_GCR_GPOUT)
			defmedia |= IFM_10_2;
		else
			defmedia |= IFM_10_5;
		bus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR,
		    x &~ WE790_HWR_SWH);
	} else {
		x = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);
		if (x & WE_IRR_OUT2)
			defmedia |= IFM_10_2;
		else
			defmedia |= IFM_10_5;
	}

	ifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_2, 0, NULL);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_5, 0, NULL);
	ifmedia_set(&sc->sc_media, defmedia);
}

int
we_mediachange(struct dp8390_softc *sc)
{

	/*
	 * Current media is already set up.  Just reset the interface
	 * to let the new value take hold.  The new media will be
	 * set up in dp8390_init().
	 */
	dp8390_reset(sc);
	return (0);
}

void
we_mediastatus(struct dp8390_softc *sc, struct ifmediareq *ifmr)
{
	struct ifmedia *ifm = &sc->sc_media;

	/*
	 * The currently selected media is always the active media.
	 */
	ifmr->ifm_active = ifm->ifm_cur->ifm_media;
}

const char *
we_params(bus_space_tag_t asict, bus_space_handle_t asich,
    u_int8_t *typep, bus_size_t *memsizep, int *is16bitp,
    int *is790p)
{
	const char *typestr;
	bus_size_t memsize;
	int is16bit, is790;
	u_int8_t type;

	memsize = 8192;
	is16bit = is790 = 0;

	type = bus_space_read_1(asict, asich, WE_CARD_ID);
	switch (type) {
	case WE_TYPE_WD8003S: 
		typestr = "WD8003S"; 
		break;
	case WE_TYPE_WD8003E:
		typestr = "WD8003E";
		break;
	case WE_TYPE_WD8003EB: 
		typestr = "WD8003EB";
		break;
	case WE_TYPE_WD8003W:
		typestr = "WD8003W";
		break;
	case WE_TYPE_WD8013EBT: 
		typestr = "WD8013EBT";
		memsize = 16384;
		is16bit = 1;
		break;
	case WE_TYPE_WD8013W:
		typestr = "WD8013W";
		memsize = 16384;
		is16bit = 1;
		break;
	case WE_TYPE_WD8013EP:		/* also WD8003EP */
		if (bus_space_read_1(asict, asich, WE_ICR) & WE_ICR_16BIT) {
			is16bit = 1;
			memsize = 16384;
			typestr = "WD8013EP";
		} else
			typestr = "WD8003EP";
		break;
	case WE_TYPE_WD8013WC:
		typestr = "WD8013WC";
		memsize = 16384;
		is16bit = 1;
		break;
	case WE_TYPE_WD8013EBP:
		typestr = "WD8013EBP";
		memsize = 16384;
		is16bit = 1;
		break;
	case WE_TYPE_WD8013EPC:
		typestr = "WD8013EPC";
		memsize = 16384;
		is16bit = 1;
		break;
	case WE_TYPE_SMC8216C:
	case WE_TYPE_SMC8216T:
	    {
		u_int8_t hwr;

		typestr = (type == WE_TYPE_SMC8216C) ?
		    "SMC8216/SMC8216C" : "SMC8216T";

		hwr = bus_space_read_1(asict, asich, WE790_HWR);
		bus_space_write_1(asict, asich, WE790_HWR,
		    hwr | WE790_HWR_SWH);
		switch (bus_space_read_1(asict, asich, WE790_RAR) &
		    WE790_RAR_SZ64) {
		case WE790_RAR_SZ64:
			memsize = 65536;
			break;
		case WE790_RAR_SZ32:
			memsize = 32768;
			break;
		case WE790_RAR_SZ16:
			memsize = 16384;
			break;
		case WE790_RAR_SZ8:
			/* 8216 has 16K shared mem -- 8416 has 8K */
			typestr = (type == WE_TYPE_SMC8216C) ?
			    "SMC8416C/SMC8416BT" : "SMC8416T";
			memsize = 8192;
			break;
		}
		bus_space_write_1(asict, asich, WE790_HWR, hwr);

		is16bit = 1;
		is790 = 1;
		break;
	    }
#ifdef TOSH_ETHER
	case WE_TYPE_TOSHIBA1:
		typestr = "Toshiba1";
		memsize = 32768;
		is16bit = 1;
		break;
	case WE_TYPE_TOSHIBA4:
		typestr = "Toshiba4";
		memsize = 32768;
		is16bit = 1;
		break;
#endif
	default:
		/* Not one we recognize. */
		return (NULL);
	}

	/*
	 * Make some adjustments to initial values depending on what is
	 * found in the ICR.
	 */
	if (is16bit && (type != WE_TYPE_WD8013EBT) &&
#ifdef TOSH_ETHER
	    (type != WE_TYPE_TOSHIBA1 && type != WE_TYPE_TOSHIBA4) &&
#endif
	    (bus_space_read_1(asict, asich, WE_ICR) & WE_ICR_16BIT) == 0) {
		is16bit = 0;
		memsize = 8192;
	}

#ifdef WE_DEBUG
	{
		int i;

		printf("we_params: type = 0x%x, typestr = %s, is16bit = %d, "
		    "memsize = %d\n", type, typestr, is16bit, memsize);
		for (i = 0; i < 8; i++)
			printf("     %d -> 0x%x\n", i,
			    bus_space_read_1(asict, asich, i));
	}
#endif

	if (typep != NULL)
		*typep = type;
	if (memsizep != NULL)
		*memsizep = memsize;
	if (is16bitp != NULL)
		*is16bitp = is16bit;
	if (is790p != NULL)
		*is790p = is790;
	return (typestr);
}
@


1.25
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.24 2015/09/11 13:02:28 stsp Exp $	*/
a62 1
#include <net/if_dl.h>
@


1.24
log
@Make room for media types of the future. Extend the ifmedia word to 64 bits.
This changes numbers of the SIOCSIFMEDIA and SIOCGIFMEDIA ioctls and
grows struct ifmediareq.

Old ifconfig and dhclient binaries can still assign addresses, however
the 'media' subcommand stops working. Recompiling ifconfig and dhclient
with new headers before a reboot should not be necessary unless in very
special circumstances where non-default media settings must be used to
get link and console access is not available.

There may be some MD fallout but that will be cleared up later.

ok deraadt miod
with help and suggestions from several sharks attending l2k15
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.23 2014/08/11 12:45:45 mpi Exp $	*/
a63 1
#include <net/if_types.h>
@


1.23
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.22 2013/08/07 01:06:33 bluhm Exp $	*/
d750 1
a750 1
	int defmedia = IFM_ETHER;
@


1.22
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.21 2011/06/20 01:09:25 matthew Exp $	*/
a66 1
#ifdef INET
a67 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a68 1
#endif 
@


1.21
log
@isa(4) is an indirect bus, which means that drivers that attach to it
need to provide an xxxprobe() method instead of an xxxmatch() method.
The critical difference is xxxprobe() is given a device softc for the
second argument, whereas a xxxmatch() is given the cfdata as the
second argument.

This commit fixes the handful of ISA device drivers that incorrectly
cast the second argument to a "struct cfdata *" instead of a "struct
device *".  (Minor complication: unlike isa(4), isapnp(4) is a direct
bus, and if_we.c used the same probe/match code for both; now separate
we_probe and we_match methods are used as appropriate.)

"makes sense to me" krw@@; ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.20 2008/06/26 05:42:16 ray Exp $	*/
a69 1
#include <netinet/in_var.h> 
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.19 2007/05/08 15:56:56 deraadt Exp $	*/
d113 1
d122 1
a122 1
	sizeof(struct we_softc), we_probe, we_attach
d189 8
@


1.19
log
@old school media handling is no longer used; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.18 2007/04/10 17:47:55 miod Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.17 2006/10/20 17:02:24 brad Exp $	*/
a137 1
void	we_set_media(struct we_softc *, int);
a144 1
void	we_init_card(struct dp8390_softc *);
d788 1
a788 1
	 * set up in we_init_card() called via dp8390_init().
a802 41
}

void
we_init_card(struct dp8390_softc *sc)
{
	struct we_softc *wsc = (struct we_softc *)sc;
	struct ifmedia *ifm = &sc->sc_media;

	we_set_media(wsc, ifm->ifm_cur->ifm_media);
}

void
we_set_media(struct we_softc *wsc, int media)
{
	struct dp8390_softc *sc = &wsc->sc_dp8390;
	bus_space_tag_t asict = wsc->sc_asict;
	bus_space_handle_t asich = wsc->sc_asich;
	u_int8_t hwr, gcr, irr;

	if (sc->is790) {
		hwr = bus_space_read_1(asict, asich, WE790_HWR);
		bus_space_write_1(asict, asich, WE790_HWR,
		    hwr | WE790_HWR_SWH);
		gcr = bus_space_read_1(asict, asich, WE790_GCR);
		if (IFM_SUBTYPE(media) == IFM_10_2)
			gcr |= WE790_GCR_GPOUT;
		else
			gcr &= ~WE790_GCR_GPOUT;
		bus_space_write_1(asict, asich, WE790_GCR,
		    gcr | WE790_GCR_LIT);
		bus_space_write_1(asict, asich, WE790_HWR,
		    hwr & ~WE790_HWR_SWH);
		return;
	}

	irr = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);
	if (IFM_SUBTYPE(media) == IFM_10_2)
		irr |= WE_IRR_OUT2;
	else
		irr &= ~WE_IRR_OUT2;
	bus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE_IRR, irr);
@


1.17
log
@remove some NetBSD code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.16 2006/10/20 16:54:01 brad Exp $	*/
d267 1
a267 1
	/* Wait in case the card is reading it's EEPROM. */
@


1.16
log
@ansi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.15 2006/10/01 20:51:36 brad Exp $	*/
a73 4
#ifdef __NetBSD__
#include <net/if_ether.h>
#endif

a78 3
#ifdef __NetBSD__
#include <netinet/if_inarp.h> 
#else
a79 1
#endif
a131 3
#ifdef __NetBSD__
extern struct cfdriver we_cd;
#else
a134 1
#endif
a421 3
#ifdef __NetBSD__
		sc->sc_enaddr[i] = bus_space_read_1(asict, asich, WE_PROM + i);
#else
a423 1
#endif
@


1.15
log
@fix dmesg line wrapping; this was fallout from shortening the ne(4) dmesg
printing.

reported/tested by and okay nick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.14 2006/07/29 11:31:21 miod Exp $	*/
d208 1
a208 3
we_probe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
d351 1
a351 3
we_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d571 1
a571 2
we_test_mem(sc)
	struct dp8390_softc *sc;
d611 1
a611 5
we_readmem(wsc, from, to, len)
	struct we_softc *wsc;
	int from;
	u_int8_t *to;
	int len;
d628 1
a628 4
we_write_mbuf(sc, m, buf)
	struct dp8390_softc *sc;
	struct mbuf *m;
	int buf;
d722 1
a722 5
we_ring_copy(sc, src, dst, amount)
	struct dp8390_softc *sc;
	int src;
	caddr_t dst;
	u_short amount;
d745 2
a746 4
we_read_hdr(sc, packet_ptr, packet_hdrp)
	struct dp8390_softc *sc;
	int packet_ptr;
	struct dp8390_ring *packet_hdrp;
d758 1
a758 2
we_recv_int(sc)
	struct dp8390_softc *sc;
d800 1
a800 2
we_mediachange(sc)
	struct dp8390_softc *sc;
d813 1
a813 3
we_mediastatus(sc, ifmr)
	struct dp8390_softc *sc;
	struct ifmediareq *ifmr;
d824 1
a824 2
we_init_card(sc)
	struct dp8390_softc *sc;
d833 1
a833 3
we_set_media(wsc, media)
	struct we_softc *wsc;
	int media;
d865 3
a867 6
we_params(asict, asich, typep, memsizep, is16bitp, is790p)
	bus_space_tag_t asict;
	bus_space_handle_t asich;
	u_int8_t *typep;
	bus_size_t *memsizep;
	int *is16bitp, *is790p;
@


1.14
log
@Do not redefine ALIGNED_POINTER, it comes from <machine/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.13 2005/06/08 17:03:00 henning Exp $	*/
d366 2
d375 2
a376 1
		printf(": can't map nic i/o space\n");
d382 2
a383 1
		printf(": can't subregion i/o space\n");
d390 2
a391 1
		printf(": where did the card go?\n");
d402 2
a403 1
		printf(": can't map shared memory\n");
d433 2
a434 1
	printf(": %s (%s-bit)\n", typestr, wsc->sc_16bitp ? "16" : "8");
d533 1
a533 1
		printf("%s: configuration failed\n", sc->sc_dev.dv_xname);
@


1.13
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.12 2004/05/12 06:35:11 tedu Exp $	*/
a682 3
#ifdef alpha
#define ALIGNED_POINTER(p,t)	((((u_long)(p)) & (sizeof(t)-1)) == 0)
#endif
@


1.12
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.11 2003/04/17 03:49:52 drahn Exp $	*/
a88 5

#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif
@


1.11
log
@Remove a bogus ALIGNED_POINTER, this is now defined in proper i386 headers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.10 2002/03/14 01:26:56 millert Exp $	*/
a96 1
#include <net/bpfdesc.h>
@


1.10
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.9 2001/03/12 05:37:00 aaron Exp $	*/
a688 3
#ifdef i386
#define ALIGNED_POINTER(p,t)	1
#endif
@


1.9
log
@Adjust the way that media is initialized on DP8390-compatibles; from NetBSD.
The dp8390_softc now has media_init and media_fini function pointers that
do the work. fgsch@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.8 2000/04/03 07:43:53 deraadt Exp $	*/
d133 2
a134 2
int	we_probe __P((struct device *, void *, void *));
void	we_attach __P((struct device *, struct device *, void *));
d154 15
a168 15
const char *we_params __P((bus_space_tag_t, bus_space_handle_t, u_int8_t *,
	    bus_size_t *, int *, int *));
void	we_set_media __P((struct we_softc *, int));

void	we_media_init __P((struct dp8390_softc *));

int	we_mediachange __P((struct dp8390_softc *));
void	we_mediastatus __P((struct dp8390_softc *, struct ifmediareq *));

void	we_recv_int __P((struct dp8390_softc *));
void	we_init_card __P((struct dp8390_softc *));
int	we_write_mbuf __P((struct dp8390_softc *, struct mbuf *, int));
int	we_ring_copy __P((struct dp8390_softc *, int, caddr_t, u_short));
void	we_read_hdr __P((struct dp8390_softc *, int, struct dp8390_ring *));
int	we_test_mem __P((struct dp8390_softc *));
d170 1
a170 1
__inline void we_readmem __P((struct we_softc *, int, u_int8_t *, int));
@


1.9.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.9 2001/03/12 05:37:00 aaron Exp $	*/
d133 2
a134 2
int	we_probe(struct device *, void *, void *);
void	we_attach(struct device *, struct device *, void *);
d154 15
a168 15
const char *we_params(bus_space_tag_t, bus_space_handle_t, u_int8_t *,
	    bus_size_t *, int *, int *);
void	we_set_media(struct we_softc *, int);

void	we_media_init(struct dp8390_softc *);

int	we_mediachange(struct dp8390_softc *);
void	we_mediastatus(struct dp8390_softc *, struct ifmediareq *);

void	we_recv_int(struct dp8390_softc *);
void	we_init_card(struct dp8390_softc *);
int	we_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	we_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	we_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	we_test_mem(struct dp8390_softc *);
d170 1
a170 1
__inline void we_readmem(struct we_softc *, int, u_int8_t *, int);
@


1.9.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d689 3
@


1.8
log
@change overriding message
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.7 1998/12/23 07:58:26 aaron Exp $	*/
d158 2
a181 6
int we_media[] = {
	IFM_ETHER|IFM_10_2,
	IFM_ETHER|IFM_10_5,
};
#define	NWE_MEDIA	(sizeof(we_media) / sizeof(we_media[0]))

d527 5
a531 25
	if (wsc->sc_type & WE_SOFTCONFIG) {
		int defmedia = IFM_ETHER;

		if (sc->is790) {
			x = bus_space_read_1(asict, asich, WE790_HWR);
			bus_space_write_1(asict, asich, WE790_HWR,
			    x | WE790_HWR_SWH);
			if (bus_space_read_1(asict, asich, WE790_GCR) &
			    WE790_GCR_GPOUT)
				defmedia |= IFM_10_2;
			else
				defmedia |= IFM_10_5;
			bus_space_write_1(asict, asich, WE790_HWR,
			    x & ~WE790_HWR_SWH);
		} else {
			x = bus_space_read_1(asict, asich, WE_IRR);
			if (x & WE_IRR_OUT2)
				defmedia |= IFM_10_2;
			else
				defmedia |= IFM_10_5;
		}
		i = dp8390_config(sc, we_media, NWE_MEDIA, defmedia);
	} else
		i = dp8390_config(sc, NULL, 0, 0);
	if (i) {
d789 32
@


1.7
log
@whoops; finally this should work with isapnp *and* non-isapnp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.6 1998/12/23 06:02:19 aaron Exp $	*/
d332 1
a332 1
			printf("%s%d: overriding IRQ %d to %d\n",
d343 1
a343 1
			printf("%s%d: overriding IRQ %d to %d\n",
@


1.7.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.9 2001/03/12 05:37:00 aaron Exp $	*/
a157 2
void	we_media_init __P((struct dp8390_softc *));

d180 6
d332 1
a332 1
			printf("%s%d: changing IRQ %d to %d\n",
d343 1
a343 1
			printf("%s%d: changing IRQ %d to %d\n",
d531 25
a555 5
	if (wsc->sc_type & WE_SOFTCONFIG)
		sc->sc_media_init = we_media_init;
	else
		sc->sc_media_init = dp8390_media_init;
	if (dp8390_config(sc)) {
a812 32
}

void
we_media_init(struct dp8390_softc *sc)
{
	struct we_softc *wsc = (void *)sc;
	int defmedia = IFM_ETHER;
	u_int8_t x;

	if (sc->is790) {
		x = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR);
		bus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR,
		    x | WE790_HWR_SWH);
		if (bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE790_GCR) &
		    WE790_GCR_GPOUT)
			defmedia |= IFM_10_2;
		else
			defmedia |= IFM_10_5;
		bus_space_write_1(wsc->sc_asict, wsc->sc_asich, WE790_HWR,
		    x &~ WE790_HWR_SWH);
	} else {
		x = bus_space_read_1(wsc->sc_asict, wsc->sc_asich, WE_IRR);
		if (x & WE_IRR_OUT2)
			defmedia |= IFM_10_2;
		else
			defmedia |= IFM_10_5;
	}

	ifmedia_init(&sc->sc_media, 0, dp8390_mediachange, dp8390_mediastatus);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_2, 0, NULL);
	ifmedia_add(&sc->sc_media, IFM_ETHER|IFM_10_5, 0, NULL);
	ifmedia_set(&sc->sc_media, defmedia);
@


1.7.6.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 2
a134 2
int	we_probe(struct device *, void *, void *);
void	we_attach(struct device *, struct device *, void *);
d154 15
a168 15
const char *we_params(bus_space_tag_t, bus_space_handle_t, u_int8_t *,
	    bus_size_t *, int *, int *);
void	we_set_media(struct we_softc *, int);

void	we_media_init(struct dp8390_softc *);

int	we_mediachange(struct dp8390_softc *);
void	we_mediastatus(struct dp8390_softc *, struct ifmediareq *);

void	we_recv_int(struct dp8390_softc *);
void	we_init_card(struct dp8390_softc *);
int	we_write_mbuf(struct dp8390_softc *, struct mbuf *, int);
int	we_ring_copy(struct dp8390_softc *, int, caddr_t, u_short);
void	we_read_hdr(struct dp8390_softc *, int, struct dp8390_ring *);
int	we_test_mem(struct dp8390_softc *);
d170 1
a170 1
__inline void we_readmem(struct we_softc *, int, u_int8_t *, int);
@


1.7.6.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.7.6.2 2002/03/28 12:11:35 niklas Exp $	*/
d689 3
@


1.7.6.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d97 1
@


1.6
log
@a better fix; deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.5 1998/12/23 00:33:29 aaron Exp $	*/
d380 1
a380 1
	if (ia->ia_ioh)
d404 1
a404 1
	if (ia->ia_memh)
@


1.5
log
@make this driver work again (move _valid assignments out of else{} so they are
performed regardless)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.4 1998/11/28 02:29:29 deraadt Exp $	*/
d245 1
a245 1
	if (ia->ia_ioh)
d250 1
a251 1
	asich_valid = 1;
d305 1
a305 1
	if (ia->ia_memh)
d310 1
a311 1
	memh_valid = 1;
@


1.4
log
@no debug by default
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.3 1998/11/28 01:29:05 deraadt Exp $	*/
a249 1
		asich_valid = 1;
d251 1
a309 1
		memh_valid = 1;
d311 1
@


1.3
log
@first attempt at SMC EtherEZ (8416) on isapnp
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.2 1998/10/04 22:28:14 niklas Exp $	*/
a61 1
#define WE_DEBUG
@


1.2
log
@Use swap16 not bswap16 in OpenBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_we.c,v 1.1 1998/09/22 06:33:19 fgsch Exp $	*/
d60 1
d62 1
d137 1
a137 1
struct cfattach we_ca = {
d141 6
d246 7
a252 3
	if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich))
		goto out;
	asich_valid = 1;
d306 7
a312 3
	if (bus_space_map(memt, ia->ia_maddr, memsize, 0, &memh))
		goto out;
	memh_valid = 1;
a376 2
	printf("\n");

d381 4
a384 3
	if (bus_space_map(asict, ia->ia_iobase, WE_NPORTS, 0, &asich)) {
		printf("%s: can't map nic i/o space\n",
		    sc->sc_dev.dv_xname);
d390 1
a390 2
		printf("%s: can't subregion i/o space\n",
		    sc->sc_dev.dv_xname);
d397 1
a397 1
		printf("%s: where did the card go?\n", sc->sc_dev.dv_xname);
d405 4
a408 3
	if (bus_space_map(memt, ia->ia_maddr, ia->ia_msize, 0, &memh)) {
		printf("%s: can't map shared memory\n",
		    sc->sc_dev.dv_xname);
d438 1
a438 2
	printf("%s: %s Ethernet (%s-bit)\n", sc->sc_dev.dv_xname,
	    typestr, wsc->sc_16bitp ? "16" : "8");
d446 1
a446 1
				bus_space_read_1(asict, asich, WE_PROM + i);
@


1.1
log
@Replace the ed driver.
ec is used for 3c503 cards, we for SMC/WD 80x3 series and ne for ne[12]00.
This also adds ne2k pnp support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d787 1
a787 1
	packet_hdrp->count = bswap16(packet_hdrp->count);
@

