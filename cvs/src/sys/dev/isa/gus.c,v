head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.4
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.43.0.4
	OPENBSD_5_8_BASE:1.43
	OPENBSD_5_7:1.41.0.4
	OPENBSD_5_7_BASE:1.41
	OPENBSD_5_6:1.40.0.4
	OPENBSD_5_6_BASE:1.40
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.38.0.2
	OPENBSD_5_4_BASE:1.38
	OPENBSD_5_3:1.35.0.4
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.2
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.34
	OPENBSD_5_1:1.34.0.8
	OPENBSD_5_0:1.34.0.6
	OPENBSD_5_0_BASE:1.34
	OPENBSD_4_9:1.34.0.4
	OPENBSD_4_9_BASE:1.34
	OPENBSD_4_8:1.34.0.2
	OPENBSD_4_8_BASE:1.34
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.32.0.6
	OPENBSD_4_6_BASE:1.32
	OPENBSD_4_5:1.32.0.2
	OPENBSD_4_5_BASE:1.32
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.29.0.8
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.6
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.29.0.4
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.29.0.2
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.4
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.2
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.25
	OPENBSD_3_3:1.24.0.6
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.24.0.4
	OPENBSD_3_2_BASE:1.24
	OPENBSD_3_1:1.24.0.2
	OPENBSD_3_1_BASE:1.24
	UBC_SYNC_B:1.24
	UBC:1.23.0.6
	UBC_BASE:1.23
	OPENBSD_3_0:1.23.0.4
	OPENBSD_3_0_BASE:1.23
	OPENBSD_2_9_BASE:1.23
	OPENBSD_2_9:1.23.0.2
	OPENBSD_2_8:1.22.0.2
	OPENBSD_2_8_BASE:1.22
	OPENBSD_2_7:1.21.0.6
	OPENBSD_2_7_BASE:1.21
	SMP:1.21.0.4
	SMP_BASE:1.21
	kame_19991208:1.21
	OPENBSD_2_6:1.21.0.2
	OPENBSD_2_6_BASE:1.21
	OPENBSD_2_5:1.20.0.2
	OPENBSD_2_5_BASE:1.20
	OPENBSD_2_4:1.17.0.2
	OPENBSD_2_4_BASE:1.17
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	OPENBSD_2_2:1.12.0.2
	OPENBSD_2_2_BASE:1.12
	OPENBSD_2_1:1.11.0.4
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.05.04.15.19.01;	author bluhm;	state Exp;
branches;
next	1.45;
commitid	v8InGhXbvT4hucXf;

1.45
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.44;
commitid	qGgYgJTgEFuAoGj4;

1.44
date	2016.09.14.06.12.19;	author ratchov;	state Exp;
branches;
next	1.43;
commitid	pi1a9KN0itEngOc4;

1.43
date	2015.06.25.20.05.11;	author ratchov;	state Exp;
branches;
next	1.42;
commitid	1oxFAuaevSf6sg9Y;

1.42
date	2015.05.11.06.46.21;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	RaOGL5SyOGOZylwx;

1.41
date	2014.09.14.14.17.25;	author jsg;	state Exp;
branches;
next	1.40;
commitid	uzzBR7hz9ncd4O6G;

1.40
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.39;
commitid	I19imNlAX05zJOED;

1.39
date	2013.11.15.16.46.27;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2013.06.26.09.39.56;	author kettenis;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.24.07.58.46;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2013.05.15.08.29.24;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2012.02.25.22.33.22;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2010.07.15.03.43.11;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.26.22.29.09;	author jasper;	state Exp;
branches;
next	1.32;

1.32
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.26.05.42.16;	author ray;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.21.00.32.42;	author jakemsr;	state Exp;
branches;
next	1.29;

1.29
date	2006.03.04.12.42.23;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.10.19.22.52.02;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2004.06.13.21.49.24;	author niklas;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.08.00.41.47;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.23;

1.23
date	2001.01.29.05.30.30;	author mickey;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2000.08.19.14.25.15;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	99.07.05.20.08.37;	author deraadt;	state Exp;
branches
	1.21.4.1;
next	1.20;

1.20
date	99.01.24.15.58.53;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	99.01.02.00.02.45;	author niklas;	state Exp;
branches;
next	1.18;

1.18
date	98.11.03.21.14.59;	author downsj;	state Exp;
branches;
next	1.17;

1.17
date	98.08.20.08.37.47;	author provos;	state Exp;
branches;
next	1.16;

1.16
date	98.05.13.10.25.13;	author provos;	state Exp;
branches;
next	1.15;

1.15
date	98.05.08.18.37.21;	author csapuntz;	state Exp;
branches;
next	1.14;

1.14
date	98.04.26.21.02.41;	author provos;	state Exp;
branches;
next	1.13;

1.13
date	98.01.18.18.58.37;	author niklas;	state Exp;
branches;
next	1.12;

1.12
date	97.07.10.23.06.34;	author provos;	state Exp;
branches;
next	1.11;

1.11
date	96.05.26.00.27.15;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.07.07.36.36;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.04.21.22.23.28;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.18.23.47.34;	author niklas;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.01.00.44;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.10.11;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.16.42.54;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.50;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.18;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.14.06.31.07;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.34;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.34;	author deraadt;	state Exp;
branches;
next	;

1.21.4.1
date	2001.05.14.22.24.34;	author niklas;	state Exp;
branches;
next	1.21.4.2;

1.21.4.2
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.21.4.3;

1.21.4.3
date	2003.05.13.19.35.03;	author ho;	state Exp;
branches;
next	1.21.4.4;

1.21.4.4
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	1.21.4.5;

1.21.4.5
date	2004.03.23.08.02.56;	author niklas;	state Exp;
branches;
next	;

1.23.6.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Remove side effects from assignment.  Fixes warning with cppcheck.
No binary change.
OK ratchov@@
@
text
@/*	$OpenBSD: gus.c,v 1.45 2016/09/19 06:46:44 ratchov Exp $	*/
/*	$NetBSD: gus.c,v 1.51 1998/01/25 23:48:06 mycroft Exp $	*/

/*-
 * Copyright (c) 1996 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ken Hornstein and John Kohl.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 *
 * TODO:
 *	. figure out why mixer activity while sound is playing causes problems
 *	  (phantom interrupts?)
 *	. figure out a better deinterleave strategy that avoids sucking up
 *	  CPU, memory and cache bandwidth.  (Maybe a special encoding?
 *	  Maybe use the double-speed sampling/hardware deinterleave trick
 *	  from the GUS SDK?)  A 486/33 isn't quite fast enough to keep
 *	  up with 44.1kHz 16-bit stereo output without some drop-outs.
 *	. use CS4231 for 16-bit sampling, for a-law and mu-law playback.
 *	. actually test full-duplex sampling(recording) and playback.
 */

/*
 * Gravis UltraSound driver
 *
 * For more detailed information, see the GUS developers' kit
 * available on the net at:
 *
 * http://www.gravis.com/Public/sdk/GUSDK222.ZIP
 *
 *		See ultrawrd.doc inside--it's MS Word (ick), but it's the bible
 *
 */

/*
 * The GUS Max has a slightly strange set of connections between the CS4231
 * and the GF1 and the DMA interconnects.  It's set up so that the CS4231 can
 * be playing while the GF1 is loading patches from the system.
 *
 * Here's a recreation of the DMA interconnect diagram:
 *
 *       GF1
 *   +---------+				 digital
 *   |         |  record			 ASIC
 *   |         |--------------+
 *   |         |              |		       +--------+
 *   |         | play (dram)  |      +----+    |	|
 *   |         |--------------(------|-\  |    |   +-+  |
 *   +---------+              |      |  >-|----|---|C|--|------  dma chan 1
 *                            |  +---|-/  |    |   +-+	|
 *                            |  |   +----+    |    |   |
 *                            |	 |   +----+    |    |   |
 *   +---------+        +-+   +--(---|-\  |    |    |   |
 *   |         | play   |8|      |   |  >-|----|----+---|------  dma chan 2
 *   | ---C----|--------|/|------(---|-/  |    |        |
 *   |    ^    |record  |1|      |   +----+    |	|
 *   |    |    |   /----|6|------+	       +--------+
 *   | ---+----|--/     +-+
 *   +---------+
 *     CS4231	8-to-16 bit bus conversion, if needed
 *
 *
 * "C" is an optional combiner.
 *
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/syslog.h>
#include <sys/device.h>
#include <sys/buf.h>
#include <sys/fcntl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/timeout.h>

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/bus.h>
#include <machine/cpufunc.h>
#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/ics2101reg.h>
#include <dev/ic/cs4231reg.h>
#include <dev/ic/ad1848reg.h>
#include <dev/isa/ics2101var.h>
#include <dev/isa/ad1848var.h>
#include <dev/isa/cs4231var.h>
#include "gusreg.h"
#include "gusvar.h"

#ifdef AUDIO_DEBUG
#define GUSPLAYDEBUG	/*XXX*/
#define DPRINTF(x)	if (gusdebug) printf x
#define DMAPRINTF(x)	if (gusdmadebug) printf x
int	gusdebug = 0;
int	gusdmadebug = 0;
#else
#define DPRINTF(x)
#define DMAPRINTF(x)
#endif
int	gus_dostereo = 1;

#define NDMARECS 2048
#ifdef GUSPLAYDEBUG
int	gusstats = 0;

struct dma_record dmarecords[NDMARECS];

int dmarecord_index = 0;
#endif

struct cfdriver gus_cd = {
	NULL, "gus", DV_DULL
};

/*
 * A mapping from IRQ/DRQ values to the values used in the GUS's internal
 * registers.  A zero means that the referenced IRQ/DRQ is invalid
 */
const int gus_irq_map[] = {
	IRQUNK, IRQUNK, 1, 3, IRQUNK, 2, IRQUNK, 4, IRQUNK, 1, IRQUNK, 5, 6,
	IRQUNK, IRQUNK, 7
};
const int gus_drq_map[] = {
	DRQUNK, 1, DRQUNK, 2, DRQUNK, 3, 4, 5
};

/*
 * A list of valid base addresses for the GUS
 */

const int gus_base_addrs[] = {
	0x210, 0x220, 0x230, 0x240, 0x250, 0x260
};
const int gus_addrs = sizeof(gus_base_addrs) / sizeof(gus_base_addrs[0]);

/*
 * Maximum frequency values of the GUS based on the number of currently active
 * voices.  Since the GUS samples a voice every 1.6 us, the maximum frequency
 * is dependent on the number of active voices.  Yes, it is pretty weird.
 */

static const int gus_max_frequency[] = {
		44100,		/* 14 voices */
		41160,		/* 15 voices */
		38587,		/* 16 voices */
		36317,		/* 17 voices */
		34300,		/* 18 voices */
		32494,		/* 19 voices */
		30870,		/* 20 voices */
		29400,		/* 21 voices */
		28063,		/* 22 voices */
		26843,		/* 23 voices */
		25725,		/* 24 voices */
		24696,		/* 25 voices */
		23746,		/* 26 voices */
		22866,		/* 27 voices */
		22050,		/* 28 voices */
		21289,		/* 29 voices */
		20580,		/* 30 voices */
		19916,		/* 31 voices */
		19293		/* 32 voices */
};
/*
 * A mapping of linear volume levels to the logarithmic volume values used
 * by the GF1 chip on the GUS.  From GUS SDK vol1.c.
 */

static const unsigned short gus_log_volumes[512] = {
 0x0000,
 0x0700, 0x07ff, 0x0880, 0x08ff, 0x0940, 0x0980, 0x09c0, 0x09ff, 0x0a20,
 0x0a40, 0x0a60, 0x0a80, 0x0aa0, 0x0ac0, 0x0ae0, 0x0aff, 0x0b10, 0x0b20,
 0x0b30, 0x0b40, 0x0b50, 0x0b60, 0x0b70, 0x0b80, 0x0b90, 0x0ba0, 0x0bb0,
 0x0bc0, 0x0bd0, 0x0be0, 0x0bf0, 0x0bff, 0x0c08, 0x0c10, 0x0c18, 0x0c20,
 0x0c28, 0x0c30, 0x0c38, 0x0c40, 0x0c48, 0x0c50, 0x0c58, 0x0c60, 0x0c68,
 0x0c70, 0x0c78, 0x0c80, 0x0c88, 0x0c90, 0x0c98, 0x0ca0, 0x0ca8, 0x0cb0,
 0x0cb8, 0x0cc0, 0x0cc8, 0x0cd0, 0x0cd8, 0x0ce0, 0x0ce8, 0x0cf0, 0x0cf8,
 0x0cff, 0x0d04, 0x0d08, 0x0d0c, 0x0d10, 0x0d14, 0x0d18, 0x0d1c, 0x0d20,
 0x0d24, 0x0d28, 0x0d2c, 0x0d30, 0x0d34, 0x0d38, 0x0d3c, 0x0d40, 0x0d44,
 0x0d48, 0x0d4c, 0x0d50, 0x0d54, 0x0d58, 0x0d5c, 0x0d60, 0x0d64, 0x0d68,
 0x0d6c, 0x0d70, 0x0d74, 0x0d78, 0x0d7c, 0x0d80, 0x0d84, 0x0d88, 0x0d8c,
 0x0d90, 0x0d94, 0x0d98, 0x0d9c, 0x0da0, 0x0da4, 0x0da8, 0x0dac, 0x0db0,
 0x0db4, 0x0db8, 0x0dbc, 0x0dc0, 0x0dc4, 0x0dc8, 0x0dcc, 0x0dd0, 0x0dd4,
 0x0dd8, 0x0ddc, 0x0de0, 0x0de4, 0x0de8, 0x0dec, 0x0df0, 0x0df4, 0x0df8,
 0x0dfc, 0x0dff, 0x0e02, 0x0e04, 0x0e06, 0x0e08, 0x0e0a, 0x0e0c, 0x0e0e,
 0x0e10, 0x0e12, 0x0e14, 0x0e16, 0x0e18, 0x0e1a, 0x0e1c, 0x0e1e, 0x0e20,
 0x0e22, 0x0e24, 0x0e26, 0x0e28, 0x0e2a, 0x0e2c, 0x0e2e, 0x0e30, 0x0e32,
 0x0e34, 0x0e36, 0x0e38, 0x0e3a, 0x0e3c, 0x0e3e, 0x0e40, 0x0e42, 0x0e44,
 0x0e46, 0x0e48, 0x0e4a, 0x0e4c, 0x0e4e, 0x0e50, 0x0e52, 0x0e54, 0x0e56,
 0x0e58, 0x0e5a, 0x0e5c, 0x0e5e, 0x0e60, 0x0e62, 0x0e64, 0x0e66, 0x0e68,
 0x0e6a, 0x0e6c, 0x0e6e, 0x0e70, 0x0e72, 0x0e74, 0x0e76, 0x0e78, 0x0e7a,
 0x0e7c, 0x0e7e, 0x0e80, 0x0e82, 0x0e84, 0x0e86, 0x0e88, 0x0e8a, 0x0e8c,
 0x0e8e, 0x0e90, 0x0e92, 0x0e94, 0x0e96, 0x0e98, 0x0e9a, 0x0e9c, 0x0e9e,
 0x0ea0, 0x0ea2, 0x0ea4, 0x0ea6, 0x0ea8, 0x0eaa, 0x0eac, 0x0eae, 0x0eb0,
 0x0eb2, 0x0eb4, 0x0eb6, 0x0eb8, 0x0eba, 0x0ebc, 0x0ebe, 0x0ec0, 0x0ec2,
 0x0ec4, 0x0ec6, 0x0ec8, 0x0eca, 0x0ecc, 0x0ece, 0x0ed0, 0x0ed2, 0x0ed4,
 0x0ed6, 0x0ed8, 0x0eda, 0x0edc, 0x0ede, 0x0ee0, 0x0ee2, 0x0ee4, 0x0ee6,
 0x0ee8, 0x0eea, 0x0eec, 0x0eee, 0x0ef0, 0x0ef2, 0x0ef4, 0x0ef6, 0x0ef8,
 0x0efa, 0x0efc, 0x0efe, 0x0eff, 0x0f01, 0x0f02, 0x0f03, 0x0f04, 0x0f05,
 0x0f06, 0x0f07, 0x0f08, 0x0f09, 0x0f0a, 0x0f0b, 0x0f0c, 0x0f0d, 0x0f0e,
 0x0f0f, 0x0f10, 0x0f11, 0x0f12, 0x0f13, 0x0f14, 0x0f15, 0x0f16, 0x0f17,
 0x0f18, 0x0f19, 0x0f1a, 0x0f1b, 0x0f1c, 0x0f1d, 0x0f1e, 0x0f1f, 0x0f20,
 0x0f21, 0x0f22, 0x0f23, 0x0f24, 0x0f25, 0x0f26, 0x0f27, 0x0f28, 0x0f29,
 0x0f2a, 0x0f2b, 0x0f2c, 0x0f2d, 0x0f2e, 0x0f2f, 0x0f30, 0x0f31, 0x0f32,
 0x0f33, 0x0f34, 0x0f35, 0x0f36, 0x0f37, 0x0f38, 0x0f39, 0x0f3a, 0x0f3b,
 0x0f3c, 0x0f3d, 0x0f3e, 0x0f3f, 0x0f40, 0x0f41, 0x0f42, 0x0f43, 0x0f44,
 0x0f45, 0x0f46, 0x0f47, 0x0f48, 0x0f49, 0x0f4a, 0x0f4b, 0x0f4c, 0x0f4d,
 0x0f4e, 0x0f4f, 0x0f50, 0x0f51, 0x0f52, 0x0f53, 0x0f54, 0x0f55, 0x0f56,
 0x0f57, 0x0f58, 0x0f59, 0x0f5a, 0x0f5b, 0x0f5c, 0x0f5d, 0x0f5e, 0x0f5f,
 0x0f60, 0x0f61, 0x0f62, 0x0f63, 0x0f64, 0x0f65, 0x0f66, 0x0f67, 0x0f68,
 0x0f69, 0x0f6a, 0x0f6b, 0x0f6c, 0x0f6d, 0x0f6e, 0x0f6f, 0x0f70, 0x0f71,
 0x0f72, 0x0f73, 0x0f74, 0x0f75, 0x0f76, 0x0f77, 0x0f78, 0x0f79, 0x0f7a,
 0x0f7b, 0x0f7c, 0x0f7d, 0x0f7e, 0x0f7f, 0x0f80, 0x0f81, 0x0f82, 0x0f83,
 0x0f84, 0x0f85, 0x0f86, 0x0f87, 0x0f88, 0x0f89, 0x0f8a, 0x0f8b, 0x0f8c,
 0x0f8d, 0x0f8e, 0x0f8f, 0x0f90, 0x0f91, 0x0f92, 0x0f93, 0x0f94, 0x0f95,
 0x0f96, 0x0f97, 0x0f98, 0x0f99, 0x0f9a, 0x0f9b, 0x0f9c, 0x0f9d, 0x0f9e,
 0x0f9f, 0x0fa0, 0x0fa1, 0x0fa2, 0x0fa3, 0x0fa4, 0x0fa5, 0x0fa6, 0x0fa7,
 0x0fa8, 0x0fa9, 0x0faa, 0x0fab, 0x0fac, 0x0fad, 0x0fae, 0x0faf, 0x0fb0,
 0x0fb1, 0x0fb2, 0x0fb3, 0x0fb4, 0x0fb5, 0x0fb6, 0x0fb7, 0x0fb8, 0x0fb9,
 0x0fba, 0x0fbb, 0x0fbc, 0x0fbd, 0x0fbe, 0x0fbf, 0x0fc0, 0x0fc1, 0x0fc2,
 0x0fc3, 0x0fc4, 0x0fc5, 0x0fc6, 0x0fc7, 0x0fc8, 0x0fc9, 0x0fca, 0x0fcb,
 0x0fcc, 0x0fcd, 0x0fce, 0x0fcf, 0x0fd0, 0x0fd1, 0x0fd2, 0x0fd3, 0x0fd4,
 0x0fd5, 0x0fd6, 0x0fd7, 0x0fd8, 0x0fd9, 0x0fda, 0x0fdb, 0x0fdc, 0x0fdd,
 0x0fde, 0x0fdf, 0x0fe0, 0x0fe1, 0x0fe2, 0x0fe3, 0x0fe4, 0x0fe5, 0x0fe6,
 0x0fe7, 0x0fe8, 0x0fe9, 0x0fea, 0x0feb, 0x0fec, 0x0fed, 0x0fee, 0x0fef,
 0x0ff0, 0x0ff1, 0x0ff2, 0x0ff3, 0x0ff4, 0x0ff5, 0x0ff6, 0x0ff7, 0x0ff8,
 0x0ff9, 0x0ffa, 0x0ffb, 0x0ffc, 0x0ffd, 0x0ffe, 0x0fff};

/*
 * Interface to higher level audio driver
 */
struct audio_hw_if gus_hw_if = {
	gusopen,
	gusclose,
	gus_set_params,

	gus_round_blocksize,

	gus_commit_settings,

	NULL,
	NULL,

	gus_dma_output,
	gus_dma_input,
	gus_halt_out_dma,
	gus_halt_in_dma,
	gus_speaker_ctl,

	NULL,
	gus_mixer_set_port,
	gus_mixer_get_port,
	gus_mixer_query_devinfo,
	gus_malloc,
	gus_free,
	gus_round,
	gus_get_props,

	NULL,
	NULL
};

static struct audio_hw_if gusmax_hw_if = {
	gusmaxopen,
	gusmax_close,
	gusmax_set_params,

	gusmax_round_blocksize,

	gusmax_commit_settings,

	NULL,
	NULL,

	gusmax_dma_output,
	gusmax_dma_input,
	gusmax_halt_out_dma,
	gusmax_halt_in_dma,

	gusmax_speaker_ctl,

	NULL,
	gusmax_mixer_set_port,
	gusmax_mixer_get_port,
	gusmax_mixer_query_devinfo,
	ad1848_malloc,
	ad1848_free,
	ad1848_round,
	gusmax_get_props,

	NULL,
	NULL
};

int
gusopen(void *addr, int flags)
{
	struct gus_softc *sc = addr;

	DPRINTF(("gusopen() called\n"));

	if (sc->sc_flags & GUS_OPEN)
		return EBUSY;

	/*
	 * Some initialization
	 */

	sc->sc_flags |= GUS_OPEN;
	sc->sc_dmabuf = 0;
	sc->sc_playbuf = -1;
	sc->sc_bufcnt = 0;
	sc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;
	sc->sc_voc[GUS_VOICE_LEFT].current_addr = GUS_MEM_OFFSET;

	if (HAS_CODEC(sc)) {
		ad1848_open(&sc->sc_codec, flags);
		sc->sc_codec.mute[AD1848_AUX1_CHANNEL] = 0;
		ad1848_mute_channel(&sc->sc_codec, AD1848_AUX1_CHANNEL, 0); /* turn on DAC output */
		if (flags & FREAD) {
			sc->sc_codec.mute[AD1848_MONO_CHANNEL] = 0;
			ad1848_mute_channel(&sc->sc_codec, AD1848_MONO_CHANNEL, 0);
		}
	} else if (flags & FREAD) {
		/* enable/unmute the microphone */
		if (HAS_MIXER(sc)) {
			gusics_mic_mute(&sc->sc_mixer, 0);
		} else
			gus_mic_ctl(sc, SPKR_ON);
	}
	if (sc->sc_nbufs == 0)
	    gus_round_blocksize(sc, GUS_BUFFER_MULTIPLE); /* default blksiz */
	return 0;
}

int
gusmaxopen(void *addr, int flags)
{
	struct ad1848_softc *ac = addr;
	return gusopen(ac->parent, flags);
}

void
gus_deinterleave(struct gus_softc *sc, void *buf, int size)
{
	/* deinterleave the stereo data.  We can use sc->sc_deintr_buf
	   for scratch space. */
	int i;

	if (size > sc->sc_blocksize) {
		printf("gus: deinterleave %d > %d\n", size, sc->sc_blocksize);
		return;
	} else if (size < sc->sc_blocksize) {
		DPRINTF(("gus: deinterleave %d < %d\n", size, sc->sc_blocksize));
	}

	/*
	 * size is in bytes.
	 */
	if (sc->sc_precision == 16) {
		u_short *dei = sc->sc_deintr_buf;
		u_short *sbuf = buf;
		size >>= 1;		/* bytecnt to shortcnt */
		/* copy 2nd of each pair of samples to the staging area, while
		   compacting the 1st of each pair into the original area. */
		for (i = 0; i < size/2-1; i++)  {
			dei[i] = sbuf[i*2+1];
			sbuf[i+1] = sbuf[i*2+2];
		}
		/*
		 * this has copied one less sample than half of the
		 * buffer.  The first sample of the 1st stream was
		 * already in place and didn't need copying.
		 * Therefore, we've moved all of the 1st stream's
		 * samples into place.  We have one sample from 2nd
		 * stream in the last slot of original area, not
		 * copied to the staging area (But we don't need to!).
		 * Copy the remainder of the original stream into place.
		 */
		bcopy(dei, &sbuf[size/2], i * sizeof(short));
	} else {
		u_char *dei = sc->sc_deintr_buf;
		u_char *sbuf = buf;
		for (i = 0; i < size/2-1; i++)  {
			dei[i] = sbuf[i*2+1];
			sbuf[i+1] = sbuf[i*2+2];
		}
		bcopy(dei, &sbuf[size/2], i);
	}
}

/*
 * Actually output a buffer to the DSP chip
 */

int
gusmax_dma_output(void *addr, void *buf, int size, void (*intr)(void *),
    void *arg)
{
	struct ad1848_softc *ac = addr;
	return gus_dma_output(ac->parent, buf, size, intr, arg);
}

/*
 * called at splaudio() from interrupt handler.
 */
void
stereo_dmaintr(void *arg)
{
    struct gus_softc *sc = arg;
    struct stereo_dma_intr *sa = &sc->sc_stereo;

    DMAPRINTF(("stereo_dmaintr"));

    /*
     * Put other half in its place, then call the real interrupt routine :)
     */

    sc->sc_dmaoutintr = sa->intr;
    sc->sc_outarg = sa->arg;

#ifdef GUSPLAYDEBUG
    if (gusstats) {
      microtime(&dmarecords[dmarecord_index].tv);
      dmarecords[dmarecord_index].gusaddr = sa->dmabuf;
      dmarecords[dmarecord_index].bsdaddr = sa->buffer;
      dmarecords[dmarecord_index].count = sa->size;
      dmarecords[dmarecord_index].channel = 1;
      dmarecords[dmarecord_index++].direction = 1;
      dmarecord_index = dmarecord_index % NDMARECS;
    }
#endif

    gusdmaout(sc, sa->flags, sa->dmabuf, (caddr_t) sa->buffer, sa->size);

    sa->flags = 0;
    sa->dmabuf = 0;
    sa->buffer = 0;
    sa->size = 0;
    sa->intr = 0;
    sa->arg = 0;
}

/*
 * Start up DMA output to the card.
 * Called at splaudio(), either from intr handler or from
 * generic audio code.
 */
int
gus_dma_output(void *addr, void *buf, int size, void (*intr)(void *), void *arg)
{
	struct gus_softc *sc = addr;
	u_char *buffer = buf;
	u_long boarddma;
	int flags;

	DMAPRINTF(("gus_dma_output %d @@ %p\n", size, buf));
	if (size != sc->sc_blocksize) {
	    DPRINTF(("gus_dma_output reqsize %d not sc_blocksize %d\n",
		     size, sc->sc_blocksize));
	    return EINVAL;
	}

	flags = GUSMASK_DMA_WRITE;
	if (sc->sc_precision == 16)
	    flags |= GUSMASK_DMA_DATA_SIZE;
	if (sc->sc_encoding == AUDIO_ENCODING_ULAW ||
	    sc->sc_encoding == AUDIO_ENCODING_ALAW ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE)
	    flags |= GUSMASK_DMA_INVBIT;

	if (sc->sc_channels == 2) {
		if (sc->sc_precision == 16) {
			if (size & 3) {
				DPRINTF(("gus_dma_output: unpaired 16bit samples"));
				size &= 3;
			}
		} else if (size & 1) {
			DPRINTF(("gus_dma_output: unpaired samples"));
			size &= 1;
		}
		if (size == 0) {
			return 0;
		}

		gus_deinterleave(sc, (void *)buffer, size);

		size >>= 1;

		boarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;

		sc->sc_stereo.intr = intr;
		sc->sc_stereo.arg = arg;
		sc->sc_stereo.size = size;
		sc->sc_stereo.dmabuf = boarddma + GUS_LEFT_RIGHT_OFFSET;
		sc->sc_stereo.buffer = buffer + size;
		sc->sc_stereo.flags = flags;
		if (gus_dostereo) {
		  intr = stereo_dmaintr;
		  arg = sc;
		}
	} else
		boarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;


	sc->sc_flags |= GUS_LOCKED;
	sc->sc_dmaoutintr = intr;
	sc->sc_outarg = arg;

#ifdef GUSPLAYDEBUG
	if (gusstats) {
	  microtime(&dmarecords[dmarecord_index].tv);
	  dmarecords[dmarecord_index].gusaddr = boarddma;
	  dmarecords[dmarecord_index].bsdaddr = buffer;
	  dmarecords[dmarecord_index].count = size;
	  dmarecords[dmarecord_index].channel = 0;
	  dmarecords[dmarecord_index++].direction = 1;
	  dmarecord_index = dmarecord_index % NDMARECS;
	}
#endif

	gusdmaout(sc, flags, boarddma, (caddr_t) buffer, size);
	return 0;
}

void
gusmax_close(void *addr)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;
#if 0
	ac->mute[AD1848_AUX1_CHANNEL] = MUTE_ALL;
	ad1848_mute_channel(ac, MUTE_ALL); /* turn off DAC output */
#endif
	ad1848_close(ac);
	gusclose(sc);
}

/*
 * Close out device stuff.  Called at splaudio() from generic audio layer.
 */
void
gusclose(void *addr)
{
	struct gus_softc *sc = addr;

        DPRINTF(("gus_close: sc=%p\n", sc));

/*	if (sc->sc_flags & GUS_DMAOUT_ACTIVE) */ {
		gus_halt_out_dma(sc);
	}
/*	if (sc->sc_flags & GUS_DMAIN_ACTIVE) */ {
		gus_halt_in_dma(sc);
	}
	sc->sc_flags &= ~(GUS_OPEN|GUS_LOCKED|GUS_DMAOUT_ACTIVE|GUS_DMAIN_ACTIVE);

	if (sc->sc_deintr_buf) {
		free(sc->sc_deintr_buf, M_DEVBUF, 0);
		sc->sc_deintr_buf = NULL;
	}
	/* turn off speaker, etc. */

	/* make sure the voices shut up: */
	gus_stop_voice(sc, GUS_VOICE_LEFT, 1);
	gus_stop_voice(sc, GUS_VOICE_RIGHT, 0);
}

/*
 * Service interrupts.  Farm them off to helper routines if we are using the
 * GUS for simple playback/record
 */

#ifdef AUDIO_DEBUG
int gusintrcnt;
int gusdmaintrcnt;
int gusvocintrcnt;
#endif

int
gusintr(void *arg)
{
	struct gus_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	unsigned char intr;

	int retval = 0;

	DPRINTF(("gusintr\n"));
#ifdef AUDIO_DEBUG
	gusintrcnt++;
#endif
	if (HAS_CODEC(sc))
		retval = ad1848_intr(&sc->sc_codec);
	mtx_enter(&audio_lock);
	if ((intr = bus_space_read_1(iot, ioh1, GUS_IRQ_STATUS)) & GUSMASK_IRQ_DMATC) {
		DMAPRINTF(("gusintr dma flags=%x\n", sc->sc_flags));
#ifdef AUDIO_DEBUG
		gusdmaintrcnt++;
#endif
		retval += gus_dmaout_intr(sc);
		if (sc->sc_flags & GUS_DMAIN_ACTIVE) {
		    SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
		    intr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
		    if (intr & GUSMASK_SAMPLE_DMATC) {
			retval += gus_dmain_intr(sc);
		    }
		}
	}
	if (intr & (GUSMASK_IRQ_VOICE | GUSMASK_IRQ_VOLUME)) {
		DMAPRINTF(("gusintr voice flags=%x\n", sc->sc_flags));
#ifdef AUDIO_DEBUG
		gusvocintrcnt++;
#endif
		retval += gus_voice_intr(sc);
	}
	if (retval) {
		mtx_leave(&audio_lock);
		return 1;
	}
	mtx_leave(&audio_lock);
	return retval;
}

int gus_bufcnt[GUS_MEM_FOR_BUFFERS / GUS_BUFFER_MULTIPLE];
int gus_restart;				/* how many restarts? */
int gus_stops;				/* how many times did voice stop? */
int gus_falsestops;			/* stopped but not done? */
int gus_continues;

struct playcont {
	struct timeval tv;
	u_int playbuf;
	u_int dmabuf;
	u_char bufcnt;
	u_char vaction;
	u_char voccntl;
	u_char volcntl;
	u_long curaddr;
	u_long endaddr;
} playstats[NDMARECS];

int playcntr;

void
gus_dmaout_timeout(void *arg)
{
	struct gus_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	printf("%s: dmaout timeout\n", sc->sc_dev.dv_xname);
	/*
	 * Stop any DMA.
	 */

	mtx_enter(&audio_lock);
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);
 
#if 0
	/* XXX we will dmadone below? */
	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
#endif
 
	gus_dmaout_dointr(sc);
	mtx_leave(&audio_lock);
}


/*
 * Service DMA interrupts.  This routine will only get called if we're doing
 * a DMA transfer for playback/record requests from the audio layer.
 */

int
gus_dmaout_intr(struct gus_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	/*
	 * If we got a DMA transfer complete from the GUS DRAM, then deal
	 * with it.
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	if (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {
	    timeout_del(&sc->sc_dma_tmo);
	    gus_dmaout_dointr(sc);
	    return 1;
	}
	return 0;
}

void
gus_dmaout_dointr(struct gus_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	/* sc->sc_dmaoutcnt - 1 because DMA controller counts from zero?. */
	isa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);
	sc->sc_flags &= ~GUS_DMAOUT_ACTIVE;  /* pending DMA is done */
	DMAPRINTF(("gus_dmaout_dointr %d @@ %p\n", sc->sc_dmaoutcnt,
		   sc->sc_dmaoutaddr));

	/*
	 * to prevent clicking, we need to copy last sample
	 * from last buffer to scratch area just before beginning of
	 * buffer.  However, if we're doing formats that are converted by
	 * the card during the DMA process, we need to pick up the converted
	 * byte rather than the one we have in memory.
	 */
	if (sc->sc_dmabuf == sc->sc_nbufs - 1) {
	  int i;
	  switch (sc->sc_encoding) {
	  case AUDIO_ENCODING_SLINEAR_LE:
	  case AUDIO_ENCODING_SLINEAR_BE:
	    if (sc->sc_precision == 8)
	      goto byte;
	    /* we have the native format */
	    for (i = 1; i <= 2; i++)
	      guspoke(iot, ioh2, sc->sc_gusaddr -
		      (sc->sc_nbufs - 1) * sc->sc_chanblocksize - i,
		      sc->sc_dmaoutaddr[sc->sc_dmaoutcnt-i]);
	    break;
	  case AUDIO_ENCODING_ULINEAR_LE:
	  case AUDIO_ENCODING_ULINEAR_BE:
	    guspoke(iot, ioh2, sc->sc_gusaddr -
		    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 2,
		    guspeek(iot, ioh2,
			    sc->sc_gusaddr + sc->sc_chanblocksize - 2));
	  case AUDIO_ENCODING_ALAW:
	  case AUDIO_ENCODING_ULAW:
	  byte:
	    /* we need to fetch the translated byte, then stuff it. */
	    guspoke(iot, ioh2, sc->sc_gusaddr -
		    (sc->sc_nbufs - 1) * sc->sc_chanblocksize - 1,
		    guspeek(iot, ioh2,
			    sc->sc_gusaddr + sc->sc_chanblocksize - 1));
	    break;
	  }
	}
	/*
	 * If this is the first half of stereo, "ignore" this one
	 * and copy out the second half.
	 */
	if (sc->sc_dmaoutintr == stereo_dmaintr) {
	    (*sc->sc_dmaoutintr)(sc->sc_outarg);
	    return;
	}
	/*
	 * If the voice is stopped, then start it.  Reset the loop
	 * and roll bits.  Call the audio layer routine, since if
	 * we're starting a stopped voice, that means that the next
	 * buffer can be filled
	 */

	sc->sc_flags &= ~GUS_LOCKED;
	if (sc->sc_voc[GUS_VOICE_LEFT].voccntl &
	    GUSMASK_VOICE_STOPPED) {
	    if (sc->sc_flags & GUS_PLAYING) {
		printf("%s: playing yet stopped?\n", sc->sc_dev.dv_xname);
	    }
	    sc->sc_bufcnt++; /* another yet to be played */
	    gus_start_playing(sc, sc->sc_dmabuf);
	    gus_restart++;
	} else {
	    /*
	     * set the sound action based on which buffer we
	     * just transferred.  If we just transferred buffer 0
	     * we want the sound to loop when it gets to the nth
	     * buffer; if we just transferred
	     * any other buffer, we want the sound to roll over
	     * at least one more time.  The voice interrupt
	     * handlers will take care of accounting &
	     * setting control bits if it's not caught up to us
	     * yet.
	     */
	    if (++sc->sc_bufcnt == 2) {
		/*
		 * XXX
		 * If we're too slow in reaction here,
		 * the voice could be just approaching the
		 * end of its run.  It should be set to stop,
		 * so these adjustments might not DTRT.
		 */
		if (sc->sc_dmabuf == 0 &&
		    sc->sc_playbuf == sc->sc_nbufs - 1) {
		    /* player is just at the last buf, we're at the
		       first.  Turn on looping, turn off rolling. */
		    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;
		    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~GUSMASK_VOICE_ROLL;
		    playstats[playcntr].vaction = 3;
		} else {
		    /* player is at previous buf:
		       turn on rolling, turn off looping */
		    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;
		    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;
		    playstats[playcntr].vaction = 4;
		}
#ifdef GUSPLAYDEBUG
		if (gusstats) {
		  microtime(&playstats[playcntr].tv);
		  playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;
		  playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;
		  playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;
		  playstats[playcntr].playbuf = sc->sc_playbuf;
		  playstats[playcntr].dmabuf = sc->sc_dmabuf;
		  playstats[playcntr].bufcnt = sc->sc_bufcnt;
		  playstats[playcntr++].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);
		  playcntr = playcntr % NDMARECS;
		}
#endif
		bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);
		SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);
		SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);
	    }
	}
	gus_bufcnt[sc->sc_bufcnt-1]++;
	/*
	 * flip to the next DMA buffer
	 */

	sc->sc_dmabuf = (sc->sc_dmabuf + 1) % sc->sc_nbufs;
	/*
	 * See comments below about DMA admission control strategy.
	 * We can call the upper level here if we have an
	 * idle buffer (not currently playing) to DMA into.
	 */
	if (sc->sc_dmaoutintr && sc->sc_bufcnt < sc->sc_nbufs) {
	    /* clean out to prevent double calls */
	    void (*pfunc)(void *) = sc->sc_dmaoutintr;
	    void *arg = sc->sc_outarg;

	    sc->sc_outarg = 0;
	    sc->sc_dmaoutintr = 0;
	    (*pfunc)(arg);
	}
}

/*
 * Service voice interrupts
 */

int
gus_voice_intr(struct gus_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	int ignore = 0, voice, rval = 0;
	unsigned char intr, status;

	/*
	 * The point of this may not be obvious at first.  A voice can
	 * interrupt more than once; according to the GUS SDK we are supposed
	 * to ignore multiple interrupts for the same voice.
	 */

	while(1) {
		SELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);
		intr = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);

		if ((intr & (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))
			== (GUSMASK_WIRQ_VOLUME | GUSMASK_WIRQ_VOICE))
			/*
			 * No more interrupts, time to return
			 */
			return rval;

		if ((intr & GUSMASK_WIRQ_VOICE) == 0) {

		    /*
		     * We've got a voice interrupt.  Ignore previous
		     * interrupts by the same voice.
		     */

		    rval = 1;
		    voice = intr & GUSMASK_WIRQ_VOICEMASK;

		    if ((1 << voice) & ignore)
			break;

		    ignore |= 1 << voice;

		    /*
		     * If the voice is stopped, then force it to stop
		     * (this stops it from continuously generating IRQs)
		     */

		    SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL+0x80);
		    status = bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
		    if (status & GUSMASK_VOICE_STOPPED) {
			if (voice != GUS_VOICE_LEFT) {
			    DMAPRINTF(("%s: spurious voice %d stop?\n",
				       sc->sc_dev.dv_xname, voice));
			    gus_stop_voice(sc, voice, 0);
			    continue;
			}
			gus_stop_voice(sc, voice, 1);
			/* also kill right voice */
			gus_stop_voice(sc, GUS_VOICE_RIGHT, 0);
			sc->sc_bufcnt--; /* it finished a buffer */
			if (sc->sc_bufcnt > 0) {
			    /*
			     * probably a race to get here: the voice
			     * stopped while the DMA code was just trying to
			     * get the next buffer in place.
			     * Start the voice again.
			     */
			    printf("%s: stopped voice not drained? (%x)\n",
				   sc->sc_dev.dv_xname, sc->sc_bufcnt);
			    gus_falsestops++;

			    sc->sc_playbuf = (sc->sc_playbuf + 1) % sc->sc_nbufs;
			    gus_start_playing(sc, sc->sc_playbuf);
			} else if (sc->sc_bufcnt < 0) {
			    panic("%s: negative bufcnt in stopped voice",
				   sc->sc_dev.dv_xname);
			} else {
			    sc->sc_playbuf = -1; /* none are active */
			    gus_stops++;
			}
			/* fall through to callback and admit another
			   buffer.... */
		    } else if (sc->sc_bufcnt != 0) {
			/*
			 * This should always be taken if the voice
			 * is not stopped.
			 */
			gus_continues++;
			if (gus_continue_playing(sc, voice)) {
				/*
				 * we shouldn't have continued--active DMA
				 * is in the way in the ring, for
				 * some as-yet undebugged reason.
				 */
				gus_stop_voice(sc, GUS_VOICE_LEFT, 1);
				/* also kill right voice */
				gus_stop_voice(sc, GUS_VOICE_RIGHT, 0);
				sc->sc_playbuf = -1;
				gus_stops++;
			}
		    }
		    /*
		     * call the upper level to send on down another
		     * block. We do admission rate control as follows:
		     *
		     * When starting up output (in the first N
		     * blocks), call the upper layer after the DMA is
		     * complete (see above in gus_dmaout_intr()).
		     *
		     * When output is already in progress and we have
		     * no more GUS buffers to use for DMA, the DMA
		     * output routines do not call the upper layer.
		     * Instead, we call the DMA completion routine
		     * here, after the voice interrupts indicating
		     * that it's finished with a buffer.
		     *
		     * However, don't call anything here if the DMA
		     * output flag is set, (which shouldn't happen)
		     * because we'll squish somebody else's DMA if
		     * that's the case.  When DMA is done, it will
		     * call back if there is a spare buffer.
		     */
		    if (sc->sc_dmaoutintr && !(sc->sc_flags & GUS_LOCKED)) {
			if (sc->sc_dmaoutintr == stereo_dmaintr)
			    printf("gusdmaout botch?\n");
			else {
			    /* clean out to avoid double calls */
			    void (*pfunc)(void *) = sc->sc_dmaoutintr;
			    void *arg = sc->sc_outarg;

			    sc->sc_outarg = 0;
			    sc->sc_dmaoutintr = 0;
			    (*pfunc)(arg);
			}
		    }
		}

		/*
		 * Ignore other interrupts for now
		 */
	}
	return 0;
}

void
gus_start_playing(struct gus_softc *sc, int bufno)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	/*
	 * Start the voices playing, with buffer BUFNO.
	 */

	/*
	 * Loop or roll if we have buffers ready.
	 */

	if (sc->sc_bufcnt == 1) {
		sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);
		sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);
	} else {
		if (bufno == sc->sc_nbufs - 1) {
			sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;
			sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);
		} else {
			sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;
			sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;
		}
	}

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_LEFT);

	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);

	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);

	sc->sc_voc[GUS_VOICE_LEFT].current_addr =
		GUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;
	sc->sc_voc[GUS_VOICE_LEFT].end_addr =
		sc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;
	sc->sc_voc[GUS_VOICE_RIGHT].current_addr =
		sc->sc_voc[GUS_VOICE_LEFT].current_addr +
		(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);
	/*
	 * set up right channel to just loop forever, no interrupts,
	 * starting at the buffer we just filled.  We'll feed it data
	 * at the same time as left channel.
	 */
	sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;
	sc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);

#ifdef GUSPLAYDEBUG
	if (gusstats) {
		microtime(&playstats[playcntr].tv);
		playstats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;

		playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;
		playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;
		playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;
		playstats[playcntr].playbuf = bufno;
		playstats[playcntr].dmabuf = sc->sc_dmabuf;
		playstats[playcntr].bufcnt = sc->sc_bufcnt;
		playstats[playcntr++].vaction = 5;
		playcntr = playcntr % NDMARECS;
	}
#endif

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, GUS_VOICE_RIGHT);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);

	gus_start_voice(sc, GUS_VOICE_RIGHT, 0);
	gus_start_voice(sc, GUS_VOICE_LEFT, 1);
	if (sc->sc_playbuf == -1)
		/* mark start of playing */
		sc->sc_playbuf = bufno;
}

int
gus_continue_playing(struct gus_softc *sc, int voice)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	/*
	 * stop this voice from interrupting while we work.
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));

	/*
	 * update playbuf to point to the buffer the hardware just started
	 * playing
	 */
	sc->sc_playbuf = (sc->sc_playbuf + 1) % sc->sc_nbufs;

	/*
	 * account for buffer just finished
	 */
	if (--sc->sc_bufcnt == 0) {
		DPRINTF(("gus: bufcnt 0 on continuing voice?\n"));
	}
	if (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {
		printf("%s: continue into active dmabuf?\n", sc->sc_dev.dv_xname);
		return 1;
	}

	/*
	 * Select the end of the buffer based on the currently active
	 * buffer, [plus extra contiguous buffers (if ready)].
	 */

	/*
	 * set endpoint at end of buffer we just started playing.
	 *
	 * The total gets -1 because end addrs are one less than you might
	 * think (the end_addr is the address of the last sample to play)
	 */
	gus_set_endaddr(sc, voice, GUS_MEM_OFFSET +
			sc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);

	if (sc->sc_bufcnt < 2) {
		/*
		 * Clear out the loop and roll flags, and rotate the currently
		 * playing buffer.  That way, if we don't manage to get more
		 * data before this buffer finishes, we'll just stop.
		 */
		sc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;
		sc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;
		playstats[playcntr].vaction = 0;
	} else {
		/*
		 * We have some buffers to play.  set LOOP if we're on the
		 * last buffer in the ring, otherwise set ROLL.
		 */
		if (sc->sc_playbuf == sc->sc_nbufs - 1) {
			sc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;
			sc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;
			playstats[playcntr].vaction = 1;
		} else {
			sc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;
			sc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;
			playstats[playcntr].vaction = 2;
		}
	}
#ifdef GUSPLAYDEBUG
	if (gusstats) {
		microtime(&playstats[playcntr].tv);
		playstats[playcntr].curaddr = gus_get_curaddr(sc, voice);

		playstats[playcntr].voccntl = sc->sc_voc[voice].voccntl;
		playstats[playcntr].volcntl = sc->sc_voc[voice].volcntl;
		playstats[playcntr].endaddr = sc->sc_voc[voice].end_addr;
		playstats[playcntr].playbuf = sc->sc_playbuf;
		playstats[playcntr].dmabuf = sc->sc_dmabuf;
		playstats[playcntr++].bufcnt = sc->sc_bufcnt;
		playcntr = playcntr % NDMARECS;
	}
#endif

	/*
	 * (re-)set voice parameters.  This will reenable interrupts from this
	 * voice.
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);
	return 0;
}

/*
 * Send/receive data into GUS's DRAM using DMA.  Called at splaudio()
 */

void
gusdmaout(struct gus_softc *sc, int flags, u_long gusaddr, caddr_t buffaddr,
    int length)
{
	unsigned char c = (unsigned char) flags;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	DMAPRINTF(("gusdmaout flags=%x scflags=%x\n", flags, sc->sc_flags));

	sc->sc_gusaddr = gusaddr;

	/*
	 * If we're using a 16 bit DMA channel, we have to jump through some
	 * extra hoops; this includes translating the DRAM address a bit
	 */

	if (sc->sc_drq >= 4) {
		c |= GUSMASK_DMA_WIDTH;
		gusaddr = convert_to_16bit(gusaddr);
	}

	/*
	 * Add flag bits that we always set - fast DMA, enable IRQ
	 */

	c |= GUSMASK_DMA_ENABLE | GUSMASK_DMA_R0 | GUSMASK_DMA_IRQ;

	/*
	 * Make sure the GUS _isn't_ setup for DMA
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);

	/*
	 * Tell the PC DMA controller to start doing DMA
	 */

	sc->sc_dmaoutaddr = (u_char *) buffaddr;
	sc->sc_dmaoutcnt = length;
	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,
	    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);

	/*
	 * Set up DMA address - use the upper 16 bits ONLY
	 */

	sc->sc_flags |= GUS_DMAOUT_ACTIVE;

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));

	/*
	 * Tell the GUS to start doing DMA
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, c);

	/*
	 * XXX If we don't finish in one second, give up...
	 */
	timeout_add_sec(&sc->sc_dma_tmo, 1);
}

/*
 * Start a voice playing on the GUS.  Called from interrupt handler at
 * splaudio().
 */

void
gus_start_voice(struct gus_softc *sc, int voice, int intrs)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	u_long start;
	u_long current;
	u_long end;

	/*
	 * Pick all the values for the voice out of the gus_voice struct
	 * and use those to program the voice
	 */

	start = sc->sc_voc[voice].start_addr;
	current = sc->sc_voc[voice].current_addr;
	end = sc->sc_voc[voice].end_addr;

	/*
	 * If we're using 16 bit data, mangle the addresses a bit
	 */

	if (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16) {
	        /* -1 on start so that we get onto sample boundary--other
		   code always sets it for 1-byte rollover protection */
		start = convert_to_16bit(start-1);
		current = convert_to_16bit(current);
		end = convert_to_16bit(end);
	}

	/*
	 * Select the voice we want to use, and program the data addresses
	 */

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);

	SELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(start));
	SELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(start));

	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(current));
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(current));

	SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(end));
	SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(end));

	/*
	 * (maybe) enable interrupts, disable voice stopping
	 */

	if (intrs) {
		sc->sc_flags |= GUS_PLAYING; /* playing is about to start */
		sc->sc_voc[voice].voccntl |= GUSMASK_VOICE_IRQ;
		DMAPRINTF(("gus voice playing=%x\n", sc->sc_flags));
	} else
		sc->sc_voc[voice].voccntl &= ~GUSMASK_VOICE_IRQ;
	sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_STOPPED |
		GUSMASK_STOP_VOICE);

	/*
	 * Tell the GUS about it.  Note that we're doing volume ramping here
	 * from 0 up to the set volume to help reduce clicks.
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x00);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 63);

	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
	delay(50);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

}

/*
 * Stop a given voice.  Called at splaudio().
 */

void
gus_stop_voice(struct gus_softc *sc, int voice, int intrs_too)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	sc->sc_voc[voice].voccntl |= GUSMASK_VOICE_STOPPED |
		GUSMASK_STOP_VOICE;
	if (intrs_too) {
	  sc->sc_voc[voice].voccntl &= ~(GUSMASK_VOICE_IRQ);
	  /* no more DMA to do */
	  sc->sc_flags &= ~GUS_PLAYING;
	}
	DMAPRINTF(("gusintr voice notplaying=%x\n", sc->sc_flags));

	guspoke(iot, ioh2, 0L, 0);

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);

	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	delay(100);
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);

	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);

}


/*
 * Set the volume of a given voice.  Called at splaudio().
 */
void
gus_set_volume(struct gus_softc *sc, int voice, int volume)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	unsigned int gusvol;

	gusvol = gus_log_volumes[volume < 512 ? volume : 511];

	sc->sc_voc[voice].current_volume = gusvol;

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);

	SELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));

	SELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));

	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);
	delay(500);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, gusvol << 4);

}

/*
 * Interface to the audio layer.
 */

int
gusmax_set_params(void *addr, int setmode, int usemode, struct audio_params *p,
    struct audio_params *r)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;
	int error;

	error = ad1848_set_params(ac, setmode, usemode, p, r);
	if (error)
		return error;
	error = gus_set_params(sc, setmode, usemode, p, r);
	return error;
}

int
gus_set_params(void *addr, int setmode, int usemode, struct audio_params *p,
    struct audio_params *r)
{
	struct gus_softc *sc = addr;

	switch (p->encoding) {
	case AUDIO_ENCODING_SLINEAR_LE:
	case AUDIO_ENCODING_ULINEAR_LE:
		break;
	default:
		return (EINVAL);
	}

	/* XXX: why?! this is called with interrupts disabled */
	mtx_enter(&audio_lock);

	if (p->precision == 8) {
		sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;
		sc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;
	} else {
		sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;
		sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;
	}

	sc->sc_encoding = p->encoding;
	sc->sc_precision = p->precision;
	sc->sc_channels = p->channels;

	mtx_leave(&audio_lock);

	if (p->sample_rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])
		p->sample_rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];
	if (setmode & AUMODE_RECORD)
		sc->sc_irate = p->sample_rate;
	if (setmode & AUMODE_PLAY)
		sc->sc_orate = p->sample_rate;

	p->bps = AUDIO_BPS(p->precision);
	r->bps = AUDIO_BPS(r->precision);
	p->msb = r->msb = 1;

	return 0;
}

/*
 * Interface to the audio layer - set the blocksize to the correct number
 * of units
 */

int
gusmax_round_blocksize(void *addr, int blocksize)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;

/*	blocksize = ad1848_round_blocksize(ac, blocksize);*/
	return gus_round_blocksize(sc, blocksize);
}

int
gus_round_blocksize(addr, blocksize)
	void * addr;
	int blocksize;
{
	struct gus_softc *sc = addr;

	DPRINTF(("gus_round_blocksize called\n"));

	if ((sc->sc_encoding == AUDIO_ENCODING_ULAW ||
	     sc->sc_encoding == AUDIO_ENCODING_ALAW) && blocksize > 32768)
		blocksize = 32768;
	else if (blocksize > 65536)
		blocksize = 65536;

	if ((blocksize % GUS_BUFFER_MULTIPLE) != 0)
		blocksize = (blocksize / GUS_BUFFER_MULTIPLE + 1) *
			GUS_BUFFER_MULTIPLE;

	/* set up temporary buffer to hold the deinterleave, if necessary
	   for stereo output */
	if (sc->sc_deintr_buf) {
		free(sc->sc_deintr_buf, M_DEVBUF, 0);
		sc->sc_deintr_buf = NULL;
	}
	sc->sc_deintr_buf = malloc(blocksize/2, M_DEVBUF, M_WAITOK);

	sc->sc_blocksize = blocksize;
	/* multi-buffering not quite working yet. */
	sc->sc_nbufs = /*GUS_MEM_FOR_BUFFERS / blocksize*/ 2;

	gus_set_chan_addrs(sc);

	return blocksize;
}

int
gus_get_out_gain(caddr_t addr)
{
	struct gus_softc *sc = (struct gus_softc *) addr;

	DPRINTF(("gus_get_out_gain called\n"));
	return sc->sc_ogain / 2;
}

inline void
gus_set_voices(struct gus_softc *sc, int voices)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	/*
	 * Select the active number of voices
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_ACTIVE_VOICES);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (voices-1) | 0xc0);

	sc->sc_voices = voices;
}

/*
 * Actually set the settings of various values on the card
 */

int
gusmax_commit_settings(void *addr)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;
	int error;

	error = ad1848_commit_settings(ac);
	if (error)
		return error;
	return gus_commit_settings(sc);
}

/*
 * Commit the settings.  Called at normal IPL.
 */
int
gus_commit_settings(void *addr)
{
	struct gus_softc *sc = addr;

	DPRINTF(("gus_commit_settings called (gain = %d)\n",sc->sc_ogain));


	/* XXX: why?! this is called with interrupts disabled */
	mtx_enter(&audio_lock);

	gus_set_recrate(sc, sc->sc_irate);
	gus_set_volume(sc, GUS_VOICE_LEFT, sc->sc_ogain);
	gus_set_volume(sc, GUS_VOICE_RIGHT, sc->sc_ogain);
	gus_set_samprate(sc, GUS_VOICE_LEFT, sc->sc_orate);
	gus_set_samprate(sc, GUS_VOICE_RIGHT, sc->sc_orate);
	mtx_leave(&audio_lock);
	gus_set_chan_addrs(sc);

	return 0;
}

void
gus_set_chan_addrs(struct gus_softc *sc)
{
	/*
	 * We use sc_nbufs * blocksize bytes of storage in the on-board GUS
	 * ram.
	 * For mono, each of the sc_nbufs buffers is DMA'd to in one chunk,
	 * and both left & right channels play the same buffer.
	 *
	 * For stereo, each channel gets a contiguous half of the memory,
	 * and each has sc_nbufs buffers of size blocksize/2.
	 * Stereo data are deinterleaved in main memory before the DMA out
	 * routines are called to queue the output.
	 *
	 * The blocksize per channel is kept in sc_chanblocksize.
	 */
	if (sc->sc_channels == 2)
	    sc->sc_chanblocksize = sc->sc_blocksize/2;
	else
	    sc->sc_chanblocksize = sc->sc_blocksize;

	sc->sc_voc[GUS_VOICE_LEFT].start_addr = GUS_MEM_OFFSET - 1;
	sc->sc_voc[GUS_VOICE_RIGHT].start_addr =
	    (gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0)
	      + GUS_MEM_OFFSET - 1;
	sc->sc_voc[GUS_VOICE_RIGHT].current_addr =
	    sc->sc_voc[GUS_VOICE_RIGHT].start_addr + 1;
	sc->sc_voc[GUS_VOICE_RIGHT].end_addr =
	    sc->sc_voc[GUS_VOICE_RIGHT].start_addr +
	    sc->sc_nbufs * sc->sc_chanblocksize;

}

/*
 * Set the sample rate of the given voice.  Called at splaudio().
 */

void
gus_set_samprate(struct gus_softc *sc, int voice, int freq)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	unsigned int fc;
	u_long temp, f = (u_long) freq;

	/*
	 * calculate fc based on the number of active voices;
	 * we need to use longs to preserve enough bits
	 */

	temp = (u_long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];

	fc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);

	fc <<= 1;


	/*
	 * Program the voice frequency, and set it in the voice data record
	 */

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);
	SELECT_GUS_REG(iot, ioh2, GUSREG_FREQ_CONTROL);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, fc);

	sc->sc_voc[voice].rate = freq;

}

/*
 * Set the sample rate of the recording frequency.  Formula is from the GUS
 * SDK.  Called at splaudio().
 */

void
gus_set_recrate(struct gus_softc *sc, u_long rate)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	u_char realrate;
	DPRINTF(("gus_set_recrate %lu\n", rate));

#if 0
	realrate = 9878400/(16*(rate+2)); /* formula from GUS docs */
#endif
	realrate = (9878400 >> 4)/rate - 2; /* formula from code, sigh. */

	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_FREQ);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);
}

/*
 * Interface to the audio layer - turn the output on or off.  Note that some
 * of these bits are flipped in the register
 */

int
gusmax_speaker_ctl(void *addr, int newstate)
{
	struct ad1848_softc *sc = addr;
	return gus_speaker_ctl(sc->parent, newstate);
}

int
gus_speaker_ctl(void *addr, int newstate)
{
	struct gus_softc *sc = (struct gus_softc *) addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;

	/* Line out bit is flipped: 0 enables, 1 disables */
	if ((newstate == SPKR_ON) &&
	    (sc->sc_mixcontrol & GUSMASK_LINE_OUT)) {
		sc->sc_mixcontrol &= ~GUSMASK_LINE_OUT;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}
	if ((newstate == SPKR_OFF) &&
	    (sc->sc_mixcontrol & GUSMASK_LINE_OUT) == 0) {
		sc->sc_mixcontrol |= GUSMASK_LINE_OUT;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}

	return 0;
}

int
gus_linein_ctl(void *addr, int newstate)
{
	struct gus_softc *sc = (struct gus_softc *) addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;

	/* Line in bit is flipped: 0 enables, 1 disables */
	if ((newstate == SPKR_ON) &&
	    (sc->sc_mixcontrol & GUSMASK_LINE_IN)) {
		sc->sc_mixcontrol &= ~GUSMASK_LINE_IN;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}
	if ((newstate == SPKR_OFF) &&
	    (sc->sc_mixcontrol & GUSMASK_LINE_IN) == 0) {
		sc->sc_mixcontrol |= GUSMASK_LINE_IN;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}

	return 0;
}

int
gus_mic_ctl(void *addr, int newstate)
{
	struct gus_softc *sc = (struct gus_softc *) addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;

	/* Mic bit is normal: 1 enables, 0 disables */
	if ((newstate == SPKR_ON) &&
	    (sc->sc_mixcontrol & GUSMASK_MIC_IN) == 0) {
		sc->sc_mixcontrol |= GUSMASK_MIC_IN;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}
	if ((newstate == SPKR_OFF) &&
	    (sc->sc_mixcontrol & GUSMASK_MIC_IN)) {
		sc->sc_mixcontrol &= ~GUSMASK_MIC_IN;
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);
	}

	return 0;
}

/*
 * Set the end address of a give voice.  Called at splaudio().
 */

void
gus_set_endaddr(struct gus_softc *sc, int voice, u_long addr)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	sc->sc_voc[voice].end_addr = addr;

	if (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)
		addr = convert_to_16bit(addr);

	SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));
	SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));

}

#ifdef GUSPLAYDEBUG
/*
 * Set current address.  Called at splaudio().
 */
void
gus_set_curaddr(struct gus_softc *sc, int voice, u_long addr)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	sc->sc_voc[voice].current_addr = addr;

	if (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)
		addr = convert_to_16bit(addr);

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);

	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_HIGH(addr));
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, ADDR_LOW(addr));

}

/*
 * Get current GUS playback address.  Called at splaudio().
 */
u_long
gus_get_curaddr(struct gus_softc *sc, int voice)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	u_long addr;

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) voice);
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);
	addr = (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) & 0x1fff) << 7;
	SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW|GUSREG_READ);
	addr |= (bus_space_read_2(iot, ioh2, GUS_DATA_LOW) >> 9L) & 0x7f;

	if (sc->sc_voc[voice].voccntl & GUSMASK_DATA_SIZE16)
	    addr = (addr & 0xc0000) | ((addr & 0x1ffff) << 1); /* undo 16-bit change */
	DPRINTF(("gus voice %d curaddr %ld end_addr %ld\n",
		 voice, addr, sc->sc_voc[voice].end_addr));
	/* XXX sanity check the address? */

	return(addr);
}
#endif

/*
 * Convert an address value to a "16 bit" value - why this is necessary I
 * have NO idea
 */

u_long
convert_to_16bit(u_long address)
{
	u_long old_address;

	old_address = address;
	address >>= 1;
	address &= 0x0001ffffL;
	address |= (old_address & 0x000c0000L);

	return (address);
}

/*
 * Write a value into the GUS's DRAM
 */

void
guspoke(bus_space_tag_t iot, bus_space_handle_t ioh2, long address,
    unsigned char value)
{

	/*
	 * Select the DRAM address
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));

	/*
	 * Actually write the data
	 */

	bus_space_write_1(iot, ioh2, GUS_DRAM_DATA, value);
}

/*
 * Read a value from the GUS's DRAM
 */

unsigned char
guspeek(bus_space_tag_t iot, bus_space_handle_t ioh2, u_long address)
{

	/*
	 * Select the DRAM address
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));

	/*
	 * Read in the data from the board
	 */

	return (unsigned char) bus_space_read_1(iot, ioh2, GUS_DRAM_DATA);
}

/*
 * Reset the Gravis UltraSound card, completely
 */

void
gusreset(struct gus_softc *sc, int voices)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	bus_space_handle_t ioh4 = sc->sc_ioh4;
	int i;

	mtx_enter(&audio_lock);

	/*
	 * Reset the GF1 chip
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

	delay(500);

	/*
	 * Release reset
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);

	delay(500);

	/*
	 * Reset MIDI port as well, if applicable
	 */

	if (ioh4 != (bus_space_handle_t)NULL) {
		bus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);

		delay(500);

		bus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);
	}

	/*
	 * Clear interrupts
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(iot, ioh2, GUSREG_TIMER_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

	gus_set_voices(sc, voices);

	bus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
	SELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);

	/*
	 * Reset voice specific information
	 */

	for(i = 0; i < voices; i++) {
		bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) i);

		SELECT_GUS_REG(iot, ioh2, GUSREG_VOICE_CNTL);

		sc->sc_voc[i].voccntl = GUSMASK_VOICE_STOPPED |
			GUSMASK_STOP_VOICE;

		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].voccntl);

		sc->sc_voc[i].volcntl = GUSMASK_VOLUME_STOPPED |
				GUSMASK_STOP_VOLUME;

		SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_CONTROL);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, sc->sc_voc[i].volcntl);

		delay(100);

		gus_set_samprate(sc, i, 8000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_HIGH);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_START_ADDR_LOW);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_HIGH);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_END_ADDR_LOW);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_VOLUME_RATE);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x01);
		SELECT_GUS_REG(iot, ioh2, GUSREG_START_VOLUME);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x10);
		SELECT_GUS_REG(iot, ioh2, GUSREG_END_VOLUME);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0xe0);
		SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_VOLUME);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);

		SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_HIGH);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_CUR_ADDR_LOW);
		bus_space_write_2(iot, ioh2, GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);
		bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x07);
	}

	/*
	 * Clear out any pending IRQs
	 */

	bus_space_read_1(iot, ioh1, GUS_IRQ_STATUS);
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);
	SELECT_GUS_REG(iot, ioh2, GUSREG_IRQ_STATUS);
	bus_space_read_1(iot, ioh2, GUS_DATA_HIGH);

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |
		GUSMASK_IRQ_ENABLE);

	mtx_leave(&audio_lock);
}


int
gus_init_cs4231(struct gus_softc *sc)
{
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh1 = sc->sc_ioh1;
	int port = sc->sc_iobase;
	u_char ctrl;

	ctrl = (port & 0xf0) >> 4;	/* set port address middle nibble */
	/*
	 * The codec is a bit weird--swapped dma channels.
	 */
	ctrl |= GUS_MAX_CODEC_ENABLE;
	if (sc->sc_drq >= 4)
		ctrl |= GUS_MAX_RECCHAN16;
	if (sc->sc_recdrq >= 4)
		ctrl |= GUS_MAX_PLAYCHAN16;

	bus_space_write_1(iot, ioh1, GUS_MAX_CTRL, ctrl);

	sc->sc_codec.sc_iot = sc->sc_iot;
	sc->sc_codec.sc_iobase = port+GUS_MAX_CODEC_BASE;

	if (ad1848_mapprobe(&sc->sc_codec, sc->sc_codec.sc_iobase) == 0) {
		sc->sc_flags &= ~GUS_CODEC_INSTALLED;
		return (0);
	} else {
		struct ad1848_volume vol = {AUDIO_MAX_GAIN, AUDIO_MAX_GAIN};
		sc->sc_flags |= GUS_CODEC_INSTALLED;
		sc->sc_codec.parent = sc;
		sc->sc_codec.sc_drq = sc->sc_recdrq;
		sc->sc_codec.sc_recdrq = sc->sc_drq;
		gus_hw_if = gusmax_hw_if;
		/* enable line in and mic in the GUS mixer; the codec chip
		   will do the real mixing for them. */
		sc->sc_mixcontrol &= ~GUSMASK_LINE_IN; /* 0 enables. */
		sc->sc_mixcontrol |= GUSMASK_MIC_IN; /* 1 enables. */
		bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, sc->sc_mixcontrol);

		ad1848_attach(&sc->sc_codec);
		/* turn on pre-MUX microphone gain. */
		ad1848_set_mic_gain(&sc->sc_codec, &vol);

		return (1);
	}
}

/*
 * stubs (XXX)
 */

int
gus_set_in_gain(caddr_t addr, u_int gain,  u_char balance)
{
	DPRINTF(("gus_set_in_gain called\n"));
	return 0;
}

int
gus_get_in_gain(caddr_t addr)
{
	DPRINTF(("gus_get_in_gain called\n"));
	return 0;
}

int
gusmax_dma_input(void *addr, void *buf, int size, void (*callback)(void *),
    void *arg)
{
	struct ad1848_softc *sc = addr;
	return gus_dma_input(sc->parent, buf, size, callback, arg);
}

/*
 * Start sampling the input source into the requested DMA buffer.
 * Called at splaudio(), either from top-half or from interrupt handler.
 */
int
gus_dma_input(void *addr, void *buf, int size, void (*callback)(void *),
    void *arg)
{
	struct gus_softc *sc = addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	u_char dmac;
	DMAPRINTF(("gus_dma_input called\n"));

	/*
	 * Sample SIZE bytes of data from the card, into buffer at BUF.
	 */
	if (sc->sc_precision == 16) {
	    return EINVAL;		/* XXX */
	}

	/* set DMA modes */
	dmac = GUSMASK_SAMPLE_IRQ|GUSMASK_SAMPLE_START;
	if (sc->sc_recdrq >= 4)
		dmac |= GUSMASK_SAMPLE_DATA16;
	if (sc->sc_encoding == AUDIO_ENCODING_ULAW ||
	    sc->sc_encoding == AUDIO_ENCODING_ALAW ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)
	    dmac |= GUSMASK_SAMPLE_INVBIT;
	if (sc->sc_channels == 2)
	    dmac |= GUSMASK_SAMPLE_STEREO;
	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,
	    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);

	DMAPRINTF(("gus_dma_input isadma_started\n"));
	sc->sc_flags |= GUS_DMAIN_ACTIVE;
	sc->sc_dmainintr = callback;
	sc->sc_inarg = arg;
	sc->sc_dmaincnt = size;
	sc->sc_dmainaddr = buf;

	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, dmac);	/* Go! */


	DMAPRINTF(("gus_dma_input returning\n"));
	return 0;
}

int
gus_dmain_intr(struct gus_softc *sc)
{
        void (*callback)(void *);
	void *arg;

	DMAPRINTF(("gus_dmain_intr called\n"));
	if (sc->sc_dmainintr) {
	    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);
	    callback = sc->sc_dmainintr;
	    arg = sc->sc_inarg;

	    sc->sc_dmainaddr = 0;
	    sc->sc_dmaincnt = 0;
	    sc->sc_dmainintr = 0;
	    sc->sc_inarg = 0;

	    sc->sc_flags &= ~GUS_DMAIN_ACTIVE;
	    DMAPRINTF(("calling dmain_intr callback %p(%p)\n", callback, arg));
	    (*callback)(arg);
	    return 1;
	} else {
	    DMAPRINTF(("gus_dmain_intr false?\n"));
	    return 0;			/* XXX ??? */
	}
}

int
gusmax_halt_out_dma(void *addr)
{
	struct ad1848_softc *sc = addr;
	return gus_halt_out_dma(sc->parent);
}


int
gusmax_halt_in_dma(void *addr)
{
	struct ad1848_softc *sc = addr;
	return gus_halt_in_dma(sc->parent);
}

/*
 * Stop any DMA output.  Called at splaudio().
 */
int
gus_halt_out_dma(void *addr)
{
	struct gus_softc *sc = addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	mtx_enter(&audio_lock);
	DMAPRINTF(("gus_halt_out_dma called\n"));
	/*
	 * Make sure the GUS _isn't_ setup for DMA
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);

	timeout_del(&sc->sc_dma_tmo);
	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
	sc->sc_flags &= ~(GUS_DMAOUT_ACTIVE|GUS_LOCKED);
	sc->sc_dmaoutintr = 0;
	sc->sc_outarg = 0;
	sc->sc_dmaoutaddr = 0;
	sc->sc_dmaoutcnt = 0;
	sc->sc_dmabuf = 0;
	sc->sc_bufcnt = 0;
	sc->sc_playbuf = -1;
	/* also stop playing */
	gus_stop_voice(sc, GUS_VOICE_LEFT, 1);
	gus_stop_voice(sc, GUS_VOICE_RIGHT, 0);
	mtx_leave(&audio_lock);
	return 0;
}

/*
 * Stop any DMA output.  Called at splaudio().
 */
int
gus_halt_in_dma(void *addr)
{
	struct gus_softc *sc = addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;

	mtx_enter(&audio_lock);
	DMAPRINTF(("gus_halt_in_dma called\n"));

	/*
	 * Make sure the GUS _isn't_ setup for DMA
	 */

	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH,
	     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));

	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);
	sc->sc_flags &= ~GUS_DMAIN_ACTIVE;
	sc->sc_dmainintr = 0;
	sc->sc_inarg = 0;
	sc->sc_dmainaddr = 0;
	sc->sc_dmaincnt = 0;
	mtx_leave(&audio_lock);
	return 0;
}


ad1848_devmap_t gusmapping[] = {
  {GUSMAX_DAC_LVL, AD1848_KIND_LVL, AD1848_AUX1_CHANNEL},
  {GUSMAX_LINE_IN_LVL, AD1848_KIND_LVL, AD1848_LINE_CHANNEL},
  {GUSMAX_MONO_LVL, AD1848_KIND_LVL, AD1848_MONO_CHANNEL},
  {GUSMAX_CD_LVL, AD1848_KIND_LVL, AD1848_AUX2_CHANNEL},
  {GUSMAX_MONITOR_LVL, AD1848_KIND_LVL, AD1848_MONITOR_CHANNEL},
  {GUSMAX_OUT_LVL, AD1848_KIND_LVL, AD1848_DAC_CHANNEL},
  {GUSMAX_DAC_MUTE, AD1848_KIND_MUTE, AD1848_AUX1_CHANNEL},
  {GUSMAX_LINE_IN_MUTE, AD1848_KIND_MUTE, AD1848_LINE_CHANNEL},
  {GUSMAX_MONO_MUTE, AD1848_KIND_MUTE, AD1848_MONO_CHANNEL},
  {GUSMAX_CD_MUTE, AD1848_KIND_MUTE, AD1848_AUX2_CHANNEL},
  {GUSMAX_MONITOR_MUTE, AD1848_KIND_MUTE, AD1848_MONITOR_CHANNEL},
  {GUSMAX_REC_LVL, AD1848_KIND_RECORDGAIN, -1},
  {GUSMAX_RECORD_SOURCE, AD1848_KIND_RECORDSOURCE, -1}
};

int nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);

int
gusmax_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;
	struct ad1848_volume vol;
	int error = ad1848_mixer_get_port(ac, gusmapping, nummap, cp);

	if (error != ENXIO)
	  return (error);

	error = EINVAL;

	switch (cp->dev) {
	case GUSMAX_SPEAKER_LVL:	/* fake speaker for mute naming */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (sc->sc_mixcontrol & GUSMASK_LINE_OUT)
				vol.left = vol.right = AUDIO_MAX_GAIN;
			else
				vol.left = vol.right = AUDIO_MIN_GAIN;
			error = 0;
			ad1848_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_SPEAKER_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;
			error = 0;
		}
		break;
	default:
		error = ENXIO;
		break;
	}

	return(error);
}

int
gus_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct gus_softc *sc = addr;
	struct ics2101_softc *ic = &sc->sc_mixer;
	struct ad1848_volume vol;
	int error = EINVAL;

	DPRINTF(("gus_mixer_get_port: dev=%d type=%d\n", cp->dev, cp->type));

	if (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)
		return ENXIO;

	switch (cp->dev) {

	case GUSICS_MIC_IN_MUTE:	/* Microphone */
		if (cp->type == AUDIO_MIXER_ENUM) {
			if (HAS_MIXER(sc))
				cp->un.ord = ic->sc_mute[GUSMIX_CHAN_MIC][ICSMIX_LEFT];
			else
				cp->un.ord =
				    sc->sc_mixcontrol & GUSMASK_MIC_IN ? 0 : 1;
			error = 0;
		}
		break;

	case GUSICS_LINE_IN_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			if (HAS_MIXER(sc))
				cp->un.ord = ic->sc_mute[GUSMIX_CHAN_LINE][ICSMIX_LEFT];
			else
				cp->un.ord =
				    sc->sc_mixcontrol & GUSMASK_LINE_IN ? 1 : 0;
			error = 0;
		}
		break;

	case GUSICS_MASTER_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			if (HAS_MIXER(sc))
				cp->un.ord = ic->sc_mute[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];
			else
				cp->un.ord =
				    sc->sc_mixcontrol & GUSMASK_LINE_OUT ? 1 : 0;
			error = 0;
		}
		break;

	case GUSICS_DAC_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ic->sc_mute[GUSMIX_CHAN_DAC][ICSMIX_LEFT];
			error = 0;
		}
		break;

	case GUSICS_CD_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ic->sc_mute[GUSMIX_CHAN_CD][ICSMIX_LEFT];
			error = 0;
		}
		break;

	case GUSICS_MASTER_LVL:
		if (cp->type == AUDIO_MIXER_VALUE) {
			vol.left = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_LEFT];
			vol.right = ic->sc_setting[GUSMIX_CHAN_MASTER][ICSMIX_RIGHT];
			if (ad1848_from_vol(cp, &vol))
				error = 0;
		}
		break;

	case GUSICS_MIC_IN_LVL:	/* Microphone */
		if (cp->type == AUDIO_MIXER_VALUE) {
			vol.left = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_LEFT];
			vol.right = ic->sc_setting[GUSMIX_CHAN_MIC][ICSMIX_RIGHT];
			if (ad1848_from_vol(cp, &vol))
				error = 0;
		}
		break;

	case GUSICS_LINE_IN_LVL:	/* line in */
		if (cp->type == AUDIO_MIXER_VALUE) {
			vol.left = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_LEFT];
			vol.right = ic->sc_setting[GUSMIX_CHAN_LINE][ICSMIX_RIGHT];
			if (ad1848_from_vol(cp, &vol))
				error = 0;
		}
		break;


	case GUSICS_CD_LVL:
		if (cp->type == AUDIO_MIXER_VALUE) {
			vol.left = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_LEFT];
			vol.right = ic->sc_setting[GUSMIX_CHAN_CD][ICSMIX_RIGHT];
			if (ad1848_from_vol(cp, &vol))
				error = 0;
		}
		break;

	case GUSICS_DAC_LVL:		/* dac out */
		if (cp->type == AUDIO_MIXER_VALUE) {
			vol.left = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_LEFT];
			vol.right = ic->sc_setting[GUSMIX_CHAN_DAC][ICSMIX_RIGHT];
			if (ad1848_from_vol(cp, &vol))
				error = 0;
		}
		break;


	case GUSICS_RECORD_SOURCE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			/* Can't set anything else useful, sigh. */
			 cp->un.ord = 0;
		}
		break;

	default:
		return ENXIO;
	    /*NOTREACHED*/
	}
	return error;
}

void
gusics_master_mute(struct ics2101_softc *ic, int mute)
{
	ics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_LEFT, mute);
	ics2101_mix_mute(ic, GUSMIX_CHAN_MASTER, ICSMIX_RIGHT, mute);
}

void
gusics_mic_mute(struct ics2101_softc *ic, int mute)
{
	ics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_LEFT, mute);
	ics2101_mix_mute(ic, GUSMIX_CHAN_MIC, ICSMIX_RIGHT, mute);
}

void
gusics_linein_mute(struct ics2101_softc *ic, int mute)
{
	ics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_LEFT, mute);
	ics2101_mix_mute(ic, GUSMIX_CHAN_LINE, ICSMIX_RIGHT, mute);
}

void
gusics_cd_mute(struct ics2101_softc *ic, int mute)
{
	ics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_LEFT, mute);
	ics2101_mix_mute(ic, GUSMIX_CHAN_CD, ICSMIX_RIGHT, mute);
}

void
gusics_dac_mute(struct ics2101_softc *ic, int mute)
{
	ics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_LEFT, mute);
	ics2101_mix_mute(ic, GUSMIX_CHAN_DAC, ICSMIX_RIGHT, mute);
}

int
gusmax_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct ad1848_softc *ac = addr;
	struct gus_softc *sc = ac->parent;
	struct ad1848_volume vol;
	int error = ad1848_mixer_set_port(ac, gusmapping, nummap, cp);

	if (error != ENXIO)
	  return (error);

	DPRINTF(("gusmax_mixer_set_port: dev=%d type=%d\n", cp->dev, cp->type));

	switch (cp->dev) {
	case GUSMAX_SPEAKER_LVL:
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			if (ad1848_to_vol(cp, &vol)) {
				gus_speaker_ctl(sc, vol.left > AUDIO_MIN_GAIN ?
						SPKR_ON : SPKR_OFF);
				error = 0;
			}
		}
		break;

	case GUSMAX_SPEAKER_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			gus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	default:
		return ENXIO;
	    /*NOTREACHED*/
    }
    return error;
}

int
gus_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct gus_softc *sc = addr;
	struct ics2101_softc *ic = &sc->sc_mixer;
	struct ad1848_volume vol;
	int error = EINVAL;

	DPRINTF(("gus_mixer_set_port: dev=%d type=%d\n", cp->dev, cp->type));

	if (!HAS_MIXER(sc) && cp->dev > GUSICS_MASTER_MUTE)
		return ENXIO;

	switch (cp->dev) {

	case GUSICS_MIC_IN_MUTE:	/* Microphone */
		if (cp->type == AUDIO_MIXER_ENUM) {
			DPRINTF(("mic mute %d\n", cp->un.ord));
			if (HAS_MIXER(sc)) {
				gusics_mic_mute(ic, cp->un.ord);
			}
			gus_mic_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	case GUSICS_LINE_IN_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			DPRINTF(("linein mute %d\n", cp->un.ord));
			if (HAS_MIXER(sc)) {
				gusics_linein_mute(ic, cp->un.ord);
			}
			gus_linein_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	case GUSICS_MASTER_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			DPRINTF(("master mute %d\n", cp->un.ord));
			if (HAS_MIXER(sc)) {
				gusics_master_mute(ic, cp->un.ord);
			}
			gus_speaker_ctl(sc, cp->un.ord ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	case GUSICS_DAC_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			gusics_dac_mute(ic, cp->un.ord);
			error = 0;
		}
		break;

	case GUSICS_CD_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			gusics_cd_mute(ic, cp->un.ord);
			error = 0;
		}
		break;

	case GUSICS_MASTER_LVL:
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (ad1848_to_vol(cp, &vol)) {
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_MASTER,
						      ICSMIX_LEFT,
						      vol.left);
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_MASTER,
						      ICSMIX_RIGHT,
						      vol.right);
				error = 0;
			}
		}
		break;

	case GUSICS_MIC_IN_LVL:	/* Microphone */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (ad1848_to_vol(cp, &vol)) {
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_MIC,
						      ICSMIX_LEFT,
						      vol.left);
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_MIC,
						      ICSMIX_RIGHT,
						      vol.right);
				error = 0;
			}
		}
		break;

	case GUSICS_LINE_IN_LVL:	/* line in */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (ad1848_to_vol(cp, &vol)) {
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_LINE,
						      ICSMIX_LEFT,
						      vol.left);
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_LINE,
						      ICSMIX_RIGHT,
						      vol.right);
				error = 0;
			}
		}
		break;


	case GUSICS_CD_LVL:
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (ad1848_to_vol(cp, &vol)) {
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_CD,
						      ICSMIX_LEFT,
						      vol.left);
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_CD,
						      ICSMIX_RIGHT,
						      vol.right);
				error = 0;
			}
		}
		break;

	case GUSICS_DAC_LVL:		/* dac out */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (ad1848_to_vol(cp, &vol)) {
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_DAC,
						      ICSMIX_LEFT,
						      vol.left);
				ics2101_mix_attenuate(ic,
						      GUSMIX_CHAN_DAC,
						      ICSMIX_RIGHT,
						      vol.right);
				error = 0;
			}
		}
		break;


	case GUSICS_RECORD_SOURCE:
		if (cp->type == AUDIO_MIXER_ENUM && cp->un.ord == 0) {
			/* Can't set anything else useful, sigh. */
			error = 0;
		}
		break;

	default:
		return ENXIO;
	    /*NOTREACHED*/
	}
	return error;
}

int
gus_get_props(void *addr)
{
	struct gus_softc *sc = addr;
	return AUDIO_PROP_MMAP |
		(sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX);
}

int
gusmax_get_props(void *addr)
{
	struct ad1848_softc *ac = addr;
	return gus_get_props(ac->parent);
}

int
gusmax_mixer_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	DPRINTF(("gusmax_query_devinfo: index=%d\n", dip->index));

	switch(dip->index) {
#if 0
    case GUSMAX_MIC_IN_LVL:	/* Microphone */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_MIC_IN_MUTE;
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;
#endif

    case GUSMAX_MONO_LVL:	/* mono/microphone mixer */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_MONO_MUTE;
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_DAC_LVL:		/*  dacout */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_DAC_MUTE;
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_LINE_IN_LVL:	/* line */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_LINE_IN_MUTE;
	strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_CD_LVL:		/* cd */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_CD_MUTE;
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;


    case GUSMAX_MONITOR_LVL:	/* monitor level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_MONITOR_CLASS;
	dip->next = GUSMAX_MONITOR_MUTE;
	dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
	dip->un.v.num_channels = 1;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_OUT_LVL:		/* cs4231 output volume: not useful? */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_MONITOR_CLASS;
	dip->prev = dip->next = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_SPEAKER_LVL:		/* fake speaker volume */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_MONITOR_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_SPEAKER_MUTE;
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
	break;

    case GUSMAX_LINE_IN_MUTE:
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_LINE_IN_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case GUSMAX_DAC_MUTE:
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_DAC_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case GUSMAX_CD_MUTE:
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_CD_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case GUSMAX_MONO_MUTE:
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_MONO_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case GUSMAX_MONITOR_MUTE:
	dip->mixer_class = GUSMAX_OUTPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_MONITOR_LVL;
	dip->next = AUDIO_MIXER_LAST;
	goto mute;

    case GUSMAX_SPEAKER_MUTE:
	dip->mixer_class = GUSMAX_OUTPUT_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_SPEAKER_LVL;
	dip->next = AUDIO_MIXER_LAST;
    mute:
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
	dip->un.e.num_mem = 2;
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = 0;
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = 1;
	break;

    case GUSMAX_REC_LVL:	/* record level */
	dip->type = AUDIO_MIXER_VALUE;
	dip->mixer_class = GUSMAX_RECORD_CLASS;
	dip->prev = AUDIO_MIXER_LAST;
	dip->next = GUSMAX_RECORD_SOURCE;
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
	dip->un.v.num_channels = 2;
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
	break;

    case GUSMAX_RECORD_SOURCE:
	dip->mixer_class = GUSMAX_RECORD_CLASS;
	dip->type = AUDIO_MIXER_ENUM;
	dip->prev = GUSMAX_REC_LVL;
	dip->next = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
	dip->un.e.num_mem = 4;
	strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
	    sizeof dip->un.e.member[0].label.name);
	dip->un.e.member[0].ord = DAC_IN_PORT;
	strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[1].label.name);
	dip->un.e.member[1].ord = MIC_IN_PORT;
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
	dip->un.e.member[2].ord = AUX1_IN_PORT;
	strlcpy(dip->un.e.member[3].label.name, AudioNline,
	    sizeof dip->un.e.member[3].label.name);
	dip->un.e.member[3].ord = LINE_IN_PORT;
	break;

    case GUSMAX_INPUT_CLASS:			/* input class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = GUSMAX_INPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
	break;

    case GUSMAX_OUTPUT_CLASS:			/* output class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = GUSMAX_OUTPUT_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
	break;

    case GUSMAX_MONITOR_CLASS:			/* monitor class descriptor */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = GUSMAX_MONITOR_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
	break;

    case GUSMAX_RECORD_CLASS:			/* record source class */
	dip->type = AUDIO_MIXER_CLASS;
	dip->mixer_class = GUSMAX_RECORD_CLASS;
	dip->next = dip->prev = AUDIO_MIXER_LAST;
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
	break;

    default:
	return ENXIO;
	/*NOTREACHED*/
    }
    DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));
	return 0;
}

int
gus_mixer_query_devinfo(void *addr, mixer_devinfo_t *dip)
{
	struct gus_softc *sc = addr;

	DPRINTF(("gusmax_query_devinfo: index=%d\n", dip->index));

	if (!HAS_MIXER(sc) && dip->index > GUSICS_MASTER_MUTE)
		return ENXIO;

	switch(dip->index) {

	case GUSICS_MIC_IN_LVL:	/* Microphone */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = GUSICS_MIC_IN_MUTE;
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case GUSICS_LINE_IN_LVL:	/* line */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = GUSICS_LINE_IN_MUTE;
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case GUSICS_CD_LVL:		/* cd */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = GUSICS_CD_MUTE;
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case GUSICS_DAC_LVL:		/*  dacout */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = GUSICS_DAC_MUTE;
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;

	case GUSICS_MASTER_LVL:		/*  master output */
		dip->type = AUDIO_MIXER_VALUE;
		dip->mixer_class = GUSICS_OUTPUT_CLASS;
		dip->prev = AUDIO_MIXER_LAST;
		dip->next = GUSICS_MASTER_MUTE;
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
		dip->un.v.num_channels = 2;
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
		break;


	case GUSICS_LINE_IN_MUTE:
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = GUSICS_LINE_IN_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;

	case GUSICS_DAC_MUTE:
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = GUSICS_DAC_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;

	case GUSICS_CD_MUTE:
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = GUSICS_CD_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;

	case GUSICS_MIC_IN_MUTE:
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = GUSICS_MIC_IN_LVL;
		dip->next = AUDIO_MIXER_LAST;
		goto mute;

	case GUSICS_MASTER_MUTE:
		dip->mixer_class = GUSICS_OUTPUT_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = GUSICS_MASTER_LVL;
		dip->next = AUDIO_MIXER_LAST;
mute:
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
		dip->un.e.num_mem = 2;
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = 0;
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
		dip->un.e.member[1].ord = 1;
		break;

	case GUSICS_RECORD_SOURCE:
		dip->mixer_class = GUSICS_RECORD_CLASS;
		dip->type = AUDIO_MIXER_ENUM;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
		dip->un.e.num_mem = 1;
		strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
		    sizeof dip->un.e.member[0].label.name);
		dip->un.e.member[0].ord = GUSICS_MASTER_LVL;
		break;

	case GUSICS_INPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = GUSICS_INPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
		break;

	case GUSICS_OUTPUT_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = GUSICS_OUTPUT_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
		break;

	case GUSICS_RECORD_CLASS:
		dip->type = AUDIO_MIXER_CLASS;
		dip->mixer_class = GUSICS_RECORD_CLASS;
		dip->next = dip->prev = AUDIO_MIXER_LAST;
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
		break;

	default:
		return ENXIO;
	/*NOTREACHED*/
	}
	DPRINTF(("AUDIO_MIXER_DEVINFO: name=%s\n", dip->label.name));
	return 0;
}

void *
gus_malloc(void *addr, int direction, size_t size, int pool, int flags)
{
	struct gus_softc *sc = addr;
	int drq;

	if (direction == AUMODE_PLAY)
		drq = sc->sc_drq;
	else
		drq = sc->sc_recdrq;

	return isa_malloc(sc->sc_isa, drq, size, pool, flags);
}

void
gus_free(void *addr, void *ptr, int pool)
{
	isa_free(ptr, pool);
}

size_t
gus_round(void *addr, int direction, size_t size)
{
	if (size > MAX_ISADMA)
		size = MAX_ISADMA;
	return size;
}

/*
 * Setup the ICS mixer in "transparent" mode: reset everything to a sensible
 * level.  Levels as suggested by GUS SDK code.
 */

void
gus_init_ics2101(struct gus_softc *sc)
{
	struct ics2101_softc *ic = &sc->sc_mixer;
	sc->sc_mixer.sc_iot = sc->sc_iot;
	sc->sc_mixer.sc_selio = GUS_MIXER_SELECT;
	sc->sc_mixer.sc_selio_ioh = sc->sc_ioh3;
	sc->sc_mixer.sc_dataio = GUS_MIXER_DATA;
	sc->sc_mixer.sc_dataio_ioh = sc->sc_ioh2;
	sc->sc_mixer.sc_flags = (sc->sc_revision == 5) ? ICS_FLIP : 0;

	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_MIC,
			      ICSMIX_LEFT,
			      ICSMIX_MIN_ATTN);
	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_MIC,
			      ICSMIX_RIGHT,
			      ICSMIX_MIN_ATTN);
	/*
	 * Start with microphone muted by the mixer...
	 */
	gusics_mic_mute(ic, 1);

	/* ... and enabled by the GUS master mix control */
	gus_mic_ctl(sc, SPKR_ON);

	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_LINE,
			      ICSMIX_LEFT,
			      ICSMIX_MIN_ATTN);
	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_LINE,
			      ICSMIX_RIGHT,
			      ICSMIX_MIN_ATTN);

	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_CD,
			      ICSMIX_LEFT,
			      ICSMIX_MIN_ATTN);
	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_CD,
			      ICSMIX_RIGHT,
			      ICSMIX_MIN_ATTN);

	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_DAC,
			      ICSMIX_LEFT,
			      ICSMIX_MIN_ATTN);
	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_DAC,
			      ICSMIX_RIGHT,
			      ICSMIX_MIN_ATTN);

	ics2101_mix_attenuate(ic,
			      ICSMIX_CHAN_4,
			      ICSMIX_LEFT,
			      ICSMIX_MAX_ATTN);
	ics2101_mix_attenuate(ic,
			      ICSMIX_CHAN_4,
			      ICSMIX_RIGHT,
			      ICSMIX_MAX_ATTN);

	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_MASTER,
			      ICSMIX_LEFT,
			      ICSMIX_MIN_ATTN);
	ics2101_mix_attenuate(ic,
			      GUSMIX_CHAN_MASTER,
			      ICSMIX_RIGHT,
			      ICSMIX_MIN_ATTN);
	/* unmute other stuff: */
	gusics_cd_mute(ic, 0);
	gusics_dac_mute(ic, 0);
	gusics_linein_mute(ic, 0);
	return;
}



void
gus_subattach(struct gus_softc *sc, struct isa_attach_args *ia)
{
	int		i;
	bus_space_tag_t iot;
	unsigned char	c,d,m;

	iot = sc->sc_iot;

	/*
	 * Figure out our board rev, and see if we need to initialize the
	 * mixer
	 */

	c = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);
	if (c != 0xff)
		sc->sc_revision = c;
	else
		sc->sc_revision = 0;

	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
	bus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);

	gusreset(sc, GUS_MAX_VOICES); /* initialize all voices */
	gusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */

	/*
	 * Setup the IRQ and DRQ lines in software, using values from
	 * config file
	 */

	m = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;		/* disable all */

	c = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;

	if (sc->sc_recdrq == sc->sc_drq)
		d = (unsigned char) (gus_drq_map[sc->sc_drq] |
				GUSMASK_BOTH_RQ);
	else
		d = (unsigned char) (gus_drq_map[sc->sc_drq] |
				gus_drq_map[sc->sc_recdrq] << 3);

	/*
	 * Program the IRQ and DMA channels on the GUS.  Note that we hardwire
	 * the GUS to only use one IRQ channel, but we give the user the
	 * option of using two DMA channels (the other one given by the drq2
	 * option in the config file).  Two DMA channels are needed for full-
	 * duplex operation.
	 *
	 * The order of these operations is very magical.
	 */

	disable_intr();		/* XXX needed? */

	bus_space_write_1(iot, sc->sc_ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);
	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);
	bus_space_write_1(iot, sc->sc_ioh1, GUS_IRQCTL_CONTROL, 0x00);
	bus_space_write_1(iot, sc->sc_ioh1, 0x0f, 0x00);

	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);

	/* magic reset? */
	bus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d | 0x80);

	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,
	    m | GUSMASK_CONTROL_SEL);
	bus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);

	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL, m);
	bus_space_write_1(iot, sc->sc_ioh1, GUS_DMA_CONTROL, d);

	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,
	    m | GUSMASK_CONTROL_SEL);
	bus_space_write_1(iot, sc->sc_ioh1, GUS_IRQ_CONTROL, c);

	bus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);

	/* enable line in, line out.  leave mic disabled. */
	bus_space_write_1(iot, sc->sc_ioh1, GUS_MIX_CONTROL,
	     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));
	bus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT, 0x00);

	enable_intr();

	sc->sc_mixcontrol =
		(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);

	sc->sc_codec.sc_isa = sc->sc_isa;

	if (sc->sc_revision >= 5 && sc->sc_revision <= 9) {
		sc->sc_flags |= GUS_MIXER_INSTALLED;
		gus_init_ics2101(sc);
	}
	if (sc->sc_revision < 10 || !gus_init_cs4231(sc)) {
		/* Not using the CS4231, so create our DMA maps. */
		if (sc->sc_drq != -1) {
			if (isa_dmamap_create(sc->sc_isa, sc->sc_drq,
			    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
				printf("%s: can't create map for drq %d\n",
				       sc->sc_dev.dv_xname, sc->sc_drq);
				return;
			}
		}
		if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {
			if (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,
			    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
				printf("%s: can't create map for drq %d\n",
				       sc->sc_dev.dv_xname, sc->sc_recdrq);
				return;
			}
		}
	}

	timeout_set(&sc->sc_dma_tmo, gus_dmaout_timeout, sc);

	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
	/*
	 * Check to see how much memory we have on this card; see if any
	 * "mirroring" occurs.  We're assuming at least 256K already exists
	 * on the card; otherwise the initial probe would have failed
	 */

	guspoke(iot, sc->sc_ioh2, 0L, 0x00);
	for(i = 1; i < 1024; i++) {
		u_long loc;

		/*
		 * See if we've run into mirroring yet
		 */

		if (guspeek(iot, sc->sc_ioh2, 0L) != 0)
			break;

		loc = i << 10;

		guspoke(iot, sc->sc_ioh2, loc, 0xaa);
		if (guspeek(iot, sc->sc_ioh2, loc) != 0xaa)
			break;
	}

	sc->sc_dsize = i;
	/*
	 * The "official" (3.x) version number cannot easily be obtained.
	 * The revision register does not correspond to the minor number
	 * of the board version. Simply use the revision register as
	 * identification.
	 */
	printf(": ver %d", sc->sc_revision);
	if (sc->sc_revision >= 10)
		printf(", MAX");
	else {
		if (HAS_MIXER(sc))
			printf(", ICS2101 mixer");
		if (HAS_CODEC(sc))
			printf(", %s codec/mixer", sc->sc_codec.chip_name);
	}
	printf(", %dKB DRAM, ", sc->sc_dsize);
	if (sc->sc_recdrq == sc->sc_drq) {
		printf("half-duplex");
	} else {
		printf("full-duplex, record drq %d", sc->sc_recdrq);
	}

	printf("\n");

	/*
	 * Setup a default interrupt handler
	 */

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq,
	    IST_EDGE, IPL_AUDIO | IPL_MPSAFE,
	    gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);

	/*
	 * Set some default values
	 * XXX others start with 8kHz mono mulaw
	 */

	sc->sc_irate = sc->sc_orate = 44100;
	sc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;
	sc->sc_precision = 16;
	sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;
	sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;
	sc->sc_channels = 1;
	sc->sc_ogain = 340;
	gus_commit_settings(sc);

	/*
	 * We always put the left channel full left & right channel
	 * full right.
	 * For mono playback, we set up both voices playing the same buffer.
	 */
	bus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,
	    (u_char)GUS_VOICE_LEFT);
	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);
	bus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);

	bus_space_write_1(iot, sc->sc_ioh2, GUS_VOICE_SELECT,
	    (u_char)GUS_VOICE_RIGHT);
	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_PAN_POS);
	bus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);

	/*
	 * Attach to the generic audio layer
	 */

	audio_attach_mi(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec :
	    (void *)sc, &sc->sc_dev);
}

/*
 * Test to see if a particular I/O base is valid for the GUS.  Return true
 * if it is.
 */

int
gus_test_iobase (bus_space_tag_t iot, int iobase)
{
	bus_space_handle_t ioh1, ioh2, ioh3, ioh4;
	u_char s1, s2;
	int rv = 0;

	/* Map i/o space */
	if (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))
		return 0;
	if (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))
		goto bad1;

	/* XXX Maybe we shouldn't fail on mapping this, but just assume
	 * the card is of revision 0? */
	if (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))
		goto bad2;

	if (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))
		goto bad3;

	/*
	 * Reset GUS to an initial state before we do anything.
	 */

	mtx_enter(&audio_lock);
	delay(500);

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

	delay(500);

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);

	delay(500);

	mtx_leave(&audio_lock);

	/*
	 * See if we can write to the board's memory
	 */

	s1 = guspeek(iot, ioh2, 0L);
	s2 = guspeek(iot, ioh2, 1L);

	guspoke(iot, ioh2, 0L, 0xaa);
	guspoke(iot, ioh2, 1L, 0x55);

	if (guspeek(iot, ioh2, 0L) != 0xaa)
		goto bad;

	guspoke(iot, ioh2, 0L, s1);
	guspoke(iot, ioh2, 1L, s2);

	rv = 1;

bad:
	bus_space_unmap(iot, ioh4, GUS_NPORT4);
bad3:
	bus_space_unmap(iot, ioh3, GUS_NPORT3);
bad2:
	bus_space_unmap(iot, ioh2, GUS_NPORT2);
bad1:
	bus_space_unmap(iot, ioh1, GUS_NPORT1);
	return rv;
}
@


1.45
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.44 2016/09/14 06:12:19 ratchov Exp $	*/
d861 1
a861 1
	sc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs;
d951 1
a951 1
			    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;
d1119 1
a1119 1
	sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;
@


1.44
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.42 2015/05/11 06:46:21 ratchov Exp $	*/
a280 1
	gus_getdev,
a312 1
	gus_getdev,
a325 10
/*
 * Some info about the current audio device
 */
struct audio_device gus_device = {
	"UltraSound",
	"",
	"gus",
};


a2101 12

/*
 * Return info about the audio device, for the AUDIO_GETINFO ioctl
 */

int
gus_getdev(void *addr, struct audio_device *dev)
{
	*dev = gus_device;
	return 0;
}

a3341 3
	snprintf(gus_device.version, sizeof gus_device.version, "%d",
	    sc->sc_revision);

@


1.43
log
@Cards with revision < 10 (qemu rev is 0), have no ad1848 chip and
don't attach the ad1848 driver. But the "malloc" method of gus_hw_if
is ad1848_malloc() which assumes a ad1848 is attached (and expect the
softc pointer to be a struct ad1848_softc, but get a gus_softc pointer
instead). Implement, the missing gus_{malloc,free,mappage,...}
routines. Add the missing mtx_{enter,leave} calls, as we're at it.
Found by mlarkin.

ok mlarkin
@
text
@a265 4
	NULL,				/* drain */

	gus_query_encoding,

a288 1
	gus_mappage,
a291 1
	NULL,
a297 4
	NULL,				/* drain */

	gus_query_encoding, /* query encoding */

a321 1
	ad1848_mappage,
a324 1
	NULL,
a3105 38
int
gus_query_encoding(void *addr, struct audio_encoding *fp)
{
	switch (fp->index) {
	case 0:
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 1:
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 2:
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = 0;
		break;
	case 3:
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	default:
		return(EINVAL);
		/*NOTREACHED*/
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;

	return (0);
}

a3131 6
}

paddr_t
gus_mappage(void *addr, void *mem, off_t off, int prot)
{
	return isa_mappage(mem, off, prot);
@


1.42
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.41 2014/09/14 14:17:25 jsg Exp $	*/
d290 4
a293 4
	ad1848_malloc,
	ad1848_free,
	ad1848_round,
	ad1848_mappage,
a512 1
	mtx_enter(&audio_lock);
a515 1
	    mtx_leave(&audio_lock);
a538 1
			mtx_leave(&audio_lock);
a578 1
	mtx_leave(&audio_lock);
a2177 1
	mtx_enter(&audio_lock);
a2181 1
	    mtx_leave(&audio_lock);
a2210 1
	mtx_leave(&audio_lock);
d3154 34
@


1.41
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.40 2014/07/12 18:48:17 tedu Exp $	*/
a108 2
#include <dev/mulaw.h>
#include <dev/auconv.h>
a1485 2
	case AUDIO_ENCODING_ULAW:
	case AUDIO_ENCODING_ALAW:
a1487 2
	case AUDIO_ENCODING_SLINEAR_BE:
	case AUDIO_ENCODING_ULINEAR_BE:
a1516 14
	switch (p->encoding) {
	case AUDIO_ENCODING_ULAW:
		p->sw_code = mulaw_to_ulinear8;
		r->sw_code = ulinear8_to_mulaw;
		break;
	case AUDIO_ENCODING_ALAW:
		p->sw_code = alaw_to_ulinear8;
		r->sw_code = ulinear8_to_alaw;
		break;
	case AUDIO_ENCODING_ULINEAR_BE:
	case AUDIO_ENCODING_SLINEAR_BE:
		r->sw_code = p->sw_code = swap_bytes;
		break;
	}
a3129 6
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 1:
d3135 1
a3135 1
	case 2:
d3141 1
a3141 1
	case 3:
d3147 1
a3147 1
	case 4:
a3152 19
	case 5:
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;

@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.39 2013/11/15 16:46:27 brad Exp $	*/
a96 1
#include <sys/proc.h>
@


1.39
log
@ansify some function definitions.
no functional change.

ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.38 2013/06/26 09:39:56 kettenis Exp $	*/
d621 1
a621 1
		free(sc->sc_deintr_buf, M_DEVBUF);
d1582 1
a1582 1
		free(sc->sc_deintr_buf, M_DEVBUF);
@


1.38
log
@Remove some lies in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.37 2013/05/24 07:58:46 ratchov Exp $	*/
d354 1
a354 3
gusopen(addr, flags)
	void *addr;
	int flags;
d395 1
a395 3
gusmaxopen(addr, flags)
	void *addr;
	int flags;
d402 1
a402 4
gus_deinterleave(sc, buf, size)
	struct gus_softc *sc;
	void *buf;
	int size;
d455 2
a456 6
gusmax_dma_output(addr, buf, size, intr, arg)
	void * addr;
	void *buf;
	int size;
	void (*intr)(void *);
	void *arg;
d466 1
a466 2
stereo_dmaintr(arg)
	void *arg;
d508 1
a508 6
gus_dma_output(addr, buf, size, intr, arg)
	void * addr;
	void *buf;
	int size;
	void (*intr)(void *);
	void *arg;
d590 1
a590 2
gusmax_close(addr)
	void *addr;
d606 1
a606 2
gusclose(addr)
	void *addr;
a611 1

d643 1
a643 2
gusintr(arg)
	void *arg;
d710 1
a710 2
gus_dmaout_timeout(arg)
	void *arg;
d741 1
a741 2
gus_dmaout_intr(sc)
	struct gus_softc *sc;
d761 1
a761 2
gus_dmaout_dointr(sc)
	struct gus_softc *sc;
d914 1
a914 2
gus_voice_intr(sc)
	struct gus_softc *sc;
d1056 1
a1056 3
gus_start_playing(sc, bufno)
	struct gus_softc *sc;
	int bufno;
d1134 1
a1134 3
gus_continue_playing(sc, voice)
	struct gus_softc *sc;
	int voice;
d1233 2
a1234 5
gusdmaout(sc, flags, gusaddr, buffaddr, length)
	struct gus_softc *sc;
	int flags, length;
	u_long gusaddr;
	caddr_t buffaddr;
d1304 1
a1304 4
gus_start_voice(sc, voice, intrs)
	struct gus_softc *sc;
	int voice;
	int intrs;
d1398 1
a1398 4
gus_stop_voice(sc, voice, intrs_too)
	struct gus_softc *sc;
	int voice;
	int intrs_too;
d1438 1
a1438 3
gus_set_volume(sc, voice, volume)
	struct gus_softc *sc;
	int voice, volume;
d1468 2
a1469 4
gusmax_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
d1483 2
a1484 4
gus_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
d1551 1
a1551 3
gusmax_round_blocksize(addr, blocksize)
	void * addr;
	int blocksize;
d1597 1
a1597 2
gus_get_out_gain(addr)
	caddr_t addr;
d1605 2
a1606 3
inline void gus_set_voices(sc, voices)
struct gus_softc *sc;
int voices;
d1625 1
a1625 2
gusmax_commit_settings(addr)
	void * addr;
d1641 1
a1641 2
gus_commit_settings(addr)
	void * addr;
d1663 1
a1663 2
gus_set_chan_addrs(sc)
struct gus_softc *sc;
d1700 1
a1700 3
gus_set_samprate(sc, voice, freq)
	struct gus_softc *sc;
	int voice, freq;
d1737 1
a1737 3
gus_set_recrate(sc, rate)
	struct gus_softc *sc;
	u_long rate;
d1759 1
a1759 3
gusmax_speaker_ctl(addr, newstate)
	void * addr;
	int newstate;
d1766 1
a1766 3
gus_speaker_ctl(addr, newstate)
	void * addr;
	int newstate;
d1788 1
a1788 3
gus_linein_ctl(addr, newstate)
	void * addr;
	int newstate;
d1810 1
a1810 3
gus_mic_ctl(addr, newstate)
	void * addr;
	int newstate;
d1836 1
a1836 4
gus_set_endaddr(sc, voice, addr)
	struct gus_softc *sc;
	int voice;
	u_long addr;
d1858 1
a1858 4
gus_set_curaddr(sc, voice, addr)
	struct gus_softc *sc;
	int voice;
	u_long addr;
d1881 1
a1881 3
gus_get_curaddr(sc, voice)
	struct gus_softc *sc;
	int voice;
d1909 1
a1909 2
convert_to_16bit(address)
	u_long address;
d1926 2
a1927 5
guspoke(iot, ioh2, address, value)
	bus_space_tag_t iot;
	bus_space_handle_t ioh2;
	long address;
	unsigned char value;
d1951 1
a1951 4
guspeek(iot, ioh2, address)
	bus_space_tag_t iot;
	bus_space_handle_t ioh2;
	u_long address;
d1975 1
a1975 3
gusreset(sc, voices)
	struct gus_softc *sc;
	int voices;
d2105 1
a2105 2
gus_init_cs4231(sc)
	struct gus_softc *sc;
d2157 1
a2157 3
gus_getdev(addr, dev)
	void * addr;
	struct audio_device *dev;
d2168 1
a2168 4
gus_set_in_gain(addr, gain, balance)
	caddr_t addr;
	u_int gain;
	u_char balance;
d2175 1
a2175 2
gus_get_in_gain(addr)
	caddr_t addr;
d2182 2
a2183 6
gusmax_dma_input(addr, buf, size, callback, arg)
	void * addr;
	void *buf;
	int size;
	void (*callback)(void *);
	void *arg;
d2194 2
a2195 6
gus_dma_input(addr, buf, size, callback, arg)
	void * addr;
	void *buf;
	int size;
	void (*callback)(void *);
	void *arg;
d2243 1
a2243 2
gus_dmain_intr(sc)
	struct gus_softc *sc;
d2270 1
a2270 2
gusmax_halt_out_dma(addr)
	void * addr;
d2278 1
a2278 2
gusmax_halt_in_dma(addr)
	void * addr;
d2288 1
a2288 2
gus_halt_out_dma(addr)
	void * addr;
d2324 1
a2324 2
gus_halt_in_dma(addr)
	void * addr;
d2371 1
a2371 3
gusmax_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d2410 1
a2410 3
gus_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d2533 1
a2533 3
gusics_master_mute(ic, mute)
	struct ics2101_softc *ic;
	int mute;
d2540 1
a2540 3
gusics_mic_mute(ic, mute)
	struct ics2101_softc *ic;
	int mute;
d2547 1
a2547 3
gusics_linein_mute(ic, mute)
	struct ics2101_softc *ic;
	int mute;
d2554 1
a2554 3
gusics_cd_mute(ic, mute)
	struct ics2101_softc *ic;
	int mute;
d2561 1
a2561 3
gusics_dac_mute(ic, mute)
	struct ics2101_softc *ic;
	int mute;
d2568 1
a2568 3
gusmax_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d2607 1
a2607 3
gus_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d2765 1
a2765 2
gus_get_props(addr)
	void *addr;
d2773 1
a2773 2
gusmax_get_props(addr)
	void *addr;
d2780 1
a2780 3
gusmax_mixer_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d2994 1
a2994 3
gus_mixer_query_devinfo(addr, dip)
	void *addr;
	mixer_devinfo_t *dip;
d3147 1
a3147 3
gus_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d3215 1
a3215 2
gus_init_ics2101(sc)
	struct gus_softc *sc;
d3295 1
a3295 3
gus_subattach(sc, ia)
	struct gus_softc *sc;
	struct isa_attach_args *ia;
d3513 1
a3513 3
gus_test_iobase (iot, iobase)
	bus_space_tag_t iot;
	int iobase;
@


1.37
log
@Since audio code is mp safe, establish isa and pci audio interrupts
with the IPL_MPSAFE flag. In certain circumstances, this prevents
interrupt handlers from waiting the global kernel_lock possibly (hold
by slower code) to be released.

ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.36 2013/05/15 08:29:24 ratchov Exp $	*/
d474 1
a474 1
 * called at splgus() from interrupt handler.
d516 1
a516 1
 * Called at splgus/splaudio already, either from intr handler or from
d621 1
a621 1
 * Close out device stuff.  Called at splgus() from generic audio layer.
d1258 1
a1258 1
 * Send/receive data into GUS's DRAM using DMA.  Called at splgus()
d1332 1
a1332 1
 * splgus().
d1429 1
a1429 1
 * Stop a given voice.  called at splgus()
d1473 1
a1473 1
 * Set the volume of a given voice.  Called at splgus().
d1747 1
a1747 1
 * Set the sample rate of the given voice.  Called at splgus().
d1786 1
a1786 1
 * SDK.  Called at splgus().
d1895 1
a1895 1
 * Set the end address of a give voice.  Called at splgus()
d1921 1
a1921 1
 * Set current address.  called at splgus()
d1947 1
a1947 1
 * Get current GUS playback address.  Called at splgus().
d2282 1
a2282 1
 * Called at splgus(), either from top-half or from interrupt handler.
d2383 1
a2383 1
 * Stop any DMA output.  Called at splgus().
d2420 1
a2420 1
 * Stop any DMA output.  Called at splgus().
a3594 3
	/* XXX we shouldn't have to use splgus == splclock, nor should
	 * we use IPL_CLOCK.
	 */
@


1.36
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.35 2012/02/25 22:33:22 miod Exp $	*/
d3598 3
a3600 2
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);
@


1.35
log
@Don't tinker with the MIDI registers if they aren't mapped; necessary for the
GUS PnP.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.34 2010/07/15 03:43:11 jakemsr Exp $	*/
d533 1
a533 1

d537 1
d560 2
a561 1
		if (size == 0)
d563 1
d602 1
a602 1

d680 1
d702 2
a703 1
	if (retval)
d705 2
a736 1
	int s;
d743 1
a743 1
	s = splgus();
d753 1
a753 1
	splx(s);
a1530 1
	int s;
d1544 2
a1545 1
	s = splaudio();
d1559 1
a1559 1
	splx(s);
a1693 1
	int s;
d1698 2
a1699 1
	s = splgus();
d1706 1
a1706 1
	splx(s);
d2061 1
a2061 1
	int i,s;
d2063 1
a2063 1
	s = splgus();
d2180 1
a2180 1
	splx(s);
d2298 1
d2302 2
a2303 2

	if (sc->sc_precision == 16)
d2305 1
d2333 1
a2333 1

d2393 1
d2415 1
a2415 1

d2429 2
d2447 1
a2447 1

d3650 1
a3650 1
	int s, rv = 0;
d3670 1
a3670 1
	s = splgus();
d3683 1
a3683 1
	splx(s);
@


1.34
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.33 2009/08/26 22:29:09 jasper Exp $	*/
d2078 1
a2078 1
	 * Reset MIDI port as well
d2081 2
a2082 1
	bus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, MIDI_RESET);
d2084 1
a2084 1
	delay(500);
d2086 2
a2087 1
	bus_space_write_1(iot, ioh4, GUS_MIDI_CONTROL, 0x00);
@


1.33
log
@directly calling Debugger() is bad. turn these printf();Debugger(); series
into panic()'s.

ok deraadt@@ jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.32 2008/10/15 19:12:18 blambert Exp $	*/
d1576 3
d3316 3
@


1.32
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.31 2008/06/26 05:42:16 ray Exp $	*/
d1004 1
a1004 2
#ifdef DDB
			    printf("%s: negative bufcnt in stopped voice\n",
a1005 5
			    Debugger();
#else
			    panic("%s: negative bufcnt in stopped voice",
				  sc->sc_dev.dv_xname);
#endif
@


1.31
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.30 2008/04/21 00:32:42 jakemsr Exp $	*/
d1327 1
a1327 1
	timeout_add(&sc->sc_dma_tmo, hz);
@


1.30
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.29 2006/03/04 12:42:23 miod Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.29
log
@Internal interrupt counters should be compiled only if option AUDIO_DEBUG
rather than if option DIAGNOSTIC.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.28 2005/10/19 22:52:02 fgsch Exp $	*/
d307 1
d344 4
@


1.28
log
@make this compile with AUDIO_DEBUG; reported in tech@@ by
Gordon Willem Klok (gklok at cogeco dot ca).
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.27 2004/06/13 21:49:24 niklas Exp $	*/
d655 1
a655 1
#ifdef DIAGNOSTIC
d674 1
a674 1
#ifdef DIAGNOSTIC
d681 1
a681 1
#ifdef DIAGNOSTIC
d695 1
a695 1
#ifdef DIAGNOSTIC
@


1.27
log
@debranch SMP, have fun
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d501 2
a502 2
      dmarecords[dmarecord_index].direction = 1;
      dmarecord_index = ++dmarecord_index % NDMARECS;
d595 2
a596 2
	  dmarecords[dmarecord_index].direction = 1;
	  dmarecord_index = ++dmarecord_index % NDMARECS;
d896 2
a897 2
		  playstats[playcntr].curaddr = gus_get_curaddr(sc, GUS_VOICE_LEFT);
		  playcntr = ++playcntr % NDMARECS;
d1144 2
a1145 2
		playstats[playcntr].vaction = 5;
		playcntr = ++playcntr % NDMARECS;
d1242 2
a1243 2
		playstats[playcntr].bufcnt = sc->sc_bufcnt;
		playcntr = ++playcntr % NDMARECS;
@


1.26
log
@Fix probe for GUS MAX cards; from NetBSD.
mickey@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.25 2003/04/27 11:22:53 ho Exp $	*/
a121 1
#include <i386/isa/icu.h>
@


1.25
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.24 2002/03/14 01:26:56 millert Exp $	*/
d60 2
a61 2
 * ftp://freedom.nmsu.edu/pub/ultrasound/gravis/util/
 *	gusdkXXX.zip (developers' kit--get rev 2.22 or later)
d2206 1
a2206 1
	if (ad1848_probe(&sc->sc_codec) == 0) {
d3458 1
a3458 1
	 * option of using two DMA channels (the other one given by the flags
d3506 1
a3506 1
	if (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {
d3554 7
a3560 1
	snprintf(gus_device.version, sizeof gus_device.version, "3.%d",
d3563 10
a3572 6
	printf(": ver 3.%d, %dKB DRAM, ",
	       sc->sc_revision, sc->sc_dsize);
	if (HAS_MIXER(sc))
		printf("ICS2101 mixer, ");
	if (HAS_CODEC(sc))
		printf("%s codec/mixer, ", sc->sc_codec.chip_name);
@


1.24
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.23 2001/01/29 05:30:30 mickey Exp $	*/
d2906 1
a2906 1
	strcpy(dip->label.name, AudioNmicrophone);
d2908 2
a2909 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2918 1
a2918 1
	strcpy(dip->label.name, AudioNmicrophone);
d2920 2
a2921 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2929 1
a2929 1
	strcpy(dip->label.name, AudioNdac);
d2931 2
a2932 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2940 1
a2940 1
	strcpy(dip->label.name, AudioNline);
d2942 2
a2943 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2951 1
a2951 1
	strcpy(dip->label.name, AudioNcd);
d2953 2
a2954 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2963 1
a2963 1
	strcpy(dip->label.name, AudioNmonitor);
d2965 2
a2966 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2973 1
a2973 1
	strcpy(dip->label.name, AudioNoutput);
d2975 2
a2976 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d2984 1
a2984 1
	strcpy(dip->label.name, AudioNmaster);
d2986 2
a2987 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d3031 1
a3031 1
	strcpy(dip->label.name, AudioNmute);
d3033 2
a3034 1
	strcpy(dip->un.e.member[0].label.name, AudioNoff);
d3036 2
a3037 1
	strcpy(dip->un.e.member[1].label.name, AudioNon);
d3046 1
a3046 1
	strcpy(dip->label.name, AudioNrecord);
d3048 1
a3048 1
	strcpy(dip->un.v.units.name, AudioNvolume);
d3056 1
a3056 1
	strcpy(dip->label.name, AudioNsource);
d3058 2
a3059 1
	strcpy(dip->un.e.member[0].label.name, AudioNoutput);
d3061 2
a3062 1
	strcpy(dip->un.e.member[1].label.name, AudioNmicrophone);
d3064 2
a3065 1
	strcpy(dip->un.e.member[2].label.name, AudioNdac);
d3067 2
a3068 1
	strcpy(dip->un.e.member[3].label.name, AudioNline);
d3076 1
a3076 1
	strcpy(dip->label.name, AudioCinputs);
d3083 1
a3083 1
	strcpy(dip->label.name, AudioCoutputs);
d3090 1
a3090 1
	strcpy(dip->label.name, AudioCmonitor);
d3097 1
a3097 1
	strcpy(dip->label.name, AudioCrecord);
d3127 2
a3128 1
		strcpy(dip->label.name, AudioNmicrophone);
d3130 2
a3131 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d3139 1
a3139 1
		strcpy(dip->label.name, AudioNline);
d3141 2
a3142 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d3150 1
a3150 1
		strcpy(dip->label.name, AudioNcd);
d3152 2
a3153 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d3161 1
a3161 1
		strcpy(dip->label.name, AudioNdac);
d3163 2
a3164 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d3172 1
a3172 1
		strcpy(dip->label.name, AudioNmaster);
d3174 2
a3175 1
		strcpy(dip->un.v.units.name, AudioNvolume);
d3213 1
a3213 1
		strcpy(dip->label.name, AudioNmute);
d3215 2
a3216 1
		strcpy(dip->un.e.member[0].label.name, AudioNoff);
d3218 2
a3219 1
		strcpy(dip->un.e.member[1].label.name, AudioNon);
d3227 1
a3227 1
		strcpy(dip->label.name, AudioNsource);
d3229 2
a3230 1
		strcpy(dip->un.e.member[0].label.name, AudioNoutput);
d3238 1
a3238 1
		strcpy(dip->label.name, AudioCinputs);
d3245 1
a3245 1
		strcpy(dip->label.name, AudioCoutputs);
d3252 1
a3252 1
		strcpy(dip->label.name, AudioCrecord);
d3270 1
a3270 1
		strcpy(fp->name, AudioEmulaw);
d3276 1
a3276 1
		strcpy(fp->name, AudioEslinear);
d3282 1
a3282 1
		strcpy(fp->name, AudioEslinear_le);
d3288 1
a3288 1
		strcpy(fp->name, AudioEulinear);
d3294 1
a3294 1
		strcpy(fp->name, AudioEulinear_le);
d3300 1
a3300 1
		strcpy(fp->name, AudioEslinear_be);
d3306 1
a3306 1
		strcpy(fp->name, AudioEulinear_be);
d3312 1
a3312 1
		strcpy(fp->name, AudioEalaw);
d3554 2
a3555 1
	sprintf(gus_device.version, "3.%d", sc->sc_revision);
@


1.23
log
@new timeouts; some constifying; space control
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.22 2000/08/19 14:25:15 nate Exp $	*/
d469 1
a469 1
	void (*intr) __P((void *));
d527 1
a527 1
	void (*intr) __P((void *));
d921 1
a921 1
	    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;
d1066 1
a1066 1
			    void (*pfunc) __P((void *)) = sc->sc_dmaoutintr;
d2271 1
a2271 1
	void (*callback) __P((void *));
d2287 1
a2287 1
	void (*callback) __P((void *));
d2337 1
a2337 1
        void (*callback) __P((void *));
@


1.23.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.23 2001/01/29 05:30:30 mickey Exp $	*/
d469 1
a469 1
	void (*intr)(void *);
d527 1
a527 1
	void (*intr)(void *);
d921 1
a921 1
	    void (*pfunc)(void *) = sc->sc_dmaoutintr;
d1066 1
a1066 1
			    void (*pfunc)(void *) = sc->sc_dmaoutintr;
d2271 1
a2271 1
	void (*callback)(void *);
d2287 1
a2287 1
	void (*callback)(void *);
d2337 1
a2337 1
        void (*callback)(void *);
@


1.23.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2906 1
a2906 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d2908 1
a2908 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2917 1
a2917 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d2919 1
a2919 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2927 1
a2927 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d2929 1
a2929 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2937 1
a2937 1
	strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d2939 1
a2939 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2947 1
a2947 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d2949 1
a2949 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2958 1
a2958 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d2960 1
a2960 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2967 1
a2967 1
	strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d2969 1
a2969 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2977 1
a2977 1
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d2979 1
a2979 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d3023 1
a3023 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d3025 1
a3025 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d3027 1
a3027 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d3036 1
a3036 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d3038 1
a3038 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d3046 1
a3046 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d3048 1
a3048 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
	    sizeof dip->un.e.member[0].label.name);
d3050 1
a3050 2
	strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[1].label.name);
d3052 1
a3052 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
d3054 1
a3054 2
	strlcpy(dip->un.e.member[3].label.name, AudioNline,
	    sizeof dip->un.e.member[3].label.name);
d3062 1
a3062 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d3069 1
a3069 1
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d3076 1
a3076 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d3083 1
a3083 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d3113 1
a3113 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d3115 1
a3115 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3123 1
a3123 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d3125 1
a3125 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3133 1
a3133 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d3135 1
a3135 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3143 1
a3143 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d3145 1
a3145 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3153 1
a3153 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d3155 1
a3155 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3193 1
a3193 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d3195 1
a3195 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d3197 1
a3197 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d3205 1
a3205 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d3207 1
a3207 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
		    sizeof dip->un.e.member[0].label.name);
d3215 1
a3215 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d3222 1
a3222 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d3229 1
a3229 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d3247 1
a3247 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d3253 1
a3253 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d3259 1
a3259 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d3265 1
a3265 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d3271 1
a3271 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d3277 1
a3277 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d3283 1
a3283 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d3289 1
a3289 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d3531 1
a3531 2
	snprintf(gus_device.version, sizeof gus_device.version, "3.%d",
	    sc->sc_revision);
@


1.22
log
@MALLOC/FREE -> malloc/free ok art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.21 1999/07/05 20:08:37 deraadt Exp $	*/
d21 1
a21 1
 *        This product includes software developed by the NetBSD 
d23 2
a24 2
 * 4. Neither the name of The NetBSD Foundation nor the names of its 
 *    contributors may be used to endorse or promote products derived 
d45 1
a45 1
 *  	. figure out a better deinterleave strategy that avoids sucking up
d61 1
a61 1
 * 	gusdkXXX.zip (developers' kit--get rev 2.22 or later)
d81 1
a81 1
 *                            |  +---|-/  |    |   +-+ 	|
d88 1
a88 1
 *   |    |    |   /----|6|------+   	       +--------+
d91 1
a91 1
 *     CS4231   	8-to-16 bit bus conversion, if needed
d109 1
d162 1
a162 1
int gus_irq_map[] = {
d166 1
a166 1
int gus_drq_map[] = {
d174 1
a174 1
int gus_base_addrs[] = {
d177 1
a177 1
int gus_addrs = sizeof(gus_base_addrs) / sizeof(gus_base_addrs[0]);
d185 1
a185 1
static int gus_max_frequency[] = {
d211 1
a211 1
static unsigned short gus_log_volumes[512] = {
d315 1
a315 1
	
d317 1
a317 1
	
d319 1
a319 1
	
d321 1
a321 1
	
d323 1
a323 1
	
d326 1
a326 1
	
d331 1
a331 1
	
d333 1
a333 1
	
d545 1
a545 1
	    flags |= GUSMASK_DMA_DATA_SIZE; 
d569 1
a569 1
 		boarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;
d728 1
a728 1
 	void *arg;
d730 14
a743 14
 	struct gus_softc *sc = arg;
 	bus_space_tag_t iot = sc->sc_iot;
 	bus_space_handle_t ioh2 = sc->sc_ioh2;
 	int s;

 	printf("%s: dmaout timeout\n", sc->sc_dev.dv_xname);
 	/*
 	 * Stop any DMA.
 	 */

 	s = splgus();
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);
 	
d745 2
a746 2
 	/* XXX we will dmadone below? */
 	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
d748 3
a750 3
 	
 	gus_dmaout_dointr(sc);
 	splx(s);
d772 2
a773 2
 	if (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {
	    untimeout(gus_dmaout_timeout, sc);
d784 2
a785 2
 	bus_space_tag_t iot = sc->sc_iot;
 	bus_space_handle_t ioh2 = sc->sc_ioh2;
d788 1
a788 1
 	isa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);
d790 1
a790 1
 	DMAPRINTF(("gus_dmaout_dointr %d @@ %p\n", sc->sc_dmaoutcnt,
d868 1
a868 1
		 * XXX 
d913 1
a913 1
	sc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs; 
d958 1
a958 1
		 	return rval;
d997 1
a997 1
			     * get the next buffer in place. 
d1124 1
a1124 1
		sc->sc_voc[GUS_VOICE_LEFT].current_addr + 
d1178 1
a1178 1
	/* 
d1183 1
a1183 1
    
d1200 1
a1200 1
	/* 
d1299 1
a1299 1
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
d1308 2
a1309 2
 	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,
 	    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);
d1317 2
a1318 2
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);
 	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));
d1320 3
a1322 3
 	/*
 	 * Tell the GUS to start doing DMA
 	 */
d1324 1
a1324 1
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
d1330 1
a1330 2
	untimeout(gus_dmaout_timeout, sc); /* flush old one, if there is one */
	timeout(gus_dmaout_timeout, sc, hz);
d1355 3
a1357 3
 	start = sc->sc_voc[voice].start_addr;
 	current = sc->sc_voc[voice].current_addr;
 	end = sc->sc_voc[voice].end_addr;
d1359 1
a1359 1
 	/*
d1718 1
a1718 1
	 * ram. 
d1767 1
a1767 1
 	fc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);
d1769 1
a1769 1
 	fc <<= 1;
d1805 1
a1805 1
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);
d2009 4
a2012 4
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
 	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2036 4
a2039 4
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
 	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
 	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2221 1
a2221 1
		
d2295 1
a2295 1
    
d2308 3
a2310 3
 	    sc->sc_encoding == AUDIO_ENCODING_ALAW ||
 	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||
 	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)
d2314 2
a2315 2
 	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,
 	    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);
d2342 1
a2342 1
 	    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);
d2385 3
a2387 3
 	struct gus_softc *sc = addr;
 	bus_space_tag_t iot = sc->sc_iot;
 	bus_space_handle_t ioh2 = sc->sc_ioh2;
d2394 2
a2395 2
  	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);
d2397 2
a2398 2
	untimeout(gus_dmaout_timeout, sc);
 	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
d2421 3
a2423 3
 	struct gus_softc *sc = addr;
 	bus_space_tag_t iot = sc->sc_iot;
 	bus_space_handle_t ioh2 = sc->sc_ioh2;
d2430 5
a2434 5
  	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH,
 	     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));
  
 	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);
d2472 1
a2472 1
    
d2518 1
a2518 1
    
d2585 1
a2585 1
	
d2683 1
a2683 1
    
d2729 1
a2729 1
    
d2810 1
a2810 1
	
d2988 1
a2988 1
	
d3002 1
a3002 1
	
d3030 1
a3030 1
	
d3078 1
a3078 1
	    
d3165 1
a3165 1
	
d3179 1
a3179 1
	
d3200 1
a3200 1
	
d3393 1
a3393 1
 	int		i;
d3404 1
a3404 1
 	c = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);
d3410 2
a3411 2
 	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
 	bus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);
d3479 3
a3481 3
 	if (sc->sc_revision >= 5 && sc->sc_revision <= 9) {
 		sc->sc_flags |= GUS_MIXER_INSTALLED;
 		gus_init_ics2101(sc);
d3503 8
a3510 6
 	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
 	/*
 	 * Check to see how much memory we have on this card; see if any
 	 * "mirroring" occurs.  We're assuming at least 256K already exists
 	 * on the card; otherwise the initial probe would have failed
 	 */
d3629 2
a3630 2
 	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
d3632 1
a3632 1
 	delay(500);
d3635 1
a3635 1
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);
d3637 1
a3637 1
 	delay(500);
d3645 2
a3646 2
 	s1 = guspeek(iot, ioh2, 0L);
 	s2 = guspeek(iot, ioh2, 1L);
d3648 2
a3649 2
 	guspoke(iot, ioh2, 0L, 0xaa);
 	guspoke(iot, ioh2, 1L, 0x55);
d3651 1
a3651 1
 	if (guspeek(iot, ioh2, 0L) != 0xaa)
@


1.21
log
@first attempt at isapnp gus support
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.20 1999/01/24 15:58:53 mickey Exp $	*/
d640 1
a640 1
		FREE(sc->sc_deintr_buf, M_DEVBUF);
d1628 1
a1628 1
		FREE(sc->sc_deintr_buf, M_DEVBUF);
d1631 1
a1631 1
	MALLOC(sc->sc_deintr_buf, void *, blocksize>>1, M_DEVBUF, M_WAITOK);
@


1.21.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.23 2001/01/29 05:30:30 mickey Exp $	*/
d21 1
a21 1
 *        This product includes software developed by the NetBSD
d23 2
a24 2
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
d45 1
a45 1
 *	. figure out a better deinterleave strategy that avoids sucking up
d61 1
a61 1
 *	gusdkXXX.zip (developers' kit--get rev 2.22 or later)
d81 1
a81 1
 *                            |  +---|-/  |    |   +-+	|
d88 1
a88 1
 *   |    |    |   /----|6|------+	       +--------+
d91 1
a91 1
 *     CS4231	8-to-16 bit bus conversion, if needed
a108 1
#include <sys/timeout.h>
d161 1
a161 1
const int gus_irq_map[] = {
d165 1
a165 1
const int gus_drq_map[] = {
d173 1
a173 1
const int gus_base_addrs[] = {
d176 1
a176 1
const int gus_addrs = sizeof(gus_base_addrs) / sizeof(gus_base_addrs[0]);
d184 1
a184 1
static const int gus_max_frequency[] = {
d210 1
a210 1
static const unsigned short gus_log_volumes[512] = {
d314 1
a314 1

d316 1
a316 1

d318 1
a318 1

d320 1
a320 1

d322 1
a322 1

d325 1
a325 1

d330 1
a330 1

d332 1
a332 1

d544 1
a544 1
	    flags |= GUSMASK_DMA_DATA_SIZE;
d568 1
a568 1
		boarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;
d640 1
a640 1
		free(sc->sc_deintr_buf, M_DEVBUF);
d727 1
a727 1
	void *arg;
d729 14
a742 14
	struct gus_softc *sc = arg;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
	int s;

	printf("%s: dmaout timeout\n", sc->sc_dev.dv_xname);
	/*
	 * Stop any DMA.
	 */

	s = splgus();
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);
 
d744 2
a745 2
	/* XXX we will dmadone below? */
	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
d747 3
a749 3
 
	gus_dmaout_dointr(sc);
	splx(s);
d771 2
a772 2
	if (bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {
	    timeout_del(&sc->sc_dma_tmo);
d783 2
a784 2
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
d787 1
a787 1
	isa_dmadone(sc->sc_dev.dv_parent, sc->sc_drq);
d789 1
a789 1
	DMAPRINTF(("gus_dmaout_dointr %d @@ %p\n", sc->sc_dmaoutcnt,
d867 1
a867 1
		 * XXX
d912 1
a912 1
	sc->sc_dmabuf = ++sc->sc_dmabuf % sc->sc_nbufs;
d957 1
a957 1
			return rval;
d996 1
a996 1
			     * get the next buffer in place.
d1123 1
a1123 1
		sc->sc_voc[GUS_VOICE_LEFT].current_addr +
d1177 1
a1177 1
	/*
d1182 1
a1182 1

d1199 1
a1199 1
	/*
d1298 1
a1298 1
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
d1307 2
a1308 2
	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_drq, buffaddr, length,
	    NULL, DMAMODE_WRITE, BUS_DMA_NOWAIT);
d1316 2
a1317 2
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_START);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (int) (gusaddr >> 4));
d1319 3
a1321 3
	/*
	 * Tell the GUS to start doing DMA
	 */
d1323 1
a1323 1
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
d1329 2
a1330 1
	timeout_add(&sc->sc_dma_tmo, hz);
d1355 3
a1357 3
	start = sc->sc_voc[voice].start_addr;
	current = sc->sc_voc[voice].current_addr;
	end = sc->sc_voc[voice].end_addr;
d1359 1
a1359 1
	/*
d1628 1
a1628 1
		free(sc->sc_deintr_buf, M_DEVBUF);
d1631 1
a1631 1
	sc->sc_deintr_buf = malloc(blocksize/2, M_DEVBUF, M_WAITOK);
d1718 1
a1718 1
	 * ram.
d1767 1
a1767 1
	fc = (unsigned int)(((f << 9L) + (temp >> 1L)) / temp);
d1769 1
a1769 1
	fc <<= 1;
d1805 1
a1805 1
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, realrate);
d2009 4
a2012 4
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2036 4
a2039 4
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_LOW);
	bus_space_write_2(iot, ioh2, GUS_DATA_LOW, (unsigned int) (address & 0xffff));
	SELECT_GUS_REG(iot, ioh2, GUSREG_DRAM_ADDR_HIGH);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2221 1
a2221 1

d2295 1
a2295 1

d2308 3
a2310 3
	    sc->sc_encoding == AUDIO_ENCODING_ALAW ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_LE ||
	    sc->sc_encoding == AUDIO_ENCODING_ULINEAR_BE)
d2314 2
a2315 2
	isa_dmastart(sc->sc_dev.dv_parent, sc->sc_recdrq, buf, size,
	    NULL, DMAMODE_READ, BUS_DMA_NOWAIT);
d2342 1
a2342 1
	    isa_dmadone(sc->sc_dev.dv_parent, sc->sc_recdrq);
d2385 3
a2387 3
	struct gus_softc *sc = addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
d2394 2
a2395 2
	SELECT_GUS_REG(iot, ioh2, GUSREG_DMA_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0);
d2397 2
a2398 2
	timeout_del(&sc->sc_dma_tmo);
	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_drq);
d2421 3
a2423 3
	struct gus_softc *sc = addr;
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh2 = sc->sc_ioh2;
d2430 5
a2434 5
	SELECT_GUS_REG(iot, ioh2, GUSREG_SAMPLE_CONTROL);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH,
	     bus_space_read_1(iot, ioh2, GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));

	isa_dmaabort(sc->sc_dev.dv_parent, sc->sc_recdrq);
d2472 1
a2472 1

d2518 1
a2518 1

d2585 1
a2585 1

d2683 1
a2683 1

d2729 1
a2729 1

d2810 1
a2810 1

d2988 1
a2988 1

d3002 1
a3002 1

d3030 1
a3030 1

d3078 1
a3078 1

d3165 1
a3165 1

d3179 1
a3179 1

d3200 1
a3200 1

d3393 1
a3393 1
	int		i;
d3404 1
a3404 1
	c = bus_space_read_1(iot, sc->sc_ioh3, GUS_BOARD_REV);
d3410 2
a3411 2
	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
	bus_space_write_1(iot, sc->sc_ioh2, GUS_DATA_HIGH, 0x00);
d3479 3
a3481 3
	if (sc->sc_revision >= 5 && sc->sc_revision <= 9) {
		sc->sc_flags |= GUS_MIXER_INSTALLED;
		gus_init_ics2101(sc);
d3503 6
a3508 8
	timeout_set(&sc->sc_dma_tmo, gus_dmaout_timeout, sc);

	SELECT_GUS_REG(iot, sc->sc_ioh2, GUSREG_RESET);
	/*
	 * Check to see how much memory we have on this card; see if any
	 * "mirroring" occurs.  We're assuming at least 256K already exists
	 * on the card; otherwise the initial probe would have failed
	 */
d3627 2
a3628 2
	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);
d3630 1
a3630 1
	delay(500);
d3633 1
a3633 1
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);
d3635 1
a3635 1
	delay(500);
d3643 2
a3644 2
	s1 = guspeek(iot, ioh2, 0L);
	s2 = guspeek(iot, ioh2, 1L);
d3646 2
a3647 2
	guspoke(iot, ioh2, 0L, 0xaa);
	guspoke(iot, ioh2, 1L, 0x55);
d3649 1
a3649 1
	if (guspeek(iot, ioh2, 0L) != 0xaa)
@


1.21.4.2
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d469 1
a469 1
	void (*intr)(void *);
d527 1
a527 1
	void (*intr)(void *);
d921 1
a921 1
	    void (*pfunc)(void *) = sc->sc_dmaoutintr;
d1066 1
a1066 1
			    void (*pfunc)(void *) = sc->sc_dmaoutintr;
d2271 1
a2271 1
	void (*callback)(void *);
d2287 1
a2287 1
	void (*callback)(void *);
d2337 1
a2337 1
        void (*callback)(void *);
@


1.21.4.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.21.4.2 2002/03/28 12:11:35 niklas Exp $	*/
d2906 1
a2906 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d2908 1
a2908 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2917 1
a2917 1
	strlcpy(dip->label.name, AudioNmicrophone, sizeof dip->label.name);
d2919 1
a2919 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2927 1
a2927 1
	strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d2929 1
a2929 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2937 1
a2937 1
	strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d2939 1
a2939 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2947 1
a2947 1
	strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d2949 1
a2949 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2958 1
a2958 1
	strlcpy(dip->label.name, AudioNmonitor, sizeof dip->label.name);
d2960 1
a2960 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2967 1
a2967 1
	strlcpy(dip->label.name, AudioNoutput, sizeof dip->label.name);
d2969 1
a2969 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d2977 1
a2977 1
	strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d2979 1
a2979 2
	strlcpy(dip->un.v.units.name, AudioNvolume,
	    sizeof dip->un.v.units.name);
d3023 1
a3023 1
	strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d3025 1
a3025 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoff,
	    sizeof dip->un.e.member[0].label.name);
d3027 1
a3027 2
	strlcpy(dip->un.e.member[1].label.name, AudioNon,
	    sizeof dip->un.e.member[1].label.name);
d3036 1
a3036 1
	strlcpy(dip->label.name, AudioNrecord, sizeof dip->label.name);
d3038 1
a3038 1
	strlcpy(dip->un.v.units.name, AudioNvolume, sizeof dip->un.v.units.name);
d3046 1
a3046 1
	strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d3048 1
a3048 2
	strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
	    sizeof dip->un.e.member[0].label.name);
d3050 1
a3050 2
	strlcpy(dip->un.e.member[1].label.name, AudioNmicrophone,
	    sizeof dip->un.e.member[1].label.name);
d3052 1
a3052 2
	strlcpy(dip->un.e.member[2].label.name, AudioNdac,
	    sizeof dip->un.e.member[2].label.name);
d3054 1
a3054 2
	strlcpy(dip->un.e.member[3].label.name, AudioNline,
	    sizeof dip->un.e.member[3].label.name);
d3062 1
a3062 1
	strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d3069 1
a3069 1
	strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d3076 1
a3076 1
	strlcpy(dip->label.name, AudioCmonitor, sizeof dip->label.name);
d3083 1
a3083 1
	strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d3113 1
a3113 2
		strlcpy(dip->label.name, AudioNmicrophone,
		    sizeof dip->label.name);
d3115 1
a3115 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3123 1
a3123 1
		strlcpy(dip->label.name, AudioNline, sizeof dip->label.name);
d3125 1
a3125 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3133 1
a3133 1
		strlcpy(dip->label.name, AudioNcd, sizeof dip->label.name);
d3135 1
a3135 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3143 1
a3143 1
		strlcpy(dip->label.name, AudioNdac, sizeof dip->label.name);
d3145 1
a3145 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3153 1
a3153 1
		strlcpy(dip->label.name, AudioNmaster, sizeof dip->label.name);
d3155 1
a3155 2
		strlcpy(dip->un.v.units.name, AudioNvolume,
		    sizeof dip->un.v.units.name);
d3193 1
a3193 1
		strlcpy(dip->label.name, AudioNmute, sizeof dip->label.name);
d3195 1
a3195 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoff,
		    sizeof dip->un.e.member[0].label.name);
d3197 1
a3197 2
		strlcpy(dip->un.e.member[1].label.name, AudioNon,
		    sizeof dip->un.e.member[1].label.name);
d3205 1
a3205 1
		strlcpy(dip->label.name, AudioNsource, sizeof dip->label.name);
d3207 1
a3207 2
		strlcpy(dip->un.e.member[0].label.name, AudioNoutput,
		    sizeof dip->un.e.member[0].label.name);
d3215 1
a3215 1
		strlcpy(dip->label.name, AudioCinputs, sizeof dip->label.name);
d3222 1
a3222 1
		strlcpy(dip->label.name, AudioCoutputs, sizeof dip->label.name);
d3229 1
a3229 1
		strlcpy(dip->label.name, AudioCrecord, sizeof dip->label.name);
d3247 1
a3247 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d3253 1
a3253 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d3259 1
a3259 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d3265 1
a3265 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d3271 1
a3271 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d3277 1
a3277 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d3283 1
a3283 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d3289 1
a3289 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d3531 1
a3531 2
	snprintf(gus_device.version, sizeof gus_device.version, "3.%d",
	    sc->sc_revision);
@


1.21.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d60 2
a61 2
 * http://www.gravis.com/Public/sdk/GUSDK222.ZIP
 *
d2206 1
a2206 1
	if (ad1848_mapprobe(&sc->sc_codec, sc->sc_codec.sc_iobase) == 0) {
d3458 1
a3458 1
	 * option of using two DMA channels (the other one given by the drq2
d3506 1
a3506 1
	if (sc->sc_revision < 10 || !gus_init_cs4231(sc)) {
d3554 1
a3554 7
	/*
	 * The "official" (3.x) version number cannot easily be obtained.
	 * The revision register does not correspond to the minor number
	 * of the board version. Simply use the revision register as
	 * identification.
	 */
	snprintf(gus_device.version, sizeof gus_device.version, "%d",
d3557 6
a3562 10
	printf(": ver %d", sc->sc_revision);
	if (sc->sc_revision >= 10)
		printf(", MAX");
	else {
		if (HAS_MIXER(sc))
			printf(", ICS2101 mixer");
		if (HAS_CODEC(sc))
			printf(", %s codec/mixer", sc->sc_codec.chip_name);
	}
	printf(", %dKB DRAM, ", sc->sc_dsize);
@


1.21.4.5
log
@a small step towards an integrated PIC/APIC system: move isa/icu.h to
include/i8259.h, and adapt the ACK/MASK/UNMASK macros so we can
reuse the API for APICs.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.21.4.4 2004/02/19 10:56:21 niklas Exp $	*/
d122 1
@


1.20
log
@remove unneeded pio.h inclusion
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.19 1999/01/02 00:02:45 niklas Exp $	*/
a97 3
#include "gus.h"
#if NGUS > 0

d130 1
a130 190

#ifdef AUDIO_DEBUG
#define STATIC /* empty; for debugging symbols */
#else
#define STATIC static
#endif

/*
 * Software state of a single "voice" on the GUS
 */

struct gus_voice {

	/*
	 * Various control bits
	 */

	unsigned char voccntl;	/* State of voice control register */
	unsigned char volcntl;	/* State of volume control register */
	unsigned char pan_pos;	/* Position of volume panning (4 bits) */
	int rate;		/* Sample rate of voice being played back */

	/*
	 * Address of the voice data into the GUS's DRAM.  20 bits each
	 */

	u_long start_addr;	/* Starting address of voice data loop area */
	u_long end_addr;	/* Ending address of voice data loop */
	u_long current_addr;	/* Beginning address of voice data
				   (start playing here) */

	/*
	 * linear volume values for the GUS's volume ramp.  0-511 (9 bits).
	 * These values must be translated into the logarithmic values using
	 * gus_log_volumes[]
	 */

	int start_volume;	/* Starting position of volume ramp */
	int current_volume;	/* Current position of volume on volume ramp */
	int end_volume;		/* Ending position of volume on volume ramp */
};

/*
 * Software state of GUS
 */

struct gus_softc {
	struct device sc_dev;		/* base device */
	struct device *sc_isa;		/* pointer to ISA parent */
	void *sc_ih;			/* interrupt vector */
	bus_space_tag_t sc_iot;		/* tag */
	bus_space_handle_t sc_ioh1;	/* handle */
	bus_space_handle_t sc_ioh2;	/* handle */
	bus_space_handle_t sc_ioh3;	/* ICS2101 handle */
	bus_space_handle_t sc_ioh4;	/* MIDI handle */

	int sc_iobase;			/* I/O base address */
	int sc_irq;			/* IRQ used */
	int sc_drq;			/* DMA channel for play */
	int sc_recdrq;			/* DMA channel for recording */

	int sc_flags;			/* Various flags about the GUS */
#define GUS_MIXER_INSTALLED	0x01	/* An ICS mixer is installed */
#define GUS_LOCKED		0x02	/* GUS is busy doing multi-phase DMA */
#define GUS_CODEC_INSTALLED	0x04	/* CS4231 installed/MAX */
#define GUS_PLAYING		0x08	/* GUS is playing a voice */
#define GUS_DMAOUT_ACTIVE	0x10	/* GUS is busy doing audio DMA */
#define GUS_DMAIN_ACTIVE	0x20	/* GUS is busy sampling  */
#define GUS_OPEN		0x100	/* GUS is open */
	int sc_dsize;			/* Size of GUS DRAM */
	int sc_voices;			/* Number of active voices */
	u_char sc_revision;		/* Board revision of GUS */
	u_char sc_mixcontrol;		/* Value of GUS_MIX_CONTROL register */

	u_long sc_orate;		/* Output sampling rate */
	u_long sc_irate;		/* Input sampling rate */

	int sc_encoding;		/* Current data encoding type */
	int sc_precision;		/* # of bits of precision */
	int sc_channels;		/* Number of active channels */
	int sc_blocksize;		/* Current blocksize */
	int sc_chanblocksize;		/* Current blocksize for each in-use
					   channel */
	short sc_nbufs;			/* how many on-GUS bufs per-channel */
	short sc_bufcnt;		/* how many need to be played */
	void *sc_deintr_buf;		/* deinterleave buffer for stereo */

	int sc_ogain;			/* Output gain control */
	u_char sc_out_port;		/* Current out port (generic only) */
	u_char sc_in_port;		/* keep track of it when no codec */

	void (*sc_dmaoutintr) __P((void*)); /* DMA completion intr handler */
	void *sc_outarg;		/* argument for sc_dmaoutintr() */
	u_char *sc_dmaoutaddr;		/* for isadma_done */
	u_long sc_gusaddr;		/* where did we just put it? */
	int sc_dmaoutcnt;		/* for isadma_done */

	void (*sc_dmainintr) __P((void*)); /* DMA completion intr handler */
	void *sc_inarg;			/* argument for sc_dmaoutintr() */
	u_char *sc_dmainaddr;		/* for isadma_done */
	int sc_dmaincnt;		/* for isadma_done */

	struct stereo_dma_intr {
		void (*intr)__P((void *));
		void *arg;
		u_char *buffer;
		u_long dmabuf;
		int size;
		int flags;
	} sc_stereo;

	/*
	 * State information for linear audio layer
	 */

	int sc_dmabuf;			/* Which ring buffer we're DMA'ing to */
	int sc_playbuf;			/* Which ring buffer we're playing */

	/*
	 * Voice information array.  All voice-specific information is stored
	 * here
	 */

	struct gus_voice sc_voc[32];	/* Voice data for each voice */
	union {
		struct ics2101_softc sc_mixer_u;
		struct ad1848_softc sc_codec_u;
	} u;
#define sc_mixer u.sc_mixer_u
#define sc_codec u.sc_codec_u
};

struct ics2101_volume {
	u_char left;
	u_char right;
};

#define HAS_CODEC(sc) ((sc)->sc_flags & GUS_CODEC_INSTALLED)
#define HAS_MIXER(sc) ((sc)->sc_flags & GUS_MIXER_INSTALLED)

/*
 * Mixer devices for ICS2101
 */
/* MIC IN mute, line in mute, line out mute are first since they can be done
   even if no ICS mixer. */
#define GUSICS_MIC_IN_MUTE		0
#define GUSICS_LINE_IN_MUTE		1
#define GUSICS_MASTER_MUTE		2
#define GUSICS_CD_MUTE			3
#define GUSICS_DAC_MUTE			4
#define GUSICS_MIC_IN_LVL		5
#define GUSICS_LINE_IN_LVL		6
#define GUSICS_CD_LVL			7
#define GUSICS_DAC_LVL			8
#define GUSICS_MASTER_LVL		9

#define GUSICS_RECORD_SOURCE		10

/* Classes */
#define GUSICS_INPUT_CLASS		11
#define GUSICS_OUTPUT_CLASS		12
#define GUSICS_RECORD_CLASS		13

/*
 * Mixer & MUX devices for CS4231
 */
#define GUSMAX_MONO_LVL			0 /* mic input to MUX;
					     also mono mixer input */
#define GUSMAX_DAC_LVL			1 /* input to MUX; also mixer input */
#define GUSMAX_LINE_IN_LVL		2 /* input to MUX; also mixer input */
#define GUSMAX_CD_LVL			3 /* mixer input only */
#define GUSMAX_MONITOR_LVL		4 /* digital mix (?) */
#define GUSMAX_OUT_LVL			5 /* output level. (?) */
#define GUSMAX_SPEAKER_LVL		6 /* pseudo-device for mute */
#define GUSMAX_LINE_IN_MUTE		7 /* pre-mixer */
#define GUSMAX_DAC_MUTE			8 /* pre-mixer */
#define GUSMAX_CD_MUTE			9 /* pre-mixer */
#define GUSMAX_MONO_MUTE		10 /* pre-mixer--microphone/mono */
#define GUSMAX_MONITOR_MUTE		11 /* post-mixer level/mute */
#define GUSMAX_SPEAKER_MUTE		12 /* speaker mute */

#define GUSMAX_REC_LVL			13 /* post-MUX gain */

#define GUSMAX_RECORD_SOURCE		14

/* Classes */
#define GUSMAX_INPUT_CLASS		15
#define GUSMAX_RECORD_CLASS		16
#define GUSMAX_MONITOR_CLASS		17
#define GUSMAX_OUTPUT_CLASS		18
d147 2
a148 8
struct dma_record {
    struct timeval tv;
    u_long gusaddr;
    caddr_t bsdaddr;
    u_short count;
    u_char channel;
    u_char direction;
} dmarecords[NDMARECS];
a152 97
/*
 * local routines
 */

int	gusopen __P((void *, int));
void	gusclose __P((void *));
void	gusmax_close __P((void *));
int	gusintr __P((void *));
int	gus_set_in_gain __P((caddr_t, u_int, u_char));
int	gus_get_in_gain __P((caddr_t));
int	gus_set_out_gain __P((caddr_t, u_int, u_char));
int	gus_get_out_gain __P((caddr_t));
int 	gus_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int 	gusmax_set_params __P((void *, int, int, struct audio_params *, struct audio_params *));
int	gus_round_blocksize __P((void *, int));
int	gus_commit_settings __P((void *));
int	gus_dma_output __P((void *, void *, int, void (*)(void *), void *));
int	gus_dma_input __P((void *, void *, int, void (*)(void *), void *));
int	gus_halt_out_dma __P((void *));
int	gus_halt_in_dma __P((void *));
int	gus_speaker_ctl __P((void *, int));
int	gusmaxopen __P((void *, int));
int	gusmax_round_blocksize __P((void *, int));
int	gusmax_commit_settings __P((void *));
int	gusmax_dma_output __P((void *, void *, int, void (*)(void *), void *));
int	gusmax_dma_input __P((void *, void *, int, void (*)(void *), void *));
int	gusmax_halt_out_dma __P((void *));
int	gusmax_halt_in_dma __P((void *));
int	gusmax_speaker_ctl __P((void *, int));
int	gus_getdev __P((void *, struct audio_device *));

STATIC void	gus_deinterleave __P((struct gus_softc *, void *, int));

STATIC int	gus_mic_ctl __P((void *, int));
STATIC int	gus_linein_ctl __P((void *, int));
STATIC int	gus_test_iobase __P((bus_space_tag_t, int));
STATIC void	guspoke __P((bus_space_tag_t, bus_space_handle_t, long, u_char));
STATIC void	gusdmaout __P((struct gus_softc *, int, u_long, caddr_t, int));
STATIC int	gus_init_cs4231 __P((struct gus_softc *));
STATIC void	gus_init_ics2101 __P((struct gus_softc *));

STATIC void	gus_set_chan_addrs __P((struct gus_softc *));
STATIC void	gusreset __P((struct gus_softc *, int));
STATIC void	gus_set_voices __P((struct gus_softc *, int));
STATIC void	gus_set_volume __P((struct gus_softc *, int, int));
STATIC void	gus_set_samprate __P((struct gus_softc *, int, int));
STATIC void	gus_set_recrate __P((struct gus_softc *, u_long));
STATIC void	gus_start_voice __P((struct gus_softc *, int, int));
STATIC void	gus_stop_voice __P((struct gus_softc *, int, int));
STATIC void	gus_set_endaddr __P((struct gus_softc *, int, u_long));
#ifdef GUSPLAYDEBUG
STATIC void	gus_set_curaddr __P((struct gus_softc *, int, u_long));
STATIC u_long	gus_get_curaddr __P((struct gus_softc *, int));
#endif
STATIC int	gus_dmaout_intr __P((struct gus_softc *));
STATIC void	gus_dmaout_dointr __P((struct gus_softc *));
STATIC void	gus_dmaout_timeout __P((void *));
STATIC int	gus_dmain_intr __P((struct gus_softc *));
STATIC int	gus_voice_intr __P((struct gus_softc *));
STATIC void	gus_start_playing __P((struct gus_softc *, int));
STATIC int	gus_continue_playing __P((struct gus_softc *, int));
STATIC u_char guspeek __P((bus_space_tag_t, bus_space_handle_t, u_long));
STATIC u_long convert_to_16bit __P((u_long));
STATIC int	gus_mixer_set_port __P((void *, mixer_ctrl_t *));
STATIC int	gus_mixer_get_port __P((void *, mixer_ctrl_t *));
STATIC int	gusmax_mixer_set_port __P((void *, mixer_ctrl_t *));
STATIC int	gusmax_mixer_get_port __P((void *, mixer_ctrl_t *));
STATIC int	gus_mixer_query_devinfo __P((void *, mixer_devinfo_t *));
STATIC int	gusmax_mixer_query_devinfo __P((void *, mixer_devinfo_t *));
STATIC int	gus_query_encoding __P((void *, struct audio_encoding *));
STATIC int	gus_get_props __P((void *));
STATIC int	gusmax_get_props __P((void *));

STATIC void	gusics_master_mute __P((struct ics2101_softc *, int));
STATIC void	gusics_dac_mute __P((struct ics2101_softc *, int));
STATIC void	gusics_mic_mute __P((struct ics2101_softc *, int));
STATIC void	gusics_linein_mute __P((struct ics2101_softc *, int));
STATIC void	gusics_cd_mute __P((struct ics2101_softc *, int));

void	stereo_dmaintr __P((void *));

/*
 * ISA bus driver routines
 */

#define __BROKEN_INDIRECT_CONFIG
#ifdef __BROKEN_INDIRECT_CONFIG
int	gusprobe __P((struct device *, void *, void *));
#else
int	gusprobe __P((struct device *, struct cfdata *, void *));
#endif
void	gusattach __P((struct device *, struct device *, void *));

struct cfattach gus_ca = {
	sizeof(struct gus_softc), gusprobe, gusattach,
};

a156 1

d161 1
a161 2

static int gus_irq_map[] = {
d165 1
a165 1
static int gus_drq_map[] = {
d173 1
a173 1
static int gus_base_addrs[] = {
d176 1
a176 1
static int gus_addrs = sizeof(gus_base_addrs) / sizeof(gus_base_addrs[0]);
a269 19
#define SELECT_GUS_REG(iot,ioh1,x) bus_space_write_1(iot,ioh1,GUS_REG_SELECT,x)
#define ADDR_HIGH(x) (unsigned int) ((x >> 7L) & 0x1fffL)
#define ADDR_LOW(x) (unsigned int) ((x & 0x7fL) << 9L)

#define GUS_MIN_VOICES 14	/* Minimum possible number of voices */
#define GUS_MAX_VOICES 32	/* Maximum possible number of voices */
#define GUS_VOICE_LEFT 0	/* Voice used for left (and mono) playback */
#define GUS_VOICE_RIGHT 1	/* Voice used for right playback */
#define GUS_MEM_OFFSET 32	/* Offset into GUS memory to begin of buffer */
#define GUS_BUFFER_MULTIPLE 1024	/* Audio buffers are multiples of this */
#define	GUS_MEM_FOR_BUFFERS	131072	/* use this many bytes on-GUS */
#define	GUS_LEFT_RIGHT_OFFSET	(sc->sc_nbufs * sc->sc_chanblocksize + GUS_MEM_OFFSET)

#define GUS_PREC_BYTES (sc->sc_precision >> 3) /* precision to bytes */

/* splgus() must be splaudio() */

#define splgus splaudio

a272 1

a347 1

a353 372
#define FLIP_REV	5		/* This rev has flipped mixer chans */


int
gusprobe(parent, match, aux)
	struct device *parent;
#ifdef __BROKEN_INDIRECT_CONFIG
	void *match;
#else
	struct cfdata *match;
#endif
	void *aux;
{
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;
	int recdrq = ia->ia_drq2;

	/*
	 * Before we do anything else, make sure requested IRQ and DRQ are
	 * valid for this card.
	 */

	/* XXX range check before indexing!! */
	if (ia->ia_irq == IRQUNK || gus_irq_map[ia->ia_irq] == IRQUNK) {
		DPRINTF(("gus: invalid irq %d, card not probed\n", ia->ia_irq));
		return 0;
	}

	if (ia->ia_drq == DRQUNK || gus_drq_map[ia->ia_drq] == DRQUNK) {
		DPRINTF(("gus: invalid drq %d, card not probed\n", ia->ia_drq));
		return 0;
	}

	if (recdrq != DRQUNK) {
		if (recdrq > 7 || gus_drq_map[recdrq] == DRQUNK) {
		   DPRINTF(("gus: invalid second DMA channel (%d), card not probed\n", recdrq));
		   return 0;
	        }
	} else
		recdrq = ia->ia_drq;

	if (iobase == IOBASEUNK) {
		int i;
		for(i = 0; i < gus_addrs; i++)
			if (gus_test_iobase(ia->ia_iot, gus_base_addrs[i])) {
				iobase = gus_base_addrs[i];
				goto done;
			}
		return 0;
	} else if (!gus_test_iobase(ia->ia_iot, iobase))
			return 0;

done:
	if ((ia->ia_drq    != -1 && !isa_drq_isfree(parent, ia->ia_drq)) ||
	    (recdrq != -1 && !isa_drq_isfree(parent, recdrq)))
		return 0;

	ia->ia_iobase = iobase;
	ia->ia_iosize = GUS_NPORT1;
	return 1;
}

/*
 * Test to see if a particular I/O base is valid for the GUS.  Return true
 * if it is.
 */

STATIC int
gus_test_iobase (iot, iobase)
	bus_space_tag_t iot;
	int iobase;
{
	bus_space_handle_t ioh1, ioh2, ioh3, ioh4;
	u_char s1, s2;
	int s, rv = 0;

	/* Map i/o space */
	if (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))
		return 0;
	if (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))
		goto bad1;

	/* XXX Maybe we shouldn't fail on mapping this, but just assume
	 * the card is of revision 0? */
	if (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))
		goto bad2;

	if (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))
		goto bad3;

	/*
	 * Reset GUS to an initial state before we do anything.
	 */

	s = splgus();
	delay(500);

 	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

 	delay(500);

	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUSMASK_MASTER_RESET);

 	delay(500);

	splx(s);

	/*
	 * See if we can write to the board's memory
	 */

 	s1 = guspeek(iot, ioh2, 0L);
 	s2 = guspeek(iot, ioh2, 1L);

 	guspoke(iot, ioh2, 0L, 0xaa);
 	guspoke(iot, ioh2, 1L, 0x55);

 	if (guspeek(iot, ioh2, 0L) != 0xaa)
		goto bad;

	guspoke(iot, ioh2, 0L, s1);
	guspoke(iot, ioh2, 1L, s2);

	rv = 1;

bad:
	bus_space_unmap(iot, ioh4, GUS_NPORT4);
bad3:
	bus_space_unmap(iot, ioh3, GUS_NPORT3);
bad2:
	bus_space_unmap(iot, ioh2, GUS_NPORT2);
bad1:
	bus_space_unmap(iot, ioh1, GUS_NPORT1);
	return rv;
}

/*
 * Setup the GUS for use; called shortly after probe
 */

void
gusattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct gus_softc *sc = (void *) self;
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot;
	bus_space_handle_t ioh1, ioh2, ioh3, ioh4;
 	int		iobase, i;
	unsigned char	c,d,m;

	sc->sc_iot = iot = ia->ia_iot;
	iobase = ia->ia_iobase;

	/* Map i/o space */
	if (bus_space_map(iot, iobase, GUS_NPORT1, 0, &ioh1))
		panic("%s: can't map io port range 1", self->dv_xname);
	sc->sc_ioh1 = ioh1;
	if (bus_space_map(iot, iobase+GUS_IOH2_OFFSET, GUS_NPORT2, 0, &ioh2))
		panic("%s: can't map io port range 2", self->dv_xname);
	sc->sc_ioh2 = ioh2;

	/* XXX Maybe we shouldn't fail on mapping this, but just assume
	 * the card is of revision 0? */
	if (bus_space_map(iot, iobase+GUS_IOH3_OFFSET, GUS_NPORT3, 0, &ioh3))
		panic("%s: can't map io port range 3", self->dv_xname);
	sc->sc_ioh3 = ioh3;

	if (bus_space_map(iot, iobase+GUS_IOH4_OFFSET, GUS_NPORT4, 0, &ioh4))
		panic("%s: can't map io port range 4", self->dv_xname);
	sc->sc_ioh4 = ioh4;

	sc->sc_iobase = iobase;
	sc->sc_irq = ia->ia_irq;
	sc->sc_drq = ia->ia_drq;
	sc->sc_recdrq = ia->ia_drq2;

	/*
	 * Figure out our board rev, and see if we need to initialize the
	 * mixer
	 */

	sc->sc_isa = parent;

 	delay(500);

 	c = bus_space_read_1(iot, ioh3, GUS_BOARD_REV);
	if (c != 0xff)
		sc->sc_revision = c;
	else
		sc->sc_revision = 0;


 	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
 	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, 0x00);

	gusreset(sc, GUS_MAX_VOICES); /* initialize all voices */
	gusreset(sc, GUS_MIN_VOICES); /* then set to just the ones we use */

	/*
	 * Setup the IRQ and DRQ lines in software, using values from
	 * config file
	 */

	m = GUSMASK_LINE_IN|GUSMASK_LINE_OUT;		/* disable all */

	c = ((unsigned char) gus_irq_map[ia->ia_irq]) | GUSMASK_BOTH_RQ;

	if (sc->sc_recdrq == sc->sc_drq)
		d = (unsigned char) (gus_drq_map[sc->sc_drq] |
				GUSMASK_BOTH_RQ);
	else
		d = (unsigned char) (gus_drq_map[sc->sc_drq] |
				gus_drq_map[sc->sc_recdrq] << 3);

	/*
	 * Program the IRQ and DMA channels on the GUS.  Note that we hardwire
	 * the GUS to only use one IRQ channel, but we give the user the
	 * option of using two DMA channels (the other one given by the flags
	 * option in the config file).  Two DMA channels are needed for full-
	 * duplex operation.
	 *
	 * The order of these operations is very magical.
	 */

	disable_intr();		/* XXX needed? */

	bus_space_write_1(iot, ioh1, GUS_REG_CONTROL, GUS_REG_IRQCTL);
	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, m);
	bus_space_write_1(iot, ioh1, GUS_IRQCTL_CONTROL, 0x00);
	bus_space_write_1(iot, ioh1, 0x0f, 0x00);

	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, m);
	bus_space_write_1(iot, ioh1, GUS_DMA_CONTROL, d | 0x80); /* magic reset? */

	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, m | GUSMASK_CONTROL_SEL);
	bus_space_write_1(iot, ioh1, GUS_IRQ_CONTROL, c);

	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, m);
	bus_space_write_1(iot, ioh1, GUS_DMA_CONTROL, d);

	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL, m | GUSMASK_CONTROL_SEL);
	bus_space_write_1(iot, ioh1, GUS_IRQ_CONTROL, c);

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, 0x00);

	/* enable line in, line out.  leave mic disabled. */
	bus_space_write_1(iot, ioh1, GUS_MIX_CONTROL,
	     (m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN));
	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, 0x00);

	enable_intr();

	sc->sc_mixcontrol =
		(m | GUSMASK_LATCHES) & ~(GUSMASK_LINE_OUT|GUSMASK_LINE_IN);

	/* XXX WILL THIS ALWAYS WORK THE WAY THEY'RE OVERLAYED?! */
	sc->sc_codec.sc_isa = sc->sc_dev.dv_parent;

 	if (sc->sc_revision >= 5 && sc->sc_revision <= 9) {
 		sc->sc_flags |= GUS_MIXER_INSTALLED;
 		gus_init_ics2101(sc);
	}
	if (sc->sc_revision < 0xa || !gus_init_cs4231(sc)) {
		/* Not using the CS4231, so create our DMA maps. */
		if (sc->sc_drq != -1) {
			if (isa_dmamap_create(sc->sc_isa, sc->sc_drq,
			    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
				printf("%s: can't create map for drq %d\n",
				       sc->sc_dev.dv_xname, sc->sc_drq);
				return;
			}
		}
		if (sc->sc_recdrq != -1 && sc->sc_recdrq != sc->sc_drq) {
			if (isa_dmamap_create(sc->sc_isa, sc->sc_recdrq,
			    MAX_ISADMA, BUS_DMA_NOWAIT|BUS_DMA_ALLOCNOW)) {
				printf("%s: can't create map for drq %d\n",
				       sc->sc_dev.dv_xname, sc->sc_recdrq);
				return;
			}
		}
	}

 	SELECT_GUS_REG(iot, ioh2, GUSREG_RESET);
 	/*
 	 * Check to see how much memory we have on this card; see if any
 	 * "mirroring" occurs.  We're assuming at least 256K already exists
 	 * on the card; otherwise the initial probe would have failed
 	 */

	guspoke(iot, ioh2, 0L, 0x00);
	for(i = 1; i < 1024; i++) {
		u_long loc;

		/*
		 * See if we've run into mirroring yet
		 */

		if (guspeek(iot, ioh2, 0L) != 0)
			break;

		loc = i << 10;

		guspoke(iot, ioh2, loc, 0xaa);
		if (guspeek(iot, ioh2, loc) != 0xaa)
			break;
	}

	sc->sc_dsize = i;
	sprintf(gus_device.version, "3.%d", sc->sc_revision);

	printf("\n <Gravis UltraSound version 3.%d, %dKB DRAM, ",
	       sc->sc_revision, sc->sc_dsize);
	if (HAS_MIXER(sc))
		printf("ICS2101 mixer, ");
	if (HAS_CODEC(sc))
		printf("%s codec/mixer, ", sc->sc_codec.chip_name);
	if (sc->sc_recdrq == sc->sc_drq) {
		printf("half-duplex");
	} else {
		printf("full-duplex, record drq %d", sc->sc_recdrq);
	}

	printf(">\n");

	/*
	 * Setup a default interrupt handler
	 */

	/* XXX we shouldn't have to use splgus == splclock, nor should
	 * we use IPL_CLOCK.
	 */
	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_AUDIO, gusintr, sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);

	/*
	 * Set some default values
	 * XXX others start with 8kHz mono mulaw
	 */

	sc->sc_irate = sc->sc_orate = 44100;
	sc->sc_encoding = AUDIO_ENCODING_SLINEAR_LE;
	sc->sc_precision = 16;
	sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;
	sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;
	sc->sc_channels = 1;
	sc->sc_ogain = 340;
	gus_commit_settings(sc);

	/*
	 * We always put the left channel full left & right channel
	 * full right.
	 * For mono playback, we set up both voices playing the same buffer.
	 */
	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) GUS_VOICE_LEFT);
	SELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);

	bus_space_write_1(iot, ioh2, GUS_VOICE_SELECT, (unsigned char) GUS_VOICE_RIGHT);
	SELECT_GUS_REG(iot, ioh2, GUSREG_PAN_POS);
	bus_space_write_1(iot, ioh2, GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);

	/*
	 * Attach to the generic audio layer
	 */

	audio_attach_mi(&gus_hw_if,
	    HAS_CODEC(sc) ? (void *)&sc->sc_codec : (void *)sc, &sc->sc_dev);
}
d407 1
a407 1
STATIC void
d725 1
a725 1
STATIC void
d758 1
a758 1
STATIC int
d779 1
a779 1
STATIC void
d933 1
a933 1
STATIC int
d1082 1
a1082 1
STATIC void
d1162 1
a1162 1
STATIC int
d1263 1
a1263 1
STATIC void
d1338 1
a1338 1
STATIC void
d1435 1
a1435 1
STATIC void
d1478 1
a1478 1
STATIC void
d1652 1
a1652 1
STATIC inline void gus_set_voices(sc, voices)
d1712 1
a1712 1
STATIC void
d1750 1
a1750 1
STATIC void
d1789 1
a1789 1
STATIC void
d1846 1
a1846 1
STATIC int
d1870 1
a1870 1
STATIC int
d1898 1
a1898 1
STATIC void
d1923 1
a1923 1
STATIC void
d1949 1
a1949 1
STATIC u_long
d1979 1
a1979 1
STATIC u_long
d1997 1
a1997 1
STATIC void
d2025 1
a2025 1
STATIC unsigned char
d2052 1
a2052 1
STATIC void
d2182 1
a2182 1
STATIC int
d2333 1
a2333 1
STATIC int
d2445 1
a2445 1
static ad1848_devmap_t gusmapping[] = {
d2461 1
a2461 1
static int nummap = sizeof(gusmapping) / sizeof(gusmapping[0]);
d2463 1
a2463 1
STATIC int
d2504 1
a2504 1
STATIC int
d2629 1
a2629 1
STATIC void
d2638 1
a2638 1
STATIC void
d2647 1
a2647 1
STATIC void
d2656 1
a2656 1
STATIC void
d2665 1
a2665 1
STATIC void
d2674 1
a2674 1
STATIC int
d2715 1
a2715 1
STATIC int
d2875 1
a2875 1
STATIC int
d2884 1
a2884 1
STATIC int
d2892 1
a2892 1
STATIC int
d3094 1
a3094 1
STATIC int
d3240 1
a3240 1
STATIC int
d3307 1
a3307 1
STATIC void
d3387 280
a3666 1
#endif /* NGUS */
@


1.19
log
@Midi & sequencer support from NetBSD, mostly by Lennart Augustsson
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.18 1998/11/03 21:14:59 downsj Exp $	*/
a115 1
#include <machine/pio.h>
@


1.18
log
@Update audio_hw_if.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.17 1998/08/20 08:37:47 provos Exp $	*/
d1042 2
a1043 1
	audio_attach_mi(&gus_hw_if, 0, HAS_CODEC(sc) ? (void *)&sc->sc_codec : (void *)sc, &sc->sc_dev);
@


1.17
log
@mmap support for gus, dillema@@acm.org
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.16 1998/05/13 10:25:13 provos Exp $	*/
d623 3
@


1.16
log
@don't printf in probe routines.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.15 1998/05/08 18:37:21 csapuntz Exp $	*/
d618 4
a621 4
	NULL,
	NULL,
	NULL,
        NULL,
d653 4
a656 4
	NULL,
	NULL,
	NULL,
	NULL,
d3567 2
a3568 1
	return sc->sc_recdrq == sc->sc_drq ? 0 : AUDIO_PROP_FULLDUPLEX;
@


1.15
log
@

Cleaned up AD1848 driver and added driver for Yamaha OPL3-SA3 to tree.
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.14 1998/04/26 21:02:41 provos Exp $	*/
d694 1
a694 1
		printf("gus: invalid irq %d, card not probed\n", ia->ia_irq);
d699 1
a699 1
		printf("gus: invalid drq %d, card not probed\n", ia->ia_drq);
d705 1
a705 1
		   printf("gus: invalid second DMA channel (%d), card not probed\n", recdrq);
@


1.14
log
@update audio from NetBSD, mostly by Lennart Augustsson <augustss@@cs.chalmers.se>
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.13 1998/01/18 18:58:37 niklas Exp $	*/
a430 3
STATIC __inline int gus_to_vol __P((mixer_ctrl_t *, struct ad1848_volume *));
STATIC __inline int gus_from_vol __P((mixer_ctrl_t *, struct ad1848_volume *));

d1067 2
a1068 2
		sc->sc_codec.aux1_mute = 0;
		ad1848_mute_aux1(&sc->sc_codec, 0); /* turn on DAC output */
d1070 2
a1071 2
			sc->sc_codec.mono_mute = 0;
			cs4231_mute_mono(&sc->sc_codec, 0);
d1299 2
a1300 2
	ac->aux1_mute = 1;
	ad1848_mute_aux1(ac, 1);	/* turn off DAC output */
a3130 16
STATIC __inline int
gus_to_vol(cp, vol)
	mixer_ctrl_t *cp;
	struct ad1848_volume *vol;
{
	if (cp->un.value.num_channels == 1) {
		vol->left = vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
		return(1);
	}
	else if (cp->un.value.num_channels == 2) {
		vol->left  = cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT];
		vol->right = cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT];
		return(1);
	}
	return(0);
}
d3132 17
a3148 16
STATIC __inline int
gus_from_vol(cp, vol)
	mixer_ctrl_t *cp;
	struct ad1848_volume *vol;
{
	if (cp->un.value.num_channels == 1) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] = vol->left;
		return(1);
	}
	else if (cp->un.value.num_channels == 2) {
		cp->un.value.level[AUDIO_MIXER_LEVEL_LEFT] = vol->left;
		cp->un.value.level[AUDIO_MIXER_LEVEL_RIGHT] = vol->right;
		return(1);
	}
	return(0);
}
d3158 1
a3158 1
	int error = EINVAL;
d3160 4
a3163 1
	DPRINTF(("gusmax_mixer_get_port: port=%d\n", cp->dev));
a3165 61
#if 0 /* use mono level instead */
	case GUSMAX_MIC_IN_LVL:	/* Microphone */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = ad1848_get_mic_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;
#endif

	case GUSMAX_DAC_LVL:		/* dac out */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = ad1848_get_aux1_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_LINE_IN_LVL:	/* line in */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = cs4231_get_linein_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_MONO_LVL:	/* mono */
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			error = cs4231_get_mono_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_CD_LVL:	/* CD */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = ad1848_get_aux2_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_MONITOR_LVL:	/* monitor level */
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			error = ad1848_get_mon_gain(ac, &vol);
			if (!error)
				cp->un.value.level[AUDIO_MIXER_LEVEL_MONO] =
					vol.left;
		}
		break;

	case GUSMAX_OUT_LVL:	/* output level */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = ad1848_get_out_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

d3173 1
a3173 37
			gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_LINE_IN_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ac->line_mute;
			error = 0;
		}
		break;


	case GUSMAX_DAC_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ac->aux1_mute;
			error = 0;
		}
		break;

	case GUSMAX_CD_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ac->aux2_mute;
			error = 0;
		}
		break;

	case GUSMAX_MONO_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ac->mono_mute;
			error = 0;
		}
		break;

	case GUSMAX_MONITOR_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ac->mon_mute;
			error = 0;
a3182 16

	case GUSMAX_REC_LVL:		/* record level */
		if (cp->type == AUDIO_MIXER_VALUE) {
			error = ad1848_get_rec_gain(ac, &vol);
			if (!error)
				gus_from_vol(cp, &vol);
		}
		break;

	case GUSMAX_RECORD_SOURCE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			cp->un.ord = ad1848_get_rec_port(ac);
			error = 0;
		}
		break;

d3259 1
a3259 1
			if (gus_from_vol(cp, &vol))
d3268 1
a3268 1
			if (gus_from_vol(cp, &vol))
d3277 1
a3277 1
			if (gus_from_vol(cp, &vol))
d3287 1
a3287 1
			if (gus_from_vol(cp, &vol))
d3296 1
a3296 1
			if (gus_from_vol(cp, &vol))
d3369 1
a3369 1
	int error = EINVAL;
d3371 3
a3376 55
#if 0
	case GUSMAX_MIC_IN_LVL:	/* Microphone */
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			/* XXX enable/disable pre-MUX fixed gain */
			if (gus_to_vol(cp, &vol))
				error = ad1848_set_mic_gain(ac, &vol);
		}
		break;
#endif
	
	case GUSMAX_DAC_LVL:		/* dac out */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (gus_to_vol(cp, &vol))
				error = ad1848_set_aux1_gain(ac, &vol);
		}
		break;

	case GUSMAX_LINE_IN_LVL:	/* line in */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (gus_to_vol(cp, &vol))
				error = cs4231_set_linein_gain(ac, &vol);
		}
		break;

	case GUSMAX_MONO_LVL:	/* mic/mono in */
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			if (gus_to_vol(cp, &vol))
				error = cs4231_set_mono_gain(ac, &vol);
		}
		break;

	case GUSMAX_CD_LVL:	/* CD: AUX2 */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (gus_to_vol(cp, &vol))
				error = ad1848_set_aux2_gain(ac, &vol);
		}
		break;

	case GUSMAX_MONITOR_LVL:
		if (cp->type == AUDIO_MIXER_VALUE &&
		    cp->un.value.num_channels == 1) {
			vol.left  = cp->un.value.level[AUDIO_MIXER_LEVEL_MONO];
			error = ad1848_set_mon_gain(ac, &vol);
		}
		break;

	case GUSMAX_OUT_LVL:	/* output volume */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (gus_to_vol(cp, &vol))
				error = ad1848_set_out_gain(ac, &vol);
		}
		break;

d3380 1
a3380 1
			if (gus_to_vol(cp, &vol)) {
a3387 47
	case GUSMAX_LINE_IN_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			ac->line_mute = cp->un.ord ? 1 : 0;
			DPRINTF(("line mute %d\n", cp->un.ord));
			cs4231_mute_line(ac, ac->line_mute);
			gus_linein_ctl(sc, ac->line_mute ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	case GUSMAX_DAC_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			ac->aux1_mute = cp->un.ord ? 1 : 0;
			DPRINTF(("dac mute %d\n", cp->un.ord));
			ad1848_mute_aux1(ac, ac->aux1_mute);
			error = 0;
		}
		break;

	case GUSMAX_CD_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			ac->aux2_mute = cp->un.ord ? 1 : 0;
			DPRINTF(("cd mute %d\n", cp->un.ord));
			ad1848_mute_aux2(ac, ac->aux2_mute);
			error = 0;
		}
		break;

	case GUSMAX_MONO_MUTE:	/* Microphone */
		if (cp->type == AUDIO_MIXER_ENUM) {
			ac->mono_mute = cp->un.ord ? 1 : 0;
			DPRINTF(("mono mute %d\n", cp->un.ord));
			cs4231_mute_mono(ac, ac->mono_mute);
			gus_mic_ctl(sc, ac->mono_mute ? SPKR_OFF : SPKR_ON);
			error = 0;
		}
		break;

	case GUSMAX_MONITOR_MUTE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			ac->mon_mute = cp->un.ord ? 1 : 0;
			DPRINTF(("mono mute %d\n", cp->un.ord));
			cs4231_mute_monitor(ac, ac->mon_mute);
			error = 0;
		}
		break;

a3394 13
	case GUSMAX_REC_LVL:		/* record level */
		if (cp->type == AUDIO_MIXER_VALUE) {
			if (gus_to_vol(cp, &vol))
				error = ad1848_set_rec_gain(ac, &vol);
		}
		break;
	
	case GUSMAX_RECORD_SOURCE:
		if (cp->type == AUDIO_MIXER_ENUM) {
			error = ad1848_set_rec_port(ac, cp->un.ord);
		}
		break;

d3468 1
a3468 1
			if (gus_to_vol(cp, &vol)) {
d3484 1
a3484 1
			if (gus_to_vol(cp, &vol)) {
d3500 1
a3500 1
			if (gus_to_vol(cp, &vol)) {
d3517 1
a3517 1
			if (gus_to_vol(cp, &vol)) {
d3533 1
a3533 1
			if (gus_to_vol(cp, &vol)) {
@


1.13
log
@move to current OpenBSD isadma API
@
text
@d1 2
a2 2
/*	$OpenBSD: gus.c,v 1.12 1997/07/10 23:06:34 provos Exp $	*/
/*	$NetBSD: gus.c,v 1.16 1996/05/12 23:52:08 mycroft Exp $	*/
d30 2
a31 2
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
d115 1
d121 1
d182 1
a182 1
	struct isadev sc_id;		/* ISA device */
d184 5
d300 1
a300 2
#define GUSMAX_MIX_IN			0 /* input to MUX from mixer output */
#define GUSMAX_MONO_LVL			1 /* mic input to MUX;
d302 12
a313 12
#define GUSMAX_DAC_LVL			2 /* input to MUX; also mixer input */
#define GUSMAX_LINE_IN_LVL		3 /* input to MUX; also mixer input */
#define GUSMAX_CD_LVL			4 /* mixer input only */
#define GUSMAX_MONITOR_LVL		5 /* digital mix (?) */
#define GUSMAX_OUT_LVL			6 /* output level. (?) */
#define GUSMAX_SPEAKER_LVL		7 /* pseudo-device for mute */
#define GUSMAX_LINE_IN_MUTE		8 /* pre-mixer */
#define GUSMAX_DAC_MUTE			9 /* pre-mixer */
#define GUSMAX_CD_MUTE			10 /* pre-mixer */
#define GUSMAX_MONO_MUTE		11 /* pre-mixer--microphone/mono */
#define GUSMAX_MONITOR_MUTE		12 /* post-mixer level/mute */
#define GUSMAX_SPEAKER_MUTE		13 /* speaker mute */
d315 1
a315 1
#define GUSMAX_REC_LVL			14 /* post-MUX gain */
d317 1
a317 1
#define GUSMAX_RECORD_SOURCE		15
d320 4
a323 4
#define GUSMAX_INPUT_CLASS		16
#define GUSMAX_RECORD_CLASS		17
#define GUSMAX_MONITOR_CLASS		18
#define GUSMAX_OUTPUT_CLASS		19
d327 2
a328 3
extern void Dprintf __P((const char *, ...));
#define DPRINTF(x)	if (gusdebug) Dprintf x
#define DMAPRINTF(x)	if (gusdmadebug) Dprintf x
d356 1
a356 1
int	gusopen __P((dev_t, int));
d364 2
a365 18
int 	gus_set_in_sr __P((void *, u_long));
u_long 	gus_get_in_sr __P((void *));
int 	gusmax_set_in_sr __P((void *, u_long));
u_long 	gusmax_get_in_sr __P((void *));
int 	gus_set_out_sr __P((void *, u_long));
u_long 	gus_get_out_sr __P((void *));
int 	gusmax_set_out_sr __P((void *, u_long));
u_long 	gusmax_get_out_sr __P((void *));
int	gus_set_format __P((void *, u_int, u_int));
int	gus_get_encoding __P((void *));
int	gus_get_precision __P((void *));
int	gusmax_set_format __P((void *, u_int, u_int));
int	gusmax_get_encoding __P((void *));
int	gusmax_get_precision __P((void *));
int	gus_set_channels __P((void *, int));
int	gus_get_channels __P((void *));
int	gusmax_set_channels __P((void *, int));
int	gusmax_get_channels __P((void *));
a366 4
int	gus_set_out_port __P((void *, int));
int	gus_get_out_port __P((void *));
int	gus_set_in_port __P((void *, int));
int	gus_get_in_port __P((void *));
a371 2
int	gus_cont_out_dma __P((void *));
int	gus_cont_in_dma __P((void *));
d373 1
a379 2
int	gusmax_cont_out_dma __P((void *));
int	gusmax_cont_in_dma __P((void *));
a380 4
int	gusmax_set_out_port __P((void *, int));
int	gusmax_get_out_port __P((void *));
int	gusmax_set_in_port __P((void *, int));
int	gusmax_get_in_port __P((void *));
a383 2
STATIC void	gus_expand __P((void *, int, u_char *, int));
STATIC void	gusmax_expand __P((void *, int, u_char *, int));
d387 2
a388 2
STATIC int	gus_test_iobase __P((int));
STATIC void	guspoke __P((int, long, u_char));
d390 1
a390 1
STATIC void	gus_init_cs4231 __P((struct gus_softc *));
d413 1
a413 1
STATIC u_char guspeek __P((int, u_long));
a414 1
STATIC int	gus_setfd __P((void *, int));
d422 2
d440 2
d443 3
d571 1
a571 2
#define SELECT_GUS_REG(port,x) outb(port+GUS_REG_SELECT,x)
#define WHICH_GUS_REG(port) inb(port+GUS_REG_SELECT)
a597 4
	gus_set_in_sr,
	gus_get_in_sr,
	gus_set_out_sr,
	gus_get_out_sr,
a599 3
	gus_set_format,
	gus_get_encoding,
	gus_get_precision,
d601 1
a601 2
	gus_set_channels,
	gus_get_channels,
a604 5
	gus_set_out_port,
	gus_get_out_port,
	gus_set_in_port,
	gus_get_in_port,

d607 2
a608 2
	gus_expand,
	mulaw_compress,
a613 3
	gus_cont_out_dma,
	gus_cont_in_dma,

d617 1
a617 1
	gus_setfd,
d621 5
a625 2
	1,				/* full-duplex */
	0,
d628 34
d679 6
a684 1
	void *match, *aux;
d686 3
a688 5
	register struct gus_softc *sc = match;
	register struct isa_attach_args *ia = aux;
	struct cfdata *cf = sc->sc_dev.dv_cfdata;
	register int iobase = ia->ia_iobase;
	int recdrq = cf->cf_flags;
d695 2
a696 1
	if (gus_irq_map[ia->ia_irq] == IRQUNK) {
d698 1
a698 1
		return(0);
d701 1
a701 1
	if (gus_drq_map[ia->ia_drq] == DRQUNK) {
d703 1
a703 1
		return(0);
d706 1
a706 1
	if (recdrq != 0x00) {
d708 2
a709 2
		   printf("gus: invalid flag given for second DMA channel (0x%x), card not probed\n", recdrq);
		   return(0);
d717 1
a717 1
			if (gus_test_iobase(gus_base_addrs[i])) {
d722 1
a722 1
	} else if (! gus_test_iobase(iobase))
d726 3
a728 4
	sc->sc_iobase = iobase;
	sc->sc_irq = ia->ia_irq;
	sc->sc_drq = ia->ia_drq;
	sc->sc_recdrq = recdrq;
d730 3
a732 3
	ia->ia_iobase = sc->sc_iobase;
	ia->ia_iosize = 16;		/* XXX */
	return(1);
d741 3
a743 1
gus_test_iobase (int iobase)
d745 1
a745 1
	int i = splgus();
d747 15
d767 1
d770 2
a771 2
 	SELECT_GUS_REG(iobase, GUSREG_RESET);
 	outb(iobase+GUS_DATA_HIGH, 0x00);
d775 2
a776 2
	SELECT_GUS_REG(iobase, GUSREG_RESET);
 	outb(iobase+GUS_DATA_HIGH, GUSMASK_MASTER_RESET);
d780 1
a780 1
	splx(i);
d786 2
a787 2
 	s1 = guspeek(iobase, 0L);
 	s2 = guspeek(iobase, 1L);
d789 2
a790 2
 	guspoke(iobase, 0L, 0xaa);
 	guspoke(iobase, 1L, 0x55);
d792 2
a793 6
 	if ((i=(int)guspeek(iobase, 0L)) != 0xaa) {
		return(0);
	}

	guspoke(iobase, 0L, s1);
	guspoke(iobase, 1L, s2);
d795 14
a808 1
	return 1;
d820 32
a851 5
	register struct gus_softc *sc = (void *) self;
	register struct isa_attach_args *ia = aux;
	register int port = ia->ia_iobase;
	int		i;
	register unsigned char	c,d,m;
d858 2
d862 1
a862 1
 	c = inb(port+GUS_BOARD_REV);
d869 2
a870 2
 	SELECT_GUS_REG(port, GUSREG_RESET);
 	outb(port+GUS_DATA_HIGH, 0x00);
d901 1
a901 1
	disable_intr();
d903 4
a906 4
	outb(port+GUS_REG_CONTROL, GUS_REG_IRQCTL);
	outb(port+GUS_MIX_CONTROL, m);
	outb(port+GUS_IRQCTL_CONTROL, 0x00);
	outb(port+0x0f, 0x00);
d908 2
a909 2
	outb(port+GUS_MIX_CONTROL, m);
	outb(port+GUS_DMA_CONTROL, d | 0x80); /* magic reset? */
d911 2
a912 2
	outb(port+GUS_MIX_CONTROL, m | GUSMASK_CONTROL_SEL);
	outb(port+GUS_IRQ_CONTROL, c);
d914 2
a915 2
	outb(port+GUS_MIX_CONTROL, m);
	outb(port+GUS_DMA_CONTROL, d);
d917 2
a918 2
	outb(port+GUS_MIX_CONTROL, m | GUSMASK_CONTROL_SEL);
	outb(port+GUS_IRQ_CONTROL, c);
d920 1
a920 1
	outb(port+GUS_VOICE_SELECT, 0x00);
d923 1
a923 1
	outb(port+GUS_MIX_CONTROL,
d925 1
a925 1
	outb(port+GUS_VOICE_SELECT, 0x00);
d932 2
d939 18
a956 2
	if (sc->sc_revision >= 0xa) {
		gus_init_cs4231(sc);
d959 1
a959 1
 	SELECT_GUS_REG(port, GUSREG_RESET);
d966 1
a966 1
	guspoke(port, 0L, 0x00);
d974 1
a974 1
		if (guspeek(port, 0L) != 0)
d979 2
a980 2
		guspoke(port, loc, 0xaa);
		if (guspeek(port, loc) != 0xaa)
a994 1
		gus_hw_if.full_duplex = 0;
a996 1
		gus_hw_if.full_duplex = 1;
d1013 1
d1017 1
a1017 1
	sc->sc_encoding = AUDIO_ENCODING_LINEAR;
d1030 7
a1036 7
	outb(sc->sc_iobase+GUS_VOICE_SELECT, (unsigned char) GUS_VOICE_LEFT);
	SELECT_GUS_REG(sc->sc_iobase, GUSREG_PAN_POS);
	outb(sc->sc_iobase+GUS_DATA_HIGH, GUS_PAN_FULL_LEFT);

	outb(sc->sc_iobase+GUS_VOICE_SELECT, (unsigned char) GUS_VOICE_RIGHT);
	SELECT_GUS_REG(sc->sc_iobase, GUSREG_PAN_POS);
	outb(sc->sc_iobase+GUS_DATA_HIGH, GUS_PAN_FULL_RIGHT);
d1042 1
a1042 2
	if (audio_hardware_attach(&gus_hw_if, HAS_CODEC(sc) ? (void *)&sc->sc_codec : (void *)sc) != 0)
		printf("gus: could not attach to audio pseudo-device driver\n");
d1046 2
a1047 2
gusopen(dev, flags)
	dev_t dev;
d1050 1
a1050 2
	int unit = AUDIOUNIT(dev);
	struct gus_softc *sc;
a1053 6
	if (unit >= gus_cd.cd_ndevs)
		return ENXIO;
	sc = gus_cd.cd_devs[unit];
	if (!sc)
		return ENXIO;

d1069 1
a1069 1
		ad1848_open(&sc->sc_codec, dev, flags);
d1088 4
a1091 18
STATIC void
gusmax_expand(hdl, encoding, buf, count)
	void *hdl;
	int encoding;
	u_char *buf;
	int count;
{
	register struct ad1848_softc *ac = hdl;

	gus_expand(ac->parent, encoding, buf, count);
}

STATIC void
gus_expand(hdl, encoding, buf, count)
	void *hdl;
	int encoding;
	u_char *buf;
	int count;
d1093 2
a1094 8
	struct gus_softc *sc = hdl;

	mulaw_expand(NULL, encoding, buf, count);
	/*
	 * If we need stereo deinterleaving, do it now.
	 */
	if (sc->sc_channels == 2)
		gus_deinterleave(sc, (void *)buf, count);
d1099 1
a1099 1
	register struct gus_softc *sc;
d1105 8
a1112 1
	register int i;
d1118 2
a1119 2
		register u_short *dei = sc->sc_deintr_buf;
		register u_short *sbuf = buf;
d1139 2
a1140 2
		register u_char *dei = sc->sc_deintr_buf;
		register u_char *sbuf = buf;
d1161 1
a1161 1
	register struct ad1848_softc *ac = addr;
d1224 1
a1224 1
	DMAPRINTF(("gus_dma_output %d @@ %x\n", size, buf));
a1234 1
	/* pcm16 is signed, mulaw & pcm8 are unsigned */
d1236 3
a1238 1
	    sc->sc_encoding == AUDIO_ENCODING_PCM8)
d1253 3
d1258 1
a1258 1
		boarddma = size * sc->sc_dmabuf + GUS_MEM_OFFSET;
d1299 2
a1300 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d1318 1
a1318 1
        DPRINTF(("gus_close: sc=0x%x\n", sc));
d1355 4
a1358 1
	register struct gus_softc *sc = arg;
d1360 1
a1360 1
	register int port = sc->sc_iobase;
d1369 1
a1369 1
	if ((intr = inb(port+GUS_IRQ_STATUS)) & GUSMASK_IRQ_DMATC) {
d1376 2
a1377 2
		    SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
		    intr = inb(port+GUS_DATA_HIGH);
d1417 1
a1417 1
     void *arg;
d1419 4
a1422 3
    register struct gus_softc *sc = arg;
    register int port = sc->sc_iobase;
    int s;
d1424 4
a1427 8
    printf("%s: dmaout timeout\n", sc->sc_dev.dv_xname);
    /*
     * Stop any DMA.
     */

    s = splgus();
    SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
    outb(sc->sc_iobase+GUS_DATA_HIGH, 0);
d1429 4
d1434 2
a1435 1
    isadma_abort(sc->sc_drq);		/* XXX we will dmadone below? */
d1437 3
a1439 3

    gus_dmaout_dointr(sc);
    splx(s);
d1452 2
a1453 1
	register int port = sc->sc_iobase;
d1460 2
a1461 2
	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
 	if (inb(port+GUS_DATA_HIGH) & GUSMASK_DMA_IRQPEND) {
d1473 2
a1474 1
	register int port = sc->sc_iobase;
d1477 1
a1477 1
	isadma_done(sc->sc_drq);
d1479 1
a1479 1
	DMAPRINTF(("gus_dmaout_dointr %d @@ %x\n", sc->sc_dmaoutcnt,
d1490 1
a1490 1
	  register int i;
d1492 4
a1495 1
	  case AUDIO_ENCODING_PCM16:
d1498 1
a1498 1
	      guspoke(port, sc->sc_gusaddr -
d1502 7
a1508 1
	  case AUDIO_ENCODING_PCM8:
d1510 1
d1512 1
a1512 1
	    guspoke(port, sc->sc_gusaddr -
d1514 1
a1514 1
		    guspeek(port,
d1590 5
a1594 5
		outb(port+GUS_VOICE_SELECT, GUS_VOICE_LEFT);
		SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
		outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);
		SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
		outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);
d1627 2
a1628 1
	register int port = sc->sc_iobase;
d1639 2
a1640 2
		SELECT_GUS_REG(port, GUSREG_IRQ_STATUS);
		intr = inb(port+GUS_DATA_HIGH);
d1669 2
a1670 2
		    SELECT_GUS_REG(port, GUSREG_VOICE_CNTL+0x80);
		    status = inb(port+GUS_DATA_HIGH);
d1774 2
a1775 2
struct gus_softc *sc;
int bufno;
d1777 5
a1781 4
    register int port = sc->sc_iobase;
    /*
     * Start the voices playing, with buffer BUFNO.
     */
d1783 3
a1785 3
    /*
     * Loop or roll if we have buffers ready.
     */
d1787 3
a1789 7
    if (sc->sc_bufcnt == 1) {
	sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~(GUSMASK_LOOP_ENABLE);
	sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);
    } else {
	if (bufno == sc->sc_nbufs - 1) {
	    sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_LOOP_ENABLE;
	    sc->sc_voc[GUS_VOICE_LEFT].volcntl &= ~(GUSMASK_VOICE_ROLL);
d1791 7
a1797 2
	    sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_LOOP_ENABLE;
	    sc->sc_voc[GUS_VOICE_LEFT].volcntl |= GUSMASK_VOICE_ROLL;
a1798 1
    }
d1800 1
a1800 1
    outb(port+GUS_VOICE_SELECT, GUS_VOICE_LEFT);
d1802 2
a1803 2
    SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].voccntl);
d1805 2
a1806 2
    SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_LEFT].volcntl);
d1808 14
a1821 14
    sc->sc_voc[GUS_VOICE_LEFT].current_addr =
	GUS_MEM_OFFSET + sc->sc_chanblocksize * bufno;
    sc->sc_voc[GUS_VOICE_LEFT].end_addr =
	sc->sc_voc[GUS_VOICE_LEFT].current_addr + sc->sc_chanblocksize - 1;
    sc->sc_voc[GUS_VOICE_RIGHT].current_addr =
	sc->sc_voc[GUS_VOICE_LEFT].current_addr + 
	(gus_dostereo && sc->sc_channels == 2 ? GUS_LEFT_RIGHT_OFFSET : 0);
    /*
     * set up right channel to just loop forever, no interrupts,
     * starting at the buffer we just filled.  We'll feed it data
     * at the same time as left channel.
     */
    sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_LOOP_ENABLE;
    sc->sc_voc[GUS_VOICE_RIGHT].volcntl &= ~(GUSMASK_VOICE_ROLL);
d1824 3
a1826 3
    if (gusstats) {
      microtime(&playstats[playcntr].tv);
      playstats[playcntr].curaddr = sc->sc_voc[GUS_VOICE_LEFT].current_addr;
d1828 9
a1836 9
      playstats[playcntr].voccntl = sc->sc_voc[GUS_VOICE_LEFT].voccntl;
      playstats[playcntr].volcntl = sc->sc_voc[GUS_VOICE_LEFT].volcntl;
      playstats[playcntr].endaddr = sc->sc_voc[GUS_VOICE_LEFT].end_addr;
      playstats[playcntr].playbuf = bufno;
      playstats[playcntr].dmabuf = sc->sc_dmabuf;
      playstats[playcntr].bufcnt = sc->sc_bufcnt;
      playstats[playcntr].vaction = 5;
      playcntr = ++playcntr % NDMARECS;
    }
d1839 11
a1849 11
    outb(port+GUS_VOICE_SELECT, GUS_VOICE_RIGHT);
    SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].voccntl);
    SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[GUS_VOICE_RIGHT].volcntl);

    gus_start_voice(sc, GUS_VOICE_RIGHT, 0);
    gus_start_voice(sc, GUS_VOICE_LEFT, 1);
    if (sc->sc_playbuf == -1)
	/* mark start of playing */
	sc->sc_playbuf = bufno;
d1854 2
a1855 2
register struct gus_softc *sc;
int voice;
d1857 2
a1858 1
    register int port = sc->sc_iobase;
d1860 3
a1862 3
    /*
     * stop this voice from interrupting while we work.
     */
d1864 2
a1865 2
    SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl & ~(GUSMASK_VOICE_IRQ));
d1867 5
a1871 5
    /* 
     * update playbuf to point to the buffer the hardware just started
     * playing
     */
    sc->sc_playbuf = ++sc->sc_playbuf % sc->sc_nbufs;
d1873 10
a1882 10
    /*
     * account for buffer just finished
     */
    if (--sc->sc_bufcnt == 0) {
	DPRINTF(("gus: bufcnt 0 on continuing voice?\n"));
    }
    if (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED)) {
	printf("%s: continue into active dmabuf?\n", sc->sc_dev.dv_xname);
	return 1;
    }
d1884 4
a1887 4
    /*
     * Select the end of the buffer based on the currently active
     * buffer, [plus extra contiguous buffers (if ready)].
     */
d1889 8
a1896 8
    /* 
     * set endpoint at end of buffer we just started playing.
     *
     * The total gets -1 because end addrs are one less than you might
     * think (the end_addr is the address of the last sample to play)
     */
    gus_set_endaddr(sc, voice, GUS_MEM_OFFSET +
		    sc->sc_chanblocksize * (sc->sc_playbuf + 1) - 1);
d1898 9
a1906 18
    if (sc->sc_bufcnt < 2) {
	/*
	 * Clear out the loop and roll flags, and rotate the currently
	 * playing buffer.  That way, if we don't manage to get more
	 * data before this buffer finishes, we'll just stop.
	 */
	sc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;
	sc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;
	playstats[playcntr].vaction = 0;
    } else {
	/*
	 * We have some buffers to play.  set LOOP if we're on the
	 * last buffer in the ring, otherwise set ROLL.
	 */
	if (sc->sc_playbuf == sc->sc_nbufs - 1) {
	    sc->sc_voc[voice].voccntl |= GUSMASK_LOOP_ENABLE;
	    sc->sc_voc[voice].volcntl &= ~GUSMASK_VOICE_ROLL;
	    playstats[playcntr].vaction = 1;
d1908 13
a1920 3
	    sc->sc_voc[voice].voccntl &= ~GUSMASK_LOOP_ENABLE;
	    sc->sc_voc[voice].volcntl |= GUSMASK_VOICE_ROLL;
	    playstats[playcntr].vaction = 2;
a1921 1
    }
d1923 3
a1925 3
    if (gusstats) {
      microtime(&playstats[playcntr].tv);
      playstats[playcntr].curaddr = gus_get_curaddr(sc, voice);
d1927 8
a1934 8
      playstats[playcntr].voccntl = sc->sc_voc[voice].voccntl;
      playstats[playcntr].volcntl = sc->sc_voc[voice].volcntl;
      playstats[playcntr].endaddr = sc->sc_voc[voice].end_addr;
      playstats[playcntr].playbuf = sc->sc_playbuf;
      playstats[playcntr].dmabuf = sc->sc_dmabuf;
      playstats[playcntr].bufcnt = sc->sc_bufcnt;
      playcntr = ++playcntr % NDMARECS;
    }
d1937 4
a1940 4
    /*
     * (re-)set voice parameters.  This will reenable interrupts from this
     * voice.
     */
d1942 5
a1946 5
    SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
    SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
    outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].volcntl);
    return 0;
d1960 3
a1962 2
	register unsigned char c = (unsigned char) flags;
	register int port = sc->sc_iobase;
d1988 2
a1989 2
 	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	outb(port+GUS_DATA_HIGH, 0);
d1997 2
a1998 1
	isadma_start(buffaddr, length, sc->sc_drq, DMAMODE_WRITE);
d2006 2
a2007 2
 	SELECT_GUS_REG(port, GUSREG_DMA_START);
 	outw(port+GUS_DATA_LOW, (int) (gusaddr >> 4));
d2013 2
a2014 2
 	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	outb(port+GUS_DATA_HIGH, c);
d2034 2
a2035 1
	register int port = sc->sc_iobase;
d2065 1
a2065 1
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
d2067 14
a2080 14
	SELECT_GUS_REG(port, GUSREG_START_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, ADDR_HIGH(start));
	SELECT_GUS_REG(port, GUSREG_START_ADDR_LOW);
	outw(port+GUS_DATA_LOW, ADDR_LOW(start));

	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, ADDR_HIGH(current));
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_LOW);
	outw(port+GUS_DATA_LOW, ADDR_LOW(current));

	SELECT_GUS_REG(port, GUSREG_END_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, ADDR_HIGH(end));
	SELECT_GUS_REG(port, GUSREG_END_ADDR_LOW);
	outw(port+GUS_DATA_LOW, ADDR_LOW(end));
d2100 13
a2112 13
	SELECT_GUS_REG(port, GUSREG_START_VOLUME);
	outb(port+GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(port, GUSREG_END_VOLUME);
	outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].current_volume >> 4);
	SELECT_GUS_REG(port, GUSREG_CUR_VOLUME);
	outw(port+GUS_DATA_LOW, 0x00);
	SELECT_GUS_REG(port, GUSREG_VOLUME_RATE);
	outb(port+GUS_DATA_HIGH, 63);

	SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
	outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
	outb(port+GUS_DATA_HIGH, 0x00);
d2114 4
a2117 4
	SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
	outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
	SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
	outb(port+GUS_DATA_HIGH, 0x00);
d2131 2
a2132 1
	register int port = sc->sc_iobase;
d2143 1
a2143 1
	guspoke(port, 0L, 0);
d2145 1
a2145 1
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
d2147 4
a2150 4
	SELECT_GUS_REG(port, GUSREG_CUR_VOLUME);
	outw(port+GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
	outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);
d2152 9
a2160 9
	SELECT_GUS_REG(port, GUSREG_CUR_VOLUME);
	outw(port+GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
	outb(port+GUS_DATA_HIGH, sc->sc_voc[voice].voccntl);

	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, 0x0000);
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_LOW);
	outw(port+GUS_DATA_LOW, 0x0000);
d2173 2
a2174 1
	register int port = sc->sc_iobase;
d2181 1
a2181 1
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
d2183 2
a2184 2
	SELECT_GUS_REG(port, GUSREG_START_VOLUME);
	outb(port+GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));
d2186 2
a2187 2
	SELECT_GUS_REG(port, GUSREG_END_VOLUME);
	outb(port+GUS_DATA_HIGH, (unsigned char) (gusvol >> 4));
d2189 2
a2190 2
	SELECT_GUS_REG(port, GUSREG_CUR_VOLUME);
	outw(port+GUS_DATA_LOW, gusvol << 4);
d2192 1
a2192 1
	outw(port+GUS_DATA_LOW, gusvol << 4);
d2197 1
a2197 1
 * Interface to the audio layer - set the data encoding type
d2201 4
a2204 3
gusmax_set_format(addr, encoding, precision)
	void * addr;
	u_int encoding, precision;
d2206 2
a2207 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d2210 5
a2214 2
	error = ad1848_set_format(ac, encoding, precision);
	return (error ? error : gus_set_format(sc, encoding, precision));
d2218 4
a2221 3
gus_set_format(addr, encoding, precision)
	void * addr;
	u_int encoding, precision;
d2223 1
a2223 1
	register struct gus_softc *sc = addr;
d2226 1
a2226 3
	DPRINTF(("gus_set_format called\n"));

	switch (encoding) {
d2228 5
a2232 2
	case AUDIO_ENCODING_PCM16:
	case AUDIO_ENCODING_PCM8:
d2240 1
a2240 1
	if (precision == 8) {
d2248 3
a2250 2
	sc->sc_encoding = encoding;
	sc->sc_precision = precision;
d2254 6
a2259 2
	return 0;
}
d2261 14
a2274 26
int
gusmax_set_channels(addr, channels)
	void * addr;
	int channels;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	int error;

	error = ad1848_set_channels(ac, channels);
	return (error ? error : gus_set_channels(sc, channels));
}

int
gus_set_channels(addr, channels)
	void * addr;
	int channels;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_set_channels called\n"));

	if (channels != 1 && channels != 2)
		return EINVAL;

	sc->sc_channels = channels;
d2289 2
a2290 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d2301 1
a2301 1
	register struct gus_softc *sc = addr;
d2305 2
a2306 1
	if (sc->sc_encoding == AUDIO_ENCODING_ULAW && blocksize > 32768)
a2331 103
/*
 * Interfaces to the audio layer - return values from the software config
 * struct
 */

int
gusmax_get_encoding(addr)
	void * addr;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	return gus_get_encoding(sc);
}

int
gus_get_encoding(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_get_encoding called\n"));

	/* XXX TODO: codec stuff */
	return sc->sc_encoding;
}

int
gusmax_get_channels(addr)
	void * addr;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	return gus_get_channels(sc);
}

int
gus_get_channels(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_get_channels called\n"));

	return sc->sc_channels;
}

u_long
gus_get_in_sr(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_get_in_sr called\n"));
	return sc->sc_irate;
}

u_long
gusmax_get_in_sr(addr)
	void * addr;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	return gus_get_in_sr(sc);
}

u_long
gusmax_get_out_sr(addr)
	void * addr;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	return gus_get_out_sr(sc);
}

u_long
gus_get_out_sr(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_get_out_sr called\n"));
	return sc->sc_orate;
}

int
gusmax_get_precision(addr)
	void * addr;
{
	register struct ad1848_softc *sc = addr;
	return gus_get_precision(sc->parent);
}

int
gus_get_precision(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_get_precision called\n"));

	return sc->sc_precision;
}

d2336 1
a2336 1
	register struct gus_softc *sc = (struct gus_softc *) addr;
a2341 34
/*
 * Interface to the audio layer - set the sample rate of the output voices
 */

int
gusmax_set_out_sr(addr, rate)
	void * addr;
	u_long rate;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	int error;

	error = ad1848_set_out_sr(ac, rate);
	return (error ? error : gus_set_out_sr(sc, rate));
}

int
gus_set_out_sr(addr, rate)
	void * addr;
	u_long rate;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_set_out_sr called\n"));

	if (rate > gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES])
		rate = gus_max_frequency[sc->sc_voices - GUS_MIN_VOICES];

	sc->sc_orate = rate;

	return 0;
}

d2346 2
a2347 1
	register int port = sc->sc_iobase;
d2352 2
a2353 2
	SELECT_GUS_REG(port, GUSREG_ACTIVE_VOICES);
	outb(port+GUS_DATA_HIGH, (voices-1) | 0xc0);
d2366 3
a2368 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d2370 3
a2372 1
	(void) ad1848_commit_settings(ac);
d2383 1
a2383 1
	register struct gus_softc *sc = addr;
d2445 2
a2446 1
	register int port = sc->sc_iobase;
d2466 3
a2468 3
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
	SELECT_GUS_REG(port, GUSREG_FREQ_CONTROL);
	outw(port+GUS_DATA_LOW, fc);
a2474 31
 * Interface to the audio layer - set the recording sampling rate
 */

int
gusmax_set_in_sr(addr, rate)
	void * addr;
	u_long rate;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
	int error;

	error = ad1848_set_in_sr(ac, rate);
	return (error ? error : gus_set_in_sr(sc, rate));
}


int
gus_set_in_sr(addr, rate)
	void *addr;
	u_long rate;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_set_in_sr called\n"));

	sc->sc_irate = rate;

	return 0;
}
/*
d2484 2
a2485 1
	register int port = sc->sc_iobase;
d2494 2
a2495 2
	SELECT_GUS_REG(port, GUSREG_SAMPLE_FREQ);
 	outb(port+GUS_DATA_HIGH, realrate);
d2508 1
a2508 1
	register struct ad1848_softc *sc = addr;
d2517 3
a2519 1
	register struct gus_softc *sc = (struct gus_softc *) addr;
d2525 1
a2525 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2530 1
a2530 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2541 3
a2543 1
	register struct gus_softc *sc = (struct gus_softc *) addr;
d2549 1
a2549 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2554 1
a2554 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2565 3
a2567 1
	register struct gus_softc *sc = (struct gus_softc *) addr;
d2573 1
a2573 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2578 1
a2578 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2594 2
a2595 1
	register int port = sc->sc_iobase;
d2602 4
a2605 4
	SELECT_GUS_REG(port, GUSREG_END_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, ADDR_HIGH(addr));
	SELECT_GUS_REG(port, GUSREG_END_ADDR_LOW);
	outw(port+GUS_DATA_LOW, ADDR_LOW(addr));
d2619 2
a2620 1
	register int port = sc->sc_iobase;
d2627 1
a2627 1
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
d2629 4
a2632 4
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_HIGH);
	outw(port+GUS_DATA_LOW, ADDR_HIGH(addr));
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_LOW);
	outw(port+GUS_DATA_LOW, ADDR_LOW(addr));
d2644 2
a2645 1
	register int port = sc->sc_iobase;
d2648 5
a2652 5
	outb(port+GUS_VOICE_SELECT, (unsigned char) voice);
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_HIGH|GUSREG_READ);
	addr = (inw(port+GUS_DATA_LOW) & 0x1fff) << 7;
	SELECT_GUS_REG(port, GUSREG_CUR_ADDR_LOW|GUSREG_READ);
	addr |= (inw(port+GUS_DATA_LOW) >> 9L) & 0x7f;
d2656 1
a2656 1
	DPRINTF(("gus voice %d curaddr %d end_addr %d\n",
d2688 3
a2690 2
guspoke(port, address, value)
	int port;
d2699 4
a2702 4
 	SELECT_GUS_REG(port, GUSREG_DRAM_ADDR_LOW);
 	outw(port+GUS_DATA_LOW, (unsigned int) (address & 0xffff));
 	SELECT_GUS_REG(port, GUSREG_DRAM_ADDR_HIGH);
 	outb(port+GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2708 1
a2708 1
	outb(port+GUS_DRAM_DATA, value);
d2716 3
a2718 2
guspeek(port, address)
	int port;
d2726 4
a2729 4
 	SELECT_GUS_REG(port, GUSREG_DRAM_ADDR_LOW);
 	outw(port+GUS_DATA_LOW, (unsigned int) (address & 0xffff));
 	SELECT_GUS_REG(port, GUSREG_DRAM_ADDR_HIGH);
 	outb(port+GUS_DATA_HIGH, (unsigned char) ((address >> 16) & 0xff));
d2735 1
a2735 1
	return (unsigned char) inb(port+GUS_DRAM_DATA);
d2747 4
a2750 1
	register int port = sc->sc_iobase;
d2759 2
a2760 2
	SELECT_GUS_REG(port, GUSREG_RESET);
	outb(port+GUS_DATA_HIGH, 0x00);
d2768 2
a2769 2
	SELECT_GUS_REG(port, GUSREG_RESET);
	outb(port+GUS_DATA_HIGH, GUSMASK_MASTER_RESET);
d2777 1
a2777 1
	outb(GUS_MIDI_CONTROL,MIDI_RESET);
d2781 1
a2781 1
	outb(GUS_MIDI_CONTROL,0x00);
d2787 6
a2792 6
	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	outb(port+GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(port, GUSREG_TIMER_CONTROL);
	outb(port+GUS_DATA_HIGH, 0x00);
	SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
	outb(port+GUS_DATA_HIGH, 0x00);
d2796 7
a2802 7
	inb(port+GUS_IRQ_STATUS);
	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	inb(port+GUS_DATA_HIGH);
	SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
	inb(port+GUS_DATA_HIGH);
	SELECT_GUS_REG(port, GUSREG_IRQ_STATUS);
	inb(port+GUS_DATA_HIGH);
d2809 1
a2809 1
		outb(port+GUS_VOICE_SELECT, (unsigned char) i);
d2811 1
a2811 1
		SELECT_GUS_REG(port, GUSREG_VOICE_CNTL);
d2816 1
a2816 1
		outb(port+GUS_DATA_HIGH, sc->sc_voc[i].voccntl);
d2821 2
a2822 2
		SELECT_GUS_REG(port, GUSREG_VOLUME_CONTROL);
		outb(port+GUS_DATA_HIGH, sc->sc_voc[i].volcntl);
d2827 23
a2849 23
		SELECT_GUS_REG(port, GUSREG_START_ADDR_HIGH);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_START_ADDR_LOW);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_END_ADDR_HIGH);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_END_ADDR_LOW);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_VOLUME_RATE);
		outb(port+GUS_DATA_HIGH, 0x01);
		SELECT_GUS_REG(port, GUSREG_START_VOLUME);
		outb(port+GUS_DATA_HIGH, 0x10);
		SELECT_GUS_REG(port, GUSREG_END_VOLUME);
		outb(port+GUS_DATA_HIGH, 0xe0);
		SELECT_GUS_REG(port, GUSREG_CUR_VOLUME);
		outw(port+GUS_DATA_LOW, 0x0000);

		SELECT_GUS_REG(port, GUSREG_CUR_ADDR_HIGH);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_CUR_ADDR_LOW);
		outw(port+GUS_DATA_LOW, 0x0000);
		SELECT_GUS_REG(port, GUSREG_PAN_POS);
		outb(port+GUS_DATA_HIGH, 0x07);
d2856 7
a2862 7
	inb(port+GUS_IRQ_STATUS);
	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	inb(port+GUS_DATA_HIGH);
	SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
	inb(port+GUS_DATA_HIGH);
	SELECT_GUS_REG(port, GUSREG_IRQ_STATUS);
	inb(port+GUS_DATA_HIGH);
d2864 2
a2865 2
	SELECT_GUS_REG(port, GUSREG_RESET);
	outb(port+GUS_DATA_HIGH, GUSMASK_MASTER_RESET | GUSMASK_DAC_ENABLE |
d2872 1
a2872 1
STATIC void
d2876 3
a2878 1
	register int port = sc->sc_iobase;
d2891 1
a2891 1
	outb(port+GUS_MAX_CTRL, ctrl);
d2893 1
d2898 1
a2900 46
		struct audio_hw_if gusmax_hw_if = {
			gusopen,
			gusmax_close,
			NULL,				/* drain */
			gusmax_set_in_sr,
			gusmax_get_in_sr,
			gusmax_set_out_sr,
			gusmax_get_out_sr,

			ad1848_query_encoding, /* query encoding */
			gusmax_set_format,
			gusmax_get_encoding,
			gusmax_get_precision,

			gusmax_set_channels,
			gusmax_get_channels,

			gusmax_round_blocksize,

			gusmax_set_out_port,
			gusmax_get_out_port,
			gusmax_set_in_port,
			gusmax_get_in_port,

			gusmax_commit_settings,

			gusmax_expand,	/* XXX use codec */
			mulaw_compress,

			gusmax_dma_output,
			gusmax_dma_input,
			gusmax_halt_out_dma,
			gusmax_halt_in_dma,
			gusmax_cont_out_dma,
			gusmax_cont_in_dma,

			gusmax_speaker_ctl,

			gus_getdev,
			gus_setfd,
			gusmax_mixer_set_port,
			gusmax_mixer_get_port,
			gusmax_mixer_query_devinfo,
			1,				/* full-duplex */
			0,
		};
d2910 1
a2910 1
		outb(sc->sc_iobase+GUS_MIX_CONTROL, sc->sc_mixcontrol);
d2915 2
a2956 122
gusmax_set_out_port(addr, port)
	void * addr;
	int port;
{
	register struct ad1848_softc *sc = addr;
	return gus_set_out_port(sc->parent, port);
}

int
gus_set_out_port(addr, port)
	void * addr;
	int port;
{
	register struct gus_softc *sc = addr;
	DPRINTF(("gus_set_out_port called\n"));
	sc->sc_out_port = port;

	return 0;
}

int
gusmax_get_out_port(addr)
	void * addr;
{
	register struct ad1848_softc *sc = addr;
	return gus_get_out_port(sc->parent);
}

int
gus_get_out_port(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;
	DPRINTF(("gus_get_out_port() called\n"));
	return sc->sc_out_port;
}

int
gusmax_set_in_port(addr, port)
	void * addr;
	int port;
{
	register struct ad1848_softc *sc = addr;
	DPRINTF(("gusmax_set_in_port: %d\n", port));

	switch(port) {
	case GUSMAX_MONO_LVL:
		port = MIC_IN_PORT;
		break;
	case GUSMAX_LINE_IN_LVL:
		port = LINE_IN_PORT;
		break;
	case GUSMAX_DAC_LVL:
		port = AUX1_IN_PORT;
		break;
	case GUSMAX_MIX_IN:
		port = DAC_IN_PORT;
		break;
	default:
		return(EINVAL);
		/*NOTREACHED*/
	}
	return(ad1848_set_rec_port(sc, port));
}

int
gusmax_get_in_port(addr)
	void * addr;
{
	register struct ad1848_softc *sc = addr;
	int port = GUSMAX_MONO_LVL;
    
	switch(ad1848_get_rec_port(sc)) {
	case MIC_IN_PORT:
		port = GUSMAX_MONO_LVL;
		break;
	case LINE_IN_PORT:
		port = GUSMAX_LINE_IN_LVL;
		break;
	case DAC_IN_PORT:
		port = GUSMAX_MIX_IN;
		break;
	case AUX1_IN_PORT:
		port = GUSMAX_DAC_LVL;
		break;
	}

	DPRINTF(("gusmax_get_in_port: %d\n", port));

	return(port);
}

int
gus_set_in_port(addr, port)
	void * addr;
	int port;
{
	register struct gus_softc *sc = addr;
	DPRINTF(("gus_set_in_port called\n"));
	/*
	 * On the GUS with ICS mixer, the ADC input is after the mixer stage,
	 * so we can't set the input port.
	 *
	 * On the GUS with CS4231 codec/mixer, see gusmax_set_in_port().
	 */
	sc->sc_in_port = port;

	return 0;
}


int
gus_get_in_port(addr)
	void * addr;
{
	register struct gus_softc *sc = addr;
	DPRINTF(("gus_get_in_port called\n"));
	return sc->sc_in_port;
}


int
d2964 1
a2964 1
	register struct ad1848_softc *sc = addr;
d2980 4
a2983 3
	register struct gus_softc *sc = addr;
	register int port = sc->sc_iobase;
	register u_char dmac;
d2998 3
a3000 1
	    sc->sc_encoding == AUDIO_ENCODING_PCM8)
d3004 2
a3005 1
	isadma_start((caddr_t)buf, size, sc->sc_recdrq, DMAMODE_READ);
d3014 2
a3015 2
	SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
	outb(port+GUS_DATA_HIGH, dmac);	/* Go! */
d3032 1
a3032 1
	    isadma_done(sc->sc_recdrq);
d3042 1
a3042 1
	    DMAPRINTF(("calling dmain_intr callback %x(%x)\n", callback, arg));
d3055 1
a3055 1
	register struct ad1848_softc *sc = addr;
d3064 1
a3064 1
	register struct ad1848_softc *sc = addr;
a3067 16
int
gusmax_cont_out_dma(addr)
	void * addr;
{
	register struct ad1848_softc *sc = addr;
	return gus_cont_out_dma(sc->parent);
}

int
gusmax_cont_in_dma(addr)
	void * addr;
{
	register struct ad1848_softc *sc = addr;
	return gus_cont_in_dma(sc->parent);
}

d3075 3
a3077 2
	register struct gus_softc *sc = addr;
	register int port = sc->sc_iobase;
d3084 2
a3085 2
 	SELECT_GUS_REG(port, GUSREG_DMA_CONTROL);
	outb(sc->sc_iobase+GUS_DATA_HIGH, 0);
d3088 1
a3088 1
	isadma_abort(sc->sc_drq);
d3111 3
a3113 2
	register struct gus_softc *sc = addr;
	register int port = sc->sc_iobase;
d3120 5
a3124 6
 	SELECT_GUS_REG(port, GUSREG_SAMPLE_CONTROL);
	outb(port+GUS_DATA_HIGH,
	    inb(port+GUS_DATA_HIGH) &
	    ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));

	isadma_abort(sc->sc_recdrq);
a3133 28
int
gus_cont_out_dma(addr)
	void * addr;
{
	DPRINTF(("gus_cont_out_dma called\n"));
	return EOPNOTSUPP;
}

int
gus_cont_in_dma(addr)
	void * addr;
{
	DPRINTF(("gus_cont_in_dma called\n"));
	return EOPNOTSUPP;
}


STATIC int
gus_setfd(addr, flag)
	void *addr;
	int flag;
{
    if (gus_hw_if.full_duplex == 0)
	 return ENOTTY;

    return(0);				/* nothing fancy to do. */
}

d3173 2
a3174 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d3324 2
a3325 2
	register struct gus_softc *sc = addr;
	register struct ics2101_softc *ic = &sc->sc_mixer;
d3494 2
a3495 2
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;
d3647 2
a3648 2
	register struct gus_softc *sc = addr;
	register struct ics2101_softc *ic = &sc->sc_mixer;
d3803 16
d3821 1
a3821 1
	register mixer_devinfo_t *dip;
a3825 8
	case GUSMAX_MIX_IN:	/* mixed MUX input */
		dip->type = AUDIO_MIXER_ENUM;
		dip->mixer_class = GUSMAX_INPUT_CLASS;
		dip->prev = dip->next = AUDIO_MIXER_LAST;
		strcpy(dip->label.name, AudioNmixerout);
		dip->un.e.num_mem = 0;		/* XXX */
		break;

d3903 1
a3903 1
	strcpy(dip->label.name, AudioNspeaker);
d3975 1
a3975 1
	dip->un.e.member[0].ord = GUSMAX_MIX_IN;
d3977 1
a3977 1
	dip->un.e.member[1].ord = GUSMAX_MONO_LVL;
d3979 1
a3979 1
	dip->un.e.member[2].ord = GUSMAX_DAC_LVL;
d3981 1
a3981 1
	dip->un.e.member[3].ord = GUSMAX_LINE_IN_LVL;
d3988 1
a3988 1
	strcpy(dip->label.name, AudioCInputs);
d3995 1
a3995 1
	strcpy(dip->label.name, AudioCOutputs);
d4002 1
a4002 1
	strcpy(dip->label.name, AudioCMonitor);
d4009 1
a4009 1
	strcpy(dip->label.name, AudioCRecord);
d4023 1
a4023 1
	register mixer_devinfo_t *dip;
d4025 1
a4025 1
	register struct gus_softc *sc = addr;
d4079 1
a4079 1
		strcpy(dip->label.name, AudioNvolume);
d4141 1
a4141 1
		strcpy(dip->label.name, AudioCInputs);
d4148 1
a4148 1
		strcpy(dip->label.name, AudioCOutputs);
d4155 1
a4155 1
		strcpy(dip->label.name, AudioCRecord);
d4174 3
a4176 1
		fp->format_id = AUDIO_ENCODING_ULAW;
d4179 4
a4182 2
		strcpy(fp->name, AudioEpcm16);
		fp->format_id = AUDIO_ENCODING_PCM16;
d4185 34
a4218 2
		strcpy(fp->name, AudioEpcm8);
		fp->format_id = AUDIO_ENCODING_PCM8;
d4220 1
d4237 6
a4242 4
	register int port = sc->sc_iobase;
	register struct ics2101_softc *ic = &sc->sc_mixer;
	sc->sc_mixer.sc_selio = port+GUS_MIXER_SELECT;
	sc->sc_mixer.sc_dataio = port+GUS_MIXER_DATA;
@


1.12
log
@sync with NETBSD 30/3/97 + adapating aria.c
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.10 1996/05/07 07:36:36 deraadt Exp $	*/
d220 1
a220 1
	u_char *sc_dmaoutaddr;		/* for isa_dmadone */
d222 1
a222 1
	int sc_dmaoutcnt;		/* for isa_dmadone */
d226 2
a227 2
	u_char *sc_dmainaddr;		/* for isa_dmadone */
	int sc_dmaincnt;		/* for isa_dmadone */
d1369 1
a1369 1
    isa_dmaabort(sc->sc_drq);		/* XXX we will dmadone below? */
d1409 1
a1409 4
	isa_dmadone(DMAMODE_WRITE,
		    sc->sc_dmaoutaddr,
		    sc->sc_dmaoutcnt - 1,
		    sc->sc_drq);
d1915 1
a1915 1
	isa_dmastart(DMAMODE_WRITE, buffaddr, length, sc->sc_drq);
d3225 1
a3225 1
	isa_dmastart(DMAMODE_READ, (caddr_t) buf, size, sc->sc_recdrq);
d3227 1
a3227 1
	DMAPRINTF(("gus_dma_input isa_dmastarted\n"));
d3252 1
a3252 2
	    isa_dmadone(DMAMODE_READ, sc->sc_dmainaddr, sc->sc_dmaincnt - 1,
			sc->sc_recdrq);
d3323 1
a3323 1
	isa_dmaabort(sc->sc_drq);
d3356 2
a3357 1
	     inb(port+GUS_DATA_HIGH) & ~(GUSMASK_SAMPLE_START|GUSMASK_SAMPLE_IRQ));
d3359 1
a3359 1
	isa_dmaabort(sc->sc_recdrq);
@


1.11
log
@sync 0521
@
text
@d367 1
a367 1
int	gus_set_encoding __P((void *, u_int));
d369 2
a370 1
int	gusmax_set_encoding __P((void *, u_int));
a371 3
int	gus_set_precision __P((void *, u_int));
int	gus_get_precision __P((void *));
int	gusmax_set_precision __P((void *, u_int));
a389 2
int	gusmax_set_precision __P((void *, u_int));
int	gusmax_get_precision __P((void *));
d623 1
a623 1
	gus_set_encoding,
a624 2

	gus_set_precision,
a638 2
	ad1848_get_silence,

d2118 1
a2118 1
gusmax_set_encoding(addr, encoding)
d2120 1
a2120 1
	u_int encoding;
d2124 4
a2127 2
	(void) ad1848_set_encoding(ac, encoding);
	return gus_set_encoding(sc, encoding);
d2131 1
a2131 1
gus_set_encoding(addr, encoding)
d2133 1
a2133 1
	u_int encoding;
d2136 1
d2138 1
a2138 1
	DPRINTF(("gus_set_encoding called\n"));
d2140 8
a2147 5
	/* XXX todo: add alaw for codec */
	if (encoding != AUDIO_ENCODING_ULAW &&
	    encoding != AUDIO_ENCODING_PCM16 &&
	    encoding != AUDIO_ENCODING_PCM8)
		return EINVAL;
d2149 1
a2149 4
	if (encoding != AUDIO_ENCODING_PCM16)
		sc->sc_precision = 8;       /* XXX force it. */

	sc->sc_encoding = encoding;
d2151 1
a2151 1
	if (sc->sc_precision == 8) {
d2158 6
d2174 4
a2177 2
	(void) ad1848_set_channels(ac, channels);
	return gus_set_channels(sc, channels);
a2197 45
 * Interface to the audio layer - set the data precision
 */

int
gusmax_set_precision(addr, bits)
	void * addr;
	u_int bits;
{
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;

	(void) ad1848_set_precision(ac, bits);
	return gus_set_precision(sc, bits);
}


int
gus_set_precision(addr, bits)
	void * addr;
	u_int bits;
{
	register struct gus_softc *sc = addr;

	DPRINTF(("gus_set_precision called\n"));

	if (bits != 8 && bits != 16)
		return EINVAL;

	if (sc->sc_encoding != AUDIO_ENCODING_PCM16 && bits != 8)
		/* If we're doing PCM8 or MULAW, it must be 8 bits. */
		return EINVAL;

	sc->sc_precision = bits;

	if (bits == 16) {
		sc->sc_voc[GUS_VOICE_LEFT].voccntl |= GUSMASK_DATA_SIZE16;
		sc->sc_voc[GUS_VOICE_RIGHT].voccntl |= GUSMASK_DATA_SIZE16;
	} else {
		sc->sc_voc[GUS_VOICE_LEFT].voccntl &= ~GUSMASK_DATA_SIZE16;
		sc->sc_voc[GUS_VOICE_RIGHT].voccntl &= ~GUSMASK_DATA_SIZE16;
	}
	return 0;
}

/*
d2373 4
a2376 2
	(void) ad1848_set_out_sr(ac, rate);
	return gus_set_out_sr(sc, rate);
d2534 4
a2537 2
	(void) ad1848_set_in_sr(ac, rate);
	return gus_set_in_sr(sc, rate);
d2972 1
a2972 1
			gusmax_set_encoding,
a2973 2

			gusmax_set_precision,
a2986 2

			ad1848_get_silence,
@


1.10
log
@sync with 0504 -- prototypes and bus.h
@
text
@d1 2
a2 2
/*	$OpenBSD: gus.c,v 1.9 1996/04/21 22:23:28 deraadt Exp $	*/
/*	$NetBSD: gus.c,v 1.15 1996/05/03 22:35:24 jtk Exp $	*/
d114 1
@


1.9
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*	$OpenBSD: gus.c,v 1.8 1996/04/18 23:47:34 niklas Exp $	*/
/*	$NetBSD: gus.c,v 1.13 1996/04/11 22:28:42 cgd Exp $	*/
d384 2
a385 2
int	gus_dma_output __P((void *, void *, int, void (*)(), void *));
int	gus_dma_input __P((void *, void *, int, void (*)(), void *));
d395 2
a396 2
int	gusmax_dma_output __P((void *, void *, int, void (*)(), void *));
int	gusmax_dma_input __P((void *, void *, int, void (*)(), void *));
d426 5
a430 4
STATIC void	gus_start_voice __P((struct gus_softc *, int, int)),
		gus_stop_voice __P((struct gus_softc *, int, int)),
		gus_set_endaddr __P((struct gus_softc *, int, u_long)),
		gus_set_curaddr __P((struct gus_softc *, int, u_long));
d432 1
d441 1
a441 1
STATIC unsigned long convert_to_16bit();
d457 5
a691 3
	int i;
	unsigned char s1, s2;

d798 1
a798 1
	int		s,i;
d896 1
a896 2
		unsigned long loc;
		unsigned char val;
d1108 1
a1108 1
	void (*intr)();
d1119 2
a1120 1
stereo_dmaintr(void *arg)
d1166 1
a1166 1
	void (*intr)();
d1172 1
a1172 1
	int i, flags;
d1247 2
a1248 1
/*	ac->aux1_mute = 1;
d1250 1
d1375 3
a1377 1
/*    isa_dmaabort(sc->sc_drq);		/* XXX we will dmadone below? */
a1560 1
	unsigned long addr;
d1686 1
a1686 1
			    void (*pfunc)() = sc->sc_dmaoutintr;
d1700 1
d1886 1
a1886 1
	unsigned long gusaddr;
a1890 1
	int s;
d1962 3
a1964 3
	unsigned long start;
	unsigned long current;
	unsigned long end;
a2260 1
	register unsigned long i;
d2536 1
a2536 1
	unsigned long temp, f = (unsigned long) freq;
d2543 1
a2543 1
	temp = (unsigned long) gus_max_frequency[sc->sc_voices-GUS_MIN_VOICES];
a2602 1
	int s;
d2605 3
a2607 1
/*	realrate = 9878400/(16*(rate+2)); /* formula from GUS docs */
d2702 1
a2702 1
	unsigned long addr;
d2718 1
a2718 1
#if 0
d2726 1
a2726 1
	unsigned long addr;
a2742 1
#endif
d2747 1
a2747 1
STATIC unsigned long
d2753 1
a2753 1
	unsigned long addr;
d2769 1
d2776 1
a2776 1
STATIC unsigned long
d2778 1
a2778 1
	unsigned long address;
d2780 1
a2780 1
	unsigned long old_address;
d3229 1
a3229 1
	void (*callback)();
d3245 1
a3245 1
	void (*callback)();
d3441 1
a3441 1
STATIC inline int
d3458 1
a3458 1
STATIC inline int
a3482 1
	u_char eq;
a3634 1
	u_int mute;
a3957 1
	u_int mute;
a4113 3
	register struct ad1848_softc *ac = addr;
	register struct gus_softc *sc = ac->parent;

a4469 2
	register struct gus_softc *sc = addr;

@


1.8
log
@NetBSD 960317 merge
@
text
@d1 2
a2 2
/*	$OpenBSD: gus.c,v 1.7 1996/03/20 01:00:44 mickey Exp $	*/
/*	$NetBSD: gus.c,v 1.10 1996/03/01 04:08:31 mycroft Exp $	*/
d129 1
d462 6
a467 2
struct cfdriver guscd = {
	NULL, "gus", gusprobe, gusattach, DV_DULL, sizeof(struct gus_softc)
d935 2
a936 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_AUDIO, gusintr,
	    sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);
d982 1
a982 1
	if (unit >= guscd.cd_ndevs)
d984 1
a984 1
	sc = guscd.cd_devs[unit];
@


1.7
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*	$OpenBSD: gus.c,v 1.6 1996/03/19 21:10:11 mickey Exp $	*/
/*	$NetBSD: gus.c,v 1.7 1996/02/16 08:18:37 mycroft Exp $	*/
d131 6
d407 19
a425 19
static void	gus_deinterleave __P((struct gus_softc *, void *, int));
static void	gus_expand __P((void *, int, u_char *, int));
static void	gusmax_expand __P((void *, int, u_char *, int));

static int	gus_mic_ctl __P((void *, int));
static int	gus_linein_ctl __P((void *, int));
static int	gus_test_iobase __P((int));
static void	guspoke __P((int, long, u_char));
static void	gusdmaout __P((struct gus_softc *, int, u_long, caddr_t, int));
static void	gus_init_cs4231 __P((struct gus_softc *));
static void	gus_init_ics2101 __P((struct gus_softc *));

static void	gus_set_chan_addrs __P((struct gus_softc *));
static void	gusreset __P((struct gus_softc *, int));
static void	gus_set_voices __P((struct gus_softc *, int));
static void	gus_set_volume __P((struct gus_softc *, int, int));
static void	gus_set_samprate __P((struct gus_softc *, int, int));
static void	gus_set_recrate __P((struct gus_softc *, u_long));
static void	gus_start_voice __P((struct gus_softc *, int, int)),
d429 24
a452 24
static u_long	gus_get_curaddr __P((struct gus_softc *, int));
static int	gus_dmaout_intr __P((struct gus_softc *));
static void	gus_dmaout_dointr __P((struct gus_softc *));
static void	gus_dmaout_timeout __P((void *));
static int	gus_dmain_intr __P((struct gus_softc *));
static int	gus_voice_intr __P((struct gus_softc *));
static void	gus_start_playing __P((struct gus_softc *, int));
static void	gus_continue_playing __P((struct gus_softc *, int));
static u_char guspeek __P((int, u_long));
static unsigned long convert_to_16bit();
static int	gus_setfd __P((void *, int));
static int	gus_mixer_set_port __P((void *, mixer_ctrl_t *));
static int	gus_mixer_get_port __P((void *, mixer_ctrl_t *));
static int	gusmax_mixer_set_port __P((void *, mixer_ctrl_t *));
static int	gusmax_mixer_get_port __P((void *, mixer_ctrl_t *));
static int	gus_mixer_query_devinfo __P((void *, mixer_devinfo_t *));
static int	gusmax_mixer_query_devinfo __P((void *, mixer_devinfo_t *));
static int	gus_query_encoding __P((void *, struct audio_encoding *));

static void	gusics_master_mute __P((struct ics2101_softc *, int));
static void	gusics_dac_mute __P((struct ics2101_softc *, int));
static void	gusics_mic_mute __P((struct ics2101_softc *, int));
static void	gusics_linein_mute __P((struct ics2101_softc *, int));
static void	gusics_cd_mute __P((struct ics2101_softc *, int));
d671 1
a671 1
	struct device *parent, *self;
d733 1
a733 1
static int
d1017 1
a1017 1
static void
d1029 1
a1029 1
static void
d1046 1
a1046 1
static void
d1347 1
a1347 1
static void
d1376 1
a1376 1
static int
d1396 1
a1396 1
static void
d1403 1
a1403 1
	isa_dmadone(B_WRITE,
d1542 1
a1542 1
static int
d1616 2
a1617 1
			    printf("negative bufcnt in stopped voice\n");
d1620 2
a1621 1
			    panic("negative bufcnt in stopped voice");
d1635 12
a1646 1
			gus_continue_playing(sc, voice);
d1690 1
a1690 1
static void
d1769 1
a1769 1
static void
d1795 4
a1798 2
    if (sc->sc_playbuf == sc->sc_dmabuf && (sc->sc_flags & GUS_LOCKED))
	printf("continue into active dmabuf?\n");
d1862 1
d1869 1
a1869 1
static void
d1913 1
a1913 1
	isa_dmastart(B_WRITE, buffaddr, length, sc->sc_drq);
d1943 1
a1943 1
static void
d2039 1
a2039 1
static void
d2081 1
a2081 1
static void
d2424 1
a2424 1
static inline void gus_set_voices(sc, voices)
d2480 1
a2480 1
static void
d2518 1
a2518 1
static void
d2585 1
a2585 1
static void
d2638 1
a2638 1
static int
d2660 1
a2660 1
static int
d2686 1
a2686 1
static void
d2710 1
a2710 1
static void
d2736 1
a2736 1
static unsigned long
d2764 1
a2764 1
static unsigned long
d2782 1
a2782 1
static void
d2809 1
a2809 1
static unsigned char
d2835 1
a2835 1
static void
d2962 1
a2962 1
static void
d3257 1
a3257 1
	isa_dmastart(B_READ, (caddr_t) buf, size, sc->sc_recdrq);
d3275 1
a3275 1
static int
d3284 1
a3284 1
	    isa_dmadone(B_READ, sc->sc_dmainaddr, sc->sc_dmaincnt - 1,
d3418 1
a3418 1
static int
d3429 1
a3429 1
static inline int
d3446 1
a3446 1
static inline int
d3463 1
a3463 1
static int
d3615 1
a3615 1
static int
d3741 1
a3741 1
static void
d3750 1
a3750 1
static void
d3759 1
a3759 1
static void
d3768 1
a3768 1
static void
d3777 1
a3777 1
static void
d3786 1
a3786 1
static int
d3939 1
a3939 1
static int
d4100 1
a4100 1
static int
d4313 1
a4313 1
static int
d4459 1
a4459 1
static int
d4491 1
a4491 1
static void
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*	$OpenBSD: gus.c,v 1.5 1996/03/08 16:42:54 niklas Exp $	*/
d925 1
a925 1
	    sc /* sc->sc_gusdsp */);
@


1.5
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d925 1
a925 1
	    sc /* sc->sc_gusdsp */, sc->sc_dev.dv_xname);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: gus.c,v 1.3 1995/11/10 04:30:44 mycroft Exp $	*/
d4 6
a9 3
/*
 * Copyright (c) 1994, 1995 Ken Hornstein.  All rights reserved.
 * Copyright (c) 1995 John T. Kohl.  All rights reserved.
d21 17
a37 14
 *	This product includes software developed by Ken Hornstein.
 * 4. The name of the authors may not be used to endorse or promote products
 *      derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
a345 2
int	gusprobe ()/*__P((struct device *, struct device *, void *))*/;
void	gusattach __P((struct device *, struct device *, void *));
d452 3
d664 1
a664 1
gusprobe(parent, self, aux)
d666 1
a666 1
	void *aux;
d668 1
a668 1
	register struct gus_softc *sc = (void *) self;
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d917 1
a917 1
	    sc /* sc->sc_gusdsp */);
@


1.2
log
@from netbsd; Convert IRQ, DRQ, and port numbers to int
@
text
@d914 1
a914 1
	 * we use ISA_IPL_CLOCK.
d916 2
a917 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_AUDIO,
				       gusintr, sc /* sc->sc_gusdsp */);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: gus.c,v 1.2 1995/07/24 05:54:52 cgd Exp $	*/
d168 4
a171 4
	u_short sc_iobase;		/* I/O base address */
	u_short sc_irq;			/* IRQ used */
	u_short sc_drq;			/* DMA channel for play */
	u_short sc_recdrq;		/* DMA channel for recording */
d457 7
a463 2
static int gus_irq_map[] = { 0, 0, 1, 3, 0, 2, 0, 4, 0, 1, 0, 5, 6, 0, 0, 7 };
static int gus_drq_map[] = { 0, 1, 0, 2, 0, 3, 4, 5 };
d469 4
a472 2
static u_short gus_base_addrs[] = { 0x210, 0x220, 0x230, 0x240, 0x250, 0x260 };
static int gus_addrs = sizeof(gus_base_addrs) / sizeof(u_short);
d664 1
a664 1
	u_short recdrq = cf->cf_flags;
d674 1
a674 1
	if (! gus_irq_map[ia->ia_irq]) {
d679 1
a679 1
	if (! gus_drq_map[ia->ia_drq]) {
d685 1
a685 1
		if (recdrq > 7 || ! gus_drq_map[recdrq]) {
d774 1
a774 1
	register u_short port = ia->ia_iobase;
d1278 1
a1278 1
	register u_short port = sc->sc_iobase;
d1338 1
a1338 1
    register u_short port = sc->sc_iobase;
d1366 1
a1366 1
	register u_short port = sc->sc_iobase;
d1386 1
a1386 1
	register u_short port = sc->sc_iobase;
d1532 1
a1532 1
	register u_short port = sc->sc_iobase;
d1668 1
a1668 1
    register u_short port = sc->sc_iobase;
d1747 1
a1747 1
    register u_short port = sc->sc_iobase;
d1847 1
a1847 1
	register u_short port = sc->sc_iobase;
d1919 1
a1919 1
	register u_short port = sc->sc_iobase;
d2015 1
a2015 1
	register u_short port = sc->sc_iobase;
d2056 1
a2056 1
	register u_short port = sc->sc_iobase;
d2398 1
a2398 1
	register u_short port = sc->sc_iobase;
d2493 1
a2493 1
	register u_short port = sc->sc_iobase;
d2560 1
a2560 1
	register u_short port = sc->sc_iobase;
d2662 1
a2662 1
	register u_short port = sc->sc_iobase;
d2686 1
a2686 1
	register u_short port = sc->sc_iobase;
d2711 1
a2711 1
	register u_short port = sc->sc_iobase;
d2810 1
a2810 1
	register u_short port = sc->sc_iobase;
d2936 1
a2936 1
	register u_short port = sc->sc_iobase;
d3207 1
a3207 1
	register u_short port = sc->sc_iobase;
d3315 1
a3315 1
	register u_short port = sc->sc_iobase;
d3350 1
a3350 1
	register u_short port = sc->sc_iobase;
d4465 1
a4465 1
	register u_short port = sc->sc_iobase;
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
