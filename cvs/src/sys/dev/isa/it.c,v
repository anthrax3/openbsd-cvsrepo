head	1.46;
access;
symbols
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.46.0.10
	OPENBSD_6_1_BASE:1.46
	OPENBSD_6_0:1.46.0.6
	OPENBSD_6_0_BASE:1.46
	OPENBSD_5_9:1.46.0.2
	OPENBSD_5_9_BASE:1.46
	OPENBSD_5_8:1.46.0.4
	OPENBSD_5_8_BASE:1.46
	OPENBSD_5_7:1.45.0.4
	OPENBSD_5_7_BASE:1.45
	OPENBSD_5_6:1.44.0.8
	OPENBSD_5_6_BASE:1.44
	OPENBSD_5_5:1.44.0.6
	OPENBSD_5_5_BASE:1.44
	OPENBSD_5_4:1.44.0.2
	OPENBSD_5_4_BASE:1.44
	OPENBSD_5_3:1.42.0.2
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.40.0.8
	OPENBSD_5_2_BASE:1.40
	OPENBSD_5_1_BASE:1.40
	OPENBSD_5_1:1.40.0.6
	OPENBSD_5_0:1.40.0.4
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.40.0.2
	OPENBSD_4_9_BASE:1.40
	OPENBSD_4_8:1.39.0.8
	OPENBSD_4_8_BASE:1.39
	OPENBSD_4_7:1.39.0.4
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.39.0.6
	OPENBSD_4_6_BASE:1.39
	OPENBSD_4_5:1.39.0.2
	OPENBSD_4_5_BASE:1.39
	OPENBSD_4_4:1.32.0.2
	OPENBSD_4_4_BASE:1.32
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.23.0.2
	OPENBSD_4_2_BASE:1.23
	OPENBSD_4_1:1.21.0.2
	OPENBSD_4_1_BASE:1.21
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.18.0.2
	OPENBSD_3_9_BASE:1.18
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.12.0.2
	OPENBSD_3_7_BASE:1.12
	OPENBSD_3_6:1.10.0.2
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.8
	SMP_SYNC_B:1.8
	OPENBSD_3_5:1.8.0.2
	OPENBSD_3_5_BASE:1.8
	OPENBSD_3_4:1.2.0.4
	OPENBSD_3_4_BASE:1.2
	SMP:1.2.0.2;
locks; strict;
comment	@ * @;


1.46
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.45;
commitid	p4LJxGKbi0BU2cG6;

1.45
date	2014.12.10.12.27.57;	author mikeb;	state Exp;
branches;
next	1.44;
commitid	v6PAeA18rydwc5Vx;

1.44
date	2013.04.10.01.35.55;	author guenther;	state Exp;
branches;
next	1.43;

1.43
date	2013.03.21.18.20.00;	author brynet;	state Exp;
branches;
next	1.42;

1.42
date	2012.12.14.13.17.29;	author mikeb;	state Exp;
branches;
next	1.41;

1.41
date	2012.10.17.22.32.01;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2011.01.20.16.59.55;	author form;	state Exp;
branches;
next	1.39;

1.39
date	2009.01.16.06.58.32;	author form;	state Exp;
branches;
next	1.38;

1.38
date	2008.10.23.08.08.44;	author form;	state Exp;
branches;
next	1.37;

1.37
date	2008.10.22.05.38.17;	author form;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.11.20.31.50;	author miod;	state Exp;
branches;
next	1.35;

1.35
date	2008.10.08.17.32.47;	author form;	state Exp;
branches;
next	1.34;

1.34
date	2008.10.08.17.17.39;	author form;	state Exp;
branches;
next	1.33;

1.33
date	2008.10.08.15.06.49;	author form;	state Exp;
branches;
next	1.32;

1.32
date	2008.04.07.17.50.37;	author form;	state Exp;
branches;
next	1.31;

1.31
date	2008.04.07.17.37.58;	author form;	state Exp;
branches;
next	1.30;

1.30
date	2008.04.07.09.43.54;	author form;	state Exp;
branches;
next	1.29;

1.29
date	2008.04.07.09.31.30;	author form;	state Exp;
branches;
next	1.28;

1.28
date	2008.04.03.20.28.05;	author form;	state Exp;
branches;
next	1.27;

1.27
date	2007.12.24.14.07.47;	author form;	state Exp;
branches;
next	1.26;

1.26
date	2007.12.23.17.44.07;	author form;	state Exp;
branches;
next	1.25;

1.25
date	2007.12.20.12.02.14;	author form;	state Exp;
branches;
next	1.24;

1.24
date	2007.12.18.21.17.54;	author form;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.24.05.34.35;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2006.06.24.13.42.45;	author kettenis;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.10.00.57.54;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2006.01.23.18.43.22;	author kettenis;	state Exp;
branches;
next	1.17;

1.17
date	2006.01.19.17.08.40;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2005.12.28.15.27.44;	author grange;	state Exp;
branches;
next	1.15;

1.15
date	2005.07.26.19.08.09;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.29.17.13.54;	author grange;	state Exp;
branches;
next	1.13;

1.13
date	2005.04.09.14.42.33;	author grange;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.02.21.34.58;	author grange;	state Exp;
branches;
next	1.11;

1.11
date	2004.10.05.18.36.04;	author grange;	state Exp;
branches;
next	1.10;

1.10
date	2004.08.23.18.06.02;	author millert;	state Exp;
branches;
next	1.9;

1.9
date	2004.08.17.21.59.15;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.10.20.01.40;	author grange;	state Exp;
branches;
next	1.7;

1.7
date	2004.02.02.20.14.26;	author grange;	state Exp;
branches;
next	1.6;

1.6
date	2004.01.28.20.02.27;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.01.12.14.10.53;	author grange;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.05.20.57.10;	author grange;	state Exp;
branches;
next	1.3;

1.3
date	2003.10.19.17.29.41;	author grange;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.28.19.21.11;	author grange;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2003.05.20.20.26.27;	author grange;	state Exp;
branches;
next	;

1.2.2.1
date	2003.06.07.10.32.24;	author ho;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	1.2.2.3;

1.2.2.3
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: it.c,v 1.45 2014/12/10 12:27:57 mikeb Exp $	*/

/*
 * Copyright (c) 2007-2008 Oleg Safiullin <form@@pdp-11.org.ru>
 * Copyright (c) 2006-2007 Juan Romero Pardines <juan@@xtrarom.org>
 * Copyright (c) 2003 Julien Bordet <zejames@@greyhats.org>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/sensors.h>

#include <machine/bus.h>

#include <dev/isa/isavar.h>
#include <dev/isa/itvar.h>


#if defined(ITDEBUG)
#define DPRINTF(x)		do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif


int it_match(struct device *, void *, void *);
void it_attach(struct device *, struct device *, void *);
int it_activate(struct device *, int);
u_int8_t it_readreg(bus_space_tag_t, bus_space_handle_t, int);
void it_writereg(bus_space_tag_t, bus_space_handle_t, int, u_int8_t);
void it_enter(bus_space_tag_t, bus_space_handle_t, int);
void it_exit(bus_space_tag_t, bus_space_handle_t);

u_int8_t it_ec_readreg(struct it_softc *, int);
void it_ec_writereg(struct it_softc *, int, u_int8_t);
void it_ec_refresh(void *arg);

int it_wdog_cb(void *, int);

/*
 * IT87-compatible chips can typically measure voltages up to 4.096 V.
 * To measure higher voltages the input is attenuated with (external)
 * resistors.  Negative voltages are measured using a reference
 * voltage.  So we have to convert the sensor values back to real
 * voltages by applying the appropriate resistor factor.
 */
#define RFACT_NONE		10000
#define RFACT(x, y)		(RFACT_NONE * ((x) + (y)) / (y))


struct {
	enum sensor_type	type;
	const char		*desc;
} it_sensors[IT_EC_NUMSENSORS] = {
#define IT_TEMP_BASE		0
#define IT_TEMP_COUNT		3
	{ SENSOR_TEMP,		NULL		},
	{ SENSOR_TEMP,		NULL		},
	{ SENSOR_TEMP,		NULL		},

#define IT_FAN_BASE		3
#define IT_FAN_COUNT		5
	{ SENSOR_FANRPM,	NULL		},
	{ SENSOR_FANRPM,	NULL		},
	{ SENSOR_FANRPM,	NULL		},
	{ SENSOR_FANRPM,	NULL		},
	{ SENSOR_FANRPM,	NULL		},

#define IT_VOLT_BASE		8
#define IT_VOLT_COUNT		9
	{ SENSOR_VOLTS_DC,	"VCORE_A"	},
	{ SENSOR_VOLTS_DC,	"VCORE_B"	},
	{ SENSOR_VOLTS_DC,	"+3.3V"		},
	{ SENSOR_VOLTS_DC,	"+5V"		},
	{ SENSOR_VOLTS_DC,	"+12V"		},
	{ SENSOR_VOLTS_DC,	"-12V"		},
	{ SENSOR_VOLTS_DC,	"-5V"		},
	{ SENSOR_VOLTS_DC,	"+5VSB"		},
	{ SENSOR_VOLTS_DC,	"VBAT"		}
};

/* rfact values for voltage sensors */
int it_vrfact[IT_VOLT_COUNT] = {
	RFACT_NONE,		/* VCORE_A	*/
	RFACT_NONE,		/* VCORE_A	*/
	RFACT_NONE,		/* +3.3V	*/
	RFACT(68, 100),		/* +5V		*/
	RFACT(30, 10),		/* +12V		*/
	RFACT(83, 20),		/* -12V		*/
	RFACT(21, 10),		/* -5V		*/
	RFACT(68, 100),		/* +5VSB	*/
	RFACT_NONE		/* VBAT		*/
};

int it_fan_regs[] = {
	IT_EC_FAN_TAC1, IT_EC_FAN_TAC2, IT_EC_FAN_TAC3,
	IT_EC_FAN_TAC4_LSB, IT_EC_FAN_TAC5_LSB
};

int it_fan_ext_regs[] = {
	IT_EC_FAN_EXT_TAC1, IT_EC_FAN_EXT_TAC2, IT_EC_FAN_EXT_TAC3,
	IT_EC_FAN_TAC4_MSB, IT_EC_FAN_TAC5_MSB
};

LIST_HEAD(, it_softc) it_softc_list = LIST_HEAD_INITIALIZER(it_softc_list);


int
it_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	struct it_softc *sc;
	bus_space_handle_t ioh;
	int ec_iobase, found = 0;
	u_int16_t cr;

	if (ia->ipa_io[0].base != IO_IT1 && ia->ipa_io[0].base != IO_IT2)
		return (0);

	/* map i/o space */
	if (bus_space_map(ia->ia_iot, ia->ipa_io[0].base, 2, 0, &ioh) != 0) {
		DPRINTF(("it_match: can't map i/o space"));
		return (0);
	}

	/* enter MB PnP mode */
	it_enter(ia->ia_iot, ioh, ia->ipa_io[0].base);

	/*
	 * SMSC or similar SuperIO chips use 0x55 magic to enter PnP mode
	 * and 0xaa to exit. These chips also enter PnP mode via ITE
	 * `enter MB PnP mode' sequence, so force chip to exit PnP mode
	 * if this is the case.
	 */
	bus_space_write_1(ia->ia_iot, ioh, IT_IO_ADDR, 0xaa);

	/* get chip id */
	cr = it_readreg(ia->ia_iot, ioh, IT_CHIPID1) << 8;
	cr |= it_readreg(ia->ia_iot, ioh, IT_CHIPID2);

	switch (cr) {
	case IT_ID_8705:
	case IT_ID_8712:
	case IT_ID_8716:
	case IT_ID_8718:
	case IT_ID_8720:
	case IT_ID_8721:
	case IT_ID_8726:
	case IT_ID_8728:
	case IT_ID_8772:
		/* get environment controller base address */
		it_writereg(ia->ia_iot, ioh, IT_LDN, IT_EC_LDN);
		ec_iobase = it_readreg(ia->ia_iot, ioh, IT_EC_MSB) << 8;
		ec_iobase |= it_readreg(ia->ia_iot, ioh, IT_EC_LSB);

		/* check if device already attached */
		LIST_FOREACH(sc, &it_softc_list, sc_list)
			if (sc->sc_ec_iobase == ec_iobase)
				break;

		if (sc == NULL) {
			ia->ipa_nio = 1;
			ia->ipa_io[0].length = 2;
			ia->ipa_nmem = ia->ipa_nirq = ia->ipa_ndrq = 0;
			found++;
		}

		break;
	}

	/* exit MB PnP mode */
	it_exit(ia->ia_iot, ioh);

	/* unmap i/o space */
	bus_space_unmap(ia->ia_iot, ioh, 2);

	return (found);
}

void
it_attach(struct device *parent, struct device *self, void *aux)
{
	struct it_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	int i;

	sc->sc_iot = ia->ia_iot;
	sc->sc_iobase = ia->ipa_io[0].base;
	if (bus_space_map(sc->sc_iot, sc->sc_iobase, 2, 0, &sc->sc_ioh) != 0) {
		printf(": can't map i/o space\n");
		return;
	}

	/* enter MB PnP mode */
	it_enter(sc->sc_iot, sc->sc_ioh, sc->sc_iobase);

	/* get chip id and rev */
	sc->sc_chipid = it_readreg(sc->sc_iot, sc->sc_ioh, IT_CHIPID1) << 8;
	sc->sc_chipid |= it_readreg(sc->sc_iot, sc->sc_ioh, IT_CHIPID2);
	sc->sc_chiprev = it_readreg(sc->sc_iot, sc->sc_ioh, IT_CHIPREV) & 0x0f;

	/* get environment controller base address */
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_LDN, IT_EC_LDN);
	sc->sc_ec_iobase = it_readreg(sc->sc_iot, sc->sc_ioh, IT_EC_MSB) << 8;
	sc->sc_ec_iobase |= it_readreg(sc->sc_iot, sc->sc_ioh, IT_EC_LSB);

	/* initialize watchdog timer */
	if (sc->sc_chipid != IT_ID_8705) {
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_LDN, IT_WDT_LDN);
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_CSR, 0x00);
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, 0x00);
		wdog_register(it_wdog_cb, sc);
	}

	/* exit MB PnP mode and unmap */
	it_exit(sc->sc_iot, sc->sc_ioh);

	LIST_INSERT_HEAD(&it_softc_list, sc, sc_list);
	printf(": IT%xF rev %X", sc->sc_chipid, sc->sc_chiprev);

	if (sc->sc_ec_iobase == 0) {
		printf(", EC disabled\n");
		return;
	}

	printf(", EC port 0x%x\n", sc->sc_ec_iobase);

	/* map environment controller i/o space */
	sc->sc_ec_iot = ia->ia_iot;
	if (bus_space_map(sc->sc_ec_iot, sc->sc_ec_iobase, 8, 0,
	    &sc->sc_ec_ioh) != 0) {
		printf("%s: can't map EC i/o space\n", sc->sc_dev.dv_xname);
		return;
	}

	/* initialize sensor structures */
	for (i = 0; i < IT_EC_NUMSENSORS; i++) {
		sc->sc_sensors[i].type = it_sensors[i].type;

		if (it_sensors[i].desc != NULL)
			strlcpy(sc->sc_sensors[i].desc, it_sensors[i].desc,
			    sizeof(sc->sc_sensors[i].desc));
	}

	/* register sensor update task */
	if (sensor_task_register(sc, it_ec_refresh, IT_EC_INTERVAL) == NULL) {
		printf("%s: unable to register update task\n",
		    sc->sc_dev.dv_xname);
		bus_space_unmap(sc->sc_ec_iot, sc->sc_ec_ioh, 8);
		return;
	}

	/* use 16-bit FAN tachometer registers for newer chips */
	if (sc->sc_chipid != IT_ID_8705 && sc->sc_chipid != IT_ID_8712)
		it_ec_writereg(sc, IT_EC_FAN_ECER,
		    it_ec_readreg(sc, IT_EC_FAN_ECER) | 0x07);

	/* activate monitoring */
	it_ec_writereg(sc, IT_EC_CFG,
	    it_ec_readreg(sc, IT_EC_CFG) | IT_EC_CFG_START | IT_EC_CFG_INTCLR);

	/* initialize sensors */
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));
	for (i = 0; i < IT_EC_NUMSENSORS; i++)
		sensor_attach(&sc->sc_sensordev, &sc->sc_sensors[i]);
	sensordev_install(&sc->sc_sensordev);
}

int
it_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_POWERDOWN:
		wdog_shutdown(self);
		break;
	}

	return (0);
}

u_int8_t
it_readreg(bus_space_tag_t iot, bus_space_handle_t ioh, int r)
{
	bus_space_write_1(iot, ioh, IT_IO_ADDR, r);
	return (bus_space_read_1(iot, ioh, IT_IO_DATA));
}

void
it_writereg(bus_space_tag_t iot, bus_space_handle_t ioh, int r, u_int8_t v)
{
	bus_space_write_1(iot, ioh, IT_IO_ADDR, r);
	bus_space_write_1(iot, ioh, IT_IO_DATA, v);
}

void
it_enter(bus_space_tag_t iot, bus_space_handle_t ioh, int iobase)
{
	bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x87);
	bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x01);
	bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x55);
	if (iobase == IO_IT1)
		bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x55);
	else
		bus_space_write_1(iot, ioh, IT_IO_ADDR, 0xaa);
}

void
it_exit(bus_space_tag_t iot, bus_space_handle_t ioh)
{
	bus_space_write_1(iot, ioh, IT_IO_ADDR, IT_CCR);
	bus_space_write_1(iot, ioh, IT_IO_DATA, 0x02);
}

u_int8_t
it_ec_readreg(struct it_softc *sc, int r)
{
	bus_space_write_1(sc->sc_ec_iot, sc->sc_ec_ioh, IT_EC_ADDR, r);
	return (bus_space_read_1(sc->sc_ec_iot, sc->sc_ec_ioh, IT_EC_DATA));
}

void
it_ec_writereg(struct it_softc *sc, int r, u_int8_t v)
{
	bus_space_write_1(sc->sc_ec_iot, sc->sc_ec_ioh, IT_EC_ADDR, r);
	bus_space_write_1(sc->sc_ec_iot, sc->sc_ec_ioh, IT_EC_DATA, v);
}

void
it_ec_refresh(void *arg)
{
	struct it_softc *sc = arg;
	int i, sdata, divisor, odivisor, ndivisor;
	u_int8_t cr, ecr;

	/* refresh temp sensors */
	cr = it_ec_readreg(sc, IT_EC_ADC_TEMPER);

	for (i = 0; i < IT_TEMP_COUNT; i++) {
		sc->sc_sensors[IT_TEMP_BASE + i].flags &=
		    SENSOR_FINVALID;

		if (!(cr & (1 << i)) && !(cr & (1 << (i + 3)))) {
			sc->sc_sensors[IT_TEMP_BASE + i].flags |=
			    SENSOR_FINVALID;
			continue;
		}

		sdata = it_ec_readreg(sc, IT_EC_TEMPBASE + i);
		/* convert to degF */
		sc->sc_sensors[IT_TEMP_BASE + i].value =
		    sdata * 1000000 + 273150000;
	}

	/* refresh volt sensors */
	cr = it_ec_readreg(sc, IT_EC_ADC_VINER);

	for (i = 0; i < IT_VOLT_COUNT; i++) {
		sc->sc_sensors[IT_VOLT_BASE + i].flags &=
		    SENSOR_FINVALID;

		if ((i < 8) && !(cr & (1 << i))) {
			sc->sc_sensors[IT_VOLT_BASE + i].flags |=
			    SENSOR_FINVALID;
			continue;
		}

		sdata = it_ec_readreg(sc, IT_EC_VOLTBASE + i);
		/* voltage returned as (mV >> 4) */
		sc->sc_sensors[IT_VOLT_BASE + i].value = sdata << 4;
		/* these two values are negative and formula is different */
		if (i == 5 || i == 6)
			sc->sc_sensors[IT_VOLT_BASE + i].value -= IT_EC_VREF;
		/* rfact is (factor * 10^4) */
		sc->sc_sensors[IT_VOLT_BASE + i].value *= it_vrfact[i];
		/* division by 10 gets us back to uVDC */
		sc->sc_sensors[IT_VOLT_BASE + i].value /= 10;
		if (i == 5 || i == 6)
			sc->sc_sensors[IT_VOLT_BASE + i].value +=
			    IT_EC_VREF * 1000;
	}

	/* refresh fan sensors */
	cr = it_ec_readreg(sc, IT_EC_FAN_MCR);

	if (sc->sc_chipid != IT_ID_8705 && sc->sc_chipid != IT_ID_8712) {
		/* use 16-bit FAN tachometer registers */
		ecr = it_ec_readreg(sc, IT_EC_FAN_ECER);

		for (i = 0; i < IT_FAN_COUNT; i++) {
			sc->sc_sensors[IT_FAN_BASE + i].flags &=
			    ~SENSOR_FINVALID;

			if (i < 3 && !(cr & (1 << (i + 4)))) {
				sc->sc_sensors[IT_FAN_BASE + i].flags |=
				    SENSOR_FINVALID;
				continue;
			} else if (i > 2 && !(ecr & (1 << (i + 1)))) {
				sc->sc_sensors[IT_FAN_BASE + i].flags |=
				    SENSOR_FINVALID;
				continue;
			}

			sdata = it_ec_readreg(sc, it_fan_regs[i]);
			sdata |= it_ec_readreg(sc, it_fan_ext_regs[i]) << 8;

			if (sdata == 0 || sdata == 0xffff)
				sc->sc_sensors[IT_FAN_BASE + i].value = 0;
			else
				sc->sc_sensors[IT_FAN_BASE + i].value =
				    675000 / sdata;
		}
	} else {
		/* use 8-bit FAN tachometer & FAN divisor registers */
		odivisor = ndivisor = divisor =
		    it_ec_readreg(sc, IT_EC_FAN_DIV);

		for (i = 0; i < IT_FAN_COUNT; i++) {
			if (i > 2 || !(cr & (1 << (i + 4)))) {
				sc->sc_sensors[IT_FAN_BASE + i].flags |=
				    SENSOR_FINVALID;
				continue;
			}

			sc->sc_sensors[IT_FAN_BASE + i].flags &=
			    ~SENSOR_FINVALID;

			sdata = it_ec_readreg(sc, it_fan_regs[i]);

			if (sdata == 0xff) {
				sc->sc_sensors[IT_FAN_BASE + i].value = 0;

				if (i == 2)
					ndivisor ^= 0x40;
				else {
					ndivisor &= ~(7 << (i * 3));
					ndivisor |= ((divisor + 1) & 7) <<
					    (i * 3);
				}
			} else if (sdata != 0) {
				if (i == 2)
					divisor = divisor & 1 ? 3 : 1;
				sc->sc_sensors[IT_FAN_BASE + i].value =
				    1350000 / (sdata << (divisor & 7));
			} else
				sc->sc_sensors[IT_FAN_BASE + i].value = 0;
		}

		if (ndivisor != odivisor)
			it_ec_writereg(sc, IT_EC_FAN_DIV, ndivisor);
	}
}

int
it_wdog_cb(void *arg, int period)
{
	struct it_softc *sc = arg;
	int minutes = 0;

	/* enter MB PnP mode and select WDT device */
	it_enter(sc->sc_iot, sc->sc_ioh, sc->sc_iobase);
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_LDN, IT_WDT_LDN);

	/* disable watchdog timer */
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, 0x00);

	/* 1000s should be enough for everyone */
	if (period > 1000)
		period = 1000;
	else if (period < 0)
		period = 0;

	if (period > 0) {
		/*
		 * Older IT8712F chips have 8-bit timeout counter.
		 * Use minutes for 16-bit values for these chips.
		 */
		if (sc->sc_chipid == IT_ID_8712 && sc->sc_chiprev < 0x8 &&
		    period > 0xff) {
			if (period % 60 >= 30)
				period += 60;
			period /= 60;
			minutes++;
		}

		/* set watchdog timeout (low byte) */
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TMO_LSB,
		    period & 0xff);

		if (minutes) {
			/* enable watchdog timer */
			it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR,
			    IT_WDT_TCR_KRST | IT_WDT_TCR_PWROK);

			period *= 60;
		} else {
			/* set watchdog timeout (high byte) */
			it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TMO_MSB,
			    period >> 8);

			/* enable watchdog timer */
			it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR,
			    IT_WDT_TCR_SECS | IT_WDT_TCR_KRST |
			    IT_WDT_TCR_PWROK);
		}
	}

	/* exit MB PnP mode */
	it_exit(sc->sc_iot, sc->sc_ioh);

	return (period);
}


struct cfattach it_ca = {
	sizeof(struct it_softc),
	it_match,
	it_attach,
	NULL,
	it_activate
};

struct cfdriver it_cd = {
	NULL, "it", DV_DULL
};
@


1.45
log
@Convert watchdog(4) devices to use autoconf(9) framework.

ok deraadt, tests on glxpcib and ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.44 2013/04/10 01:35:55 guenther Exp $	*/
a36 1
#include <dev/isa/isareg.h>
@


1.44
log
@Fix various glitches in queue macro usage.

ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.43 2013/03/21 18:20:00 brynet Exp $	*/
d51 1
d293 12
d541 3
a543 1
	it_attach
@


1.43
log
@Attach on ITE 8728.

it0 at isa0 port 0x2e/2: IT8728F rev 1, EC port 0x228

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.42 2012/12/14 13:17:29 mikeb Exp $	*/
d127 1
a127 1
LIST_HEAD(, it_softc) it_softc_list = LIST_HEAD_INITIALIZER(&it_softc_list);
@


1.42
log
@Support IT8772F; from form@@, ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.41 2012/10/17 22:32:01 deraadt Exp $	*/
d171 1
@


1.41
log
@Swap arguments to wdog_register() since it is nicer, and prepare
wdog_shutdown() for external usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.40 2011/01/20 16:59:55 form Exp $	*/
d171 1
@


1.40
log
@add IT8721 support
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.39 2009/01/16 06:58:32 form Exp $	*/
d232 1
a232 1
		wdog_register(sc, it_wdog_cb);
@


1.39
log
@add IT8720F support
thanks to Vit Skibinskiy <bucker(ik)skibinski.pp.ru>
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.38 2008/10/23 08:08:44 form Exp $	*/
d169 1
@


1.38
log
@Round up to the nearest minute 16-bit timeout values for older IT8712 chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.37 2008/10/22 05:38:17 form Exp $	*/
d168 1
@


1.37
log
@o add FAN4 and FAN5 sensors for IT8716/8718/8726
o always use 16-bit FAN counters for IT8716/8718/8726
o do not try to poll sensors disabled by BIOS
o sync VIN5 & VIN6 sensors description w/ ITE docs

tested by naddy@@ weerd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.36 2008/10/11 20:31:50 miod Exp $	*/
d486 2
@


1.36
log
@Fix various printf constructs either missing arguments or format specifiers.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.35 2008/10/08 17:32:47 form Exp $	*/
d74 2
a75 2
	int		type;
	const char	*desc;
d84 3
a86 1
#define IT_FAN_COUNT		3
d91 1
a91 1
#define IT_VOLT_BASE		6
d98 1
a99 1
	{ SENSOR_VOLTS_DC,	"-12V"		},
d111 1
a112 1
	RFACT(83, 20),		/* -12V		*/
d117 10
d237 1
a237 1
	printf(": IT%xF rev 0x%x", sc->sc_chipid, sc->sc_chiprev);
d271 5
d278 1
a278 1
	    it_ec_readreg(sc, IT_EC_CFG) | IT_EC_CFG_START | IT_EC_INT_CLEAR);
d339 2
a340 1
	int i, sdata, mode, divisor, odivisor, ndivisor;
d343 2
d346 9
d362 2
d365 9
d390 31
a420 1
	if (sc->sc_chipid == IT_ID_8705 || sc->sc_chipid == IT_ID_8712)
a422 4
	else {
		mode = it_ec_readreg(sc, IT_EC_FAN_ECR);
		divisor = -1;
	}
d424 2
a425 9
	for (i = 0; i < IT_FAN_COUNT; i++) {
		sc->sc_sensors[IT_FAN_BASE + i].flags &= ~SENSOR_FINVALID;
		sdata = it_ec_readreg(sc, IT_EC_FANBASE + i);

		if (divisor != -1) {
			/*
			 * Use 8-bit FAN Tachometer & FAN Divisor registers
			 */
			if (sdata == 0xff) {
d428 11
d453 1
d455 2
a456 18
			if (ndivisor != odivisor)
				it_ec_writereg(sc, IT_EC_FAN_DIV, ndivisor);
		} else {
			/*
			 * Use 16-bit FAN tachometer register
			 */
			if (mode & (1 << i))
				sdata |= it_ec_readreg(sc,
				    IT_EC_FANEXTBASE + i) << 8;
			if (sdata == ((mode & (1 << i)) ? 0xffff : 0xff))
				sc->sc_sensors[IT_FAN_BASE + i].flags |=
				    SENSOR_FINVALID;
			else if (sdata != 0)
				sc->sc_sensors[IT_FAN_BASE + i].value =
				    675000 / sdata;
			else
				sc->sc_sensors[IT_FAN_BASE + i].value = 0;
		}
@


1.35
log
@better comments
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.34 2008/10/08 17:17:39 form Exp $	*/
d253 1
a253 1
		printf(": unable to register update task\n",
@


1.34
log
@Older IT8712F chips have 8-bit watchdog timeout counter.
Use minutes for 16-bit values.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.33 2008/10/08 15:06:49 form Exp $	*/
d213 1
a213 1
	/* initialize watchdog */
d251 1
a251 1
	/* register update task */
d427 1
a427 1
		 * Use minutes for 16-bit values.
@


1.33
log
@o chip revision is 4-bit value
o some #define's instead of digits
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.32 2008/04/07 17:50:37 form Exp $	*/
d217 1
a217 2
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR,
		    IT_WDT_TCR_SECS);
d409 1
d415 2
a416 2
	/* disable watchdog timeout */
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, IT_WDT_TCR_SECS);
d424 32
a455 8
	/* set watchdog timeout */
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TMO_MSB, period >> 8);
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TMO_LSB, period & 0xff);

	if (period > 0)
		/* enable watchdog timeout */
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR,
		    IT_WDT_TCR_SECS | IT_WDT_TCR_KRST);
@


1.32
log
@snprintf "%s" -> strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.31 2008/04/07 17:37:58 form Exp $	*/
a191 1
	u_int8_t cr;
d206 1
a206 1
	sc->sc_chiprev = it_readreg(sc->sc_iot, sc->sc_ioh, IT_CHIPREV);
d226 1
a226 2

	printf(": IT%xF rev 0x%02x", sc->sc_chipid, sc->sc_chiprev);
d261 2
a262 2
	cr = it_ec_readreg(sc, IT_EC_CFG);
	it_ec_writereg(sc, IT_EC_CFG, cr | 0x09);
@


1.31
log
@fix snprintf usage
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.30 2008/04/07 09:43:54 form Exp $	*/
d250 2
a251 3
			snprintf(sc->sc_sensors[i].desc,
			    sizeof(sc->sc_sensors[i].desc), "%s",
			    it_sensors[i].desc); 
@


1.30
log
@more cosmetic changes
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.29 2008/04/07 09:31:30 form Exp $	*/
d251 1
a251 1
			    sizeof(sc->sc_sensors[i].desc),
@


1.29
log
@some cosmetic changes
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.28 2008/04/03 20:28:05 form Exp $	*/
d218 2
a219 1
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, 0x80);
d419 1
a419 1
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, 0x80);
d428 2
a429 2
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_MSB, period >> 8);
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_LSB, period & 0xff);
d433 2
a434 1
		it_writereg(sc->sc_iot, sc->sc_ioh, IT_WDT_TCR, 0xc0);
@


1.28
log
@Switch it(4) back to PnP config mode. Avoid possible
conflicts with SMSC or similar chips.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.27 2007/12/24 14:07:47 form Exp $	*/
d62 10
d102 1
a102 3
#define RFACT_NONE		10000
#define RFACT(x, y)		(RFACT_NONE * ((x) + (y)) / (y))

d104 9
a112 3
	RFACT_NONE, RFACT_NONE, RFACT_NONE, RFACT(68, 100), RFACT(30, 10),
	RFACT(21, 10), RFACT(83, 20),
	RFACT(68, 100), RFACT_NONE
@


1.27
log
@alwais unmap i/o space in it_match
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.26 2007/12/23 17:44:07 form Exp $	*/
d4 1
a4 1
 * Copyright (c) 2007 Oleg Safiullin <form@@pdp-11.org.ru>
d53 1
a53 1
void it_enter(bus_space_tag_t, bus_space_handle_t);
d101 1
a101 1
int it_found;
d108 1
d110 1
a110 1
	bus_addr_t iobase;
d113 1
a113 18
	if (it_found || ia->ipa_io[0].base == IOBASEUNK)
		return (0);

	/* map EC i/o space */
	if (bus_space_map(ia->ia_iot, ia->ipa_io[0].base, 8, 0, &ioh) != 0) {
		DPRINTF(("it_probe: can't map EC i/o space"));
		return (0);
	}

	/* get vendor id */
	bus_space_write_1(ia->ia_iot, ioh, IT_EC_ADDR, IT_EC_VENDID);
	cr = bus_space_read_1(ia->ia_iot, ioh, IT_EC_DATA);

	/* unmap EC i/o space */
	bus_space_unmap(ia->ia_iot, ioh, 8);

	/* check for ITE vendor ID */
	if (cr != IT_VEND_ITE)
d117 2
a118 2
	if (bus_space_map(ia->ia_iot, IO_IT, 2, 0, &ioh) != 0) {
		DPRINTF(("it_probe: can't map i/o space"));
d123 9
a131 1
	it_enter(ia->ia_iot, ioh);
a136 13
	/* get environment controller base address */
	it_writereg(ia->ia_iot, ioh, IT_LDN, IT_EC_LDN);
	iobase = it_readreg(ia->ia_iot, ioh, IT_EC_MSB) << 8;
	iobase |= it_readreg(ia->ia_iot, ioh, IT_EC_LSB);

	/* exit MB PnP mode and unmap */
	it_exit(ia->ia_iot, ioh);
	bus_space_unmap(ia->ia_iot, ioh, 2);

	/* check if EC i/o base address match */
	if (ia->ipa_io[0].base != iobase)
		return (0);

d143 17
a159 3
		ia->ipa_nio = 1;
		ia->ipa_io[0].length = 8;
		ia->ipa_nmem = ia->ipa_nirq = ia->ipa_ndrq = 0;
a160 2
	default:
		return (0);
d163 7
a169 1
	return (1);
d181 2
a182 1
	if (bus_space_map(sc->sc_iot, IO_IT, 2, 0, &sc->sc_ioh) != 0) {
a186 2
	it_found++;

d188 1
a188 1
	it_enter(sc->sc_iot, sc->sc_ioh);
d195 5
d211 10
a220 1
	printf(": IT%xF rev 0x%02x\n", sc->sc_chipid, sc->sc_chiprev);
d224 1
a224 1
	if (bus_space_map(sc->sc_ec_iot, ia->ipa_io[0].base, 8, 0,
d275 1
a275 1
it_enter(bus_space_tag_t iot, bus_space_handle_t ioh)
d280 4
a283 1
	bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x55);
d400 1
a400 1
	it_enter(sc->sc_iot, sc->sc_ioh);
@


1.26
log
@Look for environment controller first, and access ITE SuperIO address/data
ports only if we found one. Fixes possible issues with some notebook
chipsets.

ok deraadt@@
tested by me, jcs@@ and Rodolfo Gouveia
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.25 2007/12/20 12:02:14 form Exp $	*/
d121 1
a121 1
	/* check for ITE vendor ID */
d123 1
a123 2
	if (bus_space_read_1(ia->ia_iot, ioh, IT_EC_DATA) != IT_VEND_ITE)
		return (0);
d127 4
@


1.25
log
@add original copyright
bad me
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.24 2007/12/18 21:17:54 form Exp $	*/
a48 1
int it_probe(struct isa_attach_args *, bus_addr_t);
d53 1
a53 1
void it_enter(bus_space_tag_t, bus_space_handle_t, int);
d105 1
a105 1
it_probe(struct isa_attach_args *ia, bus_addr_t iobase)
d107 1
d109 1
d112 17
d130 1
a130 1
	if (bus_space_map(ia->ia_iot, iobase, 2, 0, &ioh) != 0) {
d136 1
a136 1
	it_enter(ia->ia_iot, ioh, iobase);
d142 5
d151 4
a160 1
		ia->ipa_io[0].base = iobase;
d162 1
a162 1
		ia->ipa_io[0].length = 2;
a171 17
int
it_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;

	if (!it_found) {
		if (ia->ipa_io[0].base == IOBASEUNK) {
			if (it_probe(ia, IO_IT1) || it_probe(ia, IO_IT2))
				return (1);
		} else if (ia->ipa_io[0].base == IO_IT1 ||
			    ia->ipa_io[0].base == IO_IT2)
			return (it_probe(ia, ia->ipa_io[0].base));
	}

	return (0);
}

d177 1
a177 1
	int i, iobase;
d181 1
a181 2
	sc->sc_iobase = ia->ipa_io[0].base;
	if (bus_space_map(sc->sc_iot, sc->sc_iobase, 2, 0, &sc->sc_ioh) != 0) {
d189 1
a189 1
	it_enter(sc->sc_iot, sc->sc_ioh, sc->sc_iobase);
a195 5
	/* get environment controller base address */
	it_writereg(sc->sc_iot, sc->sc_ioh, IT_LDN, IT_EC_LDN);
	iobase = it_readreg(sc->sc_iot, sc->sc_ioh, IT_EC_MSB) << 8;
	iobase |= it_readreg(sc->sc_iot, sc->sc_ioh, IT_EC_LSB);

d207 1
a207 8
	printf(": IT%xF rev 0x%02x", sc->sc_chipid, sc->sc_chiprev);

	if (iobase == 0) {
		printf(", EC disabled\n");
		return;
	}

	printf(", EC port 0x%x\n", iobase);
d211 2
a212 1
	if (bus_space_map(sc->sc_ec_iot, iobase, 8, 0, &sc->sc_ec_ioh) != 0) {
d262 1
a262 1
it_enter(bus_space_tag_t iot, bus_space_handle_t ioh, int iobase)
d267 1
a267 4
	if (iobase == IO_IT1)
		bus_space_write_1(iot, ioh, IT_IO_ADDR, 0x55);
	else
		bus_space_write_1(iot, ioh, IT_IO_ADDR, 0xaa);
d384 1
a384 1
	it_enter(sc->sc_iot, sc->sc_ioh, sc->sc_iobase);
@


1.24
log
@New it(4) driver.
Supports ITE IT8705/8712/8716/8718/8726 and SiS SiS950
hardware monitors and ITE IT8712F/8716F/8718F/8726F watchdog timer.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.23 2007/06/24 05:34:35 dlg Exp $	*/
d5 2
@


1.23
log
@rework sensor tasks to use the kernels generic workq rather than a special
kernel thread of its own. the api has changed (which will be fixed in the
manpage shortly) so all the users of sensor tasks that i can find have
been fixed too.

noone tested, so its going in to force people to run with it.
"put it in" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.22 2007/03/22 16:55:31 deraadt Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003 Julien Bordet <zejames@@greyhats.org>
a30 1
#include <sys/kernel.h>
d32 1
d37 1
a38 1
#include <dev/isa/itvar.h>
a45 9
/*
 * IT87-compatible chips can typically measure voltages up to 4.096 V.
 * To measure higher voltages the input is attenuated with (external)
 * resistors.  Negative voltages are measured using a reference
 * voltage.  So we have to convert the sensor values back to real
 * voltages by applying the appropriate resistor factor.
 */
#define RFACT_NONE	10000
#define RFACT(x, y)	(RFACT_NONE * ((x) + (y)) / (y))
d47 2
a48 1
int  it_match(struct device *, void *, void *);
d50 40
a89 9
u_int8_t it_readreg(struct it_softc *, int);
void it_writereg(struct it_softc *, int, int);
void it_setup_volt(struct it_softc *, int, int);
void it_setup_temp(struct it_softc *, int, int);
void it_setup_fan(struct it_softc *, int, int);

void it_generic_stemp(struct it_softc *, struct ksensor *);
void it_generic_svolt(struct it_softc *, struct ksensor *);
void it_generic_fanrpm(struct it_softc *, struct ksensor *);
d91 2
a92 2
void it_refresh_sensor_data(struct it_softc *);
void it_refresh(void *);
d94 4
a97 4
struct cfattach it_ca = {
	sizeof(struct it_softc),
	it_match,
	it_attach
d100 1
a100 3
struct cfdriver it_cd = {
	NULL, "it", DV_DULL
};
a101 11
const int it_vrfact[] = {
	RFACT_NONE,
	RFACT_NONE,
	RFACT_NONE,
	RFACT(68, 100),
	RFACT(30, 10),
	RFACT(21, 10),
	RFACT(83, 20),
	RFACT(68, 100),
	RFACT_NONE
};
d104 1
a104 1
it_match(struct device *parent, void *match, void *aux)
a105 1
	bus_space_tag_t iot;
d107 7
a113 3
	struct isa_attach_args *ia = aux;
	int iobase;
	u_int8_t cr;
d115 2
a116 2
	iot = ia->ia_iot;
	iobase = ia->ipa_io[0].base;
d118 20
a137 2
	if (bus_space_map(iot, iobase, 8, 0, &ioh)) {
		DPRINTF(("it: can't map i/o space\n"));
d141 7
a147 7
	/* Check Vendor ID */
	bus_space_write_1(iot, ioh, ITC_ADDR, ITD_CHIPID);
	cr = bus_space_read_1(iot, ioh, ITC_DATA);
	bus_space_unmap(iot, ioh, 8);
	DPRINTF(("it: vendor id 0x%x\n", cr));
	if (cr != IT_ID_IT87)
		return (0);
d149 8
a156 5
	ia->ipa_nio = 1;
	ia->ipa_io[0].length = 8;
	ia->ipa_nmem = 0;
	ia->ipa_nirq = 0;
	ia->ipa_ndrq = 0;
d158 1
a158 1
	return (1);
a164 2
	int iobase;
	bus_space_tag_t iot;
d166 1
a166 1
	int i;
d169 3
a171 4
	iobase = ia->ipa_io[0].base;
	iot = sc->it_iot = ia->ia_iot;

	if (bus_space_map(iot, iobase, 8, 0, &sc->it_ioh)) {
d176 31
a206 5
	i = it_readreg(sc, ITD_CHIPID);
	switch (i) {
		case IT_ID_IT87:
			printf(": IT87\n");
			break;
d209 1
a209 1
	sc->numsensors = IT_NUM_SENSORS;
d211 6
a216 3
	it_setup_fan(sc, 0, 3);
	it_setup_volt(sc, 3, 9);
	it_setup_temp(sc, 12, 3);
d218 13
a230 2
	if (sensor_task_register(sc, it_refresh, 5) == NULL) {
		printf("%s: unable to register update task\n",
d232 1
d236 10
a245 11
	/* Activate monitoring */
	cr = it_readreg(sc, ITD_CONFIG);
	cr |= 0x01 | 0x08;
	it_writereg(sc, ITD_CONFIG, cr);

	/* Initialize sensors */
	strlcpy(sc->sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sensordev.xname));
	for (i = 0; i < sc->numsensors; ++i)
		sensor_attach(&sc->sensordev, &sc->sensors[i]);
	sensordev_install(&sc->sensordev);
d249 1
a249 1
it_readreg(struct it_softc *sc, int reg)
d251 2
a252 2
	bus_space_write_1(sc->it_iot, sc->it_ioh, ITC_ADDR, reg);
	return (bus_space_read_1(sc->it_iot, sc->it_ioh, ITC_DATA));
d256 1
a256 1
it_writereg(struct it_softc *sc, int reg, int val)
d258 2
a259 2
	bus_space_write_1(sc->it_iot, sc->it_ioh, ITC_ADDR, reg);
	bus_space_write_1(sc->it_iot, sc->it_ioh, ITC_DATA, val);
d263 1
a263 1
it_setup_volt(struct it_softc *sc, int start, int n)
d265 7
a271 24
	int i;

	for (i = 0; i < n; ++i) {
		sc->sensors[start + i].type = SENSOR_VOLTS_DC;
	}

	snprintf(sc->sensors[start + 0].desc, sizeof(sc->sensors[0].desc),
	    "VCORE_A");
	snprintf(sc->sensors[start + 1].desc, sizeof(sc->sensors[1].desc),
	    "VCORE_B");
	snprintf(sc->sensors[start + 2].desc, sizeof(sc->sensors[2].desc),
	    "+3.3V");
	snprintf(sc->sensors[start + 3].desc, sizeof(sc->sensors[3].desc),
	    "+5V");
	snprintf(sc->sensors[start + 4].desc, sizeof(sc->sensors[4].desc),
	    "+12V");
	snprintf(sc->sensors[start + 5].desc, sizeof(sc->sensors[5].desc),
	    "Unused");
	snprintf(sc->sensors[start + 6].desc, sizeof(sc->sensors[6].desc),
	    "-12V");
	snprintf(sc->sensors[start + 7].desc, sizeof(sc->sensors[7].desc),
	    "+5VSB");
	snprintf(sc->sensors[start + 8].desc, sizeof(sc->sensors[8].desc),
	    "VBAT");
d275 1
a275 1
it_setup_temp(struct it_softc *sc, int start, int n)
d277 3
a279 1
	int i;
d281 5
a285 2
	for (i = 0; i < n; ++i)
		sc->sensors[start + i].type = SENSOR_TEMP;
d289 1
a289 1
it_setup_fan(struct it_softc *sc, int start, int n)
d291 2
a292 4
	int i;

	for (i = 0; i < n; ++i)
		sc->sensors[start + i].type = SENSOR_FANRPM;
d296 1
a296 1
it_generic_stemp(struct it_softc *sc, struct ksensor *sensors)
d298 2
a299 1
	int i, sdata;
d301 6
a306 4
	for (i = 0; i < 3; i++) {
		sdata = it_readreg(sc, ITD_SENSORTEMPBASE + i);
		/* Convert temperature to Fahrenheit degres */
		sensors[i].value = sdata * 1000000 + 273150000;
a307 6
}

void
it_generic_svolt(struct it_softc *sc, struct ksensor *sensors)
{
	int i, sdata;
d309 3
a311 3
	for (i = 0; i < 9; i++) {
		sdata = it_readreg(sc, ITD_SENSORVOLTBASE + i);
		DPRINTF(("sdata[volt%d] 0x%x\n", i, sdata));
d313 1
a313 1
		sensors[i].value = (sdata << 4);
d316 1
a316 1
			sensors[i].value = ((sdata << 4) - IT_VREF);
d318 1
a318 1
		sensors[i].value *= it_vrfact[i];
d320 1
a320 1
		sensors[i].value /= 10;
d322 11
a332 1
			sensors[i].value += IT_VREF * 1000;
a333 1
}
d335 25
a359 4
void
it_generic_fanrpm(struct it_softc *sc, struct ksensor *sensors)
{
	int i, sdata, divisor, odivisor, ndivisor;
d361 2
a362 13
	odivisor = ndivisor = divisor = it_readreg(sc, ITD_FAN);
	for (i = 0; i < 3; i++, divisor >>= 3) {
		sensors[i].flags &= ~SENSOR_FINVALID;
		if ((sdata = it_readreg(sc, ITD_SENSORFANBASE + i)) == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
			if (i == 2)
				ndivisor ^= 0x40;
			else {
				ndivisor &= ~(7 << (i * 3));
				ndivisor |= ((divisor + 1) & 7) << (i * 3);
			}
		} else if (sdata == 0) {
			sensors[i].value = 0;
d364 14
a377 3
			if (i == 2)
				divisor = divisor & 1 ? 3 : 1;
			sensors[i].value = 1350000 / (sdata << (divisor & 7));
a379 2
	if (ndivisor != odivisor)
		it_writereg(sc, ITD_FAN, ndivisor);
d382 2
a383 6
/*
 * pre:  last read occurred >= 1.5 seconds ago
 * post: sensors[] current data are the latest from the chip
 */
void
it_refresh_sensor_data(struct it_softc *sc)
d385 27
a411 4
	/* Refresh our stored data for every sensor */
	it_generic_stemp(sc, &sc->sensors[12]);
	it_generic_svolt(sc, &sc->sensors[3]);
	it_generic_fanrpm(sc, &sc->sensors[0]);
a413 4
void
it_refresh(void *arg)
{
	struct it_softc *sc = (struct it_softc *)arg;
d415 9
a423 2
	it_refresh_sensor_data(sc);
}
@


1.22
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.21 2006/12/23 17:46:39 deraadt Exp $	*/
d158 1
a158 1
	if (sensor_task_register(sc, it_refresh, 5)) {
@


1.21
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.20 2006/06/24 13:42:45 kettenis Exp $	*/
d64 3
a66 3
void it_generic_stemp(struct it_softc *, struct sensor *);
void it_generic_svolt(struct it_softc *, struct sensor *);
void it_generic_fanrpm(struct it_softc *, struct sensor *);
d239 1
a239 1
it_generic_stemp(struct it_softc *sc, struct sensor *sensors)
d251 1
a251 1
it_generic_svolt(struct it_softc *sc, struct sensor *sensors)
d273 1
a273 1
it_generic_fanrpm(struct it_softc *sc, struct sensor *sensors)
@


1.20
log
@Add abstraction for resistor factors and avoid using the rfact member of
'struct sensor' which is on its way out.
tested by & ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.19 2006/04/10 00:57:54 deraadt Exp $	*/
d170 5
a174 5
	for (i = 0; i < sc->numsensors; ++i) {
		strlcpy(sc->sensors[i].device, sc->sc_dev.dv_xname,
		    sizeof(sc->sensors[i].device));
		sensor_add(&sc->sensors[i]);
	}
d225 1
a225 1
	for (i = 0; i < n; ++i) {
a226 4
		snprintf(sc->sensors[start + i].desc,
		    sizeof(sc->sensors[start + i].desc),
		    "Temp %d", i + 1);
	}
d234 1
a234 1
	for (i = 0; i < n; ++i) {
a235 4
		snprintf(sc->sensors[start + i].desc,
		    sizeof(sc->sensors[start + i].desc),
		    "Fan%d", i + 1);
	}
@


1.19
log
@unify temperature sensor names much more
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.18 2006/01/23 18:43:22 kettenis Exp $	*/
d46 10
d81 12
a199 1
	sc->sensors[start + 0].rfact = 10000;
a201 1
	sc->sensors[start + 1].rfact = 10000;
a203 1
	sc->sensors[start + 2].rfact = 10000;
a205 1
	sc->sensors[start + 3].rfact = (int)(( 16.8 / 10) * 10000);
a207 1
	sc->sensors[start + 4].rfact = (int)(( 40 / 10) * 10000);
a209 1
	sc->sensors[start + 5].rfact = (int)(( 31.0 / 10) * 10000);
a211 1
	sc->sensors[start + 6].rfact = (int)(( 103.0 / 20) * 10000);
a213 1
	sc->sensors[start + 7].rfact = (int)(( 16.8 / 10) * 10000);
a215 1
	sc->sensors[start + 8].rfact = 10000;
d268 3
d272 1
a272 8
		sensors[i].value *= sensors[i].rfact;
		/* these two values are negative and formula is different */
		if (i == 5)
			sensors[i].value -=
			    (int) (21.0 / 10 * IT_VREF * 10000);
		if (i == 6)
			sensors[i].value -=
			    (int) (83.0 / 20 * IT_VREF * 10000);
d275 2
a276 1

@


1.18
log
@Do not enable disabled sensors.
ok grange@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.17 2006/01/19 17:08:40 grange Exp $	*/
d216 1
a216 1
		    "Temp%d", i + 1);
@


1.17
log
@Replace SENSOR_ADD() macro with a pair of functions
sensor_add()/sensor_del() so that sensors can be attached
and detached dynamicaly.

ok kettenis@@ deraadt@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.16 2005/12/28 15:27:44 grange Exp $	*/
a204 3

	/* Enable voltage monitoring */
	it_writereg(sc, ITD_VOLTENABLE, 0xff);
a217 5

	/* Enable temperature monitoring
	 * bits 7 and 8 are reserved, so we don't change them */
	i = it_readreg(sc, ITD_TEMPENABLE) & 0xc0;
	it_writereg(sc, ITD_TEMPENABLE, i | 0x38);
a230 5

	/* Enable fan rpm monitoring
	 * bits 4 to 6 are the only interesting bits */
	i = it_readreg(sc, ITD_FANENABLE) & 0x8f;
	it_writereg(sc, ITD_FANENABLE, i | 0x70);
@


1.16
log
@Convert for sensor_task_register();
diff from Mike Belopuhov <mkb@@crypt.org.ru>.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.15 2005/07/26 19:08:09 grange Exp $	*/
d151 1
a151 1
		SENSOR_ADD(&sc->sensors[i]);
@


1.15
log
@Fan tachometers improvements from form@@pdp-11.org.ru:
- correct rpm calculation
- automatic devisor tuning
- correct handling of fan being stopped and started again

Thanks jsg@@ for testing.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.14 2005/04/29 17:13:54 grange Exp $	*/
a32 1
#include <sys/timeout.h>
a70 2
struct timeout it_timeout;

d136 6
a152 3

	timeout_set(&it_timeout, it_refresh, sc);
	timeout_add(&it_timeout, (15 * hz) / 10);
a329 1
	timeout_add(&it_timeout, (15 * hz) / 10);
@


1.14
log
@Correct FAN3 divisor for IT8705 and add support for FAN3 divisor on IT8712.
Diff from Stephan Leemburg <sleemburg@@jvc.nl>.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.13 2005/04/09 14:42:33 grange Exp $	*/
d286 1
a286 1
	int i, sdata, divisor;
d288 4
a291 16
	divisor = it_readreg(sc, ITD_FAN);
	for (i = 0; i < 3; i++) {
		sdata = it_readreg(sc, ITD_SENSORFANBASE + i);
		switch (i) {
			case 2:
				divisor = (divisor & 0x40) ? 3 : 1;
				break;
			case 1:
				divisor = (divisor >> 3) & 0x7;
				break;
			case 0:
				divisor = divisor & 0x7;
				break;
		}

		if (sdata == 0xff) {
d293 6
d302 3
a304 1
			sensors[i].value = 1350000 / (sdata << divisor);
d307 2
@


1.13
log
@Use vendor id register for chip matching instead of configuration
register patterns. From Stephan Leemburg <sleemburg@@jvc.nl>.

Tested by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.12 2005/03/02 21:34:58 grange Exp $	*/
d288 1
d293 1
a293 1
				divisor = 2;
d296 1
a296 1
				divisor = (it_readreg(sc, ITD_FAN) >> 3) & 0x7;
d298 2
a299 2
			default:
				divisor = it_readreg(sc, ITD_FAN) & 0x7;
@


1.12
log
@Spaces.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.11 2004/10/05 18:36:04 grange Exp $	*/
a80 1
	int rv;
d87 1
a87 1
		DPRINTF(("%s: can't map i/o space\n", __func__));
d91 2
a92 2
	/* Check for some power-on defaults */
	bus_space_write_1(iot, ioh, ITC_ADDR, ITD_CONFIG);
a93 9

	/* The monitoring may have been enabled by BIOS */
	if (cr == 0x11 || cr == 0x13 || cr == 0x18 || cr == 0x19)
		rv = 1;
	else
		rv = 0;

	DPRINTF(("it: rv = %d, cr = %x\n", rv, cr));

d95 3
d99 5
a103 8
	if (rv) {
		ia->ipa_nio = 1;
		ia->ipa_io[0].length = 8;

		ia->ipa_nmem = 0;
		ia->ipa_nirq = 0;
		ia->ipa_ndrq = 0;
	}
d105 1
a105 1
	return (rv);
a129 3
			break;
		default:
			printf(": unknown chip (ID %d)\n", i);
@


1.11
log
@Don't reset the chip on attach. This solves the problem with fans
starting to spin very fast after it0 is attached. Extracted from the
diff provided by Stephan Leemburg via millert@@.

Test and ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.10 2004/08/23 18:06:02 millert Exp $	*/
d128 1
a128 1
        iobase = ia->ipa_io[0].base;
d192 1
a192 1
	snprintf(sc->sensors[start + 0].desc, sizeof(sc->sensors[0].desc), 
d195 1
a195 1
	snprintf(sc->sensors[start + 1].desc, sizeof(sc->sensors[1].desc), 
d198 1
a198 1
	snprintf(sc->sensors[start + 2].desc, sizeof(sc->sensors[2].desc), 
d201 1
a201 1
	snprintf(sc->sensors[start + 3].desc, sizeof(sc->sensors[3].desc), 
d204 1
a204 1
	snprintf(sc->sensors[start + 4].desc, sizeof(sc->sensors[4].desc), 
d207 1
a207 1
	snprintf(sc->sensors[start + 5].desc, sizeof(sc->sensors[5].desc), 
d210 1
a210 1
	snprintf(sc->sensors[start + 6].desc, sizeof(sc->sensors[6].desc), 
d213 1
a213 1
	snprintf(sc->sensors[start + 7].desc, sizeof(sc->sensors[7].desc), 
d216 1
a216 1
	snprintf(sc->sensors[start + 8].desc, sizeof(sc->sensors[8].desc), 
d230 1
a230 1
		snprintf(sc->sensors[start + i].desc, 
d235 1
a235 1
	/* Enable temperature monitoring 
d248 1
a248 1
		snprintf(sc->sensors[start + i].desc, 
d284 2
a285 2
		if (i == 5) 
			sensors[i].value -= 
d287 2
a288 2
		if (i == 6) 
			sensors[i].value -= 
@


1.10
log
@The IT87 chip has 3 Fan sensors.  Fix the loop invariant and add
a missing break statement.  From Stephan Leemburg.  OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.9 2004/08/17 21:59:15 mickey Exp $	*/
a146 3

	/* Reset chip */
	it_writereg(sc, ITD_CONFIG, 0x80);
@


1.9
log
@don't forget to set rv to zero on false match
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.8 2004/02/10 20:01:40 grange Exp $	*/
d304 1
a304 1
	for (i = 0; i < 2; i++) {
d309 1
d311 1
a311 2
				divisor = (it_readreg(sc, 
				    ITD_FAN) >> 3) & 0x7;
@


1.8
log
@Use SENSOR_FINVALID.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.7 2004/02/02 20:14:26 grange Exp $	*/
d99 2
@


1.7
log
@Yet another signature; reported by danh@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.6 2004/01/28 20:02:27 grange Exp $	*/
d316 3
a318 1
		if (sdata == 0xff || sdata == 0) {
@


1.6
log
@Add new probe signature. From Alexey E. Suslikov <cruel@@texnika.com.ua>.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.5 2004/01/12 14:10:53 grange Exp $	*/
d97 1
a97 1
	if (cr == 0x11 || cr == 0x18 || cr == 0x19)
@


1.5
log
@Move sensors externs to sys/sensors.h and introduce a macro
SENSOR_ADD to hide all operations with these externs.

ok markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.4 2003/11/05 20:57:10 grange Exp $	*/
d97 1
a97 1
	if (cr == 0x18 || cr == 0x19)
@


1.4
log
@Correct author's email address per his request.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.3 2003/10/19 17:29:41 grange Exp $	*/
a124 2
	extern int nsensors;
	extern struct sensors_head sensors;
d162 1
a162 2
		sc->sensors[i].num = nsensors++;
		SLIST_INSERT_HEAD(&sensors, &sc->sensors[i], list);
@


1.3
log
@Don't check for valid nio since pnp is not used; similar to lm(4).
This makes it(4) work on recent ASUS boards. Tested by me and henning@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.2 2003/05/28 19:21:11 grange Exp $	*/
d4 1
a4 1
 * Copyright (c) 2003 Julien Bordet <zejames@@greygats.org>
@


1.2
log
@Print some debug info on match routine failure
@
text
@d1 1
a1 1
/*	$OpenBSD: it.c,v 1.1 2003/05/20 20:26:27 grange Exp $	*/
a82 6

	/* Must supply an address */
	if (ia->ipa_nio < 1) {
		DPRINTF(("%s: ipa_nio=%d\n", __func__, ia->ipa_nio));
		return (0);
	}
@


1.2.2.1
log
@add file to SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.2.2.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d4 1
a4 1
 * Copyright (c) 2003 Julien Bordet <zejames@@greyhats.org>
d84 6
d103 1
a103 1
	if (cr == 0x11 || cr == 0x13 || cr == 0x18 || cr == 0x19)
d131 2
d170 2
a171 1
		SENSOR_ADD(&sc->sensors[i]);
@


1.2.2.3
log
@Merge with the trunk
@
text
@d316 1
a316 3
		if (sdata == 0xff) {
			sensors[i].flags |= SENSOR_FINVALID;
		} else if (sdata == 0) {
@


1.1
log
@it(4) driver provides support for ITE IT8705F, IT8712F and SiS SiS950
hardware monitoring chips to be used with hw.sensors sysctl interface.
Work by Julien Bordet <zejames@@greyhats.org> with my little help.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d85 2
a86 1
	if (ia->ipa_nio < 1)
d88 1
d93 2
a94 1
	if (bus_space_map(iot, iobase, 8, 0, &ioh))
d96 1
@

