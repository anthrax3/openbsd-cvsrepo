head	1.20;
access;
symbols
	OPENBSD_6_2:1.20.0.10
	OPENBSD_6_2_BASE:1.20
	OPENBSD_6_1:1.20.0.12
	OPENBSD_6_1_BASE:1.20
	OPENBSD_6_0:1.20.0.8
	OPENBSD_6_0_BASE:1.20
	OPENBSD_5_9:1.20.0.2
	OPENBSD_5_9_BASE:1.20
	OPENBSD_5_8:1.20.0.6
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.20.0.4
	OPENBSD_5_7_BASE:1.20
	OPENBSD_5_6:1.19.0.6
	OPENBSD_5_6_BASE:1.19
	OPENBSD_5_5:1.19.0.4
	OPENBSD_5_5_BASE:1.19
	OPENBSD_5_4:1.18.0.26
	OPENBSD_5_4_BASE:1.18
	OPENBSD_5_3:1.18.0.24
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.22
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.20
	OPENBSD_5_0:1.18.0.18
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.16
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.18.0.14
	OPENBSD_4_8_BASE:1.18
	OPENBSD_4_7:1.18.0.10
	OPENBSD_4_7_BASE:1.18
	OPENBSD_4_6:1.18.0.12
	OPENBSD_4_6_BASE:1.18
	OPENBSD_4_5:1.18.0.8
	OPENBSD_4_5_BASE:1.18
	OPENBSD_4_4:1.18.0.6
	OPENBSD_4_4_BASE:1.18
	OPENBSD_4_3:1.18.0.4
	OPENBSD_4_3_BASE:1.18
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.17.0.14
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.12
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.17.0.10
	OPENBSD_3_9_BASE:1.17
	OPENBSD_3_8:1.17.0.8
	OPENBSD_3_8_BASE:1.17
	OPENBSD_3_7:1.17.0.6
	OPENBSD_3_7_BASE:1.17
	OPENBSD_3_6:1.17.0.4
	OPENBSD_3_6_BASE:1.17
	SMP_SYNC_A:1.17
	SMP_SYNC_B:1.17
	OPENBSD_3_5:1.17.0.2
	OPENBSD_3_5_BASE:1.17
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.15.0.8
	OPENBSD_3_3_BASE:1.15
	OPENBSD_3_2:1.15.0.6
	OPENBSD_3_2_BASE:1.15
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.15
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.16
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.14
	OPENBSD_2_8:1.14.0.12
	OPENBSD_2_8_BASE:1.14
	OPENBSD_2_7:1.14.0.10
	OPENBSD_2_7_BASE:1.14
	SMP:1.14.0.8
	SMP_BASE:1.14
	kame_19991208:1.14
	OPENBSD_2_6:1.14.0.6
	OPENBSD_2_6_BASE:1.14
	OPENBSD_2_5:1.14.0.4
	OPENBSD_2_5_BASE:1.14
	OPENBSD_2_4:1.14.0.2
	OPENBSD_2_4_BASE:1.14
	OPENBSD_2_3:1.13.0.2
	OPENBSD_2_3_BASE:1.13
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.20
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.19;
commitid	yM2VFFhpDTeFQlve;

1.19
date	2013.09.24.20.11.00;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.17.21.20.47;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2004.01.09.21.32.24;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.02.23.28.02;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.11.06.19.53.19;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	98.09.16.22.41.20;	author jason;	state Exp;
branches
	1.14.8.1;
next	1.13;

1.13
date	97.12.26.23.44.20;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	97.12.26.08.07.32;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	96.09.12.23.11.11;	author deraadt;	state dead;
branches;
next	1.10;

1.10
date	96.05.10.12.41.21;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.02.13.51.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.04.21.22.24.09;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	96.03.20.01.00.54;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	96.03.19.21.10.22;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.08.16.43.05;	author niklas;	state Exp;
branches;
next	1.4;

1.4
date	96.02.20.04.35.59;	author tholo;	state Exp;
branches;
next	1.3;

1.3
date	95.12.27.22.06.28;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	95.12.15.02.36.27;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.36;	author deraadt;	state Exp;
branches;
next	;

1.14.8.1
date	2001.11.13.21.10.01;	author niklas;	state Exp;
branches;
next	1.14.8.2;

1.14.8.2
date	2003.06.07.11.02.29;	author ho;	state Exp;
branches;
next	1.14.8.3;

1.14.8.3
date	2004.02.19.10.56.22;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.20
log
@unifdef INET
@
text
@/*	$OpenBSD: if_le.c,v 1.19 2013/09/24 20:11:00 miod Exp $	*/
/*	$NetBSD: if_le_isa.c,v 1.2 1996/05/12 23:52:56 mycroft Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"
#include "isadma.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <machine/cpu.h>
#include <machine/intr.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>

#include <dev/ic/lancereg.h>
#include <dev/ic/lancevar.h>
#include <dev/ic/am7990reg.h>
#include <dev/ic/am7990var.h>

#include <dev/isa/if_levar.h>

void
le_isa_wrcsr(struct lance_softc *sc, uint16_t port, uint16_t val)
{
	struct le_softc *lesc = (struct le_softc *)sc;
	bus_space_tag_t iot = lesc->sc_iot;
	bus_space_handle_t ioh = lesc->sc_ioh;

	bus_space_write_2(iot, ioh, lesc->sc_rap, port);
	bus_space_write_2(iot, ioh, lesc->sc_rdp, val);
}

uint16_t
le_isa_rdcsr(struct lance_softc *sc, uint16_t port)
{
	struct le_softc *lesc = (struct le_softc *)sc;
	bus_space_tag_t iot = lesc->sc_iot;
	bus_space_handle_t ioh = lesc->sc_ioh;
	uint16_t val;

	bus_space_write_2(iot, ioh, lesc->sc_rap, port);
	val = bus_space_read_2(iot, ioh, lesc->sc_rdp);
	return (val);
}


/*
 * Controller interrupt.
 */
int
le_isa_intredge(void *arg)
{

	if (am7990_intr(arg) == 0)
		return (0);
	for (;;)
		if (am7990_intr(arg) == 0)
			return (1);
}
@


1.19
log
@Sync the MI LANCE code ( le(4) ) with NetBSD, except for the following:
- the am7990_get() - now lance_get() - is unchanged.
- the interrupt acknowledge logic is unchanged, and will disable interrupts,
  then acknowledge all interrupt conditions.

Add ILACC (79900) support (from NetBSD).

Both LANCE (am7990.c) and ILACC (am79900.c) code share as much common code
(lance.c) as possible. This affects all le(4) attachments, but the changes
are mostly mechanical, to split am7990-specific parts from lance-agnostic
parts.

Compile tested on all affected platforms. Tested on alpha, hp300, luna88k,
mvme88k, sparc, sparc64 and vax.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.18 2007/06/17 21:20:47 jasper Exp $	*/
a51 1
#ifdef INET
a53 1
#endif
@


1.18
log
@ansify/de-register

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.17 2004/01/09 21:32:24 brad Exp $	*/
d64 2
d72 1
a72 1
le_isa_wrcsr(struct am7990_softc *sc, u_int16_t port, u_int16_t val)
d82 2
a83 2
u_int16_t
le_isa_rdcsr(struct am7990_softc *sc, u_int16_t port)
d88 1
a88 1
	u_int16_t val;
@


1.17
log
@remove uvm_extern.h

tested on alpha, i386, powerpc, sparc64, m68k.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.16 2003/06/02 23:28:02 millert Exp $	*/
d70 1
a70 3
le_isa_wrcsr(sc, port, val)
	struct am7990_softc *sc;
	u_int16_t port, val;
d81 1
a81 3
le_isa_rdcsr(sc, port)
	struct am7990_softc *sc;
	u_int16_t port;
d98 1
a98 2
le_isa_intredge(arg)
	void *arg;
@


1.16
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.15 2001/11/06 19:53:19 miod Exp $	*/
a55 2

#include <uvm/uvm_extern.h>
@


1.15
log
@Replace inclusion of <vm/foo.h> with the correct <uvm/bar.h> when necessary.
(Look ma, I might have broken the tree)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14 1998/09/16 22:41:20 jason Exp $	*/
d20 1
a20 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.14
log
@o if_media'fied am7990
o if_media'fied sun4m le.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.13 1997/12/26 23:44:20 deraadt Exp $	*/
d61 1
a61 1
#include <vm/vm.h>
@


1.14.8.1
log
@Merge in -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d61 1
a61 1
#include <uvm/uvm_extern.h>
@


1.14.8.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.14.8.1 2001/11/13 21:10:01 niklas Exp $	*/
d20 5
a24 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.14.8.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d56 2
@


1.13
log
@finish busify
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le.c,v 1.12 1997/12/26 08:07:32 deraadt Exp $	*/
d54 1
@


1.12
log
@busify; support isapnp lance cards
@
text
@d1 1
a1 1
/*	$OpenBSD: if_le_isa.c,v 1.8 1997/08/08 08:23:32 downsj Exp $	*/
a63 1
#include <machine/pio.h>
a67 1
#include <i386/isa/isa_machdep.h>
d74 1
a74 1
hide void
d87 1
a87 1
hide u_int16_t
@


1.11
log
@foom
@
text
@d1 118
@


1.10
log
@if_name/if_unit -> if_xname/if_softc
@
text
@@


1.9
log
@make these work together
@
text
@a0 463
/*    $OpenBSD: if_le.c,v 1.8 1996/04/21 22:24:09 deraadt Exp $       */
/*	$NetBSD: if_le.c,v 1.43 1996/04/22 02:53:28 christos Exp $	*/

/*-
 * Copyright (c) 1995 Charles M. Hannum.  All rights reserved.
 * Copyright (c) 1992, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * Ralph Campbell and Rick Macklem.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)if_le.c	8.2 (Berkeley) 11/16/93
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/mbuf.h>
#include <sys/syslog.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#ifdef INET
#include <netinet/in.h>
#include <netinet/if_ether.h>
#endif

#include <vm/vm.h>

#include <machine/cpu.h>
#include <machine/pio.h>

#include "isa.h"
#include "pci.h"

#if NISA > 0
#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>
#include <dev/isa/isadmavar.h>
#include <i386/isa/isa_machdep.h>
#endif

#if NPCI > 0
#include <dev/pci/pcireg.h>
#include <dev/pci/pcivar.h>
#endif

#include <dev/isa/if_levar.h>
#include <dev/ic/am7990reg.h>
#define LE_NEED_BUF_CONTIG
#include <dev/ic/am7990var.h>

char *card_type[] = {"unknown", "BICC Isolan", "NE2100", "DEPCA", "PCnet-ISA", "PCnet-PCI"};

#define	LE_SOFTC(unit)	le_cd.cd_devs[unit]
#define	LE_DELAY(x)	delay(x)

int leprobe __P((struct device *, void *, void *));
int depca_probe __P((struct le_softc *, struct isa_attach_args *));
int ne2100_probe __P((struct le_softc *, struct isa_attach_args *));
int bicc_probe __P((struct le_softc *, struct isa_attach_args *));
int lance_probe __P((struct le_softc *));
void leattach __P((struct device *, struct device *, void *));
int leintr __P((void *));
int leintredge __P((void *));
void leshutdown __P((void *));

/* XXX the following two structs should be different. */
struct cfattach le_isa_ca = {
	sizeof(struct le_softc), leprobe, leattach
};

struct cfattach le_pci_ca = {
	sizeof(struct le_softc), leprobe, leattach
};

struct cfdriver le_cd = {
	NULL, "le", DV_IFNET
};

integrate void
lehwinit(sc)
	struct le_softc *sc;
{
}

integrate void
lewrcsr(sc, port, val)
	struct le_softc *sc;
	u_int16_t port, val;
{

	outw(sc->sc_rap, port);
	outw(sc->sc_rdp, val);
}

integrate u_int16_t
lerdcsr(sc, port)
	struct le_softc *sc;
	u_int16_t port;
{
	u_int16_t val;

	outw(sc->sc_rap, port);
	val = inw(sc->sc_rdp);
	return (val);
}

int
leprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct le_softc *sc = match;
	extern struct cfdriver isa_cd, pci_cd;

#if NISA > 0
	if (parent->dv_cfdata->cf_driver == &isa_cd) {
		struct isa_attach_args *ia = aux;

		if (bicc_probe(sc, ia))
			return (1);
		if (ne2100_probe(sc, ia))
			return (1);
		if (depca_probe(sc, ia))
			return (1);
	}
#endif

#if NPCI > 0
	if (parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;

		if (pa->pa_id == 0x20001022)
			return (1);
	}
#endif

	return (0);
}

#if NISA > 0
int
depca_probe(sc, ia)
	struct le_softc *sc;
	struct isa_attach_args *ia;
{
	int iobase = ia->ia_iobase, port;
	u_long sum, rom_sum;
	u_char x;
	int i;

	sc->sc_rap = iobase + DEPCA_RAP;
	sc->sc_rdp = iobase + DEPCA_RDP;
	sc->sc_card = DEPCA;

	if (lance_probe(sc) == 0)
		return 0;

	outb(iobase + DEPCA_CSR, DEPCA_CSR_DUM);

	/*
	 * Extract the physical MAC address from the ROM.
	 *
	 * The address PROM is 32 bytes wide, and we access it through
	 * a single I/O port.  On each read, it rotates to the next
	 * position.  We find the ethernet address by looking for a
	 * particular sequence of bytes (0xff, 0x00, 0x55, 0xaa, 0xff,
	 * 0x00, 0x55, 0xaa), and then reading the next 8 bytes (the
	 * ethernet address and a checksum).
	 *
	 * It appears that the PROM can be at one of two locations, so
	 * we just try both.
	 */
	port = iobase + DEPCA_ADP;
	for (i = 0; i < 32; i++)
		if (inb(port) == 0xff && inb(port) == 0x00 &&
		    inb(port) == 0x55 && inb(port) == 0xaa &&
		    inb(port) == 0xff && inb(port) == 0x00 &&
		    inb(port) == 0x55 && inb(port) == 0xaa)
			goto found;
	port = iobase + DEPCA_ADP + 1;
	for (i = 0; i < 32; i++)
		if (inb(port) == 0xff && inb(port) == 0x00 &&
		    inb(port) == 0x55 && inb(port) == 0xaa &&
		    inb(port) == 0xff && inb(port) == 0x00 &&
		    inb(port) == 0x55 && inb(port) == 0xaa)
			goto found;
	printf("%s: address not found\n", sc->sc_dev.dv_xname);
	return 0;

found:
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++)
		sc->sc_arpcom.ac_enaddr[i] = inb(port);

#if 0
	sum =
	    (sc->sc_arpcom.ac_enaddr[0] <<  2) +
	    (sc->sc_arpcom.ac_enaddr[1] << 10) +
	    (sc->sc_arpcom.ac_enaddr[2] <<  1) +
	    (sc->sc_arpcom.ac_enaddr[3] <<  9) +
	    (sc->sc_arpcom.ac_enaddr[4] <<  0) +
	    (sc->sc_arpcom.ac_enaddr[5] <<  8);
	sum = (sum & 0xffff) + (sum >> 16);
	sum = (sum & 0xffff) + (sum >> 16);

	rom_sum = inb(port);
	rom_sum |= inb(port) << 8;

	if (sum != rom_sum) {
		printf("%s: checksum mismatch; calculated %04x != read %04x",
		    sc->sc_dev.dv_xname, sum, rom_sum);
		return 0;
	}
#endif

	outb(iobase + DEPCA_CSR, DEPCA_CSR_NORMAL);

	ia->ia_iosize = 16;
	ia->ia_drq = DRQUNK;
	return 1;
}

int
ne2100_probe(sc, ia)
	struct le_softc *sc;
	struct isa_attach_args *ia;
{
	int iobase = ia->ia_iobase;
	int i;

	sc->sc_rap = iobase + NE2100_RAP;
	sc->sc_rdp = iobase + NE2100_RDP;
	sc->sc_card = NE2100;

	if (lance_probe(sc) == 0)
		return 0;

	/*
	 * Extract the physical MAC address from the ROM.
	 */
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++)
		sc->sc_arpcom.ac_enaddr[i] = inb(iobase + i);

	ia->ia_iosize = 24;
	return 1;
}

int
bicc_probe(sc, ia)
	struct le_softc *sc;
	struct isa_attach_args *ia;
{
	int iobase = ia->ia_iobase;
	int i;

	sc->sc_rap = iobase + BICC_RAP;
	sc->sc_rdp = iobase + BICC_RDP;
	sc->sc_card = BICC;

	if (lance_probe(sc) == 0)
		return 0;

	/*
	 * Extract the physical MAC address from the ROM.
	 */
	for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++)
		sc->sc_arpcom.ac_enaddr[i] = inb(iobase + i * 2);

	ia->ia_iosize = 16;
	return 1;
}

/*
 * Determine which chip is present on the card.
 */
int
lance_probe(sc)
	struct le_softc *sc;
{

	/* Stop the LANCE chip and put it in a known state. */
	lewrcsr(sc, LE_CSR0, LE_C0_STOP);
	LE_DELAY(100);

	if (lerdcsr(sc, LE_CSR0) != LE_C0_STOP)
		return 0;

	lewrcsr(sc, LE_CSR3, sc->sc_conf3);
	return 1;
}
#endif

void
leattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct le_softc *sc = (void *)self;
	extern struct cfdriver isa_cd, pci_cd;

#if NPCI > 0
	if (parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;
		int iobase;

		if (pa->pa_id == 0x20001022) {
			int i;

			if (pci_map_io(pa->pa_tag, 0x10, &iobase))
				return;

			sc->sc_rap = iobase + NE2100_RAP;
			sc->sc_rdp = iobase + NE2100_RDP;
			sc->sc_card = PCnet_PCI;

			/*
			 * Extract the physical MAC address from the ROM.
			 */
			for (i = 0; i < sizeof(sc->sc_arpcom.ac_enaddr); i++)
				sc->sc_arpcom.ac_enaddr[i] = inb(iobase + i);
		}
	}
#endif

#if NISA > 0
	if (sc->sc_card == DEPCA) {
		struct isa_attach_args *ia = aux;
		u_char *mem, val;
		int i;

		mem = sc->sc_mem = ISA_HOLE_VADDR(ia->ia_maddr);

		val = 0xff;
		for (;;) {
			for (i = 0; i < ia->ia_msize; i++)
				mem[i] = val;
			for (i = 0; i < ia->ia_msize; i++)
				if (mem[i] != val) {
					printf("%s: failed to clear memory\n",
					    sc->sc_dev.dv_xname);
					return;
				}
			if (val == 0x00)
				break;
			val -= 0x55;
		}

		sc->sc_conf3 = LE_C3_ACON;
		sc->sc_addr = 0;
		sc->sc_memsize = ia->ia_msize;
	} else
#endif
	{
		sc->sc_mem = malloc(16384, M_DEVBUF, M_NOWAIT);
		if (sc->sc_mem == 0) {
			printf("%s: couldn't allocate memory for card\n",
			    sc->sc_dev.dv_xname);
			return;
		}

		sc->sc_conf3 = 0;
		sc->sc_addr = kvtop(sc->sc_mem);
		sc->sc_memsize = 16384;
	}

	sc->sc_copytodesc = am7990_copytobuf_contig;
	sc->sc_copyfromdesc = am7990_copyfrombuf_contig;
	sc->sc_copytobuf = am7990_copytobuf_contig;
	sc->sc_copyfrombuf = am7990_copyfrombuf_contig;
	sc->sc_zerobuf = am7990_zerobuf_contig;

	sc->sc_arpcom.ac_if.if_name = le_cd.cd_name;
	leconfig(sc);

	printf("%s: type %s\n", sc->sc_dev.dv_xname, card_type[sc->sc_card]);

#if NISA > 0
	if (parent->dv_cfdata->cf_driver == &isa_cd) {
		struct isa_attach_args *ia = aux;

		if (ia->ia_drq != DRQUNK)
			isa_dmacascade(ia->ia_drq);

		sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
		    IPL_NET, leintredge, sc, sc->sc_dev.dv_xname);
	}
#endif

#if NPCI > 0
	if (parent->dv_cfdata->cf_driver == &pci_cd) {
		struct pci_attach_args *pa = aux;
		pcireg_t csr;

		csr = pci_conf_read(pa->pa_bc, pa->pa_tag,
		    PCI_COMMAND_STATUS_REG);
		pci_conf_write(pa->pa_bc, pa->pa_tag, PCI_COMMAND_STATUS_REG,
		    csr | PCI_COMMAND_MASTER_ENABLE);

		sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, leintr, sc);
	}
#endif

	sc->sc_sh = shutdownhook_establish(leshutdown, sc);
}

void
leshutdown(arg)
	void *arg;
{
	struct le_softc *sc = arg;

	lestop(sc);
}

#if NISA > 0
/*
 * Controller interrupt.
 */
leintredge(arg)
	void *arg;
{

	if (leintr(arg) == 0)
		return (0);
	for (;;)
		if (leintr(arg) == 0)
			return (1);
}
#endif

#include <dev/ic/am7990.c>
@


1.8
log
@partial sync with netbsd 960418, more to come
@
text
@d1 2
a2 2
/*    $OpenBSD: if_le.c,v 1.7 1996/03/20 01:00:54 mickey Exp $       */
/*	$NetBSD: if_le.c,v 1.41 1996/04/11 22:29:34 cgd Exp $	*/
d113 6
d398 5
a402 5
	sc->sc_copytodesc = copytobuf_contig;
	sc->sc_copyfromdesc = copyfrombuf_contig;
	sc->sc_copytobuf = copytobuf_contig;
	sc->sc_copyfrombuf = copyfrombuf_contig;
	sc->sc_zerobuf = zerobuf_contig;
@


1.7
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*    $OpenBSD: if_le.c,v 1.6 1996/03/19 21:10:22 mickey Exp $       */
/*    $NetBSD: if_le.c,v 1.38 1995/12/24 02:31:35 mycroft Exp $       */
d86 1
a86 1
#define	LE_SOFTC(unit)	lecd.cd_devs[unit]
d99 11
a109 2
struct cfdriver lecd = {
	NULL, "le", leprobe, leattach, DV_IFNET, sizeof(struct le_softc)
d140 1
a140 1
	extern struct cfdriver isacd, pcicd;
d143 1
a143 1
	if (parent->dv_cfdata->cf_driver == &isacd) {
d156 1
a156 1
	if (parent->dv_cfdata->cf_driver == &pcicd) {
d325 1
a325 1
	extern struct cfdriver isacd, pcicd;
d328 1
a328 1
	if (parent->dv_cfdata->cf_driver == &pcicd) {
d398 1
a398 1
	sc->sc_arpcom.ac_if.if_name = lecd.cd_name;
d404 1
a404 1
	if (parent->dv_cfdata->cf_driver == &isacd) {
d410 2
a411 2
		sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_NET,
		    leintredge, sc, sc->sc_dev.dv_xname);
d416 1
a416 1
	if (parent->dv_cfdata->cf_driver == &pcicd) {
d418 1
d420 4
a423 3
		pci_conf_write(pa->pa_tag, PCI_COMMAND_STATUS_REG,
		    pci_conf_read(pa->pa_tag, PCI_COMMAND_STATUS_REG) |
		    PCI_COMMAND_MASTER_ENABLE);
d425 1
a425 2
		sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, leintr, sc,
					sc->sc_dev.dv_xname);
@


1.6
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*    $OpenBSD: if_le.c,v 1.5 1996/03/08 16:43:05 niklas Exp $       */
d402 1
a402 1
		    leintredge, sc);
@


1.5
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*    $OpenBSD$       */
d402 1
a402 1
		    leintredge, sc, sc->sc_dev.dv_xname);
@


1.4
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: if_le.c,v 1.37 1995/11/25 01:24:00 cgd Exp $	*/
@


1.3
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d401 1
a401 1
		    leintredge, sc);
d413 2
a414 1
		sc->sc_ih = pci_map_int(pa->pa_tag, IPL_NET, leintr, sc);
@


1.2
log
@from netbsd; use bus-specific copying functions
@
text
@d400 2
a401 2
		sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE,
		    ISA_IPL_NET, leintredge, sc);
d413 1
a413 1
		sc->sc_ih = pci_map_int(pa->pa_tag, PCI_IPL_NET, leintr, sc);
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/*	$NetBSD: if_le.c,v 1.36 1995/10/07 09:19:13 mycroft Exp $	*/
d80 1
a443 45

/*
 * Routines for accessing the transmit and receive buffers.
 */

void
copytobuf_contig(sc, from, boff, len)
	struct le_softc *sc;
	caddr_t from;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(from, buf + boff, len);
}

void
copyfrombuf_contig(sc, to, boff, len)
	struct le_softc *sc;
	caddr_t to;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bcopy() to do the work.
	 */
	bcopy(buf + boff, to, len);
}

void
zerobuf_contig(sc, boff, len)
	struct le_softc *sc;
	int boff, len;
{
	volatile caddr_t buf = sc->sc_mem;

	/*
	 * Just call bzero() to do the work.
	 */
	bzero(buf + boff, len);
}
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
