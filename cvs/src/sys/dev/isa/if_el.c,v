head	1.34;
access;
symbols
	OPENBSD_6_0:1.33.0.2
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.32.0.2
	OPENBSD_5_9_BASE:1.32
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.24.0.4
	OPENBSD_5_7_BASE:1.24
	OPENBSD_5_6:1.22.0.6
	OPENBSD_5_6_BASE:1.22
	OPENBSD_5_5:1.22.0.4
	OPENBSD_5_5_BASE:1.22
	OPENBSD_5_4:1.21.0.20
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.21.0.18
	OPENBSD_5_3_BASE:1.21
	OPENBSD_5_2:1.21.0.16
	OPENBSD_5_2_BASE:1.21
	OPENBSD_5_1_BASE:1.21
	OPENBSD_5_1:1.21.0.14
	OPENBSD_5_0:1.21.0.12
	OPENBSD_5_0_BASE:1.21
	OPENBSD_4_9:1.21.0.10
	OPENBSD_4_9_BASE:1.21
	OPENBSD_4_8:1.21.0.8
	OPENBSD_4_8_BASE:1.21
	OPENBSD_4_7:1.21.0.4
	OPENBSD_4_7_BASE:1.21
	OPENBSD_4_6:1.21.0.6
	OPENBSD_4_6_BASE:1.21
	OPENBSD_4_5:1.21.0.2
	OPENBSD_4_5_BASE:1.21
	OPENBSD_4_4:1.20.0.10
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.20.0.8
	OPENBSD_4_3_BASE:1.20
	OPENBSD_4_2:1.20.0.6
	OPENBSD_4_2_BASE:1.20
	OPENBSD_4_1:1.20.0.4
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.20.0.2
	OPENBSD_4_0_BASE:1.20
	OPENBSD_3_9:1.19.0.8
	OPENBSD_3_9_BASE:1.19
	OPENBSD_3_8:1.19.0.6
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.19.0.4
	OPENBSD_3_7_BASE:1.19
	OPENBSD_3_6:1.19.0.2
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.18.0.6
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.18.0.4
	OPENBSD_3_4_BASE:1.18
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.18.0.2
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.17.0.4
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.17.0.2
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.17
	UBC:1.16.0.4
	UBC_BASE:1.16
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.12.0.10
	OPENBSD_2_8_BASE:1.12
	OPENBSD_2_7:1.12.0.8
	OPENBSD_2_7_BASE:1.12
	SMP:1.12.0.6
	SMP_BASE:1.12
	kame_19991208:1.12
	OPENBSD_2_6:1.12.0.4
	OPENBSD_2_6_BASE:1.12
	OPENBSD_2_5:1.12.0.2
	OPENBSD_2_5_BASE:1.12
	OPENBSD_2_4:1.11.0.10
	OPENBSD_2_4_BASE:1.11
	OPENBSD_2_3:1.11.0.8
	OPENBSD_2_3_BASE:1.11
	OPENBSD_2_2:1.11.0.6
	OPENBSD_2_2_BASE:1.11
	OPENBSD_2_1:1.11.0.4
	OPENBSD_2_1_BASE:1.11
	OPENBSD_2_0:1.11.0.2
	OPENBSD_2_0_BASE:1.11
	netbsd:1.1.1
	netbsd_1_1:1.1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2017.01.22.10.17.38;	author dlg;	state Exp;
branches;
next	1.33;
commitid	VyLWTsbepAOk7VQM;

1.33
date	2016.04.13.10.49.26;	author mpi;	state Exp;
branches;
next	1.32;
commitid	QHiEhS9DHyE6oiIr;

1.32
date	2015.12.08.13.34.22;	author tedu;	state Exp;
branches;
next	1.31;
commitid	J9apD0jq2AjFmqZc;

1.31
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.30;
commitid	B0kwmVGiD5DVx4kv;

1.30
date	2015.11.24.17.11.39;	author mpi;	state Exp;
branches;
next	1.29;
commitid	5gdEnqVoJuTuwdTu;

1.29
date	2015.11.24.13.33.17;	author mpi;	state Exp;
branches;
next	1.28;
commitid	5DvsamK0GblTp8ww;

1.28
date	2015.10.25.13.13.06;	author mpi;	state Exp;
branches;
next	1.27;
commitid	SaArro4mM2Ab3ure;

1.27
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.26;
commitid	MVWrtktB46JRxFWT;

1.26
date	2015.05.19.11.24.01;	author mpi;	state Exp;
branches;
next	1.25;
commitid	0fL6zHGm3fqppVdw;

1.25
date	2015.05.13.10.42.46;	author jsg;	state Exp;
branches;
next	1.24;
commitid	hN5bFCE56DrAjl99;

1.24
date	2014.12.22.02.28.51;	author tedu;	state Exp;
branches;
next	1.23;
commitid	yM2VFFhpDTeFQlve;

1.23
date	2014.08.11.12.45.45;	author mpi;	state Exp;
branches;
next	1.22;
commitid	nYggAidK85QbUFh2;

1.22
date	2013.08.07.01.06.32;	author bluhm;	state Exp;
branches;
next	1.21;

1.21
date	2008.10.02.20.21.13;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2006.03.25.22.41.44;	author djm;	state Exp;
branches;
next	1.19;

1.19
date	2004.05.12.06.35.11;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.01.27.19.09.12;	author jason;	state Exp;
branches;
next	1.17;

1.17
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.16;

1.16
date	2001.06.27.06.34.45;	author kjc;	state Exp;
branches
	1.16.4.1;
next	1.15;

1.15
date	2001.06.25.04.44.28;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.23.21.54.49;	author fgsch;	state Exp;
branches;
next	1.13;

1.13
date	2001.02.20.19.39.40;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	99.02.28.03.23.37;	author jason;	state Exp;
branches
	1.12.6.1;
next	1.11;

1.11
date	96.05.26.00.27.18;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	96.05.10.12.41.18;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	96.05.07.07.36.53;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	96.05.05.13.38.27;	author mickey;	state Exp;
branches;
next	1.7;

1.7
date	96.04.21.22.23.48;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	96.03.20.01.00.48;	author mickey;	state Exp;
branches;
next	1.5;

1.5
date	96.03.19.21.10.17;	author mickey;	state Exp;
branches;
next	1.4;

1.4
date	96.03.08.16.43.01;	author niklas;	state Exp;
branches;
next	1.3;

1.3
date	96.02.20.04.35.54;	author tholo;	state Exp;
branches;
next	1.2;

1.2
date	95.12.27.22.06.22;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	95.10.18.08.52.35;	author deraadt;	state Exp;
branches;
next	;

1.12.6.1
date	2001.05.14.22.24.41;	author niklas;	state Exp;
branches;
next	1.12.6.2;

1.12.6.2
date	2001.07.04.10.41.28;	author niklas;	state Exp;
branches;
next	1.12.6.3;

1.12.6.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.12.6.4;

1.12.6.4
date	2003.03.28.00.38.15;	author niklas;	state Exp;
branches;
next	1.12.6.5;

1.12.6.5
date	2004.06.05.23.12.45;	author niklas;	state Exp;
branches;
next	;

1.16.4.1
date	2002.06.11.03.42.21;	author art;	state Exp;
branches;
next	1.16.4.2;

1.16.4.2
date	2003.05.19.22.07.48;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.34
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*    $OpenBSD: if_el.c,v 1.33 2016/04/13 10:49:26 mpi Exp $       */
/*	$NetBSD: if_el.c,v 1.39 1996/05/12 23:52:32 mycroft Exp $	*/

/*
 * Copyright (c) 1994, Matthew E. Kimmel.  Permission is hereby granted
 * to use, copy, modify and distribute this software provided that both
 * the copyright notice and this permission notice appear in all copies
 * of the software, derivative works or modified versions, and any
 * portions thereof.
 */

/*
 * 3COM Etherlink 3C501 device driver
 */

/*
 * Bugs/possible improvements:
 *	- Does not currently support DMA
 *	- Does not currently support multicasts
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/errno.h>
#include <sys/ioctl.h>
#include <sys/mbuf.h>
#include <sys/socket.h>
#include <sys/syslog.h>
#include <sys/device.h>

#include <net/if.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/cpu.h>
#include <machine/intr.h>
#include <machine/pio.h>

#include <dev/isa/isavar.h>
#include <dev/isa/if_elreg.h>

/* for debugging convenience */
#ifdef EL_DEBUG
#define dprintf(x) printf x
#else
#define dprintf(x)
#endif

/*
 * per-line info and status
 */
struct el_softc {
	struct device sc_dev;
	void *sc_ih;

	struct arpcom sc_arpcom;	/* ethernet common */
	int sc_iobase;			/* base I/O addr */
};

/*
 * prototypes
 */
int elintr(void *);
void elinit(struct el_softc *);
int elioctl(struct ifnet *, u_long, caddr_t);
void elstart(struct ifnet *);
void elwatchdog(struct ifnet *);
void elreset(struct el_softc *);
void elstop(struct el_softc *);
static int el_xmit(struct el_softc *);
void elread(struct el_softc *, int);
struct mbuf *elget(struct el_softc *sc, int);
static inline void el_hardreset(struct el_softc *);

int elprobe(struct device *, void *, void *);
void elattach(struct device *, struct device *, void *);

struct cfattach el_ca = {
	sizeof(struct el_softc), elprobe, elattach
};

struct cfdriver el_cd = {
	NULL, "el", DV_IFNET
};

/*
 * Probe routine.
 *
 * See if the card is there and at the right place.
 * (XXX - cgd -- needs help)
 */
int
elprobe(parent, match, aux)
	struct device *parent;
	void *match, *aux;
{
	struct el_softc *sc = match;
	struct isa_attach_args *ia = aux;
	int iobase = ia->ia_iobase;
	u_char station_addr[ETHER_ADDR_LEN];
	int i;

	/* First check the base. */
	if (iobase < 0x280 || iobase > 0x3f0)
		return 0;

	/* Grab some info for our structure. */
	sc->sc_iobase = iobase;

	/*
	 * Now attempt to grab the station address from the PROM and see if it
	 * contains the 3com vendor code.
	 */
	dprintf(("Probing 3c501 at 0x%x...\n", iobase));

	/* Reset the board. */
	dprintf(("Resetting board...\n"));
	outb(iobase+EL_AC, EL_AC_RESET);
	delay(5);
	outb(iobase+EL_AC, 0);

	/* Now read the address. */
	dprintf(("Reading station address...\n"));
	for (i = 0; i < ETHER_ADDR_LEN; i++) {
		outb(iobase+EL_GPBL, i);
		station_addr[i] = inb(iobase+EL_EAW);
	}
	dprintf(("Address is %s\n", ether_sprintf(station_addr)));

	/*
	 * If the vendor code is ok, return a 1.  We'll assume that whoever
	 * configured this system is right about the IRQ.
	 */
	if (station_addr[0] != 0x02 || station_addr[1] != 0x60 ||
	    station_addr[2] != 0x8c) {
		dprintf(("Bad vendor code.\n"));
		return 0;
	}

	dprintf(("Vendor code ok.\n"));
	/* Copy the station address into the arpcom structure. */
	bcopy(station_addr, sc->sc_arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ia->ia_iosize = 4;	/* XXX */
	ia->ia_msize = 0;
	return 1;
}

/*
 * Attach the interface to the kernel data structures.  By the time this is
 * called, we know that the card exists at the given I/O address.  We still
 * assume that the IRQ given is correct.
 */
void
elattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
{
	struct el_softc *sc = (void *)self;
	struct isa_attach_args *ia = aux;
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;

	dprintf(("Attaching %s...\n", sc->sc_dev.dv_xname));

	/* Stop the board. */
	elstop(sc);

	/* Initialize ifnet structure. */
	bcopy(sc->sc_dev.dv_xname, ifp->if_xname, IFNAMSIZ);
	ifp->if_softc = sc;
	ifp->if_start = elstart;
	ifp->if_ioctl = elioctl;
	ifp->if_watchdog = elwatchdog;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX;

	/* Now we can attach the interface. */
	dprintf(("Attaching interface...\n"));
	if_attach(ifp);
	ether_ifattach(ifp);

	/* Print out some information for the user. */
	printf(": address %s\n", ether_sprintf(sc->sc_arpcom.ac_enaddr));

	sc->sc_ih = isa_intr_establish(ia->ia_ic, ia->ia_irq, IST_EDGE,
	    IPL_NET, elintr, sc, sc->sc_dev.dv_xname);

	dprintf(("elattach() finished.\n"));
}

/*
 * Reset interface.
 */
void
elreset(sc)
	struct el_softc *sc;
{
	int s;

	dprintf(("elreset()\n"));
	s = splnet();
	elstop(sc);
	elinit(sc);
	splx(s);
}

/*
 * Stop interface.
 */
void
elstop(sc)
	struct el_softc *sc;
{

	outb(sc->sc_iobase+EL_AC, 0);
}

/*
 * Do a hardware reset of the board, and upload the ethernet address again in
 * case the board forgets.
 */
static inline void
el_hardreset(sc)
	struct el_softc *sc;
{
	int iobase = sc->sc_iobase;
	int i;

	outb(iobase+EL_AC, EL_AC_RESET);
	delay(5);
	outb(iobase+EL_AC, 0);

	for (i = 0; i < ETHER_ADDR_LEN; i++)
		outb(iobase+i, sc->sc_arpcom.ac_enaddr[i]);
}

/*
 * Initialize interface.
 */
void
elinit(sc)
	struct el_softc *sc;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	int iobase = sc->sc_iobase;

	/* First, reset the board. */
	el_hardreset(sc);

	/* Configure rx. */
	dprintf(("Configuring rx...\n"));
	if (ifp->if_flags & IFF_PROMISC)
		outb(iobase+EL_RXC, EL_RXC_AGF | EL_RXC_DSHORT | EL_RXC_DDRIB | EL_RXC_DOFLOW | EL_RXC_PROMISC);
	else
		outb(iobase+EL_RXC, EL_RXC_AGF | EL_RXC_DSHORT | EL_RXC_DDRIB | EL_RXC_DOFLOW | EL_RXC_ABROAD);
	outb(iobase+EL_RBC, 0);

	/* Configure TX. */
	dprintf(("Configuring tx...\n"));
	outb(iobase+EL_TXC, 0);

	/* Start reception. */
	dprintf(("Starting reception...\n"));
	outb(iobase+EL_AC, EL_AC_IRQE | EL_AC_RX);

	/* Set flags appropriately. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* And start output. */
	elstart(ifp);
}

/*
 * Start output on interface.  Get datagrams from the queue and output them,
 * giving the receiver a chance between datagrams.  Call only from splnet or
 * interrupt level!
 */
void
elstart(ifp)
	struct ifnet *ifp;
{
	struct el_softc *sc = ifp->if_softc;
	int iobase = sc->sc_iobase;
	struct mbuf *m, *m0;
	int s, i, off, retries;

	dprintf(("elstart()...\n"));
	s = splnet();

	/* Don't do anything if output is active. */
	if (ifq_is_oactive(&ifp->if_snd) != 0) {
		splx(s);
		return;
	}

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * The main loop.  They warned me against endless loops, but would I
	 * listen?  NOOO....
	 */
	for (;;) {
		/* Dequeue the next datagram. */
		IFQ_DEQUEUE(&ifp->if_snd, m0);

		/* If there's nothing to send, return. */
		if (m0 == NULL)
			break;

#if NBPFILTER > 0
		/* Give the packet to the bpf, if any. */
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif

		/* Disable the receiver. */
		outb(iobase+EL_AC, EL_AC_HOST);
		outb(iobase+EL_RBC, 0);

		/* Transfer datagram to board. */
		dprintf(("el: xfr pkt length=%d...\n", m0->m_pkthdr.len));
		off = EL_BUFSIZ - max(m0->m_pkthdr.len, ETHER_MIN_LEN);
		outb(iobase+EL_GPBL, off);
		outb(iobase+EL_GPBH, off >> 8);

		/* Copy the datagram to the buffer. */
		for (m = m0; m != 0; m = m->m_next)
			outsb(iobase+EL_BUF, mtod(m, caddr_t), m->m_len);
		for (i = 0;
		    i < ETHER_MIN_LEN - ETHER_CRC_LEN - m0->m_pkthdr.len; i++)
			outb(iobase+EL_BUF, 0);
			
		m_freem(m0);

		/* Now transmit the datagram. */
		retries = 0;
		for (;;) {
			outb(iobase+EL_GPBL, off);
			outb(iobase+EL_GPBH, off >> 8);
			if (el_xmit(sc)) {
				ifp->if_oerrors++;
				break;
			}
			/* Check out status. */
			i = inb(iobase+EL_TXS);
			dprintf(("tx status=0x%x\n", i));
			if ((i & EL_TXS_READY) == 0) {
				dprintf(("el: err txs=%x\n", i));
				if (i & (EL_TXS_COLL | EL_TXS_COLL16)) {
					ifp->if_collisions++;
					if ((i & EL_TXC_DCOLL16) == 0 &&
					    retries < 15) {
						retries++;
						outb(iobase+EL_AC, EL_AC_HOST);
					}
				} else {
					ifp->if_oerrors++;
					break;
				}
			} else {
				break;
			}
		}

		/*
		 * Now give the card a chance to receive.
		 * Gotta love 3c501s...
		 */
		(void)inb(iobase+EL_AS);
		outb(iobase+EL_AC, EL_AC_IRQE | EL_AC_RX);
		splx(s);
		/* Interrupt here. */
		s = splnet();
	}

	(void)inb(iobase+EL_AS);
	outb(iobase+EL_AC, EL_AC_IRQE | EL_AC_RX);
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);
}

/*
 * This function actually attempts to transmit a datagram downloaded to the
 * board.  Call at splnet or interrupt, after downloading data!  Returns 0 on
 * success, non-0 on failure.
 */
static int
el_xmit(sc)
	struct el_softc *sc;
{
	int iobase = sc->sc_iobase;
	int i;

	/*
	 * XXX
	 * This busy-waits for the tx completion.  Can we get an interrupt
	 * instead?
	 */

	dprintf(("el: xmit..."));
	outb(iobase+EL_AC, EL_AC_TXFRX);
	i = 20000;
	while ((inb(iobase+EL_AS) & EL_AS_TXBUSY) && (i > 0))
		i--;
	if (i == 0) {
		dprintf(("tx not ready\n"));
		return -1;
	}
	dprintf(("%d cycles.\n", 20000 - i));
	return 0;
}

/*
 * Controller interrupt.
 */
int
elintr(arg)
	void *arg;
{
	register struct el_softc *sc = arg;
	int iobase = sc->sc_iobase;
	int rxstat, len;

	dprintf(("elintr: "));

	/* Check board status. */
	if ((inb(iobase+EL_AS) & EL_AS_RXBUSY) != 0) {
		(void)inb(iobase+EL_RXC);
		outb(iobase+EL_AC, EL_AC_IRQE | EL_AC_RX);
		return 0;
	}

	for (;;) {
		rxstat = inb(iobase+EL_RXS);
		if (rxstat & EL_RXS_STALE)
			break;

		/* If there's an overflow, reinit the board. */
		if ((rxstat & EL_RXS_NOFLOW) == 0) {
			dprintf(("overflow.\n"));
			el_hardreset(sc);
			/* Put board back into receive mode. */
			if (sc->sc_arpcom.ac_if.if_flags & IFF_PROMISC)
				outb(iobase+EL_RXC, EL_RXC_AGF | EL_RXC_DSHORT | EL_RXC_DDRIB | EL_RXC_DOFLOW | EL_RXC_PROMISC);
			else
				outb(iobase+EL_RXC, EL_RXC_AGF | EL_RXC_DSHORT | EL_RXC_DDRIB | EL_RXC_DOFLOW | EL_RXC_ABROAD);
			(void)inb(iobase+EL_AS);
			outb(iobase+EL_RBC, 0);
			break;
		}

		/* Incoming packet. */
		len = inb(iobase+EL_RBL);
		len |= inb(iobase+EL_RBH) << 8;
		dprintf(("receive len=%d rxstat=%x ", len, rxstat));
		outb(iobase+EL_AC, EL_AC_HOST);

		/* Pass data up to upper levels. */
		elread(sc, len);

		/* Is there another packet? */
		if ((inb(iobase+EL_AS) & EL_AS_RXBUSY) != 0)
			break;

		dprintf(("<rescan> "));
	}

	(void)inb(iobase+EL_RXC);
	outb(iobase+EL_AC, EL_AC_IRQE | EL_AC_RX);
	return 1;
}

/*
 * Pass a packet to the higher levels.
 */
void
elread(sc, len)
	register struct el_softc *sc;
	int len;
{
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;

	if (len <= sizeof(struct ether_header) ||
	    len > ETHER_MAX_LEN) {
		printf("%s: invalid packet size %d; dropping\n",
		    sc->sc_dev.dv_xname, len);
		ifp->if_ierrors++;
		return;
	}

	/* Pull packet off interface. */
	m = elget(sc, len);
	if (m == NULL) {
		ifp->if_ierrors++;
		return;
	}

	ml_enqueue(&ml, m);
	if_input(ifp, &ml);
}

/*
 * Pull read data off a interface.  Len is length of data, with local net
 * header stripped.  We copy the data into mbufs.  When full cluster sized
 * units are present we copy into clusters.
 */
struct mbuf *
elget(sc, totlen)
	struct el_softc *sc;
	int totlen;
{
	int iobase = sc->sc_iobase;
	struct mbuf *top, **mp, *m;
	int len;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return 0;
	m->m_pkthdr.len = totlen;
	len = MHLEN;
	top = 0;
	mp = &top;

	outb(iobase+EL_GPBL, 0);
	outb(iobase+EL_GPBH, 0);

	while (totlen > 0) {
		if (top) {
			MGET(m, M_DONTWAIT, MT_DATA);
			if (m == NULL) {
				m_freem(top);
				return 0;
			}
			len = MLEN;
		}
		if (totlen >= MINCLSIZE) {
			MCLGET(m, M_DONTWAIT);
			if (m->m_flags & M_EXT)
				len = MCLBYTES;
		}
		m->m_len = len = min(totlen, len);
		insb(iobase+EL_BUF, mtod(m, caddr_t), len);
		totlen -= len;
		*mp = m;
		mp = &m->m_next;
	}

	outb(iobase+EL_RBC, 0);
	outb(iobase+EL_AC, EL_AC_RX);

	return top;
}

/*
 * Process an ioctl request. This code needs some work - it looks pretty ugly.
 */
int
elioctl(ifp, cmd, data)
	register struct ifnet *ifp;
	u_long cmd;
	caddr_t data;
{
	struct el_softc *sc = ifp->if_softc;
	int s, error = 0;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		elinit(sc);
		break;

	case SIOCSIFFLAGS:
		if ((ifp->if_flags & IFF_UP) == 0 &&
		    (ifp->if_flags & IFF_RUNNING) != 0) {
			/*
			 * If interface is marked down and it is running, then
			 * stop it.
			 */
			elstop(sc);
			ifp->if_flags &= ~IFF_RUNNING;
		} else if ((ifp->if_flags & IFF_UP) != 0 &&
		    	   (ifp->if_flags & IFF_RUNNING) == 0) {
			/*
			 * If interface is marked up and it is stopped, then
			 * start it.
			 */
			elinit(sc);
		} else {
			/*
			 * Some other important flag might have changed, so
			 * reset.
			 */
			elreset(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data);
	}

	splx(s);
	return error;
}

/*
 * Device timeout routine.
 */
void
elwatchdog(ifp)
	struct ifnet *ifp;
{
	struct el_softc *sc = ifp->if_softc;

	log(LOG_ERR, "%s: device timeout\n", sc->sc_dev.dv_xname);
	sc->sc_arpcom.ac_if.if_oerrors++;

	elreset(sc);
}
@


1.33
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.32 2015/12/08 13:34:22 tedu Exp $       */
a367 1
				ifp->if_opackets++;
@


1.32
log
@No trailers has been the default and only option for 20 years, yet some
drivers still set IFF_NOTRAILERS while others do not. Remove all usage of
the flag from the drivers which in ancient times used it (and the modern
drivers which blindly copied it from those drivers of yore).
suggested by guenther. ok mpi
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.31 2015/11/25 03:09:59 dlg Exp $       */
a181 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.31
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.30 2015/11/24 17:11:39 mpi Exp $       */
d181 1
a181 1
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_NOTRAILERS;
@


1.30
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.29 2015/11/24 13:33:17 mpi Exp $       */
d275 1
a275 1
	ifp->if_flags &= ~IFF_OACTIVE;
d299 1
a299 1
	if ((ifp->if_flags & IFF_OACTIVE) != 0) {
d304 1
a304 1
	ifp->if_flags |= IFF_OACTIVE;
d387 1
a387 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.29
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.28 2015/10/25 13:13:06 mpi Exp $       */
a33 1
#include <net/if_dl.h>
@


1.28
log
@arp_ifinit() is no longer needed and almost dead.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.27 2015/06/24 09:40:54 mpi Exp $       */
a34 1
#include <net/if_types.h>
@


1.27
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.26 2015/05/19 11:24:01 mpi Exp $       */
a576 1
	struct ifaddr *ifa = (struct ifaddr *)data;
d584 1
a584 10

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			elinit(sc);
			arp_ifinit(&sc->sc_arpcom, ifa);
			break;
		default:
			elinit(sc);
			break;
		}
@


1.26
log
@Convert to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.25 2015/05/13 10:42:46 jsg Exp $       */
a510 1
	ifp->if_ipackets++;
a511 1

@


1.25
log
@test mbuf pointers against NULL not 0
ok krw@@ miod@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.24 2014/12/22 02:28:51 tedu Exp $       */
d493 1
d512 1
d514 1
a514 10
#if NBPFILTER > 0
	/*
	 * Check if there's a BPF listener on this interface.
	 * If so, hand off the raw packet to BPF.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);
a526 1
	struct ifnet *ifp = &sc->sc_arpcom.ac_if;
a533 1
	m->m_pkthdr.rcvif = ifp;
@


1.24
log
@unifdef INET
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.23 2014/08/11 12:45:45 mpi Exp $       */
d317 1
a317 1
		if (m0 == 0)
d505 1
a505 1
	if (m == 0) {
d540 1
a540 1
	if (m == 0)
d554 1
a554 1
			if (m == 0) {
@


1.23
log
@Fewer <netinet/in_systm.h>
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.22 2013/08/07 01:06:32 bluhm Exp $       */
a597 1
#ifdef INET
a601 1
#endif
@


1.22
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.21 2008/10/02 20:21:13 brad Exp $       */
a36 1
#ifdef INET
a37 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a38 1
#endif
@


1.21
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.20 2006/03/25 22:41:44 djm Exp $       */
a39 1
#include <netinet/in_var.h>
@


1.20
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.19 2004/05/12 06:35:11 tedu Exp $       */
a597 5
	if ((error = ether_ioctl(ifp, &sc->sc_arpcom, cmd, data)) > 0) {
		splx(s);
		return error;
	}

a598 1

d641 1
a641 2
		error = EINVAL;
		break;
@


1.19
log
@network drivers don't need to include bpfdesc.h
ok krw@@ canacar@@
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.18 2003/01/27 19:09:12 jason Exp $       */
d328 1
a328 1
			bpf_mtap(ifp->if_bpf, m0);
d523 1
a523 1
		bpf_mtap(ifp->if_bpf, m);
@


1.18
log
@Pad tx buffer with 0's on minimum sized frames; based on NetBSD.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.17 2002/03/14 01:26:56 millert Exp $       */
a46 1
#include <net/bpfdesc.h>
@


1.17
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.16 2001/06/27 06:34:45 kjc Exp $       */
d345 4
a348 1

@


1.16
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.15 2001/06/25 04:44:28 fgsch Exp $       */
d78 11
a88 11
int elintr __P((void *));
void elinit __P((struct el_softc *));
int elioctl __P((struct ifnet *, u_long, caddr_t));
void elstart __P((struct ifnet *));
void elwatchdog __P((struct ifnet *));
void elreset __P((struct el_softc *));
void elstop __P((struct el_softc *));
static int el_xmit __P((struct el_softc *));
void elread __P((struct el_softc *, int));
struct mbuf *elget __P((struct el_softc *sc, int));
static inline void el_hardreset __P((struct el_softc *));
d90 2
a91 2
int elprobe __P((struct device *, void *, void *));
void elattach __P((struct device *, struct device *, void *));
@


1.16.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.16 2001/06/27 06:34:45 kjc Exp $       */
d78 11
a88 11
int elintr(void *);
void elinit(struct el_softc *);
int elioctl(struct ifnet *, u_long, caddr_t);
void elstart(struct ifnet *);
void elwatchdog(struct ifnet *);
void elreset(struct el_softc *);
void elstop(struct el_softc *);
static int el_xmit(struct el_softc *);
void elread(struct el_softc *, int);
struct mbuf *elget(struct el_softc *sc, int);
static inline void el_hardreset(struct el_softc *);
d90 2
a91 2
int elprobe(struct device *, void *, void *);
void elattach(struct device *, struct device *, void *);
@


1.16.4.2
log
@sync
@
text
@d1 1
a1 1
/*    $OpenBSD$       */
d345 1
a345 4
		for (i = 0;
		    i < ETHER_MIN_LEN - ETHER_CRC_LEN - m0->m_pkthdr.len; i++)
			outb(iobase+EL_BUF, 0);
			
@


1.15
log
@ether_input_mbuf() conversion.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.14 2001/06/23 21:54:49 fgsch Exp $       */
d190 1
d320 1
a320 1
		IF_DEQUEUE(&ifp->if_snd, m0);
@


1.14
log
@Remove repeated ethernet constants; use if_ether.h for it instead.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.13 2001/02/20 19:39:40 mickey Exp $       */
a495 1
	struct ether_header *eh;
a513 3
	/* We assume that the header fit entirely in one mbuf. */
	eh = mtod(m, struct ether_header *);

d523 1
a523 3
	/* We assume that the header fit entirely in one mbuf. */
	m_adj(m, sizeof(struct ether_header));
	ether_input(ifp, eh, m);
@


1.13
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.12 1999/02/28 03:23:37 jason Exp $       */
a55 4

#define ETHER_MIN_LEN	64
#define ETHER_MAX_LEN	1518
#define	ETHER_ADDR_LEN	6
@


1.12
log
@compensate for the test of packet ownership being moved to ether_input()
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.11 1996/05/26 00:27:18 deraadt Exp $       */
a201 6

	/* Finally, attach to bpf filter if it is present. */
#if NBPFILTER > 0
	dprintf(("Attaching to BPF...\n"));
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB, sizeof(struct ether_header));
#endif
@


1.12.6.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.13 2001/02/20 19:39:40 mickey Exp $       */
d202 6
@


1.12.6.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.12.6.1 2001/05/14 22:24:41 niklas Exp $       */
d57 4
a193 1
	IFQ_SET_READY(&ifp->if_snd);
d323 1
a323 1
		IFQ_DEQUEUE(&ifp->if_snd, m0);
d500 1
d519 3
d531 3
a533 1
	ether_input_mbuf(ifp, m);
@


1.12.6.3
log
@Merge in -current from about a week ago
@
text
@d1 1
a1 1
/*    $OpenBSD$       */
d78 11
a88 11
int elintr(void *);
void elinit(struct el_softc *);
int elioctl(struct ifnet *, u_long, caddr_t);
void elstart(struct ifnet *);
void elwatchdog(struct ifnet *);
void elreset(struct el_softc *);
void elstop(struct el_softc *);
static int el_xmit(struct el_softc *);
void elread(struct el_softc *, int);
struct mbuf *elget(struct el_softc *sc, int);
static inline void el_hardreset(struct el_softc *);
d90 2
a91 2
int elprobe(struct device *, void *, void *);
void elattach(struct device *, struct device *, void *);
@


1.12.6.4
log
@Sync the SMP branch with 3.3
@
text
@d345 1
a345 4
		for (i = 0;
		    i < ETHER_MIN_LEN - ETHER_CRC_LEN - m0->m_pkthdr.len; i++)
			outb(iobase+EL_BUF, 0);
			
@


1.12.6.5
log
@Merge with the trunk
@
text
@d47 1
@


1.11
log
@sync 0521
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.10 1996/05/10 12:41:18 deraadt Exp $       */
d533 1
a533 1
	if (ifp->if_bpf) {
a534 14

		/*
		 * Note that the interface cannot be in promiscuous mode if
		 * there are no BPF listeners.  And if we are in promiscuous
		 * mode, we have to check if this packet is really ours.
		 */
		if ((ifp->if_flags & IFF_PROMISC) &&
		    (eh->ether_dhost[0] & 1) == 0 && /* !mcast and !bcast */
		    bcmp(eh->ether_dhost, sc->sc_arpcom.ac_enaddr,
			    sizeof(eh->ether_dhost)) != 0) {
			m_freem(m);
			return;
		}
	}
@


1.10
log
@if_name/if_unit -> if_xname/if_softc
@
text
@d1 2
a2 2
/*    $OpenBSD: if_el.c,v 1.7 1996/04/21 22:23:48 deraadt Exp $       */
/*	$NetBSD: if_el.c,v 1.38 1996/05/07 01:55:20 thorpej Exp $	*/
d51 1
@


1.9
log
@sync with 0504 -- prototypes and bus.h
@
text
@d2 1
a2 1
/*	$NetBSD: if_el.c,v 1.37 1996/04/29 20:03:17 christos Exp $	*/
d85 1
a85 1
void elwatchdog __P((int));
d187 2
a188 2
	ifp->if_unit = sc->sc_dev.dv_unit;
	ifp->if_name = el_cd.cd_name;
d306 1
a306 1
	struct el_softc *sc = el_cd.cd_devs[ifp->if_unit];
d618 1
a618 1
	struct el_softc *sc = el_cd.cd_devs[ifp->if_unit];
d685 2
a686 2
elwatchdog(unit)
	int unit;
d688 1
a688 1
	struct el_softc *sc = el_cd.cd_devs[unit];
@


1.8
log
@add general ether_ioctl call in net/if_ethersubr.c,
NS,IPX,X.25 special processing is now handled in there.
reflect this amazing addition in all the ether ifaces.
ppl, pls check the stuff.
@
text
@d2 1
a2 1
/*	$NetBSD: if_el.c,v 1.36 1996/04/11 22:29:07 cgd Exp $	*/
d25 1
d82 1
a82 1
int elinit __P((struct el_softc *));
d263 1
a263 1
int
a619 1
	struct ifreq *ifr = (struct ifreq *)data;
@


1.7
log
@partial sync with netbsd 960418, more to come
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.6 1996/03/20 01:00:48 mickey Exp $       */
a43 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

d624 5
a639 18
#endif
#ifdef NS
		/* XXX - This code is probably wrong. */
		case AF_NS:
		    {
			register struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host =
				    *(union ns_host *)(sc->sc_arpcom.ac_enaddr);
			else
				bcopy(ina->x_host.c_host,
				    sc->sc_arpcom.ac_enaddr,
				    sizeof(sc->sc_arpcom.ac_enaddr));
			/* Set new address. */
			elinit(sc);
			break;
		    }
@


1.6
log
@Fix back wrong patches.
@
text
@d1 2
a2 2
/*    $OpenBSD: if_el.c,v 1.5 1996/03/19 21:10:17 mickey Exp $       */
/*    $NetBSD: if_el.c,v 1.34 1995/12/24 02:31:25 mycroft Exp $       */
d100 6
a105 3
/* isa_driver structure for autoconf */
struct cfdriver elcd = {
	NULL, "el", elprobe, elattach, DV_IFNET, sizeof(struct el_softc)
d192 1
a192 1
	ifp->if_name = elcd.cd_name;
d212 2
a213 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, IST_EDGE, IPL_NET, elintr,
	    sc, sc->sc_dev.dv_xname);
d310 1
a310 1
	struct el_softc *sc = elcd.cd_devs[ifp->if_unit];
d622 1
a622 1
	struct el_softc *sc = elcd.cd_devs[ifp->if_unit];
d706 1
a706 1
	struct el_softc *sc = elcd.cd_devs[unit];
@


1.5
log
@Merging w/ NetBSD 021796.
speaker upgraded to the current.
some changes to the VM stuff (ie kern_thread.c added and so).
@
text
@d1 1
a1 1
/*    $OpenBSD: if_el.c,v 1.4 1996/03/08 16:43:01 niklas Exp $       */
d210 1
a210 1
	    sc);
@


1.4
log
@From NetBSD: merge of 960217
@
text
@d1 1
a1 1
/*    $OpenBSD$       */
d210 1
a210 1
	    sc, sc->sc_dev.dv_xname);
@


1.3
log
@Pass device name to interrupt establish routines so it can be recorded in
the device interrupt chain structures (isa, pci)

Move interrupt chain structure definition to <machine/psl.h> so vmstat can
get at it (i386)

Remove hack to count interrupts the old way (i386)
@
text
@d1 2
a2 1
/*	$NetBSD: if_el.c,v 1.33 1995/08/05 23:53:18 mycroft Exp $	*/
@


1.2
log
@from netbsd:
The IST_* and IPL_* constants are not bus-specific; don't treat them as such.
Change splimp -> splnet in Ethernet, ARCnet, and FDDI drivers.
@
text
@d209 1
a209 1
	    sc);
@


1.1
log
@Initial revision
@
text
@d208 2
a209 2
	sc->sc_ih = isa_intr_establish(ia->ia_irq, ISA_IST_EDGE, ISA_IPL_NET,
	    elintr, sc);
d224 1
a224 1
	s = splimp();
d299 1
a299 1
 * giving the receiver a chance between datagrams.  Call only from splimp or
d312 1
a312 1
	s = splimp();
d395 1
a395 1
		s = splimp();
d406 1
a406 1
 * board.  Call at splimp or interrupt, after downloading data!  Returns 0 on
d623 1
a623 1
	s = splimp();
@


1.1.1.1
log
@initial import of NetBSD tree
@
text
@@
