head	1.19;
access;
symbols
	OPENBSD_6_1:1.19.0.6
	OPENBSD_6_1_BASE:1.19
	OPENBSD_6_0:1.19.0.4
	OPENBSD_6_0_BASE:1.19
	OPENBSD_5_9:1.19.0.2
	OPENBSD_5_9_BASE:1.19
	OPENBSD_5_8:1.18.0.4
	OPENBSD_5_8_BASE:1.18
	OPENBSD_5_7:1.14.0.8
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.14.0.6
	OPENBSD_5_6_BASE:1.14
	OPENBSD_5_5:1.14.0.4
	OPENBSD_5_5_BASE:1.14
	OPENBSD_5_4:1.13.0.2
	OPENBSD_5_4_BASE:1.13
	OPENBSD_5_3:1.11.0.6
	OPENBSD_5_3_BASE:1.11
	OPENBSD_5_2:1.11.0.4
	OPENBSD_5_2_BASE:1.11
	OPENBSD_5_1_BASE:1.11
	OPENBSD_5_1:1.11.0.2
	OPENBSD_5_0:1.10.0.4
	OPENBSD_5_0_BASE:1.10
	OPENBSD_4_9:1.10.0.2
	OPENBSD_4_9_BASE:1.10
	OPENBSD_4_8:1.7.0.2
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.5.0.8
	OPENBSD_4_7_BASE:1.5
	OPENBSD_4_6:1.5.0.10
	OPENBSD_4_6_BASE:1.5
	OPENBSD_4_5:1.5.0.6
	OPENBSD_4_5_BASE:1.5
	OPENBSD_4_4:1.5.0.4
	OPENBSD_4_4_BASE:1.5
	OPENBSD_4_3:1.5.0.2
	OPENBSD_4_3_BASE:1.5
	OPENBSD_4_2:1.4.0.14
	OPENBSD_4_2_BASE:1.4
	OPENBSD_4_1:1.4.0.12
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.10
	OPENBSD_4_0_BASE:1.4
	OPENBSD_3_9:1.4.0.8
	OPENBSD_3_9_BASE:1.4
	OPENBSD_3_8:1.4.0.6
	OPENBSD_3_8_BASE:1.4
	OPENBSD_3_7:1.4.0.4
	OPENBSD_3_7_BASE:1.4
	OPENBSD_3_6:1.4.0.2
	OPENBSD_3_6_BASE:1.4
	SMP_SYNC_A:1.4
	SMP_SYNC_B:1.4
	OPENBSD_3_5:1.3.0.10
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.8
	OPENBSD_3_4_BASE:1.3
	UBC_SYNC_A:1.3
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.2.0.4
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.2
	OPENBSD_3_0_BASE:1.2
	SMP:1.1.0.4
	OPENBSD_2_9_BASE:1.1
	OPENBSD_2_9:1.1.0.2;
locks; strict;
comment	@ * @;


1.19
date	2015.08.18.06.54.00;	author stsp;	state Exp;
branches;
next	1.18;
commitid	Oe8apdIEWlAjApCE;

1.18
date	2015.05.24.10.57.47;	author miod;	state Exp;
branches;
next	1.17;
commitid	lWcX96d8OBs4r9kK;

1.17
date	2015.05.21.19.32.29;	author miod;	state Exp;
branches;
next	1.16;
commitid	p0pkcVaGhvmhhXCy;

1.16
date	2015.05.04.09.33.46;	author mpi;	state Exp;
branches;
next	1.15;
commitid	AEsxL0jOoaDjikVc;

1.15
date	2015.03.14.03.38.47;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2013.12.06.21.03.03;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2013.05.23.18.29.51;	author tobias;	state Exp;
branches;
next	1.12;

1.12
date	2013.04.20.08.01.37;	author tobias;	state Exp;
branches;
next	1.11;

1.11
date	2012.02.02.21.40.19;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2010.08.31.17.15.04;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2010.08.31.16.31.00;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2010.08.28.12.47.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2010.07.22.14.27.46;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2010.07.21.20.10.17;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2007.10.01.15.34.48;	author krw;	state Exp;
branches;
next	1.4;

1.4
date	2004.04.02.04.39.51;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2002.03.14.01.26.56;	author millert;	state Exp;
branches;
next	1.2;

1.2
date	2001.07.08.06.41.38;	author fgsch;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	2000.11.13.20.12.34;	author aaron;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2001.05.14.22.24.48;	author niklas;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2001.10.31.03.22.43;	author nate;	state Exp;
branches;
next	1.1.4.3;

1.1.4.3
date	2002.03.28.12.11.35;	author niklas;	state Exp;
branches;
next	1.1.4.4;

1.1.4.4
date	2004.06.05.23.12.46;	author niklas;	state Exp;
branches;
next	;

1.2.4.1
date	2002.06.11.03.42.22;	author art;	state Exp;
branches;
next	;


desc
@@


1.19
log
@Add missing trailing to error message:
pckbc0: unable to establish interrupt for irq 12pckbd0 at pckbc0 (kbd slot)
ok miod@@
@
text
@/*	$OpenBSD: pckbc_isa.c,v 1.18 2015/05/24 10:57:47 miod Exp $	*/
/*	$NetBSD: pckbc_isa.c,v 1.2 2000/03/23 07:01:35 thorpej Exp $	*/

/*
 * Copyright (c) 1998
 *	Matthias Drochner.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/isa/isareg.h>
#include <dev/isa/isavar.h>

#include <dev/ic/i8042reg.h>
#include <dev/ic/pckbcvar.h>

int	pckbc_isa_match(struct device *, void *, void *);
void	pckbc_isa_attach(struct device *, struct device *, void *);
int	pckbc_isa_activate(struct device *, int);

const struct cfattach pckbc_isa_ca = {
	sizeof(struct pckbc_softc), pckbc_isa_match, pckbc_isa_attach,
	NULL, pckbc_isa_activate
};

int
pckbc_isa_match(struct device *parent, void *match, void *aux)
{
	struct isa_attach_args *ia = aux;
	bus_space_tag_t iot = ia->ia_iot;
	bus_space_handle_t ioh_d, ioh_c;
	int res;

	/* If values are hardwired to something that they can't be, punt. */
	if ((ia->ia_iobase != IOBASEUNK && ia->ia_iobase != IO_KBD) ||
	    ia->ia_maddr != MADDRUNK ||
	    (ia->ia_irq != IRQUNK && ia->ia_irq != 1 /* XXX */) ||
	    ia->ia_drq != DRQUNK)
		return (0);

	if (pckbc_is_console(iot, IO_KBD) == 0) {
		if (bus_space_map(iot, IO_KBD + KBDATAP, 1, 0, &ioh_d))
			return (0);
		if (bus_space_map(iot, IO_KBD + KBCMDP, 1, 0, &ioh_c))
			goto fail;

		/* flush KBC */
		(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);

		/* KBC selftest */
		if (pckbc_send_cmd(iot, ioh_c, KBC_SELFTEST) == 0)
			goto fail2;
		res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
		if (res != 0x55) {
			printf("kbc selftest: %x\n", res);
			goto fail2;
		}
		bus_space_unmap(iot, ioh_c, 1);
		bus_space_unmap(iot, ioh_d, 1);
	}

	ia->ia_iobase = IO_KBD;
	ia->ia_iosize = 5;
	ia->ia_msize = 0x0;
	ia->ipa_nirq = PCKBC_NSLOTS;
	ia->ipa_irq[PCKBC_KBD_SLOT].num = 1;
	ia->ipa_irq[PCKBC_AUX_SLOT].num = 12;

	return (1);

fail2:
	bus_space_unmap(iot, ioh_c, 1);
fail:
	bus_space_unmap(iot, ioh_d, 1);
	return (0);
}

int
pckbc_isa_activate(struct device *self, int act)
{
	struct pckbc_softc *sc = (struct pckbc_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);
		pckbc_stop(sc);
		break;
	case DVACT_RESUME:
		pckbc_reset(sc);
		rv = config_activate_children(self, act);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

void
pckbc_isa_attach(struct device *parent, struct device *self, void *aux)
{
	struct pckbc_softc *sc = (struct pckbc_softc *)self;
	struct cfdata *cf = self->dv_cfdata;
	struct isa_attach_args *ia = aux;
	struct pckbc_internal *t;
	bus_space_tag_t iot;
	bus_space_handle_t ioh_d, ioh_c;
	void *rv;
	int slot;

	iot = ia->ia_iot;

	printf("\n");

	for (slot = 0; slot < PCKBC_NSLOTS; slot++) {
		rv = isa_intr_establish(ia->ia_ic, ia->ipa_irq[slot].num,
		    IST_EDGE, IPL_TTY, pckbcintr, sc, sc->sc_dv.dv_xname);
		if (rv == NULL) {
			printf("%s: unable to establish interrupt for irq %d\n",
			    sc->sc_dv.dv_xname, ia->ipa_irq[slot].num);
			/* XXX fail attach? */
		}
	}

	if (pckbc_is_console(iot, IO_KBD)) {
		t = &pckbc_consdata;
		pckbc_console_attached = 1;
		/* t->t_cmdbyte was initialized by cnattach */
	} else {
		if (bus_space_map(iot, IO_KBD + KBDATAP, 1, 0, &ioh_d) ||
		    bus_space_map(iot, IO_KBD + KBCMDP, 1, 0, &ioh_c))
			panic("pckbc_attach: couldn't map");

		t = malloc(sizeof(*t), M_DEVBUF, M_WAITOK | M_ZERO);
		t->t_iot = iot;
		t->t_ioh_d = ioh_d;
		t->t_ioh_c = ioh_c;
		t->t_addr = IO_KBD;
		t->t_cmdbyte = KC8_CPU; /* Enable ports */
	}

	t->t_sc = sc;
	sc->id = t;

	/* Finish off the attach. */
	pckbc_attach(sc, cf->cf_flags);
}
@


1.18
log
@Follow the recent pckbc@@isa changes and always establish all the necessary
interrupts at pckbc attach time, and get rid of the `intr_establish'
pckbc callback.

Tested on hppa (gsckbc) and sgi (pckbc@@hpc); not tested on sparc64 (pckbc@@ebus)
but this attachment was already behaving this way and its intr_establish
callback was an empty function.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.17 2015/05/21 19:32:29 miod Exp $	*/
d145 1
a145 1
			printf("%s: unable to establish interrupt for irq %d",
@


1.17
log
@Establish interrupts for both keyboard and mouse slots at pckbc attach time,
rather than lazily from pckbc when slots are discovered. This is consistent
with what other isa devices (and pckbc on non-isa busses) do, and as a side
effect, this makes the dmesg output shorter.

This will also let us get rid of pckbc's intr_establish() callback in a
later diff.

Prompted by krw@@ noticing ugly kernel output in a configuration with the
mouse slot left empty. ok krw@@ mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.16 2015/05/04 09:33:46 mpi Exp $	*/
a50 2
void	pckbc_isa_intr_establish(struct pckbc_softc *, pckbc_slot_t);

a150 2
	sc->intr_establish = pckbc_isa_intr_establish;

a172 6
}

void
pckbc_isa_intr_establish(struct pckbc_softc *sc, pckbc_slot_t slot)
{
	/* done in attach */
@


1.16
log
@Print irq informations in pckbc_set_inputhandler().

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.15 2015/03/14 03:38:47 jsg Exp $	*/
d46 2
a47 9
struct pckbc_isa_softc {
	struct pckbc_softc sc_pckbc;

	isa_chipset_tag_t sc_ic;
	int sc_irq[PCKBC_NSLOTS];
};

struct cfattach pckbc_isa_ca = {
	sizeof(struct pckbc_isa_softc), pckbc_isa_match, pckbc_isa_attach,
d92 3
d108 1
a108 1
	struct pckbc_isa_softc *isc = (struct pckbc_isa_softc *)self;
d114 1
a114 1
		pckbc_stop(&isc->sc_pckbc);
d117 1
a117 1
		pckbc_reset(&isc->sc_pckbc);
d130 1
a130 2
	struct pckbc_isa_softc *isc = (void *)self;
	struct pckbc_softc *sc = &isc->sc_pckbc;
d136 2
a138 1
	isc->sc_ic = ia->ia_ic;
d141 11
a151 5
	/*
	 * Set up IRQs for "normal" ISA.
	 */
	isc->sc_irq[PCKBC_KBD_SLOT] = 1;
	isc->sc_irq[PCKBC_AUX_SLOT] = 12;
a174 2
	printf("\n");

d182 1
a182 10
	struct pckbc_isa_softc *isc = (void *)sc;
	void *rv;

	rv = isa_intr_establish(isc->sc_ic, isc->sc_irq[slot], IST_EDGE,
	    IPL_TTY, pckbcintr, sc, sc->sc_dv.dv_xname);
	if (rv == NULL) {
		printf(": unable to establish interrupt");
	} else {
		printf(": using irq %d", isc->sc_irq[slot]);
	}
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.14 2013/12/06 21:03:03 deraadt Exp $	*/
d188 1
a188 2
		printf("%s: unable to establish interrupt for %s slot\n",
		    sc->sc_dv.dv_xname, pckbc_slot_names[slot]);
d190 1
a190 2
		printf("%s: using irq %d for %s slot\n", sc->sc_dv.dv_xname,
		    isc->sc_irq[slot], pckbc_slot_names[slot]);
@


1.14
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.13 2013/05/23 18:29:51 tobias Exp $	*/
a30 1
#include <sys/kernel.h>
@


1.13
log
@Revert Active PS/2 support for now, until we find a solution suitable
for chipsets which stopped working.

ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.11 2012/02/02 21:40:19 deraadt Exp $	*/
a116 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
d123 3
@


1.12
log
@Enable active PS/2 multiplexing if available.
Supported for i386 and amd64 except SMALL_KERNEL.

Based on Miod's former work on this subject.

ok mpi
@
text
@d83 1
a83 1
		(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
d88 1
a88 1
		res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, NULL);
a141 3
#ifdef PCKBC_APM
	uint slot;
#endif
a149 4
#ifdef PCKBC_APM
	for (slot = PCKBC_AUX_SLOT; slot < PCKBC_NSLOTS; slot++)
		isc->sc_irq[slot] = 12;
#else
a150 1
#endif
d192 1
a192 1
		printf("%s: using irq %d for %s\n", sc->sc_dv.dv_xname,
@


1.11
log
@disable the polling timeout when we suspend; discovered by some code
guenther is working on
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.10 2010/08/31 17:15:04 deraadt Exp $	*/
d83 1
a83 1
		(void) pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d88 1
a88 1
		res = pckbc_poll_data1(iot, ioh_d, ioh_c, PCKBC_KBD_SLOT, 0);
d142 3
d153 4
d158 1
d200 1
a200 1
		printf("%s: using irq %d for %s slot\n", sc->sc_dv.dv_xname,
@


1.10
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
(missed file)
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.9 2010/08/31 16:31:00 deraadt Exp $	*/
d122 1
@


1.9
log
@activate function should return result of config_activate_children
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.8 2010/08/28 12:47:12 miod Exp $	*/
d117 3
@


1.8
log
@Remove dead code, ansify, and clean the match routine; adapted from a diff
by Alexandr Shadchin (firstname dot lastname at gmail) on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.7 2010/07/22 14:27:46 deraadt Exp $	*/
d114 1
d118 1
a118 1
		config_activate_children(self, act);
d122 1
a122 1
		config_activate_children(self, act);
d125 1
a125 1
	return (0);
@


1.7
log
@Reset the keyboard controller on resume, and also alert the children
(pckbd and pms) to do their part
started by mlarkin, cleaned up by me
ok miod
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.6 2010/07/21 20:10:17 miod Exp $	*/
a31 1
#include <sys/proc.h>
d33 1
a33 4
#include <sys/malloc.h> 
#include <sys/errno.h>
#include <sys/queue.h>
#include <sys/lock.h>
d37 1
a37 1
#include <dev/isa/isareg.h>  
d62 1
a62 4
pckbc_isa_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d67 1
a67 1
	int res, ok = 1;
d79 2
a80 4
		if (bus_space_map(iot, IO_KBD + KBCMDP, 1, 0, &ioh_c)) {
			bus_space_unmap(iot, ioh_d, 1);
			return (0);
		}
d86 2
a87 4
		if (pckbc_send_cmd(iot, ioh_c, KBC_SELFTEST) == 0) {
			ok = 0;
			goto out;
		}
d91 1
a91 1
			ok = 0;
d93 1
a93 1
 out:
a94 1
		bus_space_unmap(iot, ioh_c, 1);
d97 11
a107 6
	if (ok) {
		ia->ia_iobase = IO_KBD;
		ia->ia_iosize = 5;
		ia->ia_msize = 0x0;
	}
	return (ok);
d128 1
a128 3
pckbc_isa_attach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
a142 2
	 *
	 * XXX The "aux" slot is different (9) on the Alpha AXP150 Jensen.
a150 2
		ioh_d = t->t_ioh_d;
		ioh_c = t->t_ioh_c;
d176 1
a176 3
pckbc_isa_intr_establish(sc, slot)
	struct pckbc_softc *sc;
	pckbc_slot_t slot;
d178 1
a178 1
	struct pckbc_isa_softc *isc = (void *) sc;
@


1.6
log
@Disable the heuristics for legacy free systems if pckbc flags are set to 1
in UKC; found the hard way by jakemsr@@ on an old Tecra laptop.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.5 2007/10/01 15:34:48 krw Exp $	*/
d49 1
d60 1
d115 17
@


1.5
log
@More easy bzero() -> M_ZERO. Use 'p = malloc(sizeof(*p) ...' where
obvious.
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.4 2004/04/02 04:39:51 deraadt Exp $	*/
d122 1
d166 1
a166 1
	pckbc_attach(sc);
@


1.4
log
@remove terms 3 & 4 for drochner@@NetBSD.org; as seen on netbsd lists
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.3 2002/03/14 01:26:56 millert Exp $	*/
d151 1
a151 2
		t = malloc(sizeof(struct pckbc_internal), M_DEVBUF, M_WAITOK);
		bzero(t, sizeof(struct pckbc_internal));
@


1.3
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.2 2001/07/08 06:41:38 fgsch Exp $	*/
a15 6
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed for the NetBSD Project
 *	by Matthias Drochner.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.2
log
@OpenBSD tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d53 2
a54 2
int	pckbc_isa_match __P((struct device *, void *, void *));
void	pckbc_isa_attach __P((struct device *, struct device *, void *));
d67 1
a67 1
void	pckbc_isa_intr_establish __P((struct pckbc_softc *, pckbc_slot_t));
@


1.2.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: pckbc_isa.c,v 1.2 2001/07/08 06:41:38 fgsch Exp $	*/
d53 2
a54 2
int	pckbc_isa_match(struct device *, void *, void *);
void	pckbc_isa_attach(struct device *, struct device *, void *);
d67 1
a67 1
void	pckbc_isa_intr_establish(struct pckbc_softc *, pckbc_slot_t);
@


1.1
log
@Machine-independent PC-like keyboard driver; from NetBSD. XXX - Not used
anywhere quite yet, but useful to have these files in the tree while we work
towards wscons for i386 and alpha.
@
text
@d1 2
a2 1
/* $NetBSD: pckbc_isa.c,v 1.2 2000/03/23 07:01:35 thorpej Exp $ */
@


1.1.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@@


1.1.4.2
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 2
/*	$OpenBSD$	*/
/*	$NetBSD: pckbc_isa.c,v 1.2 2000/03/23 07:01:35 thorpej Exp $	*/
@


1.1.4.3
log
@Merge in -current from about a week ago
@
text
@d53 2
a54 2
int	pckbc_isa_match(struct device *, void *, void *);
void	pckbc_isa_attach(struct device *, struct device *, void *);
d67 1
a67 1
void	pckbc_isa_intr_establish(struct pckbc_softc *, pckbc_slot_t);
@


1.1.4.4
log
@Merge with the trunk
@
text
@d16 6
@


