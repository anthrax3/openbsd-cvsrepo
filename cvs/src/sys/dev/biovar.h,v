head	1.45;
access;
symbols
	OPENBSD_6_2:1.45.0.2
	OPENBSD_6_2_BASE:1.45
	OPENBSD_6_1:1.45.0.4
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.6
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.43.0.8
	OPENBSD_5_7_BASE:1.43
	OPENBSD_5_6:1.43.0.6
	OPENBSD_5_6_BASE:1.43
	OPENBSD_5_5:1.43.0.4
	OPENBSD_5_5_BASE:1.43
	OPENBSD_5_4:1.42.0.8
	OPENBSD_5_4_BASE:1.42
	OPENBSD_5_3:1.42.0.6
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.4
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.2
	OPENBSD_5_0:1.40.0.2
	OPENBSD_5_0_BASE:1.40
	OPENBSD_4_9:1.38.0.4
	OPENBSD_4_9_BASE:1.38
	OPENBSD_4_8:1.38.0.2
	OPENBSD_4_8_BASE:1.38
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.34.0.6
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.2
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.31.0.2
	OPENBSD_4_4_BASE:1.31
	OPENBSD_4_3:1.28.0.4
	OPENBSD_4_3_BASE:1.28
	OPENBSD_4_2:1.28.0.2
	OPENBSD_4_2_BASE:1.28
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.2
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.20.0.4
	OPENBSD_3_9_BASE:1.20
	OPENBSD_3_8:1.20.0.2
	OPENBSD_3_8_BASE:1.20
	OPENBSD_3_7:1.2.0.8
	OPENBSD_3_7_BASE:1.2
	OPENBSD_3_6:1.2.0.6
	OPENBSD_3_6_BASE:1.2
	SMP_SYNC_A:1.2
	SMP_SYNC_B:1.2
	OPENBSD_3_5:1.2.0.4
	OPENBSD_3_5_BASE:1.2
	OPENBSD_3_4:1.2.0.2
	OPENBSD_3_4_BASE:1.2
	UBC_SYNC_A:1.1
	SMP:1.1.0.8
	OPENBSD_3_3:1.1.0.6
	OPENBSD_3_3_BASE:1.1
	UBC:1.1.0.4
	UBC_SYNC_B:1.1
	OPENBSD_3_2:1.1.0.2
	OPENBSD_3_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.45
date	2016.08.14.04.08.03;	author dlg;	state Exp;
branches;
next	1.44;
commitid	7Sh26Zh99sH8viYr;

1.44
date	2015.05.29.00.33.37;	author uebayasi;	state Exp;
branches;
next	1.43;
commitid	k9pN2wgTn5cUwDek;

1.43
date	2013.10.23.13.05.38;	author kettenis;	state Exp;
branches;
next	1.42;

1.42
date	2012.01.20.12.38.19;	author jsing;	state Exp;
branches;
next	1.41;

1.41
date	2012.01.17.15.15.57;	author jsing;	state Exp;
branches;
next	1.40;

1.40
date	2011.05.20.14.46.44;	author marco;	state Exp;
branches;
next	1.39;

1.39
date	2011.04.14.02.41.40;	author marco;	state Exp;
branches;
next	1.38;

1.38
date	2010.03.26.16.50.59;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2009.12.31.14.00.45;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.23.16.33.59;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2009.11.22.17.01.18;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2008.08.22.02.00.12;	author marco;	state Exp;
branches;
next	1.33;

1.33
date	2008.08.11.17.28.24;	author marco;	state Exp;
branches;
next	1.32;

1.32
date	2008.08.11.17.22.54;	author marco;	state Exp;
branches;
next	1.31;

1.31
date	2008.06.14.18.40.50;	author hshoexer;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.12.00.19.15;	author marco;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.10.23.44.59;	author marco;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.28.21.54.26;	author marco;	state Exp;
branches;
next	1.27;

1.27
date	2007.05.23.21.27.13;	author marco;	state Exp;
branches;
next	1.26;

1.26
date	2007.03.19.03.02.08;	author marco;	state Exp;
branches;
next	1.25;

1.25
date	2006.06.10.18.47.43;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.26.00.09.03;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2006.05.25.22.25.48;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2006.05.25.03.38.34;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2006.05.25.03.11.59;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2005.08.18.09.42.41;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.18.09.10.40;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2005.08.18.04.49.52;	author marco;	state Exp;
branches;
next	1.17;

1.17
date	2005.08.17.22.28.54;	author marco;	state Exp;
branches;
next	1.16;

1.16
date	2005.08.17.21.35.09;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.17.02.32.23;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.16.01.12.46;	author marco;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.09.14.29.18;	author marco;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.08.20.23.46;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2005.08.08.04.02.30;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.08.03.11.36;	author marco;	state Exp;
branches;
next	1.9;

1.9
date	2005.08.01.17.23.14;	author beck;	state Exp;
branches;
next	1.8;

1.8
date	2005.07.29.16.01.29;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.18.15.10.57;	author dlg;	state Exp;
branches;
next	1.6;

1.6
date	2005.07.18.01.29.01;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2005.04.06.02.11.25;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2005.04.04.22.36.29;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.29.22.13.37;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2003.06.03.20.49.28;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.09.22.03.43;	author niklas;	state Exp;
branches
	1.1.4.1
	1.1.8.1;
next	;

1.1.4.1
date	2002.10.29.00.33.23;	author art;	state Exp;
branches;
next	;

1.1.8.1
date	2003.06.07.11.02.28;	author ho;	state Exp;
branches;
next	;


desc
@@


1.45
log
@change some types in bio from u_quad_t to uint64_t, and fix casts in
drivers that fill that field in too.

quad types are going away.
@
text
@/*	$OpenBSD: biovar.h,v 1.44 2015/05/29 00:33:37 uebayasi Exp $	*/

/*
 * Copyright (c) 2002 Niklas Hallqvist.  All rights reserved.
 * Copyright (c) 2005 Marco Peereboom.  All rights reserved.
 * Copyright (c) 2012 Joel Sing <jsing@@openbsd.org>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Devices getting ioctls through this interface should use ioctl class 'B'
 * and command numbers starting from 32, lower ones are reserved for generic
 * ioctls. All ioctl data must be structures which start with a struct bio.
 */

#include <sys/types.h>

#define	BIO_MSG_COUNT	5
#define	BIO_MSG_LEN	128

struct bio_msg {
	int		bm_type;
#define	BIO_MSG_INFO	1
#define	BIO_MSG_WARN	2
#define	BIO_MSG_ERROR	3
	char		bm_msg[BIO_MSG_LEN];
};

struct bio_status {
	char		bs_controller[16];
	int		bs_status;
#define	BIO_STATUS_UNKNOWN	0
#define	BIO_STATUS_SUCCESS	1
#define	BIO_STATUS_ERROR	2
	int		bs_msg_count;
	struct bio_msg	bs_msgs[BIO_MSG_COUNT];
};

struct bio {
	void			*bio_cookie;
	struct bio_status	bio_status;
};

/* convert name to a cookie */
#define BIOCLOCATE _IOWR('B', 0, struct bio_locate)
struct bio_locate {
	struct bio	bl_bio;
	char		*bl_name;
};

#define BIOCINQ _IOWR('B', 32, struct bioc_inq)
struct bioc_inq {
	struct bio	bi_bio;

	char		bi_dev[16];	/* controller device */
	int		bi_novol;	/* nr of volumes */
	int		bi_nodisk;	/* nr of total disks */
};

#define BIOCDISK _IOWR('B', 33, struct bioc_disk)
/* structure that represents a disk in a RAID volume */
struct bioc_disk {
	struct bio	bd_bio;

	u_int16_t	bd_channel;
	u_int16_t	bd_target;
	u_int16_t	bd_lun;
	u_int16_t	bd_other_id;	/* unused for now  */

	int		bd_volid;	/* associate with volume */
	int		bd_diskid;	/* virtual disk */
	int		bd_status;	/* current status */
#define BIOC_SDONLINE		0x00
#define BIOC_SDONLINE_S		"Online"
#define BIOC_SDOFFLINE		0x01
#define BIOC_SDOFFLINE_S	"Offline"
#define BIOC_SDFAILED		0x02
#define BIOC_SDFAILED_S		"Failed"
#define BIOC_SDREBUILD		0x03
#define BIOC_SDREBUILD_S	"Rebuild"
#define BIOC_SDHOTSPARE		0x04
#define BIOC_SDHOTSPARE_S	"Hot spare"
#define BIOC_SDUNUSED		0x05
#define BIOC_SDUNUSED_S		"Unused"
#define BIOC_SDSCRUB		0x06
#define BIOC_SDSCRUB_S		"Scrubbing"
#define BIOC_SDINVALID		0xff
#define BIOC_SDINVALID_S	"Invalid"
	uint64_t	bd_size;	/* size of the disk */

	char		bd_vendor[32];	/* scsi string */
	char		bd_serial[32];	/* serial number */
	char		bd_procdev[16];	/* processor device */

	struct {
		int		bdp_percent;
		int		bdp_seconds;
	}		bd_patrol;
};

#define BIOCVOL _IOWR('B', 34, struct bioc_vol)
/* structure that represents a RAID volume */
struct bioc_vol {
	struct bio	bv_bio;
	int		bv_volid;	/* volume id */

	int16_t		bv_percent;	/* percent done operation */
	u_int16_t	bv_seconds;	/* seconds of progress so far */

	int		bv_status;	/* current status */
#define BIOC_SVONLINE		0x00
#define BIOC_SVONLINE_S		"Online"
#define BIOC_SVOFFLINE		0x01
#define BIOC_SVOFFLINE_S	"Offline"
#define BIOC_SVDEGRADED		0x02
#define BIOC_SVDEGRADED_S	"Degraded"
#define BIOC_SVBUILDING		0x03
#define BIOC_SVBUILDING_S	"Building"
#define BIOC_SVSCRUB		0x04
#define BIOC_SVSCRUB_S		"Scrubbing"
#define BIOC_SVREBUILD		0x05
#define BIOC_SVREBUILD_S	"Rebuild"
#define BIOC_SVINVALID		0xff
#define BIOC_SVINVALID_S	"Invalid"
	uint64_t	bv_size;	/* size of the disk */
	int		bv_level;	/* raid level */
	int		bv_nodisk;	/* nr of drives */
	int		bv_cache;	/* cache mode */
#define BIOC_CVUNKNOWN		0x00
#define BIOC_CVUNKNOWN_S	""
#define BIOC_CVWRITEBACK	0x01
#define BIOC_CVWRITEBACK_S	"WB"
#define BIOC_CVWRITETHROUGH	0x02
#define BIOC_CVWRITETHROUGH_S	"WT"

	char		bv_dev[16];	/* device */
	char		bv_vendor[32];	/* scsi string */
};

#define BIOCALARM _IOWR('B', 35, struct bioc_alarm)
struct bioc_alarm {
	struct bio	ba_bio;
	int		ba_opcode;

	int		ba_status;	/* only used with get state */
#define BIOC_SADISABLE		0x00	/* disable alarm */
#define BIOC_SAENABLE		0x01	/* enable alarm */
#define BIOC_SASILENCE		0x02	/* silence alarm */
#define BIOC_GASTATUS		0x03	/* get status */
#define BIOC_SATEST		0x04	/* test alarm */
};

#define BIOCBLINK _IOWR('B', 36, struct bioc_blink)
struct bioc_blink {
	struct bio	bb_bio;
	u_int16_t	bb_channel;
	u_int16_t	bb_target;

	int		bb_status;	/* current status */
#define BIOC_SBUNBLINK		0x00	/* disable blinking */
#define BIOC_SBBLINK		0x01	/* enable blink */
#define BIOC_SBALARM		0x02	/* enable alarm blink */
};

#define BIOCSETSTATE _IOWR('B', 37, struct bioc_setstate)
struct bioc_setstate {
	struct bio	bs_bio;
	u_int16_t	bs_channel;
	u_int16_t	bs_target;
	u_int16_t	bs_lun;
	u_int16_t	bs_other_id_type; /* use other_id instead of ctl */
#define BIOC_SSOTHER_UNUSED	0x00
#define BIOC_SSOTHER_DEVT	0x01
	int		bs_other_id;	/* cram dev_t or other id in here */

	int		bs_status;	/* change to this status */
#define BIOC_SSONLINE		0x00	/* online disk */
#define BIOC_SSOFFLINE		0x01	/* offline disk */
#define BIOC_SSHOTSPARE		0x02	/* mark as hotspare */
#define BIOC_SSREBUILD		0x03	/* rebuild on this disk */
	int		bs_volid;	/* volume id for rebuild */
};

#define BIOCCREATERAID _IOWR('B', 38, struct bioc_createraid)
struct bioc_createraid {
	struct bio	bc_bio;
	void		*bc_dev_list;
	u_int16_t	bc_dev_list_len;
	int32_t		bc_key_disk;
#define BIOC_CRMAXLEN		1024
	u_int16_t	bc_level;
	u_int32_t	bc_flags;
#define BIOC_SCFORCE		0x01	/* do not assemble, force create */
#define BIOC_SCDEVT		0x02	/* dev_t array or string in dev_list */
#define BIOC_SCNOAUTOASSEMBLE	0x04	/* do not assemble during autoconf */
#define BIOC_SCBOOTABLE		0x08	/* device is bootable */
	u_int32_t	bc_opaque_size;
	u_int32_t	bc_opaque_flags;
#define	BIOC_SOINVALID		0x00	/* no opaque pointer */
#define	BIOC_SOIN		0x01	/* kernel perspective direction */
#define BIOC_SOOUT		0x02	/* kernel perspective direction */
	u_int32_t	bc_opaque_status;
#define	BIOC_SOINOUT_FAILED	0x00	/* operation failed */
#define	BIOC_SOINOUT_OK		0x01	/* operation succeeded */
	void		*bc_opaque;
};

#define BIOCDELETERAID _IOWR('B', 39, struct bioc_deleteraid)
struct bioc_deleteraid {
	struct bio	bd_bio;
	u_int32_t	bd_flags;
#define BIOC_SDCLEARMETA	0x01	/* clear metadata region */
	char		bd_dev[16];	/* device */
};

#define BIOCDISCIPLINE _IOWR('B', 40, struct bioc_discipline)
struct bioc_discipline {
	struct bio	bd_bio;
	char		bd_dev[16];
	u_int32_t	bd_cmd;
	u_int32_t	bd_size;
	void		*bd_data;
};

#define BIOCINSTALLBOOT _IOWR('B', 41, struct bioc_installboot)
struct bioc_installboot {
	struct bio	bb_bio;
	char		bb_dev[16];
	void		*bb_bootblk;
	void		*bb_bootldr;
	u_int32_t	bb_bootblk_size;
	u_int32_t	bb_bootldr_size;
};

#define BIOCPATROL _IOWR('B', 42, struct bioc_patrol)
struct bioc_patrol {
	struct bio	bp_bio;
	int		bp_opcode;
#define BIOC_SPSTOP		0x00	/* stop patrol */
#define BIOC_SPSTART		0x01	/* start patrol */
#define BIOC_GPSTATUS		0x02	/* get status */
#define BIOC_SPDISABLE		0x03	/* disable patrol */
#define BIOC_SPAUTO		0x04	/* enable patrol as auto */
#define BIOC_SPMANUAL		0x05	/* enable patrol as manual */

	int		bp_mode;
#define	BIOC_SPMAUTO		0x00
#define	BIOC_SPMMANUAL		0x01
#define BIOC_SPMDISABLED	0x02
	int		bp_status;	/* only used with get state */
#define	BIOC_SPSSTOPPED		0x00
#define	BIOC_SPSREADY		0x01
#define BIOC_SPSACTIVE		0x02
#define BIOC_SPSABORTED		0xff

	int		bp_autoival;
	int		bp_autonext;
	int		bp_autonow;
};

/* kernel and userspace defines */
#define BIOC_INQ		0x0001
#define BIOC_DISK		0x0002
#define BIOC_VOL		0x0004
#define BIOC_ALARM		0x0008
#define BIOC_BLINK		0x0010
#define BIOC_SETSTATE		0x0020
#define BIOC_CREATERAID		0x0040
#define BIOC_DELETERAID		0x0080
#define BIOC_DISCIPLINE		0x0100
#define BIOC_INSTALLBOOT	0x0200
#define BIOC_PATROL		0x0400

/* user space defines */
#define BIOC_DEVLIST		0x10000

#ifdef _KERNEL
int	bio_register(struct device *, int (*)(struct device *, u_long,
	    caddr_t));
void	bio_unregister(struct device *);

void	bio_status_init(struct bio_status *, struct device *);
void	bio_status(struct bio_status *, int, int, const char *, va_list *);

void	bio_info(struct bio_status *, int, const char *, ...);
void	bio_warn(struct bio_status *, int, const char *, ...);
void	bio_error(struct bio_status *, int, const char *, ...);
#endif
@


1.44
log
@Initial addition of ``Patrol Read'' support in bio(4), biocto(8), and
mfi(4).  Based on FreeBSD, but done without mfiutil(8).

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d108 1
a108 1
	u_quad_t	bd_size;	/* size of the disk */
d144 1
a144 1
	u_quad_t	bv_size;	/* size of the disk */
@


1.43
log
@Add support for displaying the cache write policy of RAID volumes to bioctl(8)
and make mfi(4) pass up the necessary information.  Adding support for other
RAID controllers is left as an excercise to the reader.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.42 2012/01/20 12:38:19 jsing Exp $	*/
d113 5
d254 26
d291 1
@


1.42
log
@Implement a status message interface for bio(4) capable devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.39 2011/04/14 02:41:40 marco Exp $	*/
d142 7
@


1.41
log
@Move the bio(4) cookie into a separate struct and make this struct the
first member of each ioctl data structure. This will allow for future
changes to bio(4) status handling.
@
text
@d6 1
d37 21
d59 2
a60 1
	void		*bio_cookie;
a69 6
#ifdef _KERNEL
int	bio_register(struct device *, int (*)(struct device *, u_long,
    caddr_t));
void	bio_unregister(struct device *);
#endif

d256 13
@


1.40
log
@fix copy and paste in BIOCINSTALLBOOT ioctl number.

found by Vadim Zhukov <persgray@@gmail.com>

ok jsing
@
text
@d31 1
a31 2
 * ioctls.  All ioctl data must be structures which start with a void *
 * cookie.
d36 2
a37 2
struct bio_common {
	void		*bc_cookie;
d43 1
a43 1
	void		*bl_cookie;
d55 1
a55 1
	void		*bi_cookie;
d65 1
a65 1
	void		*bd_cookie;
d101 1
a101 1
	void		*bv_cookie;
d132 1
a132 1
	void		*ba_cookie;
d145 1
a145 1
	void		*bb_cookie;
d157 1
a157 1
	void		*bs_cookie;
d176 1
a176 1
	void		*bc_cookie;
d200 1
a200 1
	void		*bd_cookie;
d208 1
a208 1
	void		*bd_cookie;
d217 1
a217 1
	void		*bb_cookie;
@


1.39
log
@stray space
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.38 2010/03/26 16:50:59 jsing Exp $	*/
d216 1
a216 1
#define BIOCINSTALLBOOT _IOWR('B', 40, struct bioc_installboot)
@


1.38
log
@Add an ioctl to softraid to allow the boot block and boot loader to be
installed on a softraid volume. This is work in progress but can continue
in tree.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.36 2009/11/23 16:33:59 jsing Exp $	*/
d81 1
a81 1
#define BIOC_SDFAILED_S 	"Failed"
@


1.37
log
@Add support for key disks. This allows a crypto volume to be constructed
without using a passphrase - instead the encryption mask key is stored on
the specified key disk partition (ideally being one on a removable device).
This also enables automatic assembly of crypto volumes at boot time.

ok marco@@
@
text
@d187 1
d216 10
d236 1
@


1.36
log
@Improve discipline specific ioctl framework and attach to softraid ioctl.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.35 2009/11/22 17:01:18 jsing Exp $	*/
d180 1
@


1.35
log
@Add a framework for discipline specific ioctls.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.33 2008/08/11 17:28:24 marco Exp $	*/
a40 5
struct bio_device {
	void		*cookie;
	char		dev[16];
};

d205 9
d223 1
@


1.34
log
@Add a hack to manually kick off rebuilds.  This will need some love in the
near future.

ok deraadt
@
text
@d41 5
@


1.33
log
@Undo last commit; deraadt didn't like it.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.32 2008/08/11 17:22:54 marco Exp $	*/
d162 4
a165 1
	u_int16_t	bs_other_id;	/* unused for now  */
@


1.32
log
@Add infrastructure to manually kick off rebuilds.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.31 2008/06/14 18:40:50 hshoexer Exp $	*/
d162 1
a162 4
	u_int16_t	bs_other_id_type; /* use other_id instead of ctl */
#define BIOC_SSOTHER_UNUSED	0x00
#define BIOC_SSOTHER_DEVT	0x01
	int		bs_other_id;	/* cram dev_t or other id in here */
@


1.31
log
@Provide a status field for operations on the bc_opaque data.  Now we're
able to distinguish cleanly an failing ioctl (ie. return value -1) from
trying to retrieve a KDF hint from a not yet initialized volume.

ok marco djm
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.30 2008/06/12 00:19:15 marco Exp $	*/
d162 4
a165 1
	u_int16_t	bs_other_id;	/* unused for now  */
@


1.30
log
@Add delete volume functionality.

discussed with krw, kettenis & drahn
ok hshoexer
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.29 2008/06/10 23:44:59 marco Exp $	*/
d188 3
@


1.29
log
@Add opaque structure to create raid.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.28 2007/05/28 21:54:26 marco Exp $	*/
d191 8
d207 1
@


1.28
log
@Make disk assembly smarter and add two qualifiers to it:
1) noautoassemble; when set the softraid volume will not be assembled during
   autoconf.
2) force; when set it will overwrite metadata on disk

While writing this I ran into 3 bugs that were fixed along the way
1) bcopy in sr_read_meta was copying data to the wrong pointer
2) in sr_read_meta the wrong metadata was coppied into the chunk
3) sr_free_discipline was freing a pointer that wasn't malloc'd

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.27 2007/05/23 21:27:13 marco Exp $	*/
d183 6
@


1.27
log
@Remove all vnode dependencies so that we can bootstrap softraid volumes.
Code from tedu.

Replace all kernel string magic with dev_t passed in from bioctl.
Suggestion from beck and tedu.  Help from miod.

Fix chunk crc.

ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.26 2007/03/19 03:02:08 marco Exp $	*/
d182 1
@


1.26
log
@Add a new device that provides a framework for IO manipulation.  A very basic
implementation of a RAID 1 is included in this but it does not deal with
failures yet.  Disabled in GENERIC.

Suggestions from and ok beck@@ miod@@ krw@@ dlg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.25 2006/06/10 18:47:43 deraadt Exp $	*/
d175 1
a175 1
	char		*bc_dev_list;
d177 1
d179 3
@


1.25
log
@shorten a name for bioctl
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.24 2006/05/26 00:09:03 deraadt Exp $	*/
d168 2
d172 9
d187 4
@


1.24
log
@simplify interface (not binary compatible); ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.23 2006/05/25 22:25:48 deraadt Exp $	*/
d89 1
a89 1
#define BIOC_SDSCRUB_S		"Online/Scrub"
d118 1
a118 1
#define BIOC_SVSCRUB_S		"Online/Scrub"
@


1.23
log
@make an Online/Scrub SD state for marco
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.22 2006/05/25 03:38:34 deraadt Exp $	*/
d41 1
a53 2
/* RAID section */

d68 5
a91 1
	int		bd_resv;	/* align */
a93 5
	/* physical data */
	u_int16_t	bd_channel;
	u_int16_t	bd_target;
	u_int16_t	bd_lun;
	u_int16_t	bd_other_id;	/* unused for now  */
d103 1
a104 1
	int		bv_volid;	/* volume id */
a122 1
	int		bv_resv2;	/* align */
d134 1
a135 2
	int		ba_resv1;	/* for binary compatibility */
	int		ba_resv2;	/* for binary compatibility */
a136 3
	int		ba_resv3;	/* for binary compatibility */

	int		ba_opcode;
d147 2
a149 2
	int		bb_resv1;	/* for binary compatibility */
	int		bb_resv2;	/* for binary compatibility */
a153 3
	int		bb_resv3;	/* for binary compatibility */

	int		bb_target;
d159 4
a163 2
	int		bs_resv1;	/* for binary compatibility */
	int		bs_resv2;	/* for binary compatibility */
a167 8
	int		bs_resv3;	/* for binary compatibility */

	u_int16_t	bs_channel;
	u_int16_t	bs_target;
	u_int16_t	bs_lun;
	u_int16_t	bs_other_id;	/* unused for now  */

	int		bs_resv4;
@


1.22
log
@also provide a seconds-of-progress counter; ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.21 2006/05/25 03:11:59 deraadt Exp $	*/
d84 2
@


1.21
log
@Add a few more volume status values, and a % completion as well, now
that we have a controller which can give more information; ok marco
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.20 2005/08/18 09:42:41 dlg Exp $	*/
d105 3
a107 1
	int		bv_percent;	/* percent done operation */
@


1.20
log
@blinking doesnt care about volid and diskid at the moment. use target
instead
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.19 2005/08/18 09:10:40 dlg Exp $	*/
d105 1
a105 1
	int		bv_resv1;	/* for binary compatibility */
d113 6
@


1.19
log
@fix a pasto by marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.18 2005/08/18 04:49:52 marco Exp $	*/
d145 2
a146 2
	int		bb_volid;	/* volume */
	int		bb_diskid;	/* virtual disk id, -1 all */
a147 3
	int		bb_resv;	/* for binary compatibility */

	int		bb_opcode;
d151 3
@


1.18
log
@Add "create hot spare" ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.17 2005/08/17 22:28:54 marco Exp $	*/
a153 5

	u_int16_t	bs_channel;
	u_int16_t	bs_target;
	u_int16_t	bs_lun;
	u_int16_t	bs_other_id;	/* unused for now  */
@


1.17
log
@Add ioctl for setting the state of disks.
KNF
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.16 2005/08/17 21:35:09 marco Exp $	*/
d154 5
d165 3
a167 3
	int		bs_volid;	/* volume */
	int		bs_diskid;	/* virtual disk */
	int		bs_status;	/* current status */
d171 6
a176 1
	int		bs_resv1;	/* for binary compatibility */
d178 1
a178 1
	int		bs_resv2;
@


1.16
log
@Add blink ioctl.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.14 2005/08/16 01:12:46 marco Exp $	*/
d38 1
a38 1
	void	*bc_cookie;
d43 2
a44 2
	void	*bl_cookie;
	char	*bl_name;
d57 1
a57 1
	void	*bi_cookie;
d59 3
a61 3
	char	bi_dev[16];		/* controller device */
	int	bi_novol;		/* nr of volumes */
	int	bi_nodisk;		/* nr of total disks */
d69 3
a71 3
	int		bd_volid;		/* associate with volume, if -1 unused */
	int		bd_diskid;		/* virtual disk id */
	int		bd_status;		/* current status */
d86 2
a87 2
	int		bd_resv;		/* align */
	u_quad_t	bd_size;		/* size of the disk */
d93 4
a96 4
	u_int16_t	bd_other_id;	/* unused for now but needed for sas/fc */
	char		bd_vendor[32];		/* scsi string */
	char		bd_serial[32];		/* serial number */
	char		bd_procdev[16];		/* processor device */
d104 3
a106 3
	int		bv_volid;		/* volume id */
	int		bv_resv1;		/* for binary compatibility */
	int		bv_status;		/* current status */
d115 4
a118 4
	int		bv_resv2;		/* align */
	u_quad_t	bv_size;		/* size of the disk */
	int		bv_level;		/* raid level */
	int		bv_nodisk;		/* nr of drives */
d120 2
a121 2
	char		bv_dev[16];		/* device */
	char		bv_vendor[32];		/* scsi string */
d126 1
a126 1
	void	*ba_cookie;
d128 4
a131 4
	int	ba_resv1;		/* for binary compatibility */
	int	ba_resv2;		/* for binary compatibility */
	int	ba_status;		/* only used with get state */
	int	ba_resv3;		/* for binary compatibility */
d133 1
a133 1
	int	ba_opcode;
d145 1
a145 1
	int		bb_volid;	/* volume, -1 unused */
d156 21
a176 5
#define BIOC_INQ		0x01
#define BIOC_DISK		0x02
#define BIOC_VOL		0x04
#define BIOC_ALARM		0x08
#define BIOC_BLINK		0x10
@


1.15
log
@add bio_unregister so drivers can remove their bio entry on error or
detach.

ok marco@@ after i proved i had tested it.
@
text
@d141 15
d160 1
@


1.14
log
@Fix a few retardos.  Yelled at by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.13 2005/08/09 14:29:18 marco Exp $	*/
d50 1
@


1.13
log
@Provide HDD serial numbers to bio.  Requested deraadt@@ ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.12 2005/08/08 20:23:46 marco Exp $	*/
d93 1
a93 4
	char		bd_vendor[8];		/* vendor string */
	char		bd_product[16];		/* product string */
	char		bd_revision[4];		/* revision string */
	char		bd_pad[4];		/* zero terminate in here */
d120 1
a120 4
	char		bv_vendor[8];		/* vendor string */
	char		bv_product[16];		/* product string */
	char		bv_revision[4];		/* revision string */
	char		bv_pad[4];		/* zero terminate in here */
@


1.12
log
@Add ses link.  Tested and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.11 2005/08/08 04:02:30 deraadt Exp $	*/
d97 1
a97 1
	char		bd_serial[16];		/* serial number */
@


1.11
log
@rename a bunch of bio/raid APIs to stop the bleeding in dlg and
my eyes; marco ok
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.9 2005/08/01 17:23:14 beck Exp $	*/
d97 2
a98 1
	char		bd_serial[16];
@


1.10
log
@Add devices to structures.

ok and help deraadt@@
@
text
@d38 1
a38 1
	void *cookie;
d43 2
a44 2
	void *cookie;
	char *name;
d54 8
a61 9
#define BIOCINQ _IOWR('B', 32, bioc_inq)
typedef struct _bioc_inq {
	void *cookie;

	int novol;		/* nr of volumes */
	int nodisk;		/* nr of total disks */

	char dev[16];		/* controller device */
} bioc_inq;
d63 1
a63 1
#define BIOCDISK _IOWR('B', 33, bioc_disk)
d65 2
a66 2
typedef struct _bioc_disk {
	void *cookie;
d68 3
a70 3
	int volid;		/* associate with volume, if -1 unused */
	int diskid;		/* virtual disk id */
	int status;		/* current status */
d85 2
a86 9
	int resv;		/* align */

	u_quad_t size;		/* size of the disk */

	/* this is provided by the physical disks if suported */
	char vendor[8];		/* vendor string */
	char product[16];	/* product string */
	char revision[4];	/* revision string */
	char pad[4];		/* zero terminate in here */
d89 10
a98 8
	u_int16_t channel;
	u_int16_t target;
	u_int16_t lun;
	u_int16_t other_id;	/* unused for now but needed for sas/fc */

	/* XXX get this too? */
				/* serial number */
} bioc_disk;
d100 1
a100 1
#define BIOCVOL _IOWR('B', 34, bioc_vol)
d102 2
a103 2
typedef struct _bioc_vol {
	void *cookie;
d105 3
a107 3
	int	volid;		/* volume id */
	int	resv1;		/* for binary compatibility */
	int	status;		/* current status */
d116 11
a126 10
	int	resv2;		/* align */
	u_quad_t size;		/* size of the disk */
	int	level;		/* raid level */
	int	nodisk;		/* nr of drives */

	/* this is provided by the RAID card */
	char	vendor[8];	/* vendor string */
	char	product[16];	/* product string */
	char	revision[4];	/* revision string */
	char	pad[4];		/* zero terminate in here */
d128 8
a135 3
	/* physical data */
	char	dev[16];	/* device */
} bioc_vol;
d137 1
a137 10
#define BIOCALARM _IOWR('B', 35, bioc_alarm)
typedef struct _bioc_alarm {
	void *cookie;

	int resv1;		/* for binary compatibility */
	int resv2;		/* for binary compatibility */
	int status;		/* only used with get state */
	int resv3;		/* for binary compatibility */

	int opcode;
d143 1
a143 1
} bioc_alarm;
@


1.9
log
@Unbreak tree after marco forgotten commit. Then phoning marco to bitch him out.
no objections krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.8 2005/07/29 16:01:29 marco Exp $	*/
d60 2
d88 1
a88 1
	quad_t size;		/* size of the disk */
d96 6
d111 3
a113 3
	int volid;		/* volume id */
	int resv1;		/* for binary compatibility */
	int status;		/* current status */
d122 4
a125 4
	int resv2;		/* align */
	quad_t size;		/* size of the disk */
	int level;		/* raid level */
	int nodisk;		/* nr of drives */
d128 7
a134 4
	char vendor[8];		/* vendor string */
	char product[16];	/* product string */
	char revision[4];	/* revision string */
	char pad[4];		/* zero terminate in here */
@


1.8
log
@Redo bioctl because initial implementation was too complex.

tested and ok dlg@@ beck@@
get it in @@deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.6 2005/07/18 01:29:01 marco Exp $	*/
d126 21
a146 3
#define BIOC_INQ	0x01
#define BIOC_DISK	0x02
#define BIOC_VOL	0x04
@


1.7
log
@revert marcos bio changes, mickey not ok
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.5 2005/04/06 02:11:25 marco Exp $	*/
d5 1
d54 2
a55 9
#define BIOC_MAX_CDB   16
#define BIOC_MAX_SENSE 32
#define BIOC_MAX_PHYSDISK 128	/* based on FC arrays */
#define BIOC_MAX_VIRTDISK 128	/* based on FC arrays */

/* ioctl tunnel defines */
/* SHALL be implemented */
#define BIOCPING _IOWR('B', 32, bioc_ping)
typedef struct _bioc_ping {
a56 133
	int x;
} bioc_ping;

/* SHALL be implemented */
#define BIOCCAPABILITIES _IOWR('B', 33, bioc_capabilities)
typedef struct _bioc_capabilities {
	void *cookie;
	u_int64_t ioctls; /* bit field, 1 ioctl supported */
#define BIOC_PING         0x01
#define BIOC_ALARM        0x02
#define BIOC_PREP_REMOVAL 0x04
#define BIOC_REBUILD      0x08
#define BIOC_STATUS       0x10
#define BIOC_SCSICMD      0x20
#define BIOC_STARTSTOP    0x40
#define BIOC_BLINK        0x80
	u_int32_t raid_types; /* bit field, 1 supported raid type */
#define BIOC_RAID0  0x01
#define BIOC_RAID1  0x02
#define BIOC_RAID3  0x04
#define BIOC_RAID5  0x08
#define BIOC_RAID10 0x10
#define BIOC_RAID01 0x20
#define BIOC_RAID50 0x40
} bioc_capabilities;

/* OPTIONAL */
#define BIOCALARM _IOWR('B', 34, bioc_alarm)
typedef struct _bioc_alarm {
	void *cookie;
	u_int32_t opcode;
#define BIOCSALARM_DISABLE 0x00
#define BIOCSALARM_ENABLE  0x01
#define BIOCSALARM_SILENCE 0x02
#define BIOCGALARM_STATE   0x03
#define BIOCSALARM_TEST    0x04
	u_int8_t state; /* only used with GET function */
} bioc_alarm;

/* OPTIONAL */
#define BIOCSCSICMD _IOWR('B', 35, bioc_scsicmd)
typedef struct _bioc_scsicmd {
	void *cookie;

	/* in (kernel centric) */
	u_int8_t channel;
	u_int8_t target;
	u_int8_t cdb[BIOC_MAX_CDB];
	u_int8_t cdblen;
	u_int8_t direction; /* 0 = out, 1 = in, this is userland centric */
#define BIOC_DIROUT  0x00
#define BIOC_DIRIN   0x01
#define BIOC_DIRNONE 0x02

	/* out (kernel centric) */
	u_int8_t status;
	u_int8_t sensebuf[BIOC_MAX_SENSE];
	u_int8_t senselen;

	/* in & out (kernel centric) */
	void *data;
	u_int32_t datalen; /* going in it governs the maximum buffer size
			      going out it contains actual bytes transfered */
} bioc_scsicmd;

/* OPTIONAL */
#define BIOCSTARTSTOP _IOWR('B', 36, bioc_startstop)
typedef struct _bioc_startstop {
	void *cookie;
	u_int8_t opcode;
#define BIOCSUNIT_START 0x00
#define BIOCSUNIT_STOP  0x01
	u_int8_t channel;
	u_int8_t target;
} bioc_startstop;

/* SHALL be implemented */
#define BIOCSTATUS _IOWR('B', 37, bioc_status)
typedef struct _bioc_status {
	void *cookie;
	u_int8_t opcode;
#define BIOCGSTAT_CHANGE	0x00	/* any changes since last call? */
#define BIOCGSTAT_ALL		0x01	/* get all status */
#define BIOCGSTAT_PHYSDISK	0x02	/* get physical disk status only */
#define BIOCGSTAT_VIRTDISK	0x03	/* get virtual disk status only */
#define BIOCGSTAT_BATTERY	0x04	/* get battery status only */
#define BIOCGSTAT_ENCLOSURE	0x05	/* get enclosure status only */
#define BIOCGSTAT_TEMPERATURE	0x06	/* get temperature status only */
	u_int8_t status;		/* global status flag */
#define BIOC_STATOK	0x00		/* status is OK */
#define BIOC_STATDEGRAD 0x01		/* status is degraded */
#define BIOC_STATCRIT	0x02		/* status is critical */
#define BIOC_STATBAT	0x04		/* something wrong with battery */
#define BIOC_STATENC	0x08		/* something wrong with enclosure */
#define BIOC_STATTEMP	0x10		/* something is over/under heating */
	/* return fields used per request define in opcode */
	u_int8_t	channels;	/* max channels */
	u_int8_t	buswidth;	/* max physical drives per channel */
	/* filled in when called with BIOCGSTAT_PHYSDISK set */
	u_int8_t pdcount;		/* physical disk counter */
	u_int8_t physdisk[BIOC_MAX_PHYSDISK];
#define BIOC_PDUNUSED	0x00		/* disk not present */
#define BIOC_PDONLINE	0x01		/* disk present */
#define BIOC_PDOFFLINE	0x02		/* disk present but offline */
#define BIOC_PDINUSE	0x04		/* critical operation in progress */
	/* filled in when called with BIOCGSTAT_VIRTDISK set */
	u_int8_t vdcount;		/* virtual disk counter */
	u_int8_t virtdisk[BIOC_MAX_VIRTDISK];
#define BIOC_VDUNUSED	0x00		/* disk not present */
#define BIOC_VDONLINE	0x01		/* disk present */
#define BIOC_VDOFFLINE	0x02		/* disk present but offline */
#define BIOC_VDINUSE	0x04		/* critical operation in progress */
	/* filled in when called with BIOCGSTAT_BATTERY set */
	u_int8_t	batstat;	/* battery status */
#define BIOC_BATNOTPRES	0x00		/* battery not present */
#define BIOC_BATMISSING 0x01		/* battery removed */
#define BIOC_BATVOLTERR	0x02		/* battery low/high power */
#define BIOC_BATTEMP	0x04		/* battery over/under temp*/
	/* NOTYET: encloure status & temperature status */
} bioc_status;

/* OPTIONAL */
/* depending on the controller it is handled either in userland or in kernel */
#define BIOCBLINK _IOWR('B', 38, bioc_blink)
typedef struct _bioc_blink {
	void *cookie;
	u_int8_t opcode;
#define BIOCSBLINK_BLINK   0x00
#define BIOCSBLINK_UNBLINK 0x01
#define BIOCSBLINK_ALERT   0x02
	u_int8_t channel;
	u_int8_t target;
} bioc_blink;
d58 71
@


1.6
log
@Rip out all previous bio code because it sucked.  Replaced all ioctl code in
ami(4) and bio(4).

Note that this will break trees where userland and kernel are not in sync.

ok dlg@@
@
text
@d53 9
a61 2
#define BIOCINQ _IOWR('B', 32, bioc_inq)
typedef struct _bioc_inq {
d63 133
a196 49
	int novol;	/* nr of volumes */
	int nodisk;	/* nr of total disks */
} bioc_inq;

#define BIOCDISK _IOWR('B', 33, bioc_disk)
/* structure that represents a disk in a RAID volume */
typedef struct _bioc_disk {
	void *cookie;

	int diskid;	/* virtual disk id */
	int status;	/* current status */
	int volid;	/* associate with volume, if -1 unused */

	quad_t size;	/* size of the disk */

	/* this is provided by the physical disks if suported */
	char vendor[8];		/* vendor string */
	char product[16];	/* product string */
	char revision[4];	/* revision string */
	char pad[4];		/* zero terminate in here */

	/* XXX get this too? */
				/* serial number */
} bioc_disk;

#define BIOCVOL _IOWR('B', 34, bioc_vol)
/* structure that represents a RAID volume */
typedef struct _bioc_vol {
	void *cookie;

	int volid;	/* volume id */
	int status;	/* current status */
#define BIOC_SONLINE	0x00
#define BIOC_SOFFLINE	0x01
#define BIOC_SDEGRADED	0x02
	quad_t size;	/* size of the disk */
	int level;	/* raid level */
	int nodisk;	/* nr of drives */

	/* this is provided by the RAID card */
	char vendor[8];		/* vendor string */
	char product[16];	/* product string */
	char revision[4];	/* revision string */
	char pad[4];		/* zero terminate in here */
} bioc_vol;

#define BIOC_INQ	0x01
#define BIOC_DISK	0x02
#define BIOC_VOL	0x04
@


1.5
log
@Add alert blink.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.4 2005/04/04 22:36:29 marco Exp $	*/
d53 2
a54 9
#define BIOC_MAX_CDB   16
#define BIOC_MAX_SENSE 32
#define BIOC_MAX_PHYSDISK 128	/* based on FC arrays */
#define BIOC_MAX_VIRTDISK 128	/* based on FC arrays */

/* ioctl tunnel defines */
/* SHALL be implemented */
#define BIOCPING _IOWR('B', 32, bioc_ping)
typedef struct _bioc_ping {
a55 133
	int x;
} bioc_ping;

/* SHALL be implemented */
#define BIOCCAPABILITIES _IOWR('B', 33, bioc_capabilities)
typedef struct _bioc_capabilities {
	void *cookie;
	u_int64_t ioctls; /* bit field, 1 ioctl supported */
#define BIOC_PING         0x01
#define BIOC_ALARM        0x02
#define BIOC_PREP_REMOVAL 0x04
#define BIOC_REBUILD      0x08
#define BIOC_STATUS       0x10
#define BIOC_SCSICMD      0x20
#define BIOC_STARTSTOP    0x40
#define BIOC_BLINK        0x80
	u_int32_t raid_types; /* bit field, 1 supported raid type */
#define BIOC_RAID0  0x01
#define BIOC_RAID1  0x02
#define BIOC_RAID3  0x04
#define BIOC_RAID5  0x08
#define BIOC_RAID10 0x10
#define BIOC_RAID01 0x20
#define BIOC_RAID50 0x40
} bioc_capabilities;

/* OPTIONAL */
#define BIOCALARM _IOWR('B', 34, bioc_alarm)
typedef struct _bioc_alarm {
	void *cookie;
	u_int32_t opcode;
#define BIOCSALARM_DISABLE 0x00
#define BIOCSALARM_ENABLE  0x01
#define BIOCSALARM_SILENCE 0x02
#define BIOCGALARM_STATE   0x03
#define BIOCSALARM_TEST    0x04
	u_int8_t state; /* only used with GET function */
} bioc_alarm;

/* OPTIONAL */
#define BIOCSCSICMD _IOWR('B', 35, bioc_scsicmd)
typedef struct _bioc_scsicmd {
	void *cookie;

	/* in (kernel centric) */
	u_int8_t channel;
	u_int8_t target;
	u_int8_t cdb[BIOC_MAX_CDB];
	u_int8_t cdblen;
	u_int8_t direction; /* 0 = out, 1 = in, this is userland centric */
#define BIOC_DIROUT  0x00
#define BIOC_DIRIN   0x01
#define BIOC_DIRNONE 0x02

	/* out (kernel centric) */
	u_int8_t status;
	u_int8_t sensebuf[BIOC_MAX_SENSE];
	u_int8_t senselen;

	/* in & out (kernel centric) */
	void *data;
	u_int32_t datalen; /* going in it governs the maximum buffer size
			      going out it contains actual bytes transfered */
} bioc_scsicmd;

/* OPTIONAL */
#define BIOCSTARTSTOP _IOWR('B', 36, bioc_startstop)
typedef struct _bioc_startstop {
	void *cookie;
	u_int8_t opcode;
#define BIOCSUNIT_START 0x00
#define BIOCSUNIT_STOP  0x01
	u_int8_t channel;
	u_int8_t target;
} bioc_startstop;

/* SHALL be implemented */
#define BIOCSTATUS _IOWR('B', 37, bioc_status)
typedef struct _bioc_status {
	void *cookie;
	u_int8_t opcode;
#define BIOCGSTAT_CHANGE	0x00	/* any changes since last call? */
#define BIOCGSTAT_ALL		0x01	/* get all status */
#define BIOCGSTAT_PHYSDISK	0x02	/* get physical disk status only */
#define BIOCGSTAT_VIRTDISK	0x03	/* get virtual disk status only */
#define BIOCGSTAT_BATTERY	0x04	/* get battery status only */
#define BIOCGSTAT_ENCLOSURE	0x05	/* get enclosure status only */
#define BIOCGSTAT_TEMPERATURE	0x06	/* get temperature status only */
	u_int8_t status;		/* global status flag */
#define BIOC_STATOK	0x00		/* status is OK */
#define BIOC_STATDEGRAD 0x01		/* status is degraded */
#define BIOC_STATCRIT	0x02		/* status is critical */
#define BIOC_STATBAT	0x04		/* something wrong with battery */
#define BIOC_STATENC	0x08		/* something wrong with enclosure */
#define BIOC_STATTEMP	0x10		/* something is over/under heating */
	/* return fields used per request define in opcode */
	u_int8_t	channels;	/* max channels */
	u_int8_t	buswidth;	/* max physical drives per channel */
	/* filled in when called with BIOCGSTAT_PHYSDISK set */
	u_int8_t pdcount;		/* physical disk counter */
	u_int8_t physdisk[BIOC_MAX_PHYSDISK];
#define BIOC_PDUNUSED	0x00		/* disk not present */
#define BIOC_PDONLINE	0x01		/* disk present */
#define BIOC_PDOFFLINE	0x02		/* disk present but offline */
#define BIOC_PDINUSE	0x04		/* critical operation in progress */
	/* filled in when called with BIOCGSTAT_VIRTDISK set */
	u_int8_t vdcount;		/* virtual disk counter */
	u_int8_t virtdisk[BIOC_MAX_VIRTDISK];
#define BIOC_VDUNUSED	0x00		/* disk not present */
#define BIOC_VDONLINE	0x01		/* disk present */
#define BIOC_VDOFFLINE	0x02		/* disk present but offline */
#define BIOC_VDINUSE	0x04		/* critical operation in progress */
	/* filled in when called with BIOCGSTAT_BATTERY set */
	u_int8_t	batstat;	/* battery status */
#define BIOC_BATNOTPRES	0x00		/* battery not present */
#define BIOC_BATMISSING 0x01		/* battery removed */
#define BIOC_BATVOLTERR	0x02		/* battery low/high power */
#define BIOC_BATTEMP	0x04		/* battery over/under temp*/
	/* NOTYET: encloure status & temperature status */
} bioc_status;

/* OPTIONAL */
/* depending on the controller it is handled either in userland or in kernel */
#define BIOCBLINK _IOWR('B', 38, bioc_blink)
typedef struct _bioc_blink {
	void *cookie;
	u_int8_t opcode;
#define BIOCSBLINK_BLINK   0x00
#define BIOCSBLINK_UNBLINK 0x01
#define BIOCSBLINK_ALERT   0x02
	u_int8_t channel;
	u_int8_t target;
} bioc_blink;
d57 49
@


1.4
log
@add blink and unblink.
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.3 2005/03/29 22:13:37 marco Exp $	*/
d192 1
@


1.3
log
@add raid defines

ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.2 2003/06/03 20:49:28 deraadt Exp $	*/
d78 1
d183 13
@


1.2
log
@fix various 3/4 licenses according to "terms" file
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.1 2002/06/09 22:03:43 niklas Exp $	*/
d34 2
d50 132
@


1.1
log
@bio is a driver that can delegate ioctls to other drivers which
otherwise do not deserve a /dev-node of their own.  Will be used for RAID
mgmt among other things.  Initially only i386 gets the device, but other
platforms will follow in a few hours.  MAKEDEV stuff coming soon too.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a13 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Niklas Hallqvist.
 * 4. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
@


1.1.8.1
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: biovar.h,v 1.1 2002/06/09 22:03:43 niklas Exp $	*/
d14 5
@


1.1.4.1
log
@sync to -current
@
text
@@

