head	1.15;
access;
symbols
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.14
	SMP_SYNC_B:1.14
	OPENBSD_3_5:1.14.0.2
	OPENBSD_3_5_BASE:1.14
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.13
	SMP:1.12.0.4
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	UBC:1.4.0.2
	UBC_SYNC_B:1.4
	OPENBSD_3_2:1.3.0.2
	OPENBSD_3_2_BASE:1.3;
locks; strict;
comment	@ * @;


1.15
date	2005.03.05.23.58.44;	author tdeval;	state dead;
branches;
next	1.14;

1.14
date	2003.10.22.09.31.30;	author jmc;	state Exp;
branches;
next	1.13;

1.13
date	2003.04.27.11.22.53;	author ho;	state Exp;
branches;
next	1.12;

1.12
date	2003.01.13.07.16.20;	author tdeval;	state Exp;
branches
	1.12.4.1;
next	1.11;

1.11
date	2003.01.12.12.05.04;	author tdeval;	state Exp;
branches;
next	1.10;

1.10
date	2003.01.06.11.33.28;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2002.12.30.11.12.12;	author tdeval;	state Exp;
branches;
next	1.8;

1.8
date	2002.12.13.22.54.29;	author tdeval;	state Exp;
branches;
next	1.7;

1.7
date	2002.12.13.22.40.16;	author tdeval;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.13.21.35.11;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.13.02.52.04;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2002.10.12.02.03.46;	author krw;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2002.07.07.13.41.27;	author tdeval;	state Exp;
branches;
next	1.2;

1.2
date	2002.06.26.15.52.13;	author tdeval;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.25.17.11.49;	author itojun;	state Exp;
branches;
next	;

1.4.2.1
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;

1.12.4.1
date	2003.05.13.19.35.02;	author ho;	state Exp;
branches;
next	1.12.4.2;

1.12.4.2
date	2004.02.19.10.56.21;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Clean up the tree from incomplete, unreliable and unsupported IEEE1394 code.
Ok deraadt@@, miod@@
@
text
@/*	$OpenBSD: fwohci.c,v 1.14 2003/10/22 09:31:30 jmc Exp $	*/
/*	$NetBSD: fwohci.c,v 1.54 2002/03/29 05:06:42 jmc Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Matt Thomas of 3am Software Foundry.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * IEEE1394 Open Host Controller Interface
 *	based on OHCI Specification 1.1 (January 6, 2000)
 * The first version to support network interface part is wrtten by
 * Atsushi Onoe <onoe@@netbsd.org>.
 */

/*
 * The first version to support isochronous acquisition part is wrtten
 * by HAYAKAWA Koichi <haya@@netbsd.org>.
 */

#include <sys/cdefs.h>
#ifdef	__KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: fwohci.c,v 1.54 2002/03/29 05:06:42 jmc Exp $");
#endif

#define	DOUBLEBUF 0
#define	NO_THREAD 0

#ifdef	__NetBSD__
#include "opt_inet.h"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kthread.h>
#include <sys/socket.h>
#ifdef	__NetBSD__
#include <sys/callout.h>
#else
#include <sys/timeout.h>
#endif
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/mbuf.h>
#ifdef	__OpenBSD__
#include <sys/endian.h>
#endif

#if	__NetBSD_Version__ >= 105010000 || !defined(__NetBSD__)
#include <uvm/uvm_extern.h>
#else
#include <vm/vm.h>
#endif

#include <machine/bus.h>
#include <machine/intr.h>

#include <dev/ieee1394/ieee1394reg.h>
#include <dev/ieee1394/fwohcireg.h>

#include <dev/ieee1394/ieee1394var.h>
#include <dev/ieee1394/fwohcivar.h>

const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
const char * const ieee1394_power[] = { IEEE1394_POW_STRINGS };

#if 0
int fwohci_dmamem_alloc(struct fwohci_softc *sc, int size,
    int alignment, bus_dmamap_t *mapp, caddr_t *kvap, int flags);
#endif
void fwohci_create_event_thread(void *);
void fwohci_thread_init(void *);

void fwohci_event_thread(struct fwohci_softc *);
void fwohci_event_dispatch(struct fwohci_softc *);
void fwohci_hw_init(struct fwohci_softc *);
void fwohci_power(int, void *);
void fwohci_shutdown(void *);

int  fwohci_desc_alloc(struct fwohci_softc *);
void fwohci_desc_free(struct fwohci_softc *);
struct fwohci_desc *fwohci_desc_get(struct fwohci_softc *, int);
void fwohci_desc_put(struct fwohci_softc *, struct fwohci_desc *, int);

int  fwohci_ctx_alloc(struct fwohci_softc *, struct fwohci_ctx **,
    int, int, int);
void fwohci_ctx_free(struct fwohci_softc *, struct fwohci_ctx *);
void fwohci_ctx_init(struct fwohci_softc *, struct fwohci_ctx *);

int  fwohci_buf_alloc(struct fwohci_softc *, struct fwohci_buf *);
void fwohci_buf_free(struct fwohci_softc *, struct fwohci_buf *);
void fwohci_buf_init_rx(struct fwohci_softc *);
void fwohci_buf_start_rx(struct fwohci_softc *);
void fwohci_buf_stop_rx(struct fwohci_softc *);
void fwohci_buf_stop_tx(struct fwohci_softc *);
void fwohci_buf_next(struct fwohci_softc *, struct fwohci_ctx *);
int  fwohci_buf_pktget(struct fwohci_softc *, struct fwohci_buf **,
    caddr_t *, int);
int  fwohci_buf_input(struct fwohci_softc *, struct fwohci_ctx *,
    struct fwohci_pkt *);
int  fwohci_buf_input_ppb(struct fwohci_softc *, struct fwohci_ctx *,
    struct fwohci_pkt *);

u_int8_t fwohci_phy_read(struct fwohci_softc *, u_int8_t);
void fwohci_phy_write(struct fwohci_softc *, u_int8_t, u_int8_t);
void fwohci_phy_busreset(struct fwohci_softc *);
void fwohci_phy_input(struct fwohci_softc *, struct fwohci_pkt *);

int  fwohci_handler_set(struct fwohci_softc *, int, u_int32_t, u_int32_t,
    u_int32_t, int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *);
int  fwohci_block_handler_set(struct fwohci_softc *, int, u_int32_t, u_int32_t,
    u_int32_t, int, int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *);

void fwohci_arrq_input(struct fwohci_softc *, struct fwohci_ctx *);
void fwohci_arrs_input(struct fwohci_softc *, struct fwohci_ctx *);
void fwohci_ir_input(struct fwohci_softc *, struct fwohci_ctx *);

int  fwohci_at_output(struct fwohci_softc *, struct fwohci_ctx *,
    struct fwohci_pkt *);
void fwohci_at_done(struct fwohci_softc *, struct fwohci_ctx *, int);
void fwohci_atrs_output(struct fwohci_softc *, int, struct fwohci_pkt *,
    struct fwohci_pkt *);

int  fwohci_guidrom_init(struct fwohci_softc *);
void fwohci_configrom_init(struct fwohci_softc *);
int  fwohci_configrom_input(struct fwohci_softc *, void *,
    struct fwohci_pkt *);
void fwohci_selfid_init(struct fwohci_softc *);
int  fwohci_selfid_input(struct fwohci_softc *);

void fwohci_csr_init(struct fwohci_softc *);
int  fwohci_csr_input(struct fwohci_softc *, void *,
    struct fwohci_pkt *);

void fwohci_uid_collect(struct fwohci_softc *);
void fwohci_uid_req(struct fwohci_softc *, int);
int  fwohci_uid_input(struct fwohci_softc *, void *,
    struct fwohci_pkt *);
int  fwohci_uid_lookup(struct fwohci_softc *, const u_int8_t *);
void fwohci_check_nodes(struct fwohci_softc *);

int  fwohci_if_inreg(struct device *, u_int32_t, u_int32_t,
    void (*)(struct device *, struct mbuf *));
int  fwohci_if_input(struct fwohci_softc *, void *, struct fwohci_pkt *);
int  fwohci_if_input_iso(struct fwohci_softc *, void *, struct fwohci_pkt *);
int  fwohci_if_output(struct device *, struct mbuf *,
    void (*)(struct device *, struct mbuf *));
int fwohci_if_setiso(struct device *, u_int32_t, u_int32_t, u_int32_t,
    void (*)(struct device *, struct mbuf *));
int  fwohci_read(struct ieee1394_abuf *);
int  fwohci_write(struct ieee1394_abuf *);
int  fwohci_read_resp(struct fwohci_softc *, void *, struct fwohci_pkt *);
int  fwohci_write_ack(struct fwohci_softc *, void *, struct fwohci_pkt *);
int  fwohci_read_multi_resp(struct fwohci_softc *, void *,
    struct fwohci_pkt *);
int  fwohci_inreg(struct ieee1394_abuf *, int);
int  fwohci_unreg(struct ieee1394_abuf *, int);
int  fwohci_parse_input(struct fwohci_softc *, void *,
    struct fwohci_pkt *);
#ifdef	__NetBSD__
int  fwohci_submatch(struct device *, struct cfdata *, void *);
#else
int  fwohci_submatch(struct device *, void *, void *);
#endif
u_int16_t fwohci_crc16(u_int32_t *, int);

#ifdef	FWOHCI_DEBUG
void fwohci_show_intr(struct fwohci_softc *, u_int32_t);
void fwohci_show_phypkt(struct fwohci_softc *, u_int32_t);

/* 1 is normal debug, 2 is verbose debug, 3 is complete (packet dumps). */

#include <sys/syslog.h>
extern int log_open;
int fwohci_oldlog;
#define	DPRINTF(x)	if (fwohcidebug) do {				\
	fwohci_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwohci_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (fwohcidebug>(n)) do {			\
	fwohci_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwohci_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	fwohcidebug = 0;
int	fwintr = 0;
caddr_t	fwptr = 0;
int	fwlen = 0;
struct fwohci_buf *fwbuf = NULL;
#else	/* FWOHCI_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! FWOHCI_DEBUG */

#ifdef	__OpenBSD__
struct cfdriver fwohci_cd = {
	NULL, "fwohci", DV_DULL
};
#endif

int
fwohci_init(struct fwohci_softc *sc, const struct evcnt *ev)
{
	int i;
	u_int32_t val;
#if 0
	int error;
#endif

#ifdef	__NetBSD__
	evcnt_attach_dynamic(&sc->sc_intrcnt, EVCNT_TYPE_INTR, ev,
	    sc->sc_sc1394.sc1394_dev.dv_xname, "intr");

	evcnt_attach_dynamic(&sc->sc_isocnt, EVCNT_TYPE_MISC, ev,
	    sc->sc_sc1394.sc1394_dev.dv_xname, "iso");
	evcnt_attach_dynamic(&sc->sc_isopktcnt, EVCNT_TYPE_MISC, ev,
	    sc->sc_sc1394.sc1394_dev.dv_xname, "isopackets");
#endif

	/*
	 * Wait for reset completion.
	 */
	for (i = 0; i < OHCI_LOOP; i++) {
		val = OHCI_CSR_READ(sc, OHCI_REG_HCControlClear);
		if ((val & OHCI_HCControl_SoftReset) == 0)
			break;
		DELAY(10);
	}

	/*
	 * What dialect of OHCI is this device ?
	 */
	val = OHCI_CSR_READ(sc, OHCI_REG_Version);
	printf("%s: OHCI %u.%u", sc->sc_sc1394.sc1394_dev.dv_xname,
	    OHCI_Version_GET_Version(val), OHCI_Version_GET_Revision(val));

	LIST_INIT(&sc->sc_nodelist);

	if (fwohci_guidrom_init(sc) != 0) {
		printf("\n%s: fatal: no global UID ROM\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
		return -1;
	}

	printf(", %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x",
	    sc->sc_sc1394.sc1394_guid[0], sc->sc_sc1394.sc1394_guid[1],
	    sc->sc_sc1394.sc1394_guid[2], sc->sc_sc1394.sc1394_guid[3],
	    sc->sc_sc1394.sc1394_guid[4], sc->sc_sc1394.sc1394_guid[5],
	    sc->sc_sc1394.sc1394_guid[6], sc->sc_sc1394.sc1394_guid[7]);

	/*
	 * Get the maximum link speed and receive size.
	 */
	val = OHCI_CSR_READ(sc, OHCI_REG_BusOptions);
	sc->sc_sc1394.sc1394_link_speed =
	    OHCI_BITVAL(val, OHCI_BusOptions_LinkSpd);
	if (sc->sc_sc1394.sc1394_link_speed < IEEE1394_SPD_MAX) {
		printf(", %s",
		    ieee1394_speeds[sc->sc_sc1394.sc1394_link_speed]);
	} else {
		printf(", unknown speed %u", sc->sc_sc1394.sc1394_link_speed);
	}

	/*
	 * MaxRec is encoded as log2(max_rec_octets)-1
	 */
	sc->sc_sc1394.sc1394_max_receive =
	    1 << (OHCI_BITVAL(val, OHCI_BusOptions_MaxRec) + 1);
	printf(", %u max_rec", sc->sc_sc1394.sc1394_max_receive);

	/*
	 * Count how many isochronous ctx we have.
	 */
	OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntMaskSet, ~0);
	val = OHCI_CSR_READ(sc, OHCI_REG_IsoRecvIntMaskClear);
	OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntMaskClear, ~0);
	for (i = 0; val != 0; val >>= 1) {
		if (val & 0x1)
			i++;
	}
	sc->sc_isoctx = i;
	printf(", %d iso_ctx", sc->sc_isoctx);

	printf("\n");

#if 0
	error = fwohci_dmamem_alloc(sc, OHCI_CONFIG_SIZE,
	    OHCI_CONFIG_ALIGNMENT, &sc->sc_configrom_map,
	    (caddr_t *) &sc->sc_configrom, BUS_DMA_WAITOK|BUS_DMA_COHERENT);
	return error;
#endif

	MALLOC(sc->sc_dying, int *, sizeof(int), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", sc->sc_dying);
	DPRINTF(("%s: sc_dying 0x%08x\n", __func__, (u_int32_t)sc->sc_dying));
	*sc->sc_dying = 0;
	sc->sc_nodeid = 0xFFFF;		/* Invalid. */

#ifdef	__NetBSD__
	kthread_create(fwohci_create_event_thread, sc);
#else
	if (initproc == NULL)
		kthread_create_deferred(fwohci_create_event_thread, sc);
	else
		/* Late binding, threads already running. */
		fwohci_create_event_thread(sc);
#endif

	return 0;
}

int
fwohci_if_setiso(struct device *self, u_int32_t channel, u_int32_t tag,
    u_int32_t direction, void (*handler)(struct device *, struct mbuf *))
{
	struct fwohci_softc *sc = (struct fwohci_softc *)self;
	int retval;
	int s;

	if (direction == 1) {
		return EIO;
	}

	s = splnet();
	retval = fwohci_handler_set(sc, IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK,
	    channel, tag, 0, fwohci_if_input_iso, handler);
	splx(s);

	if (!retval) {
		printf("%s: dummy iso handler set\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
	} else {
		printf("%s: dummy iso handler cannot set\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
	}

	return retval;
}

int
fwohci_intr(void *arg)
{
	struct fwohci_softc * const sc = arg;
#if 1
	int progress = 0;
#else
	int progress = (sc->sc_intmask != 0);
#endif
	u_int32_t intmask, iso;

	splassert(IPL_BIO);

#ifdef	FWOHCI_DEBUG
	//DPRINTFN(3,("%s:  in(%d)\n", __func__, fwintr));
	fwintr++;
#endif	/* FWOHCI_DEBUG */

#if 1
	for (;;) {
#endif
		intmask = OHCI_CSR_READ(sc, OHCI_REG_IntEventClear);

		/*
		 * On a bus reset, everything except bus reset gets
		 * cleared. That can't get cleared until the selfid
		 * phase completes (which happens outside the
		 * interrupt routines). So if just a bus reset is left
		 * in the mask and it's already in the sc_intmask,
		 * just return.
		 */

		if ((intmask == 0xFFFFFFFF) || (intmask == 0) ||
		    (progress && (intmask == OHCI_Int_BusReset) &&
		       (sc->sc_intmask & OHCI_Int_BusReset))) {

			if (intmask == 0xFFFFFFFF)
				config_detach(((struct device *)sc)
				    ->dv_parent, 0);

			if (progress) {
#if	NO_THREAD
				fwohci_event_dispatch(sc);
#else	/* NO_THREAD */
				wakeup(fwohci_event_thread);
#endif	/* NO_THREAD */
			}

#ifdef	FWOHCI_DEBUG
			--fwintr;
			//DPRINTFN(3,("%s: out(%d)\n", __func__, fwintr));
#endif	/* FWOHCI_DEBUG */

			return (progress);
		}
#if 1
		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
		    intmask & ~OHCI_Int_BusReset);
#else
		DPRINTFN(2,("%s: IntEventClear(0x%08x) IntMaskClear(0x%08x)\n",
		    __func__,
		    intmask & ~OHCI_Int_BusReset,
		    intmask & ~OHCI_Int_BusReset & ~OHCI_Int_MasterEnable));
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskClear,
		    intmask & ~OHCI_Int_BusReset & ~OHCI_Int_MasterEnable);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
		    intmask & ~OHCI_Int_BusReset);
#endif
#ifdef	FWOHCI_DEBUG
		if (fwohcidebug > 1)
			fwohci_show_intr(sc, intmask);
#endif	/* FWOHCI_DEBUG */

		if (intmask & OHCI_Int_BusReset) {
			/*
			 * According to OHCI spec 6.1.1 "busReset",
			 * all asynchronous transmit must be stopped before
			 * clearing BusReset. Moreover, the BusReset
			 * interrupt bit should not be cleared during the
			 * SelfID phase. Thus we turned off interrupt mask
			 * bit of BusReset instead until SelfID completion
			 * or SelfID timeout.
			 */
#if 0
			DPRINTFN(2,("%s: IntMaskSet(0x%08x)"
			    " IntMaskClear(0x%08x)\n", __func__,
			    intmask & ~OHCI_Int_BusReset, OHCI_Int_BusReset));
			OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
			    intmask & ~OHCI_Int_BusReset);
#endif
			intmask &= OHCI_Int_SelfIDComplete;
			OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskClear,
			    OHCI_Int_BusReset);
			sc->sc_intmask = OHCI_Int_BusReset;
		}
		sc->sc_intmask |= intmask;

		if (intmask & OHCI_Int_IsochTx) {
			iso = OHCI_CSR_READ(sc, OHCI_REG_IsoXmitIntEventClear);
#if 1
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoXmitIntEventClear, iso);
#else
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoXmitIntEventClear,
			    sc->sc_isotxrst);
#endif
		}
		if (intmask & OHCI_Int_IsochRx) {
#if	NO_THREAD
			int i;
			int asyncstream = 0;
#endif	/* NO_THREAD */

			iso = OHCI_CSR_READ(sc, OHCI_REG_IsoRecvIntEventClear);
#if 1
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntEventClear, iso);
#else
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntEventClear,
			    sc->sc_isorxrst);
#endif
#if	NO_THREAD
			for (i = 0; i < sc->sc_isoctx; i++) {
				if ((iso & (1<<i)) &&
				    sc->sc_ctx_ir[i] != NULL) {
					if (sc->sc_ctx_ir[i]->fc_type ==
					    FWOHCI_CTX_ISO_SINGLE) {
						asyncstream |= (1 << i);
						continue;
					}
					bus_dmamap_sync(sc->sc_dmat,
					    sc->sc_ddmamap,
					    0, sizeof(struct fwohci_desc) *
					    sc->sc_descsize,
					    BUS_DMASYNC_PREREAD);
					sc->sc_isocnt.ev_count++;

					fwohci_ir_input(sc, sc->sc_ctx_ir[i]);
				}
			}
			if (asyncstream != 0) {
				sc->sc_iso |= asyncstream;
			} else {
				/* All iso intr is pure isochronous. */
				sc->sc_intmask &= ~OHCI_Int_IsochRx;
			}
#else	/* NO_THREAD */
			sc->sc_iso |= iso;
#endif	/* NO_THREAD */
		}

		if (!progress) {
			sc->sc_intrcnt.ev_count++;
#if 1
			progress = 1;
#endif
		}
#if 1
	}
#else
#ifdef	FWOHCI_DEBUG
	--fwintr;
	//DPRINTF(("%s: out(%d)\n", __func__, fwintr));
#endif	/* FWOHCI_DEBUG */

	return (progress);
#endif
}

void
fwohci_create_event_thread(void *arg)
{
	struct fwohci_softc  *sc = arg;

#ifdef	__NetBSD__
	if (kthread_create1(fwohci_thread_init, sc, &sc->sc_event_thread, "%s",
	    sc->sc_sc1394.sc1394_dev.dv_xname))
#else
	if (kthread_create(fwohci_thread_init, sc, &sc->sc_event_thread, "%s",
	    sc->sc_sc1394.sc1394_dev.dv_xname))
#endif
	{
		printf("%s: unable to create event thread\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
		panic("fwohci_create_event_thread");
	}
}

void
fwohci_thread_init(void *arg)
{
	struct fwohci_softc *sc = arg;
	int i;

	/*
	 * Allocate descriptors.
	 */
	if (fwohci_desc_alloc(sc)) {
		printf("%s: not enabling interrupts\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
		kthread_exit(1);
	}

	/*
	 * Enable Link Power.
	 */

	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet, OHCI_HCControl_LPS);

	/*
	 * Allocate DMA Context.
	 */
	fwohci_ctx_alloc(sc, &sc->sc_ctx_arrq, OHCI_BUF_ARRQ_CNT,
	    OHCI_CTX_ASYNC_RX_REQUEST, FWOHCI_CTX_ASYNC);
	fwohci_ctx_alloc(sc, &sc->sc_ctx_arrs, OHCI_BUF_ARRS_CNT,
	    OHCI_CTX_ASYNC_RX_RESPONSE, FWOHCI_CTX_ASYNC);
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrq, 0,
	    OHCI_CTX_ASYNC_TX_REQUEST, FWOHCI_CTX_ASYNC);
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrs, 0,
	    OHCI_CTX_ASYNC_TX_RESPONSE, FWOHCI_CTX_ASYNC);
	sc->sc_ctx_ir = malloc(sizeof(sc->sc_ctx_ir[0]) * sc->sc_isoctx,
	    M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", sc->sc_ctx_ir);
	for (i = 0; i < sc->sc_isoctx; i++)
		sc->sc_ctx_ir[i] = NULL;

	/*
	 * Allocate buffer for configuration ROM and SelfID buffer.
	 */
	fwohci_buf_alloc(sc, &sc->sc_buf_cnfrom);
	fwohci_buf_alloc(sc, &sc->sc_buf_selfid);

#ifdef	__NetBSD__
	callout_init(&sc->sc_selfid_callout);
#else
	bzero(&sc->sc_selfid_callout, sizeof(sc->sc_selfid_callout));
#endif

	sc->sc_sc1394.sc1394_ifinreg = fwohci_if_inreg;
	sc->sc_sc1394.sc1394_ifoutput = fwohci_if_output;
	sc->sc_sc1394.sc1394_ifsetiso = fwohci_if_setiso;

	/*
	 * Establish hooks for shutdown and suspend/resume.
	 */
	sc->sc_shutdownhook = shutdownhook_establish(fwohci_shutdown, sc);
	sc->sc_powerhook = powerhook_establish(fwohci_power, sc);

	sc->sc_sc1394.sc1394_if = config_found(&sc->sc_sc1394.sc1394_dev, "fw",
	    fwohci_print);

	/* Main loop. It's not coming back normally. */

	fwohci_event_thread(sc);
	printf("%s: event thread exited\n", __func__);

	if (sc->sc_uidtbl != NULL) {
		free(sc->sc_uidtbl, M_DEVBUF);
		MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
		sc->sc_uidtbl = NULL;
	}

	fwohci_buf_free(sc, &sc->sc_buf_selfid);
	fwohci_buf_free(sc, &sc->sc_buf_cnfrom);

	free(sc->sc_ctx_ir, M_DEVBUF);
	MPRINTF("free(DEVBUF)", sc->sc_ctx_ir);
	sc->sc_ctx_ir = NULL;	/* XXX */
	fwohci_ctx_free(sc, sc->sc_ctx_atrs);
	fwohci_ctx_free(sc, sc->sc_ctx_atrq);
	fwohci_ctx_free(sc, sc->sc_ctx_arrs);
	fwohci_ctx_free(sc, sc->sc_ctx_arrq);

	fwohci_desc_free(sc);

	DPRINTF(("%s: waking up... 0x%08x\n", __func__,
	    (u_int32_t)sc->sc_dying));
	wakeup(sc->sc_dying);
	kthread_exit(0);
}

void
fwohci_event_thread(struct fwohci_softc *sc)
{
	int s;
#if !	NO_THREAD
	int i;
	uint32_t intmask, iso;
#endif	/* NO_THREAD */

	s = splbio();

	/*
	 * Initialize hardware registers.
	 */

	fwohci_hw_init(sc);

	/* Initial Bus Reset. */
	fwohci_phy_busreset(sc);
	splx(s);

	while (! *sc->sc_dying) {
#if !	NO_THREAD
		s = splbio();
		intmask = sc->sc_intmask;
		if (intmask == 0) {
#endif	/* NO_THREAD */
#if 1
			tsleep(fwohci_event_thread, PZERO, "fwohciev", 8);
#else
			tsleep(fwohci_event_thread, PZERO, "fwohciev", 0);
#endif
#if !	NO_THREAD
			splx(s);
			continue;
		}
		sc->sc_intmask = 0;
		splx(s);
		DPRINTFN(2, ("%s: treating interrupts 0x%08x\n", __func__,
		    intmask));

		if (intmask & OHCI_Int_BusReset) {
//			s = splbio();
			fwohci_buf_stop_tx(sc);
//			splx(s);
			if (sc->sc_uidtbl != NULL) {
				free(sc->sc_uidtbl, M_DEVBUF);
				MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
				sc->sc_uidtbl = NULL;
			}

#ifdef	__NetBSD__
			callout_reset(&sc->sc_selfid_callout,
			    OHCI_SELFID_TIMEOUT,
			    (void (*)(void *))fwohci_phy_busreset, sc);
#else
			timeout_set(&sc->sc_selfid_callout,
			    (void (*)(void *))fwohci_phy_busreset, sc);
			timeout_add(&sc->sc_selfid_callout,
			    OHCI_SELFID_TIMEOUT);
#endif
			sc->sc_nodeid = 0xFFFF;	/* Indicate invalid. */
			sc->sc_rootid = 0;
			sc->sc_irmid = IEEE1394_BCAST_PHY_ID;
		}
		if (intmask & OHCI_Int_SelfIDComplete) {
			s = splbio();
			OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
			    OHCI_Int_BusReset);
			OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
			    OHCI_Int_BusReset);
			splx(s);
#ifdef	__NetBSD__
			callout_stop(&sc->sc_selfid_callout);
#else
			timeout_del(&sc->sc_selfid_callout);
#endif
			if (fwohci_selfid_input(sc) == 0) {
//				s = splbio();
				fwohci_buf_start_rx(sc);
//				splx(s);
				fwohci_uid_collect(sc);
			}
		}
		if (intmask & OHCI_Int_ReqTxComplete) {
//			s = splbio();
			fwohci_at_done(sc, sc->sc_ctx_atrq, 0);
//			splx(s);
		}
		if (intmask & OHCI_Int_RespTxComplete) {
//			s = splbio();
			fwohci_at_done(sc, sc->sc_ctx_atrs, 0);
//			splx(s);
		}
		if (intmask & OHCI_Int_RQPkt) {
			fwohci_arrq_input(sc, sc->sc_ctx_arrq);
		}
		if (intmask & OHCI_Int_RSPkt) {
			fwohci_arrs_input(sc, sc->sc_ctx_arrs);
		}
		if (intmask & OHCI_Int_IsochRx) {
			s = splbio();
			iso = sc->sc_iso;
			sc->sc_iso = 0;
			splx(s);
			for (i = 0; i < sc->sc_isoctx; i++) {
				if ((iso & (1 << i)) &&
				    sc->sc_ctx_ir[i] != NULL) {
					fwohci_ir_input(sc, sc->sc_ctx_ir[i]);
					sc->sc_isocnt.ev_count++;
				}
			}
		}
#if 0
		DPRINTF(("%s: IntMaskSet(0x%08x)\n",
		    __func__, intmask & ~OHCI_Int_BusReset));
		s = splbio();
//		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
//		    intmask & ~OHCI_Int_BusReset);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
		    intmask & ~OHCI_Int_BusReset);
		splx(s);
#endif
#endif	/* NO_THREAD */
	}
}

#if	NO_THREAD
void
fwohci_event_dispatch(struct fwohci_softc *sc)
{
	int i, s;
	u_int32_t intmask, iso;

	splassert(IPL_BIO);
	intmask = sc->sc_intmask;
	if (intmask == 0)
		return;

	sc->sc_intmask = 0;
	s = spl0();
	DPRINTFN(2, ("%s: treating interrupts 0x%08x\n", __func__, intmask));

	if (intmask & OHCI_Int_BusReset) {
//		s = splbio();
		fwohci_buf_stop_tx(sc);
//		splx(s);
		if (sc->sc_uidtbl != NULL) {
			free(sc->sc_uidtbl, M_DEVBUF);
			MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
			sc->sc_uidtbl = NULL;
		}

#ifdef	__NetBSD__
		callout_reset(&sc->sc_selfid_callout,
		    OHCI_SELFID_TIMEOUT,
		    (void (*)(void *))fwohci_phy_busreset, sc);
#else
		timeout_set(&sc->sc_selfid_callout,
		    (void (*)(void *))fwohci_phy_busreset, sc);
		timeout_add(&sc->sc_selfid_callout,
		    OHCI_SELFID_TIMEOUT);
#endif
		sc->sc_nodeid = 0xFFFF;	/* Indicate invalid. */
		sc->sc_rootid = 0;
		sc->sc_irmid = IEEE1394_BCAST_PHY_ID;
	}
	if (intmask & OHCI_Int_SelfIDComplete) {
		splx(s);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
		    OHCI_Int_BusReset);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
		    OHCI_Int_BusReset);
		s = spl0();
#ifdef	__NetBSD__
		callout_stop(&sc->sc_selfid_callout);
#else
		timeout_del(&sc->sc_selfid_callout);
#endif
		if (fwohci_selfid_input(sc) == 0) {
//			s = splbio();
			fwohci_buf_start_rx(sc);
//			splx(s);
			fwohci_uid_collect(sc);
		}
	}
	if (intmask & OHCI_Int_ReqTxComplete) {
//		s = splbio();
		fwohci_at_done(sc, sc->sc_ctx_atrq, 0);
//		splx(s);
	}
	if (intmask & OHCI_Int_RespTxComplete) {
//		s = splbio();
		fwohci_at_done(sc, sc->sc_ctx_atrs, 0);
//		splx(s);
	}
	if (intmask & OHCI_Int_RQPkt) {
		fwohci_arrq_input(sc, sc->sc_ctx_arrq);
	}
	if (intmask & OHCI_Int_RSPkt) {
		fwohci_arrs_input(sc, sc->sc_ctx_arrs);
	}
	if (intmask & OHCI_Int_IsochRx) {
		splx(s);
		iso = sc->sc_iso;
		sc->sc_iso = 0;
		s = spl0();
		for (i = 0; i < sc->sc_isoctx; i++) {
			if ((iso & (1 << i)) &&
			    sc->sc_ctx_ir[i] != NULL) {
				fwohci_ir_input(sc, sc->sc_ctx_ir[i]);
				sc->sc_isocnt.ev_count++;
			}
		}
	}
#if 0
	DPRINTF(("%s: IntMaskSet(0x%08x)\n",
	    __func__, intmask & ~OHCI_Int_BusReset));
	s = splbio();
//	OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
//	    intmask & ~OHCI_Int_BusReset);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, intmask & ~OHCI_Int_BusReset);
	splx(s);
#endif
	splx(s);
}
#endif	/* NO_THREAD */


#if 0
int
fwohci_dmamem_alloc(struct fwohci_softc *sc, int size, int alignment,
    bus_dmamap_t *mapp, caddr_t *kvap, int flags)
{
	bus_dma_segment_t segs[1];
	int error, nsegs, steps;

	steps = 0;
	error = bus_dmamem_alloc(sc->sc_dmat, size, alignment, alignment,
	    segs, 1, &nsegs, flags);
	if (error)
		goto cleanup;
	MPRINTF("bus_dmamem_alloc", segs->ds_addr);

	steps = 1;
	error = bus_dmamem_map(sc->sc_dmat, segs, nsegs, segs[0].ds_len,
	    kvap, flags);
	if (error)
		goto cleanup;

	if (error == 0)
		error = bus_dmamap_create(sc->sc_dmat, size, 1, alignment,
		    size, flags, mapp);
	if (error)
		goto cleanup;
	MPRINTF("bus_dmamap_create", mapp);

	if (error == 0)
		error = bus_dmamap_load(sc->sc_dmat, *mapp, *kvap, size, NULL,
		    flags);
	if (error)
		goto cleanup;

 cleanup:
	switch (steps) {
	case 1:
		bus_dmamem_free(sc->sc_dmat, segs, nsegs);
		MPRINTF("bus_dmamem_free", segs->ds_addr);
	}

	return error;
}
#endif

int
fwohci_print(void *aux, const char *pnp)
{
	char *name = aux;

	if (pnp)
		printf("%s at %s", name, pnp);

	return UNCONF;
}

void
fwohci_hw_init(struct fwohci_softc *sc)
{
	int i;
	u_int32_t val;

	splassert(IPL_BIO);

	/*
	 * Software Reset.
	 */
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet, OHCI_HCControl_SoftReset);
	for (i = 0; i < OHCI_LOOP; i++) {
		val = OHCI_CSR_READ(sc, OHCI_REG_HCControlClear);
		if ((val & OHCI_HCControl_SoftReset) == 0)
			break;
		DELAY(10);
	}

	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet, OHCI_HCControl_LPS);
	DELAY(100000);

	/*
	 * First, initialize CSRs with undefined value to default settings.
	 */
	val = OHCI_CSR_READ(sc, OHCI_REG_BusOptions);
	val |= OHCI_BusOptions_ISC | OHCI_BusOptions_CMC;
#if 1
	val |= OHCI_BusOptions_BMC | OHCI_BusOptions_IRMC;
	val |= OHCI_BusOptions_PMC;
#else
	val &= ~(OHCI_BusOptions_BMC | OHCI_BusOptions_IRMC);
	val &= ~(OHCI_BusOptions_PMC);
#endif
	OHCI_CSR_WRITE(sc, OHCI_REG_BusOptions, val);
	for (i = 0; i < sc->sc_isoctx; i++) {
		OHCI_SYNC_RX_DMA_WRITE(sc, i, OHCI_SUBREG_ContextControlClear,
		    ~0);
	}
	OHCI_CSR_WRITE(sc, OHCI_REG_LinkControlClear, ~0);

	fwohci_configrom_init(sc);
	fwohci_selfid_init(sc);
	fwohci_buf_init_rx(sc);
	fwohci_csr_init(sc);

	/*
	 * Final CSR settings.
	 */
	OHCI_CSR_WRITE(sc, OHCI_REG_LinkControlSet,
	    OHCI_LinkControl_CycleTimerEnable |
	    OHCI_LinkControl_RcvSelfID | OHCI_LinkControl_RcvPhyPkt);

#if 0
	OHCI_CSR_WRITE(sc, OHCI_REG_ATRetries, 0x00000888);	/*XXX*/
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_ATRetries, 0xFFFF0FFF);	/*XXX*/
#endif

	/* Clear receive filter. */
	OHCI_CSR_WRITE(sc, OHCI_REG_IRMultiChanMaskHiClear, ~0);
	OHCI_CSR_WRITE(sc, OHCI_REG_IRMultiChanMaskLoClear, ~0);
	OHCI_CSR_WRITE(sc, OHCI_REG_AsynchronousRequestFilterHiSet, 0x80000000);

	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
	    OHCI_HCControl_ProgramPhyEnable);
#if 0
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlClear,
	    OHCI_HCControl_APhyEnhanceEnable);
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
	    OHCI_HCControl_APhyEnhanceEnable);
#endif
#if BYTE_ORDER == BIG_ENDIAN
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
	    OHCI_HCControl_NoByteSwapData);
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlClear,
	    OHCI_HCControl_NoByteSwapData);
#endif

	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskClear, ~0);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, OHCI_Int_BusReset |
	    OHCI_Int_SelfIDComplete | OHCI_Int_IsochRx | OHCI_Int_IsochTx |
	    OHCI_Int_RSPkt | OHCI_Int_RQPkt | OHCI_Int_ARRS | OHCI_Int_ARRQ |
	    OHCI_Int_RespTxComplete | OHCI_Int_ReqTxComplete);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, OHCI_Int_CycleTooLong |
	    OHCI_Int_UnrecoverableError | OHCI_Int_CycleInconsistent |
	    OHCI_Int_LockRespErr | OHCI_Int_PostedWriteErr);
	OHCI_CSR_WRITE(sc, OHCI_REG_IsoXmitIntMaskSet, ~0);
	OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntMaskSet, ~0);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, OHCI_Int_MasterEnable);

	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet, OHCI_HCControl_LinkEnable);

	/*
	 * Start the receivers.
	 */
	fwohci_buf_start_rx(sc);
}

void
fwohci_power(int why, void *arg)
{
	struct fwohci_softc *sc = arg;
	int s;

	s = splbio();
	switch (why) {
	case PWR_SUSPEND:
	case PWR_STANDBY:
		fwohci_shutdown(sc);
		break;
	case PWR_RESUME:
		fwohci_hw_init(sc);
		fwohci_phy_busreset(sc);
		break;
#ifdef	__NetBSD__
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
	}
	splx(s);
}

void
fwohci_shutdown(void *arg)
{
	struct fwohci_softc *sc = arg;
	u_int32_t val;
	int s;

	//splassert(IPL_BIO);

#ifdef	__NetBSD__
	callout_stop(&sc->sc_selfid_callout);
#else
	timeout_del(&sc->sc_selfid_callout);
#endif
	/* Disable all interrupt. */
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskClear, OHCI_Int_MasterEnable);
	fwohci_buf_stop_tx(sc);
	fwohci_buf_stop_rx(sc);
	s = splbio();
	val = OHCI_CSR_READ(sc, OHCI_REG_BusOptions);
	val &= ~(OHCI_BusOptions_BMC | OHCI_BusOptions_ISC |
		OHCI_BusOptions_CMC | OHCI_BusOptions_IRMC);
	OHCI_CSR_WRITE(sc, OHCI_REG_BusOptions, val);
	splx(s);
	fwohci_phy_busreset(sc);
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlClear, OHCI_HCControl_LinkEnable);
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlClear, OHCI_HCControl_LPS);
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet, OHCI_HCControl_SoftReset);
}

/*
 * COMMON FUNCTIONS.
 */

/*
 * Read the PHY Register.
 */
u_int8_t
fwohci_phy_read(struct fwohci_softc *sc, u_int8_t reg)
{
	int i;
	u_int32_t val;

	//splassert(IPL_BIO);

	OHCI_CSR_WRITE(sc, OHCI_REG_PhyControl,
	    OHCI_PhyControl_RdReg |
	    OHCI_BITSET(reg, OHCI_PhyControl_RegAddr));
	for (i = 0; i < OHCI_LOOP; i++) {
		val = OHCI_CSR_READ(sc, OHCI_REG_PhyControl);
		if (!(val & OHCI_PhyControl_RdReg) &&
		    (val & OHCI_PhyControl_RdDone))
			break;
		DELAY(10);
	}
	return (OHCI_BITVAL(val, OHCI_PhyControl_RdData));
}

/*
 * Write the PHY Register.
 */
void
fwohci_phy_write(struct fwohci_softc *sc, u_int8_t reg, u_int8_t val)
{
	int i;

	//splassert(IPL_BIO);

	OHCI_CSR_WRITE(sc, OHCI_REG_PhyControl, OHCI_PhyControl_WrReg |
	    OHCI_BITSET(reg, OHCI_PhyControl_RegAddr) |
	    OHCI_BITSET(val, OHCI_PhyControl_WrData));
	for (i = 0; i < OHCI_LOOP; i++) {
		if (!(OHCI_CSR_READ(sc, OHCI_REG_PhyControl) &
		    OHCI_PhyControl_WrReg))
			break;
		DELAY(10);
	}
}

/*
 * Initiate Bus Reset.
 */
void
fwohci_phy_busreset(struct fwohci_softc *sc)
{
	int s;
	u_int8_t val;

	//splassert(IPL_BIO);

	s = splbio();
	OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
	    OHCI_Int_BusReset | OHCI_Int_SelfIDComplete);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, OHCI_Int_BusReset);
#ifdef	__NetBSD__
	callout_stop(&sc->sc_selfid_callout);
#else
	timeout_del(&sc->sc_selfid_callout);
#endif
	val = fwohci_phy_read(sc, 1);
	val = (val & 0x80) |			/* Preserve RHB (force root). */
	    0x40 |				/* Initiate Bus Reset. */
	    0x3F;				/* Default GAP count. */
	fwohci_phy_write(sc, 1, val);
	splx(s);
}

/*
 * PHY Packet.
 */
void
fwohci_phy_input(struct fwohci_softc *sc, struct fwohci_pkt *pkt)
{
	u_int32_t val;

	val = pkt->fp_hdr[1];
	if (val != ~pkt->fp_hdr[2]) {
		if (val == 0 && ((*pkt->fp_trail & 0x001F0000) >> 16) ==
		    OHCI_CTXCTL_EVENT_BUS_RESET) {
			DPRINTFN(1, ("%s: BusReset: 0x%08x\n", __func__,
			    pkt->fp_hdr[2]));
		} else {
			printf("%s: phy packet corrupted (0x%08x, 0x%08x)\n",
			    sc->sc_sc1394.sc1394_dev.dv_xname, val,
			    pkt->fp_hdr[2]);
		}
		return;
	}
#ifdef	FWOHCI_DEBUG
	if (fwohcidebug > 1)
		fwohci_show_phypkt(sc, val);
#endif	/* FWOHCI_DEBUG */
}

/*
 * Descriptor for context DMA.
 */
int
fwohci_desc_alloc(struct fwohci_softc *sc)
{
	int error, mapsize, dsize;

	/*
	 * Allocate descriptor buffer.
	 */

	sc->sc_descsize = OHCI_BUF_ARRQ_CNT + OHCI_BUF_ARRS_CNT +
	    OHCI_BUF_ATRQ_CNT + OHCI_BUF_ATRS_CNT +
	    OHCI_BUF_IR_CNT * sc->sc_isoctx + 2;
	dsize = sizeof(struct fwohci_desc) * sc->sc_descsize;
	mapsize = howmany(sc->sc_descsize, NBBY);
#ifdef	M_ZERO
	sc->sc_descmap = malloc(mapsize, M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("malloc(DEVBUF)", sc->sc_descmap);
#else
	sc->sc_descmap = malloc(mapsize, M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", sc->sc_descmap);
	bzero(sc->sc_descmap, mapsize);
#endif

#if 1	/* XXX Added when reorganizing dmamap stuff... */
	sc->sc_dnseg = 1;
#endif

	if ((error = bus_dmamap_create(sc->sc_dmat, dsize, sc->sc_dnseg,
	    dsize, 0, BUS_DMA_WAITOK, &sc->sc_ddmamap)) != 0) {
		printf("%s: unable to create descriptor buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_0;
	}
	MPRINTF("bus_dmamap_create", sc->sc_ddmamap);

	if ((error = bus_dmamem_alloc(sc->sc_dmat, dsize, PAGE_SIZE, 0,
	    &sc->sc_dseg, 1, &sc->sc_dnseg, BUS_DMA_WAITOK)) != 0) {
		printf("%s: unable to allocate descriptor buffer, error = %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_1;
	}
	MPRINTF("bus_dmamem_alloc", sc->sc_dseg.ds_addr);

	if ((error = bus_dmamem_map(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg,
	    dsize, (caddr_t *)&sc->sc_desc, BUS_DMA_COHERENT | BUS_DMA_WAITOK))
	    != 0) {
		printf("%s: unable to map descriptor buffer, error = %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_2;
	}

#if 0
	if ((error = bus_dmamap_load(sc->sc_dmat, sc->sc_ddmamap, sc->sc_desc,
	    dsize, NULL, BUS_DMA_WAITOK)) != 0) {
#else
	if ((error = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_ddmamap,
	    &sc->sc_dseg, sc->sc_dnseg, dsize, BUS_DMA_WAITOK)) != 0) {
#endif
		printf("%s: unable to load descriptor buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_3;
	}

	return 0;

  fail_3:
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_desc, dsize);
  fail_2:
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);
	MPRINTF("bus_dmamem_free", sc->sc_dseg.ds_addr);
  fail_1:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	MPRINTF("bus_dmamap_destroy", sc->sc_ddmamap);
  fail_0:
	return error;
}

void
fwohci_desc_free(struct fwohci_softc *sc)
{
	int dsize = sizeof(struct fwohci_desc) * sc->sc_descsize;

	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_desc, dsize);
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);
	MPRINTF("bus_dmamem_free", sc->sc_dseg.ds_addr);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	MPRINTF("bus_dmamap_destroy", sc->sc_ddmamap);

	free(sc->sc_descmap, M_DEVBUF);
	MPRINTF("free(DEVBUF)", sc->sc_descmap);
	sc->sc_descmap = NULL;	/* XXX */
}

struct fwohci_desc *
fwohci_desc_get(struct fwohci_softc *sc, int ndesc)
{
	int i, n;

	assert(ndesc > 0);

	for (n = 0; n <= sc->sc_descsize - ndesc; n++) {
		for (i = 0; ; i++) {
			if (i == ndesc) {
				for (i = 0; i < ndesc; i++)
					setbit(sc->sc_descmap, n + i);
				return sc->sc_desc + n;
			}
			if (isset(sc->sc_descmap, n + i))
				break;
		}
	}
	return NULL;
}

void
fwohci_desc_put(struct fwohci_softc *sc, struct fwohci_desc *fd, int ndesc)
{
	int i, n;

	assert(ndesc > 0);

	n = fd - sc->sc_desc;
	for (i = 0; i < ndesc; i++, n++) {
#ifdef	DIAGNOSTIC
		if (isclr(sc->sc_descmap, n))
			panic("fwohci_desc_put: duplicated free");
#endif
		clrbit(sc->sc_descmap, n);
	}
}

/*
 * Asynchronous/Isochronous Transmit/Receive Context.
 */
int
fwohci_ctx_alloc(struct fwohci_softc *sc, struct fwohci_ctx **fcp,
    int bufcnt, int ctx, int ctxtype)
{
	int i, error;
	struct fwohci_ctx *fc;
	struct fwohci_buf *fb;
	struct fwohci_desc *fd;
#if DOUBLEBUF
	int buf2cnt;
#endif

#ifdef	M_ZERO
	MALLOC(fc, struct fwohci_ctx *, sizeof(*fc), M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(DEVBUF)", fc);
#else
	MALLOC(fc, struct fwohci_ctx *, sizeof(*fc), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", fc);
	bzero(fc, sizeof(*fc));
#endif
	LIST_INIT(&fc->fc_handler);
	TAILQ_INIT(&fc->fc_buf);
	fc->fc_ctx = ctx;
#ifdef	M_ZERO
	fc->fc_buffers = fb = malloc(sizeof(*fb) * bufcnt,
	    M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("malloc(DEVBUF)", fc->fc_buffers);
#else
	fc->fc_buffers = fb = malloc(sizeof(*fb) * bufcnt, M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", fc->fc_buffers);
	bzero(fb, sizeof(*fb) * bufcnt);
#endif
	fc->fc_bufcnt = bufcnt;
	if (bufcnt == 0)		/* Asynchronous transmit... */
		goto ok;

#if DOUBLEBUF
	TAILQ_INIT(&fc->fc_buf2);	/* For isochronous. */
	if (ctxtype == FWOHCI_CTX_ISO_MULTI) {
		buf2cnt = bufcnt/2;
		bufcnt -= buf2cnt;
		if (buf2cnt == 0) {
			panic("cannot allocate iso buffer");
		}
	}
#endif
	for (i = 0; i < bufcnt; i++, fb++) {
		if ((error = fwohci_buf_alloc(sc, fb)) != 0)
			goto fail;
		if ((fd = fwohci_desc_get(sc, 1)) == NULL) {
			error = ENOBUFS;
			goto fail;
		}
		fb->fb_desc = fd;
		fb->fb_daddr = sc->sc_ddmamap->dm_segs[0].ds_addr +
		    ((caddr_t)fd - (caddr_t)sc->sc_desc);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
		fd->fd_flags = OHCI_DESC_INPUT | OHCI_DESC_STATUS |
		    OHCI_DESC_INTR_ALWAYS | OHCI_DESC_BRANCH;
		fd->fd_reqcount = fb->fb_dmamap->dm_segs[0].ds_len;
		fd->fd_data = fb->fb_dmamap->dm_segs[0].ds_addr;
		TAILQ_INSERT_TAIL(&fc->fc_buf, fb, fb_list);
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
	}
#if DOUBLEBUF
	if (ctxtype == FWOHCI_CTX_ISO_MULTI) {
		for (i = bufcnt; i < bufcnt + buf2cnt; i++, fb++) {
			if ((error = fwohci_buf_alloc(sc, fb)) != 0)
				goto fail;
			if ((fd = fwohci_desc_get(sc, 1)) == NULL) {
				error = ENOBUFS;
				goto fail;
			}
			fb->fb_desc = fd;
			fb->fb_daddr = sc->sc_ddmamap->dm_segs[0].ds_addr +
			    ((caddr_t)fd - (caddr_t)sc->sc_desc);
			bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
			    (caddr_t)fd - (caddr_t)sc->sc_desc,
			    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
			fd->fd_flags = OHCI_DESC_INPUT | OHCI_DESC_STATUS |
			    OHCI_DESC_INTR_ALWAYS | OHCI_DESC_BRANCH;
			fd->fd_reqcount = fb->fb_dmamap->dm_segs[0].ds_len;
			fd->fd_data = fb->fb_dmamap->dm_segs[0].ds_addr;
			TAILQ_INSERT_TAIL(&fc->fc_buf2, fb, fb_list);
			bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
			    (caddr_t)fd - (caddr_t)sc->sc_desc,
			    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
		}
	}
#endif /* DOUBLEBUF */
    ok:
	fc->fc_type = ctxtype;
	*fcp = fc;
	return 0;

  fail:
	while (i-- > 0) {
		fb--;
		if (fb->fb_desc)
			fwohci_desc_put(sc, fb->fb_desc, 1);
		fwohci_buf_free(sc, fb);
	}
	FREE(fc, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", fc);
	fc = NULL;	/* XXX */
	return error;
}

void
fwohci_ctx_free(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	struct fwohci_buf *fb;
	struct fwohci_handler *fh;

#if DOUBLEBUF
	if ((fc->fc_type == FWOHCI_CTX_ISO_MULTI) &&
	    (TAILQ_FIRST(&fc->fc_buf) > TAILQ_FIRST(&fc->fc_buf2))) {
		struct fwohci_buf_s fctmp;

		fctmp = fc->fc_buf;
		fc->fc_buf = fc->fc_buf2;
		fc->fc_buf2 = fctmp;
	}
#endif
	while ((fh = LIST_FIRST(&fc->fc_handler)) != NULL)
		fwohci_handler_set(sc, fh->fh_tcode, fh->fh_key1, fh->fh_key2,
		    fh->fh_key3, NULL, NULL);
	while ((fb = TAILQ_FIRST(&fc->fc_buf)) != NULL) {
		TAILQ_REMOVE(&fc->fc_buf, fb, fb_list);
		if (fb->fb_desc)
			fwohci_desc_put(sc, fb->fb_desc, 1);
		fwohci_buf_free(sc, fb);
	}
#if	DOUBLEBUF
	while ((fb = TAILQ_FIRST(&fc->fc_buf2)) != NULL) {
		TAILQ_REMOVE(&fc->fc_buf2, fb, fb_list);
		if (fb->fb_desc)
			fwohci_desc_put(sc, fb->fb_desc, 1);
		fwohci_buf_free(sc, fb);
	}
#endif	/* DOUBLEBUF */
	free(fc->fc_buffers, M_DEVBUF);
	MPRINTF("free(DEVBUF)", fc->fc_buffers);
	fc->fc_buffers = NULL;	/* XXX */
	FREE(fc, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", fc);
	fc = NULL;	/* XXX */
}

void
fwohci_ctx_init(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	struct fwohci_buf *fb, *nfb;
	struct fwohci_desc *fd;
	struct fwohci_handler *fh;
	int n;

	//splassert(IPL_BIO);

	TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
		nfb = TAILQ_NEXT(fb, fb_list);
		fb->fb_off = 0;
		fd = fb->fb_desc;
		fd->fd_branch = (nfb != NULL) ? (nfb->fb_daddr | 1) : 0;
		fd->fd_rescount = fd->fd_reqcount;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
	}

#if DOUBLEBUF
	TAILQ_FOREACH(fb, &fc->fc_buf2, fb_list) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
		nfb = TAILQ_NEXT(fb, fb_list);
		fb->fb_off = 0;
		fd = fb->fb_desc;
		fd->fd_branch = (nfb != NULL) ? (nfb->fb_daddr | 1) : 0;
		fd->fd_rescount = fd->fd_reqcount;
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
	}
#endif /* DOUBLEBUF */

	n = fc->fc_ctx;
	fb = TAILQ_FIRST(&fc->fc_buf);
	if (fc->fc_type != FWOHCI_CTX_ASYNC) {
		OHCI_SYNC_RX_DMA_WRITE(sc, n, OHCI_SUBREG_CommandPtr,
		    fb->fb_daddr | 1);
		MPRINTF("OHCI_SUBREG_CommandPtr(SYNC_RX)", fb->fb_daddr);
		OHCI_SYNC_RX_DMA_WRITE(sc, n, OHCI_SUBREG_ContextControlClear,
		    OHCI_CTXCTL_RX_BUFFER_FILL |
		    OHCI_CTXCTL_RX_CYCLE_MATCH_ENABLE |
		    OHCI_CTXCTL_RX_MULTI_CHAN_MODE |
		    OHCI_CTXCTL_RX_DUAL_BUFFER_MODE);
		OHCI_SYNC_RX_DMA_WRITE(sc, n, OHCI_SUBREG_ContextControlSet,
		    OHCI_CTXCTL_RX_ISOCH_HEADER);
		if (fc->fc_type == FWOHCI_CTX_ISO_MULTI) {
			OHCI_SYNC_RX_DMA_WRITE(sc, n,
			    OHCI_SUBREG_ContextControlSet,
			    OHCI_CTXCTL_RX_BUFFER_FILL);
		}
		fh = LIST_FIRST(&fc->fc_handler);
		OHCI_SYNC_RX_DMA_WRITE(sc, n, OHCI_SUBREG_ContextMatch,
		    (OHCI_CTXMATCH_TAG0 << fh->fh_key2) | fh->fh_key1);
	} else {
		OHCI_ASYNC_DMA_WRITE(sc, n, OHCI_SUBREG_CommandPtr,
		    fb->fb_daddr | 1);
		MPRINTF("OHCI_SUBREG_CommandPtr(ASYNC)", fb->fb_daddr);
	}
}

/*
 * DMA data buffer.
 */
int
fwohci_buf_alloc(struct fwohci_softc *sc, struct fwohci_buf *fb)
{
	int error;

	if (!fb->fb_nseg)
		fb->fb_nseg = 1;

	if ((error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, fb->fb_nseg,
	    PAGE_SIZE, 0, BUS_DMA_WAITOK, &fb->fb_dmamap)) != 0) {
		printf("%s: unable to create buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname,
		    error);
		goto fail_0;
	}
	MPRINTF("bus_dmamap_create", fb->fb_dmamap);

	if ((error = bus_dmamem_alloc(sc->sc_dmat, PAGE_SIZE, PAGE_SIZE,
	    PAGE_SIZE, &fb->fb_seg, 1, &fb->fb_nseg, BUS_DMA_WAITOK)) != 0) {
		printf("%s: unable to allocate buffer, error = %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_1;
	}
	MPRINTF("bus_dmamem_alloc", fb->fb_seg.ds_addr);

	if ((error = bus_dmamem_map(sc->sc_dmat, &fb->fb_seg,
	    fb->fb_nseg, PAGE_SIZE, &fb->fb_buf,
	    BUS_DMA_COHERENT | BUS_DMA_WAITOK)) != 0) {
		printf("%s: unable to map buffer, error = %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_2;
	}

#if 0
	if ((error = bus_dmamap_load(sc->sc_dmat, fb->fb_dmamap,
	    fb->fb_buf, PAGE_SIZE, NULL, BUS_DMA_WAITOK)) != 0) {
#else
	if ((error = bus_dmamap_load_raw(sc->sc_dmat, fb->fb_dmamap,
	    &fb->fb_seg, fb->fb_nseg, PAGE_SIZE, BUS_DMA_WAITOK)) != 0) {
#endif
		printf("%s: unable to load buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname,
		    error);
		goto fail_3;
	}

	return 0;

	bus_dmamap_unload(sc->sc_dmat, fb->fb_dmamap);
  fail_3:
	bus_dmamem_unmap(sc->sc_dmat, fb->fb_buf, PAGE_SIZE);
  fail_2:
	bus_dmamem_free(sc->sc_dmat, &fb->fb_seg, fb->fb_nseg);
	MPRINTF("bus_dmamem_free", fb->fb_seg.ds_addr);
  fail_1:
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
	MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
  fail_0:
	return error;
}

void
fwohci_buf_free(struct fwohci_softc *sc, struct fwohci_buf *fb)
{

	bus_dmamap_unload(sc->sc_dmat, fb->fb_dmamap);
	bus_dmamem_unmap(sc->sc_dmat, fb->fb_buf, PAGE_SIZE);
	bus_dmamem_free(sc->sc_dmat, &fb->fb_seg, fb->fb_nseg);
	MPRINTF("bus_dmamem_free", fb->fb_seg.ds_addr);
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
	MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
}

void
fwohci_buf_init_rx(struct fwohci_softc *sc)
{
	int i;

	//splassert(IPL_BIO);

	/*
	 * Initialize for Asynchronous Receive Queue.
	 */
	fwohci_ctx_init(sc, sc->sc_ctx_arrq);
	fwohci_ctx_init(sc, sc->sc_ctx_arrs);

	/*
	 * Initialize for Isochronous Receive Queue.
	 */
	for (i = 0; i < sc->sc_isoctx; i++) {
		if (sc->sc_ctx_ir[i] != NULL)
			fwohci_ctx_init(sc, sc->sc_ctx_ir[i]);
	}
}

void
fwohci_buf_start_rx(struct fwohci_softc *sc)
{
	int i;

//	splassert(IPL_BIO);

	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_RX_REQUEST,
	    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_RX_RESPONSE,
	    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
	for (i = 0; i < sc->sc_isoctx; i++) {
		if (sc->sc_ctx_ir[i] != NULL)
			OHCI_SYNC_RX_DMA_WRITE(sc, i,
			    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
	}
}

void
fwohci_buf_stop_tx(struct fwohci_softc *sc)
{
	int i;

//	splassert(IPL_BIO);

	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_TX_REQUEST,
	    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_TX_RESPONSE,
	    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);

	/*
	 * Make sure the transmitter is stopped.
	 */
	for (i = 0; i < OHCI_LOOP; i++) {
		DELAY(10);
		if (OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_TX_REQUEST,
		    OHCI_SUBREG_ContextControlClear) & OHCI_CTXCTL_ACTIVE)
			continue;
		if (OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_TX_RESPONSE,
		    OHCI_SUBREG_ContextControlClear) & OHCI_CTXCTL_ACTIVE)
			continue;
		break;
	}

	/*
	 * Initialize for Asynchronous Transmit Queue.
	 */
	fwohci_at_done(sc, sc->sc_ctx_atrq, 1);
	fwohci_at_done(sc, sc->sc_ctx_atrs, 1);
}

void
fwohci_buf_stop_rx(struct fwohci_softc *sc)
{
	int i;

	//splassert(IPL_BIO);

	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_RX_REQUEST,
	    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
	OHCI_ASYNC_DMA_WRITE(sc, OHCI_CTX_ASYNC_RX_RESPONSE,
	    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
	for (i = 0; i < sc->sc_isoctx; i++) {
		OHCI_SYNC_RX_DMA_WRITE(sc, i,
		    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
	}
}

void
fwohci_buf_next(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	struct fwohci_buf *fb, *tfb;

#if DOUBLEBUF
	if (fc->fc_type != FWOHCI_CTX_ISO_MULTI) {
#endif
		while ((fb = TAILQ_FIRST(&fc->fc_buf)) != NULL) {
			if (fc->fc_type != FWOHCI_CTX_ASYNC) {
				if (fb->fb_off == 0)
					break;
			} else {
				if (fb->fb_off != fb->fb_desc->fd_reqcount ||
				    fb->fb_desc->fd_rescount != 0)
					break;
			}
			TAILQ_REMOVE(&fc->fc_buf, fb, fb_list);
			fb->fb_desc->fd_rescount = fb->fb_desc->fd_reqcount;
			fb->fb_off = 0;
			fb->fb_desc->fd_branch = 0;
			tfb = TAILQ_LAST(&fc->fc_buf, fwohci_buf_s);
			tfb->fb_desc->fd_branch = fb->fb_daddr | 1;
			TAILQ_INSERT_TAIL(&fc->fc_buf, fb, fb_list);
		}
#if DOUBLEBUF
	} else {
		struct fwohci_buf_s fctmp;

		/* Cleaning buffer. */
		TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
			fb->fb_off = 0;
			fb->fb_desc->fd_rescount = fb->fb_desc->fd_reqcount;
		}

		/* Rotating buffer. */
		fctmp = fc->fc_buf;
		fc->fc_buf = fc->fc_buf2;
		fc->fc_buf2 = fctmp;
	}
#endif
}

int
fwohci_buf_pktget(struct fwohci_softc *sc, struct fwohci_buf **fbp,
    caddr_t *pp, int reqlen)
{
	struct fwohci_buf *fb;
	struct fwohci_desc *fd;
	int bufend, len = reqlen;
#ifdef	FWOHCI_DEBUG
	int i;
#endif	/* FWOHCI_DEBUG */

	fb = *fbp;
again:
	fd = fb->fb_desc;
	DPRINTFN(1, ("%s: desc %ld, off %d, req %d, res %d, len %d, avail %d",
	    __func__, (long)(fd - sc->sc_desc), fb->fb_off, fd->fd_reqcount,
	    fd->fd_rescount, len,
	    fd->fd_reqcount - fd->fd_rescount - fb->fb_off));
	bufend = fd->fd_reqcount - fd->fd_rescount;
	if (fb->fb_off >= bufend) {
		DPRINTFN(5, ("\n\tbuf %08x finish req %d res %d off %d",
		    fb->fb_desc->fd_data, fd->fd_reqcount, fd->fd_rescount,
		    fb->fb_off));
		if (fd->fd_rescount == 0) {
			*fbp = fb = TAILQ_NEXT(fb, fb_list);
			if (fb != TAILQ_END(fb))
				goto again;
		}
		return 0;
	}
	if (fb->fb_off + len > bufend)
		len = bufend - fb->fb_off;
	bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, fb->fb_off, len,
	    BUS_DMASYNC_POSTREAD);

#ifdef	FWOHCI_DEBUG
	for (i=0; i < (roundup(len, 4) / 4); i++) {
		if ((i % 8) == 0) DPRINTFN(5, ("\n   "));
		DPRINTFN(5, (" %08x",
		    ((u_int32_t *)(fb->fb_buf + fb->fb_off))[i]));
	}
#endif	/* FWOHCI_DEBUG */
	DPRINTF(("\n"));
	*pp = fb->fb_buf + fb->fb_off;
	fb->fb_off += roundup(len, 4);
	return len;
}

int
fwohci_buf_input(struct fwohci_softc *sc, struct fwohci_ctx *fc,
    struct fwohci_pkt *pkt)
{
	caddr_t p;
	struct fwohci_buf *fb;
	int len, count, i;

	bzero(pkt, sizeof(*pkt));
	pkt->fp_uio.uio_iov = pkt->fp_iov;
	pkt->fp_uio.uio_rw = UIO_WRITE;
	pkt->fp_uio.uio_segflg = UIO_SYSSPACE;

	/* Get first quadlet. */
	fb = TAILQ_FIRST(&fc->fc_buf);
	count = 4;
	len = fwohci_buf_pktget(sc, &fb, &p, count);
	if (len <= 0) {
		DPRINTFN(1, ("%s: no input for %d\n", __func__, fc->fc_ctx));
		return 0;
	}
	pkt->fp_hdr[0] = *(u_int32_t *)p;	/* XXX Alignment !!! */
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000F0) >> 4;
	switch (pkt->fp_tcode) {
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
		pkt->fp_hlen = 12;
		pkt->fp_dlen = 4;
		break;
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
		pkt->fp_hlen = 16;
		pkt->fp_dlen = 0;
		break;
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
	case IEEE1394_TCODE_LOCK_REQUEST:
	case IEEE1394_TCODE_LOCK_RESPONSE:
		pkt->fp_hlen = 16;
		break;
	case IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK:
#ifdef	DIAGNOSTIC
		if (fc->fc_type == FWOHCI_CTX_ISO_MULTI)
#endif
		{
			pkt->fp_hlen = 4;
			pkt->fp_dlen = (pkt->fp_hdr[0] >> 16) & 0xFFFF;
			DPRINTFN(5, ("[%d]", pkt->fp_dlen));
			break;
		}
#ifdef	DIAGNOSTIC
		else {
			printf("%s: bad tcode: STREAM_DATA\n", __func__);
			return 0;
		}
#endif
	default:
		pkt->fp_hlen = 12;
		pkt->fp_dlen = 0;
		break;
	}

	/* Get header. */
	while (count < pkt->fp_hlen) {
		len = fwohci_buf_pktget(sc, &fb, &p, pkt->fp_hlen - count);
		if (len == 0) {
			printf("%s: malformed input 1: %d\n", __func__,
			    pkt->fp_hlen - count);
			return 0;
		}
#ifdef	FWOHCI_DEBUG
		fwptr = p; fwlen = len; fwbuf = fb;
#endif	/* FWOHCI_DEBUG */
		bcopy(p, (caddr_t)pkt->fp_hdr + count, len);
#ifdef	FWOHCI_DEBUG
		fwptr = NULL; fwlen = 0; fwbuf = NULL;
#endif	/* FWOHCI_DEBUG */
		count += len;
	}
	if (pkt->fp_hlen == 16 &&
	    pkt->fp_tcode != IEEE1394_TCODE_READ_REQUEST_DATABLOCK)
		pkt->fp_dlen = pkt->fp_hdr[3] >> 16;
	DPRINTFN(1, ("%s: tcode=0x%x, hlen=%d, dlen=%d\n", __func__,
	    pkt->fp_tcode, pkt->fp_hlen, pkt->fp_dlen));

	/* Get data. */
	count = 0;
	i = 0;
	while (i < 6 && count < pkt->fp_dlen) {
		len = fwohci_buf_pktget(sc, &fb,
		    (caddr_t *)&pkt->fp_iov[i].iov_base,
		    pkt->fp_dlen - count);
		if (len == 0) {
			printf("%s: malformed input 2: %d\n", __func__,
			    pkt->fp_dlen - count);
			return 0;
		}
		pkt->fp_iov[i++].iov_len = len;
		count += len;
	}
	pkt->fp_uio.uio_iovcnt = i;
	pkt->fp_uio.uio_resid = count;

	if (count < pkt->fp_dlen) {	/* Eat the remainder of the packet. */
		printf("%s: %d iov exhausted, %d bytes not gotten\n",
		    __func__, i, pkt->fp_dlen - count);
		while (count < pkt->fp_dlen) {
			len = fwohci_buf_pktget(sc, &fb,
			    (caddr_t *)&pkt->fp_trail,
			    ((pkt->fp_dlen - count) > sizeof(*pkt->fp_trail)) ?
			    sizeof(*pkt->fp_trail) : (pkt->fp_dlen - count));
			count += len;
		}
	}

	/* Get trailer. */
	len = fwohci_buf_pktget(sc, &fb, (caddr_t *)&pkt->fp_trail,
	    sizeof(*pkt->fp_trail));
	if (len <= 0) {
		printf("%s: malformed input 3: %d\n", __func__,
		    pkt->fp_hlen - count);
		return 0;
	}
	return 1;
}

int
fwohci_buf_input_ppb(struct fwohci_softc *sc, struct fwohci_ctx *fc,
    struct fwohci_pkt *pkt)
{
	caddr_t p;
	int len;
	struct fwohci_buf *fb;
	struct fwohci_desc *fd;

	if (fc->fc_type ==  FWOHCI_CTX_ISO_MULTI) {
		return fwohci_buf_input(sc, fc, pkt);
	}

	bzero(pkt, sizeof(*pkt));
	pkt->fp_uio.uio_iov = pkt->fp_iov;
	pkt->fp_uio.uio_rw = UIO_WRITE;
	pkt->fp_uio.uio_segflg = UIO_SYSSPACE;

	TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
		if (fb->fb_off == 0)
			break;
	}
	if (fb == NULL)
		return 0;

	fd = fb->fb_desc;
	len = fd->fd_reqcount - fd->fd_rescount;
	if (len == 0)
		return 0;
	bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, fb->fb_off, len,
	    BUS_DMASYNC_POSTREAD);

	p = fb->fb_buf;
	fb->fb_off += roundup(len, 4);
	if (len < 8) {
		printf("%s: malformed input 1: %d\n", __func__, len);
		return 0;
	}

	/*
	 * Get trailer first, may be bogus data unless status update
	 * in descriptor is set.
	 */
	pkt->fp_trail = (u_int32_t *)p;
	*pkt->fp_trail = (*pkt->fp_trail & 0xFFFF) | (fd->fd_status << 16);
	pkt->fp_hdr[0] = ((u_int32_t *)p)[1];
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000F0) >> 4;
#ifdef	DIAGNOSTIC
	if (pkt->fp_tcode != IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		printf("%s: bad tcode: 0x%x\n", __func__, pkt->fp_tcode);
		return 0;
	}
#endif
	pkt->fp_hlen = 4;
	pkt->fp_dlen = pkt->fp_hdr[0] >> 16;
	p += 8;
	len -= 8;
	if (pkt->fp_dlen != len) {
		printf("%s: malformed input 2: %d != %d\n", __func__,
		    pkt->fp_dlen, len);
		return 0;
	}
	DPRINTFN(1, ("%s: tcode=0x%x, hlen=%d, dlen=%d\n", __func__,
	    pkt->fp_tcode, pkt->fp_hlen, pkt->fp_dlen));
	pkt->fp_iov[0].iov_base = p;
	pkt->fp_iov[0].iov_len = len;
	pkt->fp_uio.uio_iovcnt = 1;
	pkt->fp_uio.uio_resid = len;
	return 1;
}

int
fwohci_handler_set(struct fwohci_softc *sc, int tcode,
    u_int32_t key1, u_int32_t key2, u_int32_t key3,
    int (*handler)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *arg)
{
	struct fwohci_ctx *fc;
	struct fwohci_handler *fh;
	int i, j, s;

	if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		int isasync = key1 & OHCI_ASYNC_STREAM;

		key1 &= IEEE1394_ISOCH_MASK;
		j = sc->sc_isoctx;
		fh = NULL;
		for (i = 0; i < sc->sc_isoctx; i++) {
			if ((fc = sc->sc_ctx_ir[i]) == NULL) {
				if (j == sc->sc_isoctx)
					j = i;
				continue;
			}
			fh = LIST_FIRST(&fc->fc_handler);
			if (fh->fh_tcode == tcode &&
			    fh->fh_key1 == key1 && fh->fh_key2 == key2)
				break;
			fh = NULL;
		}
		if (fh == NULL) {
			if (handler == NULL)
				return 0;
			if (j == sc->sc_isoctx) {
				DPRINTF(("%s: no more free context\n",
				    __func__));
				return ENOMEM;
			}
			if ((fc = sc->sc_ctx_ir[j]) == NULL) {
				fwohci_ctx_alloc(sc, &fc, OHCI_BUF_IR_CNT, j,
				    isasync ? FWOHCI_CTX_ISO_SINGLE :
				    FWOHCI_CTX_ISO_MULTI);
				sc->sc_ctx_ir[j] = fc;
			}
		}
	} else {
		switch (tcode) {
		case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
		case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		case IEEE1394_TCODE_READ_REQUEST_QUADLET:
		case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
		case IEEE1394_TCODE_LOCK_REQUEST:
			fc = sc->sc_ctx_arrq;
			break;
		case IEEE1394_TCODE_WRITE_RESPONSE:
		case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
		case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
		case IEEE1394_TCODE_LOCK_RESPONSE:
			fc = sc->sc_ctx_arrs;
			break;
		default:
			return EIO;
		}
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
			if (fh->fh_tcode == tcode &&
			    fh->fh_key1 == key1 &&
			    fh->fh_key2 == key2 &&
			    fh->fh_key3 == key3)
				break;
		}
	}
	if (handler == NULL) {
		if (fh != NULL) {
			LIST_REMOVE(fh, fh_list);
			FREE(fh, M_DEVBUF);
			MPRINTF("FREE(DEVBUF)", fh);
			fh = NULL;	/* XXX */
		}
		if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
			OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx,
			    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
			sc->sc_ctx_ir[fc->fc_ctx] = NULL;
			fwohci_ctx_free(sc, fc);
		}
		DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x, 0x%x [NULL]\n",
		    __func__, fc->fc_ctx, tcode, key1, key2, key3));

		return 0;
	}
	s = splbio();
	if (fh == NULL) {
		MALLOC(fh, struct fwohci_handler *, sizeof(*fh),
		    M_DEVBUF, M_WAITOK);
		MPRINTF("MALLOC(DEVBUF)", fh);
		bzero(fh, sizeof(*fh));
	}
	fh->fh_tcode = tcode;
	fh->fh_key1 = key1;
	fh->fh_key2 = key2;
	fh->fh_key3 = key3;
	fh->fh_handler = handler;
	fh->fh_handarg = arg;

	if (fh->fh_list.le_prev == NULL)
		LIST_INSERT_HEAD(&fc->fc_handler, fh, fh_list);
	splx(s);

	DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x, 0x%x [%08x]\n",
	    __func__, fc->fc_ctx, tcode, key1, key2, key3, (u_int32_t)handler));

	if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		s = splbio();
		fwohci_ctx_init(sc, fc);
		OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
		splx(s);
		DPRINTFN(1, ("%s: SYNC desc %ld\n", __func__,
		    (long)(TAILQ_FIRST(&fc->fc_buf)->fb_desc - sc->sc_desc)));
	}
	return 0;
}

int
fwohci_block_handler_set(struct fwohci_softc *sc, int tcode,
    u_int32_t key1, u_int32_t key2, u_int32_t key3, int len,
    int (*handler)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *arg)
{
	u_int32_t key3n = (key3 & 0xFFFF) | ((len & 0xFFFF) << 16);

	return (fwohci_handler_set(sc, tcode, key1, key2, key3n, handler, arg));
}

/*
 * Asynchronous Receive Requests input frontend.
 */
void
fwohci_arrq_input(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	u_int16_t srcid, datalen = 0;
	int rcode, tlabel;
	u_int32_t key1, key2;
	struct fwohci_handler *fh;
	struct fwohci_pkt pkt, res;

	/*
	 * Do not return if next packet is in the buffer, or the next
	 * packet cannot be received until the next receive interrupt.
	 */
	while (fwohci_buf_input(sc, fc, &pkt)) {
		switch(pkt.fp_tcode) {
		case OHCI_TCODE_PHY:
			fwohci_phy_input(sc, &pkt);
			continue; break;
		case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
			datalen = pkt.fp_dlen;
			break;
		case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
			datalen = pkt.fp_hdr[3] >> 16;
			break;
		}
		key1 = pkt.fp_hdr[1] & 0xFFFF;
		key2 = pkt.fp_hdr[2];
		bzero(&res, sizeof(res));
		res.fp_uio.uio_rw = UIO_WRITE;
		res.fp_uio.uio_segflg = UIO_SYSSPACE;
		srcid = pkt.fp_hdr[1] >> 16;
		tlabel = (pkt.fp_hdr[0] & 0x0000FC00) >> 10;
		DPRINTFN(1, ("%s: tcode 0x%x, from 0x%04x, tlabel 0x%x, "
		    "hlen %d, dlen %d\n", __func__, pkt.fp_tcode,
		    srcid, tlabel, pkt.fp_hlen, pkt.fp_dlen));
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
			if (pkt.fp_tcode == fh->fh_tcode &&
			    ((fh->fh_key3 & 0xFFFF) == OHCI_NodeId_NodeNumber ||
			     (srcid & OHCI_NodeId_NodeNumber) ==
			     (fh->fh_key3 & 0xFFFF)) &&
			    ((key1 == fh->fh_key1 && key2 == fh->fh_key2) ||
			     (datalen && key1 == fh->fh_key1 &&
			      key2 >= fh->fh_key2 &&
			      (key2 + datalen) <=
			       (fh->fh_key2 + (fh->fh_key3 >> 16)))))
			{
				DPRINTFN(5, ("%s: handler 0x%08x(0x%08x)\n",
				    __func__, (u_int32_t)(*fh->fh_handler),
				    (u_int32_t)(fh->fh_handarg)));
				rcode = (*fh->fh_handler)(sc, fh->fh_handarg,
				    &pkt);
				DPRINTFN(5, ("%s:  --> rcode %d\n", __func__,
				    rcode));
				break;
			}
		}
		if (fh == NULL) {
			rcode = IEEE1394_RCODE_ADDRESS_ERROR;
			DPRINTFN(1, ("%s: no listener: tcode 0x%x, "
			    "addr=0x%04x%08x\n", __func__, pkt.fp_tcode,
			    key1, key2));
		}
		if (((*pkt.fp_trail & 0x001F0000) >> 16) !=
		    OHCI_CTXCTL_EVENT_ACK_PENDING)
			continue;
		if (rcode != -1)
			fwohci_atrs_output(sc, rcode, &pkt, &res);
	}
	fwohci_buf_next(sc, fc);
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlSet,
	    OHCI_CTXCTL_WAKE);
}


/*
 * Asynchronous Receive Response input frontend.
 */
void
fwohci_arrs_input(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	struct fwohci_pkt pkt;
	struct fwohci_handler *fh;
	u_int16_t srcid;
	int rcode, tlabel;

	while (fwohci_buf_input(sc, fc, &pkt)) {
		srcid = pkt.fp_hdr[1] >> 16;
		rcode = (pkt.fp_hdr[1] & 0x0000F000) >> 12;
		tlabel = (pkt.fp_hdr[0] & 0x0000FC00) >> 10;
		DPRINTFN(1, ("%s: tcode 0x%x, from 0x%04x, tlabel 0x%x, "
		    "rcode 0x%x, hlen %d, dlen %d\n", __func__,
		    pkt.fp_tcode, srcid, tlabel, rcode, pkt.fp_hlen,
		    pkt.fp_dlen));
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
			if (pkt.fp_tcode == fh->fh_tcode &&
			    (srcid & OHCI_NodeId_NodeNumber) == fh->fh_key1 &&
			    tlabel == fh->fh_key2) {
				(*fh->fh_handler)(sc, fh->fh_handarg, &pkt);
				LIST_REMOVE(fh, fh_list);
				FREE(fh, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", fh);
				fh = NULL;	/* XXX */
				break;
			}
		}
		if (fh == NULL)
			DPRINTFN(1, ("%s: no listener\n", __func__));
	}
	fwohci_buf_next(sc, fc);
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlSet,
	    OHCI_CTXCTL_WAKE);
}

/*
 * Isochronous Receive input frontend.
 */
void
fwohci_ir_input(struct fwohci_softc *sc, struct fwohci_ctx *fc)
{
	int rcode, chan, tag;
	struct iovec *iov;
	struct fwohci_handler *fh;
	struct fwohci_pkt pkt;

#if DOUBLEBUF
	if (fc->fc_type == FWOHCI_CTX_ISO_MULTI) {
		struct fwohci_buf *fb;
		int i;
		u_int32_t reg;

		/* Stop dma engine before read buffer. */
		reg = OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlClear);
		DPRINTFN(5, ("%s: %08x =>", __func__, reg));
		if (reg & OHCI_CTXCTL_RUN) {
			OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx,
			    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
		}
		DPRINTFN(5, (" %08x\n", OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlClear)));

		i = 0;
		while ((reg = OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet)) & OHCI_CTXCTL_ACTIVE) {
			delay(10);
			if (++i > 10000) {
				printf("cannot stop dma engine 0x%08x\n", reg);
				return;
			}
		}

		/* Rotate dma buffer. */
		fb = TAILQ_FIRST(&fc->fc_buf2);
		OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx, OHCI_SUBREG_CommandPtr,
		    fb->fb_daddr | 1);
		MPRINTF("OHCI_SUBREG_CommandPtr(SYNC_RX)", fb->fb_daddr);
		/* Start dma engine. */
		OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
		OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntEventClear,
		    (1 << fc->fc_ctx));
	}
#endif

	while (fwohci_buf_input_ppb(sc, fc, &pkt)) {
		chan = (pkt.fp_hdr[0] & 0x00003F00) >> 8;
		tag  = (pkt.fp_hdr[0] & 0x0000C000) >> 14;
		DPRINTFN(1, ("%s: hdr 0x%08x, tcode 0x%0x, hlen %d, dlen %d\n",
		    __func__, pkt.fp_hdr[0], pkt.fp_tcode, pkt.fp_hlen,
		    pkt.fp_dlen));
		if (tag == IEEE1394_TAG_GASP) {
			/*
			 * The pkt with tag=3 is GASP format.
			 * Move GASP header to header part.
			 */
			if (pkt.fp_dlen < 8)
				continue;
			iov = pkt.fp_iov;
			/* Assuming pkt per buffer mode. */
			pkt.fp_hdr[1] = ntohl(((u_int32_t *)iov->iov_base)[0]);
			pkt.fp_hdr[2] = ntohl(((u_int32_t *)iov->iov_base)[1]);
			iov->iov_base = (caddr_t)iov->iov_base + 8;
			iov->iov_len -= 8;
			pkt.fp_hlen += 8;
			pkt.fp_dlen -= 8;
		}
		sc->sc_isopktcnt.ev_count++;
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
			if (pkt.fp_tcode == fh->fh_tcode &&
			    chan == fh->fh_key1 && tag == fh->fh_key2) {
				rcode = (*fh->fh_handler)(sc, fh->fh_handarg,
				    &pkt);
				break;
			}
		}
#ifdef	FWOHCI_DEBUG
		if (fh == NULL) {
			DPRINTFN(1, ("%s: no handler\n", __func__));
		} else {
			DPRINTFN(1, ("%s: rcode %d\n", __func__, rcode));
		}
#endif	/* FWOHCI_DEBUG */
	}
	fwohci_buf_next(sc, fc);

	if (fc->fc_type == FWOHCI_CTX_ISO_SINGLE) {
		OHCI_SYNC_RX_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet,
		    OHCI_CTXCTL_WAKE);
	}
}

/*
 * Asynchronous Transmit common routine.
 */
int
fwohci_at_output(struct fwohci_softc *sc, struct fwohci_ctx *fc,
    struct fwohci_pkt *pkt)
{
	struct fwohci_buf *fb;
	struct fwohci_desc *fd;
	struct mbuf *m, *m0;
	int i, ndesc, error, off, len;
	u_int32_t val;
#ifdef	FWOHCI_DEBUG
	struct iovec *iov;
#endif	/* FWOHCI_DEBUG */

	if ((sc->sc_nodeid & OHCI_NodeId_NodeNumber) == IEEE1394_BCAST_PHY_ID)
		/* We can't send anything during selfid duration */
		return EAGAIN;

#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: tcode 0x%x, hlen %d, dlen %d", __func__,
	    pkt->fp_tcode, pkt->fp_hlen, pkt->fp_dlen));
	for (i = 0; i < pkt->fp_hlen/4; i++)
		DPRINTFN(2, ("%s%08x", i?" ":"\n    ", pkt->fp_hdr[i]));
	DPRINTFN(2, (" $"));
	if (pkt->fp_uio.uio_iovcnt) {
		for (ndesc = 0, iov = pkt->fp_iov;
		     ndesc < pkt->fp_uio.uio_iovcnt; ndesc++, iov++) {
			for (i = 0; i < iov->iov_len; i++)
				DPRINTFN(2, ("%s%02x", (i%32)?((i%4)?"":" ")
							     :"\n    ",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(2, (" $"));
		}
	}
	DPRINTFN(1, ("\n"));
#endif	/* FWOHCI_DEBUG */

	if ((m = pkt->fp_m) != NULL) {
		for (ndesc = 2; m != NULL; m = m->m_next)
			ndesc++;
		if (ndesc > OHCI_DESC_MAX) {
			m0 = NULL;
			ndesc = 2;
			for (off = 0; off < pkt->fp_dlen; off += len) {
				if (m0 == NULL) {
					MGETHDR(m0, M_DONTWAIT, MT_DATA);
					MPRINTF("MGETHDR", m0);
					if (m0 != NULL) {
#ifdef	__NetBSD__
						M_COPY_PKTHDR(m0, pkt->fp_m);
#else
						M_DUP_PKTHDR(m0, pkt->fp_m);
#endif
					}
					m = m0;
				} else {
					MGET(m->m_next, M_DONTWAIT, MT_DATA);
					MPRINTF("MGET", m->m_next);
					m = m->m_next;
				}
				if (m != NULL)
					MCLGET(m, M_DONTWAIT);
				if (m == NULL || (m->m_flags & M_EXT) == 0) {
					m_freem(m0);
					MPRINTF("m_freem", m0);
					return ENOMEM;
				}
				len = pkt->fp_dlen - off;
				if (len > m->m_ext.ext_size)
					len = m->m_ext.ext_size;
				m_copydata(pkt->fp_m, off, len,
				    mtod(m, caddr_t));
				m->m_len = len;
				ndesc++;
			}
			m_freem(pkt->fp_m);
			MPRINTF("m_freem", pkt->fp_m);
			pkt->fp_m = m0;
		}
	} else
		ndesc = 2 + pkt->fp_uio.uio_iovcnt;

	if (ndesc > OHCI_DESC_MAX)
		return ENOBUFS;

	if (fc->fc_bufcnt > 50)			/* XXX */
		return ENOBUFS;

	fb = malloc(sizeof(*fb), M_DEVBUF, M_WAITOK);
	MPRINTF("malloc(DEVBUF)", fb);
	fb->fb_nseg = ndesc;
	fb->fb_desc = fwohci_desc_get(sc, ndesc);
	if (fb->fb_desc == NULL) {
		free(fb, M_DEVBUF);
		MPRINTF("free(DEVBUF)", fb);
		fb = NULL;	/* XXX */
		return ENOBUFS;
	}
	fb->fb_daddr = sc->sc_ddmamap->dm_segs[0].ds_addr +
	    ((caddr_t)fb->fb_desc - (caddr_t)sc->sc_desc);
	fb->fb_m = pkt->fp_m;
	fb->fb_callback = pkt->fp_callback;
	fb->fb_statuscb = pkt->fp_statuscb;
	fb->fb_statusarg = pkt->fp_statusarg;

	if (ndesc > 2) {
		if ((error = bus_dmamap_create(sc->sc_dmat, pkt->fp_dlen, ndesc,
		    PAGE_SIZE, 0, BUS_DMA_WAITOK, &fb->fb_dmamap)) != 0) {
			fwohci_desc_put(sc, fb->fb_desc, ndesc);
			free(fb, M_DEVBUF);
			MPRINTF("free(DEVBUF)", fb);
			fb = NULL;	/* XXX */
			return error;
		}
		MPRINTF("bus_dmamap_create", fb->fb_dmamap);

		if (pkt->fp_m != NULL)
			error = bus_dmamap_load_mbuf(sc->sc_dmat, fb->fb_dmamap,
			    pkt->fp_m, BUS_DMA_WAITOK);
		else
			error = bus_dmamap_load_uio(sc->sc_dmat, fb->fb_dmamap,
			    &pkt->fp_uio, BUS_DMA_WAITOK);
		if (error != 0) {
			bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
			MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
			fwohci_desc_put(sc, fb->fb_desc, ndesc);
			free(fb, M_DEVBUF);
			MPRINTF("free(DEVBUF)", fb);
			fb = NULL;	/* XXX */
			return error;
		}
		bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, 0, pkt->fp_dlen,
		    BUS_DMASYNC_PREWRITE);
	}

	fd = fb->fb_desc;
	fd->fd_flags = OHCI_DESC_IMMED;
	fd->fd_reqcount = pkt->fp_hlen;
	fd->fd_data = 0;
	fd->fd_branch = 0;
	fd->fd_status = 0;
	if (fc->fc_ctx == OHCI_CTX_ASYNC_TX_RESPONSE) {
		i = 3;				/* XXX: 3 sec */
		val = OHCI_CSR_READ(sc, OHCI_REG_IsochronousCycleTimer);
		fd->fd_timestamp = ((val >> 12) & 0x1FFF) |
		    ((((val >> 25) + i) & 0x7) << 13);
	} else
		fd->fd_timestamp = 0;

#if 1	/* XXX */
	bcopy(pkt->fp_hdr, fd + 1, pkt->fp_hlen);
#else
	bcopy(pkt->fp_hdr, fd->fd_immed, pkt->fp_hlen);
#endif

	if (ndesc > 2) {
		for (i = 0; i < ndesc - 2; i++) {
			fd = fb->fb_desc + 2 + i;
			fd->fd_flags = 0;
			fd->fd_reqcount = fb->fb_dmamap->dm_segs[i].ds_len;
			fd->fd_data = fb->fb_dmamap->dm_segs[i].ds_addr;
			fd->fd_branch = 0;
			fd->fd_status = 0;
			fd->fd_timestamp = 0;
		}
		bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, 0, pkt->fp_dlen,
		    BUS_DMASYNC_POSTWRITE);
	}
	fd->fd_flags |= OHCI_DESC_LAST | OHCI_DESC_BRANCH;
	fd->fd_flags |= OHCI_DESC_INTR_ALWAYS;

#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: desc %ld", __func__,
	    (long)(fb->fb_desc - sc->sc_desc)));
	for (i = 0; i < ndesc * 4; i++)
		DPRINTFN(2, ("%s%08x", i&7?" ":"\n    ",
		    ((u_int32_t *)fb->fb_desc)[i]));
	DPRINTFN(1, ("\n"));
#endif	/* FWOHCI_DEBUG */

	val = OHCI_ASYNC_DMA_READ(sc, fc->fc_ctx,
	    OHCI_SUBREG_ContextControlClear);

	if (val & OHCI_CTXCTL_RUN) {
		if (fc->fc_branch == NULL) {
			OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
			    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
			goto run;
		}
		*fc->fc_branch = fb->fb_daddr | ndesc;
		OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_WAKE);
	} else {
  run:
		OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_CommandPtr, fb->fb_daddr | ndesc);
		MPRINTF("OHCI_SUBREG_CommandPtr(ASYNC)", fb->fb_daddr);
		OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_RUN);
	}
	fc->fc_branch = &fd->fd_branch;

	fc->fc_bufcnt++;
	TAILQ_INSERT_TAIL(&fc->fc_buf, fb, fb_list);
	pkt->fp_m = NULL;
	return 0;
}

void
fwohci_at_done(struct fwohci_softc *sc, struct fwohci_ctx *fc, int force)
{
	struct fwohci_buf *fb;
	struct fwohci_desc *fd;
	struct fwohci_pkt pkt;
	int i;

//	splassert(IPL_BIO);

	while ((fb = TAILQ_FIRST(&fc->fc_buf)) != NULL) {
		fd = fb->fb_desc;
#ifdef	FWOHCI_DEBUG
		DPRINTFN(1, ("%s: %sdesc %ld (%d)", __func__,
		    force ? "force " : "", (long)(fd - sc->sc_desc),
		    fb->fb_nseg));
		for (i = 0; i < fb->fb_nseg * 4; i++)
			DPRINTFN(2, ("%s%08x", i&7?" ":"\n    ",
			    ((u_int32_t *)fd)[i]));
		DPRINTFN(1, ("\n"));
#endif	/* FWOHCI_DEBUG */
		if (fb->fb_nseg > 2)
			fd += fb->fb_nseg - 1;
		if (!force && !(fd->fd_status & OHCI_CTXCTL_ACTIVE))
			break;
		TAILQ_REMOVE(&fc->fc_buf, fb, fb_list);
		if (fc->fc_branch == &fd->fd_branch) {
			OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
			    OHCI_SUBREG_ContextControlClear, OHCI_CTXCTL_RUN);
			fc->fc_branch = NULL;
			for (i = 0; i < OHCI_LOOP; i++) {
				if (!(OHCI_ASYNC_DMA_READ(sc, fc->fc_ctx,
				    OHCI_SUBREG_ContextControlClear) &
				    OHCI_CTXCTL_ACTIVE))
					break;
				DELAY(10);
			}
		}

		if (fb->fb_statuscb) {
			bzero(&pkt, sizeof(pkt));
			pkt.fp_status = fd->fd_status;
			bcopy(fd + 1, pkt.fp_hdr, sizeof(pkt.fp_hdr[0]));

			/* Indicate this is just returning the status bits. */
			pkt.fp_tcode = -1;
			(*fb->fb_statuscb)(sc, fb->fb_statusarg, &pkt);
			fb->fb_statuscb = NULL;
			fb->fb_statusarg = NULL;
		}
		fwohci_desc_put(sc, fb->fb_desc, fb->fb_nseg);
		if (fb->fb_nseg > 2) {
			bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
			MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
		}
		fc->fc_bufcnt--;
		if (fb->fb_callback) {
			(*fb->fb_callback)(sc->sc_sc1394.sc1394_if, fb->fb_m);
			fb->fb_callback = NULL;
		} else if (fb->fb_m != NULL) {
			m_freem(fb->fb_m);
			MPRINTF("m_freem", fb->fb_m);
		}
		free(fb, M_DEVBUF);
		MPRINTF("free(DEVBUF)", fb);
		fb = NULL;	/* XXX */
	}
}

/*
 * Asynchronous Transmit Reponse -- in response to request packet.
 */
void
fwohci_atrs_output(struct fwohci_softc *sc, int rcode, struct fwohci_pkt *req,
    struct fwohci_pkt *res)
{

	if (((*req->fp_trail & 0x001F0000) >> 16) !=
	    OHCI_CTXCTL_EVENT_ACK_PENDING)
		return;

	res->fp_hdr[0] = (req->fp_hdr[0] & 0x0000FC00) | 0x00000100;
	res->fp_hdr[1] = (req->fp_hdr[1] & 0xFFFF0000) | (rcode << 12);
	switch (req->fp_tcode) {
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		res->fp_tcode = IEEE1394_TCODE_WRITE_RESPONSE;
		res->fp_hlen = 12;
		break;
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
		res->fp_tcode = IEEE1394_TCODE_READ_RESPONSE_QUADLET;
		res->fp_hlen = 16;
		res->fp_dlen = 0;
		if (res->fp_uio.uio_iovcnt == 1 && res->fp_iov[0].iov_len == 4)
			res->fp_hdr[3] =
			    *(u_int32_t *)res->fp_iov[0].iov_base;
		res->fp_uio.uio_iovcnt = 0;
		break;
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_LOCK_REQUEST:
		if (req->fp_tcode == IEEE1394_TCODE_LOCK_REQUEST)
			res->fp_tcode = IEEE1394_TCODE_LOCK_RESPONSE;
		else
			res->fp_tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
		res->fp_hlen = 16;
		res->fp_dlen = res->fp_uio.uio_resid;
		res->fp_hdr[3] = res->fp_dlen << 16;
		break;
	}
	res->fp_hdr[0] |= (res->fp_tcode << 4);
	fwohci_at_output(sc, sc->sc_ctx_atrs, res);
}

/*
 * APPLICATION LAYER SERVICES.
 */

/*
 * Retrieve Global UID from GUID ROM.
 */
int
fwohci_guidrom_init(struct fwohci_softc *sc)
{
	int i, n, off;
	u_int32_t val1, val2;

	/*
	 * Extract the Global UID.
	 */
	val1 = OHCI_CSR_READ(sc, OHCI_REG_GUIDHi);
	val2 = OHCI_CSR_READ(sc, OHCI_REG_GUIDLo);

	if (val1 != 0 || val2 != 0) {
		sc->sc_sc1394.sc1394_guid[0] = (val1 >> 24) & 0xFF;
		sc->sc_sc1394.sc1394_guid[1] = (val1 >> 16) & 0xFF;
		sc->sc_sc1394.sc1394_guid[2] = (val1 >>  8) & 0xFF;
		sc->sc_sc1394.sc1394_guid[3] = (val1 >>  0) & 0xFF;
		sc->sc_sc1394.sc1394_guid[4] = (val2 >> 24) & 0xFF;
		sc->sc_sc1394.sc1394_guid[5] = (val2 >> 16) & 0xFF;
		sc->sc_sc1394.sc1394_guid[6] = (val2 >>  8) & 0xFF;
		sc->sc_sc1394.sc1394_guid[7] = (val2 >>  0) & 0xFF;
	} else {
		val1 = OHCI_CSR_READ(sc, OHCI_REG_Version);
		if ((val1 & OHCI_Version_GUID_ROM) == 0)
			return -1;
		OHCI_CSR_WRITE(sc, OHCI_REG_Guid_Rom, OHCI_Guid_AddrReset);
		for (i = 0; i < OHCI_LOOP; i++) {
			val1 = OHCI_CSR_READ(sc, OHCI_REG_Guid_Rom);
			if (!(val1 & OHCI_Guid_AddrReset))
				break;
			DELAY(10);
		}
		off = OHCI_BITVAL(val1, OHCI_Guid_MiniROM) + 4;
		val2 = 0;
		for (n = 0; n < off + sizeof(sc->sc_sc1394.sc1394_guid); n++) {
			OHCI_CSR_WRITE(sc, OHCI_REG_Guid_Rom,
			    OHCI_Guid_RdStart);
			for (i = 0; i < OHCI_LOOP; i++) {
				val1 = OHCI_CSR_READ(sc, OHCI_REG_Guid_Rom);
				if (!(val1 & OHCI_Guid_RdStart))
					break;
				DELAY(10);
			}
			if (n < off)
				continue;
			val1 = OHCI_BITVAL(val1, OHCI_Guid_RdData);
			sc->sc_sc1394.sc1394_guid[n - off] = val1;
			val2 |= val1;
		}
		if (val2 == 0)
			return -1;
	}
	return 0;
}

/*
 * Initialization for Configuration ROM (no DMA context).
 */

#define	CFR_MAXUNIT		20

typedef struct configromctx {
	u_int32_t	*ptr;
	int		 curunit;
	struct {
		u_int32_t	*start;
		int		 length;
		u_int32_t	*refer;
		int		 refunit;
	} unit[CFR_MAXUNIT];
} configromctx;

#define	CFR_PUT_DATA4(cfr, d1, d2, d3, d4)				\
	(*(cfr)->ptr++ = (((d1)<<24) | ((d2)<<16) | ((d3)<<8) | (d4)))

#define	CFR_PUT_DATA1(cfr, d)		(*(cfr)->ptr++ = (d))

#define	CFR_PUT_VALUE(cfr, key, d)	(*(cfr)->ptr++ = ((key)<<24) | (d))

#define	CFR_PUT_CRC(cfr, n)						\
	(*(cfr)->unit[n].start = ((cfr)->unit[n].length << 16) |	\
	    fwohci_crc16((cfr)->unit[n].start + 1, (cfr)->unit[n].length))

#define	CFR_START_UNIT(cfr, n)						\
do {									\
	if ((cfr)->unit[n].refer != NULL) {				\
		*(cfr)->unit[n].refer |=				\
		    (cfr)->ptr - (cfr)->unit[n].refer;			\
		CFR_PUT_CRC(cfr, (cfr)->unit[n].refunit);		\
	}								\
	(cfr)->curunit = (n);						\
	(cfr)->unit[n].start = (cfr)->ptr++;				\
} while (0)

#define	CFR_PUT_REFER(cfr, key, n)					\
do {									\
	(cfr)->unit[n].refer = (cfr)->ptr;				\
	(cfr)->unit[n].refunit = (cfr)->curunit;			\
	*(cfr)->ptr++ = (key) << 24;					\
} while (0)

#define	CFR_END_UNIT(cfr)						\
do {									\
	(cfr)->unit[(cfr)->curunit].length = (cfr)->ptr -		\
	    ((cfr)->unit[(cfr)->curunit].start + 1);			\
	CFR_PUT_CRC(cfr, (cfr)->curunit);				\
} while (0)

u_int16_t
fwohci_crc16(u_int32_t *ptr, int len)
{
	int shift;
	u_int32_t crc, sum, data;

	crc = 0;
	while (len-- > 0) {
		data = *ptr++;
		for (shift = 28; shift >= 0; shift -= 4) {
			sum = ((crc >> 12) ^ (data >> shift)) & 0x000F;
			crc = (crc << 4) ^ (sum << 12) ^ (sum << 5) ^ sum;
		}
		crc &= 0xFFFF;
	}
	return crc;
}

void
fwohci_configrom_init(struct fwohci_softc *sc)
{
	int i, val;
	struct fwohci_buf *fb;
	u_int32_t *hdr;
	struct configromctx cfr;

	//splassert(IPL_BIO);

	fb = &sc->sc_buf_cnfrom;
	bzero(&cfr, sizeof(cfr));
	cfr.ptr = hdr = (u_int32_t *)fb->fb_buf;

	/* Headers. */
	CFR_START_UNIT(&cfr, 0);
	CFR_PUT_DATA1(&cfr, OHCI_CSR_READ(sc, OHCI_REG_BusId));
	CFR_PUT_DATA1(&cfr, OHCI_CSR_READ(sc, OHCI_REG_BusOptions));
	CFR_PUT_DATA1(&cfr, OHCI_CSR_READ(sc, OHCI_REG_GUIDHi));
	CFR_PUT_DATA1(&cfr, OHCI_CSR_READ(sc, OHCI_REG_GUIDLo));
	CFR_END_UNIT(&cfr);
	/* Copy info_length from crc_length. */
	*hdr |= (*hdr & 0x00FF0000) << 8;
	OHCI_CSR_WRITE(sc, OHCI_REG_ConfigROMhdr, *hdr);

	/* Root directory. */
	CFR_START_UNIT(&cfr, 1);
	CFR_PUT_VALUE(&cfr, 0x03, 0x00005E);	/* Vendor ID. */
	CFR_PUT_REFER(&cfr, 0x81, 2);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x0C, 0x0083C0);	/* Node capability. */
						/* spt,64,fix,lst,drq */
#ifdef	INET
	CFR_PUT_REFER(&cfr, 0xD1, 3);		/* IPv4 unit directory. */
#endif	/* INET */
#ifdef	INET6
	CFR_PUT_REFER(&cfr, 0xD1, 4);		/* IPv6 unit directory. */
#endif	/* INET6 */
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 2);
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
#ifdef	__NetBSD__
	CFR_PUT_DATA4(&cfr, 'N', 'e', 't', 'B');
	CFR_PUT_DATA4(&cfr, 'S', 'D', 0x00, 0x00);
#else
	CFR_PUT_DATA4(&cfr, 'O', 'p', 'e', 'n');
	CFR_PUT_DATA4(&cfr, 'B', 'S', 'D', 0x00);
#endif
	CFR_END_UNIT(&cfr);

#ifdef	INET
	/* IPv4 unit directory. */
	CFR_START_UNIT(&cfr, 3);
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005E);	/* Unit spec ID. */
	CFR_PUT_REFER(&cfr, 0x81, 6);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000001);	/* Unit sw version. */
	CFR_PUT_REFER(&cfr, 0x81, 7);		/* Textual descriptor offset. */
	CFR_PUT_REFER(&cfr, 0x95, 8);		/* unit location. */
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 6);
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
	CFR_PUT_DATA4(&cfr, 'I', 'A', 'N', 'A');
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 7);
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
	CFR_PUT_DATA4(&cfr, 'I', 'P', 'v', '4');
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 8);		/* Spec's valid addr range. */
	CFR_PUT_DATA1(&cfr, FW_FIFO_HI);
	CFR_PUT_DATA1(&cfr, (FW_FIFO_LO | 0x1));
	CFR_PUT_DATA1(&cfr, FW_FIFO_HI);
	CFR_PUT_DATA1(&cfr, FW_FIFO_LO);
	CFR_END_UNIT(&cfr);

#endif	/* INET */

#ifdef	INET6
	/* IPv6 unit directory. */
	CFR_START_UNIT(&cfr, 4);
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005E);	/* Unit spec id. */
	CFR_PUT_REFER(&cfr, 0x81, 9);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000002);	/* Unit sw version. */
						/* XXX: TBA by IANA */
	CFR_PUT_REFER(&cfr, 0x81, 10);		/* Textual descriptor offset. */
	CFR_PUT_REFER(&cfr, 0x95, 11);		/* Unit location. */
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 9);
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
	CFR_PUT_DATA4(&cfr, 'I', 'A', 'N', 'A');
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 10);
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);
	CFR_PUT_DATA4(&cfr, 'I', 'P', 'v', '6');
	CFR_END_UNIT(&cfr);

	CFR_START_UNIT(&cfr, 11);		/* Spec's valid addr range. */
	CFR_PUT_DATA1(&cfr, FW_FIFO_HI);
	CFR_PUT_DATA1(&cfr, (FW_FIFO_LO | 0x1));
	CFR_PUT_DATA1(&cfr, FW_FIFO_HI);
	CFR_PUT_DATA1(&cfr, FW_FIFO_LO);
	CFR_END_UNIT(&cfr);

#endif	/* INET6 */

	fb->fb_off = cfr.ptr - hdr;
#ifdef	FWOHCI_DEBUG
	DPRINTF(("%s: Config ROM:", sc->sc_sc1394.sc1394_dev.dv_xname));
	for (i = 0; i < fb->fb_off; i++)
		DPRINTF(("%s%08x", i&7?" ":"\n    ", hdr[i]));
	DPRINTF(("\n"));
#endif	/* FWOHCI_DEBUG */

	/*
	 * Make network byte order for DMA.
	 */
	for (i = 0; i < fb->fb_off; i++)
		HTONL(hdr[i]);
	bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, 0,
	    (caddr_t)cfr.ptr - fb->fb_buf, BUS_DMASYNC_PREWRITE);

	OHCI_CSR_WRITE(sc, OHCI_REG_ConfigROMmap,
	    fb->fb_dmamap->dm_segs[0].ds_addr);

	/* This register is only valid on OHCI 1.1. */
	val = OHCI_CSR_READ(sc, OHCI_REG_Version);
	if ((OHCI_Version_GET_Version(val) == 1) &&
	    (OHCI_Version_GET_Revision(val) == 1))
		OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
		    OHCI_HCControl_BIBImageValid);

	/* Just allow quad reads of the rom, from every nodes. */
	for (i = 0; i < fb->fb_off; i++)
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQUEST_QUADLET,
		    CSR_BASE_HI, CSR_BASE_LO + CSR_CONFIG_ROM + (i * 4),
		    OHCI_NodeId_NodeNumber, fwohci_configrom_input, NULL);
}

int
fwohci_configrom_input(struct fwohci_softc *sc, void *arg,
    struct fwohci_pkt *pkt)
{
	struct fwohci_pkt res;
	u_int32_t loc, *rom;

	/* This will be used as an array index so size accordingly. */
	loc = pkt->fp_hdr[2] - (CSR_BASE_LO + CSR_CONFIG_ROM);
	if ((loc & 0x03) != 0) {
		/* Alignment error. */
		return IEEE1394_RCODE_ADDRESS_ERROR;
	}
	else
		loc /= 4;
	rom = (u_int32_t *)sc->sc_buf_cnfrom.fb_buf;

	DPRINTFN(1, ("%s: ConfigRom[0x%04x]: 0x%08x\n", __func__, loc,
	    ntohl(rom[loc])));

	bzero(&res, sizeof(res));
	res.fp_hdr[3] = rom[loc];
	fwohci_atrs_output(sc, IEEE1394_RCODE_COMPLETE, pkt, &res);
	return -1;
}

/*
 * SelfID buffer (no DMA context).
 */
void
fwohci_selfid_init(struct fwohci_softc *sc)
{
	struct fwohci_buf *fb;

	//splassert(IPL_BIO);

	fb = &sc->sc_buf_selfid;
#ifdef	DIAGNOSTIC
	if ((fb->fb_dmamap->dm_segs[0].ds_addr & 0x7FF) != 0)
		panic("fwohci_selfid_init: not aligned: %ld (%ld) %p",
		    (unsigned long)fb->fb_dmamap->dm_segs[0].ds_addr,
		    (unsigned long)fb->fb_dmamap->dm_segs[0].ds_len, fb->fb_buf);
#endif
	bzero(fb->fb_buf, fb->fb_dmamap->dm_segs[0].ds_len);
	bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, 0,
	    fb->fb_dmamap->dm_segs[0].ds_len, BUS_DMASYNC_PREREAD);

	OHCI_CSR_WRITE(sc, OHCI_REG_SelfIDBuffer,
	    fb->fb_dmamap->dm_segs[0].ds_addr);
}

int
fwohci_selfid_input(struct fwohci_softc *sc)
{
	int i;
	u_int32_t count, val, gen;
	u_int32_t *buf;

	buf = (u_int32_t *)sc->sc_buf_selfid.fb_buf;
	val = OHCI_CSR_READ(sc, OHCI_REG_SelfIDCount);
  again:
	if (val & OHCI_SelfID_Error) {
		printf("%s: SelfID Error\n", sc->sc_sc1394.sc1394_dev.dv_xname);
		return (-1);
	}
	count = OHCI_BITVAL(val, OHCI_SelfID_Size);

	bus_dmamap_sync(sc->sc_dmat, sc->sc_buf_selfid.fb_dmamap,
	    0, count << 2, BUS_DMASYNC_POSTREAD);
	gen = OHCI_BITVAL(buf[0], OHCI_SelfID_Gen);

#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: SelfID: 0x%08x", sc->sc_sc1394.sc1394_dev.dv_xname,
	    val));
	for (i = 0; i < count; i++)
		DPRINTFN(2, ("%s%08x", i&7?" ":"\n    ", buf[i]));
	DPRINTFN(1, ("\n"));
#endif	/* FWOHCI_DEBUG */

	for (i = 1; i < count; i += 2) {
		if (buf[i] != ~buf[i + 1])
			break;
#if	defined(FWOHCI_DEBUG)
		if (fwohcidebug > 2)
			fwohci_show_phypkt(sc, buf[i]);
#endif	/* FWOHCI_DEBUG */
		if (buf[i] & IEEE1394_SELFID_MORE_PACKETS)
			continue;	/* More pkt. */
		if (buf[i] & IEEE1394_SELFID_EXTENDED)
			continue;	/* Extended ID. */
		sc->sc_rootid = OHCI_BITVAL(buf[i], IEEE1394_PHY_ID);
		if ((buf[i] &
		     (IEEE1394_SELFID_LINK_ACTIVE|IEEE1394_SELFID_CONTENDER))
		    == (IEEE1394_SELFID_LINK_ACTIVE|IEEE1394_SELFID_CONTENDER))
			sc->sc_irmid = sc->sc_rootid;
	}

	val = OHCI_CSR_READ(sc, OHCI_REG_SelfIDCount);
	if (OHCI_BITVAL(val, OHCI_SelfID_Gen) != gen) {
		if (OHCI_BITVAL(val, OHCI_SelfID_Gen) !=
		    OHCI_BITVAL(buf[0], OHCI_SelfID_Gen))
			goto again;
		DPRINTF(("%s: SelfID Gen mismatch (%d, %d)\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, gen,
		    OHCI_BITVAL(val, OHCI_SelfID_Gen)));
		return (-1);
	}
	if (i != count) {
		printf("%s: SelfID corrupted (%d, 0x%08x, 0x%08x)\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, i, buf[i], buf[i + 1]);
#if 1
		if (i == 1 && buf[i] == 0 && buf[i + 1] == 0) {
			/*
			 * XXX: CXD3222 sometimes fails to DMA
			 * selfid packet??
			 */
			sc->sc_rootid = (count - 1) / 2 - 1;
			sc->sc_irmid = sc->sc_rootid;
		} else
#endif
		return (-1);
	}

	val = OHCI_CSR_READ(sc, OHCI_REG_NodeId);
	if ((val & OHCI_NodeId_IDValid) == 0) {
		sc->sc_nodeid = 0xFFFF;		/* Invalid. */
		printf("%s: nodeid is invalid\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname);
		return (-1);
	}
	sc->sc_nodeid = val & 0xFFFF;

	DPRINTF(("%s: nodeid=0x%04x(%d), rootid=%d, irmid=%d\n",
	    sc->sc_sc1394.sc1394_dev.dv_xname, sc->sc_nodeid,
	    sc->sc_nodeid & OHCI_NodeId_NodeNumber, sc->sc_rootid,
	    sc->sc_irmid));

	if ((sc->sc_nodeid & OHCI_NodeId_NodeNumber) > sc->sc_rootid)
		return (-1);

	if ((sc->sc_nodeid & OHCI_NodeId_NodeNumber) == sc->sc_rootid)
		OHCI_CSR_WRITE(sc, OHCI_REG_LinkControlSet,
		    OHCI_LinkControl_CycleMaster);
	else
		OHCI_CSR_WRITE(sc, OHCI_REG_LinkControlClear,
		    OHCI_LinkControl_CycleMaster);
	return (0);
}

/*
 * Some CSRs are handled by driver.
 */
void
fwohci_csr_init(struct fwohci_softc *sc)
{
	int i;
	static u_int32_t csr[] = {
	    CSR_STATE_CLEAR, CSR_STATE_SET, CSR_SB_CYCLE_TIME,
	    CSR_SB_BUS_TIME, CSR_SB_BUSY_TIMEOUT, CSR_SB_BUS_MANAGER_ID,
	    CSR_SB_CHANNEL_AVAILABLE_HI, CSR_SB_CHANNEL_AVAILABLE_LO,
	    CSR_SB_BROADCAST_CHANNEL
	};

	//splassert(IPL_BIO);

	for (i = 0; i < sizeof(csr) / sizeof(csr[0]); i++) {
		fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQUEST_QUADLET,
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], OHCI_NodeId_NodeNumber,
		    fwohci_csr_input, NULL);
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQUEST_QUADLET,
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], OHCI_NodeId_NodeNumber,
		    fwohci_csr_input, NULL);
	}
	sc->sc_csr[CSR_SB_BROADCAST_CHANNEL] = 31;	/*XXX*/
}

int
fwohci_csr_input(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	struct fwohci_pkt res;
	u_int32_t reg;

	/*
	 * XXX Need to do special functionality other than just r/w...
	 */
	reg = pkt->fp_hdr[2] - CSR_BASE_LO;

	if ((reg & 0x03) != 0) {
		/* Alignment error. */
		return IEEE1394_RCODE_ADDRESS_ERROR;
	}
	DPRINTFN(1, ("%s: CSR[0x%04x]: 0x%08x", __func__, reg,
	    *(u_int32_t *)(&sc->sc_csr[reg])));
	if (pkt->fp_tcode == IEEE1394_TCODE_WRITE_REQUEST_QUADLET) {
		DPRINTFN(1, (" -> 0x%08x\n",
		    ntohl(*(u_int32_t *)pkt->fp_iov[0].iov_base)));
		*(u_int32_t *)&sc->sc_csr[reg] =
		    ntohl(*(u_int32_t *)pkt->fp_iov[0].iov_base);
	} else {
		DPRINTFN(1, ("\n"));
		res.fp_hdr[3] = htonl(*(u_int32_t *)&sc->sc_csr[reg]);
		res.fp_iov[0].iov_base = &res.fp_hdr[3];
		res.fp_iov[0].iov_len = 4;
		res.fp_uio.uio_resid = 4;
		res.fp_uio.uio_iovcnt = 1;
		fwohci_atrs_output(sc, IEEE1394_RCODE_COMPLETE, pkt, &res);
		return -1;
	}
	return IEEE1394_RCODE_COMPLETE;
}

/*
 * Mapping between nodeid and unique ID (EUI-64).
 *
 * Track old mappings and simply update their devices with the new id's when
 * they match an existing EUI. This allows proper renumeration of the bus.
 */
void
fwohci_uid_collect(struct fwohci_softc *sc)
{
	int i, count, val, phy_id;
	struct fwohci_uidtbl *fu;
	struct ieee1394_softc *iea;
	u_int32_t *selfid_buf;

	selfid_buf = (u_int32_t *)sc->sc_buf_selfid.fb_buf;

	LIST_FOREACH(iea, &sc->sc_nodelist, sc1394_node)
		iea->sc1394_node_id = 0xFFFF;

	if (sc->sc_uidtbl != NULL) {
		free(sc->sc_uidtbl, M_DEVBUF);
		MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
		sc->sc_uidtbl = NULL;	/* XXX */
	}
#ifdef	M_ZERO
	sc->sc_uidtbl = malloc(sizeof(*fu) * (sc->sc_rootid + 1), M_DEVBUF,
	    M_NOWAIT|M_ZERO);	/* XXX M_WAITOK requires locks. */
	MPRINTF("malloc(DEVBUF)", sc->sc_uidtbl);
#else
	sc->sc_uidtbl = malloc(sizeof(*fu) * (sc->sc_rootid + 1), M_DEVBUF,
	    M_NOWAIT);		/* XXX M_WAITOK requires locks. */
	MPRINTF("malloc(DEVBUF)", sc->sc_uidtbl);
#endif
	if (sc->sc_uidtbl == NULL) {
		DPRINTF(("sc_uidtbl malloc failed."));
		return;
	}
#ifndef	M_ZERO
	bzero(sc->sc_uidtbl, sizeof(*fu) * (sc->sc_rootid + 1));
#endif

	/* Update each node's link speed from SelfID buf. */
	count = OHCI_BITVAL(OHCI_CSR_READ(sc, OHCI_REG_SelfIDCount),
	    OHCI_SelfID_Size);
	for (i = 1; i < count; i += 2) {
		if (selfid_buf[i] & IEEE1394_SELFID_EXTENDED)
			continue;	/* No link speed info in Extended ID. */
		phy_id = OHCI_BITVAL(selfid_buf[i], IEEE1394_PHY_ID);
		if (phy_id > sc->sc_rootid)
			continue;	/* Bogus !!! */
		val = OHCI_BITVAL(selfid_buf[i], IEEE1394_SELFID_SPEED);
		sc->sc_uidtbl[phy_id].fu_link_speed = val;
	}

	for (i = 0, fu = sc->sc_uidtbl; i <= sc->sc_rootid; i++, fu++) {
		if (i == (sc->sc_nodeid & OHCI_NodeId_NodeNumber)) {
			bcopy(sc->sc_sc1394.sc1394_guid, fu->fu_uid, 8);
			fu->fu_valid = 3;

			iea = (struct ieee1394_softc *)sc->sc_sc1394.sc1394_if;
			if (iea) {
				iea->sc1394_node_id = i;
				DPRINTF(("%s: Updating nodeid to %d\n",
				    iea->sc1394_dev.dv_xname,
				    iea->sc1394_node_id));
				if (iea->sc1394_callback.cb1394_busreset) {
					iea->sc1394_callback.cb1394_busreset(
					    iea);
				}
			}
		} else {
			fu->fu_valid = 0;
			fwohci_uid_req(sc, i);
		}
	}
	if (sc->sc_rootid == 0)
		fwohci_check_nodes(sc);
}

void
fwohci_uid_req(struct fwohci_softc *sc, int phyid)
{
	struct fwohci_pkt pkt;

	bzero(&pkt, sizeof(pkt));
	pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
	pkt.fp_hlen = 12;
	pkt.fp_dlen = 0;
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
	    (pkt.fp_tcode << 4);
	pkt.fp_hdr[1] = ((0xFFC0 | phyid) << 16) | CSR_BASE_HI;
	pkt.fp_hdr[2] = CSR_BASE_LO + CSR_CONFIG_ROM + 12;
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESPONSE_QUADLET, phyid,
	    sc->sc_tlabel, OHCI_NodeId_NodeNumber, fwohci_uid_input, (void *)0);
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
	fwohci_at_output(sc, sc->sc_ctx_atrq, &pkt);

	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
	    (pkt.fp_tcode << 4);
	pkt.fp_hdr[2] = CSR_BASE_LO + CSR_CONFIG_ROM + 16;
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESPONSE_QUADLET, phyid,
	    sc->sc_tlabel, OHCI_NodeId_NodeNumber, fwohci_uid_input, (void *)1);
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
	fwohci_at_output(sc, sc->sc_ctx_atrq, &pkt);
}

int
fwohci_uid_input(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *res)
{
	struct fwohci_uidtbl *fu;
	struct ieee1394_softc *iea;
	struct ieee1394_attach_args fwa;
	int i, n, done, rcode, found;

	found = 0;

	n = (res->fp_hdr[1] >> 16) & OHCI_NodeId_NodeNumber;
	rcode = (res->fp_hdr[1] & 0x0000F000) >> 12;
	if (rcode != IEEE1394_RCODE_COMPLETE ||
	    sc->sc_uidtbl == NULL ||
	    n > sc->sc_rootid)
		return 0;
	fu = &sc->sc_uidtbl[n];
	if (arg == 0) {
		bcopy(res->fp_iov[0].iov_base, fu->fu_uid, 4);
		fu->fu_valid |= 0x1;
	} else {
		bcopy(res->fp_iov[0].iov_base, fu->fu_uid + 4, 4);
		fu->fu_valid |= 0x2;
	}
	if (fu->fu_valid == 0x3) {
		DPRINTFN(1, ("%s: Node %d, UID %02x:%02x:%02x:%02x:%02x:%02x:"
		    "%02x:%02x\n", __func__, n,
		    fu->fu_uid[0], fu->fu_uid[1], fu->fu_uid[2], fu->fu_uid[3],
		    fu->fu_uid[4], fu->fu_uid[5], fu->fu_uid[6], fu->fu_uid[7]));
		LIST_FOREACH(iea, &sc->sc_nodelist, sc1394_node) {
			if (memcmp(iea->sc1394_guid, fu->fu_uid, 8) == 0) {
				found = 1;
				iea->sc1394_node_id = n;
				iea->sc1394_link_speed = fu->fu_link_speed;
				DPRINTF(("%s: Updating nodeid to %d, speed %d\n",
				    iea->sc1394_dev.dv_xname,
				    iea->sc1394_node_id,
				    fu->fu_link_speed));
				if (iea->sc1394_callback.cb1394_busreset) {
					iea->sc1394_callback.cb1394_busreset(
					    iea);
				}
				break;
			}
		}
		if (!found) {
			strlcpy(fwa.name, "fwnode", sizeof fwa.name);
			fwa.link_speed = fu->fu_link_speed;
			bcopy(fu->fu_uid, fwa.uid, 8);
			fwa.nodeid = n;
			fwa.read = fwohci_read;
			fwa.write = fwohci_write;
			fwa.inreg = fwohci_inreg;
			fwa.unreg = fwohci_unreg;
			iea = (struct ieee1394_softc *)
			    config_found_sm(&sc->sc_sc1394.sc1394_dev, &fwa,
			    fwohci_print, fwohci_submatch);
			if (iea != NULL) {
				DPRINTF(("%s: Update speed to %d.",
				    iea->sc1394_dev.dv_xname,
				    fu->fu_link_speed));
				iea->sc1394_link_speed = fu->fu_link_speed;
				LIST_INSERT_HEAD(&sc->sc_nodelist, iea,
				    sc1394_node);
			}
		}
	}
	done = 1;

	for (i = 0; i <= sc->sc_rootid; i++) {
		fu = &sc->sc_uidtbl[i];
		if (fu->fu_valid != 0x3) {
			done = 0;
			break;
		}
	}
	if (done)
		fwohci_check_nodes(sc);

	return 0;
}

void
fwohci_check_nodes(struct fwohci_softc *sc)
{
	struct device *detach = NULL;
	struct ieee1394_softc *iea;

	LIST_FOREACH(iea, &sc->sc_nodelist, sc1394_node) {

		/*
		 * Have to defer detachment until the next
		 * loop iteration since config_detach
		 * free's the softc and the loop iterator
		 * needs data from the softc to move
		 * forward.
		 */

		if (detach) {
//			config_detach_children(detach, 0);
			config_detach(detach, 0);
			detach = NULL;
		}
		if (iea->sc1394_node_id == 0xFFFF) {
			detach = (struct device *)iea;
			LIST_REMOVE(iea, sc1394_node);
		}
	}
	if (detach)  {
//		config_detach_children(detach, 0);
		config_detach(detach, 0);
	}
}

int
fwohci_uid_lookup(struct fwohci_softc *sc, const u_int8_t *uid)
{
	struct fwohci_uidtbl *fu;
	int n;
	static const u_int8_t bcast[] =
	    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

	fu = sc->sc_uidtbl;
	if (fu == NULL) {
		if (memcmp(uid, bcast, sizeof(bcast)) == 0)
			return IEEE1394_BCAST_PHY_ID;
		fwohci_uid_collect(sc); /* Try to get. */
		return -1;
	}
	for (n = 0; n <= sc->sc_rootid; n++, fu++) {
		if (fu->fu_valid == 0x3 && memcmp(fu->fu_uid, uid, 8) == 0)
			return n;
	}
	if (memcmp(uid, bcast, sizeof(bcast)) == 0)
		return IEEE1394_BCAST_PHY_ID;
	for (n = 0, fu = sc->sc_uidtbl; n <= sc->sc_rootid; n++, fu++) {
		if (fu->fu_valid != 0x3) {
			/*
			 * XXX: Need timer before retransmission.
			 */
			fwohci_uid_req(sc, n);
		}
	}
	return -1;
}

/*
 * Functions to support network interface.
 */
int
fwohci_if_inreg(struct device *self, u_int32_t offhi, u_int32_t offlo,
    void (*handler)(struct device *, struct mbuf *))
{
	struct fwohci_softc *sc = (struct fwohci_softc *)self;

	fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK,
	    offhi, offlo, OHCI_NodeId_NodeNumber,
	    handler ? fwohci_if_input : NULL, handler);
	fwohci_handler_set(sc, IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK,
	    (sc->sc_csr[CSR_SB_BROADCAST_CHANNEL] & IEEE1394_ISOCH_MASK) |
	    OHCI_ASYNC_STREAM, IEEE1394_TAG_GASP, 0,
	    handler ? fwohci_if_input : NULL, handler);
	return 0;
}

int
fwohci_if_input(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	int n, len;
	struct mbuf *m;
	struct iovec *iov;
	void (*handler)(struct device *, struct mbuf *) = arg;

#ifdef	FWOHCI_DEBUG
	int i;
	DPRINTFN(1, ("tcode=0x%x, dlen=%d\n", pkt->fp_tcode, pkt->fp_dlen));
	for (i = 0; fwohcidebug > 5 && i < pkt->fp_hlen/4; i++)
		DPRINTFN(5, ("%s %08x", i?"":"   ", pkt->fp_hdr[i]));
	DPRINTFN(5, (" $\n"));
	if (pkt->fp_dlen) {
		for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
			iov = &pkt->fp_iov[n];
			for (i = 0; fwohcidebug > 5 && i < iov->iov_len; i++)
				DPRINTFN(5, ("%s%02x",
				    i&31?i&3?"":" ":i?"\n    ":"    ",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(5, (" $\n"));
		}
	}
#endif	/* FWOHCI_DEBUG */
	len = pkt->fp_dlen;
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return IEEE1394_RCODE_COMPLETE;
	m->m_len = 16;
	if (len + m->m_len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			MPRINTF("m_freem", m);
			return IEEE1394_RCODE_COMPLETE;
		}
	}
	n = (pkt->fp_hdr[1] >> 16) & OHCI_NodeId_NodeNumber;
	if (sc->sc_uidtbl == NULL || n > sc->sc_rootid ||
	    sc->sc_uidtbl[n].fu_valid != 0x3) {
		printf("%s: packet from unknown node: phy id %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, n);
		m_freem(m);
		MPRINTF("m_freem", m);
		fwohci_uid_req(sc, n);
		return IEEE1394_RCODE_COMPLETE;
	}
	bcopy(sc->sc_uidtbl[n].fu_uid, mtod(m, caddr_t), 8);
	if (pkt->fp_tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		m->m_flags |= M_BCAST;
		mtod(m, u_int32_t *)[2] = mtod(m, u_int32_t *)[3] = 0;
	} else {
		mtod(m, u_int32_t *)[2] = htonl(pkt->fp_hdr[1]);
		mtod(m, u_int32_t *)[3] = htonl(pkt->fp_hdr[2]);
	}
	mtod(m, u_int8_t *)[8] = n;	/*XXX: Node id for debug. */
	mtod(m, u_int8_t *)[9] = OHCI_BITVAL(*pkt->fp_trail, OHCI_CTXCTL_SPD);

	m->m_pkthdr.rcvif = NULL;	/* set in child */
	m->m_pkthdr.len = len + m->m_len;
	/*
	 * We may use receive buffer by external mbuf instead of copy here.
	 * But asynchronous receive buffer must be operate in buffer fill
	 * mode, so that each receive buffer will shared by multiple mbufs.
	 * If upper layer doesn't free mbuf soon, e.g. application program
	 * is suspended, buffer must be reallocated.
	 * Isochronous buffer must be operate in packet buffer mode, and
	 * it is easy to map receive buffer to external mbuf. But it is
	 * used for broadcast/multicast only, and is expected not so
	 * performance sensitive for now.
	 * XXX: The performance may be important for multicast case,
	 * so we should revisit here later.
	 *						-- onoe
	 */
	n = 0;
	iov = pkt->fp_uio.uio_iov;
	while (len > 0) {
		bcopy(iov->iov_base, mtod(m, caddr_t) + m->m_len,
		    iov->iov_len);
		m->m_len += iov->iov_len;
		len -= iov->iov_len;
		iov++;
	}
	(*handler)(sc->sc_sc1394.sc1394_if, m);
	return IEEE1394_RCODE_COMPLETE;
}

int
fwohci_if_input_iso(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	int n, len;
	int chan, tag;
	struct mbuf *m;
	struct iovec *iov;
	void (*handler)(struct device *, struct mbuf *) = arg;
#if	defined(FWOHCI_DEBUG)
	int i;
#endif	/* FWOHCI_DEBUG */

	chan = (pkt->fp_hdr[0] & 0x00003F00) >> 8;
	tag  = (pkt->fp_hdr[0] & 0x0000C000) >> 14;
#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: tcode=0x%x, chan=%d, tag=%x, dlen=%d", __func__,
	    pkt->fp_tcode, chan, tag, pkt->fp_dlen));
	for (i = 0; i < pkt->fp_hlen/4; i++)
		DPRINTFN(2, ("%s%08x", i?" ":"\n\t", pkt->fp_hdr[i]));
	DPRINTFN(2, ("$"));
	if (pkt->fp_dlen) {
		for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
			iov = &pkt->fp_iov[n];
			for (i = 0; i < iov->iov_len; i++)
				DPRINTFN(2, ("%s%02x",
				    (i%32)?((i%4)?"":" "):"\n\t",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(2, ("$"));
		}
	}
	DPRINTFN(2, ("\n"));
#endif	/* FWOHCI_DEBUG */
	len = pkt->fp_dlen;
	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return IEEE1394_RCODE_COMPLETE;
	m->m_len = 16;
	if (m->m_len + len > MHLEN) {
		MCLGET(m, M_DONTWAIT);
		if ((m->m_flags & M_EXT) == 0) {
			m_freem(m);
			MPRINTF("m_freem", m);
			return IEEE1394_RCODE_COMPLETE;
		}
	}

	m->m_flags |= M_BCAST;

	if (tag == IEEE1394_TAG_GASP) {
		n = (pkt->fp_hdr[1] >> 16) & OHCI_NodeId_NodeNumber;
		if (sc->sc_uidtbl == NULL || n > sc->sc_rootid ||
		    sc->sc_uidtbl[n].fu_valid != 0x3) {
			printf("%s: packet from unknown node: phy id %d\n",
			    sc->sc_sc1394.sc1394_dev.dv_xname, n);
			m_freem(m);
			MPRINTF("m_freem", m);
			return IEEE1394_RCODE_COMPLETE;
		}
		bcopy(sc->sc_uidtbl[n].fu_uid, mtod(m, caddr_t), 8);
		mtod(m, u_int32_t *)[2] = htonl(pkt->fp_hdr[1]);
		mtod(m, u_int32_t *)[3] = htonl(pkt->fp_hdr[2]);
		mtod(m, u_int8_t *)[8] = n;	/*XXX: node id for debug */
		mtod(m, u_int8_t *)[9] =
		    OHCI_BITVAL(*pkt->fp_trail, OHCI_CTXCTL_SPD);
	}
	mtod(m, u_int8_t *)[14] = chan;
	mtod(m, u_int8_t *)[15] = tag;


	m->m_pkthdr.rcvif = NULL;	/* set in child */
	m->m_pkthdr.len = len + m->m_len;
	/*
	 * We may use receive buffer by external mbuf instead of copy here.
	 * But asynchronous receive buffer must be operate in buffer fill
	 * mode, so that each receive buffer will shared by multiple mbufs.
	 * If upper layer doesn't free mbuf soon, e.g. application program
	 * is suspended, buffer must be reallocated.
	 * Isochronous buffer must be operate in packet buffer mode, and
	 * it is easy to map receive buffer to external mbuf. But it is
	 * used for broadcast/multicast only, and is expected not so
	 * performance sensitive for now.
	 * XXX: The performance may be important for multicast case,
	 * so we should revisit here later.
	 *						-- onoe
	 */
	n = 0;
	iov = pkt->fp_uio.uio_iov;
	while (len > 0) {
		bcopy(iov->iov_base, mtod(m, caddr_t) + m->m_len,
		    iov->iov_len);
		m->m_len += iov->iov_len;
		len -= iov->iov_len;
		iov++;
	}
	(*handler)(sc->sc_sc1394.sc1394_if, m);
	return IEEE1394_RCODE_COMPLETE;
}



int
fwohci_if_output(struct device *self, struct mbuf *m0,
    void (*callback)(struct device *, struct mbuf *))
{
	struct fwohci_softc *sc = (struct fwohci_softc *)self;
	struct fwohci_pkt pkt;
	u_int8_t *p;
	int n, error, spd, hdrlen, maxrec;
#ifdef	FWOHCI_DEBUG
	struct mbuf *m;
#endif	/* FWOHCI_DEBUG */

	p = mtod(m0, u_int8_t *);
	if (m0->m_flags & (M_BCAST | M_MCAST)) {
		spd = IEEE1394_SPD_S100;	/*XXX*/
		maxrec = 512;			/*XXX*/
		hdrlen = 8;
	} else {
		n = fwohci_uid_lookup(sc, p);
		if (n < 0) {
			printf("%s: nodeid unknown:"
			    " %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
			    sc->sc_sc1394.sc1394_dev.dv_xname,
			    p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
			error = EHOSTUNREACH;
			goto end;
		}
		if (n == IEEE1394_BCAST_PHY_ID) {
			printf("%s: broadcast with !M_MCAST\n",
			    sc->sc_sc1394.sc1394_dev.dv_xname);
#ifdef	FWOHCI_DEBUG
			DPRINTFN(2, ("packet:"));
			for (m = m0; m != NULL; m = m->m_next) {
				for (n = 0; n < m->m_len; n++)
					DPRINTFN(2, ("%s%02x", (n%32)?
					    ((n%4)?"":" "):"\n    ",
					    mtod(m, u_int8_t *)[n]));
				DPRINTFN(2, ("$"));
			}
			DPRINTFN(2, ("\n"));
#endif	/* FWOHCI_DEBUG */
			error = EHOSTUNREACH;
			goto end;
		}
		maxrec = 2 << p[8];
		spd = p[9];
		hdrlen = 0;
	}
	if (spd > sc->sc_sc1394.sc1394_link_speed) {
		DPRINTF(("%s: spd (%d) is faster than %d\n", __func__,
		    spd, sc->sc_sc1394.sc1394_link_speed));
		spd = sc->sc_sc1394.sc1394_link_speed;
	}
	if (maxrec > (512 << spd)) {
		DPRINTF(("%s: maxrec (%d) is larger for spd (%d)\n", __func__,
		    maxrec, spd));
		maxrec = 512 << spd;
	}
	while (maxrec > sc->sc_sc1394.sc1394_max_receive) {
		DPRINTF(("%s: maxrec (%d) is larger than %d\n", __func__,
		    maxrec, sc->sc_sc1394.sc1394_max_receive));
		maxrec >>= 1;
	}
	if (maxrec < 512) {
		DPRINTF(("%s: maxrec (%d) is smaller than minimum\n",
		    __func__, maxrec));
		maxrec = 512;
	}

	m_adj(m0, 16 - hdrlen);
	if (m0->m_pkthdr.len > maxrec) {
		DPRINTF(("%s: packet too big: hdr %d, pktlen %d, maxrec %d\n",
		    __func__, hdrlen, m0->m_pkthdr.len, maxrec));
		error = E2BIG;	/*XXX*/
		goto end;
	}

	bzero(&pkt, sizeof(pkt));
	pkt.fp_uio.uio_iov = pkt.fp_iov;
	pkt.fp_uio.uio_segflg = UIO_SYSSPACE;
	pkt.fp_uio.uio_rw = UIO_WRITE;
	if (m0->m_flags & (M_BCAST | M_MCAST)) {
		/* Construct GASP header. */
		p = mtod(m0, u_int8_t *);
		p[0] = sc->sc_nodeid >> 8;
		p[1] = sc->sc_nodeid & 0xFF;
		p[2] = 0x00; p[3] = 0x00; p[4] = 0x5E;
		p[5] = 0x00; p[6] = 0x00; p[7] = 0x01;
		pkt.fp_tcode = IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK;
		pkt.fp_hlen = 8;
		pkt.fp_hdr[0] = (spd << 16) | (IEEE1394_TAG_GASP << 14) |
		    ((sc->sc_csr[CSR_SB_BROADCAST_CHANNEL] &
		    OHCI_NodeId_NodeNumber) << 8);
		pkt.fp_hdr[1] = m0->m_pkthdr.len << 16;
	} else {
		pkt.fp_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
		pkt.fp_hlen = 16;
		pkt.fp_hdr[0] = 0x00800100 | (sc->sc_tlabel << 10) |
		    (spd << 16);
		pkt.fp_hdr[1] =
		    (((sc->sc_nodeid & OHCI_NodeId_BusNumber) | n) << 16) |
		    (p[10] << 8) | p[11];
		pkt.fp_hdr[2] = (p[12]<<24) | (p[13]<<16) | (p[14]<<8) | p[15];
		pkt.fp_hdr[3] = m0->m_pkthdr.len << 16;
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
	}
	pkt.fp_hdr[0] |= (pkt.fp_tcode << 4);
	pkt.fp_dlen = m0->m_pkthdr.len;
	pkt.fp_m = m0;
	pkt.fp_callback = callback;
	error = fwohci_at_output(sc, sc->sc_ctx_atrq, &pkt);
	m0 = pkt.fp_m;
  end:
	if (m0 != NULL) {
		if (callback) {
			(*callback)(sc->sc_sc1394.sc1394_if, m0);
		} else {
			m_freem(m0);
			MPRINTF("m_freem", m0);
		}
	}
	return error;
}

/*
 * High level routines to provide abstraction to attaching layers to
 * send/receive data.
 */

/*
 * These break down into 4 routines as follows:
 *
 * int fwohci_read(struct ieee1394_abuf *)
 *
 * This routine will attempt to read a region from the requested node.
 * A callback must be provided which will be called when either the completed
 * read is done or an unrecoverable error occurs. This is mainly a convenience
 * routine since it will encapsulate retrying a region as quadlet vs. block
 * reads and recombining all the returned data. This could also be done with a
 * series of write/inreg's for each packet sent.
 *
 * int fwohci_write(struct ieee1394_abuf *)
 *
 * The work horse main entry point for putting packets on the bus. This is the
 * generalized interface for fwnode/etc code to put packets out onto the bus.
 * It accepts all standard ieee1394 tcodes (XXX: only a few today) and
 * optionally will callback via a func pointer to the calling code with the
 * resulting ACK code from the packet. If the ACK code is to be ignored (i.e.
 * no cb) then the write routine will take care of free'ing the abuf since the
 * fwnode/etc code won't have any knowledge of when to do this. This allows for
 * simple one-off packets to be sent from the upper-level code without worrying
 * about a callback for cleanup.
 *
 * int fwohci_inreg(struct ieee1394_abuf *, int)
 *
 * This is very simple. It evals the abuf passed in and registers an internal
 * handler as the callback for packets received for that operation.
 * The integer argument specifies whether on a block read/write operation to
 * allow sub-regions to be read/written (in block form) as well.
 *
 * XXX: This whole structure needs to be redone as a list of regions and
 * operations allowed on those regions.
 *
 * int fwohci_unreg(struct ieee1394_abuf *, int)
 *
 * This simply unregisters the respective callback done via inreg for items
 * that only need to register an area for a one-time operation (like a status
 * buffer a remote node will write to when the current operation is done). The
 * int argument specifies the same behavior as inreg, except in reverse (i.e.
 * it unregisters).
 */

int
fwohci_read(struct ieee1394_abuf *ab)
{
	struct fwohci_pkt pkt;
	struct ieee1394_softc *sc = ab->ab_req;
	struct fwohci_softc *psc =
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent;
	struct fwohci_cb *fcb;
	u_int32_t high, lo;
	int rv, tcode;

	/* Have to have a callback when reading. */
	if (ab->ab_cb == NULL)
		return -1;

	MALLOC(fcb, struct fwohci_cb *, sizeof(*fcb), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", fcb);
	fcb->ab = ab;
	fcb->count = 0;
	fcb->abuf_valid = 1;

	high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000FFFFFFFF);

	bzero(&pkt, sizeof(pkt));
	pkt.fp_hdr[1] = ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
	pkt.fp_hdr[2] = lo;
	pkt.fp_dlen = 0;

	if (ab->ab_length == 4) {
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
		tcode = IEEE1394_TCODE_READ_RESPONSE_QUADLET;
		pkt.fp_hlen = 12;
	} else {
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_DATABLOCK;
		pkt.fp_hlen = 16;
		tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
		pkt.fp_hdr[3] = (ab->ab_length << 16);
	}
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc1394_link_speed << 16) |
	    (psc->sc_tlabel << 10) | (pkt.fp_tcode << 4);

	pkt.fp_statusarg = fcb;
	pkt.fp_statuscb = fwohci_read_resp;

	rv = fwohci_handler_set(psc, tcode, ab->ab_req->sc1394_node_id,
	    psc->sc_tlabel, 0, fwohci_read_resp, fcb);
	if (rv)
		return rv;
	rv = fwohci_at_output(psc, psc->sc_ctx_atrq, &pkt);
	if (rv)
		fwohci_handler_set(psc, tcode, ab->ab_req->sc1394_node_id,
		    psc->sc_tlabel, 0, NULL, NULL);
	psc->sc_tlabel = (psc->sc_tlabel + 1) & 0x3F;
	fcb->count = 1;
	return rv;
}

int
fwohci_write(struct ieee1394_abuf *ab)
{
	struct fwohci_pkt pkt;
	struct ieee1394_softc *sc = ab->ab_req;
	struct fwohci_softc *psc =
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent;
	u_int32_t high, lo;
	int rv;

	if ((ab->ab_tcode == IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK &&
	     ab->ab_length > IEEE1394_MAX_REC(sc->sc1394_max_receive)) ||
	    ab->ab_length > IEEE1394_MAX_ASYNC(sc->sc1394_link_speed)) {
		DPRINTF(("%s: Packet too large: %d\n", __func__,
		    ab->ab_length));
		return E2BIG;
	}

	if (ab->ab_data && ab->ab_uio) 
		panic("Can't call with uio and data set");
	if ((ab->ab_data == NULL) && (ab->ab_uio == NULL))
		panic("One of either ab_data or ab_uio must be set");

	bzero(&pkt, sizeof(pkt));

	pkt.fp_tcode = ab->ab_tcode;
	if (ab->ab_data) {
		pkt.fp_uio.uio_iov = pkt.fp_iov;
		pkt.fp_uio.uio_segflg = UIO_SYSSPACE;
		pkt.fp_uio.uio_rw = UIO_WRITE;
	} else
		bcopy(ab->ab_uio, &pkt.fp_uio, sizeof(struct uio));

	pkt.fp_statusarg = ab;
	pkt.fp_statuscb = fwohci_write_ack;

	switch (ab->ab_tcode) {
	case IEEE1394_TCODE_WRITE_RESPONSE:
		pkt.fp_hlen = 12;
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
		if (!pkt.fp_hlen)
			pkt.fp_hlen = 16;
		high = ab->ab_retlen;
		ab->ab_retlen = 0;
		lo = 0;
		pkt.fp_hdr[0] = 0x00000100 | (sc->sc1394_link_speed << 16) |
		    (ab->ab_tlabel << 10) | (pkt.fp_tcode << 4);
		break;
	default:
		pkt.fp_hlen = 16;
		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF);
		pkt.fp_hdr[0] = 0x00000100 | (sc->sc1394_link_speed << 16) |
		    (psc->sc_tlabel << 10) | (pkt.fp_tcode << 4);
		break;
	}

	pkt.fp_hdr[1] = ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
	pkt.fp_hdr[2] = lo;
	if (pkt.fp_hlen == 16) {
		if (ab->ab_length == 4) {
			pkt.fp_hdr[3] = ab->ab_data[0];
			pkt.fp_dlen = 0;
		}  else {
			pkt.fp_hdr[3] = (ab->ab_length << 16);
			pkt.fp_dlen = ab->ab_length;
			if (ab->ab_data) {
				pkt.fp_uio.uio_iovcnt = 1;
				pkt.fp_uio.uio_resid = ab->ab_length;
				pkt.fp_iov[0].iov_base = ab->ab_data;
				pkt.fp_iov[0].iov_len = ab->ab_length;
			}
		}
	}
	switch (ab->ab_tcode) {
	case IEEE1394_TCODE_WRITE_RESPONSE:
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
		rv = fwohci_at_output(psc, psc->sc_ctx_atrs, &pkt);
		break;
	default:
		rv = fwohci_at_output(psc, psc->sc_ctx_atrq, &pkt);
		break;
	}
	return rv;
}

int
fwohci_read_resp(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	struct fwohci_cb *fcb = arg;
	struct ieee1394_abuf *ab = fcb->ab;
	struct fwohci_pkt newpkt;
	u_int32_t *cur, high, lo;
	int i, tcode, rcode, status, rv;

	/*
	 * Both the ACK handling and normal response callbacks are handled here.
	 * The main reason for this is the various error conditions that can
	 * occur trying to block read some areas and the ways that gets reported
	 * back to calling station. This is a variety of ACK codes, responses,
	 * etc which makes it much more difficult to process if both aren't
	 * handled here.
	 */

	/* Check for status packet. */

	if (pkt->fp_tcode == -1) {
		status = pkt->fp_status & OHCI_DESC_STATUS_ACK_MASK;
		rcode = -1;
		tcode = (pkt->fp_hdr[0] >> 4) & 0xF;
		if ((status != OHCI_CTXCTL_EVENT_ACK_COMPLETE) &&
		    (status != OHCI_CTXCTL_EVENT_ACK_PENDING))
			DPRINTFN(2, ("%s: Got status packet: 0x%02x\n",
			    __func__, (unsigned int)status));
		fcb->count--;

		/*
		 * Got all the ack's back and the buffer is invalid (i.e. the
		 * callback has been called). Clean up.
		 */

		if (fcb->abuf_valid == 0) {
			if (fcb->count == 0) {
				FREE(fcb, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", fcb);
				fcb = NULL;	/* XXX */
			}
			return IEEE1394_RCODE_COMPLETE;
		}
	} else {
		status = -1;
		tcode = pkt->fp_tcode;
		rcode = (pkt->fp_hdr[1] & 0x0000F000) >> 12;
	}

	/*
	 * Some areas (like the config rom) want to be read as quadlets only.
	 *
	 * The current ideas to try are:
	 *
	 * Got an ACK_TYPE_ERROR on a block read.
	 *
	 * Got either RCODE_TYPE or RCODE_ADDRESS errors in a block read
	 * response.
	 *
	 * In all cases construct a new packet for a quadlet read and let
	 * multi_resp handle the iteration over the space.
	 */

	if (((status == OHCI_CTXCTL_EVENT_ACK_TYPE_ERROR) &&
	     (tcode == IEEE1394_TCODE_READ_REQUEST_DATABLOCK)) ||
	    (((rcode == IEEE1394_RCODE_TYPE_ERROR) ||
	      (rcode == IEEE1394_RCODE_ADDRESS_ERROR)) &&
	     (tcode == IEEE1394_TCODE_READ_RESPONSE_DATABLOCK))) {

		/* Read the area in quadlet chunks (internally track this). */

		bzero(&newpkt, sizeof(newpkt));

		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF);

		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
		newpkt.fp_hlen = 12;
		newpkt.fp_dlen = 0;
		newpkt.fp_hdr[1] =
		    ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
		newpkt.fp_hdr[2] = lo;
		newpkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
		    (newpkt.fp_tcode << 4);

		rv = fwohci_handler_set(sc,
		    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
		    fwohci_read_multi_resp, fcb);
		if (rv) {
			(*ab->ab_cb)(ab, -1);
			goto cleanup;
		}
		newpkt.fp_statusarg = fcb;
		newpkt.fp_statuscb = fwohci_read_resp;
		rv = fwohci_at_output(sc, sc->sc_ctx_atrq, &newpkt);
		if (rv) {
			fwohci_handler_set(sc,
			    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
			    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
			    NULL, NULL);
			(*ab->ab_cb)(ab, -1);
			goto cleanup;
		}
		fcb->count++;
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
		return IEEE1394_RCODE_COMPLETE;
	} else if ((rcode != -1) || ((status != -1) &&
	    (status != OHCI_CTXCTL_EVENT_ACK_COMPLETE) &&
	    (status != OHCI_CTXCTL_EVENT_ACK_PENDING))) {

		/*
		 * Recombine all the iov data into 1 chunk for higher
		 * level code.
		 */

		if (rcode != -1) {
			cur = ab->ab_data;

			assert(pkt->fp_uio.uio_iovcnt > 0);

			for (i = 0; i < pkt->fp_uio.uio_iovcnt; i++) {
				/*
				 * Make sure and don't exceed the buffer
				 * allocated for return.
				 */
				if ((ab->ab_retlen + pkt->fp_iov[i].iov_len) >
				    ab->ab_length) {
					bcopy(pkt->fp_iov[i].iov_base, cur,
					    (ab->ab_length - ab->ab_retlen));
					ab->ab_retlen = ab->ab_length;
					break;
				}
				bcopy(pkt->fp_iov[i].iov_base, cur,
				    pkt->fp_iov[i].iov_len);
				(caddr_t)cur += pkt->fp_iov[i].iov_len;
				ab->ab_retlen += pkt->fp_iov[i].iov_len;
			}
			DPRINTF(("%s: retlen=%d\n", __func__, ab->ab_retlen));
		}
		if (status != -1)
			/* XXX: Need a complete tlabel interface. */
			for (i = 0; i < 64; i++)
				fwohci_handler_set(sc,
				    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
				    ab->ab_req->sc1394_node_id, i, 0,
				    NULL, NULL);
		(*ab->ab_cb)(ab, rcode);
		goto cleanup;
	} else
		/* Good ack packet. */
		return IEEE1394_RCODE_COMPLETE;

	/* Can't get here unless ab->ab_cb has been called. */

 cleanup:
	fcb->abuf_valid = 0;
	if (fcb->count == 0) {
		FREE(fcb, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", fcb);
		fcb = NULL;
	}
	return IEEE1394_RCODE_COMPLETE;
}

int
fwohci_read_multi_resp(struct fwohci_softc *sc, void *arg,
    struct fwohci_pkt *pkt)
{
	struct fwohci_cb *fcb = arg;
	struct ieee1394_abuf *ab = fcb->ab;
	struct fwohci_pkt newpkt;
	u_int32_t high, lo;
	int rcode, rv;

	/*
	 * Bad return codes from the wire, just return what's already in the
	 * buf.
	 */

	/* Make sure a response packet didn't arrive after a bad ACK. */
	if (fcb->abuf_valid == 0)
		return IEEE1394_RCODE_COMPLETE;

	rcode = (pkt->fp_hdr[1] & 0x0000F000) >> 12;

	if (rcode) {
		(*ab->ab_cb)(ab, rcode);
		goto cleanup;
	}

	if ((ab->ab_retlen + pkt->fp_iov[0].iov_len) > ab->ab_length) {
		bcopy(pkt->fp_iov[0].iov_base,
		    ((char *)ab->ab_data + ab->ab_retlen),
		    (ab->ab_length - ab->ab_retlen));
		ab->ab_retlen = ab->ab_length;
	} else {
		bcopy(pkt->fp_iov[0].iov_base,
		    ((char *)ab->ab_data + ab->ab_retlen), 4);
		ab->ab_retlen += 4;
	}
	DPRINTF(("%s: retlen=%d\n", __func__, ab->ab_retlen));
	/* Still more, loop and read 4 more bytes. */
	if (ab->ab_retlen < ab->ab_length) {
		bzero(&newpkt, sizeof(newpkt));

		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF) + ab->ab_retlen;

		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
		newpkt.fp_hlen = 12;
		newpkt.fp_dlen = 0;
		newpkt.fp_hdr[1] =
		    ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
		newpkt.fp_hdr[2] = lo;
		newpkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
		    (newpkt.fp_tcode << 4);

		newpkt.fp_statusarg = fcb;
		newpkt.fp_statuscb = fwohci_read_resp;

		/*
		 * Bad return code. Just give up and return what's
		 * come in now.
		 */
		rv = fwohci_handler_set(sc,
		    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
		    fwohci_read_multi_resp, fcb);
		if (rv)
			(*ab->ab_cb)(ab, -1);
		else {
			rv = fwohci_at_output(sc, sc->sc_ctx_atrq, &newpkt);
			if (rv) {
				fwohci_handler_set(sc,
				    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
				    ab->ab_req->sc1394_node_id, sc->sc_tlabel,
				    0, NULL, NULL);
				(*ab->ab_cb)(ab, -1);
			} else {
				sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
				fcb->count++;
				return IEEE1394_RCODE_COMPLETE;
			}
		}
	} else
		(*ab->ab_cb)(ab, IEEE1394_RCODE_COMPLETE);

 cleanup:
	/* Can't get here unless ab_cb has been called. */
	fcb->abuf_valid = 0;
	if (fcb->count == 0) {
		FREE(fcb, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", fcb);
		fcb = NULL;
	}
	return IEEE1394_RCODE_COMPLETE;
}

int
fwohci_write_ack(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	struct ieee1394_abuf *ab = arg;
	u_int16_t status;


	status = pkt->fp_status & OHCI_DESC_STATUS_ACK_MASK;
	if ((status != OHCI_CTXCTL_EVENT_ACK_COMPLETE) &&
	    (status != OHCI_CTXCTL_EVENT_ACK_PENDING))
		DPRINTF(("%s: Got status packet: 0x%02x\n", __func__,
		    (unsigned int)status));

	/* No callback means this level should free the buffers. */
	if (ab->ab_cb)
		(*ab->ab_cb)(ab, status);
	else {
		if (ab->ab_data) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
	}
	return IEEE1394_RCODE_COMPLETE;
}

int
fwohci_inreg(struct ieee1394_abuf *ab, int allow)
{
	struct ieee1394_softc *sc = ab->ab_req;
	struct fwohci_softc *psc =
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent;
	u_int32_t high, lo;
	int rv;

	high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000FFFFFFFF);

	rv = 0;
	switch (ab->ab_tcode) {
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
		if (ab->ab_cb)
			rv = fwohci_handler_set(psc, ab->ab_tcode, high, lo,
			    sc->sc1394_node_id, fwohci_parse_input, ab);
		else
			fwohci_handler_set(psc, ab->ab_tcode, high, lo,
			    sc->sc1394_node_id, NULL, NULL);
		break;
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		if (allow) {
			if (ab->ab_cb)
				rv = fwohci_block_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id, ab->ab_length,
				    fwohci_parse_input, ab);
			else
				fwohci_block_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id, ab->ab_length,
				    NULL, NULL);
			/*
			 * XXX: Need something to indicate writing a smaller
			 * amount is ok.
			 */
			if (ab->ab_cb)
				ab->ab_data = (void *)1;
		} else {
			if (ab->ab_cb)
				rv = fwohci_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id,
				    fwohci_parse_input, ab);
			else
				fwohci_handler_set(psc, ab->ab_tcode, high, lo,
				    sc->sc1394_node_id, NULL, NULL);
		}
		break;
	default:
		DPRINTF(("%s: Invalid registration tcode: %d\n", __func__,
		    ab->ab_tcode));
		return -1;
		break;
	}
	return rv;
}

int
fwohci_unreg(struct ieee1394_abuf *ab, int allow)
{
	void *save;
	int rv;

	save = ab->ab_cb;
	ab->ab_cb = NULL;
	rv = fwohci_inreg(ab, allow);
	ab->ab_cb = save;
	return rv;
}

int
fwohci_parse_input(struct fwohci_softc *sc, void *arg, struct fwohci_pkt *pkt)
{
	struct ieee1394_abuf *ab = (struct ieee1394_abuf *)arg;
	u_int64_t addr;
	u_int32_t *cur;
	int i, count;

	ab->ab_tcode = (pkt->fp_hdr[0] >> 4) & 0xF;
	ab->ab_tlabel = (pkt->fp_hdr[0] >> 10) & 0x3F;
	addr = (((u_int64_t)(pkt->fp_hdr[1] & 0xFFFF) << 32) | pkt->fp_hdr[2]);

	DPRINTFN(3, ("%s: ab=0x%08x ab_cb=0x%08x\n\ttcode=%d tlabel=0x%02x"
	    " addr=%04x%08x\n", __func__, (u_int32_t)ab, (u_int32_t)ab->ab_cb,
	    ab->ab_tcode, ab->ab_tlabel, pkt->fp_hdr[1] & 0xffff,
	    pkt->fp_hdr[2]));

	switch (ab->ab_tcode) {
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
		ab->ab_retlen = 4;
		break;
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
		ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
		if ((ab->ab_retlen > ab->ab_length) ||
		    ((addr + ab->ab_retlen) > (ab->ab_addr + ab->ab_length)))
			return IEEE1394_RCODE_ADDRESS_ERROR;

		if ((caddr_t)ab->ab_data > (caddr_t)1) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;
		}
		break;
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
		ab->ab_retlen = 4;
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		if (!ab->ab_retlen)
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
		else {
#ifdef	FWOHCI_DEBUG
			if (ab->ab_retlen != ((pkt->fp_hdr[3] >> 16) & 0xFFFF))
				DPRINTF(("%s: retlen(%d) <> pktlen(%d)\n",
				    __func__, ab->ab_retlen,
				    (pkt->fp_hdr[3] >> 16) & 0xFFFF));
#endif	/* FWOHCI_DEBUG */
#if 0
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
#endif
		}
		if ((ab->ab_retlen > ab->ab_length) ||
		    ((addr + ab->ab_retlen) > (ab->ab_addr + ab->ab_length)))
			return IEEE1394_RCODE_ADDRESS_ERROR;

		if ((caddr_t)ab->ab_data > (caddr_t)1) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;
		}
		ab->ab_data = malloc(ab->ab_retlen, M_1394DATA, M_WAITOK);
		MPRINTF("malloc(1394DATA)", ab->ab_data);

		if (ab->ab_tcode == IEEE1394_TCODE_WRITE_REQUEST_QUADLET)
			ab->ab_data[0] = pkt->fp_hdr[3];
		else {
			count = 0;
			cur = ab->ab_data;

			assert(pkt->fp_uio.uio_iovcnt > 0);

			for (i = 0; i < pkt->fp_uio.uio_iovcnt; i++) {
				DPRINTFN(3, ("\t%d : bcopy(0x%08x, 0x%08x,"
				    " 0x%x)\n", i,
				    (u_int32_t)pkt->fp_iov[i].iov_base,
				    (u_int32_t)cur, pkt->fp_iov[i].iov_len));
				bcopy(pkt->fp_iov[i].iov_base, cur,
				    pkt->fp_iov[i].iov_len);
				(caddr_t)cur += pkt->fp_iov[i].iov_len;
				count += pkt->fp_iov[i].iov_len;
			}
			if (ab->ab_retlen != count)
				panic("Packet claims %d length "
				    "but %d bytes returned",
				    ab->ab_retlen, count);
		}
		break;
	default:
		panic("Got a callback for a tcode that wasn't requested: %d",
		    ab->ab_tcode);
		break;
	}
	ab->ab_addr = addr;
	ab->ab_cb(ab, IEEE1394_RCODE_COMPLETE);
	return -1;
}

#ifdef	__NetBSD__
int
fwohci_submatch(struct device *parent, struct cfdata *cf, void *aux)
#else
int
fwohci_submatch(struct device *parent, void *vcf, void *aux)
#endif
{
	struct ieee1394_attach_args *fwa = aux;
#ifdef	__OpenBSD__
	struct cfdata *cf = (struct cfdata *)vcf;
#endif

	/* Both halves must be filled in for a match. */
	if ((cf->fwbuscf_idhi == FWBUS_UNK_IDHI &&
	    cf->fwbuscf_idlo == FWBUS_UNK_IDLO) ||
	    (cf->fwbuscf_idhi == ntohl(*((u_int32_t *)&fwa->uid[0])) &&
	    cf->fwbuscf_idlo == ntohl(*((u_int32_t *)&fwa->uid[4]))))
		return ((*cf->cf_attach->ca_match)(parent, cf, aux));
	return 0;
}

int
fwohci_detach(struct fwohci_softc *sc, int flags)
{
	int rv = 0;

	*sc->sc_dying = 1;	/* Stop the event thread. */
	wakeup(fwohci_event_thread);
	DPRINTF(("%s: waiting 0x%08x\n", __func__, sc->sc_dying));
	tsleep(sc->sc_dying, PZERO, "detach", 3 * hz);
	DPRINTF(("%s: woken up...\n", __func__));
	FREE(sc->sc_dying, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", sc->sc_dying);
	sc->sc_dying = NULL;	/* XXX */

	if (sc->sc_sc1394.sc1394_if != NULL) {
		rv = config_detach_children(sc->sc_sc1394.sc1394_if, flags);
		rv |= config_detach(sc->sc_sc1394.sc1394_if, flags);
	}
	if (rv)
		return (rv);

#ifdef	__NetBSD__
	callout_stop(&sc->sc_selfid_callout);
#else
	timeout_del(&sc->sc_selfid_callout);
#endif

	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
	if (sc->sc_shutdownhook != NULL)
		shutdownhook_disestablish(sc->sc_shutdownhook);

	return (rv);
}

int
fwohci_activate(struct device *self, enum devact act)
{
	struct fwohci_softc *sc = (struct fwohci_softc *)self;
	int s, rv = 0;

	s = splhigh();
	switch (act) {
	case DVACT_ACTIVATE:
		rv = EOPNOTSUPP;
		break;

	case DVACT_DEACTIVATE:
		if (sc->sc_sc1394.sc1394_if != NULL)
			rv = config_deactivate(sc->sc_sc1394.sc1394_if);
		break;
	}
	splx(s);

	return (rv);
}

#ifdef	FWOHCI_DEBUG
void
fwohci_show_intr(struct fwohci_softc *sc, u_int32_t intmask)
{

	DPRINTF(("%s: intmask=0x%08x:", sc->sc_sc1394.sc1394_dev.dv_xname,
	    intmask));
	if (intmask & OHCI_Int_CycleTooLong)
		DPRINTF((" CycleTooLong"));
	if (intmask & OHCI_Int_UnrecoverableError)
		DPRINTF((" UnrecoverableError"));
	if (intmask & OHCI_Int_CycleInconsistent)
		DPRINTF((" CycleInconsistent"));
	if (intmask & OHCI_Int_BusReset)
		DPRINTF((" BusReset"));
	if (intmask & OHCI_Int_SelfIDComplete)
		DPRINTF((" SelfIDComplete"));
	if (intmask & OHCI_Int_LockRespErr)
		DPRINTF((" LockRespErr"));
	if (intmask & OHCI_Int_PostedWriteErr)
		DPRINTF((" PostedWriteErr"));
	if (intmask & OHCI_Int_ReqTxComplete)
		DPRINTF((" ReqTxComplete(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_TX_REQUEST,
		    OHCI_SUBREG_ContextControlClear)));
	if (intmask & OHCI_Int_RespTxComplete)
		DPRINTF((" RespTxComplete(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_TX_RESPONSE,
		    OHCI_SUBREG_ContextControlClear)));
	if (intmask & OHCI_Int_ARRS)
		DPRINTF((" ARRS(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_RX_RESPONSE,
		    OHCI_SUBREG_ContextControlClear)));
	if (intmask & OHCI_Int_ARRQ)
		DPRINTF((" ARRQ(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_RX_REQUEST,
		    OHCI_SUBREG_ContextControlClear)));
	if (intmask & OHCI_Int_IsochRx)
		DPRINTF((" IsochRx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoRecvIntEventClear)));
	if (intmask & OHCI_Int_IsochTx)
		DPRINTF((" IsochTx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoXmitIntEventClear)));
	if (intmask & OHCI_Int_RQPkt)
		DPRINTF((" RQPkt(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_RX_REQUEST,
		    OHCI_SUBREG_ContextControlClear)));
	if (intmask & OHCI_Int_RSPkt)
		DPRINTF((" RSPkt(0x%04x)",
		    OHCI_ASYNC_DMA_READ(sc, OHCI_CTX_ASYNC_RX_RESPONSE,
		    OHCI_SUBREG_ContextControlClear)));
	DPRINTF(("\n"));
}

void
fwohci_show_phypkt(struct fwohci_softc *sc, u_int32_t val)
{
	u_int8_t key, phyid;

	key = OHCI_BITVAL(val, IEEE1394_PHY_TYPE);
	phyid = OHCI_BITVAL(val, IEEE1394_PHY_ID);
	DPRINTF(("%s: PHY packet from %d: ",
	    sc->sc_sc1394.sc1394_dev.dv_xname, phyid));
	switch (key) {
	case 0:
		DPRINTF(("PHY Config:"));
		if (val & IEEE1394_CONFIG_FORCE_ROOT)
			DPRINTF((" ForceRoot"));
		if (val & IEEE1394_CONFIG_SET_GAPCNT)
			DPRINTF((" Gap=%x",
			    OHCI_BITVAL(val, IEEE1394_CONFIG_GAPCNT)));
		DPRINTF(("\n"));
		break;
	case 1:
		DPRINTF(("Link-on\n"));
		break;
	case 2:
		DPRINTF(("SelfID:"));
		if (val & IEEE1394_SELFID_EXTENDED) {
			DPRINTF((" #%d",
			    OHCI_BITVAL(val, IEEE1394_SELFID_EXT_SEQ)));
		} else {
			if (val & IEEE1394_SELFID_LINK_ACTIVE)
				DPRINTF((" LinkActive"));
			DPRINTF((" Gap=%x",
			    OHCI_BITVAL(val, IEEE1394_SELFID_GAPCNT)));
			DPRINTF((" Spd=S%d",
			    100 << OHCI_BITVAL(val, IEEE1394_SELFID_SPEED)));
			DPRINTF((" Pow=%s", ieee1394_power[OHCI_BITVAL(val,
			     IEEE1394_SELFID_POWER)]));
			if (val & IEEE1394_SELFID_CONTENDER)
				DPRINTF((" Cont"));
			if (val & IEEE1394_SELFID_INITIATED_RESET)
				DPRINTF((" InitiateBusReset"));
		}
		if (val & IEEE1394_SELFID_MORE_PACKETS)
			DPRINTF((" +"));
		DPRINTF(("\n"));
		break;
	default:
		DPRINTF(("unknown: 0x%08x\n", val));
		break;
	}
}
#endif	/* FWOHCI_DEBUG */
@


1.14
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.13 2003/04/27 11:22:53 ho Exp $	*/
@


1.13
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.12 2003/01/13 07:16:20 tdeval Exp $	*/
d2644 1
a2644 1
 * Asynchronous Transmit Reponse -- in response of request packet.
@


1.12
log
@Fix pastos.  Reported by andres at msu dot edu.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.11 2003/01/12 12:05:04 tdeval Exp $	*/
d3330 1
a3330 1
			strcpy(fwa.name, "fwnode");
@


1.12.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.12 2003/01/13 07:16:20 tdeval Exp $	*/
d3330 1
a3330 1
			strlcpy(fwa.name, "fwnode", sizeof fwa.name);
@


1.12.4.2
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d2644 1
a2644 1
 * Asynchronous Transmit Reponse -- in response to request packet.
@


1.11
log
@- Use OHCI_BITVAL and OHCI_BITSET where appropriate.
- Use the IEEE1394_SELFID names, instead of dumb hex constants.
- Get the nodes' link_speed from the SeldID PHY packets.
- Some more cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.10 2003/01/06 11:33:28 miod Exp $	*/
d3457 1
a3457 1
#if	defined(FWOHCI_DEBUG) && !defined(SMALL_KERNEL)
d3459 4
a3462 7
	DPRINTF(DBG_LOG|DBG_TIME|DBG_FUNC|DBG_L_V1,
	   ("tcode=0x%x, dlen=%d", pkt->fp_tcode, pkt->fp_dlen));
	for (i = 0; (DBG_FLAGS_VAR(fwohci) & DBG_L_BUFFER) &&
	     i < pkt->fp_hlen/4; i++)
		DPRINTF(DBG_LOG|DBG_NOLF|DBG_L_BUFFER,
		    ("%s %08x", i?"":"   ", pkt->fp_hdr[i]));
	DPRINTF(DBG_LOG|DBG_L_BUFFER, (" $"));
d3466 3
a3468 4
			for (i = 0; (DBG_FLAGS_VAR(fwohci) & DBG_L_BUFFER) &&
			     i < iov->iov_len; i++)
				DPRINTF(DBG_LOG|DBG_NOLF|DBG_L_BUFFER,
				   ("%s%02x", i&31?i&3?"":" ":i?"\n    ":"    ",
d3470 1
a3470 1
			DPRINTF(DBG_LOG|DBG_L_BUFFER, (" $"));
@


1.10
log
@syncronous -> synchronous
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.9 2002/12/30 11:12:12 tdeval Exp $	*/
d97 1
d338 1
a338 1
	sc->sc_nodeid = 0xffff;		/* invalid */
d413 1
a413 1
		if ((intmask == 0xffffffff) || (intmask == 0) ||
d417 1
a417 1
			if (intmask == 0xffffffff)
d721 1
a721 1
			sc->sc_nodeid = 0xffff;	/* Indicate invalid. */
d823 1
a823 1
		sc->sc_nodeid = 0xffff;	/* Indicate invalid. */
d1001 1
a1001 1
	OHCI_CSR_WRITE(sc, OHCI_REG_ATRetries, 0xffff0fff);	/*XXX*/
d1077 1
d1079 1
a1079 1
	splassert(IPL_BIO);
d1090 1
d1095 1
d1115 1
a1115 1
	splassert(IPL_BIO);
d1119 1
a1119 1
	    ((reg & 0xf) << OHCI_PhyControl_RegAddr_BITPOS));
d1127 1
a1127 1
	return (val & OHCI_PhyControl_RdData) >> OHCI_PhyControl_RdData_BITPOS;
d1138 1
a1138 1
	splassert(IPL_BIO);
d1141 2
a1142 2
	    ((reg & 0xf) << OHCI_PhyControl_RegAddr_BITPOS) |
	    (val << OHCI_PhyControl_WrData_BITPOS));
d1160 1
a1160 1
	splassert(IPL_BIO);
d1174 1
a1174 1
	    0x3f;				/* Default GAP count. */
d1189 1
a1189 1
		if (val == 0 && ((*pkt->fp_trail & 0x001f0000) >> 16) ==
d1505 1
a1505 1
	splassert(IPL_BIO);
d1646 1
a1646 1
	splassert(IPL_BIO);
d1719 1
a1719 1
	splassert(IPL_BIO);
d1844 1
a1844 1
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000f0) >> 4;
d1867 1
a1867 1
			pkt->fp_dlen = (pkt->fp_hdr[0] >> 16) & 0xffff;
d1991 1
a1991 1
	*pkt->fp_trail = (*pkt->fp_trail & 0xffff) | (fd->fd_status << 16);
d1993 1
a1993 1
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000f0) >> 4;
d2144 1
a2144 1
	u_int32_t key3n = (key3 & 0xffff) | ((len & 0xffff) << 16);
d2183 1
a2183 1
		tlabel = (pkt.fp_hdr[0] & 0x0000fc00) >> 10;
d2214 1
a2214 1
		if (((*pkt.fp_trail & 0x001f0000) >> 16) !=
d2239 2
a2240 2
		rcode = (pkt.fp_hdr[1] & 0x0000f000) >> 12;
		tlabel = (pkt.fp_hdr[0] & 0x0000fc00) >> 10;
d2317 2
a2318 2
		chan = (pkt.fp_hdr[0] & 0x00003f00) >> 8;
		tag  = (pkt.fp_hdr[0] & 0x0000c000) >> 14;
d2510 1
a2510 1
		fd->fd_timestamp = ((val >> 12) & 0x1fff) |
d2651 1
a2651 1
	if (((*req->fp_trail & 0x001f0000) >> 16) !=
d2655 2
a2656 2
	res->fp_hdr[0] = (req->fp_hdr[0] & 0x0000fc00) | 0x00000100;
	res->fp_hdr[1] = (req->fp_hdr[1] & 0xffff0000) | (rcode << 12);
d2707 8
a2714 8
		sc->sc_sc1394.sc1394_guid[0] = (val1 >> 24) & 0xff;
		sc->sc_sc1394.sc1394_guid[1] = (val1 >> 16) & 0xff;
		sc->sc_sc1394.sc1394_guid[2] = (val1 >>  8) & 0xff;
		sc->sc_sc1394.sc1394_guid[3] = (val1 >>  0) & 0xff;
		sc->sc_sc1394.sc1394_guid[4] = (val2 >> 24) & 0xff;
		sc->sc_sc1394.sc1394_guid[5] = (val2 >> 16) & 0xff;
		sc->sc_sc1394.sc1394_guid[6] = (val2 >>  8) & 0xff;
		sc->sc_sc1394.sc1394_guid[7] = (val2 >>  0) & 0xff;
d2812 1
a2812 1
			sum = ((crc >> 12) ^ (data >> shift)) & 0x000f;
d2815 1
a2815 1
		crc &= 0xffff;
d2828 1
a2828 1
	splassert(IPL_BIO);
d2842 1
a2842 1
	*hdr |= (*hdr & 0x00ff0000) << 8;
d2847 1
a2847 1
	CFR_PUT_VALUE(&cfr, 0x03, 0x00005e);	/* Vendor ID. */
d2849 1
a2849 1
	CFR_PUT_VALUE(&cfr, 0x0c, 0x0083c0);	/* Node capability. */
d2852 1
a2852 1
	CFR_PUT_REFER(&cfr, 0xd1, 3);		/* IPv4 unit directory. */
d2855 1
a2855 1
	CFR_PUT_REFER(&cfr, 0xd1, 4);		/* IPv6 unit directory. */
d2874 1
a2874 1
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005e);	/* Unit spec ID. */
d2905 1
a2905 1
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005e);	/* Unit spec id. */
d3001 1
a3001 1
	splassert(IPL_BIO);
d3005 1
a3005 1
	if ((fb->fb_dmamap->dm_segs[0].ds_addr & 0x7ff) != 0)
d3030 1
a3030 1
		return -1;
d3049 5
a3053 1
		if (buf[i] & 0x00000001)
d3055 6
a3060 4
		if (buf[i] & 0x00800000)
			continue;	/* External ID. */
		sc->sc_rootid = (buf[i] & 0x3f000000) >> 24;
		if ((buf[i] & 0x00400800) == 0x00400800)
d3072 1
a3072 1
		return -1;
d3087 1
a3087 1
		return -1;
d3092 1
a3092 1
		sc->sc_nodeid = 0xffff;		/* Invalid. */
d3095 1
a3095 1
		return -1;
d3097 1
a3097 1
	sc->sc_nodeid = val & 0xffff;
d3105 1
a3105 1
		return -1;
d3113 1
a3113 1
	return 0;
d3130 1
a3130 1
	splassert(IPL_BIO);
d3187 1
a3187 1
	int i;
d3190 3
d3195 1
a3195 1
		iea->sc1394_node_id = 0xffff;
d3211 2
a3212 1
	if (sc->sc_uidtbl == NULL)
d3214 1
d3219 13
d3268 1
a3268 1
	pkt.fp_hdr[1] = ((0xffc0 | phyid) << 16) | CSR_BASE_HI;
d3272 1
a3272 1
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3f;
d3280 1
a3280 1
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3f;
d3295 1
a3295 1
	rcode = (res->fp_hdr[1] & 0x0000f000) >> 12;
d3313 1
a3313 1
		LIST_FOREACH(iea, &sc->sc_nodelist, sc1394_node)
d3317 2
a3318 1
				DPRINTF(("%s: Updating nodeid to %d\n",
d3320 2
a3321 1
				    iea->sc1394_node_id));
d3328 1
d3331 1
d3341 5
a3345 1
			if (iea != NULL)
d3348 1
d3387 1
a3387 1
		if (iea->sc1394_node_id == 0xffff) {
d3404 1
a3404 1
	    { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
d3457 1
a3457 1
#ifdef	FWOHCI_DEBUG
d3459 7
a3465 5
	DPRINTFN(1, ("%s: tcode=0x%x, dlen=%d", __func__, pkt->fp_tcode,
	    pkt->fp_dlen));
	for (i = 0; i < pkt->fp_hlen/4; i++)
		DPRINTFN(2, ("%s%08x", i?" ":"\n    ", pkt->fp_hdr[i]));
	DPRINTFN(2, ("$"));
d3469 4
a3472 3
			for (i = 0; i < iov->iov_len; i++)
				DPRINTFN(2, ("%s%02x", (i%32)?((i%4)?"":" ")
							     :"\n    ",
d3474 1
a3474 1
			DPRINTFN(2, ("$"));
a3476 1
	DPRINTFN(1, ("\n"));
d3510 1
a3510 3
	mtod(m, u_int8_t *)[9] =
	    (*pkt->fp_trail >> (16 + OHCI_CTXCTL_SPD_BITPOS)) &
	    ((1 << OHCI_CTXCTL_SPD_BITLEN) - 1);
d3549 1
a3549 1
#ifdef	FWOHCI_DEBUG
d3553 2
a3554 2
	chan = (pkt->fp_hdr[0] & 0x00003f00) >> 8;
	tag  = (pkt->fp_hdr[0] & 0x0000c000) >> 14;
d3604 1
a3604 2
		    (*pkt->fp_trail >> (16 + OHCI_CTXCTL_SPD_BITPOS)) &
		    ((1 << OHCI_CTXCTL_SPD_BITLEN) - 1);
d3726 2
a3727 2
		p[1] = sc->sc_nodeid & 0xff;
		p[2] = 0x00; p[3] = 0x00; p[4] = 0x5e;
d3745 1
a3745 1
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3f;
d3834 2
a3835 2
	high = ((ab->ab_addr & 0x0000ffff00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000ffffffff);
d3838 1
a3838 1
	pkt.fp_hdr[1] = ((0xffc0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3866 1
a3866 1
	psc->sc_tlabel = (psc->sc_tlabel + 1) & 0x3f;
d3922 2
a3923 2
		high = ((ab->ab_addr & 0x0000ffff00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000ffffffff);
d3929 1
a3929 1
	pkt.fp_hdr[1] = ((0xffc0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3982 1
a3982 1
		tcode = (pkt->fp_hdr[0] >> 4) & 0xf;
d4005 1
a4005 1
		rcode = (pkt->fp_hdr[1] & 0x0000f000) >> 12;
d4032 2
a4033 2
		high = ((ab->ab_addr & 0x0000ffff00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000ffffffff);
d4039 1
a4039 1
		    ((0xffc0 | ab->ab_req->sc1394_node_id) << 16) | high;
d4064 1
a4064 1
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3f;
d4143 1
a4143 1
	rcode = (pkt->fp_hdr[1] & 0x0000f000) >> 12;
d4165 2
a4166 2
		high = ((ab->ab_addr & 0x0000ffff00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000ffffffff) + ab->ab_retlen;
d4172 1
a4172 1
		    ((0xffc0 | ab->ab_req->sc1394_node_id) << 16) | high;
d4199 1
a4199 1
				sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3f;
d4256 2
a4257 2
	high = ((ab->ab_addr & 0x0000ffff00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000ffffffff);
d4327 3
a4329 3
	ab->ab_tcode = (pkt->fp_hdr[0] >> 4) & 0xf;
	ab->ab_tlabel = (pkt->fp_hdr[0] >> 10) & 0x3f;
	addr = (((u_int64_t)(pkt->fp_hdr[1] & 0xffff) << 32) | pkt->fp_hdr[2]);
d4341 1
a4341 1
		ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xffff;
d4356 1
a4356 1
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xffff;
d4359 1
a4359 1
			if (ab->ab_retlen != ((pkt->fp_hdr[3] >> 16) & 0xffff))
d4362 1
a4362 1
				    (pkt->fp_hdr[3] >> 16) & 0xffff));
d4365 1
a4365 1
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xffff;
d4552 2
a4553 2
	key = (val & 0xc0000000) >> 30;
	phyid = (val & 0x3f000000) >> 24;
d4559 1
a4559 1
		if (val & 0x00800000)
d4561 3
a4563 2
		if (val & 0x00400000)
			DPRINTF((" Gap=%x", (val & 0x003f0000) >> 16));
d4571 3
a4573 2
		if (val & 0x00800000) {
			DPRINTF((" #%d", (val & 0x00700000) >> 20));
d4575 1
a4575 1
			if (val & 0x00400000)
d4577 7
a4583 4
			DPRINTF((" Gap=%x", (val & 0x003f0000) >> 16));
			DPRINTF((" Spd=S%d", 100 <<
			    ((val & 0x0000c000) >> 14)));
			if (val & 0x00000800)
d4585 1
a4585 1
			if (val & 0x00000002)
d4588 1
a4588 1
		if (val & 0x00000001)
@


1.9
log
@Re-design fwohci_hadler_set() to use a new key3.
That new key will be used for Request handlers to discriminate the requests
by nodes. Key3 will also get the lenght field specifier... (may still change)

Add an implementation for a BusReset callback that will be called whenever
a node's node_id changes.

This will allow us to work with more than one device at the same time...
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.8 2002/12/13 22:54:29 tdeval Exp $	*/
d1338 1
a1338 1
 * Asyncronous/Isochronous Transmit/Receive Context.
d2146 1
a2146 1
 * Asyncronous Receive Requests input frontend.
@


1.8
log
@Some more cleaning...
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.7 2002/12/13 22:40:16 tdeval Exp $	*/
d141 2
a142 1
    int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *), void *);
d144 2
a145 1
    int, int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *), void *);
d366 1
a366 1
	    channel, tag, fwohci_if_input_iso, handler);
d1470 1
a1470 1
		    NULL, NULL);
d2015 4
a2018 3
fwohci_handler_set(struct fwohci_softc *sc, int tcode, u_int32_t key1,
    u_int32_t key2, int (*handler)(struct fwohci_softc *, void *,
    struct fwohci_pkt *), void *arg)
d2077 3
a2079 1
			    fh->fh_key1 == key1 && fh->fh_key2 == key2)
d2096 2
a2097 2
		DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x [NULL]\n",
		    __func__, fc->fc_ctx, tcode, key1, key2));
d2111 1
d2119 2
a2120 2
	DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x [%08x]\n",
	    __func__, fc->fc_ctx, tcode, key1, key2, (u_int32_t)handler));
d2135 4
a2138 3
fwohci_block_handler_set(struct fwohci_softc *sc, int tcode, u_int32_t key1,
    u_int32_t key2, int len, int (*handler)(struct fwohci_softc *, void *,
    struct fwohci_pkt *), void *arg)
d2140 1
a2140 1
	u_int32_t key1_n = (key1 & 0xffff) | ((len & 0xffff) << 16);
d2142 1
a2142 1
	return (fwohci_handler_set(sc, tcode, key1_n, key2, handler, arg));
d2173 1
a2173 1
		key1 = pkt.fp_hdr[1] & 0xffff;
d2185 3
d2189 1
a2189 1
			     (datalen && key1 == (fh->fh_key1 & 0xffff) &&
d2192 1
a2192 1
			       (fh->fh_key2 + ((fh->fh_key1 >> 16) & 0xffff)))))
d2956 1
a2956 1
	/* Just allow quad reads of the rom. */
d2960 1
a2960 1
		    fwohci_configrom_input, NULL);
d3124 2
a3125 1
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], fwohci_csr_input, NULL);
d3127 2
a3128 1
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], fwohci_csr_input, NULL);
d3215 4
d3243 1
a3243 1
	    sc->sc_tlabel, fwohci_uid_input, (void *)0);
d3251 1
a3251 1
	    sc->sc_tlabel, fwohci_uid_input, (void *)1);
d3280 1
a3280 2
#ifdef	FWOHCI_DEBUG
	if (fu->fu_valid == 0x3)
a3284 2
#endif	/* FWOHCI_DEBUG */
	if (fu->fu_valid == 0x3) {
d3292 4
d3402 3
a3404 2
	fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK, offhi,
	    offlo, handler ? fwohci_if_input : NULL, handler);
d3407 2
a3408 2
	    OHCI_ASYNC_STREAM,
	    IEEE1394_TAG_GASP, handler ? fwohci_if_input : NULL, handler);
d3823 1
a3823 1
	    psc->sc_tlabel, fwohci_read_resp, fcb);
d3829 1
a3829 1
		    psc->sc_tlabel, NULL, NULL);
d4010 1
a4010 1
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel,
d4022 2
a4023 2
			    ab->ab_req->sc1394_node_id, sc->sc_tlabel, NULL,
			    NULL);
d4068 2
a4069 1
				    ab->ab_req->sc1394_node_id, i, NULL, NULL);
d4150 1
a4150 1
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel,
d4160 1
a4160 1
				    NULL, NULL);
a4217 3
#if 0	/* use fwohci_block_handler_set */
	int i, j;
#endif
d4229 1
a4229 1
			    fwohci_parse_input, ab);
d4232 1
a4232 1
			    NULL, NULL);
a4236 19
#if 0	/* use fwohci_block_handler_set */
			for (i = 0; i < (ab->ab_length / 4); i++) {
				if (ab->ab_cb) {
					rv = fwohci_handler_set(psc,
					    ab->ab_tcode, high, lo + (i * 4),
					    fwohci_parse_input, ab);
					if (rv)
						break;
				} else
					fwohci_handler_set(psc, ab->ab_tcode,
					    high, lo + (i * 4), NULL, NULL);
			}
			if (i != (ab->ab_length / 4)) {
				j = i + 1;
				for (i = 0; i < j; i++)
					fwohci_handler_set(psc, ab->ab_tcode,
					    high, lo + (i * 4), NULL, NULL);
			}
#else	/* use fwohci_block_handler_set */
d4239 2
a4240 2
				    high, lo, ab->ab_length, fwohci_parse_input,
				    ab);
d4243 2
a4244 2
				    high, lo, ab->ab_length, NULL, NULL);
#endif	/* use fwohci_block_handler_set */
d4253 3
a4255 2
				rv = fwohci_handler_set(psc, ab->ab_tcode, high,
				    lo, fwohci_parse_input, ab);
d4258 1
a4258 1
				    NULL, NULL);
@


1.7
log
@Only WRITE_REQUEST_DATABLOCK are limited to the device's max_receive.
Other writes are only limited by the link speed.

Idea from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.6 2002/12/13 21:35:11 tdeval Exp $	*/
d2091 3
d2113 2
a2114 2
	DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x\n", __func__,
	    fc->fc_ctx, tcode, key1, key2));
a4205 5

#ifdef	FWOHCI_DEBUG
	if (ab->ab_retlen)
		DPRINTF(("%s: retlen=%d\n", __func__, ab->ab_retlen));
#endif	/* FWOHCI_DEBUG */
@


1.6
log
@Malloc debug cleaning (MPRINTF).
Uses option FW_MALLOC_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.5 2002/12/13 02:52:04 tdeval Exp $	*/
d3824 3
a3826 1
	if (ab->ab_length > IEEE1394_MAX_REC(sc->sc1394_max_receive)) {
@


1.5
log
@Better memory balancing (between alloc/free),
some enhancements, lots of debugging, KNF...
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.4 2002/10/12 02:03:46 krw Exp $	*/
d215 1
d218 3
d332 1
a332 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", sc->sc_dying);
d598 1
a598 1
	//MPRINTF_OLD("malloc(DEVBUF)", sc->sc_ctx_ir);
d634 1
a634 1
		//MPRINTF_OLD("free(DEVBUF)", sc->sc_uidtbl);
d642 1
a642 1
	//MPRINTF_OLD("free(DEVBUF)", sc->sc_ctx_ir);
d704 1
a704 1
				//MPRINTF_OLD("free(DEVBUF)", sc->sc_uidtbl);
d806 1
a806 1
			//MPRINTF_OLD("free(DEVBUF)", sc->sc_uidtbl);
d899 1
a899 1
	//MPRINTF_OLD("bus_dmamem_alloc", segs->ds_addr);
d912 1
a912 1
	//MPRINTF_OLD("bus_dmamap_create", mapp);
d924 1
a924 1
		//MPRINTF_OLD("bus_dmamem_free", segs->ds_addr);
d1219 1
a1219 1
	//MPRINTF_OLD("malloc(DEVBUF)", sc->sc_descmap);
d1222 1
a1222 1
	//MPRINTF_OLD("malloc(DEVBUF)", sc->sc_descmap);
d1236 1
a1236 1
	//MPRINTF_OLD("bus_dmamap_create", sc->sc_ddmamap);
d1244 1
a1244 1
	//MPRINTF_OLD("bus_dmamem_alloc", sc->sc_dseg.ds_addr);
d1272 1
a1272 1
	//MPRINTF_OLD("bus_dmamem_free", sc->sc_dseg.ds_addr);
d1275 1
a1275 1
	//MPRINTF_OLD("bus_dmamap_destroy", sc->sc_ddmamap);
d1288 1
a1288 1
	//MPRINTF_OLD("bus_dmamem_free", sc->sc_dseg.ds_addr);
d1290 1
a1290 1
	//MPRINTF_OLD("bus_dmamap_destroy", sc->sc_ddmamap);
d1293 1
a1293 1
	//MPRINTF_OLD("free(DEVBUF)", sc->sc_descmap);
d1352 1
a1352 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", fc);
d1355 1
a1355 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", fc);
d1364 1
a1364 1
	//MPRINTF_OLD("malloc(DEVBUF)", fc->fc_buffers);
d1367 1
a1367 1
	//MPRINTF_OLD("malloc(DEVBUF)", fc->fc_buffers);
d1445 1
a1445 1
	//MPRINTF_OLD("FREE(DEVBUF)", fc);
d1484 1
a1484 1
	//MPRINTF_OLD("free(DEVBUF)", fc->fc_buffers);
d1487 1
a1487 1
	//MPRINTF_OLD("FREE(DEVBUF)", fc);
d1577 1
a1577 1
	//MPRINTF_OLD("bus_dmamap_create", fb->fb_dmamap);
d1585 1
a1585 1
	//MPRINTF_OLD("bus_dmamem_alloc", fb->fb_seg.ds_addr);
d1615 1
a1615 1
	//MPRINTF_OLD("bus_dmamem_free", fb->fb_seg.ds_addr);
d1618 1
a1618 1
	//MPRINTF_OLD("bus_dmamap_destroy", fb->fb_dmamap);
d1630 1
a1630 1
	//MPRINTF_OLD("bus_dmamem_free", fb->fb_seg.ds_addr);
d1632 1
a1632 1
	//MPRINTF_OLD("bus_dmamap_destroy", fb->fb_dmamap);
d2082 1
a2082 1
			//MPRINTF_OLD("FREE(DEVBUF)", fh);
d2097 1
a2097 1
		//MPRINTF_OLD("MALLOC(DEVBUF)", fh);
d2235 1
a2235 1
				//MPRINTF_OLD("FREE(DEVBUF)", fh);
d2395 1
a2395 1
					//MPRINTF_OLD("MGETHDR", m0);
d2406 1
a2406 1
					//MPRINTF_OLD("MGET", m->m_next);
d2413 1
a2413 1
					//MPRINTF_OLD("m_freem", m0);
d2425 1
a2425 1
			//MPRINTF_OLD("m_freem", pkt->fp_m);
d2438 1
a2438 1
	//MPRINTF_OLD("malloc(DEVBUF)", fb);
d2443 1
a2443 1
		//MPRINTF_OLD("free(DEVBUF)", fb);
d2459 1
a2459 1
			//MPRINTF_OLD("free(DEVBUF)", fb);
d2463 1
a2463 1
		//MPRINTF_OLD("bus_dmamap_create", fb->fb_dmamap);
d2473 1
a2473 1
			//MPRINTF_OLD("bus_dmamap_destroy", fb->fb_dmamap);
d2476 1
a2476 1
			//MPRINTF_OLD("free(DEVBUF)", fb);
d2610 1
a2610 1
			//MPRINTF_OLD("bus_dmamap_destroy", fb->fb_dmamap);
d2618 1
a2618 1
			//MPRINTF_OLD("m_freem", fb->fb_m);
d2621 1
a2621 1
		//MPRINTF_OLD("free(DEVBUF)", fb);
d3171 1
a3171 1
		//MPRINTF_OLD("free(DEVBUF)", sc->sc_uidtbl);
d3177 1
a3177 1
	//MPRINTF_OLD("malloc(DEVBUF)", sc->sc_uidtbl);
d3181 1
a3181 1
	//MPRINTF_OLD("malloc(DEVBUF)", sc->sc_uidtbl);
d3427 1
a3427 1
			//MPRINTF_OLD("m_freem", m);
d3437 1
a3437 1
		//MPRINTF_OLD("m_freem", m);
d3524 1
a3524 1
			//MPRINTF_OLD("m_freem", m);
d3538 1
a3538 1
			//MPRINTF_OLD("m_freem", m);
d3702 1
a3702 1
			//MPRINTF_OLD("m_freem", m0);
d3772 1
a3772 1
	//MPRINTF_OLD("MALLOC(DEVBUF)", fcb);
d3938 1
a3938 1
				//MPRINTF_OLD("FREE(DEVBUF)", fcb);
d4058 1
a4058 1
		//MPRINTF_OLD("FREE(DEVBUF)", fcb);
d4152 1
a4152 1
		//MPRINTF_OLD("FREE(DEVBUF)", fcb);
d4177 1
a4177 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d4181 1
a4181 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d4314 1
a4314 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d4340 1
a4340 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d4344 1
a4344 1
		//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d4413 1
a4413 1
	//MPRINTF_OLD("FREE(DEVBUF)", sc->sc_dying);
@


1.4
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Last bits of diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.3 2002/07/07 13:41:27 tdeval Exp $	*/
d4 1
a4 1
/*-
d21 2
a22 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d53 1
a53 1
#ifdef __KERNEL_RCSID
d57 2
a58 2
#define DOUBLEBUF 1
#define NO_THREAD 0
d60 1
a60 1
#ifdef __NetBSD__
d68 1
a68 1
#ifdef __NetBSD__
d77 1
a77 1
#ifdef __OpenBSD__
d81 1
a81 1
#if __NetBSD_Version__ >= 105010000 || !defined(__NetBSD__)
d96 1
a96 1
static const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
d99 1
a99 1
int fwohci_dnamem_alloc(struct fwohci_softc *sc, int size,
d106 1
d112 1
d125 1
a126 1
void fwohci_buf_stop_rx(struct fwohci_softc *);
d142 2
d191 1
a191 1
#ifdef __NetBSD__
d198 1
a198 1
#ifdef FW_DEBUG
d204 24
a227 7
#define DPRINTF(x)      if (fwdebug) printf x
#define DPRINTFN(n,x)   if (fwdebug>(n)) printf x
int     fwdebug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
d229 1
a229 1
#ifdef __OpenBSD__
d244 1
a244 1
#ifdef __NetBSD__
d255 1
a255 1
	 * Wait for reset completion
d264 2
a265 1
	/* What dialect of OHCI is this device?
d285 2
a286 1
	/* Get the maximum link speed and receive size
d297 3
a299 2
	
	/* MaxRec is encoded as log2(max_rec_octets)-1
d317 1
a317 1
	
d321 1
a321 1
	error = fwohci_dnamem_alloc(sc, OHCI_CONFIG_SIZE,
d327 4
a330 1
	sc->sc_dying = 0;
d333 1
a333 1
#ifdef __NetBSD__
d338 2
a339 2
	else				/* late binding, threads
					   already running */
d359 1
a359 1
	retval = fwohci_handler_set(sc, IEEE1394_TCODE_STREAM_DATA,
d378 1
d380 3
d385 8
d394 1
d399 1
a399 1
		 * cleared.  That can't get cleared until the selfid
d406 1
a406 1
		if ((intmask == 0) ||
d408 10
a417 2
			(sc->sc_intmask & OHCI_Int_BusReset))) {
			if (progress)
d419 9
a427 1
			return progress;
d429 1
d432 12
a443 2
#ifdef FW_DEBUG
		if (fwdebug > 1)
d445 1
a445 1
#endif
d450 2
a451 2
			 * All asynchronous transmit must be stopped before
			 * clearing BusReset.  Moreover, the BusReset
d453 1
a453 1
			 * SelfID phase.  Thus we turned off interrupt mask
d457 7
d473 1
d475 4
d481 1
a481 1
#if NO_THREAD
d484 1
a484 1
#endif
d487 1
d489 5
a493 1
#if NO_THREAD
d495 4
a498 2
				if ((iso & (1<<i)) && sc->sc_ctx_ir[i] != NULL) {
					if (sc->sc_ctx_ir[i]->fc_type == FWOHCI_CTX_ISO_SINGLE) {
d504 2
a505 1
					    0, sizeof(struct fwohci_desc) * sc->sc_descsize,
d515 1
a515 1
				/* all iso intr is pure isochronous */
d518 1
a518 1
#else
d520 1
a520 1
#endif /* NO_THREAD */
d525 1
d527 1
d529 1
d531 8
d546 1
a546 1
#ifdef __NetBSD__
d567 1
a567 1
	 * Allocate descriptors
d576 1
a576 1
	 * Enable Link Power
d582 1
a582 1
	 * Allocate DMA Context
d588 4
a591 4
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrq, 0, OHCI_CTX_ASYNC_TX_REQUEST,
	    FWOHCI_CTX_ASYNC);
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrs, 0, OHCI_CTX_ASYNC_TX_RESPONSE,
	    FWOHCI_CTX_ASYNC);
d594 1
d599 1
a599 1
	 * Allocate buffer for configuration ROM and SelfID buffer
d604 1
a604 1
#ifdef __NetBSD__
d615 1
a615 1
	 * establish hooks for shutdown and suspend/resume 
d626 10
d637 13
d656 5
a660 2
	int i, s;
	u_int32_t intmask, iso;
d670 1
a670 1
	/* Initial Bus Reset */
d674 2
a675 1
	while (!sc->sc_dying) {
d679 4
d684 2
d691 2
d695 1
d697 1
d700 1
d704 1
a704 1
#ifdef __NetBSD__
d714 1
a714 1
			sc->sc_nodeid = 0xffff;	/* indicate invalid */
d725 1
a725 1
#ifdef __NetBSD__
d731 1
d733 1
d737 2
a738 1
		if (intmask & OHCI_Int_ReqTxComplete)
d740 4
a743 1
		if (intmask & OHCI_Int_RespTxComplete)
d745 3
a747 1
		if (intmask & OHCI_Int_RQPkt)
d749 2
a750 1
		if (intmask & OHCI_Int_RSPkt)
d752 1
d766 11
d780 102
d884 1
a884 1
fwohci_dnamem_alloc(struct fwohci_softc *sc, int size, int alignment,
d895 1
d908 2
d920 1
d944 2
d958 1
d961 1
a961 1
	 * First, initilize CSRs with undefined value to default settings.
d965 1
a965 1
#if 0
d967 1
d970 1
a971 1
	val &= ~(OHCI_BusOptions_PMC);
d991 1
d993 3
d997 1
a997 1
	/* clear receive filter */
d1002 3
d1006 5
a1010 1
	    OHCI_HCControl_NoByteSwapData | OHCI_HCControl_APhyEnhanceEnable);
d1014 3
d1034 1
a1034 1
	 * Start the receivers
d1055 1
a1055 1
#ifdef __NetBSD__
d1071 3
a1073 1
#ifdef __NetBSD__
d1078 1
a1078 1
	/* disable all interrupt */
d1093 1
a1093 1
 * COMMON FUNCTIONS
d1097 1
a1097 1
 * read the PHY Register.
d1105 2
d1111 3
a1113 2
		if (OHCI_CSR_READ(sc, OHCI_REG_PhyControl) &
		    OHCI_PhyControl_RdDone)
a1116 1
	val = OHCI_CSR_READ(sc, OHCI_REG_PhyControl);
d1121 1
a1121 1
 * write the PHY Register.
d1128 2
d1142 1
a1142 1
 * Initiate Bus Reset
d1150 2
d1156 1
a1156 1
#ifdef __NetBSD__
d1162 3
a1164 3
	val = (val & 0x80) |			/* preserve RHB (force root) */
	    0x40 |				/* Initiate Bus Reset */
	    0x3f;				/* default GAP count */
d1170 1
a1170 1
 * PHY Packet
d1181 1
a1181 1
			DPRINTFN(1, ("fwohci_phy_input: BusReset: 0x%08x\n",
d1190 2
a1191 2
#ifdef FW_DEBUG
	if (fwdebug > 1)
d1193 1
a1193 1
#endif
d1205 1
a1205 1
	 * allocate descriptor buffer
d1213 1
a1213 1
#ifdef M_ZERO
d1215 1
d1218 1
d1222 12
d1235 1
a1235 1
	    &sc->sc_dseg, 1, &sc->sc_dnseg, 0)) != 0) {
d1238 1
a1238 1
		goto fail_0;
d1240 1
a1246 7
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, dsize, sc->sc_dnseg,
	    dsize, 0, BUS_DMA_WAITOK, &sc->sc_ddmamap)) != 0) {
		printf("%s: unable to create descriptor buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname, error);
d1250 1
d1253 4
d1265 1
a1265 1
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
d1267 2
a1268 1
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_desc, dsize);
d1270 2
a1271 1
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);
d1276 17
d1298 2
d1319 2
d1323 1
a1323 1
#ifdef DIAGNOSTIC
d1332 1
a1332 1
 * Asyncronous/Isochronous Transmit/Receive Context
d1346 3
a1348 2
#ifdef M_ZERO
	fc = malloc(sizeof(*fc), M_DEVBUF, M_WAITOK|M_ZERO);
d1350 2
a1351 1
	fc = malloc(sizeof(*fc), M_DEVBUF, M_WAITOK);
d1357 4
a1360 2
#ifdef M_ZERO
	fc->fc_buffers = fb = malloc(sizeof(*fb) * bufcnt, M_DEVBUF, M_WAITOK|M_ZERO);
d1363 1
d1367 3
d1371 1
a1371 1
	TAILQ_INIT(&fc->fc_buf2); /* for isochronous */
d1390 3
d1398 3
d1415 2
a1416 2
			    (caddr_t)fd - (caddr_t)sc->sc_desc, sizeof(struct fwohci_desc),
			    BUS_DMASYNC_PREWRITE);
d1423 2
a1424 2
			    (caddr_t)fd - (caddr_t)sc->sc_desc, sizeof(struct fwohci_desc),
			    BUS_DMASYNC_POSTWRITE);
d1428 1
d1440 3
a1442 1
	free(fc, M_DEVBUF);
d1471 1
a1471 1
#if DOUBLEBUF
d1478 1
a1478 1
#endif /* DOUBLEBUF */
d1480 5
a1484 1
	free(fc, M_DEVBUF);
d1495 6
a1500 1
	for (fb = TAILQ_FIRST(&fc->fc_buf); fb != NULL; fb = nfb) {
d1506 3
d1512 1
a1512 1
	for (fb = TAILQ_FIRST(&fc->fc_buf2); fb != NULL; fb = nfb) {
d1514 2
a1515 2
		    (caddr_t)fd - (caddr_t)sc->sc_desc, sizeof(struct fwohci_desc),
		    BUS_DMASYNC_PREWRITE);
d1522 2
a1523 2
		    (caddr_t)fd - (caddr_t)sc->sc_desc, sizeof(struct fwohci_desc),
		    BUS_DMASYNC_POSTWRITE);
d1532 1
d1551 1
d1556 1
a1556 1
 * DMA data buffer
d1563 12
d1579 1
a1579 1
		goto fail_0;
d1581 1
d1584 2
a1585 1
	    fb->fb_nseg, PAGE_SIZE, &fb->fb_buf, BUS_DMA_WAITOK)) != 0) {
a1587 8
		goto fail_1;
	}

	if ((error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, fb->fb_nseg,
	    PAGE_SIZE, 0, BUS_DMA_WAITOK, &fb->fb_dmamap)) != 0) {
		printf("%s: unable to create buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname,
		    error);
d1591 1
d1594 4
d1608 1
a1608 1
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
d1610 2
a1611 1
	bus_dmamem_unmap(sc->sc_dmat, fb->fb_buf, PAGE_SIZE);
d1613 2
a1614 1
	bus_dmamem_free(sc->sc_dmat, &fb->fb_seg, fb->fb_nseg);
a1623 1
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
d1626 3
d1636 2
d1658 2
d1676 2
d1709 2
d1730 1
a1730 1
			if (fc->fc_type) {
d1750 2
a1751 3
		/* cleaning buffer */
		for (fb = TAILQ_FIRST(&fc->fc_buf); fb != NULL;
		     fb = TAILQ_NEXT(fb, fb_list)) {
d1755 2
a1756 2
	
		/* rotating buffer */
d1765 2
a1766 2
fwohci_buf_pktget(struct fwohci_softc *sc, struct fwohci_buf **fbp, caddr_t *pp,
    int len)
d1770 4
a1773 1
	int bufend;
d1776 1
a1776 1
  again:
d1778 3
a1780 3
	DPRINTFN(1, ("fwohci_buf_pktget: desc %ld, off %d, req %d, res %d,"
	    " len %d, avail %d\n", (long)(fd - sc->sc_desc), fb->fb_off,
	    fd->fd_reqcount, fd->fd_rescount, len,
d1784 1
a1784 1
		DPRINTFN(5, ("buf %x finish req %d res %d off %d ",
d1789 1
a1789 1
			if (fb != NULL)
d1798 9
d1820 1
a1820 1
	memset(pkt, 0, sizeof(*pkt));
d1825 1
a1825 1
	/* get first quadlet */
d1830 1
a1830 2
		DPRINTFN(1, ("fwohci_buf_input: no input for %d\n",
		    fc->fc_ctx));
d1833 1
a1833 1
	pkt->fp_hdr[0] = *(u_int32_t *)p;
d1836 2
a1837 2
	case IEEE1394_TCODE_WRITE_REQ_QUAD:
	case IEEE1394_TCODE_READ_RESP_QUAD:
d1841 1
a1841 1
	case IEEE1394_TCODE_READ_REQ_BLOCK:
d1845 4
a1848 4
	case IEEE1394_TCODE_WRITE_REQ_BLOCK:
	case IEEE1394_TCODE_READ_RESP_BLOCK:
	case IEEE1394_TCODE_LOCK_REQ:
	case IEEE1394_TCODE_LOCK_RESP:
d1851 2
a1852 2
	case IEEE1394_TCODE_STREAM_DATA:
#ifdef DIAGNOSTIC
d1857 1
a1857 1
			pkt->fp_dlen = pkt->fp_hdr[0] >> 16;
d1861 1
a1861 1
#ifdef DIAGNOSTIC
d1863 1
a1863 1
			printf("fwohci_buf_input: bad tcode: STREAM_DATA\n");
d1873 1
a1873 1
	/* get header */
d1877 1
a1877 1
			printf("fwohci_buf_input: malformed input 1: %d\n",
d1881 7
a1887 1
		memcpy((caddr_t)pkt->fp_hdr + count, p, len);
d1891 1
a1891 1
	    pkt->fp_tcode != IEEE1394_TCODE_READ_REQ_BLOCK)
d1893 1
a1893 1
	DPRINTFN(1, ("fwohci_buf_input: tcode=0x%x, hlen=%d, dlen=%d\n",
d1896 1
a1896 1
	/* get data */
d1899 1
a1899 1
	while (count < pkt->fp_dlen) {
d1904 1
a1904 1
			printf("fwohci_buf_input: malformed input 2: %d\n",
d1914 13
a1926 1
	/* get trailer */
d1930 1
a1930 1
		printf("fwohci_buf_input: malformed input 3: %d\n",
d1950 1
a1950 1
	memset(pkt, 0, sizeof(*pkt));
d1955 1
a1955 3
	for (fb = TAILQ_FIRST(&fc->fc_buf); ; fb = TAILQ_NEXT(fb, fb_list)) {
		if (fb == NULL)
			return 0;
d1959 3
d1972 1
a1972 1
		printf("fwohci_buf_input_ppb: malformed input 1: %d\n", len);
d1977 1
a1977 1
	 * get trailer first, may be bogus data unless status update
d1984 3
a1986 4
#ifdef DIAGNOSTIC
	if (pkt->fp_tcode != IEEE1394_TCODE_STREAM_DATA) {
		printf("fwohci_buf_input_ppb: bad tcode: 0x%x\n",
		    pkt->fp_tcode);
d1995 1
a1995 1
		printf("fwohci_buf_input_ppb: malformed input 2: %d != %d\n",
d1999 1
a1999 1
	DPRINTFN(1, ("fwohci_buf_input_ppb: tcode=0x%x, hlen=%d, dlen=%d\n",
d2003 1
a2003 1
	pkt->fp_uio.uio_iovcnt = 0;
d2009 3
a2011 4
fwohci_handler_set(struct fwohci_softc *sc,
    int tcode, u_int32_t key1, u_int32_t key2,
    int (*handler)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *arg)
d2015 1
a2015 1
	int i, j;
d2017 1
a2017 1
	if (tcode == IEEE1394_TCODE_STREAM_DATA) {
d2039 2
a2040 2
				DPRINTF(("fwohci_handler_set: no more free "
				    "context\n"));
d2052 5
a2056 5
		case IEEE1394_TCODE_WRITE_REQ_QUAD:
		case IEEE1394_TCODE_WRITE_REQ_BLOCK:
		case IEEE1394_TCODE_READ_REQ_QUAD:
		case IEEE1394_TCODE_READ_REQ_BLOCK:
		case IEEE1394_TCODE_LOCK_REQ:
d2059 4
a2062 4
		case IEEE1394_TCODE_WRITE_RESP:
		case IEEE1394_TCODE_READ_RESP_QUAD:
		case IEEE1394_TCODE_READ_RESP_BLOCK:
		case IEEE1394_TCODE_LOCK_RESP:
d2068 1
a2068 2
		for (fh = LIST_FIRST(&fc->fc_handler); fh != NULL;
		    fh = LIST_NEXT(fh, fh_list)) {
d2077 3
a2079 1
			free(fh, M_DEVBUF);
d2081 1
a2081 1
		if (tcode == IEEE1394_TCODE_STREAM_DATA) {
d2089 1
d2091 4
a2094 2
		fh = malloc(sizeof(*fh), M_DEVBUF, M_WAITOK);
		LIST_INSERT_HEAD(&fc->fc_handler, fh, fh_list);
d2101 6
a2106 1
	DPRINTFN(1, ("fwohci_handler_set: ctx %d, tcode %x, key 0x%x, 0x%x\n",
d2109 2
a2110 1
	if (tcode == IEEE1394_TCODE_STREAM_DATA) {
a2111 2
		DPRINTFN(1, ("fwohci_handler_set: SYNC desc %ld\n",
		    (long)(TAILQ_FIRST(&fc->fc_buf)->fb_desc - sc->sc_desc)));
d2114 3
d2121 10
d2137 2
a2138 1
	int rcode;
d2148 2
a2149 1
		if (pkt.fp_tcode == OHCI_TCODE_PHY) {
d2151 7
a2157 1
			continue;
d2161 1
a2161 1
		memset(&res, 0, sizeof(res));
d2164 6
a2169 2
		for (fh = LIST_FIRST(&fc->fc_handler); fh != NULL;
		    fh = LIST_NEXT(fh, fh_list)) {
d2171 9
a2179 2
			    key1 == fh->fh_key1 &&
			    key2 == fh->fh_key2) {
d2182 2
d2189 3
a2191 3
			DPRINTFN(1, ("fwohci_arrq_input: no listener: tcode "
			    "0x%x, addr=0x%04x %08x\n", pkt.fp_tcode, key1,
			    key2));
d2196 1
a2196 1
		if (rcode != -1) 
d2200 2
a2201 2
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
	    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_WAKE);
d2220 2
a2221 2
		DPRINTFN(1, ("fwohci_arrs_input: tcode 0x%x, from 0x%04x,"
		    " tlabel 0x%x, rcode 0x%x, hlen %d, dlen %d\n",
d2224 1
a2224 2
		for (fh = LIST_FIRST(&fc->fc_handler); fh != NULL;
		    fh = LIST_NEXT(fh, fh_list)) {
d2230 3
a2232 1
				free(fh, M_DEVBUF);
d2236 2
a2237 2
		if (fh == NULL) 
			DPRINTFN(1, ("fwohci_arrs_input: no listner\n"));
d2240 2
a2241 2
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx,
	    OHCI_SUBREG_ContextControlSet, OHCI_CTXCTL_WAKE);
d2261 1
a2261 1
		/* stop dma engine before read buffer */
d2264 1
a2264 1
		DPRINTFN(5, ("ir_input %08x =>", reg));
d2269 2
a2270 1
		DPRINTFN(5, (" %08x\n", OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlClear)));
d2273 2
a2274 1
		while ((reg = OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlSet)) & OHCI_CTXCTL_ACTIVE) {
d2282 1
a2282 1
		/* rotate dma buffer */
d2286 2
a2287 1
		/* start dma engine */
d2298 2
a2299 2
		DPRINTFN(1, ("fwohci_ir_input: hdr 0x%08x, tcode 0x%0x, hlen %d"
		    ", dlen %d\n", pkt.fp_hdr[0], pkt.fp_tcode, pkt.fp_hlen,
d2309 1
a2309 1
			/* assuming pkt per buffer mode */
d2318 1
a2318 2
		for (fh = LIST_FIRST(&fc->fc_handler); fh != NULL;
		    fh = LIST_NEXT(fh, fh_list)) {
d2326 1
a2326 1
#ifdef FW_DEBUG
d2328 1
a2328 1
			DPRINTFN(1, ("fwohci_ir_input: no handler\n"));
d2330 1
a2330 1
			DPRINTFN(1, ("fwohci_ir_input: rcode %d\n", rcode));
d2332 1
a2332 1
#endif
d2355 1
a2355 1
#ifdef FW_DEBUG
d2357 2
a2358 2
#endif
	
d2363 2
a2364 2
#ifdef FW_DEBUG
	DPRINTFN(1, ("fwohci_at_output: tcode 0x%x, hlen %d, dlen %d",
d2366 1
a2366 1
	for (i = 0; i < pkt->fp_hlen/4; i++) 
d2368 10
a2377 7
	DPRINTFN(2, ("$"));
	for (ndesc = 0, iov = pkt->fp_iov;
	     ndesc < pkt->fp_uio.uio_iovcnt; ndesc++, iov++) {
		for (i = 0; i < iov->iov_len; i++)
			DPRINTFN(2, ("%s%02x", (i%32)?((i%4)?"":" "):"\n    ",
			    ((u_int8_t *)iov->iov_base)[i]));
		DPRINTFN(2, ("$"));
d2380 1
a2380 1
#endif
d2391 1
d2393 1
a2393 1
#ifdef __NetBSD__
d2402 1
d2409 1
d2421 1
d2430 1
a2430 1
	if (fc->fc_bufcnt > 50)			/*XXX*/
d2432 1
d2434 1
d2439 2
d2449 1
a2449 1
	
d2455 2
d2459 1
d2469 1
d2472 2
d2493 19
a2511 9
	memcpy(fd + 1, pkt->fp_hdr, pkt->fp_hlen);
	for (i = 0; i < ndesc - 2; i++) {
		fd = fb->fb_desc + 2 + i;
		fd->fd_flags = 0;
		fd->fd_reqcount = fb->fb_dmamap->dm_segs[i].ds_len;
		fd->fd_data = fb->fb_dmamap->dm_segs[i].ds_addr;
		fd->fd_branch = 0;
		fd->fd_status = 0;
		fd->fd_timestamp = 0;
d2516 2
a2517 2
#ifdef FW_DEBUG
	DPRINTFN(1, ("fwohci_at_output: desc %ld",
d2523 1
a2523 1
#endif
d2541 1
d2561 2
d2565 2
a2566 2
#ifdef FW_DEBUG
		DPRINTFN(1, ("fwohci_at_done: %sdesc %ld (%d)",
d2573 1
a2573 1
#endif
d2593 4
a2596 4
			memset(&pkt, 0, sizeof(pkt));
			pkt.fp_status = fd->fd_status; 
			memcpy(pkt.fp_hdr, fd + 1, sizeof(pkt.fp_hdr[0]));
			
d2604 1
a2604 1
		if (fb->fb_nseg > 2)
d2606 2
d2612 1
a2612 1
		} else if (fb->fb_m != NULL)
d2614 2
d2617 2
d2631 1
a2631 1
	    OHCI_CTXCTL_EVENT_ACK_PENDING) 
d2637 3
a2639 3
	case IEEE1394_TCODE_WRITE_REQ_QUAD:
	case IEEE1394_TCODE_WRITE_REQ_BLOCK:
		res->fp_tcode = IEEE1394_TCODE_WRITE_RESP;
d2642 2
a2643 2
	case IEEE1394_TCODE_READ_REQ_QUAD:
		res->fp_tcode = IEEE1394_TCODE_READ_RESP_QUAD;
d2651 4
a2654 4
	case IEEE1394_TCODE_READ_REQ_BLOCK:
	case IEEE1394_TCODE_LOCK_REQ:
		if (req->fp_tcode == IEEE1394_TCODE_LOCK_REQ)
			res->fp_tcode = IEEE1394_TCODE_LOCK_RESP;
d2656 1
a2656 1
			res->fp_tcode = IEEE1394_TCODE_READ_RESP_BLOCK;
d2667 1
a2667 1
 * APPLICATION LAYER SERVICES
d2671 1
a2671 1
 * Retrieve Global UID from GUID ROM
d2679 2
a2680 1
	/* Extract the Global UID
d2729 1
a2729 1
 * Initialization for Configuration ROM (no DMA context)
d2734 1
a2734 1
struct configromctx {
d2736 1
a2736 1
	int		curunit;
d2739 1
a2739 1
		int		length;
d2741 1
a2741 1
		int		refunit;
d2743 1
a2743 1
};
d2748 1
a2748 1
#define	CFR_PUT_DATA1(cfr, d)	(*(cfr)->ptr++ = (d))
d2765 1
a2765 1
} while (0 /* CONSTCOND */)
d2772 1
a2772 1
} while (0 /* CONSTCOND */)
d2779 1
a2779 1
} while (0 /* CONSTCOND */)
d2807 2
d2810 1
a2810 1
	memset(&cfr, 0, sizeof(cfr));
d2813 1
a2813 1
	/* headers */
d2820 1
a2820 1
	/* copy info_length from crc_length */
d2824 1
a2824 1
	/* root directory */
d2826 3
a2828 3
	CFR_PUT_VALUE(&cfr, 0x03, 0x00005e);	/* vendor id */
	CFR_PUT_REFER(&cfr, 0x81, 2);		/* textual descriptor offset */
	CFR_PUT_VALUE(&cfr, 0x0c, 0x0083c0);	/* node capability */
d2830 6
a2835 6
#ifdef INET
	CFR_PUT_REFER(&cfr, 0xd1, 3);		/* IPv4 unit directory */
#endif /* INET */
#ifdef INET6
	CFR_PUT_REFER(&cfr, 0xd1, 4);		/* IPv6 unit directory */
#endif /* INET6 */
d2839 2
a2840 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* textual descriptor */
	CFR_PUT_DATA1(&cfr, 0);			/* minimal ASCII */
d2850 2
a2851 2
#ifdef INET
	/* IPv4 unit directory */
d2853 5
a2857 5
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005e);	/* unit spec id */
	CFR_PUT_REFER(&cfr, 0x81, 6);		/* textual descriptor offset */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000001);	/* unit sw version */
	CFR_PUT_REFER(&cfr, 0x81, 7);		/* textual descriptor offset */
	CFR_PUT_REFER(&cfr, 0x95, 8);		/* Unit location */
d2861 2
a2862 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* textual descriptor */
	CFR_PUT_DATA1(&cfr, 0);			/* minimal ASCII */
d2867 2
a2868 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* textual descriptor */
	CFR_PUT_DATA1(&cfr, 0);			/* minimal ASCII */
a2877 2
	
#endif /* INET */
d2879 4
a2882 2
#ifdef INET6
	/* IPv6 unit directory */
d2884 3
a2886 3
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005e);	/* unit spec id */
	CFR_PUT_REFER(&cfr, 0x81, 9);		/* textual descriptor offset */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000002);	/* unit sw version */
d2888 2
a2889 2
	CFR_PUT_REFER(&cfr, 0x81, 10);		/* textual descriptor offset */
	CFR_PUT_REFER(&cfr, 0x95, 11);		/* Unit location */
d2893 2
a2894 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* textual descriptor */
	CFR_PUT_DATA1(&cfr, 0);			/* minimal ASCII */
d2899 1
a2899 1
	CFR_PUT_VALUE(&cfr, 0, 0);		/* textual descriptor */
d2910 2
a2911 2
	
#endif /* INET6 */
d2914 1
a2914 1
#ifdef FW_DEBUG
d2919 1
a2919 1
#endif /* FW_DEBUG */
d2922 1
a2922 1
	 * Make network byte order for DMA
d2938 1
a2938 1
	
d2940 2
a2941 2
	for (i = 0; i < fb->fb_off; i++) 
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQ_QUAD,
d2956 1
a2956 1
		/* alignment error */
d2963 1
a2963 1
	DPRINTFN(1, ("fwohci_configrom_input: ConfigRom[0x%04x]: 0x%08x\n", loc,
d2966 1
a2966 1
	memset(&res, 0, sizeof(res));
d2973 1
a2973 1
 * SelfID buffer (no DMA context)
d2980 2
d2983 1
a2983 1
#ifdef DIAGNOSTIC
d2989 1
a2989 1
	memset(fb->fb_buf, 0, fb->fb_dmamap->dm_segs[0].ds_len);
d3017 1
a3017 1
#ifdef FW_DEBUG
d3023 1
a3023 1
#endif /* FW_DEBUG */
d3029 1
a3029 1
			continue;	/* more pkt */
d3031 1
a3031 1
			continue;	/* external id */
d3065 1
a3065 1
		sc->sc_nodeid = 0xffff;		/* invalid */
d3071 1
a3071 1
	
d3090 1
a3090 1
 * some CSRs are handled by driver.
d3096 1
a3096 1
	static u_int32_t csr[] = { 
d3103 2
d3106 1
a3106 1
		fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQ_QUAD,
d3108 1
a3108 1
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQ_QUAD,
d3121 1
a3121 1
	 * XXX need to do special functionality other than just r/w...
d3126 1
a3126 1
		/* alignment error */
d3129 1
a3129 1
	DPRINTFN(1, ("fwohci_csr_input: CSR[0x%04x]: 0x%08x", reg,
d3131 1
a3131 1
	if (pkt->fp_tcode == IEEE1394_TCODE_WRITE_REQ_QUAD) {
d3165 1
a3165 1
	if (sc->sc_uidtbl != NULL)
d3167 4
a3170 1
#ifdef M_ZERO
d3172 2
a3173 1
	    M_NOWAIT|M_ZERO);	/* XXX M_WAITOK requires locks */
d3176 2
a3177 2
	    M_NOWAIT);	/* XXX M_WAITOK requires locks */
	bzero(sc->sc_uidtbl, sizeof(*fu) * (sc->sc_rootid + 1));
d3181 3
d3187 1
a3187 1
			memcpy(fu->fu_uid, sc->sc_sc1394.sc1394_guid, 8);
d3193 1
a3193 1
				DPRINTF(("%s: Updating nodeid to %d\n", 
d3211 2
a3212 2
	memset(&pkt, 0, sizeof(pkt));
	pkt.fp_tcode = IEEE1394_TCODE_READ_REQ_QUAD;
d3215 1
a3215 1
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) | 
d3219 1
a3219 1
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESP_QUAD, phyid,
d3224 1
a3224 1
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) | 
d3227 1
a3227 1
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESP_QUAD, phyid,
d3251 1
a3251 1
		memcpy(fu->fu_uid, res->fp_iov[0].iov_base, 4);
d3254 1
a3254 1
		memcpy(fu->fu_uid + 4, res->fp_iov[0].iov_base, 4);
d3257 1
a3257 1
#ifdef FW_DEBUG
d3259 2
a3260 2
		DPRINTFN(1, ("fwohci_uid_input: "
		    "Node %d, UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", n,
d3263 1
a3263 1
#endif
d3269 1
a3269 1
				DPRINTF(("%s: Updating nodeid to %d\n", 
d3276 1
a3276 1
			memcpy(fwa.uid, fu->fu_uid, 8);
d3283 1
a3283 1
			    config_found_sm(&sc->sc_sc1394.sc1394_dev, &fwa, 
d3292 1
a3292 1
	for (i = 0; i < sc->sc_rootid + 1; i++) {
d3322 1
d3331 2
a3332 1
	if (detach) 
d3334 1
d3349 1
a3349 1
		fwohci_uid_collect(sc); /* try to get */
d3361 1
a3361 1
			 * XXX: need timer before retransmission
d3370 1
a3370 1
 * functions to support network interface
d3378 3
a3380 3
	fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQ_BLOCK, offhi, offlo, 
	    handler ? fwohci_if_input : NULL, handler);
	fwohci_handler_set(sc, IEEE1394_TCODE_STREAM_DATA,
d3395 1
a3395 1
#ifdef FW_DEBUG
d3397 1
a3397 1
	DPRINTFN(1, ("fwohci_if_input: tcode=0x%x, dlen=%d", pkt->fp_tcode,
d3402 9
a3410 6
	for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
		iov = &pkt->fp_iov[n];
		for (i = 0; i < iov->iov_len; i++)
			DPRINTFN(2, ("%s%02x", (i%32)?((i%4)?"":" "):"\n    ",
			    ((u_int8_t *)iov->iov_base)[i]));
		DPRINTFN(2, ("$"));
d3413 1
a3413 1
#endif /* FW_DEBUG */
d3423 1
d3433 1
d3437 2
a3438 2
	memcpy(mtod(m, caddr_t), sc->sc_uidtbl[n].fu_uid, 8);
	if (pkt->fp_tcode == IEEE1394_TCODE_STREAM_DATA) {
d3445 1
a3445 1
	mtod(m, u_int8_t *)[8] = n;	/*XXX: node id for debug */
d3459 1
a3459 1
	 * it is easy to map receive buffer to external mbuf.  But it is
d3469 1
a3469 1
		memcpy(mtod(m, caddr_t) + m->m_len, iov->iov_base,
d3487 1
a3487 1
#ifdef FW_DEBUG
d3489 1
a3489 1
#endif
d3493 2
a3494 3
#ifdef FW_DEBUG
	DPRINTFN(1, ("fwohci_if_input_iso: "
	    "tcode=0x%x, chan=%d, tag=%x, dlen=%d",
d3499 9
a3507 7
	for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
		iov = &pkt->fp_iov[n];
		for (i = 0; i < iov->iov_len; i++)
			DPRINTFN(2, ("%s%02x",
			    (i%32)?((i%4)?"":" "):"\n\t",
			    ((u_int8_t *)iov->iov_base)[i]));
		DPRINTFN(2, ("$"));
d3510 1
a3510 1
#endif /* FW_DEBUG */
d3520 1
d3534 1
d3537 1
a3537 1
		memcpy(mtod(m, caddr_t), sc->sc_uidtbl[n].fu_uid, 8);
d3558 1
a3558 1
	 * it is easy to map receive buffer to external mbuf.  But it is
d3568 1
a3568 1
		memcpy(mtod(m, caddr_t) + m->m_len, iov->iov_base,
d3570 2
a3571 2
	        m->m_len += iov->iov_len;
	        len -= iov->iov_len;
d3588 1
a3588 1
#ifdef FW_DEBUG
d3590 1
a3590 1
#endif
d3610 1
a3610 1
#ifdef FW_DEBUG
d3620 1
a3620 1
#endif
d3629 1
a3629 1
		DPRINTF(("fwohci_if_output: spd (%d) is faster than %d\n",
d3634 2
a3635 2
		DPRINTF(("fwohci_if_output: maxrec (%d) is larger for spd (%d)"
		    "\n", maxrec, spd));
d3639 2
a3640 2
		DPRINTF(("fwohci_if_output: maxrec (%d) is larger than"
		    " %d\n", maxrec, sc->sc_sc1394.sc1394_max_receive));
d3644 2
a3645 2
		DPRINTF(("fwohci_if_output: maxrec (%d) is smaller than "
		    "minimum\n", maxrec));
d3651 2
a3652 2
		DPRINTF(("fwohci_if_output: packet too big: hdr %d, pktlen "
		    "%d, maxrec %d\n", hdrlen, m0->m_pkthdr.len, maxrec));
d3657 1
a3657 1
	memset(&pkt, 0, sizeof(pkt));
d3662 1
a3662 1
		/* construct GASP header */
d3668 1
a3668 1
		pkt.fp_tcode = IEEE1394_TCODE_STREAM_DATA;
d3675 1
a3675 1
		pkt.fp_tcode = IEEE1394_TCODE_WRITE_REQ_BLOCK;
d3694 1
a3694 1
		if (callback)
d3696 1
a3696 1
		else
d3698 2
d3717 2
a3718 2
 * routine since it will encapsulate retrying a region as quadlet vs. block 
 * reads and recombining all the returned data. This could also be done with a 
d3725 4
a3728 4
 * It accepts all standard ieee1394 tcodes (XXX: only a few today) and 
 * optionally will callback via a func pointer to the calling code with the 
 * resulting ACK code from the packet. If the ACK code is to be ignored (i.e. 
 * no cb) then the write routine will take care of free'ing the abuf since the 
d3746 1
a3746 1
 * which only need to register an area for a one-time operation (like a status
d3751 1
a3751 1
 
d3767 2
a3768 1
	fcb = malloc(sizeof(struct fwohci_cb), M_DEVBUF, M_WAITOK);
d3772 1
a3772 1
	
d3776 1
a3776 1
	memset(&pkt, 0, sizeof(pkt));
d3782 2
a3783 2
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQ_QUAD;
		tcode = IEEE1394_TCODE_READ_RESP_QUAD;
d3786 1
a3786 1
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQ_BLOCK;
d3788 1
a3788 1
		tcode = IEEE1394_TCODE_READ_RESP_BLOCK;
d3799 1
a3799 1
	if (rv) 
d3816 1
a3816 1
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent; 
d3821 2
a3822 1
		DPRINTF(("Packet too large: %d\n", ab->ab_length));
d3831 1
a3831 1
	memset(&pkt, 0, sizeof(pkt));
d3838 3
a3840 3
	} else 
		memcpy(&pkt.fp_uio, ab->ab_uio, sizeof(struct uio));
	
d3845 1
a3845 1
	case IEEE1394_TCODE_WRITE_RESP:
d3847 2
a3848 2
	case IEEE1394_TCODE_READ_RESP_QUAD:
	case IEEE1394_TCODE_READ_RESP_BLOCK:
d3884 3
a3886 3
	case IEEE1394_TCODE_WRITE_RESP:
	case IEEE1394_TCODE_READ_RESP_QUAD:
	case IEEE1394_TCODE_READ_RESP_BLOCK:
d3913 1
a3913 1
	
d3922 2
a3923 2
			DPRINTFN(2, ("Got status packet: 0x%02x\n",
			    (unsigned int)status));
d3928 1
a3928 1
		 * callback has been called. Clean up.
d3930 1
a3930 1
		
d3932 5
a3936 2
			if (fcb->count == 0)
				free(fcb, M_DEVBUF);
d3946 1
a3946 1
	 * Some area's (like the config rom want to be read as quadlets only.
d3956 1
a3956 1
	 * mutli_resp handle the iteration over the space.
d3960 1
a3960 1
	     (tcode == IEEE1394_TCODE_READ_REQ_BLOCK)) ||
d3962 2
a3963 2
	     (rcode == IEEE1394_RCODE_ADDRESS_ERROR)) &&
	      (tcode == IEEE1394_TCODE_READ_RESP_BLOCK))) {
d3967 1
a3967 1
		memset(&newpkt, 0, sizeof(newpkt));
d3972 1
a3972 1
		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQ_QUAD;
d3981 2
a3982 1
		rv = fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESP_QUAD,
d3993 2
a3994 1
			fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESP_QUAD,
d4014 3
d4024 1
a4024 1
					memcpy(cur, pkt->fp_iov[i].iov_base,
d4029 1
a4029 1
				memcpy(cur, pkt->fp_iov[i].iov_base,
d4031 1
a4031 1
				cur += pkt->fp_iov[i].iov_len;
d4034 1
d4036 1
a4036 1
		if (status != -1) 
d4040 1
a4040 1
				    IEEE1394_TCODE_READ_RESP_QUAD,
d4049 1
a4049 1
	
d4052 5
a4056 2
	if (fcb->count == 0)
		free(fcb, M_DEVBUF);
d4087 3
a4089 2
		memcpy(((char *)ab->ab_data + ab->ab_retlen),
		    pkt->fp_iov[0].iov_base, (ab->ab_length - ab->ab_retlen));
d4092 2
a4093 2
		memcpy(((char *)ab->ab_data + ab->ab_retlen),
		    pkt->fp_iov[0].iov_base, 4);
d4096 1
d4099 1
a4099 1
		memset(&newpkt, 0, sizeof(newpkt));
d4104 1
a4104 1
		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQ_QUAD;
d4117 1
a4117 1
		 * Bad return code.  Just give up and return what's
d4120 2
a4121 1
		rv = fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESP_QUAD,
d4124 1
a4124 1
		if (rv) 
d4130 1
a4130 1
				    IEEE1394_TCODE_READ_RESP_QUAD,
d4146 5
a4150 2
	if (fcb->count == 0)
		free(fcb, M_DEVBUF);
d4164 1
a4164 1
		DPRINTF(("Got status packet: 0x%02x\n",
d4171 1
a4171 1
		if (ab->ab_data)
d4173 6
a4178 1
		free(ab, M_1394DATA);
d4188 1
a4188 1
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent; 
d4190 4
a4193 1
	int i, j, rv;
d4198 5
d4205 2
a4206 2
	case IEEE1394_TCODE_READ_REQ_QUAD:
	case IEEE1394_TCODE_WRITE_REQ_QUAD:
d4211 2
a4212 2
			fwohci_handler_set(psc, ab->ab_tcode, high, lo, NULL,
			    NULL);
d4214 2
a4215 2
	case IEEE1394_TCODE_READ_REQ_BLOCK:
	case IEEE1394_TCODE_WRITE_REQ_BLOCK:
d4217 1
d4231 1
a4231 1
				for (i = 0; i < j; i++) 
d4235 9
d4247 1
a4247 1
			 */ 
d4249 1
a4249 1
                                ab->ab_data = (void *)1;
d4251 1
a4251 1
			if (ab->ab_cb) 
d4260 2
a4261 1
		DPRINTF(("Invalid registration tcode: %d\n", ab->ab_tcode));
d4273 1
a4273 1
	
d4293 5
d4299 1
a4299 1
	case IEEE1394_TCODE_READ_REQ_QUAD:
d4302 1
a4302 1
	case IEEE1394_TCODE_READ_REQ_BLOCK:
d4304 7
a4310 4
		if (ab->ab_data) {
			if ((addr + ab->ab_retlen) >
			    (ab->ab_addr + ab->ab_length))
				return IEEE1394_RCODE_ADDRESS_ERROR;
d4312 1
a4312 3
		} else
			if (ab->ab_retlen != ab->ab_length)
				return IEEE1394_RCODE_ADDRESS_ERROR;
d4314 1
a4314 1
	case IEEE1394_TCODE_WRITE_REQ_QUAD:
d4316 11
a4326 2
	case IEEE1394_TCODE_WRITE_REQ_BLOCK:
		if (!ab->ab_retlen) 
d4328 9
a4336 4
		if (ab->ab_data) {
			if ((addr + ab->ab_retlen) >
			    (ab->ab_addr + ab->ab_length))
				return IEEE1394_RCODE_ADDRESS_ERROR;
d4338 3
a4340 3
		} else
			if (ab->ab_retlen != ab->ab_length)
				return IEEE1394_RCODE_ADDRESS_ERROR;
d4342 1
a4342 2
		ab->ab_data = malloc(ab->ab_retlen, M_1394DATA, M_WAITOK);
		if (ab->ab_tcode == IEEE1394_TCODE_WRITE_REQ_QUAD)
d4347 3
d4351 5
a4355 1
				memcpy(cur, pkt->fp_iov[i].iov_base,
d4357 1
a4357 1
				cur += pkt->fp_iov[i].iov_len;
d4362 1
a4362 1
				    "but only %d bytes returned",
d4376 1
a4376 1
#ifdef __NetBSD__
d4385 1
a4385 1
#ifdef __OpenBSD__
d4403 14
a4416 3
	if (sc->sc_sc1394.sc1394_if != NULL)
		rv = config_detach(sc->sc_sc1394.sc1394_if, flags);
	if (rv != 0)
d4419 1
a4419 1
#ifdef __NetBSD__
d4447 2
a4448 2
	                rv = config_deactivate(sc->sc_sc1394.sc1394_if);
		break; 
d4455 1
a4455 1
#ifdef FW_DEBUG
d4460 2
a4461 2
	printf("%s: intmask=0x%08x:", sc->sc_sc1394.sc1394_dev.dv_xname,
	    intmask);
d4463 1
a4463 1
		printf(" CycleTooLong");
d4465 1
a4465 1
		printf(" UnrecoverableError");
d4467 1
a4467 1
		printf(" CycleInconsistent");
d4469 1
a4469 1
		printf(" BusReset");
d4471 1
a4471 1
		printf(" SelfIDComplete");
d4473 1
a4473 1
		printf(" LockRespErr");
d4475 1
a4475 1
		printf(" PostedWriteErr");
d4477 1
a4477 1
		printf(" ReqTxComplete(0x%04x)",
d4479 1
a4479 1
		    OHCI_SUBREG_ContextControlClear));
d4481 1
a4481 1
		printf(" RespTxComplete(0x%04x)",
d4483 1
a4483 1
		    OHCI_SUBREG_ContextControlClear));
d4485 1
a4485 1
		printf(" ARRS(0x%04x)",
d4487 1
a4487 1
		    OHCI_SUBREG_ContextControlClear));
d4489 1
a4489 1
		printf(" ARRQ(0x%04x)",
d4491 1
a4491 1
		    OHCI_SUBREG_ContextControlClear));
d4493 2
a4494 2
		printf(" IsochRx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoRecvIntEventClear));
d4496 2
a4497 2
		printf(" IsochTx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoXmitIntEventClear));
d4499 1
a4499 1
		printf(" RQPkt(0x%04x)",
d4501 1
a4501 1
		    OHCI_SUBREG_ContextControlClear));
d4503 1
a4503 1
		printf(" RSPkt(0x%04x)",
d4505 2
a4506 2
		    OHCI_SUBREG_ContextControlClear));
	printf("\n");
d4516 2
a4517 2
	printf("%s: PHY packet from %d: ",
	    sc->sc_sc1394.sc1394_dev.dv_xname, phyid);
d4520 1
a4520 1
		printf("PHY Config:");
d4522 1
a4522 1
			printf(" ForceRoot");
d4524 2
a4525 2
			printf(" Gap=%x", (val & 0x003f0000) >> 16);
		printf("\n");
d4528 1
a4528 1
		printf("Link-on\n");
d4531 1
a4531 1
		printf("SelfID:");
d4533 1
a4533 1
			printf(" #%d", (val & 0x00700000) >> 20);
d4536 4
a4539 3
				printf(" LinkActive");
			printf(" Gap=%x", (val & 0x003f0000) >> 16);
			printf(" Spd=S%d", 100 << ((val & 0x0000c000) >> 14));
d4541 1
a4541 1
				printf(" Cont");
d4543 1
a4543 1
				printf(" InitiateBusReset");
d4546 2
a4547 2
			printf(" +");
		printf("\n");
d4550 1
a4550 1
		printf("unknown: 0x%08x\n", val);
d4554 1
a4554 1
#endif /* FW_DEBUG */
@


1.4.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d4 1
a4 1
/*
d21 2
a22 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d53 1
a53 1
#ifdef	__KERNEL_RCSID
d57 2
a58 2
#define	DOUBLEBUF 0
#define	NO_THREAD 0
d60 1
a60 1
#ifdef	__NetBSD__
d68 1
a68 1
#ifdef	__NetBSD__
d77 1
a77 1
#ifdef	__OpenBSD__
d81 1
a81 1
#if	__NetBSD_Version__ >= 105010000 || !defined(__NetBSD__)
d96 1
a96 2
const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
const char * const ieee1394_power[] = { IEEE1394_POW_STRINGS };
d99 1
a99 1
int fwohci_dmamem_alloc(struct fwohci_softc *sc, int size,
a105 1
void fwohci_event_dispatch(struct fwohci_softc *);
a110 1
void fwohci_desc_free(struct fwohci_softc *);
d123 1
a124 1
void fwohci_buf_stop_tx(struct fwohci_softc *);
d139 1
a139 5
    u_int32_t, int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *);
int  fwohci_block_handler_set(struct fwohci_softc *, int, u_int32_t, u_int32_t,
    u_int32_t, int, int (*)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *);
d187 1
a187 1
#ifdef	__NetBSD__
d194 1
a194 1
#ifdef	FWOHCI_DEBUG
d200 7
a206 28
#include <sys/syslog.h>
extern int log_open;
int fwohci_oldlog;
#define	DPRINTF(x)	if (fwohcidebug) do {				\
	fwohci_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwohci_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (fwohcidebug>(n)) do {			\
	fwohci_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwohci_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	fwohcidebug = 0;
int	fwintr = 0;
caddr_t	fwptr = 0;
int	fwlen = 0;
struct fwohci_buf *fwbuf = NULL;
#else	/* FWOHCI_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! FWOHCI_DEBUG */
d208 1
a208 1
#ifdef	__OpenBSD__
d223 1
a223 1
#ifdef	__NetBSD__
d234 1
a234 1
	 * Wait for reset completion.
d243 1
a243 2
	/*
	 * What dialect of OHCI is this device ?
d263 1
a263 2
	/*
	 * Get the maximum link speed and receive size.
d274 2
a275 3

	/*
	 * MaxRec is encoded as log2(max_rec_octets)-1
d293 1
a293 1

d297 1
a297 1
	error = fwohci_dmamem_alloc(sc, OHCI_CONFIG_SIZE,
d303 2
a304 5
	MALLOC(sc->sc_dying, int *, sizeof(int), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", sc->sc_dying);
	DPRINTF(("%s: sc_dying 0x%08x\n", __func__, (u_int32_t)sc->sc_dying));
	*sc->sc_dying = 0;
	sc->sc_nodeid = 0xFFFF;		/* Invalid. */
d306 1
a306 1
#ifdef	__NetBSD__
d311 2
a312 2
	else
		/* Late binding, threads already running. */
d332 2
a333 2
	retval = fwohci_handler_set(sc, IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK,
	    channel, tag, 0, fwohci_if_input_iso, handler);
a350 1
#if 1
a351 3
#else
	int progress = (sc->sc_intmask != 0);
#endif
a353 8
	splassert(IPL_BIO);

#ifdef	FWOHCI_DEBUG
	//DPRINTFN(3,("%s:  in(%d)\n", __func__, fwintr));
	fwintr++;
#endif	/* FWOHCI_DEBUG */

#if 1
a354 1
#endif
d359 1
a359 1
		 * cleared. That can't get cleared until the selfid
d366 1
a366 1
		if ((intmask == 0xFFFFFFFF) || (intmask == 0) ||
d368 2
a369 10
		       (sc->sc_intmask & OHCI_Int_BusReset))) {

			if (intmask == 0xFFFFFFFF)
				config_detach(((struct device *)sc)
				    ->dv_parent, 0);

			if (progress) {
#if	NO_THREAD
				fwohci_event_dispatch(sc);
#else	/* NO_THREAD */
d371 1
a371 9
#endif	/* NO_THREAD */
			}

#ifdef	FWOHCI_DEBUG
			--fwintr;
			//DPRINTFN(3,("%s: out(%d)\n", __func__, fwintr));
#endif	/* FWOHCI_DEBUG */

			return (progress);
a372 10
#if 1
		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
		    intmask & ~OHCI_Int_BusReset);
#else
		DPRINTFN(2,("%s: IntEventClear(0x%08x) IntMaskClear(0x%08x)\n",
		    __func__,
		    intmask & ~OHCI_Int_BusReset,
		    intmask & ~OHCI_Int_BusReset & ~OHCI_Int_MasterEnable));
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskClear,
		    intmask & ~OHCI_Int_BusReset & ~OHCI_Int_MasterEnable);
d375 3
a378 4
#ifdef	FWOHCI_DEBUG
		if (fwohcidebug > 1)
			fwohci_show_intr(sc, intmask);
#endif	/* FWOHCI_DEBUG */
d383 2
a384 2
			 * all asynchronous transmit must be stopped before
			 * clearing BusReset. Moreover, the BusReset
d386 1
a386 1
			 * SelfID phase. Thus we turned off interrupt mask
a389 7
#if 0
			DPRINTFN(2,("%s: IntMaskSet(0x%08x)"
			    " IntMaskClear(0x%08x)\n", __func__,
			    intmask & ~OHCI_Int_BusReset, OHCI_Int_BusReset));
			OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
			    intmask & ~OHCI_Int_BusReset);
#endif
a398 1
#if 1
a399 4
#else
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoXmitIntEventClear,
			    sc->sc_isotxrst);
#endif
d402 1
a402 1
#if	NO_THREAD
d405 1
a405 1
#endif	/* NO_THREAD */
a407 1
#if 1
d409 1
a409 5
#else
			OHCI_CSR_WRITE(sc, OHCI_REG_IsoRecvIntEventClear,
			    sc->sc_isorxrst);
#endif
#if	NO_THREAD
d411 2
a412 4
				if ((iso & (1<<i)) &&
				    sc->sc_ctx_ir[i] != NULL) {
					if (sc->sc_ctx_ir[i]->fc_type ==
					    FWOHCI_CTX_ISO_SINGLE) {
d418 1
a418 2
					    0, sizeof(struct fwohci_desc) *
					    sc->sc_descsize,
d428 1
a428 1
				/* All iso intr is pure isochronous. */
d431 1
a431 1
#else	/* NO_THREAD */
d433 1
a433 1
#endif	/* NO_THREAD */
a437 1
#if 1
a438 1
#endif
a439 1
#if 1
a440 8
#else
#ifdef	FWOHCI_DEBUG
	--fwintr;
	//DPRINTF(("%s: out(%d)\n", __func__, fwintr));
#endif	/* FWOHCI_DEBUG */

	return (progress);
#endif
d448 1
a448 1
#ifdef	__NetBSD__
d469 1
a469 1
	 * Allocate descriptors.
d478 1
a478 1
	 * Enable Link Power.
d484 1
a484 1
	 * Allocate DMA Context.
d490 4
a493 4
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrq, 0,
	    OHCI_CTX_ASYNC_TX_REQUEST, FWOHCI_CTX_ASYNC);
	fwohci_ctx_alloc(sc, &sc->sc_ctx_atrs, 0,
	    OHCI_CTX_ASYNC_TX_RESPONSE, FWOHCI_CTX_ASYNC);
a495 1
	MPRINTF("malloc(DEVBUF)", sc->sc_ctx_ir);
d500 1
a500 1
	 * Allocate buffer for configuration ROM and SelfID buffer.
d505 1
a505 1
#ifdef	__NetBSD__
d516 1
a516 1
	 * Establish hooks for shutdown and suspend/resume.
a526 10
	printf("%s: event thread exited\n", __func__);

	if (sc->sc_uidtbl != NULL) {
		free(sc->sc_uidtbl, M_DEVBUF);
		MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
		sc->sc_uidtbl = NULL;
	}

	fwohci_buf_free(sc, &sc->sc_buf_selfid);
	fwohci_buf_free(sc, &sc->sc_buf_cnfrom);
a527 13
	free(sc->sc_ctx_ir, M_DEVBUF);
	MPRINTF("free(DEVBUF)", sc->sc_ctx_ir);
	sc->sc_ctx_ir = NULL;	/* XXX */
	fwohci_ctx_free(sc, sc->sc_ctx_atrs);
	fwohci_ctx_free(sc, sc->sc_ctx_atrq);
	fwohci_ctx_free(sc, sc->sc_ctx_arrs);
	fwohci_ctx_free(sc, sc->sc_ctx_arrq);

	fwohci_desc_free(sc);

	DPRINTF(("%s: waking up... 0x%08x\n", __func__,
	    (u_int32_t)sc->sc_dying));
	wakeup(sc->sc_dying);
d534 2
a535 5
	int s;
#if !	NO_THREAD
	int i;
	uint32_t intmask, iso;
#endif	/* NO_THREAD */
d545 1
a545 1
	/* Initial Bus Reset. */
d549 1
a549 2
	while (! *sc->sc_dying) {
#if !	NO_THREAD
a552 4
#endif	/* NO_THREAD */
#if 1
			tsleep(fwohci_event_thread, PZERO, "fwohciev", 8);
#else
a553 2
#endif
#if !	NO_THREAD
a558 2
		DPRINTFN(2, ("%s: treating interrupts 0x%08x\n", __func__,
		    intmask));
a560 1
//			s = splbio();
a561 1
//			splx(s);
a563 1
				MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
d567 1
a567 1
#ifdef	__NetBSD__
d577 1
a577 1
			sc->sc_nodeid = 0xFFFF;	/* Indicate invalid. */
d588 1
a588 1
#ifdef	__NetBSD__
a593 1
//				s = splbio();
a594 1
//				splx(s);
d598 1
a598 2
		if (intmask & OHCI_Int_ReqTxComplete) {
//			s = splbio();
d600 1
a600 4
//			splx(s);
		}
		if (intmask & OHCI_Int_RespTxComplete) {
//			s = splbio();
d602 1
a602 3
//			splx(s);
		}
		if (intmask & OHCI_Int_RQPkt) {
d604 1
a604 2
		}
		if (intmask & OHCI_Int_RSPkt) {
a605 1
		}
a618 101
#if 0
		DPRINTF(("%s: IntMaskSet(0x%08x)\n",
		    __func__, intmask & ~OHCI_Int_BusReset));
		s = splbio();
//		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
//		    intmask & ~OHCI_Int_BusReset);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
		    intmask & ~OHCI_Int_BusReset);
		splx(s);
#endif
#endif	/* NO_THREAD */
	}
}

#if	NO_THREAD
void
fwohci_event_dispatch(struct fwohci_softc *sc)
{
	int i, s;
	u_int32_t intmask, iso;

	splassert(IPL_BIO);
	intmask = sc->sc_intmask;
	if (intmask == 0)
		return;

	sc->sc_intmask = 0;
	s = spl0();
	DPRINTFN(2, ("%s: treating interrupts 0x%08x\n", __func__, intmask));

	if (intmask & OHCI_Int_BusReset) {
//		s = splbio();
		fwohci_buf_stop_tx(sc);
//		splx(s);
		if (sc->sc_uidtbl != NULL) {
			free(sc->sc_uidtbl, M_DEVBUF);
			MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
			sc->sc_uidtbl = NULL;
		}

#ifdef	__NetBSD__
		callout_reset(&sc->sc_selfid_callout,
		    OHCI_SELFID_TIMEOUT,
		    (void (*)(void *))fwohci_phy_busreset, sc);
#else
		timeout_set(&sc->sc_selfid_callout,
		    (void (*)(void *))fwohci_phy_busreset, sc);
		timeout_add(&sc->sc_selfid_callout,
		    OHCI_SELFID_TIMEOUT);
#endif
		sc->sc_nodeid = 0xFFFF;	/* Indicate invalid. */
		sc->sc_rootid = 0;
		sc->sc_irmid = IEEE1394_BCAST_PHY_ID;
	}
	if (intmask & OHCI_Int_SelfIDComplete) {
		splx(s);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
		    OHCI_Int_BusReset);
		OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet,
		    OHCI_Int_BusReset);
		s = spl0();
#ifdef	__NetBSD__
		callout_stop(&sc->sc_selfid_callout);
#else
		timeout_del(&sc->sc_selfid_callout);
#endif
		if (fwohci_selfid_input(sc) == 0) {
//			s = splbio();
			fwohci_buf_start_rx(sc);
//			splx(s);
			fwohci_uid_collect(sc);
		}
	}
	if (intmask & OHCI_Int_ReqTxComplete) {
//		s = splbio();
		fwohci_at_done(sc, sc->sc_ctx_atrq, 0);
//		splx(s);
	}
	if (intmask & OHCI_Int_RespTxComplete) {
//		s = splbio();
		fwohci_at_done(sc, sc->sc_ctx_atrs, 0);
//		splx(s);
	}
	if (intmask & OHCI_Int_RQPkt) {
		fwohci_arrq_input(sc, sc->sc_ctx_arrq);
	}
	if (intmask & OHCI_Int_RSPkt) {
		fwohci_arrs_input(sc, sc->sc_ctx_arrs);
	}
	if (intmask & OHCI_Int_IsochRx) {
		splx(s);
		iso = sc->sc_iso;
		sc->sc_iso = 0;
		s = spl0();
		for (i = 0; i < sc->sc_isoctx; i++) {
			if ((iso & (1 << i)) &&
			    sc->sc_ctx_ir[i] != NULL) {
				fwohci_ir_input(sc, sc->sc_ctx_ir[i]);
				sc->sc_isocnt.ev_count++;
			}
		}
a619 10
#if 0
	DPRINTF(("%s: IntMaskSet(0x%08x)\n",
	    __func__, intmask & ~OHCI_Int_BusReset));
	s = splbio();
//	OHCI_CSR_WRITE(sc, OHCI_REG_IntEventClear,
//	    intmask & ~OHCI_Int_BusReset);
	OHCI_CSR_WRITE(sc, OHCI_REG_IntMaskSet, intmask & ~OHCI_Int_BusReset);
	splx(s);
#endif
	splx(s);
a620 2
#endif	/* NO_THREAD */

d624 1
a624 1
fwohci_dmamem_alloc(struct fwohci_softc *sc, int size, int alignment,
a634 1
	MPRINTF("bus_dmamem_alloc", segs->ds_addr);
a646 2
	MPRINTF("bus_dmamap_create", mapp);

a656 1
		MPRINTF("bus_dmamem_free", segs->ds_addr);
a679 2
	splassert(IPL_BIO);

a691 1
	DELAY(100000);
d694 1
a694 1
	 * First, initialize CSRs with undefined value to default settings.
d698 1
a698 1
#if 1
a699 1
	val |= OHCI_BusOptions_PMC;
d702 1
a703 1
#endif
a722 1
#if 0
a723 3
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_ATRetries, 0xFFFF0FFF);	/*XXX*/
#endif
d725 1
a725 1
	/* Clear receive filter. */
a729 3
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
	    OHCI_HCControl_ProgramPhyEnable);
#if 0
d731 1
a731 5
	    OHCI_HCControl_APhyEnhanceEnable);
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlSet,
	    OHCI_HCControl_APhyEnhanceEnable);
#endif
a734 3
#else
	OHCI_CSR_WRITE(sc, OHCI_REG_HCControlClear,
	    OHCI_HCControl_NoByteSwapData);
d752 1
a752 1
	 * Start the receivers.
d773 1
a773 1
#ifdef	__NetBSD__
a787 3
	int s;

	//splassert(IPL_BIO);
d789 1
a789 1
#ifdef	__NetBSD__
d794 1
a794 1
	/* Disable all interrupt. */
a797 1
	s = splbio();
a801 1
	splx(s);
d809 1
a809 1
 * COMMON FUNCTIONS.
d813 1
a813 1
 * Read the PHY Register.
a820 2
	//splassert(IPL_BIO);

d823 1
a823 1
	    OHCI_BITSET(reg, OHCI_PhyControl_RegAddr));
d825 2
a826 3
		val = OHCI_CSR_READ(sc, OHCI_REG_PhyControl);
		if (!(val & OHCI_PhyControl_RdReg) &&
		    (val & OHCI_PhyControl_RdDone))
d830 2
a831 1
	return (OHCI_BITVAL(val, OHCI_PhyControl_RdData));
d835 1
a835 1
 * Write the PHY Register.
a841 2
	//splassert(IPL_BIO);

d843 2
a844 2
	    OHCI_BITSET(reg, OHCI_PhyControl_RegAddr) |
	    OHCI_BITSET(val, OHCI_PhyControl_WrData));
d854 1
a854 1
 * Initiate Bus Reset.
a861 2
	//splassert(IPL_BIO);

d866 1
a866 1
#ifdef	__NetBSD__
d872 3
a874 3
	val = (val & 0x80) |			/* Preserve RHB (force root). */
	    0x40 |				/* Initiate Bus Reset. */
	    0x3F;				/* Default GAP count. */
d880 1
a880 1
 * PHY Packet.
d889 1
a889 1
		if (val == 0 && ((*pkt->fp_trail & 0x001F0000) >> 16) ==
d891 1
a891 1
			DPRINTFN(1, ("%s: BusReset: 0x%08x\n", __func__,
d900 2
a901 2
#ifdef	FWOHCI_DEBUG
	if (fwohcidebug > 1)
d903 1
a903 1
#endif	/* FWOHCI_DEBUG */
d915 1
a915 1
	 * Allocate descriptor buffer.
d923 1
a923 1
#ifdef	M_ZERO
a924 1
	MPRINTF("malloc(DEVBUF)", sc->sc_descmap);
a926 1
	MPRINTF("malloc(DEVBUF)", sc->sc_descmap);
a929 12
#if 1	/* XXX Added when reorganizing dmamap stuff... */
	sc->sc_dnseg = 1;
#endif

	if ((error = bus_dmamap_create(sc->sc_dmat, dsize, sc->sc_dnseg,
	    dsize, 0, BUS_DMA_WAITOK, &sc->sc_ddmamap)) != 0) {
		printf("%s: unable to create descriptor buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname, error);
		goto fail_0;
	}
	MPRINTF("bus_dmamap_create", sc->sc_ddmamap);

d931 1
a931 1
	    &sc->sc_dseg, 1, &sc->sc_dnseg, BUS_DMA_WAITOK)) != 0) {
d934 1
a934 1
		goto fail_1;
a935 1
	MPRINTF("bus_dmamem_alloc", sc->sc_dseg.ds_addr);
d942 7
a951 1
#if 0
a953 4
#else
	if ((error = bus_dmamap_load_raw(sc->sc_dmat, sc->sc_ddmamap,
	    &sc->sc_dseg, sc->sc_dnseg, dsize, BUS_DMA_WAITOK)) != 0) {
#endif
d962 2
d965 1
a965 1
  fail_2:
a966 4
	MPRINTF("bus_dmamem_free", sc->sc_dseg.ds_addr);
  fail_1:
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	MPRINTF("bus_dmamap_destroy", sc->sc_ddmamap);
a970 17
void
fwohci_desc_free(struct fwohci_softc *sc)
{
	int dsize = sizeof(struct fwohci_desc) * sc->sc_descsize;

	bus_dmamap_unload(sc->sc_dmat, sc->sc_ddmamap);
	bus_dmamem_unmap(sc->sc_dmat, (caddr_t)sc->sc_desc, dsize);
	bus_dmamem_free(sc->sc_dmat, &sc->sc_dseg, sc->sc_dnseg);
	MPRINTF("bus_dmamem_free", sc->sc_dseg.ds_addr);
	bus_dmamap_destroy(sc->sc_dmat, sc->sc_ddmamap);
	MPRINTF("bus_dmamap_destroy", sc->sc_ddmamap);

	free(sc->sc_descmap, M_DEVBUF);
	MPRINTF("free(DEVBUF)", sc->sc_descmap);
	sc->sc_descmap = NULL;	/* XXX */
}

a975 2
	assert(ndesc > 0);

a994 2
	assert(ndesc > 0);

d997 1
a997 1
#ifdef	DIAGNOSTIC
d1006 1
a1006 1
 * Asynchronous/Isochronous Transmit/Receive Context.
d1020 2
a1021 3
#ifdef	M_ZERO
	MALLOC(fc, struct fwohci_ctx *, sizeof(*fc), M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(DEVBUF)", fc);
d1023 1
a1023 2
	MALLOC(fc, struct fwohci_ctx *, sizeof(*fc), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", fc);
d1029 2
a1030 4
#ifdef	M_ZERO
	fc->fc_buffers = fb = malloc(sizeof(*fb) * bufcnt,
	    M_DEVBUF, M_WAITOK|M_ZERO);
	MPRINTF("malloc(DEVBUF)", fc->fc_buffers);
a1032 1
	MPRINTF("malloc(DEVBUF)", fc->fc_buffers);
a1035 3
	if (bufcnt == 0)		/* Asynchronous transmit... */
		goto ok;

d1037 1
a1037 1
	TAILQ_INIT(&fc->fc_buf2);	/* For isochronous. */
a1055 3
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
a1060 3
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
d1075 2
a1076 2
			    (caddr_t)fd - (caddr_t)sc->sc_desc,
			    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
d1083 2
a1084 2
			    (caddr_t)fd - (caddr_t)sc->sc_desc,
			    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
a1087 1
    ok:
d1099 1
a1099 3
	FREE(fc, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", fc);
	fc = NULL;	/* XXX */
d1121 1
a1121 1
		    fh->fh_key3, NULL, NULL);
d1128 1
a1128 1
#if	DOUBLEBUF
d1135 1
a1135 1
#endif	/* DOUBLEBUF */
d1137 1
a1137 5
	MPRINTF("free(DEVBUF)", fc->fc_buffers);
	fc->fc_buffers = NULL;	/* XXX */
	FREE(fc, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", fc);
	fc = NULL;	/* XXX */
d1148 1
a1148 6
	//splassert(IPL_BIO);

	TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
a1153 3
		bus_dmamap_sync(sc->sc_dmat, sc->sc_ddmamap,
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
d1157 1
a1157 1
	TAILQ_FOREACH(fb, &fc->fc_buf2, fb_list) {
d1159 2
a1160 2
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_PREWRITE);
d1167 2
a1168 2
		    (caddr_t)fd - (caddr_t)sc->sc_desc,
		    sizeof(struct fwohci_desc), BUS_DMASYNC_POSTWRITE);
a1176 1
		MPRINTF("OHCI_SUBREG_CommandPtr(SYNC_RX)", fb->fb_daddr);
a1194 1
		MPRINTF("OHCI_SUBREG_CommandPtr(ASYNC)", fb->fb_daddr);
d1199 1
a1199 1
 * DMA data buffer.
a1205 12
	if (!fb->fb_nseg)
		fb->fb_nseg = 1;

	if ((error = bus_dmamap_create(sc->sc_dmat, PAGE_SIZE, fb->fb_nseg,
	    PAGE_SIZE, 0, BUS_DMA_WAITOK, &fb->fb_dmamap)) != 0) {
		printf("%s: unable to create buffer DMA map, "
		    "error = %d\n", sc->sc_sc1394.sc1394_dev.dv_xname,
		    error);
		goto fail_0;
	}
	MPRINTF("bus_dmamap_create", fb->fb_dmamap);

d1210 1
a1210 1
		goto fail_1;
a1211 1
	MPRINTF("bus_dmamem_alloc", fb->fb_seg.ds_addr);
d1214 1
a1214 2
	    fb->fb_nseg, PAGE_SIZE, &fb->fb_buf,
	    BUS_DMA_COHERENT | BUS_DMA_WAITOK)) != 0) {
d1217 8
a1227 1
#if 0
a1229 4
#else
	if ((error = bus_dmamap_load_raw(sc->sc_dmat, fb->fb_dmamap,
	    &fb->fb_seg, fb->fb_nseg, PAGE_SIZE, BUS_DMA_WAITOK)) != 0) {
#endif
d1240 2
d1243 1
a1243 1
  fail_2:
a1244 4
	MPRINTF("bus_dmamem_free", fb->fb_seg.ds_addr);
  fail_1:
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
	MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
d1254 1
a1256 3
	MPRINTF("bus_dmamem_free", fb->fb_seg.ds_addr);
	bus_dmamap_destroy(sc->sc_dmat, fb->fb_dmamap);
	MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
a1263 2
	//splassert(IPL_BIO);

a1283 2
//	splassert(IPL_BIO);

a1299 2
//	splassert(IPL_BIO);

a1330 2
	//splassert(IPL_BIO);

d1350 1
a1350 1
			if (fc->fc_type != FWOHCI_CTX_ASYNC) {
d1370 3
a1372 2
		/* Cleaning buffer. */
		TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
d1376 2
a1377 2

		/* Rotating buffer. */
d1386 2
a1387 2
fwohci_buf_pktget(struct fwohci_softc *sc, struct fwohci_buf **fbp,
    caddr_t *pp, int reqlen)
d1391 1
a1391 4
	int bufend, len = reqlen;
#ifdef	FWOHCI_DEBUG
	int i;
#endif	/* FWOHCI_DEBUG */
d1394 1
a1394 1
again:
d1396 3
a1398 3
	DPRINTFN(1, ("%s: desc %ld, off %d, req %d, res %d, len %d, avail %d",
	    __func__, (long)(fd - sc->sc_desc), fb->fb_off, fd->fd_reqcount,
	    fd->fd_rescount, len,
d1402 1
a1402 1
		DPRINTFN(5, ("\n\tbuf %08x finish req %d res %d off %d",
d1407 1
a1407 1
			if (fb != TAILQ_END(fb))
a1415 9

#ifdef	FWOHCI_DEBUG
	for (i=0; i < (roundup(len, 4) / 4); i++) {
		if ((i % 8) == 0) DPRINTFN(5, ("\n   "));
		DPRINTFN(5, (" %08x",
		    ((u_int32_t *)(fb->fb_buf + fb->fb_off))[i]));
	}
#endif	/* FWOHCI_DEBUG */
	DPRINTF(("\n"));
d1429 1
a1429 1
	bzero(pkt, sizeof(*pkt));
d1434 1
a1434 1
	/* Get first quadlet. */
d1439 2
a1440 1
		DPRINTFN(1, ("%s: no input for %d\n", __func__, fc->fc_ctx));
d1443 2
a1444 2
	pkt->fp_hdr[0] = *(u_int32_t *)p;	/* XXX Alignment !!! */
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000F0) >> 4;
d1446 2
a1447 2
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
d1451 1
a1451 1
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
d1455 4
a1458 4
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
	case IEEE1394_TCODE_LOCK_REQUEST:
	case IEEE1394_TCODE_LOCK_RESPONSE:
d1461 2
a1462 2
	case IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK:
#ifdef	DIAGNOSTIC
d1467 1
a1467 1
			pkt->fp_dlen = (pkt->fp_hdr[0] >> 16) & 0xFFFF;
d1471 1
a1471 1
#ifdef	DIAGNOSTIC
d1473 1
a1473 1
			printf("%s: bad tcode: STREAM_DATA\n", __func__);
d1483 1
a1483 1
	/* Get header. */
d1487 1
a1487 1
			printf("%s: malformed input 1: %d\n", __func__,
d1491 1
a1491 7
#ifdef	FWOHCI_DEBUG
		fwptr = p; fwlen = len; fwbuf = fb;
#endif	/* FWOHCI_DEBUG */
		bcopy(p, (caddr_t)pkt->fp_hdr + count, len);
#ifdef	FWOHCI_DEBUG
		fwptr = NULL; fwlen = 0; fwbuf = NULL;
#endif	/* FWOHCI_DEBUG */
d1495 1
a1495 1
	    pkt->fp_tcode != IEEE1394_TCODE_READ_REQUEST_DATABLOCK)
d1497 1
a1497 1
	DPRINTFN(1, ("%s: tcode=0x%x, hlen=%d, dlen=%d\n", __func__,
d1500 1
a1500 1
	/* Get data. */
d1503 1
a1503 1
	while (i < 6 && count < pkt->fp_dlen) {
d1508 1
a1508 1
			printf("%s: malformed input 2: %d\n", __func__,
d1518 1
a1518 13
	if (count < pkt->fp_dlen) {	/* Eat the remainder of the packet. */
		printf("%s: %d iov exhausted, %d bytes not gotten\n",
		    __func__, i, pkt->fp_dlen - count);
		while (count < pkt->fp_dlen) {
			len = fwohci_buf_pktget(sc, &fb,
			    (caddr_t *)&pkt->fp_trail,
			    ((pkt->fp_dlen - count) > sizeof(*pkt->fp_trail)) ?
			    sizeof(*pkt->fp_trail) : (pkt->fp_dlen - count));
			count += len;
		}
	}

	/* Get trailer. */
d1522 1
a1522 1
		printf("%s: malformed input 3: %d\n", __func__,
d1542 1
a1542 1
	bzero(pkt, sizeof(*pkt));
d1547 3
a1549 1
	TAILQ_FOREACH(fb, &fc->fc_buf, fb_list) {
a1552 3
	if (fb == NULL)
		return 0;

d1563 1
a1563 1
		printf("%s: malformed input 1: %d\n", __func__, len);
d1568 1
a1568 1
	 * Get trailer first, may be bogus data unless status update
d1572 1
a1572 1
	*pkt->fp_trail = (*pkt->fp_trail & 0xFFFF) | (fd->fd_status << 16);
d1574 5
a1578 4
	pkt->fp_tcode = (pkt->fp_hdr[0] & 0x000000F0) >> 4;
#ifdef	DIAGNOSTIC
	if (pkt->fp_tcode != IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		printf("%s: bad tcode: 0x%x\n", __func__, pkt->fp_tcode);
d1587 1
a1587 1
		printf("%s: malformed input 2: %d != %d\n", __func__,
d1591 1
a1591 1
	DPRINTFN(1, ("%s: tcode=0x%x, hlen=%d, dlen=%d\n", __func__,
d1595 1
a1595 1
	pkt->fp_uio.uio_iovcnt = 1;
d1601 2
a1602 2
fwohci_handler_set(struct fwohci_softc *sc, int tcode,
    u_int32_t key1, u_int32_t key2, u_int32_t key3,
d1608 1
a1608 1
	int i, j, s;
d1610 1
a1610 1
	if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
d1632 2
a1633 2
				DPRINTF(("%s: no more free context\n",
				    __func__));
d1645 5
a1649 5
		case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
		case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		case IEEE1394_TCODE_READ_REQUEST_QUADLET:
		case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
		case IEEE1394_TCODE_LOCK_REQUEST:
d1652 4
a1655 4
		case IEEE1394_TCODE_WRITE_RESPONSE:
		case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
		case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
		case IEEE1394_TCODE_LOCK_RESPONSE:
d1661 2
a1662 1
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
d1664 1
a1664 3
			    fh->fh_key1 == key1 &&
			    fh->fh_key2 == key2 &&
			    fh->fh_key3 == key3)
d1671 1
a1671 3
			FREE(fh, M_DEVBUF);
			MPRINTF("FREE(DEVBUF)", fh);
			fh = NULL;	/* XXX */
d1673 1
a1673 1
		if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
a1678 3
		DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x, 0x%x [NULL]\n",
		    __func__, fc->fc_ctx, tcode, key1, key2, key3));

a1680 1
	s = splbio();
d1682 2
a1683 4
		MALLOC(fh, struct fwohci_handler *, sizeof(*fh),
		    M_DEVBUF, M_WAITOK);
		MPRINTF("MALLOC(DEVBUF)", fh);
		bzero(fh, sizeof(*fh));
a1687 1
	fh->fh_key3 = key3;
d1690 2
d1693 1
a1693 9
	if (fh->fh_list.le_prev == NULL)
		LIST_INSERT_HEAD(&fc->fc_handler, fh, fh_list);
	splx(s);

	DPRINTFN(1, ("%s: ctx %d, tcode %x, key 0x%x, 0x%x, 0x%x [%08x]\n",
	    __func__, fc->fc_ctx, tcode, key1, key2, key3, (u_int32_t)handler));

	if (tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
		s = splbio();
d1695 2
a1698 3
		splx(s);
		DPRINTFN(1, ("%s: SYNC desc %ld\n", __func__,
		    (long)(TAILQ_FIRST(&fc->fc_buf)->fb_desc - sc->sc_desc)));
a1702 11
int
fwohci_block_handler_set(struct fwohci_softc *sc, int tcode,
    u_int32_t key1, u_int32_t key2, u_int32_t key3, int len,
    int (*handler)(struct fwohci_softc *, void *, struct fwohci_pkt *),
    void *arg)
{
	u_int32_t key3n = (key3 & 0xFFFF) | ((len & 0xFFFF) << 16);

	return (fwohci_handler_set(sc, tcode, key1, key2, key3n, handler, arg));
}

d1704 1
a1704 1
 * Asynchronous Receive Requests input frontend.
d1709 1
a1709 2
	u_int16_t srcid, datalen = 0;
	int rcode, tlabel;
d1719 1
a1719 2
		switch(pkt.fp_tcode) {
		case OHCI_TCODE_PHY:
d1721 1
a1721 7
			continue; break;
		case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
			datalen = pkt.fp_dlen;
			break;
		case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
			datalen = pkt.fp_hdr[3] >> 16;
			break;
d1723 1
a1723 1
		key1 = pkt.fp_hdr[1] & 0xFFFF;
d1725 1
a1725 1
		bzero(&res, sizeof(res));
d1728 2
a1729 6
		srcid = pkt.fp_hdr[1] >> 16;
		tlabel = (pkt.fp_hdr[0] & 0x0000FC00) >> 10;
		DPRINTFN(1, ("%s: tcode 0x%x, from 0x%04x, tlabel 0x%x, "
		    "hlen %d, dlen %d\n", __func__, pkt.fp_tcode,
		    srcid, tlabel, pkt.fp_hlen, pkt.fp_dlen));
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
d1731 2
a1732 12
			    ((fh->fh_key3 & 0xFFFF) == OHCI_NodeId_NodeNumber ||
			     (srcid & OHCI_NodeId_NodeNumber) ==
			     (fh->fh_key3 & 0xFFFF)) &&
			    ((key1 == fh->fh_key1 && key2 == fh->fh_key2) ||
			     (datalen && key1 == fh->fh_key1 &&
			      key2 >= fh->fh_key2 &&
			      (key2 + datalen) <=
			       (fh->fh_key2 + (fh->fh_key3 >> 16)))))
			{
				DPRINTFN(5, ("%s: handler 0x%08x(0x%08x)\n",
				    __func__, (u_int32_t)(*fh->fh_handler),
				    (u_int32_t)(fh->fh_handarg)));
a1734 2
				DPRINTFN(5, ("%s:  --> rcode %d\n", __func__,
				    rcode));
d1740 3
a1742 3
			DPRINTFN(1, ("%s: no listener: tcode 0x%x, "
			    "addr=0x%04x%08x\n", __func__, pkt.fp_tcode,
			    key1, key2));
d1744 1
a1744 1
		if (((*pkt.fp_trail & 0x001F0000) >> 16) !=
d1747 1
a1747 1
		if (rcode != -1)
d1751 2
a1752 2
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlSet,
	    OHCI_CTXCTL_WAKE);
d1769 4
a1772 4
		rcode = (pkt.fp_hdr[1] & 0x0000F000) >> 12;
		tlabel = (pkt.fp_hdr[0] & 0x0000FC00) >> 10;
		DPRINTFN(1, ("%s: tcode 0x%x, from 0x%04x, tlabel 0x%x, "
		    "rcode 0x%x, hlen %d, dlen %d\n", __func__,
d1775 2
a1776 1
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
d1782 1
a1782 3
				FREE(fh, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", fh);
				fh = NULL;	/* XXX */
d1786 2
a1787 2
		if (fh == NULL)
			DPRINTFN(1, ("%s: no listener\n", __func__));
d1790 2
a1791 2
	OHCI_ASYNC_DMA_WRITE(sc, fc->fc_ctx, OHCI_SUBREG_ContextControlSet,
	    OHCI_CTXCTL_WAKE);
d1811 1
a1811 1
		/* Stop dma engine before read buffer. */
d1814 1
a1814 1
		DPRINTFN(5, ("%s: %08x =>", __func__, reg));
d1819 1
a1819 2
		DPRINTFN(5, (" %08x\n", OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlClear)));
d1822 1
a1822 2
		while ((reg = OHCI_SYNC_RX_DMA_READ(sc, fc->fc_ctx,
		    OHCI_SUBREG_ContextControlSet)) & OHCI_CTXCTL_ACTIVE) {
d1830 1
a1830 1
		/* Rotate dma buffer. */
d1834 1
a1834 2
		MPRINTF("OHCI_SUBREG_CommandPtr(SYNC_RX)", fb->fb_daddr);
		/* Start dma engine. */
d1843 4
a1846 4
		chan = (pkt.fp_hdr[0] & 0x00003F00) >> 8;
		tag  = (pkt.fp_hdr[0] & 0x0000C000) >> 14;
		DPRINTFN(1, ("%s: hdr 0x%08x, tcode 0x%0x, hlen %d, dlen %d\n",
		    __func__, pkt.fp_hdr[0], pkt.fp_tcode, pkt.fp_hlen,
d1856 1
a1856 1
			/* Assuming pkt per buffer mode. */
d1865 2
a1866 1
		LIST_FOREACH(fh, &fc->fc_handler, fh_list) {
d1874 1
a1874 1
#ifdef	FWOHCI_DEBUG
d1876 1
a1876 1
			DPRINTFN(1, ("%s: no handler\n", __func__));
d1878 1
a1878 1
			DPRINTFN(1, ("%s: rcode %d\n", __func__, rcode));
d1880 1
a1880 1
#endif	/* FWOHCI_DEBUG */
d1903 1
a1903 1
#ifdef	FWOHCI_DEBUG
d1905 2
a1906 2
#endif	/* FWOHCI_DEBUG */

d1911 2
a1912 2
#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: tcode 0x%x, hlen %d, dlen %d", __func__,
d1914 1
a1914 1
	for (i = 0; i < pkt->fp_hlen/4; i++)
d1916 7
a1922 10
	DPRINTFN(2, (" $"));
	if (pkt->fp_uio.uio_iovcnt) {
		for (ndesc = 0, iov = pkt->fp_iov;
		     ndesc < pkt->fp_uio.uio_iovcnt; ndesc++, iov++) {
			for (i = 0; i < iov->iov_len; i++)
				DPRINTFN(2, ("%s%02x", (i%32)?((i%4)?"":" ")
							     :"\n    ",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(2, (" $"));
		}
d1925 1
a1925 1
#endif	/* FWOHCI_DEBUG */
a1935 1
					MPRINTF("MGETHDR", m0);
d1937 1
a1937 1
#ifdef	__NetBSD__
a1945 1
					MPRINTF("MGET", m->m_next);
a1951 1
					MPRINTF("m_freem", m0);
a1962 1
			MPRINTF("m_freem", pkt->fp_m);
d1971 1
a1971 1
	if (fc->fc_bufcnt > 50)			/* XXX */
a1972 1

a1973 1
	MPRINTF("malloc(DEVBUF)", fb);
a1977 2
		MPRINTF("free(DEVBUF)", fb);
		fb = NULL;	/* XXX */
d1986 1
a1986 1

a1991 2
			MPRINTF("free(DEVBUF)", fb);
			fb = NULL;	/* XXX */
a1993 1
		MPRINTF("bus_dmamap_create", fb->fb_dmamap);
a2002 1
			MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
a2004 2
			MPRINTF("free(DEVBUF)", fb);
			fb = NULL;	/* XXX */
d2020 1
a2020 1
		fd->fd_timestamp = ((val >> 12) & 0x1FFF) |
d2024 9
a2032 19

#if 1	/* XXX */
	bcopy(pkt->fp_hdr, fd + 1, pkt->fp_hlen);
#else
	bcopy(pkt->fp_hdr, fd->fd_immed, pkt->fp_hlen);
#endif

	if (ndesc > 2) {
		for (i = 0; i < ndesc - 2; i++) {
			fd = fb->fb_desc + 2 + i;
			fd->fd_flags = 0;
			fd->fd_reqcount = fb->fb_dmamap->dm_segs[i].ds_len;
			fd->fd_data = fb->fb_dmamap->dm_segs[i].ds_addr;
			fd->fd_branch = 0;
			fd->fd_status = 0;
			fd->fd_timestamp = 0;
		}
		bus_dmamap_sync(sc->sc_dmat, fb->fb_dmamap, 0, pkt->fp_dlen,
		    BUS_DMASYNC_POSTWRITE);
d2037 2
a2038 2
#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: desc %ld", __func__,
d2044 1
a2044 1
#endif	/* FWOHCI_DEBUG */
a2061 1
		MPRINTF("OHCI_SUBREG_CommandPtr(ASYNC)", fb->fb_daddr);
a2080 2
//	splassert(IPL_BIO);

d2083 2
a2084 2
#ifdef	FWOHCI_DEBUG
		DPRINTFN(1, ("%s: %sdesc %ld (%d)", __func__,
d2091 1
a2091 1
#endif	/* FWOHCI_DEBUG */
d2111 4
a2114 4
			bzero(&pkt, sizeof(pkt));
			pkt.fp_status = fd->fd_status;
			bcopy(fd + 1, pkt.fp_hdr, sizeof(pkt.fp_hdr[0]));

d2122 1
a2122 1
		if (fb->fb_nseg > 2) {
a2123 2
			MPRINTF("bus_dmamap_destroy", fb->fb_dmamap);
		}
d2128 1
a2128 1
		} else if (fb->fb_m != NULL) {
a2129 2
			MPRINTF("m_freem", fb->fb_m);
		}
a2130 2
		MPRINTF("free(DEVBUF)", fb);
		fb = NULL;	/* XXX */
d2142 2
a2143 2
	if (((*req->fp_trail & 0x001F0000) >> 16) !=
	    OHCI_CTXCTL_EVENT_ACK_PENDING)
d2146 2
a2147 2
	res->fp_hdr[0] = (req->fp_hdr[0] & 0x0000FC00) | 0x00000100;
	res->fp_hdr[1] = (req->fp_hdr[1] & 0xFFFF0000) | (rcode << 12);
d2149 3
a2151 3
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		res->fp_tcode = IEEE1394_TCODE_WRITE_RESPONSE;
d2154 2
a2155 2
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
		res->fp_tcode = IEEE1394_TCODE_READ_RESPONSE_QUADLET;
d2163 4
a2166 4
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_LOCK_REQUEST:
		if (req->fp_tcode == IEEE1394_TCODE_LOCK_REQUEST)
			res->fp_tcode = IEEE1394_TCODE_LOCK_RESPONSE;
d2168 1
a2168 1
			res->fp_tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
d2179 1
a2179 1
 * APPLICATION LAYER SERVICES.
d2183 1
a2183 1
 * Retrieve Global UID from GUID ROM.
d2191 1
a2191 2
	/*
	 * Extract the Global UID.
d2197 8
a2204 8
		sc->sc_sc1394.sc1394_guid[0] = (val1 >> 24) & 0xFF;
		sc->sc_sc1394.sc1394_guid[1] = (val1 >> 16) & 0xFF;
		sc->sc_sc1394.sc1394_guid[2] = (val1 >>  8) & 0xFF;
		sc->sc_sc1394.sc1394_guid[3] = (val1 >>  0) & 0xFF;
		sc->sc_sc1394.sc1394_guid[4] = (val2 >> 24) & 0xFF;
		sc->sc_sc1394.sc1394_guid[5] = (val2 >> 16) & 0xFF;
		sc->sc_sc1394.sc1394_guid[6] = (val2 >>  8) & 0xFF;
		sc->sc_sc1394.sc1394_guid[7] = (val2 >>  0) & 0xFF;
d2240 1
a2240 1
 * Initialization for Configuration ROM (no DMA context).
d2245 1
a2245 1
typedef struct configromctx {
d2247 1
a2247 1
	int		 curunit;
d2250 1
a2250 1
		int		 length;
d2252 1
a2252 1
		int		 refunit;
d2254 1
a2254 1
} configromctx;
d2259 1
a2259 1
#define	CFR_PUT_DATA1(cfr, d)		(*(cfr)->ptr++ = (d))
d2276 1
a2276 1
} while (0)
d2283 1
a2283 1
} while (0)
d2290 1
a2290 1
} while (0)
d2302 1
a2302 1
			sum = ((crc >> 12) ^ (data >> shift)) & 0x000F;
d2305 1
a2305 1
		crc &= 0xFFFF;
a2317 2
	//splassert(IPL_BIO);

d2319 1
a2319 1
	bzero(&cfr, sizeof(cfr));
d2322 1
a2322 1
	/* Headers. */
d2329 2
a2330 2
	/* Copy info_length from crc_length. */
	*hdr |= (*hdr & 0x00FF0000) << 8;
d2333 1
a2333 1
	/* Root directory. */
d2335 3
a2337 3
	CFR_PUT_VALUE(&cfr, 0x03, 0x00005E);	/* Vendor ID. */
	CFR_PUT_REFER(&cfr, 0x81, 2);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x0C, 0x0083C0);	/* Node capability. */
d2339 6
a2344 6
#ifdef	INET
	CFR_PUT_REFER(&cfr, 0xD1, 3);		/* IPv4 unit directory. */
#endif	/* INET */
#ifdef	INET6
	CFR_PUT_REFER(&cfr, 0xD1, 4);		/* IPv6 unit directory. */
#endif	/* INET6 */
d2348 2
a2349 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
d2359 2
a2360 2
#ifdef	INET
	/* IPv4 unit directory. */
d2362 5
a2366 5
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005E);	/* Unit spec ID. */
	CFR_PUT_REFER(&cfr, 0x81, 6);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000001);	/* Unit sw version. */
	CFR_PUT_REFER(&cfr, 0x81, 7);		/* Textual descriptor offset. */
	CFR_PUT_REFER(&cfr, 0x95, 8);		/* unit location. */
d2370 2
a2371 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
d2376 2
a2377 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
d2387 2
d2390 2
a2391 4
#endif	/* INET */

#ifdef	INET6
	/* IPv6 unit directory. */
d2393 3
a2395 3
	CFR_PUT_VALUE(&cfr, 0x12, 0x00005E);	/* Unit spec id. */
	CFR_PUT_REFER(&cfr, 0x81, 9);		/* Textual descriptor offset. */
	CFR_PUT_VALUE(&cfr, 0x13, 0x000002);	/* Unit sw version. */
d2397 2
a2398 2
	CFR_PUT_REFER(&cfr, 0x81, 10);		/* Textual descriptor offset. */
	CFR_PUT_REFER(&cfr, 0x95, 11);		/* Unit location. */
d2402 2
a2403 2
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
	CFR_PUT_DATA1(&cfr, 0);			/* Minimal ASCII. */
d2408 1
a2408 1
	CFR_PUT_VALUE(&cfr, 0, 0);		/* Textual descriptor. */
d2419 2
a2420 2

#endif	/* INET6 */
d2423 1
a2423 1
#ifdef	FWOHCI_DEBUG
d2428 1
a2428 1
#endif	/* FWOHCI_DEBUG */
d2431 1
a2431 1
	 * Make network byte order for DMA.
d2447 4
a2450 4

	/* Just allow quad reads of the rom, from every nodes. */
	for (i = 0; i < fb->fb_off; i++)
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQUEST_QUADLET,
d2452 1
a2452 1
		    OHCI_NodeId_NodeNumber, fwohci_configrom_input, NULL);
d2465 1
a2465 1
		/* Alignment error. */
d2472 1
a2472 1
	DPRINTFN(1, ("%s: ConfigRom[0x%04x]: 0x%08x\n", __func__, loc,
d2475 1
a2475 1
	bzero(&res, sizeof(res));
d2482 1
a2482 1
 * SelfID buffer (no DMA context).
a2488 2
	//splassert(IPL_BIO);

d2490 2
a2491 2
#ifdef	DIAGNOSTIC
	if ((fb->fb_dmamap->dm_segs[0].ds_addr & 0x7FF) != 0)
d2496 1
a2496 1
	bzero(fb->fb_buf, fb->fb_dmamap->dm_segs[0].ds_len);
d2516 1
a2516 1
		return (-1);
d2524 1
a2524 1
#ifdef	FWOHCI_DEBUG
d2530 1
a2530 1
#endif	/* FWOHCI_DEBUG */
d2535 6
a2540 12
#if	defined(FWOHCI_DEBUG)
		if (fwohcidebug > 2)
			fwohci_show_phypkt(sc, buf[i]);
#endif	/* FWOHCI_DEBUG */
		if (buf[i] & IEEE1394_SELFID_MORE_PACKETS)
			continue;	/* More pkt. */
		if (buf[i] & IEEE1394_SELFID_EXTENDED)
			continue;	/* Extended ID. */
		sc->sc_rootid = OHCI_BITVAL(buf[i], IEEE1394_PHY_ID);
		if ((buf[i] &
		     (IEEE1394_SELFID_LINK_ACTIVE|IEEE1394_SELFID_CONTENDER))
		    == (IEEE1394_SELFID_LINK_ACTIVE|IEEE1394_SELFID_CONTENDER))
d2552 1
a2552 1
		return (-1);
d2567 1
a2567 1
		return (-1);
d2572 1
a2572 1
		sc->sc_nodeid = 0xFFFF;		/* Invalid. */
d2575 1
a2575 1
		return (-1);
d2577 2
a2578 2
	sc->sc_nodeid = val & 0xFFFF;

d2585 1
a2585 1
		return (-1);
d2593 1
a2593 1
	return (0);
d2597 1
a2597 1
 * Some CSRs are handled by driver.
d2603 1
a2603 1
	static u_int32_t csr[] = {
a2609 2
	//splassert(IPL_BIO);

d2611 4
a2614 6
		fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQUEST_QUADLET,
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], OHCI_NodeId_NodeNumber,
		    fwohci_csr_input, NULL);
		fwohci_handler_set(sc, IEEE1394_TCODE_READ_REQUEST_QUADLET,
		    CSR_BASE_HI, CSR_BASE_LO + csr[i], OHCI_NodeId_NodeNumber,
		    fwohci_csr_input, NULL);
d2626 1
a2626 1
	 * XXX Need to do special functionality other than just r/w...
d2631 1
a2631 1
		/* Alignment error. */
d2634 1
a2634 1
	DPRINTFN(1, ("%s: CSR[0x%04x]: 0x%08x", __func__, reg,
d2636 1
a2636 1
	if (pkt->fp_tcode == IEEE1394_TCODE_WRITE_REQUEST_QUADLET) {
d2663 1
a2663 1
	int i, count, val, phy_id;
a2665 3
	u_int32_t *selfid_buf;

	selfid_buf = (u_int32_t *)sc->sc_buf_selfid.fb_buf;
d2668 1
a2668 1
		iea->sc1394_node_id = 0xFFFF;
d2670 1
a2670 1
	if (sc->sc_uidtbl != NULL) {
d2672 1
a2672 4
		MPRINTF("free(DEVBUF)", sc->sc_uidtbl);
		sc->sc_uidtbl = NULL;	/* XXX */
	}
#ifdef	M_ZERO
d2674 1
a2674 2
	    M_NOWAIT|M_ZERO);	/* XXX M_WAITOK requires locks. */
	MPRINTF("malloc(DEVBUF)", sc->sc_uidtbl);
d2677 2
a2678 2
	    M_NOWAIT);		/* XXX M_WAITOK requires locks. */
	MPRINTF("malloc(DEVBUF)", sc->sc_uidtbl);
d2680 1
a2680 2
	if (sc->sc_uidtbl == NULL) {
		DPRINTF(("sc_uidtbl malloc failed."));
a2681 17
	}
#ifndef	M_ZERO
	bzero(sc->sc_uidtbl, sizeof(*fu) * (sc->sc_rootid + 1));
#endif

	/* Update each node's link speed from SelfID buf. */
	count = OHCI_BITVAL(OHCI_CSR_READ(sc, OHCI_REG_SelfIDCount),
	    OHCI_SelfID_Size);
	for (i = 1; i < count; i += 2) {
		if (selfid_buf[i] & IEEE1394_SELFID_EXTENDED)
			continue;	/* No link speed info in Extended ID. */
		phy_id = OHCI_BITVAL(selfid_buf[i], IEEE1394_PHY_ID);
		if (phy_id > sc->sc_rootid)
			continue;	/* Bogus !!! */
		val = OHCI_BITVAL(selfid_buf[i], IEEE1394_SELFID_SPEED);
		sc->sc_uidtbl[phy_id].fu_link_speed = val;
	}
d2685 1
a2685 1
			bcopy(sc->sc_sc1394.sc1394_guid, fu->fu_uid, 8);
d2691 1
a2691 1
				DPRINTF(("%s: Updating nodeid to %d\n",
a2693 4
				if (iea->sc1394_callback.cb1394_busreset) {
					iea->sc1394_callback.cb1394_busreset(
					    iea);
				}
d2709 2
a2710 2
	bzero(&pkt, sizeof(pkt));
	pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
d2713 1
a2713 1
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
d2715 1
a2715 1
	pkt.fp_hdr[1] = ((0xFFC0 | phyid) << 16) | CSR_BASE_HI;
d2717 3
a2719 3
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESPONSE_QUADLET, phyid,
	    sc->sc_tlabel, OHCI_NodeId_NodeNumber, fwohci_uid_input, (void *)0);
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
d2722 1
a2722 1
	pkt.fp_hdr[0] = 0x00000100 | (sc->sc_tlabel << 10) |
d2725 3
a2727 3
	fwohci_handler_set(sc, IEEE1394_TCODE_READ_RESPONSE_QUADLET, phyid,
	    sc->sc_tlabel, OHCI_NodeId_NodeNumber, fwohci_uid_input, (void *)1);
	sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
d2742 1
a2742 1
	rcode = (res->fp_hdr[1] & 0x0000F000) >> 12;
d2749 1
a2749 1
		bcopy(res->fp_iov[0].iov_base, fu->fu_uid, 4);
d2752 1
a2752 1
		bcopy(res->fp_iov[0].iov_base, fu->fu_uid + 4, 4);
d2755 4
a2758 3
	if (fu->fu_valid == 0x3) {
		DPRINTFN(1, ("%s: Node %d, UID %02x:%02x:%02x:%02x:%02x:%02x:"
		    "%02x:%02x\n", __func__, n,
d2761 3
a2763 1
		LIST_FOREACH(iea, &sc->sc_nodelist, sc1394_node) {
d2767 1
a2767 2
				iea->sc1394_link_speed = fu->fu_link_speed;
				DPRINTF(("%s: Updating nodeid to %d, speed %d\n",
d2769 1
a2769 6
				    iea->sc1394_node_id,
				    fu->fu_link_speed));
				if (iea->sc1394_callback.cb1394_busreset) {
					iea->sc1394_callback.cb1394_busreset(
					    iea);
				}
a2771 1
		}
d2773 2
a2774 3
			strlcpy(fwa.name, "fwnode", sizeof fwa.name);
			fwa.link_speed = fu->fu_link_speed;
			bcopy(fu->fu_uid, fwa.uid, 8);
d2781 1
a2781 1
			    config_found_sm(&sc->sc_sc1394.sc1394_dev, &fwa,
d2783 1
a2783 5
			if (iea != NULL) {
				DPRINTF(("%s: Update speed to %d.",
				    iea->sc1394_dev.dv_xname,
				    fu->fu_link_speed));
				iea->sc1394_link_speed = fu->fu_link_speed;
a2785 1
			}
d2790 1
a2790 1
	for (i = 0; i <= sc->sc_rootid; i++) {
a2819 1
//			config_detach_children(detach, 0);
d2823 1
a2823 1
		if (iea->sc1394_node_id == 0xFFFF) {
d2828 1
a2828 2
	if (detach)  {
//		config_detach_children(detach, 0);
a2829 1
	}
d2838 1
a2838 1
	    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
d2844 1
a2844 1
		fwohci_uid_collect(sc); /* Try to get. */
d2856 1
a2856 1
			 * XXX: Need timer before retransmission.
d2865 1
a2865 1
 * Functions to support network interface.
d2873 1
a2873 2
	fwohci_handler_set(sc, IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK,
	    offhi, offlo, OHCI_NodeId_NodeNumber,
d2875 1
a2875 1
	fwohci_handler_set(sc, IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK,
d2877 2
a2878 2
	    OHCI_ASYNC_STREAM, IEEE1394_TAG_GASP, 0,
	    handler ? fwohci_if_input : NULL, handler);
d2890 1
a2890 1
#ifdef	FWOHCI_DEBUG
d2892 11
a2902 13
	DPRINTFN(1, ("tcode=0x%x, dlen=%d\n", pkt->fp_tcode, pkt->fp_dlen));
	for (i = 0; fwohcidebug > 5 && i < pkt->fp_hlen/4; i++)
		DPRINTFN(5, ("%s %08x", i?"":"   ", pkt->fp_hdr[i]));
	DPRINTFN(5, (" $\n"));
	if (pkt->fp_dlen) {
		for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
			iov = &pkt->fp_iov[n];
			for (i = 0; fwohcidebug > 5 && i < iov->iov_len; i++)
				DPRINTFN(5, ("%s%02x",
				    i&31?i&3?"":" ":i?"\n    ":"    ",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(5, (" $\n"));
		}
d2904 2
a2905 1
#endif	/* FWOHCI_DEBUG */
a2914 1
			MPRINTF("m_freem", m);
a2923 1
		MPRINTF("m_freem", m);
d2927 2
a2928 2
	bcopy(sc->sc_uidtbl[n].fu_uid, mtod(m, caddr_t), 8);
	if (pkt->fp_tcode == IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK) {
d2935 4
a2938 2
	mtod(m, u_int8_t *)[8] = n;	/*XXX: Node id for debug. */
	mtod(m, u_int8_t *)[9] = OHCI_BITVAL(*pkt->fp_trail, OHCI_CTXCTL_SPD);
d2949 1
a2949 1
	 * it is easy to map receive buffer to external mbuf. But it is
d2959 1
a2959 1
		bcopy(iov->iov_base, mtod(m, caddr_t) + m->m_len,
d2977 1
a2977 1
#if	defined(FWOHCI_DEBUG)
d2979 1
a2979 1
#endif	/* FWOHCI_DEBUG */
d2981 5
a2985 4
	chan = (pkt->fp_hdr[0] & 0x00003F00) >> 8;
	tag  = (pkt->fp_hdr[0] & 0x0000C000) >> 14;
#ifdef	FWOHCI_DEBUG
	DPRINTFN(1, ("%s: tcode=0x%x, chan=%d, tag=%x, dlen=%d", __func__,
d2990 7
a2996 9
	if (pkt->fp_dlen) {
		for (n = 0, len = pkt->fp_dlen; len > 0; len -= i, n++){
			iov = &pkt->fp_iov[n];
			for (i = 0; i < iov->iov_len; i++)
				DPRINTFN(2, ("%s%02x",
				    (i%32)?((i%4)?"":" "):"\n\t",
				    ((u_int8_t *)iov->iov_base)[i]));
			DPRINTFN(2, ("$"));
		}
d2999 1
a2999 1
#endif	/* FWOHCI_DEBUG */
a3008 1
			MPRINTF("m_freem", m);
a3021 1
			MPRINTF("m_freem", m);
d3024 1
a3024 1
		bcopy(sc->sc_uidtbl[n].fu_uid, mtod(m, caddr_t), 8);
d3029 2
a3030 1
		    OHCI_BITVAL(*pkt->fp_trail, OHCI_CTXCTL_SPD);
d3045 1
a3045 1
	 * it is easy to map receive buffer to external mbuf. But it is
d3055 1
a3055 1
		bcopy(iov->iov_base, mtod(m, caddr_t) + m->m_len,
d3057 2
a3058 2
		m->m_len += iov->iov_len;
		len -= iov->iov_len;
d3075 1
a3075 1
#ifdef	FWOHCI_DEBUG
d3077 1
a3077 1
#endif	/* FWOHCI_DEBUG */
d3097 1
a3097 1
#ifdef	FWOHCI_DEBUG
d3107 1
a3107 1
#endif	/* FWOHCI_DEBUG */
d3116 1
a3116 1
		DPRINTF(("%s: spd (%d) is faster than %d\n", __func__,
d3121 2
a3122 2
		DPRINTF(("%s: maxrec (%d) is larger for spd (%d)\n", __func__,
		    maxrec, spd));
d3126 2
a3127 2
		DPRINTF(("%s: maxrec (%d) is larger than %d\n", __func__,
		    maxrec, sc->sc_sc1394.sc1394_max_receive));
d3131 2
a3132 2
		DPRINTF(("%s: maxrec (%d) is smaller than minimum\n",
		    __func__, maxrec));
d3138 2
a3139 2
		DPRINTF(("%s: packet too big: hdr %d, pktlen %d, maxrec %d\n",
		    __func__, hdrlen, m0->m_pkthdr.len, maxrec));
d3144 1
a3144 1
	bzero(&pkt, sizeof(pkt));
d3149 1
a3149 1
		/* Construct GASP header. */
d3152 2
a3153 2
		p[1] = sc->sc_nodeid & 0xFF;
		p[2] = 0x00; p[3] = 0x00; p[4] = 0x5E;
d3155 1
a3155 1
		pkt.fp_tcode = IEEE1394_TCODE_ISOCHRONOUS_DATABLOCK;
d3162 1
a3162 1
		pkt.fp_tcode = IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK;
d3171 1
a3171 1
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
d3181 1
a3181 1
		if (callback) {
d3183 1
a3183 1
		} else {
a3184 2
			MPRINTF("m_freem", m0);
		}
d3202 2
a3203 2
 * routine since it will encapsulate retrying a region as quadlet vs. block
 * reads and recombining all the returned data. This could also be done with a
d3210 4
a3213 4
 * It accepts all standard ieee1394 tcodes (XXX: only a few today) and
 * optionally will callback via a func pointer to the calling code with the
 * resulting ACK code from the packet. If the ACK code is to be ignored (i.e.
 * no cb) then the write routine will take care of free'ing the abuf since the
d3231 1
a3231 1
 * that only need to register an area for a one-time operation (like a status
d3236 1
a3236 1

d3252 1
a3252 2
	MALLOC(fcb, struct fwohci_cb *, sizeof(*fcb), M_DEVBUF, M_WAITOK);
	MPRINTF("MALLOC(DEVBUF)", fcb);
d3256 3
d3260 2
a3261 5
	high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000FFFFFFFF);

	bzero(&pkt, sizeof(pkt));
	pkt.fp_hdr[1] = ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3266 2
a3267 2
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
		tcode = IEEE1394_TCODE_READ_RESPONSE_QUADLET;
d3270 1
a3270 1
		pkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_DATABLOCK;
d3272 1
a3272 1
		tcode = IEEE1394_TCODE_READ_RESPONSE_DATABLOCK;
d3282 2
a3283 2
	    psc->sc_tlabel, 0, fwohci_read_resp, fcb);
	if (rv)
d3288 2
a3289 2
		    psc->sc_tlabel, 0, NULL, NULL);
	psc->sc_tlabel = (psc->sc_tlabel + 1) & 0x3F;
d3300 1
a3300 1
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent;
d3304 2
a3305 5
	if ((ab->ab_tcode == IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK &&
	     ab->ab_length > IEEE1394_MAX_REC(sc->sc1394_max_receive)) ||
	    ab->ab_length > IEEE1394_MAX_ASYNC(sc->sc1394_link_speed)) {
		DPRINTF(("%s: Packet too large: %d\n", __func__,
		    ab->ab_length));
d3314 1
a3314 1
	bzero(&pkt, sizeof(pkt));
d3321 3
a3323 3
	} else
		bcopy(ab->ab_uio, &pkt.fp_uio, sizeof(struct uio));

d3328 1
a3328 1
	case IEEE1394_TCODE_WRITE_RESPONSE:
d3330 2
a3331 2
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
d3342 2
a3343 2
		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF);
d3349 1
a3349 1
	pkt.fp_hdr[1] = ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3367 3
a3369 3
	case IEEE1394_TCODE_WRITE_RESPONSE:
	case IEEE1394_TCODE_READ_RESPONSE_QUADLET:
	case IEEE1394_TCODE_READ_RESPONSE_DATABLOCK:
d3396 1
a3396 1

d3402 1
a3402 1
		tcode = (pkt->fp_hdr[0] >> 4) & 0xF;
d3405 2
a3406 2
			DPRINTFN(2, ("%s: Got status packet: 0x%02x\n",
			    __func__, (unsigned int)status));
d3411 1
a3411 1
		 * callback has been called). Clean up.
d3413 1
a3413 1

d3415 2
a3416 5
			if (fcb->count == 0) {
				FREE(fcb, M_DEVBUF);
				MPRINTF("FREE(DEVBUF)", fcb);
				fcb = NULL;	/* XXX */
			}
d3422 1
a3422 1
		rcode = (pkt->fp_hdr[1] & 0x0000F000) >> 12;
d3426 1
a3426 1
	 * Some areas (like the config rom) want to be read as quadlets only.
d3436 1
a3436 1
	 * multi_resp handle the iteration over the space.
d3440 1
a3440 1
	     (tcode == IEEE1394_TCODE_READ_REQUEST_DATABLOCK)) ||
d3442 2
a3443 2
	      (rcode == IEEE1394_RCODE_ADDRESS_ERROR)) &&
	     (tcode == IEEE1394_TCODE_READ_RESPONSE_DATABLOCK))) {
d3447 1
a3447 1
		bzero(&newpkt, sizeof(newpkt));
d3449 2
a3450 2
		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF);
d3452 1
a3452 1
		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
d3456 1
a3456 1
		    ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3461 2
a3462 3
		rv = fwohci_handler_set(sc,
		    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
d3472 3
a3474 4
			fwohci_handler_set(sc,
			    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
			    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
			    NULL, NULL);
d3479 1
a3479 1
		sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
a3491 3

			assert(pkt->fp_uio.uio_iovcnt > 0);

d3499 1
a3499 1
					bcopy(pkt->fp_iov[i].iov_base, cur,
d3504 1
a3504 1
				bcopy(pkt->fp_iov[i].iov_base, cur,
d3506 1
a3506 1
				(caddr_t)cur += pkt->fp_iov[i].iov_len;
a3508 1
			DPRINTF(("%s: retlen=%d\n", __func__, ab->ab_retlen));
d3510 1
a3510 1
		if (status != -1)
d3514 2
a3515 3
				    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
				    ab->ab_req->sc1394_node_id, i, 0,
				    NULL, NULL);
d3523 1
a3523 1

d3526 2
a3527 5
	if (fcb->count == 0) {
		FREE(fcb, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", fcb);
		fcb = NULL;
	}
d3550 1
a3550 1
	rcode = (pkt->fp_hdr[1] & 0x0000F000) >> 12;
d3558 2
a3559 3
		bcopy(pkt->fp_iov[0].iov_base,
		    ((char *)ab->ab_data + ab->ab_retlen),
		    (ab->ab_length - ab->ab_retlen));
d3562 2
a3563 2
		bcopy(pkt->fp_iov[0].iov_base,
		    ((char *)ab->ab_data + ab->ab_retlen), 4);
a3565 1
	DPRINTF(("%s: retlen=%d\n", __func__, ab->ab_retlen));
d3568 1
a3568 1
		bzero(&newpkt, sizeof(newpkt));
d3570 2
a3571 2
		high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
		lo = (ab->ab_addr & 0x00000000FFFFFFFF) + ab->ab_retlen;
d3573 1
a3573 1
		newpkt.fp_tcode = IEEE1394_TCODE_READ_REQUEST_QUADLET;
d3577 1
a3577 1
		    ((0xFFC0 | ab->ab_req->sc1394_node_id) << 16) | high;
d3586 1
a3586 1
		 * Bad return code. Just give up and return what's
d3589 2
a3590 3
		rv = fwohci_handler_set(sc,
		    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
		    ab->ab_req->sc1394_node_id, sc->sc_tlabel, 0,
d3592 1
a3592 1
		if (rv)
d3598 1
a3598 1
				    IEEE1394_TCODE_READ_RESPONSE_QUADLET,
d3600 1
a3600 1
				    0, NULL, NULL);
d3603 1
a3603 1
				sc->sc_tlabel = (sc->sc_tlabel + 1) & 0x3F;
d3614 2
a3615 5
	if (fcb->count == 0) {
		FREE(fcb, M_DEVBUF);
		MPRINTF("FREE(DEVBUF)", fcb);
		fcb = NULL;
	}
d3629 1
a3629 1
		DPRINTF(("%s: Got status packet: 0x%02x\n", __func__,
d3636 1
a3636 1
		if (ab->ab_data) {
d3638 1
a3638 6
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
		}
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
d3648 1
a3648 1
	    (struct fwohci_softc *)sc->sc1394_dev.dv_parent;
d3650 1
a3650 1
	int rv;
d3652 2
a3653 2
	high = ((ab->ab_addr & 0x0000FFFF00000000) >> 32);
	lo = (ab->ab_addr & 0x00000000FFFFFFFF);
d3657 2
a3658 2
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
d3661 1
a3661 1
			    sc->sc1394_node_id, fwohci_parse_input, ab);
d3663 2
a3664 2
			fwohci_handler_set(psc, ab->ab_tcode, high, lo,
			    sc->sc1394_node_id, NULL, NULL);
d3666 2
a3667 2
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
d3669 17
a3685 8
			if (ab->ab_cb)
				rv = fwohci_block_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id, ab->ab_length,
				    fwohci_parse_input, ab);
			else
				fwohci_block_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id, ab->ab_length,
				    NULL, NULL);
d3689 1
a3689 1
			 */
d3691 1
a3691 1
				ab->ab_data = (void *)1;
d3693 3
a3695 4
			if (ab->ab_cb)
				rv = fwohci_handler_set(psc, ab->ab_tcode,
				    high, lo, sc->sc1394_node_id,
				    fwohci_parse_input, ab);
d3698 1
a3698 1
				    sc->sc1394_node_id, NULL, NULL);
d3702 1
a3702 2
		DPRINTF(("%s: Invalid registration tcode: %d\n", __func__,
		    ab->ab_tcode));
d3714 1
a3714 1

d3730 3
a3732 8
	ab->ab_tcode = (pkt->fp_hdr[0] >> 4) & 0xF;
	ab->ab_tlabel = (pkt->fp_hdr[0] >> 10) & 0x3F;
	addr = (((u_int64_t)(pkt->fp_hdr[1] & 0xFFFF) << 32) | pkt->fp_hdr[2]);

	DPRINTFN(3, ("%s: ab=0x%08x ab_cb=0x%08x\n\ttcode=%d tlabel=0x%02x"
	    " addr=%04x%08x\n", __func__, (u_int32_t)ab, (u_int32_t)ab->ab_cb,
	    ab->ab_tcode, ab->ab_tlabel, pkt->fp_hdr[1] & 0xffff,
	    pkt->fp_hdr[2]));
d3735 1
a3735 1
	case IEEE1394_TCODE_READ_REQUEST_QUADLET:
d3738 6
a3743 9
	case IEEE1394_TCODE_READ_REQUEST_DATABLOCK:
		ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
		if ((ab->ab_retlen > ab->ab_length) ||
		    ((addr + ab->ab_retlen) > (ab->ab_addr + ab->ab_length)))
			return IEEE1394_RCODE_ADDRESS_ERROR;

		if ((caddr_t)ab->ab_data > (caddr_t)1) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
d3745 3
a3747 1
		}
d3749 1
a3749 1
	case IEEE1394_TCODE_WRITE_REQUEST_QUADLET:
d3751 11
a3761 17
	case IEEE1394_TCODE_WRITE_REQUEST_DATABLOCK:
		if (!ab->ab_retlen)
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
		else {
#ifdef	FWOHCI_DEBUG
			if (ab->ab_retlen != ((pkt->fp_hdr[3] >> 16) & 0xFFFF))
				DPRINTF(("%s: retlen(%d) <> pktlen(%d)\n",
				    __func__, ab->ab_retlen,
				    (pkt->fp_hdr[3] >> 16) & 0xFFFF));
#endif	/* FWOHCI_DEBUG */
#if 0
			ab->ab_retlen = (pkt->fp_hdr[3] >> 16) & 0xFFFF;
#endif
		}
		if ((ab->ab_retlen > ab->ab_length) ||
		    ((addr + ab->ab_retlen) > (ab->ab_addr + ab->ab_length)))
			return IEEE1394_RCODE_ADDRESS_ERROR;
a3762 5
		if ((caddr_t)ab->ab_data > (caddr_t)1) {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;
		}
d3764 1
a3764 3
		MPRINTF("malloc(1394DATA)", ab->ab_data);

		if (ab->ab_tcode == IEEE1394_TCODE_WRITE_REQUEST_QUADLET)
a3768 3

			assert(pkt->fp_uio.uio_iovcnt > 0);

d3770 1
a3770 5
				DPRINTFN(3, ("\t%d : bcopy(0x%08x, 0x%08x,"
				    " 0x%x)\n", i,
				    (u_int32_t)pkt->fp_iov[i].iov_base,
				    (u_int32_t)cur, pkt->fp_iov[i].iov_len));
				bcopy(pkt->fp_iov[i].iov_base, cur,
d3772 1
a3772 1
				(caddr_t)cur += pkt->fp_iov[i].iov_len;
d3777 1
a3777 1
				    "but %d bytes returned",
d3791 1
a3791 1
#ifdef	__NetBSD__
d3800 1
a3800 1
#ifdef	__OpenBSD__
d3818 3
a3820 14
	*sc->sc_dying = 1;	/* Stop the event thread. */
	wakeup(fwohci_event_thread);
	DPRINTF(("%s: waiting 0x%08x\n", __func__, sc->sc_dying));
	tsleep(sc->sc_dying, PZERO, "detach", 3 * hz);
	DPRINTF(("%s: woken up...\n", __func__));
	FREE(sc->sc_dying, M_DEVBUF);
	MPRINTF("FREE(DEVBUF)", sc->sc_dying);
	sc->sc_dying = NULL;	/* XXX */

	if (sc->sc_sc1394.sc1394_if != NULL) {
		rv = config_detach_children(sc->sc_sc1394.sc1394_if, flags);
		rv |= config_detach(sc->sc_sc1394.sc1394_if, flags);
	}
	if (rv)
d3823 1
a3823 1
#ifdef	__NetBSD__
d3851 2
a3852 2
			rv = config_deactivate(sc->sc_sc1394.sc1394_if);
		break;
d3859 1
a3859 1
#ifdef	FWOHCI_DEBUG
d3864 2
a3865 2
	DPRINTF(("%s: intmask=0x%08x:", sc->sc_sc1394.sc1394_dev.dv_xname,
	    intmask));
d3867 1
a3867 1
		DPRINTF((" CycleTooLong"));
d3869 1
a3869 1
		DPRINTF((" UnrecoverableError"));
d3871 1
a3871 1
		DPRINTF((" CycleInconsistent"));
d3873 1
a3873 1
		DPRINTF((" BusReset"));
d3875 1
a3875 1
		DPRINTF((" SelfIDComplete"));
d3877 1
a3877 1
		DPRINTF((" LockRespErr"));
d3879 1
a3879 1
		DPRINTF((" PostedWriteErr"));
d3881 1
a3881 1
		DPRINTF((" ReqTxComplete(0x%04x)",
d3883 1
a3883 1
		    OHCI_SUBREG_ContextControlClear)));
d3885 1
a3885 1
		DPRINTF((" RespTxComplete(0x%04x)",
d3887 1
a3887 1
		    OHCI_SUBREG_ContextControlClear)));
d3889 1
a3889 1
		DPRINTF((" ARRS(0x%04x)",
d3891 1
a3891 1
		    OHCI_SUBREG_ContextControlClear)));
d3893 1
a3893 1
		DPRINTF((" ARRQ(0x%04x)",
d3895 1
a3895 1
		    OHCI_SUBREG_ContextControlClear)));
d3897 2
a3898 2
		DPRINTF((" IsochRx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoRecvIntEventClear)));
d3900 2
a3901 2
		DPRINTF((" IsochTx(0x%08x)",
		    OHCI_CSR_READ(sc, OHCI_REG_IsoXmitIntEventClear)));
d3903 1
a3903 1
		DPRINTF((" RQPkt(0x%04x)",
d3905 1
a3905 1
		    OHCI_SUBREG_ContextControlClear)));
d3907 1
a3907 1
		DPRINTF((" RSPkt(0x%04x)",
d3909 2
a3910 2
		    OHCI_SUBREG_ContextControlClear)));
	DPRINTF(("\n"));
d3918 4
a3921 4
	key = OHCI_BITVAL(val, IEEE1394_PHY_TYPE);
	phyid = OHCI_BITVAL(val, IEEE1394_PHY_ID);
	DPRINTF(("%s: PHY packet from %d: ",
	    sc->sc_sc1394.sc1394_dev.dv_xname, phyid));
d3924 6
a3929 7
		DPRINTF(("PHY Config:"));
		if (val & IEEE1394_CONFIG_FORCE_ROOT)
			DPRINTF((" ForceRoot"));
		if (val & IEEE1394_CONFIG_SET_GAPCNT)
			DPRINTF((" Gap=%x",
			    OHCI_BITVAL(val, IEEE1394_CONFIG_GAPCNT)));
		DPRINTF(("\n"));
d3932 1
a3932 1
		DPRINTF(("Link-on\n"));
d3935 3
a3937 4
		DPRINTF(("SelfID:"));
		if (val & IEEE1394_SELFID_EXTENDED) {
			DPRINTF((" #%d",
			    OHCI_BITVAL(val, IEEE1394_SELFID_EXT_SEQ)));
d3939 12
a3950 16
			if (val & IEEE1394_SELFID_LINK_ACTIVE)
				DPRINTF((" LinkActive"));
			DPRINTF((" Gap=%x",
			    OHCI_BITVAL(val, IEEE1394_SELFID_GAPCNT)));
			DPRINTF((" Spd=S%d",
			    100 << OHCI_BITVAL(val, IEEE1394_SELFID_SPEED)));
			DPRINTF((" Pow=%s", ieee1394_power[OHCI_BITVAL(val,
			     IEEE1394_SELFID_POWER)]));
			if (val & IEEE1394_SELFID_CONTENDER)
				DPRINTF((" Cont"));
			if (val & IEEE1394_SELFID_INITIATED_RESET)
				DPRINTF((" InitiateBusReset"));
		}
		if (val & IEEE1394_SELFID_MORE_PACKETS)
			DPRINTF((" +"));
		DPRINTF(("\n"));
d3953 1
a3953 1
		DPRINTF(("unknown: 0x%08x\n", val));
d3957 1
a3957 1
#endif	/* FWOHCI_DEBUG */
@


1.3
log
@better say we are OpenBSD in the configrom
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.2 2002/06/26 15:52:13 tdeval Exp $	*/
d3310 1
a3310 1
		panic("Can't call with uio and data set\n");
d3312 1
a3312 1
		panic("One of either ab_data or ab_uio must be set\n");
d3777 1
a3777 1
				    "but only %d bytes returned\n",
d3782 1
a3782 1
		panic("Got a callback for a tcode that wasn't requested: %d\n",
@


1.2
log
@various fixes + some KNF
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fwohci.c,v 1.1 2002/06/25 17:11:49 itojun Exp $	*/
d2350 1
d2353 4
@


1.1
log
@IEEE1394 infrastructure part.
IP-over-FW and SCSI over FW are being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d58 1
a58 1
#define NO_THREAD 1
d99 1
a99 1
static int fwohci_dnamem_alloc(struct fwohci_softc *sc, int size,
d102 2
a103 2
static void fwohci_create_event_thread(void *);
static void fwohci_thread_init(void *);
d105 8
a112 8
static void fwohci_event_thread(struct fwohci_softc *);
static void fwohci_hw_init(struct fwohci_softc *);
static void fwohci_power(int, void *);
static void fwohci_shutdown(void *);

static int  fwohci_desc_alloc(struct fwohci_softc *);
static struct fwohci_desc *fwohci_desc_get(struct fwohci_softc *, int);
static void fwohci_desc_put(struct fwohci_softc *, struct fwohci_desc *, int);
d114 1
a114 1
static int  fwohci_ctx_alloc(struct fwohci_softc *, struct fwohci_ctx **,
d116 2
a117 2
static void fwohci_ctx_free(struct fwohci_softc *, struct fwohci_ctx *);
static void fwohci_ctx_init(struct fwohci_softc *, struct fwohci_ctx *);
d119 8
a126 8
static int  fwohci_buf_alloc(struct fwohci_softc *, struct fwohci_buf *);
static void fwohci_buf_free(struct fwohci_softc *, struct fwohci_buf *);
static void fwohci_buf_init_rx(struct fwohci_softc *);
static void fwohci_buf_start_rx(struct fwohci_softc *);
static void fwohci_buf_stop_tx(struct fwohci_softc *);
static void fwohci_buf_stop_rx(struct fwohci_softc *);
static void fwohci_buf_next(struct fwohci_softc *, struct fwohci_ctx *);
static int  fwohci_buf_pktget(struct fwohci_softc *, struct fwohci_buf **,
d128 1
a128 1
static int  fwohci_buf_input(struct fwohci_softc *, struct fwohci_ctx *,
d130 1
a130 1
static int  fwohci_buf_input_ppb(struct fwohci_softc *, struct fwohci_ctx *,
d133 4
a136 4
static u_int8_t fwohci_phy_read(struct fwohci_softc *, u_int8_t);
static void fwohci_phy_write(struct fwohci_softc *, u_int8_t, u_int8_t);
static void fwohci_phy_busreset(struct fwohci_softc *);
static void fwohci_phy_input(struct fwohci_softc *, struct fwohci_pkt *);
d138 1
a138 1
static int  fwohci_handler_set(struct fwohci_softc *, int, u_int32_t, u_int32_t,
d141 3
a143 3
static void fwohci_arrq_input(struct fwohci_softc *, struct fwohci_ctx *);
static void fwohci_arrs_input(struct fwohci_softc *, struct fwohci_ctx *);
static void fwohci_ir_input(struct fwohci_softc *, struct fwohci_ctx *);
d145 1
a145 1
static int  fwohci_at_output(struct fwohci_softc *, struct fwohci_ctx *,
d147 2
a148 2
static void fwohci_at_done(struct fwohci_softc *, struct fwohci_ctx *, int);
static void fwohci_atrs_output(struct fwohci_softc *, int, struct fwohci_pkt *,
d151 3
a153 3
static int  fwohci_guidrom_init(struct fwohci_softc *);
static void fwohci_configrom_init(struct fwohci_softc *);
static int  fwohci_configrom_input(struct fwohci_softc *, void *,
d155 2
a156 2
static void fwohci_selfid_init(struct fwohci_softc *);
static int  fwohci_selfid_input(struct fwohci_softc *);
d158 2
a159 2
static void fwohci_csr_init(struct fwohci_softc *);
static int  fwohci_csr_input(struct fwohci_softc *, void *,
d162 3
a164 3
static void fwohci_uid_collect(struct fwohci_softc *);
static void fwohci_uid_req(struct fwohci_softc *, int);
static int  fwohci_uid_input(struct fwohci_softc *, void *,
d166 2
a167 2
static int  fwohci_uid_lookup(struct fwohci_softc *, const u_int8_t *);
static void fwohci_check_nodes(struct fwohci_softc *);
d169 1
a169 1
static int  fwohci_if_inreg(struct device *, u_int32_t, u_int32_t,
d171 3
a173 3
static int  fwohci_if_input(struct fwohci_softc *, void *, struct fwohci_pkt *);
static int  fwohci_if_input_iso(struct fwohci_softc *, void *, struct fwohci_pkt *);
static int  fwohci_if_output(struct device *, struct mbuf *,
d175 1
a175 1
static int fwohci_if_setiso(struct device *, u_int32_t, u_int32_t, u_int32_t,
d177 5
a181 5
static int  fwohci_read(struct ieee1394_abuf *);
static int  fwohci_write(struct ieee1394_abuf *);
static int  fwohci_read_resp(struct fwohci_softc *, void *, struct fwohci_pkt *);
static int  fwohci_write_ack(struct fwohci_softc *, void *, struct fwohci_pkt *);
static int  fwohci_read_multi_resp(struct fwohci_softc *, void *,
d183 3
a185 3
static int  fwohci_inreg(struct ieee1394_abuf *, int);
static int  fwohci_unreg(struct ieee1394_abuf *, int);
static int  fwohci_parse_input(struct fwohci_softc *, void *,
d188 1
a188 1
static int  fwohci_submatch(struct device *, struct cfdata *, void *);
d190 1
a190 1
static int  fwohci_submatch(struct device *, void *, void *);
d192 1
d195 2
a196 2
static void fwohci_show_intr(struct fwohci_softc *, u_int32_t);
static void fwohci_show_phypkt(struct fwohci_softc *, u_int32_t);
d309 5
a313 1
	kthread_create_deferred(fwohci_create_event_thread, sc);
d315 1
d319 1
a319 1
static int
d443 1
a443 1
static void
d462 1
a462 1
static void
d531 1
a531 1
static void
d623 1
a623 1
static int
d674 1
a674 1
static void
d703 1
d757 1
a757 1
static void
d783 1
a783 1
static void
d815 1
a815 1
static u_int8_t
d822 2
a823 1
	    OHCI_PhyControl_RdReg | (reg << OHCI_PhyControl_RegAddr_BITPOS));
d837 1
a837 1
static void
d843 1
a843 1
	    (reg << OHCI_PhyControl_RegAddr_BITPOS) |
d856 1
a856 1
static void
d882 1
a882 1
static void
d909 1
a909 1
static int
d971 1
a971 1
static struct fwohci_desc *
d990 1
a990 1
static void
d1008 1
a1008 1
static int
d1033 1
a1033 1
	bzero(fb, sizeof(*fb));
d1103 1
a1103 1
static void
d1140 1
a1140 1
static void
d1201 1
a1201 1
static int
d1249 1
a1249 1
static void
d1259 1
a1259 1
static void
d1279 1
a1279 1
static void
d1295 1
a1295 1
static void
d1326 1
a1326 1
static void
d1341 1
a1341 1
static void
d1385 1
a1385 1
static int
d1421 1
a1421 1
static int
d1529 1
a1529 1
static int
d1600 1
a1600 1
static int
d1706 1
a1706 1
static void
d1759 1
a1759 1
static void
d1797 1
a1797 1
static void
d1894 1
a1894 1
static int
d2073 1
a2073 1
static void
d2137 1
a2137 1
static void
d2185 1
a2185 1
static int
d2292 1
a2292 1
static u_int16_t
d2310 1
a2310 1
static void
d2450 1
a2450 1
static int
d2479 1
a2479 1
static void
d2499 1
a2499 1
static int
d2594 1
a2594 1
static void
d2614 1
a2614 1
static int
d2655 1
a2655 1
static void
d2699 1
a2699 1
static void
d2726 1
a2726 1
static int
d2798 1
a2798 1
static void
d2827 1
a2827 1
static int
d2862 1
a2862 1
static int
d2877 1
a2877 1
static int
d2964 1
a2964 1
static int
d3062 1
a3062 1
static int
d3232 1
a3232 1
static int
d3289 1
a3289 1
static int
d3374 1
a3374 1
static int
d3526 1
a3526 1
static int
d3614 1
a3614 1
static int
d3638 1
a3638 1
static int
d3704 1
a3704 1
static int
d3717 1
a3717 1
static int
d3787 1
a3787 1
static int
d3790 1
a3790 1
static int
d3855 1
a3855 1
static void
d3908 1
a3908 1
static void
@

