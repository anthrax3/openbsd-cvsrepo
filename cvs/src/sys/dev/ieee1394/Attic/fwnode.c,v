head	1.7;
access;
symbols
	OPENBSD_3_6:1.6.0.10
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.8
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.6.0.6
	OPENBSD_3_4_BASE:1.6
	UBC_SYNC_A:1.6
	SMP:1.6.0.4
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	UBC:1.3.0.2
	UBC_SYNC_B:1.3
	OPENBSD_3_2:1.2.0.2
	OPENBSD_3_2_BASE:1.2;
locks; strict;
comment	@ * @;


1.7
date	2005.03.05.23.58.43;	author tdeval;	state dead;
branches;
next	1.6;

1.6
date	2003.01.12.12.05.53;	author tdeval;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.13.21.35.11;	author tdeval;	state Exp;
branches;
next	1.4;

1.4
date	2002.12.13.02.52.04;	author tdeval;	state Exp;
branches;
next	1.3;

1.3
date	2002.10.12.01.09.44;	author krw;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2002.06.26.14.04.02;	author tdeval;	state Exp;
branches;
next	1.1;

1.1
date	2002.06.25.17.11.49;	author itojun;	state Exp;
branches;
next	;

1.3.2.1
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.7
log
@Clean up the tree from incomplete, unreliable and unsupported IEEE1394 code.
Ok deraadt@@, miod@@
@
text
@/*	$OpenBSD: fwnode.c,v 1.6 2003/01/12 12:05:53 tdeval Exp $	*/
/*	$NetBSD: fwnode.c,v 1.13 2002/04/03 04:15:59 jmc Exp $	*/

/*
 * Copyright (c) 2001,2002 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by James Chacon.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/cdefs.h>
#ifdef	__KERNEL_RCSID
__KERNEL_RCSID(0, "$NetBSD: fwnode.c,v 1.13 2002/04/03 04:15:59 jmc Exp $");
#endif

#include <sys/param.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/systm.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/std/ieee1212var.h>
#include <dev/std/ieee1212reg.h>

#include <dev/ieee1394/ieee1394reg.h>
#include <dev/ieee1394/fwnodereg.h>

#include <dev/ieee1394/ieee1394var.h>
#include <dev/ieee1394/fwnodevar.h>

#if 0
const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
#endif

#ifdef	__NetBSD__
int  fwnode_match(struct device *, struct cfdata *, void *);
#else
int  fwnode_match(struct device *, void *, void *);
#endif
void fwnode_attach(struct device *, struct device *, void *);
int  fwnode_detach(struct device *, int);
void fwnode_configrom_input(struct ieee1394_abuf *, int);
int  fwnode_print(void *, const char *);
#ifdef	FWNODE_DEBUG
void fwnode_dump_rom(struct fwnode_softc *, u_int32_t *, u_int32_t);
#endif	/* FWNODE_DEBUG */

#ifdef	FWNODE_DEBUG
#include <sys/syslog.h>
extern int log_open;
int fwnode_oldlog;
#define	DPRINTF(x)	if (fwnodedebug) do {				\
	fwnode_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwnode_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (fwnodedebug>(n)) do {			\
	fwnode_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwnode_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	fwnodedebug = 0;
#else	/* FWNODE_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! FWNODE_DEBUG */

#ifdef __OpenBSD__
struct cfdriver fwnode_cd = {
	NULL, "fwnode", DV_DULL
};
#endif

struct cfattach fwnode_ca = {
	sizeof(struct fwnode_softc), fwnode_match, fwnode_attach,
	fwnode_detach
};

#ifdef __NetBSD__
int
fwnode_match(struct device *parent, struct cfdata *match, void *aux)
#else
int
fwnode_match(struct device *parent, void *match, void *aux)
#endif
{
	struct ieee1394_attach_args *fwa = aux;

	if (strcmp(fwa->name, "fwnode") == 0)
		return (1);
	return (0);
}

void
fwnode_attach(struct device *parent, struct device *self, void *aux)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)self;
	struct ieee1394_softc *psc = (struct ieee1394_softc *)parent;
	struct ieee1394_attach_args *fwa = aux;
	struct ieee1394_abuf *ab;

#ifdef M_ZERO
	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab),
	    M_1394DATA, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(1394DATA)", ab);
#else
	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab);
	bzero(ab, sizeof(*ab));
#endif
	ab->ab_data = malloc(4, M_1394DATA, M_WAITOK);
	MPRINTF("malloc(1394DATA)", ab->ab_data);
	ab->ab_data[0] = 0;

	sc->sc_sc1394.sc1394_link_speed = fwa->link_speed;
	sc->sc_sc1394.sc1394_node_id = fwa->nodeid;
	memcpy(sc->sc_sc1394.sc1394_guid, fwa->uid, 8);
	sc->sc1394_read = fwa->read;
	sc->sc1394_write = fwa->write;
	sc->sc1394_inreg = fwa->inreg;
	sc->sc1394_unreg = fwa->unreg;

	/* XXX. Fix the fw code to use the generic routines. */
	sc->sc_sc1394.sc1394_ifinreg = psc->sc1394_ifinreg;
	sc->sc_sc1394.sc1394_ifoutput = psc->sc1394_ifoutput;

	printf(" Node %d: UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
	    sc->sc_sc1394.sc1394_node_id,
	    sc->sc_sc1394.sc1394_guid[0], sc->sc_sc1394.sc1394_guid[1],
	    sc->sc_sc1394.sc1394_guid[2], sc->sc_sc1394.sc1394_guid[3],
	    sc->sc_sc1394.sc1394_guid[4], sc->sc_sc1394.sc1394_guid[5],
	    sc->sc_sc1394.sc1394_guid[6], sc->sc_sc1394.sc1394_guid[7]);
	ab->ab_req = (struct ieee1394_softc *)sc;
	ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM;
	ab->ab_length = 4;
	ab->ab_retlen = 0;
	ab->ab_cbarg = NULL;
	ab->ab_cb = fwnode_configrom_input;
	sc->sc1394_read(ab);
}

int
fwnode_detach(struct device *self, int flags)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)self;
	struct device **children;

	if (sc->sc_children) {
		children = sc->sc_children;
		while (*children != NULL) {
			config_detach(*children, 0);
			children++;
		}
		free(sc->sc_children, M_DEVBUF);
		MPRINTF("free(DEVBUF)", sc->sc_children);
		sc->sc_children = NULL;
	}

	if (sc->sc_sc1394.sc1394_configrom &&
	    sc->sc_sc1394.sc1394_configrom_len) {
		free(sc->sc_sc1394.sc1394_configrom, M_1394DATA);
		MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
		sc->sc_sc1394.sc1394_configrom = NULL;
	}

	if (sc->sc_configrom)
		p1212_free(sc->sc_configrom);
	return 0;
}

/*
 * This code is trying to build a complete image of the ROM in memory.
 * This is done all here to keep the bus_read logic/callback for the ROM in one
 * place since reading the whole ROM may require lots of small reads up front
 * and building separate callback handlers for each step would be even worse.
 */

typedef struct cfgrom_cbarg {
	int		 cc_type;
	int		 cc_retlen;
	int		 cc_num;
	uint32_t	*cc_buf;
} cfgrom_cbarg;

void
fwnode_configrom_input(struct ieee1394_abuf *ab, int rcode)
{
	struct fwnode_softc *sc = (struct fwnode_softc *)ab->ab_req;
	struct cfgrom_cbarg *cc = NULL;
	u_int32_t val, *cbuf;

	if (ab->ab_cbarg != NULL) {
		cc = (struct cfgrom_cbarg *) ab->ab_cbarg;
		if (cc->cc_type != 0x31333934)
			panic("Got an invalid abuf on callback");
		DPRINTF(("(cc_num:%d/0x%02x) ", cc->cc_num, cc->cc_num));
	}

	if (rcode != IEEE1394_RCODE_COMPLETE) {
		DPRINTF(("Aborting configrom input, rcode: %d\n", rcode));
#ifdef	FWNODE_DEBUG
		fwnode_dump_rom(sc, ab->ab_data, ab->ab_retlen);
#endif	/* FWNODE_DEBUG */
		if (cc != NULL) {
			FREE(cc, M_1394DATA);
			MPRINTF("FREE(1394DATA)", cc);
			cc = NULL;	/* XXX */
		}
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	if (ab->ab_length != ab->ab_retlen) {
		DPRINTF(("%s: config rom short read. Expected :%d, received: "
		    "%d. Not attaching\n", sc->sc_sc1394.sc1394_dev.dv_xname,
		    ab->ab_length, ab->ab_retlen));
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}
	if (ab->ab_retlen % 4) {
		DPRINTF(("%s: configrom read of invalid length: %d\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname, ab->ab_retlen));
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

	ab->ab_retlen = ab->ab_retlen / 4;

	if (cc != NULL) {
		cc->cc_buf[cc->cc_num++] = ab->ab_data[0];
		ab->ab_data[0] = 0;
		if (cc->cc_num < cc->cc_retlen) {
			ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM +
			    cc->cc_num * 4;
			ab->ab_length = 4;
			ab->ab_retlen = 0;
			ab->ab_cb = fwnode_configrom_input;
			ab->ab_cbarg = cc;
			sc->sc1394_read(ab);
			return;
		} else {
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;
			ab->ab_data = &cc->cc_buf[0];
			ab->ab_retlen = cc->cc_retlen;
			ab->ab_length = cc->cc_retlen * 4;
			FREE(cc, M_1394DATA);
			MPRINTF("FREE(1394DATA)", cc);
			cc = NULL;	/* XXX */
			ab->ab_cbarg = NULL;
		}
	}

	if (p1212_iscomplete(ab->ab_data, &ab->ab_retlen) == -1) {
		DPRINTF(("%s: configrom parse error\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname));
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
		return;
	}

#ifdef DIAGNOSTIC
	if (ab->ab_retlen < (ab->ab_length / 4))
		panic("Configrom shrank during iscomplete check?");
#endif

	if (ab->ab_retlen > (ab->ab_length / 4)) {

		if (cc != NULL) {	/* Should never occur here */
			DPRINTF(("%s: cbarg not NULL\n",
			    sc->sc_sc1394.sc1394_dev.dv_xname));
			free(ab->ab_data, M_1394DATA);
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
			FREE(ab, M_1394DATA);
			MPRINTF("FREE(1394DATA)", ab);
			ab = NULL;	/* XXX */
			return;
		}
		free(ab->ab_data, M_1394DATA);
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */

		if (ab->ab_length == 4) {	/* reread whole rom */
#ifdef	M_ZERO
			ab->ab_data = malloc(ab->ab_retlen * 4, M_1394DATA,
			    M_WAITOK|M_ZERO);
			MPRINTF("malloc(1394DATA)",ab->ab_data);
#else
			ab->ab_data = malloc(ab->ab_retlen * 4,
			    M_1394DATA, M_WAITOK);
			MPRINTF("malloc(1394DATA)",ab->ab_data);
			bzero(ab->ab_data, ab->ab_retlen * 4);
#endif

			ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM;
			ab->ab_length = ab->ab_retlen * 4;
			ab->ab_retlen = 0;
			ab->ab_cbarg = NULL;
			ab->ab_cb = fwnode_configrom_input;
			sc->sc1394_read(ab);
		} else {			/* reread quadlet-wise */
			DPRINTF(("%s: configrom re-read %d(0x%02x) quadlets"
			    " - 0x%08x\n", sc->sc_sc1394.sc1394_dev.dv_xname,
			    ab->ab_retlen, ab->ab_retlen, ab->ab_data[0]));

#ifdef	M_ZERO
			cbuf = malloc(ab->ab_retlen * 4, M_1394DATA,
			    M_WAITOK|M_ZERO);
			MPRINTF("malloc(1394DATA)", cbuf);
			MALLOC(cc, struct cfgrom_cbarg *, sizeof(*cc),
			    M_1394DATA, M_WAITOK|M_ZERO);
			MPRINTF("MALLOC(1394DATA)", cc);
#else
			cbuf = malloc(ab->ab_retlen * 4, M_1394DATA, M_WAITOK);
			MPRINTF("malloc(1394DATA)", cbuf);
			bzero(cbuf, ab->ab_retlen * 4);
			MALLOC(cc, struct cfgrom_cbarg *, sizeof(*cc),
			    M_1394DATA, M_WAITOK);
			MPRINTF("MALLOC(1394DATA)", cc);
			bzero(cc, sizeof(*cc));
#endif
			cc->cc_type = 0x31333934;
			cc->cc_retlen = ab->ab_retlen;
			cc->cc_num = 0;
			cc->cc_buf = cbuf;

			ab->ab_data = malloc(4, M_1394DATA, M_WAITOK);
			MPRINTF("malloc(1394DATA)", ab->ab_data);
			ab->ab_data[0] = 0;
			ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM;
			ab->ab_length = 4;
			ab->ab_retlen = 0;
			ab->ab_cb = fwnode_configrom_input;
			ab->ab_cbarg = cc;
			sc->sc1394_read(ab);
		}
		return;
	} else {
		DPRINTF(("configrom loaded...\n"));
		sc->sc_sc1394.sc1394_configrom_len = ab->ab_retlen;
		sc->sc_sc1394.sc1394_configrom = ab->ab_data;
		ab->ab_data = NULL;

		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */

		/*
		 * Set P1212_ALLOW_DEPENDENT_INFO_OFFSET_TYPE and
		 * P1212_ALLOW_DEPENDENT_INFO_IMMED_TYPE as some protocols
		 * such as SBP2 need it.
		 */

		val = P1212_ALLOW_DEPENDENT_INFO_OFFSET_TYPE;
		val |= P1212_ALLOW_DEPENDENT_INFO_IMMED_TYPE;
		val |= P1212_ALLOW_VENDOR_DIRECTORY_TYPE;
		sc->sc_configrom =
		    p1212_parse(sc->sc_sc1394.sc1394_configrom,
		    sc->sc_sc1394.sc1394_configrom_len, val);
		if ((sc->sc_configrom == NULL) ||
		    (sc->sc_configrom->len != IEEE1394_BUSINFO_LEN)) {
#ifdef	FWNODE_DEBUG
			DPRINTF(("Parse error with config rom\n"));
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
				sc->sc_sc1394.sc1394_configrom_len);
#endif	/* FWNODE_DEBUG */
			if (sc->sc_configrom)
				p1212_free(sc->sc_configrom);
			free(sc->sc_sc1394.sc1394_configrom, M_1394DATA);
			MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
			sc->sc_sc1394.sc1394_configrom = NULL;
			sc->sc_sc1394.sc1394_configrom_len = 0;
			return;
		}

		val = htonl(IEEE1394_SIGNATURE);
		if (memcmp(sc->sc_configrom->name, &val, 4)) {
#ifdef	FWNODE_DEBUG
			DPRINTF(("Invalid signature found in bus info block: "
				    "%s\n", sc->sc_configrom->name));
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
				sc->sc_sc1394.sc1394_configrom_len);
#endif	/* FWNODE_DEBUG */
			p1212_free(sc->sc_configrom);
			free(sc->sc_sc1394.sc1394_configrom, M_1394DATA);
			MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
			sc->sc_sc1394.sc1394_configrom = NULL;
			sc->sc_sc1394.sc1394_configrom_len = 0;
			return;
		}

		sc->sc_sc1394.sc1394_max_receive =
		    IEEE1394_GET_MAX_REC(ntohl(sc->sc_configrom->data[0]));
		val = IEEE1394_GET_LINK_SPD(ntohl(sc->sc_configrom->data[0]));
		DPRINTFN(1, ("%s: ConfigRom Link Speed: %s",
		    sc->sc_sc1394.sc1394_dev.dv_xname, ieee1394_speeds[val]));
		printf("%s: Link Speed: %s, max_rec: %d bytes\n",
		    sc->sc_sc1394.sc1394_dev.dv_xname,
		    ieee1394_speeds[sc->sc_sc1394.sc1394_link_speed],
		    IEEE1394_MAX_REC(sc->sc_sc1394.sc1394_max_receive));
#ifdef	FWNODE_DEBUG
		if (fwnodedebug) {
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
			    sc->sc_sc1394.sc1394_configrom_len);
			p1212_print(sc->sc_configrom->root);
		}
#endif	/* FWNODE_DEBUG */
		sc->sc_children = p1212_match_units(&sc->sc_sc1394.sc1394_dev,
			sc->sc_configrom->root, fwnode_print);
	}
}

int
fwnode_print(void *aux, const char *pnp)
{
	if (pnp)
		printf("Unknown device at %s", pnp);

	return UNCONF;
}

#ifdef	FWNODE_DEBUG
void
fwnode_dump_rom(struct fwnode_softc *sc, u_int32_t *t, u_int32_t len)
{
	int i;
	DPRINTF(("%s: Config rom dump:\n", sc->sc_sc1394.sc1394_dev.dv_xname));
	for (i = 0; i < len; i++) {
		if ((i % 4) == 0) {
			if (i)
				DPRINTF(("\n"));
			DPRINTF(("%s: 0x%02hx: ",
			    sc->sc_sc1394.sc1394_dev.dv_xname, (short)(4 * i)));
		}
		DPRINTF(("0x%08x ", ntohl(t[i])));
	}
	DPRINTF(("\n"));
}
#endif	/* FWNODE_DEBUG */
@


1.6
log
@Trust the link_speed from SelfID (PHY), better than a minimalist (usually
fixed) ConfigROM.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwnode.c,v 1.5 2002/12/13 21:35:11 tdeval Exp $	*/
@


1.5
log
@Malloc debug cleaning (MPRINTF).
Uses option FW_MALLOC_DEBUG.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwnode.c,v 1.4 2002/12/13 02:52:04 tdeval Exp $	*/
d152 1
d452 3
a454 2
		sc->sc_sc1394.sc1394_link_speed =
		    IEEE1394_GET_LINK_SPD(ntohl(sc->sc_configrom->data[0]));
@


1.4
log
@Better memory balancing (between alloc/free),
some enhancements, lots of debugging, KNF...
@
text
@d1 1
a1 1
/*	$OpenBSD: fwnode.c,v 1.3 2002/10/12 01:09:44 krw Exp $	*/
d91 1
d94 3
d142 1
a142 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d145 1
a145 1
	//MPRINTF_OLD("MALLOC(1394DATA)", ab);
d149 1
a149 1
	//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d191 1
a191 1
		//MPRINTF_OLD("free(DEVBUF)", sc->sc_children);
d198 1
a198 1
		//MPRINTF_OLD("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
d242 1
a242 1
			//MPRINTF_OLD("FREE(1394DATA)", cc);
d246 1
a246 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d249 1
a249 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d259 1
a259 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d262 1
a262 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d270 1
a270 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d273 1
a273 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d294 1
a294 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d300 1
a300 1
			//MPRINTF_OLD("FREE(1394DATA)", cc);
d310 1
a310 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d313 1
a313 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d329 1
a329 1
			//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d332 1
a332 1
			//MPRINTF_OLD("FREE(1394DATA)", ab);
d337 1
a337 1
		//MPRINTF_OLD("free(1394DATA)", ab->ab_data);
d344 1
a344 1
			//MPRINTF_OLD("malloc(1394DATA)",ab->ab_data);
d348 1
a348 1
			//MPRINTF_OLD("malloc(1394DATA)",ab->ab_data);
d366 1
a366 1
			//MPRINTF_OLD("malloc(1394DATA)", cbuf);
d369 1
a369 1
			//MPRINTF_OLD("MALLOC(1394DATA)", cc);
d372 1
a372 1
			//MPRINTF_OLD("malloc(1394DATA)", cbuf);
d376 1
a376 1
			//MPRINTF_OLD("MALLOC(1394DATA)", cc);
d385 1
a385 1
			//MPRINTF_OLD("malloc(1394DATA)", ab->ab_data);
d402 1
a402 1
		//MPRINTF_OLD("FREE(1394DATA)", ab);
d427 1
a427 1
			//MPRINTF_OLD("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
d443 1
a443 1
			//MPRINTF_OLD("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
@


1.3
log
@Remove more '\n's from panic() statements. Both trailing and leading.

Diff generated by Chris Kuethe.
@
text
@d1 1
a1 1
/*	$OpenBSD: fwnode.c,v 1.2 2002/06/26 14:04:02 tdeval Exp $	*/
d41 1
a41 1
#ifdef __KERNEL_RCSID
d62 3
a64 1
static const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
d75 25
a99 12
#ifdef FWNODE_DEBUG
void fwnode_dump_rom(struct fwnode_softc *,u_int32_t *, u_int32_t);
#endif

#ifdef FWNODE_DEBUG
#define DPRINTF(x)      if (fwnodedebug) printf x
#define DPRINTFN(n,x)   if (fwnodedebug>(n)) printf x
int     fwnodedebug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
d121 1
a121 1
	
d123 2
a124 2
		return 1;
	return 0;
d134 1
a134 1
	
d136 3
a138 1
	ab = malloc(sizeof(struct ieee1394_abuf), M_1394DATA, M_WAITOK|M_ZERO);
d140 3
a142 2
	ab = malloc(sizeof(struct ieee1394_abuf), M_1394DATA, M_WAITOK);
	bzero(ab, sizeof(struct ieee1394_abuf));
d145 1
d147 1
a147 1
	
d154 1
a154 1
	
d158 2
a159 2
	
	printf(" Node %d: UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n", 
d177 1
a177 1
        struct fwnode_softc *sc = (struct fwnode_softc *)self;
d179 1
a179 1
	
d182 1
a182 1
		while (*children++)
d184 2
d187 2
d190 1
a190 1
	
d192 1
a192 1
	    sc->sc_sc1394.sc1394_configrom_len)
d194 4
a197 1
	
d233 1
a233 1
#ifdef FWNODE_DEBUG
d235 6
a240 2
#endif
		if (cc != NULL) free(cc, M_1394DATA);
d242 5
a246 1
		free(ab, M_1394DATA);
a253 1
/*		if (cc != NULL) free(cc, M_1394DATA);	*/
d255 5
a259 1
		free(ab, M_1394DATA);
d261 1
a261 1
	} 
a264 1
/*		if (cc != NULL) free(cc, M_1394DATA);	*/
d266 5
a270 1
		free(ab, M_1394DATA);
d273 1
a273 1
	
a274 5
/*
	DPRINTF(("ab_length:%d/0x%02x ab_retlen:%d/0x%02x ab_data0:0x%08x\n",
	    ab->ab_length, ab->ab_length, ab->ab_retlen, ab->ab_retlen,
	    ab->ab_data[0], ab->ab_data[0]));
 */
a277 1
/*		free(ab->ab_data, M_1394DATA);	*/
a278 2
/*		wakeup(&cc->cc_num); DPRINTF(("wakeup %d\n", cc->cc_num)); */
/*		if (test != 0) {	*/
a279 2
/*			free(cc, M_1394DATA);	*/
/*			free(ab, M_1394DATA);	*/
a285 1
/*			DPRINTF(("re-submitting %d\n", cc->cc_num));	*/
a286 1
/*			DPRINTF(("re-submitted %d\n", cc->cc_num));	*/
d290 2
d295 3
a297 2
			free(cc, M_1394DATA);
			cc = NULL;
a298 3
#ifdef FWNODE_DEBUG
/*			fwnode_dump_rom(sc, ab->ab_data, ab->ab_retlen); */
#endif
d306 5
a310 1
		free(ab, M_1394DATA);
a312 5
/*
	DPRINTF(("ab_length:%d/0x%02x ab_retlen:%d/0x%02x ab_data0:0x%08x\n",
	    ab->ab_length, ab->ab_length, ab->ab_retlen, ab->ab_retlen,
	    ab->ab_data[0], ab->ab_data[0]));
 */
d318 1
a318 1
	
a323 1
/*			free(cc, M_1394DATA);	*/
d325 5
a329 1
			free(ab, M_1394DATA);
d333 2
d338 1
a338 1
			ab->ab_data = malloc(ab->ab_retlen * 4, M_1394DATA, 
d340 1
d344 1
d347 1
a347 1
		
d359 1
a359 1
#ifdef  M_ZERO
d362 4
a365 2
			cc = malloc(sizeof(struct cfgrom_cbarg), M_1394DATA,
			    M_WAITOK|M_ZERO);
d368 1
d370 4
a373 3
			cc = malloc(sizeof(struct cfgrom_cbarg), M_1394DATA,
			    M_WAITOK);
			bzero(cc, sizeof(struct cfgrom_cbarg));
a376 1
/*			cc->cc_num = i;	*/
d381 1
a382 1
/*			ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM + i * 4; */
a387 2
/*			splx(s);	*/
/*			DPRINTF(("submitting %d\n", cc->cc_num));	*/
a388 8
/*			DPRINTF(("submitted %d\n", cc->cc_num));	*/
#if 0
			s = tsleep(&cc->cc_num, PRIBIO, "cfgrom_wait", 1 * hz);
			DPRINTF(("returned %d\n", cc->cc_num));
			free(cc, M_1394DATA);
			if (s == EWOULDBLOCK) break;
			free(ab, M_1394DATA);
#endif
d396 6
a401 4
		
		free(ab, M_1394DATA);
		
		/* 
d404 1
a404 1
		 * such as SBP2 need it. 
d406 1
a406 1
		
d415 1
a415 1
#ifdef FWNODE_DEBUG
d417 1
a417 1
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom, 
d419 1
a419 1
#endif
d423 1
d428 1
a428 1
		
d431 1
a431 1
#ifdef FWNODE_DEBUG
d434 1
a434 1
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom, 
d436 1
a436 1
#endif
d438 2
d450 1
a450 1
		    sc->sc_sc1394.sc1394_dev.dv_xname, 
d453 7
a459 5
#ifdef FWNODE_DEBUG
		fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom, 
			sc->sc_sc1394.sc1394_configrom_len);
		p1212_print(sc->sc_configrom->root);
#endif
d470 1
a470 1
	
d474 1
a474 1
#ifdef FWNODE_DEBUG
d479 1
a479 1
	printf("%s: Config rom dump:\n", sc->sc_sc1394.sc1394_dev.dv_xname);
d483 3
a485 3
				printf("\n");
			printf("%s: 0x%02hx: ",
			    sc->sc_sc1394.sc1394_dev.dv_xname, (short)(4 * i));
d487 1
a487 1
		printf("0x%08x ", ntohl(t[i]));
d489 1
a489 1
	printf("\n");
d491 1
a491 1
#endif
@


1.3.2.1
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d41 1
a41 1
#ifdef	__KERNEL_RCSID
d62 1
a62 3
#if 0
const char * const ieee1394_speeds[] = { IEEE1394_SPD_STRINGS };
#endif
d73 12
a84 29
#ifdef	FWNODE_DEBUG
void fwnode_dump_rom(struct fwnode_softc *, u_int32_t *, u_int32_t);
#endif	/* FWNODE_DEBUG */

#ifdef	FWNODE_DEBUG
#include <sys/syslog.h>
extern int log_open;
int fwnode_oldlog;
#define	DPRINTF(x)	if (fwnodedebug) do {				\
	fwnode_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwnode_oldlog;				\
} while (0)
#define	DPRINTFN(n,x)	if (fwnodedebug>(n)) do {			\
	fwnode_oldlog = log_open; log_open = 1;				\
	addlog x; log_open = fwnode_oldlog;				\
} while (0)
#ifdef	FW_MALLOC_DEBUG
#define	MPRINTF(x,y)	DPRINTF(("%s[%d]: %s 0x%08x\n",			\
			    __func__, __LINE__, (x), (u_int32_t)(y)))
#else	/* !FW_MALLOC_DEBUG */
#define	MPRINTF(x,y)
#endif	/* FW_MALLOC_DEBUG */

int	fwnodedebug = 0;
#else	/* FWNODE_DEBUG */
#define	DPRINTF(x)
#define	DPRINTFN(n,x)
#define	MPRINTF(x,y)
#endif	/* ! FWNODE_DEBUG */
d106 1
a106 1

d108 2
a109 2
		return (1);
	return (0);
d119 1
a119 1

d121 1
a121 3
	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab),
	    M_1394DATA, M_WAITOK|M_ZERO);
	MPRINTF("MALLOC(1394DATA)", ab);
d123 2
a124 3
	MALLOC(ab, struct ieee1394_abuf *, sizeof(*ab), M_1394DATA, M_WAITOK);
	MPRINTF("MALLOC(1394DATA)", ab);
	bzero(ab, sizeof(*ab));
a126 1
	MPRINTF("malloc(1394DATA)", ab->ab_data);
d128 1
a128 2

	sc->sc_sc1394.sc1394_link_speed = fwa->link_speed;
d135 1
a135 1

d139 2
a140 2

	printf(" Node %d: UID %02x:%02x:%02x:%02x:%02x:%02x:%02x:%02x\n",
d158 1
a158 1
	struct fwnode_softc *sc = (struct fwnode_softc *)self;
d160 1
a160 1

d163 1
a163 1
		while (*children != NULL) {
a164 2
			children++;
		}
a165 2
		MPRINTF("free(DEVBUF)", sc->sc_children);
		sc->sc_children = NULL;
d167 1
a167 1

d169 1
a169 1
	    sc->sc_sc1394.sc1394_configrom_len) {
d171 1
a171 4
		MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
		sc->sc_sc1394.sc1394_configrom = NULL;
	}

d207 1
a207 1
#ifdef	FWNODE_DEBUG
d209 2
a210 6
#endif	/* FWNODE_DEBUG */
		if (cc != NULL) {
			FREE(cc, M_1394DATA);
			MPRINTF("FREE(1394DATA)", cc);
			cc = NULL;	/* XXX */
		}
d212 1
a212 5
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
d220 1
d222 1
a222 5
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
d224 1
a224 1
	}
d228 1
d230 1
a230 5
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
d233 1
a233 1

d235 5
d243 1
d245 2
d248 2
d256 1
d258 1
a261 2
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;
d265 2
a266 3
			FREE(cc, M_1394DATA);
			MPRINTF("FREE(1394DATA)", cc);
			cc = NULL;	/* XXX */
d268 3
d278 1
a278 5
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */
		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */
d281 5
d291 1
a291 1

d297 1
d299 1
a299 5
			MPRINTF("free(1394DATA)", ab->ab_data);
			ab->ab_data = NULL;	/* XXX */
			FREE(ab, M_1394DATA);
			MPRINTF("FREE(1394DATA)", ab);
			ab = NULL;	/* XXX */
a302 2
		MPRINTF("free(1394DATA)", ab->ab_data);
		ab->ab_data = NULL;	/* XXX */
d306 1
a306 1
			ab->ab_data = malloc(ab->ab_retlen * 4, M_1394DATA,
a307 1
			MPRINTF("malloc(1394DATA)",ab->ab_data);
a310 1
			MPRINTF("malloc(1394DATA)",ab->ab_data);
d313 1
a313 1

d325 1
a325 1
#ifdef	M_ZERO
d328 2
a329 4
			MPRINTF("malloc(1394DATA)", cbuf);
			MALLOC(cc, struct cfgrom_cbarg *, sizeof(*cc),
			    M_1394DATA, M_WAITOK|M_ZERO);
			MPRINTF("MALLOC(1394DATA)", cc);
a331 1
			MPRINTF("malloc(1394DATA)", cbuf);
d333 3
a335 4
			MALLOC(cc, struct cfgrom_cbarg *, sizeof(*cc),
			    M_1394DATA, M_WAITOK);
			MPRINTF("MALLOC(1394DATA)", cc);
			bzero(cc, sizeof(*cc));
d339 1
a343 1
			MPRINTF("malloc(1394DATA)", ab->ab_data);
d345 1
d351 2
d354 8
d369 4
a372 6

		FREE(ab, M_1394DATA);
		MPRINTF("FREE(1394DATA)", ab);
		ab = NULL;	/* XXX */

		/*
d375 1
a375 1
		 * such as SBP2 need it.
d377 1
a377 1

d386 1
a386 1
#ifdef	FWNODE_DEBUG
d388 1
a388 1
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
d390 1
a390 1
#endif	/* FWNODE_DEBUG */
a393 1
			MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
d398 1
a398 1

d401 1
a401 1
#ifdef	FWNODE_DEBUG
d404 1
a404 1
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
d406 1
a406 1
#endif	/* FWNODE_DEBUG */
a407 2
			free(sc->sc_sc1394.sc1394_configrom, M_1394DATA);
			MPRINTF("free(1394DATA)", sc->sc_sc1394.sc1394_configrom);
d415 2
a416 3
		val = IEEE1394_GET_LINK_SPD(ntohl(sc->sc_configrom->data[0]));
		DPRINTFN(1, ("%s: ConfigRom Link Speed: %s",
		    sc->sc_sc1394.sc1394_dev.dv_xname, ieee1394_speeds[val]));
d418 1
a418 1
		    sc->sc_sc1394.sc1394_dev.dv_xname,
d421 5
a425 7
#ifdef	FWNODE_DEBUG
		if (fwnodedebug) {
			fwnode_dump_rom(sc, sc->sc_sc1394.sc1394_configrom,
			    sc->sc_sc1394.sc1394_configrom_len);
			p1212_print(sc->sc_configrom->root);
		}
#endif	/* FWNODE_DEBUG */
d436 1
a436 1

d440 1
a440 1
#ifdef	FWNODE_DEBUG
d445 1
a445 1
	DPRINTF(("%s: Config rom dump:\n", sc->sc_sc1394.sc1394_dev.dv_xname));
d449 3
a451 3
				DPRINTF(("\n"));
			DPRINTF(("%s: 0x%02hx: ",
			    sc->sc_sc1394.sc1394_dev.dv_xname, (short)(4 * i)));
d453 1
a453 1
		DPRINTF(("0x%08x ", ntohl(t[i])));
d455 1
a455 1
	DPRINTF(("\n"));
d457 1
a457 1
#endif	/* FWNODE_DEBUG */
@


1.2
log
@configrom input failover + some KNF
ok itojun@@
@
text
@d1 1
a1 1
/*	$OpenBSD: fwnode.c,v 1.1 2002/06/25 17:11:49 itojun Exp $	*/
d201 1
a201 1
			panic("Got an invalid abuf on callback\n");
d289 1
a289 1
		panic("Configrom shrank during iscomplete check?\n");
@


1.1
log
@IEEE1394 infrastructure part.
IP-over-FW and SCSI over FW are being worked on.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d64 1
a64 1
#ifdef __NetBSD__
d71 2
a72 2
static void fwnode_configrom_input(struct ieee1394_abuf *, int);
static int  fwnode_print(void *, const char *);
d74 1
a74 1
static void fwnode_dump_rom(struct fwnode_softc *,u_int32_t *, u_int32_t);
d184 8
a191 1
static void
d195 10
a204 2
	u_int32_t val;
	
d210 1
a214 3
	
	if (ab->ab_cbarg)
		panic("Got an invalid abuf on callback\n");
d220 1
d228 1
d235 39
d281 5
d294 8
d303 5
a307 3
#ifdef M_ZERO
		ab->ab_data = malloc(ab->ab_retlen * 4, M_1394DATA, 
		    M_WAITOK|M_ZERO);
d309 3
a311 2
		ab->ab_data = malloc(ab->ab_retlen * 4, M_1394DATA, M_WAITOK);
		bzero(ab->ab_data, ab->ab_retlen * 4);
d314 49
a362 6
		ab->ab_addr = CSR_BASE + CSR_CONFIG_ROM;
		ab->ab_length = ab->ab_retlen * 4;
		ab->ab_retlen = 0;
		ab->ab_cbarg = NULL;
		ab->ab_cb = fwnode_configrom_input;
		sc->sc1394_read(ab);
d365 1
d401 1
d404 3
d431 1
a431 1
static int
d441 1
a441 1
static void
@

