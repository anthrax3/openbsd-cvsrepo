head	1.15;
access;
symbols
	OPENBSD_6_1_BASE:1.15
	OPENBSD_6_0:1.15.0.2
	OPENBSD_6_0_BASE:1.15
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.9.0.4
	OPENBSD_5_7_BASE:1.9
	OPENBSD_5_6:1.8.0.4
	OPENBSD_5_6_BASE:1.8
	OPENBSD_5_5:1.7.0.10
	OPENBSD_5_5_BASE:1.7
	OPENBSD_5_4:1.7.0.6
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.7.0.4
	OPENBSD_5_3_BASE:1.7
	OPENBSD_5_2:1.7.0.2
	OPENBSD_5_2_BASE:1.7
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.4
	OPENBSD_5_0:1.6.0.2
	OPENBSD_5_0_BASE:1.6
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3
	OPENBSD_4_8:1.2.0.2
	OPENBSD_4_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.15
date	2016.04.29.14.40.36;	author beck;	state Exp;
branches;
next	1.14;
commitid	p3EbVWCYrcYkiFMB;

1.14
date	2016.03.19.12.04.15;	author natano;	state Exp;
branches;
next	1.13;
commitid	gAjwyca5TfuoJAhn;

1.13
date	2015.11.20.16.06.53;	author deraadt;	state Exp;
branches;
next	1.12;
commitid	286NXZOWU0sYXBvc;

1.12
date	2015.08.30.03.09.14;	author deraadt;	state Exp;
branches;
next	1.11;
commitid	5RV5Mv2KSiBLukfj;

1.11
date	2015.05.07.08.53.33;	author mpi;	state Exp;
branches;
next	1.10;
commitid	c9ymkCbPubGplOgk;

1.10
date	2015.03.14.03.38.46;	author jsg;	state Exp;
branches;
next	1.9;
commitid	p4LJxGKbi0BU2cG6;

1.9
date	2014.12.16.18.30.03;	author tedu;	state Exp;
branches;
next	1.8;
commitid	P6Av4XGqOi3rFasL;

1.8
date	2014.07.12.18.48.17;	author tedu;	state Exp;
branches;
next	1.7;
commitid	I19imNlAX05zJOED;

1.7
date	2012.04.22.05.43.14;	author guenther;	state Exp;
branches;
next	1.6;

1.6
date	2011.07.07.23.45.00;	author matthew;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.02.16.53.17;	author jsing;	state Exp;
branches;
next	1.4;

1.4
date	2011.04.07.15.30.16;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.12.23.18.56;	author thib;	state Exp;
branches;
next	1.2;

1.2
date	2010.06.14.16.51.55;	author thib;	state Exp;
branches;
next	1.1;

1.1
date	2010.06.08.12.46.49;	author jsing;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Fix some gibbering horrors due to uninitialized struct nameidata's

1) turn NDINITAT into a function and make the macros point to it
with the later goal of getting rid of them.

2) Sweep the kernel for places where people make a struct nameidata manually
on the stack and fill in what they hope are the required fields and count
on prayer and clean living to always get them right. Instead use NDINIT
everywhere. NFS was especially bad for this and there have likely
been things lurking there for a while.

3) Add a couple of strategic KASSERT's to catch future offenders.

ok krw@@ sthen@@ deraadt@@
@
text
@/*	$OpenBSD: diskmap.c,v 1.14 2016/03/19 12:04:15 natano Exp $	*/

/*
 * Copyright (c) 2009, 2010 Joel Sing <jsing@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Disk mapper.
 */

#include <sys/param.h>
#include <sys/types.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/errno.h>
#include <sys/conf.h>
#include <sys/dkio.h>
#include <sys/disk.h>
#include <sys/disklabel.h>
#include <sys/file.h>
#include <sys/filedesc.h>
#include <sys/lock.h>
#include <sys/malloc.h>
#include <sys/namei.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/pledge.h>
#include <sys/namei.h>

int
diskmapopen(dev_t dev, int flag, int fmt, struct proc *p)
{
	return 0;
}

int
diskmapclose(dev_t dev, int flag, int fmt, struct proc *p)
{
	return 0;
}

int
diskmapioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct dk_diskmap *dm;
	struct nameidata ndp;
	struct filedesc *fdp;
	struct file *fp = NULL;
	struct vnode *vp = NULL, *ovp;
	char *devname;
	int fd, error = EINVAL;

	if (cmd != DIOCMAP)
		return EINVAL;

	/*
	 * Map a request for a disk to the correct device. We should be
	 * supplied with either a diskname or a disklabel UID.
	 */

	dm = (struct dk_diskmap *)addr;
	fd = dm->fd;
	devname = malloc(PATH_MAX, M_DEVBUF, M_WAITOK);
	if (copyinstr(dm->device, devname, PATH_MAX, NULL))
		goto invalid;
	if (disk_map(devname, devname, PATH_MAX, dm->flags) == 0)
		if (copyoutstr(devname, dm->device, PATH_MAX, NULL))
			goto invalid;

	/* Attempt to open actual device. */
	if ((error = getvnode(p, fd, &fp)) != 0)
		goto invalid;

	fdp = p->p_fd;
	fdplock(fdp);

	NDINIT(&ndp, 0, 0, UIO_SYSSPACE, devname, p);
	ndp.ni_pledge = PLEDGE_RPATH;
	if ((error = vn_open(&ndp, fp->f_flag, 0)) != 0)
		goto bad;

	vp = ndp.ni_vp;

	/* Close the original vnode. */
	ovp = (struct vnode *)fp->f_data;
	if (fp->f_flag & FWRITE)
		ovp->v_writecount--;

	if (ovp->v_writecount == 0) {
		vn_lock(ovp, LK_EXCLUSIVE | LK_RETRY, p);
		VOP_CLOSE(ovp, fp->f_flag, p->p_ucred, p);
		vput(ovp);
	}

	fp->f_type = DTYPE_VNODE;
	fp->f_ops = &vnops;
	fp->f_data = (caddr_t)vp;
	fp->f_offset = 0;
	fp->f_rxfer = 0;
	fp->f_wxfer = 0;
	fp->f_seek = 0;
	fp->f_rbytes = 0;
	fp->f_wbytes = 0;

	VOP_UNLOCK(vp, p);

	FRELE(fp, p);
	fdpunlock(fdp);
	free(devname, M_DEVBUF, PATH_MAX);

	return 0;

bad:
	if (vp)
		vput(vp);
	if (fp)
		FRELE(fp, p);

	fdpunlock(fdp);

invalid:
	free(devname, M_DEVBUF, PATH_MAX);

	return (error);
}

int
diskmapread(dev_t dev, struct uio *uio, int flag)
{
	return ENXIO;
}

int
diskmapwrite(dev_t dev, struct uio *uio, int flag)
{
	return ENXIO;
}
@


1.14
log
@Remove the unused flags argument from VOP_UNLOCK().

torture tested on amd64, i386 and macppc
ok beck mpi stefan
"the change looks right" deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.13 2015/11/20 16:06:53 deraadt Exp $	*/
d40 1
d89 1
a89 4
	ndp.ni_segflg = UIO_SYSSPACE;
	ndp.ni_dirfd = AT_FDCWD;
	ndp.ni_dirp = devname;
	ndp.ni_cnd.cn_proc = p;
@


1.13
log
@Add pledge "disklabel", which allows sysctl kern.rawpartition, a
few disklabel ioctls, and the DIOCMAP ioctl against /dev/diskmap used
to translate duid numbers into partitions.
This will allow pledging of at least 12 disk/filesystem aware
programs; due to the negative impact that diff will wait a bit so
everyone has a chance to update their kernels.
ok semarie
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.12 2015/08/30 03:09:14 deraadt Exp $	*/
d119 1
a119 1
	VOP_UNLOCK(vp, 0, p);
@


1.12
log
@size for free(); ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.11 2015/05/07 08:53:33 mpi Exp $	*/
d39 1
d92 1
@


1.11
log
@Pass a thread pointer instead of its file descriptor table to getvnode(9).

Input and ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.10 2015/03/14 03:38:46 jsg Exp $	*/
d121 1
a121 1
	free(devname, M_DEVBUF, 0);
d134 1
a134 1
	free(devname, M_DEVBUF, 0);
@


1.10
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.9 2014/12/16 18:30:03 tedu Exp $	*/
d81 3
a85 3

	if ((error = getvnode(fdp, fd, &fp)) != 0)
		goto bad;
@


1.9
log
@primary change: move uvm_vnode out of vnode, keeping only a pointer.
objective: vnode.h doesn't include uvm_extern.h anymore.
followup changes: include uvm_extern.h or lock.h where necessary.
ok and help from deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.8 2014/07/12 18:48:17 tedu Exp $	*/
a27 1
#include <sys/buf.h>
@


1.8
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.7 2012/04/22 05:43:14 guenther Exp $	*/
d35 1
@


1.7
log
@Add struct proc * argument to FRELE() and FILE_SET_MATURE() in
anticipation of further changes to closef().  No binary change.

ok krw@@ miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.6 2011/07/07 23:45:00 matthew Exp $	*/
d121 1
a121 1
	free(devname, M_DEVBUF);
d134 1
a134 1
	free(devname, M_DEVBUF);
@


1.6
log
@Add new syscall entries to support the openat(2) family of functions
added in POSIX Issue 7: openat(), mknodat(), mkfifoat(), linkat(),
symlinkat(), unlinkat(), faccessat(), fstatat(), readlinkat(),
fchmodat(), fchownat(), utimensat(), renameat(), and mkdirat().

This diff mostly just refactors the existing sys_foo() logic into a
common dofooat() function that can then be called by both sys_foo()
and sys_fooat().  Some of the new system calls support new flags to
control their behavior, and proper support for these will be added in
subsequent diffs.

Incorporating suggestions from thib@@, guenther@@, and tedu@@.

ok tedu@@, thib@@, deraadt@@, guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.5 2011/07/02 16:53:17 jsing Exp $	*/
d119 1
a119 1
	FRELE(fp);
d129 1
a129 1
		FRELE(fp);
@


1.5
log
@Use getvnode() instead of implementing our own file descriptor handling
code. This gets us some additional validation and correct reference
counting.

Issue spotted by matthew@@

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.3 2011/01/12 23:18:56 thib Exp $	*/
d88 1
@


1.4
log
@Do not use NULL in integer comparisons. No functional change.
ok matthew@@ tedu@@, also eyeballed by at least krw@@ oga@@ kettenis@@ jsg@@
@
text
@d58 1
a58 1
	struct file *fp;
d84 1
a84 2
	if ((u_int)fd >= fdp->fd_nfiles || (fp = fdp->fd_ofiles[fd]) == NULL) {
		error = EINVAL;
a85 6
	}

	if (!FILE_IS_USABLE(fp)) {
		error = EINVAL;
		goto bad;
	}
d118 2
a120 1
	fdpunlock(fdp);
d127 2
@


1.3
log
@Only init the nameidata parts that are strictly needed instead
of using NDINIT as vn_open overwrites and sets things up directly
it self.

the NDINIT usage here was actually wrong and would cause leaks
if vn_open would totally honor the nameidata it gets passed,
also there is one less place that triggers on my nameidata
flag greps...

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.2 2010/06/14 16:51:55 thib Exp $	*/
d89 1
a89 1
	if (FILE_IS_USABLE(fp) == NULL) {
@


1.2
log
@plug a memleak, free the devname when we succeed with
the ioctl. also remove an uneeded if (devname) check.

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: diskmap.c,v 1.1 2010/06/08 12:46:49 jsing Exp $	*/
d94 3
a96 3
	NDINIT(&ndp, LOOKUP, NOFOLLOW | LOCKLEAF | SAVENAME, UIO_SYSSPACE,
	    devname, p);

@


1.1
log
@Introduce a diskmap pseudo device which allows userland to open a disk
specified via its disklabel UID. The mapping from the disklabel UID to the
real disk and the opening of the resulting device is performed atomically
using a single ioctl.

ok krw@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d125 1
d137 1
a137 2
	if (devname)
		free(devname, M_DEVBUF);
@

