head	1.43;
access;
symbols
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.6
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.2
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.42.0.2
	OPENBSD_5_9_BASE:1.42
	OPENBSD_5_8:1.42.0.4
	OPENBSD_5_8_BASE:1.42
	OPENBSD_5_7:1.38.0.6
	OPENBSD_5_7_BASE:1.38
	OPENBSD_5_6:1.38.0.4
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.35.0.4
	OPENBSD_5_5_BASE:1.35
	OPENBSD_5_4:1.34.0.4
	OPENBSD_5_4_BASE:1.34
	OPENBSD_5_3:1.34.0.2
	OPENBSD_5_3_BASE:1.34
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.30.0.2
	OPENBSD_4_9_BASE:1.30
	OPENBSD_4_8:1.27.0.2
	OPENBSD_4_8_BASE:1.27
	OPENBSD_4_7:1.24.0.2
	OPENBSD_4_7_BASE:1.24
	OPENBSD_4_6:1.17.0.4
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.15.0.2
	OPENBSD_4_4_BASE:1.15
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.9.0.4
	OPENBSD_4_2_BASE:1.9
	OPENBSD_4_1:1.9.0.2
	OPENBSD_4_1_BASE:1.9
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.8.0.2
	OPENBSD_3_9_BASE:1.8
	OPENBSD_3_8:1.7.0.4
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.7.0.2
	OPENBSD_3_7_BASE:1.7
	OPENBSD_3_6:1.6.0.4
	OPENBSD_3_6_BASE:1.6
	SMP_SYNC_A:1.6
	SMP_SYNC_B:1.6
	OPENBSD_3_5:1.6.0.2
	OPENBSD_3_5_BASE:1.6
	OPENBSD_3_4:1.5.0.2
	OPENBSD_3_4_BASE:1.5
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.4.0.6
	OPENBSD_3_3_BASE:1.4
	OPENBSD_3_2:1.4.0.4
	OPENBSD_3_2_BASE:1.4
	OPENBSD_3_1:1.4.0.2
	OPENBSD_3_1_BASE:1.4
	UBC_SYNC_B:1.4
	UBC:1.2.0.8
	UBC_BASE:1.2
	OPENBSD_3_0:1.2.0.6
	OPENBSD_3_0_BASE:1.2
	SMP:1.2.0.4
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2;
locks; strict;
comment	@ * @;


1.43
date	2016.04.14.07.06.03;	author mlarkin;	state Exp;
branches;
next	1.42;
commitid	I8Ge5KP1RR5tYAiT;

1.42
date	2015.05.04.09.33.46;	author mpi;	state Exp;
branches;
next	1.41;
commitid	AEsxL0jOoaDjikVc;

1.41
date	2015.03.16.01.54.47;	author jcs;	state Exp;
branches;
next	1.40;
commitid	r8S2brpgzoW6BZhZ;

1.40
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.39;
commitid	p4LJxGKbi0BU2cG6;

1.39
date	2015.03.12.20.28.26;	author deraadt;	state Exp;
branches;
next	1.38;
commitid	b4GpIOJh3xdhlHXS;

1.38
date	2014.07.24.22.38.19;	author mpi;	state Exp;
branches;
next	1.37;
commitid	YuBsPUVnY4iDocx9;

1.37
date	2014.03.23.11.48.23;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2014.03.13.07.48.14;	author ratchov;	state Exp;
branches;
next	1.35;

1.35
date	2014.01.26.17.48.08;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2013.02.15.10.20.07;	author ratchov;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.06.18.07.07;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2012.08.10.17.49.31;	author shadchin;	state Exp;
branches;
next	1.31;

1.31
date	2011.03.17.15.42.05;	author shadchin;	state Exp;
branches;
next	1.30;

1.30
date	2010.12.16.20.18.31;	author shadchin;	state Exp;
branches;
next	1.29;

1.29
date	2010.12.03.18.29.56;	author shadchin;	state Exp;
branches;
next	1.28;

1.28
date	2010.08.28.12.49.57;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2010.07.22.14.26.38;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2010.07.21.20.10.17;	author miod;	state Exp;
branches;
next	1.25;

1.25
date	2010.07.08.19.29.25;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2009.11.23.23.22.38;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2009.11.23.15.21.41;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.23.01.33.08;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.13.19.33.16;	author pirofti;	state Exp;
branches;
next	1.20;

1.20
date	2009.08.25.19.16.36;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2009.08.13.21.46.23;	author pirofti;	state Exp;
branches;
next	1.18;

1.18
date	2009.08.13.21.15.03;	author pirofti;	state Exp;
branches;
next	1.17;

1.17
date	2009.05.03.13.02.35;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2008.11.21.14.38.03;	author robert;	state Exp;
branches;
next	1.15;

1.15
date	2008.07.16.20.00.45;	author miod;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.17;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.12.31.17.08.07;	author miod;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.17.21.54.29;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.17.01.32.46;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2007.10.17.01.16.04;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.30.20.45.05;	author jcs;	state Exp;
branches;
next	1.8;

1.8
date	2005.12.29.12.31.29;	author martin;	state Exp;
branches;
next	1.7;

1.7
date	2005.02.22.16.17.31;	author mickey;	state Exp;
branches;
next	1.6;

1.6
date	2003.10.22.09.44.22;	author jmc;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.02.23.28.03;	author millert;	state Exp;
branches;
next	1.4;

1.4
date	2002.03.14.01.27.00;	author millert;	state Exp;
branches;
next	1.3;

1.3
date	2002.02.18.05.25.14;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2001.02.02.20.19.04;	author aaron;	state Exp;
branches
	1.2.4.1
	1.2.8.1;
next	1.1;

1.1
date	2000.11.13.20.12.34;	author aaron;	state Exp;
branches;
next	;

1.2.4.1
date	2001.05.14.22.26.04;	author niklas;	state Exp;
branches;
next	1.2.4.2;

1.2.4.2
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.2.4.3;

1.2.4.3
date	2002.03.30.08.19.20;	author niklas;	state Exp;
branches;
next	1.2.4.4;

1.2.4.4
date	2003.06.07.11.02.31;	author ho;	state Exp;
branches;
next	1.2.4.5;

1.2.4.5
date	2004.02.19.10.56.30;	author niklas;	state Exp;
branches;
next	;

1.2.8.1
date	2002.06.11.03.42.27;	author art;	state Exp;
branches;
next	;


desc
@@


1.43
log
@
Re-enable pckbd on resume (similar to what we do on boot). Fixes problems
on (at least) various HP laptops that previously had no working keyboard
after resuming from 'zzz'.

Reported by Aleksandar Lakic, who also verified several versions of the
diff during development, thanks.

discussed with miod and kettenis, tested by many others on tech@@ - thanks.
@
text
@/* $OpenBSD: pckbd.c,v 1.42 2015/05/04 09:33:46 mpi Exp $ */
/* $NetBSD: pckbd.c,v 1.24 2000/06/05 22:20:57 sommerfeld Exp $ */

/*-
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Charles M. Hannum.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*-
 * Copyright (c) 1990 The Regents of the University of California.
 * All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * William Jolitz and Don Ahn.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 *	@@(#)pccons.c	5.11 (Berkeley) 5/21/91
 */

/*
 * code to work keyboard for PC-style console
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>

#include <machine/bus.h>

#include <dev/ic/pckbcvar.h>
#include <dev/pckbc/pckbdreg.h>
#include <dev/pckbc/pmsreg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wskbdvar.h>
#include <dev/wscons/wsksymdef.h>
#include <dev/wscons/wsksymvar.h>

#include <dev/pckbc/wskbdmap_mfii.h>

struct pckbd_internal {
	int t_isconsole;
	pckbc_tag_t t_kbctag;
	pckbc_slot_t t_kbcslot;

	int t_translating;
	int t_table;

	int t_lastchar;
	int t_extended;
	int t_extended1;
	int t_releasing;

	struct pckbd_softc *t_sc; /* back pointer */
};

struct pckbd_softc {
        struct  device sc_dev;

	struct pckbd_internal *id;
	int sc_enabled;

	int sc_ledstate;

	struct device *sc_wskbddev;
#ifdef WSDISPLAY_COMPAT_RAWKBD
	int	rawkbd;
	u_int	sc_rawcnt;
	char	sc_rawbuf[3];
#endif
};

static int pckbd_is_console(pckbc_tag_t, pckbc_slot_t);

int pckbdprobe(struct device *, void *, void *);
void pckbdattach(struct device *, struct device *, void *);
int pckbdactivate(struct device *, int);

struct cfattach pckbd_ca = {
	sizeof(struct pckbd_softc), 
	pckbdprobe, 
	pckbdattach, 
	NULL, 
	pckbdactivate
};

int	pckbd_enable(void *, int);
void	pckbd_set_leds(void *, int);
int	pckbd_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wskbd_accessops pckbd_accessops = {
	pckbd_enable,
	pckbd_set_leds,
	pckbd_ioctl,
};

void	pckbd_cngetc(void *, u_int *, int *);
void	pckbd_cnpollc(void *, int);
void	pckbd_cnbell(void *, u_int, u_int, u_int);

const struct wskbd_consops pckbd_consops = {
	pckbd_cngetc,
	pckbd_cnpollc,
	pckbd_cnbell,
};

const struct wskbd_mapdata pckbd_keymapdata = {
	pckbd_keydesctab,
#ifdef PCKBD_LAYOUT
	PCKBD_LAYOUT,
#else
	KB_US | KB_DEFAULT,
#endif
};

/*
 * Hackish support for a bell on the PC Keyboard; when a suitable feeper
 * is found, it attaches itself into the pckbd driver here.
 */
void	(*pckbd_bell_fn)(void *, u_int, u_int, u_int, int);
void	*pckbd_bell_fn_arg;

void	pckbd_bell(u_int, u_int, u_int, int);

int	pckbd_scancode_translate(struct pckbd_internal *, int);
int	pckbd_set_xtscancode(pckbc_tag_t, pckbc_slot_t,
	    struct pckbd_internal *);
void	pckbd_init(struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t, int);
void	pckbd_input(void *, int);

static int	pckbd_decode(struct pckbd_internal *, int,
				  u_int *, int *);
static int	pckbd_led_encode(int);

struct pckbd_internal pckbd_consdata;

int
pckbdactivate(struct device *self, int act)
{
	struct pckbd_softc *sc = (struct pckbd_softc *)self;
	int rv = 0;
	u_char cmd[1];

	switch(act) {
	case DVACT_RESUME:
		if (sc->sc_enabled) {
			/*
			 * Some keyboards are not enabled after a reset,
			 * so make sure it is enabled now.
			 */
			cmd[0] = KBC_ENABLE;
			(void) pckbc_poll_cmd(sc->id->t_kbctag,
			    sc->id->t_kbcslot, cmd, 1, 0, NULL, 0);
			/* XXX - also invoke pckbd_set_xtscancode() too? */
		}
		break;
	}

	rv = config_activate_children(self, act);

	return (rv);
}

int
pckbd_set_xtscancode(pckbc_tag_t kbctag, pckbc_slot_t kbcslot,
    struct pckbd_internal *id)
{
	/* default to have the 8042 translate the keyboard with table 3. */
	int table = 3;

	if (pckbc_xt_translation(kbctag)) {
#ifdef DEBUG
		printf("pckbd: enabling of translation failed\n");
#endif
		/*
		 * Since the keyboard controller can not translate scan
		 * codes to the XT set (#1), we would like to request
		 * this exact set. However it is likely that the
		 * controller does not support it either.
		 *
		 * So try scan code set #2 as well, which this driver
		 * knows how to translate.
		 */
		table = 2;
		if (id != NULL)
			id->t_translating = 0;
	} else {
		if (id != NULL)
			id->t_translating = 1;
	}

	/* keep falling back until we hit a table that looks usable. */
	for (; table >= 1; table--) {
		u_char cmd[2];
#ifdef DEBUG
		printf("pckbd: trying table %d\n", table);
#endif
		cmd[0] = KBC_SETTABLE;
		cmd[1] = table;
		if (pckbc_poll_cmd(kbctag, kbcslot, cmd, 2, 0, NULL, 0)) {
#ifdef DEBUG
			printf("pckbd: table set of %d failed\n", table);
#endif
			if (table > 1) {
				cmd[0] = KBC_RESET;
				(void)pckbc_poll_cmd(kbctag, kbcslot, cmd,
				    1, 1, NULL, 1);
				pckbc_flush(kbctag, kbcslot);

				continue;
			}
		}

		/*
		 * the 8042 took the table set request, however, not all that
		 * report they can work with table 3 actually work, so ask what
		 * table it reports it's in.
		 */
		if (table == 3) {
			u_char resp[1];

			cmd[0] = KBC_SETTABLE;
			cmd[1] = 0;
			if (pckbc_poll_cmd(kbctag, kbcslot, cmd, 2, 1, resp, 0)) {
				/*
				 * query failed, step down to table 2 to be
				 * safe.
				 */
#ifdef DEBUG
				printf("pckbd: table 3 verification failed\n");
#endif
				continue;
			} else if (resp[0] == 3) {
#ifdef DEBUG
				printf("pckbd: settling on table 3\n");
#endif
				break;
			}
#ifdef DEBUG
			else
				printf("pckbd: table \"%x\" != 3, trying 2\n",
					resp[0]);
#endif
		} else {
#ifdef DEBUG
			printf("pckbd: settling on table %d\n", table);
#endif
			break;
		}
	}

	if (table == 0)
		return (1);

	if (id != NULL)
		id->t_table = table;

	return (0);
}

static int
pckbd_is_console(pckbc_tag_t tag, pckbc_slot_t slot)
{
	return (pckbd_consdata.t_isconsole &&
		(tag == pckbd_consdata.t_kbctag) &&
		(slot == pckbd_consdata.t_kbcslot));
}

/*
 * these are both bad jokes
 */
int
pckbdprobe(struct device *parent, void *match, void *aux)
{
	struct cfdata *cf = match;
	struct pckbc_attach_args *pa = aux;
	u_char cmd[1], resp[1];
	int res;

	/*
	 * XXX There are rumours that a keyboard can be connected
	 * to the aux port as well. For me, this didn't work.
	 * For further experiments, allow it if explicitly
	 * wired in the config file.
	 */
	if ((pa->pa_slot != PCKBC_KBD_SLOT) &&
	    (cf->cf_loc[PCKBCCF_SLOT] == PCKBCCF_SLOT_DEFAULT))
		return (0);

	/* Flush any garbage. */
	pckbc_flush(pa->pa_tag, pa->pa_slot);

	/* Reset the keyboard. */
	cmd[0] = KBC_RESET;
	res = pckbc_poll_cmd(pa->pa_tag, pa->pa_slot, cmd, 1, 1, resp, 1);
	if (res) {
#ifdef DEBUG
		printf("pckbdprobe: reset error %d\n", res);
#endif
		/*
		 * There is probably no keyboard connected.
		 * Let the probe succeed if the keyboard is used
		 * as console input - it can be connected later.
		 */
#if defined(__i386__) || defined(__amd64__)
		/*
		 * However, on legacy-free PCs, there might really
		 * be no PS/2 connector at all; in that case, do not
		 * even try to attach; ukbd will take over as console.
		 */
		if (res == ENXIO) {
			/* check cf_flags from parent */
			struct cfdata *cf = parent->dv_cfdata;
			if (!ISSET(cf->cf_flags, PCKBCF_FORCE_KEYBOARD_PRESENT))
				return 0;
		}
#endif
		return (pckbd_is_console(pa->pa_tag, pa->pa_slot) ? 1 : 0);
	}
	if (resp[0] != KBR_RSTDONE) {
		printf("pckbdprobe: reset response 0x%x\n", resp[0]);
		return (0);
	}

	/*
	 * Some keyboards seem to leave a second ack byte after the reset.
	 * This is kind of stupid, but we account for them anyway by just
	 * flushing the buffer.
	 */
	pckbc_flush(pa->pa_tag, pa->pa_slot);

	return (2);
}

void
pckbdattach(struct device *parent, struct device *self, void *aux)
{
	struct pckbd_softc *sc = (void *)self;
	struct pckbc_attach_args *pa = aux;
	int isconsole;
	struct wskbddev_attach_args a;
	u_char cmd[1];

	isconsole = pckbd_is_console(pa->pa_tag, pa->pa_slot);

	if (isconsole) {
		sc->id = &pckbd_consdata;
		if (sc->id->t_table == 0)
			pckbd_set_xtscancode(pa->pa_tag, pa->pa_slot, sc->id);

		/*
		 * Some keyboards are not enabled after a reset,
		 * so make sure it is enabled now.
		 */
		cmd[0] = KBC_ENABLE;
		(void) pckbc_poll_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
		    cmd, 1, 0, NULL, 0);
		sc->sc_enabled = 1;
	} else {
		sc->id = malloc(sizeof(struct pckbd_internal),
				M_DEVBUF, M_WAITOK);
		pckbd_init(sc->id, pa->pa_tag, pa->pa_slot, 0);
		pckbd_set_xtscancode(pa->pa_tag, pa->pa_slot, sc->id);

		/* no interrupts until enabled */
		cmd[0] = KBC_DISABLE;
		(void) pckbc_poll_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
				      cmd, 1, 0, NULL, 0);
		sc->sc_enabled = 0;
	}

	sc->id->t_sc = sc;

	pckbc_set_inputhandler(sc->id->t_kbctag, sc->id->t_kbcslot,
			       pckbd_input, sc, sc->sc_dev.dv_xname);

	a.console = isconsole;

	a.keymap = &pckbd_keymapdata;

	a.accessops = &pckbd_accessops;
	a.accesscookie = sc;

	printf("\n");

	/*
	 * Attach the wskbd, saving a handle to it.
	 */
	sc->sc_wskbddev = config_found(self, &a, wskbddevprint);
}

int
pckbd_enable(void *v, int on)
{
	struct pckbd_softc *sc = v;
	u_char cmd[1];
	int res;

	if (on) {
		if (sc->sc_enabled)
			return (EBUSY);

		pckbc_slot_enable(sc->id->t_kbctag, sc->id->t_kbcslot, 1);

		cmd[0] = KBC_ENABLE;
		res = pckbc_poll_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
					cmd, 1, 0, NULL, 0);
		if (res) {
			printf("pckbd_enable: command error\n");
			return (res);
		}

		res = pckbd_set_xtscancode(sc->id->t_kbctag,
					   sc->id->t_kbcslot, sc->id);
		if (res)
			return (res);

		sc->sc_enabled = 1;
	} else {
		if (sc->id->t_isconsole)
			return (EBUSY);

		cmd[0] = KBC_DISABLE;
		res = pckbc_enqueue_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
					cmd, 1, 0, 1, 0);
		if (res) {
			printf("pckbd_disable: command error\n");
			return (res);
		}

		pckbc_slot_enable(sc->id->t_kbctag, sc->id->t_kbcslot, 0);

		sc->sc_enabled = 0;
	}

	return (0);
}

const u_int8_t pckbd_xtbl[] = {
/* 0x00 */
	0,
	0x43,		/* F9 */
	0,
	0x3f,		/* F5 */
	0x3d,		/* F3 */
	0x3b,		/* F1 */
	0x3c,		/* F2 */
	0x58,		/* F12 */
	0x40,		/* F6 according to documentation */
	0x44,		/* F10 */
	0x42,		/* F8 */
	0x40,		/* F6 according to experimentation */
	0x3e,		/* F4 */
	0x0f,		/* Tab */
	0x29,		/* ` ~ */
	0,
/* 0x10 */
	0,
	0x38,		/* Left Alt */
	0x2a,		/* Left Shift */
	0,
	0x1d,		/* Left Ctrl */
	0x10,		/* q */
	0x02,		/* 1 ! */
	0,
	0,
	0,
	0x2c,		/* z */
	0x1f,		/* s */
	0x1e,		/* a */
	0x11,		/* w */
	0x03,		/* 2 @@ */
	0,
/* 0x20 */	
	0,
	0x2e,		/* c */
	0x2d,		/* x */
	0x20,		/* d */
	0x12,		/* e */
	0x05,		/* 4 $ */
	0x04,		/* 3 # */
	0,
	0,
	0x39,		/* Space */
	0x2f,		/* v */
	0x21,		/* f */
	0x14,		/* t */
	0x13,		/* r */
	0x06,		/* 5 % */
	0,
/* 0x30 */
	0,
	0x31,		/* n */
	0x30,		/* b */
	0x23,		/* h */
	0x22,		/* g */
	0x15,		/* y */
	0x07,		/* 6 ^ */
	0,
	0,
	0,
	0x32,		/* m */
	0x24,		/* j */
	0x16,		/* u */
	0x08,		/* 7 & */
	0x09,		/* 8 * */
	0,
/* 0x40 */
	0,
	0x33,		/* , < */
	0x25,		/* k */
	0x17,		/* i */
	0x18,		/* o */
	0x0b,		/* 0 ) */
	0x0a,		/* 9 ( */
	0,
	0,
	0x34,		/* . > */
	0x35,		/* / ? */
	0x26,		/* l */
	0x27,		/* ; : */
	0x19,		/* p */
	0x0c,		/* - _ */
	0,
/* 0x50 */
	0,
	0,
	0x28,		/* ' " */
	0,
	0x1a,		/* [ { */
	0x0d,		/* = + */
	0,
	0,
	0x3a,		/* Caps Lock */
	0x36,		/* Right Shift */
	0x1c,		/* Return */
	0x1b,		/* ] } */
	0,
	0x2b,		/* \ | */
	0,
	0,
/* 0x60 */
	0,
	0,
	0,
	0,
	0,
	0,
	0x0e,		/* Back Space */
	0,
	0,
	0x4f,		/* KP 1 */
	0,
	0x4b,		/* KP 4 */
	0x47,		/* KP 7 */
	0,
	0,
	0,
/* 0x70 */
	0x52,		/* KP 0 */
	0x53,		/* KP . */
	0x50,		/* KP 2 */
	0x4c,		/* KP 5 */
	0x4d,		/* KP 6 */
	0x48,		/* KP 8 */
	0x01,		/* Escape */
	0x45,		/* Num Lock */
	0x57,		/* F11 */
	0x4e,		/* KP + */
	0x51,		/* KP 3 */
	0x4a,		/* KP - */
	0x37,		/* KP * */
	0x49,		/* KP 9 */
	0x46,		/* Scroll Lock */
	0,
/* 0x80 */
	0,
	0,
	0,
	0x41,		/* F7 (produced as an actual 8 bit code) */
	0		/* Alt-Print Screen */
};

const u_int8_t pckbd_xtbl_ext[] = {
/* 0x00 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
/* 0x10 */
	0,
	0x38,		/* Right Alt */
	0,		/* E0 12, to be ignored */
	0,
	0x1d,		/* Right Ctrl */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
/* 0x20 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
/* 0x30 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
/* 0x40 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0x55,		/* KP / */
	0,
	0,
	0,
	0,
	0,
/* 0x50 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0x1c,		/* KP Return */
	0,
	0,
	0,
	0,
	0,
/* 0x60 */
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0,
	0x4f,		/* End */
	0,
	0x4b,		/* Left */
	0x47,		/* Home */
	0,
	0,
	0,
/* 0x70 */
	0x52,		/* Insert */
	0x53,		/* Delete */
	0x50,		/* Down */
	0,
	0x4d,		/* Right */
	0x48,		/* Up */
	0,
	0,
	0,
	0,
	0x51,		/* Page Down */
	0,
	0x37,		/* Print Screen */
	0x49,		/* Page Up */
	0x46,		/* Ctrl-Break */
	0
};

/*
 * Translate scan codes from set 2 to set 1
 */
int
pckbd_scancode_translate(struct pckbd_internal *id, int datain)
{
	if (id->t_translating != 0 || id->t_table == 1)
		return datain;

	if (datain == KBR_BREAK) {
		id->t_releasing = 0x80;	/* next keycode is a release */
		return 0;	/* consume scancode */
	}

	/*
	 * Convert BREAK sequence (14 77 -> 1D 45)
	 */
	if (id->t_extended1 == 2 && datain == 0x14)
		return 0x1d | id->t_releasing;
	else if (id->t_extended1 == 1 && datain == 0x77)
		return 0x45 | id->t_releasing;

	if (id->t_extended != 0) {
		if (datain >= sizeof pckbd_xtbl_ext)
			datain = 0;
		else
			datain = pckbd_xtbl_ext[datain];
	} else {
		if (datain >= sizeof pckbd_xtbl)
			datain = 0;
		else
			datain = pckbd_xtbl[datain];
	}

	if (datain == 0) {
		/*
		 * We don't know how to translate this scan code, but
		 * we can't silently eat it either (because there might
		 * have been an extended byte transmitted already).
		 * Hopefully this value will be harmless to the upper
		 * layers.
		 */
		return 0xff;
	}

	return datain | id->t_releasing;
}

static int
pckbd_decode(struct pckbd_internal *id, int datain, u_int *type, int *dataout)
{
	int key;
	int releasing;

	if (datain == KBR_EXTENDED0) {
		id->t_extended = 0x80;
		return 0;
	} else if (datain == KBR_EXTENDED1) {
		id->t_extended1 = 2;
		return 0;
	}

	releasing = datain & 0x80;
	datain &= 0x7f;

	/*
	 * process BREAK key sequence (EXT1 1D 45 / EXT1 9D C5):
	 * map to (unused) code 7F
	 */
	if (id->t_extended1 == 2 && datain == 0x1d) {
		id->t_extended1 = 1;
		return 0;
	} else if (id->t_extended1 == 1 && datain == 0x45) {
		id->t_extended1 = 0;
		datain = 0x7f;
	} else
		id->t_extended1 = 0;

	if (id->t_translating != 0 || id->t_table == 1) {
		id->t_releasing = releasing;
	} else {
		/* id->t_releasing computed in pckbd_scancode_translate() */
	}

	/* map extended keys to (unused) codes 128-254 */
	key = datain | id->t_extended;
	id->t_extended = 0;

	if (id->t_releasing) {
		id->t_releasing = 0;
		id->t_lastchar = 0;
		*type = WSCONS_EVENT_KEY_UP;
	} else {
		/* Always ignore typematic keys */
		if (key == id->t_lastchar)
			return 0;
		id->t_lastchar = key;
		*type = WSCONS_EVENT_KEY_DOWN;
	}

	*dataout = key;
	return 1;
}

void
pckbd_init(struct pckbd_internal *t, pckbc_tag_t kbctag, pckbc_slot_t kbcslot,
    int console)
{
	bzero(t, sizeof(struct pckbd_internal));

	t->t_isconsole = console;
	t->t_kbctag = kbctag;
	t->t_kbcslot = kbcslot;
}

static int
pckbd_led_encode(int led)
{
	int res;

	res = 0;

	if (led & WSKBD_LED_SCROLL)
		res |= 0x01;
	if (led & WSKBD_LED_NUM)
		res |= 0x02;
	if (led & WSKBD_LED_CAPS)
		res |= 0x04;
	return(res);
}

void
pckbd_set_leds(void *v, int leds)
{
	struct pckbd_softc *sc = v;
	u_char cmd[2];

	cmd[0] = KBC_MODEIND;
	cmd[1] = pckbd_led_encode(leds);
	sc->sc_ledstate = leds;

	(void) pckbc_enqueue_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
				 cmd, 2, 0, 0, 0);
}

/*
 * Got a console receive interrupt -
 * the console processor wants to give us a character.
 */
void
pckbd_input(void *vsc, int data)
{
	struct pckbd_softc *sc = vsc;
	int rc, type, key;

	data = pckbd_scancode_translate(sc->id, data);
	if (data == 0)
		return;

	rc = pckbd_decode(sc->id, data, &type, &key);

#ifdef WSDISPLAY_COMPAT_RAWKBD
	if (sc->rawkbd) {
		sc->sc_rawbuf[sc->sc_rawcnt++] = (char)data;

		if (rc != 0 || sc->sc_rawcnt == sizeof(sc->sc_rawbuf)) {
			wskbd_rawinput(sc->sc_wskbddev, sc->sc_rawbuf,
			    sc->sc_rawcnt);
			sc->sc_rawcnt = 0;
		}

		/*
		 * Pass audio keys to wskbd_input anyway.
		 */
		if (rc == 0 || (key != 160 && key != 174 && key != 176))
			return;
	}
#endif
	if (rc != 0)
		wskbd_input(sc->sc_wskbddev, type, key);
}

int
pckbd_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pckbd_softc *sc = v;

	switch (cmd) {
	    case WSKBDIO_GTYPE:
		*(int *)data = WSKBD_TYPE_PC_XT;
		return 0;
	    case WSKBDIO_SETLEDS: {
		char cmd[2];
		int res;
		cmd[0] = KBC_MODEIND;
		cmd[1] = pckbd_led_encode(*(int *)data);
		sc->sc_ledstate = *(int *)data & (WSKBD_LED_SCROLL |
		    WSKBD_LED_NUM | WSKBD_LED_CAPS);
		res = pckbc_enqueue_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
					cmd, 2, 0, 1, 0);
		return (res);
		}
	    case WSKBDIO_GETLEDS:
		*(int *)data = sc->sc_ledstate;
		return (0);
	    case WSKBDIO_COMPLEXBELL:
#define d ((struct wskbd_bell_data *)data)
		/*
		 * Keyboard can't beep directly; we have an
		 * externally-provided global hook to do this.
		 */
		pckbd_bell(d->pitch, d->period, d->volume, 0);
#undef d
		return (0);
#ifdef WSDISPLAY_COMPAT_RAWKBD
	    case WSKBDIO_SETMODE:
		sc->rawkbd = (*(int *)data == WSKBD_RAW);
		return (0);
#endif
	}
	return -1;
}

void
pckbd_bell(u_int pitch, u_int period, u_int volume, int poll)
{

	if (pckbd_bell_fn != NULL)
		(*pckbd_bell_fn)(pckbd_bell_fn_arg, pitch, period,
		    volume, poll);
}

void
pckbd_hookup_bell(void (*fn)(void *, u_int, u_int, u_int, int), void *arg)
{

	if (pckbd_bell_fn == NULL) {
		pckbd_bell_fn = fn;
		pckbd_bell_fn_arg = arg;
	}
}

int
pckbd_cnattach(pckbc_tag_t kbctag)
{

	pckbd_init(&pckbd_consdata, kbctag, PCKBC_KBD_SLOT, 1);

	wskbd_cnattach(&pckbd_consops, &pckbd_consdata, &pckbd_keymapdata);

	return (0);
}

/* ARGSUSED */
void
pckbd_cngetc(void *v, u_int *type, int *data)
{
        struct pckbd_internal *t = v;
	int val;

	for (;;) {
		val = pckbc_poll_data(t->t_kbctag, t->t_kbcslot);
		if (val == -1)
			continue;

		val = pckbd_scancode_translate(t, val);
		if (val == 0)
			continue;

		if (pckbd_decode(t, val, type, data))
			return;
	}
}

void
pckbd_cnpollc(void *v, int on)
{
	struct pckbd_internal *t = v;

	pckbc_set_poll(t->t_kbctag, t->t_kbcslot, on);

	/*
	 * If we enter ukc or ddb before having attached the console
	 * keyboard we need to probe its scan code set.
	 */
	if (t->t_table == 0) {
		char cmd[1];

		pckbc_flush(t->t_kbctag, t->t_kbcslot);
		pckbd_set_xtscancode(t->t_kbctag, t->t_kbcslot, t);

		/* Just to be sure. */
		cmd[0] = KBC_ENABLE;
		pckbc_poll_cmd(t->t_kbctag, PCKBC_KBD_SLOT, cmd, 1, 0, NULL, 0);
	}
}

void
pckbd_cnbell(void *v, u_int pitch, u_int period, u_int volume)
{

	pckbd_bell(pitch, period, volume, 1);
}

struct cfdriver pckbd_cd = {
	NULL, "pckbd", DV_DULL
};
@


1.42
log
@Print irq informations in pckbc_set_inputhandler().

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.41 2015/03/16 01:54:47 jcs Exp $ */
d126 1
d133 1
a133 1
	NULL
d185 27
@


1.41
log
@Revert 1.39.  Resetting after specifically putting the keyboard in a
different table will most likely just revert the keyboard to its
default table anyway.

Instead, just flush the kbd slot before choosing a table and then
still forcefully enable the slot, which is enough to fix UKC on the
3rd gen X1 carbon while having a much smaller chance of breaking
anything else.

ok deraadt
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.40 2015/03/14 03:38:49 jsg Exp $ */
a364 2
	printf("\n");

d404 2
@


1.40
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.39 2015/03/12 20:28:26 deraadt Exp $ */
d1031 1
a1036 4
		cmd[0] = KBC_RESET;
		pckbc_poll_cmd(t->t_kbctag, PCKBC_KBD_SLOT, cmd, 1, 0, NULL, 0);
		cmd[0] = PMS_RESET;
		pckbc_poll_cmd(t->t_kbctag, PCKBC_AUX_SLOT, cmd, 1, 0, NULL, 0);
@


1.39
log
@On first cnpoll, reset the keyboard and pms hard.  This is required
to make "boot -c" support work on a variety of newer machines.
Do not anticipate this harming older machines, but we'll have to wait
and see with this change in the tree.
with jcs
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.38 2014/07/24 22:38:19 mpi Exp $ */
a80 1
#include <dev/pckbc/pckbdvar.h>
@


1.38
log
@Speed up the boot sequence by deferring the scan of xt keyboard code set.

If you were wondering why there's a pause of 5 seconds after loading the
kernel and before seeing the copyright in blue when booting some of your
machines, well this is for you!

mlarkin@@ found that this delay is caused by some code probing for xt scan
code tables when pckbd(4) initialize the console keyboard.  So this diff
implements an idea from deraadt@@ to only do the scan once, either during
*attach() or if we enter ddb> or ukc> before that!

ok miod@@, mlarkin@@, deraadt@@, shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.37 2014/03/23 11:48:23 ratchov Exp $ */
d82 1
d1037 4
@


1.37
log
@my bad, last commit was not ok deraadt, revert it.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.35 2014/01/26 17:48:08 miod Exp $ */
d176 1
a176 1
int	pckbd_init(struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t, int);
a352 3
	if (pckbd_set_xtscancode(pa->pa_tag, pa->pa_slot, NULL))
		return (0);

d371 3
d385 2
a386 1
		(void) pckbd_init(sc->id, pa->pa_tag, pa->pa_slot, 0);
d847 1
a847 1
int
a855 2

	return (pckbd_set_xtscancode(kbctag, kbcslot, t));
a987 2
	char cmd[1];
	int res;
d989 1
a989 13
	res = pckbd_init(&pckbd_consdata, kbctag, PCKBC_KBD_SLOT, 1);
#if 0 /* we allow the console to be attached if no keyboard is present */
	if (res)
		return (res);
#endif

	/* Just to be sure. */
	cmd[0] = KBC_ENABLE;
	res = pckbc_poll_cmd(kbctag, PCKBC_KBD_SLOT, cmd, 1, 0, NULL, 0);
#if 0
	if (res)
		return (res);
#endif
d1023 14
@


1.36
log
@Don't use volume keys when in raw-mode (this doesn't work), and let
Xorg driver do the translation and handle them as regular keys. Fixes
confusion caused by the volume being changed twice in contradictory
ways: once by X programs and once by the pckbd(4) driver.

ok deraadt, kettenis
@
text
@d914 6
a919 1
		return;
@


1.35
log
@Attempt to make user changes of keyboard layout a bit more `sticky' on wsmux
kernels:
- keyboard drivers will now tell wskbd if the keyboard layout they ask
  for is a default value, or a value they are 100% sure of (either
  because your kernel has a XXXKBD_LAYOUT option, or because the
  driver can tell the keyboard layout, e.g. by the country code on USB
  keyboards which provide it, such as Sun's)
- when attaching a keyboard with a non-default layout, the layout will
  become the default layout of the mux for new keyboard attachments if
  the mux doesn't have a layout set already.
- when changing the keyboard layout of a particular keyboard with an
  ioctl (i.e. using kbd(8) or wsconsctl(8)), the layout will become the
  default layout of the mux for new keyboard attachments.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.34 2013/02/15 10:20:07 ratchov Exp $ */
d914 1
a914 6

		/*
		 * Pass audio keys to wskbd_input anyway.
		 */
		if (rc == 0 || (key != 160 && key != 174 && key != 176))
			return;
@


1.34
log
@backout latest: audio keys can autorepeat. Autorepeated keys are not
decoded by the wskbd layer, thus autorepeted audio keys end-up passed
to userland in raw mode (ie to X), resulting in keyboard input
corruption. Noticed (and debugged) by halex@@, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.32 2012/08/10 17:49:31 shadchin Exp $ */
d160 1
a160 1
	KB_US,
@


1.33
log
@don't propagate XF86XK_Audio{Lower,Raise}Volume keys to userspace,
otherwise volume may be adjusted twice: once by X apps and once in
the kernel.

feedback from many, ok shadchin@@
@
text
@a904 7
	/*
	 * Pass audio keys to wskbd_input and discard them.
	 */
	if (rc != 0 && (key == 160 || key == 174 || key == 176)) {
		wskbd_input(sc->sc_wskbddev, type, key);
		return;
	}
d914 6
a919 1
		return;
@


1.32
log
@simplify pckbc_xt_translation()
* call only for set translation on (once in /sys/dev/pckbd.c)
  therefore we can delete unused code.
* change behavior (more standard) - return zero on success

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.31 2011/03/17 15:42:05 shadchin Exp $ */
d905 7
d921 1
a921 6

		/*
		 * Pass audio keys to wskbd_input anyway.
		 */
		if (rc == 0 || (key != 160 && key != 174 && key != 176))
			return;
@


1.31
log
@Ansify non-ansified function definitions. No functional change.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.30 2010/12/16 20:18:31 shadchin Exp $ */
d192 1
a192 4
	if (pckbc_xt_translation(kbctag, kbcslot, 1)) {
		if (id != NULL)
			id->t_translating = 1;
	} else {
d208 3
@


1.30
log
@small cleanup ioctl WSKBDIO_GETLEDS

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.29 2010/12/03 18:29:56 shadchin Exp $ */
d283 1
a283 3
pckbd_is_console(tag, slot)
	pckbc_tag_t tag;
	pckbc_slot_t slot;
d294 1
a294 4
pckbdprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d360 1
a360 3
pckbdattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d413 1
a413 3
pckbd_enable(v, on)
	void *v;
	int on;
d791 1
a791 5
pckbd_decode(id, datain, type, dataout)
	struct pckbd_internal *id;
	int datain;
	u_int *type;
	int *dataout;
d847 2
a848 5
pckbd_init(t, kbctag, kbcslot, console)
	struct pckbd_internal *t;
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
	int console;
d860 1
a860 2
pckbd_led_encode(led)
	int led;
d876 1
a876 3
pckbd_set_leds(v, leds)
	void *v;
	int leds;
d894 1
a894 3
pckbd_input(vsc, data)
	void *vsc;
	int data;
d927 1
a927 6
pckbd_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d968 1
a968 3
pckbd_bell(pitch, period, volume, poll)
	u_int pitch, period, volume;
	int poll;
d977 1
a977 3
pckbd_hookup_bell(fn, arg)
	void (*fn)(void *, u_int, u_int, u_int, int);
	void *arg;
d987 1
a987 2
pckbd_cnattach(kbctag)
	pckbc_tag_t kbctag;
d1013 1
a1013 4
pckbd_cngetc(v, type, data)
	void *v;
	u_int *type;
	int *data;
d1033 1
a1033 3
pckbd_cnpollc(v, on)
	void *v;
        int on;
d1041 1
a1041 3
pckbd_cnbell(v, pitch, period, volume)
	void *v;
	u_int pitch, period, volume;
@


1.29
log
@removed slot argument of function pckbd_cnattach
because it is always PCKBC_KBD_SLOT

ok miod@@, krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.28 2010/08/28 12:49:57 miod Exp $ */
a181 1
static int	pckbd_led_decode(int);
a891 16
static int
pckbd_led_decode(led)
	int led;
{
	int res;

	res = 0;
	if (led & 0x01)
		res |= WSKBD_LED_SCROLL;
	if (led & 0x02)
		res |= WSKBD_LED_NUM;
	if (led & 0x04)
		res |= WSKBD_LED_CAPS;
	return(res);
}

d902 1
a902 1
	sc->sc_ledstate = cmd[1];
d966 2
a967 1
		sc->sc_ledstate = cmd[1];
d973 1
a973 1
		*(int *)data = pckbd_led_decode(sc->sc_ledstate);
@


1.28
log
@In pckbd_scancode_translate(), correctly translate the break sequence
between scan code sets 1 and 2.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.27 2010/07/22 14:26:38 deraadt Exp $ */
d1033 1
a1033 1
pckbd_cnattach(kbctag, kbcslot)
a1034 1
	int kbcslot;
d1039 1
a1039 1
	res = pckbd_init(&pckbd_consdata, kbctag, kbcslot, 1);
d1047 1
a1047 1
	res = pckbc_poll_cmd(kbctag, kbcslot, cmd, 1, 0, NULL, 0);
@


1.27
log
@Don't do anything on suspend/resume for now (there is a diff brewing,
but it has some problems still..)
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.26 2010/07/21 20:10:17 miod Exp $ */
d772 1
a772 1
		return 0x77 | id->t_releasing;
d851 1
a851 1
			return(0);
@


1.26
log
@Disable the heuristics for legacy free systems if pckbc flags are set to 1
in UKC; found the hard way by jakemsr@@ on an old Tecra laptop.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.25 2010/07/08 19:29:25 deraadt Exp $ */
a125 1
int pckbd_activate(struct device *, int);
d132 1
a132 1
	pckbd_activate
a417 14
}

int
pckbd_activate(struct device *self, int act)
{
	switch (act) {
	case DVACT_SUSPEND:
		pckbd_enable(self, 0);
		break;
	case DVACT_RESUME:
		pckbd_enable(self, 1);
		break;
	}
	return (0);
@


1.25
log
@For DVACT_SUSPEND and DVACT_RESUME we should always return success.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.24 2009/11/23 23:22:38 deraadt Exp $ */
d339 6
a344 2
		if (res == ENXIO)
			return 0;
@


1.24
log
@pckbd_activate() should return failure if it knows; ok pirofti
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.23 2009/11/23 15:21:41 deraadt Exp $ */
a419 2
	int rv = 0;

d422 1
a422 1
		rv = pckbd_enable(self, 0);
d425 1
a425 1
		rv = pckbd_enable(self, 1);
d428 1
a428 1
	return (rv);
@


1.23
log
@better style is DVACT_SUSPEND before DVACT_RESUME
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.22 2009/11/23 01:33:08 pirofti Exp $ */
d420 2
d424 1
a424 1
		pckbd_enable(self, 0);
d427 1
a427 1
		pckbd_enable(self, 1);
d430 1
a430 1
	return (0);
@


1.22
log
@Fix pckbd and acpihpet suspend/resume cases to fit with the future framework
that's going to get in really soon.

Okay mlarkin@@, deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.21 2009/10/13 19:33:16 pirofti Exp $ */
d421 3
a425 3
		break;
	case DVACT_SUSPEND:
		pckbd_enable(self, 0);
@


1.21
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.20 2009/08/25 19:16:36 miod Exp $ */
d421 2
a422 3
	case DVACT_ACTIVATE:
		if (!cold)
			pckbd_enable(self, 1);
d424 2
a425 3
	case DVACT_DEACTIVATE:
		if (!cold)
			pckbd_enable(self, 0);
@


1.20
log
@Legacy-free PC hardware do not have a real PS/2 keyboard controller, but
rather have the USB HCI emulate it during boot, while legacy mode is enabled.

This causes pckbd0 to attach as the console device, but is lost as soon as
the USB HCI driver attaches.

The disappearance of the emulated PS/2 controller can however be detected
in pckbc(4) - which is supposed to attach after [eou]hci(4), with the controller
refusing to ack commands and replying ``please resend'' instead.

In that case, the kernel will now no longer attach pckbd, and will perform a
new console input device selection, allowing the (real) usb keyboard to
become the console.

Thanks to krw@@ for countless tests on legacy-free hardware; also tested on
more conventional hardware by naddy@@ and I.

Only amd64 and i386 platforms are affected by this change.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.19 2009/08/13 21:46:23 pirofti Exp $ */
d126 1
a126 1
int pckbd_activate(struct device *, enum devact);
d418 1
a418 1
pckbd_activate(struct device *self, enum devact act)
@


1.19
log
@Forgot to add break to the switch cases. Silly.
Okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.18 2009/08/13 21:15:03 pirofti Exp $ */
d333 9
a412 1
	 * XXX XXX XXX
@


1.18
log
@Add wake/suspend support for pckbd(4).

Patch initially from mlarkin@@. KNF and refactoring by me.
Suggestions and okay deraadt@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.17 2009/05/03 13:02:35 miod Exp $ */
d416 1
d420 1
@


1.17
log
@Make sure pckbd_scancode_translate() returns a scancode with the break/release
bit set if needed, in all cases. This fixes rawkbd operation on controllers
which require the kernel to perform scancode translation.

Found by and ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.16 2008/11/21 14:38:03 robert Exp $ */
d126 1
d129 5
a133 1
	sizeof(struct pckbd_softc), pckbdprobe, pckbdattach,
d407 14
@


1.16
log
@Move #include <dev/pckbc/wskbdmap_mfii.h> after including
dev/wscons/wsksymvar.h where struct wskbd_mapdata gets
declared.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.15 2008/07/16 20:00:45 miod Exp $ */
d781 1
a781 1
	return datain;
@


1.15
log
@If pckbc_xt_translation() fails, do not try to force the keyboard in table
1; instead, try table 2 first, then 1: some older keyboards, connected to
a castrated 8042, do not know how to talk in table 1 (or worse, will report
they do while they don't).

If automatic translation is not possible, remember which table the keyboard
ended configured in, and convert the scancodes from table 2 to table 1 if
necessary.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.14 2008/06/26 05:42:17 ray Exp $ */
a81 1
#include <dev/pckbc/wskbdmap_mfii.h>
d87 2
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.13 2007/12/31 17:08:07 miod Exp $ */
a88 4
#if defined(__i386__) || defined(__alpha__)
#include <sys/kernel.h> /* XXX for hz */
#endif

d94 3
d100 1
d168 4
a171 3
int	pckbd_set_xtscancode(pckbc_tag_t, pckbc_slot_t);
int	pckbd_init(struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t,
			int);
d182 2
a183 3
pckbd_set_xtscancode(kbctag, kbcslot)
	pckbc_tag_t kbctag;
	pckbc_slot_t kbcslot;
d188 4
a191 1
	if (!pckbc_xt_translation(kbctag, kbcslot, 1)) {
d195 12
a206 2
		/* just set the basic XT table and hope it works. */
		table = 1;
d254 1
a254 1
				return (0);
d265 1
a265 1
			return (0);
d269 7
a275 1
	return (1);
d341 1
a341 1
	if (pckbd_set_xtscancode(pa->pa_tag, pa->pa_slot))
d427 1
a427 1
					   sc->id->t_kbcslot);
d452 331
d791 1
d794 2
a795 2
		id->t_extended = 1;
		return(0);
d798 1
a798 1
		return(0);
d801 2
a802 3
 	/* map extended keys to (unused) codes 128-254 */
	key = (datain & 0x7f) | (id->t_extended ? 0x80 : 0);
	id->t_extended = 0;
d805 1
a805 1
	 * process BREAK key (EXT1 1D 45  EXT1 9D C5):
d808 1
a808 1
	if (id->t_extended1 == 2 && (datain == 0x1d || datain == 0x9d)) {
d810 2
a811 3
		return(0);
	} else if (id->t_extended1 == 1 &&
		   (datain == 0x45 || datain == 0xc5)) {
d813 2
a814 2
		key = 0x7f;
	} else if (id->t_extended1 > 0) {
d816 5
d823 6
a828 1
	if (datain & 0x80) {
d840 1
a840 1
	return(1);
d856 1
a856 1
	return (pckbd_set_xtscancode(kbctag, kbcslot));
d920 4
d1054 8
a1061 1
		if ((val != -1) && pckbd_decode(t, val, type, data))
@


1.13
log
@Keep running the scancode translation state machine even when the keyboard
is set to raw mode, but only feed decoded events to wscons if non-raw mode.

Then, as an exception to this, pass the audio control keys events to
wscons even if in raw mode, so that the in-kernel mixer control code can
perform its work. The event is also seen by the raw event consumer (i.e.
the X server).

Requested and tested by many...
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.12 2007/10/17 21:54:29 deraadt Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@miod says noone needs isa/isavar.h anymore, and i believe him
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.11 2007/10/17 01:32:46 deraadt Exp $ */
d122 3
a124 1
	int rawkbd;
d566 3
a568 1
	int type, key;
d572 13
a584 3
		char d = data;
		wskbd_rawinput(sc->sc_wskbddev, &d, 1);
		return;
d587 1
a587 1
	if (pckbd_decode(sc->id, data, &type, &key))
@


1.11
log
@use NULL to point to the response buffer, which avoids confusion; ok fgsch
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.10 2007/10/17 01:16:04 fgsch Exp $ */
a85 4
#ifndef __sparc64__
#include <dev/isa/isavar.h>		/* XXX XXX XXX */
#endif

a86 1

@


1.10
log
@- Remove a shadow declaration.
- Correct resp size.

deraadt@@ ok.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.9 2007/01/30 20:45:05 jcs Exp $ */
d214 1
a214 1
		if (pckbc_poll_cmd(kbctag, kbcslot, cmd, 2, 0, 0, 0)) {
d221 1
a221 1
				    1, 1, 0, 1);
d361 1
a361 1
		    cmd, 1, 0, 0, 0);
d371 1
a371 1
				      cmd, 1, 0, 0, 0);
d666 1
a666 1
	res = pckbc_poll_cmd(kbctag, kbcslot, cmd, 1, 0, 0, 0);
@


1.9
log
@default to have pckbd_set_xtscancode() instruct the 8042 to use
table 3, still falling back on table 2 or 1 after carefully checking
that the table set request took

fixes the keyboard on the oqo model 01/01+

in snaps for a while, tested by many

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.8 2005/12/29 12:31:29 martin Exp $ */
a214 1
			u_char cmd[1];
d234 1
a234 1
			u_char cmd[1], resp[0];
@


1.8
log
@go via pckbc_enqeue_cmd() in pckbd_enable() if on; fixes PR 4615

ok miod@@, mickey@@
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.7 2005/02/22 16:17:31 mickey Exp $ */
d195 2
a196 2
	u_char cmd[2];
	int res;
d198 14
a211 15
	/*
	 * Some keyboard/8042 combinations do not seem to work if the keyboard
	 * is set to table 1; in fact, it would appear that some keyboards just
	 * ignore the command altogether.  So by default, we use the AT scan
	 * codes and have the 8042 translate them.  Unfortunately, this is
	 * known to not work on some PS/2 machines.  We try desperately to deal
	 * with this by checking the (lack of a) translate bit in the 8042 and
	 * attempting to set the keyboard to XT mode.  If this all fails, well,
	 * tough luck.
	 *
	 * XXX It would perhaps be a better choice to just use AT scan codes
	 * and not bother with this.
	 */
	if (pckbc_xt_translation(kbctag, kbcslot, 1)) {
		/* The 8042 is translating for us; use AT codes. */
d213 2
a214 3
		cmd[1] = 2;
		res = pckbc_poll_cmd(kbctag, kbcslot, cmd, 2, 0, 0, 0);
		if (res) {
d217 1
a217 1
			printf("pckbd: error setting scanset 2\n");
d219 8
a226 10
			/*
			 * XXX at least one keyboard is reported to lock up
			 * if a "set table" is attempted, thus the "reset".
			 * XXX ignore errors, scanset 2 should be
			 * default anyway.
			 */
			cmd[0] = KBC_RESET;
			(void)pckbc_poll_cmd(kbctag, kbcslot, cmd, 1, 1, 0, 1);
			pckbc_flush(kbctag, kbcslot);
			res = 0;
d228 32
a259 5
	} else {
		/* Stupid 8042; set keyboard to XT codes. */
		cmd[0] = KBC_SETTABLE;
		cmd[1] = 1;
		res = pckbc_poll_cmd(kbctag, kbcslot, cmd, 2, 0, 0, 0);
d261 1
a261 2
		if (res)
			printf("pckbd: error setting scanset 1\n");
d263 2
d266 2
a267 1
	return (res);
@


1.7
log
@send enable cmd after a reset; form netbsd
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.6 2003/10/22 09:44:22 jmc Exp $ */
d386 2
a387 2
		res = pckbc_enqueue_cmd(sc->id->t_kbctag, sc->id->t_kbcslot,
					cmd, 1, 0, 1, 0);
@


1.6
log
@typos from Tom Cosgrove;
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.5 2003/06/02 23:28:03 millert Exp $ */
d323 1
d331 7
a339 2
		u_char cmd[1];

@


1.5
log
@Remove the advertising clause in the UCB license which Berkeley
rescinded 22 July 1999.  Proofed by myself and Theo.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.4 2002/03/14 01:27:00 millert Exp $ */
d203 1
a203 1
	 * known to not work on some PS/2 machines.  We try desparately to deal
@


1.4
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.3 2002/02/18 05:25:14 jason Exp $ */
d55 1
a55 5
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the University of
 *	California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
@


1.3
log
@Don't include isavar.h on sparc64
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.2 2001/02/02 20:19:04 aaron Exp $ */
d135 1
a135 1
static int pckbd_is_console __P((pckbc_tag_t, pckbc_slot_t));
d137 2
a138 2
int pckbdprobe __P((struct device *, void *, void *));
void pckbdattach __P((struct device *, struct device *, void *));
d144 3
a146 3
int	pckbd_enable __P((void *, int));
void	pckbd_set_leds __P((void *, int));
int	pckbd_ioctl __P((void *, u_long, caddr_t, int, struct proc *));
d154 3
a156 3
void	pckbd_cngetc __P((void *, u_int *, int *));
void	pckbd_cnpollc __P((void *, int));
void	pckbd_cnbell __P((void *, u_int, u_int, u_int));
d177 1
a177 1
void	(*pckbd_bell_fn) __P((void *, u_int, u_int, u_int, int));
d180 1
a180 1
void	pckbd_bell __P((u_int, u_int, u_int, int));
d182 9
a190 9
int	pckbd_set_xtscancode __P((pckbc_tag_t, pckbc_slot_t));
int	pckbd_init __P((struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t,
			int));
void	pckbd_input __P((void *, int));

static int	pckbd_decode __P((struct pckbd_internal *, int,
				  u_int *, int *));
static int	pckbd_led_encode __P((int));
static int	pckbd_led_decode __P((int));
d614 1
a614 1
	void (*fn) __P((void *, u_int, u_int, u_int, int));
@


1.2
log
@Remove dead code.
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.1 2000/11/13 20:12:34 aaron Exp $ */
d90 1
d92 1
@


1.2.8.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.2 2001/02/02 20:19:04 aaron Exp $ */
a89 1
#ifndef __sparc64__
a90 1
#endif
d133 1
a133 1
static int pckbd_is_console(pckbc_tag_t, pckbc_slot_t);
d135 2
a136 2
int pckbdprobe(struct device *, void *, void *);
void pckbdattach(struct device *, struct device *, void *);
d142 3
a144 3
int	pckbd_enable(void *, int);
void	pckbd_set_leds(void *, int);
int	pckbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d152 3
a154 3
void	pckbd_cngetc(void *, u_int *, int *);
void	pckbd_cnpollc(void *, int);
void	pckbd_cnbell(void *, u_int, u_int, u_int);
d175 1
a175 1
void	(*pckbd_bell_fn)(void *, u_int, u_int, u_int, int);
d178 1
a178 1
void	pckbd_bell(u_int, u_int, u_int, int);
d180 9
a188 9
int	pckbd_set_xtscancode(pckbc_tag_t, pckbc_slot_t);
int	pckbd_init(struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t,
			int);
void	pckbd_input(void *, int);

static int	pckbd_decode(struct pckbd_internal *, int,
				  u_int *, int *);
static int	pckbd_led_encode(int);
static int	pckbd_led_decode(int);
d612 1
a612 1
	void (*fn)(void *, u_int, u_int, u_int, int);
@


1.2.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.2 2001/02/02 20:19:04 aaron Exp $ */
@


1.2.4.2
log
@Merge in trunk
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a89 1
#ifndef __sparc64__
a90 1
#endif
@


1.2.4.3
log
@Merge unpeeing cvs missed
@
text
@d135 1
a135 1
static int pckbd_is_console(pckbc_tag_t, pckbc_slot_t);
d137 2
a138 2
int pckbdprobe(struct device *, void *, void *);
void pckbdattach(struct device *, struct device *, void *);
d144 3
a146 3
int	pckbd_enable(void *, int);
void	pckbd_set_leds(void *, int);
int	pckbd_ioctl(void *, u_long, caddr_t, int, struct proc *);
d154 3
a156 3
void	pckbd_cngetc(void *, u_int *, int *);
void	pckbd_cnpollc(void *, int);
void	pckbd_cnbell(void *, u_int, u_int, u_int);
d177 1
a177 1
void	(*pckbd_bell_fn)(void *, u_int, u_int, u_int, int);
d180 1
a180 1
void	pckbd_bell(u_int, u_int, u_int, int);
d182 9
a190 9
int	pckbd_set_xtscancode(pckbc_tag_t, pckbc_slot_t);
int	pckbd_init(struct pckbd_internal *, pckbc_tag_t, pckbc_slot_t,
			int);
void	pckbd_input(void *, int);

static int	pckbd_decode(struct pckbd_internal *, int,
				  u_int *, int *);
static int	pckbd_led_encode(int);
static int	pckbd_led_decode(int);
d614 1
a614 1
	void (*fn)(void *, u_int, u_int, u_int, int);
@


1.2.4.4
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/* $OpenBSD: pckbd.c,v 1.2.4.3 2002/03/30 08:19:20 niklas Exp $ */
d55 5
a59 1
 * 3. Neither the name of the University nor the names of its contributors
@


1.2.4.5
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d203 1
a203 1
	 * known to not work on some PS/2 machines.  We try desperately to deal
@


1.1
log
@Machine-independent PC-like keyboard driver; from NetBSD. XXX - Not used
anywhere quite yet, but useful to have these files in the tree while we work
towards wscons for i386 and alpha.
@
text
@d1 1
a1 1
/* $OpenBSD$ */
a104 5
#endif

#if 0
#include "opt_pckbd_layout.h"
#include "opt_wsdisplay_compat.h"
@

