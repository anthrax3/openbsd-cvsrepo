head	1.75;
access;
symbols
	OPENBSD_6_1:1.74.0.4
	OPENBSD_6_1_BASE:1.74
	OPENBSD_6_0:1.70.0.2
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.67.0.2
	OPENBSD_5_9_BASE:1.67
	OPENBSD_5_8:1.64.0.4
	OPENBSD_5_8_BASE:1.64
	OPENBSD_5_7:1.57.0.4
	OPENBSD_5_7_BASE:1.57
	OPENBSD_5_6:1.52.0.4
	OPENBSD_5_6_BASE:1.52
	OPENBSD_5_5:1.49.0.4
	OPENBSD_5_5_BASE:1.49
	OPENBSD_5_4:1.45.0.2
	OPENBSD_5_4_BASE:1.45
	OPENBSD_5_3:1.35.0.2
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.31.0.2
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.27
	OPENBSD_5_1:1.27.0.2
	OPENBSD_5_0:1.18.0.4
	OPENBSD_5_0_BASE:1.18
	OPENBSD_4_9:1.18.0.2
	OPENBSD_4_9_BASE:1.18
	OPENBSD_4_8:1.3.0.2
	OPENBSD_4_8_BASE:1.3
	OPENBSD_4_7:1.2.0.8
	OPENBSD_4_7_BASE:1.2
	OPENBSD_4_6:1.2.0.10
	OPENBSD_4_6_BASE:1.2
	OPENBSD_4_5:1.2.0.6
	OPENBSD_4_5_BASE:1.2
	OPENBSD_4_4:1.2.0.4
	OPENBSD_4_4_BASE:1.2
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.75
date	2017.05.08.20.55.29;	author bru;	state Exp;
branches;
next	1.74;
commitid	HWVWBmAyExdFs9jj;

1.74
date	2017.03.06.09.06.20;	author mpi;	state Exp;
branches;
next	1.73;
commitid	Bz72fKoAs2I1Mi0e;

1.73
date	2017.02.27.16.40.10;	author bru;	state Exp;
branches;
next	1.72;
commitid	YUHukv9B1BPg8fjR;

1.72
date	2017.02.27.16.21.47;	author bru;	state Exp;
branches;
next	1.71;
commitid	rAbNM7v6DDPHgGLN;

1.71
date	2016.10.23.22.59.19;	author bru;	state Exp;
branches;
next	1.70;
commitid	m7Qv2drIZWfJ1bkB;

1.70
date	2016.05.22.22.06.11;	author bru;	state Exp;
branches;
next	1.69;
commitid	GkZBxuz69gc30pav;

1.69
date	2016.03.30.23.34.12;	author bru;	state Exp;
branches;
next	1.68;
commitid	216Sb0C4sEs8CDdv;

1.68
date	2016.02.27.22.01.58;	author mmcc;	state Exp;
branches;
next	1.67;
commitid	1tMgMih8jW096Zot;

1.67
date	2015.09.05.14.02.21;	author bru;	state Exp;
branches;
next	1.66;
commitid	EIBy9LgYoz011bAe;

1.66
date	2015.09.05.13.52.54;	author bru;	state Exp;
branches;
next	1.65;
commitid	qR4g8pCIfKayzzgh;

1.65
date	2015.08.23.04.45.23;	author deraadt;	state Exp;
branches;
next	1.64;
commitid	wjeD3sETAqZdKuq8;

1.64
date	2015.07.20.00.55.06;	author kspillner;	state Exp;
branches;
next	1.63;
commitid	38PD24lvCvYms7MN;

1.63
date	2015.07.19.15.43.44;	author krw;	state Exp;
branches;
next	1.62;
commitid	gBjqmo1epMwcSHvi;

1.62
date	2015.06.08.06.39.22;	author stsp;	state Exp;
branches;
next	1.61;
commitid	A9xLUkDigCpSEp7I;

1.61
date	2015.05.25.15.04.26;	author mpi;	state Exp;
branches;
next	1.60;
commitid	t7MrjbAtgQpQsl5D;

1.60
date	2015.05.04.09.33.46;	author mpi;	state Exp;
branches;
next	1.59;
commitid	AEsxL0jOoaDjikVc;

1.59
date	2015.04.10.08.48.08;	author stsp;	state Exp;
branches;
next	1.58;
commitid	MRL73wbe46tiC12j;

1.58
date	2015.03.26.01.30.22;	author jsg;	state Exp;
branches;
next	1.57;
commitid	DfGw11wytDIaNGqm;

1.57
date	2015.02.09.04.05.25;	author mpi;	state Exp;
branches;
next	1.56;
commitid	nBTu4c6G16PZzUbW;

1.56
date	2015.01.15.01.19.28;	author jsg;	state Exp;
branches;
next	1.55;
commitid	PSdMLDHj2pHrUoMH;

1.55
date	2015.01.07.10.32.13;	author mpi;	state Exp;
branches;
next	1.54;
commitid	w9HRflCK0z1fEnup;

1.54
date	2014.08.29.20.09.09;	author shadchin;	state Exp;
branches;
next	1.53;
commitid	5xH2OMmIWTSBmkYI;

1.53
date	2014.08.19.12.24.04;	author mpi;	state Exp;
branches;
next	1.52;
commitid	vLQyAD0fOW7hYEMj;

1.52
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.51;
commitid	OBNa5kfxQ2UXoiIw;

1.51
date	2014.05.18.15.27.28;	author stsp;	state Exp;
branches;
next	1.50;

1.50
date	2014.04.25.10.33.36;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.10.30.18.00.56;	author shadchin;	state Exp;
branches;
next	1.48;

1.48
date	2013.09.20.14.07.30;	author stsp;	state Exp;
branches;
next	1.47;

1.47
date	2013.09.03.09.29.35;	author stsp;	state Exp;
branches;
next	1.46;

1.46
date	2013.09.03.07.37.58;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.07.16.08.11.39;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.06.28.18.32.01;	author jcs;	state Exp;
branches;
next	1.43;

1.43
date	2013.05.31.19.21.09;	author jcs;	state Exp;
branches;
next	1.42;

1.42
date	2013.05.23.18.29.51;	author tobias;	state Exp;
branches;
next	1.41;

1.41
date	2013.04.20.08.01.37;	author tobias;	state Exp;
branches;
next	1.40;

1.40
date	2013.04.15.09.14.41;	author mpi;	state Exp;
branches;
next	1.39;

1.39
date	2013.04.15.09.12.42;	author mpi;	state Exp;
branches;
next	1.38;

1.38
date	2013.04.15.09.09.50;	author mpi;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.18.16.31.01;	author stsp;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.16.11.14.47;	author stsp;	state Exp;
branches;
next	1.35;

1.35
date	2012.11.05.19.08.29;	author shadchin;	state Exp;
branches;
next	1.34;

1.34
date	2012.11.03.13.43.57;	author stsp;	state Exp;
branches;
next	1.33;

1.33
date	2012.11.02.12.07.57;	author stsp;	state Exp;
branches;
next	1.32;

1.32
date	2012.10.29.11.54.45;	author stsp;	state Exp;
branches;
next	1.31;

1.31
date	2012.07.22.18.28.36;	author shadchin;	state Exp;
branches;
next	1.30;

1.30
date	2012.07.01.12.59.34;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2012.04.28.09.43.24;	author tobias;	state Exp;
branches;
next	1.28;

1.28
date	2012.03.05.18.42.55;	author shadchin;	state Exp;
branches;
next	1.27;

1.27
date	2012.01.28.21.00.48;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2011.12.04.00.53.49;	author shadchin;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.03.19.43.00;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2011.10.17.17.12.01;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2011.10.17.09.15.22;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2011.10.04.06.30.40;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2011.08.24.15.34.25;	author shadchin;	state Exp;
branches;
next	1.20;

1.20
date	2011.08.22.16.26.42;	author shadchin;	state Exp;
branches;
next	1.19;

1.19
date	2011.08.17.16.10.27;	author shadchin;	state Exp;
branches;
next	1.18;

1.18
date	2011.01.03.19.46.34;	author shadchin;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.27.12.22.20;	author shadchin;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.24.18.22.20;	author shadchin;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.23.20.04.09;	author shadchin;	state Exp;
branches;
next	1.14;

1.14
date	2010.11.15.20.25.31;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2010.11.15.13.51.20;	author krw;	state Exp;
branches;
next	1.12;

1.12
date	2010.11.05.16.10.49;	author krw;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.19.11.00.50;	author krw;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.17.10.32.00;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.16.11.24.04;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2010.10.07.01.52.25;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2010.10.02.00.28.57;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2010.09.29.19.39.18;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.27.18.16.25;	author miod;	state Exp;
branches;
next	1.4;

1.4
date	2010.09.26.20.39.08;	author miod;	state Exp;
branches;
next	1.3;

1.3
date	2010.07.22.14.25.41;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2007.10.17.01.32.46;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.01.12.16.59;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.75
log
@improved coordinate filters

ok mpi@@
@
text
@/* $OpenBSD: pms.c,v 1.74 2017/03/06 09:06:20 mpi Exp $ */
/* $NetBSD: psm.c,v 1.11 2000/06/05 22:20:57 sommerfeld Exp $ */

/*-
 * Copyright (c) 1994 Charles M. Hannum.
 * Copyright (c) 1992, 1993 Erik Forsberg.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *
 * THIS SOFTWARE IS PROVIDED BY ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN
 * NO EVENT SHALL I BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 * PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/rwlock.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>

#include <machine/bus.h>

#include <dev/ic/pckbcvar.h>

#include <dev/pckbc/pmsreg.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#if defined(__i386__) || defined(__amd64__)
#include "acpi.h"
#endif

#if !defined(SMALL_KERNEL) && NACPI > 0
extern int mouse_has_softbtn;
#else
int mouse_has_softbtn;
#endif

#ifdef DEBUG
#define DPRINTF(x...)	do { printf(x); } while (0);
#else
#define DPRINTF(x...)
#endif

#define DEVNAME(sc)	((sc)->sc_dev.dv_xname)

#define WSMOUSE_BUTTON(x)	(1 << ((x) - 1))

struct pms_softc;

struct pms_protocol {
	int type;
#define PMS_STANDARD		0
#define PMS_INTELLI		1
#define PMS_SYNAPTICS		2
#define PMS_ALPS		3
#define PMS_ELANTECH_V1		4
#define PMS_ELANTECH_V2		5
#define PMS_ELANTECH_V3		6
#define PMS_ELANTECH_V4		7
	u_int packetsize;
	int (*enable)(struct pms_softc *);
	int (*ioctl)(struct pms_softc *, u_long, caddr_t, int, struct proc *);
	int (*sync)(struct pms_softc *, int);
	void (*proc)(struct pms_softc *);
	void (*disable)(struct pms_softc *);
};

struct synaptics_softc {
	int identify;
	int capabilities, ext_capabilities, ext2_capabilities;
	int model, ext_model;
	int resolution, dimension;
	int modes;

	int mode;

	int mask;
#define SYNAPTICS_MASK_NEWABS_STRICT	0xc8
#define SYNAPTICS_MASK_NEWABS_RELAXED	0xc0
#define SYNAPTICS_VALID_NEWABS_FIRST	0x80
#define SYNAPTICS_VALID_NEWABS_NEXT	0xc0

	u_int sec_buttons;

#define SYNAPTICS_PRESSURE_HI		30
#define SYNAPTICS_PRESSURE_LO		25
#define SYNAPTICS_PRESSURE		SYNAPTICS_PRESSURE_HI
#define SYNAPTICS_SCALE			4
#define SYNAPTICS_MAX_FINGERS		3
};

struct alps_softc {
	int model;
#define ALPS_GLIDEPOINT		(1 << 1)
#define ALPS_DUALPOINT		(1 << 2)
#define ALPS_PASSTHROUGH	(1 << 3)
#define ALPS_INTERLEAVED	(1 << 4)

	int mask;
	int version;

	int min_x, min_y;
	int max_x, max_y;

	u_int gesture;

	u_int sec_buttons;	/* trackpoint */

	/* Compat mode */
	int wsmode;
	int old_x, old_y;
	u_int old_buttons;
#define ALPS_PRESSURE		40
};

struct elantech_softc {
	int flags;
#define ELANTECH_F_REPORTS_PRESSURE	0x01
#define ELANTECH_F_HAS_ROCKER		0x02
#define ELANTECH_F_2FINGER_PACKET	0x04
#define ELANTECH_F_HW_V1_OLD		0x08
#define ELANTECH_F_CRC_ENABLED		0x10
	int fw_version;

	int min_x, min_y;
	int max_x, max_y;

	u_int mt_slots;

	int width;

	u_char parity[256];
	u_char p1, p2, p3;

	/* Compat mode */
	int wsmode;
	int old_x, old_y;
	u_int old_buttons;
};

struct pms_softc {		/* driver status information */
	struct device sc_dev;

	pckbc_tag_t sc_kbctag;

	int sc_state;
#define PMS_STATE_DISABLED	0
#define PMS_STATE_ENABLED	1
#define PMS_STATE_SUSPENDED	2

	struct rwlock sc_state_lock;

	int sc_dev_enable;
#define PMS_DEV_IGNORE		0x00
#define PMS_DEV_PRIMARY		0x01
#define PMS_DEV_SECONDARY	0x02

	int poll;
	int inputstate;

	const struct pms_protocol *protocol;
	struct synaptics_softc *synaptics;
	struct alps_softc *alps;
	struct elantech_softc *elantech;

	u_char packet[8];

	struct device *sc_wsmousedev;
	struct device *sc_sec_wsmousedev;
};

static const u_int butmap[8] = {
	0,
	WSMOUSE_BUTTON(1),
	WSMOUSE_BUTTON(3),
	WSMOUSE_BUTTON(1) | WSMOUSE_BUTTON(3),
	WSMOUSE_BUTTON(2),
	WSMOUSE_BUTTON(1) | WSMOUSE_BUTTON(2),
	WSMOUSE_BUTTON(2) | WSMOUSE_BUTTON(3),
	WSMOUSE_BUTTON(1) | WSMOUSE_BUTTON(2) | WSMOUSE_BUTTON(3)
};

static const struct alps_model {
	int version;
	int mask;
	int model;
} alps_models[] = {
	{ 0x2021, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x2221, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x2222, 0xff, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x3222, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x5212, 0xff, ALPS_DUALPOINT | ALPS_PASSTHROUGH | ALPS_INTERLEAVED },
	{ 0x5321, 0xf8, ALPS_GLIDEPOINT },
	{ 0x5322, 0xf8, ALPS_GLIDEPOINT },
	{ 0x603b, 0xf8, ALPS_GLIDEPOINT },
	{ 0x6222, 0xcf, ALPS_DUALPOINT | ALPS_PASSTHROUGH | ALPS_INTERLEAVED },
	{ 0x6321, 0xf8, ALPS_GLIDEPOINT },
	{ 0x6322, 0xf8, ALPS_GLIDEPOINT },
	{ 0x6323, 0xf8, ALPS_GLIDEPOINT },
	{ 0x6324, 0x8f, ALPS_GLIDEPOINT },
	{ 0x6325, 0xef, ALPS_GLIDEPOINT },
	{ 0x6326, 0xf8, ALPS_GLIDEPOINT },
	{ 0x7301, 0xf8, ALPS_DUALPOINT },
	{ 0x7321, 0xf8, ALPS_GLIDEPOINT },
	{ 0x7322, 0xf8, ALPS_GLIDEPOINT },
	{ 0x7325, 0xcf, ALPS_GLIDEPOINT },
#if 0
	/*
	 * This model has a clitpad sending almost compatible PS2
	 * packets but not compatible enough to be used with the
	 * ALPS protocol.
	 */
	{ 0x633b, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },

	{ 0x7326, 0, 0 },	/* XXX Uses unknown v3 protocol */
#endif
};

static struct wsmouse_param synaptics_params[] = {
	{ WSMOUSECFG_PRESSURE_LO, SYNAPTICS_PRESSURE_LO },
	{ WSMOUSECFG_PRESSURE_HI, SYNAPTICS_PRESSURE_HI }
};

static struct wsmouse_param elantech_v4_params[] = {
	{ WSMOUSECFG_STRONG_HYSTERESIS, 0 }
};

int	pmsprobe(struct device *, void *, void *);
void	pmsattach(struct device *, struct device *, void *);
int	pmsactivate(struct device *, int);

void	pmsinput(void *, int);

int	pms_change_state(struct pms_softc *, int, int);

int	pms_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	pms_enable(void *);
void	pms_disable(void *);

int	pms_sec_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	pms_sec_enable(void *);
void	pms_sec_disable(void *);

int	pms_cmd(struct pms_softc *, u_char *, int, u_char *, int);
int	pms_spec_cmd(struct pms_softc *, int);
int	pms_get_devid(struct pms_softc *, u_char *);
int	pms_get_status(struct pms_softc *, u_char *);
int	pms_set_rate(struct pms_softc *, int);
int	pms_set_resolution(struct pms_softc *, int);
int	pms_set_scaling(struct pms_softc *, int);
int	pms_reset(struct pms_softc *);
int	pms_dev_enable(struct pms_softc *);
int	pms_dev_disable(struct pms_softc *);
void	pms_protocol_lookup(struct pms_softc *);

int	pms_enable_intelli(struct pms_softc *);

int	pms_ioctl_mouse(struct pms_softc *, u_long, caddr_t, int, struct proc *);
int	pms_sync_mouse(struct pms_softc *, int);
void	pms_proc_mouse(struct pms_softc *);

int	pms_enable_synaptics(struct pms_softc *);
int	pms_ioctl_synaptics(struct pms_softc *, u_long, caddr_t, int, struct proc *);
int	pms_sync_synaptics(struct pms_softc *, int);
void	pms_proc_synaptics(struct pms_softc *);
void	pms_disable_synaptics(struct pms_softc *);

int	pms_enable_alps(struct pms_softc *);
int	pms_ioctl_alps(struct pms_softc *, u_long, caddr_t, int, struct proc *);
int	pms_sync_alps(struct pms_softc *, int);
void	pms_proc_alps(struct pms_softc *);

int	pms_enable_elantech_v1(struct pms_softc *);
int	pms_enable_elantech_v2(struct pms_softc *);
int	pms_enable_elantech_v3(struct pms_softc *);
int	pms_enable_elantech_v4(struct pms_softc *);
int	pms_ioctl_elantech(struct pms_softc *, u_long, caddr_t, int,
    struct proc *);
int	pms_sync_elantech_v1(struct pms_softc *, int);
int	pms_sync_elantech_v2(struct pms_softc *, int);
int	pms_sync_elantech_v3(struct pms_softc *, int);
int	pms_sync_elantech_v4(struct pms_softc *, int);
void	pms_proc_elantech_v1(struct pms_softc *);
void	pms_proc_elantech_v2(struct pms_softc *);
void	pms_proc_elantech_v3(struct pms_softc *);
void	pms_proc_elantech_v4(struct pms_softc *);

int	synaptics_knock(struct pms_softc *);
int	synaptics_set_mode(struct pms_softc *, int);
int	synaptics_query(struct pms_softc *, int, int *);
int	synaptics_get_hwinfo(struct pms_softc *);
void	synaptics_sec_proc(struct pms_softc *);

int	alps_sec_proc(struct pms_softc *);
int	alps_get_hwinfo(struct pms_softc *);

int	elantech_knock(struct pms_softc *);
void	elantech_send_input(struct pms_softc *, int, int, int, int);
int	elantech_get_hwinfo_v1(struct pms_softc *);
int	elantech_get_hwinfo_v2(struct pms_softc *);
int	elantech_get_hwinfo_v3(struct pms_softc *);
int	elantech_get_hwinfo_v4(struct pms_softc *);
int	elantech_ps2_cmd(struct pms_softc *, u_char);
int	elantech_set_absolute_mode_v1(struct pms_softc *);
int	elantech_set_absolute_mode_v2(struct pms_softc *);
int	elantech_set_absolute_mode_v3(struct pms_softc *);
int	elantech_set_absolute_mode_v4(struct pms_softc *);

struct cfattach pms_ca = {
	sizeof(struct pms_softc), pmsprobe, pmsattach, NULL,
	pmsactivate
};

struct cfdriver pms_cd = {
	NULL, "pms", DV_DULL
};

const struct wsmouse_accessops pms_accessops = {
	pms_enable,
	pms_ioctl,
	pms_disable,
};

const struct wsmouse_accessops pms_sec_accessops = {
	pms_sec_enable,
	pms_sec_ioctl,
	pms_sec_disable,
};

const struct pms_protocol pms_protocols[] = {
	/* Generic PS/2 mouse */
	{
		PMS_STANDARD, 3,
		NULL,
		pms_ioctl_mouse,
		pms_sync_mouse,
		pms_proc_mouse,
		NULL
	},
	/* Synaptics touchpad */
	{
		PMS_SYNAPTICS, 6,
		pms_enable_synaptics,
		pms_ioctl_synaptics,
		pms_sync_synaptics,
		pms_proc_synaptics,
		pms_disable_synaptics
	},
	/* ALPS touchpad */
	{
		PMS_ALPS, 6,
		pms_enable_alps,
		pms_ioctl_alps,
		pms_sync_alps,
		pms_proc_alps,
		NULL
	},
	/* Elantech touchpad (hardware version 1) */
	{
		PMS_ELANTECH_V1, 4,
		pms_enable_elantech_v1,
		pms_ioctl_elantech,
		pms_sync_elantech_v1,
		pms_proc_elantech_v1,
		NULL
	},
	/* Elantech touchpad (hardware version 2) */
	{
		PMS_ELANTECH_V2, 6,
		pms_enable_elantech_v2,
		pms_ioctl_elantech,
		pms_sync_elantech_v2,
		pms_proc_elantech_v2,
		NULL
	},
	/* Elantech touchpad (hardware version 3) */
	{
		PMS_ELANTECH_V3, 6,
		pms_enable_elantech_v3,
		pms_ioctl_elantech,
		pms_sync_elantech_v3,
		pms_proc_elantech_v3,
		NULL
	},
	/* Elantech touchpad (hardware version 4) */
	{
		PMS_ELANTECH_V4, 6,
		pms_enable_elantech_v4,
		pms_ioctl_elantech,
		pms_sync_elantech_v4,
		pms_proc_elantech_v4,
		NULL
	},
	/* Microsoft IntelliMouse */
	{
		PMS_INTELLI, 4,
		pms_enable_intelli,
		pms_ioctl_mouse,
		pms_sync_mouse,
		pms_proc_mouse,
		NULL
	},
};

int
pms_cmd(struct pms_softc *sc, u_char *cmd, int len, u_char *resp, int resplen)
{
	if (sc->poll) {
		return pckbc_poll_cmd(sc->sc_kbctag, PCKBC_AUX_SLOT,
		    cmd, len, resplen, resp, 1);
	} else {
		return pckbc_enqueue_cmd(sc->sc_kbctag, PCKBC_AUX_SLOT,
		    cmd, len, resplen, 1, resp);
	}
}

int
pms_spec_cmd(struct pms_softc *sc, int cmd)
{
	if (pms_set_scaling(sc, 1) ||
	    pms_set_resolution(sc, (cmd >> 6) & 0x03) ||
	    pms_set_resolution(sc, (cmd >> 4) & 0x03) ||
	    pms_set_resolution(sc, (cmd >> 2) & 0x03) ||
	    pms_set_resolution(sc, (cmd >> 0) & 0x03))
		return (-1);
	return (0);
}

int
pms_get_devid(struct pms_softc *sc, u_char *resp)
{
	u_char cmd[1];

	cmd[0] = PMS_SEND_DEV_ID;
	return (pms_cmd(sc, cmd, 1, resp, 1));
}

int
pms_get_status(struct pms_softc *sc, u_char *resp)
{
	u_char cmd[1];

	cmd[0] = PMS_SEND_DEV_STATUS;
	return (pms_cmd(sc, cmd, 1, resp, 3));
}

int
pms_set_rate(struct pms_softc *sc, int value)
{
	u_char cmd[2];

	cmd[0] = PMS_SET_SAMPLE;
	cmd[1] = value;
	return (pms_cmd(sc, cmd, 2, NULL, 0));
}

int
pms_set_resolution(struct pms_softc *sc, int value)
{
	u_char cmd[2];

	cmd[0] = PMS_SET_RES;
	cmd[1] = value;
	return (pms_cmd(sc, cmd, 2, NULL, 0));
}

int
pms_set_scaling(struct pms_softc *sc, int scale)
{
	u_char cmd[1];

	switch (scale) {
	case 1:
	default:
		cmd[0] = PMS_SET_SCALE11;
		break;
	case 2:
		cmd[0] = PMS_SET_SCALE21;
		break;
	}
	return (pms_cmd(sc, cmd, 1, NULL, 0));
}

int
pms_reset(struct pms_softc *sc)
{
	u_char cmd[1], resp[2];
	int res;

	cmd[0] = PMS_RESET;
	res = pms_cmd(sc, cmd, 1, resp, 2);
#ifdef DEBUG
	if (res || resp[0] != PMS_RSTDONE || resp[1] != 0)
		printf("%s: reset error %d (response 0x%02x, type 0x%02x)\n",
		    DEVNAME(sc), res, resp[0], resp[1]);
#endif
	return (res);
}

int
pms_dev_enable(struct pms_softc *sc)
{
	u_char cmd[1];
	int res;

	cmd[0] = PMS_DEV_ENABLE;
	res = pms_cmd(sc, cmd, 1, NULL, 0);
	if (res)
		printf("%s: enable error\n", DEVNAME(sc));
	return (res);
}

int
pms_dev_disable(struct pms_softc *sc)
{
	u_char cmd[1];
	int res;

	cmd[0] = PMS_DEV_DISABLE;
	res = pms_cmd(sc, cmd, 1, NULL, 0);
	if (res)
		printf("%s: disable error\n", DEVNAME(sc));
	return (res);
}

void
pms_protocol_lookup(struct pms_softc *sc)
{
	int i;

	sc->protocol = &pms_protocols[0];
	for (i = 1; i < nitems(pms_protocols); i++) {
		pms_reset(sc);
		if (pms_protocols[i].enable(sc)) {
			sc->protocol = &pms_protocols[i];
			break;
		}
	}

	DPRINTF("%s: protocol type %d\n", DEVNAME(sc), sc->protocol->type);
}

int
pms_enable_intelli(struct pms_softc *sc)
{
	u_char resp;

	/* the special sequence to enable the third button and the roller */
	if (pms_set_rate(sc, PMS_INTELLI_MAGIC1) ||
	    pms_set_rate(sc, PMS_INTELLI_MAGIC2) ||
	    pms_set_rate(sc, PMS_INTELLI_MAGIC3) ||
	    pms_get_devid(sc, &resp) ||
	    resp != PMS_INTELLI_ID)
		return (0);

	return (1);
}

int
pms_ioctl_mouse(struct pms_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	int i;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_PS2;
		break;
	case WSMOUSEIO_SRES:
		i = ((int) *(u_int *)data - 12) / 25;
		/* valid values are {0,1,2,3} */
		if (i < 0)
			i = 0;
		if (i > 3)
			i = 3;

		if (pms_set_resolution(sc, i))
			printf("%s: SET_RES command error\n", DEVNAME(sc));
		break;
	default:
		return (-1);
	}
	return (0);
}

int
pms_sync_mouse(struct pms_softc *sc, int data)
{
	if (sc->inputstate != 0)
		return (0);

	switch (sc->protocol->type) {
	case PMS_STANDARD:
		if ((data & 0xc0) != 0)
			return (-1);
		break;
	case PMS_INTELLI:
		if ((data & 0x08) != 0x08)
			return (-1);
		break;
	}

	return (0);
}

void
pms_proc_mouse(struct pms_softc *sc)
{
	u_int buttons;
	int  dx, dy, dz;

	buttons = butmap[sc->packet[0] & PMS_PS2_BUTTONSMASK];
	dx = (sc->packet[0] & PMS_PS2_XNEG) ?
	    (int)sc->packet[1] - 256 : sc->packet[1];
	dy = (sc->packet[0] & PMS_PS2_YNEG) ?
	    (int)sc->packet[2] - 256 : sc->packet[2];

	if (sc->protocol->type == PMS_INTELLI)
		dz = (signed char)sc->packet[3];
	else
		dz = 0;

	WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, dz, 0);
}

int
pmsprobe(struct device *parent, void *match, void *aux)
{
	struct pckbc_attach_args *pa = aux;
	u_char cmd[1], resp[2];
	int res;

	if (pa->pa_slot != PCKBC_AUX_SLOT)
		return (0);

	/* Flush any garbage. */
	pckbc_flush(pa->pa_tag, pa->pa_slot);

	/* reset the device */
	cmd[0] = PMS_RESET;
	res = pckbc_poll_cmd(pa->pa_tag, pa->pa_slot, cmd, 1, 2, resp, 1);
	if (res || resp[0] != PMS_RSTDONE || resp[1] != 0) {
#ifdef DEBUG
		printf("pms: reset error %d (response 0x%02x, type 0x%02x)\n",
		    res, resp[0], resp[1]);
#endif
		return (0);
	}

	return (1);
}

void
pmsattach(struct device *parent, struct device *self, void *aux)
{
	struct pms_softc *sc = (void *)self;
	struct pckbc_attach_args *pa = aux;
	struct wsmousedev_attach_args a;

	sc->sc_kbctag = pa->pa_tag;

	pckbc_set_inputhandler(sc->sc_kbctag, PCKBC_AUX_SLOT,
	    pmsinput, sc, DEVNAME(sc));

	printf("\n");

	a.accessops = &pms_accessops;
	a.accesscookie = sc;

	rw_init(&sc->sc_state_lock, "pmsst");

	/*
	 * Attach the wsmouse, saving a handle to it.
	 * Note that we don't need to check this pointer against NULL
	 * here or in pmsintr, because if this fails pms_enable() will
	 * never be called, so pmsinput() will never be called.
	 */
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);

	sc->poll = 1;
	sc->sc_dev_enable = 0;

	/* See if the device understands an extended (touchpad) protocol. */
	pms_protocol_lookup(sc);

	/* no interrupts until enabled */
	pms_change_state(sc, PMS_STATE_DISABLED, PMS_DEV_IGNORE);
}

int
pmsactivate(struct device *self, int act)
{
	struct pms_softc *sc = (struct pms_softc *)self;

	switch (act) {
	case DVACT_SUSPEND:
		if (sc->sc_state == PMS_STATE_ENABLED)
			pms_change_state(sc, PMS_STATE_SUSPENDED,
			    PMS_DEV_IGNORE);
		break;
	case DVACT_RESUME:
		if (sc->sc_state == PMS_STATE_SUSPENDED)
			pms_change_state(sc, PMS_STATE_ENABLED,
			    PMS_DEV_IGNORE);
		break;
	}
	return (0);
}

int
pms_change_state(struct pms_softc *sc, int newstate, int dev)
{
	if (dev != PMS_DEV_IGNORE) {
		switch (newstate) {
		case PMS_STATE_ENABLED:
			if (sc->sc_dev_enable & dev)
				return (EBUSY);

			sc->sc_dev_enable |= dev;

			if (sc->sc_state == PMS_STATE_ENABLED)
				return (0);

			break;
		case PMS_STATE_DISABLED:
			sc->sc_dev_enable &= ~dev;

			if (sc->sc_dev_enable)
				return (0);

			break;
		}
	}

	switch (newstate) {
	case PMS_STATE_ENABLED:
		sc->inputstate = 0;

		pckbc_slot_enable(sc->sc_kbctag, PCKBC_AUX_SLOT, 1);

		if (sc->poll)
			pckbc_flush(sc->sc_kbctag, PCKBC_AUX_SLOT);

		pms_reset(sc);
		if (sc->protocol->enable != NULL &&
		    sc->protocol->enable(sc) == 0)
			pms_protocol_lookup(sc);

		pms_dev_enable(sc);
		break;
	case PMS_STATE_DISABLED:
	case PMS_STATE_SUSPENDED:
		pms_dev_disable(sc);

		if (sc->protocol->disable)
			sc->protocol->disable(sc);

		pckbc_slot_enable(sc->sc_kbctag, PCKBC_AUX_SLOT, 0);
		break;
	}

	sc->sc_state = newstate;
	sc->poll = (newstate == PMS_STATE_SUSPENDED) ? 1 : 0;

	return (0);
}

int
pms_enable(void *v)
{
	struct pms_softc *sc = v;
	int rv;

	rw_enter_write(&sc->sc_state_lock);
	rv = pms_change_state(sc, PMS_STATE_ENABLED, PMS_DEV_PRIMARY);
	rw_exit_write(&sc->sc_state_lock);

	return (rv);
}

void
pms_disable(void *v)
{
	struct pms_softc *sc = v;

	rw_enter_write(&sc->sc_state_lock);
	pms_change_state(sc, PMS_STATE_DISABLED, PMS_DEV_PRIMARY);
	rw_exit_write(&sc->sc_state_lock);
}

int
pms_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct pms_softc *sc = v;

	if (sc->protocol->ioctl)
		return (sc->protocol->ioctl(sc, cmd, data, flag, p));
	else
		return (-1);
}

int
pms_sec_enable(void *v)
{
	struct pms_softc *sc = v;
	int rv;

	rw_enter_write(&sc->sc_state_lock);
	rv = pms_change_state(sc, PMS_STATE_ENABLED, PMS_DEV_SECONDARY);
	rw_exit_write(&sc->sc_state_lock);

	return (rv);
}

void
pms_sec_disable(void *v)
{
	struct pms_softc *sc = v;

	rw_enter_write(&sc->sc_state_lock);
	pms_change_state(sc, PMS_STATE_DISABLED, PMS_DEV_SECONDARY);
	rw_exit_write(&sc->sc_state_lock);
}

int
pms_sec_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_PS2;
		break;
	default:
		return (-1);
	}
	return (0);
}

void
pmsinput(void *vsc, int data)
{
	struct pms_softc *sc = vsc;

	if (sc->sc_state != PMS_STATE_ENABLED) {
		/* Interrupts are not expected.  Discard the byte. */
		return;
	}

	sc->packet[sc->inputstate] = data;
	if (sc->protocol->sync(sc, data)) {
#ifdef DIAGNOSTIC
		printf("%s: not in sync yet, discard input (state %d)\n",
		    DEVNAME(sc), sc->inputstate);
#endif
		sc->inputstate = 0;
		return;
	}

	sc->inputstate++;

	if (sc->inputstate != sc->protocol->packetsize)
		return;

	sc->inputstate = 0;
	sc->protocol->proc(sc);
}

int
synaptics_set_mode(struct pms_softc *sc, int mode)
{
	struct synaptics_softc *syn = sc->synaptics;

	if (pms_spec_cmd(sc, mode) ||
	    pms_set_rate(sc, SYNAPTICS_CMD_SET_MODE))
		return (-1);

	syn->mode = mode;

	return (0);
}

int
synaptics_query(struct pms_softc *sc, int query, int *val)
{
	u_char resp[3];

	if (pms_spec_cmd(sc, query) ||
	    pms_get_status(sc, resp))
		return (-1);

	if (val)
		*val = (resp[0] << 16) | (resp[1] << 8) | resp[2];

	return (0);
}

int
synaptics_get_hwinfo(struct pms_softc *sc)
{
	struct synaptics_softc *syn = sc->synaptics;
	struct wsmousehw *hw;

	hw = wsmouse_get_hw(sc->sc_wsmousedev);

	if (synaptics_query(sc, SYNAPTICS_QUE_IDENTIFY, &syn->identify))
		return (-1);
	if (synaptics_query(sc, SYNAPTICS_QUE_CAPABILITIES,
	    &syn->capabilities))
		return (-1);
	if (synaptics_query(sc, SYNAPTICS_QUE_MODEL, &syn->model))
		return (-1);
	if ((SYNAPTICS_CAP_EXTENDED_QUERIES(syn->capabilities) >= 1) &&
	    synaptics_query(sc, SYNAPTICS_QUE_EXT_MODEL, &syn->ext_model))
		return (-1);
	if ((SYNAPTICS_CAP_EXTENDED_QUERIES(syn->capabilities) >= 4) &&
	    synaptics_query(sc, SYNAPTICS_QUE_EXT_CAPABILITIES,
		&syn->ext_capabilities))
		return (-1);
	if ((SYNAPTICS_ID_MAJOR(syn->identify) >= 4) &&
	    synaptics_query(sc, SYNAPTICS_QUE_RESOLUTION, &syn->resolution))
		return (-1);
	if ((SYNAPTICS_CAP_EXTENDED_QUERIES(syn->capabilities) >= 5) &&
	    (syn->ext_capabilities & SYNAPTICS_EXT_CAP_MAX_DIMENSIONS) &&
	    synaptics_query(sc, SYNAPTICS_QUE_EXT_DIMENSIONS, &syn->dimension))
		return (-1);
	if (SYNAPTICS_ID_FULL(syn->identify) >= 0x705) {
		if (synaptics_query(sc, SYNAPTICS_QUE_MODES, &syn->modes))
			return (-1);
		if ((syn->modes & SYNAPTICS_EXT2_CAP) &&
		    synaptics_query(sc, SYNAPTICS_QUE_EXT2_CAPABILITIES,
		    &syn->ext2_capabilities))
			return (-1);
	}

	if ((syn->ext_capabilities & SYNAPTICS_EXT_CAP_CLICKPAD) &&
	    !(syn->ext2_capabilities & SYNAPTICS_EXT2_CAP_BUTTONS_STICK)
	    && mouse_has_softbtn)
		hw->type = WSMOUSE_TYPE_SYNAP_SBTN;
	else
		hw->type = WSMOUSE_TYPE_SYNAPTICS;

	hw->hw_type = (syn->ext_capabilities & SYNAPTICS_EXT_CAP_CLICKPAD)
	    ? WSMOUSEHW_CLICKPAD : WSMOUSEHW_TOUCHPAD;

	if (syn->resolution & SYNAPTICS_RESOLUTION_VALID) {
		hw->h_res = SYNAPTICS_RESOLUTION_X(syn->resolution);
		hw->v_res = SYNAPTICS_RESOLUTION_Y(syn->resolution);
	}
	hw->x_min = SYNAPTICS_XMIN_BEZEL;
	hw->y_min = SYNAPTICS_YMIN_BEZEL;
	hw->x_max = (syn->dimension) ?
	    SYNAPTICS_DIM_X(syn->dimension) : SYNAPTICS_XMAX_BEZEL;
	hw->y_max = (syn->dimension) ?
	    SYNAPTICS_DIM_Y(syn->dimension) : SYNAPTICS_YMAX_BEZEL;

	hw->contacts_max = SYNAPTICS_MAX_FINGERS;

	syn->sec_buttons = 0;

	if (SYNAPTICS_EXT_MODEL_BUTTONS(syn->ext_model) > 8)
		syn->ext_model &= ~0xf000;

	if ((syn->model & SYNAPTICS_MODEL_NEWABS) == 0) {
		printf("%s: don't support Synaptics OLDABS\n", DEVNAME(sc));
		return (-1);
	}

	if ((SYNAPTICS_ID_MAJOR(syn->identify) == 5) &&
	    (SYNAPTICS_ID_MINOR(syn->identify) == 9))
		syn->mask = SYNAPTICS_MASK_NEWABS_RELAXED;
	else
		syn->mask = SYNAPTICS_MASK_NEWABS_STRICT;

	return (0);
}

void
synaptics_sec_proc(struct pms_softc *sc)
{
	struct synaptics_softc *syn = sc->synaptics;
	u_int buttons;
	int dx, dy;

	if ((sc->sc_dev_enable & PMS_DEV_SECONDARY) == 0)
		return;

	buttons = butmap[sc->packet[1] & PMS_PS2_BUTTONSMASK];
	buttons |= syn->sec_buttons;
	dx = (sc->packet[1] & PMS_PS2_XNEG) ?
	    (int)sc->packet[4] - 256 : sc->packet[4];
	dy = (sc->packet[1] & PMS_PS2_YNEG) ?
	    (int)sc->packet[5] - 256 : sc->packet[5];

	WSMOUSE_INPUT(sc->sc_sec_wsmousedev, buttons, dx, dy, 0, 0);
}

int
synaptics_knock(struct pms_softc *sc)
{
	u_char resp[3];

	if (pms_set_resolution(sc, 0) ||
	    pms_set_resolution(sc, 0) ||
	    pms_set_resolution(sc, 0) ||
	    pms_set_resolution(sc, 0) ||
	    pms_get_status(sc, resp) ||
	    resp[1] != SYNAPTICS_ID_MAGIC)
		return (-1);

	return (0);
}

int
pms_enable_synaptics(struct pms_softc *sc)
{
	struct synaptics_softc *syn = sc->synaptics;
	struct wsmousedev_attach_args a;
	int mode, i;

	if (synaptics_knock(sc)) {
		if (sc->synaptics == NULL)
			goto err;
		/*
		 * Some synaptics touchpads don't resume quickly.
		 * Retry a few times.
		 */
		for (i = 10; i > 0; --i) {
			printf("%s: device not resuming, retrying\n",
			    DEVNAME(sc));
			pms_reset(sc);
			if (synaptics_knock(sc) == 0)
				break;
			delay(100000);
		}
		if (i == 0) {
			printf("%s: lost device\n", DEVNAME(sc));
			goto err;
		}
	}

	if (sc->synaptics == NULL) {
		sc->synaptics = syn = malloc(sizeof(struct synaptics_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (syn == NULL) {
			printf("%s: synaptics: not enough memory\n",
			    DEVNAME(sc));
			goto err;
		}

		if (synaptics_get_hwinfo(sc)) {
			free(sc->synaptics, M_DEVBUF,
			    sizeof(struct synaptics_softc));
			sc->synaptics = NULL;
			goto err;
		}

		/* enable pass-through PS/2 port if supported */
		if (syn->capabilities & SYNAPTICS_CAP_PASSTHROUGH) {
			a.accessops = &pms_sec_accessops;
			a.accesscookie = sc;
			sc->sc_sec_wsmousedev = config_found((void *)sc, &a,
			    wsmousedevprint);
		}

		if (wsmouse_configure(sc->sc_wsmousedev, synaptics_params,
		    nitems(synaptics_params)))
			goto err;

		printf("%s: Synaptics %s, firmware %d.%d\n", DEVNAME(sc),
		    (syn->ext_capabilities & SYNAPTICS_EXT_CAP_CLICKPAD ?
			"clickpad" : "touchpad"),
		    SYNAPTICS_ID_MAJOR(syn->identify),
		    SYNAPTICS_ID_MINOR(syn->identify));
	}

	mode = SYNAPTICS_ABSOLUTE_MODE | SYNAPTICS_HIGH_RATE;
	if (SYNAPTICS_ID_MAJOR(syn->identify) >= 4)
		mode |= SYNAPTICS_DISABLE_GESTURE;
	if (syn->capabilities & SYNAPTICS_CAP_EXTENDED)
		mode |= SYNAPTICS_W_MODE;
	if (synaptics_set_mode(sc, mode))
		goto err;

	/* enable advanced gesture mode if supported */
	if ((syn->ext_capabilities & SYNAPTICS_EXT_CAP_ADV_GESTURE) &&
	    (pms_spec_cmd(sc, SYNAPTICS_QUE_MODEL) ||
	     pms_set_rate(sc, SYNAPTICS_CMD_SET_ADV_GESTURE_MODE)))
		goto err;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_ioctl_synaptics(struct pms_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;
	struct wsmousehw *hw;
	int wsmode;

	hw = wsmouse_get_hw(sc->sc_wsmousedev);

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = hw->type;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		wsmc->minx = hw->x_min;
		wsmc->maxx = hw->x_max;
		wsmc->miny = hw->y_min;
		wsmc->maxy = hw->y_max;
		wsmc->swapxy = 0;
		wsmc->resx = hw->h_res;
		wsmc->resy = hw->v_res;
		break;
	case WSMOUSEIO_SETMODE:
		wsmode = *(u_int *)data;
		if (wsmode != WSMOUSE_COMPAT && wsmode != WSMOUSE_NATIVE)
			return (EINVAL);
		wsmouse_set_mode(sc->sc_wsmousedev, wsmode);
		break;
	default:
		return (-1);
	}
	return (0);
}

int
pms_sync_synaptics(struct pms_softc *sc, int data)
{
	struct synaptics_softc *syn = sc->synaptics;

	switch (sc->inputstate) {
	case 0:
		if ((data & syn->mask) != SYNAPTICS_VALID_NEWABS_FIRST)
			return (-1);
		break;
	case 3:
		if ((data & syn->mask) != SYNAPTICS_VALID_NEWABS_NEXT)
			return (-1);
		break;
	}

	return (0);
}

void
pms_proc_synaptics(struct pms_softc *sc)
{
	struct synaptics_softc *syn = sc->synaptics;
	u_int buttons;
	int x, y, z, w, fingerwidth;

	w = ((sc->packet[0] & 0x30) >> 2) | ((sc->packet[0] & 0x04) >> 1) |
	    ((sc->packet[3] & 0x04) >> 2);
	z = sc->packet[2];

	if ((syn->capabilities & SYNAPTICS_CAP_EXTENDED) == 0) {
		/*
		 * Emulate W mode for models that don't provide it. Bit 3
		 * of the w-input signals a touch ("finger"), Bit 2 and
		 * the "gesture" bits 1-0 can be ignored.
		 */
		if (w & 8)
			w = 4;
		else
			z = w = 0;
	}


	if ((syn->capabilities & SYNAPTICS_CAP_PASSTHROUGH) && w == 3) {
		synaptics_sec_proc(sc);
		return;
	}

	if ((sc->sc_dev_enable & PMS_DEV_PRIMARY) == 0)
		return;

	/* XXX ignore advanced gesture packet, not yet supported */
	if ((syn->ext_capabilities & SYNAPTICS_EXT_CAP_ADV_GESTURE) && w == 2)
		return;

	x = ((sc->packet[3] & 0x10) << 8) | ((sc->packet[1] & 0x0f) << 8) |
	    sc->packet[4];
	y = ((sc->packet[3] & 0x20) << 7) | ((sc->packet[1] & 0xf0) << 4) |
	    sc->packet[5];

	buttons = ((sc->packet[0] & sc->packet[3]) & 0x01) ?
	    WSMOUSE_BUTTON(1) : 0;
	buttons |= ((sc->packet[0] & sc->packet[3]) & 0x02) ?
	    WSMOUSE_BUTTON(3) : 0;

	if (syn->ext_capabilities & SYNAPTICS_EXT_CAP_CLICKPAD) {
		buttons |= ((sc->packet[0] ^ sc->packet[3]) & 0x01) ?
		    WSMOUSE_BUTTON(1) : 0;
	} else if (syn->capabilities & SYNAPTICS_CAP_MIDDLE_BUTTON) {
		buttons |= ((sc->packet[0] ^ sc->packet[3]) & 0x01) ?
		    WSMOUSE_BUTTON(2) : 0;
	}

	if (syn->capabilities & SYNAPTICS_CAP_FOUR_BUTTON) {
		buttons |= ((sc->packet[0] ^ sc->packet[3]) & 0x01) ?
		    WSMOUSE_BUTTON(4) : 0;
		buttons |= ((sc->packet[0] ^ sc->packet[3]) & 0x02) ?
		    WSMOUSE_BUTTON(5) : 0;
	} else if (SYNAPTICS_EXT_MODEL_BUTTONS(syn->ext_model) &&
	    ((sc->packet[0] ^ sc->packet[3]) & 0x02)) {
		if (syn->ext2_capabilities & SYNAPTICS_EXT2_CAP_BUTTONS_STICK) {
			/*
			 * Trackstick buttons on this machine are wired to the
			 * trackpad as extra buttons, so route the event
			 * through the trackstick interface as normal buttons
			 */
			syn->sec_buttons =
			    (sc->packet[4] & 0x01) ? WSMOUSE_BUTTON(1) : 0;
			syn->sec_buttons |=
			    (sc->packet[5] & 0x01) ? WSMOUSE_BUTTON(3) : 0;
			syn->sec_buttons |=
			    (sc->packet[4] & 0x02) ? WSMOUSE_BUTTON(2) : 0;
			wsmouse_buttons(
			    sc->sc_sec_wsmousedev, syn->sec_buttons);
			wsmouse_input_sync(sc->sc_sec_wsmousedev);
			return;
		}

		buttons |= (sc->packet[4] & 0x01) ? WSMOUSE_BUTTON(6) : 0;
		buttons |= (sc->packet[5] & 0x01) ? WSMOUSE_BUTTON(7) : 0;
		buttons |= (sc->packet[4] & 0x02) ? WSMOUSE_BUTTON(8) : 0;
		buttons |= (sc->packet[5] & 0x02) ? WSMOUSE_BUTTON(9) : 0;
		buttons |= (sc->packet[4] & 0x04) ? WSMOUSE_BUTTON(10) : 0;
		buttons |= (sc->packet[5] & 0x04) ? WSMOUSE_BUTTON(11) : 0;
		buttons |= (sc->packet[4] & 0x08) ? WSMOUSE_BUTTON(12) : 0;
		buttons |= (sc->packet[5] & 0x08) ? WSMOUSE_BUTTON(13) : 0;
		x &= ~0x0f;
		y &= ~0x0f;
	}

	if (z) {
		fingerwidth = max(w, 4);
		w = (w < 2 ? w + 2 : 1);
	} else {
		fingerwidth = 0;
		w = 0;
	}
	wsmouse_set(sc->sc_wsmousedev, WSMOUSE_TOUCH_WIDTH, fingerwidth, 0);
	WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons, x, y, z, w);
}

void
pms_disable_synaptics(struct pms_softc *sc)
{
	struct synaptics_softc *syn = sc->synaptics;

	if (syn->capabilities & SYNAPTICS_CAP_SLEEP)
		synaptics_set_mode(sc, SYNAPTICS_SLEEP_MODE |
		    SYNAPTICS_DISABLE_GESTURE);
}

int
alps_sec_proc(struct pms_softc *sc)
{
	struct alps_softc *alps = sc->alps;
	int dx, dy, pos = 0;

	if ((sc->packet[0] & PMS_ALPS_PS2_MASK) == PMS_ALPS_PS2_VALID) {
		/*
		 * We need to keep buttons states because interleaved
		 * packets only signalize x/y movements.
		 */
		alps->sec_buttons = butmap[sc->packet[0] & PMS_PS2_BUTTONSMASK];
	} else if ((sc->packet[3] & PMS_ALPS_INTERLEAVED_MASK) ==
	    PMS_ALPS_INTERLEAVED_VALID) {
		sc->inputstate = 3;
		pos = 3;
	} else {
		return (0);
	}

	if ((sc->sc_dev_enable & PMS_DEV_SECONDARY) == 0)
		return (1);

	dx = (sc->packet[pos] & PMS_PS2_XNEG) ?
	    (int)sc->packet[pos + 1] - 256 : sc->packet[pos + 1];
	dy = (sc->packet[pos] & PMS_PS2_YNEG) ?
	    (int)sc->packet[pos + 2] - 256 : sc->packet[pos + 2];

	WSMOUSE_INPUT(sc->sc_sec_wsmousedev, alps->sec_buttons, dx, dy, 0, 0);

	return (1);
}

int
alps_get_hwinfo(struct pms_softc *sc)
{
	struct alps_softc *alps = sc->alps;
	u_char resp[3];
	int i;

	if (pms_set_resolution(sc, 0) ||
	    pms_set_scaling(sc, 2) ||
	    pms_set_scaling(sc, 2) ||
	    pms_set_scaling(sc, 2) ||
	    pms_get_status(sc, resp)) {
		DPRINTF("%s: alps: model query error\n", DEVNAME(sc));
		return (-1);
	}

	alps->version = (resp[0] << 8) | (resp[1] << 4) | (resp[2] / 20 + 1);

	for (i = 0; i < nitems(alps_models); i++)
		if (alps->version == alps_models[i].version) {
			alps->model = alps_models[i].model;
			alps->mask = alps_models[i].mask;
			return (0);
		}

	return (-1);
}

int
pms_enable_alps(struct pms_softc *sc)
{
	struct alps_softc *alps = sc->alps;
	struct wsmousedev_attach_args a;
	u_char resp[3];

	if (pms_set_resolution(sc, 0) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_get_status(sc, resp) ||
	    resp[0] != PMS_ALPS_MAGIC1 ||
	    resp[1] != PMS_ALPS_MAGIC2 ||
	    (resp[2] != PMS_ALPS_MAGIC3_1 && resp[2] != PMS_ALPS_MAGIC3_2 &&
	    resp[2] != PMS_ALPS_MAGIC3_3))
		goto err;

	if (sc->alps == NULL) {
		sc->alps = alps = malloc(sizeof(struct alps_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (alps == NULL) {
			printf("%s: alps: not enough memory\n", DEVNAME(sc));
			goto err;
		}

		if (alps_get_hwinfo(sc)) {
			free(sc->alps, M_DEVBUF, sizeof(struct alps_softc));
			sc->alps = NULL;
			goto err;
		}

		printf("%s: ALPS %s, version 0x%04x\n", DEVNAME(sc),
		    (alps->model & ALPS_DUALPOINT ? "Dualpoint" : "Glidepoint"),
		    alps->version);

		alps->min_x = ALPS_XMIN_BEZEL;
		alps->min_y = ALPS_YMIN_BEZEL;
		alps->max_x = ALPS_XMAX_BEZEL;
		alps->max_y = ALPS_YMAX_BEZEL;

		alps->wsmode = WSMOUSE_COMPAT;

		if (alps->model & ALPS_DUALPOINT) {
			a.accessops = &pms_sec_accessops;
			a.accesscookie = sc;
			sc->sc_sec_wsmousedev = config_found((void *)sc, &a,
			    wsmousedevprint);
		}
	}

	if (alps->model == 0)
		goto err;

	if ((alps->model & ALPS_PASSTHROUGH) &&
	   (pms_set_scaling(sc, 2) ||
	    pms_set_scaling(sc, 2) ||
	    pms_set_scaling(sc, 2) ||
	    pms_dev_disable(sc))) {
		DPRINTF("%s: alps: passthrough on error\n", DEVNAME(sc));
		goto err;
	}

	if (pms_dev_disable(sc) ||
	    pms_dev_disable(sc) ||
	    pms_set_rate(sc, 0x0a)) {
		DPRINTF("%s: alps: tapping error\n", DEVNAME(sc));
		goto err;
	}

	if (pms_dev_disable(sc) ||
	    pms_dev_disable(sc) ||
	    pms_dev_disable(sc) ||
	    pms_dev_disable(sc) ||
	    pms_dev_enable(sc)) {
		DPRINTF("%s: alps: absolute mode error\n", DEVNAME(sc));
		goto err;
	}

	if ((alps->model & ALPS_PASSTHROUGH) &&
	   (pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_dev_disable(sc))) {
		DPRINTF("%s: alps: passthrough off error\n", DEVNAME(sc));
		goto err;
	}

	alps->sec_buttons = 0;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_ioctl_alps(struct pms_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct alps_softc *alps = sc->alps;
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;
	int wsmode;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_ALPS;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		wsmc->minx = alps->min_x;
		wsmc->maxx = alps->max_x;
		wsmc->miny = alps->min_y;
		wsmc->maxy = alps->max_y;
		wsmc->swapxy = 0;
		break;
	case WSMOUSEIO_SETMODE:
		wsmode = *(u_int *)data;
		if (wsmode != WSMOUSE_COMPAT && wsmode != WSMOUSE_NATIVE)
			return (EINVAL);
		alps->wsmode = wsmode;
		break;
	default:
		return (-1);
	}
	return (0);
}

int
pms_sync_alps(struct pms_softc *sc, int data)
{
	struct alps_softc *alps = sc->alps;

	if ((alps->model & ALPS_DUALPOINT) &&
	    (sc->packet[0] & PMS_ALPS_PS2_MASK) == PMS_ALPS_PS2_VALID) {
		if (sc->inputstate == 2)
			sc->inputstate += 3;
		return (0);
	}

	switch (sc->inputstate) {
	case 0:
		if ((data & alps->mask) != alps->mask)
			return (-1);
		break;
	case 1:
	case 2:
	case 3:
		if ((data & PMS_ALPS_MASK) != PMS_ALPS_VALID)
			return (-1);
		break;
	case 4:
	case 5:
		if ((alps->model & ALPS_INTERLEAVED) == 0 &&
		    (data & PMS_ALPS_MASK) != PMS_ALPS_VALID)
			return (-1);
		break;
	}

	return (0);
}

void
pms_proc_alps(struct pms_softc *sc)
{
	struct alps_softc *alps = sc->alps;
	int x, y, z, dx, dy;
	u_int buttons, gesture;

	if ((alps->model & ALPS_DUALPOINT) && alps_sec_proc(sc))
		return;

	x = sc->packet[1] | ((sc->packet[2] & 0x78) << 4);
	y = sc->packet[4] | ((sc->packet[3] & 0x70) << 3);
	z = sc->packet[5];

	buttons = ((sc->packet[3] & 1) ? WSMOUSE_BUTTON(1) : 0) |
	    ((sc->packet[3] & 2) ? WSMOUSE_BUTTON(3) : 0) |
	    ((sc->packet[3] & 4) ? WSMOUSE_BUTTON(2) : 0);

	if ((sc->sc_dev_enable & PMS_DEV_SECONDARY) && z == ALPS_Z_MAGIC) {
		dx = (x > ALPS_XSEC_BEZEL / 2) ? (x - ALPS_XSEC_BEZEL) : x;
		dy = (y > ALPS_YSEC_BEZEL / 2) ? (y - ALPS_YSEC_BEZEL) : y;

		WSMOUSE_INPUT(sc->sc_sec_wsmousedev, buttons, dx, dy, 0, 0);

		return;
	}

	if ((sc->sc_dev_enable & PMS_DEV_PRIMARY) == 0)
		return;

	/*
	 * XXX The Y-axis is in the oposit direction compared to
	 * Synaptics touchpads and PS/2 mouses.
	 * It's why we need to translate the y value here for both
	 * NATIVE and COMPAT modes.
	 */
	y = ALPS_YMAX_BEZEL - y + ALPS_YMIN_BEZEL;

	if (alps->wsmode == WSMOUSE_NATIVE) {
		if (alps->gesture == ALPS_TAP) {
			/* Report a touch with the tap coordinates. */
			WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons,
			    alps->old_x, alps->old_y, ALPS_PRESSURE, 0);
			if (z > 0) {
				/*
				 * The hardware doesn't send a null pressure
				 * event when dragging starts.
				 */
				WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons,
				    alps->old_x, alps->old_y, 0, 0);
			}
		}

		gesture = sc->packet[2] & 0x03;
		if (gesture != ALPS_TAP)
			WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons, x, y, z, 0);

		if (alps->gesture != ALPS_DRAG || gesture != ALPS_TAP)
			alps->gesture = gesture;

		alps->old_x = x;
		alps->old_y = y;

	} else {
		dx = dy = 0;
		if (z > ALPS_PRESSURE) {
			dx = x - alps->old_x;
			dy = y - alps->old_y;

			/* Prevent jump */
			dx = abs(dx) > 50 ? 0 : dx;
			dy = abs(dy) > 50 ? 0 : dy;
		}

		if (dx || dy || buttons != alps->old_buttons)
			WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, 0, 0);

		alps->old_x = x;
		alps->old_y = y;
		alps->old_buttons = buttons;
	}
}

int
elantech_set_absolute_mode_v1(struct pms_softc *sc)
{
	int i;
	u_char resp[3];

	/* Enable absolute mode. Magic numbers from Linux driver. */
	if (pms_spec_cmd(sc, ELANTECH_CMD_WRITE_REG) ||
	    pms_spec_cmd(sc, 0x10) ||
	    pms_spec_cmd(sc, 0x16) ||
	    pms_set_scaling(sc, 1) ||
	    pms_spec_cmd(sc, ELANTECH_CMD_WRITE_REG) ||
	    pms_spec_cmd(sc, 0x11) ||
	    pms_spec_cmd(sc, 0x8f) ||
	    pms_set_scaling(sc, 1))
		return (-1);

	/* Read back reg 0x10 to ensure hardware is ready. */
	for (i = 0; i < 5; i++) {
		if (pms_spec_cmd(sc, ELANTECH_CMD_READ_REG) ||
		    pms_spec_cmd(sc, 0x10) ||
		    pms_get_status(sc, resp) == 0)
			break;
		delay(2000);
	}
	if (i == 5)
		return (-1);

	if ((resp[0] & ELANTECH_ABSOLUTE_MODE) == 0)
		return (-1);

	return (0);
}

int
elantech_set_absolute_mode_v2(struct pms_softc *sc)
{
	int i;
	u_char resp[3];
	u_char reg10 = (sc->elantech->fw_version == 0x20030 ? 0x54 : 0xc4);

	/* Enable absolute mode. Magic numbers from Linux driver. */
	if (elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x10) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, reg10) ||
	    pms_set_scaling(sc, 1) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x11) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x88) ||
	    pms_set_scaling(sc, 1))
		return (-1);

	/* Read back reg 0x10 to ensure hardware is ready. */
	for (i = 0; i < 5; i++) {
		if (elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
		    elantech_ps2_cmd(sc, ELANTECH_CMD_READ_REG) ||
		    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
		    elantech_ps2_cmd(sc, 0x10) ||
		    pms_get_status(sc, resp) == 0)
			break;
		delay(2000);
	}
	if (i == 5)
		return (-1);

	return (0);
}

int
elantech_set_absolute_mode_v3(struct pms_softc *sc)
{
	int i;
	u_char resp[3];

	/* Enable absolute mode. Magic numbers from Linux driver. */
	if (elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_READ_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x10) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x0b) ||
	    pms_set_scaling(sc, 1))
		return (-1);

	/* Read back reg 0x10 to ensure hardware is ready. */
	for (i = 0; i < 5; i++) {
		if (elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
		    elantech_ps2_cmd(sc, ELANTECH_CMD_READ_WRITE_REG) ||
		    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
		    elantech_ps2_cmd(sc, 0x10) ||
		    pms_get_status(sc, resp) == 0)
			break;
		delay(2000);
	}
	if (i == 5)
		return (-1);

	return (0);
}

int
elantech_set_absolute_mode_v4(struct pms_softc *sc)
{
	/* Enable absolute mode. Magic numbers from Linux driver. */
	if (elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_READ_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x07) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_READ_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x01) ||
	    pms_set_scaling(sc, 1))
		return (-1);

	/* v4 has no register 0x10 to read response from */

	return (0);
}

int
elantech_get_hwinfo_v1(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	int fw_version;
	u_char capabilities[3];

	if (synaptics_query(sc, ELANTECH_QUE_FW_VER, &fw_version))
		return (-1);

	if (fw_version < 0x20030 || fw_version == 0x20600) {
		if (fw_version < 0x20000)
			elantech->flags |= ELANTECH_F_HW_V1_OLD;
	} else
		return (-1);

	elantech->fw_version = fw_version;

	if (pms_spec_cmd(sc, ELANTECH_QUE_CAPABILITIES) ||
	    pms_get_status(sc, capabilities))
		return (-1);

	if (capabilities[0] & ELANTECH_CAP_HAS_ROCKER)
		elantech->flags |= ELANTECH_F_HAS_ROCKER;

	if (elantech_set_absolute_mode_v1(sc))
		return (-1);

	elantech->min_x = ELANTECH_V1_X_MIN;
	elantech->max_x = ELANTECH_V1_X_MAX;
	elantech->min_y = ELANTECH_V1_Y_MIN;
	elantech->max_y = ELANTECH_V1_Y_MAX;

	return (0);
}

int
elantech_get_hwinfo_v2(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	int fw_version, ic_ver;
	u_char capabilities[3];
	int i, fixed_dpi;
	u_char resp[3];

	if (synaptics_query(sc, ELANTECH_QUE_FW_VER, &fw_version))
		return (-1);

	ic_ver = (fw_version & 0x0f0000) >> 16;
	if (ic_ver != 2 && ic_ver != 4)
		return (-1);

	elantech->fw_version = fw_version;
	if (fw_version >= 0x20800)
		elantech->flags |= ELANTECH_F_REPORTS_PRESSURE;

	if (pms_spec_cmd(sc, ELANTECH_QUE_CAPABILITIES) ||
	    pms_get_status(sc, capabilities))
		return (-1);

	if (elantech_set_absolute_mode_v2(sc))
		return (-1);

	if (fw_version == 0x20800 || fw_version == 0x20b00 ||
	    fw_version == 0x20030) {
		elantech->max_x = ELANTECH_V2_X_MAX;
		elantech->max_y = ELANTECH_V2_Y_MAX;
	} else {
		if (pms_spec_cmd(sc, ELANTECH_QUE_FW_ID) ||
		    pms_get_status(sc, resp))
			return (-1);
		fixed_dpi = resp[1] & 0x10;
		i = (fw_version > 0x20800 && fw_version < 0x20900) ? 1 : 2;
		if ((fw_version >> 16) == 0x14 && fixed_dpi) {
			if (pms_spec_cmd(sc, ELANTECH_QUE_SAMPLE) ||
			    pms_get_status(sc, resp))
				return (-1);
			elantech->max_x = (capabilities[1] - i) * resp[1] / 2;
			elantech->max_y = (capabilities[2] - i) * resp[2] / 2;
		} else if (fw_version == 0x040216) {
			elantech->max_x = 819;
			elantech->max_y = 405;
		} else if (fw_version == 0x040219 || fw_version == 0x040215) {
			elantech->max_x = 900;
			elantech->max_y = 500;
		} else {
			elantech->max_x = (capabilities[1] - i) * 64;
			elantech->max_y = (capabilities[2] - i) * 64;
		}
	}

	return (0);
}

int
elantech_get_hwinfo_v3(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	int fw_version;
	u_char resp[3];

	if (synaptics_query(sc, ELANTECH_QUE_FW_VER, &fw_version))
		return (-1);

	if (((fw_version & 0x0f0000) >> 16) != 5)
		return (-1);

	elantech->fw_version = fw_version;
	elantech->flags |= ELANTECH_F_REPORTS_PRESSURE;

	if ((fw_version & 0x4000) == 0x4000)
		elantech->flags |= ELANTECH_F_CRC_ENABLED;

	if (elantech_set_absolute_mode_v3(sc))
		return (-1);

	if (pms_spec_cmd(sc, ELANTECH_QUE_FW_ID) ||
	    pms_get_status(sc, resp))
		return (-1);

	elantech->max_x = (resp[0] & 0x0f) << 8 | resp[1];
	elantech->max_y = (resp[0] & 0xf0) << 4 | resp[2];

	return (0);
}

int
elantech_get_hwinfo_v4(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	struct wsmousehw *hw;
	int fw_version;
	u_char capabilities[3];
	u_char resp[3];

	if (synaptics_query(sc, ELANTECH_QUE_FW_VER, &fw_version))
		return (-1);

	if (((fw_version & 0x0f0000) >> 16) != 6 &&
	    (fw_version & 0x0f0000) >> 16 != 8)
		return (-1);

	elantech->fw_version = fw_version;
	elantech->flags |= ELANTECH_F_REPORTS_PRESSURE;

	if (elantech_set_absolute_mode_v4(sc))
		return (-1);

	if (pms_spec_cmd(sc, ELANTECH_QUE_CAPABILITIES) ||
	    pms_get_status(sc, capabilities))
		return (-1);

	if (pms_spec_cmd(sc, ELANTECH_QUE_FW_ID) ||
	    pms_get_status(sc, resp))
		return (-1);

	hw = wsmouse_get_hw(sc->sc_wsmousedev);
	hw->x_max = (resp[0] & 0x0f) << 8 | resp[1];
	hw->y_max = (resp[0] & 0xf0) << 4 | resp[2];

	if ((capabilities[1] < 2) || (capabilities[1] > hw->x_max))
		return (-1);

	hw->type = WSMOUSE_TYPE_ELANTECH;
	hw->hw_type = WSMOUSEHW_CLICKPAD;
	hw->mt_slots = ELANTECH_MAX_FINGERS;

	elantech->width = hw->x_max / (capabilities[1] - 1);

	return (0);
}

int
elantech_ps2_cmd(struct pms_softc *sc, u_char command)
{
	u_char cmd[1];

	cmd[0] = command;
	return (pms_cmd(sc, cmd, 1, NULL, 0));
}

int
elantech_knock(struct pms_softc *sc)
{
	u_char resp[3];

	if (pms_dev_disable(sc) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_get_status(sc, resp) ||
	    resp[0] != PMS_ELANTECH_MAGIC1 ||
	    resp[1] != PMS_ELANTECH_MAGIC2 ||
	    (resp[2] != PMS_ELANTECH_MAGIC3_1 &&
	    resp[2] != PMS_ELANTECH_MAGIC3_2))
		return (-1);

	return (0);
}

int
pms_enable_elantech_v1(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	int i;

	if (elantech_knock(sc))
		goto err;

	if (sc->elantech == NULL) {
		sc->elantech = elantech = malloc(sizeof(struct elantech_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (elantech == NULL) {
			printf("%s: elantech: not enough memory\n",
			    DEVNAME(sc));
			goto err;
		}

		if (elantech_get_hwinfo_v1(sc)) {
			free(sc->elantech, M_DEVBUF,
			    sizeof(struct elantech_softc));
			sc->elantech = NULL;
			goto err;
		}

		printf("%s: Elantech Touchpad, version %d, firmware 0x%x\n",
		    DEVNAME(sc), 1, sc->elantech->fw_version);
	} else if (elantech_set_absolute_mode_v1(sc))
		goto err;

	for (i = 0; i < nitems(sc->elantech->parity); i++)
		sc->elantech->parity[i] = sc->elantech->parity[i & (i - 1)] ^ 1;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_enable_elantech_v2(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;

	if (elantech_knock(sc))
		goto err;

	if (sc->elantech == NULL) {
		sc->elantech = elantech = malloc(sizeof(struct elantech_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (elantech == NULL) {
			printf("%s: elantech: not enough memory\n",
			    DEVNAME(sc));
			goto err;
		}

		if (elantech_get_hwinfo_v2(sc)) {
			free(sc->elantech, M_DEVBUF,
			    sizeof(struct elantech_softc));
			sc->elantech = NULL;
			goto err;
		}

		printf("%s: Elantech Touchpad, version %d, firmware 0x%x\n",
		    DEVNAME(sc), 2, sc->elantech->fw_version);
	} else if (elantech_set_absolute_mode_v2(sc))
		goto err;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_enable_elantech_v3(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;

	if (elantech_knock(sc))
		goto err;

	if (sc->elantech == NULL) {
		sc->elantech = elantech = malloc(sizeof(struct elantech_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (elantech == NULL) {
			printf("%s: elantech: not enough memory\n",
			    DEVNAME(sc));
			goto err;
		}

		if (elantech_get_hwinfo_v3(sc)) {
			free(sc->elantech, M_DEVBUF,
			    sizeof(struct elantech_softc));
			sc->elantech = NULL;
			goto err;
		}

		printf("%s: Elantech Touchpad, version %d, firmware 0x%x\n",
		    DEVNAME(sc), 3, sc->elantech->fw_version);
	} else if (elantech_set_absolute_mode_v3(sc))
		goto err;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_enable_elantech_v4(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;

	if (elantech_knock(sc))
		goto err;

	if (sc->elantech == NULL) {
		sc->elantech = elantech = malloc(sizeof(struct elantech_softc),
		    M_DEVBUF, M_WAITOK | M_ZERO);
		if (elantech == NULL) {
			printf("%s: elantech: not enough memory\n",
			    DEVNAME(sc));
			goto err;
		}

		if (elantech_get_hwinfo_v4(sc)) {
			free(sc->elantech, M_DEVBUF,
			    sizeof(struct elantech_softc));
			sc->elantech = NULL;
			goto err;
		}
		if (wsmouse_configure(sc->sc_wsmousedev,
		    elantech_v4_params, nitems(elantech_v4_params))) {
			free(sc->elantech, M_DEVBUF, 0);
			sc->elantech = NULL;
			printf("%s: setup failed\n", DEVNAME(sc));
			goto err;
		}
		wsmouse_set_mode(sc->sc_wsmousedev, WSMOUSE_COMPAT);

		printf("%s: Elantech Clickpad, version %d, firmware 0x%x\n",
		    DEVNAME(sc), 4, sc->elantech->fw_version);
	} else if (elantech_set_absolute_mode_v4(sc))
		goto err;

	return (1);

err:
	pms_reset(sc);

	return (0);
}

int
pms_ioctl_elantech(struct pms_softc *sc, u_long cmd, caddr_t data, int flag,
    struct proc *p)
{
	struct elantech_softc *elantech = sc->elantech;
	struct wsmouse_calibcoords *wsmc = (struct wsmouse_calibcoords *)data;
	struct wsmousehw *hw;
	int wsmode;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_ELANTECH;
		break;
	case WSMOUSEIO_GCALIBCOORDS:
		if (sc->protocol->type == PMS_ELANTECH_V4) {
			hw = wsmouse_get_hw(sc->sc_wsmousedev);
			wsmc->minx = hw->x_min;
			wsmc->maxx = hw->x_max;
			wsmc->miny = hw->y_min;
			wsmc->maxy = hw->y_max;
		} else {
			wsmc->minx = elantech->min_x;
			wsmc->maxx = elantech->max_x;
			wsmc->miny = elantech->min_y;
			wsmc->maxy = elantech->max_y;
		}
		wsmc->swapxy = 0;
		wsmc->resx = 0;
		wsmc->resy = 0;
		break;
	case WSMOUSEIO_SETMODE:
		wsmode = *(u_int *)data;
		if (wsmode != WSMOUSE_COMPAT && wsmode != WSMOUSE_NATIVE)
			return (EINVAL);
		elantech->wsmode = wsmode;
		if (sc->protocol->type == PMS_ELANTECH_V4)
			wsmouse_set_mode(sc->sc_wsmousedev, wsmode);
		break;
	default:
		return (-1);
	}
	return (0);
}

int
pms_sync_elantech_v1(struct pms_softc *sc, int data)
{
	struct elantech_softc *elantech = sc->elantech;
	u_char p;

	switch (sc->inputstate) {
	case 0:
		if (elantech->flags & ELANTECH_F_HW_V1_OLD) {
			elantech->p1 = (data & 0x20) >> 5;
			elantech->p2 = (data & 0x10) >> 4;
		} else {
			elantech->p1 = (data & 0x10) >> 4;
			elantech->p2 = (data & 0x20) >> 5;
		}
		elantech->p3 = (data & 0x04) >> 2;
		return (0);
	case 1:
		p = elantech->p1;
		break;
	case 2:
		p = elantech->p2;
		break;
	case 3:
		p = elantech->p3;
		break;
	default:
		return (-1);
	}

	if (data < 0 || data >= nitems(elantech->parity) ||
	    elantech->parity[data] != p)
		return (-1);

	return (0);
}

int
pms_sync_elantech_v2(struct pms_softc *sc, int data)
{
	struct elantech_softc *elantech = sc->elantech;

	/* Variants reporting pressure always have the same constant bits. */
	if (elantech->flags & ELANTECH_F_REPORTS_PRESSURE) {
		if (sc->inputstate == 0 && (data & 0x0c) != 0x04)
			return (-1);
		if (sc->inputstate == 3 && (data & 0x0f) != 0x02)
			return (-1);
		return (0);
	}

	/* For variants not reporting pressure, 1 and 3 finger touch packets
	 * have different constant bits than 2 finger touch packets. */
	switch (sc->inputstate) {
	case 0:
		if ((data & 0xc0) == 0x80) {
			if ((data & 0x0c) != 0x0c)
				return (-1);
			elantech->flags |= ELANTECH_F_2FINGER_PACKET;
		} else {
			if ((data & 0x3c) != 0x3c)
				return (-1);
			elantech->flags &= ~ELANTECH_F_2FINGER_PACKET;
		}
		break;
	case 1:
	case 4:
		if (elantech->flags & ELANTECH_F_2FINGER_PACKET)
			break;
		if ((data & 0xf0) != 0x00)
			return (-1);
		break;
	case 3:
		if (elantech->flags & ELANTECH_F_2FINGER_PACKET) {
			if ((data & 0x0e) != 0x08)
				return (-1);
		} else {
			if ((data & 0x3e) != 0x38)
				return (-1);
		}
		break;
	default:
		break;
	}

	return (0);
}

int
pms_sync_elantech_v3(struct pms_softc *sc, int data)
{
	struct elantech_softc *elantech = sc->elantech;

	switch (sc->inputstate) {
	case 0:
		if (elantech->flags & ELANTECH_F_CRC_ENABLED)
			break;
		if ((data & 0x0c) != 0x04 && (data & 0x0c) != 0x0c)
			return (-1);
		break;
	case 3:
		if (elantech->flags & ELANTECH_F_CRC_ENABLED) {
			if ((data & 0x09) != 0x08 && (data & 0x09) != 0x09)
				return (-1);
		} else {
			if ((data & 0xcf) != 0x02 && (data & 0xce) != 0x0c)
				return (-1);
		}
		break;
	}

	return (0);
}

int
pms_sync_elantech_v4(struct pms_softc *sc, int data)
{
	if (sc->inputstate == 0 && (data & 0x0c) != 0x04)
		return (-1);
	else
		return (0);
}

void
pms_proc_elantech_v1(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	int x, y, w, z;

	if (elantech->flags & ELANTECH_F_HW_V1_OLD)
		w = ((sc->packet[1] & 0x80) >> 7) +
		    ((sc->packet[1] & 0x30) >> 4);
	else
		w = (sc->packet[0] & 0xc0) >> 6;

	/* Hardware version 1 doesn't report pressure. */
	if (w) {
		x = ((sc->packet[1] & 0x0c) << 6) | sc->packet[2];
		y = ((sc->packet[1] & 0x03) << 8) | sc->packet[3];
		z = SYNAPTICS_PRESSURE;
	} else {
		x = elantech->old_x;
		y = elantech->old_y;
		z = 0;
	}

	elantech_send_input(sc, x, y, z, w);
}

void
pms_proc_elantech_v2(struct pms_softc *sc)
{
	const u_char debounce_pkt[] = { 0x84, 0xff, 0xff, 0x02, 0xff, 0xff };
	struct elantech_softc *elantech = sc->elantech;
	int x, y, w, z;

	/*
	 * The hardware sends this packet when in debounce state.
	 * The packet should be ignored.
	 */
	if (!memcmp(sc->packet, debounce_pkt, sizeof(debounce_pkt)))
		return;

	w = (sc->packet[0] & 0xc0) >> 6;
	if (w == 1 || w == 3) {
		x = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];
		y = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];
		if (elantech->flags & ELANTECH_F_REPORTS_PRESSURE)
			z = ((sc->packet[1] & 0xf0) |
			    (sc->packet[4] & 0xf0) >> 4);
		else
			z = SYNAPTICS_PRESSURE;
	} else if (w == 2) {
		x = (((sc->packet[0] & 0x10) << 4) | sc->packet[1]) << 2;
		y = (((sc->packet[0] & 0x20) << 3) | sc->packet[2]) << 2;
		z = SYNAPTICS_PRESSURE;
	} else {
		x = elantech->old_x;
		y = elantech->old_y;
		z = 0;
	}

	elantech_send_input(sc, x, y, z, w);
}

void
pms_proc_elantech_v3(struct pms_softc *sc)
{
	const u_char debounce_pkt[] = { 0xc4, 0xff, 0xff, 0x02, 0xff, 0xff };
	struct elantech_softc *elantech = sc->elantech;
	int x, y, w, z;

	x = ((sc->packet[1] & 0x0f) << 8 | sc->packet[2]);
	y = ((sc->packet[4] & 0x0f) << 8 | sc->packet[5]);
	z = 0;
	w = (sc->packet[0] & 0xc0) >> 6;
	if (w == 2) {
		/*
		 * Two-finger touch causes two packets -- a head packet
		 * and a tail packet. We report a single event and ignore
		 * the tail packet.
		 */
		if (elantech->flags & ELANTECH_F_CRC_ENABLED) {
			if ((sc->packet[3] & 0x09) != 0x08)
				return;
		} else {
			/* The hardware sends this packet when in debounce state.
	 		 * The packet should be ignored. */
			if (!memcmp(sc->packet, debounce_pkt, sizeof(debounce_pkt)))
				return;
			if ((sc->packet[0] & 0x0c) != 0x04 &&
	    		(sc->packet[3] & 0xcf) != 0x02) {
				/* not the head packet -- ignore */
				return;
			}
		}
	}

	/* Prevent juming cursor if pad isn't touched or reports garbage. */
	if (w == 0 ||
	    ((x == 0 || y == 0 || x == elantech->max_x || y == elantech->max_y)
	    && (x != elantech->old_x || y != elantech->old_y))) {
		x = elantech->old_x;
		y = elantech->old_y;
	}

	if (elantech->flags & ELANTECH_F_REPORTS_PRESSURE)
		z = (sc->packet[1] & 0xf0) | ((sc->packet[4] & 0xf0) >> 4);
	else if (w)
		z = SYNAPTICS_PRESSURE;

	elantech_send_input(sc, x, y, z, w);
}

void
pms_proc_elantech_v4(struct pms_softc *sc)
{
	struct elantech_softc *elantech = sc->elantech;
	struct device *sc_wsmousedev = sc->sc_wsmousedev;
	int id, weight, n, x, y, z;
	u_int buttons, slots;

	switch (sc->packet[3] & 0x1f) {
	case ELANTECH_V4_PKT_STATUS:
		slots = elantech->mt_slots;
		elantech->mt_slots = sc->packet[1] & 0x1f;
		slots &= ~elantech->mt_slots;
		for (id = 0; slots; id++, slots >>= 1) {
			if (slots & 1)
				wsmouse_mtstate(sc_wsmousedev, id, 0, 0, 0);
		}
		break;

	case ELANTECH_V4_PKT_HEAD:
		id = ((sc->packet[3] & 0xe0) >> 5) - 1;
		if (id > -1 && id < ELANTECH_MAX_FINGERS) {
			x = ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];
			y = ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];
			z = (sc->packet[1] & 0xf0)
			    | ((sc->packet[4] & 0xf0) >> 4);
			wsmouse_mtstate(sc_wsmousedev, id, x, y, z);
		}
		break;

	case ELANTECH_V4_PKT_MOTION:
		weight = (sc->packet[0] & 0x10) ? ELANTECH_V4_WEIGHT_VALUE : 1;
		for (n = 0; n < 6; n += 3) {
			id = ((sc->packet[n] & 0xe0) >> 5) - 1;
			if (id < 0 || id >= ELANTECH_MAX_FINGERS)
				continue;
			x = weight * (signed char)sc->packet[n + 1];
			y = weight * (signed char)sc->packet[n + 2];
			z = WSMOUSE_DEFAULT_PRESSURE;
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_X, x, id);
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_REL_Y, y, id);
			wsmouse_set(sc_wsmousedev, WSMOUSE_MT_PRESSURE, z, id);
		}

		break;

	default:
		printf("%s: unknown packet type 0x%x\n", DEVNAME(sc),
		    sc->packet[3] & 0x1f);
		return;
	}

	buttons = 0;
	if (sc->packet[0] & 0x01)
		buttons |= WSMOUSE_BUTTON(1);
	if (sc->packet[0] & 0x02)
		buttons |= WSMOUSE_BUTTON(3);
	wsmouse_buttons(sc_wsmousedev, buttons);

	wsmouse_input_sync(sc_wsmousedev);
}

void
elantech_send_input(struct pms_softc *sc, int x, int y, int z, int w)
{
	struct elantech_softc *elantech = sc->elantech;
	int dx, dy;
	u_int buttons = 0;

	if (sc->packet[0] & 0x01)
		buttons |= WSMOUSE_BUTTON(1);
	if (sc->packet[0] & 0x02)
		buttons |= WSMOUSE_BUTTON(3);

	if (elantech->flags & ELANTECH_F_HAS_ROCKER) {
		if (sc->packet[0] & 0x40) /* up */
			buttons |= WSMOUSE_BUTTON(4);
		if (sc->packet[0] & 0x80) /* down */
			buttons |= WSMOUSE_BUTTON(5);
	}

	if (elantech->wsmode == WSMOUSE_NATIVE) {
		WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons, x, y, z, w);
	} else {
		dx = dy = 0;

		if ((elantech->flags & ELANTECH_F_REPORTS_PRESSURE) &&
		    z > SYNAPTICS_PRESSURE) {
			dx = x - elantech->old_x;
			dy = y - elantech->old_y;
			dx /= SYNAPTICS_SCALE;
			dy /= SYNAPTICS_SCALE;
		}
		if (dx || dy || buttons != elantech->old_buttons)
			WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, 0, 0);
		elantech->old_buttons = buttons;
	}

	elantech->old_x = x;
	elantech->old_y = y;
}
@


1.74
log
@Use nitems() when passing all known parameters to wsmouse_configure().

ok bru@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.73 2017/02/27 16:40:10 bru Exp $ */
d239 4
d2049 2
a2050 1
		if (wsmouse_configure(sc->sc_wsmousedev, NULL, 0)) {
@


1.73
log
@pms/elantech-v4: configure wsmouse for handling compat-mode

ok @@matthieu @@stsp @@mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.72 2017/02/27 16:21:47 bru Exp $ */
a237 1
#define SYNAPTICS_NPARAMS 2
d1075 2
a1076 2
		if (wsmouse_configure(sc->sc_wsmousedev,
		    synaptics_params, SYNAPTICS_NPARAMS))
@


1.72
log
@pms/synaptics: configure wsmouse for handling compat-mode

ok @@matthieu @@stsp @@mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.71 2016/10/23 22:59:19 bru Exp $ */
a239 6
static const struct wsmouse_param elantech_v4_cfg[] = {
    { WSMOUSECFG_DX_SCALE, (4096 / SYNAPTICS_SCALE) },
    { WSMOUSECFG_DY_SCALE, (4096 / SYNAPTICS_SCALE) },
};
#define ELANTECH_V4_NPARAMS 2

d1838 1
d1864 3
a1866 2
	elantech->max_x = (resp[0] & 0x0f) << 8 | resp[1];
	elantech->max_y = (resp[0] & 0xf0) << 4 | resp[2];
d1868 1
a1868 1
	if ((capabilities[1] < 2) || (capabilities[1] > elantech->max_x))
d1871 5
a1875 1
	elantech->width = elantech->max_x / (capabilities[1] - 1);
a2023 12
pms_elantech_v4_configure(struct device *sc_wsmousedev,
    struct elantech_softc *elantech)
{
	if (wsmouse_mt_init(sc_wsmousedev, ELANTECH_MAX_FINGERS, 0)
	    || wsmouse_set_params(sc_wsmousedev, elantech_v4_cfg,
	    ELANTECH_V4_NPARAMS))
		return (-1);

	return (0);
}

int
d2046 1
a2046 3

		if (pms_elantech_v4_configure(
		    sc->sc_wsmousedev, sc->elantech)) {
d2073 1
d2081 12
a2092 4
		wsmc->minx = elantech->min_x;
		wsmc->maxx = elantech->max_x;
		wsmc->miny = elantech->min_y;
		wsmc->maxy = elantech->max_y;
@


1.71
log
@Improved parameter handling in wsmouse and new ioctls for reading and
setting parameter values.

ok matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.70 2016/05/22 22:06:11 bru Exp $ */
d98 1
a98 3
	int res_x, res_y;
	int min_x, min_y;
	int max_x, max_y;
d100 5
a104 7
	/* Compat mode */
	int wsmode;
	int old_x, old_y;
	u_int old_buttons;
	u_int sec_buttons;
#define SYNAPTICS_SCALE		4
#define SYNAPTICS_PRESSURE	30
d234 6
d918 3
d952 10
d963 2
a964 2
		syn->res_x = SYNAPTICS_RESOLUTION_X(syn->resolution);
		syn->res_y = SYNAPTICS_RESOLUTION_Y(syn->resolution);
d966 3
a968 3
	syn->min_x = SYNAPTICS_XMIN_BEZEL;
	syn->min_y = SYNAPTICS_YMIN_BEZEL;
	syn->max_x = (syn->dimension) ?
d970 1
a970 1
	syn->max_y = (syn->dimension) ?
d973 2
d1082 3
a1084 1
		syn->wsmode = WSMOUSE_COMPAT;
a1118 1
	struct synaptics_softc *syn = sc->synaptics;
d1120 1
d1123 2
d1127 1
a1127 6
		if ((syn->ext_capabilities & SYNAPTICS_EXT_CAP_CLICKPAD) &&
		    !(syn->ext2_capabilities & SYNAPTICS_EXT2_CAP_BUTTONS_STICK)
		    && mouse_has_softbtn)
			*(u_int *)data = WSMOUSE_TYPE_SYNAP_SBTN;
		else
			*(u_int *)data = WSMOUSE_TYPE_SYNAPTICS;
d1130 4
a1133 4
		wsmc->minx = syn->min_x;
		wsmc->maxx = syn->max_x;
		wsmc->miny = syn->min_y;
		wsmc->maxy = syn->max_y;
d1135 2
a1136 2
		wsmc->resx = syn->res_x;
		wsmc->resy = syn->res_y;
d1142 1
a1142 1
		syn->wsmode = wsmode;
d1174 1
a1174 1
	int x, y, z, w, dx, dy, width;
d1260 3
a1262 15
	/* ignore final events that happen when removing all fingers */
	if (x <= 1 || y <= 1) {
		x = syn->old_x;
		y = syn->old_y;
	}

	if (syn->wsmode == WSMOUSE_NATIVE) {
		if (z) {
			width = imax(w, 4);
			w = (w < 2 ? w + 2 : 1);
		} else {
			width = w = 0;
		}
		wsmouse_set(sc->sc_wsmousedev, WSMOUSE_TOUCH_WIDTH, width, 0);
		WSMOUSE_TOUCH(sc->sc_wsmousedev, buttons, x, y, z, w);
d1264 2
a1265 10
		dx = dy = 0;
		if (z > SYNAPTICS_PRESSURE) {
			dx = x - syn->old_x;
			dy = y - syn->old_y;
			dx /= SYNAPTICS_SCALE;
			dy /= SYNAPTICS_SCALE;
		}
		if (dx || dy || buttons != syn->old_buttons)
			WSMOUSE_INPUT(sc->sc_wsmousedev, buttons, dx, dy, 0, 0);
		syn->old_buttons = buttons;
d1267 2
a1268 3

	syn->old_x = x;
	syn->old_y = y;
@


1.70
log
@Use the new input functions of wsmouse in mouse and touchscreen drivers.

ok kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.69 2016/03/30 23:34:12 bru Exp $ */
d238 6
a324 2
void	elantech_send_mt_input(struct pms_softc *, int);

d2032 3
a2034 1
	if (wsmouse_mt_init(sc_wsmousedev, ELANTECH_MAX_FINGERS, 0))
a2036 2
	wsmouse_set_param(sc_wsmousedev, WSMPARAM_DX_DIV, SYNAPTICS_SCALE);
	wsmouse_set_param(sc_wsmousedev, WSMPARAM_DY_DIV, SYNAPTICS_SCALE);
@


1.69
log
@Add support for multitouch input to wsmouse.

This change adds new input-processing functions to wsmouse and
adapts the touchpad drivers.

ok mpi@@, shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.68 2016/02/27 22:01:58 mmcc Exp $ */
d635 1
a635 2
	wsmouse_input(sc->sc_wsmousedev,
	    buttons, dx, dy, dz, 0, WSMOUSE_INPUT_DELTA);
@


1.68
log
@pakets -> packets
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.67 2015/09/05 14:02:21 bru Exp $ */
d146 2
a147 11
	struct {
		unsigned int x;
		unsigned int y;
		unsigned int z;
	} mt[ELANTECH_MAX_FINGERS];
	int mt_slots;
	int mt_count;
	int mt_filter;
	int mt_lastid;
	int mt_lastcount;
	int mt_buttons;
d991 1
a991 2
	wsmouse_input(sc->sc_sec_wsmousedev,
	    buttons, dx, dy, 0, 0, WSMOUSE_INPUT_DELTA);
d1155 1
a1155 1
	int x, y, z, w, dx, dy;
d1223 3
a1225 2
			wsmouse_input(sc->sc_sec_wsmousedev,
			    syn->sec_buttons, 0, 0, 0, 0, WSMOUSE_INPUT_DELTA);
d1248 8
a1255 3
		wsmouse_input(sc->sc_wsmousedev, buttons, x, y, z, w,
		    WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W);
d1265 1
a1265 2
			wsmouse_input(sc->sc_wsmousedev, buttons, dx, dy, 0, 0,
			    WSMOUSE_INPUT_DELTA);
d1311 1
a1311 2
	wsmouse_input(sc->sc_sec_wsmousedev, alps->sec_buttons,
	    dx, dy, 0, 0, WSMOUSE_INPUT_DELTA);
d1511 1
a1511 1
	int x, y, z, w, dx, dy;
d1529 1
a1529 2
		wsmouse_input(sc->sc_sec_wsmousedev, buttons, dx, dy, 0, 0,
		    WSMOUSE_INPUT_DELTA);
d1548 2
a1549 6
			wsmouse_input(sc->sc_wsmousedev, buttons,
			    alps->old_x, alps->old_y, ALPS_PRESSURE, 4,
			    WSMOUSE_INPUT_ABSOLUTE_X
			    | WSMOUSE_INPUT_ABSOLUTE_Y
			    | WSMOUSE_INPUT_ABSOLUTE_Z
			    | WSMOUSE_INPUT_ABSOLUTE_W);
d1555 2
a1556 6
				wsmouse_input(sc->sc_wsmousedev, buttons,
				    alps->old_x, alps->old_y, 0, 0,
				    WSMOUSE_INPUT_ABSOLUTE_X
				    | WSMOUSE_INPUT_ABSOLUTE_Y
				    | WSMOUSE_INPUT_ABSOLUTE_Z
				    | WSMOUSE_INPUT_ABSOLUTE_W);
d1561 2
a1562 8
		if (gesture != ALPS_TAP) {
			w = z ? 4 : 0;
			wsmouse_input(sc->sc_wsmousedev, buttons, x, y, z, w,
			    WSMOUSE_INPUT_ABSOLUTE_X
			    | WSMOUSE_INPUT_ABSOLUTE_Y
			    | WSMOUSE_INPUT_ABSOLUTE_Z
			    | WSMOUSE_INPUT_ABSOLUTE_W);
		}
d1582 1
a1582 2
			wsmouse_input(sc->sc_wsmousedev, buttons, dx, dy, 0, 0,
			    WSMOUSE_INPUT_DELTA);
d2026 12
d2061 9
d2109 2
d2356 3
a2358 1
	int n, id, slots, weight, dx, dy;
d2362 7
a2368 14
		if (elantech->mt_slots == 0)
			elantech->mt_lastid = -1;
		slots = sc->packet[1] & 0x1f;
		if (slots == 0 && elantech->mt_lastid > -1)
			/* Notify that we lifted. */
			elantech_send_input(sc,
			    elantech->mt[elantech->mt_lastid].x,
			    elantech->mt[elantech->mt_lastid].y, 0, 0);

		elantech->mt_filter = elantech->mt_slots = slots;

		for (elantech->mt_count = 0; slots != 0; slots >>= 1)
			elantech->mt_count += (1 & slots);

d2374 3
a2376 6
			elantech->mt[id].x =
			    ((sc->packet[1] & 0x0f) << 8) | sc->packet[2];
			elantech->mt[id].y =
			    ((sc->packet[4] & 0x0f) << 8) | sc->packet[5];
			elantech->mt[id].z =
			    (sc->packet[1] & 0xf0)
d2378 1
a2378 5

			if (elantech->mt_filter & (1 << id)) {
				elantech_send_mt_input(sc, id);
				elantech->mt_filter = (1 << id);
			}
d2388 6
a2393 16
			dx = weight * (signed char)sc->packet[n + 1];
			dy = weight * (signed char)sc->packet[n + 2];
			elantech->mt[id].x += dx;
			elantech->mt[id].y += dy;
			elantech->mt[id].z = 1;
			if (elantech->mt_filter & (1 << id)) {
				if ((dx | dy)
				    || elantech->mt_count !=
				    elantech->mt_lastcount
				    || (sc->packet[0] & 3) !=
				    elantech->mt_buttons)
					elantech_send_mt_input(sc, id);

				elantech->mt_filter = (dx | dy) ?
				    (1 << id) : elantech->mt_slots;
			}
a2402 1
}
d2404 6
a2409 4
void
elantech_send_mt_input(struct pms_softc *sc, int id)
{
	struct elantech_softc *elantech = sc->elantech;
d2411 1
a2411 24
	if (id != elantech->mt_lastid) {
		/* Correct for compatibility mode, but not useful yet: */
		elantech->old_x = elantech->mt[id].x;
		elantech->old_y = elantech->mt[id].y;
		/*
		 * To avoid a jump of the cursor, simulate a change of the
		 * number of touches (without producing tapping gestures
		 * accidentally). It should suffice to do that only if
		 * mt_count hasn't changed, but we cannot rely on the
		 * synaptics driver, which alters its finger counts when
		 * handling click-and-drag actions (see HandleTapProcessing
		 * and ComputeDeltas in synaptics.c).
		 */
		if (elantech->mt_lastid > -1)
			elantech_send_input(sc,
			    elantech->mt[id].x, elantech->mt[id].y,
			    elantech->mt[id].z, ELANTECH_MAX_FINGERS);
		elantech->mt_lastid = id;
	}
	elantech->mt_lastcount = elantech->mt_count;
	elantech->mt_buttons = sc->packet[0] & 3;
	elantech_send_input(sc,
	    elantech->mt[id].x, elantech->mt[id].y,
	    elantech->mt[id].z, elantech->mt_count);
d2434 1
a2434 5
		wsmouse_input(sc->sc_wsmousedev, buttons, x, y, z, w,
		    WSMOUSE_INPUT_ABSOLUTE_X |
		    WSMOUSE_INPUT_ABSOLUTE_Y |
		    WSMOUSE_INPUT_ABSOLUTE_Z |
		    WSMOUSE_INPUT_ABSOLUTE_W);
d2446 1
a2446 2
			wsmouse_input(sc->sc_wsmousedev, buttons, dx, dy, 0, 0,
			    WSMOUSE_INPUT_DELTA);
@


1.67
log
@Support Synaptics touchpads without W mode.

Emulate W mode if a Synaptics model doesn't provide it, and check
for the success of the resolution query during setup.

ok shadchin@@, mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.66 2015/09/05 13:52:54 bru Exp $ */
d2169 1
a2169 1
	 * have different constant bits than 2 finger touch pakets. */
@


1.66
log
@Improve tap-and-drag detection for ALPS touchpads.

The ALPS mechanism for gesture detection can produce long delays between
a packet that signals a tap and the next packet, which either signals
the end of the gesture or the start of a drag-operation. The time spans
can exceed the timeouts used by the generic detection mechanism in the
synaptics driver. Reporting both the touch and the release event when
the second packet has arrived ensures that the tap will be recognized.

ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.65 2015/08/23 04:45:23 deraadt Exp $ */
d953 4
a956 2
	syn->res_x = SYNAPTICS_RESOLUTION_X(syn->resolution);
	syn->res_y = SYNAPTICS_RESOLUTION_Y(syn->resolution);
d1169 1
d1171 10
a1180 21
	/*
	 * Conform to the encoding understood by
	 * /usr/xenocara/driver/xf86-input-synaptics/src/wsconscomm.c
	 */
	switch (w) {
	case 0:
		/* fingerwidth 5, numfingers 2 */
		break;
	case 1:
		/* fingerwidth 5, numfingers 3 */
		break;
	case 5:
		/* fingerwidth 5, numfingers 1 */
		break;
	case 4:
	case 8:
		/* fingerwidth 4, numfingers 1 */
		w = 4;
		break;
	default:
		break;
d1183 1
a1199 1
	z = sc->packet[2];
@


1.65
log
@fairly trivial sizes for free()
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.64 2015/07/20 00:55:06 kspillner Exp $ */
d123 2
a124 1
	int old_fin;
d1526 1
a1526 2
	u_int buttons;
	int fin, ges;
d1561 31
a1591 2
		ges = sc->packet[2] & 0x01;
		fin = sc->packet[2] & 0x02;
d1593 2
a1594 13
		/* Simulate click (tap) */
		if (ges && !fin)
			z = 35;

		/* Generate a null pressure event (needed for tap & drag) */
		if (ges && fin && !alps->old_fin)
			z = 0;

		/* Generate a width value corresponding to one finger */
		if (z > 0)
			w = 4;
		else
			w = 0;
d1596 2
a1597 3
		wsmouse_input(sc->sc_wsmousedev, buttons, x, y, z, w,
		    WSMOUSE_INPUT_ABSOLUTE_X | WSMOUSE_INPUT_ABSOLUTE_Y |
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W);
a1598 1
		alps->old_fin = fin;
@


1.64
log
@Tweak previous; the Synaptics TrackPoint in my ThinkPad T500 works again.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.63 2015/07/19 15:43:44 krw Exp $ */
d1055 2
a1056 1
			free(sc->synaptics, M_DEVBUF, 0);
d1384 1
a1384 1
			free(sc->alps, M_DEVBUF, 0);
d1943 2
a1944 1
			free(sc->elantech, M_DEVBUF, 0);
d1983 2
a1984 1
			free(sc->elantech, M_DEVBUF, 0);
d2020 2
a2021 1
			free(sc->elantech, M_DEVBUF, 0);
d2057 2
a2058 1
			free(sc->elantech, M_DEVBUF, 0);
@


1.63
log
@Don't emit values for 'width' that

 /usr/xenocara/driver/xf86-input-synaptics/src/wsconscomm.c

doesn't understand.

'Fixes' synaptics trackpad in Dell L400 laptop so the cursor can
be moved in X. Problem noted and experimental Dell L400 donated by
Paolo Aglialoro. Thanks!

ok miod@@ mpi@@ jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.62 2015/06/08 06:39:22 stsp Exp $ */
d1180 2
a1181 1
	default:
d1184 2
@


1.62
log
@pms(4): Don't match Elantech v4 devices with firmware versions 0xX7XXXX.
Apparently we don't support these touchpads properly so leave them in
PS/2 compat mode. Regression reported by Remi Locherer on bugs@@. And stop
matching devices with firmware versions higher than 0xX8XXXX since we cannot
be sure they work.
ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.61 2015/05/25 15:04:26 mpi Exp $ */
d1165 20
@


1.61
log
@Match newer elantech v4 touchpads, logic taken from Linux.

Based on a submission from and ok jcs@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.60 2015/05/04 09:33:46 mpi Exp $ */
d1843 2
a1844 1
	if (((fw_version & 0x0f0000) >> 16) < 6)
@


1.60
log
@Print irq informations in pckbc_set_inputhandler().

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.59 2015/04/10 08:48:08 stsp Exp $ */
d1843 1
a1843 1
	if (((fw_version & 0x0f0000) >> 16) != 6)
@


1.59
log
@Add support for CRC-enabled elantech v3 touchpads.
Patch by Fasse <fasse.f2@@gmail.com>
ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.58 2015/03/26 01:30:22 jsg Exp $ */
a682 2
	printf("\n");

d685 2
@


1.58
log
@Use the 0x10 extended capability to determine if the trackstick
buttons are wired to the trackpad and need to be re-routed to the
trackstick.  Without this change the buttons on 2015 thinkpads
get picked up as extended buttons that show up as scroll up/down.

Remove the X1 Carbon 2015 (LEN0048) and X250 (LEN0046) from the
top button area/soft buttons quirks list.  Also avoid using the
quirk list entirely if the capability bit is set.

Based on work from jcs@@ with feedback from mpi@@
ok mpi@@ jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.57 2015/02/09 04:05:25 mpi Exp $ */
d140 1
d1816 3
d2171 2
d2175 2
d2181 7
a2187 2
		if ((data & 0xcf) != 0x02 && (data & 0xce) != 0x0c)
			return (-1);
a2271 5
	/* The hardware sends this packet when in debounce state.
	 * The packet should be ignored. */
	if (!memcmp(sc->packet, debounce_pkt, sizeof(debounce_pkt)))
		return;

d2282 13
a2294 4
		if ((sc->packet[0] & 0x0c) != 0x04 &&
		    (sc->packet[3] & 0xcf) != 0x02) {
			/* not the head packet -- ignore */
			return;
@


1.57
log
@Complete rewrite of the Elantech clickpads v4 packet parser in order to
support "click-and-drag".

This implements a simple filter to keep track of a moving finger on the
clickpad.  For the moment wsmouse(4) and wscons(4) are still unaware of
multitouch events and pms(4) has to do the translation, but this is a
small steps in this direction.

All the good work has been done by Ulf Brosziewski.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.56 2015/01/15 01:19:28 jsg Exp $ */
d85 1
a85 1
	int capabilities, ext_capabilities;
d88 1
d106 1
d942 8
d960 2
d982 1
d990 1
d1109 2
a1110 1
		    mouse_has_softbtn)
d1203 17
@


1.56
log
@Define a new wscons mouse type for Synaptics clickpad devices that lack
physical buttons.  This will be used if the acpi pnpid for the mouse
matches a list provided by Synaptics found in Linux.

Combined with the xenocara changes this will remove the need for an xorg
config file for the x240/t440/t540 generation of thinkpads.

ok matthieu@@ shadchin@@ kettenis@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.55 2015/01/07 10:32:13 mpi Exp $ */
d145 1
d147 7
a153 1
	int fingers[ELANTECH_MAX_FINGERS];
d324 1
d2269 1
a2269 2
	int z, delta_x1 = 0, delta_x2 = 0, delta_y1 = 0, delta_y2 = 0;
	int i, weight, finger, fingers = 0, id, sid;
d2273 10
a2282 7
		fingers = sc->packet[1] & 0x1f;
		for (i = 0; i < ELANTECH_MAX_FINGERS; i++) {
			finger = ((fingers & (1 << i)) != 0);
			if (elantech->fingers[i] && !finger)
				/* notify that we lifted */
				elantech_send_input(sc, elantech->mt[i].x,
				    elantech->mt[i].y, 0, 0);
d2284 2
a2285 2
			elantech->fingers[i] = finger;
		}
d2291 14
a2304 16
		if (id < 0)
			return;

		for (i = 0; i < ELANTECH_MAX_FINGERS; i++)
			if (elantech->fingers[i])
				fingers++;

		elantech->mt[id].x = ((sc->packet[1] & 0x0f) << 8) |
		    sc->packet[2];
		elantech->mt[id].y = (((sc->packet[4] & 0x0f) << 8) |
		    sc->packet[5]);
		z = (sc->packet[1] & 0xf0) | ((sc->packet[4] & 0xf0) >> 4);

		elantech_send_input(sc, elantech->mt[id].x, elantech->mt[id].y,
		    z, fingers);

a2307 5
		id = ((sc->packet[0] & 0xe0) >> 5) - 1;
		if (id < 0)
			return;

		sid = ((sc->packet[3] & 0xe0) >> 5) - 1;
d2309 20
a2328 24

		delta_x1 = (signed char)sc->packet[1];
		delta_y1 = (signed char)sc->packet[2];
		delta_x2 = (signed char)sc->packet[4];
		delta_y2 = (signed char)sc->packet[5];

		elantech->mt[id].x += delta_x1 * weight;
		elantech->mt[id].y -= delta_y1 * weight;

		for (i = 0; i < ELANTECH_MAX_FINGERS; i++)
			if (elantech->fingers[i])
				fingers++;

		elantech_send_input(sc, elantech->mt[id].x, elantech->mt[id].y,
		    1, fingers);

		if (sid >= 0) {
			elantech->mt[sid].x += delta_x2 * weight;
			elantech->mt[sid].y -= delta_y2 * weight;
			/* XXX: can only send one finger of input */
			/*
			elantech_send_input(sc, elantech->mt[sid].x,
			    elantech->mt[sid].y, 1, fingers);
			*/
d2338 31
@


1.55
log
@Only MS IntelliMouse have a Z axis, prevent a false positive triggered
by -Wuninitialized reported by jsg@@.

ok stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.54 2014/08/29 20:09:09 shadchin Exp $ */
d43 10
d1086 5
a1090 1
		*(u_int *)data = WSMOUSE_TYPE_SYNAPTICS;
@


1.54
log
@Fix checking sync for old synaptics touchpad (ver 5.9)
From Thierry Deval <thierry at deval dot be>

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.53 2014/08/19 12:24:04 mpi Exp $ */
d617 3
a619 2
	switch (sc->protocol->type) {
	case PMS_STANDARD:
a620 5
		break;
	case PMS_INTELLI:
		dz = (signed char)sc->packet[3];
		break;
	}
@


1.53
log
@Make sure state changes are properly serialized.

When pms(4) is attached to a touchpad it generally presents two different
wsmouse(4) devices: one for the touchpad itself and one for the clitpad
and/or some interleaved packets.  But since both devices are writing to
the same pckbc slot, a race can occur if they try to change the state at
the same time.

So prevent two process opening the two /dev/wsmouse* node at the same time
to corrupt the magic sequences needed to enable/disable the touchpad.

ok schadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.52 2014/07/12 18:48:52 tedu Exp $ */
d81 6
d944 6
d998 1
a998 1
		/* 
d1106 2
d1110 1
a1110 1
		if ((data & 0xc8) != 0x80)
d1114 1
a1114 1
		if ((data & 0xc8) != 0xc0)
@


1.52
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.51 2014/05/18 15:27:28 stsp Exp $ */
d29 1
d152 2
d668 2
d770 1
d772 5
a776 1
	return pms_change_state(sc, PMS_STATE_ENABLED, PMS_DEV_PRIMARY);
d784 1
d786 1
d804 5
d810 1
a810 1
	return (pms_change_state(sc, PMS_STATE_ENABLED, PMS_DEV_SECONDARY));
d818 1
d820 1
@


1.51
log
@Fix tail packet check in elantech v3 touchpad code. Due to a typo this
code was masking out bits which were also tested in the same expression.
Reported by cppcheck via jsg@@ (Expression '(X & 0xfc) != 0x2' is always true).
Tested with Elantech Touchpad, version 3, firmware 0x250f00.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.50 2014/04/25 10:33:36 mpi Exp $ */
d995 1
a995 1
			free(sc->synaptics, M_DEVBUF);
d1276 1
a1276 1
			free(sc->alps, M_DEVBUF);
d1831 1
a1831 1
			free(sc->elantech, M_DEVBUF);
d1870 1
a1870 1
			free(sc->elantech, M_DEVBUF);
d1906 1
a1906 1
			free(sc->elantech, M_DEVBUF);
d1942 1
a1942 1
			free(sc->elantech, M_DEVBUF);
@


1.50
log
@Do no reprobe for a supported protocol when enabling a pointing
device of type PMS_STANDARD, probing during autoconf(9) is enough!.

In such case, the device can be a simple PS/2 mouse, a unsupported
touchpad or a downgraded touchpad if something bad happened.  But
it is very unlikely that reprobing will improve the situation and
transform a standard mouse into a multitouch-aware touchpad ;)

This fixes the 12 seconds delay seen on various Dell laptops (E4310
and Latitude D630) when starting Xorg, reported by Kārlis Miķelsons
on bugs@@.

ok stsp@@, dcoppa@@, shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.49 2013/10/30 18:00:56 shadchin Exp $ */
d2192 1
a2192 1
		    (sc->packet[3] & 0xfc) != 0x02) {
@


1.49
log
@Fix jagged diagonal lines (kernel part)

Send WSCONS_EVENT_SYNC every time you call wsmouse_input(). Used to synchronize
and separate events into packets of input data changes occurring at the same
moment in time. For example, motion of a mouse may set the DELTA_X and DELTA_Y
values for one motion, then emit a SYNC.

ok matthieu@@. tested edd@@, Henri Kemppainen and Alf Schlichting.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.48 2013/09/20 14:07:30 stsp Exp $ */
d738 1
a738 1
		if (sc->protocol->type == PMS_STANDARD ||
@


1.48
log
@Use a working magic sequence to configure absolute mode for elantech v2.
The synaptics driver now attaches to elantech v2 touchpads. It seems these
pads were always falling back to compat mode, which went unnoticed until r1.47.

Fix based on a patch submitted by Cedric Tessier:
http://marc.info/?l=openbsd-bugs&m=136904396518528&w=2
which in turn was probably based on parts of this patch:
https://launchpadlibrarian.net/73099683/elantech.patch
which updates the Linux driver code but isn't part of Torvald's Linux.

Behaviour of elantech firmware versions seems to vary quite a bit so print
the firmware version at attach time for reference in future bug reports.

Fix tested by frantisek holop and Peter J. Philipp.
ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.47 2013/09/03 09:29:35 stsp Exp $ */
d1158 1
a1158 2
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W |
		    WSMOUSE_INPUT_SYNC);
d1472 1
a1472 2
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W |
		    WSMOUSE_INPUT_SYNC);
d2322 1
a2322 2
		    WSMOUSE_INPUT_ABSOLUTE_W |
		    WSMOUSE_INPUT_SYNC);
@


1.47
log
@When /dev/wsmouse is opened right after resume, some synaptics touchpads
are still taking time to wake up. So make the pms(4) driver wait a little
longer before giving up on them. Fixes mouse after resume on my x130e TP.
ok mpi, earlier versions tested by weerd with no regressions seen
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.46 2013/09/03 07:37:58 mpi Exp $ */
d121 1
d1537 1
d1545 1
a1545 1
	    elantech_ps2_cmd(sc, 0x54) ||
a1552 7
	    pms_set_scaling(sc, 1) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, ELANTECH_CMD_WRITE_REG) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x21) ||
	    elantech_ps2_cmd(sc, ELANTECH_PS2_CUSTOM_COMMAND) ||
	    elantech_ps2_cmd(sc, 0x88) ||
d1640 2
d1676 1
d1731 1
d1761 1
d1838 2
a1839 1
		printf("%s: Elantech Touchpad, version %d\n", DEVNAME(sc), 1);
d1877 2
a1878 1
		printf("%s: Elantech Touchpad, version %d\n", DEVNAME(sc), 2);
d1913 2
a1914 1
		printf("%s: Elantech Touchpad, version %d\n", DEVNAME(sc), 3);
d1949 2
a1950 1
		printf("%s: Elantech Clickpad, version %d\n", DEVNAME(sc), 4);
@


1.46
log
@Only free the per-protocol descriptor if a touchpad cannot be correctly
identified during attach.  This prevents the driver to downgrade itself
to use the standard mouse protocol and reattach a new wsmouse child if
something bad happens when we re-query the hardware (during resume for
example).

Discussed with and ok stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.45 2013/07/16 08:11:39 mpi Exp $ */
d276 1
d941 1
a941 1
pms_enable_synaptics(struct pms_softc *sc)
a942 2
	struct synaptics_softc *syn = sc->synaptics;
	struct wsmousedev_attach_args a;
a943 1
	int mode;
d951 32
a982 1
		goto err;
@


1.45
log
@Correctly initialized the width value to 0 instead of passing garbage
to wsmouse_input() when no finger are reported.

Pointed out by Maxime Villard.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.44 2013/06/28 18:32:01 jcs Exp $ */
d912 5
d964 3
a966 6
		if (synaptics_get_hwinfo(sc))
			goto err;

		if ((syn->model & SYNAPTICS_MODEL_NEWABS) == 0) {
			printf("%s: don't support Synaptics OLDABS\n",
			    DEVNAME(sc));
a1003 5
	if (sc->synaptics) {
		free(sc->synaptics, M_DEVBUF);
		sc->synaptics = NULL;
	}

d1246 3
a1248 1
		if (alps_get_hwinfo(sc))
d1250 1
a1312 5
	if (sc->alps) {
		free(sc->alps, M_DEVBUF);
		sc->alps = NULL;
	}

d1803 3
a1805 1
		if (elantech_get_hwinfo_v1(sc))
d1807 1
a1818 5
	if (sc->elantech) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
	}

d1841 3
a1843 1
		if (elantech_get_hwinfo_v2(sc))
d1845 1
a1853 5
	if (sc->elantech) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
	}

d1876 3
a1878 1
		if (elantech_get_hwinfo_v3(sc))
d1880 1
a1888 5
	if (sc->elantech) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
	}

d1911 3
a1913 1
		if (elantech_get_hwinfo_v4(sc))
d1915 1
a1923 5
	if (sc->elantech) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
	}

@


1.44
log
@send proper z value to elantech_send_input in previous v4 commit

pointed out by Owain G. Ainsworth
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.43 2013/05/31 19:21:09 jcs Exp $ */
d1443 2
@


1.43
log
@add elantech v4 (clickpad) support
tested on an asus ux21a

ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.42 2013/05/23 18:29:51 tobias Exp $ */
d2198 1
a2198 1
	int w, z, delta_x1 = 0, delta_x2 = 0, delta_y1 = 0, delta_y2 = 0;
d2257 1
a2257 1
		    z, fingers);
d2260 2
a2261 2
			elantech->mt[sid].x += delta_x2 * w;
			elantech->mt[sid].y -= delta_y2 * w;
d2265 1
a2265 1
			    elantech->mt[sid].y, z, w);
@


1.42
log
@Revert Active PS/2 support for now, until we find a solution suitable
for chipsets which stopped working.

ok mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.40 2013/04/15 09:14:41 mpi Exp $ */
d63 1
d124 6
d264 1
d270 1
d274 1
d289 1
d294 1
d373 9
d828 2
a829 1
		printf("%s: not in sync yet, discard input\n", DEVNAME(sc));
d1584 20
d1723 38
d1904 37
d2078 9
d2192 84
@


1.41
log
@Enable active PS/2 multiplexing if available.
Supported for i386 and amd64 except SMALL_KERNEL.

Based on Miod's former work on this subject.

ok mpi
@
text
@a136 1
	int sc_slot;
d376 1
a376 1
		return pckbc_poll_cmd(sc->sc_kbctag, sc->sc_slot,
d379 1
a379 1
		return pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_slot,
d605 1
a605 1
	if (pa->pa_slot < PCKBC_AUX_SLOT)
a632 1
	sc->sc_slot = pa->pa_slot;
d636 1
a636 1
	pckbc_set_inputhandler(sc->sc_kbctag, sc->sc_slot,
d709 1
a709 1
		pckbc_slot_enable(sc->sc_kbctag, sc->sc_slot, 1);
d712 1
a712 1
			pckbc_flush(sc->sc_kbctag, sc->sc_slot);
d728 1
a728 1
		pckbc_slot_enable(sc->sc_kbctag, sc->sc_slot, 0);
@


1.40
log
@Revert r1.37 now that we stop after the first matching protocol, tested
by Peter J. Philipp, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.39 2013/04/15 09:12:42 mpi Exp $ */
d137 1
d377 1
a377 1
		return pckbc_poll_cmd(sc->sc_kbctag, PCKBC_AUX_SLOT,
d380 1
a380 1
		return pckbc_enqueue_cmd(sc->sc_kbctag, PCKBC_AUX_SLOT,
d606 1
a606 1
	if (pa->pa_slot != PCKBC_AUX_SLOT)
d634 1
d638 1
a638 1
	pckbc_set_inputhandler(sc->sc_kbctag, PCKBC_AUX_SLOT,
d711 1
a711 1
		pckbc_slot_enable(sc->sc_kbctag, PCKBC_AUX_SLOT, 1);
d714 1
a714 1
			pckbc_flush(sc->sc_kbctag, PCKBC_AUX_SLOT);
d730 1
a730 1
		pckbc_slot_enable(sc->sc_kbctag, PCKBC_AUX_SLOT, 0);
@


1.39
log
@Move the IntelliMouse protocol definition after Elantech ones, because some
touchpads support both of them and we want to pick the latter.

Reported by Peter J. Philipp, thanks.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.38 2013/04/15 09:09:50 mpi Exp $ */
a120 1
	int hw_version;
a1713 4
	/* Check if a different hardware version has been detected. */
	if (elantech && elantech->hw_version != 0 && elantech->hw_version != 1)
		return (0);

a1735 2
	elantech->hw_version = 1;

a1753 4
	/* Check if a different hardware version has been detected. */
	if (elantech && elantech->hw_version != 0 && elantech->hw_version != 2)
		return (0);

a1772 2
	elantech->hw_version = 2;

a1790 4
	/* Check if a different hardware version has been detected. */
	if (elantech && elantech->hw_version != 0 && elantech->hw_version != 3)
		return (0);
		
a1808 2

	elantech->hw_version = 3;
@


1.38
log
@Don't probe for all supported protocols this can confuse some touchpads and
makes it harder to pick the right protocol if a device answers to more than
one magic sequence.

Tested by many on tech@@, ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.37 2013/03/18 16:31:01 stsp Exp $ */
a316 9
	/* Microsoft IntelliMouse */
	{
		PMS_INTELLI, 4,
		pms_enable_intelli,
		pms_ioctl_mouse,
		pms_sync_mouse,
		pms_proc_mouse,
		NULL
	},
d360 9
@


1.37
log
@Once we've detected an elantech touchpad, stop probing for other hardware
versions. Fixes a problem reported by Peter J. Philipp where the pms driver
spits out "not in sync yet" messages after attaching to elantech v2 hardware.
Fix tested by me on v3 hardware, and by Peter on v2 hardware.
ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.36 2013/03/16 11:14:47 stsp Exp $ */
d236 1
d494 17
a631 1
	int i;
d654 2
a655 8
	sc->protocol = &pms_protocols[0];
	for (i = 1; i < nitems(pms_protocols); i++) {
		pms_reset(sc);
		if (pms_protocols[i].enable(sc))
			sc->protocol = &pms_protocols[i];
	}

	DPRINTF("%s: protocol type %d\n", DEVNAME(sc), sc->protocol->type);
a683 2
	int i;

d716 1
a716 2

		if (sc->protocol->type != PMS_STANDARD &&
d718 1
a718 12
			sc->protocol = &pms_protocols[0];

		if (sc->protocol->type == PMS_STANDARD)
			for (i = 1; i < nitems(pms_protocols); i++) {
				pms_reset(sc);
				if (pms_protocols[i].enable(sc))
					sc->protocol = &pms_protocols[i];
			}

#ifdef DEBUG
		printf("%s: protocol type %d\n", DEVNAME(sc), sc->protocol->type);
#endif
d726 1
a726 1
		if (sc->protocol && sc->protocol->disable)
d760 1
a760 1
	if (sc->protocol && sc->protocol->ioctl)
@


1.36
log
@Enable untested Elantech touchpad v1 and v2 code. I'd like some test reports.
ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.35 2012/11/05 19:08:29 shadchin Exp $ */
d121 1
d1718 4
d1744 2
d1764 4
d1787 2
d1807 4
d1829 2
@


1.35
log
@Fix memory leak in error paths for synaptics and alps (pointed stsp@@).
Also small simplify elantech part.

ok stsp@@, mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.34 2012/11/03 13:43:57 stsp Exp $ */
a341 1
#ifdef notyet
a359 1
#endif
@


1.34
log
@Handle elantech touchpad buttons in a common code path for all
hardware variants. ok shadchin mikeb mpi
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.33 2012/11/02 12:07:57 stsp Exp $ */
d931 1
a931 1
		return (0);
d939 1
a939 1
			return (0);
d943 1
a943 1
			return (0);
d948 1
a948 1
			return (0);
d974 1
a974 1
		return (0);
d980 1
a980 1
		return (0);
d983 10
d1222 1
a1222 1
		return (0);
d1296 5
d1720 1
a1720 1
		return (0);
d1731 1
a1731 3
		if (elantech_get_hwinfo_v1(sc)) {
			free(sc->elantech, M_DEVBUF);
			sc->elantech = NULL;
a1732 1
		}
d1735 1
a1735 3
	} else if (elantech_set_absolute_mode_v1(sc)) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
a1736 1
	}
d1744 5
d1760 1
a1760 1
		return (0);
d1771 1
a1771 3
		if (elantech_get_hwinfo_v2(sc)) {
			free(sc->elantech, M_DEVBUF);
			sc->elantech = NULL;
a1772 1
		}
d1775 1
a1775 3
	} else if (elantech_set_absolute_mode_v2(sc)) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
a1776 1
	}
d1781 5
d1797 1
a1797 1
		return (0);
d1808 1
a1808 3
		if (elantech_get_hwinfo_v3(sc)) {
			free(sc->elantech, M_DEVBUF);
			sc->elantech = NULL;
a1809 1
		}
d1812 1
a1812 3
	} else if (elantech_set_absolute_mode_v3(sc)) {
		free(sc->elantech, M_DEVBUF);
		sc->elantech = NULL;
a1813 1
	}
d1818 5
d1999 1
a1999 1
	/* 
d2045 1
a2045 1
		/* 
d2075 1
a2075 1
 {
@


1.33
log
@Don't OR flags into an uninitialized variable in elantech hardware v1 code.
Fix by oga, via mikeb.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.32 2012/10/29 11:54:45 stsp Exp $ */
d274 1
a274 1
void	elantech_send_input(struct pms_softc *, u_int, int, int, int, int);
a1957 1
	u_int buttons = 0;
d1977 1
a1977 12
	if (sc->packet[0] & 0x01)
		buttons |= WSMOUSE_BUTTON(1);
	if (sc->packet[0] & 0x02)
		buttons |= WSMOUSE_BUTTON(3);
	if (elantech->flags & ELANTECH_F_HAS_ROCKER) {
		if (sc->packet[0] & 0x40) /* up */
			buttons |= WSMOUSE_BUTTON(4);
		if (sc->packet[0] & 0x80) /* down */
			buttons |= WSMOUSE_BUTTON(5);
	}

	elantech_send_input(sc, buttons, x, y, z, w);
a1984 1
	u_int buttons;
d2013 1
a2013 4
	buttons = ((sc->packet[0] & 0x01 ? WSMOUSE_BUTTON(1) : 0) |
	    ((sc->packet[0] & 0x02) ? WSMOUSE_BUTTON(3): 0));

	elantech_send_input(sc, buttons, x, y, z, w);
a2020 1
	u_int buttons;
a2027 2
	buttons = ((sc->packet[0] & 0x01 ? WSMOUSE_BUTTON(1) : 0) |
	    ((sc->packet[0] & 0x02) ? WSMOUSE_BUTTON(3): 0));
d2058 1
a2058 1
	elantech_send_input(sc, buttons, x, y, z, w);
d2062 1
a2062 2
elantech_send_input(struct pms_softc *sc, u_int buttons, int x, int y, int z,
    int w)
d2066 13
@


1.32
log
@Add support for Elantech touchpads to pms(4). This allows the X synaptics(4)
input driver to configure these touchpads properly, e.g. toggle tap-to-click,
two-finger scrolling, edge-scrolling, etc. So far these pads were working
only in PS/2 mouse compatibility mode.

Support for up to hardware version 3 has been implemented. But only version 3
has been tested so versions 1 and 2 remain disabled via #ifdef notyet until
someone tests (bugs in this code could seriously mess up the mouse and I
don't want to end up shipping such bugs in 5.3).

help and ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.31 2012/07/22 18:28:36 shadchin Exp $ */
d1958 1
a1958 1
	u_int buttons;
@


1.31
log
@Fix for ClickPad. On issue pointed gilles@@ and matthieu@@

ok gilles@@, matthieu@@, mpi@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.30 2012/07/01 12:59:34 mpi Exp $ */
d60 3
d114 19
d154 1
d253 12
d273 11
d342 29
d1437 675
@


1.30
log
@Pass a width value corresponding to one finger for ALPS touchpads when the
reported pressure is non-null. Fix the use of ALPS touchpads with recent
(>1.6) xf86-input-synaptics drivers, issue reported by janis at cieti lv.

Tested by yasuoka@@ and janis, ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.29 2012/04/28 09:43:24 tobias Exp $ */
d1029 2
a1030 1
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W);
d1339 2
a1340 1
		    WSMOUSE_INPUT_ABSOLUTE_Z | WSMOUSE_INPUT_ABSOLUTE_W);
@


1.29
log
@Added yet another magic for my ALPS touchpad.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.28 2012/03/05 18:42:55 shadchin Exp $ */
d1284 1
a1284 1
	int x, y, z, dx, dy;
d1332 5
a1336 1
		wsmouse_input(sc->sc_wsmousedev, buttons, x, y, z, 0,
d1338 1
a1338 1
		    WSMOUSE_INPUT_ABSOLUTE_Z);
@


1.28
log
@Adds support for a slightly different version of the ALPS protocol,
which send 'interleaved' PS2 packets in between absolute ALPS packets.
Dell laptops (E6xxx and E5500 at least) have this kind of touchpad.

ok and some rework mpi@@, tested okan@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.27 2012/01/28 21:00:48 mpi Exp $ */
d1134 2
a1135 1
	    (resp[2] != PMS_ALPS_MAGIC3_1 && resp[2] != PMS_ALPS_MAGIC3_2))
@


1.27
log
@Blacklist a dualpoint model which clitpad sends non compatible PS2 packets.

Issue reported by deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.26 2011/12/04 00:53:49 shadchin Exp $ */
d90 5
d102 2
a154 5
#if 0
	/* FIXME some clipads are not working yet */
	{ 0x5212, 0xff, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x6222, 0xcf, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
#endif
d159 1
d163 1
d235 1
d734 1
d743 1
a743 1
	sc->packet[sc->inputstate++] = data;
d748 1
a749 1
	sc->inputstate = 0;
d1059 34
d1204 2
d1250 7
d1265 3
d1270 2
a1271 1
		if ((data & 0x80) != 0)
d1286 3
@


1.26
log
@renaming synaptics_pt_* -> pms_sec_*
(synaptics and alps uses this for trackpoint)

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.25 2011/12/03 19:43:00 mpi Exp $ */
a165 1
	{ 0x633b, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
d171 7
@


1.25
log
@Correctly handle clitpad packets for some ALPS models.

reported by espie@@, not reported by miod@@

with and ok shadchin@@, ok espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.24 2011/10/17 17:12:01 mpi Exp $ */
d56 4
a59 4
#define PMS_STANDARD	0
#define PMS_INTELLI	1
#define PMS_SYNAPTICS	2
#define PMS_ALPS	3
d101 1
a101 1
#define ALPS_PRESSURE	40
d129 1
a129 1
	struct device *sc_pt_wsmousedev;
d183 1
d188 4
d223 1
a223 6

void	synaptics_pt_proc(struct pms_softc *);

int	synaptics_pt_ioctl(void *, u_long, caddr_t, int, struct proc *);
int	synaptics_pt_enable(void *);
void	synaptics_pt_disable(void *);
d242 4
a245 4
const struct wsmouse_accessops synaptics_pt_accessops = {
	synaptics_pt_enable,
	synaptics_pt_ioctl,
	synaptics_pt_disable,
d684 29
d732 1
d812 1
a812 1
synaptics_pt_proc(struct pms_softc *sc)
d826 1
a826 1
	wsmouse_input(sc->sc_pt_wsmousedev,
a830 29
synaptics_pt_enable(void *v)
{
	struct pms_softc *sc = v;

	return (pms_change_state(sc, PMS_STATE_ENABLED, PMS_DEV_SECONDARY));
}

void
synaptics_pt_disable(void *v)
{
	struct pms_softc *sc = v;

	pms_change_state(sc, PMS_STATE_DISABLED, PMS_DEV_SECONDARY);
}

int
synaptics_pt_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_PS2;
		break;
	default:
		return (-1);
	}
	return (0);
}

int
d866 1
a866 1
			a.accessops = &synaptics_pt_accessops;
d868 1
a868 1
			sc->sc_pt_wsmousedev = config_found((void *)sc, &a,
d959 1
a959 1
		synaptics_pt_proc(sc);
a1071 1

d1114 1
a1114 1
			a.accessops = &synaptics_pt_accessops;
d1116 1
a1116 1
			sc->sc_pt_wsmousedev = config_found((void *)sc, &a,
d1240 1
a1240 1
		wsmouse_input(sc->sc_pt_wsmousedev, buttons, dx, dy, 0, 0,
@


1.24
log
@Blacklist alps devices that might have a clitpad untill the driver get fixed
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.23 2011/10/17 09:15:22 mpi Exp $ */
d150 3
a156 5
	{ 0x5212, 0xff, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x6222, 0xcf, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x633b, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x7301, 0xf8, ALPS_DUALPOINT },
#endif
d166 2
d1078 1
d1112 7
d1232 17
a1256 4
	buttons = ((sc->packet[3] & 1) ? WSMOUSE_BUTTON(1) : 0) |
	    ((sc->packet[3] & 2) ? WSMOUSE_BUTTON(3) : 0) |
	    ((sc->packet[3] & 4) ? WSMOUSE_BUTTON(2) : 0);

a1257 7
		if (z == 127) {
			/* DualPoint touchpads are not absolute. */
			wsmouse_input(sc->sc_wsmousedev, buttons, x, y, 0, 0,
			    WSMOUSE_INPUT_DELTA);
			return;
		}

@


1.23
log
@Fix the synchronization of some alps pads, issue reported by Bryan (brakeb)
on misc@@

Similar diff tested by okan@@ and Mathieu (ptr.jetable)

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.22 2011/10/04 06:30:40 mpi Exp $ */
d148 2
d155 4
a161 1
	{ 0x6222, 0xcf, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
a167 2
	{ 0x633b, 0xf8, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x7301, 0xf8, ALPS_DUALPOINT },
@


1.22
log
@Add support for ALPS touchpads.

This also fix the "slow touchpad" problem due to the fact that some ALPS
devices respond to some Synaptics messages and stay in un half-configured
state.

Tested by Rivo Nurges, armani@@, shadchin@@ and matthieu@@

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.21 2011/08/24 15:34:25 shadchin Exp $ */
d90 1
d145 1
d148 20
a167 20
	{ 0x2021, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x2221, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x2222, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x3222, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x5212, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x5321, ALPS_GLIDEPOINT },
	{ 0x5322, ALPS_GLIDEPOINT },
	{ 0x603b, ALPS_GLIDEPOINT },
	{ 0x6222, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x6321, ALPS_GLIDEPOINT },
	{ 0x6322, ALPS_GLIDEPOINT },
	{ 0x6323, ALPS_GLIDEPOINT },
	{ 0x6324, ALPS_GLIDEPOINT },
	{ 0x6325, ALPS_GLIDEPOINT },
	{ 0x6326, ALPS_GLIDEPOINT },
	{ 0x633b, ALPS_DUALPOINT | ALPS_PASSTHROUGH },
	{ 0x7301, ALPS_DUALPOINT },
	{ 0x7321, ALPS_GLIDEPOINT },
	{ 0x7322, ALPS_GLIDEPOINT },
	{ 0x7325, ALPS_GLIDEPOINT },
d169 1
a169 1
	{ 0x7326, 0 },	/* XXX Uses unknown v3 protocol */
d1063 1
d1189 2
d1193 1
a1193 1
		if ((data & 0xf8) != 0xf8)	/* XXX model dependant? */
@


1.21
log
@revert the last commit. pms_enable_alps() does not guarantee
the accuracy detection ALPS.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.19 2011/08/17 16:10:27 shadchin Exp $ */
d42 6
d59 1
d88 15
d123 1
d142 29
d205 5
d220 2
d270 10
a279 1
	}
d554 2
d1038 233
@


1.20
log
@Adding stub for ALPS touchpad, which not supported yet.
This fixed "react strangely" when the pms driver probes
for a synaptic-compatible touchpad.

Tested and ok mpi@@
@
text
@a52 1
#define PMS_ALPS	3
a152 2
int	pms_enable_alps(struct pms_softc *);

a210 9
	},
	/* ALPS touchpad - not supported yet */
	{
		PMS_ALPS, 3,
		pms_enable_alps,
		pms_ioctl_mouse,
		pms_sync_mouse,
		pms_proc_mouse,
		NULL
a385 1
	case PMS_ALPS:			/* XXX */
a411 1
	case PMS_ALPS:			/* XXX */
a967 21
}

int
pms_enable_alps(struct pms_softc *sc)
{
	u_char resp[3];

	if (pms_set_resolution(sc, 0) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_set_scaling(sc, 1) ||
	    pms_get_status(sc, resp) ||
	    resp[0] != PMS_ALPS_MAGIC1 ||
	    resp[1] != PMS_ALPS_MAGIC2 ||
	    (resp[2] != PMS_ALPS_MAGIC3_1 && resp[2] != PMS_ALPS_MAGIC3_2))
		return (0);

	/* XXX reset, ALPS not supported yet */
	pms_reset(sc);

	return (1);
@


1.19
log
@Adding support Synaptics touchpad. Thanks all for test.

ok miod@@, matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.18 2011/01/03 19:46:34 shadchin Exp $ */
d53 1
d154 2
d214 9
d398 1
d425 1
d982 21
@


1.18
log
@remove sc->sc_kbcslot, as is always PCKBC_AUX_SLOT
ok krw, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.17 2010/12/27 12:22:20 shadchin Exp $ */
d31 1
d44 2
d52 1
d61 20
d91 5
d100 1
d105 1
a107 4
#define PMS_BUTTON1DOWN		0x0001	/* left */
#define PMS_BUTTON2DOWN		0x0002	/* middle */
#define PMS_BUTTON3DOWN		0x0004	/* right */

d110 7
a116 7
	PMS_BUTTON1DOWN,
	PMS_BUTTON3DOWN,
	PMS_BUTTON1DOWN | PMS_BUTTON3DOWN,
	PMS_BUTTON2DOWN,
	PMS_BUTTON1DOWN | PMS_BUTTON2DOWN,
	PMS_BUTTON2DOWN | PMS_BUTTON3DOWN,
	PMS_BUTTON1DOWN | PMS_BUTTON2DOWN | PMS_BUTTON3DOWN
a118 13
/* PS/2 mouse data packet */
#define PMS_PS2_BUTTONSMASK	0x07
#define PMS_PS2_BUTTON1		0x01	/* left */
#define PMS_PS2_BUTTON2		0x04	/* middle */
#define PMS_PS2_BUTTON3		0x02	/* right */
#define PMS_PS2_XNEG		0x10
#define PMS_PS2_YNEG		0x20

#define PMS_INTELLI_MAGIC1	200
#define PMS_INTELLI_MAGIC2	100
#define PMS_INTELLI_MAGIC3	80
#define PMS_INTELLI_ID		0x03

d125 1
a125 1
int	pms_change_state(struct pms_softc *, int);
d131 1
d147 16
d178 7
a184 1
const struct pms_protocol pms_mouse[] = {
d202 9
d227 12
d456 1
d476 10
d487 1
a487 4
	sc->poll = 1;
	pms_change_state(sc, PMS_STATE_ENABLED);
	sc->poll = 1; /* XXX */
	pms_change_state(sc, PMS_STATE_DISABLED);
d498 2
a499 1
			pms_change_state(sc, PMS_STATE_SUSPENDED);
d503 2
a504 1
			pms_change_state(sc, PMS_STATE_ENABLED);
d511 1
a511 1
pms_change_state(struct pms_softc *sc, int newstate)
d515 22
a538 3
		if (sc->sc_state == PMS_STATE_ENABLED)
			return (EBUSY);

d548 10
a557 4
		sc->protocol = &pms_mouse[0];
		for (i = 1; i < nitems(pms_mouse); i++)
			if (pms_mouse[i].enable(sc))
				sc->protocol = &pms_mouse[i];
d587 1
a587 1
	return pms_change_state(sc, PMS_STATE_ENABLED);
d595 1
a595 1
	pms_change_state(sc, PMS_STATE_DISABLED);
d620 1
a620 1
#ifdef DEBUG
d633 335
@


1.17
log
@cleanup pms_enable_intelli: magic numbers -> defines
ok krw, miod
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.16 2010/12/24 18:22:20 shadchin Exp $ */
a60 1
	int sc_kbcslot;
d172 1
a172 1
		return pckbc_poll_cmd(sc->sc_kbctag, sc->sc_kbcslot,
d175 1
a175 1
		return pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot,
a399 1
	sc->sc_kbcslot = pa->pa_slot;
d403 1
a403 1
	pckbc_set_inputhandler(sc->sc_kbctag, sc->sc_kbcslot,
d454 1
a454 1
		pckbc_slot_enable(sc->sc_kbctag, sc->sc_kbcslot, 1);
d457 1
a457 1
			pckbc_flush(sc->sc_kbctag, sc->sc_kbcslot);
d479 1
a479 1
		pckbc_slot_enable(sc->sc_kbctag, sc->sc_kbcslot, 0);
@


1.16
log
@fix crash:
after boot and before the first activation (wsmoused or X),
sc->protocol is not initialized, and any call ioctl lead to crash
(example 'wsconsctl -a')

thanks and ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.15 2010/12/23 20:04:09 shadchin Exp $ */
d101 5
a280 1
	static const int rates[] = {200, 100, 80};
d283 4
a286 3
	if (pms_set_rate(sc, rates[0]) ||
	    pms_set_rate(sc, rates[1]) ||
	    pms_set_rate(sc, rates[2]) ||
d288 1
a288 1
	    resp != 0x03)
d513 1
a513 1
		return(sc->protocol->ioctl(sc, cmd, data, flag, p));
@


1.15
log
@Add a common interface for various devices

This is to make it easier to add additional mice types in future

ok krw@@, miod@@, nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.14 2010/11/15 20:25:31 krw Exp $ */
d416 2
d507 4
a510 1
	return (sc->protocol->ioctl(sc, cmd, data, flag, p));
@


1.14
log
@Aesthetic improvements to make it appear more normal and knf'y.

No functional change. From Alexandr Scadchin again.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.13 2010/11/15 13:51:20 krw Exp $ */
d43 14
a68 1
	int intelli;
d70 4
a73 2
	u_int buttons, oldbuttons;	/* mouse button status */
	signed char dx, dy;
d78 23
d122 5
a126 1
int	pms_setintellimode(struct pms_softc *sc);
d143 21
d274 1
a274 1
pms_setintellimode(struct pms_softc *sc)
d290 72
d440 2
a447 1
		sc->oldbuttons = 0;
d456 8
a463 1
		sc->intelli = pms_setintellimode(sc);
d470 4
a503 2
	u_char kbcmd[2];
	int i;
d505 1
a505 26
	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_PS2;
		break;
		
	case WSMOUSEIO_SRES:
		i = ((int) *(u_int *)data - 12) / 25;		
		/* valid values are {0,1,2,3} */
		if (i < 0)
			i = 0;
		if (i > 3)
			i = 3;
		
		kbcmd[0] = PMS_SET_RES;
		kbcmd[1] = (unsigned char) i;			
		i = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, kbcmd, 
		    2, 0, 1, 0);
		
		if (i)
			printf("pms_ioctl: SET_RES command error\n");
		break;
		
	default:
		return (-1);
	}
	return (0);
a507 5
/* Masks for the first byte of a packet */
#define PS2LBUTMASK 0x01
#define PS2RBUTMASK 0x02
#define PS2MBUTMASK 0x04

a511 2
	signed char dz = 0;
	u_int changed;
d518 6
a523 29
	switch (sc->inputstate) {

	case 0:
		if ((data & 0xc0) == 0) { /* no ovfl, bit 3 == 1 too? */
			sc->buttons = ((data & PS2LBUTMASK) ? 0x1 : 0) |
			    ((data & PS2MBUTMASK) ? 0x2 : 0) |
			    ((data & PS2RBUTMASK) ? 0x4 : 0);
			++sc->inputstate;
		}
		break;

	case 1:
		sc->dx = data;
		/* Bounding at -127 avoids a bug in XFree86. */
		sc->dx = (sc->dx == -128) ? -127 : sc->dx;
		++sc->inputstate;
		break;

	case 2:
		sc->dy = data;
		sc->dy = (sc->dy == -128) ? -127 : sc->dy;
		++sc->inputstate;
		break;

	case 3:
		dz = data;
		dz = (dz == -128) ? -127 : dz;
		++sc->inputstate;
		break;
d526 3
a528 11
	if ((sc->inputstate == 3 && sc->intelli == 0) || sc->inputstate == 4) {
		sc->inputstate = 0;

		changed = (sc->buttons ^ sc->oldbuttons);
		sc->oldbuttons = sc->buttons;

		if (sc->dx || sc->dy || dz || changed)
			wsmouse_input(sc->sc_wsmousedev,
				      sc->buttons, sc->dx, sc->dy, dz, 0,
				      WSMOUSE_INPUT_DELTA);
	}
d530 2
a531 1
	return;
@


1.13
log
@More cleanup. Add DEVNAME() macro and generic functions for various
actions (set/get/reset/enable/disable) to wrap pms_cmd() invocations.

No functional change. From Alexandr Scadchin again.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.12 2010/11/05 16:10:49 krw Exp $ */
d63 3
a65 4
int pmsprobe(struct device *, void *, void *);
void pmsattach(struct device *, struct device *, void *);
int pmsactivate(struct device *, int);
void pmsinput(void *, int);
d67 1
a67 4
struct cfattach pms_ca = {
	sizeof(struct pms_softc), pmsprobe, pmsattach, NULL,
	pmsactivate
};
d86 9
a449 4

struct cfdriver pms_cd = {
	NULL, "pms", DV_DULL
};
@


1.12
log
@Minor code cleanups. No functional change. From Alexandr Shadchin.

ok nicm@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.11 2010/10/19 11:00:50 krw Exp $ */
d41 2
d79 8
d109 19
a127 1
pms_setintellimode(struct pms_softc *sc)
d129 1
a129 3
	u_char cmd[2], resp[1];
	int i, res;
	static const u_char rates[] = {200, 100, 80};
d132 27
a158 5
	for (i = 0; i < 3; i++) {
		cmd[1] = rates[i];
		res = pms_cmd(sc, cmd, 2, NULL, 0);
		if (res)
			return (0);
d160 31
d192 24
a215 3
	cmd[0] = PMS_SEND_DEV_ID;
	res = pms_cmd(sc, cmd, 1, resp, 1);
	if (res || resp[0] != 3)
d261 1
a261 1
			       pmsinput, sc, sc->sc_dev.dv_xname);
a299 3
	u_char cmd[1], resp[2];
	int res;

d313 1
a313 2
		cmd[0] = PMS_RESET;
		res = pms_cmd(sc, cmd, 1, resp, 2);
d317 1
a317 4
		cmd[0] = PMS_DEV_ENABLE;
		res = pms_cmd(sc, cmd, 1, NULL, 0);
		if (res)
			printf("pms_enable: command error\n");
d321 1
a321 4
		cmd[0] = PMS_DEV_DISABLE;
		res = pms_cmd(sc, cmd, 1, NULL, 0);
		if (res)
			printf("pms_disable: command error\n");
@


1.11
log
@Unify some error messages to simplify reset code. No functional
change.

ok nicm@@

From shadchin.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.10 2010/10/17 10:32:00 krw Exp $ */
d206 2
a207 1
			return EBUSY;
a224 27
#if 0
		{
			u_char scmd[2];

			scmd[0] = PMS_SET_RES;
			scmd[1] = 3; /* 8 counts/mm */
			res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
						2, 0, 1, 0);
			if (res)
				printf("pms_enable: setup error1 (%d)\n", res);

			scmd[0] = PMS_SET_SCALE21;
			res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
						1, 0, 1, 0);
			if (res)
				printf("pms_enable: setup error2 (%d)\n", res);

			scmd[0] = PMS_SET_SAMPLE;
			scmd[1] = 100; /* 100 samples/sec */
			res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
						2, 0, 1, 0);
			if (res)
				printf("pms_enable: setup error3 (%d)\n", res);
		}
#endif
		sc->sc_state = newstate;
		sc->poll = 0;
a226 2

		/* FALLTHROUGH */
a232 2
		sc->sc_state = newstate;
		sc->poll = (newstate == PMS_STATE_SUSPENDED) ? 1 : 0;
d235 5
a239 1
	return 0;
@


1.10
log
@Ansify non-ansified function definitions. No functional change.

ok nicm@@

From shadchin.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.9 2010/10/16 11:24:04 krw Exp $ */
d137 1
a137 1
	if (res) {
d139 2
a140 13
		printf("pmsprobe: reset error %d\n", res);
#endif
		return (0);
	}
	if (resp[0] != PMS_RSTDONE) {
		printf("pmsprobe: reset response 0x%x\n", resp[0]);
		return (0);
	}

	/* get type number (0 = mouse) */
	if (resp[1] != 0) {
#ifdef DEBUG
		printf("pmsprobe: type 0x%x\n", resp[1]);
@


1.9
log
@Remove some duplicated code. No need to flush/reset at attach and then
again at PMS_STATE_CHANGE events.

Tested my myself, ian@@ and nicm@@ without regressions on usual
problematic machines.

From shadchin.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.8 2010/10/07 01:52:25 krw Exp $ */
d122 1
a122 4
pmsprobe(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d160 1
a160 3
pmsattach(parent, self, aux)
	struct device *parent, *self;
	void *aux;
d280 1
a280 2
pms_enable(v)
	void *v;
d288 1
a288 2
pms_disable(v)
	void *v;
d296 1
a296 6
pms_ioctl(v, cmd, data, flag, p)
	void *v;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d335 2
a336 3
void pmsinput(vsc, data)
void *vsc;
int data;
@


1.8
log
@Fix some pms(4) vs wsmoused issues. From Alexandr Shadchin via
tech@@. Tested on the usual problematic machines by myself, nicm@@
and ian@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.7 2010/10/02 00:28:57 krw Exp $ */
a169 2
	u_char cmd[1], resp[2];
	int res;
a174 16

	/* Flush any garbage. */
	pckbc_flush(pa->pa_tag, pa->pa_slot);

	/* reset the device */
	cmd[0] = PMS_RESET;
	res = pckbc_poll_cmd(pa->pa_tag, pa->pa_slot, cmd, 1, 2, resp, 1);
#ifdef DEBUG
	if (res || resp[0] != PMS_RSTDONE || resp[1] != 0) {
		printf("pmsattach: reset error\n");
		return;
	}
#endif

	sc->inputstate = 0;
	sc->oldbuttons = 0;
@


1.7
log
@Fix Ian@@'s pms keyboard/mouse while keeping my eeePC working.

For posterity: there is one time when pckbc commands must be thrown,
and one time when pckbc commands must be polled.

Diff from shadchin.

ok miod@@
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.6 2010/09/29 19:39:18 deraadt Exp $ */
d246 2
a247 1
		pckbc_flush(sc->sc_kbctag, sc->sc_kbcslot);
@


1.6
log
@The attach function can return 1 now because there is no more priority
scheme relating to pmsi.
from alexandr.shadchin@@gmail.com
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.5 2010/09/27 18:16:25 miod Exp $ */
d52 1
d76 3
a78 1
int	pms_setintellimode(pckbc_tag_t, pckbc_slot_t);
d87 13
a99 1
pms_setintellimode(pckbc_tag_t tag, pckbc_slot_t slot)
d108 1
a108 1
		res = pckbc_enqueue_cmd(tag, slot, cmd, 2, 0, 0, NULL);
d114 1
a114 1
	res = pckbc_enqueue_cmd(tag, slot, cmd, 1, 1, 1, resp);
d209 2
a210 5
	cmd[0] = PMS_DEV_DISABLE;
	res = pckbc_poll_cmd(pa->pa_tag, pa->pa_slot, cmd, 1, 0, NULL, 0);
	if (res)
		printf("pmsattach: disable error\n");
	pckbc_slot_enable(sc->sc_kbctag, sc->sc_kbcslot, 0);
d234 1
a234 1
	u_char cmd[1];
d247 5
a251 1
		sc->intelli = pms_setintellimode(sc->sc_kbctag, sc->sc_kbcslot);
d254 1
a254 2
		res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot,
		    cmd, 1, 0, 1, 0);
d283 1
d290 1
a290 2
		res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot,
		    cmd, 1, 0, 1, 0);
d295 1
@


1.5
log
@Make sure the SEND_DEV_ID command is sent synchronously, so the response buffer
is valid when we look at it. Repairs intellimouse (former pmsi) operation.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.4 2010/09/26 20:39:08 miod Exp $ */
d144 1
a144 1
	return (10);
@


1.4
log
@Merge pmsi(4) into pms(4). From Alexandr Shadchin on tech@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.3 2010/07/22 14:25:41 deraadt Exp $ */
d99 1
a99 1
	res = pckbc_enqueue_cmd(tag, slot, cmd, 1, 1, 0, resp);
d234 1
@


1.3
log
@Toggle the mouse through the disabled and enabled states when suspending
and restoring.  Fixes most mice.
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.2 2007/10/17 01:32:46 deraadt Exp $ */
d51 2
d55 1
a55 1
	signed char dx;
d75 2
d84 23
d234 2
d352 1
a352 1
	signed char dy;
d379 13
a391 2
		dy = data;
		dy = (dy == -128) ? -127 : dy;
d397 1
a397 1
		if (sc->dx || dy || changed)
d399 1
a399 1
				      sc->buttons, sc->dx, dy, 0, 0,
a400 1
		break;
@


1.2
log
@use NULL to point to the response buffer, which avoids confusion; ok fgsch
@
text
@d1 1
a1 1
/* $OpenBSD: pms.c,v 1.1 2007/08/01 12:16:59 kettenis Exp $ */
d47 4
a50 1
	int sc_enabled;		/* input enabled? */
d60 1
d64 2
a65 1
	sizeof(struct pms_softc), pmsprobe, pmsattach,
d68 2
a70 1
int	pms_ioctl(void *, u_long, caddr_t, int, struct proc *);
d175 19
a193 2
pms_enable(v)
	void *v;
a194 1
	struct pms_softc *sc = v;
d198 14
a211 13
	if (sc->sc_enabled)
		return EBUSY;

	sc->sc_enabled = 1;
	sc->inputstate = 0;
	sc->oldbuttons = 0;

	pckbc_slot_enable(sc->sc_kbctag, sc->sc_kbcslot, 1);

	cmd[0] = PMS_DEV_ENABLE;
	res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, cmd, 1, 0, 1, 0);
	if (res)
		printf("pms_enable: command error\n");
d213 2
a214 2
	{
		u_char scmd[2];
d216 24
a239 6
		scmd[0] = PMS_SET_RES;
		scmd[1] = 3; /* 8 counts/mm */
		res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
					2, 0, 1, 0);
		if (res)
			printf("pms_enable: setup error1 (%d)\n", res);
d241 5
a245 3
		scmd[0] = PMS_SET_SCALE21;
		res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
					1, 0, 1, 0);
d247 7
a253 1
			printf("pms_enable: setup error2 (%d)\n", res);
d255 5
a259 8
		scmd[0] = PMS_SET_SAMPLE;
		scmd[1] = 100; /* 100 samples/sec */
		res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, scmd,
					2, 0, 1, 0);
		if (res)
			printf("pms_enable: setup error3 (%d)\n", res);
	}
#endif
d261 1
a261 1
	return 0;
a268 9
	u_char cmd[1];
	int res;

	cmd[0] = PMS_DEV_DISABLE;
	res = pckbc_enqueue_cmd(sc->sc_kbctag, sc->sc_kbcslot, cmd, 1, 0, 1, 0);
	if (res)
		printf("pms_disable: command error\n");

	pckbc_slot_enable(sc->sc_kbctag, sc->sc_kbcslot, 0);
d270 1
a270 1
	sc->sc_enabled = 0;
d326 1
a326 1
	if (!sc->sc_enabled) {
@


1.1
log
@Correct a 10-year old typo inherited from NetBSD by renaming psm.c,
psm_intelli.c and psmreg.h into pms.c, pms_intelli.c and pmsreg.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: psm.c,v 1.5 2007/04/10 22:37:17 miod Exp $ */
d162 1
a162 1
	res = pckbc_poll_cmd(pa->pa_tag, pa->pa_slot, cmd, 1, 0, 0, 0);
@

