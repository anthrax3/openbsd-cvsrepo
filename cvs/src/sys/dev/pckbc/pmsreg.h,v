head	1.13;
access;
symbols
	OPENBSD_6_1:1.13.0.8
	OPENBSD_6_1_BASE:1.13
	OPENBSD_6_0:1.13.0.4
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.11.0.4
	OPENBSD_5_8_BASE:1.11
	OPENBSD_5_7:1.10.0.10
	OPENBSD_5_7_BASE:1.10
	OPENBSD_5_6:1.10.0.8
	OPENBSD_5_6_BASE:1.10
	OPENBSD_5_5:1.10.0.6
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.10.0.2
	OPENBSD_5_4_BASE:1.10
	OPENBSD_5_3:1.9.0.2
	OPENBSD_5_3_BASE:1.9
	OPENBSD_5_2:1.8.0.2
	OPENBSD_5_2_BASE:1.8
	OPENBSD_5_1_BASE:1.6
	OPENBSD_5_1:1.6.0.2
	OPENBSD_5_0:1.1.0.18
	OPENBSD_5_0_BASE:1.1
	OPENBSD_4_9:1.1.0.16
	OPENBSD_4_9_BASE:1.1
	OPENBSD_4_8:1.1.0.14
	OPENBSD_4_8_BASE:1.1
	OPENBSD_4_7:1.1.0.10
	OPENBSD_4_7_BASE:1.1
	OPENBSD_4_6:1.1.0.12
	OPENBSD_4_6_BASE:1.1
	OPENBSD_4_5:1.1.0.8
	OPENBSD_4_5_BASE:1.1
	OPENBSD_4_4:1.1.0.6
	OPENBSD_4_4_BASE:1.1
	OPENBSD_4_3:1.1.0.4
	OPENBSD_4_3_BASE:1.1
	OPENBSD_4_2:1.1.0.2
	OPENBSD_4_2_BASE:1.1;
locks; strict;
comment	@ * @;


1.13
date	2015.09.05.14.02.21;	author bru;	state Exp;
branches;
next	1.12;
commitid	EIBy9LgYoz011bAe;

1.12
date	2015.09.05.13.52.54;	author bru;	state Exp;
branches;
next	1.11;
commitid	qR4g8pCIfKayzzgh;

1.11
date	2015.03.26.01.30.22;	author jsg;	state Exp;
branches;
next	1.10;
commitid	DfGw11wytDIaNGqm;

1.10
date	2013.05.31.19.21.09;	author jcs;	state Exp;
branches;
next	1.9;

1.9
date	2012.10.29.11.54.45;	author stsp;	state Exp;
branches;
next	1.8;

1.8
date	2012.04.28.09.43.24;	author tobias;	state Exp;
branches;
next	1.7;

1.7
date	2012.03.05.18.42.55;	author shadchin;	state Exp;
branches;
next	1.6;

1.6
date	2011.12.03.19.43.00;	author mpi;	state Exp;
branches;
next	1.5;

1.5
date	2011.10.04.06.30.40;	author mpi;	state Exp;
branches;
next	1.4;

1.4
date	2011.08.24.15.34.25;	author shadchin;	state Exp;
branches;
next	1.3;

1.3
date	2011.08.22.16.26.42;	author shadchin;	state Exp;
branches;
next	1.2;

1.2
date	2011.08.17.16.10.27;	author shadchin;	state Exp;
branches;
next	1.1;

1.1
date	2007.08.01.12.16.59;	author kettenis;	state Exp;
branches;
next	;


desc
@@


1.13
log
@Support Synaptics touchpads without W mode.

Emulate W mode if a Synaptics model doesn't provide it, and check
for the success of the resolution query during setup.

ok shadchin@@, mpi@@
@
text
@/* $OpenBSD: pmsreg.h,v 1.12 2015/09/05 13:52:54 bru Exp $ */
/* $NetBSD: psmreg.h,v 1.1 1998/03/22 15:41:28 drochner Exp $ */

#ifndef SYS_DEV_PCKBC_PMSREG_H
#define SYS_DEV_PCKBC_PMSREG_H

/* mouse commands */
#define PMS_SET_SCALE11		0xe6	/* set scaling 1:1 */
#define PMS_SET_SCALE21		0xe7	/* set scaling 2:1 */
#define PMS_SET_RES		0xe8	/* set resolution (0..3) */
#define PMS_SEND_DEV_STATUS	0xe9	/* status request */
#define PMS_SET_STREAM_MODE	0xea
#define PMS_SEND_DEV_DATA	0xeb	/* read data */
#define PMS_RESET_WRAP_MODE	0xec
#define PMS_SET_WRAP_MODE	0xed
#define PMS_SET_REMOTE_MODE	0xf0
#define PMS_SEND_DEV_ID		0xf2	/* read device type */
#define PMS_SET_SAMPLE		0xf3	/* set sampling rate */
#define PMS_DEV_ENABLE		0xf4	/* mouse on */
#define PMS_DEV_DISABLE		0xf5	/* mouse off */
#define PMS_SET_DEFAULTS	0xf6
#define PMS_RESEND		0xfe
#define PMS_RESET		0xff	/* reset */

#define PMS_RSTDONE		0xaa

/* PS/2 mouse data packet */
#define PMS_PS2_BUTTONSMASK	0x07
#define PMS_PS2_BUTTON1		0x01	/* left */
#define PMS_PS2_BUTTON2		0x04	/* middle */
#define PMS_PS2_BUTTON3		0x02	/* right */
#define PMS_PS2_XNEG		0x10
#define PMS_PS2_YNEG		0x20

#define PMS_INTELLI_MAGIC1	200
#define PMS_INTELLI_MAGIC2	100
#define PMS_INTELLI_MAGIC3	80
#define PMS_INTELLI_ID		0x03

#define PMS_ALPS_MAGIC1		0
#define PMS_ALPS_MAGIC2		0
#define PMS_ALPS_MAGIC3_1	10
#define PMS_ALPS_MAGIC3_2	80
#define PMS_ALPS_MAGIC3_3	100

#define PMS_ELANTECH_MAGIC1	0x3c
#define PMS_ELANTECH_MAGIC2	0x03
#define PMS_ELANTECH_MAGIC3_1	0xc8
#define PMS_ELANTECH_MAGIC3_2	0x00

/*
 * Checking for almost-standard PS/2 packet
 * Note: ALPS devices never signal overflow condition
 */
#define PMS_ALPS_PS2_MASK			0xc8
#define PMS_ALPS_PS2_VALID			0x08

/* Checking for interleaved packet */
#define PMS_ALPS_INTERLEAVED_MASK		0xcf
#define PMS_ALPS_INTERLEAVED_VALID		0x0f

/* Checking for non first byte */
#define PMS_ALPS_MASK				0x80
#define PMS_ALPS_VALID				0x00

/* Synaptics queries */
#define SYNAPTICS_QUE_IDENTIFY			0x00
#define SYNAPTICS_QUE_MODES			0x01
#define SYNAPTICS_QUE_CAPABILITIES		0x02
#define SYNAPTICS_QUE_MODEL			0x03
#define SYNAPTICS_QUE_SERIAL_NUMBER_PREFIX	0x06
#define SYNAPTICS_QUE_SERIAL_NUMBER_SUFFIX	0x07
#define SYNAPTICS_QUE_RESOLUTION		0x08
#define SYNAPTICS_QUE_EXT_MODEL			0x09
#define SYNAPTICS_QUE_EXT_CAPABILITIES		0x0c
#define SYNAPTICS_QUE_EXT_DIMENSIONS		0x0d
#define SYNAPTICS_QUE_EXT2_CAPABILITIES		0x10

#define SYNAPTICS_CMD_SET_MODE			0x14
#define SYNAPTICS_CMD_SEND_CLIENT		0x28
#define SYNAPTICS_CMD_SET_ADV_GESTURE_MODE	0xc8

/* Identify */
#define SYNAPTICS_ID_MODEL(id)			(((id) >>  4) & 0x0f)
#define SYNAPTICS_ID_MINOR(id)			(((id) >> 16) & 0xff)
#define SYNAPTICS_ID_MAJOR(id)			((id) & 0x0f)
#define SYNAPTICS_ID_FULL(id) \
	(SYNAPTICS_ID_MAJOR(id) << 8 | SYNAPTICS_ID_MINOR(id))
#define SYNAPTICS_ID_MAGIC			0x47

/* Modes bits */
#define SYNAPTICS_EXT2_CAP			(1 << 17)
#define SYNAPTICS_ABSOLUTE_MODE			(1 << 7)
#define SYNAPTICS_HIGH_RATE			(1 << 6)
#define SYNAPTICS_SLEEP_MODE			(1 << 3)
#define SYNAPTICS_DISABLE_GESTURE		(1 << 2)
#define SYNAPTICS_FOUR_BYTE_CLIENT		(1 << 1)
#define SYNAPTICS_W_MODE			(1 << 0)

/* Capability bits */
#define SYNAPTICS_CAP_EXTENDED			(1 << 23)
#define SYNAPTICS_CAP_EXTENDED_QUERIES(c)	(((c) >> 20) & 0x07)
#define SYNAPTICS_CAP_MIDDLE_BUTTON		(1 << 18)
#define SYNAPTICS_CAP_PASSTHROUGH		(1 << 7)
#define SYNAPTICS_CAP_SLEEP			(1 << 4)
#define SYNAPTICS_CAP_FOUR_BUTTON		(1 << 3)
#define SYNAPTICS_CAP_BALLISTICS		(1 << 2)
#define SYNAPTICS_CAP_MULTIFINGER		(1 << 1)
#define SYNAPTICS_CAP_PALMDETECT		(1 << 0)

/* Model ID bits */
#define SYNAPTICS_MODEL_ROT180			(1 << 23)
#define SYNAPTICS_MODEL_PORTRAIT		(1 << 22)
#define SYNAPTICS_MODEL_SENSOR(m)		(((m) >> 16) & 0x3f)
#define SYNAPTICS_MODEL_HARDWARE(m)		(((m) >> 9) & 0x7f)
#define SYNAPTICS_MODEL_NEWABS			(1 << 7)
#define SYNAPTICS_MODEL_PEN			(1 << 6)
#define SYNAPTICS_MODEL_SIMPLC			(1 << 5)
#define SYNAPTICS_MODEL_GEOMETRY(m)		((m) & 0x0f)

/* Resolutions */
#define SYNAPTICS_RESOLUTION_VALID		(1 << 15)
#define SYNAPTICS_RESOLUTION_X(r)		(((r) >> 16) & 0xff)
#define SYNAPTICS_RESOLUTION_Y(r)		((r) & 0xff)

/* Extended Model ID bits */
#define SYNAPTICS_EXT_MODEL_LIGHTCONTROL	(1 << 22)
#define SYNAPTICS_EXT_MODEL_PEAKDETECT		(1 << 21)
#define SYNAPTICS_EXT_MODEL_VWHEEL		(1 << 19)
#define SYNAPTICS_EXT_MODEL_EW_MODE		(1 << 18)
#define SYNAPTICS_EXT_MODEL_HSCROLL		(1 << 17)
#define SYNAPTICS_EXT_MODEL_VSCROLL		(1 << 16)
#define SYNAPTICS_EXT_MODEL_BUTTONS(em)		((em >> 12) & 0x0f)
#define SYNAPTICS_EXT_MODEL_SENSOR(em)		((em >> 10) & 0x03)
#define SYNAPTICS_EXT_MODEL_PRODUCT(em)		((em) & 0xff)

/* Extended Capability bits */
#define SYNAPTICS_EXT_CAP_CLICKPAD		(1 << 20)
#define SYNAPTICS_EXT_CAP_ADV_GESTURE		(1 << 19)
#define SYNAPTICS_EXT_CAP_MAX_DIMENSIONS	(1 << 17)
#define SYNAPTICS_EXT_CAP_CLICKPAD_2BTN		(1 << 8)

/* Extended Dimensions */
#define SYNAPTICS_DIM_X(d)			((((d) & 0xff0000) >> 11) | \
						 (((d) & 0xf00) >> 7))
#define SYNAPTICS_DIM_Y(d)			((((d) & 0xff) << 5) | \
						 (((d) & 0xf000) >> 11))

/* Extended Capability 2 */
#define SYNAPTICS_EXT2_CAP_BUTTONS_STICK	(1 << 16)

/* Typical bezel limit */
#define SYNAPTICS_XMIN_BEZEL			1472
#define SYNAPTICS_XMAX_BEZEL			5472
#define SYNAPTICS_YMIN_BEZEL			1408
#define SYNAPTICS_YMAX_BEZEL			4448

#define ALPS_XMIN_BEZEL				130
#define ALPS_XMAX_BEZEL				840
#define ALPS_YMIN_BEZEL				130
#define ALPS_YMAX_BEZEL				640

#define ALPS_XSEC_BEZEL				768
#define ALPS_YSEC_BEZEL				512

#define ALPS_Z_MAGIC				127

/* ALPS "gesture" and "finger" bits */
#define ALPS_TAP				0x01
#define ALPS_DRAG				0x03

/* Elantech queries */
#define ELANTECH_QUE_FW_ID			0
#define ELANTECH_QUE_FW_VER			1
#define ELANTECH_QUE_CAPABILITIES		2
#define ELANTECH_QUE_SAMPLE			3
#define ELANTECH_QUE_RESOLUTION			4

/* Elantech capabilities */
#define ELANTECH_CAP_HAS_ROCKER			4

#define ELANTECH_PS2_CUSTOM_COMMAND		0xf8

#define ELANTECH_CMD_READ_REG			0x10
#define ELANTECH_CMD_WRITE_REG			0x11
#define ELANTECH_CMD_READ_WRITE_REG		0x00

#define ELANTECH_ABSOLUTE_MODE			0x04

/* Hardware version 1 has hard-coded axis range values.
 * X axis range is 0 to 576, Y axis range is 0 to 384.
 * Edge offset accounts for bezel around the touchpad. */
#define ELANTECH_V1_EDGE_OFFSET	32
#define ELANTECH_V1_X_MIN	(0 + ELANTECH_V1_EDGE_OFFSET)
#define ELANTECH_V1_X_MAX	(576 - ELANTECH_V1_EDGE_OFFSET)
#define ELANTECH_V1_Y_MIN	(0 + ELANTECH_V1_EDGE_OFFSET)
#define ELANTECH_V1_Y_MAX	(384 - ELANTECH_V1_EDGE_OFFSET)

/* Older hardware version 2 variants lack ID query capability. */
#define ELANTECH_V2_X_MAX	1152
#define ELANTECH_V2_Y_MAX	768

/* V4 */
#define ELANTECH_MAX_FINGERS			5
#define ELANTECH_V4_WEIGHT_VALUE		5

#define ELANTECH_V4_PKT_STATUS			0x10
#define ELANTECH_V4_PKT_HEAD			0x11
#define ELANTECH_V4_PKT_MOTION			0x12

#endif /* SYS_DEV_PCKBC_PMSREG_H */
@


1.12
log
@Improve tap-and-drag detection for ALPS touchpads.

The ALPS mechanism for gesture detection can produce long delays between
a packet that signals a tap and the next packet, which either signals
the end of the gesture or the start of a drag-operation. The time spans
can exceed the timeouts used by the generic detection mechanism in the
synaptics driver. Reporting both the touch and the release event when
the second packet has arrived ensures that the tap will be recognized.

ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.11 2015/03/26 01:30:22 jsg Exp $ */
d122 1
@


1.11
log
@Use the 0x10 extended capability to determine if the trackstick
buttons are wired to the trackpad and need to be re-routed to the
trackstick.  Without this change the buttons on 2015 thinkpads
get picked up as extended buttons that show up as scroll up/down.

Remove the X1 Carbon 2015 (LEN0048) and X250 (LEN0046) from the
top button area/soft buttons quirks list.  Also avoid using the
quirk list entirely if the capability bit is set.

Based on work from jcs@@ with feedback from mpi@@
ok mpi@@ jcs@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.10 2013/05/31 19:21:09 jcs Exp $ */
d166 4
@


1.10
log
@add elantech v4 (clickpad) support
tested on an asus ux21a

ok mpi@@ stsp@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.9 2012/10/29 11:54:45 stsp Exp $ */
d77 1
d87 2
d92 1
d147 3
@


1.9
log
@Add support for Elantech touchpads to pms(4). This allows the X synaptics(4)
input driver to configure these touchpads properly, e.g. toggle tap-to-click,
two-finger scrolling, edge-scrolling, etc. So far these pads were working
only in PS/2 mouse compatibility mode.

Support for up to hardware version 3 has been implemented. But only version 3
has been tested so versions 1 and 2 remain disabled via #ifdef notyet until
someone tests (bugs in this code could seriously mess up the mouse and I
don't want to end up shipping such bugs in 5.3).

help and ok mpi@@ shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.8 2012/04/28 09:43:24 tobias Exp $ */
d191 7
@


1.8
log
@Added yet another magic for my ALPS touchpad.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.7 2012/03/05 18:42:55 shadchin Exp $ */
d46 5
d159 32
@


1.7
log
@Adds support for a slightly different version of the ALPS protocol,
which send 'interleaved' PS2 packets in between absolute ALPS packets.
Dell laptops (E6xxx and E5500 at least) have this kind of touchpad.

ok and some rework mpi@@, tested okan@@.
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.6 2011/12/03 19:43:00 mpi Exp $ */
d43 2
a44 1
#define PMS_ALPS_MAGIC3_2	100
@


1.6
log
@Correctly handle clitpad packets for some ALPS models.

reported by espie@@, not reported by miod@@

with and ok shadchin@@, ok espie@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.5 2011/10/04 06:30:40 mpi Exp $ */
d45 15
a109 4

#define ALPS_GLIDEPOINT				(1 << 1)
#define ALPS_DUALPOINT				(1 << 2)
#define ALPS_PASSTHROUGH			(1 << 3)
@


1.5
log
@Add support for ALPS touchpads.

This also fix the "slow touchpad" problem due to the fact that some ALPS
devices respond to some Synaptics messages and stay in un half-configured
state.

Tested by Rivo Nurges, armani@@, shadchin@@ and matthieu@@

ok shadchin@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.4 2011/08/24 15:34:25 shadchin Exp $ */
d137 5
@


1.4
log
@revert the last commit. pms_enable_alps() does not guarantee
the accuracy detection ALPS.

ok mpi@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.2 2011/08/17 16:10:27 shadchin Exp $ */
d40 5
d96 4
d132 5
@


1.3
log
@Adding stub for ALPS touchpad, which not supported yet.
This fixed "react strangely" when the pms driver probes
for a synaptic-compatible touchpad.

Tested and ok mpi@@
@
text
@a39 5
#define PMS_ALPS_MAGIC1		0
#define PMS_ALPS_MAGIC2		0
#define PMS_ALPS_MAGIC3_1	10
#define PMS_ALPS_MAGIC3_2	100

@


1.2
log
@Adding support Synaptics touchpad. Thanks all for test.

ok miod@@, matthieu@@
@
text
@d1 1
a1 1
/* $OpenBSD: pmsreg.h,v 1.1 2007/08/01 12:16:59 kettenis Exp $ */
d39 5
@


1.1
log
@Correct a 10-year old typo inherited from NetBSD by renaming psm.c,
psm_intelli.c and psmreg.h into pms.c, pms_intelli.c and pmsreg.h.

ok deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: psmreg.h,v 1.2 2001/02/02 20:20:08 aaron Exp $ */
d4 3
d8 8
a15 7
#define	PMS_SET_SCALE11	0xe6	/* set scaling 1:1 */
#define	PMS_SET_SCALE21 0xe7	/* set scaling 2:1 */
#define	PMS_SET_RES	0xe8	/* set resolution (0..3) */
#define	PMS_GET_SCALE	0xe9	/* get scaling factor */
#define PMS_SEND_DEV_STATUS	0xe9
#define	PMS_SET_STREAM	0xea	/* set streaming mode */
#define PMS_SEND_DEV_DATA	0xeb
d17 4
a20 4
#define PMS_SEND_DEV_ID	0xf2
#define	PMS_SET_SAMPLE	0xf3	/* set sampling rate */
#define	PMS_DEV_ENABLE	0xf4	/* mouse on */
#define	PMS_DEV_DISABLE	0xf5	/* mouse off */
d22 101
a122 1
#define	PMS_RESET	0xff	/* reset */
d124 1
a124 1
#define	PMS_RSTDONE	0xaa
@

