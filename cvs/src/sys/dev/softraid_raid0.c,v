head	1.52;
access;
symbols
	OPENBSD_6_2:1.52.0.4
	OPENBSD_6_2_BASE:1.52
	OPENBSD_6_1:1.52.0.6
	OPENBSD_6_1_BASE:1.52
	OPENBSD_6_0:1.52.0.2
	OPENBSD_6_0_BASE:1.52
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.47.0.4
	OPENBSD_5_7_BASE:1.47
	OPENBSD_5_6:1.45.0.6
	OPENBSD_5_6_BASE:1.45
	OPENBSD_5_5:1.45.0.4
	OPENBSD_5_5_BASE:1.45
	OPENBSD_5_4:1.41.0.2
	OPENBSD_5_4_BASE:1.41
	OPENBSD_5_3:1.33.0.2
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.26.0.4
	OPENBSD_5_2_BASE:1.26
	OPENBSD_5_1_BASE:1.26
	OPENBSD_5_1:1.26.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.4
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.15.0.4
	OPENBSD_4_6_BASE:1.15
	OPENBSD_4_5:1.11.0.2
	OPENBSD_4_5_BASE:1.11
	OPENBSD_4_4:1.9.0.2
	OPENBSD_4_4_BASE:1.9
	OPENBSD_4_3:1.8.0.2
	OPENBSD_4_3_BASE:1.8;
locks; strict;
comment	@ * @;


1.52
date	2016.04.12.16.26.54;	author krw;	state Exp;
branches;
next	1.51;
commitid	ATfj2h1H9b585gss;

1.51
date	2016.04.04.18.48.39;	author krw;	state Exp;
branches;
next	1.50;
commitid	1ISokwrtQ24zRrhW;

1.50
date	2015.07.21.03.30.51;	author krw;	state Exp;
branches;
next	1.49;
commitid	TJiPw62Nfq0KhqBx;

1.49
date	2015.07.19.21.06.04;	author krw;	state Exp;
branches;
next	1.48;
commitid	DQBduvhX3UJc1lbB;

1.48
date	2015.07.19.17.04.31;	author krw;	state Exp;
branches;
next	1.47;
commitid	WthDQr0yYlXab4V8;

1.47
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.46;
commitid	Z1vcFtHO8wRH0yRt;

1.46
date	2014.09.14.14.17.24;	author jsg;	state Exp;
branches;
next	1.45;
commitid	uzzBR7hz9ncd4O6G;

1.45
date	2013.11.21.16.54.46;	author krw;	state Exp;
branches;
next	1.44;

1.44
date	2013.11.21.16.34.50;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2013.11.05.08.55.58;	author reyk;	state Exp;
branches;
next	1.42;

1.42
date	2013.11.01.17.36.19;	author krw;	state Exp;
branches;
next	1.41;

1.41
date	2013.06.11.16.42.13;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2013.05.21.15.01.53;	author jsing;	state Exp;
branches;
next	1.39;

1.39
date	2013.03.31.15.44.52;	author jsing;	state Exp;
branches;
next	1.38;

1.38
date	2013.03.31.11.12.06;	author jsing;	state Exp;
branches;
next	1.37;

1.37
date	2013.03.31.10.41.16;	author jsing;	state Exp;
branches;
next	1.36;

1.36
date	2013.03.30.02.02.14;	author jsing;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.02.12.50.01;	author jsing;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.02.12.25.55;	author jsing;	state Exp;
branches;
next	1.33;

1.33
date	2013.01.18.11.48.05;	author jsing;	state Exp;
branches;
next	1.32;

1.32
date	2013.01.18.06.49.16;	author jsing;	state Exp;
branches;
next	1.31;

1.31
date	2013.01.17.04.07.39;	author jsing;	state Exp;
branches;
next	1.30;

1.30
date	2013.01.16.06.42.22;	author jsing;	state Exp;
branches;
next	1.29;

1.29
date	2013.01.15.09.28.29;	author jsing;	state Exp;
branches;
next	1.28;

1.28
date	2013.01.15.04.03.01;	author jsing;	state Exp;
branches;
next	1.27;

1.27
date	2012.10.08.14.22.41;	author jsing;	state Exp;
branches;
next	1.26;

1.26
date	2012.01.22.11.13.32;	author jsing;	state Exp;
branches;
next	1.25;

1.25
date	2011.12.26.14.54.52;	author jsing;	state Exp;
branches;
next	1.24;

1.24
date	2011.12.25.15.28.17;	author jsing;	state Exp;
branches;
next	1.23;

1.23
date	2011.04.05.19.52.02;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.02.09.20.26;	author jsing;	state Exp;
branches;
next	1.21;

1.21
date	2010.07.01.19.31.04;	author thib;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.26.11.20.34;	author jsing;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2009.12.15.13.19.37;	author jsing;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.07.14.27.12;	author jsing;	state Exp;
branches;
next	1.16;

1.16
date	2009.08.09.14.12.25;	author marco;	state Exp;
branches;
next	1.15;

1.15
date	2009.06.02.21.23.11;	author marco;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.02.11.38.51;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2009.05.11.14.06.21;	author jsing;	state Exp;
branches;
next	1.12;

1.12
date	2009.04.28.02.54.53;	author marco;	state Exp;
branches;
next	1.11;

1.11
date	2008.11.25.23.05.17;	author marco;	state Exp;
branches;
next	1.10;

1.10
date	2008.10.04.19.21.00;	author miod;	state Exp;
branches;
next	1.9;

1.9
date	2008.07.19.22.41.58;	author marco;	state Exp;
branches;
next	1.8;

1.8
date	2008.02.05.16.49.25;	author marco;	state Exp;
branches;
next	1.7;

1.7
date	2008.02.05.16.15.35;	author marco;	state Exp;
branches;
next	1.6;

1.6
date	2008.01.26.19.23.07;	author marco;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.24.19.58.08;	author marco;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.24.17.50.17;	author marco;	state Exp;
branches;
next	1.3;

1.3
date	2008.01.24.14.01.06;	author marco;	state Exp;
branches;
next	1.2;

1.2
date	2008.01.24.13.58.14;	author marco;	state Exp;
branches;
next	1.1;

1.1
date	2008.01.19.23.53.53;	author marco;	state Exp;
branches;
next	;


desc
@@


1.52
log
@No need to rescan chunks in each discipline to find appropriate
volume sector size.  Determine volume sector size in sr_meta_init().

Pointed out, tweaked and ok jsing@@
@
text
@/* $OpenBSD: softraid_raid0.c,v 1.51 2016/04/04 18:48:39 krw Exp $ */
/*
 * Copyright (c) 2008 Marco Peereboom <marco@@peereboom.us>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bio.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/disk.h>
#include <sys/rwlock.h>
#include <sys/queue.h>
#include <sys/fcntl.h>
#include <sys/mount.h>
#include <sys/sensors.h>
#include <sys/stat.h>
#include <sys/conf.h>
#include <sys/uio.h>

#include <scsi/scsi_all.h>
#include <scsi/scsiconf.h>
#include <scsi/scsi_disk.h>

#include <dev/softraidvar.h>

/* RAID 0 functions. */
int	sr_raid0_create(struct sr_discipline *, struct bioc_createraid *,
	    int, int64_t);
int	sr_raid0_assemble(struct sr_discipline *, struct bioc_createraid *,
	    int, void *);
int	sr_raid0_init(struct sr_discipline *);
int	sr_raid0_rw(struct sr_workunit *);

/* Discipline initialisation. */
void
sr_raid0_discipline_init(struct sr_discipline *sd)
{

	/* Fill out discipline members. */
	sd->sd_type = SR_MD_RAID0;
	strlcpy(sd->sd_name, "RAID 0", sizeof(sd->sd_name));
	sd->sd_capabilities = SR_CAP_SYSTEM_DISK | SR_CAP_AUTO_ASSEMBLE;
	sd->sd_max_wu = SR_RAID0_NOWU;

	/* Setup discipline specific function pointers. */
	sd->sd_assemble = sr_raid0_assemble;
	sd->sd_create = sr_raid0_create;
	sd->sd_scsi_rw = sr_raid0_rw;
}

int
sr_raid0_create(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunk, int64_t coerced_size)
{
	if (no_chunk < 2) {
		sr_error(sd->sd_sc, "%s requires two or more chunks",
		    sd->sd_name);
		return EINVAL;
        }

	/*
	 * XXX add variable strip size later even though MAXPHYS is really
	 * the clever value, users like to tinker with that type of stuff.
	 */
	sd->sd_meta->ssdi.ssd_strip_size = MAXPHYS;
	sd->sd_meta->ssdi.ssd_size = (coerced_size &
	    ~(((u_int64_t)sd->sd_meta->ssdi.ssd_strip_size >>
	    DEV_BSHIFT) - 1)) * no_chunk;

	return sr_raid0_init(sd);
}

int
sr_raid0_assemble(struct sr_discipline *sd, struct bioc_createraid *bc,
    int no_chunks, void *data)
{
	return sr_raid0_init(sd);
}

int
sr_raid0_init(struct sr_discipline *sd)
{
	/* Initialise runtime values. */
	sd->mds.mdd_raid0.sr0_strip_bits =
	    sr_validate_stripsize(sd->sd_meta->ssdi.ssd_strip_size);
	if (sd->mds.mdd_raid0.sr0_strip_bits == -1) {
		sr_error(sd->sd_sc, "invalid strip size", sd->sd_name);
		return EINVAL;
	}
	sd->sd_max_ccb_per_wu =
	    (MAXPHYS / sd->sd_meta->ssdi.ssd_strip_size + 1) *
	    SR_RAID0_NOWU * sd->sd_meta->ssdi.ssd_chunk_no;

	return 0;
}

int
sr_raid0_rw(struct sr_workunit *wu)
{
	struct sr_discipline	*sd = wu->swu_dis;
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_ccb		*ccb;
	struct sr_chunk		*scp;
	daddr_t			blkno;
	int64_t			chunkoffs, lbaoffs, offset, stripoffs;
	int64_t			strip_bits, strip_no, strip_size;
	int64_t			chunk, no_chunk;
	int64_t			length, leftover;
	u_int8_t		*data;

	/* blkno and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blkno, "sr_raid0_rw"))
		goto bad;

	strip_size = sd->sd_meta->ssdi.ssd_strip_size;
	strip_bits = sd->mds.mdd_raid0.sr0_strip_bits;
	no_chunk = sd->sd_meta->ssdi.ssd_chunk_no;

	DNPRINTF(SR_D_DIS, "%s: %s: front end io: blkno %lld size %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    (long long)blkno, xs->datalen);

	/* all offs are in bytes */
	lbaoffs = blkno << DEV_BSHIFT;
	strip_no = lbaoffs >> strip_bits;
	chunk = strip_no % no_chunk;
	stripoffs = lbaoffs & (strip_size - 1);
	chunkoffs = (strip_no / no_chunk) << strip_bits;
	offset = chunkoffs + stripoffs;
	length = MIN(xs->datalen, strip_size - stripoffs);
	leftover = xs->datalen;
	data = xs->data;
	for (;;) {
		/* make sure chunk is online */
		scp = sd->sd_vol.sv_chunks[chunk];
		if (scp->src_meta.scm_status != BIOC_SDONLINE)
			goto bad;

		DNPRINTF(SR_D_DIS, "%s: %s %s io lbaoffs %lld "
		    "strip_no %lld chunk %lld stripoffs %lld "
		    "chunkoffs %lld offset %lld length %lld "
		    "leftover %lld data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name,
		    lbaoffs, strip_no, chunk, stripoffs, chunkoffs, offset,
		    length, leftover, data);

		blkno = offset >> DEV_BSHIFT;
		ccb = sr_ccb_rw(sd, chunk, blkno, length, data, xs->flags, 0);
		if (!ccb) {
			/* should never happen but handle more gracefully */
			printf("%s: %s: too many ccbs queued\n",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname);
			goto bad;
		}
		sr_wu_enqueue_ccb(wu, ccb);

		leftover -= length;
		if (leftover == 0)
			break;

		data += length;
		if (++chunk > no_chunk - 1) {
			chunk = 0;
			offset += length;
		} else if (wu->swu_io_count == 1)
			offset -= stripoffs;
		length = MIN(leftover,strip_size);
	}

	sr_schedule_wu(wu);

	return (0);

bad:
	/* wu is unwound by sr_wu_put */
	return (1);
}
@


1.51
log
@Enable creation of softraid volumes using disks with non-512 byte
sectors. Volumes created will present a sector size equal to the
largest sector size of the constituent disks.

Softraid Metadata version cranks to 6 due to new field.

ok jsing@@ with tweaks that will follow soon.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.50 2015/07/21 03:30:51 krw Exp $ */
a71 3
	int i;
	u_int32_t secsize;

a76 7

	secsize = 0;
	for (i = 0; i < no_chunk; i++) {
		if (sd->sd_vol.sv_chunks[i]->src_secsize > secsize)
			secsize = sd->sd_vol.sv_chunks[i]->src_secsize;
	}
	sd->sd_meta->ssdi.ssd_secsize = secsize;
@


1.50
log
@A few more daddr_t fixes. Rename 'phys_off' variables to 'offset'
since they are now relative to chunks. Use 'blkno' as normal variable
name for daddr_t items rather than mix of 'blkno, blk, offset.
Change field name ssd_data_offset to ssd_data_blkno since it is a
block and not byte quantity.

No intentional functional change.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.49 2015/07/19 21:06:04 krw Exp $ */
d72 3
d80 7
@


1.49
log
@Remove unneeded #include <disklabel.h>.

ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.48 2015/07/19 17:04:31 krw Exp $ */
d121 2
a122 2
	daddr_t			blk;
	int64_t			chunkoffs, lbaoffs, physoffs, stripoffs;
d128 2
a129 2
	/* blk and scsi error will be handled by sr_validate_io */
	if (sr_validate_io(wu, &blk, "sr_raid0_rw"))
d136 1
a136 1
	DNPRINTF(SR_D_DIS, "%s: %s: front end io: lba %lld size %d\n",
d138 1
a138 1
	    (long long)blk, xs->datalen);
d141 1
a141 1
	lbaoffs = blk << DEV_BSHIFT;
d146 1
a146 1
	physoffs = chunkoffs + stripoffs;
d158 1
a158 1
		    "chunkoffs %lld physoffs %lld length %lld "
d161 1
a161 1
		    lbaoffs, strip_no, chunk, stripoffs, chunkoffs, physoffs,
d164 2
a165 2
		blk = physoffs >> DEV_BSHIFT;
		ccb = sr_ccb_rw(sd, chunk, blk, length, data, xs->flags, 0);
d182 1
a182 1
			physoffs += length;
d184 1
a184 1
			physoffs -= stripoffs;
@


1.48
log
@Stop adding and subtracting data offset. Just keep to chunk relative
block offsets until actual i/o is constructed and needs the physical
offset. Eliminate a number of <<DEV_BSIZE shifts as a bonus.

No intentional functional change.

Fixed and ok jsing@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.47 2014/11/18 02:37:30 tedu Exp $ */
a30 1
#include <sys/disklabel.h>
@


1.47
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.46 2014/09/14 14:17:24 jsg Exp $ */
d147 1
a147 2
	physoffs = chunkoffs + stripoffs +
	    (sd->sd_meta->ssd_data_offset << DEV_BSHIFT);
@


1.46
log
@remove uneeded proc.h includes
ok mpi@@ kspillner@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.45 2013/11/21 16:54:46 krw Exp $ */
a42 1
#include <dev/rndvar.h>
@


1.45
log
@Don't cast int64_t variables to (long long) when using %lld.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.44 2013/11/21 16:34:50 krw Exp $ */
a24 1
#include <sys/proc.h>
@


1.44
log
@Change a bunch of daddr_t variables that don't (obviously) contain
512-byte-block information to int64_t, the underlying type of
daddr_t at the moment. No change to .o files. Removal of now
unneeded (long long) casts is next.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.43 2013/11/05 08:55:58 reyk Exp $ */
d165 2
a166 4
		    (long long)lbaoffs, (long long)strip_no, (long long)chunk,
		    (long long)stripoffs, (long long)chunkoffs,
		    (long long)physoffs, (long long)length, (long long)leftover,
		    data);
@


1.43
log
@Fix RAID levels 0, 4, 5, and 6 with partitions larger than 2TB.

A 64bit bit operation with the 32bit strip size could overflow and
result in ridiculously small volumes when using large partitions (eg.
4x 3TB in RAID 5 resulted in a ~2TB volume).  It is fixed by casting
the strip size to an unsigned 64bit value.

ok tedu@@ millert@@ deraadt@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.42 2013/11/01 17:36:19 krw Exp $ */
d124 5
a128 3
	daddr_t			blk, lbaoffs, strip_no, chunk, stripoffs;
	daddr_t			strip_size, no_chunk, chunkoffs, physoffs;
	daddr_t			strip_bits, length, leftover;
@


1.42
log
@Sprinkle (long long) casts where %lld is being used to print daddr_t
variables. Some random whitespace/knf repairs encountered on the way.

ok miod@@ on inspection, feedback & more suggestions from millert@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.41 2013/06/11 16:42:13 deraadt Exp $ */
d87 2
a88 1
	    ~((sd->sd_meta->ssdi.ssd_strip_size >> DEV_BSHIFT) - 1)) * no_chunk;
@


1.41
log
@final removal of daddr64_t.  daddr_t has been 64 bit for a long enough
test period; i think 3 years ago the last bugs fell out.
ok otto beck others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.40 2013/05/21 15:01:53 jsing Exp $ */
d138 1
a138 1
	    blk, xs->datalen);
d162 4
a165 2
		    lbaoffs, strip_no, chunk, stripoffs, chunkoffs, physoffs,
		    length, leftover, data);
@


1.40
log
@Provide a function that handles the scheduling of work units. This
simplifies the discipline code, avoids code duplication and moves the
scheduling logic into a single location.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.39 2013/03/31 15:44:52 jsing Exp $ */
d123 3
a125 3
	daddr64_t		blk, lbaoffs, strip_no, chunk, stripoffs;
	daddr64_t		strip_size, no_chunk, chunkoffs, physoffs;
	daddr64_t		strip_bits, length, leftover;
@


1.39
log
@Use consistent error handling when validating the number of chunks
provided.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.38 2013/03/31 11:12:06 jsing Exp $ */
a122 1
	int			s;
d189 1
a189 1
	s = splbio();
d191 1
a191 2
	if (sr_check_io_collision(wu))
		goto queued;
a192 4
	sr_raid_startwu(wu);
queued:
	splx(s);
	return (0);
@


1.38
log
@Provide default resource allocation and free functions. Convert all
disciplines except for AOE and CRYPTO, which require custom handlers.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.37 2013/03/31 10:41:16 jsing Exp $ */
d76 2
a77 1
		sr_error(sd->sd_sc, "RAID 0 requires two or more chunks");
@


1.37
log
@Pull the initialisation of runtime values out into a separate init
function, rather than having it spread across create/assemble/alloc.
Also handle strip size errors appropriately, rather than failing silently.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.36 2013/03/30 02:02:14 jsing Exp $ */
a51 2
int	sr_raid0_alloc_resources(struct sr_discipline *);
int	sr_raid0_free_resources(struct sr_discipline *);
a65 1
	sd->sd_alloc_resources = sr_raid0_alloc_resources;
a67 1
	sd->sd_free_resources = sr_raid0_free_resources;
a112 33
}

int
sr_raid0_alloc_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raid0_alloc_resources\n",
	    DEVNAME(sd->sd_sc));

	if (sr_wu_alloc(sd))
		goto bad;
	if (sr_ccb_alloc(sd))
		goto bad;

	rv = 0;
bad:
	return (rv);
}

int
sr_raid0_free_resources(struct sr_discipline *sd)
{
	int			rv = EINVAL;

	DNPRINTF(SR_D_DIS, "%s: sr_raid0_free_resources\n",
	    DEVNAME(sd->sd_sc));

	sr_wu_free(sd);
	sr_ccb_free(sd);

	rv = 0;
	return (rv);
@


1.36
log
@Provide a default discipline interrupt handling function and migrate all of
the disciplines that now have the same interrupt code.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.35 2013/03/02 12:50:01 jsing Exp $ */
d51 1
d92 1
a92 5
	sd->sd_max_ccb_per_wu =
	    (MAXPHYS / sd->sd_meta->ssdi.ssd_strip_size + 1) *
	    SR_RAID0_NOWU * no_chunk;

	return 0;
d99 2
d102 10
a129 6
		goto bad;

	/* setup runtime values */
	sd->mds.mdd_raid0.sr0_strip_bits =
	    sr_validate_stripsize(sd->sd_meta->ssdi.ssd_strip_size);
	if (sd->mds.mdd_raid0.sr0_strip_bits == -1)
@


1.35
log
@sr_alloc_resources() and sr_free_resources() can never be called without
a valid struct sr_discipline. Remove redundant NULL pointer checks.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.34 2013/03/02 12:25:55 jsing Exp $ */
a53 1
void	sr_raid0_intr(struct buf *);
a71 1
	sd->sd_scsi_intr = sr_raid0_intr;
a234 20
}

void
sr_raid0_intr(struct buf *bp)
{
	struct sr_ccb		*ccb = (struct sr_ccb *)bp;
	struct sr_workunit	*wu = ccb->ccb_wu;
#ifdef SR_DEBUG
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_discipline	*sd = wu->swu_dis;
#endif
	int			s;

	DNPRINTF(SR_D_INTR, "%s: %s %s intr bp %x xs %x\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, sd->sd_name, bp, xs);

	s = splbio();
	sr_ccb_done(ccb);
	sr_wu_done(wu);
	splx(s);
@


1.34
log
@Unbreak softraid compilation with debug enabled.

Prompted by Dmitry Bogdan.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.33 2013/01/18 11:48:05 jsing Exp $ */
a116 3
	if (!sd)
		return (rv);

a139 3

	if (!sd)
		return (rv);
@


1.33
log
@Convert softraid RAID 0 to new workunit completion functions
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.32 2013/01/18 06:49:16 jsing Exp $ */
d257 1
a257 1
	    DEVNAME(sd->sd_sc), sd->sd_meta.ssd_name, sd->sd_name, bp, xs);
@


1.32
log
@Clean up and rework workunit completion for RAID 0. Ensure that we remove
the workunit from the pending queue and restart deferred workunits, even
in error conditions.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.31 2013/01/17 04:07:39 jsing Exp $ */
d249 3
a251 1
	struct sr_workunit	*wu = ccb->ccb_wu, *wup;
d253 1
a253 2
	struct scsi_xfer	*xs = wu->swu_xs;
	struct sr_softc		*sc = sd->sd_sc;
d257 1
a257 1
	    DEVNAME(sc), sd->sd_meta.ssd_name, sd->sd_name, bp, xs);
a259 1

d261 1
a261 35

	DNPRINTF(SR_D_INTR, "%s: sr_intr: comp: %d count: %d failed: %d\n",
	    DEVNAME(sc), wu->swu_ios_complete, wu->swu_io_count,
	    wu->swu_ios_failed);

	if (wu->swu_ios_complete >= wu->swu_io_count) {
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link)
			if (wup == wu)
				break;

		if (wup == NULL)
			panic("%s: wu %p not on pending queue",
			    DEVNAME(sc), wu);

		TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);

		if (wu->swu_collider) {
			/* restart deferred wu */
			wu->swu_collider->swu_state = SR_WU_INPROGRESS;
			TAILQ_REMOVE(&sd->sd_wu_defq,
			    wu->swu_collider, swu_link);
			sr_raid_startwu(wu->swu_collider);
		}

		if (wu->swu_ios_failed)
			xs->error = XS_DRIVER_STUFFUP;
		else
			xs->error = XS_NOERROR;

		sr_scsi_done(sd, xs);

		if (sd->sd_sync && sd->sd_wu_pending == 0)
			wakeup(sd);
	}

@


1.31
log
@Convert softraid RAID 0 to the new ccb functions.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.30 2013/01/16 06:42:22 jsing Exp $ */
d253 1
a253 1
	int			s, pend;
d255 2
a256 2
	DNPRINTF(SR_D_INTR, "%s: sr_intr bp %x xs %x\n",
	    DEVNAME(sc), bp, xs);
d267 7
a273 2
		if (wu->swu_ios_failed)
			goto bad;
d275 1
a275 1
		xs->error = XS_NOERROR;
d277 6
a282 17
		pend = 0;
		TAILQ_FOREACH(wup, &sd->sd_wu_pendq, swu_link) {
			if (wu == wup) {
				/* wu on pendq, remove */
				TAILQ_REMOVE(&sd->sd_wu_pendq, wu, swu_link);
				pend = 1;

				if (wu->swu_collider) {
					/* restart deferred wu */
					wu->swu_collider->swu_state =
					    SR_WU_INPROGRESS;
					TAILQ_REMOVE(&sd->sd_wu_defq,
					    wu->swu_collider, swu_link);
					sr_raid_startwu(wu->swu_collider);
				}
				break;
			}
d285 4
a288 3
		if (!pend)
			printf("%s: wu: %p not on pending queue\n",
			    DEVNAME(sc), wu);
a295 5
	splx(s);
	return;
bad:
	xs->error = XS_DRIVER_STUFFUP;
	sr_scsi_done(sd, xs);
@


1.30
log
@Set resid to zero if the scsi transfer completed without error.

ok krw@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.29 2013/01/15 09:28:29 jsing Exp $ */
d193 1
a193 1
	for (wu->swu_io_count = 1;; wu->swu_io_count++) {
d196 1
a196 1
		if (scp->src_meta.scm_status != BIOC_SDONLINE) {
a197 1
		}
d199 10
a208 1
		ccb = sr_ccb_get(sd);
d216 1
a216 35

		DNPRINTF(SR_D_DIS, "%s: %s raid io: lbaoffs: %lld "
		    "strip_no: %lld chunk: %lld stripoffs: %lld "
		    "chunkoffs: %lld physoffs: %lld length: %lld "
		    "leftover: %lld data: %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname, lbaoffs,
		    strip_no, chunk, stripoffs, chunkoffs, physoffs, length,
		    leftover, data);

		ccb->ccb_buf.b_flags = B_CALL | B_PHYS;
		ccb->ccb_buf.b_iodone = sr_raid0_intr;
		ccb->ccb_buf.b_blkno = physoffs >> DEV_BSHIFT;
		ccb->ccb_buf.b_bcount = length;
		ccb->ccb_buf.b_bufsize = length;
		ccb->ccb_buf.b_resid = length;
		ccb->ccb_buf.b_data = data;
		ccb->ccb_buf.b_error = 0;
		ccb->ccb_buf.b_proc = curproc;
		ccb->ccb_buf.b_bq = NULL;
		ccb->ccb_wu = wu;
		ccb->ccb_buf.b_flags |= xs->flags & SCSI_DATA_IN ?
		    B_READ : B_WRITE;
		ccb->ccb_target = chunk;
		ccb->ccb_buf.b_dev = sd->sd_vol.sv_chunks[chunk]->src_dev_mm;
		ccb->ccb_buf.b_vp = sd->sd_vol.sv_chunks[chunk]->src_vn;
		if ((ccb->ccb_buf.b_flags & B_READ) == 0)
			ccb->ccb_buf.b_vp->v_numoutput++;
		LIST_INIT(&ccb->ccb_buf.b_dep);
		TAILQ_INSERT_TAIL(&wu->swu_ccb, ccb, ccb_link);

		DNPRINTF(SR_D_DIS, "%s: %s: sr_raid0: b_bcount: %d "
		    "b_blkno: %lld b_flags 0x%0x b_data %p\n",
		    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
		    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_blkno,
		    ccb->ccb_buf.b_flags, ccb->ccb_buf.b_data);
a257 5
	DNPRINTF(SR_D_INTR, "%s: sr_intr: b_bcount: %d b_resid: %d"
	    " b_flags: 0x%0x block: %lld target: %d\n", DEVNAME(sc),
	    ccb->ccb_buf.b_bcount, ccb->ccb_buf.b_resid, ccb->ccb_buf.b_flags,
	    ccb->ccb_buf.b_blkno, ccb->ccb_target);

d260 1
a260 18
	if (ccb->ccb_buf.b_flags & B_ERROR) {
		printf("%s: i/o error on block %lld target: %d b_error: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target,
		    ccb->ccb_buf.b_error);
		DNPRINTF(SR_D_INTR, "%s: i/o error on block %lld target: %d\n",
		    DEVNAME(sc), ccb->ccb_buf.b_blkno, ccb->ccb_target);
		wu->swu_ios_failed++;
		ccb->ccb_state = SR_CCB_FAILED;
		if (ccb->ccb_target != -1)
			sd->sd_set_chunk_state(sd, ccb->ccb_target,
			    BIOC_SDOFFLINE);
		else
			panic("%s: invalid target on wu: %p", DEVNAME(sc), wu);
	} else {
		ccb->ccb_state = SR_CCB_OK;
		wu->swu_ios_succeeded++;
	}
	wu->swu_ios_complete++;
@


1.29
log
@Always initialise the discipline name, not just when we are doing a create.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.28 2013/01/15 04:03:01 jsing Exp $ */
a318 1
		xs->resid = 0;
@


1.28
log
@Keep a function pointer to the per-discipline I/O interrupt handler in the
discipline data structure. To be used with an upcoming diff.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.27 2012/10/08 14:22:41 jsing Exp $ */
d63 1
a88 1
	strlcpy(sd->sd_name, "RAID 0", sizeof(sd->sd_name));
@


1.27
log
@Provide a mechanism for the kernel to pass data through to the discipline
during volume assembly.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.25 2011/12/26 14:54:52 jsing Exp $ */
d72 1
@


1.26
log
@Convert softraid(4) to new bio(4) status interface. This allows bioctl(8)
to provide useful feedback, rather than reporting an ioctl failure and
leaving the user to consult dmesg. For now we continue to print most things
to the console, even if the message is a result of an ioctl.
@
text
@d50 1
a50 1
	    int);
d101 1
a101 1
    int no_chunks)
@


1.25
log
@Provide default set chunk state and set volume state functions which
cover the no redundancy/no rebuild case. Use these for the AOE, crypto and
RAID 0 disciplines.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.24 2011/12/25 15:28:17 jsing Exp $ */
d78 2
a79 2

	if (no_chunk < 2)
d81 1
@


1.24
log
@Initialise discipline function pointers with defaults and only override
those that are needed by a specific discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.22 2010/07/02 09:20:26 jsing Exp $ */
a54 2
void	sr_raid0_set_chunk_state(struct sr_discipline *, int, int);
void	sr_raid0_set_vol_state(struct sr_discipline *);
a71 2
	sd->sd_set_chunk_state = sr_raid0_set_chunk_state;
	sd->sd_set_vol_state = sr_raid0_set_vol_state;
a152 106
}

void
sr_raid0_set_chunk_state(struct sr_discipline *sd, int c, int new_state)
{
	int			old_state, s;

	DNPRINTF(SR_D_STATE, "%s: %s: %s: sr_raid_set_chunk_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname, c, new_state);

	/* ok to go to splbio since this only happens in error path */
	s = splbio();
	old_state = sd->sd_vol.sv_chunks[c]->src_meta.scm_status;

	/* multiple IOs to the same chunk that fail will come through here */
	if (old_state == new_state)
		goto done;

	switch (old_state) {
	case BIOC_SDONLINE:
		if (new_state == BIOC_SDOFFLINE)
			break;
		else
			goto die;
		break;

	case BIOC_SDOFFLINE:
		goto die;

	default:
die:
		splx(s); /* XXX */
		panic("%s: %s: %s: invalid chunk state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scmi.scm_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol.sv_chunks[c]->src_meta.scm_status = new_state;
	sd->sd_set_vol_state(sd);

	sd->sd_must_flush = 1;
	workq_add_task(NULL, 0, sr_meta_save_callback, sd, NULL);
done:
	splx(s);
}

void
sr_raid0_set_vol_state(struct sr_discipline *sd)
{
	int			states[SR_MAX_STATES];
	int			new_state, i, s, nd;
	int			old_state = sd->sd_vol_status;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname);

	nd = sd->sd_meta->ssdi.ssd_chunk_no;

	for (i = 0; i < SR_MAX_STATES; i++)
		states[i] = 0;

	for (i = 0; i < nd; i++) {
		s = sd->sd_vol.sv_chunks[i]->src_meta.scm_status;
		if (s >= SR_MAX_STATES)
			panic("%s: %s: %s: invalid chunk state",
			    DEVNAME(sd->sd_sc),
			    sd->sd_meta->ssd_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scmi.scm_devname);
		states[s]++;
	}

	if (states[BIOC_SDONLINE] == nd)
		new_state = BIOC_SVONLINE;
	else 
		new_state = BIOC_SVOFFLINE;

	DNPRINTF(SR_D_STATE, "%s: %s: sr_raid_set_vol_state %d -> %d\n",
	    DEVNAME(sd->sd_sc), sd->sd_meta->ssd_devname,
	    old_state, new_state);

	switch (old_state) {
	case BIOC_SVONLINE:
		if (new_state == BIOC_SVOFFLINE || new_state == BIOC_SVONLINE)
			break;
		else
			goto die;
		break;

	case BIOC_SVOFFLINE:
		/* XXX this might be a little too much */
		goto die;

	default:
die:
		panic("%s: %s: invalid volume state transition "
		    "%d -> %d\n", DEVNAME(sd->sd_sc),
		    sd->sd_meta->ssd_devname,
		    old_state, new_state);
		/* NOTREACHED */
	}

	sd->sd_vol_status = new_state;
@


1.23
log
@Iopoolification. Testing by marco@@.

ok dlg@@ marco@@
@
text
@d68 3
a70 1
	/* Setup discipline pointers. */
a71 2
	sd->sd_assemble = sr_raid0_assemble;
	sd->sd_alloc_resources = sr_raid0_alloc_resources;
a72 7
	sd->sd_start_discipline = NULL;
	sd->sd_scsi_inquiry = sr_raid_inquiry;
	sd->sd_scsi_read_cap = sr_raid_read_cap;
	sd->sd_scsi_tur = sr_raid_tur;
	sd->sd_scsi_req_sense = sr_raid_request_sense;
	sd->sd_scsi_start_stop = sr_raid_start_stop;
	sd->sd_scsi_sync = sr_raid_sync;
@


1.22
log
@Determine the data offset using a variable specified within the softraid
metadata. This allows us to implement seamless transitions from the
previous metadata version to the current version, avoiding the need to
recreate the softraid volume.

Joint work with marco@@ during c2k10.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.20 2010/03/26 11:20:34 jsing Exp $ */
a458 2
		/* do not change the order of these 2 functions */
		sr_wu_put(wu);
a468 1
	sr_wu_put(wu);
@


1.21
log
@make sure that buf's on the stack set the b_bq to NULL.
one memset -> bzero.

ok marco@@, jsing@@
@
text
@d303 2
a304 1
	physoffs = chunkoffs + stripoffs + (SR_DATA_OFFSET << DEV_BSHIFT);
@


1.20
log
@Add storage for the boot block and boot loader to the softraid metadata.
Also add a new optional metadata type for boot data. This is the first
step (of many) towards being able to boot from softraid volumes.

WARNING: This version of the softraid metadata is not compatible with
previous versions. As a result, any softraid volumes created with older
kernels will not assemble. Data on existing softraid volumes should be
backed up before upgrading. The volume should then be recreated and the
data restored.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.18 2009/12/15 13:19:37 jsing Exp $ */
d340 1
@


1.19
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d303 1
a303 2
	physoffs = chunkoffs + stripoffs +
	    ((SR_META_OFFSET + SR_META_SIZE) << DEV_BSHIFT);
@


1.18
log
@Factor out discipline specific create/assemble code.

"in, in, in!" marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.15 2009/06/02 21:23:11 marco Exp $ */
a433 1
		xs->flags |= ITSDONE;
a469 1
	xs->flags |= ITSDONE;
@


1.17
log
@Define discipline capabilities using a set of flags.

"shiny!!" marco@@
@
text
@d47 4
a65 3
	sd->sd_max_ccb_per_wu =
	    (MAXPHYS / sd->sd_meta->ssdi.ssd_strip_size + 1) *
	    SR_RAID0_NOWU * sd->sd_meta->ssdi.ssd_chunk_no;
d69 2
d83 36
@


1.16
log
@Switch softraid to vnodes to prevent bad things from happening when using
d_open/d_close.

tested by many, ok jsing, thib, krw
@
text
@d61 1
@


1.15
log
@Abuse bio layer a little less by marking fake buffers with B_PHYS.
From beck with lots of squealing and ear bleeds.
Issue originally reported by todd.

ok beck
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.14 2009/06/02 11:38:51 deraadt Exp $ */
d306 3
a308 1
		ccb->ccb_buf.b_vp = NULL;
@


1.14
log
@marco needs to learn how to do his range checks better, found by Parfait
ok oga guenther
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.13 2009/05/11 14:06:21 jsing Exp $ */
d292 1
a292 1
		ccb->ccb_buf.b_flags = B_CALL;
@


1.13
log
@Move the discipline initialisation code into discipline specific functions,
rather than initialising everything in softraid.c. This makes a discipline
more self-contained and reduces the number of function declarations needed
in softraidvar.h.

ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.11 2008/11/25 23:05:17 marco Exp $ */
d191 1
a191 1
		if (s > SR_MAX_STATES)
@


1.12
log
@Part one of partial bringup volumes.  Plenty of rope to kill your data
use with caution...
@
text
@d46 35
a80 1
/* RAID 0 functions */
@


1.11
log
@Add generic sr_scsi_done function that does the spl dance
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.10 2008/10/04 19:21:00 miod Exp $ */
d176 1
a176 1
		if (new_state == BIOC_SVOFFLINE)
@


1.10
log
@Remove bogus code from the error path in sr_raid0_rw(); ok marco@@
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.9 2008/07/19 22:41:58 marco Exp $ */
d385 1
a385 1
		scsi_done(xs);
d397 1
a397 1
	scsi_done(xs);
@


1.9
log
@Full rewrite of metadata handling.  This fixes power failures and crashes
that caused illegal checksums.  The new metadata code is more or less ready
to deal with other vendor's metadata formats.

While here clean up the name space.

Fix thib's pool mess by adding removing bad flags in interrupt context.

tested on macppc, amd64, i386, sparc64 & hppa

sparc64 has issues with crypto however those do not seem to be softraid
specific.

help from okan@@ ckuethe@@ Will Backman and others
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.8 2008/02/05 16:49:25 marco Exp $ */
a237 1
			sr_ccb_put(ccb);
@


1.8
log
@Shave off a few more bytes by moving IO collision detection into a generic
fucntion.  Fix bug in the crypto code that could casuse data corruption as
a bonus, bad cut & past tedu!
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.7 2008/02/05 16:15:35 marco Exp $ */
d58 1
a58 1
	if (sr_alloc_wu(sd))
d60 1
a60 1
	if (sr_alloc_ccb(sd))
d65 1
a65 1
	    sr_validate_stripsize(sd->sd_vol.sv_meta.svm_strip_size);
d85 2
a86 5
	sr_free_wu(sd);
	sr_free_ccb(sd);

	if (sd->sd_meta)
		free(sd->sd_meta, M_DEVBUF);
d98 2
a99 2
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
	    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname, c, new_state);
d125 2
a126 2
		    sd->sd_vol.sv_meta.svm_devname,
		    sd->sd_vol.sv_chunks[c]->src_meta.scm_devname,
d135 1
a135 1
	workq_add_task(NULL, 0, sr_save_metadata_callback, sd, NULL);
d145 1
a145 1
	int			old_state = sd->sd_vol.sv_meta.svm_status;
d148 1
a148 1
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
d150 1
a150 1
	nd = sd->sd_vol.sv_meta.svm_no_chunk;
d160 2
a161 2
			    sd->sd_vol.sv_meta.svm_devname,
			    sd->sd_vol.sv_chunks[i]->src_meta.scm_devname);
d171 1
a171 1
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d190 1
a190 1
		    sd->sd_vol.sv_meta.svm_devname,
d195 1
a195 1
	sd->sd_vol.sv_meta.svm_status = new_state;
d215 1
a215 1
	strip_size = sd->sd_vol.sv_meta.svm_strip_size;
d217 1
a217 1
	no_chunk = sd->sd_vol.sv_meta.svm_no_chunk;
d220 1
a220 1
	    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d238 1
a238 1
			sr_put_ccb(ccb);
d242 1
a242 1
		ccb = sr_get_ccb(sd);
d247 1
a247 1
			    sd->sd_vol.sv_meta.svm_devname);
d255 1
a255 1
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname, lbaoffs,
d279 1
a279 1
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname,
d306 1
a306 1
	/* wu is unwound by sr_put_wu */
d385 1
a385 1
		sr_put_wu(wu);
d397 1
a397 1
	sr_put_wu(wu);
@


1.7
log
@Create a generic function to validate IO instead of copying and pasting
same code in all disciplines.  This shaves of a few bytes.

crypto 3185 -> 2690
raid 0 2843 -> 2378
raid 1 3474 -> 2689
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.6 2008/01/26 19:23:07 marco Exp $ */
a205 1
	struct sr_workunit	*wup;
d301 1
a301 16
	/* walk queue backwards and fill in collider if we have one */
	TAILQ_FOREACH_REVERSE(wup, &sd->sd_wu_pendq, sr_wu_list, swu_link) {
		if (wu->swu_blk_end < wup->swu_blk_start ||
		    wup->swu_blk_end < wu->swu_blk_start)
			continue;

		/* we have an LBA collision, defer wu */
		wu->swu_state = SR_WU_DEFERRED;
		if (wup->swu_collider)
			/* wu is on deferred queue, append to last wu */
			while (wup->swu_collider)
				wup = wup->swu_collider;

		wup->swu_collider = wu;
		TAILQ_INSERT_TAIL(&sd->sd_wu_defq, wu, swu_link);
		sd->sd_wu_collisions++;
d303 1
a303 1
	}
@


1.6
log
@Fix some debug prints
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.5 2008/01/24 19:58:08 marco Exp $ */
d215 2
a216 42
	DNPRINTF(SR_D_DIS, "%s: sr_raid0_rw 0x%02x\n", DEVNAME(sd->sd_sc),
	    xs->cmd->opcode);

	if (sd->sd_vol.sv_meta.svm_status == BIOC_SVOFFLINE) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid0_rw device offline\n",
		    DEVNAME(sd->sd_sc));
		goto bad;
	}

	if (xs->datalen == 0) {
		printf("%s: %s: illegal block count\n",
		    DEVNAME(sd->sd_sc), sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	if (xs->cmdlen == 10)
		blk = _4btol(((struct scsi_rw_big *)xs->cmd)->addr);
	else if (xs->cmdlen == 16)
		blk = _8btol(((struct scsi_rw_16 *)xs->cmd)->addr);
	else if (xs->cmdlen == 6)
		blk = _3btol(((struct scsi_rw *)xs->cmd)->addr);
	else {
		printf("%s: %s: illegal cmdlen\n", DEVNAME(sd->sd_sc),
		    sd->sd_vol.sv_meta.svm_devname);
		goto bad;
	}

	wu->swu_blk_start = blk;
	wu->swu_blk_end = blk + (xs->datalen >> DEV_BSHIFT) - 1;

	if (wu->swu_blk_end > sd->sd_vol.sv_meta.svm_size) {
		DNPRINTF(SR_D_DIS, "%s: sr_raid0_rw out of bounds start: %lld "
		    "end: %lld length: %d\n",
		    DEVNAME(sd->sd_sc), wu->swu_blk_start, wu->swu_blk_end,
		    xs->datalen);

		sd->sd_scsi_sense.error_code = SSD_ERRCODE_CURRENT |
		    SSD_ERRCODE_VALID;
		sd->sd_scsi_sense.flags = SKEY_ILLEGAL_REQUEST;
		sd->sd_scsi_sense.add_sense_code = 0x21;
		sd->sd_scsi_sense.add_sense_code_qual = 0x00;
		sd->sd_scsi_sense.extra_len = 4;
a217 1
	}
@


1.5
log
@Create chunk and state transition functions for RAID 0.
Move RAID 1 chunk and state transition functions into proper file.
Let Crypto use RAID 1 chunk and state transition functions for now but this
needs fixing.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.4 2008/01/24 17:50:17 marco Exp $ */
d247 3
a249 2
		    "end: %lld length: %d\n", wu->swu_blk_start,
		    wu->swu_blk_end, xs->datalen);
d265 2
a266 1
	    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname, blk, xs->datalen);
d300 1
a300 1
		    DEVNAME(sc), sd->sd_vol.sv_meta.svm_devname, lbaoffs,
@


1.4
log
@Bring softraid into the world of 16 byte commands; this allows for > 2TB disks
Fix bioctl size output which was off by *512; diagnosed by otto
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.3 2008/01/24 14:01:06 marco Exp $ */
d93 106
@


1.3
log
@Oops, make fit in 80 cols.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.2 2008/01/24 13:58:14 marco Exp $ */
d126 2
@


1.2
log
@Add IO path to RAID 0 discipline.
@
text
@d1 1
a1 1
/* $OpenBSD: softraid_raid0.c,v 1.1 2008/01/19 23:53:53 marco Exp $ */
d104 3
a106 2
	daddr64_t		blk, lbaoffs, strip_no, chunk, stripoffs, strip_bits;
	daddr64_t		strip_size, no_chunk, chunkoffs, physoffs, length, leftover;
@


1.1
log
@Add initial scaffold for RAID 0.  No IO just yet.

Much prodding todd
@
text
@d1 1
a1 1
/* $OpenBSD$ */
d64 1
a64 1
	sd->mds.mdd_raid0.sr0_stripbits =
d66 1
a66 1
	if (sd->mds.mdd_raid0.sr0_stripbits == -1)
d101 2
d104 3
a106 1
	daddr64_t		blk;
a110 3
	/* XXX don't do io yet */
	goto bad;

d134 1
a134 1
	wu->swu_blk_end = blk + (xs->datalen >> 9) - 1;
d150 80
a229 2
	/* calculate physical block */
	blk += SR_META_SIZE + SR_META_OFFSET;
a231 2
	/* generate ios */

a249 2

/* start: */
d263 1
a263 1
	struct sr_workunit	*wu = ccb->ccb_wu;
d267 1
a267 1
	int			s;
d280 3
d302 42
a343 1
/* bad: */
@

