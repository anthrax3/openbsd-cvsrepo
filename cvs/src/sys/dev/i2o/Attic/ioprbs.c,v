head	1.32;
access;
symbols
	OPENBSD_5_4:1.31.0.10
	OPENBSD_5_4_BASE:1.31
	OPENBSD_5_3:1.31.0.8
	OPENBSD_5_3_BASE:1.31
	OPENBSD_5_2:1.31.0.6
	OPENBSD_5_2_BASE:1.31
	OPENBSD_5_1_BASE:1.31
	OPENBSD_5_1:1.31.0.4
	OPENBSD_5_0:1.31.0.2
	OPENBSD_5_0_BASE:1.31
	OPENBSD_4_9:1.25.0.2
	OPENBSD_4_9_BASE:1.25
	OPENBSD_4_8:1.22.0.2
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.19.0.2
	OPENBSD_4_7_BASE:1.19
	OPENBSD_4_6:1.16.0.6
	OPENBSD_4_6_BASE:1.16
	OPENBSD_4_5:1.16.0.2
	OPENBSD_4_5_BASE:1.16
	OPENBSD_4_4:1.13.0.2
	OPENBSD_4_4_BASE:1.13
	OPENBSD_4_3:1.12.0.2
	OPENBSD_4_3_BASE:1.12
	OPENBSD_4_2:1.11.0.4
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.11.0.2
	OPENBSD_4_1_BASE:1.11
	OPENBSD_4_0:1.10.0.4
	OPENBSD_4_0_BASE:1.10
	OPENBSD_3_9:1.10.0.2
	OPENBSD_3_9_BASE:1.10
	OPENBSD_3_8:1.8.0.2
	OPENBSD_3_8_BASE:1.8
	OPENBSD_3_7:1.5.0.4
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.2
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	OPENBSD_3_5:1.4.0.4
	OPENBSD_3_5_BASE:1.4
	OPENBSD_3_4:1.4.0.2
	OPENBSD_3_4_BASE:1.4
	UBC_SYNC_A:1.4
	OPENBSD_3_3:1.3.0.6
	OPENBSD_3_3_BASE:1.3
	OPENBSD_3_2:1.3.0.4
	OPENBSD_3_2_BASE:1.3
	OPENBSD_3_1:1.3.0.2
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.3
	UBC:1.1.0.6
	UBC_BASE:1.1
	OPENBSD_3_0:1.1.0.4
	OPENBSD_3_0_BASE:1.1
	SMP:1.1.0.2;
locks; strict;
comment	@ * @;


1.32
date	2013.11.04.14.07.15;	author deraadt;	state dead;
branches;
next	1.31;

1.31
date	2011.05.02.22.15.11;	author chl;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.27.18.54.19;	author matthew;	state Exp;
branches;
next	1.29;

1.29
date	2011.04.25.12.40.52;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2011.04.03.17.58.31;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2011.04.03.17.55.07;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.03.16.53.20;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2010.11.20.20.11.19;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2010.10.12.00.53.32;	author krw;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.20.06.17.49;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2010.07.14.06.16.04;	author matthew;	state Exp;
branches;
next	1.21;

1.21
date	2010.06.28.18.31.01;	author krw;	state Exp;
branches;
next	1.20;

1.20
date	2010.03.23.01.57.19;	author krw;	state Exp;
branches;
next	1.19;

1.19
date	2010.01.09.23.15.06;	author krw;	state Exp;
branches;
next	1.18;

1.18
date	2009.11.22.14.14.10;	author krw;	state Exp;
branches;
next	1.17;

1.17
date	2009.08.29.11.02.51;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2009.02.16.21.19.06;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2009.01.21.21.53.59;	author grange;	state Exp;
branches;
next	1.14;

1.14
date	2008.11.25.17.52.02;	author krw;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.26.05.42.15;	author ray;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.17.15.07.37;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2006.11.28.23.59.45;	author dlg;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.04.04.05.25;	author krw;	state Exp;
branches;
next	1.9;

1.9
date	2005.09.15.05.33.39;	author krw;	state Exp;
branches;
next	1.8;

1.8
date	2005.08.24.01.19.47;	author krw;	state Exp;
branches;
next	1.7;

1.7
date	2005.07.03.22.31.27;	author krw;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.23.23.26.55;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2004.04.12.22.12.32;	author jmc;	state Exp;
branches;
next	1.4;

1.4
date	2003.04.27.11.22.52;	author ho;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.03.16.47.57;	author niklas;	state Exp;
branches;
next	1.2;

1.2
date	2002.03.14.01.26.53;	author millert;	state Exp;
branches;
next	1.1;

1.1
date	2001.06.29.06.05.03;	author niklas;	state Exp;
branches
	1.1.2.1
	1.1.6.1;
next	;

1.1.2.1
date	2002.03.28.11.50.59;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2003.03.28.00.38.10;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2003.05.13.19.34.57;	author ho;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2004.06.05.23.12.38;	author niklas;	state Exp;
branches;
next	;

1.1.6.1
date	2002.06.11.03.42.16;	author art;	state Exp;
branches;
next	1.1.6.2;

1.1.6.2
date	2003.05.19.22.01.43;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.32
log
@remove iop(4) driver.  it is entirely unmaintained and supports something
which basically doesn't exist at all.
reminded about it by brad
@
text
@/*	$OpenBSD: ioprbs.c,v 1.31 2011/05/02 22:15:11 chl Exp $	*/

/*
 * Copyright (c) 2001 Niklas Hallqvist
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*-
 * Copyright (c) 2000, 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Andrew Doran.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * A driver for I2O "Random block storage" devices, like RAID.
 */

/*
 * This driver would not have been written if it was not for the hardware
 * donation from pi.se.  I want to thank them for their support.  It also
 * had been much harder without Andrew Doran's work in NetBSD's ld_iop.c
 * driver, from which I have both gotten inspiration and actual code.
 * - Niklas Hallqvist
 */

#include <sys/param.h>
#include <sys/buf.h>
#include <sys/device.h>
#include <sys/kernel.h>
#include <sys/proc.h>
#include <sys/systm.h>

#include <machine/bus.h>

#include <scsi/scsi_all.h>
#include <scsi/scsi_disk.h>
#include <scsi/scsiconf.h>

#include <dev/i2o/i2o.h>
#include <dev/i2o/iopio.h>
#include <dev/i2o/iopvar.h>
#include <dev/i2o/ioprbsvar.h>

#ifdef I2ODEBUG
#define DPRINTF(x)	printf x
#else
#define	DPRINTF(x)
#endif

void	ioprbs_adjqparam(struct device *, int);
void	ioprbs_attach(struct device *, struct device *, void *);
void	ioprbs_copy_internal_data(struct scsi_xfer *, u_int8_t *,
	    size_t);
void	ioprbs_enqueue_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
int	ioprbs_exec_ccb(struct ioprbs_ccb *);
void	ioprbs_free_ccb(void *, void *);
void	*ioprbs_get_ccb(void *);
void	ioprbs_internal_cache_cmd(struct scsi_xfer *);
void	ioprbs_intr(struct device *, struct iop_msg *, void *);
void	ioprbs_intr_event(struct device *, struct iop_msg *, void *);
int	ioprbs_match(struct device *, void *, void *);
void	ioprbs_scsi_cmd(struct scsi_xfer *);
int	ioprbs_start(struct ioprbs_ccb *);
void	ioprbs_start_ccbs(struct ioprbs_softc *);
void	ioprbs_timeout(void *);
void	ioprbs_unconfig(struct ioprbs_softc *, int);
void	ioprbs_watchdog(void *);

struct cfdriver ioprbs_cd = {
	NULL, "ioprbs", DV_DULL
};

struct cfattach ioprbs_ca = {
	sizeof(struct ioprbs_softc), ioprbs_match, ioprbs_attach
};

struct scsi_adapter ioprbs_switch = {
	ioprbs_scsi_cmd, scsi_minphys, 0, 0,
};

#ifdef I2OVERBOSE
static const char *const ioprbs_errors[] = { 
	"success", 
	"media error", 
	"access error",
	"device failure",
	"device not ready",
	"media not present",
	"media locked",
	"media failure",
	"protocol failure",
	"bus failure",
	"access violation",
	"media write protected",
	"device reset",
	"volume changed, waiting for acknowledgement",
	"timeout",
};
#endif

/*
 * Match a supported device.
 */
int
ioprbs_match(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
{
	struct iop_attach_args *ia = aux;

	return (ia->ia_class == I2O_CLASS_RANDOM_BLOCK_STORAGE);
}

/*
 * Attach a supported device.
 */
void
ioprbs_attach(struct device *parent, struct device *self, void *aux)
{
	struct iop_attach_args *ia = aux;
	struct ioprbs_softc *sc = (struct ioprbs_softc *)self;
	struct iop_softc *iop = (struct iop_softc *)parent;
	struct scsibus_attach_args saa;
	int rv, state = 0;
	int enable;
	u_int32_t cachesz;
	char *typestr, *fixedstr;
	struct {
		struct	i2o_param_op_results pr;
		struct	i2o_param_read_results prr;
		union {
			struct	i2o_param_rbs_cache_control cc;
			struct	i2o_param_rbs_device_info bdi;
			struct	i2o_param_rbs_operation op;
		} p;
	} __packed param;
	int i;

	TAILQ_INIT(&sc->sc_free_ccb);
	TAILQ_INIT(&sc->sc_ccbq);
	mtx_init(&sc->sc_ccb_mtx, IPL_BIO);
	scsi_iopool_init(&sc->sc_iopool, sc, ioprbs_get_ccb, ioprbs_free_ccb);

	/* Initialize the ccbs */
	for (i = 0; i < IOPRBS_MAX_CCBS; i++)
		TAILQ_INSERT_TAIL(&sc->sc_free_ccb, &sc->sc_ccbs[i],
		    ic_chain);

	/* Register us as an initiator. */
	sc->sc_ii.ii_dv = self;
	sc->sc_ii.ii_intr = ioprbs_intr;
	sc->sc_ii.ii_adjqparam = ioprbs_adjqparam;
	sc->sc_ii.ii_flags = 0;
	sc->sc_ii.ii_tid = ia->ia_tid;
	iop_initiator_register(iop, &sc->sc_ii);

	/* Register another initiator to handle events from the device. */
	sc->sc_eventii.ii_dv = self;
	sc->sc_eventii.ii_intr = ioprbs_intr_event;
	sc->sc_eventii.ii_flags = II_DISCARD | II_UTILITY;
	sc->sc_eventii.ii_tid = ia->ia_tid;
	iop_initiator_register(iop, &sc->sc_eventii);

	rv = iop_util_eventreg(iop, &sc->sc_eventii,
	    I2O_EVENT_GEN_EVENT_MASK_MODIFIED | I2O_EVENT_GEN_DEVICE_RESET |
	    I2O_EVENT_GEN_STATE_CHANGE | I2O_EVENT_GEN_GENERAL_WARNING);
	if (rv != 0) {
		printf("%s: unable to register for events", self->dv_xname);
		goto bad;
	}
	state++;

	/*
	 * Start out with one queued command.  The `iop' driver will adjust
	 * the queue parameters once we're up and running.
	 */
	sc->sc_maxqueuecnt = 1;

	sc->sc_maxxfer = IOP_MAX_XFER;

	/* Say what the device is. */
	printf(":");
	iop_print_ident(iop, ia->ia_tid);

	/*
	 * Claim the device so that we don't get any nasty surprises.  Allow
	 * failure.
	 */
	rv = iop_util_claim(iop, &sc->sc_ii, 0,
	    I2O_UTIL_CLAIM_CAPACITY_SENSITIVE |
	    I2O_UTIL_CLAIM_NO_PEER_SERVICE |
	    I2O_UTIL_CLAIM_NO_MANAGEMENT_SERVICE |
	    I2O_UTIL_CLAIM_PRIMARY_USER);
	sc->sc_flags = rv ? 0 : IOPRBS_CLAIMED;

	rv = iop_param_op(iop, ia->ia_tid, NULL, 0, I2O_PARAM_RBS_DEVICE_INFO,
	    &param, sizeof param);
	if (rv != 0) {
		printf("%s: unable to get parameters (0x%04x; %d)\n",
		   sc->sc_dv.dv_xname, I2O_PARAM_RBS_DEVICE_INFO, rv);
		goto bad;
	}

	sc->sc_secsize = letoh32(param.p.bdi.blocksize);
	sc->sc_secperunit = (int)
	    (letoh64(param.p.bdi.capacity) / sc->sc_secsize);

	switch (param.p.bdi.type) {
	case I2O_RBS_TYPE_DIRECT:
		typestr = "direct access";
		enable = 1;
		break;
	case I2O_RBS_TYPE_WORM:
		typestr = "WORM";
		enable = 0;
		break;
	case I2O_RBS_TYPE_CDROM:
		typestr = "CD-ROM";
		enable = 0;
		break;
	case I2O_RBS_TYPE_OPTICAL:
		typestr = "optical";
		enable = 0;
		break;
	default:
		typestr = "unknown";
		enable = 0;
		break;
	}

	if ((letoh32(param.p.bdi.capabilities) & I2O_RBS_CAP_REMOVABLE_MEDIA)
	    != 0) {
		/* sc->sc_flags = IOPRBS_REMOVABLE; */
		fixedstr = "removable";
		enable = 0;
	} else
		fixedstr = "fixed";

	printf(" %s, %s", typestr, fixedstr);

	/*
	 * Determine if the device has an private cache.  If so, print the
	 * cache size.  Even if the device doesn't appear to have a cache,
	 * we perform a flush at shutdown.
	 */
	rv = iop_param_op(iop, ia->ia_tid, NULL, 0,
	    I2O_PARAM_RBS_CACHE_CONTROL, &param, sizeof(param));
	if (rv != 0) {
		printf("%s: unable to get parameters (0x%04x; %d)\n",
		   sc->sc_dv.dv_xname, I2O_PARAM_RBS_CACHE_CONTROL, rv);
		goto bad;
	}

	if ((cachesz = letoh32(param.p.cc.totalcachesize)) != 0)
		printf(", %dkB cache", cachesz >> 10);

	printf("\n");

	/*
	 * Configure the DDM's timeout functions to time out all commands
	 * after 30 seconds.
	 */
	rv = iop_param_op(iop, ia->ia_tid, NULL, 0, I2O_PARAM_RBS_OPERATION,
	    &param, sizeof(param));
	if (rv != 0) {
		printf("%s: unable to get parameters (0x%04x; %d)\n",
		   sc->sc_dv.dv_xname, I2O_PARAM_RBS_OPERATION, rv);
		goto bad;
	}

	param.p.op.timeoutbase = htole32(IOPRBS_TIMEOUT * 1000); 
	param.p.op.rwvtimeoutbase = htole32(IOPRBS_TIMEOUT * 1000); 
	param.p.op.rwvtimeout = 0; 

	rv = iop_param_op(iop, ia->ia_tid, NULL, 1, I2O_PARAM_RBS_OPERATION,
	    &param, sizeof(param));
#ifdef notdef
	/*
	 * Intel RAID adapters don't like the above, but do post a
	 * `parameter changed' event.  Perhaps we're doing something
	 * wrong...
	 */
	if (rv != 0) {
		printf("%s: unable to set parameters (0x%04x; %d)\n",
		   sc->sc_dv.dv_xname, I2O_PARAM_RBS_OPERATION, rv);
		goto bad;
	}
#endif

	if (enable)
		sc->sc_flags |= IOPRBS_ENABLED;
	else
		printf("%s: device not yet supported\n", self->dv_xname);

	/* Fill in the prototype scsi_link. */
	sc->sc_link.adapter_softc = sc;
	sc->sc_link.adapter = &ioprbs_switch;
	sc->sc_link.openings = 1;
	sc->sc_link.adapter_buswidth = 1;
	sc->sc_link.adapter_target = 1;
	sc->sc_link.pool = &sc->sc_iopool;

	bzero(&saa, sizeof(saa));
	saa.saa_sc_link = &sc->sc_link;

	config_found(&sc->sc_dv, &saa, scsiprint);

	return;

 bad:
	ioprbs_unconfig(sc, state > 0);
}

void
ioprbs_unconfig(struct ioprbs_softc *sc, int evreg)
{
	struct iop_softc *iop;
	int s;

	iop = (struct iop_softc *)sc->sc_dv.dv_parent;

	if ((sc->sc_flags & IOPRBS_CLAIMED) != 0)
		iop_util_claim(iop, &sc->sc_ii, 1,
		    I2O_UTIL_CLAIM_PRIMARY_USER);

	if (evreg) {
		/*
		 * Mask off events, and wait up to 5 seconds for a reply. 
		 * Note that some adapters won't reply to this (XXX We
		 * should check the event capabilities).
		 */
		sc->sc_flags &= ~IOPRBS_NEW_EVTMASK;
		iop_util_eventreg(iop, &sc->sc_eventii,
		    I2O_EVENT_GEN_EVENT_MASK_MODIFIED);
		s = splbio();
		if ((sc->sc_flags & IOPRBS_NEW_EVTMASK) == 0)
			tsleep(&sc->sc_eventii, PRIBIO, "ioprbsevt", hz * 5);
		splx(s);
#ifdef I2ODEBUG
		if ((sc->sc_flags & IOPRBS_NEW_EVTMASK) == 0)
			printf("%s: didn't reply to event unregister",
			    sc->sc_dv.dv_xname);
#endif
	}

	iop_initiator_unregister(iop, &sc->sc_eventii);
	iop_initiator_unregister(iop, &sc->sc_ii);
}

void
ioprbs_scsi_cmd(struct scsi_xfer *xs)
{
	struct scsi_link *link = xs->sc_link;
	struct ioprbs_softc *sc = link->adapter_softc;
	struct ioprbs_ccb *ccb = xs->io;
	u_int64_t blockno;
	u_int32_t blockcnt;
	int s;

	xs->error = XS_NOERROR;

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case REQUEST_SENSE:
	case INQUIRY:
	case MODE_SENSE:
	case START_STOP:
	case READ_CAPACITY:
#if 0
	case VERIFY:
#endif
		ioprbs_internal_cache_cmd(xs);
		scsi_done(xs);
		return;

	case PREVENT_ALLOW:
		DPRINTF(("PREVENT/ALLOW "));
		/* XXX Not yet implemented */
		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	case SYNCHRONIZE_CACHE:
		DPRINTF(("SYNCHRONIZE_CACHE "));
		/* XXX Not yet implemented */
		xs->error = XS_NOERROR;
		scsi_done(xs);
		return;

	default:
		DPRINTF(("unknown opc %d ", xs->cmd->opcode));
		/* XXX Not yet implemented */
		xs->error = XS_DRIVER_STUFFUP;
		scsi_done(xs);
		return;

	case READ_COMMAND:
	case READ_BIG:
	case WRITE_COMMAND:
	case WRITE_BIG:
		DPRINTF(("rw opc %d ", xs->cmd->opcode));

		scsi_cmd_rw_decode(xs->cmd, &blockno, &blockcnt);
		if (blockno >= sc->sc_secperunit ||
		    blockcnt > sc->sc_secperunit - blockno) {
			printf("%s: out of bounds %llu-%u >= %u\n",
			    sc->sc_dv.dv_xname, blockno, blockcnt,
			    sc->sc_secperunit);
			/*
			 * XXX Should be XS_SENSE but that
			 * would require setting up a faked
			 * sense too.
			 */
			xs->error = XS_DRIVER_STUFFUP;
			scsi_done(xs);
			return;
		}

		ccb->ic_blockno = blockno;
		ccb->ic_blockcnt = blockcnt;
		ccb->ic_xs = xs;
		ccb->ic_timeout = xs->timeout;

		s = splbio();
		ioprbs_enqueue_ccb(sc, ccb);
		splx(s);

		if (xs->flags & SCSI_POLL) {
			/* XXX Should actually poll... */
		}
	}
}

void
ioprbs_intr(struct device *dv, struct iop_msg *im, void *reply)
{
	struct i2o_rbs_reply *rb = reply;
	struct ioprbs_ccb *ccb = im->im_dvcontext;
	struct scsi_xfer *xs = ccb->ic_xs;
	struct iop_softc *iop = (struct iop_softc *)dv->dv_parent;
	int err, detail;
#ifdef I2OVERBOSE
	const char *errstr;
#endif

	DPRINTF(("ioprbs_intr(%p, %p, %p) ", dv, im, reply));

	timeout_del(&xs->stimeout);

	err = ((rb->msgflags & I2O_MSGFLAGS_FAIL) != 0);

	if (!err && rb->reqstatus != I2O_STATUS_SUCCESS) {
		detail = letoh16(rb->detail);
#ifdef I2OVERBOSE
		if (detail >= sizeof(ioprbs_errors) / sizeof(ioprbs_errors[0]))
			errstr = "<unknown>";
		else
			errstr = ioprbs_errors[detail];
		printf("%s: error 0x%04x: %s\n", dv->dv_xname, detail, errstr);
#else
		printf("%s: error 0x%04x\n", dv->dv_xname, detail);
#endif
		err = 1;
	}

	if (err)
		xs->error = XS_DRIVER_STUFFUP;
	else
		xs->resid = xs->datalen - letoh32(rb->transfercount);

	iop_msg_unmap(iop, im);
	iop_msg_free(iop, im);
	scsi_done(xs);
}

void
ioprbs_intr_event(struct device *dv, struct iop_msg *im, void *reply)
{
	struct i2o_util_event_register_reply *rb;
	struct ioprbs_softc *sc;
	u_int event;

	rb = reply;

	if ((rb->msgflags & I2O_MSGFLAGS_FAIL) != 0)
		return;

	event = letoh32(rb->event);
	sc = (struct ioprbs_softc *)dv;

	if (event == I2O_EVENT_GEN_EVENT_MASK_MODIFIED) {
		sc->sc_flags |= IOPRBS_NEW_EVTMASK;
		wakeup(&sc->sc_eventii);
#ifndef I2ODEBUG
		return;
#endif
	}

	printf("%s: event 0x%08x received\n", dv->dv_xname, event);
}

void
ioprbs_adjqparam(struct device *dv, int mpi)
{
#if 0
	struct iop_softc *iop;

	/*
	 * AMI controllers seem to lose the plot if you hand off lots of
	 * queued commands.
	 */
	iop = (struct iop_softc *)dv->dv_parent;
	if (letoh16(I2O_ORG_AMI) == iop->sc_status.orgid && mpi > 64)
		mpi = 64;

	ldadjqparam((struct ld_softc *)dv, mpi);
#endif
}

void
ioprbs_copy_internal_data(xs, data, size)
	struct scsi_xfer *xs;
	u_int8_t *data;
	size_t size;
{
	size_t copy_cnt;

	DPRINTF(("ioprbs_copy_internal_data "));

	if (!xs->datalen)
		printf("uio move not yet supported\n");
	else {
		copy_cnt = MIN(size, xs->datalen);
		bcopy(data, xs->data, copy_cnt);
	}
}

/* Emulated SCSI operation on cache device */
void
ioprbs_internal_cache_cmd(xs)
	struct scsi_xfer *xs;
{
	struct scsi_link *link = xs->sc_link;
	struct ioprbs_softc *sc = link->adapter_softc;
	u_int8_t target = link->target;
	struct scsi_inquiry_data inq;
	struct scsi_sense_data sd;
	struct scsi_read_cap_data rcd;

	DPRINTF(("ioprbs_internal_cache_cmd "));

	xs->error = XS_NOERROR;

	if (target > 0 || link->lun != 0) {
		xs->error = XS_DRIVER_STUFFUP;
		return;
	}

	switch (xs->cmd->opcode) {
	case TEST_UNIT_READY:
	case START_STOP:
#if 0
	case VERIFY:
#endif
		DPRINTF(("opc %d tgt %d ", xs->cmd->opcode, target));
		break;

	case REQUEST_SENSE:
		DPRINTF(("REQUEST SENSE tgt %d ", target));
		bzero(&sd, sizeof sd);
		sd.error_code = SSD_ERRCODE_CURRENT;
		sd.segment = 0;
		sd.flags = SKEY_NO_SENSE;
		bzero(sd.info, sizeof sd.info);
		sd.extra_len = 0;
		ioprbs_copy_internal_data(xs, (u_int8_t *)&sd, sizeof sd);
		break;

	case INQUIRY:
		DPRINTF(("INQUIRY tgt %d", target));
		bzero(&inq, sizeof inq);
		/* XXX How do we detect removable/CD-ROM devices?  */
		inq.device = T_DIRECT;
		inq.dev_qual2 = 0;
		inq.version = 2;
		inq.response_format = 2;
		inq.additional_length = 32;
		inq.flags |= SID_CmdQue;
		strlcpy(inq.vendor, "I2O", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
		ioprbs_copy_internal_data(xs, (u_int8_t *)&inq, sizeof inq);
		break;

	case READ_CAPACITY:
		DPRINTF(("READ CAPACITY tgt %d ", target));
		bzero(&rcd, sizeof rcd);
		_lto4b(sc->sc_secperunit - 1, rcd.addr);
		_lto4b(IOPRBS_BLOCK_SIZE, rcd.length);
		ioprbs_copy_internal_data(xs, (u_int8_t *)&rcd, sizeof rcd);
		break;

	default:
		DPRINTF(("unsupported scsi command %#x tgt %d ",
		    xs->cmd->opcode, target));
		xs->error = XS_DRIVER_STUFFUP;
		return;
	}

	xs->error = XS_NOERROR;
}

void *
ioprbs_get_ccb(void *cookie)
{
	struct ioprbs_softc *sc = cookie;
	struct ioprbs_ccb *ccb;

	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb)
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ic_chain);
	mtx_leave(&sc->sc_ccb_mtx);

	/* initialise the command */
	if (ccb)
		ccb->ic_flags = 0;

	return (ccb);
}

void
ioprbs_free_ccb(void *cookie, void *io)
{
	struct ioprbs_softc *sc = cookie;
	struct ioprbs_ccb *ccb = io;

	mtx_enter(&sc->sc_ccb_mtx);
	TAILQ_INSERT_HEAD(&sc->sc_free_ccb, ccb, ic_chain);
	mtx_leave(&sc->sc_ccb_mtx);
}

void
ioprbs_enqueue_ccb(sc, ccb)
	struct ioprbs_softc *sc;
	struct ioprbs_ccb *ccb;
{
	DPRINTF(("ioprbs_enqueue_ccb(%p, %p) ", sc, ccb));

	timeout_set(&ccb->ic_xs->stimeout, ioprbs_timeout, ccb);
	TAILQ_INSERT_TAIL(&sc->sc_ccbq, ccb, ic_chain);
	ioprbs_start_ccbs(sc);
}

void
ioprbs_start_ccbs(sc)
	struct ioprbs_softc *sc;
{
	struct ioprbs_ccb *ccb;
	struct scsi_xfer *xs;

	DPRINTF(("ioprbs_start_ccbs(%p) ", sc));

	while ((ccb = TAILQ_FIRST(&sc->sc_ccbq)) != NULL) {

		xs = ccb->ic_xs;
		if (ccb->ic_flags & IOPRBS_ICF_WATCHDOG)
			timeout_del(&xs->stimeout);

		if (ioprbs_exec_ccb(ccb) == 0) {
			ccb->ic_flags |= IOPRBS_ICF_WATCHDOG;
			timeout_set(&ccb->ic_xs->stimeout, ioprbs_watchdog,
			    ccb);
			timeout_add_msec(&xs->stimeout, IOPRBS_WATCH_TIMEOUT);
			break;
		}
		TAILQ_REMOVE(&sc->sc_ccbq, ccb, ic_chain);

		if ((xs->flags & SCSI_POLL) == 0) {
			timeout_set(&ccb->ic_xs->stimeout, ioprbs_timeout,
			    ccb);
			timeout_add_msec(&xs->stimeout, ccb->ic_timeout);
		}
	}
}

int
ioprbs_exec_ccb(ccb)
	struct ioprbs_ccb *ccb;
{
	struct scsi_xfer *xs = ccb->ic_xs;

	DPRINTF(("ioprbs_exec_ccb(%p, %p) ", xs, ccb));

	ioprbs_start(ccb);

	xs->error = XS_NOERROR;
	xs->resid = 0;
	return (1);
}

/*
 * Deliver a command to the controller; allocate controller resources at the
 * last moment when possible.
 */
int
ioprbs_start(struct ioprbs_ccb *ccb)
{
	struct scsi_xfer *xs = ccb->ic_xs;
	struct scsi_link *link = xs->sc_link;
	struct ioprbs_softc *sc = link->adapter_softc;
#ifdef I2ODEBUG
	u_int8_t target = link->target;
#endif
	struct iop_msg *im;
	struct iop_softc *iop = (struct iop_softc *)sc->sc_dv.dv_parent;
	struct i2o_rbs_block_read *mf;
	u_int rv, flags = 0, mode = I2O_RBS_BLOCK_READ;
	u_int64_t ba;
	u_int32_t mb[IOP_MAX_MSG_SIZE / sizeof(u_int32_t)];

	im = iop_msg_alloc(iop, &sc->sc_ii, 0);
	im->im_dvcontext = ccb;

	switch (xs->cmd->opcode) {
	case PREVENT_ALLOW:
	case SYNCHRONIZE_CACHE:
		if (xs->cmd->opcode == PREVENT_ALLOW) {
			/* XXX PREVENT_ALLOW support goes here */
		} else {
			DPRINTF(("SYNCHRONIZE CACHE tgt %d ", target));
		}
		break;

	case WRITE_COMMAND:
	case WRITE_BIG:
		flags = I2O_RBS_BLOCK_WRITE_CACHE_WB;
		mode = I2O_RBS_BLOCK_WRITE;
		/* FALLTHROUGH */

	case READ_COMMAND:
	case READ_BIG:
		ba = (u_int64_t)ccb->ic_blockno * DEV_BSIZE;

		/*
		 * Fill the message frame.  We can use the block_read
		 * structure for both reads and writes, as it's almost
		 * identical to the * block_write structure.
		 */
		mf = (struct i2o_rbs_block_read *)mb;
		mf->msgflags = I2O_MSGFLAGS(i2o_rbs_block_read);
		mf->msgfunc = I2O_MSGFUNC(sc->sc_ii.ii_tid, mode);
		mf->msgictx = sc->sc_ii.ii_ictx;
		mf->msgtctx = im->im_tctx;
		mf->flags = flags | (1 << 16);	/* flags & time multiplier */
		mf->datasize = ccb->ic_blockcnt * DEV_BSIZE;
		mf->lowoffset = (u_int32_t)ba;
		mf->highoffset = (u_int32_t)(ba >> 32);

		/* Map the data transfer and enqueue the command. */
		rv = iop_msg_map_bio(iop, im, mb, xs->data,
		    ccb->ic_blockcnt * DEV_BSIZE, mode == I2O_RBS_BLOCK_WRITE);
		if (rv == 0) {
			if ((rv = iop_msg_post(iop, im, mb, 0)) != 0) {
				iop_msg_unmap(iop, im);
				iop_msg_free(iop, im);
			}
		}
		break;
	}
	return (0);
}

void
ioprbs_timeout(arg)
	void *arg;
{
	struct ioprbs_ccb *ccb = arg;
	struct scsi_link *link = ccb->ic_xs->sc_link;
	struct ioprbs_softc *sc = link->adapter_softc;
	int s;

	sc_print_addr(link);
	printf("timed out\n");

	/* XXX Test for multiple timeouts */

	ccb->ic_xs->error = XS_TIMEOUT;
	s = splbio();
	ioprbs_enqueue_ccb(sc, ccb);
	splx(s);
}

void
ioprbs_watchdog(arg)
	void *arg;
{
	struct ioprbs_ccb *ccb = arg;
	struct scsi_link *link = ccb->ic_xs->sc_link;
	struct ioprbs_softc *sc = link->adapter_softc;
	int s;

	s = splbio();
	ccb->ic_flags &= ~IOPRBS_ICF_WATCHDOG;
	ioprbs_start_ccbs(sc);
	splx(s);
}
@


1.31
log
@Fix potential null dereference.

Found by LLVM/Clang Static Analyzer.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.30 2011/04/27 18:54:19 matthew Exp $	*/
@


1.30
log
@Simplify ioprbs(4) scsi_xfer handling.

XS_POLL handling is still wrong, but reportedly it works, so leaving
it be for now.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.29 2011/04/25 12:40:52 miod Exp $	*/
d672 2
a673 1
	ccb->ic_flags = 0;
@


1.29
log
@Callers of scsi_iopool_init() ought to set up the pool member in struct
scsi_link accordingly, for bad things will happen without (and this was a
real pita to debug).
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.28 2011/04/03 17:58:31 dlg Exp $	*/
a97 2
struct scsi_xfer *ioprbs_dequeue(struct ioprbs_softc *);
void	ioprbs_enqueue(struct ioprbs_softc *, struct scsi_xfer *, int);
a185 1
	LIST_INIT(&sc->sc_queue);
d396 1
a396 2
ioprbs_scsi_cmd(xs)
	struct scsi_xfer *xs;
d401 2
a402 3
	u_int32_t blockno, blockcnt;
	struct scsi_rw *rw;
	struct scsi_rw_big *rwb;
d405 1
a405 1
	s = splbio();
d407 13
a419 3
	/* Don't double enqueue if we came from ioprbs_chain. */
	if (xs != LIST_FIRST(&sc->sc_queue))
		ioprbs_enqueue(sc, xs, 0);
d421 3
a423 1
	while ((xs = ioprbs_dequeue(sc))) {
d425 2
d428 6
a433 1
		ccb = NULL;
d435 6
a440 20
		switch (xs->cmd->opcode) {
		case TEST_UNIT_READY:
		case REQUEST_SENSE:
		case INQUIRY:
		case MODE_SENSE:
		case START_STOP:
		case READ_CAPACITY:
#if 0
		case VERIFY:
#endif
			ioprbs_internal_cache_cmd(xs);
			scsi_done(xs);
			goto ready;

		case PREVENT_ALLOW:
			DPRINTF(("PREVENT/ALLOW "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			scsi_done(xs);
			goto ready;
d442 17
a458 10
		case SYNCHRONIZE_CACHE:
			DPRINTF(("SYNCHRONIZE_CACHE "));
			/* XXX Not yet implemented */
			xs->error = XS_NOERROR;
			scsi_done(xs);
			goto ready;

		default:
			DPRINTF(("unknown opc %d ", xs->cmd->opcode));
			/* XXX Not yet implemented */
d461 2
a462 1
			goto ready;
d464 4
a467 40
		case READ_COMMAND:
		case READ_BIG:
		case WRITE_COMMAND:
		case WRITE_BIG:
			DPRINTF(("rw opc %d ", xs->cmd->opcode));

			if (xs->cmd->opcode != SYNCHRONIZE_CACHE) {
				/* A read or write operation. */
				if (xs->cmdlen == 6) {
					rw = (struct scsi_rw *)xs->cmd;
					blockno = _3btol(rw->addr) &
					    (SRW_TOPADDR << 16 | 0xffff);
					blockcnt =
					    rw->length ? rw->length : 0x100;
				} else {
					rwb = (struct scsi_rw_big *)xs->cmd;
					blockno = _4btol(rwb->addr);
					blockcnt = _2btol(rwb->length);
				}
				if (blockno >= sc->sc_secperunit ||
				    blockno + blockcnt > sc->sc_secperunit) {
					printf(
					    "%s: out of bounds %u-%u >= %u\n",
					    sc->sc_dv.dv_xname, blockno,
					    blockcnt, sc->sc_secperunit);
					/*
					 * XXX Should be XS_SENSE but that
					 * would require setting up a faked
					 * sense too.
					 */
					xs->error = XS_DRIVER_STUFFUP;
					scsi_done(xs);
					goto ready;
				}
			}

			ccb->ic_blockno = blockno;
			ccb->ic_blockcnt = blockcnt;
			ccb->ic_xs = xs;
			ccb->ic_timeout = xs->timeout;
d469 3
a471 18
			ioprbs_enqueue_ccb(sc, ccb);

			/* XXX what if enqueue did not start a transfer? */
			if (xs->flags & SCSI_POLL) {
#if 0
				if (!ioprbs_wait(sc, ccb, ccb->ic_timeout)) {
					splx(s);
					printf("%s: command timed out\n",
					    sc->sc_dv.dv_xname);
					xs->error = XS_NO_CCB;
					scsi_done(xs);
					splx(s);
					return;
				}
				scsi_done(xs);
#endif
			}
		}
a472 4
	ready:
		/*
		 * Don't process the queue if we are polling.
		 */
d474 1
a474 1
			break;
a476 2

	splx(s);
a562 41
}

/*
 * Insert a command into the driver queue, either at the front or at the tail.
 * It's ok to overload the freelist link as these structures are never on
 * the freelist at this time.
 */
void
ioprbs_enqueue(sc, xs, infront)
	struct ioprbs_softc *sc;
	struct scsi_xfer *xs;
	int infront;
{
	if (infront || LIST_FIRST(&sc->sc_queue) == NULL) {
		if (LIST_FIRST(&sc->sc_queue) == NULL)
			sc->sc_queuelast = xs;
		LIST_INSERT_HEAD(&sc->sc_queue, xs, free_list);
		return;
	}
	LIST_INSERT_AFTER(sc->sc_queuelast, xs, free_list);
	sc->sc_queuelast = xs;
}

/*
 * Pull a command off the front of the driver queue.
 */
struct scsi_xfer *
ioprbs_dequeue(sc)
	struct ioprbs_softc *sc;
{
	struct scsi_xfer *xs;

	xs = LIST_FIRST(&sc->sc_queue);
	if (xs == NULL)
		return (NULL);
	LIST_REMOVE(xs, free_list);

	if (LIST_FIRST(&sc->sc_queue) == NULL)
		sc->sc_queuelast = NULL;

	return (xs);
@


1.28
log
@put iopools back in. ok gcc
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.27 2011/04/03 17:55:07 dlg Exp $	*/
d349 1
@


1.27
log
@back iopools out, it was never compiled.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.26 2011/04/03 16:53:20 dlg Exp $	*/
d102 2
a103 2
void	ioprbs_free_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
struct ioprbs_ccb *ioprbs_get_ccb(struct ioprbs_softc *, int);
d189 2
d403 1
a403 1
	struct ioprbs_ccb *ccb;
a490 12
			ccb = ioprbs_get_ccb(sc, xs->flags);

			/*
			 * We are out of commands, try again in a little while.
			 */
			if (ccb == NULL) {
				xs->error = XS_NO_CCB;
				scsi_done(xs);
				splx(s);
				return;
			}

a532 1
	struct ioprbs_softc *sc = (struct ioprbs_softc *)dv;
a566 1
	ioprbs_free_ccb(sc, ccb);
d748 2
a749 4
struct ioprbs_ccb *
ioprbs_get_ccb(sc, flags)
	struct ioprbs_softc *sc;
	int flags;
d751 1
a752 5
	int s;

	DPRINTF(("ioprbs_get_ccb(%p, 0x%x) ", sc, flags));

	s = splbio();
d754 5
a758 10
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb != NULL)
			break;
		if (flags & SCSI_NOSLEEP)
			goto bail_out;
		tsleep(&sc->sc_free_ccb, PRIBIO, "ioprbs_ccb", 0);
	}

	TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ic_chain);
a762 2
 bail_out:
	splx(s);
d767 1
a767 3
ioprbs_free_ccb(sc, ccb)
	struct ioprbs_softc *sc;
	struct ioprbs_ccb *ccb;
d769 2
a770 5
	int s;

	DPRINTF(("ioprbs_free_ccb(%p, %p) ", sc, ccb));

	s = splbio();
d772 1
d774 1
a774 6

	/* If the free list was empty, wake up potential waiters. */
	if (TAILQ_NEXT(ccb, ic_chain) == NULL)
		wakeup(&sc->sc_free_ccb);

	splx(s);
@


1.26
log
@get rid of NO_CCB by moving to iopools.

"be brave" k2k11
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.25 2010/11/20 20:11:19 miod Exp $	*/
d102 2
a103 2
void	ioprbs_free_ccb(void *, void *);
void	*ioprbs_get_ccb(void *);
a188 2
	mtx_init(&sc->sc_ccb_mtx);
	scsi_iopool_init(&sc->sc_iopool, sc, iopbrs_get_ccb, iopbrs_free_ccb);
d401 1
a401 1
	struct ioprbs_ccb *ccb = xs->io;
d489 12
d578 1
d760 4
a763 2
void *
ioprbs_get_ccb(void *cookie)
a764 1
	struct iopbrs_softc *sc = cookie;
d766 5
d772 10
a781 5
	mtx_enter(&sc->sc_ccb_mtx);
	ccb = TAILQ_FIRST(&sc->sc_free_ccb);
	if (ccb)
		TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ic_chain);
	mtx_leave(&sc->sc_ccb_mtx);
d786 2
d792 3
a794 1
ioprbs_free_ccb(void *cookie, void *io)
d796 5
a800 2
	struct iopbrs_softc *sc = cookie;
	struct ioprbs_ccb *ccb = io;
a801 1
	mtx_enter(&sc->sc_ccb_mtx);
d803 6
a808 1
	mtx_leave(&sc->sc_ccb_mtx);
@


1.25
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.24 2010/10/12 00:53:32 krw Exp $	*/
d102 2
a103 2
void	ioprbs_free_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
struct ioprbs_ccb *ioprbs_get_ccb(struct ioprbs_softc *, int);
d189 2
d403 1
a403 1
	struct ioprbs_ccb *ccb;
a490 12
			ccb = ioprbs_get_ccb(sc, xs->flags);

			/*
			 * We are out of commands, try again in a little while.
			 */
			if (ccb == NULL) {
				xs->error = XS_NO_CCB;
				scsi_done(xs);
				splx(s);
				return;
			}

a567 1
	ioprbs_free_ccb(sc, ccb);
d749 2
a750 4
struct ioprbs_ccb *
ioprbs_get_ccb(sc, flags)
	struct ioprbs_softc *sc;
	int flags;
d752 1
a753 5
	int s;

	DPRINTF(("ioprbs_get_ccb(%p, 0x%x) ", sc, flags));

	s = splbio();
d755 5
a759 10
	for (;;) {
		ccb = TAILQ_FIRST(&sc->sc_free_ccb);
		if (ccb != NULL)
			break;
		if (flags & SCSI_NOSLEEP)
			goto bail_out;
		tsleep(&sc->sc_free_ccb, PRIBIO, "ioprbs_ccb", 0);
	}

	TAILQ_REMOVE(&sc->sc_free_ccb, ccb, ic_chain);
a763 2
 bail_out:
	splx(s);
d768 1
a768 3
ioprbs_free_ccb(sc, ccb)
	struct ioprbs_softc *sc;
	struct ioprbs_ccb *ccb;
d770 2
a771 5
	int s;

	DPRINTF(("ioprbs_free_ccb(%p, %p) ", sc, ccb));

	s = splbio();
d773 1
d775 1
a775 6

	/* If the free list was empty, wake up potential waiters. */
	if (TAILQ_NEXT(ccb, ic_chain) == NULL)
		wakeup(&sc->sc_free_ccb);

	splx(s);
@


1.24
log
@Force openings to 1 for devices that can't do tagged i/o, i.e. more
than 1 i/o active at once.  This reduces the chances that concurrent
i/o's for such devices will confuse the device or the adapter code.
It also eliminates a reason for adapter code to maintain its own
queues.

Tweak all drivers that fake INQUIRY results to set the SID_CmdQue
flag, thus continuing to claim to be able to do tagged i/o.

Positive feedback from matthew@@ and marco@@ for an earlier version.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.23 2010/09/20 06:17:49 krw Exp $	*/
d183 1
a183 1
	} param /* XXX gcc __attribute__ ((__packed__)) */;
@


1.23
log
@Use SSD_ERRCODE_CURRENT instead of magic 0x70.

ok dlg@@ matthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.22 2010/07/14 06:16:04 matthew Exp $	*/
d734 1
@


1.22
log
@SCSI HBA drivers need to report success/error through xs, not xs->bp.
By trying to do the latter, ioprbs(4) was inadvertently always
signalling to the SCSI mid and upper layers that read/write requests
succeeded, even if they failed or only partially completed.

Light testing by claudio@@, which is still way more effort than this
driver deserved.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.21 2010/06/28 18:31:01 krw Exp $	*/
d717 1
a717 1
		sd.error_code = 0x70;
@


1.21
log
@Remove all adapter-specific 'struct scsi_device's. They are never used. First
step in elminating 'struct scsi_device' entirely.

Spotted and initial diff from matthew@@.

ok matthew@@ dlg@@ deraadt@@ marco@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.20 2010/03/23 01:57:19 krw Exp $	*/
d542 1
a542 1
	struct buf *bp = ccb->ic_xs->bp;
d552 1
a552 1
	timeout_del(&ccb->ic_xs->stimeout);
d570 4
a573 8
	if (bp) {
		if (err) {
			bp->b_flags |= B_ERROR;
			bp->b_error = EIO;
			bp->b_resid = bp->b_bcount;
		} else
			bp->b_resid = bp->b_bcount - letoh32(rb->transfercount);
	}
d577 1
a577 1
	scsi_done(ccb->ic_xs);
@


1.20
log
@Change the scsi_cmd function member of scsi_adapter from int to
void. Use XS_NO_CCB error in the scsi command (xs) to report the
NO_CCB condition. Eliminates all SUCCESSFULLY_QUEUED and COMPLETE
confusion and untangles the midlayer from the adapter a bit more.

Eyes and some fixes by miod@@

There may be some compile issues on little used (i.e. I don't have
any) drivers but the change is mechanical and thus easy to remedy.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.19 2010/01/09 23:15:06 krw Exp $	*/
a126 4
struct scsi_device ioprbs_dev = {
	NULL, NULL, NULL, NULL
};

a343 1
	sc->sc_link.device = &ioprbs_dev;
@


1.19
log
@Zap all setting of ITSDONE in drivers that don't look at it. Nobody
else cares so it's just noise. Drivers that actually look at ITSDONE
are unchanged.

ok marco@@ (for his files) dlg@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.18 2009/11/22 14:14:10 krw Exp $	*/
d108 1
a108 1
int	ioprbs_scsi_cmd(struct scsi_xfer *);
d400 1
a400 1
int
a410 1
	int retval = SUCCESSFULLY_QUEUED;
d500 2
d503 1
a503 1
				return (NO_CCB);
d520 4
a523 1
					return (NO_CCB);
a534 1
			retval = COMPLETE;
a539 1
	return (retval);
@


1.18
log
@Bring last drivers fully into the NO_CCB world by replacing
TRY_AGAIN_LATER uses with equivalent NO_CCB.  Eliminates confusion
between the two as was always intended.  buf I/O's that can't be
started get pushed back onto the front of the queue and retried.
Others get sent back to originator as failures. No more epi-cycle
looping inside the SCSI midlayer hoping the problem goes away.

Various testers, no objection from miod@@ as vs(4) was tested by
nick@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.17 2009/08/29 11:02:51 miod Exp $	*/
a434 1
			xs->flags |= ITSDONE;
a441 1
			xs->flags |= ITSDONE;
a448 1
			xs->flags |= ITSDONE;
a455 1
			xs->flags |= ITSDONE;
a489 1
					xs->flags |= ITSDONE;
a520 1
				xs->flags |= ITSDONE;
@


1.17
log
@incorrect array bounds check in I2OVERBOSE error reporting.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.16 2009/02/16 21:19:06 miod Exp $	*/
d524 1
a524 1
					return (TRY_AGAIN_LATER);
@


1.16
log
@Extend the scsi_adapter minphys() callback to take a struct scsi_link *
as additional argument. This will allow intermediate layers between
scsi devices such as sd and scsi host adapters to take appropriate
action if necessary.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.15 2009/01/21 21:53:59 grange Exp $	*/
d568 1
a568 1
		if (detail > sizeof(ioprbs_errors) / sizeof(ioprbs_errors[0]))
@


1.15
log
@Replace timeout_add(msecs * hz / 1000) with timeout_add_msec(msecs).
No functional changes.

ok krw@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.14 2008/11/25 17:52:02 krw Exp $	*/
a93 1
void	ioprbsminphys(struct buf *);
d124 1
a124 1
	ioprbs_scsi_cmd, ioprbsminphys, 0, 0,
a543 7
}

void
ioprbsminphys(bp)
	struct buf *bp;
{
	minphys(bp);
@


1.14
log
@Another bunch of TRY_AGAIN_LATER -> NO_CCB when no I/O could be started.

"looks sane to me" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.13 2008/06/26 05:42:15 ray Exp $	*/
d862 1
a862 2
			timeout_add(&xs->stimeout,
			    (IOPRBS_WATCH_TIMEOUT * hz) / 1000);
d870 1
a870 2
			timeout_add(&xs->stimeout,
			    (ccb->ic_timeout * hz) / 1000);
@


1.13
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.12 2007/10/17 15:07:37 deraadt Exp $	*/
d508 1
a508 1
				return (TRY_AGAIN_LATER);
@


1.12
log
@de-abstract and just use splbio() and splx()
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.11 2006/11/28 23:59:45 dlg Exp $	*/
a43 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.11
log
@give scsi controllers a real attach args to fill in when attaching scsibus.

ok miod@@ marco@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.10 2005/12/04 04:05:25 krw Exp $	*/
d418 1
a418 1
	ioprbs_lock_t lock;
d421 1
a421 1
	lock = IOPRBS_LOCK(sc);
d514 1
a514 1
				IOPRBS_UNLOCK(sc, lock);
d529 1
a529 1
					IOPRBS_UNLOCK(sc, lock);
d550 1
a550 1
	IOPRBS_UNLOCK(sc, lock);
d793 1
a793 1
	ioprbs_lock_t lock;
d797 1
a797 1
	lock = IOPRBS_LOCK(sc);
d814 1
a814 1
	IOPRBS_UNLOCK(sc, lock);
d823 1
a823 1
	ioprbs_lock_t lock;
d827 1
a827 1
	lock = IOPRBS_LOCK(sc);
d835 1
a835 1
	IOPRBS_UNLOCK(sc, lock);
d978 1
a978 1
	ioprbs_lock_t lock;
d986 1
a986 1
	lock = IOPRBS_LOCK(sc);
d988 1
a988 1
	IOPRBS_UNLOCK(sc, lock);
d998 1
a998 1
	ioprbs_lock_t lock;
d1000 1
a1000 1
	lock = IOPRBS_LOCK(sc);
d1003 1
a1003 1
	IOPRBS_UNLOCK(sc, lock);
@


1.10
log
@Don't retry unsupported commands, or commands for invalid
targets/luns.  Same fix as gdt got for boot delays.

Don't set xs->error when returning TRY_AGAIN_LATER.

"Make sense, doesn't it?" tdeval@@, "awesome find!" marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.9 2005/09/15 05:33:39 krw Exp $	*/
d182 1
d361 4
a364 1
	config_found(&sc->sc_dv, &sc->sc_link, scsiprint);
@


1.9
log
@Don't fake MODE SENSE page 4 info inside raid drivers, just let sd
fake a geometry. Page 4 info does not get used for size information.
Eliminate now unused union scsi_disk_pages.

ok marco@@ mickey@@ pre-lock.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.8 2005/08/24 01:19:47 krw Exp $	*/
d112 1
a112 1
int	ioprbs_internal_cache_cmd(struct scsi_xfer *);
d438 1
a438 4
			if (!ioprbs_internal_cache_cmd(xs)) {
				IOPRBS_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
			}
a509 1
				xs->error = XS_DRIVER_STUFFUP;
a527 1
					xs->error = XS_TIMEOUT;
d709 1
a709 1
int
a724 4
		/*
		 * XXX Should be XS_SENSE but that would require setting up a
		 * faked sense too.
		 */
d726 1
a726 3
		xs->flags |= ITSDONE;
		scsi_done(xs);
		return (COMPLETE);
d777 1
a777 1
		return (0);
a780 1
	return (1);
@


1.8
log
@Test xs->bp before de-referencing it. Initialize it to NULL, not 0.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.7 2005/07/03 22:31:27 krw Exp $	*/
a264 16
	/* Build synthetic geometry. */
	if (sc->sc_secperunit <= 528 * 2048)		/* 528MB */
		sc->sc_nheads = 16;
	else if (sc->sc_secperunit <= 1024 * 2048)	/* 1GB */
		sc->sc_nheads = 32;
	else if (sc->sc_secperunit <= 21504 * 2048)	/* 21GB */
		sc->sc_nheads = 64;
	else if (sc->sc_secperunit <= 43008 * 2048)	/* 42GB */
		sc->sc_nheads = 128;
	else
		sc->sc_nheads = 255;

	sc->sc_nsectors = 63;
	sc->sc_ncylinders = sc->sc_secperunit / 
	    (sc->sc_nheads * sc->sc_nsectors);

a722 5
	struct {
		struct scsi_mode_header hd;
		struct scsi_blk_desc bd;
		union scsi_disk_pages dp;
	} mpd;
a775 32
	case MODE_SENSE:
		DPRINTF(("MODE SENSE tgt %d ", target));

		bzero(&mpd, sizeof mpd);
		switch (((struct scsi_mode_sense *)xs->cmd)->page) {
		case 4:
			/* scsi_disk.h says this should be 0x16 */
			mpd.dp.rigid_geometry.pg_length = 0x16;
			mpd.hd.data_length = sizeof mpd.hd -
			    sizeof mpd.hd.data_length + sizeof mpd.bd +
			    sizeof mpd.dp.rigid_geometry;
			mpd.hd.blk_desc_len = sizeof mpd.bd;

			/* XXX */
			mpd.hd.dev_spec = 0;
			_lto3b(IOPRBS_BLOCK_SIZE, mpd.bd.blklen);
			mpd.dp.rigid_geometry.pg_code = 4;
			_lto3b(sc->sc_ncylinders, mpd.dp.rigid_geometry.ncyl);
			mpd.dp.rigid_geometry.nheads = sc->sc_nheads;
			ioprbs_copy_internal_data(xs, (u_int8_t *)&mpd,
			    sizeof mpd);
			break;

		default:
			printf("%s: mode sense page %d not simulated\n",
			    sc->sc_dv.dv_xname,
			    ((struct scsi_mode_sense *)xs->cmd)->page);
			xs->error = XS_DRIVER_STUFFUP;
			return (0);
		}
		break;

d785 2
a786 2
		printf("ioprbs_internal_cache_cmd got bad opcode: %d\n",
		    xs->cmd->opcode);
@


1.7
log
@Fix data_length values in simulationed MODE SENSE page 4 responses so
that scsi_do_mode_sense() accepts them.

The data_length value does not include itself, and the pg_length value
in a mode page does not include itself or the page_code fields. We
were +1 on the former and -2 on the latter resulting in a data_length
value that was too small by one.

Eliminates 'mode sense page 5 not simulated' messages.

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.6 2005/05/23 23:26:55 tedu Exp $	*/
d611 8
a618 6
	if (err) {
		bp->b_flags |= B_ERROR;
		bp->b_error = EIO;
		bp->b_resid = bp->b_bcount;
	} else
		bp->b_resid = bp->b_bcount - letoh32(rb->transfercount);
@


1.6
log
@loose is not lose. ok deraadt tdeval and a few more typos from jfb
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.5 2004/04/12 22:12:32 jmc Exp $	*/
d803 3
a805 2
			mpd.hd.data_length = sizeof mpd.hd + sizeof mpd.bd +
			    mpd.dp.rigid_geometry.pg_length;
@


1.5
log
@removeable -> removable;
ok deraadt@@ beck@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.4 2003/04/27 11:22:52 ho Exp $	*/
d657 1
a657 1
	 * AMI controllers seem to loose the plot if you hand off lots of
@


1.4
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.3 2002/04/03 16:47:57 niklas Exp $	*/
d304 1
a304 1
	if ((letoh32(param.p.bdi.capabilities) & I2O_RBS_CAP_REMOVEABLE_MEDIA)
d306 2
a307 2
		/* sc->sc_flags = IOPRBS_REMOVEABLE; */
		fixedstr = "removeable";
@


1.3
log
@deal with ccb shortage correctly, ok mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.2 2002/03/14 01:26:53 millert Exp $	*/
d788 4
a791 3
		strcpy(inq.vendor, "I2O");
		sprintf(inq.product, "Container #%02d", target);
		strcpy(inq.revision, "   ");
@


1.2
log
@First round of __P removal in sys
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.1 2001/06/29 06:05:03 niklas Exp $	*/
d526 1
a526 2
			 * Are we out of commands, something is wrong.
			 * 
a528 2
				printf("%s: no ccb in ioprbs_scsi_cmd",
				    sc->sc_dv.dv_xname);
d530 2
a531 3
				xs->flags |= ITSDONE;
				scsi_done(xs);
				goto ready;
@


1.1
log
@Alpha-version (or is that Intel?) of the I2O random block storage driver.
Inspired by ld_iop.c from NetBSD but written by me mostly.  Tested on the
Adaptec 2100S RAID card, got it working at Usenix in a weird hackathon setup.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d104 9
a112 9
void	ioprbs_copy_internal_data __P((struct scsi_xfer *, u_int8_t *,
	    size_t));
struct scsi_xfer *ioprbs_dequeue __P((struct ioprbs_softc *));
void	ioprbs_enqueue __P((struct ioprbs_softc *, struct scsi_xfer *, int));
void	ioprbs_enqueue_ccb __P((struct ioprbs_softc *, struct ioprbs_ccb *));
int	ioprbs_exec_ccb __P((struct ioprbs_ccb *));
void	ioprbs_free_ccb __P((struct ioprbs_softc *, struct ioprbs_ccb *));
struct ioprbs_ccb *ioprbs_get_ccb __P((struct ioprbs_softc *, int));
int	ioprbs_internal_cache_cmd __P((struct scsi_xfer *));
d117 3
a119 3
int	ioprbs_start __P((struct ioprbs_ccb *));
void	ioprbs_start_ccbs __P((struct ioprbs_softc *));
void	ioprbs_timeout __P((void *));
d121 1
a121 1
void	ioprbs_watchdog __P((void *));
@


1.1.6.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.1 2001/06/29 06:05:03 niklas Exp $	*/
d104 9
a112 9
void	ioprbs_copy_internal_data(struct scsi_xfer *, u_int8_t *,
	    size_t);
struct scsi_xfer *ioprbs_dequeue(struct ioprbs_softc *);
void	ioprbs_enqueue(struct ioprbs_softc *, struct scsi_xfer *, int);
void	ioprbs_enqueue_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
int	ioprbs_exec_ccb(struct ioprbs_ccb *);
void	ioprbs_free_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
struct ioprbs_ccb *ioprbs_get_ccb(struct ioprbs_softc *, int);
int	ioprbs_internal_cache_cmd(struct scsi_xfer *);
d117 3
a119 3
int	ioprbs_start(struct ioprbs_ccb *);
void	ioprbs_start_ccbs(struct ioprbs_softc *);
void	ioprbs_timeout(void *);
d121 1
a121 1
void	ioprbs_watchdog(void *);
d526 2
a527 1
			 * We are out of commands, try again in a little while.
d530 2
d533 3
a535 2
				IOPRBS_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
@


1.1.6.2
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d788 3
a790 4
		strlcpy(inq.vendor, "I2O", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.1.2.1
log
@Merge in -current from about a week ago
@
text
@d104 9
a112 9
void	ioprbs_copy_internal_data(struct scsi_xfer *, u_int8_t *,
	    size_t);
struct scsi_xfer *ioprbs_dequeue(struct ioprbs_softc *);
void	ioprbs_enqueue(struct ioprbs_softc *, struct scsi_xfer *, int);
void	ioprbs_enqueue_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
int	ioprbs_exec_ccb(struct ioprbs_ccb *);
void	ioprbs_free_ccb(struct ioprbs_softc *, struct ioprbs_ccb *);
struct ioprbs_ccb *ioprbs_get_ccb(struct ioprbs_softc *, int);
int	ioprbs_internal_cache_cmd(struct scsi_xfer *);
d117 3
a119 3
int	ioprbs_start(struct ioprbs_ccb *);
void	ioprbs_start_ccbs(struct ioprbs_softc *);
void	ioprbs_timeout(void *);
d121 1
a121 1
void	ioprbs_watchdog(void *);
@


1.1.2.2
log
@Sync the SMP branch with 3.3
@
text
@d526 2
a527 1
			 * We are out of commands, try again in a little while.
d530 2
d533 3
a535 2
				IOPRBS_UNLOCK(sc, lock);
				return (TRY_AGAIN_LATER);
@


1.1.2.3
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ioprbs.c,v 1.1.2.2 2003/03/28 00:38:10 niklas Exp $	*/
d788 3
a790 4
		strlcpy(inq.vendor, "I2O", sizeof inq.vendor);
		snprintf(inq.product, sizeof inq.product, "Container #%02d",
		    target);
		strlcpy(inq.revision, "   ", sizeof inq.revision);
@


1.1.2.4
log
@Merge with the trunk
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d304 1
a304 1
	if ((letoh32(param.p.bdi.capabilities) & I2O_RBS_CAP_REMOVABLE_MEDIA)
d306 2
a307 2
		/* sc->sc_flags = IOPRBS_REMOVABLE; */
		fixedstr = "removable";
@


