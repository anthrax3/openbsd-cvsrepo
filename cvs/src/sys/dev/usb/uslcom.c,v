head	1.39;
access;
symbols
	OPENBSD_6_1:1.39.0.4
	OPENBSD_6_1_BASE:1.39
	OPENBSD_6_0:1.38.0.4
	OPENBSD_6_0_BASE:1.38
	OPENBSD_5_9:1.37.0.2
	OPENBSD_5_9_BASE:1.37
	OPENBSD_5_8:1.36.0.4
	OPENBSD_5_8_BASE:1.36
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.31.0.4
	OPENBSD_5_6_BASE:1.31
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.28.0.2
	OPENBSD_5_4_BASE:1.28
	OPENBSD_5_3:1.27.0.2
	OPENBSD_5_3_BASE:1.27
	OPENBSD_5_2:1.24.0.4
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.2
	OPENBSD_5_0:1.23.0.2
	OPENBSD_5_0_BASE:1.23
	OPENBSD_4_9:1.22.0.2
	OPENBSD_4_9_BASE:1.22
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.8
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.4
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.2
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.17.0.2
	OPENBSD_4_3_BASE:1.17
	OPENBSD_4_2:1.13.0.2
	OPENBSD_4_2_BASE:1.13
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.3.0.4
	OPENBSD_4_0_BASE:1.3;
locks; strict;
comment	@ * @;


1.39
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.38;
commitid	blfE5YU3eGM81J65;

1.38
date	2016.03.31.12.41.46;	author reyk;	state Exp;
branches;
next	1.37;
commitid	JLDwgU2VmbBbNVWO;

1.37
date	2016.01.07.12.53.37;	author mpi;	state Exp;
branches;
next	1.36;
commitid	cbOY1YhZQayIAejH;

1.36
date	2015.06.18.10.47.44;	author jsg;	state Exp;
branches;
next	1.35;
commitid	humDZ9Ng8Je99ofk;

1.35
date	2015.06.16.05.08.55;	author jsg;	state Exp;
branches;
next	1.34;
commitid	9pZ0Dhh16w4reyPl;

1.34
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.33;
commitid	p4LJxGKbi0BU2cG6;

1.33
date	2014.11.23.21.18.46;	author sasano;	state Exp;
branches;
next	1.32;
commitid	SDztAvInuWaMeVVC;

1.32
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.31;
commitid	Qb045HZ5OhQfU69H;

1.31
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.30;
commitid	AGVMSdzbrCHVAlSG;

1.30
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.07.10.34.02;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2012.09.29.12.06.27;	author jsg;	state Exp;
branches;
next	1.26;

1.26
date	2012.09.29.10.47.37;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2012.09.29.06.45.53;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2011.09.16.13.36.18;	author yuo;	state Exp;
branches;
next	1.23;

1.23
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2008.03.22.02.50.02;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2008.03.18.12.37.41;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.11.24.10.52.12;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2007.10.08.03.10.42;	author jcs;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.08.03.08.49;	author jcs;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2007.02.17.01.47.47;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.29.02.58.15;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.29.02.15.06;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.39
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: uslcom.c,v 1.38 2016/03/31 12:41:46 reyk Exp $	*/

/*
 * Copyright (c) 2006 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/tty.h>
#include <sys/device.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#ifdef USLCOM_DEBUG
#define DPRINTFN(n, x)  do { if (uslcomdebug > (n)) printf x; } while (0)
int	uslcomdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define USLCOMBUFSZ		256
#define USLCOM_IFACE_NO		0

#define USLCOM_SET_DATA_BITS(x)	(x << 8)

#define USLCOM_WRITE		0x41
#define USLCOM_READ		0xc1

#define USLCOM_UART		0x00
#define USLCOM_SET_BAUD_DIV	0x01
#define USLCOM_DATA		0x03
#define USLCOM_BREAK		0x05
#define USLCOM_CTRL		0x07
#define USLCOM_SET_FLOW		0x13
#define USLCOM_SET_BAUD_RATE	0x1e

#define USLCOM_UART_DISABLE	0x00
#define USLCOM_UART_ENABLE	0x01

#define USLCOM_CTRL_DTR_ON	0x0001	
#define USLCOM_CTRL_DTR_SET	0x0100
#define USLCOM_CTRL_RTS_ON	0x0002
#define USLCOM_CTRL_RTS_SET	0x0200
#define USLCOM_CTRL_CTS		0x0010
#define USLCOM_CTRL_DSR		0x0020
#define USLCOM_CTRL_DCD		0x0080

#define USLCOM_BAUD_REF		3686400 /* 3.6864 MHz */

#define USLCOM_STOP_BITS_1	0x00
#define USLCOM_STOP_BITS_2	0x02

#define USLCOM_PARITY_NONE	0x00
#define USLCOM_PARITY_ODD	0x10
#define USLCOM_PARITY_EVEN	0x20

#define USLCOM_BREAK_OFF	0x00
#define USLCOM_BREAK_ON		0x01

/* USLCOM_SET_FLOW values - 1st word */
#define USLCOM_FLOW_DTR_ON	0x00000001 /* DTR static active */
#define USLCOM_FLOW_CTS_HS	0x00000008 /* CTS handshake */
/* USLCOM_SET_FLOW values - 2nd word */
#define USLCOM_FLOW_RTS_ON	0x00000040 /* RTS static active */
#define USLCOM_FLOW_RTS_HS	0x00000080 /* RTS handshake */

struct uslcom_softc {
	struct device		 sc_dev;
	struct usbd_device	*sc_udev;
	struct usbd_interface	*sc_iface;
	struct device		*sc_subdev;

	u_char			 sc_msr;
	u_char			 sc_lsr;
};

void	uslcom_get_status(void *, int portno, u_char *lsr, u_char *msr);
void	uslcom_set(void *, int, int, int);
int	uslcom_param(void *, int, struct termios *);
int	uslcom_open(void *sc, int portno);
void	uslcom_close(void *, int);
void	uslcom_break(void *sc, int portno, int onoff);

struct ucom_methods uslcom_methods = {
	uslcom_get_status,
	uslcom_set,
	uslcom_param,
	NULL,
	uslcom_open,
	uslcom_close,
	NULL,
	NULL,
};

static const struct usb_devno uslcom_devs[] = {
	{ USB_VENDOR_ARUBA,		USB_PRODUCT_ARUBA_CP210X },
	{ USB_VENDOR_BALTECH,		USB_PRODUCT_BALTECH_CARDREADER },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_5000CT2 },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_5500PACA },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_5500PCU },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_560884 },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_5800PC },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_C5000CT2 },
	{ USB_VENDOR_CLIPSAL,		USB_PRODUCT_CLIPSAL_L51xx },
	{ USB_VENDOR_CORSAIR,		USB_PRODUCT_CORSAIR_CP210X },
	{ USB_VENDOR_DATAAPEX,		USB_PRODUCT_DATAAPEX_MULTICOM },
	{ USB_VENDOR_DELL,		USB_PRODUCT_DELL_DW700 },
	{ USB_VENDOR_DIGIANSWER,	USB_PRODUCT_DIGIANSWER_ZIGBEE802154 },
	{ USB_VENDOR_DYNASTREAM,	USB_PRODUCT_DYNASTREAM_ANT2USB },
	{ USB_VENDOR_DYNASTREAM,	USB_PRODUCT_DYNASTREAM_ANTDEVBOARD },
	{ USB_VENDOR_DYNASTREAM,	USB_PRODUCT_DYNASTREAM_ANTDEVBOARD2 },
	{ USB_VENDOR_ELV,		USB_PRODUCT_ELV_USBI2C },
	{ USB_VENDOR_FESTO,		USB_PRODUCT_FESTO_CMSP },
	{ USB_VENDOR_FESTO,		USB_PRODUCT_FESTO_CPX_USB },
	{ USB_VENDOR_FOXCONN,		USB_PRODUCT_FOXCONN_PIRELLI_DP_L10 },
	{ USB_VENDOR_FOXCONN,		USB_PRODUCT_FOXCONN_TCOM_TC_300 },
	{ USB_VENDOR_GEMPLUS,		USB_PRODUCT_GEMPLUS_PROXPU },
	{ USB_VENDOR_JABLOTRON,		USB_PRODUCT_JABLOTRON_PC60B },
	{ USB_VENDOR_KAMSTRUP,		USB_PRODUCT_KAMSTRUP_MBUS_250D },
	{ USB_VENDOR_KAMSTRUP,		USB_PRODUCT_KAMSTRUP_OPTICALEYE },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M121 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M218A },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M219 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M233 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M235 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M335 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M336 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M350 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M371 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M411 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M425 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M455A },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M465 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M475A },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M625A },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M642A },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M648 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M737 },
	{ USB_VENDOR_LAKESHORE,		USB_PRODUCT_LAKESHORE_M776 },
	{ USB_VENDOR_LINKINSTRUMENTS,	USB_PRODUCT_LINKINSTRUMENTS_MSO19 },
	{ USB_VENDOR_LINKINSTRUMENTS,	USB_PRODUCT_LINKINSTRUMENTS_MSO28 },
	{ USB_VENDOR_LINKINSTRUMENTS,	USB_PRODUCT_LINKINSTRUMENTS_MSO28_2 },
	{ USB_VENDOR_MEI,		USB_PRODUCT_MEI_CASHFLOW_SC },
	{ USB_VENDOR_MEI,		USB_PRODUCT_MEI_S2000 },
	{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_M7100 },
	{ USB_VENDOR_OREGONSCI,		USB_PRODUCT_OREGONSCI_OWL_CM160 },
	{ USB_VENDOR_OWEN,		USB_PRODUCT_OWEN_AC4 },
	{ USB_VENDOR_PHILIPS,		USB_PRODUCT_PHILIPS_ACE1001 },
	{ USB_VENDOR_RENESAS,		USB_PRODUCT_RENESAS_RX610 },
	{ USB_VENDOR_SEL,		USB_PRODUCT_SEL_C662 },
	{ USB_VENDOR_SELUXIT,		USB_PRODUCT_SELUXIT_RF },
	{ USB_VENDOR_SIEMENS4,		USB_PRODUCT_SIEMENS4_RUGGEDCOM },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AC_SERV_CAN },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AC_SERV_CIS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AC_SERV_IBUS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AC_SERV_OBD },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AEROCOMM },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AMBER_AMB2560 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_ARGUSISP },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_ARKHAM_DS101_A },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_ARKHAM_DS101_M },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_ARYGON_MIFARE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AVIT_USB_TTL },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_BALLUFF_RFID },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_BEI_VCP },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_BSM7DUSB },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_B_G_H3000 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_C2_EDGE_MODEM },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CELDEVKIT },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_1 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_2 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_3 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CRUMB128 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CYGNAL },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CYGNAL_DEBUG },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CYGNAL_GPS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_DEGREECONT },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_DEKTEK_DTAPLUS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_DESKTOPMOBILE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_EDG1228 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_EM357 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_EM357LR },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_EMS_C1007 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_GSM2228 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_HAMLINKUSB },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_HUBZ },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_IMS_USB_RS422 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_INFINITY_MIC },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_INSYS_MODEM },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_IPLINK1220 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_IRZ_SG10 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_KCF_PRN },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_KETRA_N1 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_KYOCERA_GPS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_LIPOWSKY_HARP },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_LIPOWSKY_JTAG },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_LIPOWSKY_LIN },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_MC35PU },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_MJS_TOSLINK },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_MMB_ZIGBEE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_MSD_DASHHAWK },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_MULTIPLEX_RC },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_OPTRIS_MSPRO },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_PII_ZIGBEE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_PLUGDRIVE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_POLOLU },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_PREON32 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_PROCYON_AVS },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_RIGBLASTER },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_RIGTALK },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_SB_PARAMOUNT_ME },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_SB_PARAMOUNT_ME2 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_SUUNTO },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_TAMSMASTER },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_TELEGESIS_ETRX2 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_TRACIENT },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_TRAQMATE },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_USBCOUNT50 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_USBPULSE100 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_USBSCOPE50 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_USBWAVE12 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_VSTABI },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_WAVIT },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_ZEPHYR_BIO },
	{ USB_VENDOR_SILABS2,		USB_PRODUCT_SILABS2_DCU11CLONE },
	{ USB_VENDOR_SILABS3,		USB_PRODUCT_SILABS3_GPRS_MODEM },
	{ USB_VENDOR_SILABS4,		USB_PRODUCT_SILABS4_100EU_MODEM },
	{ USB_VENDOR_SILABS5,		USB_PRODUCT_SILABS5_EM358X },
	{ USB_VENDOR_SYNTECH,		USB_PRODUCT_SYNTECH_CIPHERLAB100 },
	{ USB_VENDOR_USI,		USB_PRODUCT_USI_MC60 },
	{ USB_VENDOR_VAISALA,		USB_PRODUCT_VAISALA_USBINSTCABLE },
	{ USB_VENDOR_VOTI,		USB_PRODUCT_VOTI_SELETEK_1 },
	{ USB_VENDOR_VOTI,		USB_PRODUCT_VOTI_SELETEK_2 },
	{ USB_VENDOR_WAGO,		USB_PRODUCT_WAGO_SERVICECABLE },
	{ USB_VENDOR_WAVESENSE,		USB_PRODUCT_WAVESENSE_JAZZ },
	{ USB_VENDOR_WIENERPLEINBAUS,	USB_PRODUCT_WIENERPLEINBAUS_CML },
	{ USB_VENDOR_WIENERPLEINBAUS,	USB_PRODUCT_WIENERPLEINBAUS_MPOD },
	{ USB_VENDOR_WIENERPLEINBAUS,	USB_PRODUCT_WIENERPLEINBAUS_PL512 },
	{ USB_VENDOR_WIENERPLEINBAUS,	USB_PRODUCT_WIENERPLEINBAUS_RCM },
	{ USB_VENDOR_WMR,		USB_PRODUCT_WMR_RIGBLASTER },
};

int uslcom_match(struct device *, void *, void *);
void uslcom_attach(struct device *, struct device *, void *);
int uslcom_detach(struct device *, int);

struct cfdriver uslcom_cd = {
	NULL, "uslcom", DV_DULL
};

const struct cfattach uslcom_ca = {
	sizeof(struct uslcom_softc), uslcom_match, uslcom_attach, uslcom_detach
};

int
uslcom_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return UMATCH_NONE;

	return (usb_lookup(uslcom_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
uslcom_attach(struct device *parent, struct device *self, void *aux)
{
	struct uslcom_softc *sc = (struct uslcom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ucom_attach_args uca;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status error;
	int i;

	bzero(&uca, sizeof(uca));
	sc->sc_udev = uaa->device;

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, USLCOM_IFACE_NO,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	id = usbd_get_interface_descriptor(sc->sc_iface);

	uca.bulkin = uca.bulkout = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor found for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			uca.bulkin = ed->bEndpointAddress;
		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			uca.bulkout = ed->bEndpointAddress;
	}

	if (uca.bulkin == -1 || uca.bulkout == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	uca.ibufsize = USLCOMBUFSZ;
	uca.obufsize = USLCOMBUFSZ;
	uca.ibufsizepad = USLCOMBUFSZ;
	uca.opkthdrlen = 0;
	uca.device = sc->sc_udev;
	uca.iface = sc->sc_iface;
	uca.methods = &uslcom_methods;
	uca.arg = sc;
	uca.info = NULL;

	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
}

int
uslcom_detach(struct device *self, int flags)
{
	struct uslcom_softc *sc = (struct uslcom_softc *)self;
	int rv = 0;

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

int
uslcom_open(void *vsc, int portno)
{
	struct uslcom_softc *sc = vsc;
	usb_device_request_t req;
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_UART;
	USETW(req.wValue, USLCOM_UART_ENABLE);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	return (0);
}

void
uslcom_close(void *vsc, int portno)
{
	struct uslcom_softc *sc = vsc;
	usb_device_request_t req;

	if (usbd_is_dying(sc->sc_udev))
		return;

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_UART;
	USETW(req.wValue, USLCOM_UART_DISABLE);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	usbd_do_request(sc->sc_udev, &req, NULL);
}

void
uslcom_set(void *vsc, int portno, int reg, int onoff)
{
	struct uslcom_softc *sc = vsc;
	usb_device_request_t req;
	int ctl;

	switch (reg) {
	case UCOM_SET_DTR:
		ctl = onoff ? USLCOM_CTRL_DTR_ON : 0;
		ctl |= USLCOM_CTRL_DTR_SET;
		break;
	case UCOM_SET_RTS:
		ctl = onoff ? USLCOM_CTRL_RTS_ON : 0;
		ctl |= USLCOM_CTRL_RTS_SET;
		break;
	case UCOM_SET_BREAK:
		uslcom_break(sc, portno, onoff);
		return;
	default:
		return;
	}
	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_CTRL;
	USETW(req.wValue, ctl);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	usbd_do_request(sc->sc_udev, &req, NULL);
}

int
uslcom_param(void *vsc, int portno, struct termios *t)
{
	struct uslcom_softc *sc = (struct uslcom_softc *)vsc;
	usbd_status err;
	usb_device_request_t req;
	uint32_t baudrate, flowctrl[4];
	int data;

	if (t->c_ospeed <= 0 || t->c_ospeed > 921600)
		return (EINVAL);

	baudrate = t->c_ospeed;
	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_SET_BAUD_RATE;
	USETW(req.wValue, 0);
	USETW(req.wIndex, portno);
	USETW(req.wLength, sizeof(baudrate));
	err = usbd_do_request(sc->sc_udev, &req, &baudrate);
	if (err)
		return (EIO);

	if (ISSET(t->c_cflag, CSTOPB))
		data = USLCOM_STOP_BITS_2;
	else
		data = USLCOM_STOP_BITS_1;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			data |= USLCOM_PARITY_ODD;
		else
			data |= USLCOM_PARITY_EVEN;
	} else
		data |= USLCOM_PARITY_NONE;
	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		data |= USLCOM_SET_DATA_BITS(5);
		break;
	case CS6:
		data |= USLCOM_SET_DATA_BITS(6);
		break;
	case CS7:
		data |= USLCOM_SET_DATA_BITS(7);
		break;
	case CS8:
		data |= USLCOM_SET_DATA_BITS(8);
		break;
	}

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_DATA;
	USETW(req.wValue, data);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		return (EIO);

	if (ISSET(t->c_cflag, CRTSCTS)) {
		/*  rts/cts flow ctl */
		flowctrl[0] = htole32(USLCOM_FLOW_DTR_ON | USLCOM_FLOW_CTS_HS);
		flowctrl[1] = htole32(USLCOM_FLOW_RTS_HS);
	} else {
		/* disable flow ctl */
		flowctrl[0] = htole32(USLCOM_FLOW_DTR_ON);
		flowctrl[1] = htole32(USLCOM_FLOW_RTS_ON);
	}
	flowctrl[2] = 0;
	flowctrl[3] = 0;

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_SET_FLOW;
	USETW(req.wValue, 0);
	USETW(req.wIndex, portno);
	USETW(req.wLength, sizeof(flowctrl));
	err = usbd_do_request(sc->sc_udev, &req, flowctrl);
	if (err)
		return (EIO);

	return (0);
}

void
uslcom_get_status(void *vsc, int portno, u_char *lsr, u_char *msr)
{
	struct uslcom_softc *sc = vsc;
	
	if (msr != NULL)
		*msr = sc->sc_msr;
	if (lsr != NULL)
		*lsr = sc->sc_lsr;
}

void
uslcom_break(void *vsc, int portno, int onoff)
{
	struct uslcom_softc *sc = vsc;
	usb_device_request_t req;
	int brk = onoff ? USLCOM_BREAK_ON : USLCOM_BREAK_OFF;	

	req.bmRequestType = USLCOM_WRITE;
	req.bRequest = USLCOM_BREAK;
	USETW(req.wValue, brk);
	USETW(req.wIndex, portno);
	USETW(req.wLength, 0);
	usbd_do_request(sc->sc_udev, &req, NULL);
}
@


1.38
log
@The USB console port on Aruba 7xxx wireless controllers shows up as
"Aruba Networks USB to UART Bridge Controller".  It uses a Silabs
CP210x chip with a modified vendor Id that is supported by uslcom(4).

OK jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.37 2016/01/07 12:53:37 mpi Exp $	*/
a40 1
#define USLCOM_CONFIG_INDEX	0
d279 1
a279 1
	if (uaa->iface != NULL)
a298 7

	if (usbd_set_config_index(sc->sc_udev, USLCOM_CONFIG_INDEX, 1) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}
@


1.37
log
@Rename some wrongly defined *_CONFIG_NO into *_CONFIG_INDEX.

Configuration indexes start a 0, for the default one, while
numbers correspond to the 'bConfigurationValue' field of a
config descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.36 2015/06/18 10:47:44 jsg Exp $	*/
d116 1
@


1.36
log
@CP2110 is handled by uslhcom not uslcom
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.35 2015/06/16 05:08:55 jsg Exp $	*/
d41 1
a41 1
#define USLCOM_CONFIG_NO	0
d300 1
a300 1
	if (usbd_set_config_index(sc->sc_udev, USLCOM_CONFIG_NO, 1) != 0) {
@


1.35
log
@Add a uslcom id for the Netgear M7100 console from Andrew Daugherity.
Add some additional uslcom ids found in the Linux driver while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.34 2015/03/14 03:38:50 jsg Exp $	*/
a191 1
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP2110 },
@


1.34
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.33 2014/11/23 21:18:46 sasano Exp $	*/
d124 1
d140 19
d164 2
d169 3
d188 1
d192 1
d201 2
d204 1
d206 1
d212 2
d220 1
d224 2
d227 1
d232 1
d248 1
d252 2
d260 1
@


1.33
log
@USB_VENDOR_SILABS:USB_PRODUCT_SILABS_CP210X_4(0x10c4:0xea80) is
not CP210x family. removed.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.32 2014/11/18 23:55:01 krw Exp $	*/
a21 1
#include <sys/conf.h>
@


1.32
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.31 2014/07/12 21:24:33 mpi Exp $	*/
a166 1
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_4 },
@


1.31
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.30 2013/11/15 08:25:31 pirofti Exp $	*/
a30 1
#include <dev/usb/usbdevs.h>
@


1.30
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.29 2013/11/07 10:34:02 pirofti Exp $	*/
d224 10
a233 15
int uslcom_match(struct device *, void *, void *); 
void uslcom_attach(struct device *, struct device *, void *); 
int uslcom_detach(struct device *, int); 
int uslcom_activate(struct device *, int); 

struct cfdriver uslcom_cd = { 
	NULL, "uslcom", DV_DULL 
}; 

const struct cfattach uslcom_ca = { 
	sizeof(struct uslcom_softc), 
	uslcom_match, 
	uslcom_attach, 
	uslcom_detach, 
	uslcom_activate, 
a329 13
}

int
uslcom_activate(struct device *self, int act)
{
	struct uslcom_softc *sc = (struct uslcom_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.29
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.28 2013/04/15 09:23:02 mglocker Exp $	*/
a340 1
	int rv = 0;
a343 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d347 1
a347 1
	return (rv);
@


1.28
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.27 2012/09/29 12:06:27 jsg Exp $	*/
a96 2

	u_char			 sc_dying;
d270 1
a270 1
		sc->sc_dying = 1;
d280 1
a280 1
		sc->sc_dying = 1;
d292 1
a292 1
			sc->sc_dying = 1;
d306 1
a306 1
		sc->sc_dying = 1;
d347 1
a347 1
		sc->sc_dying = 1;
d360 1
a360 1
	if (sc->sc_dying)
d381 1
a381 1
	if (sc->sc_dying)
@


1.27
log
@add support for hardware flow control, from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.26 2012/09/29 10:47:37 jsg Exp $	*/
d91 2
a92 2
	usbd_device_handle	 sc_udev;
	usbd_interface_handle	 sc_iface;
@


1.26
log
@add some uslcom devices from FreeBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.25 2012/09/29 06:45:53 jsg Exp $	*/
d56 1
d82 6
d430 1
a430 1
	uint32_t baudrate;
d481 1
a481 3
#if 0
	/* XXX flow control */
	if (ISSET(t->c_cflag, CRTSCTS))
d483 2
a484 2
	} else if (ISSET(t->c_iflag, IXON|IXOFF)) {
		/*  xon/xoff flow ctl */
d487 2
d490 11
a500 1
#endif
@


1.25
log
@From Gavin Atkinson in FreeBSD SVN rev 238778:

The baud rate on CP1201/2/3 devices can be set in one of two ways:
 - The USLCOM_SET_BAUD_DIV command (0x01)
 - The USLCOM_SET_BAUD_RATE command (0x13)

Devices based on the CP1204 will only accept the latter command, and ignore
the former.  As the latter command works on all chips that this driver
supports, switch to always using it.

A slight confusion here is that the previously used command was incorrectly
named USLCOM_BAUD_RATE - even though we no longer use it, rename it to
USLCOM_SET_BAUD_DIV to closer match the name used in the datasheet.

This change reflects a similar change made in the Linux driver, which was
submitted by preston.fick at silabs.com, and has been tested on all of the
uslcom(4) devices I have to hand.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.24 2011/09/16 13:36:18 yuo Exp $	*/
d114 2
d117 8
d126 6
a131 1
	{ USB_VENDOR_DYNASTREAM,	USB_PRODUCT_DYNASTREAM_ANT2USB },
d134 16
d151 6
a156 1
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_AEROCOMM },
d158 2
d162 2
d165 3
d169 1
d172 5
d178 2
d184 4
d189 1
d192 4
a195 1
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_SUNNTO },
d202 3
d207 2
d210 7
a216 1
	{ USB_VENDOR_VAISALA,		USB_PRODUCT_VAISALA_USBINSTCABLE }
@


1.24
log
@add Vaisala's "USB instrument cable" entry
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.23 2011/07/03 15:47:17 matthew Exp $	*/
d52 1
a52 1
#define USLCOM_BAUD_RATE	0x01	
d56 1
d69 1
a69 2

#define USLCOM_BAUD_REF		0x384000
d353 1
d359 1
d361 2
a362 2
	req.bRequest = USLCOM_BAUD_RATE;
	USETW(req.wValue, USLCOM_BAUD_REF / t->c_ospeed);
d364 2
a365 2
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
@


1.23
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.22 2011/01/25 20:03:36 jakemsr Exp $	*/
d145 2
a146 1
	{ USB_VENDOR_USI,		USB_PRODUCT_USI_MC60 }
@


1.22
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.21 2010/09/24 08:33:59 yuo Exp $	*/
a267 3
	case DVACT_ACTIVATE:
		break;

@


1.21
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.20 2009/10/13 19:33:19 pirofti Exp $	*/
a243 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
	
a256 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.19 2008/03/22 02:50:02 jsg Exp $	*/
a255 1
	sc->sc_dying = 1;
@


1.19
log
@Add a bunch of uslcom devices found in the Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.18 2008/03/18 12:37:41 jsg Exp $	*/
d151 1
a151 1
int uslcom_activate(struct device *, enum devact); 
d269 1
a269 1
uslcom_activate(struct device *self, enum devact act)
@


1.18
log
@IRZ MC35pu GSM Terminal
From/tested by Sergey Prysiazhnyi <apelsin@@atmnis.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.17 2007/11/24 10:52:12 jsg Exp $	*/
d114 1
d116 2
d120 4
d127 1
d134 2
a135 2
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_1 },
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X_2 },
d137 1
d139 4
d144 1
@


1.17
log
@Allow for any baud rate within a range rather than
having a fixed list of rates.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.16 2007/10/11 18:33:15 deraadt Exp $	*/
d124 1
@


1.16
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.15 2007/10/08 03:10:42 jcs Exp $	*/
d349 1
a349 24
	switch (t->c_ospeed) {
	case 600:
	case 1200:
	case 1800:
	case 2400:
	case 4800:
	case 9600:
	case 19200:
	case 38400:
	case 57600:
	case 115200:
	case 230400:
	case 460800:
	case 921600:
		req.bmRequestType = USLCOM_WRITE;
		req.bRequest = USLCOM_BAUD_RATE;
		USETW(req.wValue, USLCOM_BAUD_REF / t->c_ospeed);
		USETW(req.wIndex, portno);
		USETW(req.wLength, 0);
		err = usbd_do_request(sc->sc_udev, &req, NULL);
		if (err)
			return (EIO);
		break;
	default:
d351 9
a359 1
	}
@


1.15
log
@attach uslcom to the track systems traqmate
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.14 2007/10/08 03:08:49 jcs Exp $	*/
a170 1
	char *devinfop;
a174 3
	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.14
log
@support 230400 speed
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.13 2007/06/14 10:11:16 mbalmer Exp $	*/
d128 1
@


1.13
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.12 2007/06/13 06:25:03 mbalmer Exp $	*/
d363 1
@


1.12
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.11 2007/06/12 16:26:37 mbalmer Exp $	*/
d132 16
a147 1
USB_DECLARE_DRIVER(uslcom);
@


1.11
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.10 2007/06/10 14:49:01 mbalmer Exp $	*/
d83 4
a86 4
	struct device		sc_dev;
	usbd_device_handle	sc_udev;
	usbd_interface_handle	sc_iface;
	struct device *		sc_subdev;
d88 2
a89 2
	u_char			sc_msr;
	u_char			sc_lsr;
d91 1
a91 1
	u_char			sc_dying;
@


1.10
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.9 2007/06/10 10:53:49 mbalmer Exp $	*/
d86 1
a86 1
	device_ptr_t		sc_subdev;
d242 1
a242 1
uslcom_activate(device_ptr_t self, enum devact act)
@


1.9
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.8 2007/06/06 19:25:50 mk Exp $	*/
d161 1
a161 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d166 1
a166 1
		    USBDEVNAME(sc->sc_dev));
d176 1
a176 1
		    USBDEVNAME(sc->sc_dev));
d188 1
a188 1
			    USBDEVNAME(sc->sc_dev), i);
d202 1
a202 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
@


1.8
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.7 2007/06/05 08:43:56 mbalmer Exp $	*/
d218 1
a218 1
	    USBDEV(sc->sc_dev));
d236 1
a236 1
			   USBDEV(sc->sc_dev));
@


1.7
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.6 2007/05/27 04:00:25 jsg Exp $	*/
d83 1
a83 1
	USBBASEDEVICE		sc_dev;
@


1.6
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.5 2007/05/21 05:40:28 jsg Exp $	*/
d94 6
a99 6
Static void	uslcom_get_status(void *, int portno, u_char *lsr, u_char *msr);
Static void	uslcom_set(void *, int, int, int);
Static int	uslcom_param(void *, int, struct termios *);
Static int	uslcom_open(void *sc, int portno);
Static void	uslcom_close(void *, int);
Static void	uslcom_break(void *sc, int portno, int onoff);
d260 1
a260 1
Static int
d282 1
a282 1
Static void
d299 1
a299 1
Static void
d329 1
a329 1
Static int
@


1.5
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.4 2007/02/17 01:47:47 jsg Exp $	*/
d134 2
a135 1
USB_MATCH(uslcom)
d137 1
a137 1
	USB_MATCH_START(uslcom, uaa);
d146 2
a147 1
USB_ATTACH(uslcom)
d149 2
a150 1
	USB_ATTACH_START(uslcom, sc, uaa);
d161 1
a161 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d168 1
a168 1
		USB_ATTACH_ERROR_RETURN;
d178 1
a178 1
		USB_ATTACH_ERROR_RETURN;
d190 1
a190 1
			USB_ATTACH_ERROR_RETURN;
d204 1
a204 1
		USB_ATTACH_ERROR_RETURN;
a220 2

	USB_ATTACH_SUCCESS_RETURN;
d223 2
a224 1
USB_DETACH(uslcom)
d226 1
a226 1
	USB_DETACH_START(uslcom, sc);
@


1.4
log
@Add some device ids found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.3 2006/06/23 06:27:12 miod Exp $	*/
d35 1
a35 1
#define DPRINTFN(n, x)  do { if (uslcomdebug > (n)) logprintf x; } while (0)
@


1.3
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.2 2006/04/29 02:58:15 jsg Exp $	*/
d113 1
d116 1
d121 3
d125 2
a126 1
	{ USB_VENDOR_SILABS,		USB_PRODUCT_SILABS_CP210X },
@


1.2
log
@Add a close method to send the shutdown command, which presumably
put the adapter in a low power usage state.
@
text
@d1 1
a1 1
/*	$OpenBSD: uslcom.c,v 1.1 2006/04/29 02:15:06 jsg Exp $	*/
d242 1
a242 1
		return (EOPNOTSUPP);
@


1.1
log
@Driver for Silicon Laboratories CP2101/CP2102 based serial adapters.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d98 1
d107 1
a107 1
	NULL,
d273 17
@

