head	1.123;
access;
symbols
	OPENBSD_6_2:1.123.0.2
	OPENBSD_6_2_BASE:1.123
	OPENBSD_6_1:1.122.0.4
	OPENBSD_6_1_BASE:1.122
	OPENBSD_6_0:1.119.0.4
	OPENBSD_6_0_BASE:1.119
	OPENBSD_5_9:1.117.0.2
	OPENBSD_5_9_BASE:1.117
	OPENBSD_5_8:1.112.0.4
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.111.0.2
	OPENBSD_5_7_BASE:1.111
	OPENBSD_5_6:1.109.0.4
	OPENBSD_5_6_BASE:1.109
	OPENBSD_5_5:1.104.0.4
	OPENBSD_5_5_BASE:1.104
	OPENBSD_5_4:1.103.0.2
	OPENBSD_5_4_BASE:1.103
	OPENBSD_5_3:1.101.0.4
	OPENBSD_5_3_BASE:1.101
	OPENBSD_5_2:1.101.0.2
	OPENBSD_5_2_BASE:1.101
	OPENBSD_5_1_BASE:1.100
	OPENBSD_5_1:1.100.0.2
	OPENBSD_5_0:1.99.0.2
	OPENBSD_5_0_BASE:1.99
	OPENBSD_4_9:1.98.0.2
	OPENBSD_4_9_BASE:1.98
	OPENBSD_4_8:1.94.0.4
	OPENBSD_4_8_BASE:1.94
	OPENBSD_4_7:1.94.0.2
	OPENBSD_4_7_BASE:1.94
	OPENBSD_4_6:1.92.0.8
	OPENBSD_4_6_BASE:1.92
	OPENBSD_4_5:1.92.0.4
	OPENBSD_4_5_BASE:1.92
	OPENBSD_4_4:1.92.0.2
	OPENBSD_4_4_BASE:1.92
	OPENBSD_4_3:1.91.0.2
	OPENBSD_4_3_BASE:1.91
	OPENBSD_4_2:1.86.0.2
	OPENBSD_4_2_BASE:1.86
	OPENBSD_4_1:1.79.0.2
	OPENBSD_4_1_BASE:1.79
	OPENBSD_4_0:1.76.0.4
	OPENBSD_4_0_BASE:1.76
	OPENBSD_3_9:1.68.0.2
	OPENBSD_3_9_BASE:1.68
	OPENBSD_3_8:1.64.0.2
	OPENBSD_3_8_BASE:1.64
	OPENBSD_3_7:1.59.0.2
	OPENBSD_3_7_BASE:1.59;
locks; strict;
comment	@ * @;


1.123
date	2017.07.21.15.55.04;	author stsp;	state Exp;
branches;
next	1.122;
commitid	E2Q6PFAoBX1KLJb7;

1.122
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.121;
commitid	x5RWYO05Q3UFL5Oq;

1.121
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.120;
commitid	VyLWTsbepAOk7VQM;

1.120
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.119;
commitid	xlY19nmD0cBL53l1;

1.119
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.118;
commitid	gWZDkudwxydTq8x4;

1.118
date	2016.03.17.21.36.48;	author krw;	state Exp;
branches;
next	1.117;
commitid	idWTuX14jOpqz25n;

1.117
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.116;
commitid	fbhqfhfdKxBcsetK;

1.116
date	2015.11.25.03.09.59;	author dlg;	state Exp;
branches;
next	1.115;
commitid	B0kwmVGiD5DVx4kv;

1.115
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.114;
commitid	5gdEnqVoJuTuwdTu;

1.114
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.113;
commitid	YT6fyIEviv9qwbl6;

1.113
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.112;
commitid	pwYnMC1gOKohmeGw;

1.112
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.111;
commitid	MVWrtktB46JRxFWT;

1.111
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.110;
commitid	Hly9lJn6CNMylcFu;

1.110
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.109;
commitid	yM2VFFhpDTeFQlve;

1.109
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.108;
commitid	Pclvgy2Z4XV9hveD;

1.108
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.107;
commitid	OBNa5kfxQ2UXoiIw;

1.107
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.106;
commitid	b0VSac5dnnsxcDao;

1.106
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.105;

1.105
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.104;

1.104
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.103;

1.103
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.102;

1.102
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.100;

1.100
date	2011.09.18.23.24.12;	author krw;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.98;

1.98
date	2010.12.17.22.38.54;	author jasper;	state Exp;
branches;
next	1.97;

1.97
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.96;

1.96
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.95;

1.95
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.94;

1.94
date	2009.11.21.14.18.34;	author deraadt;	state Exp;
branches;
next	1.93;

1.93
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.92;

1.92
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.91;

1.91
date	2007.11.27.16.22.13;	author martynas;	state Exp;
branches;
next	1.90;

1.90
date	2007.11.25.16.40.03;	author jmc;	state Exp;
branches;
next	1.89;

1.89
date	2007.10.11.18.33.13;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2007.10.06.16.01.17;	author jsg;	state Exp;
branches;
next	1.87;

1.87
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.86;

1.86
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.84;

1.84
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.83;

1.83
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.82;

1.82
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.81;

1.81
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.80;

1.80
date	2007.04.10.17.47.55;	author miod;	state Exp;
branches;
next	1.79;

1.79
date	2007.01.02.14.43.50;	author claudio;	state Exp;
branches;
next	1.78;

1.78
date	2006.12.21.02.28.47;	author krw;	state Exp;
branches;
next	1.77;

1.77
date	2006.11.26.17.20.33;	author jsg;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.17.11.43.12;	author mk;	state Exp;
branches;
next	1.75;

1.75
date	2006.07.09.22.39.50;	author dlg;	state Exp;
branches;
next	1.74;

1.74
date	2006.07.09.22.10.05;	author mk;	state Exp;
branches;
next	1.73;

1.73
date	2006.06.27.03.58.07;	author jsg;	state Exp;
branches;
next	1.72;

1.72
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.71;

1.71
date	2006.06.19.16.03.19;	author mk;	state Exp;
branches;
next	1.70;

1.70
date	2006.05.11.18.50.19;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.68;

1.68
date	2006.02.20.20.12.14;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.66;

1.66
date	2006.01.29.01.13.47;	author dlg;	state Exp;
branches;
next	1.65;

1.65
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.01.05.36.47;	author brad;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.07.22.47.08;	author dlg;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.07.15.14.56;	author jcs;	state Exp;
branches;
next	1.61;

1.61
date	2005.07.01.04.09.19;	author jsg;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.23.20.09.31;	author jsg;	state Exp;
branches;
next	1.59;

1.59
date	2005.03.08.12.15.12;	author dlg;	state Exp;
branches;
next	1.58;

1.58
date	2005.03.08.09.54.18;	author dlg;	state Exp;
branches;
next	1.57;

1.57
date	2005.03.03.13.25.16;	author dlg;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.03.11.42.48;	author dlg;	state Exp;
branches;
next	1.55;

1.55
date	2005.03.03.09.49.22;	author dlg;	state Exp;
branches;
next	1.54;

1.54
date	2005.03.03.09.38.07;	author itojun;	state Exp;
branches;
next	1.53;

1.53
date	2005.02.28.05.59.00;	author dlg;	state Exp;
branches;
next	1.52;

1.52
date	2005.02.24.23.10.48;	author dlg;	state Exp;
branches;
next	1.51;

1.51
date	2005.02.17.18.28.05;	author reyk;	state Exp;
branches;
next	1.50;

1.50
date	2005.01.26.13.05.49;	author dlg;	state Exp;
branches;
next	1.49;

1.49
date	2005.01.23.03.37.42;	author dlg;	state Exp;
branches;
next	1.48;

1.48
date	2004.12.30.01.53.21;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2004.12.23.13.19.38;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2004.12.20.12.11.57;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2004.12.13.08.09.51;	author dlg;	state Exp;
branches;
next	1.44;

1.44
date	2004.12.13.07.37.54;	author dlg;	state Exp;
branches;
next	1.43;

1.43
date	2004.12.12.08.45.36;	author dlg;	state Exp;
branches;
next	1.42;

1.42
date	2004.12.12.05.30.48;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.08.21.04.44;	author dlg;	state Exp;
branches;
next	1.40;

1.40
date	2004.12.06.11.33.30;	author dlg;	state Exp;
branches;
next	1.39;

1.39
date	2004.12.06.09.05.51;	author dlg;	state Exp;
branches;
next	1.38;

1.38
date	2004.12.05.12.25.59;	author dlg;	state Exp;
branches;
next	1.37;

1.37
date	2004.12.05.04.51.47;	author dlg;	state Exp;
branches;
next	1.36;

1.36
date	2004.12.05.03.04.44;	author dlg;	state Exp;
branches;
next	1.35;

1.35
date	2004.12.05.02.04.36;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2004.12.05.01.51.20;	author dlg;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.05.01.38.35;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2004.12.05.01.10.56;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2004.12.05.00.16.14;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.12.04.23.56.49;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.04.23.36.15;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.04.08.29.41;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.04.08.02.02;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2004.11.23.02.40.34;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2004.11.22.22.52.44;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2004.11.22.22.28.16;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.11.22.13.41.13;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.22.08.14.01;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.21.04.55.36;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2004.11.19.23.14.27;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.19.22.38.12;	author dlg;	state Exp;
branches;
next	1.18;

1.18
date	2004.11.17.14.13.47;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.17.01.44.29;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.16.08.57.29;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2004.11.15.12.50.08;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2004.11.15.09.59.17;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2004.11.12.12.12.29;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.12.11.56.34;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.12.02.55.02;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.11.22.48.24;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.11.11.22.47.56;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.11.11.14.29.00;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2004.11.11.00.35.00;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.11.00.08.29;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.11.10.21.45.23;	author dlg;	state Exp;
branches;
next	1.4;

1.4
date	2004.11.09.21.08.49;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.09.14.42.26;	author dlg;	state Exp;
branches;
next	1.2;

1.2
date	2004.11.08.22.41.55;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.11.08.22.09.11;	author dlg;	state Exp;
branches;
next	;


desc
@@


1.123
log
@Add frame length boundary checks to the input path of atu(4).
Problem found by Ilja Van Sprundel.
ok kevlo
@
text
@/*	$OpenBSD: if_atu.c,v 1.122 2017/03/26 15:31:15 deraadt Exp $ */
/*
 * Copyright (c) 2003, 2004
 *	Daan Vreeken <Danovitsch@@Vitsch.net>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Daan Vreeken.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Daan Vreeken AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Daan Vreeken OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Atmel AT76c503 / AT76c503a / AT76c505 / AT76c505a  USB WLAN driver
 * version 0.5 - 2004-08-03
 *
 * Originally written by Daan Vreeken <Danovitsch @@ Vitsch . net>
 *  http://vitsch.net/bsd/atuwi
 *
 * Contributed to by :
 *  Chris Whitehouse, Alistair Phillips, Peter Pilka, Martijn van Buul,
 *  Suihong Liang, Arjan van Leeuwen, Stuart Walsh
 *
 * Ported to OpenBSD by Theo de Raadt and David Gwynne.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/queue.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#include <dev/usb/usbdevs.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/if_atureg.h>

#ifdef ATU_DEBUG
#define DPRINTF(x)	do { if (atudebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (atudebug>(n)) printf x; } while (0)
int atudebug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

int atu_match(struct device *, void *, void *);
void atu_attach(struct device *, struct device *, void *);
int atu_detach(struct device *, int);

struct cfdriver atu_cd = {
	NULL, "atu", DV_IFNET
};

const struct cfattach atu_ca = {
	sizeof(struct atu_softc), atu_match, atu_attach, atu_detach
};

/*
 * Various supported device vendors/products/radio type.
 */
struct atu_type atu_devs[] = {
	{ USB_VENDOR_3COM,	USB_PRODUCT_3COM_3CRSHEW696,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ABOCOM,	USB_PRODUCT_ABOCOM_BWU613,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ACCTON,	USB_PRODUCT_ACCTON_2664W,
	  AT76C503_rfmd_acc,	ATU_NO_QUIRK },
	{ USB_VENDOR_ACERP,	USB_PRODUCT_ACERP_AWL300,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_ACERP,	USB_PRODUCT_ACERP_AWL400,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ACTIONTEC,	USB_PRODUCT_ACTIONTEC_802UAT1,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ADDTRON,	USB_PRODUCT_ADDTRON_AWU120,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_AINCOMM,	USB_PRODUCT_AINCOMM_AWU2000B,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_ASKEY,	USB_PRODUCT_ASKEY_VOYAGER1010,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_ASKEY,	USB_PRODUCT_ASKEY_WLL013I,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_ASKEY,	USB_PRODUCT_ASKEY_WLL013,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503I1,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503I2,
	  AT76C503_i3863,	ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503RFMD,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C505RFMD,
	  AT76C505_rfmd,	ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C505RFMD2958,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C505A, /* SMC2662 V.4 */
	  RadioRFMD2958_SMC,	ATU_QUIRK_NO_REMAP | ATU_QUIRK_FW_DELAY },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C505AS, /* quirk? */
	  RadioRFMD2958_SMC,	ATU_QUIRK_NO_REMAP | ATU_QUIRK_FW_DELAY },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_WN210,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_F5D6050,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_CONCEPTRONIC, USB_PRODUCT_CONCEPTRONIC_C11U,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_CONCEPTRONIC, USB_PRODUCT_CONCEPTRONIC_WL210,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_COMPAQ,	USB_PRODUCT_COMPAQ_IPAQWLAN,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_COREGA,	USB_PRODUCT_COREGA_WLUSB_11_STICK,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_DICKSMITH,	USB_PRODUCT_DICKSMITH_CHUSB611G,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_DICKSMITH,	USB_PRODUCT_DICKSMITH_WL200U,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_DICKSMITH,	USB_PRODUCT_DICKSMITH_WL240U,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_DICKSMITH,	USB_PRODUCT_DICKSMITH_XH1153,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_DLINK,	USB_PRODUCT_DLINK_DWL120E,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_GIGABYTE,	USB_PRODUCT_GIGABYTE_GNWLBM101,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_GIGASET,	USB_PRODUCT_GIGASET_WLAN, /* quirk? */
	  RadioRFMD2958_SMC,	ATU_QUIRK_NO_REMAP | ATU_QUIRK_FW_DELAY },
	{ USB_VENDOR_HP,	USB_PRODUCT_HP_HN210W,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_INTEL,	USB_PRODUCT_INTEL_AP310,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_IODATA,	USB_PRODUCT_IODATA_USBWNB11A,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_LEXAR,	USB_PRODUCT_LEXAR_2662WAR,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_LINKSYS,	USB_PRODUCT_LINKSYS_WUSB11,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_LINKSYS2,	USB_PRODUCT_LINKSYS2_WUSB11,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_LINKSYS2,	USB_PRODUCT_LINKSYS2_NWU11B,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_LINKSYS3,	USB_PRODUCT_LINKSYS3_WUSB11V28,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_MSI,	USB_PRODUCT_MSI_WLAN,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_NETGEAR2,	USB_PRODUCT_NETGEAR2_MA101,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_NETGEAR2,	USB_PRODUCT_NETGEAR2_MA101B,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_OQO,	USB_PRODUCT_OQO_WIFI01,
	  RadioRFMD2958_SMC,	ATU_QUIRK_NO_REMAP | ATU_QUIRK_FW_DELAY },
	{ USB_VENDOR_PLANEX2,	USB_PRODUCT_PLANEX2_GW_US11S,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_SAMSUNG,	USB_PRODUCT_SAMSUNG_SWL2100W,
	  AT76C503_i3863,	ATU_NO_QUIRK },
	{ USB_VENDOR_SIEMENS2,	USB_PRODUCT_SIEMENS2_WLL013,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_SMC3,	USB_PRODUCT_SMC3_2662WV1,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_SMC3,	USB_PRODUCT_SMC3_2662WV2,
	  AT76C503_rfmd_acc,	ATU_NO_QUIRK },
	{ USB_VENDOR_TEKRAM,	USB_PRODUCT_TEKRAM_U300C,
	  RadioIntersil,	ATU_NO_QUIRK },
	{ USB_VENDOR_ZCOM,	USB_PRODUCT_ZCOM_M4Y750,
	  RadioIntersil,	ATU_NO_QUIRK },
};

struct atu_radfirm {
	enum	atu_radio_type atur_type;
	char	*atur_internal;
	char	*atur_external;
	u_int8_t max_rssi;
} atu_radfirm[] = {
	{ RadioRFMD,		"atu-rfmd-int",		"atu-rfmd-ext",	0 },
	{ RadioRFMD2958,	"atu-rfmd2958-int",	"atu-rfmd2958-ext", 81 },
	{ RadioRFMD2958_SMC,	"atu-rfmd2958smc-int",	"atu-rfmd2958smc-ext", 0 },
	{ RadioIntersil,	"atu-intersil-int",	"atu-intersil-ext", 0 },
	{
		AT76C503_i3863,
		"atu-at76c503-i3863-int",
		"atu-at76c503-i3863-ext",
		0
	},
	{
		AT76C503_rfmd_acc,
		"atu-at76c503-rfmd-acc-int",
		"atu-at76c503-rfmd-acc-ext",
		0
	},
	{
		AT76C505_rfmd,
		"atu-at76c505-rfmd-int",
		"atu-at76c505-rfmd-ext",
		0
	}
};

int	atu_newbuf(struct atu_softc *, struct atu_chain *, struct mbuf *);
void	atu_rxeof(struct usbd_xfer *, void *, usbd_status);
void	atu_txeof(struct usbd_xfer *, void *, usbd_status);
void	atu_start(struct ifnet *);
int	atu_ioctl(struct ifnet *, u_long, caddr_t);
int	atu_init(struct ifnet *);
void	atu_stop(struct ifnet *, int);
void	atu_watchdog(struct ifnet *);
usbd_status atu_usb_request(struct atu_softc *sc, u_int8_t type,
	    u_int8_t request, u_int16_t value, u_int16_t index,
	    u_int16_t length, u_int8_t *data);
int	atu_send_command(struct atu_softc *sc, u_int8_t *command, int size);
int	atu_get_cmd_status(struct atu_softc *sc, u_int8_t cmd,
	    u_int8_t *status);
int	atu_wait_completion(struct atu_softc *sc, u_int8_t cmd,
	    u_int8_t *status);
int	atu_send_mib(struct atu_softc *sc, u_int8_t type,
	    u_int8_t size, u_int8_t index, void *data);
int	atu_get_mib(struct atu_softc *sc, u_int8_t type,
	    u_int8_t size, u_int8_t index, u_int8_t *buf);
#if 0
int	atu_start_ibss(struct atu_softc *sc);
#endif
int	atu_start_scan(struct atu_softc *sc);
int	atu_switch_radio(struct atu_softc *sc, int state);
int	atu_initial_config(struct atu_softc *sc);
int	atu_join(struct atu_softc *sc, struct ieee80211_node *node);
int8_t	atu_get_dfu_state(struct atu_softc *sc);
u_int8_t atu_get_opmode(struct atu_softc *sc, u_int8_t *mode);
void	atu_internal_firmware(struct device *);
void	atu_external_firmware(struct device *);
int	atu_get_card_config(struct atu_softc *sc);
int	atu_media_change(struct ifnet *ifp);
void	atu_media_status(struct ifnet *ifp, struct ifmediareq *req);
int	atu_tx_list_init(struct atu_softc *);
int	atu_rx_list_init(struct atu_softc *);
void	atu_xfer_list_free(struct atu_softc *sc, struct atu_chain *ch,
	    int listlen);

void atu_task(void *);
int atu_newstate(struct ieee80211com *, enum ieee80211_state, int);
int atu_tx_start(struct atu_softc *, struct ieee80211_node *,
    struct atu_chain *, struct mbuf *);
void atu_complete_attach(struct atu_softc *);
u_int8_t atu_calculate_padding(int);

usbd_status
atu_usb_request(struct atu_softc *sc, u_int8_t type,
    u_int8_t request, u_int16_t value, u_int16_t index, u_int16_t length,
    u_int8_t *data)
{
	usb_device_request_t	req;
	struct usbd_xfer	*xfer;
	usbd_status		err;
	int			total_len = 0, s;

	req.bmRequestType = type;
	req.bRequest = request;
	USETW(req.wValue, value);
	USETW(req.wIndex, index);
	USETW(req.wLength, length);

#ifdef ATU_DEBUG
	if (atudebug) {
		if ((data == NULL) || (type & UT_READ)) {
			DPRINTFN(20, ("%s: req=%02x val=%02x ind=%02x "
			    "len=%02x\n", sc->atu_dev.dv_xname, request,
			    value, index, length));
		} else {
			DPRINTFN(20, ("%s: req=%02x val=%02x ind=%02x "
			    "len=%02x [%8D]\n", sc->atu_dev.dv_xname,
			    request, value, index, length, data, " "));
		}
	}
#endif /* ATU_DEBUG */

	s = splnet();

	xfer = usbd_alloc_xfer(sc->atu_udev);
	usbd_setup_default_xfer(xfer, sc->atu_udev, 0, 500000, &req, data,
	    length, USBD_SHORT_XFER_OK | USBD_SYNCHRONOUS, 0);

	err = usbd_transfer(xfer);

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

#ifdef ATU_DEBUG
	if (atudebug) {
		if (type & UT_READ) {
			DPRINTFN(20, ("%s: transferred 0x%x bytes in\n",
			    sc->atu_dev.dv_xname, total_len));
			DPRINTFN(20, ("%s: dump [%10D]\n",
			    sc->atu_dev.dv_xname, data, " "));
		} else {
			if (total_len != length)
				DPRINTF(("%s: ARG! wrote only %x bytes\n",
				    sc->atu_dev.dv_xname, total_len));
		}
	}
#endif /* ATU_DEBUG */

	usbd_free_xfer(xfer);

	splx(s);
	return(err);
}

int
atu_send_command(struct atu_softc *sc, u_int8_t *command, int size)
{
	return atu_usb_request(sc, UT_WRITE_VENDOR_DEVICE, 0x0e, 0x0000,
	    0x0000, size, command);
}

int
atu_get_cmd_status(struct atu_softc *sc, u_int8_t cmd, u_int8_t *status)
{
	/*
	 * all other drivers (including Windoze) request 40 bytes of status
	 * and get a short-xfer of just 6 bytes. we can save 34 bytes of
	 * buffer if we just request those 6 bytes in the first place :)
	 */
	/*
	return atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x22, cmd,
	    0x0000, 40, status);
	*/
	return atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x22, cmd,
	    0x0000, 6, status);
}

int
atu_wait_completion(struct atu_softc *sc, u_int8_t cmd, u_int8_t *status)
{
	int			idle_count = 0, err;
	u_int8_t		statusreq[6];

	DPRINTFN(15, ("%s: wait-completion: cmd=%02x\n",
	    sc->atu_dev.dv_xname, cmd));

	while (1) {
		err = atu_get_cmd_status(sc, cmd, statusreq);
		if (err)
			return err;

#ifdef ATU_DEBUG
		if (atudebug) {
			DPRINTFN(20, ("%s: status=%s cmd=%02x\n",
			    sc->atu_dev.dv_xname,
			ether_sprintf(statusreq), cmd));
		}
#endif /* ATU_DEBUG */

		/*
		 * during normal operations waiting on STATUS_IDLE
		 * will never happen more than once
		 */
		if ((statusreq[5] == STATUS_IDLE) && (idle_count++ > 20)) {
			DPRINTF(("%s: AAARRGGG!!! FIX ME!\n",
			    sc->atu_dev.dv_xname));
			return 0;
		}

		if ((statusreq[5] != STATUS_IN_PROGRESS) &&
		    (statusreq[5] != STATUS_IDLE)) {
			if (status != NULL)
				*status = statusreq[5];
			return 0;
		}
		usbd_delay_ms(sc->atu_udev, 25);
	}
}

int
atu_send_mib(struct atu_softc *sc, u_int8_t type, u_int8_t size,
    u_int8_t index, void *data)
{
	int				err;
	struct atu_cmd_set_mib		request;

	/*
	 * We don't construct a MIB packet first and then memcpy it into an
	 * Atmel-command-packet, we just construct it the right way at once :)
	 */

	memset(&request, 0, sizeof(request));

	request.AtCmd = CMD_SET_MIB;
	USETW(request.AtSize, size + 4);

	request.MIBType = type;
	request.MIBSize = size;
	request.MIBIndex = index;
	request.MIBReserved = 0;

	/*
	 * For 1 and 2 byte requests we assume a direct value,
	 * everything bigger than 2 bytes we assume a pointer to the data
	 */
	switch (size) {
	case 0:
		break;
	case 1:
		request.data[0]=(long)data & 0x000000ff;
		break;
	case 2:
		request.data[0]=(long)data & 0x000000ff;
		request.data[1]=(long)data >> 8;
		break;
	default:
		memcpy(request.data, data, size);
		break;
	}

	err = atu_usb_request(sc, UT_WRITE_VENDOR_DEVICE, 0x0e, 0x0000,
	    0x0000, size+8, (uByte *)&request);
	if (err)
		return (err);

	DPRINTFN(15, ("%s: sendmib : waitcompletion...\n",
	    sc->atu_dev.dv_xname));
	return atu_wait_completion(sc, CMD_SET_MIB, NULL);
}

int
atu_get_mib(struct atu_softc *sc, u_int8_t type, u_int8_t size,
    u_int8_t index, u_int8_t *buf)
{

	/* linux/at76c503.c - 478 */
	return atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x033,
	    type << 8, index, size, buf);
}

#if 0
int
atu_start_ibss(struct atu_softc *sc)
{
	int				err;
	struct atu_cmd_start_ibss	Request;

	Request.Cmd = CMD_START_IBSS;
	Request.Reserved = 0;
	Request.Size = sizeof(Request) - 4;

	memset(Request.BSSID, 0x00, sizeof(Request.BSSID));
	memset(Request.SSID, 0x00, sizeof(Request.SSID));
	memcpy(Request.SSID, sc->atu_ssid, sc->atu_ssidlen);
	Request.SSIDSize = sc->atu_ssidlen;
	if (sc->atu_desired_channel != IEEE80211_CHAN_ANY)
		Request.Channel = (u_int8_t)sc->atu_desired_channel;
	else
		Request.Channel = ATU_DEFAULT_CHANNEL;
	Request.BSSType = AD_HOC_MODE;
	memset(Request.Res, 0x00, sizeof(Request.Res));

	/* Write config to adapter */
	err = atu_send_command(sc, (u_int8_t *)&Request, sizeof(Request));
	if (err) {
		DPRINTF(("%s: start ibss failed!\n",
		    sc->atu_dev.dv_xname));
		return err;
	}

	/* Wait for the adapter to do its thing */
	err = atu_wait_completion(sc, CMD_START_IBSS, NULL);
	if (err) {
		DPRINTF(("%s: error waiting for start_ibss\n",
		    sc->atu_dev.dv_xname));
		return err;
	}

	/* Get the current BSSID */
	err = atu_get_mib(sc, MIB_MAC_MGMT__CURRENT_BSSID, sc->atu_bssid);
	if (err) {
		DPRINTF(("%s: could not get BSSID!\n",
		    sc->atu_dev.dv_xname));
		return err;
	}

	DPRINTF(("%s: started a new IBSS (BSSID=%s)\n",
	    sc->atu_dev.dv_xname, ether_sprintf(sc->atu_bssid)));
	return 0;
}
#endif

int
atu_start_scan(struct atu_softc *sc)
{
	struct ieee80211com		*ic = &sc->sc_ic;
	struct atu_cmd_do_scan		Scan;
	usbd_status			err;
	int				Cnt;

	memset(&Scan, 0, sizeof(Scan));

	Scan.Cmd = CMD_START_SCAN;
	Scan.Reserved = 0;
	USETW(Scan.Size, sizeof(Scan) - 4);

	/* use the broadcast BSSID (in active scan) */
	for (Cnt=0; Cnt<6; Cnt++)
		Scan.BSSID[Cnt] = 0xff;

	memcpy(Scan.SSID, ic->ic_des_essid, ic->ic_des_esslen);
	Scan.SSID_Len = ic->ic_des_esslen;

	/* default values for scan */
	Scan.ScanType = ATU_SCAN_ACTIVE;
	if (sc->atu_desired_channel != IEEE80211_CHAN_ANY)
		Scan.Channel = (u_int8_t)sc->atu_desired_channel;
	else
		Scan.Channel = sc->atu_channel;

	/* we like scans to be quick :) */
	/* the time we wait before sending probe's */
	USETW(Scan.ProbeDelay, 0);
	/* the time we stay on one channel */
	USETW(Scan.MinChannelTime, 100);
	USETW(Scan.MaxChannelTime, 200);
	/* whether or not we scan all channels */
	Scan.InternationalScan = 0xc1;

#ifdef ATU_DEBUG
	if (atudebug) {
		DPRINTFN(20, ("%s: scan cmd len=%02x\n",
		    sc->atu_dev.dv_xname, sizeof(Scan)));
		DPRINTFN(20, ("%s: scan cmd: %52D\n", sc->atu_dev.dv_xname,
		    (u_int8_t *)&Scan, " "));
	}
#endif /* ATU_DEBUG */

	/* Write config to adapter */
	err = atu_send_command(sc, (u_int8_t *)&Scan, sizeof(Scan));
	if (err)
		return err;

	/*
	 * We don't wait for the command to finish... the mgmt-thread will do
	 * that for us
	 */
	/*
	err = atu_wait_completion(sc, CMD_START_SCAN, NULL);
	if (err)
		return err;
	*/
	return 0;
}

int
atu_switch_radio(struct atu_softc *sc, int state)
{
	usbd_status		err;
	struct atu_cmd		CmdRadio;

	if (sc->atu_radio == RadioIntersil) {
		/*
		 * Intersil doesn't seem to need/support switching the radio
		 * on/off
		 */
		return 0;
	}

	memset(&CmdRadio, 0, sizeof(CmdRadio));
	CmdRadio.Cmd = CMD_RADIO_ON;

	if (sc->atu_radio_on != state) {
		if (state == 0)
			CmdRadio.Cmd = CMD_RADIO_OFF;

		err = atu_send_command(sc, (u_int8_t *)&CmdRadio,
		    sizeof(CmdRadio));
		if (err)
			return err;

		err = atu_wait_completion(sc, CmdRadio.Cmd, NULL);
		if (err)
			return err;

		DPRINTFN(10, ("%s: radio turned %s\n",
		    sc->atu_dev.dv_xname, state ? "on" : "off"));
		sc->atu_radio_on = state;
	}
	return 0;
}

int
atu_initial_config(struct atu_softc *sc)
{
	struct ieee80211com		*ic = &sc->sc_ic;
	u_int32_t			i;
	usbd_status			err;
/*	u_int8_t			rates[4] = {0x82, 0x84, 0x8B, 0x96};*/
	u_int8_t			rates[4] = {0x82, 0x04, 0x0B, 0x16};
	struct atu_cmd_card_config	cmd;
	u_int8_t			reg_domain;

	DPRINTFN(10, ("%s: sending mac-addr\n", sc->atu_dev.dv_xname));
	err = atu_send_mib(sc, MIB_MAC_ADDR__ADDR, ic->ic_myaddr);
	if (err) {
		DPRINTF(("%s: error setting mac-addr\n",
		    sc->atu_dev.dv_xname));
		return err;
	}

	/*
	DPRINTF(("%s: sending reg-domain\n", sc->atu_dev.dv_xname));
	err = atu_send_mib(sc, MIB_PHY__REG_DOMAIN, NR(0x30));
	if (err) {
		DPRINTF(("%s: error setting mac-addr\n",
		    sc->atu_dev.dv_xname));
		return err;
	}
	*/

	memset(&cmd, 0, sizeof(cmd));
	cmd.Cmd = CMD_STARTUP;
	cmd.Reserved = 0;
	USETW(cmd.Size, sizeof(cmd) - 4);

	if (sc->atu_desired_channel != IEEE80211_CHAN_ANY)
		cmd.Channel = (u_int8_t)sc->atu_desired_channel;
	else
		cmd.Channel = sc->atu_channel;
	cmd.AutoRateFallback = 1;
	memcpy(cmd.BasicRateSet, rates, 4);

	/* ShortRetryLimit should be 7 according to 802.11 spec */
	cmd.ShortRetryLimit = 7;
	USETW(cmd.RTS_Threshold, 2347);
	USETW(cmd.FragThreshold, 2346);

	/* Doesn't seem to work, but we'll set it to 1 anyway */
	cmd.PromiscuousMode = 1;

	/* this goes into the beacon we transmit */
	cmd.PrivacyInvoked = (ic->ic_flags & IEEE80211_F_WEPON) ? 1 : 0;

	cmd.ExcludeUnencrypted = 0;
	switch (ic->ic_nw_keys[ic->ic_wep_txkey].k_cipher) {
	case IEEE80211_CIPHER_WEP40:
		cmd.EncryptionType = ATU_WEP_40BITS;
		break;
	case IEEE80211_CIPHER_WEP104:
		cmd.EncryptionType = ATU_WEP_104BITS;
		break;
	default:
		cmd.EncryptionType = ATU_WEP_OFF;
		break;
	}

	cmd.WEP_DefaultKeyID = ic->ic_wep_txkey;
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		memcpy(cmd.WEP_DefaultKey[i], ic->ic_nw_keys[i].k_key,
		    ic->ic_nw_keys[i].k_len);
	}

	/* Setting the SSID here doesn't seem to do anything */
	memcpy(cmd.SSID, ic->ic_des_essid, ic->ic_des_esslen);
	cmd.SSID_Len = ic->ic_des_esslen;

	cmd.ShortPreamble = 0;
	USETW(cmd.BeaconPeriod, 100);
	/* cmd.BeaconPeriod = 65535; */

	/*
	 * TODO:
	 * read reg domain MIB_PHY @@ 0x17 (1 byte), (reply = 0x30)
	 * we should do something useful with this info. right now it's just
	 * ignored
	 */
	err = atu_get_mib(sc, MIB_PHY__REG_DOMAIN, &reg_domain);
	if (err) {
		DPRINTF(("%s: could not get regdomain!\n",
		    sc->atu_dev.dv_xname));
	} else {
		DPRINTF(("%s: we're in reg domain 0x%x according to the "
		    "adapter\n", sc->atu_dev.dv_xname, reg_domain));
	}

#ifdef ATU_DEBUG
	if (atudebug) {
		DPRINTFN(20, ("%s: configlen=%02x\n", sc->atu_dev.dv_xname,
		    sizeof(cmd)));
		DPRINTFN(20, ("%s: configdata= %108D\n",
		    sc->atu_dev.dv_xname, (u_int8_t *)&cmd, " "));
	}
#endif /* ATU_DEBUG */

	/* Windoze : driver says exclude-unencrypted=1 & encr-type=1 */

	err = atu_send_command(sc, (u_int8_t *)&cmd, sizeof(cmd));
	if (err)
		return err;
	err = atu_wait_completion(sc, CMD_STARTUP, NULL);
	if (err)
		return err;

	/* Turn on radio now */
	err = atu_switch_radio(sc, 1);
	if (err)
		return err;

	/* preamble type = short */
	err = atu_send_mib(sc, MIB_LOCAL__PREAMBLE, NR(PREAMBLE_SHORT));
	if (err)
		return err;

	/* frag = 1536 */
	err = atu_send_mib(sc, MIB_MAC__FRAG, NR(2346));
	if (err)
		return err;

	/* rts = 1536 */
	err = atu_send_mib(sc, MIB_MAC__RTS, NR(2347));
	if (err)
		return err;

	/* auto rate fallback = 1 */
	err = atu_send_mib(sc, MIB_LOCAL__AUTO_RATE_FALLBACK, NR(1));
	if (err)
		return err;

	/* power mode = full on, no power saving */
	err = atu_send_mib(sc, MIB_MAC_MGMT__POWER_MODE,
	    NR(POWER_MODE_ACTIVE));
	if (err)
		return err;

	DPRINTFN(10, ("%s: completed initial config\n",
	   sc->atu_dev.dv_xname));
	return 0;
}

int
atu_join(struct atu_softc *sc, struct ieee80211_node *node)
{
	struct atu_cmd_join		join;
	u_int8_t			status;
	usbd_status			err;

	memset(&join, 0, sizeof(join));

	join.Cmd = CMD_JOIN;
	join.Reserved = 0x00;
	USETW(join.Size, sizeof(join) - 4);

	DPRINTFN(15, ("%s: pre-join sc->atu_bssid=%s\n",
	    sc->atu_dev.dv_xname, ether_sprintf(sc->atu_bssid)));
	DPRINTFN(15, ("%s: mode=%d\n", sc->atu_dev.dv_xname,
	    sc->atu_mode));
	memcpy(join.bssid, node->ni_bssid, IEEE80211_ADDR_LEN);
	memcpy(join.essid, node->ni_essid, node->ni_esslen);
	join.essid_size = node->ni_esslen;
	if (node->ni_capinfo & IEEE80211_CAPINFO_IBSS)
		join.bss_type = AD_HOC_MODE;
	else
		join.bss_type = INFRASTRUCTURE_MODE;
	join.channel = ieee80211_chan2ieee(&sc->sc_ic, node->ni_chan);

	USETW(join.timeout, ATU_JOIN_TIMEOUT);
	join.reserved = 0x00;

	DPRINTFN(10, ("%s: trying to join BSSID=%s\n",
	    sc->atu_dev.dv_xname, ether_sprintf(join.bssid)));
	err = atu_send_command(sc, (u_int8_t *)&join, sizeof(join));
	if (err) {
		DPRINTF(("%s: ERROR trying to join IBSS\n",
		    sc->atu_dev.dv_xname));
		return err;
	}
	err = atu_wait_completion(sc, CMD_JOIN, &status);
	if (err) {
		DPRINTF(("%s: error joining BSS!\n",
		    sc->atu_dev.dv_xname));
		return err;
	}
	if (status != STATUS_COMPLETE) {
		DPRINTF(("%s: error joining... [status=%02x]\n",
		    sc->atu_dev.dv_xname, status));
		return status;
	} else {
		DPRINTFN(10, ("%s: joined BSS\n", sc->atu_dev.dv_xname));
	}
	return err;
}

/*
 * Get the state of the DFU unit
 */
int8_t
atu_get_dfu_state(struct atu_softc *sc)
{
	u_int8_t	state;

	if (atu_usb_request(sc, DFU_GETSTATE, 0, 0, 1, &state))
		return -1;
	return state;
}

/*
 * Get MAC opmode
 */
u_int8_t
atu_get_opmode(struct atu_softc *sc, u_int8_t *mode)
{

	return atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x33, 0x0001,
	    0x0000, 1, mode);
}

/*
 * Upload the internal firmware into the device
 */
void
atu_internal_firmware(struct device *self)
{
	struct atu_softc *sc = (struct atu_softc *)self;
	u_char	state, *ptr = NULL, *firm = NULL, status[6];
	int block_size, block = 0, err, i;
	size_t	firm_len, bytes_left = 0;
	char	*name = "unknown-device";

	/*
	 * Uploading firmware is done with the DFU (Device Firmware Upgrade)
	 * interface. See "Universal Serial Bus - Device Class Specification
	 * for Device Firmware Upgrade" pdf for details of the protocol.
	 * Maybe this could be moved to a separate 'firmware driver' once more
	 * device drivers need it... For now we'll just do it here.
	 *
	 * Just for your information, the Atmel's DFU descriptor looks like
	 * this:
	 *
	 * 07		size
	 * 21		type
	 * 01		capabilities : only firmware download, need reset
	 *		  after download
	 * 13 05	detach timeout : max 1299ms between DFU_DETACH and
	 *		  reset
	 * 00 04	max bytes of firmware per transaction : 1024
	 */

	/* Choose the right firmware for the device */
	for (i = 0; i < nitems(atu_radfirm); i++)
		if (sc->atu_radio == atu_radfirm[i].atur_type)
			name = atu_radfirm[i].atur_internal;

	DPRINTF(("%s: loading firmware %s...\n",
	    sc->atu_dev.dv_xname, name));
	err = loadfirmware(name, &firm, &firm_len);
	if (err != 0) {
		printf("%s: %s loadfirmware error %d\n",
		    sc->atu_dev.dv_xname, name, err);
		goto fail;
	}

	ptr = firm;
	bytes_left = firm_len;
	state = atu_get_dfu_state(sc);

	while (block >= 0 && state > 0) {
		switch (state) {
		case DFUState_DnLoadSync:
			/* get DFU status */
			err = atu_usb_request(sc, DFU_GETSTATUS, 0, 0 , 6,
			    status);
			if (err) {
				DPRINTF(("%s: dfu_getstatus failed!\n",
				    sc->atu_dev.dv_xname));
				free(firm, M_DEVBUF, firm_len);
				goto fail;
			}
			/* success means state => DnLoadIdle */
			state = DFUState_DnLoadIdle;
			continue;
			break;

		case DFUState_DFUIdle:
		case DFUState_DnLoadIdle:
			if (bytes_left>=DFU_MaxBlockSize)
				block_size = DFU_MaxBlockSize;
			else
				block_size = bytes_left;
			DPRINTFN(15, ("%s: firmware block %d\n",
			    sc->atu_dev.dv_xname, block));

			err = atu_usb_request(sc, DFU_DNLOAD, block++, 0,
			    block_size, ptr);
			if (err) {
				DPRINTF(("%s: dfu_dnload failed\n",
				    sc->atu_dev.dv_xname));
				free(firm, M_DEVBUF, firm_len);
				goto fail;
			}

			ptr += block_size;
			bytes_left -= block_size;
			if (block_size == 0)
				block = -1;
			break;

		default:
			DPRINTFN(20, ("%s: sleeping for a while\n",
			    sc->atu_dev.dv_xname));
			usbd_delay_ms(sc->atu_udev, 100);
			break;
		}

		state = atu_get_dfu_state(sc);
	}
	free(firm, M_DEVBUF, firm_len);

	if (state != DFUState_ManifestSync) {
		DPRINTF(("%s: state != manifestsync... eek!\n",
		    sc->atu_dev.dv_xname));
	}

	err = atu_usb_request(sc, DFU_GETSTATUS, 0, 0, 6, status);
	if (err) {
		DPRINTF(("%s: dfu_getstatus failed!\n",
		    sc->atu_dev.dv_xname));
		goto fail;
	}

	DPRINTFN(15, ("%s: sending remap\n", sc->atu_dev.dv_xname));
	err = atu_usb_request(sc, DFU_REMAP, 0, 0, 0, NULL);
	if ((err) && (!ISSET(sc->atu_quirk, ATU_QUIRK_NO_REMAP))) {
		DPRINTF(("%s: remap failed!\n", sc->atu_dev.dv_xname));
		goto fail;
	}

	/* after a lot of trying and measuring I found out the device needs
	 * about 56 milliseconds after sending the remap command before
	 * it's ready to communicate again. So we'll wait just a little bit
	 * longer than that to be sure...
	 */
	usbd_delay_ms(sc->atu_udev, 56+100);

	printf("%s: reattaching after firmware upload\n",
	    sc->atu_dev.dv_xname);
	usb_needs_reattach(sc->atu_udev);

fail:
	usbd_deactivate(sc->atu_udev);
}

void
atu_external_firmware(struct device *self)
{
	struct atu_softc *sc = (struct atu_softc *)self;
	u_char	*ptr = NULL, *firm = NULL;
	int	block_size, block = 0, err, i;
	size_t	firm_len, bytes_left = 0;
	char	*name = "unknown-device";

	for (i = 0; i < nitems(atu_radfirm); i++)
		if (sc->atu_radio == atu_radfirm[i].atur_type)
			name = atu_radfirm[i].atur_external;

	DPRINTF(("%s: loading external firmware %s\n",
	    sc->atu_dev.dv_xname, name));
	err = loadfirmware(name, &firm, &firm_len);
	if (err != 0) {
		printf("%s: %s loadfirmware error %d\n",
		    sc->atu_dev.dv_xname, name, err);
		return;
	}
	ptr = firm;
	bytes_left = firm_len;

	while (bytes_left) {
		if (bytes_left > 1024)
			block_size = 1024;
		else
			block_size = bytes_left;

		DPRINTFN(15, ("%s: block:%d size:%d\n",
		    sc->atu_dev.dv_xname, block, block_size));
		err = atu_usb_request(sc, UT_WRITE_VENDOR_DEVICE, 0x0e,
		    0x0802, block, block_size, ptr);
		if (err) {
			DPRINTF(("%s: could not load external firmware "
			    "block\n", sc->atu_dev.dv_xname));
			free(firm, M_DEVBUF, firm_len);
			return;
		}

		ptr += block_size;
		block++;
		bytes_left -= block_size;
	}
	free(firm, M_DEVBUF, firm_len);

	err = atu_usb_request(sc, UT_WRITE_VENDOR_DEVICE, 0x0e, 0x0802,
	    block, 0, NULL);
	if (err) {
		DPRINTF(("%s: could not load last zero-length firmware "
		    "block\n", sc->atu_dev.dv_xname));
		return;
	}

	/*
	 * The SMC2662w V.4 seems to require some time to do its thing with
	 * the external firmware... 20 ms isn't enough, but 21 ms works 100
	 * times out of 100 tries. We'll wait a bit longer just to be sure
	 */
	if (sc->atu_quirk & ATU_QUIRK_FW_DELAY)
		usbd_delay_ms(sc->atu_udev, 21 + 100);

	DPRINTFN(10, ("%s: external firmware upload done\n",
	    sc->atu_dev.dv_xname));
	/* complete configuration after the firmwares have been uploaded */
	atu_complete_attach(sc);
}

int
atu_get_card_config(struct atu_softc *sc)
{
	struct ieee80211com		*ic = &sc->sc_ic;
	struct atu_rfmd_conf		rfmd_conf;
	struct atu_intersil_conf	intersil_conf;
	int				err;

	switch (sc->atu_radio) {

	case RadioRFMD:
	case RadioRFMD2958:
	case RadioRFMD2958_SMC:
	case AT76C503_rfmd_acc:
	case AT76C505_rfmd:
		err = atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x33,
		    0x0a02, 0x0000, sizeof(rfmd_conf),
		    (u_int8_t *)&rfmd_conf);
		if (err) {
			DPRINTF(("%s: could not get rfmd config!\n",
			    sc->atu_dev.dv_xname));
			return err;
		}
		memcpy(ic->ic_myaddr, rfmd_conf.MACAddr, IEEE80211_ADDR_LEN);
		break;

	case RadioIntersil:
	case AT76C503_i3863:
		err = atu_usb_request(sc, UT_READ_VENDOR_INTERFACE, 0x33,
		    0x0902, 0x0000, sizeof(intersil_conf),
		    (u_int8_t *)&intersil_conf);
		if (err) {
			DPRINTF(("%s: could not get intersil config!\n",
			    sc->atu_dev.dv_xname));
			return err;
		}
		memcpy(ic->ic_myaddr, intersil_conf.MACAddr,
		    IEEE80211_ADDR_LEN);
		break;
	}
	return 0;
}

/*
 * Probe for an AT76c503 chip.
 */
int
atu_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;
	int			i;

	if (uaa->iface == NULL || uaa->configno != ATU_CONFIG_NO)
		return(UMATCH_NONE);

	for (i = 0; i < nitems(atu_devs); i++) {
		struct atu_type *t = &atu_devs[i];

		if (uaa->vendor == t->atu_vid &&
		    uaa->product == t->atu_pid) {
			return(UMATCH_VENDOR_PRODUCT);
		}
	}
	return(UMATCH_NONE);
}

int
atu_media_change(struct ifnet *ifp)
{
#ifdef ATU_DEBUG
	struct atu_softc	*sc = ifp->if_softc;
#endif /* ATU_DEBUG */
	int			err;

	DPRINTFN(10, ("%s: atu_media_change\n", sc->atu_dev.dv_xname));

	err = ieee80211_media_change(ifp);
	if (err == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
		    (IFF_RUNNING|IFF_UP))
			atu_init(ifp);
		err = 0;
	}

	return (err);
}

void
atu_media_status(struct ifnet *ifp, struct ifmediareq *req)
{
#ifdef ATU_DEBUG
	struct atu_softc	*sc = ifp->if_softc;
#endif /* ATU_DEBUG */

	DPRINTFN(10, ("%s: atu_media_status\n", sc->atu_dev.dv_xname));

	ieee80211_media_status(ifp, req);
}

void
atu_task(void *arg)
{
	struct atu_softc	*sc = (struct atu_softc *)arg;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	usbd_status		err;
	int			s;

	DPRINTFN(10, ("%s: atu_task\n", sc->atu_dev.dv_xname));

	if (usbd_is_dying(sc->atu_udev))
		return;

	switch (sc->sc_cmd) {
	case ATU_C_SCAN:

		err = atu_start_scan(sc);
		if (err) {
			DPRINTFN(1, ("%s: atu_init: couldn't start scan!\n",
			    sc->atu_dev.dv_xname));
			return;
		}

		err = atu_wait_completion(sc, CMD_START_SCAN, NULL);
		if (err) {
			DPRINTF(("%s: atu_init: error waiting for scan\n",
			    sc->atu_dev.dv_xname));
			return;
		}

		DPRINTF(("%s: ==========================> END OF SCAN!\n",
		    sc->atu_dev.dv_xname));

		s = splnet();
		/* ieee80211_next_scan(ifp); */
		ieee80211_end_scan(ifp);
		splx(s);

		DPRINTF(("%s: ----------------------======> END OF SCAN2!\n",
		    sc->atu_dev.dv_xname));
		break;

	case ATU_C_JOIN:
		atu_join(sc, ic->ic_bss);
	}
}

int
atu_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ifnet		*ifp = &ic->ic_if;
	struct atu_softc	*sc = ifp->if_softc;
	enum ieee80211_state	ostate = ic->ic_state;

	DPRINTFN(10, ("%s: atu_newstate: %s -> %s\n", sc->atu_dev.dv_xname,
	    ieee80211_state_name[ostate], ieee80211_state_name[nstate]));

	switch (nstate) {
	case IEEE80211_S_SCAN:
		memcpy(ic->ic_chan_scan, ic->ic_chan_active,
		    sizeof(ic->ic_chan_active));
		ieee80211_free_allnodes(ic);

		/* tell the event thread that we want a scan */
		sc->sc_cmd = ATU_C_SCAN;
		usb_add_task(sc->atu_udev, &sc->sc_task);

		/* handle this ourselves */
		ic->ic_state = nstate;
		return (0);

	case IEEE80211_S_AUTH:
	case IEEE80211_S_RUN:
		if (ostate == IEEE80211_S_SCAN) {
			sc->sc_cmd = ATU_C_JOIN;
			usb_add_task(sc->atu_udev, &sc->sc_task);
		}
		break;
	default:
		/* nothing to do */
		break;
	}

	return (*sc->sc_newstate)(ic, nstate, arg);
}

/*
 * Attach the interface. Allocate softc structures, do
 * setup and ethernet/BPF attach.
 */
void
atu_attach(struct device *parent, struct device *self, void *aux)
{
	struct atu_softc		*sc = (struct atu_softc *)self;
	struct usb_attach_arg		*uaa = aux;
	usbd_status			err;
	struct usbd_device		*dev = uaa->device;
	u_int8_t			mode, channel;
	int i;

	sc->atu_unit = self->dv_unit;
	sc->atu_udev = dev;

	err = usbd_device2interface_handle(dev, ATU_IFACE_IDX, &sc->atu_iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->atu_dev.dv_xname);
		goto fail;
	}

	/*
	 * look up the radio_type for the device
	 * basically does the same as USB_MATCH
	 */
	for (i = 0; i < nitems(atu_devs); i++) {
		struct atu_type *t = &atu_devs[i];

		if (uaa->vendor == t->atu_vid &&
		    uaa->product == t->atu_pid) {
			sc->atu_radio = t->atu_radio;
			sc->atu_quirk = t->atu_quirk;
		}
	}

	/*
	 * Check in the interface descriptor if we're in DFU mode
	 * If we're in DFU mode, we upload the external firmware
	 * If we're not, the PC must have rebooted without power-cycling
	 * the device.. I've tried this out, a reboot only requeres the
	 * external firmware to be reloaded :)
	 *
	 * Hmm. The at76c505a doesn't report a DFU descriptor when it's
	 * in DFU mode... Let's just try to get the opmode
	 */
	err = atu_get_opmode(sc, &mode);
	DPRINTFN(20, ("%s: opmode: %d\n", sc->atu_dev.dv_xname, mode));
	if (err || (mode != MODE_NETCARD && mode != MODE_NOFLASHNETCARD)) {
		DPRINTF(("%s: starting internal firmware download\n",
		    sc->atu_dev.dv_xname));

		config_mountroot(self, atu_internal_firmware);
		/*
		 * atu_internal_firmware will cause a reset of the device
		 * so we don't want to do any more configuration after this
		 * point.
		 */
		return;
	}

	uaa->iface = sc->atu_iface;

	if (mode != MODE_NETCARD) {
		DPRINTFN(15, ("%s: device needs external firmware\n",
		    sc->atu_dev.dv_xname));

		if (mode != MODE_NOFLASHNETCARD) {
			DPRINTF(("%s: EEK! unexpected opmode=%d\n",
			    sc->atu_dev.dv_xname, mode));
		}

		/*
		 * There is no difference in opmode before and after external
		 * firmware upload with the SMC2662 V.4 . So instead we'll try
		 * to read the channel number. If we succeed, external
		 * firmwaremust have been already uploaded...
		 */
		if (sc->atu_radio != RadioIntersil) {
			err = atu_get_mib(sc, MIB_PHY__CHANNEL, &channel);
			if (!err) {
				DPRINTF(("%s: external firmware has already"
				    " been downloaded\n",
				    sc->atu_dev.dv_xname));
				atu_complete_attach(sc);
				return;
			}
		}

		config_mountroot(self, atu_external_firmware);

		/*
		 * atu_external_firmware will call atu_complete_attach after
		 * it's finished so we can just return.
		 */
	} else {
		/* all the firmwares are in place, so complete the attach */
		atu_complete_attach(sc);
	}
fail:
	usbd_deactivate(sc->atu_udev);
}

void
atu_complete_attach(struct atu_softc *sc)
{
	struct ieee80211com		*ic = &sc->sc_ic;
	struct ifnet			*ifp = &ic->ic_if;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	usbd_status			err;
	int				i;
#ifdef ATU_DEBUG
	struct atu_fw			fw;
#endif

	id = usbd_get_interface_descriptor(sc->atu_iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->atu_iface, i);
		if (!ed) {
			DPRINTF(("%s: num_endp:%d\n", sc->atu_dev.dv_xname,
			    sc->atu_iface->idesc->bNumEndpoints));
			DPRINTF(("%s: couldn't get ep %d\n",
			    sc->atu_dev.dv_xname, i));
			goto fail;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->atu_ed[ATU_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->atu_ed[ATU_ENDPT_TX] = ed->bEndpointAddress;
		}
	}

	/* read device config & get MAC address */
	err = atu_get_card_config(sc);
	if (err) {
		printf("%s: could not get card cfg!\n",
		    sc->atu_dev.dv_xname);
		goto fail;
	}

#ifdef ATU_DEBUG
	/* DEBUG : try to get firmware version */
	err = atu_get_mib(sc, MIB_FW_VERSION, sizeof(fw), 0,
	    (u_int8_t *)&fw);
	if (!err) {
		DPRINTFN(15, ("%s: firmware: maj:%d min:%d patch:%d "
		    "build:%d\n", sc->atu_dev.dv_xname, fw.major, fw.minor,
		    fw.patch, fw.build));
	} else {
		DPRINTF(("%s: get firmware version failed\n",
		    sc->atu_dev.dv_xname));
	}
#endif /* ATU_DEBUG */

	/* Show the world our MAC address */
	printf("%s: address %s\n", sc->atu_dev.dv_xname,
	    ether_sprintf(ic->ic_myaddr));

	sc->atu_cdata.atu_tx_inuse = 0;

	bzero(sc->atu_bssid, ETHER_ADDR_LEN);
	sc->atu_channel = ATU_DEFAULT_CHANNEL;
	sc->atu_desired_channel = IEEE80211_CHAN_ANY;
	sc->atu_mode = INFRASTRUCTURE_MODE;

	ic->ic_softc = sc;
	ic->ic_phytype = IEEE80211_T_DS;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_WEP | IEEE80211_C_SCANALL;
	ic->ic_max_rssi = atu_radfirm[sc->atu_radio].max_rssi;

	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;

	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_B |
		    IEEE80211_CHAN_PASSIVE;
		ic->ic_channels[i].ic_freq = ieee80211_ieee2mhz(i,
		    ic->ic_channels[i].ic_flags);
	}

	ic->ic_ibss_chan = &ic->ic_channels[0];

	ifp->if_softc = sc;
	memcpy(ifp->if_xname, sc->atu_dev.dv_xname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = atu_start;
	ifp->if_ioctl = atu_ioctl;
	ifp->if_watchdog = atu_watchdog;
	ifp->if_mtu = ATU_DEFAULT_MTU;

	/* Call MI attach routine. */
	if_attach(ifp);
	ieee80211_ifattach(ifp);

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = atu_newstate;

	/* setup ifmedia interface */
	ieee80211_media_init(ifp, atu_media_change, atu_media_status);

	usb_init_task(&sc->sc_task, atu_task, sc, USB_TASK_TYPE_GENERIC);

#if NBPFILTER > 0
	bpfattach(&sc->sc_radiobpf, &sc->sc_ic.ic_if, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);

	bzero(&sc->sc_rxtapu, sizeof(sc->sc_rxtapu));
	sc->sc_rxtap.rr_ihdr.it_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.rr_ihdr.it_present = htole32(ATU_RX_RADIOTAP_PRESENT);

	bzero(&sc->sc_txtapu, sizeof(sc->sc_txtapu));
	sc->sc_txtap.rt_ihdr.it_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.rt_ihdr.it_present = htole32(ATU_TX_RADIOTAP_PRESENT);
#endif

fail:
	usbd_deactivate(sc->atu_udev);
}

int
atu_detach(struct device *self, int flags)
{
	struct atu_softc	*sc = (struct atu_softc *)self;
	struct ifnet		*ifp = &sc->sc_ic.ic_if;

	DPRINTFN(10, ("%s: atu_detach\n", sc->atu_dev.dv_xname));

	if (ifp->if_flags & IFF_RUNNING)
		atu_stop(ifp, 1);

	usb_rem_task(sc->atu_udev, &sc->sc_task);

	if (sc->atu_ep[ATU_ENDPT_TX] != NULL)
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_TX]);
	if (sc->atu_ep[ATU_ENDPT_RX] != NULL)
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_RX]);

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}

	return(0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
atu_newbuf(struct atu_softc *sc, struct atu_chain *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			DPRINTF(("%s: no memory for rx list\n",
			    sc->atu_dev.dv_xname));
			return(ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			DPRINTF(("%s: no memory for rx list\n",
			    sc->atu_dev.dv_xname));
			m_freem(m_new);
			return(ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}
	c->atu_mbuf = m_new;
	return(0);
}

int
atu_rx_list_init(struct atu_softc *sc)
{
	struct atu_cdata	*cd = &sc->atu_cdata;
	struct atu_chain	*c;
	int			i;

	DPRINTFN(15, ("%s: atu_rx_list_init: enter\n",
	    sc->atu_dev.dv_xname));

	for (i = 0; i < ATU_RX_LIST_CNT; i++) {
		c = &cd->atu_rx_chain[i];
		c->atu_sc = sc;
		c->atu_idx = i;
		if (c->atu_xfer == NULL) {
			c->atu_xfer = usbd_alloc_xfer(sc->atu_udev);
			if (c->atu_xfer == NULL)
				return (ENOBUFS);
			c->atu_buf = usbd_alloc_buffer(c->atu_xfer,
			    ATU_RX_BUFSZ);
			if (c->atu_buf == NULL) /* XXX free xfer */
				return (ENOBUFS);
			if (atu_newbuf(sc, c, NULL) == ENOBUFS) /* XXX free? */
				return(ENOBUFS);
		}
	}
	return (0);
}

int
atu_tx_list_init(struct atu_softc *sc)
{
	struct atu_cdata	*cd = &sc->atu_cdata;
	struct atu_chain	*c;
	int			i;

	DPRINTFN(15, ("%s: atu_tx_list_init\n",
	    sc->atu_dev.dv_xname));

	SLIST_INIT(&cd->atu_tx_free);
	sc->atu_cdata.atu_tx_inuse = 0;

	for (i = 0; i < ATU_TX_LIST_CNT; i++) {
		c = &cd->atu_tx_chain[i];
		c->atu_sc = sc;
		c->atu_idx = i;
		if (c->atu_xfer == NULL) {
			c->atu_xfer = usbd_alloc_xfer(sc->atu_udev);
			if (c->atu_xfer == NULL)
				return(ENOBUFS);
			c->atu_mbuf = NULL;
			c->atu_buf = usbd_alloc_buffer(c->atu_xfer,
			    ATU_TX_BUFSZ);
			if (c->atu_buf == NULL)
				return(ENOBUFS); /* XXX free xfer */
			SLIST_INSERT_HEAD(&cd->atu_tx_free, c, atu_list);
		}
	}
	return(0);
}

void
atu_xfer_list_free(struct atu_softc *sc, struct atu_chain *ch,
    int listlen)
{
	int			i;

	/* Free resources. */
	for (i = 0; i < listlen; i++) {
		if (ch[i].atu_buf != NULL)
			ch[i].atu_buf = NULL;
		if (ch[i].atu_mbuf != NULL) {
			m_freem(ch[i].atu_mbuf);
			ch[i].atu_mbuf = NULL;
		}
		if (ch[i].atu_xfer != NULL) {
			usbd_free_xfer(ch[i].atu_xfer);
			ch[i].atu_xfer = NULL;
		}
	}
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
atu_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct atu_chain	*c = (struct atu_chain *)priv;
	struct atu_softc	*sc = c->atu_sc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct ifnet		*ifp = &ic->ic_if;
	struct atu_rx_hdr	*h;
	struct ieee80211_frame	*wh;
	struct ieee80211_rxinfo	rxi;
	struct ieee80211_node	*ni;
	struct mbuf		*m;
	u_int32_t		len;
	int			s;

	DPRINTFN(25, ("%s: atu_rxeof\n", sc->atu_dev.dv_xname));

	if (usbd_is_dying(sc->atu_udev))
		return;

	if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP))
		goto done;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("%s: status != USBD_NORMAL_COMPLETION\n",
		    sc->atu_dev.dv_xname));
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			return;
		}
#if 0
		if (status == USBD_IOERROR) {
			DPRINTF(("%s: rx: EEK! lost device?\n",
			    sc->atu_dev.dv_xname));

			/*
			 * My experience with USBD_IOERROR is that trying to
			 * restart the transfer will always fail and we'll
			 * keep on looping restarting transfers untill someone
			 * pulls the plug of the device.
			 * So we don't restart the transfer, but just let it
			 * die... If someone knows of a situation where we can
			 * recover from USBD_IOERROR, let me know.
			 */
			splx(s);
			return;
		}
#endif /* 0 */

		if (usbd_ratecheck(&sc->atu_rx_notice)) {
			DPRINTF(("%s: usb error on rx: %s\n",
			    sc->atu_dev.dv_xname, usbd_errstr(status)));
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(
			    sc->atu_ep[ATU_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (len < ATU_RX_HDRLEN) {
		DPRINTF(("%s: atu_rxeof: too short\n",
		    sc->atu_dev.dv_xname));
		ic->ic_stats.is_rx_tooshort++;
		ifp->if_ierrors++;
		goto done;
	}

	h = (struct atu_rx_hdr *)c->atu_buf;
	len = UGETW(h->length);
	if (len < IEEE80211_MIN_LEN) {
		ic->ic_stats.is_rx_tooshort++;
		ifp->if_ierrors++;
		goto done;
	}
	if (len > ATU_RX_BUFSZ) {
		ifp->if_ierrors++;
		goto done;
	}
	len -= IEEE80211_CRC_LEN;

	m = c->atu_mbuf;
	memcpy(mtod(m, char *), c->atu_buf + ATU_RX_HDRLEN, len);
	m->m_pkthdr.len = m->m_len = len;

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	s = splnet();

	if (atu_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done1; /* XXX if we can't allocate, why restart it? */
	}

#if NBPFILTER > 0
	if (sc->sc_radiobpf != NULL) {
		struct mbuf mb;
		struct atu_rx_radiotap_header *rr = &sc->sc_rxtap;

		rr->rr_flags = 0;
		rr->rr_chan_freq =
		    htole16(ic->ic_bss->ni_chan->ic_freq);
		rr->rr_chan_flags =
		    htole16(ic->ic_bss->ni_chan->ic_flags);
		rr->rr_rssi = h->rssi;
		rr->rr_max_rssi = ic->ic_max_rssi;

		mb.m_data = (caddr_t)rr;
		mb.m_len = sizeof(sc->sc_txtapu);
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_IN);
	}
#endif /* NBPFILTER > 0 */

	rxi.rxi_flags = 0;
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		/*
		 * WEP is decrypted by hardware. Clear WEP bit
		 * header for ieee80211_input().
		 */
		wh->i_fc[1] &= ~IEEE80211_FC1_WEP;
		rxi.rxi_flags |= IEEE80211_RXI_HWDEC;
	}

	rxi.rxi_rssi = h->rssi;
	rxi.rxi_tstamp = UGETDW(h->rx_time);
	ieee80211_input(ifp, m, ni, &rxi);

	ieee80211_release_node(ic, ni);
done1:
	splx(s);
done:
	/* Setup new transfer. */
	usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_RX], c, c->atu_buf,
	    ATU_RX_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		atu_rxeof);
	usbd_transfer(c->atu_xfer);
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */
void
atu_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct atu_chain	*c = (struct atu_chain *)priv;
	struct atu_softc	*sc = c->atu_sc;
	struct ifnet		*ifp = &sc->sc_ic.ic_if;
	usbd_status		err;
	int			s;

	DPRINTFN(25, ("%s: atu_txeof status=%d\n", sc->atu_dev.dv_xname,
	    status));

	if (c->atu_mbuf != NULL) {
		m_freem(c->atu_mbuf);
		c->atu_mbuf = NULL;
	}

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: usb error on tx: %s\n", sc->atu_dev.dv_xname,
		    usbd_errstr(status)));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->atu_ep[ATU_ENDPT_TX]);
		return;
	}

	usbd_get_xfer_status(c->atu_xfer, NULL, NULL, NULL, &err);

	if (err)
		ifp->if_oerrors++;

	s = splnet();
	SLIST_INSERT_HEAD(&sc->atu_cdata.atu_tx_free, c, atu_list);
	sc->atu_cdata.atu_tx_inuse--;
	if (sc->atu_cdata.atu_tx_inuse == 0)
		ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);

	atu_start(ifp);
}

u_int8_t
atu_calculate_padding(int size)
{
	size %= 64;

	if (size < 50)
		return (50 - size);
	if (size >=61)
		return (64 + 50 - size);
	return (0);
}

int
atu_tx_start(struct atu_softc *sc, struct ieee80211_node *ni,
    struct atu_chain *c, struct mbuf *m)
{
	int			len;
	struct atu_tx_hdr	*h;
	usbd_status		err;
	u_int8_t		pad;
#if NBPFILTER > 0
	struct ieee80211com *ic = &sc->sc_ic;
#endif

	DPRINTFN(25, ("%s: atu_tx_start\n", sc->atu_dev.dv_xname));

	/* Don't try to send when we're shutting down the driver */
	if (usbd_is_dying(sc->atu_udev)) {
		m_freem(m);
		return(EIO);
	}

#if NBPFILTER > 0
	if (sc->sc_radiobpf != NULL) {
		struct mbuf mb;
		struct atu_tx_radiotap_header *rt = &sc->sc_txtap;

		rt->rt_flags = 0;
		rt->rt_chan_freq =
		    htole16(ic->ic_bss->ni_chan->ic_freq);
		rt->rt_chan_flags =
		    htole16(ic->ic_bss->ni_chan->ic_flags);

		mb.m_data = (caddr_t)rt;
		mb.m_len = sizeof(sc->sc_txtapu);
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_radiobpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving
	 * enough room for the atmel headers
	 */
	len = m->m_pkthdr.len;

	m_copydata(m, 0, m->m_pkthdr.len, c->atu_buf + ATU_TX_HDRLEN);

	h = (struct atu_tx_hdr *)c->atu_buf;
	memset(h, 0, ATU_TX_HDRLEN);
	USETW(h->length, len);
	h->tx_rate = 4; /* XXX rate = auto */
	len += ATU_TX_HDRLEN;

	pad = atu_calculate_padding(len);
	len += pad;
	h->padding = pad;

	c->atu_length = len;
	c->atu_mbuf = m;

	usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_TX],
	    c, c->atu_buf, c->atu_length, USBD_NO_COPY, ATU_TX_TIMEOUT,
	    atu_txeof);

	/* Let's get this thing into the air! */
	c->atu_in_xfer = 1;
	err = usbd_transfer(c->atu_xfer);
	if (err != USBD_IN_PROGRESS) {
		DPRINTFN(25, ("%s: atu_tx_start: err=%d\n",
		    sc->atu_dev.dv_xname, err));
		c->atu_mbuf = NULL;
		m_freem(m);
		return(EIO);
	}

	return (0);
}

void
atu_start(struct ifnet *ifp)
{
	struct atu_softc	*sc = ifp->if_softc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct atu_cdata	*cd = &sc->atu_cdata;
	struct ieee80211_node	*ni;
	struct ieee80211_frame	*wh;
	struct atu_chain	*c;
	struct mbuf		*m = NULL;
	int			s;

	DPRINTFN(25, ("%s: atu_start: enter\n", sc->atu_dev.dv_xname));

	if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP)) {
		DPRINTFN(30, ("%s: atu_start: not running or up\n",
		    sc->atu_dev.dv_xname));
		return;
	}

	if (ifq_is_oactive(&ifp->if_snd)) {
		DPRINTFN(30, ("%s: atu_start: oactive\n",
		    sc->atu_dev.dv_xname));
		return;
	}

	for (;;) {
		/* grab a TX buffer */
		s = splnet();
		c = SLIST_FIRST(&cd->atu_tx_free);
		if (c != NULL) {
			SLIST_REMOVE_HEAD(&cd->atu_tx_free, atu_list);
			cd->atu_tx_inuse++;
			if (cd->atu_tx_inuse == ATU_TX_LIST_CNT)
				ifq_set_oactive(&ifp->if_snd);
		}
		splx(s);
		if (c == NULL) {
			DPRINTFN(10, ("%s: out of tx xfers\n",
			    sc->atu_dev.dv_xname));
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		/*
		 * Poll the management queue for frames, it has priority over
		 * normal data frames.
		 */
		m = mq_dequeue(&ic->ic_mgtq);
		if (m == NULL) {
			DPRINTFN(10, ("%s: atu_start: data packet\n",
			    sc->atu_dev.dv_xname));
			if (ic->ic_state != IEEE80211_S_RUN) {
				DPRINTFN(25, ("%s: no data till running\n",
				    sc->atu_dev.dv_xname));
				/* put the xfer back on the list */
				s = splnet();
				SLIST_INSERT_HEAD(&cd->atu_tx_free, c,
				    atu_list);
				cd->atu_tx_inuse--;
				splx(s);
				break;
			}

			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL) {
				DPRINTFN(25, ("%s: nothing to send\n",
				    sc->atu_dev.dv_xname));
				s = splnet();
				SLIST_INSERT_HEAD(&cd->atu_tx_free, c,
				    atu_list);
				cd->atu_tx_inuse--;
				splx(s);
				break;
			}

#if NBPFILTER > 0
			if (ifp->if_bpf)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif

			m = ieee80211_encap(ifp, m, &ni);
			if (m == NULL)
				goto bad;
			wh = mtod(m, struct ieee80211_frame *);

#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
		} else {
			DPRINTFN(25, ("%s: atu_start: mgmt packet\n",
			    sc->atu_dev.dv_xname));

			ni = m->m_pkthdr.ph_cookie;

			wh = mtod(m, struct ieee80211_frame *);
			/* sc->sc_stats.ast_tx_mgmt++; */
		}

		if (atu_tx_start(sc, ni, c, m)) {
bad:
			s = splnet();
			SLIST_INSERT_HEAD(&cd->atu_tx_free, c,
			    atu_list);
			cd->atu_tx_inuse--;
			splx(s);
			/* ifp_if_oerrors++; */
			if (ni != NULL)
				ieee80211_release_node(ic, ni);
			continue;
		}
		ifp->if_timer = 5;
	}
}

int
atu_init(struct ifnet *ifp)
{
	struct atu_softc	*sc = ifp->if_softc;
	struct ieee80211com	*ic = &sc->sc_ic;
	struct atu_chain	*c;
	usbd_status		err;
	int			i, s;

	s = splnet();

	DPRINTFN(10, ("%s: atu_init\n", sc->atu_dev.dv_xname));

	if (ifp->if_flags & IFF_RUNNING) {
		splx(s);
		return(0);
	}

	/* Init TX ring */
	if (atu_tx_list_init(sc))
		printf("%s: tx list init failed\n", sc->atu_dev.dv_xname);

	/* Init RX ring */
	if (atu_rx_list_init(sc))
		printf("%s: rx list init failed\n", sc->atu_dev.dv_xname);

	/* Load the multicast filter. */
	/*atu_setmulti(sc); */

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->atu_iface, sc->atu_ed[ATU_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->atu_ep[ATU_ENDPT_RX]);
	if (err) {
		DPRINTF(("%s: open rx pipe failed: %s\n",
		    sc->atu_dev.dv_xname, usbd_errstr(err)));
		splx(s);
		return(EIO);
	}

	err = usbd_open_pipe(sc->atu_iface, sc->atu_ed[ATU_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->atu_ep[ATU_ENDPT_TX]);
	if (err) {
		DPRINTF(("%s: open tx pipe failed: %s\n",
		    sc->atu_dev.dv_xname, usbd_errstr(err)));
		splx(s);
		return(EIO);
	}

	/* Start up the receive pipe. */
	for (i = 0; i < ATU_RX_LIST_CNT; i++) {
		c = &sc->atu_cdata.atu_rx_chain[i];

		usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_RX], c,
		    c->atu_buf, ATU_RX_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, atu_rxeof);
		usbd_transfer(c->atu_xfer);
	}

	DPRINTFN(10, ("%s: starting up using MAC=%s\n",
	    sc->atu_dev.dv_xname, ether_sprintf(ic->ic_myaddr)));

	/* Do initial setup */
	err = atu_initial_config(sc);
	if (err) {
		DPRINTF(("%s: initial config failed!\n",
		    sc->atu_dev.dv_xname));
		splx(s);
		return(EIO);
	}
	DPRINTFN(10, ("%s: initialised transceiver\n",
	    sc->atu_dev.dv_xname));

	/* sc->atu_rxfilt = ATU_RXFILT_UNICAST|ATU_RXFILT_BROADCAST; */

	/* If we want promiscuous mode, set the allframes bit. */
	/*
	if (ifp->if_flags & IFF_PROMISC)
		sc->atu_rxfilt |= ATU_RXFILT_PROMISC;
	*/

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	splx(s);

	/* XXX the following HAS to be replaced */
	s = splnet();
	err = ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);
	if (err)
		DPRINTFN(1, ("%s: atu_init: error calling "
		    "ieee80211_net_state", sc->atu_dev.dv_xname));
	splx(s);

	return 0;
}

int
atu_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct atu_softc	*sc = ifp->if_softc;
	int			err = 0, s;

	s = splnet();
	switch (command) {
	case SIOCSIFADDR:
		DPRINTFN(15, ("%s: SIOCSIFADDR\n", sc->atu_dev.dv_xname));

		ifp->if_flags |= IFF_UP;
		atu_init(ifp);
		break;

	case SIOCSIFFLAGS:
		DPRINTFN(15, ("%s: SIOCSIFFLAGS\n", sc->atu_dev.dv_xname));

		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->atu_if_flags & IFF_PROMISC)) {
/* enable promisc */
#if 0
				sc->atu_rxfilt |= ATU_RXFILT_PROMISC;
				atu_setword(sc, ATU_CMD_SET_PKT_FILTER,
				    sc->atu_rxfilt);
#endif
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->atu_if_flags & IFF_PROMISC) {
/* disable promisc */
#if 0
				sc->atu_rxfilt &= ~ATU_RXFILT_PROMISC;
				atu_setword(sc, ATU_CMD_SET_PKT_FILTER,
				    sc->atu_rxfilt);
#endif
			} else if (!(ifp->if_flags & IFF_RUNNING))
				atu_init(ifp);

			DPRINTFN(15, ("%s: ioctl calling atu_init()\n",
			    sc->atu_dev.dv_xname));
			atu_init(ifp);
			err = atu_switch_radio(sc, 1);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				atu_stop(ifp, 0);
			err = atu_switch_radio(sc, 0);
		}
		sc->atu_if_flags = ifp->if_flags;
		err = 0;
		break;

	case SIOCADDMULTI:
		DPRINTFN(15, ("%s: SIOCADDMULTI\n", sc->atu_dev.dv_xname));
		/* TODO: implement */
		err = 0;
		break;

	case SIOCDELMULTI:
		DPRINTFN(15, ("%s: SIOCDELMULTI\n", sc->atu_dev.dv_xname));
		/* TODO: implement */
		err = 0;
		break;

	default:
		DPRINTFN(15, ("%s: ieee80211_ioctl (%lu)\n",
		    sc->atu_dev.dv_xname, command));
		err = ieee80211_ioctl(ifp, command, data);
		break;
	}

	if (err == ENETRESET) {
		if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) ==
		    (IFF_RUNNING|IFF_UP)) {
			DPRINTF(("%s: atu_ioctl(): netreset\n",
			    sc->atu_dev.dv_xname));
			atu_init(ifp);
		}
		err = 0;
	}

	splx(s);
	return (err);
}

void
atu_watchdog(struct ifnet *ifp)
{
	struct atu_softc	*sc = ifp->if_softc;
	struct atu_chain	*c;
	usbd_status		stat;
	int			cnt, s;

	DPRINTF(("%s: atu_watchdog\n", sc->atu_dev.dv_xname));

	ifp->if_timer = 0;

	if ((ifp->if_flags & (IFF_RUNNING|IFF_UP)) != (IFF_RUNNING|IFF_UP))
		return;

	if (usbd_is_dying(sc->atu_udev))
		return;

	sc = ifp->if_softc;
	s = splnet();
	ifp->if_oerrors++;
	DPRINTF(("%s: watchdog timeout\n", sc->atu_dev.dv_xname));

	/*
	 * TODO:
	 * we should change this since we have multiple TX transfers...
	 */
	for (cnt = 0; cnt < ATU_TX_LIST_CNT; cnt++) {
		c = &sc->atu_cdata.atu_tx_chain[cnt];
		if (c->atu_in_xfer) {
			usbd_get_xfer_status(c->atu_xfer, NULL, NULL, NULL,
			    &stat);
			atu_txeof(c->atu_xfer, c, stat);
		}
	}

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		atu_start(ifp);
	splx(s);

	ieee80211_watchdog(ifp);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
atu_stop(struct ifnet *ifp, int disable)
{
	struct atu_softc	*sc = ifp->if_softc;
	struct atu_cdata	*cd;
	usbd_status		err;
	int s;

	s = splnet();
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_timer = 0;

	/* Stop transfers. */
	if (sc->atu_ep[ATU_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_RX]);
		err = usbd_close_pipe(sc->atu_ep[ATU_ENDPT_RX]);
		if (err) {
			DPRINTF(("%s: close rx pipe failed: %s\n",
			    sc->atu_dev.dv_xname, usbd_errstr(err)));
		}
		sc->atu_ep[ATU_ENDPT_RX] = NULL;
	}

	if (sc->atu_ep[ATU_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_TX]);
		err = usbd_close_pipe(sc->atu_ep[ATU_ENDPT_TX]);
		if (err) {
			DPRINTF(("%s: close tx pipe failed: %s\n",
			    sc->atu_dev.dv_xname, usbd_errstr(err)));
		}
		sc->atu_ep[ATU_ENDPT_TX] = NULL;
	}

	/* Free RX/TX/MGMT list resources. */
	cd = &sc->atu_cdata;
	atu_xfer_list_free(sc, cd->atu_rx_chain, ATU_RX_LIST_CNT);
	atu_xfer_list_free(sc, cd->atu_tx_chain, ATU_TX_LIST_CNT);

	/* Let's be nice and turn off the radio before we leave */
	atu_switch_radio(sc, 0);

	splx(s);
}
@


1.122
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.121 2017/01/22 10:17:39 dlg Exp $ */
d1673 1
a1673 1
	if (len <= 1) {
d1676 2
d1682 11
a1692 1
	len = UGETW(h->length) - 4; /* XXX magic number */
@


1.121
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.120 2016/11/06 12:58:01 mpi Exp $ */
d860 1
a860 1
	size_t	bytes_left = 0;
d889 1
a889 1
	err = loadfirmware(name, &firm, &bytes_left);
d897 1
d909 1
a909 1
				free(firm, M_DEVBUF, 0);
d931 1
a931 1
				free(firm, M_DEVBUF, 0);
d950 1
a950 1
	free(firm, M_DEVBUF, 0);
d992 1
a992 1
	size_t	bytes_left = 0;
d1001 1
a1001 1
	err = loadfirmware(name, &firm, &bytes_left);
d1008 1
d1023 1
a1023 1
			free(firm, M_DEVBUF, 0);
d1031 1
a1031 1
	free(firm, M_DEVBUF, 0);
@


1.120
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.119 2016/04/13 11:03:37 mpi Exp $ */
a1777 2
	else
		ifp->if_opackets++;
@


1.119
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.118 2016/03/17 21:36:48 krw Exp $ */
d1105 1
a1105 1
	if (!uaa->iface)
a1254 7

	err = usbd_set_config_no(dev, ATU_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->atu_dev.dv_xname);
		goto fail;
	}
@


1.118
log
@'miliseconds' -> 'milliseconds' in comments.

if_atu.c noted by Michal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.117 2015/12/11 16:07:02 mpi Exp $ */
a1442 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.117
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.116 2015/11/25 03:09:59 dlg Exp $ */
d971 1
a971 1
	 * about 56 miliseconds after sending the remap command before
@


1.116
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.115 2015/11/24 17:11:40 mpi Exp $ */
d270 2
a271 2
void	atu_internal_firmware(void *);
void	atu_external_firmware(void *);
d855 1
a855 1
atu_internal_firmware(void *arg)
d857 1
a857 1
	struct atu_softc *sc = arg;
d986 1
a986 1
atu_external_firmware(void *arg)
d988 1
a988 1
	struct atu_softc *sc = arg;
d1300 1
a1300 4
		if (rootvp == NULL)
			mountroothook_establish(atu_internal_firmware, sc);
		else
			atu_internal_firmware(sc);
d1337 1
a1337 4
		if (rootvp == NULL)
			mountroothook_establish(atu_external_firmware, sc);
		else
			atu_external_firmware(sc);
@


1.115
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.114 2015/11/04 12:12:00 dlg Exp $ */
d1800 1
a1800 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1918 2
a1919 2
	if (ifp->if_flags & IFF_OACTIVE) {
		DPRINTFN(30, ("%s: atu_start: IFF_OACTIVE\n",
d1932 1
a1932 1
				ifp->if_flags |= IFF_OACTIVE;
d1938 1
a1938 1
			ifp->if_flags |= IFF_OACTIVE;
d2095 1
a2095 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2251 2
a2252 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.114
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.113 2015/10/25 12:11:56 mpi Exp $ */
a73 1
#include <net/if_dl.h>
@


1.113
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.112 2015/06/24 09:40:54 mpi Exp $ */
d1947 1
a1947 1
		IF_DEQUEUE(&ic->ic_mgtq, m);
@


1.112
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.111 2015/02/10 23:25:46 mpi Exp $ */
a2113 1
	struct ifaddr		*ifa;
a2120 1
		ifa = (struct ifaddr *)data;
a2122 6

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
			break;
		}
@


1.111
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.110 2014/12/22 02:28:52 tedu Exp $ */
a1700 2

	ifp->if_ipackets++;
@


1.110
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.109 2014/07/13 15:52:49 mpi Exp $ */
a1696 1
	m->m_pkthdr.rcvif = ifp;
@


1.109
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.108 2014/07/12 18:48:52 tedu Exp $ */
a2129 1
#ifdef INET
a2132 1
#endif /* INET */
@


1.108
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.107 2014/07/12 07:59:23 mpi Exp $ */
a76 1
#ifdef INET
a78 1
#endif
@


1.107
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.106 2014/03/19 10:09:19 mpi Exp $ */
d911 1
a911 1
				free(firm, M_DEVBUF);
d933 1
a933 1
				free(firm, M_DEVBUF);
d952 1
a952 1
	free(firm, M_DEVBUF);
d1024 1
a1024 1
			free(firm, M_DEVBUF);
d1032 1
a1032 1
	free(firm, M_DEVBUF);
@


1.106
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.105 2014/03/07 18:39:02 mpi Exp $ */
d96 10
a105 15
int atu_match(struct device *, void *, void *); 
void atu_attach(struct device *, struct device *, void *); 
int atu_detach(struct device *, int); 
int atu_activate(struct device *, int); 

struct cfdriver atu_cd = { 
	NULL, "atu", DV_IFNET 
}; 

const struct cfattach atu_ca = { 
	sizeof(struct atu_softc), 
	atu_match, 
	atu_attach, 
	atu_detach, 
	atu_activate, 
a1506 13
}

int
atu_activate(struct device *self, int act)
{
	struct atu_softc *sc = (struct atu_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->atu_udev);
		break;
	}
	return (0);
@


1.105
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.104 2013/11/15 10:17:39 pirofti Exp $ */
d2016 1
a2016 11
			/*
			 * Hack!  The referenced node pointer is in the
			 * rcvif field of the packet header.  This is
			 * placed there by ieee80211_mgmt_output because
			 * we need to hold the reference with the frame
			 * and there's no other way (other than packet
			 * tags which we consider too expensive to use)
			 * to pass it along.
			 */
			ni = (struct ieee80211_node *)m->m_pkthdr.rcvif;
			m->m_pkthdr.rcvif = NULL;
@


1.104
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.103 2013/04/15 09:23:01 mglocker Exp $ */
a83 4

#ifdef USB_DEBUG
#define ATU_DEBUG
#endif
@


1.103
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.102 2013/04/12 12:58:39 mpi Exp $ */
d2304 1
a2304 5
		err = usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_RX]);
		if (err) {
			DPRINTF(("%s: abort rx pipe failed: %s\n",
			    sc->atu_dev.dv_xname, usbd_errstr(err)));
		}
d2314 1
a2314 5
		err = usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_TX]);
		if (err) {
			DPRINTF(("%s: abort tx pipe failed: %s\n",
			    sc->atu_dev.dv_xname, usbd_errstr(err)));
		}
@


1.102
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.101 2012/02/24 06:19:00 guenther Exp $ */
d254 2
a255 2
void	atu_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void	atu_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d305 1
a305 1
	usbd_xfer_handle	xfer;
d1261 1
a1261 1
	usbd_device_handle		dev = uaa->device;
d1651 1
a1651 1
atu_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1789 1
a1789 1
atu_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.101
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.100 2011/09/18 23:24:12 krw Exp $ */
d333 1
a333 1
	    length, USBD_SHORT_XFER_OK, 0);
d335 1
a335 1
	err = usbd_sync_transfer(xfer);
@


1.100
log
@usbdivar.h needs struct timeout. But don't get it indirectly via
sys/kthread.h,  use sys/timeout.h explicitly. Noted by Michael
Knudsen.

ok deraadt@@ kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.99 2011/07/03 15:47:17 matthew Exp $ */
d342 1
a342 1
			DPRINTFN(20, ("%s: transfered 0x%x bytes in\n",
@


1.99
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.98 2010/12/17 22:38:54 jasper Exp $ */
d56 1
a56 1
#include <sys/kthread.h>
@


1.98
log
@- use nitems()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.97 2010/12/06 04:41:39 jakemsr Exp $ */
a1523 2
	case DVACT_ACTIVATE:
		break;
@


1.97
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.96 2010/10/27 17:51:11 jakemsr Exp $ */
d895 1
a895 1
	for (i = 0; i < sizeof(atu_radfirm)/sizeof(atu_radfirm[0]); i++)
d1006 1
a1006 1
	for (i = 0; i < sizeof(atu_radfirm)/sizeof(atu_radfirm[0]); i++)
d1120 1
a1120 1
	for (i = 0; i < sizeof(atu_devs)/sizeof(atu_devs[0]); i++) {
d1286 1
a1286 1
	for (i = 0; i < sizeof(atu_devs)/sizeof(atu_devs[0]); i++) {
@


1.96
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.95 2010/10/23 15:42:09 jakemsr Exp $ */
d905 1
a905 1
		return;
d921 1
a921 1
				return;
d943 1
a943 1
				return;
d972 1
a972 1
		return;
d979 1
a979 1
		return;
d992 3
d1175 1
a1175 1
	if (sc->sc_state != ATU_S_OK)
d1265 2
a1266 1
	sc->sc_state = ATU_S_UNCONFIG;
d1272 1
a1272 1
		return;
d1279 1
a1279 1
		return;
a1281 3
	sc->atu_unit = self->dv_unit;
	sc->atu_udev = dev;

d1365 2
d1392 1
a1392 1
			return;
d1408 1
a1408 1
		return;
d1488 2
a1489 1
	sc->sc_state = ATU_S_OK;
d1498 1
a1498 2
	DPRINTFN(10, ("%s: atu_detach state=%d\n", sc->atu_dev.dv_xname,
	    sc->sc_state));
d1500 1
a1500 1
	if (sc->sc_state != ATU_S_UNCONFIG) {
d1503 1
a1503 1
		usb_rem_task(sc->atu_udev, &sc->sc_task);
d1505 8
a1512 9
		if (sc->atu_ep[ATU_ENDPT_TX] != NULL)
			usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_TX]);
		if (sc->atu_ep[ATU_ENDPT_RX] != NULL)
			usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_RX]);

		if (ifp->if_softc != NULL) {
			ieee80211_ifdetach(ifp);
			if_detach(ifp);
		}
d1527 1
a1527 2
		if (sc->sc_state != ATU_S_UNCONFIG)
			sc->sc_state = ATU_S_DEAD;
d1669 1
a1669 1
	if (sc->sc_state != ATU_S_OK)
d1863 1
a1863 1
	if (sc->sc_state != ATU_S_OK) {
d2260 1
a2260 1
	if (sc->sc_state != ATU_S_OK)
@


1.95
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.94 2009/11/21 14:18:34 deraadt Exp $ */
d1507 4
a1510 2
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
@


1.94
log
@Do the operations in atu_detach in the right order, as done in
other drivers recently.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.93 2009/10/13 19:33:17 pirofti Exp $ */
d1470 1
a1470 1
	usb_init_task(&sc->sc_task, atu_task, sc);
@


1.93
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.92 2008/07/21 18:43:19 damien Exp $ */
d1499 2
a1500 2
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
d1507 2
a1508 1
		usb_rem_task(sc->atu_udev, &sc->sc_task);
@


1.92
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.91 2007/11/27 16:22:13 martynas Exp $ */
d103 1
a103 1
int atu_activate(struct device *, enum devact); 
d1514 1
a1514 1
atu_activate(struct device *self, enum devact act)
@


1.91
log
@typos;  ok jmc@@
sys/dev/pci/pciide.c from naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.90 2007/11/25 16:40:03 jmc Exp $ */
d1657 1
d1757 1
d1764 1
d1767 3
a1769 1
	ieee80211_input(ifp, m, ni, h->rssi, UGETDW(h->rx_time));
@


1.90
log
@spelling fixes, from Martynas Venckus;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.89 2007/10/11 18:33:13 deraadt Exp $ */
d879 1
a879 1
	 * Maybe this could be moved to a seperate 'firmware driver' once more
@


1.89
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.88 2007/10/06 16:01:17 jsg Exp $ */
d720 1
a720 1
	 * we should do something usefull with this info. right now it's just
@


1.88
log
@Another NPBFILTER comment typo.
From Jung <moorang@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.87 2007/09/17 01:40:38 fgsch Exp $ */
a1256 1
	char				*devinfop;
a1263 4
	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s", sc->atu_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);

a1310 2
		printf("\n");

d1403 1
a1403 1
		printf("\n%s: could not get card cfg!\n",
d1423 2
a1424 1
	printf(", address %s\n", ether_sprintf(ic->ic_myaddr));
@


1.87
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.86 2007/07/18 18:10:31 damien Exp $ */
d1760 1
a1760 1
#endif /* NPBFILTER > 0 */
@


1.86
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.85 2007/06/14 10:11:15 mbalmer Exp $ */
a55 1
#include <sys/malloc.h>
@


1.85
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.84 2007/06/12 16:26:36 mbalmer Exp $ */
d692 2
a693 2
	switch (ic->ic_nw_keys[ic->ic_wep_txkey].wk_len) {
	case 5:
d696 1
a696 1
	case 13:
d706 2
a707 2
		memcpy(cmd.WEP_DefaultKey[i], ic->ic_nw_keys[i].wk_key,
		    ic->ic_nw_keys[i].wk_len);
@


1.84
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.83 2007/06/10 14:49:00 mbalmer Exp $ */
d101 16
a116 1
USB_DECLARE_DRIVER_CLASS(atu, DV_IFNET);
@


1.83
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.82 2007/06/09 12:22:53 mbalmer Exp $ */
d1506 1
a1506 1
atu_activate(device_ptr_t self, enum devact act)
@


1.82
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.81 2007/05/27 04:00:24 jsg Exp $ */
d305 1
a305 1
			    "len=%02x\n", USBDEVNAME(sc->atu_dev), request,
d309 1
a309 1
			    "len=%02x [%8D]\n", USBDEVNAME(sc->atu_dev),
d329 1
a329 1
			    USBDEVNAME(sc->atu_dev), total_len));
d331 1
a331 1
			    USBDEVNAME(sc->atu_dev), data, " "));
d335 1
a335 1
				    USBDEVNAME(sc->atu_dev), total_len));
d376 1
a376 1
	    USBDEVNAME(sc->atu_dev), cmd));
d386 1
a386 1
			    USBDEVNAME(sc->atu_dev),
d397 1
a397 1
			    USBDEVNAME(sc->atu_dev)));
d458 1
a458 1
	    USBDEVNAME(sc->atu_dev)));
d498 1
a498 1
		    USBDEVNAME(sc->atu_dev)));
d506 1
a506 1
		    USBDEVNAME(sc->atu_dev)));
d514 1
a514 1
		    USBDEVNAME(sc->atu_dev)));
d519 1
a519 1
	    USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_bssid)));
d564 2
a565 2
		    USBDEVNAME(sc->atu_dev), sizeof(Scan)));
		DPRINTFN(20, ("%s: scan cmd: %52D\n", USBDEVNAME(sc->atu_dev),
d618 1
a618 1
		    USBDEVNAME(sc->atu_dev), state ? "on" : "off"));
d635 1
a635 1
	DPRINTFN(10, ("%s: sending mac-addr\n", USBDEVNAME(sc->atu_dev)));
d639 1
a639 1
		    USBDEVNAME(sc->atu_dev)));
d644 1
a644 1
	DPRINTF(("%s: sending reg-domain\n", USBDEVNAME(sc->atu_dev)));
d648 1
a648 1
		    USBDEVNAME(sc->atu_dev)));
d712 1
a712 1
		    USBDEVNAME(sc->atu_dev)));
d715 1
a715 1
		    "adapter\n", USBDEVNAME(sc->atu_dev), reg_domain));
d720 1
a720 1
		DPRINTFN(20, ("%s: configlen=%02x\n", USBDEVNAME(sc->atu_dev),
d723 1
a723 1
		    USBDEVNAME(sc->atu_dev), (u_int8_t *)&cmd, " "));
d768 1
a768 1
	   USBDEVNAME(sc->atu_dev)));
d786 2
a787 2
	    USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_bssid)));
	DPRINTFN(15, ("%s: mode=%d\n", USBDEVNAME(sc->atu_dev),
d802 1
a802 1
	    USBDEVNAME(sc->atu_dev), ether_sprintf(join.bssid)));
d806 1
a806 1
		    USBDEVNAME(sc->atu_dev)));
d812 1
a812 1
		    USBDEVNAME(sc->atu_dev)));
d817 1
a817 1
		    USBDEVNAME(sc->atu_dev), status));
d820 1
a820 1
		DPRINTFN(10, ("%s: joined BSS\n", USBDEVNAME(sc->atu_dev)));
d886 1
a886 1
	    USBDEVNAME(sc->atu_dev), name));
d890 1
a890 1
		    USBDEVNAME(sc->atu_dev), name, err);
d905 1
a905 1
				    USBDEVNAME(sc->atu_dev)));
d921 1
a921 1
			    USBDEVNAME(sc->atu_dev), block));
d927 1
a927 1
				    USBDEVNAME(sc->atu_dev)));
d940 1
a940 1
			    USBDEVNAME(sc->atu_dev)));
d951 1
a951 1
		    USBDEVNAME(sc->atu_dev)));
d957 1
a957 1
		    USBDEVNAME(sc->atu_dev)));
d961 1
a961 1
	DPRINTFN(15, ("%s: sending remap\n", USBDEVNAME(sc->atu_dev)));
d964 1
a964 1
		DPRINTF(("%s: remap failed!\n", USBDEVNAME(sc->atu_dev)));
d976 1
a976 1
	    USBDEVNAME(sc->atu_dev));
d994 1
a994 1
	    USBDEVNAME(sc->atu_dev), name));
d998 1
a998 1
		    USBDEVNAME(sc->atu_dev), name, err);
d1010 1
a1010 1
		    USBDEVNAME(sc->atu_dev), block, block_size));
d1015 1
a1015 1
			    "block\n", USBDEVNAME(sc->atu_dev)));
d1030 1
a1030 1
		    "block\n", USBDEVNAME(sc->atu_dev)));
d1043 1
a1043 1
	    USBDEVNAME(sc->atu_dev)));
d1068 1
a1068 1
			    USBDEVNAME(sc->atu_dev)));
d1081 1
a1081 1
			    USBDEVNAME(sc->atu_dev)));
d1122 1
a1122 1
	DPRINTFN(10, ("%s: atu_media_change\n", USBDEVNAME(sc->atu_dev)));
d1142 1
a1142 1
	DPRINTFN(10, ("%s: atu_media_status\n", USBDEVNAME(sc->atu_dev)));
d1156 1
a1156 1
	DPRINTFN(10, ("%s: atu_task\n", USBDEVNAME(sc->atu_dev)));
d1167 1
a1167 1
			    USBDEVNAME(sc->atu_dev)));
d1174 1
a1174 1
			    USBDEVNAME(sc->atu_dev)));
d1179 1
a1179 1
		    USBDEVNAME(sc->atu_dev)));
d1187 1
a1187 1
		    USBDEVNAME(sc->atu_dev)));
d1202 1
a1202 1
	DPRINTFN(10, ("%s: atu_newstate: %s -> %s\n", USBDEVNAME(sc->atu_dev),
d1252 1
a1252 1
	printf("\n%s: %s", USBDEVNAME(sc->atu_dev), devinfop);
d1258 1
a1258 1
		    USBDEVNAME(sc->atu_dev));
d1265 1
a1265 1
		    USBDEVNAME(sc->atu_dev));
d1297 1
a1297 1
	DPRINTFN(20, ("%s: opmode: %d\n", USBDEVNAME(sc->atu_dev), mode));
d1300 1
a1300 1
		    USBDEVNAME(sc->atu_dev)));
d1320 1
a1320 1
		    USBDEVNAME(sc->atu_dev)));
d1324 1
a1324 1
			    USBDEVNAME(sc->atu_dev), mode));
d1338 1
a1338 1
				    USBDEVNAME(sc->atu_dev)));
d1378 1
a1378 1
			DPRINTF(("%s: num_endp:%d\n", USBDEVNAME(sc->atu_dev),
d1381 1
a1381 1
			    USBDEVNAME(sc->atu_dev), i));
d1397 1
a1397 1
		    USBDEVNAME(sc->atu_dev));
d1407 1
a1407 1
		    "build:%d\n", USBDEVNAME(sc->atu_dev), fw.major, fw.minor,
d1411 1
a1411 1
		    USBDEVNAME(sc->atu_dev)));
d1444 1
a1444 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->atu_dev), IFNAMSIZ);
d1486 1
a1486 1
	DPRINTFN(10, ("%s: atu_detach state=%d\n", USBDEVNAME(sc->atu_dev),
d1533 1
a1533 1
			    USBDEVNAME(sc->atu_dev)));
d1540 1
a1540 1
			    USBDEVNAME(sc->atu_dev)));
d1562 1
a1562 1
	    USBDEVNAME(sc->atu_dev)));
d1591 1
a1591 1
	    USBDEVNAME(sc->atu_dev)));
d1654 1
a1654 1
	DPRINTFN(25, ("%s: atu_rxeof\n", USBDEVNAME(sc->atu_dev)));
d1664 1
a1664 1
		    USBDEVNAME(sc->atu_dev)));
d1671 1
a1671 1
			    USBDEVNAME(sc->atu_dev)));
d1689 1
a1689 1
			    USBDEVNAME(sc->atu_dev), usbd_errstr(status)));
d1701 1
a1701 1
		    USBDEVNAME(sc->atu_dev)));
d1782 1
a1782 1
	DPRINTFN(25, ("%s: atu_txeof status=%d\n", USBDEVNAME(sc->atu_dev),
d1794 1
a1794 1
		DPRINTF(("%s: usb error on tx: %s\n", USBDEVNAME(sc->atu_dev),
d1843 1
a1843 1
	DPRINTFN(25, ("%s: atu_tx_start\n", USBDEVNAME(sc->atu_dev)));
d1902 1
a1902 1
		    USBDEVNAME(sc->atu_dev), err));
d1923 1
a1923 1
	DPRINTFN(25, ("%s: atu_start: enter\n", USBDEVNAME(sc->atu_dev)));
d1927 1
a1927 1
		    USBDEVNAME(sc->atu_dev)));
d1933 1
a1933 1
		    USBDEVNAME(sc->atu_dev)));
d1950 1
a1950 1
			    USBDEVNAME(sc->atu_dev)));
d1962 1
a1962 1
			    USBDEVNAME(sc->atu_dev)));
d1965 1
a1965 1
				    USBDEVNAME(sc->atu_dev)));
d1978 1
a1978 1
				    USBDEVNAME(sc->atu_dev)));
d2003 1
a2003 1
			    USBDEVNAME(sc->atu_dev)));
d2048 1
a2048 1
	DPRINTFN(10, ("%s: atu_init\n", USBDEVNAME(sc->atu_dev)));
d2057 1
a2057 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->atu_dev));
d2061 1
a2061 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->atu_dev));
d2071 1
a2071 1
		    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
d2080 1
a2080 1
		    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
d2096 1
a2096 1
	    USBDEVNAME(sc->atu_dev), ether_sprintf(ic->ic_myaddr)));
d2102 1
a2102 1
		    USBDEVNAME(sc->atu_dev)));
d2107 1
a2107 1
	    USBDEVNAME(sc->atu_dev)));
d2126 1
a2126 1
		    "ieee80211_net_state", USBDEVNAME(sc->atu_dev)));
d2142 1
a2142 1
		DPRINTFN(15, ("%s: SIOCSIFADDR\n", USBDEVNAME(sc->atu_dev)));
d2158 1
a2158 1
		DPRINTFN(15, ("%s: SIOCSIFFLAGS\n", USBDEVNAME(sc->atu_dev)));
d2183 1
a2183 1
			    USBDEVNAME(sc->atu_dev)));
d2196 1
a2196 1
		DPRINTFN(15, ("%s: SIOCADDMULTI\n", USBDEVNAME(sc->atu_dev)));
d2202 1
a2202 1
		DPRINTFN(15, ("%s: SIOCDELMULTI\n", USBDEVNAME(sc->atu_dev)));
d2209 1
a2209 1
		    USBDEVNAME(sc->atu_dev), command));
d2218 1
a2218 1
			    USBDEVNAME(sc->atu_dev)));
d2236 1
a2236 1
	DPRINTF(("%s: atu_watchdog\n", USBDEVNAME(sc->atu_dev)));
d2249 1
a2249 1
	DPRINTF(("%s: watchdog timeout\n", USBDEVNAME(sc->atu_dev)));
d2292 1
a2292 1
			    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
d2297 1
a2297 1
			    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
d2306 1
a2306 1
			    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
d2311 1
a2311 1
			    USBDEVNAME(sc->atu_dev), usbd_errstr(err)));
@


1.81
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.80 2007/04/10 17:47:55 miod Exp $ */
d1514 1
a1514 2
		if (sc->sc_state != ATU_S_UNCONFIG) {
			if_deactivate(&sc->atu_ec.ec_if);
a1515 1
		}
@


1.80
log
@``it's'' -> ``its'' when the grammar gods require this change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.79 2007/01/02 14:43:50 claudio Exp $ */
d1094 2
a1095 1
USB_MATCH(atu)
d1097 1
a1097 1
	USB_MATCH_START(atu, uaa);
d1238 2
a1239 1
USB_ATTACH(atu)
d1241 2
a1242 1
	USB_ATTACH_START(atu, sc, uaa);
d1252 1
a1252 2
	USB_ATTACH_SETUP;
	printf("%s: %s", USBDEVNAME(sc->atu_dev), devinfop);
d1259 1
a1259 1
		USB_ATTACH_ERROR_RETURN;
d1266 1
a1266 1
		USB_ATTACH_ERROR_RETURN;
d1313 1
a1313 1
		USB_ATTACH_SUCCESS_RETURN;
d1340 1
a1340 1
				USB_ATTACH_SUCCESS_RETURN;
a1356 2

	USB_ATTACH_SUCCESS_RETURN;
d1480 2
a1481 1
USB_DETACH(atu)
d1483 1
a1483 1
	USB_DETACH_START(atu, sc);
@


1.79
log
@Don't use M_DUP_PKTHDR() in the driver bpf hook. Using M_DUP_PKTHDR() on a
static mbuf results in a mbuf tag memory leak. Same change as in rum(4).
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.78 2006/12/21 02:28:47 krw Exp $ */
d502 1
a502 1
	/* Wait for the adapter to do it's thing */
d1035 1
a1035 1
	 * The SMC2662w V.4 seems to require some time to do it's thing with
@


1.78
log
@'tranfer' -> 'transfer' in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.77 2006/11/26 17:20:33 jsg Exp $ */
a1738 1
		M_DUP_PKTHDR(&mb, m);
d1742 3
a1744 1
		mb.m_pkthdr.len += mb.m_len;
a1862 1
		M_DUP_PKTHDR(&mb, m);
d1866 3
a1868 1
		mb.m_pkthdr.len += mb.m_len;
@


1.77
log
@Make use of ieee80211_std_rateset
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.76 2006/07/17 11:43:12 mk Exp $ */
d2252 1
a2252 1
	 * we should change this since we have multiple TX tranfers...
@


1.76
log
@No point in memsetting individual struct members after memsetting the
entire struct.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.75 2006/07/09 22:39:50 dlg Exp $ */
d1432 1
a1432 6
	i = 0;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[i++] = 2;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[i++] = 4;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[i++] = 11;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_rates[i++] = 22;
	ic->ic_sup_rates[IEEE80211_MODE_11B].rs_nrates = i;
@


1.75
log
@remove dead code
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.74 2006/07/09 22:10:05 mk Exp $ */
a541 1
	memset(Scan.SSID, 0x00, sizeof(Scan.SSID));
a695 1
	memset(cmd.SSID, 0x00, sizeof(cmd.SSID));
a789 1
	memset(join.essid, 0x00, 32);
@


1.74
log
@I don't think we're talking about animals in here, so
s/wether/whether/g.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.73 2006/06/27 03:58:07 jsg Exp $ */
a277 4
#ifdef ATU_DEBUG
void	atu_print_a_bunch_of_debug_things(struct atu_softc *sc);
#endif

a2137 84

#ifdef ATU_DEBUG
void
atu_print_a_bunch_of_debug_things(struct atu_softc *sc)
{
	usbd_status		err;
	u_int8_t		tmp[32];

	/* DEBUG */
	if ((err = atu_get_mib(sc, MIB_MAC_MGMT__CURRENT_BSSID, tmp)))
		return;
	DPRINTF(("%s: DEBUG: current BSSID=%s\n", USBDEVNAME(sc->atu_dev),
	    ether_sprintf(tmp)));

	if ((err = atu_get_mib(sc, MIB_MAC_MGMT__BEACON_PERIOD, tmp)))
		return;
	DPRINTF(("%s: DEBUG: beacon period=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_MAC_WEP__PRIVACY_INVOKED, tmp)))
		return;
	DPRINTF(("%s: DEBUG: privacy invoked=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_MAC_WEP__ENCR_LEVEL, tmp)))
		return;
	DPRINTF(("%s: DEBUG: encr_level=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_MAC_WEP__ICV_ERROR_COUNT, tmp)))
		return;
	DPRINTF(("%s: DEBUG: icv error count=%d\n", USBDEVNAME(sc->atu_dev),
	    *(short *)tmp));

	if ((err = atu_get_mib(sc, MIB_MAC_WEP__EXCLUDED_COUNT, tmp)))
		return;
	DPRINTF(("%s: DEBUG: wep excluded count=%d\n",
	    USBDEVNAME(sc->atu_dev), *(short *)tmp));

	if ((err = atu_get_mib(sc, MIB_MAC_MGMT__POWER_MODE, tmp)))
		return;
	DPRINTF(("%s: DEBUG: power mode=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_PHY__CHANNEL, tmp)))
		return;
	DPRINTF(("%s: DEBUG: channel=%d\n", USBDEVNAME(sc->atu_dev), tmp[0]));

	if ((err = atu_get_mib(sc, MIB_PHY__REG_DOMAIN, tmp)))
		return;
	DPRINTF(("%s: DEBUG: reg domain=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_LOCAL__SSID_SIZE, tmp)))
		return;
	DPRINTF(("%s: DEBUG: ssid size=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_LOCAL__BEACON_ENABLE, tmp)))
		return;
	DPRINTF(("%s: DEBUG: beacon enable=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));

	if ((err = atu_get_mib(sc, MIB_LOCAL__AUTO_RATE_FALLBACK, tmp)))
		return;
	DPRINTF(("%s: DEBUG: auto rate fallback=%d\n",
	    USBDEVNAME(sc->atu_dev), tmp[0]));

	if ((err = atu_get_mib(sc, MIB_MAC_ADDR__ADDR, tmp)))
		return;
	DPRINTF(("%s: DEBUG: mac addr=%s\n", USBDEVNAME(sc->atu_dev),
	    ether_sprintf(tmp)));

	if ((err = atu_get_mib(sc, MIB_MAC__DESIRED_SSID, tmp)))
		return;
	DPRINTF(("%s: DEBUG: desired ssid=%s\n", USBDEVNAME(sc->atu_dev),
	    tmp));

	if ((err = atu_get_mib(sc, MIB_MAC_MGMT__CURRENT_ESSID, tmp)))
		return;
	DPRINTF(("%s: DEBUG: current ESSID=%s\n", USBDEVNAME(sc->atu_dev),
	    tmp));
}
#endif /* ATU_DEBUG */
@


1.73
log
@Add support for max rssi/signal strength percentage on RFMD 2958
based adapters.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.72 2006/06/23 06:27:11 miod Exp $ */
d563 1
a563 1
	/* wether or not we scan all channels */
@


1.72
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.71 2006/06/19 16:03:19 mk Exp $ */
d213 1
d215 4
a218 4
	{ RadioRFMD,		"atu-rfmd-int",		"atu-rfmd-ext" },
	{ RadioRFMD2958,	"atu-rfmd2958-int",	"atu-rfmd2958-ext" },
	{ RadioRFMD2958_SMC,	"atu-rfmd2958smc-int",	"atu-rfmd2958smc-ext" },
	{ RadioIntersil,	"atu-intersil-int",	"atu-intersil-ext" },
d222 2
a223 1
		"atu-at76c503-i3863-ext"
d228 2
a229 1
		"atu-at76c503-rfmd-acc-ext"
d234 2
a235 1
		"atu-at76c505-rfmd-ext"
d1437 1
d1748 2
a1749 1
		rr->rr_antsignal = h->rssi;
@


1.71
log
@Don't sleep and then say we're going to sleep -- do it the other way
around because the other thing is just silly and confusing.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.70 2006/05/11 18:50:19 miod Exp $ */
a1517 1
		return (EOPNOTSUPP);
@


1.70
log
@if (!foo & BAR) bad, if (!(foo & BAR)) better, and I'll have a cookie per
file.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.69 2006/03/25 22:41:46 djm Exp $ */
a941 1
			usbd_delay_ms(sc->atu_udev, 100);
d944 1
@


1.69
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.68 2006/02/20 20:12:14 damien Exp $ */
d966 1
a966 1
	if ((err) && (! sc->atu_quirk & ATU_QUIRK_NO_REMAP)) {
@


1.68
log
@Fix kernel builds without bpfilter. Linking is still broken.

"Please commit this diff ASAP" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.67 2006/01/29 03:22:52 brad Exp $ */
d1751 1
a1751 1
		bpf_mtap(sc->sc_radiobpf, &mb);
d1874 1
a1874 1
		bpf_mtap(sc->sc_radiobpf, &mb);
d1995 1
a1995 1
				bpf_mtap(ifp->if_bpf, m);
d2005 1
a2005 1
				bpf_mtap(ic->ic_rawbpf, m);
@


1.67
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.66 2006/01/29 01:13:47 dlg Exp $ */
d1846 1
d1848 1
@


1.66
log
@prettify dmesg output a touch. from Michael Knudsen.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.65 2006/01/04 06:04:41 canacar Exp $ */
d1701 1
a1701 1
			usbd_clear_endpoint_stall(
d1804 1
a1804 1
			usbd_clear_endpoint_stall(sc->atu_ep[ATU_ENDPT_TX]);
@


1.65
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.64 2005/08/01 05:36:47 brad Exp $ */
d1253 1
a1253 1
	printf("%s: %s\n", USBDEVNAME(sc->atu_dev), devinfop);
d1419 1
a1419 1
	printf(": address %s\n", ether_sprintf(ic->ic_myaddr));
@


1.64
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.63 2005/07/07 22:47:08 dlg Exp $ */
a1496 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.63
log
@extend what jcs did a bit further by removing atus storage for the ssid.
now there is no confusion since it is only provided by net80211.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.62 2005/07/07 15:14:56 jcs Exp $ */
d1243 1
a1243 1
	char				devinfo[1024];
d1251 1
a1251 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d1253 2
a1254 1
	printf("%s: %s", USBDEVNAME(sc->atu_dev), devinfo);
@


1.62
log
@initialize Scan.SSID from the right source

fixes association with access points with ssid broadcasting disabled

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.61 2005/07/01 04:09:19 jsg Exp $ */
d697 3
a699 3
	memset(cmd.SSID, 0, sizeof(cmd.SSID));
	memcpy(cmd.SSID, sc->atu_ssid, sc->atu_ssidlen);
	cmd.SSID_Len = sc->atu_ssidlen;
a1422 2
	sc->atu_ssidlen = strlen(ATU_DEFAULT_SSID);
	memcpy(sc->atu_ssid, ATU_DEFAULT_SSID, sc->atu_ssidlen);
@


1.61
log
@Remove duplicate if_start assignment. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.60 2005/05/23 20:09:31 jsg Exp $ */
d527 1
d543 2
a544 2
	memcpy(Scan.SSID, sc->atu_ssid, sc->atu_ssidlen);
	Scan.SSID_Len = sc->atu_ssidlen;
@


1.60
log
@Initial radiotap support. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.59 2005/03/08 12:15:12 dlg Exp $ */
a1454 1
	ifp->if_start = atu_start;
@


1.59
log
@add support for the new firmwares and the devices that use them
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.58 2005/03/08 09:54:18 dlg Exp $ */
a70 1
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))
d1472 13
d1498 3
a1500 1

d1739 19
a1757 3
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
#endif
d1850 1
d1860 20
d1995 4
a1998 1
			/* XXX bpf listener goes here */
d2004 5
@


1.58
log
@lots of new devices found in a linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.57 2005/03/03 13:25:16 dlg Exp $ */
d112 2
a113 2
	{ USB_VENDOR_ADDTRON,	USB_PRODUCT_ADDTRON_AWU120,
	  RadioIntersil,	ATU_NO_QUIRK },
d120 2
d130 1
a130 1
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503,
d132 2
d136 2
d196 2
d202 2
d218 16
a233 1
	{ RadioIntersil,	"atu-intersil-int",	"atu-intersil-ext" }
d1064 2
d1078 1
@


1.57
log
@sort devices and remove a duplicate
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.56 2005/03/03 11:42:48 dlg Exp $ */
d108 6
d118 2
d122 4
d128 1
a128 1
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503A,
d130 4
d136 17
a152 1
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_BW002,
d154 1
a154 1
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_WL1130,
d156 5
a160 1
	{ USB_VENDOR_BELKIN,	USB_PRODUCT_BELKIN_F5D6050,
d162 8
d172 2
d176 2
d180 4
d188 10
@


1.56
log
@properly implement hardware wep support. mostly done by jesse off with
some minor cleanup by me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.55 2005/03/03 09:49:22 dlg Exp $ */
d108 6
d116 4
d122 2
a123 2
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C503A,
	  RadioIntersil,	ATU_NO_QUIRK },
a133 8
	{ USB_VENDOR_ACERP,	USB_PRODUCT_ACERP_AWL400,
	  RadioRFMD,		ATU_NO_QUIRK },
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_WL1130,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_LINKSYS3,	USB_PRODUCT_LINKSYS3_WUSB11V28,
	  RadioRFMD2958,	ATU_NO_QUIRK },
	{ USB_VENDOR_AINCOMM,	USB_PRODUCT_AINCOMM_AWU2000B,
	  RadioRFMD2958,	ATU_NO_QUIRK },
a135 5
	/* SMC2662 V.4 */
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_AT76C505A,
	  RadioRFMD2958_SMC,	ATU_QUIRK_NO_REMAP | ATU_QUIRK_FW_DELAY },
	{ USB_VENDOR_ACERP,	USB_PRODUCT_ACERP_AWL300,
	  RadioIntersil,	ATU_NO_QUIRK },
@


1.55
log
@some mbuf handling fixes from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.54 2005/03/03 09:38:07 itojun Exp $ */
a189 1
int	atu_set_wepkey(struct atu_softc *sc, int nr, u_int8_t *key, int len);
d545 1
d591 1
a591 4
	if (sc->atu_encrypt == ATU_WEP_OFF)
		cmd.PrivacyInvoked = 0;
	else
		cmd.PrivacyInvoked = 1;
d594 17
a610 1
	cmd.EncryptionType = sc->atu_wepkeylen;
a616 5
	cmd.WEP_DefaultKeyID = sc->atu_wepkey;
	memcpy(cmd.WEP_DefaultKey, sc->atu_wepkeys,
	    sizeof(cmd.WEP_DefaultKey));

	cmd.ShortPreamble = 1;
a1333 3
	sc->atu_encrypt = ATU_WEP_OFF;
	sc->atu_wepkeylen = ATU_WEP_104BITS;
	sc->atu_wepkey = 0;
a1340 1
	sc->atu_encrypt = ATU_WEP_OFF;
d1642 8
a2076 18
int
atu_set_wepkey(struct atu_softc *sc, int nr, u_int8_t *key, int len)
{
	if ((len != 5) && (len != 13))
		return EINVAL;

	DPRINTFN(10, ("%s: changed wepkey %d (len=%d)\n",
	    USBDEVNAME(sc->atu_dev), nr, len));

	memcpy(sc->atu_wepkeys[nr], key, len);
	if (len == 13)
		sc->atu_wepkeylen = ATU_WEP_104BITS;
	else
		sc->atu_wepkeylen = ATU_WEP_40BITS;

	atu_send_mib(sc, MIB_MAC_WEP__ENCR_LEVEL, NR(sc->atu_wepkeylen));
	return atu_send_mib(sc, MIB_MAC_WEP__KEYS(nr), key);
}
@


1.54
log
@OQO model 01 internal wireless.  help from many, ok by dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.53 2005/02/28 05:59:00 dlg Exp $ */
d1667 5
a1689 3
	m_freem(c->atu_mbuf);
	c->atu_mbuf = NULL;

a1716 1
	struct ifnet		*ifp = &sc->sc_ic.ic_if;
d1725 2
a1726 1
	if (sc->sc_state != ATU_S_OK)
d1728 1
d1759 4
a1762 1
		atu_stop(ifp, 0);
d2216 1
a2216 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.53
log
@another fix from netbsd pointed out by jsg@@

Clear IFF_RUNNING flag before aborting usb pipes in atu_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.52 2005/02/24 23:10:48 dlg Exp $ */
d132 2
@


1.52
log
@fixes inspired by netbsd and pointed out by jsg@@

- make sure the interface is up before continuing in atu_start
- use IFQ_DEQUEUE instead of IF_DEQUEUE
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.51 2005/02/17 18:28:05 reyk Exp $ */
d2228 1
a2267 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.51
log
@derived from NetBSD:

---
Make the node table into an LRU cache: least-recently used nodes
are at the end of the node queue.  Change the reference-counting
discipline: ni->ni_refcnt indicates how many times net80211 has
granted ni to the driver.  Every node in the table with ni_refcnt=0
is eligible to be garbage-collected.  The mere presence of a node
in the table does not any longer indicate its auth/assoc state;
nodes have a ni_state variable, now.

While I am here, patch ieee80211_find_node_for_beacon to do a "best
match" by bssid/ssid/channel, not a "perfect match."  This keeps
net80211 from caching duplicate nodes in the table.
---

ok deraadt@@ dlg@@, looks good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.50 2005/01/26 13:05:49 dlg Exp $ */
d1775 6
a1780 1
	s = splnet();
a1783 1
		splx(s);
d1825 1
a1825 1
			IF_DEQUEUE(&ifp->if_snd, m);
d2183 3
@


1.50
log
@add the Belkin F5D6050 802.11b Wireless Device. from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.49 2005/01/23 03:37:42 dlg Exp $ */
d1638 1
a1638 4
	if (ni == ic->ic_bss)
		ieee80211_unref_node(&ni);
	else
		ieee80211_free_node(ic, ni);
d1867 2
a1868 3
			if (ni != NULL && ni != ic->ic_bss)
				/* reclaim node */
				ieee80211_free_node(ic, ni);
@


1.49
log
@Add the Askey WLL013. found by jsg in a dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.48 2004/12/30 01:53:21 dlg Exp $ */
d114 2
@


1.48
log
@get rid of ieee80211 debug output
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.47 2004/12/23 13:19:38 dlg Exp $ */
d108 2
@


1.47
log
@turn padding of tx packets on since it appears it may be needed by certain
firmwares or revisions of the chip. also remove the option to turn it off.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.46 2004/12/20 12:11:57 deraadt Exp $ */
a1081 2
		ifp->if_flags |= IFF_DEBUG;

a1146 6
#ifdef IEEE80211_DEBUG
	/* XXX gotta clean this up later */
	extern int			ieee80211_debug;

	ieee80211_debug = 11;
#endif
@


1.46
log
@lots of minor tweaking and cleanup, removal of unused junk, etc; dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.45 2004/12/13 08:09:51 dlg Exp $ */
d195 1
a1703 1
#ifdef ATU_TX_PADDING
d1710 1
a1710 1
		return 50 - size;
d1712 2
a1713 2
		return 64 + 50 - size;
	return 0;
a1714 1
#endif /* ATU_TX_PADDING */
d1724 1
a1724 3
#ifdef ATU_TX_PADDING
	u_int8_t		padding;
#endif /* ATU_TX_PADDING */
d1744 5
a1748 1
	h->padding = 0;
a1749 8
	len += ATU_TX_HDRLEN;
#ifdef ATU_TX_PADDING
/*
	padding = atu_calculate_padding(len % 64);
	len += padding;
	pkt->AtHeader.padding = padding;
*/
#endif /* ATU_TX_PADDING */
@


1.45
log
@endian fixes, ie, atu will now work on big endian architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.44 2004/12/13 07:37:54 dlg Exp $ */
d96 1
a96 1
int atudebug = 14;
d133 11
a143 1
	{ 0, 0, 0, 0 }
a153 1
void	atu_msleep(struct atu_softc *, int);
d184 3
d188 1
a188 1
int	atu_set_wepkey(struct atu_softc *sc, int nr, u_int8_t *key, int len);
a195 16
void
atu_msleep(struct atu_softc *sc, int ms)
{
	u_int8_t	dummy;
	int		ticks;

	usbd_delay_ms(sc->atu_udev, ms);
	return;

	ticks = ms * hz / 1000;
	if (ticks == 0)
		ticks = 1;

	tsleep(&dummy, PZERO | PCATCH, "atus", ms * hz / 1000);
}

d283 1
a283 1
	int			err;
a284 1
	int			idle_count = 0;
d318 1
a318 1
		atu_msleep(sc, 25);
d360 1
d364 1
a364 1
		0x0000, size+8, (uByte *)&request);
d380 1
a380 1
		type << 8, index, size, buf);
d430 1
a430 1
		USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_bssid)));
d520 1
a520 1
			sizeof(CmdRadio));
d761 1
a761 1
	int block_size, block = 0, err;
d763 1
a763 1
	char	*name = NULL;
d785 3
a787 17
	switch (sc->atu_radio) {
	case RadioRFMD:
		name = "atu-rfmd-int";
		break;
	case RadioRFMD2958:
		name = "atu-rfmd2958-int";
		break;
	case RadioRFMD2958_SMC:
		name = "atu-rfmd2958smc-int";
		break;
	case RadioIntersil:
		name = "atu-intersil-int";
		break;
	default:
		name = "unknown-device";
		break;
	}
d825 1
a825 1
				USBDEVNAME(sc->atu_dev), block));
d843 1
a843 1
			atu_msleep(sc, 100);
d846 1
d877 1
a877 1
	atu_msleep(sc, 56+100);
d889 1
a889 1
	int	block_size, block = 0, err;
d891 1
a891 1
	char	*name = NULL;
d893 3
a895 17
	switch (sc->atu_radio) {
	case RadioRFMD:
		name = "atu-rfmd-ext";
		break;
	case RadioRFMD2958:
		name = "atu-rfmd2958-ext";
		break;
	case RadioRFMD2958_SMC:
		name = "atu-rfmd2958smc-ext";
		break;
	case RadioIntersil:
		name = "atu-intersil-ext";
		break;
	default:
		name = "unknown-device";
		break;
	}
d943 2
a944 3
	if (sc->atu_quirk & ATU_QUIRK_FW_DELAY) {
		atu_msleep(sc, 21 + 100);
	}
d998 1
a998 1
	struct atu_type		*t;
d1003 3
a1005 2
	t = atu_devs;
	while(t->atu_vid) {
a1009 1
		t++;
d1147 2
a1148 1
	struct atu_type			*t;
a1149 1
#ifdef IEEE80211_DEBUG
d1171 1
a1171 1
			USBDEVNAME(sc->atu_dev));
d1182 3
a1184 2
	t = atu_devs;
	while(t->atu_vid) {
a1189 1
		t++;
a1313 1
#if 0
a1316 1
#endif
d1631 1
a1631 1
		goto done1; /* XXX if we cant allocate, why restart it? */
a1633 1

d1636 1
a1636 1
		BPF_MTAP(ifp, m);
d1649 3
a1651 4
	usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_RX],
	    c, c->atu_buf, ATU_RX_BUFSZ,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, atu_rxeof);
a1774 1

d1909 1
a1909 1
	if (atu_tx_list_init(sc)) {
a1910 1
	}
d1913 1
a1913 1
	if (atu_rx_list_init(sc)) {
a1914 1
	}
d1942 2
a1943 3
		usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_RX],
		    c, c->atu_buf, ATU_RX_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY,
d1955 1
a1955 1
			USBDEVNAME(sc->atu_dev)));
d1977 1
a1977 1
	if (err) {
a1979 1
	}
d1985 1
d1993 2
a1994 2
	err = atu_get_mib(sc, MIB_MAC_MGMT__CURRENT_BSSID, tmp);
	if (err) return;
d1998 2
a1999 2
	err = atu_get_mib(sc, MIB_MAC_MGMT__BEACON_PERIOD, tmp);
	if (err) return;
d2003 2
a2004 2
	err = atu_get_mib(sc, MIB_MAC_WEP__PRIVACY_INVOKED, tmp);
	if (err) return;
d2008 2
a2009 2
	err = atu_get_mib(sc, MIB_MAC_WEP__ENCR_LEVEL, tmp);
	if (err) return;
d2013 2
a2014 2
	err = atu_get_mib(sc, MIB_MAC_WEP__ICV_ERROR_COUNT, tmp);
	if (err) return;
d2018 2
a2019 2
	err = atu_get_mib(sc, MIB_MAC_WEP__EXCLUDED_COUNT, tmp);
	if (err) return;
d2023 2
a2024 2
	err = atu_get_mib(sc, MIB_MAC_MGMT__POWER_MODE, tmp);
	if (err) return;
d2028 2
a2029 2
	err = atu_get_mib(sc, MIB_PHY__CHANNEL, tmp);
	if (err) return;
d2032 2
a2033 2
	err = atu_get_mib(sc, MIB_PHY__REG_DOMAIN, tmp);
	if (err) return;
d2037 2
a2038 2
	err = atu_get_mib(sc, MIB_LOCAL__SSID_SIZE, tmp);
	if (err) return;
d2042 2
a2043 2
	err = atu_get_mib(sc, MIB_LOCAL__BEACON_ENABLE, tmp);
	if (err) return;
d2047 2
a2048 2
	err = atu_get_mib(sc, MIB_LOCAL__AUTO_RATE_FALLBACK, tmp);
	if (err) return;
d2052 2
a2053 2
	err = atu_get_mib(sc, MIB_MAC_ADDR__ADDR, tmp);
	if (err) return;
d2057 2
a2058 2
	err = atu_get_mib(sc, MIB_MAC__DESIRED_SSID, tmp);
	if (err) return;
d2062 2
a2063 2
	err = atu_get_mib(sc, MIB_MAC_MGMT__CURRENT_ESSID, tmp);
	if (err) return;
a2065 1

d2067 1
a2067 1

d2090 3
a2092 4
	struct atu_softc		*sc = ifp->if_softc;
	struct ifaddr			*ifa;
	int				err = 0;
	int				s;
a2094 1

a2099 1

a2136 1
#if 0
a2140 1
#endif
a2146 1

d2155 1
a2155 1
   
a2179 1

a2229 1
	usbd_status		err;
d2232 1
@


1.44
log
@set the buffer up before we try to use it. fixes a panic on sparc64 which
didn't manifest on i386 for some reason.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.43 2004/12/12 08:45:36 dlg Exp $ */
d157 1
d159 1
d332 1
a332 1
	struct atu_cmd_set_mib	request;
d339 2
d342 1
a342 2
	request.AtReserved = 0;
	request.AtSize = size + 4;
d368 1
a368 1
		0x0000, request.AtSize+4, (u_int8_t *)&request);
d370 1
a370 1
		return err;
d387 1
d437 1
d442 1
a442 1
	struct atu_cmd_do_scan	Scan;
d446 2
d450 1
a450 1
	Scan.Size = sizeof(Scan) - 4;
a465 3
	Scan.ProbeDelay = 3550;
	Scan.MinChannelTime = 250;
	Scan.MaxChannelTime = 3550;
d469 1
a469 1
	Scan.ProbeDelay = 0;
d471 2
a472 2
	Scan.MinChannelTime = 100;
	Scan.MaxChannelTime = 200;
d506 1
a506 1
	struct atu_cmd	CmdRadio = {CMD_RADIO_ON, 0, 0};
d516 3
d570 1
a570 1
	cmd.Size = sizeof(cmd) - 4;
d581 2
a582 2
	cmd.RTS_Threshold = 2347;
	cmd.FragThreshold = 2346;
d607 1
a607 1
	cmd.BeaconPeriod = 100;
d686 2
d690 1
a690 1
	join.Size = sizeof(join) - 4;
d706 1
a706 1
	join.timeout = ATU_JOIN_TIMEOUT;
d1649 1
a1649 1
	len = h->length - 4; /* XXX magic number */
d1674 1
a1674 1
	ieee80211_input(ifp, m, ni, h->rssi, h->rx_time);
d1781 1
a1781 1
	h->length = len;
@


1.43
log
@wait till we have root mounted before trying to upload firmwares
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.42 2004/12/12 05:30:48 dlg Exp $ */
a1641 3
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

d1646 3
@


1.42
log
@do a better reattachement of this device
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.41 2004/12/08 21:04:44 dlg Exp $ */
d96 1
a96 1
int atudebug = 40;
d164 2
a165 2
int	atu_upload_internal_firmware(struct atu_softc *sc);
int	atu_upload_external_firmware(struct atu_softc *sc);
d180 1
d751 2
a752 2
int
atu_upload_internal_firmware(struct atu_softc *sc)
d754 1
d804 1
a804 1
		return (err);
d820 1
a820 1
				return err;
d842 1
a842 1
				return err;
d870 1
a870 1
		return err;
d877 1
a877 1
		return err;
d887 3
a889 3
	DPRINTFN(10, ("%s: internal firmware upload done\n",
	    USBDEVNAME(sc->atu_dev)));
	return 0;
d892 2
a893 2
int
atu_upload_external_firmware(struct atu_softc *sc)
d895 2
a896 1
	u_char	*ptr = NULL, *firm = NULL, mode, channel;
a900 33
	err = atu_get_opmode(sc, &mode);
	if (err) {
		DPRINTF(("%s: could not get opmode\n",
		    USBDEVNAME(sc->atu_dev)));
		return err;
	}
	DPRINTFN(20, ("%s: opmode: %d\n", USBDEVNAME(sc->atu_dev), mode));

	if (mode == MODE_NETCARD) {
		DPRINTFN(15, ("%s: device doesn't need external "
		    "firmware\n", USBDEVNAME(sc->atu_dev)));
		return 0;
	}
	if (mode != MODE_NOFLASHNETCARD) {
		DPRINTF(("%s: EEK! unexpected opmode=%d\n",
		    USBDEVNAME(sc->atu_dev), mode));
	}

	/*
	 * There is no difference in opmode before and after external firmware
	 * upload with the SMC2662 V.4 . So instead we'll try to read the
	 * channel number. If we succeed, external firmware must have been
	 * already uploaded...
	 */
	if (sc->atu_radio != RadioIntersil) {
		err = atu_get_mib(sc, MIB_PHY__CHANNEL, &channel);
		if (! err) {
			DPRINTF(("%s: external firmware has already been "
			    "downloaded\n", USBDEVNAME(sc->atu_dev)));
			return (0);
		}
	}

d925 1
a925 1
		return (err);
d943 1
a943 1
			return err;
d957 1
a957 1
		return err;
d971 2
a972 1
	return 0;
a1165 2
	struct ieee80211com		*ic = &sc->sc_ic;
	struct ifnet			*ifp = &ic->ic_if;
d1169 1
a1169 4
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int				i;
	u_int8_t			mode;
a1170 1
	struct atu_fw			fw;
d1191 1
a1191 2
	err = usbd_device2interface_handle(dev, ATU_IFACE_IDX,
	    &sc->atu_iface);
a1200 2
	id = usbd_get_interface_descriptor(sc->atu_iface);

d1226 2
a1227 2
	if (err || (mode != MODE_NETCARD &&
	    mode != MODE_NOFLASHNETCARD)) {
d1231 1
a1231 4
		/* upload internal firmware */
		err = atu_upload_internal_firmware(sc);
		if (err)
			USB_ATTACH_ERROR_RETURN;
d1233 9
a1241 3
		printf("\n%s: reattaching after firmware upload\n",
		    USBDEVNAME(sc->atu_dev));
		usb_needs_reattach(dev);
d1247 57
a1303 6
	/* upload external firmware */
	DPRINTF(("%s: starting external firmware download\n",
	    USBDEVNAME(sc->atu_dev)));
	err = atu_upload_external_firmware(sc);
	if (err)
		USB_ATTACH_ERROR_RETURN;
d1307 1
a1307 1
		ed = usbd_interface2endpoint_descriptor(uaa->iface, i);
d1310 1
a1310 1
			    uaa->iface->idesc->bNumEndpoints));
d1313 1
a1313 1
			USB_ATTACH_ERROR_RETURN;
d1327 3
a1329 3
		DPRINTF(("%s: could not get card cfg!\n",
		    USBDEVNAME(sc->atu_dev)));
		USB_ATTACH_ERROR_RETURN;
d1332 1
d1346 1
a1408 2

	USB_ATTACH_SUCCESS_RETURN;
@


1.41
log
@remove the variables that used to make up the signal cache. nothing in atu
is using this now.

from daan vreeken
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.40 2004/12/06 11:33:30 dlg Exp $ */
a196 15
static usbd_status
atu_reset(struct atu_softc *sc)
{
	/* We don't need to actually send the device a reset... */
#if 0
	usb_port_status_t	stat;

	usbd_reset_port(sc->atu_udev->myhub,
	    sc->atu_udev->powersrc->portno, &stat);
#endif

	sc->atu_udev->address = USB_START_ADDR;
	return(0);
}

a884 9
	/* reset the device to get the firmware to boot */
	DPRINTFN(10, ("%s: trying to reset device...\n",
	    USBDEVNAME(sc->atu_dev)));
	err = atu_reset(sc);
	if (err) {
		DPRINTF(("%s: reset failed...\n", USBDEVNAME(sc->atu_dev)));
		return err;
	}

d1110 1
a1110 1
	if (sc->atu_dying)
d1213 2
d1217 1
a1217 1
	printf("%s: %s\n", USBDEVNAME(sc->atu_dev), devinfo);
d1274 4
a1277 2
		DPRINTFN(10, ("%s: done...\n", USBDEVNAME(sc->atu_dev)));
		USB_ATTACH_NEED_RESET;
d1331 1
a1331 2
	printf("%s: address %s\n", USBDEVNAME(sc->atu_dev),
	    ether_sprintf(ic->ic_myaddr));
d1390 1
a1390 1
	sc->atu_dying = 0;
d1400 2
a1401 1
	atu_stop(ifp, 1);
d1403 2
a1404 2
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
d1406 10
a1415 4
	if (sc->atu_ep[ATU_ENDPT_TX] != NULL)
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_TX]);
	if (sc->atu_ep[ATU_ENDPT_RX] != NULL)
		usbd_abort_pipe(sc->atu_ep[ATU_ENDPT_RX]);
a1416 1
	usb_rem_task(sc->atu_udev, &sc->sc_task);
d1430 4
a1433 2
		if_deactivate(&sc->atu_ec.ec_if);
		sc->atu_dying = 1;
d1574 1
a1574 1
	if (sc->atu_dying)
d1743 1
a1743 1
	if (sc->atu_dying)
d2218 1
a2218 1
	if (sc->atu_dying)
@


1.40
log
@tell net80211 that we can get probes/beacons on any channel during a scan.
this lets us get rid of an ugly hack that was needed to work around the
default net80211 behaviour of dropping these packets when not on the
current channel.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.39 2004/12/06 09:05:51 dlg Exp $ */
a1353 4
	for (i=0; i<ATU_AVG_TIME; i++)
		sc->atu_signalarr[i] = 0;
	sc->atu_signaltotal = 0;
	sc->atu_signalptr = 0;
@


1.39
log
@dont try and detect if the external firmware is already loaded by changing
the channel on atu devices with intersil radios. it seems to crash the
firmware.

from daan vreeken, tested by mitja muzenic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.38 2004/12/05 12:25:59 dlg Exp $ */
a179 2
/* XXX stolen from iwi */
void atu_fix_channel(struct ieee80211com *, struct mbuf *);
d1375 1
a1375 1
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_WEP;
a1570 38
/* XXX Horrible hack to fix channel number of beacons and probe responses */
void
atu_fix_channel(struct ieee80211com *ic, struct mbuf *m)
{
	struct ieee80211_frame *wh;
	u_int8_t subtype;
	u_int8_t *frm, *efrm;

	DPRINTFN(10, ("atu_fix_channel\n"));

	wh = mtod(m, struct ieee80211_frame *);

	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) != IEEE80211_FC0_TYPE_MGT)
		return;

	DPRINTFN(10, ("atu_fix_channel: beacon/resp\n"));

	subtype = wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK;

	if (subtype != IEEE80211_FC0_SUBTYPE_BEACON &&
	    subtype != IEEE80211_FC0_SUBTYPE_PROBE_RESP)
		return;

	frm = (u_int8_t *)(wh + 1);
	efrm = mtod(m, u_int8_t *) + m->m_len;

	frm += 12;	/* skip tstamp, bintval and capinfo */
	while (frm < efrm) {
		if (*frm == IEEE80211_ELEMID_DSPARMS)
#if IEEE80211_CHAN_MAX < 255
		if (frm[2] <= IEEE80211_CHAN_MAX)
#endif
			ic->ic_bss->ni_chan = &ic->ic_channels[frm[2]];

		frm += frm[1] + 2;
	}
}

a1649 9

	/*
	 * XXX stolen from iwi, needs fixing
	 * Management frames (beacons or probe responses) received during
	 * scanning have an invalid channel field. Thus these frames are
	 * rejected by the 802.11 layer which breaks AP detection.
	 */
	if (ic->ic_state == IEEE80211_S_SCAN)
		atu_fix_channel(ic, m);
@


1.38
log
@do a scan for networks when net80211 thinks we should rather than doing it
only when we bring the interface up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.37 2004/12/05 04:51:47 dlg Exp $ */
d948 7
a954 5
	err = atu_get_mib(sc, MIB_PHY__CHANNEL, &channel);
	if (! err) {
		DPRINTF(("%s: external firmware has already been "
		    "downloaded\n", USBDEVNAME(sc->atu_dev)));
		return 0;
@


1.37
log
@net80211 in the watchdog
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.36 2004/12/05 03:04:44 dlg Exp $ */
d176 1
d1123 50
d1183 25
a1207 7
	if ((ostate == IEEE80211_S_SCAN) && ((nstate == IEEE80211_S_AUTH) ||
	    (nstate == IEEE80211_S_RUN))) {

		/*
		 * The BSSID has changed. Join it first before net80211 starts
		 * sending packets...
		 */
a1208 2
		atu_join(sc, ic->ic_bss);
	}
d1386 1
a1386 1
		    IEEE80211_F_ASCAN;
d1413 2
d1434 2
a2060 34

	err = atu_start_scan(sc);
	if (err) {
		DPRINTFN(1, ("%s: atu_init: couldn't start scan!\n",
		    USBDEVNAME(sc->atu_dev)));
		return(EIO);
	}

	/* Start a timer to check when the scan is done */
	/* timeout_add(&sc->atu_scan_timer, (1000 * hz) / 1000); */
	/*
	 * Hmmm... sleeping in a timeout handler crashes the system :)
	 * let's just wait here for the scan to finish
	 */

	err = atu_wait_completion(sc, CMD_START_SCAN, NULL);
	if (err) {
		DPRINTF(("%s: atu_init: error waiting for scan\n",
		    USBDEVNAME(sc->atu_dev)));
		return(err);
	}

	DPRINTF(("%s: ==========================> END OF SCAN!\n",
	    USBDEVNAME(sc->atu_dev)));

	ifp->if_flags |= IFF_DEBUG;

	s = splnet();
	/* ieee80211_next_scan(ifp); */
	ieee80211_end_scan(ifp);
	splx(s);

	DPRINTF(("%s: ----------------------======> END OF SCAN2!\n",
	    USBDEVNAME(sc->atu_dev)));
@


1.36
log
@clean up init of the tx xfers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.35 2004/12/05 02:04:36 dlg Exp $ */
d2236 1
a2236 1
	struct atu_softc	*sc;
d2241 7
d2269 2
@


1.35
log
@unbreak builds without ATU_DEBUG set.

thanks to jsg@@ for pointing that out
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.34 2004/12/05 01:51:20 dlg Exp $ */
d169 1
a169 2
int	atu_xfer_list_init(struct atu_softc *sc, struct atu_chain *ch,
	    int listlen, int need_mbuf, int bufsize, struct atu_list_head *list);
a1303 3
	/* Initialise transfer lists */
	SLIST_INIT(&sc->atu_cdata.atu_tx_free);

a1431 3
		if (c->atu_xfer != NULL) {
			printf("UGH RX\n");
		}
a1443 1

d1448 1
a1448 2
atu_xfer_list_init(struct atu_softc *sc, struct atu_chain *ch,
    int listlen, int need_mbuf, int bufsize, struct atu_list_head *list)
d1450 2
a1451 1
	struct atu_cdata	*cd;
d1454 2
a1455 1
	cd = &sc->atu_cdata;
d1457 2
a1458 2
	DPRINTFN(15, ("%s: list init (%d entries of %d bytes)\n",
	    USBDEVNAME(sc->atu_dev), listlen, bufsize));
d1460 7
a1466 6
	for (i = 0; i < listlen; i++) {
		ch->atu_sc = sc;
		ch->atu_idx = i;
		if (ch->atu_xfer == NULL) {
			ch->atu_xfer = usbd_alloc_xfer(sc->atu_udev);
			if (ch->atu_xfer == NULL)
d1468 6
a1474 20

		if (need_mbuf) {
			if (atu_newbuf(sc, ch, NULL) == ENOBUFS)
				return(ENOBUFS);
		} else {
			ch->atu_mbuf = NULL;
		}

		if ((bufsize > 0) && (ch->atu_buf == NULL)) {
			ch->atu_buf = usbd_alloc_buffer(ch->atu_xfer,
			    bufsize);
			if (ch->atu_buf == NULL)
				return(ENOBUFS);
		}

		if (list != NULL) {
			SLIST_INSERT_HEAD(list, ch, atu_list);
		}

		ch++;
a1899 1
	struct atu_cdata	*cd = &sc->atu_cdata;
d1914 2
a1915 4
	if (atu_xfer_list_init(sc, cd->atu_tx_chain, ATU_TX_LIST_CNT, 0,
	    ATU_TX_BUFSZ, &cd->atu_tx_free)) {
		DPRINTF(("%s: tx list init failed\n",
		    USBDEVNAME(sc->atu_dev)));
@


1.34
log
@clean up some more of the old state machine
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.33 2004/12/05 01:38:35 dlg Exp $ */
d1093 1
d1095 1
d1114 1
d1116 1
@


1.33
log
@shrink atu_ioctl to only have the useful bits. inet6 seems a bit happier as a
side effect
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.32 2004/12/05 01:10:56 dlg Exp $ */
a1291 1
	sc->atu_mgmt_flags = 0;
a1302 1
	SLIST_INIT(&sc->atu_cdata.atu_mgmt_free);
a1941 7
	/* Init mgmt ring */
	if (atu_xfer_list_init(sc, cd->atu_mgmt_chain,
	    ATU_MGMT_LIST_CNT, 0, ATU_MGMT_BUFSZ, &cd->atu_mgmt_free)) {
		DPRINTF(("%s: rx list init failed\n",
		    USBDEVNAME(sc->atu_dev)));
	}

a1996 2
	sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;

a2276 8
	for (cnt = 0; cnt < ATU_MGMT_LIST_CNT; cnt++) {
		c = &sc->atu_cdata.atu_mgmt_chain[cnt];
		if (c->atu_in_xfer) {
			usbd_get_xfer_status(c->atu_xfer, NULL, NULL, NULL,
			    &stat);
			atu_txeof(c->atu_xfer, c, stat);
		}
	}
a2330 1
	atu_xfer_list_free(sc, cd->atu_mgmt_chain, ATU_MGMT_LIST_CNT);
@


1.32
log
@rely on net80211 for media status/changes. reset the device as needed

from daan vreeken
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.31 2004/12/05 00:16:14 dlg Exp $ */
d2164 1
a2164 7

	struct ifreq			*ifr = (struct ifreq *)data;
	struct ifaddr			*ifa = (struct ifaddr *)data;
	struct ieee80211req		*ireq;
	struct ieee80211_bssid		*bssid;
	struct ieee80211chanreq		*chanreq;
	struct ieee80211_power		*power;
d2166 1
a2166 6
#if 0
	u_int8_t			tmp[32] = "";
	int				len = 0;
#endif
	struct ieee80211_nwid		nwid;
	int				change, s;
a2168 5
	ireq = (struct ieee80211req *)data;
	change = ifp->if_flags ^ sc->atu_if_flags;

	DPRINTFN(15, ("%s: atu_ioctl: command=%lu\n", USBDEVNAME(sc->atu_dev),
	    command));
d2174 2
d2229 12
d2242 2
a2260 333

	switch (command) {
	case SIOCSIFADDR:
		DPRINTFN(15, ("%s: SIOCSIFADDR\n", USBDEVNAME(sc->atu_dev)));

		ifp->if_flags |= IFF_UP;
		atu_init(ifp);

		switch (ifa->ifa_addr->sa_family) {
#ifdef INET
		case AF_INET:
			arp_ifinit(&sc->sc_ic.ic_ac, ifa);
			break;
#endif /* INET */
		}
		break;

	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ATU_MAX_MTU)
			err = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

	case SIOCSIFFLAGS:
		DPRINTFN(15, ("%s: SIOCSIFFLAGS\n", USBDEVNAME(sc->atu_dev)));

		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->atu_if_flags & IFF_PROMISC)) {
/* enable promisc */
#if 0
				sc->atu_rxfilt |= ATU_RXFILT_PROMISC;
				atu_setword(sc, ATU_CMD_SET_PKT_FILTER,
				    sc->atu_rxfilt);
#endif
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->atu_if_flags & IFF_PROMISC) {
/* disable promisc */
#if 0
				sc->atu_rxfilt &= ~ATU_RXFILT_PROMISC;
				atu_setword(sc, ATU_CMD_SET_PKT_FILTER,
				    sc->atu_rxfilt);
#endif
			} else if (!(ifp->if_flags & IFF_RUNNING))
				atu_init(ifp);

#if 0
			DPRINTFN(15, ("%s: ioctl calling atu_init()\n",
			    USBDEVNAME(sc->atu_dev)));
			atu_init(ifp);
			err = atu_switch_radio(sc, 1);
#endif
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				atu_stop(ifp, 0);
			err = atu_switch_radio(sc, 0);
		}
		sc->atu_if_flags = ifp->if_flags;

		err = 0;
		break;

	case SIOCADDMULTI:
		DPRINTFN(15, ("%s: SIOCADDMULTI\n", USBDEVNAME(sc->atu_dev)));
		/* TODO: implement */
		err = 0;
		break;

	case SIOCDELMULTI:
		DPRINTFN(15, ("%s: SIOCDELMULTI\n", USBDEVNAME(sc->atu_dev)));
		/* TODO: implement */
		err = 0;
		break;

	case SIOCS80211NWID:
		DPRINTFN(15, ("%s: SIOCS80211NWID\n",
		    USBDEVNAME(sc->atu_dev)));
		err = copyin(ifr->ifr_data, &nwid, sizeof(nwid));
		if (err)
			break;
		if (nwid.i_len > IEEE80211_NWID_LEN) {
			err = EINVAL;
			break;
		}
		sc->atu_ssidlen = nwid.i_len;
		memcpy(sc->atu_ssid, nwid.i_nwid, nwid.i_len);
		sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
		break;

	case SIOCG80211NWID:
		DPRINTFN(15, ("%s: SIOGS80211NWID\n",
		    USBDEVNAME(sc->atu_dev)));
		nwid.i_len = sc->atu_ssidlen;
		memcpy(nwid.i_nwid, sc->atu_ssid, nwid.i_len);
		err = copyout(&nwid, ifr->ifr_data, sizeof(nwid));
#ifdef ATU_DEBUG
		if (atudebug > 20)
			atu_print_a_bunch_of_debug_things(sc);
#endif /* ATU_DEBUG */
		break;

	case SIOCG80211BSSID:
		DPRINTF(("%s: ioctl 80211 get BSSID\n",
		    USBDEVNAME(sc->atu_dev)));
		bssid = (struct ieee80211_bssid *)data;
		IEEE80211_ADDR_COPY(bssid->i_bssid, sc->atu_bssid);
		DPRINTF(("%s: returned %s\n", USBDEVNAME(sc->atu_dev),
		    ether_sprintf(sc->atu_bssid)));
		break;
	case SIOCS80211CHANNEL:
		chanreq = (struct ieee80211chanreq *)data;
		DPRINTF(("%s: ioctl 80211 set CHANNEL (%d)\n",
		    USBDEVNAME(sc->atu_dev), chanreq->i_channel));

		if (((chanreq->i_channel < 1) || (chanreq->i_channel > 14)) &&
		    (chanreq->i_channel != IEEE80211_CHAN_ANY)) {
			err = EINVAL;
			break;
		}
		/* restart scan / join / etc now */
		sc->atu_desired_channel = chanreq->i_channel;
		sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
		break;
	case SIOCG80211CHANNEL:
		DPRINTF(("%s: ioctl 80211 get CHANNEL\n",
		    USBDEVNAME(sc->atu_dev)));
		chanreq = (struct ieee80211chanreq *)data;
		if ((sc->atu_desired_channel == IEEE80211_CHAN_ANY) &&
		    (!(sc->atu_mgmt_flags & ATU_NETWORK_OK)))
			chanreq->i_channel = IEEE80211_CHAN_ANY;
		else
			chanreq->i_channel = sc->atu_channel;
		break;
	case SIOCG80211POWER:
		DPRINTF(("%s: ioctl 80211 get POWER\n",
		    USBDEVNAME(sc->atu_dev)));
		power = (struct ieee80211_power *)data;
		/* Dummmy, we don't do power saving at the moment */
		power->i_enabled = 0;
		power->i_maxsleep = 0;
		break;

#if 0
	case SIOCG80211:
		switch(ireq->i_type) {
		case IEEE80211_IOC_SSID:
			err = copyout(sc->atu_ssid, ireq->i_data,
			    sc->atu_ssidlen);
			ireq->i_len = sc->atu_ssidlen;
			break;

		case IEEE80211_IOC_NUMSSIDS:
			ireq->i_val = 1;
			break;

		case IEEE80211_IOC_CHANNEL:
			ireq->i_val = sc->atu_channel;

			/*
			 * every time the channel is requested, we errr...
			 * print a bunch of debug things :)
			 */
#ifdef ATU_DEBUG
			if (atudebug > 20)
				atu_print_a_bunch_of_debug_things(sc);
#endif /* ATU_DEBUG */
			break;

		case IEEE80211_IOC_AUTHMODE:
			/* TODO: change this when shared-key is implemented */
			ireq->i_val = IEEE80211_AUTH_OPEN;
			break;

		case IEEE80211_IOC_WEP:
			switch (sc->atu_encrypt) {
			case ATU_WEP_TX:
				ireq->i_val = IEEE80211_WEP_MIXED;
				break;
			case ATU_WEP_TXRX:
				ireq->i_val = IEEE80211_WEP_ON;
				break;
			default:
				ireq->i_val = IEEE80211_WEP_OFF;
			}
			break;

		case IEEE80211_IOC_NUMWEPKEYS:
			ireq->i_val = 4;
			break;

		case IEEE80211_IOC_WEPKEY:
			err = suser(curproc, 0);
			if (err)
				break;

			if((ireq->i_val < 0) || (ireq->i_val > 3)) {
				err = EINVAL;
				break;
			}

			if (sc->atu_encrypt == ATU_WEP_40BITS)
				len = 5;
			else
				len = 13;

			err = copyout(sc->atu_wepkeys[ireq->i_val],
			    ireq->i_data, len);
			break;

		case IEEE80211_IOC_WEPTXKEY:
			ireq->i_val = sc->atu_wepkey;
			break;

		default:
			DPRINTF(("%s: ioctl:  unknown 80211: %04x %d\n",
			    USBDEVNAME(sc->atu_dev), ireq->i_type,
			    ireq->i_type));
			err = EINVAL;
		}
		break;

	case SIOCS80211:
		err = suser(curproc, 0);
		if (err)
			break;

		switch(ireq->i_type) {
		case IEEE80211_IOC_SSID:
			if (ireq->i_len < 0 || ireq->i_len > 32) {
				err = EINVAL;
				break;
			}

			err = copyin(ireq->i_data, tmp, ireq->i_len);
			if (err)
				break;

			sc->atu_ssidlen = ireq->i_len;
			memcpy(sc->atu_ssid, tmp, ireq->i_len);

			sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
			break;

		case IEEE80211_IOC_CHANNEL:
			if (ireq->i_val < 1 || ireq->i_val > 14) {
				err = EINVAL;
				break;
			}

			sc->atu_channel = ireq->i_val;

			/* restart scan / join / etc now */
			sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
			break;

		case IEEE80211_IOC_WEP:
			switch (ireq->i_val) {
			case IEEE80211_WEP_OFF:
				sc->atu_encrypt = ATU_WEP_OFF;
				break;
			case IEEE80211_WEP_MIXED:
				sc->atu_encrypt = ATU_WEP_TX;
				break;
			case IEEE80211_WEP_ON:
				sc->atu_encrypt = ATU_WEP_TXRX;
				break;
			default:
				err = EINVAL;
			}
			if (err)
				break;

			/*
			 * to change the wep-bit in our beacon we HAVE to send
			 * CMD_STARTUP again
			 */
			err = atu_initial_config(sc);
			/*
			 * after that we have to send CMD_JOIN again to get
			 * the receiver running again. so we'll just
			 * restart the entire join/assoc/auth state-machine.
			 */
			sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
			break;

		case IEEE80211_IOC_WEPKEY:
			if ((ireq->i_val < 0) || (ireq->i_val > 3) ||
			    (ireq->i_len > 13)) {
				err = EINVAL;
				break;
			}
			err = copyin(ireq->i_data, tmp, ireq->i_len);
			if (err)
				break;
			err = atu_set_wepkey(sc, ireq->i_val, tmp,
			    ireq->i_len);
			break;

		case IEEE80211_IOC_WEPTXKEY:
			if ((ireq->i_val < 0) || (ireq->i_val > 3)) {
				err = EINVAL;
				break;
			}
			sc->atu_wepkey = ireq->i_val;
			err = atu_send_mib(sc, MIB_MAC_WEP__KEY_ID,
			    NR(sc->atu_wepkey));

			break;

		case IEEE80211_IOC_AUTHMODE:
			/* TODO: change when shared-key is implemented */
			if (ireq->i_val != IEEE80211_AUTH_OPEN)
				err = EINVAL;
			break;

		default:
			err = EINVAL;
		}
		break;
#endif

	default:
		DPRINTFN(15, ("%s: default\n", USBDEVNAME(sc->atu_dev)));
		err = ieee80211_ioctl(ifp, command, data);
		break;
	}

	sc->atu_if_flags = ifp->if_flags;
	splx(s);
	return(err);
@


1.31
log
@remove the dependance on code from wi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.30 2004/12/04 23:56:49 dlg Exp $ */
d1093 2
a1094 2
	struct atu_softc	*sc;
	struct ifmedia_entry	*ime;
d1096 1
a1096 2
	sc = ifp->if_softc;
	ime = sc->atu_media.ifm_cur;
d1098 6
a1103 11
	/* TODO: fully implement - see if_wi.c @@ 1189 */

	DPRINTFN(10, ("%s: subtype=%d %d\n", USBDEVNAME(sc->atu_dev),
	    IFM_SUBTYPE(ime->ifm_media), ime->ifm_media));

	if ((ime->ifm_media & IFM_IEEE80211_ADHOC) &&
	    (sc->atu_mode != AD_HOC_MODE)) {
		DPRINTFN(10, ("%s: mode changed to adhoc\n",
		    USBDEVNAME(sc->atu_dev)));
		sc->atu_mode = AD_HOC_MODE;
		sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
d1106 1
a1106 10
	if ((!(ime->ifm_media & IFM_IEEE80211_ADHOC)) &&
	    (sc->atu_mode != INFRASTRUCTURE_MODE)) {
		DPRINTFN(10, ("%s: mode changed to infra\n",
		    USBDEVNAME(sc->atu_dev)));
		sc->atu_mode = INFRASTRUCTURE_MODE;
		sc->atu_mgmt_flags |= ATU_CHANGED_SETTINGS;
	}

	DPRINTFN(10, ("%s: media_change...\n", USBDEVNAME(sc->atu_dev)));
	return 0;
d1112 1
a1112 1
	struct atu_softc	*sc;
d1114 1
a1114 1
	sc = ifp->if_softc;
d1116 1
a1116 14
	/* TODO: fully implement */

	req->ifm_status = IFM_AVALID;
	req->ifm_active = IFM_IEEE80211;

	if (sc->atu_mgmt_flags & ATU_NETWORK_OK)
		req->ifm_status |= IFM_ACTIVE;

	/* req->ifm_active |= ieee80211_rate2media(2*11, IEEE80211_T_DS); */

	if (sc->atu_mode == AD_HOC_MODE) {
		req->ifm_active |= IFM_IEEE80211_ADHOC;
	}
	DPRINTFN(10, ("%s: atu_media_status\n", USBDEVNAME(sc->atu_dev)));
d2248 10
a2259 1
	/* XXX need to check if we need a config change */
@


1.30
log
@remove code that is now unused because of the move to net80211 and the
rx/tx cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.29 2004/12/04 23:36:15 dlg Exp $ */
a83 2
#include <dev/ic/if_wi_ieee.h>

a2204 1
	struct wi_req			wreq;
a2602 32

	case SIOCGWAVELAN:
		DPRINTFN(15, ("%s: ioctl: get wavelan\n",
		    USBDEVNAME(sc->atu_dev)));
		/*
		err = ether_ioctl(ifp, &sc->arpcom, command, data);
		break;
		*/

		/* TODO: implement */

		err = copyin(ifr->ifr_data, &wreq, sizeof(wreq));
		if (err)
			break;

		DPRINTFN(15, ("%s: SIOCGWAVELAN\n", USBDEVNAME(sc->atu_dev)));
		if (wreq.wi_len > WI_MAX_DATALEN) {
			err = EINVAL;
			break;
		}

		DPRINTFN(15, ("%s: ioctl: wi_type=%04x %d\n",
		    USBDEVNAME(sc->atu_dev), wreq.wi_type, wreq.wi_type));
		err = 0;
		/* err = EINVAL; */
		break;

	case SIOCSWAVELAN:
		DPRINTFN(15, ("%s: ioctl: wavset type=%x\n",
		    USBDEVNAME(sc->atu_dev), 0));
		err = 0;
		break;
@


1.29
log
@clean up the tx path
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.28 2004/12/04 08:29:41 dlg Exp $ */
a138 1
int	atu_encap(struct atu_softc *sc, struct mbuf *m, struct atu_chain *c);
a141 1
void	atu_mgmt_loop(void *arg);
a163 5
int	atu_send_packet(struct atu_softc *sc, struct atu_chain *c);
int	atu_send_mgmt_packet(struct atu_softc *sc,
	    struct atu_chain *c, u_int16_t length);
int	atu_authenticate(struct atu_softc *sc);
int	atu_associate(struct atu_softc *sc);
a168 1
int	atu_mgmt_state_machine(struct atu_softc *sc);
a175 2
void	atu_print_beacon(struct atu_softc *sc, struct atu_rxpkt *pkt);
void	atu_handle_mgmt_packet(struct atu_softc *sc, struct atu_rxpkt *pkt);
a741 191
int
atu_send_packet(struct atu_softc *sc, struct atu_chain *c)
{
	usbd_status		err;
	struct atu_txpkt	*pkt;

	/* Don't try to send when we're shutting down the driver */
	if (sc->atu_dying)
		return(EIO);

	pkt = (struct atu_txpkt *)c->atu_buf;

	usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_TX],
	    c, c->atu_buf, c->atu_length, USBD_NO_COPY, ATU_TX_TIMEOUT,
	    atu_txeof);

	/* Let's get this thing into the air! */
	c->atu_in_xfer = 1;
	err = usbd_transfer(c->atu_xfer);
	if (err != USBD_IN_PROGRESS) {
		atu_stop(&sc->sc_ic.ic_if, 0);
		return(EIO);
	}

	DPRINTFN(10, ("%s: tx packet...\n", USBDEVNAME(sc->atu_dev)));
	return 0;
}

int
atu_send_mgmt_packet(struct atu_softc *sc, struct atu_chain *c,
    u_int16_t length)
{
	struct ieee80211com		*ic = &sc->sc_ic;
	struct atu_mgmt_packet		*packet;

	packet = (struct atu_mgmt_packet *)c->atu_buf;

	packet->athdr.wlength = length - sizeof(packet->athdr);
	packet->athdr.tx_rate = 4;
	packet->athdr.padding = 0;
	memset(packet->athdr.reserved, 0x00, 4);

	packet->mgmt_hdr.duration = 0x8000;
	memcpy(packet->mgmt_hdr.dst_addr, sc->atu_bssid, ETHER_ADDR_LEN);
	memcpy(packet->mgmt_hdr.src_addr, ic->ic_myaddr, IEEE80211_ADDR_LEN);
	memcpy(packet->mgmt_hdr.bssid, sc->atu_bssid, ETHER_ADDR_LEN);
	packet->mgmt_hdr.seq_ctl = 0;

	c->atu_length = length;
	return atu_send_packet(sc, c);
}

int
atu_authenticate(struct atu_softc *sc)
{
	usbd_status			err;
	struct atu_chain		*ch;
	struct atu_auth_packet	*packet;

	/*
	 * now we should authenticate :
	 *  7.2.3.10 - page 64 of 802.11b spec
	 *  8.1 - page 74 of 802.11b spec
	 *  see 7.3.1.9 - page 69 for status codes
	 *
	 * open systems :
	 *  send: seq_nr=1	auth req
	 *  recv: seq_nr=2	auth resp. (with status code)
	 *
	 * shared key systems :
	 *  send: seq_nr=1	auth req
	 *  recv: seq_nr=2	auth challenge (with status code & challenge
	 *                        text)
	 *  send: seq_nr=3	auth reponse (wep encr challenge text)
	 *  recv: seq_nr=4	auth result
	 *
	 * algorithm number :
	 *  0 = open
	 *  1 = shared
	 */

	ch = SLIST_FIRST(&sc->atu_cdata.atu_mgmt_free);
	if (ch == NULL) {
		DPRINTF(("%s: authenticate: no mgmt transfers available\n",
		    USBDEVNAME(sc->atu_dev)));
		return ENOMEM;
	}
	SLIST_REMOVE_HEAD(&sc->atu_cdata.atu_mgmt_free, atu_list);

	packet = (struct atu_auth_packet *)ch->atu_buf;

	packet->mgmt_hdr.frame_ctl = WI_FTYPE_MGMT |
	    IEEE80211_FC0_SUBTYPE_AUTH;

	packet->auth_hdr.wi_algo = 0;
	packet->auth_hdr.wi_seq = 1;
	packet->auth_hdr.wi_status = 0;

	DPRINTFN(15, ("%s: auth packet: %30D\n", USBDEVNAME(sc->atu_dev),
		((u_int8_t *)packet)+8, " "));

	err = atu_send_mgmt_packet(sc, ch, sizeof(*packet));
	if (err) {
		DPRINTF(("%s: could not send auth packet\n",
		    USBDEVNAME(sc->atu_dev)));
	}

	/*
	 * TODO: implement shared key auth
	 */
	/*
	packet->algoritm = 1;
	packet->sequence = 3;
	packet->status = 0;

	memcpy(packet->challenge, the_challenge_text, the_challenge_length);

	DPRINTFN(15, ("%s: auth packet: %30D\n", USBDEVNAME(sc->atu_dev),
		((u_int8_t *)packet)+8, " "));

	if (sc->atu_encrypt & ATU_WEP_TX) {
		packet->mgmt_hdr.frame_ctl |= WI_FCTL_WEP;
		DPRINTFN(20, ("%s: ==> WEP on please\n",
		    USBDEVNAME(sc->atu_dev)));
	}

	err = atu_send_mgmt_packet(sc, ch, sizeof(*packet) + challenge_len);
	if (err) {
		DPRINTF(("%s: could not send auth packet 2\n",
		    USBDEVNAME(sc->atu_dev)));
	}
	*/
	return 0;
}

int
atu_associate(struct atu_softc *sc)
{
	usbd_status			err;
	struct atu_chain		*ch;
	u_int8_t			*ptr;
	struct atu_assoc_packet	*packet;

	/*
	 * associate :
	 *  7.2.3.4 - page 62 of 802.11b spec
	 *
	 */

	ch = SLIST_FIRST(&sc->atu_cdata.atu_mgmt_free);
	if (ch == NULL) {
		DPRINTF(("%s: associate: no mgmt transfers left\n",
		    USBDEVNAME(sc->atu_dev)));
		return ENOMEM;
	}
	SLIST_REMOVE_HEAD(&sc->atu_cdata.atu_mgmt_free, atu_list);

	packet = (struct atu_assoc_packet *)ch->atu_buf;

	packet->mgmt_hdr.frame_ctl = WI_FTYPE_MGMT |
	    IEEE80211_FC0_SUBTYPE_ASSOC_REQ;

	packet->capability = 1 + 32;	/* ess & short preamble */
	packet->capability = 1;
	packet->listen_interval = 100;	/* beacon interval */

	ptr = packet->data;
	*ptr++ = WI_VAR_SSID;		/* SSID */
	*ptr++ = sc->atu_ssidlen;
	memcpy(ptr, sc->atu_ssid, sc->atu_ssidlen);
	ptr += sc->atu_ssidlen;

	*ptr++ = WI_VAR_SRATES;		/* supported rates */
	*ptr++ = 0x04;
	*ptr++ = 0x82;
	*ptr++ = 0x84;
	*ptr++ = 0x8b;
	*ptr++ = 0x96;

	DPRINTFN(15, ("%s: associate packet: %50D\n",
	    USBDEVNAME(sc->atu_dev), (u_int8_t *)packet, " "));

	err = atu_send_mgmt_packet(sc, ch, sizeof(*packet) + 2 +
	    sc->atu_ssidlen + 6);
	if (err) {
		DPRINTF(("%s: could not send associate packet\n",
		    USBDEVNAME(sc->atu_dev)));
	}
	return 0;
}

a1091 216
/*
 * this routine gets called from the mgmt thread at least once a second.
 * if we return 0 the thread will go to sleep, if we return 1 we will be
 * called again immediately (like 'continue' does in a while-loop)
 */
int
atu_mgmt_state_machine(struct atu_softc *sc)
{
	struct atu_mgmt	*vars = &sc->atu_mgmt_vars;
	usbd_status		err;
	u_int8_t		statusreq[6];
	int s;

	if (sc->atu_mgmt_flags & ATU_CHANGED_SETTINGS) {
		sc->atu_mgmt_flags &= ~ATU_CHANGED_SETTINGS;
		sc->atu_mgmt_flags &= ~ATU_FOUND_BSSID;
		sc->atu_mgmt_flags &= ~ATU_AUTH_OK;
		sc->atu_mgmt_flags &= ~ATU_RE_AUTH;
		sc->atu_mgmt_flags &= ~ATU_ASSOC_OK;
		sc->atu_mgmt_flags |= ATU_SEARCHING;
		vars->state = STATE_LISTENING;
		vars->retry = 0;
	}

	DPRINTFN(5, ("%s: [state=%s, retry=%d, chan=%d d-chan=%d enc=%d]\n",
	    USBDEVNAME(sc->atu_dev), atu_mgmt_statename[vars->state],
	    vars->retry, sc->atu_channel, sc->atu_desired_channel,
	    sc->atu_encrypt));

	/* Fall back to authentication if needed */
	/* TODO: should we only allow this when in infra-mode? */
	if ((sc->atu_mgmt_flags & ATU_RE_AUTH) &&
	    (vars->state >= STATE_AUTHENTICATING)) {
		vars->state = STATE_AUTHENTICATING;
		sc->atu_mgmt_flags &= ~(ATU_RE_AUTH | ATU_AUTH_OK |
		    ATU_ASSOC_OK);
		vars->retry = 0;
	}

	/* Fall back to association if needed */
	/* TODO: should we only allow this when in infra-mode? */
	if ((sc->atu_mgmt_flags & ATU_RE_ASSOC) &&
	    (vars->state >= STATE_ASSOCIATING)) {
		vars->state = STATE_ASSOCIATING;
		sc->atu_mgmt_flags &= ~(ATU_RE_ASSOC | ATU_AUTH_OK |
		    ATU_ASSOC_OK);
		vars->retry = 0;
	}

	switch (vars->state) {
	case STATE_NONE:
		/* awaiting orders */
		break;
	case STATE_LISTENING:
		/* do some nifty scanning here */

		if (sc->atu_mgmt_flags & ATU_FOUND_BSSID) {
			vars->state = STATE_JOINING;
			vars->retry = 0;
			return 1;
		}
		s = splusb();
		err = atu_get_cmd_status(sc, CMD_JOIN, statusreq);
		if (err) {
			DPRINTF(("%s: get_cmd_status failed in mgmt_loop\n",
			    USBDEVNAME(sc->atu_dev)));
			vars->state = STATE_GIVEN_UP;
			vars->retry = 0;
		}
		if (statusreq[5]==STATUS_IN_PROGRESS) {
			DPRINTFN(10, ("%s: scanning in progress...\n",
			    USBDEVNAME(sc->atu_dev)));
		} else {
			err = atu_start_scan(sc);
			if (vars->retry++ > ATU_SCAN_RETRIES &&
			    sc->atu_mode == AD_HOC_MODE) {
				DPRINTFN(10, ("%s: scanned long enough\n",
				    USBDEVNAME(sc->atu_dev)));
				sc->atu_mgmt_flags &= ~ATU_SEARCHING;
				vars->state = STATE_CREATING_IBSS;
				vars->retry = 0;
			}
			if (err) {
				DPRINTF(("%s: get_cmd_failed in mgmt_loop\n",
				    USBDEVNAME(sc->atu_dev)));
				vars->state = STATE_GIVEN_UP;
				vars->retry = 0;
			}
		}
		splx(s);
		break;
	case STATE_JOINING:
		DPRINTFN(10, ("%s: going to join\n",
		    USBDEVNAME(sc->atu_dev)));
		//err = atu_join(sc, );
		if (err) {
			if (vars->retry++ > ATU_JOIN_RETRIES) {
				if (sc->atu_mode == AD_HOC_MODE)
					vars->state = STATE_CREATING_IBSS;
				else
					vars->state = STATE_GIVEN_UP;
				vars->retry = 0;
			}
			DPRINTF(("%s: error joining\n",
			    USBDEVNAME(sc->atu_dev)));
		} else {
			if (sc->atu_mode == AD_HOC_MODE)
				vars->state = STATE_HAPPY_NETWORKING;
			else
				vars->state = STATE_AUTHENTICATING;
			vars->retry = 0;
		}
		break;
	case STATE_AUTHENTICATING:
		if (sc->atu_mgmt_flags & ATU_AUTH_OK) {
			vars->state = STATE_ASSOCIATING;
			vars->retry = 0;
			return 1;
		}

		DPRINTFN(10, ("%s: trying authentication\n",
		    USBDEVNAME(sc->atu_dev)));
		atu_authenticate(sc);
		if (vars->retry++ > ATU_AUTH_RETRIES) {
			vars->state = STATE_GIVEN_UP;
			DPRINTF(("%s: error authenticating...\n",
			    USBDEVNAME(sc->atu_dev)));
		}
		break;
	case STATE_ASSOCIATING:
		if (sc->atu_mgmt_flags & ATU_ASSOC_OK) {
			vars->state = STATE_HAPPY_NETWORKING;
			vars->retry = 0;
			return 1;
		}
		DPRINTFN(10, ("%s: trying to associate\n",
		    USBDEVNAME(sc->atu_dev)));
		atu_associate(sc);
		if (vars->retry++ > ATU_ASSOC_RETRIES) {
			vars->state = STATE_GIVEN_UP;
			DPRINTF(("%s: error associating...\n",
			    USBDEVNAME(sc->atu_dev)));
		}
		break;
	case STATE_CREATING_IBSS:
		DPRINTFN(10, ("%s: trying to create IBSS\n",
		    USBDEVNAME(sc->atu_dev)));
		err = atu_start_ibss(sc);
		if (err) {
			if (vars->retry++ > ATU_IBSS_RETRIES)
				vars->state = STATE_GIVEN_UP;
			DPRINTF(("%s: error creating IBSS...\n",
			    USBDEVNAME(sc->atu_dev)));
		} else {
			vars->state = STATE_HAPPY_NETWORKING;
			vars->retry = 0;
		}
		break;
	case STATE_HAPPY_NETWORKING:
		/* happy networking
		 *
		 * TODO:
		 * we should bounce back to previous states from here
		 * on beacon timeout.
		 */
		break;
	case STATE_GIVEN_UP:
		/*
		 * can only leave this state if someone changes the
		 * config
		 */
		break;
	}

	if (vars->state == STATE_HAPPY_NETWORKING)
		sc->atu_mgmt_flags |= ATU_NETWORK_OK;
	else
		sc->atu_mgmt_flags &= ~ATU_NETWORK_OK;
	return 0;
}

void
atu_mgmt_loop(void *arg)
{
	struct atu_softc	*sc = arg;
	int			again;
	int s;

	DPRINTFN(10, ("%s: mgmt task initialised\n",
	    USBDEVNAME(sc->atu_dev)));

	sc->atu_mgmt_vars.state = STATE_NONE;
	sc->atu_mgmt_vars.retry = 0;

	while (!sc->atu_dying) {
		s = splnet();
		again = atu_mgmt_state_machine(sc);
		while (again)
			again = atu_mgmt_state_machine(sc);
		splx(s);

		/*
		 * wait for something to happen (but not too long :)
		 * if someone changes the config or a mgmt packet is received
		 * we will be waken up
		 */
		tsleep(sc, PZERO | PCATCH, "atum", ATU_MGMT_INTERVAL);
	}

	DPRINTFN(10, ("%s: mgmt thread stops now...\n",
	    USBDEVNAME(sc->atu_dev)));
	sc->atu_dying++;
	sc->atu_mgmt_flags &= ~ATU_TASK_RUNNING;
	kthread_exit(0);
}

a1547 304
void
atu_print_beacon(struct atu_softc *sc, struct atu_rxpkt *pkt)
{
	u_int8_t		*ptr;
	struct tlv		*tlv;
	u_int8_t		*end;
	u_int8_t		tmp;
	u_int8_t		rate;

	/* Let's have a closer look at this beacon... */
	ptr = (u_int8_t *)pkt->WiHeader.addr4 + 12;
	end = ptr + pkt->AtHeader.wlength - 24 - 12 - 4;
	tlv = (struct tlv *)ptr;

	while ((ptr<end) && (ptr + 2 + tlv->length <= end)) {
		switch (tlv->type) {
		case WI_VAR_SSID: /* SSID */
			/* sanity check */
			if (tlv->length > 32)
				break;

			tmp = tlv->value[tlv->length];
			tlv->value[tlv->length] = 0;
			DPRINTF(("%s:  ssid=[%s]\n", USBDEVNAME(sc->atu_dev),
			    tlv->value));
			tlv->value[tlv->length] = tmp;
			break;
		case WI_VAR_SRATES: /* Supported rates */
			for (rate=0; rate<tlv->length; rate++) {
				tmp = tlv->value[rate] & (~0x80);
				DPRINTF(("%s:  rate: %d kbps (%02x)\n",
				    USBDEVNAME(sc->atu_dev), 500 * tmp,
				    tlv->value[rate]));
			}
			break;
		case WI_VAR_DS: /* DS (channel) */
			DPRINTF(("%s:  channel=%d\n",
			    USBDEVNAME(sc->atu_dev), *tlv->value));
			break;
		default :
			DPRINTF(("%s:  tlv: t=%02x l=%02x v[0]=%02x\n",
			    USBDEVNAME(sc->atu_dev), tlv->type, tlv->length,
			    tlv->value[0]));
		}

		ptr += 2 + tlv->length;
		tlv = (struct tlv *)ptr;
	}
}

void
atu_handle_mgmt_packet(struct atu_softc *sc, struct atu_rxpkt *pkt)
{
	u_int8_t		*ptr;
	struct tlv		*tlv;
	u_int8_t		*end;
	u_int8_t		tmp;
	int			match;
	int			match_channel = 1;
	struct wi_80211_beacon	*beacon;
	struct wi_mgmt_auth_hdr	*auth;
	struct wi_mgmt_deauth_hdr	*deauth;
	struct wi_mgmt_disas_hdr	*deassoc;
	struct wi_mgmt_asresp_hdr	*assoc;

	switch (pkt->WiHeader.frame_ctl & WI_FCTL_STYPE) {
	case WI_STYPE_MGMT_AUTH:
		DPRINTFN(15, ("%s: received auth response...\n",
		    USBDEVNAME(sc->atu_dev)));

		auth = (struct wi_mgmt_auth_hdr *)pkt->WiHeader.addr4;

		if (auth->wi_seq != 2) {
			DPRINTF(("%s: auth wrong seq.nr (%x)\n",
			    USBDEVNAME(sc->atu_dev), auth->wi_seq));
			break;
		}
		if (auth->wi_status != 0) {
			DPRINTF(("%s: auth status error (%x)\n",
			    USBDEVNAME(sc->atu_dev), auth->wi_status));
			break;
		}

		/* TODO: should check bssid & mac ! */

		sc->atu_mgmt_flags |= ATU_AUTH_OK;
		wakeup(sc);

		/*
		 * TODO: DAAN Daan daan - Add challenge text blah blah
		 * (for shared-key systems)
		 */
		/*
		memcpy(the_challenge_text, ((u_int8_t *)&pkt->WiHeader) + 30,
		    the_challenge_length);
		DPRINTFN(15, ("%s: challenge= %100D\n",
		    USBDEVNAME(sc->atu_dev), the_challende_text, " "));
		*/
		break;

	case WI_STYPE_MGMT_DEAUTH:
		DPRINTF(("%s: the AP has de-authenticated us\n",
		    USBDEVNAME(sc->atu_dev)));

		deauth = (struct wi_mgmt_deauth_hdr *)pkt->WiHeader.addr4;

		DPRINTF(("%s: de-authentication reason: %04x\n",
		    USBDEVNAME(sc->atu_dev), deauth->wi_reason));

		/* TODO: should check bssid & mac ! */

		/* wake up the state machine to get us re-authenticated */
		sc->atu_mgmt_flags |= ATU_RE_AUTH;
		wakeup(sc);
		break;

	case WI_STYPE_MGMT_ASRESP:
		DPRINTFN(15, ("%s: received assoc response...\n",
		    USBDEVNAME(sc->atu_dev)));

		assoc = (struct wi_mgmt_asresp_hdr *)pkt->WiHeader.addr4;

		if (assoc->wi_status == 0) {
			sc->atu_mgmt_flags |= ATU_ASSOC_OK;
			wakeup(sc);
		} else {
			DPRINTF(("%s: assoc status error (%x)\n",
			    USBDEVNAME(sc->atu_dev), assoc->wi_status));
			break;
		}

		/* TODO: should check bssid & mac ! */
		wakeup(sc);

		break;

	case WI_STYPE_MGMT_DISAS:
		DPRINTF(("%s: the AP has de-associated us",
		    USBDEVNAME(sc->atu_dev)));

		deassoc = (struct wi_mgmt_disas_hdr *)pkt->WiHeader.addr4;

		DPRINTF(("%s: de-association reason: %04x\n",
		    USBDEVNAME(sc->atu_dev), deassoc->wi_reason));

		/* TODO: should check bssid & mac ! */

		/* wake up the state machine to get us re-authenticated */
		sc->atu_mgmt_flags |= ATU_RE_ASSOC;
		wakeup(sc);
		break;

	case WI_STYPE_MGMT_PROBERESP:
		DPRINTFN(20, ("%s: PROBE RESPONSE\n",
		    USBDEVNAME(sc->atu_dev)));
		/* FALLTHROUGH */
	case WI_STYPE_MGMT_BEACON:

		beacon = (struct wi_80211_beacon *)&pkt->WiHeader.addr4;

		/* Show beacon src MAC & signal strength */
		DPRINTFN(18, ("%s: mgmt bssid=%s", USBDEVNAME(sc->atu_dev),
		    ether_sprintf(pkt->WiHeader.addr3)));
		DPRINTFN(18, (" mac=%s signal=%d\n",
		   ether_sprintf(pkt->WiHeader.addr2), pkt->AtHeader.rssi));

#ifdef ATU_DEBUG
		if (atudebug > 20) {
			/*
			 * calculate average signal strength, can be very
			 *  usefull when precisely aiming antenna's
			 * NOTE: this is done on ALL beacons, so multiple
			 * stations can end up in the average. this only
			 * works well if we're only receiving one station.
			 */
			sc->atu_signaltotal += pkt->AtHeader.rssi;
			sc->atu_signaltotal -=
			    sc->atu_signalarr[sc->atu_signalptr];
			sc->atu_signalarr[sc->atu_signalptr] =
			    pkt->AtHeader.rssi;
			sc->atu_signalptr=(sc->atu_signalptr+1) %
			    ATU_AVG_TIME;
			DPRINTF(("%s: mgmt mac=%s signal=%02d ptr=%02d "
			    "avg=%02d.%02d\n", USBDEVNAME(sc->atu_dev),
			    ether_sprintf(pkt->WiHeader.addr2),
			    pkt->AtHeader.rssi, sc->atu_signalptr,
			    sc->atu_signaltotal / ATU_AVG_TIME,
			    (sc->atu_signaltotal * 100 / ATU_AVG_TIME) %
			    100));
		}
#endif

		DPRINTFN(18, ("%s: mgmt capabilities=%04x (mode=%s, wep=%s, "
		    "short-preamble=%s)\n", USBDEVNAME(sc->atu_dev),
		    beacon->flags,
		    (beacon->flags & IEEE80211_CAPINFO_ESS) ?
		    "infra" : "ad-hoc",
		    (beacon->flags & IEEE80211_CAPINFO_PRIVACY) ?
		    "on" : "off",
		    (beacon->flags & IEEE80211_CAPINFO_SHORT_PREAMBLE) ?
		    "yes" : "no"));

#ifdef ATU_DEBUG
		if (atudebug > 18)
			atu_print_beacon(sc, pkt);
#endif
		if (!(sc->atu_mgmt_flags & ATU_SEARCHING))
			break;

		/* Let's have a closer look at this beacon... */
		ptr = (u_int8_t *)pkt->WiHeader.addr4 + 12;
		end = ptr + pkt->AtHeader.wlength - 24 - 12 - 4;
		tlv = (struct tlv *)ptr;
		match = 0;
		while ((ptr<end) && (ptr + 2 + tlv->length <= end)) {
			switch (tlv->type) {
			case WI_VAR_SSID: /* SSID */
				/* sanity check */
				if (tlv->length > 32)
					break;

				tmp = tlv->value[tlv->length];
				tlv->value[tlv->length] = 0;
				sc->atu_ssid[sc->atu_ssidlen] = 0;
				if (!strcmp(tlv->value, sc->atu_ssid)) {
					match = 1;
				}
				tlv->value[tlv->length] = tmp;
				break;
			case WI_VAR_SRATES: /* Supported rates */
				/*
				 * TODO: should check if we support all
				 *  mandatory rates
				 */
				break;
			case WI_VAR_DS: /* DS (channel) */
				if (match)
					match_channel = *tlv->value;
				break;
			}

			ptr += 2 + tlv->length;
			tlv = (struct tlv *)ptr;
		}

		/* check mode... */
		beacon = (struct wi_80211_beacon *)&pkt->WiHeader.addr4;
		if (match) {
			if ((sc->atu_mode == AD_HOC_MODE) &&
			    (beacon->flags & IEEE80211_CAPINFO_ESS)) {
				match = 0;
				DPRINTF(("%s: SSID matches, but we're in "
				    "adhoc mode instead of infra\n",
				    USBDEVNAME(sc->atu_dev)));
			}
			if ((sc->atu_mode == INFRASTRUCTURE_MODE) &&
			    (!(beacon->flags & IEEE80211_CAPINFO_ESS))) {
				match = 0;
				DPRINTF(("%s: SSID matches, but we're in "
				    "infra mode instead of adhoc\n",
				    USBDEVNAME(sc->atu_dev)));
			}
			if ((sc->atu_desired_channel != IEEE80211_CHAN_ANY) &&
			    (match_channel != sc->atu_desired_channel)) {
				match = 0;
				DPRINTF(("%s: SSID matches, but the channel "
				    "doesn't (%d != %d)\n",
				    USBDEVNAME(sc->atu_dev), match_channel,
				    sc->atu_desired_channel));
			}

			if (!match) {
				break;
			}
		}

		if (match) {
			DPRINTF(("%s: ==> MATCH! (BSSID=%s, ch=%d)\n",
			    USBDEVNAME(sc->atu_dev),
			    ether_sprintf(pkt->WiHeader.addr3),
			    match_channel));

			/*
			 * TODO: should do some channel-checking here instead
			 * of just ignoring the channel the user sets
			 */

			memcpy(sc->atu_bssid, pkt->WiHeader.addr3,
			    ETHER_ADDR_LEN);
			sc->atu_channel = match_channel;

			sc->atu_mgmt_flags &= ~ATU_SEARCHING;
			sc->atu_mgmt_flags |= ATU_FOUND_BSSID;
		}

		break;

	default:
		DPRINTF(("%s: FIXME: unhandled mgmt type! (stype=%x)\n",
		    USBDEVNAME(sc->atu_dev),
		    pkt->WiHeader.frame_ctl & WI_FCTL_STYPE));
	}
}

a1767 34

int
atu_encap(struct atu_softc *sc, struct mbuf *m, struct atu_chain *c)
{
	int			total_len;
	struct atu_txpkt	*pkt;
#ifdef ATU_TX_PADDING
	u_int8_t		padding;
#endif /* ATU_TX_PADDING */

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving
	 * enough room for the atmel & 802.11 headers
	 */
	total_len = m->m_pkthdr.len;

	m_copydata(m, 0, m->m_pkthdr.len, c->atu_buf + sizeof(pkt->AtHeader));

	pkt = (struct atu_txpkt *)c->atu_buf;
	pkt->AtHeader.wlength = total_len;
	pkt->AtHeader.tx_rate = 4;			 /* rate = auto */
	pkt->AtHeader.padding = 0;
	memset(pkt->AtHeader.reserved, 0x00, sizeof(pkt->AtHeader.reserved));

	total_len += sizeof(pkt->AtHeader);
#ifdef ATU_TX_PADDING
	padding = atu_calculate_padding(total_len % 64);
	total_len += padding;
	pkt->AtHeader.padding = padding;
#endif /* ATU_TX_PADDING */
	c->atu_length = total_len;
	c->atu_mbuf = m;
	return(0);
}
@


1.28
log
@clean up the rx path
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.27 2004/12/04 08:02:02 dlg Exp $ */
d190 2
d2439 1
a2439 6
	int s;

	s = splusb();

	ifp->if_timer = 0;
	c->atu_in_xfer = 0;
d2441 2
a2442 20
	if (c->atu_mbuf != NULL) {
		/* put it back on the tx_list */
		sc->atu_cdata.atu_tx_inuse--;
		SLIST_INSERT_HEAD(&sc->atu_cdata.atu_tx_free, c,
		    atu_list);
	} else {
		/* put it back on the mgmt_list */
		SLIST_INSERT_HEAD(&sc->atu_cdata.atu_mgmt_free, c,
		    atu_list);
	}
	/*
	 * turn off active flag if we're done transmitting.
	 * we don't depend on the active flag anywhere. do we still need to
	 * set it then?
	 */
	if (sc->atu_cdata.atu_tx_inuse == 0) {
		ifp->if_flags &= ~IFF_OACTIVE;
	}
	DPRINTFN(25, ("%s: txeof me=%d  status=%d\n", USBDEVNAME(sc->atu_dev),
	    c->atu_idx, status));
d2445 1
a2445 2
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
a2446 1
		}
d2451 1
a2451 3
			usbd_clear_endpoint_stall(
			    sc->atu_ep[ATU_ENDPT_TX]);
		splx(s);
a2456 7
	if (c->atu_mbuf != NULL) {
		m_freem(c->atu_mbuf);
		c->atu_mbuf = NULL;
		if (ifp->if_snd.ifq_head != NULL)
			atu_start(ifp);
	}

d2461 10
d2472 2
d2524 59
d2588 1
d2590 4
a2593 5
	struct mbuf		*m_head = NULL;
	struct atu_cdata	*cd = &sc->atu_cdata;
	struct atu_chain	*entry;
	usbd_status		err;
	int s;
d2595 1
a2595 1
	DPRINTFN(10, ("%s: atu_start: enter\n", USBDEVNAME(sc->atu_dev)));
d2599 2
d2605 9
a2613 6
	entry = SLIST_FIRST(&sc->atu_cdata.atu_tx_free);
	while (entry) {
		if (entry == NULL) {
			/* all transfers are in use at this moment */
			splx(s);
			return;
d2615 3
a2617 4

		IF_DEQUEUE(&ic->ic_mgtq, m_head);
		if (m_head != NULL) {
			DPRINTFN(10, ("%s: atu_start: mgmt\n",
d2619 3
d2623 7
a2629 4
			ni = (struct ieee80211_node *)m_head->m_pkthdr.rcvif;
			m_head->m_pkthdr.rcvif = NULL;
		} else {
			DPRINTFN(10, ("%s: atu_start: data\n",
d2632 7
d2640 1
a2640 1
				return;
a2641 8
			IF_DEQUEUE(&ifp->if_snd, m_head);
			if (m_head == NULL) {
				/* no packets on queues */
				splx(s);
				return;
			}
			DPRINTFN(10, ("%s: atu_start: data\n",
			    USBDEVNAME(sc->atu_dev)));
d2643 8
a2650 3
			m_head = ieee80211_encap(ifp, m_head, &ni);
			if (m_head == NULL) {
				/* no packets on queues */
d2652 1
a2652 1
				return;
a2653 1
		}
d2655 1
a2655 1
		SLIST_REMOVE_HEAD(&sc->atu_cdata.atu_tx_free, atu_list);
d2657 7
a2663 2
		ifp->if_flags |= IFF_OACTIVE;
		cd->atu_tx_inuse++;
d2665 11
a2675 3
		DPRINTFN(25, ("%s: index:%d (inuse=%d)\n",
		    USBDEVNAME(sc->atu_dev), entry->atu_idx,
		    cd->atu_tx_inuse));
d2677 2
a2678 9
		err = atu_encap(sc, m_head, entry);
		if (err) {
			DPRINTF(("%s: error encapsulating packet!\n",
			    USBDEVNAME(sc->atu_dev)));
			IF_PREPEND(&ifp->if_snd, m_head);
			if (--cd->atu_tx_inuse == 0)
				ifp->if_flags &= ~IFF_OACTIVE;
			splx(s);
			return;
d2680 7
a2686 4
		err = atu_send_packet(sc, entry);
		if (err) {
			DPRINTF(("%s: error sending packet!\n",
			    USBDEVNAME(sc->atu_dev)));
d2688 5
a2692 1
			return;
a2693 12

		if ((ni != NULL) && (ni != ic->ic_bss))
			ieee80211_free_node(ic, ni);

#if NBPFILTER > 0
		if (ifp->if_bpf)
			BPF_MTAP(ifp, m_head);
#endif

		/*
		 * Set a timeout in case the chip goes out to lunch.
		 */
a2694 1
		entry = SLIST_FIRST(&sc->atu_cdata.atu_tx_free);
a2695 1
	splx(s);
@


1.27
log
@disable the state machine in atu in favour of the net80211 framework. lots of
cleanup to follow.

partly from daan vreeken, partly from me
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.26 2004/11/23 02:40:34 dlg Exp $ */
a2313 1
	struct ifnet		*ifp = &sc->sc_ic.ic_if;
d2315 4
d2320 1
a2320 1
	u_int32_t		total_len;
d2323 1
a2323 7
	struct atu_rxpkt	*pkt;
	int			offset;

	struct ieee80211_frame	*wh;
	struct ieee80211_node	*ni;

	DPRINTFN(25, ("%s: atu_rxeof: enter\n", USBDEVNAME(sc->atu_dev)));
d2328 1
a2328 1
	if (!(ifp->if_flags & IFF_RUNNING))
a2330 2
	DPRINTFN(25, ("%s: got a packet\n", USBDEVNAME(sc->atu_dev)));

d2366 1
a2366 1
	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);
d2368 1
a2368 1
	if (total_len <= 1) {
d2374 2
a2375 2
	m = c->atu_mbuf;
	memcpy(mtod(m, char *), c->atu_buf, total_len);
d2377 2
a2378 1
	pkt = mtod(m, struct atu_rxpkt *);
d2380 2
a2381 22
	DPRINTFN(25, ("%s: -- RX (rate=%d enc=%d) mac=%s",
	    USBDEVNAME(sc->atu_dev), pkt->AtHeader.rx_rate,
	    (pkt->WiHeader.frame_ctl & WI_FCTL_WEP) != 0,
	    ether_sprintf(pkt->WiHeader.addr3)));
	DPRINTFN(25, (" bssid=%s\n", ether_sprintf(pkt->WiHeader.addr2)));

	DPRINTFN(25, ("%s: rx frag:%02x rssi:%02x q:%02x nl:%02x time:%d\n",
	    USBDEVNAME(sc->atu_dev), pkt->AtHeader.fragmentation,
	    pkt->AtHeader.rssi, pkt->AtHeader.link_quality,
	    pkt->AtHeader.noise_level, pkt->AtHeader.rx_time));

	/* if (total_len > 1514) { */
	if (total_len > 1548) {
		DPRINTF(("%s: AAARRRGGGHHH!! Invalid packet size? (%d)\n",
		    USBDEVNAME(sc->atu_dev), total_len));
		ifp->if_ierrors++;
		goto done;
	}

	total_len = pkt->AtHeader.wlength - 4;

	ifp->if_ipackets++;
d2383 1
a2383 6

	/* Adjust mbuf for headers */
	offset = sizeof(pkt->AtHeader);
	m->m_pkthdr.len = m->m_len = total_len + offset;
	/* cut off Atmel header */
	m_adj(m, offset);
d2394 1
a2394 2
	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);
d2398 6
d2409 1
a2409 2
	ieee80211_input(ifp, m, ni, pkt->AtHeader.rssi,
	    pkt->AtHeader.rx_time);
a2414 6

	if (atu_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done1;
	}

@


1.26
log
@use ieee80211com to store the mac
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.25 2004/11/22 22:52:44 dlg Exp $ */
d98 1
a98 1
int atudebug = 11;
d145 2
a146 2
void	atu_init(void *);
void	atu_stop(struct atu_softc *);
d165 1
a165 1
int	atu_join(struct atu_softc *sc);
d189 4
d699 1
a699 1
atu_join(struct atu_softc *sc)
d713 1
a713 1
	memcpy(join.bssid, sc->atu_bssid, ETHER_ADDR_LEN);
d715 7
a721 4
	memcpy(join.essid, sc->atu_ssid, sc->atu_ssidlen);
	join.essid_size = sc->atu_ssidlen;
	join.bss_type = sc->atu_mode;
	join.channel = sc->atu_channel;
d770 1
a770 1
		atu_stop(sc);
d1385 1
a1385 1
		err = atu_join(sc);
a1526 1
		wakeup(sc);
a1534 1
		wakeup(sc);
d1564 23
d1603 1
a1603 1
	struct atu_type		*t;
d1605 6
d1755 1
a1755 1
	ic->ic_caps = IEEE80211_C_IBSS | IEEE80211_C_PMGT | IEEE80211_C_WEP;
d1765 2
a1766 1
		ic->ic_channels[i].ic_flags = IEEE80211_CHAN_B;
d1776 1
d1787 3
d1803 1
a1803 1
	atu_stop(sc);
d2267 38
d2315 1
a2320 1
	struct ether_header	*eth_hdr;
d2323 3
d2332 1
a2332 1
		return;
a2389 30
	if (pkt->WiHeader.frame_ctl & WI_FCTL_WEP) {
		DPRINTFN(25, ("%s: WEP enabled on RX\n",
		    USBDEVNAME(sc->atu_dev)));
	}

	/* Is it a managment packet? */
	if ((pkt->WiHeader.frame_ctl & WI_FCTL_FTYPE) == WI_FTYPE_MGMT) {
		atu_handle_mgmt_packet(sc, pkt);
		goto done;
	}

	/* Everything but data packets we just ignore from here */
	if ((pkt->WiHeader.frame_ctl & WI_FCTL_FTYPE) != WI_FTYPE_DATA) {
		DPRINTFN(25, ("%s: ---- not a data packet? ---\n",
		    USBDEVNAME(sc->atu_dev)));
		goto done;
	}

	/* Woohaa! It's an ethernet packet! */
	DPRINTFN(25, ("%s: received a packet! rx-rate: %d\n",
	    USBDEVNAME(sc->atu_dev), pkt->AtHeader.rx_rate));

	/* drop non-encrypted packets if wep-mode=on */
	if ((!(pkt->WiHeader.frame_ctl & WI_FCTL_WEP)) &&
	    (sc->atu_encrypt & ATU_WEP_RX)) {
		DPRINTFN(25, ("%s: dropping RX packet. (wep=off)\n",
		    USBDEVNAME(sc->atu_dev)));
		goto done;
	}

a2394 7
	/* Do some sanity checking... */
	if (total_len < sizeof(struct ether_header)) {
		DPRINTFN(25, ("%s: Packet too small?? (size:%d)\n",
		    USBDEVNAME(sc->atu_dev), total_len));
		ifp->if_ierrors++;
		goto done;
	}
d2403 1
a2403 36
	/*
	 * Copy src & dest mac to the right place (overwriting part of the
	 * 802.11 header)
	 */
	eth_hdr = (struct ether_header *)(pkt->Packet - 2 * ETHER_ADDR_LEN);

	switch (pkt->WiHeader.frame_ctl & (WI_FCTL_TODS | WI_FCTL_FROMDS)) {
	case 0:
		/* ad-hoc: copy order doesn't matter here */
		memcpy(eth_hdr->ether_shost, pkt->WiHeader.addr2,
		    ETHER_ADDR_LEN);
		memcpy(eth_hdr->ether_dhost, pkt->WiHeader.addr1,
		    ETHER_ADDR_LEN);
		break;

	case WI_FCTL_FROMDS:
		/* infra mode: MUST be done in this order! */
		memcpy(eth_hdr->ether_shost, pkt->WiHeader.addr3,
		    ETHER_ADDR_LEN);
		memcpy(eth_hdr->ether_dhost, pkt->WiHeader.addr1,
		    ETHER_ADDR_LEN);

		DPRINTFN(25, ("%s: infra decap (%d bytes)\n",
		    USBDEVNAME(sc->atu_dev), pkt->AtHeader.wlength));
		DPRINTFN(25, ("%s: RX: %50D\n", USBDEVNAME(sc->atu_dev),
		    (u_int8_t *)&pkt->WiHeader, " "));
		break;

	default:
		DPRINTFN(25, ("%s: we shouldn't receive this (f_cntl=%02x)\n",
		    USBDEVNAME(sc->atu_dev), pkt->WiHeader.frame_ctl));
	}

	/* calculate 802.3 packet length (= packet - 802.11 hdr - fcs) */
	total_len = pkt->AtHeader.wlength - sizeof(struct wi_80211_hdr) +
	    2 * ETHER_ADDR_LEN - 4;
d2409 1
a2409 2
	offset = sizeof(struct at76c503_rx_buffer) +
	    sizeof(struct wi_80211_hdr) - 12;
d2411 1
d2414 12
a2427 5
	if (atu_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done1;
	}

d2433 12
a2444 1
	IF_INPUT(ifp, m);
a2545 1
	struct ether_header	*eth_hdr;
d2556 1
a2556 5
	m_copydata(m, 0, m->m_pkthdr.len, c->atu_buf +
		sizeof(pkt->AtHeader) + sizeof(struct wi_80211_hdr) -
		2 * ETHER_ADDR_LEN);

	total_len += sizeof(struct wi_80211_hdr) - 2 * ETHER_ADDR_LEN;
d2562 1
a2562 43
	memset(pkt->AtHeader.reserved, 0x00, 4);

	pkt->WiHeader.dur_id = 0x0000;			/* ? */
	pkt->WiHeader.frame_ctl = WI_FTYPE_DATA;

	eth_hdr = (struct ether_header *)(pkt->Packet - 2 * ETHER_ADDR_LEN);

	switch(sc->atu_mode) {
	case AD_HOC_MODE:
		/* dest */
		memcpy(pkt->WiHeader.addr1, eth_hdr->ether_dhost,
		    ETHER_ADDR_LEN);
		/* src */
		memcpy(pkt->WiHeader.addr2, eth_hdr->ether_shost,
		    ETHER_ADDR_LEN);
		/* bssid */
		memcpy(pkt->WiHeader.addr3, sc->atu_bssid, ETHER_ADDR_LEN);
		DPRINTFN(25, ("%s: adhoc encap (bssid=%s)\n",
		    USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_bssid)));
		break;

	case INFRASTRUCTURE_MODE:
		pkt->WiHeader.frame_ctl|=WI_FCTL_TODS;
		/* bssid */
		memcpy(pkt->WiHeader.addr1, sc->atu_bssid, ETHER_ADDR_LEN);
		/* src */
		memcpy(pkt->WiHeader.addr2, eth_hdr->ether_shost,
		    ETHER_ADDR_LEN);
		/* dst */
		memcpy(pkt->WiHeader.addr3, eth_hdr->ether_dhost,
		    ETHER_ADDR_LEN);

		DPRINTFN(25, ("%s: infra encap (bssid=%s)\n",
		    USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_bssid)));
	}
	memset(pkt->WiHeader.addr4, 0x00, ETHER_ADDR_LEN);
	pkt->WiHeader.seq_ctl = 0;

	if (sc->atu_encrypt & ATU_WEP_TX) {
		pkt->WiHeader.frame_ctl |= WI_FCTL_WEP;
		DPRINTFN(25, ("%s: turning WEP on on packet\n",
		    USBDEVNAME(sc->atu_dev)));
	}
d2579 2
d2582 1
a2582 1
	struct atu_cdata	*cd;
d2587 2
a2594 6
	IFQ_POLL(&ifp->if_snd, m_head);
	if (m_head == NULL) {
		splx(s);
		return;
	}

d2603 4
a2606 5
		if (sc->atu_mgmt_vars.state != STATE_HAPPY_NETWORKING) {
			/* don't try to send if we're not associated */
			splx(s);
			return;
		}
d2608 17
a2624 1
		cd = &sc->atu_cdata;
d2626 6
a2631 5
		IF_DEQUEUE(&ifp->if_snd, m_head);
		if (m_head == NULL) {
			/* no packets on queue */
			splx(s);
			return;
d2661 3
d2678 2
a2679 2
void
atu_init(void *xsc)
d2681 1
a2681 1
	struct atu_softc	*sc = xsc;
a2682 1
	struct ifnet		*ifp = &ic->ic_if;
d2694 1
a2694 1
		return;
d2726 1
a2726 1
		return;
d2735 1
a2735 1
		return;
d2758 1
a2758 1
		return;
a2762 15
	/* Fire up managment task */
	DPRINTFN(10, ("%s: trying to start mgmt task...\n",
	    USBDEVNAME(sc->atu_dev)));
	if (!(sc->atu_mgmt_flags & ATU_TASK_RUNNING)) {
		sc->atu_dying = 0;
		err = kthread_create(atu_mgmt_loop, sc,
		    &sc->atu_mgmt_thread, USBDEVNAME(sc->atu_dev));
		if (err) {
			DPRINTF(("%s: failed to create kthread\n",
			    USBDEVNAME(sc->atu_dev)));
		}

		sc->atu_mgmt_flags |= ATU_TASK_RUNNING;
	}

a2771 1
	wakeup(sc);
d2776 45
d2957 68
a3024 1
		atu_init(sc);
d3065 1
a3065 1
				atu_init(sc);
d3070 1
a3070 1
			atu_init(sc);
d3075 1
a3075 1
				atu_stop(sc);
a3107 1
		wakeup(sc);
a3142 1
		wakeup(sc);
a3261 1
			wakeup(sc);
a3273 1
			wakeup(sc);
a3303 1
			wakeup(sc);
d3429 1
a3429 1
atu_stop(struct atu_softc *sc)
d3432 1
a3432 1
	struct ifnet		*ifp = &sc->sc_ic.ic_if;
a3437 16

	/* there must be a better way to clean up the mgmt task... */
	sc->atu_dying = 1;
	splx(s);

	if (sc->atu_mgmt_flags & ATU_TASK_RUNNING) {
		DPRINTFN(10, ("%s: waiting for mgmt task to die\n",
		    USBDEVNAME(sc->atu_dev)));
		wakeup(sc);
		while (sc->atu_dying == 1) {
			atu_msleep(sc, 100);
		}
	}
	s = splnet();
	DPRINTFN(10, ("%s: stopped managment thread\n",
	    USBDEVNAME(sc->atu_dev)));
@


1.25
log
@better fix for the internal fw loader that doesnt break 64bit archs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.24 2004/11/22 22:28:16 deraadt Exp $ */
d557 1
d565 1
a565 1
	err = atu_send_mib(sc, MIB_MAC_ADDR__ADDR, sc->atu_mac_addr);
d775 2
a776 1
	struct atu_mgmt_packet	*packet;
d787 1
a787 1
	memcpy(packet->mgmt_hdr.src_addr, sc->atu_mac_addr, ETHER_ADDR_LEN);
d1225 1
d1243 1
a1243 1
		memcpy(sc->atu_mac_addr, rfmd_conf.MACAddr, ETHER_ADDR_LEN);
d1255 2
a1256 2
		memcpy(sc->atu_mac_addr, intersil_conf.MACAddr,
		    ETHER_ADDR_LEN);
d1693 1
a1693 1
	    ether_sprintf(sc->atu_mac_addr));
a1721 1
	bcopy(sc->atu_mac_addr, &ic->ic_myaddr, IEEE80211_ADDR_LEN);
a2753 1
	//bcopy(&ic->ic_myaddr, sc->atu_mac_addr, ETHER_ADDR_LEN);
d2755 1
a2755 1
	    USBDEVNAME(sc->atu_dev), ether_sprintf(sc->atu_mac_addr)));
@


1.24
log
@use a size_t here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.23 2004/11/22 13:41:13 dlg Exp $ */
d1017 1
a1017 1
	while (bytes_left >= 0 && state > 0) {
d1055 1
a1055 1
				bytes_left = -1;
@


1.23
log
@use a signed type if we're comparing the var to -1. fixes loading of the
internal firmware.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.22 2004/11/22 08:14:01 deraadt Exp $ */
d963 2
a964 1
	int	bytes_left = 0, block_size, block = 0, err;
@


1.22
log
@cleaner handling of unknown radios
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.21 2004/11/21 04:55:36 dlg Exp $ */
d963 1
a963 2
	int	block_size, block = 0, err;
	size_t	bytes_left = 0;
@


1.21
log
@introduce the net80211 framework to atu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.20 2004/11/19 23:14:27 dlg Exp $ */
d1001 1
d1009 2
a1010 2
		printf("%s: loadfirmware error %d\n",
		    USBDEVNAME(sc->atu_dev), err);
d1161 1
a1161 1
		bytes_left = 0;
d1169 2
a1170 2
		printf("%s: loadfirmware error %d\n",
		    USBDEVNAME(sc->atu_dev), err);
@


1.20
log
@remove the atmel dwl120 since its product ids dont seem to exist, it looks
like a typo. since the atmel at76c503a appears to be the real device we just
remove the typo
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.19 2004/11/19 22:38:12 dlg Exp $ */
d1562 2
a1564 1
	struct ifnet			*ifp;
d1569 1
a1569 1
	int				i, s;
a1611 2
	s = splnet();

d1630 1
a1630 2
		if (err) {
			splx(s);
a1631 1
		}
a1633 1
		splx(s);
d1643 1
a1643 2
	if (err) {
		splx(s);
a1644 1
	}
a1653 1
			splx(s);
a1669 1
		splx(s);
a1690 3
	bcopy(sc->atu_mac_addr,
	    (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

d1713 22
a1734 1
	ifp = &sc->arpcom.ac_if;
d1736 1
a1736 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->atu_dev), IFNAMSIZ);
a1740 1
	ifp->if_baudrate = 10000000;
a1741 1

d1744 1
a1744 3
	/*
	 * Call MI attach routine.
	 */
d1746 1
a1746 3
	Ether_ifattach(ifp, sc->atu_mac_addr);

	sc->atu_dying = 0;
d1749 1
a1749 2
	ifmedia_init(&sc->atu_media, 0, atu_media_change,
	    atu_media_status);
d1751 1
a1751 34
#define ADD(s, o)       ifmedia_add(&sc->atu_media, \
	IFM_MAKEWORD(IFM_IEEE80211, (s), (o), 0), 0, NULL)

	ADD(IFM_AUTO, 0);
	ADD(IFM_AUTO, IFM_IEEE80211_ADHOC);

	/*
	 * TODO:
	 * add a list of supported rates here.
	 * (can't do that as long as we only support 'auto fallback'
	 *
	for (i = 0; i < nrate; i++) {
		r = ic->ic_sup_rates[i];
		mword = ieee80211_rate2media(r, IEEE80211_T_DS);
		if (mword == 0)
			continue;
		printf("%s%d%sMbps", (i != 0 ? " " : ""),
		    (r & IEEE80211_RATE_VAL) / 2, ((r & 0x1) != 0 ? ".5" : ""));
		ADD(mword, 0);
		if (ic->ic_flags & IEEE80211_F_HASHOSTAP)
			ADD(mword, IFM_IEEE80211_HOSTAP);
		if (ic->ic_flags & IEEE80211_F_HASIBSS)
			ADD(mword, IFM_IEEE80211_ADHOC);
		ADD(mword, IFM_IEEE80211_ADHOC | IFM_FLAG0);
	}
	printf("\n");
	*/

	ADD(11, 0);
	ADD(11, IFM_IEEE80211_ADHOC);

	ifmedia_set(&sc->atu_media, IFM_MAKEWORD(IFM_IEEE80211, IFM_AUTO, 0,
	    0));
#undef ADD
a1752 1
	splx(s);
d1759 1
a1759 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1763 1
a1763 1
	ether_ifdetach(ifp);
d2230 1
a2230 2
atu_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
d2234 1
a2234 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d2395 1
a2395 1
	m->m_pkthdr.rcvif = &sc->arpcom.ac_if;
d2435 3
a2437 3
	struct atu_softc	*sc;
	struct atu_chain	*c;
	struct ifnet		*ifp;
a2440 2
	c = priv;
	sc = c->atu_sc;
a2442 1
	ifp = &sc->arpcom.ac_if;
d2683 3
a2685 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
a2686 1
	struct atu_cdata	*cd = &sc->atu_cdata;
d2751 1
a2751 2
	bcopy((char *)&sc->arpcom.ac_enaddr, sc->atu_mac_addr,
	    ETHER_ADDR_LEN);
d2936 1
a2936 1
			arp_ifinit(&sc->arpcom, ifa);
a3253 5
	case SIOCSIFMEDIA:
	case SIOCGIFMEDIA:
		err = ifmedia_ioctl(ifp, ifr, &sc->atu_media, command);
		break;

d3287 2
a3288 3
		DPRINTFN(15, ("%s: ioctl: default\n",
		    USBDEVNAME(sc->atu_dev)));
		err = ether_ioctl(ifp, &sc->arpcom, command, data);
d3344 1
a3344 1
	struct ifnet		*ifp;
a3348 1
	ifp = &sc->arpcom.ac_if;
@


1.19
log
@cleanup includes

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.18 2004/11/17 14:13:47 deraadt Exp $ */
a132 3
	/* XXX is this one right? */
	{ USB_VENDOR_ATMEL,	USB_PRODUCT_ATMEL_DWL120,
	  RadioIntersil,	ATU_NO_QUIRK },
@


1.18
log
@use the filesystem based firmware loader; dlg ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.17 2004/11/17 01:44:29 deraadt Exp $ */
d48 2
d51 1
a51 2
#include <sys/systm.h>
#include <sys/lock.h>
a53 1
#include <sys/proc.h>
d55 4
d61 1
a61 3
#include <sys/sockio.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
d63 4
a66 4
#include <net/if.h>
#include <net/if_arp.h>
#include <net/if_dl.h>
#include <net/if_media.h>
d68 1
a68 5
#include <netinet/in.h>
#include <netinet/in_systm.h>
#include <netinet/in_var.h>
#include <netinet/ip.h>
#include <netinet/if_ether.h>
d70 1
a70 1
#include "bpfilter.h"
a71 1
#if NBPFILTER > 0
d75 3
a77 4
#include <sys/ucred.h>
#include <sys/kthread.h>
#include <sys/queue.h>
#include <machine/bus.h>
d79 3
a81 6
#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#if 0
#include <dev/usb/usb_ethersubr.h>
a83 2
#include <dev/usb/usbdevs.h>

d86 1
a86 2
#include <net80211/ieee80211.h>
#include <net80211/ieee80211_ioctl.h>
a87 1
#include <net80211/ieee80211_var.h>
@


1.17
log
@remove bogus printf
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.16 2004/11/16 08:57:29 dlg Exp $ */
a105 5
#include <dev/microcode/atmel/atuwi_rfmd_fw.h>
#include <dev/microcode/atmel/atuwi_rfmd2958_fw.h>
#include <dev/microcode/atmel/atuwi_rfmd2958-smc_fw.h>
#include <dev/microcode/atmel/atuwi_intersil_fw.h>

d976 4
a979 7
	int8_t			state;
	int			bytes_left = 0;
	u_int8_t		*ptr = NULL;
	int			block_size;
	int			block = 0;
	u_int8_t		status[6];
	int			err;
d1003 1
a1003 4
		ptr = atuwi_fw_rfmd_int;
		bytes_left = sizeof(atuwi_fw_rfmd_int);
		DPRINTF(("%s: loading RFMD firmware...\n",
		    USBDEVNAME(sc->atu_dev)));
d1006 1
a1006 4
		ptr = atuwi_fw_rfmd2958_int;
		bytes_left = sizeof(atuwi_fw_rfmd2958_int);
		DPRINTF(("%s: loading RFMD2958 firmware...\n",
		    USBDEVNAME(sc->atu_dev)));
d1009 1
a1009 4
		ptr = atuwi_fw_rfmd2958_smc_int;
		bytes_left = sizeof(atuwi_fw_rfmd2958_smc_int);
		DPRINTF(("%s: loading RFMD2958-smc firmware...\n",
		    USBDEVNAME(sc->atu_dev)));
d1012 1
a1012 4
		ptr = atuwi_fw_intersil_int;
		bytes_left = sizeof(atuwi_fw_intersil_int);
		DPRINTF(("%s: loading Intersil firmware...\n",
		    USBDEVNAME(sc->atu_dev)));
a1014 3
		DPRINTF(("%s: unknown device type?\n",
		    USBDEVNAME(sc->atu_dev)));
		bytes_left = 0;
d1018 10
d1039 1
d1061 1
d1079 1
d1124 4
a1127 7
	u_int8_t		*ptr = NULL;
	int			bytes_left = 0;
	int			block_size;
	int			block = 0;
	u_int8_t		mode;
	u_int8_t		channel;
	int			err;
d1162 1
a1162 4
		ptr = atuwi_fw_rfmd_ext;
		bytes_left = sizeof(atuwi_fw_rfmd_ext);
		DPRINTF(("%s: loading external RFMD firmware\n",
		    USBDEVNAME(sc->atu_dev)));
d1165 1
a1165 4
		ptr = atuwi_fw_rfmd2958_ext;
		bytes_left = sizeof(atuwi_fw_rfmd2958_ext);
		DPRINTF(("%s: loading external RFMD2958 "
		    "firmware\n", USBDEVNAME(sc->atu_dev)));
d1168 1
a1168 4
		ptr = atuwi_fw_rfmd2958_smc_ext;
		bytes_left = sizeof(atuwi_fw_rfmd2958_smc_ext);
		DPRINTF(("%s: loading external RFMD2958-smc "
		    "firmware\n", USBDEVNAME(sc->atu_dev)));
d1171 1
a1171 4
		ptr = atuwi_fw_intersil_ext;
		bytes_left = sizeof(atuwi_fw_intersil_ext);
		DPRINTF(("%s: loading external Intersil "
		    "firmware\n", USBDEVNAME(sc->atu_dev)));
a1173 2
		DPRINTF(("%s: unknown device type?\n",
		    USBDEVNAME(sc->atu_dev)));
d1178 10
d1201 1
d1209 1
@


1.16
log
@get rid of the ATU_NO_COPY_TX knob. we always want it on.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.15 2004/11/15 12:50:08 dlg Exp $ */
a1666 1
		printf("trying reset now\n");
@


1.15
log
@remove some debug cruft
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.14 2004/11/15 09:59:17 dlg Exp $ */
a772 1
#ifdef ATU_NO_COPY_TX
a775 4
#else /* ATU_NO_COPY_TX */
	usbd_setup_xfer(c->atu_xfer, sc->atu_ep[ATU_ENDPT_TX],
	    c, c->atu_buf, c->atu_length, 0, ATU_TX_TIMEOUT, atu_txeof);
#endif /* ATU_NO_COPY_TX */
a1945 1
#ifdef ATU_NO_COPY_TX
a1949 6
#else /* ATU_NO_COPY_TX */
			ch->atu_buf = malloc(bufsize, M_USBDEV,
			    M_NOWAIT);
			if (ch->atu_buf == NULL)
				return(ENOBUFS);
#endif /* ATU_NO_COPY_TX */
d1969 1
a1969 8
		if (ch[i].atu_buf != NULL) {
#ifdef ATU_NO_COPY_TX
			/*
			 * usbdi.c cleans up for us
			 */
#else /* ATU_NO_COPY_TX */
			free(ch[i].atu_buf, M_USBDEV);
#endif /* ATU_NO_COPY_TX */
a1970 1
		}
@


1.14
log
@debug printf fixes from Daan Vreeken
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.13 2004/11/12 12:12:29 deraadt Exp $ */
d100 4
a109 4

#ifdef USB_DEBUG
#define ATU_DEBUG
#endif
@


1.13
log
@support SIOCG80211BSSID SIOCS80211CHANNEL SIOCG80211POWER; from daan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.12 2004/11/12 11:56:34 deraadt Exp $ */
d653 3
d1465 1
a1465 1
			DPRINTF(("atu:%d: error creating IBSS...\n",
d1477 1
a1477 3
		 * on beacon timeout, disassociate or deauthenticate
		 *
		 * (but none of that has been implemented at this time)
d2108 1
a2108 1
		DPRINTF(("autiw%d: de-authentication reason: %04x\n",
d2144 1
a2144 1
		DPRINTF(("autiw%d: de-association reason: %04x\n",
d2205 1
a2205 1
		if (atudebug & FLAG_BEACONSFULL)
@


1.12
log
@cleanup prototypes
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.11 2004/11/12 02:55:02 deraadt Exp $ */
d55 1
d368 1
a368 1
u_int8_t index, void *data)
d395 1
a395 1
		request.data[0]=(u_int32_t)data & 0x000000ff;
d398 2
a399 2
		request.data[0]=(u_int32_t)data & 0x000000ff;
		request.data[1]=(u_int32_t)data >> 8;
d439 4
a442 1
	Request.Channel = sc->atu_channel;
d496 4
a499 1
	Scan.Channel = sc->atu_channel;
d605 4
a608 1
	cmd.Channel = sc->atu_channel;
d1335 1
a1335 1
	DPRINTFN(5, ("%s: [state=%s, retry=%d, chan=%d enc=%d]\n",
d1337 2
a1338 1
	    vars->retry, sc->atu_channel, sc->atu_encrypt));
d1598 1
a1598 1
	usbd_device_handle	 	dev = uaa->device;
d1749 2
a1750 1
	sc->atu_channel = 10;
d2250 1
a2250 1
			    (beacon->flags & IEEE80211_CAPINFO_ESS))
d2252 4
d2257 8
a2264 1
			    (!(beacon->flags & IEEE80211_CAPINFO_ESS)))
d2266 5
a2272 7
				DPRINTF(("%s: SSID matches, "
				    "but we're in %s mode instead of %s\n",
				    USBDEVNAME(sc->atu_dev),
				    (sc->atu_mode == AD_HOC_MODE) ?
				    "adhoc" : "infra",
				    (sc->atu_mode == AD_HOC_MODE) ?
				    "infra" : "adhoc"));
d2986 1
a2986 1
	struct atu_softc	*sc = ifp->if_softc;
d2988 7
a2994 4
	struct ifreq		*ifr = (struct ifreq *)data;
	struct ifaddr		*ifa = (struct ifaddr *)data;
	struct ieee80211req	*ireq;
	int			err = 0;
d2996 2
a2997 2
	u_int8_t		tmp[32] = "";
	int			len = 0;
d2999 3
a3001 3
	struct ieee80211_nwid   nwid;
	struct wi_req		wreq;
	int			change, s;
a3024 1
		
d3112 42
@


1.11
log
@print address, this is not a debug piece
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.10 2004/11/11 22:48:24 deraadt Exp $ */
d156 11
a166 12
int atu_newbuf(struct atu_softc *, struct atu_chain *, struct mbuf *);
int atu_encap(struct atu_softc *sc, struct mbuf *m, struct atu_chain *c);
void atu_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void atu_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void atu_start(struct ifnet *);
// void atu_rxstart(struct ifnet *);
void atu_mgmt_loop(void *arg);
int atu_ioctl(struct ifnet *, u_long, caddr_t);
void atu_init(void *);
void atu_stop(struct atu_softc *);
void atu_watchdog(struct ifnet *);
void atu_msleep(struct atu_softc *, int);
d168 22
a189 24
	 u_int8_t request, u_int16_t value, u_int16_t index, u_int16_t length,
	 u_int8_t *data);
int atu_send_command(struct atu_softc *sc, u_int8_t *command,
	int size);
int atu_get_cmd_status(struct atu_softc *sc, u_int8_t cmd,
	 u_int8_t *status);
int atu_wait_completion(struct atu_softc *sc, u_int8_t cmd,
	u_int8_t *status);
int atu_send_mib(struct atu_softc *sc, u_int8_t type,
	u_int8_t size, u_int8_t index, void *data);
int atu_get_mib(struct atu_softc *sc, u_int8_t type,
	u_int8_t size, u_int8_t index, u_int8_t *buf);
int atu_start_ibss(struct atu_softc *sc);
int atu_start_scan(struct atu_softc *sc);
int atu_switch_radio(struct atu_softc *sc, int state);
int atu_initial_config(struct atu_softc *sc);
int atu_join(struct atu_softc *sc);
int
atu_send_packet(struct atu_softc *sc, struct atu_chain *c);
int atu_send_mgmt_packet(struct atu_softc *sc,
    struct atu_chain *c, u_int16_t length);
int atu_authenticate(struct atu_softc *sc);
int atu_associate(struct atu_softc *sc);
int8_t atu_get_dfu_state(struct atu_softc *sc);
d191 15
a205 16
int atu_upload_internal_firmware(struct atu_softc *sc);
int atu_upload_external_firmware(struct atu_softc *sc);
int atu_get_card_config(struct atu_softc *sc);
int atu_mgmt_state_machine(struct atu_softc *sc);
int atu_media_change(struct ifnet *ifp);
void atu_media_status(struct ifnet *ifp, struct ifmediareq *req);
int atu_xfer_list_init(struct atu_softc *sc, struct atu_chain *ch,
    int listlen, int need_mbuf, int bufsize, struct atu_list_head *list);
int atu_rx_list_init(struct atu_softc *);
void atu_xfer_list_free(struct atu_softc *sc, struct atu_chain *ch,
    int listlen);
void atu_print_beacon(struct atu_softc *sc, struct atu_rxpkt *pkt);
void atu_handle_mgmt_packet(struct atu_softc *sc, struct atu_rxpkt *pkt);
void atu_print_a_bunch_of_debug_things(struct atu_softc *sc);
int atu_set_wepkey(struct atu_softc *sc, int nr, u_int8_t *key, int len);

@


1.10
log
@use ether_ifdetach; from daan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.9 2004/11/11 22:47:56 deraadt Exp $ */
d1723 2
a1724 2
	DPRINTF(("%s: address %s\n", USBDEVNAME(sc->atu_dev),
		ether_sprintf(sc->atu_mac_addr)));
@


1.9
log
@simplify debug printf mechanism, with various levels of verbosity more
in tune with what one needs when debugging; from daan
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.8 2004/11/11 14:29:00 dlg Exp $ */
d1820 1
a1820 1
	ieee80211_ifdetach(ifp);
@


1.8
log
@add support for the Atmel AT76c503a (vendor/device ids, we should already
support this chip) and the Linksys WUSB11 v2.8 found by Sam Chill and
Barry Dexter A. Gonzaga respectively. they both seem keen to try this driver
out.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.7 2004/11/11 00:35:00 deraadt Exp $ */
d113 1
a113 1
int atudebug = 1;
d261 3
a263 3
			DPRINTFN(10, ("%s: req=%02x val=%02x "
			    "ind=%02x len=%02x\n", USBDEVNAME(sc->atu_dev),
			    request, value, index, length));
d265 3
a267 4
			DPRINTFN(10, ("%s: req=%02x val=%02x "
			    "ind=%02x len=%02x [%8D]\n",
			    USBDEVNAME(sc->atu_dev), request, value, index,
			    length, data, " "));
d285 3
a287 3
			DPRINTF(("%s: transfered 0x%x bytes"
			    " in\n", USBDEVNAME(sc->atu_dev), total_len));
			DPRINTF(("%s: dump [%10D]\n",
d291 2
a292 3
				DPRINTF(("%s: ARG! wrote "
				    "only %x bytes\n", USBDEVNAME(sc->atu_dev),
				    total_len));
d333 1
a333 1
	DPRINTF(("%s: wait-completion: cmd=%02x\n",
d343 1
a343 1
			DPRINTF(("%s: status=%s cmd=%02x\n",
d413 1
a413 1
	DPRINTF(("%s: sendmib : waitcompletion...\n",
d449 2
a450 1
		DPRINTF(("%s: start ibss failed!\n", USBDEVNAME(sc->atu_dev)));
d465 2
a466 1
		DPRINTF(("%s: could not get BSSID!\n", USBDEVNAME(sc->atu_dev)));
d512 1
a512 1
		DPRINTF(("%s: scan cmd len=%02x\n",
d514 2
a515 2
		DPRINTF(("%s: scan cmd: %52D\n",
		    USBDEVNAME(sc->atu_dev), (u_int8_t *)&Scan, " "));
d563 1
a563 1
		DPRINTF(("%s: radio turned %s\n",
d579 1
a579 1
	DPRINTF(("%s: sending mac-addr\n", USBDEVNAME(sc->atu_dev)));
d582 2
a583 1
		DPRINTF(("%s: error setting mac-addr\n", USBDEVNAME(sc->atu_dev)));
d591 2
a592 1
		DPRINTF(("%s: error setting mac-addr\n", USBDEVNAME(sc->atu_dev)));
d651 3
a653 3
		DPRINTF(("%s: configlen=%02x\n",
		    USBDEVNAME(sc->atu_dev), sizeof(cmd)));
		DPRINTF(("%s: configdata= %108D\n",
d698 2
a699 2
	DPRINTF(("%s: completed initial config\n",
	    USBDEVNAME(sc->atu_dev)));
d714 1
a714 1
	DPRINTF(("%s: pre-join sc->atu_bssid=%s\n",
d716 1
a716 1
	DPRINTF(("%s: mode=%d\n", USBDEVNAME(sc->atu_dev),
d728 1
a728 1
	DPRINTF(("%s: trying to join BSSID=%s\n",
d747 1
a747 1
		DPRINTF(("%s: joined BSS\n", USBDEVNAME(sc->atu_dev)));
d781 1
a781 1
	DPRINTF(("%s: tx packet...\n", USBDEVNAME(sc->atu_dev)));
d854 1
a854 1
	DPRINTF(("%s: auth packet: %30D\n", USBDEVNAME(sc->atu_dev),
d873 1
a873 1
	DPRINTF(("%s: auth packet: %30D\n", USBDEVNAME(sc->atu_dev),
d878 1
a878 1
		DPRINTF(("%s: ==> WEP on please\n",
d935 1
a935 1
	DPRINTF(("%s: associate packet: %50D\n",
d1031 2
a1032 1
		DPRINTF(("%s: unknown device type?\n", USBDEVNAME(sc->atu_dev)));
d1061 1
a1061 1
			DPRINTF(("%s: firmware block %d\n",
d1080 2
a1081 2
			DPRINTF(("%s: sleeping for a while\n",
				USBDEVNAME(sc->atu_dev)));
d1094 2
a1095 1
		DPRINTF(("%s: dfu_getstatus failed!\n", USBDEVNAME(sc->atu_dev)));
d1099 1
a1099 1
	DPRINTF(("%s: sending remap\n", USBDEVNAME(sc->atu_dev)));
d1114 1
a1114 1
	DPRINTF(("%s: trying to reset device...\n",
d1122 1
a1122 1
	DPRINTF(("%s: internal firmware upload done\n",
d1140 2
a1141 1
		DPRINTF(("%s: could not get opmode\n", USBDEVNAME(sc->atu_dev)));
d1144 1
a1144 1
	DPRINTF(("%s: opmode: %d\n", USBDEVNAME(sc->atu_dev), mode));
d1147 1
a1147 1
		DPRINTF(("%s: device doesn't need external "
d1152 2
a1153 2
		DPRINTF(("%s: EEK! unexpected opmode=%d\n", USBDEVNAME(sc->atu_dev),
		    mode));
d1195 2
a1196 1
		DPRINTF(("%s: unknown device type?\n", USBDEVNAME(sc->atu_dev)));
d1207 1
a1207 1
		DPRINTF(("%s: block:%d size:%d\n",
d1225 2
a1226 2
		DPRINTF(("%s: could not load last zero-length firmware block\n",
		    USBDEVNAME(sc->atu_dev)));
d1239 1
a1239 1
	DPRINTF(("%s: external firmware upload done\n",
d1329 2
a1330 2
	DPRINTF(("%s: [state=%s, retry=%d, chan=%d "
	    "enc=%d]\n", USBDEVNAME(sc->atu_dev), atu_mgmt_statename[vars->state],
d1374 1
a1374 1
			DPRINTF(("%s: scanning in progress...\n",
d1380 1
a1380 1
				DPRINTF(("%s: scanned long enough\n",
d1396 1
a1396 1
		DPRINTF(("%s: going to join\n",
d1424 1
a1424 1
		DPRINTF(("%s: trying authentication\n",
d1439 1
a1439 1
		DPRINTF(("%s: trying to associate\n",
d1449 1
a1449 1
		DPRINTF(("%s: trying to create IBSS\n",
d1494 2
a1495 1
	DPRINTF(("%s: mgmt task initialised\n", USBDEVNAME(sc->atu_dev)));
d1515 1
a1515 1
	DPRINTF(("%s: mgmt thread stops now...\n",
d1533 1
a1533 1
	DPRINTF(("%s: subtype=%d %d\n", USBDEVNAME(sc->atu_dev),
d1538 1
a1538 1
		DPRINTF(("%s: mode changed to adhoc\n",
d1547 1
a1547 1
		DPRINTF(("%s: mode changed to infra\n",
d1554 1
a1554 1
	DPRINTF(("%s: media_change...\n", USBDEVNAME(sc->atu_dev)));
d1578 1
a1578 1
	DPRINTF(("%s: atu_media_status\n", USBDEVNAME(sc->atu_dev)));
d1653 1
a1653 1
			USBDEVNAME(sc->atu_dev)));
d1662 1
a1662 2
		DPRINTF(("%s: done...\n",
		    USBDEVNAME(sc->atu_dev)));
d1702 2
a1703 1
		DPRINTF(("%s: could not get card cfg!\n", USBDEVNAME(sc->atu_dev)));
d1713 2
a1714 2
		DPRINTF(("%s: firmware: maj:%d min:%d patch:%d build:%d\n",
		    USBDEVNAME(sc->atu_dev), fw.major, fw.minor,
d1887 1
a1887 1
	DPRINTFN(10, ("%s: atu_rx_list_init: enter\n",
d1922 1
a1922 1
	DPRINTF(("%s: list init (%d entries of %d bytes)\n",
d2016 2
a2017 2
			DPRINTF(("%s:  ssid=[%s]\n",
			    USBDEVNAME(sc->atu_dev), tlv->value));
d2023 2
a2024 2
				DPRINTF(("%s:  rate: %d kbps "
				    "(%02x)\n", USBDEVNAME(sc->atu_dev), 500 * tmp,
d2033 3
a2035 3
			DPRINTF(("%s:  tlv: t=%02x l=%02x "
			    "v[0]=%02x\n", USBDEVNAME(sc->atu_dev), tlv->type,
			    tlv->length, tlv->value[0]));
d2060 1
a2060 1
		DPRINTF(("%s: received auth response...\n",
d2088 1
a2088 1
		DPRINTF(("%s: challenge= %100D\n",
d2094 2
a2095 2
		DPRINTF(("%s: the AP has de-authenticated "
		    "us\n", USBDEVNAME(sc->atu_dev)));
d2110 1
a2110 1
		DPRINTF(("%s: received assoc response...\n",
d2146 1
a2146 1
		DPRINTF(("%s: PROBE RESPONSE\n",
d2154 4
a2157 4
		DPRINTF(("%s: mgmt bssid=%s",
		    USBDEVNAME(sc->atu_dev), ether_sprintf(pkt->WiHeader.addr3)));
		DPRINTF((" mac=%s signal=%d\n",
		    ether_sprintf(pkt->WiHeader.addr2), pkt->AtHeader.rssi));
d2160 1
a2160 1
		if (atudebug & FLAG_SIGNAL) {
d2175 4
a2178 4
			DPRINTF(("%s: mgmt mac=%s signal=%02d"
			    " ptr=%02d avg=%02d.%02d\n", USBDEVNAME(sc->atu_dev),
			    ether_sprintf(pkt->WiHeader.addr2), pkt->AtHeader.rssi,
			    sc->atu_signalptr,
d2185 2
a2186 2
		DPRINTF(("%s: mgmt capabilities=%04x "
		    "(mode=%s, wep=%s, short-preamble=%s)\n", USBDEVNAME(sc->atu_dev),
d2263 2
a2264 1
			    ether_sprintf(pkt->WiHeader.addr3), match_channel));
d2282 2
a2283 2
		DPRINTF(("%s: FIXME: unhandled mgmt type! "
		    "(stype=%x)\n", USBDEVNAME(sc->atu_dev),
d2307 1
a2307 1
	DPRINTFN(10, ("%s: atu_rxeof: enter\n", USBDEVNAME(sc->atu_dev)));
d2315 1
a2315 1
	DPRINTF(("%s: got a packet\n", USBDEVNAME(sc->atu_dev)));
d2365 1
a2365 1
	DPRINTFN(10, ("%s: -- RX (rate=%d enc=%d) mac=%s",
d2369 1
a2369 1
	DPRINTFN(10, (" bssid=%s\n", ether_sprintf(pkt->WiHeader.addr2)));
d2372 1
a2372 1
		DPRINTF(("%s: WEP enabled on RX\n",
d2384 1
a2384 1
		DPRINTF(("%s: ---- not a data packet? ---\n",
d2390 1
a2390 1
	DPRINTF(("%s: received a packet! rx-rate: %d\n",
d2396 1
a2396 1
		DPRINTF(("%s: dropping RX packet. (wep=off)\n",
d2401 2
a2402 2
	DPRINTF(("%s: rx frag:%02x rssi:%02x q:%02x nl:%02x "
	    "time:%d\n", USBDEVNAME(sc->atu_dev), pkt->AtHeader.fragmentation,
d2408 1
a2408 1
		DPRINTF(("%s: Packet too small?? (size:%d)\n",
d2443 1
a2443 1
		DPRINTF(("%s: infra decap (%d bytes)\n",
d2445 1
a2445 1
		DPRINTF(("%s: RX: %50D\n", USBDEVNAME(sc->atu_dev),
d2450 1
a2450 1
		DPRINTF(("%s: we shouldn't receive this (f_cntl=%02x)\n",
d2531 2
a2532 2
	DPRINTF(("%s: txeof me=%d  status=%d\n", USBDEVNAME(sc->atu_dev),
		c->atu_idx, status));
d2622 1
a2622 1
		DPRINTF(("%s: adhoc encap (bssid=%s)\n",
d2637 1
a2637 1
		DPRINTF(("%s: infra encap (bssid=%s)\n",
d2645 1
a2645 1
		DPRINTF(("%s: turning WEP on on packet\n",
d2710 3
a2712 2
		DPRINTF(("%s: index:%d (inuse=%d)\n",
		    USBDEVNAME(sc->atu_dev), entry->atu_idx, cd->atu_tx_inuse));
d2758 1
a2758 1
	DPRINTF(("%s: atu_init\n", USBDEVNAME(sc->atu_dev)));
d2768 2
a2769 1
		DPRINTF(("%s: tx list init failed\n", USBDEVNAME(sc->atu_dev)));
d2780 2
a2781 1
		DPRINTF(("%s: rx list init failed\n", USBDEVNAME(sc->atu_dev)));
d2791 2
a2792 2
		DPRINTF(("%s: open rx pipe failed: %s\n", USBDEVNAME(sc->atu_dev),
		    usbd_errstr(err)));
d2800 2
a2801 2
		DPRINTF(("%s: open tx pipe failed: %s\n", USBDEVNAME(sc->atu_dev),
		    usbd_errstr(err)));
d2819 1
a2819 1
	DPRINTF(("%s: starting up using MAC=%s\n",
d2830 1
a2830 1
	DPRINTF(("%s: initialised transceiver\n",
d2834 1
a2834 1
	DPRINTF(("%s: trying to start mgmt task...\n",
d2873 2
a2874 2
	DPRINTF(("%s: DEBUG: current BSSID=%s\n",
	    USBDEVNAME(sc->atu_dev), ether_sprintf(tmp)));
d2878 2
a2879 2
	DPRINTF(("%s: DEBUG: beacon period=%d\n",
	    USBDEVNAME(sc->atu_dev), tmp[0]));
d2883 2
a2884 2
	DPRINTF(("%s: DEBUG: privacy invoked=%d\n",
	    USBDEVNAME(sc->atu_dev), tmp[0]));
d2888 2
a2889 2
	DPRINTF(("%s: DEBUG: encr_level=%d\n",
	    USBDEVNAME(sc->atu_dev), tmp[0]));
d2893 2
a2894 2
	DPRINTF(("%s: DEBUG: icv error count=%d\n",
	     USBDEVNAME(sc->atu_dev), *(short *)tmp));
d2908 1
a2908 2
	DPRINTF(("%s: DEBUG: channel=%d\n", USBDEVNAME(sc->atu_dev),
	    tmp[0]));
d2922 2
a2923 2
	DPRINTF(("%s: DEBUG: beacon enable=%d\n",
	    USBDEVNAME(sc->atu_dev), tmp[0]));
d2937 2
a2938 2
	DPRINTF(("%s: DEBUG: desired ssid=%s\n",
	    USBDEVNAME(sc->atu_dev), tmp));
d2942 2
a2943 2
	DPRINTF(("%s: DEBUG: current ESSID=%s\n",
	    USBDEVNAME(sc->atu_dev), tmp));
d2953 1
a2953 1
	DPRINTF(("%s: changed wepkey %d (len=%d)\n",
d2987 2
a2988 1
	DPRINTF(("atu_ioctl: command=%lu\n", command));
d2992 1
a2992 1
		DPRINTF(("%s: SIOCSIFADDR\n", USBDEVNAME(sc->atu_dev)));
d3015 1
a3015 1
		DPRINTF(("%s: SIOCSIFFLAGS\n", USBDEVNAME(sc->atu_dev)));
d3040 2
a3041 2
			DPRINTF(("%s: ioctl calling "
			    "atu_init()\n", USBDEVNAME(sc->atu_dev)));
d3056 1
a3056 1
		DPRINTF(("%s: SIOCADDMULTI\n", USBDEVNAME(sc->atu_dev)));
d3062 1
a3062 1
		DPRINTF(("%s: SIOCDELMULTI\n", USBDEVNAME(sc->atu_dev)));
d3068 2
a3069 1
		DPRINTF(("%s: SIOCS80211NWID\n", USBDEVNAME(sc->atu_dev)));
d3084 2
a3085 1
		DPRINTF(("%s: SIOGS80211NWID\n", USBDEVNAME(sc->atu_dev)));
d3089 4
a3092 1
		atu_print_a_bunch_of_debug_things(sc);
d3115 4
a3118 1
			atu_print_a_bunch_of_debug_things(sc);
d3167 2
a3168 2
			DPRINTF(("%s: ioctl:  unknown 80211: "
			    "%04x %d\n", USBDEVNAME(sc->atu_dev), ireq->i_type,
d3283 1
a3283 1
		DPRINTF(("%s: ioctl: get wavelan\n",
d3296 1
a3296 1
		DPRINTF(("%s: SIOCGWAVELAN\n", USBDEVNAME(sc->atu_dev)));
d3302 1
a3302 1
		DPRINTF(("%s: ioctl: wi_type=%04x %d\n",
d3309 1
a3309 1
		DPRINTF(("%s: ioctl: wavset type=%x\n",
d3315 1
a3315 1
		DPRINTF(("%s: ioctl: default\n",
d3386 1
a3386 1
		DPRINTF(("%s: waiting for mgmt task to die\n",
d3394 1
a3394 1
	DPRINTF(("%s: stopped managment thread\n",
@


1.7
log
@remove test code; Danovitsch@@vitsch.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.6 2004/11/11 00:08:29 deraadt Exp $ */
d127 2
d133 2
d148 1
@


1.6
log
@remove excessive splnet; Danovitsch@@vitsch.net
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.5 2004/11/10 21:45:23 dlg Exp $ */
a755 31
	if (pkt->WiHeader.addr1[0]==0xff) {
		printf("lal :)\n");

		/* memcpy(pkt->WiHeader.addr1, sc->atu_bssid, 6); */
		/*
		pkt->WiHeader.addr1[0]=0xe3;
		pkt->WiHeader.addr1[1]=0x13;
		pkt->WiHeader.addr1[2]=0x41;
		pkt->WiHeader.addr1[3]=0x25;
		pkt->WiHeader.addr1[4]=0x61;
		pkt->WiHeader.addr1[5]=0xe3;
		*/

		/*
		pkt->WiHeader.addr1[0]=0x00;
		pkt->WiHeader.addr1[1]=0x04;
		pkt->WiHeader.addr1[2]=0xe2;
		pkt->WiHeader.addr1[3]=0xa9;
		pkt->WiHeader.addr1[4]=0xf5;
		pkt->WiHeader.addr1[5]=0x28;
		*/

		/*
		pkt->WiHeader.addr1[0]=0x0;
		pkt->WiHeader.addr1[1]=0x0;
		pkt->WiHeader.addr1[2]=0x0;
		pkt->WiHeader.addr1[3]=0x0;
		pkt->WiHeader.addr1[4]=0x0;
		pkt->WiHeader.addr1[5]=0x0;
		*/
	}
a790 3
	/* DAAN Daan daan */
	packet->athdr.tx_rate = 0;

d2590 1
a2590 3
	/*pkt->AtHeader.tx_rate = 4;			 rate = auto */
	/* DAAN Daan daan !!! */
	pkt->AtHeader.tx_rate = 0;
@


1.5
log
@allocate a single buffer for the rx xfer to use rather than let it try
allocating one every time we're restarting it in an interrupt handler.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.4 2004/11/09 21:08:49 dlg Exp $ */
a1720 2

	s = splnet();
@


1.4
log
@fix the url pointing to the original atuwi driver. pointed out by Dries
Schellekens.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.3 2004/11/09 14:42:26 dlg Exp $ */
d197 1
a1770 1
	SLIST_INIT(&sc->atu_cdata.atu_rx_free);
d1882 1
a1882 1
			DPRINTF(("%s: no memory for rx list -- packet dropped!\n",
d1889 1
a1889 1
			DPRINTF(("%s: no memory for rx list -- packet dropped!\n",
d1905 33
a2376 2
	m = c->atu_mbuf;

d2378 1
a2378 1
		DPRINTF(("%s: atuw_rxeof: too short\n",
d2383 3
a2506 3
	/* Put transfer back into rx-chain */
	SLIST_INSERT_HEAD(&sc->atu_cdata.atu_rx_free, c, atu_list);

d2509 3
a2511 2
	    c, mtod(c->atu_mbuf, char *), ATU_RX_BUFSZ,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, atu_rxeof);
d2796 2
a2797 3
	if (atu_xfer_list_init(sc, cd->atu_rx_chain, ATU_RX_LIST_CNT, 1,
	    0, &cd->atu_rx_free)) {
		DPRINTF(("%s: rx list init failed\n", USBDEVNAME(sc->atu_dev)));
d2833 3
a2835 2
		    c, mtod(c->atu_mbuf, char *), ATU_RX_BUFSZ,
		    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, atu_rxeof);
@


1.3
log
@remove useless bpf code. removes dependancy on code from an(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.2 2004/11/08 22:41:55 deraadt Exp $ */
d39 1
a39 1
 *  http://vitsch.net/bsd/atu
@


1.2
log
@let it actually compile
@
text
@d1 1
a1 1
/*	$OpenBSD: if_atu.c,v 1.1 2004/11/08 22:09:11 dlg Exp $ */
a89 4
#if 0
#include <dev/ic/anreg.h>
#endif

a180 5
#if 0
void
atu_airo_tap(struct atu_softc *sc, u_int8_t *pkt, u_int length,
    struct at76c503_rx_buffer *at_hdr);
#endif
a743 83
#if 0
void
atu_airo_tap(struct atu_softc *sc, u_int8_t *pkt, u_int length,
    struct at76c503_rx_buffer *at_hdr)
{
	struct mbuf		*airo_pkt;
	struct an_rxframe	*airo_hdr;
	struct wi_80211_hdr	*wi_hdr;
	struct wi_80211_hdr	*wi_hdr_dst;
	int			wi_hdr_len;
	u_int8_t		*payload_ptr;
	int s;

	MGETHDR(airo_pkt, M_DONTWAIT, MT_DATA);
	if (airo_pkt == NULL) {
		DPRINTF(("%s: airo_tap: could not get an mbuf!\n",
		    USBDEVNAME(sc->atu_dev)));
		return;
	}

	MCLGET(airo_pkt, M_DONTWAIT);
	if (!(airo_pkt->m_flags & M_EXT)) {
		DPRINTF(("%s: airo_tap: could not get an mbuf!\n",
		    USBDEVNAME(sc->atu_dev)));
		m_freem(airo_pkt);
		return;
	}

	airo_pkt->m_len = airo_pkt->m_pkthdr.len =
	    MCLBYTES;

	airo_hdr = mtod(airo_pkt, struct an_rxframe *);
	wi_hdr_dst = (struct wi_80211_hdr *)&airo_hdr->an_frame_ctl;
	wi_hdr = (struct wi_80211_hdr *)pkt;
	payload_ptr = mtod(airo_pkt, u_int8_t *) + sizeof(struct an_rxframe);

	bzero(airo_hdr, sizeof(struct an_rxframe));

	if (at_hdr != NULL) {
		/* It's a received packet : fill in receiver info */
		airo_hdr->an_rx_time = at_hdr->rx_time;
		airo_hdr->an_rx_signal_strength = at_hdr->rssi;
		airo_hdr->an_rx_rate = at_hdr->rx_rate;

		/* this is inaccurate when scanning! */
		airo_hdr->an_rx_chan = sc->atu_channel;

	} else {
		/* It's a transmitted packet : make up as much as we can */
		airo_hdr->an_rx_time = 0;
		airo_hdr->an_rx_signal_strength = 0xff;
		airo_hdr->an_rx_rate = 4;

		airo_hdr->an_rx_chan = sc->atu_channel;
	}

	if ((wi_hdr->frame_ctl & WI_FCTL_FTYPE) == WI_FTYPE_DATA) {
		wi_hdr_len = sizeof(struct wi_80211_hdr);
	} else {
		wi_hdr_len = sizeof(struct wi_mgmt_hdr);
	}

	airo_hdr->an_rx_payload_len = length - wi_hdr_len;

	bcopy(wi_hdr, wi_hdr_dst, wi_hdr_len);
	airo_hdr->an_gaplen = 0;

	m_copyback(airo_pkt, sizeof(struct an_rxframe), length - wi_hdr_len,
	    pkt + wi_hdr_len);

	airo_pkt->m_pkthdr.rcvif = &sc->arpcom.ac_if;
	s = splnet();
	IF_INPUT(&sc->arpcom.ac_if, airo_pkt);
	splx(s);

	airo_pkt->m_pkthdr.len = airo_pkt->m_len = length - wi_hdr_len +
	    sizeof(struct an_rxframe);

	bpf_mtap(sc->atu_airobpf, airo_pkt);
	m_free(airo_pkt);
}
#endif /* 0 */

d749 1
a749 3
#if 0
	struct ifnet		*ifp = &sc->arpcom.ac_if;
#endif
a753 14
#if 0
	if (ifp->if_bpf) {
		DPRINTF(("%s: bpf_tap on tx\n", USBDEVNAME(sc->atu_dev)));
		bpf_tap(ifp->if_bpf, c->atu_buf, c->atu_length);
	}

	/* drop the raw 802.11b packets to bpf */
	if (sc->atu_rawbpf) {
		DPRINTF(("%s: raw bpf tap on TX :)\n",
		    USBDEVNAME(sc->atu_dev)));
		bpf_tap(sc->atu_rawbpf, c->atu_buf, c->atu_length);
	}
#endif

a786 15
#if 0
	/* drop the raw 802.11b packets to bpf with aironet header */
	if (sc->atu_airobpf) {

		DPRINTF(("%s: aironet bpf tap on TX :)\n",
		    USBDEVNAME(sc->atu_dev)));

		pkt = (struct atu_txpkt *)c->atu_buf;

		atu_airo_tap(sc, (u_int8_t *)&pkt->WiHeader,
		    c->atu_length - sizeof(struct at76c503_tx_buffer),
		    NULL);
	}
#endif

a1832 8
	/* attach to bpf for raw 802.11 packets */
#if 0
#if NBPFILTER > 0
	bpfattach(&sc->atu_rawbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + 64);
#endif
#endif

a1843 6
#if 0
#if NBPFILTER > 0
	bpfdetach(ipf);
#endif
#endif

a2353 38
#if 0
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_tap(ifp->if_bpf, (u_int8_t *)&pkt->WiHeader,
		     pkt->AtHeader.wlength);
#if 0
	if (ifp->if_bpf) {
		printf("HELKLO@@#\n");
		BPF_MTAP(ifp, m);
	}
#endif
#endif
#endif

#if 0
	/* drop the raw 802.11b packets to bpf (including 4-byte FCS) */
	if (sc->atu_rawbpf) {
		/*
		 * TODO: could drop mbuf's to bpf
		 */
		DPRINTF(("%s: bpf raw tap on RX :)\n",
		    USBDEVNAME(sc->atu_dev)));

		bpf_tap(sc->atu_rawbpf, (u_int8_t *)&pkt->WiHeader,
		     pkt->AtHeader.wlength);
	}
#endif
#if 0
	/* drop the raw 802.11b packets to bpf (with aironet header) */
	if (sc->atu_airobpf) {
		DPRINTF(("%s: bpf aironet tap on RX\n",
		    USBDEVNAME(sc->atu_dev)));

		atu_airo_tap(sc, (u_int8_t *)&pkt->WiHeader,
		    pkt->AtHeader.wlength - 4, &pkt->AtHeader);
	}
#endif

a2724 5
#if 0
		if (sc->atu_airobpf)
			bpf_mtap(sc->atu_airobpf, m_head);
#endif

@


1.1
log
@Atmel AT76c503 / AT76c503a / AT76c505 / AT76c505a  USB WLAN driver

originally the atuwi driver from Daan Vreeken, but with enough changes by
deraadt@@ and me to warrant a name change.

there are still plenty of issues to resolve, but at least i can get packets
over it now.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d2287 1
d2311 1
d2323 1
d2326 1
a2326 1

@

