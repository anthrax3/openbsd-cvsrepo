head	1.61;
access;
symbols
	OPENBSD_6_1:1.61.0.4
	OPENBSD_6_1_BASE:1.61
	OPENBSD_6_0:1.60.0.8
	OPENBSD_6_0_BASE:1.60
	OPENBSD_5_9:1.60.0.2
	OPENBSD_5_9_BASE:1.60
	OPENBSD_5_8:1.60.0.4
	OPENBSD_5_8_BASE:1.60
	OPENBSD_5_7:1.58.0.2
	OPENBSD_5_7_BASE:1.58
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.57.0.6
	OPENBSD_5_5_BASE:1.57
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.54.0.8
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.6
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.4
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.53.0.2
	OPENBSD_4_9_BASE:1.53
	OPENBSD_4_8:1.47.0.4
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.46.0.4
	OPENBSD_4_6_BASE:1.46
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.44.0.2
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.41.0.2
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.38.0.2
	OPENBSD_4_2_BASE:1.38
	OPENBSD_4_1:1.29.0.2
	OPENBSD_4_1_BASE:1.29
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16;
locks; strict;
comment	@ * @;


1.61
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.60;
commitid	blfE5YU3eGM81J65;

1.60
date	2015.06.07.20.11.52;	author claudio;	state Exp;
branches;
next	1.59;
commitid	R73m2dP0mEnXu6rx;

1.59
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.58;
commitid	p4LJxGKbi0BU2cG6;

1.58
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.57;
commitid	PSjXNz8dGohZ6ZSK;

1.57
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.53;

1.53
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.51;

1.51
date	2010.12.06.04.41.40;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.47;

1.47
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2009.04.26.02.20.58;	author cnst;	state Exp;
branches;
next	1.45;

1.45
date	2008.11.21.11.36.19;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2008.07.10.13.48.54;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2008.07.06.10.00.47;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2008.07.05.12.11.51;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.11.23.16.23.11;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.23.12.16.17;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2007.04.21.20.17.04;	author art;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.21.08.50.14;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.03.22.16.55.31;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2007.01.02.22.40.22;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2006.12.23.17.46.39;	author deraadt;	state Exp;
branches;
next	1.27;

1.27
date	2006.12.10.16.47.44;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2006.12.10.16.13.32;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2006.12.10.15.42.12;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2006.12.10.14.39.05;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2006.12.06.11.44.53;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2006.12.05.15.23.16;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.15.07.10.14;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2006.10.28.09.26.46;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2006.10.27.11.28.40;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2006.10.14.22.41.21;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2006.10.11.13.06.35;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.06.19.16.23.32;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2006.06.19.15.13.35;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2006.06.17.12.26.55;	author mbalmer;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.12.09.51.09;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.05.10.06.12;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.04.09.52.40;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2006.05.28.18.52.16;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.27.21.32.21;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.27.18.22.04;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.27.08.22.56;	author mbalmer;	state Exp;
branches;
next	1.5;

1.5
date	2006.04.22.22.12.31;	author mbalmer;	state Exp;
branches;
next	1.4;

1.4
date	2006.04.21.16.13.14;	author mbalmer;	state Exp;
branches;
next	1.3;

1.3
date	2006.04.20.21.04.36;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2006.04.20.10.12.00;	author mbalmer;	state Exp;
branches;
next	1.1;

1.1
date	2006.04.19.21.12.49;	author mbalmer;	state Exp;
branches;
next	;


desc
@@


1.61
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: udcf.c,v 1.60 2015/06/07 20:11:52 claudio Exp $ */

/*
 * Copyright (c) 2006, 2007, 2008 Marc Balmer <mbalmer@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/file.h>
#include <sys/select.h>
#include <sys/device.h>
#include <sys/poll.h>
#include <sys/time.h>
#include <sys/sensors.h>
#include <sys/timeout.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#ifdef UDCF_DEBUG
#define DPRINTFN(n, x)	do { if (udcfdebug > (n)) printf x; } while (0)
int udcfdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x)	DPRINTFN(0, x)

#define UDCF_READ_IDX	0x1f

#define UDCF_CTRL_IDX	0x33
#define UDCF_CTRL_VAL	0x98

#define FT232R_RESET	0x00	/* reset USB request */
#define FT232R_STATUS	0x05	/* get modem status USB request */
#define FT232R_RI	0x40	/* ring indicator */

#define DPERIOD1	((long) 5 * 60)		/* degrade OK -> WARN */
#define DPERIOD2	((long) 15 * 60)	/* degrade WARN -> CRIT */

/* max. skew of received time diff vs. measured time diff in percent. */
#define MAX_SKEW	5

#define CLOCK_DCF77	"DCF77"

struct udcf_softc {
	struct device		sc_dev;		/* base device */
	struct usbd_device	*sc_udev;	/* USB device */
	struct usbd_interface	*sc_iface;	/* data interface */

	struct timeout		sc_to;
	struct usb_task		sc_task;

	struct timeout		sc_bv_to;	/* bit-value detect */
	struct timeout		sc_db_to;	/* debounce */
	struct timeout		sc_mg_to;	/* minute-gap detect */
	struct timeout		sc_sl_to;	/* signal-loss detect */
	struct timeout		sc_it_to;	/* invalidate time */
	struct usb_task		sc_bv_task;
	struct usb_task		sc_mg_task;
	struct usb_task		sc_sl_task;

	usb_device_request_t	sc_req;

	int			sc_sync;	/* 1 during sync */
	u_int64_t		sc_mask;	/* 64 bit mask */
	u_int64_t		sc_tbits;	/* Time bits */
	int			sc_minute;
	int			sc_level;
	time_t			sc_last_mg;
	int			(*sc_signal)(struct udcf_softc *);

	time_t			sc_current;	/* current time */
	time_t			sc_next;	/* time to become valid next */
	time_t			sc_last;
	int			sc_nrecv;	/* consecutive valid times */
	struct timeval		sc_last_tv;	/* uptime of last valid time */
	struct ksensor		sc_sensor;
#ifdef UDCF_DEBUG
	struct ksensor		sc_skew;	/* recv vs local skew */
#endif
	struct ksensordev	sc_sensordev;
};

/*
 * timeouts being used in hz:
 * t_bv		bit value detection (150ms)
 * t_sync	sync (950ms)
 * t_mg		minute gap detection (1500ms)
 * t_mgsync	resync after a minute gap (450ms)
 * t_sl		detect signal loss (3sec)
 * t_wait	wait (5sec)
 * t_warn	degrade sensor status to warning (5min)
 * t_crit	degrade sensor status to critical (15min)
 */
static int t_bv, t_sync, t_mg, t_sl, t_mgsync, t_wait, t_warn, t_crit;

void	udcf_intr(void *);
void	udcf_probe(void *);

void	udcf_bv_intr(void *);
void	udcf_mg_intr(void *);
void	udcf_sl_intr(void *);
void	udcf_it_intr(void *);
void	udcf_bv_probe(void *);
void	udcf_mg_probe(void *);
void	udcf_sl_probe(void *);

int udcf_match(struct device *, void *, void *);
void udcf_attach(struct device *, struct device *, void *);
int udcf_detach(struct device *, int);

int udcf_nc_signal(struct udcf_softc *);
int udcf_nc_init_hw(struct udcf_softc *);
int udcf_ft232r_signal(struct udcf_softc *);
int udcf_ft232r_init_hw(struct udcf_softc *);

struct cfdriver udcf_cd = {
	NULL, "udcf", DV_DULL
};

const struct cfattach udcf_ca = {
	sizeof(struct udcf_softc), udcf_match, udcf_attach, udcf_detach,
};

static const struct usb_devno udcf_devs[] = {
	{ USB_VENDOR_GUDE, USB_PRODUCT_GUDE_DCF },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_DCF }
};

int
udcf_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg		*uaa = aux;

	if (uaa->iface == NULL)
		return UMATCH_NONE;

	return (usb_lookup(udcf_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
udcf_attach(struct device *parent, struct device *self, void *aux)
{
	struct udcf_softc		*sc = (struct udcf_softc *)self;
	struct usb_attach_arg		*uaa = aux;
	struct usbd_device		*dev = uaa->device;
	struct usbd_interface		*iface;
	struct timeval			 t;
	usbd_status			 err;

	switch (uaa->product) {
	case USB_PRODUCT_GUDE_DCF:
		sc->sc_signal = udcf_nc_signal;
		strlcpy(sc->sc_sensor.desc, "DCF77",
		    sizeof(sc->sc_sensor.desc));
		break;
	case USB_PRODUCT_FTDI_DCF:
		sc->sc_signal = udcf_ft232r_signal;
		strlcpy(sc->sc_sensor.desc, "DCF77",
		    sizeof(sc->sc_sensor.desc));
		break;
	}

	usb_init_task(&sc->sc_task, udcf_probe, sc, USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->sc_bv_task, udcf_bv_probe, sc, USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->sc_mg_task, udcf_mg_probe, sc, USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->sc_sl_task, udcf_sl_probe, sc, USB_TASK_TYPE_GENERIC);

	timeout_set(&sc->sc_to, udcf_intr, sc);
	timeout_set(&sc->sc_bv_to, udcf_bv_intr, sc);
	timeout_set(&sc->sc_mg_to, udcf_mg_intr, sc);
	timeout_set(&sc->sc_sl_to, udcf_sl_intr, sc);
	timeout_set(&sc->sc_it_to, udcf_it_intr, sc);

	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor.type = SENSOR_TIMEDELTA;
	sc->sc_sensor.status = SENSOR_S_UNKNOWN;
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor);

#ifdef UDCF_DEBUG
	sc->sc_skew.type = SENSOR_TIMEDELTA;
	sc->sc_skew.status = SENSOR_S_UNKNOWN;
	strlcpy(sc->sc_skew.desc, "local clock skew",
	    sizeof(sc->sc_skew.desc));
	sensor_attach(&sc->sc_sensordev, &sc->sc_skew);
#endif
	sensordev_install(&sc->sc_sensordev);

	sc->sc_udev = dev;
	if ((err = usbd_device2interface_handle(dev, 0, &iface))) {
		DPRINTF(("%s: failed to get interface, err=%s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err)));
		goto fishy;
	}

	sc->sc_iface = iface;

	sc->sc_level = 0;
	sc->sc_minute = 0;
	sc->sc_last_mg = 0L;

	sc->sc_sync = 1;

	sc->sc_current = 0L;
	sc->sc_next = 0L;
	sc->sc_nrecv = 0;
	sc->sc_last = 0L;
	sc->sc_last_tv.tv_sec = 0L;

	switch (uaa->product) {
	case USB_PRODUCT_GUDE_DCF:
		if (udcf_nc_init_hw(sc))
			goto fishy;
		break;
	case USB_PRODUCT_FTDI_DCF:
		if (udcf_ft232r_init_hw(sc))
			goto fishy;
		break;
	}

	/* convert timevals to hz */
	t.tv_sec = 0L;
	t.tv_usec = 150000L;
	t_bv = tvtohz(&t);

	t.tv_usec = 450000L;
	t_mgsync = tvtohz(&t);

	t.tv_usec = 950000L;
	t_sync = tvtohz(&t);

	t.tv_sec = 1L;
	t.tv_usec = 500000L;
	t_mg = tvtohz(&t);

	t.tv_sec = 3L;
	t.tv_usec = 0L;
	t_sl = tvtohz(&t);
	
	t.tv_sec = 5L;
	t_wait = tvtohz(&t);

	t.tv_sec = DPERIOD1;
	t_warn = tvtohz(&t);

	t.tv_sec = DPERIOD2;
	t_crit = tvtohz(&t);

	/* Give the receiver some slack to stabilize */
	timeout_add(&sc->sc_to, t_wait);

	/* Detect signal loss */
	timeout_add(&sc->sc_sl_to, t_wait + t_sl);

	DPRINTF(("synchronizing\n"));
	return;

fishy:
	DPRINTF(("udcf_attach failed\n"));
	usbd_deactivate(sc->sc_udev);
}

int
udcf_detach(struct device *self, int flags)
{
	struct udcf_softc	*sc = (struct udcf_softc *)self;

	if (timeout_initialized(&sc->sc_to))
		timeout_del(&sc->sc_to);
	if (timeout_initialized(&sc->sc_bv_to))
		timeout_del(&sc->sc_bv_to);
	if (timeout_initialized(&sc->sc_mg_to))
		timeout_del(&sc->sc_mg_to);
	if (timeout_initialized(&sc->sc_sl_to))
		timeout_del(&sc->sc_sl_to);
	if (timeout_initialized(&sc->sc_it_to))
		timeout_del(&sc->sc_it_to);

	/* Unregister the clock with the kernel */
	sensordev_deinstall(&sc->sc_sensordev);
	usb_rem_task(sc->sc_udev, &sc->sc_task);
	usb_rem_task(sc->sc_udev, &sc->sc_bv_task);
	usb_rem_task(sc->sc_udev, &sc->sc_mg_task);
	usb_rem_task(sc->sc_udev, &sc->sc_sl_task);

	return 0;
}

/* udcf_intr runs in an interrupt context */
void
udcf_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_task);
}

/* bit value detection */
void
udcf_bv_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_bv_task);
}

/* minute gap detection */
void
udcf_mg_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_mg_task);
}

/* signal loss detection */
void
udcf_sl_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_sl_task);
}

/*
 * initialize the Expert mouseCLOCK USB devices, they use a NetCologne
 * chip to interface the receiver.  Power must be supplied to the
 * receiver and the receiver must be turned on.
 */
int
udcf_nc_init_hw(struct udcf_softc *sc)
{
	usbd_status			 err;
	usb_device_request_t		 req;
	uWord				 result;
	int				 actlen;

	/* Prepare the USB request to probe the value */
	sc->sc_req.bmRequestType = UT_READ_VENDOR_DEVICE;
	sc->sc_req.bRequest = 1;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, UDCF_READ_IDX);
	USETW(sc->sc_req.wLength, 1);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = 0;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	if ((err = usbd_do_request_flags(sc->sc_udev, &req, &result,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))) {
		DPRINTF(("failed to turn on power for receiver\n"));
		return -1;
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = 0;
	USETW(req.wValue, UDCF_CTRL_VAL);
	USETW(req.wIndex, UDCF_CTRL_IDX);
	USETW(req.wLength, 0);
	if ((err = usbd_do_request_flags(sc->sc_udev, &req, &result,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))) {
		DPRINTF(("failed to turn on receiver\n"));
		return -1;
	}
	return 0;
}

/*
 * initialize the Expert mouseCLOCK USB II devices, they use an FTDI
 * FT232R chip to interface the receiver.  Only reset the chip.
 */
int
udcf_ft232r_init_hw(struct udcf_softc *sc)
{
	usbd_status		err;
	usb_device_request_t	req;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = FT232R_RESET;
	/* 0 resets the SIO */
	USETW(req.wValue,FT232R_RESET);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		DPRINTF(("failed to reset ftdi\n"));
		return -1;
	}
	return 0;
}

/*
 * return 1 during high-power-, 0 during low-power-emission
 * If bit 0 is set, the transmitter emits at full power.
 * During the low-power emission we decode a zero bit.
 */
int
udcf_nc_signal(struct udcf_softc *sc)
{
	int		actlen;
	unsigned char	data;

	if (usbd_do_request_flags(sc->sc_udev, &sc->sc_req, &data,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))
		/* This happens if we pull the receiver */
		return -1;
	return data & 0x01;
}

/* pick up the signal level through the FTDI FT232R chip */
int
udcf_ft232r_signal(struct udcf_softc *sc)
{
	usb_device_request_t	req;
	int			actlen;
	u_int16_t		data;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = FT232R_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 2);
	if (usbd_do_request_flags(sc->sc_udev, &req, &data,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT)) {
		DPRINTFN(2, ("error reading ftdi modem status\n"));
		return -1;
	}
	DPRINTFN(2, ("ftdi status 0x%04x\n", data));
	return data & FT232R_RI ? 0 : 1;
}

/* udcf_probe runs in a process context. */
void
udcf_probe(void *xsc)
{
	struct udcf_softc	*sc = xsc;
	struct timespec		 now;
	int			 data;

	if (usbd_is_dying(sc->sc_udev))
		return;

	data = sc->sc_signal(sc);
	if (data == -1)
		return;

	if (data) {
		sc->sc_level = 1;
		timeout_add(&sc->sc_to, 1);
		return;
	}

	if (sc->sc_level == 0)
		return;

	/* the beginning of a second */
	sc->sc_level = 0;
	if (sc->sc_minute == 1) {
		if (sc->sc_sync) {
			DPRINTF(("start collecting bits\n"));
			sc->sc_sync = 0;
		} else {
			/* provide the timedelta */
			microtime(&sc->sc_sensor.tv);
			nanotime(&now);
			sc->sc_current = sc->sc_next;
			sc->sc_sensor.value = (int64_t)(now.tv_sec -
			    sc->sc_current) * 1000000000LL + now.tv_nsec;

			sc->sc_sensor.status = SENSOR_S_OK;

			/*
			 * if no valid time information is received
			 * during the next 5 minutes, the sensor state
			 * will be degraded to SENSOR_S_WARN
			 */
			timeout_add(&sc->sc_it_to, t_warn);
		}
		sc->sc_minute = 0;
	}

	timeout_add(&sc->sc_to, t_sync);	/* resync in 950 ms */

	/* no clock and bit detection during sync */
	if (!sc->sc_sync) {
		/* detect bit value */
		timeout_add(&sc->sc_bv_to, t_bv);
	}
	timeout_add(&sc->sc_mg_to, t_mg);	/* detect minute gap */
	timeout_add(&sc->sc_sl_to, t_sl);	/* detect signal loss */
}

/* detect the bit value */
void
udcf_bv_probe(void *xsc)
{
	struct udcf_softc	*sc = xsc;
	int			 data;

	if (usbd_is_dying(sc->sc_udev))
		return;

	data = sc->sc_signal(sc);
	if (data == -1) {
		DPRINTF(("bit detection failed\n"));
		return;
	}	

	DPRINTFN(1, (data ? "0" : "1"));
	if (!(data))
		sc->sc_tbits |= sc->sc_mask;
	sc->sc_mask <<= 1;
}

/* detect the minute gap */
void
udcf_mg_probe(void *xsc)
{
	struct udcf_softc	*sc = xsc;
	struct clock_ymdhms	 ymdhm;
	struct timeval		 monotime;
	int			 tdiff_recv, tdiff_local;
	int			 skew;
	int			 minute_bits, hour_bits, day_bits;
	int			 month_bits, year_bits, wday;
	int			 p1, p2, p3;
	int			 p1_bit, p2_bit, p3_bit;
	int			 r_bit, a1_bit, a2_bit, z1_bit, z2_bit;
	int			 s_bit, m_bit;
	u_int32_t		 parity = 0x6996;

	if (sc->sc_sync) {
		sc->sc_minute = 1;
		goto cleanbits;
	}

	if (time_second - sc->sc_last_mg < 57) {
		DPRINTF(("\nunexpected gap, resync\n"));
		sc->sc_sync = sc->sc_minute = 1;
		goto cleanbits;	
	}

	/* extract bits w/o parity */
	m_bit = sc->sc_tbits & 1;
	r_bit = sc->sc_tbits >> 15 & 1;
	a1_bit = sc->sc_tbits >> 16 & 1;
	z1_bit = sc->sc_tbits >> 17 & 1;
	z2_bit = sc->sc_tbits >> 18 & 1;
	a2_bit = sc->sc_tbits >> 19 & 1;
	s_bit = sc->sc_tbits >> 20 & 1;
	p1_bit = sc->sc_tbits >> 28 & 1;
	p2_bit = sc->sc_tbits >> 35 & 1;
	p3_bit = sc->sc_tbits >> 58 & 1;

	minute_bits = sc->sc_tbits >> 21 & 0x7f;	
	hour_bits = sc->sc_tbits >> 29 & 0x3f;
	day_bits = sc->sc_tbits >> 36 & 0x3f;
	wday = (sc->sc_tbits >> 42) & 0x07;
	month_bits = sc->sc_tbits >> 45 & 0x1f;
	year_bits = sc->sc_tbits >> 50 & 0xff;

	/* validate time information */
	p1 = (parity >> (minute_bits & 0x0f) & 1) ^
	    (parity >> (minute_bits >> 4) & 1);

	p2 = (parity >> (hour_bits & 0x0f) & 1) ^
	    (parity >> (hour_bits >> 4) & 1);

	p3 = (parity >> (day_bits & 0x0f) & 1) ^
	    (parity >> (day_bits >> 4) & 1) ^
	    ((parity >> wday) & 1) ^ (parity >> (month_bits & 0x0f) & 1) ^
	    (parity >> (month_bits >> 4) & 1) ^
	    (parity >> (year_bits & 0x0f) & 1) ^
	    (parity >> (year_bits >> 4) & 1);

	if (m_bit == 0 && s_bit == 1 && p1 == p1_bit && p2 == p2_bit &&
	    p3 == p3_bit && (z1_bit ^ z2_bit)) {

		/* Decode time */
		if ((ymdhm.dt_year = 2000 + FROMBCD(year_bits)) > 2037) {
			DPRINTF(("year out of range, resync\n"));
			sc->sc_sync = 1;
			goto cleanbits;
		}
		ymdhm.dt_min = FROMBCD(minute_bits);
		ymdhm.dt_hour = FROMBCD(hour_bits);
		ymdhm.dt_day = FROMBCD(day_bits);
		ymdhm.dt_mon = FROMBCD(month_bits);
		ymdhm.dt_sec = 0;

		sc->sc_next = clock_ymdhms_to_secs(&ymdhm);
		getmicrouptime(&monotime);

		/* convert to coordinated universal time */
		sc->sc_next -= z1_bit ? 7200 : 3600;

		DPRINTF(("\n%02d.%02d.%04d %02d:%02d:00 %s",
		    ymdhm.dt_day, ymdhm.dt_mon, ymdhm.dt_year,
		    ymdhm.dt_hour, ymdhm.dt_min, z1_bit ? "CEST" : "CET"));
		DPRINTF((r_bit ? ", call bit" : ""));
		DPRINTF((a1_bit ? ", dst chg ann." : ""));
		DPRINTF((a2_bit ? ", leap sec ann." : ""));
		DPRINTF(("\n"));

		if (sc->sc_last) {
			tdiff_recv = sc->sc_next - sc->sc_last;
			tdiff_local = monotime.tv_sec - sc->sc_last_tv.tv_sec;
			skew = abs(tdiff_local - tdiff_recv);
#ifdef UDCF_DEBUG
			if (sc->sc_skew.status == SENSOR_S_UNKNOWN)
				sc->sc_skew.status = SENSOR_S_CRIT;
			sc->sc_skew.value = skew * 1000000000LL;
			getmicrotime(&sc->sc_skew.tv);
#endif
			DPRINTF(("local = %d, recv = %d, skew = %d\n",
			    tdiff_local, tdiff_recv, skew));

			if (skew && skew * 100LL / tdiff_local > MAX_SKEW) {
				DPRINTF(("skew out of tolerated range\n"));
				goto cleanbits;
			} else {
				if (sc->sc_nrecv < 2) {
					sc->sc_nrecv++;
					DPRINTF(("got frame %d\n",
					    sc->sc_nrecv));
				} else {
					DPRINTF(("data is valid\n"));
					sc->sc_minute = 1;
				}
			}
		} else {
			DPRINTF(("received the first frame\n"));
			sc->sc_nrecv = 1;
		}

		/* record the time received and when it was received */
		sc->sc_last = sc->sc_next;
		sc->sc_last_tv.tv_sec = monotime.tv_sec;
	} else {
		DPRINTF(("\nparity error, resync\n"));
		sc->sc_sync = sc->sc_minute = 1;
	}

cleanbits:
	timeout_add(&sc->sc_to, t_mgsync);	/* re-sync in 450 ms */
	sc->sc_last_mg = time_second;
	sc->sc_tbits = 0LL;
	sc->sc_mask = 1LL;
}

/* detect signal loss */
void
udcf_sl_probe(void *xsc)
{
	struct udcf_softc *sc = xsc;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(("no signal\n"));
	sc->sc_sync = 1;
	timeout_add(&sc->sc_to, t_wait);
	timeout_add(&sc->sc_sl_to, t_wait + t_sl);
}

/* invalidate timedelta (called in an interrupt context) */
void
udcf_it_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (sc->sc_sensor.status == SENSOR_S_OK) {
		sc->sc_sensor.status = SENSOR_S_WARN;
		/*
		 * further degrade in 15 minutes if we dont receive any new
		 * time information
		 */
		timeout_add(&sc->sc_it_to, t_crit);
	} else {
		sc->sc_sensor.status = SENSOR_S_CRIT;
		sc->sc_nrecv = 0;
	}
}
@


1.60
log
@The Swiss Federal Government decided to shut down HBG at the end of 2011.
On 6 September 2012 at 12:02:00 UTC both antenna towers were demolished by
controlled explosives. So this is not coming back and we can tedu the
support for HBG form the DCF77 drivers.
Remided by mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.59 2015/03/14 03:38:49 jsg Exp $ */
d150 1
a150 1
	if (uaa->iface != NULL)
a207 6
	if ((err = usbd_set_config_index(dev, 0, 1))) {
		DPRINTF(("%s: failed to set configuration, err=%s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err)));
		goto fishy;
	}

@


1.59
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.58 2014/07/12 20:26:33 mpi Exp $ */
d58 1
a58 6
#define CLOCK_DCF77	0
#define CLOCK_HBG	1

static const char	*clockname[2] = {
	"DCF77",
	"HBG" };
a72 1
	struct timeout		sc_ct_to;	/* detect clock type */
a75 1
	struct usb_task		sc_ct_task;
a78 2
	int			sc_detect_ct;	/* != 0: autodetect type */
	int			sc_clocktype;	/* DCF77 or HBG */
a101 1
 * t_ct		detect clocktype (250ms)
d110 1
a110 1
static int t_bv, t_ct, t_sync, t_mg, t_sl, t_mgsync, t_wait, t_warn, t_crit;
a118 1
void	udcf_ct_intr(void *);
a121 1
void	udcf_ct_probe(void *);
d142 1
a142 2
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_DCF },
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_HBG }
a168 1
		sc->sc_detect_ct = 1;
d170 1
a170 1
		strlcpy(sc->sc_sensor.desc, "Unknown",
d175 1
a175 6
		strlcpy(sc->sc_sensor.desc, clockname[CLOCK_DCF77],
		    sizeof(sc->sc_sensor.desc));
		break;
	case USB_PRODUCT_FTDI_HBG:
		sc->sc_signal = udcf_ft232r_signal;
		strlcpy(sc->sc_sensor.desc, clockname[CLOCK_HBG],
a190 5
	if (sc->sc_detect_ct) {
		usb_init_task(&sc->sc_ct_task, udcf_ct_probe, sc,
		    USB_TASK_TYPE_GENERIC);
		timeout_set(&sc->sc_ct_to, udcf_ct_intr, sc);
	}
a221 1
	sc->sc_clocktype = -1;
d239 1
a239 2
	case USB_PRODUCT_FTDI_DCF:	/* FALLTHROUGH */
	case USB_PRODUCT_FTDI_HBG:
a272 6
	if (sc->sc_detect_ct) {
		t.tv_sec = 0L;
		t.tv_usec = 250000L;
		t_ct = tvtohz(&t);
	}

a301 4
	if (sc->sc_detect_ct) {
		if (timeout_initialized(&sc->sc_ct_to))
			timeout_del(&sc->sc_ct_to);
	}
a308 2
	if (sc->sc_detect_ct)
		usb_rem_task(sc->sc_udev, &sc->sc_ct_task);
a344 8
/* detect the clock type (DCF77 or HBG) */
void
udcf_ct_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_ct_task);
}

a482 3
			if (sc->sc_sensor.status == SENSOR_S_UNKNOWN &&
			    sc->sc_detect_ct)
				sc->sc_clocktype = -1;
a490 8
			/* set the clocktype and make sensor valid */
			if (sc->sc_sensor.status == SENSOR_S_UNKNOWN &&
			    sc->sc_detect_ct) {
				strlcpy(sc->sc_sensor.desc, sc->sc_clocktype ?
				    clockname[CLOCK_HBG] :
				    clockname[CLOCK_DCF77],
				    sizeof(sc->sc_sensor.desc));
			}
a508 4

		/* detect clocktype */
		if (sc->sc_detect_ct && sc->sc_clocktype == -1)
			timeout_add(&sc->sc_ct_to, t_ct);
a707 22

/* detect clock type.  used for older devices only. */
void
udcf_ct_probe(void *xsc)
{
	struct udcf_softc	*sc = xsc;
	int			 data;

	if (usbd_is_dying(sc->sc_udev))
		return;

	data = sc->sc_signal(sc);
	if (data == -1) {
		DPRINTF(("clocktype detection failed\n"));
		return;
	}

	sc->sc_clocktype = data ? 0 : 1;
	DPRINTF(("\nclocktype is %s\n", sc->sc_clocktype ?
		clockname[CLOCK_HBG] : clockname[CLOCK_DCF77]));
}

@


1.58
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.57 2013/04/15 09:23:02 mglocker Exp $ */
a21 1
#include <sys/conf.h>
@


1.57
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.56 2013/03/28 03:58:03 tedu Exp $ */
d136 3
a138 4
int udcf_match(struct device *, void *, void *); 
void udcf_attach(struct device *, struct device *, void *); 
int udcf_detach(struct device *, int); 
int udcf_activate(struct device *, int); 
d150 1
a150 5
	sizeof(struct udcf_softc),
	udcf_match,
	udcf_attach,
	udcf_detach,
	udcf_activate
a791 12
int
udcf_activate(struct device *self, int act)
{
	struct udcf_softc *sc = (struct udcf_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return 0;
}
@


1.56
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.55 2013/03/28 03:31:55 tedu Exp $ */
d68 2
a69 2
	usbd_device_handle	sc_udev;	/* USB device */
	usbd_interface_handle	sc_iface;	/* data interface */
d181 2
a182 2
	usbd_device_handle		 dev = uaa->device;
	usbd_interface_handle		 iface;
@


1.55
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.54 2011/07/03 15:47:17 matthew Exp $ */
a24 1
#include <sys/proc.h>
d29 1
@


1.54
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.53 2011/01/25 20:03:36 jakemsr Exp $ */
a25 1
#include <sys/vnode.h>
@


1.53
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.52 2010/12/17 21:53:34 jasper Exp $ */
a803 2
	case DVACT_ACTIVATE:
		break;
@


1.52
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.51 2010/12/06 04:41:40 jakemsr Exp $ */
a277 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);

a354 2
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.51
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.50 2010/10/23 16:14:07 jakemsr Exp $ */
d173 2
a174 4
	if (usb_lookup(udcf_devs, uaa->vendor, uaa->product) == NULL)
		return UMATCH_NONE;

	return UMATCH_VENDOR_PRODUCT;
@


1.50
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.49 2010/10/23 15:42:09 jakemsr Exp $ */
a70 1
	u_char			sc_dying;	/* disconnecting */
d328 1
a328 1
	sc->sc_dying = 1;
d521 1
a521 1
	if (sc->sc_dying)
d596 1
a596 1
	if (sc->sc_dying)
d753 1
a753 1
	if (sc->sc_dying)
d768 1
a768 1
	if (sc->sc_dying)
d791 1
a791 1
	if (sc->sc_dying)
d814 1
a814 1
		sc->sc_dying = 1;
@


1.49
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.48 2010/09/24 08:33:59 yuo Exp $ */
d337 14
a350 7
	timeout_del(&sc->sc_to);
	timeout_del(&sc->sc_bv_to);
	timeout_del(&sc->sc_mg_to);
	timeout_del(&sc->sc_sl_to);
	timeout_del(&sc->sc_it_to);
	if (sc->sc_detect_ct)
		timeout_del(&sc->sc_ct_to);
@


1.48
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.47 2009/10/13 19:33:17 pirofti Exp $ */
d209 4
a212 4
	usb_init_task(&sc->sc_task, udcf_probe, sc);
	usb_init_task(&sc->sc_bv_task, udcf_bv_probe, sc);
	usb_init_task(&sc->sc_mg_task, udcf_mg_probe, sc);
	usb_init_task(&sc->sc_sl_task, udcf_sl_probe, sc);
d221 2
a222 1
		usb_init_task(&sc->sc_ct_task, udcf_ct_probe, sc);
@


1.47
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.46 2009/04/26 02:20:58 cnst Exp $ */
a334 2

	sc->sc_dying = 1;
@


1.46
log
@in ca_attach() there is no need to set .value and .flags of sensors to 0,
since autoconf(9) allocates softc with M_ZERO;  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.45 2008/11/21 11:36:19 mbalmer Exp $ */
d141 1
a141 1
int udcf_activate(struct device *, enum devact); 
d801 1
a801 1
udcf_activate(struct device *self, enum devact act)
@


1.45
log
@Kill some whitespace, removed unneeded stuff at the end of a list.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.44 2008/07/10 13:48:54 mbalmer Exp $ */
a228 2
	sc->sc_sensor.value = 0LL;
	sc->sc_sensor.flags = 0;
a233 2
	sc->sc_skew.value = 0LL;
	sc->sc_skew.flags = 0;
@


1.44
log
@Don't terminate the array of matching product/vendor IDs with { 0, 0 }
when usb_lookup is used.  If a device indeed has 0 as vendor and product
ID, like the  HP DL165 BMC Server Engines SE USB Device, a wrong driver
will attach and the machine will most pbly crash.

Problem reported Rivo Nurges <rix@@estpak.ee>
cvs: ----------------------------------------------------------------------
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.43 2008/07/06 10:00:47 mbalmer Exp $ */
d148 10
a157 10
struct cfdriver udcf_cd = { 
	NULL, "udcf", DV_DULL 
}; 

const struct cfattach udcf_ca = { 
	sizeof(struct udcf_softc), 
	udcf_match, 
	udcf_attach, 
	udcf_detach, 
	udcf_activate, 
@


1.43
log
@Use UT_{READ|WRITE}_VENDOR_DEVICE instead of self defined values.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.42 2008/07/05 12:11:51 mbalmer Exp $ */
d163 1
a163 2
	{ USB_VENDOR_FTDI, USB_PRODUCT_FTDI_HBG },
	{ 0, 0 }
@


1.42
log
@Add support for the new Expert mouseCLOCK USB II that uses an FTDI
FT232R chip to interface the receiver (instead of the NetCologne
chip used on older models).  Only the DCF77 and HBG receivers are
supported.

A sidenote:  Gude ADS not only provides me with receivers and
documentation, but as a result of my feedback on their older receivers
the new ones now have proper USB product IDs to distinguish between
DCF77, HBG, and MSF.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.41 2007/11/23 16:23:11 mbalmer Exp $ */
a44 1
#define UDCF_READ_REQ	0xc0
a46 1
#define UDCF_CTRL_REQ	0x40
d419 1
a419 1
	sc->sc_req.bmRequestType = UDCF_READ_REQ;
d425 1
a425 1
	req.bmRequestType = UDCF_CTRL_REQ;
d436 1
a436 1
	req.bmRequestType = UDCF_CTRL_REQ;
@


1.41
log
@Make sure that variables used during detach are initialized during attach.
Discussed with dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.40 2007/11/23 12:16:17 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
d52 4
d91 1
d99 1
d145 5
d162 7
d177 4
a180 3
	return uaa->vendor == USB_VENDOR_GUDE &&
	    uaa->product == USB_PRODUCT_GUDE_DCF ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
d192 19
a210 3
	usb_device_request_t		 req;
	uWord				 result;
	int				 actlen;
a215 1
	usb_init_task(&sc->sc_ct_task, udcf_ct_probe, sc);
a221 1
	timeout_set(&sc->sc_ct_to, udcf_ct_intr, sc);
d223 4
a233 1
	strlcpy(sc->sc_sensor.desc, "Unknown", sizeof(sc->sc_sensor.desc));
a246 1

d275 10
a284 27
	/* Prepare the USB request to probe the value */
	sc->sc_req.bmRequestType = UDCF_READ_REQ;
	sc->sc_req.bRequest = 1;
	USETW(sc->sc_req.wValue, 0);
	USETW(sc->sc_req.wIndex, UDCF_READ_IDX);
	USETW(sc->sc_req.wLength, 1);

	req.bmRequestType = UDCF_CTRL_REQ;
	req.bRequest = 0;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	if ((err = usbd_do_request_flags(sc->sc_udev, &req, &result,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))) {
		DPRINTF(("failed to turn on power for receiver\n"));
		goto fishy;
	}

	req.bmRequestType = UDCF_CTRL_REQ;
	req.bRequest = 0;
	USETW(req.wValue, UDCF_CTRL_VAL);
	USETW(req.wIndex, UDCF_CTRL_IDX);
	USETW(req.wLength, 0);
	if ((err = usbd_do_request_flags(sc->sc_udev, &req, &result,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))) {
		DPRINTF(("failed to turn on receiver\n"));
		goto fishy;
d318 5
a322 3
	t.tv_sec = 0L;
	t.tv_usec = 250000L;
	t_ct = tvtohz(&t);
d350 2
a351 1
	timeout_del(&sc->sc_ct_to);
d359 2
a360 1
	usb_rem_task(sc->sc_udev, &sc->sc_ct_task);
d408 46
a453 2
 * udcf_probe runs in a process context.  If bit 0 is set, the transmitter
 * emits at full power.  During the low-power emission we decode a zero bit.
d455 61
d521 1
a521 2
	unsigned char		 data;
	int			 actlen;
d526 2
a527 3
	if (usbd_do_request_flags(sc->sc_udev, &sc->sc_req, &data,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT))
		/* This happens if we pull the receiver */
d530 1
a530 1
	if (data & 0x01) {
d539 1
a539 1
	/* Begin of a second */
d545 2
a546 1
			if (sc->sc_sensor.status == SENSOR_S_UNKNOWN)
d557 2
a558 1
			if (sc->sc_sensor.status == SENSOR_S_UNKNOWN) {
d578 1
a578 1
	/* No clock and bit detection during sync */
d584 1
a584 1
		if (sc->sc_clocktype == -1)
d596 1
a596 2
	int			 actlen;
	unsigned char		 data;
d601 2
a602 3
	if (usbd_do_request_flags(sc->sc_udev, &sc->sc_req, &data,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT)) {
		/* This happens if we pull the receiver */
d605 1
a605 1
	}
d607 2
a608 2
	DPRINTFN(1, (data & 0x01 ? "0" : "1"));
	if (!(data & 0x01))
d641 1
a641 1
	/* Extract bits w/o parity */
d660 1
a660 1
	/* Validate time information */
d786 1
a786 1
/* detect clock type */
d791 1
a791 2
	int			 actlen;
	unsigned char		 data;
d796 2
a797 3
	if (usbd_do_request_flags(sc->sc_udev, &sc->sc_req, &data,
	    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT)) {
		/* This happens if we pull the receiver */
d802 1
a802 1
	sc->sc_clocktype = data & 0x01 ? 0 : 1;
@


1.40
log
@No need for process context to degrade the sensor status.
Discussed with kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.39 2007/10/11 18:33:14 deraadt Exp $ */
a171 1
	usb_interface_descriptor_t	*id;
d177 36
a224 3
	id = usbd_get_interface_descriptor(iface);

	sc->sc_udev = dev;
a239 22
	strlcpy(sc->sc_sensordev.xname, sc->sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	sc->sc_sensor.type = SENSOR_TIMEDELTA;
	sc->sc_sensor.status = SENSOR_S_UNKNOWN;
	sc->sc_sensor.value = 0LL;
	sc->sc_sensor.flags = 0;
	strlcpy(sc->sc_sensor.desc, "Unknown", sizeof(sc->sc_sensor.desc));
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor);

#ifdef UDCF_DEBUG
	sc->sc_skew.type = SENSOR_TIMEDELTA;
	sc->sc_skew.status = SENSOR_S_UNKNOWN;
	sc->sc_skew.value = 0LL;
	sc->sc_skew.flags = 0;
	strlcpy(sc->sc_skew.desc, "local clock skew",
	    sizeof(sc->sc_skew.desc));
	sensor_attach(&sc->sc_sensordev, &sc->sc_skew);
#endif

	sensordev_install(&sc->sc_sensordev);

a270 13

	usb_init_task(&sc->sc_task, udcf_probe, sc);
	usb_init_task(&sc->sc_bv_task, udcf_bv_probe, sc);
	usb_init_task(&sc->sc_mg_task, udcf_mg_probe, sc);
	usb_init_task(&sc->sc_sl_task, udcf_sl_probe, sc);
	usb_init_task(&sc->sc_ct_task, udcf_ct_probe, sc);

	timeout_set(&sc->sc_to, udcf_intr, sc);
	timeout_set(&sc->sc_bv_to, udcf_bv_intr, sc);
	timeout_set(&sc->sc_mg_to, udcf_mg_intr, sc);
	timeout_set(&sc->sc_sl_to, udcf_sl_intr, sc);
	timeout_set(&sc->sc_it_to, udcf_it_intr, sc);
	timeout_set(&sc->sc_ct_to, udcf_ct_intr, sc);
@


1.39
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.38 2007/06/14 10:11:15 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006 Marc Balmer <mbalmer@@openbsd.org>
a82 1
	struct usb_task		sc_it_task;
a131 1
void	udcf_it_probe(void *);
a265 1
	usb_init_task(&sc->sc_it_task, udcf_it_probe, sc);
a340 1
	usb_rem_task(sc->sc_udev, &sc->sc_it_task);
a379 8
/* degrade the sensor */
void
udcf_it_intr(void *xsc)
{
	struct udcf_softc *sc = xsc;
	usb_add_task(sc->sc_udev, &sc->sc_it_task);
}

d642 1
a642 1
/* invalidate timedelta */
d644 1
a644 1
udcf_it_probe(void *xsc)
a649 2

	DPRINTF(("\ndegrading sensor state\n"));
@


1.38
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.37 2007/06/12 16:26:36 mbalmer Exp $ */
a173 1
	char				*devinfop;
d181 1
a181 1
		DPRINTF(("\n%s: failed to set configuration, err=%s\n",
d187 1
a187 1
		DPRINTF(("\n%s: failed to get interface, err=%s\n",
a190 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.37
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.36 2007/06/10 14:49:00 mbalmer Exp $ */
d136 16
a151 1
USB_DECLARE_DRIVER(udcf);
@


1.36
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.35 2007/06/10 10:53:48 mbalmer Exp $ */
d692 1
a692 1
udcf_activate(device_ptr_t self, enum devact act)
@


1.35
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.34 2007/06/06 19:25:49 mk Exp $ */
d168 1
a168 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d174 1
a174 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d179 1
a179 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d200 1
a200 1
	strlcpy(sc->sc_sensordev.xname, USBDEVNAME(sc->sc_dev),
@


1.34
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.33 2007/05/27 04:00:25 jsg Exp $ */
d252 1
a252 1
	    USBDEV(sc->sc_dev));
d338 1
a338 1
	    USBDEV(sc->sc_dev));
@


1.33
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.32 2007/04/21 20:17:04 art Exp $ */
d66 1
a66 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.32
log
@Back out last. the world is not i386.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.30 2007/03/22 16:55:31 deraadt Exp $ */
d138 2
a139 1
USB_MATCH(udcf)
d141 1
a141 1
	USB_MATCH_START(udcf, uaa);
d151 2
a152 1
USB_ATTACH(udcf)
d154 2
a155 1
	USB_ATTACH_START(udcf, sc, uaa);
d179 1
a179 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d307 1
a307 1
	USB_ATTACH_SUCCESS_RETURN;
a311 1
	USB_ATTACH_ERROR_RETURN;
d314 2
a315 1
USB_DETACH(udcf)
@


1.31
log
@Remove unused header files.
@
text
@d4 1
a4 1
 * Copyright (c) 2006, 2007 Marc Balmer <mbalmer@@openbsd.org>
d22 7
@


1.30
log
@split userland & kernel struct sensor/sensordev so that the addition
of new fields in the future is less disruptive.  This is done similar
to how struct proc is handled for ps(1).  ok jmc (man page changes)
tested fkr simon, and more suggestions from millert
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.29 2007/01/02 22:40:22 mbalmer Exp $ */
d4 1
a4 1
 * Copyright (c) 2006 Marc Balmer <mbalmer@@openbsd.org>
a21 7
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/poll.h>
@


1.29
log
@return is not a function.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.28 2006/12/23 17:46:39 deraadt Exp $ */
d101 1
a101 1
	struct sensor		sc_sensor;
d103 1
a103 1
	struct sensor		sc_skew;	/* recv vs local skew */
d105 1
a105 1
	struct sensordev	sc_sensordev;
@


1.28
log
@adapt to new two-level sensor api; Constantine A. Murenin
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.27 2006/12/10 16:47:44 mbalmer Exp $ */
d143 1
a143 1
		return (UMATCH_NONE);
d337 1
a337 1
	return (0);
d701 1
a701 1
	return (0);
@


1.27
log
@Make sure the bit collecting is restarted after signal loss.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.26 2006/12/10 16:13:32 mbalmer Exp $ */
d105 1
d198 3
a200 2
	strlcpy(sc->sc_sensor.device, USBDEVNAME(sc->sc_dev),
	    sizeof(sc->sc_sensor.device));
d206 2
a207 1
	sensor_add(&sc->sc_sensor);
a208 2
	strlcpy(sc->sc_skew.device, USBDEVNAME(sc->sc_dev),
	    sizeof(sc->sc_skew.device));
d215 1
a215 1
	sensor_add(&sc->sc_skew);
d217 3
d327 1
a327 4
	sensor_del(&sc->sc_sensor);
#ifdef UDCF_DEBUG
	sensor_del(&sc->sc_skew);
#endif
@


1.26
log
@restart collecting bits immediately after a parity error, i.e. use the frame
immediately following the corrupt one; there is no no need to skip it by
waiting for the next minute gap and the sensor value has valid data one
minute earlier than before.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.25 2006/12/10 15:42:12 mbalmer Exp $ */
d638 1
@


1.25
log
@Re-arm signal loss detection only after we received a bit, not in itself.  This
prevents the signal loss function from being called  repeatedly when we have
no signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.24 2006/12/10 14:39:05 mbalmer Exp $ */
a494 1

a504 1

d616 1
a616 1
		sc->sc_sync = 1;
@


1.24
log
@Faster synchronization after an unexpected minute gap.
Only look at the skew value if it is != 0.
Remove some dead code.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.23 2006/12/06 11:44:53 mbalmer Exp $ */
d420 1
a420 1
			DPRINTF(("synchronized, collecting bits\n"));
a639 1
	timeout_add(&sc->sc_sl_to, t_wait + t_sl);
@


1.23
log
@When compiled with UDCF_DEBUG, only output the bits received when
udcfdebug > 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.22 2006/12/05 15:23:16 mbalmer Exp $ */
d55 2
a56 2
/* skew tolerance of received time diff vs. measured time diff in percent. */
#define SKEW_TOLERANCE	5
d516 1
a516 6
		sc->sc_sync = 1;
#if 0
		timeout_add(&sc->sc_to, t_wait);
		timeout_add(&sc->sc_sl_to, t_wait + t_sl);
		sc->sc_last_mg = 0;
#endif
d577 1
a577 1
		DPRINTF((r_bit ? ", reserve antenna" : ""));
d595 1
a595 1
			if (skew * 100LL / tdiff_local > SKEW_TOLERANCE) {
d652 1
a652 1
	DPRINTF(("\ndegrading sensor state"));
@


1.22
log
@Add code to detect (and eliminate) statistical outliers.  Tested by me and
naddy; many thanks to naddy for continous testing and feedback during the
last weeks.

ok naddy
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.21 2006/11/15 07:10:14 mbalmer Exp $ */
d484 1
a484 1
	DPRINTF((data & 0x01 ? "0" : "1"));
@


1.21
log
@Fix an integer type promotion that can lead to wrong offsets on 64 bit arches.
Problem and solution found by Christian "Naddy" Weisgerber <naddy@@openbsd.org>,
thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.20 2006/10/28 09:26:46 mbalmer Exp $ */
d55 3
d96 1
a96 1
	time_t			sc_current;	/* current time information */
d98 3
a100 1

d102 3
d193 3
d205 11
a215 1

d324 3
a326 1

a447 2
		sc->sc_tbits = 0LL;
		sc->sc_mask = 1LL;
d497 3
a509 1
		timeout_add(&sc->sc_to, t_mgsync);	/* re-sync in 450 ms */
d511 1
a511 2
		sc->sc_last_mg = time_second;
		return;
d515 1
a515 1
		DPRINTF(("unexpected gap, resync\n"));
d517 1
d521 2
a522 1
		return;
d561 6
a566 1
		/* Decode valid time */
a570 1
		ymdhm.dt_year = 2000 + FROMBCD(year_bits);
d574 1
d580 1
a580 1
		    ymdhm.dt_day, ymdhm.dt_mon + 1, ymdhm.dt_year,
d586 35
d622 1
a622 1
		DPRINTF(("parity error, resync\n"));
d625 2
a627 1
	sc->sc_minute = 1;
d629 2
d666 1
a666 1
	} else
d668 2
@


1.20
log
@- Use better names for the variables containing the timeouts in Hz instead of
just t1-t10.
- Remove some unused variables.
- Restructure some functions to remove some levels of indentation.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.19 2006/10/27 11:28:40 mbalmer Exp $ */
d406 2
a407 2
			sc->sc_sensor.value = (now.tv_sec - sc->sc_current)
			    * 1000000000 + now.tv_nsec;
@


1.19
log
@udcf(4) degraded the sensor status from OK to WARNING on the first receiption
error, which is to fast as this does not give ntpd the opportunity to use the
sensor value.

If we decode a valid time information, it has to be available to applications
for some minimal time.  I choose a value of 5 minutes.  If we do not receive
any new valid time information during this period, the sensor will be degraded
to WARNING, and after another fifteen minutes it will be further degraded to
CRITICAL.

"makes sense to me" henning@@, "sure" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.18 2006/10/14 22:41:21 mbalmer Exp $ */
d86 1
a86 1
	int			sc_sync;	/* 1 during sync to DCF77 */
d99 13
a111 1
static int t1, t2, t3, t4, t5, t6, t7, t8, t9, t10;	/* timeouts in hz */
a148 3
#ifdef UDCF_DEBUG
	char 				*devname = USBDEVNAME(sc->sc_dev);
#endif
d156 1
a156 1
		    devname, usbd_errstr(err)));
d162 1
a162 1
		    devname, usbd_errstr(err)));
a241 1

d244 1
a244 1
	t1 = tvtohz(&t);
d247 1
a247 1
	t4 = tvtohz(&t);
d249 2
a250 2
	t.tv_usec = 900000L;
	t7 = tvtohz(&t);
d254 1
a254 1
	t2 = tvtohz(&t);
d258 1
a258 1
	t3 = tvtohz(&t);
d261 1
a261 4
	t5 = tvtohz(&t);

	t.tv_sec = 8L;
	t6 = tvtohz(&t);
d264 1
a264 1
	t8 = tvtohz(&t);
d267 1
a267 1
	t10 = tvtohz(&t);
d271 1
a271 1
	t9 = tvtohz(&t);
d274 1
a274 1
	timeout_add(&sc->sc_to, t3);
d276 2
a277 2
	/* Detect signal loss in 5 sec */
	timeout_add(&sc->sc_sl_to, t5);
a301 1

d348 1
a348 1
/* degrade the sensor if no new time received for >= DPERIOD seconds. */
d365 1
a365 1
 * udcf_probe runs in a process context.  If Bit 0 is set, the transmitter
d387 28
a414 33
	} else if (sc->sc_level == 1)	{ /* Begin of a second */
		sc->sc_level = 0;
		if (sc->sc_minute == 1) {
			if (sc->sc_sync) {
				DPRINTF(("synchronized, collecting bits\n"));
				sc->sc_sync = 0;
				if (sc->sc_sensor.status == SENSOR_S_UNKNOWN)
					sc->sc_clocktype = -1;
			} else {
				/* provide the timedelta */
				microtime(&sc->sc_sensor.tv);
				nanotime(&now);
				sc->sc_current = sc->sc_next;
				sc->sc_sensor.value =
				    (now.tv_sec - sc->sc_current)
				    * 1000000000 + now.tv_nsec;

				/* set the clocktype and make sensor valid */
				if (sc->sc_sensor.status == SENSOR_S_UNKNOWN) {
					strlcpy(sc->sc_sensor.desc,
					    sc->sc_clocktype ?
					    clockname[CLOCK_HBG] :
					    clockname[CLOCK_DCF77],
					    sizeof(sc->sc_sensor.desc));
				}
				sc->sc_sensor.status = SENSOR_S_OK;

				/*
				 * if no valid time information is received
				 * during the next 5 minutes, the sensor state
				 * will be degraded to SENSOR_S_WARN
				 */
				timeout_add(&sc->sc_it_to, t8);
d416 8
a423 3
			sc->sc_tbits = 0LL;
			sc->sc_mask = 1LL;
			sc->sc_minute = 0;
d425 4
d430 1
a430 5
		timeout_add(&sc->sc_to, t7);	/* Begin resync in 900 ms */

		/* No clock and bit detection during sync */
		if (!sc->sc_sync) {
			timeout_add(&sc->sc_bv_to, t1);	/* bit in 150 ms */
d432 8
a439 7
			/* detect clocktype in 250 ms if not known yet */

			if (sc->sc_clocktype == -1)
				timeout_add(&sc->sc_ct_to, t9);
		}
		timeout_add(&sc->sc_mg_to, t2);	/* minute gap in 1500 ms */
		timeout_add(&sc->sc_sl_to, t3);	/* signal loss in 3 sec */
d441 2
d486 1
a486 1
		timeout_add(&sc->sc_to, t4);	/* re-sync in 450 ms */
d489 68
d558 2
a559 76
		if (time_second - sc->sc_last_mg < 57) {
			DPRINTF(("unexpected gap, resync\n"));
			sc->sc_sync = 1;
			timeout_add(&sc->sc_to, t5);
			timeout_add(&sc->sc_sl_to, t6);
			sc->sc_last_mg = 0;
		} else {
			/* Extract bits w/o parity */
			m_bit = sc->sc_tbits & 1;
			r_bit = sc->sc_tbits >> 15 & 1;
			a1_bit = sc->sc_tbits >> 16 & 1;
			z1_bit = sc->sc_tbits >> 17 & 1;
			z2_bit = sc->sc_tbits >> 18 & 1;
			a2_bit = sc->sc_tbits >> 19 & 1;
			s_bit = sc->sc_tbits >> 20 & 1;
			p1_bit = sc->sc_tbits >> 28 & 1;
			p2_bit = sc->sc_tbits >> 35 & 1;
			p3_bit = sc->sc_tbits >> 58 & 1;

			minute_bits = sc->sc_tbits >> 21 & 0x7f;	
			hour_bits = sc->sc_tbits >> 29 & 0x3f;
			day_bits = sc->sc_tbits >> 36 & 0x3f;
			wday = (sc->sc_tbits >> 42) & 0x07;
			month_bits = sc->sc_tbits >> 45 & 0x1f;
			year_bits = sc->sc_tbits >> 50 & 0xff;

			/* Validate time information */

			p1 = (parity >> (minute_bits & 0x0f) & 1) ^
			    (parity >> (minute_bits >> 4) & 1);

			p2 = (parity >> (hour_bits & 0x0f) & 1) ^
			    (parity >> (hour_bits >> 4) & 1);

			p3 = (parity >> (day_bits & 0x0f) & 1) ^
			    (parity >> (day_bits >> 4) & 1) ^
			    ((parity >> wday) & 1) ^
			    (parity >> (month_bits & 0x0f) & 1) ^
			    (parity >> (month_bits >> 4) & 1) ^
			    (parity >> (year_bits & 0x0f) & 1) ^
			    (parity >> (year_bits >> 4) & 1);

			if (m_bit == 0 && s_bit == 1 &&
			    p1 == p1_bit && p2 == p2_bit &&
			    p3 == p3_bit &&
			    (z1_bit ^ z2_bit)) {

				/* Decode valid time */
				ymdhm.dt_min = FROMBCD(minute_bits);
				ymdhm.dt_hour = FROMBCD(hour_bits);
				ymdhm.dt_day = FROMBCD(day_bits);
				ymdhm.dt_mon = FROMBCD(month_bits);
				ymdhm.dt_year = 2000 + FROMBCD(year_bits);
				ymdhm.dt_sec = 0;

				sc->sc_next = clock_ymdhms_to_secs(&ymdhm);

				/* convert to coordinated universal time */
				sc->sc_next -= z1_bit ? 7200 : 3600;

				DPRINTF(("\n%02d.%02d.%04d %02d:%02d:00 %s",
				    ymdhm.dt_day, ymdhm.dt_mon + 1,
				    ymdhm.dt_year, ymdhm.dt_hour,
				    ymdhm.dt_min, z1_bit ? "CEST" : "CET"));
				DPRINTF((r_bit ? ", reserve antenna" : ""));
				DPRINTF((a1_bit ? ", dst chg ann." : ""));
				DPRINTF((a2_bit ? ", leap sec ann." : ""));
				DPRINTF(("\n"));
			} else {
				DPRINTF(("parity error, resync\n"));
				sc->sc_sync = 1;
			}
			timeout_add(&sc->sc_to, t4);	/* re-sync in 450 ms */
			sc->sc_minute = 1;
			sc->sc_last_mg = time_second;
		}
d561 3
d577 2
a578 2
	timeout_add(&sc->sc_to, t5);
	timeout_add(&sc->sc_sl_to, t6);
d595 1
a595 1
		 * further degrade in 15 minutes if we dont receive and new
d598 1
a598 1
		timeout_add(&sc->sc_it_to, t10);
a633 1

@


1.18
log
@Apply some formatting.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.17 2006/10/11 13:06:35 mbalmer Exp $ */
d52 2
a53 1
#define DPERIOD		((long) 15 * 60)	/* degrade period, 15 min */
d99 1
a99 1
static int	t1, t2, t3, t4, t5, t6, t7, t8, t9;	/* timeouts in hz */
d258 1
a258 1
	t.tv_sec = DPERIOD;
d261 3
d352 1
a352 1
/* detect the cloc type (DCF77 or HBG) */
d410 6
a415 1
				timeout_del(&sc->sc_it_to);
a485 4
			if (sc->sc_sensor.status == SENSOR_S_OK) {
				sc->sc_sensor.status = SENSOR_S_WARN;
				timeout_add(&sc->sc_it_to, t8);
			}
a552 5
				
				if (sc->sc_sensor.status == SENSOR_S_OK) {
					sc->sc_sensor.status = SENSOR_S_WARN;
					timeout_add(&sc->sc_it_to, t8);
				}
a572 4
	if (sc->sc_sensor.status == SENSOR_S_OK) {
		sc->sc_sensor.status = SENSOR_S_WARN;
		timeout_add(&sc->sc_it_to, t8);
	}
d586 1
a586 1
	DPRINTF(("\ndegrading sensor to state critical"));
d588 9
a596 1
	sc->sc_sensor.status = SENSOR_S_CRIT;
@


1.17
log
@Make the timedelta sensor appear right when a device is plugged-in, with a
status of SENSOR_S_UNKNOWN.  Do not set the SENSOR_FINVALID bit, sysctl
hw.sensors does not list sensors with this flags set and we want to the sensor
when the device is present.

ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.16 2006/06/23 06:27:11 miod Exp $ */
d98 1
a98 2
static int	t1, t2, t3, t4, t5, t6, t7, t8;	/* timeouts in hz */
static int	t9;
a185 1

a388 1

a396 1

a485 1

a525 1

a535 1

@


1.16
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.15 2006/06/19 16:23:32 mbalmer Exp $ */
d181 3
a183 1
	sc->sc_sensor.flags = SENSOR_FINVALID;
a406 1
					sc->sc_sensor.flags &= ~SENSOR_FINVALID;
@


1.15
log
@remove the no longer needed time calculations now that we have them in
sys/kern/clock_subr.c
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.12 2006/06/12 09:51:09 mbalmer Exp $ */
d631 1
a631 1
		return (EOPNOTSUPP);
@


1.14
log
@move clock_subr.c to a better place, and now it is always in the kernel
so that things can use it; tested on all architectures; ok kettenis
@
text
@a31 1
#include <dev/clock_subr.h>
@


1.13
log
@udcf(4) no longer needs the file sys/dev/clock_subr.c to be compiled and linked
to the kernel, the two functions it used from this file are now included in
the driver itself (like in nmea(4)).  udcf(4) can now be enabled to the zaurus,
too.  in fact on all arches that have USB support.
@
text
@d32 1
a45 12
/* Traditional POSIX base year */
#define	POSIX_BASE_YEAR	1970

static inline int leapyear(int year);
#define FEBRUARY	2
#define	days_in_year(a) 	(leapyear(a) ? 366 : 365)
#define	days_in_month(a)	(month_days[(a) - 1])

static const int month_days[12] = {
	31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31
};

a115 5
#define FROMBCD(x)	(((x) >> 4) * 10 + ((x) & 0xf))
static inline int leapyear(int year);
int	udcf_ymdhm_to_secs(int y, int mon, int d, int h, int m, time_t *secs);


d463 1
a463 1
	int			 year, month, day, hour, minute;
d532 6
a537 5
				minute = FROMBCD(minute_bits);
				hour = FROMBCD(hour_bits);
				day = FROMBCD(day_bits);
				month = FROMBCD(month_bits);
				year = 2000 + FROMBCD(year_bits);
d539 1
a539 2
				if (!udcf_ymdhm_to_secs(year, month, day,
				    hour, minute, &sc->sc_next)) {
d541 1
a541 1
					/* convert to UTC */
d543 1
a543 6
					sc->sc_next -= z1_bit ? 7200 : 3600;
				} else {
					sc->sc_sensor.status = SENSOR_S_WARN;
					timeout_add(&sc->sc_it_to, t8);
					sc->sc_sync = 1;
				}
a637 101
	return (0);
}

/*
 * the leapyear() and udcf_ymdhms_to_secs() functions to calculate the number
 * of seconds since the epoch for a certain date are from sys/dev/clock_subr.c,
 * the following copyright applies to these functions:
 */
/*
 * Copyright (c) 1988 University of Utah.
 * Copyright (c) 1982, 1990, 1993
 *	The Regents of the University of California.  All rights reserved.
 *
 * This code is derived from software contributed to Berkeley by
 * the Systems Programming Group of the University of Utah Computer
 * Science Department.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/*
 * This inline avoids some unnecessary modulo operations
 * as compared with the usual macro:
 *   ( ((year % 4) == 0 &&
 *      (year % 100) != 0) ||
 *     ((year % 400) == 0) )
 * It is otherwise equivalent.
 */
static inline int
leapyear(int year)
{
	int rv = 0;

	if ((year & 3) == 0) {
		rv = 1;
		if ((year % 100) == 0) {
			rv = 0;
			if ((year % 400) == 0)
				rv = 1;
		}
	}
	return (rv);
}

/* convert year, month, day, hour, minute to seconds since the epoch */
int
udcf_ymdhm_to_secs(int year, int month, int day, int hour, int minute,
   time_t *secs)
{
	int i, days;
	int leap;

	if (month < 1 || month > 12)
		return (-1);

	days = days_in_month(month);
	leap = leapyear(year);
	if (month == FEBRUARY && leap)
		days++;
	if (day < 1 || day > days)
		return (-1);

	/*
	 * Compute days since start of time
	 * First from years, then from months.
	 */
	days = 0;
	for (i = POSIX_BASE_YEAR; i < year; i++)
		days += days_in_year(i);
	if (leap && month > FEBRUARY)
		days++;

	/* Months */
	for (i = 1; i < month; i++)
	  	days += days_in_month(i);
	days += (day - 1);

	/* convert to seconds. */
	*secs = days * 86400L + hour * 3600L + minute * 60L;
@


1.12
log
@Typos in comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.11 2006/06/05 10:06:12 mbalmer Exp $ */
a31 1
#include <dev/clock_subr.h>
d45 12
d127 5
d479 1
a479 1
	struct clock_ymdhms	 ymdhm;
d548 5
a552 6
				ymdhm.dt_min = FROMBCD(minute_bits);
				ymdhm.dt_hour = FROMBCD(hour_bits);
				ymdhm.dt_day = FROMBCD(day_bits);
				ymdhm.dt_mon = FROMBCD(month_bits);
				ymdhm.dt_year = 2000 + FROMBCD(year_bits);
				ymdhm.dt_sec = 0;
d554 2
a555 1
				sc->sc_next = clock_ymdhms_to_secs(&ymdhm);
d557 1
a557 1
				/* convert to coordinated universal time */
d559 6
a564 1
				sc->sc_next -= z1_bit ? 7200 : 3600;
d659 101
@


1.11
log
@cleanup.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.10 2006/06/04 09:52:40 mbalmer Exp $ */
d389 1
a389 1
				/* provide the time delta */
d588 1
a588 1
/* invalidate time delta */
@


1.10
log
@- ntpd no longer needs the NTP identifier as part of a timedelta sensor
  description.
- create the timedelta sensors as early as possible, but mark them invalid
  as long as there is no real data.
- update docs accordingly
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.9 2006/05/28 18:52:16 mbalmer Exp $ */
a309 1

a317 1

a325 1

a333 1

a341 1

a349 1

a360 1

a433 1

a457 1

a569 1

a588 1

a602 1

@


1.9
log
@Change the timedelta sensor descritpion so that the first four bytes contain
the NTP identifier (filled with spaces), followed by a space and the station
name (which might be the same as the NTP identifier).

All timedelta sensor have to follow this scheme as OpenNTPD needs it.

Requested by henning.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.8 2006/05/27 21:32:21 mbalmer Exp $ */
d59 2
a60 2
	"DCF  DCF77",
	"HBG  HBG" };
d182 2
d295 1
a295 2
	if (sc->sc_sensor.status != SENSOR_S_UNKNOWN)
		sensor_del(&sc->sc_sensor);
d413 1
a413 3
					DPRINTF(("add timedelta sensor for %s\n",
						sc->sc_sensor.desc));
					sensor_add(&sc->sc_sensor);
@


1.8
log
@There is no longer the need to create INVALID sensors on stock, the sensor
framework will create hotplug events for sensor addition/deletion. ntpd
will catch these events.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.7 2006/05/27 18:22:04 mbalmer Exp $ */
d59 2
a60 2
	"DCF77",
	"HBG" };
@


1.7
log
@When the device is attached, immediately create the timedelta sensor with the
SENSOR_FINVALID flag set and without a description.  We do not need a dummy
description as a sensor with the FINVALID flags set will not show up or be used
anyways.  It's merely an indication to applications that there is a sensor that
will eventually have a correct value.

The SENSOR_FINVALID flag is removed and the description is set to the proper
clockname as soon as we have received the first valid time information.

This enables ntpd to check for hotplug events and rescan the list of timedelta
sensors after a hotplug event.

discussed with deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.6 2006/04/27 08:22:56 mbalmer Exp $ */
a181 2
	sc->sc_sensor.flags = SENSOR_FINVALID;
	sensor_add(&sc->sc_sensor);
d414 1
a414 2
					sc->sc_sensor.flags &=
					    ~SENSOR_FINVALID;
@


1.6
log
@cope with recent changes in the sensor framework

- provide the timedelta in nanoseconds
- provide a timestamp in the sensor

support for HBG and DCF77:

- detect clocktype (DCF77 or HBG) and set it once is the sensor description
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.5 2006/04/22 22:12:31 mbalmer Exp $ */
d182 2
d406 1
a406 1
				/* set the clocktype */
d416 2
a417 1
					sensor_add(&sc->sc_sensor);
@


1.5
log
@Simplify time calculations.

help and ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.4 2006/04/21 16:13:14 mbalmer Exp $ */
a45 2
#define SECSPERDAY	((long) 60 * 60 * 24)

d53 9
a65 1
	int			sc_refcnt;
d76 1
d81 1
d85 1
d93 2
a94 2
	struct timeval		sc_last;	/* when we last had a valid time */
	time_t			sc_next;	/* the time to become valid next */
d100 1
d109 1
d114 1
d168 1
d175 1
d177 1
a179 2
	
	strlcpy(sc->sc_sensor.desc, "DCF77", sizeof(sc->sc_sensor.desc));
d221 1
d228 1
d256 1
a256 1
	t.tv_sec = SECSPERDAY;
d259 4
d269 1
a269 3
	/* Register the clock with kernel */

	sensor_add(&sc->sc_sensor);
a280 1
	int			 s;
d288 2
d293 2
a294 1
	sensor_del(&sc->sc_sensor);
d300 2
a301 7

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(USBDEV(sc->sc_dev));
	}
	splx(s);
d344 1
a344 4
/*
 * invalidate time delta in the sensor if we did not receive time for
 * more then MAXVALID seconds.
 */
d353 9
d371 1
d392 2
d397 19
a415 3
				microtime(&sc->sc_last);
				sc->sc_sensor.value = (sc->sc_last.tv_sec - sc->sc_next)
				    * 1000 + sc->sc_last.tv_usec / 1000;
a417 2
				/* retrigger the invalidation timer */

a418 1
				timeout_add(&sc->sc_it_to, t8);
d427 1
a427 1
		/* No bit detection during sync */
d429 6
a434 2
			timeout_del(&sc->sc_bv_to);
			timeout_add(&sc->sc_bv_to, t1);	/* Detect bit in 150 ms */
d436 2
a437 4
		timeout_del(&sc->sc_mg_to);
		timeout_add(&sc->sc_mg_to, t2);	/* detect minute gap in 1500 ms */
		timeout_del(&sc->sc_sl_to);
		timeout_add(&sc->sc_sl_to, t3);	/* Detect signal loss in 3 sec */
a483 1
		timeout_del(&sc->sc_to);
d491 4
a494 1
			timeout_del(&sc->sc_to);
a495 1
			timeout_del(&sc->sc_sl_to);
d555 4
a558 4
				DPRINTF(("\n%02d.%02d.%04d %02d:%02d:00 UTC",
				    ymdhm.dt_day, ymdhm.dt_mon + 1, ymdhm.dt_year,
				    ymdhm.dt_hour, ymdhm.dt_min));
				DPRINTF((z1_bit ? ", dst" : ""));
d560 2
a561 2
				DPRINTF((a1_bit ? ", dst chg announced" : ""));
				DPRINTF((a2_bit ? ", leap sec announced" : ""));
d565 5
a571 1
			timeout_del(&sc->sc_to);
d589 1
a589 1
	DPRINTF(("signal loss, resync\n"));
d591 4
a594 1
	timeout_del(&sc->sc_to);
a595 1
	timeout_del(&sc->sc_sl_to);
d609 27
a635 3
	DPRINTF(("invalidating time delta\n"));
	sc->sc_sensor.status = SENSOR_S_UNKNOWN;
	sc->sc_sensor.value = 0LL;
@


1.4
log
@make udcf work as a SENSOR_TIMEDELTA type sensor.  The sensor value is the
offset between the time of the device and the localtime in mSec.

the sensor status is set to OK once we received a complete and valid time
information.

help and ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.2 2006/04/20 10:12:00 mbalmer Exp $ */
d32 1
d44 1
a44 1
#define DPRINTF(x) DPRINTFN(0, x)
d46 1
a46 20
#define SECSPERMIN	60
#define MINSPERHOUR	60
#define HOURSPERDAY	24
#define DAYSPERWEEK	7
#define DAYSPERNYEAR	365
#define DAYSPERLYEAR	366
#define SECSPERHOUR	(SECSPERMIN * MINSPERHOUR)
#define SECSPERDAY	((long) SECSPERHOUR * HOURSPERDAY)
#define MONSPERYEAR	12
#define BASE_YEAR	2006
#define JAN1_2006	1136073600L	/* 2006/01/01 00:00:00 UTC */
#define LEAPS_2006	486		/* num of leap years till 2006 */

#define isleap(y)	(((y) % 4) == 0 && (((y) % 100) != 0 || ((y) % 400) == 0))
#define leaps(y)	((y) / 4 - (y) / 100 + (y) / 400 - LEAPS_2006)

static const int	mon_lengths[2][12] = {
	{ 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 },
	{ 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 }
};
d69 1
d73 1
d84 2
a85 1
	long			sc_next;	/* the time to become valid next */
d90 1
a90 1
static int	t1, t2, t3, t4, t5, t6, t7;	/* timeouts in hz */
d98 1
d102 1
d207 1
d213 1
d241 3
d331 12
a350 1
	struct timeval		 now;
d374 3
a376 3
				microtime(&now);
				sc->sc_sensor.value = (now.tv_sec - sc->sc_next) * 1000 +
				    now.tv_usec / 1000;
d378 5
d435 1
a435 1
	int			 wday;
d437 1
a437 1
	int			 month_bits, year_bits;
a441 3
	int			 year, mon, mday, hour, min;
	int			 nyears, lyears, days, leap;
	int			 n;
a452 1
			sc->sc_sensor.status = SENSOR_S_UNKNOWN;
d503 8
a510 10
				min = (minute_bits & 0x0f) +
				    (minute_bits >> 4) * 10;
				hour = (hour_bits & 0x0f) +
				    (hour_bits >> 4) * 10;
				mday = (day_bits & 0x0f) +
				    (day_bits >> 4) * 10;
				mon = (month_bits & 0x0f) +
				    (month_bits >> 4) * 10 - 1;
				year = 2000 + (year_bits & 0x0f) +
				    (year_bits >> 4) * 10;
a512 15
				hour -= z1_bit ? 2 : 1;
				if (hour < 0)
					hour += 24;

				if (year > BASE_YEAR)
					lyears = leaps(year - 1);
				else
					lyears = 0;
				nyears = year - BASE_YEAR - lyears;
				leap = isleap(year);

				days = nyears * DAYSPERNYEAR + lyears * DAYSPERLYEAR;
				for (n = 0; n < mon; n++)
					days += mon_lengths[leap][n];
				days += mday - 1;
d514 1
a514 2
				sc->sc_next = JAN1_2006 + days * SECSPERDAY +
				    hour * SECSPERHOUR + min * SECSPERMIN;
d517 2
a518 2
				    mday, mon + 1, year, hour,
				    min));
a546 1
	sc->sc_sensor.status = SENSOR_S_UNKNOWN;
d552 15
@


1.3
log
@open/close/cdevsw code goes bye bye; ok mbalber
@
text
@d30 1
d45 21
d73 28
a100 11
/* UTC time information */
struct utc {
	int utc_sec;
	int utc_min;
	int utc_hour;
	int utc_mday;
	int utc_mon;
	int utc_year;
	int utc_wday;
	struct timeval utc_timestamp;
};
d102 1
a102 30
struct udcf_softc {
	USBBASEDEVICE		 sc_dev;	/* base device */
	usbd_device_handle	 sc_udev;	/* USB device */
	usbd_interface_handle	 sc_iface;	/* data interface */
	int			 sc_refcnt;
	u_char			 sc_dying;	/* disconnecting */

	struct timeout		 sc_to;
	struct usb_task		 sc_task;

	struct timeout		 sc_bv_to;	/* bit-value detect */
	struct timeout		 sc_db_to;	/* debounce */
	struct timeout		 sc_mg_to;	/* minute-gap detect */
	struct timeout		 sc_sl_to;	/* signal-loss detect */
	struct usb_task		 sc_bv_task;
	struct usb_task		 sc_mg_task;
	struct usb_task		 sc_sl_task;

	usb_device_request_t	 sc_req;

	int			 sc_sync;	/* 1 during sync to DCF77 */
	u_int64_t		 sc_mask;	/* 64 bit mask */
	u_int64_t		 sc_tbits;	/* Time bits */
	int			 sc_minute;
	int			 sc_level;
	time_t			 sc_last_mg;

	struct utc		 sc_utc[2];	/* Broken down time */
	int			 sc_utc_valid;	/* index to sc_utc */
	int			 sc_utc_next;	/* index to sc_utc */
d175 7
a181 2
	sc->sc_utc_valid = -1;	/* no valid time yet */
	sc->sc_utc_next = 0;
d258 3
d281 4
d347 1
a347 1
	struct utc		*utc;
d369 1
a369 7
				/* provide the time */

				utc = &sc->sc_utc[sc->sc_utc_next];

				microtime(&utc->utc_timestamp);
				sc->sc_utc_valid = sc->sc_utc_next;
				sc->sc_utc_next = 1 - sc->sc_utc_valid;
d371 4
a425 1
	struct utc		*utc;
d434 3
d448 1
d499 1
a499 3
				utc = &sc->sc_utc[sc->sc_utc_next];
				utc->utc_sec = 0;
				utc->utc_min = (minute_bits & 0x0f) +
d501 1
a501 1
				utc->utc_hour = (hour_bits & 0x0f) +
d503 1
a503 1
				utc->utc_mday = (day_bits & 0x0f) +
d505 1
a505 1
				utc->utc_mon = (month_bits & 0x0f) +
d507 1
a507 1
				utc->utc_year = 100 + (year_bits & 0x0f) +
a508 1
				utc->utc_wday = wday;
d511 22
a532 8
				utc->utc_hour -= z1_bit ? 2 : 1;
				if (utc->utc_hour < 0)
					utc->utc_hour += 24;

				DPRINTF(("\n%d %02d.%02d.%04d %02d:%02d:00 UTC",
				    utc->utc_wday, utc->utc_mday, utc->utc_mon + 1,
				    1900 + utc->utc_year, utc->utc_hour,
				    utc->utc_min));
d561 1
@


1.2
log
@- remove the 'needs-flag' from the udcf entry in files.usb and the #ifdef NUDCF
  idom in udcf.c
- declare t1 to t7 as static to prevent the risk of name clashes
- add two missing function prototypes

help and ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: udcf.c,v 1.1 2006/04/19 21:12:49 mbalmer Exp $ */
a64 1

a65 1

a66 1

a106 3
int	udcfopen(dev_t, int, int, usb_proc_ptr);
int	udcfclose(dev_t, int, int, usb_proc_ptr);

a253 1
	int			 maj, mn;
a274 10
	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == udcfopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	DPRINTF(("udcf_detach: maj=%d mn=%d\n", maj, mn));
	vdevgone(maj, mn, mn, VCHR);

a546 27
	return (0);
}

int
udcfopen(dev_t dev, int flag, int mode, usb_proc_ptr tp)
{
	int			 unit = minor(dev);
	struct udcf_softc	*sc;

	if (unit >= udcf_cd.cd_ndevs)
		return (ENXIO);
	sc = udcf_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	if (sc->sc_dying)
		return (EIO);

	if (ISSET(sc->sc_dev.dv_flags, DVF_ACTIVE) == 0)
		return (ENXIO);

	return (0);
}

int
udcfclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
{
@


1.1
log
@Driver to decode the DCF77 time code using a USB attached Gude Expert
mouseCLOCK device; without a mechanism to pass data out.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a35 3
#include "udcf.h"

#if NUDCF > 0
d98 1
a98 1
int	t1, t2, t3, t4, t5, t6, t7;	/* timeouts in hz */
d110 3
a592 2

#endif /* NUDCF > 0 */
@

