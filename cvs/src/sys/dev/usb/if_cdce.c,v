head	1.74;
access;
symbols
	OPENBSD_6_1:1.73.0.4
	OPENBSD_6_1_BASE:1.73
	OPENBSD_6_0:1.70.0.4
	OPENBSD_6_0_BASE:1.70
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.62.0.2
	OPENBSD_5_7_BASE:1.62
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.59.0.4
	OPENBSD_5_5_BASE:1.59
	OPENBSD_5_4:1.54.0.2
	OPENBSD_5_4_BASE:1.54
	OPENBSD_5_3:1.51.0.6
	OPENBSD_5_3_BASE:1.51
	OPENBSD_5_2:1.51.0.4
	OPENBSD_5_2_BASE:1.51
	OPENBSD_5_1_BASE:1.51
	OPENBSD_5_1:1.51.0.2
	OPENBSD_5_0:1.50.0.2
	OPENBSD_5_0_BASE:1.50
	OPENBSD_4_9:1.49.0.2
	OPENBSD_4_9_BASE:1.49
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.41.0.2
	OPENBSD_4_4_BASE:1.41
	OPENBSD_4_3:1.39.0.2
	OPENBSD_4_3_BASE:1.39
	OPENBSD_4_2:1.36.0.2
	OPENBSD_4_2_BASE:1.36
	OPENBSD_4_1:1.23.0.2
	OPENBSD_4_1_BASE:1.23
	OPENBSD_4_0:1.19.0.4
	OPENBSD_4_0_BASE:1.19
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.10.0.2
	OPENBSD_3_8_BASE:1.10
	OPENBSD_3_7:1.8.0.2
	OPENBSD_3_7_BASE:1.8
	OPENBSD_3_6:1.4.0.4
	OPENBSD_3_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.74
date	2017.04.21.09.42.53;	author mpi;	state Exp;
branches;
next	1.73;
commitid	NMqtgTe2gIn76Kr5;

1.73
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.72;
commitid	VyLWTsbepAOk7VQM;

1.72
date	2016.10.12.21.51.11;	author fcambus;	state Exp;
branches;
next	1.71;
commitid	IcKkOi5LKiIk7t5F;

1.71
date	2016.09.26.07.09.32;	author fcambus;	state Exp;
branches;
next	1.70;
commitid	QWtQfaxNhXIA9i5T;

1.70
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.69;
commitid	gWZDkudwxydTq8x4;

1.69
date	2016.04.12.10.15.25;	author mpi;	state Exp;
branches;
next	1.68;
commitid	qnT2zx5QZlYWGbAS;

1.68
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.67;
commitid	B0kwmVGiD5DVx4kv;

1.67
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.66;
commitid	eYnPulzvLjDImPCa;

1.66
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.65;
commitid	pwYnMC1gOKohmeGw;

1.65
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.64;
commitid	MVWrtktB46JRxFWT;

1.64
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.63;
commitid	aqezguXMYUVIGMPW;

1.63
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.62;
commitid	p4LJxGKbi0BU2cG6;

1.62
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.61;
commitid	yM2VFFhpDTeFQlve;

1.61
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.60;
commitid	Pclvgy2Z4XV9hveD;

1.60
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.59;
commitid	b0VSac5dnnsxcDao;

1.59
date	2013.12.07.20.17.42;	author brad;	state Exp;
branches;
next	1.58;

1.58
date	2013.12.04.00.52.52;	author deraadt;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.11.12.38.16;	author pirofti;	state Exp;
branches;
next	1.55;

1.55
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.54;

1.54
date	2013.04.26.13.46.40;	author mglocker;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.52;

1.52
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2011.11.09.21.45.50;	author sthen;	state Exp;
branches;
next	1.50;

1.50
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.49;

1.49
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.47;

1.47
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.09.24.08.33.58;	author yuo;	state Exp;
branches;
next	1.45;

1.45
date	2010.03.06.17.09.31;	author mk;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2008.03.14.21.54.23;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2008.03.13.08.32.02;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.37;

1.37
date	2007.09.11.21.17.37;	author winiger;	state Exp;
branches;
next	1.36;

1.36
date	2007.07.25.21.22.20;	author claudio;	state Exp;
branches;
next	1.35;

1.35
date	2007.07.25.16.42.24;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.07.23.16.41.15;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2007.04.05.02.32.45;	author tedu;	state Exp;
branches;
next	1.23;

1.23
date	2007.02.23.01.19.15;	author drahn;	state Exp;
branches;
next	1.22;

1.22
date	2007.01.22.03.46.49;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2006.11.28.16.23.44;	author drahn;	state Exp;
branches;
next	1.20;

1.20
date	2006.11.16.23.50.16;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.18;

1.18
date	2006.05.30.22.51.53;	author pascoe;	state Exp;
branches;
next	1.17;

1.17
date	2006.05.27.21.47.55;	author pascoe;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.15;

1.15
date	2006.03.24.13.50.14;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2006.02.20.20.12.13;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.12.13.17.41.59;	author drahn;	state Exp;
branches;
next	1.11;

1.11
date	2005.09.29.01.18.05;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.9;

1.9
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2005.01.27.21.49.53;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2005.01.23.03.32.35;	author drahn;	state Exp;
branches;
next	1.6;

1.6
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.5;

1.5
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.21.15.54.54;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.07.21.15.49.43;	author dhartmei;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.21.08.00.24;	author dhartmei;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.20.20.30.09;	author dhartmei;	state Exp;
branches;
next	;


desc
@@


1.74
log
@Use ether_crc32_le() instead of a custom version.

From Hiltjo Posthuma.
@
text
@/*	$OpenBSD: if_cdce.c,v 1.73 2017/01/22 10:17:39 dlg Exp $ */

/*
 * Copyright (c) 1997, 1998, 1999, 2000-2003 Bill Paul <wpaul@@windriver.com>
 * Copyright (c) 2003 Craig Boston
 * Copyright (c) 2004 Daniel Hartmeier
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul, THE VOICES IN HIS HEAD OR
 * THE CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB Communication Device Class (Ethernet Networking Control Model)
 * http://www.usb.org/developers/devclass_docs/usbcdc11.pdf
 *
 */

#include <bpfilter.h>

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/if_cdcereg.h>

#ifdef CDCE_DEBUG
#define DPRINTFN(n, x)	do { if (cdcedebug > (n)) printf x; } while (0)
int cdcedebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x)	DPRINTFN(0, x)

int	 cdce_tx_list_init(struct cdce_softc *);
int	 cdce_rx_list_init(struct cdce_softc *);
int	 cdce_newbuf(struct cdce_softc *, struct cdce_chain *,
		    struct mbuf *);
int	 cdce_encap(struct cdce_softc *, struct mbuf *, int);
void	 cdce_rxeof(struct usbd_xfer *, void *, usbd_status);
void	 cdce_txeof(struct usbd_xfer *, void *, usbd_status);
void	 cdce_start(struct ifnet *);
int	 cdce_ioctl(struct ifnet *, u_long, caddr_t);
void	 cdce_init(void *);
void	 cdce_watchdog(struct ifnet *);
void	 cdce_stop(struct cdce_softc *);
void	 cdce_intr(struct usbd_xfer *, void *, usbd_status);

const struct cdce_type cdce_devs[] = {
    {{ USB_VENDOR_ACERLABS, USB_PRODUCT_ACERLABS_M5632 }, 0 },
    {{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2501 }, 0 },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_SL5500 }, CDCE_CRC32 },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_A300 }, CDCE_CRC32 },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_SL5600 }, CDCE_CRC32 },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C700 }, CDCE_CRC32 },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C750 }, CDCE_CRC32 },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN }, CDCE_CRC32 },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN2 }, CDCE_CRC32 },
    {{ USB_VENDOR_GMATE, USB_PRODUCT_GMATE_YP3X00 }, 0 },
    {{ USB_VENDOR_NETCHIP, USB_PRODUCT_NETCHIP_ETHERNETGADGET }, 0 },
    {{ USB_VENDOR_COMPAQ, USB_PRODUCT_COMPAQ_IPAQLINUX }, 0 },
    {{ USB_VENDOR_AMBIT, USB_PRODUCT_AMBIT_NTL_250 }, CDCE_SWAPUNION },
};
#define cdce_lookup(v, p) \
    ((const struct cdce_type *)usb_lookup(cdce_devs, v, p))

int cdce_match(struct device *, void *, void *);
void cdce_attach(struct device *, struct device *, void *);
int cdce_detach(struct device *, int);

struct cfdriver cdce_cd = {
	NULL, "cdce", DV_IFNET
};

const struct cfattach cdce_ca = {
	sizeof(struct cdce_softc), cdce_match, cdce_attach, cdce_detach
};

int
cdce_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return (UMATCH_NONE);

	if (cdce_lookup(uaa->vendor, uaa->product) != NULL)
		return (UMATCH_VENDOR_PRODUCT);

	if (id->bInterfaceClass == UICLASS_CDC &&
	    (id->bInterfaceSubClass ==
	    UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL ||
	    id->bInterfaceSubClass == UISUBCLASS_MOBILE_DIRECT_LINE_MODEL))
		return (UMATCH_IFACECLASS_GENERIC);

	return (UMATCH_NONE);
}

void
cdce_attach(struct device *parent, struct device *self, void *aux)
{
	struct cdce_softc		*sc = (struct cdce_softc *)self;
	struct usb_attach_arg		*uaa = aux;
	int				 s;
	struct ifnet			*ifp = GET_IFP(sc);
	struct usbd_device		*dev = uaa->device;
	const struct cdce_type		*t;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	struct usb_cdc_union_descriptor	*ud;
	struct usb_cdc_ethernet_descriptor *ethd;
	usb_config_descriptor_t		*cd;
	const usb_descriptor_t		*desc;
	struct usbd_desc_iter		 iter;
	usb_string_descriptor_t		 eaddr_str;
	int				 i, j, numalts, len;
	int				 ctl_ifcno = -1;
	int				 data_ifcno = -1;

	sc->cdce_udev = uaa->device;
	sc->cdce_ctl_iface = uaa->iface;
	id = usbd_get_interface_descriptor(sc->cdce_ctl_iface);
	ctl_ifcno = id->bInterfaceNumber;

	t = cdce_lookup(uaa->vendor, uaa->product);
	if (t)
		sc->cdce_flags = t->cdce_flags;

	/* Get the data interface no. and capabilities */
	ethd = NULL;
	usbd_desc_iter_init(dev, &iter);
	desc = usbd_desc_iter_next(&iter);
	while (desc) {
		if (desc->bDescriptorType != UDESC_CS_INTERFACE) {
			desc = usbd_desc_iter_next(&iter);
			continue;
		}
		switch(desc->bDescriptorSubtype) {
		case UDESCSUB_CDC_UNION:
			ud = (struct usb_cdc_union_descriptor *)desc; 
			if ((sc->cdce_flags & CDCE_SWAPUNION) == 0 &&
			    ud->bMasterInterface == ctl_ifcno)
				data_ifcno = ud->bSlaveInterface[0];
			if ((sc->cdce_flags & CDCE_SWAPUNION) &&
			    ud->bSlaveInterface[0] == ctl_ifcno)
				data_ifcno = ud->bMasterInterface;
			break;
		case UDESCSUB_CDC_ENF:
			if (ethd) {
				printf("%s: ", sc->cdce_dev.dv_xname);
				printf("extra ethernet descriptor\n");
				return;
			}
			ethd = (struct usb_cdc_ethernet_descriptor *)desc;
			break;
		}
		desc = usbd_desc_iter_next(&iter);
	}

	if (data_ifcno == -1) {
		DPRINTF(("cdce_attach: no union interface\n"));
		sc->cdce_data_iface = sc->cdce_ctl_iface;
	} else {
		DPRINTF(("cdce_attach: union interface: ctl=%d, data=%d\n",
		    ctl_ifcno, data_ifcno));
		for (i = 0; i < uaa->nifaces; i++) {
			if (usbd_iface_claimed(sc->cdce_udev, i))
				continue;
			id = usbd_get_interface_descriptor(uaa->ifaces[i]);
			if (id != NULL && id->bInterfaceNumber == data_ifcno) {
				sc->cdce_data_iface = uaa->ifaces[i];
				usbd_claim_iface(sc->cdce_udev, i);
			}
		}
	}

	if (sc->cdce_data_iface == NULL) {
		printf("%s: no data interface\n", sc->cdce_dev.dv_xname);
		return;
	}

	id = usbd_get_interface_descriptor(sc->cdce_ctl_iface);
	sc->cdce_intr_no = -1;
	for (i = 0; i < id->bNumEndpoints && sc->cdce_intr_no == -1; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->cdce_ctl_iface, i);
		if (!ed) {
			printf("%s: no descriptor for interrupt endpoint %d\n",
			    sc->cdce_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->cdce_intr_no = ed->bEndpointAddress;
			sc->cdce_intr_size = sizeof(sc->cdce_intr_buf);
		}
	}

	id = usbd_get_interface_descriptor(sc->cdce_data_iface);
	cd = usbd_get_config_descriptor(sc->cdce_udev);
	numalts = usbd_get_no_alts(cd, id->bInterfaceNumber);

	for (j = 0; j < numalts; j++) {
		if (usbd_set_interface(sc->cdce_data_iface, j)) {
			printf("%s: interface alternate setting %d failed\n", 
			    sc->cdce_dev.dv_xname, j);
			return;
		} 
		/* Find endpoints. */
		id = usbd_get_interface_descriptor(sc->cdce_data_iface);
		sc->cdce_bulkin_no = sc->cdce_bulkout_no = -1;
		for (i = 0; i < id->bNumEndpoints; i++) {
			ed = usbd_interface2endpoint_descriptor(
			    sc->cdce_data_iface, i);
			if (!ed) {
				printf("%s: no descriptor for bulk endpoint "
				    "%d\n", sc->cdce_dev.dv_xname, i);
				return;
			}
			if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
				sc->cdce_bulkin_no = ed->bEndpointAddress;
			} else if (
			    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
				sc->cdce_bulkout_no = ed->bEndpointAddress;
			}
#ifdef CDCE_DEBUG
			else if (
			    UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN &&
			    UE_GET_XFERTYPE(ed->bmAttributes) != UE_INTERRUPT) {
				printf("%s: unexpected endpoint, ep=%x attr=%x"
				    "\n", sc->cdce_dev.dv_xname,
				    ed->bEndpointAddress, ed->bmAttributes);
			}
#endif
		}
		if ((sc->cdce_bulkin_no != -1) && (sc->cdce_bulkout_no != -1)) {
			DPRINTF(("cdce_attach: intr=0x%x, in=0x%x, out=0x%x\n",
			    sc->cdce_intr_no, sc->cdce_bulkin_no,
			    sc->cdce_bulkout_no));
			goto found;
		}
	}
	
	if (sc->cdce_bulkin_no == -1) {
		printf("%s: could not find data bulk in\n",
		    sc->cdce_dev.dv_xname);
		return;
	}
	if (sc->cdce_bulkout_no == -1 ) {
		printf("%s: could not find data bulk out\n",
		    sc->cdce_dev.dv_xname);
		return;
	}

found:
	s = splnet();

	if (!ethd || usbd_get_string_desc(sc->cdce_udev, ethd->iMacAddress, 0,
	    &eaddr_str, &len)) {
		ether_fakeaddr(ifp);
	} else {
		for (i = 0; i < ETHER_ADDR_LEN * 2; i++) {
			int c = UGETW(eaddr_str.bString[i]);

			if ('0' <= c && c <= '9')
				c -= '0';
			else if ('A' <= c && c <= 'F')
				c -= 'A' - 10;
			else if ('a' <= c && c <= 'f')
				c -= 'a' - 10;
			c &= 0xf;
			if (i % 2 == 0)
				c <<= 4;
			sc->cdce_arpcom.ac_enaddr[i / 2] |= c;
		}
	}

	printf("%s: address %s\n", sc->cdce_dev.dv_xname,
	    ether_sprintf(sc->cdce_arpcom.ac_enaddr));

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = cdce_ioctl;
	ifp->if_start = cdce_start;
	ifp->if_watchdog = cdce_watchdog;
	strlcpy(ifp->if_xname, sc->cdce_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ether_ifattach(ifp);

	sc->cdce_attached = 1;
	splx(s);
}

int
cdce_detach(struct device *self, int flags)
{
	struct cdce_softc	*sc = (struct cdce_softc *)self;	
	struct ifnet		*ifp = GET_IFP(sc);
	int			 s;

	if (!sc->cdce_attached)
		return (0);

	s = splusb();

	if (ifp->if_flags & IFF_RUNNING)
		cdce_stop(sc);

	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

	sc->cdce_attached = 0;
	splx(s);

	return (0);
}

void
cdce_start(struct ifnet *ifp)
{
	struct cdce_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	if (usbd_is_dying(sc->cdce_udev) || ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (cdce_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	ifp->if_timer = 6;
}

int
cdce_encap(struct cdce_softc *sc, struct mbuf *m, int idx)
{
	struct cdce_chain	*c;
	usbd_status		 err;
	int			 extra = 0;

	c = &sc->cdce_cdata.cdce_tx_chain[idx];

	m_copydata(m, 0, m->m_pkthdr.len, c->cdce_buf);
	if (sc->cdce_flags & CDCE_CRC32) {
		/* Some devices want a 32-bit CRC appended to every frame */
		u_int32_t crc;

		crc = ether_crc32_le(c->cdce_buf, m->m_pkthdr.len) ^ ~0U;
		bcopy(&crc, c->cdce_buf + m->m_pkthdr.len, 4);
		extra = 4;
	}
	c->cdce_mbuf = m;

	usbd_setup_xfer(c->cdce_xfer, sc->cdce_bulkout_pipe, c, c->cdce_buf,
	    m->m_pkthdr.len + extra, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    10000, cdce_txeof);
	err = usbd_transfer(c->cdce_xfer);
	if (err != USBD_IN_PROGRESS) {
		cdce_stop(sc);
		return (EIO);
	}

	sc->cdce_cdata.cdce_tx_cnt++;

	return (0);
}

void
cdce_stop(struct cdce_softc *sc)
{
	usbd_status	 err;
	struct ifnet	*ifp = GET_IFP(sc);
	int		 i;

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	if (sc->cdce_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->cdce_bulkin_pipe);
		err = usbd_close_pipe(sc->cdce_bulkin_pipe);
		if (err)
			printf("%s: close rx pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
		sc->cdce_bulkin_pipe = NULL;
	}

	if (sc->cdce_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->cdce_bulkout_pipe);
		err = usbd_close_pipe(sc->cdce_bulkout_pipe);
		if (err)
			printf("%s: close tx pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
		sc->cdce_bulkout_pipe = NULL;
	}

	if (sc->cdce_intr_pipe != NULL) {
		usbd_abort_pipe(sc->cdce_intr_pipe);
		err = usbd_close_pipe(sc->cdce_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
		sc->cdce_intr_pipe = NULL;
	}

	for (i = 0; i < CDCE_RX_LIST_CNT; i++) {
		if (sc->cdce_cdata.cdce_rx_chain[i].cdce_mbuf != NULL) {
			m_freem(sc->cdce_cdata.cdce_rx_chain[i].cdce_mbuf);
			sc->cdce_cdata.cdce_rx_chain[i].cdce_mbuf = NULL;
		}
		if (sc->cdce_cdata.cdce_rx_chain[i].cdce_xfer != NULL) {
			usbd_free_xfer(sc->cdce_cdata.cdce_rx_chain[i].cdce_xfer);
			sc->cdce_cdata.cdce_rx_chain[i].cdce_xfer = NULL;
		}
	}

	for (i = 0; i < CDCE_TX_LIST_CNT; i++) {
		if (sc->cdce_cdata.cdce_tx_chain[i].cdce_mbuf != NULL) {
			m_freem(sc->cdce_cdata.cdce_tx_chain[i].cdce_mbuf);
			sc->cdce_cdata.cdce_tx_chain[i].cdce_mbuf = NULL;
		}
		if (sc->cdce_cdata.cdce_tx_chain[i].cdce_xfer != NULL) {
			usbd_free_xfer(
			    sc->cdce_cdata.cdce_tx_chain[i].cdce_xfer);
			sc->cdce_cdata.cdce_tx_chain[i].cdce_xfer = NULL;
		}
	}
}

int
cdce_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct cdce_softc	*sc = ifp->if_softc;
	int			 s, error = 0;

	if (usbd_is_dying(sc->cdce_udev))
		return (EIO);

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			cdce_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				cdce_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				cdce_stop(sc);
		}
		break;

	default:
		error = ether_ioctl(ifp, &sc->cdce_arpcom, command, data);
		break;
	}

	if (error == ENETRESET)
		error = 0;

	splx(s);
	return (error);
}

void
cdce_watchdog(struct ifnet *ifp)
{
	struct cdce_softc	*sc = ifp->if_softc;

	if (usbd_is_dying(sc->cdce_udev))
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->cdce_dev.dv_xname);
}

void
cdce_init(void *xsc)
{
	struct cdce_softc	*sc = xsc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct cdce_chain	*c;
	usbd_status		 err;
	int			 s, i;

	s = splnet();

	if (sc->cdce_intr_no != -1 && sc->cdce_intr_pipe == NULL) {
		DPRINTFN(1, ("cdce_init: establish interrupt pipe\n"));
		err = usbd_open_pipe_intr(sc->cdce_ctl_iface, sc->cdce_intr_no,
		    USBD_SHORT_XFER_OK, &sc->cdce_intr_pipe, sc,
		    &sc->cdce_intr_buf, sc->cdce_intr_size, cdce_intr,
		    USBD_DEFAULT_INTERVAL);
		if (err) {
			printf("%s: open interrupt pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
			splx(s);
			return;
		}
	}

	if (cdce_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->cdce_dev.dv_xname);
		splx(s);
		return;
	}

	if (cdce_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->cdce_dev.dv_xname);
		splx(s);
		return;
	}

	/* Maybe set multicast / broadcast here??? */

	err = usbd_open_pipe(sc->cdce_data_iface, sc->cdce_bulkin_no,
	    USBD_EXCLUSIVE_USE, &sc->cdce_bulkin_pipe);
	if (err) {
		printf("%s: open rx pipe failed: %s\n", sc->cdce_dev.dv_xname,
		    usbd_errstr(err));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->cdce_data_iface, sc->cdce_bulkout_no,
	    USBD_EXCLUSIVE_USE, &sc->cdce_bulkout_pipe);
	if (err) {
		printf("%s: open tx pipe failed: %s\n", sc->cdce_dev.dv_xname,
		    usbd_errstr(err));
		splx(s);
		return;
	}

	for (i = 0; i < CDCE_RX_LIST_CNT; i++) {
		c = &sc->cdce_cdata.cdce_rx_chain[i];
		usbd_setup_xfer(c->cdce_xfer, sc->cdce_bulkin_pipe, c,
		    c->cdce_buf, CDCE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, cdce_rxeof);
		usbd_transfer(c->cdce_xfer);
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

int
cdce_newbuf(struct cdce_softc *sc, struct cdce_chain *c, struct mbuf *m)
{
	struct mbuf	*m_new = NULL;

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->cdce_dev.dv_xname);
			return (ENOBUFS);
		}
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->cdce_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);
	c->cdce_mbuf = m_new;
	return (0);
}

int
cdce_rx_list_init(struct cdce_softc *sc)
{
	struct cdce_cdata	*cd;
	struct cdce_chain	*c;
	int			 i;

	cd = &sc->cdce_cdata;
	for (i = 0; i < CDCE_RX_LIST_CNT; i++) {
		c = &cd->cdce_rx_chain[i];
		c->cdce_sc = sc;
		c->cdce_idx = i;
		if (cdce_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->cdce_xfer == NULL) {
			c->cdce_xfer = usbd_alloc_xfer(sc->cdce_udev);
			if (c->cdce_xfer == NULL)
				return (ENOBUFS);
			c->cdce_buf = usbd_alloc_buffer(c->cdce_xfer,
			    CDCE_BUFSZ);
			if (c->cdce_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

int
cdce_tx_list_init(struct cdce_softc *sc)
{
	struct cdce_cdata	*cd;
	struct cdce_chain	*c;
	int			 i;

	cd = &sc->cdce_cdata;
	for (i = 0; i < CDCE_TX_LIST_CNT; i++) {
		c = &cd->cdce_tx_chain[i];
		c->cdce_sc = sc;
		c->cdce_idx = i;
		c->cdce_mbuf = NULL;
		if (c->cdce_xfer == NULL) {
			c->cdce_xfer = usbd_alloc_xfer(sc->cdce_udev);
			if (c->cdce_xfer == NULL)
				return (ENOBUFS);
			c->cdce_buf = usbd_alloc_buffer(c->cdce_xfer,
			    CDCE_BUFSZ);
			if (c->cdce_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

void
cdce_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct cdce_chain	*c = priv;
	struct cdce_softc	*sc = c->cdce_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf		*m;
	struct mbuf_list	 ml = MBUF_LIST_INITIALIZER();
	int			 total_len = 0;
	int			 s;

	if (usbd_is_dying(sc->cdce_udev) || !(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (sc->cdce_rxeof_errors == 0)
			printf("%s: usb error on rx: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cdce_bulkin_pipe);
		DELAY(sc->cdce_rxeof_errors * 10000);
		if (sc->cdce_rxeof_errors++ > 10) {
			printf("%s: too many errors, disabling\n",
			    sc->cdce_dev.dv_xname);
			usbd_deactivate(sc->cdce_udev);
			return;
		}
		goto done;
	}

	sc->cdce_rxeof_errors = 0;

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);
	if (sc->cdce_flags & CDCE_CRC32)
		total_len -= 4;	/* Strip off added CRC */
	if (total_len <= 1)
		goto done;

	m = c->cdce_mbuf;
	memcpy(mtod(m, char *), c->cdce_buf, total_len);

	if (total_len < sizeof(struct ether_header)) {
		ifp->if_ierrors++;
		goto done;
	}

	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (cdce_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

done:
	/* Setup new transfer. */
	usbd_setup_xfer(c->cdce_xfer, sc->cdce_bulkin_pipe, c, c->cdce_buf,
	    CDCE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
	    cdce_rxeof);
	usbd_transfer(c->cdce_xfer);
}

void
cdce_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct cdce_chain	*c = priv;
	struct cdce_softc	*sc = c->cdce_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	usbd_status		 err;
	int			 s;

	if (usbd_is_dying(sc->cdce_udev))
		return;

	s = splnet();

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->cdce_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cdce_bulkout_pipe);
		splx(s);
		return;
	}

	usbd_get_xfer_status(c->cdce_xfer, NULL, NULL, NULL, &err);

	if (c->cdce_mbuf != NULL) {
		m_freem(c->cdce_mbuf);
		c->cdce_mbuf = NULL;
	}

	if (err)
		ifp->if_oerrors++;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		cdce_start(ifp);

	splx(s);
}

void
cdce_intr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct cdce_softc	*sc = addr;
	struct usb_cdc_notification *buf = &sc->cdce_intr_buf;
	struct usb_cdc_connection_speed	*speed;
	u_int32_t		 count;

	if (status == USBD_CANCELLED)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTFN(2, ("cdce_intr: status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->cdce_intr_pipe);
		return;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);

	if (buf->bmRequestType == UCDC_NOTIFICATION) {
		switch (buf->bNotification) {
		case UCDC_N_NETWORK_CONNECTION:
			DPRINTFN(1, ("cdce_intr: network %s\n",
			    UGETW(buf->wValue) ? "connected" : "disconnected"));
			break;
		case UCDC_N_CONNECTION_SPEED_CHANGE:
			speed = (struct usb_cdc_connection_speed *)&buf->data;
			DPRINTFN(1, ("cdce_intr: up=%d, down=%d\n",
			    UGETDW(speed->dwUSBitRate),
			    UGETDW(speed->dwDSBitRate)));
			break;
		default:
			DPRINTF(("cdce_intr: bNotification 0x%x\n",
			    buf->bNotification));
		}
	}
#ifdef CDCE_DEBUG
	else {
		printf("cdce_intr: bmRequestType=%d ", buf->bmRequestType);
		printf("wValue=%d wIndex=%d wLength=%d\n", UGETW(buf->wValue),
		    UGETW(buf->wIndex), UGETW(buf->wLength));
	}
#endif
}
@


1.73
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.72 2016/10/12 21:51:11 fcambus Exp $ */
a90 1
static uint32_t	 cdce_crc32(const void *, size_t);
d415 1
a415 1
		crc = cdce_crc32(c->cdce_buf, m->m_pkthdr.len);
a866 66
}


/*  COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
 *  code or tables extracted from it, as desired without restriction.
 */

static uint32_t cdce_crc32_tab[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3,	0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de,	0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec,	0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5,	0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,	0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940,	0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,	0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

uint32_t
cdce_crc32(const void *buf, size_t size)
{
	const uint8_t *p;
	uint32_t crc;

	p = buf;
	crc = ~0U;

	while (size--)
		crc = cdce_crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);

	return (htole32(crc) ^ ~0U);
@


1.72
log
@Rename CDCE_ZAURUS option to CDCE_CRC32 for clarity.

OK kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.71 2016/09/26 07:09:32 fcambus Exp $ */
a816 2
	else
		ifp->if_opackets++;
@


1.71
log
@Move the net/bpf.h include within the #if NBPFILTER directive

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.70 2016/04/13 11:03:37 mpi Exp $ */
d96 7
a102 7
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_SL5500 }, CDCE_ZAURUS },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_A300 }, CDCE_ZAURUS },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_SL5600 }, CDCE_ZAURUS },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C700 }, CDCE_ZAURUS },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C750 }, CDCE_ZAURUS },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN }, CDCE_ZAURUS },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN2 }, CDCE_ZAURUS },
d412 2
a413 2
	if (sc->cdce_flags & CDCE_ZAURUS) {
		/* Zaurus wants a 32-bit CRC appended to every frame */
d744 2
a745 2
	if (sc->cdce_flags & CDCE_ZAURUS)
		total_len -= 4;	/* Strip off CRC added by Zaurus */
@


1.70
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.69 2016/04/12 10:15:25 mpi Exp $ */
d55 1
a56 1
#if NBPFILTER > 0
@


1.69
log
@Call ether_fakeaddr() instead of faking Ethernet addresses manually.

Input from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.68 2015/11/25 03:10:00 dlg Exp $ */
a336 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.68
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.67 2015/11/20 03:35:23 dlg Exp $ */
d154 1
a154 1
	struct ifnet			*ifp;
a164 3
	struct timeval			 now;
	u_int32_t			 macaddr_lo;
	u_int16_t			 macaddr_hi;
d310 1
a310 7
		macaddr_hi = htons(0x2acb);
		bcopy(&macaddr_hi, &sc->cdce_arpcom.ac_enaddr[0],
		    sizeof(u_int16_t));
		getmicrotime(&now);
		macaddr_lo = htonl(now.tv_usec << 8);
		bcopy(&macaddr_lo, &sc->cdce_arpcom.ac_enaddr[2], sizeof(u_int32_t));
		sc->cdce_arpcom.ac_enaddr[5] = (u_int8_t)(sc->cdce_dev.dv_unit);
a330 1
	ifp = GET_IFP(sc);
@


1.67
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.66 2015/10/25 12:11:56 mpi Exp $ */
d389 1
a389 1
	if (usbd_is_dying(sc->cdce_udev) || (ifp->if_flags & IFF_OACTIVE))
d398 1
a398 1
		ifp->if_flags |= IFF_OACTIVE;
d409 1
a409 1
	ifp->if_flags |= IFF_OACTIVE;
d456 2
a457 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d630 1
a630 1
	ifp->if_flags &= ~IFF_OACTIVE;
d804 1
a804 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.66
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.65 2015/06/24 09:40:54 mpi Exp $ */
d392 1
a392 1
	IFQ_POLL(&ifp->if_snd, m_head);
d397 1
d402 1
a402 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.65
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.64 2015/04/10 08:41:43 mpi Exp $ */
a511 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a523 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->cdce_arpcom, ifa);
@


1.64
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.63 2015/03/14 03:38:49 jsg Exp $ */
a769 1
	ifp->if_ipackets++;
@


1.63
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.62 2014/12/22 02:28:52 tedu Exp $ */
d729 1
a770 1

d772 1
a772 3
	m->m_pkthdr.rcvif = ifp;

	s = splnet();
d776 1
a776 1
		goto done1;
d779 2
a780 8
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);

done1:
@


1.62
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.61 2014/07/13 15:52:49 mpi Exp $ */
a53 1
#include <net/if_dl.h>
@


1.61
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.60 2014/07/12 07:59:23 mpi Exp $ */
a525 1
#ifdef INET
a527 1
#endif
@


1.60
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.59 2013/12/07 20:17:42 brad Exp $ */
a60 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.59
log
@Some cleaning up of the ioctl handling bits to bring things in line
with the other drivers. No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.58 2013/12/04 00:52:52 deraadt Exp $ */
d114 10
a123 15
int cdce_match(struct device *, void *, void *); 
void cdce_attach(struct device *, struct device *, void *); 
int cdce_detach(struct device *, int); 
int cdce_activate(struct device *, int); 

struct cfdriver cdce_cd = { 
	NULL, "cdce", DV_IFNET 
}; 

const struct cfattach cdce_ca = { 
	sizeof(struct cdce_softc), 
	cdce_match, 
	cdce_attach, 
	cdce_detach, 
	cdce_activate, 
a850 13
}

int
cdce_activate(struct device *self, int act)
{
	struct cdce_softc *sc = (struct cdce_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->cdce_udev);
		break;
	}
	return (0);
@


1.58
log
@use dv_unit rather than storing (or forgetting to store...) a local
version
noted by uaa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.57 2013/11/15 10:17:39 pirofti Exp $ */
d531 4
a534 3
		cdce_init(sc);
		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
d536 1
a536 2
			break;
		}
d541 3
a543 1
			if (!(ifp->if_flags & IFF_RUNNING))
a548 1
		error = 0;
a582 3

	if (ifp->if_flags & IFF_RUNNING)
		return;
@


1.57
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.56 2013/11/11 12:38:16 pirofti Exp $ */
d327 1
a327 1
		sc->cdce_arpcom.ac_enaddr[5] = (u_int8_t)(sc->cdce_unit);
@


1.56
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.55 2013/08/07 01:06:41 bluhm Exp $ */
d466 1
a466 4
		err = usbd_abort_pipe(sc->cdce_bulkin_pipe);
		if (err)
			printf("%s: abort rx pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
d475 1
a475 4
		err = usbd_abort_pipe(sc->cdce_bulkout_pipe);
		if (err)
			printf("%s: abort tx pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
d484 1
a484 4
		err = usbd_abort_pipe(sc->cdce_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			    sc->cdce_dev.dv_xname, usbd_errstr(err));
@


1.55
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.54 2013/04/26 13:46:40 mglocker Exp $ */
d397 1
a397 1
	if (sc->cdce_dying || (ifp->if_flags & IFF_OACTIVE))
d532 1
a532 1
	if (sc->cdce_dying)
d576 1
a576 1
	if (sc->cdce_dying)
d753 1
a753 1
	if (sc->cdce_dying || !(ifp->if_flags & IFF_RUNNING))
d768 1
a768 1
			sc->cdce_dying = 1;
d829 1
a829 1
	if (sc->cdce_dying)
d876 1
a876 1
		sc->cdce_dying = 1;
@


1.54
log
@Rename three functions in usbdi.c to their right prefix (usb_* to usbd_*).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.53 2013/04/15 09:23:01 mglocker Exp $ */
a61 1
#include <netinet/in_var.h>
@


1.53
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.52 2013/03/28 03:58:03 tedu Exp $ */
d192 2
a193 2
	usb_desc_iter_init(dev, &iter);
	desc = usb_desc_iter_next(&iter);
d196 1
a196 1
			desc = usb_desc_iter_next(&iter);
d218 1
a218 1
		desc = usb_desc_iter_next(&iter);
@


1.52
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.51 2011/11/09 21:45:50 sthen Exp $ */
d87 2
a88 2
void	 cdce_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void	 cdce_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d94 1
a94 1
void	 cdce_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d164 1
a164 1
	usbd_device_handle		 dev = uaa->device;
d168 2
a169 2
	usb_cdc_union_descriptor_t	*ud;
	usb_cdc_ethernet_descriptor_t	*ethd;
d172 1
a172 1
	usbd_desc_iter_t		 iter;
d201 1
a201 1
			ud = (usb_cdc_union_descriptor_t *)desc; 
d215 1
a215 1
			ethd = (usb_cdc_ethernet_descriptor_t *)desc;
d745 1
a745 1
cdce_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d822 1
a822 1
cdce_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d884 1
a884 1
cdce_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d887 2
a888 2
	usb_cdc_notification_t	*buf = &sc->cdce_intr_buf;
	usb_cdc_connection_speed_t	*speed;
d910 1
a910 1
			speed = (usb_cdc_connection_speed_t *)&buf->data;
@


1.51
log
@Add support for UISUBCLASS_MOBILE_DIRECT_LINE_MODEL to cdce(4).
This is available with at least Ericsson-derived HSPA cards (e.g.
Dell 5530/5540) and provides a nice alternative to using them in
ppp mode. From Rivo Nurges (rix at estpak ee), ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.50 2011/07/03 15:47:17 matthew Exp $ */
a51 1
#include <sys/proc.h>
@


1.50
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.49 2011/01/25 20:03:35 jakemsr Exp $ */
d149 4
a152 2
	if (id->bInterfaceClass == UICLASS_CDC && id->bInterfaceSubClass ==
	    UISUBCLASS_ETHERNET_NETWORKING_CONTROL_MODEL)
@


1.49
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.48 2011/01/16 22:35:29 jakemsr Exp $ */
a874 3
	case DVACT_ACTIVATE:
		break;

@


1.48
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.47 2010/10/27 17:51:11 jakemsr Exp $ */
a362 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->cdce_udev,
	    &sc->cdce_dev);
a386 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->cdce_udev,
	    &sc->cdce_dev);
@


1.47
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.46 2010/09/24 08:33:58 yuo Exp $ */
d227 1
a227 1
			if (uaa->ifaces[i] == NULL)
d232 1
a232 1
				uaa->ifaces[i] = NULL;
@


1.46
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.45 2010/03/06 17:09:31 mk Exp $ */
d383 4
a386 3
	ether_ifdetach(ifp);

	if_detach(ifp);
@


1.45
log
@In cdce_detach(), add usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, ...)
like other drivers do.

Tested and ok mpf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.44 2009/10/13 19:33:17 pirofti Exp $ */
d375 3
a378 5

	if (!sc->cdce_attached) {
		splx(s);
		return (0);
	}
@


1.44
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.43 2008/11/28 02:44:18 brad Exp $ */
d391 3
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.42 2008/10/02 20:21:14 brad Exp $ */
d119 1
a119 1
int cdce_activate(struct device *, enum devact); 
d874 1
a874 1
cdce_activate(struct device *self, enum devact act)
@


1.42
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.41 2008/03/14 21:54:23 mbalmer Exp $ */
a533 1
	struct ifreq		*ifr = (struct ifreq *)data;
a551 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

a562 10
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->cdce_arpcom) :
		    ether_delmulti(ifr, &sc->cdce_arpcom);

		if (error == ENETRESET)
			error = 0;
		break;

d567 3
@


1.41
log
@Make sure the most often changing bits of tv_usec are used for lladdr
generation.

ok brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.40 2008/03/13 08:32:02 mbalmer Exp $ */
d582 1
a582 1
		error = EINVAL;
a586 1

@


1.40
log
@when attaching a cdce(4) device that does not have a proper mac address,
use the tv_usec part of a getmicrotime(9) call instead of 'int ticks' to
create a mac address.  as ticks is 0 during boot, this resulted in both ends
of a USB link cable to have the same mac address.

problem found/diff tested winiger, feedback/ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.39 2007/10/11 18:33:14 deraadt Exp $ */
d325 1
a325 1
		macaddr_lo = htonl(now.tv_usec);
@


1.39
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.38 2007/09/17 01:40:38 fgsch Exp $ */
d173 2
d324 3
a326 1
		bcopy(&ticks, &sc->cdce_arpcom.ac_enaddr[2], sizeof(u_int32_t));
@


1.38
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.37 2007/09/11 21:17:37 winiger Exp $ */
a160 1
	char				*devinfop;
a176 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->cdce_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.37
log
@KNF.   "go for it" deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.36 2007/07/25 21:22:20 claudio Exp $ */
a48 1
#include <sys/malloc.h>
@


1.36
log
@Add a missing splx() and while there update the printf() to match the format
of the other ones. From Marc Winiger mw at msys . ch
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.35 2007/07/25 16:42:24 mbalmer Exp $ */
d114 2
a115 1
#define cdce_lookup(v, p) ((const struct cdce_type *)usb_lookup(cdce_devs, v, p))
d162 1
a162 1
	char				 *devinfop;
d231 6
a236 8
			if (uaa->ifaces[i] != NULL) {
				id = usbd_get_interface_descriptor(
				    uaa->ifaces[i]);
				if (id != NULL && id->bInterfaceNumber ==
				    data_ifcno) {
					sc->cdce_data_iface = uaa->ifaces[i];
					uaa->ifaces[i] = NULL;
				}
d267 3
a269 13
	    if (usbd_set_interface(sc->cdce_data_iface, j)) {
	    	printf("%s: interface alternate setting %d failed\n", 
		    sc->cdce_dev.dv_xname, j);
		return;
    	    } 
	    /* Find endpoints. */
	    id = usbd_get_interface_descriptor(sc->cdce_data_iface);
	    sc->cdce_bulkin_no = sc->cdce_bulkout_no = -1;
	    for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->cdce_data_iface, i);
		if (!ed) {
			printf("%s: no descriptor for bulk endpoint %d\n",
			    sc->cdce_dev.dv_xname, i);
d271 29
d301 5
a305 13
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->cdce_bulkin_no = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->cdce_bulkout_no = ed->bEndpointAddress;
		}
#ifdef CDCE_DEBUG
		else if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) != UE_INTERRUPT) {
			printf("%s: unexpected endpoint, ep=%x attr=%x\n",
			    sc->cdce_dev.dv_xname, ed->bEndpointAddress,
			    ed->bmAttributes);
a306 7
#endif
	    }
	    if ((sc->cdce_bulkin_no != -1) && (sc->cdce_bulkout_no != -1)) {
		DPRINTF(("cdce_attach: intr=0x%x, in=0x%x, out=0x%x\n",
		    sc->cdce_intr_no, sc->cdce_bulkin_no, sc->cdce_bulkout_no));
		goto found;
	    }
d524 2
a525 1
			usbd_free_xfer(sc->cdce_cdata.cdce_tx_chain[i].cdce_xfer);
d728 2
a729 1
			c->cdce_buf = usbd_alloc_buffer(c->cdce_xfer, CDCE_BUFSZ);
d755 2
a756 1
			c->cdce_buf = usbd_alloc_buffer(c->cdce_xfer, CDCE_BUFSZ);
d929 1
a929 1
		    case UCDC_N_NETWORK_CONNECTION:
d933 1
a933 1
		    case UCDC_N_CONNECTION_SPEED_CHANGE:
d939 1
a939 1
		    default:
@


1.35
log
@define and use CDCE_DEBUG and DPRINTF/DPRINTFN to be less noisy on the
console.

From Marc Winiger <mw@@msys.ch>

ok jsg, claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.34 2007/07/23 16:41:15 mbalmer Exp $ */
d622 3
a624 2
			printf("Failed to establish interrupt pipe: %s\n",
			    usbd_errstr(err));
@


1.34
log
@This improves cdce(4) and makes some devices work that previously did not
(like the Sony Ericsson K610 mobile phone).

- Read hardware address from ethernet descriptor makes the Sony Ericsson
  K610 work.
- Add support for status notifications (interrupt endpoint).
- Recognize if there is a union descriptori (thus remove CDCE_NO_UNION).
- Handle wrong union descriptors (master/slave values are swapped)
  (Ambit NTL 250)

Diff done by Marc Winiger <mw@@msys.ch>, tested by many on different
platforms and with various devices:  cable modems, mobile phones, and,
zaurus as USB function.

ok jsg, claudio, kili
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.33 2007/06/14 10:11:15 mbalmer Exp $ */
d76 8
d224 1
d227 2
a257 2
			printf("%s: status change notification available\n",
			    sc->cdce_dev.dv_xname);
d289 4
a292 5
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			/* XXX: CDC spec defines an interrupt pipe, but it is
			 * not needed for simple host-to-host applications. */
		} else {
d297 1
d300 2
d616 1
d912 1
a912 1
		printf("cdce_intr: status=%d\n", status);
d923 2
a924 2
			printf("%s: network %s\n", sc->cdce_dev.dv_xname,
			    UGETW(buf->wValue) ? "connected" : "disconnected");
d928 3
a930 3
			printf("%s: upstream %d bps, downstream %d bps\n",
			    sc->cdce_dev.dv_xname, UGETDW(speed->dwUSBitRate),
			    UGETDW(speed->dwDSBitRate));
d933 2
a934 2
			printf("%s: bNotification 0x%x\n",
			    sc->cdce_dev.dv_xname, buf->bNotification);
d936 4
a939 3
	} else {
		printf("%s: bmRequestType=%d ", sc->cdce_dev.dv_xname,
		    buf->bmRequestType);
d943 1
@


1.33
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.32 2007/06/13 11:15:29 mbalmer Exp $ */
a75 1
void	*cdce_get_desc(usbd_device_handle dev, int type, int subtype);
d88 1
d92 2
a93 2
    {{ USB_VENDOR_ACERLABS, USB_PRODUCT_ACERLABS_M5632 }, CDCE_NO_UNION },
    {{ USB_VENDOR_PROLIFIC, USB_PRODUCT_PROLIFIC_PL2501 }, CDCE_NO_UNION },
d95 10
a104 10
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_A300 }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_SL5600 }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C700 }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_SHARP, USB_PRODUCT_SHARP_C750 }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_MOTOROLA2, USB_PRODUCT_MOTOROLA2_USBLAN2 }, CDCE_ZAURUS | CDCE_NO_UNION },
    {{ USB_VENDOR_GMATE, USB_PRODUCT_GMATE_YP3X00 }, CDCE_NO_UNION },
    {{ USB_VENDOR_NETCHIP, USB_PRODUCT_NETCHIP_ETHERNETGADGET }, CDCE_NO_UNION },
    {{ USB_VENDOR_COMPAQ, USB_PRODUCT_COMPAQ_IPAQLINUX }, CDCE_NO_UNION },
    {{ USB_VENDOR_AMBIT, USB_PRODUCT_AMBIT_NTL_250 }, CDCE_NO_UNION },
d161 1
d163 3
a165 1
	int				 data_ifcno;
d167 3
a169 1
	int				 i, j, numalts;
d177 2
d184 27
a210 9
	if (sc->cdce_flags & CDCE_NO_UNION)
		sc->cdce_data_iface = sc->cdce_ctl_iface;
	else {
		ud = cdce_get_desc(sc->cdce_udev, UDESC_CS_INTERFACE,
		    UDESCSUB_CDC_UNION);
		if (ud == NULL) {
			printf("%s: no union descriptor\n",
			    sc->cdce_dev.dv_xname);
			return;
d212 2
a213 1
		data_ifcno = ud->bSlaveInterface[0];
d215 3
d236 18
a253 1
	/* Find endpoints. */
d259 3
a261 3
    	    if (usbd_set_interface(sc->cdce_data_iface, j)) {
       		printf("%s: setting alternate interface failed\n", 
			sc->cdce_dev.dv_xname);
d264 1
d270 2
a271 2
			printf("%s: could not read endpoint descriptor\n",
			    sc->cdce_dev.dv_xname);
d282 2
a283 2
			/* XXX: CDC spec defines an interrupt pipe, but it is not
			 * needed for simple host-to-host applications. */
d285 3
a287 2
			printf("%s: unexpected endpoint\n",
			    sc->cdce_dev.dv_xname);
d290 3
a292 1
	    
d306 1
d309 23
a331 4
	macaddr_hi = htons(0x2acb);
	bcopy(&macaddr_hi, &sc->cdce_arpcom.ac_enaddr[0], sizeof(u_int16_t));
	bcopy(&ticks, &sc->cdce_arpcom.ac_enaddr[2], sizeof(u_int32_t));
	sc->cdce_arpcom.ac_enaddr[5] = (u_int8_t)(sc->cdce_unit);
d481 12
d604 12
a871 19
void *
cdce_get_desc(usbd_device_handle dev, int type, int subtype)
{
	usb_descriptor_t	*desc;
	usb_config_descriptor_t	*cd = usbd_get_config_descriptor(dev);
	uByte			*p = (uByte *)cd;
	uByte			*end = p + UGETW(cd->wTotalLength);

	while (p < end) {
		desc = (usb_descriptor_t *)p;
		if (desc->bDescriptorType == type &&
		    desc->bDescriptorSubtype == subtype)
			return (desc);
		p += desc->bLength;
	}

	return (NULL);
}

d886 44
@


1.32
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.31 2007/06/12 16:26:36 mbalmer Exp $ */
d108 16
a123 1
USB_DECLARE_DRIVER_CLASS(cdce, DV_IFNET);
@


1.31
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.30 2007/06/10 14:49:00 mbalmer Exp $ */
d701 1
a701 1
	IF_INPUT(ifp, m);
@


1.30
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.29 2007/06/10 10:53:48 mbalmer Exp $ */
d783 1
a783 1
cdce_activate(device_ptr_t self, enum devact act)
@


1.29
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.28 2007/06/09 12:22:53 mbalmer Exp $ */
d152 1
a152 1
	printf("\n%s: %s\n", USBDEVNAME(sc->cdce_dev), devinfop);
d169 1
a169 1
			    USBDEVNAME(sc->cdce_dev));
d188 1
a188 1
		printf("%s: no data interface\n", USBDEVNAME(sc->cdce_dev));
d200 1
a200 1
			USBDEVNAME(sc->cdce_dev));
d209 1
a209 1
			    USBDEVNAME(sc->cdce_dev));
d224 1
a224 1
			    USBDEVNAME(sc->cdce_dev));
d232 1
a232 1
		    USBDEVNAME(sc->cdce_dev));
d237 1
a237 1
		    USBDEVNAME(sc->cdce_dev));
d248 1
a248 1
	printf("%s: address %s\n", USBDEVNAME(sc->cdce_dev),
d257 1
a257 1
	strlcpy(ifp->if_xname, USBDEVNAME(sc->cdce_dev), IFNAMSIZ);
d376 1
a376 1
			    USBDEVNAME(sc->cdce_dev), usbd_errstr(err));
d380 1
a380 1
			    USBDEVNAME(sc->cdce_dev), usbd_errstr(err));
d388 1
a388 1
			    USBDEVNAME(sc->cdce_dev), usbd_errstr(err));
d392 1
a392 1
			    USBDEVNAME(sc->cdce_dev), usbd_errstr(err));
d490 1
a490 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->cdce_dev));
d508 1
a508 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->cdce_dev));
d514 1
a514 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->cdce_dev));
d524 1
a524 1
		printf("%s: open rx pipe failed: %s\n", USBDEVNAME(sc->cdce_dev),
d533 1
a533 1
		printf("%s: open tx pipe failed: %s\n", USBDEVNAME(sc->cdce_dev),
d562 1
a562 1
			    "-- packet dropped!\n", USBDEVNAME(sc->cdce_dev));
d568 1
a568 1
			    "-- packet dropped!\n", USBDEVNAME(sc->cdce_dev));
d655 1
a655 1
			    USBDEVNAME(sc->cdce_dev), usbd_errstr(status));
d661 1
a661 1
			    USBDEVNAME(sc->cdce_dev));
d737 1
a737 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->cdce_dev),
@


1.28
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.27 2007/06/05 08:43:55 mbalmer Exp $ */
d268 1
a268 1
	    USBDEV(sc->cdce_dev));
@


1.27
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.26 2007/05/27 04:00:24 jsg Exp $ */
a791 1
		if_deactivate(GET_IFP(sc));
@


1.26
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.25 2007/05/21 05:18:56 jsg Exp $ */
d76 4
a79 4
Static void	*cdce_get_desc(usbd_device_handle dev, int type, int subtype);
Static int	 cdce_tx_list_init(struct cdce_softc *);
Static int	 cdce_rx_list_init(struct cdce_softc *);
Static int	 cdce_newbuf(struct cdce_softc *, struct cdce_chain *,
d81 8
a88 8
Static int	 cdce_encap(struct cdce_softc *, struct mbuf *, int);
Static void	 cdce_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void	 cdce_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void	 cdce_start(struct ifnet *);
Static int	 cdce_ioctl(struct ifnet *, u_long, caddr_t);
Static void	 cdce_init(void *);
Static void	 cdce_watchdog(struct ifnet *);
Static void	 cdce_stop(struct cdce_softc *);
d91 1
a91 1
Static const struct cdce_type cdce_devs[] = {
d298 1
a298 1
Static void
d328 1
a328 1
Static int
d362 1
a362 1
Static void
d419 1
a419 1
Static int
d481 1
a481 1
Static void
d493 1
a493 1
Static void
d553 1
a553 1
Static int
d584 1
a584 1
Static int
d611 1
a611 1
Static int
d637 1
a637 1
Static void
d714 1
a714 1
Static void
@


1.25
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.24 2007/04/05 02:32:45 tedu Exp $ */
d110 2
a111 1
USB_MATCH(cdce)
d113 1
a113 1
	USB_MATCH_START(cdce, uaa);
d133 2
a134 1
USB_ATTACH(cdce)
d136 2
a137 1
	USB_ATTACH_START(cdce, sc, uaa);
d152 1
a152 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->cdce_dev), devinfop);
d170 1
a170 1
			USB_ATTACH_ERROR_RETURN;
d189 1
a189 1
		USB_ATTACH_ERROR_RETURN;
d201 1
a201 1
        	USB_ATTACH_ERROR_RETURN;
d210 1
a210 1
			USB_ATTACH_ERROR_RETURN;
d233 1
a233 1
		USB_ATTACH_ERROR_RETURN;
d238 1
a238 1
		USB_ATTACH_ERROR_RETURN;
a268 2

	USB_ATTACH_SUCCESS_RETURN;
d271 2
a272 1
USB_DETACH(cdce)
d274 3
a276 3
	USB_DETACH_START(cdce, sc);
	struct ifnet	*ifp = GET_IFP(sc);
	int		 s;
@


1.24
log
@laurence tratt says his cable mostly works with this
ok millert
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.23 2007/02/23 01:19:15 drahn Exp $ */
d260 1
a260 1
	Ether_ifattach(ifp, sc->cdce_arpcom.ac_enaddr);
@


1.23
log
@force usb to send a zero length packet on the end of usb packets
which happen to be a multple of 64 bytes, to indicate end of packet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.22 2007/01/22 03:46:49 dlg Exp $ */
d104 1
@


1.22
log
@iterate over the endpoints looking for appropriate interface descriptors to
use.

this makes my adsl modem and ckeuthes cable modem work.

idea from freebsd, via a diff from Krystian Baniak
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.20 2006/11/16 23:50:16 deraadt Exp $ */
d347 2
a348 1
	    m->m_pkthdr.len + extra, USBD_NO_COPY, 10000, cdce_txeof);
@


1.21
log
@another motorola device.
@
text
@d142 1
d145 1
a145 1
	int				 i;
d191 12
a202 2
	sc->cdce_bulkin_no = sc->cdce_bulkout_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
d223 2
d226 1
a226 1

@


1.20
log
@another cdce
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.19 2006/06/23 06:27:11 miod Exp $ */
d100 1
@


1.19
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.18 2006/05/30 22:51:53 pascoe Exp $ */
d102 1
@


1.18
log
@Give up trying to communicate after 10 consecutive errors - the device
is most likely not coming back.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.17 2006/05/27 21:47:55 pascoe Exp $ */
a770 1
		return (EOPNOTSUPP);
@


1.17
log
@Add support for multicast packets.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.16 2006/03/25 22:41:46 djm Exp $ */
d641 6
a646 1
		sc->cdce_rxeof_errors++;
@


1.16
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.15 2006/03/24 13:50:14 dlg Exp $ */
d441 10
@


1.15
log
@i wish all new hardware was this easy to support. acer labs usb2 data
link cable seems happy. thanks to sevan janiyan for the gear.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.14 2006/02/20 20:12:13 damien Exp $ */
a59 1
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))
d303 1
a303 1
		BPF_MTAP(ifp, m_head);
d665 1
a665 1
		BPF_MTAP(ifp, m);
@


1.14
log
@Fix kernel builds without bpfilter. Linking is still broken.

"Please commit this diff ASAP" brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.13 2006/01/29 03:22:52 brad Exp $ */
d93 1
@


1.13
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.12 2005/12/13 17:41:59 drahn Exp $ */
d58 1
a59 1
#include <net/bpf.h>
@


1.12
log
@add new device.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.11 2005/09/29 01:18:05 deraadt Exp $ */
d629 1
a629 1
			usbd_clear_endpoint_stall(sc->cdce_bulkin_pipe);
d707 1
a707 1
			usbd_clear_endpoint_stall(sc->cdce_bulkout_pipe);
@


1.11
log
@2 more cdce devices
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.10 2005/08/01 05:36:48 brad Exp $ */
d99 1
@


1.10
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.9 2005/07/02 22:21:12 brad Exp $ */
d99 2
@


1.9
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.8 2005/01/27 21:49:53 dlg Exp $ */
d129 1
a129 1
	char				 devinfo[1024];
d141 1
a141 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d143 2
a144 1
	printf("%s: %s\n", USBDEVNAME(sc->cdce_dev), devinfo);
@


1.8
log
@align the buffer when it is allocated, rather than realign the data in it
after we recieve it.

the crc is little endian, so always transmit it in that byteorder. this lets
me talk to a zaurus with a sparc64.

ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.7 2005/01/23 03:32:35 drahn Exp $ */
d348 1
a394 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.7
log
@Allow this to work on __STRICT_ALIGN archs, ok dhartmei@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.6 2004/11/10 10:14:48 grange Exp $ */
d547 2
a649 6
#ifdef __STRICT_ALIGNMENT
	bcopy(m->m_data, m->m_data + ETHER_ALIGN,
	    total_len);
	m->m_data += ETHER_ALIGN;
#endif

d827 1
a827 1
	return (crc ^ ~0U);
@


1.6
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.5 2004/09/23 17:45:17 brad Exp $ */
d647 7
@


1.5
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.4 2004/07/21 15:54:54 deraadt Exp $ */
d235 1
a235 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->cdce_dev), IFNAMSIZ);
@


1.4
log
@spacing
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.3 2004/07/21 15:49:43 dhartmei Exp $ */
a230 1
	ifp->if_mtu = ETHERMTU;
@


1.3
log
@use cdce_ prefix on crc32 function and table name to avoid conflicts,
suggested by mickey
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.2 2004/07/21 08:00:24 dhartmei Exp $ */
d52 1
a52 1
#include <sys/device.h> 
d115 1
a115 1
    
d181 1
a181 1
    
d519 1
a519 1
    
d531 1
a531 1
	    		printf("%s: no memory for rx list "
d537 1
a537 1
	    		printf("%s: no memory for rx list "
@


1.2
log
@add crc32(), ether_crc32_[b|l]e() doesn't work here. should make it work
with Zaurus.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_cdce.c,v 1.1 2004/07/20 20:30:09 dhartmei Exp $ */
d90 1
a90 1
static uint32_t	 crc32(const void *, size_t);
d322 1
a322 1
		crc = crc32(c->cdce_buf, m->m_pkthdr.len);
d767 1
a767 1
uint32_t crc32_tab[] = {
d814 1
a814 1
crc32(const void *buf, size_t size)
d823 1
a823 1
		crc = crc32_tab[(crc ^ *p++) & 0xFF] ^ (crc >> 8);
@


1.1
log
@Driver for USB CDC Ethernet devices (USB Host-to-Host), appearing as
network interfaces, transporting Ethernet, supporting Sharp Zaurus and
Prolific PL-2501 (external cable). Written by Craig Boston based on code
from Bill Paul. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d90 1
d322 1
a322 1
		crc = ether_crc32_le(c->cdce_buf, m->m_pkthdr.len);
d760 66
@

