head	1.29;
access;
symbols
	OPENBSD_6_2:1.29.0.14
	OPENBSD_6_2_BASE:1.29
	OPENBSD_6_1:1.29.0.12
	OPENBSD_6_1_BASE:1.29
	OPENBSD_6_0:1.29.0.10
	OPENBSD_6_0_BASE:1.29
	OPENBSD_5_9:1.29.0.4
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.29.0.6
	OPENBSD_5_8_BASE:1.29
	OPENBSD_5_7:1.29.0.2
	OPENBSD_5_7_BASE:1.29
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.21.0.2
	OPENBSD_5_4_BASE:1.21
	OPENBSD_5_3:1.17.0.20
	OPENBSD_5_3_BASE:1.17
	OPENBSD_5_2:1.17.0.18
	OPENBSD_5_2_BASE:1.17
	OPENBSD_5_1_BASE:1.17
	OPENBSD_5_1:1.17.0.16
	OPENBSD_5_0:1.17.0.14
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.17.0.12
	OPENBSD_4_9_BASE:1.17
	OPENBSD_4_8:1.17.0.10
	OPENBSD_4_8_BASE:1.17
	OPENBSD_4_7:1.17.0.6
	OPENBSD_4_7_BASE:1.17
	OPENBSD_4_6:1.17.0.8
	OPENBSD_4_6_BASE:1.17
	OPENBSD_4_5:1.17.0.4
	OPENBSD_4_5_BASE:1.17
	OPENBSD_4_4:1.17.0.2
	OPENBSD_4_4_BASE:1.17
	OPENBSD_4_3:1.16.0.4
	OPENBSD_4_3_BASE:1.16
	OPENBSD_4_2:1.16.0.2
	OPENBSD_4_2_BASE:1.16
	OPENBSD_4_1:1.14.0.8
	OPENBSD_4_1_BASE:1.14
	OPENBSD_4_0:1.14.0.10
	OPENBSD_4_0_BASE:1.14
	OPENBSD_3_9:1.14.0.6
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.14.0.4
	OPENBSD_3_8_BASE:1.14
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.12
	SMP_SYNC_B:1.12
	OPENBSD_3_5:1.12.0.4
	OPENBSD_3_5_BASE:1.12
	OPENBSD_3_4:1.12.0.2
	OPENBSD_3_4_BASE:1.12
	UBC_SYNC_A:1.11
	OPENBSD_3_3:1.11.0.4
	OPENBSD_3_3_BASE:1.11
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.8.0.4
	OPENBSD_3_1_BASE:1.8
	UBC_SYNC_B:1.11
	UBC:1.8.0.2
	UBC_BASE:1.8
	OPENBSD_3_0:1.7.0.4
	OPENBSD_3_0_BASE:1.7
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5
	SMP:1.3.0.4
	SMP_BASE:1.3
	kame_19991208:1.3
	OPENBSD_2_6:1.3.0.2
	OPENBSD_2_6_BASE:1.3;
locks; strict;
comment	@ * @;


1.29
date	2014.12.08.22.00.11;	author mpi;	state Exp;
branches;
next	1.28;
commitid	S4AL2dWdKDpjf5ru;

1.28
date	2014.11.07.13.56.29;	author mpi;	state Exp;
branches;
next	1.27;
commitid	gYNQMCaIWvIlAGBb;

1.27
date	2014.08.08.14.20.05;	author mpi;	state Exp;
branches;
next	1.26;
commitid	HPvxK5z15RUEsAkp;

1.26
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.25;
commitid	d8ZHVs7unt3KxWXc;

1.25
date	2014.04.24.09.40.28;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2014.03.07.18.57.23;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.02.12.23.58;	author mpi;	state Exp;
branches;
next	1.22;

1.22
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.21;

1.21
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.10.07.48.36;	author mpi;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.10.07.37.32;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2013.04.09.08.42.48;	author mpi;	state Exp;
branches;
next	1.17;

1.17
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.09.12.03.39;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.31.12.10.52;	author dlg;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.21.00.01.08;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.31.04.24.45;	author nate;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.11.44.26;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.03.28.19.37.53;	author aaron;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches
	1.3.4.1;
next	1.2;

1.2
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.05;	author fgsch;	state Exp;
branches;
next	;

1.3.4.1
date	2001.05.14.22.26.26;	author niklas;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.3.4.3;

1.3.4.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.3.4.4;

1.3.4.4
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.8.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	;


desc
@@


1.29
log
@Deprecate usb_*_report().  USB HID devices are always attached below
an uhidev(4) on OpenBSD and there is not point in rerolling your own
reportID handling.  Simply use uhidev_*_report().

This is a first step towards better error handling required to deal
with broken upd(4) firmwares.

Tested by David Higgs.
@
text
@/*	$OpenBSD: usbdi_util.h,v 1.28 2014/11/07 13:56:29 mpi Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.28 2002/07/11 21:14:36 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi_util.h,v 1.9 1999/11/17 22:33:50 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

usbd_status	usbd_get_desc(struct usbd_device *dev, int type,
		    int index, int len, void *desc);
usbd_status	usbd_get_port_status(struct usbd_device *,
		    int, usb_port_status_t *);
usbd_status	usbd_set_hub_depth(struct usbd_device *, int);
usbd_status	usbd_set_hub_feature(struct usbd_device *dev, int);
usbd_status	usbd_clear_hub_feature(struct usbd_device *, int);
usbd_status	usbd_set_port_feature(struct usbd_device *dev, int, int);
usbd_status	usbd_clear_port_feature(struct usbd_device *, int, int);
usbd_status	usbd_get_device_status(struct usbd_device *, usb_status_t *);
usbd_status	usbd_get_hub_status(struct usbd_device *, usb_hub_status_t *);
usbd_status	usbd_get_hub_descriptor(struct usbd_device *,
		    usb_hub_descriptor_t *, uint8_t);
usbd_status	usbd_get_hub_ss_descriptor(struct usbd_device *,
		    usb_hub_ss_descriptor_t *, uint8_t);
struct usb_hid_descriptor *usbd_get_hid_descriptor(struct usbd_device *,
		   usb_interface_descriptor_t *);
usbd_status	usbd_set_idle(struct usbd_device *, int, int, int);
usbd_status	usbd_get_report_descriptor(struct usbd_device *, int, void *,
		    int);
usbd_status	usbd_get_config(struct usbd_device *dev, u_int8_t *conf);
usbd_status	usbd_get_string_desc(struct usbd_device *dev, int sindex,
		    int langid,usb_string_descriptor_t *sdesc, int *sizep);
void		usbd_delay_ms(struct usbd_device *, u_int);


usbd_status	usbd_set_config_no(struct usbd_device *dev, int no, int msg);
usbd_status	usbd_set_config_index(struct usbd_device *dev, int index,
		    int msg);

void usb_detach_wait(struct device *);
void usb_detach_wakeup(struct device *);
@


1.28
log
@Give Super-Speed hubs a chance to route USB 3.0 transfers.

Without knowing their depth, hubs couldn't find the bits correspdonding
to their downstream port in the route-string.  Now USB 3.0 devices just
work(tm) anywhere in your hub chain.

This commit would not have been possible without the cheese provided by
miod@@ at #HAMoween.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.27 2014/08/08 14:20:05 mpi Exp $ */
a51 6
usbd_status	usbd_get_report(struct usbd_device *, int, int, int, void *,
		    int);
usbd_status	usbd_set_report(struct usbd_device *, int, int, int, void *,
		    int);
usbd_status	usbd_set_report_async(struct usbd_device *, int, int, int,
		    void *, int);
@


1.27
log
@Super Speed hub descriptor definition and routine, required for upcoming
external USB 3.0 hub support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.26 2014/07/09 15:47:54 mpi Exp $ */
d39 1
@


1.26
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.25 2014/04/24 09:40:28 mpi Exp $ */
d47 2
@


1.25
log
@Change the usbd_*_report() family of functions to take a usbd_device
and a infaceno argument instead of an iface pointer.  While here,
remove some unused functions and inlined usbd_read_report_desc since
it is used only once.

This is part of plumbing required to convert the various USB HID devices
to handle multiples report IDs.

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.24 2014/03/07 18:57:23 mpi Exp $ */
a36 1
usbd_status	usbd_set_address(struct usbd_device *dev, int addr);
@


1.24
log
@Indtroduce usbd_get_hub_descriptor() to start cleaning uhub(4)'s mess.
This will help us deal with the different hub device descriptors used
by super speed devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.23 2013/11/02 12:23:58 mpi Exp $ */
d48 11
a58 14
usbd_status	usbd_get_protocol(struct usbd_interface *dev, u_int8_t *report);
usbd_status	usbd_set_protocol(struct usbd_interface *dev, int report);
usbd_status	usbd_get_report_descriptor(struct usbd_device *dev, int ifcno,
		    int size, void *d);
struct usb_hid_descriptor *usbd_get_hid_descriptor(struct usbd_interface *ifc);
usbd_status	usbd_set_report(struct usbd_interface *iface, int type, int id,
		    void *data,int len);
usbd_status	usbd_set_report_async(struct usbd_interface *iface, int type,
		    int id, void *data, int len);
usbd_status	usbd_get_report(struct usbd_interface *iface, int type, int id,
		    void *data, int len);
usbd_status	usbd_set_idle(struct usbd_interface *iface, int duration,int id);
usbd_status	usbd_read_report_desc(struct usbd_interface *ifc, void **descp,
		    int *sizep, int mem);
@


1.23
log
@Remove a layer of abstraction for fetching a configuration descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.22 2013/09/20 15:34:51 mpi Exp $ */
d46 2
@


1.22
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.21 2013/04/15 09:23:02 mglocker Exp $ */
a36 2
usbd_status	usbd_get_config_desc(struct usbd_device *, int,
		    usb_config_descriptor_t *);
@


1.21
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.20 2013/04/10 07:48:36 mpi Exp $ */
a70 8

usbd_status	usbd_bulk_transfer(struct usbd_xfer *xfer,
		    struct usbd_pipe *pipe, u_int16_t flags, u_int32_t timeout,
		    void *buf, u_int32_t *size, char *lbl);

usbd_status	usbd_intr_transfer(struct usbd_xfer *xfer,
		    struct usbd_pipe *pipe, u_int16_t flags, u_int32_t timeout,
		    void *buf, u_int32_t *size, char *lbl);
@


1.20
log
@Merge usbd_get_device_desc() into the only function using them.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.19 2013/04/10 07:37:32 mpi Exp $ */
d35 1
a35 1
usbd_status	usbd_get_desc(usbd_device_handle dev, int type,
d37 1
a37 1
usbd_status	usbd_get_config_desc(usbd_device_handle, int,
d39 2
a40 2
usbd_status	usbd_set_address(usbd_device_handle dev, int addr);
usbd_status	usbd_get_port_status(usbd_device_handle,
d42 9
a50 9
usbd_status	usbd_set_hub_feature(usbd_device_handle dev, int);
usbd_status	usbd_clear_hub_feature(usbd_device_handle, int);
usbd_status	usbd_set_port_feature(usbd_device_handle dev, int, int);
usbd_status	usbd_clear_port_feature(usbd_device_handle, int, int);
usbd_status	usbd_get_device_status(usbd_device_handle, usb_status_t *);
usbd_status	usbd_get_hub_status(usbd_device_handle, usb_hub_status_t *);
usbd_status	usbd_get_protocol(usbd_interface_handle dev, u_int8_t *report);
usbd_status	usbd_set_protocol(usbd_interface_handle dev, int report);
usbd_status	usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
d52 2
a53 2
struct usb_hid_descriptor *usbd_get_hid_descriptor(usbd_interface_handle ifc);
usbd_status	usbd_set_report(usbd_interface_handle iface, int type, int id,
d55 1
a55 1
usbd_status	usbd_set_report_async(usbd_interface_handle iface, int type,
d57 1
a57 1
usbd_status	usbd_get_report(usbd_interface_handle iface, int type, int id,
d59 2
a60 2
usbd_status	usbd_set_idle(usbd_interface_handle iface, int duration,int id);
usbd_status	usbd_read_report_desc(usbd_interface_handle ifc, void **descp,
d62 2
a63 2
usbd_status	usbd_get_config(usbd_device_handle dev, u_int8_t *conf);
usbd_status	usbd_get_string_desc(usbd_device_handle dev, int sindex,
d65 1
a65 1
void		usbd_delay_ms(usbd_device_handle, u_int);
d68 2
a69 2
usbd_status	usbd_set_config_no(usbd_device_handle dev, int no, int msg);
usbd_status	usbd_set_config_index(usbd_device_handle dev, int index,
d72 2
a73 2
usbd_status	usbd_bulk_transfer(usbd_xfer_handle xfer,
		    usbd_pipe_handle pipe, u_int16_t flags, u_int32_t timeout,
d76 2
a77 2
usbd_status	usbd_intr_transfer(usbd_xfer_handle xfer,
		    usbd_pipe_handle pipe, u_int16_t flags, u_int32_t timeout,
@


1.19
log
@Remove unused function usb_find_desc().
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.18 2013/04/09 08:42:48 mpi Exp $ */
a38 2
usbd_status	usbd_get_device_desc(usbd_device_handle dev,
		    usb_device_descriptor_t *d);
@


1.18
log
@There's no need for usbd_get_config_desc_full() so just call usbd_get_desc()
directly this also makes it easier to understand which function actually
generates IO.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.17 2008/06/26 05:42:19 ray Exp $ */
a83 2

usb_descriptor_t *usb_find_desc(usbd_device_handle dev, int type);
@


1.17
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.16 2007/06/12 16:26:37 mbalmer Exp $ */
a38 1
usbd_status	usbd_get_config_desc_full(usbd_device_handle, int, void *, int);
@


1.16
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.15 2007/06/09 12:03:39 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.15
log
@Remove the definition and use of usb_malloc_type which is really int.
While here, reindent the function prototypes in usbdi_util.h

No binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.14 2004/10/31 12:10:52 dlg Exp $ */
d90 2
a91 2
void usb_detach_wait(device_ptr_t);
void usb_detach_wakeup(device_ptr_t);
@


1.14
log
@from netbsd via freebsd via jsg@@

usbdi_util.h (1.29), uhid.c (1.62), ugen.c (1.68), usb_subr.c (1.114)
   Yes, some devices return incorrect lengths in their string
   descriptors.  Rather than losing, do what Windows does: just
   request the maximum size, and allow a shorter response.  Obsoletes
   the need for UQ_NO_STRINGS, and therefore these "quirks" are removed.

usb_subr.c (1.116)
    In the "seemed like a good idea until I found the fatal flaw"
    department...  Attempting to read a maximum-size string descriptor
    causes my kue device to go completely apeshit.  So, go back to the
    original method, but allow the device to return a shorter string than
    it claimed.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.13 2004/07/21 00:01:08 dlg Exp $ */
d43 1
a43 1
			      int index, int len, void *desc);
d45 1
a45 1
				     usb_config_descriptor_t *);
d48 1
a48 1
				     usb_device_descriptor_t *d);
d51 1
a51 1
				     int, usb_port_status_t *);
d61 1
a61 1
					   int size, void *d);
d64 1
a64 1
				void *data,int len);
d66 1
a66 1
				      int id, void *data, int len);
d68 1
a68 1
				void *data, int len);
d71 1
a71 1
				       int *sizep, usb_malloc_type mem);
d74 1
a74 2
				     int langid,usb_string_descriptor_t *sdesc,
			 	     int *sizep);
d78 11
a88 10
usbd_status usbd_set_config_no(usbd_device_handle dev, int no, int msg);
usbd_status usbd_set_config_index(usbd_device_handle dev, int index, int msg);

usbd_status usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
			       u_int16_t flags, u_int32_t timeout, void *buf,
			       u_int32_t *size, char *lbl);

usbd_status usbd_intr_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
 			       u_int16_t flags, u_int32_t timeout, void *buf,
 			       u_int32_t *size, char *lbl);
@


1.13
log
@from freebsd, ugen.c 1.68 usbdi_util.c 1.27 usbdi_util.h 1.15
log message:
Implement outgoing interrupt pipes. It is part of the USB 1.1 spec.
The Lego Infrared Tower use it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.12 2003/07/08 13:19:09 nate Exp $ */
d74 2
a75 1
				     int langid,usb_string_descriptor_t *sdesc);
@


1.12
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.11 2002/07/25 02:18:11 nate Exp $ */
d84 4
@


1.11
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.h,v 1.10 2002/05/07 18:29:19 nate Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.23 2001/10/26 17:58:22 augustss Exp $	*/
d56 1
a56 1
usbd_status	usbd_get_device_status(usbd_device_handle,usb_status_t*);
d58 1
d88 1
@


1.10
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.8 2001/10/31 04:24:45 nate Exp $ */
d42 1
a42 1
usbd_status	usbd_get_desc(usbd_device_handle dev, int type, 
d44 1
a44 1
usbd_status	usbd_get_config_desc(usbd_device_handle, int, 
d50 1
a50 1
usbd_status	usbd_get_port_status(usbd_device_handle, 
@


1.9
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi_util.h,v 1.27 2002/03/17 18:02:53 augustss Exp $	*/
d56 1
a56 1
usbd_status	usbd_get_device_status(usbd_device_handle, usb_status_t *);
a57 1
usbd_status	usbd_get_protocol(usbd_interface_handle dev, u_int8_t *report);
a86 1
usb_descriptor_t *usb_find_desc(usbd_device_handle dev, int type);
@


1.8
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.h,v 1.7 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.23 2001/10/26 17:58:22 augustss Exp $	*/
d56 1
a56 1
usbd_status	usbd_get_device_status(usbd_device_handle,usb_status_t*);
d58 1
d88 1
@


1.8.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.8 2001/10/31 04:24:45 nate Exp $ */
@


1.8.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.8.2.1 2002/06/11 03:42:31 art Exp $ */
d42 1
a42 1
usbd_status	usbd_get_desc(usbd_device_handle dev, int type,
d44 1
a44 1
usbd_status	usbd_get_config_desc(usbd_device_handle, int,
d50 1
a50 1
usbd_status	usbd_get_port_status(usbd_device_handle,
@


1.7
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.h,v 1.6 2000/07/04 11:44:26 fgsch Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.22 2000/06/01 14:37:52 augustss Exp $	*/
d60 1
a60 1
					   int repid, int size, void *d);
d69 1
a69 1
usbd_status	usbd_alloc_report_desc(usbd_interface_handle ifc, void **descp,
@


1.6
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.h,v 1.5 2000/03/28 19:37:53 aaron Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.19 1999/11/18 23:32:37 augustss Exp $	*/
d42 41
a82 50
usbd_status	usbd_get_desc __P((usbd_device_handle dev, int type, 
				   int index, int len, void *desc));
usbd_status	usbd_get_config_desc __P((usbd_device_handle, int, 
					  usb_config_descriptor_t *));
usbd_status	usbd_get_config_desc_full __P((usbd_device_handle, int, 
					       void *, int));
usbd_status	usbd_get_device_desc __P((usbd_device_handle dev,
					  usb_device_descriptor_t *d));
usbd_status	usbd_set_address __P((usbd_device_handle dev, int addr));
usbd_status	usbd_get_port_status __P((usbd_device_handle, 
				      int, usb_port_status_t *));
usbd_status	usbd_set_hub_feature __P((usbd_device_handle dev, int));
usbd_status	usbd_clear_hub_feature __P((usbd_device_handle, int));
usbd_status	usbd_set_port_feature __P((usbd_device_handle dev, int, int));
usbd_status	usbd_clear_port_feature __P((usbd_device_handle, int, int));
usbd_status	usbd_get_device_status __P((usbd_device_handle,usb_status_t*));
usbd_status	usbd_get_hub_status __P((usbd_device_handle dev,
					 usb_hub_status_t *st));
usbd_status	usbd_set_protocol __P((usbd_interface_handle dev, int report));
usbd_status	usbd_get_report_descriptor
	__P((usbd_device_handle dev, int ifcno, int repid, int size, void *d));
struct usb_hid_descriptor *usbd_get_hid_descriptor 
	__P((usbd_interface_handle ifc));
usbd_status	usbd_set_report 
	__P((usbd_interface_handle iface,int type,int id,void *data,int len));
usbd_status	usbd_set_report_async
	__P((usbd_interface_handle iface,int type,int id,void *data,int len));
usbd_status	usbd_get_report 
	__P((usbd_interface_handle iface,int type,int id,void *data,int len));
usbd_status	usbd_set_idle 
	__P((usbd_interface_handle iface, int duration, int id));
usbd_status	usbd_alloc_report_desc
	__P((usbd_interface_handle ifc, void **descp, int *sizep,
	     usb_malloc_type mem));
usbd_status	usbd_get_config
	__P((usbd_device_handle dev, u_int8_t *conf));
usbd_status	usbd_get_string_desc
	__P((usbd_device_handle dev, int sindex, int langid, 
	     usb_string_descriptor_t *sdesc));
void		usbd_delay_ms __P((usbd_device_handle, u_int));


usbd_status usbd_set_config_no
	__P((usbd_device_handle dev, int no, int msg));
usbd_status usbd_set_config_index
	__P((usbd_device_handle dev, int index, int msg));

usbd_status usbd_bulk_transfer
	__P((usbd_xfer_handle xfer, usbd_pipe_handle pipe, u_int16_t flags,
	     u_int32_t timeout, void *buf, u_int32_t *size, char *lbl));
d84 2
a85 2
void usb_detach_wait __P((device_ptr_t));
void usb_detach_wakeup __P((device_ptr_t));
@


1.5
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
a72 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d74 2
a75 5
	__P((usbd_interface_handle ifc, void **descp, int *sizep, int mem));
#elif defined(__FreeBSD__)
usbd_status	usbd_alloc_report_desc
	__P((usbd_interface_handle ifc, void **descp, int *sizep, struct malloc_type * mem));
#endif
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi_util.h,v 1.3 1999/09/27 18:03:56 fgsch Exp $	*/
d3 1
@


1.3
log
@Sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usbdi_util.h,v 1.17 1999/09/05 19:32:19 augustss Exp $	*/
d93 1
a93 1
	__P((usbd_request_handle reqh, usbd_pipe_handle pipe, u_int16_t flags,
@


1.3.4.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usbdi_util.h,v 1.7 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi_util.h,v 1.22 2000/06/01 14:37:52 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi_util.h,v 1.9 1999/11/17 22:33:50 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d41 54
a94 41
usbd_status	usbd_get_desc(usbd_device_handle dev, int type, 
			      int index, int len, void *desc);
usbd_status	usbd_get_config_desc(usbd_device_handle, int, 
				     usb_config_descriptor_t *);
usbd_status	usbd_get_config_desc_full(usbd_device_handle, int, void *, int);
usbd_status	usbd_get_device_desc(usbd_device_handle dev,
				     usb_device_descriptor_t *d);
usbd_status	usbd_set_address(usbd_device_handle dev, int addr);
usbd_status	usbd_get_port_status(usbd_device_handle, 
				     int, usb_port_status_t *);
usbd_status	usbd_set_hub_feature(usbd_device_handle dev, int);
usbd_status	usbd_clear_hub_feature(usbd_device_handle, int);
usbd_status	usbd_set_port_feature(usbd_device_handle dev, int, int);
usbd_status	usbd_clear_port_feature(usbd_device_handle, int, int);
usbd_status	usbd_get_device_status(usbd_device_handle,usb_status_t*);
usbd_status	usbd_get_hub_status(usbd_device_handle, usb_hub_status_t *);
usbd_status	usbd_set_protocol(usbd_interface_handle dev, int report);
usbd_status	usbd_get_report_descriptor(usbd_device_handle dev, int ifcno,
					   int repid, int size, void *d);
struct usb_hid_descriptor *usbd_get_hid_descriptor(usbd_interface_handle ifc);
usbd_status	usbd_set_report(usbd_interface_handle iface, int type, int id,
				void *data,int len);
usbd_status	usbd_set_report_async(usbd_interface_handle iface, int type,
				      int id, void *data, int len);
usbd_status	usbd_get_report(usbd_interface_handle iface, int type, int id,
				void *data, int len);
usbd_status	usbd_set_idle(usbd_interface_handle iface, int duration,int id);
usbd_status	usbd_alloc_report_desc(usbd_interface_handle ifc, void **descp,
				       int *sizep, usb_malloc_type mem);
usbd_status	usbd_get_config(usbd_device_handle dev, u_int8_t *conf);
usbd_status	usbd_get_string_desc(usbd_device_handle dev, int sindex,
				     int langid,usb_string_descriptor_t *sdesc);
void		usbd_delay_ms(usbd_device_handle, u_int);


usbd_status usbd_set_config_no(usbd_device_handle dev, int no, int msg);
usbd_status usbd_set_config_index(usbd_device_handle dev, int index, int msg);

usbd_status usbd_bulk_transfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
			       u_int16_t flags, u_int32_t timeout, void *buf,
			       u_int32_t *size, char *lbl);
d96 2
a97 2
void usb_detach_wait(device_ptr_t);
void usb_detach_wakeup(device_ptr_t);
@


1.3.4.2
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi_util.h,v 1.23 2001/10/26 17:58:22 augustss Exp $	*/
d60 1
a60 1
					   int size, void *d);
d69 1
a69 1
usbd_status	usbd_read_report_desc(usbd_interface_handle ifc, void **descp,
@


1.3.4.3
log
@Sync the SMP branch with 3.3
@
text
@d42 1
a42 1
usbd_status	usbd_get_desc(usbd_device_handle dev, int type,
d44 1
a44 1
usbd_status	usbd_get_config_desc(usbd_device_handle, int,
d50 1
a50 1
usbd_status	usbd_get_port_status(usbd_device_handle,
@


1.3.4.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi_util.h,v 1.28 2002/07/11 21:14:36 augustss Exp $	*/
d56 1
a56 1
usbd_status	usbd_get_device_status(usbd_device_handle, usb_status_t *);
a57 1
usbd_status	usbd_get_protocol(usbd_interface_handle dev, u_int8_t *report);
a86 1
usb_descriptor_t *usb_find_desc(usbd_device_handle dev, int type);
@


1.2
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi_util.h,v 1.1 1999/08/13 05:28:05 fgsch Exp $	*/
/*	$NetBSD: usbdi_util.h,v 1.14 1999/08/07 23:14:17 augustss Exp $	*/
d96 2
a97 2
void usb_detach_wait __P((bdevice *));
void usb_detach_wakeup __P((bdevice *));
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 1
a94 1
	     void *buf, u_int32_t *size, char *lbl));
@

