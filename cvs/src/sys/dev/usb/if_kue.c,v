head	1.87;
access;
symbols
	OPENBSD_6_1_BASE:1.87
	OPENBSD_6_0:1.85.0.4
	OPENBSD_6_0_BASE:1.85
	OPENBSD_5_9:1.84.0.2
	OPENBSD_5_9_BASE:1.84
	OPENBSD_5_8:1.80.0.4
	OPENBSD_5_8_BASE:1.80
	OPENBSD_5_7:1.77.0.2
	OPENBSD_5_7_BASE:1.77
	OPENBSD_5_6:1.74.0.4
	OPENBSD_5_6_BASE:1.74
	OPENBSD_5_5:1.71.0.4
	OPENBSD_5_5_BASE:1.71
	OPENBSD_5_4:1.67.0.2
	OPENBSD_5_4_BASE:1.67
	OPENBSD_5_3:1.64.0.8
	OPENBSD_5_3_BASE:1.64
	OPENBSD_5_2:1.64.0.6
	OPENBSD_5_2_BASE:1.64
	OPENBSD_5_1_BASE:1.64
	OPENBSD_5_1:1.64.0.4
	OPENBSD_5_0:1.64.0.2
	OPENBSD_5_0_BASE:1.64
	OPENBSD_4_9:1.63.0.2
	OPENBSD_4_9_BASE:1.63
	OPENBSD_4_8:1.59.0.4
	OPENBSD_4_8_BASE:1.59
	OPENBSD_4_7:1.59.0.2
	OPENBSD_4_7_BASE:1.59
	OPENBSD_4_6:1.58.0.6
	OPENBSD_4_6_BASE:1.58
	OPENBSD_4_5:1.58.0.2
	OPENBSD_4_5_BASE:1.58
	OPENBSD_4_4:1.56.0.4
	OPENBSD_4_4_BASE:1.56
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.55.0.2
	OPENBSD_4_2_BASE:1.55
	OPENBSD_4_1:1.44.0.2
	OPENBSD_4_1_BASE:1.44
	OPENBSD_4_0:1.42.0.4
	OPENBSD_4_0_BASE:1.42
	OPENBSD_3_9:1.39.0.2
	OPENBSD_3_9_BASE:1.39
	OPENBSD_3_8:1.38.0.2
	OPENBSD_3_8_BASE:1.38
	OPENBSD_3_7:1.35.0.2
	OPENBSD_3_7_BASE:1.35
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.25
	SMP_SYNC_B:1.25
	OPENBSD_3_5:1.24.0.2
	OPENBSD_3_5_BASE:1.24
	OPENBSD_3_4:1.23.0.2
	OPENBSD_3_4_BASE:1.23
	UBC_SYNC_A:1.23
	OPENBSD_3_3:1.22.0.4
	OPENBSD_3_3_BASE:1.22
	OPENBSD_3_2:1.22.0.2
	OPENBSD_3_2_BASE:1.22
	OPENBSD_3_1:1.16.0.2
	OPENBSD_3_1_BASE:1.16
	UBC_SYNC_B:1.22
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	SMP:1.10.0.2
	OPENBSD_2_9_BASE:1.9
	OPENBSD_2_9:1.9.0.2
	OPENBSD_2_8:1.5.0.4
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.87
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.86;
commitid	x5RWYO05Q3UFL5Oq;

1.86
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.85;
commitid	VyLWTsbepAOk7VQM;

1.85
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.84;
commitid	gWZDkudwxydTq8x4;

1.84
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.83;
commitid	fbhqfhfdKxBcsetK;

1.83
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.82;
commitid	B0kwmVGiD5DVx4kv;

1.82
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.81;
commitid	eYnPulzvLjDImPCa;

1.81
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.80;
commitid	pwYnMC1gOKohmeGw;

1.80
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.79;
commitid	MVWrtktB46JRxFWT;

1.79
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.78;
commitid	aqezguXMYUVIGMPW;

1.78
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.77;
commitid	p4LJxGKbi0BU2cG6;

1.77
date	2015.02.04.05.12.13;	author mpi;	state Exp;
branches;
next	1.76;
commitid	kJMgw6D3PQCR1sKa;

1.76
date	2015.01.11.02.59.59;	author deraadt;	state Exp;
branches;
next	1.75;
commitid	RCUdDbnfjJ8lCApj;

1.75
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.74;
commitid	yM2VFFhpDTeFQlve;

1.74
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.73;
commitid	Pclvgy2Z4XV9hveD;

1.73
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.72;
commitid	OBNa5kfxQ2UXoiIw;

1.72
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.71;
commitid	b0VSac5dnnsxcDao;

1.71
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.70;

1.70
date	2013.11.11.12.38.39;	author pirofti;	state Exp;
branches;
next	1.69;

1.69
date	2013.11.05.10.20.04;	author mpi;	state Exp;
branches;
next	1.68;

1.68
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.67;

1.67
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.66;

1.66
date	2013.04.10.07.46.24;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.64;

1.64
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2010.12.17.13.48.06;	author jasper;	state Exp;
branches;
next	1.61;

1.61
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.60;

1.60
date	2010.09.24.08.33.58;	author yuo;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.57;

1.57
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.56;

1.56
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.54;

1.54
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.53;

1.53
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.51;

1.51
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.48;

1.48
date	2007.05.31.00.34.11;	author maja;	state Exp;
branches;
next	1.47;

1.47
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.46;

1.46
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.45;

1.45
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.43;

1.43
date	2007.01.09.16.30.08;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.41;

1.41
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.40;

1.40
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.39;

1.39
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.35;

1.35
date	2005.01.15.03.53.36;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.12.06.21.35;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2004.11.28.02.14.55;	author deraadt;	state Exp;
branches;
next	1.31;

1.31
date	2004.11.22.18.59.39;	author dhartmei;	state Exp;
branches;
next	1.30;

1.30
date	2004.11.22.18.49.05;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.16.01.22.52;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.06.02.06.30.28;	author mcbride;	state Exp;
branches;
next	1.24;

1.24
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.23;

1.23
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.29.02.38.54;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2002.07.09.16.44.15;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.06.26.11.29.55;	author espie;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.06.05.34.39;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2001.12.17.02.18.18;	author deraadt;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.12.17.01.39.08;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.08.23.38.08;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.27.06.34.53;	author kjc;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.03.02.20.32;	author aaron;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2001.02.20.19.39.46;	author mickey;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.30.21.07.27;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.12.05.21.37.39;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.23.17.33.47;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.04.22.52.30;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.30.16.19.32;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.28.19.37.47;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.26.18.49.44;	author aaron;	state Exp;
branches;
next	;

1.10.2.1
date	2001.05.14.22.26.19;	author niklas;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.07.04.10.43.43;	author niklas;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.10.2.4;

1.10.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.10.2.5;

1.10.2.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.10.2.6;

1.10.2.6
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.10.2.7;

1.10.2.7
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.10.2.8;

1.10.2.8
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.10.2.9;

1.10.2.9
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.10.2.10;

1.10.2.10
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.87
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@/*	$OpenBSD: if_kue.c,v 1.86 2017/01/22 10:17:39 dlg Exp $ */
/*	$NetBSD: if_kue.c,v 1.50 2002/07/16 22:00:31 augustss Exp $	*/
/*
 * Copyright (c) 1997, 1998, 1999, 2000
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/usb/if_kue.c,v 1.14 2000/01/14 01:36:15 wpaul Exp $
 */

/*
 * Kawasaki LSI KL5KUSB101B USB to ethernet adapter driver.
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The KLSI USB to ethernet adapter chip contains an USB serial interface,
 * ethernet MAC and embedded microcontroller (called the QT Engine).
 * The chip must have firmware loaded into it before it will operate.
 * Packets are passed between the chip and host via bulk transfers.
 * There is an interrupt endpoint mentioned in the software spec, however
 * it's currently unused. This device is 10Mbps half-duplex only, hence
 * there is no media selection logic. The MAC supports a 128 entry
 * multicast filter, though the exact size of the filter can depend
 * on the firmware. Curiously, while the software spec describes various
 * ethernet statistics counters, my sample adapter and firmware combination
 * claims not to support any statistics counters at all.
 *
 * Note that once we load the firmware in the device, we have to be
 * careful not to load it again: if you restart your computer but
 * leave the adapter attached to the USB controller, it may remain
 * powered on and retain its firmware. In this case, we don't need
 * to load the firmware a second time.
 *
 * Special thanks to Rob Furr for providing an ADS Technologies
 * adapter for development and testing. No monkeys were harmed during
 * the development of this driver.
 */

/*
 * Ported to NetBSD and somewhat rewritten by Lennart Augustsson.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>

#include <net/if.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_kuereg.h>
#include <dev/usb/if_kuevar.h>

#ifdef KUE_DEBUG
#define DPRINTF(x)	do { if (kuedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (kuedebug >= (n)) printf x; } while (0)
int	kuedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
const struct usb_devno kue_devs[] = {
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C19250 },
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C460 },
	{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_URE450 },
	{ USB_VENDOR_ADS, USB_PRODUCT_ADS_UBS10BT },
	{ USB_VENDOR_ADS, USB_PRODUCT_ADS_UBS10BTX },
	{ USB_VENDOR_AOX, USB_PRODUCT_AOX_USB101 },
	{ USB_VENDOR_ASANTE, USB_PRODUCT_ASANTE_EA },
	{ USB_VENDOR_ATEN, USB_PRODUCT_ATEN_UC10T },
	{ USB_VENDOR_ATEN, USB_PRODUCT_ATEN_DSB650C },
	{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_ETHER_USB_T },
	{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DSB650C },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_E45 },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_XX1 },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_XX2 },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBETT },
	{ USB_VENDOR_JATON, USB_PRODUCT_JATON_EDA },
	{ USB_VENDOR_KINGSTON, USB_PRODUCT_KINGSTON_XX1 },
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_DUH3E10BT },
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_DUH3E10BTN },
	{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_USB10T },
	{ USB_VENDOR_MOBILITY, USB_PRODUCT_MOBILITY_EA },
	{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_EA101 },
	{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_EA101X },
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_ENET },
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_ENET2 },
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_ENET3 },
	{ USB_VENDOR_PORTGEAR, USB_PRODUCT_PORTGEAR_EA8 },
	{ USB_VENDOR_PORTGEAR, USB_PRODUCT_PORTGEAR_EA9 },
	{ USB_VENDOR_PORTSMITH, USB_PRODUCT_PORTSMITH_EEA },
	{ USB_VENDOR_SHARK, USB_PRODUCT_SHARK_PA },
	{ USB_VENDOR_SILICOM, USB_PRODUCT_SILICOM_U2E },
	{ USB_VENDOR_SILICOM, USB_PRODUCT_SILICOM_GPE },
	{ USB_VENDOR_SMC, USB_PRODUCT_SMC_2102USB },
};

int kue_match(struct device *, void *, void *);
void kue_attach(struct device *, struct device *, void *);
int kue_detach(struct device *, int);

struct cfdriver kue_cd = {
	NULL, "kue", DV_IFNET
};

const struct cfattach kue_ca = {
	sizeof(struct kue_softc), kue_match, kue_attach, kue_detach
};

int kue_tx_list_init(struct kue_softc *);
int kue_rx_list_init(struct kue_softc *);
int kue_newbuf(struct kue_softc *, struct kue_chain *,struct mbuf *);
int kue_send(struct kue_softc *, struct mbuf *, int);
int kue_open_pipes(struct kue_softc *);
void kue_rxeof(struct usbd_xfer *, void *, usbd_status);
void kue_txeof(struct usbd_xfer *, void *, usbd_status);
void kue_start(struct ifnet *);
int kue_ioctl(struct ifnet *, u_long, caddr_t);
void kue_init(void *);
void kue_stop(struct kue_softc *);
void kue_watchdog(struct ifnet *);

void kue_setmulti(struct kue_softc *);
void kue_reset(struct kue_softc *);

usbd_status kue_ctl(struct kue_softc *, int, u_int8_t,
			   u_int16_t, void *, u_int32_t);
usbd_status kue_setword(struct kue_softc *, u_int8_t, u_int16_t);
int kue_load_fw(struct kue_softc *);
void kue_attachhook(struct device *);

usbd_status
kue_setword(struct kue_softc *sc, u_int8_t breq, u_int16_t word)
{
	usb_device_request_t	req;

	DPRINTFN(10,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = breq;
	USETW(req.wValue, word);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	return (usbd_do_request(sc->kue_udev, &req, NULL));
}

usbd_status
kue_ctl(struct kue_softc *sc, int rw, u_int8_t breq, u_int16_t val,
	void *data, u_int32_t len)
{
	usb_device_request_t	req;

	DPRINTFN(10,("%s: %s: enter, len=%d\n", sc->kue_dev.dv_xname,
		     __func__, len));

	if (rw == KUE_CTL_WRITE)
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	else
		req.bmRequestType = UT_READ_VENDOR_DEVICE;

	req.bRequest = breq;
	USETW(req.wValue, val);
	USETW(req.wIndex, 0);
	USETW(req.wLength, len);

	return (usbd_do_request(sc->kue_udev, &req, data));
}

int
kue_load_fw(struct kue_softc *sc)
{
	usb_device_descriptor_t *dd;
	usbd_status		err;
	struct kue_firmware	*fw;
	u_char			*buf;
	size_t			buflen;

	DPRINTFN(1,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	/*
	 * First, check if we even need to load the firmware.
	 * If the device was still attached when the system was
	 * rebooted, it may already have firmware loaded in it.
	 * If this is the case, we don't need to do it again.
	 * And in fact, if we try to load it again, we'll hang,
	 * so we have to avoid this condition if we don't want
	 * to look stupid.
	 *
	 * We can test this quickly by checking the bcdRevision
	 * code. The NIC will return a different revision code if
	 * it's probed while the firmware is still loaded and
	 * running.
	 */
	if ((dd = usbd_get_device_descriptor(sc->kue_udev)) == NULL)
		return (EIO);
	if (UGETW(dd->bcdDevice) >= KUE_WARM_REV) {
		printf("%s: warm boot, no firmware download\n",
		       sc->kue_dev.dv_xname);
		return (0);
	}

	err = loadfirmware("kue", &buf, &buflen);
	if (err) {
		printf("%s: failed loadfirmware of file %s: errno %d\n",
		    sc->kue_dev.dv_xname, "kue", err);
		return (err);
	}
	fw = (struct kue_firmware *)buf;

	printf("%s: cold boot, downloading firmware\n",
	       sc->kue_dev.dv_xname);

	/* Load code segment */
	DPRINTFN(1,("%s: kue_load_fw: download code_seg\n",
		    sc->kue_dev.dv_xname));
	err = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,
	    0, (void *)&fw->data[0], ntohl(fw->codeseglen));
	if (err) {
		printf("%s: failed to load code segment: %s\n",
		    sc->kue_dev.dv_xname, usbd_errstr(err));
		free(buf, M_DEVBUF, buflen);
		return (EIO);
	}

	/* Load fixup segment */
	DPRINTFN(1,("%s: kue_load_fw: download fix_seg\n",
		    sc->kue_dev.dv_xname));
	err = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,
	    0, (void *)&fw->data[ntohl(fw->codeseglen)], ntohl(fw->fixseglen));
	if (err) {
		printf("%s: failed to load fixup segment: %s\n",
		    sc->kue_dev.dv_xname, usbd_errstr(err));
		free(buf, M_DEVBUF, buflen);
		return (EIO);
	}

	/* Send trigger command. */
	DPRINTFN(1,("%s: kue_load_fw: download trig_seg\n",
		    sc->kue_dev.dv_xname));
	err = kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SEND_SCAN,
	    0, (void *)&fw->data[ntohl(fw->codeseglen) + ntohl(fw->fixseglen)],
	    ntohl(fw->trigseglen));
	if (err) {
		printf("%s: failed to load trigger segment: %s\n",
		    sc->kue_dev.dv_xname, usbd_errstr(err));
		free(buf, M_DEVBUF, buflen);
		return (EIO);
	}
	free(buf, M_DEVBUF, buflen);

	usbd_delay_ms(sc->kue_udev, 10);

	/*
	 * Reload device descriptor.
	 * Why? The chip without the firmware loaded returns
	 * one revision code. The chip with the firmware
	 * loaded and running returns a *different* revision
	 * code. This confuses the quirk mechanism, which is
	 * dependent on the revision data.
	 */
	(void)usbd_reload_device_desc(sc->kue_udev);

	DPRINTFN(1,("%s: %s: done\n", sc->kue_dev.dv_xname, __func__));

	/* Reset the adapter. */
	kue_reset(sc);

	return (0);
}

void
kue_setmulti(struct kue_softc *sc)
{
	struct arpcom		*ac = &sc->arpcom;
	struct ifnet		*ifp = GET_IFP(sc);
	struct ether_multi	*enm;
	struct ether_multistep	step;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
		sc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;
		sc->kue_rxfilt &= ~KUE_RXFILT_MULTICAST;
		kue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);
		return;
	}

	sc->kue_rxfilt &= ~KUE_RXFILT_ALLMULTI;

	i = 0;
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		if (i == KUE_MCFILTCNT(sc))
			goto allmulti;

		memcpy(KUE_MCFILT(sc, i), enm->enm_addrlo, ETHER_ADDR_LEN);
		ETHER_NEXT_MULTI(step, enm);
		i++;
	}

	ifp->if_flags &= ~IFF_ALLMULTI;

	sc->kue_rxfilt |= KUE_RXFILT_MULTICAST;
	kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,
	    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);

	kue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);
}

/*
 * Issue a SET_CONFIGURATION command to reset the MAC. This should be
 * done after the firmware is loaded into the adapter in order to
 * bring it into proper operation.
 */
void
kue_reset(struct kue_softc *sc)
{
	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	if (usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 1) ||
	    usbd_device2interface_handle(sc->kue_udev, KUE_IFACE_IDX,
					 &sc->kue_iface))
		printf("%s: reset failed\n", sc->kue_dev.dv_xname);

	/* Wait a little while for the chip to get its brains in order. */
	usbd_delay_ms(sc->kue_udev, 10);
}

/*
 * Probe for a KLSI chip.
 */
int
kue_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	DPRINTFN(25,("kue_match: enter\n"));

	if (uaa->iface != NULL)
		return (UMATCH_NONE);

	return (usb_lookup(kue_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
kue_attachhook(struct device *self)
{
	struct kue_softc	*sc = (struct kue_softc *)self;
	int			s;
	struct ifnet		*ifp;
	struct usbd_device	*dev = sc->kue_udev;
	struct usbd_interface	*iface;
	usbd_status		err;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int			i;

	/* Load the firmware into the NIC. */
	if (kue_load_fw(sc)) {
		printf("%s: loading firmware failed\n",
		    sc->kue_dev.dv_xname);
		return;
	}

	err = usbd_device2interface_handle(dev, KUE_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->kue_dev.dv_xname);
		return;
	}

	sc->kue_iface = iface;
	id = usbd_get_interface_descriptor(iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get ep %d\n",
			    sc->kue_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->kue_ed[KUE_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->kue_ed[KUE_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->kue_ed[KUE_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	if (sc->kue_ed[KUE_ENDPT_RX] == 0 || sc->kue_ed[KUE_ENDPT_TX] == 0) {
		printf("%s: missing endpoint\n", sc->kue_dev.dv_xname);
		return;
	}

	/* Read ethernet descriptor */
	err = kue_ctl(sc, KUE_CTL_READ, KUE_CMD_GET_ETHER_DESCRIPTOR,
	    0, &sc->kue_desc, sizeof(sc->kue_desc));
	if (err) {
		printf("%s: could not read Ethernet descriptor\n",
		    sc->kue_dev.dv_xname);
		return;
	}

	sc->kue_mcfilters = mallocarray(KUE_MCFILTCNT(sc), ETHER_ADDR_LEN,
	    M_USBDEV, M_NOWAIT);
	if (sc->kue_mcfilters == NULL) {
		printf("%s: no memory for multicast filter buffer\n",
		    sc->kue_dev.dv_xname);
		return;
	}

	s = splnet();

	/*
	 * A KLSI chip was detected. Inform the world.
	 */
	printf("%s: address %s\n", sc->kue_dev.dv_xname,
	    ether_sprintf(sc->kue_desc.kue_macaddr));

	bcopy(sc->kue_desc.kue_macaddr,
	    (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	/* Initialize interface info.*/
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = kue_ioctl;
	ifp->if_start = kue_start;
	ifp->if_watchdog = kue_watchdog;
	strlcpy(ifp->if_xname, sc->kue_dev.dv_xname, IFNAMSIZ);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	sc->kue_attached = 1;
	splx(s);

}

/*
 * Attach the interface. Allocate softc structures, do
 * setup and ethernet/BPF attach.
 */
void
kue_attach(struct device *parent, struct device *self, void *aux)
{
	struct kue_softc	*sc = (struct kue_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct usbd_device	*dev = uaa->device;
	usbd_status		err;

	DPRINTFN(5,(" : kue_attach: sc=%p, dev=%p", sc, dev));

	err = usbd_set_config_no(dev, KUE_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->kue_dev.dv_xname);
		return;
	}

	sc->kue_udev = dev;
	sc->kue_product = uaa->product;
	sc->kue_vendor = uaa->vendor;

	config_mountroot(self, kue_attachhook);
}

int
kue_detach(struct device *self, int flags)
{
	struct kue_softc	*sc = (struct kue_softc *)self;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	/* Detached before attached finished, so just bail out. */
	if (!sc->kue_attached)
		return (0);

	s = splusb();		/* XXX why? */

	if (sc->kue_mcfilters != NULL) {
		free(sc->kue_mcfilters, M_USBDEV, 0);
		sc->kue_mcfilters = NULL;
	}

	if (ifp->if_flags & IFF_RUNNING)
		kue_stop(sc);

	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->kue_ep[KUE_ENDPT_TX] != NULL ||
	    sc->kue_ep[KUE_ENDPT_RX] != NULL ||
	    sc->kue_ep[KUE_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		       sc->kue_dev.dv_xname);
#endif

	sc->kue_attached = 0;
	splx(s);

	return (0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
kue_newbuf(struct kue_softc *sc, struct kue_chain *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	DPRINTFN(10,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->kue_dev.dv_xname);
			return (ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->kue_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	c->kue_mbuf = m_new;

	return (0);
}

int
kue_rx_list_init(struct kue_softc *sc)
{
	struct kue_cdata	*cd;
	struct kue_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	cd = &sc->kue_cdata;
	for (i = 0; i < KUE_RX_LIST_CNT; i++) {
		c = &cd->kue_rx_chain[i];
		c->kue_sc = sc;
		c->kue_idx = i;
		if (kue_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->kue_xfer == NULL) {
			c->kue_xfer = usbd_alloc_xfer(sc->kue_udev);
			if (c->kue_xfer == NULL)
				return (ENOBUFS);
			c->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);
			if (c->kue_buf == NULL)
				return (ENOBUFS); /* XXX free xfer */
		}
	}

	return (0);
}

int
kue_tx_list_init(struct kue_softc *sc)
{
	struct kue_cdata	*cd;
	struct kue_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	cd = &sc->kue_cdata;
	for (i = 0; i < KUE_TX_LIST_CNT; i++) {
		c = &cd->kue_tx_chain[i];
		c->kue_sc = sc;
		c->kue_idx = i;
		c->kue_mbuf = NULL;
		if (c->kue_xfer == NULL) {
			c->kue_xfer = usbd_alloc_xfer(sc->kue_udev);
			if (c->kue_xfer == NULL)
				return (ENOBUFS);
			c->kue_buf = usbd_alloc_buffer(c->kue_xfer, KUE_BUFSZ);
			if (c->kue_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
kue_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct kue_chain	*c = priv;
	struct kue_softc	*sc = c->kue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	int			total_len = 0;
	int			s;

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->kue_dev.dv_xname,
		     __func__, status));

	if (usbd_is_dying(sc->kue_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->kue_rx_errs++;
		if (usbd_ratecheck(&sc->kue_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->kue_dev.dv_xname, sc->kue_rx_errs,
			    usbd_errstr(status));
			sc->kue_rx_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->kue_ep[KUE_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	DPRINTFN(10,("%s: %s: total_len=%d len=%d\n", sc->kue_dev.dv_xname,
		     __func__, total_len,
		     UGETW(mtod(c->kue_mbuf, u_int8_t *))));

	if (total_len <= 1)
		goto done;

	m = c->kue_mbuf;
	/* copy data to mbuf */
	memcpy(mtod(m, char *), c->kue_buf, total_len);

	/* No errors; receive the packet. */
	total_len = UGETW(mtod(m, u_int8_t *));
	m_adj(m, sizeof(u_int16_t));

	if (total_len < sizeof(struct ether_header)) {
		ifp->if_ierrors++;
		goto done;
	}

	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (kue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

 done:

	/* Setup new transfer. */
	usbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],
	    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, kue_rxeof);
	usbd_transfer(c->kue_xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->kue_dev.dv_xname,
		    __func__));
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
kue_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct kue_chain	*c = priv;
	struct kue_softc	*sc = c->kue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	if (usbd_is_dying(sc->kue_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->kue_dev.dv_xname,
		    __func__, status));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->kue_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->kue_ep[KUE_ENDPT_TX]);
		splx(s);
		return;
	}

	m_freem(c->kue_mbuf);
	c->kue_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		kue_start(ifp);

	splx(s);
}

int
kue_send(struct kue_softc *sc, struct mbuf *m, int idx)
{
	int			total_len;
	struct kue_chain	*c;
	usbd_status		err;

	DPRINTFN(10,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	c = &sc->kue_cdata.kue_tx_chain[idx];

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving two
	 * bytes at the beginning to hold the frame length.
	 */
	m_copydata(m, 0, m->m_pkthdr.len, c->kue_buf + 2);
	c->kue_mbuf = m;

	total_len = m->m_pkthdr.len + 2;
	/* XXX what's this? */
	total_len += 64 - (total_len % 64);

	/* Frame length is specified in the first 2 bytes of the buffer. */
	c->kue_buf[0] = (u_int8_t)m->m_pkthdr.len;
	c->kue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);

	usbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_TX],
	    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT,
	    kue_txeof);

	/* Transmit */
	err = usbd_transfer(c->kue_xfer);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: kue_send error=%s\n", sc->kue_dev.dv_xname,
		       usbd_errstr(err));
		kue_stop(sc);
		return (EIO);
	}

	sc->kue_cdata.kue_tx_cnt++;

	return (0);
}

void
kue_start(struct ifnet *ifp)
{
	struct kue_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	DPRINTFN(10,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->kue_udev))
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (kue_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 6;
}

void
kue_init(void *xsc)
{
	struct kue_softc	*sc = xsc;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;
	u_char			*eaddr;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	if (ifp->if_flags & IFF_RUNNING)
		return;

	s = splnet();

	eaddr = sc->arpcom.ac_enaddr;
	/* Set MAC address */
	kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MAC, 0, eaddr, ETHER_ADDR_LEN);

	sc->kue_rxfilt = KUE_RXFILT_UNICAST | KUE_RXFILT_BROADCAST;

	 /* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		sc->kue_rxfilt |= KUE_RXFILT_PROMISC;

	kue_setword(sc, KUE_CMD_SET_PKT_FILTER, sc->kue_rxfilt);

	/* I'm not sure how to tune these. */
#if 0
	/*
	 * Leave this one alone for now; setting it
	 * wrong causes lockups on some machines/controllers.
	 */
	kue_setword(sc, KUE_CMD_SET_SOFS, 1);
#endif
	kue_setword(sc, KUE_CMD_SET_URB_SIZE, 64);

	/* Init TX ring. */
	if (kue_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->kue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init RX ring. */
	if (kue_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->kue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Load the multicast filter. */
	kue_setmulti(sc);

	if (sc->kue_ep[KUE_ENDPT_RX] == NULL) {
		if (kue_open_pipes(sc)) {
			splx(s);
			return;
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);
}

int
kue_open_pipes(struct kue_softc *sc)
{
	usbd_status		err;
	struct kue_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->kue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}

	err = usbd_open_pipe(sc->kue_iface, sc->kue_ed[KUE_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->kue_ep[KUE_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->kue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}

	/* Start up the receive pipe. */
	for (i = 0; i < KUE_RX_LIST_CNT; i++) {
		c = &sc->kue_cdata.kue_rx_chain[i];
		usbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],
		    c, c->kue_buf, KUE_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		    kue_rxeof);
		DPRINTFN(5,("%s: %s: start read\n", sc->kue_dev.dv_xname,
			    __func__));
		usbd_transfer(c->kue_xfer);
	}

	return (0);
}

int
kue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct kue_softc	*sc = ifp->if_softc;
	int			s, error = 0;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->kue_udev))
		return (EIO);

#ifdef DIAGNOSTIC
	if (!curproc) {
		printf("%s: no proc!!\n", sc->kue_dev.dv_xname);
		return EIO;
	}
#endif

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		kue_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->kue_if_flags & IFF_PROMISC)) {
				sc->kue_rxfilt |= KUE_RXFILT_PROMISC;
				kue_setword(sc, KUE_CMD_SET_PKT_FILTER,
				    sc->kue_rxfilt);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->kue_if_flags & IFF_PROMISC) {
				sc->kue_rxfilt &= ~KUE_RXFILT_PROMISC;
				kue_setword(sc, KUE_CMD_SET_PKT_FILTER,
				    sc->kue_rxfilt);
			} else if (!(ifp->if_flags & IFF_RUNNING))
				kue_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				kue_stop(sc);
		}
		sc->kue_if_flags = ifp->if_flags;
		error = 0;
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			kue_setmulti(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
kue_watchdog(struct ifnet *ifp)
{
	struct kue_softc	*sc = ifp->if_softc;
	struct kue_chain	*c;
	usbd_status		stat;
	int			s;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->kue_udev))
		return;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->kue_dev.dv_xname);

	s = splusb();
	c = &sc->kue_cdata.kue_tx_chain[0];
	usbd_get_xfer_status(c->kue_xfer, NULL, NULL, NULL, &stat);
	kue_txeof(c->kue_xfer, c, stat);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		kue_start(ifp);
	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
kue_stop(struct kue_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->kue_dev.dv_xname,__func__));

	ifp = GET_IFP(sc);
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	/* Stop transfers. */
	if (sc->kue_ep[KUE_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);
		err = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
		sc->kue_ep[KUE_ENDPT_RX] = NULL;
	}

	if (sc->kue_ep[KUE_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);
		err = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
		sc->kue_ep[KUE_ENDPT_TX] = NULL;
	}

	if (sc->kue_ep[KUE_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);
		err = usbd_close_pipe(sc->kue_ep[KUE_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
		sc->kue_ep[KUE_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < KUE_RX_LIST_CNT; i++) {
		if (sc->kue_cdata.kue_rx_chain[i].kue_mbuf != NULL) {
			m_freem(sc->kue_cdata.kue_rx_chain[i].kue_mbuf);
			sc->kue_cdata.kue_rx_chain[i].kue_mbuf = NULL;
		}
		if (sc->kue_cdata.kue_rx_chain[i].kue_xfer != NULL) {
			usbd_free_xfer(sc->kue_cdata.kue_rx_chain[i].kue_xfer);
			sc->kue_cdata.kue_rx_chain[i].kue_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < KUE_TX_LIST_CNT; i++) {
		if (sc->kue_cdata.kue_tx_chain[i].kue_mbuf != NULL) {
			m_freem(sc->kue_cdata.kue_tx_chain[i].kue_mbuf);
			sc->kue_cdata.kue_tx_chain[i].kue_mbuf = NULL;
		}
		if (sc->kue_cdata.kue_tx_chain[i].kue_xfer != NULL) {
			usbd_free_xfer(sc->kue_cdata.kue_tx_chain[i].kue_xfer);
			sc->kue_cdata.kue_tx_chain[i].kue_xfer = NULL;
		}
	}
}
@


1.86
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.85 2016/04/13 11:03:37 mpi Exp $ */
d273 1
a273 1
		free(buf, M_DEVBUF, 0);
d285 1
a285 1
		free(buf, M_DEVBUF, 0);
d298 1
a298 1
		free(buf, M_DEVBUF, 0);
d301 1
a301 1
	free(buf, M_DEVBUF, 0);
@


1.85
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.84 2015/12/11 16:07:02 mpi Exp $ */
a785 2

	ifp->if_opackets++;
@


1.84
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.83 2015/11/25 03:10:00 dlg Exp $ */
a491 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.83
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.82 2015/11/20 03:35:23 dlg Exp $ */
d181 1
a181 1
void kue_attachhook(void *);
d402 1
a402 1
kue_attachhook(void *xsc)
d404 1
a404 1
	struct kue_softc *sc = xsc;
d529 1
a529 4
	if (rootvp == NULL)
		mountroothook_establish(kue_attachhook, sc);
	else
		kue_attachhook(sc);
@


1.82
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.81 2015/10/25 12:11:56 mpi Exp $ */
d776 1
a776 1
	ifp->if_flags &= ~IFF_OACTIVE;
d858 1
a858 1
	if (ifp->if_flags & IFF_OACTIVE)
d867 1
a867 1
		ifp->if_flags |= IFF_OACTIVE;
d882 1
a882 1
	ifp->if_flags |= IFF_OACTIVE;
d952 1
a952 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1103 2
a1104 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.81
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.80 2015/06/24 09:40:54 mpi Exp $ */
d861 1
a861 1
	IFQ_POLL(&ifp->if_snd, m_head);
d866 1
d871 1
a871 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.80
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.79 2015/04/10 08:41:43 mpi Exp $ */
a1000 1
	struct ifaddr 		*ifa = (struct ifaddr *)data;
a1020 6

		switch (ifa->ifa_addr->sa_family) {
		case AF_INET:
			arp_ifinit(&sc->arpcom, ifa);
			break;
		}
@


1.79
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.78 2015/03/14 03:38:49 jsg Exp $ */
a729 1
	ifp->if_ipackets++;
@


1.78
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.77 2015/02/04 05:12:13 mpi Exp $ */
d679 1
d732 1
a733 5
	m->m_pkthdr.rcvif = ifp;

	s = splnet();

	/* XXX ugly */
d736 1
a736 1
		goto done1;
d739 2
a740 9
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	DPRINTFN(10,("%s: %s: deliver %d\n", sc->kue_dev.dv_xname,
		    __func__, m->m_len));
	ether_input_mbuf(ifp, m);
 done1:
@


1.77
log
@Kill annoying comments about ether_input()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.76 2015/01/11 02:59:59 deraadt Exp $ */
a84 1
#include <net/if_dl.h>
@


1.76
log
@KUE_MCFILTCNT() is non-constant, so use mallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.75 2014/12/22 02:28:52 tedu Exp $ */
a743 6
	/*
	 * Handle BPF listeners. Let the BPF user see the packet, but
	 * don't pass it up to the ether_input() layer unless it's
	 * a broadcast packet, multicast packet, matches our ethernet
	 * address or the interface is in promiscuous mode.
	 */
@


1.75
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.74 2014/07/13 15:52:49 mpi Exp $ */
d466 1
a466 1
	sc->kue_mcfilters = malloc(KUE_MCFILTCNT(sc) * ETHER_ADDR_LEN,
@


1.74
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.73 2014/07/12 18:48:52 tedu Exp $ */
a1041 1
#ifdef INET
a1044 1
#endif /* INET */
@


1.73
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.72 2014/07/12 07:59:23 mpi Exp $ */
a90 1
#ifdef INET
a91 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a92 1
#endif
@


1.72
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.71 2013/11/15 10:17:39 pirofti Exp $ */
d278 1
a278 1
		free(buf, M_DEVBUF);
d290 1
a290 1
		free(buf, M_DEVBUF);
d303 1
a303 1
		free(buf, M_DEVBUF);
d306 1
a306 1
	free(buf, M_DEVBUF);
d554 1
a554 1
		free(sc->kue_mcfilters, M_USBDEV);
@


1.71
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.70 2013/11/11 12:38:39 pirofti Exp $ */
d154 10
a163 15
int kue_match(struct device *, void *, void *); 
void kue_attach(struct device *, struct device *, void *); 
int kue_detach(struct device *, int); 
int kue_activate(struct device *, int); 

struct cfdriver kue_cd = { 
	NULL, "kue", DV_IFNET 
}; 

const struct cfattach kue_ca = { 
	sizeof(struct kue_softc), 
	kue_match, 
	kue_attach, 
	kue_detach, 
	kue_activate, 
a576 15
	return (0);
}

int
kue_activate(struct device *self, int act)
{
	struct kue_softc *sc = (struct kue_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->kue_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->kue_udev);
		break;
	}
@


1.70
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.69 2013/11/05 10:20:04 mpi Exp $ */
d1157 1
a1157 5
		err = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
d1167 1
a1167 5
		err = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
d1177 1
a1177 5
		err = usbd_abort_pipe(sc->kue_ep[KUE_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    sc->kue_dev.dv_xname, usbd_errstr(err));
		}
@


1.69
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.68 2013/08/07 01:06:41 bluhm Exp $ */
d594 1
a594 1
		sc->kue_dying = 1;
d711 1
a711 1
	if (sc->kue_dying)
d809 1
a809 1
	if (sc->kue_dying)
d897 1
a897 1
	if (sc->kue_dying)
d1048 1
a1048 1
	if (sc->kue_dying)
d1122 1
a1122 1
	if (sc->kue_dying)
@


1.68
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.67 2013/04/15 09:23:01 mglocker Exp $ */
d336 1
d344 1
a344 1
	if (ifp->if_flags & IFF_PROMISC) {
d356 1
a356 1
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
d358 1
a358 3
		if (i == KUE_MCFILTCNT(sc) ||
		    memcmp(enm->enm_addrlo, enm->enm_addrhi,
			ETHER_ADDR_LEN) != 0)
@


1.67
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.66 2013/04/10 07:46:24 mpi Exp $ */
a93 1
#include <netinet/in_var.h>
@


1.66
log
@Instead of refetching the descriptor from the device, just use the copy
already in memory retrieved during the autoconf USB attach logic. This
is a good example of how confusing can be the usbd_get_* functions.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.65 2013/03/28 03:58:03 tedu Exp $ */
d177 2
a178 2
void kue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void kue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d419 2
a420 2
	usbd_device_handle	dev = sc->kue_udev;
	usbd_interface_handle	iface;
d525 1
a525 1
	usbd_device_handle	dev = uaa->device;
d701 1
a701 1
kue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d804 1
a804 1
kue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.65
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.64 2011/07/03 15:47:17 matthew Exp $ */
d235 1
a235 1
	usb_device_descriptor_t dd;
d257 1
a257 1
	if (usbd_get_device_desc(sc->kue_udev, &dd))
d259 1
a259 1
	if (UGETW(dd.bcdDevice) >= KUE_WARM_REV) {
@


1.64
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.63 2011/01/25 20:03:35 jakemsr Exp $ */
a82 1
#include <sys/proc.h>
@


1.63
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.62 2010/12/17 13:48:06 jasper Exp $ */
a595 3
	case DVACT_ACTIVATE:
		break;

@


1.62
log
@- use usb_lookup() instead of handrolled macro.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.61 2010/10/27 17:51:11 jakemsr Exp $ */
a545 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->kue_udev,
			   &sc->kue_dev);
@


1.61
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.60 2010/09/24 08:33:58 yuo Exp $ */
a154 1
#define kue_lookup(v, p) (usb_lookup(kue_devs, v, p))
d410 2
a411 2
	return (kue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.60
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.59 2009/10/13 19:33:17 pirofti Exp $ */
d573 4
a576 3
	ether_ifdetach(ifp);

	if_detach(ifp);
@


1.59
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.58 2008/11/28 02:44:18 brad Exp $ */
d559 4
a567 6
	}

	if (!sc->kue_attached) {
		/* Detached before attached finished, so just bail out. */
		splx(s);
		return (0);
@


1.58
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.57 2008/10/02 20:21:14 brad Exp $ */
d160 1
a160 1
int kue_activate(struct device *, enum devact); 
d594 1
a594 1
kue_activate(struct device *self, enum devact act)
@


1.57
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.56 2007/10/11 18:33:14 deraadt Exp $ */
a1054 1
	struct ifreq		*ifr = (struct ifreq *)data;
a1084 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

d1108 1
a1108 16
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				kue_setmulti(sc);
			error = 0;
		}
		break;
d1111 6
@


1.56
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.55 2007/06/14 10:11:15 mbalmer Exp $ */
d1133 1
a1133 2
		error = EINVAL;
		break;
a1136 1

@


1.55
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.54 2007/06/13 11:15:29 mbalmer Exp $ */
a526 1
	char			*devinfop;
a530 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->kue_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.54
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.53 2007/06/12 16:26:36 mbalmer Exp $ */
d157 16
a172 1
USB_DECLARE_DRIVER_CLASS(kue, DV_IFNET);
@


1.53
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.52 2007/06/10 14:49:00 mbalmer Exp $ */
d781 1
a781 1
	IF_INPUT(ifp, m);
@


1.52
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.51 2007/06/10 10:53:48 mbalmer Exp $ */
d584 1
a584 1
kue_activate(device_ptr_t self, enum devact act)
@


1.51
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.50 2007/06/05 08:43:55 mbalmer Exp $ */
d186 1
a186 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d203 1
a203 1
	DPRINTFN(10,("%s: %s: enter, len=%d\n", USBDEVNAME(sc->kue_dev),
d228 1
a228 1
	DPRINTFN(1,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d248 1
a248 1
		       USBDEVNAME(sc->kue_dev));
d255 1
a255 1
		    USBDEVNAME(sc->kue_dev), "kue", err);
d261 1
a261 1
	       USBDEVNAME(sc->kue_dev));
d265 1
a265 1
		    USBDEVNAME(sc->kue_dev)));
d270 1
a270 1
		    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d277 1
a277 1
		    USBDEVNAME(sc->kue_dev)));
d282 1
a282 1
		    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d289 1
a289 1
		    USBDEVNAME(sc->kue_dev)));
d295 1
a295 1
		    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d313 1
a313 1
	DPRINTFN(1,("%s: %s: done\n", USBDEVNAME(sc->kue_dev), __func__));
d329 1
a329 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d372 1
a372 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d377 1
a377 1
		printf("%s: reset failed\n", USBDEVNAME(sc->kue_dev));
d416 1
a416 1
		    USBDEVNAME(sc->kue_dev));
d423 1
a423 1
		    USBDEVNAME(sc->kue_dev));
d435 1
a435 1
			    USBDEVNAME(sc->kue_dev), i);
d451 1
a451 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->kue_dev));
d460 1
a460 1
		    USBDEVNAME(sc->kue_dev));
d468 1
a468 1
		    USBDEVNAME(sc->kue_dev));
d477 1
a477 1
	printf("%s: address %s\n", USBDEVNAME(sc->kue_dev),
d490 1
a490 1
	strlcpy(ifp->if_xname, USBDEVNAME(sc->kue_dev), IFNAMSIZ);
d519 1
a519 1
	printf("\n%s: %s\n", USBDEVNAME(sc->kue_dev), devinfop);
d525 1
a525 1
		    USBDEVNAME(sc->kue_dev));
d574 1
a574 1
		       USBDEVNAME(sc->kue_dev));
d588 1
a588 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d609 1
a609 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d615 1
a615 1
			    "-- packet dropped!\n", USBDEVNAME(sc->kue_dev));
d622 1
a622 1
			    "-- packet dropped!\n", USBDEVNAME(sc->kue_dev));
d645 1
a645 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d674 1
a674 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d709 1
a709 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->kue_dev),
d724 1
a724 1
			    USBDEVNAME(sc->kue_dev), sc->kue_rx_errs,
d735 1
a735 1
	DPRINTFN(10,("%s: %s: total_len=%d len=%d\n", USBDEVNAME(sc->kue_dev),
d779 1
a779 1
	DPRINTFN(10,("%s: %s: deliver %d\n", USBDEVNAME(sc->kue_dev),
d793 1
a793 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->kue_dev),
d815 1
a815 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->kue_dev),
d827 1
a827 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->kue_dev),
d853 1
a853 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d879 1
a879 1
		printf("%s: kue_send error=%s\n", USBDEVNAME(sc->kue_dev),
d896 1
a896 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d940 1
a940 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d971 1
a971 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->kue_dev));
d978 1
a978 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->kue_dev));
d1006 1
a1006 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1013 1
a1013 1
		    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1021 1
a1021 1
		    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1032 1
a1032 1
		DPRINTFN(5,("%s: %s: start read\n", USBDEVNAME(sc->kue_dev),
d1048 1
a1048 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1055 1
a1055 1
		printf("%s: no proc!!\n", USBDEVNAME(sc->kue_dev));
d1140 1
a1140 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1146 1
a1146 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->kue_dev));
d1169 1
a1169 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1180 1
a1180 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1185 1
a1185 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1194 1
a1194 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1199 1
a1199 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1208 1
a1208 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
d1213 1
a1213 1
			    USBDEVNAME(sc->kue_dev), usbd_errstr(err));
@


1.50
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.49 2007/06/04 10:34:04 mbalmer Exp $ */
d539 1
a539 1
			   USBDEV(sc->kue_dev));
@


1.49
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.48 2007/05/31 00:34:11 maja Exp $ */
d120 1
a120 1
Static const struct usb_devno kue_devs[] = {
d159 12
a170 12
Static int kue_tx_list_init(struct kue_softc *);
Static int kue_rx_list_init(struct kue_softc *);
Static int kue_newbuf(struct kue_softc *, struct kue_chain *,struct mbuf *);
Static int kue_send(struct kue_softc *, struct mbuf *, int);
Static int kue_open_pipes(struct kue_softc *);
Static void kue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void kue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void kue_start(struct ifnet *);
Static int kue_ioctl(struct ifnet *, u_long, caddr_t);
Static void kue_init(void *);
Static void kue_stop(struct kue_softc *);
Static void kue_watchdog(struct ifnet *);
d172 2
a173 2
Static void kue_setmulti(struct kue_softc *);
Static void kue_reset(struct kue_softc *);
d175 1
a175 1
Static usbd_status kue_ctl(struct kue_softc *, int, u_int8_t,
d177 2
a178 2
Static usbd_status kue_setword(struct kue_softc *, u_int8_t, u_int16_t);
Static int kue_load_fw(struct kue_softc *);
d181 1
a181 1
Static usbd_status
d197 1
a197 1
Static usbd_status
d219 1
a219 1
Static int
d321 1
a321 1
Static void
d369 1
a369 1
Static void
d604 1
a604 1
Static int
d638 1
a638 1
Static int
d667 1
a667 1
Static int
d699 1
a699 1
Static void
d802 1
a802 1
Static void
d846 1
a846 1
Static int
d890 1
a890 1
Static void
d932 1
a932 1
Static void
d999 1
a999 1
Static int
d1040 1
a1040 1
Static int
d1132 1
a1132 1
Static void
d1162 1
a1162 1
Static void
@


1.48
log
@Fix dmesg output. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.47 2007/05/27 04:00:24 jsg Exp $ */
a85 3
#if defined(__NetBSD__)
#include <net/if_arp.h>
#endif
a91 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined (__NetBSD__) */

#if defined(__OpenBSD__)
a98 1
#endif /* defined (__OpenBSD__) */
a342 3
#if defined (__NetBSD__)
	ETHER_FIRST_MULTI(step, &sc->kue_ec, enm);
#else
a343 1
#endif
a479 1
#if defined(__OpenBSD__)
a481 1
#endif
a594 4
#if defined(__NetBSD__)
		/* Deactivate the interface. */
		if_deactivate(&sc->kue_ec.ec_if);
#endif
a946 3
#if defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
#else
a947 1
#endif /* defined(__NetBSD__) */
a1069 3
#if defined(__NetBSD__)
			arp_ifinit(ifp, ifa);
#else
a1070 1
#endif
@


1.47
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.46 2007/05/21 05:40:27 jsg Exp $ */
d538 1
a538 1
	printf("/n%s: %s\n", USBDEVNAME(sc->kue_dev), devinfop);
@


1.46
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.45 2007/05/21 05:18:56 jsg Exp $ */
d403 2
a404 1
USB_MATCH(kue)
d406 1
a406 1
	USB_MATCH_START(kue, uaa);
d434 1
a434 1
		USB_ATTACH_ERROR_RETURN;
d441 1
a441 1
		USB_ATTACH_ERROR_RETURN;
d453 1
a453 1
			USB_ATTACH_ERROR_RETURN;
d469 1
a469 1
		USB_ATTACH_ERROR_RETURN;
d478 1
a478 1
		USB_ATTACH_ERROR_RETURN;
d486 1
a486 1
		USB_ATTACH_ERROR_RETURN;
d526 2
a527 1
USB_ATTACH(kue)
d529 2
a530 1
	USB_ATTACH_START(kue, sc, uaa);
d538 1
a538 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->kue_dev), devinfop);
d545 1
a545 1
		USB_ATTACH_ERROR_RETURN;
a558 2

	USB_ATTACH_SUCCESS_RETURN;
d561 2
a562 1
USB_DETACH(kue)
d564 1
a564 1
	USB_DETACH_START(kue, sc);
@


1.45
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.44 2007/02/11 20:29:22 miod Exp $ */
d122 2
a123 2
#define DPRINTF(x)	do { if (kuedebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (kuedebug >= (n)) logprintf x; } while (0)
@


1.44
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.43 2007/01/09 16:30:08 deraadt Exp $ */
d514 1
a514 1
	Ether_ifattach(ifp, sc->kue_desc.kue_macaddr);
@


1.43
log
@network byte order firmware, so that firmware files are the same on
all architectures
YOU HAVE TO INSTALL NEW FIRMWARE BEFORE BOOTING A NEW KERNEL
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.42 2006/06/23 06:27:11 miod Exp $ */
a72 3
#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
a73 4
#include "rnd.h"
#elif defined(__OpenBSD__)
#include "bpfilter.h"
#endif
@


1.42
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.41 2006/03/25 22:41:47 djm Exp $ */
d287 1
a287 1
	    0, (void *)&fw->data[0], fw->codeseglen);
d299 1
a299 1
	    0, (void *)&fw->data[fw->codeseglen], fw->fixseglen);
d311 2
a312 2
	    0, (void *)&fw->data[fw->codeseglen + fw->fixseglen],
	    fw->trigseglen);
@


1.41
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.40 2006/03/07 04:41:19 krw Exp $ */
a616 1
		return (EOPNOTSUPP);
@


1.40
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.39 2006/01/29 03:22:52 brad Exp $ */
d806 1
a806 1
		bpf_mtap(ifp->if_bpf, m);
d951 1
a951 1
		bpf_mtap(ifp->if_bpf, m_head);
@


1.39
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.38 2005/08/01 05:36:48 brad Exp $ */
a91 4
#if NRND > 0
#include <sys/rnd.h>
#endif

a521 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, USBDEVNAME(sc->kue_dev),
	    RND_TYPE_NET, 0);
#endif
a589 5
#if defined(__NetBSD__)
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
#endif /* __NetBSD__ */
@


1.38
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.37 2005/07/02 22:21:12 brad Exp $ */
d772 1
a772 1
			usbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_RX]);
d873 1
a873 1
			usbd_clear_endpoint_stall(sc->kue_ep[KUE_ENDPT_TX]);
@


1.37
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.36 2005/06/08 17:03:02 henning Exp $ */
d543 1
a543 1
	char			devinfo[1024];
d549 1
a549 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d551 2
a552 1
	printf("%s: %s\n", USBDEVNAME(sc->kue_dev), devinfo);
@


1.36
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.35 2005/01/15 03:53:36 jsg Exp $ */
d1223 1
a1290 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.35
log
@Add id for Psion Dacom Gold Port Ethernet found in Linux driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.34 2005/01/03 22:45:52 brad Exp $ */
a123 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1122 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.34
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.33 2004/12/12 06:21:35 deraadt Exp $ */
d181 1
@


1.33
log
@fix proto
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.32 2004/11/28 02:14:55 deraadt Exp $ */
d1180 1
d1186 2
a1187 1
			kue_setmulti(sc);
@


1.32
log
@kue(4) uses loadfirmware(9), but usb threaded probing starts before
root is mounted.  split up kue_attach() so that if in the worst case...
it knows how to defer the second part until after the filesystem is up
tested by maja, idea ok from miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.31 2004/11/22 18:59:39 dhartmei Exp $ */
d207 1
a207 1
void kue_attachhook(void *xsc);
@


1.31
log
@relax warmboot detection, required for some models. ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.30 2004/11/22 18:49:05 deraadt Exp $ */
d207 1
d431 2
a432 5
/*
 * Attach the interface. Allocate softc structures, do
 * setup and ethernet/BPF attach.
 */
USB_ATTACH(kue)
d434 1
a434 2
	USB_ATTACH_START(kue, sc, uaa);
	char			devinfo[1024];
d437 1
a437 1
	usbd_device_handle	dev = uaa->device;
a443 17
	DPRINTFN(5,(" : kue_attach: sc=%p, dev=%p", sc, dev));

	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->kue_dev), devinfo);

	err = usbd_set_config_no(dev, KUE_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    USBDEVNAME(sc->kue_dev));
		USB_ATTACH_ERROR_RETURN;
	}

	sc->kue_udev = dev;
	sc->kue_product = uaa->product;
	sc->kue_vendor = uaa->vendor;

d537 35
@


1.30
log
@firmware loading for kue(4), tested for me by dhartmei
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.29 2004/11/10 10:14:48 grange Exp $ */
d273 1
a273 1
	if (UGETW(dd.bcdDevice) == KUE_WARM_REV) {
@


1.29
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.28 2004/10/16 01:22:52 jsg Exp $ */
d135 1
a135 6

#if defined(__OpenBSD__)
#include <dev/microcode/kue/kue_fw.h>
#else
#include <dev/usb/kue_fw.h>
#endif
d251 3
d279 8
d294 1
a294 1
	    0, (void *)kue_code_seg, sizeof(kue_code_seg));
d298 2
a299 1
			return (EIO);
d306 1
a306 1
	    0, (void *)kue_fix_seg, sizeof(kue_fix_seg));
d310 2
a311 1
			return (EIO);
d318 2
a319 1
	    0, (void *)kue_trig_seg, sizeof(kue_trig_seg));
d323 2
a324 1
			return (EIO);
d326 1
@


1.28
log
@Add Silicom U2E found in linux driver. ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.27 2004/09/23 17:45:17 brad Exp $ */
d532 1
a532 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->kue_dev), IFNAMSIZ);
@


1.27
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.26 2004/07/08 22:18:44 deraadt Exp $ */
d185 1
@


1.26
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.25 2004/06/02 06:30:28 mcbride Exp $ */
a526 1
	ifp->if_mtu = ETHERMTU;
@


1.25
log
@Add ether_{add,del}multi(), makes multicast work.

Testing & ok cedric@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.24 2003/12/15 23:36:14 cedric Exp $ */
d143 2
a144 2
#define DPRINTF(x)	if (kuedebug) logprintf x
#define DPRINTFN(n,x)	if (kuedebug >= (n)) logprintf x
@


1.24
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.23 2003/05/07 04:33:33 deraadt Exp $ */
d1151 11
a1161 2
		kue_setmulti(sc);
		error = 0;
@


1.23
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.22 2002/07/29 02:38:54 nate Exp $ */
d189 1
a189 1
USB_DECLARE_DRIVER(kue);
@


1.22
log
@Refetch interface handle on reset.  Avoids potential access to freed memory.
From FreeBSD via NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.21 2002/07/25 02:18:10 nate Exp $ */
d437 1
a437 1
	usbd_devinfo(dev, 0, devinfo);
@


1.21
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.20 2002/07/10 18:08:13 deraadt Exp $ */
/*	$NetBSD: if_kue.c,v 1.48 2002/07/08 17:46:24 augustss Exp $	*/
a390 2
	usbd_status		err;

d393 3
a395 2
	err = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 1);
	if (err)
@


1.20
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.19 2002/07/09 16:44:15 nate Exp $ */
d109 1
a109 1
#include <netinet/in.h> 
d284 1
a284 1
	DPRINTFN(1,("%s: kue_load_fw: download code_seg\n", 
d295 1
a295 1
	DPRINTFN(1,("%s: kue_load_fw: download fix_seg\n", 
d306 1
a306 1
	DPRINTFN(1,("%s: kue_load_fw: download trig_seg\n", 
d757 1
a757 1
		     __func__, total_len, 
@


1.19
log
@Sync Id string with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.18 2002/06/26 11:29:55 espie Exp $ */
d517 1
a517 1
	printf("%s: Ethernet address %s\n", USBDEVNAME(sc->kue_dev),
@


1.18
log
@Kill __FUNCTION__.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.17 2002/05/06 05:34:39 nate Exp $ */
/*	$NetBSD: if_kue.c,v 1.47 2002/03/17 18:02:52 augustss Exp $	*/
@


1.17
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.16 2002/03/14 03:16:08 millert Exp $ */
d217 1
a217 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d235 1
a235 1
		     __FUNCTION__, len));
d256 1
a256 1
	DPRINTFN(1,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d328 1
a328 1
	DPRINTFN(1,("%s: %s: done\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d344 1
a344 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d393 1
a393 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d604 1
a604 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d630 1
a630 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d666 1
a666 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d695 1
a695 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __FUNCTION__));
d731 1
a731 1
		     __FUNCTION__, status));
d757 1
a757 1
		     __FUNCTION__, total_len, 
d801 1
a801 1
		    __FUNCTION__, m->m_len));
d815 1
a815 1
		    __FUNCTION__));
d837 1
a837 1
		    __FUNCTION__, status));
d874 1
a874 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d917 1
a917 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d961 1
a961 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d1031 1
a1031 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d1058 1
a1058 1
			    __FUNCTION__));
d1073 1
a1073 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d1173 1
a1173 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
d1202 1
a1202 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__FUNCTION__));
@


1.16
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.15 2001/12/17 02:18:18 deraadt Exp $ */
/*	$NetBSD: if_kue.c,v 1.43 2001/10/08 03:37:53 augustss Exp $	*/
a91 1
#include <sys/device.h>
a101 2
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))

d135 2
d138 3
d154 1
a154 1
Static const struct kue_type kue_devs[] = {
a185 1
	{ 0, 0 }
d187 1
d253 1
a253 1
	usb_device_descriptor_t	dd;
a408 1
	const struct kue_type			*t;
d415 2
a416 5
	for (t = kue_devs; t->kue_vid != 0; t++)
		if (uaa->vendor == t->kue_vid && uaa->product == t->kue_did)
			return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
a579 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
d797 1
a797 1
		BPF_MTAP(ifp, m);
d942 1
a942 1
		BPF_MTAP(ifp, m_head);
@


1.15
log
@and of course, since the tree is so volatile now, i mess it up
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.14 2001/12/17 01:39:08 deraadt Exp $ */
d770 1
a770 1
	memcpy(mtod(m, char*), c->kue_buf, total_len);
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_kue.c,v 1.47 2002/03/17 18:02:52 augustss Exp $	*/
d92 1
d103 2
a137 2

#if defined(__OpenBSD__)
a138 3
#else
#include <dev/usb/kue_fw.h>
#endif
d152 1
a152 1
Static const struct usb_devno kue_devs[] = {
d184 1
a185 1
#define kue_lookup(v, p) (usb_lookup(kue_devs, v, p))
d251 1
a251 1
	usb_device_descriptor_t dd;
d407 1
d414 5
a418 2
	return (kue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d582 3
d770 1
a770 1
	memcpy(mtod(m, char *), c->kue_buf, total_len);
d802 1
a802 1
		bpf_mtap(ifp->if_bpf, m);
d947 1
a947 1
		bpf_mtap(ifp->if_bpf, m_head);
@


1.15.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: if_kue.c,v 1.50 2002/07/16 22:00:31 augustss Exp $	*/
d109 1
a109 1
#include <netinet/in.h>
d217 1
a217 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d235 1
a235 1
		     __func__, len));
d256 1
a256 1
	DPRINTFN(1,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d284 1
a284 1
	DPRINTFN(1,("%s: kue_load_fw: download code_seg\n",
d295 1
a295 1
	DPRINTFN(1,("%s: kue_load_fw: download fix_seg\n",
d306 1
a306 1
	DPRINTFN(1,("%s: kue_load_fw: download trig_seg\n",
d328 1
a328 1
	DPRINTFN(1,("%s: %s: done\n", USBDEVNAME(sc->kue_dev), __func__));
d344 1
a344 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d391 3
a393 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d395 2
a396 3
	if (usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 1) ||
	    usbd_device2interface_handle(sc->kue_udev, KUE_IFACE_IDX,
					 &sc->kue_iface))
d517 1
a517 1
	printf("%s: address %s\n", USBDEVNAME(sc->kue_dev),
d604 1
a604 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d630 1
a630 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d666 1
a666 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d695 1
a695 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d731 1
a731 1
		     __func__, status));
d757 1
a757 1
		     __func__, total_len,
d801 1
a801 1
		    __func__, m->m_len));
d815 1
a815 1
		    __func__));
d837 1
a837 1
		    __func__, status));
d874 1
a874 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d917 1
a917 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d961 1
a961 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1031 1
a1031 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1058 1
a1058 1
			    __func__));
d1073 1
a1073 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1173 1
a1173 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1202 1
a1202 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
@


1.15.2.3
log
@sync
@
text
@d437 1
a437 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.14
log
@move more microcode, so that it does not end up in /usr/include
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.13 2001/10/31 04:24:44 nate Exp $ */
d138 1
a138 1
#include <dev/microcode/kue_fw.h>
@


1.13
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.12 2001/07/08 23:38:08 fgsch Exp $ */
d138 1
a138 1
#include <dev/usb/kue_fw.h>
@


1.12
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.11 2001/06/27 06:34:53 kjc Exp $ */
/*	$NetBSD: if_kue.c,v 1.40 2001/04/08 02:10:57 augustss Exp $	*/
d153 5
d159 1
a159 1
	{ USB_VENDOR_ADS, USB_PRODUCT_ADS_UBS10BT },
d161 13
d175 1
d179 4
a182 5
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_E45 },
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C19250 },
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C460 },
	{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_ETHER_USB_T },
	{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DSB650C },
a183 4
	{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_USB10T },
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_DUH3E10BT },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBETT },
	{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_URE450 },
d535 2
a537 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->kue_dev), IFNAMSIZ);
@


1.11
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.10 2001/05/03 02:20:32 aaron Exp $ */
a520 3
#if defined(__OpenBSD__)
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
#endif
@


1.10
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.9 2001/02/20 19:39:46 mickey Exp $ */
d522 1
a522 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d524 1
d854 1
a854 1
	if (ifp->if_snd.ifq_head != NULL)
d918 1
a918 1
	IF_DEQUEUE(&ifp->if_snd, m_head);
a922 1
		IF_PREPEND(&ifp->if_snd, m_head);
d927 2
d1179 1
a1179 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.10.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: if_kue.c,v 1.28 2000/04/02 21:25:41 augustss Exp $	*/
a72 6
/*
 * TODO:
 * only use kue_do_request for downloading firmware.
 * more DPRINTF
 * proper cleanup on errors
 */
d89 2
a90 8

#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>

#elif defined(__NetBSD__) || defined(__OpenBSD__)
a96 2
#endif

d98 1
a98 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a102 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a103 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d105 1
a105 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a126 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a130 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a136 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d159 1
d175 20
a194 60
Static int kue_tx_list_init	__P((struct kue_softc *));
Static int kue_rx_list_init	__P((struct kue_softc *));
Static int kue_newbuf		__P((struct kue_softc *, struct kue_chain *,
				    struct mbuf *));
Static int kue_send		__P((struct kue_softc *, struct mbuf *, int));
Static int kue_open_pipes	__P((struct kue_softc *));
Static void kue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void kue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void kue_start		__P((struct ifnet *));
Static int kue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void kue_init		__P((void *));
Static void kue_stop		__P((struct kue_softc *));
Static void kue_watchdog		__P((struct ifnet *));

Static void kue_setmulti	__P((struct kue_softc *));
Static void kue_reset		__P((struct kue_softc *));

Static usbd_status kue_ctl	__P((struct kue_softc *, int, u_int8_t,
				    u_int16_t, void *, u_int32_t));
Static usbd_status kue_setword	__P((struct kue_softc *, u_int8_t, u_int16_t));
Static int kue_is_warm		__P((struct kue_softc *));
Static int kue_load_fw		__P((struct kue_softc *));

#if defined(__FreeBSD__)
#ifndef lint
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_kue.c,v 1.14 2000/01/14 01:36:15 wpaul Exp $";
#endif

Static void kue_rxstart		__P((struct ifnet *));
Static void kue_shutdown	__P((device_t));

Static struct usb_qdat kue_qdat;

Static device_method_t kue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		kue_match),
	DEVMETHOD(device_attach,	kue_attach),
	DEVMETHOD(device_detach,	kue_detach),
	DEVMETHOD(device_shutdown,	kue_shutdown),

	{ 0, 0 }
};

Static driver_t kue_driver = {
	"kue",
	kue_methods,
	sizeof(struct kue_softc)
};

Static devclass_t kue_devclass;

DRIVER_MODULE(if_kue, uhub, kue_driver, kue_devclass, usbd_driver_load, 0);

#endif /* __FreeBSD__ */

#define KUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d197 1
a197 4
kue_setword(sc, breq, word)
	struct kue_softc	*sc;
	u_int8_t		breq;
	u_int16_t		word;
a199 2
	usbd_status		err;
	int			s;
d209 1
a209 5
	s = splusb();
	err = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);
	splx(s);

	return (err);
d213 2
a214 7
kue_ctl(sc, rw, breq, val, data, len)
	struct kue_softc	*sc;
	int			rw;
	u_int8_t		breq;
	u_int16_t		val;
	void			*data;
	u_int32_t		len;
a216 2
	usbd_status		err;
	int			s;
d231 1
a231 5
	s = splusb();
	err = KUE_DO_REQUEST(sc->kue_udev, &req, (void *)data);
	splx(s);

	return (err);
d235 1
a235 21
kue_is_warm(sc)
	struct kue_softc	*sc;
{
	usbd_status		err;
	usb_device_request_t	req;

	/* Just issue some random command. */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(sc->kue_desc));

	err = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);

	return (!err);
}

Static int
kue_load_fw(sc)
	struct kue_softc	*sc;
d237 1
d251 4
a254 2
	 * We can test this quickly by issuing a request that
	 * is only valid after firmware download.
d256 3
a258 1
	if (kue_is_warm(sc)) {
d321 1
a321 2
kue_setmulti(sc)
	struct kue_softc	*sc;
a323 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a325 1
#endif
d330 3
a332 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a341 16
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		/*
		 * If there are too many addresses for the
		 * internal filter, switch over to allmulti mode.
		 */
		if (i == KUE_MCFILTCNT(sc))
			break;
		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
		    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);
		i++;
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d348 5
a352 10
		if (i == KUE_MCFILTCNT(sc))
			break;
#if 0
		if (memcmp(enm->enm_addrlo,
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			/* XXX what now? */
			return;
		}
#endif
a356 1
#endif
d358 5
a362 7
	if (i == KUE_MCFILTCNT(sc))
		sc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;
	else {
		sc->kue_rxfilt |= KUE_RXFILT_MULTICAST;
		kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,
		    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);
	}
d373 1
a373 2
kue_reset(sc)
	struct kue_softc	*sc;
d379 1
a379 1
	err = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);
d393 1
a393 1
	const struct kue_type		*t;
a423 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct kue_softc));
#endif

d430 1
a430 1
	err = usbd_set_config_no(dev, KUE_CONFIG_NO, 0);
d500 1
a500 1
	s = splimp();
a504 33
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->kue_dev),
	    sc->kue_desc.kue_macaddr, ":");

	bcopy(sc->kue_desc.kue_macaddr,
	    (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_unit = sc->kue_unit;
	ifp->if_name = "kue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = kue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = kue_start;
	ifp->if_watchdog = kue_watchdog;
	ifp->if_init = kue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	kue_qdat.ifp = ifp;
	kue_qdat.if_rxstart = kue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a528 1

a533 1
#endif /* __NetBSD__ */
d572 1
a573 1
#endif /* __NetBSD__ */
a590 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d592 1
a592 3
kue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a612 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d618 1
a618 4
kue_newbuf(sc, c, m)
	struct kue_softc	*sc;
	struct kue_chain	*c;
	struct mbuf		*m;
d652 1
a652 2
kue_rx_list_init(sc)
	struct kue_softc	*sc;
d681 1
a681 2
kue_tx_list_init(sc)
	struct kue_softc	*sc;
a707 24
#ifdef __FreeBSD__
Static void
kue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct kue_softc	*sc;
	struct kue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->kue_cdata.kue_rx_chain[sc->kue_cdata.kue_rx_prod];

	if (kue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],
	    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, kue_rxeof);
	usbd_transfer(c->kue_xfer);
}
#endif

d713 1
a713 4
kue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a719 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a720 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a770 8
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d773 1
a773 1
	s = splimp();
d788 1
a788 3
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
a789 11
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
		BPF_MTAP(ifp, m);
#endif
	}
a796 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d816 1
a816 4
kue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d826 1
a826 1
	s = splimp();
a849 5
#if defined(__FreeBSD__)
	c->kue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->kue_mbuf);
	c->kue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a854 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d860 1
a860 4
kue_send(sc, m, idx)
	struct kue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d886 2
a887 1
	    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);
d904 1
a904 2
kue_start(ifp)
	struct ifnet		*ifp;
d941 1
a941 1
	ifp->if_timer = 5;
d945 1
a945 2
kue_init(xsc)
	void			*xsc;
d957 1
a957 1
	s = splimp();
d959 3
a961 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a962 2
#elif defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
d1016 1
a1016 2
kue_open_pipes(sc)
	struct kue_softc	*sc;
d1057 1
a1057 4
kue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1059 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1061 1
#endif
d1069 8
a1076 1
	s = splimp();
a1078 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1117 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d1157 1
a1157 2
kue_watchdog(ifp)
	struct ifnet		*ifp;
d1160 3
d1172 4
a1175 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->kue_udev, 1);
	kue_stop(sc);
	kue_init(sc);
	usbd_set_polling(sc->kue_udev, 0);
d1179 1
d1187 1
a1187 2
kue_stop(sc)
	struct kue_softc	*sc;
a1266 17

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
kue_shutdown(dev)
	device_t		dev;
{
	struct kue_softc	*sc;

	sc = device_get_softc(dev);

	kue_stop(sc);
}
#endif
@


1.10.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_kue.c,v 1.40 2001/04/08 02:10:57 augustss Exp $	*/
d73 6
d95 8
a102 2
#include <sys/device.h>
#include <sys/proc.h>
d109 2
d112 1
a112 1
#if defined(__NetBSD__)
d117 1
d119 3
d123 1
a123 1
#if NBPFILTER > 0
d145 1
d150 1
d157 4
a182 1
	{ USB_VENDOR_PERACOM, USB_PRODUCT_PERACOM_ENET3 },
d198 60
a257 20
Static int kue_tx_list_init(struct kue_softc *);
Static int kue_rx_list_init(struct kue_softc *);
Static int kue_newbuf(struct kue_softc *, struct kue_chain *,struct mbuf *);
Static int kue_send(struct kue_softc *, struct mbuf *, int);
Static int kue_open_pipes(struct kue_softc *);
Static void kue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void kue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void kue_start(struct ifnet *);
Static int kue_ioctl(struct ifnet *, u_long, caddr_t);
Static void kue_init(void *);
Static void kue_stop(struct kue_softc *);
Static void kue_watchdog(struct ifnet *);

Static void kue_setmulti(struct kue_softc *);
Static void kue_reset(struct kue_softc *);

Static usbd_status kue_ctl(struct kue_softc *, int, u_int8_t,
			   u_int16_t, void *, u_int32_t);
Static usbd_status kue_setword(struct kue_softc *, u_int8_t, u_int16_t);
Static int kue_load_fw(struct kue_softc *);
d260 4
a263 1
kue_setword(struct kue_softc *sc, u_int8_t breq, u_int16_t word)
d266 2
d277 5
a281 1
	return (usbd_do_request(sc->kue_udev, &req, NULL));
d285 7
a291 2
kue_ctl(struct kue_softc *sc, int rw, u_int8_t breq, u_int16_t val,
	void *data, u_int32_t len)
d294 2
d310 5
a314 1
	return (usbd_do_request(sc->kue_udev, &req, data));
d318 21
a338 1
kue_load_fw(struct kue_softc *sc)
a339 1
	usb_device_descriptor_t	dd;
d353 2
a354 4
	 * We can test this quickly by checking the bcdRevision
	 * code. The NIC will return a different revision code if
	 * it's probed while the firmware is still loaded and
	 * running.
d356 1
a356 3
	if (usbd_get_device_desc(sc->kue_udev, &dd))
		return (EIO);
	if (UGETW(dd.bcdDevice) == KUE_WARM_REV) {
d419 2
a420 1
kue_setmulti(struct kue_softc *sc)
d423 3
d428 1
d433 1
a433 3
	if (ifp->if_flags & IFF_PROMISC) {
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
d443 16
d465 10
a474 5
		if (i == KUE_MCFILTCNT(sc) ||
		    memcmp(enm->enm_addrlo, enm->enm_addrhi,
			ETHER_ADDR_LEN) != 0)
			goto allmulti;

d479 1
d481 7
a487 5
	ifp->if_flags &= ~IFF_ALLMULTI;

	sc->kue_rxfilt |= KUE_RXFILT_MULTICAST;
	kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,
	    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);
d498 2
a499 1
kue_reset(struct kue_softc *sc)
d505 1
a505 1
	err = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 1);
d519 1
a519 1
	const struct kue_type			*t;
d550 4
d560 1
a560 1
	err = usbd_set_config_no(dev, KUE_CONFIG_NO, 1);
d630 1
a630 1
	s = splnet();
d635 33
d685 1
a685 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
a686 1
	IFQ_SET_READY(&ifp->if_snd);
d692 1
d698 1
d737 1
a738 1
	ether_ifdetach(ifp);
d756 1
d758 3
a760 1
kue_activate(device_ptr_t self, enum devact act)
d781 1
d787 4
a790 1
kue_newbuf(struct kue_softc *sc, struct kue_chain *c, struct mbuf *m)
d824 2
a825 1
kue_rx_list_init(struct kue_softc *sc)
d854 2
a855 1
kue_tx_list_init(struct kue_softc *sc)
d882 24
d911 4
a914 1
kue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d921 1
d923 1
d974 8
d984 1
a984 1
	s = splnet();
d999 12
a1010 1
	if (ifp->if_bpf)
d1013 2
d1021 1
d1041 4
a1044 1
kue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1054 1
a1054 1
	s = splnet();
d1078 5
d1086 1
a1086 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1088 1
d1094 4
a1097 1
kue_send(struct kue_softc *sc, struct mbuf *m, int idx)
d1123 1
a1123 2
	    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT,
	    kue_txeof);
d1140 2
a1141 1
kue_start(struct ifnet *ifp)
d1154 1
a1154 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1159 1
a1163 2
	IFQ_DEQUEUE(&ifp->if_snd, m_head);

d1178 1
a1178 1
	ifp->if_timer = 6;
d1182 2
a1183 1
kue_init(void *xsc)
d1195 1
a1195 1
	s = splnet();
d1197 3
a1199 1
#if defined(__NetBSD__)
a1200 2
#else
	eaddr = sc->arpcom.ac_enaddr;
d1254 2
a1255 1
kue_open_pipes(struct kue_softc *sc)
d1296 4
a1299 1
kue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d1302 1
d1305 1
d1313 1
a1313 8
#ifdef DIAGNOSTIC
	if (!curproc) {
		printf("%s: no proc!!\n", USBDEVNAME(sc->kue_dev));
		return EIO;
	}
#endif

	s = splnet();
d1316 7
d1362 2
d1403 2
a1404 1
kue_watchdog(struct ifnet *ifp)
a1406 3
	struct kue_chain	*c;
	usbd_status		stat;
	int			s;
d1416 10
a1425 4
	s = splusb();
	c = &sc->kue_cdata.kue_tx_chain[0];
	usbd_get_xfer_status(c->kue_xfer, NULL, NULL, NULL, &stat);
	kue_txeof(c->kue_xfer, c, stat);
d1427 1
a1427 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
a1428 1
	splx(s);
d1436 2
a1437 1
kue_stop(struct kue_softc *sc)
d1517 17
@


1.10.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.10.2.2 2001/07/04 10:43:43 niklas Exp $ */
d521 3
@


1.10.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_kue.c,v 1.43 2001/10/08 03:37:53 augustss Exp $	*/
d153 1
a153 3
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C19250 },
	{ USB_VENDOR_3COM, USB_PRODUCT_3COM_3C460 },
	{ USB_VENDOR_ABOCOM, USB_PRODUCT_ABOCOM_URE450 },
a154 3
	{ USB_VENDOR_ADS, USB_PRODUCT_ADS_UBS10BTX },
	{ USB_VENDOR_AOX, USB_PRODUCT_AOX_USB101 },
	{ USB_VENDOR_ASANTE, USB_PRODUCT_ASANTE_EA },
a155 13
	{ USB_VENDOR_ATEN, USB_PRODUCT_ATEN_DSB650C },
	{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_ETHER_USB_T },
	{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DSB650C },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_E45 },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_XX1 },
	{ USB_VENDOR_ENTREGA, USB_PRODUCT_ENTREGA_XX2 },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBETT },
	{ USB_VENDOR_JATON, USB_PRODUCT_JATON_EDA },
	{ USB_VENDOR_KINGSTON, USB_PRODUCT_KINGSTON_XX1 },
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_DUH3E10BT },
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_DUH3E10BTN },
	{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_USB10T },
	{ USB_VENDOR_MOBILITY, USB_PRODUCT_MOBILITY_EA },
a156 1
	{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_EA101X },
d160 5
a164 4
	{ USB_VENDOR_PORTGEAR, USB_PRODUCT_PORTGEAR_EA8 },
	{ USB_VENDOR_PORTGEAR, USB_PRODUCT_PORTGEAR_EA9 },
	{ USB_VENDOR_PORTSMITH, USB_PRODUCT_PORTSMITH_EEA },
	{ USB_VENDOR_SHARK, USB_PRODUCT_SHARK_PA },
d166 4
d521 1
a522 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.10.2.5
log
@Merge in trunk
@
text
@d138 1
a138 1
#include <dev/microcode/kue/kue_fw.h>
@


1.10.2.6
log
@Merge in -current from roughly a week ago
@
text
@d770 1
a770 1
	memcpy(mtod(m, char *), c->kue_buf, total_len);
@


1.10.2.7
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: if_kue.c,v 1.50 2002/07/16 22:00:31 augustss Exp $	*/
d92 1
d103 2
d112 1
a112 1
#include <netinet/in.h>
a137 2

#if defined(__OpenBSD__)
a138 3
#else
#include <dev/usb/kue_fw.h>
#endif
d152 1
a152 1
Static const struct usb_devno kue_devs[] = {
d184 1
a185 1
#define kue_lookup(v, p) (usb_lookup(kue_devs, v, p))
d215 1
a215 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d233 1
a233 1
		     __func__, len));
d251 1
a251 1
	usb_device_descriptor_t dd;
d254 1
a254 1
	DPRINTFN(1,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d282 1
a282 1
	DPRINTFN(1,("%s: kue_load_fw: download code_seg\n",
d293 1
a293 1
	DPRINTFN(1,("%s: kue_load_fw: download fix_seg\n",
d304 1
a304 1
	DPRINTFN(1,("%s: kue_load_fw: download trig_seg\n",
d326 1
a326 1
	DPRINTFN(1,("%s: %s: done\n", USBDEVNAME(sc->kue_dev), __func__));
d342 1
a342 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d389 3
a391 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d393 2
a394 3
	if (usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 1) ||
	    usbd_device2interface_handle(sc->kue_udev, KUE_IFACE_IDX,
					 &sc->kue_iface))
d407 1
d414 5
a418 2
	return (kue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d519 1
a519 1
	printf("%s: address %s\n", USBDEVNAME(sc->kue_dev),
d582 3
d609 1
a609 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d635 1
a635 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d671 1
a671 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d700 1
a700 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev), __func__));
d736 1
a736 1
		     __func__, status));
d762 1
a762 1
		     __func__, total_len,
d802 1
a802 1
		bpf_mtap(ifp->if_bpf, m);
d806 1
a806 1
		    __func__, m->m_len));
d820 1
a820 1
		    __func__));
d842 1
a842 1
		    __func__, status));
d879 1
a879 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d922 1
a922 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d947 1
a947 1
		bpf_mtap(ifp->if_bpf, m_head);
d966 1
a966 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1036 1
a1036 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1063 1
a1063 1
			    __func__));
d1078 1
a1078 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1178 1
a1178 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
d1207 1
a1207 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->kue_dev),__func__));
@


1.10.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.10.2.7 2003/03/28 00:38:31 niklas Exp $ */
d437 1
a437 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.10.2.9
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d189 1
a189 1
USB_DECLARE_DRIVER_CLASS(kue, DV_IFNET);
@


1.10.2.10
log
@Merge with the trunk
@
text
@d1151 2
a1152 11
		error = (command == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);
		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			kue_setmulti(sc);
			error = 0;
		}
@


1.9
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.8 2001/01/30 21:07:27 deraadt Exp $ */
/*	$NetBSD: if_kue.c,v 1.28 2000/04/02 21:25:41 augustss Exp $	*/
a72 6
/*
 * TODO:
 * only use kue_do_request for downloading firmware.
 * more DPRINTF
 * proper cleanup on errors
 */
d89 2
a90 8

#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>

#elif defined(__NetBSD__) || defined(__OpenBSD__)
a96 2
#endif

d98 1
a98 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a102 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a103 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d105 1
a105 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a126 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a130 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a136 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d159 1
d175 20
a194 60
Static int kue_tx_list_init	__P((struct kue_softc *));
Static int kue_rx_list_init	__P((struct kue_softc *));
Static int kue_newbuf		__P((struct kue_softc *, struct kue_chain *,
				    struct mbuf *));
Static int kue_send		__P((struct kue_softc *, struct mbuf *, int));
Static int kue_open_pipes	__P((struct kue_softc *));
Static void kue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void kue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void kue_start		__P((struct ifnet *));
Static int kue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void kue_init		__P((void *));
Static void kue_stop		__P((struct kue_softc *));
Static void kue_watchdog		__P((struct ifnet *));

Static void kue_setmulti	__P((struct kue_softc *));
Static void kue_reset		__P((struct kue_softc *));

Static usbd_status kue_ctl	__P((struct kue_softc *, int, u_int8_t,
				    u_int16_t, void *, u_int32_t));
Static usbd_status kue_setword	__P((struct kue_softc *, u_int8_t, u_int16_t));
Static int kue_is_warm		__P((struct kue_softc *));
Static int kue_load_fw		__P((struct kue_softc *));

#if defined(__FreeBSD__)
#ifndef lint
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_kue.c,v 1.14 2000/01/14 01:36:15 wpaul Exp $";
#endif

Static void kue_rxstart		__P((struct ifnet *));
Static void kue_shutdown	__P((device_t));

Static struct usb_qdat kue_qdat;

Static device_method_t kue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		kue_match),
	DEVMETHOD(device_attach,	kue_attach),
	DEVMETHOD(device_detach,	kue_detach),
	DEVMETHOD(device_shutdown,	kue_shutdown),

	{ 0, 0 }
};

Static driver_t kue_driver = {
	"kue",
	kue_methods,
	sizeof(struct kue_softc)
};

Static devclass_t kue_devclass;

DRIVER_MODULE(if_kue, uhub, kue_driver, kue_devclass, usbd_driver_load, 0);

#endif /* __FreeBSD__ */

#define KUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d197 1
a197 4
kue_setword(sc, breq, word)
	struct kue_softc	*sc;
	u_int8_t		breq;
	u_int16_t		word;
a199 2
	usbd_status		err;
	int			s;
d209 1
a209 5
	s = splusb();
	err = KUE_DO_REQUEST(sc->kue_udev, &req, NULL);
	splx(s);

	return (err);
d213 2
a214 7
kue_ctl(sc, rw, breq, val, data, len)
	struct kue_softc	*sc;
	int			rw;
	u_int8_t		breq;
	u_int16_t		val;
	void			*data;
	u_int32_t		len;
a216 2
	usbd_status		err;
	int			s;
d231 1
a231 5
	s = splusb();
	err = KUE_DO_REQUEST(sc->kue_udev, &req, (void *)data);
	splx(s);

	return (err);
d235 1
a235 21
kue_is_warm(sc)
	struct kue_softc	*sc;
{
	usbd_status		err;
	usb_device_request_t	req;

	/* Just issue some random command. */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = KUE_CMD_GET_ETHER_DESCRIPTOR;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, sizeof(sc->kue_desc));

	err = usbd_do_request(sc->kue_udev, &req, &sc->kue_desc);

	return (!err);
}

Static int
kue_load_fw(sc)
	struct kue_softc	*sc;
d237 1
d251 4
a254 2
	 * We can test this quickly by issuing a request that
	 * is only valid after firmware download.
d256 3
a258 1
	if (kue_is_warm(sc)) {
d321 1
a321 2
kue_setmulti(sc)
	struct kue_softc	*sc;
a323 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a325 1
#endif
d330 3
a332 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a341 16
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		/*
		 * If there are too many addresses for the
		 * internal filter, switch over to allmulti mode.
		 */
		if (i == KUE_MCFILTCNT(sc))
			break;
		bcopy(LLADDR((struct sockaddr_dl *)ifma->ifma_addr),
		    KUE_MCFILT(sc, i), ETHER_ADDR_LEN);
		i++;
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d348 5
a352 10
		if (i == KUE_MCFILTCNT(sc))
			break;
#if 0
		if (memcmp(enm->enm_addrlo,
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			/* XXX what now? */
			return;
		}
#endif
a356 1
#endif
d358 5
a362 7
	if (i == KUE_MCFILTCNT(sc))
		sc->kue_rxfilt |= KUE_RXFILT_ALLMULTI;
	else {
		sc->kue_rxfilt |= KUE_RXFILT_MULTICAST;
		kue_ctl(sc, KUE_CTL_WRITE, KUE_CMD_SET_MCAST_FILTERS,
		    i, sc->kue_mcfilters, i * ETHER_ADDR_LEN);
	}
d373 1
a373 2
kue_reset(sc)
	struct kue_softc	*sc;
d379 1
a379 1
	err = usbd_set_config_no(sc->kue_udev, KUE_CONFIG_NO, 0);
d393 1
a393 1
	const struct kue_type		*t;
a423 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct kue_softc));
#endif

d430 1
a430 1
	err = usbd_set_config_no(dev, KUE_CONFIG_NO, 0);
d500 1
a500 1
	s = splimp();
a504 33
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->kue_dev),
	    sc->kue_desc.kue_macaddr, ":");

	bcopy(sc->kue_desc.kue_macaddr,
	    (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_unit = sc->kue_unit;
	ifp->if_name = "kue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = kue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = kue_start;
	ifp->if_watchdog = kue_watchdog;
	ifp->if_init = kue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	kue_qdat.ifp = ifp;
	kue_qdat.if_rxstart = kue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));
	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a528 1

a533 1
#endif /* __NetBSD__ */
d572 1
a573 1
#endif /* __NetBSD__ */
a590 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d592 1
a592 3
kue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a612 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d618 1
a618 4
kue_newbuf(sc, c, m)
	struct kue_softc	*sc;
	struct kue_chain	*c;
	struct mbuf		*m;
d652 1
a652 2
kue_rx_list_init(sc)
	struct kue_softc	*sc;
d681 1
a681 2
kue_tx_list_init(sc)
	struct kue_softc	*sc;
a707 24
#ifdef __FreeBSD__
Static void
kue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct kue_softc	*sc;
	struct kue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->kue_cdata.kue_rx_chain[sc->kue_cdata.kue_rx_prod];

	if (kue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->kue_xfer, sc->kue_ep[KUE_ENDPT_RX],
	    c, c->kue_buf, KUE_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, kue_rxeof);
	usbd_transfer(c->kue_xfer);
}
#endif

d713 1
a713 4
kue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a719 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a720 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a770 8
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d773 1
a773 1
	s = splimp();
d788 1
a788 3
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
a789 11
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
		BPF_MTAP(ifp, m);
#endif
	}
a796 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d816 1
a816 4
kue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d826 1
a826 1
	s = splimp();
a849 5
#if defined(__FreeBSD__)
	c->kue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->kue_mbuf);
	c->kue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a854 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d860 1
a860 4
kue_send(sc, m, idx)
	struct kue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d886 2
a887 1
	    c, c->kue_buf, total_len, USBD_NO_COPY, USBD_DEFAULT_TIMEOUT, kue_txeof);
d904 1
a904 2
kue_start(ifp)
	struct ifnet		*ifp;
d941 1
a941 1
	ifp->if_timer = 5;
d945 1
a945 2
kue_init(xsc)
	void			*xsc;
d957 1
a957 1
	s = splimp();
d959 3
a961 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
a962 2
#elif defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
d1016 1
a1016 2
kue_open_pipes(sc)
	struct kue_softc	*sc;
d1057 1
a1057 4
kue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1059 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1061 1
#endif
d1069 8
a1076 1
	s = splimp();
a1078 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1117 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d1157 1
a1157 2
kue_watchdog(ifp)
	struct ifnet		*ifp;
d1160 3
d1172 4
a1175 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->kue_udev, 1);
	kue_stop(sc);
	kue_init(sc);
	usbd_set_polling(sc->kue_udev, 0);
d1179 1
d1187 1
a1187 2
kue_stop(sc)
	struct kue_softc	*sc;
a1266 17

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
kue_shutdown(dev)
	device_t		dev;
{
	struct kue_softc	*sc;

	sc = device_get_softc(dev);

	kue_stop(sc);
}
#endif
@


1.8
log
@AboCom URE450
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.7 2001/01/28 09:43:41 aaron Exp $ */
a692 4
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.7
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.6 2000/12/05 21:37:39 deraadt Exp $ */
d192 1
@


1.6
log
@new IODATA USB-ET/T is a KL5KUSB101B; ori@@tahoo.org
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.5 2000/04/23 17:33:47 maja Exp $ */
d176 1
a176 1
Static struct kue_type kue_devs[] = {
d310 1
a310 1
	err = KUE_DO_REQUEST(sc->kue_udev, &req, data);
d368 1
a368 1
	    0, kue_code_seg, sizeof(kue_code_seg));
d379 1
a379 1
	    0, kue_fix_seg, sizeof(kue_fix_seg));
d390 1
a390 1
	    0, kue_trig_seg, sizeof(kue_trig_seg));
d518 1
a518 1
	struct kue_type			*t;
@


1.5
log
@Save ethernet address in arpcom.ac_enaddr. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.4 2000/04/04 22:52:30 aaron Exp $ */
d191 1
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_kue.c,v 1.3 2000/03/30 16:19:32 aaron Exp $ */
d668 5
@


1.3
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_kue.c,v 1.2 2000/03/28 19:37:47 aaron Exp $ */
/*	$NetBSD: if_kue.c,v 1.27 2000/03/30 00:18:17 augustss Exp $	*/
d1125 2
a1126 2
		DPRINTF(("%s: kue_send err=%s\n", USBDEVNAME(sc->kue_dev),
			 usbd_errstr(err)));
@


1.2
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_kue.c,v 1.23 2000/03/26 15:08:44 augustss Exp $	*/
d176 1
a176 1
static struct kue_type kue_devs[] = {
d196 3
a198 3
static int kue_tx_list_init	__P((struct kue_softc *));
static int kue_rx_list_init	__P((struct kue_softc *));
static int kue_newbuf		__P((struct kue_softc *, struct kue_chain *,
d200 3
a202 3
static int kue_send		__P((struct kue_softc *, struct mbuf *, int));
static int kue_open_pipes	__P((struct kue_softc *));
static void kue_rxeof		__P((usbd_xfer_handle,
d204 1
a204 1
static void kue_txeof		__P((usbd_xfer_handle,
d206 5
a210 5
static void kue_start		__P((struct ifnet *));
static int kue_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void kue_init		__P((void *));
static void kue_stop		__P((struct kue_softc *));
static void kue_watchdog		__P((struct ifnet *));
d212 2
a213 2
static void kue_setmulti	__P((struct kue_softc *));
static void kue_reset		__P((struct kue_softc *));
d215 1
a215 1
static usbd_status kue_ctl	__P((struct kue_softc *, int, u_int8_t,
d217 3
a219 3
static usbd_status kue_setword	__P((struct kue_softc *, u_int8_t, u_int16_t));
static int kue_is_warm		__P((struct kue_softc *));
static int kue_load_fw		__P((struct kue_softc *));
d227 2
a228 2
static void kue_rxstart		__P((struct ifnet *));
static void kue_shutdown	__P((device_t));
d230 1
a230 1
static struct usb_qdat kue_qdat;
d232 1
a232 1
static device_method_t kue_methods[] = {
d242 1
a242 1
static driver_t kue_driver = {
d248 1
a248 1
static devclass_t kue_devclass;
d257 1
a257 1
static usbd_status
d282 1
a282 1
static usbd_status
d315 1
a315 1
static int
d334 1
a334 1
static int
d416 1
a416 1
static void
d495 1
a495 1
static void
d677 3
d684 1
a684 5
#if defined(__NetBSD__)
	ether_ifattach(ifp, sc->kue_desc.kue_macaddr);
#else
	ether_ifattach(ifp);
#endif
d783 1
a783 1
static int
d820 1
a820 1
static int
d850 1
a850 1
static int
d880 1
a880 1
static void
d907 1
a907 1
static void
a919 1
	struct ether_header	*eh;
a988 2
	eh = mtod(m, struct ether_header *);

d997 2
a999 1
#if defined(__NetBSD__)
d1007 2
d1015 1
a1015 5
#if defined(__NetBSD__)
	(*ifp->if_input)(ifp, m);
#else
	ether_input(ifp, eh, m);
#endif
d1037 1
a1037 1
static void
d1090 1
a1090 1
static int
a1118 1
	/* XXX 10000 */
d1120 1
a1120 1
	    c, c->kue_buf, total_len, USBD_NO_COPY, 10000, kue_txeof);
d1125 2
d1136 1
a1136 1
static void
d1178 1
a1178 1
static void
d1250 1
a1250 1
static int
d1292 1
a1292 1
static int
d1399 1
a1399 1
static void
d1432 1
a1432 1
static void
d1520 1
a1520 1
static void
@


1.1
log
@Driver for USB Ethernet adapters based on the Kawasaki LSI KL5KUSB101B.
@
text
@d2 1
a2 1
/*	$NetBSD: if_kue.c,v 1.21 2000/03/24 22:03:30 augustss Exp $	*/
d79 3
d83 4
d96 8
d105 5
d112 3
a115 1
#include <net/if_types.h>
d117 19
d143 1
d145 1
a145 6
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

d150 1
d157 4
d190 1
a190 1
	{ USB_VENDOR_KLSI, USB_PRODUCT_KLSI_USB101 },
d196 57
a252 23
int kue_tx_list_init	__P((struct kue_softc *));
int kue_rx_list_init	__P((struct kue_softc *));
int kue_newbuf		__P((struct kue_softc *, struct kue_chain *,
			    struct mbuf *));
int kue_send		__P((struct kue_softc *, struct mbuf *, int));
int kue_open_pipes	__P((struct kue_softc *));
void kue_rxeof		__P((usbd_xfer_handle,
			    usbd_private_handle, usbd_status));
void kue_txeof		__P((usbd_xfer_handle,
			    usbd_private_handle, usbd_status));
void kue_start		__P((struct ifnet *));
int kue_ioctl		__P((struct ifnet *, u_long, caddr_t));
void kue_init		__P((void *));
void kue_stop		__P((struct kue_softc *));
void kue_watchdog	__P((struct ifnet *));

void kue_setmulti	__P((struct kue_softc *));
void kue_reset		__P((struct kue_softc *));

usbd_status kue_ctl	__P((struct kue_softc *, int, u_int8_t,
			    u_int16_t, void *, u_int32_t));
usbd_status kue_setword	__P((struct kue_softc *, u_int8_t, u_int16_t));
int kue_load_fw		__P((struct kue_softc *));
d257 1
a257 1
usbd_status
d282 1
a282 1
usbd_status
d315 20
a334 1
int
d354 1
a354 3
	err = kue_ctl(sc, KUE_CTL_READ, KUE_CMD_GET_ETHER_DESCRIPTOR,
	    0, &sc->kue_desc, sizeof(sc->kue_desc));
	if (!err) {
d416 1
a416 1
void
d420 4
a423 2
	struct ifnet		*ifp;
	struct arpcom		*ac = &sc->arpcom;
d426 1
a428 2
	ifp = &sc->arpcom.ac_if;

d441 21
a461 1
	ETHER_FIRST_MULTI(step, ac, enm);
d477 1
d495 1
a495 1
void
d548 4
d633 33
d670 1
a670 1
	ifp = &sc->arpcom.ac_if;
d681 3
d685 1
d688 1
a688 1
	bpfattach(&sc->arpcom.ac_if.if_bpf, ifp, DLT_EN10MB,
d691 6
d709 1
a709 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d728 4
d736 1
d754 1
d770 4
a774 1
		return (EOPNOTSUPP);
d779 1
d784 1
a784 1
int
d821 1
a821 1
int
d851 1
a851 1
int
d908 1
a908 1
void
a913 1
	struct ether_header	*eh;
d916 1
a916 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d919 1
d921 2
d973 8
d994 18
a1011 2
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m);
d1016 3
d1020 1
d1023 1
d1042 1
a1042 1
void
d1050 1
a1050 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1080 5
d1090 1
d1095 1
a1095 1
int
d1140 1
a1140 1
void
d1171 1
a1171 1
		bpf_mtap(ifp->if_bpf, m_head);
d1182 1
a1182 1
void
d1187 1
a1187 1
	struct ifnet		*ifp = &sc->arpcom.ac_if;
d1198 1
d1200 3
a1202 1

d1254 1
a1254 1
int
d1296 1
a1296 1
int
d1303 1
d1306 1
d1317 7
d1331 3
d1335 1
d1345 1
a1345 1
					sc->arpcom.ac_enaddr;
d1347 1
a1347 1
				memcpy(sc->arpcom.ac_enaddr,
d1363 2
d1403 1
a1403 1
void
d1436 1
a1436 1
void
d1446 1
a1446 1
	ifp = &sc->arpcom.ac_if;
@

