head	1.57;
access;
symbols
	OPENBSD_6_2:1.57.0.12
	OPENBSD_6_2_BASE:1.57
	OPENBSD_6_1:1.57.0.10
	OPENBSD_6_1_BASE:1.57
	OPENBSD_6_0:1.57.0.8
	OPENBSD_6_0_BASE:1.57
	OPENBSD_5_9:1.57.0.2
	OPENBSD_5_9_BASE:1.57
	OPENBSD_5_8:1.57.0.4
	OPENBSD_5_8_BASE:1.57
	OPENBSD_5_7:1.56.0.2
	OPENBSD_5_7_BASE:1.56
	OPENBSD_5_6:1.56.0.6
	OPENBSD_5_6_BASE:1.56
	OPENBSD_5_5:1.56.0.4
	OPENBSD_5_5_BASE:1.56
	OPENBSD_5_4:1.55.0.2
	OPENBSD_5_4_BASE:1.55
	OPENBSD_5_3:1.54.0.8
	OPENBSD_5_3_BASE:1.54
	OPENBSD_5_2:1.54.0.6
	OPENBSD_5_2_BASE:1.54
	OPENBSD_5_1_BASE:1.54
	OPENBSD_5_1:1.54.0.4
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.46.0.2
	OPENBSD_4_8_BASE:1.46
	OPENBSD_4_7:1.45.0.4
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.27.0.2
	OPENBSD_4_4_BASE:1.27;
locks; strict;
comment	@ * @;


1.57
date	2015.07.09.14.58.32;	author mpi;	state Exp;
branches;
next	1.56;
commitid	FD53NNEpFSdy0VGJ;

1.56
date	2013.11.07.11.14.26;	author pirofti;	state Exp;
branches;
next	1.55;

1.55
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.54;

1.54
date	2011.04.11.02.04.48;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.26.08.13.05;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.25.21.23.54;	author jakemsr;	state Exp;
branches;
next	1.51;

1.51
date	2010.11.27.00.38.29;	author weerd;	state Exp;
branches;
next	1.50;

1.50
date	2010.10.09.09.48.04;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.09.08.41.28;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.29.09.33.26;	author jakemsr;	state Exp;
branches;
next	1.47;

1.47
date	2010.09.26.23.44.51;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.04.27.11.58.14;	author marco;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.19.21.17.35;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.02.12.14.48.00;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2008.12.22.09.34.46;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2008.12.17.18.14.46;	author mglocker;	state Exp;
branches;
next	1.41;

1.41
date	2008.12.08.22.02.39;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2008.12.08.18.33.24;	author mglocker;	state Exp;
branches;
next	1.39;

1.39
date	2008.12.05.10.44.52;	author mglocker;	state Exp;
branches;
next	1.38;

1.38
date	2008.12.03.03.47.25;	author yuo;	state Exp;
branches;
next	1.37;

1.37
date	2008.12.03.03.44.25;	author yuo;	state Exp;
branches;
next	1.36;

1.36
date	2008.12.03.03.28.25;	author yuo;	state Exp;
branches;
next	1.35;

1.35
date	2008.11.30.15.20.33;	author mglocker;	state Exp;
branches;
next	1.34;

1.34
date	2008.11.10.13.15.51;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2008.11.09.21.24.55;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2008.11.09.20.14.06;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.27.17.31.48;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.26.21.52.48;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2008.08.24.11.43.00;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2008.08.24.11.05.03;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2008.08.02.21.52.37;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2008.07.31.15.26.25;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2008.07.26.11.42.43;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2008.07.24.14.59.44;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2008.07.19.11.30.55;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2008.07.18.18.49.11;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2008.07.14.04.45.50;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2008.07.13.11.49.31;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2008.07.12.06.26.06;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2008.07.03.09.50.04;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.02.21.28.50;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2008.06.30.17.04.18;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.06.26.21.00.27;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.09.20.51.31;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2008.06.09.19.57.45;	author robert;	state Exp;
branches;
next	1.12;

1.12
date	2008.06.07.22.14.58;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2008.06.06.19.14.45;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2008.06.05.20.50.28;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2008.05.27.17.47.28;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2008.05.24.19.37.34;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2008.04.20.09.14.05;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2008.04.18.21.19.15;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2008.04.16.20.45.24;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2008.04.16.12.19.11;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2008.04.10.09.22.15;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2008.04.09.20.38.55;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2008.04.09.19.49.55;	author robert;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Move the softc definition to uvideo.c so that userland can include
<dev/usb/uvideo.h> to get USB video descriptor definitions.

from Ludovic Coues.
@
text
@/*	$OpenBSD: uvideo.h,v 1.56 2013/11/07 11:14:26 pirofti Exp $ */

/*
 * Copyright (c) 2007 Robert Nagy <robert@@openbsd.org>
 * Copyright (c) 2008 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include <sys/queue.h>
#include <sys/videoio.h>

/*
 * USB Video Class
 */
/* Table A-7: Video Class-Specific Endpoint Descriptor Subtypes */
#define	EP_UNDEFINED					0x00
#define EP_GENERAL					0x01
#define EP_ENDPOINT					0x02
#define EP_INTERRUPT					0x03

/* Table A-5: Video Class-Specific VC Interface Descriptor Subtypes */
#define	UDESCSUB_VC_DESCRIPTOR_UNDEFINED		0x00
#define UDESCSUB_VC_HEADER				0x01
#define UDESCSUB_VC_INPUT_TERMINAL			0x02
#define UDESCSUB_VC_OUTPUT_TERMINAL			0x03
#define UDESCSUB_VC_SELECTOR_UNIT			0x04
#define UDESCSUB_VC_PROCESSING_UNIT			0x05
#define UDESCSUB_VC_EXTENSION_UNIT			0x06

/* Table A-6: Video Class-Specific VS Interface Descriptor Subtypes */
#define	UDESCSUB_VS_UNDEFINED				0x00
#define UDESCSUB_VS_INPUT_HEADER			0x01
#define UDESCSUB_VS_OUTPUT_HEADER			0x02
#define UDESCSUB_VS_STILL_IMAGE_FRAME			0x03
#define UDESCSUB_VS_FORMAT_UNCOMPRESSED			0x04
#define UDESCSUB_VS_FRAME_UNCOMPRESSED			0x05
#define UDESCSUB_VS_FORMAT_MJPEG			0x06
#define UDESCSUB_VS_FRAME_MJPEG				0x07
#define UDESCSUB_VS_FORMAT_MPEG2TS			0x0a
#define UDESCSUB_VS_FORMAT_DV				0x0c
#define UDESCSUB_VS_COLORFORMAT				0x0d
#define UDESCSUB_VS_FORMAT_FRAME_BASED			0x10
#define UDESCSUB_VS_FRAME_FRAME_BASED			0x11
#define UDESCSUB_VS_FORMAT_STREAM_BASED			0x12

/* Table A-8: Video Class-Specific Request Codes */
#define RC_UNDEFINED					0x00
#define SET_CUR						0x01
#define GET_CUR						0x81
#define GET_MIN						0x82
#define GET_MAX						0x83
#define GET_RES						0x84
#define GET_LEN						0x85
#define GET_INFO					0x86
#define GET_DEF						0x87

/* Table A-9: Video Control Interface Control Selectors */
#define VC_CONTROL_UNDEFINED				0x00
#define VC_VIDEO_POWER_MODE_CONTROL			0x01
#define VC_REQUEST_ERROR_CODE_CONTROL			0x02

/* Table A-11: Selector Unit Control Selectors */
#define	SU_CONTROL_UNDEFINED				0x00
#define	SU_INPUT_SELECT_CONTROL				0x01

/* Table A-12: Camera Terminal Control Selectors */
#define	CT_CONTROL_UNDEFINED				0x00
#define	CT_SCANNING_MODE_CONTROL			0x01
#define	CT_AE_MODE_CONTROL				0x02
#define	CT_AE_PRIORITY_CONTROL				0x03
#define	CT_EXPOSURE_TIME_ABSOLUTE_CONTROL		0x04
#define	CT_EXPOSURE_TIME_RELATIVE_CONTROL		0x05
#define	CT_FOCUS_ABSOLUTE_CONTROL			0x06
#define	CT_FOCUS_RELATIVE_CONTROL			0x07
#define	CT_FOCUS_AUTO_CONTROL				0x08
#define	CT_IRIS_ABSOLUTE_CONTROL			0x09
#define	CT_IRIS_RELATIVE_CONTROL			0x0a
#define	CT_ZOOM_ABSOLUTE_CONTROL			0x0b
#define	CT_ZOOM_RELATIVE_CONTROL			0x0c
#define	CT_PANTILT_ABSOLUTE_CONTROL			0x0d
#define	CT_PANTILT_RELATIVE_CONTROL			0x0e
#define	CT_ROLL_ABSOLUTE_CONTROL			0x0f
#define	CT_ROLL_RELATIVE_CONTROL			0x10
#define	CT_PRIVACY_CONTROL				0x11

/* Table A-13: Processing Unit Control Selectors */
#define	PU_CONTROL_UNDEFINED				0x00
#define	PU_BACKLIGHT_COMPENSATION_CONTROL		0x01
#define	PU_BRIGHTNESS_CONTROL				0x02
#define	PU_CONTRAST_CONTROL				0x03
#define	PU_GAIN_CONTROL					0x04
#define	PU_POWER_LINE_FREQUENCY_CONTROL			0x05
#define	PU_HUE_CONTROL					0x06
#define	PU_SATURATION_CONTROL				0x07
#define	PU_SHARPNESS_CONTROL				0x08
#define	PU_GAMMA_CONTROL				0x09
#define	PU_WHITE_BALANCE_TEMPERATURE_CONTROL		0x0a
#define	PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL	0x0b
#define	PU_WHITE_BALANCE_COMPONENT_CONTROL		0x0c
#define	PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL		0x0d
#define	PU_DIGITAL_MULTIPLIER_CONTROL			0x0e
#define	PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL		0x0f
#define	PU_HUE_AUTO_CONTROL				0x10
#define	PU_ANALOG_VIDEO_STANDARD_CONTROL		0x11
#define	PU_ANALOG_LOCK_STATUS_CONTROL			0x12

/* Table A-15: VideoStreaming Interface Control Selectors */
#define	VS_CONTROL_UNDEFINED				0x00
#define	VS_PROBE_CONTROL				0x01
#define	VS_COMMIT_CONTROL				0x02
#define	VS_STILL_PROBE_CONTROL				0x03
#define	VS_STILL_COMMIT_CONTROL				0x04
#define	VS_STILL_IMAGE_TRIGGER_CONTROL			0x05
#define	VS_STREAM_ERROR_CODE_CONTROL			0x06
#define	VS_GENERATE_KEY_FRAME_CONTROL			0x07
#define	VS_UPDATE_FRAME_SEGMENT_CONTROL			0x08
#define	VS_SYNC_DELAY_CONTROL				0x09

/* probe commit bmRequests */
#define	UVIDEO_SET_IF					0x21
#define	UVIDEO_GET_IF					0xa1
#define	UVIDEO_SET_EP					0x22
#define	UVIDEO_GET_EP					0xa2

/* Table B-1: USB Terminal Types */
#define	TT_VENDOR_SPECIFIC				0x0100
#define	TT_STREAMING					0x0101

/* Table B-2: Input Terminal Types */
#define	ITT_VENDOR_SPECIFIC				0x0200
#define	ITT_CAMERA					0x0201
#define	ITT_MEDIA_TRANSPORT_INPUT			0x0202

/* Table B-3: Output Terminal Types */
#define	OTT_VENDOR_SPECIFIC				0x0300
#define	OTT_DISPLAY					0x0301
#define	OTT_MEDIA_TRANSPORT_OUTPUT			0x0302

/* Table B-4: External Terminal Types */
#define	EXTERNAL_VENDOR_SPECIFIC			0x0400
#define	COMPOSITE_CONNECTOR				0x0401
#define	SVIDEO_CONNECTOR				0x0402
#define	COMPONENT_CONNECTOR				0x0403

/* Table 3-3: VC Interface Header Descriptor */
struct usb_video_header_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uWord	bcdUVC;
	uWord	wTotalLength;
	uDWord	dwClockFrequency;
	uByte	bInCollection;
} __packed;

struct usb_video_header_desc_all {
	struct usb_video_header_desc	*fix;
	uByte				*baInterfaceNr;
};

/* Table 3-4: Input Terminal Descriptor */
struct usb_video_input_terminal_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bTerminalID;
	uWord	wTerminalType;
	uByte	bAssocTerminal;
	uByte	iTerminal;
} __packed;

/* Table 3-5: Output Terminal Descriptor */
struct usb_video_output_terminal_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bTerminalID;
	uWord	wTerminalType;
	uByte	bAssocTerminal;
	uByte	bSourceID;
	uByte	iTerminal;
} __packed;

/* Table 3-6: Camera Terminal Descriptor */
struct usb_video_camera_terminal_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bTerminalID;
	uWord	wTerminalType;
	uByte	bAssocTerminal;
	uByte	iTerminal;
	uWord	wObjectiveFocalLengthMin;
	uWord	wObjectiveFocalLengthMax;
	uWord	wOcularFocalLength;
	uByte	bControlSize;
	uByte	*bmControls;
} __packed;

/* Table 3-8: VC Processing Unit Descriptor */
struct usb_video_vc_processing_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bUnitID;
	uByte	bSourceID;
	uWord	wMaxMultiplier;
	uByte	bControlSize;
	uByte	bmControls[255]; /* [bControlSize] */
	/* uByte iProcessing; */
	/* uByte bmVideoStandards; */
} __packed;

/* Table 3-9: VC Extension Unit Descriptor */
struct usb_video_vc_extension_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bUnitID;
	uByte	guidExtensionCode[16];
	uByte	bNumControls;
	uByte	bNrInPins;
} __packed;

/* Table 3-11: VC Endpoint Descriptor */
struct usb_video_vc_endpoint_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uWord	wMaxTransferSize;
} __packed;

/* Table 3-13: Interface Input Header Descriptor */
struct usb_video_input_header_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bNumFormats;
	uWord	wTotalLength;
	uByte	bEndpointAddress;
	uByte	bmInfo;
	uByte	bTerminalLink;
	uByte	bStillCaptureMethod;
	uByte	bTriggerSupport;
	uByte	bTriggerUsage;
	uByte	bControlSize;
} __packed;

struct usb_video_input_header_desc_all {
	struct usb_video_input_header_desc	*fix;
	uByte					*bmaControls;
};

/* Table 3-18: Color Matching Descriptor */
struct usb_video_color_matching_descr {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bColorPrimaries;
	uByte	bTransferCharacteristics;
	uByte	bMatrixCoefficients;
} __packed;

/* Table 4-47: Video Probe and Commit Controls */
struct usb_video_probe_commit {
	uWord	bmHint;
	uByte	bFormatIndex;
	uByte	bFrameIndex;
	uDWord	dwFrameInterval;
	uWord	wKeyFrameRate;
	uWord	wPFrameRate;
	uWord	wCompQuality;
	uWord	wCompWindowSize;
	uWord	wDelay;
	uDWord	dwMaxVideoFrameSize;
	uDWord	dwMaxPayloadTransferSize;
	uDWord	dwClockFrequency;
	uByte	bmFramingInfo;
	uByte	bPreferedVersion;
	uByte	bMinVersion;
	uByte	bMaxVersion;
} __packed;

/*
 * USB Video Payload Uncompressed
 */
/* Table 2-1: Compression Formats */
#define	UVIDEO_FORMAT_GUID_YUY2	{			\
    0x59, 0x55, 0x59, 0x32, 0x00, 0x00, 0x10, 0x00,	\
    0x80, 0x00, 0x00, 0xaa, 0x00, 0x38, 0x9b, 0x71 }

#define	UVIDEO_FORMAT_GUID_NV12	{			\
    0x4e, 0x56, 0x31, 0x32, 0x00, 0x00, 0x10, 0x00,	\
    0x80, 0x00, 0x00, 0xaa, 0x00, 0x38,	0x9b, 0x71 }

#define	UVIDEO_FORMAT_GUID_UYVY	{			\
    0x55, 0x59, 0x56, 0x59, 0x00, 0x00, 0x10, 0x00,	\
    0x80, 0x00, 0x00, 0xaa, 0x00, 0x38,	0x9b, 0x71 }

/*
 * USB Video Payload MJPEG
 */
/* Table 2-1: Stream Header Format for the Motion-JPEG */
#define UVIDEO_SH_MAX_LEN	12
#define UVIDEO_SH_MIN_LEN	2
struct usb_video_stream_header {
	uByte	bLength;
	uByte	bFlags;
#define	UVIDEO_SH_FLAG_FID	(1 << 0)
#define	UVIDEO_SH_FLAG_EOF	(1 << 1)
#define	UVIDEO_SH_FLAG_PTS	(1 << 2)
#define	UVIDEO_SH_FLAG_SCR	(1 << 3)
#define	UVIDEO_SH_FLAG_RES	(1 << 4)
#define	UVIDEO_SH_FLAG_STI	(1 << 5)
#define	UVIDEO_SH_FLAG_ERR	(1 << 6)
#define	UVIDEO_SH_FLAG_EOH	(1 << 7)
	/* TODO complete struct */
} __packed;

/* Table 3-1: Motion-JPEG Video Format Descriptor */
struct usb_video_format_mjpeg_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFormatIndex;
	uByte	bNumFrameDescriptors;
	uByte	bmFlags;
	uByte	bDefaultFrameIndex;
	uByte	bAspectRatioX;
	uByte	bAspectRatioY;
	uByte	bmInterlaceFlags;
	uByte	bCopyProtect;
} __packed;

/* Table 3-2: Video Frame Descriptor (same for mjpeg and uncompressed)*/
struct usb_video_frame_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFrameIndex;
	uByte	bmCapabilities;
	uWord	wWidth;
	uWord	wHeight;
	uDWord	dwMinBitRate;
	uDWord	dwMaxBitRate;
	uDWord	dwMaxVideoFrameBufferSize;
	uDWord	dwDefaultFrameInterval;
	uByte	bFrameIntervalType;
	/* uDWord ivals[]; frame intervals, length varies */
} __packed;

/*
 * USB Video Payload Uncompressed
 */
/* Table 3-1: Uncompressed Video Format Descriptor */
struct usb_video_format_uncompressed_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFormatIndex;
	uByte	bNumFrameDescriptors;
	uByte	guidFormat[16];
	uByte	bBitsPerPixel;
	uByte	bDefaultFrameIndex;
	uByte	bAspectRatioX;
	uByte	bAspectRatioY;
	uByte	bmInterlaceFlags;
	uByte	bCopyProtect;
} __packed;

/*
 * Driver specific private definitions.
 */
struct uvideo_format_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFormatIndex;
	uByte	bNumFrameDescriptors;
	union {
		/* mjpeg */
		struct {
			uByte	bmFlags;
			uByte	bDefaultFrameIndex;
			uByte	bAspectRatioX;
			uByte	bAspectRatioY;
			uByte	bmInterlaceFlags;
			uByte	bCopyProtect;
		} mjpeg;

		/* uncompressed */
		struct {
			uByte	guidFormat[16];
			uByte	bBitsPerPixel;
			uByte	bDefaultFrameIndex;
			uByte	bAspectRatioX;
			uByte	bAspectRatioY;
			uByte	bmInterlaceFlags;
			uByte	bCopyProtect;
		} uc;
	} u;
} __packed;

#define UVIDEO_NFRAMES_MAX	40
struct uvideo_isoc_xfer {
	struct uvideo_softc	*sc;
	struct usbd_xfer	*xfer;
	void			*buf;
	uint16_t		 size[UVIDEO_NFRAMES_MAX];
};

struct uvideo_bulk_xfer {
	struct uvideo_softc	*sc;
	struct usbd_xfer	*xfer;
	void			*buf;
	uint16_t		 size;
};

#define UVIDEO_IXFERS		3
struct uvideo_vs_iface {
	struct usbd_interface	*ifaceh;
	struct usbd_pipe	*pipeh;
	int			 iface;
	int			 numalts;
	int			 curalt;
	int			 endpoint;
	uint32_t		 psize;
	int			 bulk_endpoint;
	int			 bulk_running;
	struct uvideo_isoc_xfer	 ixfer[UVIDEO_IXFERS];
	struct uvideo_bulk_xfer	 bxfer;
};

struct uvideo_frame_buffer {
	int		 sample;
	uint8_t		 fid;
	int		 offset;
	int		 buf_size;
	uint8_t		*buf;
	uint32_t	 fmt_flags;
};

#define UVIDEO_MAX_BUFFERS	32
struct uvideo_mmap {
	SIMPLEQ_ENTRY(uvideo_mmap)	q_frames;
	uint8_t				*buf;
	struct v4l2_buffer		 v4l2_buf;
};
typedef SIMPLEQ_HEAD(, uvideo_mmap) q_mmap;

struct uvideo_format_group {
	uint32_t				 pixelformat;
	uint8_t					 format_dfidx;
	struct uvideo_format_desc		*format;
	/* frame descriptors for mjpeg and uncompressed are identical */
#define UVIDEO_MAX_FRAME			 32
	struct usb_video_frame_desc		*frame_cur;
	struct usb_video_frame_desc		*frame[UVIDEO_MAX_FRAME];
	int					 frame_num;
};

struct uvideo_res {
	int width;
	int height;
	int fidx;
};

struct uvideo_controls {
	int		cid;
	int		type;
	char		name[32];
	uint8_t         ctrl_bit;
	uint16_t	ctrl_selector;
	uint16_t	ctrl_len;
	int		sig;
} uvideo_ctrls[] = {
        /*
         * Processing Unit Controls
         */
	{
	    V4L2_CID_BRIGHTNESS,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Brightness",
	    0,
	    PU_BRIGHTNESS_CONTROL,
	    2,
	    1
	},
	{
	    V4L2_CID_CONTRAST,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Contrast",
	    1,
	    PU_CONTRAST_CONTROL,
	    2,
	    0
	},
	{
	    V4L2_CID_HUE,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Hue",
	    2,
	    PU_HUE_CONTROL,
	    2,
	    1
	},
	{
	    V4L2_CID_SATURATION,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Saturation",
	    3,
	    PU_SATURATION_CONTROL,
	    2,
	    0
	},
	{
	    V4L2_CID_SHARPNESS,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Sharpness",
	    4,
	    PU_SHARPNESS_CONTROL,
	    2,
	    0
	},
	{
	    V4L2_CID_GAMMA,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Gamma",
	    5,
	    PU_GAMMA_CONTROL,
	    2,
	    0
	},
	{
	    V4L2_CID_WHITE_BALANCE_TEMPERATURE,
	    V4L2_CTRL_TYPE_INTEGER,
	    "White Balance Temperature",
	    6,
	    PU_WHITE_BALANCE_TEMPERATURE_CONTROL,
	    2,
	    0
	},
#if 0
        /* XXX Two V4L2 ids mapping one UVC control */
	{
	    V4L2_CID_RED_BALANCE, /* V4L2_CID_BLUE_BALANCE */
	    V4L2_CTRL_TYPE_INTEGER,
	    "White Balance Red Component", /* Blue Component */
	    7,
	    PU_WHITE_BALANCE_COMPONENT_CONTROL,
	    4,
	    0
	},
#endif
        {
            V4L2_CID_BACKLIGHT_COMPENSATION,
            V4L2_CTRL_TYPE_INTEGER,
            "Backlight Compensation",
            8,
            PU_BACKLIGHT_COMPENSATION_CONTROL,
            2,
	    0
        },
	{
	    V4L2_CID_GAIN,
	    V4L2_CTRL_TYPE_INTEGER,
	    "Gain",
	    9,
	    PU_GAIN_CONTROL,
	    2,
	    0
	},
        {
            V4L2_CID_POWER_LINE_FREQUENCY,
            V4L2_CTRL_TYPE_MENU,
            "Power Line Frequency",
            10,
            PU_POWER_LINE_FREQUENCY_CONTROL,
            2,
	    0
        },
        {
            V4L2_CID_HUE_AUTO,
            V4L2_CTRL_TYPE_BOOLEAN,
            "Hue Auto",
            11,
            PU_HUE_AUTO_CONTROL,
            1,
	    0
        },
        {
            V4L2_CID_AUTO_WHITE_BALANCE,
            V4L2_CTRL_TYPE_BOOLEAN,
            "White Balance Temperature Auto",
            12,
            PU_WHITE_BALANCE_TEMPERATURE_AUTO_CONTROL,
            1,
	    0
        },
        {
            V4L2_CID_AUTO_WHITE_BALANCE,
            V4L2_CTRL_TYPE_BOOLEAN,
            "White Balance Component Auto",
            13,
            PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL,
            1,
	    0
        },
#if 0
        /* XXX No V4L2 CID for these controls? */
        {
            V4L2_CID_XXX,
            V4L2_CTRL_TYPE_INTEGER,
            "Digital Multiplier",
            14,
            PU_DIGITAL_MULTIPLIER_CONTROL,
            2,
	    0
        },
        {
            V4L2_CID_XXX,
            V4L2_CTRL_TYPE_INTEGER,
            "Digital Multiplier Limit",
            15,
            PU_DIGITAL_MULTIPLIER_LIMIT_CONTROL,
            2,
	    0
        },
        {
            V4L2_CID_XXX,
            V4L2_CTRL_TYPE_INTEGER,
            "Analog Video Standard",
            16,
            PU_ANALOG_VIDEO_STANDARD_CONTROL,
            1,
	    0
        },
        {
            V4L2_CID_XXX,
            V4L2_CTRL_TYPE_INTEGER,
            "Analog Lock Status",
            17,
            PU_ANALOG_LOCK_STATUS_CONTROL,
            1,
	    0
        },
#endif
	{ 0, 0, "", 0, 0, 0, 0 }
};
@


1.56
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Tested and okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.55 2013/04/15 09:23:02 mglocker Exp $ */
d75 1
a75 1
#define	SU_INPUT_SELECT_CONTROL 			0x01
d102 2
a103 2
#define	PU_GAIN_CONTROL 				0x04
#define	PU_POWER_LINE_FREQUENCY_CONTROL 		0x05
d111 1
a111 1
#define	PU_WHITE_BALANCE_COMPONENT_AUTO_CONTROL 	0x0d
d123 1
a123 1
#define	VS_STILL_COMMIT_CONTROL 			0x04
d273 1
a273 1
} __packed; 
a659 56
};

struct uvideo_softc {
	struct device				 sc_dev;
	struct usbd_device			*sc_udev;
	int					 sc_nifaces;
	struct usbd_interface			**sc_ifaces;

	struct device				*sc_videodev;

	int					 sc_enabled;
	int					 sc_max_fbuf_size;
	int					 sc_negotiated_flag;
	int					 sc_frame_rate;

	struct uvideo_frame_buffer		 sc_frame_buffer;

	struct uvideo_mmap			 sc_mmap[UVIDEO_MAX_BUFFERS];
	uint8_t					*sc_mmap_buffer;
	q_mmap					 sc_mmap_q;
	int					 sc_mmap_count;
	int					 sc_mmap_cur;
	int					 sc_mmap_flag;

	struct vnode				*sc_vp;
	struct usb_task				 sc_task_write;

	int					 sc_nframes;
	struct usb_video_probe_commit		 sc_desc_probe;
	struct usb_video_header_desc_all	 sc_desc_vc_header;
	struct usb_video_input_header_desc_all	 sc_desc_vs_input_header;

#define UVIDEO_MAX_PU				 8
	int					 sc_desc_vc_pu_num;
	struct usb_video_vc_processing_desc	*sc_desc_vc_pu_cur;
	struct usb_video_vc_processing_desc	*sc_desc_vc_pu[UVIDEO_MAX_PU];

#define UVIDEO_MAX_FORMAT			 8
	int					 sc_fmtgrp_idx;
	int					 sc_fmtgrp_num;
	struct uvideo_format_group		*sc_fmtgrp_cur;
	struct uvideo_format_group		 sc_fmtgrp[UVIDEO_MAX_FORMAT];

#define	UVIDEO_MAX_VS_NUM			 8
	struct uvideo_vs_iface			*sc_vs_cur;
	struct uvideo_vs_iface			 sc_vs_coll[UVIDEO_MAX_VS_NUM];

	void					*sc_uplayer_arg;
	int					*sc_uplayer_fsize;
	uint8_t					*sc_uplayer_fbuffer;
	void					 (*sc_uplayer_intr)(void *);

	struct uvideo_devs			*sc_quirk;
	usbd_status				(*sc_decode_stream_header)
						    (struct uvideo_softc *,
						    uint8_t *, int);
@


1.55
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.54 2011/04/11 02:04:48 jakemsr Exp $ */
a670 1
	int					 sc_dying;
@


1.54
log
@uncompressed video formats have a fixed per-pixel bit depth, which
means the data size of a frame can be calculated if the dimensions
are known.

* calculate frame data sizes for uncompressed formats instead of believing
what the hardware says.  the UVC spec changed between 1.0 and 1.1, and
as a result, some devices return bogus information.
* skip under-sized as well as over-sized uncompressed frames; there is
only one correct size for uncompressed frames.
* remove quirk to fix uncompressed frame sizes on certain devices,
since that now always happens.
* check that the device is actually using the parameters we think it's
using.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.53 2011/03/26 08:13:05 jakemsr Exp $ */
d418 1
a418 1
	usbd_xfer_handle	 xfer;
d425 1
a425 1
	usbd_xfer_handle	 xfer;
d432 2
a433 2
	usbd_interface_handle  	 ifaceh;
	usbd_pipe_handle	 pipeh;
d664 1
a664 1
	usbd_device_handle			 sc_udev;
d666 1
a666 1
	usbd_interface_handle			*sc_ifaces;
@


1.53
log
@support VIDIOC_S_PARM and VIDIOC_G_PARM.  these ioctls are used for
setting and and getting the frame interval.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.52 2011/03/25 21:23:54 jakemsr Exp $ */
d451 1
@


1.52
log
@* the mjpeg and uncompressed video frame descriptor structures are
  equivilent.  only define one structure, struct usb_video_frame_desc,
  and handle both types of frame descriptors in the same code.
* replace hardcoded numbers with 'sizeof(struct usb_video_frame_desc)'
  where the numbers represent the size of a frame descriptor

tested by several
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.51 2010/11/27 00:38:29 weerd Exp $ */
d360 1
a360 1
	/* TODO add continous/discrete frame intervals (Table 3-3/3-4) */
d673 1
@


1.51
log
@Increase UVIDEO_MAX_FRAME to 32 to support 28 possible frame types on
Logitech HD Pro Webcam C910 (and probably others) to make it work.

Debugging, suggested and ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.50 2010/10/09 09:48:04 jakemsr Exp $ */
d346 2
a347 2
/* Table 3-2: Motion-JPEG Video Frame Descriptor */
struct usb_video_frame_mjpeg_desc {
a381 17
/* Table 3-2: Uncompressed Video Frame Descriptor */
struct usb_video_frame_uncompressed_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFrameIndex;
	uByte	bmCapabilities;
	uWord	wWidth;
	uWord	wHeight;
	uDWord	dwMinBitRate;
	uDWord	dwMaxBitRate;
	uDWord	dwMaxVideoFrameBufferSize;
	uDWord	dwDefaultFrameInterval;
	uByte	bFrameIntervalType;
	/* TODO add continous/discrete frame intervals (Table 3-3/3-4) */
} __packed;

d467 2
a468 2
	struct usb_video_frame_mjpeg_desc	*frame_cur;
	struct usb_video_frame_mjpeg_desc	*frame[UVIDEO_MAX_FRAME];
@


1.50
log
@* define structure that represents USB descriptor with variable sized
  member the way uaudio does, make the variable sized member as large
  as it can be and don't define the following members.
* reenable control support for devices where bControlSize != 2 in
  the processing unit descriptor.

tested on alpha, amd64, i386, sparc64 and zaurus, as well as the machine
where previous support for variable bControlSize caused a hang.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.49 2010/10/09 08:41:28 jakemsr Exp $ */
d483 1
a483 1
#define UVIDEO_MAX_FRAME			 24
@


1.49
log
@control values can be 1 or 2 bytes, signed or unsigned.  fixes hue
control.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.48 2010/09/29 09:33:26 jakemsr Exp $ */
d220 3
a222 4
	uWord	bmControls;	/* XXX must be variable size of bControlSize */
	uByte	iProcessing;
	uByte	bmVideoStandards;

@


1.48
log
@back out support for variable sized processing unit controls until
I can figure out why it causes boot hangs with some Sonix camera
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.47 2010/09/26 23:44:51 jakemsr Exp $ */
d503 1
d514 2
a515 1
	    2
d523 2
a524 1
	    2
d532 2
a533 1
	    2
d541 2
a542 1
	    2
d550 2
a551 1
	    2
d559 2
a560 1
	    2
d568 2
a569 1
	    2
d579 2
a580 1
	    4
d590 1
d599 1
d607 2
a608 1
            1,
d617 1
d626 1
d635 1
d646 1
d655 1
d664 1
d673 1
d676 1
a676 1
	{ 0, 0, "", 0, 0, 0 }
@


1.47
log
@support variable sized (bControlSize != 2) processing unit bmControls,
and add support for more processing unit controls.
from Martin Pieuchot, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.46 2010/04/27 11:58:14 marco Exp $ */
d220 1
a220 1
	uByte	bmControls[255]; /* [bControlSize] */
@


1.46
log
@Add a couple more frames in order to support the latest logitech pro 9000
webcam.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.45 2009/02/19 21:17:35 deraadt Exp $ */
d220 1
a220 1
	uWord	bmControls;	/* XXX must be variable size of bControlSize */
d223 1
d500 1
a500 1
	uint16_t	ctrl_bitmap;
d504 3
a506 1
	/* TODO complete control list */
d511 1
a511 1
	    (1 << 0),
d519 1
a519 1
	    (1 << 1),
d527 1
a527 1
	    (1 << 2),
d535 1
a535 1
	    (1 << 3),
d540 8
d551 1
a551 1
	    (1 << 5),
d556 27
d586 1
a586 1
	    (1 << 9),
d590 67
@


1.45
log
@the uaa structure (and things it points, for instance ifaces) is only
alive during match and attach.  do not attempt to reuse this pointer or
ifaces during a deferred attach routine, since it will contain junk,
but instead make copies.
tested on all 3 kinds of uvideo's (ricoh fw load, apple fw load, and the rest)
ok robert mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.44 2009/02/12 14:48:00 mglocker Exp $ */
d483 1
a483 1
#define UVIDEO_MAX_FRAME			 16
@


1.44
log
@Fix typo; wClockFrequency -> dwClockFrequency.

From Kenji Aoyama
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.43 2008/12/22 09:34:46 mglocker Exp $ */
a556 1
	struct usb_attach_arg			*sc_uaa;
d558 2
@


1.43
log
@Add firmware load for Apple iSight first generation devices
(0x05ac:8300 before firmware load, 0x05ac:0x8501 after firmware load).

Also those devices have a own stream header procotol for which we've
added a seperate stream header decode function, which does not work yet.

A jointventure work with robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.42 2008/12/17 18:14:46 mglocker Exp $ */
d288 1
a288 1
	uDWord	wClockFrequency;
@


1.42
log
@- Extend our quirk device table by a flags field.
- Add Apple iSight first revision device to the quirk table for future code.
- Fix some logic in the device matching function.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.41 2008/12/08 22:02:39 deraadt Exp $ */
d557 1
d605 3
@


1.41
log
@do device classification for non-UVC and firmware-needing devices together
in the same device table, and abstract usb control out of the ricoh firmware
loader so that it can be reused by other loaders
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.40 2008/12/08 18:33:24 mglocker Exp $ */
d603 1
a603 1
	struct uvideo_devs			*sc_ucode;
@


1.40
log
@Add ability to load firmware for devices which require it.

Tested by deraadt@@ and myself.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.39 2008/12/05 10:44:52 mglocker Exp $ */
a560 2
#define UVIDEO_FLAGS_NEED_UCODE			 0x1
	int					 sc_flags;
d603 1
a603 1
	struct uvideo_ucode			*sc_ucode;
@


1.39
log
@Sort uvideo_vs_iface struct a bit.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.38 2008/12/03 03:47:25 yuo Exp $ */
d561 2
d604 2
@


1.38
log
@add UYVY video format support for uncompressed video

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.37 2008/12/03 03:44:25 yuo Exp $ */
a449 1
	int			 endpoint;
d451 1
d454 1
a455 1
	int			 iface;
@


1.37
log
@remove bogus part (GUID_UYVY part) form last commit.

(this diff will be include next diff.)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.36 2008/12/03 03:28:25 yuo Exp $ */
d305 4
@


1.36
log
@fix USB packet size handling of uvideo(4)
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.35 2008/11/30 15:20:33 mglocker Exp $ */
a306 3
#define	UVIDEO_FORMAT_GUID_UYVY	{			\
    0x55, 0x59, 0x56, 0x59, 0x00, 0x00, 0x10, 0x00,	\
    0x80, 0x00, 0x00, 0xaa, 0x00, 0x38,	0x9b, 0x71 }
@


1.35
log
@Setup three isoc transfers at a time so we don't miss frames.  This fixes
transfers which require larger bandwidths, e.g. for higher resolutions.

discussed with yuo@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.34 2008/11/10 13:15:51 mglocker Exp $ */
d307 3
d431 1
a431 1
#define UVIDEO_NFRAMES_MAX	640
d453 1
a453 1
	uint32_t		 max_packet_size;
@


1.34
log
@Remove 17 unused vars from uvideo_softc.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.33 2008/11/09 21:24:55 mglocker Exp $ */
d428 9
a436 2
#define UVIDEO_NFRAMES_MAX	40
struct uvideo_vs_iface {
d440 5
a447 1
	uint16_t		 size[UVIDEO_NFRAMES_MAX];
d454 2
@


1.33
log
@Make own struct for the stream header instead saving the data in single
variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.32 2008/11/09 20:14:06 mglocker Exp $ */
a540 10
	usbd_interface_handle			 sc_iface;
	int					 sc_iface_number;
	int					 sc_product;
	int					 sc_vendor;

	int					 sc_intr_number;
	usbd_pipe_handle			 sc_intr_pipe;
	u_char					*sc_ibuf;
	int					 sc_isize;
	int					 sc_vc_iface;
a543 4
	struct vs_info				*sc_alts;
	int					 sc_nalts;
	int					 sc_nullalt;
	int					 sc_video_rev;
a545 1
	int					 sc_mode;
a547 4

	u_int16_t				 uvc_version;
	u_int32_t				 clock_frequency;
	u_int32_t				 quirks;
@


1.32
log
@Add BULK xfer support.

Thanks to Carlos Valiente for donating an EeePC 701 where this has been
developed and tested.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.31 2008/08/27 17:31:48 mglocker Exp $ */
d311 15
a325 8
#define	UVIDEO_STREAM_FID	(1 << 0)
#define	UVIDEO_STREAM_EOF	(1 << 1)
#define	UVIDEO_STREAM_PTS	(1 << 2)
#define	UVIDEO_STREAM_SCR	(1 << 3)
#define	UVIDEO_STREAM_RES	(1 << 4)
#define	UVIDEO_STREAM_STI	(1 << 5)
#define	UVIDEO_STREAM_ERR	(1 << 6)
#define	UVIDEO_STREAM_EOH	(1 << 7)
@


1.31
log
@Some __packed cleanup;  Remove another obsolete pack from a none-hardware
struct and pack all other hardware structs which have been forgotten.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.30 2008/08/26 21:52:48 mglocker Exp $ */
d434 2
@


1.30
log
@Fix alignment panic on sparc64 by removing a wrong __packed.  While
there reorder fields in the struct to make it shorter on 64 bit archs.

panic reported by jasper@@
thanks to miod@@ for helping me debug this down
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.29 2008/08/24 11:43:00 mglocker Exp $ */
d165 1
a165 1
};
d181 1
a181 1
};
d193 1
a193 1
};
d209 1
a209 1
};
d242 1
a242 1
};
d258 1
a258 1
};
d391 30
a421 1

a451 30
struct uvideo_format_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uByte	bFormatIndex;
	uByte	bNumFrameDescriptors;
	union {
		/* mjpeg */
		struct {
			uByte	bmFlags;
			uByte	bDefaultFrameIndex;
			uByte	bAspectRatioX;
			uByte	bAspectRatioY;
			uByte	bmInterlaceFlags;
			uByte	bCopyProtect;
		} mjpeg;

		/* uncompressed */
		struct {
			uByte	guidFormat[16];
			uByte	bBitsPerPixel;
			uByte	bDefaultFrameIndex;
			uByte	bAspectRatioX;
			uByte	bAspectRatioY;
			uByte	bmInterlaceFlags;
			uByte	bCopyProtect;
		} uc;
	} u;
} __packed;

d467 1
a467 1
} __packed;
@


1.29
log
@Use consistent variable names;  curr -> cur, err -> error.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.28 2008/08/24 11:05:03 mglocker Exp $ */
d455 1
a456 1
	uint8_t					 format_dfidx;
a458 1
	int					 frame_num;
d461 2
a462 1
} __packed;
@


1.28
log
@Add support for processing unit (e.g. brightness) controls.  New V4L2
ioctls therefore are VIDIOC_QUERYCTRL, VIDIOC_G_CTRL, and VIDIOC_S_CTRL.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.27 2008/08/02 21:52:37 mglocker Exp $ */
d589 1
a589 1
	struct uvideo_vs_iface			*sc_vs_curr;
@


1.27
log
@Use correct terms as in the specs;
"fragment" gets replaced by "sample".
"sample" gets replaced by "frame".
A sample is a peace of a frame (final image).  No functional changes.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.26 2008/07/31 15:26:25 mglocker Exp $ */
d211 14
d470 60
d576 5
@


1.26
log
@- Don't relay on bFormatIndex as an internal array index, since this
field is unreliable and can start with any number.  Use an own internal
array index instead.

- If the read buffer is too small, return a propper error to the calling
functions.  Just check the buffer size if we use the read(2) method since
it doesn't affect mmap(2).

Fixes kernel crashes seen with the M$ LifeCam NX-6000 and internal
(laptop) Sonix chipsets.

Tested by jcs@@ (Sonix) and myself (NX-6000).

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.25 2008/07/26 11:42:43 mglocker Exp $ */
d393 2
a394 2
struct uvideo_sample_buffer {
	int		 fragment;
d486 1
a486 1
	struct uvideo_sample_buffer		 sc_sample_buffer;
@


1.25
log
@Since we are able to change the device image resolution on the fly in the
meantime, the memory allocation for the read(2) method for video(4)
is not right anymore, and can cause a buffer overflow.

We fix this by queuering the maximum available image size for a device at
attach time.  If the image size should exceed our video(4) buffer after a
video format change (which shouldn't happen), uvideo(4) will gracefully
fail.

Also tested by kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.24 2008/07/24 14:59:44 mglocker Exp $ */
d504 1
@


1.24
log
@Remove some obsolete XXX comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.23 2008/07/19 11:30:55 mglocker Exp $ */
d479 1
a479 1
	int					 sc_video_buf_size;
@


1.23
log
@If a resolution which has been requested over VIDEO_TRY_FMT or
VIDEO_S_FMT doesn't exactly match the devices available resolutions,
return the next best matching resolution which we have.

Makes some V4L2 apps happy when running them with the default resolution
(no options).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.22 2008/07/18 18:49:11 mglocker Exp $ */
d163 1
a163 1
	uDWord	dwClockFrequency; /* XXX deprecated */
d208 1
a208 1
	uByte	*bmControls; /* XXX */	
@


1.22
log
@Implement VIDIOC_S_FMT and VIDIOC_TRY_FMT.  Now V4L2 applications can
set their desired image size, and therefore users can manipulate the
image size, too via the application.

Also tested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.21 2008/07/14 04:45:50 mglocker Exp $ */
d448 6
@


1.21
log
@Finish support for uncompressed payloads (UDESCSUB_VS_FORMAT_UNCOMPRESSED).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.20 2008/07/13 11:49:31 mglocker Exp $ */
d440 1
d445 1
d474 1
d498 1
@


1.20
log
@Save format and frame descriptors to a format group structure so we
can use them later for stuff like VIDIOC_S_FMT (e.g. set custom
resolution).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.19 2008/07/12 06:26:06 mglocker Exp $ */
d409 30
d440 4
a443 2
	/* XXX format descriptor should be union */
	struct usb_video_format_mjpeg_desc	*format;
a444 1
#define UVIDEO_MAX_FRAME			 16
@


1.19
log
@Remove obsolete TODO comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.18 2008/07/03 09:50:04 mglocker Exp $ */
d409 8
d462 4
a465 2
	struct usb_video_format_mjpeg_desc	*sc_desc_format_mjpeg;
	struct usb_video_frame_mjpeg_desc	*sc_desc_frame_mjpeg;
@


1.18
log
@Add struct for VC_EXTENSION_UNIT and dump it in debug mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.17 2008/07/02 21:28:50 mglocker Exp $ */
a403 5
	/*
	 * TODO
	 * Complete buffer so we can queue/dequeue video frames.
	 * Maybe we should use some queue macros for this?
	 */
@


1.17
log
@Add first bits to support uncompressed format.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.16 2008/06/30 17:04:18 mglocker Exp $ */
d210 11
@


1.16
log
@Limit maximal number of mmap buffers to 32 (instead 256).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.15 2008/06/26 21:00:27 mglocker Exp $ */
d312 36
@


1.15
log
@Make video stream work properly on uhci and ohci by adding an ohci
isoc xfer workaround.

Improved and OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.14 2008/06/09 20:51:31 mglocker Exp $ */
d354 1
a354 1
#define UVIDEO_MAX_BUFFERS	256
@


1.14
log
@Let the driver switch between read() and mmap() depending on what
the userland application wants.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.13 2008/06/09 19:57:45 robert Exp $ */
d330 1
a330 2
#define UVIDEO_NFRAMES_MAX	34	/* XXX find optimal value */
#define UVIDEO_SFRAMES_MAX	6400	/* XXX find optimal value */
@


1.13
log
@oops. this change was missing from the previous commit
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.12 2008/06/07 22:14:58 mglocker Exp $ */
d404 1
@


1.12
log
@Start to queue mmap frames.  Add VIDIOC_QBUF, VIDIOC_DQBUF,
VIDIOC_STREAMON for that purpose, too.

OK robert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.11 2008/06/06 19:14:45 mglocker Exp $ */
d391 1
@


1.11
log
@Arrange our mmap buffer struct better.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.10 2008/06/05 20:50:28 mglocker Exp $ */
d20 1
d357 1
d363 2
a364 3
	uint8_t			*buf;

	struct v4l2_buffer	 v4l2_buf;
d366 1
d397 1
d400 3
@


1.10
log
@Add some first mmap bits.

Help by miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.9 2008/05/27 17:47:28 mglocker Exp $ */
d355 1
a355 1
struct uvideo_mmap_buffer {
d363 1
a363 1
	struct v4l2_buffer	 v4l2_buf[UVIDEO_MAX_BUFFERS];
d395 2
a396 1
	struct uvideo_mmap_buffer		 sc_mmap_buffer;
@


1.9
log
@Instead alloacting a fix frame buffer we allocate the maximum frame size
delivered by the device (dwMaxVideoFrameSize).  Also check for too large
frames (buffer overflow),  they get skipped.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.8 2008/05/24 19:37:34 mglocker Exp $ */
d354 12
d395 1
@


1.8
log
@- Enable userland to read(2) video stream from /dev/video.
- Prepare for mmap(2).
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.7 2008/04/20 09:14:05 mglocker Exp $ */
d350 1
@


1.7
log
@Parse VS_INPUT_HEADER descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.6 2008/04/18 21:19:15 mglocker Exp $ */
d396 5
@


1.6
log
@Add VS_INPUT_HEADER descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.5 2008/04/16 20:45:24 mglocker Exp $ */
d234 5
d389 1
@


1.5
log
@Tune isoc maximal transfer size to a better value.  Makes all available
resolutions on my cam work.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.4 2008/04/16 12:19:11 mglocker Exp $ */
d216 16
@


1.4
log
@Start to make device initialization automatic instead all the static
games.

Tested by robert@@ and myself
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.3 2008/04/10 09:22:15 mglocker Exp $ */
d308 2
a309 4
//#define UVIDEO_NFRAMES		10	/* XXX calculate right value */
//#define UVIDEO_NFRAMES		4	/* XXX calculate right value */
#define UVIDEO_NFRAMES_MAX	10	/* XXX find optimal value */
#define UVIDEO_SFRAMES_MAX	3200	/* XXX find optimal value */
@


1.3
log
@Fix MJPEG Video Frame Descriptor struct.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvideo.h,v 1.2 2008/04/09 20:38:55 mglocker Exp $ */
d156 1
a156 1
struct usb_video_header_descriptor {
d166 3
a168 14
struct usb_video_control {
	struct usb_video_header_descriptor	*descr;
	uByte					*baInterfaceNr;
};

struct usb_video_header_desc {
	uByte	bLength;
	uByte	bDescriptorType;
	uByte	bDescriptorSubtype;
	uWord	bcdUVC;
	uWord	wTotalLength;
	uDWord	dwClockFrequency; /* XXX deprecated */
	uByte	bInCollection;
	uByte	baInterfaceNr;
d230 1
a230 1
	uByte	bmHint[2];
d233 9
a241 9
	uByte	dwFrameInterval[4];
	uByte	wKeyFrameRate[2];
	uByte	wPFrameRate[2];
	uByte	wCompQuality[2];
	uByte	wCompWindowSize[2];
	uByte	wDelay[2];
	uByte	dwMaxVideoFrameSize[4];
	uByte	dwMaxPayloadTransferSize[4];
	uByte	wClockFrequency[4];
d274 1
a274 1
struct usb_video_format_mjpeg_descriptor {
d289 1
a289 1
struct usb_video_frame_descriptor {
d308 4
a311 1
#define UVIDEO_NFRAMES		10 /* XXX calculate right value */
d313 1
a313 1
struct uvideo_stream_if {
d317 4
a320 1
	int			 busy;
d322 3
a324 14
	usbd_interface_handle  	 in_ifaceh;
	usbd_pipe_handle	 in_pipeh;
	int			 endpoint;
	u_int16_t		 size[UVIDEO_NFRAMES];

	u_int8_t		 fmtgrp_cnt;

	usbd_interface_handle	 ifaceh;
	usbd_interface_handle	*if_descr;
	int			 curr_alt;
	u_int32_t		 max_isoc_payload;

	char			 start_polling;
	char			 fid;
d367 9
a375 2
	struct usb_video_control		*sc_vc_header;
	struct uvideo_stream_if			 sc_curr_strm;
@


1.2
log
@Add OpenBSD cvs id.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d311 1
a311 1
	uWord	dwDefaultFrameInterval;
d313 1
@


1.1
log
@Initial import for uvideo(4) and video(4):

uvideo(4) is a driver for USB video device class devices including webcams,
camcorders and other cameras.

video(4) is a device-independent layer that implements the V4L2 (Video for Linux Two)
API.

These drivers are *really* work in progress so don't even try to use them just yet,
because the driver still has some issues, even if it can be used to capture simple
MJPEG videos.

ok mglocker@@, deraadt@@
@
text
@d1 2
@

