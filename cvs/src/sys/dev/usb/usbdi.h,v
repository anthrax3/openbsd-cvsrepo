head	1.69;
access;
symbols
	OPENBSD_6_2_BASE:1.69
	OPENBSD_6_1:1.67.0.6
	OPENBSD_6_1_BASE:1.67
	OPENBSD_6_0:1.67.0.4
	OPENBSD_6_0_BASE:1.67
	OPENBSD_5_9:1.66.0.2
	OPENBSD_5_9_BASE:1.66
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.65.0.2
	OPENBSD_5_7_BASE:1.65
	OPENBSD_5_6:1.62.0.4
	OPENBSD_5_6_BASE:1.62
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.53.0.2
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.42.0.10
	OPENBSD_5_3_BASE:1.42
	OPENBSD_5_2:1.42.0.8
	OPENBSD_5_2_BASE:1.42
	OPENBSD_5_1_BASE:1.42
	OPENBSD_5_1:1.42.0.6
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.33.0.4
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.33.0.2
	OPENBSD_4_7_BASE:1.33
	OPENBSD_4_6:1.30.0.8
	OPENBSD_4_6_BASE:1.30
	OPENBSD_4_5:1.30.0.4
	OPENBSD_4_5_BASE:1.30
	OPENBSD_4_4:1.30.0.2
	OPENBSD_4_4_BASE:1.30
	OPENBSD_4_3:1.29.0.4
	OPENBSD_4_3_BASE:1.29
	OPENBSD_4_2:1.29.0.2
	OPENBSD_4_2_BASE:1.29
	OPENBSD_4_1:1.25.0.4
	OPENBSD_4_1_BASE:1.25
	OPENBSD_4_0:1.25.0.6
	OPENBSD_4_0_BASE:1.25
	OPENBSD_3_9:1.25.0.2
	OPENBSD_3_9_BASE:1.25
	OPENBSD_3_8:1.24.0.2
	OPENBSD_3_8_BASE:1.24
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.21.0.8
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.21
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.20
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.14.0.2
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.18
	UBC:1.13.0.2
	UBC_BASE:1.13
	OPENBSD_3_0:1.12.0.2
	OPENBSD_3_0_BASE:1.12
	OPENBSD_2_9_BASE:1.11
	OPENBSD_2_9:1.11.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.69
date	2017.05.15.11.05.51;	author mpi;	state Exp;
branches;
next	1.68;
commitid	wkvm66TLWRsALwKH;

1.68
date	2017.05.15.10.52.08;	author mpi;	state Exp;
branches;
next	1.67;
commitid	cyblrmsSmLeFugC0;

1.67
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.66;
commitid	KhGZngmPmcr1rX2x;

1.66
date	2015.07.10.15.47.48;	author mpi;	state Exp;
branches;
next	1.65;
commitid	BjEcbAHow6xga6pa;

1.65
date	2015.01.22.10.27.47;	author mpi;	state Exp;
branches;
next	1.64;
commitid	lKfM5ejoPYfCitV4;

1.64
date	2015.01.09.12.07.50;	author mpi;	state Exp;
branches;
next	1.63;
commitid	SbnTte7ZSgPxxJ3B;

1.63
date	2014.08.10.11.18.57;	author mpi;	state Exp;
branches;
next	1.62;
commitid	soKLg6qedOsGZg3L;

1.62
date	2014.03.07.09.38.14;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2014.03.06.23.51.04;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.11.19.14.04.07;	author pirofti;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2013.11.13.13.48.08;	author pirofti;	state Exp;
branches;
next	1.57;

1.57
date	2013.11.06.15.55.15;	author jeremy;	state Exp;
branches;
next	1.56;

1.56
date	2013.11.02.01.41.17;	author jeremy;	state Exp;
branches;
next	1.55;

1.55
date	2013.10.31.10.12.19;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2013.09.20.15.34.51;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.04.26.14.19.25;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2013.04.26.14.11.18;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.04.26.13.46.40;	author mglocker;	state Exp;
branches;
next	1.50;

1.50
date	2013.04.19.08.54.50;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.18.08.44.39;	author mglocker;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.10.07.39.43;	author mpi;	state Exp;
branches;
next	1.45;

1.45
date	2013.04.09.08.47.56;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2013.04.08.10.34.20;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2013.04.01.19.49.53;	author mglocker;	state Exp;
branches;
next	1.42;

1.42
date	2011.02.09.20.24.39;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2011.02.09.04.25.32;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2011.02.04.08.21.39;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.38;

1.38
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2010.12.30.05.10.35;	author jakemsr;	state Exp;
branches;
next	1.36;

1.36
date	2010.12.06.04.25.27;	author jakemsr;	state Exp;
branches;
next	1.35;

1.35
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.34;

1.34
date	2010.09.23.06.30.37;	author jakemsr;	state Exp;
branches;
next	1.33;

1.33
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.23.19.59.08;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.08.30.19.15.40;	author miod;	state Exp;
branches;
next	1.30;

1.30
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.18.11.37.04;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.05.29.01.43.44;	author claudio;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.20.08.03.59;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2004.12.12.06.13.15;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2004.11.08.22.01.02;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.17.05.33.45;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.01.21.47.07;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.31.04.24.45;	author nate;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.28.09.43.43;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.04.11.44.25;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.52;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.20;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.05;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.26;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.44.03;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.13.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.69
log
@Use splraise() rather than splsoftnet() which is going away.
@
text
@/*	$OpenBSD: usbdi.h,v 1.68 2017/05/15 10:52:08 mpi Exp $ */
/*	$NetBSD: usbdi.h,v 1.62 2002/07/11 21:14:35 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi.h,v 1.18 1999/11/17 22:33:49 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _USBDI_H_
#define _USBDI_H_

struct usbd_bus;
struct usbd_device;
struct usbd_interface;
struct usbd_pipe;
struct usbd_xfer;

typedef enum {
	USBD_NORMAL_COMPLETION = 0, /* must be 0 */
	USBD_IN_PROGRESS,	/* 1 */
	/* errors */
	USBD_PENDING_REQUESTS,	/* 2 */
	USBD_NOT_STARTED,	/* 3 */
	USBD_INVAL,		/* 4 */
	USBD_NOMEM,		/* 5 */
	USBD_CANCELLED,		/* 6 */
	USBD_BAD_ADDRESS,	/* 7 */
	USBD_IN_USE,		/* 8 */
	USBD_NO_ADDR,		/* 9 */
	USBD_SET_ADDR_FAILED,	/* 10 */
	USBD_NO_POWER,		/* 11 */
	USBD_TOO_DEEP,		/* 12 */
	USBD_IOERROR,		/* 13 */
	USBD_NOT_CONFIGURED,	/* 14 */
	USBD_TIMEOUT,		/* 15 */
	USBD_SHORT_XFER,	/* 16 */
	USBD_STALLED,		/* 17 */
	USBD_INTERRUPTED,	/* 18 */

	USBD_ERROR_MAX		/* must be last */
} usbd_status;

typedef void (*usbd_callback)(struct usbd_xfer *, void *, usbd_status);

/* Open flags */
#define USBD_EXCLUSIVE_USE	0x01

/* Use default (specified by ep. desc.) interval on interrupt pipe */
#define USBD_DEFAULT_INTERVAL	(-1)

/* Request flags */
#define USBD_NO_COPY		0x01	/* do not copy data to DMA buffer */
#define USBD_SYNCHRONOUS	0x02	/* wait for completion */
/* in usb.h #define USBD_SHORT_XFER_OK	0x04*/	/* allow short reads */
#define USBD_FORCE_SHORT_XFER	0x08	/* force last short packet on write */
#define USBD_CATCH		0x10	/* catch signals while sleeping */

#define USBD_NO_TIMEOUT 0
#define USBD_DEFAULT_TIMEOUT 5000 /* ms = 5 s */

#define DEVINFOSIZE 1024

usbd_status usbd_open_pipe(struct usbd_interface *iface, u_int8_t address,
    u_int8_t flags, struct usbd_pipe **pipe);
usbd_status usbd_close_pipe(struct usbd_pipe *pipe);
usbd_status usbd_transfer(struct usbd_xfer *req);
struct usbd_xfer *usbd_alloc_xfer(struct usbd_device *);
void usbd_free_xfer(struct usbd_xfer *xfer);
void usbd_setup_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    void *priv, void *buffer, u_int32_t length, u_int16_t flags,
    u_int32_t timeout, usbd_callback);
void usbd_setup_default_xfer(struct usbd_xfer *xfer, struct usbd_device *dev,
    void *priv, u_int32_t timeout, usb_device_request_t *req,
    void *buffer, u_int32_t length, u_int16_t flags, usbd_callback);
void usbd_setup_isoc_xfer(struct usbd_xfer *xfer, struct usbd_pipe *pipe,
    void *priv, u_int16_t *frlengths, u_int32_t nframes,
    u_int16_t flags, usbd_callback);
void usbd_get_xfer_status(struct usbd_xfer *xfer, void **priv,
    void **buffer, u_int32_t *count, usbd_status *status);
usb_endpoint_descriptor_t *usbd_interface2endpoint_descriptor(
    struct usbd_interface *iface, u_int8_t address);
void usbd_abort_pipe(struct usbd_pipe *pipe);
usbd_status usbd_clear_endpoint_stall(struct usbd_pipe *pipe);
usbd_status usbd_clear_endpoint_stall_async(struct usbd_pipe *pipe);
void usbd_clear_endpoint_toggle(struct usbd_pipe *pipe);
usbd_status usbd_device2interface_handle(struct usbd_device *dev,
    u_int8_t ifaceno, struct usbd_interface **iface);

void *usbd_alloc_buffer(struct usbd_xfer *xfer, u_int32_t size);
void usbd_free_buffer(struct usbd_xfer *xfer);
usbd_status usbd_open_pipe_intr(struct usbd_interface *iface, u_int8_t address,
    u_int8_t flags, struct usbd_pipe **pipe, void *priv,
    void *buffer, u_int32_t length, usbd_callback, int);
usbd_status usbd_do_request(struct usbd_device *pipe, usb_device_request_t *req,
    void *data);
usbd_status usbd_request_async(struct usbd_xfer *xfer,
    usb_device_request_t *req, void *priv, usbd_callback callback);
usbd_status usbd_do_request_flags(struct usbd_device *pipe,
    usb_device_request_t *req, void *data, u_int16_t flags, int*, u_int32_t);
usb_interface_descriptor_t *usbd_get_interface_descriptor(
    struct usbd_interface *iface);
usb_config_descriptor_t *usbd_get_config_descriptor(struct usbd_device *dev);
usb_device_descriptor_t *usbd_get_device_descriptor(struct usbd_device *dev);
usbd_status usbd_set_interface(struct usbd_interface *, int);
int usbd_get_no_alts(usb_config_descriptor_t *, int);
void usbd_fill_deviceinfo(struct usbd_device *, struct usb_device_info *, int);
usb_config_descriptor_t *usbd_get_cdesc(struct usbd_device *, int, u_int *);
int usbd_get_interface_altindex(struct usbd_interface *iface);

usb_interface_descriptor_t *usbd_find_idesc(usb_config_descriptor_t *cd,
    int iindex, int ano);
usb_endpoint_descriptor_t *usbd_find_edesc(usb_config_descriptor_t *cd,
    int ifaceidx, int altidx, int endptidx);

void usbd_dopoll(struct usbd_device *);
void usbd_set_polling(struct usbd_device *iface, int on);

const char *usbd_errstr(usbd_status err);

const struct usbd_quirks *usbd_get_quirks(struct usbd_device *);
usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor(
    struct usbd_interface *iface, u_int8_t address);

usbd_status usbd_reload_device_desc(struct usbd_device *);

int usbd_ratecheck(struct timeval *last);

int usbd_get_devcnt(struct usbd_device *);
void usbd_claim_iface(struct usbd_device *, int);
int usbd_iface_claimed(struct usbd_device *, int);

int usbd_is_dying(struct usbd_device *);
void usbd_deactivate(struct usbd_device *);

void usbd_ref_incr(struct usbd_device *);
void usbd_ref_decr(struct usbd_device *);
void usbd_ref_wait(struct usbd_device *);

/* An iterator for descriptors. */
struct usbd_desc_iter {
	const uByte *cur;
	const uByte *end;
};
void usbd_desc_iter_init(struct usbd_device *, struct usbd_desc_iter *);
const usb_descriptor_t *usbd_desc_iter_next(struct usbd_desc_iter *);

int usbd_str(usb_string_descriptor_t *, int, const char *);

/*
 * The usb_task structs form a queue of things to run in the USB task
 * threads.  Normally this is just device discovery when a connect/disconnect
 * has been detected.  But it may also be used by drivers that need to
 * perform (short) tasks that must have a process context.
 */
struct usb_task {
	TAILQ_ENTRY(usb_task) next;
	struct usbd_device *dev;
	void (*fun)(void *);
	void *arg;
	char type;
#define	USB_TASK_TYPE_GENERIC	0
#define USB_TASK_TYPE_EXPLORE	1
#define USB_TASK_TYPE_ABORT	2
	u_int state;
#define	USB_TASK_STATE_NONE	0x0
#define	USB_TASK_STATE_ONQ	0x1
#define	USB_TASK_STATE_RUN	0x2

};

void usb_add_task(struct usbd_device *, struct usb_task *);
void usb_rem_task(struct usbd_device *, struct usb_task *);
void usb_wait_task(struct usbd_device *, struct usb_task *);
void usb_rem_wait_task(struct usbd_device *, struct usb_task *);
#define usb_init_task(t, f, a, y) \
	((t)->fun = (f),	\
	(t)->arg = (a),		\
	(t)->type = (y),	\
	(t)->state = USB_TASK_STATE_NONE)

struct usb_devno {
	u_int16_t ud_vendor;
	u_int16_t ud_product;
};
const struct usb_devno *usbd_match_device(const struct usb_devno *tbl,
    u_int nentries, u_int sz, u_int16_t vendor, u_int16_t product);
#define usb_lookup(tbl, vendor, product) \
	usbd_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
#define	USB_PRODUCT_ANY		0xffff

/* Attach data */
struct usb_attach_arg {
	int			port;
	int			configno;
	int			ifaceno;
	int			vendor;
	int			product;
	int			release;
	struct usbd_device	*device;	/* current device */
	struct usbd_interface	*iface; /* current interface */
	int			usegeneric;
	struct usbd_interface	**ifaces;/* all interfaces */
	int			nifaces; /* number of interfaces */
};

/* Match codes. */
/* First five codes is for a whole device. */
#define UMATCH_VENDOR_PRODUCT_REV			14
#define UMATCH_VENDOR_PRODUCT				13
#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			12
#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		11
#define UMATCH_DEVCLASS_DEVSUBCLASS			10
/* Next six codes are for interfaces. */
#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		 9
#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		 8
#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		 7
#define UMATCH_VENDOR_IFACESUBCLASS			 6
#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	 5
#define UMATCH_IFACECLASS_IFACESUBCLASS			 4
#define UMATCH_IFACECLASS				 3
#define UMATCH_IFACECLASS_GENERIC			 2
/* Generic driver */
#define UMATCH_GENERIC					 1
/* No match */
#define UMATCH_NONE					 0

#define	IPL_USB		IPL_BIO
#define	IPL_SOFTUSB	IPL_SOFTNET

#define splusb()	splraise(IPL_SOFTUSB)
#define splhardusb()	splraise(IPL_USB)


#endif /* _USBDI_H_ */
@


1.68
log
@Replace remaining SPLUSBCHECK by a splsoftassert(IPL_SOFTUSB).

USB is the last real user of IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.67 2016/03/03 18:13:24 stefan Exp $ */
a252 3
#define splusb splsoftnet
#define splhardusb splbio

d255 4
@


1.67
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.66 2015/07/10 15:47:48 mpi Exp $ */
a252 1
/* XXX Perhaps USB should have its own levels? */
a253 5
#if 0
#define	SPLUSBCHECK	splsoftassert(IPL_SOFTUSB)
#else
#define	SPLUSBCHECK	do { /* nothing */ } while (0)
#endif
@


1.66
log
@usbd_{endpoint,interface}_count() are no longer used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.65 2015/01/22 10:27:47 mpi Exp $ */
d133 1
a133 1
usb_config_descriptor_t *usbd_get_cdesc(struct usbd_device *, int, int *);
@


1.65
log
@Reduce the number of intermediate buffers by pre-allocating DMA buffers
in the report functions instead of letting the stack do it magically for
us.

Reviewed and tested by David Higgs, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.64 2015/01/09 12:07:50 mpi Exp $ */
a111 2
int usbd_endpoint_count(struct usbd_interface *dev, u_int8_t *count);
int usbd_interface_count(struct usbd_device *dev, u_int8_t *count);
@


1.64
log
@Add an asynchronous version of uhidev_get_report(), from David Higgs
with some tweaks.

Nothing use it for the moment, but upcoming upd(4) improvements need
it.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.63 2014/08/10 11:18:57 mpi Exp $ */
d124 2
a125 2
usbd_status usbd_do_request_async(struct usbd_device *pipe,
    usb_device_request_t *req, void *data, void *priv, usbd_callback callback);
@


1.63
log
@Since USB xfer pools are accessed in interrupt context, initialize them
with the correct ipl to prevent your CPU from locking against itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.62 2014/03/07 09:38:14 mpi Exp $ */
d125 1
a125 1
    usb_device_request_t *req, void *data);
@


1.62
log
@We already have three identical copies of the *hci_str() function,
so merge them into usbd_str() to not introduce other copies with
the upcoming HC drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.61 2014/03/06 23:51:04 mpi Exp $ */
d258 1
a258 1
#define	SPLUSBCHECK	splsoftassert(IPL_SOFTNET)
d263 3
a265 1
#define IPL_USB IPL_BIO
@


1.61
log
@Add include guards.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.60 2013/11/19 14:04:07 pirofti Exp $ */
d174 2
@


1.60
log
@Kill matchlvl usage throughout the usb stack.

Allows us to move forward on cleaning.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.59 2013/11/15 10:17:39 pirofti Exp $ */
d35 3
d262 2
@


1.59
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.58 2013/11/13 13:48:08 pirofti Exp $ */
a221 1
	int			matchlvl;
@


1.58
log
@Polling is done per controller not per interface.

The controllers are linked through device->bus so the iface is redundant.

So fixing usbd_dopoll() to take the device as argument and making
usbd_interface2device_handle() private (for now) inside usbdi_util.

Tested and okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.57 2013/11/06 15:55:15 jeremy Exp $ */
d105 1
a105 1
usbd_status usbd_abort_pipe(struct usbd_pipe *pipe);
@


1.57
log
@Make usbd_free_xfer return void, since no callers use the return value.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.56 2013/11/02 01:41:17 jeremy Exp $ */
a110 2
void usbd_interface2device_handle(struct usbd_interface *iface,
    struct usbd_device **dev);
d140 1
a140 1
void usbd_dopoll(struct usbd_interface *);
@


1.56
log
@Begin conversion of USB stack to return int instead of usbd_status,
starting with usbd_endpoint_count and usbd_interface_count.  usbd_status
should only be used to indicate the status of a USB transfer, it should
not be used for generic error codes.

Idea from and much hand-holding by mpi@@

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.55 2013/10/31 10:12:19 mpi Exp $ */
d91 1
a91 1
usbd_status usbd_free_xfer(struct usbd_xfer *xfer);
@


1.55
log
@usbd_pipe2device_handle() is not used, should not be used and die.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.54 2013/09/20 15:34:51 mpi Exp $ */
d109 2
a110 2
usbd_status usbd_endpoint_count(struct usbd_interface *dev, u_int8_t *count);
usbd_status usbd_interface_count(struct usbd_device *dev, u_int8_t *count);
@


1.54
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.53 2013/04/26 14:19:25 mpi Exp $ */
a115 1
struct usbd_device *usbd_pipe2device_handle(struct usbd_pipe *);
@


1.53
log
@Remove unused and ambiguous usbd_get_interface() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.51 2013/04/26 13:46:40 mglocker Exp $ */
d79 1
@


1.52
log
@Remove bogus comments.
@
text
@a132 1
usbd_status  usbd_get_interface(struct usbd_interface *iface, u_int8_t *aiface);
@


1.51
log
@Rename three functions in usbdi.c to their right prefix (usb_* to usbd_*).

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.50 2013/04/19 08:54:50 mpi Exp $ */
d41 1
a41 1
typedef enum {		/* keep in sync with usbd_status_msgs */
a215 2

/* NetBSD attachment information */
@


1.50
log
@Remove unused usbd_get_buffer() function.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.49 2013/04/18 08:44:39 mglocker Exp $ */
d172 2
a173 2
void usb_desc_iter_init(struct usbd_device *, struct usbd_desc_iter *);
const usb_descriptor_t *usb_desc_iter_next(struct usbd_desc_iter *);
d211 1
a211 1
const struct usb_devno *usb_match_device(const struct usb_devno *tbl,
d214 1
a214 1
	usb_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
@


1.49
log
@Move over function prototypes from ubsdi.h to usb.c which just get used
there.  Some spacing while here.

Suggested and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.48 2013/04/15 09:23:02 mglocker Exp $ */
a117 1
void *usbd_get_buffer(struct usbd_xfer *xfer);
@


1.48
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.47 2013/04/12 12:58:39 mpi Exp $ */
a135 3
void usbd_fill_di_task(void *);
void usbd_fill_udc_task(void *);
void usbd_fill_udf_task(void *);
@


1.47
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.46 2013/04/10 07:39:43 mpi Exp $ */
d35 5
a39 6
typedef struct usbd_bus		*usbd_bus_handle;
typedef struct usbd_device	*usbd_device_handle;
typedef struct usbd_interface	*usbd_interface_handle;
typedef struct usbd_pipe	*usbd_pipe_handle;
typedef struct usbd_xfer	*usbd_xfer_handle;
typedef void			*usbd_private_handle;
d66 1
a66 2
typedef void (*usbd_callback)(usbd_xfer_handle, usbd_private_handle,
			      usbd_status);
d85 8
a92 8
usbd_status usbd_open_pipe(usbd_interface_handle iface, u_int8_t address,
    u_int8_t flags, usbd_pipe_handle *pipe);
usbd_status usbd_close_pipe(usbd_pipe_handle pipe);
usbd_status usbd_transfer(usbd_xfer_handle req);
usbd_xfer_handle usbd_alloc_xfer(usbd_device_handle);
usbd_status usbd_free_xfer(usbd_xfer_handle xfer);
void usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
    usbd_private_handle priv, void *buffer, u_int32_t length, u_int16_t flags,
d94 2
a95 2
void usbd_setup_default_xfer(usbd_xfer_handle xfer, usbd_device_handle dev,
    usbd_private_handle priv, u_int32_t timeout, usb_device_request_t *req,
d97 2
a98 2
void usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
    usbd_private_handle priv, u_int16_t *frlengths, u_int32_t nframes,
d100 1
a100 1
void usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle *priv,
d103 18
a120 18
    usbd_interface_handle iface, u_int8_t address);
usbd_status usbd_abort_pipe(usbd_pipe_handle pipe);
usbd_status usbd_clear_endpoint_stall(usbd_pipe_handle pipe);
usbd_status usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe);
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);
usbd_status usbd_endpoint_count(usbd_interface_handle dev, u_int8_t *count);
usbd_status usbd_interface_count(usbd_device_handle dev, u_int8_t *count);
void usbd_interface2device_handle(usbd_interface_handle iface,
    usbd_device_handle *dev);
usbd_status usbd_device2interface_handle(usbd_device_handle dev,
    u_int8_t ifaceno, usbd_interface_handle *iface);

usbd_device_handle usbd_pipe2device_handle(usbd_pipe_handle);
void *usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle xfer);
void *usbd_get_buffer(usbd_xfer_handle xfer);
usbd_status usbd_open_pipe_intr(usbd_interface_handle iface, u_int8_t address,
    u_int8_t flags, usbd_pipe_handle *pipe, usbd_private_handle priv,
d122 1
a122 1
usbd_status usbd_do_request(usbd_device_handle pipe, usb_device_request_t *req,
d124 1
a124 1
usbd_status usbd_do_request_async(usbd_device_handle pipe,
d126 1
a126 1
usbd_status usbd_do_request_flags(usbd_device_handle pipe,
d129 4
a132 4
    usbd_interface_handle iface);
usb_config_descriptor_t *usbd_get_config_descriptor(usbd_device_handle dev);
usb_device_descriptor_t *usbd_get_device_descriptor(usbd_device_handle dev);
usbd_status usbd_set_interface(usbd_interface_handle, int);
d134 2
a135 2
usbd_status  usbd_get_interface(usbd_interface_handle iface, u_int8_t *aiface);
void usbd_fill_deviceinfo(usbd_device_handle, struct usb_device_info *, int);
d139 2
a140 2
usb_config_descriptor_t *usbd_get_cdesc(usbd_device_handle, int, int *);
int usbd_get_interface_altindex(usbd_interface_handle iface);
d147 2
a148 2
void usbd_dopoll(usbd_interface_handle);
void usbd_set_polling(usbd_device_handle iface, int on);
d152 1
a152 1
const struct usbd_quirks *usbd_get_quirks(usbd_device_handle);
d154 1
a154 1
    usbd_interface_handle iface, u_int8_t address);
d156 1
a156 1
usbd_status usbd_reload_device_desc(usbd_device_handle);
d160 10
a169 10
int usbd_get_devcnt(usbd_device_handle);
void usbd_claim_iface(usbd_device_handle, int);
int usbd_iface_claimed(usbd_device_handle, int);

int usbd_is_dying(usbd_device_handle);
void usbd_deactivate(usbd_device_handle);

void usbd_ref_incr(usbd_device_handle);
void usbd_ref_decr(usbd_device_handle);
void usbd_ref_wait(usbd_device_handle);
d172 1
a172 1
typedef struct {
d175 3
a177 3
} usbd_desc_iter_t;
void usb_desc_iter_init(usbd_device_handle, usbd_desc_iter_t *);
const usb_descriptor_t *usb_desc_iter_next(usbd_desc_iter_t *);
d187 1
a187 1
	usbd_device_handle dev;
d201 4
a204 4
void usb_add_task(usbd_device_handle, struct usb_task *);
void usb_rem_task(usbd_device_handle, struct usb_task *);
void usb_wait_task(usbd_device_handle, struct usb_task *);
void usb_rem_wait_task(usbd_device_handle, struct usb_task *);
d232 2
a233 2
	usbd_device_handle	device;	/* current device */
	usbd_interface_handle	iface; /* current interface */
d235 1
a235 1
	usbd_interface_handle  *ifaces;	/* all interfaces */
@


1.46
log
@Merge usb_devinfo* helper functions into usbd_print(), nothing else use
them.

ok ratchov@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.45 2013/04/09 08:47:56 mpi Exp $ */
a120 1
usbd_status usbd_sync_transfer(usbd_xfer_handle req);
@


1.45
log
@When submitting a request the device's default pipe is always
used, so do not pretend to support a different one and get rid
of the unused usbd_do_request_flags_pipe() function.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.44 2013/04/08 10:34:20 mglocker Exp $ */
a153 3

char *usbd_devinfo_alloc(usbd_device_handle dev, int showclass);
void usbd_devinfo_free(char *devinfop);
@


1.44
log
@Add new ioctl's USB_DEVICE_GET_CDESC and USB_DEVICE_GET_FDESC to usb(4).
Those are the equivalents for ugen(4)'s USB_GET_CONFIG_DESC and
USB_GET_FULL_DESC.

Help and OK mpi@@, jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.43 2013/04/01 19:49:53 mglocker Exp $ */
a130 3
usbd_status usbd_do_request_flags_pipe( usbd_device_handle dev,
    usbd_pipe_handle pipe, usb_device_request_t *req, void *data,
    u_int16_t flags, int *actlen, u_int32_t);
@


1.43
log
@Make ugen_get_cdesc() a generic function by renaming it to usbd_get_cdesc()
and move it to usb_subr.c.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.42 2011/02/09 20:24:39 jakemsr Exp $ */
d143 2
@


1.42
log
@bring back changes in usb.c revision 1.73
date: 2011/02/04 08:21:39;  author: jakemsr;  state: Exp;  lines: +85 -34
* merge 'onqueue' and 'running' members of struct usb_task into
  a new member, 'state'.
* add new function 'usb_wait_task()', which waits for queued or running
  usb_tasks to complete.
* in the USB_DEVICEINFO ioctl, fill struct usb_device_info in a
  usb_task, thereby avoiding races against driver attach/detach.

but this time make the state a bitmask, since it is valid to be added
to the task queue while the task is running.  also be more careful
about waking up the task when state changes.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.41 2011/02/09 04:25:32 jakemsr Exp $ */
d143 1
@


1.41
log
@revert usb.c to r1.72, and all subsequent changes that depend on it.
this is causing problems with suspend/resume for some people.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.40 2011/02/04 08:21:39 jakemsr Exp $ */
d142 1
d197 1
a197 1
#define USB_TASK_TYPE_GENERIC	0
d200 5
a204 2
	char onqueue;
	char running;
d209 1
d215 1
a215 2
	(t)->onqueue = 0,	\
	(t)->running = 0)
@


1.40
log
@* merge 'onqueue' and 'running' members of struct usb_task into
  a new member, 'state'.
* add new function 'usb_wait_task()', which waits for queued or running
  usb_tasks to complete.
* in the USB_DEVICEINFO ioctl, fill struct usb_device_info in a
  usb_task, thereby avoiding races against driver attach/detach.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.39 2011/01/25 20:03:36 jakemsr Exp $ */
a141 1
void usbd_fill_di_task(void *);
a189 6
enum usb_task_state {
	USB_TASK_STATE_NONE,
	USB_TASK_STATE_ONQ,
	USB_TASK_STATE_RUN
};

d196 1
a196 1
#define	USB_TASK_TYPE_GENERIC	0
d199 2
a200 1
	enum usb_task_state state;
a204 1
void usb_wait_task(usbd_device_handle, struct usb_task *);
d210 2
a211 1
	(t)->state = USB_TASK_STATE_NONE)
@


1.39
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.38 2011/01/16 22:35:29 jakemsr Exp $ */
d142 1
d191 6
d203 1
a203 1
#define USB_TASK_TYPE_GENERIC	0
d206 1
a206 2
	char onqueue;
	char running;
d211 1
d217 1
a217 2
	(t)->onqueue = 0,	\
	(t)->running = 0)
@


1.38
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.37 2010/12/30 05:10:35 jakemsr Exp $ */
a153 3
void usbd_add_dev_event(int, usbd_device_handle);
void usbd_add_drv_event(int, usbd_device_handle, struct device *);

d185 2
a186 2
 * The usb_task structs form a queue of things to run in the USB event
 * thread.  Normally this is just device discovery when a connect/disconnect
@


1.37
log
@* add a process reference counting variable to struct usbd_device
* add functions to increment and decrement the reference count, and a
  function to wait until the reference count is zero
ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.36 2010/12/06 04:25:27 jakemsr Exp $ */
d167 4
@


1.36
log
@* add dying flag to struct usbd_device
* add usbd_deactivate(), which should be use to set the dying flag in
  struct usbd_device
* add usbd_is_dying(), which can be used to check if either the device
  or the associated bus dying flag has been set
* use usbd_is_dying() to check if the deivce or bus is dying before
  issuing transfers or requests
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.35 2010/10/23 15:42:09 jakemsr Exp $ */
d170 4
@


1.35
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.34 2010/09/23 06:30:37 jakemsr Exp $ */
d167 3
@


1.34
log
@add two members to struct usb_task
* usbd_device_handle dev - the device responsible for the task.  use
this to not run the task if the device's hub is dying.
* int running - a flag to be set when the task is running.

add usb_rem_wait_task(), a wrapper for usb_rem_task() that waits for
the task to complete if the task is already running.

s/usb_rem_task/usb_rem_wait_task/ in usb_detach().  probably most
drivers using usb_tasks should do this as well.  although device
attach/detach is serialized in normal cases, in the special case
where the usb bus is hotpluggable (like cardbus/pcmcia), devices
are not detached in the task thread.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.33 2009/11/04 19:14:10 kettenis Exp $ */
d187 4
d198 6
a203 1
#define usb_init_task(t, f, a) ((t)->fun = (f), (t)->arg = (a), (t)->onqueue = 0, (t)->running = 0)
@


1.33
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.32 2009/09/23 19:59:08 miod Exp $ */
d184 1
d188 1
d191 4
a194 3
void usb_add_task(usbd_device_handle dev, struct usb_task *task);
void usb_rem_task(usbd_device_handle dev, struct usb_task *task);
#define usb_init_task(t, f, a) ((t)->fun = (f), (t)->arg = (a), (t)->onqueue = 0)
@


1.32
log
@Disable SPLUSBCHECK for now, as these turn out to be harmful on sparc64.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.31 2009/08/30 19:15:40 miod Exp $ */
a242 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a248 8
#else
#define splusb splbio
#if 0
#define	SPLUSBCHECK	splassert(IPL_BIO)
#else
#define	SPLUSBCHECK	do { /* nothing */ } while (0)
#endif
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
@


1.31
log
@Reinstate SPLUSBCHECK checks (DIAGNOSTIC-only), but implemented as splassert(),
which is exactly what it was trying to do.

Tested on all *hci controllers with a bunch of usb devices by at least ckuethe@@
and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.30 2008/06/26 05:42:19 ray Exp $ */
d245 1
d248 3
d252 1
d254 3
@


1.30
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.29 2007/06/18 11:37:04 mbalmer Exp $ */
d245 1
d248 1
@


1.29
log
@KNF, especially re-indent prototypes.  No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.28 2007/06/15 11:41:48 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.28
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.27 2007/06/12 16:26:37 mbalmer Exp $ */
d95 1
a95 1
			   u_int8_t flags, usbd_pipe_handle *pipe);
d101 2
a102 3
		     usbd_private_handle priv, void *buffer,
		     u_int32_t length, u_int16_t flags, u_int32_t timeout,
		     usbd_callback);
d104 2
a105 3
			     usbd_private_handle priv, u_int32_t timeout,
			     usb_device_request_t *req, void *buffer,
			     u_int32_t length, u_int16_t flags, usbd_callback);
d107 2
a108 2
			  usbd_private_handle priv, u_int16_t *frlengths,
			  u_int32_t nframes, u_int16_t flags, usbd_callback);
d110 3
a112 3
			  void **buffer, u_int32_t *count, usbd_status *status);
usb_endpoint_descriptor_t *usbd_interface2endpoint_descriptor
			(usbd_interface_handle iface, u_int8_t address);
d120 1
a120 1
				  usbd_device_handle *dev);
d122 1
a122 1
			      u_int8_t ifaceno, usbd_interface_handle *iface);
d130 2
a131 3
				u_int8_t flags, usbd_pipe_handle *pipe,
				usbd_private_handle priv, void *buffer,
				u_int32_t length, usbd_callback, int);
d133 1
a133 1
			    void *data);
d135 1
a135 1
				  usb_device_request_t *req, void *data);
d137 6
a142 8
				  usb_device_request_t *req,
				  void *data, u_int16_t flags, int*, u_int32_t);
usbd_status usbd_do_request_flags_pipe(
	usbd_device_handle dev, usbd_pipe_handle pipe,
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t);
usb_interface_descriptor_t *usbd_get_interface_descriptor
				(usbd_interface_handle iface);
d152 1
a152 1
					    int iindex, int ano);
d154 1
a154 2
					   int ifaceidx, int altidx,
					   int endptidx);
d168 2
a169 2
usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor
			(usbd_interface_handle iface, u_int8_t address);
d205 1
a205 1
	u_int nentries, u_int sz, u_int16_t vendor, u_int16_t product);
@


1.27
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.26 2007/05/29 01:43:44 claudio Exp $ */
a255 1
#ifdef USB_USE_SOFTINTR
d259 1
a259 1
#define	splusb splsoftclock
a260 3
#else
#define splusb splbio
#endif /* USB_USE_SOFTINTR */
@


1.26
log
@Kill some #if define(__OtherBSD__). OK dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.25 2005/09/20 08:03:59 dlg Exp $ */
d168 1
a168 1
void usbd_add_drv_event(int, usbd_device_handle, device_ptr_t);
@


1.25
log
@add iterators for usb descriptors. from Tony Lambris and Staffan Ulfberg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.24 2005/08/01 05:36:49 brad Exp $ */
a91 4
#if defined(__FreeBSD__)
#define USB_CDEV_MAJOR 108
#endif

a233 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a253 24

#elif defined(__FreeBSD__)
/* FreeBSD needs values less than zero */
#define UMATCH_VENDOR_PRODUCT_REV			(-10)
#define UMATCH_VENDOR_PRODUCT				(-20)
#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			(-30)
#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		(-40)
#define UMATCH_DEVCLASS_DEVSUBCLASS			(-50)
#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		(-60)
#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		(-70)
#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		(-80)
#define UMATCH_VENDOR_IFACESUBCLASS			(-90)
#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	(-100)
#define UMATCH_IFACECLASS_IFACESUBCLASS			(-110)
#define UMATCH_IFACECLASS				(-120)
#define UMATCH_IFACECLASS_GENERIC			(-130)
#define UMATCH_GENERIC					(-140)
#define UMATCH_NONE					(ENXIO)

#endif

#if defined(__FreeBSD__)
int usbd_driver_load(module_t mod, int what, void *arg);
#endif
@


1.24
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.23 2004/12/12 06:13:15 dlg Exp $ */
d184 8
@


1.23
log
@backout the original method of reattaching a usb device now that we have
something better and more flexible to use.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.22 2004/11/08 22:01:02 dlg Exp $ */
d96 2
d174 3
a176 1
void usbd_devinfo(usbd_device_handle, int, char *, size_t);
@


1.22
log
@ugly ugly hack to allow a usb device to do a full reset of the port during
attach.

this is required by atu (atmel based usb wireless) devices. something better
will be done, but we need it for now to work on atu.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.21 2003/07/08 13:19:09 nate Exp $ */
a69 1
	USBD_NEED_RESET,	/* 19 */
@


1.21
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.20 2003/05/17 05:33:45 nate Exp $ */
d70 1
@


1.20
log
@make this function available to others
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.19 2003/05/07 04:33:33 deraadt Exp $ */
/*	$NetBSD: usbdi.h,v 1.53 2001/08/15 00:04:59 augustss Exp $	*/
d51 1
a51 1
	USBD_IN_PROGRESS,
d53 17
a69 17
	USBD_PENDING_REQUESTS,
	USBD_NOT_STARTED,
	USBD_INVAL,
	USBD_NOMEM,
	USBD_CANCELLED,
	USBD_BAD_ADDRESS,
	USBD_IN_USE,
	USBD_NO_ADDR,
	USBD_SET_ADDR_FAILED,
	USBD_NO_POWER,
	USBD_TOO_DEEP,
	USBD_IOERROR,
	USBD_NOT_CONFIGURED,
	USBD_TIMEOUT,
	USBD_SHORT_XFER,
	USBD_STALLED,
	USBD_INTERRUPTED,
d123 2
a124 2
usbd_status usbd_interface2device_handle(usbd_interface_handle iface,
					 usbd_device_handle *dev);
d129 2
a130 2
void *usbd_alloc_buffer(usbd_xfer_handle req, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle req);
d155 1
a155 1
void usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di, int);
d272 8
a279 7
/*
 * XXX
 * splusb MUST be the lowest level interrupt so that within USB callbacks
 * the level can be raised the appropriate level.
 * XXX Should probably use a softsplusb.
 */
/* XXX */
d281 1
a283 1
/* XXX */
@


1.19
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.18 2002/07/25 02:18:11 nate Exp $ */
d120 1
@


1.18
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.17 2002/07/09 17:41:02 nate Exp $ */
d171 1
a171 1
void usbd_devinfo(usbd_device_handle, int, char *);
@


1.17
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.16 2002/05/07 18:29:19 nate Exp $ */
d49 1
a49 1
typedef enum {		/* keep in sync with usbd_status_msgs */ 
d141 1
a141 1
				  usb_device_request_t *req, 
d160 1
a160 1
					   int ifaceidx, int altidx, 
@


1.16
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.14 2002/04/01 21:47:07 nate Exp $ */
d142 1
a142 1
				  void *data, u_int16_t flags, int *);
d145 2
a146 1
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen);
@


1.15
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.h,v 1.61 2002/02/11 15:20:23 augustss Exp $	*/
d51 1
a51 1
	USBD_IN_PROGRESS,	/* 1 */
d53 17
a69 17
	USBD_PENDING_REQUESTS,	/* 2 */
	USBD_NOT_STARTED,	/* 3 */
	USBD_INVAL,		/* 4 */
	USBD_NOMEM,		/* 5 */
	USBD_CANCELLED,		/* 6 */
	USBD_BAD_ADDRESS,	/* 7 */
	USBD_IN_USE,		/* 8 */
	USBD_NO_ADDR,		/* 9 */
	USBD_SET_ADDR_FAILED,	/* 10 */
	USBD_NO_POWER,		/* 11 */
	USBD_TOO_DEEP,		/* 12 */
	USBD_IOERROR,		/* 13 */
	USBD_NOT_CONFIGURED,	/* 14 */
	USBD_TIMEOUT,		/* 15 */
	USBD_SHORT_XFER,	/* 16 */
	USBD_STALLED,		/* 17 */
	USBD_INTERRUPTED,	/* 18 */
a119 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);
d122 2
a123 2
void usbd_interface2device_handle(usbd_interface_handle iface,
				  usbd_device_handle *dev);
d128 2
a129 2
void *usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle xfer);
d142 1
a142 1
				  void *data, u_int16_t flags, int*, u_int32_t);
d145 1
a145 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t);
d153 1
a153 1
void usbd_fill_deviceinfo(usbd_device_handle, struct usb_device_info *, int);
d270 7
a276 8
/* XXX Perhaps USB should have its own levels? */
#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
#define splusb splsoftnet
#else
#define	splusb splsoftclock
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
#else
a277 1
#endif /* USB_USE_SOFTINTR */
d280 1
@


1.14
log
@Add support for a bunch of new adapters.
Sync with NetBSD.  ok deraadt
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.13 2001/10/31 04:24:45 nate Exp $ */
/*	$NetBSD: usbdi.h,v 1.53 2001/08/15 00:04:59 augustss Exp $	*/
d51 1
a51 1
	USBD_IN_PROGRESS,
d53 17
a69 17
	USBD_PENDING_REQUESTS,
	USBD_NOT_STARTED,
	USBD_INVAL,
	USBD_NOMEM,
	USBD_CANCELLED,
	USBD_BAD_ADDRESS,
	USBD_IN_USE,
	USBD_NO_ADDR,
	USBD_SET_ADDR_FAILED,
	USBD_NO_POWER,
	USBD_TOO_DEEP,
	USBD_IOERROR,
	USBD_NOT_CONFIGURED,
	USBD_TIMEOUT,
	USBD_SHORT_XFER,
	USBD_STALLED,
	USBD_INTERRUPTED,
d120 1
d123 2
a124 2
usbd_status usbd_interface2device_handle(usbd_interface_handle iface,
					 usbd_device_handle *dev);
d129 2
a130 2
void *usbd_alloc_buffer(usbd_xfer_handle req, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle req);
d143 1
a143 1
				  void *data, u_int16_t flags, int *);
d146 2
a147 1
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen);
d155 1
a155 1
void usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di, int);
d272 8
a279 7
/*
 * XXX
 * splusb MUST be the lowest level interrupt so that within USB callbacks
 * the level can be raised the appropriate level.
 * XXX Should probably use a softsplusb.
 */
/* XXX */
d281 1
a283 1
/* XXX */
@


1.13
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.12 2001/05/03 02:20:34 aaron Exp $ */
d195 10
@


1.13.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.13 2001/10/31 04:24:45 nate Exp $ */
a194 10

struct usb_devno {
	u_int16_t ud_vendor;
	u_int16_t ud_product;
};
const struct usb_devno *usb_match_device(const struct usb_devno *tbl,
	u_int nentries, u_int sz, u_int16_t vendor, u_int16_t product);
#define usb_lookup(tbl, vendor, product) \
	usb_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
#define	USB_PRODUCT_ANY		0xffff
@


1.13.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.13.2.1 2002/06/11 03:42:31 art Exp $ */
d49 1
a49 1
typedef enum {		/* keep in sync with usbd_status_msgs */
d141 2
a142 2
				  usb_device_request_t *req,
				  void *data, u_int16_t flags, int*, u_int32_t);
d145 1
a145 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t);
d159 1
a159 1
					   int ifaceidx, int altidx,
@


1.13.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a119 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);
d171 1
a171 1
void usbd_devinfo(usbd_device_handle, int, char *, size_t);
@


1.12
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.11 2001/01/28 09:43:43 aaron Exp $ */
/*	$NetBSD: usbdi.h,v 1.52 2001/05/01 16:43:44 lukem Exp $	*/
d206 1
@


1.11
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.10 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdi.h,v 1.44 2000/09/23 21:02:04 augustss Exp $	*/
d71 1
a71 1
	USBD_ERROR_MAX,		/* must be last */
a88 3
/* XXX Temporary hack XXX */
#define USBD_NO_TSLEEP		0x80	/* XXX use busy wait */

d178 17
@


1.10
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.9 2000/07/04 11:44:25 fgsch Exp $ */
d156 1
a156 1
void usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di);
d174 1
a174 1
struct usbd_quirks *usbd_get_quirks(usbd_device_handle);
@


1.9
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.8 2000/03/28 19:37:52 aaron Exp $ */
/*	$NetBSD: usbdi.h,v 1.41 2000/03/02 12:37:51 augustss Exp $	*/
d74 2
a75 2
typedef void (*usbd_callback) __P((usbd_xfer_handle, usbd_private_handle,
				   usbd_status));
d99 19
a117 24
usbd_status usbd_open_pipe
	__P((usbd_interface_handle iface, u_int8_t address,
	     u_int8_t flags, usbd_pipe_handle *pipe));
usbd_status usbd_close_pipe	__P((usbd_pipe_handle pipe));
usbd_status usbd_transfer	__P((usbd_xfer_handle req));
usbd_xfer_handle usbd_alloc_xfer __P((usbd_device_handle));
usbd_status usbd_free_xfer	__P((usbd_xfer_handle xfer));
void usbd_setup_xfer
	__P((usbd_xfer_handle xfer, usbd_pipe_handle pipe,
	     usbd_private_handle priv, void *buffer,
	     u_int32_t length, u_int16_t flags, u_int32_t timeout,
	     usbd_callback));
void usbd_setup_default_xfer
	__P((usbd_xfer_handle xfer, usbd_device_handle dev,
	     usbd_private_handle priv, u_int32_t timeout,
	     usb_device_request_t *req,  void *buffer,
	     u_int32_t length, u_int16_t flags, usbd_callback));
void usbd_setup_isoc_xfer	
	__P((usbd_xfer_handle xfer, usbd_pipe_handle pipe,
	     usbd_private_handle priv, u_int16_t *frlengths,
	     u_int32_t nframes, u_int16_t flags, usbd_callback));
void usbd_get_xfer_status
	__P((usbd_xfer_handle xfer, usbd_private_handle *priv,
	     void **buffer, u_int32_t *count, usbd_status *status));
d119 30
a148 30
	__P((usbd_interface_handle iface, u_int8_t address));
usbd_status usbd_abort_pipe __P((usbd_pipe_handle pipe));
usbd_status usbd_clear_endpoint_stall __P((usbd_pipe_handle pipe));
usbd_status usbd_clear_endpoint_stall_async __P((usbd_pipe_handle pipe));
usbd_status usbd_endpoint_count
	__P((usbd_interface_handle dev, u_int8_t *count));
usbd_status usbd_interface_count
	__P((usbd_device_handle dev, u_int8_t *count));
usbd_status usbd_interface2device_handle
	__P((usbd_interface_handle iface, usbd_device_handle *dev));
usbd_status usbd_device2interface_handle
	__P((usbd_device_handle dev, u_int8_t ifaceno, usbd_interface_handle *iface));

usbd_device_handle usbd_pipe2device_handle __P((usbd_pipe_handle));
void *usbd_alloc_buffer __P((usbd_xfer_handle req, u_int32_t size));
void usbd_free_buffer __P((usbd_xfer_handle req));
void *usbd_get_buffer __P((usbd_xfer_handle xfer));
usbd_status usbd_sync_transfer	__P((usbd_xfer_handle req));
usbd_status usbd_open_pipe_intr
	__P((usbd_interface_handle iface, u_int8_t address,
	     u_int8_t flags, usbd_pipe_handle *pipe,
	     usbd_private_handle priv, void *buffer,
	     u_int32_t length, usbd_callback, int));
usbd_status usbd_do_request 
	__P((usbd_device_handle pipe, usb_device_request_t *req, void *data));
usbd_status usbd_do_request_async
	__P((usbd_device_handle pipe, usb_device_request_t *req, void *data));
usbd_status usbd_do_request_flags
	__P((usbd_device_handle pipe, usb_device_request_t *req, 
	     void *data, u_int16_t flags, int *));
d150 17
a166 21
	__P((usbd_interface_handle iface));
usb_config_descriptor_t *usbd_get_config_descriptor
	__P((usbd_device_handle dev));
usb_device_descriptor_t *usbd_get_device_descriptor
	__P((usbd_device_handle dev));
usbd_status usbd_set_interface __P((usbd_interface_handle, int));
int usbd_get_no_alts __P((usb_config_descriptor_t *, int));
usbd_status	usbd_get_interface
	__P((usbd_interface_handle iface, u_int8_t *aiface));
void usbd_fill_deviceinfo 
	__P((usbd_device_handle dev, struct usb_device_info *di));
int usbd_get_interface_altindex __P((usbd_interface_handle iface));

usb_interface_descriptor_t *usbd_find_idesc
	__P((usb_config_descriptor_t *cd, int iindex, int ano));
usb_endpoint_descriptor_t *usbd_find_edesc
	__P((usb_config_descriptor_t *cd, int ifaceidx, int altidx, 
	     int endptidx));

void usbd_dopoll __P((usbd_interface_handle));
void usbd_set_polling __P((usbd_device_handle iface, int on));
d168 1
a168 1
const char *usbd_errstr __P((usbd_status err));
d170 2
a171 2
void usbd_add_dev_event __P((int, usbd_device_handle));
void usbd_add_drv_event __P((int, usbd_device_handle, device_ptr_t));
d173 2
a174 2
void usbd_devinfo __P((usbd_device_handle, int, char *));
struct usbd_quirks *usbd_get_quirks __P((usbd_device_handle));
d176 1
a176 1
	__P((usbd_interface_handle iface, u_int8_t address));
d178 1
a178 1
usbd_status usbd_reload_device_desc __P((usbd_device_handle));
d180 1
a180 1
int usbd_ratecheck __P((struct timeval *last));
d242 1
a242 1
int usbd_driver_load    __P((module_t mod, int what, void *arg));
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.7
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usbdi.h,v 1.6 1999/11/07 21:30:20 fgsch Exp $	*/
/*	$NetBSD: usbdi.h,v 1.31 2000/03/02 12:37:51 augustss Exp $	*/
d81 1
a81 1
#define USBD_DEFAULT_INTERVAL 	(-1)
d104 1
a104 1
usbd_xfer_handle usbd_alloc_xfer	__P((usbd_device_handle));
d116 1
a116 1
void usbd_setup_isoc_xfer
a264 1

@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usbdi.h,v 1.31 1999/10/13 08:10:58 augustss Exp $	*/
d45 1
a45 1
typedef struct usbd_request	*usbd_request_handle;
d73 1
a73 3
typedef int usbd_lock_token;

typedef void (*usbd_callback) __P((usbd_request_handle, usbd_private_handle,
d79 3
d86 4
d102 5
a106 5
usbd_status usbd_transfer	__P((usbd_request_handle req));
usbd_request_handle usbd_alloc_request	__P((usbd_device_handle));
usbd_status usbd_free_request	__P((usbd_request_handle reqh));
void usbd_setup_request	
	__P((usbd_request_handle reqh, usbd_pipe_handle pipe,
d110 2
a111 2
void usbd_setup_default_request
	__P((usbd_request_handle reqh, usbd_device_handle dev,
d115 2
a116 2
void usbd_setup_isoc_request	
	__P((usbd_request_handle reqh, usbd_pipe_handle pipe,
d119 2
a120 2
void usbd_get_request_status
	__P((usbd_request_handle reqh, usbd_private_handle *priv,
d137 4
a140 4
void *usbd_alloc_buffer __P((usbd_request_handle req, u_int32_t size));
void usbd_free_buffer __P((usbd_request_handle req));
void *usbd_get_buffer __P((usbd_request_handle reqh));
usbd_status usbd_sync_transfer	__P((usbd_request_handle req));
d145 1
a145 1
	     u_int32_t length, usbd_callback));
d174 1
a174 1
void usbd_set_polling __P((usbd_interface_handle iface, int on));
d178 11
a188 1
void usbd_add_event __P((int, usbd_device_handle));
a248 5
void usbd_devinfo __P((usbd_device_handle, int, char *));
struct usbd_quirks *usbd_get_quirks __P((usbd_device_handle));
usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor
	__P((usbd_interface_handle iface, u_int8_t address));

d253 6
d261 1
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usbdi.h,v 1.11 2001/01/28 09:43:43 aaron Exp $ */
/*	$NetBSD: usbdi.h,v 1.44 2000/09/23 21:02:04 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdi.h,v 1.18 1999/11/17 22:33:49 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d45 1
a45 1
typedef struct usbd_xfer	*usbd_xfer_handle;
d73 4
a76 2
typedef void (*usbd_callback)(usbd_xfer_handle, usbd_private_handle,
			      usbd_status);
a80 3
/* Use default (specified by ep. desc.) interval on interrupt pipe */
#define USBD_DEFAULT_INTERVAL	(-1)

a84 4
#define USBD_FORCE_SHORT_XFER	0x08	/* force last short packet on write */

/* XXX Temporary hack XXX */
#define USBD_NO_TSLEEP		0x80	/* XXX use busy wait */
d93 24
a116 19
usbd_status usbd_open_pipe(usbd_interface_handle iface, u_int8_t address,
			   u_int8_t flags, usbd_pipe_handle *pipe);
usbd_status usbd_close_pipe(usbd_pipe_handle pipe);
usbd_status usbd_transfer(usbd_xfer_handle req);
usbd_xfer_handle usbd_alloc_xfer(usbd_device_handle);
usbd_status usbd_free_xfer(usbd_xfer_handle xfer);
void usbd_setup_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
		     usbd_private_handle priv, void *buffer,
		     u_int32_t length, u_int16_t flags, u_int32_t timeout,
		     usbd_callback);
void usbd_setup_default_xfer(usbd_xfer_handle xfer, usbd_device_handle dev,
			     usbd_private_handle priv, u_int32_t timeout,
			     usb_device_request_t *req, void *buffer,
			     u_int32_t length, u_int16_t flags, usbd_callback);
void usbd_setup_isoc_xfer(usbd_xfer_handle xfer, usbd_pipe_handle pipe,
			  usbd_private_handle priv, u_int16_t *frlengths,
			  u_int32_t nframes, u_int16_t flags, usbd_callback);
void usbd_get_xfer_status(usbd_xfer_handle xfer, usbd_private_handle *priv,
			  void **buffer, u_int32_t *count, usbd_status *status);
d118 30
a147 30
			(usbd_interface_handle iface, u_int8_t address);
usbd_status usbd_abort_pipe(usbd_pipe_handle pipe);
usbd_status usbd_clear_endpoint_stall(usbd_pipe_handle pipe);
usbd_status usbd_clear_endpoint_stall_async(usbd_pipe_handle pipe);
usbd_status usbd_endpoint_count(usbd_interface_handle dev, u_int8_t *count);
usbd_status usbd_interface_count(usbd_device_handle dev, u_int8_t *count);
usbd_status usbd_interface2device_handle(usbd_interface_handle iface,
					 usbd_device_handle *dev);
usbd_status usbd_device2interface_handle(usbd_device_handle dev,
			      u_int8_t ifaceno, usbd_interface_handle *iface);

usbd_device_handle usbd_pipe2device_handle(usbd_pipe_handle);
void *usbd_alloc_buffer(usbd_xfer_handle req, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle req);
void *usbd_get_buffer(usbd_xfer_handle xfer);
usbd_status usbd_sync_transfer(usbd_xfer_handle req);
usbd_status usbd_open_pipe_intr(usbd_interface_handle iface, u_int8_t address,
				u_int8_t flags, usbd_pipe_handle *pipe,
				usbd_private_handle priv, void *buffer,
				u_int32_t length, usbd_callback, int);
usbd_status usbd_do_request(usbd_device_handle pipe, usb_device_request_t *req,
			    void *data);
usbd_status usbd_do_request_async(usbd_device_handle pipe,
				  usb_device_request_t *req, void *data);
usbd_status usbd_do_request_flags(usbd_device_handle pipe,
				  usb_device_request_t *req, 
				  void *data, u_int16_t flags, int *);
usbd_status usbd_do_request_flags_pipe(
	usbd_device_handle dev, usbd_pipe_handle pipe,
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen);
d149 18
a166 17
				(usbd_interface_handle iface);
usb_config_descriptor_t *usbd_get_config_descriptor(usbd_device_handle dev);
usb_device_descriptor_t *usbd_get_device_descriptor(usbd_device_handle dev);
usbd_status usbd_set_interface(usbd_interface_handle, int);
int usbd_get_no_alts(usb_config_descriptor_t *, int);
usbd_status  usbd_get_interface(usbd_interface_handle iface, u_int8_t *aiface);
void usbd_fill_deviceinfo(usbd_device_handle dev, struct usb_device_info *di, int);
int usbd_get_interface_altindex(usbd_interface_handle iface);

usb_interface_descriptor_t *usbd_find_idesc(usb_config_descriptor_t *cd,
					    int iindex, int ano);
usb_endpoint_descriptor_t *usbd_find_edesc(usb_config_descriptor_t *cd,
					   int ifaceidx, int altidx, 
					   int endptidx);

void usbd_dopoll(usbd_interface_handle);
void usbd_set_polling(usbd_device_handle iface, int on);
d168 2
a169 9
const char *usbd_errstr(usbd_status err);

void usbd_add_dev_event(int, usbd_device_handle);
void usbd_add_drv_event(int, usbd_device_handle, device_ptr_t);

void usbd_devinfo(usbd_device_handle, int, char *);
const struct usbd_quirks *usbd_get_quirks(usbd_device_handle);
usb_endpoint_descriptor_t *usbd_get_endpoint_descriptor
			(usbd_interface_handle iface, u_int8_t address);
d171 1
a171 1
usbd_status usbd_reload_device_desc(usbd_device_handle);
d173 1
a173 1
int usbd_ratecheck(struct timeval *last);
d234 5
d240 1
a240 1
int usbd_driver_load(module_t mod, int what, void *arg);
a242 6
/*
 * XXX
 * splusb MUST be the lowest level interrupt so that within USB callbacks
 * the level can be raised the appropriate level.
 * XXX Should probably use a softsplusb.
 */
a244 1
#define splhardusb splbio
d247 1
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi.h,v 1.52 2001/05/01 16:43:44 lukem Exp $	*/
d71 1
a71 1
	USBD_ERROR_MAX		/* must be last */
d89 3
a180 17

/*
 * The usb_task structs form a queue of things to run in the USB event
 * thread.  Normally this is just device discovery when a connect/disconnect
 * has been detected.  But it may also be used by drivers that need to
 * perform (short) tasks that must have a process context.
 */
struct usb_task {
	TAILQ_ENTRY(usb_task) next;
	void (*fun)(void *);
	void *arg;
	char onqueue;
};

void usb_add_task(usbd_device_handle dev, struct usb_task *task);
void usb_rem_task(usbd_device_handle dev, struct usb_task *task);
#define usb_init_task(t, f, a) ((t)->fun = (f), (t)->arg = (a), (t)->onqueue = 0)
@


1.6.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.h,v 1.53 2001/08/15 00:04:59 augustss Exp $	*/
a205 1
	int			matchlvl;
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d49 1
a49 1
typedef enum {		/* keep in sync with usbd_status_msgs */
d141 2
a142 2
				  usb_device_request_t *req,
				  void *data, u_int16_t flags, int*, u_int32_t);
d145 1
a145 2
	usb_device_request_t *req, void *data, u_int16_t flags, int *actlen,
	u_int32_t);
d159 1
a159 1
					   int ifaceidx, int altidx,
a194 10

struct usb_devno {
	u_int16_t ud_vendor;
	u_int16_t ud_product;
};
const struct usb_devno *usb_match_device(const struct usb_devno *tbl,
	u_int nentries, u_int sz, u_int16_t vendor, u_int16_t product);
#define usb_lookup(tbl, vendor, product) \
	usb_match_device((const struct usb_devno *)(tbl), sizeof (tbl) / sizeof ((tbl)[0]), sizeof ((tbl)[0]), (vendor), (product))
#define	USB_PRODUCT_ANY		0xffff
@


1.6.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.6.2.4 2003/03/28 00:38:32 niklas Exp $ */
d171 1
a171 1
void usbd_devinfo(usbd_device_handle, int, char *, size_t);
@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.6.2.5 2003/05/13 19:35:13 ho Exp $ */
a119 1
void usbd_clear_endpoint_toggle(usbd_pipe_handle pipe);
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdi.h,v 1.62 2002/07/11 21:14:35 augustss Exp $	*/
d51 1
a51 1
	USBD_IN_PROGRESS,	/* 1 */
d53 17
a69 17
	USBD_PENDING_REQUESTS,	/* 2 */
	USBD_NOT_STARTED,	/* 3 */
	USBD_INVAL,		/* 4 */
	USBD_NOMEM,		/* 5 */
	USBD_CANCELLED,		/* 6 */
	USBD_BAD_ADDRESS,	/* 7 */
	USBD_IN_USE,		/* 8 */
	USBD_NO_ADDR,		/* 9 */
	USBD_SET_ADDR_FAILED,	/* 10 */
	USBD_NO_POWER,		/* 11 */
	USBD_TOO_DEEP,		/* 12 */
	USBD_IOERROR,		/* 13 */
	USBD_NOT_CONFIGURED,	/* 14 */
	USBD_TIMEOUT,		/* 15 */
	USBD_SHORT_XFER,	/* 16 */
	USBD_STALLED,		/* 17 */
	USBD_INTERRUPTED,	/* 18 */
d123 2
a124 2
void usbd_interface2device_handle(usbd_interface_handle iface,
				  usbd_device_handle *dev);
d129 2
a130 2
void *usbd_alloc_buffer(usbd_xfer_handle xfer, u_int32_t size);
void usbd_free_buffer(usbd_xfer_handle xfer);
d155 1
a155 1
void usbd_fill_deviceinfo(usbd_device_handle, struct usb_device_info *, int);
d272 7
a278 8
/* XXX Perhaps USB should have its own levels? */
#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
#define splusb splsoftnet
#else
#define	splusb splsoftclock
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
#else
a279 1
#endif /* USB_USE_SOFTINTR */
d282 1
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdi.h,v 1.29 1999/09/12 08:23:42 augustss Exp $	*/
d48 1
a48 1
typedef enum { 
d89 4
d173 2
d216 15
a230 36
/* for the moment disabled
#define UMATCH_VENDOR_PRODUCT_REV			-14
#define UMATCH_VENDOR_PRODUCT				-13
#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			-12
#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		-11
#define UMATCH_DEVCLASS_DEVSUBCLASS			-10
#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		 -9
#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		 -8
#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		 -7
#define UMATCH_VENDOR_IFACESUBCLASS			 -6
#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	 -5
#define UMATCH_IFACECLASS_IFACESUBCLASS			 -4
#define UMATCH_IFACECLASS				 -3
#define UMATCH_IFACECLASS_GENERIC			 -2
#define UMATCH_GENERIC					 -1
#define UMATCH_NONE				      ENXIO

* For the moment we use Yes/No answers with appropriate
* sorting in the config file
*/
#define UMATCH_VENDOR_PRODUCT_REV			0
#define UMATCH_VENDOR_PRODUCT				0
#define UMATCH_VENDOR_DEVCLASS_DEVPROTO			0
#define UMATCH_DEVCLASS_DEVSUBCLASS_DEVPROTO		0
#define UMATCH_DEVCLASS_DEVSUBCLASS			0
#define UMATCH_VENDOR_PRODUCT_REV_CONF_IFACE		0
#define UMATCH_VENDOR_PRODUCT_CONF_IFACE		0
#define UMATCH_VENDOR_IFACESUBCLASS_IFACEPROTO		0
#define UMATCH_VENDOR_IFACESUBCLASS			0
#define UMATCH_IFACECLASS_IFACESUBCLASS_IFACEPROTO	0
#define UMATCH_IFACECLASS_IFACESUBCLASS			0
#define UMATCH_IFACECLASS				0
#define UMATCH_IFACECLASS_GENERIC			0
#define UMATCH_GENERIC					0
#define UMATCH_NONE				      ENXIO

a240 3
void usbd_device_set_desc __P((device_t device, char *devinfo));
char *usbd_devname(device_t *bdev);
bus_print_child_t usbd_print_child;
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdi.h,v 1.3 1999/08/27 09:00:30 fgsch Exp $	*/
/*	$NetBSD: usbdi.h,v 1.20 1999/06/30 06:44:23 augustss Exp $	*/
a69 2
	USBD_XXX,

d82 3
a84 4
#define USBD_XFER_OUT		0x01
#define USBD_XFER_IN		0x02
#define USBD_SHORT_XFER_OK	0x04	/* allow short reads */
#define USBD_SYNCHRONOUS	0x08	/* wait for completion */
d94 1
a94 1
usbd_request_handle usbd_alloc_request	__P((void));
d96 1
a96 1
usbd_status usbd_setup_request	
d101 1
a101 1
usbd_status usbd_setup_default_request
d106 4
d127 4
a130 1
/* Non-standard */
a136 4
usbd_status usbd_open_pipe_iso
	__P((usbd_interface_handle iface, u_int8_t address,
	     u_int8_t flags, usbd_pipe_handle *pipe,
	     usbd_private_handle priv, u_int32_t bufsize, u_int32_t nbuf));
d257 1
a257 1
char *usbd_devname(bdevice *bdev);
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.2 1999/08/16 22:08:49 fgsch Exp $	*/
d167 1
a167 1
char *usbd_errstr __P((usbd_status err));
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdi.h,v 1.1 1999/08/13 05:28:05 fgsch Exp $	*/
d49 1
a49 1
	USBD_NORMAL_COMPLETION = 0,
d71 2
d86 2
a87 1
#define USBD_SHORT_XFER_OK	0x04
d109 1
a109 1
usbd_status usbd_get_request_status
d166 2
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d133 1
a133 2
	     usbd_private_handle priv, u_int32_t bufsize, u_int32_t nbuf,
	     usbd_callback));
@

