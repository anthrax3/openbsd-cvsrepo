head	1.142;
access;
symbols
	OPENBSD_6_1_BASE:1.142
	OPENBSD_6_0:1.140.0.4
	OPENBSD_6_0_BASE:1.140
	OPENBSD_5_9:1.138.0.2
	OPENBSD_5_9_BASE:1.138
	OPENBSD_5_8:1.132.0.4
	OPENBSD_5_8_BASE:1.132
	OPENBSD_5_7:1.131.0.2
	OPENBSD_5_7_BASE:1.131
	OPENBSD_5_6:1.128.0.4
	OPENBSD_5_6_BASE:1.128
	OPENBSD_5_5:1.124.0.4
	OPENBSD_5_5_BASE:1.124
	OPENBSD_5_4:1.123.0.2
	OPENBSD_5_4_BASE:1.123
	OPENBSD_5_3:1.121.0.8
	OPENBSD_5_3_BASE:1.121
	OPENBSD_5_2:1.121.0.6
	OPENBSD_5_2_BASE:1.121
	OPENBSD_5_1_BASE:1.121
	OPENBSD_5_1:1.121.0.4
	OPENBSD_5_0:1.121.0.2
	OPENBSD_5_0_BASE:1.121
	OPENBSD_4_9:1.120.0.2
	OPENBSD_4_9_BASE:1.120
	OPENBSD_4_8:1.112.0.2
	OPENBSD_4_8_BASE:1.112
	OPENBSD_4_7:1.111.0.2
	OPENBSD_4_7_BASE:1.111
	OPENBSD_4_6:1.109.0.6
	OPENBSD_4_6_BASE:1.109
	OPENBSD_4_5:1.109.0.2
	OPENBSD_4_5_BASE:1.109
	OPENBSD_4_4:1.105.0.2
	OPENBSD_4_4_BASE:1.105
	OPENBSD_4_3:1.102.0.2
	OPENBSD_4_3_BASE:1.102
	OPENBSD_4_2:1.100.0.2
	OPENBSD_4_2_BASE:1.100
	OPENBSD_4_1:1.89.0.2
	OPENBSD_4_1_BASE:1.89
	OPENBSD_4_0:1.79.0.4
	OPENBSD_4_0_BASE:1.79
	OPENBSD_3_9:1.65.0.2
	OPENBSD_3_9_BASE:1.65
	OPENBSD_3_8:1.44.0.2
	OPENBSD_3_8_BASE:1.44
	OPENBSD_3_7:1.14.0.2
	OPENBSD_3_7_BASE:1.14;
locks; strict;
comment	@ * @;


1.142
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.141;
commitid	VyLWTsbepAOk7VQM;

1.141
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.140;
commitid	xlY19nmD0cBL53l1;

1.140
date	2016.07.20.10.24.43;	author stsp;	state Exp;
branches;
next	1.139;
commitid	PAZIN9Bw788O5cOp;

1.139
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.138;
commitid	gWZDkudwxydTq8x4;

1.138
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.137;
commitid	B0kwmVGiD5DVx4kv;

1.137
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.136;
commitid	FuSD2mFDJWATHIDx;

1.136
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.135;
commitid	5DvsamK0GblTp8ww;

1.135
date	2015.11.13.10.36.29;	author mpi;	state Exp;
branches;
next	1.134;
commitid	pVgZpZmw966Haagb;

1.134
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.133;
commitid	YT6fyIEviv9qwbl6;

1.133
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.132;
commitid	pwYnMC1gOKohmeGw;

1.132
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.131;
commitid	p4LJxGKbi0BU2cG6;

1.131
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.130;
commitid	Hly9lJn6CNMylcFu;

1.130
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.129;
commitid	yM2VFFhpDTeFQlve;

1.129
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.128;
commitid	LS2TNeCue5R9L67C;

1.128
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.127;
commitid	Pclvgy2Z4XV9hveD;

1.127
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.126;
commitid	b0VSac5dnnsxcDao;

1.126
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.125;

1.125
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.124;

1.124
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.123;

1.123
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.122;

1.122
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.120;

1.120
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.119;

1.119
date	2010.12.30.05.22.51;	author jakemsr;	state Exp;
branches;
next	1.118;

1.118
date	2010.12.17.22.38.54;	author jasper;	state Exp;
branches;
next	1.117;

1.117
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.116;

1.116
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.115;

1.115
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.114;

1.114
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.113;

1.113
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.112;

1.112
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.111;

1.111
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.110;

1.110
date	2009.07.10.07.47.38;	author blambert;	state Exp;
branches;
next	1.109;

1.109
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.108;

1.108
date	2008.08.27.10.34.24;	author damien;	state Exp;
branches;
next	1.107;

1.107
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.106;

1.106
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.105;

1.105
date	2008.07.30.06.25.23;	author damien;	state Exp;
branches;
next	1.104;

1.104
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.103;

1.103
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.102;

1.102
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.101;

1.101
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.100;

1.100
date	2007.07.18.18.10.31;	author damien;	state Exp;
branches;
next	1.99;

1.99
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.98;

1.98
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.97;

1.97
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.96;

1.96
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.95;

1.95
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.94;

1.94
date	2007.06.09.08.52.10;	author damien;	state Exp;
branches;
next	1.93;

1.93
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.92;

1.92
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.91;

1.91
date	2007.05.21.06.10.43;	author jsg;	state Exp;
branches;
next	1.90;

1.90
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.89;

1.89
date	2007.02.19.17.22.02;	author deraadt;	state Exp;
branches;
next	1.88;

1.88
date	2007.01.02.14.43.50;	author claudio;	state Exp;
branches;
next	1.87;

1.87
date	2006.12.07.17.32.19;	author damien;	state Exp;
branches;
next	1.86;

1.86
date	2006.12.03.16.39.13;	author damien;	state Exp;
branches;
next	1.85;

1.85
date	2006.12.03.16.16.58;	author damien;	state Exp;
branches;
next	1.84;

1.84
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.83;

1.83
date	2006.11.19.16.44.36;	author damien;	state Exp;
branches;
next	1.82;

1.82
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.81;

1.81
date	2006.10.22.12.27.56;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.79;

1.79
date	2006.08.24.19.32.21;	author damien;	state Exp;
branches;
next	1.78;

1.78
date	2006.08.23.21.37.04;	author niallo;	state Exp;
branches;
next	1.77;

1.77
date	2006.08.23.16.25.07;	author damien;	state Exp;
branches;
next	1.76;

1.76
date	2006.08.23.08.06.49;	author jsg;	state Exp;
branches;
next	1.75;

1.75
date	2006.08.18.16.04.56;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2006.08.18.15.23.13;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2006.08.18.15.18.24;	author damien;	state Exp;
branches;
next	1.72;

1.72
date	2006.08.09.07.40.52;	author damien;	state Exp;
branches;
next	1.71;

1.71
date	2006.07.02.00.56.14;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.69;

1.69
date	2006.06.17.19.07.19;	author damien;	state Exp;
branches;
next	1.68;

1.68
date	2006.06.10.20.28.11;	author damien;	state Exp;
branches;
next	1.67;

1.67
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.66;

1.66
date	2006.03.21.11.19.22;	author pedro;	state Exp;
branches;
next	1.65;

1.65
date	2006.02.19.08.44.17;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2006.02.11.09.31.42;	author damien;	state Exp;
branches;
next	1.63;

1.63
date	2006.02.04.11.40.32;	author damien;	state Exp;
branches;
next	1.62;

1.62
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.61;

1.61
date	2006.01.22.21.41.03;	author damien;	state Exp;
branches;
next	1.60;

1.60
date	2006.01.14.12.40.39;	author damien;	state Exp;
branches;
next	1.59;

1.59
date	2006.01.14.08.50.38;	author jsg;	state Exp;
branches;
next	1.58;

1.58
date	2006.01.13.21.29.53;	author damien;	state Exp;
branches;
next	1.57;

1.57
date	2006.01.13.21.00.54;	author damien;	state Exp;
branches;
next	1.56;

1.56
date	2006.01.13.17.48.25;	author damien;	state Exp;
branches;
next	1.55;

1.55
date	2006.01.13.17.35.33;	author damien;	state Exp;
branches;
next	1.54;

1.54
date	2006.01.04.06.04.41;	author canacar;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.23.08.10.12;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2005.12.09.05.22.08;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.24.22.10.07;	author damien;	state Exp;
branches;
next	1.50;

1.50
date	2005.11.24.13.01.58;	author grange;	state Exp;
branches;
next	1.49;

1.49
date	2005.11.23.20.37.37;	author damien;	state Exp;
branches;
next	1.48;

1.48
date	2005.11.23.20.29.30;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2005.11.23.20.23.48;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2005.11.23.19.56.51;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2005.10.02.13.01.59;	author damien;	state Exp;
branches;
next	1.44;

1.44
date	2005.08.27.14.46.37;	author damien;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2005.08.27.06.42.27;	author deraadt;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.25.20.28.19;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2005.08.23.02.25.52;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.07.18.14.41.15;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2005.07.07.08.33.22;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2005.07.07.02.14.32;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2005.06.20.18.54.59;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2005.06.16.03.43.50;	author dlg;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.18.20.10.17;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2005.05.13.19.35.47;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2005.05.13.19.13.11;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2005.05.13.19.00.10;	author damien;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.13.18.42.50;	author damien;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.13.18.17.08;	author damien;	state Exp;
branches;
next	1.28;

1.28
date	2005.04.17.13.41.51;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2005.04.16.08.27.41;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2005.04.16.08.26.01;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2005.04.15.13.42.54;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.13.12.24.11;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2005.04.02.11.00.11;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.01.13.13.42;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.01.12.57.27;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2005.04.01.10.00.56;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.23.15.15.11;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2005.03.23.14.48.55;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.23.14.14.31;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.23.13.07.35;	author dlg;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.23.12.41.47;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.19.10.18.49;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.19.09.52.54;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.19.09.49.39;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.18.22.11.08;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.18.20.18.57;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2005.03.18.19.07.22;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2005.03.18.13.57.42;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.18.13.53.31;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2005.03.17.14.23.03;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.17.12.46.54;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.17.11.04.30;	author dlg;	state Exp;
branches;
next	1.3;

1.3
date	2005.03.17.09.01.43;	author damien;	state Exp;
branches;
next	1.2;

1.2
date	2005.03.16.21.21.39;	author damien;	state Exp;
branches;
next	1.1;

1.1
date	2005.03.16.20.17.10;	author damien;	state Exp;
branches;
next	;

1.44.2.1
date	2006.05.06.18.51.07;	author brad;	state Exp;
branches;
next	;


desc
@@


1.142
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_ral.c,v 1.141 2016/11/06 12:58:01 mpi Exp $	*/

/*-
 * Copyright (c) 2005, 2006
 *	Damien Bergamini <damien.bergamini@@free.fr>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Ralink Technology RT2500USB chipset driver
 * http://www.ralinktech.com.tw/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_ralreg.h>
#include <dev/usb/if_ralvar.h>

#ifdef URAL_DEBUG
#define DPRINTF(x)	do { if (ural_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (ural_debug >= (n)) printf x; } while (0)
int ural_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

/* various supported device vendors/products */
static const struct usb_devno ural_devs[] = {
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_RT2570 },
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_RT2570_2 },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050 },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54G },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54GP },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_HU200TS },
	{ USB_VENDOR_CONCEPTRONIC2,	USB_PRODUCT_CONCEPTRONIC2_C54RU },
	{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_RT2570 },
	{ USB_VENDOR_GIGABYTE,		USB_PRODUCT_GIGABYTE_GNWBKG },
	{ USB_VENDOR_GUILLEMOT,		USB_PRODUCT_GUILLEMOT_HWGUSB254 },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54 },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54AI },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_KG54YB },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_NINWIFI },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570_2 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2570_3 },
	{ USB_VENDOR_NOVATECH,		USB_PRODUCT_NOVATECH_NV902W },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2570 },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2570_2 },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2570_3 },
	{ USB_VENDOR_SPHAIRON,		USB_PRODUCT_SPHAIRON_UB801R },
	{ USB_VENDOR_SURECOM,		USB_PRODUCT_SURECOM_RT2570 },
	{ USB_VENDOR_VTECH,		USB_PRODUCT_VTECH_RT2570 },
	{ USB_VENDOR_ZINWELL,		USB_PRODUCT_ZINWELL_RT2570 }
};

int		ural_alloc_tx_list(struct ural_softc *);
void		ural_free_tx_list(struct ural_softc *);
int		ural_alloc_rx_list(struct ural_softc *);
void		ural_free_rx_list(struct ural_softc *);
int		ural_media_change(struct ifnet *);
void		ural_next_scan(void *);
void		ural_task(void *);
int		ural_newstate(struct ieee80211com *, enum ieee80211_state,
		    int);
void		ural_txeof(struct usbd_xfer *, void *, usbd_status);
void		ural_rxeof(struct usbd_xfer *, void *, usbd_status);
#if NBPFILTER > 0
uint8_t		ural_rxrate(const struct ural_rx_desc *);
#endif
int		ural_ack_rate(struct ieee80211com *, int);
uint16_t	ural_txtime(int, int, uint32_t);
uint8_t		ural_plcp_signal(int);
void		ural_setup_tx_desc(struct ural_softc *, struct ural_tx_desc *,
		    uint32_t, int, int);
#ifndef IEEE80211_STA_ONLY
int		ural_tx_bcn(struct ural_softc *, struct mbuf *,
		    struct ieee80211_node *);
#endif
int		ural_tx_data(struct ural_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		ural_start(struct ifnet *);
void		ural_watchdog(struct ifnet *);
int		ural_ioctl(struct ifnet *, u_long, caddr_t);
void		ural_eeprom_read(struct ural_softc *, uint16_t, void *, int);
uint16_t	ural_read(struct ural_softc *, uint16_t);
void		ural_read_multi(struct ural_softc *, uint16_t, void *, int);
void		ural_write(struct ural_softc *, uint16_t, uint16_t);
void		ural_write_multi(struct ural_softc *, uint16_t, void *, int);
void		ural_bbp_write(struct ural_softc *, uint8_t, uint8_t);
uint8_t		ural_bbp_read(struct ural_softc *, uint8_t);
void		ural_rf_write(struct ural_softc *, uint8_t, uint32_t);
void		ural_set_chan(struct ural_softc *, struct ieee80211_channel *);
void		ural_disable_rf_tune(struct ural_softc *);
void		ural_enable_tsf_sync(struct ural_softc *);
void		ural_update_slot(struct ural_softc *);
void		ural_set_txpreamble(struct ural_softc *);
void		ural_set_basicrates(struct ural_softc *);
void		ural_set_bssid(struct ural_softc *, const uint8_t *);
void		ural_set_macaddr(struct ural_softc *, const uint8_t *);
void		ural_update_promisc(struct ural_softc *);
const char	*ural_get_rf(int);
void		ural_read_eeprom(struct ural_softc *);
int		ural_bbp_init(struct ural_softc *);
void		ural_set_txantenna(struct ural_softc *, int);
void		ural_set_rxantenna(struct ural_softc *, int);
int		ural_init(struct ifnet *);
void		ural_stop(struct ifnet *, int);
void		ural_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
void		ural_amrr_start(struct ural_softc *, struct ieee80211_node *);
void		ural_amrr_timeout(void *);
void		ural_amrr_update(struct usbd_xfer *, void *,
		    usbd_status status);

static const struct {
	uint16_t	reg;
	uint16_t	val;
} ural_def_mac[] = {
	RAL_DEF_MAC
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
} ural_def_bbp[] = {
	RAL_DEF_BBP
};

static const uint32_t ural_rf2522_r2[] =    RAL_RF2522_R2;
static const uint32_t ural_rf2523_r2[] =    RAL_RF2523_R2;
static const uint32_t ural_rf2524_r2[] =    RAL_RF2524_R2;
static const uint32_t ural_rf2525_r2[] =    RAL_RF2525_R2;
static const uint32_t ural_rf2525_hi_r2[] = RAL_RF2525_HI_R2;
static const uint32_t ural_rf2525e_r2[] =   RAL_RF2525E_R2;
static const uint32_t ural_rf2526_hi_r2[] = RAL_RF2526_HI_R2;
static const uint32_t ural_rf2526_r2[] =    RAL_RF2526_R2;

int ural_match(struct device *, void *, void *);
void ural_attach(struct device *, struct device *, void *);
int ural_detach(struct device *, int);

struct cfdriver ural_cd = {
	NULL, "ural", DV_IFNET
};

const struct cfattach ural_ca = {
	sizeof(struct ural_softc), ural_match, ural_attach, ural_detach
};

int
ural_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != RAL_CONFIG_NO)
		return UMATCH_NONE;

	return (usb_lookup(ural_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

void
ural_attach(struct device *parent, struct device *self, void *aux)
{
	struct ural_softc *sc = (struct ural_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status error;
	int i;

	sc->sc_udev = uaa->device;

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, RAL_IFACE_INDEX,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/*
	 * Find endpoints.
	 */
	id = usbd_get_interface_descriptor(sc->sc_iface);

	sc->sc_rx_no = sc->sc_tx_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for iface %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_rx_no = ed->bEndpointAddress;
		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_tx_no = ed->bEndpointAddress;
	}
	if (sc->sc_rx_no == -1 || sc->sc_tx_no == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		return;
	}

	usb_init_task(&sc->sc_task, ural_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, ural_next_scan, sc);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 10;
	timeout_set(&sc->amrr_to, ural_amrr_timeout, sc);

	/* retrieve RT2570 rev. no */
	sc->asic_rev = ural_read(sc, RAL_MAC_CSR0);

	/* retrieve MAC address and various other things from EEPROM */
	ural_read_eeprom(sc);

	printf("%s: MAC/BBP RT%04x (rev 0x%02x), RF %s, address %s\n",
	    sc->sc_dev.dv_xname, sc->macbbp_rev, sc->asic_rev,
	    ural_get_rf(sc->rf_rev), ether_sprintf(ic->ic_myaddr));

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_HOSTAP |	/* HostAp mode supported */
#endif
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = ural_ioctl;
	ifp->if_start = ural_start;
	ifp->if_watchdog = ural_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_newassoc = ural_newassoc;

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = ural_newstate;
	ieee80211_media_init(ifp, ural_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + 64);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(RAL_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(RAL_TX_RADIOTAP_PRESENT);
#endif
}

int
ural_detach(struct device *self, int flags)
{
	struct ural_softc *sc = (struct ural_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->amrr_to))
		timeout_del(&sc->amrr_to);

	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);	/* free all nodes */
		if_detach(ifp);
	}

	if (sc->amrr_xfer != NULL) {
		usbd_free_xfer(sc->amrr_xfer);
		sc->amrr_xfer = NULL;
	}

	if (sc->sc_rx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_rx_pipeh);
		usbd_close_pipe(sc->sc_rx_pipeh);
	}

	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
	}

	ural_free_rx_list(sc);
	ural_free_tx_list(sc);

	splx(s);

	return 0;
}

int
ural_alloc_tx_list(struct ural_softc *sc)
{
	int i, error;

	sc->tx_cur = sc->tx_queued = 0;

	for (i = 0; i < RAL_TX_LIST_COUNT; i++) {
		struct ural_tx_data *data = &sc->tx_data[i];

		data->sc = sc;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer,
		    RAL_TX_DESC_SIZE + IEEE80211_MAX_LEN);
		if (data->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
	}

	return 0;

fail:	ural_free_tx_list(sc);
	return error;
}

void
ural_free_tx_list(struct ural_softc *sc)
{
	int i;

	for (i = 0; i < RAL_TX_LIST_COUNT; i++) {
		struct ural_tx_data *data = &sc->tx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;
	}
}

int
ural_alloc_rx_list(struct ural_softc *sc)
{
	int i, error;

	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
		struct ural_rx_data *data = &sc->rx_data[i];

		data->sc = sc;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		if (usbd_alloc_buffer(data->xfer, MCLBYTES) == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = mtod(data->m, uint8_t *);
	}

	return 0;

fail:	ural_free_rx_list(sc);
	return error;
}

void
ural_free_rx_list(struct ural_softc *sc)
{
	int i;

	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
		struct ural_rx_data *data = &sc->rx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		if (data->m != NULL) {
			m_freem(data->m);
			data->m = NULL;
		}
	}
}

int
ural_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		ural_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
ural_next_scan(void *arg)
{
	struct ural_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);

	usbd_ref_decr(sc->sc_udev);
}

void
ural_task(void *arg)
{
	struct ural_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	enum ieee80211_state ostate;
	struct ieee80211_node *ni;

	if (usbd_is_dying(sc->sc_udev))
		return;

	ostate = ic->ic_state;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* abort TSF synchronization */
			ural_write(sc, RAL_TXRX_CSR19, 0);

			/* force tx led to stop blinking */
			ural_write(sc, RAL_MAC_CSR20, 0);
		}
		break;

	case IEEE80211_S_SCAN:
		ural_set_chan(sc, ic->ic_bss->ni_chan);
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
		ural_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_ASSOC:
		ural_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		ural_set_chan(sc, ic->ic_bss->ni_chan);

		ni = ic->ic_bss;

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			ural_update_slot(sc);
			ural_set_txpreamble(sc);
			ural_set_basicrates(sc);
			ural_set_bssid(sc, ni->ni_bssid);
		}

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS) {
			struct mbuf *m = ieee80211_beacon_alloc(ic, ni);
			if (m == NULL) {
				printf("%s: could not allocate beacon\n",
				    sc->sc_dev.dv_xname);
				return;
			}

			if (ural_tx_bcn(sc, m, ni) != 0) {
				m_freem(m);
				printf("%s: could not transmit beacon\n",
				    sc->sc_dev.dv_xname);
				return;
			}

			/* beacon is no longer needed */
			m_freem(m);
		}
#endif

		/* make tx led blink on tx (controlled by ASIC) */
		ural_write(sc, RAL_MAC_CSR20, 1);

		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			ural_enable_tsf_sync(sc);

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			ural_newassoc(ic, ic->ic_bss, 1);

			/* enable automatic rate control in STA mode */
			if (ic->ic_fixed_rate == -1)
				ural_amrr_start(sc, ic->ic_bss);
		}

		break;
	}

	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);
}

int
ural_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct ural_softc *sc = ic->ic_if.if_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task);
	return 0;
}

/* quickly determine if a given rate is CCK or OFDM */
#define RAL_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

#define RAL_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RAL_CTS_SIZE	14	/* 10 + 4(FCS) */

#define RAL_SIFS		10	/* us */

#define RAL_RXTX_TURNAROUND	5	/* us */

void
ural_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ural_tx_data *data = priv;
	struct ural_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_tx_pipeh);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->tx_queued--;

	DPRINTFN(10, ("tx done\n"));

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	ural_start(ifp);

	splx(s);
}

void
ural_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct ural_rx_data *data = priv;
	struct ural_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	const struct ural_rx_desc *desc;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *mnew, *m;
	int s, len;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_rx_pipeh);
		goto skip;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (len < RAL_RX_DESC_SIZE + IEEE80211_MIN_LEN) {
		DPRINTF(("%s: xfer too short %d\n", sc->sc_dev.dv_xname,
		    len));
		ifp->if_ierrors++;
		goto skip;
	}

	/* rx descriptor is located at the end */
	desc = (struct ural_rx_desc *)(data->buf + len - RAL_RX_DESC_SIZE);

	if (letoh32(desc->flags) & (RAL_RX_PHY_ERROR | RAL_RX_CRC_ERROR)) {
		/*
		 * This should not happen since we did not request to receive
		 * those frames when we filled RAL_TXRX_CSR2.
		 */
		DPRINTFN(5, ("PHY or CRC error\n"));
		ifp->if_ierrors++;
		goto skip;
	}

	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		goto skip;
	}
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		m_freem(mnew);
		ifp->if_ierrors++;
		goto skip;
	}
	m = data->m;
	data->m = mnew;
	data->buf = mtod(data->m, uint8_t *);

	/* finalize mbuf */
	m->m_pkthdr.len = m->m_len = (letoh32(desc->flags) >> 16) & 0xfff;

	s = splnet();

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct ural_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = IEEE80211_RADIOTAP_F_FCS;
		tap->wr_rate = ural_rxrate(desc);
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wr_antenna = sc->rx_ant;
		tap->wr_antsignal = desc->rssi;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif
	m_adj(m, -IEEE80211_CRC_LEN);	/* trim FCS */

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* send the frame to the 802.11 layer */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = desc->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);

	splx(s);

	DPRINTFN(15, ("rx done\n"));

skip:	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->sc_rx_pipeh, data, data->buf, MCLBYTES,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, ural_rxeof);
	(void)usbd_transfer(xfer);
}

/*
 * This function is only used by the Rx radiotap code. It returns the rate at
 * which a given frame was received.
 */
#if NBPFILTER > 0
uint8_t
ural_rxrate(const struct ural_rx_desc *desc)
{
	if (letoh32(desc->flags) & RAL_RX_OFDM) {
		/* reverse function of ural_plcp_signal */
		switch (desc->rate) {
		case 0xb:	return 12;
		case 0xf:	return 18;
		case 0xa:	return 24;
		case 0xe:	return 36;
		case 0x9:	return 48;
		case 0xd:	return 72;
		case 0x8:	return 96;
		case 0xc:	return 108;
		}
	} else {
		if (desc->rate == 10)
			return 2;
		if (desc->rate == 20)
			return 4;
		if (desc->rate == 55)
			return 11;
		if (desc->rate == 110)
			return 22;
	}
	return 2;	/* should not get there */
}
#endif

/*
 * Return the expected ack rate for a frame transmitted at rate `rate'.
 */
int
ural_ack_rate(struct ieee80211com *ic, int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:
		return 2;
	case 4:
	case 11:
	case 22:
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;

	/* OFDM rates */
	case 12:
	case 18:
		return 12;
	case 24:
	case 36:
		return 24;
	case 48:
	case 72:
	case 96:
	case 108:
		return 48;
	}

	/* default to 1Mbps */
	return 2;
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
ural_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (RAL_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11g-2003, pp. 44 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}
	return txtime;
}

uint8_t
ural_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}

void
ural_setup_tx_desc(struct ural_softc *sc, struct ural_tx_desc *desc,
    uint32_t flags, int len, int rate)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t plcp_length;
	int remainder;

	desc->flags = htole32(flags);
	desc->flags |= htole32(len << 16);

	desc->wme = htole16(
	    RAL_AIFSN(2) |
	    RAL_LOGCWMIN(3) |
	    RAL_LOGCWMAX(5));

	/* setup PLCP fields */
	desc->plcp_signal  = ural_plcp_signal(rate);
	desc->plcp_service = 4;

	len += IEEE80211_CRC_LEN;
	if (RAL_RATE_IS_OFDM(rate)) {
		desc->flags |= htole32(RAL_TX_OFDM);

		plcp_length = len & 0xfff;
		desc->plcp_length_hi = plcp_length >> 6;
		desc->plcp_length_lo = plcp_length & 0x3f;
	} else {
		plcp_length = (16 * len + rate - 1) / rate;
		if (rate == 22) {
			remainder = (16 * len) % 22;
			if (remainder != 0 && remainder < 7)
				desc->plcp_service |= RAL_PLCP_LENGEXT;
		}
		desc->plcp_length_hi = plcp_length >> 8;
		desc->plcp_length_lo = plcp_length & 0xff;

		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			desc->plcp_signal |= 0x08;
	}

	desc->iv = 0;
	desc->eiv = 0;
}

#define RAL_TX_TIMEOUT	5000

#ifndef IEEE80211_STA_ONLY
int
ural_tx_bcn(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ural_tx_desc *desc;
	struct usbd_xfer *xfer;
	usbd_status error;
	uint8_t cmd = 0;
	uint8_t *buf;
	int xferlen, rate = 2;

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return ENOMEM;

	/* xfer length needs to be a multiple of two! */
	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	buf = usbd_alloc_buffer(xfer, xferlen);
	if (buf == NULL) {
		usbd_free_xfer(xfer);
		return ENOMEM;
	}

	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, &cmd, sizeof cmd,
	    USBD_FORCE_SHORT_XFER | USBD_SYNCHRONOUS, RAL_TX_TIMEOUT, NULL);

	error = usbd_transfer(xfer);
	if (error != 0) {
		usbd_free_xfer(xfer);
		return error;
	}

	desc = (struct ural_tx_desc *)buf;

	m_copydata(m0, 0, m0->m_pkthdr.len, buf + RAL_TX_DESC_SIZE);
	ural_setup_tx_desc(sc, desc, RAL_TX_IFS_NEWBACKOFF | RAL_TX_TIMESTAMP,
	    m0->m_pkthdr.len, rate);

	DPRINTFN(10, ("sending beacon frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY | USBD_SYNCHRONOUS,
	    RAL_TX_TIMEOUT, NULL);

	error = usbd_transfer(xfer);
	usbd_free_xfer(xfer);

	return error;
}
#endif

int
ural_tx_data(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ural_tx_desc *desc;
	struct ural_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	uint32_t flags = RAL_TX_NEWSEQ;
	uint16_t dur;
	usbd_status error;
	int rate, xferlen, pktlen, needrts = 0, needcts = 0;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

	/* compute actual packet length (including CRC and crypto overhead) */
	pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	if (rate == 0)
		rate = 2;	/* XXX should not happen */
	rate &= IEEE80211_RATE_VAL;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (pktlen > ic->ic_rtsthreshold) {
			needrts = 1;	/* RTS/CTS based on frame length */
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    RAL_RATE_IS_OFDM(rate)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				needcts = 1;	/* CTS-to-self */
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				needrts = 1;	/* RTS/CTS */
		}
	}
	if (needrts || needcts) {
		struct mbuf *mprot;
		int protrate, ackrate;
		uint16_t dur;

		protrate = 2;
		ackrate  = ural_ack_rate(ic, rate);

		dur = ural_txtime(pktlen, rate, ic->ic_flags) +
		      ural_txtime(RAL_ACK_SIZE, ackrate, ic->ic_flags) +
		      2 * RAL_SIFS;
		if (needrts) {
			dur += ural_txtime(RAL_CTS_SIZE, ural_ack_rate(ic,
			    protrate), ic->ic_flags) + RAL_SIFS;
			mprot = ieee80211_get_rts(ic, wh, dur);
		} else {
			mprot = ieee80211_get_cts_to_self(ic, dur);
		}
		if (mprot == NULL) {
			printf("%s: could not allocate protection frame\n",
			    sc->sc_dev.dv_xname);
			m_freem(m0);
			return ENOBUFS;
		}

		data = &sc->tx_data[sc->tx_cur];
		desc = (struct ural_tx_desc *)data->buf;

		/* avoid multiple free() of the same node for each fragment */
		data->ni = ieee80211_ref_node(ni);

		m_copydata(mprot, 0, mprot->m_pkthdr.len,
		    data->buf + RAL_TX_DESC_SIZE);
		ural_setup_tx_desc(sc, desc,
		    (needrts ? RAL_TX_NEED_ACK : 0) | RAL_TX_RETRY(7),
		    mprot->m_pkthdr.len, protrate);

		/* no roundup necessary here */
		xferlen = RAL_TX_DESC_SIZE + mprot->m_pkthdr.len;

		/* XXX may want to pass the protection frame to BPF */

		/* mbuf is no longer needed */
		m_freem(mprot);

		usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
		    xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
		    RAL_TX_TIMEOUT, ural_txeof);
		error = usbd_transfer(data->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS) {
			m_freem(m0);
			return error;
		}

		sc->tx_queued++;
		sc->tx_cur = (sc->tx_cur + 1) % RAL_TX_LIST_COUNT;

		flags |= RAL_TX_IFS_SIFS;
	}

	data = &sc->tx_data[sc->tx_cur];
	desc = (struct ural_tx_desc *)data->buf;

	data->ni = ni;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RAL_TX_NEED_ACK;
		flags |= RAL_TX_RETRY(7);

		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(ic, rate),
		    ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);

#ifndef IEEE80211_STA_ONLY
		/* tell hardware to set timestamp in probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RAL_TX_TIMESTAMP;
#endif
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct ural_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RAL_TX_DESC_SIZE);
	ural_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);

	/* align end on a 2-bytes boundary */
	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	/*
	 * No space left in the last URB to store the extra 2 bytes, force
	 * sending of another URB.
	 */
	if ((xferlen % 64) == 0)
		xferlen += 2;

	DPRINTFN(10, ("sending frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));

	/* mbuf is no longer needed */
	m_freem(m0);

	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT, ural_txeof);
	error = usbd_transfer(data->xfer);
	if (error != 0 && error != USBD_IN_PROGRESS)
		return error;

	sc->tx_queued++;
	sc->tx_cur = (sc->tx_cur + 1) % RAL_TX_LIST_COUNT;

	return 0;
}

void
ural_start(struct ifnet *ifp)
{
	struct ural_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m0;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->tx_queued >= RAL_TX_LIST_COUNT - 1) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (ural_tx_data(sc, m0, ni) != 0)
				break;

		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (ural_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
ural_watchdog(struct ifnet *ifp)
{
	struct ural_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/*ural_init(ifp); XXX needs a process context! */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
ural_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct ural_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				ural_update_promisc(sc);
			else
				ural_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				ural_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				ural_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			ural_init(ifp);
		error = 0;
	}

	splx(s);

	usbd_ref_decr(sc->sc_udev);

	return error;
}

void
ural_eeprom_read(struct ural_softc *sc, uint16_t addr, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RAL_READ_EEPROM;
	USETW(req.wValue, 0);
	USETW(req.wIndex, addr);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not read EEPROM: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

uint16_t
ural_read(struct ural_softc *sc, uint16_t reg)
{
	usb_device_request_t req;
	usbd_status error;
	uint16_t val;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RAL_READ_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, sizeof (uint16_t));

	error = usbd_do_request(sc->sc_udev, &req, &val);
	if (error != 0) {
		printf("%s: could not read MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		return 0;
	}
	return letoh16(val);
}

void
ural_read_multi(struct ural_softc *sc, uint16_t reg, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RAL_READ_MULTI_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not read MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

void
ural_write(struct ural_softc *sc, uint16_t reg, uint16_t val)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RAL_WRITE_MAC;
	USETW(req.wValue, val);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 0);

	error = usbd_do_request(sc->sc_udev, &req, NULL);
	if (error != 0) {
		printf("%s: could not write MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

void
ural_write_multi(struct ural_softc *sc, uint16_t reg, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RAL_WRITE_MULTI_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not write MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

void
ural_bbp_write(struct ural_softc *sc, uint8_t reg, uint8_t val)
{
	uint16_t tmp;
	int ntries;

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(ural_read(sc, RAL_PHY_CSR8) & RAL_BBP_BUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not write to BBP\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = reg << 8 | val;
	ural_write(sc, RAL_PHY_CSR7, tmp);
}

uint8_t
ural_bbp_read(struct ural_softc *sc, uint8_t reg)
{
	uint16_t val;
	int ntries;

	val = RAL_BBP_WRITE | reg << 8;
	ural_write(sc, RAL_PHY_CSR7, val);

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(ural_read(sc, RAL_PHY_CSR8) & RAL_BBP_BUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not read BBP\n", sc->sc_dev.dv_xname);
		return 0;
	}
	return ural_read(sc, RAL_PHY_CSR7) & 0xff;
}

void
ural_rf_write(struct ural_softc *sc, uint8_t reg, uint32_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(ural_read(sc, RAL_PHY_CSR10) & RAL_RF_LOBUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RAL_RF_BUSY | RAL_RF_20BIT | (val & 0xfffff) << 2 | (reg & 0x3);
	ural_write(sc, RAL_PHY_CSR9,  tmp & 0xffff);
	ural_write(sc, RAL_PHY_CSR10, tmp >> 16);

	/* remember last written value in sc */
	sc->rf_regs[reg] = val;

	DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 0x3, val & 0xfffff));
}

void
ural_set_chan(struct ural_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t power, tmp;
	u_int chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	power = min(sc->txpow[chan - 1], 31);

	DPRINTFN(2, ("setting channel to %u, txpower to %u\n", chan, power));

	switch (sc->rf_rev) {
	case RAL_RF_2522:
		ural_rf_write(sc, RAL_RF1, 0x00814);
		ural_rf_write(sc, RAL_RF2, ural_rf2522_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
		break;

	case RAL_RF_2523:
		ural_rf_write(sc, RAL_RF1, 0x08804);
		ural_rf_write(sc, RAL_RF2, ural_rf2523_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x38044);
		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RAL_RF_2524:
		ural_rf_write(sc, RAL_RF1, 0x0c808);
		ural_rf_write(sc, RAL_RF2, ural_rf2524_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RAL_RF_2525:
		ural_rf_write(sc, RAL_RF1, 0x08808);
		ural_rf_write(sc, RAL_RF2, ural_rf2525_hi_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);

		ural_rf_write(sc, RAL_RF1, 0x08808);
		ural_rf_write(sc, RAL_RF2, ural_rf2525_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00280 : 0x00286);
		break;

	case RAL_RF_2525E:
		ural_rf_write(sc, RAL_RF1, 0x08808);
		ural_rf_write(sc, RAL_RF2, ural_rf2525e_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
		ural_rf_write(sc, RAL_RF4, (chan == 14) ? 0x00286 : 0x00282);
		break;

	case RAL_RF_2526:
		ural_rf_write(sc, RAL_RF2, ural_rf2526_hi_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF4, (chan & 1) ? 0x00386 : 0x00381);
		ural_rf_write(sc, RAL_RF1, 0x08804);

		ural_rf_write(sc, RAL_RF2, ural_rf2526_r2[chan - 1]);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x18044);
		ural_rf_write(sc, RAL_RF4, (chan & 1) ? 0x00386 : 0x00381);
		break;
	}

	if (ic->ic_opmode != IEEE80211_M_MONITOR &&
	    ic->ic_state != IEEE80211_S_SCAN) {
		/* set Japan filter bit for channel 14 */
		tmp = ural_bbp_read(sc, 70);

		tmp &= ~RAL_JAPAN_FILTER;
		if (chan == 14)
			tmp |= RAL_JAPAN_FILTER;

		ural_bbp_write(sc, 70, tmp);

		/* clear CRC errors */
		ural_read(sc, RAL_STA_CSR0);

		DELAY(1000); /* RF needs a 1ms delay here */
		ural_disable_rf_tune(sc);
	}
}

/*
 * Disable RF auto-tuning.
 */
void
ural_disable_rf_tune(struct ural_softc *sc)
{
	uint32_t tmp;

	if (sc->rf_rev != RAL_RF_2523) {
		tmp = sc->rf_regs[RAL_RF1] & ~RAL_RF1_AUTOTUNE;
		ural_rf_write(sc, RAL_RF1, tmp);
	}

	tmp = sc->rf_regs[RAL_RF3] & ~RAL_RF3_AUTOTUNE;
	ural_rf_write(sc, RAL_RF3, tmp);

	DPRINTFN(2, ("disabling RF autotune\n"));
}

/*
 * Refer to IEEE Std 802.11-1999 pp. 123 for more information on TSF
 * synchronization.
 */
void
ural_enable_tsf_sync(struct ural_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t logcwmin, preload, tmp;

	/* first, disable TSF synchronization */
	ural_write(sc, RAL_TXRX_CSR19, 0);

	tmp = (16 * ic->ic_bss->ni_intval) << 4;
	ural_write(sc, RAL_TXRX_CSR18, tmp);

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode == IEEE80211_M_IBSS) {
		logcwmin = 2;
		preload = 320;
	} else
#endif
	{
		logcwmin = 0;
		preload = 6;
	}
	tmp = logcwmin << 12 | preload;
	ural_write(sc, RAL_TXRX_CSR20, tmp);

	/* finally, enable TSF synchronization */
	tmp = RAL_ENABLE_TSF | RAL_ENABLE_TBCN;
	if (ic->ic_opmode == IEEE80211_M_STA)
		tmp |= RAL_ENABLE_TSF_SYNC(1);
#ifndef IEEE80211_STA_ONLY
	else
		tmp |= RAL_ENABLE_TSF_SYNC(2) | RAL_ENABLE_BEACON_GENERATOR;
#endif
	ural_write(sc, RAL_TXRX_CSR19, tmp);

	DPRINTF(("enabling TSF synchronization\n"));
}

void
ural_update_slot(struct ural_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t slottime, sifs, eifs;

	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;

	/*
	 * These settings may sound a bit inconsistent but this is what the
	 * reference driver does.
	 */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		sifs = 16 - RAL_RXTX_TURNAROUND;
		eifs = 364;
	} else {
		sifs = 10 - RAL_RXTX_TURNAROUND;
		eifs = 64;
	}

	ural_write(sc, RAL_MAC_CSR10, slottime);
	ural_write(sc, RAL_MAC_CSR11, sifs);
	ural_write(sc, RAL_MAC_CSR12, eifs);
}

void
ural_set_txpreamble(struct ural_softc *sc)
{
	uint16_t tmp;

	tmp = ural_read(sc, RAL_TXRX_CSR10);

	tmp &= ~RAL_SHORT_PREAMBLE;
	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
		tmp |= RAL_SHORT_PREAMBLE;

	ural_write(sc, RAL_TXRX_CSR10, tmp);
}

void
ural_set_basicrates(struct ural_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* update basic rate set */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		/* 11b basic rates: 1, 2Mbps */
		ural_write(sc, RAL_TXRX_CSR11, 0x3);
	} else {
		/* 11b/g basic rates: 1, 2, 5.5, 11Mbps */
		ural_write(sc, RAL_TXRX_CSR11, 0xf);
	}
}

void
ural_set_bssid(struct ural_softc *sc, const uint8_t *bssid)
{
	uint16_t tmp;

	tmp = bssid[0] | bssid[1] << 8;
	ural_write(sc, RAL_MAC_CSR5, tmp);

	tmp = bssid[2] | bssid[3] << 8;
	ural_write(sc, RAL_MAC_CSR6, tmp);

	tmp = bssid[4] | bssid[5] << 8;
	ural_write(sc, RAL_MAC_CSR7, tmp);

	DPRINTF(("setting BSSID to %s\n", ether_sprintf((uint8_t *)bssid)));
}

void
ural_set_macaddr(struct ural_softc *sc, const uint8_t *addr)
{
	uint16_t tmp;

	tmp = addr[0] | addr[1] << 8;
	ural_write(sc, RAL_MAC_CSR2, tmp);

	tmp = addr[2] | addr[3] << 8;
	ural_write(sc, RAL_MAC_CSR3, tmp);

	tmp = addr[4] | addr[5] << 8;
	ural_write(sc, RAL_MAC_CSR4, tmp);

	DPRINTF(("setting MAC address to %s\n",
	    ether_sprintf((uint8_t *)addr)));
}

void
ural_update_promisc(struct ural_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint16_t tmp;

	tmp = ural_read(sc, RAL_TXRX_CSR2);

	tmp &= ~RAL_DROP_NOT_TO_ME;
	if (!(ifp->if_flags & IFF_PROMISC))
		tmp |= RAL_DROP_NOT_TO_ME;

	ural_write(sc, RAL_TXRX_CSR2, tmp);

	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
	    "entering" : "leaving"));
}

const char *
ural_get_rf(int rev)
{
	switch (rev) {
	case RAL_RF_2522:	return "RT2522";
	case RAL_RF_2523:	return "RT2523";
	case RAL_RF_2524:	return "RT2524";
	case RAL_RF_2525:	return "RT2525";
	case RAL_RF_2525E:	return "RT2525e";
	case RAL_RF_2526:	return "RT2526";
	case RAL_RF_5222:	return "RT5222";
	default:		return "unknown";
	}
}

void
ural_read_eeprom(struct ural_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t val;

	/* retrieve MAC/BBP type */
	ural_eeprom_read(sc, RAL_EEPROM_MACBBP, &val, 2);
	sc->macbbp_rev = letoh16(val);

	ural_eeprom_read(sc, RAL_EEPROM_CONFIG0, &val, 2);
	val = letoh16(val);
	sc->rf_rev =   (val >> 11) & 0x7;
	sc->hw_radio = (val >> 10) & 0x1;
	sc->led_mode = (val >> 6)  & 0x7;
	sc->rx_ant =   (val >> 4)  & 0x3;
	sc->tx_ant =   (val >> 2)  & 0x3;
	sc->nb_ant =   val & 0x3;

	/* read MAC address */
	ural_eeprom_read(sc, RAL_EEPROM_ADDRESS, ic->ic_myaddr, 6);

	/* read default values for BBP registers */
	ural_eeprom_read(sc, RAL_EEPROM_BBP_BASE, sc->bbp_prom, 2 * 16);

	/* read Tx power for all b/g channels */
	ural_eeprom_read(sc, RAL_EEPROM_TXPOWER, sc->txpow, 14);
}

int
ural_bbp_init(struct ural_softc *sc)
{
	int i, ntries;

	/* wait for BBP to be ready */
	for (ntries = 0; ntries < 100; ntries++) {
		if (ural_bbp_read(sc, RAL_BBP_VERSION) != 0)
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for BBP\n", sc->sc_dev.dv_xname);
		return EIO;
	}

	/* initialize BBP registers to default values */
	for (i = 0; i < nitems(ural_def_bbp); i++)
		ural_bbp_write(sc, ural_def_bbp[i].reg, ural_def_bbp[i].val);

#if 0
	/* initialize BBP registers to values stored in EEPROM */
	for (i = 0; i < 16; i++) {
		if (sc->bbp_prom[i].reg == 0xff)
			continue;
		ural_bbp_write(sc, sc->bbp_prom[i].reg, sc->bbp_prom[i].val);
	}
#endif

	return 0;
}

void
ural_set_txantenna(struct ural_softc *sc, int antenna)
{
	uint16_t tmp;
	uint8_t tx;

	tx = ural_bbp_read(sc, RAL_BBP_TX) & ~RAL_BBP_ANTMASK;
	if (antenna == 1)
		tx |= RAL_BBP_ANTA;
	else if (antenna == 2)
		tx |= RAL_BBP_ANTB;
	else
		tx |= RAL_BBP_DIVERSITY;

	/* need to force I/Q flip for RF 2525e, 2526 and 5222 */
	if (sc->rf_rev == RAL_RF_2525E || sc->rf_rev == RAL_RF_2526 ||
	    sc->rf_rev == RAL_RF_5222)
		tx |= RAL_BBP_FLIPIQ;

	ural_bbp_write(sc, RAL_BBP_TX, tx);

	/* update flags in PHY_CSR5 and PHY_CSR6 too */
	tmp = ural_read(sc, RAL_PHY_CSR5) & ~0x7;
	ural_write(sc, RAL_PHY_CSR5, tmp | (tx & 0x7));

	tmp = ural_read(sc, RAL_PHY_CSR6) & ~0x7;
	ural_write(sc, RAL_PHY_CSR6, tmp | (tx & 0x7));
}

void
ural_set_rxantenna(struct ural_softc *sc, int antenna)
{
	uint8_t rx;

	rx = ural_bbp_read(sc, RAL_BBP_RX) & ~RAL_BBP_ANTMASK;
	if (antenna == 1)
		rx |= RAL_BBP_ANTA;
	else if (antenna == 2)
		rx |= RAL_BBP_ANTB;
	else
		rx |= RAL_BBP_DIVERSITY;

	/* need to force no I/Q flip for RF 2525e and 2526 */
	if (sc->rf_rev == RAL_RF_2525E || sc->rf_rev == RAL_RF_2526)
		rx &= ~RAL_BBP_FLIPIQ;

	ural_bbp_write(sc, RAL_BBP_RX, rx);
}

int
ural_init(struct ifnet *ifp)
{
	struct ural_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t tmp;
	usbd_status error;
	int i, ntries;

	ural_stop(ifp, 0);

	/* initialize MAC registers to default values */
	for (i = 0; i < nitems(ural_def_mac); i++)
		ural_write(sc, ural_def_mac[i].reg, ural_def_mac[i].val);

	/* wait for BBP and RF to wake up (this can take a long time!) */
	for (ntries = 0; ntries < 100; ntries++) {
		tmp = ural_read(sc, RAL_MAC_CSR17);
		if ((tmp & (RAL_BBP_AWAKE | RAL_RF_AWAKE)) ==
		    (RAL_BBP_AWAKE | RAL_RF_AWAKE))
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for BBP/RF to wakeup\n",
		    sc->sc_dev.dv_xname);
		error = EIO;
		goto fail;
	}

	/* we're ready! */
	ural_write(sc, RAL_MAC_CSR1, RAL_HOST_READY);

	/* set basic rate set (will be updated later) */
	ural_write(sc, RAL_TXRX_CSR11, 0x153);

	error = ural_bbp_init(sc);
	if (error != 0)
		goto fail;

	/* set default BSS channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	ural_set_chan(sc, ic->ic_bss->ni_chan);

	/* clear statistic registers (STA_CSR0 to STA_CSR10) */
	ural_read_multi(sc, RAL_STA_CSR0, sc->sta, sizeof sc->sta);

	/* set default sensitivity */
	ural_bbp_write(sc, 17, 0x48);

	ural_set_txantenna(sc, 1);
	ural_set_rxantenna(sc, 1);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	ural_set_macaddr(sc, ic->ic_myaddr);

	/*
	 * Copy WEP keys into adapter's memory (SEC_CSR0 to SEC_CSR31).
	 */
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		struct ieee80211_key *k = &ic->ic_nw_keys[i];
		ural_write_multi(sc, RAL_SEC_CSR0 + i * IEEE80211_KEYBUF_SIZE,
		    k->k_key, IEEE80211_KEYBUF_SIZE);
	}

	/*
	 * Allocate xfer for AMRR statistics requests.
	 */
	sc->amrr_xfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->amrr_xfer == NULL) {
		printf("%s: could not allocate AMRR xfer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Open Tx and Rx USB bulk pipes.
	 */
	error = usbd_open_pipe(sc->sc_iface, sc->sc_tx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_tx_pipeh);
	if (error != 0) {
		printf("%s: could not open Tx pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	error = usbd_open_pipe(sc->sc_iface, sc->sc_rx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_rx_pipeh);
	if (error != 0) {
		printf("%s: could not open Rx pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/*
	 * Allocate Tx and Rx xfer queues.
	 */
	error = ural_alloc_tx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Tx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	error = ural_alloc_rx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Rx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Start up the receive pipe.
	 */
	for (i = 0; i < RAL_RX_LIST_COUNT; i++) {
		struct ural_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->sc_rx_pipeh, data, data->buf,
		    MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, ural_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS) {
			printf("%s: could not queue Rx transfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	/* kick Rx */
	tmp = RAL_DROP_PHY_ERROR | RAL_DROP_CRC_ERROR;
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RAL_DROP_CTL | RAL_DROP_VERSION_ERROR;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
			tmp |= RAL_DROP_TODS;
		if (!(ifp->if_flags & IFF_PROMISC))
			tmp |= RAL_DROP_NOT_TO_ME;
	}
	ural_write(sc, RAL_TXRX_CSR2, tmp);

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;

fail:	ural_stop(ifp, 1);
	return error;
}

void
ural_stop(struct ifnet *ifp, int disable)
{
	struct ural_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	/* disable Rx */
	ural_write(sc, RAL_TXRX_CSR2, RAL_DISABLE_RX);

	/* reset ASIC and BBP (but won't reset MAC registers!) */
	ural_write(sc, RAL_MAC_CSR1, RAL_RESET_ASIC | RAL_RESET_BBP);
	ural_write(sc, RAL_MAC_CSR1, 0);

	if (sc->amrr_xfer != NULL) {
		usbd_free_xfer(sc->amrr_xfer);
		sc->amrr_xfer = NULL;
	}
	if (sc->sc_rx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_rx_pipeh);
		usbd_close_pipe(sc->sc_rx_pipeh);
		sc->sc_rx_pipeh = NULL;
	}
	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
		sc->sc_tx_pipeh = NULL;
	}

	ural_free_rx_list(sc);
	ural_free_tx_list(sc);
}

void
ural_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	/* start with lowest Tx rate */
	ni->ni_txrate = 0;
}

void
ural_amrr_start(struct ural_softc *sc, struct ieee80211_node *ni)
{
	int i;

	/* clear statistic registers (STA_CSR0 to STA_CSR10) */
	ural_read_multi(sc, RAL_STA_CSR0, sc->sta, sizeof sc->sta);

	ieee80211_amrr_node_init(&sc->amrr, &sc->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->amrr_to, 1);
}

void
ural_amrr_timeout(void *arg)
{
	struct ural_softc *sc = arg;
	usb_device_request_t req;
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	s = splusb();

	/*
	 * Asynchronously read statistic registers (cleared by read).
	 */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RAL_READ_MULTI_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, RAL_STA_CSR0);
	USETW(req.wLength, sizeof sc->sta);

	usbd_setup_default_xfer(sc->amrr_xfer, sc->sc_udev, sc,
	    USBD_DEFAULT_TIMEOUT, &req, sc->sta, sizeof sc->sta, 0,
	    ural_amrr_update);
	(void)usbd_transfer(sc->amrr_xfer);

	splx(s);

	usbd_ref_decr(sc->sc_udev);
}

void
ural_amrr_update(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct ural_softc *sc = (struct ural_softc *)priv;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: could not retrieve Tx statistics - cancelling "
		    "automatic rate control\n", sc->sc_dev.dv_xname);
		return;
	}

	/* count TX retry-fail as Tx errors */
	ifp->if_oerrors += letoh16(sc->sta[9]);

	sc->amn.amn_retrycnt =
	    letoh16(sc->sta[7]) +	/* TX one-retry ok count */
	    letoh16(sc->sta[8]) +	/* TX more-retry ok count */
	    letoh16(sc->sta[9]);	/* TX retry-fail count */

	sc->amn.amn_txcnt =
	    sc->amn.amn_retrycnt +
	    letoh16(sc->sta[6]);	/* TX no-retry ok count */

	ieee80211_amrr_choose(&sc->amrr, sc->sc_ic.ic_bss, &sc->amn);

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->amrr_to, 1);
}
@


1.141
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.140 2016/07/20 10:24:43 stsp Exp $	*/
a683 1
	ifp->if_opackets++;
@


1.140
log
@Unbreak ural(4), which had been dropping frames on Tx while
the IFF_RUNNING flag was set since last November (r1.138).
Apparently nobody is using this driver, except for martijn@@.
Fix tested by martijn@@ and myself.
ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.139 2016/04/13 11:03:37 mpi Exp $	*/
d199 1
a199 1
	if (uaa->iface != NULL)
a218 6

	if (usbd_set_config_no(sc->sc_udev, RAL_CONFIG_NO, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.139
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.138 2015/11/25 03:10:00 dlg Exp $	*/
d1234 1
a1234 1
	if ((ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
@


1.138
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.137 2015/11/24 13:45:06 mpi Exp $	*/
a312 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.137
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.136 2015/11/24 13:33:18 mpi Exp $	*/
d696 1
a696 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1235 1
a1235 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1240 1
a1240 1
			ifp->if_flags |= IFF_OACTIVE;
d2059 1
a2059 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2081 2
a2082 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.136
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.135 2015/11/13 10:36:29 mpi Exp $	*/
a43 1
#include <net/if_arp.h>
@


1.135
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.134 2015/11/04 12:12:00 dlg Exp $	*/
a46 1
#include <net/if_types.h>
@


1.134
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.133 2015/10/25 12:11:56 mpi Exp $	*/
d1241 5
a1247 6
			if (sc->tx_queued >= RAL_TX_LIST_COUNT - 1) {
				mq_requeue(&ic->ic_mgtq, m0);
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}

d1259 2
a1260 1
			IFQ_POLL(&ifp->if_snd, m0);
a1262 5
			if (sc->tx_queued >= RAL_TX_LIST_COUNT - 1) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.133
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.132 2015/03/14 03:38:49 jsg Exp $	*/
d1241 1
a1241 1
		IF_POLL(&ic->ic_mgtq, m0);
d1244 1
a1247 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.132
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.131 2015/02/10 23:25:46 mpi Exp $	*/
a1316 1
	struct ifaddr *ifa;
a1328 1
		ifa = (struct ifaddr *)data;
a1329 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.131
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.130 2014/12/22 02:28:52 tedu Exp $	*/
a37 1
#include <machine/bus.h>
@


1.130
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.129 2014/12/19 22:44:59 guenther Exp $	*/
a769 1
	m->m_pkthdr.rcvif = ifp;
@


1.129
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.128 2014/07/13 15:52:49 mpi Exp $	*/
a1333 1
#ifdef INET
a1335 1
#endif
@


1.128
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.127 2014/07/12 07:59:23 mpi Exp $	*/
d36 1
a38 1
#include <machine/endian.h>
@


1.127
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.126 2014/03/19 10:09:19 mpi Exp $	*/
a50 1
#include <netinet/in_systm.h>
a51 1
#include <netinet/ip.h>
@


1.126
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.125 2014/03/07 18:39:02 mpi Exp $	*/
d187 10
a196 15
int ural_match(struct device *, void *, void *); 
void ural_attach(struct device *, struct device *, void *); 
int ural_detach(struct device *, int); 
int ural_activate(struct device *, int); 

struct cfdriver ural_cd = { 
	NULL, "ural", DV_IFNET 
}; 

const struct cfattach ural_ca = { 
	sizeof(struct ural_softc), 
	ural_match, 
	ural_attach, 
	ural_detach, 
	ural_activate, 
a2216 14
}

int
ural_activate(struct device *self, int act)
{
	struct ural_softc *sc = (struct ural_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return 0;
@


1.125
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.124 2013/08/07 01:06:42 bluhm Exp $	*/
d1258 1
a1258 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.124
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.123 2013/04/15 09:23:01 mglocker Exp $	*/
a65 4

#ifdef USB_DEBUG
#define URAL_DEBUG
#endif
@


1.123
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.122 2013/04/12 12:58:39 mpi Exp $	*/
a51 1
#include <netinet/in_var.h>
@


1.122
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.121 2011/07/03 15:47:17 matthew Exp $	*/
d119 2
a120 2
void		ural_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		ural_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d166 1
a166 1
void		ural_amrr_update(usbd_xfer_handle, usbd_private_handle,
d678 1
a678 1
ural_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d718 1
a718 1
ural_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1001 1
a1001 1
	usbd_xfer_handle xfer;
d2200 1
a2200 1
ural_amrr_update(usbd_xfer_handle xfer, usbd_private_handle priv,
@


1.121
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.120 2011/01/25 20:03:35 jakemsr Exp $	*/
d1021 1
a1021 1
	    USBD_FORCE_SHORT_XFER, RAL_TX_TIMEOUT, NULL);
d1023 1
a1023 1
	error = usbd_sync_transfer(xfer);
d1039 2
a1040 1
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT, NULL);
d1042 1
a1042 1
	error = usbd_sync_transfer(xfer);
@


1.120
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.119 2010/12/30 05:22:51 jakemsr Exp $	*/
a2234 3
	case DVACT_ACTIVATE:
		break;

@


1.119
log
@* do not add timeouts if the driver is dying
* use usbd_ref_{incr,decr,wait} to not detach while another process/thread
  is using the driver
* s/usb_rem_task/usb_rem_wait_task/ in detach functions because detach
  doesn't always happen in the task thread; otherwise a task could be
  running while the driver detaches
* in detach functions, first delete pending timeouts, then wait for
  processes to be done with the driver before freeing resources

ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.118 2010/12/17 22:38:54 jasper Exp $	*/
a351 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
a395 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.118
log
@- use nitems()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.117 2010/12/06 04:41:39 jakemsr Exp $	*/
d366 9
a379 6
	usb_rem_task(sc->sc_udev, &sc->sc_task);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->amrr_to))
		timeout_del(&sc->amrr_to);

d553 5
d560 2
d572 3
d590 2
a591 1
		timeout_add_msec(&sc->scan_to, 200);
d1341 5
d1409 2
d2167 2
a2168 1
	timeout_add_sec(&sc->amrr_to, 1);
d2178 5
d2200 2
d2231 2
a2232 1
	timeout_add_sec(&sc->amrr_to, 1);
@


1.117
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.116 2010/10/27 17:51:11 jakemsr Exp $	*/
a1854 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1869 1
a1869 1
	for (i = 0; i < N(ural_def_bbp); i++)
a1881 1
#undef N
a1935 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1945 1
a1945 1
	for (i = 0; i < N(ural_def_mac); i++)
a2082 1
#undef N
@


1.116
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.115 2010/10/23 16:14:07 jakemsr Exp $	*/
d2212 2
d2219 1
@


1.115
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.114 2010/10/23 15:42:09 jakemsr Exp $	*/
d366 4
a369 2
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);
@


1.114
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.113 2010/08/27 17:08:01 jsg Exp $	*/
d370 4
a373 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);
@


1.113
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.112 2010/04/20 22:05:43 tedu Exp $	*/
d276 1
a276 1
	usb_init_task(&sc->sc_task, ural_task, sc);
@


1.112
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.111 2009/10/13 19:33:17 pirofti Exp $	*/
a324 1
	ifp->if_init = ural_init;
@


1.111
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.110 2009/07/10 07:47:38 blambert Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.110
log
@timeout_add -> timeout_add_msec

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.109 2008/10/15 19:12:18 blambert Exp $	*/
d196 1
a196 1
int ural_activate(struct device *, enum devact); 
d2208 1
a2208 1
ural_activate(struct device *self, enum devact act)
@


1.109
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.108 2008/08/27 10:34:24 damien Exp $	*/
d575 1
a575 1
		timeout_add(&sc->scan_to, hz / 5);
@


1.108
log
@pass FCS to radiotap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.107 2008/08/27 09:05:03 damien Exp $	*/
d2148 1
a2148 1
	timeout_add(&sc->amrr_to, hz);
d2204 1
a2204 1
	timeout_add(&sc->amrr_to, hz);
@


1.107
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.106 2008/08/14 16:02:24 damien Exp $	*/
a773 1
	m_adj(m, -IEEE80211_CRC_LEN);	/* trim FCS */
d782 1
a782 1
		tap->wr_flags = 0;
d798 1
@


1.106
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.105 2008/07/30 06:25:23 damien Exp $	*/
d130 1
d133 1
d300 2
a302 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
d304 1
a558 1
	struct mbuf *m;
d598 1
d601 1
a601 1
			m = ieee80211_beacon_alloc(ic, ni);
d618 1
d986 1
d1036 1
d1167 1
d1173 1
d1673 10
a1682 2
	logcwmin = (ic->ic_opmode == IEEE80211_M_IBSS) ? 2 : 0;
	preload = (ic->ic_opmode == IEEE80211_M_IBSS) ? 320 : 6;
d1690 1
d1693 1
d2063 1
d2065 1
@


1.105
log
@Free the correct buffer list on failure.

From Andrew Thompson at FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.104 2008/07/21 18:43:19 damien Exp $	*/
a805 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		ural_start(ifp);
@


1.104
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.103 2008/04/16 18:32:15 damien Exp $	*/
d495 1
a495 1
fail:	ural_free_tx_list(sc);
@


1.103
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.102 2007/10/11 18:33:14 deraadt Exp $	*/
d711 1
d799 4
a802 1
	ieee80211_input(ifp, m, ni, desc->rssi, 0);
@


1.102
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.101 2007/09/07 19:05:05 damien Exp $	*/
d304 2
a305 1
	    IEEE80211_C_WEP;		/* s/w WEP */
a1037 1
	struct ifnet *ifp = &ic->ic_if;
d1041 1
d1049 4
a1052 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.101
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.100 2007/07/18 18:10:31 damien Exp $	*/
a229 1
	char *devinfop;
a232 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.100
log
@replace the ieee80211_wepkey structure with a more generic ieee80211_key
one that can be used with other ciphers than WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.99 2007/06/14 10:11:15 mbalmer Exp $	*/
a33 1
#include <sys/malloc.h>
@


1.99
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.98 2007/06/12 16:26:36 mbalmer Exp $	*/
d1982 1
a1982 1
		struct ieee80211_wepkey *wk = &ic->ic_nw_keys[i];
d1984 1
a1984 1
		    wk->wk_key, IEEE80211_KEYBUF_SIZE);
@


1.98
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.97 2007/06/10 14:49:00 mbalmer Exp $	*/
d192 16
a207 1
USB_DECLARE_DRIVER_CLASS(ural, DV_IFNET);
@


1.97
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.96 2007/06/10 10:53:48 mbalmer Exp $	*/
d2179 1
a2179 1
ural_activate(device_ptr_t self, enum devact act)
@


1.96
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.95 2007/06/09 12:22:53 mbalmer Exp $	*/
d222 1
a222 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d227 1
a227 1
		    USBDEVNAME(sc->sc_dev));
d236 1
a236 1
		    USBDEVNAME(sc->sc_dev));
d250 1
a250 1
			    USBDEVNAME(sc->sc_dev), i);
d262 1
a262 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
d280 1
a280 1
	    USBDEVNAME(sc->sc_dev), sc->macbbp_rev, sc->asic_rev,
d317 1
a317 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d402 1
a402 1
			    USBDEVNAME(sc->sc_dev));
d410 1
a410 1
			    USBDEVNAME(sc->sc_dev));
d455 1
a455 1
			    USBDEVNAME(sc->sc_dev));
d461 1
a461 1
			    USBDEVNAME(sc->sc_dev));
d469 1
a469 1
			    USBDEVNAME(sc->sc_dev));
d476 1
a476 1
			    USBDEVNAME(sc->sc_dev));
d590 1
a590 1
				    USBDEVNAME(sc->sc_dev));
d597 1
a597 1
				    USBDEVNAME(sc->sc_dev));
d666 1
a666 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d717 1
a717 1
		DPRINTF(("%s: xfer too short %d\n", USBDEVNAME(sc->sc_dev),
d739 1
a739 1
		    USBDEVNAME(sc->sc_dev));
d746 1
a746 1
		    USBDEVNAME(sc->sc_dev));
d1288 1
a1288 1
			printf("%s: device timeout\n", USBDEVNAME(sc->sc_dev));
d1389 1
a1389 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1409 1
a1409 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1430 1
a1430 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1449 1
a1449 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1468 1
a1468 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1483 1
a1483 1
		printf("%s: could not write to BBP\n", USBDEVNAME(sc->sc_dev));
d1505 1
a1505 1
		printf("%s: could not read BBP\n", USBDEVNAME(sc->sc_dev));
d1522 1
a1522 1
		printf("%s: could not write to RF\n", USBDEVNAME(sc->sc_dev));
d1836 1
a1836 1
		printf("%s: timeout waiting for BBP\n", USBDEVNAME(sc->sc_dev));
d1932 1
a1932 1
		    USBDEVNAME(sc->sc_dev));
d1978 1
a1978 1
		    USBDEVNAME(sc->sc_dev));
d1989 1
a1989 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1996 1
a1996 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2006 1
a2006 1
		    USBDEVNAME(sc->sc_dev));
d2012 1
a2012 1
		    USBDEVNAME(sc->sc_dev));
d2027 1
a2027 1
			    USBDEVNAME(sc->sc_dev));
d2157 1
a2157 1
		    "automatic rate control\n", USBDEVNAME(sc->sc_dev));
@


1.95
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.94 2007/06/09 08:52:10 damien Exp $	*/
d342 1
a342 1
	    USBDEV(sc->sc_dev));
d382 1
a382 1
	    USBDEV(sc->sc_dev));
@


1.94
log
@re-indent prototypes after "Static" removal.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.93 2007/06/05 08:43:55 mbalmer Exp $	*/
a2185 1
		/*if_deactivate(&sc->sc_ic.ic_if);*/
@


1.93
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.92 2007/05/27 04:00:24 jsg Exp $	*/
d119 4
a122 6
int		ural_newstate(struct ieee80211com *,
			    enum ieee80211_state, int);
void		ural_txeof(usbd_xfer_handle, usbd_private_handle,
			    usbd_status);
void		ural_rxeof(usbd_xfer_handle, usbd_private_handle,
			    usbd_status);
d127 1
a127 1
uint16_t		ural_txtime(int, int, uint32_t);
d129 2
a130 2
void		ural_setup_tx_desc(struct ural_softc *,
			    struct ural_tx_desc *, uint32_t, int, int);
d132 1
a132 1
			    struct ieee80211_node *);
d134 1
a134 1
			    struct ieee80211_node *);
d138 3
a140 5
void		ural_eeprom_read(struct ural_softc *, uint16_t, void *,
			    int);
uint16_t		ural_read(struct ural_softc *, uint16_t);
void		ural_read_multi(struct ural_softc *, uint16_t, void *,
			    int);
d142 1
a142 2
void		ural_write_multi(struct ural_softc *, uint16_t, void *,
			    int);
d146 1
a146 2
void		ural_set_chan(struct ural_softc *,
			    struct ieee80211_channel *);
d162 3
a164 4
void		ural_newassoc(struct ieee80211com *,
			    struct ieee80211_node *, int);
void		ural_amrr_start(struct ural_softc *,
			    struct ieee80211_node *);
d167 1
a167 1
			    usbd_status status);
@


1.92
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.91 2007/05/21 06:10:43 jsg Exp $	*/
d112 8
a119 8
Static int		ural_alloc_tx_list(struct ural_softc *);
Static void		ural_free_tx_list(struct ural_softc *);
Static int		ural_alloc_rx_list(struct ural_softc *);
Static void		ural_free_rx_list(struct ural_softc *);
Static int		ural_media_change(struct ifnet *);
Static void		ural_next_scan(void *);
Static void		ural_task(void *);
Static int		ural_newstate(struct ieee80211com *,
d121 1
a121 1
Static void		ural_txeof(usbd_xfer_handle, usbd_private_handle,
d123 1
a123 1
Static void		ural_rxeof(usbd_xfer_handle, usbd_private_handle,
d126 1
a126 1
Static uint8_t		ural_rxrate(const struct ural_rx_desc *);
d128 4
a131 4
Static int		ural_ack_rate(struct ieee80211com *, int);
Static uint16_t		ural_txtime(int, int, uint32_t);
Static uint8_t		ural_plcp_signal(int);
Static void		ural_setup_tx_desc(struct ural_softc *,
d133 1
a133 1
Static int		ural_tx_bcn(struct ural_softc *, struct mbuf *,
d135 1
a135 1
Static int		ural_tx_data(struct ural_softc *, struct mbuf *,
d137 4
a140 4
Static void		ural_start(struct ifnet *);
Static void		ural_watchdog(struct ifnet *);
Static int		ural_ioctl(struct ifnet *, u_long, caddr_t);
Static void		ural_eeprom_read(struct ural_softc *, uint16_t, void *,
d142 2
a143 2
Static uint16_t		ural_read(struct ural_softc *, uint16_t);
Static void		ural_read_multi(struct ural_softc *, uint16_t, void *,
d145 2
a146 2
Static void		ural_write(struct ural_softc *, uint16_t, uint16_t);
Static void		ural_write_multi(struct ural_softc *, uint16_t, void *,
d148 4
a151 4
Static void		ural_bbp_write(struct ural_softc *, uint8_t, uint8_t);
Static uint8_t		ural_bbp_read(struct ural_softc *, uint8_t);
Static void		ural_rf_write(struct ural_softc *, uint8_t, uint32_t);
Static void		ural_set_chan(struct ural_softc *,
d153 16
a168 16
Static void		ural_disable_rf_tune(struct ural_softc *);
Static void		ural_enable_tsf_sync(struct ural_softc *);
Static void		ural_update_slot(struct ural_softc *);
Static void		ural_set_txpreamble(struct ural_softc *);
Static void		ural_set_basicrates(struct ural_softc *);
Static void		ural_set_bssid(struct ural_softc *, const uint8_t *);
Static void		ural_set_macaddr(struct ural_softc *, const uint8_t *);
Static void		ural_update_promisc(struct ural_softc *);
Static const char	*ural_get_rf(int);
Static void		ural_read_eeprom(struct ural_softc *);
Static int		ural_bbp_init(struct ural_softc *);
Static void		ural_set_txantenna(struct ural_softc *, int);
Static void		ural_set_rxantenna(struct ural_softc *, int);
Static int		ural_init(struct ifnet *);
Static void		ural_stop(struct ifnet *, int);
Static void		ural_newassoc(struct ieee80211com *,
d170 1
a170 1
Static void		ural_amrr_start(struct ural_softc *,
d172 2
a173 2
Static void		ural_amrr_timeout(void *);
Static void		ural_amrr_update(usbd_xfer_handle, usbd_private_handle,
d394 1
a394 1
Static int
d429 1
a429 1
Static void
d449 1
a449 1
Static int
d496 1
a496 1
Static void
d515 1
a515 1
Static int
d534 1
a534 1
Static void
d545 1
a545 1
Static void
d633 1
a633 1
Static int
d659 1
a659 1
Static void
d699 1
a699 1
Static void
d822 1
a822 1
Static uint8_t
d854 1
a854 1
Static int
d889 1
a889 1
Static uint16_t
d909 1
a909 1
Static uint8_t
d934 1
a934 1
Static void
d981 1
a981 1
Static int
d1031 1
a1031 1
Static int
d1218 1
a1218 1
Static void
d1286 1
a1286 1
Static void
d1306 1
a1306 1
Static int
d1381 1
a1381 1
Static void
d1400 1
a1400 1
Static uint16_t
d1422 1
a1422 1
Static void
d1441 1
a1441 1
Static void
d1460 1
a1460 1
Static void
d1479 1
a1479 1
Static void
d1498 1
a1498 1
Static uint8_t
d1518 1
a1518 1
Static void
d1543 1
a1543 1
Static void
d1631 1
a1631 1
Static void
d1651 1
a1651 1
Static void
d1679 1
a1679 1
Static void
d1704 1
a1704 1
Static void
d1718 1
a1718 1
Static void
d1733 1
a1733 1
Static void
d1750 1
a1750 1
Static void
d1768 1
a1768 1
Static void
d1786 1
a1786 1
Static const char *
d1801 1
a1801 1
Static void
d1830 1
a1830 1
Static int
d1864 1
a1864 1
Static void
d1893 1
a1893 1
Static void
d1913 1
a1913 1
Static int
d2065 1
a2065 1
Static void
d2103 1
a2103 1
Static void
d2110 1
a2110 1
Static void
d2129 1
a2129 1
Static void
d2155 1
a2155 1
Static void
d2185 1
a2185 1
Static int
@


1.91
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.90 2007/05/21 05:40:27 jsg Exp $	*/
d201 2
a202 1
USB_MATCH(ural)
d204 1
a204 1
	USB_MATCH_START(ural, uaa);
d213 2
a214 1
USB_ATTACH(ural)
d216 2
a217 1
	USB_ATTACH_START(ural, sc, uaa);
d229 1
a229 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d235 1
a235 1
		USB_ATTACH_ERROR_RETURN;
d244 1
a244 1
		USB_ATTACH_ERROR_RETURN;
d258 1
a258 1
			USB_ATTACH_ERROR_RETURN;
d270 1
a270 1
		USB_ATTACH_ERROR_RETURN;
a349 2

	USB_ATTACH_SUCCESS_RETURN;
d352 2
a353 1
USB_DETACH(ural)
d355 1
a355 1
	USB_DETACH_START(ural, sc);
@


1.90
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.89 2007/02/19 17:22:02 deraadt Exp $	*/
d1418 1
a1418 1
	return le16toh(val);
@


1.89
log
@do not do a curproc test for interrupt context, because it is plainly wrong.
this lets these work on macppc, for instance
diagnosed by kettenis, but damien is not around, so ok jsg and others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.88 2007/01/02 14:43:50 claudio Exp $	*/
d75 2
a76 2
#define DPRINTF(x)	do { if (ural_debug) logprintf x; } while (0)
#define DPRINTFN(n, x)	do { if (ural_debug >= (n)) logprintf x; } while (0)
@


1.88
log
@Don't use M_DUP_PKTHDR() in the driver bpf hook. Using M_DUP_PKTHDR() on a
static mbuf results in a mbuf tag memory leak. Same change as in rum(4).
OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.87 2006/12/07 17:32:19 damien Exp $	*/
d641 1
d644 1
a644 6
	if (curproc != NULL) {
		ural_task(sc);
	} else {
		/* do it in a process context */
		usb_add_task(sc->sc_udev, &sc->sc_task);
	}
@


1.87
log
@http://www.ralinktech.com/ domain name is for sale.
use official url instead: http://www.ralinktech.com.tw/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.86 2006/12/03 16:39:13 damien Exp $	*/
a783 1
		M_DUP_PKTHDR(&mb, m);
d787 3
a789 1
		mb.m_pkthdr.len += mb.m_len;
a1179 1
		M_DUP_PKTHDR(&mb, m0);
d1183 3
a1185 1
		mb.m_pkthdr.len += mb.m_len;
@


1.86
log
@fix handling of the SIOCS80211CHANNEL ioctl in monitor mode:
don't call xxx_set_chan() if the interface is not up&running.

patch from Steffen Schuetz (st dot sch at gmx dot net) with
minor modifications by me.

closes kernel/5313
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.85 2006/12/03 16:16:58 damien Exp $	*/
d22 1
a22 1
 * http://www.ralinktech.com/
@


1.85
log
@don't schedule a USB task in {ural,rum}_newstate() if we're called from
a process context. this avoids potential races in {ural,rum}_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.84 2006/11/26 11:14:22 deraadt Exp $	*/
d1359 3
a1361 1
			ural_set_chan(sc, ic->ic_ibss_chan);
@


1.84
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.83 2006/11/19 16:44:36 damien Exp $	*/
a640 1
	/* do it in a process context */
d643 6
a648 2
	usb_add_task(sc->sc_udev, &sc->sc_task);

@


1.83
log
@restore the workaround for rate==0 bug.
i removed it in my last commit because i thought it was gone.
looks like it's not the case.

pointed out by niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.82 2006/11/13 20:06:38 damien Exp $	*/
a175 9
/*
 * Supported rates for 802.11b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset ural_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset ural_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d303 2
a304 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ural_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ural_rateset_11g;
@


1.82
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.81 2006/10/22 12:27:56 damien Exp $	*/
d1077 2
@


1.81
log
@make sure ni->ni_txrate is always initialized to a meaningful value by
redefining ic->ic_newassoc.
this should prevent "bogus xmit rate" panics when operating in HostAP
mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.80 2006/09/18 16:20:20 damien Exp $	*/
d126 1
a126 1
Static uint8_t		ural_rxrate(struct ural_rx_desc *);
d158 2
a159 2
Static void		ural_set_bssid(struct ural_softc *, uint8_t *);
Static void		ural_set_macaddr(struct ural_softc *, uint8_t *);
d177 1
a177 1
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
a178 3
static const struct ieee80211_rateset ural_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

a207 7
static const struct {
	uint8_t		chan;
	uint32_t	r1, r2, r4;
} ural_rf5222[] = {
	RAL_RF5222
};

d281 1
a281 1
	timeout_set(&sc->scan_ch, ural_next_scan, sc);
d285 1
a285 1
	timeout_set(&sc->amrr_ch, ural_amrr_timeout, sc);
a310 22
	if (sc->rf_rev == RAL_RF_5222) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] = ural_rateset_11a;

		/* set supported .11a channels */
		for (i = 36; i <= 64; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 100; i <= 140; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 149; i <= 161; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
	}

d373 2
a374 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->amrr_ch);
a404 1
	struct ural_tx_data *data;
d407 1
a407 1
	sc->tx_queued = 0;
d410 1
a410 1
		data = &sc->tx_data[i];
a420 1

a439 1
	struct ural_tx_data *data;
d443 1
a443 1
		data = &sc->tx_data[i];
a448 1

a459 1
	struct ural_rx_data *data;
d463 1
a463 1
		data = &sc->rx_data[i];
a473 1

a487 1

a494 1

a506 1
	struct ural_rx_data *data;
d510 1
a510 1
		data = &sc->rx_data[i];
a515 1

d577 1
a577 1
		timeout_add(&sc->scan_ch, hz / 5);
d647 2
a648 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->amrr_ch);
a692 2
	m_freem(data->m);
	data->m = NULL;
d715 1
a715 1
	struct ural_rx_desc *desc;
a758 1

a766 1

d822 1
a822 1
	usbd_transfer(xfer);
d831 1
a831 1
ural_rxrate(struct ural_rx_desc *desc)
a860 1
 * XXX: this should depend on the destination node basic rate set.
a950 1
	desc->flags |= htole32(RAL_TX_NEWSEQ);
d997 1
a997 3
	int xferlen, rate;

	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
d1047 1
a1047 1
	uint32_t flags = 0;
d1050 1
a1050 1
	int xferlen, rate;
d1063 3
d1067 4
a1070 3
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT) {
		/* mgmt frames are sent at the lowest available bit-rate */
d1072 4
a1075 5
	} else {
		if (ic->ic_fixed_rate != -1) {
			rate = ic->ic_sup_rates[ic->ic_curmode].
			    rs_rates[ic->ic_fixed_rate];
		} else
d1077 73
a1150 3
	rate &= IEEE80211_RATE_VAL;
	if (rate == 0)
		rate = 2;	/* fallback to 1Mbps; should not happen  */
d1152 1
a1152 1
	data = &sc->tx_data[0];
a1154 1
	data->m = m0;
d1158 1
a1158 1
		flags |= RAL_TX_ACK;
d1208 3
a1212 1

d1214 1
a1214 2
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		m_freem(m0);
a1215 1
	}
d1218 1
d1241 1
a1241 1
			if (sc->tx_queued >= RAL_TX_LIST_COUNT) {
d1262 1
a1262 1
			if (sc->tx_queued >= RAL_TX_LIST_COUNT) {
a1421 1

a1517 1

d1551 1
a1551 1
	u_int i, chan;
d1557 1
a1557 4
	if (IEEE80211_IS_CHAN_2GHZ(c))
		power = min(sc->txpow[chan - 1], 31);
	else
		power = 31;
a1609 10

	/* dual-band RF */
	case RAL_RF_5222:
		for (i = 0; ural_rf5222[i].chan != chan; i++);

		ural_rf_write(sc, RAL_RF1, ural_rf5222[i].r1);
		ural_rf_write(sc, RAL_RF2, ural_rf5222[i].r2);
		ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
		ural_rf_write(sc, RAL_RF4, ural_rf5222[i].r4);
		break;
a1729 3
	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
		/* 11a basic rates: 6, 12, 24Mbps */
		ural_write(sc, RAL_TXRX_CSR11, 0x150);
d1731 2
a1732 2
		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
		ural_write(sc, RAL_TXRX_CSR11, 0x15f);
d1737 1
a1737 1
ural_set_bssid(struct ural_softc *sc, uint8_t *bssid)
d1750 1
a1750 1
	DPRINTF(("setting BSSID to %s\n", ether_sprintf(bssid)));
d1754 1
a1754 1
ural_set_macaddr(struct ural_softc *sc, uint8_t *addr)
d1767 2
a1768 1
	DPRINTF(("setting MAC address to %s\n", ether_sprintf(addr)));
a1921 2
	struct ieee80211_wepkey *wk;
	struct ural_rx_data *data;
d1977 1
a1977 1
		wk = &ic->ic_nw_keys[i];
a2001 1

a2018 1

d2030 1
a2030 1
		data = &sc->rx_data[i];
d2034 6
a2039 1
		usbd_transfer(data->xfer);
a2090 1

a2095 1

d2129 1
a2129 1
	timeout_add(&sc->amrr_ch, hz);
d2185 1
a2185 1
	timeout_add(&sc->amrr_ch, hz);
@


1.80
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.79 2006/08/24 19:32:21 damien Exp $	*/
d168 2
d367 1
d668 8
a675 4
		/* enable automatic rate adaptation in STA mode */
		if (ic->ic_opmode == IEEE80211_M_STA &&
		    ic->ic_fixed_rate == -1)
			ural_amrr_start(sc, ic->ic_bss);
d2099 7
@


1.79
log
@s/IEEE80211_MTU_MAX/IEEE80211_MAX_LEN/ in my previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.78 2006/08/23 21:37:04 niallo Exp $  */
d1229 1
a1229 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a1232 1
				IF_PREPEND(&ifp->if_snd, m0);
d1236 1
a1236 1

@


1.78
log
@- fall back to 1Mbps if tx rate is returned as zero.  avoids divide by zero.  should never happen, but sometimes it does on my amd64.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.77 2006/08/23 16:25:07 damien Exp $  */
d453 1
a453 1
		    RAL_TX_DESC_SIZE + IEEE80211_MTU_MAX);
@


1.77
log
@the maximum MTU allowed for IEEE802.11 is 2290 which is greater than
MCLBYTES (usually 2048).
allocate tx xfer buffers of IEEE80211_MTU_MAX instead of MCLBYTES.
rx buffers are still limited to MCLBYTES though.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.76 2006/08/23 08:06:49 jsg Exp $  */
d1119 2
@


1.76
log
@Add Nova Tech NV-902W, and mention another Zinwell ural(4) device.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.75 2006/08/18 16:04:56 damien Exp $  */
d453 1
a453 1
		    RAL_TX_DESC_SIZE + MCLBYTES);
@


1.75
log
@set of unrelated cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.74 2006/08/18 15:23:13 damien Exp $  */
d102 1
@


1.74
log
@fix a printf format string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.73 2006/08/18 15:18:24 damien Exp $  */
d304 2
a305 2
	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
d993 4
a996 1
	desc->wme = htole16(RAL_AIFSN(2) | RAL_LOGCWMIN(3) | RAL_LOGCWMAX(5));
d2114 1
a2114 1
	struct ural_softc *sc = (struct ural_softc *)arg;
@


1.73
log
@sync w/ rum(4):

- in ral_newstate(), save the "arg" parameter so we can pass it to the
  ieee80211_newstate() function in the usb task
- merge ral_tx_data() and ral_tx_mgt()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.72 2006/08/09 07:40:52 damien Exp $  */
d300 1
a300 1
	printf("%s: MAC/BBP RT%02x (rev 0x%02x), RF %s, address %s\n",
@


1.72
log
@fix endianness. this should give rate adaptation a better chance to work
on big endian architectures.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.71 2006/07/02 00:56:14 jsg Exp $  */
a133 2
Static int		ural_tx_mgt(struct ural_softc *, struct mbuf *,
			    struct ieee80211_node *);
d672 1
a672 1
	sc->sc_newstate(ic, sc->sc_state, -1);
d686 1
a1078 85
ural_tx_mgt(struct ural_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ural_tx_desc *desc;
	struct ural_tx_data *data;
	struct ieee80211_frame *wh;
	uint32_t flags = 0;
	uint16_t dur;
	usbd_status error;
	int xferlen, rate;

	data = &sc->tx_data[0];
	desc = (struct ural_tx_desc *)data->buf;

	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RAL_TX_ACK;

		dur = ural_txtime(RAL_ACK_SIZE, rate, ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);

		/* tell hardware to add timestamp for probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RAL_TX_TIMESTAMP;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct ural_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		M_DUP_PKTHDR(&mb, m0);
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_pkthdr.len += mb.m_len;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RAL_TX_DESC_SIZE);
	ural_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);

	/* align end on a 2-bytes boundary */
	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	/*
	 * No space left in the last URB to store the extra 2 bytes, force
	 * sending of another URB.
	 */
	if ((xferlen % 64) == 0)
		xferlen += 2;

	DPRINTFN(10, ("sending mgt frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT, ural_txeof);

	error = usbd_transfer(data->xfer);
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		m_freem(m0);
		return error;
	}

	sc->tx_queued++;

	return 0;
}

Static int
a1082 1
	struct ieee80211_rateset *rs;
a1090 13
	if (ic->ic_fixed_rate != -1) {
		if (ic->ic_curmode != IEEE80211_MODE_AUTO)
			rs = &ic->ic_sup_rates[ic->ic_curmode];
		else
			rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];

		rate = rs->rs_rates[ic->ic_fixed_rate];
	} else {
		rs = &ni->ni_rates;
		rate = rs->rs_rates[ni->ni_txrate];
	}
	rate &= IEEE80211_RATE_VAL;

d1102 14
d1129 6
d1170 1
a1170 1
	DPRINTFN(10, ("sending data frame len=%u rate=%u xfer len=%u\n",
d1217 1
a1217 1
			if (ural_tx_mgt(sc, m0, ni) != 0)
@


1.71
log
@Fix channel frequency/flags in radiotap structures.
Now I can see probes cycling 1->14 instead of just
sitting at channel 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.70 2006/06/23 06:27:11 miod Exp $  */
d2228 1
a2228 1
	ifp->if_oerrors += sc->sta[9];
d2231 3
a2233 3
	    sc->sta[7] +	/* TX one-retry ok count */
	    sc->sta[8] +	/* TX more-retry ok count */
	    sc->sta[9];		/* TX retry-fail count */
d2237 1
a2237 1
	    sc->sta[6];		/* TX no-retry ok count */
@


1.70
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.69 2006/06/17 19:07:19 damien Exp $  */
d824 2
a825 2
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1121 2
a1122 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1224 2
a1225 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
@


1.69
log
@Move AMRR rate control algorithm out of wpi(4) and ural(4), into net80211.

ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.68 2006/06/10 20:28:11 damien Exp $  */
d2249 1
a2249 1
		return EOPNOTSUPP;
@


1.68
log
@- fix checking of WEP flag
- move default MAC/BBP/RF settings from if_ral.c to if_ralreg.h
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.67 2006/03/25 22:41:47 djm Exp $  */
d59 1
a59 1
#include <net80211/ieee80211_rssadapt.h>
a173 2
Static void		ural_ratectl(struct ural_amrr *,
			    struct ieee80211_node *);
d291 3
d943 1
a943 1
		/* IEEE Std 802.11a-1999, pp. 37 */
a2168 3
#define URAL_AMRR_MIN_SUCCESS_THRESHOLD	 1
#define URAL_AMRR_MAX_SUCCESS_THRESHOLD	10

a2171 1
	struct ural_amrr *amrr = &sc->amrr;
d2177 1
a2177 4
	amrr->success = 0;
	amrr->recovery = 0;
	amrr->txcnt = amrr->retrycnt = 0;
	amrr->success_threshold = URAL_AMRR_MIN_SUCCESS_THRESHOLD;
a2182 1

a2218 1
	struct ural_amrr *amrr = &sc->amrr;
d2230 1
a2230 1
	amrr->retrycnt =
d2235 2
a2236 2
	amrr->txcnt =
	    amrr->retrycnt +
d2239 1
a2239 1
	ural_ratectl(amrr, sc->sc_ic.ic_bss);
a2241 67
}

/*-
 * Naive implementation of the Adaptive Multi Rate Retry algorithm:
 *     "IEEE 802.11 Rate Adaptation: A Practical Approach"
 *     Mathieu Lacage, Hossein Manshaei, Thierry Turletti
 *     INRIA Sophia - Projet Planete
 *     http://www-sop.inria.fr/rapports/sophia/RR-5208.html
 *
 * This algorithm is particularly well suited for ural since it does not
 * require per-frame retry statistics.  Note however that since h/w does
 * not provide per-frame stats, we can't do per-node rate adaptation and
 * thus automatic rate adaptation is only enabled in STA operating mode.
 */
#define is_success(amrr)	\
	((amrr)->retrycnt < (amrr)->txcnt / 10)
#define is_failure(amrr)	\
	((amrr)->retrycnt > (amrr)->txcnt / 3)
#define is_enough(amrr)		\
	((amrr)->txcnt > 10)
#define is_min_rate(ni)		\
	((ni)->ni_txrate == 0)
#define is_max_rate(ni)		\
	((ni)->ni_txrate == (ni)->ni_rates.rs_nrates - 1)
#define increase_rate(ni)	\
	((ni)->ni_txrate++)
#define decrease_rate(ni)	\
	((ni)->ni_txrate--)
#define reset_cnt(amrr)		\
	do { (amrr)->txcnt = (amrr)->retrycnt = 0; } while (0)
Static void
ural_ratectl(struct ural_amrr *amrr, struct ieee80211_node *ni)
{
	int need_change = 0;

	if (is_success(amrr) && is_enough(amrr)) {
		amrr->success++;
		if (amrr->success >= amrr->success_threshold &&
		    !is_max_rate(ni)) {
			amrr->recovery = 1;
			amrr->success = 0;
			increase_rate(ni);
			need_change = 1;
		} else {
			amrr->recovery = 0;
		}
	} else if (is_failure(amrr)) {
		amrr->success = 0;
		if (!is_min_rate(ni)) {
			if (amrr->recovery) {
				amrr->success_threshold *= 2;
				if (amrr->success_threshold >
				    URAL_AMRR_MAX_SUCCESS_THRESHOLD)
					amrr->success_threshold =
					    URAL_AMRR_MAX_SUCCESS_THRESHOLD;
			} else {
				amrr->success_threshold =
				    URAL_AMRR_MIN_SUCCESS_THRESHOLD;
			}
			decrease_rate(ni);
			need_change = 1;
		}
		amrr->recovery = 0;	/* original paper was incorrect */
	}

	if (is_enough(amrr) || need_change)
		reset_cnt(amrr);
@


1.67
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.66 2006/03/21 11:19:22 pedro Exp $  */
a188 3
/*
 * Default values for MAC registers; values taken from the reference driver.
 */
d193 1
a193 17
	{ RAL_TXRX_CSR5,  0x8c8d },
	{ RAL_TXRX_CSR6,  0x8b8a },
	{ RAL_TXRX_CSR7,  0x8687 },
	{ RAL_TXRX_CSR8,  0x0085 },
	{ RAL_MAC_CSR13,  0x1111 },
	{ RAL_MAC_CSR14,  0x1e11 },
	{ RAL_TXRX_CSR21, 0xe78f },
	{ RAL_MAC_CSR9,   0xff1d },
	{ RAL_MAC_CSR11,  0x0002 },
	{ RAL_MAC_CSR22,  0x0053 },
	{ RAL_MAC_CSR15,  0x0000 },
	{ RAL_MAC_CSR8,   0x0780 },
	{ RAL_TXRX_CSR19, 0x0000 },
	{ RAL_TXRX_CSR18, 0x005a },
	{ RAL_PHY_CSR2,   0x0000 },
	{ RAL_TXRX_CSR0,  0x1ec0 },
	{ RAL_PHY_CSR4,   0x000f }
a195 3
/*
 * Default values for BBP registers; values taken from the reference driver.
 */
d200 1
a200 55
	{  3, 0x02 },
	{  4, 0x19 },
	{ 14, 0x1c },
	{ 15, 0x30 },
	{ 16, 0xac },
	{ 17, 0x48 },
	{ 18, 0x18 },
	{ 19, 0xff },
	{ 20, 0x1e },
	{ 21, 0x08 },
	{ 22, 0x08 },
	{ 23, 0x08 },
	{ 24, 0x80 },
	{ 25, 0x50 },
	{ 26, 0x08 },
	{ 27, 0x23 },
	{ 30, 0x10 },
	{ 31, 0x2b },
	{ 32, 0xb9 },
	{ 34, 0x12 },
	{ 35, 0x50 },
	{ 39, 0xc4 },
	{ 40, 0x02 },
	{ 41, 0x60 },
	{ 53, 0x10 },
	{ 54, 0x18 },
	{ 56, 0x08 },
	{ 57, 0x10 },
	{ 58, 0x08 },
	{ 61, 0x60 },
	{ 62, 0x10 },
	{ 75, 0xff }
};

/*
 * Default values for RF register R2 indexed by channel numbers.
 */
static const uint32_t ural_rf2522_r2[] = {
	0x307f6, 0x307fb, 0x30800, 0x30805, 0x3080a, 0x3080f, 0x30814,
	0x30819, 0x3081e, 0x30823, 0x30828, 0x3082d, 0x30832, 0x3083e
};

static const uint32_t ural_rf2523_r2[] = {
	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
};

static const uint32_t ural_rf2524_r2[] = {
	0x00327, 0x00328, 0x00329, 0x0032a, 0x0032b, 0x0032c, 0x0032d,
	0x0032e, 0x0032f, 0x00340, 0x00341, 0x00342, 0x00343, 0x00346
};

static const uint32_t ural_rf2525_r2[] = {
	0x20327, 0x20328, 0x20329, 0x2032a, 0x2032b, 0x2032c, 0x2032d,
	0x2032e, 0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20346
d203 8
a210 19
static const uint32_t ural_rf2525_hi_r2[] = {
	0x2032f, 0x20340, 0x20341, 0x20342, 0x20343, 0x20344, 0x20345,
	0x20346, 0x20347, 0x20348, 0x20349, 0x2034a, 0x2034b, 0x2034e
};

static const uint32_t ural_rf2525e_r2[] = {
	0x2044d, 0x2044e, 0x2044f, 0x20460, 0x20461, 0x20462, 0x20463,
	0x20464, 0x20465, 0x20466, 0x20467, 0x20468, 0x20469, 0x2046b
};

static const uint32_t ural_rf2526_hi_r2[] = {
	0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d, 0x0022d,
	0x0022e, 0x0022e, 0x0022f, 0x0022d, 0x00240, 0x00240, 0x00241
};

static const uint32_t ural_rf2526_r2[] = {
	0x00226, 0x00227, 0x00227, 0x00228, 0x00228, 0x00229, 0x00229,
	0x0022a, 0x0022a, 0x0022b, 0x0022b, 0x0022c, 0x0022c, 0x0022d
};
a211 4
/*
 * For dual-band RF, RF registers R1 and R4 also depend on channel number;
 * values taken from the reference driver.
 */
d214 1
a214 3
	uint32_t	r1;
	uint32_t	r2;
	uint32_t	r4;
d216 1
a216 40
	{   1, 0x08808, 0x0044d, 0x00282 },
	{   2, 0x08808, 0x0044e, 0x00282 },
	{   3, 0x08808, 0x0044f, 0x00282 },
	{   4, 0x08808, 0x00460, 0x00282 },
	{   5, 0x08808, 0x00461, 0x00282 },
	{   6, 0x08808, 0x00462, 0x00282 },
	{   7, 0x08808, 0x00463, 0x00282 },
	{   8, 0x08808, 0x00464, 0x00282 },
	{   9, 0x08808, 0x00465, 0x00282 },
	{  10, 0x08808, 0x00466, 0x00282 },
	{  11, 0x08808, 0x00467, 0x00282 },
	{  12, 0x08808, 0x00468, 0x00282 },
	{  13, 0x08808, 0x00469, 0x00282 },
	{  14, 0x08808, 0x0046b, 0x00286 },

	{  36, 0x08804, 0x06225, 0x00287 },
	{  40, 0x08804, 0x06226, 0x00287 },
	{  44, 0x08804, 0x06227, 0x00287 },
	{  48, 0x08804, 0x06228, 0x00287 },
	{  52, 0x08804, 0x06229, 0x00287 },
	{  56, 0x08804, 0x0622a, 0x00287 },
	{  60, 0x08804, 0x0622b, 0x00287 },
	{  64, 0x08804, 0x0622c, 0x00287 },

	{ 100, 0x08804, 0x02200, 0x00283 },
	{ 104, 0x08804, 0x02201, 0x00283 },
	{ 108, 0x08804, 0x02202, 0x00283 },
	{ 112, 0x08804, 0x02203, 0x00283 },
	{ 116, 0x08804, 0x02204, 0x00283 },
	{ 120, 0x08804, 0x02205, 0x00283 },
	{ 124, 0x08804, 0x02206, 0x00283 },
	{ 128, 0x08804, 0x02207, 0x00283 },
	{ 132, 0x08804, 0x02208, 0x00283 },
	{ 136, 0x08804, 0x02209, 0x00283 },
	{ 140, 0x08804, 0x0220a, 0x00283 },

	{ 149, 0x08808, 0x02429, 0x00281 },
	{ 153, 0x08808, 0x0242b, 0x00281 },
	{ 157, 0x08808, 0x0242d, 0x00281 },
	{ 161, 0x08808, 0x0242f, 0x00281 }
d1190 3
a1192 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
d1196 3
a1205 2

	wh = mtod(m0, struct ieee80211_frame *);
@


1.66
log
@Make ural(4) read and show real MAC/BBP rev instead of hardcoded RT2570
"Go ahead" damien@@ via jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.65 2006/02/19 08:44:17 damien Exp $  */
d965 1
a965 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1261 1
a1261 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1361 1
a1361 1
		bpf_mtap(sc->sc_drvbpf, &mb);
d1423 1
a1423 1
				bpf_mtap(ic->ic_rawbpf, m0);
d1442 1
a1442 1
				bpf_mtap(ifp->if_bpf, m0);
d1449 1
a1449 1
				bpf_mtap(ic->ic_rawbpf, m0);
@


1.65
log
@sync w/ rt2560.c:

don't try to release references to nodes that have been freed by net80211.
in HostAP mode, when switching to the INIT state, net80211 sends a DISASSOC
and a DEAUTH frame to all associated stations and immediately free all the
nodes while we may still hold references to them in our Tx queues.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.64 2006/02/11 09:31:42 damien Exp $  */
d433 3
a435 3
	printf("%s: MAC/BBP RT2570 (rev 0x%02x), RF %s, address %s\n",
	    USBDEVNAME(sc->sc_dev), sc->asic_rev, ural_get_rf(sc->rf_rev),
	    ether_sprintf(ic->ic_myaddr));
d1999 4
@


1.64
log
@trim FCS in the driver instead of setting the M_HASFCS flag and letting
ieee80211_input() do the job.

requested by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.63 2006/02/04 11:40:32 damien Exp $  */
d530 3
a554 3
	ieee80211_ifdetach(ifp);
	if_detach(ifp);

a602 1
	struct ieee80211com *ic = &sc->sc_ic;
d614 5
a618 4
		if (data->ni != NULL) {
			ieee80211_release_node(ic, data->ni);
			data->ni = NULL;
		}
d1403 7
d2259 5
a2263 1
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
a2270 4

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.63
log
@fix a copy/paste in a comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.62 2006/01/29 03:22:52 brad Exp $  */
d944 1
a944 1
	m->m_flags |= M_HASFCS; /* h/w leaves FCS */
@


1.62
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.61 2006/01/22 21:41:03 damien Exp $  */
d1004 1
a1004 1
		/* reverse function of rt2560_plcp_signal */
@


1.61
log
@account tx retry-fail errors in if_oerrors.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.60 2006/01/14 12:40:39 damien Exp $  */
d851 1
a851 1
			usbd_clear_endpoint_stall(sc->sc_tx_pipeh);
d894 1
a894 1
			usbd_clear_endpoint_stall(sc->sc_rx_pipeh);
@


1.60
log
@- give rate to rx radiotap
- swap rssi/rate fields in ural_rx_desc
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.59 2006/01/14 08:50:38 jsg Exp $  */
d2345 1
d2347 3
a2349 1
	if (status != USBD_NORMAL_COMPLETION)
d2351 4
@


1.59
log
@Correct the length of the rx radiotap to be that of the rx not tx
struct.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.58 2006/01/13 21:29:53 damien Exp $  */
d124 3
d944 1
a944 1
	m->m_flags |= M_HASFCS; /* hardware appends FCS */
d954 1
d994 34
@


1.58
log
@send management frames at lowest possible rate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.57 2006/01/13 21:00:54 damien Exp $  */
d958 1
a958 1
		mb.m_len = sc->sc_txtap_len;
@


1.57
log
@- fix short preamble support
- add short slot support
- fix eifs settings
- many consistency tweaks
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.56 2006/01/13 17:48:25 damien Exp $  */
d1130 1
a1130 1
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
d1187 1
a1187 1
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
@


1.56
log
@- simplify lookup of 802.11a channels (we know they exist)
- kill two stupid comments while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.55 2006/01/13 17:35:33 damien Exp $  */
d153 3
d439 8
a446 3
	ic->ic_caps = IEEE80211_C_MONITOR | IEEE80211_C_IBSS |
	    IEEE80211_C_HOSTAP | IEEE80211_C_SHPREAMBLE | IEEE80211_C_PMGT |
	    IEEE80211_C_TXPMGT | IEEE80211_C_WEP;
d727 1
d759 7
a765 10
		/* update basic rate set */
		if (ic->ic_curmode == IEEE80211_MODE_11B) {
			/* 11b basic rates: 1, 2Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x3);
		} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
			/* 11a basic rates: 6, 12, 24Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x150);
		} else {
			/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x15f);
a767 3
		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			ural_set_bssid(sc, ic->ic_bss->ni_bssid);

d770 1
a770 1
			m = ieee80211_beacon_alloc(ic, ic->ic_bss);
d777 1
a777 1
			if (ural_tx_bcn(sc, m, ic->ic_bss) != 0) {
d826 4
a829 1
#define RAL_SIFS	10
d1823 57
@


1.55
log
@- fix AMRR initialization + retry-fail count
- fix contention window
- silently discard received frames that are too short
- sync setup_tx_desc w/ ral
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.54 2006/01/04 06:04:41 canacar Exp $  */
d4 1
a4 1
 * Copyright (c) 2005
a302 1
	/* channels in the 2.4GHz band */
a317 1
	/* channels in the 5.2GHz band */
a1672 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1740 1
a1740 3
		for (i = 0; i < N(ural_rf5222); i++)
			if (ural_rf5222[i].chan == chan)
				break;
d1742 4
a1745 6
		if (i < N(ural_rf5222)) {
			ural_rf_write(sc, RAL_RF1, ural_rf5222[i].r1);
			ural_rf_write(sc, RAL_RF2, ural_rf5222[i].r2);
			ural_rf_write(sc, RAL_RF3, power << 7 | 0x00040);
			ural_rf_write(sc, RAL_RF4, ural_rf5222[i].r4);
		}
a1765 1
#undef N
@


1.54
log
@Remove redundant calls to bpfdetach.
ok brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.53 2005/12/23 08:10:12 jsg Exp $  */
d894 2
a895 1
		printf("%s: xfer too short %d\n", USBDEVNAME(sc->sc_dev), len);
d1083 1
a1083 4
	if (RAL_RATE_IS_OFDM(rate))
		desc->flags |= htole32(RAL_TX_OFDM);

	desc->wme = htole16(RAL_AIFSN(3) | RAL_LOGCWMIN(4) | RAL_LOGCWMAX(6));
d1085 2
a1086 3
	/*
	 * Fill PLCP fields.
	 */
d1091 2
a1092 4
		/*
		 * PLCP length field (LENGTH).
		 * From IEEE Std 802.11a-1999, pp. 14.
		 */
d1094 2
a1095 2
		desc->plcp_length = htole16((plcp_length >> 6) << 8 |
		    (plcp_length & 0x3f));
a1096 4
		/*
		 * Long PLCP LENGTH field.
		 * From IEEE Std 802.11b-1999, pp. 16.
		 */
d1103 5
a1107 1
		desc->plcp_length = htole16(plcp_length);
a1109 4
	desc->plcp_signal = ural_plcp_signal(rate);
	if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
		desc->plcp_signal |= 0x08;

d2193 3
a2206 1
	amrr->success_threshold = 0;
d2208 1
d2259 1
a2259 1
	    sc->sta[8];		/* TX retry-fail count */
a2281 4

#define URAL_AMRR_MIN_SUCCESS_THRESHOLD	 1
#define URAL_AMRR_MAX_SUCCESS_THRESHOLD	10

@


1.53
log
@Support Nintendo Wi-Fi USB Connector, noticed in Linux rt2570 driver
and verified against windows driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.52 2005/12/09 05:22:08 jsg Exp $  */
a542 3
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
@


1.52
log
@Add support for Linksys HU200-TS, id found in Linux RT2570 driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.51 2005/11/24 22:10:07 damien Exp $  */
d98 1
@


1.51
log
@o Force the sending of an extra URB if there is less than 2 bytes left
  at the end of the last URB (URB = USB Request Block = 64 bytes).
o Better check of the size of received frames.
o In ural_tx_{data,mgt} send the packet to BPF after setting the duration
  field of the frame.
o Minor tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.50 2005/11/24 13:01:58 grange Exp $  */
d90 1
@


1.50
log
@ural should be DV_IFNET, not DV_DULL. noticed by ian@@.
ok many.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.49 2005/11/23 20:37:37 damien Exp $  */
d894 1
a894 1
	if (len < RAL_RX_DESC_SIZE) {
d1093 1
a1093 1
	len += 4; /* account for FCS */
d1195 18
a1232 18
	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RAL_TX_ACK;

		dur = ural_txtime(RAL_ACK_SIZE, rate, ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);

		/* tell hardware to add timestamp for probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RAL_TX_TIMESTAMP;
	}

d1236 1
a1236 1
	/* xfer length needs to be a multiple of two! */
d1239 7
d1296 17
a1332 17
	data = &sc->tx_data[0];
	desc = (struct ural_tx_desc *)data->buf;

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RAL_TX_ACK;
		flags |= RAL_TX_RETRY(7);

		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(ic, rate),
		    ic->ic_flags) + RAL_SIFS;
		*(uint16_t *)wh->i_dur = htole16(dur);
	}

d1336 1
a1336 1
	/* xfer length needs to be a multiple of two! */
d1339 7
a1575 1
		return;
@


1.49
log
@Be more robust when receiving frames.  If we can't allocate a new mbuf,
just discard the received frame and reuse the old mbuf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.48 2005/11/23 20:29:30 damien Exp $  */
d345 1
a345 1
USB_DECLARE_DRIVER(ural);
@


1.48
log
@use sizeof instead of hard-coded values.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.47 2005/11/23 20:23:48 damien Exp $  */
d880 1
a880 1
	struct mbuf *m;
d913 21
a934 1
	m = data->m;
a977 18

	MGETHDR(data->m, M_DONTWAIT, MT_DATA);
	if (data->m == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    USBDEVNAME(sc->sc_dev));
		return;
	}

	MCLGET(data->m, M_DONTWAIT);
	if (!(data->m->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    USBDEVNAME(sc->sc_dev));
		m_freem(data->m);
		data->m = NULL;
		return;
	}

	data->buf = mtod(data->m, uint8_t *);
@


1.47
log
@Implement the Adaptive Multi Rate Retry algorithm (AMRR) for BSS mode.
This algorithm is particularly well suited for ural since it does not
require per-frame retry statistics.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.46 2005/11/23 19:56:51 damien Exp $  */
d2228 1
a2228 1
	USETW(req.wLength, 22);
d2231 2
a2232 1
	    USBD_DEFAULT_TIMEOUT, &req, sc->sta, 22, 0, ural_amrr_update);
d2250 1
a2250 1
	    sc->sta[8] +	/* TX more-retry ok count  */
@


1.46
log
@Optimize TXTIME and PLCP LENGTH field computation.
Avoid modulus operations.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.45 2005/10/02 13:01:59 damien Exp $  */
d161 7
d419 1
d521 6
d793 6
d812 1
a1267 1
	/* XXX this should be reworked! */
d2005 1
a2005 1
	uint16_t sta[11], tmp;
d2045 1
a2045 1
	ural_read_multi(sc, RAL_STA_CSR0, sta, sizeof sta);
d2066 10
d2167 5
d2186 144
@


1.45
log
@allows dhcpd to work when ral/ural is acting as a standalone AP (without
bridging).  it appears that ieee80211_input() enqueues packets in if_snd
without calling if_start().

closes PR/4237
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.44 2005/08/27 14:46:37 damien Exp $  */
a1006 1
	int ceil, dbps;
d1009 3
a1011 11
		/*
		 * OFDM TXTIME calculation.
		 * From IEEE Std 802.11a-1999, pp. 37.
		 */
		dbps = rate * 2; /* data bits per OFDM symbol */

		ceil = (16 + 8 * len + 6) / dbps;
		if ((16 + 8 * len + 6) % dbps != 0)
			ceil++;

		txtime = 16 + 4 + 4 * ceil + 6;
d1013 2
a1014 8
		/*
		 * High Rate TXTIME calculation.
		 * From IEEE Std 802.11b-1999, pp. 28.
		 */
		ceil = (8 * len * 2) / rate;
		if ((8 * len * 2) % rate != 0)
			ceil++;

d1016 1
a1016 1
			txtime =  72 + 24 + ceil;
d1018 1
a1018 1
			txtime = 144 + 48 + ceil;
a1019 1

d1084 4
a1087 4
		plcp_length = (8 * len * 2) / rate;
		remainder = (8 * len * 2) % rate;
		if (remainder != 0) {
			if (rate == 22 && (rate - remainder) / 16 != 0)
a1088 1
			plcp_length++;
@


1.44
log
@Extend basic rate set in 802.11g so that ACKs can be sent at 5.5 or 11Mbps.
Fix WME settings (Best Effort).

ok deraadt@@ reyk@@ henning@@
tested by many
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.42 2005/08/25 20:28:19 damien Exp $  */
d928 7
@


1.44.2.1
log
@MFC:
Fix by damien@@

allows dhcpd to work when ral/ural is acting as a standalone AP (without
bridging).  it appears that ieee80211_input() enqueues packets in if_snd
without calling if_start().

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.44 2005/08/27 14:46:37 damien Exp $  */
a927 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		ural_start(ifp);
@


1.43
log
@backout unapproved diff
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.41 2005/08/23 02:25:52 jsg Exp $  */
d122 1
a122 1
Static int		ural_ack_rate(int);
d739 12
d962 1
a962 1
ural_ack_rate(int rate)
d971 1
a971 1
		return 4;
d1072 1
a1072 1
	desc->wme = htole16(RAL_LOGCWMAX(5) | RAL_LOGCWMIN(3) | RAL_AIFSN(2));
d1309 1
a1309 1
		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(rate),
d2023 1
a2023 1
	/* set supported basic rates (1, 2, 6, 12, 24) */
@


1.42
log
@Extend basic rate set in 802.11g so that ACKs can be sent at 5.5 or 11Mbps.
Fix WME settings (Best Effort).
@
text
@d122 1
a122 1
Static int		ural_ack_rate(struct ieee80211com *, int);
a738 12
		/* update basic rate set */
		if (ic->ic_curmode == IEEE80211_MODE_11B) {
			/* 11b basic rates: 1, 2Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x3);
		} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
			/* 11a basic rates: 6, 12, 24Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x150);
		} else {
			/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
			ural_write(sc, RAL_TXRX_CSR11, 0x15f);
		}

d950 1
a950 1
ural_ack_rate(struct ieee80211com *ic, int rate)
d959 1
a959 1
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;
d1060 1
a1060 1
	desc->wme = htole16(RAL_AIFSN(3) | RAL_LOGCWMIN(4) | RAL_LOGCWMAX(6));
d1297 1
a1297 1
		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(ic, rate),
d2011 1
a2011 1
	/* set basic rate set (will be updated later) */
@


1.41
log
@Ralink windows driver incorrectly lists a SMC product id that is
actually some kind of prism chip. ok derradt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.40 2005/08/01 05:36:48 brad Exp $  */
d122 1
a122 1
Static int		ural_ack_rate(int);
d739 12
d962 1
a962 1
ural_ack_rate(int rate)
d971 1
a971 1
		return 4;
d1072 1
a1072 1
	desc->wme = htole16(RAL_LOGCWMAX(5) | RAL_LOGCWMIN(3) | RAL_AIFSN(2));
d1309 1
a1309 1
		dur = ural_txtime(RAL_ACK_SIZE, ural_ack_rate(rate),
d2023 1
a2023 1
	/* set supported basic rates (1, 2, 6, 12, 24) */
@


1.40
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.39 2005/07/18 14:41:15 jsg Exp $  */
a102 1
	{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_RT2570 },
@


1.39
log
@Match Sphairon UB801R.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.38 2005/07/07 08:33:22 jsg Exp $  */
d360 1
a360 1
	char devinfo[1024];
d365 1
a365 1
	usbd_devinfo(sc->sc_udev, 0, devinfo, sizeof devinfo);
d367 2
a368 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.38
log
@Match an additional 10 ural ids, most of which are already listed
in the device list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.37 2005/07/07 02:14:32 jsg Exp $  */
d104 1
@


1.37
log
@Match Gigabyte GN-WBKG, from Jaime Fournier <ober at linbsd.org>.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.36 2005/06/20 18:54:59 damien Exp $  */
d86 1
a86 1
	{ USB_VENDOR_ASUS,		USB_PRODUCT_RALINK_RT2570 },
d93 1
d95 5
d102 5
a106 1
	{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_RT2570 }
@


1.36
log
@remove freebsd'isms in debug messages.  pointed out by timsl (tim at
planetpixel dot de).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.35 2005/06/16 03:43:50 dlg Exp $  */
d92 1
@


1.35
log
@add support for the Belkin F5D7050 54g USB Network Adapter

for jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.34 2005/05/18 20:10:17 damien Exp $  */
d1802 1
a1802 1
	DPRINTF(("setting BSSID to %6D\n", bssid, ":"));
d1819 1
a1819 1
	DPRINTF(("setting MAC address to %6D\n", addr, ":"));
@


1.34
log
@don't initialize bbp registers with values in eeprom.  some adapters seem
to have problems with that.  noticed by Andrey Matveev.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.33 2005/05/13 19:35:47 damien Exp $  */
d87 1
@


1.33
log
@override default bbp register values with values stored in eeprom (except
for the R17 register).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.32 2005/05/13 19:13:11 damien Exp $  */
d1900 1
d1907 1
@


1.32
log
@before ieee80211.c rev 1.6, it was guaranted that ic_curmode was different
from IEEE80211_MODE_AUTO if ic_fixed_rate != -1.  it is no longer the case.
this implements a temporary workaround.  the whole rate selection should be
rewritten.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.31 2005/05/13 19:00:10 damien Exp $  */
a1899 1
#if 0
a1905 1
#endif
d2009 3
@


1.31
log
@simplify test conditions.  ((v & f1) || (v & f2)) <=> (v & (f1 | f2)) in
these particular cases.  avoid extra calls to letoh32().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.30 2005/05/13 18:42:50 damien Exp $  */
d1232 1
d1234 5
a1238 1
		rs = &ic->ic_sup_rates[ic->ic_curmode];
@


1.30
log
@make sure all endpoint descriptors have been found during the attachment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.29 2005/05/13 18:17:08 damien Exp $  */
d857 1
a857 2
	if ((letoh32(desc->flags) & RAL_RX_PHY_ERROR) ||
	    (letoh32(desc->flags) & RAL_RX_CRC_ERROR)) {
d1189 3
a1191 4
		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT &&
		    (wh->i_fc[0] & IEEE80211_FC0_SUBTYPE_MASK) ==
		    IEEE80211_FC0_SUBTYPE_PROBE_RESP)
@


1.29
log
@give disassociation a chance when turning the interface down while associated.
avoid usb tx timeouts too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.28 2005/04/17 13:41:51 damien Exp $  */
d376 1
d380 1
a380 1
			printf("%s: no endpoint descriptor for %d\n",
d391 4
@


1.28
log
@don't disassociate on SIOCSIFADDR if the interface is already up and running.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.27 2005/04/16 08:27:41 damien Exp $  */
d2098 2
a2105 2

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
@


1.27
log
@don't leak a mbuf when tx fails.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.25 2005/04/15 13:42:54 damien Exp $  */
a1400 1
		switch (ifa->ifa_addr->sa_family) {
d1402 1
a1402 1
		case AF_INET:
a1403 2
			ural_init(ifp);
			break;
d1405 1
a1405 5
		default:
			ural_init(ifp);
		}
		break;

@


1.26
log
@indent
@
text
@d1205 2
a1206 1
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
d1208 1
d1294 2
a1295 1
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS)
d1297 1
@


1.25
log
@in ural_txeof(), call usbd_clear_endpoint_stall() on the tx pipe instead of
the rx pipe.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.24 2005/04/13 12:24:11 damien Exp $  */
d1239 1
a1239 1
		return ENOBUFS;
@


1.24
log
@New ural devices. Pointed out by Rodolfo Gouveia.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.23 2005/04/02 11:00:11 damien Exp $  */
d794 1
a794 1
			usbd_clear_endpoint_stall(sc->sc_rx_pipeh);
@


1.23
log
@sync with ral. fixes hostap mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.22 2005/04/01 13:13:42 damien Exp $  */
d93 1
@


1.22
log
@add code for setting WEP keys. this will be useful when i'll implement
hardware WEP.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.19 2005/03/23 15:15:11 damien Exp $  */
d718 3
a720 2
		if (ic->ic_opmode != IEEE80211_M_MONITOR &&
		    ic->ic_opmode != IEEE80211_M_HOSTAP)
@


1.21
log
@make constants names match the spec.
@
text
@d1961 1
d2010 9
@


1.20
log
@force hardware timestamp insertion in outgoing beacons. make sure the size
of the allocated buffer for outgoing beacons can fit an extra byte (xfer
length must be a multiple of 2).
@
text
@d1041 1
a1041 4
	desc->wme = htole32(
	    5 << RAL_WME_CWMAX_BITS_SHIFT |
	    3 << RAL_WME_CWMIN_BITS_SHIFT |
	    2 << RAL_WME_AIFSN_BITS_SHIFT);
d1119 2
a1120 2
	ural_setup_tx_desc(sc, desc, RAL_TX_IFS_NEW_BACKOFF |
	    RAL_TX_INSERT_TIMESTAMP, m0->m_pkthdr.len, rate);
d1177 1
a1177 1
		flags |= RAL_TX_NEED_ACK;
d1187 1
a1187 1
			flags |= RAL_TX_INSERT_TIMESTAMP;
d1269 1
a1269 1
		flags |= RAL_TX_NEED_ACK;
d1770 1
d1772 1
a1772 2
		ural_write(sc, RAL_TXRX_CSR19, RAL_TSF_SYNC_BSS |
		    RAL_TSF_AUTOCOUNT | RAL_BCN_RELOAD);
d1774 2
a1775 2
		ural_write(sc, RAL_TXRX_CSR19, RAL_TSF_SYNC_IBSS |
		    RAL_TSF_AUTOCOUNT | RAL_BCN_RELOAD | RAL_GENERATE_BEACON);
d2058 1
a2058 1
	tmp = RAL_DROP_PHY | RAL_DROP_CRC;
d2060 1
a2060 1
		tmp |= RAL_DROP_CTL | RAL_DROP_BAD_VERSION;
@


1.19
log
@use URAL_DEBUG not RAL_DEBUG. use logprintf for consistency. default to
debug level 0.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.18 2005/03/23 14:48:55 damien Exp $  */
a1090 1
	uint32_t flags = 0;
d1101 4
a1104 1
	buf = usbd_alloc_buffer(xfer, RAL_TX_DESC_SIZE + m0->m_pkthdr.len);
d1122 2
a1123 4
	ural_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);

	/* xfer length needs to be a multiple of two! */
	xferlen = (RAL_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
@


1.18
log
@add new vendor/product ids.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.17 2005/03/23 14:14:31 damien Exp $  */
d71 1
a71 1
#define RAL_DEBUG
d74 4
a77 4
#ifdef RAL_DEBUG
#define DPRINTF(x)	do { if (ural_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (ural_debug >= (n)) printf x; } while (0)
int ural_debug = 14;
@


1.17
log
@do packet accounting (opackets/oerrors/ierrors).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.16 2005/03/23 13:07:35 dlg Exp $  */
a86 1
	{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_RT2570 },
d89 3
@


1.16
log
@print the mac address in dmesg like every other nic we have

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.15 2005/03/23 12:41:47 dlg Exp $  */
d791 2
d804 1
d841 1
d855 1
d1372 1
@


1.15
log
@USB_DEBUG implies URAL_DEBUG.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.14 2005/03/19 10:18:49 damien Exp $  */
d398 3
a400 2
	printf("%s: MAC/BBP RT2570 (rev 0x%02x), RF %s\n",
	    USBDEVNAME(sc->sc_dev), sc->asic_rev, ural_get_rf(sc->rf_rev));
@


1.14
log
@add spl calls where appropriate.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.13 2005/03/19 09:52:54 damien Exp $  */
d70 4
d75 2
a76 2
#define DPRINTF(x)	if (ural_debug > 0) printf x
#define DPRINTFN(n, x)	if (ural_debug >= (n)) printf x
@


1.13
log
@ieee80211_get_rate() is broken.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.12 2005/03/19 09:49:39 damien Exp $  */
d481 3
d507 2
d775 1
d789 2
d803 2
d818 1
a818 1
	int len;
d855 2
d885 2
@


1.12
log
@scan channels 12, 13 and 14 too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.11 2005/03/18 22:11:08 damien Exp $  */
d1193 1
d1202 8
a1209 3
	/* XXX should do automatic rate adaptation */
	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 4;
	rate = MAX(rate, ieee80211_get_rate(ic));
@


1.11
log
@use ieee80211_get_rate() instead of building or own routine.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.10 2005/03/18 20:18:57 damien Exp $  */
d433 1
a433 1
	for (i = 1; i <= 11; i++) {
@


1.10
log
@add IBSS and HostAP support. thanks to SnoopyPro.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.9 2005/03/18 19:07:22 damien Exp $  */
d1202 2
a1203 6
	if (ic->ic_fixed_rate != -1)
		rate = ic->ic_bss->ni_rates.rs_rates[ic->ic_fixed_rate];
	else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];

	rate &= IEEE80211_RATE_VAL;
@


1.9
log
@use xferlen for mgt frames too. this prevents management frames with a
odd length from being dropped.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.8 2005/03/18 13:57:42 damien Exp $  */
d108 2
d402 3
a404 2
	ic->ic_caps = IEEE80211_C_MONITOR | IEEE80211_C_SHPREAMBLE |
	    IEEE80211_C_PMGT | IEEE80211_C_TXPMGT | IEEE80211_C_WEP;
d677 1
d706 2
a707 1
		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
d709 19
a727 1
			ural_enable_tsf_sync(sc);
d732 3
d1060 52
d2034 3
a2036 1
		tmp |= RAL_DROP_CTL | RAL_DROP_TODS | RAL_DROP_BAD_VERSION;
@


1.8
log
@only update the flags part of PHY_CSR5 and PHY_CSR6. this makes OFDM
modulation working and improves tx signal.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.7 2005/03/18 13:53:31 damien Exp $  */
d1098 2
a1099 3
	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
	    RAL_TX_DESC_SIZE + m0->m_pkthdr.len, USBD_FORCE_SHORT_XFER |
	    USBD_NO_COPY, RAL_TX_TIMEOUT, ural_txeof);
d1183 2
a1184 3
	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
	    xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RAL_TX_TIMEOUT,
	    ural_txeof);
@


1.7
log
@close pipes and free tx/rx lists in detach(). this avoids some of the
panics observed when detaching the device while the interface is up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.6 2005/03/17 14:23:03 damien Exp $  */
d1825 3
a1827 3
	/* update values with PHY_CSR5 and PHY_CSR6 */
	tmp = ural_read(sc, RAL_PHY_CSR5) & ~0xff;
	ural_write(sc, RAL_PHY_CSR5, tmp | tx);
d1829 2
a1830 2
	tmp = ural_read(sc, RAL_PHY_CSR6) & ~0xff;
	ural_write(sc, RAL_PHY_CSR6, tmp | tx);
@


1.6
log
@give ipv6 a chance. pointed out by Paul de Weerd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.5 2005/03/17 12:46:54 damien Exp $  */
d481 13
@


1.5
log
@enable tx retries for unicast frames.
ok and tweaks from dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.4 2005/03/17 11:04:30 dlg Exp $  */
d1271 1
d1304 11
d1333 1
a1333 1
	if (error == ENETRESET && cmd != SIOCADDMULTI) {
@


1.4
log
@fix for big endian archs

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.3 2005/03/17 09:01:43 damien Exp $  */
d1155 1
@


1.3
log
@- fix ralink url
- add usb events for attach/detach
- pre-allocate rx buffers so they are not allocated in an interrupt
  context
- let ural_free_rx_list() do the cleanup
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.2 2005/03/16 21:21:39 damien Exp $  */
d1726 1
@


1.2
log
@move ral vendor/product Ids into usbdevs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_ral.c,v 1.1 2005/03/16 20:17:10 damien Exp $  */
d22 1
a22 1
 * http://www.uralinktech.com/
d468 3
d488 3
d572 7
a588 2
			m_freem(data->m);
			data->m = NULL;
@


1.1
log
@Driver for Ralink Technology RT2500USB wireless adapters.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d81 7
a87 7
	{ USB_VENDOR_ALPHA,	USB_PRODUCT_ALPHA_RT2570 },
	{ USB_VENDOR_ASUS,	USB_PRODUCT_ASUS_RT2570_1 },
	{ USB_VENDOR_ASUS,	USB_PRODUCT_ASUS_RT2570_2 },
	{ USB_VENDOR_GEMTEK,	USB_PRODUCT_GEMTEK_RT2570_1 },
	{ USB_VENDOR_GEMTEK,	USB_PRODUCT_GEMTEK_RT2570_2 },
	{ USB_VENDOR_RALINK,	USB_PRODUCT_RALINK_RT2570 },
	{ USB_VENDOR_SMC,	USB_PRODUCT_SMC_RT2570 }
@

