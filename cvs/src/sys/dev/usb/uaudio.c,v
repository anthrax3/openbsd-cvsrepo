head	1.125;
access;
symbols
	OPENBSD_6_1:1.124.0.4
	OPENBSD_6_1_BASE:1.124
	OPENBSD_6_0:1.113.0.6
	OPENBSD_6_0_BASE:1.113
	OPENBSD_5_9:1.113.0.2
	OPENBSD_5_9_BASE:1.113
	OPENBSD_5_8:1.112.0.4
	OPENBSD_5_8_BASE:1.112
	OPENBSD_5_7:1.109.0.2
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.104.0.4
	OPENBSD_5_6_BASE:1.104
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.96.0.4
	OPENBSD_5_3_BASE:1.96
	OPENBSD_5_2:1.96.0.2
	OPENBSD_5_2_BASE:1.96
	OPENBSD_5_1_BASE:1.95
	OPENBSD_5_1:1.95.0.2
	OPENBSD_5_0:1.92.0.2
	OPENBSD_5_0_BASE:1.92
	OPENBSD_4_9:1.91.0.2
	OPENBSD_4_9_BASE:1.91
	OPENBSD_4_8:1.87.0.2
	OPENBSD_4_8_BASE:1.87
	OPENBSD_4_7:1.73.0.2
	OPENBSD_4_7_BASE:1.73
	OPENBSD_4_6:1.61.0.6
	OPENBSD_4_6_BASE:1.61
	OPENBSD_4_5:1.61.0.2
	OPENBSD_4_5_BASE:1.61
	OPENBSD_4_4:1.59.0.2
	OPENBSD_4_4_BASE:1.59
	OPENBSD_4_3:1.56.0.2
	OPENBSD_4_3_BASE:1.56
	OPENBSD_4_2:1.48.0.2
	OPENBSD_4_2_BASE:1.48
	OPENBSD_4_1:1.37.0.2
	OPENBSD_4_1_BASE:1.37
	OPENBSD_4_0:1.37.0.4
	OPENBSD_4_0_BASE:1.37
	OPENBSD_3_9:1.34.0.2
	OPENBSD_3_9_BASE:1.34
	OPENBSD_3_8:1.22.0.2
	OPENBSD_3_8_BASE:1.22
	OPENBSD_3_7:1.21.0.2
	OPENBSD_3_7_BASE:1.21
	OPENBSD_3_6:1.20.0.4
	OPENBSD_3_6_BASE:1.20
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.18.0.2
	OPENBSD_3_5_BASE:1.18
	OPENBSD_3_4:1.17.0.2
	OPENBSD_3_4_BASE:1.17
	UBC_SYNC_A:1.15
	OPENBSD_3_3:1.13.0.4
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.13.0.2
	OPENBSD_3_2_BASE:1.13
	OPENBSD_3_1:1.11.0.4
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.13
	UBC:1.11.0.2
	UBC_BASE:1.11
	OPENBSD_3_0:1.10.0.2
	OPENBSD_3_0_BASE:1.10
	OPENBSD_2_9_BASE:1.8
	OPENBSD_2_9:1.8.0.2
	OPENBSD_2_8:1.6.0.2
	OPENBSD_2_8_BASE:1.6
	OPENBSD_2_7:1.4.0.2
	OPENBSD_2_7_BASE:1.4
	SMP:1.1.0.2
	SMP_BASE:1.1
	kame_19991208:1.1;
locks; strict;
comment	@ * @;


1.125
date	2017.04.05.22.45.21;	author deraadt;	state Exp;
branches;
next	1.124;
commitid	1HPbx5MpMiNl2Nsx;

1.124
date	2017.02.10.08.09.36;	author ratchov;	state Exp;
branches;
next	1.123;
commitid	BHGrVHFOUpnAoTNh;

1.123
date	2017.01.31.13.42.15;	author jca;	state Exp;
branches;
next	1.122;
commitid	uHAZD1L57gGVrKqK;

1.122
date	2017.01.03.06.45.58;	author ratchov;	state Exp;
branches;
next	1.121;
commitid	Y8gthU35nnUKnEBm;

1.121
date	2016.12.12.06.51.09;	author ratchov;	state Exp;
branches;
next	1.120;
commitid	Y5AYeChw3s6Fmtlk;

1.120
date	2016.12.05.07.07.43;	author ratchov;	state Exp;
branches;
next	1.119;
commitid	LAezTuo5aySaIcRi;

1.119
date	2016.11.16.07.02.48;	author ratchov;	state Exp;
branches;
next	1.118;
commitid	JnQUhZNM6DJT2G17;

1.118
date	2016.11.08.06.09.56;	author ratchov;	state Exp;
branches;
next	1.117;
commitid	urQ4RckRUKnk3bb2;

1.117
date	2016.10.27.05.08.23;	author ratchov;	state Exp;
branches;
next	1.116;
commitid	wKPnlwzqNO52KESX;

1.116
date	2016.09.23.08.21.22;	author ratchov;	state Exp;
branches;
next	1.115;
commitid	Wblc1sBj1vAIyaYy;

1.115
date	2016.09.19.06.46.44;	author ratchov;	state Exp;
branches;
next	1.114;
commitid	qGgYgJTgEFuAoGj4;

1.114
date	2016.09.14.06.12.20;	author ratchov;	state Exp;
branches;
next	1.113;
commitid	pi1a9KN0itEngOc4;

1.113
date	2015.11.27.10.59.32;	author mpi;	state Exp;
branches;
next	1.112;
commitid	6yJdd8L38vYwsx40;

1.112
date	2015.06.15.15.45.28;	author mpi;	state Exp;
branches;
next	1.111;
commitid	fJDSm2PsdeBQgvgI;

1.111
date	2015.05.11.06.46.22;	author ratchov;	state Exp;
branches;
next	1.110;
commitid	RaOGL5SyOGOZylwx;

1.110
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.109;
commitid	p4LJxGKbi0BU2cG6;

1.109
date	2015.01.12.07.12.58;	author deraadt;	state Exp;
branches;
next	1.108;
commitid	XcIBuQ1J8conypfF;

1.108
date	2014.12.13.21.05.33;	author doug;	state Exp;
branches;
next	1.107;
commitid	20ZyHa9gTJxHxhwD;

1.107
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.106;
commitid	zM5ckwX4kwwmipG0;

1.106
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.105;
commitid	Qb045HZ5OhQfU69H;

1.105
date	2014.08.21.14.52.55;	author mpi;	state Exp;
branches;
next	1.104;
commitid	nyUgTgf8DHNH5RDf;

1.104
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.103;
commitid	OBNa5kfxQ2UXoiIw;

1.103
date	2014.06.04.08.01.25;	author ratchov;	state Exp;
branches;
next	1.102;
commitid	1uWg5OOAGOEjDVK9;

1.102
date	2014.05.17.12.43.18;	author ratchov;	state Exp;
branches;
next	1.101;

1.101
date	2013.11.06.16.13.42;	author pirofti;	state Exp;
branches;
next	1.100;

1.100
date	2013.05.15.08.29.26;	author ratchov;	state Exp;
branches;
next	1.99;

1.99
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.98;

1.98
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.97;

1.97
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.96;

1.96
date	2012.03.01.08.49.22;	author ratchov;	state Exp;
branches;
next	1.95;

1.95
date	2012.01.31.21.13.32;	author brynet;	state Exp;
branches;
next	1.94;

1.94
date	2012.01.26.09.00.36;	author ratchov;	state Exp;
branches;
next	1.93;

1.93
date	2011.12.01.23.02.12;	author dhill;	state Exp;
branches;
next	1.92;

1.92
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.91;

1.91
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.90;

1.90
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.89;

1.89
date	2010.08.18.22.54.58;	author jakemsr;	state Exp;
branches;
next	1.88;

1.88
date	2010.08.18.22.53.10;	author jakemsr;	state Exp;
branches;
next	1.87;

1.87
date	2010.07.31.02.52.16;	author jakemsr;	state Exp;
branches;
next	1.86;

1.86
date	2010.07.23.19.59.09;	author jakemsr;	state Exp;
branches;
next	1.85;

1.85
date	2010.07.23.14.46.28;	author sthen;	state Exp;
branches;
next	1.84;

1.84
date	2010.07.23.12.17.48;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2010.07.21.10.16.07;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2010.07.21.05.57.19;	author jakemsr;	state Exp;
branches;
next	1.81;

1.81
date	2010.07.21.05.54.42;	author jakemsr;	state Exp;
branches;
next	1.80;

1.80
date	2010.07.21.05.04.57;	author jakemsr;	state Exp;
branches;
next	1.79;

1.79
date	2010.07.21.03.06.35;	author jakemsr;	state Exp;
branches;
next	1.78;

1.78
date	2010.07.20.23.46.11;	author jakemsr;	state Exp;
branches;
next	1.77;

1.77
date	2010.07.19.07.57.36;	author jakemsr;	state Exp;
branches;
next	1.76;

1.76
date	2010.07.19.05.50.37;	author jakemsr;	state Exp;
branches;
next	1.75;

1.75
date	2010.07.19.05.08.37;	author jakemsr;	state Exp;
branches;
next	1.74;

1.74
date	2010.07.15.03.43.12;	author jakemsr;	state Exp;
branches;
next	1.73;

1.73
date	2009.12.04.20.50.59;	author jakemsr;	state Exp;
branches;
next	1.72;

1.72
date	2009.12.04.20.38.43;	author jakemsr;	state Exp;
branches;
next	1.71;

1.71
date	2009.12.04.08.17.39;	author ratchov;	state Exp;
branches;
next	1.70;

1.70
date	2009.11.26.15.45.25;	author jakemsr;	state Exp;
branches;
next	1.69;

1.69
date	2009.11.26.15.34.15;	author jakemsr;	state Exp;
branches;
next	1.68;

1.68
date	2009.11.03.08.31.44;	author jakemsr;	state Exp;
branches;
next	1.67;

1.67
date	2009.11.03.08.07.27;	author jakemsr;	state Exp;
branches;
next	1.66;

1.66
date	2009.11.03.08.04.38;	author jakemsr;	state Exp;
branches;
next	1.65;

1.65
date	2009.11.03.07.57.24;	author jakemsr;	state Exp;
branches;
next	1.64;

1.64
date	2009.10.17.07.10.37;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2009.10.15.08.47.44;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.61;

1.61
date	2008.11.21.17.55.02;	author robert;	state Exp;
branches;
next	1.60;

1.60
date	2008.11.12.16.01.09;	author sthen;	state Exp;
branches;
next	1.59;

1.59
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.58;

1.58
date	2008.06.17.16.51.40;	author jakemsr;	state Exp;
branches;
next	1.57;

1.57
date	2008.04.21.00.32.43;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2007.12.02.14.59.31;	author robert;	state Exp;
branches;
next	1.55;

1.55
date	2007.11.05.00.17.28;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.09.28.07.55.15;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2007.09.25.18.11.47;	author ratchov;	state Exp;
branches;
next	1.51;

1.51
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.50;

1.50
date	2007.09.09.01.00.35;	author fgsch;	state Exp;
branches;
next	1.49;

1.49
date	2007.09.08.17.34.54;	author ratchov;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.13.10.10.30;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.36;

1.36
date	2006.05.04.15.25.10;	author mickey;	state Exp;
branches;
next	1.35;

1.35
date	2006.04.21.15.47.27;	author jolan;	state Exp;
branches;
next	1.34;

1.34
date	2006.01.06.11.34.08;	author fgsch;	state Exp;
branches;
next	1.33;

1.33
date	2006.01.06.11.13.40;	author fgsch;	state Exp;
branches;
next	1.32;

1.32
date	2006.01.02.04.05.50;	author fgsch;	state Exp;
branches;
next	1.31;

1.31
date	2006.01.02.03.52.29;	author fgsch;	state Exp;
branches;
next	1.30;

1.30
date	2006.01.02.03.45.15;	author fgsch;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.02.01.24.18;	author fgsch;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.02.00.26.48;	author fgsch;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.02.00.07.13;	author fgsch;	state Exp;
branches;
next	1.26;

1.26
date	2006.01.01.22.55.39;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.01.22.49.25;	author fgsch;	state Exp;
branches;
next	1.24;

1.24
date	2006.01.01.22.13.52;	author fgsch;	state Exp;
branches;
next	1.23;

1.23
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches;
next	1.22;

1.22
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.18.11.26.52;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.30.03.06.48;	author drahn;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2003.11.07.11.10.47;	author jmc;	state Exp;
branches;
next	1.17;

1.17
date	2003.05.19.18.38.42;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2003.05.19.05.27.00;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.27.11.22.54;	author ho;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.06.23.07.26;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.09.17.20.30.25;	author drahn;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.03.02.20.32;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.08.18.10.37;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.11.44.22;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.24.13.44.18;	author ho;	state Exp;
branches;
next	1.4;

1.4
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.03.28.19.37.49;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.26.08.39.45;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	99.11.11.15.54.59;	author ho;	state Exp;
branches
	1.1.2.1;
next	;

1.1.2.1
date	2001.05.14.22.26.20;	author niklas;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2001.07.04.10.43.48;	author niklas;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.1.2.5;

1.1.2.5
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.1.2.6;

1.1.2.6
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.1.2.7;

1.1.2.7
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.1.2.8;

1.1.2.8
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;

1.11.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.11.2.2;

1.11.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.11.2.3;

1.11.2.3
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.125
log
@3 more mallocarray() uses
@
text
@/*	$OpenBSD: uaudio.c,v 1.124 2017/02/10 08:09:36 ratchov Exp $ */
/*	$NetBSD: uaudio.c,v 1.90 2004/10/29 17:12:53 kent Exp $	*/

/*
 * Copyright (c) 1999 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf
 *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf
 *                  http://www.usb.org/developers/devclass_docs/termt10.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/poll.h>

#include <machine/bus.h>

#include <sys/audioio.h>
#include <dev/audio_if.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#include <dev/usb/uaudioreg.h>

/* #define UAUDIO_DEBUG */
#ifdef UAUDIO_DEBUG
#define DPRINTF(x)	do { if (uaudiodebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uaudiodebug>(n)) printf x; } while (0)
int	uaudiodebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UAUDIO_NCHANBUFS 3	/* number of outstanding request */
#define UAUDIO_MIN_FRAMES 2	/* ms of sound in each request */
#define UAUDIO_MAX_FRAMES 16
#define UAUDIO_NSYNCBUFS 3	/* number of outstanding sync requests */

#define UAUDIO_MAX_ALTS  32	/* max alt settings allowed by driver */

#define MIX_MAX_CHAN 8
struct mixerctl {
	u_int16_t	wValue[MIX_MAX_CHAN]; /* using nchan */
	u_int16_t	wIndex;
	u_int8_t	nchan;
	u_int8_t	type;
#define MIX_ON_OFF	1
#define MIX_SIGNED_16	2
#define MIX_UNSIGNED_16	3
#define MIX_SIGNED_8	4
#define MIX_SELECTOR	5
#define MIX_SIZE(n) ((n) == MIX_SIGNED_16 || (n) == MIX_UNSIGNED_16 ? 2 : 1)
#define MIX_UNSIGNED(n) ((n) == MIX_UNSIGNED_16)
	int		minval, maxval;
	u_int		delta;
	u_int8_t	class;
	char		ctlname[MAX_AUDIO_DEV_LEN];
	char		*ctlunit;
};
#define MAKE(h,l) (((h) << 8) | (l))

struct as_info {
	u_int8_t	alt;
	u_int8_t	encoding;
	u_int8_t	attributes; /* Copy of bmAttributes of
				     * usb_audio_streaming_endpoint_descriptor
				     */
	struct usbd_interface *ifaceh;
	const usb_interface_descriptor_t *idesc;
	const struct usb_endpoint_descriptor_audio *edesc;
	const struct usb_endpoint_descriptor_audio *edesc1;
	const struct usb_audio_streaming_type1_descriptor *asf1desc;
	int		sc_busy;	/* currently used */
};

struct chan {
	void	(*intr)(void *);	/* DMA completion intr handler */
	void	*arg;		/* arg for intr() */
	struct usbd_pipe *pipe;
	struct usbd_pipe *sync_pipe;

	u_int	sample_size;
	u_int	sample_rate;
	u_int	bytes_per_frame;
	u_int	max_bytes_per_frame;
	u_int	fraction;	/* fraction/frac_denom is the extra samples/frame */
	u_int	frac_denom;	/* denominator for fractional samples */
	u_int	residue;	/* accumulates the fractional samples */
	u_int	nframes;	/* # of frames per transfer */
	u_int	nsync_frames;	/* # of frames per sync transfer */
	u_int	usb_fps;
	u_int	maxpktsize;
	u_int	reqms;		/* usb request data duration, in ms */
	u_int	hi_speed;

	u_char	*start;		/* upper layer buffer start */
	u_char	*end;		/* upper layer buffer end */
	u_char	*cur;		/* current position in upper layer buffer */
	int	blksize;	/* chunk size to report up */
	int	transferred;	/* transferred bytes not reported up */

	int	altidx;		/* currently used altidx */

	int	curchanbuf;
	int	cursyncbuf;

	struct chanbuf {
		struct chan	*chan;
		struct usbd_xfer *xfer;
		u_char		*buffer;
		u_int16_t	sizes[UAUDIO_MAX_FRAMES];
		u_int16_t	offsets[UAUDIO_MAX_FRAMES];
		u_int16_t	size;
	} chanbufs[UAUDIO_NCHANBUFS];

	struct syncbuf {
		struct chan	*chan;
		struct usbd_xfer *xfer;
		u_char		*buffer;
		u_int16_t	sizes[UAUDIO_MAX_FRAMES];
		u_int16_t	offsets[UAUDIO_MAX_FRAMES];
		u_int16_t	size;
	} syncbufs[UAUDIO_NSYNCBUFS];

	struct uaudio_softc *sc; /* our softc */
};

#define UAUDIO_FLAG_BAD_AUDIO	 0x0001	/* claims audio class, but isn't */
#define UAUDIO_FLAG_NO_FRAC	 0x0002	/* don't use fractional samples */
#define UAUDIO_FLAG_NO_XU	 0x0004	/* has broken extension unit */
#define UAUDIO_FLAG_BAD_ADC	 0x0008	/* bad audio spec version number */
#define UAUDIO_FLAG_VENDOR_CLASS 0x0010	/* claims vendor class but works */
#define UAUDIO_FLAG_DEPENDENT	 0x0020	/* play and record params must equal */
#define UAUDIO_FLAG_EMU0202	 0x0040

struct uaudio_devs {
	struct usb_devno	 uv_dev;
	int			 flags;
} uaudio_devs[] = {
	{ { USB_VENDOR_YAMAHA, USB_PRODUCT_YAMAHA_UR22 },
		UAUDIO_FLAG_VENDOR_CLASS },
	{ { USB_VENDOR_ALTEC, USB_PRODUCT_ALTEC_ADA70 },
		UAUDIO_FLAG_BAD_ADC } ,
	{ { USB_VENDOR_ALTEC, USB_PRODUCT_ALTEC_ASC495 },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_3G },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_3GS },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_4_GSM },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_4_CDMA },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_4S },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPHONE_6 },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPOD_TOUCH },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPOD_TOUCH_2G },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPOD_TOUCH_3G },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPOD_TOUCH_4G },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPAD },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_APPLE, USB_PRODUCT_APPLE_IPAD2 },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_CREATIVE, USB_PRODUCT_CREATIVE_EMU0202 },
		UAUDIO_FLAG_VENDOR_CLASS | UAUDIO_FLAG_EMU0202 |
		UAUDIO_FLAG_DEPENDENT },
	{ { USB_VENDOR_DALLAS, USB_PRODUCT_DALLAS_J6502 },
		UAUDIO_FLAG_NO_XU | UAUDIO_FLAG_BAD_ADC },
	{ { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMNBDLX },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMPRONB },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMPRO4K },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_LOGITECH, USB_PRODUCT_LOGITECH_QUICKCAMZOOM },
		UAUDIO_FLAG_BAD_AUDIO },
	{ { USB_VENDOR_TELEX, USB_PRODUCT_TELEX_MIC1 },
		UAUDIO_FLAG_NO_FRAC }
};
#define uaudio_lookup(v, p) \
	((struct uaudio_devs *)usb_lookup(uaudio_devs, v, p))

struct uaudio_softc {
	struct device	 sc_dev;	/* base device */
	struct usbd_device *sc_udev;	/* USB device */
	int		 sc_ac_iface;	/* Audio Control interface */
	struct chan	 sc_playchan;	/* play channel */
	struct chan	 sc_recchan;	/* record channel */
	int		 sc_nullalt;
	int		 sc_audio_rev;
	struct as_info	*sc_alts;	/* alternate settings */
	int		 sc_nalts;	/* # of alternate settings */
	int		 sc_altflags;
#define HAS_8		 0x01
#define HAS_16		 0x02
#define HAS_8U		 0x04
#define HAS_ALAW	 0x08
#define HAS_MULAW	 0x10
#define UA_NOFRAC	 0x20		/* don't do sample rate adjustment */
#define HAS_24		 0x40
	int		 sc_mode;	/* play/record capability */
	struct mixerctl *sc_ctls;	/* mixer controls */
	int		 sc_nctls;	/* # of mixer controls */
	int		 sc_quirks;
};

struct terminal_list {
	int size;
	uint16_t terminals[1];
};
#define TERMINAL_LIST_SIZE(N)	(offsetof(struct terminal_list, terminals) \
				+ sizeof(uint16_t) * (N))

struct io_terminal {
	union {
		const usb_descriptor_t *desc;
		const struct usb_audio_input_terminal *it;
		const struct usb_audio_output_terminal *ot;
		const struct usb_audio_mixer_unit *mu;
		const struct usb_audio_selector_unit *su;
		const struct usb_audio_feature_unit *fu;
		const struct usb_audio_processing_unit *pu;
		const struct usb_audio_extension_unit *eu;
	} d;
	int inputs_size;
	struct terminal_list **inputs; /* list of source input terminals */
	struct terminal_list *output; /* list of destination output terminals */
	int direct;		/* directly connected to an output terminal */
};

#define UAC_OUTPUT	0
#define UAC_INPUT	1
#define UAC_EQUAL	2
#define UAC_RECORD	3
#define UAC_NCLASSES	4
#ifdef UAUDIO_DEBUG
const char *uac_names[] = {
	AudioCoutputs, AudioCinputs, AudioCequalization, AudioCrecord,
};
#endif

usbd_status uaudio_identify_ac
	(struct uaudio_softc *, const usb_config_descriptor_t *);
usbd_status uaudio_identify_as
	(struct uaudio_softc *, const usb_config_descriptor_t *);
usbd_status uaudio_process_as
	(struct uaudio_softc *, const char *, int *, int,
	 const usb_interface_descriptor_t *);

void	uaudio_add_alt(struct uaudio_softc *, const struct as_info *);

const usb_interface_descriptor_t *uaudio_find_iface
	(const char *, int, int *, int, int);

void	uaudio_mixer_add_ctl(struct uaudio_softc *, struct mixerctl *);
char	*uaudio_id_name
	(struct uaudio_softc *, const struct io_terminal *, int);
uByte	uaudio_get_cluster_nchan
	(int, const struct io_terminal *);
void	uaudio_add_input
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_output
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_mixer
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_selector
	(struct uaudio_softc *, const struct io_terminal *, int);
#ifdef UAUDIO_DEBUG
const char *uaudio_get_terminal_name(int);
#endif
int	uaudio_determine_class
	(const struct io_terminal *, struct mixerctl *);
const char *uaudio_feature_name
	(const struct io_terminal *, struct mixerctl *);
void	uaudio_add_feature
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_processing_updown
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_processing
	(struct uaudio_softc *, const struct io_terminal *, int);
void	uaudio_add_extension
	(struct uaudio_softc *, const struct io_terminal *, int);
struct terminal_list *uaudio_merge_terminal_list
	(const struct io_terminal *);
struct terminal_list *uaudio_io_terminaltype
	(int, struct io_terminal *, int);
usbd_status uaudio_identify
	(struct uaudio_softc *, const usb_config_descriptor_t *);

int	uaudio_signext(int, int);
int	uaudio_unsignext(int, int);
int	uaudio_value2bsd(struct mixerctl *, int);
int	uaudio_bsd2value(struct mixerctl *, int);
int	uaudio_get(struct uaudio_softc *, int, int, int, int, int);
int	uaudio_ctl_get
	(struct uaudio_softc *, int, struct mixerctl *, int);
void	uaudio_set
	(struct uaudio_softc *, int, int, int, int, int, int);
void	uaudio_ctl_set
	(struct uaudio_softc *, int, struct mixerctl *, int, int);

usbd_status uaudio_set_speed(struct uaudio_softc *, int, u_int);
void	uaudio_set_speed_emu0202(struct chan *ch);

usbd_status uaudio_chan_open(struct uaudio_softc *, struct chan *);
void	uaudio_chan_close(struct uaudio_softc *, struct chan *);
usbd_status uaudio_chan_alloc_buffers
	(struct uaudio_softc *, struct chan *);
void	uaudio_chan_free_buffers(struct uaudio_softc *, struct chan *);
void	uaudio_chan_init
	(struct chan *, int, int, const struct audio_params *);
void	uaudio_chan_set_param(struct chan *, u_char *, u_char *, int);
void	uaudio_chan_ptransfer(struct chan *);
void	uaudio_chan_pintr
	(struct usbd_xfer *, void *, usbd_status);
void	uaudio_chan_psync_transfer(struct chan *);
void	uaudio_chan_psync_intr
	(struct usbd_xfer *, void *, usbd_status);

void	uaudio_chan_rtransfer(struct chan *);
void	uaudio_chan_rintr
	(struct usbd_xfer *, void *, usbd_status);

int	uaudio_open(void *, int);
void	uaudio_close(void *);
int	uaudio_drain(void *);
void	uaudio_get_minmax_rates
	(int, const struct as_info *, const struct audio_params *,
	 int, int, int, u_long *, u_long *);
int	uaudio_match_alt_rate(void *, int, int);
int	uaudio_match_alt(void *, struct audio_params *, int);
int	uaudio_set_params
	(void *, int, int, struct audio_params *, struct audio_params *);
int	uaudio_round_blocksize(void *, int);
int	uaudio_trigger_output
	(void *, void *, void *, int, void (*)(void *), void *,
	 struct audio_params *);
int	uaudio_trigger_input
	(void *, void *, void *, int, void (*)(void *), void *,
	 struct audio_params *);
int	uaudio_halt_in_dma(void *);
int	uaudio_halt_out_dma(void *);
int	uaudio_mixer_set_port(void *, mixer_ctrl_t *);
int	uaudio_mixer_get_port(void *, mixer_ctrl_t *);
int	uaudio_query_devinfo(void *, mixer_devinfo_t *);
int	uaudio_get_props(void *);

struct audio_hw_if uaudio_hw_if = {
	uaudio_open,
	uaudio_close,
	uaudio_set_params,
	uaudio_round_blocksize,
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	uaudio_halt_out_dma,
	uaudio_halt_in_dma,
	NULL,
	NULL,
	uaudio_mixer_set_port,
	uaudio_mixer_get_port,
	uaudio_query_devinfo,
	NULL,
	NULL,
	NULL,
	uaudio_get_props,
	uaudio_trigger_output,
	uaudio_trigger_input
};

int uaudio_match(struct device *, void *, void *); 
void uaudio_attach(struct device *, struct device *, void *); 
int uaudio_detach(struct device *, int); 

struct cfdriver uaudio_cd = { 
	NULL, "uaudio", DV_DULL 
}; 

const struct cfattach uaudio_ca = {
	sizeof(struct uaudio_softc), uaudio_match, uaudio_attach, uaudio_detach
};

int
uaudio_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	const usb_interface_descriptor_t *cd_id;
	usb_config_descriptor_t *cdesc;
	struct uaudio_devs *quirk;
	const char *buf;
	int flags = 0, size, offs;

	if (uaa->iface == NULL || uaa->device == NULL)
		return (UMATCH_NONE);

	quirk = uaudio_lookup(uaa->vendor, uaa->product);
	if (quirk)
		flags = quirk->flags;

	if (flags & UAUDIO_FLAG_BAD_AUDIO)
		return (UMATCH_NONE);

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL)
		return (UMATCH_NONE);

	if (!(id->bInterfaceClass == UICLASS_AUDIO ||
	    ((flags & UAUDIO_FLAG_VENDOR_CLASS) &&
	    id->bInterfaceClass == UICLASS_VENDOR)))
		return (UMATCH_NONE);

	if (id->bInterfaceSubClass != UISUBCLASS_AUDIOCONTROL)
		return (UMATCH_NONE);

	cdesc = usbd_get_config_descriptor(uaa->device);
	if (cdesc == NULL)
		return (UMATCH_NONE);

	size = UGETW(cdesc->wTotalLength);
	buf = (const char *)cdesc;

	offs = 0;
	cd_id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM,
	    flags);
	if (cd_id == NULL)
		return (UMATCH_NONE);

	offs = 0;
	cd_id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL,
	    flags);
	if (cd_id == NULL)
		return (UMATCH_NONE);

	return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);
}

void
uaudio_attach(struct device *parent, struct device *self, void *aux)
{
	struct uaudio_softc *sc = (struct uaudio_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uaudio_devs *quirk;
	usb_interface_descriptor_t *id;
	usb_config_descriptor_t *cdesc;
	usbd_status err;
	int i, j, found;

	sc->sc_udev = uaa->device;

	quirk = uaudio_lookup(uaa->vendor, uaa->product);
	if (quirk)
		sc->sc_quirks = quirk->flags;

	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		       sc->sc_dev.dv_xname);
		return;
	}

	err = uaudio_identify(sc, cdesc);
	if (err) {
		printf("%s: audio descriptors make no sense, error=%d\n",
		       sc->sc_dev.dv_xname, err);
		return;
	}

	/* Pick up the AS interface. */
	for (i = 0; i < uaa->nifaces; i++) {
		if (usbd_iface_claimed(sc->sc_udev, i))
			continue;
		id = usbd_get_interface_descriptor(uaa->ifaces[i]);
		if (id == NULL)
			continue;
		found = 0;
		for (j = 0; j < sc->sc_nalts; j++) {
			if (id->bInterfaceNumber ==
			    sc->sc_alts[j].idesc->bInterfaceNumber) {
				sc->sc_alts[j].ifaceh = uaa->ifaces[i];
				found = 1;
			}
		}
		if (found)
			usbd_claim_iface(sc->sc_udev, i);
	}

	for (j = 0; j < sc->sc_nalts; j++) {
		if (sc->sc_alts[j].ifaceh == NULL) {
			printf("%s: alt %d missing AS interface(s)\n",
			    sc->sc_dev.dv_xname, j);
			return;
		}
	}

	printf("%s: audio rev %d.%02x", sc->sc_dev.dv_xname,
	       sc->sc_audio_rev >> 8, sc->sc_audio_rev & 0xff);

	sc->sc_playchan.sc = sc->sc_recchan.sc = sc;
	sc->sc_playchan.altidx = -1;
	sc->sc_recchan.altidx = -1;

	if (sc->sc_quirks & UAUDIO_FLAG_NO_FRAC)
		sc->sc_altflags |= UA_NOFRAC;

	printf(", %d mixer controls\n", sc->sc_nctls);

	DPRINTF(("%s: doing audio_attach_mi\n", __func__));
	audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
}

int
uaudio_detach(struct device *self, int flags)
{
	struct uaudio_softc *sc = (struct uaudio_softc *)self;
	int rv = 0;

	/*
	 * sc_alts may be NULL if uaudio_identify_as() failed, in
	 * which case uaudio_attach() didn't finish and there's
	 * nothing to detach.
	 */
	if (sc->sc_alts == NULL)
		return (rv);

	/* Wait for outstanding requests to complete. */
	uaudio_drain(sc);

	rv = config_detach_children(self, flags);

	return (rv);
}

const usb_interface_descriptor_t *
uaudio_find_iface(const char *buf, int size, int *offsp, int subtype, int flags)
{
	const usb_interface_descriptor_t *d;

	while (*offsp < size) {
		d = (const void *)(buf + *offsp);
		*offsp += d->bLength;
		if (d->bDescriptorType == UDESC_INTERFACE &&
		    d->bInterfaceSubClass == subtype &&
		    (d->bInterfaceClass == UICLASS_AUDIO ||
		    (d->bInterfaceClass == UICLASS_VENDOR &&
		    (flags & UAUDIO_FLAG_VENDOR_CLASS))))
			return (d);
	}
	return (NULL);
}

void
uaudio_mixer_add_ctl(struct uaudio_softc *sc, struct mixerctl *mc)
{
	int res, range;
	size_t len;
	struct mixerctl *nmc;

	if (mc->class < UAC_NCLASSES) {
		DPRINTF(("%s: adding %s.%s\n",
			 __func__, uac_names[mc->class], mc->ctlname));
	} else {
		DPRINTF(("%s: adding %s\n", __func__, mc->ctlname));
	}

	nmc = mallocarray(sc->sc_nctls + 1, sizeof(*mc), M_USBDEV, M_NOWAIT);
	if (nmc == NULL) {
		printf("%s: no memory\n", __func__);
		return;
	}
	len = sizeof(*mc) * (sc->sc_nctls + 1);

	/* Copy old data, if there was any */
	if (sc->sc_nctls != 0) {
		memcpy(nmc, sc->sc_ctls, sizeof(*mc) * (sc->sc_nctls));
		free(sc->sc_ctls, M_USBDEV, 0);
	}
	sc->sc_ctls = nmc;

	mc->delta = 0;
	if (mc->type == MIX_ON_OFF) {
		mc->minval = 0;
		mc->maxval = 1;
	} else if (mc->type == MIX_SELECTOR) {
		;
	} else {
		/* Determine min and max values. */
		mc->minval = uaudio_signext(mc->type,
			uaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE,
				   mc->wValue[0], mc->wIndex,
				   MIX_SIZE(mc->type)));
		mc->maxval = uaudio_signext(mc->type,
			uaudio_get(sc, GET_MAX, UT_READ_CLASS_INTERFACE,
				   mc->wValue[0], mc->wIndex,
				   MIX_SIZE(mc->type)));
		range = mc->maxval - mc->minval;
		res = uaudio_get(sc, GET_RES, UT_READ_CLASS_INTERFACE,
				 mc->wValue[0], mc->wIndex,
				 MIX_SIZE(mc->type));
		if (res > 0 && range > 0)
			mc->delta = (res * 255 + res - 1) / range;
	}

	sc->sc_ctls[sc->sc_nctls++] = *mc;

#ifdef UAUDIO_DEBUG
	if (uaudiodebug > 2) {
		int i;
		DPRINTF(("%s: wValue=%04x", __func__, mc->wValue[0]));
		for (i = 1; i < mc->nchan; i++)
			DPRINTF((",%04x", mc->wValue[i]));
		DPRINTF((" wIndex=%04x type=%d name='%s' unit='%s' "
			 "min=%d max=%d\n",
			 mc->wIndex, mc->type, mc->ctlname, mc->ctlunit,
			 mc->minval, mc->maxval));
	}
#endif
}

char *
uaudio_id_name(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	static char buf[32];
	snprintf(buf, sizeof(buf), "i%d", id);
	return (buf);
}

uByte
uaudio_get_cluster_nchan(int id, const struct io_terminal *iot)
{
	struct usb_audio_cluster r;
	const usb_descriptor_t *dp;
	int i;

	for (i = 0; i < 25; i++) { /* avoid infinite loops */
		dp = iot[id].d.desc;
		if (dp == 0)
			goto bad;
		switch (dp->bDescriptorSubtype) {
		case UDESCSUB_AC_INPUT:
			return (iot[id].d.it->bNrChannels);
		case UDESCSUB_AC_OUTPUT:
			id = iot[id].d.ot->bSourceId;
			break;
		case UDESCSUB_AC_MIXER:
			r = *(struct usb_audio_cluster *)
				&iot[id].d.mu->baSourceId[iot[id].d.mu->bNrInPins];
			return (r.bNrChannels);
		case UDESCSUB_AC_SELECTOR:
			/* XXX This is not really right */
			id = iot[id].d.su->baSourceId[0];
			break;
		case UDESCSUB_AC_FEATURE:
			id = iot[id].d.fu->bSourceId;
			break;
		case UDESCSUB_AC_PROCESSING:
			r = *(struct usb_audio_cluster *)
				&iot[id].d.pu->baSourceId[iot[id].d.pu->bNrInPins];
			return (r.bNrChannels);
		case UDESCSUB_AC_EXTENSION:
			r = *(struct usb_audio_cluster *)
				&iot[id].d.eu->baSourceId[iot[id].d.eu->bNrInPins];
			return (r.bNrChannels);
		default:
			goto bad;
		}
	}
bad:
	printf("%s: bad data\n", __func__);
	return (0);
}

void
uaudio_add_input(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
#ifdef UAUDIO_DEBUG
	const struct usb_audio_input_terminal *d = iot[id].d.it;

	DPRINTFN(2,("%s: bTerminalId=%d wTerminalType=0x%04x "
		    "bAssocTerminal=%d bNrChannels=%d wChannelConfig=%d "
		    "iChannelNames=%d iTerminal=%d\n",
		    __func__,
		    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,
		    d->bNrChannels, UGETW(d->wChannelConfig),
		    d->iChannelNames, d->iTerminal));
#endif
}

void
uaudio_add_output(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
#ifdef UAUDIO_DEBUG
	const struct usb_audio_output_terminal *d = iot[id].d.ot;

	DPRINTFN(2,("%s: bTerminalId=%d wTerminalType=0x%04x "
		    "bAssocTerminal=%d bSourceId=%d iTerminal=%d\n",
		    __func__,
		    d->bTerminalId, UGETW(d->wTerminalType), d->bAssocTerminal,
		    d->bSourceId, d->iTerminal));
#endif
}

void
uaudio_add_mixer(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	const struct usb_audio_mixer_unit *d = iot[id].d.mu;
	struct usb_audio_mixer_unit_1 *d1;
	int c, chs, ichs, ochs, i, o, bno, p, mo, mc, k;
	uByte *bm;
	struct mixerctl mix;

	DPRINTFN(2,("%s: bUnitId=%d bNrInPins=%d\n", __func__,
		    d->bUnitId, d->bNrInPins));

	/* Compute the number of input channels */
	ichs = 0;
	for (i = 0; i < d->bNrInPins; i++)
		ichs += uaudio_get_cluster_nchan(d->baSourceId[i], iot);

	/* and the number of output channels */
	d1 = (struct usb_audio_mixer_unit_1 *)&d->baSourceId[d->bNrInPins];
	ochs = d1->bNrChannels;
	DPRINTFN(2,("%s: ichs=%d ochs=%d\n", __func__, ichs, ochs));

	bm = d1->bmControls;
	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
	uaudio_determine_class(&iot[id], &mix);
	mix.type = MIX_SIGNED_16;
	mix.ctlunit = AudioNvolume;
#define BIT(bno) ((bm[bno / 8] >> (7 - bno % 8)) & 1)
	for (p = i = 0; i < d->bNrInPins; i++) {
		chs = uaudio_get_cluster_nchan(d->baSourceId[i], iot);
		mc = 0;
		for (c = 0; c < chs; c++) {
			mo = 0;
			for (o = 0; o < ochs; o++) {
				bno = (p + c) * ochs + o;
				if (BIT(bno))
					mo++;
			}
			if (mo == 1)
				mc++;
		}
		if (mc == chs && chs <= MIX_MAX_CHAN) {
			k = 0;
			for (c = 0; c < chs; c++)
				for (o = 0; o < ochs; o++) {
					bno = (p + c) * ochs + o;
					if (BIT(bno))
						mix.wValue[k++] =
							MAKE(p+c+1, o+1);
				}
			snprintf(mix.ctlname, sizeof(mix.ctlname), "mix%d-%s",
			    d->bUnitId, uaudio_id_name(sc, iot,
			    d->baSourceId[i]));
			mix.nchan = chs;
			uaudio_mixer_add_ctl(sc, &mix);
		} else {
			/* XXX */
		}
#undef BIT
		p += chs;
	}

}

void
uaudio_add_selector(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	const struct usb_audio_selector_unit *d = iot[id].d.su;
	struct mixerctl mix;
	int i, wp;

	DPRINTFN(2,("%s: bUnitId=%d bNrInPins=%d\n", __func__,
		    d->bUnitId, d->bNrInPins));
	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
	mix.wValue[0] = MAKE(0, 0);
	uaudio_determine_class(&iot[id], &mix);
	mix.nchan = 1;
	mix.type = MIX_SELECTOR;
	mix.ctlunit = "";
	mix.minval = 1;
	mix.maxval = d->bNrInPins;
	wp = snprintf(mix.ctlname, MAX_AUDIO_DEV_LEN, "sel%d-", d->bUnitId);
	for (i = 1; i <= d->bNrInPins; i++) {
		wp += snprintf(mix.ctlname + wp, MAX_AUDIO_DEV_LEN - wp,
			       "i%d", d->baSourceId[i - 1]);
		if (wp > MAX_AUDIO_DEV_LEN - 1)
			break;
	}
	uaudio_mixer_add_ctl(sc, &mix);
}

#ifdef UAUDIO_DEBUG
const char *
uaudio_get_terminal_name(int terminal_type)
{
	static char buf[100];

	switch (terminal_type) {
	/* USB terminal types */
	case UAT_UNDEFINED:	return "UAT_UNDEFINED";
	case UAT_STREAM:	return "UAT_STREAM";
	case UAT_VENDOR:	return "UAT_VENDOR";
	/* input terminal types */
	case UATI_UNDEFINED:	return "UATI_UNDEFINED";
	case UATI_MICROPHONE:	return "UATI_MICROPHONE";
	case UATI_DESKMICROPHONE:	return "UATI_DESKMICROPHONE";
	case UATI_PERSONALMICROPHONE:	return "UATI_PERSONALMICROPHONE";
	case UATI_OMNIMICROPHONE:	return "UATI_OMNIMICROPHONE";
	case UATI_MICROPHONEARRAY:	return "UATI_MICROPHONEARRAY";
	case UATI_PROCMICROPHONEARR:	return "UATI_PROCMICROPHONEARR";
	/* output terminal types */
	case UATO_UNDEFINED:	return "UATO_UNDEFINED";
	case UATO_SPEAKER:	return "UATO_SPEAKER";
	case UATO_HEADPHONES:	return "UATO_HEADPHONES";
	case UATO_DISPLAYAUDIO:	return "UATO_DISPLAYAUDIO";
	case UATO_DESKTOPSPEAKER:	return "UATO_DESKTOPSPEAKER";
	case UATO_ROOMSPEAKER:	return "UATO_ROOMSPEAKER";
	case UATO_COMMSPEAKER:	return "UATO_COMMSPEAKER";
	case UATO_SUBWOOFER:	return "UATO_SUBWOOFER";
	/* bidir terminal types */
	case UATB_UNDEFINED:	return "UATB_UNDEFINED";
	case UATB_HANDSET:	return "UATB_HANDSET";
	case UATB_HEADSET:	return "UATB_HEADSET";
	case UATB_SPEAKERPHONE:	return "UATB_SPEAKERPHONE";
	case UATB_SPEAKERPHONEESUP:	return "UATB_SPEAKERPHONEESUP";
	case UATB_SPEAKERPHONEECANC:	return "UATB_SPEAKERPHONEECANC";
	/* telephony terminal types */
	case UATT_UNDEFINED:	return "UATT_UNDEFINED";
	case UATT_PHONELINE:	return "UATT_PHONELINE";
	case UATT_TELEPHONE:	return "UATT_TELEPHONE";
	case UATT_DOWNLINEPHONE:	return "UATT_DOWNLINEPHONE";
	/* external terminal types */
	case UATE_UNDEFINED:	return "UATE_UNDEFINED";
	case UATE_ANALOGCONN:	return "UATE_ANALOGCONN";
	case UATE_LINECONN:	return "UATE_LINECONN";
	case UATE_LEGACYCONN:	return "UATE_LEGACYCONN";
	case UATE_DIGITALAUIFC:	return "UATE_DIGITALAUIFC";
	case UATE_SPDIF:	return "UATE_SPDIF";
	case UATE_1394DA:	return "UATE_1394DA";
	case UATE_1394DV:	return "UATE_1394DV";
	/* embedded function terminal types */
	case UATF_UNDEFINED:	return "UATF_UNDEFINED";
	case UATF_CALIBNOISE:	return "UATF_CALIBNOISE";
	case UATF_EQUNOISE:	return "UATF_EQUNOISE";
	case UATF_CDPLAYER:	return "UATF_CDPLAYER";
	case UATF_DAT:	return "UATF_DAT";
	case UATF_DCC:	return "UATF_DCC";
	case UATF_MINIDISK:	return "UATF_MINIDISK";
	case UATF_ANALOGTAPE:	return "UATF_ANALOGTAPE";
	case UATF_PHONOGRAPH:	return "UATF_PHONOGRAPH";
	case UATF_VCRAUDIO:	return "UATF_VCRAUDIO";
	case UATF_VIDEODISCAUDIO:	return "UATF_VIDEODISCAUDIO";
	case UATF_DVDAUDIO:	return "UATF_DVDAUDIO";
	case UATF_TVTUNERAUDIO:	return "UATF_TVTUNERAUDIO";
	case UATF_SATELLITE:	return "UATF_SATELLITE";
	case UATF_CABLETUNER:	return "UATF_CABLETUNER";
	case UATF_DSS:	return "UATF_DSS";
	case UATF_RADIORECV:	return "UATF_RADIORECV";
	case UATF_RADIOXMIT:	return "UATF_RADIOXMIT";
	case UATF_MULTITRACK:	return "UATF_MULTITRACK";
	case UATF_SYNTHESIZER:	return "UATF_SYNTHESIZER";
	default:
		snprintf(buf, sizeof(buf), "unknown type (0x%.4x)", terminal_type);
		return buf;
	}
}
#endif

int
uaudio_determine_class(const struct io_terminal *iot, struct mixerctl *mix)
{
	int terminal_type;

	if (iot == NULL || iot->output == NULL) {
		mix->class = UAC_OUTPUT;
		return 0;
	}
	terminal_type = 0;
	if (iot->output->size == 1)
		terminal_type = iot->output->terminals[0];
	/*
	 * If the only output terminal is USB,
	 * the class is UAC_RECORD.
	 */
	if ((terminal_type & 0xff00) == (UAT_UNDEFINED & 0xff00)) {
		mix->class = UAC_RECORD;
		if (iot->inputs_size == 1
		    && iot->inputs[0] != NULL
		    && iot->inputs[0]->size == 1)
			return iot->inputs[0]->terminals[0];
		else
			return 0;
	}
	/*
	 * If the ultimate destination of the unit is just one output
	 * terminal and the unit is connected to the output terminal
	 * directly, the class is UAC_OUTPUT.
	 */
	if (terminal_type != 0 && iot->direct) {
		mix->class = UAC_OUTPUT;
		return terminal_type;
	}
	/*
	 * If the unit is connected to just one input terminal,
	 * the class is UAC_INPUT.
	 */
	if (iot->inputs_size == 1 && iot->inputs[0] != NULL
	    && iot->inputs[0]->size == 1) {
		mix->class = UAC_INPUT;
		return iot->inputs[0]->terminals[0];
	}
	/*
	 * Otherwise, the class is UAC_OUTPUT.
	 */
	mix->class = UAC_OUTPUT;
	return terminal_type;
}

const char *
uaudio_feature_name(const struct io_terminal *iot, struct mixerctl *mix)
{
	int terminal_type;

	terminal_type = uaudio_determine_class(iot, mix);
	if (mix->class == UAC_RECORD && terminal_type == 0)
		return AudioNmixerout;
	DPRINTF(("%s: terminal_type=%s\n", __func__,
		 uaudio_get_terminal_name(terminal_type)));
	switch (terminal_type) {
	case UAT_STREAM:
		return AudioNdac;

	case UATI_MICROPHONE:
	case UATI_DESKMICROPHONE:
	case UATI_PERSONALMICROPHONE:
	case UATI_OMNIMICROPHONE:
	case UATI_MICROPHONEARRAY:
	case UATI_PROCMICROPHONEARR:
		return AudioNmicrophone;

	case UATO_SPEAKER:
	case UATO_DESKTOPSPEAKER:
	case UATO_ROOMSPEAKER:
	case UATO_COMMSPEAKER:
		return AudioNspeaker;

	case UATO_HEADPHONES:
		return AudioNheadphone;

	case UATO_SUBWOOFER:
		return AudioNlfe;

	/* telephony terminal types */
	case UATT_UNDEFINED:
	case UATT_PHONELINE:
	case UATT_TELEPHONE:
	case UATT_DOWNLINEPHONE:
		return "phone";

	case UATE_ANALOGCONN:
	case UATE_LINECONN:
	case UATE_LEGACYCONN:
		return AudioNline;

	case UATE_DIGITALAUIFC:
	case UATE_SPDIF:
	case UATE_1394DA:
	case UATE_1394DV:
		return AudioNaux;

	case UATF_CDPLAYER:
		return AudioNcd;

	case UATF_SYNTHESIZER:
		return AudioNfmsynth;

	case UATF_VIDEODISCAUDIO:
	case UATF_DVDAUDIO:
	case UATF_TVTUNERAUDIO:
		return AudioNvideo;

	case UAT_UNDEFINED:
	case UAT_VENDOR:
	case UATI_UNDEFINED:
/* output terminal types */
	case UATO_UNDEFINED:
	case UATO_DISPLAYAUDIO:
/* bidir terminal types */
	case UATB_UNDEFINED:
	case UATB_HANDSET:
	case UATB_HEADSET:
	case UATB_SPEAKERPHONE:
	case UATB_SPEAKERPHONEESUP:
	case UATB_SPEAKERPHONEECANC:
/* external terminal types */
	case UATE_UNDEFINED:
/* embedded function terminal types */
	case UATF_UNDEFINED:
	case UATF_CALIBNOISE:
	case UATF_EQUNOISE:
	case UATF_DAT:
	case UATF_DCC:
	case UATF_MINIDISK:
	case UATF_ANALOGTAPE:
	case UATF_PHONOGRAPH:
	case UATF_VCRAUDIO:
	case UATF_SATELLITE:
	case UATF_CABLETUNER:
	case UATF_DSS:
	case UATF_RADIORECV:
	case UATF_RADIOXMIT:
	case UATF_MULTITRACK:
	case 0xffff:
	default:
		DPRINTF(("%s: 'master' for 0x%.4x\n", __func__, terminal_type));
		return AudioNmaster;
	}
}

void
uaudio_add_feature(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	const struct usb_audio_feature_unit *d = iot[id].d.fu;
	uByte *ctls = (uByte *)d->bmaControls;
	int ctlsize = d->bControlSize;
	int nchan = (d->bLength - 7) / ctlsize;
	u_int fumask, mmask, cmask;
	struct mixerctl mix;
	int chan, ctl, i, unit;
	const char *mixername;

#define GET(i) (ctls[(i)*ctlsize] | \
		(ctlsize > 1 ? ctls[(i)*ctlsize+1] << 8 : 0))

	mmask = GET(0);
	/* Figure out what we can control */
	for (cmask = 0, chan = 1; chan < nchan; chan++) {
		DPRINTFN(9,("%s: chan=%d mask=%x\n",
			    __func__, chan, GET(chan)));
		cmask |= GET(chan);
	}

	DPRINTFN(1,("%s: bUnitId=%d, "
		    "%d channels, mmask=0x%04x, cmask=0x%04x\n",
		    __func__, d->bUnitId, nchan, mmask, cmask));

	if (nchan > MIX_MAX_CHAN)
		nchan = MIX_MAX_CHAN;
	unit = d->bUnitId;
	mix.wIndex = MAKE(unit, sc->sc_ac_iface);
	for (ctl = MUTE_CONTROL; ctl < LOUDNESS_CONTROL; ctl++) {
		fumask = FU_MASK(ctl);
		DPRINTFN(4,("%s: ctl=%d fumask=0x%04x\n",
			    __func__, ctl, fumask));
		if (mmask & fumask) {
			mix.nchan = 1;
			mix.wValue[0] = MAKE(ctl, 0);
		} else if (cmask & fumask) {
			mix.nchan = nchan - 1;
			for (i = 1; i < nchan; i++) {
				if (GET(i) & fumask)
					mix.wValue[i-1] = MAKE(ctl, i);
				else
					mix.wValue[i-1] = -1;
			}
		} else {
			continue;
		}
#undef GET
		mixername = uaudio_feature_name(&iot[id], &mix);
		switch (ctl) {
		case MUTE_CONTROL:
			mix.type = MIX_ON_OFF;
			mix.ctlunit = "";
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNmute);
			break;
		case VOLUME_CONTROL:
			mix.type = MIX_SIGNED_16;
			mix.ctlunit = AudioNvolume;
			strlcpy(mix.ctlname, mixername, sizeof(mix.ctlname));
			break;
		case BASS_CONTROL:
			mix.type = MIX_SIGNED_8;
			mix.ctlunit = AudioNbass;
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNbass);
			break;
		case MID_CONTROL:
			mix.type = MIX_SIGNED_8;
			mix.ctlunit = AudioNmid;
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNmid);
			break;
		case TREBLE_CONTROL:
			mix.type = MIX_SIGNED_8;
			mix.ctlunit = AudioNtreble;
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNtreble);
			break;
		case GRAPHIC_EQUALIZER_CONTROL:
			continue; /* XXX don't add anything */
			break;
		case AGC_CONTROL:
			mix.type = MIX_ON_OFF;
			mix.ctlunit = "";
			snprintf(mix.ctlname, sizeof(mix.ctlname), "%s.%s",
				 mixername, AudioNagc);
			break;
		case DELAY_CONTROL:
			mix.type = MIX_UNSIGNED_16;
			mix.ctlunit = "4 ms";
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNdelay);
			break;
		case BASS_BOOST_CONTROL:
			mix.type = MIX_ON_OFF;
			mix.ctlunit = "";
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNbassboost);
			break;
		case LOUDNESS_CONTROL:
			mix.type = MIX_ON_OFF;
			mix.ctlunit = "";
			snprintf(mix.ctlname, sizeof(mix.ctlname),
				 "%s.%s", mixername, AudioNloudness);
			break;
		}
		uaudio_mixer_add_ctl(sc, &mix);
	}
}

void
uaudio_add_processing_updown(struct uaudio_softc *sc,
			     const struct io_terminal *iot, int id)
{
	const struct usb_audio_processing_unit *d = iot[id].d.pu;
	const struct usb_audio_processing_unit_1 *d1 =
	    (const struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
	const struct usb_audio_processing_unit_updown *ud =
	    (const struct usb_audio_processing_unit_updown *)
		&d1->bmControls[d1->bControlSize];
	struct mixerctl mix;
	int i;

	DPRINTFN(2,("%s: bUnitId=%d bNrModes=%d\n",
		    __func__, d->bUnitId, ud->bNrModes));

	if (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {
		DPRINTF(("%s: no mode select\n", __func__));
		return;
	}

	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
	mix.nchan = 1;
	mix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);
	uaudio_determine_class(&iot[id], &mix);
	mix.type = MIX_ON_OFF;	/* XXX */
	mix.ctlunit = "";
	snprintf(mix.ctlname, sizeof(mix.ctlname), "pro%d-mode", d->bUnitId);

	for (i = 0; i < ud->bNrModes; i++) {
		DPRINTFN(2,("%s: i=%d bm=0x%x\n",
			    __func__, i, UGETW(ud->waModes[i])));
		/* XXX */
	}
	uaudio_mixer_add_ctl(sc, &mix);
}

void
uaudio_add_processing(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	const struct usb_audio_processing_unit *d = iot[id].d.pu;
	const struct usb_audio_processing_unit_1 *d1 =
	    (const struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
	int ptype = UGETW(d->wProcessType);
	struct mixerctl mix;

	DPRINTFN(2,("%s: wProcessType=%d bUnitId=%d "
		    "bNrInPins=%d\n", __func__, ptype, d->bUnitId,
		    d->bNrInPins));

	if (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {
		mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
		mix.nchan = 1;
		mix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);
		uaudio_determine_class(&iot[id], &mix);
		mix.type = MIX_ON_OFF;
		mix.ctlunit = "";
		snprintf(mix.ctlname, sizeof(mix.ctlname), "pro%d.%d-enable",
		    d->bUnitId, ptype);
		uaudio_mixer_add_ctl(sc, &mix);
	}

	switch(ptype) {
	case UPDOWNMIX_PROCESS:
		uaudio_add_processing_updown(sc, iot, id);
		break;
	case DOLBY_PROLOGIC_PROCESS:
	case P3D_STEREO_EXTENDER_PROCESS:
	case REVERBATION_PROCESS:
	case CHORUS_PROCESS:
	case DYN_RANGE_COMP_PROCESS:
	default:
		DPRINTF(("%s: unit %d, type=%d not impl.\n",
		       __func__, d->bUnitId, ptype));
		break;
	}
}

void
uaudio_add_extension(struct uaudio_softc *sc, const struct io_terminal *iot, int id)
{
	const struct usb_audio_extension_unit *d = iot[id].d.eu;
	const struct usb_audio_extension_unit_1 *d1 =
	    (const struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];
	struct mixerctl mix;

	DPRINTFN(2,("%s: bUnitId=%d bNrInPins=%d\n",
		    __func__, d->bUnitId, d->bNrInPins));

	if (sc->sc_quirks & UAUDIO_FLAG_NO_XU)
		return;

	if (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {
		mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
		mix.nchan = 1;
		mix.wValue[0] = MAKE(UA_EXT_ENABLE, 0);
		uaudio_determine_class(&iot[id], &mix);
		mix.type = MIX_ON_OFF;
		mix.ctlunit = "";
		snprintf(mix.ctlname, sizeof(mix.ctlname), "ext%d-enable",
		    d->bUnitId);
		uaudio_mixer_add_ctl(sc, &mix);
	}
}

struct terminal_list*
uaudio_merge_terminal_list(const struct io_terminal *iot)
{
	struct terminal_list *tml;
	uint16_t *ptm;
	int i, len;

	len = 0;
	if (iot->inputs == NULL)
		return NULL;
	for (i = 0; i < iot->inputs_size; i++) {
		if (iot->inputs[i] != NULL)
			len += iot->inputs[i]->size;
	}
	tml = malloc(TERMINAL_LIST_SIZE(len), M_TEMP, M_NOWAIT);
	if (tml == NULL) {
		printf("%s: no memory\n", __func__);
		return NULL;
	}
	tml->size = 0;
	ptm = tml->terminals;
	for (i = 0; i < iot->inputs_size; i++) {
		if (iot->inputs[i] == NULL)
			continue;
		if (iot->inputs[i]->size > len)
			break;
		memcpy(ptm, iot->inputs[i]->terminals,
		       iot->inputs[i]->size * sizeof(uint16_t));
		tml->size += iot->inputs[i]->size;
		ptm += iot->inputs[i]->size;
		len -= iot->inputs[i]->size;
	}
	return tml;
}

struct terminal_list *
uaudio_io_terminaltype(int outtype, struct io_terminal *iot, int id)
{
	struct terminal_list *tml;
	struct io_terminal *it;
	int src_id, i;

	it = &iot[id];
	if (it->output != NULL) {
		/* already has outtype? */
		for (i = 0; i < it->output->size; i++)
			if (it->output->terminals[i] == outtype)
				return uaudio_merge_terminal_list(it);
		tml = malloc(TERMINAL_LIST_SIZE(it->output->size + 1),
		    M_TEMP, M_NOWAIT);
		if (tml == NULL) {
			printf("%s: no memory\n", __func__);
			return uaudio_merge_terminal_list(it);
		}
		memcpy(tml, it->output, TERMINAL_LIST_SIZE(it->output->size));
		tml->terminals[it->output->size] = outtype;
		tml->size++;
		free(it->output, M_TEMP, 0);
		it->output = tml;
		if (it->inputs != NULL) {
			for (i = 0; i < it->inputs_size; i++)
				if (it->inputs[i] != NULL)
					free(it->inputs[i], M_TEMP, 0);
			free(it->inputs, M_TEMP, 0);
		}
		it->inputs_size = 0;
		it->inputs = NULL;
	} else {		/* end `iot[id] != NULL' */
		it->inputs_size = 0;
		it->inputs = NULL;
		it->output = malloc(TERMINAL_LIST_SIZE(1), M_TEMP, M_NOWAIT);
		if (it->output == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		it->output->terminals[0] = outtype;
		it->output->size = 1;
		it->direct = 0;
	}

	switch (it->d.desc->bDescriptorSubtype) {
	case UDESCSUB_AC_INPUT:
		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		tml = malloc(TERMINAL_LIST_SIZE(1), M_TEMP, M_NOWAIT);
		if (tml == NULL) {
			printf("%s: no memory\n", __func__);
			free(it->inputs, M_TEMP, 0);
			it->inputs = NULL;
			return NULL;
		}
		it->inputs[0] = tml;
		tml->terminals[0] = UGETW(it->d.it->wTerminalType);
		tml->size = 1;
		it->inputs_size = 1;
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_FEATURE:
		src_id = it->d.fu->bSourceId;
		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return uaudio_io_terminaltype(outtype, iot, src_id);
		}
		it->inputs[0] = uaudio_io_terminaltype(outtype, iot, src_id);
		it->inputs_size = 1;
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_OUTPUT:
		it->inputs = malloc(sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		src_id = it->d.ot->bSourceId;
		it->inputs[0] = uaudio_io_terminaltype(outtype, iot, src_id);
		it->inputs_size = 1;
		iot[src_id].direct = 1;
		return NULL;
	case UDESCSUB_AC_MIXER:
		it->inputs_size = 0;
		it->inputs = mallocarray(it->d.mu->bNrInPins,
		    sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		for (i = 0; i < it->d.mu->bNrInPins; i++) {
			src_id = it->d.mu->baSourceId[i];
			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
							       src_id);
			it->inputs_size++;
		}
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_SELECTOR:
		it->inputs_size = 0;
		it->inputs = mallocarray(it->d.su->bNrInPins,
		    sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		for (i = 0; i < it->d.su->bNrInPins; i++) {
			src_id = it->d.su->baSourceId[i];
			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
							       src_id);
			it->inputs_size++;
		}
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_PROCESSING:
		it->inputs_size = 0;
		it->inputs = mallocarray(it->d.pu->bNrInPins,
		    sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		for (i = 0; i < it->d.pu->bNrInPins; i++) {
			src_id = it->d.pu->baSourceId[i];
			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
							       src_id);
			it->inputs_size++;
		}
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_EXTENSION:
		it->inputs_size = 0;
		it->inputs = mallocarray(it->d.eu->bNrInPins,
		    sizeof(struct terminal_list *), M_TEMP, M_NOWAIT);
		if (it->inputs == NULL) {
			printf("%s: no memory\n", __func__);
			return NULL;
		}
		for (i = 0; i < it->d.eu->bNrInPins; i++) {
			src_id = it->d.eu->baSourceId[i];
			it->inputs[i] = uaudio_io_terminaltype(outtype, iot,
							       src_id);
			it->inputs_size++;
		}
		return uaudio_merge_terminal_list(it);
	case UDESCSUB_AC_HEADER:
	default:
		return NULL;
	}
}

usbd_status
uaudio_identify(struct uaudio_softc *sc, const usb_config_descriptor_t *cdesc)
{
	usbd_status err;

	err = uaudio_identify_ac(sc, cdesc);
	if (err)
		return (err);
	return (uaudio_identify_as(sc, cdesc));
}

void
uaudio_add_alt(struct uaudio_softc *sc, const struct as_info *ai)
{
	struct as_info *nai;

	nai = mallocarray(sc->sc_nalts + 1, sizeof(*ai), M_USBDEV, M_NOWAIT);
	if (nai == NULL) {
		printf("%s: no memory\n", __func__);
		return;
	}

	/* Copy old data, if there was any */
	if (sc->sc_nalts != 0) {
		memcpy(nai, sc->sc_alts, sizeof(*ai) * (sc->sc_nalts));
		free(sc->sc_alts, M_USBDEV, 0);
	}
	sc->sc_alts = nai;
	DPRINTFN(2,("%s: adding alt=%d, enc=%d\n",
		    __func__, ai->alt, ai->encoding));
	sc->sc_alts[sc->sc_nalts++] = *ai;
}

usbd_status
uaudio_process_as(struct uaudio_softc *sc, const char *buf, int *offsp,
		  int size, const usb_interface_descriptor_t *id)
#define offs (*offsp)
{
	const struct usb_audio_streaming_interface_descriptor *asid;
	const struct usb_audio_streaming_type1_descriptor *asf1d;
	const struct usb_endpoint_descriptor_audio *ed;
	const struct usb_endpoint_descriptor_audio *sync_ed;
	const struct usb_audio_streaming_endpoint_descriptor *sed;
	int format, chan, prec, enc, bps;
	int dir, type, sync, sync_addr;
	struct as_info ai;
	const char *format_str;

	asid = (const void *)(buf + offs);
	if (asid->bDescriptorType != UDESC_CS_INTERFACE ||
	    asid->bDescriptorSubtype != AS_GENERAL)
		return (USBD_INVAL);
	DPRINTF(("%s: asid: bTerminalLink=%d wFormatTag=%d\n", __func__,
		 asid->bTerminalLink, UGETW(asid->wFormatTag)));
	offs += asid->bLength;
	if (offs > size)
		return (USBD_INVAL);

	asf1d = (const void *)(buf + offs);
	if (asf1d->bDescriptorType != UDESC_CS_INTERFACE ||
	    asf1d->bDescriptorSubtype != FORMAT_TYPE)
		return (USBD_INVAL);
	offs += asf1d->bLength;
	if (offs > size)
		return (USBD_INVAL);

	if (asf1d->bFormatType != FORMAT_TYPE_I) {
		printf("%s: ignored setting with type %d format\n",
		       sc->sc_dev.dv_xname, UGETW(asid->wFormatTag));
		return (USBD_NORMAL_COMPLETION);
	}

	ed = (const void *)(buf + offs);
	if (ed->bDescriptorType != UDESC_ENDPOINT)
		return (USBD_INVAL);
	DPRINTF(("%s: endpoint[0] bLength=%d bDescriptorType=%d "
		 "bEndpointAddress=%d bmAttributes=0x%x wMaxPacketSize=%d "
		 "bInterval=%d bRefresh=%d bSynchAddress=%d\n",
		 __func__,
		 ed->bLength, ed->bDescriptorType, ed->bEndpointAddress,
		 ed->bmAttributes, UGETW(ed->wMaxPacketSize),
		 ed->bInterval, ed->bRefresh, ed->bSynchAddress));
	offs += ed->bLength;
	if (offs > size)
		return (USBD_INVAL);
	if (UE_GET_XFERTYPE(ed->bmAttributes) != UE_ISOCHRONOUS)
		return (USBD_INVAL);

	dir = UE_GET_DIR(ed->bEndpointAddress);
	type = UE_GET_ISO_TYPE(ed->bmAttributes);

	/* Check for sync endpoint. */
	sync = 0;
	sync_addr = 0;
	if (id->bNumEndpoints > 1 &&
	    ((dir == UE_DIR_IN && type == UE_ISO_ADAPT) ||
	    (dir != UE_DIR_IN && type == UE_ISO_ASYNC)))
		sync = 1;

	/* Check whether sync endpoint address is given. */
	if (ed->bLength >= USB_ENDPOINT_DESCRIPTOR_AUDIO_SIZE) {
		/* bSynchAdress set to 0 indicates sync is not used. */
		if (ed->bSynchAddress == 0)
			sync = 0;
		else
			sync_addr = ed->bSynchAddress;
	}

	sed = (const void *)(buf + offs);
	if (sed->bDescriptorType != UDESC_CS_ENDPOINT ||
	    sed->bDescriptorSubtype != AS_GENERAL)
		return (USBD_INVAL);
	DPRINTF((" streaming_endpoint: offset=%d bLength=%d\n", offs, sed->bLength));
	offs += sed->bLength;
	if (offs > size)
		return (USBD_INVAL);

	sync_ed = NULL;
	if (sync == 1) {
		sync_ed = (const void*)(buf + offs);
		if (sync_ed->bDescriptorType != UDESC_ENDPOINT) {
			printf("%s: sync ep descriptor wrong type\n",
			    sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		DPRINTF(("%s: endpoint[1] bLength=%d "
			 "bDescriptorType=%d bEndpointAddress=%d "
			 "bmAttributes=0x%x wMaxPacketSize=%d bInterval=%d "
			 "bRefresh=%d bSynchAddress=%d\n",
			 __func__,
			 sync_ed->bLength, sync_ed->bDescriptorType,
			 sync_ed->bEndpointAddress, sync_ed->bmAttributes,
			 UGETW(sync_ed->wMaxPacketSize), sync_ed->bInterval,
			 sync_ed->bRefresh, sync_ed->bSynchAddress));
		offs += sync_ed->bLength;
		if (offs > size) {
			printf("%s: sync ep descriptor too large\n",
			    sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (dir == UE_GET_DIR(sync_ed->bEndpointAddress)) {
			printf("%s: sync ep wrong direction\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (UE_GET_XFERTYPE(sync_ed->bmAttributes) != UE_ISOCHRONOUS) {
			printf("%s: sync ep wrong xfer type\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (sync_ed->bLength >=
		    USB_ENDPOINT_DESCRIPTOR_AUDIO_SIZE &&
		    sync_ed->bSynchAddress != 0) {
			printf("%s: sync ep bSynchAddress != 0\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (sync_addr &&
		    UE_GET_ADDR(sync_ed->bEndpointAddress) !=
		    UE_GET_ADDR(sync_addr)) {
			printf("%s: sync ep address mismatch\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
	}
	if (sync_ed != NULL && dir == UE_DIR_IN) {
		printf("%s: sync pipe for recording not yet implemented\n",
		    sc->sc_dev.dv_xname);
		return (USBD_NORMAL_COMPLETION);
	}

	format = UGETW(asid->wFormatTag);
	chan = asf1d->bNrChannels;
	prec = asf1d->bBitResolution;
	bps = asf1d->bSubFrameSize;
	if ((prec != 8 && prec != 16 && prec != 24) || (bps < 1 || bps > 4)) {
		printf("%s: ignored setting with precision %d bps %d\n",
		       sc->sc_dev.dv_xname, prec, bps);
		return (USBD_NORMAL_COMPLETION);
	}
	switch (format) {
	case UA_FMT_PCM:
		if (prec == 8) {
			sc->sc_altflags |= HAS_8;
		} else if (prec == 16) {
			sc->sc_altflags |= HAS_16;
		} else if (prec == 24) {
			sc->sc_altflags |= HAS_24;
		}
		enc = AUDIO_ENCODING_SLINEAR_LE;
		format_str = "pcm";
		break;
	case UA_FMT_PCM8:
		enc = AUDIO_ENCODING_ULINEAR_LE;
		sc->sc_altflags |= HAS_8U;
		format_str = "pcm8";
		break;
	case UA_FMT_ALAW:
		enc = AUDIO_ENCODING_ALAW;
		sc->sc_altflags |= HAS_ALAW;
		format_str = "alaw";
		break;
	case UA_FMT_MULAW:
		enc = AUDIO_ENCODING_ULAW;
		sc->sc_altflags |= HAS_MULAW;
		format_str = "mulaw";
		break;
	case UA_FMT_IEEE_FLOAT:
	default:
		printf("%s: ignored setting with format %d\n",
		       sc->sc_dev.dv_xname, format);
		return (USBD_NORMAL_COMPLETION);
	}
#ifdef UAUDIO_DEBUG
	printf("%s: %s: %d-ch %d-bit %d-byte %s,", sc->sc_dev.dv_xname,
	       dir == UE_DIR_IN ? "recording" : "playback",
	       chan, prec, bps, format_str);
	if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
		printf(" %d-%dHz\n", UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d));
	} else {
		int r;
		printf(" %d", UA_GETSAMP(asf1d, 0));
		for (r = 1; r < asf1d->bSamFreqType; r++)
			printf(",%d", UA_GETSAMP(asf1d, r));
		printf("Hz\n");
	}
#endif
	ai.alt = id->bAlternateSetting;
	ai.encoding = enc;
	ai.attributes = sed->bmAttributes;
	ai.idesc = id;
	ai.edesc = ed;
	ai.edesc1 = sync_ed;
	ai.asf1desc = asf1d;
	ai.sc_busy = 0;
	if (sc->sc_nalts < UAUDIO_MAX_ALTS)
		uaudio_add_alt(sc, &ai);
#ifdef UAUDIO_DEBUG
	if (ai.attributes & UA_SED_FREQ_CONTROL)
		DPRINTFN(1, ("%s:  FREQ_CONTROL\n", __func__));
	if (ai.attributes & UA_SED_PITCH_CONTROL)
		DPRINTFN(1, ("%s:  PITCH_CONTROL\n", __func__));
#endif
	sc->sc_mode |= (dir == UE_DIR_OUT) ? AUMODE_PLAY : AUMODE_RECORD;

	return (USBD_NORMAL_COMPLETION);
}
#undef offs

usbd_status
uaudio_identify_as(struct uaudio_softc *sc,
		   const usb_config_descriptor_t *cdesc)
{
	const usb_interface_descriptor_t *id;
	const char *buf;
	int size, offs;

	size = UGETW(cdesc->wTotalLength);
	buf = (const char *)cdesc;

	/* Locate the AudioStreaming interface descriptor. */
	offs = 0;
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM,
	    sc->sc_quirks);
	if (id == NULL)
		return (USBD_INVAL);

	/* Loop through all the alternate settings. */
	while (offs <= size) {
		DPRINTFN(2, ("%s: interface=%d offset=%d\n",
		    __func__, id->bInterfaceNumber, offs));
		switch (id->bNumEndpoints) {
		case 0:
			DPRINTFN(2, ("%s: AS null alt=%d\n",
				     __func__, id->bAlternateSetting));
			sc->sc_nullalt = id->bAlternateSetting;
			break;
		case 1:
		case 2:
			uaudio_process_as(sc, buf, &offs, size, id);
			break;
		default:
			printf("%s: ignored audio interface with %d "
			       "endpoints\n",
			       sc->sc_dev.dv_xname, id->bNumEndpoints);
			break;
		}
		id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM,
		    sc->sc_quirks);
		if (id == NULL)
			break;
	}
	if (offs > size)
		return (USBD_INVAL);
	DPRINTF(("%s: %d alts available\n", __func__, sc->sc_nalts));

	if (sc->sc_mode == 0) {
		printf("%s: no usable endpoint found\n",
		       sc->sc_dev.dv_xname);
		return (USBD_INVAL);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uaudio_identify_ac(struct uaudio_softc *sc, const usb_config_descriptor_t *cdesc)
{
	struct io_terminal* iot;
	const usb_interface_descriptor_t *id;
	const struct usb_audio_control_descriptor *acdp;
	const usb_descriptor_t *dp;
	const struct usb_audio_output_terminal *pot;
	struct terminal_list *tml;
	const char *buf, *ibuf, *ibufend;
	int size, offs, aclen, ndps, i, j;

	size = UGETW(cdesc->wTotalLength);
	buf = (char *)cdesc;

	/* Locate the AudioControl interface descriptor. */
	offs = 0;
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL,
	    sc->sc_quirks);
	if (id == NULL)
		return (USBD_INVAL);
	if (offs + sizeof *acdp > size)
		return (USBD_INVAL);
	sc->sc_ac_iface = id->bInterfaceNumber;
	DPRINTFN(2,("%s: AC interface is %d\n", 
	    __func__, sc->sc_ac_iface));

	/* A class-specific AC interface header should follow. */
	ibuf = buf + offs;
	acdp = (const struct usb_audio_control_descriptor *)ibuf;
	if (acdp->bDescriptorType != UDESC_CS_INTERFACE ||
	    acdp->bDescriptorSubtype != UDESCSUB_AC_HEADER)
		return (USBD_INVAL);
	aclen = UGETW(acdp->wTotalLength);
	if (offs + aclen > size)
		return (USBD_INVAL);

	if (!(sc->sc_quirks & UAUDIO_FLAG_BAD_ADC) &&
	     UGETW(acdp->bcdADC) != UAUDIO_VERSION)
		return (USBD_INVAL);

	sc->sc_audio_rev = UGETW(acdp->bcdADC);
	DPRINTFN(2,("%s: found AC header, vers=%03x, len=%d\n",
		 __func__, sc->sc_audio_rev, aclen));

	sc->sc_nullalt = -1;

	/* Scan through all the AC specific descriptors */
	ibufend = ibuf + aclen;
	dp = (const usb_descriptor_t *)ibuf;
	ndps = 0;
	iot = mallocarray(256, sizeof(struct io_terminal),
	    M_TEMP, M_NOWAIT | M_ZERO);
	if (iot == NULL) {
		printf("%s: no memory\n", __func__);
		return USBD_NOMEM;
	}
	for (;;) {
		ibuf += dp->bLength;
		if (ibuf >= ibufend)
			break;
		dp = (const usb_descriptor_t *)ibuf;
		if (ibuf + dp->bLength > ibufend) {
			free(iot, M_TEMP, 0);
			return (USBD_INVAL);
		}
		if (dp->bDescriptorType != UDESC_CS_INTERFACE) {
			printf("%s: skip desc type=0x%02x\n",
			       __func__, dp->bDescriptorType);
			continue;
		}
		i = ((const struct usb_audio_input_terminal *)dp)->bTerminalId;
		iot[i].d.desc = dp;
		if (i > ndps)
			ndps = i;
	}
	ndps++;

	/* construct io_terminal */
	for (i = 0; i < ndps; i++) {
		dp = iot[i].d.desc;
		if (dp == NULL)
			continue;
		if (dp->bDescriptorSubtype != UDESCSUB_AC_OUTPUT)
			continue;
		pot = iot[i].d.ot;
		tml = uaudio_io_terminaltype(UGETW(pot->wTerminalType), iot, i);
		if (tml != NULL)
			free(tml, M_TEMP, 0);
	}

#ifdef UAUDIO_DEBUG
	for (i = 0; i < 256; i++) {
		if (iot[i].d.desc == NULL)
			continue;
		printf("id %d:\t", i);
		switch (iot[i].d.desc->bDescriptorSubtype) {
		case UDESCSUB_AC_INPUT:
			printf("AC_INPUT type=%s\n", uaudio_get_terminal_name
			       (UGETW(iot[i].d.it->wTerminalType)));
			break;
		case UDESCSUB_AC_OUTPUT:
			printf("AC_OUTPUT type=%s ", uaudio_get_terminal_name
			       (UGETW(iot[i].d.ot->wTerminalType)));
			printf("src=%d\n", iot[i].d.ot->bSourceId);
			break;
		case UDESCSUB_AC_MIXER:
			printf("AC_MIXER src=");
			for (j = 0; j < iot[i].d.mu->bNrInPins; j++)
				printf("%d ", iot[i].d.mu->baSourceId[j]);
			printf("\n");
			break;
		case UDESCSUB_AC_SELECTOR:
			printf("AC_SELECTOR src=");
			for (j = 0; j < iot[i].d.su->bNrInPins; j++)
				printf("%d ", iot[i].d.su->baSourceId[j]);
			printf("\n");
			break;
		case UDESCSUB_AC_FEATURE:
			printf("AC_FEATURE src=%d\n", iot[i].d.fu->bSourceId);
			break;
		case UDESCSUB_AC_PROCESSING:
			printf("AC_PROCESSING src=");
			for (j = 0; j < iot[i].d.pu->bNrInPins; j++)
				printf("%d ", iot[i].d.pu->baSourceId[j]);
			printf("\n");
			break;
		case UDESCSUB_AC_EXTENSION:
			printf("AC_EXTENSION src=");
			for (j = 0; j < iot[i].d.eu->bNrInPins; j++)
				printf("%d ", iot[i].d.eu->baSourceId[j]);
			printf("\n");
			break;
		default:
			printf("unknown audio control (subtype=%d)\n",
			       iot[i].d.desc->bDescriptorSubtype);
		}
		for (j = 0; j < iot[i].inputs_size; j++) {
			int k;
			printf("\tinput%d: ", j);
			tml = iot[i].inputs[j];
			if (tml == NULL) {
				printf("NULL\n");
				continue;
			}
			for (k = 0; k < tml->size; k++)
				printf("%s ", uaudio_get_terminal_name
				       (tml->terminals[k]));
			printf("\n");
		}
		printf("\toutput: ");
		tml = iot[i].output;
		for (j = 0; j < tml->size; j++)
			printf("%s ", uaudio_get_terminal_name(tml->terminals[j]));
		printf("\n");
	}
#endif

	for (i = 0; i < ndps; i++) {
		dp = iot[i].d.desc;
		if (dp == NULL)
			continue;
		DPRINTF(("%s: id=%d subtype=%d\n",
			 __func__, i, dp->bDescriptorSubtype));
		switch (dp->bDescriptorSubtype) {
		case UDESCSUB_AC_HEADER:
			printf("%s: unexpected AC header\n", __func__);
			break;
		case UDESCSUB_AC_INPUT:
			uaudio_add_input(sc, iot, i);
			break;
		case UDESCSUB_AC_OUTPUT:
			uaudio_add_output(sc, iot, i);
			break;
		case UDESCSUB_AC_MIXER:
			uaudio_add_mixer(sc, iot, i);
			break;
		case UDESCSUB_AC_SELECTOR:
			uaudio_add_selector(sc, iot, i);
			break;
		case UDESCSUB_AC_FEATURE:
			uaudio_add_feature(sc, iot, i);
			break;
		case UDESCSUB_AC_PROCESSING:
			uaudio_add_processing(sc, iot, i);
			break;
		case UDESCSUB_AC_EXTENSION:
			uaudio_add_extension(sc, iot, i);
			break;
		default:
			printf("%s: bad AC desc subtype=0x%02x\n",
			       __func__, dp->bDescriptorSubtype);
			break;
		}
	}

	/* delete io_terminal */
	for (i = 0; i < 256; i++) {
		if (iot[i].d.desc == NULL)
			continue;
		if (iot[i].inputs != NULL) {
			for (j = 0; j < iot[i].inputs_size; j++) {
				if (iot[i].inputs[j] != NULL)
					free(iot[i].inputs[j], M_TEMP, 0);
			}
			free(iot[i].inputs, M_TEMP, 0);
		}
		if (iot[i].output != NULL)
			free(iot[i].output, M_TEMP, 0);
		iot[i].d.desc = NULL;
	}
	free(iot, M_TEMP, 0);

	return (USBD_NORMAL_COMPLETION);
}

int
uaudio_query_devinfo(void *addr, mixer_devinfo_t *mi)
{
	struct uaudio_softc *sc = addr;
	struct mixerctl *mc;
	int n, nctls, i;

	DPRINTFN(2,("%s: index=%d\n", __func__, mi->index));
	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	n = mi->index;
	nctls = sc->sc_nctls;

	switch (n) {
	case UAC_OUTPUT:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_OUTPUT;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCoutputs, sizeof(mi->label.name));
		return (0);
	case UAC_INPUT:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_INPUT;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCinputs, sizeof(mi->label.name));
		return (0);
	case UAC_EQUAL:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_EQUAL;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCequalization,
		    sizeof(mi->label.name));
		return (0);
	case UAC_RECORD:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_RECORD;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCrecord, sizeof(mi->label.name));
		return 0;
	default:
		break;
	}

	n -= UAC_NCLASSES;
	if (n < 0 || n >= nctls)
		return (ENXIO);

	mc = &sc->sc_ctls[n];
	strlcpy(mi->label.name, mc->ctlname, sizeof(mi->label.name));
	mi->mixer_class = mc->class;
	mi->next = mi->prev = AUDIO_MIXER_LAST;	/* XXX */
	switch (mc->type) {
	case MIX_ON_OFF:
		mi->type = AUDIO_MIXER_ENUM;
		mi->un.e.num_mem = 2;
		strlcpy(mi->un.e.member[0].label.name, AudioNoff,
		    sizeof(mi->un.e.member[0].label.name));
		mi->un.e.member[0].ord = 0;
		strlcpy(mi->un.e.member[1].label.name, AudioNon,
		    sizeof(mi->un.e.member[1].label.name));
		mi->un.e.member[1].ord = 1;
		break;
	case MIX_SELECTOR:
		mi->type = AUDIO_MIXER_ENUM;
		mi->un.e.num_mem = mc->maxval - mc->minval + 1;
		for (i = 0; i <= mc->maxval - mc->minval; i++) {
			snprintf(mi->un.e.member[i].label.name,
				 sizeof(mi->un.e.member[i].label.name),
				 "%d", i + mc->minval);
			mi->un.e.member[i].ord = i + mc->minval;
		}
		break;
	default:
		mi->type = AUDIO_MIXER_VALUE;
		strlcpy(mi->un.v.units.name, mc->ctlunit,
		    sizeof(mi->un.v.units.name));
		mi->un.v.num_channels = mc->nchan;
		mi->un.v.delta = mc->delta;
		break;
	}
	return (0);
}

int
uaudio_open(void *addr, int flags)
{
	struct uaudio_softc *sc = addr;

	DPRINTF(("%s: sc=%p\n", __func__, sc));
	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if ((flags & FWRITE) && !(sc->sc_mode & AUMODE_PLAY))
		return (ENXIO);
	if ((flags & FREAD) && !(sc->sc_mode & AUMODE_RECORD))
		return (ENXIO);

	return (0);
}

/*
 * Close function is called at splaudio().
 */
void
uaudio_close(void *addr)
{
	struct uaudio_softc *sc = addr;

	if (sc->sc_playchan.altidx != -1)
		uaudio_chan_close(sc, &sc->sc_playchan);
	if (sc->sc_recchan.altidx != -1)
		uaudio_chan_close(sc, &sc->sc_recchan);
}

int
uaudio_drain(void *addr)
{
	struct uaudio_softc *sc = addr;
	struct chan *pchan = &sc->sc_playchan;
	struct chan *rchan = &sc->sc_recchan;
	int ms = 0;

	/* Wait for outstanding requests to complete. */
	if (pchan->altidx != -1 && sc->sc_alts[pchan->altidx].sc_busy)
		ms = max(ms, pchan->reqms);
	if (rchan->altidx != -1 && sc->sc_alts[rchan->altidx].sc_busy)
		ms = max(ms, rchan->reqms);
	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * ms);

	return (0);
}

int
uaudio_halt_out_dma(void *addr)
{
	struct uaudio_softc *sc = addr;

	DPRINTF(("%s: enter\n", __func__));
	if (sc->sc_playchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_playchan);
		sc->sc_playchan.pipe = NULL;
		if (sc->sc_playchan.sync_pipe != NULL)
			sc->sc_playchan.sync_pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_playchan);
		sc->sc_playchan.intr = NULL;
	}
	return (0);
}

int
uaudio_halt_in_dma(void *addr)
{
	struct uaudio_softc *sc = addr;

	DPRINTF(("%s: enter\n", __func__));
	if (sc->sc_recchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_recchan);
		sc->sc_recchan.pipe = NULL;
		if (sc->sc_recchan.sync_pipe != NULL)
			sc->sc_recchan.sync_pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_recchan);
		sc->sc_recchan.intr = NULL;
	}
	return (0);
}

/*
 * Make sure the block size is large enough to hold at least 1 transfer.
 * Ideally, the block size should be a multiple of the transfer size.
 * Currently, the transfer size for play and record can differ, and there's
 * no way to round playback and record blocksizes separately.
 */
int
uaudio_round_blocksize(void *addr, int blk)
{
	struct uaudio_softc *sc = addr;
	int bpf, pbpf, rbpf;

	DPRINTF(("%s: p.mbpf=%d r.mbpf=%d\n", __func__,
		 sc->sc_playchan.max_bytes_per_frame,
		 sc->sc_recchan.max_bytes_per_frame));

	pbpf = rbpf = 0;
	if (sc->sc_mode & AUMODE_PLAY) {
		pbpf = (sc->sc_playchan.max_bytes_per_frame) *
		    sc->sc_playchan.nframes;
	}
	if (sc->sc_mode & AUMODE_RECORD) {
		rbpf = (sc->sc_recchan.max_bytes_per_frame) *
		    sc->sc_recchan.nframes;
	}
	bpf = max(pbpf, rbpf);

	if (blk < bpf)
		blk = bpf;

#ifdef DIAGNOSTIC
	if (blk <= 0) {
		printf("%s: blk=%d\n", __func__, blk);
		blk = 512;
	}
#endif

	DPRINTFN(1,("%s: blk=%d\n", __func__, blk));
	return (blk);
}

int
uaudio_get_props(void *addr)
{
	struct uaudio_softc *sc = addr;
	int props = 0;

	if (!(sc->sc_quirks & UAUDIO_FLAG_DEPENDENT))
		props |= AUDIO_PROP_INDEPENDENT;

	if ((sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD)) ==
	    (AUMODE_PLAY | AUMODE_RECORD))
		props |= AUDIO_PROP_FULLDUPLEX;

	return props;
}

int
uaudio_get(struct uaudio_softc *sc, int which, int type, int wValue,
	   int wIndex, int len)
{
	usb_device_request_t req;
	u_int8_t data[4];
	usbd_status err;
	int val;

	if (wValue == -1)
		return (0);

	req.bmRequestType = type;
	req.bRequest = which;
	USETW(req.wValue, wValue);
	USETW(req.wIndex, wIndex);
	USETW(req.wLength, len);
	DPRINTFN(2,("%s: type=0x%02x req=0x%02x wValue=0x%04x "
		    "wIndex=0x%04x len=%d\n",
		    __func__, type, which, wValue, wIndex, len));
	err = usbd_do_request(sc->sc_udev, &req, data);
	if (err) {
		DPRINTF(("%s: err=%s\n", __func__, usbd_errstr(err)));
		return (-1);
	}
	switch (len) {
	case 1:
		val = data[0];
		break;
	case 2:
		val = data[0] | (data[1] << 8);
		break;
	default:
		DPRINTF(("%s: bad length=%d\n", __func__, len));
		return (-1);
	}
	DPRINTFN(2,("%s: val=%d\n", __func__, val));
	return (val);
}

void
uaudio_set(struct uaudio_softc *sc, int which, int type, int wValue,
	   int wIndex, int len, int val)
{
	usb_device_request_t req;
	u_int8_t data[4];
	usbd_status err;

	if (wValue == -1)
		return;

	req.bmRequestType = type;
	req.bRequest = which;
	USETW(req.wValue, wValue);
	USETW(req.wIndex, wIndex);
	USETW(req.wLength, len);
	switch (len) {
	case 1:
		data[0] = val;
		break;
	case 2:
		data[0] = val;
		data[1] = val >> 8;
		break;
	default:
		return;
	}
	DPRINTFN(2,("%s: type=0x%02x req=0x%02x wValue=0x%04x "
		    "wIndex=0x%04x len=%d, val=%d\n", __func__,
		    type, which, wValue, wIndex, len, val & 0xffff));
	err = usbd_do_request(sc->sc_udev, &req, data);
#ifdef UAUDIO_DEBUG
	if (err)
		DPRINTF(("%s: err=%d\n", __func__, err));
#endif
}

int
uaudio_signext(int type, int val)
{
	if (!MIX_UNSIGNED(type)) {
		if (MIX_SIZE(type) == 2)
			val = (int16_t)val;
		else
			val = (int8_t)val;
	}
	return (val);
}

int
uaudio_unsignext(int type, int val)
{
	if (!MIX_UNSIGNED(type)) {
		if (MIX_SIZE(type) == 2)
			val = (u_int16_t)val;
		else
			val = (u_int8_t)val;
	}
	return (val);
}

int
uaudio_value2bsd(struct mixerctl *mc, int val)
{
	int range;
	DPRINTFN(5, ("%s: type=%03x val=%d min=%d max=%d ",
		     __func__, mc->type, val, mc->minval, mc->maxval));
	if (mc->type == MIX_ON_OFF) {
		val = (val != 0);
	} else if (mc->type == MIX_SELECTOR) {
		if (val < mc->minval || val > mc->maxval)
			val = mc->minval;
	} else {
		range = mc->maxval - mc->minval;
		if (range == 0) 
			val = 0;
		else
			val = 255 * (uaudio_signext(mc->type, val) - 
			    mc->minval) / range;
	}
	DPRINTFN(5, ("val'=%d\n", val));
	return (val);
}

int
uaudio_bsd2value(struct mixerctl *mc, int val)
{
	DPRINTFN(5,("%s: type=%03x val=%d min=%d max=%d ",
		    __func__, mc->type, val, mc->minval, mc->maxval));
	if (mc->type == MIX_ON_OFF) {
		val = (val != 0);
	} else if (mc->type == MIX_SELECTOR) {
		if (val < mc->minval || val > mc->maxval)
			val = mc->minval;
	} else
		val = uaudio_unsignext(mc->type, 
		    val * (mc->maxval - mc->minval) / 255 + mc->minval);
	DPRINTFN(5, ("val'=%d\n", val));
	return (val);
}

int
uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc,
	       int chan)
{
	int val;

	DPRINTFN(5,("%s: which=%d chan=%d\n", __func__, which, chan));
	val = uaudio_get(sc, which, UT_READ_CLASS_INTERFACE, mc->wValue[chan],
			 mc->wIndex, MIX_SIZE(mc->type));
	return (uaudio_value2bsd(mc, val));
}

void
uaudio_ctl_set(struct uaudio_softc *sc, int which, struct mixerctl *mc,
	       int chan, int val)
{
	val = uaudio_bsd2value(mc, val);
	uaudio_set(sc, which, UT_WRITE_CLASS_INTERFACE, mc->wValue[chan],
		   mc->wIndex, MIX_SIZE(mc->type), val);
}

int
uaudio_mixer_get_port(void *addr, mixer_ctrl_t *cp)
{
	struct uaudio_softc *sc = addr;
	struct mixerctl *mc;
	int i, n, vals[MIX_MAX_CHAN], val;

	DPRINTFN(2,("%s: index=%d\n", __func__, cp->dev));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	n = cp->dev - UAC_NCLASSES;
	if (n < 0 || n >= sc->sc_nctls)
		return (ENXIO);
	mc = &sc->sc_ctls[n];

	if (mc->type == MIX_ON_OFF) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);
	} else if (mc->type == MIX_SELECTOR) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		cp->un.ord = uaudio_ctl_get(sc, GET_CUR, mc, 0);
	} else {
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		if (cp->un.value.num_channels != 1 &&
		    cp->un.value.num_channels != mc->nchan)
			return (EINVAL);
		for (i = 0; i < mc->nchan; i++)
			vals[i] = uaudio_ctl_get(sc, GET_CUR, mc, i);
		if (cp->un.value.num_channels == 1 && mc->nchan != 1) {
			for (val = 0, i = 0; i < mc->nchan; i++)
				val += vals[i];
			vals[0] = val / mc->nchan;
		}
		for (i = 0; i < cp->un.value.num_channels; i++)
			cp->un.value.level[i] = vals[i];
	}

	return (0);
}

int
uaudio_mixer_set_port(void *addr, mixer_ctrl_t *cp)
{
	struct uaudio_softc *sc = addr;
	struct mixerctl *mc;
	int i, n, vals[MIX_MAX_CHAN];

	DPRINTFN(2,("%s: index = %d\n", __func__, cp->dev));
	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	n = cp->dev - UAC_NCLASSES;
	if (n < 0 || n >= sc->sc_nctls)
		return (ENXIO);
	mc = &sc->sc_ctls[n];

	if (mc->type == MIX_ON_OFF) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		uaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);
	} else if (mc->type == MIX_SELECTOR) {
		if (cp->type != AUDIO_MIXER_ENUM)
			return (EINVAL);
		uaudio_ctl_set(sc, SET_CUR, mc, 0, cp->un.ord);
	} else {
		if (cp->type != AUDIO_MIXER_VALUE)
			return (EINVAL);
		if (cp->un.value.num_channels == 1)
			for (i = 0; i < mc->nchan; i++)
				vals[i] = cp->un.value.level[0];
		else if (cp->un.value.num_channels == mc->nchan)
			for (i = 0; i < mc->nchan; i++)
				vals[i] = cp->un.value.level[i];
		else
			return (EINVAL);
		for (i = 0; i < mc->nchan; i++)
			uaudio_ctl_set(sc, SET_CUR, mc, i, vals[i]);
	}
	return (0);
}

int
uaudio_trigger_input(void *addr, void *start, void *end, int blksize,
		     void (*intr)(void *), void *arg,
		     struct audio_params *param)
{
	struct uaudio_softc *sc = addr;
	struct chan *ch = &sc->sc_recchan;
	usbd_status err;
	int i, s;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTFN(3,("%s: sc=%p start=%p end=%p "
		    "blksize=%d\n", __func__, sc, start, end, blksize));

	uaudio_chan_set_param(ch, start, end, blksize);
	DPRINTFN(3,("%s: sample_size=%d bytes/frame=%d "
		    "fraction=0.%03d\n",
		    __func__, ch->sample_size, ch->bytes_per_frame,
		    ch->fraction));

	err = uaudio_chan_alloc_buffers(sc, ch);
	if (err)
		return (EIO);

	err = uaudio_chan_open(sc, ch);
	if (err) {
		uaudio_chan_free_buffers(sc, ch);
		return (EIO);
	}

	ch->intr = intr;
	ch->arg = arg;

	s = splusb();
	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
		uaudio_chan_rtransfer(ch);
	splx(s);

	return (0);
}

int
uaudio_trigger_output(void *addr, void *start, void *end, int blksize,
		      void (*intr)(void *), void *arg,
		      struct audio_params *param)
{
	struct uaudio_softc *sc = addr;
	struct chan *ch = &sc->sc_playchan;
	usbd_status err;
	int i, s;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTFN(3,("%s: sc=%p start=%p end=%p "
		    "blksize=%d\n", __func__, sc, start, end, blksize));

	uaudio_chan_set_param(ch, start, end, blksize);
	DPRINTFN(3,("%s: sample_size=%d bytes/frame=%d "
		    "fraction=0.%03d\n", __func__, ch->sample_size,
		    ch->bytes_per_frame, ch->fraction));

	err = uaudio_chan_alloc_buffers(sc, ch);
	if (err)
		return (EIO);

	err = uaudio_chan_open(sc, ch);
	if (err) {
		uaudio_chan_free_buffers(sc, ch);
		return (EIO);
	}

	ch->intr = intr;
	ch->arg = arg;

	s = splusb();
	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
		uaudio_chan_ptransfer(ch);
	if (ch->sync_pipe) {
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++)
			uaudio_chan_psync_transfer(ch);
	}
	splx(s);

	return (0);
}

/* Set up a pipe for a channel. */
usbd_status
uaudio_chan_open(struct uaudio_softc *sc, struct chan *ch)
{
	struct as_info *as = &sc->sc_alts[ch->altidx];
	int endpt = as->edesc->bEndpointAddress;
	usbd_status err;

	DPRINTF(("%s: endpt=0x%02x, speed=%d, alt=%d\n",
		 __func__, endpt, ch->sample_rate, as->alt));

	/* Set alternate interface corresponding to the mode. */
	err = usbd_set_interface(as->ifaceh, as->alt);
	if (err) {
		DPRINTF(("%s: usbd_set_interface failed\n", __func__));
		return (err);
	}

	/*
	 * If just one sampling rate is supported,
	 * no need to call uaudio_set_speed().
	 * Roland SD-90 freezes by a SAMPLING_FREQ_CONTROL request.
	 */
	if (as->asf1desc->bSamFreqType != 1) {
		err = uaudio_set_speed(sc, endpt, ch->sample_rate);
		if (err)
			DPRINTF(("%s: set_speed failed err=%s\n",
				 __func__, usbd_errstr(err)));
	}

	if (sc->sc_quirks & UAUDIO_FLAG_EMU0202)
		uaudio_set_speed_emu0202(ch);

	ch->pipe = 0;
	ch->sync_pipe = 0;
	DPRINTF(("%s: create pipe to 0x%02x\n", __func__, endpt));
	err = usbd_open_pipe(as->ifaceh, endpt, 0, &ch->pipe);
	if (err) {
		printf("%s: error creating pipe: err=%s endpt=0x%02x\n",
		    __func__, usbd_errstr(err), endpt);
		return err;
	}
	if (as->edesc1 != NULL) {
		endpt = as->edesc1->bEndpointAddress;
		DPRINTF(("%s: create sync-pipe to 0x%02x\n", __func__, endpt));
		err = usbd_open_pipe(as->ifaceh, endpt, 0, &ch->sync_pipe);
		if (err) {
			printf("%s: error creating sync-pipe: err=%s endpt=0x%02x\n",
			    __func__, usbd_errstr(err), endpt);
		}
	}
	return err;
}

void
uaudio_chan_close(struct uaudio_softc *sc, struct chan *ch)
{
	struct as_info *as = &sc->sc_alts[ch->altidx];

	as->sc_busy = 0;
	if (sc->sc_nullalt >= 0) {
		DPRINTF(("%s: set null alt=%d\n",
			 __func__, sc->sc_nullalt));
		usbd_set_interface(as->ifaceh, sc->sc_nullalt);
	}
	if (ch->pipe) {
		usbd_abort_pipe(ch->pipe);
		usbd_close_pipe(ch->pipe);
	}
	if (ch->sync_pipe) {
		usbd_abort_pipe(ch->sync_pipe);
		usbd_close_pipe(ch->sync_pipe);
	}
}

usbd_status
uaudio_chan_alloc_buffers(struct uaudio_softc *sc, struct chan *ch)
{
	struct as_info *as = &sc->sc_alts[ch->altidx];
	struct usbd_xfer *xfer;
	void *buf;
	int i, size;

	DPRINTF(("%s: max_bytes_per_frame=%d nframes=%d\n", __func__,
	    ch->max_bytes_per_frame, ch->nframes));

	size = ch->max_bytes_per_frame * ch->nframes;
	for (i = 0; i < UAUDIO_NCHANBUFS; i++) {
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
			goto bad;
		ch->chanbufs[i].xfer = xfer;
		buf = usbd_alloc_buffer(xfer, size);
		if (buf == 0) {
			i++;
			goto bad;
		}
		ch->chanbufs[i].buffer = buf;
		ch->chanbufs[i].chan = ch;
	}
	if (as->edesc1 != NULL) {
		size = (ch->hi_speed ? 4 : 3) * ch->nsync_frames;
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++) {
			xfer = usbd_alloc_xfer(sc->sc_udev);
			if (xfer == 0)
				goto bad_sync;
			ch->syncbufs[i].xfer = xfer;
			buf = usbd_alloc_buffer(xfer, size);
			if (buf == 0) {
				i++;
				goto bad_sync;
			}
			ch->syncbufs[i].buffer = buf;
			ch->syncbufs[i].chan = ch;
		}
	}

	return (USBD_NORMAL_COMPLETION);

bad:
	while (--i >= 0)
		/* implicit buffer free */
		usbd_free_xfer(ch->chanbufs[i].xfer);
	return (USBD_NOMEM);

bad_sync:
	while (--i >= 0)
		/* implicit buffer free */
		usbd_free_xfer(ch->syncbufs[i].xfer);
	return (USBD_NOMEM);

}

void
uaudio_chan_free_buffers(struct uaudio_softc *sc, struct chan *ch)
{
	struct as_info *as = &sc->sc_alts[ch->altidx];
	int i;

	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
		usbd_free_xfer(ch->chanbufs[i].xfer);
	if (as->edesc1 != NULL) {
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++)
			usbd_free_xfer(ch->syncbufs[i].xfer);
	}
}

/* Called at splusb() */
void
uaudio_chan_ptransfer(struct chan *ch)
{
	struct chanbuf *cb;
	u_char *pos;
	int i, n, size, residue, total;

	if (usbd_is_dying(ch->sc->sc_udev))
		return;

	/* Pick the next channel buffer. */
	cb = &ch->chanbufs[ch->curchanbuf];
	if (++ch->curchanbuf >= UAUDIO_NCHANBUFS)
		ch->curchanbuf = 0;

	/* Compute the size of each frame in the next transfer. */
	residue = ch->residue;
	total = 0;
	for (i = 0; i < ch->nframes; i++) {
		size = ch->bytes_per_frame;
		residue += ch->fraction;
		if (residue >= ch->frac_denom) {
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
				size += ch->sample_size;
			residue -= ch->frac_denom;
		}
		cb->sizes[i] = size;
		total += size;
	}
	ch->residue = residue;
	cb->size = total;

	/*
	 * Transfer data from upper layer buffer to channel buffer.  Be sure
	 * to let the upper layer know each time a block is moved, so it can
	 * add more.
	 */
	pos = cb->buffer;
	while (total > 0) {
		n = min(total, ch->end - ch->cur);
		n = min(n, ch->blksize - ch->transferred);
		memcpy(pos, ch->cur, n);
		total -= n;
		pos += n;
		ch->cur += n;
		if (ch->cur >= ch->end)
			ch->cur = ch->start;

		ch->transferred += n;
		/* Call back to upper layer */
		if (ch->transferred >= ch->blksize) {
			DPRINTFN(5,("%s: call %p(%p)\n",
				    __func__, ch->intr, ch->arg));
			mtx_enter(&audio_lock);
			ch->intr(ch->arg);
			mtx_leave(&audio_lock);
			ch->transferred -= ch->blksize;
		}
	}

#ifdef UAUDIO_DEBUG
	if (uaudiodebug > 8) {
		DPRINTF(("%s: buffer=%p, residue=0.%03d\n",
			 __func__, cb->buffer, ch->residue));
		for (i = 0; i < ch->nframes; i++) {
			DPRINTF(("   [%d] length %d\n", i, cb->sizes[i]));
		}
	}
#endif

	DPRINTFN(5,("%s: transfer xfer=%p\n", __func__, cb->xfer));
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, ch->nframes,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK, uaudio_chan_pintr);

	(void)usbd_transfer(cb->xfer);
}

void
uaudio_chan_pintr(struct usbd_xfer *xfer, void *priv,
		  usbd_status status)
{
	struct chanbuf *cb = priv;
	struct chan *ch = cb->chan;
	u_int32_t count;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("%s: count=%d, transferred=%d\n",
		    __func__, count, ch->transferred));
#ifdef UAUDIO_DEBUG
	if (count != cb->size) {
		printf("%s: count(%d) != size(%d)\n",
		       __func__, count, cb->size);
	}
#endif

	/* start next transfer */
	uaudio_chan_ptransfer(ch);
}

/* Called at splusb() */
void
uaudio_chan_psync_transfer(struct chan *ch)
{
	struct syncbuf *sb;
	int i, size, total = 0;

	if (usbd_is_dying(ch->sc->sc_udev))
		return;

	/* Pick the next sync buffer. */
	sb = &ch->syncbufs[ch->cursyncbuf];
	if (++ch->cursyncbuf >= UAUDIO_NSYNCBUFS)
		ch->cursyncbuf = 0;

	size = ch->hi_speed ? 4 : 3;
	for (i = 0; i < ch->nsync_frames; i++) {
		sb->sizes[i] = size;
		sb->offsets[i] = total;
		total += size;
	}
	sb->size = total;

	DPRINTFN(5,("%s: transfer xfer=%p\n", __func__, sb->xfer));
	usbd_setup_isoc_xfer(sb->xfer, ch->sync_pipe, sb, sb->sizes,
	    ch->nsync_frames, USBD_NO_COPY | USBD_SHORT_XFER_OK,
	    uaudio_chan_psync_intr);

	(void)usbd_transfer(sb->xfer);
}

void
uaudio_chan_psync_intr(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct syncbuf *sb = priv;
	struct chan *ch = sb->chan;
	u_int32_t count, tmp;
	u_int32_t freq, freq_w, freq_f;
	int i, pos, size;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("%s: count=%d\n", __func__, count));

	size = ch->hi_speed ? 4 : 3;
	for (i = 0; count > 0 && i < ch->nsync_frames; i++) {
		if (sb->sizes[i] != size)
			continue;
		count -= size;
		pos = sb->offsets[i];
		if (ch->hi_speed) {
			/* 16.16 (12.13) -> 16.16 (12.16) */
			freq = sb->buffer[pos+3] << 24 |
			    sb->buffer[pos+2] << 16 |
			    sb->buffer[pos+1] << 8 |
			    sb->buffer[pos];
		} else {
			/* 10.14 (10.10) -> 16.16 (10.16) */
			freq = sb->buffer[pos+2] << 18 |
			    sb->buffer[pos+1] << 10 |
			    sb->buffer[pos] << 2;
		}
		freq_w = (freq >> 16) & (ch->hi_speed ? 0x0fff : 0x03ff);
		freq_f = freq & 0xffff;
		DPRINTFN(5,("%s: freq = %d %d/%d\n", __func__, freq_w, freq_f,
		    ch->frac_denom));
		tmp = freq_w * ch->sample_size;
		if (tmp + (freq_f ? ch->sample_size : 0) >
		    ch->max_bytes_per_frame) {
			DPRINTF(("%s: packet size request too large: %d/%d/%d\n",
			    __func__, tmp, ch->max_bytes_per_frame, ch->maxpktsize));
		} else {
			ch->bytes_per_frame = tmp;
			ch->fraction = freq_f;
		}
	}

	/* start next transfer */
	uaudio_chan_psync_transfer(ch);
}

/* Called at splusb() */
void
uaudio_chan_rtransfer(struct chan *ch)
{
	struct chanbuf *cb;
	int i, size, total;

	if (usbd_is_dying(ch->sc->sc_udev))
		return;

	/* Pick the next channel buffer. */
	cb = &ch->chanbufs[ch->curchanbuf];
	if (++ch->curchanbuf >= UAUDIO_NCHANBUFS)
		ch->curchanbuf = 0;

	/* Compute the size of each frame in the next transfer. */
	total = 0;
	for (i = 0; i < ch->nframes; i++) {
		size = ch->bytes_per_frame;
		cb->sizes[i] = size;
		cb->offsets[i] = total;
		total += size;
	}
	cb->size = total;

#ifdef UAUDIO_DEBUG
	if (uaudiodebug > 8) {
		DPRINTF(("%s: buffer=%p, residue=0.%03d\n",
			 __func__, cb->buffer, ch->residue));
		for (i = 0; i < ch->nframes; i++) {
			DPRINTF(("   [%d] length %d\n", i, cb->sizes[i]));
		}
	}
#endif

	DPRINTFN(5,("%s: transfer xfer=%p\n", __func__, cb->xfer));
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, ch->nframes,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK, uaudio_chan_rintr);

	(void)usbd_transfer(cb->xfer);
}

void
uaudio_chan_rintr(struct usbd_xfer *xfer, void *priv,
		  usbd_status status)
{
	struct chanbuf *cb = priv;
	struct chan *ch = cb->chan;
	u_int16_t pos;
	u_int32_t count;
	int i, n, frsize;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("%s: count=%d, transferred=%d\n",
		    __func__, count, ch->transferred));

	/* count < cb->size is normal for asynchronous source */
#ifdef DIAGNOSTIC
	if (count > cb->size) {
		printf("%s: count(%d) > size(%d)\n",
		       __func__, count, cb->size);
	}
#endif

	/*
	 * Transfer data from channel buffer to upper layer buffer, taking
	 * care of wrapping the upper layer buffer.
	 */
	for (i = 0; i < ch->nframes; i++) {
		frsize = cb->sizes[i];
		pos = cb->offsets[i];
		while (frsize > 0) {
			n = min(frsize, ch->end - ch->cur);
			n = min(n, ch->blksize - ch->transferred);
			memcpy(ch->cur, cb->buffer + pos, n);
			frsize -= n;
			pos += n;
			ch->cur += n;
			if (ch->cur >= ch->end)
				ch->cur = ch->start;

			ch->transferred += n;
			/* Call back to upper layer */
			if (ch->transferred >= ch->blksize) {
				DPRINTFN(5,("%s: call %p(%p)\n",
					    __func__, ch->intr, ch->arg));
				mtx_enter(&audio_lock);
				ch->intr(ch->arg);
				mtx_leave(&audio_lock);
				ch->transferred -= ch->blksize;
			}
			if (count < n)
				printf("%s: count < n\n", __func__);
			else
				count -= n;
		}
	}
	if (count != 0) {
		printf("%s: transfer count - frame total = %d\n",
		    __func__, count);
	}

	/* start next transfer */
	uaudio_chan_rtransfer(ch);
}

void
uaudio_chan_init(struct chan *ch, int mode, int altidx,
    const struct audio_params *param)
{
	struct as_info *ai = &ch->sc->sc_alts[altidx];
	int samples_per_frame, ival, use_maxpkt = 0;

	if (ai->attributes & UA_SED_MAXPACKETSONLY) {
		DPRINTF(("%s: alt %d needs maxpktsize packets\n",
		    __func__, altidx));
		use_maxpkt = 1;
	}
	else if (mode == AUMODE_RECORD) {
		DPRINTF(("%s: using maxpktsize packets for record channel\n",
		    __func__));
		use_maxpkt = 1;
	}

	ch->altidx = altidx;
	ch->maxpktsize = UGETW(ai->edesc->wMaxPacketSize);
	ch->sample_rate = param->sample_rate;
	ch->sample_size = param->channels * param->bps;
	ch->usb_fps = USB_FRAMES_PER_SECOND;
	ch->hi_speed = ch->sc->sc_udev->speed == USB_SPEED_HIGH;
	if (ch->hi_speed) {
		ch->usb_fps *= 8;
		/*
		 * Polling interval is considered a frame, as opposed to
		 * micro-frame being a frame.
		 */
		ival = ch->sc->sc_alts[altidx].edesc->bInterval;
		if (ival > 0 && ival <= 4)
			ch->usb_fps >>= (ival - 1);
		DPRINTF(("%s: detected USB high-speed with ival %d\n",
		    __func__, ival));
	}

	/*
	 * Use UAUDIO_MIN_FRAMES here, so uaudio_round_blocksize() can
	 * make sure the blocksize duration will be > 1 USB frame.
	 */
	samples_per_frame = ch->sample_rate / ch->usb_fps;
	if (!use_maxpkt) {
		ch->fraction = ch->sample_rate % ch->usb_fps;
		if (samples_per_frame * ch->sample_size > ch->maxpktsize) {
			DPRINTF(("%s: packet size %d too big, max %d\n",
			    __func__, ch->bytes_per_frame, ch->maxpktsize));
			samples_per_frame = ch->maxpktsize / ch->sample_size;
		}
		ch->bytes_per_frame = samples_per_frame * ch->sample_size;
		ch->nframes = UAUDIO_MIN_FRAMES;
	} else {
		ch->fraction = 0;
		ch->bytes_per_frame = ch->maxpktsize;
		ch->nframes = UAUDIO_MIN_FRAMES * samples_per_frame *
		    ch->sample_size / ch->maxpktsize;
	}
	if (ch->nframes > UAUDIO_MAX_FRAMES)
		ch->nframes = UAUDIO_MAX_FRAMES;
	else if (ch->nframes < 1)
		ch->nframes = 1;

	ch->max_bytes_per_frame = ch->bytes_per_frame;
	if (!use_maxpkt)
		ch->max_bytes_per_frame += ch->sample_size;
	if (ch->max_bytes_per_frame > ch->maxpktsize)
		ch->max_bytes_per_frame = ch->maxpktsize;

	ch->residue = 0;
	ch->frac_denom = ch->usb_fps;
	if (ai->edesc1 != NULL) {
		/*
		 * The lower 16-bits of the sync request represent
		 * fractional samples.  Scale up the fraction here once
		 * so all fractions are using the same denominator.
		 */
		ch->frac_denom = 1 << 16;
		ch->fraction = (ch->fraction * ch->frac_denom) / ch->usb_fps;

		/*
		 * Have to set nsync_frames somewhere.  We can request
		 * a lot of sync data; the device will reply when it's
		 * ready, with empty frames meaning to keep using the
		 * current rate.
		 */
		ch->nsync_frames = UAUDIO_MAX_FRAMES;
	}
	DPRINTF(("%s: residual sample fraction: %d/%d\n", __func__,
	    ch->fraction, ch->frac_denom));
}

void
uaudio_chan_set_param(struct chan *ch, u_char *start, u_char *end, int blksize)
{
	ch->start = start;
	ch->end = end;
	ch->cur = start;
	ch->transferred = 0;
	ch->curchanbuf = 0;
	ch->blksize = blksize;

	/*
	 * Recompute nframes based on blksize, but make sure nframes
	 * is not longer in time duration than blksize.
	 */
	ch->nframes = ch->blksize * ch->usb_fps /
	    (ch->bytes_per_frame * ch->usb_fps +
	    ch->sample_size * ch->fraction);
	if (ch->nframes > UAUDIO_MAX_FRAMES)
		ch->nframes = UAUDIO_MAX_FRAMES;
	else if (ch->nframes < 1)
		ch->nframes = 1;

	ch->reqms = ch->bytes_per_frame / ch->sample_size *
	    ch->nframes * 1000 / ch->sample_rate;

	DPRINTF(("%s: alt=%d blk=%d maxpkt=%u bpf=%u rate=%u nframes=%u reqms=%u\n",
	    __func__, ch->altidx, ch->blksize, ch->maxpktsize,
	    ch->bytes_per_frame, ch->sample_rate, ch->nframes, ch->reqms));
}

int
uaudio_match_alt_rate(void *addr, int alt, int rate)
{
	struct uaudio_softc *sc = addr;
	const struct usb_audio_streaming_type1_descriptor *a1d;
	int i, j, r;

	a1d = sc->sc_alts[alt].asf1desc;
	if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
		if ((UA_SAMP_LO(a1d) <= rate) &&
		    (UA_SAMP_HI(a1d) >= rate)) {
			return rate;
		} else {
			if (UA_SAMP_LO(a1d) > rate)
				return UA_SAMP_LO(a1d);
			else
				return UA_SAMP_HI(a1d);
		}
	} else {
		for (i = 0; i < 100; i++) {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				r = UA_GETSAMP(a1d, j);
				if ((r - (500 * i) <= rate) &&
				    (r + (500 * i) >= rate))
					return r;
			}
		}
		/* assumes rates are listed in order from lowest to highest */
		if (rate < UA_GETSAMP(a1d, 0))
			j = 0;
		else
			j = a1d->bSamFreqType - 1;
		return UA_GETSAMP(a1d, j);
	}
	DPRINTF(("%s: could not match rate\n", __func__));
	return rate;
}

int
uaudio_match_alt(void *addr, struct audio_params *p, int mode)
{
	struct uaudio_softc *sc = addr;
	const struct usb_audio_streaming_type1_descriptor *a1d;
	int i, j, dir, rate;
	int alts_eh, alts_ch, ualt;

	DPRINTF(("%s: mode=%s rate=%ld ch=%d pre=%d bps=%d enc=%d\n",
	    __func__, mode == AUMODE_RECORD ? "rec" : "play", p->sample_rate,
	    p->channels, p->precision, p->bps, p->encoding));

	alts_eh = 0;
	for (i = 0; i < sc->sc_nalts; i++) {
		dir = UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress);
		if ((mode == AUMODE_RECORD && dir != UE_DIR_IN) ||
		    (mode == AUMODE_PLAY && dir == UE_DIR_IN))
			continue;
		DPRINTFN(6,("%s: matched %s alt %d for direction\n", __func__,
		    mode == AUMODE_RECORD ? "rec" : "play", i));
		if (sc->sc_alts[i].encoding != p->encoding)
			continue;
		a1d = sc->sc_alts[i].asf1desc;
		if (a1d->bBitResolution != p->precision)
			continue;
		alts_eh |= 1 << i;
		DPRINTFN(6,("%s: matched %s alt %d for enc/pre\n", __func__,
		    mode == AUMODE_RECORD ? "rec" : "play", i));
	}
	if (alts_eh == 0) {
		DPRINTF(("%s: could not match dir/enc/prec\n", __func__));
		return -1;
	}

	alts_ch = 0;
	for (i = 0; i < 3; i++) {
		for (j = 0; j < sc->sc_nalts; j++) {
			if (!(alts_eh & (1 << j)))
				continue;
			a1d = sc->sc_alts[j].asf1desc;
			if (a1d->bNrChannels == p->channels) {
				alts_ch |= 1 << j;
				DPRINTFN(6,("%s: matched alt %d for channels\n",
				    __func__, j));
			}
		}
		if (alts_ch)
			break;
		if (p->channels == 2)
			p->channels = 1;
		else
			p->channels = 2;
	}
	if (!alts_ch) {
		/* just use the first alt that matched the encoding */
		for (i = 0; i < sc->sc_nalts; i++)
			if (alts_eh & (1 << i))
				break;
		alts_ch = 1 << i;
		a1d = sc->sc_alts[i].asf1desc;
		p->channels = a1d->bNrChannels;
	}

	ualt = -1;
	for (i = 0; i < sc->sc_nalts; i++) {
		if (alts_ch & (1 << i)) {
			rate = uaudio_match_alt_rate(sc, i, p->sample_rate);
			if (rate - 50 <= p->sample_rate &&
			    rate + 50 >= p->sample_rate) {
				DPRINTFN(6,("%s: alt %d matched rate %ld with %d\n",
				    __func__, i, p->sample_rate, rate));
				p->sample_rate = rate;
				break;
			}
		}
	}
	if (i < sc->sc_nalts) {
		ualt = i;
	} else {
		for (i = 0; i < sc->sc_nalts; i++) {
			if (alts_ch & (1 << i)) {
				ualt = i;
				p->sample_rate = uaudio_match_alt_rate(sc,
				    i, p->sample_rate);
				break;
			}
		}
	}

	return ualt;
}

int
uaudio_set_params(void *addr, int setmode, int usemode,
    struct audio_params *play, struct audio_params *rec)
{
	struct uaudio_softc *sc = addr;
	int flags = sc->sc_altflags;
	int i;
	int paltidx = -1, raltidx = -1;
	struct audio_params *p;
	int mode;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (((usemode & AUMODE_PLAY) && sc->sc_playchan.pipe != NULL) ||
	    ((usemode & AUMODE_RECORD) && sc->sc_recchan.pipe != NULL))
		return (EBUSY);

	if ((usemode & AUMODE_PLAY) && sc->sc_playchan.altidx != -1)
		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 0;
	if ((usemode & AUMODE_RECORD) && sc->sc_recchan.altidx != -1)
		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 0;

	/* Some uaudio devices are unidirectional.  Don't try to find a
	   matching mode for the unsupported direction. */
	setmode &= sc->sc_mode;

	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;

		p = (mode == AUMODE_PLAY) ? play : rec;

		switch (p->precision) {
		case 24:
			if (!(flags & HAS_24)) {
				if (flags & HAS_16)
					p->precision = 16;
				else
					p->precision = 8;
			}
			break;
		case 16:
			if (!(flags & HAS_16)) {
				if (flags & HAS_24)
					p->precision = 24;
				else
					p->precision = 8;
			}
			break;
		case 8:
			if (!(flags & HAS_8) && !(flags & HAS_8U)) {
				if (flags & HAS_16)
					p->precision = 16;
				else
					p->precision = 24;
			}
			break;
		}

		i = uaudio_match_alt(sc, p, mode);
		if (i < 0) {
			DPRINTF(("%s: uaudio_match_alt failed for %s\n",
			    __func__, mode == AUMODE_RECORD ? "rec" : "play"));
			continue;
		}

		p->bps = sc->sc_alts[i].asf1desc->bSubFrameSize;
		p->msb = 1;

		if (mode == AUMODE_PLAY)
			paltidx = i;
		else
			raltidx = i;
	}

	if (setmode & AUMODE_PLAY) {
		if (paltidx == -1) {
			DPRINTF(("%s: did not find alt for playback\n",
			    __func__));
			return (EINVAL);
		}
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_playchan, AUMODE_PLAY, paltidx, play);
	}
	if (setmode & AUMODE_RECORD) {
		if (raltidx == -1) {
			DPRINTF(("%s: did not find alt for recording\n",
			    __func__));
			return (EINVAL);
		}
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_recchan, AUMODE_RECORD, raltidx, rec);
	}

	if ((usemode & AUMODE_PLAY) && sc->sc_playchan.altidx != -1)
		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 1;
	if ((usemode & AUMODE_RECORD) && sc->sc_recchan.altidx != -1)
		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 1;

	DPRINTF(("%s: use altidx=p%d/r%d, altno=p%d/r%d\n", __func__,
		 sc->sc_playchan.altidx, sc->sc_recchan.altidx,
		 (sc->sc_playchan.altidx >= 0)
		   ?sc->sc_alts[sc->sc_playchan.altidx].idesc->bAlternateSetting
		   : -1,
		 (sc->sc_recchan.altidx >= 0)
		   ? sc->sc_alts[sc->sc_recchan.altidx].idesc->bAlternateSetting
		   : -1));

	return (0);
}

usbd_status
uaudio_set_speed(struct uaudio_softc *sc, int endpt, u_int speed)
{
	usb_device_request_t req;
	u_int8_t data[3];

	DPRINTFN(5,("%s: endpt=%d speed=%u\n", __func__, endpt, speed));
	req.bmRequestType = UT_WRITE_CLASS_ENDPOINT;
	req.bRequest = SET_CUR;
	USETW2(req.wValue, SAMPLING_FREQ_CONTROL, 0);
	USETW(req.wIndex, endpt);
	USETW(req.wLength, 3);
	data[0] = speed;
	data[1] = speed >> 8;
	data[2] = speed >> 16;

	return (usbd_do_request(sc->sc_udev, &req, data));
}

void
uaudio_set_speed_emu0202(struct chan *ch)
{
	usb_device_request_t req;
	int rates[6] = { 44100, 48000, 88200, 96000, 176400, 192000 };
	int i;
	u_int8_t data[1];

	for (i = 0; i < 6; i++)
		if (rates[i] >= ch->sample_rate)
			break;
	if (i >= 6) {
		DPRINTF(("%s: unhandled rate %d\n", __func__, ch->sample_rate));
		i = 0;
	}

	req.bmRequestType = UT_WRITE_CLASS_INTERFACE;
	req.bRequest = SET_CUR;
	USETW2(req.wValue, 0x03, 0);
	USETW2(req.wIndex, 12, ch->sc->sc_ac_iface);
	USETW(req.wLength, 1);
	data[0] = i;

	usbd_do_request(ch->sc->sc_udev, &req, data);
}
@


1.124
log
@Fix links to usb-audio specs. From Michael Reed <m.reed at mykolab.com>.
Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.123 2017/01/31 13:42:15 jca Exp $ */
d1832 1
a1832 1
	iot = malloc(256 * sizeof(struct io_terminal),
@


1.123
log
@Fix links to USB audio specs.

From Michael Reed
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.122 2017/01/03 06:45:58 ratchov Exp $ */
d35 3
a37 3
 * USB audio specs: http://www.usb.org/developers/docs/devclass_docs/audio10.pdf
 *                  http://www.usb.org/developers/docs/devclass_docs/frmts10.pdf
 *                  http://www.usb.org/developers/docs/devclass_docs/termt10.pdf
@


1.122
log
@No need to set use_maxpkt twice. From Michael W. Bombardieri. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.121 2016/12/12 06:51:09 ratchov Exp $ */
d35 3
a37 3
 * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf
 *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf
 *                  http://www.usb.org/developers/devclass_docs/termt10.pdf
@


1.121
log
@Use DPRINTF instead of printf() in #ifdef UAUDIO_DEBUG section. From
Michael W. Bombardieri <mb at ii.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.120 2016/12/05 07:07:43 ratchov Exp $ */
d3016 1
a3016 1
	if (mode == AUMODE_RECORD) {
@


1.120
log
@Remove unused variable. From Michael W. Bombardieri <mb@@ii.net>. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.119 2016/11/16 07:02:48 ratchov Exp $ */
d1257 2
a1258 4
#ifdef UAUDIO_DEBUG
		printf("%s: unit %d, type=%d not impl.\n",
		       __func__, d->bUnitId, ptype);
#endif
@


1.119
log
@Use memcpy() to copy structures into freshly malloc'ated buffers,
as source and destination never overlap in this case. From
Michael W. Bombardieri <mb at ii.net>.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.118 2016/11/08 06:09:56 ratchov Exp $ */
a1491 1
	size_t len;
a1498 1
	len = sizeof(*ai) * (sc->sc_nalts + 1);
@


1.118
log
@Remove dead store. From Michael W. Bombardieri <mb at ii.net>. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.117 2016/10/27 05:08:23 ratchov Exp $ */
d625 1
a625 1
		bcopy(sc->sc_ctls, nmc, sizeof(*mc) * (sc->sc_nctls));
d1504 1
a1504 1
		bcopy(sc->sc_alts, nai, sizeof(*ai) * (sc->sc_nalts));
@


1.117
log
@Uniformize debug printfs, by using consistently __func__ everywhere.
From Michael W. Bombardieri <mb at ii.net>
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.116 2016/09/23 08:21:22 ratchov Exp $ */
d2903 1
a2903 1
	int i, size, residue, total;
a2913 1
	residue = ch->residue;
a2920 1
	ch->residue = residue;
@


1.116
log
@Add quirk to allow Yamaha UR22 to attach as uaudio(4). From
Michael W. Bombardieri <mb at ii.net>. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.115 2016/09/19 06:46:44 ratchov Exp $ */
d558 1
a558 1
	DPRINTF(("uaudio_attach: doing audio_attach_mi\n"));
d618 1
a618 1
		printf("uaudio_mixer_add_ctl: no memory\n");
d659 1
a659 1
		DPRINTF(("uaudio_mixer_add_ctl: wValue=%04x",mc->wValue[0]));
d719 1
a719 1
	printf("uaudio_get_cluster_nchan: bad data\n");
d729 1
a729 1
	DPRINTFN(2,("uaudio_add_input: bTerminalId=%d wTerminalType=0x%04x "
d732 1
d745 1
a745 1
	DPRINTFN(2,("uaudio_add_output: bTerminalId=%d wTerminalType=0x%04x "
d747 1
d762 1
a762 1
	DPRINTFN(2,("uaudio_add_mixer: bUnitId=%d bNrInPins=%d\n",
d773 1
a773 1
	DPRINTFN(2,("uaudio_add_mixer: ichs=%d ochs=%d\n", ichs, ochs));
d824 1
a824 1
	DPRINTFN(2,("uaudio_add_selector: bUnitId=%d bNrInPins=%d\n",
d1090 2
a1091 2
		DPRINTFN(9,("uaudio_add_feature: chan=%d mask=%x\n",
			    chan, GET(chan)));
d1095 1
a1095 1
	DPRINTFN(1,("uaudio_add_feature: bUnitId=%d, "
d1097 1
a1097 1
		    d->bUnitId, nchan, mmask, cmask));
d1105 2
a1106 2
		DPRINTFN(4,("uaudio_add_feature: ctl=%d fumask=0x%04x\n",
			    ctl, fumask));
d1198 2
a1199 2
	DPRINTFN(2,("uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\n",
		    d->bUnitId, ud->bNrModes));
d1202 1
a1202 1
		DPRINTF(("uaudio_add_processing_updown: no mode select\n"));
d1215 2
a1216 2
		DPRINTFN(2,("uaudio_add_processing_updown: i=%d bm=0x%x\n",
			    i, UGETW(ud->waModes[i])));
d1231 3
a1233 2
	DPRINTFN(2,("uaudio_add_processing: wProcessType=%d bUnitId=%d "
		    "bNrInPins=%d\n", ptype, d->bUnitId, d->bNrInPins));
d1258 2
a1259 2
		printf("uaudio_add_processing: unit %d, type=%d not impl.\n",
		       d->bUnitId, ptype);
d1273 2
a1274 2
	DPRINTFN(2,("uaudio_add_extension: bUnitId=%d bNrInPins=%d\n",
		    d->bUnitId, d->bNrInPins));
d1308 1
a1308 1
		printf("uaudio_merge_terminal_list: no memory\n");
d1343 1
a1343 1
			printf("uaudio_io_terminaltype: no memory\n");
d1364 1
a1364 1
			printf("uaudio_io_terminaltype: no memory\n");
d1376 1
a1376 1
			printf("uaudio_io_terminaltype: no memory\n");
d1381 1
a1381 1
			printf("uaudio_io_terminaltype: no memory\n");
d1395 1
a1395 1
			printf("uaudio_io_terminaltype: no memory\n");
d1404 1
a1404 1
			printf("uaudio_io_terminaltype: no memory\n");
d1417 1
a1417 1
			printf("uaudio_io_terminaltype: no memory\n");
d1432 1
a1432 1
			printf("uaudio_io_terminaltype: no memory\n");
d1447 1
a1447 1
			printf("uaudio_io_terminaltype: no memory\n");
d1462 1
a1462 1
			printf("uaudio_io_terminaltype: no memory\n");
d1497 1
a1497 1
		printf("uaudio_add_alt: no memory\n");
d1508 2
a1509 2
	DPRINTFN(2,("uaudio_add_alt: adding alt=%d, enc=%d\n",
		    ai->alt, ai->encoding));
d1532 1
a1532 1
	DPRINTF(("uaudio_process_as: asid: bTerminalLink=%d wFormatTag=%d\n",
d1555 1
a1555 1
	DPRINTF(("uaudio_process_as: endpoint[0] bLength=%d bDescriptorType=%d "
d1558 1
d1605 1
a1605 1
		DPRINTF(("uaudio_process_as: endpoint[1] bLength=%d "
d1609 1
d1719 1
a1719 1
		DPRINTFN(1, ("uaudio_process_as:  FREQ_CONTROL\n"));
d1721 1
a1721 1
		DPRINTFN(1, ("uaudio_process_as:  PITCH_CONTROL\n"));
d1749 2
a1750 2
		DPRINTFN(2, ("uaudio_identify: interface=%d offset=%d\n",
		    id->bInterfaceNumber, offs));
d1753 2
a1754 2
			DPRINTFN(2, ("uaudio_identify: AS null alt=%d\n",
				     id->bAlternateSetting));
d1774 1
a1774 1
	DPRINTF(("uaudio_identify_as: %d alts available\n", sc->sc_nalts));
d1809 2
a1810 1
	DPRINTFN(2,("uaudio_identify_ac: AC interface is %d\n", sc->sc_ac_iface));
d1827 2
a1828 2
	DPRINTFN(2,("uaudio_identify_ac: found AC header, vers=%03x, len=%d\n",
		 sc->sc_audio_rev, aclen));
d1852 2
a1853 2
			printf("uaudio_identify_ac: skip desc type=0x%02x\n",
			       dp->bDescriptorType);
d1947 2
a1948 2
		DPRINTF(("uaudio_identify_ac: id=%d subtype=%d\n",
			 i, dp->bDescriptorSubtype));
d1951 1
a1951 1
			printf("uaudio_identify_ac: unexpected AC header\n");
d1975 2
a1976 2
			printf("uaudio_identify_ac: bad AC desc subtype=0x%02x\n",
			       dp->bDescriptorSubtype);
d2008 1
a2008 1
	DPRINTFN(2,("uaudio_query_devinfo: index=%d\n", mi->index));
d2090 1
a2090 1
	DPRINTF(("uaudio_open: sc=%p\n", sc));
d2139 1
a2139 1
	DPRINTF(("uaudio_halt_out_dma: enter\n"));
d2156 1
a2156 1
	DPRINTF(("uaudio_halt_in_dma: enter\n"));
d2180 1
a2180 1
	DPRINTF(("uaudio_round_blocksize: p.mbpf=%d r.mbpf=%d\n",
d2200 1
a2200 1
		printf("uaudio_round_blocksize: blk=%d\n", blk);
d2205 1
a2205 1
	DPRINTFN(1,("uaudio_round_blocksize: blk=%d\n", blk));
d2242 1
a2242 1
	DPRINTFN(2,("uaudio_get: type=0x%02x req=0x%02x wValue=0x%04x "
d2244 1
a2244 1
		    type, which, wValue, wIndex, len));
d2247 1
a2247 1
		DPRINTF(("uaudio_get: err=%s\n", usbd_errstr(err)));
d2258 1
a2258 1
		DPRINTF(("uaudio_get: bad length=%d\n", len));
d2261 1
a2261 1
	DPRINTFN(2,("uaudio_get: val=%d\n", val));
d2292 2
a2293 2
	DPRINTFN(2,("uaudio_set: type=0x%02x req=0x%02x wValue=0x%04x "
		    "wIndex=0x%04x len=%d, val=%d\n",
d2298 1
a2298 1
		DPRINTF(("uaudio_set: err=%d\n", err));
d2330 2
a2331 2
	DPRINTFN(5, ("uaudio_value2bsd: type=%03x val=%d min=%d max=%d ",
		     mc->type, val, mc->minval, mc->maxval));
d2352 2
a2353 2
	DPRINTFN(5,("uaudio_bsd2value: type=%03x val=%d min=%d max=%d ",
		    mc->type, val, mc->minval, mc->maxval));
d2372 1
a2372 1
	DPRINTFN(5,("uaudio_ctl_get: which=%d chan=%d\n", which, chan));
d2394 1
a2394 1
	DPRINTFN(2,("uaudio_mixer_get_port: index=%d\n", cp->dev));
d2439 1
a2439 1
	DPRINTFN(2,("uaudio_mixer_set_port: index = %d\n", cp->dev));
d2486 2
a2487 2
	DPRINTFN(3,("uaudio_trigger_input: sc=%p start=%p end=%p "
		    "blksize=%d\n", sc, start, end, blksize));
d2490 3
a2492 2
	DPRINTFN(3,("uaudio_trigger_input: sample_size=%d bytes/frame=%d "
		    "fraction=0.%03d\n", ch->sample_size, ch->bytes_per_frame,
d2529 2
a2530 2
	DPRINTFN(3,("uaudio_trigger_output: sc=%p start=%p end=%p "
		    "blksize=%d\n", sc, start, end, blksize));
d2533 3
a2535 3
	DPRINTFN(3,("uaudio_trigger_output: sample_size=%d bytes/frame=%d "
		    "fraction=0.%03d\n", ch->sample_size, ch->bytes_per_frame,
		    ch->fraction));
d2570 2
a2571 2
	DPRINTF(("uaudio_chan_open: endpt=0x%02x, speed=%d, alt=%d\n",
		 endpt, ch->sample_rate, as->alt));
d2588 2
a2589 2
			DPRINTF(("uaudio_chan_open: set_speed failed err=%s\n",
				 usbd_errstr(err)));
d2597 1
a2597 1
	DPRINTF(("uaudio_chan_open: create pipe to 0x%02x\n", endpt));
d2606 1
a2606 1
		DPRINTF(("uaudio_chan_open: create sync-pipe to 0x%02x\n", endpt));
d2623 2
a2624 2
		DPRINTF(("uaudio_chan_close: set null alt=%d\n",
			 sc->sc_nullalt));
d2761 2
a2762 2
			DPRINTFN(5,("uaudio_chan_ptransfer: call %p(%p)\n",
				    ch->intr, ch->arg));
d2772 2
a2773 2
		DPRINTF(("uaudio_chan_ptransfer: buffer=%p, residue=0.%03d\n",
			 cb->buffer, ch->residue));
d2780 1
a2780 1
	DPRINTFN(5,("uaudio_chan_ptransfer: transfer xfer=%p\n", cb->xfer));
d2800 2
a2801 2
	DPRINTFN(5,("uaudio_chan_pintr: count=%d, transferred=%d\n",
		    count, ch->transferred));
d2804 2
a2805 2
		printf("uaudio_chan_pintr: count(%d) != size(%d)\n",
		       count, cb->size);
d2927 2
a2928 2
		DPRINTF(("uaudio_chan_rtransfer: buffer=%p, residue=0.%03d\n",
			 cb->buffer, ch->residue));
d2935 1
a2935 1
	DPRINTFN(5,("uaudio_chan_rtransfer: transfer xfer=%p\n", cb->xfer));
d2957 2
a2958 2
	DPRINTFN(5,("uaudio_chan_rintr: count=%d, transferred=%d\n",
		    count, ch->transferred));
d2963 2
a2964 2
		printf("uaudio_chan_rintr: count(%d) > size(%d)\n",
		       count, cb->size);
d2988 2
a2989 2
				DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n",
					    ch->intr, ch->arg));
d3362 1
a3362 1
	DPRINTF(("uaudio_set_params: use altidx=p%d/r%d, altno=p%d/r%d\n",
d3380 1
a3380 1
	DPRINTFN(5,("uaudio_set_speed: endpt=%d speed=%u\n", endpt, speed));
@


1.115
log
@Remove unused getdev() audio driver functions.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.114 2016/09/14 06:12:20 ratchov Exp $ */
d180 2
@


1.114
log
@Remove drain(), query_encoding(), mappage() and get_default_params()
methods from all audio drivers and from the audio_if structure as they
are never called.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.112 2015/06/15 15:45:28 mpi Exp $ */
a388 1
int	uaudio_getdev(void *, struct audio_device *);
a406 1
	uaudio_getdev,
a418 6
struct audio_device uaudio_device = {
	"USB audio",
	"",
	"uaudio"
};

a2156 13
	return (0);
}

int
uaudio_getdev(void *addr, struct audio_device *retp)
{
	struct uaudio_softc *sc = addr;

	DPRINTF(("uaudio_mixer_getdev:\n"));
	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	*retp = uaudio_device;
@


1.113
log
@Attach the iPhone 6 as ugen(4), from Laurent GUALDI.
@
text
@a247 2
	struct audio_encoding *sc_encs;
	int		 sc_nencs;
a297 2
void	uaudio_create_encodings(struct uaudio_softc *);

a372 1
int	uaudio_query_encoding(void *, struct audio_encoding *);
a393 1
void	uaudio_get_default_params(void *, int, struct audio_params *);
a397 2
	uaudio_drain,
	uaudio_query_encoding,
a415 1
	NULL,
d418 1
a418 2
	uaudio_trigger_input,
	uaudio_get_default_params
a563 2
	uaudio_create_encodings(sc);

a589 19
int
uaudio_query_encoding(void *addr, struct audio_encoding *fp)
{
	struct uaudio_softc *sc = addr;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (sc->sc_nalts == 0 || sc->sc_altflags == 0)
		return (ENXIO);

	if (fp->index < 0 || fp->index >= sc->sc_nencs)
		return (EINVAL);

	*fp = sc->sc_encs[fp->index];

	return (0);
}

a1515 77
void
uaudio_create_encodings(struct uaudio_softc *sc)
{
	int enc, encs[16], nencs, i, j;

	nencs = 0;
	for (i = 0; i < sc->sc_nalts && nencs < 16; i++) {
		enc = (sc->sc_alts[i].asf1desc->bSubFrameSize << 16) |
		    (sc->sc_alts[i].asf1desc->bBitResolution << 8) |
		    sc->sc_alts[i].encoding;
		for (j = 0; j < nencs; j++) {
			if (encs[j] == enc)
				break;
		}
		if (j < nencs)
			continue;
		encs[j] = enc;
		nencs++;
	}

	sc->sc_nencs = 0;
	sc->sc_encs = mallocarray(nencs, sizeof(struct audio_encoding),
	    M_USBDEV, M_NOWAIT);
	if (sc->sc_encs == NULL) {
		printf("%s: no memory\n", __func__);
		return;
	}
	sc->sc_nencs = nencs;

	for (i = 0; i < sc->sc_nencs; i++) {
		sc->sc_encs[i].index = i;
		sc->sc_encs[i].encoding = encs[i] & 0xff;
		sc->sc_encs[i].precision = (encs[i] >> 8) & 0xff;
		sc->sc_encs[i].bps = (encs[i] >> 16) & 0xff;
		sc->sc_encs[i].msb = 1;
		sc->sc_encs[i].flags = 0;
		switch (sc->sc_encs[i].encoding) {
		case AUDIO_ENCODING_SLINEAR_LE:
			strlcpy(sc->sc_encs[i].name,
			    sc->sc_encs[i].precision == 8 ?
			    AudioEslinear : AudioEslinear_le,
			    sizeof(sc->sc_encs[i].name));
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (sc->sc_encs[i].precision != 8) {
				DPRINTF(("%s: invalid precision for ulinear: %d\n",
				    __func__, sc->sc_encs[i].precision));
				continue;
			}
			strlcpy(sc->sc_encs[i].name, AudioEulinear,
			    sizeof(sc->sc_encs[i].name));
			break;
		case AUDIO_ENCODING_ALAW:
			if (sc->sc_encs[i].precision != 8) {
				DPRINTF(("%s: invalid precision for alaw: %d\n",
				    __func__, sc->sc_encs[i].precision));
				continue;
			}
			strlcpy(sc->sc_encs[i].name, AudioEalaw,
			    sizeof(sc->sc_encs[i].name));
			break;
		case AUDIO_ENCODING_ULAW:
			if (sc->sc_encs[i].precision != 8) {
				DPRINTF(("%s: invalid precision for ulaw: %d\n",
				    __func__, sc->sc_encs[i].precision));
				continue;
			}
			strlcpy(sc->sc_encs[i].name, AudioEmulaw,
			    sizeof(sc->sc_encs[i].name));
			break;
		default:
			DPRINTF(("%s: unknown format\n", __func__));
			break;
		}
	}
}

a2235 42
}

void
uaudio_get_default_params(void *addr, int mode, struct audio_params *p)
{
	struct uaudio_softc *sc = addr;
	int flags, alt;

	/* try aucat(1) defaults: 44100 Hz stereo s16le */
	p->sample_rate = 44100;
	p->encoding = AUDIO_ENCODING_SLINEAR_LE;
	p->precision = 16;
	p->bps = 2;
	p->msb = 1;
	p->channels = 2;

	/* If the device doesn't support the current mode, there's no
	 * need to find better parameters.
	 */
	if (!(sc->sc_mode & mode))
		return;

	flags = sc->sc_altflags;
	if (flags & HAS_16)
		;
	else if (flags & HAS_24)
		p->precision = 24;
	else {
		p->precision = 8;
		if (flags & HAS_8)
			;
		else if (flags & HAS_8U)
			p->encoding = AUDIO_ENCODING_ULINEAR_LE;
		else if (flags & HAS_MULAW)
			p->encoding = AUDIO_ENCODING_ULAW;
		else if (flags & HAS_ALAW)
			p->encoding = AUDIO_ENCODING_ALAW;
	}

	alt = uaudio_match_alt(sc, p, mode);
	if (alt != -1)
		p->bps = sc->sc_alts[alt].asf1desc->bSubFrameSize;
@


1.112
log
@Set the length of isochronous transfers as the sum of the frames lengths.

This reduces differences between non-isoch and isoch transfers submissions,
makes the generic DMA buffer overrun check work with isoch transfers and
will allow some code simplifications in HC drivers.

Since short-transfers were never checked for isoch transfers, we now need to
pass the USBD_SHORT_XFER_OK flag to not change this behavior.  This might be
revisited later.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.111 2015/05/11 06:46:22 ratchov Exp $ */
d196 2
d201 1
a201 1
		UAUDIO_FLAG_BAD_AUDIO },	
@


1.111
log
@Remove all audio format conversion code from the kernel (btw holding
the kernel_lock), as we already do better conversions in
user-mode. Yet, no need for every single driver to fiddle with the
conversion code as they are done transparently by common MI code. With
help from armani and miod, support from mpi

ok armani@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.110 2015/03/14 03:38:49 jsg Exp $ */
d2941 2
a2942 4
	/* Fill the request */
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     ch->nframes, USBD_NO_COPY,
			     uaudio_chan_pintr);
a2996 1
	/* Fill the request */
d2998 2
a2999 1
	    ch->nsync_frames, USBD_NO_COPY, uaudio_chan_psync_intr);
d3096 2
a3097 4
	/* Fill the request */
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     ch->nframes, USBD_NO_COPY,
			     uaudio_chan_rintr);
@


1.110
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.109 2015/01/12 07:12:58 deraadt Exp $ */
a54 1
#include <dev/mulaw.h>
a2356 2
	p->sw_code = NULL;
	p->factor = 1;
a3491 3

		p->sw_code = NULL;
		p->factor  = 1;
@


1.109
log
@pretty up some malloc() calls
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.108 2014/12/13 21:05:33 doug Exp $ */
a55 1
#include <dev/auconv.h>
@


1.108
log
@yet more mallocarray() changes.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.107 2014/12/09 07:05:06 doug Exp $ */
d1375 1
a1375 1
			     M_TEMP, M_NOWAIT);
d1944 2
a1945 1
	iot = malloc(sizeof(struct io_terminal) * 256, M_TEMP, M_NOWAIT | M_ZERO);
@


1.107
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.106 2014/11/18 23:55:01 krw Exp $ */
d652 2
a653 2
	len = sizeof(*mc) * (sc->sc_nctls + 1);
	nmc = malloc(len, M_USBDEV, M_NOWAIT);
d658 2
d1529 1
a1529 2
	len = sizeof(*ai) * (sc->sc_nalts + 1);
	nai = malloc(len, M_USBDEV, M_NOWAIT);
d1534 2
@


1.106
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.105 2014/08/21 14:52:55 mpi Exp $ */
d1446 2
a1447 2
		it->inputs = malloc(sizeof(struct terminal_list *)
				    * it->d.mu->bNrInPins, M_TEMP, M_NOWAIT);
d1461 2
a1462 2
		it->inputs = malloc(sizeof(struct terminal_list *)
				    * it->d.su->bNrInPins, M_TEMP, M_NOWAIT);
d1476 2
a1477 2
		it->inputs = malloc(sizeof(struct terminal_list *)
				    * it->d.pu->bNrInPins, M_TEMP, M_NOWAIT);
d1491 2
a1492 2
		it->inputs = malloc(sizeof(struct terminal_list *)
				    * it->d.eu->bNrInPins, M_TEMP, M_NOWAIT);
d1565 1
a1565 1
	sc->sc_encs = malloc(sizeof(struct audio_encoding) * nencs,
@


1.105
log
@Now that DVACT_DEACTIVATE is propagated to the children of a device when
a driver does not implement a specific *_activate() handler and that our
USB stack sets the dying flag before detaching a device, these specific
handlers can die.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.104 2014/07/12 18:48:52 tedu Exp $ */
a48 1
#include <sys/device.h>
@


1.104
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.103 2014/06/04 08:01:25 ratchov Exp $ */
a252 1
	struct device	*sc_audiodev;
a440 1
int uaudio_activate(struct device *, int); 
d446 2
a447 6
const struct cfattach uaudio_ca = { 
	sizeof(struct uaudio_softc), 
	uaudio_match, 
	uaudio_attach, 
	uaudio_detach, 
	uaudio_activate, 
d578 1
a578 17
	sc->sc_audiodev = audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
}

int
uaudio_activate(struct device *self, int act)
{
	struct uaudio_softc *sc = (struct uaudio_softc *)self;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (sc->sc_audiodev != NULL)
			rv = config_deactivate(sc->sc_audiodev);
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (rv);
d598 1
a598 2
	if (sc->sc_audiodev != NULL)
		rv = config_detach(sc->sc_audiodev, flags);
@


1.103
log
@Properly compare endpoint addresses: ignore the direction bit which
is not part of the address. From Remco <remco at d-compu.dyndns.org>,
thanks!

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.102 2014/05/17 12:43:18 ratchov Exp $ */
d685 1
a685 1
		free(sc->sc_ctls, M_USBDEV);
d1405 1
a1405 1
		free(it->output, M_TEMP);
d1410 2
a1411 2
					free(it->inputs[i], M_TEMP);
			free(it->inputs, M_TEMP);
d1438 1
a1438 1
			free(it->inputs, M_TEMP);
d1560 1
a1560 1
		free(sc->sc_alts, M_USBDEV);
d1976 1
a1976 1
			free(iot, M_TEMP);
d2001 1
a2001 1
			free(tml, M_TEMP);
d2116 1
a2116 1
					free(iot[i].inputs[j], M_TEMP);
d2118 1
a2118 1
			free(iot[i].inputs, M_TEMP);
d2121 1
a2121 1
			free(iot[i].output, M_TEMP);
d2124 1
a2124 1
	free(iot, M_TEMP);
@


1.102
log
@fix format mistakes visible if UAUDIO_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.101 2013/11/06 16:13:42 pirofti Exp $ */
d1768 2
a1769 1
		    UE_GET_ADDR(sync_ed->bEndpointAddress) != sync_addr) {
@


1.101
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.100 2013/05/15 08:29:26 ratchov Exp $ */
d3364 1
a3364 1
	DPRINTF(("%s: mode=%s rate=%d ch=%d pre=%d bps=%d enc=%d\n",
d3425 1
a3425 1
				DPRINTFN(6,("%s: alt %d matched rate %d with %d\n",
@


1.100
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.99 2013/04/15 09:23:01 mglocker Exp $ */
a253 1
	char		 sc_dying;
d597 1
a597 1
		sc->sc_dying = 1;
d631 1
a631 1
	if (sc->sc_dying)
d2136 1
a2136 1
	if (sc->sc_dying)
d2218 1
a2218 1
	if (sc->sc_dying)
d2301 1
a2301 1
	if (sc->sc_dying)
d2580 1
a2580 1
	if (sc->sc_dying)
d2624 1
a2624 1
	if (sc->sc_dying)
d2667 1
a2667 1
	if (sc->sc_dying)
d2709 1
a2709 1
	if (sc->sc_dying)
d2900 1
a2900 1
	if (ch->sc->sc_dying)
d3005 1
a3005 1
	if (ch->sc->sc_dying)
d3090 1
a3090 1
	if (ch->sc->sc_dying)
d3459 1
a3459 1
	if (sc->sc_dying)
@


1.99
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.98 2013/03/28 03:58:03 tedu Exp $ */
a2899 1
	int s;
d2947 1
a2947 1
			s = splaudio();
d2949 1
a2949 1
			splx(s);
d3138 1
a3138 1
	int s, i, n, frsize;
d3178 1
a3178 1
				s = splaudio();
d3180 1
a3180 1
				splx(s);
@


1.98
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.97 2013/03/28 03:31:55 tedu Exp $ */
d111 1
a111 1
	usbd_interface_handle	ifaceh;
d113 2
a114 2
	const usb_endpoint_descriptor_audio_t *edesc;
	const usb_endpoint_descriptor_audio_t *edesc1;
d122 2
a123 2
	usbd_pipe_handle pipe;
	usbd_pipe_handle sync_pipe;
d152 1
a152 1
		usbd_xfer_handle xfer;
d161 1
a161 1
		usbd_xfer_handle xfer;
d232 1
a232 1
	usbd_device_handle sc_udev;	/* USB device */
d368 1
a368 1
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d371 1
a371 1
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d375 1
a375 1
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d1653 2
a1654 2
	const usb_endpoint_descriptor_audio_t *ed;
	const usb_endpoint_descriptor_audio_t *sync_ed;
d2825 1
a2825 1
	usbd_xfer_handle xfer;
d2975 1
a2975 1
uaudio_chan_pintr(usbd_xfer_handle xfer, usbd_private_handle priv,
d3032 1
a3032 1
uaudio_chan_psync_intr(usbd_xfer_handle xfer, usbd_private_handle priv,
d3132 1
a3132 1
uaudio_chan_rintr(usbd_xfer_handle xfer, usbd_private_handle priv,
@


1.97
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.96 2012/03/01 08:49:22 ratchov Exp $ */
a48 1
#include <sys/proc.h>
@


1.96
log
@use UE_GET_ADDR to get endpoint address (remove direction bit). Fixes
devices using sych endpoints. From Gregor Pintar <grpintar at gmail.com>
Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.95 2012/01/31 21:13:32 brynet Exp $ */
a47 1
#include <sys/reboot.h>			/* for bootverbose */
a49 1
#include <sys/vnode.h>
d1427 1
a1427 1
		it->direct = FALSE;
d1468 1
a1468 1
		iot[src_id].direct = TRUE;
d1705 1
a1705 1
	sync = FALSE;
d1710 1
a1710 1
		sync = TRUE;
d1716 1
a1716 1
			sync = FALSE;
d1731 1
a1731 1
	if (sync == TRUE) {
@


1.95
log
@add uhid/uaudio quirks for the iPad and iPad 2.

ok deraadt@@/dcoppa@@ and sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.94 2012/01/26 09:00:36 ratchov Exp $ */
d1771 2
a1772 1
		if (sync_addr && sync_ed->bEndpointAddress != sync_addr) {
@


1.94
log
@Don't printf (recoverable) xruns unless UAUDIO_DEBUG is defined
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.93 2011/12/01 23:02:12 dhill Exp $ */
d209 4
@


1.93
log
@Mark Apple iPod and iPhone products with UQ_BAD_HID and UAUDIO_FLAG_BAD_AUDIO.

This allows these devices to attach as ugen, so at least we can use some apps,
like gphoto2 to retrieve media.

requested by a few,  ok mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.92 2011/07/03 15:47:17 matthew Exp $ */
d2987 1
a2987 1
#ifdef DIAGNOSTIC
@


1.92
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.91 2011/01/25 20:03:36 jakemsr Exp $ */
d189 20
@


1.91
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.90 2011/01/16 22:35:29 jakemsr Exp $ */
a573 2
	case DVACT_ACTIVATE:
		break;
@


1.90
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.89 2010/08/18 22:54:58 jakemsr Exp $ */
a562 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a603 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.89
log
@* indentation fix
* use the correct variable in a DPRINTF
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.88 2010/08/18 22:53:10 jakemsr Exp $ */
a212 1
	usbd_interface_handle	sc_ac_ifaceh;
a521 1
	sc->sc_ac_ifaceh = uaa->iface;
d524 1
a524 1
		if (uaa->ifaces[i] == NULL)
d538 1
a538 1
			uaa->ifaces[i] = NULL;
@


1.88
log
@* the detach and drain functions do the same waiting for channels to
complete outstanding requests, so use uaudio_drain in uaudio_detach.
* the channel alt index can still be -1 at detach.  check for this.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.87 2010/07/31 02:52:16 jakemsr Exp $ */
d611 1
a611 1
			   &sc->sc_dev);
d3275 1
a3275 1
	    ch->fraction, ch->usb_fps));
@


1.87
log
@check for audio stream and control interface descriptors in the
device configuration descriptor in the match() function.  stops
midi devices from attaching as uaudio then bailing out, leaving
a phantom uaudio.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.86 2010/07/23 19:59:09 jakemsr Exp $ */
d594 1
a594 3
	struct chan *pchan = &sc->sc_playchan;
	struct chan *rchan = &sc->sc_recchan;
	int ms, rv = 0;
d597 3
a599 1
	 * sc_alts may be NULL if uaudio_identify_as() failed
d602 1
a602 1
		return rv;
d605 1
a605 3
	ms = max(sc->sc_alts[pchan->altidx].sc_busy ? pchan->reqms : 0,
	    sc->sc_alts[rchan->altidx].sc_busy ? rchan->reqms : 0);
	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * ms);
d2238 1
a2238 1
	int ms;
d2241 4
a2244 2
	ms = max(sc->sc_alts[pchan->altidx].sc_busy ? pchan->reqms : 0,
	    sc->sc_alts[rchan->altidx].sc_busy ? rchan->reqms : 0);
@


1.86
log
@bring back changes in uaudio.c r1.83, this time remembering to commit
uaudioreg.h.  sorry about that.

sync endpoints allow for the sample clock on USB audio devices to not
be synchronized to the USB clock.  the sync endpoint gives information
on how much data to send to the data endpoint.  although devices that
require sync endpoints will "work" when the sync endpoint inormation
is ignored, there is a possibility of static, echoing, or any other
type of clock desync error.

requires some small changes to existing code:
* tighten up checks for whether a setting needs/supplies a sync
endpoint.  ignore settings that need a sync endpoint but don't
supply one.  previously all settings that require a sync endpoint
were ignored.
* if a sync endpoint is being used, use the same denominator for
fractional samples as the sync endpoint uses (2**16).

this only implements playback sync endpoints.  recording sync
endpoints are an odd concept: the driver would control the clock
rate of the device.  there may be such devices, but I can't even
imagine how that could be reliably implemented.  I guess you would
sync to the USB clock or the system clock ... but then, what's the
point?
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.84 2010/07/23 12:17:48 jakemsr Exp $ */
d442 2
d445 2
a446 1
	int flags;
d448 8
a455 1
	if (uaa->iface == NULL)
d462 20
a481 3
	quirk = uaudio_lookup(uaa->vendor, uaa->product);
	if (quirk)
		flags = quirk->flags;
d483 5
a487 10
	if (id->bInterfaceClass == UICLASS_AUDIO &&
	    id->bInterfaceSubClass == UISUBCLASS_AUDIOCONTROL &&
	    !(flags & UAUDIO_FLAG_BAD_AUDIO))
		return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);

	/* additional quirk devices which we want to attach */
	if ((flags & UAUDIO_FLAG_VENDOR_CLASS) &&
	    id->bInterfaceClass == UICLASS_VENDOR &&
	    id->bInterfaceSubClass == UISUBCLASS_AUDIOCONTROL)
		return (UMATCH_VENDOR_PRODUCT_CONF_IFACE);
d489 1
a489 1
	return (UMATCH_NONE);
@


1.85
log
@revert last commit, unbreaking the tree; was missing a macro definition
presumably from a missing commit to a header file. go ahead kettenis@@ todd@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.83 2010/07/21 10:16:07 jakemsr Exp $ */
a70 1
/* #define UAUDIO_MULTIPLE_ENDPOINTS */
d83 1
d132 2
a133 1
	u_int	fraction;	/* fraction/usb_fps is the extra samples/frame */
d136 1
d151 2
d162 9
d349 3
d1623 1
a1623 1
	const usb_endpoint_descriptor_audio_t *epdesc1;
d1626 1
a1626 1
	int dir, type, sync;
d1672 1
a1672 1
	/* We can't handle endpoints that need a sync pipe yet. */
d1674 13
a1686 23
	/* bSynchAddress set to 0 indicates sync pipe is not needed. */
	if (ed->bSynchAddress != 0) {
		if (dir == UE_DIR_IN && type == UE_ISO_ADAPT) {
			sync = TRUE;
#ifndef UAUDIO_MULTIPLE_ENDPOINTS
			printf("%s: ignored input endpoint of type adaptive\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
#endif
		}
		if (dir != UE_DIR_IN && type == UE_ISO_ASYNC) {
			sync = TRUE;
#ifndef UAUDIO_MULTIPLE_ENDPOINTS
			printf("%s: ignored output endpoint of type async\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
#endif
		}
	}
	if (sync && id->bNumEndpoints < 2) {
		printf("%s: sync pipe needed, but no sync endpoint given\n",
		       sc->sc_dev.dv_xname);
		return (USBD_NORMAL_COMPLETION);
d1698 8
a1705 6
	epdesc1 = NULL;
#ifdef UAUDIO_MULTIPLE_ENDPOINTS
	if (sync) {
		epdesc1 = (const void*)(buf + offs);
		if (epdesc1->bDescriptorType != UDESC_ENDPOINT)
			return USBD_INVAL;
d1710 12
a1721 9
			 epdesc1->bLength, epdesc1->bDescriptorType,
			 epdesc1->bEndpointAddress, epdesc1->bmAttributes,
			 UGETW(epdesc1->wMaxPacketSize), epdesc1->bInterval,
			 epdesc1->bRefresh, epdesc1->bSynchAddress));
		offs += epdesc1->bLength;
		if (offs > size)
			return USBD_INVAL;
		if (epdesc1->bSynchAddress != 0) {
			printf("%s: invalid endpoint: bSynchAddress=0\n",
d1723 13
a1735 1
			return USBD_INVAL;
d1737 4
a1740 12
		if (UE_GET_XFERTYPE(epdesc1->bmAttributes) != UE_ISOCHRONOUS) {
			printf("%s: invalid endpoint: bmAttributes=0x%x\n",
			       sc->sc_dev.dv_xname, epdesc1->bmAttributes);
			return USBD_INVAL;
		}
		if (epdesc1->bEndpointAddress != ed->bSynchAddress) {
			printf("%s: invalid endpoint addresses: "
			       "ep[0]->bSynchAddress=0x%x "
			       "ep[1]->bEndpointAddress=0x%x\n",
			       sc->sc_dev.dv_xname, ed->bSynchAddress,
			       epdesc1->bEndpointAddress);
			return USBD_INVAL;
a1741 1
		/* UE_GET_ADDR(epdesc1->bEndpointAddress), and epdesc1->bRefresh */
d1743 5
a1747 1
#endif
d1810 1
a1810 1
	ai.edesc1 = epdesc1;
a1855 1
#ifdef UAUDIO_MULTIPLE_ENDPOINTS
a1856 1
#endif
d2237 2
d2254 2
d2703 4
d2725 2
a2726 1
	if (err)
d2728 1
d2749 3
a2751 1
	if (err)
d2753 1
d2758 4
d2790 1
d2812 16
d2836 7
d2848 1
d2853 4
d2882 1
a2882 1
		if (residue >= ch->usb_fps) {
d2885 1
a2885 1
			residue -= ch->usb_fps;
d2968 85
d3234 18
@


1.84
log
@support for playback sync endpoints

sync endpoints allow for the sample clock on USB audio devices to not
be synchronized to the USB clock.  the sync endpoint gives information
on how much data to send to the data endpoint.  although devices that
require sync endpoints will "work" when the sync endpoint inormation
is ignored, there is a possibility of static, echoing, or any other
type of clock desync error.

requires some small changes to existing code:
* tighten up checks for whether a setting needs/supplies a sync
endpoint.  ignore settings that need a sync endpoint but don't
supply one.  previously all settings that require a sync endpoint
were ignored.
* if a sync endpoint is being used, use the same denominator for
fractional samples as the sync endpoint uses (2**16).

this only implements playback sync endpoints.  recording sync
endpoints are an odd concept: the driver would control the clock
rate of the device.  there may be such devices, but I can't even
imagine how that could be reliably implemented.  I guess you would
sync to the USB clock or the system clock ... but then, what's the
point?
@
text
@d71 1
a83 1
#define UAUDIO_NSYNCBUFS 3	/* number of outstanding sync requests */
d132 1
a132 2
	u_int	fraction;	/* fraction/frac_denom is the extra samples/frame */
	u_int	frac_denom;	/* denominator for fractional samples */
a134 1
	u_int	nsync_frames;	/* # of frames per sync transfer */
a148 2
	int	cursyncbuf;

a157 9
	struct syncbuf {
		struct chan	*chan;
		usbd_xfer_handle xfer;
		u_char		*buffer;
		u_int16_t	sizes[UAUDIO_MAX_FRAMES];
		u_int16_t	offsets[UAUDIO_MAX_FRAMES];
		u_int16_t	size;
	} syncbufs[UAUDIO_NSYNCBUFS];

a335 3
void	uaudio_chan_psync_transfer(struct chan *);
void	uaudio_chan_psync_intr
	(usbd_xfer_handle, usbd_private_handle, usbd_status);
d1607 1
a1607 1
	const usb_endpoint_descriptor_audio_t *sync_ed;
d1610 1
a1610 1
	int dir, type, sync, sync_addr;
d1656 1
a1656 1
	/* Check for sync endpoint. */
d1658 23
a1680 13
	sync_addr = 0;
	if (id->bNumEndpoints > 1 &&
	    ((dir == UE_DIR_IN && type == UE_ISO_ADAPT) ||
	    (dir != UE_DIR_IN && type == UE_ISO_ASYNC)))
		sync = TRUE;

	/* Check whether sync endpoint address is given. */
	if (ed->bLength >= USB_ENDPOINT_DESCRIPTOR_AUDIO_SIZE) {
		/* bSynchAdress set to 0 indicates sync is not used. */
		if (ed->bSynchAddress == 0)
			sync = FALSE;
		else
			sync_addr = ed->bSynchAddress;
d1692 6
a1697 8
	sync_ed = NULL;
	if (sync == TRUE) {
		sync_ed = (const void*)(buf + offs);
		if (sync_ed->bDescriptorType != UDESC_ENDPOINT) {
			printf("%s: sync ep descriptor wrong type\n",
			    sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
d1702 9
a1710 12
			 sync_ed->bLength, sync_ed->bDescriptorType,
			 sync_ed->bEndpointAddress, sync_ed->bmAttributes,
			 UGETW(sync_ed->wMaxPacketSize), sync_ed->bInterval,
			 sync_ed->bRefresh, sync_ed->bSynchAddress));
		offs += sync_ed->bLength;
		if (offs > size) {
			printf("%s: sync ep descriptor too large\n",
			    sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (dir == UE_GET_DIR(sync_ed->bEndpointAddress)) {
			printf("%s: sync ep wrong direction\n",
d1712 1
a1712 13
			return (USBD_NORMAL_COMPLETION);
		}
		if (UE_GET_XFERTYPE(sync_ed->bmAttributes) != UE_ISOCHRONOUS) {
			printf("%s: sync ep wrong xfer type\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
		}
		if (sync_ed->bLength >=
		    USB_ENDPOINT_DESCRIPTOR_AUDIO_SIZE &&
		    sync_ed->bSynchAddress != 0) {
			printf("%s: sync ep bSynchAddress != 0\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
d1714 12
a1725 4
		if (sync_addr && sync_ed->bEndpointAddress != sync_addr) {
			printf("%s: sync ep address mismatch\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
d1727 1
d1729 1
a1729 5
	if (sync_ed != NULL && dir == UE_DIR_IN) {
		printf("%s: sync pipe for recording not yet implemented\n",
		    sc->sc_dev.dv_xname);
		return (USBD_NORMAL_COMPLETION);
	}
d1792 1
a1792 1
	ai.edesc1 = sync_ed;
d1838 1
d1840 1
a2220 2
		if (sc->sc_playchan.sync_pipe != NULL)
			sc->sc_playchan.sync_pipe = NULL;
a2235 2
		if (sc->sc_recchan.sync_pipe != NULL)
			sc->sc_recchan.sync_pipe = NULL;
a2682 4
	if (ch->sync_pipe) {
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++)
			uaudio_chan_psync_transfer(ch);
	}
d2701 1
a2701 2
	if (err) {
		DPRINTF(("%s: usbd_set_interface failed\n", __func__));
a2702 1
	}
d2723 1
a2723 3
	if (err) {
		printf("%s: error creating pipe: err=%s endpt=0x%02x\n",
		    __func__, usbd_errstr(err), endpt);
a2724 1
	}
a2728 4
		if (err) {
			printf("%s: error creating sync-pipe: err=%s endpt=0x%02x\n",
			    __func__, usbd_errstr(err), endpt);
		}
a2756 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
a2777 16
	if (as->edesc1 != NULL) {
		size = (ch->hi_speed ? 4 : 3) * ch->nsync_frames;
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++) {
			xfer = usbd_alloc_xfer(sc->sc_udev);
			if (xfer == 0)
				goto bad_sync;
			ch->syncbufs[i].xfer = xfer;
			buf = usbd_alloc_buffer(xfer, size);
			if (buf == 0) {
				i++;
				goto bad_sync;
			}
			ch->syncbufs[i].buffer = buf;
			ch->syncbufs[i].chan = ch;
		}
	}
a2785 7

bad_sync:
	while (--i >= 0)
		/* implicit buffer free */
		usbd_free_xfer(ch->syncbufs[i].xfer);
	return (USBD_NOMEM);

a2790 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
a2794 4
	if (as->edesc1 != NULL) {
		for (i = 0; i < UAUDIO_NSYNCBUFS; i++)
			usbd_free_xfer(ch->syncbufs[i].xfer);
	}
d2820 1
a2820 1
		if (residue >= ch->frac_denom) {
d2823 1
a2823 1
			residue -= ch->frac_denom;
a2905 85
uaudio_chan_psync_transfer(struct chan *ch)
{
	struct syncbuf *sb;
	int i, size, total = 0;

	if (ch->sc->sc_dying)
		return;

	/* Pick the next sync buffer. */
	sb = &ch->syncbufs[ch->cursyncbuf];
	if (++ch->cursyncbuf >= UAUDIO_NSYNCBUFS)
		ch->cursyncbuf = 0;

	size = ch->hi_speed ? 4 : 3;
	for (i = 0; i < ch->nsync_frames; i++) {
		sb->sizes[i] = size;
		sb->offsets[i] = total;
		total += size;
	}
	sb->size = total;

	DPRINTFN(5,("%s: transfer xfer=%p\n", __func__, sb->xfer));
	/* Fill the request */
	usbd_setup_isoc_xfer(sb->xfer, ch->sync_pipe, sb, sb->sizes,
	    ch->nsync_frames, USBD_NO_COPY, uaudio_chan_psync_intr);

	(void)usbd_transfer(sb->xfer);
}

void
uaudio_chan_psync_intr(usbd_xfer_handle xfer, usbd_private_handle priv,
    usbd_status status)
{
	struct syncbuf *sb = priv;
	struct chan *ch = sb->chan;
	u_int32_t count, tmp;
	u_int32_t freq, freq_w, freq_f;
	int i, pos, size;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("%s: count=%d\n", __func__, count));

	size = ch->hi_speed ? 4 : 3;
	for (i = 0; count > 0 && i < ch->nsync_frames; i++) {
		if (sb->sizes[i] != size)
			continue;
		count -= size;
		pos = sb->offsets[i];
		if (ch->hi_speed) {
			/* 16.16 (12.13) -> 16.16 (12.16) */
			freq = sb->buffer[pos+3] << 24 |
			    sb->buffer[pos+2] << 16 |
			    sb->buffer[pos+1] << 8 |
			    sb->buffer[pos];
		} else {
			/* 10.14 (10.10) -> 16.16 (10.16) */
			freq = sb->buffer[pos+2] << 18 |
			    sb->buffer[pos+1] << 10 |
			    sb->buffer[pos] << 2;
		}
		freq_w = (freq >> 16) & (ch->hi_speed ? 0x0fff : 0x03ff);
		freq_f = freq & 0xffff;
		DPRINTFN(5,("%s: freq = %d %d/%d\n", __func__, freq_w, freq_f,
		    ch->frac_denom));
		tmp = freq_w * ch->sample_size;
		if (tmp + (freq_f ? ch->sample_size : 0) >
		    ch->max_bytes_per_frame) {
			DPRINTF(("%s: packet size request too large: %d/%d/%d\n",
			    __func__, tmp, ch->max_bytes_per_frame, ch->maxpktsize));
		} else {
			ch->bytes_per_frame = tmp;
			ch->fraction = freq_f;
		}
	}

	/* start next transfer */
	uaudio_chan_psync_transfer(ch);
}

/* Called at splusb() */
void
a3086 18
	ch->frac_denom = ch->usb_fps;
	if (ai->edesc1 != NULL) {
		/*
		 * The lower 16-bits of the sync request represent
		 * fractional samples.  Scale up the fraction here once
		 * so all fractions are using the same denominator.
		 */
		ch->frac_denom = 1 << 16;
		ch->fraction = (ch->fraction * ch->frac_denom) / ch->usb_fps;

		/*
		 * Have to set nsync_frames somewhere.  We can request
		 * a lot of sync data; the device will reply when it's
		 * ready, with empty frames meaning to keep using the
		 * current rate.
		 */
		ch->nsync_frames = UAUDIO_MAX_FRAMES;
	}
@


1.83
log
@add a couple quirks for the E-MU 0202
* the clock rate is configured through the audio interface, instead
of on the endpoint.
* since the clock rate is set on the interface, both play and
record must use the same sample rate.  this means the playback
and recording parameters are not independent, which is what uaudio
assumes.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.82 2010/07/21 05:57:19 jakemsr Exp $ */
a70 1
/* #define UAUDIO_MULTIPLE_ENDPOINTS */
d83 1
d132 2
a133 1
	u_int	fraction;	/* fraction/usb_fps is the extra samples/frame */
d136 1
d151 2
d162 9
d349 3
d1623 1
a1623 1
	const usb_endpoint_descriptor_audio_t *epdesc1;
d1626 1
a1626 1
	int dir, type, sync;
d1672 1
a1672 1
	/* We can't handle endpoints that need a sync pipe yet. */
d1674 13
a1686 23
	/* bSynchAddress set to 0 indicates sync pipe is not needed. */
	if (ed->bSynchAddress != 0) {
		if (dir == UE_DIR_IN && type == UE_ISO_ADAPT) {
			sync = TRUE;
#ifndef UAUDIO_MULTIPLE_ENDPOINTS
			printf("%s: ignored input endpoint of type adaptive\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
#endif
		}
		if (dir != UE_DIR_IN && type == UE_ISO_ASYNC) {
			sync = TRUE;
#ifndef UAUDIO_MULTIPLE_ENDPOINTS
			printf("%s: ignored output endpoint of type async\n",
			       sc->sc_dev.dv_xname);
			return (USBD_NORMAL_COMPLETION);
#endif
		}
	}
	if (sync && id->bNumEndpoints < 2) {
		printf("%s: sync pipe needed, but no sync endpoint given\n",
		       sc->sc_dev.dv_xname);
		return (USBD_NORMAL_COMPLETION);
d1698 8
a1705 6
	epdesc1 = NULL;
#ifdef UAUDIO_MULTIPLE_ENDPOINTS
	if (sync) {
		epdesc1 = (const void*)(buf + offs);
		if (epdesc1->bDescriptorType != UDESC_ENDPOINT)
			return USBD_INVAL;
d1710 12
a1721 9
			 epdesc1->bLength, epdesc1->bDescriptorType,
			 epdesc1->bEndpointAddress, epdesc1->bmAttributes,
			 UGETW(epdesc1->wMaxPacketSize), epdesc1->bInterval,
			 epdesc1->bRefresh, epdesc1->bSynchAddress));
		offs += epdesc1->bLength;
		if (offs > size)
			return USBD_INVAL;
		if (epdesc1->bSynchAddress != 0) {
			printf("%s: invalid endpoint: bSynchAddress=0\n",
d1723 13
a1735 1
			return USBD_INVAL;
d1737 4
a1740 12
		if (UE_GET_XFERTYPE(epdesc1->bmAttributes) != UE_ISOCHRONOUS) {
			printf("%s: invalid endpoint: bmAttributes=0x%x\n",
			       sc->sc_dev.dv_xname, epdesc1->bmAttributes);
			return USBD_INVAL;
		}
		if (epdesc1->bEndpointAddress != ed->bSynchAddress) {
			printf("%s: invalid endpoint addresses: "
			       "ep[0]->bSynchAddress=0x%x "
			       "ep[1]->bEndpointAddress=0x%x\n",
			       sc->sc_dev.dv_xname, ed->bSynchAddress,
			       epdesc1->bEndpointAddress);
			return USBD_INVAL;
a1741 1
		/* UE_GET_ADDR(epdesc1->bEndpointAddress), and epdesc1->bRefresh */
d1743 5
a1747 1
#endif
d1810 1
a1810 1
	ai.edesc1 = epdesc1;
a1855 1
#ifdef UAUDIO_MULTIPLE_ENDPOINTS
a1856 1
#endif
d2237 2
d2254 2
d2703 4
d2725 2
a2726 1
	if (err)
d2728 1
d2749 3
a2751 1
	if (err)
d2753 1
d2758 4
d2790 1
d2812 16
d2836 7
d2848 1
d2853 4
d2882 1
a2882 1
		if (residue >= ch->usb_fps) {
d2885 1
a2885 1
			residue -= ch->usb_fps;
d2968 85
d3234 18
@


1.82
log
@* check that the bytes per frame the device is reporting isn't a
ridiculous value.
* encoding expansion factor is always 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.81 2010/07/21 05:54:42 jakemsr Exp $ */
d166 2
d178 2
a179 1
		UAUDIO_FLAG_VENDOR_CLASS },
d323 1
d2300 4
a2303 1
	int props;
a2304 1
	props = AUDIO_PROP_INDEPENDENT;
d2716 3
d3384 26
@


1.81
log
@move use_maxpkt out of struct chan, use a local variable in the
only function that was using it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.80 2010/07/21 05:04:57 jakemsr Exp $ */
d1605 1
a1605 1
	int format, chan, prec, enc;
d1730 4
a1733 3
	if (prec != 8 && prec != 16 && prec != 24) {
		printf("%s: ignored setting with precision %d\n",
		       sc->sc_dev.dv_xname, prec);
d3030 1
a3030 1
	ch->sample_size = param->factor * param->channels * param->bps;
@


1.80
log
@some bits for USB 2.0 playback support.  I'm not 100% sure about
scaling the frame rate to the polling interval, but it works on
the E-MU 0202 and it generally makes a lot of sense, especially
considering that this often brings the frames rate back to 1 kHz,
which is the frame rate of USB 1.x, which was the most current
USB spec when USB audio 1.0 spec was written.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.79 2010/07/21 03:06:35 jakemsr Exp $ */
a136 1
	u_int	use_maxpkt;	/* whether to always use maxpktsize */
d3013 1
a3013 1
	int samples_per_frame, ival;
a3014 1
	ch->use_maxpkt = 0;
d3018 1
a3018 1
		ch->use_maxpkt = 1;
d3023 1
a3023 1
		ch->use_maxpkt = 1;
d3050 1
a3050 1
	if (!ch->use_maxpkt) {
d3071 1
a3071 1
	if (!ch->use_maxpkt)
@


1.79
log
@currently we use the endpoint's maximum packet size for recording,
and for playback, we use a packet size that is at least one audio
frame smaller.

in most usb audio devices, the sample clock is synced to the usb
clock.  this means that for sample rates that aren't multiples of
1000, we'll occasionally need to add a frame to adjust the overall
rate.  that's why we use the smaller packet size.

also, the usb audio spec defines a way for devices to request
to always use the maximum packet size.

so,
* add a max_bytes_per_frame, which is the largest packet size
the channel will use.  use that instead of calculating what
the maximum we will use is in a couple places.  generally makes
things easier to understand.
* respect a device's request to always use maximum packet size.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.78 2010/07/20 23:46:11 jakemsr Exp $ */
d55 2
d66 1
d132 1
a132 1
	u_int	fraction;	/* fraction/1000 is the extra samples/frame */
d135 1
a135 1
	u_int   usb_fps;
d139 1
d3014 1
a3014 1
	int samples_per_frame;
d3033 13
d3079 2
@


1.78
log
@support 24-bit encodings.  simplify the way supported encodings are
handled by storing an array of supported encodings.

NOTE: this also removes all conversions from this driver.  in
particular, uaudio no longer supports 16-bit big endian encodings,
because the USB audio specification only supports little endian
encodings.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.77 2010/07/19 07:57:36 jakemsr Exp $ */
d128 1
d134 1
d324 1
a324 1
	(struct chan *, int, const struct audio_params *, int);
d2259 3
a2261 3
	DPRINTF(("uaudio_round_blocksize: p.bpf=%d r.bpf=%d\n",
		 sc->sc_playchan.bytes_per_frame,
		 sc->sc_recchan.bytes_per_frame));
d2265 1
a2265 2
		pbpf = (sc->sc_playchan.bytes_per_frame +
		    sc->sc_playchan.sample_size) *
d2269 1
a2269 2
		rbpf = (sc->sc_recchan.bytes_per_frame +
		    sc->sc_recchan.sample_size) *
d2748 4
a2751 1
	size = (ch->bytes_per_frame + ch->sample_size) * ch->nframes;
d3006 2
a3007 2
uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param,
    int maxpktsize)
d3009 1
d3012 12
d3025 1
a3025 1
	ch->maxpktsize = maxpktsize;
d3035 1
a3035 1
	if (ch->maxpktsize == 0) {
d3037 5
a3048 4
		if (ch->nframes > UAUDIO_MAX_FRAMES)
			ch->nframes = UAUDIO_MAX_FRAMES;
		else if (ch->nframes < 1)
			ch->nframes = 1;
d3050 11
d3311 1
a3311 1
		uaudio_chan_init(&sc->sc_playchan, paltidx, play, 0);
d3320 1
a3320 2
		uaudio_chan_init(&sc->sc_recchan, raltidx, rec,
		    UGETW(sc->sc_alts[raltidx].edesc->wMaxPacketSize));
@


1.77
log
@* don't round blocksize to multiples of 16; can cause problems when
sample size or number of channels is not a power of 2.
* use 'param->bps' instead of 'param->precision / NBBY' for the number
of bytes per sample.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.76 2010/07/19 05:50:37 jakemsr Exp $ */
d208 2
d262 2
d340 1
a340 1
int	uaudio_match_alt(void *, struct audio_params *, int, int, int);
d516 2
a574 2
	int flags = sc->sc_altflags;
	int idx;
d579 1
a579 1
	if (sc->sc_nalts == 0 || flags == 0)
d582 1
a582 51
	idx = fp->index;
	switch (idx) {
	case 0:
		strlcpy(fp->name, AudioEulinear, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR;
		fp->precision = 8;
		fp->flags = flags&HAS_8U ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 1:
		strlcpy(fp->name, AudioEmulaw, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULAW;
		fp->precision = 8;
		fp->flags = flags&HAS_MULAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 2:
		strlcpy(fp->name, AudioEalaw, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ALAW;
		fp->precision = 8;
		fp->flags = flags&HAS_ALAW ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 3:
		strlcpy(fp->name, AudioEslinear, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR;
		fp->precision = 8;
		fp->flags = flags&HAS_8 ? 0 : AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 4:
		strlcpy(fp->name, AudioEslinear_le, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR_LE;
		fp->precision = 16;
		fp->flags = 0;
		break;
	case 5:
		strlcpy(fp->name, AudioEulinear_le, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR_LE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 6:
		strlcpy(fp->name, AudioEslinear_be, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_SLINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	case 7:
		strlcpy(fp->name, AudioEulinear_be, sizeof(fp->name));
		fp->encoding = AUDIO_ENCODING_ULINEAR_BE;
		fp->precision = 16;
		fp->flags = AUDIO_ENCODINGFLAG_EMULATED;
		break;
	default:
d584 2
a585 3
	}
	fp->bps = AUDIO_BPS(fp->precision);
	fp->msb = 1;
d1513 77
d1764 1
a1764 1
	printf("%s: %s: %dch, %d/%dbit, %s,", sc->sc_dev.dv_xname,
d1766 1
a1766 1
	       chan, prec, asf1d->bSubFrameSize * 8, format_str);
d2306 1
a2306 1
	int flags;
d2341 3
a2343 4
	uaudio_match_alt(sc, p, mode, p->encoding, p->precision);

	p->bps = AUDIO_BPS(p->precision);
	p->msb = 1;
d3105 1
a3105 1
uaudio_match_alt(void *addr, struct audio_params *p, int mode, int enc, int pre)
d3112 4
d3122 3
a3124 1
		if (sc->sc_alts[i].encoding != enc)
d3127 1
a3127 1
		if (a1d->bBitResolution != pre)
d3130 2
d3144 1
a3144 1
			if (a1d->bNrChannels == p->channels)
d3146 3
d3173 2
d3198 1
a3198 1
		  struct audio_params *play, struct audio_params *rec)
d3202 2
a3203 4
	int factor;
	int enc, pre, i;
	int paltidx=-1, raltidx=-1;
	void (*swcode)(void *, u_char *buf, int cnt);
d3230 7
a3236 26
		factor = 1;
		swcode = 0;
		enc = p->encoding;
		pre = p->precision;
		switch (enc) {
		case AUDIO_ENCODING_SLINEAR_BE:
			/* FALLTHROUGH */
		case AUDIO_ENCODING_SLINEAR_LE:
			if (enc == AUDIO_ENCODING_SLINEAR_BE
			    && pre == 16 && (flags & HAS_16)) {
				swcode = swap_bytes;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else if (pre == 8) {
				if (flags & HAS_8) {
					/* No conversion */
				} else if (flags & HAS_8U) {
					swcode = change_sign8;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_16) {
					factor = 2;
					pre = 16;
					if (mode == AUMODE_PLAY)
						swcode = linear8_to_linear16_le;
					else
						swcode = linear16_to_linear8_le;
				}
d3239 4
a3242 8
		case AUDIO_ENCODING_ULINEAR_BE:
			/* FALLTHROUGH */
		case AUDIO_ENCODING_ULINEAR_LE:
			if (pre == 16) {
				if (enc == AUDIO_ENCODING_ULINEAR_LE)
					swcode = change_sign16_le;
				else if (mode == AUMODE_PLAY)
					swcode = swap_bytes_change_sign16_le;
d3244 1
a3244 17
					swcode = change_sign16_swap_bytes_le;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else if (pre == 8) {
				if (flags & HAS_8U) {
					/* No conversion */
				} else if (flags & HAS_8) {
					swcode = change_sign8;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else if (flags & HAS_16) {
					factor = 2;
					pre = 16;
					enc = AUDIO_ENCODING_SLINEAR_LE;
					if (mode == AUMODE_PLAY)
						swcode = ulinear8_to_linear16_le;
					else
						swcode = linear16_to_ulinear8_le;
				}
d3247 4
a3250 32
		case AUDIO_ENCODING_ULAW:
			if (flags & HAS_MULAW)
				break;
			if (flags & HAS_16) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear16_le;
				else
					swcode = slinear16_to_mulaw_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				pre = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_ulinear8;
				else
					swcode = ulinear8_to_mulaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear8;
				else
					swcode = slinear8_to_mulaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
			break;
		case AUDIO_ENCODING_ALAW:
			if (flags & HAS_ALAW)
				break;
			if (flags & HAS_16) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_slinear16_le;
d3252 2
a3253 18
					swcode = slinear16_to_alaw_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				pre = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_ulinear8;
				else
					swcode = ulinear8_to_alaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_slinear8;
				else
					swcode = slinear8_to_alaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
a3254 2
		default:
			return (EINVAL);
a3255 1
		/* XXX do some other conversions... */
d3257 6
a3262 6
		DPRINTF(("uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n",
			 p->channels, pre, enc, p->sample_rate));

		i = uaudio_match_alt(sc, p, mode, enc, pre);
		if (i < 0)
			return (EINVAL);
d3264 2
a3265 2
		p->sw_code = swcode;
		p->factor  = factor;
d3267 1
a3267 1
		p->bps = AUDIO_BPS(p->precision);
d3276 6
a3281 1
	if ((setmode & AUMODE_PLAY)) {
d3285 6
a3290 1
	if ((setmode & AUMODE_RECORD)) {
@


1.76
log
@add a quirk to allow attaching devices which claim to have a vendor
defined interface class, but are audio class compliant enough to
be supported by this driver.
the E-MU 0202 USB is such a device.  this gets it attaching, but
needs some forthcoming commits to make it usable.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.75 2010/07/19 05:08:37 jakemsr Exp $ */
a2243 2
	bpf = (bpf + 15) &~ 15;

d2982 1
a2982 2
	ch->sample_size = param->factor * param->channels *
	    param->precision / NBBY;
@


1.75
log
@move audio specific quirks out of usb_quirks and into uaudio

ok krw
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.74 2010/07/15 03:43:12 jakemsr Exp $ */
d160 1
d170 2
d261 1
a261 1
	(const char *, int, int *, int);
d432 6
d638 1
a638 1
uaudio_find_iface(const char *buf, int size, int *offsp, int subtype)
d646 4
a649 2
		    d->bInterfaceClass == UICLASS_AUDIO &&
		    d->bInterfaceSubClass == subtype)
d1782 2
a1783 1
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);
d1809 2
a1810 1
		id = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);
d1844 2
a1845 1
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);
@


1.74
log
@add two new members to structs audio_encoding and audio_prinfo.
for both structs, the new members are 'bps' and 'msb', which
describe the number of bytes per sample and data alignment in the
sample, respectively.  drivers must properly set these fields in
the 'query_encoding', 'set_parameters' and 'get_default_params'
hardware interface methods.

discussed with ratchov, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.73 2009/12/04 20:50:59 jakemsr Exp $ */
d61 1
a63 1
#include <dev/usb/usb_quirks.h>
d156 29
d209 1
d410 2
d417 1
a417 5
	/* Trigger on the control interface. */
	if (id == NULL ||
	    id->bInterfaceClass != UICLASS_AUDIO ||
	    id->bInterfaceSubClass != UISUBCLASS_AUDIOCONTROL ||
	    (usbd_get_quirks(uaa->device)->uq_flags & UQ_BAD_AUDIO))
d420 10
a429 1
	return (UMATCH_IFACECLASS_IFACESUBCLASS);
d437 1
d445 4
d498 1
a498 1
	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_FRAC)
d1313 1
a1313 1
	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_XU)
d1849 1
a1849 1
	if (!(usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_BAD_ADC) &&
@


1.73
log
@calculate the number of frames per usb xfer only once, and take into
account possible "fractional samples" which occur when the usb frame
rate is not a whole number factor of the audio sample rate, such as
with 44.1 kHz audio sample rate and full-speed usb (1 kHz frame rate).
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.72 2009/12/04 20:38:43 jakemsr Exp $ */
d534 1
a534 1
		return (0);
d540 1
a540 1
		return (0);
d546 1
a546 1
		return (0);
d552 1
a552 1
		return (0);
d558 1
a558 1
		return (0);
d564 1
a564 1
		return (0);
d570 1
a570 1
		return (0);
d576 1
a576 1
		return (0);
d580 4
d2228 2
d2258 3
d3259 3
@


1.72
log
@instead of returning a structure, return the only member of the
structure that will be used.  discussed with deraadt.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.71 2009/12/04 08:17:39 ratchov Exp $ */
d2957 1
a2957 1
	 * is not longer in time duration than blksize.  Rounding helps.
d2959 3
a2961 7
	if (ch->maxpktsize) {
		ch->nframes = ch->blksize / ch->maxpktsize;
	} else {
		ch->nframes = (ch->blksize / ch->sample_size) *
		    ch->usb_fps / ch->sample_rate;
	}
	ch->nframes = ch->blksize / ch->bytes_per_frame;
@


1.71
log
@In uaudio_detach(), check that sc->sc_alts is not NULL before
using it.  This could happen if uaudio_attach() failed, for
instance because the device has no valid audio stream interface.
Certain MIDI devices expose such descriptors.

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.70 2009/11/26 15:45:25 jakemsr Exp $ */
d233 1
a233 1
struct usb_audio_cluster uaudio_get_cluster
d672 2
a673 2
struct usb_audio_cluster
uaudio_get_cluster(int id, const struct io_terminal *iot)
d685 1
a685 4
			r.bNrChannels = iot[id].d.it->bNrChannels;
			USETW(r.wChannelConfig, UGETW(iot[id].d.it->wChannelConfig));
			r.iChannelNames = iot[id].d.it->iChannelNames;
			return (r);
d692 1
a692 1
			return (r);
d703 1
a703 1
			return (r);
d707 1
a707 1
			return (r);
d712 3
a714 5
 bad:
	printf("uaudio_get_cluster: bad data\n");
	memset(&r, 0, sizeof r);
	return (r);

d760 1
a760 1
		ichs += uaudio_get_cluster(d->baSourceId[i], iot).bNrChannels;
d774 1
a774 1
		chs = uaudio_get_cluster(d->baSourceId[i], iot).bNrChannels;
@


1.70
log
@allow USB xfer requests to use up to 16 frames per xfer, depending on
blocksize
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.69 2009/11/26 15:34:15 jakemsr Exp $ */
d493 6
@


1.69
log
@greatly reduce latency and kill some XXXs:
* reduce number of outstanding USB xfers: 6 -> 3
* reduce number of USB frames per xfer: 10 -> 2
* if the device uses wMaxPacketSize frame sizes that are longer than
  1 ms, allow 1 frame per xfer
* instead of making blocksizes big enough to hold all outstanding
  xfers, just make it big enough to hold one xfer
* calculate blocksizes a little better
* be more careful to let the upper layer know exactly when a block
  has been moved in/out of the upper layer buffer

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.68 2009/11/03 08:31:44 jakemsr Exp $ */
d79 2
a80 1
#define UAUDIO_NFRAMES   2	/* ms of sound in each request */
d131 3
d148 2
a149 2
		u_int16_t	sizes[UAUDIO_NFRAMES];
		u_int16_t	offsets[UAUDIO_NFRAMES];
d490 3
a492 1
	int rv = 0;
d495 3
a497 1
	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
d2099 3
d2103 4
a2106 1
	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);
d2711 1
a2711 1
		if (residue >= USB_FRAMES_PER_SECOND) {
d2714 1
a2714 1
			residue -= USB_FRAMES_PER_SECOND;
d2913 1
a2913 1
	int samples_per_frame, sample_size;
d2916 1
a2916 3
	sample_size = param->precision * param->factor * param->channels / 8;
	samples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;
	ch->sample_size = sample_size;
d2918 13
a2930 4
	if (maxpktsize == 0) {
		ch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;
		ch->bytes_per_frame = samples_per_frame * sample_size;
		ch->nframes = UAUDIO_NFRAMES;
d2933 5
a2937 5
		ch->bytes_per_frame = maxpktsize;
		ch->nframes = UAUDIO_NFRAMES * samples_per_frame *
		    sample_size / maxpktsize;
		if (ch->nframes > UAUDIO_NFRAMES)
			ch->nframes = UAUDIO_NFRAMES;
d2950 2
a2952 1
	ch->transferred = 0;
d2954 22
a2975 1
	ch->curchanbuf = 0;
@


1.68
log
@don't take playback blocksize constraints into account when rounding
blocksizes if the device doesn't support playback.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.67 2009/11/03 08:07:27 jakemsr Exp $ */
d78 2
a79 2
#define UAUDIO_NCHANBUFS 6	/* number of outstanding request */
#define UAUDIO_NFRAMES   10	/* ms of sound in each request */
d129 1
d2141 4
a2144 1
 * Make sure the block size is large enough to hold all outstanding transfers.
d2150 1
a2150 1
	int bpf;
d2155 11
a2165 7
	if ((sc->sc_mode & AUMODE_PLAY) &&
	    sc->sc_playchan.bytes_per_frame > sc->sc_recchan.bytes_per_frame) {
		bpf = sc->sc_playchan.bytes_per_frame
		    + sc->sc_playchan.sample_size;
	} else {
		bpf = sc->sc_recchan.bytes_per_frame
		    + sc->sc_recchan.sample_size;
d2167 1
a2167 2
	/* XXX */
	bpf *= UAUDIO_NFRAMES * UAUDIO_NCHANBUFS;
d2522 1
a2522 1
	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */
d2564 1
a2564 1
	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */
d2641 1
a2641 1
	size = (ch->bytes_per_frame + ch->sample_size) * UAUDIO_NFRAMES;
d2679 1
d2681 1
d2694 1
a2694 1
	for (i = 0; i < UAUDIO_NFRAMES; i++) {
d2709 3
a2711 2
	 * Transfer data from upper layer buffer to channel buffer, taking
	 * care of wrapping the upper layer buffer.
d2713 5
a2717 6
	n = min(total, ch->end - ch->cur);
	memcpy(cb->buffer, ch->cur, n);
	ch->cur += n;
	if (ch->cur >= ch->end)
		ch->cur = ch->start;
	if (total > n) {
d2719 15
a2733 2
		memcpy(cb->buffer + n, ch->cur, total);
		ch->cur += total;
d2740 1
a2740 1
		for (i = 0; i < UAUDIO_NFRAMES; i++) {
d2746 1
a2746 1
	DPRINTFN(5,("uaudio_chan_transfer: ptransfer xfer=%p\n", cb->xfer));
d2749 1
a2749 1
			     UAUDIO_NFRAMES, USBD_NO_COPY,
a2761 1
	int s;
a2776 11
	ch->transferred += cb->size;
	s = splaudio();
	/* Call back to upper layer */
	while (ch->transferred >= ch->blksize) {
		ch->transferred -= ch->blksize;
		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n",
			    ch->intr, ch->arg));
		ch->intr(ch->arg);
	}
	splx(s);

d2799 1
a2799 1
	for (i = 0; i < UAUDIO_NFRAMES; i++) {
d2812 1
a2812 1
		for (i = 0; i < UAUDIO_NFRAMES; i++) {
d2821 1
a2821 1
			     UAUDIO_NFRAMES, USBD_NO_COPY,
d2833 1
d2857 1
a2857 1
	for(i = 0; i < UAUDIO_NFRAMES; i++) {
d2859 25
a2883 9
		n = min(frsize, ch->end - ch->cur);
		memcpy(ch->cur, cb->buffer + cb->offsets[i], n);
		ch->cur += n;
		if (ch->cur >= ch->end)
			ch->cur = ch->start;
		if (frsize > n) {
			memcpy(ch->cur, cb->buffer + cb->offsets[i] + n,
			    frsize - n);
			ch->cur += frsize - n;
d2886 3
a2888 9

	/* Call back to upper layer */
	ch->transferred += count;
	s = splaudio();
	while (ch->transferred >= ch->blksize) {
		ch->transferred -= ch->blksize;
		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n",
			    ch->intr, ch->arg));
		ch->intr(ch->arg);
a2889 1
	splx(s);
d2909 1
d2913 6
@


1.67
log
@don't claim to support full-duplex if the device doesn't support both
recording and playback
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.66 2009/11/03 08:04:38 jakemsr Exp $ */
d2151 2
a2152 1
	if (sc->sc_playchan.bytes_per_frame > sc->sc_recchan.bytes_per_frame) {
@


1.66
log
@provide a get_default_params method.  tries aucat(1) defaults first
but returns the closest parameters the device supports.

ok rathcov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.65 2009/11/03 07:57:24 jakemsr Exp $ */
d2180 7
a2186 1
	return (AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT);
d2188 1
@


1.65
log
@rewrite supported audio parameter matching code
- easier to read/follow
- if can't match desired parameters exactly, find closest match instead
of returning an error.  this is how most other audio drivers work.

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.64 2009/10/17 07:10:37 jakemsr Exp $ */
d315 1
d344 1
a344 1
	NULL
d2182 40
@


1.64
log
@remove bogus quirk.  these devices do not lie about their type, but
they do have bSynchAddress set to 0 in their endpoint descriptor.
uaudio(4) used to not handle that correctly, but now does.

positive response from krw, deraadt, ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.63 2009/10/15 08:47:44 jakemsr Exp $ */
d81 1
d297 2
a298 7
int	uaudio_match_alt_sub
	(int, const struct as_info *, const struct audio_params *, 
	 int, int, int, u_long);
int	uaudio_match_alt_chan
	(int, const struct as_info *, struct audio_params *, int, int, int);
int	uaudio_match_alt
	(int, const struct as_info *, struct audio_params *, int, int, int);
d1687 2
a1688 1
	uaudio_add_alt(sc, &ai);
d2859 2
a2860 5
void
uaudio_get_minmax_rates(int nalts, const struct as_info *alts,
			const struct audio_params *p, int mode,
			int enc, int pre,
			u_long *min, u_long *max)
d2862 1
d2864 1
a2864 1
	int i, j;
d2866 5
a2870 21
	*min = ULONG_MAX;
	*max = 0;
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
			continue;
		if (p->channels != a1d->bNrChannels)
			continue;
		if (pre != a1d->bBitResolution)
			continue;
		if (enc != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(2,("uaudio_get_minmax_rates: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) < *min)
				*min = UA_SAMP_LO(a1d);
			if (UA_SAMP_HI(a1d) > *max)
				*max = UA_SAMP_HI(a1d);
d2872 7
d2880 4
a2883 6
				DPRINTFN(2,("uaudio_get_minmax_rates: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				if (UA_GETSAMP(a1d, j) < *min)
					*min = UA_GETSAMP(a1d, j);
				if (UA_GETSAMP(a1d, j) > *max)
					*max = UA_GETSAMP(a1d, j);
d2886 6
d2893 2
d2898 1
a2898 3
uaudio_match_alt_sub(int nalts, const struct as_info *alts, 
		     const struct audio_params *p, int mode, 
		     int enc, int pre, u_long rate)
d2900 1
d2902 2
a2903 1
	int i, j;
d2905 5
a2909 5
	DPRINTF(("uaudio_match_alt_sub: search for %luHz %dch\n",
		 rate, p->channels));
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
d2911 1
a2911 1
		if (p->channels != a1d->bNrChannels)
d2913 2
a2914 1
		if (pre != a1d->bBitResolution)
d2916 15
a2930 17
		if (enc != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(3,("uaudio_match_alt_sub: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) <= rate && rate <= UA_SAMP_HI(a1d))
				return i;
		} else {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				DPRINTFN(3,("uaudio_match_alt_sub: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				/* XXX allow for some slack */
				if (UA_GETSAMP(a1d, j) == rate)
					return i;
			}
d2932 15
a2947 2
	return -1;
}
d2949 9
a2957 26
int
uaudio_match_alt_chan(int nalts, const struct as_info *alts,
		      struct audio_params *p, int mode, int enc, int pre)
{
	int i, n;
	u_long min, max;
	u_long rate;

	/* Exact match */
	DPRINTF(("uaudio_match_alt_chan: examine %ldHz %dch %dbit.\n",
		 p->sample_rate, p->channels, pre));
	i = uaudio_match_alt_sub(nalts, alts, p, mode, enc, pre, p->sample_rate);
	if (i >= 0)
		return i;

	uaudio_get_minmax_rates(nalts, alts, p, mode, enc, pre, &min, &max);
	DPRINTF(("uaudio_match_alt_chan: min=%lu max=%lu\n", min, max));
	if (max <= 0)
		return -1;
	/* Search for biggers */
	n = 2;
	while ((rate = p->sample_rate * n++) <= max) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, enc, pre, rate);
		if (i >= 0) {
			p->sample_rate = rate;
			return i;
d2960 2
a2961 6
	if (p->sample_rate >= min) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, enc, pre, max);
		if (i >= 0) {
			p->sample_rate = max;
			return i;
		}
d2963 7
a2969 4
		i = uaudio_match_alt_sub(nalts, alts, p, mode, enc, pre, min);
		if (i >= 0) {
			p->sample_rate = min;
			return i;
a2971 2
	return -1;
}
d2973 1
a2973 22
int
uaudio_match_alt(int nalts, const struct as_info *alts,
		 struct audio_params *p, int mode, int enc, int pre)
{
	int i, n;

	mode = mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN;
	i = uaudio_match_alt_chan(nalts, alts, p, mode, enc, pre);
	if (i >= 0)
		return i;

	for (n = p->channels + 1; n <= AUDIO_MAX_CHANNELS; n++) {
		p->channels = n;
		i = uaudio_match_alt_chan(nalts, alts, p, mode, enc, pre);
		if (i >= 0)
			return i;
	}

	if (p->channels != 2)
		return -1;
	p->channels = 1;
	return uaudio_match_alt_chan(nalts, alts, p, mode, enc, pre);
d3128 1
a3128 1
		i = uaudio_match_alt(sc->sc_nalts, sc->sc_alts, p, mode, enc, pre);
@


1.63
log
@If the bSynchAddress of the AudioStreaming isochronous audio data
endpoint descriptor is set to 0, it means that a synchronization
pipe is not needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.62 2009/10/13 19:33:17 pirofti Exp $ */
a1551 3
	if ((usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_INP_ASYNC) &&
	    dir == UE_DIR_IN && type == UE_ISO_ADAPT)
		type = UE_ISO_ASYNC;
@


1.62
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.61 2008/11/21 17:55:02 robert Exp $ */
d1558 4
a1561 2
	if (dir == UE_DIR_IN && type == UE_ISO_ADAPT) {
		sync = TRUE;
d1563 11
a1573 3
		printf("%s: ignored input endpoint of type adaptive\n",
		       sc->sc_dev.dv_xname);
		return (USBD_NORMAL_COMPLETION);
d1575 1
d1577 2
a1578 4
	if (dir != UE_DIR_IN && type == UE_ISO_ASYNC) {
		sync = TRUE;
#ifndef UAUDIO_MULTIPLE_ENDPOINTS
		printf("%s: ignored output endpoint of type async\n",
a1580 1
#endif
a1591 10
	if (sync && id->bNumEndpoints <= 1) {
		printf("%s: a sync-pipe endpoint but no other endpoint\n",
		       sc->sc_dev.dv_xname);
		return USBD_INVAL;
	}
	if (!sync && id->bNumEndpoints > 1) {
		printf("%s: non sync-pipe endpoint but multiple endpoints\n",
		       sc->sc_dev.dv_xname);
		return USBD_INVAL;
	}
d1593 2
a1594 1
	if (id->bNumEndpoints > 1) {
d1629 1
@


1.61
log
@cast d->bmaControls to uByte * in uaudio_add_feature()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.60 2008/11/12 16:01:09 sthen Exp $ */
d359 1
a359 1
int uaudio_activate(struct device *, enum devact); 
d467 1
a467 1
uaudio_activate(struct device *self, enum devact act)
@


1.60
log
@fix typo in debug printf; ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.59 2008/06/26 05:42:18 ray Exp $ */
d1061 1
a1061 1
	uByte *ctls = d->bmaControls;
@


1.59
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.58 2008/06/17 16:51:40 jakemsr Exp $ */
d1579 1
a1579 1
	DPRINTF((" streadming_endpoint: offset=%d bLength=%d\n", offs, sed->bLength));
@


1.58
log
@
if reading (or writing) is not supported, but the device is opened
for reading (or writing), return ENXIO (Device not configured) instead
of EACCES (Permission denied).

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.57 2008/04/21 00:32:43 jakemsr Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.57
log
@
allow low level audio drivers to specify a default sample format,
instead of 8-bit mono mulaw @@ 8kHz.

this is just the infrastructure; no drivers are specifying a default
yet.

ok ratchov@@, deanna@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.56 2007/12/02 14:59:31 robert Exp $ */
d2077 1
a2077 1
		return (EACCES);
d2079 1
a2079 1
		return (EACCES);
@


1.56
log
@spelling fix in debug printf
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.55 2007/11/05 00:17:28 jakemsr Exp $ */
d354 1
@


1.55
log
@audio encoding conversion cleanup

- the endianness of the conversions don't depend on the endianness
  of machine the conversions are built on, but the endianness of the
  audio data itself.  choose encoding conversions explicitly, instead
  of relying on #defines based on the endianness of the machine.
- replace home-grown conversions with comparable conversions in
  auconv.c and mulaw.c
- use the proper conversion for ulinear_be:16 -> slinear_le:16 in
  auixp(4)

thanks ajacoutot@@ and sthen@@ for !x86 testing
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.54 2007/10/11 18:33:14 deraadt Exp $ */
d1521 1
a1521 1
	DPRINTF(("uaudio_process_as: asid: bTerminakLink=%d wFormatTag=%d\n",
@


1.54
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.53 2007/09/28 07:55:15 jakemsr Exp $ */
d3091 1
a3091 1
					swcode = change_sign16;
d3093 1
a3093 1
					swcode = swap_bytes_change_sign16;
d3095 1
a3095 1
					swcode = change_sign16_swap_bytes;
@


1.53
log
@no longer used macros

spotted by brad

ok ratchov
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.52 2007/09/25 18:11:47 ratchov Exp $ */
a405 1
	char *devinfop;
a407 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf(": %s\n", devinfop);
	usbd_devinfo_free(devinfop);
@


1.52
log
@fix emulated encodings

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.51 2007/09/11 13:39:34 gilles Exp $ */
a475 8

/*
 * Macros to help sync OpenBSD to NetBSD
 */
#define hw_channels channels
#define hw_sample_rate sample_rate
#define hw_precision precision
#define hw_encoding encoding
@


1.51
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.50 2007/09/09 01:00:35 fgsch Exp $ */
d302 1
a302 1
	 int, u_long *, u_long *);
d304 2
a305 1
	(int, const struct as_info *, const struct audio_params *, int, u_long);
d307 1
a307 1
	(int, const struct as_info *, struct audio_params *, int);
d309 1
a309 1
	(int, const struct as_info *, struct audio_params *, int);
d2858 2
a2859 2
	sample_size = param->precision * param->factor * param->hw_channels / 8;
	samples_per_frame = param->hw_sample_rate / USB_FRAMES_PER_SECOND;
d2861 1
a2861 1
	ch->sample_rate = param->hw_sample_rate;
d2863 1
a2863 1
		ch->fraction = param->hw_sample_rate % USB_FRAMES_PER_SECOND;
d2887 1
d2899 1
a2899 1
		if (p->hw_channels != a1d->bNrChannels)
d2901 1
a2901 1
		if (p->hw_precision != a1d->bBitResolution)
d2903 1
a2903 1
		if (p->hw_encoding != alts[i].encoding)
d2928 3
a2930 2
uaudio_match_alt_sub(int nalts, const struct as_info *alts,
		     const struct audio_params *p, int mode, u_long rate)
d2936 1
a2936 1
		 rate, p->hw_channels));
d2941 1
a2941 1
		if (p->hw_channels != a1d->bNrChannels)
d2943 1
a2943 1
		if (p->hw_precision != a1d->bBitResolution)
d2945 1
a2945 1
		if (p->hw_encoding != alts[i].encoding)
d2969 1
a2969 1
		      struct audio_params *p, int mode)
d2977 2
a2978 2
		 p->sample_rate, p->hw_channels, p->hw_precision));
	i = uaudio_match_alt_sub(nalts, alts, p, mode, p->sample_rate);
d2982 1
a2982 1
	uaudio_get_minmax_rates(nalts, alts, p, mode, &min, &max);
d2989 1
a2989 1
		i = uaudio_match_alt_sub(nalts, alts, p, mode, rate);
d2991 1
a2991 1
			p->hw_sample_rate = rate;
d2996 1
a2996 1
		i = uaudio_match_alt_sub(nalts, alts, p, mode, max);
d2998 1
a2998 1
			p->hw_sample_rate = max;
d3002 1
a3002 1
		i = uaudio_match_alt_sub(nalts, alts, p, mode, min);
d3004 1
a3004 1
			p->hw_sample_rate = min;
d3013 1
a3013 1
		 struct audio_params *p, int mode)
d3018 1
a3018 1
	i = uaudio_match_alt_chan(nalts, alts, p, mode);
d3023 2
a3024 2
		p->hw_channels = n;
		i = uaudio_match_alt_chan(nalts, alts, p, mode);
d3031 2
a3032 2
	p->hw_channels = 1;
	return uaudio_match_alt_chan(nalts, alts, p, mode);
d3042 1
a3042 1
	int enc, i;
d3074 1
d3080 1
a3080 1
			    && p->precision == 16 && (flags & HAS_16)) {
d3083 1
a3083 1
			} else if (p->precision == 8) {
d3091 1
a3091 1
					p->hw_precision = 16;
d3102 1
a3102 1
			if (p->precision == 16) {
d3110 1
a3110 1
			} else if (p->precision == 8) {
d3118 1
a3118 1
					p->hw_precision = 16;
d3137 1
a3137 1
				p->hw_precision = 16;
d3156 5
a3160 2
			if (mode == AUMODE_PLAY && (flags & HAS_16)) {
				swcode = alaw_to_slinear16_le;
d3163 1
a3163 1
				p->hw_precision = 16;
d3185 1
a3185 1
			 p->channels, p->hw_precision, enc, p->sample_rate));
d3187 1
a3187 2
		p->hw_encoding = enc;
		i = uaudio_match_alt(sc->sc_nalts, sc->sc_alts, p, mode);
@


1.50
log
@more M_ZERO conversions; ok krw@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.49 2007/09/08 17:34:54 ratchov Exp $ */
d1830 1
a1830 1
	iot = malloc(sizeof(struct io_terminal) * 256, M_TEMP, M_NOWAIT|M_ZERO);
@


1.49
log
@fix uaudio(4) devices using signed mixer controls

ok jakemsr@@, tested by jolan@@ with 3 different devices
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.48 2007/06/14 10:11:15 mbalmer Exp $ */
d1830 1
a1830 1
	iot = malloc(sizeof(struct io_terminal) * 256, M_TEMP, M_NOWAIT);
a1834 1
	bzero(iot, sizeof(struct io_terminal) * 256);
@


1.48
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.47 2007/06/13 10:10:30 mbalmer Exp $ */
a103 1
	u_int		mul;
d267 1
d607 1
a607 1
	int res;
d642 1
a642 1
		mc->maxval = 1 + uaudio_signext(mc->type,
d646 1
a646 3
		mc->mul = mc->maxval - mc->minval;
		if (mc->mul == 0)
			mc->mul = 1;
d650 2
a651 2
		if (res > 0)
			mc->delta = (res * 255 + mc->mul/2) / mc->mul;
a836 1
	mix.mul = mix.maxval - mix.minval;
d2298 12
d2312 1
d2320 8
a2327 3
	} else
		val = ((uaudio_signext(mc->type, val) - mc->minval) * 255
			+ mc->mul/2) / mc->mul;
d2343 2
a2344 1
		val = (val + mc->delta/2) * mc->mul / 255 + mc->minval;
@


1.47
log
@Remove the defintion and use of some byteswap macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.46 2007/06/13 06:25:03 mbalmer Exp $ */
d361 16
a376 1
USB_DECLARE_DRIVER(uaudio);
@


1.46
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.45 2007/06/12 16:26:36 mbalmer Exp $ */
d3070 1
a3070 1
					swcode = change_sign16_le;
d3072 1
a3072 1
					swcode = swap_bytes_change_sign16_le;
d3074 1
a3074 1
					swcode = change_sign16_swap_bytes_le;
d3087 1
a3087 1
						swcode = ulinear8_to_slinear16_le;
d3089 1
a3089 1
						swcode = slinear16_to_ulinear8_le;
@


1.45
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.44 2007/06/10 14:49:00 mbalmer Exp $ */
d159 1
a159 1
	struct device	sc_dev;		/* base device */
d161 1
a161 1
	int		sc_ac_iface;	/* Audio Control interface */
d163 4
a166 4
	struct chan	sc_playchan;	/* play channel */
	struct chan	sc_recchan;	/* record channel */
	int		sc_nullalt;
	int		sc_audio_rev;
d168 10
a177 10
	int		sc_nalts;	/* # of alternate settings */
	int		sc_altflags;
#define HAS_8		0x01
#define HAS_16		0x02
#define HAS_8U		0x04
#define HAS_ALAW	0x08
#define HAS_MULAW	0x10
#define UA_NOFRAC	0x20		/* don't do sample rate adjustment */
#define HAS_24		0x40
	int		sc_mode;	/* play/record capability */
d179 3
a181 3
	int		sc_nctls;	/* # of mixer controls */
	struct device *	sc_audiodev;
	char		sc_dying;
@


1.44
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.43 2007/06/10 10:53:48 mbalmer Exp $ */
d180 1
a180 1
	device_ptr_t	sc_audiodev;
d470 1
a470 1
uaudio_activate(device_ptr_t self, enum devact act)
d488 1
a488 1
uaudio_detach(device_ptr_t self, int flags)
@


1.43
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.42 2007/06/06 19:25:49 mk Exp $ */
d403 1
a403 1
		       USBDEVNAME(sc->sc_dev));
d410 1
a410 1
		       USBDEVNAME(sc->sc_dev), err);
d437 1
a437 1
			    USBDEVNAME(sc->sc_dev), j);
d442 1
a442 1
	printf("%s: audio rev %d.%02x", USBDEVNAME(sc->sc_dev),
d1537 1
a1537 1
		       USBDEVNAME(sc->sc_dev), UGETW(asid->wFormatTag));
d1568 1
a1568 1
		       USBDEVNAME(sc->sc_dev));
d1576 1
a1576 1
		       USBDEVNAME(sc->sc_dev));
d1592 1
a1592 1
		       USBDEVNAME(sc->sc_dev));
d1597 1
a1597 1
		       USBDEVNAME(sc->sc_dev));
d1618 1
a1618 1
			       USBDEVNAME(sc->sc_dev));
d1623 1
a1623 1
			       USBDEVNAME(sc->sc_dev), epdesc1->bmAttributes);
d1630 1
a1630 1
			       USBDEVNAME(sc->sc_dev), ed->bSynchAddress,
d1642 1
a1642 1
		       USBDEVNAME(sc->sc_dev), prec);
d1675 1
a1675 1
		       USBDEVNAME(sc->sc_dev), format);
d1679 1
a1679 1
	printf("%s: %s: %dch, %d/%dbit, %s,", USBDEVNAME(sc->sc_dev),
d1749 1
a1749 1
			       USBDEVNAME(sc->sc_dev), id->bNumEndpoints);
d1762 1
a1762 1
		       USBDEVNAME(sc->sc_dev));
@


1.42
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.41 2007/06/05 08:43:55 mbalmer Exp $ */
d455 1
a455 1
			   USBDEV(sc->sc_dev));
d500 1
a500 1
			   USBDEV(sc->sc_dev));
@


1.41
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.40 2007/06/04 10:34:04 mbalmer Exp $ */
d159 1
a159 1
	USBBASEDEVICE	sc_dev;		/* base device */
@


1.40
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.39 2007/05/27 04:00:25 jsg Exp $ */
d214 1
a214 1
Static const char *uac_names[] = {
d219 1
a219 1
Static usbd_status uaudio_identify_ac
d221 1
a221 1
Static usbd_status uaudio_identify_as
d223 1
a223 1
Static usbd_status uaudio_process_as
d227 1
a227 1
Static void	uaudio_add_alt(struct uaudio_softc *, const struct as_info *);
d229 1
a229 1
Static const usb_interface_descriptor_t *uaudio_find_iface
d232 2
a233 2
Static void	uaudio_mixer_add_ctl(struct uaudio_softc *, struct mixerctl *);
Static char	*uaudio_id_name
d235 1
a235 1
Static struct usb_audio_cluster uaudio_get_cluster
d237 1
a237 1
Static void	uaudio_add_input
d239 1
a239 1
Static void	uaudio_add_output
d241 1
a241 1
Static void	uaudio_add_mixer
d243 1
a243 1
Static void	uaudio_add_selector
d246 1
a246 1
Static const char *uaudio_get_terminal_name(int);
d248 1
a248 1
Static int	uaudio_determine_class
d250 1
a250 1
Static const char *uaudio_feature_name
d252 1
a252 1
Static void	uaudio_add_feature
d254 1
a254 1
Static void	uaudio_add_processing_updown
d256 1
a256 1
Static void	uaudio_add_processing
d258 1
a258 1
Static void	uaudio_add_extension
d260 1
a260 1
Static struct terminal_list *uaudio_merge_terminal_list
d262 1
a262 1
Static struct terminal_list *uaudio_io_terminaltype
d264 1
a264 1
Static usbd_status uaudio_identify
d267 5
a271 5
Static int	uaudio_signext(int, int);
Static int	uaudio_value2bsd(struct mixerctl *, int);
Static int	uaudio_bsd2value(struct mixerctl *, int);
Static int	uaudio_get(struct uaudio_softc *, int, int, int, int, int);
Static int	uaudio_ctl_get
d273 1
a273 1
Static void	uaudio_set
d275 1
a275 1
Static void	uaudio_ctl_set
d278 1
a278 1
Static usbd_status uaudio_set_speed(struct uaudio_softc *, int, u_int);
d280 3
a282 3
Static usbd_status uaudio_chan_open(struct uaudio_softc *, struct chan *);
Static void	uaudio_chan_close(struct uaudio_softc *, struct chan *);
Static usbd_status uaudio_chan_alloc_buffers
d284 2
a285 2
Static void	uaudio_chan_free_buffers(struct uaudio_softc *, struct chan *);
Static void	uaudio_chan_init
d287 3
a289 3
Static void	uaudio_chan_set_param(struct chan *, u_char *, u_char *, int);
Static void	uaudio_chan_ptransfer(struct chan *);
Static void	uaudio_chan_pintr
d292 2
a293 2
Static void	uaudio_chan_rtransfer(struct chan *);
Static void	uaudio_chan_rintr
d296 5
a300 5
Static int	uaudio_open(void *, int);
Static void	uaudio_close(void *);
Static int	uaudio_drain(void *);
Static int	uaudio_query_encoding(void *, struct audio_encoding *);
Static void	uaudio_get_minmax_rates
d303 1
a303 1
Static int	uaudio_match_alt_sub
d305 1
a305 1
Static int	uaudio_match_alt_chan
d307 1
a307 1
Static int	uaudio_match_alt
d309 1
a309 1
Static int	uaudio_set_params
d311 2
a312 2
Static int	uaudio_round_blocksize(void *, int);
Static int	uaudio_trigger_output
d315 1
a315 1
Static int	uaudio_trigger_input
d318 7
a324 7
Static int	uaudio_halt_in_dma(void *);
Static int	uaudio_halt_out_dma(void *);
Static int	uaudio_getdev(void *, struct audio_device *);
Static int	uaudio_mixer_set_port(void *, mixer_ctrl_t *);
Static int	uaudio_mixer_get_port(void *, mixer_ctrl_t *);
Static int	uaudio_query_devinfo(void *, mixer_devinfo_t *);
Static int	uaudio_get_props(void *);
d326 1
a326 1
Static struct audio_hw_if uaudio_hw_if = {
d355 1
a355 1
Static struct audio_device uaudio_device = {
d505 1
a505 1
Static int
d573 1
a573 1
Static const usb_interface_descriptor_t *
d589 1
a589 1
Static void
d657 1
a657 1
Static char *
d665 1
a665 1
Static struct usb_audio_cluster
d715 1
a715 1
Static void
d730 1
a730 1
Static void
d743 1
a743 1
Static void
d807 1
a807 1
Static void
d836 1
a836 1
Static const char *
d912 1
a912 1
Static int
d962 1
a962 1
Static const char *
d1063 1
a1063 1
Static void
d1176 1
a1176 1
Static void
d1213 1
a1213 1
Static void
d1255 1
a1255 1
Static void
d1282 1
a1282 1
Static struct terminal_list*
d1317 1
a1317 1
Static struct terminal_list *
d1468 1
a1468 1
Static usbd_status
d1479 1
a1479 1
Static void
d1502 1
a1502 1
Static usbd_status
d1713 1
a1713 1
Static usbd_status
d1769 1
a1769 1
Static usbd_status
d1983 1
a1983 1
Static int
d2067 1
a2067 1
Static int
d2087 1
a2087 1
Static void
d2098 1
a2098 1
Static int
d2108 1
a2108 1
Static int
d2123 1
a2123 1
Static int
d2138 1
a2138 1
Static int
d2154 1
a2154 1
Static int
d2189 1
a2189 1
Static int
d2196 1
a2196 1
Static int
d2236 1
a2236 1
Static void
d2273 1
a2273 1
Static int
d2285 1
a2285 1
Static int
d2318 1
a2318 1
Static int
d2330 1
a2330 1
Static void
d2339 1
a2339 1
Static int
d2384 1
a2384 1
Static int
d2425 1
a2425 1
Static int
d2467 1
a2467 1
Static int
d2510 1
a2510 1
Static usbd_status
d2551 1
a2551 1
Static void
d2572 1
a2572 1
Static usbd_status
d2603 1
a2603 1
Static void
d2613 1
a2613 1
Static void
d2678 1
a2678 1
Static void
d2717 1
a2717 1
Static void
d2762 1
a2762 1
Static void
d2820 1
a2820 1
Static void
d2841 1
a2841 1
Static void
d2853 1
a2853 1
Static void
d2895 1
a2895 1
Static int
d2934 1
a2934 1
Static int
d2978 1
a2978 1
Static int
d3002 1
a3002 1
Static int
d3191 1
a3191 1
Static usbd_status
@


1.39
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.38 2007/05/21 05:40:27 jsg Exp $ */
a352 3
#if defined(__NetBSD__)
	NULL,
#endif
d452 1
a452 6
#if defined(__NetBSD__) && !defined(UAUDIO_DEBUG)
	if (bootverbose)
#endif
		printf(", %d mixer controls", sc->sc_nctls);

	printf("\n");
a463 1
#if defined(__OpenBSD__)
a467 1
#endif
@


1.38
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.37 2006/06/23 06:27:11 miod Exp $ */
d366 2
a367 1
USB_MATCH(uaudio)
d369 1
a369 1
	USB_MATCH_START(uaudio, uaa);
d386 2
a387 1
USB_ATTACH(uaudio)
d389 2
a390 1
	USB_ATTACH_START(uaudio, sc, uaa);
d407 1
a407 1
		USB_ATTACH_ERROR_RETURN;
d414 1
a414 1
		USB_ATTACH_ERROR_RETURN;
d441 1
a441 1
			USB_ATTACH_ERROR_RETURN;
a466 2

	USB_ATTACH_SUCCESS_RETURN;
@


1.37
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.36 2006/05/04 15:25:10 mickey Exp $ */
d77 2
a78 2
#define DPRINTF(x)	do { if (uaudiodebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uaudiodebug>(n)) logprintf x; } while (0)
@


1.36
log
@free resources on close; found by Alexandre Ratchov <alex@@caoua.org>
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.35 2006/04/21 15:47:27 jolan Exp $ */
d486 1
a486 1
		return (EOPNOTSUPP);
@


1.35
log
@remove a couple of unreachable statements, one found by lint, one found
by my eyes
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.34 2006/01/06 11:34:08 fgsch Exp $ */
d2099 6
@


1.34
log
@from kent@@netbsd.org:
Call uaudio_set_speed() if and only if the selected Audio Streaming
interface supports multiple sampling rates.
fixed netbsd pr 27237.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.33 2006/01/06 11:13:40 fgsch Exp $ */
a486 2
		break;

a1069 1
	return AudioNmaster;
@


1.33
log
@from kent@@netbsd.org:
assign AudioNlfe to UATO_SUBWOOFER
assign "phone" to telephony terimnal types.  The label "phone" is used
in ac97 though it is not defined as AudioN* macro.
dlg@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.32 2006/01/02 04:05:50 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.87 2004/10/22 17:00:22 kent Exp $	*/
d2531 11
a2541 9
	/* Some devices do not support this request, so ignore errors. */
#ifdef UAUDIO_DEBUG
	err = uaudio_set_speed(sc, endpt, ch->sample_rate);
	if (err)
		DPRINTF(("uaudio_chan_open: set_speed failed err=%s\n",
			 usbd_errstr(err)));
#else
	(void)uaudio_set_speed(sc, endpt, ch->sample_rate);
#endif
@


1.32
log
@mostly style nits; from kent@@netbsd.org.
some other cosmetical changes to make future merges easier.  dlg@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.31 2006/01/02 03:52:29 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.86 2004/10/22 16:01:49 kent Exp $	*/
d853 2
d856 3
d865 2
d868 2
a872 19
	case UATO_HEADPHONES:	return "UATO_HEADPHONES";
	case UATE_ANALOGCONN:	return "UATE_ANALOGCONN";
	case UATE_LINECONN:	return "UATE_LINECONN";
	case UATE_LEGACYCONN:	return "UATE_LEGACYCONN";
	case UATE_DIGITALAUIFC:	return "UATE_DIGITALAUIFC";
	case UATE_SPDIF:	return "UATE_SPDIF";
	case UATE_1394DA:	return "UATE_1394DA";
	case UATE_1394DV:	return "UATE_1394DV";
	case UATF_CDPLAYER:	return "UATF_CDPLAYER";
	case UATF_SYNTHESIZER:	return "UATF_SYNTHESIZER";
	case UATF_VIDEODISCAUDIO:	return "UATF_VIDEODISCAUDIO";
	case UATF_DVDAUDIO:	return "UATF_DVDAUDIO";
	case UATF_TVTUNERAUDIO:	return "UATF_TVTUNERAUDIO";
	case UAT_UNDEFINED:	return "UAT_UNDEFINED";
	case UAT_VENDOR:	return "UAT_VENDOR";
	case UATI_UNDEFINED:	return "UATI_UNDEFINED";
/* output terminal types */
	case UATO_UNDEFINED:	return "UATO_UNDEFINED";
	case UATO_DISPLAYAUDIO:	return "UATO_DISPLAYAUDIO";
d874 1
a874 1
/* bidir terminal types */
d881 1
a881 1
/* telephony terminal types */
d886 1
a886 1
/* external terminal types */
d888 8
a895 1
/* embedded function terminal types */
d899 1
d906 3
d915 1
d1004 10
a1041 1
	case UATO_SUBWOOFER:
a1048 5
/* telephony terminal types */
	case UATT_UNDEFINED:
	case UATT_PHONELINE:
	case UATT_TELEPHONE:
	case UATT_DOWNLINEPHONE:
@


1.31
log
@fix some typos and add open/close code of sync pipe, disabled for now.
from kent@@netbsd.org. dlg@@ ok.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.30 2006/01/02 03:45:15 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.83 2004/10/22 15:25:56 kent Exp $	*/
d159 1
a159 1
	USBBASEDEVICE sc_dev;		/* base device */
d161 1
a161 2

	int	sc_ac_iface;	/* Audio Control interface */
d163 7
a169 12

	struct chan sc_playchan;	/* play channel */
	struct chan sc_recchan;		/* record channel */

	int	sc_nullalt;

	int	sc_audio_rev;

	struct as_info *sc_alts;
	int	sc_nalts;

	int	sc_altflags;
d177 5
a181 8

	int	sc_mode;		/* play/record capability */

	struct mixerctl *sc_ctls;
	int	sc_nctls;

	device_ptr_t sc_audiodev;
	char	sc_dying;
d219 7
a225 7
Static usbd_status uaudio_identify_ac(struct uaudio_softc *,
				      const usb_config_descriptor_t *);
Static usbd_status uaudio_identify_as(struct uaudio_softc *,
				      const usb_config_descriptor_t *);
Static usbd_status uaudio_process_as(struct uaudio_softc *,
				     const char *, int *, int,
				     const usb_interface_descriptor_t *);
d233 12
a244 12
Static char	*uaudio_id_name(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static struct usb_audio_cluster uaudio_get_cluster(int,
		    const struct io_terminal *);
Static void	uaudio_add_input(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_output(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_mixer(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_selector(struct uaudio_softc *,
		    const struct io_terminal *, int);
d248 18
a265 18
Static int	uaudio_determine_class(const struct io_terminal *,
		    struct mixerctl *);
Static const char *uaudio_feature_name(const struct io_terminal *,
		    struct mixerctl *);
Static void	uaudio_add_feature(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_processing_updown(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_processing(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static void	uaudio_add_extension(struct uaudio_softc *,
		    const struct io_terminal *, int);
Static struct terminal_list	*uaudio_merge_terminal_list
		    (const struct io_terminal *);
Static struct terminal_list	*uaudio_io_terminaltype(int,
		    struct io_terminal *, int);
Static usbd_status uaudio_identify(struct uaudio_softc *,
		    const usb_config_descriptor_t *);
d271 6
a276 6
Static int	uaudio_ctl_get(struct uaudio_softc *, int,
			       struct mixerctl *, int);
Static void	uaudio_set(struct uaudio_softc *, int,
			   int, int, int, int, int);
Static void	uaudio_ctl_set(struct uaudio_softc *, int,
			       struct mixerctl *, int, int);
d282 2
a283 2
Static usbd_status uaudio_chan_alloc_buffers(struct uaudio_softc *,
					     struct chan *);
d285 2
a286 2
Static void	uaudio_chan_init(struct chan *, int,
				 const struct audio_params *, int);
d289 2
a290 2
Static void	uaudio_chan_pintr(usbd_xfer_handle,
				  usbd_private_handle, usbd_status);
d293 2
a294 2
Static void	uaudio_chan_rintr(usbd_xfer_handle,
				  usbd_private_handle, usbd_status);
d300 11
a310 11
Static void	uaudio_get_minmax_rates(int, const struct as_info *,
					const struct audio_params *,
					int, u_long *, u_long *);
Static int	uaudio_match_alt_sub(int, const struct as_info *,
				     const struct audio_params *, int, u_long);
Static int	uaudio_match_alt_chan(int, const struct as_info *,
				      struct audio_params *, int);
Static int	uaudio_match_alt(int, const struct as_info *,
				 struct audio_params *, int);
Static int	uaudio_set_params(void *, int, int, struct audio_params *,
				  struct audio_params *);
d312 6
a317 4
Static int	uaudio_trigger_output(void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
Static int	uaudio_trigger_input (void *, void *, void *, int,
		    void (*)(void *), void *, struct audio_params *);
d516 1
a516 1
int
d584 1
a584 1
const usb_interface_descriptor_t *
d600 1
a600 1
void
d604 2
a605 2
	size_t len = sizeof(*mc) * (sc->sc_nctls + 1);
	struct mixerctl *nmc = malloc(len, M_USBDEV, M_NOWAIT);
d613 2
a618 1

d621 2
a622 2
	    bcopy(sc->sc_ctls, nmc, sizeof(*mc) * (sc->sc_nctls));
	    free(sc->sc_ctls, M_USBDEV);
a623 1

d668 1
a668 1
char *
d676 1
a676 1
struct usb_audio_cluster
d726 1
a726 1
void
d741 1
a741 1
void
d754 1
a754 1
void
d818 1
a818 1
void
d847 1
a847 1
const char *
d921 1
a921 1
int
d971 1
a971 1
const char *
d1069 1
a1069 1
void
d1182 1
a1182 1
void
d1219 1
a1219 1
void
d1261 1
a1261 1
void
d1288 1
a1288 1
struct terminal_list*
d1323 1
a1323 1
struct terminal_list *
d1474 1
a1474 1
usbd_status
d1485 1
a1485 1
void
d1488 2
a1489 2
	size_t len = sizeof(*ai) * (sc->sc_nalts + 1);
	struct as_info *nai = malloc(len, M_USBDEV, M_NOWAIT);
d1491 2
a1496 1

d1499 2
a1500 2
	    bcopy(sc->sc_alts, nai, sizeof(*ai) * (sc->sc_nalts));
	    free(sc->sc_alts, M_USBDEV);
a1501 1

d1508 1
a1508 1
usbd_status
d1719 1
a1719 1
usbd_status
d1775 1
a1775 1
usbd_status
d1989 1
a1989 1
int
d2073 1
a2073 1
int
d2093 1
a2093 1
void
d2098 1
a2098 1
int
d2108 1
a2108 1
int
d2123 1
a2123 1
int
d2138 1
a2138 1
int
d2154 1
a2154 1
int
d2189 1
a2189 1
int
d2196 1
a2196 1
int
d2236 1
a2236 1
void
d2273 1
a2273 1
int
d2285 1
a2285 1
int
d2318 1
a2318 1
int
d2330 1
a2330 1
void
d2339 1
a2339 1
int
d2384 1
a2384 1
int
d2425 1
a2425 1
int
d2467 1
a2467 1
int
d2510 1
a2510 1
usbd_status
d2549 1
a2549 1
void
d2570 1
a2570 1
usbd_status
d2601 1
a2601 1
void
d2611 1
a2611 1
void
d2676 1
a2676 1
void
d2715 1
a2715 1
void
d2760 1
a2760 1
void
d2818 1
a2818 1
void
d2839 1
a2839 1
void
d2851 1
a2851 1
void
d2893 1
a2893 1
int
d2932 1
a2932 1
int
d2976 1
a2976 1
int
d3000 1
a3000 1
int
d3189 1
a3189 1
usbd_status
@


1.30
log
@make mixer names compatible with other audio devices. from kent@@netbsd.org
via netbsd pr 15441 by Kazuhito Honda.  dlg@@ ok this and previous diffs.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.29 2006/01/02 01:24:18 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.82 2004/10/21 12:41:07 kent Exp $	*/
d129 1
d214 1
a214 1
	int direct;		/* direcly connected to an output terminal */
d954 1
a954 1
	 * If the ulitimate destination of the unit is just one output
d2542 2
d2546 8
a2553 1
	return (err);
d2567 8
a2574 2
	usbd_abort_pipe(ch->pipe);
	usbd_close_pipe(ch->pipe);
@


1.29
log
@recognize sync-pipe audio stream; disabled for now. from kent@@netbsd.org
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.28 2006/01/02 00:26:48 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.80 2004/10/16 18:08:50 kent Exp $	*/
d192 34
a225 4
#define UAC_OUTPUT 0
#define UAC_INPUT  1
#define UAC_EQUAL  2
#define UAC_NCLASSES 3
a235 2
Static void	uaudio_mixer_alias_ctl(struct uaudio_softc *,
				       struct mixerctl *, const char *);
d242 1
a242 1
		    const usb_descriptor_t **, int);
d244 1
a244 1
		    const usb_descriptor_t **);
d246 1
a246 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d248 1
a248 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d250 1
a250 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d252 8
a259 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d261 1
a261 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d263 1
a263 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d265 1
a265 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d267 5
a271 1
		    const usb_descriptor_t *, const usb_descriptor_t **);
d613 6
a673 9
void
uaudio_mixer_alias_ctl(struct uaudio_softc *sc, struct mixerctl *mc,
		     const char *name)
{
	/* XXX mark as alias? */
	strlcpy(mc->ctlname, name, sizeof(mc->ctlname));
	uaudio_mixer_add_ctl(sc, mc);
}

d675 1
a675 1
uaudio_id_name(struct uaudio_softc *sc, const usb_descriptor_t **dps, int id)
d683 1
a683 1
uaudio_get_cluster(int id, const usb_descriptor_t **dps)
d690 1
a690 1
		dp = dps[id];
d695 3
a697 5
#define p ((const struct usb_audio_input_terminal *)dp)
			r.bNrChannels = p->bNrChannels;
			USETW(r.wChannelConfig, UGETW(p->wChannelConfig));
			r.iChannelNames = p->iChannelNames;
#undef p
d700 1
a700 3
#define p ((const struct usb_audio_output_terminal *)dp)
			id = p->bSourceId;
#undef p
a702 1
#define p ((const struct usb_audio_mixer_unit *)dp)
d704 1
a704 2
				&p->baSourceId[p->bNrInPins];
#undef p
d708 1
a708 3
#define p ((const struct usb_audio_selector_unit *)dp)
			id = p->baSourceId[0];
#undef p
d711 1
a711 3
#define p ((const struct usb_audio_feature_unit *)dp)
			id = p->bSourceId;
#undef p
a713 1
#define p ((const struct usb_audio_processing_unit *)dp)
d715 1
a715 2
				&p->baSourceId[p->bNrInPins];
#undef p
a717 1
#define p ((const struct usb_audio_extension_unit *)dp)
d719 1
a719 2
				&p->baSourceId[p->bNrInPins];
#undef p
d733 1
a733 2
uaudio_add_input(struct uaudio_softc *sc, const usb_descriptor_t *v,
		 const usb_descriptor_t **dps)
d736 1
a736 2
	const struct usb_audio_input_terminal *d =
		(const struct usb_audio_input_terminal *)v;
d748 1
a748 2
uaudio_add_output(struct uaudio_softc *sc, const usb_descriptor_t *v,
		  const usb_descriptor_t **dps)
d751 1
a751 2
	const struct usb_audio_output_terminal *d =
		(const struct usb_audio_output_terminal *)v;
d761 1
a761 2
uaudio_add_mixer(struct uaudio_softc *sc, const usb_descriptor_t *v,
		 const usb_descriptor_t **dps)
d763 1
a763 1
	const struct usb_audio_mixer_unit *d = (const struct usb_audio_mixer_unit *)v;
d775 1
a775 1
		ichs += uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;
d784 1
a784 1
	mix.class = -1;
d789 1
a789 1
		chs = uaudio_get_cluster(d->baSourceId[i], dps).bNrChannels;
d811 1
a811 1
			    d->bUnitId, uaudio_id_name(sc, dps,
d825 1
a825 2
uaudio_add_selector(struct uaudio_softc *sc, const usb_descriptor_t *v,
		    const usb_descriptor_t **dps)
d827 1
a827 2
	const struct usb_audio_selector_unit *d =
		(const struct usb_audio_selector_unit *)v;
d835 1
a835 1
	mix.class = UAC_OUTPUT;
d842 1
a842 1
	wp = snprintf(mix.ctlname, MAX_AUDIO_DEV_LEN, "fea%d-", d->bUnitId);
d852 223
d1076 1
a1076 2
uaudio_add_feature(struct uaudio_softc *sc, const usb_descriptor_t *v,
		   const usb_descriptor_t **dps)
d1078 1
a1078 2
	const struct usb_audio_feature_unit *d
		= (const struct usb_audio_feature_unit *)v;
a1081 1
	int srcId = d->bSourceId;
d1085 1
d1098 1
a1098 1
	DPRINTFN(1,("uaudio_add_feature: bUnitId=%d bSourceId=%d, "
d1100 1
a1100 1
		    d->bUnitId, srcId, nchan, mmask, cmask));
d1125 1
a1125 1
		mix.class = UAC_OUTPUT;	/* XXX we don't really know this */
a1129 1
			uaudio_mixer_alias_ctl(sc, &mix, AudioNmute);
d1131 1
a1131 2
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNmute);
d1136 1
a1136 4
			uaudio_mixer_alias_ctl(sc, &mix, AudioNmaster);
			snprintf(mix.ctlname, sizeof(mix.ctlname),
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNmaster);
a1140 1
			uaudio_mixer_alias_ctl(sc, &mix, AudioNbass);
d1142 1
a1142 2
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNbass);
d1148 1
a1148 2
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNmid);
a1152 1
			uaudio_mixer_alias_ctl(sc, &mix, AudioNtreble);
d1154 1
a1154 2
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNtreble);
a1160 3
			snprintf(mix.ctlname, sizeof(mix.ctlname),
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNagc);
d1162 2
d1167 1
d1169 1
a1169 3
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNdelay);
			mix.ctlunit = "4 ms";
d1173 1
d1175 1
a1175 3
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNbassboost);
			mix.ctlunit = "";
d1179 1
d1181 1
a1181 3
			    "fea%d-%s-%s", unit, uaudio_id_name(sc, dps, srcId),
			    AudioNloudness);
			mix.ctlunit = "";
d1190 1
a1190 2
			     const usb_descriptor_t *v,
			     const usb_descriptor_t **dps)
d1192 1
a1192 2
	const struct usb_audio_processing_unit *d =
	    (const struct usb_audio_processing_unit *)v;
d1212 1
a1212 1
	mix.class = -1;
d1226 1
a1226 2
uaudio_add_processing(struct uaudio_softc *sc, const usb_descriptor_t *v,
		      const usb_descriptor_t **dps)
d1228 1
a1228 2
	const struct usb_audio_processing_unit *d =
	    (const struct usb_audio_processing_unit *)v;
d1241 1
a1241 1
		mix.class = -1;
d1251 1
a1251 1
		uaudio_add_processing_updown(sc, v, dps);
d1268 1
a1268 2
uaudio_add_extension(struct uaudio_softc *sc, const usb_descriptor_t *v,
		     const usb_descriptor_t **dps)
d1270 1
a1270 2
	const struct usb_audio_extension_unit *d =
	    (const struct usb_audio_extension_unit *)v;
d1285 1
a1285 1
		mix.class = -1;
d1294 186
d1784 1
d1787 3
a1789 1
	const usb_descriptor_t *dp, *dps[256];
d1791 1
a1791 1
	int size, offs, aclen, ndps, i;
d1804 1
a1804 1
	DPRINTFN(2,("uaudio_identify: AC interface is %d\n", sc->sc_ac_iface));
d1821 1
a1821 1
	DPRINTFN(2,("uaudio_identify: found AC header, vers=%03x, len=%d\n",
d1828 1
a1828 1
	dp = (usb_descriptor_t *)ibuf;
d1830 6
a1835 1
	memset(dps, 0, sizeof dps);
d1840 3
a1842 2
		dp = (usb_descriptor_t *)ibuf;
		if (ibuf + dp->bLength > ibufend)
d1844 1
d1846 1
a1846 1
			printf("uaudio_identify: skip desc type=0x%02x\n",
d1850 2
a1851 2
		i = ((struct usb_audio_input_terminal *)dp)->bTerminalId;
		dps[i] = dp;
d1857 1
d1859 1
a1859 1
		dp = dps[i];
d1862 81
a1942 2
		DPRINTF(("uaudio_identify: subtype=%d\n",
			 dp->bDescriptorSubtype));
d1945 1
a1945 1
			printf("uaudio_identify: unexpected AC header\n");
d1948 1
a1948 1
			uaudio_add_input(sc, dp, dps);
d1951 1
a1951 1
			uaudio_add_output(sc, dp, dps);
d1954 1
a1954 1
			uaudio_add_mixer(sc, dp, dps);
d1957 1
a1957 1
			uaudio_add_selector(sc, dp, dps);
d1960 1
a1960 1
			uaudio_add_feature(sc, dp, dps);
d1963 1
a1963 1
			uaudio_add_processing(sc, dp, dps);
d1966 1
a1966 1
			uaudio_add_extension(sc, dp, dps);
d1969 1
a1969 1
			printf("uaudio_identify: bad AC desc subtype=0x%02x\n",
d1974 18
d2029 6
@


1.28
log
@add source selector support. netbsd pr 26538.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.27 2006/01/02 00:07:13 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.79 2004/10/03 06:01:09 kent Exp $	*/
d74 2
d120 1
d1120 1
d1123 1
a1123 1
	int dir, type;
d1154 1
a1154 1
	DPRINTF(("uaudio_process_as: endpoint bLength=%d bDescriptorType=%d "
d1173 1
d1175 2
d1180 1
d1183 2
d1188 1
d1195 1
d1200 47
d1282 1
d1307 1
d1342 2
a1343 2
		DPRINTFN(2, ("uaudio_identify: interface %d\n",
		    id->bInterfaceNumber));
d1351 3
d2390 1
a2390 1
			DPRINTFN(2,("uaudio_match_alt_sub: cont %d-%d\n",
d2396 1
a2396 1
				DPRINTFN(2,("uaudio_match_alt_sub: disc #%d: %d\n",
@


1.27
log
@knf. add some debug and use const.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.26 2006/01/01 22:55:39 fgsch Exp $ */
/*	$NetBSD: uaudio.c,v 1.67 2003/05/03 18:11:41 wiz Exp $	*/
d97 1
d585 6
a590 1
	if (mc->type != MIX_ON_OFF) {
a607 3
	} else {
		mc->minval = 0;
		mc->maxval = 1;
a807 1
#ifdef UAUDIO_DEBUG
d810 2
d815 17
a831 2
#endif
	printf("uaudio_add_selector: NOT IMPLEMENTED\n");
d1426 1
a1426 1
	int n, nctls;
d1478 10
d1716 1
a1716 1
	if (mc->type == MIX_ON_OFF)
d1718 4
a1721 1
	else
d1733 1
a1733 1
	if (mc->type == MIX_ON_OFF)
d1735 4
a1738 1
	else
d1786 4
d1827 4
@


1.26
log
@correct a typo and reorder check.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.25 2006/01/01 22:49:25 fgsch Exp $ */
d115 3
a117 3
	usb_interface_descriptor_t *idesc;
	usb_endpoint_descriptor_audio_t *edesc;
	struct usb_audio_streaming_type1_descriptor *asf1desc;
d193 95
a287 105
Static usbd_status	uaudio_identify_ac(struct uaudio_softc *sc,
					   usb_config_descriptor_t *cdesc);
Static usbd_status	uaudio_identify_as(struct uaudio_softc *sc,
					   usb_config_descriptor_t *cdesc);
Static usbd_status	uaudio_process_as(struct uaudio_softc *sc,
			    char *buf, int *offsp, int size,
			    usb_interface_descriptor_t *id);

Static void		uaudio_add_alt(struct uaudio_softc *sc,
				       struct as_info *ai);
Static void		uaudio_mixer_alias_ctl(struct uaudio_softc *sc,
			     struct mixerctl *mp, const char *ctl);

Static usb_interface_descriptor_t *uaudio_find_iface(char *buf,
			    int size, int *offsp, int subtype);

Static void		uaudio_mixer_add_ctl(struct uaudio_softc *sc,
					     struct mixerctl *mp);
Static char		*uaudio_id_name(struct uaudio_softc *sc,
					usb_descriptor_t **dps, int id);
Static struct usb_audio_cluster uaudio_get_cluster(int id,
						   usb_descriptor_t **dps);
Static void		uaudio_add_input(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_output(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_mixer(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_selector(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_feature(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_processing_updown(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_processing(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_extension(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static usbd_status	uaudio_identify(struct uaudio_softc *sc,
			    usb_config_descriptor_t *cdesc);

Static int		uaudio_signext(int type, int val);
Static int		uaudio_value2bsd(struct mixerctl *mc, int val);
Static int		uaudio_bsd2value(struct mixerctl *mc, int val);
Static int		uaudio_get(struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int len);
Static int		uaudio_ctl_get(struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan);
Static void		uaudio_set(struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int l, int v);
Static void		uaudio_ctl_set(struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan, int val);

Static usbd_status	uaudio_set_speed(struct uaudio_softc *, int, u_int);

Static usbd_status	uaudio_chan_open(struct uaudio_softc *sc,
					 struct chan *ch);
Static void		uaudio_chan_close(struct uaudio_softc *sc,
					  struct chan *ch);
Static usbd_status	uaudio_chan_alloc_buffers(struct uaudio_softc *,
						  struct chan *);
Static void		uaudio_chan_free_buffers(struct uaudio_softc *,
						 struct chan *);
Static void		uaudio_chan_init(struct chan *, int,
					 const struct audio_params *, int);
Static void		uaudio_chan_set_param(struct chan *ch, u_char *start,
			    u_char *end, int blksize);
Static void		uaudio_chan_ptransfer(struct chan *ch);
Static void		uaudio_chan_pintr(usbd_xfer_handle xfer,
			    usbd_private_handle priv, usbd_status status);

Static void		uaudio_chan_rtransfer(struct chan *ch);
Static void		uaudio_chan_rintr(usbd_xfer_handle xfer,
			    usbd_private_handle priv, usbd_status status);

Static int		uaudio_open(void *, int);
Static void		uaudio_close(void *);
Static int		uaudio_drain(void *);
Static int		uaudio_query_encoding(void *, struct audio_encoding *);
Static void		uaudio_get_minmax_rates(int, const struct as_info *,
						const struct audio_params *,
						int, u_long *, u_long *);
Static int		uaudio_match_alt_sub(int, const struct as_info *,
					     const struct audio_params *,
					     int, u_long);
Static int		uaudio_match_alt_chan(int, const struct as_info *,
					      struct audio_params *, int);
Static int		uaudio_match_alt(int, const struct as_info *,
					 struct audio_params *, int);
Static int		uaudio_set_params(void *, int, int,
			    struct audio_params *, struct audio_params *);
Static int		uaudio_round_blocksize(void *, int);
Static int		uaudio_trigger_output(void *, void *, void *,
					      int, void (*)(void *), void *,
					      struct audio_params *);
Static int		uaudio_trigger_input (void *, void *, void *,
					      int, void (*)(void *), void *,
					      struct audio_params *);
Static int		uaudio_halt_in_dma(void *);
Static int		uaudio_halt_out_dma(void *);
Static int		uaudio_getdev(void *, struct audio_device *);
Static int		uaudio_mixer_set_port(void *, mixer_ctrl_t *);
Static int		uaudio_mixer_get_port(void *, mixer_ctrl_t *);
Static int		uaudio_query_devinfo(void *, mixer_devinfo_t *);
Static int		uaudio_get_props(void *);
d495 1
a495 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d501 1
a501 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d507 1
a507 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d513 1
a513 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d519 1
a519 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d525 1
a525 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d531 1
a531 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d537 1
a537 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d547 2
a548 2
usb_interface_descriptor_t *
uaudio_find_iface(char *buf, int size, int *offsp, int subtype)
d550 1
a550 1
	usb_interface_descriptor_t *d;
d553 1
a553 1
		d = (void *)(buf + *offsp);
d628 1
a628 1
	strlcpy(mc->ctlname, name, sizeof mc->ctlname);
d633 1
a633 1
uaudio_id_name(struct uaudio_softc *sc, usb_descriptor_t **dps, int id)
d636 1
a636 1
	snprintf(buf, sizeof buf, "i%d", id);
d641 1
a641 1
uaudio_get_cluster(int id, usb_descriptor_t **dps)
d644 1
a644 1
	usb_descriptor_t *dp;
d653 1
a653 1
#define p ((struct usb_audio_input_terminal *)dp)
d660 1
a660 1
#define p ((struct usb_audio_output_terminal *)dp)
d665 1
a665 1
#define p ((struct usb_audio_mixer_unit *)dp)
d672 1
a672 1
#define p ((struct usb_audio_selector_unit *)dp)
d677 1
a677 1
#define p ((struct usb_audio_feature_unit *)dp)
d682 1
a682 1
#define p ((struct usb_audio_processing_unit *)dp)
d688 1
a688 1
#define p ((struct usb_audio_extension_unit *)dp)
d705 2
a706 2
uaudio_add_input(struct uaudio_softc *sc, usb_descriptor_t *v,
		 usb_descriptor_t **dps)
d709 2
a710 2
	struct usb_audio_input_terminal *d =
		(struct usb_audio_input_terminal *)v;
d722 2
a723 2
uaudio_add_output(struct uaudio_softc *sc, usb_descriptor_t *v,
		  usb_descriptor_t **dps)
d726 2
a727 2
	struct usb_audio_output_terminal *d =
		(struct usb_audio_output_terminal *)v;
d737 2
a738 2
uaudio_add_mixer(struct uaudio_softc *sc, usb_descriptor_t *v,
		 usb_descriptor_t **dps)
d740 1
a740 1
	struct usb_audio_mixer_unit *d = (struct usb_audio_mixer_unit *)v;
d787 3
a789 3
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"mix%d-%s", d->bUnitId,
				uaudio_id_name(sc, dps, d->baSourceId[i]));
d802 2
a803 2
uaudio_add_selector(struct uaudio_softc *sc, usb_descriptor_t *v,
		    usb_descriptor_t **dps)
d806 2
a807 2
	struct usb_audio_selector_unit *d =
		(struct usb_audio_selector_unit *)v;
d816 2
a817 2
uaudio_add_feature(struct uaudio_softc *sc, usb_descriptor_t *v,
		   usb_descriptor_t **dps)
d819 2
a820 1
	struct usb_audio_feature_unit *d = (struct usb_audio_feature_unit *)v;
d873 3
a875 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNmute);
d881 3
a883 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNmaster);
d889 3
a891 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNbass);
d896 3
a898 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNmid);
d904 3
a906 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNtreble);
d913 3
a915 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNagc);
d920 3
a922 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNdelay);
d927 3
a929 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNbassboost);
d934 3
a936 4
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
				uaudio_id_name(sc, dps, srcId),
				AudioNloudness);
d945 10
a954 9
uaudio_add_processing_updown(struct uaudio_softc *sc, usb_descriptor_t *v,
			     usb_descriptor_t **dps)
{
	struct usb_audio_processing_unit *d =
	    (struct usb_audio_processing_unit *)v;
	struct usb_audio_processing_unit_1 *d1 =
	    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
	struct usb_audio_processing_unit_updown *ud =
	    (struct usb_audio_processing_unit_updown *)
d973 1
a973 2
	snprintf(mix.ctlname, sizeof mix.ctlname,
		"pro%d-mode", d->bUnitId);
d984 2
a985 2
uaudio_add_processing(struct uaudio_softc *sc, usb_descriptor_t *v,
		      usb_descriptor_t **dps)
d987 4
a990 4
	struct usb_audio_processing_unit *d =
	    (struct usb_audio_processing_unit *)v;
	struct usb_audio_processing_unit_1 *d1 =
	    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
d1004 2
a1005 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"pro%d.%d-enable", d->bUnitId, ptype);
d1028 2
a1029 2
uaudio_add_extension(struct uaudio_softc *sc, usb_descriptor_t *v,
		     usb_descriptor_t **dps)
d1031 4
a1034 4
	struct usb_audio_extension_unit *d =
	    (struct usb_audio_extension_unit *)v;
	struct usb_audio_extension_unit_1 *d1 =
	    (struct usb_audio_extension_unit_1 *)&d->baSourceId[d->bNrInPins];
d1050 2
a1051 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"ext%d-enable", d->bUnitId);
d1057 1
a1057 1
uaudio_identify(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d1068 1
a1068 1
uaudio_add_alt(struct uaudio_softc *sc, struct as_info *ai)
d1091 2
a1092 2
uaudio_process_as(struct uaudio_softc *sc, char *buf, int *offsp,
		  int size, usb_interface_descriptor_t *id)
d1095 4
a1098 4
	struct usb_audio_streaming_interface_descriptor *asid;
	struct usb_audio_streaming_type1_descriptor *asf1d;
	usb_endpoint_descriptor_audio_t *ed;
	struct usb_audio_streaming_endpoint_descriptor *sed;
d1102 1
d1104 1
a1104 1
	asid = (void *)(buf + offs);
d1108 2
d1113 2
a1114 1
	asf1d = (void *)(buf + offs);
d1128 1
a1128 1
	ed = (void *)(buf + offs);
d1150 8
a1157 5
	if (dir == UE_DIR_IN ? type == UE_ISO_ADAPT : type == UE_ISO_ASYNC) {
		printf("%s: ignored %sput endpoint of type %s\n",
		       USBDEVNAME(sc->sc_dev),
		       dir == UE_DIR_IN ? "in" : "out",
		       dir == UE_DIR_IN ? "adaptive" : "async");
d1161 1
a1161 1
	sed = (void *)(buf + offs);
d1187 1
d1192 1
d1197 1
d1202 1
d1209 14
a1222 2
	DPRINTFN(1, ("uaudio_process_as: alt=%d enc=%d chan=%d prec=%d\n",
		     id->bAlternateSetting, enc, chan, prec));
d1232 4
a1235 16
	{
		int j;
		if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(1, ("uaudio_process_as:  rate=%d-%d\n",
				     UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d)));
		} else {
			DPRINTFN(1, ("uaudio_process_as: "));
			for (j = 0; j < asf1d->bSamFreqType; j++)
				DPRINTFN(1, (" %d", UA_GETSAMP(asf1d, j)));
			DPRINTFN(1, ("\n"));
		}
		if (ai.attributes & UA_SED_FREQ_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  FREQ_CONTROL\n"));
		if (ai.attributes & UA_SED_PITCH_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  PITCH_CONTROL\n"));
	}
d1244 2
a1245 1
uaudio_identify_as(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d1247 2
a1248 2
	usb_interface_descriptor_t *id;
	char *buf;
d1252 1
a1252 1
	buf = (char *)cdesc;
a1273 1
#ifdef UAUDIO_DEBUG
a1276 1
#endif
d1297 1
a1297 1
uaudio_identify_ac(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d1299 4
a1302 4
	usb_interface_descriptor_t *id;
	struct usb_audio_control_descriptor *acdp;
	usb_descriptor_t *dp, *dps[256];
	char *buf, *ibuf, *ibufend;
d1320 1
a1320 1
	acdp = (struct usb_audio_control_descriptor *)ibuf;
d1421 1
a1421 1
		strlcpy(mi->label.name, AudioCoutputs, sizeof mi->label.name);
d1427 1
a1427 1
		strlcpy(mi->label.name, AudioCinputs, sizeof mi->label.name);
d1434 1
a1434 1
		    sizeof mi->label.name);
d1445 1
a1445 1
	strlcpy(mi->label.name, mc->ctlname, sizeof mi->label.name);
d1453 1
a1453 1
		    sizeof mi->un.e.member[0].label.name);
d1456 1
a1456 1
		    sizeof mi->un.e.member[1].label.name);
d1462 1
a1462 1
		    sizeof mi->un.v.units.name);
d1590 1
d2224 1
a2225 1
	struct usb_audio_streaming_type1_descriptor *a1d;
d2265 1
a2266 1
	struct usb_audio_streaming_type1_descriptor *a1d;
@


1.25
log
@Rearrange to fix a potential crash when changing parameters with audioctl
and the device is closed.  netbsd pr 24066.
Some cleanup and also correctly set the mode via audioctl.  from mycroft.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.24 2006/01/01 22:13:52 fgsch Exp $ */
d1489 1
a1489 1
	if ((flags & FREAD) && !(sc->sc_mode | AUMODE_RECORD))
d2391 2
a2392 2
	if (((usemode & AUMODE_RECORD) && sc->sc_recchan.pipe != NULL) ||
	    ((usemode & AUMODE_PLAY) && sc->sc_playchan.pipe != NULL))
@


1.24
log
@Fix mixer wraparound. from netbsd pr 16652.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.23 2005/11/21 18:16:43 millert Exp $ */
d1097 1
a1097 1
	if (sc->sc_nalts != 0) { 
d1295 1
a1295 1
	if ((sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD)) == 0) {
d1487 4
a1490 14
	if (sc->sc_mode == 0)
		return (ENXIO);

	if (flags & FREAD) {
		if ((sc->sc_mode & AUMODE_RECORD) == 0)
			return (EACCES);
		sc->sc_recchan.intr = NULL;
	}

	if (flags & FWRITE) {
		if ((sc->sc_mode & AUMODE_PLAY) == 0)
			return (EACCES);
		sc->sc_playchan.intr = NULL;
	}
a1500 7
	struct uaudio_softc *sc = addr;

	DPRINTF(("uaudio_close: sc=%p\n", sc));
	uaudio_halt_in_dma(sc);
	uaudio_halt_out_dma(sc);

	sc->sc_playchan.intr = sc->sc_recchan.intr = NULL;
d1523 1
d1538 1
d2391 2
a2392 2
	if ((usemode == AUMODE_RECORD && sc->sc_recchan.pipe != NULL)
	    || (usemode == AUMODE_PLAY && sc->sc_playchan.pipe != NULL))
d2395 1
a2395 1
	if (usemode & AUMODE_PLAY && sc->sc_playchan.altidx != -1)
d2397 1
a2397 1
	if (usemode & AUMODE_RECORD && sc->sc_recchan.altidx != -1)
d2400 4
a2408 3
		if ((sc->sc_mode & mode) == 0)
			continue;

d2530 5
a2534 9
		if (usemode & mode) {
			if (mode == AUMODE_PLAY) {
				paltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			} else {
				raltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			}
		}
d2537 1
a2537 1
	if ((usemode & AUMODE_PLAY) /*&& paltidx != sc->sc_playchan.altidx*/) {
d2541 1
a2541 1
	if ((usemode & AUMODE_RECORD) /*&& raltidx != sc->sc_recchan.altidx*/) {
d2546 5
@


1.23
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.22 2005/08/01 05:36:48 brad Exp $ */
d611 1
a611 1
			mc->delta = (res * 256 + mc->mul/2) / mc->mul;
d1712 1
a1712 1
		val = ((uaudio_signext(mc->type, val) - mc->minval) * 256
d1726 1
a1726 1
		val = (val + mc->delta/2) * mc->mul / 256 + mc->minval;
@


1.22
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.21 2004/10/18 11:26:52 deraadt Exp $ */
d56 1
a56 1
#include <sys/select.h>
@


1.21
log
@reduce linecount in dmesg
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.20 2004/08/30 03:06:48 drahn Exp $ */
d363 1
a363 1
	char devinfo[1024];
d367 3
a369 2
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
	printf(": %s\n", devinfo);
@


1.20
log
@Remove 'usb_'realloc() usage because it doesn't know the size of the old
buffer, thus may copy too much, causing a memory fault.
ok millert, dlg, henning, tdeval, otto
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.19 2004/07/08 22:18:44 deraadt Exp $ */
d414 1
a414 1
	printf("%s: audio rev %d.%02x\n", USBDEVNAME(sc->sc_dev),
d427 3
a429 2
		printf("%s: %d mixer controls\n", USBDEVNAME(sc->sc_dev),
		    sc->sc_nctls);
@


1.19
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.18 2003/11/07 11:10:47 jmc Exp $ */
d576 1
a576 3
	struct mixerctl *nmc = sc->sc_nctls == 0 ?
	    malloc(len, M_USBDEV, M_NOWAIT) :
	    realloc(sc->sc_ctls, len, M_USBDEV, M_NOWAIT);
d582 7
d1087 1
a1087 3
	struct as_info *nai = (sc->sc_nalts == 0) ?
	    malloc(len, M_USBDEV, M_NOWAIT) :
	    realloc(sc->sc_alts, len, M_USBDEV, M_NOWAIT);
d1092 6
@


1.18
log
@updated URLs from Jared Yanovich;

however, I did not apply the diff exactly. After hunting around I
found URLs for the missing files, and the ../index.html link appears
not to work. I replaced it with a more suitable link.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.17 2003/05/19 18:38:42 miod Exp $ */
d75 2
a76 2
#define DPRINTF(x)	if (uaudiodebug) logprintf x
#define DPRINTFN(n,x)	if (uaudiodebug>(n)) logprintf x
@


1.17
log
@strlcpy; millert@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.16 2003/05/19 05:27:00 nate Exp $ */
d42 3
a44 3
 * USB audio specs: http://www.usb.org/developers/data/devclass/audio10.pdf
 *                  http://www.usb.org/developers/data/devclass/frmts10.pdf
 *                  http://www.usb.org/developers/data/devclass/termt10.pdf
@


1.16
log
@updates from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.15 2003/05/07 04:33:33 deraadt Exp $ */
d631 1
a631 1
	strcpy(mc->ctlname, name);
d1418 1
a1418 1
		strcpy(mi->label.name, AudioCoutputs);
d1424 1
a1424 1
		strcpy(mi->label.name, AudioCinputs);
d1430 2
a1431 1
		strcpy(mi->label.name, AudioCequalization);
@


1.15
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.14 2003/04/27 11:22:54 ho Exp $ */
/*	$NetBSD: uaudio.c,v 1.60 2002/05/18 15:14:39 kent Exp $	*/
d122 1
a122 1
	void	(*intr)(void *);	/* dma completion intr handler */
d146 1
d191 1
d203 2
d257 1
a257 1
					 const struct audio_params *);
d418 2
d439 10
d626 9
d869 1
a869 1
		mix.class = -1;	/* XXX */
d873 2
a878 1
			mix.ctlunit = "";
d882 2
a887 1
			mix.ctlunit = AudioNvolume;
d891 2
a896 1
			mix.ctlunit = AudioNbass;
d900 1
a904 1
			mix.ctlunit = AudioNmid;
d908 2
a913 1
			mix.ctlunit = AudioNtreble;
a1242 1
	usbd_status err;
d1266 1
a1266 1
			err = uaudio_process_as(sc, buf, &offs, size, id);
d1413 21
a1433 26
	if (n < 0 || n >= nctls) {
		switch (n - nctls) {
		case UAC_OUTPUT:
			mi->type = AUDIO_MIXER_CLASS;
			mi->mixer_class = nctls + UAC_OUTPUT;
			mi->next = mi->prev = AUDIO_MIXER_LAST;
			strlcpy(mi->label.name, AudioCoutputs,
			    sizeof mi->label.name);
			return (0);
		case UAC_INPUT:
			mi->type = AUDIO_MIXER_CLASS;
			mi->mixer_class = nctls + UAC_INPUT;
			mi->next = mi->prev = AUDIO_MIXER_LAST;
			strlcpy(mi->label.name, AudioCinputs,
			    sizeof mi->label.name);
			return (0);
		case UAC_EQUAL:
			mi->type = AUDIO_MIXER_CLASS;
			mi->mixer_class = nctls + UAC_EQUAL;
			mi->next = mi->prev = AUDIO_MIXER_LAST;
			strlcpy(mi->label.name, AudioCequalization,
			    sizeof mi->label.name);
			return (0);
		default:
			return (ENXIO);
		}
d1435 5
d1752 1
a1752 1
	n = cp->dev;
d1792 1
a1792 1
	n = cp->dev;
a2111 6
		residue += ch->fraction;
		if (residue >= USB_FRAMES_PER_SECOND) {
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
				size += ch->sample_size;
			residue -= USB_FRAMES_PER_SECOND;
		}
d2113 1
d2145 1
a2145 1
	int s, n;
d2155 1
a2155 7
	if (count < cb->size) {
		/* if the device fails to keep up, copy last byte */
		u_char b = count ? cb->buffer[count-1] : 0;
		while (count < cb->size)
			cb->buffer[count++] = b;
	}

d2157 2
a2158 2
	if (count != cb->size) {
		printf("uaudio_chan_rintr: count(%d) != size(%d)\n",
d2167 12
a2178 8
	n = min(count, ch->end - ch->cur);
	memcpy(ch->cur, cb->buffer, n);
	ch->cur += n;
	if (ch->cur >= ch->end)
		ch->cur = ch->start;
	if (count > n) {
		memcpy(ch->cur, cb->buffer + n, count - n);
		ch->cur += count - n;
d2182 1
a2182 1
	ch->transferred += cb->size;
d2197 2
a2198 1
uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param)
d2203 2
a2204 3
	sample_size = param->precision * param->factor * param->channels / 8;
	samples_per_frame = param->sample_rate / USB_FRAMES_PER_SECOND;
	ch->fraction = param->sample_rate % USB_FRAMES_PER_SECOND;
d2206 8
a2213 2
	ch->sample_rate = param->sample_rate;
	ch->bytes_per_frame = samples_per_frame * sample_size;
d2243 1
a2243 1
		if (p->channels != a1d->bNrChannels)
d2245 1
a2245 1
		if (p->precision != a1d->bBitResolution)
d2247 1
a2247 1
		if (p->encoding != alts[i].encoding)
d2279 1
a2279 1
		 rate, p->channels));
d2284 1
a2284 1
		if (p->channels != a1d->bNrChannels)
d2286 1
a2286 1
		if (p->precision != a1d->bBitResolution)
d2288 1
a2288 1
		if (p->encoding != alts[i].encoding)
d2295 1
a2295 1
			if (UA_SAMP_LO(a1d) < rate && rate < UA_SAMP_HI(a1d))
d2320 1
a2320 1
		 p->sample_rate, p->channels, p->precision));
d2334 1
a2334 1
			p->sample_rate = rate;
d2341 1
a2341 1
			p->sample_rate = max;
d2347 1
a2347 1
			p->sample_rate = min;
d2366 1
a2366 1
		p->channels = n;
d2374 1
a2374 1
	p->channels = 1;
d2394 2
a2395 2
	if ((mode == AUMODE_RECORD && sc->sc_recchan.pipe != NULL)
	    || (mode == AUMODE_PLAY && sc->sc_playchan.pipe != NULL))
d2432 1
a2432 1
					p->precision = 16;
d2459 1
a2459 1
					p->precision = 16;
d2478 1
a2478 1
				p->precision = 16;
d2501 1
a2501 1
				p->precision = 16;
d2523 1
a2523 1
			 p->channels, p->precision, enc, p->sample_rate));
d2525 1
a2525 1
		p->encoding = enc;
d2545 1
a2545 1
		uaudio_chan_init(&sc->sc_playchan, paltidx, play);
d2549 2
a2550 1
		uaudio_chan_init(&sc->sc_recchan, raltidx, rec);
@


1.14
log
@strcpy/sprintf cleanup of sys/dev. miod@@, deraadt@@ says to commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.13 2002/07/25 04:07:32 nate Exp $ */
d363 1
a363 1
	usbd_devinfo(uaa->device, 0, devinfo);
d614 1
a614 1
	sprintf(buf, "i%d", id);
d765 2
a766 1
			sprintf(mix.ctlname, "mix%d-%s", d->bUnitId,
d848 2
a849 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d856 2
a857 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d864 2
a865 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d872 2
a873 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d880 2
a881 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d891 2
a892 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d899 2
a900 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d907 2
a908 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d915 2
a916 1
			sprintf(mix.ctlname, "fea%d-%s-%s", unit,
d954 2
a955 1
	sprintf(mix.ctlname, "pro%d-mode", d->bUnitId);
d986 2
a987 1
		sprintf(mix.ctlname, "pro%d.%d-enable", d->bUnitId, ptype);
d1032 2
a1033 1
		sprintf(mix.ctlname, "ext%d-enable", d->bUnitId);
@


1.13
log
@update $NetBSD$ tags
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.12 2002/05/06 23:07:26 nate Exp $ */
d487 1
a487 1
		strcpy(fp->name, AudioEulinear);
d493 1
a493 1
		strcpy(fp->name, AudioEmulaw);
d499 1
a499 1
		strcpy(fp->name, AudioEalaw);
d505 1
a505 1
		strcpy(fp->name, AudioEslinear);
d511 1
a511 1
		strcpy(fp->name, AudioEslinear_le);
d517 1
a517 1
		strcpy(fp->name, AudioEulinear_le);
d523 1
a523 1
		strcpy(fp->name, AudioEslinear_be);
d529 1
a529 1
		strcpy(fp->name, AudioEulinear_be);
d1378 2
a1379 1
			strcpy(mi->label.name, AudioCoutputs);
d1385 2
a1386 1
			strcpy(mi->label.name, AudioCinputs);
d1392 2
a1393 1
			strcpy(mi->label.name, AudioCequalization);
d1400 1
a1400 1
	strncpy(mi->label.name, mc->ctlname, MAX_AUDIO_DEV_LEN);
d1407 2
a1408 1
		strcpy(mi->un.e.member[0].label.name, AudioNoff);
d1410 2
a1411 1
		strcpy(mi->un.e.member[1].label.name, AudioNon);
d1416 2
a1417 1
		strncpy(mi->un.v.units.name, mc->ctlunit, MAX_AUDIO_DEV_LEN);
@


1.12
log
@sync uaudio with NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.11 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: uaudio.c,v 1.59 2002/04/20 17:36:16 kent Exp $	*/
@


1.11
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.10 2001/09/17 20:30:25 drahn Exp $ */
/*	$NetBSD: uaudio.c,v 1.43 2001/10/03 00:04:53 augustss Exp $	*/
d55 1
a55 1
#include <sys/reboot.h>				/* for bootverbose */
d84 1
a84 1
#define UAUDIO_NFRAMES   20	/* ms of sound in each request */
d111 3
d118 1
a121 1
	int	terminal;	/* terminal id */
a124 1
	int	dir;		/* direction */
d138 1
a138 1
	char	nofrac;		/* don't do sample rate adjustment */
d142 1
a142 1
		struct chan         *chan;
d144 3
a146 3
		u_char              *buffer;
		u_int16_t           sizes[UAUDIO_NFRAMES];
		u_int16_t	    size;
d159 2
a160 3
	struct chan sc_chan;

	int	sc_curaltidx;
a167 1
	int	sc_props;
d170 9
a178 5
#define HAS_8     0x01
#define HAS_16    0x02
#define HAS_8U    0x04
#define HAS_ALAW  0x08
#define HAS_MULAW 0x10
d199 1
a199 1
Static void 		uaudio_add_alt(struct uaudio_softc *sc, 
d207 1
a207 1
Static char 		*uaudio_id_name(struct uaudio_softc *sc,
d213 1
a213 1
Static void 		uaudio_add_output(struct uaudio_softc *sc,
d222 1
a222 1
			         usb_descriptor_t *v, usb_descriptor_t **dps);
d227 1
a227 1
Static usbd_status	uaudio_identify(struct uaudio_softc *sc, 
d230 4
a233 4
Static int 		uaudio_signext(int type, int val);
Static int 		uaudio_value2bsd(struct mixerctl *mc, int val);
Static int 		uaudio_bsd2value(struct mixerctl *mc, int val);
Static int 		uaudio_get(struct uaudio_softc *sc, int type,
d239 1
a239 1
Static void 		uaudio_ctl_set(struct uaudio_softc *sc, int which,
d252 3
a254 2
Static void		uaudio_chan_set_param(struct chan *ch,
			    struct audio_params *param, u_char *start, 
d257 1
a257 1
Static void		uaudio_chan_pintr(usbd_xfer_handle xfer, 
d261 1
a261 1
Static void		uaudio_chan_rintr(usbd_xfer_handle xfer, 
d268 11
a278 1
Static int		uaudio_set_params(void *, int, int, 
d322 3
d339 1
a339 1
	
d345 1
a345 1
	if (id == NULL || 
d413 1
a413 1
	sc->sc_chan.sc = sc;
d416 1
a416 1
		sc->sc_chan.nofrac = 1;
d418 1
a418 2
#if defined(__NetBSD__)
#ifndef UAUDIO_DEBUG
a420 1
#endif
d480 1
a480 1
    
d510 1
a510 1
        case 4:
d563 1
a563 1
 
d573 3
a575 3
		mc->minval = uaudio_signext(mc->type, 
			uaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE, 
				   mc->wValue[0], mc->wIndex, 
d577 1
a577 1
		mc->maxval = 1 + uaudio_signext(mc->type, 
d683 1
a683 1
uaudio_add_input(struct uaudio_softc *sc, usb_descriptor_t *v, 
d687 1
a687 1
	struct usb_audio_input_terminal *d = 
d704 1
a704 1
	struct usb_audio_output_terminal *d = 
d726 1
a726 1
	
d762 1
a762 1
						mix.wValue[k++] = 
d817 1
a817 1
		    "%d channels, mmask=0x%04x, cmask=0x%04x\n", 
d848 1
a848 1
				uaudio_id_name(sc, dps, srcId), 
d855 1
a855 1
				uaudio_id_name(sc, dps, srcId), 
d862 1
a862 1
				uaudio_id_name(sc, dps, srcId), 
d869 1
a869 1
				uaudio_id_name(sc, dps, srcId), 
d876 1
a876 1
				uaudio_id_name(sc, dps, srcId), 
d886 1
a886 1
				uaudio_id_name(sc, dps, srcId), 
d893 1
a893 1
				uaudio_id_name(sc, dps, srcId), 
d900 1
a900 1
				uaudio_id_name(sc, dps, srcId), 
d907 1
a907 1
				uaudio_id_name(sc, dps, srcId), 
d920 1
a920 1
	struct usb_audio_processing_unit *d = 
d958 1
a958 1
	struct usb_audio_processing_unit *d = 
d1001 1
a1001 1
	struct usb_audio_extension_unit *d = 
d1040 1
a1040 1
	struct as_info *nai = sc->sc_nalts == 0 ?
d1118 1
a1118 1
	
d1126 1
a1126 1
	
d1130 1
a1130 2
	if (prec != 8 && prec != 16) {
#ifdef UAUDIO_DEBUG
a1132 1
#endif
d1137 7
a1143 1
		sc->sc_altflags |= prec == 8 ? HAS_8 : HAS_16;
d1163 2
a1164 2
	DPRINTFN(1,("uaudio_identify: alt=%d enc=%d chan=%d prec=%d\n",
		    id->bAlternateSetting, enc, chan, prec));
d1167 1
d1171 1
d1173 20
a1192 2
	sc->sc_chan.terminal = asid->bTerminalLink; /* XXX */
	sc->sc_chan.dir |= dir == UE_DIR_OUT ? AUMODE_PLAY : AUMODE_RECORD;
d1196 1
a1196 1
	
a1213 3
	sc->sc_chan.terminal = -1;
	sc->sc_chan.dir = 0;

d1242 3
a1244 2
	if (sc->sc_chan.terminal < 0) {
		printf("%s: no useable endpoint found\n", 
d1248 1
a1248 4
#if 0
	if (sc->sc_chan.dir == (AUMODE_PLAY | AUMODE_RECORD))
		sc->sc_props |= AUDIO_PROP_FULLDUPLEX;
#endif
d1322 1
a1322 1
		DPRINTF(("uaudio_identify: subtype=%d\n", 
d1368 1
a1368 1
    
d1424 1
a1424 1
        DPRINTF(("uaudio_open: sc=%p\n", sc));
d1428 1
a1428 1
	if (sc->sc_chan.terminal < 0)
d1431 5
a1435 4
	if ((flags & FREAD) && !(sc->sc_chan.dir & AUMODE_RECORD))
		return (EACCES);
	if ((flags & FWRITE) && !(sc->sc_chan.dir & AUMODE_PLAY))
		return (EACCES);
d1437 5
a1441 1
        sc->sc_chan.intr = 0;
d1443 1
a1443 1
        return (0);
d1458 1
a1458 1
	sc->sc_chan.intr = 0;
d1477 4
a1480 4
	if (sc->sc_chan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_chan);
		sc->sc_chan.pipe = 0;
		uaudio_chan_free_buffers(sc, &sc->sc_chan);
d1482 1
a1482 1
        return (0);
d1491 4
a1494 4
	if (sc->sc_chan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_chan);
		sc->sc_chan.pipe = 0;
		uaudio_chan_free_buffers(sc, &sc->sc_chan);
d1496 1
a1496 1
        return (0);
d1507 1
a1507 1
    
d1509 1
a1509 1
        return (0);
d1521 10
a1530 1
	bpf = sc->sc_chan.bytes_per_frame + sc->sc_chan.sample_size;
d1553 1
a1553 3
	struct uaudio_softc *sc = addr;

	return (sc->sc_props);
d1574 1
a1574 1
		    "wIndex=0x%04x len=%d\n", 
d1576 1
a1576 1
	err = usbd_do_request(sc->sc_udev, &req, &data);
d1624 1
a1624 1
		    "wIndex=0x%04x len=%d, val=%d\n", 
d1626 1
a1626 1
	err = usbd_do_request(sc->sc_udev, &req, &data);
d1651 1
a1651 1
		val = val != 0;
d1665 1
a1665 1
		val = val != 0;
d1673 1
a1673 1
uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc, 
d1704 1
a1704 1
    
d1733 1
a1733 1
    
d1744 1
a1744 1
    
d1777 1
a1777 1
	struct chan *ch = &sc->sc_chan;
d1787 1
a1787 1
	uaudio_chan_set_param(ch, param, start, end, blksize);
d1802 2
a1803 2
	sc->sc_chan.intr = intr;
	sc->sc_chan.arg = arg;
d1810 1
a1810 1
        return (0);
d1812 1
a1812 1
    
d1819 1
a1819 1
	struct chan *ch = &sc->sc_chan;
d1829 1
a1829 1
	uaudio_chan_set_param(ch, param, start, end, blksize);
d1844 2
a1845 2
	sc->sc_chan.intr = intr;
	sc->sc_chan.arg = arg;
d1852 1
a1852 1
        return (0);
d1859 1
a1859 1
	struct as_info *as = &sc->sc_alts[sc->sc_curaltidx];
d1863 1
a1863 1
	DPRINTF(("uaudio_open_chan: endpt=0x%02x, speed=%d, alt=%d\n", 
d1881 1
a1881 1
	DPRINTF(("uaudio_open_chan: create pipe to 0x%02x\n", endpt));
d1889 1
a1889 1
	struct as_info *as = &sc->sc_alts[sc->sc_curaltidx];
d1891 1
d1893 1
a1893 1
		DPRINTF(("uaudio_close_chan: set null alt=%d\n",
d1963 1
a1963 1
			if (!ch->nofrac)
d1973 1
a1973 1
	/* 
d2000 2
a2001 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, 
			     UAUDIO_NFRAMES, USBD_NO_COPY, 
d2035 1
a2035 1
		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n", 
d2067 1
a2067 1
			if (!ch->nofrac)
d2089 2
a2090 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, 
			     UAUDIO_NFRAMES, USBD_NO_COPY, 
d2127 1
a2127 1
	/* 
d2146 1
a2146 1
		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n", 
d2157 1
a2157 2
uaudio_chan_set_param(struct chan *ch, struct audio_params *param,
		      u_char *start, u_char *end, int blksize)
d2161 2
a2162 1
	sample_size = param->precision * param->channels / 8;
d2169 1
d2171 3
d2183 149
d2339 2
a2340 1
	int enc, i, j;
d2348 2
a2349 1
	if (sc->sc_chan.pipe != NULL)
d2352 5
d2361 2
a2362 1
		if ((sc->sc_chan.dir & mode) == 0)
d2365 1
a2365 1
		p = mode == AUMODE_PLAY ? play : rec;
d2372 4
a2375 1
			if (p->precision == 16) {
d2378 14
a2391 9
			} else if (p->precision == 8 && !(flags & HAS_8)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision == 8 && !(flags & HAS_8)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_ULINEAR_LE;
d2395 2
d2398 3
a2400 1
				if (mode == AUMODE_PLAY)
d2405 7
a2411 19
			} else if (p->precision == 8 && !(flags & HAS_8U)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16) {
				swcode = change_sign16_le;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else if (p->precision == 8 && !(flags & HAS_8U)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_ULAW:
			if (!(flags & HAS_MULAW)) {
				if (mode == AUMODE_PLAY &&
				    (flags & HAS_16)) {
					swcode = mulaw_to_slinear16_le;
d2413 1
a2414 1
				} else if (flags & HAS_8U) {
d2416 1
a2416 1
						swcode = mulaw_to_ulinear8;
d2418 2
a2419 10
						swcode = ulinear8_to_mulaw;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_8) {
					if (mode == AUMODE_PLAY)
						swcode = mulaw_to_slinear8;
					else
						swcode = slinear8_to_mulaw;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else
					return (EINVAL);
d2422 26
d2449 21
a2469 21
			if (!(flags & HAS_ALAW)) {
				if (mode == AUMODE_PLAY &&
				    (flags & HAS_16)) {
					swcode = alaw_to_slinear16_le;
					factor = 2;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else if (flags & HAS_8U) {
					if (mode == AUMODE_PLAY)
						swcode = alaw_to_ulinear8;
					else
						swcode = ulinear8_to_alaw;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_8) {
					if (mode == AUMODE_PLAY)
						swcode = alaw_to_slinear8;
					else
						swcode = slinear8_to_alaw;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else
					return (EINVAL);
			}
d2479 4
a2482 27
		for (i = 0; i < sc->sc_nalts; i++) {
			struct usb_audio_streaming_type1_descriptor *a1d =
				sc->sc_alts[i].asf1desc;
			if (p->channels == a1d->bNrChannels &&
			    p->precision == a1d->bBitResolution &&
			    enc == sc->sc_alts[i].encoding &&
			    (mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN) ==
			    UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress)) {
				if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
					DPRINTFN(2,("uaudio_set_params: cont %d-%d\n",
					    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
					if (UA_SAMP_LO(a1d) < p->sample_rate &&
					    p->sample_rate < UA_SAMP_HI(a1d))
						goto found;
				} else {
					for (j = 0; j < a1d->bSamFreqType; j++) {
						DPRINTFN(2,("uaudio_set_params: disc #"
						    "%d: %d\n", j, UA_GETSAMP(a1d, j)));
						/* XXX allow for some slack */
						if (UA_GETSAMP(a1d, j) ==
						    p->sample_rate)
							goto found;
					}
				}
			}
		}
		return (EINVAL);
a2483 1
	found:
d2486 9
a2494 2
		if (usemode == mode)
			sc->sc_curaltidx = i;
d2497 18
a2514 4
	DPRINTF(("uaudio_set_params: use altidx=%d, altno=%d\n", 
		 sc->sc_curaltidx, 
		 sc->sc_alts[sc->sc_curaltidx].idesc->bAlternateSetting));
	
d2534 1
a2534 1
	return (usbd_do_request(sc->sc_udev, &req, &data));
a2535 1

@


1.11.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uaudio.c,v 1.59 2002/04/20 17:36:16 kent Exp $	*/
d55 1
a55 1
#include <sys/reboot.h>			/* for bootverbose */
d84 1
a84 1
#define UAUDIO_NFRAMES   10	/* ms of sound in each request */
a110 3
	u_int8_t	attributes; /* Copy of bmAttributes of
				     * usb_audio_streaming_endpoint_descriptor
				     */
a114 1
	int		sc_busy;	/* currently used */
d118 1
d122 1
d136 1
a136 1
	int	altidx;		/* currently used altidx */
d140 1
a140 1
		struct chan	*chan;
d142 3
a144 3
		u_char		*buffer;
		u_int16_t	sizes[UAUDIO_NFRAMES];
		u_int16_t	size;
d157 3
a159 2
	struct chan sc_playchan;	/* play channel */
	struct chan sc_recchan;		/* record channel */
d167 1
d170 5
a174 9
#define HAS_8		0x01
#define HAS_16		0x02
#define HAS_8U		0x04
#define HAS_ALAW	0x08
#define HAS_MULAW	0x10
#define UA_NOFRAC	0x20		/* don't do sample rate adjustment */
#define HAS_24		0x40

	int	sc_mode;		/* play/record capability */
d195 1
a195 1
Static void		uaudio_add_alt(struct uaudio_softc *sc,
d203 1
a203 1
Static char		*uaudio_id_name(struct uaudio_softc *sc,
d209 1
a209 1
Static void		uaudio_add_output(struct uaudio_softc *sc,
d218 1
a218 1
			    usb_descriptor_t *v, usb_descriptor_t **dps);
d223 1
a223 1
Static usbd_status	uaudio_identify(struct uaudio_softc *sc,
d226 4
a229 4
Static int		uaudio_signext(int type, int val);
Static int		uaudio_value2bsd(struct mixerctl *mc, int val);
Static int		uaudio_bsd2value(struct mixerctl *mc, int val);
Static int		uaudio_get(struct uaudio_softc *sc, int type,
d235 1
a235 1
Static void		uaudio_ctl_set(struct uaudio_softc *sc, int which,
d248 2
a249 3
Static void		uaudio_chan_init(struct chan *, int,
					 const struct audio_params *);
Static void		uaudio_chan_set_param(struct chan *ch, u_char *start,
d252 1
a252 1
Static void		uaudio_chan_pintr(usbd_xfer_handle xfer,
d256 1
a256 1
Static void		uaudio_chan_rintr(usbd_xfer_handle xfer,
d263 1
a263 11
Static void		uaudio_get_minmax_rates(int, const struct as_info *,
						const struct audio_params *,
						int, u_long *, u_long *);
Static int		uaudio_match_alt_sub(int, const struct as_info *,
					     const struct audio_params *,
					     int, u_long);
Static int		uaudio_match_alt_chan(int, const struct as_info *,
					      struct audio_params *, int);
Static int		uaudio_match_alt(int, const struct as_info *,
					 struct audio_params *, int);
Static int		uaudio_set_params(void *, int, int,
a306 3
#if defined(__NetBSD__)
	NULL,
#endif
d321 1
a321 1

d327 1
a327 1
	if (id == NULL ||
d395 1
a395 1
	sc->sc_playchan.sc = sc->sc_recchan.sc = sc;
d398 1
a398 1
		sc->sc_altflags |= UA_NOFRAC;
d400 2
a401 1
#if defined(__NetBSD__) && !defined(UAUDIO_DEBUG)
d404 1
d464 1
a464 1

d494 1
a494 1
	case 4:
d547 1
a547 1

d557 3
a559 3
		mc->minval = uaudio_signext(mc->type,
			uaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE,
				   mc->wValue[0], mc->wIndex,
d561 1
a561 1
		mc->maxval = 1 + uaudio_signext(mc->type,
d667 1
a667 1
uaudio_add_input(struct uaudio_softc *sc, usb_descriptor_t *v,
d671 1
a671 1
	struct usb_audio_input_terminal *d =
d688 1
a688 1
	struct usb_audio_output_terminal *d =
d710 1
a710 1

d746 1
a746 1
						mix.wValue[k++] =
d801 1
a801 1
		    "%d channels, mmask=0x%04x, cmask=0x%04x\n",
d832 1
a832 1
				uaudio_id_name(sc, dps, srcId),
d839 1
a839 1
				uaudio_id_name(sc, dps, srcId),
d846 1
a846 1
				uaudio_id_name(sc, dps, srcId),
d853 1
a853 1
				uaudio_id_name(sc, dps, srcId),
d860 1
a860 1
				uaudio_id_name(sc, dps, srcId),
d870 1
a870 1
				uaudio_id_name(sc, dps, srcId),
d877 1
a877 1
				uaudio_id_name(sc, dps, srcId),
d884 1
a884 1
				uaudio_id_name(sc, dps, srcId),
d891 1
a891 1
				uaudio_id_name(sc, dps, srcId),
d904 1
a904 1
	struct usb_audio_processing_unit *d =
d942 1
a942 1
	struct usb_audio_processing_unit *d =
d985 1
a985 1
	struct usb_audio_extension_unit *d =
d1024 1
a1024 1
	struct as_info *nai = (sc->sc_nalts == 0) ?
d1102 1
a1102 1

d1110 1
a1110 1

d1114 2
a1115 1
	if (prec != 8 && prec != 16 && prec != 24) {
d1118 1
d1123 1
a1123 7
		if (prec == 8) {
			sc->sc_altflags |= HAS_8;
		} else if (prec == 16) {
			sc->sc_altflags |= HAS_16;
		} else if (prec == 24) {
			sc->sc_altflags |= HAS_24;
		}
d1143 2
a1144 2
	DPRINTFN(1, ("uaudio_process_as: alt=%d enc=%d chan=%d prec=%d\n",
		     id->bAlternateSetting, enc, chan, prec));
a1146 1
	ai.attributes = sed->bmAttributes;
a1149 1
	ai.sc_busy = 0;
d1151 2
a1152 20
#ifdef UAUDIO_DEBUG
	{
		int j;
		if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(1, ("uaudio_process_as:  rate=%d-%d\n",
				     UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d)));
		} else {
			DPRINTFN(1, ("uaudio_process_as: "));
			for (j = 0; j < asf1d->bSamFreqType; j++)
				DPRINTFN(1, (" %d", UA_GETSAMP(asf1d, j)));
			DPRINTFN(1, ("\n"));
		}
		if (ai.attributes & UA_SED_FREQ_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  FREQ_CONTROL\n"));
		if (ai.attributes & UA_SED_PITCH_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  PITCH_CONTROL\n"));
	}
#endif
	sc->sc_mode |= (dir == UE_DIR_OUT) ? AUMODE_PLAY : AUMODE_RECORD;

d1156 1
a1156 1

d1174 3
d1205 2
a1206 3

	if ((sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD)) == 0) {
		printf("%s: no usable endpoint found\n",
d1210 4
a1213 1

d1287 1
a1287 1
		DPRINTF(("uaudio_identify: subtype=%d\n",
d1333 1
a1333 1

d1389 1
a1389 1
	DPRINTF(("uaudio_open: sc=%p\n", sc));
d1393 1
a1393 1
	if (sc->sc_mode == 0)
d1396 4
a1399 5
	if (flags & FREAD) {
		if ((sc->sc_mode & AUMODE_RECORD) == 0)
			return (EACCES);
		sc->sc_recchan.intr = NULL;
	}
d1401 1
a1401 5
	if (flags & FWRITE) {
		if ((sc->sc_mode & AUMODE_PLAY) == 0)
			return (EACCES);
		sc->sc_playchan.intr = NULL;
	}
d1403 1
a1403 1
	return (0);
d1418 1
a1418 1
	sc->sc_playchan.intr = sc->sc_recchan.intr = NULL;
d1437 4
a1440 4
	if (sc->sc_playchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_playchan);
		sc->sc_playchan.pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_playchan);
d1442 1
a1442 1
	return (0);
d1451 4
a1454 4
	if (sc->sc_recchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_recchan);
		sc->sc_recchan.pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_recchan);
d1456 1
a1456 1
	return (0);
d1467 1
a1467 1

d1469 1
a1469 1
	return (0);
d1481 1
a1481 10
	DPRINTF(("uaudio_round_blocksize: p.bpf=%d r.bpf=%d\n",
		 sc->sc_playchan.bytes_per_frame,
		 sc->sc_recchan.bytes_per_frame));
	if (sc->sc_playchan.bytes_per_frame > sc->sc_recchan.bytes_per_frame) {
		bpf = sc->sc_playchan.bytes_per_frame
		    + sc->sc_playchan.sample_size;
	} else {
		bpf = sc->sc_recchan.bytes_per_frame
		    + sc->sc_recchan.sample_size;
	}
d1504 3
a1506 1
	return (AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT);
d1527 1
a1527 1
		    "wIndex=0x%04x len=%d\n",
d1529 1
a1529 1
	err = usbd_do_request(sc->sc_udev, &req, data);
d1577 1
a1577 1
		    "wIndex=0x%04x len=%d, val=%d\n",
d1579 1
a1579 1
	err = usbd_do_request(sc->sc_udev, &req, data);
d1604 1
a1604 1
		val = (val != 0);
d1618 1
a1618 1
		val = (val != 0);
d1626 1
a1626 1
uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc,
d1657 1
a1657 1

d1686 1
a1686 1

d1697 1
a1697 1

d1730 1
a1730 1
	struct chan *ch = &sc->sc_recchan;
d1740 1
a1740 1
	uaudio_chan_set_param(ch, start, end, blksize);
d1755 2
a1756 2
	ch->intr = intr;
	ch->arg = arg;
d1763 1
a1763 1
	return (0);
d1765 1
a1765 1

d1772 1
a1772 1
	struct chan *ch = &sc->sc_playchan;
d1782 1
a1782 1
	uaudio_chan_set_param(ch, start, end, blksize);
d1797 2
a1798 2
	ch->intr = intr;
	ch->arg = arg;
d1805 1
a1805 1
	return (0);
d1812 1
a1812 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
d1816 1
a1816 1
	DPRINTF(("uaudio_chan_open: endpt=0x%02x, speed=%d, alt=%d\n",
d1834 1
a1834 1
	DPRINTF(("uaudio_chan_open: create pipe to 0x%02x\n", endpt));
d1842 1
a1842 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
a1843 1
	as->sc_busy = 0;
d1845 1
a1845 1
		DPRINTF(("uaudio_chan_close: set null alt=%d\n",
d1915 1
a1915 1
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
d1925 1
a1925 1
	/*
d1952 2
a1953 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     UAUDIO_NFRAMES, USBD_NO_COPY,
d1987 1
a1987 1
		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n",
d2019 1
a2019 1
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
d2041 2
a2042 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     UAUDIO_NFRAMES, USBD_NO_COPY,
d2079 1
a2079 1
	/*
d2098 1
a2098 1
		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n",
d2109 2
a2110 1
uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param)
d2114 1
a2114 2
	ch->altidx = altidx;
	sample_size = param->precision * param->factor * param->channels / 8;
a2120 1
}
a2121 3
void
uaudio_chan_set_param(struct chan *ch, u_char *start, u_char *end, int blksize)
{
a2130 149
void
uaudio_get_minmax_rates(int nalts, const struct as_info *alts,
			const struct audio_params *p, int mode,
			u_long *min, u_long *max)
{
	int i, j;
	struct usb_audio_streaming_type1_descriptor *a1d;

	*min = ULONG_MAX;
	*max = 0;
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
			continue;
		if (p->channels != a1d->bNrChannels)
			continue;
		if (p->precision != a1d->bBitResolution)
			continue;
		if (p->encoding != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(2,("uaudio_get_minmax_rates: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) < *min)
				*min = UA_SAMP_LO(a1d);
			if (UA_SAMP_HI(a1d) > *max)
				*max = UA_SAMP_HI(a1d);
		} else {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				DPRINTFN(2,("uaudio_get_minmax_rates: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				if (UA_GETSAMP(a1d, j) < *min)
					*min = UA_GETSAMP(a1d, j);
				if (UA_GETSAMP(a1d, j) > *max)
					*max = UA_GETSAMP(a1d, j);
			}
		}
	}
}

int
uaudio_match_alt_sub(int nalts, const struct as_info *alts,
		     const struct audio_params *p, int mode, u_long rate)
{
	int i, j;
	struct usb_audio_streaming_type1_descriptor *a1d;

	DPRINTF(("uaudio_match_alt_sub: search for %luHz %dch\n",
		 rate, p->channels));
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
			continue;
		if (p->channels != a1d->bNrChannels)
			continue;
		if (p->precision != a1d->bBitResolution)
			continue;
		if (p->encoding != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(2,("uaudio_match_alt_sub: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) < rate && rate < UA_SAMP_HI(a1d))
				return i;
		} else {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				DPRINTFN(2,("uaudio_match_alt_sub: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				/* XXX allow for some slack */
				if (UA_GETSAMP(a1d, j) == rate)
					return i;
			}
		}
	}
	return -1;
}

int
uaudio_match_alt_chan(int nalts, const struct as_info *alts,
		      struct audio_params *p, int mode)
{
	int i, n;
	u_long min, max;
	u_long rate;

	/* Exact match */
	DPRINTF(("uaudio_match_alt_chan: examine %ldHz %dch %dbit.\n",
		 p->sample_rate, p->channels, p->precision));
	i = uaudio_match_alt_sub(nalts, alts, p, mode, p->sample_rate);
	if (i >= 0)
		return i;

	uaudio_get_minmax_rates(nalts, alts, p, mode, &min, &max);
	DPRINTF(("uaudio_match_alt_chan: min=%lu max=%lu\n", min, max));
	if (max <= 0)
		return -1;
	/* Search for biggers */
	n = 2;
	while ((rate = p->sample_rate * n++) <= max) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, rate);
		if (i >= 0) {
			p->sample_rate = rate;
			return i;
		}
	}
	if (p->sample_rate >= min) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, max);
		if (i >= 0) {
			p->sample_rate = max;
			return i;
		}
	} else {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, min);
		if (i >= 0) {
			p->sample_rate = min;
			return i;
		}
	}
	return -1;
}

int
uaudio_match_alt(int nalts, const struct as_info *alts,
		 struct audio_params *p, int mode)
{
	int i, n;

	mode = mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN;
	i = uaudio_match_alt_chan(nalts, alts, p, mode);
	if (i >= 0)
		return i;

	for (n = p->channels + 1; n <= AUDIO_MAX_CHANNELS; n++) {
		p->channels = n;
		i = uaudio_match_alt_chan(nalts, alts, p, mode);
		if (i >= 0)
			return i;
	}

	if (p->channels != 2)
		return -1;
	p->channels = 1;
	return uaudio_match_alt_chan(nalts, alts, p, mode);
}

d2138 1
a2138 2
	int enc, i;
	int paltidx=-1, raltidx=-1;
d2146 1
a2146 2
	if ((mode == AUMODE_RECORD && sc->sc_recchan.pipe != NULL)
	    || (mode == AUMODE_PLAY && sc->sc_playchan.pipe != NULL))
a2148 5
	if (usemode & AUMODE_PLAY && sc->sc_playchan.altidx != -1)
		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 0;
	if (usemode & AUMODE_RECORD && sc->sc_recchan.altidx != -1)
		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 0;

d2153 1
a2153 2

		if ((sc->sc_mode & mode) == 0)
d2156 1
a2156 1
		p = (mode == AUMODE_PLAY) ? play : rec;
d2163 1
a2163 4
			/* FALLTHROUGH */
		case AUDIO_ENCODING_SLINEAR_LE:
			if (enc == AUDIO_ENCODING_SLINEAR_BE
			    && p->precision == 16 && (flags & HAS_16)) {
d2166 9
a2174 14
			} else if (p->precision == 8) {
				if (flags & HAS_8) {
					/* No conversion */
				} else if (flags & HAS_8U) {
					swcode = change_sign8;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_16) {
					factor = 2;
					p->precision = 16;
					if (mode == AUMODE_PLAY)
						swcode = linear8_to_linear16_le;
					else
						swcode = linear16_to_linear8_le;
				}
a2177 2
			/* FALLTHROUGH */
		case AUDIO_ENCODING_ULINEAR_LE:
d2179 1
a2179 3
				if (enc == AUDIO_ENCODING_ULINEAR_LE)
					swcode = change_sign16_le;
				else if (mode == AUMODE_PLAY)
d2184 27
a2210 3
			} else if (p->precision == 8) {
				if (flags & HAS_8U) {
					/* No conversion */
d2212 4
a2215 1
					swcode = change_sign8;
d2217 9
a2225 1
				} else if (flags & HAS_16) {
a2226 1
					p->precision = 16;
d2228 1
d2230 1
a2230 1
						swcode = ulinear8_to_slinear16_le;
d2232 10
a2241 2
						swcode = slinear16_to_ulinear8_le;
				}
a2243 49
		case AUDIO_ENCODING_ULAW:
			if (flags & HAS_MULAW)
				break;
			if (flags & HAS_16) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear16_le;
				else
					swcode = slinear16_to_mulaw_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				p->precision = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_ulinear8;
				else
					swcode = ulinear8_to_mulaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear8;
				else
					swcode = slinear8_to_mulaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
			break;
		case AUDIO_ENCODING_ALAW:
			if (flags & HAS_ALAW)
				break;
			if (mode == AUMODE_PLAY && (flags & HAS_16)) {
				swcode = alaw_to_slinear16_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				p->precision = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_ulinear8;
				else
					swcode = ulinear8_to_alaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_slinear8;
				else
					swcode = slinear8_to_alaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
			break;
d2252 27
a2278 4
		p->encoding = enc;
		i = uaudio_match_alt(sc->sc_nalts, sc->sc_alts, p, mode);
		if (i < 0)
			return (EINVAL);
d2280 1
d2283 2
a2284 9
		if (usemode & mode) {
			if (mode == AUMODE_PLAY) {
				paltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			} else {
				raltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			}
		}
d2287 4
a2290 18
	if ((usemode & AUMODE_PLAY) /*&& paltidx != sc->sc_playchan.altidx*/) {
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_playchan, paltidx, play);
	}
	if ((usemode & AUMODE_RECORD) /*&& raltidx != sc->sc_recchan.altidx*/) {
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_recchan, raltidx, rec);
	}

	DPRINTF(("uaudio_set_params: use altidx=p%d/r%d, altno=p%d/r%d\n",
		 sc->sc_playchan.altidx, sc->sc_recchan.altidx,
		 (sc->sc_playchan.altidx >= 0)
		   ?sc->sc_alts[sc->sc_playchan.altidx].idesc->bAlternateSetting
		   : -1,
		 (sc->sc_recchan.altidx >= 0)
		   ? sc->sc_alts[sc->sc_recchan.altidx].idesc->bAlternateSetting
		   : -1));

d2310 1
a2310 1
	return (usbd_do_request(sc->sc_udev, &req, data));
d2312 1
@


1.11.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: uaudio.c,v 1.60 2002/05/18 15:14:39 kent Exp $	*/
@


1.11.2.3
log
@sync
@
text
@d363 1
a363 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d487 1
a487 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d493 1
a493 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d499 1
a499 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d505 1
a505 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d511 1
a511 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d517 1
a517 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d523 1
a523 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d529 1
a529 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d614 1
a614 1
	snprintf(buf, sizeof buf, "i%d", id);
d765 1
a765 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"mix%d-%s", d->bUnitId,
d847 1
a847 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d854 1
a854 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d861 1
a861 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d868 1
a868 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d875 1
a875 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d885 1
a885 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d892 1
a892 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d899 1
a899 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d906 1
a906 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d944 1
a944 2
	snprintf(mix.ctlname, sizeof mix.ctlname,
		"pro%d-mode", d->bUnitId);
d975 1
a975 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"pro%d.%d-enable", d->bUnitId, ptype);
d1020 1
a1020 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"ext%d-enable", d->bUnitId);
d1378 1
a1378 2
			strlcpy(mi->label.name, AudioCoutputs,
			    sizeof mi->label.name);
d1384 1
a1384 2
			strlcpy(mi->label.name, AudioCinputs,
			    sizeof mi->label.name);
d1390 1
a1390 2
			strlcpy(mi->label.name, AudioCequalization,
			    sizeof mi->label.name);
d1397 1
a1397 1
	strlcpy(mi->label.name, mc->ctlname, sizeof mi->label.name);
d1404 1
a1404 2
		strlcpy(mi->un.e.member[0].label.name, AudioNoff,
		    sizeof mi->un.e.member[0].label.name);
d1406 1
a1406 2
		strlcpy(mi->un.e.member[1].label.name, AudioNon,
		    sizeof mi->un.e.member[1].label.name);
d1411 1
a1411 2
		strlcpy(mi->un.v.units.name, mc->ctlunit,
		    sizeof mi->un.v.units.name);
@


1.10
log
@Save the result of the configure children, so that the device
can be unconfigured. Allows uaudio to be unplugged.
Tested by lebel, aaron did not understand why the code was that way.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.9 2001/05/03 02:20:32 aaron Exp $ */
/*	$NetBSD: uaudio.c,v 1.41 2001/01/23 14:04:13 augustss Exp $	*/
d55 1
a55 1
#include <sys/reboot.h>
d543 6
a548 8

	if (sc->sc_nctls == 0)
		sc->sc_ctls = malloc(sizeof *mc, M_USBDEV, M_NOWAIT);
	else
		sc->sc_ctls = realloc(sc->sc_ctls, 
				      (sc->sc_nctls+1) * sizeof *mc,
				      M_USBDEV, M_NOWAIT);
	if (sc->sc_ctls == NULL) {
d552 1
d1023 6
a1028 7
	if (sc->sc_nalts == 0)
		sc->sc_alts = malloc(sizeof *ai, M_USBDEV, M_NOWAIT);
	else
		sc->sc_alts = realloc(sc->sc_alts,
				      (sc->sc_nalts+1) * sizeof *ai,
				      M_USBDEV, M_NOWAIT);
	if (sc->sc_alts == NULL) {
d1032 2
@


1.9
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.8 2001/01/28 09:43:41 aaron Exp $ */
a411 3
#if defined(__OpenBSD__)
	audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
#else
a412 1
#endif
@


1.8
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.7 2000/11/08 18:10:37 aaron Exp $ */
/*	$NetBSD: uaudio.c,v 1.29 2000/10/05 01:35:07 augustss Exp $	*/
d55 1
d386 2
a387 1
			printf("%s: alt %d missing AS interface(s)\n", USBDEVNAME(sc->sc_dev), j);
d392 1
a392 2
	printf("%s: audio rev %d.%02x\n",
	       USBDEVNAME(sc->sc_dev),
d400 11
a417 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d433 1
a433 1
		if (sc->sc_audiodev)
d540 1
a540 1
	return (0);
d1098 1
a1098 1
	/* We can't handle endpoints that need a sync pipe. */
@


1.7
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.6 2000/07/04 11:44:22 fgsch Exp $ */
d42 3
a44 3
 * USB audio specs: http://www.teleport.com/~usb/data/Audio10.pdf
 *                  http://www.teleport.com/~usb/data/Frmts10.pdf
 *                  http://www.teleport.com/~usb/data/Termt10.pdf
d99 2
d110 1
d121 1
a121 1
	int	dir;		/* direction, UE_DIR_XXX */
d135 2
a153 1
	int	sc_as_iface;	/* Audio Streaming interface */
a154 1
	usbd_interface_handle	sc_as_ifaceh;
d342 1
a342 1
	int i;
d366 11
a376 7
		if (uaa->ifaces[i] != NULL) {
			id = usbd_get_interface_descriptor(uaa->ifaces[i]);
			if (id != NULL &&
			    id->bInterfaceNumber == sc->sc_as_iface) {
				sc->sc_as_ifaceh = uaa->ifaces[i];
				uaa->ifaces[i] = NULL;
				break;
d379 2
d383 5
a387 3
	if (sc->sc_as_ifaceh == NULL) {
		printf("%s: missing AS interface(s)\n",USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
d390 2
a391 2
	printf("%s: streaming interface %d, audio rev %d.%02x\n",
	       USBDEVNAME(sc->sc_dev), sc->sc_as_iface,
d396 3
d537 2
d550 1
d561 8
d990 1
a990 1
	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_NO_XU)
d1085 4
d1091 1
a1091 1
		printf("%s: ignored %sput endpoint of type 0x%x\n",
d1094 1
a1094 1
		       ed->bmAttributes & UE_ISO_TYPE);
d1110 1
a1110 1
#ifdef AUDIO_DEBUG
d1147 1
a1147 1
	sc->sc_chan.dir = dir;
a1167 2
	sc->sc_as_iface = id->bInterfaceNumber;
	DPRINTF(("uaudio_identify_as: AS interface is %d\n", sc->sc_as_iface));
d1170 1
d1174 2
d1186 1
a1186 1
#ifdef AUDIO_DEBUG
d1205 4
d1373 1
d1391 1
a1391 1
	if ((flags & FREAD) && sc->sc_chan.dir != UE_DIR_IN)
d1393 1
a1393 1
	if ((flags & FWRITE) && sc->sc_chan.dir != UE_DIR_OUT)
d1601 2
a1602 2
		val = (uaudio_signext(mc->type, val) - mc->minval) * 256
			/ (mc->maxval - mc->minval);
d1615 1
a1615 1
		val = val * (mc->maxval - mc->minval) / 256 + mc->minval;
d1815 1
a1815 1
	err = usbd_set_interface(sc->sc_as_ifaceh, as->alt);
d1830 1
a1830 1
	err = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);
d1837 2
d1842 1
a1842 1
		usbd_set_interface(sc->sc_as_ifaceh, sc->sc_nullalt);
d1910 2
a1911 1
			size += ch->sample_size;
d2014 2
a2015 1
			size += ch->sample_size;
d2059 8
d2069 1
a2069 1
		printf("uaudio_chan_pintr: count(%d) != size(%d)\n",
d2093 1
a2093 1
		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n", 
d2128 1
a2128 1
		  struct audio_params *p, struct audio_params *r)
d2132 1
a2132 1
	int pfactor, rfactor;
d2134 3
a2136 2
	void (*pswcode)(void *, u_char *buf, int cnt);
	void (*rswcode)(void *, u_char *buf, int cnt);
d2144 25
a2168 43
        pswcode = rswcode = 0;
	pfactor = rfactor = 1;
	enc = p->encoding;
        switch (p->encoding) {
        case AUDIO_ENCODING_SLINEAR_BE:
        	if (p->precision == 16) {
                	rswcode = pswcode = swap_bytes;
			enc = AUDIO_ENCODING_SLINEAR_LE;
		} else if (p->precision == 8 && !(flags & HAS_8)) {
			pswcode = rswcode = change_sign8;
			enc = AUDIO_ENCODING_ULINEAR_LE;
		}
		break;
        case AUDIO_ENCODING_SLINEAR_LE:
        	if (p->precision == 8 && !(flags & HAS_8)) {
			pswcode = rswcode = change_sign8;
			enc = AUDIO_ENCODING_ULINEAR_LE;
		}
        	break;
        case AUDIO_ENCODING_ULINEAR_BE:
        	if (p->precision == 16) {
			pswcode = swap_bytes_change_sign16_le;
			rswcode = change_sign16_swap_bytes_le;
			enc = AUDIO_ENCODING_SLINEAR_LE;
		} else if (p->precision == 8 && !(flags & HAS_8U)) {
			pswcode = rswcode = change_sign8;
			enc = AUDIO_ENCODING_SLINEAR_LE;
		}
		break;
        case AUDIO_ENCODING_ULINEAR_LE:
        	if (p->precision == 16) {
			pswcode = rswcode = change_sign16_le;
			enc = AUDIO_ENCODING_SLINEAR_LE;
		} else if (p->precision == 8 && !(flags & HAS_8U)) {
			pswcode = rswcode = change_sign8;
			enc = AUDIO_ENCODING_SLINEAR_LE;
		}
        	break;
        case AUDIO_ENCODING_ULAW:
		if (!(flags & HAS_MULAW)) {
			if (flags & HAS_8U) {
				pswcode = mulaw_to_ulinear8;
				rswcode = ulinear8_to_mulaw;
d2170 8
a2177 3
			} else if (flags & HAS_8) {
				pswcode = mulaw_to_slinear8;
				rswcode = slinear8_to_mulaw;
d2179 2
a2180 3
			} else if (flags & HAS_16) {
				pswcode = mulaw_to_slinear16_le;
				pfactor = 2;
d2182 5
a2186 16
				/* XXX recording not handled */
				if (setmode & AUMODE_RECORD)
					return (EINVAL);
			} else
				return (EINVAL);
		}
                break;
        case AUDIO_ENCODING_ALAW:
		if (!(flags & HAS_ALAW)) {
			if (flags & HAS_8U) {
				pswcode = alaw_to_ulinear8;
				rswcode = ulinear8_to_alaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				pswcode = alaw_to_slinear8;
				rswcode = slinear8_to_alaw;
d2188 2
a2189 3
			} else if (flags & HAS_16) {
				pswcode = alaw_to_slinear16_le;
				pfactor = 2;
d2191 22
a2212 2
				/* XXX recording not handled */
				if (setmode & AUMODE_RECORD)
d2214 27
a2240 2
			} else
				return (EINVAL);
d2242 18
a2259 28
                break;
        default:
        	return (EINVAL);
        }
	/* XXX do some other conversions... */

	DPRINTF(("uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n",
		 p->channels, p->precision, enc, p->sample_rate));

	for (i = 0; i < sc->sc_nalts; i++) {
		struct usb_audio_streaming_type1_descriptor *a1d =
			sc->sc_alts[i].asf1desc;
		if (p->channels == a1d->bNrChannels &&
		    p->precision ==a1d->bBitResolution &&
		    enc == sc->sc_alts[i].encoding) {
			if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
				DPRINTFN(2,("uaudio_set_params: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
				if (UA_SAMP_LO(a1d) < p->sample_rate &&
				    p->sample_rate < UA_SAMP_HI(a1d))
					goto found;
			} else {
				for (j = 0; j < a1d->bSamFreqType; j++) {
					DPRINTFN(2,("uaudio_set_params: disc #"
					    "%d: %d\n", j, UA_GETSAMP(a1d, j)));
					/* XXX allow for some slack */
					if (UA_GETSAMP(a1d, j) ==
					    p->sample_rate)
d2261 9
d2273 7
a2280 8
	return (EINVAL);

 found:
        p->sw_code = pswcode;
        r->sw_code = rswcode;
	p->factor  = pfactor;
	r->factor  = rfactor;
	sc->sc_curaltidx = i;
d2286 1
a2286 1
        return (0);
@


1.6
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.5 2000/05/24 13:44:18 ho Exp $ */
/*	$NetBSD: uaudio.c,v 1.23 2000/03/29 18:24:53 augustss Exp $	*/
d115 1
a115 1
	void	(*intr) __P((void *));	/* dma completion intr handler */
d183 5
a187 5
Static usbd_status	uaudio_identify_ac __P((struct uaudio_softc *sc,
			    usb_config_descriptor_t *cdesc));
Static usbd_status	uaudio_identify_as __P((struct uaudio_softc *sc,
			    usb_config_descriptor_t *cdesc));
Static usbd_status	uaudio_process_as __P((struct uaudio_softc *sc,
d189 1
a189 1
			    usb_interface_descriptor_t *id));
d191 2
a192 2
Static void 		uaudio_add_alt __P((struct uaudio_softc *sc, 
			    struct as_info *ai));
d194 2
a195 2
Static usb_interface_descriptor_t *uaudio_find_iface 
	__P((char *buf, int size, int *offsp, int subtype));
d197 48
a244 50
Static void		uaudio_mixer_add_ctl __P((struct uaudio_softc *sc,
			    struct mixerctl *mp));
Static char 		*uaudio_id_name __P((struct uaudio_softc *sc,
			    usb_descriptor_t **dps, int id));
Static struct usb_audio_cluster uaudio_get_cluster __P((int id, 
			    usb_descriptor_t **dps));
Static void		uaudio_add_input __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void 		uaudio_add_output __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_mixer __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_selector __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_feature __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_processing_updown
			    __P((struct uaudio_softc *sc,
			         usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_processing __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static void		uaudio_add_extension __P((struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps));
Static usbd_status	uaudio_identify __P((struct uaudio_softc *sc, 
			    usb_config_descriptor_t *cdesc));

Static int 		uaudio_signext __P((int type, int val));
Static int 		uaudio_value2bsd __P((struct mixerctl *mc, int val));
Static int 		uaudio_bsd2value __P((struct mixerctl *mc, int val));
Static int 		uaudio_get __P((struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int len));
Static int		uaudio_ctl_get __P((struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan));
Static void		uaudio_set __P((struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int l, int v));
Static void 		uaudio_ctl_set __P((struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan, int val));

Static usbd_status	uaudio_set_speed __P((struct uaudio_softc *, int,
			    u_int));

Static usbd_status	uaudio_chan_open __P((struct uaudio_softc *sc,
			    struct chan *ch));
Static void		uaudio_chan_close __P((struct uaudio_softc *sc,
			    struct chan *ch));
Static usbd_status	uaudio_chan_alloc_buffers __P((struct uaudio_softc *,
			    struct chan *));
Static void		uaudio_chan_free_buffers __P((struct uaudio_softc *,
			    struct chan *));
Static void		uaudio_chan_set_param __P((struct chan *ch,
d246 29
a274 32
			    u_char *end, int blksize));
Static void		uaudio_chan_ptransfer __P((struct chan *ch));
Static void		uaudio_chan_pintr __P((usbd_xfer_handle xfer, 
			    usbd_private_handle priv, usbd_status status));

Static void		uaudio_chan_rtransfer __P((struct chan *ch));
Static void		uaudio_chan_rintr __P((usbd_xfer_handle xfer, 
			    usbd_private_handle priv, usbd_status status));



Static int		uaudio_open __P((void *, int));
Static void		uaudio_close __P((void *));
Static int		uaudio_drain __P((void *));
Static int		uaudio_query_encoding __P((void *,
			    struct audio_encoding *));
Static int		uaudio_set_params __P((void *, int, int, 
			    struct audio_params *, struct audio_params *));
Static int		uaudio_round_blocksize __P((void *, int));
Static int		uaudio_trigger_output __P((void *, void *, void *,
			    int, void (*)(void *), void *,
			    struct audio_params *));
Static int		uaudio_trigger_input  __P((void *, void *, void *,
			    int, void (*)(void *), void *,
			    struct audio_params *));
Static int		uaudio_halt_in_dma __P((void *));
Static int		uaudio_halt_out_dma __P((void *));
Static int		uaudio_getdev __P((void *, struct audio_device *));
Static int		uaudio_mixer_set_port __P((void *, mixer_ctrl_t *));
Static int		uaudio_mixer_get_port __P((void *, mixer_ctrl_t *));
Static int		uaudio_query_devinfo __P((void *, mixer_devinfo_t *));
Static int		uaudio_get_props __P((void *));
d386 3
a388 1

d390 1
d399 1
a399 3
uaudio_activate(self, act)
	device_ptr_t self;
	enum devact act;
d419 1
a419 3
uaudio_detach(self, flags)
	device_ptr_t self;
	int flags;
d437 1
a437 3
uaudio_query_encoding(addr, fp)
	void *addr;
	struct audio_encoding *fp;
d505 1
a505 5
uaudio_find_iface(buf, size, offsp, subtype)
	char *buf;
	int size;
	int *offsp;
	int subtype;
d521 1
a521 3
uaudio_mixer_add_ctl(sc, mc)
	struct uaudio_softc *sc;
	struct mixerctl *mc;
d523 1
a523 1
	if (sc->sc_nctls == NULL)
d566 1
a566 4
uaudio_id_name(sc, dps, id)
	struct uaudio_softc *sc;
	usb_descriptor_t **dps;
	int id;
d574 1
a574 3
uaudio_get_cluster(id, dps)
	int id;
	usb_descriptor_t **dps;
d638 2
a639 4
uaudio_add_input(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d655 2
a656 4
uaudio_add_output(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d670 2
a671 4
uaudio_add_mixer(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d734 2
a735 4
uaudio_add_selector(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d748 2
a749 4
uaudio_add_feature(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d872 2
a873 4
uaudio_add_processing_updown(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d910 2
a911 4
uaudio_add_processing(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d953 2
a954 4
uaudio_add_extension(sc, v, dps)
	struct uaudio_softc *sc;
	usb_descriptor_t *v;
	usb_descriptor_t **dps;
d965 3
d981 1
a981 3
uaudio_identify(sc, cdesc)
	struct uaudio_softc *sc;
	usb_config_descriptor_t *cdesc;
d992 1
a992 3
uaudio_add_alt(sc, ai)
	struct uaudio_softc *sc;
	struct as_info *ai;
d994 1
a994 1
	if (sc->sc_nalts == NULL)
d1010 2
a1011 4
uaudio_process_as(sc, buf, offsp, size, id)
	struct uaudio_softc *sc;
	char *buf;
	int *offsp;
a1012 2
	int size;
	usb_interface_descriptor_t *id;
d1124 1
a1124 3
uaudio_identify_as(sc, cdesc)
	struct uaudio_softc *sc;
	usb_config_descriptor_t *cdesc;
d1179 1
a1179 3
uaudio_identify_ac(sc, cdesc)
	struct uaudio_softc *sc;
	usb_config_descriptor_t *cdesc;
d1285 1
a1285 3
uaudio_query_devinfo(addr, mi)
	void *addr;
	mixer_devinfo_t *mi;
d1345 1
a1345 3
uaudio_open(addr, flags)
	void *addr;
	int flags;
d1370 1
a1370 2
uaudio_close(addr)
	void *addr;
d1382 1
a1382 2
uaudio_drain(addr)
	void *addr;
d1392 1
a1392 2
uaudio_halt_out_dma(addr)
	void *addr;
d1406 1
a1406 2
uaudio_halt_in_dma(addr)
	void *addr;
d1420 1
a1420 3
uaudio_getdev(addr, retp)
	void *addr;
        struct audio_device *retp;
d1436 1
a1436 3
uaudio_round_blocksize(addr, blk)
	void *addr;
	int blk;
d1462 1
a1462 2
uaudio_get_props(addr)
	void *addr;
d1470 2
a1471 3
uaudio_get(sc, which, type, wValue, wIndex, len)
	struct uaudio_softc *sc;
	int type, which, wValue, wIndex, len;
d1510 2
a1511 3
uaudio_set(sc, which, type, wValue, wIndex, len, val)
	struct uaudio_softc *sc;
	int type, which, wValue, wIndex, len, val;
d1547 1
a1547 2
uaudio_signext(type, val)
	int type, val;
d1559 1
a1559 3
uaudio_value2bsd(mc, val)
	struct mixerctl *mc;
	int val;
d1573 1
a1573 3
uaudio_bsd2value(mc, val)
	struct mixerctl *mc;
	int val;
d1586 2
a1587 5
uaudio_ctl_get(sc, which, mc, chan)
	struct uaudio_softc *sc;
	int which;
	struct mixerctl *mc;
	int chan;
d1598 2
a1599 6
uaudio_ctl_set(sc, which, mc, chan, val)
	struct uaudio_softc *sc;
	int which;
	struct mixerctl *mc;
	int chan;
	int val;
d1607 1
a1607 3
uaudio_mixer_get_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1648 1
a1648 3
uaudio_mixer_set_port(addr, cp)
	void *addr;
	mixer_ctrl_t *cp;
d1685 3
a1687 7
uaudio_trigger_input(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr) __P((void *));
	void *arg;
	struct audio_params *param;
d1727 3
a1729 7
uaudio_trigger_output(addr, start, end, blksize, intr, arg, param)
	void *addr;
	void *start, *end;
	int blksize;
	void (*intr) __P((void *));
	void *arg;
	struct audio_params *param;
d1770 1
a1770 3
uaudio_chan_open(sc, ch)
	struct uaudio_softc *sc;
	struct chan *ch;
d1800 1
a1800 3
uaudio_chan_close(sc, ch)
	struct uaudio_softc *sc;
	struct chan *ch;
d1812 1
a1812 3
uaudio_chan_alloc_buffers(sc, ch)
	struct uaudio_softc *sc;
	struct chan *ch;
d1843 1
a1843 3
uaudio_chan_free_buffers(sc, ch)
	struct uaudio_softc *sc;
	struct chan *ch;
d1853 1
a1853 2
uaudio_chan_ptransfer(ch)
	struct chan *ch;
d1917 2
a1918 4
uaudio_chan_pintr(xfer, priv, status)
	usbd_xfer_handle xfer;
	usbd_private_handle priv;
	usbd_status status;
d1956 1
a1956 2
uaudio_chan_rtransfer(ch)
	struct chan *ch;
d2005 2
a2006 4
uaudio_chan_rintr(xfer, priv, status)
	usbd_xfer_handle xfer;
	usbd_private_handle priv;
	usbd_status status;
d2057 2
a2058 5
uaudio_chan_set_param(ch, param, start, end, blksize)
	struct chan *ch;
	struct audio_params *param;
	u_char *start, *end;
	int blksize;
d2080 2
a2081 4
uaudio_set_params(addr, setmode, usemode, p, r)
	void *addr;
	int setmode, usemode;
	struct audio_params *p, *r;
d2087 2
a2088 2
	void (*pswcode) __P((void *, u_char *buf, int cnt));
	void (*rswcode) __P((void *, u_char *buf, int cnt));
a2143 1
#if 0
d2147 1
d2149 2
a2150 2
				enc = AUDIO_ENCODING_SLINEAR_LE;
#endif
a2164 1
#if 0
d2168 1
d2170 2
a2171 2
				enc = AUDIO_ENCODING_SLINEAR_LE;
#endif
d2225 1
a2225 4
uaudio_set_speed(sc, endpt, speed)
	struct uaudio_softc *sc;
	int endpt;
	u_int speed;
@


1.5
log
@Permit detach of audio devices, such as uaudio. Selected code
from NetBSD/Lennart Augustsson. (niklas@@ ok)
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.4 2000/03/30 16:19:33 aaron Exp $ */
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.4
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.3 2000/03/28 19:37:49 aaron Exp $ */
d391 1
a391 3
#if defined(__OpenBSD__)
	audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
#else
a392 1
#endif
@


1.3
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uaudio.c,v 1.20 2000/03/24 13:02:00 augustss Exp $	*/
d82 1
a82 1
#define UAUDIO_NCHANBUFS 5	/* number of outstanding request */
d183 1
a183 1
static usbd_status	uaudio_identify_ac __P((struct uaudio_softc *sc,
d185 1
a185 1
static usbd_status	uaudio_identify_as __P((struct uaudio_softc *sc,
d187 1
a187 1
static usbd_status	uaudio_process_as __P((struct uaudio_softc *sc,
d191 1
a191 1
static void 		uaudio_add_alt __P((struct uaudio_softc *sc, 
d194 1
a194 1
static usb_interface_descriptor_t *uaudio_find_iface 
d197 1
a197 1
static void		uaudio_mixer_add_ctl __P((struct uaudio_softc *sc,
d199 1
a199 1
static char 		*uaudio_id_name __P((struct uaudio_softc *sc,
d201 1
a201 1
static struct usb_audio_cluster uaudio_get_cluster __P((int id, 
d203 1
a203 1
static void		uaudio_add_input __P((struct uaudio_softc *sc,
d205 1
a205 1
static void 		uaudio_add_output __P((struct uaudio_softc *sc,
d207 1
a207 1
static void		uaudio_add_mixer __P((struct uaudio_softc *sc,
d209 1
a209 1
static void		uaudio_add_selector __P((struct uaudio_softc *sc,
d211 1
a211 1
static void		uaudio_add_feature __P((struct uaudio_softc *sc,
d213 1
a213 1
static void		uaudio_add_processing_updown
d216 1
a216 1
static void		uaudio_add_processing __P((struct uaudio_softc *sc,
d218 1
a218 1
static void		uaudio_add_extension __P((struct uaudio_softc *sc,
d220 1
a220 1
static usbd_status	uaudio_identify __P((struct uaudio_softc *sc, 
d223 4
a226 4
static int 		uaudio_signext __P((int type, int val));
static int 		uaudio_value2bsd __P((struct mixerctl *mc, int val));
static int 		uaudio_bsd2value __P((struct mixerctl *mc, int val));
static int 		uaudio_get __P((struct uaudio_softc *sc, int type,
d228 1
a228 1
static int		uaudio_ctl_get __P((struct uaudio_softc *sc, int which,
d230 1
a230 1
static void		uaudio_set __P((struct uaudio_softc *sc, int type,
d232 1
a232 1
static void 		uaudio_ctl_set __P((struct uaudio_softc *sc, int which,
d235 1
a235 1
static usbd_status	uaudio_set_speed __P((struct uaudio_softc *, int,
d238 1
a238 1
static usbd_status	uaudio_chan_open __P((struct uaudio_softc *sc,
d240 1
a240 1
static void		uaudio_chan_close __P((struct uaudio_softc *sc,
d242 1
a242 1
static usbd_status	uaudio_chan_alloc_buffers __P((struct uaudio_softc *,
d244 1
a244 1
static void		uaudio_chan_free_buffers __P((struct uaudio_softc *,
d246 1
a246 1
static void		uaudio_chan_set_param __P((struct chan *ch,
d249 2
a250 2
static void		uaudio_chan_ptransfer __P((struct chan *ch));
static void		uaudio_chan_pintr __P((usbd_xfer_handle xfer, 
d253 2
a254 2
static void		uaudio_chan_rtransfer __P((struct chan *ch));
static void		uaudio_chan_rintr __P((usbd_xfer_handle xfer, 
d259 4
a262 4
static int		uaudio_open __P((void *, int));
static void		uaudio_close __P((void *));
static int		uaudio_drain __P((void *));
static int		uaudio_query_encoding __P((void *,
d264 1
a264 1
static int		uaudio_set_params __P((void *, int, int, 
d266 2
a267 2
static int		uaudio_round_blocksize __P((void *, int));
static int		uaudio_trigger_output __P((void *, void *, void *,
d270 1
a270 1
static int		uaudio_trigger_input  __P((void *, void *, void *,
d273 7
a279 7
static int		uaudio_halt_in_dma __P((void *));
static int		uaudio_halt_out_dma __P((void *));
static int		uaudio_getdev __P((void *, struct audio_device *));
static int		uaudio_mixer_set_port __P((void *, mixer_ctrl_t *));
static int		uaudio_mixer_get_port __P((void *, mixer_ctrl_t *));
static int		uaudio_query_devinfo __P((void *, mixer_devinfo_t *));
static int		uaudio_get_props __P((void *));
d281 1
a281 1
static struct audio_hw_if uaudio_hw_if = {
d310 1
a310 1
static struct audio_device uaudio_device = {
d1801 1
a1801 1
	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
d1847 1
a1847 1
	for (i = 0; i < UAUDIO_NCHANBUFS; i++)
@


1.2
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.1 1999/11/11 15:54:59 ho Exp $	*/
d74 2
a75 2
#define DPRINTF(x)	if (uaudiodebug) printf x
#define DPRINTFN(n,x)	if (uaudiodebug>(n)) printf x
d183 7
a189 7
usbd_status uaudio_identify_ac __P((struct uaudio_softc *sc,
				    usb_config_descriptor_t *cdesc));
usbd_status uaudio_identify_as __P((struct uaudio_softc *sc,
				    usb_config_descriptor_t *cdesc));
usbd_status uaudio_process_as __P((struct uaudio_softc *sc, char *buf,
				   int *offsp, int size,
				   usb_interface_descriptor_t *id));
d191 2
a192 1
void uaudio_add_alt __P((struct uaudio_softc *sc, struct as_info *ai));
d194 1
a194 1
usb_interface_descriptor_t *uaudio_find_iface 
d197 5
a201 8
void uaudio_mixer_add_ctl __P((struct uaudio_softc *sc, struct mixerctl *mp));
char *uaudio_id_name __P((struct uaudio_softc *sc, usb_descriptor_t **dps, 
			  int id));
struct usb_audio_cluster uaudio_get_cluster __P((int id, 
						 usb_descriptor_t **dps));
void uaudio_add_input __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
			   usb_descriptor_t **dps));
void uaudio_add_output __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
d203 77
a279 66
void uaudio_add_mixer __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
			   usb_descriptor_t **dps));
void uaudio_add_selector __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
			      usb_descriptor_t **dps));
void uaudio_add_feature __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
			     usb_descriptor_t **dps));
void uaudio_add_processing_updown __P((struct uaudio_softc *sc,
				       usb_descriptor_t *v,
				       usb_descriptor_t **dps));
void uaudio_add_processing __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
				usb_descriptor_t **dps));
void uaudio_add_extension __P((struct uaudio_softc *sc, usb_descriptor_t *v, 
			       usb_descriptor_t **dps));
usbd_status uaudio_identify __P((struct uaudio_softc *sc, 
				 usb_config_descriptor_t *cdesc));

int uaudio_signext __P((int type, int val));
int uaudio_value2bsd __P((struct mixerctl *mc, int val));
int uaudio_bsd2value __P((struct mixerctl *mc, int val));
int uaudio_get __P((struct uaudio_softc *sc, int type, int which, int wValue, 
		    int wIndex, int len));
int uaudio_ctl_get __P((struct uaudio_softc *sc, int which, 
			struct mixerctl *mc, int chan));
void uaudio_set __P((struct uaudio_softc *sc, int type, int which, int wValue, 
		    int wIndex, int len, int val));
void uaudio_ctl_set __P((struct uaudio_softc *sc, int which, 
			 struct mixerctl *mc, int chan, int val));

usbd_status	uaudio_set_speed __P((struct uaudio_softc *, int, u_int));

usbd_status uaudio_chan_open __P((struct uaudio_softc *sc, struct chan *ch));
void	uaudio_chan_close __P((struct uaudio_softc *sc, struct chan *ch));
usbd_status uaudio_chan_alloc_buffers __P((struct uaudio_softc *, struct chan *));
void	uaudio_chan_free_buffers __P((struct uaudio_softc *, struct chan *));
void	uaudio_chan_set_param __P((struct chan *ch, struct audio_params *param,
				   u_char *start, u_char *end, int blksize));
void	uaudio_chan_ptransfer __P((struct chan *ch));
void	uaudio_chan_pintr __P((usbd_xfer_handle xfer, 
			       usbd_private_handle priv, usbd_status status));

void	uaudio_chan_rtransfer __P((struct chan *ch));
void	uaudio_chan_rintr __P((usbd_xfer_handle xfer, 
			       usbd_private_handle priv, usbd_status status));



int	uaudio_open __P((void *, int));
void	uaudio_close __P((void *));
int	uaudio_drain __P((void *));
int	uaudio_query_encoding __P((void *, struct audio_encoding *));
int	uaudio_set_params __P((void *, int, int, 
			       struct audio_params *, struct audio_params *));
int	uaudio_round_blocksize __P((void *, int));
int	uaudio_trigger_output __P((void *, void *, void *, int, 
				   void (*)(void *), void *,
				   struct audio_params *));
int	uaudio_trigger_input  __P((void *, void *, void *, int, 
				   void (*)(void *), void *,
				   struct audio_params *));
int	uaudio_halt_in_dma __P((void *));
int	uaudio_halt_out_dma __P((void *));
int	uaudio_getdev __P((void *, struct audio_device *));
int	uaudio_mixer_set_port __P((void *, mixer_ctrl_t *));
int	uaudio_mixer_get_port __P((void *, mixer_ctrl_t *));
int	uaudio_query_devinfo __P((void *, mixer_devinfo_t *));
int	uaudio_get_props __P((void *));
d281 1
a281 1
struct audio_hw_if uaudio_hw_if = {
d310 1
a310 1
struct audio_device uaudio_device = {
d391 5
a395 1
	/* sc->sc_audiodev = */ audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
a542 11
#ifdef __OpenBSD__
	{
		void *p;

		p = malloc((sc->sc_nctls+1) * sizeof *mc, M_USBDEV, M_NOWAIT);
		if (p != NULL)
			bcopy(sc->sc_ctls, p, sc->sc_nctls * sizeof *mc);
		free(sc->sc_ctls, M_USBDEV);
		sc->sc_ctls = p;
	}
#else
a545 1
#endif
d915 1
a915 1
	        &d1->bmControls[d1->bControlSize];
d931 1
a931 1
	mix.type = MIX_ON_OFF; /* XXX */
d970 1
a970 1
	switch (ptype) {
a1035 11
#ifdef __OpenBSD__
	{
		void *p;

		p = malloc((sc->sc_nalts+1) * sizeof *ai, M_USBDEV, M_NOWAIT);
		if (p != NULL)
			bcopy(sc->sc_alts, p, sc->sc_nalts * sizeof *ai);
		free(sc->sc_alts, M_USBDEV);
		sc->sc_alts = p;
	}
#else
d1039 1
a1039 2
#endif
	if (sc->sc_alts == 0) {
d1209 1
a1209 1
		if (!id)
d1604 1
a1604 1
		DPRINTF(("uaudio_set: r=%d\n", r));
d1876 1
a1876 1
		DPRINTF(("uaudio_chan_open: set_speed failed r=%s\n",
d2004 3
a2006 3
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
				UAUDIO_NFRAMES, USBD_NO_COPY, 
				uaudio_chan_pintr);
d2026 1
a2026 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, 0);
d2096 2
a2097 2
				UAUDIO_NFRAMES, USBD_NO_COPY, 
				uaudio_chan_rintr);
d2117 1
a2117 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, 0);
d2222 2
a2223 2
			pswcode = swap_bytes_change_sign16;
			rswcode = change_sign16_swap_bytes;
d2232 1
a2232 1
			pswcode = rswcode = change_sign16;
d2318 2
a2319 2
	p->factor = pfactor;
	r->factor = rfactor;
@


1.1
log
@USB Audio, from NetBSD (augustss@@carlstedt.se). Imported by me and niklas@@.
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.5 1999/10/25 10:16:49 augustss Exp $	*/
/*	$NetBSD: uaudio.c,v 1.5 1999/10/25 10:16:49 augustss Exp $	*/
d135 1
a135 1
		usbd_request_handle reqh;
d140 2
d159 2
d211 3
d242 1
a242 1
void	uaudio_chan_pintr __P((usbd_request_handle reqh, 
d246 1
a246 1
void	uaudio_chan_rintr __P((usbd_request_handle reqh, 
d314 1
a314 1
	if (!uaa->iface)
d319 4
a322 3
	if (!id || 
	    id->bInterfaceClass != UCLASS_AUDIO ||
	    id->bInterfaceSubClass != USUBCLASS_AUDIOCONTROL)
d334 1
a334 1
	usbd_status r;
d343 3
a345 1
	if (!cdesc)
d347 1
d349 2
a350 2
	r = uaudio_identify(sc, cdesc);
	if (r != USBD_NORMAL_COMPLETION) {
d352 1
a352 1
		       USBDEVNAME(sc->sc_dev), r);
d359 1
a359 1
		if (uaa->ifaces[i]) {
d361 2
a362 1
			if (id->bInterfaceNumber == sc->sc_as_iface) {
d364 2
a365 1
				uaa->ifaces[i] = 0;
d370 1
a370 1
	if (!sc->sc_as_ifaceh) {
d375 6
d384 3
d420 4
a423 1
	if (sc->sc_audiodev)
d426 3
d515 1
a515 1
		    d->bInterfaceClass == UCLASS_AUDIO &&
d527 1
a527 1
	if (sc->sc_nctls == 0)
d545 1
a545 1
	if (sc->sc_ctls == 0) {
d654 1
a654 1
	return r;
a674 1
	printf("uaudio_add_input: not implemented\n");
d867 1
a867 1
			continue; /* don't add anything */
d903 40
a947 1
#ifdef UAUDIO_DEBUG
d949 8
a956 1
		(struct usb_audio_processing_unit *)v;
d958 24
a981 3
	DPRINTFN(2,("uaudio_add_processing: bUnitId=%d bNrInPins=%d\n",
		    d->bUnitId, d->bNrInPins));
	printf("uaudio_add_processing: NOT IMPLEMENTED\n");
d983 2
d1002 1
a1002 1
	if (d1->bmControls[0] & (1 << UA_EXT_ENABLE)) {
d1019 1
a1019 1
	usbd_status r;
d1021 3
a1023 3
	r = uaudio_identify_ac(sc, cdesc);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1032 1
a1032 1
	if (sc->sc_nalts == 0)
d1183 1
a1183 1
	usbd_status r;
d1192 2
a1193 2
	id = uaudio_find_iface(buf, size, &offs, USUBCLASS_AUDIOSTREAM);
	if (!id)
d1209 1
a1209 1
			r = uaudio_process_as(sc, buf, &offs, size, id);
d1219 1
a1219 1
		id = uaudio_find_iface(buf, size, &offs,USUBCLASS_AUDIOSTREAM);
d1250 2
a1251 2
	id = uaudio_find_iface(buf, size, &offs, USUBCLASS_AUDIOCONTROL);
	if (!id)
d1272 1
d1274 1
a1274 1
		 UGETW(acdp->bcdADC), aclen));
d1304 1
a1304 1
		if (dp == 0)
d1462 1
a1462 1
	if (sc->sc_chan.pipe) {
d1477 1
a1477 1
	if (sc->sc_chan.pipe) {
a1536 3
	if (sc->sc_dying)
		return (EIO);
    
d1547 1
a1547 1
	usbd_status r;
d1561 3
a1563 3
	r = usbd_do_request(sc->sc_udev, &req, &data);
	if (r != USBD_NORMAL_COMPLETION) {
		DPRINTF(("uaudio_get: r=%d\n", r));
d1588 1
a1588 1
	usbd_status r;
d1612 1
a1612 1
	r = usbd_do_request(sc->sc_udev, &req, &data);
d1614 1
a1614 1
	if (r != USBD_NORMAL_COMPLETION)
d1784 1
a1784 1
	usbd_status r;
d1798 2
a1799 2
	r = uaudio_chan_alloc_buffers(sc, ch);
	if (r != USBD_NORMAL_COMPLETION)
d1802 2
a1803 2
	r = uaudio_chan_open(sc, ch);
	if (r != USBD_NORMAL_COMPLETION) {
d1830 1
a1830 1
	usbd_status r;
d1844 2
a1845 2
	r = uaudio_chan_alloc_buffers(sc, ch);
	if (r != USBD_NORMAL_COMPLETION)
d1848 2
a1849 2
	r = uaudio_chan_open(sc, ch);
	if (r != USBD_NORMAL_COMPLETION) {
d1873 1
a1873 1
	usbd_status r;
d1879 3
a1881 3
	r = usbd_set_interface(sc->sc_as_ifaceh, as->alt);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d1885 2
a1886 2
	r = uaudio_set_speed(sc, endpt, ch->sample_rate);
	if (r != USBD_NORMAL_COMPLETION)
d1888 1
a1888 1
			 usbd_errstr(r)));
d1894 2
a1895 2
	r = usbd_open_pipe(sc->sc_as_ifaceh, endpt, 0, &ch->pipe);
	return (r);
d1917 1
a1917 1
	usbd_request_handle reqh;
d1923 2
a1924 2
		reqh = usbd_alloc_request(sc->sc_udev);
		if (reqh == 0)
d1926 2
a1927 2
		ch->chanbufs[i].reqh = reqh;
		buf = usbd_alloc_buffer(reqh, size);
d1941 1
a1941 1
		usbd_free_request(ch->chanbufs[i].reqh);
d1953 1
a1953 1
		usbd_free_request(ch->chanbufs[i].reqh);
d1964 3
d2013 1
a2013 1
	DPRINTFN(5,("uaudio_chan_transfer: ptransfer reqh=%p\n", cb->reqh));
d2015 1
a2015 1
	usbd_setup_isoc_request(cb->reqh, ch->pipe, cb, cb->sizes, 
d2019 1
a2019 1
	(void)usbd_transfer(cb->reqh);
d2023 2
a2024 2
uaudio_chan_pintr(reqh, priv, status)
	usbd_request_handle reqh;
d2037 1
a2037 1
	usbd_get_request_status(reqh, 0, 0, &count, 0);
d2070 3
d2104 1
a2104 1
	DPRINTFN(5,("uaudio_chan_rtransfer: transfer reqh=%p\n", cb->reqh));
d2106 1
a2106 1
	usbd_setup_isoc_request(cb->reqh, ch->pipe, cb, cb->sizes, 
d2110 1
a2110 1
	(void)usbd_transfer(cb->reqh);
d2114 2
a2115 2
uaudio_chan_rintr(reqh, priv, status)
	usbd_request_handle reqh;
d2128 1
a2128 1
	usbd_get_request_status(reqh, 0, 0, &count, 0);
d2201 1
d2209 1
a2209 1
	if (sc->sc_chan.pipe)
d2213 1
d2260 7
d2281 7
d2307 2
d2314 2
d2329 2
@


1.1.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD: uaudio.c,v 1.8 2001/01/28 09:43:41 aaron Exp $ */
/*	$NetBSD: uaudio.c,v 1.29 2000/10/05 01:35:07 augustss Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d42 3
a44 3
 * USB audio specs: http://www.usb.org/developers/data/devclass/audio10.pdf
 *                  http://www.usb.org/developers/data/devclass/frmts10.pdf
 *                  http://www.usb.org/developers/data/devclass/termt10.pdf
d74 2
a75 2
#define DPRINTF(x)	if (uaudiodebug) logprintf x
#define DPRINTFN(n,x)	if (uaudiodebug>(n)) logprintf x
d82 1
a82 1
#define UAUDIO_NCHANBUFS 6	/* number of outstanding request */
a98 2
	u_int		delta;
	u_int		mul;
a107 1
	usbd_interface_handle	ifaceh;
d115 1
a115 1
	void	(*intr)(void *);	/* dma completion intr handler */
d118 1
a118 1
	int	dir;		/* direction */
a131 2
	char	nofrac;		/* don't do sample rate adjustment */

d135 1
a135 1
		usbd_xfer_handle xfer;
a139 2

	struct uaudio_softc *sc; /* our softc */
d147 1
d149 1
a156 2
	int	sc_audio_rev;

d179 85
a263 92
Static usbd_status	uaudio_identify_ac(struct uaudio_softc *sc,
					   usb_config_descriptor_t *cdesc);
Static usbd_status	uaudio_identify_as(struct uaudio_softc *sc,
					   usb_config_descriptor_t *cdesc);
Static usbd_status	uaudio_process_as(struct uaudio_softc *sc,
			    char *buf, int *offsp, int size,
			    usb_interface_descriptor_t *id);

Static void 		uaudio_add_alt(struct uaudio_softc *sc, 
				       struct as_info *ai);

Static usb_interface_descriptor_t *uaudio_find_iface(char *buf,
			    int size, int *offsp, int subtype);

Static void		uaudio_mixer_add_ctl(struct uaudio_softc *sc,
					     struct mixerctl *mp);
Static char 		*uaudio_id_name(struct uaudio_softc *sc,
					usb_descriptor_t **dps, int id);
Static struct usb_audio_cluster uaudio_get_cluster(int id,
						   usb_descriptor_t **dps);
Static void		uaudio_add_input(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void 		uaudio_add_output(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_mixer(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_selector(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_feature(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_processing_updown(struct uaudio_softc *sc,
			         usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_processing(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static void		uaudio_add_extension(struct uaudio_softc *sc,
			    usb_descriptor_t *v, usb_descriptor_t **dps);
Static usbd_status	uaudio_identify(struct uaudio_softc *sc, 
			    usb_config_descriptor_t *cdesc);

Static int 		uaudio_signext(int type, int val);
Static int 		uaudio_value2bsd(struct mixerctl *mc, int val);
Static int 		uaudio_bsd2value(struct mixerctl *mc, int val);
Static int 		uaudio_get(struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int len);
Static int		uaudio_ctl_get(struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan);
Static void		uaudio_set(struct uaudio_softc *sc, int type,
			    int which, int wValue, int wIndex, int l, int v);
Static void 		uaudio_ctl_set(struct uaudio_softc *sc, int which,
			    struct mixerctl *mc, int chan, int val);

Static usbd_status	uaudio_set_speed(struct uaudio_softc *, int, u_int);

Static usbd_status	uaudio_chan_open(struct uaudio_softc *sc,
					 struct chan *ch);
Static void		uaudio_chan_close(struct uaudio_softc *sc,
					  struct chan *ch);
Static usbd_status	uaudio_chan_alloc_buffers(struct uaudio_softc *,
						  struct chan *);
Static void		uaudio_chan_free_buffers(struct uaudio_softc *,
						 struct chan *);
Static void		uaudio_chan_set_param(struct chan *ch,
			    struct audio_params *param, u_char *start, 
			    u_char *end, int blksize);
Static void		uaudio_chan_ptransfer(struct chan *ch);
Static void		uaudio_chan_pintr(usbd_xfer_handle xfer, 
			    usbd_private_handle priv, usbd_status status);

Static void		uaudio_chan_rtransfer(struct chan *ch);
Static void		uaudio_chan_rintr(usbd_xfer_handle xfer, 
			    usbd_private_handle priv, usbd_status status);

Static int		uaudio_open(void *, int);
Static void		uaudio_close(void *);
Static int		uaudio_drain(void *);
Static int		uaudio_query_encoding(void *, struct audio_encoding *);
Static int		uaudio_set_params(void *, int, int, 
			    struct audio_params *, struct audio_params *);
Static int		uaudio_round_blocksize(void *, int);
Static int		uaudio_trigger_output(void *, void *, void *,
					      int, void (*)(void *), void *,
					      struct audio_params *);
Static int		uaudio_trigger_input (void *, void *, void *,
					      int, void (*)(void *), void *,
					      struct audio_params *);
Static int		uaudio_halt_in_dma(void *);
Static int		uaudio_halt_out_dma(void *);
Static int		uaudio_getdev(void *, struct audio_device *);
Static int		uaudio_mixer_set_port(void *, mixer_ctrl_t *);
Static int		uaudio_mixer_get_port(void *, mixer_ctrl_t *);
Static int		uaudio_query_devinfo(void *, mixer_devinfo_t *);
Static int		uaudio_get_props(void *);
d265 1
a265 1
Static struct audio_hw_if uaudio_hw_if = {
d294 1
a294 1
Static struct audio_device uaudio_device = {
d307 1
a307 1
	if (uaa->iface == NULL)
d312 3
a314 4
	if (id == NULL || 
	    id->bInterfaceClass != UICLASS_AUDIO ||
	    id->bInterfaceSubClass != UISUBCLASS_AUDIOCONTROL ||
	    (usbd_get_quirks(uaa->device)->uq_flags & UQ_BAD_AUDIO))
d326 2
a327 2
	usbd_status err;
	int i, j, found;
d335 1
a335 3
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		       USBDEVNAME(sc->sc_dev));
a336 1
	}
d338 2
a339 2
	err = uaudio_identify(sc, cdesc);
	if (err) {
d341 1
a341 1
		       USBDEVNAME(sc->sc_dev), err);
d348 5
a352 11
		if (uaa->ifaces[i] == NULL)
			continue;
		id = usbd_get_interface_descriptor(uaa->ifaces[i]);
		if (id == NULL)
			continue;
		found = 0;
		for (j = 0; j < sc->sc_nalts; j++) {
			if (id->bInterfaceNumber ==
			    sc->sc_alts[j].idesc->bInterfaceNumber) {
				sc->sc_alts[j].ifaceh = uaa->ifaces[i];
				found = 1;
a354 2
		if (found)
			uaa->ifaces[i] = NULL;
d357 3
a359 5
	for (j = 0; j < sc->sc_nalts; j++) {
		if (sc->sc_alts[j].ifaceh == NULL) {
			printf("%s: alt %d missing AS interface(s)\n", USBDEVNAME(sc->sc_dev), j);
			USB_ATTACH_ERROR_RETURN;
		}
a361 9
	printf("%s: audio rev %d.%02x\n",
	       USBDEVNAME(sc->sc_dev),
	       sc->sc_audio_rev >> 8, sc->sc_audio_rev & 0xff);

	sc->sc_chan.sc = sc;

	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_FRAC)
		sc->sc_chan.nofrac = 1;

d363 1
a363 8
#if defined(__OpenBSD__)
	audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
#else
	sc->sc_audiodev = audio_attach_mi(&uaudio_hw_if, sc, &sc->sc_dev);
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d369 3
a371 1
uaudio_activate(device_ptr_t self, enum devact act)
d391 3
a393 1
uaudio_detach(device_ptr_t self, int flags)
d398 1
a398 4
	/* Wait for outstanding requests to complete. */
	usbd_delay_ms(sc->sc_udev, UAUDIO_NCHANBUFS * UAUDIO_NFRAMES);

	if (sc->sc_audiodev != NULL)
a400 3
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d405 3
a407 1
uaudio_query_encoding(void *addr, struct audio_encoding *fp)
d475 5
a479 1
uaudio_find_iface(char *buf, int size, int *offsp, int subtype)
d487 1
a487 1
		    d->bInterfaceClass == UICLASS_AUDIO &&
d495 3
a497 1
uaudio_mixer_add_ctl(struct uaudio_softc *sc, struct mixerctl *mc)
a498 2
	int res;

d502 11
d516 2
a517 1
	if (sc->sc_ctls == NULL) {
a521 1
	mc->delta = 0;
a531 8
		mc->mul = mc->maxval - mc->minval;
		if (mc->mul == 0)
			mc->mul = 1;
		res = uaudio_get(sc, GET_RES, UT_READ_CLASS_INTERFACE,
				 mc->wValue[0], mc->wIndex,
				 MIX_SIZE(mc->type));
		if (res > 0)
			mc->delta = (res * 256 + mc->mul/2) / mc->mul;
d554 4
a557 1
uaudio_id_name(struct uaudio_softc *sc, usb_descriptor_t **dps, int id)
d565 3
a567 1
uaudio_get_cluster(int id, usb_descriptor_t **dps)
d626 1
a626 1
	return (r);
d631 4
a634 2
uaudio_add_input(struct uaudio_softc *sc, usb_descriptor_t *v, 
		 usb_descriptor_t **dps)
d647 1
d651 4
a654 2
uaudio_add_output(struct uaudio_softc *sc, usb_descriptor_t *v,
		  usb_descriptor_t **dps)
d668 4
a671 2
uaudio_add_mixer(struct uaudio_softc *sc, usb_descriptor_t *v,
		 usb_descriptor_t **dps)
d734 4
a737 2
uaudio_add_selector(struct uaudio_softc *sc, usb_descriptor_t *v,
		    usb_descriptor_t **dps)
d750 4
a753 2
uaudio_add_feature(struct uaudio_softc *sc, usb_descriptor_t *v,
		   usb_descriptor_t **dps)
d840 1
a840 1
			continue; /* XXX don't add anything */
d876 4
a879 2
uaudio_add_processing_updown(struct uaudio_softc *sc, usb_descriptor_t *v,
			     usb_descriptor_t **dps)
d881 1
d883 1
a883 8
	    (struct usb_audio_processing_unit *)v;
	struct usb_audio_processing_unit_1 *d1 =
	    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
	struct usb_audio_processing_unit_updown *ud =
	    (struct usb_audio_processing_unit_updown *)
		&d1->bmControls[d1->bControlSize];
	struct mixerctl mix;
	int i;
d885 3
a887 62
	DPRINTFN(2,("uaudio_add_processing_updown: bUnitId=%d bNrModes=%d\n",
		    d->bUnitId, ud->bNrModes));

	if (!(d1->bmControls[0] & UA_PROC_MASK(UD_MODE_SELECT_CONTROL))) {
		DPRINTF(("uaudio_add_processing_updown: no mode select\n"));
		return;
	}

	mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
	mix.nchan = 1;
	mix.wValue[0] = MAKE(UD_MODE_SELECT_CONTROL, 0);
	mix.class = -1;
	mix.type = MIX_ON_OFF;	/* XXX */
	mix.ctlunit = "";
	sprintf(mix.ctlname, "pro%d-mode", d->bUnitId);

	for (i = 0; i < ud->bNrModes; i++) {
		DPRINTFN(2,("uaudio_add_processing_updown: i=%d bm=0x%x\n",
			    i, UGETW(ud->waModes[i])));
		/* XXX */
	}
	uaudio_mixer_add_ctl(sc, &mix);
}

void
uaudio_add_processing(struct uaudio_softc *sc, usb_descriptor_t *v,
		      usb_descriptor_t **dps)
{
	struct usb_audio_processing_unit *d = 
	    (struct usb_audio_processing_unit *)v;
	struct usb_audio_processing_unit_1 *d1 =
	    (struct usb_audio_processing_unit_1 *)&d->baSourceId[d->bNrInPins];
	int ptype = UGETW(d->wProcessType);
	struct mixerctl mix;

	DPRINTFN(2,("uaudio_add_processing: wProcessType=%d bUnitId=%d "
		    "bNrInPins=%d\n", ptype, d->bUnitId, d->bNrInPins));

	if (d1->bmControls[0] & UA_PROC_ENABLE_MASK) {
		mix.wIndex = MAKE(d->bUnitId, sc->sc_ac_iface);
		mix.nchan = 1;
		mix.wValue[0] = MAKE(XX_ENABLE_CONTROL, 0);
		mix.class = -1;
		mix.type = MIX_ON_OFF;
		mix.ctlunit = "";
		sprintf(mix.ctlname, "pro%d.%d-enable", d->bUnitId, ptype);
		uaudio_mixer_add_ctl(sc, &mix);
	}

	switch(ptype) {
	case UPDOWNMIX_PROCESS:
		uaudio_add_processing_updown(sc, v, dps);
		break;
	case DOLBY_PROLOGIC_PROCESS:
	case P3D_STEREO_EXTENDER_PROCESS:
	case REVERBATION_PROCESS:
	case CHORUS_PROCESS:
	case DYN_RANGE_COMP_PROCESS:
	default:
#ifdef UAUDIO_DEBUG
		printf("uaudio_add_processing: unit %d, type=%d not impl.\n",
		       d->bUnitId, ptype);
a888 2
		break;
	}
d892 4
a895 2
uaudio_add_extension(struct uaudio_softc *sc, usb_descriptor_t *v,
		     usb_descriptor_t **dps)
d906 1
a906 4
	if (usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_NO_XU)
		return;

	if (d1->bmControls[0] & UA_EXT_ENABLE_MASK) {
d919 3
a921 1
uaudio_identify(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d923 1
a923 1
	usbd_status err;
d925 3
a927 3
	err = uaudio_identify_ac(sc, cdesc);
	if (err)
		return (err);
d932 3
a934 1
uaudio_add_alt(struct uaudio_softc *sc, struct as_info *ai)
d939 11
d953 2
a954 1
	if (sc->sc_alts == NULL) {
d964 4
a967 2
uaudio_process_as(struct uaudio_softc *sc, char *buf, int *offsp,
		  int size, usb_interface_descriptor_t *id)
d969 2
a1017 4
	if ((usbd_get_quirks(sc->sc_udev)->uq_flags & UQ_AU_INP_ASYNC) &&
	    dir == UE_DIR_IN && type == UE_ISO_ADAPT)
		type = UE_ISO_ASYNC;

d1020 1
a1020 1
		printf("%s: ignored %sput endpoint of type %s\n",
d1023 1
a1023 1
		       dir == UE_DIR_IN ? "adaptive" : "async");
d1039 1
a1039 1
#ifdef UAUDIO_DEBUG
d1076 1
a1076 1
	sc->sc_chan.dir |= dir == UE_DIR_OUT ? AUMODE_PLAY : AUMODE_RECORD;
d1082 3
a1084 1
uaudio_identify_as(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d1087 1
a1087 1
	usbd_status err;
d1096 2
a1097 2
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOSTREAM);
	if (id == NULL)
d1099 2
a1102 1
	sc->sc_chan.dir = 0;
a1105 2
		DPRINTFN(2, ("uaudio_identify: interface %d\n",
		    id->bInterfaceNumber));
d1113 1
a1113 1
			err = uaudio_process_as(sc, buf, &offs, size, id);
d1116 1
a1116 1
#ifdef UAUDIO_DEBUG
d1123 2
a1124 2
		id = uaudio_find_iface(buf, size, &offs,UISUBCLASS_AUDIOSTREAM);
		if (id == NULL)
a1134 4
#if 0
	if (sc->sc_chan.dir == (AUMODE_PLAY | AUMODE_RECORD))
		sc->sc_props |= AUDIO_PROP_FULLDUPLEX;
#endif
d1139 3
a1141 1
uaudio_identify_ac(struct uaudio_softc *sc, usb_config_descriptor_t *cdesc)
d1154 2
a1155 2
	id = uaudio_find_iface(buf, size, &offs, UISUBCLASS_AUDIOCONTROL);
	if (id == NULL)
a1175 1
	sc->sc_audio_rev = UGETW(acdp->bcdADC);
d1177 1
a1177 1
		 sc->sc_audio_rev, aclen));
d1207 1
a1207 1
		if (dp == NULL)
d1246 3
a1248 1
uaudio_query_devinfo(void *addr, mixer_devinfo_t *mi)
a1301 1
		mi->un.v.delta = mc->delta;
d1308 3
a1310 1
uaudio_open(void *addr, int flags)
d1321 1
a1321 1
	if ((flags & FREAD) && !(sc->sc_chan.dir & AUMODE_RECORD))
d1323 1
a1323 1
	if ((flags & FWRITE) && !(sc->sc_chan.dir & AUMODE_PLAY))
d1335 2
a1336 1
uaudio_close(void *addr)
d1348 2
a1349 1
uaudio_drain(void *addr)
d1359 2
a1360 1
uaudio_halt_out_dma(void *addr)
d1365 1
a1365 1
	if (sc->sc_chan.pipe != NULL) {
d1374 2
a1375 1
uaudio_halt_in_dma(void *addr)
d1380 1
a1380 1
	if (sc->sc_chan.pipe != NULL) {
d1389 3
a1391 1
uaudio_getdev(void *addr, struct audio_device *retp)
d1407 3
a1409 1
uaudio_round_blocksize(void *addr, int blk)
d1435 2
a1436 1
uaudio_get_props(void *addr)
d1440 3
d1447 3
a1449 2
uaudio_get(struct uaudio_softc *sc, int which, int type, int wValue,
	   int wIndex, int len)
d1453 1
a1453 1
	usbd_status err;
d1467 3
a1469 3
	err = usbd_do_request(sc->sc_udev, &req, &data);
	if (err) {
		DPRINTF(("uaudio_get: err=%s\n", usbd_errstr(err)));
d1488 3
a1490 2
uaudio_set(struct uaudio_softc *sc, int which, int type, int wValue,
	   int wIndex, int len, int val)
d1494 1
a1494 1
	usbd_status err;
d1518 1
a1518 1
	err = usbd_do_request(sc->sc_udev, &req, &data);
d1520 2
a1521 2
	if (err)
		DPRINTF(("uaudio_set: err=%d\n", err));
d1526 2
a1527 1
uaudio_signext(int type, int val)
d1539 3
a1541 1
uaudio_value2bsd(struct mixerctl *mc, int val)
d1548 2
a1549 2
		val = ((uaudio_signext(mc->type, val) - mc->minval) * 256
			+ mc->mul/2) / mc->mul;
d1555 3
a1557 1
uaudio_bsd2value(struct mixerctl *mc, int val)
d1564 1
a1564 1
		val = (val + mc->delta/2) * mc->mul / 256 + mc->minval;
d1570 5
a1574 2
uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc, 
	       int chan)
d1585 6
a1590 2
uaudio_ctl_set(struct uaudio_softc *sc, int which, struct mixerctl *mc,
	       int chan, int val)
d1598 3
a1600 1
uaudio_mixer_get_port(void *addr, mixer_ctrl_t *cp)
d1641 3
a1643 1
uaudio_mixer_set_port(void *addr, mixer_ctrl_t *cp)
d1680 7
a1686 3
uaudio_trigger_input(void *addr, void *start, void *end, int blksize,
		     void (*intr)(void *), void *arg,
		     struct audio_params *param)
d1690 1
a1690 1
	usbd_status err;
d1704 2
a1705 2
	err = uaudio_chan_alloc_buffers(sc, ch);
	if (err)
d1708 2
a1709 2
	err = uaudio_chan_open(sc, ch);
	if (err) {
d1718 1
a1718 1
	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX -1 shouldn't be needed */
d1726 7
a1732 3
uaudio_trigger_output(void *addr, void *start, void *end, int blksize,
		      void (*intr)(void *), void *arg,
		      struct audio_params *param)
d1736 1
a1736 1
	usbd_status err;
d1750 2
a1751 2
	err = uaudio_chan_alloc_buffers(sc, ch);
	if (err)
d1754 2
a1755 2
	err = uaudio_chan_open(sc, ch);
	if (err) {
d1764 1
a1764 1
	for (i = 0; i < UAUDIO_NCHANBUFS-1; i++) /* XXX */
d1773 3
a1775 1
uaudio_chan_open(struct uaudio_softc *sc, struct chan *ch)
d1779 1
a1779 1
	usbd_status err;
d1785 3
a1787 3
	err = usbd_set_interface(as->ifaceh, as->alt);
	if (err)
		return (err);
d1791 4
a1794 4
	err = uaudio_set_speed(sc, endpt, ch->sample_rate);
	if (err)
		DPRINTF(("uaudio_chan_open: set_speed failed err=%s\n",
			 usbd_errstr(err)));
d1800 2
a1801 2
	err = usbd_open_pipe(as->ifaceh, endpt, 0, &ch->pipe);
	return (err);
d1805 3
a1807 1
uaudio_chan_close(struct uaudio_softc *sc, struct chan *ch)
a1808 2
	struct as_info *as = &sc->sc_alts[sc->sc_curaltidx];

d1812 1
a1812 1
		usbd_set_interface(as->ifaceh, sc->sc_nullalt);
d1819 3
a1821 1
uaudio_chan_alloc_buffers(struct uaudio_softc *sc, struct chan *ch)
d1823 1
a1823 1
	usbd_xfer_handle xfer;
d1829 2
a1830 2
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
d1832 2
a1833 2
		ch->chanbufs[i].xfer = xfer;
		buf = usbd_alloc_buffer(xfer, size);
d1847 1
a1847 1
		usbd_free_xfer(ch->chanbufs[i].xfer);
d1852 3
a1854 1
uaudio_chan_free_buffers(struct uaudio_softc *sc, struct chan *ch)
d1859 1
a1859 1
		usbd_free_xfer(ch->chanbufs[i].xfer);
d1864 2
a1865 1
uaudio_chan_ptransfer(struct chan *ch)
a1869 3
	if (ch->sc->sc_dying)
		return;

d1882 1
a1882 2
			if (!ch->nofrac)
				size += ch->sample_size;
d1916 1
a1916 1
	DPRINTFN(5,("uaudio_chan_transfer: ptransfer xfer=%p\n", cb->xfer));
d1918 3
a1920 3
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, 
			     UAUDIO_NFRAMES, USBD_NO_COPY, 
			     uaudio_chan_pintr);
d1922 1
a1922 1
	(void)usbd_transfer(cb->xfer);
d1926 4
a1929 2
uaudio_chan_pintr(usbd_xfer_handle xfer, usbd_private_handle priv,
		  usbd_status status)
d1940 1
a1940 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
d1967 2
a1968 1
uaudio_chan_rtransfer(struct chan *ch)
a1972 3
	if (ch->sc->sc_dying)
		return;

d1985 1
a1985 2
			if (!ch->nofrac)
				size += ch->sample_size;
d2004 1
a2004 1
	DPRINTFN(5,("uaudio_chan_rtransfer: transfer xfer=%p\n", cb->xfer));
d2006 3
a2008 3
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes, 
			     UAUDIO_NFRAMES, USBD_NO_COPY, 
			     uaudio_chan_rintr);
d2010 1
a2010 1
	(void)usbd_transfer(cb->xfer);
d2014 4
a2017 2
uaudio_chan_rintr(usbd_xfer_handle xfer, usbd_private_handle priv,
		  usbd_status status)
d2028 1
a2028 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
a2030 8

	if (count < cb->size) {
		/* if the device fails to keep up, copy last byte */
		u_char b = count ? cb->buffer[count-1] : 0;
		while (count < cb->size)
			cb->buffer[count++] = b;
	}

d2033 1
a2033 1
		printf("uaudio_chan_rintr: count(%d) != size(%d)\n",
d2057 1
a2057 1
		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n", 
d2068 5
a2072 2
uaudio_chan_set_param(struct chan *ch, struct audio_params *param,
		      u_char *start, u_char *end, int blksize)
d2094 4
a2097 2
uaudio_set_params(void *addr, int setmode, int usemode,
		  struct audio_params *play, struct audio_params *rec)
a2100 1
	int factor;
d2102 2
a2103 3
	void (*swcode)(void *, u_char *buf, int cnt);
	struct audio_params *p;
	int mode;
d2108 1
a2108 1
	if (sc->sc_chan.pipe != NULL)
d2111 46
a2156 16
	for (mode = AUMODE_RECORD; mode != -1;
	     mode = mode == AUMODE_RECORD ? AUMODE_PLAY : -1) {
		if ((setmode & mode) == 0)
			continue;
		if ((sc->sc_chan.dir & mode) == 0)
			continue;

		p = mode == AUMODE_PLAY ? play : rec;

		factor = 1;
		swcode = 0;
		enc = p->encoding;
		switch (enc) {
		case AUDIO_ENCODING_SLINEAR_BE:
			if (p->precision == 16) {
				swcode = swap_bytes;
d2158 9
a2166 2
			} else if (p->precision == 8 && !(flags & HAS_8)) {
				swcode = change_sign8;
d2168 3
a2170 23
			}
			break;
		case AUDIO_ENCODING_SLINEAR_LE:
			if (p->precision == 8 && !(flags & HAS_8)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_BE:
			if (p->precision == 16) {
				if (mode == AUMODE_PLAY)
					swcode = swap_bytes_change_sign16_le;
				else
					swcode = change_sign16_swap_bytes_le;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else if (p->precision == 8 && !(flags & HAS_8U)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_ULINEAR_LE:
			if (p->precision == 16) {
				swcode = change_sign16_le;
d2172 2
a2173 53
			} else if (p->precision == 8 && !(flags & HAS_8U)) {
				swcode = change_sign8;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			}
			break;
		case AUDIO_ENCODING_ULAW:
			if (!(flags & HAS_MULAW)) {
				if (mode == AUMODE_PLAY &&
				    (flags & HAS_16)) {
					swcode = mulaw_to_slinear16_le;
					factor = 2;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else if (flags & HAS_8U) {
					if (mode == AUMODE_PLAY)
						swcode = mulaw_to_ulinear8;
					else
						swcode = ulinear8_to_mulaw;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_8) {
					if (mode == AUMODE_PLAY)
						swcode = mulaw_to_slinear8;
					else
						swcode = slinear8_to_mulaw;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else
					return (EINVAL);
			}
			break;
		case AUDIO_ENCODING_ALAW:
			if (!(flags & HAS_ALAW)) {
				if (mode == AUMODE_PLAY &&
				    (flags & HAS_16)) {
					swcode = alaw_to_slinear16_le;
					factor = 2;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else if (flags & HAS_8U) {
					if (mode == AUMODE_PLAY)
						swcode = alaw_to_ulinear8;
					else
						swcode = ulinear8_to_alaw;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_8) {
					if (mode == AUMODE_PLAY)
						swcode = alaw_to_slinear8;
					else
						swcode = slinear8_to_alaw;
					enc = AUDIO_ENCODING_SLINEAR_LE;
				} else
					return (EINVAL);
			}
			break;
		default:
			return (EINVAL);
d2175 24
a2198 18
		/* XXX do some other conversions... */

		DPRINTF(("uaudio_set_params: chan=%d prec=%d enc=%d rate=%ld\n",
			 p->channels, p->precision, enc, p->sample_rate));

		for (i = 0; i < sc->sc_nalts; i++) {
			struct usb_audio_streaming_type1_descriptor *a1d =
				sc->sc_alts[i].asf1desc;
			if (p->channels == a1d->bNrChannels &&
			    p->precision == a1d->bBitResolution &&
			    enc == sc->sc_alts[i].encoding &&
			    (mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN) ==
			    UE_GET_DIR(sc->sc_alts[i].edesc->bEndpointAddress)) {
				if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
					DPRINTFN(2,("uaudio_set_params: cont %d-%d\n",
					    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
					if (UA_SAMP_LO(a1d) < p->sample_rate &&
					    p->sample_rate < UA_SAMP_HI(a1d))
a2199 9
				} else {
					for (j = 0; j < a1d->bSamFreqType; j++) {
						DPRINTFN(2,("uaudio_set_params: disc #"
						    "%d: %d\n", j, UA_GETSAMP(a1d, j)));
						/* XXX allow for some slack */
						if (UA_GETSAMP(a1d, j) ==
						    p->sample_rate)
							goto found;
					}
d2203 2
a2204 1
		return (EINVAL);
d2206 4
a2209 6
	found:
		p->sw_code = swcode;
		p->factor  = factor;
		if (usemode == mode)
			sc->sc_curaltidx = i;
	}
d2215 1
a2215 1
	return (0);
d2219 4
a2222 1
uaudio_set_speed(struct uaudio_softc *sc, int endpt, u_int speed)
@


1.1.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uaudio.c,v 1.41 2001/01/23 14:04:13 augustss Exp $	*/
a54 1
#include <sys/reboot.h>
d385 1
a385 2
			printf("%s: alt %d missing AS interface(s)\n",
			    USBDEVNAME(sc->sc_dev), j);
d390 2
a391 1
	printf("%s: audio rev %d.%02x\n", USBDEVNAME(sc->sc_dev),
a398 11
#if defined(__NetBSD__)
#ifndef UAUDIO_DEBUG
	if (bootverbose)
#endif
#endif
		printf("%s: %d mixer controls\n", USBDEVNAME(sc->sc_dev),
		    sc->sc_nctls);

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d406 3
d424 1
a424 1
		if (sc->sc_audiodev != NULL)
d531 1
a531 1
	return (NULL);
d1089 1
a1089 1
	/* We can't handle endpoints that need a sync pipe yet. */
@


1.1.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.1.2.2 2001/07/04 10:43:48 niklas Exp $ */
d412 3
d416 1
@


1.1.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uaudio.c,v 1.43 2001/10/03 00:04:53 augustss Exp $	*/
d55 1
a55 1
#include <sys/reboot.h>				/* for bootverbose */
d543 8
a550 6
	size_t len = sizeof(*mc) * (sc->sc_nctls + 1);
	struct mixerctl *nmc = sc->sc_nctls == 0 ?
	    malloc(len, M_USBDEV, M_NOWAIT) :
	    realloc(sc->sc_ctls, len, M_USBDEV, M_NOWAIT);
 
	if (nmc == NULL) {
a553 1
	sc->sc_ctls = nmc;
d1024 7
a1030 6
	size_t len = sizeof(*ai) * (sc->sc_nalts + 1);
	struct as_info *nai = sc->sc_nalts == 0 ?
	    malloc(len, M_USBDEV, M_NOWAIT) :
	    realloc(sc->sc_alts, len, M_USBDEV, M_NOWAIT);

	if (nai == NULL) {
a1033 2

	sc->sc_alts = nai;
@


1.1.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: uaudio.c,v 1.60 2002/05/18 15:14:39 kent Exp $	*/
d55 1
a55 1
#include <sys/reboot.h>			/* for bootverbose */
d84 1
a84 1
#define UAUDIO_NFRAMES   10	/* ms of sound in each request */
a110 3
	u_int8_t	attributes; /* Copy of bmAttributes of
				     * usb_audio_streaming_endpoint_descriptor
				     */
a114 1
	int		sc_busy;	/* currently used */
d118 1
d122 1
d136 1
a136 1
	int	altidx;		/* currently used altidx */
d140 1
a140 1
		struct chan	*chan;
d142 3
a144 3
		u_char		*buffer;
		u_int16_t	sizes[UAUDIO_NFRAMES];
		u_int16_t	size;
d157 3
a159 2
	struct chan sc_playchan;	/* play channel */
	struct chan sc_recchan;		/* record channel */
d167 1
d170 5
a174 9
#define HAS_8		0x01
#define HAS_16		0x02
#define HAS_8U		0x04
#define HAS_ALAW	0x08
#define HAS_MULAW	0x10
#define UA_NOFRAC	0x20		/* don't do sample rate adjustment */
#define HAS_24		0x40

	int	sc_mode;		/* play/record capability */
d195 1
a195 1
Static void		uaudio_add_alt(struct uaudio_softc *sc,
d203 1
a203 1
Static char		*uaudio_id_name(struct uaudio_softc *sc,
d209 1
a209 1
Static void		uaudio_add_output(struct uaudio_softc *sc,
d218 1
a218 1
			    usb_descriptor_t *v, usb_descriptor_t **dps);
d223 1
a223 1
Static usbd_status	uaudio_identify(struct uaudio_softc *sc,
d226 4
a229 4
Static int		uaudio_signext(int type, int val);
Static int		uaudio_value2bsd(struct mixerctl *mc, int val);
Static int		uaudio_bsd2value(struct mixerctl *mc, int val);
Static int		uaudio_get(struct uaudio_softc *sc, int type,
d235 1
a235 1
Static void		uaudio_ctl_set(struct uaudio_softc *sc, int which,
d248 2
a249 3
Static void		uaudio_chan_init(struct chan *, int,
					 const struct audio_params *);
Static void		uaudio_chan_set_param(struct chan *ch, u_char *start,
d252 1
a252 1
Static void		uaudio_chan_pintr(usbd_xfer_handle xfer,
d256 1
a256 1
Static void		uaudio_chan_rintr(usbd_xfer_handle xfer,
d263 1
a263 11
Static void		uaudio_get_minmax_rates(int, const struct as_info *,
						const struct audio_params *,
						int, u_long *, u_long *);
Static int		uaudio_match_alt_sub(int, const struct as_info *,
					     const struct audio_params *,
					     int, u_long);
Static int		uaudio_match_alt_chan(int, const struct as_info *,
					      struct audio_params *, int);
Static int		uaudio_match_alt(int, const struct as_info *,
					 struct audio_params *, int);
Static int		uaudio_set_params(void *, int, int,
a306 3
#if defined(__NetBSD__)
	NULL,
#endif
d321 1
a321 1

d327 1
a327 1
	if (id == NULL ||
d395 1
a395 1
	sc->sc_playchan.sc = sc->sc_recchan.sc = sc;
d398 1
a398 1
		sc->sc_altflags |= UA_NOFRAC;
d400 2
a401 1
#if defined(__NetBSD__) && !defined(UAUDIO_DEBUG)
d404 1
d464 1
a464 1

d494 1
a494 1
	case 4:
d547 1
a547 1

d557 3
a559 3
		mc->minval = uaudio_signext(mc->type,
			uaudio_get(sc, GET_MIN, UT_READ_CLASS_INTERFACE,
				   mc->wValue[0], mc->wIndex,
d561 1
a561 1
		mc->maxval = 1 + uaudio_signext(mc->type,
d667 1
a667 1
uaudio_add_input(struct uaudio_softc *sc, usb_descriptor_t *v,
d671 1
a671 1
	struct usb_audio_input_terminal *d =
d688 1
a688 1
	struct usb_audio_output_terminal *d =
d710 1
a710 1

d746 1
a746 1
						mix.wValue[k++] =
d801 1
a801 1
		    "%d channels, mmask=0x%04x, cmask=0x%04x\n",
d832 1
a832 1
				uaudio_id_name(sc, dps, srcId),
d839 1
a839 1
				uaudio_id_name(sc, dps, srcId),
d846 1
a846 1
				uaudio_id_name(sc, dps, srcId),
d853 1
a853 1
				uaudio_id_name(sc, dps, srcId),
d860 1
a860 1
				uaudio_id_name(sc, dps, srcId),
d870 1
a870 1
				uaudio_id_name(sc, dps, srcId),
d877 1
a877 1
				uaudio_id_name(sc, dps, srcId),
d884 1
a884 1
				uaudio_id_name(sc, dps, srcId),
d891 1
a891 1
				uaudio_id_name(sc, dps, srcId),
d904 1
a904 1
	struct usb_audio_processing_unit *d =
d942 1
a942 1
	struct usb_audio_processing_unit *d =
d985 1
a985 1
	struct usb_audio_extension_unit *d =
d1024 1
a1024 1
	struct as_info *nai = (sc->sc_nalts == 0) ?
d1102 1
a1102 1

d1110 1
a1110 1

d1114 2
a1115 1
	if (prec != 8 && prec != 16 && prec != 24) {
d1118 1
d1123 1
a1123 7
		if (prec == 8) {
			sc->sc_altflags |= HAS_8;
		} else if (prec == 16) {
			sc->sc_altflags |= HAS_16;
		} else if (prec == 24) {
			sc->sc_altflags |= HAS_24;
		}
d1143 2
a1144 2
	DPRINTFN(1, ("uaudio_process_as: alt=%d enc=%d chan=%d prec=%d\n",
		     id->bAlternateSetting, enc, chan, prec));
a1146 1
	ai.attributes = sed->bmAttributes;
a1149 1
	ai.sc_busy = 0;
d1151 2
a1152 20
#ifdef UAUDIO_DEBUG
	{
		int j;
		if (asf1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(1, ("uaudio_process_as:  rate=%d-%d\n",
				     UA_SAMP_LO(asf1d), UA_SAMP_HI(asf1d)));
		} else {
			DPRINTFN(1, ("uaudio_process_as: "));
			for (j = 0; j < asf1d->bSamFreqType; j++)
				DPRINTFN(1, (" %d", UA_GETSAMP(asf1d, j)));
			DPRINTFN(1, ("\n"));
		}
		if (ai.attributes & UA_SED_FREQ_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  FREQ_CONTROL\n"));
		if (ai.attributes & UA_SED_PITCH_CONTROL)
			DPRINTFN(1, ("uaudio_process_as:  PITCH_CONTROL\n"));
	}
#endif
	sc->sc_mode |= (dir == UE_DIR_OUT) ? AUMODE_PLAY : AUMODE_RECORD;

d1156 1
a1156 1

d1174 3
d1205 2
a1206 3

	if ((sc->sc_mode & (AUMODE_PLAY | AUMODE_RECORD)) == 0) {
		printf("%s: no usable endpoint found\n",
d1210 4
a1213 1

d1287 1
a1287 1
		DPRINTF(("uaudio_identify: subtype=%d\n",
d1333 1
a1333 1

d1389 1
a1389 1
	DPRINTF(("uaudio_open: sc=%p\n", sc));
d1393 1
a1393 1
	if (sc->sc_mode == 0)
d1396 4
a1399 5
	if (flags & FREAD) {
		if ((sc->sc_mode & AUMODE_RECORD) == 0)
			return (EACCES);
		sc->sc_recchan.intr = NULL;
	}
d1401 1
a1401 5
	if (flags & FWRITE) {
		if ((sc->sc_mode & AUMODE_PLAY) == 0)
			return (EACCES);
		sc->sc_playchan.intr = NULL;
	}
d1403 1
a1403 1
	return (0);
d1418 1
a1418 1
	sc->sc_playchan.intr = sc->sc_recchan.intr = NULL;
d1437 4
a1440 4
	if (sc->sc_playchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_playchan);
		sc->sc_playchan.pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_playchan);
d1442 1
a1442 1
	return (0);
d1451 4
a1454 4
	if (sc->sc_recchan.pipe != NULL) {
		uaudio_chan_close(sc, &sc->sc_recchan);
		sc->sc_recchan.pipe = NULL;
		uaudio_chan_free_buffers(sc, &sc->sc_recchan);
d1456 1
a1456 1
	return (0);
d1467 1
a1467 1

d1469 1
a1469 1
	return (0);
d1481 1
a1481 10
	DPRINTF(("uaudio_round_blocksize: p.bpf=%d r.bpf=%d\n",
		 sc->sc_playchan.bytes_per_frame,
		 sc->sc_recchan.bytes_per_frame));
	if (sc->sc_playchan.bytes_per_frame > sc->sc_recchan.bytes_per_frame) {
		bpf = sc->sc_playchan.bytes_per_frame
		    + sc->sc_playchan.sample_size;
	} else {
		bpf = sc->sc_recchan.bytes_per_frame
		    + sc->sc_recchan.sample_size;
	}
d1504 3
a1506 1
	return (AUDIO_PROP_FULLDUPLEX | AUDIO_PROP_INDEPENDENT);
d1527 1
a1527 1
		    "wIndex=0x%04x len=%d\n",
d1529 1
a1529 1
	err = usbd_do_request(sc->sc_udev, &req, data);
d1577 1
a1577 1
		    "wIndex=0x%04x len=%d, val=%d\n",
d1579 1
a1579 1
	err = usbd_do_request(sc->sc_udev, &req, data);
d1604 1
a1604 1
		val = (val != 0);
d1618 1
a1618 1
		val = (val != 0);
d1626 1
a1626 1
uaudio_ctl_get(struct uaudio_softc *sc, int which, struct mixerctl *mc,
d1657 1
a1657 1

d1686 1
a1686 1

d1697 1
a1697 1

d1730 1
a1730 1
	struct chan *ch = &sc->sc_recchan;
d1740 1
a1740 1
	uaudio_chan_set_param(ch, start, end, blksize);
d1755 2
a1756 2
	ch->intr = intr;
	ch->arg = arg;
d1763 1
a1763 1
	return (0);
d1765 1
a1765 1

d1772 1
a1772 1
	struct chan *ch = &sc->sc_playchan;
d1782 1
a1782 1
	uaudio_chan_set_param(ch, start, end, blksize);
d1797 2
a1798 2
	ch->intr = intr;
	ch->arg = arg;
d1805 1
a1805 1
	return (0);
d1812 1
a1812 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
d1816 1
a1816 1
	DPRINTF(("uaudio_chan_open: endpt=0x%02x, speed=%d, alt=%d\n",
d1834 1
a1834 1
	DPRINTF(("uaudio_chan_open: create pipe to 0x%02x\n", endpt));
d1842 1
a1842 1
	struct as_info *as = &sc->sc_alts[ch->altidx];
a1843 1
	as->sc_busy = 0;
d1845 1
a1845 1
		DPRINTF(("uaudio_chan_close: set null alt=%d\n",
d1915 1
a1915 1
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
d1925 1
a1925 1
	/*
d1952 2
a1953 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     UAUDIO_NFRAMES, USBD_NO_COPY,
d1987 1
a1987 1
		DPRINTFN(5,("uaudio_chan_pintr: call %p(%p)\n",
d2019 1
a2019 1
			if ((ch->sc->sc_altflags & UA_NOFRAC) == 0)
d2041 2
a2042 2
	usbd_setup_isoc_xfer(cb->xfer, ch->pipe, cb, cb->sizes,
			     UAUDIO_NFRAMES, USBD_NO_COPY,
d2079 1
a2079 1
	/*
d2098 1
a2098 1
		DPRINTFN(5,("uaudio_chan_rintr: call %p(%p)\n",
d2109 2
a2110 1
uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param)
d2114 1
a2114 2
	ch->altidx = altidx;
	sample_size = param->precision * param->factor * param->channels / 8;
a2120 1
}
a2121 3
void
uaudio_chan_set_param(struct chan *ch, u_char *start, u_char *end, int blksize)
{
a2130 149
void
uaudio_get_minmax_rates(int nalts, const struct as_info *alts,
			const struct audio_params *p, int mode,
			u_long *min, u_long *max)
{
	int i, j;
	struct usb_audio_streaming_type1_descriptor *a1d;

	*min = ULONG_MAX;
	*max = 0;
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
			continue;
		if (p->channels != a1d->bNrChannels)
			continue;
		if (p->precision != a1d->bBitResolution)
			continue;
		if (p->encoding != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(2,("uaudio_get_minmax_rates: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) < *min)
				*min = UA_SAMP_LO(a1d);
			if (UA_SAMP_HI(a1d) > *max)
				*max = UA_SAMP_HI(a1d);
		} else {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				DPRINTFN(2,("uaudio_get_minmax_rates: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				if (UA_GETSAMP(a1d, j) < *min)
					*min = UA_GETSAMP(a1d, j);
				if (UA_GETSAMP(a1d, j) > *max)
					*max = UA_GETSAMP(a1d, j);
			}
		}
	}
}

int
uaudio_match_alt_sub(int nalts, const struct as_info *alts,
		     const struct audio_params *p, int mode, u_long rate)
{
	int i, j;
	struct usb_audio_streaming_type1_descriptor *a1d;

	DPRINTF(("uaudio_match_alt_sub: search for %luHz %dch\n",
		 rate, p->channels));
	for (i = 0; i < nalts; i++) {
		a1d = alts[i].asf1desc;
		if (alts[i].sc_busy)
			continue;
		if (p->channels != a1d->bNrChannels)
			continue;
		if (p->precision != a1d->bBitResolution)
			continue;
		if (p->encoding != alts[i].encoding)
			continue;
		if (mode != UE_GET_DIR(alts[i].edesc->bEndpointAddress))
			continue;
		if (a1d->bSamFreqType == UA_SAMP_CONTNUOUS) {
			DPRINTFN(2,("uaudio_match_alt_sub: cont %d-%d\n",
				    UA_SAMP_LO(a1d), UA_SAMP_HI(a1d)));
			if (UA_SAMP_LO(a1d) < rate && rate < UA_SAMP_HI(a1d))
				return i;
		} else {
			for (j = 0; j < a1d->bSamFreqType; j++) {
				DPRINTFN(2,("uaudio_match_alt_sub: disc #%d: %d\n",
					    j, UA_GETSAMP(a1d, j)));
				/* XXX allow for some slack */
				if (UA_GETSAMP(a1d, j) == rate)
					return i;
			}
		}
	}
	return -1;
}

int
uaudio_match_alt_chan(int nalts, const struct as_info *alts,
		      struct audio_params *p, int mode)
{
	int i, n;
	u_long min, max;
	u_long rate;

	/* Exact match */
	DPRINTF(("uaudio_match_alt_chan: examine %ldHz %dch %dbit.\n",
		 p->sample_rate, p->channels, p->precision));
	i = uaudio_match_alt_sub(nalts, alts, p, mode, p->sample_rate);
	if (i >= 0)
		return i;

	uaudio_get_minmax_rates(nalts, alts, p, mode, &min, &max);
	DPRINTF(("uaudio_match_alt_chan: min=%lu max=%lu\n", min, max));
	if (max <= 0)
		return -1;
	/* Search for biggers */
	n = 2;
	while ((rate = p->sample_rate * n++) <= max) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, rate);
		if (i >= 0) {
			p->sample_rate = rate;
			return i;
		}
	}
	if (p->sample_rate >= min) {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, max);
		if (i >= 0) {
			p->sample_rate = max;
			return i;
		}
	} else {
		i = uaudio_match_alt_sub(nalts, alts, p, mode, min);
		if (i >= 0) {
			p->sample_rate = min;
			return i;
		}
	}
	return -1;
}

int
uaudio_match_alt(int nalts, const struct as_info *alts,
		 struct audio_params *p, int mode)
{
	int i, n;

	mode = mode == AUMODE_PLAY ? UE_DIR_OUT : UE_DIR_IN;
	i = uaudio_match_alt_chan(nalts, alts, p, mode);
	if (i >= 0)
		return i;

	for (n = p->channels + 1; n <= AUDIO_MAX_CHANNELS; n++) {
		p->channels = n;
		i = uaudio_match_alt_chan(nalts, alts, p, mode);
		if (i >= 0)
			return i;
	}

	if (p->channels != 2)
		return -1;
	p->channels = 1;
	return uaudio_match_alt_chan(nalts, alts, p, mode);
}

d2138 1
a2138 2
	int enc, i;
	int paltidx=-1, raltidx=-1;
d2146 1
a2146 2
	if ((mode == AUMODE_RECORD && sc->sc_recchan.pipe != NULL)
	    || (mode == AUMODE_PLAY && sc->sc_playchan.pipe != NULL))
a2148 5
	if (usemode & AUMODE_PLAY && sc->sc_playchan.altidx != -1)
		sc->sc_alts[sc->sc_playchan.altidx].sc_busy = 0;
	if (usemode & AUMODE_RECORD && sc->sc_recchan.altidx != -1)
		sc->sc_alts[sc->sc_recchan.altidx].sc_busy = 0;

d2153 1
a2153 2

		if ((sc->sc_mode & mode) == 0)
d2156 1
a2156 1
		p = (mode == AUMODE_PLAY) ? play : rec;
d2163 1
a2163 4
			/* FALLTHROUGH */
		case AUDIO_ENCODING_SLINEAR_LE:
			if (enc == AUDIO_ENCODING_SLINEAR_BE
			    && p->precision == 16 && (flags & HAS_16)) {
d2166 9
a2174 14
			} else if (p->precision == 8) {
				if (flags & HAS_8) {
					/* No conversion */
				} else if (flags & HAS_8U) {
					swcode = change_sign8;
					enc = AUDIO_ENCODING_ULINEAR_LE;
				} else if (flags & HAS_16) {
					factor = 2;
					p->precision = 16;
					if (mode == AUMODE_PLAY)
						swcode = linear8_to_linear16_le;
					else
						swcode = linear16_to_linear8_le;
				}
a2177 2
			/* FALLTHROUGH */
		case AUDIO_ENCODING_ULINEAR_LE:
d2179 1
a2179 3
				if (enc == AUDIO_ENCODING_ULINEAR_LE)
					swcode = change_sign16_le;
				else if (mode == AUMODE_PLAY)
d2184 27
a2210 3
			} else if (p->precision == 8) {
				if (flags & HAS_8U) {
					/* No conversion */
d2212 4
a2215 1
					swcode = change_sign8;
d2217 9
a2225 1
				} else if (flags & HAS_16) {
a2226 1
					p->precision = 16;
d2228 1
d2230 1
a2230 1
						swcode = ulinear8_to_slinear16_le;
d2232 10
a2241 2
						swcode = slinear16_to_ulinear8_le;
				}
a2243 49
		case AUDIO_ENCODING_ULAW:
			if (flags & HAS_MULAW)
				break;
			if (flags & HAS_16) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear16_le;
				else
					swcode = slinear16_to_mulaw_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				p->precision = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_ulinear8;
				else
					swcode = ulinear8_to_mulaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = mulaw_to_slinear8;
				else
					swcode = slinear8_to_mulaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
			break;
		case AUDIO_ENCODING_ALAW:
			if (flags & HAS_ALAW)
				break;
			if (mode == AUMODE_PLAY && (flags & HAS_16)) {
				swcode = alaw_to_slinear16_le;
				factor = 2;
				enc = AUDIO_ENCODING_SLINEAR_LE;
				p->precision = 16;
			} else if (flags & HAS_8U) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_ulinear8;
				else
					swcode = ulinear8_to_alaw;
				enc = AUDIO_ENCODING_ULINEAR_LE;
			} else if (flags & HAS_8) {
				if (mode == AUMODE_PLAY)
					swcode = alaw_to_slinear8;
				else
					swcode = slinear8_to_alaw;
				enc = AUDIO_ENCODING_SLINEAR_LE;
			} else
				return (EINVAL);
			break;
d2252 27
a2278 4
		p->encoding = enc;
		i = uaudio_match_alt(sc->sc_nalts, sc->sc_alts, p, mode);
		if (i < 0)
			return (EINVAL);
d2280 1
d2283 2
a2284 9
		if (usemode & mode) {
			if (mode == AUMODE_PLAY) {
				paltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			} else {
				raltidx = i;
				sc->sc_alts[i].sc_busy = 1;
			}
		}
d2287 4
a2290 18
	if ((usemode & AUMODE_PLAY) /*&& paltidx != sc->sc_playchan.altidx*/) {
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_playchan, paltidx, play);
	}
	if ((usemode & AUMODE_RECORD) /*&& raltidx != sc->sc_recchan.altidx*/) {
		/* XXX abort transfer if currently happening? */
		uaudio_chan_init(&sc->sc_recchan, raltidx, rec);
	}

	DPRINTF(("uaudio_set_params: use altidx=p%d/r%d, altno=p%d/r%d\n",
		 sc->sc_playchan.altidx, sc->sc_recchan.altidx,
		 (sc->sc_playchan.altidx >= 0)
		   ?sc->sc_alts[sc->sc_playchan.altidx].idesc->bAlternateSetting
		   : -1,
		 (sc->sc_recchan.altidx >= 0)
		   ? sc->sc_alts[sc->sc_recchan.altidx].idesc->bAlternateSetting
		   : -1));

d2310 1
a2310 1
	return (usbd_do_request(sc->sc_udev, &req, data));
d2312 1
@


1.1.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uaudio.c,v 1.1.2.5 2003/03/28 00:38:31 niklas Exp $ */
d363 1
a363 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d487 1
a487 1
		strlcpy(fp->name, AudioEulinear, sizeof fp->name);
d493 1
a493 1
		strlcpy(fp->name, AudioEmulaw, sizeof fp->name);
d499 1
a499 1
		strlcpy(fp->name, AudioEalaw, sizeof fp->name);
d505 1
a505 1
		strlcpy(fp->name, AudioEslinear, sizeof fp->name);
d511 1
a511 1
		strlcpy(fp->name, AudioEslinear_le, sizeof fp->name);
d517 1
a517 1
		strlcpy(fp->name, AudioEulinear_le, sizeof fp->name);
d523 1
a523 1
		strlcpy(fp->name, AudioEslinear_be, sizeof fp->name);
d529 1
a529 1
		strlcpy(fp->name, AudioEulinear_be, sizeof fp->name);
d614 1
a614 1
	snprintf(buf, sizeof buf, "i%d", id);
d765 1
a765 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"mix%d-%s", d->bUnitId,
d847 1
a847 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d854 1
a854 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d861 1
a861 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d868 1
a868 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d875 1
a875 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d885 1
a885 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d892 1
a892 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d899 1
a899 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d906 1
a906 2
			snprintf(mix.ctlname, sizeof mix.ctlname,
				"fea%d-%s-%s", unit,
d944 1
a944 2
	snprintf(mix.ctlname, sizeof mix.ctlname,
		"pro%d-mode", d->bUnitId);
d975 1
a975 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"pro%d.%d-enable", d->bUnitId, ptype);
d1020 1
a1020 2
		snprintf(mix.ctlname, sizeof mix.ctlname,
			"ext%d-enable", d->bUnitId);
d1378 1
a1378 2
			strlcpy(mi->label.name, AudioCoutputs,
			    sizeof mi->label.name);
d1384 1
a1384 2
			strlcpy(mi->label.name, AudioCinputs,
			    sizeof mi->label.name);
d1390 1
a1390 2
			strlcpy(mi->label.name, AudioCequalization,
			    sizeof mi->label.name);
d1397 1
a1397 1
	strlcpy(mi->label.name, mc->ctlname, sizeof mi->label.name);
d1404 1
a1404 2
		strlcpy(mi->un.e.member[0].label.name, AudioNoff,
		    sizeof mi->un.e.member[0].label.name);
d1406 1
a1406 2
		strlcpy(mi->un.e.member[1].label.name, AudioNon,
		    sizeof mi->un.e.member[1].label.name);
d1411 1
a1411 2
		strlcpy(mi->un.v.units.name, mc->ctlunit,
		    sizeof mi->un.v.units.name);
@


1.1.2.7
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uaudio.c,v 1.67 2003/05/03 18:11:41 wiz Exp $	*/
d122 1
a122 1
	void	(*intr)(void *);	/* DMA completion intr handler */
a145 1
		u_int16_t	offsets[UAUDIO_NFRAMES];
a189 1
#define UAC_NCLASSES 3
a200 2
Static void		uaudio_mixer_alias_ctl(struct uaudio_softc *sc,
			     struct mixerctl *mp, const char *ctl);
d253 1
a253 1
					 const struct audio_params *, int);
a413 2
	sc->sc_playchan.altidx = -1;
	sc->sc_recchan.altidx = -1;
a432 10
/*
 * Macros to help sync OpenBSD to NetBSD
 */
#if defined(__OpenBSD__)
#define hw_channels channels
#define hw_sample_rate sample_rate
#define hw_precision precision
#define hw_encoding encoding
#endif

a609 9
void
uaudio_mixer_alias_ctl(struct uaudio_softc *sc, struct mixerctl *mc,
		     const char *name)
{
	/* XXX mark as alias? */
	strlcpy(mc->ctlname, name, sizeof mc->ctlname);
	uaudio_mixer_add_ctl(sc, mc);
}

d844 1
a844 1
		mix.class = UAC_OUTPUT;	/* XXX we don't really know this */
a847 2
			mix.ctlunit = "";
			uaudio_mixer_alias_ctl(sc, &mix, AudioNmute);
d852 1
a855 2
			mix.ctlunit = AudioNvolume;
			uaudio_mixer_alias_ctl(sc, &mix, AudioNmaster);
d860 1
a863 2
			mix.ctlunit = AudioNbass;
			uaudio_mixer_alias_ctl(sc, &mix, AudioNbass);
d868 1
a871 1
			mix.ctlunit = AudioNmid;
d876 1
a879 2
			mix.ctlunit = AudioNtreble;
			uaudio_mixer_alias_ctl(sc, &mix, AudioNtreble);
d884 1
d1214 1
d1238 1
a1238 1
			uaudio_process_as(sc, buf, &offs, size, id);
d1385 26
a1410 22
	switch (n) {
	case UAC_OUTPUT:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_OUTPUT;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCoutputs, sizeof mi->label.name);
		return (0);
	case UAC_INPUT:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_INPUT;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCinputs, sizeof mi->label.name);
		return (0);
	case UAC_EQUAL:
		mi->type = AUDIO_MIXER_CLASS;
		mi->mixer_class = UAC_EQUAL;
		mi->next = mi->prev = AUDIO_MIXER_LAST;
		strlcpy(mi->label.name, AudioCequalization,
		    sizeof mi->label.name);
		return (0);
	default:
		break;
a1411 5

	n -= UAC_NCLASSES;
	if (n < 0 || n >= nctls)
		return (ENXIO);

d1724 1
a1724 1
	n = cp->dev - UAC_NCLASSES;
d1764 1
a1764 1
	n = cp->dev - UAC_NCLASSES;
d2084 6
a2090 1
		cb->offsets[i] = total;
d2122 1
a2122 1
	int s, i, n, frsize;
d2132 7
a2138 1
	/* count < cb->size is normal for asynchronous source */
d2140 2
a2141 2
	if (count > cb->size) {
		printf("uaudio_chan_rintr: count(%d) > size(%d)\n",
d2150 8
a2157 12
	for(i = 0; i < UAUDIO_NFRAMES; i++) {
		frsize = cb->sizes[i];
		n = min(frsize, ch->end - ch->cur);
		memcpy(ch->cur, cb->buffer + cb->offsets[i], n);
		ch->cur += n;
		if (ch->cur >= ch->end)
			ch->cur = ch->start;
		if (frsize > n) {
			memcpy(ch->cur, cb->buffer + cb->offsets[i] + n,
			    frsize - n);
			ch->cur += frsize - n;
		}
d2161 1
a2161 1
	ch->transferred += count;
d2176 1
a2176 2
uaudio_chan_init(struct chan *ch, int altidx, const struct audio_params *param,
    int maxpktsize)
d2181 3
a2183 2
	sample_size = param->precision * param->factor * param->hw_channels / 8;
	samples_per_frame = param->hw_sample_rate / USB_FRAMES_PER_SECOND;
d2185 2
a2186 8
	ch->sample_rate = param->hw_sample_rate;
	if (maxpktsize == 0) {
		ch->fraction = param->hw_sample_rate % USB_FRAMES_PER_SECOND;
		ch->bytes_per_frame = samples_per_frame * sample_size;
	} else {
		ch->fraction = 0;
		ch->bytes_per_frame = maxpktsize;
	}
d2216 1
a2216 1
		if (p->hw_channels != a1d->bNrChannels)
d2218 1
a2218 1
		if (p->hw_precision != a1d->bBitResolution)
d2220 1
a2220 1
		if (p->hw_encoding != alts[i].encoding)
d2252 1
a2252 1
		 rate, p->hw_channels));
d2257 1
a2257 1
		if (p->hw_channels != a1d->bNrChannels)
d2259 1
a2259 1
		if (p->hw_precision != a1d->bBitResolution)
d2261 1
a2261 1
		if (p->hw_encoding != alts[i].encoding)
d2268 1
a2268 1
			if (UA_SAMP_LO(a1d) <= rate && rate <= UA_SAMP_HI(a1d))
d2293 1
a2293 1
		 p->sample_rate, p->hw_channels, p->hw_precision));
d2307 1
a2307 1
			p->hw_sample_rate = rate;
d2314 1
a2314 1
			p->hw_sample_rate = max;
d2320 1
a2320 1
			p->hw_sample_rate = min;
d2339 1
a2339 1
		p->hw_channels = n;
d2347 1
a2347 1
	p->hw_channels = 1;
d2367 2
a2368 2
	if ((usemode == AUMODE_RECORD && sc->sc_recchan.pipe != NULL)
	    || (usemode == AUMODE_PLAY && sc->sc_playchan.pipe != NULL))
d2405 1
a2405 1
					p->hw_precision = 16;
d2432 1
a2432 1
					p->hw_precision = 16;
d2451 1
a2451 1
				p->hw_precision = 16;
d2474 1
a2474 1
				p->hw_precision = 16;
d2496 1
a2496 1
			 p->channels, p->hw_precision, enc, p->sample_rate));
d2498 1
a2498 1
		p->hw_encoding = enc;
d2518 1
a2518 1
		uaudio_chan_init(&sc->sc_playchan, paltidx, play, 0);
d2522 1
a2522 2
		uaudio_chan_init(&sc->sc_recchan, raltidx, rec,
		    UGETW(sc->sc_alts[raltidx].edesc->wMaxPacketSize));
@


1.1.2.8
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d42 3
a44 3
 * USB audio specs: http://www.usb.org/developers/devclass_docs/audio10.pdf
 *                  http://www.usb.org/developers/devclass_docs/frmts10.pdf
 *                  http://www.usb.org/developers/devclass_docs/termt10.pdf
@


