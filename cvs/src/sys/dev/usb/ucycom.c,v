head	1.36;
access;
symbols
	OPENBSD_6_2:1.36.0.4
	OPENBSD_6_2_BASE:1.36
	OPENBSD_6_1:1.34.0.8
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.34.0.6
	OPENBSD_6_0_BASE:1.34
	OPENBSD_5_9:1.34.0.2
	OPENBSD_5_9_BASE:1.34
	OPENBSD_5_8:1.32.0.6
	OPENBSD_5_8_BASE:1.32
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.29.0.4
	OPENBSD_5_6_BASE:1.29
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.22.0.2
	OPENBSD_5_4_BASE:1.22
	OPENBSD_5_3:1.20.0.8
	OPENBSD_5_3_BASE:1.20
	OPENBSD_5_2:1.20.0.6
	OPENBSD_5_2_BASE:1.20
	OPENBSD_5_1_BASE:1.20
	OPENBSD_5_1:1.20.0.4
	OPENBSD_5_0:1.20.0.2
	OPENBSD_5_0_BASE:1.20
	OPENBSD_4_9:1.19.0.2
	OPENBSD_4_9_BASE:1.19
	OPENBSD_4_8:1.16.0.2
	OPENBSD_4_8_BASE:1.16
	OPENBSD_4_7:1.15.0.2
	OPENBSD_4_7_BASE:1.15
	OPENBSD_4_6:1.14.0.8
	OPENBSD_4_6_BASE:1.14
	OPENBSD_4_5:1.14.0.4
	OPENBSD_4_5_BASE:1.14
	OPENBSD_4_4:1.14.0.2
	OPENBSD_4_4_BASE:1.14
	OPENBSD_4_3:1.13.0.2
	OPENBSD_4_3_BASE:1.13
	OPENBSD_4_2:1.11.0.2
	OPENBSD_4_2_BASE:1.11
	OPENBSD_4_1:1.4.0.2
	OPENBSD_4_1_BASE:1.4
	OPENBSD_4_0:1.4.0.4
	OPENBSD_4_0_BASE:1.4;
locks; strict;
comment	@ * @;


1.36
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.35;
commitid	6s3MfY9d6ZKdL2Uz;

1.35
date	2017.04.06.04.48.54;	author deraadt;	state Exp;
branches;
next	1.34;
commitid	NjLNzmb74PcRT1Se;

1.34
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.33;
commitid	KAeCDAijcgEnOtfF;

1.33
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.32;
commitid	kI4H556ZKYkRQGw5;

1.32
date	2015.01.04.08.42.04;	author jsg;	state Exp;
branches;
next	1.31;
commitid	QKLNilFk0Q11BXy0;

1.31
date	2014.12.11.18.55.15;	author mpi;	state Exp;
branches;
next	1.30;
commitid	pE36XvX3wyW46uXj;

1.30
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.29;
commitid	L2P5oN9ppxqXZsYS;

1.29
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.28;
commitid	PSjXNz8dGohZ6ZSK;

1.28
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.27;
commitid	OBNa5kfxQ2UXoiIw;

1.27
date	2014.05.07.08.17.21;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.25;

1.25
date	2014.03.19.08.59.36;	author mpi;	state Exp;
branches;
next	1.24;

1.24
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.07.12.52.15;	author pirofti;	state Exp;
branches;
next	1.22;

1.22
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.20;

1.20
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.19;

1.19
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.19.21.32.57;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.16;

1.16
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.15;

1.15
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.13;

1.13
date	2007.09.11.13.39.34;	author gilles;	state Exp;
branches;
next	1.12;

1.12
date	2007.09.10.16.29.28;	author fgsch;	state Exp;
branches;
next	1.11;

1.11
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.7;

1.7
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.6;

1.6
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2006.08.24.12.14.23;	author jason;	state Exp;
branches;
next	1.3;

1.3
date	2006.08.18.23.08.45;	author jason;	state Exp;
branches;
next	1.2;

1.2
date	2006.08.16.21.22.56;	author jason;	state Exp;
branches;
next	1.1;

1.1
date	2006.08.15.16.41.02;	author jason;	state Exp;
branches;
next	;


desc
@@


1.36
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: ucycom.c,v 1.35 2017/04/06 04:48:54 deraadt Exp $	*/
/*	$NetBSD: ucycom.c,v 1.3 2005/08/05 07:27:47 skrll Exp $	*/

/*
 * Copyright (c) 2005 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Nick Hudson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This code is based on the ucom driver.
 */

/*
 * Device driver for Cypress CY7C637xx and CY7C640/1xx series USB to
 * RS232 bridges.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/conf.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/tty.h>
#include <sys/file.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>

#include <dev/usb/ucomvar.h>

#ifdef UCYCOM_DEBUG
#define DPRINTF(x)	if (ucycomdebug) printf x
#define DPRINTFN(n, x)	if (ucycomdebug > (n)) printf x
int	ucycomdebug = 200;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/* Configuration Byte */
#define UCYCOM_RESET		0x80
#define UCYCOM_PARITY_TYPE_MASK	0x20
#define  UCYCOM_PARITY_ODD	 0x20
#define  UCYCOM_PARITY_EVEN	 0x00
#define UCYCOM_PARITY_MASK	0x10
#define  UCYCOM_PARITY_ON	 0x10
#define  UCYCOM_PARITY_OFF	 0x00
#define UCYCOM_STOP_MASK	0x08
#define  UCYCOM_STOP_BITS_2	 0x08
#define  UCYCOM_STOP_BITS_1	 0x00
#define UCYCOM_DATA_MASK	0x03
#define  UCYCOM_DATA_BITS_8	 0x03
#define  UCYCOM_DATA_BITS_7	 0x02
#define  UCYCOM_DATA_BITS_6	 0x01
#define  UCYCOM_DATA_BITS_5	 0x00

/* Modem (Input) status byte */
#define UCYCOM_RI	0x80
#define UCYCOM_DCD	0x40
#define UCYCOM_DSR	0x20
#define UCYCOM_CTS	0x10
#define UCYCOM_ERROR	0x08
#define UCYCOM_LMASK	0x07

/* Modem (Output) control byte */
#define UCYCOM_DTR	0x20
#define UCYCOM_RTS	0x10
#define UCYCOM_ORESET	0x08

struct ucycom_softc {
	struct uhidev		 sc_hdev;
	struct usbd_device	*sc_udev;

	/* uhidev parameters */
	size_t			 sc_flen;	/* feature report length */
	size_t			 sc_ilen;	/* input report length */
	size_t			 sc_olen;	/* output report length */

	uint8_t			*sc_obuf;

	uint8_t			*sc_ibuf;
	uint32_t		 sc_icnt;

	/* settings */
	uint32_t		 sc_baud;
	uint8_t			 sc_cfg;	/* Data format */
	uint8_t			 sc_mcr;	/* Modem control */
	uint8_t			 sc_msr;	/* Modem status */
	uint8_t			 sc_newmsr;	/* from HID intr */
	int			 sc_swflags;

	struct device		*sc_subdev;
};

/* Callback routines */
void	ucycom_set(void *, int, int, int);
int	ucycom_param(void *, int, struct termios *);
void	ucycom_get_status(void *, int, u_char *, u_char *);
int	ucycom_open(void *, int);
void	ucycom_close(void *, int);
void	ucycom_write(void *, int, u_char *, u_char *, u_int32_t *);
void	ucycom_read(void *, int, u_char **, u_int32_t *);

struct ucom_methods ucycom_methods = {
	NULL, /* ucycom_get_status, */
	ucycom_set,
	ucycom_param,
	NULL,
	ucycom_open,
	ucycom_close,
	ucycom_read,
	ucycom_write,
};

void ucycom_intr(struct uhidev *, void *, u_int);

const struct usb_devno ucycom_devs[] = {
	{ USB_VENDOR_CYPRESS, USB_PRODUCT_CYPRESS_USBRS232 },
	{ USB_VENDOR_DELORME, USB_PRODUCT_DELORME_EMUSB },
	{ USB_VENDOR_DELORME, USB_PRODUCT_DELORME_EMLT20 },
};

int ucycom_match(struct device *, void *, void *);
void ucycom_attach(struct device *, struct device *, void *);
int ucycom_detach(struct device *, int);

struct cfdriver ucycom_cd = {
	NULL, "ucycom", DV_DULL
};

const struct cfattach ucycom_ca = {
	sizeof(struct ucycom_softc), ucycom_match, ucycom_attach, ucycom_detach
};

int
ucycom_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;

	if (uha->reportid == UHIDEV_CLAIM_ALLREPORTID)
		return (UMATCH_NONE);

	return (usb_lookup(ucycom_devs, uha->uaa->vendor, uha->uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
ucycom_attach(struct device *parent, struct device *self, void *aux)
{
	struct ucycom_softc *sc = (struct ucycom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct usbd_device *dev = uha->parent->sc_udev;
	struct ucom_attach_args uca;
	int size, repid, err;
	void *desc;

	sc->sc_hdev.sc_intr = ucycom_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_ilen = hid_report_size(desc, size, hid_input, repid);
	sc->sc_olen = hid_report_size(desc, size, hid_output, repid);
	sc->sc_flen = hid_report_size(desc, size, hid_feature, repid);

	DPRINTF(("ucycom_open: olen %d ilen %d flen %d\n", sc->sc_ilen,
	    sc->sc_olen, sc->sc_flen));

	printf("\n");

	sc->sc_udev = dev;

	err = uhidev_open(&sc->sc_hdev);
	if (err) {
		DPRINTF(("ucycom_open: uhidev_open %d\n", err));
		return;
	}

	DPRINTF(("ucycom attach: sc %p opipe %p ipipe %p report_id %d\n",
	    sc, sc->sc_hdev.sc_parent->sc_opipe, sc->sc_hdev.sc_parent->sc_ipipe,
	    uha->reportid));

	/* bulkin, bulkout set above */
	bzero(&uca, sizeof uca);
	uca.bulkin = uca.bulkout = -1;
	uca.ibufsize = sc->sc_ilen - 1;
	uca.obufsize = sc->sc_olen - 1;
	uca.ibufsizepad = 1;
	uca.opkthdrlen = 0;
	uca.uhidev = sc->sc_hdev.sc_parent;
	uca.device = uaa->device;
	uca.iface = uaa->iface;
	uca.methods = &ucycom_methods;
	uca.arg = sc;
	uca.info = NULL;

	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
	DPRINTF(("ucycom_attach: complete %p\n", sc->sc_subdev));
}

void
ucycom_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct ucycom_softc *sc = addr;

	DPRINTF(("ucycom_get_status:\n"));

#if 0
	if (lsr != NULL)
		*lsr = sc->sc_lsr;
#endif
	if (msr != NULL)
		*msr = sc->sc_msr;
}

int
ucycom_open(void *addr, int portno)
{
	struct ucycom_softc *sc = addr;
	struct termios t;
	int err;

	DPRINTF(("ucycom_open: complete\n"));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	/* Allocate an output report buffer */
	sc->sc_obuf = malloc(sc->sc_olen, M_USBDEV, M_WAITOK | M_ZERO);

	/* Allocate an input report buffer */
	sc->sc_ibuf = malloc(sc->sc_ilen, M_USBDEV, M_WAITOK);

	DPRINTF(("ucycom_open: sc->sc_ibuf=%p sc->sc_obuf=%p \n",
	    sc->sc_ibuf, sc->sc_obuf));

	t.c_ospeed = 9600;
	t.c_cflag = CSTOPB | CS8;
	(void)ucycom_param(sc, portno, &t);

	sc->sc_mcr = UCYCOM_DTR | UCYCOM_RTS;
	sc->sc_obuf[0] = sc->sc_mcr;
	err = uhidev_write(sc->sc_hdev.sc_parent, sc->sc_obuf, sc->sc_olen);
	if (err) {
		DPRINTF(("ucycom_open: set RTS err=%d\n", err));
		return (EIO);
	}

	return (0);
}

void
ucycom_close(void *addr, int portno)
{
	struct ucycom_softc *sc = addr;
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splusb();
	if (sc->sc_obuf != NULL) {
		free(sc->sc_obuf, M_USBDEV, sc->sc_olen);
		sc->sc_obuf = NULL;
	}
	if (sc->sc_ibuf != NULL) {
		free(sc->sc_ibuf, M_USBDEV, sc->sc_ilen);
		sc->sc_ibuf = NULL;
	}
	splx(s);
}

void
ucycom_read(void *addr, int portno, u_char **ptr, u_int32_t *count)
{
	struct ucycom_softc *sc = addr;

	if (sc->sc_newmsr ^ sc->sc_msr) {
		DPRINTF(("ucycom_read: msr %d new %d\n",
		    sc->sc_msr, sc->sc_newmsr));
		sc->sc_msr = sc->sc_newmsr;
		ucom_status_change((struct ucom_softc *)sc->sc_subdev);
	}

	DPRINTF(("ucycom_read: buf %p chars %d\n", sc->sc_ibuf, sc->sc_icnt));
	*ptr = sc->sc_ibuf;
	*count = sc->sc_icnt;
}

void
ucycom_write(void *addr, int portno, u_char *to, u_char *data, u_int32_t *cnt)
{
	struct ucycom_softc *sc = addr;
	u_int32_t len;
#ifdef UCYCOM_DEBUG
	u_int32_t want = *cnt;
#endif

	/*
	 * The 8 byte output report uses byte 0 for control and byte
	 * count.
	 *
	 * The 32 byte output report uses byte 0 for control. Byte 1
	 * is used for byte count.
	 */
	len = sc->sc_olen;
	memset(to, 0, len);
	switch (sc->sc_olen) {
	case 8:
		to[0] = *cnt | sc->sc_mcr;
		memcpy(&to[1], data, *cnt);
		DPRINTF(("ucycomstart(8): to[0] = %d | %d = %d\n",
		    *cnt, sc->sc_mcr, to[0]));
		break;

	case 32:
		to[0] = sc->sc_mcr;
		to[1] = *cnt;
		memcpy(&to[2], data, *cnt);
		DPRINTF(("ucycomstart(32): to[0] = %d\nto[1] = %d\n",
		    to[0], to[1]));
		break;
	}

#ifdef UCYCOM_DEBUG
	if (ucycomdebug > 5) {
		int i;

		if (len != 0) {
			DPRINTF(("ucycomstart: to[0..%d) =", len-1));
			for (i = 0; i < len; i++)
				DPRINTF((" %02x", to[i]));
			DPRINTF(("\n"));
		}
	}
#endif
	*cnt = len;

	DPRINTFN(4,("ucycomstart: req %d chars did %d chars\n", want, len));
}

int
ucycom_param(void *addr, int portno, struct termios *t)
{
	struct ucycom_softc *sc = addr;
	uint8_t report[5];
	uint32_t baud = 0;
	uint8_t cfg;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	switch (t->c_ospeed) {
	case 600:
	case 1200:
	case 2400:
	case 4800:
	case 9600:
	case 19200:
	case 38400:
	case 57600:
#if 0
	/*
	 * Stock chips only support standard baud rates in the 600 - 57600
	 * range, but higher rates can be achieved using custom firmware.
	 */
	case 115200:
	case 153600:
	case 192000:
#endif
		baud = t->c_ospeed;
		break;
	default:
		return (EINVAL);
	}

	if (t->c_cflag & CIGNORE) {
		cfg = sc->sc_cfg;
	} else {
		cfg = 0;
		switch (t->c_cflag & CSIZE) {
		case CS8:
			cfg |= UCYCOM_DATA_BITS_8;
			break;
		case CS7:
			cfg |= UCYCOM_DATA_BITS_7;
			break;
		case CS6:
			cfg |= UCYCOM_DATA_BITS_6;
			break;
		case CS5:
			cfg |= UCYCOM_DATA_BITS_5;
			break;
		default:
			return (EINVAL);
		}
		cfg |= ISSET(t->c_cflag, CSTOPB) ?
		    UCYCOM_STOP_BITS_2 : UCYCOM_STOP_BITS_1;
		cfg |= ISSET(t->c_cflag, PARENB) ?
		    UCYCOM_PARITY_ON : UCYCOM_PARITY_OFF;
		cfg |= ISSET(t->c_cflag, PARODD) ?
		    UCYCOM_PARITY_ODD : UCYCOM_PARITY_EVEN;
	}

	DPRINTF(("ucycom_param: setting %d baud, %d-%c-%d (%d)\n", baud,
	    5 + (cfg & UCYCOM_DATA_MASK),
	    (cfg & UCYCOM_PARITY_MASK) ?
		((cfg & UCYCOM_PARITY_TYPE_MASK) ? 'O' : 'E') : 'N',
	    (cfg & UCYCOM_STOP_MASK) ? 2 : 1, cfg));

	report[0] = baud & 0xff;
	report[1] = (baud >> 8) & 0xff;
	report[2] = (baud >> 16) & 0xff;
	report[3] = (baud >> 24) & 0xff;
	report[4] = cfg;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, report, sc->sc_flen) != sc->sc_flen)
		return EIO;
	sc->sc_baud = baud;
	return (0);
}

void
ucycom_intr(struct uhidev *addr, void *ibuf, u_int len)
{
	extern void ucomreadcb(struct usbd_xfer *, void *, usbd_status);
	struct ucycom_softc *sc = (struct ucycom_softc *)addr;
	uint8_t *cp = ibuf;
	int n, st, s;

	/* not accepting data anymore.. */
	if (sc->sc_ibuf == NULL)
		return;

	/* We understand 8 byte and 32 byte input records */
	switch (len) {
	case 8:
		n = cp[0] & UCYCOM_LMASK;
		st = cp[0] & ~UCYCOM_LMASK;
		cp++;
		break;

	case 32:
		st = cp[0];
		n = cp[1];
		cp += 2;
		break;

	default:
		DPRINTFN(3,("ucycom_intr: Unknown input report length\n"));
		return;
	}

#ifdef UCYCOM_DEBUG
	if (ucycomdebug > 5) {
		u_int32_t i;

		if (n != 0) {
			DPRINTF(("ucycom_intr: ibuf[0..%d) =", n));
			for (i = 0; i < n; i++)
				DPRINTF((" %02x", cp[i]));
			DPRINTF(("\n"));
		}
	}
#endif

	if (n > 0 || st != sc->sc_msr) {
		s = spltty();
		sc->sc_newmsr = st;
		bcopy(cp, sc->sc_ibuf, n);
		sc->sc_icnt = n;
		ucomreadcb(addr->sc_parent->sc_ixfer, sc->sc_subdev,
		    USBD_NORMAL_COMPLETION);
		splx(s);
	}
}

void
ucycom_set(void *addr, int portno, int reg, int onoff)
{
	struct ucycom_softc *sc = addr;
	int err;

	switch (reg) {
	case UCOM_SET_DTR:
		if (onoff)
			SET(sc->sc_mcr, UCYCOM_DTR);
		else
			CLR(sc->sc_mcr, UCYCOM_DTR);
		break;
	case UCOM_SET_RTS:
		if (onoff)
			SET(sc->sc_mcr, UCYCOM_RTS);
		else
			CLR(sc->sc_mcr, UCYCOM_RTS);
		break;
	case UCOM_SET_BREAK:
		break;
	}

	memset(sc->sc_obuf, 0, sc->sc_olen);
	sc->sc_obuf[0] = sc->sc_mcr;

	err = uhidev_write(sc->sc_hdev.sc_parent, sc->sc_obuf, sc->sc_olen);
	if (err)
		DPRINTF(("ucycom_set_status: err=%d\n", err));
}

int
ucycom_detach(struct device *self, int flags)
{
	struct ucycom_softc *sc = (struct ucycom_softc *)self;

	DPRINTF(("ucycom_detach: sc=%p flags=%d\n", sc, flags));
	if (sc->sc_subdev != NULL) {
		config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);

	return (0);
}
@


1.35
log
@Unify a few attach-time patterns between usb *com drivers, and remove
extra zero'ing of variables not needed because softc is pre-zero'd.
ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.34 2016/01/09 04:14:42 jcs Exp $	*/
d294 1
a294 1
		free(sc->sc_obuf, M_USBDEV, 0);
d298 1
a298 1
		free(sc->sc_ibuf, M_USBDEV, 0);
@


1.34
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.33 2016/01/08 15:54:14 jcs Exp $	*/
a203 2
	sc->sc_msr = sc->sc_mcr = 0;

a216 1
	uca.uhidev = sc->sc_hdev.sc_parent;
d221 1
@


1.33
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.32 2015/01/04 08:42:04 jsg Exp $	*/
a58 2

#include <dev/hid/hid.h>
@


1.32
log
@return 0 for success in ucycom_param() instead of uninitialised memory
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.31 2014/12/11 18:55:15 mpi Exp $	*/
a56 1
#include <dev/usb/hid.h>
d59 2
@


1.31
log
@Make sure you'll never look at stack garbage, prodded by kettenis@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.30 2014/12/11 18:39:27 mpi Exp $	*/
a382 1
	int err;
d454 1
a454 1
	return (err);
@


1.30
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.29 2014/07/12 20:26:33 mpi Exp $	*/
a146 2
void ucycom_get_cfg(struct ucycom_softc *);

a372 3
#if 0
	ucycom_get_cfg(sc);
#endif
a541 17
}

void
ucycom_get_cfg(struct ucycom_softc *sc)
{
	int cfg, baud;
	uint8_t report[5];

	uhidev_get_report(sc->sc_hdev.sc_parent, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, report, sc->sc_flen);
	cfg = report[4];
	baud = (report[3] << 24) + (report[2] << 16) + (report[1] << 8) + report[0];
	DPRINTF(("ucycom_configure: device reports %d baud, %d-%c-%d (%d)\n", baud,
	    5 + (cfg & UCYCOM_DATA_MASK),
	    (cfg & UCYCOM_PARITY_MASK) ?
		((cfg & UCYCOM_PARITY_TYPE_MASK) ? 'O' : 'E') : 'N',
	    (cfg & UCYCOM_STOP_MASK) ? 2 : 1, cfg));
@


1.29
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.28 2014/07/12 18:48:52 tedu Exp $	*/
d456 2
a457 5
	err = uhidev_set_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
	    sc->sc_hdev.sc_report_id, report, sc->sc_flen);
	if (err != 0) {
		DPRINTF(("ucycom_param: uhidev_set_report %d %s\n",
		    err, usbd_errstr(err)));
a458 1
	}
d552 1
a552 1
	int err, cfg, baud;
d555 1
a555 1
	err = uhidev_get_report(&sc->sc_hdev, UHID_FEATURE_REPORT,
@


1.28
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.27 2014/05/07 08:17:21 mpi Exp $	*/
d155 10
a164 15
int ucycom_match(struct device *, void *, void *); 
void ucycom_attach(struct device *, struct device *, void *); 
int ucycom_detach(struct device *, int); 
int ucycom_activate(struct device *, int); 

struct cfdriver ucycom_cd = { 
	NULL, "ucycom", DV_DULL 
}; 

const struct cfattach ucycom_ca = { 
	sizeof(struct ucycom_softc), 
	ucycom_match, 
	ucycom_attach, 
	ucycom_detach, 
	ucycom_activate, 
a583 15
	return (0);
}

int
ucycom_activate(struct device *self, int act)
{
	struct ucycom_softc *sc = (struct ucycom_softc *)self;

	DPRINTFN(5,("ucycom_activate: %d\n", act));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.27
log
@Make sure to call uhidev_close() upon detach for every HID driver calling
uhidev_open() at attach time.  This plugs up to 3 xfer leaks and a buffer
one.

ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.26 2014/04/15 09:14:27 mpi Exp $	*/
d304 1
a304 1
		free(sc->sc_obuf, M_USBDEV);
d308 1
a308 1
		free(sc->sc_ibuf, M_USBDEV);
@


1.26
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.25 2014/03/19 08:59:36 mpi Exp $	*/
d585 4
@


1.25
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.24 2013/11/15 08:25:31 pirofti Exp $	*/
d462 1
a462 1
	    report, sc->sc_flen);
d565 1
a565 1
	    report, sc->sc_flen);
@


1.24
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.23 2013/11/07 12:52:15 pirofti Exp $	*/
d177 3
a179 1
	DPRINTF(("ucycom match\n"));
@


1.23
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.22 2013/04/15 09:23:02 mglocker Exp $	*/
a589 1
	int rv = 0;
a594 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d598 1
a598 1
	return (rv);
@


1.22
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.21 2013/03/28 03:31:55 tedu Exp $	*/
a122 3

	/* flags */
	u_char			 sc_dying;
d264 1
a264 1
	if (sc->sc_dying)
d297 1
a297 1
	if (sc->sc_dying)
d393 1
a393 1
	if (sc->sc_dying)
d598 1
a598 1
		sc->sc_dying = 1;
@


1.21
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.20 2011/07/03 15:47:17 matthew Exp $	*/
d102 1
a102 1
	usbd_device_handle	 sc_udev;
d191 1
a191 1
	usbd_device_handle dev = uha->parent->sc_udev;
d476 1
a476 1
	extern void ucomreadcb(usbd_xfer_handle, usbd_private_handle, usbd_status);
@


1.20
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.19 2011/01/25 20:03:36 jakemsr Exp $	*/
a48 1
#include <sys/vnode.h>
@


1.19
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.18 2010/12/19 21:32:57 jasper Exp $	*/
a598 3
	case DVACT_ACTIVATE:
		break;

@


1.18
log
@- use usb_lookup(), these should be the last drivers that rolled their own
unneeded macro around it.
- fix a reference to the previous driver name utwitch while here

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.17 2010/09/24 08:33:59 yuo Exp $	*/
a238 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_hdev.sc_dev);
@


1.17
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.16 2010/04/20 22:05:43 tedu Exp $	*/
a157 1
#define ucycom_lookup(v, p) usb_lookup(ucycom_devs, v, p)
d182 1
a182 1
	return (ucycom_lookup(uha->uaa->vendor, uha->uaa->product) != NULL ?
@


1.16
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.15 2009/10/13 19:33:17 pirofti Exp $	*/
a586 1
	sc->sc_dying = 1;
@


1.15
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.14 2008/06/26 05:42:18 ray Exp $	*/
a46 1
#include <sys/sysctl.h>
@


1.14
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.13 2007/09/11 13:39:34 gilles Exp $	*/
d164 1
a164 1
int ucycom_activate(struct device *, enum devact); 
d597 1
a597 1
ucycom_activate(struct device *self, enum devact act)
@


1.13
log
@KNF

prompted and "much better" by marco@@, ok pyr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.12 2007/09/10 16:29:28 fgsch Exp $	*/
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.12
log
@more M_ZERO usage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.11 2007/06/14 10:11:15 mbalmer Exp $	*/
d284 1
a284 1
	sc->sc_obuf = malloc(sc->sc_olen, M_USBDEV, M_WAITOK|M_ZERO);
@


1.11
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.10 2007/06/13 06:25:03 mbalmer Exp $	*/
d284 1
a284 1
	sc->sc_obuf = malloc(sc->sc_olen, M_USBDEV, M_WAITOK);
a296 1
	memset(sc->sc_obuf, 0, sc->sc_olen);
@


1.10
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.9 2007/06/12 16:26:36 mbalmer Exp $	*/
d168 16
a183 1
USB_DECLARE_DRIVER(ucycom);
@


1.9
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.8 2007/06/10 10:53:48 mbalmer Exp $	*/
d110 2
a111 2
	struct uhidev		sc_hdev;
	usbd_device_handle	sc_udev;
d114 3
a116 3
	size_t			sc_flen; /* feature report length */
	size_t			sc_ilen; /* input report length */
	size_t			sc_olen; /* output report length */
d121 1
a121 1
	uint32_t		sc_icnt;
d124 6
a129 6
	uint32_t		sc_baud;
	uint8_t			sc_cfg;	/* Data format */
	uint8_t			sc_mcr;	/* Modem control */
	uint8_t			sc_msr;	/* Modem status */
	uint8_t			sc_newmsr; /* from HID intr */
	int			sc_swflags;
d131 1
a131 1
	struct device *		sc_subdev;
d134 1
a134 1
	u_char			sc_dying;
@


1.8
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.7 2007/06/05 08:43:55 mbalmer Exp $	*/
d131 1
a131 1
	device_ptr_t		sc_subdev;
d590 1
a590 1
ucycom_activate(device_ptr_t self, enum devact act)
@


1.7
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.6 2007/05/27 04:00:25 jsg Exp $	*/
d235 1
a235 1
			   USBDEV(sc->sc_hdev.sc_dev));
@


1.6
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.5 2007/05/21 05:40:28 jsg Exp $	*/
d138 7
a144 7
Static void	ucycom_set(void *, int, int, int);
Static int	ucycom_param(void *, int, struct termios *);
Static void	ucycom_get_status(void *, int, u_char *, u_char *);
Static int	ucycom_open(void *, int);
Static void	ucycom_close(void *, int);
Static void	ucycom_write(void *, int, u_char *, u_char *, u_int32_t *);
Static void	ucycom_read(void *, int, u_char **, u_int32_t *);
d157 1
a157 1
Static void ucycom_intr(struct uhidev *, void *, u_int);
d159 1
a159 1
Static void ucycom_get_cfg(struct ucycom_softc *);
d161 1
a161 1
Static const struct usb_devno ucycom_devs[] = {
d314 1
a314 1
Static void
d331 1
a331 1
Static void
d386 1
a386 1
Static int
d472 1
a472 1
Static void
d527 1
a527 1
Static void
d558 1
a558 1
Static void
@


1.5
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.4 2006/08/24 12:14:23 jason Exp $	*/
d170 2
a171 1
USB_MATCH(ucycom)
d180 2
a181 1
USB_ATTACH(ucycom)
d183 2
a184 1
	USB_ATTACH_START(ucycom, sc, uaa);
a238 2

	USB_ATTACH_SUCCESS_RETURN;
@


1.4
log
@when shutting down, wrap the variable manipulation in splusb() so weird
stuff doesn't happen if we're interrupted.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.3 2006/08/18 23:08:45 jason Exp $	*/
d71 2
a72 2
#define DPRINTF(x)	if (ucycomdebug) logprintf x
#define DPRINTFN(n, x)	if (ucycomdebug > (n)) logprintf x
@


1.3
log
@get the attach args from the right place (honestly, this "worked" on i386)
sparc64? not so much.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.2 2006/08/16 21:22:56 jason Exp $	*/
d296 1
d301 2
a302 2
//	uhidev_close(&sc->sc_hdev);
	if (sc->sc_obuf !=NULL) {
d306 1
a306 1
	if (sc->sc_ibuf !=NULL) {
d310 1
@


1.2
log
@remove unecessary debugging stuff
@
text
@d1 1
a1 1
/*	$OpenBSD: ucycom.c,v 1.1 2006/08/15 16:41:02 jason Exp $	*/
d182 2
a183 2
	usbd_device_handle dev = uaa->device;
	struct uhidev_attach_arg *uha = aux;
@


1.1
log
@a start at the port of ucycom from netbsd (I have an delorme earthmate and
it's damn well going to work correctly soon)
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a69 1
#define UCYCOM_DEBUG
a158 1
#ifdef UCYCOM_DEBUG
a159 1
#endif
a299 1
	printf("UHIDEV_CLOSE\n");
a475 2

	printf("ucycom_intr: %p %p %d\n", addr, ibuf, len);
@

