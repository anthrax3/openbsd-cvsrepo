head	1.17;
access;
symbols
	OPENBSD_6_2_BASE:1.17
	OPENBSD_6_1:1.16.0.8
	OPENBSD_6_1_BASE:1.16
	OPENBSD_6_0:1.16.0.6
	OPENBSD_6_0_BASE:1.16
	OPENBSD_5_9:1.16.0.2
	OPENBSD_5_9_BASE:1.16
	OPENBSD_5_8:1.14.0.6
	OPENBSD_5_8_BASE:1.14
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.8.0.4
	OPENBSD_5_5_BASE:1.8
	OPENBSD_5_4:1.7.0.2
	OPENBSD_5_4_BASE:1.7
	OPENBSD_5_3:1.5.0.8
	OPENBSD_5_3_BASE:1.5
	OPENBSD_5_2:1.5.0.6
	OPENBSD_5_2_BASE:1.5
	OPENBSD_5_1_BASE:1.5
	OPENBSD_5_1:1.5.0.4
	OPENBSD_5_0:1.5.0.2
	OPENBSD_5_0_BASE:1.5
	OPENBSD_4_9:1.3.0.2
	OPENBSD_4_9_BASE:1.3;
locks; strict;
comment	@ * @;


1.17
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.16;
commitid	6s3MfY9d6ZKdL2Uz;

1.16
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.15;
commitid	KAeCDAijcgEnOtfF;

1.15
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.14;
commitid	kI4H556ZKYkRQGw5;

1.14
date	2014.12.11.18.39.28;	author mpi;	state Exp;
branches;
next	1.13;
commitid	L2P5oN9ppxqXZsYS;

1.13
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.12;
commitid	OBNa5kfxQ2UXoiIw;

1.12
date	2014.05.07.08.17.21;	author mpi;	state Exp;
branches;
next	1.11;

1.11
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2014.03.19.08.59.37;	author mpi;	state Exp;
branches;
next	1.9;

1.9
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.8;

1.8
date	2013.08.17.08.34.45;	author sthen;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.4;

1.4
date	2011.03.02.07.15.45;	author jasper;	state Exp;
branches;
next	1.3;

1.3
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.2;

1.2
date	2010.12.19.21.32.58;	author jasper;	state Exp;
branches;
next	1.1;

1.1
date	2010.09.23.14.33.34;	author yuo;	state Exp;
branches;
next	;


desc
@@


1.17
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: utwitch.c,v 1.16 2016/01/09 04:14:42 jcs Exp $ */

/*
 * Copyright (c) 2010 Yojiro UO <yuo@@nui.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/* Driver for Maywa-Denki & KAYAC YUREX BBU sensor */
/* this driver was previously known as uyurex(4). */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/sensors.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/uhidev.h>

#define	CMD_NONE	0xf0
#define CMD_EOF		0x0d
#define CMD_ACK		0x21
#define	CMD_MODE	0x41 /* XXX */
#define	CMD_VALUE	0x43
#define CMD_READ	0x52
#define CMD_WRITE	0x53
#define CMD_PADDING	0xff

#define UPDATE_TICK	5 /* sec */

#ifdef UYUREX_DEBUG
#define DPRINTF(x)	do { printf x; } while (0)
#else
#define DPRINTF(x)
#endif

struct utwitch_softc {
	struct uhidev		 sc_hdev;
	struct usbd_device	*sc_udev;

	/* uhidev parameters */
	size_t			 sc_flen;	/* feature report length */
	size_t			 sc_ilen;	/* input report length */
	size_t			 sc_olen;	/* output report length */

	uint8_t			*sc_ibuf;

	/* sensor framework */
	struct ksensor		 sc_sensor_val;
	struct ksensor		 sc_sensor_delta;
	struct ksensordev	 sc_sensordev;
	struct sensor_task	*sc_sensortask;

	/* device private */
	int			 sc_initialized;
	uint8_t			 issueing_cmd;
	uint8_t			 accepted_cmd;

	uint32_t		 sc_curval;
	uint32_t		 sc_oldval;
};

const struct usb_devno utwitch_devs[] = {
	{ USB_VENDOR_MICRODIA, USB_PRODUCT_MICRODIA_YUREX},
};

int utwitch_match(struct device *, void *, void *);
void utwitch_attach(struct device *, struct device *, void *);
int utwitch_detach(struct device *, int);

void utwitch_set_mode(struct utwitch_softc *, uint8_t);
void utwitch_read_value_request(struct utwitch_softc *);
void utwitch_write_value_request(struct utwitch_softc *, uint32_t);

void utwitch_intr(struct uhidev *, void *, u_int);
void utwitch_refresh(void *);

struct cfdriver utwitch_cd = {
	NULL, "utwitch", DV_DULL
};

const struct cfattach utwitch_ca = {
	sizeof(struct utwitch_softc),
	utwitch_match,
	utwitch_attach,
	utwitch_detach
};

int
utwitch_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;

	if (uha->reportid == UHIDEV_CLAIM_ALLREPORTID)
		return (UMATCH_NONE);

	return (usb_lookup(utwitch_devs, uha->uaa->vendor, uha->uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
utwitch_attach(struct device *parent, struct device *self, void *aux)
{
	struct utwitch_softc *sc = (struct utwitch_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	struct usbd_device *dev = uha->parent->sc_udev;
	int size, repid, err;
	void *desc;

	sc->sc_udev = dev;
	sc->sc_hdev.sc_intr = utwitch_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_ilen = hid_report_size(desc, size, hid_input, repid);
	sc->sc_olen = hid_report_size(desc, size, hid_output, repid);
	sc->sc_flen = hid_report_size(desc, size, hid_feature, repid);

	err = uhidev_open(&sc->sc_hdev);
	if (err) {
		printf("utwitch_open: uhidev_open %d\n", err);
		return;
	}
	sc->sc_ibuf = malloc(sc->sc_ilen, M_USBDEV, M_WAITOK);

	printf("\n");


	/* attach sensor */
	strlcpy(sc->sc_sensordev.xname, sc->sc_hdev.sc_dev.dv_xname,
	    sizeof(sc->sc_sensordev.xname));

	/* add BBU sensor */
	sc->sc_sensor_val.type = SENSOR_INTEGER;
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor_val);
	strlcpy(sc->sc_sensor_val.desc, "BBU",
		sizeof(sc->sc_sensor_val.desc));

	/* add BBU delta sensor */
	sc->sc_sensor_delta.type = SENSOR_INTEGER;
	sensor_attach(&sc->sc_sensordev, &sc->sc_sensor_delta);
	strlcpy(sc->sc_sensor_delta.desc, "mBBU/sec",
		sizeof(sc->sc_sensor_delta.desc));

	sc->sc_sensortask = sensor_task_register(sc, utwitch_refresh, UPDATE_TICK);
	if (sc->sc_sensortask == NULL) {
		printf(", unable to register update task\n");
		return;
	}
	sensordev_install(&sc->sc_sensordev);

	DPRINTF(("utwitch_attach: complete\n"));

	/* init device */ /* XXX */
	utwitch_set_mode(sc, 0);
}

int
utwitch_detach(struct device *self, int flags)
{
	struct utwitch_softc *sc = (struct utwitch_softc *)self;
	int rv = 0;

	wakeup(&sc->sc_sensortask);
	sensordev_deinstall(&sc->sc_sensordev);
	sensor_detach(&sc->sc_sensordev, &sc->sc_sensor_val);
	sensor_detach(&sc->sc_sensordev, &sc->sc_sensor_delta);
	if (sc->sc_sensortask != NULL)
		sensor_task_unregister(sc->sc_sensortask);

	if (sc->sc_hdev.sc_state & UHIDEV_OPEN)
		uhidev_close(&sc->sc_hdev);

	if (sc->sc_ibuf != NULL) {
		free(sc->sc_ibuf, M_USBDEV, sc->sc_ilen);
		sc->sc_ibuf = NULL;
	}

	return (rv);
}

void
utwitch_intr(struct uhidev *addr, void *ibuf, u_int len)
{
	struct utwitch_softc *sc = (struct utwitch_softc *)addr;
	uint8_t buf[8];
	uint32_t val;

	if (sc->sc_ibuf == NULL)
		return;

	/* process requests */
	memcpy(buf, ibuf, 8);
	DPRINTF(("intr: %.2x %.2x %.2x %.2x %.2x %.2x %.2x %.2x\n",
		buf[0], buf[1], buf[2], buf[3],
		buf[4], buf[5], buf[6], buf[7]));


	switch (buf[0]) {
	case CMD_ACK:
		if (buf[1] == sc->issueing_cmd) {
			DPRINTF(("ack received for cmd 0x%.2x\n", buf[1]));
			sc->accepted_cmd = buf[1];
		} else {
			DPRINTF(("cmd-ack mismatch: recved 0x%.2x, expect 0x%.2x\n",
				buf[1], sc->issueing_cmd));
			/* discard previous command */
			sc->accepted_cmd = CMD_NONE;
			sc->issueing_cmd = CMD_NONE;
		}
		break;
	case CMD_READ:
	case CMD_VALUE:
		val = (buf[2] << 24) + (buf[3] << 16) + (buf[4] << 8)  + buf[5];
		if (!sc->sc_initialized) {
			sc->sc_oldval = val;
			sc->sc_initialized = 1;
		}
		sc->sc_sensor_val.value = val;
		sc->sc_curval = val;
		DPRINTF(("recv value update message: %d\n", val));
		break;
	default:
		DPRINTF(("unknown message: 0x%.2x\n", buf[0]));
	}

	return;
}

void
utwitch_refresh(void *arg)
{
	struct utwitch_softc *sc = arg;

	if (!sc->sc_initialized) {
		utwitch_read_value_request(sc);
	} else {
		/* calculate delta value */
		sc->sc_sensor_delta.value =
			(1000 * (sc->sc_curval - sc->sc_oldval)) / UPDATE_TICK;
		sc->sc_oldval = sc->sc_curval;
	}
}

void
utwitch_set_mode(struct utwitch_softc *sc, uint8_t val)
{
	uint8_t req[8];

	memset(req, CMD_PADDING, sizeof(req));
	req[0] = CMD_MODE;
	req[1] = val;
	req[2] = CMD_EOF;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen) != sc->sc_olen) {
		printf("uhidev_set_report error:EIO\n");
		return;
	}

	/* wait ack */
	tsleep(&sc->sc_sensortask, 0, "utwitch", (1000*hz+999)/1000 + 1);
}

void
utwitch_read_value_request(struct utwitch_softc *sc)
{
	uint8_t req[8];

	memset(req, CMD_PADDING, sizeof(req));
	req[0] = CMD_READ;
	req[1] = CMD_EOF;
	sc->issueing_cmd = CMD_READ;
	sc->accepted_cmd = CMD_NONE;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen) != sc->sc_olen)
		return;

	/* wait till sensor data are updated, 500ms will be enough */
	tsleep(&sc->sc_sensortask, 0, "utwitch", (500*hz+999)/1000 + 1);
}

void
utwitch_write_value_request(struct utwitch_softc *sc, uint32_t val)
{
	uint32_t v;
	uint8_t req[8];

	req[0] = CMD_WRITE;
	req[1] = 0;
	req[6] = CMD_EOF;
	req[7] = CMD_PADDING;
	v = htobe32(val);
	memcpy(req + 2, &v, sizeof(uint32_t));

	sc->issueing_cmd = CMD_WRITE;
	sc->accepted_cmd = CMD_NONE;
	if (uhidev_set_report(sc->sc_hdev.sc_parent, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen) != sc->sc_olen)
		return;

	/* wait till sensor data are updated, 250ms will be enough */
	tsleep(&sc->sc_sensortask, 0, "utwitch", (250*hz+999)/1000 + 1);
}
@


1.16
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.15 2016/01/08 15:54:14 jcs Exp $ */
d195 1
a195 1
		free(sc->sc_ibuf, M_USBDEV, 0);
@


1.15
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.14 2014/12/11 18:39:28 mpi Exp $ */
a35 2

#include <dev/hid/hid.h>
@


1.14
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.13 2014/07/12 18:48:53 tedu Exp $ */
d36 2
a37 1
#include <dev/usb/hid.h>
@


1.13
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.12 2014/05/07 08:17:21 mpi Exp $ */
a269 1
	usbd_status err;
d275 2
a276 3
	err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen);
	if (err) {
d295 2
a296 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen))
d318 2
a319 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
	    sc->sc_hdev.sc_report_id, req, sc->sc_olen))
@


1.12
log
@Make sure to call uhidev_close() upon detach for every HID driver calling
uhidev_open() at attach time.  This plugs up to 3 xfer leaks and a buffer
one.

ok yuo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.11 2014/04/15 09:14:27 mpi Exp $ */
d196 1
a196 1
		free(sc->sc_ibuf, M_USBDEV);
@


1.11
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.10 2014/03/19 08:59:37 mpi Exp $ */
d191 3
@


1.10
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.9 2014/03/07 18:39:02 mpi Exp $ */
d273 2
a274 2
	err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, req,
		sc->sc_olen);
d294 2
a295 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, req,
		sc->sc_olen))
d317 2
a318 2
	if (uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT, req,
		sc->sc_olen))
@


1.9
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.8 2013/08/17 08:34:45 sthen Exp $ */
d110 4
a113 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
@


1.8
log
@Remove unnecessary activate functions and unused DPRINTFN macros.
Req by and OK mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.7 2013/04/15 09:23:02 mglocker Exp $ */
a36 4

#ifdef USB_DEBUG
#define UYUREX_DEBUG
#endif
@


1.7
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.6 2013/03/28 03:58:03 tedu Exp $ */
d54 1
a54 2
int	utwitchdebug = 0;
#define DPRINTFN(n, x)	do { if (utwitchdebug > (n)) printf x; } while (0)
d56 1
a56 1
#define DPRINTFN(n, x)
a58 2
#define DPRINTF(x) DPRINTFN(0, x)

a61 2
	u_char			 sc_dying;
	uint16_t		 sc_flag;
a91 1
int utwitch_activate(struct device *, int);
d108 1
a108 2
	utwitch_detach,
	utwitch_activate,
a186 2
	sc->sc_dying = 1;

a199 13
}

int
utwitch_activate(struct device *self, int act)
{
	struct utwitch_softc *sc = (struct utwitch_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
@


1.6
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.5 2011/07/03 15:47:17 matthew Exp $ */
d64 1
a64 1
	usbd_device_handle	 sc_udev;
d134 1
a134 1
	usbd_device_handle dev = uha->parent->sc_udev;
@


1.5
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.4 2011/03/02 07:15:45 jasper Exp $ */
a22 1
#include <sys/proc.h>
@


1.4
log
@- change recieved -> received in comments, as well as two unused defines
in pxe.h.

ok deraadt@@ sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.3 2011/01/25 20:03:36 jakemsr Exp $ */
a217 3
	case DVACT_ACTIVATE:
		break;

@


1.3
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.2 2010/12/19 21:32:58 jasper Exp $ */
d248 1
a248 1
			DPRINTF(("ack recieved for cmd 0x%.2x\n", buf[1]));
@


1.2
log
@- use usb_lookup(), these should be the last drivers that rolled their own
unneeded macro around it.
- fix a reference to the previous driver name utwitch while here

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: utwitch.c,v 1.1 2010/09/23 14:33:34 yuo Exp $ */
a156 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
a207 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_hdev.sc_dev);
@


1.1
log
@rename uyurex(4) to utwitch(4)

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD:$ */
d20 1
a20 1
/* formely the driver name was utwitch(4). */
a93 1
#define utwitch_lookup(v, p) usb_lookup(utwitch_devs, v, p)
d125 2
a126 4
	if (utwitch_lookup(uha->uaa->vendor, uha->uaa->product) == NULL)
		return UMATCH_NONE;

	return (UMATCH_VENDOR_PRODUCT);
@

