head	1.65;
access;
symbols
	OPENBSD_6_1_BASE:1.65
	OPENBSD_6_0:1.65.0.8
	OPENBSD_6_0_BASE:1.65
	OPENBSD_5_9:1.65.0.2
	OPENBSD_5_9_BASE:1.65
	OPENBSD_5_8:1.65.0.4
	OPENBSD_5_8_BASE:1.65
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.61.0.2
	OPENBSD_5_4_BASE:1.61
	OPENBSD_5_3:1.56.0.2
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.55.0.4
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.54.0.2
	OPENBSD_5_0_BASE:1.54
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.50.0.2
	OPENBSD_4_8_BASE:1.50
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.42.0.8
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.4
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.41.0.4
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.32.0.2
	OPENBSD_4_1_BASE:1.32
	OPENBSD_4_0:1.32.0.4
	OPENBSD_4_0_BASE:1.32
	OPENBSD_3_9:1.27.0.2
	OPENBSD_3_9_BASE:1.27
	OPENBSD_3_8:1.26.0.2
	OPENBSD_3_8_BASE:1.26
	OPENBSD_3_7:1.25.0.2
	OPENBSD_3_7_BASE:1.25
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.20
	SMP_SYNC_B:1.20
	OPENBSD_3_5:1.20.0.2
	OPENBSD_3_5_BASE:1.20
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.17
	OPENBSD_3_3:1.17.0.2
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.16.0.2
	OPENBSD_3_2_BASE:1.16
	OPENBSD_3_1:1.9.0.4
	OPENBSD_3_1_BASE:1.9
	UBC_SYNC_B:1.16
	UBC:1.9.0.2
	UBC_BASE:1.9
	OPENBSD_3_0:1.8.0.4
	OPENBSD_3_0_BASE:1.8
	SMP:1.8.0.2
	OPENBSD_2_9_BASE:1.7
	OPENBSD_2_9:1.7.0.2
	OPENBSD_2_8:1.5.0.2
	OPENBSD_2_8_BASE:1.5
	OPENBSD_2_7:1.3.0.2
	OPENBSD_2_7_BASE:1.3;
locks; strict;
comment	@ * @;


1.65
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.64;
commitid	p4LJxGKbi0BU2cG6;

1.64
date	2014.05.06.09.44.31;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2014.02.03.20.59.05;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.61;

1.61
date	2013.07.15.13.52.05;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.06.25.13.42.28;	author mpi;	state Exp;
branches;
next	1.59;

1.59
date	2013.06.03.16.10.56;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.57;

1.57
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.56;

1.56
date	2012.12.31.04.25.46;	author miod;	state Exp;
branches;
next	1.55;

1.55
date	2011.11.29.17.15.44;	author deraadt;	state Exp;
branches;
next	1.54;

1.54
date	2011.07.03.19.38.50;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.23.16.02.33;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.50;

1.50
date	2010.07.02.17.27.01;	author nicm;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.30.09.36.51;	author nicm;	state Exp;
branches;
next	1.48;

1.48
date	2010.06.28.14.13.35;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2010.04.12.12.57.52;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.31.12.00.08;	author fgsch;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.33;

1.33
date	2007.05.20.00.52.26;	author jsg;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.29.08.15.10;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.18.02.54.11;	author jason;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.04.27.19.31.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2006.03.27.08.19.39;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2005.04.08.04.30.17;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.28.22.38.39;	author djm;	state Exp;
branches;
next	1.24;

1.24
date	2005.01.28.22.36.46;	author djm;	state Exp;
branches;
next	1.23;

1.23
date	2005.01.19.07.49.35;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.10.08.17.49;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.03.16.44.51;	author miod;	state Exp;
branches;
next	1.19;

1.19
date	2003.08.15.20.32.18;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.19.00.33.00;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.11.03.11.17;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.07.10.21.41.50;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.10.03.09.34;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.08.18.10.37;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.06.21.51.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.04.11.44.22;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.14.22.50.25;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.08.20.03.33;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.05.00.29.14;	author aaron;	state Exp;
branches;
next	;

1.8.2.1
date	2001.05.14.22.26.20;	author niklas;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.07.04.10.43.49;	author niklas;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.8.2.4;

1.8.2.4
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.8.2.5;

1.8.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.8.2.6;

1.8.2.6
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;

1.9.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2003.05.19.22.24.07;	author tedu;	state Exp;
branches;
next	;

1.27.2.1
date	2006.10.05.06.19.59;	author brad;	state Exp;
branches;
next	;


desc
@@


1.65
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@/*	$OpenBSD: ucom.c,v 1.64 2014/05/06 09:44:31 mpi Exp $ */
/*	$NetBSD: ucom.c,v 1.49 2003/01/01 00:10:25 thorpej Exp $	*/

/*
 * Copyright (c) 1998, 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * This code is very heavily based on the 16550 driver, com.c.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/uhidev.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#include "ucom.h"

#if NUCOM > 0

#ifdef UCOM_DEBUG
#define DPRINTFN(n, x)	do { if (ucomdebug > (n)) printf x; } while (0)
int ucomdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define	UCOMUNIT_MASK		0x7f
#define	UCOMCUA_MASK		0x80

#define LINESW(tp, func)	(linesw[(tp)->t_line].func)

#define	UCOMUNIT(x)		(minor(x) & UCOMUNIT_MASK)
#define	UCOMCUA(x)		(minor(x) & UCOMCUA_MASK)

struct ucom_softc {
	struct device		sc_dev;		/* base device */

	struct usbd_device	*sc_uparent;	/* USB device */
	struct uhidev_softc	*sc_uhidev;	/* hid device (if deeper) */

	struct usbd_interface	*sc_iface;	/* data interface */

	int			sc_bulkin_no;	/* bulk in endpoint address */
	struct usbd_pipe	*sc_bulkin_pipe;/* bulk in pipe */
	struct usbd_xfer	*sc_ixfer;	/* read request */
	u_char			*sc_ibuf;	/* read buffer */
	u_int			sc_ibufsize;	/* read buffer size */
	u_int			sc_ibufsizepad;	/* read buffer size padded */

	int			sc_bulkout_no;	/* bulk out endpoint address */
	struct usbd_pipe	*sc_bulkout_pipe;/* bulk out pipe */
	struct usbd_xfer	*sc_oxfer;	/* write request */
	u_char			*sc_obuf;	/* write buffer */
	u_int			sc_obufsize;	/* write buffer size */
	u_int			sc_opkthdrlen;	/* header length of
						 * output packet */

	struct usbd_pipe	*sc_ipipe;	/* hid interrupt input pipe */
	struct usbd_pipe	*sc_opipe;	/* hid interrupt pipe */

	struct ucom_methods     *sc_methods;
	void                    *sc_parent;
	int			sc_portno;

	struct tty		*sc_tty;	/* our tty */
	u_char			sc_lsr;
	u_char			sc_msr;
	u_char			sc_mcr;
	u_char			sc_tx_stopped;
	int			sc_swflags;

	u_char			sc_cua;

	struct rwlock		sc_lock;	/* lock during open */
	int			sc_open;
	int			sc_refcnt;
};

void	ucom_cleanup(struct ucom_softc *);
void	ucom_hwiflow(struct ucom_softc *);
int	ucomparam(struct tty *, struct termios *);
void	ucomstart(struct tty *);
void	ucom_shutdown(struct ucom_softc *);
int	ucom_do_open(dev_t, int, int, struct proc *);
int	ucom_do_ioctl(struct ucom_softc *, u_long, caddr_t, int, struct proc *);
int	ucom_do_close(struct ucom_softc *, int, int , struct proc *);
void	ucom_dtr(struct ucom_softc *, int);
void	ucom_rts(struct ucom_softc *, int);
void	ucom_break(struct ucom_softc *, int);
usbd_status ucomstartread(struct ucom_softc *);
void	ucomreadcb(struct usbd_xfer *, void *, usbd_status);
void	ucomwritecb(struct usbd_xfer *, void *, usbd_status);
void	tiocm_to_ucom(struct ucom_softc *, u_long, int);
int	ucom_to_tiocm(struct ucom_softc *);
void	ucom_lock(struct ucom_softc *);
void	ucom_unlock(struct ucom_softc *);

int ucom_match(struct device *, void *, void *); 
void ucom_attach(struct device *, struct device *, void *); 
int ucom_detach(struct device *, int); 

struct cfdriver ucom_cd = { 
	NULL, "ucom", DV_TTY 
}; 

const struct cfattach ucom_ca = { 
	sizeof(struct ucom_softc), 
	ucom_match, 
	ucom_attach, 
	ucom_detach, 
};

void
ucom_lock(struct ucom_softc *sc)
{
	rw_enter_write(&sc->sc_lock);
}

void
ucom_unlock(struct ucom_softc *sc)
{
	rw_exit_write(&sc->sc_lock);
}

int
ucom_match(struct device *parent, void *match, void *aux)
{
	return (1);
}

void
ucom_attach(struct device *parent, struct device *self, void *aux)
{
	struct ucom_softc *sc = (struct ucom_softc *)self;
	struct ucom_attach_args *uca = aux;
	struct tty *tp;

	if (uca->info != NULL)
		printf(", %s", uca->info);
	printf("\n");

	sc->sc_uparent = uca->device;
	sc->sc_iface = uca->iface;
	sc->sc_bulkout_no = uca->bulkout;
	sc->sc_bulkin_no = uca->bulkin;
	sc->sc_uhidev = uca->uhidev;
	sc->sc_ibufsize = uca->ibufsize;
	sc->sc_ibufsizepad = uca->ibufsizepad;
	sc->sc_obufsize = uca->obufsize;
	sc->sc_opkthdrlen = uca->opkthdrlen;
	sc->sc_methods = uca->methods;
	sc->sc_parent = uca->arg;
	sc->sc_portno = uca->portno;

	tp = ttymalloc(1000000);
	tp->t_oproc = ucomstart;
	tp->t_param = ucomparam;
	sc->sc_tty = tp;
	sc->sc_cua = 0;

	rw_init(&sc->sc_lock, "ucomlk");
}

int
ucom_detach(struct device *self, int flags)
{
	struct ucom_softc *sc = (struct ucom_softc *)self;
	struct tty *tp = sc->sc_tty;
	int maj, mn;
	int s;

	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p, pipe=%d,%d\n",
		 sc, flags, tp, sc->sc_bulkin_no, sc->sc_bulkout_no));

	if (sc->sc_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
	}
	if (sc->sc_ixfer != NULL) {
		if (sc->sc_bulkin_no != -1) {
			usbd_free_buffer(sc->sc_ixfer);
			sc->sc_ibuf = NULL;
			usbd_free_xfer(sc->sc_ixfer);
		}
		sc->sc_ixfer = NULL;
	}
	if (sc->sc_oxfer != NULL) {
		usbd_free_buffer(sc->sc_oxfer);
		sc->sc_obuf = NULL;
		if (sc->sc_bulkin_no != -1)
			usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
	}

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wake up anyone waiting */
		if (tp != NULL) {
			CLR(tp->t_state, TS_CARR_ON);
			CLR(tp->t_cflag, CLOCAL | MDMBUF);
			ttyflush(tp, FREAD|FWRITE);
		}
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == ucomopen)
			break;

	/* Nuke the vnodes for any open instances. */
	mn = self->dv_unit;
	DPRINTF(("ucom_detach: maj=%d mn=%d\n", maj, mn));
	vdevgone(maj, mn, mn, VCHR);
	vdevgone(maj, mn | UCOMCUA_MASK, mn | UCOMCUA_MASK, VCHR);

	/* Detach and free the tty. */
	if (tp != NULL) {
		(*LINESW(tp, l_close))(tp, FNONBLOCK, curproc);
		s = spltty();
		CLR(tp->t_state, TS_BUSY | TS_FLUSH);
		ttyclose(tp);
		splx(s);
		ttyfree(tp);
		sc->sc_tty = NULL;
	}

	return (0);
}

void
ucom_shutdown(struct ucom_softc *sc)
{
	struct tty *tp = sc->sc_tty;

	DPRINTF(("ucom_shutdown\n"));
	/*
	 * Hang up if necessary.  Wait a bit, so the other side has time to
	 * notice even if we immediately open the port again.
	 */
	if (ISSET(tp->t_cflag, HUPCL)) {
		ucom_dtr(sc, 0);
		(void)tsleep(sc, TTIPRI, ttclos, hz);
	}
}

int
ucomopen(dev_t dev, int flag, int mode, struct proc *p)
{
	int unit = UCOMUNIT(dev);
	struct ucom_softc *sc;
	int error;

	if (unit >= ucom_cd.cd_ndevs)
		return (ENXIO);
	sc = ucom_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	if (usbd_is_dying(sc->sc_uparent))
		return (EIO);

	if (ISSET(sc->sc_dev.dv_flags, DVF_ACTIVE) == 0)
		return (ENXIO);

	sc->sc_refcnt++;
	error = ucom_do_open(dev, flag, mode, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
ucom_do_open(dev_t dev, int flag, int mode, struct proc *p)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	usbd_status err;
	struct tty *tp;
	struct termios t;
	int error, s;

	/* open the pipes if this is the first open */
	ucom_lock(sc);
	s = splusb();
	if (sc->sc_open == 0) {
		DPRINTF(("ucomopen: open pipes in=%d out=%d\n",
		    sc->sc_bulkin_no, sc->sc_bulkout_no));
		DPRINTF(("ucomopen: hid %p pipes in=%p out=%p\n",
		    sc->sc_uhidev, sc->sc_ipipe, sc->sc_opipe));

		if (sc->sc_bulkin_no != -1) {

			/* Open the bulk pipes */
			err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin_no, 0,
			    &sc->sc_bulkin_pipe);
			if (err) {
				DPRINTF(("%s: open bulk out error (addr %d), err=%s\n",
				    sc->sc_dev.dv_xname, sc->sc_bulkin_no,
				    usbd_errstr(err)));
				error = EIO;
				goto fail_0;
			}
			err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout_no,
			    USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
			if (err) {
				DPRINTF(("%s: open bulk in error (addr %d), err=%s\n",
				    sc->sc_dev.dv_xname, sc->sc_bulkout_no,
				    usbd_errstr(err)));
				error = EIO;
				goto fail_1;
			}

			/* Allocate a request and an input buffer and start reading. */
			sc->sc_ixfer = usbd_alloc_xfer(sc->sc_uparent);
			if (sc->sc_ixfer == NULL) {
				error = ENOMEM;
				goto fail_2;
			}

			sc->sc_ibuf = usbd_alloc_buffer(sc->sc_ixfer,
			    sc->sc_ibufsizepad);
			if (sc->sc_ibuf == NULL) {
				error = ENOMEM;
				goto fail_2;
			}

			sc->sc_oxfer = usbd_alloc_xfer(sc->sc_uparent);
			if (sc->sc_oxfer == NULL) {
				error = ENOMEM;
				goto fail_3;
			}
		} else {
			/*
			 * input/output pipes and xfers already allocated
			 * as is the input buffer.
			 */
			sc->sc_ipipe = sc->sc_uhidev->sc_ipipe;
			sc->sc_ixfer = sc->sc_uhidev->sc_ixfer;
			sc->sc_opipe = sc->sc_uhidev->sc_opipe;
			sc->sc_oxfer = sc->sc_uhidev->sc_oxfer;
		}

		sc->sc_obuf = usbd_alloc_buffer(sc->sc_oxfer,
		    sc->sc_obufsize + sc->sc_opkthdrlen);
		if (sc->sc_obuf == NULL) {
			error = ENOMEM;
			goto fail_4;
		}

		if (sc->sc_methods->ucom_open != NULL) {
			error = sc->sc_methods->ucom_open(sc->sc_parent,
			    sc->sc_portno);
			if (error) {
				ucom_cleanup(sc);
				splx(s);
				ucom_unlock(sc);
				return (error);
			}
		}

		ucom_status_change(sc);

		ucomstartread(sc);
		sc->sc_open = 1;
	}
	splx(s);
	s = spltty();
	ucom_unlock(sc);
	tp = sc->sc_tty;
	splx(s);

	DPRINTF(("ucomopen: unit=%d, tp=%p\n", UCOMUNIT(dev), tp));

	tp->t_dev = dev;
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
		ttychars(tp);

		/*
		 * Initialize the termios status to the defaults.  Add in the
		 * sticky bits from TIOCSFLAGS.
		 */
		t.c_ispeed = 0;
		t.c_ospeed = TTYDEF_SPEED;
		t.c_cflag = TTYDEF_CFLAG;
		if (ISSET(sc->sc_swflags, TIOCFLAG_CLOCAL))
			SET(t.c_cflag, CLOCAL);
		if (ISSET(sc->sc_swflags, TIOCFLAG_CRTSCTS))
			SET(t.c_cflag, CRTSCTS);
		if (ISSET(sc->sc_swflags, TIOCFLAG_MDMBUF))
			SET(t.c_cflag, MDMBUF);

		/* Make sure ucomparam() will do something. */
		tp->t_ospeed = 0;
		(void) ucomparam(tp, &t);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;

		s = spltty();
		ttsetwater(tp);

		/*
		 * Turn on DTR.  We must always do this, even if carrier is not
		 * present, because otherwise we'd have to use TIOCSDTR
		 * immediately after setting CLOCAL, which applications do not
		 * expect.  We always assert DTR while the device is open
		 * unless explicitly requested to deassert it.
		 */
		ucom_dtr(sc, 1);

		/* XXX CLR(sc->sc_rx_flags, RX_ANY_BLOCK);*/
		ucom_hwiflow(sc);

		if (ISSET(sc->sc_swflags, TIOCFLAG_SOFTCAR) || UCOMCUA(dev) ||
		    ISSET(sc->sc_msr, UMSR_DCD) || ISSET(tp->t_cflag, MDMBUF))
			SET(tp->t_state, TS_CARR_ON);
		else
			CLR(tp->t_state, TS_CARR_ON);
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0)
		return (EBUSY);
	else
		s = spltty();

	if (UCOMCUA(dev)) {
		if (ISSET(tp->t_state, TS_ISOPEN)) {
			/* Someone is already dialed in */
			splx(s);
			return (EBUSY);
		}
		sc->sc_cua = 1;
	} else {
		/* tty (not cua) device, wait for carrier */
		if (ISSET(flag, O_NONBLOCK)) {
			if (sc->sc_cua) {
				splx(s);
				return (EBUSY);
			}
		} else {
			while (sc->sc_cua || (!ISSET(tp->t_cflag, CLOCAL) &&
			    !ISSET(tp->t_state, TS_CARR_ON))) {
				SET(tp->t_state, TS_WOPEN);
				error = ttysleep(tp, &tp->t_rawq,
				    TTIPRI | PCATCH, ttopen, 0);

				if (usbd_is_dying(sc->sc_uparent)) {
					splx(s);
					return (EIO);
				}

				/*
				 * If TS_WOPEN has been reset, that means the
				 * cua device has been closed.  We don't want
				 * to fail in that case, so just go around
				 * again.
				 */
				if (error && ISSET(tp->t_state, TS_WOPEN)) {
					CLR(tp->t_state, TS_WOPEN);
					splx(s);
					goto bad;
				}
			}
		}
	}
	splx(s);

	error = (*LINESW(tp, l_open))(dev, tp, p);
	if (error)
		goto bad;

	return (0);

fail_4:
	if (sc->sc_bulkin_no != -1)
		usbd_free_xfer(sc->sc_oxfer);
	sc->sc_oxfer = NULL;
fail_3:
	usbd_free_xfer(sc->sc_ixfer);
	sc->sc_ixfer = NULL;
fail_2:
	usbd_close_pipe(sc->sc_bulkout_pipe);
	sc->sc_bulkout_pipe = NULL;
fail_1:
	usbd_close_pipe(sc->sc_bulkin_pipe);
	sc->sc_bulkin_pipe = NULL;
fail_0:
	splx(s);
	ucom_unlock(sc);
	return (error);

bad:
	ucom_lock(sc);
	ucom_cleanup(sc);
	ucom_unlock(sc);

	return (error);
}

int
ucomclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return (EIO);

	DPRINTF(("ucomclose: unit=%d\n", UCOMUNIT(dev)));

	sc->sc_refcnt++;
	error = ucom_do_close(sc, flag, mode, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
ucom_do_close(struct ucom_softc *sc, int flag, int mode, struct proc *p)
{
	struct tty *tp = sc->sc_tty;
	int s;

	if (!ISSET(tp->t_state, TS_ISOPEN))
		return (0);

	ucom_lock(sc);

	(*LINESW(tp, l_close))(tp, flag, p);
	s = spltty();
	CLR(tp->t_state, TS_BUSY | TS_FLUSH);
	sc->sc_cua = 0;
	ttyclose(tp);
	splx(s);
	ucom_cleanup(sc);

	if (sc->sc_methods->ucom_close != NULL)
		sc->sc_methods->ucom_close(sc->sc_parent, sc->sc_portno);

	ucom_unlock(sc);

	return (0);
}

int
ucomread(dev_t dev, struct uio *uio, int flag)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	struct tty *tp;
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return (EIO);

	sc->sc_refcnt++;
	tp = sc->sc_tty;
	error = (*LINESW(tp, l_read))(tp, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
ucomwrite(dev_t dev, struct uio *uio, int flag)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	struct tty *tp;
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return (EIO);

	sc->sc_refcnt++;
	tp = sc->sc_tty;
	error = (*LINESW(tp, l_write))(tp, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

struct tty *
ucomtty(dev_t dev)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];

	/*
	 * Return a pointer to our tty even if the device is dying
	 * in order to properly close it in the detach routine.
	 */
	if (sc == NULL)
		return (NULL);

	return (sc->sc_tty);
}

int
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return (EIO);

	sc->sc_refcnt++;
	error = ucom_do_ioctl(sc, cmd, data, flag, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
ucom_do_ioctl(struct ucom_softc *sc, u_long cmd, caddr_t data,
	      int flag, struct proc *p)
{
	struct tty *tp = sc->sc_tty;
	int error;
	int s;

	DPRINTF(("ucomioctl: cmd=0x%08lx\n", cmd));

	error = (*LINESW(tp, l_ioctl))(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	error = ttioctl(tp, cmd, data, flag, p);
	if (error >= 0)
		return (error);

	if (sc->sc_methods->ucom_ioctl != NULL) {
		error = sc->sc_methods->ucom_ioctl(sc->sc_parent,
			    sc->sc_portno, cmd, data, flag, p);
		if (error != ENOTTY)
			return (error);
	}

	error = 0;

	DPRINTF(("ucomioctl: our cmd=0x%08lx\n", cmd));
	s = spltty();

	switch (cmd) {
	case TIOCSBRK:
		ucom_break(sc, 1);
		break;

	case TIOCCBRK:
		ucom_break(sc, 0);
		break;

	case TIOCSDTR:
		ucom_dtr(sc, 1);
		break;

	case TIOCCDTR:
		ucom_dtr(sc, 0);
		break;

	case TIOCGFLAGS:
		*(int *)data = sc->sc_swflags;
		break;

	case TIOCSFLAGS:
		error = suser(p, 0);
		if (error)
			break;
		sc->sc_swflags = *(int *)data;
		break;

	case TIOCMSET:
	case TIOCMBIS:
	case TIOCMBIC:
		tiocm_to_ucom(sc, cmd, *(int *)data);
		break;

	case TIOCMGET:
		*(int *)data = ucom_to_tiocm(sc);
		break;

	default:
		error = ENOTTY;
		break;
	}

	splx(s);

	return (error);
}

void
tiocm_to_ucom(struct ucom_softc *sc, u_long how, int ttybits)
{
	u_char combits;

	combits = 0;
	if (ISSET(ttybits, TIOCM_DTR))
		SET(combits, UMCR_DTR);
	if (ISSET(ttybits, TIOCM_RTS))
		SET(combits, UMCR_RTS);

	switch (how) {
	case TIOCMBIC:
		CLR(sc->sc_mcr, combits);
		break;

	case TIOCMBIS:
		SET(sc->sc_mcr, combits);
		break;

	case TIOCMSET:
		CLR(sc->sc_mcr, UMCR_DTR | UMCR_RTS);
		SET(sc->sc_mcr, combits);
		break;
	}

	if (how == TIOCMSET || ISSET(combits, UMCR_DTR))
		ucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);
	if (how == TIOCMSET || ISSET(combits, UMCR_RTS))
		ucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);
}

int
ucom_to_tiocm(struct ucom_softc *sc)
{
	u_char combits;
	int ttybits = 0;

	combits = sc->sc_mcr;
	if (ISSET(combits, UMCR_DTR))
		SET(ttybits, TIOCM_DTR);
	if (ISSET(combits, UMCR_RTS))
		SET(ttybits, TIOCM_RTS);

	combits = sc->sc_msr;
	if (ISSET(combits, UMSR_DCD))
		SET(ttybits, TIOCM_CD);
	if (ISSET(combits, UMSR_CTS))
		SET(ttybits, TIOCM_CTS);
	if (ISSET(combits, UMSR_DSR))
		SET(ttybits, TIOCM_DSR);
	if (ISSET(combits, UMSR_RI | UMSR_TERI))
		SET(ttybits, TIOCM_RI);

#if 0
XXX;
	if (sc->sc_ier != 0)
		SET(ttybits, TIOCM_LE);
#endif

	return (ttybits);
}

void
ucom_break(struct ucom_softc *sc, int onoff)
{
	DPRINTF(("ucom_break: onoff=%d\n", onoff));

	if (sc->sc_methods->ucom_set != NULL)
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
		    UCOM_SET_BREAK, onoff);
}

void
ucom_dtr(struct ucom_softc *sc, int onoff)
{
	DPRINTF(("ucom_dtr: onoff=%d\n", onoff));

	if (sc->sc_methods->ucom_set != NULL) {
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
		    UCOM_SET_DTR, onoff);
		/* When not using CRTSCTS, RTS follows DTR. */
		if (!(sc->sc_swflags & TIOCFLAG_CRTSCTS))
			ucom_rts(sc, onoff);
	}
}

void
ucom_rts(struct ucom_softc *sc, int onoff)
{
	DPRINTF(("ucom_rts: onoff=%d\n", onoff));

	if (sc->sc_methods->ucom_set != NULL)
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
		    UCOM_SET_RTS, onoff);
}

void
ucom_status_change(struct ucom_softc *sc)
{
	struct tty *tp = sc->sc_tty;
	u_char old_msr;

	if (sc->sc_methods->ucom_get_status != NULL) {
		old_msr = sc->sc_msr;
		sc->sc_methods->ucom_get_status(sc->sc_parent, sc->sc_portno,
		    &sc->sc_lsr, &sc->sc_msr);

		ttytstamp(tp, old_msr & UMSR_CTS, sc->sc_msr & UMSR_CTS,
		    old_msr & UMSR_DCD, sc->sc_msr & UMSR_DCD);

		if (ISSET((sc->sc_msr ^ old_msr), UMSR_DCD))
			(*LINESW(tp, l_modem))(tp,
			    ISSET(sc->sc_msr, UMSR_DCD));
	} else {
		sc->sc_lsr = 0;
		sc->sc_msr = 0;
	}
}

int
ucomparam(struct tty *tp, struct termios *t)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return (EIO);

	/* Check requested parameters. */
	if (t->c_ispeed && t->c_ispeed != t->c_ospeed)
		return (EINVAL);

	/*
	 * For the console, always force CLOCAL and !HUPCL, so that the port
	 * is always active.
	 */
	if (ISSET(sc->sc_swflags, TIOCFLAG_SOFTCAR)) {
		SET(t->c_cflag, CLOCAL);
		CLR(t->c_cflag, HUPCL);
	}

	/*
	 * If there were no changes, don't do anything.  This avoids dropping
	 * input and improves performance when all we did was frob things like
	 * VMIN and VTIME.
	 */
	if (tp->t_ospeed == t->c_ospeed &&
	    tp->t_cflag == t->c_cflag)
		return (0);

	/* XXX lcr = ISSET(sc->sc_lcr, LCR_SBREAK) | cflag2lcr(t->c_cflag); */

	/* And copy to tty. */
	tp->t_ispeed = 0;
	tp->t_ospeed = t->c_ospeed;
	tp->t_cflag = t->c_cflag;

	if (sc->sc_methods->ucom_param != NULL) {
		error = sc->sc_methods->ucom_param(sc->sc_parent, sc->sc_portno,
			    t);
		if (error)
			return (error);
	}

	/* XXX worry about CHWFLOW */

	/*
	 * Update the tty layer's idea of the carrier bit, in case we changed
	 * CLOCAL or MDMBUF.  We don't hang up here; we only do that by
	 * explicit request.
	 */
	DPRINTF(("ucomparam: l_modem\n"));
	(void) (*LINESW(tp, l_modem))(tp, 1 /* XXX carrier */ );

#if 0
XXX what if the hardware is not open
	if (!ISSET(t->c_cflag, CHWFLOW)) {
		if (sc->sc_tx_stopped) {
			sc->sc_tx_stopped = 0;
			ucomstart(tp);
		}
	}
#endif

	return (0);
}

/*
 * (un)block input via hw flowcontrol
 */
void
ucom_hwiflow(struct ucom_softc *sc)
{
	DPRINTF(("ucom_hwiflow:\n"));
#if 0
XXX
	bus_space_tag_t iot = sc->sc_iot;
	bus_space_handle_t ioh = sc->sc_ioh;

	if (sc->sc_mcr_rts == 0)
		return;

	if (ISSET(sc->sc_rx_flags, RX_ANY_BLOCK)) {
		CLR(sc->sc_mcr, sc->sc_mcr_rts);
		CLR(sc->sc_mcr_active, sc->sc_mcr_rts);
	} else {
		SET(sc->sc_mcr, sc->sc_mcr_rts);
		SET(sc->sc_mcr_active, sc->sc_mcr_rts);
	}
	bus_space_write_1(iot, ioh, com_mcr, sc->sc_mcr_active);
#endif
}

void
ucomstart(struct tty *tp)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];
	usbd_status err;
	int s;
	u_char *data;
	int cnt;

	if (sc == NULL || usbd_is_dying(sc->sc_uparent))
		return;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY | TS_TIMEOUT | TS_TTSTOP)) {
		DPRINTFN(4,("ucomstart: no go, state=0x%x\n", tp->t_state));
		goto out;
	}
	if (sc->sc_tx_stopped)
		goto out;

	ttwakeupwr(tp);
	if (tp->t_outq.c_cc == 0)
		goto out;

	/* Grab the first contiguous region of buffer space. */
	data = tp->t_outq.c_cf;
	cnt = ndqb(&tp->t_outq, 0);

	if (cnt == 0) {
		DPRINTF(("ucomstart: cnt==0\n"));
		goto out;
	}

	SET(tp->t_state, TS_BUSY);

	if (cnt > sc->sc_obufsize) {
		DPRINTF(("ucomstart: big buffer %d chars\n", cnt));
		cnt = sc->sc_obufsize;
	}
	if (sc->sc_methods->ucom_write != NULL)
		sc->sc_methods->ucom_write(sc->sc_parent, sc->sc_portno,
					   sc->sc_obuf, data, &cnt);
	else
		memcpy(sc->sc_obuf, data, cnt);

	DPRINTFN(4,("ucomstart: %d chars\n", cnt));
#ifdef DIAGNOSTIC
	if (sc->sc_oxfer == NULL) {
		printf("ucomstart: null oxfer\n");
		goto out;
	}
#endif
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe,
		    (void *)sc, sc->sc_obuf, cnt,
		    USBD_NO_COPY, USBD_NO_TIMEOUT, ucomwritecb);
	} else {
		usbd_setup_xfer(sc->sc_oxfer, sc->sc_opipe,
		    (void *)sc, sc->sc_obuf, cnt,
		    USBD_NO_COPY, USBD_NO_TIMEOUT, ucomwritecb);
	}
	/* What can we do on error? */
	err = usbd_transfer(sc->sc_oxfer);
#ifdef DIAGNOSTIC
	if (err != USBD_IN_PROGRESS)
		printf("ucomstart: err=%s\n", usbd_errstr(err));
#endif

out:
	splx(s);
}

int
ucomstop(struct tty *tp, int flag)
{
	DPRINTF(("ucomstop: flag=%d\n", flag));
#if 0
	/*struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];*/
	int s;

	s = spltty();
	if (ISSET(tp->t_state, TS_BUSY)) {
		DPRINTF(("ucomstop: XXX\n"));
		/* sc->sc_tx_stopped = 1; */
		if (!ISSET(tp->t_state, TS_TTSTOP))
			SET(tp->t_state, TS_FLUSH);
	}
	splx(s);
#endif
	return (0);
}

void
ucomwritecb(struct usbd_xfer *xfer, void *p, usbd_status status)
{
	struct ucom_softc *sc = (struct ucom_softc *)p;
	struct tty *tp = sc->sc_tty;
	u_int32_t cc;
	int s;

	DPRINTFN(5,("ucomwritecb: %p %p status=%d\n", xfer, p, status));

	if (status == USBD_CANCELLED || usbd_is_dying(sc->sc_uparent))
		goto error;

	if (sc->sc_bulkin_pipe != NULL) {
		if (status) {
			usbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);
			/* XXX we should restart after some delay. */
			goto error;
		}
		usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);
	} else {
		usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);
		// XXX above gives me wrong cc, no?
	}

	DPRINTFN(5,("ucomwritecb: cc=%d\n", cc));
	/* convert from USB bytes to tty bytes */
	cc -= sc->sc_opkthdrlen;

	s = spltty();
	CLR(tp->t_state, TS_BUSY);
	if (ISSET(tp->t_state, TS_FLUSH))
		CLR(tp->t_state, TS_FLUSH);
	else
		ndflush(&tp->t_outq, cc);
	(*LINESW(tp, l_start))(tp);
	splx(s);
	return;

error:
	s = spltty();
	CLR(tp->t_state, TS_BUSY);
	splx(s);
}

usbd_status
ucomstartread(struct ucom_softc *sc)
{
	usbd_status err;

	DPRINTFN(5,("ucomstartread: start\n"));
#ifdef DIAGNOSTIC
	if (sc->sc_ixfer == NULL) {
		DPRINTF(("ucomstartread: null ixfer\n"));
		return (USBD_INVAL);
	}
#endif

	if (sc->sc_bulkin_pipe != NULL) {
		usbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe,
			(void *)sc,
			sc->sc_ibuf, sc->sc_ibufsize,
			USBD_SHORT_XFER_OK | USBD_NO_COPY,
			USBD_NO_TIMEOUT, ucomreadcb);
		err = usbd_transfer(sc->sc_ixfer);
		if (err != USBD_IN_PROGRESS) {
			DPRINTF(("ucomstartread: err=%s\n", usbd_errstr(err)));
			return (err);
		}
	}

	return (USBD_NORMAL_COMPLETION);
}

void
ucomreadcb(struct usbd_xfer *xfer, void *p, usbd_status status)
{
	struct ucom_softc *sc = (struct ucom_softc *)p;
	struct tty *tp = sc->sc_tty;
	int (*rint)(int c, struct tty *tp) = LINESW(tp, l_rint);
	usbd_status err;
	u_int32_t cc;
	u_char *cp;
	int s;

	DPRINTFN(5,("ucomreadcb: status=%d\n", status));

	if (status == USBD_CANCELLED || status == USBD_IOERROR ||
	    usbd_is_dying(sc->sc_uparent)) {
		DPRINTF(("ucomreadcb: dying\n"));
		/* Send something to wake upper layer */
		s = spltty();
		(*rint)('\n', tp);
		ttwakeup(tp);
		splx(s);
		return;
	}

	if (status) {
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);
			/* XXX we should restart after some delay. */
			return;
		}
	}

	usbd_get_xfer_status(xfer, NULL, (void *)&cp, &cc, NULL);
	DPRINTFN(5,("ucomreadcb: got %d chars, tp=%p\n", cc, tp));
	if (sc->sc_methods->ucom_read != NULL)
		sc->sc_methods->ucom_read(sc->sc_parent, sc->sc_portno,
					  &cp, &cc);

	s = spltty();
	/* Give characters to tty layer. */
	while (cc-- > 0) {
		DPRINTFN(7,("ucomreadcb: char=0x%02x\n", *cp));
		if ((*rint)(*cp++, tp) == -1) {
			/* XXX what should we do? */
			printf("%s: lost %d chars\n", sc->sc_dev.dv_xname,
			       cc);
			break;
		}
	}
	splx(s);

	err = ucomstartread(sc);
	if (err) {
		printf("%s: read start failed\n", sc->sc_dev.dv_xname);
		/* XXX what should we dow now? */
	}
}

void
ucom_cleanup(struct ucom_softc *sc)
{
	DPRINTF(("ucom_cleanup: closing pipes\n"));

	sc->sc_open = 0;

	ucom_shutdown(sc);
	if (sc->sc_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
	}
	if (sc->sc_ixfer != NULL) {
		if (sc->sc_bulkin_no != -1) {
			usbd_free_buffer(sc->sc_ixfer);
			sc->sc_ibuf = NULL;
			usbd_free_xfer(sc->sc_ixfer);
		}
		sc->sc_ixfer = NULL;
	}
	if (sc->sc_oxfer != NULL) {
		usbd_free_buffer(sc->sc_oxfer);
		sc->sc_obuf = NULL;
		if (sc->sc_bulkin_no != -1)
			usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
	}
}

#endif /* NUCOM > 0 */

int
ucomprint(void *aux, const char *pnp)
{
	struct ucom_attach_args *uca = aux;

	if (pnp)
		printf("ucom at %s", pnp);
	if (uca->portno != UCOM_UNK_PORTNO)
		printf(" portno %d", uca->portno);
	return (UNCONF);
}

int
ucomsubmatch(struct device *parent, void *match, void *aux)
{
        struct ucom_attach_args *uca = aux;
        struct cfdata *cf = match;

	if (uca->portno != UCOM_UNK_PORTNO &&
	    cf->ucomcf_portno != UCOM_UNK_PORTNO &&
	    cf->ucomcf_portno != uca->portno)
		return (0);
	return ((*cf->cf_attach->ca_match)(parent, cf, aux));
}
@


1.64
log
@Plug two xfer leaks and a buffer one.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.63 2014/02/03 20:59:05 mpi Exp $ */
a55 1
#include <dev/usb/usb_quirks.h>
@


1.63
log
@Check if the device is being detached when returning from tsleep() and
in such case do not try to cleanup the device since this would make the
thread sleep again while keeping a reference to the softc.

Fix a panic found by sebastia@@, ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.62 2013/11/15 08:25:31 pirofti Exp $ */
d231 3
a233 1
		if (sc->sc_uhidev == NULL)
d235 1
d240 2
a241 1
		if (sc->sc_uhidev == NULL)
d425 1
a425 1
	DPRINTF(("ucomopen: unit=%d, tp=%p\n", unit, tp));
d527 1
a527 1
	if (sc->sc_uhidev == NULL)
d561 2
a579 1
	DPRINTF(("ucomclose: unit=%d\n", UCOMUNIT(dev)));
d1200 3
a1202 1
		if (sc->sc_uhidev == NULL)
d1204 1
d1209 2
a1210 1
		if (sc->sc_uhidev == NULL)
@


1.62
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.61 2013/07/15 13:52:05 mpi Exp $ */
d494 6
@


1.61
log
@When a ucom(4) device is detached do not only abort its pipes but also
free them and makes sure to close the attached tty before freeing its
descriptor.  This plugs a memleak and fixes a panic introduce in r1.59.

Found the hard way and tested by otto@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.60 2013/06/25 13:42:28 mpi Exp $ */
d83 1
a83 1
	struct usbd_device	*sc_udev;	/* USB device */
a121 1
	u_char			sc_dying;	/* disconnecting */
a145 1
int ucom_activate(struct device *, int); 
a155 1
	ucom_activate, 
d187 1
a187 1
	sc->sc_udev = uca->device;
a278 15
int
ucom_activate(struct device *self, int act)
{
	struct ucom_softc *sc = (struct ucom_softc *)self;

	DPRINTFN(5,("ucom_activate: %d\n", act));

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}

d308 1
a308 1
	if (sc->sc_dying)
d363 1
a363 1
			sc->sc_ixfer = usbd_alloc_xfer(sc->sc_udev);
d376 1
a376 1
			sc->sc_oxfer = usbd_alloc_xfer(sc->sc_udev);
d548 1
a548 1
	if (sc == NULL || sc->sc_dying)
d594 1
a594 1
	if (sc == NULL || sc->sc_dying)
d612 1
a612 1
	if (sc == NULL || sc->sc_dying)
d644 1
a644 1
	if (sc == NULL || sc->sc_dying)
d858 1
a858 1
	if (sc == NULL || sc->sc_dying)
d955 1
a955 1
	if (sc == NULL || sc->sc_dying)
d1048 1
a1048 1
	if (status == USBD_CANCELLED || sc->sc_dying)
d1126 1
a1126 1
	    sc->sc_dying) {
@


1.60
log
@Do not dereference sc before checking if it exists, pointed by otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.59 2013/06/03 16:10:56 mpi Exp $ */
d223 1
a223 1
	if (sc->sc_bulkin_pipe != NULL)
d225 4
a228 1
	if (sc->sc_bulkout_pipe != NULL)
d230 14
a252 1
		/* Wait for processes to go away. */
d270 5
d646 5
a650 1
	if (sc == NULL || sc->sc_dying)
@


1.59
log
@Correctly increment the refcounter when trying to open a non connected
serial. Fix a panic triggered by removing the USB device while the
opener is sleeping holding a reference to the softc. Found the hardway
by tobiasu@@.

While here add more sanity checks to avoid races when the driver is
being detached.

ok tobiasu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.58 2013/04/15 09:23:02 mglocker Exp $ */
d588 1
a588 1
	struct tty *tp = sc->sc_tty;
@


1.58
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.57 2013/03/28 03:58:03 tedu Exp $ */
d130 3
a132 2
int	ucom_do_ioctl(struct ucom_softc *, u_long, caddr_t,
			      int, struct proc *);
a163 1
	sc->sc_refcnt++;
a170 2
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
a295 1
	usbd_status err;
a296 3
	struct tty *tp;
	struct termios t;
	int s;
d311 17
d543 16
d591 1
a591 1
	if (sc->sc_dying)
d595 1
d606 1
a606 1
	struct tty *tp = sc->sc_tty;
d609 1
a609 1
	if (sc->sc_dying)
d613 1
a623 1
	struct tty *tp = sc->sc_tty;
d625 4
a628 1
	return (tp);
d637 3
a654 3
	if (sc->sc_dying)
		return (EIO);

d851 1
a851 1
	if (sc->sc_dying)
d948 1
a948 1
	if (sc->sc_dying)
@


1.57
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.56 2012/12/31 04:25:46 miod Exp $ */
d83 1
a83 1
	usbd_device_handle	sc_udev;	/* USB device */
d86 1
a86 1
	usbd_interface_handle	sc_iface;	/* data interface */
d89 2
a90 2
	usbd_pipe_handle	sc_bulkin_pipe;	/* bulk in pipe */
	usbd_xfer_handle	sc_ixfer;	/* read request */
d96 2
a97 2
	usbd_pipe_handle	sc_bulkout_pipe;/* bulk out pipe */
	usbd_xfer_handle	sc_oxfer;	/* write request */
d103 2
a104 2
	usbd_pipe_handle	sc_ipipe;	/* hid interrupt input pipe */
	usbd_pipe_handle	sc_opipe;	/* hid interrupt pipe */
d136 2
a137 2
void	ucomreadcb(usbd_xfer_handle, usbd_private_handle, usbd_status);
void	ucomwritecb(usbd_xfer_handle, usbd_private_handle, usbd_status);
d962 1
a962 1
		    (usbd_private_handle)sc, sc->sc_obuf, cnt,
d966 1
a966 1
		    (usbd_private_handle)sc, sc->sc_obuf, cnt,
d1001 1
a1001 1
ucomwritecb(usbd_xfer_handle xfer, usbd_private_handle p, usbd_status status)
d1060 1
a1060 1
			(usbd_private_handle)sc,
d1075 1
a1075 1
ucomreadcb(usbd_xfer_handle xfer, usbd_private_handle p, usbd_status status)
@


1.56
log
@Declare ucom as a DV_TTY class device, not DV_DULL; Alexander Polakov
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.55 2011/11/29 17:15:44 deraadt Exp $ */
a45 1
#include <sys/proc.h>
@


1.55
log
@the code for managing tty vs cua usage collision was free'ing all sorts
of critical structures when it hit a collision.  Also, ttyopen is ldisc
0, so it should not be called twice (and furthermore, with the wrong dev_t)
original report from mikeb, ok dlg mikeb and discussed with miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.54 2011/07/03 19:38:50 deraadt Exp $ */
d150 1
a150 1
	NULL, "ucom", DV_DULL 
@


1.54
log
@ucom(4) did not understand the last-close semantics.  repair that, and
add a bit more locking in the open function.
originally spotted by matthew, ok matthew miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.53 2011/07/03 15:47:17 matthew Exp $ */
d456 3
a458 4
	} else if (ISSET(tp->t_state, TS_XCLUDE) && suser(p, 0) != 0) {
		error = EBUSY;
		goto bad;
	} else
d464 2
a465 2
			error = EBUSY;
			goto bad1;
d472 2
a473 2
				error = EBUSY;
				goto bad1;
d489 2
a490 1
					goto bad1;
a496 4
	error = ttyopen(UCOMUNIT(dev), tp, p);
	if (error)
		goto bad;

a520 2
bad1:
	splx(s);
@


1.53
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.52 2011/06/23 16:02:33 tedu Exp $ */
a212 2

	sc->sc_open = 0;
d320 2
a321 3
	if (sc->sc_open++ == 0) {
		s = splusb();

d400 1
a400 2

		splx(s);
d402 2
a404 2

	s = spltty();
d553 1
a554 1
	splx(s);
d1142 1
a1142 2
	if (--sc->sc_open == 0) {
		DPRINTF(("ucom_cleanup: closing pipes\n"));
d1144 23
a1166 22
		ucom_shutdown(sc);
		if (sc->sc_bulkin_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			sc->sc_bulkin_pipe = NULL;
		}
		if (sc->sc_bulkout_pipe != NULL) {
			usbd_abort_pipe(sc->sc_bulkout_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			sc->sc_bulkout_pipe = NULL;
		}
		if (sc->sc_ixfer != NULL) {
			if (sc->sc_uhidev == NULL)
				usbd_free_xfer(sc->sc_ixfer);
			sc->sc_ixfer = NULL;
		}
		if (sc->sc_oxfer != NULL) {
			usbd_free_buffer(sc->sc_oxfer);
			if (sc->sc_uhidev == NULL)
				usbd_free_xfer(sc->sc_oxfer);
			sc->sc_oxfer = NULL;
		}
@


1.52
log
@ansify a few files.  ok deraadt dlg krw matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.51 2010/09/24 08:33:59 yuo Exp $ */
a273 3
	case DVACT_ACTIVATE:
		break;

@


1.51
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.50 2010/07/02 17:27:01 nicm Exp $ */
d772 1
a772 3
ucom_break(sc, onoff)
	struct ucom_softc *sc;
	int onoff;
@


1.50
log
@Move common code for waking up writers on a tty into a function.

ok deraadt matthew millert
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.49 2010/06/30 09:36:51 nicm Exp $ */
a226 2

	sc->sc_dying = 1;
@


1.49
log
@Instead of failing immediately , check for ENOTTY from the parent (umodem)
ioctl function and fall through to pick up the tty ioctls.

ok deraadt beck
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.48 2010/06/28 14:13:35 deraadt Exp $ */
d946 3
a948 9
	if (tp->t_outq.c_cc <= tp->t_lowat) {
		if (ISSET(tp->t_state, TS_ASLEEP)) {
			CLR(tp->t_state, TS_ASLEEP);
			wakeup(&tp->t_outq);
		}
		selwakeup(&tp->t_wsel);
		if (tp->t_outq.c_cc == 0)
			goto out;
	}
@


1.48
log
@Allow tty drivers to request larger buffers at attach time using a
max-baud-rate hint.  Adjust TTYHOG (the nearly full logic) to this new
situation.  The larger buffers are required by the very high speed
KDDI devices in Japan (CF com, or USB ucom) so those are the only two
drivers which currently ask for a larger buffer size.
ok yasuoka miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.47 2010/04/12 12:57:52 tedu Exp $ */
d653 1
a653 1
		if (error >= 0)
@


1.47
log
@Some of the line disciplines want to check for suser.  Better to pass them
a process instead of using curproc.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.46 2009/11/09 17:53:39 nicm Exp $ */
d206 1
a206 1
	tp = ttymalloc();
@


1.46
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.45 2009/10/31 12:00:08 fgsch Exp $ */
d506 1
a506 1
	error = ttyopen(UCOMUNIT(dev), tp);
d510 1
a510 1
	error = (*LINESW(tp, l_open))(dev, tp);
d557 1
a557 1
	(*LINESW(tp, l_close))(tp, flag);
@


1.45
log
@Use suser when possible. Suggested by miod@@.
miod@@ deraadt@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.44 2009/10/31 06:40:17 deraadt Exp $ */
a951 1
		KNOTE(&tp->t_wsel.si_note, 0);
@


1.44
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.43 2009/10/13 19:33:17 pirofti Exp $ */
d465 1
a465 1
	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0) {
@


1.43
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.42 2008/06/26 05:42:18 ray Exp $ */
d952 1
@


1.42
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.41 2007/06/14 10:11:15 mbalmer Exp $ */
d147 1
a147 1
int ucom_activate(struct device *, enum devact); 
d269 1
a269 1
ucom_activate(struct device *self, enum devact act)
@


1.41
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.40 2007/06/12 16:26:36 mbalmer Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.40
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.39 2007/06/11 16:30:31 mbalmer Exp $ */
d151 16
a166 1
USB_DECLARE_DRIVER(ucom);
@


1.39
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.38 2007/06/10 14:49:00 mbalmer Exp $ */
d261 1
a261 1
ucom_activate(device_ptr_t self, enum devact act)
@


1.38
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.37 2007/06/10 10:53:48 mbalmer Exp $ */
d139 1
a139 1
			      int, usb_proc_ptr);
d295 1
a295 1
ucomopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d537 1
a537 1
ucomclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d609 1
a609 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d623 1
a623 1
	      int flag, usb_proc_ptr p)
@


1.37
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.36 2007/06/06 19:25:49 mk Exp $ */
d334 1
a334 1
				    USBDEVNAME(sc->sc_dev), sc->sc_bulkin_no,
d343 1
a343 1
				    USBDEVNAME(sc->sc_dev), sc->sc_bulkout_no,
d1134 1
a1134 1
			printf("%s: lost %d chars\n", USBDEVNAME(sc->sc_dev),
d1143 1
a1143 1
		printf("%s: read start failed\n", USBDEVNAME(sc->sc_dev));
@


1.36
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.35 2007/06/05 08:43:55 mbalmer Exp $ */
d165 1
a165 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d236 1
a236 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d578 1
a578 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d595 1
a595 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d617 1
a617 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.35
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.34 2007/05/27 04:00:25 jsg Exp $ */
d89 1
a89 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.34
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.33 2007/05/20 00:52:26 jsg Exp $ */
d133 6
a138 6
Static void	ucom_cleanup(struct ucom_softc *);
Static void	ucom_hwiflow(struct ucom_softc *);
Static int	ucomparam(struct tty *, struct termios *);
Static void	ucomstart(struct tty *);
Static void	ucom_shutdown(struct ucom_softc *);
Static int	ucom_do_ioctl(struct ucom_softc *, u_long, caddr_t,
d140 10
a149 10
Static void	ucom_dtr(struct ucom_softc *, int);
Static void	ucom_rts(struct ucom_softc *, int);
Static void	ucom_break(struct ucom_softc *, int);
Static usbd_status ucomstartread(struct ucom_softc *);
Static void	ucomreadcb(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void	ucomwritecb(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void	tiocm_to_ucom(struct ucom_softc *, u_long, int);
Static int	ucom_to_tiocm(struct ucom_softc *);
Static void	ucom_lock(struct ucom_softc *);
Static void	ucom_unlock(struct ucom_softc *);
d153 1
a153 1
Static void
d160 1
a160 1
Static void
d621 1
a621 1
Static int
d702 1
a702 1
Static void
d734 1
a734 1
Static int
d765 1
a765 1
Static void
d777 1
a777 1
Static void
d791 1
a791 1
Static void
d824 1
a824 1
Static int
d895 1
a895 1
Static void
d918 1
a918 1
Static void
d1016 1
a1016 1
Static void
d1061 1
a1061 1
Static usbd_status
d1090 1
a1090 1
Static void
d1148 1
a1148 1
Static void
@


1.33
log
@Convert ehci and ucom to rwlock.
Kill the usb specific lockmgr wrapper as nothing uses it now.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.32 2006/08/29 08:15:10 mbalmer Exp $ */
d168 2
a169 1
USB_MATCH(ucom)
d174 2
a175 1
USB_ATTACH(ucom)
a206 2

	USB_ATTACH_SUCCESS_RETURN;
d209 2
a210 1
USB_DETACH(ucom)
@


1.32
log
@Fix a possible kernel panic in ucom(4) that is caused by ttyclose() using data
already freed by ucom_close().

Problem reported and initial patch provided by Marc Winiger <marc@@winiger.ch>

ok miod, deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.31 2006/08/18 02:54:11 jason Exp $ */
d47 1
d127 1
a127 1
	struct lock		sc_lock;	/* lock during open */
d157 1
a157 1
	usb_lockmgr(&sc->sc_lock, LK_EXCLUSIVE, NULL, curproc);
d163 1
a163 1
	usb_lockmgr(&sc->sc_lock, LK_RELEASE, NULL, curproc);
d202 2
a203 1
	lockinit(&sc->sc_lock, PZERO, "ucomlk", 0, LK_CANRECURSE);
@


1.31
log
@support for ucycom:
- teach ucom that not all i/o is done via bulk pipes
- teach uhidev that i/o interrupt pipes are distinct
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.30 2006/06/23 06:27:11 miod Exp $ */
a547 1
	ucom_cleanup(sc);
d550 2
a552 1
	ttyclose(tp);
@


1.30
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.29 2006/04/27 19:31:44 deraadt Exp $ */
d61 1
d91 1
d110 3
d186 1
d319 64
a395 51
		DPRINTF(("ucomopen: open pipes in=%d out=%d\n",
			 sc->sc_bulkin_no, sc->sc_bulkout_no));

		/* Open the bulk pipes */
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkin_no, 0,
				     &sc->sc_bulkin_pipe);
		if (err) {
			DPRINTF(("%s: open bulk out error (addr %d), err=%s\n",
				 USBDEVNAME(sc->sc_dev), sc->sc_bulkin_no,
				 usbd_errstr(err)));
			error = EIO;
			goto fail_0;
		}
		err = usbd_open_pipe(sc->sc_iface, sc->sc_bulkout_no,
				     USBD_EXCLUSIVE_USE, &sc->sc_bulkout_pipe);
		if (err) {
			DPRINTF(("%s: open bulk in error (addr %d), err=%s\n",
				 USBDEVNAME(sc->sc_dev), sc->sc_bulkout_no,
				 usbd_errstr(err)));
			error = EIO;
			goto fail_1;
		}

		/* Allocate a request and an input buffer and start reading. */
		sc->sc_ixfer = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_ixfer == NULL) {
			error = ENOMEM;
			goto fail_2;
		}

		sc->sc_ibuf = usbd_alloc_buffer(sc->sc_ixfer,
						sc->sc_ibufsizepad);
		if (sc->sc_ibuf == NULL) {
			error = ENOMEM;
			goto fail_3;
		}

		sc->sc_oxfer = usbd_alloc_xfer(sc->sc_udev);
		if (sc->sc_oxfer == NULL) {
			error = ENOMEM;
			goto fail_3;
		}

		sc->sc_obuf = usbd_alloc_buffer(sc->sc_oxfer,
						sc->sc_obufsize +
						sc->sc_opkthdrlen);
		if (sc->sc_obuf == NULL) {
			error = ENOMEM;
			goto fail_4;
		}

d506 2
a507 1
	usbd_free_xfer(sc->sc_oxfer);
a539 1
	DPRINTF(("ucomclose: unit=%d\n", UCOMUNIT(dev)));
d543 1
d967 15
a981 3
	usbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe,
			(usbd_private_handle)sc, sc->sc_obuf, cnt,
			USBD_NO_COPY, USBD_NO_TIMEOUT, ucomwritecb);
d1021 1
a1021 1
	DPRINTFN(5,("ucomwritecb: status=%d\n", status));
d1026 10
a1035 5
	if (status) {
		DPRINTF(("ucomwritecb: status=%d\n", status));
		usbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);
		/* XXX we should restart after some delay. */
		goto error;
a1037 2
	usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);

d1064 9
a1072 1
	usbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe,
d1077 5
a1081 4
	err = usbd_transfer(sc->sc_ixfer);
	if (err != USBD_IN_PROGRESS) {
		DPRINTF(("ucomstartread: err=%s\n", usbd_errstr(err)));
		return (err);
d1083 1
d1112 5
a1116 3
		usbd_clear_endpoint_stall_async(sc->sc_bulkin_pipe);
		/* XXX we should restart after some delay. */
		return;
d1163 2
a1164 1
			usbd_free_xfer(sc->sc_ixfer);
d1168 3
a1170 1
			usbd_free_xfer(sc->sc_oxfer);
@


1.29
log
@2 lines of code in most drivers, to do the timestamping; ok miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.28 2006/03/27 08:19:39 dlg Exp $ */
d260 1
a260 1
		return (EOPNOTSUPP);
@


1.28
log
@shrink by removing some unneeded ifdefs
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.27 2005/11/21 18:16:43 millert Exp $ */
d788 4
@


1.27
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.26 2005/04/08 04:30:17 deraadt Exp $ */
a574 19

#if defined(__NetBSD__)
int
ucompoll(dev_t dev, int events, usb_proc_ptr p)
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	struct tty *tp = sc->sc_tty;
	int error;

	if (sc->sc_dying)
		return (EIO);

	sc->sc_refcnt++;
	error = (*LINESW(tp, l_poll))(tp, events, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->sc_dev));
	return (error);
}
#endif
@


1.27.2.1
log
@MFC:
Fix by mbalmer@@

Fix a possible kernel panic in ucom(4) that is caused by ttyclose() using data
already freed by ucom_close().

Problem reported and initial patch provided by Marc Winiger <marc@@winiger.ch>
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.27 2005/11/21 18:16:43 millert Exp $ */
d528 1
d531 1
a532 2
	ucom_cleanup(sc);
	splx(s);
@


1.26
log
@no need to spit out portno twice
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.25 2005/01/28 22:38:39 djm Exp $ */
d51 1
a51 1
#include <sys/select.h>
@


1.25
log
@make RTS follow DTS when CRTSCTS is off, like com(4) and pccom(4); tested
hshoexer@@ henning@@; ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.24 2005/01/28 22:36:46 djm Exp $ */
a172 2
	if (uca->portno != UCOM_UNK_PORTNO)
		printf(": portno %d", uca->portno);
@


1.24
log
@Restore asserting DTR by default, lost when cuaU* support was added;
tested hshoexer@@ henning@@, ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.23 2005/01/19 07:49:35 dlg Exp $ */
d780 1
a780 1
	if (sc->sc_methods->ucom_set != NULL)
d783 4
@


1.23
log
@make sure only one set of xfers are set up for any number of opens of the
tty/cua device.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.22 2005/01/10 08:17:49 dlg Exp $ */
d419 9
@


1.22
log
@add support for calling units (cuaU*)
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.21 2004/07/08 22:18:44 deraadt Exp $ */
d121 2
a122 1
	u_char			sc_opening;	/* lock during open */
d142 2
d147 15
d197 3
d310 4
a313 17
	tp = sc->sc_tty;
	DPRINTF(("ucomopen: unit=%d, tp=%p\n", unit, tp));

	/*
	 * Do the following if this is a first open.
	 */
	while (sc->sc_opening)
		tsleep(&sc->sc_opening, PRIBIO, "ucomop", 0);

	if (sc->sc_dying) {
		return (EIO);
	}
	sc->sc_opening = 1;

	tp->t_dev = dev;
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		SET(tp->t_state, TS_WOPEN);
a319 2
				sc->sc_opening = 0;
				wakeup(&sc->sc_opening);
d321 1
a327 37
		/*
		 * Initialize the termios status to the defaults.  Add in the
		 * sticky bits from TIOCSFLAGS.
		 */
		t.c_ispeed = 0;
		t.c_ospeed = TTYDEF_SPEED;
		t.c_cflag = TTYDEF_CFLAG;
		if (ISSET(sc->sc_swflags, TIOCFLAG_CLOCAL))
			SET(t.c_cflag, CLOCAL);
		if (ISSET(sc->sc_swflags, TIOCFLAG_CRTSCTS))
			SET(t.c_cflag, CRTSCTS);
		if (ISSET(sc->sc_swflags, TIOCFLAG_MDMBUF))
			SET(t.c_cflag, MDMBUF);

		/* Make sure ucomparam() will do something. */
		tp->t_ospeed = 0;
		(void) ucomparam(tp, &t);
		tp->t_iflag = TTYDEF_IFLAG;
		tp->t_oflag = TTYDEF_OFLAG;
		tp->t_lflag = TTYDEF_LFLAG;
		ttychars(tp);
		ttsetwater(tp);

		s = spltty();

		/*
		 * Turn on DTR.  We must always do this, even if carrier is not
		 * present, because otherwise we'd have to use TIOCSDTR
		 * immediately after setting CLOCAL, which applications do not
		 * expect.  We always assert DTR while the device is open
		 * unless explicitly requested to deassert it.
		 */
		//ucom_dtr(sc, 1);

		/* XXX CLR(sc->sc_rx_flags, RX_ANY_BLOCK);*/
		ucom_hwiflow(sc);

d381 42
d428 4
a431 4

	} else if (ISSET(tp->t_state, TS_XCLUDE) && p->p_ucred->cr_uid != 0)
		return (EBUSY);
	else
d437 2
a438 2
			splx(s);
			return (EBUSY);
d445 2
a446 2
				splx(s);
				return (EBUSY);
d462 1
a462 5
					if (!sc->sc_cua &&
					    !ISSET(tp->t_state, TS_ISOPEN))
						ucom_cleanup(sc);
					splx(s);
					return (error);
a466 3
		
	sc->sc_opening = 0;
	wakeup(&sc->sc_opening);
a468 1

a491 2
	sc->sc_opening = 0;
	wakeup(&sc->sc_opening);
d493 1
d496 2
d499 3
a501 7
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
		/*
		 * We failed to open the device, and nobody else had it opened.
		 * Clean up the state as appropriate.
		 */
		ucom_cleanup(sc);
	}
d517 1
a517 1
	sc->sc_refcnt++;
d521 1
a521 8
	if (!ISSET(tp->t_state, TS_WOPEN)) {
		/*
		 * Although we got a last close, the device may still be in
		 * use; e.g. if this was the dialout node, and there are still
		 * processes waiting for carrier on the non-dialout node.
		 */
		ucom_cleanup(sc);
	}
d530 1
a530 2
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d1105 2
a1106 1
	DPRINTF(("ucom_cleanup: closing pipes\n"));
d1108 19
a1126 18
	ucom_shutdown(sc);
	if (sc->sc_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
	}
	if (sc->sc_ixfer != NULL) {
		usbd_free_xfer(sc->sc_ixfer);
		sc->sc_ixfer = NULL;
	}
	if (sc->sc_oxfer != NULL) {
		usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
@


1.21
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.20 2003/10/03 16:44:51 miod Exp $ */
a55 6
#if defined(__NetBSD__)
#include "rnd.h"
#if NRND > 0
#include <sys/rnd.h>
#endif
#endif
d71 1
a71 1
#define DPRINTFN(n, x)	do { if (ucomdebug > (n)) logprintf x; } while (0)
d78 2
a79 12
#if defined(__NetBSD__)
#define	UCOMUNIT_MASK		0x3ffff
#define	UCOMDIALOUT_MASK	0x80000
#define	UCOMCALLUNIT_MASK	0x40000

#define LINESW(tp, func)	((tp)->t_linesw->func)
#endif

#if defined(__OpenBSD__)
#define	UCOMUNIT_MASK		0x3f
#define	UCOMDIALOUT_MASK	0x80
#define	UCOMCALLUNIT_MASK	0x40
a81 1
#endif
d84 1
a84 2
#define	UCOMDIALOUT(x)		(minor(x) & UCOMDIALOUT_MASK)
#define	UCOMCALLUNIT(x)		(minor(x) & UCOMCALLUNIT_MASK)
d119 2
a123 4

#if defined(__NetBSD__) && NRND > 0
	rndsource_element_t	sc_rndsource;	/* random source */
#endif
a125 16
#if defined(__NetBSD__)
dev_type_open(ucomopen);
dev_type_close(ucomclose);
dev_type_read(ucomread);
dev_type_write(ucomwrite);
dev_type_ioctl(ucomioctl);
dev_type_stop(ucomstop);
dev_type_tty(ucomtty);
dev_type_poll(ucompoll);

const struct cdevsw ucom_cdevsw = {
	ucomopen, ucomclose, ucomread, ucomwrite, ucomioctl,
	ucomstop, ucomtty, ucompoll, nommap, ttykqfilter, D_TTY
};
#endif

d177 1
a177 10

#ifndef __OpenBSD__
	DPRINTF(("ucom_attach: tty_attach %p\n", tp));
	tty_attach(tp);
#endif

#if defined(__NetBSD__) && NRND > 0
	rnd_attach_source(&sc->sc_rndsource, USBDEVNAME(sc->sc_dev),
			  RND_TYPE_TTY, 0);
#endif
a211 4
#if defined(__NetBSD__)
	/* locate the major number */
	maj = cdevsw_lookup_major(&ucom_cdevsw);
#else
a215 1
#endif
d221 1
a221 2
	vdevgone(maj, mn | UCOMDIALOUT_MASK, mn | UCOMDIALOUT_MASK, VCHR);
	vdevgone(maj, mn | UCOMCALLUNIT_MASK, mn | UCOMCALLUNIT_MASK, VCHR);
a224 3
#ifndef __OpenBSD__
		tty_detach(tp);
#endif
a228 5
	/* Detach the random source */
#if defined(__NetBSD__) && NRND > 0
	rnd_detach_source(&sc->sc_rndsource);
#endif

d273 1
a289 1

a291 7
	if (ISSET(tp->t_state, TS_ISOPEN) &&
	    ISSET(tp->t_state, TS_XCLUDE) &&
	    p->p_ucred->cr_uid != 0)
		return (EBUSY);

	s = spltty();

d293 1
a293 1
	 * Do the following iff this is a first open.
a298 1
		splx(s);
d303 1
a303 3
#if defined(__NetBSD__)
	if (!ISSET(tp->t_state, TS_ISOPEN) && tp->t_wopen == 0) {
#else
d305 1
a305 4
#endif
		struct termios t;

		tp->t_dev = dev;
d309 1
a309 1
							  sc->sc_portno);
d334 1
d344 2
d353 1
a353 1
		ucom_dtr(sc, 1);
d410 48
d459 1
d464 2
a465 5
#if defined(__NetBSD__)
	error = ttyopen(tp, UCOMDIALOUT(dev), ISSET(flag, O_NONBLOCK));
#else
	error = ttyopen(UCOMDIALOUT(dev), tp);
#endif
a493 3
#if defined(__NetBSD__)
	if (!ISSET(tp->t_state, TS_ISOPEN) && tp->t_wopen == 0) {
#else
a494 1
#endif
d510 1
d519 2
a520 7
	ttyclose(tp);

#if defined(__NetBSD__)
	if (!ISSET(tp->t_state, TS_ISOPEN) && tp->t_wopen == 0) {
#else
	if (!ISSET(tp->t_state, TS_ISOPEN)) {
#endif
d528 4
a971 3
#if defined(__NetBSD__)
void
#else
a972 1
#endif
a988 1
#if !defined(__NetBSD__)
a989 1
#endif
d1013 1
a1013 3
#if defined(__NetBSD__) && NRND > 0
	rnd_add_uint32(&sc->sc_rndsource, cc);
#endif
a1083 3
#if defined(__NetBSD__) && NRND > 0
	rnd_add_uint32(&sc->sc_rndsource, cc);
#endif
a1149 1
#if defined(__OpenBSD__)
a1150 3
#else
ucomsubmatch(struct device *parent, struct cfdata *cf, void *aux)
#endif
a1152 1
#if defined(__OpenBSD__)
a1153 1
#endif
@


1.20
log
@Merge tty_attach() in ttymalloc() and tty_detach() in ttyfree(). The need for
separate tty registering is gone now that sparc has switched to wscons, and
this makes the code less error-prone.

Also, remove tests for ttymalloc() failure, since it uses M_WAITOK.

ok millert@@ deraadt@@, tested by various people as well besides me...
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.19 2003/08/15 20:32:18 tedu Exp $ */
d77 1
a77 1
#define DPRINTFN(n, x)	if (ucomdebug > (n)) logprintf x
@


1.19
log
@change arguments to suser.  suser now takes the process, and a flags
argument.  old cred only calls user suser_ucred.  this will allow future
work to more flexibly implement the idea of a root process.  looks like
something i saw in freebsd, but a little different.
use of suser_ucred vs suser in file system code should be looked at again,
for the moment semantics remain unchanged.
review and input from art@@  testing and further review miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.18 2003/05/19 00:33:00 nate Exp $ */
d214 1
d217 1
d276 1
d278 1
@


1.18
log
@better match netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.17 2002/11/11 02:32:32 nate Exp $ */
d695 1
a695 1
		error = suser(p->p_ucred, &p->p_acflag);
@


1.17
log
@sync with NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.16 2002/07/25 04:07:32 nate Exp $ */
/*	$NetBSD: ucom.c,v 1.47 2002/10/23 09:13:59 jdolecek Exp $	*/
d1114 1
a1114 1
	usbd_get_xfer_status(xfer, NULL, (void **)&cp, &cc, NULL);
@


1.16
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.15 2002/07/25 02:18:10 nate Exp $ */
/*	$NetBSD: ucom.c,v 1.43 2002/07/11 21:14:27 augustss Exp $	*/
d147 13
a159 1
cdev_decl(ucom);
d255 4
d263 1
a296 1
		break;
@


1.15
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.14 2002/07/11 03:11:17 nate Exp $ */
/*	$NetBSD: ucom.c,v 1.42 2002/03/17 19:41:04 atatat Exp $	*/
@


1.14
log
@Please be more portable in usb land
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.13 2002/07/10 21:41:50 mickey Exp $ */
d220 1
a220 1
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p, pipe=%d,%d\n", 
d314 1
a314 1
 
d349 1
a349 1
	
d415 1
a415 1
				 USBDEVNAME(sc->sc_dev), sc->sc_bulkin_no, 
d429 1
a429 1
		
d548 1
a548 1
 
d558 1
a558 1
 
d565 1
a565 1
 
d575 1
a575 1
 
d593 1
a593 1
 
d634 1
a634 1
 
d679 1
a679 1
		error = suser(p->p_ucred, &p->p_acflag); 
d715 1
a715 1
 
d786 1
a786 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, 
d796 1
a796 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno, 
d965 1
a965 1
	usbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe, 
d1055 2
a1056 2
	usbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe, 
			(usbd_private_handle)sc, 
d1067 1
a1067 1
 
@


1.13
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.12 2002/07/10 03:09:34 nate Exp $ */
d145 4
@


1.12
log
@Try to be more portable
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.11 2002/05/07 18:29:18 nate Exp $ */
a144 2

cdev_decl(ucom);
@


1.11
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.9 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: ucom.c,v 1.39 2001/08/16 22:31:24 augustss Exp $	*/
d88 2
d96 2
d154 1
a154 1
			      int, struct proc *);
d304 1
a304 1
ucomopen(dev_t dev, int flag, int mode, struct proc *p)
d470 1
a470 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d511 1
a511 1
ucomclose(dev_t dev, int flag, int mode, struct proc *p)
d522 1
a522 1
	(*linesw[tp->t_line].l_close)(tp, flag);
d558 1
a558 1
	error = ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d575 1
a575 1
	error = ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d581 1
a581 1
#if 0
d583 1
a583 4
ucompoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d593 1
a593 1
	error = ((*linesw[tp->t_line].l_poll)(tp, events, p));
d610 1
a610 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d624 1
a624 1
	      int flag, struct proc *p)
d635 1
a635 1
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
d809 1
a809 1
			(*linesw[tp->t_line].l_modem)(tp,
d870 1
a870 1
	(void) (*linesw[tp->t_line].l_modem)(tp, 1 /* XXX carrier */ );
d1037 1
a1037 1
	(*linesw[tp->t_line].l_start)(tp);
d1071 1
a1071 1
	int (*rint)(int c, struct tty *tp) = linesw[tp->t_line].l_rint;
d1172 1
a1172 1
	struct ucom_attach_args *uca = aux;
d1174 1
a1174 1
	struct cfdata *cf = match;
@


1.10
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.40 2001/11/13 06:24:54 lukem Exp $	*/
a87 2

#define LINESW(tp, func)	((tp)->t_linesw->func)
a93 2

#define LINESW(tp, func)	(linesw[(tp)->t_line].func)
d150 1
a150 1
			      int, usb_proc_ptr);
d300 1
a300 1
ucomopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d466 1
a466 1
	error = (*LINESW(tp, l_open))(dev, tp);
d507 1
a507 1
ucomclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d518 1
a518 1
	(*LINESW(tp, l_close))(tp, flag);
d554 1
a554 1
	error = (*LINESW(tp, l_read))(tp, uio, flag);
d571 1
a571 1
	error = (*LINESW(tp, l_write))(tp, uio, flag);
d577 1
a577 1
#if defined(__NetBSD__)
d579 4
a582 1
ucompoll(dev_t dev, int events, usb_proc_ptr p)
d592 1
a592 1
	error = (*LINESW(tp, l_poll))(tp, events, p);
d609 1
a609 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d623 1
a623 1
	      int flag, usb_proc_ptr p)
d634 1
a634 1
	error = (*LINESW(tp, l_ioctl))(tp, cmd, data, flag, p);
d808 1
a808 1
			(*LINESW(tp, l_modem))(tp,
d869 1
a869 1
	(void) (*LINESW(tp, l_modem))(tp, 1 /* XXX carrier */ );
d1036 1
a1036 1
	(*LINESW(tp, l_start))(tp);
d1070 1
a1070 1
	int (*rint)(int c, struct tty *tp) = LINESW(tp, l_rint);
d1171 1
a1171 1
        struct ucom_attach_args *uca = aux;
d1173 1
a1173 1
        struct cfdata *cf = match;
@


1.9
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.8 2001/05/03 02:20:33 aaron Exp $ */
/*	$NetBSD: ucom.c,v 1.39 2001/08/16 22:31:24 augustss Exp $	*/
d88 2
d96 2
d154 1
a154 1
			      int, struct proc *);
d304 1
a304 1
ucomopen(dev_t dev, int flag, int mode, struct proc *p)
d470 1
a470 1
	error = (*linesw[tp->t_line].l_open)(dev, tp);
d511 1
a511 1
ucomclose(dev_t dev, int flag, int mode, struct proc *p)
d522 1
a522 1
	(*linesw[tp->t_line].l_close)(tp, flag);
d558 1
a558 1
	error = ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d575 1
a575 1
	error = ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d581 1
a581 1
#if 0
d583 1
a583 4
ucompoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d593 1
a593 1
	error = ((*linesw[tp->t_line].l_poll)(tp, events, p));
d610 1
a610 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, struct proc *p)
d624 1
a624 1
	      int flag, struct proc *p)
d635 1
a635 1
	error = (*linesw[tp->t_line].l_ioctl)(tp, cmd, data, flag, p);
d809 1
a809 1
			(*linesw[tp->t_line].l_modem)(tp,
d870 1
a870 1
	(void) (*linesw[tp->t_line].l_modem)(tp, 1 /* XXX carrier */ );
d1037 1
a1037 1
	(*linesw[tp->t_line].l_start)(tp);
d1071 1
a1071 1
	int (*rint)(int c, struct tty *tp) = linesw[tp->t_line].l_rint;
d1172 1
a1172 1
	struct ucom_attach_args *uca = aux;
d1174 1
a1174 1
	struct cfdata *cf = match;
@


1.9.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.9 2001/10/31 04:24:44 nate Exp $ */
@


1.9.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ucom.c,v 1.43 2002/07/11 21:14:27 augustss Exp $	*/
a87 2

#define LINESW(tp, func)	((tp)->t_linesw->func)
a93 2

#define LINESW(tp, func)	(linesw[(tp)->t_line].func)
a141 1
#if defined(__NetBSD__)
a142 1
#endif
d150 1
a150 1
			      int, usb_proc_ptr);
d214 1
a214 1
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p, pipe=%d,%d\n",
d300 1
a300 1
ucomopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d308 1
a308 1

d343 1
a343 1

d409 1
a409 1
				 USBDEVNAME(sc->sc_dev), sc->sc_bulkin_no,
d423 1
a423 1

d466 1
a466 1
	error = (*LINESW(tp, l_open))(dev, tp);
d507 1
a507 1
ucomclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d518 1
a518 1
	(*LINESW(tp, l_close))(tp, flag);
d542 1
a542 1

d552 1
a552 1

d554 1
a554 1
	error = (*LINESW(tp, l_read))(tp, uio, flag);
d559 1
a559 1

d569 1
a569 1

d571 1
a571 1
	error = (*LINESW(tp, l_write))(tp, uio, flag);
d577 1
a577 1
#if defined(__NetBSD__)
d579 4
a582 1
ucompoll(dev_t dev, int events, usb_proc_ptr p)
d590 1
a590 1

d592 1
a592 1
	error = (*LINESW(tp, l_poll))(tp, events, p);
d609 1
a609 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d623 1
a623 1
	      int flag, usb_proc_ptr p)
d631 1
a631 1

d634 1
a634 1
	error = (*LINESW(tp, l_ioctl))(tp, cmd, data, flag, p);
d676 1
a676 1
		error = suser(p->p_ucred, &p->p_acflag);
d712 1
a712 1

d783 1
a783 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
d793 1
a793 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
d808 1
a808 1
			(*LINESW(tp, l_modem))(tp,
d869 1
a869 1
	(void) (*LINESW(tp, l_modem))(tp, 1 /* XXX carrier */ );
d962 1
a962 1
	usbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe,
d1036 1
a1036 1
	(*LINESW(tp, l_start))(tp);
d1052 2
a1053 2
	usbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe,
			(usbd_private_handle)sc,
d1064 1
a1064 1

d1070 1
a1070 1
	int (*rint)(int c, struct tty *tp) = LINESW(tp, l_rint);
d1171 1
a1171 1
        struct ucom_attach_args *uca = aux;
d1173 1
a1173 1
        struct cfdata *cf = match;
@


1.9.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.47 2002/10/23 09:13:59 jdolecek Exp $	*/
d147 1
a147 13
dev_type_open(ucomopen);
dev_type_close(ucomclose);
dev_type_read(ucomread);
dev_type_write(ucomwrite);
dev_type_ioctl(ucomioctl);
dev_type_stop(ucomstop);
dev_type_tty(ucomtty);
dev_type_poll(ucompoll);

const struct cdevsw ucom_cdevsw = {
	ucomopen, ucomclose, ucomread, ucomwrite, ucomioctl,
	ucomstop, ucomtty, ucompoll, nommap, ttykqfilter, D_TTY
};
a242 4
#if defined(__NetBSD__)
	/* locate the major number */
	maj = cdevsw_lookup_major(&ucom_cdevsw);
#else
a246 1
#endif
d280 1
@


1.8
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.7 2001/01/28 09:43:41 aaron Exp $ */
/*	$NetBSD: ucom.c,v 1.37 2001/04/02 13:18:31 augustss Exp $	*/
d56 6
d136 4
d199 5
d256 5
d577 22
d1013 1
a1013 1
		return;
d1019 1
a1019 1
		return;
d1038 6
d1086 1
a1086 1
                return;
@


1.8.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.30 2000/09/23 04:33:04 augustss Exp $	*/
d165 2
d195 1
d199 2
a200 2
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p\n", 
		 sc, flags, sc->sc_tty));
d204 4
a207 6
#ifdef DIAGNOSTIC
	if (sc->sc_tty == NULL) {
		DPRINTF(("ucom_detach: no tty\n"));
		return (0);
	}
#endif
d211 6
a216 1
		/* Wake everyone.. how? */
d235 5
a239 3
	tty_detach(sc->sc_tty);
	ttyfree(sc->sc_tty);
	sc->sc_tty = 0;
a243 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d249 2
a261 1
#endif
d454 1
d457 1
d460 1
d463 1
d970 1
a970 1
	if (status == USBD_CANCELLED)
d1028 12
a1039 2
	if (status == USBD_CANCELLED)
		return;
a1041 1
		DPRINTF(("ucomreadcb: status=%d\n", status));
d1082 18
a1099 6
	usbd_abort_pipe(sc->sc_bulkin_pipe);
	usbd_close_pipe(sc->sc_bulkin_pipe);
	usbd_abort_pipe(sc->sc_bulkout_pipe);
	usbd_close_pipe(sc->sc_bulkout_pipe);
	usbd_free_xfer(sc->sc_ixfer);
	usbd_free_xfer(sc->sc_oxfer);
d1107 1
d1110 3
a1112 1
		printf("ucom at %s\n", pnp);
@


1.8.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ucom.c,v 1.37 2001/04/02 13:18:31 augustss Exp $	*/
a164 2
	if (uca->info != NULL)
		printf(", %s", uca->info);
a192 1
	struct tty *tp = sc->sc_tty;
d196 2
a197 2
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p, pipe=%d,%d\n", 
		 sc, flags, tp, sc->sc_bulkin_no, sc->sc_bulkout_no));
d201 6
a206 4
	if (sc->sc_bulkin_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkin_pipe);
	if (sc->sc_bulkout_pipe != NULL)
		usbd_abort_pipe(sc->sc_bulkout_pipe);
d210 1
a210 6
		/* Wake up anyone waiting */
		if (tp != NULL) {
			CLR(tp->t_state, TS_CARR_ON);
			CLR(tp->t_cflag, CLOCAL | MDMBUF);
			ttyflush(tp, FREAD|FWRITE);
		}
d229 3
a231 5
	if (tp != NULL) {
		tty_detach(tp);
		ttyfree(tp);
		sc->sc_tty = NULL;
	}
d236 1
a241 2
	DPRINTFN(5,("ucom_activate: %d\n", act));

d253 1
a445 1
	sc->sc_oxfer = NULL;
a447 1
	sc->sc_ixfer = NULL;
a449 1
	sc->sc_bulkout_pipe = NULL;
a451 1
	sc->sc_bulkin_pipe = NULL;
d958 1
a958 1
	if (status == USBD_CANCELLED || sc->sc_dying)
d1016 2
a1017 12
	DPRINTFN(5,("ucomreadcb: status=%d\n", status));

	if (status == USBD_CANCELLED || status == USBD_IOERROR ||
	    sc->sc_dying) {
		DPRINTF(("ucomreadcb: dying\n"));
		/* Send something to wake upper layer */
		s = spltty();
		(*rint)('\n', tp);
		ttwakeup(tp);
		splx(s);
                return;
	}
d1020 1
d1061 6
a1066 18
	if (sc->sc_bulkin_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkin_pipe);
		usbd_close_pipe(sc->sc_bulkin_pipe);
		sc->sc_bulkin_pipe = NULL;
	}
	if (sc->sc_bulkout_pipe != NULL) {
		usbd_abort_pipe(sc->sc_bulkout_pipe);
		usbd_close_pipe(sc->sc_bulkout_pipe);
		sc->sc_bulkout_pipe = NULL;
	}
	if (sc->sc_ixfer != NULL) {
		usbd_free_xfer(sc->sc_ixfer);
		sc->sc_ixfer = NULL;
	}
	if (sc->sc_oxfer != NULL) {
		usbd_free_xfer(sc->sc_oxfer);
		sc->sc_oxfer = NULL;
	}
a1073 1
	struct ucom_attach_args *uca = aux;
d1076 1
a1076 3
		printf("ucom at %s", pnp);
	if (uca->portno != UCOM_UNK_PORTNO)
		printf(" portno %d", uca->portno);
@


1.8.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.39 2001/08/16 22:31:24 augustss Exp $	*/
a55 6
#if defined(__NetBSD__)
#include "rnd.h"
#if NRND > 0
#include <sys/rnd.h>
#endif
#endif
a129 4

#if defined(__NetBSD__) && NRND > 0
	rndsource_element_t	sc_rndsource;	/* random source */
#endif
a188 5
#if defined(__NetBSD__) && NRND > 0
	rnd_attach_source(&sc->sc_rndsource, USBDEVNAME(sc->sc_dev),
			  RND_TYPE_TTY, 0);
#endif

a240 5
	/* Detach the random source */
#if defined(__NetBSD__) && NRND > 0
	rnd_detach_source(&sc->sc_rndsource);
#endif

a556 22
#if 0
int
ucompoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
{
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(dev)];
	struct tty *tp = sc->sc_tty;
	int error;

	if (sc->sc_dying)
		return (EIO);
 
	sc->sc_refcnt++;
	error = ((*linesw[tp->t_line].l_poll)(tp, events, p));
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->sc_dev));
	return (error);
}
#endif

d971 1
a971 1
		goto error;
d977 1
a977 1
		goto error;
a995 6
	return;

error:
	s = spltty();
	CLR(tp->t_state, TS_BUSY);
	splx(s);
d1038 1
a1038 1
		return;
@


1.8.2.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.47 2002/10/23 09:13:59 jdolecek Exp $	*/
a87 2

#define LINESW(tp, func)	((tp)->t_linesw->func)
a93 2

#define LINESW(tp, func)	(linesw[(tp)->t_line].func)
d142 1
a142 15
#if defined(__NetBSD__)
dev_type_open(ucomopen);
dev_type_close(ucomclose);
dev_type_read(ucomread);
dev_type_write(ucomwrite);
dev_type_ioctl(ucomioctl);
dev_type_stop(ucomstop);
dev_type_tty(ucomtty);
dev_type_poll(ucompoll);

const struct cdevsw ucom_cdevsw = {
	ucomopen, ucomclose, ucomread, ucomwrite, ucomioctl,
	ucomstop, ucomtty, ucompoll, nommap, ttykqfilter, D_TTY
};
#endif
d150 1
a150 1
			      int, usb_proc_ptr);
d214 1
a214 1
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p, pipe=%d,%d\n",
a236 4
#if defined(__NetBSD__)
	/* locate the major number */
	maj = cdevsw_lookup_major(&ucom_cdevsw);
#else
a240 1
#endif
d274 1
d300 1
a300 1
ucomopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d308 1
a308 1

d343 1
a343 1

d409 1
a409 1
				 USBDEVNAME(sc->sc_dev), sc->sc_bulkin_no,
d423 1
a423 1

d466 1
a466 1
	error = (*LINESW(tp, l_open))(dev, tp);
d507 1
a507 1
ucomclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d518 1
a518 1
	(*LINESW(tp, l_close))(tp, flag);
d542 1
a542 1

d552 1
a552 1

d554 1
a554 1
	error = (*LINESW(tp, l_read))(tp, uio, flag);
d559 1
a559 1

d569 1
a569 1

d571 1
a571 1
	error = (*LINESW(tp, l_write))(tp, uio, flag);
d577 1
a577 1
#if defined(__NetBSD__)
d579 4
a582 1
ucompoll(dev_t dev, int events, usb_proc_ptr p)
d590 1
a590 1

d592 1
a592 1
	error = (*LINESW(tp, l_poll))(tp, events, p);
d609 1
a609 1
ucomioctl(dev_t dev, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
d623 1
a623 1
	      int flag, usb_proc_ptr p)
d631 1
a631 1

d634 1
a634 1
	error = (*LINESW(tp, l_ioctl))(tp, cmd, data, flag, p);
d676 1
a676 1
		error = suser(p->p_ucred, &p->p_acflag);
d712 1
a712 1

d783 1
a783 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
d793 1
a793 1
		sc->sc_methods->ucom_set(sc->sc_parent, sc->sc_portno,
d808 1
a808 1
			(*LINESW(tp, l_modem))(tp,
d869 1
a869 1
	(void) (*LINESW(tp, l_modem))(tp, 1 /* XXX carrier */ );
d962 1
a962 1
	usbd_setup_xfer(sc->sc_oxfer, sc->sc_bulkout_pipe,
d1036 1
a1036 1
	(*LINESW(tp, l_start))(tp);
d1052 2
a1053 2
	usbd_setup_xfer(sc->sc_ixfer, sc->sc_bulkin_pipe,
			(usbd_private_handle)sc,
d1064 1
a1064 1

d1070 1
a1070 1
	int (*rint)(int c, struct tty *tp) = LINESW(tp, l_rint);
d1171 1
a1171 1
        struct ucom_attach_args *uca = aux;
d1173 1
a1173 1
        struct cfdata *cf = match;
@


1.8.2.5
log
@Sync SMP branch to -current
@
text
@d2 1
a2 1
/*	$NetBSD: ucom.c,v 1.49 2003/01/01 00:10:25 thorpej Exp $	*/
d1114 1
a1114 1
	usbd_get_xfer_status(xfer, NULL, (void *)&cp, &cc, NULL);
@


1.8.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@a213 1
#ifndef __OpenBSD__
a215 1
#endif
a273 1
#ifndef __OpenBSD__
a274 1
#endif
d695 1
a695 1
		error = suser(p, 0);
@


1.7
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.6 2000/11/08 18:10:37 aaron Exp $ */
/*	$NetBSD: ucom.c,v 1.30 2000/09/23 04:33:04 augustss Exp $	*/
d165 2
d195 1
d199 2
a200 2
	DPRINTF(("ucom_detach: sc=%p flags=%d tp=%p\n", 
		 sc, flags, sc->sc_tty));
d204 4
a207 6
#ifdef DIAGNOSTIC
	if (sc->sc_tty == NULL) {
		DPRINTF(("ucom_detach: no tty\n"));
		return (0);
	}
#endif
d211 6
a216 1
		/* Wake everyone.. how? */
d235 5
a239 3
	tty_detach(sc->sc_tty);
	ttyfree(sc->sc_tty);
	sc->sc_tty = 0;
a243 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d249 2
a261 1
#endif
d454 1
d457 1
d460 1
d463 1
d970 1
a970 1
	if (status == USBD_CANCELLED)
d1028 12
a1039 2
	if (status == USBD_CANCELLED)
		return;
a1041 1
		DPRINTF(("ucomreadcb: status=%d\n", status));
d1082 18
a1099 6
	usbd_abort_pipe(sc->sc_bulkin_pipe);
	usbd_close_pipe(sc->sc_bulkin_pipe);
	usbd_abort_pipe(sc->sc_bulkout_pipe);
	usbd_close_pipe(sc->sc_bulkout_pipe);
	usbd_free_xfer(sc->sc_ixfer);
	usbd_free_xfer(sc->sc_oxfer);
d1107 1
d1110 3
a1112 1
		printf("ucom at %s\n", pnp);
@


1.6
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.5 2000/07/06 21:51:56 fgsch Exp $ */
d969 3
d1027 3
@


1.5
log
@Add ucom to char. device list and change XX_UNITMASK's to match OpenBSD;
from dugsong@@
@
text
@d1 2
a2 2
/*	$OpenBSD: ucom.c,v 1.4 2000/07/04 11:44:22 fgsch Exp $ */
/*	$NetBSD: ucom.c,v 1.22 2000/04/14 14:21:55 augustss Exp $	*/
d78 7
d88 1
d113 2
a114 1
	u_int			sc_obufsizepad;	/* write buffer size padded */
d134 15
a148 17
Static void	ucom_cleanup	__P((struct ucom_softc *));
Static void	ucom_hwiflow	__P((struct ucom_softc *));
Static int	ucomparam	__P((struct tty *, struct termios *));
Static void	ucomstart	__P((struct tty *));
Static void	ucom_shutdown	__P((struct ucom_softc *));
Static int	ucom_do_ioctl	__P((struct ucom_softc *, u_long, caddr_t,
				     int, struct proc *));
Static void	ucom_dtr	__P((struct ucom_softc *, int));
Static void	ucom_rts	__P((struct ucom_softc *, int));
Static void	ucom_break	__P((struct ucom_softc *, int));
Static usbd_status ucomstartread __P((struct ucom_softc *));
Static void	ucomreadcb	__P((usbd_xfer_handle, usbd_private_handle, 
				     usbd_status status));
Static void	ucomwritecb	__P((usbd_xfer_handle, usbd_private_handle, 
				     usbd_status status));
Static void	tiocm_to_ucom	__P((struct ucom_softc *, int, int));
Static int	ucom_to_tiocm	__P((struct ucom_softc *));
d174 1
a174 1
	sc->sc_obufsizepad = uca->obufsizepad;
d238 1
a238 3
ucom_activate(self, act)
	device_ptr_t self;
	enum devact act;
d256 1
a256 2
ucom_shutdown(sc)
	struct ucom_softc *sc;
d272 1
a272 4
ucomopen(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d330 3
d370 1
a370 1
		// XXX CLR(sc->sc_rx_flags, RX_ANY_BLOCK);
d383 2
a384 1
			return (EIO);
d392 2
a393 2
			usbd_close_pipe(sc->sc_bulkin_pipe);
			return (EIO);
d399 2
a400 3
			usbd_close_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			return (ENOMEM);
d402 1
d406 2
a407 4
			usbd_free_xfer(sc->sc_ixfer);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			return (ENOMEM);
d412 2
a413 4
			usbd_free_xfer(sc->sc_ixfer);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			return (ENOMEM);
d415 1
d417 2
a418 1
						sc->sc_obufsizepad);
d420 2
a421 5
			usbd_free_xfer(sc->sc_oxfer);
			usbd_free_xfer(sc->sc_ixfer);
			usbd_close_pipe(sc->sc_bulkin_pipe);
			usbd_close_pipe(sc->sc_bulkout_pipe);
			return (ENOMEM);
d444 14
d475 1
a475 4
ucomclose(dev, flag, mode, p)
	dev_t dev;
	int flag, mode;
	struct proc *p;
d512 1
a512 4
ucomread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d529 1
a529 4
ucomwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d546 1
a546 2
ucomtty(dev)
	dev_t dev;
d555 1
a555 6
ucomioctl(dev, cmd, data, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d568 2
a569 6
ucom_do_ioctl(sc, cmd, data, flag, p)
	struct ucom_softc *sc;
	u_long cmd;
	caddr_t data;
	int flag;
	struct proc *p;
d649 1
a649 3
tiocm_to_ucom(sc, how, ttybits)
	struct ucom_softc *sc;
	int how, ttybits;
d674 4
a677 2
	ucom_dtr(sc, (sc->sc_mcr & UMCR_DTR) != 0);
	ucom_rts(sc, (sc->sc_mcr & UMCR_RTS) != 0);
d681 1
a681 2
ucom_to_tiocm(sc)
	struct ucom_softc *sc;
d724 1
a724 3
ucom_dtr(sc, onoff)
	struct ucom_softc *sc;
	int onoff;
d734 1
a734 3
ucom_rts(sc, onoff)
	struct ucom_softc *sc;
	int onoff;
d744 1
a744 2
ucom_status_change(sc)
	struct ucom_softc *sc;
d746 3
d750 1
d753 3
d763 1
a763 3
ucomparam(tp, t)
	struct tty *tp;
	struct termios *t;
d793 1
a793 1
	//XXX lcr = ISSET(sc->sc_lcr, LCR_SBREAK) | cflag2lcr(t->c_cflag);
d807 1
a807 1
	// XXX worry about CHWFLOW
d834 1
a834 2
ucom_hwiflow(sc)
	struct ucom_softc *sc;
d857 1
a857 2
ucomstart(tp)
	struct tty *tp;
d927 1
a927 3
ucomstop(tp, flag)
	struct tty *tp;
	int flag;
d944 1
a944 1
	return 0;
d949 1
a949 4
ucomwritecb(xfer, p, status)
	usbd_xfer_handle xfer;
	usbd_private_handle p;
	usbd_status status;
d970 2
d984 1
a984 2
ucomstartread(sc)
	struct ucom_softc *sc;
d1003 1
a1003 4
ucomreadcb(xfer, p, status)
	usbd_xfer_handle xfer;
	usbd_private_handle p;
	usbd_status status;
d1007 1
a1007 1
	int (*rint) __P((int c, struct tty *tp)) = linesw[tp->t_line].l_rint;
d1050 1
a1050 2
ucom_cleanup(sc)
	struct ucom_softc *sc;
d1066 1
a1066 3
ucomprint(aux, pnp)
	void *aux;
	const char *pnp;
d1076 4
a1079 4
ucomsubmatch(parent, match, aux)
	struct device *parent;
	void *match;
	void *aux;
d1081 2
a1083 6
#else
ucomsubmatch(parent, cf, aux)
	struct device *parent;
	struct cfdata *cf;
	void *aux;
{
a1084 1
	struct ucom_attach_args *uca = aux;
@


1.4
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.3 2000/04/14 22:50:25 aaron Exp $ */
d78 3
a80 3
#define	UCOMUNIT_MASK		0x3ffff
#define	UCOMDIALOUT_MASK	0x80000
#define	UCOMCALLUNIT_MASK	0x40000
@


1.3
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ucom.c,v 1.2 2000/04/08 20:03:33 aaron Exp $ */
d9 1
a9 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.2
log
@Add RCSids.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ucom.c,v 1.16 2000/03/27 12:33:55 augustss Exp $	*/
d5 1
a5 1
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
d40 3
a85 8
/* 
 * These are the maximum number of bytes transferred per frame.
 * If some really high speed devices should use this driver they
 * may need to be increased, but this is good enough for modems.
 */
#define UCOMIBUFSIZE 64
#define UCOMOBUFSIZE 256

d97 2
d104 2
d119 1
d130 2
d164 4
d187 1
d201 7
a207 1
	/* XXX  Use reference count? */
d216 1
d218 2
a219 2
	vdevgone(maj, mn, mn | UCOMDIALOUT_MASK, VCHR);
	vdevgone(maj, mn, mn | UCOMCALLUNIT_MASK, VCHR);
d308 5
d324 9
d398 2
a399 1
		sc->sc_ibuf = usbd_alloc_buffer(sc->sc_ixfer, UCOMIBUFSIZE);
d414 2
a415 1
		sc->sc_obuf = usbd_alloc_buffer(sc->sc_oxfer, UCOMOBUFSIZE);
a423 3
		if (sc->sc_methods->ucom_open != NULL)
			sc->sc_methods->ucom_open(sc->sc_parent, sc->sc_portno);

d473 2
a477 3
	if (sc->sc_dying)
		return (0);

d494 3
d508 1
d513 5
a517 1
	return ((*linesw[tp->t_line].l_read)(tp, uio, flag));
d528 1
d533 5
a537 1
	return ((*linesw[tp->t_line].l_write)(tp, uio, flag));
d559 17
d653 1
a653 1
void
d685 1
a685 1
int
d717 1
a717 1
void
d729 1
a729 1
void
d741 1
a741 1
void
d766 1
a766 1
int
d839 1
a839 1
void
d843 1
d863 1
a863 1
void
d878 1
a878 1
		DPRINTFN(4,("ucomstart: stopped\n"));
d905 1
a905 1
	if (cnt > UCOMOBUFSIZE) {
d907 1
a907 1
		cnt = UCOMOBUFSIZE;
d909 5
a913 1
	memcpy(sc->sc_obuf, data, cnt);
d939 3
a941 1
	struct ucom_softc *sc = ucom_cd.cd_devs[UCOMUNIT(tp->t_dev)];
a943 1
	DPRINTF(("ucomstop: %d\n", flag));
d947 1
a947 1
		sc->sc_tx_stopped = 1;
d952 1
a952 1

d958 1
a958 1
void
d994 1
a994 1
usbd_status
d1003 1
a1003 1
			sc->sc_ibuf,  UCOMIBUFSIZE,
d1014 1
a1014 1
void
d1040 4
d1050 2
d1064 1
a1064 1
void
@


1.1
log
@Add USB modem driver stubs; from NetBSD. Not yet tested.
@
text
@d1 1
@

