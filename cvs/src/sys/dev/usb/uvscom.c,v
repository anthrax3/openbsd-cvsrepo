head	1.34;
access;
symbols
	OPENBSD_6_1_BASE:1.34
	OPENBSD_6_0:1.33.0.8
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.2
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.4
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.32.0.2
	OPENBSD_5_7_BASE:1.32
	OPENBSD_5_6:1.32.0.4
	OPENBSD_5_6_BASE:1.32
	OPENBSD_5_5:1.30.0.4
	OPENBSD_5_5_BASE:1.30
	OPENBSD_5_4:1.27.0.2
	OPENBSD_5_4_BASE:1.27
	OPENBSD_5_3:1.24.0.8
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.6
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.4
	OPENBSD_5_0:1.24.0.2
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.23.0.2
	OPENBSD_4_9_BASE:1.23
	OPENBSD_4_8:1.20.0.4
	OPENBSD_4_8_BASE:1.20
	OPENBSD_4_7:1.20.0.2
	OPENBSD_4_7_BASE:1.20
	OPENBSD_4_6:1.19.0.10
	OPENBSD_4_6_BASE:1.19
	OPENBSD_4_5:1.19.0.6
	OPENBSD_4_5_BASE:1.19
	OPENBSD_4_4:1.19.0.4
	OPENBSD_4_4_BASE:1.19
	OPENBSD_4_3:1.19.0.2
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.18.0.2
	OPENBSD_4_2_BASE:1.18
	OPENBSD_4_1:1.8.0.2
	OPENBSD_4_1_BASE:1.8
	OPENBSD_4_0:1.8.0.4
	OPENBSD_4_0_BASE:1.8
	OPENBSD_3_9:1.7.0.4
	OPENBSD_3_9_BASE:1.7
	OPENBSD_3_8:1.7.0.2
	OPENBSD_3_8_BASE:1.7
	OPENBSD_3_7:1.5.0.2
	OPENBSD_3_7_BASE:1.5
	OPENBSD_3_6:1.5.0.4
	OPENBSD_3_6_BASE:1.5
	SMP_SYNC_A:1.3
	SMP_SYNC_B:1.3
	OPENBSD_3_5:1.3.0.6
	OPENBSD_3_5_BASE:1.3
	OPENBSD_3_4:1.3.0.4
	OPENBSD_3_4_BASE:1.3
	UBC:1.3.0.2
	UBC_SYNC_A:1.2
	SMP:1.1.0.4
	OPENBSD_3_3:1.1.0.2
	OPENBSD_3_3_BASE:1.1;
locks; strict;
comment	@ * @;


1.34
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.33;
commitid	blfE5YU3eGM81J65;

1.33
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.32;
commitid	p4LJxGKbi0BU2cG6;

1.32
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.31;
commitid	AGVMSdzbrCHVAlSG;

1.31
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.30;
commitid	OBNa5kfxQ2UXoiIw;

1.30
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.29;

1.29
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.07.10.33.09;	author pirofti;	state Exp;
branches;
next	1.27;

1.27
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.25;

1.25
date	2013.03.28.03.31.56;	author tedu;	state Exp;
branches;
next	1.24;

1.24
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.23;

1.23
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.22;

1.22
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.21;

1.21
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.20;

1.20
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.13;

1.13
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.12;

1.12
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.11;

1.11
date	2007.05.31.18.20.22;	author mbalmer;	state Exp;
branches;
next	1.10;

1.10
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.8;

1.8
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.01.05.41.54;	author brad;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.5;

1.5
date	2004.07.11.09.27.54;	author deraadt;	state Exp;
branches;
next	1.4;

1.4
date	2004.07.08.22.18.45;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.17.17.07.32;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2002.11.30.19.09.59;	author nate;	state Exp;
branches
	1.1.4.1;
next	;

1.1.4.1
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.1.4.2;

1.1.4.2
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	;


desc
@@


1.34
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: uvscom.c,v 1.33 2015/03/14 03:38:50 jsg Exp $ */
/*	$NetBSD: uvscom.c,v 1.9 2003/02/12 15:36:20 ichiro Exp $	*/
/*-
 * Copyright (c) 2001-2002, Shunsuke Akiyama <akiyama@@jp.FreeBSD.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/usb/uvscom.c,v 1.1 2002/03/18 18:23:39 joe Exp $
 */

/*
 * uvscom: SUNTAC Slipper U VS-10U driver.
 * Slipper U is a PC card to USB converter for data communication card
 * adapter.  It supports DDI Pocket's Air H" C@@rd, C@@rd H" 64, NTT's P-in,
 * P-in m@@ater and various data communication card adapters.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/fcntl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/ioctl.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#ifdef UVSCOM_DEBUG
static int	uvscomdebug = 1;

#define DPRINTFN(n, x)  do { if (uvscomdebug > (n)) printf x; } while (0)
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define	UVSCOM_IFACE_INDEX	0

#define UVSCOM_INTR_INTERVAL	100	/* mS */

#define UVSCOM_UNIT_WAIT	5

/* Request */
#define UVSCOM_SET_SPEED	0x10
#define UVSCOM_LINE_CTL		0x11
#define UVSCOM_SET_PARAM	0x12
#define UVSCOM_READ_STATUS	0xd0
#define UVSCOM_SHUTDOWN		0xe0

/* UVSCOM_SET_SPEED parameters */
#define UVSCOM_SPEED_150BPS	0x00
#define UVSCOM_SPEED_300BPS	0x01
#define UVSCOM_SPEED_600BPS	0x02
#define UVSCOM_SPEED_1200BPS	0x03
#define UVSCOM_SPEED_2400BPS	0x04
#define UVSCOM_SPEED_4800BPS	0x05
#define UVSCOM_SPEED_9600BPS	0x06
#define UVSCOM_SPEED_19200BPS	0x07
#define UVSCOM_SPEED_38400BPS	0x08
#define UVSCOM_SPEED_57600BPS	0x09
#define UVSCOM_SPEED_115200BPS	0x0a

/* UVSCOM_LINE_CTL parameters */
#define UVSCOM_BREAK		0x40
#define UVSCOM_RTS		0x02
#define UVSCOM_DTR		0x01
#define UVSCOM_LINE_INIT	0x08

/* UVSCOM_SET_PARAM parameters */
#define UVSCOM_DATA_MASK	0x03
#define UVSCOM_DATA_BIT_8	0x03
#define UVSCOM_DATA_BIT_7	0x02
#define UVSCOM_DATA_BIT_6	0x01
#define UVSCOM_DATA_BIT_5	0x00

#define UVSCOM_STOP_MASK	0x04
#define UVSCOM_STOP_BIT_2	0x04
#define UVSCOM_STOP_BIT_1	0x00

#define UVSCOM_PARITY_MASK	0x18
#define UVSCOM_PARITY_EVEN	0x18
#if 0
#define UVSCOM_PARITY_UNK	0x10
#endif
#define UVSCOM_PARITY_ODD	0x08
#define UVSCOM_PARITY_NONE	0x00

/* Status bits */
#define UVSCOM_TXRDY		0x04
#define UVSCOM_RXRDY		0x01

#define UVSCOM_DCD		0x08
#define UVSCOM_NOCARD		0x04
#define UVSCOM_DSR		0x02
#define UVSCOM_CTS		0x01
#define UVSCOM_USTAT_MASK	(UVSCOM_NOCARD | UVSCOM_DSR | UVSCOM_CTS)

struct	uvscom_softc {
	struct device		sc_dev;		/* base device */
	struct usbd_device	*sc_udev;	/* USB device */
	struct usbd_interface	*sc_iface;	/* interface */
	int			sc_iface_number;/* interface number */

	struct usbd_interface	*sc_intr_iface;	/* interrupt interface */
	int			sc_intr_number;	/* interrupt number */
	struct usbd_pipe	*sc_intr_pipe;	/* interrupt pipe */
	u_char			*sc_intr_buf;	/* interrupt buffer */
	int			sc_isize;

	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */

	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* uvscom status register */

	uint16_t		sc_lcr;		/* Line control */
	u_char			sc_usr;		/* unit status */

	struct device		*sc_subdev;	/* ucom device */
};

/*
 * These are the maximum number of bytes transferred per frame.
 * The output buffer size cannot be increased due to the size encoding.
 */
#define UVSCOMIBUFSIZE 512
#define UVSCOMOBUFSIZE 64

usbd_status uvscom_readstat(struct uvscom_softc *);
usbd_status uvscom_shutdown(struct uvscom_softc *);
usbd_status uvscom_reset(struct uvscom_softc *);
usbd_status uvscom_set_line_coding(struct uvscom_softc *,
					   uint16_t, uint16_t);
usbd_status uvscom_set_line(struct uvscom_softc *, uint16_t);
usbd_status uvscom_set_crtscts(struct uvscom_softc *);
void uvscom_get_status(void *, int, u_char *, u_char *);
void uvscom_dtr(struct uvscom_softc *, int);
void uvscom_rts(struct uvscom_softc *, int);
void uvscom_break(struct uvscom_softc *, int);

void uvscom_set(void *, int, int, int);
void uvscom_intr(struct usbd_xfer *, void *, usbd_status);
int  uvscom_param(void *, int, struct termios *);
int  uvscom_open(void *, int);
void uvscom_close(void *, int);

struct ucom_methods uvscom_methods = {
	uvscom_get_status,
	uvscom_set,
	uvscom_param,
	NULL, /* uvscom_ioctl, TODO */
	uvscom_open,
	uvscom_close,
	NULL,
	NULL
};

static const struct usb_devno uvscom_devs [] = {
	/* SUNTAC U-Cable type A3 */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_AS64LX },
	/* SUNTAC U-Cable type A4 */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_AS144L4 },
	/* SUNTAC U-Cable type D2 */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_DS96L },
	/* SUNTAC U-Cable type P1 */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_PS64P1 },
	/* SUNTAC Slipper U  */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_VS10U },
	/* SUNTAC Ir-Trinity */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_IS96U },
};

int uvscom_match(struct device *, void *, void *);
void uvscom_attach(struct device *, struct device *, void *);
int uvscom_detach(struct device *, int);

struct cfdriver uvscom_cd = {
	NULL, "uvscom", DV_DULL
};

const struct cfattach uvscom_ca = {
	sizeof(struct uvscom_softc), uvscom_match, uvscom_attach, uvscom_detach
};

int
uvscom_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	return (usb_lookup(uvscom_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uvscom_attach(struct device *parent, struct device *self, void *aux)
{
	struct uvscom_softc *sc = (struct uvscom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	const char *devname = sc->sc_dev.dv_xname;
	usbd_status err;
	int i;
	struct ucom_attach_args uca;

        sc->sc_udev = dev;

	DPRINTF(("uvscom attach: sc = %p\n", sc));

	/* initialize endpoints */
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);

	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* get the common interface */
	err = usbd_device2interface_handle(dev, UVSCOM_IFACE_INDEX,
					   &sc->sc_iface);
	if (err) {
		printf("%s: failed to get interface, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	/* Find endpoints */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkin = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
		}
	}

	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}
	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}
	if (sc->sc_intr_number == -1) {
		printf("%s: Could not find interrupt in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	sc->sc_dtr = sc->sc_rts = 0;
	sc->sc_lcr = UVSCOM_LINE_INIT;

	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
	uca.ibufsize = UVSCOMIBUFSIZE;
	uca.obufsize = UVSCOMOBUFSIZE;
	uca.ibufsizepad = UVSCOMIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = sc->sc_iface;
	uca.methods = &uvscom_methods;
	uca.arg = sc;
	uca.info = NULL;

	err = uvscom_reset(sc);

	if (err) {
		printf("%s: reset failed, %s\n", sc->sc_dev.dv_xname,
			usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	DPRINTF(("uvscom: in = 0x%x out = 0x%x intr = 0x%x\n",
		 ucom->sc_bulkin_no, ucom->sc_bulkout_no, sc->sc_intr_number));

	DPRINTF(("uplcom: in=0x%x out=0x%x intr=0x%x\n",
			uca.bulkin, uca.bulkout, sc->sc_intr_number ));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
}

int
uvscom_detach(struct device *self, int flags)
{
	struct uvscom_softc *sc = (struct uvscom_softc *)self;
	int rv = 0;

	DPRINTF(("uvscom_detach: sc = %p\n", sc));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, 0);
		sc->sc_intr_pipe = NULL;
	}

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

usbd_status
uvscom_readstat(struct uvscom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;
	uint16_t r;

	DPRINTF(("%s: send readstat\n", sc->sc_dev.dv_xname));

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = UVSCOM_READ_STATUS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->sc_udev, &req, &r);
	if (err) {
		printf("%s: uvscom_readstat: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	DPRINTF(("%s: uvscom_readstat: r = %d\n",
		 sc->sc_dev.dv_xname, r));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvscom_shutdown(struct uvscom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: send shutdown\n", sc->sc_dev.dv_xname));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UVSCOM_SHUTDOWN;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uvscom_shutdown: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvscom_reset(struct uvscom_softc *sc)
{
	DPRINTF(("%s: uvscom_reset\n", sc->sc_dev.dv_xname));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvscom_set_crtscts(struct uvscom_softc *sc)
{
	DPRINTF(("%s: uvscom_set_crtscts\n", sc->sc_dev.dv_xname));

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvscom_set_line(struct uvscom_softc *sc, uint16_t line)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uvscom_set_line: %04x\n",
		 sc->sc_dev.dv_xname, line));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UVSCOM_LINE_CTL;
	USETW(req.wValue, line);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uvscom_set_line: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
uvscom_set_line_coding(struct uvscom_softc *sc, uint16_t lsp, uint16_t ls)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uvscom_set_line_coding: %02x %02x\n",
		 sc->sc_dev.dv_xname, lsp, ls));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UVSCOM_SET_SPEED;
	USETW(req.wValue, lsp);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uvscom_set_line_coding: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UVSCOM_SET_PARAM;
	USETW(req.wValue, ls);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uvscom_set_line_coding: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

void
uvscom_dtr(struct uvscom_softc *sc, int onoff)
{
	DPRINTF(("%s: uvscom_dtr: onoff = %d\n",
		 sc->sc_dev.dv_xname, onoff));

	if (sc->sc_dtr == onoff)
		return;			/* no change */

	sc->sc_dtr = onoff;

	if (onoff)
		SET(sc->sc_lcr, UVSCOM_DTR);
	else
		CLR(sc->sc_lcr, UVSCOM_DTR);

	uvscom_set_line(sc, sc->sc_lcr);
}

void
uvscom_rts(struct uvscom_softc *sc, int onoff)
{
	DPRINTF(("%s: uvscom_rts: onoff = %d\n",
		 sc->sc_dev.dv_xname, onoff));

	if (sc->sc_rts == onoff)
		return;			/* no change */

	sc->sc_rts = onoff;

	if (onoff)
		SET(sc->sc_lcr, UVSCOM_RTS);
	else
		CLR(sc->sc_lcr, UVSCOM_RTS);

	uvscom_set_line(sc, sc->sc_lcr);
}

void
uvscom_break(struct uvscom_softc *sc, int onoff)
{
	DPRINTF(("%s: uvscom_break: onoff = %d\n",
		 sc->sc_dev.dv_xname, onoff));

	if (onoff)
		uvscom_set_line(sc, SET(sc->sc_lcr, UVSCOM_BREAK));
}

void
uvscom_set(void *addr, int portno, int reg, int onoff)
{
	struct uvscom_softc *sc = addr;

	switch (reg) {
	case UCOM_SET_DTR:
		uvscom_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		uvscom_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		uvscom_break(sc, onoff);
		break;
	default:
		break;
	}
}

int
uvscom_param(void *addr, int portno, struct termios *t)
{
	struct uvscom_softc *sc = addr;
	usbd_status err;
	uint16_t lsp;
	uint16_t ls;

	DPRINTF(("%s: uvscom_param: sc = %p\n",
		 sc->sc_dev.dv_xname, sc));

	ls = 0;

	switch (t->c_ospeed) {
	case B150:
		lsp = UVSCOM_SPEED_150BPS;
		break;
	case B300:
		lsp = UVSCOM_SPEED_300BPS;
		break;
	case B600:
		lsp = UVSCOM_SPEED_600BPS;
		break;
	case B1200:
		lsp = UVSCOM_SPEED_1200BPS;
		break;
	case B2400:
		lsp = UVSCOM_SPEED_2400BPS;
		break;
	case B4800:
		lsp = UVSCOM_SPEED_4800BPS;
		break;
	case B9600:
		lsp = UVSCOM_SPEED_9600BPS;
		break;
	case B19200:
		lsp = UVSCOM_SPEED_19200BPS;
		break;
	case B38400:
		lsp = UVSCOM_SPEED_38400BPS;
		break;
	case B57600:
		lsp = UVSCOM_SPEED_57600BPS;
		break;
	case B115200:
		lsp = UVSCOM_SPEED_115200BPS;
		break;
	default:
		return (EIO);
	}

	if (ISSET(t->c_cflag, CSTOPB))
		SET(ls, UVSCOM_STOP_BIT_2);
	else
		SET(ls, UVSCOM_STOP_BIT_1);

	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			SET(ls, UVSCOM_PARITY_ODD);
		else
			SET(ls, UVSCOM_PARITY_EVEN);
	} else
		SET(ls, UVSCOM_PARITY_NONE);

	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		SET(ls, UVSCOM_DATA_BIT_5);
		break;
	case CS6:
		SET(ls, UVSCOM_DATA_BIT_6);
		break;
	case CS7:
		SET(ls, UVSCOM_DATA_BIT_7);
		break;
	case CS8:
		SET(ls, UVSCOM_DATA_BIT_8);
		break;
	default:
		return (EIO);
	}

	err = uvscom_set_line_coding(sc, lsp, ls);
	if (err)
		return (EIO);

	if (ISSET(t->c_cflag, CRTSCTS)) {
		err = uvscom_set_crtscts(sc);
		if (err)
			return (EIO);
	}

	return (0);
}

int
uvscom_open(void *addr, int portno)
{
	struct uvscom_softc *sc = addr;
	int err;
	int i;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("uvscom_open: sc = %p\n", sc));

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		DPRINTF(("uvscom_open: open interrupt pipe.\n"));

		sc->sc_usr = 0;		/* clear unit status */

		err = uvscom_readstat(sc);
		if (err) {
			DPRINTF(("%s: uvscom_open: readstat faild\n",
				 sc->sc_dev.dv_xname));
			return (EIO);
		}

		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_iface,
					  sc->sc_intr_number,
					  USBD_SHORT_XFER_OK,
					  &sc->sc_intr_pipe,
					  sc,
					  sc->sc_intr_buf,
					  sc->sc_isize,
					  uvscom_intr,
					  UVSCOM_INTR_INTERVAL);
		if (err) {
			printf("%s: cannot open interrupt pipe (addr %d)\n",
				 sc->sc_dev.dv_xname,
				 sc->sc_intr_number);
			return (EIO);
		}
	} else {
		DPRINTF(("uvscom_open: did not open interrupt pipe.\n"));
	}

	if ((sc->sc_usr & UVSCOM_USTAT_MASK) == 0) {
		/* unit is not ready */

		for (i = UVSCOM_UNIT_WAIT; i > 0; --i) {
			tsleep(&err, TTIPRI, "uvsop", hz);	/* XXX */
			if (ISSET(sc->sc_usr, UVSCOM_USTAT_MASK))
				break;
		}
		if (i == 0) {
			DPRINTF(("%s: unit is not ready\n",
				 sc->sc_dev.dv_xname));
			return (EIO);
		}

		/* check PC card was inserted */
		if (ISSET(sc->sc_usr, UVSCOM_NOCARD)) {
			DPRINTF(("%s: no card\n",
				 sc->sc_dev.dv_xname));
			return (EIO);
		}
	}

	return (0);
}

void
uvscom_close(void *addr, int portno)
{
	struct uvscom_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(("uvscom_close: close\n"));

	uvscom_shutdown(sc);

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname,
					   usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, 0);
		sc->sc_intr_pipe = NULL;
	}
}

void
uvscom_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct uvscom_softc *sc = priv;
	u_char *buf = sc->sc_intr_buf;
	u_char pstatus;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: uvscom_intr: abnormal status: %s\n",
			sc->sc_dev.dv_xname,
			usbd_errstr(status));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	DPRINTFN(2, ("%s: uvscom status = %02x %02x\n",
		 sc->sc_dev.dv_xname, buf[0], buf[1]));

	sc->sc_lsr = sc->sc_msr = 0;
	sc->sc_usr = buf[1];

	pstatus = buf[0];
	if (ISSET(pstatus, UVSCOM_TXRDY))
		SET(sc->sc_lsr, ULSR_TXRDY);
	if (ISSET(pstatus, UVSCOM_RXRDY))
		SET(sc->sc_lsr, ULSR_RXRDY);

	pstatus = buf[1];
	if (ISSET(pstatus, UVSCOM_CTS))
		SET(sc->sc_msr, UMSR_CTS);
	if (ISSET(pstatus, UVSCOM_DSR))
		SET(sc->sc_msr, UMSR_DSR);
	if (ISSET(pstatus, UVSCOM_DCD))
		SET(sc->sc_msr, UMSR_DCD);

	ucom_status_change((struct ucom_softc *) sc->sc_subdev);
}

void
uvscom_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct uvscom_softc *sc = addr;

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}
@


1.33
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.32 2014/07/12 21:24:33 mpi Exp $ */
a67 1
#define	UVSCOM_CONFIG_INDEX	0
d221 1
a221 1
	if (uaa->iface != NULL)
a249 9

	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UVSCOM_CONFIG_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}
@


1.32
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.31 2014/07/12 18:48:53 tedu Exp $ */
a55 1
#include <dev/usb/usb_quirks.h>
@


1.31
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.30 2013/11/15 10:17:39 pirofti Exp $ */
d206 10
a215 15
int uvscom_match(struct device *, void *, void *); 
void uvscom_attach(struct device *, struct device *, void *); 
int uvscom_detach(struct device *, int); 
int uvscom_activate(struct device *, int); 

struct cfdriver uvscom_cd = { 
	NULL, "uvscom", DV_DULL 
}; 

const struct cfattach uvscom_ca = { 
	sizeof(struct uvscom_softc), 
	uvscom_match, 
	uvscom_attach, 
	uvscom_detach, 
	uvscom_activate, 
a379 13
}

int
uvscom_activate(struct device *self, int act)
{
	struct uvscom_softc *sc = (struct uvscom_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.30
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.29 2013/11/15 08:25:31 pirofti Exp $ */
d375 1
a375 1
		free(sc->sc_intr_buf, M_USBDEV);
d782 1
a782 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.29
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.28 2013/11/07 10:33:09 pirofti Exp $ */
d776 1
a776 5
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname,
					   usbd_errstr(err));
@


1.28
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.27 2013/04/15 09:23:02 mglocker Exp $ */
a390 1
	int rv = 0;
a393 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d397 1
a397 1
	return (rv);
@


1.27
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.26 2013/03/28 03:58:03 tedu Exp $ */
a152 1
	u_char			sc_dying;	/* disconnecting */
d263 1
a263 1
		sc->sc_dying = 1;
d273 1
a273 1
		sc->sc_dying = 1;
d283 1
a283 1
		sc->sc_dying = 1;
d296 1
a296 1
			sc->sc_dying = 1;
d316 1
a316 1
		sc->sc_dying = 1;
d322 1
a322 1
		sc->sc_dying = 1;
d328 1
a328 1
		sc->sc_dying = 1;
d352 1
a352 1
		sc->sc_dying = 1;
d397 1
a397 1
		sc->sc_dying = 1;
d703 1
a703 1
	if (sc->sc_dying)
d771 1
a771 1
	if (sc->sc_dying)
d801 1
a801 1
	if (sc->sc_dying)
@


1.26
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.25 2013/03/28 03:31:56 tedu Exp $ */
d133 2
a134 2
	usbd_device_handle	sc_udev;	/* USB device */
	usbd_interface_handle	sc_iface;	/* interface */
d137 1
a137 1
	usbd_interface_handle	sc_intr_iface;	/* interrupt interface */
d139 1
a139 1
	usbd_pipe_handle	sc_intr_pipe;	/* interrupt pipe */
d176 1
a176 1
void uvscom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d241 1
a241 1
	usbd_device_handle dev = uaa->device;
d796 1
a796 1
uvscom_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.25
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.24 2011/07/03 15:47:18 matthew Exp $ */
a47 1
#include <sys/proc.h>
@


1.24
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.23 2011/01/25 20:03:36 jakemsr Exp $ */
a48 1
#include <sys/vnode.h>
@


1.23
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.22 2010/12/17 21:53:34 jasper Exp $ */
a396 3
	case DVACT_ACTIVATE:
		break;

@


1.22
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.21 2010/09/24 08:33:59 yuo Exp $ */
a361 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a385 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.21
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.20 2009/10/13 19:33:19 pirofti Exp $ */
a207 1
#define uvscom_lookup(v, p) usb_lookup(uvscom_devs, v, p)
d234 2
a235 2
	return (uvscom_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.20
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.19 2007/10/11 18:33:15 deraadt Exp $ */
a378 2
	sc->sc_dying = 1;

a385 1
	sc->sc_dying = 1;
@


1.19
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.18 2007/06/14 10:11:16 mbalmer Exp $ */
d213 1
a213 1
int uvscom_activate(struct device *, enum devact); 
d401 1
a401 1
uvscom_activate(struct device *self, enum devact act)
@


1.18
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.17 2007/06/13 06:25:03 mbalmer Exp $ */
a247 1
	char *devinfop;
a251 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.17
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.16 2007/06/12 16:26:37 mbalmer Exp $ */
d210 16
a225 1
USB_DECLARE_DRIVER(uvscom);
@


1.16
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.15 2007/06/10 14:49:01 mbalmer Exp $ */
d154 1
a154 1
	struct device *		sc_subdev;	/* ucom device */
@


1.15
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.14 2007/06/10 10:53:49 mbalmer Exp $ */
d154 1
a154 1
	device_ptr_t		sc_subdev;	/* ucom device */
d391 1
a391 1
uvscom_activate(device_ptr_t self, enum devact act)
@


1.14
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.13 2007/06/06 19:25:50 mk Exp $ */
d234 1
a234 1
	const char *devname = USBDEVNAME(sc->sc_dev);
d266 1
a266 1
			USBDEVNAME(sc->sc_dev));
d289 1
a289 1
				USBDEVNAME(sc->sc_dev), i);
d309 1
a309 1
			USBDEVNAME(sc->sc_dev));
d315 1
a315 1
			USBDEVNAME(sc->sc_dev));
d321 1
a321 1
			USBDEVNAME(sc->sc_dev));
d344 1
a344 1
		printf("%s: reset failed, %s\n", USBDEVNAME(sc->sc_dev),
d416 1
a416 1
	DPRINTF(("%s: send readstat\n", USBDEVNAME(sc->sc_dev)));
d427 1
a427 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d432 1
a432 1
		 USBDEVNAME(sc->sc_dev), r));
d443 1
a443 1
	DPRINTF(("%s: send shutdown\n", USBDEVNAME(sc->sc_dev)));
d454 1
a454 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d464 1
a464 1
	DPRINTF(("%s: uvscom_reset\n", USBDEVNAME(sc->sc_dev)));
d472 1
a472 1
	DPRINTF(("%s: uvscom_set_crtscts\n", USBDEVNAME(sc->sc_dev)));
d484 1
a484 1
		 USBDEVNAME(sc->sc_dev), line));
d495 1
a495 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d509 1
a509 1
		 USBDEVNAME(sc->sc_dev), lsp, ls));
d520 1
a520 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d533 1
a533 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d544 1
a544 1
		 USBDEVNAME(sc->sc_dev), onoff));
d563 1
a563 1
		 USBDEVNAME(sc->sc_dev), onoff));
d582 1
a582 1
		 USBDEVNAME(sc->sc_dev), onoff));
d617 1
a617 1
		 USBDEVNAME(sc->sc_dev), sc));
d722 1
a722 1
				 USBDEVNAME(sc->sc_dev)));
d738 1
a738 1
				 USBDEVNAME(sc->sc_dev),
d756 1
a756 1
				 USBDEVNAME(sc->sc_dev)));
d763 1
a763 1
				 USBDEVNAME(sc->sc_dev)));
d788 1
a788 1
				USBDEVNAME(sc->sc_dev),
d793 1
a793 1
				USBDEVNAME(sc->sc_dev),
d815 1
a815 1
			USBDEVNAME(sc->sc_dev),
d822 1
a822 1
		 USBDEVNAME(sc->sc_dev), buf[0], buf[1]));
@


1.13
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.12 2007/06/05 08:43:56 mbalmer Exp $ */
d354 1
a354 1
			   USBDEV(sc->sc_dev));
d385 1
a385 1
			   USBDEV(sc->sc_dev));
@


1.12
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.11 2007/05/31 18:20:22 mbalmer Exp $ */
d134 1
a134 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.11
log
@Remove more #ifdef/#endif's that checked for other bsds.  No binary
change, no functionality change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.10 2007/05/27 04:00:25 jsg Exp $ */
d165 4
a168 4
Static	usbd_status uvscom_readstat(struct uvscom_softc *);
Static	usbd_status uvscom_shutdown(struct uvscom_softc *);
Static	usbd_status uvscom_reset(struct uvscom_softc *);
Static	usbd_status uvscom_set_line_coding(struct uvscom_softc *,
d170 12
a181 12
Static	usbd_status uvscom_set_line(struct uvscom_softc *, uint16_t);
Static	usbd_status uvscom_set_crtscts(struct uvscom_softc *);
Static	void uvscom_get_status(void *, int, u_char *, u_char *);
Static	void uvscom_dtr(struct uvscom_softc *, int);
Static	void uvscom_rts(struct uvscom_softc *, int);
Static	void uvscom_break(struct uvscom_softc *, int);

Static	void uvscom_set(void *, int, int, int);
Static	void uvscom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static	int  uvscom_param(void *, int, struct termios *);
Static	int  uvscom_open(void *, int);
Static	void uvscom_close(void *, int);
d409 1
a409 1
Static usbd_status
d437 1
a437 1
Static usbd_status
d461 1
a461 1
Static usbd_status
d469 1
a469 1
Static usbd_status
d477 1
a477 1
Static usbd_status
d502 1
a502 1
Static usbd_status
d540 1
a540 1
Static void
d559 1
a559 1
Static void
d578 1
a578 1
Static void
d588 1
a588 1
Static void
d608 1
a608 1
Static int
d702 1
a702 1
Static int
d771 1
a771 1
Static void
d800 1
a800 1
Static void
d844 1
a844 1
Static void
@


1.10
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.9 2007/05/21 05:40:28 jsg Exp $ */
a45 9
#if defined(__FreeBSD__)
#include <sys/bus.h>
#include <sys/ioccom.h>
#if __FreeBSD_version >= 500014
#include <sys/selinfo.h>
#else
#include <sys/select.h>
#endif
#else
a47 1
#endif
a64 9
#if defined(__FreeBSD__)
#include <sys/sysctl.h>

SYSCTL_DECL(_debug_usb);
SYSCTL_INT(_debug_usb, OID_AUTO, uvscom, CTLFLAG_RW,
	   &uvscomdebug, 0, "uvscom debug level");

#endif

a70 4
#if defined(__FreeBSD__)
#define UVSCOM_MODVER		1	/* module version */
#endif

a211 24
#ifdef __FreeBSD__
Static device_probe_t uvscom_match;
Static device_attach_t uvscom_attach;
Static device_detach_t uvscom_detach;

Static device_method_t uvscom_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe, uvscom_match),
	DEVMETHOD(device_attach, uvscom_attach),
	DEVMETHOD(device_detach, uvscom_detach),
	{ 0, 0 }
};

Static driver_t uvscom_driver = {
	"usio",
	uvscom_methods,
	sizeof (struct uvscom_softc)
};

DRIVER_MODULE(uvscom, uhub, uvscom_driver, ucom_devclass, usbd_driver_load, 0);
MODULE_DEPEND(uvscom, ucom, UCOM_MINVER, UCOM_PREFVER, UCOM_MAXVER);
MODULE_VERSION(uvscom, UVSCOM_MODVER);
#endif

a853 1

@


1.9
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.8 2006/06/23 06:27:12 miod Exp $ */
d259 2
a260 1
USB_MATCH(uvscom)
d262 1
a262 1
	USB_MATCH_START(uvscom, uaa);
d271 2
a272 1
USB_ATTACH(uvscom)
d274 2
a275 1
	USB_ATTACH_START(uvscom, sc, uaa);
d287 1
a287 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d305 1
a305 1
		USB_ATTACH_ERROR_RETURN;
d315 1
a315 1
		USB_ATTACH_ERROR_RETURN;
d325 1
a325 1
		USB_ATTACH_ERROR_RETURN;
d338 1
a338 1
			USB_ATTACH_ERROR_RETURN;
d358 1
a358 1
		USB_ATTACH_ERROR_RETURN;
d364 1
a364 1
		USB_ATTACH_ERROR_RETURN;
d370 1
a370 1
		USB_ATTACH_ERROR_RETURN;
d394 1
a394 1
		USB_ATTACH_ERROR_RETURN;
a405 2

	USB_ATTACH_SUCCESS_RETURN;
d408 2
a409 1
USB_DETACH(uvscom)
d411 1
a411 1
	USB_DETACH_START(uvscom, sc);
@


1.8
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.7 2005/08/01 05:41:54 brad Exp $ */
d84 1
a84 1
#define DPRINTFN(n, x)  do { if (uvscomdebug > (n)) logprintf x; } while (0)
@


1.7
log
@spaces vs tab
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.6 2005/08/01 05:36:49 brad Exp $ */
d444 1
a444 1
		return (EOPNOTSUPP);
@


1.6
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.5 2004/07/11 09:27:54 deraadt Exp $ */
d284 2
a285 2
        USB_ATTACH_SETUP;
        printf("%s: %s\n", devname, devinfop);
@


1.5
log
@support two more suntac products; from freebsd
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.4 2004/07/08 22:18:45 deraadt Exp $ */
d277 1
a277 1
	char devinfo[1024];
d283 1
a283 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d285 2
a286 1
        printf("%s: %s\n", devname, devinfo);
@


1.4
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.3 2003/05/17 17:07:32 nate Exp $ */
d218 4
@


1.3
log
@more devices from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.2 2003/05/07 04:33:33 deraadt Exp $ */
d84 1
a84 4
#define DPRINTFN(n, x)  do { \
				if (uvscomdebug > (n)) \
					logprintf x; \
			} while (0)
@


1.2
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvscom.c,v 1.1 2002/11/30 19:09:59 nate Exp $ */
/*	$NetBSD: uvscom.c,v 1.7 2002/09/23 05:51:23 simonb Exp $	*/
d221 2
d227 2
@


1.1
log
@Add driver for SUNTAC Slipper VS-10U communications device
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d278 1
a278 1
        usbd_devinfo(dev, 0, devinfo);
@


1.1.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvscom.c,v 1.1 2002/11/30 19:09:59 nate Exp $ */
d278 1
a278 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.1.4.2
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uvscom.c,v 1.9 2003/02/12 15:36:20 ichiro Exp $	*/
a220 2
	/* SUNTAC U-Cable type D2 */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_DS96L },
a224 2
	/* SUNTAC Ir-Trinity */
	{ USB_VENDOR_SUNTAC, USB_PRODUCT_SUNTAC_IS96U },
@


