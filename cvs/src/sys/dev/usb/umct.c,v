head	1.45;
access;
symbols
	OPENBSD_6_1_BASE:1.45
	OPENBSD_6_0:1.44.0.8
	OPENBSD_6_0_BASE:1.44
	OPENBSD_5_9:1.44.0.2
	OPENBSD_5_9_BASE:1.44
	OPENBSD_5_8:1.44.0.4
	OPENBSD_5_8_BASE:1.44
	OPENBSD_5_7:1.42.0.2
	OPENBSD_5_7_BASE:1.42
	OPENBSD_5_6:1.41.0.4
	OPENBSD_5_6_BASE:1.41
	OPENBSD_5_5:1.39.0.4
	OPENBSD_5_5_BASE:1.39
	OPENBSD_5_4:1.36.0.2
	OPENBSD_5_4_BASE:1.36
	OPENBSD_5_3:1.33.0.8
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.6
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.33
	OPENBSD_5_1:1.33.0.4
	OPENBSD_5_0:1.33.0.2
	OPENBSD_5_0_BASE:1.33
	OPENBSD_4_9:1.32.0.2
	OPENBSD_4_9_BASE:1.32
	OPENBSD_4_8:1.29.0.4
	OPENBSD_4_8_BASE:1.29
	OPENBSD_4_7:1.29.0.2
	OPENBSD_4_7_BASE:1.29
	OPENBSD_4_6:1.28.0.8
	OPENBSD_4_6_BASE:1.28
	OPENBSD_4_5:1.28.0.4
	OPENBSD_4_5_BASE:1.28
	OPENBSD_4_4:1.28.0.2
	OPENBSD_4_4_BASE:1.28
	OPENBSD_4_3:1.27.0.2
	OPENBSD_4_3_BASE:1.27
	OPENBSD_4_2:1.26.0.2
	OPENBSD_4_2_BASE:1.26
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.2
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.13.0.2
	OPENBSD_3_7_BASE:1.13
	OPENBSD_3_6:1.12.0.4
	OPENBSD_3_6_BASE:1.12
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.9.0.2
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.8.0.2
	OPENBSD_3_4_BASE:1.8
	UBC_SYNC_A:1.7
	SMP:1.6.0.4
	OPENBSD_3_3:1.6.0.2
	OPENBSD_3_3_BASE:1.6
	UBC:1.5.0.4
	UBC_SYNC_B:1.5
	OPENBSD_3_2:1.5.0.2
	OPENBSD_3_2_BASE:1.5;
locks; strict;
comment	@ * @;


1.45
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.44;
commitid	blfE5YU3eGM81J65;

1.44
date	2015.04.26.06.38.04;	author jmatthew;	state Exp;
branches;
next	1.43;
commitid	vszAWBoMnXB8iRQ6;

1.43
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.42;
commitid	p4LJxGKbi0BU2cG6;

1.42
date	2014.11.18.23.55.01;	author krw;	state Exp;
branches;
next	1.41;
commitid	Qb045HZ5OhQfU69H;

1.41
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.40;
commitid	PSjXNz8dGohZ6ZSK;

1.40
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.39;
commitid	OBNa5kfxQ2UXoiIw;

1.39
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2013.11.07.07.32.07;	author pirofti;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.32;

1.32
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.31;

1.31
date	2010.12.17.21.53.34;	author jasper;	state Exp;
branches;
next	1.30;

1.30
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.28;

1.28
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.27;

1.27
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2005.08.01.05.41.54;	author brad;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2004.09.20.21.34.46;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.11.07.39.38;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.04.20.16.28.36;	author pvalchev;	state Exp;
branches;
next	1.9;

1.9
date	2003.11.07.20.22.35;	author jmc;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.19.00.36.12;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.11.06.42.17;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.5.4.1
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.5.4.2;

1.5.4.2
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;

1.6.4.1
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.4.3;

1.6.4.3
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.6.4.4;

1.6.4.4
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.45
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: umct.c,v 1.44 2015/04/26 06:38:04 jmatthew Exp $	*/
/*	$NetBSD: umct.c,v 1.10 2003/02/23 04:20:07 simonb Exp $	*/
/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Ichiro FUKUHARA (ichiro@@ichiro.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * MCT USB-RS232 Interface Controller
 * http://www.mct.com.tw/prod/rs232.html
 * http://www.dlink.com/products/usb/dsbs25
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/device.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#include <dev/usb/umct.h>

#ifdef UMCT_DEBUG
#define DPRINTFN(n, x)  do { if (umctdebug > (n)) printf x; } while (0)
int	umctdebug = 0;
#else
#define DPRINTFN(n, x)
#endif
#define DPRINTF(x) DPRINTFN(0, x)

#define	UMCT_IFACE_INDEX	0

struct	umct_softc {
	struct device		 sc_dev;	/* base device */
	struct usbd_device	*sc_udev;	/* USB device */
	struct usbd_interface	*sc_iface;	/* interface */
	int			 sc_iface_number;	/* interface number */
	u_int16_t		 sc_product;

	int			 sc_intr_number;	/* interrupt number */
	struct usbd_pipe	*sc_intr_pipe;	/* interrupt pipe */
	u_char			*sc_intr_buf;	/* interrupt buffer */
	int			 sc_isize;

	struct usb_cdc_line_state sc_line_state;	/* current line state */
	u_char			 sc_dtr;	/* current DTR state */
	u_char			 sc_rts;	/* current RTS state */
	u_char			 sc_break;	/* set break */

	u_char			 sc_status;

	struct device		*sc_subdev;	/* ucom device */

	u_char			 sc_lsr;	/* Local status register */
	u_char			 sc_msr;	/* umct status register */

	u_int			 last_lcr;	/* keep lcr register */
};

/*
 * These are the maximum number of bytes transferred per frame.
 * The output buffer size cannot be increased due to the size encoding.
 */
#define UMCTIBUFSIZE 256
#define UMCTOBUFSIZE 256

void umct_init(struct umct_softc *);
void umct_set_baudrate(struct umct_softc *, u_int, int);
void umct_set_lcr(struct umct_softc *, u_int);
void umct_intr(struct usbd_xfer *, void *, usbd_status);

void umct_set(void *, int, int, int);
void umct_dtr(struct umct_softc *, int);
void umct_rts(struct umct_softc *, int);
void umct_break(struct umct_softc *, int);
void umct_set_line_state(struct umct_softc *);
void umct_get_status(void *, int portno, u_char *lsr, u_char *msr);
int  umct_param(void *, int, struct termios *);
int  umct_open(void *, int);
void umct_close(void *, int);

struct	ucom_methods umct_methods = {
	umct_get_status,
	umct_set,
	umct_param,
	NULL,
	umct_open,
	umct_close,
	NULL,
	NULL,
};

static const struct usb_devno umct_devs[] = {
	/* MCT USB-232 Interface Products */
	{ USB_VENDOR_MCT, USB_PRODUCT_MCT_USB232 },
	/* Sitecom USB-232 Products */
	{ USB_VENDOR_MCT, USB_PRODUCT_MCT_SITECOM_USB232 },
	/* D-Link DU-H3SP USB BAY Hub Products */
	{ USB_VENDOR_MCT, USB_PRODUCT_MCT_DU_H3SP_USB232 },
	/* BELKIN F5U109 */
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U109 },
	/* BELKIN F5U409 */
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U409 },
};

int umct_match(struct device *, void *, void *);
void umct_attach(struct device *, struct device *, void *);
int umct_detach(struct device *, int);

struct cfdriver umct_cd = {
	NULL, "umct", DV_DULL
};

const struct cfattach umct_ca = {
	sizeof(struct umct_softc), umct_match, umct_attach, umct_detach
};

int
umct_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	return (usb_lookup(umct_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
umct_attach(struct device *parent, struct device *self, void *aux)
{
	struct umct_softc *sc = (struct umct_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;

	char *devname = sc->sc_dev.dv_xname;
	usbd_status err;
	int i;
	struct ucom_attach_args uca;

        sc->sc_udev = dev;
	sc->sc_product = uaa->product;

	DPRINTF(("\n\numct attach: sc=%p\n", sc));

	/* initialize endpoints */
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;

	/* get the config descriptor */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);

	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* get the interface */
	err = usbd_device2interface_handle(dev, UMCT_IFACE_INDEX,
							&sc->sc_iface);
	if (err) {
		printf("\n%s: failed to get interface, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Find the bulk{in,out} and interrupt endpoints */

	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
				sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		/*
		 * The Bulkin endpoint is marked as an interrupt. Since
		 * we can't rely on the endpoint descriptor order, we'll
		 * check the wMaxPacketSize field to differentiate.
		 */
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT &&
		    UGETW(ed->wMaxPacketSize) != 0x2) {
			uca.bulkin = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);
		}
	}

	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	if (sc->sc_intr_number== -1) {
		printf("%s: Could not find interrupt in\n",
			sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	sc->sc_dtr = sc->sc_rts = 0;
	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
	uca.ibufsize = UMCTIBUFSIZE;
	if (sc->sc_product == USB_PRODUCT_MCT_SITECOM_USB232)
		uca.obufsize = 16; /* device is broken */
	else
		uca.obufsize = UMCTOBUFSIZE;
	uca.ibufsizepad = UMCTIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = sc->sc_iface;
	uca.methods = &umct_methods;
	uca.arg = sc;
	uca.info = NULL;

	umct_init(sc);

	DPRINTF(("umct: in=0x%x out=0x%x intr=0x%x\n",
			uca.bulkin, uca.bulkout, sc->sc_intr_number ));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
}

int
umct_detach(struct device *self, int flags)
{
	struct umct_softc *sc = (struct umct_softc *)self;
	int rv = 0;

	DPRINTF(("umct_detach: sc=%p flags=%d\n", sc, flags));

        if (sc->sc_intr_pipe != NULL) {
                usbd_abort_pipe(sc->sc_intr_pipe);
                usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, 0);
                sc->sc_intr_pipe = NULL;
        }

	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	return (rv);
}

void
umct_set_line_state(struct umct_softc *sc)
{
	usb_device_request_t req;
	uByte ls;

	ls = (sc->sc_dtr ? MCR_DTR : 0) |
	     (sc->sc_rts ? MCR_RTS : 0);

	DPRINTF(("umct_set_line_state: DTR=%d,RTS=%d,ls=%02x\n",
			sc->sc_dtr, sc->sc_rts, ls));

	req.bmRequestType = UMCT_SET_REQUEST;
	req.bRequest = REQ_SET_MCR;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, LENGTH_SET_MCR);

	(void)usbd_do_request(sc->sc_udev, &req, &ls);
}

void
umct_set(void *addr, int portno, int reg, int onoff)
{
	struct umct_softc *sc = addr;

	switch (reg) {
	case UCOM_SET_DTR:
		umct_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		umct_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		umct_break(sc, onoff);
		break;
	default:
		break;
	}
}

void
umct_dtr(struct umct_softc *sc, int onoff)
{

	DPRINTF(("umct_dtr: onoff=%d\n", onoff));

	if (sc->sc_dtr == onoff)
		return;
	sc->sc_dtr = onoff;

	umct_set_line_state(sc);
}

void
umct_rts(struct umct_softc *sc, int onoff)
{
	DPRINTF(("umct_rts: onoff=%d\n", onoff));

	if (sc->sc_rts == onoff)
		return;
	sc->sc_rts = onoff;

	umct_set_line_state(sc);
}

void
umct_break(struct umct_softc *sc, int onoff)
{
	DPRINTF(("umct_break: onoff=%d\n", onoff));

	umct_set_lcr(sc, onoff ? sc->last_lcr | LCR_SET_BREAK :
		     sc->last_lcr);
}

void
umct_set_lcr(struct umct_softc *sc, u_int data)
{
	usb_device_request_t req;
	uByte adata;

	adata = data;
	req.bmRequestType = UMCT_SET_REQUEST;
	req.bRequest = REQ_SET_LCR;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, LENGTH_SET_LCR);

	/* XXX should check */
	(void)usbd_do_request(sc->sc_udev, &req, &adata);
}

void
umct_set_baudrate(struct umct_softc *sc, u_int rate, int cts)
{
        usb_device_request_t req;
	uDWord arate;
	u_int val;

	if (sc->sc_product == USB_PRODUCT_MCT_SITECOM_USB232 ||
	    sc->sc_product == USB_PRODUCT_BELKIN_F5U109) {
		switch (rate) {
		case    300: val = 0x01; break;
		case    600: val = 0x02; break;
		case   1200: val = 0x03; break;
		case   2400: val = 0x04; break;
		case   4800: val = 0x06; break;
		case   9600: val = 0x08; break;
		case  19200: val = 0x09; break;
		case  38400: val = 0x0a; break;
		case  57600: val = 0x0b; break;
		case 115200: val = 0x0c; break;
		default:     val = -1; break;
		}
	} else {
		val = UMCT_BAUD_RATE(rate);
	}
	USETDW(arate, val);

        req.bmRequestType = UMCT_SET_REQUEST;
        req.bRequest = REQ_SET_BAUD_RATE;
        USETW(req.wValue, 0);
        USETW(req.wIndex, sc->sc_iface_number);
        USETW(req.wLength, LENGTH_BAUD_RATE);

	/* XXX should check */
        (void)usbd_do_request(sc->sc_udev, &req, arate);

	/* unknown request, required after setting baud rate */
	USETDW(arate, 0);
	req.bmRequestType = UMCT_SET_REQUEST;
	req.bRequest = REQ_UNKNOWN1;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, LENGTH_UNKNOWN1);
	(void)usbd_do_request(sc->sc_udev, &req, arate);

	/* update CTS, also required after setting baud rate */
	USETDW(arate, cts);
	req.bmRequestType = UMCT_SET_REQUEST;
	req.bRequest = REQ_SET_CTS;
	USETW(req.wValue, 0);
	USETW(req.wIndex, sc->sc_iface_number);
	USETW(req.wLength, LENGTH_SET_CTS);
	(void)usbd_do_request(sc->sc_udev, &req, arate);
}

void
umct_init(struct umct_softc *sc)
{
	umct_set_baudrate(sc, 9600, 0);
	umct_set_lcr(sc, LCR_DATA_BITS_8 | LCR_PARITY_NONE | LCR_STOP_BITS_1);
}

int
umct_param(void *addr, int portno, struct termios *t)
{
	struct umct_softc *sc = addr;
	u_int data = 0;

	DPRINTF(("umct_param: sc=%p\n", sc));

	DPRINTF(("umct_param: BAUDRATE=%d\n", t->c_ospeed));

	if (ISSET(t->c_cflag, CSTOPB))
		data |= LCR_STOP_BITS_2;
	else
		data |= LCR_STOP_BITS_1;
	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			data |= LCR_PARITY_ODD;
		else
			data |= LCR_PARITY_EVEN;
	} else
		data |= LCR_PARITY_NONE;
	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		data |= LCR_DATA_BITS_5;
		break;
	case CS6:
		data |= LCR_DATA_BITS_6;
		break;
	case CS7:
		data |= LCR_DATA_BITS_7;
		break;
	case CS8:
		data |= LCR_DATA_BITS_8;
		break;
	}

	umct_set_baudrate(sc, t->c_ospeed, ISSET(t->c_cflag, CRTSCTS));

	sc->last_lcr = data;
	umct_set_lcr(sc, data);

	return (0);
}

int
umct_open(void *addr, int portno)
{
	struct umct_softc *sc = addr;
	int err, lcr_data;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("umct_open: sc=%p\n", sc));

	/* initialize LCR */
        lcr_data = LCR_DATA_BITS_8 | LCR_PARITY_NONE |
	    LCR_STOP_BITS_1;
        umct_set_lcr(sc, lcr_data);

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_status = 0; /* clear status bit */
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_intr_number,
			USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc,
			sc->sc_intr_buf, sc->sc_isize,
			umct_intr, USBD_DEFAULT_INTERVAL);
		if (err) {
			DPRINTF(("%s: cannot open interrupt pipe (addr %d)\n",
				sc->sc_dev.dv_xname, sc->sc_intr_number));
					return (EIO);
		}
	}

	return (0);
}

void
umct_close(void *addr, int portno)
{
	struct umct_softc *sc = addr;
	int err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	DPRINTF(("umct_close: close\n"));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, 0);
		sc->sc_intr_pipe = NULL;
	}
}

void
umct_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct umct_softc *sc = priv;
	u_char *buf = sc->sc_intr_buf;
	u_char mstatus;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		DPRINTF(("%s: abnormal status: %s\n", sc->sc_dev.dv_xname,
			usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	DPRINTF(("%s: umct status = MSR:%02x, LSR:%02x\n",
		 sc->sc_dev.dv_xname, buf[0],buf[1]));

	sc->sc_lsr = sc->sc_msr = 0;
	mstatus = buf[0];
	if (ISSET(mstatus, MSR_DSR))
		sc->sc_msr |= UMSR_DSR;
	if (ISSET(mstatus, MSR_DCD))
		sc->sc_msr |= UMSR_DCD;
	ucom_status_change((struct ucom_softc *)sc->sc_subdev);
}

void
umct_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
	struct umct_softc *sc = addr;

	DPRINTF(("umct_get_status:\n"));

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
}
@


1.44
log
@Two extra messages required after sending a baud rate update, as observed
in the linux mct_u232 driver, which apparently got them by sniffing usb
traffic from the vendor's windows 98 driver.  Makes this device work at
115200:

umct0 at uhub0 port 2 "Belkin Components F5U109 Serial" rev 1.10/1.02 addr 2

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.43 2015/03/14 03:38:50 jsg Exp $	*/
a68 1
#define	UMCT_CONFIG_INDEX	0
d161 1
a161 1
	if (uaa->iface != NULL)
a191 9

	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UMCT_CONFIG_INDEX, 1);
	if (err) {
		printf("\n%s: failed to set configuration, err=%s\n",
			devname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}
@


1.43
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.42 2014/11/18 23:55:01 krw Exp $	*/
d107 1
a107 1
void umct_set_baudrate(struct umct_softc *, u_int);
d416 1
a416 1
umct_set_baudrate(struct umct_softc *sc, u_int rate)
d450 18
d473 1
a473 1
	umct_set_baudrate(sc, 9600);
d513 1
a513 1
	umct_set_baudrate(sc, t->c_ospeed);
@


1.42
log
@Nuke yet more obvious #include duplications.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.41 2014/07/12 20:26:33 mpi Exp $	*/
a55 1
#include <dev/usb/usb_quirks.h>
@


1.41
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.40 2014/07/12 18:48:52 tedu Exp $	*/
a57 1
#include <dev/usb/usbdevs.h>
@


1.40
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.39 2013/11/15 10:17:39 pirofti Exp $	*/
d147 10
a156 15
int umct_match(struct device *, void *, void *); 
void umct_attach(struct device *, struct device *, void *); 
int umct_detach(struct device *, int); 
int umct_activate(struct device *, int); 

struct cfdriver umct_cd = { 
	NULL, "umct", DV_DULL 
}; 

const struct cfattach umct_ca = { 
	sizeof(struct umct_softc), 
	umct_match, 
	umct_attach, 
	umct_detach, 
	umct_activate, 
a322 13
}

int
umct_activate(struct device *self, int act)
{
	struct umct_softc *sc = (struct umct_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.39
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.38 2013/11/15 08:25:31 pirofti Exp $	*/
d318 1
a318 1
		free(sc->sc_intr_buf, M_USBDEV);
d573 1
a573 1
		free(sc->sc_intr_buf, M_USBDEV);
@


1.38
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.37 2013/11/07 07:32:07 pirofti Exp $	*/
d568 1
a568 4
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
				sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.37
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.36 2013/04/15 09:23:02 mglocker Exp $	*/
a333 1
	int rv = 0;
a336 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d340 1
a340 1
	return (rv);
@


1.36
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.35 2013/03/28 03:58:03 tedu Exp $	*/
a94 2
	u_char			 sc_dying;	/* disconnecting */

d206 1
a206 1
		sc->sc_dying = 1;
d216 1
a216 1
		sc->sc_dying = 1;
d226 1
a226 1
		sc->sc_dying = 1;
d240 1
a240 1
			sc->sc_dying = 1;
d266 1
a266 1
		sc->sc_dying = 1;
d273 1
a273 1
		sc->sc_dying = 1;
d280 1
a280 1
		sc->sc_dying = 1;
d340 1
a340 1
		sc->sc_dying = 1;
d532 1
a532 1
	if (sc->sc_dying)
d565 1
a565 1
	if (sc->sc_dying)
d591 1
a591 1
	if (sc->sc_dying)
@


1.35
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.34 2013/03/28 03:31:55 tedu Exp $	*/
d76 2
a77 2
	usbd_device_handle	sc_udev;	/* USB device */
	usbd_interface_handle	 sc_iface;	/* interface */
d82 1
a82 1
	usbd_pipe_handle	 sc_intr_pipe;	/* interrupt pipe */
d86 1
a86 1
	usb_cdc_line_state_t	 sc_line_state;	/* current line state */
d113 1
a113 1
void umct_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d183 1
a183 1
	usbd_device_handle dev = uaa->device;
d587 1
a587 1
umct_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.34
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.33 2011/07/03 15:47:17 matthew Exp $	*/
a46 1
#include <sys/proc.h>
@


1.33
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.32 2011/01/25 20:03:36 jakemsr Exp $	*/
a47 1
#include <sys/vnode.h>
@


1.32
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.31 2010/12/17 21:53:34 jasper Exp $	*/
a340 3
	case DVACT_ACTIVATE:
		break;

@


1.31
log
@- use usb_lookup() instead of handrolled macro

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.30 2010/09/24 08:33:59 yuo Exp $	*/
a305 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a329 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.30
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.29 2009/10/13 19:33:19 pirofti Exp $	*/
a149 1
#define umct_lookup(v, p) usb_lookup(umct_devs, v, p)
d176 2
a177 2
	return (umct_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
@


1.29
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.28 2008/06/26 05:42:19 ray Exp $	*/
a329 1
	sc->sc_dying = 1;
@


1.28
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.27 2007/10/11 18:33:15 deraadt Exp $	*/
d155 1
a155 1
int umct_activate(struct device *, enum devact); 
d343 1
a343 1
umct_activate(struct device *self, enum devact act)
@


1.27
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.26 2007/06/14 10:11:16 mbalmer Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.26
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.25 2007/06/13 06:25:03 mbalmer Exp $	*/
a197 1
	char *devinfop;
a201 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.25
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.24 2007/06/12 16:26:36 mbalmer Exp $	*/
d159 16
a174 1
USB_DECLARE_DRIVER(umct);
@


1.24
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.23 2007/06/10 14:49:01 mbalmer Exp $	*/
d84 1
a84 1
	struct device		sc_dev;		/* base device */
d86 3
a88 3
	usbd_interface_handle	sc_iface;	/* interface */
	int			sc_iface_number;	/* interface number */
	u_int16_t		sc_product;
d90 2
a91 2
	int			sc_intr_number;	/* interrupt number */
	usbd_pipe_handle	sc_intr_pipe;	/* interrupt pipe */
d93 1
a93 1
	int			sc_isize;
d95 4
a98 4
	usb_cdc_line_state_t	sc_line_state;	/* current line state */
	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */
	u_char			sc_break;	/* set break */
d100 1
a100 1
	u_char			sc_status;
d102 1
a102 1
	struct device *		sc_subdev;	/* ucom device */
d104 1
a104 1
	u_char			sc_dying;	/* disconnecting */
d106 2
a107 2
	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* umct status register */
d109 1
a109 1
	u_int			last_lcr;	/* keep lcr register */
@


1.23
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.22 2007/06/10 10:53:48 mbalmer Exp $	*/
d102 1
a102 1
	device_ptr_t		sc_subdev;	/* ucom device */
d340 1
a340 1
umct_activate(device_ptr_t self, enum devact act)
@


1.22
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.21 2007/06/06 19:25:49 mk Exp $	*/
d184 1
a184 1
	char *devname = USBDEVNAME(sc->sc_dev);
d217 1
a217 1
			USBDEVNAME(sc->sc_dev));
d241 1
a241 1
				USBDEVNAME(sc->sc_dev), i);
d267 1
a267 1
			USBDEVNAME(sc->sc_dev));
d274 1
a274 1
			USBDEVNAME(sc->sc_dev));
d281 1
a281 1
			USBDEVNAME(sc->sc_dev));
d563 1
a563 1
				USBDEVNAME(sc->sc_dev), sc->sc_intr_number));
d586 1
a586 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d590 1
a590 1
				USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d610 1
a610 1
		DPRINTF(("%s: abnormal status: %s\n", USBDEVNAME(sc->sc_dev),
d617 1
a617 1
		 USBDEVNAME(sc->sc_dev), buf[0],buf[1]));
@


1.21
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.20 2007/06/05 08:43:56 mbalmer Exp $	*/
d305 1
a305 1
			   USBDEV(sc->sc_dev));
d334 1
a334 1
			   USBDEV(sc->sc_dev));
@


1.20
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.19 2007/05/27 04:00:25 jsg Exp $	*/
d84 1
a84 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.19
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.18 2007/05/21 05:40:28 jsg Exp $	*/
d119 14
a132 14
Static	void umct_init(struct umct_softc *);
Static	void umct_set_baudrate(struct umct_softc *, u_int);
Static	void umct_set_lcr(struct umct_softc *, u_int);
Static	void umct_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);

Static	void umct_set(void *, int, int, int);
Static	void umct_dtr(struct umct_softc *, int);
Static	void umct_rts(struct umct_softc *, int);
Static	void umct_break(struct umct_softc *, int);
Static	void umct_set_line_state(struct umct_softc *);
Static	void umct_get_status(void *, int portno, u_char *lsr, u_char *msr);
Static	int  umct_param(void *, int, struct termios *);
Static	int  umct_open(void *, int);
Static	void umct_close(void *, int);
@


1.18
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.17 2006/06/23 06:27:12 miod Exp $	*/
d161 2
a162 1
USB_MATCH(umct)
d164 1
a164 1
	USB_MATCH_START(umct, uaa);
d173 2
a174 1
USB_ATTACH(umct)
d176 2
a177 1
	USB_ATTACH_START(umct, sc, uaa);
d190 1
a190 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d209 1
a209 1
		USB_ATTACH_ERROR_RETURN;
d219 1
a219 1
		USB_ATTACH_ERROR_RETURN;
d229 1
a229 1
		USB_ATTACH_ERROR_RETURN;
d243 1
a243 1
			USB_ATTACH_ERROR_RETURN;
d269 1
a269 1
		USB_ATTACH_ERROR_RETURN;
d276 1
a276 1
		USB_ATTACH_ERROR_RETURN;
d283 1
a283 1
		USB_ATTACH_ERROR_RETURN;
a309 2

	USB_ATTACH_SUCCESS_RETURN;
d312 2
a313 1
USB_DETACH(umct)
d315 1
a315 1
	USB_DETACH_START(umct, sc);
@


1.17
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.16 2005/11/21 18:16:44 millert Exp $	*/
d73 1
a73 1
#define DPRINTFN(n, x)  do { if (umctdebug > (n)) logprintf x; } while (0)
@


1.16
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.15 2005/08/01 05:41:54 brad Exp $	*/
d346 1
a346 1
		return (EOPNOTSUPP);
@


1.15
log
@spaces vs tab
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.14 2005/08/01 05:36:49 brad Exp $	*/
d53 1
a53 1
#include <sys/select.h>
@


1.14
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.13 2004/09/20 21:34:46 deraadt Exp $	*/
d187 2
a188 2
        USB_ATTACH_SETUP;
        printf("%s: %s\n", devname, devinfop);
@


1.13
log
@more uplcom and umct; jsg@@goblin.cx pulled from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.12 2004/07/11 07:39:38 deraadt Exp $	*/
d180 1
a180 1
	char devinfo[1024];
d186 1
a186 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d188 2
a189 1
        printf("%s: %s\n", devname, devinfo);
@


1.12
log
@from freebsd via netbsd via loki
The MCT advertises both the interrupt and bulkin endpoints as
interrupts. Go from assuming that the first enumerated interrupt
is the bulkin (since this may not be the case) to assuming that
the true interrupt endpoint will have a 0x2 wMaxPacketSize.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.11 2004/07/08 22:18:44 deraadt Exp $	*/
d154 2
@


1.11
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.10 2004/04/20 16:28:36 pvalchev Exp $	*/
d181 1
a181 1
	int i, found;
a230 1
	found = 0;
d241 5
d248 1
a248 1
		    found == 0) {
a249 1
			found = 1;
@


1.10
log
@Belkin F5U109; from NetBSD, ok henning
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.9 2003/11/07 20:22:35 jmc Exp $	*/
d73 1
a73 1
#define DPRINTFN(n, x)  if (umctdebug > (n)) logprintf x
@


1.9
log
@more updated URLs from Jared Yanovich;
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.8 2003/05/19 00:36:12 nate Exp $	*/
d152 2
d450 2
a451 1
	if (sc->sc_product == USB_PRODUCT_MCT_SITECOM_USB232) {
@


1.8
log
@nuke unused variable, from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.7 2003/05/07 04:33:33 deraadt Exp $	*/
d41 1
a41 1
 * http://www.mct.com.tw/p_u232.html
@


1.7
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: umct.c,v 1.6 2002/11/11 02:32:32 nate Exp $	*/
/*	$NetBSD: umct.c,v 1.9 2002/09/23 05:51:23 simonb Exp $	*/
d591 1
a591 1
	u_char mstatus, lstatus;
a610 1
	lstatus = buf[1];
@


1.6
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.5 2002/07/25 04:07:33 nate Exp $	*/
d182 1
a182 1
        usbd_devinfo(dev, 0, devinfo);
@


1.6.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.6 2002/11/11 02:32:32 nate Exp $	*/
d182 1
a182 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.6.4.2
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: umct.c,v 1.10 2003/02/23 04:20:07 simonb Exp $	*/
d591 1
a591 1
	u_char mstatus;
d611 1
@


1.6.4.3
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d41 1
a41 1
 * http://www.mct.com.tw/prod/rs232.html
@


1.6.4.4
log
@Merge with the trunk
@
text
@a151 2
	/* BELKIN F5U109 */
	{ USB_VENDOR_BELKIN, USB_PRODUCT_BELKIN_F5U109 },
d448 1
a448 2
	if (sc->sc_product == USB_PRODUCT_MCT_SITECOM_USB232 ||
	    sc->sc_product == USB_PRODUCT_BELKIN_F5U109) {
@


1.5
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: umct.c,v 1.4 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: umct.c,v 1.8 2002/07/11 21:14:32 augustss Exp $ */
a338 1
		break;
@


1.5.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.5.4.2
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: umct.c,v 1.9 2002/09/23 05:51:23 simonb Exp $	*/
d182 1
a182 1
        usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d339 1
@


1.4
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: umct.c,v 1.3 2002/06/11 06:42:17 nate Exp $	*/
/*	$NetBSD: umct.c,v 1.7 2001/12/17 14:19:39 ichiro Exp $	*/
@


1.3
log
@Add the umct serial driver for netbsd.
This currently does not work properly with the device that I have, so
I will not add it to GENERIC
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d175 1
a175 1
	
d191 1
a191 1
	/* initialize endpoints */ 
d216 1
a216 1
	err = usbd_device2interface_handle(dev, UMCT_IFACE_INDEX, 
d534 1
a534 1
	
d543 1
a543 1
        umct_set_lcr(sc, lcr_data);  
d563 1
a563 1
umct_close(void *addr, int portno) 
d592 1
a592 1
	u_char mstatus, lstatus; 
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: umct.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

