head	1.106;
access;
symbols
	OPENBSD_6_2:1.106.0.2
	OPENBSD_6_2_BASE:1.106
	OPENBSD_6_1:1.106.0.4
	OPENBSD_6_1_BASE:1.106
	OPENBSD_6_0:1.105.0.4
	OPENBSD_6_0_BASE:1.105
	OPENBSD_5_9:1.104.0.2
	OPENBSD_5_9_BASE:1.104
	OPENBSD_5_8:1.100.0.4
	OPENBSD_5_8_BASE:1.100
	OPENBSD_5_7:1.96.0.2
	OPENBSD_5_7_BASE:1.96
	OPENBSD_5_6:1.94.0.4
	OPENBSD_5_6_BASE:1.94
	OPENBSD_5_5:1.92.0.4
	OPENBSD_5_5_BASE:1.92
	OPENBSD_5_4:1.87.0.2
	OPENBSD_5_4_BASE:1.87
	OPENBSD_5_3:1.85.0.8
	OPENBSD_5_3_BASE:1.85
	OPENBSD_5_2:1.85.0.6
	OPENBSD_5_2_BASE:1.85
	OPENBSD_5_1_BASE:1.85
	OPENBSD_5_1:1.85.0.4
	OPENBSD_5_0:1.85.0.2
	OPENBSD_5_0_BASE:1.85
	OPENBSD_4_9:1.84.0.2
	OPENBSD_4_9_BASE:1.84
	OPENBSD_4_8:1.77.0.4
	OPENBSD_4_8_BASE:1.77
	OPENBSD_4_7:1.77.0.2
	OPENBSD_4_7_BASE:1.77
	OPENBSD_4_6:1.75.0.6
	OPENBSD_4_6_BASE:1.75
	OPENBSD_4_5:1.75.0.2
	OPENBSD_4_5_BASE:1.75
	OPENBSD_4_4:1.71.0.2
	OPENBSD_4_4_BASE:1.71
	OPENBSD_4_3:1.70.0.2
	OPENBSD_4_3_BASE:1.70
	OPENBSD_4_2:1.65.0.2
	OPENBSD_4_2_BASE:1.65
	OPENBSD_4_1:1.51.0.2
	OPENBSD_4_1_BASE:1.51
	OPENBSD_4_0:1.48.0.4
	OPENBSD_4_0_BASE:1.48
	OPENBSD_3_9:1.43.0.2
	OPENBSD_3_9_BASE:1.43
	OPENBSD_3_8:1.42.0.2
	OPENBSD_3_8_BASE:1.42
	OPENBSD_3_7:1.38.0.2
	OPENBSD_3_7_BASE:1.38
	OPENBSD_3_6:1.34.0.4
	OPENBSD_3_6_BASE:1.34
	SMP_SYNC_A:1.32
	SMP_SYNC_B:1.32
	OPENBSD_3_5:1.32.0.2
	OPENBSD_3_5_BASE:1.32
	OPENBSD_3_4:1.31.0.2
	OPENBSD_3_4_BASE:1.31
	UBC_SYNC_A:1.30
	OPENBSD_3_3:1.29.0.2
	OPENBSD_3_3_BASE:1.29
	OPENBSD_3_2:1.28.0.2
	OPENBSD_3_2_BASE:1.28
	OPENBSD_3_1:1.20.0.2
	OPENBSD_3_1_BASE:1.20
	UBC_SYNC_B:1.28
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	SMP:1.13.0.2
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.5.0.2
	OPENBSD_2_7_BASE:1.5;
locks; strict;
comment	@ * @;


1.106
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.105;
commitid	VyLWTsbepAOk7VQM;

1.105
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.104;
commitid	gWZDkudwxydTq8x4;

1.104
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.103;
commitid	B0kwmVGiD5DVx4kv;

1.103
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.102;
commitid	5gdEnqVoJuTuwdTu;

1.102
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.101;
commitid	eYnPulzvLjDImPCa;

1.101
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.100;
commitid	pwYnMC1gOKohmeGw;

1.100
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.99;
commitid	MVWrtktB46JRxFWT;

1.99
date	2015.06.18.10.02.49;	author mpi;	state Exp;
branches;
next	1.98;
commitid	IHdB5gqxznCdTVxP;

1.98
date	2015.03.24.10.02.18;	author mpi;	state Exp;
branches;
next	1.97;
commitid	qXBNUbkblhBZPZOy;

1.97
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.96;
commitid	p4LJxGKbi0BU2cG6;

1.96
date	2015.01.12.04.49.41;	author brad;	state Exp;
branches;
next	1.95;
commitid	QtlxtdBrCdYjm3Pd;

1.95
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.94;
commitid	yM2VFFhpDTeFQlve;

1.94
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.93;
commitid	Pclvgy2Z4XV9hveD;

1.93
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.92;
commitid	b0VSac5dnnsxcDao;

1.92
date	2013.12.13.01.13.56;	author brad;	state Exp;
branches;
next	1.91;

1.91
date	2013.11.17.13.57.03;	author jsg;	state Exp;
branches;
next	1.90;

1.90
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.89;

1.89
date	2013.11.05.10.20.04;	author mpi;	state Exp;
branches;
next	1.88;

1.88
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.87;

1.87
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.86;

1.86
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.85;

1.85
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.84;

1.84
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.83;

1.83
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.82;

1.82
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.81;

1.81
date	2010.10.23.16.14.06;	author jakemsr;	state Exp;
branches;
next	1.80;

1.80
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.79;

1.79
date	2010.09.24.08.33.58;	author yuo;	state Exp;
branches;
next	1.78;

1.78
date	2010.09.22.14.38.52;	author yuo;	state Exp;
branches;
next	1.77;

1.77
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.76;

1.76
date	2009.08.10.20.02.19;	author deraadt;	state Exp;
branches;
next	1.75;

1.75
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.74;

1.74
date	2008.11.06.02.32.28;	author brad;	state Exp;
branches;
next	1.73;

1.73
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.72;

1.72
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.71;

1.71
date	2008.03.18.12.24.19;	author jsg;	state Exp;
branches;
next	1.70;

1.70
date	2007.12.31.19.33.37;	author deraadt;	state Exp;
branches;
next	1.69;

1.69
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.68;

1.68
date	2007.11.10.22.58.24;	author deraadt;	state Exp;
branches;
next	1.67;

1.67
date	2007.10.11.18.33.13;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.65;

1.65
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.11.05.42.53;	author mbalmer;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.57;

1.57
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.56;

1.56
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.53;

1.53
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2007.05.06.04.08.47;	author krw;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.23.23.03.04;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.11.20.29.22;	author miod;	state Exp;
branches;
next	1.49;

1.49
date	2006.09.26.12.23.40;	author jsg;	state Exp;
branches;
next	1.48;

1.48
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.47;

1.47
date	2006.05.22.20.35.12;	author krw;	state Exp;
branches;
next	1.46;

1.46
date	2006.05.18.16.46.05;	author jolan;	state Exp;
branches;
next	1.45;

1.45
date	2006.03.25.22.41.46;	author djm;	state Exp;
branches;
next	1.44;

1.44
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.43;

1.43
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2005.08.01.05.36.47;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.40;

1.40
date	2005.07.02.22.17.57;	author brad;	state Exp;
branches;
next	1.39;

1.39
date	2005.06.08.17.03.01;	author henning;	state Exp;
branches;
next	1.38;

1.38
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.37;

1.37
date	2004.11.10.10.14.48;	author grange;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.31.00.37.40;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.23.17.45.17;	author brad;	state Exp;
branches;
next	1.34;

1.34
date	2004.07.11.09.47.22;	author deraadt;	state Exp;
branches;
next	1.33;

1.33
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.15.23.36.14;	author cedric;	state Exp;
branches;
next	1.31;

1.31
date	2003.05.17.17.48.32;	author nate;	state Exp;
branches;
next	1.30;

1.30
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.29;

1.29
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.28;

1.28
date	2002.09.27.18.42.51;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.29.03.33.02;	author nate;	state Exp;
branches;
next	1.26;

1.26
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.10.18.08.13;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.09.14.45.43;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.04.05.51.13;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.26.11.29.55;	author espie;	state Exp;
branches;
next	1.20;

1.20
date	2002.04.01.21.47.07;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.03.14.03.16.08;	author millert;	state Exp;
branches;
next	1.18;

1.18
date	2002.01.03.22.23.43;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.07.15.03.03.35;	author mickey;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.08.23.38.08;	author fgsch;	state Exp;
branches;
next	1.14;

1.14
date	2001.06.27.06.34.53;	author kjc;	state Exp;
branches;
next	1.13;

1.13
date	2001.05.03.02.20.32;	author aaron;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2001.02.20.19.39.47;	author mickey;	state Exp;
branches;
next	1.11;

1.11
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.07.21.03.01;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.10.13.04.42.10;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.09.17.00.48.30;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.08.26.20.08.39;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.04.11.44.21;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.23.17.33.47;	author maja;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.14.22.50.24;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.22.52.29;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.03.30.16.19.32;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.03.28.19.37.47;	author aaron;	state Exp;
branches;
next	;

1.13.2.1
date	2001.05.14.22.26.18;	author niklas;	state Exp;
branches;
next	1.13.2.2;

1.13.2.2
date	2001.07.04.10.43.40;	author niklas;	state Exp;
branches;
next	1.13.2.3;

1.13.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.13.2.4;

1.13.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.13.2.5;

1.13.2.5
date	2002.03.06.02.11.47;	author niklas;	state Exp;
branches;
next	1.13.2.6;

1.13.2.6
date	2002.03.28.15.09.09;	author niklas;	state Exp;
branches;
next	1.13.2.7;

1.13.2.7
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.13.2.8;

1.13.2.8
date	2003.05.13.19.35.11;	author ho;	state Exp;
branches;
next	1.13.2.9;

1.13.2.9
date	2003.06.07.11.02.32;	author ho;	state Exp;
branches;
next	1.13.2.10;

1.13.2.10
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.01.31.22.55.39;	author niklas;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2002.10.29.00.33.31;	author art;	state Exp;
branches;
next	1.17.2.4;

1.17.2.4
date	2003.05.19.22.23.39;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.106
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_aue.c,v 1.105 2016/04/13 11:03:37 mpi Exp $ */
/*	$NetBSD: if_aue.c,v 1.82 2003/03/05 17:37:36 shiba Exp $	*/
/*
 * Copyright (c) 1997, 1998, 1999, 2000
 *	Bill Paul <wpaul@@ee.columbia.edu>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $FreeBSD: src/sys/dev/usb/if_aue.c,v 1.11 2000/01/14 01:36:14 wpaul Exp $
 */

/*
 * ADMtek AN986 Pegasus and AN8511 Pegasus II USB to ethernet driver.
 * Datasheet is available from http://www.admtek.com.tw.
 *
 * Written by Bill Paul <wpaul@@ee.columbia.edu>
 * Electrical Engineering Department
 * Columbia University, New York City
 */

/*
 * The Pegasus chip uses four USB "endpoints" to provide 10/100 ethernet
 * support: the control endpoint for reading/writing registers, burst
 * read endpoint for packet reception, burst write for packet transmission
 * and one for "interrupts." The chip uses the same RX filter scheme
 * as the other ADMtek ethernet parts: one perfect filter entry for the
 * the station address and a 64-bit multicast hash table. The chip supports
 * both MII and HomePNA attachments.
 *
 * Since the maximum data transfer speed of USB is supposed to be 12Mbps,
 * you're never really going to get 100Mbps speeds from this device. I
 * think the idea is to allow the device to connect to 10 or 100Mbps
 * networks, not necessarily to provide 100Mbps performance. Also, since
 * the controller uses an external PHY chip, it's possible that board
 * designers might simply choose a 10Mbps PHY.
 *
 * Registers are accessed using usbd_do_request(). Packet transfers are
 * done using usbd_transfer() and friends.
 */

/*
 * Ported to NetBSD and somewhat rewritten by Lennart Augustsson.
 */

/*
 * TODO:
 * better error messages from rxstat
 * split out if_auevar.h
 * add thread to avoid register reads from interrupt context
 * more error checks
 * investigate short rx problem
 * proper cleanup on errors
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_auereg.h>

#ifdef AUE_DEBUG
#define DPRINTF(x)	do { if (auedebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (auedebug >= (n)) printf x; } while (0)
int	auedebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
struct aue_type {
	struct usb_devno	aue_dev;
	u_int16_t		aue_flags;
#define LSYS	0x0001		/* use Linksys reset */
#define PNA	0x0002		/* has Home PNA */
#define PII	0x0004		/* Pegasus II chip */
};

const struct aue_type aue_devs[] = {
 {{ USB_VENDOR_3COM,		USB_PRODUCT_3COM_3C460B},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX1},	  PNA|PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX2},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000},	  LSYS },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX4},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX5},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX6},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX7},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX8},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX9},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX10},	  0 },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_DSB650TX_PNA}, 0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_USB320_EC},	  0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_SS1001},	  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS},	  PNA },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII},	  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII_2},  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII_3},  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII_4},  PII },
 {{ USB_VENDOR_AEI,		USB_PRODUCT_AEI_FASTETHERNET},	  PII },
 {{ USB_VENDOR_ALLIEDTELESYN,   USB_PRODUCT_ALLIEDTELESYN_ATUSB100}, PII },
 {{ USB_VENDOR_ATEN,		USB_PRODUCT_ATEN_UC110T},	  PII },
 {{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D5050},	  PII },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100},	  0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBLP100}, PNA },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBEL100}, 0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBE100},  PII },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TX}, 0 },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TXS},PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX4},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX1},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA},  PNA },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX3},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX2},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650},	  0 },
 {{ USB_VENDOR_ELCON,		USB_PRODUCT_ELCON_PLAN},	  PNA|PII },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSB20},	  PII },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX0},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1},	  LSYS },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX2},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3},	  LSYS },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBLTX},	  PII },
 {{ USB_VENDOR_ELSA,		USB_PRODUCT_ELSA_USB2ETHERNET},	  0 },
 {{ USB_VENDOR_GIGABYTE,	USB_PRODUCT_GIGABYTE_GNBR402W},	  0 },
 {{ USB_VENDOR_HAWKING,		USB_PRODUCT_HAWKING_UF100},       PII },
 {{ USB_VENDOR_HP,		USB_PRODUCT_HP_HN210E},           PII },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX},	  0 },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTXS},	  PII },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_ETXUS2},	  PII },
 {{ USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX},   0 },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX1},	  LSYS|PII },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10T},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1},	  LSYS|PNA },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX2},	  LSYS|PII },
 {{ USB_VENDOR_MICROSOFT,	USB_PRODUCT_MICROSOFT_MN110},     PII },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUA2TX5}, 	  PII },
 {{ USB_VENDOR_MOBILITY,	USB_PRODUCT_MOBILITY_EASIDOCK},	  0 },
 {{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_FA101},	  PII },
 {{ USB_VENDOR_OCT,		USB_PRODUCT_OCT_USBTOETHER},	  PII },
 {{ USB_VENDOR_SIEMENS,		USB_PRODUCT_SIEMENS_SPEEDSTREAM}, PII },
 {{ USB_VENDOR_SMARTBRIDGES,	USB_PRODUCT_SMARTBRIDGES_SMARTNIC},PII },
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB},	  0 },
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2206USB},	  PII },
 {{ USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100},	  0 },
 {{ USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB110},	  PII },
 {{ USB_VENDOR_LOGITEC,		USB_PRODUCT_LOGITEC_LANTX},	  PII },
};
#define aue_lookup(v, p) ((struct aue_type *)usb_lookup(aue_devs, v, p))

int aue_match(struct device *, void *, void *);
void aue_attach(struct device *, struct device *, void *);
int aue_detach(struct device *, int);

struct cfdriver aue_cd = {
	NULL, "aue", DV_IFNET
};

const struct cfattach aue_ca = {
	sizeof(struct aue_softc), aue_match, aue_attach, aue_detach
};

void aue_reset_pegasus_II(struct aue_softc *sc);
int aue_tx_list_init(struct aue_softc *);
int aue_rx_list_init(struct aue_softc *);
int aue_newbuf(struct aue_softc *, struct aue_chain *, struct mbuf *);
int aue_send(struct aue_softc *, struct mbuf *, int);
void aue_intr(struct usbd_xfer *, void *, usbd_status);
void aue_rxeof(struct usbd_xfer *, void *, usbd_status);
void aue_txeof(struct usbd_xfer *, void *, usbd_status);
void aue_tick(void *);
void aue_tick_task(void *);
void aue_start(struct ifnet *);
int aue_ioctl(struct ifnet *, u_long, caddr_t);
void aue_init(void *);
void aue_stop(struct aue_softc *);
void aue_watchdog(struct ifnet *);
int aue_openpipes(struct aue_softc *);
int aue_ifmedia_upd(struct ifnet *);
void aue_ifmedia_sts(struct ifnet *, struct ifmediareq *);

int aue_eeprom_getword(struct aue_softc *, int);
void aue_read_mac(struct aue_softc *, u_char *);
int aue_miibus_readreg(struct device *, int, int);
void aue_miibus_writereg(struct device *, int, int, int);
void aue_miibus_statchg(struct device *);

void aue_lock_mii(struct aue_softc *);
void aue_unlock_mii(struct aue_softc *);

void aue_iff(struct aue_softc *);
u_int32_t aue_crc(caddr_t);
void aue_reset(struct aue_softc *);

int aue_csr_read_1(struct aue_softc *, int);
int aue_csr_write_1(struct aue_softc *, int, int);
int aue_csr_read_2(struct aue_softc *, int);
int aue_csr_write_2(struct aue_softc *, int, int);

#define AUE_SETBIT(sc, reg, x)				\
	aue_csr_write_1(sc, reg, aue_csr_read_1(sc, reg) | (x))

#define AUE_CLRBIT(sc, reg, x)				\
	aue_csr_write_1(sc, reg, aue_csr_read_1(sc, reg) & ~(x))

int
aue_csr_read_1(struct aue_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	uByte			val = 0;

	if (usbd_is_dying(sc->aue_udev))
		return (0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = AUE_UR_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 1);

	err = usbd_do_request(sc->aue_udev, &req, &val);

	if (err) {
		DPRINTF(("%s: aue_csr_read_1: reg=0x%x err=%s\n",
			 sc->aue_dev.dv_xname, reg, usbd_errstr(err)));
		return (0);
	}

	return (val);
}

int
aue_csr_read_2(struct aue_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;

	if (usbd_is_dying(sc->aue_udev))
		return (0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = AUE_UR_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->aue_udev, &req, &val);

	if (err) {
		DPRINTF(("%s: aue_csr_read_2: reg=0x%x err=%s\n",
			 sc->aue_dev.dv_xname, reg, usbd_errstr(err)));
		return (0);
	}

	return (UGETW(val));
}

int
aue_csr_write_1(struct aue_softc *sc, int reg, int aval)
{
	usb_device_request_t	req;
	usbd_status		err;
	uByte			val;

	if (usbd_is_dying(sc->aue_udev))
		return (0);

	val = aval;
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = AUE_UR_WRITEREG;
	USETW(req.wValue, val);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 1);

	err = usbd_do_request(sc->aue_udev, &req, &val);

	if (err) {
		DPRINTF(("%s: aue_csr_write_1: reg=0x%x err=%s\n",
			 sc->aue_dev.dv_xname, reg, usbd_errstr(err)));
		return (-1);
	}

	return (0);
}

int
aue_csr_write_2(struct aue_softc *sc, int reg, int aval)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;

	if (usbd_is_dying(sc->aue_udev))
		return (0);

	USETW(val, aval);
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = AUE_UR_WRITEREG;
	USETW(req.wValue, aval);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->aue_udev, &req, &val);

	if (err) {
		DPRINTF(("%s: aue_csr_write_2: reg=0x%x err=%s\n",
			 sc->aue_dev.dv_xname, reg, usbd_errstr(err)));
		return (-1);
	}

	return (0);
}

/*
 * Read a word of data stored in the EEPROM at address 'addr.'
 */
int
aue_eeprom_getword(struct aue_softc *sc, int addr)
{
	int		i;

	aue_csr_write_1(sc, AUE_EE_REG, addr);
	aue_csr_write_1(sc, AUE_EE_CTL, AUE_EECTL_READ);

	for (i = 0; i < AUE_TIMEOUT; i++) {
		if (aue_csr_read_1(sc, AUE_EE_CTL) & AUE_EECTL_DONE)
			break;
	}

	if (i == AUE_TIMEOUT) {
		printf("%s: EEPROM read timed out\n",
		    sc->aue_dev.dv_xname);
	}

	return (aue_csr_read_2(sc, AUE_EE_DATA));
}

/*
 * Read the MAC from the EEPROM.  It's at offset 0.
 */
void
aue_read_mac(struct aue_softc *sc, u_char *dest)
{
	int			i;
	int			off = 0;
	int			word;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	for (i = 0; i < 3; i++) {
		word = aue_eeprom_getword(sc, off + i);
		dest[2 * i] = (u_char)word;
		dest[2 * i + 1] = (u_char)(word >> 8);
	}
}

/* Get exclusive access to the MII registers */
void
aue_lock_mii(struct aue_softc *sc)
{
	sc->aue_refcnt++;
	rw_enter_write(&sc->aue_mii_lock);
}

void
aue_unlock_mii(struct aue_softc *sc)
{
	rw_exit_write(&sc->aue_mii_lock);
	if (--sc->aue_refcnt < 0)
		usb_detach_wakeup(&sc->aue_dev);
}

int
aue_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct aue_softc	*sc = (void *)dev;
	int			i;
	u_int16_t		val;

	if (usbd_is_dying(sc->aue_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: dying\n", sc->aue_dev.dv_xname);
#endif
		return 0;
	}

#if 0
	/*
	 * The Am79C901 HomePNA PHY actually contains
	 * two transceivers: a 1Mbps HomePNA PHY and a
	 * 10Mbps full/half duplex ethernet PHY with
	 * NWAY autoneg. However in the ADMtek adapter,
	 * only the 1Mbps PHY is actually connected to
	 * anything, so we ignore the 10Mbps one. It
	 * happens to be configured for MII address 3,
	 * so we filter that out.
	 */
	if (sc->aue_vendor == USB_VENDOR_ADMTEK &&
	    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {
		if (phy == 3)
			return (0);
	}
#endif

	aue_lock_mii(sc);
	aue_csr_write_1(sc, AUE_PHY_ADDR, phy);
	aue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_READ);

	for (i = 0; i < AUE_TIMEOUT; i++) {
		if (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)
			break;
	}

	if (i == AUE_TIMEOUT) {
		printf("%s: MII read timed out\n", sc->aue_dev.dv_xname);
	}

	val = aue_csr_read_2(sc, AUE_PHY_DATA);

	DPRINTFN(11,("%s: %s: phy=%d reg=%d => 0x%04x\n",
		     sc->aue_dev.dv_xname, __func__, phy, reg, val));

	aue_unlock_mii(sc);
	return (val);
}

void
aue_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct aue_softc	*sc = (void *)dev;
	int			i;

#if 0
	if (sc->aue_vendor == USB_VENDOR_ADMTEK &&
	    sc->aue_product == USB_PRODUCT_ADMTEK_PEGASUS) {
		if (phy == 3)
			return;
	}
#endif

	DPRINTFN(11,("%s: %s: phy=%d reg=%d data=0x%04x\n",
		     sc->aue_dev.dv_xname, __func__, phy, reg, data));

	aue_lock_mii(sc);
	aue_csr_write_2(sc, AUE_PHY_DATA, data);
	aue_csr_write_1(sc, AUE_PHY_ADDR, phy);
	aue_csr_write_1(sc, AUE_PHY_CTL, reg | AUE_PHYCTL_WRITE);

	for (i = 0; i < AUE_TIMEOUT; i++) {
		if (aue_csr_read_1(sc, AUE_PHY_CTL) & AUE_PHYCTL_DONE)
			break;
	}

	if (i == AUE_TIMEOUT) {
		printf("%s: MII read timed out\n",
		    sc->aue_dev.dv_xname);
	}
	aue_unlock_mii(sc);
}

void
aue_miibus_statchg(struct device *dev)
{
	struct aue_softc	*sc = (void *)dev;
	struct mii_data		*mii = GET_MII(sc);

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	aue_lock_mii(sc);
	AUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);

	if (IFM_SUBTYPE(mii->mii_media_active) == IFM_100_TX) {
		AUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);
	} else {
		AUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_SPEEDSEL);
	}

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
		AUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);
	else
		AUE_CLRBIT(sc, AUE_CTL1, AUE_CTL1_DUPLEX);

	AUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);
	aue_unlock_mii(sc);

	/*
	 * Set the LED modes on the LinkSys adapter.
	 * This turns on the 'dual link LED' bin in the auxmode
	 * register of the Broadcom PHY.
	 */
	if (!usbd_is_dying(sc->aue_udev) && (sc->aue_flags & LSYS)) {
		u_int16_t auxmode;
		auxmode = aue_miibus_readreg(dev, 0, 0x1b);
		aue_miibus_writereg(dev, 0, 0x1b, auxmode | 0x04);
	}
	DPRINTFN(5,("%s: %s: exit\n", sc->aue_dev.dv_xname, __func__));
}

#define AUE_POLY	0xEDB88320
#define AUE_BITS	6

u_int32_t
aue_crc(caddr_t addr)
{
	u_int32_t		idx, bit, data, crc;

	/* Compute CRC for the address value. */
	crc = 0xFFFFFFFF; /* initial value */

	for (idx = 0; idx < 6; idx++) {
		for (data = *addr++, bit = 0; bit < 8; bit++, data >>= 1)
			crc = (crc >> 1) ^ (((crc ^ data) & 1) ? AUE_POLY : 0);
	}

	return (crc & ((1 << AUE_BITS) - 1));
}

void
aue_iff(struct aue_softc *sc)
{
	struct ifnet		*ifp = GET_IFP(sc);
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		h = 0, i;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	AUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);
	AUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		AUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);
		if (ifp->if_flags & IFF_PROMISC)
			AUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);
	} else {
		/* first, zot all the existing hash bits */
		for (i = 0; i < 8; i++)
			aue_csr_write_1(sc, AUE_MAR0 + i, 0);

		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = aue_crc(enm->enm_addrlo);

			AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0x7));

			ETHER_NEXT_MULTI(step, enm);
		}
	}
}

void
aue_reset_pegasus_II(struct aue_softc *sc)
{
	/* Magic constants taken from Linux driver. */
	aue_csr_write_1(sc, AUE_REG_1D, 0);
	aue_csr_write_1(sc, AUE_REG_7B, 2);
#if 0
	if ((sc->aue_flags & HAS_HOME_PNA) && mii_mode)
		aue_csr_write_1(sc, AUE_REG_81, 6);
	else
#endif
		aue_csr_write_1(sc, AUE_REG_81, 2);
}

void
aue_reset(struct aue_softc *sc)
{
	int		i;

	DPRINTFN(2,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	AUE_SETBIT(sc, AUE_CTL1, AUE_CTL1_RESETMAC);

	for (i = 0; i < AUE_TIMEOUT; i++) {
		if (!(aue_csr_read_1(sc, AUE_CTL1) & AUE_CTL1_RESETMAC))
			break;
	}

	if (i == AUE_TIMEOUT)
		printf("%s: reset failed\n", sc->aue_dev.dv_xname);

#if 0
	/* XXX what is mii_mode supposed to be */
	if (sc->aue_mii_mode && (sc->aue_flags & PNA))
		aue_csr_write_1(sc, AUE_GPIO1, 0x34);
	else
		aue_csr_write_1(sc, AUE_GPIO1, 0x26);
#endif

	/*
	 * The PHY(s) attached to the Pegasus chip may be held
	 * in reset until we flip on the GPIO outputs. Make sure
	 * to set the GPIO pins high so that the PHY(s) will
	 * be enabled.
	 *
	 * Note: We force all of the GPIO pins low first, *then*
	 * enable the ones we want.
  	 */
	if (sc->aue_flags & LSYS) {
		/* Grrr. LinkSys has to be different from everyone else. */
		aue_csr_write_1(sc, AUE_GPIO0,
		    AUE_GPIO_SEL0 | AUE_GPIO_SEL1);
	} else {
		aue_csr_write_1(sc, AUE_GPIO0,
		    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);
	}
  	aue_csr_write_1(sc, AUE_GPIO0,
	    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);

	if (sc->aue_flags & PII)
		aue_reset_pegasus_II(sc);

	/* Wait a little while for the chip to get its brains in order. */
	delay(10000);		/* XXX */
}

/*
 * Probe for a Pegasus chip.
 */
int
aue_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return (aue_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
aue_attach(struct device *parent, struct device *self, void *aux)
{
	struct aue_softc	*sc = (struct aue_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	int			s;
	u_char			eaddr[ETHER_ADDR_LEN];
	struct ifnet		*ifp;
	struct mii_data		*mii;
	struct usbd_device	*dev = uaa->device;
	struct usbd_interface	*iface = uaa->iface;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int			i;

	DPRINTFN(5,(" : aue_attach: sc=%p", sc));

	sc->aue_udev = dev;

	usb_init_task(&sc->aue_tick_task, aue_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->aue_stop_task, (void (*)(void *))aue_stop, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->aue_mii_lock, "auemii");

	sc->aue_flags = aue_lookup(uaa->vendor, uaa->product)->aue_flags;

	sc->aue_iface = iface;
	sc->aue_product = uaa->product;
	sc->aue_vendor = uaa->vendor;

	id = usbd_get_interface_descriptor(iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get endpoint descriptor %d\n",
			    sc->aue_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->aue_ed[AUE_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->aue_ed[AUE_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->aue_ed[AUE_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	if (sc->aue_ed[AUE_ENDPT_RX] == 0 || sc->aue_ed[AUE_ENDPT_TX] == 0 ||
	    sc->aue_ed[AUE_ENDPT_INTR] == 0) {
		printf("%s: missing endpoint\n", sc->aue_dev.dv_xname);
		return;
	}


	s = splnet();

	/* Reset the adapter. */
	aue_reset(sc);

	/*
	 * Get station address from the EEPROM.
	 */
	aue_read_mac(sc, eaddr);

	/*
	 * A Pegasus chip was detected. Inform the world.
	 */
	ifp = GET_IFP(sc);
	printf("%s: address %s\n", sc->aue_dev.dv_xname,
	    ether_sprintf(eaddr));

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	/* Initialize interface info.*/
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = aue_ioctl;
	ifp->if_start = aue_start;
	ifp->if_watchdog = aue_watchdog;
	strlcpy(ifp->if_xname, sc->aue_dev.dv_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize MII/media info. */
	mii = &sc->aue_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = aue_miibus_readreg;
	mii->mii_writereg = aue_miibus_writereg;
	mii->mii_statchg = aue_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;
	ifmedia_init(&mii->mii_media, 0, aue_ifmedia_upd, aue_ifmedia_sts);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->aue_stat_ch, aue_tick, sc);

	splx(s);
}

int
aue_detach(struct device *self, int flags)
{
	struct aue_softc	*sc = (struct aue_softc *)self;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	DPRINTFN(2,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	if (timeout_initialized(&sc->aue_stat_ch))
		timeout_del(&sc->aue_stat_ch);

	/*
	 * Remove any pending tasks.  They cannot be executing because they run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->aue_udev, &sc->aue_tick_task);
	usb_rem_task(sc->aue_udev, &sc->aue_stop_task);

	s = splusb();

	if (ifp->if_flags & IFF_RUNNING)
		aue_stop(sc);

	mii_detach(&sc->aue_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->aue_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->aue_ep[AUE_ENDPT_TX] != NULL ||
	    sc->aue_ep[AUE_ENDPT_RX] != NULL ||
	    sc->aue_ep[AUE_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		       sc->aue_dev.dv_xname);
#endif

	if (--sc->aue_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->aue_dev);
	}
	splx(s);

	return (0);
}

/*
 * Initialize an RX descriptor and attach an MBUF cluster.
 */
int
aue_newbuf(struct aue_softc *sc, struct aue_chain *c, struct mbuf *m)
{
	struct mbuf		*m_new = NULL;

	DPRINTFN(10,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->aue_dev.dv_xname);
			return (ENOBUFS);
		}

		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			    "-- packet dropped!\n", sc->aue_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);
	c->aue_mbuf = m_new;

	return (0);
}

int
aue_rx_list_init(struct aue_softc *sc)
{
	struct aue_cdata	*cd;
	struct aue_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	cd = &sc->aue_cdata;
	for (i = 0; i < AUE_RX_LIST_CNT; i++) {
		c = &cd->aue_rx_chain[i];
		c->aue_sc = sc;
		c->aue_idx = i;
		if (aue_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->aue_xfer == NULL) {
			c->aue_xfer = usbd_alloc_xfer(sc->aue_udev);
			if (c->aue_xfer == NULL)
				return (ENOBUFS);
			c->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);
			if (c->aue_buf == NULL)
				return (ENOBUFS); /* XXX free xfer */
		}
	}

	return (0);
}

int
aue_tx_list_init(struct aue_softc *sc)
{
	struct aue_cdata	*cd;
	struct aue_chain	*c;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	cd = &sc->aue_cdata;
	for (i = 0; i < AUE_TX_LIST_CNT; i++) {
		c = &cd->aue_tx_chain[i];
		c->aue_sc = sc;
		c->aue_idx = i;
		c->aue_mbuf = NULL;
		if (c->aue_xfer == NULL) {
			c->aue_xfer = usbd_alloc_xfer(sc->aue_udev);
			if (c->aue_xfer == NULL)
				return (ENOBUFS);
			c->aue_buf = usbd_alloc_buffer(c->aue_xfer, AUE_BUFSZ);
			if (c->aue_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

void
aue_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct aue_softc	*sc = priv;
	struct ifnet		*ifp = GET_IFP(sc);
	struct aue_intrpkt	*p = &sc->aue_cdata.aue_ibuf;

	DPRINTFN(15,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->aue_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			return;
		}
		sc->aue_intr_errs++;
		if (usbd_ratecheck(&sc->aue_rx_notice)) {
			printf("%s: %u usb errors on intr: %s\n",
			    sc->aue_dev.dv_xname, sc->aue_intr_errs,
			    usbd_errstr(status));
			sc->aue_intr_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->aue_ep[AUE_ENDPT_RX]);
		return;
	}

	if (p->aue_txstat0)
		ifp->if_oerrors++;

	if (p->aue_txstat0 & (AUE_TXSTAT0_LATECOLL | AUE_TXSTAT0_EXCESSCOLL))
		ifp->if_collisions++;
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
aue_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct aue_chain	*c = priv;
	struct aue_softc	*sc = c->aue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mbuf		*m;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	u_int32_t		total_len;
	struct aue_rxpkt	r;
	int			s;

	DPRINTFN(10,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->aue_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->aue_rx_errs++;
		if (usbd_ratecheck(&sc->aue_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->aue_dev.dv_xname, sc->aue_rx_errs,
			    usbd_errstr(status));
			sc->aue_rx_errs = 0;
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->aue_ep[AUE_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	memcpy(mtod(c->aue_mbuf, char *), c->aue_buf, total_len);

	if (total_len <= 4 + ETHER_CRC_LEN) {
		ifp->if_ierrors++;
		goto done;
	}

	memcpy(&r, c->aue_buf + total_len - 4, sizeof(r));

	/* Turn off all the non-error bits in the rx status word. */
	r.aue_rxstat &= AUE_RXSTAT_MASK;
	if (r.aue_rxstat) {
		ifp->if_ierrors++;
		goto done;
	}

	/* No errors; receive the packet. */
	m = c->aue_mbuf;
	total_len -= ETHER_CRC_LEN + 4;
	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (aue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

 done:

	/* Setup new transfer. */
	usbd_setup_xfer(xfer, sc->aue_ep[AUE_ENDPT_RX],
	    c, c->aue_buf, AUE_BUFSZ,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, aue_rxeof);
	usbd_transfer(xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->aue_dev.dv_xname,
		    __func__));
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
aue_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct aue_chain	*c = priv;
	struct aue_softc	*sc = c->aue_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	if (usbd_is_dying(sc->aue_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->aue_dev.dv_xname,
		    __func__, status));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->aue_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->aue_ep[AUE_ENDPT_TX]);
		splx(s);
		return;
	}

	m_freem(c->aue_mbuf);
	c->aue_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		aue_start(ifp);

	splx(s);
}

void
aue_tick(void *xsc)
{
	struct aue_softc	*sc = xsc;

	DPRINTFN(15,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->aue_udev))
		return;

	/* Perform periodic stuff in process context. */
	usb_add_task(sc->aue_udev, &sc->aue_tick_task);
}

void
aue_tick_task(void *xsc)
{
	struct aue_softc	*sc = xsc;
	struct ifnet		*ifp;
	struct mii_data		*mii;
	int			s;

	DPRINTFN(15,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->aue_udev))
		return;

	ifp = GET_IFP(sc);
	mii = GET_MII(sc);
	if (mii == NULL)
		return;

	s = splnet();

	mii_tick(mii);
	if (!sc->aue_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		DPRINTFN(2,("%s: %s: got link\n",
			    sc->aue_dev.dv_xname,__func__));
		sc->aue_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			aue_start(ifp);
	}

	timeout_add_sec(&sc->aue_stat_ch, 1);

	splx(s);
}

int
aue_send(struct aue_softc *sc, struct mbuf *m, int idx)
{
	int			total_len;
	struct aue_chain	*c;
	usbd_status		err;

	DPRINTFN(10,("%s: %s: enter\n", sc->aue_dev.dv_xname,__func__));

	c = &sc->aue_cdata.aue_tx_chain[idx];

	/*
	 * Copy the mbuf data into a contiguous buffer, leaving two
	 * bytes at the beginning to hold the frame length.
	 */
	m_copydata(m, 0, m->m_pkthdr.len, c->aue_buf + 2);
	c->aue_mbuf = m;

	/*
	 * The ADMtek documentation says that the packet length is
	 * supposed to be specified in the first two bytes of the
	 * transfer, however it actually seems to ignore this info
	 * and base the frame size on the bulk transfer length.
	 */
	c->aue_buf[0] = (u_int8_t)m->m_pkthdr.len;
	c->aue_buf[1] = (u_int8_t)(m->m_pkthdr.len >> 8);
	total_len = m->m_pkthdr.len + 2;

	usbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_TX],
	    c, c->aue_buf, total_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    AUE_TX_TIMEOUT, aue_txeof);

	/* Transmit */
	err = usbd_transfer(c->aue_xfer);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: aue_send error=%s\n", sc->aue_dev.dv_xname,
		       usbd_errstr(err));
		/* Stop the interface from process context. */
		usb_add_task(sc->aue_udev, &sc->aue_stop_task);
		return (EIO);
	}
	DPRINTFN(5,("%s: %s: send %d bytes\n", sc->aue_dev.dv_xname,
		    __func__, total_len));

	sc->aue_cdata.aue_tx_cnt++;

	return (0);
}

void
aue_start(struct ifnet *ifp)
{
	struct aue_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	DPRINTFN(5,("%s: %s: enter, link=%d\n", sc->aue_dev.dv_xname,
		    __func__, sc->aue_link));

	if (usbd_is_dying(sc->aue_udev))
		return;

	if (!sc->aue_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (aue_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;
}

void
aue_init(void *xsc)
{
	struct aue_softc	*sc = xsc;
	struct ifnet		*ifp = GET_IFP(sc);
	struct mii_data		*mii = GET_MII(sc);
	int			i, s;
	u_char			*eaddr;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->aue_udev))
		return;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	aue_reset(sc);

	eaddr = sc->arpcom.ac_enaddr;
	for (i = 0; i < ETHER_ADDR_LEN; i++)
		aue_csr_write_1(sc, AUE_PAR0 + i, eaddr[i]);

	/* Init TX ring. */
	if (aue_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->aue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init RX ring. */
	if (aue_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->aue_dev.dv_xname);
		splx(s);
		return;
	}

	/* Program promiscuous mode and multicast filters. */
	aue_iff(sc);

	/* Enable RX and TX */
	AUE_SETBIT(sc, AUE_CTL0,
	    AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB | AUE_CTL0_TX_ENB);
	AUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_EP3_CLR);

	mii_mediachg(mii);

	if (sc->aue_ep[AUE_ENDPT_RX] == NULL) {
		if (aue_openpipes(sc)) {
			splx(s);
			return;
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->aue_stat_ch, 1);
}

int
aue_openpipes(struct aue_softc *sc)
{
	struct aue_chain	*c;
	usbd_status		err;
	int i;

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->aue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}
	err = usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->aue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}
	err = usbd_open_pipe_intr(sc->aue_iface, sc->aue_ed[AUE_ENDPT_INTR],
	    USBD_EXCLUSIVE_USE, &sc->aue_ep[AUE_ENDPT_INTR], sc,
	    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr,
	    AUE_INTR_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		    sc->aue_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}

	/* Start up the receive pipe. */
	for (i = 0; i < AUE_RX_LIST_CNT; i++) {
		c = &sc->aue_cdata.aue_rx_chain[i];
		usbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],
		    c, c->aue_buf, AUE_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		    aue_rxeof);
		(void)usbd_transfer(c->aue_xfer); /* XXX */
		DPRINTFN(5,("%s: %s: start read\n", sc->aue_dev.dv_xname,
			    __func__));

	}
	return (0);
}

/*
 * Set media options.
 */
int
aue_ifmedia_upd(struct ifnet *ifp)
{
	struct aue_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->aue_udev))
		return (0);

	sc->aue_link = 0;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		    miisc = LIST_NEXT(miisc, mii_list))
			 mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return (0);
}

/*
 * Report current media status.
 */
void
aue_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct aue_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

int
aue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct aue_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;

	if (usbd_is_dying(sc->aue_udev))
		return (EIO);

	s = splnet();

	switch(command) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			aue_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				aue_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				aue_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->aue_mii.mii_media, command);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, command, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			aue_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
aue_watchdog(struct ifnet *ifp)
{
	struct aue_softc	*sc = ifp->if_softc;
	struct aue_chain	*c;
	usbd_status		stat;
	int			s;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->aue_dev.dv_xname);

	s = splusb();
	c = &sc->aue_cdata.aue_tx_chain[0];
	usbd_get_xfer_status(c->aue_xfer, NULL, NULL, NULL, &stat);
	aue_txeof(c->aue_xfer, c, stat);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		aue_start(ifp);
	splx(s);
}

/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
aue_stop(struct aue_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	DPRINTFN(5,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	ifp = GET_IFP(sc);
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	aue_csr_write_1(sc, AUE_CTL0, 0);
	aue_csr_write_1(sc, AUE_CTL1, 0);
	aue_reset(sc);
	timeout_del(&sc->aue_stat_ch);

	/* Stop transfers. */
	if (sc->aue_ep[AUE_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);
		err = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
		sc->aue_ep[AUE_ENDPT_RX] = NULL;
	}

	if (sc->aue_ep[AUE_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);
		err = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
		sc->aue_ep[AUE_ENDPT_TX] = NULL;
	}

	if (sc->aue_ep[AUE_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);
		err = usbd_close_pipe(sc->aue_ep[AUE_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
		sc->aue_ep[AUE_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < AUE_RX_LIST_CNT; i++) {
		if (sc->aue_cdata.aue_rx_chain[i].aue_mbuf != NULL) {
			m_freem(sc->aue_cdata.aue_rx_chain[i].aue_mbuf);
			sc->aue_cdata.aue_rx_chain[i].aue_mbuf = NULL;
		}
		if (sc->aue_cdata.aue_rx_chain[i].aue_xfer != NULL) {
			usbd_free_xfer(sc->aue_cdata.aue_rx_chain[i].aue_xfer);
			sc->aue_cdata.aue_rx_chain[i].aue_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < AUE_TX_LIST_CNT; i++) {
		if (sc->aue_cdata.aue_tx_chain[i].aue_mbuf != NULL) {
			m_freem(sc->aue_cdata.aue_tx_chain[i].aue_mbuf);
			sc->aue_cdata.aue_tx_chain[i].aue_mbuf = NULL;
		}
		if (sc->aue_cdata.aue_tx_chain[i].aue_xfer != NULL) {
			usbd_free_xfer(sc->aue_cdata.aue_tx_chain[i].aue_xfer);
			sc->aue_cdata.aue_tx_chain[i].aue_xfer = NULL;
		}
	}

	sc->aue_link = 0;
}
@


1.105
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.104 2015/11/25 03:10:00 dlg Exp $ */
a1112 2

	ifp->if_opackets++;
@


1.104
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.103 2015/11/24 17:11:40 mpi Exp $ */
a782 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.103
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.102 2015/11/20 03:35:23 dlg Exp $ */
d1100 1
a1100 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1243 1
a1243 1
	if (ifp->if_flags & IFF_OACTIVE)
d1252 1
a1252 1
		ifp->if_flags |= IFF_OACTIVE;
d1267 1
a1267 1
	ifp->if_flags |= IFF_OACTIVE;
d1332 1
a1332 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1516 2
a1517 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.102
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.101 2015/10/25 12:11:56 mpi Exp $ */
a92 1
#include <net/if_dl.h>
@


1.101
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.100 2015/06/24 09:40:54 mpi Exp $ */
d1247 1
a1247 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1252 1
d1257 1
a1257 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.100
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.99 2015/06/18 10:02:49 mpi Exp $ */
a1431 1
	struct ifaddr 		*ifa = (struct ifaddr *)data;
a1444 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.99
log
@Only match devices with a valid configuration.

Tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.98 2015/03/24 10:02:18 mpi Exp $ */
a1054 1
	ifp->if_ipackets++;
@


1.98
log
@Convert to if_input().  Tested by jsg@@ who found that at least one his
(newer) machine can't set the device in a configurated state.  But this
is a USB-related problem.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.97 2015/03/14 03:38:49 jsg Exp $ */
d687 1
a687 1
	if (uaa->iface != NULL)
d691 1
a691 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d708 1
a708 2
	struct usbd_interface	*iface;
	usbd_status		err;
a716 7
	err = usbd_set_config_no(dev, AUE_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n",
		    sc->aue_dev.dv_xname);
		return;
	}

a721 7

	err = usbd_device2interface_handle(dev, AUE_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->aue_dev.dv_xname);
		return;
	}
@


1.97
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.96 2015/01/12 04:49:41 brad Exp $ */
d1020 1
d1071 1
a1072 5
	m->m_pkthdr.rcvif = ifp;

	s = splnet();

	/* XXX ugly */
d1075 1
a1075 1
		goto done1;
d1078 2
a1079 15
#if NBPFILTER > 0
	/*
	 * Handle BPF listeners. Let the BPF user see the packet, but
	 * don't pass it up to the ether_input() layer unless it's
	 * a broadcast packet, multicast packet, matches our ethernet
	 * address or the interface is in promiscuous mode.
	 */
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	DPRINTFN(10,("%s: %s: deliver %d\n", sc->aue_dev.dv_xname,
		    __func__, m->m_len));
	ether_input_mbuf(ifp, m);
 done1:
@


1.96
log
@Some fixes and tidying up of the receive filter handling bits.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.95 2014/12/22 02:28:52 tedu Exp $ */
a102 1
#include <dev/mii/mii.h>
@


1.95
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.94 2014/07/13 15:52:49 mpi Exp $ */
d588 2
a589 1
	AUE_CLRBIT(sc, AUE_CTL0, (AUE_CTL0_ALLMULTI | AUE_CTL2_RX_PROMISC));
a1332 6
	 /* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		AUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);
	else
		AUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);

d1351 2
a1352 2
	aue_csr_write_1(sc, AUE_CTL0, AUE_CTL0_RXSTAT_APPEND | AUE_CTL0_RX_ENB);
	AUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_TX_ENB);
@


1.94
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.93 2014/07/12 07:59:23 mpi Exp $ */
a1483 1
#ifdef INET
a1485 1
#endif
@


1.93
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.92 2013/12/13 01:13:56 brad Exp $ */
a99 1
#ifdef INET
a100 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a101 1
#endif
@


1.92
log
@Rewrite receive filter handling and ioctl bits.

Tested by ISIHARA Takanori
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.91 2013/11/17 13:57:03 jsg Exp $ */
d212 10
a221 15
int aue_match(struct device *, void *, void *); 
void aue_attach(struct device *, struct device *, void *); 
int aue_detach(struct device *, int); 
int aue_activate(struct device *, int); 

struct cfdriver aue_cd = { 
	NULL, "aue", DV_IFNET 
}; 

const struct cfattach aue_ca = { 
	sizeof(struct aue_softc), 
	aue_match, 
	aue_attach, 
	aue_detach, 
	aue_activate, 
a876 15
	return (0);
}

int
aue_activate(struct device *self, int act)
{
	struct aue_softc *sc = (struct aue_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->aue_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->aue_udev);
		break;
	}
@


1.91
log
@correct some iodata strings and add ETX-US2
from ISIHARA Takanori
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.90 2013/11/15 10:17:39 pirofti Exp $ */
d257 1
a257 1
void aue_setmulti(struct aue_softc *);
d587 1
a587 1
aue_setmulti(struct aue_softc *sc)
d589 1
a590 1
	struct ifnet		*ifp;
d597 2
a598 1
	ifp = GET_IFP(sc);
d603 11
a613 2
		return;
	}
d615 1
a615 1
	AUE_CLRBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);
d617 2
a618 10
	/* first, zot all the existing hash bits */
	for (i = 0; i < 8; i++)
		aue_csr_write_1(sc, AUE_MAR0 + i, 0);

	/* now program new ones */
	ETHER_FIRST_MULTI(step, ac, enm);
	while (enm != NULL) {
		h = aue_crc(enm->enm_addrlo);
		AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0x7));
		ETHER_NEXT_MULTI(step, enm);
a619 2

	ifp->if_flags &= ~IFF_ALLMULTI;
a1344 3
	if (ifp->if_flags & IFF_RUNNING)
		return;

d1376 2
a1377 2
	/* Load the multicast filter. */
	aue_setmulti(sc);
a1495 1
	struct mii_data		*mii;
d1506 2
a1507 3
		aue_init(sc);

		switch (ifa->ifa_addr->sa_family) {
d1509 1
a1509 1
		case AF_INET:
d1511 1
a1511 3
			break;
#endif /* INET */
		}
d1516 3
a1518 9
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->aue_if_flags & IFF_PROMISC)) {
				AUE_SETBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->aue_if_flags & IFF_PROMISC) {
				AUE_CLRBIT(sc, AUE_CTL2, AUE_CTL2_RX_PROMISC);
			} else if (!(ifp->if_flags & IFF_RUNNING))
a1523 2
		sc->aue_if_flags = ifp->if_flags;
		error = 0;
d1528 1
a1528 2
		mii = GET_MII(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, command);
d1537 1
a1537 1
			aue_setmulti(sc);
@


1.90
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.89 2013/11/05 10:20:04 mpi Exp $ */
d187 1
@


1.89
log
@Instead of comparing the lower and higher addresses of all the multicast
entries to decide if the IFF_ALLMULTI flag should be set, check if there
is at least one real range between them.

This should not introduce any behavior change but will help changing our
representation of multicast entries.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.88 2013/08/07 01:06:41 bluhm Exp $ */
d1607 1
a1607 5
		err = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
d1617 1
a1617 5
		err = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
d1627 1
a1627 5
		err = usbd_abort_pipe(sc->aue_ep[AUE_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    sc->aue_dev.dv_xname, usbd_errstr(err));
		}
@


1.88
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.87 2013/04/15 09:23:01 mglocker Exp $ */
d588 1
d598 1
a598 2
	if (ifp->if_flags & IFF_PROMISC) {
allmulti:
d611 1
a611 1
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
a612 4
		if (memcmp(enm->enm_addrlo,
		    enm->enm_addrhi, ETHER_ADDR_LEN) != 0)
			goto allmulti;

@


1.87
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.86 2013/03/28 03:58:03 tedu Exp $ */
a102 1
#include <netinet/in_var.h>
@


1.86
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.85 2011/07/03 15:47:17 matthew Exp $ */
d234 3
a236 3
void aue_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
void aue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void aue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d720 2
a721 2
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
d1000 1
a1000 1
aue_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1042 1
a1042 1
aue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1145 1
a1145 1
aue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.85
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.84 2011/01/25 20:03:35 jakemsr Exp $ */
a87 1
#include <sys/proc.h>
@


1.84
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.83 2010/12/06 04:41:39 jakemsr Exp $ */
a897 3
	case DVACT_ACTIVATE:
		break;

@


1.83
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.82 2010/10/27 17:51:11 jakemsr Exp $ */
a839 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->aue_udev,
			   &sc->aue_dev);
a885 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->aue_udev,
			   &sc->aue_dev);
@


1.82
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.81 2010/10/23 16:14:06 jakemsr Exp $ */
d280 1
a280 1
	if (sc->aue_dying)
d307 1
a307 1
	if (sc->aue_dying)
d334 1
a334 1
	if (sc->aue_dying)
d362 1
a362 1
	if (sc->aue_dying)
d449 1
a449 1
	if (sc->aue_dying) {
d560 1
a560 1
	if (!sc->aue_dying && (sc->aue_flags & LSYS)) {
d730 2
a753 1
	sc->aue_udev = dev;
a838 1
	sc->aue_attached = 1;
a853 4
	/* Detached before attached finished, so just bail out. */
	if (!sc->aue_attached) 
		return (0);

a883 2
	sc->aue_attached = 0;

d908 1
a908 1
		sc->aue_dying = 1;
d1018 1
a1018 1
	if (sc->aue_dying)
d1064 1
a1064 1
	if (sc->aue_dying)
d1162 1
a1162 1
	if (sc->aue_dying)
d1208 1
a1208 1
	if (sc->aue_dying)
d1225 1
a1225 1
	if (sc->aue_dying)
d1308 1
a1308 1
	if (sc->aue_dying)
d1356 1
a1356 1
	if (sc->aue_dying)
d1476 1
a1476 1
	if (sc->aue_dying)
d1516 1
a1516 1
	if (sc->aue_dying)
@


1.81
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.80 2010/10/23 15:42:09 jakemsr Exp $ */
d875 4
a878 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.80
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.79 2010/09/24 08:33:58 yuo Exp $ */
d858 2
a859 1
	timeout_del(&sc->aue_stat_ch);
@


1.79
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.78 2010/09/22 14:38:52 yuo Exp $ */
d737 4
a740 2
	usb_init_task(&sc->aue_tick_task, aue_tick_task, sc);
	usb_init_task(&sc->aue_stop_task, (void (*)(void *))aue_stop, sc);
@


1.78
log
@as dying flag didn't set in aue_detach(), set it.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.77 2009/10/13 19:33:17 pirofti Exp $ */
d852 2
a853 2
	if (!sc->aue_attached) {
		/* Detached before attached finished, so just bail out. */
a854 1
	}
a857 1
	sc->aue_dying = 1;
@


1.77
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.76 2009/08/10 20:02:19 deraadt Exp $ */
d858 2
@


1.76
log
@USB network devices do not DMA in a way that requires a shutdown function
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.75 2008/11/28 02:44:18 brad Exp $ */
d216 1
a216 1
int aue_activate(struct device *, enum devact); 
d898 1
a898 1
aue_activate(struct device *self, enum devact act)
@


1.75
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.74 2008/11/06 02:32:28 brad Exp $ */
a242 1
void aue_shutdown(void *);
a836 1
	sc->sc_sdhook = shutdownhook_establish(aue_shutdown, sc);
a883 2
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);
a1596 13
}

/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
void
aue_shutdown(void *arg)
{
	struct aue_softc *sc = (struct aue_softc *)arg;

	aue_reset(sc);
	aue_stop(sc);
@


1.74
log
@Set the IFCAP_VLAN_MTU capabilities flag so these interfaces are allowed
to transmit full sized VLAN tagged frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.73 2008/10/02 20:21:14 brad Exp $ */
a1539 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;

a1558 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (command == SIOCADDMULTI) ?
			ether_addmulti(ifr, &sc->arpcom) :
			ether_delmulti(ifr, &sc->arpcom);
a1559 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				aue_setmulti(sc);
			error = 0;
		}
		break;
d1565 1
d1568 6
@


1.73
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.72 2008/09/10 14:01:23 blambert Exp $ */
d813 2
@


1.72
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.71 2008/03/18 12:24:19 jsg Exp $ */
d1582 1
a1582 2
		error = EINVAL;
		break;
a1585 1

@


1.71
log
@Bring in some changes from DragonFly:
- New matching logic so we don't need to check against vid/pid
  to figure out which kind of chip we have
- Match list in a struct instead of messy if statement (hurrah!)
- More generic dual port handling
- Insane amount of device additions, mostly found in Linux driver
(aue included as a usb vendor got renamed)

Tested by ckuethe@@, 'looks super sensible' deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.70 2007/12/31 19:33:37 deraadt Exp $ */
d1248 1
a1248 1
	timeout_add(&sc->aue_stat_ch, hz);
d1418 1
a1418 1
	timeout_add(&sc->aue_stat_ch, hz);
@


1.70
log
@re-order product list slightly
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.69 2007/11/23 15:43:02 mbalmer Exp $ */
d202 1
a203 1
 {{ USB_VENDOR_SIIG2,		USB_PRODUCT_SIIG2_USBTOETHER},	  PII },
@


1.69
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.68 2007/11/10 22:58:24 deraadt Exp $ */
d177 1
a182 1
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSB20},	  PII },
@


1.68
log
@2 port usb hub with ethernet in it..
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.67 2007/10/11 18:33:13 deraadt Exp $ */
d833 1
a833 1
	timeout_set(&sc->aue_stat_ch, NULL, NULL);
a1247 2
	timeout_del(&sc->aue_stat_ch);
	timeout_set(&sc->aue_stat_ch, aue_tick, sc);
a1417 2
	timeout_del(&sc->aue_stat_ch);
	timeout_set(&sc->aue_stat_ch, aue_tick, sc);
@


1.67
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.66 2007/09/17 01:40:38 fgsch Exp $ */
d209 1
@


1.66
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.65 2007/06/14 10:11:15 mbalmer Exp $ */
a716 1
	char			*devinfop;
a728 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->aue_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.65
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.64 2007/06/13 11:15:29 mbalmer Exp $ */
a86 1
#include <sys/malloc.h>
@


1.64
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.63 2007/06/12 16:26:36 mbalmer Exp $ */
d213 16
a228 1
USB_DECLARE_DRIVER_CLASS(aue, DV_IFNET);
@


1.63
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.62 2007/06/11 05:42:53 mbalmer Exp $ */
d1125 1
a1125 1
	IF_INPUT(ifp, m);
@


1.62
log
@Remove the definition and usage of the USBGETSOFTC macro, which was really
only a cast to (void *).

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.61 2007/06/10 14:49:00 mbalmer Exp $ */
d237 3
a239 3
int aue_miibus_readreg(device_ptr_t, int, int);
void aue_miibus_writereg(device_ptr_t, int, int, int);
void aue_miibus_statchg(device_ptr_t);
d429 1
a429 1
aue_miibus_readreg(device_ptr_t dev, int phy, int reg)
d483 1
a483 1
aue_miibus_writereg(device_ptr_t dev, int phy, int reg, int data)
d517 1
a517 1
aue_miibus_statchg(device_ptr_t dev)
d890 1
a890 1
aue_activate(device_ptr_t self, enum devact act)
@


1.61
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.60 2007/06/10 10:53:48 mbalmer Exp $ */
d431 1
a431 1
	struct aue_softc	*sc = USBGETSOFTC(dev);
d485 1
a485 1
	struct aue_softc	*sc = USBGETSOFTC(dev);
d519 1
a519 1
	struct aue_softc	*sc = USBGETSOFTC(dev);
@


1.60
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.59 2007/06/10 10:15:35 mbalmer Exp $ */
d279 1
a279 1
			 USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));
d306 1
a306 1
			 USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));
d334 1
a334 1
			 USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));
d362 1
a362 1
			 USBDEVNAME(sc->aue_dev), reg, usbd_errstr(err)));
d387 1
a387 1
		    USBDEVNAME(sc->aue_dev));
d403 1
a403 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d437 1
a437 1
		printf("%s: dying\n", USBDEVNAME(sc->aue_dev));
d470 1
a470 1
		printf("%s: MII read timed out\n", USBDEVNAME(sc->aue_dev));
d476 1
a476 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, val));
d497 1
a497 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, data));
d511 1
a511 1
		    USBDEVNAME(sc->aue_dev));
d522 1
a522 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d551 1
a551 1
	DPRINTFN(5,("%s: %s: exit\n", USBDEVNAME(sc->aue_dev), __func__));
d581 1
a581 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d632 1
a632 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d642 1
a642 1
		printf("%s: reset failed\n", USBDEVNAME(sc->aue_dev));
d718 1
a718 1
	printf("\n%s: %s\n", USBDEVNAME(sc->aue_dev), devinfop);
d724 1
a724 1
		    USBDEVNAME(sc->aue_dev));
d735 1
a735 1
		    USBDEVNAME(sc->aue_dev));
d753 1
a753 1
			    USBDEVNAME(sc->aue_dev), i);
d770 1
a770 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->aue_dev));
d789 1
a789 1
	printf("%s: address %s\n", USBDEVNAME(sc->aue_dev),
d800 1
a800 1
	strlcpy(ifp->if_xname, USBDEVNAME(sc->aue_dev), IFNAMSIZ);
d840 1
a840 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d870 1
a870 1
		       USBDEVNAME(sc->aue_dev));
d894 1
a894 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d915 1
a915 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d921 1
a921 1
			    "-- packet dropped!\n", USBDEVNAME(sc->aue_dev));
d928 1
a928 1
			    "-- packet dropped!\n", USBDEVNAME(sc->aue_dev));
d952 1
a952 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d981 1
a981 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1009 1
a1009 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1024 1
a1024 1
			    USBDEVNAME(sc->aue_dev), sc->aue_intr_errs,
d1055 1
a1055 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1069 1
a1069 1
			    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,
d1123 1
a1123 1
	DPRINTFN(10,("%s: %s: deliver %d\n", USBDEVNAME(sc->aue_dev),
d1138 1
a1138 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->aue_dev),
d1160 1
a1160 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->aue_dev),
d1172 1
a1172 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->aue_dev),
d1196 1
a1196 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1216 1
a1216 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1232 1
a1232 1
			    USBDEVNAME(sc->aue_dev),__func__));
d1252 1
a1252 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1280 1
a1280 1
		printf("%s: aue_send error=%s\n", USBDEVNAME(sc->aue_dev),
d1286 1
a1286 1
	DPRINTFN(5,("%s: %s: send %d bytes\n", USBDEVNAME(sc->aue_dev),
d1300 1
a1300 1
	DPRINTFN(5,("%s: %s: enter, link=%d\n", USBDEVNAME(sc->aue_dev),
d1349 1
a1349 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1376 1
a1376 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->aue_dev));
d1383 1
a1383 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->aue_dev));
d1427 1
a1427 1
		    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1434 1
a1434 1
		    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1443 1
a1443 1
		    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1455 1
a1455 1
		DPRINTFN(5,("%s: %s: start read\n", USBDEVNAME(sc->aue_dev),
d1471 1
a1471 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1497 1
a1497 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1593 1
a1593 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1596 1
a1596 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->aue_dev));
d1632 1
a1632 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1648 1
a1648 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1653 1
a1653 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1662 1
a1662 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1667 1
a1667 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1676 1
a1676 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
d1681 1
a1681 1
			    USBDEVNAME(sc->aue_dev), usbd_errstr(err));
@


1.59
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.58 2007/06/09 12:22:53 mbalmer Exp $ */
d425 1
a425 1
		usb_detach_wakeup(USBDEV(sc->aue_dev));
d830 1
a830 1
			   USBDEV(sc->aue_dev));
d879 1
a879 1
		usb_detach_wait(USBDEV(sc->aue_dev));
d884 1
a884 1
			   USBDEV(sc->aue_dev));
@


1.58
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.57 2007/06/05 08:43:55 mbalmer Exp $ */
d823 1
a823 1
	usb_callout_init(sc->aue_stat_ch);
d847 1
a847 1
	usb_uncallout(sc->aue_stat_ch, aue_tick, sc);
d1238 3
a1240 1
	usb_callout(sc->aue_stat_ch, hz, aue_tick, sc);
d1410 3
a1412 1
	usb_callout(sc->aue_stat_ch, hz, aue_tick, sc);
d1641 1
a1641 1
	usb_uncallout(sc->aue_stat_ch, aue_tick, sc);
@


1.57
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.56 2007/06/04 10:34:04 mbalmer Exp $ */
a900 1
		if_deactivate(&sc->aue_ec.ec_if);
@


1.56
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.55 2007/05/27 04:00:24 jsg Exp $ */
d140 1
a140 1
Static const struct aue_type aue_devs[] = {
d215 37
a251 37
Static void aue_reset_pegasus_II(struct aue_softc *sc);
Static int aue_tx_list_init(struct aue_softc *);
Static int aue_rx_list_init(struct aue_softc *);
Static int aue_newbuf(struct aue_softc *, struct aue_chain *, struct mbuf *);
Static int aue_send(struct aue_softc *, struct mbuf *, int);
Static void aue_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_tick(void *);
Static void aue_tick_task(void *);
Static void aue_start(struct ifnet *);
Static int aue_ioctl(struct ifnet *, u_long, caddr_t);
Static void aue_init(void *);
Static void aue_shutdown(void *);
Static void aue_stop(struct aue_softc *);
Static void aue_watchdog(struct ifnet *);
Static int aue_openpipes(struct aue_softc *);
Static int aue_ifmedia_upd(struct ifnet *);
Static void aue_ifmedia_sts(struct ifnet *, struct ifmediareq *);

Static int aue_eeprom_getword(struct aue_softc *, int);
Static void aue_read_mac(struct aue_softc *, u_char *);
Static int aue_miibus_readreg(device_ptr_t, int, int);
Static void aue_miibus_writereg(device_ptr_t, int, int, int);
Static void aue_miibus_statchg(device_ptr_t);

Static void aue_lock_mii(struct aue_softc *);
Static void aue_unlock_mii(struct aue_softc *);

Static void aue_setmulti(struct aue_softc *);
Static u_int32_t aue_crc(caddr_t);
Static void aue_reset(struct aue_softc *);

Static int aue_csr_read_1(struct aue_softc *, int);
Static int aue_csr_write_1(struct aue_softc *, int, int);
Static int aue_csr_read_2(struct aue_softc *, int);
Static int aue_csr_write_2(struct aue_softc *, int, int);
d259 1
a259 1
Static int
d286 1
a286 1
Static int
d313 1
a313 1
Static int
d341 1
a341 1
Static int
d372 1
a372 1
Static int
d396 1
a396 1
Static void
d413 1
a413 1
Static void
d420 1
a420 1
Static void
d428 1
a428 1
Static int
d482 1
a482 1
Static void
d516 1
a516 1
Static void
d557 1
a557 1
Static u_int32_t
d573 1
a573 1
Static void
d613 1
a613 1
Static void
d627 1
a627 1
Static void
d911 1
a911 1
Static int
d946 1
a946 1
Static int
d975 1
a975 1
Static int
d1003 1
a1003 1
Static void
d1045 1
a1045 1
Static void
d1148 1
a1148 1
Static void
d1192 1
a1192 1
Static void
d1209 1
a1209 1
Static void
d1244 1
a1244 1
Static int
d1293 1
a1293 1
Static void
d1339 1
a1339 1
Static void
d1412 1
a1412 1
Static int
d1462 1
a1462 1
Static int
d1488 1
a1488 1
Static void
d1501 1
a1501 1
Static int
d1582 1
a1582 1
Static void
d1609 1
a1609 1
Static void
d1622 1
a1622 1
Static void
@


1.55
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.54 2007/05/21 05:40:27 jsg Exp $ */
a88 1
#if defined(__OpenBSD__)
a89 1
#endif
a94 3
#if defined(__NetBSD__)
#include <net/if_arp.h>
#endif
a101 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined(__NetBSD__) */

#if defined(__OpenBSD__)
a108 1
#endif /* defined(__OpenBSD__) */
a598 3
#if defined(__NetBSD__)
	ETHER_FIRST_MULTI(step, &sc->aue_ec, enm);
#else
a599 1
#endif
a791 1
#if defined(__OpenBSD__)
a792 1
#endif
a1362 1
#if defined(__OpenBSD__)
a1363 3
#elif defined(__NetBSD__)
	eaddr = LLADDR(ifp->if_sadl);
#endif /* defined(__NetBSD__) */
a1522 3
#if defined(__NetBSD__)
			arp_ifinit(ifp, ifa);
#else
a1523 1
#endif
@


1.54
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.53 2007/05/21 05:18:56 jsg Exp $ */
d701 2
a702 1
USB_MATCH(aue)
d704 1
a704 1
	USB_MATCH_START(aue, uaa);
d717 2
a718 1
USB_ATTACH(aue)
d720 2
a721 1
	USB_ATTACH_START(aue, sc, uaa);
d737 1
a737 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->aue_dev), devinfop);
d744 1
a744 1
		USB_ATTACH_ERROR_RETURN;
d755 1
a755 1
		USB_ATTACH_ERROR_RETURN;
d773 1
a773 1
			USB_ATTACH_ERROR_RETURN;
d790 1
a790 1
		USB_ATTACH_ERROR_RETURN;
a851 2

	USB_ATTACH_SUCCESS_RETURN;
d854 2
a855 1
USB_DETACH(aue)
d857 1
a857 1
	USB_DETACH_START(aue, sc);
@


1.53
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.52 2007/05/06 04:08:47 krw Exp $ */
d136 2
a137 2
#define DPRINTF(x)	do { if (auedebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (auedebug >= (n)) logprintf x; } while (0)
@


1.52
log
@More lockmgr -> rwlock low hanging fruit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.51 2007/02/23 23:03:04 jsg Exp $ */
d840 1
a840 1
	Ether_ifattach(ifp, eaddr);
@


1.51
log
@Belkin USB to LAN -> Belkin F5D5050
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.50 2007/02/11 20:29:22 miod Exp $ */
d85 1
a85 1
#include <sys/lock.h>
d432 1
a432 1
	usb_lockmgr(&sc->aue_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d438 1
a438 1
	usb_lockmgr(&sc->aue_mii_lock, LK_RELEASE, NULL, curproc);
d747 1
a747 1
	lockinit(&sc->aue_mii_lock, PZERO, "auemii", 0, 0);
@


1.50
log
@Remove _KERNEL_OPT leftovers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.49 2006/09/26 12:23:40 jsg Exp $ */
d178 1
a178 1
 {{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_USB2LAN},	  PII },
@


1.49
log
@Match ELECOM LD-USB20
From redzonemiata at yahoo.co.jp via FreeBSD PR 86195
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.48 2006/06/23 06:27:11 miod Exp $ */
a78 6

#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
#include "rnd.h"
#endif
@


1.48
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.47 2006/05/22 20:35:12 krw Exp $ */
d204 1
@


1.47
log
@Attach routines can fail before calling *hook_establish(), and they
often rely on the detach routine for cleanup. So be consistant and
careful by checking for a NULL hook before calling *hook_disestablish
in detach routines.

ok mickey@@ brad@@ dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.46 2006/05/18 16:46:05 jolan Exp $ */
a922 1
		return (EOPNOTSUPP);
@


1.46
log
@some devices can do weird things upon a warm reboot so add a shutdown
hook which explicitly resets and stops the device; fixes pr/5001

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.45 2006/03/25 22:41:46 djm Exp $ */
d899 2
a900 1
	shutdownhook_disestablish(sc->sc_sdhook);
@


1.45
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.44 2006/03/07 04:41:19 krw Exp $ */
d248 1
d850 1
d899 1
d1636 13
@


1.44
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.43 2006/01/29 03:22:52 brad Exp $ */
a108 2
#define BPF_MTAP(ifp, m) bpf_mtap((ifp)->if_bpf, (m))

d1143 1
a1143 1
		BPF_MTAP(ifp, m);
d1350 1
a1350 1
		BPF_MTAP(ifp, m_head);
@


1.43
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.42 2005/08/01 05:36:47 brad Exp $ */
a100 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a846 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, USBDEVNAME(sc->aue_dev),
	    RND_TYPE_NET, 0);
#endif
a884 5
#if defined(__NetBSD__)
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
#endif /* __NetBSD__ */
@


1.42
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.41 2005/07/02 22:21:12 brad Exp $ */
d1066 1
a1066 1
			usbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);
d1111 1
a1111 1
			usbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_RX]);
d1212 1
a1212 1
			usbd_clear_endpoint_stall(sc->aue_ep[AUE_ENDPT_TX]);
@


1.41
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.40 2005/07/02 22:17:57 brad Exp $ */
d728 1
a728 1
	char			devinfo[1024];
d742 1
a742 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d744 2
a745 1
	printf("%s: %s\n", USBDEVNAME(sc->aue_dev), devinfo);
@


1.40
log
@don't call mii_pollstat() right after mii_tick() in foo_tick_task()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.39 2005/06/08 17:03:01 henning Exp $ */
d1663 1
a1737 2

	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.39
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.38 2005/01/03 22:45:52 brad Exp $ */
d1265 7
a1271 10
	if (!sc->aue_link) {
		mii_pollstat(mii); /* XXX FreeBSD has removed this call */
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			DPRINTFN(2,("%s: %s: got link\n",
				    USBDEVNAME(sc->aue_dev),__func__));
			sc->aue_link++;
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				aue_start(ifp);
		}
@


1.38
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.37 2004/11/10 10:14:48 grange Exp $ */
a135 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1571 15
#ifdef NS
		case AF_NS:
		    {
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
					LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				       ina->x_host.c_host,
				       ifp->if_addrlen);
			break;
		    }
#endif /* NS */
@


1.37
log
@strncpy->strlcpy
ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.36 2004/10/31 00:37:40 jsg Exp $ */
a1623 4
#if defined(__NetBSD__)
			ether_addmulti(ifr, &sc->aue_ec) :
			ether_delmulti(ifr, &sc->aue_ec);
#else
d1626 1
a1626 1
#endif
d1628 3
a1630 1
			aue_init(sc);
a1631 2
		aue_setmulti(sc);
		error = 0;
@


1.36
log
@add some aue devices found in the linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.35 2004/09/23 17:45:17 brad Exp $ */
d832 1
a832 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->aue_dev), IFNAMSIZ);
@


1.35
log
@don't need to set ifp->if_mtu or ifp->if_output in each driver,
{ether,atm,fddi}_ifattach already does this.

ok mcbride@@ markus@@ henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.34 2004/07/11 09:47:22 deraadt Exp $ */
d189 5
d208 1
d215 1
d231 1
d234 1
d239 1
@


1.34
log
@4 more aue(4) devices
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.33 2004/07/08 22:18:44 deraadt Exp $ */
a817 1
	ifp->if_mtu = ETHERMTU;
@


1.33
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.32 2003/12/15 23:36:14 cedric Exp $ */
d188 1
d209 2
d220 1
@


1.32
log
@Set devclass to DV_IFNET for all USB network drivers.
ok deraadt@@ nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.31 2003/05/17 17:48:32 nate Exp $ */
d152 2
a153 2
#define DPRINTF(x)	if (auedebug) logprintf x
#define DPRINTFN(n,x)	if (auedebug >= (n)) logprintf x
@


1.31
log
@Correct chipset identification from netbsd
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.30 2003/05/07 04:33:33 deraadt Exp $ */
d229 1
a229 1
USB_DECLARE_DRIVER(aue);
@


1.30
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.29 2002/11/11 02:32:32 nate Exp $ */
/*	$NetBSD: if_aue.c,v 1.81 2002/09/29 19:55:52 augustss Exp $	*/
d203 1
a203 1
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1},	  0 },
d205 1
a205 1
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3},	  PII },
@


1.29
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.28 2002/09/27 18:42:51 nate Exp $ */
d733 1
a733 1
	usbd_devinfo(dev, 0, devinfo);
@


1.28
log
@new Netgear adapter
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.27 2002/07/29 03:33:02 nate Exp $ */
/*	$NetBSD: if_aue.c,v 1.80 2002/07/25 06:45:38 matt Exp $	*/
@


1.27
log
@another usb ethernet device
from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.26 2002/07/25 04:07:32 nate Exp $ */
d220 1
@


1.26
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.25 2002/07/25 02:18:10 nate Exp $ */
/*	$NetBSD: if_aue.c,v 1.79 2002/07/11 21:14:25 augustss Exp $ */
d188 1
@


1.25
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.24 2002/07/10 18:08:13 deraadt Exp $ */
/*	$NetBSD: if_aue.c,v 1.78 2002/07/08 17:46:23 augustss Exp $	*/
@


1.24
log
@shorten address printout
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.23 2002/07/09 14:45:43 nate Exp $ */
d121 1
a121 1
#include <netinet/in.h> 
d570 1
a570 1
Static u_int32_t 
d680 1
a680 1
		aue_csr_write_1(sc, AUE_GPIO0, 
d683 1
a683 1
		aue_csr_write_1(sc, AUE_GPIO0, 
d907 1
a907 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->aue_udev, 
d971 1
a971 1
Static int 
d1468 1
a1468 1
	    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr, 
@


1.23
log
@add new device
from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.22 2002/07/04 05:51:13 nate Exp $ */
d803 1
a803 1
	printf("%s: Ethernet address %s\n", USBDEVNAME(sc->aue_dev),
@


1.22
log
@New product ID.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.21 2002/06/26 11:29:55 espie Exp $ */
/*	$NetBSD: if_aue.c,v 1.76 2002/06/25 01:07:38 nathanw Exp $	*/
d222 1
@


1.21
log
@Kill __FUNCTION__.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.20 2002/04/01 21:47:07 nate Exp $ */
/*	$NetBSD: if_aue.c,v 1.75 2002/03/18 14:01:05 christos Exp $	*/
d172 1
@


1.20
log
@Add support for a bunch of new adapters.
Sync with NetBSD.  ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.19 2002/03/14 03:16:08 millert Exp $ */
d414 1
a414 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d487 1
a487 1
		     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, val));
d508 1
a508 1
		     USBDEVNAME(sc->aue_dev), __FUNCTION__, phy, reg, data));
d533 1
a533 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d562 1
a562 1
	DPRINTFN(5,("%s: %s: exit\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d592 1
a592 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d647 1
a647 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d859 1
a859 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d916 1
a916 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d939 1
a939 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d976 1
a976 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1005 1
a1005 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1033 1
a1033 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1079 1
a1079 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1148 1
a1148 1
		    __FUNCTION__, m->m_len));
d1163 1
a1163 1
		    __FUNCTION__));
d1185 1
a1185 1
		    __FUNCTION__, status));
d1220 1
a1220 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1240 1
a1240 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1258 1
a1258 1
				    USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1277 1
a1277 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));
d1312 1
a1312 1
		    __FUNCTION__, total_len));
d1326 1
a1326 1
		    __FUNCTION__, sc->aue_link));
d1374 1
a1374 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1483 1
a1483 1
			    __FUNCTION__));
d1498 1
a1498 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1524 1
a1524 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1643 1
a1643 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
d1669 1
a1669 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
@


1.19
log
@Final __P removal plus some cosmetic fixups
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.18 2002/01/03 22:23:43 deraadt Exp $ */
/*	$NetBSD: if_aue.c,v 1.67 2001/10/10 02:14:16 augustss Exp $	*/
a82 1
#include "bpfilter.h"
d84 2
a85 1
#elif defined(__OpenBSD__)
a86 1
#endif /* defined(__OpenBSD__) */
d95 1
d97 1
d164 1
a164 2
	u_int16_t		aue_vid;
	u_int16_t		aue_did;
d172 50
a221 47
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX1,		  PNA|PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX2,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000,	  0 },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX4,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX5,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX6,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX7,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX8,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX9,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX10,	  0 },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_DSB650TX_PNA,  0 },
  { USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_USB320_EC,	  0 },
  { USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS,	  PNA },
  { USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII,	  PII },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100,	  0 },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBLP100,  PNA },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBEL100,  0 },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBE100,	  PII },
  { USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TX, 0 },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX4,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX1,	  LSYS },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX,	  LSYS },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA,	  PNA },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX3,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX2,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX0,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX2,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3,	  PII },
  { USB_VENDOR_ELSA,		USB_PRODUCT_ELSA_USB2ETHERNET,	  0 },
  { USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX,	  0 },
  { USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTXS,	  PII },
  { USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX,    0 },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX1,	  LSYS|PII },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10T,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1,	  LSYS|PNA },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX2,	  LSYS|PII },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1, 	  0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5, 	  0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUA2TX5, 	  PII },
  { USB_VENDOR_SMARTBRIDGES,	USB_PRODUCT_SMARTBRIDGES_SMARTNIC,PII },
  { USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB,	  0 },
  { USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100,	  0 },
  { 0, 0, 0 }
d223 1
a227 1
Static const struct aue_type *aue_lookup(u_int16_t vendor, u_int16_t product);
d427 2
a428 1
	lockmgr(&sc->aue_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d434 3
a436 1
	lockmgr(&sc->aue_mii_lock, LK_RELEASE, NULL, curproc);
d446 7
d557 1
a557 1
	if (sc->aue_flags & LSYS) {
d562 1
d659 8
a675 14
	aue_csr_write_1(sc, AUE_GPIO0, 
	    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);
  	aue_csr_write_1(sc, AUE_GPIO0,
	    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);
  
#if 0
	/* XXX what is mii_mode supposed to be */
	if (sc->aue_mii_mode && (sc->aue_flags & PNA))
		aue_csr_write_1(sc, AUE_GPIO1, 0x34);
	else
		aue_csr_write_1(sc, AUE_GPIO1, 0x26);
#endif

	/* Grrr. LinkSys has to be different from everyone else. */
d677 1
d680 3
a682 2
		aue_csr_write_1(sc, AUE_GPIO0,
		    AUE_GPIO_SEL0 | AUE_GPIO_SEL1 | AUE_GPIO_OUT0);
d684 2
a693 11
Static const struct aue_type *
aue_lookup(u_int16_t vendor, u_int16_t product)
{
	const struct aue_type	*t;

	for (t = aue_devs; t->aue_vid != 0; t++)
		if (vendor == t->aue_vid && product == t->aue_did)
			return (t);
	return (NULL);
}

d883 1
a883 2
#endif

a885 6

#if defined(__NetBSD__)
#if NBPFILTER > 0
	bpfdetach(ifp);
#endif
#endif /* __NetBSD__ */
a886 1

d898 5
@


1.18
log
@new names, nate broke the tree
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.17 2001/10/31 04:24:44 nate Exp $ */
d1106 1
a1106 1
	memcpy(mtod(c->aue_mbuf, char*), c->aue_buf, total_len);
@


1.17
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.16 2001/07/15 03:03:35 mickey Exp $ */
d174 1
a174 1
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX3,		  0 },
@


1.17.2.1
log
@Merge in -current, builds on i386, otherwise untested
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.18 2002/01/03 22:23:43 deraadt Exp $ */
d174 1
a174 1
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000,	  0 },
@


1.17.2.2
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_aue.c,v 1.75 2002/03/18 14:01:05 christos Exp $	*/
d83 1
d85 1
a85 2
#endif

d87 1
a95 1
#if defined(__OpenBSD__)
a96 1
#endif
d163 2
a164 1
	struct usb_devno	aue_dev;
d172 47
a218 50
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX1},	  PNA|PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX2},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000},	  LSYS },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX4},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX5},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX6},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX7},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX8},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX9},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX10},	  0 },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_DSB650TX_PNA}, 0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_USB320_EC},	  0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_SS1001},	  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS},	  PNA },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII},	  PII },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100},	  0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBLP100}, PNA },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBEL100}, 0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBE100},  PII },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TX}, 0 },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TXS},PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX4},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX1},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA},  PNA },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX3},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX2},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX0},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX2},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3},	  PII },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBLTX},	  PII },
 {{ USB_VENDOR_ELSA,		USB_PRODUCT_ELSA_USB2ETHERNET},	  0 },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX},	  0 },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTXS},	  PII },
 {{ USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX},   0 },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX1},	  LSYS|PII },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10T},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1},	  LSYS|PNA },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX2},	  LSYS|PII },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUA2TX5}, 	  PII },
 {{ USB_VENDOR_SIEMENS,		USB_PRODUCT_SIEMENS_SPEEDSTREAM}, PII },
 {{ USB_VENDOR_SMARTBRIDGES,	USB_PRODUCT_SMARTBRIDGES_SMARTNIC},PII },
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB},	  0 },
 {{ USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100},	  0 },
a219 1
#define aue_lookup(v, p) ((struct aue_type *)usb_lookup(aue_devs, v, p))
d224 1
d424 1
a424 2
	sc->aue_refcnt++;
	usb_lockmgr(&sc->aue_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d430 1
a430 3
	usb_lockmgr(&sc->aue_mii_lock, LK_RELEASE, NULL, curproc);
	if (--sc->aue_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->aue_dev));
a439 7
	if (sc->aue_dying) {
#ifdef DIAGNOSTIC
		printf("%s: dying\n", USBDEVNAME(sc->aue_dev));
#endif
		return 0;
	}

d544 1
a544 1
	if (!sc->aue_dying && (sc->aue_flags & LSYS)) {
a548 1
	DPRINTFN(5,("%s: %s: exit\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));
a644 8
#if 0
	/* XXX what is mii_mode supposed to be */
	if (sc->aue_mii_mode && (sc->aue_flags & PNA))
		aue_csr_write_1(sc, AUE_GPIO1, 0x34);
	else
		aue_csr_write_1(sc, AUE_GPIO1, 0x26);
#endif

d654 14
a668 1
		/* Grrr. LinkSys has to be different from everyone else. */
d671 2
a672 3
	} else {
		aue_csr_write_1(sc, AUE_GPIO0, 
		    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);
a673 2
  	aue_csr_write_1(sc, AUE_GPIO0,
	    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);
d682 11
d882 2
a883 1
#endif /* __NetBSD__ */
d886 6
d893 1
a904 5

	if (--sc->aue_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(USBDEV(sc->aue_dev));
	}
d1106 1
a1106 1
	memcpy(mtod(c->aue_mbuf, char *), c->aue_buf, total_len);
@


1.17.2.3
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: if_aue.c,v 1.80 2002/07/25 06:45:38 matt Exp $	*/
d121 1
a121 1
#include <netinet/in.h>
a171 1
 {{ USB_VENDOR_3COM,		USB_PRODUCT_3COM_3C460B},	  PII },
a186 1
 {{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_USB2LAN},	  PII },
a217 1
 {{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_FA101},	  PII },
a220 1
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2206USB},	  PII },
d414 1
a414 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d487 1
a487 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, val));
d508 1
a508 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, data));
d533 1
a533 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d562 1
a562 1
	DPRINTFN(5,("%s: %s: exit\n", USBDEVNAME(sc->aue_dev), __func__));
d568 1
a568 1
Static u_int32_t
d592 1
a592 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d647 1
a647 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d678 1
a678 1
		aue_csr_write_1(sc, AUE_GPIO0,
d681 1
a681 1
		aue_csr_write_1(sc, AUE_GPIO0,
d801 1
a801 1
	printf("%s: address %s\n", USBDEVNAME(sc->aue_dev),
d859 1
a859 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d905 1
a905 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->aue_udev,
d916 1
a916 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d939 1
a939 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d969 1
a969 1
Static int
d976 1
a976 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1005 1
a1005 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1033 1
a1033 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1079 1
a1079 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1148 1
a1148 1
		    __func__, m->m_len));
d1163 1
a1163 1
		    __func__));
d1185 1
a1185 1
		    __func__, status));
d1220 1
a1220 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1240 1
a1240 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1258 1
a1258 1
				    USBDEVNAME(sc->aue_dev),__func__));
d1277 1
a1277 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1312 1
a1312 1
		    __func__, total_len));
d1326 1
a1326 1
		    __func__, sc->aue_link));
d1374 1
a1374 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1466 1
a1466 1
	    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr,
d1483 1
a1483 1
			    __func__));
d1498 1
a1498 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1524 1
a1524 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1643 1
a1643 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1669 1
a1669 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
@


1.17.2.4
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: if_aue.c,v 1.81 2002/09/29 19:55:52 augustss Exp $	*/
d733 1
a733 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.16
log
@add support for SOHOware NUB100; from Jason Ackley <jason@@ackley.net>
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.15 2001/07/08 23:38:08 fgsch Exp $ */
/*	$NetBSD: if_aue.c,v 1.55 2001/03/25 22:59:43 augustss Exp $	*/
d38 2
a39 2
 * ADMtek AN986 Pegasus USB to ethernet driver. Datasheet is available
 * from http://www.admtek.com.tw.
d165 4
a168 1
	char			aue_linksys;
d172 18
a189 12
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100,	0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1, 	0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5, 	0 },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX,	1 },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1,	1 },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA,	1 },
  { USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS,	0 },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650,	1 },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX,	1 },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA,	0 },
  { USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100,	0 },
  { USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB,	0 },
d191 27
a217 2
  { USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX,	0 },
  { USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX,	0 },
d223 1
d544 1
a544 1
	if (sc->aue_linksys) {
d615 14
d659 8
d668 1
a668 1
	if (sc->aue_linksys) {
d675 3
d750 1
a750 1
	sc->aue_linksys = aue_lookup(uaa->vendor, uaa->product)->aue_linksys;
d814 2
a816 1
	strncpy(ifp->if_xname, USBDEVNAME(sc->aue_dev), IFNAMSIZ);
d860 5
a874 6
	if (!sc->aue_attached) {
		/* Detached before attached finished, so just bail out. */
		splx(s);
		return (0);
	}

d1050 1
a1050 1
			    USBDEVNAME(sc->aue_dev), sc->aue_rx_errs,
d1256 1
a1256 1
		mii_pollstat(mii);
@


1.15
log
@Don't set up ifq_maxlen manually for drivers that uses IFQ_MAXLEN
(or ifqmaxlen); it's done in if_attach() now.
No future drivers needs to set up this anymore unless they want to
use something else.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.14 2001/06/27 06:34:53 kjc Exp $ */
d179 1
@


1.14
log
@ALTQ'ify network drivers.
- use the new queue macros.
- use IFQ_POLL() to peek at the next packet.
- use IFQ_IS_EMPTY() for empty check.
- drivers should always check if (m == NULL) after IFQ_DEQUEUE(),
since it could return NULL even when IFQ_IS_EMPTY() is FALSE
under rate-limiting.
- drivers are supposed to call if_start from tx complete interrupts
(in order to trigger the next dequeue under rate-limiting).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.13 2001/05/03 02:20:32 aaron Exp $ */
a752 3
#if defined(__OpenBSD__)
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
#endif
@


1.13
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.12 2001/02/20 19:39:47 mickey Exp $ */
d754 1
a754 1
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;
d756 1
d1153 1
a1153 1
	if (ifp->if_snd.ifq_head != NULL)
d1204 1
a1204 1
			if (ifp->if_snd.ifq_head != NULL)
d1281 1
a1281 1
	IF_DEQUEUE(&ifp->if_snd, m_head);
a1285 1
		IF_PREPEND(&ifp->if_snd, m_head);
d1290 2
d1597 1
a1597 1
	if (ifp->if_snd.ifq_head != NULL)
@


1.13.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: if_aue.c,v 1.38 2000/04/04 20:16:19 augustss Exp $	*/
d92 1
d96 1
a98 10
#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>
/* "controller miibus0" required.  See GENERIC if you get errors here. */
#include "miibus_if.h"

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a103 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d105 1
a105 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a110 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a111 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d113 1
a113 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a134 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a138 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a147 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d168 1
a168 1
Static struct aue_type aue_devs[] = {
d188 36
a223 88
Static struct aue_type *aue_lookup __P((u_int16_t, u_int16_t));
Static int aue_tx_list_init	__P((struct aue_softc *));
Static int aue_rx_list_init	__P((struct aue_softc *));
Static int aue_newbuf		__P((struct aue_softc *, struct aue_chain *,
				    struct mbuf *));
Static int aue_send		__P((struct aue_softc *, struct mbuf *, int));
Static void aue_intr		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_tick		__P((void *));
Static void aue_start		__P((struct ifnet *));
Static int aue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void aue_init		__P((void *));
Static void aue_stop		__P((struct aue_softc *));
Static void aue_watchdog	__P((struct ifnet *));
#ifdef __FreeBSD__
Static void aue_shutdown	__P((device_ptr_t));
#endif
Static int aue_openpipes	__P((struct aue_softc *));
Static int aue_ifmedia_upd	__P((struct ifnet *));
Static void aue_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

Static int aue_eeprom_getword	__P((struct aue_softc *, int));
Static void aue_read_mac	__P((struct aue_softc *, u_char *));
Static int aue_miibus_readreg	__P((device_ptr_t, int, int));
#if defined(__FreeBSD__)
Static int aue_miibus_writereg	__P((device_ptr_t, int, int, int));
#elif defined(__NetBSD__) || defined(__OpenBSD__)
Static void aue_miibus_writereg	__P((device_ptr_t, int, int, int));
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
Static void aue_miibus_statchg	__P((device_ptr_t));

Static void aue_setmulti	__P((struct aue_softc *));
Static u_int32_t aue_crc	__P((caddr_t));
Static void aue_reset		__P((struct aue_softc *));

Static int aue_csr_read_1	__P((struct aue_softc *, int));
Static int aue_csr_write_1	__P((struct aue_softc *, int, int));
Static int aue_csr_read_2	__P((struct aue_softc *, int));
Static int aue_csr_write_2	__P((struct aue_softc *, int, int));

#if defined(__FreeBSD__)
#if !defined(lint)
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_aue.c,v 1.11 2000/01/14 01:36:14 wpaul Exp $";
#endif

Static void aue_rxstart		__P((struct ifnet *));

Static struct usb_qdat aue_qdat;

Static device_method_t aue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		aue_match),
	DEVMETHOD(device_attach,	aue_attach),
	DEVMETHOD(device_detach,	aue_detach),
	DEVMETHOD(device_shutdown,	aue_shutdown),

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	aue_miibus_readreg),
	DEVMETHOD(miibus_writereg,	aue_miibus_writereg),
	DEVMETHOD(miibus_statchg,	aue_miibus_statchg),

	{ 0, 0 }
};

Static driver_t aue_driver = {
	"aue",
	aue_methods,
	sizeof(struct aue_softc)
};

Static devclass_t aue_devclass;

DRIVER_MODULE(if_aue, uhub, aue_driver, aue_devclass, usbd_driver_load, 0);
DRIVER_MODULE(miibus, aue, miibus_driver, miibus_devclass, 0, 0);

#endif /* __FreeBSD__ */

#define AUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d232 1
a232 3
aue_csr_read_1(sc, reg)
	struct aue_softc	*sc;
	int			reg;
a236 1
	int			s;
d247 1
a247 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d259 1
a259 3
aue_csr_read_2(sc, reg)
	struct aue_softc	*sc;
	int			reg;
a263 1
	int			s;
d274 1
a274 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d286 1
a286 3
aue_csr_write_1(sc, reg, aval)
	struct aue_softc	*sc;
	int			reg, aval;
a289 1
	int			s;
d302 1
a302 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d314 1
a314 3
aue_csr_write_2(sc, reg, aval)
	struct aue_softc	*sc;
	int			reg, aval;
a317 1
	int			s;
d330 1
a330 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d345 1
a345 3
aue_eeprom_getword(sc, addr)
	struct aue_softc	*sc;
	int			addr;
d369 1
a369 3
aue_read_mac(sc, dest)
	struct aue_softc	*sc;
	u_char			*dest;
d384 13
d398 1
a398 3
aue_miibus_readreg(dev, phy, reg)
	device_ptr_t		dev;
	int			phy, reg;
d404 1
d417 1
a417 1
		if (phy != 1)
d420 1
d422 1
d432 1
a432 2
		printf("%s: MII read timed out\n",
		    USBDEVNAME(sc->aue_dev));
d440 1
a443 3
#if defined(__FreeBSD__)
Static int
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d445 1
a445 4
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
aue_miibus_writereg(dev, phy, reg, data)
	device_ptr_t		dev;
	int			phy, reg, data;
d450 1
a453 3
#if defined(__FreeBSD__)
			return (0);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a454 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d456 1
d461 1
d475 1
a475 4

#if defined(__FreeBSD__)
	return (0);
#endif
d479 1
a479 2
aue_miibus_statchg(dev)
	device_ptr_t		dev;
d486 1
d501 1
d519 1
a519 2
aue_crc(addr)
	caddr_t			addr;
d535 1
a535 2
aue_setmulti(sc)
	struct aue_softc	*sc;
a537 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a539 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d546 3
a548 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a559 9
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0x7));
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a565 1
#if 1
d567 3
a569 6
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			AUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);
			return;
		}
#endif
d574 2
a575 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d579 1
a579 2
aue_reset(sc)
	struct aue_softc	*sc;
d621 2
a622 3
Static struct aue_type *
aue_lookup(vendor, product)
	u_int16_t vendor, product;
d624 1
a624 1
	struct aue_type	*t;
a664 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct aue_softc));
#endif

d671 1
a671 1
	err = usbd_set_config_no(dev, AUE_CONFIG_NO, 0);
d678 4
d725 1
a725 1
	s = splimp();
a738 52
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->aue_dev),
	    eaddr, ":");

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp->if_softc = sc;
	ifp->if_unit = sc->aue_unit;
	ifp->if_name = "aue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = aue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = aue_start;
	ifp->if_watchdog = aue_watchdog;
	ifp->if_init = aue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	/*
	 * Do MII setup.
	 * NOTE: Doing this causes child devices to be attached to us,
	 * which we would normally disconnect at in the detach routine
	 * using device_delete_child(). However the USB code is set up
	 * such that when this driver is removed, all childred devices
	 * are removed as well. In effect, the USB code ends up detaching
	 * all of our children for us, so we don't have to do is ourselves
	 * in aue_detach(). It's important to point this out since if
	 * we *do* try to detach the child devices ourselves, we will
	 * end up getting the children deleted twice, which will crash
	 * the system.
	 */
	if (mii_phy_probe(self, &sc->aue_miibus,
	    aue_ifmedia_upd, aue_ifmedia_sts)) {
		printf("%s: MII without any PHY!\n", USBDEVNAME(sc->aue_dev));
		splx(s);
		USB_ATTACH_ERROR_RETURN;
	}

	aue_qdat.ifp = ifp;
	aue_qdat.if_rxstart = aue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));

	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

d764 1
a775 1

a780 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d800 8
a809 2
	usb_uncallout(sc->aue_stat_ch, aue_tick, sc);

d832 1
a833 1
#endif /* __NetBSD__ */
a853 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d855 1
a855 3
aue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a872 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d878 1
a878 4
aue_newbuf(sc, c, m)
	struct aue_softc	*sc;
	struct aue_chain	*c;
	struct mbuf		*m;
d913 1
a913 2
aue_rx_list_init(sc)
	struct aue_softc	*sc;
d942 1
a942 2
aue_tx_list_init(sc)
	struct aue_softc	*sc;
d970 1
a970 4
aue_intr(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a1006 24
#if defined(__FreeBSD__)
Static void
aue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct aue_softc	*sc;
	struct aue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->aue_cdata.aue_rx_chain[sc->aue_cdata.aue_rx_prod];

	if (aue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],
	    c, mtod(c->aue_mbuf, char *), AUE_BUFSZ, USBD_SHORT_XFER_OK,
	    USBD_NO_TIMEOUT, aue_rxeof);
	usbd_transfer(c->aue_xfer);
}
#endif

d1012 1
a1012 4
aue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a1019 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1020 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a1068 8
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d1071 1
a1071 1
	s = splimp();
d1086 1
a1086 12
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
		BPF_MTAP(ifp, m);
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
a1088 2
	}
#endif
a1094 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1115 1
a1115 4
aue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d1125 1
a1125 1
	s = splimp();
a1148 5
#if defined(__FreeBSD__)
	c->aue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->aue_mbuf);
  	c->aue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1153 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1159 18
a1176 2
aue_tick(xsc)
	void			*xsc;
a1184 3
	if (sc == NULL)
		return;

d1193 1
a1193 1
	s = splimp();
d1214 1
a1214 4
aue_send(sc, m, idx)
	struct aue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d1250 2
a1251 1
		aue_stop(sc);
d1263 1
a1263 2
aue_start(ifp)
	struct ifnet		*ifp;
d1308 1
a1308 2
aue_init(xsc)
	void			*xsc;
d1324 1
a1324 1
	s = splimp();
d1331 1
a1331 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d1385 1
a1385 2
aue_openpipes(sc)
	struct aue_softc	*sc;
d1435 1
a1435 2
aue_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1461 1
a1461 3
aue_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1474 1
a1474 4
aue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1476 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1477 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1485 1
a1485 1
	s = splimp();
a1487 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1526 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1548 11
d1578 1
a1578 2
aue_watchdog(ifp)
	struct ifnet		*ifp;
d1581 3
d1590 4
a1593 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->aue_udev, 1);
	aue_stop(sc);
	aue_init(sc);
	usbd_set_polling(sc->aue_udev, 0);
d1597 1
d1605 1
a1605 2
aue_stop(sc)
	struct aue_softc	*sc;
a1691 18

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
aue_shutdown(dev)
	device_ptr_t		dev;
{
	struct aue_softc	*sc = USBGETSOFTC(dev);

	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));

	aue_reset(sc);
	aue_stop(sc);
}
#endif
@


1.13.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_aue.c,v 1.55 2001/03/25 22:59:43 augustss Exp $	*/
a91 1
#include <sys/lock.h>
a94 1
#include <sys/proc.h>
d97 10
d112 2
d115 1
a115 1
#if defined(__NetBSD__)
d121 1
d123 3
d127 1
a127 1
#if NBPFILTER > 0
d149 1
d154 1
d164 4
d188 1
a188 1
Static const struct aue_type aue_devs[] = {
d208 88
a295 36
Static const struct aue_type *aue_lookup(u_int16_t vendor, u_int16_t product);
Static int aue_tx_list_init(struct aue_softc *);
Static int aue_rx_list_init(struct aue_softc *);
Static int aue_newbuf(struct aue_softc *, struct aue_chain *, struct mbuf *);
Static int aue_send(struct aue_softc *, struct mbuf *, int);
Static void aue_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void aue_tick(void *);
Static void aue_tick_task(void *);
Static void aue_start(struct ifnet *);
Static int aue_ioctl(struct ifnet *, u_long, caddr_t);
Static void aue_init(void *);
Static void aue_stop(struct aue_softc *);
Static void aue_watchdog(struct ifnet *);
Static int aue_openpipes(struct aue_softc *);
Static int aue_ifmedia_upd(struct ifnet *);
Static void aue_ifmedia_sts(struct ifnet *, struct ifmediareq *);

Static int aue_eeprom_getword(struct aue_softc *, int);
Static void aue_read_mac(struct aue_softc *, u_char *);
Static int aue_miibus_readreg(device_ptr_t, int, int);
Static void aue_miibus_writereg(device_ptr_t, int, int, int);
Static void aue_miibus_statchg(device_ptr_t);

Static void aue_lock_mii(struct aue_softc *);
Static void aue_unlock_mii(struct aue_softc *);

Static void aue_setmulti(struct aue_softc *);
Static u_int32_t aue_crc(caddr_t);
Static void aue_reset(struct aue_softc *);

Static int aue_csr_read_1(struct aue_softc *, int);
Static int aue_csr_write_1(struct aue_softc *, int, int);
Static int aue_csr_read_2(struct aue_softc *, int);
Static int aue_csr_write_2(struct aue_softc *, int, int);
d304 3
a306 1
aue_csr_read_1(struct aue_softc *sc, int reg)
d311 1
d322 3
a324 1
	err = usbd_do_request(sc->aue_udev, &req, &val);
d336 3
a338 1
aue_csr_read_2(struct aue_softc *sc, int reg)
d343 1
d354 3
a356 1
	err = usbd_do_request(sc->aue_udev, &req, &val);
d368 3
a370 1
aue_csr_write_1(struct aue_softc *sc, int reg, int aval)
d374 1
d387 3
a389 1
	err = usbd_do_request(sc->aue_udev, &req, &val);
d401 3
a403 1
aue_csr_write_2(struct aue_softc *sc, int reg, int aval)
d407 1
d420 3
a422 1
	err = usbd_do_request(sc->aue_udev, &req, &val);
d437 3
a439 1
aue_eeprom_getword(struct aue_softc *sc, int addr)
d463 3
a465 1
aue_read_mac(struct aue_softc *sc, u_char *dest)
a479 13
/* Get exclusive access to the MII registers */
Static void
aue_lock_mii(struct aue_softc *sc)
{
	lockmgr(&sc->aue_mii_lock, LK_EXCLUSIVE, NULL, curproc);
}

Static void
aue_unlock_mii(struct aue_softc *sc)
{
	lockmgr(&sc->aue_mii_lock, LK_RELEASE, NULL, curproc);
}

d481 3
a483 1
aue_miibus_readreg(device_ptr_t dev, int phy, int reg)
a488 1
#if 0
d501 1
a501 1
		if (phy == 3)
a503 1
#endif
a504 1
	aue_lock_mii(sc);
d514 2
a515 1
		printf("%s: MII read timed out\n", USBDEVNAME(sc->aue_dev));
a522 1
	aue_unlock_mii(sc);
d526 3
d530 4
a533 1
aue_miibus_writereg(device_ptr_t dev, int phy, int reg, int data)
a537 1
#if 0
d541 3
d545 1
a546 1
#endif
a550 1
	aue_lock_mii(sc);
d564 4
a567 1
	aue_unlock_mii(sc);
d571 2
a572 1
aue_miibus_statchg(device_ptr_t dev)
a578 1
	aue_lock_mii(sc);
a592 1
	aue_unlock_mii(sc);
d610 2
a611 1
aue_crc(caddr_t addr)
d627 2
a628 1
aue_setmulti(struct aue_softc *sc)
d631 3
d636 1
d643 1
a643 3
	if (ifp->if_flags & IFF_PROMISC) {
allmulti:
		ifp->if_flags |= IFF_ALLMULTI;
d655 9
d670 1
d672 6
a677 3
		    enm->enm_addrhi, ETHER_ADDR_LEN) != 0)
			goto allmulti;

d682 1
a682 2

	ifp->if_flags &= ~IFF_ALLMULTI;
d686 2
a687 1
aue_reset(struct aue_softc *sc)
d729 3
a731 2
Static const struct aue_type *
aue_lookup(u_int16_t vendor, u_int16_t product)
d733 1
a733 1
	const struct aue_type	*t;
d774 4
d784 1
a784 1
	err = usbd_set_config_no(dev, AUE_CONFIG_NO, 1);
a790 4
	usb_init_task(&sc->aue_tick_task, aue_tick_task, sc);
	usb_init_task(&sc->aue_stop_task, (void (*)(void *))aue_stop, sc);
	lockinit(&sc->aue_mii_lock, PZERO, "auemii", 0, 0);

d834 1
a834 1
	s = splnet();
d848 52
d915 1
a915 1
	IFQ_SET_MAXLEN(&ifp->if_snd, IFQ_MAXLEN);
a916 1
	IFQ_SET_READY(&ifp->if_snd);
a924 1
	mii->mii_flags = MIIF_AUTOTSLEEP;
d936 1
d942 2
d963 2
a965 8
	/*
	 * Remove any pending tasks.  They cannot be executing because they run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->aue_udev, &sc->aue_tick_task);
	usb_rem_task(sc->aue_udev, &sc->aue_stop_task);

	s = splusb();
d989 1
a990 1
	ether_ifdetach(ifp);
d1011 1
d1013 3
a1015 1
aue_activate(device_ptr_t self, enum devact act)
d1033 1
d1039 4
a1042 1
aue_newbuf(struct aue_softc *sc, struct aue_chain *c, struct mbuf *m)
d1077 2
a1078 1
aue_rx_list_init(struct aue_softc *sc)
d1107 2
a1108 1
aue_tx_list_init(struct aue_softc *sc)
d1136 4
a1139 1
aue_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1176 24
d1205 4
a1208 1
aue_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1216 1
d1218 1
d1267 8
d1277 1
a1277 1
	s = splnet();
d1292 12
a1303 1
	if (ifp->if_bpf)
d1306 2
d1314 1
d1335 4
a1338 1
aue_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1348 1
a1348 1
	s = splnet();
d1372 5
d1380 1
a1380 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1382 1
d1388 2
a1389 1
aue_tick(void *xsc)
d1392 3
a1403 17
	/* Perform periodic stuff in process context. */
	usb_add_task(sc->aue_udev, &sc->aue_tick_task);
}

Static void
aue_tick_task(void *xsc)
{
	struct aue_softc	*sc = xsc;
	struct ifnet		*ifp;
	struct mii_data		*mii;
	int			s;

	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__FUNCTION__));

	if (sc->aue_dying)
		return;

d1409 1
a1409 1
	s = splnet();
d1419 1
a1419 1
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
d1430 4
a1433 1
aue_send(struct aue_softc *sc, struct mbuf *m, int idx)
d1469 1
a1469 2
		/* Stop the interface from process context. */
		usb_add_task(sc->aue_udev, &sc->aue_stop_task);
d1481 2
a1482 1
aue_start(struct ifnet *ifp)
d1499 1
a1499 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1504 1
a1508 2
	IFQ_DEQUEUE(&ifp->if_snd, m_head);

d1527 2
a1528 1
aue_init(void *xsc)
d1544 1
a1544 1
	s = splnet();
d1551 1
a1551 1
#if defined(__OpenBSD__)
d1605 2
a1606 1
aue_openpipes(struct aue_softc *sc)
d1656 2
a1657 1
aue_ifmedia_upd(struct ifnet *ifp)
d1683 3
a1685 1
aue_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
d1698 4
a1701 1
aue_ioctl(struct ifnet *ifp, u_long command, caddr_t data)
d1704 1
d1706 1
d1714 1
a1714 1
	s = splnet();
d1717 7
d1763 1
a1784 11
		error = (command == SIOCADDMULTI) ?
#if defined(__NetBSD__)
			ether_addmulti(ifr, &sc->aue_ec) :
			ether_delmulti(ifr, &sc->aue_ec);
#else
			ether_addmulti(ifr, &sc->arpcom) :
			ether_delmulti(ifr, &sc->arpcom);
#endif
		if (error == ENETRESET) {
			aue_init(sc);
		}
d1804 2
a1805 1
aue_watchdog(struct ifnet *ifp)
a1807 3
	struct aue_chain	*c;
	usbd_status		stat;
	int			s;
d1814 10
a1823 4
	s = splusb();
	c = &sc->aue_cdata.aue_tx_chain[0];
	usbd_get_xfer_status(c->aue_xfer, NULL, NULL, NULL, &stat);
	aue_txeof(c->aue_xfer, c, stat);
d1825 1
a1825 1
	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
a1826 1
	splx(s);
d1834 2
a1835 1
aue_stop(struct aue_softc *sc)
d1922 18
@


1.13.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.13.2.2 2001/07/04 10:43:40 niklas Exp $ */
a178 1
  { USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100,	0 },
d753 3
@


1.13.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_aue.c,v 1.67 2001/10/10 02:14:16 augustss Exp $	*/
d38 2
a39 2
 * ADMtek AN986 Pegasus and AN8511 Pegasus II USB to ethernet driver.
 * Datasheet is available from http://www.admtek.com.tw.
d165 1
a165 4
	u_int16_t		aue_flags;
#define LSYS	0x0001		/* use Linksys reset */
#define PNA	0x0002		/* has Home PNA */
#define PII	0x0004		/* Pegasus II chip */
d169 12
a180 18
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX1,		  PNA|PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX2,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX3,		  0 },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX4,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX5,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX6,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX7,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX8,		  PII },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX9,		  PNA },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX10,	  0 },
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_DSB650TX_PNA,  0 },
  { USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_USB320_EC,	  0 },
  { USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS,	  PNA },
  { USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII,	  PII },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100,	  0 },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBLP100,  PNA },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBEL100,  0 },
  { USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBE100,	  PII },
d182 2
a183 27
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX4,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX1,	  LSYS },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX,	  LSYS },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA,	  PNA },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX3,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX2,	  LSYS|PII },
  { USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX0,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX2,	  0 },
  { USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3,	  PII },
  { USB_VENDOR_ELSA,		USB_PRODUCT_ELSA_USB2ETHERNET,	  0 },
  { USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX,	  0 },
  { USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTXS,	  PII },
  { USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX,    0 },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX1,	  LSYS|PII },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10T,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1,	  LSYS|PNA },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA,	  LSYS },
  { USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX2,	  LSYS|PII },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1, 	  0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5, 	  0 },
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUA2TX5, 	  PII },
  { USB_VENDOR_SMARTBRIDGES,	USB_PRODUCT_SMARTBRIDGES_SMARTNIC,PII },
  { USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB,	  0 },
  { USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100,	  0 },
a188 1
Static void aue_reset_pegasus_II(struct aue_softc *sc);
d509 1
a509 1
	if (sc->aue_flags & LSYS) {
a579 14
aue_reset_pegasus_II(struct aue_softc *sc)
{
	/* Magic constants taken from Linux driver. */
	aue_csr_write_1(sc, AUE_REG_1D, 0);
	aue_csr_write_1(sc, AUE_REG_7B, 2);
#if 0
	if ((sc->aue_flags & HAS_HOME_PNA) && mii_mode)
		aue_csr_write_1(sc, AUE_REG_81, 6);
	else
#endif
		aue_csr_write_1(sc, AUE_REG_81, 2);
}

Static void
a609 8
#if 0
	/* XXX what is mii_mode supposed to be */
	if (sc->aue_mii_mode && (sc->aue_flags & PNA))
		aue_csr_write_1(sc, AUE_GPIO1, 0x34);
	else
		aue_csr_write_1(sc, AUE_GPIO1, 0x26);
#endif

d611 1
a611 1
	if (sc->aue_flags & LSYS) {
a617 3
	if (sc->aue_flags & PII)
		aue_reset_pegasus_II(sc);

d690 1
a690 1
	sc->aue_flags = aue_lookup(uaa->vendor, uaa->product)->aue_flags;
d754 1
a756 2
	IFQ_SET_READY(&ifp->if_snd);

a798 5
	if (!sc->aue_attached) {
		/* Detached before attached finished, so just bail out. */
		return (0);
	}

d809 6
d990 1
a990 1
			    USBDEVNAME(sc->aue_dev), sc->aue_intr_errs,
d1196 1
a1196 1
		mii_pollstat(mii); /* XXX FreeBSD has removed this call */
@


1.13.2.5
log
@Merge in trunk
@
text
@d174 1
a174 1
  { USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000,	  0 },
@


1.13.2.6
log
@Merge in -current from roughly a week ago
@
text
@d1106 1
a1106 1
	memcpy(mtod(c->aue_mbuf, char *), c->aue_buf, total_len);
@


1.13.2.7
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: if_aue.c,v 1.81 2002/09/29 19:55:52 augustss Exp $	*/
d83 1
d85 1
a85 2
#endif

d87 1
a95 1
#if defined(__OpenBSD__)
a96 1
#endif
d120 1
a120 1
#include <netinet/in.h>
d163 2
a164 1
	struct usb_devno	aue_dev;
d172 47
a218 54
 {{ USB_VENDOR_3COM,		USB_PRODUCT_3COM_3C460B},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX1},	  PNA|PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX2},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_UFE1000},	  LSYS },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX4},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX5},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX6},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX7},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX8},	  PII },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX9},	  PNA },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_XX10},	  0 },
 {{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_DSB650TX_PNA}, 0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_USB320_EC},	  0 },
 {{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_SS1001},	  PII },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUS},	  PNA },
 {{ USB_VENDOR_ADMTEK,		USB_PRODUCT_ADMTEK_PEGASUSII},	  PII },
 {{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_USB2LAN},	  PII },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USB100},	  0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBLP100}, PNA },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBEL100}, 0 },
 {{ USB_VENDOR_BILLIONTON,	USB_PRODUCT_BILLIONTON_USBE100},  PII },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TX}, 0 },
 {{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_FETHER_USB_TXS},PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX4},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX1},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX},	  LSYS },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX_PNA},  PNA },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX3},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650TX2},	  LSYS|PII },
 {{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DSB650},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX0},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX2},	  0 },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3},	  PII },
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBLTX},	  PII },
 {{ USB_VENDOR_ELSA,		USB_PRODUCT_ELSA_USB2ETHERNET},	  0 },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTX},	  0 },
 {{ USB_VENDOR_IODATA,		USB_PRODUCT_IODATA_USBETTXS},	  PII },
 {{ USB_VENDOR_KINGSTON,	USB_PRODUCT_KINGSTON_KNU101TX},   0 },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX1},	  LSYS|PII },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10T},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100TX},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB100H1},	  LSYS|PNA },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TA},	  LSYS },
 {{ USB_VENDOR_LINKSYS,		USB_PRODUCT_LINKSYS_USB10TX2},	  LSYS|PII },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX1}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX5}, 	  0 },
 {{ USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUA2TX5}, 	  PII },
 {{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_FA101},	  PII },
 {{ USB_VENDOR_SIEMENS,		USB_PRODUCT_SIEMENS_SPEEDSTREAM}, PII },
 {{ USB_VENDOR_SMARTBRIDGES,	USB_PRODUCT_SMARTBRIDGES_SMARTNIC},PII },
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2202USB},	  0 },
 {{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2206USB},	  PII },
 {{ USB_VENDOR_SOHOWARE,	USB_PRODUCT_SOHOWARE_NUB100},	  0 },
a219 1
#define aue_lookup(v, p) ((struct aue_type *)usb_lookup(aue_devs, v, p))
d224 1
d411 1
a411 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d424 1
a424 2
	sc->aue_refcnt++;
	usb_lockmgr(&sc->aue_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d430 1
a430 3
	usb_lockmgr(&sc->aue_mii_lock, LK_RELEASE, NULL, curproc);
	if (--sc->aue_refcnt < 0)
		usb_detach_wakeup(USBDEV(sc->aue_dev));
a439 7
	if (sc->aue_dying) {
#ifdef DIAGNOSTIC
		printf("%s: dying\n", USBDEVNAME(sc->aue_dev));
#endif
		return 0;
	}

d474 1
a474 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, val));
d495 1
a495 1
		     USBDEVNAME(sc->aue_dev), __func__, phy, reg, data));
d520 1
a520 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d544 1
a544 1
	if (!sc->aue_dying && (sc->aue_flags & LSYS)) {
a548 1
	DPRINTFN(5,("%s: %s: exit\n", USBDEVNAME(sc->aue_dev), __func__));
d554 1
a554 1
Static u_int32_t
d578 1
a578 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d633 1
a633 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
a644 8
#if 0
	/* XXX what is mii_mode supposed to be */
	if (sc->aue_mii_mode && (sc->aue_flags & PNA))
		aue_csr_write_1(sc, AUE_GPIO1, 0x34);
	else
		aue_csr_write_1(sc, AUE_GPIO1, 0x26);
#endif

d654 14
d669 1
a669 2
		/* Grrr. LinkSys has to be different from everyone else. */
		aue_csr_write_1(sc, AUE_GPIO0,
a670 1
	} else {
d672 1
a672 1
		    AUE_GPIO_OUT0 | AUE_GPIO_SEL0);
a673 2
  	aue_csr_write_1(sc, AUE_GPIO0,
	    AUE_GPIO_OUT0 | AUE_GPIO_SEL0 | AUE_GPIO_SEL1);
d682 11
d800 1
a800 1
	printf("%s: address %s\n", USBDEVNAME(sc->aue_dev),
d858 1
a858 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d882 2
a883 1
#endif /* __NetBSD__ */
d886 6
d893 1
a904 5

	if (--sc->aue_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(USBDEV(sc->aue_dev));
	}
d907 1
a907 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->aue_udev,
d918 1
a918 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d941 1
a941 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d971 1
a971 1
Static int
d978 1
a978 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1007 1
a1007 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1035 1
a1035 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1081 1
a1081 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1150 1
a1150 1
		    __func__, m->m_len));
d1165 1
a1165 1
		    __func__));
d1187 1
a1187 1
		    __func__, status));
d1222 1
a1222 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1242 1
a1242 1
	DPRINTFN(15,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1260 1
a1260 1
				    USBDEVNAME(sc->aue_dev),__func__));
d1279 1
a1279 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev),__func__));
d1314 1
a1314 1
		    __func__, total_len));
d1328 1
a1328 1
		    __func__, sc->aue_link));
d1376 1
a1376 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1468 1
a1468 1
	    &sc->aue_cdata.aue_ibuf, AUE_INTR_PKTLEN, aue_intr,
d1485 1
a1485 1
			    __func__));
d1500 1
a1500 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1526 1
a1526 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1645 1
a1645 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
d1671 1
a1671 1
	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __func__));
@


1.13.2.8
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.13.2.7 2003/03/28 00:38:31 niklas Exp $ */
d733 1
a733 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.13.2.9
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_aue.c,v 1.82 2003/03/05 17:37:36 shiba Exp $	*/
d203 1
a203 1
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX1},	  LSYS },
d205 1
a205 1
 {{ USB_VENDOR_ELECOM,		USB_PRODUCT_ELECOM_LDUSBTX3},	  LSYS },
@


1.13.2.10
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d229 1
a229 1
USB_DECLARE_DRIVER_CLASS(aue, DV_IFNET);
@


1.12
log
@for ethernet ifaces attach bpf from ether_ifattach; jason@@, aaron@@, itojun@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.11 2001/01/28 09:43:41 aaron Exp $ */
/*	$NetBSD: if_aue.c,v 1.38 2000/04/04 20:16:19 augustss Exp $	*/
d92 1
d96 1
a98 10
#if defined(__FreeBSD__)

#include <net/ethernet.h>
#include <machine/clock.h>	/* for DELAY */
#include <sys/bus.h>
/* "controller miibus0" required.  See GENERIC if you get errors here. */
#include "miibus_if.h"

#elif defined(__NetBSD__) || defined(__OpenBSD__)

a103 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d105 1
a105 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a110 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a111 3
#else
#define BPF_MTAP(ifp, m) bpf_mtap((ifp), (m))
#endif
d113 1
a113 1
#if defined(__FreeBSD__) || NBPFILTER > 0
a134 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a138 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a147 4
#ifdef __FreeBSD__
#include <dev/usb/usb_ethersubr.h>
#endif

d168 1
a168 1
Static struct aue_type aue_devs[] = {
d188 36
a223 88
Static struct aue_type *aue_lookup __P((u_int16_t, u_int16_t));
Static int aue_tx_list_init	__P((struct aue_softc *));
Static int aue_rx_list_init	__P((struct aue_softc *));
Static int aue_newbuf		__P((struct aue_softc *, struct aue_chain *,
				    struct mbuf *));
Static int aue_send		__P((struct aue_softc *, struct mbuf *, int));
Static void aue_intr		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_rxeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_txeof		__P((usbd_xfer_handle,
				    usbd_private_handle, usbd_status));
Static void aue_tick		__P((void *));
Static void aue_start		__P((struct ifnet *));
Static int aue_ioctl		__P((struct ifnet *, u_long, caddr_t));
Static void aue_init		__P((void *));
Static void aue_stop		__P((struct aue_softc *));
Static void aue_watchdog	__P((struct ifnet *));
#ifdef __FreeBSD__
Static void aue_shutdown	__P((device_ptr_t));
#endif
Static int aue_openpipes	__P((struct aue_softc *));
Static int aue_ifmedia_upd	__P((struct ifnet *));
Static void aue_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

Static int aue_eeprom_getword	__P((struct aue_softc *, int));
Static void aue_read_mac	__P((struct aue_softc *, u_char *));
Static int aue_miibus_readreg	__P((device_ptr_t, int, int));
#if defined(__FreeBSD__)
Static int aue_miibus_writereg	__P((device_ptr_t, int, int, int));
#elif defined(__NetBSD__) || defined(__OpenBSD__)
Static void aue_miibus_writereg	__P((device_ptr_t, int, int, int));
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
Static void aue_miibus_statchg	__P((device_ptr_t));

Static void aue_setmulti	__P((struct aue_softc *));
Static u_int32_t aue_crc	__P((caddr_t));
Static void aue_reset		__P((struct aue_softc *));

Static int aue_csr_read_1	__P((struct aue_softc *, int));
Static int aue_csr_write_1	__P((struct aue_softc *, int, int));
Static int aue_csr_read_2	__P((struct aue_softc *, int));
Static int aue_csr_write_2	__P((struct aue_softc *, int, int));

#if defined(__FreeBSD__)
#if !defined(lint)
static const char rcsid[] =
  "$FreeBSD: src/sys/dev/usb/if_aue.c,v 1.11 2000/01/14 01:36:14 wpaul Exp $";
#endif

Static void aue_rxstart		__P((struct ifnet *));

Static struct usb_qdat aue_qdat;

Static device_method_t aue_methods[] = {
	/* Device interface */
	DEVMETHOD(device_probe,		aue_match),
	DEVMETHOD(device_attach,	aue_attach),
	DEVMETHOD(device_detach,	aue_detach),
	DEVMETHOD(device_shutdown,	aue_shutdown),

	/* bus interface */
	DEVMETHOD(bus_print_child,	bus_generic_print_child),
	DEVMETHOD(bus_driver_added,	bus_generic_driver_added),

	/* MII interface */
	DEVMETHOD(miibus_readreg,	aue_miibus_readreg),
	DEVMETHOD(miibus_writereg,	aue_miibus_writereg),
	DEVMETHOD(miibus_statchg,	aue_miibus_statchg),

	{ 0, 0 }
};

Static driver_t aue_driver = {
	"aue",
	aue_methods,
	sizeof(struct aue_softc)
};

Static devclass_t aue_devclass;

DRIVER_MODULE(if_aue, uhub, aue_driver, aue_devclass, usbd_driver_load, 0);
DRIVER_MODULE(miibus, aue, miibus_driver, miibus_devclass, 0, 0);

#endif /* __FreeBSD__ */

#define AUE_DO_REQUEST(dev, req, data)			\
	usbd_do_request_flags(dev, req, data, USBD_NO_TSLEEP, NULL)
d232 1
a232 3
aue_csr_read_1(sc, reg)
	struct aue_softc	*sc;
	int			reg;
a236 1
	int			s;
d247 1
a247 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d259 1
a259 3
aue_csr_read_2(sc, reg)
	struct aue_softc	*sc;
	int			reg;
a263 1
	int			s;
d274 1
a274 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d286 1
a286 3
aue_csr_write_1(sc, reg, aval)
	struct aue_softc	*sc;
	int			reg, aval;
a289 1
	int			s;
d302 1
a302 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d314 1
a314 3
aue_csr_write_2(sc, reg, aval)
	struct aue_softc	*sc;
	int			reg, aval;
a317 1
	int			s;
d330 1
a330 3
	s = splusb();
	err = AUE_DO_REQUEST(sc->aue_udev, &req, &val);
	splx(s);
d345 1
a345 3
aue_eeprom_getword(sc, addr)
	struct aue_softc	*sc;
	int			addr;
d369 1
a369 3
aue_read_mac(sc, dest)
	struct aue_softc	*sc;
	u_char			*dest;
d384 13
d398 1
a398 3
aue_miibus_readreg(dev, phy, reg)
	device_ptr_t		dev;
	int			phy, reg;
d404 1
d417 1
a417 1
		if (phy != 1)
d420 1
d422 1
d432 1
a432 2
		printf("%s: MII read timed out\n",
		    USBDEVNAME(sc->aue_dev));
d440 1
a443 3
#if defined(__FreeBSD__)
Static int
#elif defined(__NetBSD__) || defined(__OpenBSD__)
d445 1
a445 4
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
aue_miibus_writereg(dev, phy, reg, data)
	device_ptr_t		dev;
	int			phy, reg, data;
d450 1
a453 3
#if defined(__FreeBSD__)
			return (0);
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a454 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d456 1
d461 1
d475 1
a475 4

#if defined(__FreeBSD__)
	return (0);
#endif
d479 1
a479 2
aue_miibus_statchg(dev)
	device_ptr_t		dev;
d486 1
d501 1
d519 1
a519 2
aue_crc(addr)
	caddr_t			addr;
d535 1
a535 2
aue_setmulti(sc)
	struct aue_softc	*sc;
a537 3
#if defined(__FreeBSD__)
	struct ifmultiaddr	*ifma;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a539 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d546 3
a548 1
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
a559 9
#if defined(__FreeBSD__)
	for (ifma = ifp->if_multiaddrs.lh_first; ifma != NULL;
	    ifma = ifma->ifma_link.le_next) {
		if (ifma->ifma_addr->sa_family != AF_LINK)
			continue;
		h = aue_crc(LLADDR((struct sockaddr_dl *)ifma->ifma_addr));
		AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0x7));
	}
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a565 1
#if 1
d567 3
a569 6
			   enm->enm_addrhi, ETHER_ADDR_LEN) != 0) {
			ifp->if_flags |= IFF_ALLMULTI;
			AUE_SETBIT(sc, AUE_CTL0, AUE_CTL0_ALLMULTI);
			return;
		}
#endif
d574 2
a575 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d579 1
a579 2
aue_reset(sc)
	struct aue_softc	*sc;
d621 2
a622 3
Static struct aue_type *
aue_lookup(vendor, product)
	u_int16_t vendor, product;
d624 1
a624 1
	struct aue_type	*t;
a664 4
#ifdef __FreeBSD__
	bzero(sc, sizeof(struct aue_softc));
#endif

d671 1
a671 1
	err = usbd_set_config_no(dev, AUE_CONFIG_NO, 0);
d678 4
d725 1
a725 1
	s = splimp();
a738 52
#if defined(__FreeBSD__)
	printf("%s: Ethernet address: %6D\n", USBDEVNAME(sc->aue_dev),
	    eaddr, ":");

	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);

	ifp->if_softc = sc;
	ifp->if_unit = sc->aue_unit;
	ifp->if_name = "aue";
	ifp->if_mtu = ETHERMTU;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = aue_ioctl;
	ifp->if_output = ether_output;
	ifp->if_start = aue_start;
	ifp->if_watchdog = aue_watchdog;
	ifp->if_init = aue_init;
	ifp->if_snd.ifq_maxlen = IFQ_MAXLEN;

	/*
	 * Do MII setup.
	 * NOTE: Doing this causes child devices to be attached to us,
	 * which we would normally disconnect at in the detach routine
	 * using device_delete_child(). However the USB code is set up
	 * such that when this driver is removed, all childred devices
	 * are removed as well. In effect, the USB code ends up detaching
	 * all of our children for us, so we don't have to do is ourselves
	 * in aue_detach(). It's important to point this out since if
	 * we *do* try to detach the child devices ourselves, we will
	 * end up getting the children deleted twice, which will crash
	 * the system.
	 */
	if (mii_phy_probe(self, &sc->aue_miibus,
	    aue_ifmedia_upd, aue_ifmedia_sts)) {
		printf("%s: MII without any PHY!\n", USBDEVNAME(sc->aue_dev));
		splx(s);
		USB_ATTACH_ERROR_RETURN;
	}

	aue_qdat.ifp = ifp;
	aue_qdat.if_rxstart = aue_rxstart;

	/*
	 * Call MI attach routines.
	 */
	if_attach(ifp);
	ether_ifattach(ifp);
	bpfattach(ifp, DLT_EN10MB, sizeof(struct ether_header));

	usb_register_netisr();

#elif defined(__NetBSD__) || defined(__OpenBSD__)

d764 1
a775 1

a780 2
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */

d800 8
a809 2
	usb_uncallout(sc->aue_stat_ch, aue_tick, sc);

d832 1
a833 1
#endif /* __NetBSD__ */
a853 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d855 1
a855 3
aue_activate(self, act)
	device_ptr_t self;
	enum devact act;
a872 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d878 1
a878 4
aue_newbuf(sc, c, m)
	struct aue_softc	*sc;
	struct aue_chain	*c;
	struct mbuf		*m;
d913 1
a913 2
aue_rx_list_init(sc)
	struct aue_softc	*sc;
d942 1
a942 2
aue_tx_list_init(sc)
	struct aue_softc	*sc;
d970 1
a970 4
aue_intr(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a1006 24
#if defined(__FreeBSD__)
Static void
aue_rxstart(ifp)
	struct ifnet		*ifp;
{
	struct aue_softc	*sc;
	struct aue_chain	*c;

	sc = ifp->if_softc;
	c = &sc->aue_cdata.aue_rx_chain[sc->aue_cdata.aue_rx_prod];

	if (aue_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		return;
	}

	/* Setup new transfer. */
	usbd_setup_xfer(c->aue_xfer, sc->aue_ep[AUE_ENDPT_RX],
	    c, mtod(c->aue_mbuf, char *), AUE_BUFSZ, USBD_SHORT_XFER_OK,
	    USBD_NO_TIMEOUT, aue_rxeof);
	usbd_transfer(c->aue_xfer);
}
#endif

d1012 1
a1012 4
aue_rxeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
a1019 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1020 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
a1068 8
#if defined(__FreeBSD__)
	m->m_pkthdr.rcvif = (struct ifnet *)&kue_qdat;
	/* Put the packet on the special USB input queue. */
	usb_ether_input(m);

	return;

#elif defined(__NetBSD__) || defined(__OpenBSD__)
d1071 1
a1071 1
	s = splimp();
d1086 1
a1086 12
	if (ifp->if_bpf) {
#if defined(__NetBSD__)
		struct ether_header *eh = mtod(m, struct ether_header *);
		BPF_MTAP(ifp, m);
		if ((ifp->if_flags & IFF_PROMISC) &&
		    memcmp(eh->ether_dhost, LLADDR(ifp->if_sadl),
			   ETHER_ADDR_LEN) &&
		    !(eh->ether_dhost[0] & 1)) {
			m_freem(m);
			goto done1;
		}
#else
a1088 2
	}
#endif
a1094 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1115 1
a1115 4
aue_txeof(xfer, priv, status)
	usbd_xfer_handle	xfer;
	usbd_private_handle	priv;
	usbd_status		status;
d1125 1
a1125 1
	s = splimp();
a1148 5
#if defined(__FreeBSD__)
	c->aue_mbuf->m_pkthdr.rcvif = ifp;
	usb_tx_done(c->aue_mbuf);
  	c->aue_mbuf = NULL;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1153 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1159 18
a1176 2
aue_tick(xsc)
	void			*xsc;
a1184 3
	if (sc == NULL)
		return;

d1193 1
a1193 1
	s = splimp();
d1214 1
a1214 4
aue_send(sc, m, idx)
	struct aue_softc	*sc;
	struct mbuf		*m;
	int			idx;
d1250 2
a1251 1
		aue_stop(sc);
d1263 1
a1263 2
aue_start(ifp)
	struct ifnet		*ifp;
d1308 1
a1308 2
aue_init(xsc)
	void			*xsc;
d1324 1
a1324 1
	s = splimp();
d1331 1
a1331 1
#if defined(__FreeBSD__) || defined(__OpenBSD__)
d1385 1
a1385 2
aue_openpipes(sc)
	struct aue_softc	*sc;
d1435 1
a1435 2
aue_ifmedia_upd(ifp)
	struct ifnet		*ifp;
d1461 1
a1461 3
aue_ifmedia_sts(ifp, ifmr)
	struct ifnet		*ifp;
	struct ifmediareq	*ifmr;
d1474 1
a1474 4
aue_ioctl(ifp, command, data)
	struct ifnet		*ifp;
	u_long			command;
	caddr_t			data;
a1476 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a1477 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1485 1
a1485 1
	s = splimp();
a1487 7
#if defined(__FreeBSD__)
	case SIOCSIFADDR:
	case SIOCGIFADDR:
	case SIOCSIFMTU:
		error = ether_ioctl(ifp, command, data);
		break;
#elif defined(__NetBSD__) || defined(__OpenBSD__)
a1526 1
#endif /* defined(__NetBSD__) || defined(__OpenBSD__) */
d1548 11
d1578 1
a1578 2
aue_watchdog(ifp)
	struct ifnet		*ifp;
d1581 3
d1590 4
a1593 10
	/*
	 * The polling business is a kludge to avoid allowing the
	 * USB code to call tsleep() in usbd_delay_ms(), which will
	 * kill us since the watchdog routine is invoked from
	 * interrupt context.
	 */
	usbd_set_polling(sc->aue_udev, 1);
	aue_stop(sc);
	aue_init(sc);
	usbd_set_polling(sc->aue_udev, 0);
d1597 1
d1605 1
a1605 2
aue_stop(sc)
	struct aue_softc	*sc;
a1691 18

#ifdef __FreeBSD__
/*
 * Stop all chip I/O so that the kernel's probe routines don't
 * get confused by errant DMAs when rebooting.
 */
Static void
aue_shutdown(dev)
	device_ptr_t		dev;
{
	struct aue_softc	*sc = USBGETSOFTC(dev);

	DPRINTFN(5,("%s: %s: enter\n", USBDEVNAME(sc->aue_dev), __FUNCTION__));

	aue_reset(sc);
	aue_stop(sc);
}
#endif
@


1.11
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.10 2000/11/07 21:03:01 aaron Exp $ */
a936 4
#if NBPFILTER > 0
	bpfattach(&ifp->if_bpf, ifp, DLT_EN10MB,
		  sizeof(struct ether_header));
#endif
@


1.10
log
@Fix multicast filter programming; from FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.9 2000/10/13 04:42:10 aaron Exp $ */
d190 2
a191 1
  { USB_VENDOR_MELCO, 		USB_PRODUCT_MELCO_LUATX, 	0 },
@


1.9
log
@Support Kingston KNU101TX USB Ethernet; from NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.8 2000/09/17 00:48:30 aaron Exp $ */
d660 1
a660 1
		AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));
d678 1
a678 1
		AUE_SETBIT(sc, AUE_MAR + (h >> 3), 1 << (h & 0xF));
@


1.8
log
@Match the new D-Link DSB-650 product ID.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.7 2000/08/26 20:08:39 nate Exp $ */
d201 1
@


1.7
log
@Add support for detach of xe and aue.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.6 2000/07/04 11:44:21 fgsch Exp $ */
d195 1
@


1.6
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.5 2000/04/23 17:33:47 maja Exp $ */
d981 2
d985 2
@


1.5
log
@Save ethernet address in arpcom.ac_enaddr. -moj
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.4 2000/04/14 22:50:24 aaron Exp $ */
d182 6
d189 12
a200 10
	{ USB_VENDOR_BILLIONTON, USB_PRODUCT_BILLIONTON_USB100 },
	{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_LUATX },
	{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_USB100TX },
	{ USB_VENDOR_ADMTEK, USB_PRODUCT_ADMTEK_PEGASUS },
	{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DSB650TX },
	{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DSB650TX_PNA },
	{ USB_VENDOR_SMC, USB_PRODUCT_SMC_2202USB },
	{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_FETHER_USB_TX },
	{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBETTX },
	{ 0, 0 }
d205 1
d596 2
a597 5
	if ((sc->aue_vendor == USB_VENDOR_LINKSYS &&
	     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||
	    (sc->aue_vendor == USB_VENDOR_DLINK &&
	     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {
		u_int16_t               auxmode;
d715 1
a715 4
	if ((sc->aue_vendor == USB_VENDOR_LINKSYS &&
	     sc->aue_product == USB_PRODUCT_LINKSYS_USB100TX) ||
	    (sc->aue_vendor == USB_VENDOR_DLINK &&
	     sc->aue_product == USB_PRODUCT_DLINK_DSB650TX)) {
d726 12
a743 1
	struct aue_type			*t;
d748 2
a749 5
	for (t = aue_devs; t->aue_vid != 0; t++)
		if (uaa->vendor == t->aue_vid && uaa->product == t->aue_did)
			return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
d795 2
d1617 1
a1617 1
	usbd_open_pipe(sc->aue_iface, sc->aue_ed[AUE_ENDPT_TX],
@


1.4
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_aue.c,v 1.3 2000/04/04 22:52:29 aaron Exp $ */
d886 4
@


1.3
log
@Sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.2 2000/03/30 16:19:32 aaron Exp $ */
/*	$NetBSD: if_aue.c,v 1.37 2000/04/02 21:25:41 augustss Exp $	*/
d1137 7
a1143 2
		printf("%s: usb error on intr: %s\n", USBDEVNAME(sc->aue_dev),
		    usbd_errstr(status));
a1182 9
 *
 * Grrr. Receiving transfers larger than about 1152 bytes sometimes
 * doesn't work. We get an incomplete frame. In order to avoid
 * this, we queue up RX transfers that are shorter than a full sized
 * frame. If the received frame is larger than our transfer size,
 * we snag the rest of the data using a second transfer. Does this
 * hurt performance? Yes. But after fighting with this stupid thing
 * for three days, I'm willing to settle. I'd rather have reliable
 * receive performance that fast but spotty performance.
@


1.2
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: if_aue.c,v 1.1 2000/03/28 19:37:47 aaron Exp $ */
/*	$NetBSD: if_aue.c,v 1.36 2000/03/30 00:18:17 augustss Exp $	*/
d1451 2
@


1.1
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: if_aue.c,v 1.33 2000/03/24 22:03:28 augustss Exp $	*/
d87 1
a87 1
#endif
d182 1
a182 1
static struct aue_type aue_devs[] = {
d197 3
a199 3
static int aue_tx_list_init	__P((struct aue_softc *));
static int aue_rx_list_init	__P((struct aue_softc *));
static int aue_newbuf		__P((struct aue_softc *, struct aue_chain *,
d201 2
a202 2
static int aue_send		__P((struct aue_softc *, struct mbuf *, int));
static void aue_intr		__P((usbd_xfer_handle,
d204 1
a204 1
static void aue_rxeof		__P((usbd_xfer_handle,
d206 1
a206 1
static void aue_txeof		__P((usbd_xfer_handle,
d208 6
a213 6
static void aue_tick		__P((void *));
static void aue_start		__P((struct ifnet *));
static int aue_ioctl		__P((struct ifnet *, u_long, caddr_t));
static void aue_init		__P((void *));
static void aue_stop		__P((struct aue_softc *));
static void aue_watchdog	__P((struct ifnet *));
d215 1
a215 1
static void aue_shutdown	__P((device_ptr_t));
d217 7
a223 7
static int aue_openpipes	__P((struct aue_softc *));
static int aue_ifmedia_upd	__P((struct ifnet *));
static void aue_ifmedia_sts	__P((struct ifnet *, struct ifmediareq *));

static int aue_eeprom_getword	__P((struct aue_softc *, int));
static void aue_read_mac	__P((struct aue_softc *, u_char *));
static int aue_miibus_readreg	__P((device_ptr_t, int, int));
d225 1
a225 1
static int aue_miibus_writereg	__P((device_ptr_t, int, int, int));
d227 1
a227 1
static void aue_miibus_writereg	__P((device_ptr_t, int, int, int));
d229 1
a229 1
static void aue_miibus_statchg	__P((device_ptr_t));
d231 8
a238 8
static void aue_setmulti	__P((struct aue_softc *));
static u_int32_t aue_crc	__P((caddr_t));
static void aue_reset		__P((struct aue_softc *));

static int aue_csr_read_1	__P((struct aue_softc *, int));
static int aue_csr_write_1	__P((struct aue_softc *, int, int));
static int aue_csr_read_2	__P((struct aue_softc *, int));
static int aue_csr_write_2	__P((struct aue_softc *, int, int));
d246 1
a246 1
static void aue_rxstart		__P((struct ifnet *));
d248 1
a248 1
static struct usb_qdat aue_qdat;
d250 1
a250 1
static device_method_t aue_methods[] = {
d269 1
a269 1
static driver_t aue_driver = {
d275 1
a275 1
static devclass_t aue_devclass;
d291 1
a291 1
static int
d323 1
a323 1
static int
d355 1
a355 1
static int
d388 1
a388 1
static int
d424 1
a424 1
static int
d450 1
a450 1
static void
d468 1
a468 1
static int
d515 1
a515 1
static int
d517 1
a517 1
static void
d558 1
a558 1
static void
d600 1
a600 1
static u_int32_t 
d617 1
a617 1
static void
d676 1
a676 1
static void
d831 1
a837 1
	ifp = &sc->arpcom.ac_if;
a887 1
	ifp = GET_IFP(sc);
d894 3
a905 1
#if defined(__NetBSD__)
a906 3
#else
	mii_phy_probe(self, mii, 0xffffffff);
#endif
d915 1
a915 5
#if defined (__NetBSD__)
	ether_ifattach(ifp, eaddr);
#else
	ether_ifattach(ifp);
#endif
a1006 1
#if defined(__NetBSD__)
a1007 1
#endif
d1018 1
a1018 1
static int
d1056 1
a1056 1
static int 
d1086 1
a1086 1
static int
d1115 1
a1115 1
static void
d1152 1
a1152 1
static void
d1188 1
a1188 1
static void
a1201 1
	struct ether_header	*eh;
a1268 2
	eh = mtod(m, struct ether_header *);

d1277 2
a1279 1
#if defined(__NetBSD__)
d1287 2
d1295 1
a1295 5
#if defined(__NetBSD__)
	(*ifp->if_input)(ifp, m);
#else
	ether_input(ifp, eh, m);
#endif
d1318 1
a1318 1
static void
d1371 1
a1371 1
static void
d1413 1
a1413 1
static int
d1462 1
a1462 1
static void
d1508 1
a1508 1
static void
d1586 1
a1586 1
static int
d1637 1
a1637 1
static int
d1664 1
a1664 1
static void
d1679 1
a1679 1
static int
d1785 1
a1785 1
static void
d1815 1
a1815 1
static void
d1910 1
a1910 1
static void
@

