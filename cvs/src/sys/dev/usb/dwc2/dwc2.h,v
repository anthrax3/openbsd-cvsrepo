head	1.14;
access;
symbols
	OPENBSD_6_2_BASE:1.14
	OPENBSD_6_1:1.14.0.4
	OPENBSD_6_1_BASE:1.14
	OPENBSD_6_0:1.13.0.8
	OPENBSD_6_0_BASE:1.13
	OPENBSD_5_9:1.13.0.2
	OPENBSD_5_9_BASE:1.13
	OPENBSD_5_8:1.13.0.4
	OPENBSD_5_8_BASE:1.13
	OPENBSD_5_7:1.11.0.2
	OPENBSD_5_7_BASE:1.11
	NETBSD_20150201:1.1.1.2
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.14
date	2017.02.15.14.49.13;	author visa;	state Exp;
branches;
next	1.13;
commitid	zQJB30C5GyalWiKF;

1.13
date	2015.06.28.11.48.18;	author jmatthew;	state Exp;
branches;
next	1.12;
commitid	iLp75a18m8TiTCQC;

1.12
date	2015.06.08.08.47.38;	author jmatthew;	state Exp;
branches;
next	1.11;
commitid	WHgR4Wq5cbFpwsa4;

1.11
date	2015.02.12.07.51.51;	author uebayasi;	state Exp;
branches;
next	1.10;
commitid	fg3wGYDRaxIxRvlX;

1.10
date	2015.02.12.06.46.23;	author uebayasi;	state Exp;
branches;
next	1.9;
commitid	sC0cDzP6o4CducN8;

1.9
date	2015.02.11.01.26.52;	author uebayasi;	state Exp;
branches;
next	1.8;
commitid	BFDGFmBS7bGS8O96;

1.8
date	2015.02.10.23.38.13;	author uebayasi;	state Exp;
branches;
next	1.7;
commitid	wDM5JZ7hVG9y06Xd;

1.7
date	2015.02.10.23.10.21;	author uebayasi;	state Exp;
branches;
next	1.6;
commitid	ZPfYvaSag55ForeS;

1.6
date	2015.02.10.14.34.14;	author uebayasi;	state Exp;
branches;
next	1.5;
commitid	aeO9IOZz4TR97GDq;

1.5
date	2015.02.10.14.15.14;	author uebayasi;	state Exp;
branches;
next	1.4;
commitid	PcNdF1apgXAKIBJI;

1.4
date	2015.02.10.13.49.48;	author uebayasi;	state Exp;
branches;
next	1.3;
commitid	1OLk1XAIxZV0U2BX;

1.3
date	2015.02.10.13.19.07;	author uebayasi;	state Exp;
branches;
next	1.2;
commitid	DX6qjlYA6iq1pLPL;

1.2
date	2015.02.10.12.58.47;	author uebayasi;	state Exp;
branches;
next	1.1;
commitid	fO2y2txhcaZJkDvb;

1.1
date	2015.02.10.05.00.27;	author uebayasi;	state Exp;
branches
	1.1.1.1;
next	;
commitid	fozgu6iqsHzTcMiM;

1.1.1.1
date	2015.02.10.05.00.27;	author uebayasi;	state Exp;
branches;
next	1.1.1.2;
commitid	fozgu6iqsHzTcMiM;

1.1.1.2
date	2015.02.10.05.10.13;	author uebayasi;	state Exp;
branches;
next	;
commitid	LFuM1eFaklW8eMEs;


desc
@@


1.14
log
@Align mutex IPL with the interrupt handler's priority.

Spotted by stsp@@; OK jmatthew@@
@
text
@/*	$OpenBSD: dwc2.h,v 1.13 2015/06/28 11:48:18 jmatthew Exp $	*/
/*	$NetBSD: dwc2.h,v 1.4 2014/12/23 16:20:06 macallan Exp $	*/

/*-
 * Copyright (c) 2013 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Nick Hudson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _EXTERNAL_BSD_DWC2_DWC2_H_
#define _EXTERNAL_BSD_DWC2_DWC2_H_

#include <sys/param.h>
#include <sys/kernel.h>

#include <sys/task.h>
#include <sys/timeout.h>

#include <lib/libkern/libkern.h>

#if 0
#include "opt_usb.h"
#endif

#define	STATIC_INLINE		static inline
#define	STATIC

// #define VERBOSE_DEBUG
// #define DWC2_DUMP_FRREM
// #define CONFIG_USB_DWC2_TRACK_MISSED_SOFS

typedef int irqreturn_t;
#define	IRQ_NONE 0
#define IRQ_HANDLED 1

#define	u8	uint8_t
#define	u16	uint16_t
#define	s16	int16_t
#define	u32	uint32_t
#define	u64	uint64_t

#define	dma_addr_t	bus_addr_t

#ifdef DWC2_DEBUG
extern int dwc2debug;
#define WARN_ON(x)	KASSERT(!(x))

#define	dev_info(d,fmt,...) do {			\
	printf("%s: " fmt, device_xname(d), 		\
	    ## __VA_ARGS__);				\
} while (0)
#define	dev_warn(d,fmt,...) do {			\
	printf("%s: " fmt, device_xname(d), 		\
	    ## __VA_ARGS__);				\
} while (0)
#define	dev_err(d,fmt,...) do {				\
	printf("%s: " fmt, device_xname(d), 		\
	    ## __VA_ARGS__);				\
} while (0)
#define	dev_dbg(d,fmt,...) do {				\
	if (dwc2debug >= 1) {				\
	    printf("%s: " fmt, device_xname(d), 	\
		    ## __VA_ARGS__);			\
	}						\
} while (0)
#define	dev_vdbg(d,fmt,...) do {			\
	if (dwc2debug >= 2) {				\
	    printf("%s: " fmt, device_xname(d), 	\
		    ## __VA_ARGS__);			\
	}						\
} while (0)
#else
#define WARN_ON(x)
#define	dev_info(...) do { } while (0)
#define	dev_warn(...) do { } while (0)
#define	dev_err(...) do { } while (0)
#define	dev_dbg(...) do { } while (0)
#define	dev_vdbg(...) do { } while (0)
#endif

#define jiffies			hardclock_ticks
#define msecs_to_jiffies	mstohz

#define gfp_t		int
#define GFP_KERNEL	 M_WAITOK
#define GFP_ATOMIC	 M_NOWAIT

enum usb_otg_state {
	OTG_STATE_RESERVED = 0,

	OTG_STATE_A_HOST,
	OTG_STATE_A_PERIPHERAL,
	OTG_STATE_A_SUSPEND,
	OTG_STATE_B_HOST,
	OTG_STATE_B_PERIPHERAL,
};

#define usleep_range(l, u)	do { DELAY(u); } while (0)

#define spinlock_t		struct mutex
#define spin_lock_init(lock)	mtx_init(lock, IPL_USB)
#define	spin_lock(l)		do { mtx_enter(l); } while (0)
#define	spin_unlock(l)		do { mtx_leave(l); } while (0)

#define	spin_lock_irqsave(l, f)		\
	do { mtx_enter(l); (void)(f); } while (0)

#define	spin_unlock_irqrestore(l, f)	\
	do { mtx_leave(l); (void)(f); } while (0)

#define	IRQ_RETVAL(r)	(r)

#define	USB_ENDPOINT_XFER_CONTROL	UE_CONTROL		/* 0 */
#define	USB_ENDPOINT_XFER_ISOC		UE_ISOCHRONOUS		/* 1 */
#define	USB_ENDPOINT_XFER_BULK		UE_BULK			/* 2 */
#define	USB_ENDPOINT_XFER_INT		UE_INTERRUPT		/* 3 */

#define USB_DIR_IN			UE_DIR_IN
#define USB_DIR_OUT			UE_DIR_OUT

#define	USB_PORT_FEAT_CONNECTION	UHF_PORT_CONNECTION
#define	USB_PORT_FEAT_ENABLE		UHF_PORT_ENABLE
#define	USB_PORT_FEAT_SUSPEND		UHF_PORT_SUSPEND
#define	USB_PORT_FEAT_OVER_CURRENT	UHF_PORT_OVER_CURRENT
#define	USB_PORT_FEAT_RESET		UHF_PORT_RESET
// #define	USB_PORT_FEAT_L1		5	/* L1 suspend */
#define	USB_PORT_FEAT_POWER		UHF_PORT_POWER
#define	USB_PORT_FEAT_LOWSPEED		UHF_PORT_LOW_SPEED
#define	USB_PORT_FEAT_C_CONNECTION	UHF_C_PORT_CONNECTION
#define	USB_PORT_FEAT_C_ENABLE		UHF_C_PORT_ENABLE
#define	USB_PORT_FEAT_C_SUSPEND		UHF_C_PORT_SUSPEND
#define	USB_PORT_FEAT_C_OVER_CURRENT	UHF_C_PORT_OVER_CURRENT
#define	USB_PORT_FEAT_C_RESET		UHF_C_PORT_RESET
#define	USB_PORT_FEAT_TEST              UHF_PORT_TEST
#define	USB_PORT_FEAT_INDICATOR         UHF_PORT_INDICATOR
#define	USB_PORT_FEAT_C_PORT_L1         UHF_C_PORT_L1

#define	C_HUB_LOCAL_POWER		UHF_C_HUB_LOCAL_POWER
#define	C_HUB_OVER_CURRENT		UHF_C_HUB_OVER_CURRENT

#define USB_REQ_GET_STATUS		UR_GET_STATUS
#define USB_REQ_CLEAR_FEATURE		UR_CLEAR_FEATURE
#define USB_REQ_SET_FEATURE		UR_SET_FEATURE
#define USB_REQ_GET_DESCRIPTOR		UR_GET_DESCRIPTOR

#define	ClearHubFeature		((UT_WRITE_CLASS_DEVICE << 8) | USB_REQ_CLEAR_FEATURE)
#define	ClearPortFeature	((UT_WRITE_CLASS_OTHER << 8) | USB_REQ_CLEAR_FEATURE)
#define	GetHubDescriptor	((UT_READ_CLASS_DEVICE << 8) | USB_REQ_GET_DESCRIPTOR)
#define	GetHubStatus		((UT_READ_CLASS_DEVICE << 8) | USB_REQ_GET_STATUS)
#define	GetPortStatus		((UT_READ_CLASS_OTHER << 8) | USB_REQ_GET_STATUS)
#define	SetHubFeature		((UT_WRITE_CLASS_DEVICE << 8) | USB_REQ_SET_FEATURE)
#define	SetPortFeature		((UT_WRITE_CLASS_OTHER << 8) | USB_REQ_SET_FEATURE)

#define	USB_PORT_STAT_CONNECTION	UPS_CURRENT_CONNECT_STATUS
#define	USB_PORT_STAT_ENABLE		UPS_PORT_ENABLED
#define	USB_PORT_STAT_SUSPEND		UPS_SUSPEND
#define	USB_PORT_STAT_OVERCURRENT	UPS_OVERCURRENT_INDICATOR
#define	USB_PORT_STAT_RESET		UPS_RESET
#define	USB_PORT_STAT_L1		UPS_PORT_L1
#define	USB_PORT_STAT_POWER		UPS_PORT_POWER
#define	USB_PORT_STAT_LOW_SPEED		UPS_LOW_SPEED
#define	USB_PORT_STAT_HIGH_SPEED        UPS_HIGH_SPEED
#define	USB_PORT_STAT_TEST              UPS_PORT_TEST
#define	USB_PORT_STAT_INDICATOR         UPS_PORT_INDICATOR

#define	USB_PORT_STAT_C_CONNECTION	UPS_C_CONNECT_STATUS
#define	USB_PORT_STAT_C_ENABLE		UPS_C_PORT_ENABLED
#define	USB_PORT_STAT_C_SUSPEND		UPS_C_SUSPEND
#define	USB_PORT_STAT_C_OVERCURRENT	UPS_C_OVERCURRENT_INDICATOR
#define	USB_PORT_STAT_C_RESET		UPS_C_PORT_RESET
#define	USB_PORT_STAT_C_L1		UPS_C_PORT_L1

STATIC_INLINE void
udelay(unsigned long usecs)
{
	DELAY(usecs);
}

#define	EREMOTEIO	EIO
#define	ECOMM		EIO

#define NS_TO_US(ns)	((ns + 500L) / 1000L)

void dw_timeout(void *);
void dwc2_worker(struct task *, void *);

struct delayed_work {
	struct task work;
	struct timeout dw_timer;

	struct taskq *dw_wq;
	void (*dw_fn)(void *);
	void *dw_arg;
};

STATIC_INLINE void
INIT_DELAYED_WORK(struct delayed_work *dw, void (*fn)(void *), void *arg)
{
	dw->dw_fn = fn;
	dw->dw_arg = arg;
	timeout_set(&dw->dw_timer, dw_timeout, dw);
}

STATIC_INLINE void
queue_delayed_work(struct taskq *wq, struct delayed_work *dw, int j)
{
	dw->dw_wq = wq;
	timeout_add(&dw->dw_timer, j);
}

#endif
@


1.13
log
@Convert list_head lists into TAILQs and LISTs and fix up header includes
so we can build dwc2 without extra stuff.

tested by several edgerouter lite owners, ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.h,v 1.12 2015/06/08 08:47:38 jmatthew Exp $	*/
d124 1
a124 1
#define spin_lock_init(lock)	mtx_init(lock, IPL_SCHED)
@


1.12
log
@rearrange delayed_work to avoid the use of container_of while leaving it in
more or less the same shape.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.h,v 1.11 2015/02/12 07:51:51 uebayasi Exp $	*/
d42 1
a42 1
#include <dev/usb/dwc2/linux/list.h>
@


1.11
log
@Move register accessor macros to saner place.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d216 1
d220 1
a220 1
INIT_DELAYED_WORK(struct delayed_work *dw, void (*fn)(struct task *))
d222 2
a223 1
	dw->dw_fn = (void (*)(void *))fn;
d230 1
@


1.10
log
@De-static for backtracing, but using #define to not change indent (for now).
@
text
@a66 5
#define DWC2_READ_4(hsotg, reg) \
    bus_space_read_4((hsotg)->hsotg_sc->sc_iot, (hsotg)->hsotg_sc->sc_ioh, (reg))
#define DWC2_WRITE_4(hsotg, reg, data)  \
    bus_space_write_4((hsotg)->hsotg_sc->sc_iot, (hsotg)->hsotg_sc->sc_ioh, (reg), (data));

@


1.9
log
@Catch up with the new taskq_create(9) API.
@
text
@d47 4
d201 1
a201 1
static inline void
d223 1
a223 1
static inline void
d230 1
a230 1
static inline void
@


1.8
log
@Adjust various kernel API differences.
@
text
@d216 1
a216 1
	void (*dw_fn)(struct task *);
d222 1
a222 1
	dw->dw_fn = fn;
@


1.7
log
@Convert timeout(9)/taskq(9) usages.
@
text
@d110 1
a110 1
#define GFP_ATOMIC	 KM_NOSLEEP
d125 1
a125 1
#define spin_lock_init(lock)	mtx_init(lock, MUTEX_DEFAULT, IPL_SCHED)
@


1.6
log
@Convert malloc(9)/free(9) usages.
@
text
@d216 1
d222 2
a223 1
	timeout_init(&dw->dw_timer, CALLOUT_MPSAFE);
d229 1
a229 1
	timeout_reset(&dw->dw_timer, j, dw_timeout, dw);
@


1.5
log
@s/device_t/struct device */
@
text
@d109 1
a109 1
#define GFP_KERNEL	 KM_SLEEP
@


1.4
log
@s/mutex/mtx/
s/pool_cache/pool/
s/callout/timeout/
s/kmem/malloc/
s/workqueue/taskq/
s/softint/softintr/
@
text
@d208 1
a208 1
void dw_callout(void *);
d213 1
a213 1
	struct callout dw_timer;
d227 1
a227 1
	timeout_reset(&dw->dw_timer, j, dw_callout, dw);
@


1.3
log
@Convert header paths.
@
text
@d124 4
a127 4
#define spinlock_t		kmutex_t
#define spin_lock_init(lock)	mutex_init(lock, MUTEX_DEFAULT, IPL_SCHED)
#define	spin_lock(l)		do { mutex_spin_enter(l); } while (0)
#define	spin_unlock(l)		do { mutex_spin_exit(l); } while (0)
d130 1
a130 1
	do { mutex_spin_enter(l); (void)(f); } while (0)
d133 1
a133 1
	do { mutex_spin_exit(l); (void)(f); } while (0)
d209 1
a209 1
void dwc2_worker(struct work *, void *);
d212 1
a212 1
	struct work work;
d215 1
a215 1
	struct workqueue *dw_wq;
d219 1
a219 1
INIT_DELAYED_WORK(struct delayed_work *dw, void (*fn)(struct work *))
d221 1
a221 1
	callout_init(&dw->dw_timer, CALLOUT_MPSAFE);
d225 1
a225 1
queue_delayed_work(struct workqueue *wq, struct delayed_work *dw, int j)
d227 1
a227 1
	callout_reset(&dw->dw_timer, j, dw_callout, dw);
@


1.2
log
@Add RCS IDs.
@
text
@d39 2
a40 2
#include <sys/workqueue.h>
#include <sys/callout.h>
d42 1
a42 1
#include <linux/list.h>
d44 1
d46 1
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD$	*/
@


1.1.1.1
log
@Import dwc2 core and glue code from NetBSD.  OK deraadt@@ jsing@@ miod@@ mpi@@
@
text
@@


1.1.1.2
log
@Redo dwc2 import with CVS tags expanded.
@
text
@d1 1
a1 1
/*	$NetBSD: dwc2.h,v 1.4 2014/12/23 16:20:06 macallan Exp $	*/
@

