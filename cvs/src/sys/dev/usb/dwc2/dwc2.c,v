head	1.46;
access;
symbols
	OPENBSD_6_2:1.46.0.4
	OPENBSD_6_2_BASE:1.46
	OPENBSD_6_1:1.43.0.4
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.36.0.6
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.36.0.2
	OPENBSD_5_9_BASE:1.36
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.22.0.2
	OPENBSD_5_7_BASE:1.22
	NETBSD_20150201:1.1.1.2
	NETBSD:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2017.06.29.17.36.16;	author deraadt;	state Exp;
branches;
next	1.45;
commitid	5ZXnhHEGi66VYL0B;

1.45
date	2017.05.15.10.52.08;	author mpi;	state Exp;
branches;
next	1.44;
commitid	cyblrmsSmLeFugC0;

1.44
date	2017.04.30.16.45.46;	author mpi;	state Exp;
branches;
next	1.43;
commitid	2Gtqjzrin9LL2yHk;

1.43
date	2017.03.10.11.18.48;	author mpi;	state Exp;
branches;
next	1.42;
commitid	KVR8Na3SYXI1y1RS;

1.42
date	2017.03.10.09.14.06;	author mpi;	state Exp;
branches;
next	1.41;
commitid	3KSzSoIpPvZCUNqm;

1.41
date	2017.02.16.14.09.00;	author visa;	state Exp;
branches;
next	1.40;
commitid	LrroiY4OYUmQFL4v;

1.40
date	2017.02.12.17.41.17;	author visa;	state Exp;
branches;
next	1.39;
commitid	3LHNrivPvi4vWnqZ;

1.39
date	2017.02.04.19.22.42;	author guenther;	state Exp;
branches;
next	1.38;
commitid	M5jsTb2bgj8pUSC5;

1.38
date	2016.09.24.12.59.42;	author kettenis;	state Exp;
branches;
next	1.37;
commitid	8GVF7vfwLAuOePYM;

1.37
date	2016.09.15.02.00.18;	author dlg;	state Exp;
branches;
next	1.36;
commitid	RlO92XR575sygHqm;

1.36
date	2015.12.23.12.38.40;	author visa;	state Exp;
branches;
next	1.35;
commitid	67JU0TKsFq2lc2mJ;

1.35
date	2015.12.18.17.23.14;	author mmcc;	state Exp;
branches;
next	1.34;
commitid	zv1oMukSucM0GnVK;

1.34
date	2015.09.03.15.14.08;	author visa;	state Exp;
branches;
next	1.33;
commitid	04r3ChxH4Gy3J0Gg;

1.33
date	2015.09.03.14.22.27;	author visa;	state Exp;
branches;
next	1.32;
commitid	XdgWAAdmEMUYJhm9;

1.32
date	2015.09.03.12.55.54;	author visa;	state Exp;
branches;
next	1.31;
commitid	nYGLcp1vtZI0hUoE;

1.31
date	2015.06.28.11.48.18;	author jmatthew;	state Exp;
branches;
next	1.30;
commitid	iLp75a18m8TiTCQC;

1.30
date	2015.06.26.11.17.34;	author mpi;	state Exp;
branches;
next	1.29;
commitid	EHLAwh7vfwmK7jPG;

1.29
date	2015.06.22.12.56.55;	author mpi;	state Exp;
branches;
next	1.28;
commitid	tsYSHGCfv1hy9V5u;

1.28
date	2015.06.08.08.47.38;	author jmatthew;	state Exp;
branches;
next	1.27;
commitid	WHgR4Wq5cbFpwsa4;

1.27
date	2015.06.08.00.58.23;	author jmatthew;	state Exp;
branches;
next	1.26;
commitid	Yn7nCglVeryCRRKH;

1.26
date	2015.06.08.00.46.33;	author jmatthew;	state Exp;
branches;
next	1.25;
commitid	ssfj9F1ZJXymgKKC;

1.25
date	2015.03.19.10.39.17;	author mpi;	state Exp;
branches;
next	1.24;
commitid	3Yd14W7CLsvXTV5b;

1.24
date	2015.03.19.10.31.29;	author mpi;	state Exp;
branches;
next	1.23;
commitid	Gdylk4Qg8t6EifEs;

1.23
date	2015.03.19.10.29.16;	author mpi;	state Exp;
branches;
next	1.22;
commitid	rFrfMqtBGvZhoeYy;

1.22
date	2015.02.14.05.52.19;	author uebayasi;	state Exp;
branches;
next	1.21;
commitid	nnVIEwxSywLLftIJ;

1.21
date	2015.02.12.11.38.42;	author uebayasi;	state Exp;
branches;
next	1.20;
commitid	9VLzkArmGNRpOVTz;

1.20
date	2015.02.12.06.46.23;	author uebayasi;	state Exp;
branches;
next	1.19;
commitid	sC0cDzP6o4CducN8;

1.19
date	2015.02.12.05.09.46;	author uebayasi;	state Exp;
branches;
next	1.18;
commitid	lFwL4w4a3br9PDfB;

1.18
date	2015.02.11.22.55.25;	author uebayasi;	state Exp;
branches;
next	1.17;
commitid	YSWmdaoKk1xYqwm2;

1.17
date	2015.02.11.06.25.20;	author uebayasi;	state Exp;
branches;
next	1.16;
commitid	wubeGQ8eKtDQmEoh;

1.16
date	2015.02.10.23.43.46;	author uebayasi;	state Exp;
branches;
next	1.15;
commitid	KdRcQuqZ2fT4xGzO;

1.15
date	2015.02.10.23.38.13;	author uebayasi;	state Exp;
branches;
next	1.14;
commitid	wDM5JZ7hVG9y06Xd;

1.14
date	2015.02.10.23.25.14;	author uebayasi;	state Exp;
branches;
next	1.13;
commitid	unZ9EWoW4RIEQknt;

1.13
date	2015.02.10.23.19.34;	author uebayasi;	state Exp;
branches;
next	1.12;
commitid	qZ4NxP6BSXbjsgaa;

1.12
date	2015.02.10.23.10.21;	author uebayasi;	state Exp;
branches;
next	1.11;
commitid	ZPfYvaSag55ForeS;

1.11
date	2015.02.10.14.34.14;	author uebayasi;	state Exp;
branches;
next	1.10;
commitid	aeO9IOZz4TR97GDq;

1.10
date	2015.02.10.14.18.34;	author uebayasi;	state Exp;
branches;
next	1.9;
commitid	HXwbS7i6cu7EzTfc;

1.9
date	2015.02.10.14.15.14;	author uebayasi;	state Exp;
branches;
next	1.8;
commitid	PcNdF1apgXAKIBJI;

1.8
date	2015.02.10.13.49.48;	author uebayasi;	state Exp;
branches;
next	1.7;
commitid	1OLk1XAIxZV0U2BX;

1.7
date	2015.02.10.13.36.13;	author uebayasi;	state Exp;
branches;
next	1.6;
commitid	P1ecLHDp0uA7jMY4;

1.6
date	2015.02.10.13.30.27;	author uebayasi;	state Exp;
branches;
next	1.5;
commitid	DPPlJ6fWAGOUGijh;

1.5
date	2015.02.10.13.27.54;	author uebayasi;	state Exp;
branches;
next	1.4;
commitid	Sa9vvvQVTmOntzZK;

1.4
date	2015.02.10.13.23.30;	author uebayasi;	state Exp;
branches;
next	1.3;
commitid	imPX9R0wTXj085jc;

1.3
date	2015.02.10.13.19.07;	author uebayasi;	state Exp;
branches;
next	1.2;
commitid	DX6qjlYA6iq1pLPL;

1.2
date	2015.02.10.12.58.47;	author uebayasi;	state Exp;
branches;
next	1.1;
commitid	fO2y2txhcaZJkDvb;

1.1
date	2015.02.10.05.00.27;	author uebayasi;	state Exp;
branches
	1.1.1.1;
next	;
commitid	fozgu6iqsHzTcMiM;

1.1.1.1
date	2015.02.10.05.00.27;	author uebayasi;	state Exp;
branches;
next	1.1.1.2;
commitid	fozgu6iqsHzTcMiM;

1.1.1.2
date	2015.02.10.05.10.13;	author uebayasi;	state Exp;
branches;
next	;
commitid	LFuM1eFaklW8eMEs;


desc
@@


1.46
log
@kill RCSID macros; discussed with millert
@
text
@/*	$OpenBSD: dwc2.c,v 1.45 2017/05/15 10:52:08 mpi Exp $	*/
/*	$NetBSD: dwc2.c,v 1.32 2014/09/02 23:26:20 macallan Exp $	*/

/*-
 * Copyright (c) 2013 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Nick Hudson
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#if 0
#include "opt_usb.h"
#endif

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/select.h>
#include <sys/proc.h>
#include <sys/queue.h>
#include <sys/endian.h>
#if 0
#include <sys/cpu.h>
#endif

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#if 0
#include <dev/usb/usbroothub_subr.h>
#endif

#include <dev/usb/dwc2/dwc2.h>
#include <dev/usb/dwc2/dwc2var.h>

#include <dev/usb/dwc2/dwc2_core.h>
#include <dev/usb/dwc2/dwc2_hcd.h>

#ifdef DWC2_COUNTERS
#define	DWC2_EVCNT_ADD(a,b)	((void)((a).ev_count += (b)))
#else
#define	DWC2_EVCNT_ADD(a,b)	do { } while (/*CONSTCOND*/0)
#endif
#define	DWC2_EVCNT_INCR(a)	DWC2_EVCNT_ADD((a), 1)

#ifdef DWC2_DEBUG
#define	DPRINTFN(n,fmt,...) do {			\
	if (dwc2debug >= (n)) {			\
		printf("%s: " fmt,			\
		__FUNCTION__,## __VA_ARGS__);		\
	}						\
} while (0)
#define	DPRINTF(...)	DPRINTFN(1, __VA_ARGS__)
int dwc2debug = 0;
#else
#define	DPRINTF(...) do { } while (0)
#define	DPRINTFN(...) do { } while (0)
#endif

STATIC usbd_status	dwc2_open(struct usbd_pipe *);
STATIC int		dwc2_setaddr(struct usbd_device *, int);
STATIC void		dwc2_poll(struct usbd_bus *);
STATIC void		dwc2_softintr(void *);

#if 0
STATIC usbd_status	dwc2_allocm(struct usbd_bus *, struct usb_dma *, uint32_t);
STATIC void		dwc2_freem(struct usbd_bus *, struct usb_dma *);
#endif

STATIC struct usbd_xfer	*dwc2_allocx(struct usbd_bus *);
STATIC void		dwc2_freex(struct usbd_bus *, struct usbd_xfer *);
#if 0
STATIC void		dwc2_get_lock(struct usbd_bus *, struct mutex **);
#endif

STATIC usbd_status	dwc2_root_ctrl_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_root_ctrl_start(struct usbd_xfer *);
STATIC void		dwc2_root_ctrl_abort(struct usbd_xfer *);
STATIC void		dwc2_root_ctrl_close(struct usbd_pipe *);
STATIC void		dwc2_root_ctrl_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_root_intr_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_root_intr_start(struct usbd_xfer *);
STATIC void		dwc2_root_intr_abort(struct usbd_xfer *);
STATIC void		dwc2_root_intr_close(struct usbd_pipe *);
STATIC void		dwc2_root_intr_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_device_ctrl_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_device_ctrl_start(struct usbd_xfer *);
STATIC void		dwc2_device_ctrl_abort(struct usbd_xfer *);
STATIC void		dwc2_device_ctrl_close(struct usbd_pipe *);
STATIC void		dwc2_device_ctrl_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_device_bulk_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_device_bulk_start(struct usbd_xfer *);
STATIC void		dwc2_device_bulk_abort(struct usbd_xfer *);
STATIC void		dwc2_device_bulk_close(struct usbd_pipe *);
STATIC void		dwc2_device_bulk_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_device_intr_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_device_intr_start(struct usbd_xfer *);
STATIC void		dwc2_device_intr_abort(struct usbd_xfer *);
STATIC void		dwc2_device_intr_close(struct usbd_pipe *);
STATIC void		dwc2_device_intr_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_device_isoc_transfer(struct usbd_xfer *);
STATIC usbd_status	dwc2_device_isoc_start(struct usbd_xfer *);
STATIC void		dwc2_device_isoc_abort(struct usbd_xfer *);
STATIC void		dwc2_device_isoc_close(struct usbd_pipe *);
STATIC void		dwc2_device_isoc_done(struct usbd_xfer *);

STATIC usbd_status	dwc2_device_start(struct usbd_xfer *);

STATIC void		dwc2_close_pipe(struct usbd_pipe *);
STATIC void		dwc2_abort_xfer(struct usbd_xfer *, usbd_status);

STATIC void		dwc2_device_clear_toggle(struct usbd_pipe *);
STATIC void		dwc2_noop(struct usbd_pipe *pipe);

STATIC int		dwc2_interrupt(struct dwc2_softc *);
STATIC void		dwc2_rhc(void *);

STATIC void		dwc2_timeout(void *);
STATIC void		dwc2_timeout_task(void *);

STATIC_INLINE void
dwc2_allocate_bus_bandwidth(struct dwc2_hsotg *hsotg, u16 bw,
			    struct usbd_xfer *xfer)
{
}

STATIC_INLINE void
dwc2_free_bus_bandwidth(struct dwc2_hsotg *hsotg, u16 bw,
			struct usbd_xfer *xfer)
{
}

#define DWC2_INTR_ENDPT 1

STATIC struct usbd_bus_methods dwc2_bus_methods = {
	.open_pipe =	dwc2_open,
	.dev_setaddr =	dwc2_setaddr,
	.soft_intr =	dwc2_softintr,
	.do_poll =	dwc2_poll,
#if 0
	.allocm =	dwc2_allocm,
	.freem =	dwc2_freem,
#endif
	.allocx =	dwc2_allocx,
	.freex =	dwc2_freex,
#if 0
	.get_lock =	dwc2_get_lock,
#endif
};

STATIC struct usbd_pipe_methods dwc2_root_ctrl_methods = {
	.transfer =	dwc2_root_ctrl_transfer,
	.start =	dwc2_root_ctrl_start,
	.abort =	dwc2_root_ctrl_abort,
	.close =	dwc2_root_ctrl_close,
	.cleartoggle =	dwc2_noop,
	.done =		dwc2_root_ctrl_done,
};

STATIC struct usbd_pipe_methods dwc2_root_intr_methods = {
	.transfer =	dwc2_root_intr_transfer,
	.start =	dwc2_root_intr_start,
	.abort =	dwc2_root_intr_abort,
	.close =	dwc2_root_intr_close,
	.cleartoggle =	dwc2_noop,
	.done =		dwc2_root_intr_done,
};

STATIC struct usbd_pipe_methods dwc2_device_ctrl_methods = {
	.transfer =	dwc2_device_ctrl_transfer,
	.start =	dwc2_device_ctrl_start,
	.abort =	dwc2_device_ctrl_abort,
	.close =	dwc2_device_ctrl_close,
	.cleartoggle =	dwc2_noop,
	.done =		dwc2_device_ctrl_done,
};

STATIC struct usbd_pipe_methods dwc2_device_intr_methods = {
	.transfer =	dwc2_device_intr_transfer,
	.start =	dwc2_device_intr_start,
	.abort =	dwc2_device_intr_abort,
	.close =	dwc2_device_intr_close,
	.cleartoggle =	dwc2_device_clear_toggle,
	.done =		dwc2_device_intr_done,
};

STATIC struct usbd_pipe_methods dwc2_device_bulk_methods = {
	.transfer =	dwc2_device_bulk_transfer,
	.start =	dwc2_device_bulk_start,
	.abort =	dwc2_device_bulk_abort,
	.close =	dwc2_device_bulk_close,
	.cleartoggle =	dwc2_device_clear_toggle,
	.done =		dwc2_device_bulk_done,
};

STATIC struct usbd_pipe_methods dwc2_device_isoc_methods = {
	.transfer =	dwc2_device_isoc_transfer,
	.start =	dwc2_device_isoc_start,
	.abort =	dwc2_device_isoc_abort,
	.close =	dwc2_device_isoc_close,
	.cleartoggle =	dwc2_noop,
	.done =		dwc2_device_isoc_done,
};

#if 0
STATIC usbd_status
dwc2_allocm(struct usbd_bus *bus, struct usb_dma *dma, uint32_t size)
{
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);
	usbd_status status;

	DPRINTFN(10, "\n");

	status = usb_allocmem(&sc->sc_bus, size, 0, dma);
	if (status == USBD_NOMEM)
		status = usb_reserve_allocm(&sc->sc_dma_reserve, dma, size);
	return status;
}

STATIC void
dwc2_freem(struct usbd_bus *bus, struct usb_dma *dma)
{
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);

	DPRINTFN(10, "\n");

	if (dma->block->flags & USB_DMA_RESERVE) {
		usb_reserve_freem(&sc->sc_dma_reserve, dma);
		return;
	}
	usb_freemem(&sc->sc_bus, dma);
}
#endif

/*
 * Work around the half configured control (default) pipe when setting
 * the address of a device.
 */
STATIC int
dwc2_setaddr(struct usbd_device *dev, int addr)
{
	if (usbd_set_address(dev, addr))
		return (1);

	dev->address = addr;

	/*
	 * Re-establish the default pipe with the new address and the
	 * new max packet size.
	 */
	dwc2_close_pipe(dev->default_pipe);
	if (dwc2_open(dev->default_pipe))
		return (EINVAL);

	return (0);
}

struct usbd_xfer *
dwc2_allocx(struct usbd_bus *bus)
{
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);
	struct dwc2_xfer *dxfer;

	DPRINTFN(10, "\n");

	DWC2_EVCNT_INCR(sc->sc_ev_xferpoolget);
	dxfer = pool_get(&sc->sc_xferpool, PR_NOWAIT);
	if (dxfer != NULL) {
		memset(dxfer, 0, sizeof(*dxfer));

		dxfer->urb = dwc2_hcd_urb_alloc(sc->sc_hsotg,
		    DWC2_MAXISOCPACKETS, GFP_KERNEL);

#ifdef DWC2_DEBUG
		dxfer->xfer.busy_free = XFER_ONQU;
#endif
	}
	return (struct usbd_xfer *)dxfer;
}

void
dwc2_freex(struct usbd_bus *bus, struct usbd_xfer *xfer)
{
	struct dwc2_xfer *dxfer = DWC2_XFER2DXFER(xfer);
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);

	DPRINTFN(10, "\n");

#ifdef DWC2_DEBUG
	if (xfer->busy_free != XFER_ONQU) {
		DPRINTF("xfer=%p not busy, 0x%08x\n", xfer, xfer->busy_free);
	}
	xfer->busy_free = XFER_FREE;
#endif
	DWC2_EVCNT_INCR(sc->sc_ev_xferpoolput);
	dwc2_hcd_urb_free(sc->sc_hsotg, dxfer->urb, DWC2_MAXISOCPACKETS);
	pool_put(&sc->sc_xferpool, xfer);
}

#if 0
STATIC void
dwc2_get_lock(struct usbd_bus *bus, struct mutex **lock)
{
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);

	*lock = &sc->sc_lock;
}
#endif

STATIC void
dwc2_rhc(void *addr)
{
	struct dwc2_softc *sc = addr;
	struct usbd_xfer *xfer;
	u_char *p;

	DPRINTF("\n");
	xfer = sc->sc_intrxfer;

	if (xfer == NULL) {
		/* Just ignore the change. */
		return;

	}
	/* set port bit */
	p = KERNADDR(&xfer->dmabuf, 0);

	p[0] = 0x02;	/* we only have one port (1 << 1) */

	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	usb_transfer_complete(xfer);
}

STATIC void
dwc2_softintr(void *v)
{
	struct usbd_bus *bus = v;
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;
	struct dwc2_xfer *dxfer;

	mtx_enter(&hsotg->lock);
	while ((dxfer = TAILQ_FIRST(&sc->sc_complete)) != NULL) {

		KASSERTMSG(!timeout_pending(&dxfer->xfer.timeout_handle), 
		    "xfer %p pipe %p\n", dxfer, dxfer->xfer.pipe);

		/*
		 * dwc2_abort_xfer will remove this transfer from the
		 * sc_complete queue
		 */
		/*XXXNH not tested */
		if (dxfer->flags & DWC2_XFER_ABORTING) {
			wakeup(&dxfer->flags);
			continue;
		}

		TAILQ_REMOVE(&sc->sc_complete, dxfer, xnext);

		mtx_leave(&hsotg->lock);
		usb_transfer_complete(&dxfer->xfer);
		mtx_enter(&hsotg->lock);
	}
	mtx_leave(&hsotg->lock);
}

STATIC void
dwc2_timeout(void *addr)
{
	struct usbd_xfer *xfer = addr;
 	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);

	DPRINTF("xfer=%p\n", xfer);

	if (sc->sc_dying) {
		dwc2_timeout_task(addr);
		return;
	}

	/* Execute the abort in a process context. */
	usb_init_task(&xfer->abort_task, dwc2_timeout_task, addr,
	    USB_TASK_TYPE_ABORT);
	usb_add_task(xfer->device, &xfer->abort_task);
}

STATIC void
dwc2_timeout_task(void *addr)
{
	struct usbd_xfer *xfer = addr;
	int s;

	DPRINTF("xfer=%p\n", xfer);

	s = splusb();
	dwc2_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

usbd_status
dwc2_open(struct usbd_pipe *pipe)
{
	struct usbd_device *dev = pipe->device;
	struct dwc2_softc *sc = DWC2_PIPE2SC(pipe);
	struct dwc2_pipe *dpipe = DWC2_PIPE2DPIPE(pipe);
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	uint8_t addr = dev->address;
	uint8_t xfertype = UE_GET_XFERTYPE(ed->bmAttributes);
	usbd_status err;

	DPRINTF("pipe %p addr %d xfertype %d dir %s\n", pipe, addr, xfertype,
	    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN ? "in" : "out");

	if (sc->sc_dying) {
		return USBD_IOERROR;
	}

	if (addr == sc->sc_addr) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &dwc2_root_ctrl_methods;
			break;
		case UE_DIR_IN | DWC2_INTR_ENDPT:
			pipe->methods = &dwc2_root_intr_methods;
			break;
		default:
			DPRINTF("bad bEndpointAddress 0x%02x\n",
			    ed->bEndpointAddress);
			return USBD_INVAL;
		}
		DPRINTF("root hub pipe open\n");
		return USBD_NORMAL_COMPLETION;
	}

	switch (xfertype) {
	case UE_CONTROL:
		pipe->methods = &dwc2_device_ctrl_methods;
		err = usb_allocmem(&sc->sc_bus, sizeof(usb_device_request_t),
		    0, &dpipe->req_dma);
		if (err)
			return err;
		break;
	case UE_INTERRUPT:
		pipe->methods = &dwc2_device_intr_methods;
		break;
	case UE_ISOCHRONOUS:
		pipe->methods = &dwc2_device_isoc_methods;
		break;
	case UE_BULK:
		pipe->methods = &dwc2_device_bulk_methods;
		break;
	default:
		DPRINTF("bad xfer type %d\n", xfertype);
		return USBD_INVAL;
	}

	dpipe->priv = NULL;	/* QH */

	return USBD_NORMAL_COMPLETION;
}

STATIC void
dwc2_poll(struct usbd_bus *bus)
{
	struct dwc2_softc *sc = DWC2_BUS2SC(bus);
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;

	mtx_enter(&hsotg->lock);
	dwc2_interrupt(sc);
	mtx_leave(&hsotg->lock);
}

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
STATIC void
dwc2_close_pipe(struct usbd_pipe *pipe)
{
	/* nothing */
}

/*
 * Abort a device request.
 */
STATIC void
dwc2_abort_xfer(struct usbd_xfer *xfer, usbd_status status)
{
	struct dwc2_xfer *dxfer = DWC2_XFER2DXFER(xfer);
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;
	struct dwc2_xfer *d, *tmp;
	bool wake;
	int err;

	splsoftassert(IPL_SOFTUSB);

	DPRINTF("xfer=%p\n", xfer);

	if (sc->sc_dying) {
		xfer->status = status;
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);
		usb_transfer_complete(xfer);
		return;
	}

	/*
	 * If an abort is already in progress then just wait for it to
	 * complete and return.
	 */
	if (dxfer->flags & DWC2_XFER_ABORTING) {
		xfer->status = status;
		dxfer->flags |= DWC2_XFER_ABORTWAIT;
		while (dxfer->flags & DWC2_XFER_ABORTING)
			tsleep(&dxfer->flags, PZERO, "dwc2xfer", 0);
		return;
	}

	mtx_enter(&hsotg->lock);

	/* The transfer might have been completed already. */
	if (xfer->status != USBD_IN_PROGRESS) {
		DPRINTF("xfer=%p already completed\n", xfer);
		mtx_leave(&hsotg->lock);
		return;
	}

	/*
	 * Step 1: Make the stack ignore it and stop the timeout.
	 */
	dxfer->flags |= DWC2_XFER_ABORTING;

	xfer->status = status;	/* make software ignore it */
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);

	/* XXXNH suboptimal */
	TAILQ_FOREACH_SAFE(d, &sc->sc_complete, xnext, tmp) {
		if (d == dxfer) {
			TAILQ_REMOVE(&sc->sc_complete, dxfer, xnext);
		}
	}

	err = dwc2_hcd_urb_dequeue(hsotg, dxfer->urb);
	if (err) {
		DPRINTF("dwc2_hcd_urb_dequeue failed\n");
	}

	mtx_leave(&hsotg->lock);

	/*
	 * Step 2: Execute callback.
	 */
	wake = dxfer->flags & DWC2_XFER_ABORTWAIT;
	dxfer->flags &= ~(DWC2_XFER_ABORTING | DWC2_XFER_ABORTWAIT);

	usb_transfer_complete(xfer);
	if (wake) {
		wakeup(&dxfer->flags);
	}
}

STATIC void
dwc2_noop(struct usbd_pipe *pipe)
{

}

STATIC void
dwc2_device_clear_toggle(struct usbd_pipe *pipe)
{

	DPRINTF("toggle %d -> 0", pipe->endpoint->savedtoggle);
}

/***********************************************************************/

/*
 * Data structures and routines to emulate the root hub.
 */

STATIC const usb_device_descriptor_t dwc2_devd = {
	.bLength = sizeof(usb_device_descriptor_t),
	.bDescriptorType = UDESC_DEVICE,
	.bcdUSB = {0x00, 0x02},
	.bDeviceClass = UDCLASS_HUB,
	.bDeviceSubClass = UDSUBCLASS_HUB,
	.bDeviceProtocol = UDPROTO_HSHUBSTT,
	.bMaxPacketSize = 64,
	.bcdDevice = {0x00, 0x01},
	.iManufacturer = 1,
	.iProduct = 2,
	.bNumConfigurations = 1,
};

struct dwc2_config_desc {
	usb_config_descriptor_t confd;
	usb_interface_descriptor_t ifcd;
	usb_endpoint_descriptor_t endpd;
} __packed;

STATIC const struct dwc2_config_desc dwc2_confd = {
	.confd = {
		.bLength = USB_CONFIG_DESCRIPTOR_SIZE,
		.bDescriptorType = UDESC_CONFIG,
		.wTotalLength[0] = sizeof(dwc2_confd),
		.bNumInterface = 1,
		.bConfigurationValue = 1,
		.iConfiguration = 0,
		.bmAttributes = UC_SELF_POWERED,
		.bMaxPower = 0,
	},
	.ifcd = {
		.bLength = USB_INTERFACE_DESCRIPTOR_SIZE,
		.bDescriptorType = UDESC_INTERFACE,
		.bInterfaceNumber = 0,
		.bAlternateSetting = 0,
		.bNumEndpoints = 1,
		.bInterfaceClass = UICLASS_HUB,
		.bInterfaceSubClass = UISUBCLASS_HUB,
		.bInterfaceProtocol = UIPROTO_HSHUBSTT,
		.iInterface = 0
	},
	.endpd = {
		.bLength = USB_ENDPOINT_DESCRIPTOR_SIZE,
		.bDescriptorType = UDESC_ENDPOINT,
		.bEndpointAddress = UE_DIR_IN | DWC2_INTR_ENDPT,
		.bmAttributes = UE_INTERRUPT,
		.wMaxPacketSize = {8, 0},			/* max packet */
		.bInterval = 255,
	},
};

#define	HSETW(ptr, val) ptr = { (uint8_t)(val), (uint8_t)((val) >> 8) }
#if 0
/* appears to be unused */
STATIC const usb_hub_descriptor_t dwc2_hubd = {
	.bDescLength = USB_HUB_DESCRIPTOR_SIZE,
	.bDescriptorType = UDESC_HUB,
	.bNbrPorts = 1,
	HSETW(.wHubCharacteristics, (UHD_PWR_NO_SWITCH | UHD_OC_INDIVIDUAL)),
	.bPwrOn2PwrGood = 50,
	.bHubContrCurrent = 0,
	.DeviceRemovable = {0},		/* port is removable */
};
#endif

STATIC usbd_status
dwc2_root_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	return dwc2_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

STATIC usbd_status
dwc2_root_ctrl_start(struct usbd_xfer *xfer)
{
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
	usb_device_request_t *req;
	uint8_t *buf;
	uint16_t len;
	int value, index, l, s, totlen;
	usbd_status err = USBD_IOERROR;

	if (sc->sc_dying)
		return USBD_IOERROR;

	req = &xfer->request;

	DPRINTFN(4, "type=0x%02x request=%02x\n",
	    req->bmRequestType, req->bRequest);

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	buf = len ? KERNADDR(&xfer->dmabuf, 0) : NULL;

	totlen = 0;

#define C(x,y) ((x) | ((y) << 8))
	switch (C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(8, "wValue=0x%04x\n", value);

		if (len == 0)
			break;
		switch (value) {
		case C(0, UDESC_DEVICE):
			l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
// 			USETW(dwc2_devd.idVendor, sc->sc_id_vendor);
			memcpy(buf, &dwc2_devd, l);
			buf += l;
			len -= l;
			totlen += l;

			break;
		case C(0, UDESC_CONFIG):
			l = min(len, sizeof(dwc2_confd));
			memcpy(buf, &dwc2_confd, l);
			buf += l;
			len -= l;
			totlen += l;

			break;
#define sd ((usb_string_descriptor_t *)buf)
		case C(0, UDESC_STRING):
			totlen = usbd_str(sd, len, "\001");
			break;
		case C(1, UDESC_STRING):
			totlen = usbd_str(sd, len, sc->sc_vendor);
			break;
		case C(2, UDESC_STRING):
			totlen = usbd_str(sd, len, "DWC2 root hub");
			break;
#undef sd
		default:
			goto fail;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		DPRINTF("UR_SET_ADDRESS, UT_WRITE_DEVICE: addr %d\n",
		    value);
		if (value >= USB_MAX_DEVICES)
			goto fail;

		sc->sc_addr = value;
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1)
			goto fail;

		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto fail;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	default:
		/* Hub requests - XXXNH len check? */
		err = dwc2_hcd_hub_control(sc->sc_hsotg,
		    C(req->bRequest, req->bmRequestType), value, index,
		    buf, len);
		if (err) {
			err = USBD_IOERROR;
			goto fail;
		}
		totlen = len;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;

fail:
	s = splusb();
	xfer->status = err;
	usb_transfer_complete(xfer);
	splx(s);

	return err;
}

STATIC void
dwc2_root_ctrl_abort(struct usbd_xfer *xfer)
{
	DPRINTFN(10, "\n");

	/* Nothing to do, all transfers are synchronous. */
}

STATIC void
dwc2_root_ctrl_close(struct usbd_pipe *pipe)
{
	DPRINTFN(10, "\n");

	/* Nothing to do. */
}

STATIC void
dwc2_root_ctrl_done(struct usbd_xfer *xfer)
{
	DPRINTFN(10, "\n");

	/* Nothing to do. */
}

STATIC usbd_status
dwc2_root_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("\n");

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	/* Pipe isn't running, start first */
	return dwc2_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

STATIC usbd_status
dwc2_root_intr_start(struct usbd_xfer *xfer)
{
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);

	DPRINTF("\n");

	if (sc->sc_dying)
		return USBD_IOERROR;

	KASSERT(sc->sc_intrxfer == NULL);
	sc->sc_intrxfer = xfer;

	return USBD_IN_PROGRESS;
}

/* Abort a root interrupt request. */
STATIC void
dwc2_root_intr_abort(struct usbd_xfer *xfer)
{
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);

	DPRINTF("xfer=%p\n", xfer);

	KASSERT(xfer->pipe->intrxfer == xfer);

	sc->sc_intrxfer = NULL;

	xfer->status = USBD_CANCELLED;
	usb_transfer_complete(xfer);
}

STATIC void
dwc2_root_intr_close(struct usbd_pipe *pipe)
{
	struct dwc2_softc *sc = DWC2_PIPE2SC(pipe);

	DPRINTF("\n");

	sc->sc_intrxfer = NULL;
}

STATIC void
dwc2_root_intr_done(struct usbd_xfer *xfer)
{

	DPRINTF("\n");
}

/***********************************************************************/

STATIC usbd_status
dwc2_device_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("\n");

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	/* Pipe isn't running, start first */
	return dwc2_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

STATIC usbd_status
dwc2_device_ctrl_start(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("\n");

	xfer->status = USBD_IN_PROGRESS;
	err = dwc2_device_start(xfer);

	return err;
}

STATIC void
dwc2_device_ctrl_abort(struct usbd_xfer *xfer)
{
	DPRINTF("xfer=%p\n", xfer);
	dwc2_abort_xfer(xfer, USBD_CANCELLED);
}

STATIC void
dwc2_device_ctrl_close(struct usbd_pipe *pipe)
{

	DPRINTF("pipe=%p\n", pipe);
	dwc2_close_pipe(pipe);
}

STATIC void
dwc2_device_ctrl_done(struct usbd_xfer *xfer)
{

	DPRINTF("xfer=%p\n", xfer);
}

/***********************************************************************/

STATIC usbd_status
dwc2_device_bulk_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("xfer=%p\n", xfer);

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	/* Pipe isn't running, start first */
	return dwc2_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

STATIC usbd_status
dwc2_device_bulk_start(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("xfer=%p\n", xfer);

	xfer->status = USBD_IN_PROGRESS;
	err = dwc2_device_start(xfer);

	return err;
}

STATIC void
dwc2_device_bulk_abort(struct usbd_xfer *xfer)
{
	DPRINTF("xfer=%p\n", xfer);

	dwc2_abort_xfer(xfer, USBD_CANCELLED);
}

STATIC void
dwc2_device_bulk_close(struct usbd_pipe *pipe)
{

	DPRINTF("pipe=%p\n", pipe);

	dwc2_close_pipe(pipe);
}

STATIC void
dwc2_device_bulk_done(struct usbd_xfer *xfer)
{

	DPRINTF("xfer=%p\n", xfer);
}

/***********************************************************************/

STATIC usbd_status
dwc2_device_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("xfer=%p\n", xfer);

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	/* Pipe isn't running, start first */
	return dwc2_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

STATIC usbd_status
dwc2_device_intr_start(struct usbd_xfer *xfer)
{
	usbd_status err;

	xfer->status = USBD_IN_PROGRESS;
	err = dwc2_device_start(xfer);

	return err;
}

/* Abort a device interrupt request. */
STATIC void
dwc2_device_intr_abort(struct usbd_xfer *xfer)
{
	KASSERT(xfer->pipe->intrxfer == xfer);

	DPRINTF("xfer=%p\n", xfer);

	dwc2_abort_xfer(xfer, USBD_CANCELLED);
}

STATIC void
dwc2_device_intr_close(struct usbd_pipe *pipe)
{

	DPRINTF("pipe=%p\n", pipe);

	dwc2_close_pipe(pipe);
}

STATIC void
dwc2_device_intr_done(struct usbd_xfer *xfer)
{

	DPRINTF("\n");

	if (xfer->pipe->repeat) {
		xfer->status = USBD_IN_PROGRESS;
		dwc2_device_start(xfer);
	}
}

/***********************************************************************/

usbd_status
dwc2_device_isoc_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	DPRINTF("xfer=%p\n", xfer);

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return err;

	/* Pipe isn't running, start first */
	return dwc2_device_isoc_start(SIMPLEQ_FIRST(&xfer->pipe->queue));
}

usbd_status
dwc2_device_isoc_start(struct usbd_xfer *xfer)
{
	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);
	struct dwc2_softc *sc = DWC2_DPIPE2SC(dpipe);
	usbd_status err;

	/* Why would you do that anyway? */
	if (sc->sc_bus.use_polling)
		return (USBD_INVAL);

	xfer->status = USBD_IN_PROGRESS;
	err = dwc2_device_start(xfer);

	return err;
}

void
dwc2_device_isoc_abort(struct usbd_xfer *xfer)
{
	DPRINTF("xfer=%p\n", xfer);

	dwc2_abort_xfer(xfer, USBD_CANCELLED);
}

void
dwc2_device_isoc_close(struct usbd_pipe *pipe)
{
	DPRINTF("\n");

	dwc2_close_pipe(pipe);
}

void
dwc2_device_isoc_done(struct usbd_xfer *xfer)
{

	DPRINTF("\n");
}


usbd_status
dwc2_device_start(struct usbd_xfer *xfer)
{
 	struct dwc2_xfer *dxfer = DWC2_XFER2DXFER(xfer);
	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;
	struct dwc2_hcd_urb *dwc2_urb;

	struct usbd_device *dev = xfer->pipe->device;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	uint8_t addr = dev->address;
	uint8_t xfertype = UE_GET_XFERTYPE(ed->bmAttributes);
	uint8_t epnum = UE_GET_ADDR(ed->bEndpointAddress);
	uint8_t dir = UE_GET_DIR(ed->bEndpointAddress);
	uint16_t mps = UE_GET_SIZE(UGETW(ed->wMaxPacketSize));
	uint32_t len;

	uint32_t flags = 0;
	uint32_t off = 0;
	int retval, err = USBD_IN_PROGRESS;
	int alloc_bandwidth = 0;
	int i;

	DPRINTFN(1, "xfer=%p pipe=%p\n", xfer, xfer->pipe);

	if (xfertype == UE_ISOCHRONOUS ||
	    xfertype == UE_INTERRUPT) {
		mtx_enter(&hsotg->lock);
		if (!dwc2_hcd_is_bandwidth_allocated(hsotg, xfer))
			alloc_bandwidth = 1;
		mtx_leave(&hsotg->lock);
	}

	/*
	 * For Control pipe the direction is from the request, all other
	 * transfers have been set correctly at pipe open time.
	 */
	if (xfertype == UE_CONTROL) {
		usb_device_request_t *req = &xfer->request;

		DPRINTFN(3, "xfer=%p type=0x%02x request=0x%02x wValue=0x%04x "
		    "wIndex=0x%04x len=%d addr=%d endpt=%d dir=%s speed=%d "
		    "mps=%d\n",
		    xfer, req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), UGETW(req->wLength), dev->address,
		    epnum, dir == UT_READ ? "in" :"out", dev->speed, mps);

		/* Copy request packet to our DMA buffer */
		memcpy(KERNADDR(&dpipe->req_dma, 0), req, sizeof(*req));
		usb_syncmem(&dpipe->req_dma, 0, sizeof(*req),
			    BUS_DMASYNC_PREWRITE);
		len = UGETW(req->wLength);
		if ((req->bmRequestType & UT_READ) == UT_READ) {
			dir = UE_DIR_IN;
		} else {
			dir = UE_DIR_OUT;
		}

		DPRINTFN(3, "req = %p dma = %llx len %d dir %s\n",
		    KERNADDR(&dpipe->req_dma, 0),
		    (long long)DMAADDR(&dpipe->req_dma, 0),
		    len, dir == UE_DIR_IN ? "in" : "out");
	} else {
		DPRINTFN(3, "xfer=%p len=%d flags=%d addr=%d endpt=%d,"
		    " mps=%d dir %s\n", xfer, xfer->length, xfer->flags, addr,
		    epnum, mps, dir == UT_READ ? "in" :"out");

		len = xfer->length;
	}

	dwc2_urb = dxfer->urb;
	if (!dwc2_urb)
		return USBD_NOMEM;

	memset(dwc2_urb, 0, sizeof(*dwc2_urb) +
	    sizeof(dwc2_urb->iso_descs[0]) * DWC2_MAXISOCPACKETS);

	dwc2_hcd_urb_set_pipeinfo(hsotg, dwc2_urb, addr, epnum, xfertype, dir,
				  mps);

	if (xfertype == UE_CONTROL) {
		dwc2_urb->setup_usbdma = &dpipe->req_dma;
		dwc2_urb->setup_packet = KERNADDR(&dpipe->req_dma, 0);
		dwc2_urb->setup_dma = DMAADDR(&dpipe->req_dma, 0);
	} else {
		/* XXXNH - % mps required? */
		if ((xfer->flags & USBD_FORCE_SHORT_XFER) && (len % mps) == 0)
			flags |= URB_SEND_ZERO_PACKET;
	}
	flags |= URB_GIVEBACK_ASAP;

	/*
	 * control transfers with no data phase don't touch usbdma, but
	 * everything else does.
	 */
	if (!(xfertype == UE_CONTROL && len == 0)) {
		dwc2_urb->usbdma = &xfer->dmabuf;
		dwc2_urb->buf = KERNADDR(dwc2_urb->usbdma, 0);
		dwc2_urb->dma = DMAADDR(dwc2_urb->usbdma, 0);
 	}
	dwc2_urb->length = len;
 	dwc2_urb->flags = flags;
	dwc2_urb->status = -EINPROGRESS;
	dwc2_urb->packet_count = xfer->nframes;

	if (xfertype == UE_INTERRUPT ||
	    xfertype == UE_ISOCHRONOUS) {
		uint16_t ival;

		if (xfertype == UE_INTERRUPT &&
		    dpipe->pipe.interval != USBD_DEFAULT_INTERVAL) {
			ival = dpipe->pipe.interval;
		} else {
			ival = ed->bInterval;
		}

		if (ival < 1) {
			retval = -ENODEV;
			goto fail;
		}
		if (dev->speed == USB_SPEED_HIGH ||
		   (dev->speed == USB_SPEED_FULL && xfertype == UE_ISOCHRONOUS)) {
			if (ival > 16) {
				/*
				 * illegal with HS/FS, but there were
				 * documentation bugs in the spec
				 */
				ival = 256;
			} else {
				ival = (1 << (ival - 1));
			}
		} else {
			if (xfertype == UE_INTERRUPT && ival < 10)
				ival = 10;
		}
		dwc2_urb->interval = ival;
	}

	xfer->actlen = 0;

	KASSERT(xfertype != UE_ISOCHRONOUS ||
	    xfer->nframes < DWC2_MAXISOCPACKETS);
	KASSERTMSG(xfer->nframes == 0 || xfertype == UE_ISOCHRONOUS,
	    "nframes %d xfertype %d\n", xfer->nframes, xfertype);

	for (off = i = 0; i < xfer->nframes; ++i) {
		DPRINTFN(3, "xfer=%p frame=%d offset=%d length=%d\n", xfer, i,
		    off, xfer->frlengths[i]);

		dwc2_hcd_urb_set_iso_desc_params(dwc2_urb, i, off,
		    xfer->frlengths[i]);
		off += xfer->frlengths[i];
	}

	/* might need to check cpu_intr_p */
	mtx_enter(&hsotg->lock);

	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_reset(&xfer->timeout_handle, mstohz(xfer->timeout),
		    dwc2_timeout, xfer);
	}

	dwc2_urb->priv = xfer;
	retval = dwc2_hcd_urb_enqueue(hsotg, dwc2_urb, &dpipe->priv, 0);
	if (retval)
		goto fail;

	if (alloc_bandwidth) {
		dwc2_allocate_bus_bandwidth(hsotg,
				dwc2_hcd_get_ep_bandwidth(hsotg, dpipe),
				xfer);
	}

fail:
	mtx_leave(&hsotg->lock);

	switch (retval) {
	case 0:
		break;
	case -ENODEV:
		err = USBD_INVAL;
		break;
	case -ENOMEM:
		err = USBD_NOMEM;
		break;
	default:
		err = USBD_IOERROR;
	}

	return err;

}

void
dwc2_worker(struct task *wk, void *priv)
{
	struct dwc2_softc *sc = priv;
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;

/* db_enter(); */
#if 0
	struct usbd_xfer *xfer = dwork->xfer;
	struct dwc2_xfer *dxfer = DWC2_XFER2DXFER(xfer);

	dwc2_hcd_endpoint_disable(sc->dwc_dev.hcd, dpipe->priv, 250);
	dwc_free(NULL, dpipe->urb);
#endif

	if (wk == &hsotg->wf_otg) {
		dwc2_conn_id_status_change(wk);
	} else if (wk == &hsotg->start_work.work) {
		dwc2_hcd_start_func(wk);
	} else if (wk == &hsotg->reset_work.work) {
		dwc2_hcd_reset_func(wk);
	} else {
#if 0
		KASSERT(dwork->xfer != NULL);
		KASSERT(dxfer->queued == true);

		if (!(dxfer->flags & DWC2_XFER_ABORTING)) {
			dwc2_start_standard_chain(xfer);
		}
		dxfer->queued = false;
		wakeup(&dxfer->flags);
#endif
	}
}

int
dwc2_intr(void *p)
{
	struct dwc2_softc *sc = p;
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;
	int ret = 0;

	mtx_enter(&hsotg->lock);

	if (sc->sc_dying)
		goto done;

	if (sc->sc_bus.use_polling) {
		uint32_t intrs;

		intrs = dwc2_read_core_intr(hsotg);
		DWC2_WRITE_4(hsotg, GINTSTS, intrs);
	} else {
		ret = dwc2_interrupt(sc);
	}

done:
	mtx_leave(&hsotg->lock);

	return ret;
}

int
dwc2_interrupt(struct dwc2_softc *sc)
{
	int ret = 0;

	if (sc->sc_hcdenabled) {
		ret |= dwc2_handle_hcd_intr(sc->sc_hsotg);
	}

	ret |= dwc2_handle_common_intr(sc->sc_hsotg);

	return ret;
}

/***********************************************************************/

int
dwc2_detach(struct dwc2_softc *sc, int flags)
{
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);

	return rv;
}

/***********************************************************************/
int
dwc2_init(struct dwc2_softc *sc)
{
	int err = 0;

	sc->sc_bus.usbrev = USBREV_2_0;
	sc->sc_bus.methods = &dwc2_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct dwc2_pipe);
	sc->sc_hcdenabled = false;

	TAILQ_INIT(&sc->sc_complete);

	sc->sc_rhc_si = softintr_establish(IPL_SOFTUSB, dwc2_rhc, sc);

#if 0
	usb_setup_reserve(&sc->sc_bus, &sc->sc_dma_reserve, sc->sc_bus.dmatag,
	    USB_MEM_RESERVE);
#endif

	pool_init(&sc->sc_xferpool, sizeof(struct dwc2_xfer), 0, IPL_USB, 0,
	    "dwc2xfer", NULL);
	pool_init(&sc->sc_qhpool, sizeof(struct dwc2_qh), 0, IPL_USB, 0,
	    "dwc2qh", NULL);
	pool_init(&sc->sc_qtdpool, sizeof(struct dwc2_qtd), 0, IPL_USB, 0,
	    "dwc2qtd", NULL);

	sc->sc_hsotg = malloc(sizeof(struct dwc2_hsotg), M_DEVBUF,
	    M_ZERO | M_WAITOK);

	sc->sc_hsotg->hsotg_sc = sc;
	sc->sc_hsotg->dev = &sc->sc_bus.bdev;
	sc->sc_hcdenabled = true;

	err = dwc2_hcd_init(sc->sc_hsotg, sc->sc_params);
	if (err) {
		err = -err;
		goto fail;
	}

	return 0;

fail:
	free(sc->sc_hsotg, M_DEVBUF, sizeof(struct dwc2_hsotg));
	softintr_disestablish(sc->sc_rhc_si);

	return err;
}

int
dwc2_dma_config(struct dwc2_softc *sc, struct dwc2_core_dma_config *config)
{
	sc->sc_dma_config = config;
	return dwc2_hcd_dma_config(sc->sc_hsotg, sc->sc_dma_config);
}

#if 0
/*
 * curmode is a mode indication bit 0 = device, 1 = host
 */
STATIC const char * const intnames[32] = {
	"curmode",	"modemis",	"otgint",	"sof",
	"rxflvl",	"nptxfemp",	"ginnakeff",	"goutnakeff",
	"ulpickint",	"i2cint",	"erlysusp",	"usbsusp",
	"usbrst",	"enumdone",	"isooutdrop",	"eopf",
	"restore_done",	"epmis",	"iepint",	"oepint",
	"incompisoin",	"incomplp",	"fetsusp",	"resetdet",
	"prtint",	"hchint",	"ptxfemp",	"lpm",
	"conidstschng",	"disconnint",	"sessreqint",	"wkupint"
};


/***********************************************************************/

#endif


void
dw_timeout(void *arg)
{
	struct delayed_work *dw = arg;

	task_set(&dw->work, dw->dw_fn, dw->dw_arg);
	task_add(dw->dw_wq, &dw->work);
}

void dwc2_host_hub_info(struct dwc2_hsotg *hsotg, void *context, int *hub_addr,
			int *hub_port)
{
	struct usbd_xfer *xfer = context;
	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);
	struct usbd_device *dev = dpipe->pipe.device;

	if (dev->myhsport != NULL) {
		*hub_addr = dev->myhsport->parent->address;
 		*hub_port = dev->myhsport->portno;
	}
}

int dwc2_host_get_speed(struct dwc2_hsotg *hsotg, void *context)
{
	struct usbd_xfer *xfer = context;
	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);
	struct usbd_device *dev = dpipe->pipe.device;

	return dev->speed;
}

/*
 * Sets the final status of an URB and returns it to the upper layer. Any
 * required cleanup of the URB is performed.
 *
 * Must be called with interrupt disabled and spinlock held
 */
void dwc2_host_complete(struct dwc2_hsotg *hsotg, struct dwc2_qtd *qtd,
			int status)
{
	struct usbd_xfer *xfer;
	struct dwc2_xfer *dxfer;
	struct dwc2_softc *sc;
	usb_endpoint_descriptor_t *ed;
	uint8_t xfertype;

	if (!qtd) {
		dev_dbg(hsotg->dev, "## %s: qtd is NULL ##\n", __func__);
		return;
	}

	if (!qtd->urb) {
		dev_dbg(hsotg->dev, "## %s: qtd->urb is NULL ##\n", __func__);
		return;
	}

	xfer = qtd->urb->priv;
	if (!xfer) {
		dev_dbg(hsotg->dev, "## %s: urb->priv is NULL ##\n", __func__);
		return;
	}

	dxfer = DWC2_XFER2DXFER(xfer);
	sc = DWC2_XFER2SC(xfer);
	ed = xfer->pipe->endpoint->edesc;
	xfertype = UE_GET_XFERTYPE(ed->bmAttributes);

	xfer->actlen = dwc2_hcd_urb_get_actual_length(qtd->urb);

	DPRINTFN(3, "xfer=%p actlen=%d\n", xfer, xfer->actlen);

	if (xfertype == UE_ISOCHRONOUS && dbg_perio()) {
		int i;

		for (i = 0; i < xfer->nframes; i++)
			dev_vdbg(hsotg->dev, " ISO Desc %d status %d\n",
				 i, qtd->urb->iso_descs[i].status);
	}

	if (xfertype == UE_ISOCHRONOUS) {
		int i;

		xfer->actlen = 0;
		for (i = 0; i < xfer->nframes; ++i) {
			xfer->frlengths[i] =
				dwc2_hcd_urb_get_iso_desc_actual_length(
						qtd->urb, i);
			xfer->actlen += xfer->frlengths[i];
		}
	}

	if (!status) {
		if (!(xfer->flags & USBD_SHORT_XFER_OK) &&
		    xfer->actlen < xfer->length)
			status = -EIO;
	}

	switch (status) {
	case 0:
		xfer->status = USBD_NORMAL_COMPLETION;
		break;
	case -EPIPE:
		xfer->status = USBD_STALLED;
		break;
	case -ETIMEDOUT:
		xfer->status = USBD_TIMEOUT;
		break;
	case -EPROTO:
		xfer->status = USBD_INVAL;
		break;
	case -EIO:
		xfer->status = USBD_IOERROR;
		break;
	case -EOVERFLOW:
		xfer->status = USBD_IOERROR;
		break;
	default:
		printf("%s: unknown error status %d\n", __func__, status);
	}

	if (xfertype == UE_ISOCHRONOUS ||
	    xfertype == UE_INTERRUPT) {
		struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);

		dwc2_free_bus_bandwidth(hsotg,
					dwc2_hcd_get_ep_bandwidth(hsotg, dpipe),
					xfer);
	}

	qtd->urb = NULL;
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);

	MUTEX_ASSERT_LOCKED(&hsotg->lock);

	TAILQ_INSERT_TAIL(&sc->sc_complete, dxfer, xnext);

	mtx_leave(&hsotg->lock);
	usb_schedsoftintr(&sc->sc_bus);
	mtx_enter(&hsotg->lock);
}


int
_dwc2_hcd_start(struct dwc2_hsotg *hsotg)
{
	dev_dbg(hsotg->dev, "DWC OTG HCD START\n");

	mtx_enter(&hsotg->lock);

	hsotg->op_state = OTG_STATE_A_HOST;

	dwc2_hcd_reinit(hsotg);

	/* Try to enable port. */
	dwc2_handle_hcd_intr(hsotg);

	/*XXXNH*/
	delay(50);

	mtx_leave(&hsotg->lock);
	return 0;
}

int dwc2_host_is_b_hnp_enabled(struct dwc2_hsotg *hsotg)
{

	return false;
}
@


1.45
log
@Replace remaining SPLUSBCHECK by a splsoftassert(IPL_SOFTUSB).

USB is the last real user of IPL_SOFTNET.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.44 2017/04/30 16:45:46 mpi Exp $	*/
a31 5

#if 0
#include <sys/cdefs.h>
__KERNEL_RCSID(0, "$NetBSD: dwc2.c,v 1.32 2014/09/02 23:26:20 macallan Exp $");
#endif
@


1.44
log
@Rename Debugger() into db_enter().

Using a name with the 'db_' prefix makes it invisible from the dynamic
profiler.

ok deraadt@@, kettenis@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.43 2017/03/10 11:18:48 mpi Exp $	*/
d535 1
a535 1
	SPLUSBCHECK;
@


1.43
log
@Fix a use-after-free when sending root hub control transfers.

*_root_ctrl_start() routines are synchronous and all end up calling
usb_transfer_complete() in the non-error case.  After calling this
function it is unsafe to dereference ``xfer'' since the transfer
callback has been called.  So returning USBD_IN_PROGRESS is wrong in
this case since transfers are always completed at this point.

So return USBD_NORMAL_COMPLETION or the corresponding error code if
something wrong happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.42 2017/03/10 09:14:06 mpi Exp $	*/
d1364 1
a1364 1
/* Debugger(); */
@


1.42
log
@Move per HC polling code to the stack.

This code contains a use-after-free which be addressed in an upcoming
diff.

This fix xhci(4) polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.41 2017/02/16 14:09:00 visa Exp $	*/
d844 1
a844 1
	return USBD_IN_PROGRESS;
@


1.41
log
@Remove an unnecessary NULL pointer check.

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.40 2017/02/12 17:41:17 visa Exp $	*/
a96 1
STATIC void		dwc2_waitintr(struct dwc2_softc *, struct usbd_xfer *);
a407 32
dwc2_waitintr(struct dwc2_softc *sc, struct usbd_xfer *xfer)
{
	struct dwc2_hsotg *hsotg = sc->sc_hsotg;
	uint32_t intrs;
	int timo;

	xfer->status = USBD_IN_PROGRESS;
	for (timo = xfer->timeout; timo >= 0; timo--) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_dying)
			break;
		intrs = dwc2_read_core_intr(hsotg);

		DPRINTFN(15, "0x%08x\n", intrs);

		if (intrs) {
			mtx_enter(&hsotg->lock);
			dwc2_interrupt(sc);
			mtx_leave(&hsotg->lock);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	DPRINTF("timeout\n");

	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
}

STATIC void
a956 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a963 3
	if (sc->sc_bus.use_polling)
		dwc2_waitintr(sc, xfer);

a1009 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a1016 3
	if (sc->sc_bus.use_polling)
		dwc2_waitintr(sc, xfer);

a1064 2
	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer)
	struct dwc2_softc *sc = DWC2_DPIPE2SC(dpipe);
a1068 3

	if (sc->sc_bus.use_polling)
		dwc2_waitintr(sc, xfer);
@


1.40
log
@Replace dummy mutex asserts with real ones.

OK stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.39 2017/02/04 19:22:42 guenther Exp $	*/
d1439 2
a1440 1
int dwc2_intr(void *p)
d1443 1
a1443 1
	struct dwc2_hsotg *hsotg;
a1445 4
	if (sc == NULL)
		return 0;

	hsotg = sc->sc_hsotg;
@


1.39
log
@Prefer <sys/endian.h> to <machine/endian.h>

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.38 2016/09/24 12:59:42 kettenis Exp $	*/
d1706 1
a1706 1
	KASSERT(mtx_owned(&hsotg->lock));
@


1.38
log
@Remove unused functions.

ok jmatthew@@, visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.37 2016/09/15 02:00:18 dlg Exp $	*/
d50 1
a55 1
#include <machine/endian.h>
@


1.37
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.36 2015/12/23 12:38:40 visa Exp $	*/
a1494 50

bool
dwc2_shutdown(struct device *self, int flags)
{
	struct dwc2_softc *sc = (void *)self;

	sc = sc;

	return true;
}

void
dwc2_childdet(struct device *self, struct device *child)
{
	struct dwc2_softc *sc = (void *)self;

	sc = sc;
}

int
dwc2_activate(struct device *self, int act)
{
	struct dwc2_softc *sc = (void *)self;

	sc = sc;

	return 0;
}

#if 0
bool
dwc2_resume(struct device *dv, const pmf_qual_t *qual)
{
	struct dwc2_softc *sc = (void *)dv;

	sc = sc;

	return true;
}

bool
dwc2_suspend(struct device *dv, const pmf_qual_t *qual)
{
	struct dwc2_softc *sc = (void *)dv;

	sc = sc;

	return true;
}
#endif
@


1.36
log
@Drop unused goto label.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.35 2015/12/18 17:23:14 mmcc Exp $	*/
d1566 1
a1566 1
	pool_init(&sc->sc_xferpool, sizeof(struct dwc2_xfer), 0, 0, 0,
d1568 1
a1568 2
	pool_setipl(&sc->sc_xferpool, IPL_USB);
	pool_init(&sc->sc_qhpool, sizeof(struct dwc2_qh), 0, 0, 0,
d1570 1
a1570 2
	pool_setipl(&sc->sc_qhpool, IPL_USB);
	pool_init(&sc->sc_qtdpool, sizeof(struct dwc2_qtd), 0, 0, 0,
a1571 1
	pool_setipl(&sc->sc_qtdpool, IPL_USB);
@


1.35
log
@Remove two error-on-NULL conditions for allocations that can't fail.

ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.34 2015/09/03 15:14:08 visa Exp $	*/
d1586 1
a1586 1
		goto fail2;
d1591 1
a1591 1
fail2:
a1592 1
fail1:
@


1.34
log
@Properly cancel any pending USB abort task when aborting a transfer
and skip completed transfers in dwc2_abort_xfer(). This fixes some
timeout-related crashes.

Feedback and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.33 2015/09/03 14:22:27 visa Exp $	*/
a1577 4
	if (sc->sc_hsotg == NULL) {
		err = ENOMEM;
		goto fail1;
	}
@


1.33
log
@Remove the abort_task field in struct dwc2_xfer. There is an identical
field in struct usbd_xfer which is part of dwc2_xfer.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.32 2015/09/03 12:55:54 visa Exp $	*/
d575 1
d592 9
a603 1
	mtx_enter(&hsotg->lock);
d608 1
d1762 1
@


1.32
log
@Remove sc->sc_lock and add several splusb()'s in dwc2, to avoid a
possible lock recursion panic on transfer timeout. The lock is not
needed yet because the USB stack is not MP-safe.

ok mpi@@, "makes sense" jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.31 2015/06/28 11:48:18 jmatthew Exp $	*/
a443 2
	struct dwc2_xfer *dxfer = DWC2_XFER2DXFER(xfer);
// 	struct dwc2_pipe *dpipe = DWC2_XFER2DPIPE(xfer);
d446 1
a446 1
	DPRINTF("dxfer=%p\n", dxfer);
d454 1
a454 1
	usb_init_task(&dxfer->abort_task, dwc2_timeout_task, addr,
d456 1
a456 1
	usb_add_task(dxfer->xfer.pipe->device, &dxfer->abort_task);
@


1.31
log
@Convert list_head lists into TAILQs and LISTs and fix up header includes
so we can build dwc2 without extra stuff.

tested by several edgerouter lite owners, ok jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.30 2015/06/26 11:17:34 mpi Exp $	*/
a356 1
	mtx_enter(&sc->sc_lock);
a360 1
		mtx_leave(&sc->sc_lock);
a372 1
	mtx_leave(&sc->sc_lock);
a382 2
	KASSERT(sc->sc_bus.use_polling || mtx_owned(&sc->sc_lock));

a435 1
	mtx_enter(&sc->sc_lock);
a437 1
	mtx_leave(&sc->sc_lock);
d451 1
a451 3
		mtx_enter(&sc->sc_lock);
		dwc2_abort_xfer(&dxfer->xfer, USBD_TIMEOUT);
		mtx_leave(&sc->sc_lock);
d465 1
a465 1
 	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
d469 1
a469 1
	mtx_enter(&sc->sc_lock);
d471 1
a471 1
	mtx_leave(&sc->sc_lock);
d554 1
a554 5
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = DWC2_PIPE2SC(pipe);
#endif

	KASSERT(mtx_owned(&sc->sc_lock));
d570 2
a573 3
	KASSERT(mtx_owned(&sc->sc_lock));
	//KASSERT(!cpu_intr_p() && !cpu_softintr_p());

a715 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a717 1
	mtx_enter(&sc->sc_lock);
a718 1
	mtx_leave(&sc->sc_lock);
d732 1
a732 1
	int value, index, l, totlen;
d864 1
a864 1
	mtx_enter(&sc->sc_lock);
d867 1
a867 1
	mtx_leave(&sc->sc_lock);
a898 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a903 1
	mtx_enter(&sc->sc_lock);
a904 1
	mtx_leave(&sc->sc_lock);
a921 1
	mtx_enter(&sc->sc_lock);
a923 1
	mtx_leave(&sc->sc_lock);
a935 1
	KASSERT(mtx_owned(&sc->sc_lock));
a950 2
	KASSERT(mtx_owned(&sc->sc_lock));

a965 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a970 1
	mtx_enter(&sc->sc_lock);
a971 1
	mtx_leave(&sc->sc_lock);
a986 1
	mtx_enter(&sc->sc_lock);
a988 1
	mtx_leave(&sc->sc_lock);
a998 5
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
#endif
	KASSERT(mtx_owned(&sc->sc_lock));

a1022 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a1027 1
	mtx_enter(&sc->sc_lock);
a1028 1
	mtx_leave(&sc->sc_lock);
d1043 1
a1043 1
	mtx_enter(&sc->sc_lock);
a1045 1
	mtx_leave(&sc->sc_lock);
d1056 1
a1056 4
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
#endif
	KASSERT(mtx_owned(&sc->sc_lock));
a1057 1
	DPRINTF("xfer=%p\n", xfer);
a1081 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a1086 1
	mtx_enter(&sc->sc_lock);
a1087 1
	mtx_leave(&sc->sc_lock);
a1101 1
	mtx_enter(&sc->sc_lock);
a1103 1
	mtx_leave(&sc->sc_lock);
a1114 5
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
#endif

	KASSERT(mtx_owned(&sc->sc_lock));
a1147 1
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
a1152 1
	mtx_enter(&sc->sc_lock);
a1153 1
	mtx_leave(&sc->sc_lock);
a1171 1
	mtx_enter(&sc->sc_lock);
a1173 1
	mtx_leave(&sc->sc_lock);
d1181 1
a1181 4
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = DWC2_XFER2SC(xfer);
#endif
	KASSERT(mtx_owned(&sc->sc_lock));
a1182 1
	DPRINTF("xfer=%p\n", xfer);
a1340 3
	/* XXXNH bring down from callers?? */
// 	mtx_enter(&sc->sc_lock);

a1378 2
// 	mtx_leave(&sc->sc_lock);

a1410 1
	mtx_enter(&sc->sc_lock);
a1428 1
	mtx_leave(&sc->sc_lock);
a1547 2

	mtx_init(&sc->sc_lock, IPL_SOFTUSB);
@


1.30
log
@Revert previous.  uvideo checks the transfered length of every frame and
this break some devices.

As found the hardway by Hugo Sastre via sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.29 2015/06/22 12:56:55 mpi Exp $	*/
d1469 1
a1469 1
Debugger();
@


1.29
log
@Do not update frame lengths to reflect what has really been transfered
when an isochronous transfer is done.

Frame lengths are just input values and no driver mess with them.

ok ratchov@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.28 2015/06/08 08:47:38 jmatthew Exp $	*/
a1773 1
		uint32_t len;
d1778 4
a1781 3
			len = dwc2_hcd_urb_get_iso_desc_actual_length(qtd->urb,
			    i);
			xfer->actlen += len;
@


1.28
log
@rearrange delayed_work to avoid the use of container_of while leaving it in
more or less the same shape.

ok uebayasi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.27 2015/06/08 00:58:23 jmatthew Exp $	*/
d1774 1
d1779 3
a1781 4
			xfer->frlengths[i] =
				dwc2_hcd_urb_get_iso_desc_actual_length(
						qtd->urb, i);
			xfer->actlen += xfer->frlengths[i];
@


1.27
log
@refuse to do polled isochronous transfers, as other usb controller drivers do

requested by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.26 2015/06/08 00:46:33 jmatthew Exp $	*/
d1699 1
a1699 1
	task_set(&dw->work, dw->dw_fn, arg);
@


1.26
log
@Ensure polled bulk, control and interrupt transfers actually poll, fixing
panics on shutdown with various usb sticks.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.25 2015/03/19 10:39:17 mpi Exp $	*/
d1224 4
a1231 3

	if (sc->sc_bus.use_polling)
		dwc2_waitintr(sc, xfer);
@


1.25
log
@Let it compile.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.24 2015/03/19 10:31:29 mpi Exp $	*/
a1019 3
	if (err)
		return err;

d1023 1
a1023 1
	return USBD_IN_PROGRESS;
d1086 3
a1152 3
	if (err)
		return err;

d1156 1
a1156 1
	return USBD_IN_PROGRESS;
@


1.24
log
@Abort tasks are run in their own thead, that's why they need a special
type, from Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.23 2015/03/19 10:29:16 mpi Exp $	*/
d1032 1
a1032 1
#ifdef DWC2_DEBUG
d1095 1
a1095 1
#ifdef DWC2_DEBUG
d1166 1
a1166 1
#ifdef DWC2_DEBUG
d1241 1
a1241 1
#ifdef DWC2_DEBUG
@


1.23
log
@Use the same workaround as ehci(4) and ohci(4) in setaddr() to deal with
half configured control pipe, from Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: dwc2.c,v 1.22 2015/02/14 05:52:19 uebayasi Exp $	*/
d466 1
a466 1
	    USB_TASK_TYPE_GENERIC);
@


1.22
log
@Handle (poll) HCD interrupt right after initialization to immediately mark
ports as enabled/connected.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d94 1
d176 1
d273 23
@


1.21
log
@Provide interface for external DMA address configuration.
@
text
@d1824 3
@


1.20
log
@De-static for backtracing, but using #define to not change indent (for now).
@
text
@d1643 7
@


1.19
log
@Don't panic even if parent port doesn't exist.
@
text
@d93 4
a96 4
static usbd_status	dwc2_open(struct usbd_pipe *);
static void		dwc2_poll(struct usbd_bus *);
static void		dwc2_softintr(void *);
static void		dwc2_waitintr(struct dwc2_softc *, struct usbd_xfer *);
d99 2
a100 2
static usbd_status	dwc2_allocm(struct usbd_bus *, struct usb_dma *, uint32_t);
static void		dwc2_freem(struct usbd_bus *, struct usb_dma *);
d103 2
a104 2
static struct usbd_xfer	*dwc2_allocx(struct usbd_bus *);
static void		dwc2_freex(struct usbd_bus *, struct usbd_xfer *);
d106 1
a106 1
static void		dwc2_get_lock(struct usbd_bus *, struct mutex **);
d109 43
a151 43
static usbd_status	dwc2_root_ctrl_transfer(struct usbd_xfer *);
static usbd_status	dwc2_root_ctrl_start(struct usbd_xfer *);
static void		dwc2_root_ctrl_abort(struct usbd_xfer *);
static void		dwc2_root_ctrl_close(struct usbd_pipe *);
static void		dwc2_root_ctrl_done(struct usbd_xfer *);

static usbd_status	dwc2_root_intr_transfer(struct usbd_xfer *);
static usbd_status	dwc2_root_intr_start(struct usbd_xfer *);
static void		dwc2_root_intr_abort(struct usbd_xfer *);
static void		dwc2_root_intr_close(struct usbd_pipe *);
static void		dwc2_root_intr_done(struct usbd_xfer *);

static usbd_status	dwc2_device_ctrl_transfer(struct usbd_xfer *);
static usbd_status	dwc2_device_ctrl_start(struct usbd_xfer *);
static void		dwc2_device_ctrl_abort(struct usbd_xfer *);
static void		dwc2_device_ctrl_close(struct usbd_pipe *);
static void		dwc2_device_ctrl_done(struct usbd_xfer *);

static usbd_status	dwc2_device_bulk_transfer(struct usbd_xfer *);
static usbd_status	dwc2_device_bulk_start(struct usbd_xfer *);
static void		dwc2_device_bulk_abort(struct usbd_xfer *);
static void		dwc2_device_bulk_close(struct usbd_pipe *);
static void		dwc2_device_bulk_done(struct usbd_xfer *);

static usbd_status	dwc2_device_intr_transfer(struct usbd_xfer *);
static usbd_status	dwc2_device_intr_start(struct usbd_xfer *);
static void		dwc2_device_intr_abort(struct usbd_xfer *);
static void		dwc2_device_intr_close(struct usbd_pipe *);
static void		dwc2_device_intr_done(struct usbd_xfer *);

static usbd_status	dwc2_device_isoc_transfer(struct usbd_xfer *);
static usbd_status	dwc2_device_isoc_start(struct usbd_xfer *);
static void		dwc2_device_isoc_abort(struct usbd_xfer *);
static void		dwc2_device_isoc_close(struct usbd_pipe *);
static void		dwc2_device_isoc_done(struct usbd_xfer *);

static usbd_status	dwc2_device_start(struct usbd_xfer *);

static void		dwc2_close_pipe(struct usbd_pipe *);
static void		dwc2_abort_xfer(struct usbd_xfer *, usbd_status);

static void		dwc2_device_clear_toggle(struct usbd_pipe *);
static void		dwc2_noop(struct usbd_pipe *pipe);
d153 2
a154 2
static int		dwc2_interrupt(struct dwc2_softc *);
static void		dwc2_rhc(void *);
d156 2
a157 2
static void		dwc2_timeout(void *);
static void		dwc2_timeout_task(void *);
d159 1
a159 1
static inline void
d165 1
a165 1
static inline void
d173 1
a173 1
static struct usbd_bus_methods dwc2_bus_methods = {
d188 1
a188 1
static struct usbd_pipe_methods dwc2_root_ctrl_methods = {
d197 1
a197 1
static struct usbd_pipe_methods dwc2_root_intr_methods = {
d206 1
a206 1
static struct usbd_pipe_methods dwc2_device_ctrl_methods = {
d215 1
a215 1
static struct usbd_pipe_methods dwc2_device_intr_methods = {
d224 1
a224 1
static struct usbd_pipe_methods dwc2_device_bulk_methods = {
d233 1
a233 1
static struct usbd_pipe_methods dwc2_device_isoc_methods = {
d243 1
a243 1
static usbd_status
d257 1
a257 1
static void
d315 1
a315 1
static void
d324 1
a324 1
static void
d353 1
a353 1
static void
d388 1
a388 1
static void
d422 1
a422 1
static void
d445 1
a445 1
static void
d520 1
a520 1
static void
d535 1
a535 1
static void
d548 1
a548 1
static void
d617 1
a617 1
static void
d623 1
a623 1
static void
d636 1
a636 1
static const usb_device_descriptor_t dwc2_devd = {
d656 1
a656 1
static const struct dwc2_config_desc dwc2_confd = {
d691 1
a691 1
static const usb_hub_descriptor_t dwc2_hubd = {
d702 1
a702 1
static usbd_status
d717 1
a717 1
static usbd_status
d864 1
a864 1
static void
d872 1
a872 1
static void
d880 1
a880 1
static void
d888 1
a888 1
static usbd_status
d907 1
a907 1
static usbd_status
d926 1
a926 1
static void
d942 1
a942 1
static void
d954 1
a954 1
static void
d963 1
a963 1
static usbd_status
d982 1
a982 1
static usbd_status
d1004 1
a1004 1
static void
d1016 1
a1016 1
static void
d1024 1
a1024 1
static void
d1033 1
a1033 1
static usbd_status
d1052 1
a1052 1
static usbd_status
d1067 1
a1067 1
static void
d1079 1
a1079 1
static void
d1088 1
a1088 1
static void
d1097 1
a1097 1
static usbd_status
d1116 1
a1116 1
static usbd_status
d1138 1
a1138 1
static void
d1153 1
a1153 1
static void
d1162 1
a1162 1
static void
d1647 1
a1647 1
static const char * const intnames[32] = {
@


1.18
log
@- Fix thinko about struct usbd_xfer allocation.
- Use bus_dma_tag_t held in struct usbd_bus.
@
text
@d1680 4
a1683 2
	*hub_addr = dev->myhsport->parent->address;
 	*hub_port = dev->myhsport->portno;
@


1.17
log
@Fix debug build, etc.
@
text
@d289 1
a289 1
		dxfer->xfer->busy_free = XFER_ONQU;
d366 2
a367 2
		KASSERTMSG(!timeout_pending(&dxfer->xfer->timeout_handle), 
		    "xfer %p pipe %p\n", dxfer, dxfer->xfer->pipe);
d382 1
a382 1
		usb_transfer_complete(dxfer->xfer);
d434 1
a434 1
		dwc2_abort_xfer(dxfer->xfer, USBD_TIMEOUT);
d442 1
a442 1
	usb_add_task(dxfer->xfer->pipe->device, &dxfer->abort_task);
@


1.16
log
@Adjust usb(9) API differences to at least compile.
@
text
@d151 1
a151 1
static void		dwc2_noop(struct usbd_pipe * pipe);
d459 1
a459 1
dwc2_open(struct usbd_pipe * pipe)
d536 1
a536 1
dwc2_close_pipe(struct usbd_pipe * pipe)
d538 1
a538 1
#ifdef DWC2_DEBUG
d618 1
a618 1
dwc2_noop(struct usbd_pipe * pipe)
d624 1
a624 1
dwc2_device_clear_toggle(struct usbd_pipe * pipe)
d627 1
a627 1
	DPRINTF("toggle %d -> 0", pipe->endpoint->datatoggle);
d873 1
a873 1
dwc2_root_ctrl_close(struct usbd_pipe * pipe)
d943 1
a943 1
dwc2_root_intr_close(struct usbd_pipe * pipe)
d1017 1
a1017 1
dwc2_device_ctrl_close(struct usbd_pipe * pipe)
d1080 1
a1080 1
dwc2_device_bulk_close(struct usbd_pipe * pipe)
d1154 1
a1154 1
dwc2_device_intr_close(struct usbd_pipe * pipe)
d1226 1
a1226 1
dwc2_device_isoc_close(struct usbd_pipe * pipe)
d1300 3
a1302 2
		DPRINTFN(3, "req = %p dma = %" PRIxBUSADDR " len %d dir %s\n",
		    KERNADDR(&dpipe->req_dma, 0), DMAADDR(&dpipe->req_dma, 0),
d1599 1
a1599 2
	sc->sc_rhc_si = softintr_establish(IPL_SOFTNET,
	    dwc2_rhc, sc);
@


1.15
log
@Adjust various kernel API differences.
@
text
@d98 1
d101 1
d103 1
a103 1
static struct usbd_xfer *	dwc2_allocx(struct usbd_bus *);
d105 1
d107 1
a158 2


d173 1
a173 1
static const struct usbd_bus_methods dwc2_bus_methods = {
d177 1
d180 1
d183 1
d185 1
d188 1
a188 1
static const struct usbd_pipe_methods dwc2_root_ctrl_methods = {
d197 1
a197 1
static const struct usbd_pipe_methods dwc2_root_intr_methods = {
d206 1
a206 1
static const struct usbd_pipe_methods dwc2_device_ctrl_methods = {
d215 1
a215 1
static const struct usbd_pipe_methods dwc2_device_intr_methods = {
d224 1
a224 1
static const struct usbd_pipe_methods dwc2_device_bulk_methods = {
d233 1
a233 1
static const struct usbd_pipe_methods dwc2_device_isoc_methods = {
d242 1
d270 1
d288 2
a289 2
#ifdef DIAGNOSTIC
		dxfer->xfer.busy_free = XFER_BUSY;
d303 2
a304 2
#ifdef DIAGNOSTIC
	if (xfer->busy_free != XFER_BUSY) {
d314 1
d322 1
d366 2
a367 2
		KASSERTMSG(!timeout_pending(&dxfer->xfer.timeout_handle), 
		    "xfer %p pipe %p\n", dxfer, dxfer->xfer.pipe);
d374 1
a374 1
		if (dxfer->xfer.hcflags & UXFER_ABORTING) {
d382 1
a382 1
		usb_transfer_complete(&dxfer->xfer);
d434 1
a434 1
		dwc2_abort_xfer(&dxfer->xfer, USBD_TIMEOUT);
d441 2
a442 3
	    USB_TASKQ_MPSAFE);
	usb_add_task(dxfer->xfer.pipe->device, &dxfer->abort_task,
	    USB_TASKQ_HC);
d538 2
a539 2
#ifdef DIAGNOSTIC
	struct dwc2_softc *sc = pipe->device->bus->hci_private;
d574 1
a574 1
	if (xfer->hcflags & UXFER_ABORTING) {
d576 2
a577 2
		xfer->hcflags |= UXFER_ABORTWAIT;
		while (xfer->hcflags & UXFER_ABORTING)
d586 1
a586 1
	xfer->hcflags |= UXFER_ABORTING;
d608 2
a609 2
	wake = xfer->hcflags & UXFER_ABORTWAIT;
	xfer->hcflags &= ~(UXFER_ABORTING | UXFER_ABORTWAIT);
d784 1
a784 1
			totlen = usb_makelangtbl(sd, len);
d787 1
a787 1
			totlen = usb_makestrdesc(sd, len, sc->sc_vendor);
d790 1
a790 1
			totlen = usb_makestrdesc(sd, len, "DWC2 root hub");
d1007 1
a1007 1
#ifdef DIAGNOSTIC
d1070 1
a1070 1
#ifdef DIAGNOSTIC
d1120 1
a1120 2
	struct usbd_device *dev = dpipe->pipe.device;
	struct dwc2_softc *sc = dev->bus->hci_private;
d1141 1
a1141 1
#ifdef DIAGNOSTIC
d1199 1
a1199 2
	struct usbd_device *dev = dpipe->pipe.device;
	struct dwc2_softc *sc = dev->bus->hci_private;
d1216 1
a1216 1
#ifdef DIAGNOSTIC
d1328 1
a1328 1
		    flags |= URB_SEND_ZERO_PACKET;
d1466 1
a1466 1
		if (!(xfer->hcflags & UXFER_ABORTING)) {
d1561 1
d1581 1
a1588 1
	sc->sc_bus.hci_private = sc;
d1601 4
a1604 2
	usb_setup_reserve(sc->sc_dev, &sc->sc_dma_reserve, sc->sc_bus.dmatag,
		USB_MEM_RESERVE);
d1624 1
a1624 1
	sc->sc_hsotg->dev = sc->sc_dev;
@


1.14
log
@Convert tsleep(9)/wakeup(9) usages.
@
text
@d552 1
a552 1
	KASSERT(!cpu_intr_p() && !cpu_softintr_p());
d1481 1
a1481 1
	if (sc->sc_dying || !device_has_power(sc->sc_dev))
d1529 1
a1529 1
	struct dwc2_softc *sc = device_private(self);
d1539 1
a1539 1
	struct dwc2_softc *sc = device_private(self);
d1545 1
a1545 1
dwc2_activate(struct device *self, enum devact act)
d1547 1
a1547 1
	struct dwc2_softc *sc = device_private(self);
d1557 1
a1557 1
	struct dwc2_softc *sc = device_private(dv);
d1567 1
a1567 1
	struct dwc2_softc *sc = device_private(dv);
d1586 1
a1586 1
	mtx_init(&sc->sc_lock, MUTEX_DEFAULT, IPL_SOFTUSB);
d1590 1
a1590 1
	sc->sc_rhc_si = softintr_establish(SOFTINT_NET | SOFTINT_MPSAFE,
@


1.13
log
@Whitespace.
@
text
@d365 1
a365 1
			cv_broadcast(&dxfer->xfer.hccv);
d569 1
a569 1
			cv_wait(&xfer->hccv, &sc->sc_lock);
d604 1
a604 1
		cv_broadcast(&xfer->hccv);
d1463 1
a1463 1
		cv_broadcast(&xfer->hccv);
@


1.12
log
@Convert timeout(9)/taskq(9) usages.
@
text
@d253 1
a253 1
        struct dwc2_softc *sc = DWC2_BUS2SC(bus);
d257 5
a261 5
        if (dma->block->flags & USB_DMA_RESERVE) {
                usb_reserve_freem(&sc->sc_dma_reserve, dma);
                return;
        }
        usb_freemem(&sc->sc_bus, dma);
d356 1
a356 1
    		KASSERTMSG(!timeout_pending(&dxfer->xfer.timeout_handle), 
d833 1
a833 1
	    	/* Hub requests - XXXNH len check? */
d1083 1
a1083 1
    	DPRINTF("xfer=%p\n", xfer);
d1241 1
a1241 1
        struct dwc2_hcd_urb *dwc2_urb;
d1306 1
a1306 1
		    return USBD_NOMEM;
d1330 1
a1330 1
    		dwc2_urb->usbdma = &xfer->dmabuf;
d1690 1
a1690 1
                        int status)
@


1.11
log
@Convert malloc(9)/free(9) usages.
@
text
@d556 1
a556 1
		timeout_stop(&xfer->timeout_handle);
d580 1
a580 1
	timeout_stop(&xfer->timeout_handle);
d1659 2
a1660 1
	taskq_enqueue(dw->dw_wq, &dw->work, NULL);
d1782 1
a1782 1
	timeout_stop(&xfer->timeout_handle);
@


1.10
log
@Convert pool(9) usages.
@
text
@d1606 2
a1607 1
	sc->sc_hsotg = malloc(sizeof(struct dwc2_hsotg), KM_SLEEP);
d1626 1
a1626 1
	free(sc->sc_hsotg, sizeof(struct dwc2_hsotg));
@


1.9
log
@s/device_t/struct device */
@
text
@d273 1
a273 1
	dxfer = pool_get(sc->sc_xferpool, PR_NOWAIT);
d303 1
a303 1
	pool_put(sc->sc_xferpool, xfer);
d1596 9
a1604 6
	sc->sc_xferpool = pool_init(sizeof(struct dwc2_xfer), 0, 0, 0,
	    "dwc2xfer", NULL, IPL_USB, NULL, NULL, NULL);
	sc->sc_qhpool = pool_init(sizeof(struct dwc2_qh), 0, 0, 0,
	    "dwc2qh", NULL, IPL_USB, NULL, NULL, NULL);
	sc->sc_qtdpool = pool_init(sizeof(struct dwc2_qtd), 0, 0, 0,
	    "dwc2qtd", NULL, IPL_USB, NULL, NULL, NULL);
@


1.8
log
@s/mutex/mtx/
s/pool_cache/pool/
s/callout/timeout/
s/kmem/malloc/
s/workqueue/taskq/
s/softint/softintr/
@
text
@d452 1
a452 1
	struct usbd_device * dev = pipe->device;
d574 1
a574 1
	 * Step 1: Make the stack ignore it and stop the callout.
d1111 1
a1111 1
	struct usbd_device * dev = dpipe->pipe.device;
d1191 1
a1191 1
	struct usbd_device * dev = dpipe->pipe.device;
d1243 1
a1243 1
	struct usbd_device * dev = xfer->pipe->device;
d1527 1
a1527 1
dwc2_shutdown(device_t self, int flags)
d1537 1
a1537 1
dwc2_childdet(device_t self, device_t child)
d1545 1
a1545 1
dwc2_activate(device_t self, enum devact act)
d1555 1
a1555 1
dwc2_resume(device_t dv, const pmf_qual_t *qual)
d1565 1
a1565 1
dwc2_suspend(device_t dv, const pmf_qual_t *qual)
d1651 1
a1651 1
dw_callout(void *arg)
d1663 1
a1663 1
	struct usbd_device * dev = dpipe->pipe.device;
d1673 1
a1673 1
	struct usbd_device * dev = dpipe->pipe.device;
@


1.7
log
@Whitespace.
@
text
@d103 1
a103 1
static void		dwc2_get_lock(struct usbd_bus *, kmutex_t **);
d273 1
a273 1
	dxfer = pool_cache_get(sc->sc_xferpool, PR_NOWAIT);
d303 1
a303 1
	pool_cache_put(sc->sc_xferpool, xfer);
d307 1
a307 1
dwc2_get_lock(struct usbd_bus *bus, kmutex_t **lock)
d322 1
a322 1
	mutex_enter(&sc->sc_lock);
d327 1
a327 1
		mutex_exit(&sc->sc_lock);
d340 1
a340 1
	mutex_exit(&sc->sc_lock);
d351 1
a351 1
	KASSERT(sc->sc_bus.use_polling || mutex_owned(&sc->sc_lock));
d353 1
a353 1
	mutex_spin_enter(&hsotg->lock);
d356 1
a356 1
    		KASSERTMSG(!callout_pending(&dxfer->xfer.timeout_handle), 
d371 1
a371 1
		mutex_spin_exit(&hsotg->lock);
d373 1
a373 1
		mutex_spin_enter(&hsotg->lock);
d375 1
a375 1
	mutex_spin_exit(&hsotg->lock);
d395 1
a395 1
			mutex_spin_enter(&hsotg->lock);
d397 1
a397 1
			mutex_spin_exit(&hsotg->lock);
d406 1
a406 1
	mutex_enter(&sc->sc_lock);
d409 1
a409 1
	mutex_exit(&sc->sc_lock);
d423 1
a423 1
		mutex_enter(&sc->sc_lock);
d425 1
a425 1
		mutex_exit(&sc->sc_lock);
d444 1
a444 1
	mutex_enter(&sc->sc_lock);
d446 1
a446 1
	mutex_exit(&sc->sc_lock);
d517 1
a517 1
	mutex_spin_enter(&hsotg->lock);
d519 1
a519 1
	mutex_spin_exit(&hsotg->lock);
d533 1
a533 1
	KASSERT(mutex_owned(&sc->sc_lock));
d551 1
a551 1
	KASSERT(mutex_owned(&sc->sc_lock));
d556 1
a556 1
		callout_stop(&xfer->timeout_handle);
d576 1
a576 1
	mutex_spin_enter(&hsotg->lock);
d580 1
a580 1
	callout_stop(&xfer->timeout_handle);
d594 1
a594 1
	mutex_spin_exit(&hsotg->lock);
d699 1
a699 1
	mutex_enter(&sc->sc_lock);
d701 1
a701 1
	mutex_exit(&sc->sc_lock);
d847 1
a847 1
	mutex_enter(&sc->sc_lock);
d850 1
a850 1
	mutex_exit(&sc->sc_lock);
d888 1
a888 1
	mutex_enter(&sc->sc_lock);
d890 1
a890 1
	mutex_exit(&sc->sc_lock);
d908 1
a908 1
	mutex_enter(&sc->sc_lock);
d911 1
a911 1
	mutex_exit(&sc->sc_lock);
d924 1
a924 1
	KASSERT(mutex_owned(&sc->sc_lock));
d940 1
a940 1
	KASSERT(mutex_owned(&sc->sc_lock));
d963 1
a963 1
	mutex_enter(&sc->sc_lock);
d965 1
a965 1
	mutex_exit(&sc->sc_lock);
d981 1
a981 1
	mutex_enter(&sc->sc_lock);
d984 1
a984 1
	mutex_exit(&sc->sc_lock);
d1001 1
a1001 1
	KASSERT(mutex_owned(&sc->sc_lock));
d1033 1
a1033 1
	mutex_enter(&sc->sc_lock);
d1035 1
a1035 1
	mutex_exit(&sc->sc_lock);
d1050 1
a1050 1
	mutex_enter(&sc->sc_lock);
d1053 1
a1053 1
	mutex_exit(&sc->sc_lock);
d1064 1
a1064 1
	KASSERT(mutex_owned(&sc->sc_lock));
d1097 1
a1097 1
	mutex_enter(&sc->sc_lock);
d1099 1
a1099 1
	mutex_exit(&sc->sc_lock);
d1115 1
a1115 1
	mutex_enter(&sc->sc_lock);
d1118 1
a1118 1
	mutex_exit(&sc->sc_lock);
d1137 1
a1137 1
	KASSERT(mutex_owned(&sc->sc_lock));
d1177 1
a1177 1
	mutex_enter(&sc->sc_lock);
d1179 1
a1179 1
	mutex_exit(&sc->sc_lock);
d1195 1
a1195 1
	mutex_enter(&sc->sc_lock);
d1198 1
a1198 1
	mutex_exit(&sc->sc_lock);
d1212 1
a1212 1
	KASSERT(mutex_owned(&sc->sc_lock));
d1262 1
a1262 1
		mutex_spin_enter(&hsotg->lock);
d1265 1
a1265 1
		mutex_spin_exit(&hsotg->lock);
d1373 1
a1373 1
// 	mutex_enter(&sc->sc_lock);
d1392 1
a1392 1
	mutex_spin_enter(&hsotg->lock);
d1395 1
a1395 1
		callout_reset(&xfer->timeout_handle, mstohz(xfer->timeout),
d1411 1
a1411 1
	mutex_spin_exit(&hsotg->lock);
d1413 1
a1413 1
// 	mutex_exit(&sc->sc_lock);
d1433 1
a1433 1
dwc2_worker(struct work *wk, void *priv)
d1447 1
a1447 1
	mutex_enter(&sc->sc_lock);
d1466 1
a1466 1
	mutex_exit(&sc->sc_lock);
d1479 1
a1479 1
	mutex_spin_enter(&hsotg->lock);
d1494 1
a1494 1
	mutex_spin_exit(&hsotg->lock);
d1586 1
a1586 1
	mutex_init(&sc->sc_lock, MUTEX_DEFAULT, IPL_SOFTUSB);
d1590 1
a1590 1
	sc->sc_rhc_si = softint_establish(SOFTINT_NET | SOFTINT_MPSAFE,
d1596 1
a1596 1
	sc->sc_xferpool = pool_cache_init(sizeof(struct dwc2_xfer), 0, 0, 0,
d1598 1
a1598 1
	sc->sc_qhpool = pool_cache_init(sizeof(struct dwc2_qh), 0, 0, 0,
d1600 1
a1600 1
	sc->sc_qtdpool = pool_cache_init(sizeof(struct dwc2_qtd), 0, 0, 0,
d1603 1
a1603 1
	sc->sc_hsotg = kmem_zalloc(sizeof(struct dwc2_hsotg), KM_SLEEP);
d1622 1
a1622 1
	kmem_free(sc->sc_hsotg, sizeof(struct dwc2_hsotg));
d1624 1
a1624 1
	softint_disestablish(sc->sc_rhc_si);
d1655 1
a1655 1
	workqueue_enqueue(dw->dw_wq, &dw->work, NULL);
d1777 1
a1777 1
	callout_stop(&xfer->timeout_handle);
d1779 1
a1779 1
	KASSERT(mutex_owned(&hsotg->lock));
d1783 1
a1783 1
	mutex_spin_exit(&hsotg->lock);
d1785 1
a1785 1
	mutex_spin_enter(&hsotg->lock);
d1794 1
a1794 1
	mutex_spin_enter(&hsotg->lock);
d1803 1
a1803 1
	mutex_spin_exit(&hsotg->lock);
@


1.6
log
@s/usb_dma_t/struct usb_dma */
@
text
@d159 1
a159 1
			    struct usbd_xfer * xfer)
d165 1
a165 1
			struct usbd_xfer * xfer)
d288 1
a288 1
dwc2_freex(struct usbd_bus *bus, struct usbd_xfer * xfer)
d318 1
a318 1
	struct usbd_xfer * xfer;
d379 1
a379 1
dwc2_waitintr(struct dwc2_softc *sc, struct usbd_xfer * xfer)
d415 1
a415 1
	struct usbd_xfer * xfer = addr;
d439 1
a439 1
	struct usbd_xfer * xfer = addr;
d540 1
a540 1
dwc2_abort_xfer(struct usbd_xfer * xfer, usbd_status status)
d694 1
a694 1
dwc2_root_ctrl_transfer(struct usbd_xfer * xfer)
d709 1
a709 1
dwc2_root_ctrl_start(struct usbd_xfer * xfer)
d856 1
a856 1
dwc2_root_ctrl_abort(struct usbd_xfer * xfer)
d872 1
a872 1
dwc2_root_ctrl_done(struct usbd_xfer * xfer)
d880 1
a880 1
dwc2_root_intr_transfer(struct usbd_xfer * xfer)
d899 1
a899 1
dwc2_root_intr_start(struct usbd_xfer * xfer)
d918 1
a918 1
dwc2_root_intr_abort(struct usbd_xfer * xfer)
d946 1
a946 1
dwc2_root_intr_done(struct usbd_xfer * xfer)
d955 1
a955 1
dwc2_device_ctrl_transfer(struct usbd_xfer * xfer)
d974 1
a974 1
dwc2_device_ctrl_start(struct usbd_xfer * xfer)
d996 1
a996 1
dwc2_device_ctrl_abort(struct usbd_xfer * xfer)
d1016 1
a1016 1
dwc2_device_ctrl_done(struct usbd_xfer * xfer)
d1025 1
a1025 1
dwc2_device_bulk_transfer(struct usbd_xfer * xfer)
d1044 1
a1044 1
dwc2_device_bulk_start(struct usbd_xfer * xfer)
d1059 1
a1059 1
dwc2_device_bulk_abort(struct usbd_xfer * xfer)
d1080 1
a1080 1
dwc2_device_bulk_done(struct usbd_xfer * xfer)
d1089 1
a1089 1
dwc2_device_intr_transfer(struct usbd_xfer * xfer)
d1108 1
a1108 1
dwc2_device_intr_start(struct usbd_xfer * xfer)
d1131 1
a1131 1
dwc2_device_intr_abort(struct usbd_xfer * xfer)
d1155 1
a1155 1
dwc2_device_intr_done(struct usbd_xfer * xfer)
d1169 1
a1169 1
dwc2_device_isoc_transfer(struct usbd_xfer * xfer)
d1188 1
a1188 1
dwc2_device_isoc_start(struct usbd_xfer * xfer)
d1207 1
a1207 1
dwc2_device_isoc_abort(struct usbd_xfer * xfer)
d1227 1
a1227 1
dwc2_device_isoc_done(struct usbd_xfer * xfer)
d1235 1
a1235 1
dwc2_device_start(struct usbd_xfer * xfer)
d1440 1
a1440 1
	struct usbd_xfer * xfer = dwork->xfer;
d1661 1
a1661 1
	struct usbd_xfer * xfer = context;
d1671 1
a1671 1
	struct usbd_xfer * xfer = context;
d1687 1
a1687 1
	struct usbd_xfer * xfer;
@


1.5
log
@s/usbd_xfer_handle/struct usbd_xfer */
s/usbd_pipe_handle/struct usbd_pipe */
s/usbd_device_handle/struct usbd_device */
@
text
@d98 2
a99 2
static usbd_status	dwc2_allocm(struct usbd_bus *, usb_dma_t *, uint32_t);
static void		dwc2_freem(struct usbd_bus *, usb_dma_t *);
d237 1
a237 1
dwc2_allocm(struct usbd_bus *bus, usb_dma_t *dma, uint32_t size)
d251 1
a251 1
dwc2_freem(struct usbd_bus *bus, usb_dma_t *dma)
@


1.4
log
@s/Static/static/
@
text
@d93 1
a93 1
static usbd_status	dwc2_open(usbd_pipe_handle);
d96 1
a96 1
static void		dwc2_waitintr(struct dwc2_softc *, usbd_xfer_handle);
d101 2
a102 2
static usbd_xfer_handle	dwc2_allocx(struct usbd_bus *);
static void		dwc2_freex(struct usbd_bus *, usbd_xfer_handle);
d105 35
a139 35
static usbd_status	dwc2_root_ctrl_transfer(usbd_xfer_handle);
static usbd_status	dwc2_root_ctrl_start(usbd_xfer_handle);
static void		dwc2_root_ctrl_abort(usbd_xfer_handle);
static void		dwc2_root_ctrl_close(usbd_pipe_handle);
static void		dwc2_root_ctrl_done(usbd_xfer_handle);

static usbd_status	dwc2_root_intr_transfer(usbd_xfer_handle);
static usbd_status	dwc2_root_intr_start(usbd_xfer_handle);
static void		dwc2_root_intr_abort(usbd_xfer_handle);
static void		dwc2_root_intr_close(usbd_pipe_handle);
static void		dwc2_root_intr_done(usbd_xfer_handle);

static usbd_status	dwc2_device_ctrl_transfer(usbd_xfer_handle);
static usbd_status	dwc2_device_ctrl_start(usbd_xfer_handle);
static void		dwc2_device_ctrl_abort(usbd_xfer_handle);
static void		dwc2_device_ctrl_close(usbd_pipe_handle);
static void		dwc2_device_ctrl_done(usbd_xfer_handle);

static usbd_status	dwc2_device_bulk_transfer(usbd_xfer_handle);
static usbd_status	dwc2_device_bulk_start(usbd_xfer_handle);
static void		dwc2_device_bulk_abort(usbd_xfer_handle);
static void		dwc2_device_bulk_close(usbd_pipe_handle);
static void		dwc2_device_bulk_done(usbd_xfer_handle);

static usbd_status	dwc2_device_intr_transfer(usbd_xfer_handle);
static usbd_status	dwc2_device_intr_start(usbd_xfer_handle);
static void		dwc2_device_intr_abort(usbd_xfer_handle);
static void		dwc2_device_intr_close(usbd_pipe_handle);
static void		dwc2_device_intr_done(usbd_xfer_handle);

static usbd_status	dwc2_device_isoc_transfer(usbd_xfer_handle);
static usbd_status	dwc2_device_isoc_start(usbd_xfer_handle);
static void		dwc2_device_isoc_abort(usbd_xfer_handle);
static void		dwc2_device_isoc_close(usbd_pipe_handle);
static void		dwc2_device_isoc_done(usbd_xfer_handle);
d141 1
a141 1
static usbd_status	dwc2_device_start(usbd_xfer_handle);
d143 2
a144 2
static void		dwc2_close_pipe(usbd_pipe_handle);
static void		dwc2_abort_xfer(usbd_xfer_handle, usbd_status);
d146 2
a147 2
static void		dwc2_device_clear_toggle(usbd_pipe_handle);
static void		dwc2_noop(usbd_pipe_handle pipe);
d159 1
a159 1
			    usbd_xfer_handle xfer)
d165 1
a165 1
			usbd_xfer_handle xfer)
d264 1
a264 1
usbd_xfer_handle
d284 1
a284 1
	return (usbd_xfer_handle)dxfer;
d288 1
a288 1
dwc2_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
d318 1
a318 1
	usbd_xfer_handle xfer;
d379 1
a379 1
dwc2_waitintr(struct dwc2_softc *sc, usbd_xfer_handle xfer)
d415 1
a415 1
	usbd_xfer_handle xfer = addr;
d439 1
a439 1
	usbd_xfer_handle xfer = addr;
d450 1
a450 1
dwc2_open(usbd_pipe_handle pipe)
d452 1
a452 1
	usbd_device_handle dev = pipe->device;
d527 1
a527 1
dwc2_close_pipe(usbd_pipe_handle pipe)
d540 1
a540 1
dwc2_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d609 1
a609 1
dwc2_noop(usbd_pipe_handle pipe)
d615 1
a615 1
dwc2_device_clear_toggle(usbd_pipe_handle pipe)
d694 1
a694 1
dwc2_root_ctrl_transfer(usbd_xfer_handle xfer)
d709 1
a709 1
dwc2_root_ctrl_start(usbd_xfer_handle xfer)
d856 1
a856 1
dwc2_root_ctrl_abort(usbd_xfer_handle xfer)
d864 1
a864 1
dwc2_root_ctrl_close(usbd_pipe_handle pipe)
d872 1
a872 1
dwc2_root_ctrl_done(usbd_xfer_handle xfer)
d880 1
a880 1
dwc2_root_intr_transfer(usbd_xfer_handle xfer)
d899 1
a899 1
dwc2_root_intr_start(usbd_xfer_handle xfer)
d918 1
a918 1
dwc2_root_intr_abort(usbd_xfer_handle xfer)
d934 1
a934 1
dwc2_root_intr_close(usbd_pipe_handle pipe)
d946 1
a946 1
dwc2_root_intr_done(usbd_xfer_handle xfer)
d955 1
a955 1
dwc2_device_ctrl_transfer(usbd_xfer_handle xfer)
d974 1
a974 1
dwc2_device_ctrl_start(usbd_xfer_handle xfer)
d996 1
a996 1
dwc2_device_ctrl_abort(usbd_xfer_handle xfer)
d1008 1
a1008 1
dwc2_device_ctrl_close(usbd_pipe_handle pipe)
d1016 1
a1016 1
dwc2_device_ctrl_done(usbd_xfer_handle xfer)
d1025 1
a1025 1
dwc2_device_bulk_transfer(usbd_xfer_handle xfer)
d1044 1
a1044 1
dwc2_device_bulk_start(usbd_xfer_handle xfer)
d1059 1
a1059 1
dwc2_device_bulk_abort(usbd_xfer_handle xfer)
d1071 1
a1071 1
dwc2_device_bulk_close(usbd_pipe_handle pipe)
d1080 1
a1080 1
dwc2_device_bulk_done(usbd_xfer_handle xfer)
d1089 1
a1089 1
dwc2_device_intr_transfer(usbd_xfer_handle xfer)
d1108 1
a1108 1
dwc2_device_intr_start(usbd_xfer_handle xfer)
d1111 1
a1111 1
	usbd_device_handle dev = dpipe->pipe.device;
d1131 1
a1131 1
dwc2_device_intr_abort(usbd_xfer_handle xfer)
d1146 1
a1146 1
dwc2_device_intr_close(usbd_pipe_handle pipe)
d1155 1
a1155 1
dwc2_device_intr_done(usbd_xfer_handle xfer)
d1169 1
a1169 1
dwc2_device_isoc_transfer(usbd_xfer_handle xfer)
d1188 1
a1188 1
dwc2_device_isoc_start(usbd_xfer_handle xfer)
d1191 1
a1191 1
	usbd_device_handle dev = dpipe->pipe.device;
d1207 1
a1207 1
dwc2_device_isoc_abort(usbd_xfer_handle xfer)
d1219 1
a1219 1
dwc2_device_isoc_close(usbd_pipe_handle pipe)
d1227 1
a1227 1
dwc2_device_isoc_done(usbd_xfer_handle xfer)
d1235 1
a1235 1
dwc2_device_start(usbd_xfer_handle xfer)
d1243 1
a1243 1
	usbd_device_handle dev = xfer->pipe->device;
d1440 1
a1440 1
	usbd_xfer_handle xfer = dwork->xfer;
d1661 1
a1661 1
	usbd_xfer_handle xfer = context;
d1663 1
a1663 1
	usbd_device_handle dev = dpipe->pipe.device;
d1671 1
a1671 1
	usbd_xfer_handle xfer = context;
d1673 1
a1673 1
	usbd_device_handle dev = dpipe->pipe.device;
d1687 1
a1687 1
	usbd_xfer_handle xfer;
@


1.3
log
@Convert header paths.
@
text
@d93 52
a144 52
Static usbd_status	dwc2_open(usbd_pipe_handle);
Static void		dwc2_poll(struct usbd_bus *);
Static void		dwc2_softintr(void *);
Static void		dwc2_waitintr(struct dwc2_softc *, usbd_xfer_handle);

Static usbd_status	dwc2_allocm(struct usbd_bus *, usb_dma_t *, uint32_t);
Static void		dwc2_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	dwc2_allocx(struct usbd_bus *);
Static void		dwc2_freex(struct usbd_bus *, usbd_xfer_handle);
Static void		dwc2_get_lock(struct usbd_bus *, kmutex_t **);

Static usbd_status	dwc2_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_root_ctrl_start(usbd_xfer_handle);
Static void		dwc2_root_ctrl_abort(usbd_xfer_handle);
Static void		dwc2_root_ctrl_close(usbd_pipe_handle);
Static void		dwc2_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	dwc2_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_root_intr_start(usbd_xfer_handle);
Static void		dwc2_root_intr_abort(usbd_xfer_handle);
Static void		dwc2_root_intr_close(usbd_pipe_handle);
Static void		dwc2_root_intr_done(usbd_xfer_handle);

Static usbd_status	dwc2_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_device_ctrl_start(usbd_xfer_handle);
Static void		dwc2_device_ctrl_abort(usbd_xfer_handle);
Static void		dwc2_device_ctrl_close(usbd_pipe_handle);
Static void		dwc2_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	dwc2_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_device_bulk_start(usbd_xfer_handle);
Static void		dwc2_device_bulk_abort(usbd_xfer_handle);
Static void		dwc2_device_bulk_close(usbd_pipe_handle);
Static void		dwc2_device_bulk_done(usbd_xfer_handle);

Static usbd_status	dwc2_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_device_intr_start(usbd_xfer_handle);
Static void		dwc2_device_intr_abort(usbd_xfer_handle);
Static void		dwc2_device_intr_close(usbd_pipe_handle);
Static void		dwc2_device_intr_done(usbd_xfer_handle);

Static usbd_status	dwc2_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	dwc2_device_isoc_start(usbd_xfer_handle);
Static void		dwc2_device_isoc_abort(usbd_xfer_handle);
Static void		dwc2_device_isoc_close(usbd_pipe_handle);
Static void		dwc2_device_isoc_done(usbd_xfer_handle);

Static usbd_status	dwc2_device_start(usbd_xfer_handle);

Static void		dwc2_close_pipe(usbd_pipe_handle);
Static void		dwc2_abort_xfer(usbd_xfer_handle, usbd_status);
d146 2
a147 2
Static void		dwc2_device_clear_toggle(usbd_pipe_handle);
Static void		dwc2_noop(usbd_pipe_handle pipe);
d149 2
a150 2
Static int		dwc2_interrupt(struct dwc2_softc *);
Static void		dwc2_rhc(void *);
d152 2
a153 2
Static void		dwc2_timeout(void *);
Static void		dwc2_timeout_task(void *);
d171 1
a171 1
Static const struct usbd_bus_methods dwc2_bus_methods = {
d182 1
a182 1
Static const struct usbd_pipe_methods dwc2_root_ctrl_methods = {
d191 1
a191 1
Static const struct usbd_pipe_methods dwc2_root_intr_methods = {
d200 1
a200 1
Static const struct usbd_pipe_methods dwc2_device_ctrl_methods = {
d209 1
a209 1
Static const struct usbd_pipe_methods dwc2_device_intr_methods = {
d218 1
a218 1
Static const struct usbd_pipe_methods dwc2_device_bulk_methods = {
d227 1
a227 1
Static const struct usbd_pipe_methods dwc2_device_isoc_methods = {
d236 1
a236 1
Static usbd_status
d250 1
a250 1
Static void
d306 1
a306 1
Static void
d314 1
a314 1
Static void
d343 1
a343 1
Static void
d378 1
a378 1
Static void
d412 1
a412 1
Static void
d436 1
a436 1
Static void
d511 1
a511 1
Static void
d526 1
a526 1
Static void
d539 1
a539 1
Static void
d608 1
a608 1
Static void
d614 1
a614 1
Static void
d627 1
a627 1
Static const usb_device_descriptor_t dwc2_devd = {
d647 1
a647 1
Static const struct dwc2_config_desc dwc2_confd = {
d682 1
a682 1
Static const usb_hub_descriptor_t dwc2_hubd = {
d693 1
a693 1
Static usbd_status
d708 1
a708 1
Static usbd_status
d855 1
a855 1
Static void
d863 1
a863 1
Static void
d871 1
a871 1
Static void
d879 1
a879 1
Static usbd_status
d898 1
a898 1
Static usbd_status
d917 1
a917 1
Static void
d933 1
a933 1
Static void
d945 1
a945 1
Static void
d954 1
a954 1
Static usbd_status
d973 1
a973 1
Static usbd_status
d995 1
a995 1
Static void
d1007 1
a1007 1
Static void
d1015 1
a1015 1
Static void
d1024 1
a1024 1
Static usbd_status
d1043 1
a1043 1
Static usbd_status
d1058 1
a1058 1
Static void
d1070 1
a1070 1
Static void
d1079 1
a1079 1
Static void
d1088 1
a1088 1
Static usbd_status
d1107 1
a1107 1
Static usbd_status
d1130 1
a1130 1
Static void
d1145 1
a1145 1
Static void
d1154 1
a1154 1
Static void
@


1.2
log
@Add RCS IDs.
@
text
@d38 1
d40 1
d44 1
a44 1
#include <sys/kmem.h>
d50 1
d52 1
d54 1
d62 1
d64 1
d66 2
a67 2
#include <dwc2/dwc2.h>
#include <dwc2/dwc2var.h>
d69 2
a70 2
#include "dwc2_core.h"
#include "dwc2_hcd.h"
@


1.1
log
@Initial revision
@
text
@d1 2
a2 1
/*	$NetBSD$	*/
d33 1
d35 2
a36 1
__KERNEL_RCSID(0, "$NetBSD$");
@


1.1.1.1
log
@Import dwc2 core and glue code from NetBSD.  OK deraadt@@ jsing@@ miod@@ mpi@@
@
text
@@


1.1.1.2
log
@Redo dwc2 import with CVS tags expanded.
@
text
@d1 1
a1 1
/*	$NetBSD: dwc2.c,v 1.32 2014/09/02 23:26:20 macallan Exp $	*/
d33 1
a33 1
__KERNEL_RCSID(0, "$NetBSD: dwc2.c,v 1.32 2014/09/02 23:26:20 macallan Exp $");
@

