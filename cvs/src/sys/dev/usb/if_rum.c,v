head	1.121;
access;
symbols
	OPENBSD_6_1:1.121.0.2
	OPENBSD_6_1_BASE:1.121
	OPENBSD_6_0:1.119.0.4
	OPENBSD_6_0_BASE:1.119
	OPENBSD_5_9:1.118.0.2
	OPENBSD_5_9_BASE:1.118
	OPENBSD_5_8:1.111.0.4
	OPENBSD_5_8_BASE:1.111
	OPENBSD_5_7:1.109.0.2
	OPENBSD_5_7_BASE:1.109
	OPENBSD_5_6:1.106.0.4
	OPENBSD_5_6_BASE:1.106
	OPENBSD_5_5:1.101.0.4
	OPENBSD_5_5_BASE:1.101
	OPENBSD_5_4:1.100.0.2
	OPENBSD_5_4_BASE:1.100
	OPENBSD_5_3:1.99.0.6
	OPENBSD_5_3_BASE:1.99
	OPENBSD_5_2:1.99.0.4
	OPENBSD_5_2_BASE:1.99
	OPENBSD_5_1_BASE:1.99
	OPENBSD_5_1:1.99.0.2
	OPENBSD_5_0:1.98.0.2
	OPENBSD_5_0_BASE:1.98
	OPENBSD_4_9:1.97.0.2
	OPENBSD_4_9_BASE:1.97
	OPENBSD_4_8:1.89.0.2
	OPENBSD_4_8_BASE:1.89
	OPENBSD_4_7:1.87.0.2
	OPENBSD_4_7_BASE:1.87
	OPENBSD_4_6:1.84.0.4
	OPENBSD_4_6_BASE:1.84
	OPENBSD_4_5:1.82.0.2
	OPENBSD_4_5_BASE:1.82
	OPENBSD_4_4:1.75.0.2
	OPENBSD_4_4_BASE:1.75
	OPENBSD_4_3:1.69.0.2
	OPENBSD_4_3_BASE:1.69
	OPENBSD_4_2:1.64.0.2
	OPENBSD_4_2_BASE:1.64
	OPENBSD_4_1:1.54.0.2
	OPENBSD_4_1_BASE:1.54
	OPENBSD_4_0:1.39.0.4
	OPENBSD_4_0_BASE:1.39;
locks; strict;
comment	@ * @;


1.121
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.120;
commitid	x5RWYO05Q3UFL5Oq;

1.120
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.119;
commitid	VyLWTsbepAOk7VQM;

1.119
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.118;
commitid	gWZDkudwxydTq8x4;

1.118
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.117;
commitid	fbhqfhfdKxBcsetK;

1.117
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.116;
commitid	B0kwmVGiD5DVx4kv;

1.116
date	2015.11.24.13.45.06;	author mpi;	state Exp;
branches;
next	1.115;
commitid	FuSD2mFDJWATHIDx;

1.115
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.114;
commitid	5DvsamK0GblTp8ww;

1.114
date	2015.11.13.10.36.29;	author mpi;	state Exp;
branches;
next	1.113;
commitid	pVgZpZmw966Haagb;

1.113
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.112;
commitid	YT6fyIEviv9qwbl6;

1.112
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.111;
commitid	pwYnMC1gOKohmeGw;

1.111
date	2015.06.12.15.47.31;	author mpi;	state Exp;
branches;
next	1.110;
commitid	t0sjCnxjbRqHxJe2;

1.110
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.109;
commitid	p4LJxGKbi0BU2cG6;

1.109
date	2015.02.10.23.25.46;	author mpi;	state Exp;
branches;
next	1.108;
commitid	Hly9lJn6CNMylcFu;

1.108
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.107;
commitid	yM2VFFhpDTeFQlve;

1.107
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.106;
commitid	LS2TNeCue5R9L67C;

1.106
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.105;
commitid	Pclvgy2Z4XV9hveD;

1.105
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.104;
commitid	OBNa5kfxQ2UXoiIw;

1.104
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.103;
commitid	b0VSac5dnnsxcDao;

1.103
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.102;

1.102
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.101;

1.101
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.100;

1.100
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.99;

1.99
date	2011.10.26.17.31.54;	author jasper;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.97;

1.97
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.96;

1.96
date	2010.12.30.05.22.51;	author jakemsr;	state Exp;
branches;
next	1.95;

1.95
date	2010.12.17.22.38.54;	author jasper;	state Exp;
branches;
next	1.94;

1.94
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.93;

1.93
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.92;

1.92
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.91;

1.91
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.90;

1.90
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.89;

1.89
date	2010.07.02.03.13.42;	author tedu;	state Exp;
branches;
next	1.88;

1.88
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.87;

1.87
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.86;

1.86
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.85;

1.85
date	2009.07.10.07.40.04;	author blambert;	state Exp;
branches;
next	1.84;

1.84
date	2009.03.27.14.59.31;	author jsg;	state Exp;
branches;
next	1.83;

1.83
date	2009.03.27.11.38.46;	author jsg;	state Exp;
branches;
next	1.82;

1.82
date	2009.02.03.10.53.28;	author kevlo;	state Exp;
branches;
next	1.81;

1.81
date	2008.12.22.18.42.04;	author damien;	state Exp;
branches;
next	1.80;

1.80
date	2008.12.10.18.10.14;	author deraadt;	state Exp;
branches;
next	1.79;

1.79
date	2008.10.15.19.12.18;	author blambert;	state Exp;
branches;
next	1.78;

1.78
date	2008.08.27.09.05.03;	author damien;	state Exp;
branches;
next	1.77;

1.77
date	2008.08.19.02.34.04;	author deraadt;	state Exp;
branches;
next	1.76;

1.76
date	2008.08.14.16.02.24;	author damien;	state Exp;
branches;
next	1.75;

1.75
date	2008.07.30.06.25.23;	author damien;	state Exp;
branches;
next	1.74;

1.74
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.73;

1.73
date	2008.06.29.00.43.11;	author deraadt;	state Exp;
branches;
next	1.72;

1.72
date	2008.06.13.05.01.04;	author jsg;	state Exp;
branches;
next	1.71;

1.71
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.70;

1.70
date	2008.04.01.13.43.53;	author jsg;	state Exp;
branches;
next	1.69;

1.69
date	2008.03.03.20.50.09;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2008.02.22.10.46.57;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2008.01.05.04.57.59;	author deraadt;	state Exp;
branches;
next	1.66;

1.66
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.65;

1.65
date	2007.09.07.19.05.05;	author damien;	state Exp;
branches;
next	1.64;

1.64
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.63;

1.63
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.62;

1.62
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.61;

1.61
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.60;

1.60
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.59;

1.59
date	2007.06.09.08.52.10;	author damien;	state Exp;
branches;
next	1.58;

1.58
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.57;

1.57
date	2007.05.27.04.00.24;	author jsg;	state Exp;
branches;
next	1.56;

1.56
date	2007.05.21.06.10.43;	author jsg;	state Exp;
branches;
next	1.55;

1.55
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.54;

1.54
date	2007.02.19.17.22.02;	author deraadt;	state Exp;
branches;
next	1.53;

1.53
date	2007.02.08.06.19.31;	author jsg;	state Exp;
branches;
next	1.52;

1.52
date	2007.02.08.05.57.46;	author itojun;	state Exp;
branches;
next	1.51;

1.51
date	2007.02.08.05.25.46;	author jsg;	state Exp;
branches;
next	1.50;

1.50
date	2007.01.08.18.53.00;	author damien;	state Exp;
branches;
next	1.49;

1.49
date	2006.12.30.22.34.53;	author claudio;	state Exp;
branches;
next	1.48;

1.48
date	2006.12.07.17.32.19;	author damien;	state Exp;
branches;
next	1.47;

1.47
date	2006.12.03.16.39.13;	author damien;	state Exp;
branches;
next	1.46;

1.46
date	2006.12.03.16.16.58;	author damien;	state Exp;
branches;
next	1.45;

1.45
date	2006.11.26.11.14.22;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2006.11.19.16.44.36;	author damien;	state Exp;
branches;
next	1.43;

1.43
date	2006.11.13.20.06.38;	author damien;	state Exp;
branches;
next	1.42;

1.42
date	2006.10.22.12.27.56;	author damien;	state Exp;
branches;
next	1.41;

1.41
date	2006.10.19.16.53.48;	author jsg;	state Exp;
branches;
next	1.40;

1.40
date	2006.09.18.16.20.20;	author damien;	state Exp;
branches;
next	1.39;

1.39
date	2006.08.24.19.32.21;	author damien;	state Exp;
branches;
next	1.38;

1.38
date	2006.08.23.21.37.04;	author niallo;	state Exp;
branches;
next	1.37;

1.37
date	2006.08.23.16.25.07;	author damien;	state Exp;
branches;
next	1.36;

1.36
date	2006.08.23.16.16.39;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2006.08.18.16.04.56;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2006.08.18.15.23.13;	author damien;	state Exp;
branches;
next	1.33;

1.33
date	2006.08.18.15.11.11;	author damien;	state Exp;
branches;
next	1.32;

1.32
date	2006.08.17.08.32.30;	author damien;	state Exp;
branches;
next	1.31;

1.31
date	2006.08.16.16.08.05;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2006.08.14.12.57.08;	author jsg;	state Exp;
branches;
next	1.29;

1.29
date	2006.08.14.10.33.18;	author jsg;	state Exp;
branches;
next	1.28;

1.28
date	2006.08.10.07.44.04;	author damien;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.09.08.21.08;	author damien;	state Exp;
branches;
next	1.26;

1.26
date	2006.07.19.20.16.20;	author damien;	state Exp;
branches;
next	1.25;

1.25
date	2006.07.19.19.54.00;	author damien;	state Exp;
branches;
next	1.24;

1.24
date	2006.07.19.19.51.01;	author damien;	state Exp;
branches;
next	1.23;

1.23
date	2006.07.19.19.36.19;	author damien;	state Exp;
branches;
next	1.22;

1.22
date	2006.07.19.19.32.46;	author damien;	state Exp;
branches;
next	1.21;

1.21
date	2006.07.19.19.27.30;	author damien;	state Exp;
branches;
next	1.20;

1.20
date	2006.07.19.19.23.26;	author damien;	state Exp;
branches;
next	1.19;

1.19
date	2006.07.19.19.22.02;	author damien;	state Exp;
branches;
next	1.18;

1.18
date	2006.07.19.19.18.11;	author damien;	state Exp;
branches;
next	1.17;

1.17
date	2006.07.19.19.15.04;	author damien;	state Exp;
branches;
next	1.16;

1.16
date	2006.07.19.19.10.52;	author damien;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.19.19.07.36;	author damien;	state Exp;
branches;
next	1.14;

1.14
date	2006.07.18.21.24.40;	author damien;	state Exp;
branches;
next	1.13;

1.13
date	2006.07.18.21.13.33;	author damien;	state Exp;
branches;
next	1.12;

1.12
date	2006.07.18.20.54.15;	author damien;	state Exp;
branches;
next	1.11;

1.11
date	2006.07.18.20.37.44;	author damien;	state Exp;
branches;
next	1.10;

1.10
date	2006.07.18.20.29.16;	author damien;	state Exp;
branches;
next	1.9;

1.9
date	2006.07.18.20.23.14;	author damien;	state Exp;
branches;
next	1.8;

1.8
date	2006.07.18.20.12.15;	author damien;	state Exp;
branches;
next	1.7;

1.7
date	2006.07.18.20.07.59;	author damien;	state Exp;
branches;
next	1.6;

1.6
date	2006.07.18.19.59.04;	author damien;	state Exp;
branches;
next	1.5;

1.5
date	2006.07.18.19.56.12;	author damien;	state Exp;
branches;
next	1.4;

1.4
date	2006.07.02.00.56.14;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2006.06.21.13.04.10;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2006.06.17.20.17.12;	author jolan;	state Exp;
branches;
next	1.1;

1.1
date	2006.06.16.22.30.46;	author niallo;	state Exp;
branches;
next	;


desc
@@


1.121
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@/*	$OpenBSD: if_rum.c,v 1.120 2017/01/22 10:17:39 dlg Exp $	*/

/*-
 * Copyright (c) 2005-2007 Damien Bergamini <damien.bergamini@@free.fr>
 * Copyright (c) 2006 Niall O'Higgins <niallo@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*-
 * Ralink Technology RT2501USB/RT2601USB chipset driver
 * http://www.ralinktech.com.tw/
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_amrr.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_rumreg.h>
#include <dev/usb/if_rumvar.h>

#ifdef RUM_DEBUG
#define DPRINTF(x)	do { if (rum_debug) printf x; } while (0)
#define DPRINTFN(n, x)	do { if (rum_debug >= (n)) printf x; } while (0)
int rum_debug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n, x)
#endif

/* various supported device vendors/products */
static const struct usb_devno rum_devs[] = {
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_HWU54DM },
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_RT2573_2 },
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_RT2573_3 },
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_RT2573_4 },
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_WUG2700 },
	{ USB_VENDOR_AMIT,		USB_PRODUCT_AMIT_CGWLUSB2GO },
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_RT2573_1 },
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_RT2573_2 },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050A },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D9050V3 },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D9050C },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB200 },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54GC },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54GR },
	{ USB_VENDOR_CONCEPTRONIC2,	USB_PRODUCT_CONCEPTRONIC2_C54RU2 },
	{ USB_VENDOR_CONCEPTRONIC2,	USB_PRODUCT_CONCEPTRONIC2_RT2573 },
	{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_CGWLUSB2GL },
	{ USB_VENDOR_COREGA,		USB_PRODUCT_COREGA_CGWLUSB2GPX },
	{ USB_VENDOR_DICKSMITH,		USB_PRODUCT_DICKSMITH_CWD854F },
	{ USB_VENDOR_DICKSMITH,		USB_PRODUCT_DICKSMITH_RT2573 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWA111 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWA110 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_DWLG122C1 },
	{ USB_VENDOR_DLINK2,		USB_PRODUCT_DLINK2_WUA1340 },
	{ USB_VENDOR_EDIMAX,		USB_PRODUCT_EDIMAX_EW7318 },
	{ USB_VENDOR_EDIMAX,		USB_PRODUCT_EDIMAX_EW7618 },
	{ USB_VENDOR_GIGABYTE,		USB_PRODUCT_GIGABYTE_GNWB01GS },
	{ USB_VENDOR_GIGABYTE,		USB_PRODUCT_GIGABYTE_GNWI05GS },
	{ USB_VENDOR_GIGASET,		USB_PRODUCT_GIGASET_RT2573 },
	{ USB_VENDOR_GOODWAY,		USB_PRODUCT_GOODWAY_RT2573 },
	{ USB_VENDOR_GUILLEMOT,		USB_PRODUCT_GUILLEMOT_HWGUSB254LB },
	{ USB_VENDOR_GUILLEMOT,		USB_PRODUCT_GUILLEMOT_HWGUSB254V2AP },
	{ USB_VENDOR_HUAWEI3COM,	USB_PRODUCT_HUAWEI3COM_WUB320G },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_G54HP },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_SG54HP },
	{ USB_VENDOR_MELCO,		USB_PRODUCT_MELCO_SG54HG },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2573_1 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2573_2 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2573_3 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2573_4 },
	{ USB_VENDOR_NOVATECH,		USB_PRODUCT_NOVATECH_RT2573 },
	{ USB_VENDOR_PLANEX2,		USB_PRODUCT_PLANEX2_GWUS54HP },
	{ USB_VENDOR_PLANEX2,		USB_PRODUCT_PLANEX2_GWUS54MINI2 },
	{ USB_VENDOR_PLANEX2,		USB_PRODUCT_PLANEX2_GWUSMM },
	{ USB_VENDOR_QCOM,		USB_PRODUCT_QCOM_RT2573 },
	{ USB_VENDOR_QCOM,		USB_PRODUCT_QCOM_RT2573_2 },
	{ USB_VENDOR_QCOM,		USB_PRODUCT_QCOM_RT2573_3 },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2573 },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2573_2 },
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2671 },
	{ USB_VENDOR_SITECOMEU,		USB_PRODUCT_SITECOMEU_WL113R2 },
	{ USB_VENDOR_SITECOMEU,		USB_PRODUCT_SITECOMEU_WL172 },
	{ USB_VENDOR_SURECOM,		USB_PRODUCT_SURECOM_RT2573 },
	{ USB_VENDOR_SPARKLAN,		USB_PRODUCT_SPARKLAN_RT2573 },
	{ USB_VENDOR_ZYXEL,		USB_PRODUCT_ZYXEL_RT2573 }
};

void		rum_attachhook(struct device *);
int		rum_alloc_tx_list(struct rum_softc *);
void		rum_free_tx_list(struct rum_softc *);
int		rum_alloc_rx_list(struct rum_softc *);
void		rum_free_rx_list(struct rum_softc *);
int		rum_media_change(struct ifnet *);
void		rum_next_scan(void *);
void		rum_task(void *);
int		rum_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		rum_txeof(struct usbd_xfer *, void *, usbd_status);
void		rum_rxeof(struct usbd_xfer *, void *, usbd_status);
#if NBPFILTER > 0
uint8_t		rum_rxrate(const struct rum_rx_desc *);
#endif
int		rum_ack_rate(struct ieee80211com *, int);
uint16_t	rum_txtime(int, int, uint32_t);
uint8_t		rum_plcp_signal(int);
void		rum_setup_tx_desc(struct rum_softc *, struct rum_tx_desc *,
		    uint32_t, uint16_t, int, int);
int		rum_tx_data(struct rum_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		rum_start(struct ifnet *);
void		rum_watchdog(struct ifnet *);
int		rum_ioctl(struct ifnet *, u_long, caddr_t);
void		rum_eeprom_read(struct rum_softc *, uint16_t, void *, int);
uint32_t	rum_read(struct rum_softc *, uint16_t);
void		rum_read_multi(struct rum_softc *, uint16_t, void *, int);
void		rum_write(struct rum_softc *, uint16_t, uint32_t);
void		rum_write_multi(struct rum_softc *, uint16_t, void *, size_t);
void		rum_bbp_write(struct rum_softc *, uint8_t, uint8_t);
uint8_t		rum_bbp_read(struct rum_softc *, uint8_t);
void		rum_rf_write(struct rum_softc *, uint8_t, uint32_t);
void		rum_select_antenna(struct rum_softc *);
void		rum_enable_mrr(struct rum_softc *);
void		rum_set_txpreamble(struct rum_softc *);
void		rum_set_basicrates(struct rum_softc *);
void		rum_select_band(struct rum_softc *,
		    struct ieee80211_channel *);
void		rum_set_chan(struct rum_softc *, struct ieee80211_channel *);
void		rum_enable_tsf_sync(struct rum_softc *);
void		rum_update_slot(struct rum_softc *);
void		rum_set_bssid(struct rum_softc *, const uint8_t *);
void		rum_set_macaddr(struct rum_softc *, const uint8_t *);
void		rum_update_promisc(struct rum_softc *);
const char	*rum_get_rf(int);
void		rum_read_eeprom(struct rum_softc *);
int		rum_bbp_init(struct rum_softc *);
int		rum_init(struct ifnet *);
void		rum_stop(struct ifnet *, int);
int		rum_load_microcode(struct rum_softc *, const u_char *, size_t);
#ifndef IEEE80211_STA_ONLY
int		rum_prepare_beacon(struct rum_softc *);
#endif
void		rum_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
void		rum_amrr_start(struct rum_softc *, struct ieee80211_node *);
void		rum_amrr_timeout(void *);
void		rum_amrr_update(struct usbd_xfer *, void *,
		    usbd_status status);

static const struct {
	uint32_t	reg;
	uint32_t	val;
} rum_def_mac[] = {
	RT2573_DEF_MAC
};

static const struct {
	uint8_t	reg;
	uint8_t	val;
} rum_def_bbp[] = {
	RT2573_DEF_BBP
};

static const struct rfprog {
	uint8_t		chan;
	uint32_t	r1, r2, r3, r4;
}  rum_rf5226[] = {
	RT2573_RF5226
}, rum_rf5225[] = {
	RT2573_RF5225
};

int rum_match(struct device *, void *, void *);
void rum_attach(struct device *, struct device *, void *);
int rum_detach(struct device *, int);

struct cfdriver rum_cd = {
	NULL, "rum", DV_IFNET
};

const struct cfattach rum_ca = {
	sizeof(struct rum_softc), rum_match, rum_attach, rum_detach
};

int
rum_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return UMATCH_NONE;

	return (usb_lookup(rum_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE;
}

void
rum_attachhook(struct device *self)
{
	struct rum_softc *sc = (struct rum_softc *)self;
	const char *name = "rum-rt2573";
	u_char *ucode;
	size_t size;
	int error;

	if ((error = loadfirmware(name, &ucode, &size)) != 0) {
		printf("%s: failed loadfirmware of file %s (error %d)\n",
		    sc->sc_dev.dv_xname, name, error);
		return;
	}

	if (rum_load_microcode(sc, ucode, size) != 0) {
		printf("%s: could not load 8051 microcode\n",
		    sc->sc_dev.dv_xname);
	}

	free(ucode, M_DEVBUF, size);
}

void
rum_attach(struct device *parent, struct device *self, void *aux)
{
	struct rum_softc *sc = (struct rum_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int i, ntries;
	uint32_t tmp;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;

	/*
	 * Find endpoints.
	 */
	id = usbd_get_interface_descriptor(sc->sc_iface);

	sc->sc_rx_no = sc->sc_tx_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for iface %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_rx_no = ed->bEndpointAddress;
		else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_tx_no = ed->bEndpointAddress;
	}
	if (sc->sc_rx_no == -1 || sc->sc_tx_no == -1) {
		printf("%s: missing endpoint\n", sc->sc_dev.dv_xname);
		return;
	}

	usb_init_task(&sc->sc_task, rum_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, rum_next_scan, sc);

	sc->amrr.amrr_min_success_threshold =  1;
	sc->amrr.amrr_max_success_threshold = 10;
	timeout_set(&sc->amrr_to, rum_amrr_timeout, sc);

	/* retrieve RT2573 rev. no */
	for (ntries = 0; ntries < 1000; ntries++) {
		if ((tmp = rum_read(sc, RT2573_MAC_CSR0)) != 0)
			break;
		DELAY(1000);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for chip to settle\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* retrieve MAC address and various other things from EEPROM */
	rum_read_eeprom(sc);

	printf("%s: MAC/BBP RT%04x (rev 0x%05x), RF %s, address %s\n",
	    sc->sc_dev.dv_xname, sc->macbbp_rev, tmp,
	    rum_get_rf(sc->rf_rev), ether_sprintf(ic->ic_myaddr));

	config_mountroot(self, rum_attachhook);

	ic->ic_phytype = IEEE80211_T_OFDM;	/* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA;	/* default to BSS mode */
	ic->ic_state = IEEE80211_S_INIT;

	/* set device capabilities */
	ic->ic_caps =
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
#ifndef IEEE80211_STA_ONLY
	    IEEE80211_C_IBSS |		/* IBSS mode supported */
	    IEEE80211_C_HOSTAP |	/* HostAp mode supported */
#endif
	    IEEE80211_C_TXPMGT |	/* tx power management */
	    IEEE80211_C_SHPREAMBLE |	/* short preamble supported */
	    IEEE80211_C_SHSLOT |	/* short slot time supported */
	    IEEE80211_C_WEP |		/* s/w WEP */
	    IEEE80211_C_RSN;		/* WPA/RSN */

	if (sc->rf_rev == RT2573_RF_5225 || sc->rf_rev == RT2573_RF_5226) {
		/* set supported .11a rates */
		ic->ic_sup_rates[IEEE80211_MODE_11A] =
		    ieee80211_std_rateset_11a;

		/* set supported .11a channels */
		for (i = 34; i <= 46; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 36; i <= 64; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 100; i <= 140; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
		for (i = 149; i <= 165; i += 4) {
			ic->ic_channels[i].ic_freq =
			    ieee80211_ieee2mhz(i, IEEE80211_CHAN_5GHZ);
			ic->ic_channels[i].ic_flags = IEEE80211_CHAN_A;
		}
	}

	/* set supported .11b and .11g rates */
	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	/* set supported .11b and .11g channels (1 through 14) */
	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = rum_ioctl;
	ifp->if_start = rum_start;
	ifp->if_watchdog = rum_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_newassoc = rum_newassoc;

	/* override state transition machine */
	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = rum_newstate;
	ieee80211_media_init(ifp, rum_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof (struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof sc->sc_rxtapu;
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(RT2573_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof sc->sc_txtapu;
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(RT2573_TX_RADIOTAP_PRESENT);
#endif
}

int
rum_detach(struct device *self, int flags)
{
	struct rum_softc *sc = (struct rum_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	s = splusb();

	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->amrr_to))
		timeout_del(&sc->amrr_to);

	usb_rem_wait_task(sc->sc_udev, &sc->sc_task);

	usbd_ref_wait(sc->sc_udev);

	if (ifp->if_softc != NULL) {
		ieee80211_ifdetach(ifp);	/* free all nodes */
		if_detach(ifp);
	}

	if (sc->amrr_xfer != NULL) {
		usbd_free_xfer(sc->amrr_xfer);
		sc->amrr_xfer = NULL;
	}
	if (sc->sc_rx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_rx_pipeh);
		usbd_close_pipe(sc->sc_rx_pipeh);
	}
	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
	}

	rum_free_rx_list(sc);
	rum_free_tx_list(sc);

	splx(s);

	return 0;
}

int
rum_alloc_tx_list(struct rum_softc *sc)
{
	int i, error;

	sc->tx_cur = sc->tx_queued = 0;

	for (i = 0; i < RUM_TX_LIST_COUNT; i++) {
		struct rum_tx_data *data = &sc->tx_data[i];

		data->sc = sc;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate tx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = usbd_alloc_buffer(data->xfer,
		    RT2573_TX_DESC_SIZE + IEEE80211_MAX_LEN);
		if (data->buf == NULL) {
			printf("%s: could not allocate tx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		/* clean Tx descriptor */
		bzero(data->buf, RT2573_TX_DESC_SIZE);
	}

	return 0;

fail:	rum_free_tx_list(sc);
	return error;
}

void
rum_free_tx_list(struct rum_softc *sc)
{
	int i;

	for (i = 0; i < RUM_TX_LIST_COUNT; i++) {
		struct rum_tx_data *data = &sc->tx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		/*
		 * The node has already been freed at that point so don't call
		 * ieee80211_release_node() here.
		 */
		data->ni = NULL;
	}
}

int
rum_alloc_rx_list(struct rum_softc *sc)
{
	int i, error;

	for (i = 0; i < RUM_RX_LIST_COUNT; i++) {
		struct rum_rx_data *data = &sc->rx_data[i];

		data->sc = sc;

		data->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data->xfer == NULL) {
			printf("%s: could not allocate rx xfer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		if (usbd_alloc_buffer(data->xfer, MCLBYTES) == NULL) {
			printf("%s: could not allocate rx buffer\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}

		MGETHDR(data->m, M_DONTWAIT, MT_DATA);
		if (data->m == NULL) {
			printf("%s: could not allocate rx mbuf\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		MCLGET(data->m, M_DONTWAIT);
		if (!(data->m->m_flags & M_EXT)) {
			printf("%s: could not allocate rx mbuf cluster\n",
			    sc->sc_dev.dv_xname);
			error = ENOMEM;
			goto fail;
		}
		data->buf = mtod(data->m, uint8_t *);
	}

	return 0;

fail:	rum_free_rx_list(sc);
	return error;
}

void
rum_free_rx_list(struct rum_softc *sc)
{
	int i;

	for (i = 0; i < RUM_RX_LIST_COUNT; i++) {
		struct rum_rx_data *data = &sc->rx_data[i];

		if (data->xfer != NULL) {
			usbd_free_xfer(data->xfer);
			data->xfer = NULL;
		}
		if (data->m != NULL) {
			m_freem(data->m);
			data->m = NULL;
		}
	}
}

int
rum_media_change(struct ifnet *ifp)
{
	int error;

	error = ieee80211_media_change(ifp);
	if (error != ENETRESET)
		return error;

	if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) == (IFF_UP | IFF_RUNNING))
		rum_init(ifp);

	return 0;
}

/*
 * This function is called periodically (every 200ms) during scanning to
 * switch from one channel to another.
 */
void
rum_next_scan(void *arg)
{
	struct rum_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usbd_ref_incr(sc->sc_udev);

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);

	usbd_ref_decr(sc->sc_udev);
}

void
rum_task(void *arg)
{
	struct rum_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	enum ieee80211_state ostate;
	struct ieee80211_node *ni;
	uint32_t tmp;

	if (usbd_is_dying(sc->sc_udev))
		return;

	ostate = ic->ic_state;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		if (ostate == IEEE80211_S_RUN) {
			/* abort TSF synchronization */
			tmp = rum_read(sc, RT2573_TXRX_CSR9);
			rum_write(sc, RT2573_TXRX_CSR9, tmp & ~0x00ffffff);
		}
		break;

	case IEEE80211_S_SCAN:
		rum_set_chan(sc, ic->ic_bss->ni_chan);
		if (!usbd_is_dying(sc->sc_udev))
			timeout_add_msec(&sc->scan_to, 200);
		break;

	case IEEE80211_S_AUTH:
		rum_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_ASSOC:
		rum_set_chan(sc, ic->ic_bss->ni_chan);
		break;

	case IEEE80211_S_RUN:
		rum_set_chan(sc, ic->ic_bss->ni_chan);

		ni = ic->ic_bss;

		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			rum_update_slot(sc);
			rum_enable_mrr(sc);
			rum_set_txpreamble(sc);
			rum_set_basicrates(sc);
			rum_set_bssid(sc, ni->ni_bssid);
		}

#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode == IEEE80211_M_HOSTAP ||
		    ic->ic_opmode == IEEE80211_M_IBSS)
			rum_prepare_beacon(sc);
#endif

		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			rum_enable_tsf_sync(sc);

		if (ic->ic_opmode == IEEE80211_M_STA) {
			/* fake a join to init the tx rate */
			rum_newassoc(ic, ic->ic_bss, 1);

			/* enable automatic rate control in STA mode */
			if (ic->ic_fixed_rate == -1)
				rum_amrr_start(sc, ni);
		}
		break;
	}

	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);
}

int
rum_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct rum_softc *sc = ic->ic_if.if_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task);
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task);
	return 0;
}

/* quickly determine if a given rate is CCK or OFDM */
#define RUM_RATE_IS_OFDM(rate)	((rate) >= 12 && (rate) != 22)

#define RUM_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RUM_CTS_SIZE	14	/* 10 + 4(FCS) */

void
rum_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct rum_tx_data *data = priv;
	struct rum_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	int s;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		printf("%s: could not transmit buffer: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status));

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_tx_pipeh);

		ifp->if_oerrors++;
		return;
	}

	s = splnet();

	ieee80211_release_node(ic, data->ni);
	data->ni = NULL;

	sc->tx_queued--;

	DPRINTFN(10, ("tx done\n"));

	sc->sc_tx_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);
	rum_start(ifp);

	splx(s);
}

void
rum_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct rum_rx_data *data = priv;
	struct rum_softc *sc = data->sc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	const struct rum_rx_desc *desc;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *mnew, *m;
	int s, len;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_rx_pipeh);
		goto skip;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	if (len < RT2573_RX_DESC_SIZE + sizeof (struct ieee80211_frame_min)) {
		DPRINTF(("%s: xfer too short %d\n", sc->sc_dev.dv_xname,
		    len));
		ifp->if_ierrors++;
		goto skip;
	}

	desc = (const struct rum_rx_desc *)data->buf;

	if (letoh32(desc->flags) & RT2573_RX_CRC_ERROR) {
		/*
		 * This should not happen since we did not request to receive
		 * those frames when we filled RT2573_TXRX_CSR0.
		 */
		DPRINTFN(5, ("CRC error\n"));
		ifp->if_ierrors++;
		goto skip;
	}

	MGETHDR(mnew, M_DONTWAIT, MT_DATA);
	if (mnew == NULL) {
		printf("%s: could not allocate rx mbuf\n",
		    sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		goto skip;
	}
	MCLGET(mnew, M_DONTWAIT);
	if (!(mnew->m_flags & M_EXT)) {
		printf("%s: could not allocate rx mbuf cluster\n",
		    sc->sc_dev.dv_xname);
		m_freem(mnew);
		ifp->if_ierrors++;
		goto skip;
	}
	m = data->m;
	data->m = mnew;
	data->buf = mtod(data->m, uint8_t *);

	/* finalize mbuf */
	m->m_data = (caddr_t)(desc + 1);
	m->m_pkthdr.len = m->m_len = (letoh32(desc->flags) >> 16) & 0xfff;

	s = splnet();

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rum_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = 0;
		tap->wr_rate = rum_rxrate(desc);
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wr_antenna = sc->rx_ant;
		tap->wr_antsignal = desc->rssi;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* send the frame to the 802.11 layer */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = desc->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);

	splx(s);

	DPRINTFN(15, ("rx done\n"));

skip:	/* setup a new transfer */
	usbd_setup_xfer(xfer, sc->sc_rx_pipeh, data, data->buf, MCLBYTES,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, rum_rxeof);
	(void)usbd_transfer(xfer);
}

/*
 * This function is only used by the Rx radiotap code. It returns the rate at
 * which a given frame was received.
 */
#if NBPFILTER > 0
uint8_t
rum_rxrate(const struct rum_rx_desc *desc)
{
	if (letoh32(desc->flags) & RT2573_RX_OFDM) {
		/* reverse function of rum_plcp_signal */
		switch (desc->rate) {
		case 0xb:	return 12;
		case 0xf:	return 18;
		case 0xa:	return 24;
		case 0xe:	return 36;
		case 0x9:	return 48;
		case 0xd:	return 72;
		case 0x8:	return 96;
		case 0xc:	return 108;
		}
	} else {
		if (desc->rate == 10)
			return 2;
		if (desc->rate == 20)
			return 4;
		if (desc->rate == 55)
			return 11;
		if (desc->rate == 110)
			return 22;
	}
	return 2;	/* should not get there */
}
#endif

/*
 * Return the expected ack rate for a frame transmitted at rate `rate'.
 */
int
rum_ack_rate(struct ieee80211com *ic, int rate)
{
	switch (rate) {
	/* CCK rates */
	case 2:
		return 2;
	case 4:
	case 11:
	case 22:
		return (ic->ic_curmode == IEEE80211_MODE_11B) ? 4 : rate;

	/* OFDM rates */
	case 12:
	case 18:
		return 12;
	case 24:
	case 36:
		return 24;
	case 48:
	case 72:
	case 96:
	case 108:
		return 48;
	}

	/* default to 1Mbps */
	return 2;
}

/*
 * Compute the duration (in us) needed to transmit `len' bytes at rate `rate'.
 * The function automatically determines the operating mode depending on the
 * given rate. `flags' indicates whether short preamble is in use or not.
 */
uint16_t
rum_txtime(int len, int rate, uint32_t flags)
{
	uint16_t txtime;

	if (RUM_RATE_IS_OFDM(rate)) {
		/* IEEE Std 802.11a-1999, pp. 37 */
		txtime = (8 + 4 * len + 3 + rate - 1) / rate;
		txtime = 16 + 4 + 4 * txtime + 6;
	} else {
		/* IEEE Std 802.11b-1999, pp. 28 */
		txtime = (16 * len + rate - 1) / rate;
		if (rate != 2 && (flags & IEEE80211_F_SHPREAMBLE))
			txtime +=  72 + 24;
		else
			txtime += 144 + 48;
	}
	return txtime;
}

uint8_t
rum_plcp_signal(int rate)
{
	switch (rate) {
	/* CCK rates (returned values are device-dependent) */
	case 2:		return 0x0;
	case 4:		return 0x1;
	case 11:	return 0x2;
	case 22:	return 0x3;

	/* OFDM rates (cf IEEE Std 802.11a-1999, pp. 14 Table 80) */
	case 12:	return 0xb;
	case 18:	return 0xf;
	case 24:	return 0xa;
	case 36:	return 0xe;
	case 48:	return 0x9;
	case 72:	return 0xd;
	case 96:	return 0x8;
	case 108:	return 0xc;

	/* unsupported rates (should not get there) */
	default:	return 0xff;
	}
}

void
rum_setup_tx_desc(struct rum_softc *sc, struct rum_tx_desc *desc,
    uint32_t flags, uint16_t xflags, int len, int rate)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t plcp_length;
	int remainder;

	desc->flags = htole32(flags);
	desc->flags |= htole32(RT2573_TX_VALID);
	desc->flags |= htole32(len << 16);

	desc->xflags = htole16(xflags);

	desc->wme = htole16(
	    RT2573_QID(0) |
	    RT2573_AIFSN(2) |
	    RT2573_LOGCWMIN(4) |
	    RT2573_LOGCWMAX(10));

	/* setup PLCP fields */
	desc->plcp_signal  = rum_plcp_signal(rate);
	desc->plcp_service = 4;

	len += IEEE80211_CRC_LEN;
	if (RUM_RATE_IS_OFDM(rate)) {
		desc->flags |= htole32(RT2573_TX_OFDM);

		plcp_length = len & 0xfff;
		desc->plcp_length_hi = plcp_length >> 6;
		desc->plcp_length_lo = plcp_length & 0x3f;
	} else {
		plcp_length = (16 * len + rate - 1) / rate;
		if (rate == 22) {
			remainder = (16 * len) % 22;
			if (remainder != 0 && remainder < 7)
				desc->plcp_service |= RT2573_PLCP_LENGEXT;
		}
		desc->plcp_length_hi = plcp_length >> 8;
		desc->plcp_length_lo = plcp_length & 0xff;

		if (rate != 2 && (ic->ic_flags & IEEE80211_F_SHPREAMBLE))
			desc->plcp_signal |= 0x08;
	}
}

#define RUM_TX_TIMEOUT	5000

int
rum_tx_data(struct rum_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rum_tx_desc *desc;
	struct rum_tx_data *data;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	uint32_t flags = 0;
	uint16_t dur;
	usbd_status error;
	int rate, xferlen, pktlen, needrts = 0, needcts = 0;

	wh = mtod(m0, struct ieee80211_frame *);

	if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
		k = ieee80211_get_txkey(ic, wh, ni);

		if ((m0 = ieee80211_encrypt(ic, m0, k)) == NULL)
			return ENOBUFS;

		/* packet header may have moved, reset our local pointer */
		wh = mtod(m0, struct ieee80211_frame *);
	}

	/* compute actual packet length (including CRC and crypto overhead) */
	pktlen = m0->m_pkthdr.len + IEEE80211_CRC_LEN;

	/* pickup a rate */
	if (IEEE80211_IS_MULTICAST(wh->i_addr1) ||
	    ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	     IEEE80211_FC0_TYPE_MGT)) {
		/* mgmt/multicast frames are sent at the lowest avail. rate */
		rate = ni->ni_rates.rs_rates[0];
	} else if (ic->ic_fixed_rate != -1) {
		rate = ic->ic_sup_rates[ic->ic_curmode].
		    rs_rates[ic->ic_fixed_rate];
	} else
		rate = ni->ni_rates.rs_rates[ni->ni_txrate];
	if (rate == 0)
		rate = 2;	/* XXX should not happen */
	rate &= IEEE80211_RATE_VAL;

	/* check if RTS/CTS or CTS-to-self protection must be used */
	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		/* multicast frames are not sent at OFDM rates in 802.11b/g */
		if (pktlen > ic->ic_rtsthreshold) {
			needrts = 1;	/* RTS/CTS based on frame length */
		} else if ((ic->ic_flags & IEEE80211_F_USEPROT) &&
		    RUM_RATE_IS_OFDM(rate)) {
			if (ic->ic_protmode == IEEE80211_PROT_CTSONLY)
				needcts = 1;	/* CTS-to-self */
			else if (ic->ic_protmode == IEEE80211_PROT_RTSCTS)
				needrts = 1;	/* RTS/CTS */
		}
	}
	if (needrts || needcts) {
		struct mbuf *mprot;
		int protrate, ackrate;
		uint16_t dur;

		protrate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;
		ackrate  = rum_ack_rate(ic, rate);

		dur = rum_txtime(pktlen, rate, ic->ic_flags) +
		      rum_txtime(RUM_ACK_SIZE, ackrate, ic->ic_flags) +
		      2 * sc->sifs;
		if (needrts) {
			dur += rum_txtime(RUM_CTS_SIZE, rum_ack_rate(ic,
			    protrate), ic->ic_flags) + sc->sifs;
			mprot = ieee80211_get_rts(ic, wh, dur);
		} else {
			mprot = ieee80211_get_cts_to_self(ic, dur);
		}
		if (mprot == NULL) {
			printf("%s: could not allocate protection frame\n",
			    sc->sc_dev.dv_xname);
			m_freem(m0);
			return ENOBUFS;
		}

		data = &sc->tx_data[sc->tx_cur];
		desc = (struct rum_tx_desc *)data->buf;

		/* avoid multiple free() of the same node for each fragment */
		data->ni = ieee80211_ref_node(ni);

		m_copydata(mprot, 0, mprot->m_pkthdr.len,
		    data->buf + RT2573_TX_DESC_SIZE);
		rum_setup_tx_desc(sc, desc,
		    (needrts ? RT2573_TX_NEED_ACK : 0) | RT2573_TX_MORE_FRAG,
		    0, mprot->m_pkthdr.len, protrate);

		/* no roundup necessary here */
		xferlen = RT2573_TX_DESC_SIZE + mprot->m_pkthdr.len;

		/* XXX may want to pass the protection frame to BPF */

		/* mbuf is no longer needed */
		m_freem(mprot);

		usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf,
		    xferlen, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
		    RUM_TX_TIMEOUT, rum_txeof);
		error = usbd_transfer(data->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS) {
			m_freem(m0);
			return error;
		}

		sc->tx_queued++;
		sc->tx_cur = (sc->tx_cur + 1) % RUM_TX_LIST_COUNT;

		flags |= RT2573_TX_LONG_RETRY | RT2573_TX_IFS_SIFS;
	}

	data = &sc->tx_data[sc->tx_cur];
	desc = (struct rum_tx_desc *)data->buf;

	data->ni = ni;

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2573_TX_NEED_ACK;

		dur = rum_txtime(RUM_ACK_SIZE, rum_ack_rate(ic, rate),
		    ic->ic_flags) + sc->sifs;
		*(uint16_t *)wh->i_dur = htole16(dur);

#ifndef IEEE80211_STA_ONLY
		/* tell hardware to set timestamp in probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RT2573_TX_TIMESTAMP;
#endif
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rum_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RT2573_TX_DESC_SIZE);
	rum_setup_tx_desc(sc, desc, flags, 0, m0->m_pkthdr.len, rate);

	/* align end on a 4-bytes boundary */
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 3) & ~3;

	/*
	 * No space left in the last URB to store the extra 4 bytes, force
	 * sending of another URB.
	 */
	if ((xferlen % 64) == 0)
		xferlen += 4;

	DPRINTFN(10, ("sending frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len + RT2573_TX_DESC_SIZE, rate, xferlen));

	/* mbuf is no longer needed */
	m_freem(m0);

	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RUM_TX_TIMEOUT, rum_txeof);
	error = usbd_transfer(data->xfer);
	if (error != 0 && error != USBD_IN_PROGRESS)
		return error;

	sc->tx_queued++;
	sc->tx_cur = (sc->tx_cur + 1) % RUM_TX_LIST_COUNT;

	return 0;
}

void
rum_start(struct ifnet *ifp)
{
	struct rum_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m0;

	/*
	 * net80211 may still try to send management frames even if the
	 * IFF_RUNNING flag is not set...
	 */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	for (;;) {
		if (sc->tx_queued >= RUM_TX_LIST_COUNT - 1) {
			ifq_set_oactive(&ifp->if_snd);
			break;
		}

		m0 = mq_dequeue(&ic->ic_mgtq);
		if (m0 != NULL) {
			ni = m0->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rum_tx_data(sc, m0, ni) != 0)
				break;

		} else {
			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m0);
			if (m0 == NULL)
				break;
#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m0, BPF_DIRECTION_OUT);
#endif
			m0 = ieee80211_encap(ifp, m0, &ni);
			if (m0 == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m0, BPF_DIRECTION_OUT);
#endif
			if (rum_tx_data(sc, m0, ni) != 0) {
				if (ni != NULL)
					ieee80211_release_node(ic, ni);
				ifp->if_oerrors++;
				break;
			}
		}

		sc->sc_tx_timer = 5;
		ifp->if_timer = 1;
	}
}

void
rum_watchdog(struct ifnet *ifp)
{
	struct rum_softc *sc = ifp->if_softc;

	ifp->if_timer = 0;

	if (sc->sc_tx_timer > 0) {
		if (--sc->sc_tx_timer == 0) {
			printf("%s: device timeout\n", sc->sc_dev.dv_xname);
			/*rum_init(ifp); XXX needs a process context! */
			ifp->if_oerrors++;
			return;
		}
		ifp->if_timer = 1;
	}

	ieee80211_watchdog(ifp);
}

int
rum_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct rum_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return ENXIO;

	usbd_ref_incr(sc->sc_udev);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				rum_update_promisc(sc);
			else
				rum_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				rum_stop(ifp, 1);
		}
		break;

	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);

		if (error == ENETRESET)
			error = 0;
		break;

	case SIOCS80211CHANNEL:
		/*
		 * This allows for fast channel switching in monitor mode
		 * (used by kismet). In IBSS mode, we must explicitly reset
		 * the interface to generate a new beacon frame.
		 */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING))
				rum_set_chan(sc, ic->ic_ibss_chan);
			error = 0;
		}
		break;

	default:
		error = ieee80211_ioctl(ifp, cmd, data);
	}

	if (error == ENETRESET) {
		if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
		    (IFF_UP | IFF_RUNNING))
			rum_init(ifp);
		error = 0;
	}

	splx(s);

	usbd_ref_decr(sc->sc_udev);

	return error;
}

void
rum_eeprom_read(struct rum_softc *sc, uint16_t addr, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RT2573_READ_EEPROM;
	USETW(req.wValue, 0);
	USETW(req.wIndex, addr);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not read EEPROM: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

uint32_t
rum_read(struct rum_softc *sc, uint16_t reg)
{
	uint32_t val;

	rum_read_multi(sc, reg, &val, sizeof val);

	return letoh32(val);
}

void
rum_read_multi(struct rum_softc *sc, uint16_t reg, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RT2573_READ_MULTI_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, len);

	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not multi read MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
}

void
rum_write(struct rum_softc *sc, uint16_t reg, uint32_t val)
{
	uint32_t tmp = htole32(val);

	rum_write_multi(sc, reg, &tmp, sizeof tmp);
}

void
rum_write_multi(struct rum_softc *sc, uint16_t reg, void *buf, size_t len)
{
	usb_device_request_t req;
	usbd_status error;
	int offset;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RT2573_WRITE_MULTI_MAC;
	USETW(req.wValue, 0);

	/* write at most 64 bytes at a time */
	for (offset = 0; offset < len; offset += 64) {
		USETW(req.wIndex, reg + offset);
		USETW(req.wLength, MIN(len - offset, 64));

		error = usbd_do_request(sc->sc_udev, &req, buf + offset);
		if (error != 0) {
			printf("%s: could not multi write MAC register: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(error));
		}
	}
}

void
rum_bbp_write(struct rum_softc *sc, uint8_t reg, uint8_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(rum_read(sc, RT2573_PHY_CSR3) & RT2573_BBP_BUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not write to BBP\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2573_BBP_BUSY | (reg & 0x7f) << 8 | val;
	rum_write(sc, RT2573_PHY_CSR3, tmp);
}

uint8_t
rum_bbp_read(struct rum_softc *sc, uint8_t reg)
{
	uint32_t val;
	int ntries;

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(rum_read(sc, RT2573_PHY_CSR3) & RT2573_BBP_BUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not read BBP\n", sc->sc_dev.dv_xname);
		return 0;
	}

	val = RT2573_BBP_BUSY | RT2573_BBP_READ | reg << 8;
	rum_write(sc, RT2573_PHY_CSR3, val);

	for (ntries = 0; ntries < 100; ntries++) {
		val = rum_read(sc, RT2573_PHY_CSR3);
		if (!(val & RT2573_BBP_BUSY))
			return val & 0xff;
		DELAY(1);
	}

	printf("%s: could not read BBP\n", sc->sc_dev.dv_xname);
	return 0;
}

void
rum_rf_write(struct rum_softc *sc, uint8_t reg, uint32_t val)
{
	uint32_t tmp;
	int ntries;

	for (ntries = 0; ntries < 5; ntries++) {
		if (!(rum_read(sc, RT2573_PHY_CSR4) & RT2573_RF_BUSY))
			break;
	}
	if (ntries == 5) {
		printf("%s: could not write to RF\n", sc->sc_dev.dv_xname);
		return;
	}

	tmp = RT2573_RF_BUSY | RT2573_RF_20BIT | (val & 0xfffff) << 2 |
	    (reg & 3);
	rum_write(sc, RT2573_PHY_CSR4, tmp);

	/* remember last written value in sc */
	sc->rf_regs[reg] = val;

	DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 3, val & 0xfffff));
}

void
rum_select_antenna(struct rum_softc *sc)
{
	uint8_t bbp4, bbp77;
	uint32_t tmp;

	bbp4  = rum_bbp_read(sc, 4);
	bbp77 = rum_bbp_read(sc, 77);

	/* TBD */

	/* make sure Rx is disabled before switching antenna */
	tmp = rum_read(sc, RT2573_TXRX_CSR0);
	rum_write(sc, RT2573_TXRX_CSR0, tmp | RT2573_DISABLE_RX);

	rum_bbp_write(sc,  4, bbp4);
	rum_bbp_write(sc, 77, bbp77);

	rum_write(sc, RT2573_TXRX_CSR0, tmp);
}

/*
 * Enable multi-rate retries for frames sent at OFDM rates.
 * In 802.11b/g mode, allow fallback to CCK rates.
 */
void
rum_enable_mrr(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

	tmp = rum_read(sc, RT2573_TXRX_CSR4);

	tmp &= ~RT2573_MRR_CCK_FALLBACK;
	if (!IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan))
		tmp |= RT2573_MRR_CCK_FALLBACK;
	tmp |= RT2573_MRR_ENABLED;

	rum_write(sc, RT2573_TXRX_CSR4, tmp);
}

void
rum_set_txpreamble(struct rum_softc *sc)
{
	uint32_t tmp;

	tmp = rum_read(sc, RT2573_TXRX_CSR4);

	tmp &= ~RT2573_SHORT_PREAMBLE;
	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
		tmp |= RT2573_SHORT_PREAMBLE;

	rum_write(sc, RT2573_TXRX_CSR4, tmp);
}

void
rum_set_basicrates(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* update basic rate set */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		/* 11b basic rates: 1, 2Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x3);
	} else if (ic->ic_curmode == IEEE80211_MODE_11A) {
		/* 11a basic rates: 6, 12, 24Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x150);
	} else {
		/* 11b/g basic rates: 1, 2, 5.5, 11Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0xf);
	}
}

/*
 * Reprogram MAC/BBP to switch to a new band.  Values taken from the reference
 * driver.
 */
void
rum_select_band(struct rum_softc *sc, struct ieee80211_channel *c)
{
	uint8_t bbp17, bbp35, bbp96, bbp97, bbp98, bbp104;
	uint32_t tmp;

	/* update all BBP registers that depend on the band */
	bbp17 = 0x20; bbp96 = 0x48; bbp104 = 0x2c;
	bbp35 = 0x50; bbp97 = 0x48; bbp98  = 0x48;
	if (IEEE80211_IS_CHAN_5GHZ(c)) {
		bbp17 += 0x08; bbp96 += 0x10; bbp104 += 0x0c;
		bbp35 += 0x10; bbp97 += 0x10; bbp98  += 0x10;
	}
	if ((IEEE80211_IS_CHAN_2GHZ(c) && sc->ext_2ghz_lna) ||
	    (IEEE80211_IS_CHAN_5GHZ(c) && sc->ext_5ghz_lna)) {
		bbp17 += 0x10; bbp96 += 0x10; bbp104 += 0x10;
	}

	sc->bbp17 = bbp17;
	rum_bbp_write(sc,  17, bbp17);
	rum_bbp_write(sc,  96, bbp96);
	rum_bbp_write(sc, 104, bbp104);

	if ((IEEE80211_IS_CHAN_2GHZ(c) && sc->ext_2ghz_lna) ||
	    (IEEE80211_IS_CHAN_5GHZ(c) && sc->ext_5ghz_lna)) {
		rum_bbp_write(sc, 75, 0x80);
		rum_bbp_write(sc, 86, 0x80);
		rum_bbp_write(sc, 88, 0x80);
	}

	rum_bbp_write(sc, 35, bbp35);
	rum_bbp_write(sc, 97, bbp97);
	rum_bbp_write(sc, 98, bbp98);

	tmp = rum_read(sc, RT2573_PHY_CSR0);
	tmp &= ~(RT2573_PA_PE_2GHZ | RT2573_PA_PE_5GHZ);
	if (IEEE80211_IS_CHAN_2GHZ(c))
		tmp |= RT2573_PA_PE_2GHZ;
	else
		tmp |= RT2573_PA_PE_5GHZ;
	rum_write(sc, RT2573_PHY_CSR0, tmp);

	/* 802.11a uses a 16 microseconds short interframe space */
	sc->sifs = IEEE80211_IS_CHAN_5GHZ(c) ? 16 : 10;
}

void
rum_set_chan(struct rum_softc *sc, struct ieee80211_channel *c)
{
	struct ieee80211com *ic = &sc->sc_ic;
	const struct rfprog *rfprog;
	uint8_t bbp3, bbp94 = RT2573_BBPR94_DEFAULT;
	int8_t power;
	u_int i, chan;

	chan = ieee80211_chan2ieee(ic, c);
	if (chan == 0 || chan == IEEE80211_CHAN_ANY)
		return;

	/* select the appropriate RF settings based on what EEPROM says */
	rfprog = (sc->rf_rev == RT2573_RF_5225 ||
		  sc->rf_rev == RT2573_RF_2527) ? rum_rf5225 : rum_rf5226;

	/* find the settings for this channel (we know it exists) */
	for (i = 0; rfprog[i].chan != chan; i++);

	power = sc->txpow[i];
	if (power < 0) {
		bbp94 += power;
		power = 0;
	} else if (power > 31) {
		bbp94 += power - 31;
		power = 31;
	}

	/*
	 * If we are switching from the 2GHz band to the 5GHz band or
	 * vice-versa, BBP registers need to be reprogrammed.
	 */
	if (c->ic_flags != sc->sc_curchan->ic_flags) {
		rum_select_band(sc, c);
		rum_select_antenna(sc);
	}
	sc->sc_curchan = c;

	rum_rf_write(sc, RT2573_RF1, rfprog[i].r1);
	rum_rf_write(sc, RT2573_RF2, rfprog[i].r2);
	rum_rf_write(sc, RT2573_RF3, rfprog[i].r3 | power << 7);
	rum_rf_write(sc, RT2573_RF4, rfprog[i].r4 | sc->rffreq << 10);

	rum_rf_write(sc, RT2573_RF1, rfprog[i].r1);
	rum_rf_write(sc, RT2573_RF2, rfprog[i].r2);
	rum_rf_write(sc, RT2573_RF3, rfprog[i].r3 | power << 7 | 1);
	rum_rf_write(sc, RT2573_RF4, rfprog[i].r4 | sc->rffreq << 10);

	rum_rf_write(sc, RT2573_RF1, rfprog[i].r1);
	rum_rf_write(sc, RT2573_RF2, rfprog[i].r2);
	rum_rf_write(sc, RT2573_RF3, rfprog[i].r3 | power << 7);
	rum_rf_write(sc, RT2573_RF4, rfprog[i].r4 | sc->rffreq << 10);

	DELAY(10);

	/* enable smart mode for MIMO-capable RFs */
	bbp3 = rum_bbp_read(sc, 3);

	bbp3 &= ~RT2573_SMART_MODE;
	if (sc->rf_rev == RT2573_RF_5225 || sc->rf_rev == RT2573_RF_2527)
		bbp3 |= RT2573_SMART_MODE;

	rum_bbp_write(sc, 3, bbp3);

	if (bbp94 != RT2573_BBPR94_DEFAULT)
		rum_bbp_write(sc, 94, bbp94);
}

/*
 * Enable TSF synchronization and tell h/w to start sending beacons for IBSS
 * and HostAP operating modes.
 */
void
rum_enable_tsf_sync(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

#ifndef IEEE80211_STA_ONLY
	if (ic->ic_opmode != IEEE80211_M_STA) {
		/*
		 * Change default 16ms TBTT adjustment to 8ms.
		 * Must be done before enabling beacon generation.
		 */
		rum_write(sc, RT2573_TXRX_CSR10, 1 << 12 | 8);
	}
#endif

	tmp = rum_read(sc, RT2573_TXRX_CSR9) & 0xff000000;

	/* set beacon interval (in 1/16ms unit) */
	tmp |= ic->ic_bss->ni_intval * 16;

	tmp |= RT2573_TSF_TICKING | RT2573_ENABLE_TBTT;
	if (ic->ic_opmode == IEEE80211_M_STA)
		tmp |= RT2573_TSF_MODE(1);
#ifndef IEEE80211_STA_ONLY
	else
		tmp |= RT2573_TSF_MODE(2) | RT2573_GENERATE_BEACON;
#endif
	rum_write(sc, RT2573_TXRX_CSR9, tmp);
}

void
rum_update_slot(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint8_t slottime;
	uint32_t tmp;

	slottime = (ic->ic_flags & IEEE80211_F_SHSLOT) ? 9 : 20;

	tmp = rum_read(sc, RT2573_MAC_CSR9);
	tmp = (tmp & ~0xff) | slottime;
	rum_write(sc, RT2573_MAC_CSR9, tmp);

	DPRINTF(("setting slot time to %uus\n", slottime));
}

void
rum_set_bssid(struct rum_softc *sc, const uint8_t *bssid)
{
	uint32_t tmp;

	tmp = bssid[0] | bssid[1] << 8 | bssid[2] << 16 | bssid[3] << 24;
	rum_write(sc, RT2573_MAC_CSR4, tmp);

	tmp = bssid[4] | bssid[5] << 8 | RT2573_ONE_BSSID << 16;
	rum_write(sc, RT2573_MAC_CSR5, tmp);
}

void
rum_set_macaddr(struct rum_softc *sc, const uint8_t *addr)
{
	uint32_t tmp;

	tmp = addr[0] | addr[1] << 8 | addr[2] << 16 | addr[3] << 24;
	rum_write(sc, RT2573_MAC_CSR2, tmp);

	tmp = addr[4] | addr[5] << 8 | 0xff << 16;
	rum_write(sc, RT2573_MAC_CSR3, tmp);
}

void
rum_update_promisc(struct rum_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	uint32_t tmp;

	tmp = rum_read(sc, RT2573_TXRX_CSR0);

	tmp &= ~RT2573_DROP_NOT_TO_ME;
	if (!(ifp->if_flags & IFF_PROMISC))
		tmp |= RT2573_DROP_NOT_TO_ME;

	rum_write(sc, RT2573_TXRX_CSR0, tmp);

	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
	    "entering" : "leaving"));
}

const char *
rum_get_rf(int rev)
{
	switch (rev) {
	case RT2573_RF_2527:	return "RT2527 (MIMO XR)";
	case RT2573_RF_2528:	return "RT2528";
	case RT2573_RF_5225:	return "RT5225 (MIMO XR)";
	case RT2573_RF_5226:	return "RT5226";
	default:		return "unknown";
	}
}

void
rum_read_eeprom(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	uint16_t val;
#ifdef RUM_DEBUG
	int i;
#endif

	/* read MAC/BBP type */
	rum_eeprom_read(sc, RT2573_EEPROM_MACBBP, &val, 2);
	sc->macbbp_rev = letoh16(val);

	/* read MAC address */
	rum_eeprom_read(sc, RT2573_EEPROM_ADDRESS, ic->ic_myaddr, 6);

	rum_eeprom_read(sc, RT2573_EEPROM_ANTENNA, &val, 2);
	val = letoh16(val);
	sc->rf_rev =   (val >> 11) & 0x1f;
	sc->hw_radio = (val >> 10) & 0x1;
	sc->rx_ant =   (val >> 4)  & 0x3;
	sc->tx_ant =   (val >> 2)  & 0x3;
	sc->nb_ant =   val & 0x3;

	DPRINTF(("RF revision=%d\n", sc->rf_rev));

	rum_eeprom_read(sc, RT2573_EEPROM_CONFIG2, &val, 2);
	val = letoh16(val);
	sc->ext_5ghz_lna = (val >> 6) & 0x1;
	sc->ext_2ghz_lna = (val >> 4) & 0x1;

	DPRINTF(("External 2GHz LNA=%d\nExternal 5GHz LNA=%d\n",
	    sc->ext_2ghz_lna, sc->ext_5ghz_lna));

	rum_eeprom_read(sc, RT2573_EEPROM_RSSI_2GHZ_OFFSET, &val, 2);
	val = letoh16(val);
	if ((val & 0xff) != 0xff)
		sc->rssi_2ghz_corr = (int8_t)(val & 0xff);	/* signed */

	rum_eeprom_read(sc, RT2573_EEPROM_RSSI_5GHZ_OFFSET, &val, 2);
	val = letoh16(val);
	if ((val & 0xff) != 0xff)
		sc->rssi_5ghz_corr = (int8_t)(val & 0xff);	/* signed */

	DPRINTF(("RSSI 2GHz corr=%d\nRSSI 5GHz corr=%d\n",
	    sc->rssi_2ghz_corr, sc->rssi_5ghz_corr));

	rum_eeprom_read(sc, RT2573_EEPROM_FREQ_OFFSET, &val, 2);
	val = letoh16(val);
	if ((val & 0xff) != 0xff)
		sc->rffreq = val & 0xff;

	DPRINTF(("RF freq=%d\n", sc->rffreq));

	/* read Tx power for all a/b/g channels */
	rum_eeprom_read(sc, RT2573_EEPROM_TXPOWER, sc->txpow, 14);
	/* XXX default Tx power for 802.11a channels */
	memset(sc->txpow + 14, 24, sizeof (sc->txpow) - 14);
#ifdef RUM_DEBUG
	for (i = 0; i < 14; i++)
		DPRINTF(("Channel=%d Tx power=%d\n", i + 1,  sc->txpow[i]));
#endif

	/* read default values for BBP registers */
	rum_eeprom_read(sc, RT2573_EEPROM_BBP_BASE, sc->bbp_prom, 2 * 16);
#ifdef RUM_DEBUG
	for (i = 0; i < 14; i++) {
		if (sc->bbp_prom[i].reg == 0 || sc->bbp_prom[i].reg == 0xff)
			continue;
		DPRINTF(("BBP R%d=%02x\n", sc->bbp_prom[i].reg,
		    sc->bbp_prom[i].val));
	}
#endif
}

int
rum_bbp_init(struct rum_softc *sc)
{
	int i, ntries;

	/* wait for BBP to be ready */
	for (ntries = 0; ntries < 100; ntries++) {
		const uint8_t val = rum_bbp_read(sc, 0);
		if (val != 0 && val != 0xff)
			break;
		DELAY(1000);
	}
	if (ntries == 100) {
		printf("%s: timeout waiting for BBP\n",
		    sc->sc_dev.dv_xname);
		return EIO;
	}

	/* initialize BBP registers to default values */
	for (i = 0; i < nitems(rum_def_bbp); i++)
		rum_bbp_write(sc, rum_def_bbp[i].reg, rum_def_bbp[i].val);

	/* write vendor-specific BBP values (from EEPROM) */
	for (i = 0; i < 16; i++) {
		if (sc->bbp_prom[i].reg == 0 || sc->bbp_prom[i].reg == 0xff)
			continue;
		rum_bbp_write(sc, sc->bbp_prom[i].reg, sc->bbp_prom[i].val);
	}

	return 0;
}

int
rum_init(struct ifnet *ifp)
{
	struct rum_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;
	usbd_status error;
	int i, ntries;

	rum_stop(ifp, 0);

	/* initialize MAC registers to default values */
	for (i = 0; i < nitems(rum_def_mac); i++)
		rum_write(sc, rum_def_mac[i].reg, rum_def_mac[i].val);

	/* set host ready */
	rum_write(sc, RT2573_MAC_CSR1, 3);
	rum_write(sc, RT2573_MAC_CSR1, 0);

	/* wait for BBP/RF to wakeup */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (rum_read(sc, RT2573_MAC_CSR12) & 8)
			break;
		rum_write(sc, RT2573_MAC_CSR12, 4);	/* force wakeup */
		DELAY(1000);
	}
	if (ntries == 1000) {
		printf("%s: timeout waiting for BBP/RF to wakeup\n",
		    sc->sc_dev.dv_xname);
		error = ENODEV;
		goto fail;
	}

	if ((error = rum_bbp_init(sc)) != 0)
		goto fail;

	/* select default channel */
	sc->sc_curchan = ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	rum_select_band(sc, sc->sc_curchan);
	rum_select_antenna(sc);
	rum_set_chan(sc, sc->sc_curchan);

	/* clear STA registers */
	rum_read_multi(sc, RT2573_STA_CSR0, sc->sta, sizeof sc->sta);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));
	rum_set_macaddr(sc, ic->ic_myaddr);

	/* initialize ASIC */
	rum_write(sc, RT2573_MAC_CSR1, 4);

	/*
	 * Allocate xfer for AMRR statistics requests.
	 */
	sc->amrr_xfer = usbd_alloc_xfer(sc->sc_udev);
	if (sc->amrr_xfer == NULL) {
		printf("%s: could not allocate AMRR xfer\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Open Tx and Rx USB bulk pipes.
	 */
	error = usbd_open_pipe(sc->sc_iface, sc->sc_tx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_tx_pipeh);
	if (error != 0) {
		printf("%s: could not open Tx pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	error = usbd_open_pipe(sc->sc_iface, sc->sc_rx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_rx_pipeh);
	if (error != 0) {
		printf("%s: could not open Rx pipe: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/*
	 * Allocate Tx and Rx xfer queues.
	 */
	error = rum_alloc_tx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Tx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	error = rum_alloc_rx_list(sc);
	if (error != 0) {
		printf("%s: could not allocate Rx list\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}

	/*
	 * Start up the receive pipe.
	 */
	for (i = 0; i < RUM_RX_LIST_COUNT; i++) {
		struct rum_rx_data *data = &sc->rx_data[i];

		usbd_setup_xfer(data->xfer, sc->sc_rx_pipeh, data, data->buf,
		    MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, rum_rxeof);
		error = usbd_transfer(data->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS) {
			printf("%s: could not queue Rx transfer\n",
			    sc->sc_dev.dv_xname);
			goto fail;
		}
	}

	/* update Rx filter */
	tmp = rum_read(sc, RT2573_TXRX_CSR0) & 0xffff;

	tmp |= RT2573_DROP_PHY_ERROR | RT2573_DROP_CRC_ERROR;
	if (ic->ic_opmode != IEEE80211_M_MONITOR) {
		tmp |= RT2573_DROP_CTL | RT2573_DROP_VER_ERROR |
		       RT2573_DROP_ACKCTS;
#ifndef IEEE80211_STA_ONLY
		if (ic->ic_opmode != IEEE80211_M_HOSTAP)
#endif
			tmp |= RT2573_DROP_TODS;
		if (!(ifp->if_flags & IFF_PROMISC))
			tmp |= RT2573_DROP_NOT_TO_ME;
	}
	rum_write(sc, RT2573_TXRX_CSR0, tmp);

	ifq_clr_oactive(&ifp->if_snd);
	ifp->if_flags |= IFF_RUNNING;

	if (ic->ic_opmode == IEEE80211_M_MONITOR)
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return 0;

fail:	rum_stop(ifp, 1);
	return error;
}

void
rum_stop(struct ifnet *ifp, int disable)
{
	struct rum_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	uint32_t tmp;

	sc->sc_tx_timer = 0;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);	/* free all nodes */

	/* disable Rx */
	tmp = rum_read(sc, RT2573_TXRX_CSR0);
	rum_write(sc, RT2573_TXRX_CSR0, tmp | RT2573_DISABLE_RX);

	/* reset ASIC */
	rum_write(sc, RT2573_MAC_CSR1, 3);
	rum_write(sc, RT2573_MAC_CSR1, 0);

	if (sc->amrr_xfer != NULL) {
		usbd_free_xfer(sc->amrr_xfer);
		sc->amrr_xfer = NULL;
	}
	if (sc->sc_rx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_rx_pipeh);
		usbd_close_pipe(sc->sc_rx_pipeh);
		sc->sc_rx_pipeh = NULL;
	}
	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
		sc->sc_tx_pipeh = NULL;
	}

	rum_free_rx_list(sc);
	rum_free_tx_list(sc);
}

int
rum_load_microcode(struct rum_softc *sc, const u_char *ucode, size_t size)
{
	usb_device_request_t req;
	uint16_t reg = RT2573_MCU_CODE_BASE;
	usbd_status error;

	/* copy firmware image into NIC */
	for (; size >= 4; reg += 4, ucode += 4, size -= 4)
		rum_write(sc, reg, UGETDW(ucode));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RT2573_MCU_CNTL;
	USETW(req.wValue, RT2573_MCU_RUN);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	error = usbd_do_request(sc->sc_udev, &req, NULL);
	if (error != 0) {
		printf("%s: could not run firmware: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
	}
	return error;
}

#ifndef IEEE80211_STA_ONLY
int
rum_prepare_beacon(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rum_tx_desc desc;
	struct mbuf *m0;
	int rate;

	m0 = ieee80211_beacon_alloc(ic, ic->ic_bss);
	if (m0 == NULL) {
		printf("%s: could not allocate beacon frame\n",
		    sc->sc_dev.dv_xname);
		return ENOBUFS;
	}

	/* send beacons at the lowest available rate */
	rate = IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan) ? 12 : 2;

	rum_setup_tx_desc(sc, &desc, RT2573_TX_TIMESTAMP, RT2573_TX_HWSEQ,
	    m0->m_pkthdr.len, rate);

	/* copy the first 24 bytes of Tx descriptor into NIC memory */
	rum_write_multi(sc, RT2573_HW_BEACON_BASE0, (uint8_t *)&desc, 24);

	/* copy beacon header and payload into NIC memory */
	rum_write_multi(sc, RT2573_HW_BEACON_BASE0 + 24, mtod(m0, uint8_t *),
	    m0->m_pkthdr.len);

	m_freem(m0);

	return 0;
}
#endif

void
rum_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	/* start with lowest Tx rate */
	ni->ni_txrate = 0;
}

void
rum_amrr_start(struct rum_softc *sc, struct ieee80211_node *ni)
{
	int i;

	/* clear statistic registers (STA_CSR0 to STA_CSR5) */
	rum_read_multi(sc, RT2573_STA_CSR0, sc->sta, sizeof sc->sta);

	ieee80211_amrr_node_init(&sc->amrr, &sc->amn);

	/* set rate to some reasonable initial value */
	for (i = ni->ni_rates.rs_nrates - 1;
	     i > 0 && (ni->ni_rates.rs_rates[i] & IEEE80211_RATE_VAL) > 72;
	     i--);
	ni->ni_txrate = i;

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->amrr_to, 1);
}

void
rum_amrr_timeout(void *arg)
{
	struct rum_softc *sc = arg;
	usb_device_request_t req;

	if (usbd_is_dying(sc->sc_udev))
		return;

	/*
	 * Asynchronously read statistic registers (cleared by read).
	 */
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RT2573_READ_MULTI_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, RT2573_STA_CSR0);
	USETW(req.wLength, sizeof sc->sta);

	usbd_setup_default_xfer(sc->amrr_xfer, sc->sc_udev, sc,
	    USBD_DEFAULT_TIMEOUT, &req, sc->sta, sizeof sc->sta, 0,
	    rum_amrr_update);
	(void)usbd_transfer(sc->amrr_xfer);
}

void
rum_amrr_update(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct rum_softc *sc = (struct rum_softc *)priv;
	struct ifnet *ifp = &sc->sc_ic.ic_if;

	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: could not retrieve Tx statistics - cancelling "
		    "automatic rate control\n", sc->sc_dev.dv_xname);
		return;
	}

	/* count TX retry-fail as Tx errors */
	ifp->if_oerrors += letoh32(sc->sta[5]) >> 16;

	sc->amn.amn_retrycnt =
	    (letoh32(sc->sta[4]) >> 16) +	/* TX one-retry ok count */
	    (letoh32(sc->sta[5]) & 0xffff) +	/* TX more-retry ok count */
	    (letoh32(sc->sta[5]) >> 16);	/* TX retry-fail count */

	sc->amn.amn_txcnt =
	    sc->amn.amn_retrycnt +
	    (letoh32(sc->sta[4]) & 0xffff);	/* TX no-retry ok count */

	ieee80211_amrr_choose(&sc->amrr, sc->sc_ic.ic_bss, &sc->amn);

	if (!usbd_is_dying(sc->sc_udev))
		timeout_add_sec(&sc->amrr_to, 1);
}
@


1.120
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.119 2016/04/13 11:03:37 mpi Exp $	*/
d257 1
a257 1
	free(ucode, M_DEVBUF, 0);
@


1.119
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.118 2015/12/11 16:07:02 mpi Exp $	*/
a744 1
	ifp->if_opackets++;
@


1.118
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.117 2015/11/25 03:10:00 dlg Exp $	*/
a391 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.117
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.116 2015/11/24 13:45:06 mpi Exp $	*/
d130 1
a130 1
void		rum_attachhook(void *);
d238 1
a238 1
rum_attachhook(void *xsc)
d240 1
a240 1
	struct rum_softc *sc = xsc;
d327 1
a327 4
	if (rootvp == NULL)
		mountroothook_establish(rum_attachhook, sc);
	else
		rum_attachhook(sc);
@


1.116
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.115 2015/11/24 13:33:18 mpi Exp $	*/
d754 1
a754 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1239 1
a1239 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1244 1
a1244 1
			ifp->if_flags |= IFF_OACTIVE;
d2069 1
a2069 1
	ifp->if_flags &= ~IFF_OACTIVE;
d2092 2
a2093 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.115
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.114 2015/11/13 10:36:29 mpi Exp $	*/
a43 1
#include <net/if_arp.h>
@


1.114
log
@Check for space on the ring before dequeuing packets.

Allows us to get rid of mq_requeue(9) and IFQ_POLL(9) because wireless
drivers use a special queue for management frames.

Tested by stsp@@, ok dlg@@, stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.113 2015/11/04 12:12:00 dlg Exp $	*/
a46 1
#include <net/if_types.h>
@


1.113
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.112 2015/10/25 12:11:56 mpi Exp $	*/
d1245 5
a1251 6
			if (sc->tx_queued >= RUM_TX_LIST_COUNT - 1) {
				mq_requeue(&ic->ic_mgtq, m0);
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}

d1263 2
a1264 1
			IFQ_POLL(&ifp->if_snd, m0);
a1266 5
			if (sc->tx_queued >= RUM_TX_LIST_COUNT - 1) {
				ifp->if_flags |= IFF_OACTIVE;
				break;
			}
			IFQ_DEQUEUE(&ifp->if_snd, m0);
@


1.112
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.111 2015/06/12 15:47:31 mpi Exp $	*/
d1245 1
a1245 1
		IF_POLL(&ic->ic_mgtq, m0);
d1248 1
a1251 1
			IF_DEQUEUE(&ic->ic_mgtq, m0);
@


1.111
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tests & ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.110 2015/03/14 03:38:49 jsg Exp $	*/
a1320 1
	struct ifaddr *ifa;
a1332 1
		ifa = (struct ifaddr *)data;
a1333 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.110
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.109 2015/02/10 23:25:46 mpi Exp $	*/
d232 1
a232 1
	if (uaa->iface != NULL)
d236 1
a236 1
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
a270 1
	usbd_status error;
d275 1
a275 15

	if (usbd_set_config_no(sc->sc_udev, RT2573_CONFIG_NO, 0) != 0) {
		printf("%s: could not set configuration no\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, RT2573_IFACE_INDEX,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.109
log
@Wireless drivers call if_input() via ieee80211_input() which set `rcvif'
on every received mbuf, so there's no need to initialize this pointer in
the drivers.

Tested by and ok phessler@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.108 2014/12/22 02:28:52 tedu Exp $	*/
a37 1
#include <machine/bus.h>
@


1.108
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.107 2014/12/19 22:44:59 guenther Exp $	*/
a841 1
	m->m_pkthdr.rcvif = ifp;
@


1.107
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.106 2014/07/13 15:52:49 mpi Exp $	*/
a1352 1
#ifdef INET
a1354 1
#endif
@


1.106
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.105 2014/07/12 18:48:52 tedu Exp $	*/
d36 1
a38 1
#include <machine/endian.h>
@


1.105
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.104 2014/07/12 07:59:23 mpi Exp $	*/
a50 1
#include <netinet/in_systm.h>
a51 1
#include <netinet/ip.h>
@


1.104
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.103 2014/03/19 10:09:19 mpi Exp $	*/
d262 1
a262 1
	free(ucode, M_DEVBUF);
@


1.103
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.102 2014/03/07 18:39:02 mpi Exp $	*/
d218 10
a227 15
int rum_match(struct device *, void *, void *); 
void rum_attach(struct device *, struct device *, void *); 
int rum_detach(struct device *, int); 
int rum_activate(struct device *, int); 

struct cfdriver rum_cd = { 
	NULL, "rum", DV_IFNET 
}; 

const struct cfattach rum_ca = { 
	sizeof(struct rum_softc), 
	rum_match, 
	rum_attach, 
	rum_detach, 
	rum_activate, 
a2294 14
}

int
rum_activate(struct device *self, int act)
{
	struct rum_softc *sc = (struct rum_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}

	return 0;
@


1.102
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.101 2013/08/07 01:06:42 bluhm Exp $	*/
d1277 1
a1277 2
			ni = (struct ieee80211_node *)m0->m_pkthdr.rcvif;
			m0->m_pkthdr.rcvif = NULL;
@


1.101
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.100 2013/04/15 09:23:01 mglocker Exp $	*/
a65 4

#ifdef USB_DEBUG
#define RUM_DEBUG
#endif
@


1.100
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.99 2011/10/26 17:31:54 jasper Exp $	*/
a51 1
#include <netinet/in_var.h>
@


1.99
log
@apply a fix by Steven Chamberlain <steven@@pyro.eu.org>, via freebsd:

Fix an issue with 11g beacon frames which looks to be a limitation
on the largest multi-write size:

==
I looked further into the magic 88-byte threshold after which the bug
occurs.  It turns out that figure included the 24-byte tx_desc, and up
to 64 bytes of beacon frame (header+data).

rum_write_multi doesn't seem happy with writing >64 bytes at a time to
the MAC register.  If I break it up into separate calls (e.g. bytes
0-63, then bytes 64-65, written at the appropriate offset) I see the
proper beacon frames being transmitted now.
==

tweak by miod@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.98 2011/07/03 15:47:17 matthew Exp $	*/
d149 2
a150 2
void		rum_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		rum_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d197 1
a197 1
void		rum_amrr_update(usbd_xfer_handle, usbd_private_handle,
d751 1
a751 1
rum_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d791 1
a791 1
rum_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d2278 1
a2278 1
rum_amrr_update(usbd_xfer_handle xfer, usbd_private_handle priv,
@


1.98
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.97 2011/01/25 20:03:35 jakemsr Exp $	*/
d1489 1
a1493 2
	USETW(req.wIndex, reg);
	USETW(req.wLength, len);
d1495 10
a1504 4
	error = usbd_do_request(sc->sc_udev, &req, buf);
	if (error != 0) {
		printf("%s: could not multi write MAC register: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
@


1.97
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.96 2010/12/30 05:22:51 jakemsr Exp $	*/
a2308 3
	case DVACT_ACTIVATE:
		break;

@


1.96
log
@* do not add timeouts if the driver is dying
* use usbd_ref_{incr,decr,wait} to not detach while another process/thread
  is using the driver
* s/usb_rem_task/usb_rem_wait_task/ in detach functions because detach
  doesn't always happen in the task thread; otherwise a task could be
  running while the driver detaches
* in detach functions, first delete pending timeouts, then wait for
  processes to be done with the driver before freeing resources

ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.95 2010/12/17 22:38:54 jasper Exp $	*/
a448 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
	    &sc->sc_dev);
a490 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.95
log
@- use nitems()

ok jakemsr@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.94 2010/12/06 04:41:39 jakemsr Exp $	*/
d463 9
a476 6
	usb_rem_task(sc->sc_udev, &sc->sc_task);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->amrr_to))
		timeout_del(&sc->amrr_to);

d653 2
d657 2
d686 2
a687 1
		timeout_add_msec(&sc->scan_to, 200);
d1361 5
d1429 2
d2250 2
a2251 1
	timeout_add_sec(&sc->amrr_to, 1);
d2305 2
a2306 1
	timeout_add_sec(&sc->amrr_to, 1);
@


1.94
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.93 2010/10/27 17:51:11 jakemsr Exp $	*/
a1941 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1958 1
a1958 1
	for (i = 0; i < N(rum_def_bbp); i++)
a1968 1
#undef N
a1973 1
#define N(a)	(sizeof (a) / sizeof ((a)[0]))
d1983 1
a1983 1
	for (i = 0; i < N(rum_def_mac); i++)
a2109 1
#undef N
@


1.93
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.92 2010/10/23 16:14:07 jakemsr Exp $	*/
d647 3
d663 3
d2248 3
d2299 2
d2306 1
@


1.92
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.91 2010/10/23 15:42:09 jakemsr Exp $	*/
d463 4
a466 2
	ieee80211_ifdetach(ifp);	/* free all nodes */
	if_detach(ifp);
@


1.91
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.90 2010/08/27 17:08:01 jsg Exp $	*/
d467 4
a470 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->amrr_to);
@


1.90
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.89 2010/07/02 03:13:42 tedu Exp $	*/
d331 1
a331 1
	usb_init_task(&sc->sc_task, rum_task, sc);
@


1.89
log
@fix a variety of uninit errors.  ok and one correction deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.88 2010/04/20 22:05:43 tedu Exp $	*/
a421 1
	ifp->if_init = rum_init;
@


1.88
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.87 2009/10/13 19:33:17 pirofti Exp $	*/
d1994 1
@


1.87
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.86 2009/08/02 10:38:34 miod Exp $	*/
a28 1
#include <sys/sysctl.h>
@


1.86
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.85 2009/07/10 07:40:04 blambert Exp $	*/
d227 1
a227 1
int rum_activate(struct device *, enum devact); 
d2285 1
a2285 1
rum_activate(struct device *self, enum devact act)
@


1.85
log
@timeout_add -> timeout_add_msec

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.84 2009/03/27 14:59:31 jsg Exp $	*/
d2289 1
a2289 1
		return EOPNOTSUPP;
@


1.84
log
@Match on Edimax EW-7318Ug, EW-7318USg, EW-7618Ug
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.83 2009/03/27 11:38:46 jsg Exp $	*/
d671 1
a671 1
		timeout_add(&sc->scan_to, hz / 5);
@


1.83
log
@Linksys WUSB200 should work according to linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.82 2009/02/03 10:53:28 kevlo Exp $	*/
d108 2
@


1.82
log
@add Buffalo WLI-U2-SG54HG

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.81 2008/12/22 18:42:04 damien Exp $	*/
d95 1
@


1.81
log
@do not leak an AMRR USB xfer at each ifconfig down/up.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.80 2008/12/10 18:10:14 deraadt Exp $	*/
d116 1
@


1.80
log
@another rum; Arndt at ba-loerrach.de
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.79 2008/10/15 19:12:18 blambert Exp $	*/
d2124 4
@


1.79
log
@Second pass of simple timeout_add -> timeout_add_sec conversions
This should take care of the simpler ones (i.e., timeout values of
integer multiples of hz).

ok krw@@, art@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.78 2008/08/27 09:05:03 damien Exp $	*/
d98 1
@


1.78
log
@introduce new IEEE80211_STA_ONLY kernel option that can be set to
remove IBSS and HostAP support from net80211 and 802.11 drivers.
it can be used to shrink RAMDISK kernels for instance (like what
was done for wi(4)).
it also has the benefit of highlighting what is specific to IBSS
and HostAP modes in the code.
the cost is that we now have two code paths to maintain.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.77 2008/08/19 02:34:04 deraadt Exp $	*/
d2221 1
a2221 1
	timeout_add(&sc->amrr_to, hz);
d2272 1
a2272 1
	timeout_add(&sc->amrr_to, hz);
@


1.77
log
@another rum; Jonathan Lee
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.76 2008/08/14 16:02:24 damien Exp $	*/
d186 1
d188 1
d364 2
a366 1
	    IEEE80211_C_MONITOR |	/* monitor mode supported */
d368 1
d690 1
d694 1
d1182 1
d1188 1
d1756 1
d1764 1
d1774 1
d1777 1
a1777 1

d2078 1
d2080 1
d2163 1
d2196 1
@


1.76
log
@in ieee80211_input(), call if_start() after enqueuing frames in if_snd
when acting as an access point instead of having each driver doing the
job.

tested by krw@@ (ral AP) and me with several drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.75 2008/07/30 06:25:23 damien Exp $	*/
d103 1
@


1.75
log
@Free the correct buffer list on failure.

From Andrew Thompson at FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.74 2008/07/21 18:43:19 damien Exp $	*/
a870 7

	/*
	 * In HostAP mode, ieee80211_input() will enqueue packets in if_snd
	 * without calling if_start().
	 */
	if (!IFQ_IS_EMPTY(&ifp->if_snd) && !(ifp->if_flags & IFF_OACTIVE))
		rum_start(ifp);
@


1.74
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.73 2008/06/29 00:43:11 deraadt Exp $	*/
d586 1
a586 1
fail:	rum_free_tx_list(sc);
@


1.73
log
@new belkin rum with california designed plastic
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.72 2008/06/13 05:01:04 jsg Exp $	*/
d777 1
d864 4
a867 1
	ieee80211_input(ifp, m, ni, desc->rssi, 0);
@


1.72
log
@D-Link DWA-111, from kevlo via FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.71 2008/04/16 18:32:15 damien Exp $	*/
d94 1
@


1.71
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.70 2008/04/01 13:43:53 jsg Exp $	*/
d101 1
@


1.70
log
@Add Corega CG-WLUSB2GPX.
From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.69 2008/03/03 20:50:09 jsg Exp $	*/
d365 2
a366 1
	    IEEE80211_C_WEP;		/* s/w WEP */
a1051 1
	struct ifnet *ifp = &ic->ic_if;
d1055 1
d1063 4
a1066 3
	if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
		m0 = ieee80211_wep_crypt(ifp, m0, 1);
		if (m0 == NULL)
@


1.69
log
@Two more rum devices from Ralink driver via sephe@@dragonfly.
discussed with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.68 2008/02/22 10:46:57 jsg Exp $	*/
d98 1
@


1.68
log
@I-O Data USB-RSAQ5 serial from Masao Uebayashi in NetBSD.
Corega CG-WLUSB2GL WLAN from KIYOHARA Takashi in NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.67 2008/01/05 04:57:59 deraadt Exp $	*/
d121 1
d128 2
a129 1
	{ USB_VENDOR_SPARKLAN,		USB_PRODUCT_SPARKLAN_RT2573 }
@


1.67
log
@SPARKLAN RT2573, found in HP s3200n, owned by laa@@laa.zp.ua
rum vs ural determination done by jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.66 2007/10/11 18:33:14 deraadt Exp $	*/
d97 1
@


1.66
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.65 2007/09/07 19:05:05 damien Exp $	*/
d125 2
a126 1
	{ USB_VENDOR_SURECOM,		USB_PRODUCT_SURECOM_RT2573 }
@


1.65
log
@use new malloc M_ZERO flag to shrink kernel.
remove <malloc.h> from files where malloc is not used.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.64 2007/06/14 10:11:15 mbalmer Exp $	*/
a270 1
	char *devinfop;
a274 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.64
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.63 2007/06/12 16:26:36 mbalmer Exp $	*/
a33 1
#include <sys/malloc.h>
@


1.63
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.62 2007/06/10 14:49:00 mbalmer Exp $	*/
d210 16
a225 1
USB_DECLARE_DRIVER_CLASS(rum, DV_IFNET);
@


1.62
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.61 2007/06/10 10:53:48 mbalmer Exp $	*/
d2245 1
a2245 1
rum_activate(device_ptr_t self, enum devact act)
@


1.61
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.60 2007/06/09 12:22:53 mbalmer Exp $	*/
d235 1
a235 1
		    USBDEVNAME(sc->sc_dev), name, error);
d241 1
a241 1
		    USBDEVNAME(sc->sc_dev));
d264 1
a264 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d269 1
a269 1
		    USBDEVNAME(sc->sc_dev));
d278 1
a278 1
		    USBDEVNAME(sc->sc_dev));
d292 1
a292 1
			    USBDEVNAME(sc->sc_dev), i);
d304 1
a304 1
		printf("%s: missing endpoint\n", USBDEVNAME(sc->sc_dev));
d323 1
a323 1
		    USBDEVNAME(sc->sc_dev));
d331 1
a331 1
	    USBDEVNAME(sc->sc_dev), sc->macbbp_rev, tmp,
d401 1
a401 1
	memcpy(ifp->if_xname, USBDEVNAME(sc->sc_dev), IFNAMSIZ);
d484 1
a484 1
			    USBDEVNAME(sc->sc_dev));
d492 1
a492 1
			    USBDEVNAME(sc->sc_dev));
d539 1
a539 1
			    USBDEVNAME(sc->sc_dev));
d545 1
a545 1
			    USBDEVNAME(sc->sc_dev));
d553 1
a553 1
			    USBDEVNAME(sc->sc_dev));
d560 1
a560 1
			    USBDEVNAME(sc->sc_dev));
d725 1
a725 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(status));
d776 1
a776 1
		DPRINTF(("%s: xfer too short %d\n", USBDEVNAME(sc->sc_dev),
d797 1
a797 1
		    USBDEVNAME(sc->sc_dev));
d804 1
a804 1
		    USBDEVNAME(sc->sc_dev));
d1296 1
a1296 1
			printf("%s: device timeout\n", USBDEVNAME(sc->sc_dev));
d1397 1
a1397 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1426 1
a1426 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1453 1
a1453 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d1468 1
a1468 1
		printf("%s: could not write to BBP\n", USBDEVNAME(sc->sc_dev));
d1487 1
a1487 1
		printf("%s: could not read BBP\n", USBDEVNAME(sc->sc_dev));
d1501 1
a1501 1
	printf("%s: could not read BBP\n", USBDEVNAME(sc->sc_dev));
d1516 1
a1516 1
		printf("%s: could not write to RF\n", USBDEVNAME(sc->sc_dev));
d1914 1
a1914 1
		    USBDEVNAME(sc->sc_dev));
d1962 1
a1962 1
		    USBDEVNAME(sc->sc_dev));
d1990 1
a1990 1
		    USBDEVNAME(sc->sc_dev));
d2001 1
a2001 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2008 1
a2008 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2018 1
a2018 1
		    USBDEVNAME(sc->sc_dev));
d2024 1
a2024 1
		    USBDEVNAME(sc->sc_dev));
d2039 1
a2039 1
			    USBDEVNAME(sc->sc_dev));
d2129 1
a2129 1
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2223 1
a2223 1
		    "automatic rate control\n", USBDEVNAME(sc->sc_dev));
@


1.60
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.59 2007/06/09 08:52:10 damien Exp $	*/
d426 1
a426 1
	    USBDEV(sc->sc_dev));
d464 1
a464 1
	    USBDEV(sc->sc_dev));
@


1.59
log
@re-indent prototypes after "Static" removal.
no binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.58 2007/06/05 08:43:55 mbalmer Exp $	*/
a2251 1
		/*if_deactivate(&sc->sc_ic.ic_if);*/
@


1.58
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.57 2007/05/27 04:00:24 jsg Exp $	*/
d137 3
a139 6
int		rum_newstate(struct ieee80211com *,
			    enum ieee80211_state, int);
void		rum_txeof(usbd_xfer_handle, usbd_private_handle,
			    usbd_status);
void		rum_rxeof(usbd_xfer_handle, usbd_private_handle,
			    usbd_status);
d144 1
a144 1
uint16_t		rum_txtime(int, int, uint32_t);
d146 2
a147 3
void		rum_setup_tx_desc(struct rum_softc *,
			    struct rum_tx_desc *, uint32_t, uint16_t, int,
			    int);
d149 1
a149 1
			    struct ieee80211_node *);
d153 3
a155 5
void		rum_eeprom_read(struct rum_softc *, uint16_t, void *,
			    int);
uint32_t		rum_read(struct rum_softc *, uint16_t);
void		rum_read_multi(struct rum_softc *, uint16_t, void *,
			    int);
d157 1
a157 2
void		rum_write_multi(struct rum_softc *, uint16_t, void *,
			    size_t);
d166 2
a167 3
			    struct ieee80211_channel *);
void		rum_set_chan(struct rum_softc *,
			    struct ieee80211_channel *);
d178 1
a178 2
int		rum_load_microcode(struct rum_softc *, const u_char *,
			    size_t);
d180 3
a182 4
void		rum_newassoc(struct ieee80211com *,
			    struct ieee80211_node *, int);
void		rum_amrr_start(struct rum_softc *,
			    struct ieee80211_node *);
d185 1
a185 1
			    usbd_status status);
@


1.57
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.56 2007/05/21 06:10:43 jsg Exp $	*/
d129 9
a137 9
Static void		rum_attachhook(void *);
Static int		rum_alloc_tx_list(struct rum_softc *);
Static void		rum_free_tx_list(struct rum_softc *);
Static int		rum_alloc_rx_list(struct rum_softc *);
Static void		rum_free_rx_list(struct rum_softc *);
Static int		rum_media_change(struct ifnet *);
Static void		rum_next_scan(void *);
Static void		rum_task(void *);
Static int		rum_newstate(struct ieee80211com *,
d139 1
a139 1
Static void		rum_txeof(usbd_xfer_handle, usbd_private_handle,
d141 1
a141 1
Static void		rum_rxeof(usbd_xfer_handle, usbd_private_handle,
d144 1
a144 1
Static uint8_t		rum_rxrate(const struct rum_rx_desc *);
d146 4
a149 4
Static int		rum_ack_rate(struct ieee80211com *, int);
Static uint16_t		rum_txtime(int, int, uint32_t);
Static uint8_t		rum_plcp_signal(int);
Static void		rum_setup_tx_desc(struct rum_softc *,
d152 1
a152 1
Static int		rum_tx_data(struct rum_softc *, struct mbuf *,
d154 4
a157 4
Static void		rum_start(struct ifnet *);
Static void		rum_watchdog(struct ifnet *);
Static int		rum_ioctl(struct ifnet *, u_long, caddr_t);
Static void		rum_eeprom_read(struct rum_softc *, uint16_t, void *,
d159 2
a160 2
Static uint32_t		rum_read(struct rum_softc *, uint16_t);
Static void		rum_read_multi(struct rum_softc *, uint16_t, void *,
d162 2
a163 2
Static void		rum_write(struct rum_softc *, uint16_t, uint32_t);
Static void		rum_write_multi(struct rum_softc *, uint16_t, void *,
d165 8
a172 8
Static void		rum_bbp_write(struct rum_softc *, uint8_t, uint8_t);
Static uint8_t		rum_bbp_read(struct rum_softc *, uint8_t);
Static void		rum_rf_write(struct rum_softc *, uint8_t, uint32_t);
Static void		rum_select_antenna(struct rum_softc *);
Static void		rum_enable_mrr(struct rum_softc *);
Static void		rum_set_txpreamble(struct rum_softc *);
Static void		rum_set_basicrates(struct rum_softc *);
Static void		rum_select_band(struct rum_softc *,
d174 1
a174 1
Static void		rum_set_chan(struct rum_softc *,
d176 11
a186 11
Static void		rum_enable_tsf_sync(struct rum_softc *);
Static void		rum_update_slot(struct rum_softc *);
Static void		rum_set_bssid(struct rum_softc *, const uint8_t *);
Static void		rum_set_macaddr(struct rum_softc *, const uint8_t *);
Static void		rum_update_promisc(struct rum_softc *);
Static const char	*rum_get_rf(int);
Static void		rum_read_eeprom(struct rum_softc *);
Static int		rum_bbp_init(struct rum_softc *);
Static int		rum_init(struct ifnet *);
Static void		rum_stop(struct ifnet *, int);
Static int		rum_load_microcode(struct rum_softc *, const u_char *,
d188 2
a189 2
Static int		rum_prepare_beacon(struct rum_softc *);
Static void		rum_newassoc(struct ieee80211com *,
d191 1
a191 1
Static void		rum_amrr_start(struct rum_softc *,
d193 2
a194 2
Static void		rum_amrr_timeout(void *);
Static void		rum_amrr_update(usbd_xfer_handle, usbd_private_handle,
d234 1
a234 1
Static void
d479 1
a479 1
Static int
d516 1
a516 1
Static void
d536 1
a536 1
Static int
d583 1
a583 1
Static void
d602 1
a602 1
Static int
d621 1
a621 1
Static void
d632 1
a632 1
Static void
d699 1
a699 1
Static int
d721 1
a721 1
Static void
d761 1
a761 1
Static void
d883 1
a883 1
Static uint8_t
d915 1
a915 1
Static int
d950 1
a950 1
Static uint16_t
d970 1
a970 1
Static uint8_t
d995 1
a995 1
Static void
d1043 1
a1043 1
Static int
d1229 1
a1229 1
Static void
d1297 1
a1297 1
Static void
d1317 1
a1317 1
Static int
d1392 1
a1392 1
Static void
d1411 1
a1411 1
Static uint32_t
d1421 1
a1421 1
Static void
d1440 1
a1440 1
Static void
d1448 1
a1448 1
Static void
d1467 1
a1467 1
Static void
d1486 1
a1486 1
Static uint8_t
d1515 1
a1515 1
Static void
d1540 1
a1540 1
Static void
d1565 1
a1565 1
Static void
d1581 1
a1581 1
Static void
d1595 1
a1595 1
Static void
d1617 1
a1617 1
Static void
d1663 1
a1663 1
Static void
d1736 1
a1736 1
Static void
d1764 1
a1764 1
Static void
d1780 1
a1780 1
Static void
d1792 1
a1792 1
Static void
d1804 1
a1804 1
Static void
d1822 1
a1822 1
Static const char *
d1834 1
a1834 1
Static void
d1909 1
a1909 1
Static int
d1943 1
a1943 1
Static int
d2083 1
a2083 1
Static void
d2119 1
a2119 1
Static int
d2144 1
a2144 1
Static int
d2177 1
a2177 1
Static void
d2184 1
a2184 1
Static void
d2203 1
a2203 1
Static void
d2224 1
a2224 1
Static void
@


1.56
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.55 2007/05/21 05:40:27 jsg Exp $	*/
d222 2
a223 1
USB_MATCH(rum)
d225 1
a225 1
	USB_MATCH_START(rum, uaa);
d257 2
a258 1
USB_ATTACH(rum)
d260 2
a261 1
	USB_ATTACH_START(rum, sc, uaa);
d274 1
a274 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d280 1
a280 1
		USB_ATTACH_ERROR_RETURN;
d289 1
a289 1
		USB_ATTACH_ERROR_RETURN;
d303 1
a303 1
			USB_ATTACH_ERROR_RETURN;
d315 1
a315 1
		USB_ATTACH_ERROR_RETURN;
d334 1
a334 1
		USB_ATTACH_ERROR_RETURN;
a436 2

	USB_ATTACH_SUCCESS_RETURN;
d439 2
a440 1
USB_DETACH(rum)
d442 1
a442 1
	USB_DETACH_START(rum, sc);
@


1.55
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.54 2007/02/19 17:22:02 deraadt Exp $	*/
d1860 1
a1860 1
	val = le16toh(val);
d1881 1
a1881 1
	val = le16toh(val);
@


1.54
log
@do not do a curproc test for interrupt context, because it is plainly wrong.
this lets these work on macppc, for instance
diagnosed by kettenis, but damien is not around, so ok jsg and others
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.53 2007/02/08 06:19:31 jsg Exp $	*/
d75 2
a76 2
#define DPRINTF(x)	do { if (rum_debug) logprintf x; } while (0)
#define DPRINTFN(n, x)	do { if (rum_debug >= (n)) logprintf x; } while (0)
@


1.53
log
@commit the correct version of this, which matches recent additions.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.52 2007/02/08 05:57:46 itojun Exp $	*/
d707 1
d710 1
a710 6
	if (curproc != NULL) {
		rum_task(sc);
	} else {
		/* do it in a process context */
		usb_add_task(sc->sc_udev, &sc->sc_task);
	}
@


1.52
log
@add entry for WLI-U2-SG54HP.  forgotten on previous commit.
tnx to: yuo at nui.org
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.51 2007/02/08 05:25:46 jsg Exp $	*/
d96 1
d106 2
d109 1
d122 1
@


1.51
log
@Add quite a few more rum(4) devices.
Two from Yojiro UO in NetBSD PR 35552
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.50 2007/01/08 18:53:00 damien Exp $	*/
d106 1
@


1.50
log
@attach to Gigabyte GN-WI05GS Mini-PCI Express adapters.
bump copyright while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.49 2006/12/30 22:34:53 claudio Exp $	*/
d85 8
a92 2
	{ USB_VENDOR_ABOCOM,		USB_PRODUCT_ABOCOM_RT2573 },
	{ USB_VENDOR_ASUS,		USB_PRODUCT_ASUS_RT2573 },
d105 2
a106 2
	{ USB_VENDOR_HUAWEI3COM,	USB_PRODUCT_HUAWEI3COM_RT2573 },
	{ USB_VENDOR_MSI,		USB_PRODUCT_MSI_RT2573 },
d109 4
@


1.49
log
@Don't use M_DUP_PKTHDR() on static mbufs. M_DUP_PKTHDR() copies the mtag
chain and so a later MFREE() is needed to free the chain again.
In this special case we get away by initializing a minimal mbuf header
instead of the M_DUP_PKTHDR() because bpf_mtap() does not access the pkthdr.
This fixes kettenis@@ mtag memory leak on armish.
Tested by kettenis@@ OK mglocker@@ Sounds good jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.48 2006/12/07 17:32:19 damien Exp $	*/
d4 1
a4 1
 * Copyright (c) 2005, 2006 Damien Bergamini <damien.bergamini@@free.fr>
d96 1
@


1.48
log
@http://www.ralinktech.com/ domain name is for sale.
use official url instead: http://www.ralinktech.com.tw/
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.47 2006/12/03 16:39:13 damien Exp $	*/
a827 1
		M_DUP_PKTHDR(&mb, m);
d831 3
a833 1
		mb.m_pkthdr.len += mb.m_len;
a1173 1
		M_DUP_PKTHDR(&mb, m0);
d1177 3
a1179 1
		mb.m_pkthdr.len += mb.m_len;
@


1.47
log
@fix handling of the SIOCS80211CHANNEL ioctl in monitor mode:
don't call xxx_set_chan() if the interface is not up&running.

patch from Steffen Schuetz (st dot sch at gmx dot net) with
minor modifications by me.

closes kernel/5313
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.46 2006/12/03 16:16:58 damien Exp $	*/
d22 1
a22 1
 * http://www.ralinktech.com/
@


1.46
log
@don't schedule a USB task in {ural,rum}_newstate() if we're called from
a process context. this avoids potential races in {ural,rum}_stop().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.45 2006/11/26 11:14:22 deraadt Exp $	*/
d346 2
a347 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = ieee80211_std_rateset_11a;
d1353 3
a1355 1
			rum_set_chan(sc, ic->ic_ibss_chan);
@


1.45
log
@do not have each net80211 driver define its own rates structures.  if they use
the standard rates, use some defined by net80211 itself.  kernel shrinks a bit
ok jsg mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.44 2006/11/19 16:44:36 damien Exp $	*/
a688 1
	/* do it in a process context */
d691 6
a696 2
	usb_add_task(sc->sc_udev, &sc->sc_task);

@


1.44
log
@restore the workaround for rate==0 bug.
i removed it in my last commit because i thought it was gone.
looks like it's not the case.

pointed out by niallo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.43 2006/11/13 20:06:38 damien Exp $	*/
a179 12
/*
 * Supported rates for 802.11a/b/g modes (in 500Kbps unit).
 */
static const struct ieee80211_rateset rum_rateset_11a =
	{ 8, { 12, 18, 24, 36, 48, 72, 96, 108 } };

static const struct ieee80211_rateset rum_rateset_11b =
	{ 4, { 2, 4, 11, 22 } };

static const struct ieee80211_rateset rum_rateset_11g =
	{ 12, { 2, 4, 11, 22, 12, 18, 24, 36, 48, 72, 96, 108 } };

d346 1
a346 1
		ic->ic_sup_rates[IEEE80211_MODE_11A] = rum_rateset_11a;
d372 2
a373 2
	ic->ic_sup_rates[IEEE80211_MODE_11B] = rum_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = rum_rateset_11g;
@


1.43
log
@first round of commits for proper 11b/g protection support:
- use the newly introduced ieee80211_get_rts() and
  ieee80211_get_cts_to_self() functions.
- use CTS-to-self instead of RTS/CTS to protect OFDM frames in
  a mixed 11b/g BSS.
- make sure multicast frames are sent using CCK modulation.

remove support for 5GHz radios in ral(4) RT2560 and ural(4).
i'm not aware of any such adapters on the market and 11a code
is known to be broken.

some cleanup while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.42 2006/10/22 12:27:56 damien Exp $	*/
d1074 2
@


1.42
log
@make sure ni->ni_txrate is always initialized to a meaningful value by
redefining ic->ic_newassoc.
this should prevent "bogus xmit rate" panics when operating in HostAP
mode.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.41 2006/10/19 16:53:48 jsg Exp $	*/
d127 1
a127 1
Static uint8_t		rum_rxrate(struct rum_rx_desc *);
d312 1
a312 1
	timeout_set(&sc->scan_ch, rum_next_scan, sc);
d316 1
a316 1
	timeout_set(&sc->amrr_ch, rum_amrr_timeout, sc);
d445 2
a446 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->amrr_ch);
a451 1

a455 1

a474 1
	struct rum_tx_data *data;
d477 1
a477 1
	sc->tx_queued = 0;
d479 2
a480 2
	for (i = 0; i < RT2573_TX_LIST_COUNT; i++) {
		data = &sc->tx_data[i];
a490 1

a498 1

a511 1
	struct rum_tx_data *data;
d514 2
a515 2
	for (i = 0; i < RT2573_TX_LIST_COUNT; i++) {
		data = &sc->tx_data[i];
a520 1

a531 1
	struct rum_rx_data *data;
d534 2
a535 2
	for (i = 0; i < RT2573_RX_LIST_COUNT; i++) {
		data = &sc->rx_data[i];
a545 1

a559 1

a566 1

a578 1
	struct rum_rx_data *data;
d581 2
a582 2
	for (i = 0; i < RT2573_RX_LIST_COUNT; i++) {
		data = &sc->rx_data[i];
a587 1

d647 1
a647 1
		timeout_add(&sc->scan_ch, hz / 5);
d698 2
a699 2
	timeout_del(&sc->scan_ch);
	timeout_del(&sc->amrr_ch);
a739 2
	m_freem(data->m);
	data->m = NULL;
d762 1
a762 1
	struct rum_rx_desc *desc;
d786 1
a786 1
	desc = (struct rum_rx_desc *)data->buf;
a804 1

a812 1

d868 1
a868 1
	usbd_transfer(xfer);
d877 1
a877 1
rum_rxrate(struct rum_rx_desc *desc)
a906 1
 * XXX: this should depend on the destination node basic rate set.
d1047 1
a1047 1
	int xferlen, rate;
d1060 3
d1064 4
a1067 3
	if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
	    IEEE80211_FC0_TYPE_MGT) {
		/* mgmt frames are sent at the lowest available bit-rate */
d1069 78
a1146 6
	} else {
		if (ic->ic_fixed_rate != -1) {
			rate = ic->ic_sup_rates[ic->ic_curmode].
			    rs_rates[ic->ic_fixed_rate];
		} else
			rate = ni->ni_rates.rs_rates[ni->ni_txrate];
a1147 3
	rate &= IEEE80211_RATE_VAL;
	if (rate == 0)
		rate = 2;	/* fallback to 1Mbps; should not happen  */
d1149 1
a1149 1
	data = &sc->tx_data[0];
a1151 1
	data->m = m0;
d1155 1
a1155 1
		flags |= RT2573_TX_ACK;
d1204 3
a1208 1

d1210 1
a1210 2
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		m_freem(m0);
a1211 1
	}
d1214 1
d1237 1
a1237 1
			if (sc->tx_queued >= RT2573_TX_LIST_COUNT) {
d1258 1
a1258 1
			if (sc->tx_queued >= RT2573_TX_LIST_COUNT) {
d1592 1
a1592 1
	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
d1596 2
a1597 2
		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x15f);
a1901 1
	uint8_t val;
d1905 1
a1905 1
		val = rum_bbp_read(sc, 0);
a1936 1
	struct rum_rx_data *data;
a2001 1

a2018 1

d2029 2
a2030 2
	for (i = 0; i < RT2573_RX_LIST_COUNT; i++) {
		data = &sc->rx_data[i];
d2034 6
a2039 1
		usbd_transfer(data->xfer);
a2096 1

d2188 1
a2188 1
	timeout_add(&sc->amrr_ch, hz);
d2239 1
a2239 1
	timeout_add(&sc->amrr_ch, hz);
@


1.41
log
@Support later versions of the ASUS WL-167g which have switched
from ural to rum.

From Jason Crawford <jasonrcrawford@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.40 2006/09/18 16:20:20 damien Exp $	*/
d172 2
d407 1
d691 8
a698 5
		/* enable automatic rate adaptation in STA mode */
		if (ic->ic_opmode == IEEE80211_M_STA &&
		    ic->ic_fixed_rate == -1)
			rum_amrr_start(sc, ni);

d2111 7
a2140 3
	int s;

	s = splusb();
a2154 2

	splx(s);
@


1.40
log
@don't use IF_PREPEND() on altq's.
use IFQ_POLL()/IFQ_DEQUEUE() logic instead as described in altq(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.39 2006/08/24 19:32:21 damien Exp $	*/
d86 1
@


1.39
log
@s/IEEE80211_MTU_MAX/IEEE80211_MAX_LEN/ in my previous commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.38 2006/08/23 21:37:04 niallo Exp $	*/
d1193 1
a1193 1
			IFQ_DEQUEUE(&ifp->if_snd, m0);
a1196 1
				IF_PREPEND(&ifp->if_snd, m0);
d1200 1
a1200 1

@


1.38
log
@- fall back to 1Mbps if tx rate is returned as zero.  avoids divide by zero.  should never happen, but sometimes it does on my amd64.

ok damien@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.37 2006/08/23 16:25:07 damien Exp $	*/
d492 1
a492 1
		    RT2573_TX_DESC_SIZE + IEEE80211_MTU_MAX);
@


1.37
log
@the maximum MTU allowed for IEEE802.11 is 2290 which is greater than
MCLBYTES (usually 2048).
allocate tx xfer buffers of IEEE80211_MTU_MAX instead of MCLBYTES.
rx buffers are still limited to MCLBYTES though.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.36 2006/08/23 16:16:39 damien Exp $	*/
d1084 2
@


1.36
log
@in rum_rxeof(), don't check xfer length against IEEE80211_MIN_LEN since
the CRC is not included in the xfer.
check against sizeof(struct ieee80211_frame_min) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.35 2006/08/18 16:04:56 damien Exp $	*/
d492 1
a492 1
		    RT2573_TX_DESC_SIZE + MCLBYTES);
@


1.35
log
@set of unrelated cosmetic tweaks.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.34 2006/08/18 15:23:13 damien Exp $	*/
d787 1
a787 1
	if (len < RT2573_RX_DESC_SIZE + IEEE80211_MIN_LEN) {
d2098 1
@


1.34
log
@fix a printf format string
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.33 2006/08/18 15:11:11 damien Exp $	*/
d70 4
d2123 1
a2123 1
	struct rum_softc *sc = (struct rum_softc *)arg;
@


1.33
log
@- fix support for RT5225 (802.11a MIMO)
- set default Tx power for 802.11a channels
- in rum_newstate(), save the "arg" parameter so we can pass it to the
  ieee80211_new_state() function in the usb task
- merge rum_tx_data() and rum_tx_mgt()
- s/le32toh/letoh32/g (le32toh is defined in usb_port.h)
- cosmetic while i'm here
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.32 2006/08/17 08:32:30 damien Exp $	*/
d326 1
a326 1
	printf("%s: MAC/BBP RT%02x (rev 0x%02x), RF %s, address %s\n",
@


1.32
log
@Separate rum(4) firmware from ral(4) ones.

ral(4) firmwares are built on PCI-capable architectures only while rum(4)
firmware is built on USB-capable architectures only.
Rename ral-rt2573 into rum-rt2573 and build rum-rt2573 on the zaurus too
(pointed out by Patrick Heim).

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.31 2006/08/16 16:08:05 jsg Exp $	*/
d107 1
a129 2
Static int		rum_tx_mgt(struct rum_softc *, struct mbuf *,
			    struct ieee80211_node *);
d146 4
a155 2
Static void		rum_set_txpreamble(struct rum_softc *);
Static void		rum_set_basicrates(struct rum_softc *);
a165 2
Static int		rum_led_write(struct rum_softc *, uint16_t, uint8_t);
Static void		rum_attachhook(void *);
a166 2
Static void		rum_select_antenna(struct rum_softc *);
Static void		rum_enable_mrr(struct rum_softc *);
d210 12
a221 1
void
a243 11
USB_MATCH(rum)
{
	USB_MATCH_START(rum, uaa);

	if (uaa->iface != NULL)
		return UMATCH_NONE;

	return (usb_lookup(rum_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
}

d335 2
a336 2
	ic->ic_phytype = IEEE80211_T_OFDM; /* not only, but not used */
	ic->ic_opmode = IEEE80211_M_STA; /* default to BSS mode */
d349 1
a349 1
	if (sc->rf_rev == RT2573_RF_5226) {
d408 1
a408 1
	    sizeof (struct ieee80211_frame) + 64);
a679 4
		/* make tx led blink on tx (controlled by ASIC) */
		/*rum_led_write(sc, RT2573_LED_RADIO | RT2573_LED_A |
		    RT2573_LED_G, 1);*/

d686 1
a686 1
			rum_amrr_start(sc, ic->ic_bss);
d691 1
a691 1
	sc->sc_newstate(ic, sc->sc_state, -1);
d705 1
a1043 85
rum_tx_mgt(struct rum_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct rum_tx_desc *desc;
	struct rum_tx_data *data;
	struct ieee80211_frame *wh;
	uint32_t flags = 0;
	uint16_t dur;
	usbd_status error;
	int xferlen, rate;

	data = &sc->tx_data[0];
	desc = (struct rum_tx_desc *)data->buf;

	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

	data->m = m0;
	data->ni = ni;

	wh = mtod(m0, struct ieee80211_frame *);

	if (!IEEE80211_IS_MULTICAST(wh->i_addr1)) {
		flags |= RT2573_TX_ACK;

		dur = rum_txtime(RUM_ACK_SIZE, rate, ic->ic_flags) + sc->sifs;
		*(uint16_t *)wh->i_dur = htole16(dur);

		/* tell hardware to add timestamp for probe responses */
		if ((wh->i_fc[0] &
		    (IEEE80211_FC0_TYPE_MASK | IEEE80211_FC0_SUBTYPE_MASK)) ==
		    (IEEE80211_FC0_TYPE_MGT | IEEE80211_FC0_SUBTYPE_PROBE_RESP))
			flags |= RT2573_TX_TIMESTAMP;
	}

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct rum_tx_radiotap_header *tap = &sc->sc_txtap;

		tap->wt_flags = 0;
		tap->wt_rate = rate;
		tap->wt_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wt_antenna = sc->tx_ant;

		M_DUP_PKTHDR(&mb, m0);
		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_txtap_len;
		mb.m_next = m0;
		mb.m_pkthdr.len += mb.m_len;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
	}
#endif

	m_copydata(m0, 0, m0->m_pkthdr.len, data->buf + RT2573_TX_DESC_SIZE);
	rum_setup_tx_desc(sc, desc, flags, 0, m0->m_pkthdr.len, rate);

	/* align end on a 2-bytes boundary */
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	/*
	 * No space left in the last URB to store the extra 2 bytes, force
	 * sending of another URB.
	 */
	if ((xferlen % 64) == 0)
		xferlen += 2;

	DPRINTFN(10, ("sending mgt frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(data->xfer, sc->sc_tx_pipeh, data, data->buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RUM_TX_TIMEOUT, rum_txeof);

	error = usbd_transfer(data->xfer);
	if (error != USBD_NORMAL_COMPLETION && error != USBD_IN_PROGRESS) {
		m_freem(m0);
		return error;
	}

	sc->tx_queued++;

	return 0;
}

Static int
a1047 1
	struct ieee80211_rateset *rs;
a1055 13
	if (ic->ic_fixed_rate != -1) {
		if (ic->ic_curmode != IEEE80211_MODE_AUTO)
			rs = &ic->ic_sup_rates[ic->ic_curmode];
		else
			rs = &ic->ic_sup_rates[IEEE80211_MODE_11G];

		rate = rs->rs_rates[ic->ic_fixed_rate];
	} else {
		rs = &ni->ni_rates;
		rate = rs->rs_rates[ni->ni_txrate];
	}
	rate &= IEEE80211_RATE_VAL;

d1067 14
d1093 6
d1134 1
a1134 1
	DPRINTFN(10, ("sending data frame len=%u rate=%u xfer len=%u\n",
d1181 1
a1181 1
			if (rum_tx_mgt(sc, m0, ni) != 0)
d1339 1
a1339 1
	return le32toh(val);
d1604 1
a1604 1
	power = sc->txpow[chan - 1];
d1811 2
a2015 3
	/* turn off LED */
/*	rum_write(sc, RT2573_MAC_CSR14, RT2573_LED_OFF);*/

d2020 3
a2022 2
/*	rum_write(sc, RT2573_MAC_CSR10, 0x0018);*/
/*	rum_led_write(sc, 0, 0);*/
a2023 5
	/* reset ASIC and BBP (but won't reset MAC registers!) */
	/*
	rum_write(sc, RT2573_MAC_CSR1, RT2573_RESET_ASIC | RT2573_RESET_BBP);
	rum_write(sc, RT2573_MAC_CSR1, 0);
	*/
a2040 20
rum_led_write(struct rum_softc *sc, uint16_t reg, uint8_t strength)
{
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RT2573_WRITE_LED;
	USETW(req.wValue, reg);
	USETW(req.wIndex, strength);
	USETW(req.wLength, 0);

	error = usbd_do_request(sc->sc_udev, &req, NULL);
	if (error != 0) {
		printf("%s: could not write LED register: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
	}
	return error;
}

Static int
a2162 5
#if 0
	printf("one-retry ok=%d more-retry ok=%d retry-fail=%d txcnt=%d\n",
	    letoh32(sc->sta[4]) >> 16, letoh32(sc->sta[5]) & 0xffff,
	    letoh32(sc->sta[5]) >> 16, letoh32(sc->sta[4]) & 0xffff);
#endif
@


1.31
log
@Belkin RT2601USB.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.30 2006/08/14 12:57:08 jsg Exp $	*/
d21 1
a21 1
 * Ralink Technology RT2501USB chipset driver
d217 1
a217 1
	const char *name = "ral-rt2573";
d803 1
a803 1
		DPRINTF(/*5,*/ ("CRC error\n"));
d1898 1
a1898 1
		DPRINTF(("Channel=%d Tx power=%d\n", i,  sc->txpow[i]));
d2200 2
a2201 2
	rum_write_multi(sc, RT2573_HW_BEACON_BASE0 + 24,
	    mtod(m0, uint8_t *), m0->m_pkthdr.len);
@


1.30
log
@Add a bunch more devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.29 2006/08/14 10:33:18 jsg Exp $	*/
d83 1
@


1.29
log
@Disable default debug setting now rum works.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.28 2006/08/10 07:44:04 damien Exp $	*/
d81 1
d86 1
d90 14
a103 1
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2573 }
@


1.28
log
@tell if chipset supports MIMO in dmesg output.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.27 2006/08/09 08:21:08 damien Exp $	*/
a69 2
#define RUM_DEBUG

d73 1
a73 1
int rum_debug = 1;
@


1.27
log
@mega-commit of unrelated changes to bring rum(4) into a working state.
more to come but works well enough for me to commit this over a rum(4).
it shares a lot of code with ral(4) rt2661.c.

thanks to jsg@@ for sending me a rum(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.26 2006/07/19 20:16:20 damien Exp $	*/
d1818 1
a1818 1
	case RT2573_RF_2527:	return "RT2527";
d1820 1
a1820 1
	case RT2573_RF_5225:	return "RT5225";
a1874 2
	if ((val >> 8) != 0xff)
		sc->rfprog = (val >> 8) & 0x3;
@


1.26
log
@RX descriptor is located at the beginning of the RX buffer, unlike
RT2500USB.
@
text
@d1 2
a2 1
/*	$OpenBSD: if_rum.c,v 1.25 2006/07/19 19:54:00 damien Exp $  */
d20 1
a20 1
/*
d59 1
a69 1
#ifdef USB_DEBUG
a70 1
#endif
d75 1
a75 1
int rum_debug = 0;
d93 13
a105 13
int		rum_alloc_tx_list(struct rum_softc *);
void		rum_free_tx_list(struct rum_softc *);
int		rum_alloc_rx_list(struct rum_softc *);
void		rum_free_rx_list(struct rum_softc *);
int		rum_media_change(struct ifnet *);
void		rum_next_scan(void *);
void		rum_task(void *);
int		rum_newstate(struct ieee80211com *,
		    enum ieee80211_state, int);
void		rum_txeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
void		rum_rxeof(usbd_xfer_handle, usbd_private_handle,
		    usbd_status);
d107 1
a107 1
uint8_t		rum_rxrate(struct rum_rx_desc *);
d109 52
a160 46
int		rum_ack_rate(struct ieee80211com *, int);
uint16_t	rum_txtime(int, int, uint32_t);
uint8_t		rum_plcp_signal(int);
void		rum_setup_tx_desc(struct rum_softc *,
		    struct rum_tx_desc *, uint32_t, int, int);
int		rum_tx_bcn(struct rum_softc *, struct mbuf *,
		    struct ieee80211_node *);
int		rum_tx_mgt(struct rum_softc *, struct mbuf *,
		    struct ieee80211_node *);
int		rum_tx_data(struct rum_softc *, struct mbuf *,
		    struct ieee80211_node *);
void		rum_start(struct ifnet *);
void		rum_watchdog(struct ifnet *);
int		rum_ioctl(struct ifnet *, u_long, caddr_t);
void		rum_eeprom_read(struct rum_softc *, uint16_t, void *,
		    int);
uint32_t	rum_read(struct rum_softc *, uint16_t);
void		rum_read_multi(struct rum_softc *, uint16_t, void *,
		    int);
void		rum_write(struct rum_softc *, uint16_t, uint32_t);
void		rum_write_multi(struct rum_softc *, uint16_t,
		    void *, size_t);
void		rum_bbp_write(struct rum_softc *, uint8_t, uint8_t);
uint8_t		rum_bbp_read(struct rum_softc *, uint8_t);
void		rum_rf_write(struct rum_softc *, uint8_t, uint32_t);
void		rum_set_chan(struct rum_softc *,
		    struct ieee80211_channel *);
void		rum_enable_tsf_sync(struct rum_softc *);
void		rum_update_slot(struct rum_softc *);
void		rum_set_txpreamble(struct rum_softc *);
void		rum_set_basicrates(struct rum_softc *);
void		rum_set_bssid(struct rum_softc *, const uint8_t *);
void		rum_set_macaddr(struct rum_softc *, const uint8_t *);
void		rum_update_promisc(struct rum_softc *);
const char	*rum_get_rf(int);
void		rum_read_eeprom(struct rum_softc *);
int		rum_bbp_init(struct rum_softc *);
int		rum_init(struct ifnet *);
void		rum_stop(struct ifnet *, int);
int		rum_load_microcode(struct rum_softc *,
		    const u_char *, size_t);
int		rum_led_write(struct rum_softc *, uint16_t, uint8_t);

void		rum_attachhook(void *);
int		rum_prepare_beacon(struct rum_softc *);
void		rum_select_antenna(struct rum_softc *);
a187 3
static const uint32_t rum_rf2528_r2[] = RT2573_RF2528_R2;
static const uint32_t rum_rf2528_r4[] = RT2573_RF2528_R4;

d191 4
a194 2
} rum_rf5222[] = {
	RT2573_RF5222
d296 5
a300 1
	/* wait for chip to settle */
a311 3
	/* retrieve RT2573 rev. no */
	sc->asic_rev = tmp;

d316 1
a316 1
	    USBDEVNAME(sc->sc_dev), sc->macbbp_rev, sc->asic_rev,
d338 27
d427 6
d455 1
a455 1
int
d484 3
d495 1
a495 1
void
d517 1
a517 1
int
d568 1
a568 1
void
d589 1
a589 1
int
d608 1
a608 1
void
d619 1
a619 1
void
d659 1
d670 2
a671 1
		rum_led_write(sc, RT2573_LED_RADIO|RT2573_LED_A|RT2573_LED_G, 1);
d675 6
d687 1
a687 1
int
d694 1
d699 1
d704 1
a704 4
#define RT2573_RATE_IS_OFDM(rate) ((rate) >= 12 && (rate) != 22)

#define RT2573_ACK_SIZE	14	/* 10 + 4(FCS) */
#define RT2573_CTS_SIZE	14	/* 10 + 4(FCS) */
d706 2
a707 1
#define RT2573_SIFS		10	/* us */
d709 1
a709 1
void
d742 1
a742 1
	DPRINTFN(10, ("%s: tx done\n", USBDEVNAME(sc->sc_dev)));
d751 1
a751 1
void
d784 1
a784 1
	if (letoh32(desc->flags) & (RT2573_RX_PHY_ERROR | RT2573_RX_CRC_ERROR)) {
d787 1
a787 1
		 * those frames when we filled RT2573_TXRX_CSR2.
d789 1
a789 1
		DPRINTFN(5, ("%s: PHY or CRC error\n", USBDEVNAME(sc->sc_dev)));
a818 1
	m_adj(m, -IEEE80211_CRC_LEN);	/* trim FCS */
d861 1
a861 1
	DPRINTFN(15, ("%s: rx done\n", USBDEVNAME(sc->sc_dev)));
d874 1
a874 1
uint8_t
d907 1
a907 1
int
d942 1
a942 1
uint16_t
d947 1
a947 1
	if (RT2573_RATE_IS_OFDM(rate)) {
d962 1
a962 1
uint8_t
d987 1
a987 1
void
d989 1
a989 1
    uint32_t flags, int len, int rate)
d996 1
a996 1
	desc->flags |= htole32(RT2573_TX_NEWSEQ);
d999 7
a1005 1
	desc->wme = htole16(RT2573_AIFSN(2) | RT2573_LOGCWMIN(4) | RT2573_LOGCWMAX(10));
d1012 1
a1012 1
	if (RT2573_RATE_IS_OFDM(rate)) {
a1030 3

	desc->iv = 0;
	desc->eiv = 0;
d1033 1
a1033 53
#define RT2573_TX_TIMEOUT	5000

int
rum_tx_bcn(struct rum_softc *sc, struct mbuf *m0, struct ieee80211_node *ni)
{
	struct rum_tx_desc *desc;
	usbd_xfer_handle xfer;
	usbd_status error;
	uint8_t cmd = 0;
	uint8_t *buf;
	int xferlen, rate;

	rate = IEEE80211_IS_CHAN_5GHZ(ni->ni_chan) ? 12 : 2;

	xfer = usbd_alloc_xfer(sc->sc_udev);
	if (xfer == NULL)
		return ENOMEM;

	/* xfer length needs to be a multiple of two! */
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;

	buf = usbd_alloc_buffer(xfer, xferlen);
	if (buf == NULL) {
		usbd_free_xfer(xfer);
		return ENOMEM;
	}

	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, &cmd, sizeof cmd,
	    USBD_FORCE_SHORT_XFER, RT2573_TX_TIMEOUT, NULL);

	error = usbd_sync_transfer(xfer);
	if (error != 0) {
		usbd_free_xfer(xfer);
		return error;
	}

	desc = (struct rum_tx_desc *)buf;

	m_copydata(m0, 0, m0->m_pkthdr.len, buf + RT2573_TX_DESC_SIZE);
	rum_setup_tx_desc(sc, desc, RT2573_TX_IFS_NEWBACKOFF | RT2573_TX_TIMESTAMP,
	    m0->m_pkthdr.len, rate);

	DPRINTFN(10, ("%s: sending beacon frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->sc_dev), m0->m_pkthdr.len, rate, xferlen));

	usbd_setup_xfer(xfer, sc->sc_tx_pipeh, NULL, buf, xferlen,
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RT2573_TX_TIMEOUT, NULL);

	error = usbd_sync_transfer(xfer);
	usbd_free_xfer(xfer);

	return error;
}
d1035 1
a1035 1
int
d1060 1
a1060 1
		dur = rum_txtime(RT2573_ACK_SIZE, rate, ic->ic_flags) + RT2573_SIFS;
d1091 1
a1091 1
	rum_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);
d1103 2
a1104 2
	DPRINTFN(10, ("%s: sending mgt frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->sc_dev), m0->m_pkthdr.len, rate, xferlen));
d1107 1
a1107 1
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RT2573_TX_TIMEOUT, rum_txeof);
a1110 2
		DPRINTFN(10, ("%s: %s\n", USBDEVNAME(sc->sc_dev),
		    usbd_errstr(error)));
d1120 1
a1120 1
int
d1147 3
a1149 1
	if (ic->ic_flags & IEEE80211_F_WEPON) {
d1153 3
a1163 2
	wh = mtod(m0, struct ieee80211_frame *);

a1165 1
		flags |= RT2573_TX_RETRY(7);
d1167 2
a1168 2
		dur = rum_txtime(RT2573_ACK_SIZE, rum_ack_rate(ic, rate),
		    ic->ic_flags) + RT2573_SIFS;
d1193 1
a1193 1
	rum_setup_tx_desc(sc, desc, flags, m0->m_pkthdr.len, rate);
d1205 2
a1206 2
	DPRINTFN(10, ("%s: sending data frame len=%u rate=%u xfer len=%u\n",
	    USBDEVNAME(sc->sc_dev), m0->m_pkthdr.len, rate, xferlen));
d1209 1
a1209 1
	    USBD_FORCE_SHORT_XFER | USBD_NO_COPY, RT2573_TX_TIMEOUT, rum_txeof);
d1218 1
d1222 1
a1222 1
void
d1291 1
a1291 1
void
d1311 1
a1311 1
int
d1364 1
d1384 1
a1384 1
void
d1403 1
a1403 1
uint32_t
d1413 1
a1413 1
void
d1432 1
a1432 1
void
d1440 1
a1440 1
void
d1459 1
a1459 1
void
d1478 1
a1478 1
uint8_t
d1507 1
a1507 1
void
d1529 124
a1652 1
	/*DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 3, val & 0xfffff));*/
d1655 1
a1655 1
void
d1659 2
a1660 1
	uint8_t bbp94 = RT2573_BBPR94_DEFAULT;
d1662 1
a1662 1
	u_int chan;
d1668 7
d1683 9
d1694 14
a1707 14
	rum_rf_write(sc, RT2573_RF1, 0xb03);
	rum_rf_write(sc, RT2573_RF2, rum_rf2528_r2[chan - 1]);
	rum_rf_write(sc, RT2573_RF3, 0x1a014 | power << 7);
	rum_rf_write(sc, RT2573_RF4, rum_rf2528_r4[chan - 1]);

	rum_rf_write(sc, RT2573_RF1, 0xb03);
	rum_rf_write(sc, RT2573_RF2, rum_rf2528_r2[chan - 1]);
	rum_rf_write(sc, RT2573_RF3, 0x1a015 | power << 7);
	rum_rf_write(sc, RT2573_RF4, rum_rf2528_r4[chan - 1]);

	rum_rf_write(sc, RT2573_RF1, 0xb03);
	rum_rf_write(sc, RT2573_RF2, rum_rf2528_r2[chan - 1]);
	rum_rf_write(sc, RT2573_RF3, 0x1a014 | power << 7);
	rum_rf_write(sc, RT2573_RF4, rum_rf2528_r4[chan - 1]);
d1711 9
d1728 1
a1728 1
void
a1753 2

	DPRINTF(("%s: enabling TSF synchronization\n", USBDEVNAME(sc->sc_dev)));
d1756 1
a1756 1
void
a1766 1

a1767 8
}

void
rum_set_txpreamble(struct rum_softc *sc)
{
	uint32_t tmp;

	tmp = rum_read(sc, RT2573_TXRX_CSR10);
d1769 1
a1769 5
	tmp &= ~RT2573_SHORT_PREAMBLE;
	if (sc->sc_ic.ic_flags & IEEE80211_F_SHPREAMBLE)
		tmp |= RT2573_SHORT_PREAMBLE;

	rum_write(sc, RT2573_TXRX_CSR10, tmp);
d1772 1
a1772 19
void
rum_set_basicrates(struct rum_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/* update basic rate set */
	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		/* 11b basic rates: 1, 2Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x3);
	} else if (IEEE80211_IS_CHAN_5GHZ(ic->ic_bss->ni_chan)) {
		/* 11a basic rates: 6, 12, 24Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x150);
	} else {
		/* 11g basic rates: 1, 2, 5.5, 11, 6, 12, 24Mbps */
		rum_write(sc, RT2573_TXRX_CSR5, 0x15f);
	}
}

void
a1781 3

	DPRINTF(("%s: setting BSSID to %s\n", USBDEVNAME(sc->sc_dev),
	    ether_sprintf(bssid)));
d1784 1
a1784 1
void
a1793 3

	DPRINTF(("%s: setting MAC address to %s\n", USBDEVNAME(sc->sc_dev),
	    ether_sprintf(addr)));
d1796 1
a1796 1
void
d1810 2
a1811 2
	DPRINTF(("%s: %s promiscuous mode\n", USBDEVNAME(sc->sc_dev),
	    (ifp->if_flags & IFF_PROMISC) ? "entering" : "leaving"));
d1814 1
a1814 1
const char *
d1818 1
d1820 2
d1826 1
a1826 1
void
d1831 3
d1835 1
a1835 1
	/* retrieve MAC/BBP type */
d1839 4
a1842 1
	rum_eeprom_read(sc, RT2573_EEPROM_CONFIG0_RT71, &val, 2);
d1844 1
a1844 1
	sc->rf_rev =   ((val << 5) & 0x700);
a1845 2
	/* reserved  (val >> 7) & 0x3; */
	/* frametype (val >> 5) & 0x01; */
d1850 38
a1887 2
	/* read MAC address */
	rum_eeprom_read(sc, RT2573_EEPROM_ADDRESS, ic->ic_myaddr, 6);
d1890 9
a1898 4
	rum_eeprom_read(sc, RT2573_EEPROM_BBP_BASE_RT71, sc->bbp_prom, 2 * 16);

	/* read Tx power for all b/g channels */
	rum_eeprom_read(sc, RT2573_EEPROM_TXPOWER_RT71, sc->txpow, 14);
d1901 1
a1901 1
int
d1906 1
a1906 1
	uint8_t tmp;
d1908 4
a1911 3
	/* wait for BBP and RF to wake up (this can take a long time!) */
	for (ntries = 0; ntries < 1000; ntries++) {
		if (rum_read(sc, RT2573_MAC_CSR12) & 8)
a1912 2
		/* force wakeup */
		rum_write(sc, RT2573_MAC_CSR12, 0x4);
d1915 2
a1916 2
	if (ntries == 1000) {
		printf("%s: timeout waiting for BBP/RF to wakeup\n",
d1918 1
a1920 10
	/* wait for BBP */
	for (ntries = 0; ntries < 100; ntries++) {
		tmp = rum_bbp_read(sc, RT2573_BBP_VERSION);
		if (tmp != 0 && tmp != 0xff)
			break;
		DELAY(1000);
	}
	if (ntries == 100)
		printf("timeout reading BBP version\n");

d1925 1
a1925 1
	/* initialize BBP registers to values stored in EEPROM */
d1927 1
a1927 1
		if (sc->bbp_prom[i].reg == 0)
d1936 1
a1936 1
int
d1943 1
d1945 1
a1945 2
	uint32_t tmp, sta[3];
	int i;
d1957 13
d1973 3
a1975 2
	/* set default BSS channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
d1977 1
a1977 1
	rum_set_chan(sc, ic->ic_bss->ni_chan);
d1980 1
a1980 1
	rum_read_multi(sc, RT2573_STA_CSR0, sta, sizeof sta);
d1989 10
d2045 4
a2048 2
	/* kick Rx */
	tmp = RT2573_DROP_PHY_ERROR | RT2573_DROP_CRC_ERROR;
d2050 2
a2051 1
		tmp |= RT2573_DROP_CTL | RT2573_DROP_VERSION_ERROR;
d2057 1
a2057 1
	rum_write(sc, RT2573_TXRX_CSR2, tmp);
a2066 5
	/* turn on the LED */
	rum_led_write(sc, RT2573_LED_A|RT2573_LED_G|RT2573_LED_RADIO,
	    5);
	rum_write(sc, RT2573_MAC_CSR14, RT2573_LED_ON);

d2074 1
a2074 1
void
d2079 1
d2088 1
a2088 1
	rum_write(sc, RT2573_MAC_CSR14, RT2573_LED_OFF);
d2091 6
a2096 3
	rum_write(sc, RT2573_TXRX_CSR0, RT2573_DISABLE_RX);
	rum_write(sc, RT2573_MAC_CSR10, 0x0018);
	rum_led_write(sc, 0, 0);
d2118 1
a2118 16
int
rum_activate(device_ptr_t self, enum devact act)
{
	switch (act) {
	case DVACT_ACTIVATE:
		return EOPNOTSUPP;

	case DVACT_DEACTIVATE:
		/*if_deactivate(&sc->sc_ic.ic_if);*/
		break;
	}

	return 0;
}

int
a2133 1
		return (-1);
d2135 1
a2135 2

	return (0);
d2138 1
a2138 1
int
d2142 1
a2143 1
	uint16_t reg = RT2573_MCU_CODE_BASE;
d2145 1
a2145 1
	/* XXX would rum_write_multi(sc, ucode, size) work? */
d2163 1
a2163 1
int
d2181 1
a2181 1
	rum_setup_tx_desc(sc, &desc, RT2573_TX_TIMESTAMP,
d2195 48
a2242 2
void
rum_select_antenna(struct rum_softc *sc)
d2244 27
a2270 2
	uint8_t bbp4, bbp77;
	uint32_t tmp;
d2272 2
a2273 2
	bbp4 = rum_bbp_read(sc, 4);
	bbp77 = rum_bbp_read(sc, 77);
d2275 6
a2280 2
	tmp = rum_read(sc, RT2573_TXRX_CSR0);
	rum_write(sc, RT2573_TXRX_CSR0, tmp | RT2573_DISABLE_RX);
d2282 4
a2285 2
	rum_bbp_write(sc, 4, bbp4);
	rum_bbp_write(sc, 77, bbp77);
d2287 1
a2287 1
	rum_write(sc, RT2573_TXRX_CSR0, tmp);
@


1.25
log
@remove rum_set{tx,rx}antenna() that were specific to RT2500USB.
remove #define that are no longer needed or not relevant for this hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.24 2006/07/19 19:51:01 damien Exp $  */
d732 1
a732 2
	/* rx descriptor is located at the end */
	desc = (struct rum_rx_desc *)(data->buf + len - RT2573_RX_DESC_SIZE);
d767 1
@


1.24
log
@write firmware 4 bytes at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.23 2006/07/19 19:36:19 damien Exp $  */
a145 2
void		rum_set_txantenna(struct rum_softc *, int);
void		rum_set_rxantenna(struct rum_softc *, int);
a658 2
#define RT2573_RXTX_TURNAROUND	5	/* us */

a1783 49
}

void
rum_set_txantenna(struct rum_softc *sc, int antenna)
{
	uint32_t tmp;
	uint8_t tx;

	tx = rum_bbp_read(sc, RT2573_BBP_TX) & ~RT2573_BBP_ANTMASK;
	if (antenna == 1)
		tx |= RT2573_BBP_ANTA;
	else if (antenna == 2)
		tx |= RT2573_BBP_ANTB;
	else
		tx |= RT2573_BBP_DIVERSITY;

	/* need to force I/Q flip for RF 2525e, 2526 and 5222 */
	if (sc->rf_rev == RT2573_RF_2525E || sc->rf_rev == RT2573_RF_2526 ||
	    sc->rf_rev == RT2573_RF_5222)
		tx |= RT2573_BBP_FLIPIQ;

	rum_bbp_write(sc, RT2573_BBP_TX, tx);

	/* update flags in PHY_CSR5 and PHY_CSR6 too */
	tmp = rum_read(sc, RT2573_PHY_CSR5) & ~0x7;
	rum_write(sc, RT2573_PHY_CSR5, tmp | (tx & 0x7));

	tmp = rum_read(sc, RT2573_PHY_CSR6) & ~0x7;
	rum_write(sc, RT2573_PHY_CSR6, tmp | (tx & 0x7));
}

void
rum_set_rxantenna(struct rum_softc *sc, int antenna)
{
	uint8_t rx;

	rx = rum_bbp_read(sc, RT2573_BBP_RX) & ~RT2573_BBP_ANTMASK;
	if (antenna == 1)
		rx |= RT2573_BBP_ANTA;
	else if (antenna == 2)
		rx |= RT2573_BBP_ANTB;
	else
		rx |= RT2573_BBP_DIVERSITY;

	/* need to force no I/Q flip for RF 2525e and 2526 */
	if (sc->rf_rev == RT2573_RF_2525E || sc->rf_rev == RT2573_RF_2526)
		rx &= ~RT2573_BBP_FLIPIQ;

	rum_bbp_write(sc, RT2573_BBP_RX, rx);
@


1.23
log
@revert part of r1.6 commit.
only data frames must reserve 4 bytes.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.22 2006/07/19 19:32:46 damien Exp $  */
a151 1
int		rum_firmware_run(struct rum_softc *sc);
d2033 1
a2033 1
rum_firmware_run(struct rum_softc *sc)
d2037 5
d2044 2
a2045 2
	req.bRequest = RT2573_FIRMWARE_RUN;
	USETW(req.wValue, 0x8);
a2052 1
		return (-1);
d2054 1
a2054 19
	return (0);
}

int
rum_load_microcode(struct rum_softc *sc, const u_char *ucode, size_t size)
{
	size_t i;

	for (i = 0; i < size; i += 2) {
		rum_write(sc, RT2573_MCU_CODE_BASE + i,
			(ucode[i+1] << 8) | ucode[i]);
	}
	/* run the firmware */
	if (rum_firmware_run(sc) < 0) {
		return (-1);
	}
	DELAY(1000);

	return (0);
@


1.22
log
@fix rum_set_macaddr() and cleanup rum_set_bssid().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.21 2006/07/19 19:27:30 damien Exp $  */
d1005 1
a1005 1
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 3) & ~3;
d1098 2
a1099 2
	/* align end on a 4-bytes boundary */
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 3) & ~3;
d1102 1
a1102 1
	 * No space left in the last URB to store the extra 4 bytes, force
d1106 1
a1106 1
		xferlen += 4;
d1200 1
a1200 1
	/* align end on a 2-bytes boundary */
d1204 1
a1204 1
	 * No space left in the last URB to store the extra 2 bytes, force
@


1.21
log
@fix rum_write().
on RT2501USB, registers are 32bit thus the value doesn't fit into the
wValue field (16bit) of a usb_device_request_t structure.
define rum_write() using rum_write_multi(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.20 2006/07/19 19:23:26 damien Exp $  */
d140 2
a141 2
void		rum_set_bssid(struct rum_softc *, uint8_t *);
void		rum_set_macaddr(struct rum_softc *, uint8_t *);
d1660 1
a1660 1
rum_set_bssid(struct rum_softc *sc, uint8_t *bssid)
d1667 1
a1667 2
	/* XXX: magic number! */
	tmp = bssid[4] | bssid[5] << 8 | 0x00030000;
d1675 1
a1675 1
rum_set_macaddr(struct rum_softc *sc, uint8_t *addr)
d1682 1
a1682 1
	tmp = addr[4] | addr[5] << 8;
@


1.20
log
@kick ASIC only after clearing STA registers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.19 2006/07/19 19:22:02 damien Exp $  */
d1438 1
a1438 8
	usb_device_request_t req;
	usbd_status error;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = RT2573_WRITE_MAC;
	USETW(req.wValue, val);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 0);
d1440 1
a1440 5
	error = usbd_do_request(sc->sc_udev, &req, NULL);
	if (error != 0) {
		printf("%s: could not write MAC register: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
	}
@


1.19
log
@there aren't 10 STA registers on RT2501USB.
clear only STA0 to STA2 included.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.18 2006/07/19 19:18:11 damien Exp $  */
d1870 2
a1871 2
	rum_write(sc, RT2573_MAC_CSR1, 0x3);
	rum_write(sc, RT2573_MAC_CSR1, 0x0);
a1874 2
	/* set host ready */
	rum_write(sc, RT2573_MAC_CSR1, 0x4);
d1886 3
@


1.18
log
@wait for chip to settle *before* retrieving ASIC revision number since
waiting for the chip to settle means waiting until ASIC revision number
is different from zero.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.17 2006/07/19 19:15:04 damien Exp $  */
d1860 1
a1860 1
	uint32_t tmp;
d1883 2
a1884 2
	/* clear statistic registers (STA_CSR0 to STA_CSR10) */
	rum_read_multi(sc, RT2573_STA_CSR0, sc->sta, sizeof sc->sta);
@


1.17
log
@define rum_read() as rum_read_multi().
change the prototype to take a uin16_t instead of a uint32_t (register
offsets are 16bit).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.16 2006/07/19 19:10:52 damien Exp $  */
a293 10
	/* retrieve RT2573 rev. no */
	sc->asic_rev = rum_read(sc, RT2573_MAC_CSR0);

	/* retrieve MAC address and various other things from EEPROM */
	rum_read_eeprom(sc);

	printf("%s: MAC/BBP RT%02x (rev 0x%02x), RF %s, address %s\n",
	    USBDEVNAME(sc->sc_dev), sc->macbbp_rev, sc->asic_rev,
	    rum_get_rf(sc->rf_rev), ether_sprintf(ic->ic_myaddr));

d296 1
a296 2
		tmp = rum_read(sc, RT2573_MAC_CSR0);
		if (tmp != 0)
d305 10
@


1.16
log
@fix rum_read_multi() to actually read at the requested index.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.15 2006/07/19 19:07:36 damien Exp $  */
d125 1
a125 1
uint32_t	rum_read(struct rum_softc *, uint32_t);
d1408 1
a1408 1
rum_read(struct rum_softc *sc, uint32_t reg)
a1409 2
	usb_device_request_t req;
	usbd_status error;
d1412 1
a1412 12
	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = RT2573_READ_MAC;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, sizeof (uint32_t));

	error = usbd_do_request(sc->sc_udev, &req, &val);
	if (error != 0) {
		printf("%s: could not read MAC register: %s\n",
		    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
		return 0;
	}
@


1.15
log
@remove redundant #define
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.14 2006/07/18 21:24:40 damien Exp $  */
d1437 1
a1437 1
	req.bRequest = 0x7;
d1439 1
a1439 1
	USETW(req.wIndex, 0x0800);
@


1.14
log
@nuke sc->rssadapt_ch.  it was used but not initialized.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.13 2006/07/18 21:13:33 damien Exp $  */
d1494 1
a1494 1
		if (!(rum_read(sc, RT2573_PHY_CSR3_RT71) & RT2573_BBP_BUSY))
@


1.13
log
@fix a broken conditional expression in rum_bbp_init().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.12 2006/07/18 20:54:15 damien Exp $  */
a57 1
#include <net80211/ieee80211_rssadapt.h>
a593 2
		timeout_del(&sc->rssadapt_ch);

d633 1
a633 2
		if (ic->ic_opmode != IEEE80211_M_MONITOR) {
			timeout_add(&sc->rssadapt_ch, hz / 10);
a634 1
		}
@


1.12
log
@mountroothooks don't return a value, so don't use USB_ATTACH_ERROR_RETURN
(even if it's defined as return; under OpenBSD, it's just confusing).

kill all soft tabs while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.11 2006/07/18 20:37:44 damien Exp $  */
d1782 1
a1782 1
	uint32_t tmp;
d1786 1
a1786 2
		tmp = rum_read(sc, RT2573_MAC_CSR12);
		if (tmp & 8)
d1799 2
a1800 2
		tmp = rum_read(sc, 0);
		if ((tmp < 0xff) || (tmp > 0))
@


1.11
log
@fix polling for busy bit in rum_bbp_{read,write}
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.10 2006/07/18 20:29:16 damien Exp $  */
d176 1
a176 1
        RT2573_DEF_MAC
d202 9
a210 11
	u_char				*ucode;
	char				*name;
	size_t				size;
	int				err;

        name = "ral-rt2573";

	if ((err = loadfirmware(name, &ucode, &size)) != 0) {
		printf("%s: failed loadfirmware of file %s: errno %d\n",
		    USBDEVNAME(sc->sc_dev), name, err);
		USB_ATTACH_ERROR_RETURN;
a215 2
		free(ucode, M_DEVBUF);
		USB_ATTACH_ERROR_RETURN;
d217 1
a322 1

d1568 18
a1585 18
        struct ieee80211com *ic = &sc->sc_ic;
        uint8_t bbp94 = RT2573_BBPR94_DEFAULT;
        int8_t power;
        u_int chan;

        chan = ieee80211_chan2ieee(ic, c);
        if (chan == 0 || chan == IEEE80211_CHAN_ANY)
                return;

        power = sc->txpow[chan - 1];
        if (power < 0) {
                bbp94 += power;
                power = 0;
        } else if (power > 31) {
                bbp94 += power - 31;
                power = 31;
        }
        sc->sc_curchan = c;
d1604 2
a1605 2
        if (bbp94 != RT2573_BBPR94_DEFAULT)
                rum_bbp_write(sc, 94, bbp94);
d1616 14
a1629 1
        uint32_t tmp;
d1631 5
a1635 18
        if (ic->ic_opmode != IEEE80211_M_STA) {
                /*
                 * Change default 16ms TBTT adjustment to 8ms.
                 * Must be done before enabling beacon generation.
                 */
                rum_write(sc, RT2573_TXRX_CSR10, 1 << 12 | 8);
        }

        tmp = rum_read(sc, RT2573_TXRX_CSR9) & 0xff000000;

        /* set beacon interval (in 1/16ms unit) */
        tmp |= ic->ic_bss->ni_intval * 16;

        tmp |= RT2573_TSF_TICKING | RT2573_ENABLE_TBTT;
        if (ic->ic_opmode == IEEE80211_M_STA)
                tmp |= RT2573_TSF_MODE(1);
        else
                tmp |= RT2573_TSF_MODE(2) | RT2573_GENERATE_BEACON;
d2045 8
a2052 2
        usb_device_request_t req;
        usbd_status error;
d2054 4
a2057 10
        req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
        req.bRequest = RT2573_WRITE_LED;
        USETW(req.wValue, reg);
        USETW(req.wIndex, strength);
        USETW(req.wLength, 0);

        error = usbd_do_request(sc->sc_udev, &req, NULL);
        if (error != 0) {
                printf("%s: could not write LED register: %s\n",
                    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2059 1
a2059 1
        }
d2067 8
a2074 2
        usb_device_request_t req;
        usbd_status error;
d2076 4
a2079 10
        req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
        req.bRequest = RT2573_FIRMWARE_RUN;
        USETW(req.wValue, 0x8);
        USETW(req.wIndex, 0);
        USETW(req.wLength, 0);

        error = usbd_do_request(sc->sc_udev, &req, NULL);
        if (error != 0) {
                printf("%s: could not run firmware: %s\n",
                    USBDEVNAME(sc->sc_dev), usbd_errstr(error));
d2095 1
a2095 1
        if (rum_firmware_run(sc) < 0) {
d2100 1
a2100 1
        return (0);
@


1.10
log
@SEC_CSR registers have a different meaning in RT2501USB.
leave them to zero for now since we don't support h/w crypto yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.9 2006/07/18 20:23:14 damien Exp $  */
d1503 1
a1503 1
		if (!((rum_read(sc, RT2573_PHY_CSR3_RT71) >> 16) & RT2573_BBP_BUSY))
d1522 1
a1522 1
		if (!((rum_read(sc, RT2573_PHY_CSR3) >> 16) & RT2573_BBP_BUSY))
d1536 1
a1536 1
			return (val & 0xff);
d1561 1
a1561 1
	rum_write(sc, RT2573_PHY_CSR4,  tmp);
d1566 1
a1566 1
	//DPRINTFN(15, ("RF R[%u] <- 0x%05x\n", reg & 3, val & 0xfffff));
@


1.9
log
@fix rum_set_chan():
- don't read BBP register R3 since the returned value is unused
- fix RF register R1 setting
- fix RF register R3 setting
- RF settings must be written three times (with only RF R3 changing)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.8 2006/07/18 20:12:15 damien Exp $  */
a1881 1
	struct ieee80211_wepkey *wk;
d1884 1
a1885 1
	uint32_t tmp;
a1888 3

	tmp = rum_read(sc, RT2573_MAC_CSR0);

d1897 1
a1897 3

	error = rum_bbp_init(sc);
	if (error != 0)
a1913 9
	 * Copy WEP keys into adapter's memory (SEC_CSR0 to SEC_CSR31).
	 */
	for (i = 0; i < IEEE80211_WEP_NKID; i++) {
		wk = &ic->ic_nw_keys[i];
		rum_write_multi(sc, RT2573_SEC_CSR0 + i * IEEE80211_KEYBUF_SIZE,
		    wk->wk_key, IEEE80211_KEYBUF_SIZE);
	}

	/*
a1982 1

@


1.8
log
@RF registers are 20 bits on RT2501USB, not 21.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.7 2006/07/18 20:07:59 damien Exp $  */
d1573 1
a1573 1
        uint8_t bbp3, bbp94 = RT2573_BBPR94_DEFAULT;
d1591 1
a1591 1
	rum_rf_write(sc, RT2573_RF1, 0x0c808);
d1593 1
a1593 1
	rum_rf_write(sc, RT2573_RF3, power << 7 | 0x18044);
d1596 9
a1604 1
        DELAY(200);
d1606 1
a1606 1
        bbp3 = rum_bbp_read(sc, 3);
a1609 4

        /* 5GHz radio needs a 1ms delay here */
        if (IEEE80211_IS_CHAN_5GHZ(c))
                DELAY(1000);
@


1.7
log
@RT2501USB uses 32bit registers unlike RT2500USB.
fix rum_bbp_read() while i'm here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.6 2006/07/18 19:59:04 damien Exp $  */
d1559 1
a1559 1
	tmp = RT2573_RF_BUSY | RT2573_RF_21BIT | (val & 0xfffff) << 2 |
@


1.6
log
@RT2501USB needs to reserve room for a 32bit value aligned on a 32bit
boundary at the end of each data transfer (unlike RT2500USB which
reserves only 16bit).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.5 2006/07/18 19:56:12 damien Exp $  */
d1436 1
a1436 1
	return le16toh(val);
d1499 1
a1499 1
	uint16_t tmp;
d1518 1
a1518 1
	uint16_t val;
d1534 1
a1534 1
		val - rum_read(sc, RT2573_PHY_CSR3);
d1660 1
a1660 1
	uint16_t tmp;
d1724 1
a1724 1
	uint16_t tmp;
d1782 1
a1782 1
	uint16_t tmp;
d1826 1
a1826 1
	uint16_t tmp;
@


1.5
log
@- move default register values into if_rumreg.h (for consistency w/ ural)
- fix channel 11 RF R4 setting for RF2528
- overwrite BBP register 39 default value
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.4 2006/07/02 00:56:14 jsg Exp $  */
d1015 1
a1015 1
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
d1108 2
a1109 2
	/* align end on a 2-bytes boundary */
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
d1112 1
a1112 1
	 * No space left in the last URB to store the extra 2 bytes, force
d1116 1
a1116 1
		xferlen += 2;
d1211 1
a1211 1
	xferlen = (RT2573_TX_DESC_SIZE + m0->m_pkthdr.len + 1) & ~1;
d1218 1
a1218 1
		xferlen += 2;
@


1.4
log
@Fix channel frequency/flags in radiotap structures.
Now I can see probes cycling 1->14 instead of just
sitting at channel 1.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.3 2006/06/21 13:04:10 jsg Exp $  */
a171 3
/*
 * Default values for MAC registers; values taken from the reference driver.
 */
d176 1
a176 22
        { RT2573_TXRX_CSR0,        0x025fb032 },
        { RT2573_TXRX_CSR1,        0x9eaa9eaf },
        { RT2573_TXRX_CSR2,        0x8a8b8c8d },
        { RT2573_TXRX_CSR3,        0x00858687 },
        { RT2573_TXRX_CSR7,        0x2E31353B },
        { RT2573_TXRX_CSR8,        0x2a2a2a2c },
        { RT2573_TXRX_CSR15,       0x0000000f },
        { RT2573_MAC_CSR6,         0x00000fff },
        { RT2573_MAC_CSR8,         0x016c030a },
        { RT2573_MAC_CSR10,        0x00000718 },
        { RT2573_MAC_CSR12,        0x00000004 },
        { RT2573_MAC_CSR13,        0x00007f00 },
        { RT2573_SEC_CSR0,         0x00000000 },
        { RT2573_SEC_CSR1,         0x00000000 },
        { RT2573_SEC_CSR5,         0x00000000 },
        { RT2573_PHY_CSR1,         0x000023b0 },
        { RT2573_PHY_CSR5,         0x00040a06 },
        { RT2573_PHY_CSR6,         0x00080606 },
        { RT2573_PHY_CSR7,         0x00000408 },
        { RT2573_AIFSN_CSR,        0x00002273 },
        { RT2573_CWMIN_CSR,        0x00002344 },
        { RT2573_CWMAX_CSR,        0x000034aa }
a178 3
/*
 * Default values for BBP registers; values taken from the reference driver.
 */
d183 1
a183 34
	{  3, 0x80 },
	{ 15, 0x30 },
	{ 17, 0x20 },
	{ 21, 0xc8 },
	{ 22, 0x38 },
	{ 23, 0x06 },
	{ 24, 0xfe },
	{ 25, 0x0a },
	{ 26, 0x0d },
	{ 32, 0x0b },
	{ 34, 0x12 },
	{ 37, 0x07 },
	{ 41, 0x60 },
	{ 53, 0x10 },
	{ 54, 0x18 },
	{ 60, 0x10 },
	{ 61, 0x04 },
	{ 62, 0x04 },
	{ 75, 0xfe },
	{ 86, 0xfe },
	{ 88, 0xfe },
	{ 90, 0x0f },
	{ 99, 0x00 },
	{ 102, 0x16 },
	{ 107, 0x04 }
};

/*
 * Default values for RF register R2 indexed by channel numbers.
 */

static const uint32_t rum_rf2528_r2[] = {
	0x001e1, 0x001e1, 0x001e2, 0x001e2, 0x001e3, 0x001e3, 0x001e4,
	0x001e4, 0x001e5, 0x001e5, 0x001e6, 0x001e6, 0x001e7, 0x001e8
d186 2
a187 4
static const uint32_t rum_rf2528_r4[] = {
	0x30282, 0x30287, 0x30282, 0x30287, 0x30282, 0x30287, 0x30282,
	0x30287, 0x30282, 0x30287, 0x39282, 0x30287, 0x30282, 0x30284
};
a188 4
/*
 * For dual-band RF, RF registers R1 and R4 also depend on channel number;
 * values taken from the reference driver.
 */
d191 1
a191 4
	uint32_t	r1;
	uint32_t	r2;
	uint32_t	r3;
	uint32_t	r4;
d193 1
a193 40
	{   1, 0x08808, 0x0044d, 0x00282 },
	{   2, 0x08808, 0x0044e, 0x00282 },
	{   3, 0x08808, 0x0044f, 0x00282 },
	{   4, 0x08808, 0x00460, 0x00282 },
	{   5, 0x08808, 0x00461, 0x00282 },
	{   6, 0x08808, 0x00462, 0x00282 },
	{   7, 0x08808, 0x00463, 0x00282 },
	{   8, 0x08808, 0x00464, 0x00282 },
	{   9, 0x08808, 0x00465, 0x00282 },
	{  10, 0x08808, 0x00466, 0x00282 },
	{  11, 0x08808, 0x00467, 0x00282 },
	{  12, 0x08808, 0x00468, 0x00282 },
	{  13, 0x08808, 0x00469, 0x00282 },
	{  14, 0x08808, 0x0046b, 0x00286 },

	{  36, 0x08804, 0x06225, 0x00287 },
	{  40, 0x08804, 0x06226, 0x00287 },
	{  44, 0x08804, 0x06227, 0x00287 },
	{  48, 0x08804, 0x06228, 0x00287 },
	{  52, 0x08804, 0x06229, 0x00287 },
	{  56, 0x08804, 0x0622a, 0x00287 },
	{  60, 0x08804, 0x0622b, 0x00287 },
	{  64, 0x08804, 0x0622c, 0x00287 },

	{ 100, 0x08804, 0x02200, 0x00283 },
	{ 104, 0x08804, 0x02201, 0x00283 },
	{ 108, 0x08804, 0x02202, 0x00283 },
	{ 112, 0x08804, 0x02203, 0x00283 },
	{ 116, 0x08804, 0x02204, 0x00283 },
	{ 120, 0x08804, 0x02205, 0x00283 },
	{ 124, 0x08804, 0x02206, 0x00283 },
	{ 128, 0x08804, 0x02207, 0x00283 },
	{ 132, 0x08804, 0x02208, 0x00283 },
	{ 136, 0x08804, 0x02209, 0x00283 },
	{ 140, 0x08804, 0x0220a, 0x00283 },

	{ 149, 0x08808, 0x02429, 0x00281 },
	{ 153, 0x08808, 0x0242b, 0x00281 },
	{ 157, 0x08808, 0x0242d, 0x00281 },
	{ 161, 0x08808, 0x0242f, 0x00281 }
@


1.3
log
@Add a few RT73 devices that are known to exist in the wild.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.2 2006/06/17 20:17:12 jolan Exp $  */
d903 2
a904 2
		tap->wr_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1200 2
a1201 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
d1302 2
a1303 2
		tap->wt_chan_freq = htole16(ic->ic_ibss_chan->ic_freq);
		tap->wt_chan_flags = htole16(ic->ic_ibss_chan->ic_flags);
@


1.2
log
@prefix debug messages with the device name
@
text
@d1 1
a1 1
/*	$OpenBSD: if_rum.c,v 1.1 2006/06/16 22:30:46 niallo Exp $  */
d84 8
a91 2
	{ USB_VENDOR_RALINK,		USB_PRODUCT_RALINK_RT2573 },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050A }
@


1.1
log
@- add rum(4), a driver for the next generation Ralink Technology USB 802.11a/b/g
  wireless network devices.

not yet fully functional, putting it in the tree so others can hack on it too.
@
text
@d1 1
a1 1
/*	$OpenBSD$  */
d809 1
a809 1
	DPRINTFN(10, ("tx done\n"));
d857 1
a857 1
		DPRINTFN(5, ("PHY or CRC error\n"));
d929 1
a929 1
	DPRINTFN(15, ("rx done\n"));
d1140 2
a1141 2
	DPRINTFN(10, ("sending beacon frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
d1220 2
a1221 2
	DPRINTFN(10, ("sending mgt frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
d1228 2
d1322 2
a1323 2
	DPRINTFN(10, ("sending data frame len=%u rate=%u xfer len=%u\n",
	    m0->m_pkthdr.len, rate, xferlen));
d1741 1
a1741 1
	DPRINTF(("enabling TSF synchronization\n"));
d1803 2
a1804 1
	DPRINTF(("setting BSSID to %s\n", ether_sprintf(bssid)));
d1818 2
a1819 1
	DPRINTF(("setting MAC address to %s\n", ether_sprintf(addr)));
d1836 2
a1837 2
	DPRINTF(("%s promiscuous mode\n", (ifp->if_flags & IFF_PROMISC) ?
	    "entering" : "leaving"));
@

