head	1.32;
access;
symbols
	OPENBSD_6_1:1.31.0.4
	OPENBSD_6_1_BASE:1.31
	OPENBSD_6_0:1.30.0.4
	OPENBSD_6_0_BASE:1.30
	OPENBSD_5_9:1.29.0.2
	OPENBSD_5_9_BASE:1.29
	OPENBSD_5_8:1.27.0.4
	OPENBSD_5_8_BASE:1.27
	OPENBSD_5_7:1.26.0.2
	OPENBSD_5_7_BASE:1.26
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.23.0.4
	OPENBSD_5_5_BASE:1.23
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.6
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.18.0.4
	OPENBSD_5_2_BASE:1.18
	OPENBSD_5_1_BASE:1.18
	OPENBSD_5_1:1.18.0.2
	OPENBSD_5_0:1.17.0.2
	OPENBSD_5_0_BASE:1.17
	OPENBSD_4_9:1.13.0.2
	OPENBSD_4_9_BASE:1.13
	OPENBSD_4_8:1.4.0.4
	OPENBSD_4_8_BASE:1.4
	OPENBSD_4_7:1.4.0.2
	OPENBSD_4_7_BASE:1.4
	OPENBSD_4_6:1.3.0.8
	OPENBSD_4_6_BASE:1.3
	OPENBSD_4_5:1.3.0.4
	OPENBSD_4_5_BASE:1.3
	OPENBSD_4_4:1.3.0.2
	OPENBSD_4_4_BASE:1.3
	OPENBSD_4_3:1.2.0.2
	OPENBSD_4_3_BASE:1.2;
locks; strict;
comment	@ * @;


1.32
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.31;
commitid	6s3MfY9d6ZKdL2Uz;

1.31
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.30;
commitid	x5RWYO05Q3UFL5Oq;

1.30
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches;
next	1.29;
commitid	zkpZsVIWMnE2TPgn;

1.29
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.28;
commitid	kI4H556ZKYkRQGw5;

1.28
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.27;
commitid	fbhqfhfdKxBcsetK;

1.27
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.26;
commitid	p4LJxGKbi0BU2cG6;

1.26
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.25;
commitid	AGVMSdzbrCHVAlSG;

1.25
date	2014.07.12.18.48.53;	author tedu;	state Exp;
branches;
next	1.24;
commitid	OBNa5kfxQ2UXoiIw;

1.24
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.23;

1.23
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2013.11.07.10.32.51;	author pirofti;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2013.04.12.12.58.39;	author mpi;	state Exp;
branches;
next	1.18;

1.18
date	2011.08.17.18.58.45;	author jasper;	state Exp;
branches;
next	1.17;

1.17
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.16;

1.16
date	2011.06.19.17.55.37;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.14;

1.14
date	2011.04.05.20.42.43;	author jsg;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.17.21.02.58;	author jasper;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.17.14.53.43;	author jasper;	state Exp;
branches;
next	1.10;

1.10
date	2010.12.15.16.22.16;	author jasper;	state Exp;
branches;
next	1.9;

1.9
date	2010.12.15.14.55.04;	author jasper;	state Exp;
branches;
next	1.8;

1.8
date	2010.12.15.11.09.03;	author jsg;	state Exp;
branches;
next	1.7;

1.7
date	2010.12.03.17.02.29;	author jakemsr;	state Exp;
branches;
next	1.6;

1.6
date	2010.11.20.20.11.19;	author miod;	state Exp;
branches;
next	1.5;

1.5
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.4;

1.4
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.3;

1.3
date	2008.06.14.14.33.38;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	2007.11.23.12.58.12;	author winiger;	state Exp;
branches;
next	1.1;

1.1
date	2007.11.16.16.25.31;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.32
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@/*	$OpenBSD: uticom.c,v 1.31 2017/03/26 15:31:15 deraadt Exp $	*/
/*
 * Copyright (c) 2005 Dmitry Komissaroff <dxi@@mail.ru>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/malloc.h>
#include <sys/conf.h>
#include <sys/tty.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usbcdc.h>

#include <dev/usb/ucomvar.h>

#ifdef UTICOM_DEBUG
static int uticomdebug = 0;
#define DPRINTFN(n, x)	do { if (uticomdebug > (n)) printf x; } while (0)
#else
#define DPRINTFN(n, x)
#endif

#define DPRINTF(x) DPRINTFN(0, x)

#define	UTICOM_CONFIG_INDEX	1
#define	UTICOM_ACTIVE_INDEX	2

#define	UTICOM_IFACE_INDEX	0

/*
 * These are the maximum number of bytes transferred per frame.
 * The output buffer size cannot be increased due to the size encoding.
 */
#define UTICOM_IBUFSZ		64
#define UTICOM_OBUFSZ		64

#define UTICOM_FW_BUFSZ		16284

#define UTICOM_INTR_INTERVAL	100	/* ms */

#define UTICOM_RQ_LINE		0
/* Used to sync data0/1-toggle on reopen bulk pipe. */
#define UTICOM_RQ_SOF		1
#define UTICOM_RQ_SON		2

#define UTICOM_RQ_BAUD		3
#define UTICOM_RQ_LCR		4
#define UTICOM_RQ_FCR		5
#define UTICOM_RQ_RTS		6
#define UTICOM_RQ_DTR		7
#define UTICOM_RQ_BREAK		8
#define UTICOM_RQ_CRTSCTS	9

#define UTICOM_BRATE_REF	923077

#define UTICOM_SET_DATA_BITS(x)	(x - 5)

#define UTICOM_STOP_BITS_1	0x00
#define UTICOM_STOP_BITS_2	0x40

#define UTICOM_PARITY_NONE	0x00
#define UTICOM_PARITY_ODD	0x08
#define UTICOM_PARITY_EVEN	0x18

#define UTICOM_LCR_OVR		0x1
#define UTICOM_LCR_PTE		0x2
#define UTICOM_LCR_FRE		0x4
#define UTICOM_LCR_BRK		0x8

#define UTICOM_MCR_CTS		0x1
#define UTICOM_MCR_DSR		0x2
#define UTICOM_MCR_CD		0x4
#define UTICOM_MCR_RI		0x8

/* Structures */
struct uticom_fw_header {
	uint16_t	length;
	uint8_t		checkSum;
} __packed;

struct uticom_buf {
	unsigned int		buf_size;
	char			*buf_buf;
	char			*buf_get;
	char			*buf_put;
};

struct	uticom_softc {
	struct device		 sc_dev;	/* base device */
	struct usbd_device	*sc_udev;	/* device */
	struct usbd_interface	*sc_iface;	/* interface */

	int			sc_iface_number; /* interface number */

	struct usbd_interface	*sc_intr_iface;	/* interrupt interface */
	int			sc_intr_number;	/* interrupt number */
	struct usbd_pipe	*sc_intr_pipe;	/* interrupt pipe */
	u_char			*sc_intr_buf;	/* interrupt buffer */
	int			sc_isize;

	u_char			sc_dtr;		/* current DTR state */
	u_char			sc_rts;		/* current RTS state */
	u_char			sc_status;

	u_char			sc_lsr;		/* Local status register */
	u_char			sc_msr;		/* uticom status register */

	struct device		*sc_subdev;
};

static	usbd_status uticom_reset(struct uticom_softc *);
static	usbd_status uticom_set_crtscts(struct uticom_softc *);
static	void uticom_intr(struct usbd_xfer *, void *, usbd_status);

static	void uticom_set(void *, int, int, int);
static	void uticom_dtr(struct uticom_softc *, int);
static	void uticom_rts(struct uticom_softc *, int);
static	void uticom_break(struct uticom_softc *, int);
static	void uticom_get_status(void *, int, u_char *, u_char *);
static	int  uticom_param(void *, int, struct termios *);
static	int  uticom_open(void *, int);
static	void uticom_close(void *, int);

void uticom_attach_hook(struct device *);

static int uticom_download_fw(struct uticom_softc *sc, int pipeno,
    struct usbd_device *dev);

struct ucom_methods uticom_methods = {
	uticom_get_status,
	uticom_set,
	uticom_param,
	NULL,
	uticom_open,
	uticom_close,
	NULL,
	NULL
};

int	uticom_match(struct device *, void *, void *);
void	uticom_attach(struct device *, struct device *, void *);
int	uticom_detach(struct device *, int);

struct cfdriver uticom_cd = {
	NULL, "uticom", DV_DULL
};

const struct cfattach uticom_ca = {
	sizeof(struct uticom_softc), uticom_match, uticom_attach, uticom_detach
};

static const struct usb_devno uticom_devs[] = {
	{ USB_VENDOR_TI, USB_PRODUCT_TI_TUSB3410 },
	{ USB_VENDOR_TI, USB_PRODUCT_TI_MSP430_JTAG },
	{ USB_VENDOR_STARTECH, USB_PRODUCT_STARTECH_ICUSB232X },
	{ USB_VENDOR_MOXA, USB_PRODUCT_MOXA_UPORT1110 },
	{ USB_VENDOR_ABBOTT, USB_PRODUCT_ABBOTT_STEREO_PLUG }
};

int
uticom_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface != NULL)
		return (UMATCH_NONE);

	return (usb_lookup(uticom_devs, uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uticom_attach(struct device *parent, struct device *self, void *aux)
{
	struct uticom_softc	*sc = (struct uticom_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct usbd_device	*dev = uaa->device;

	sc->sc_udev = dev;
	sc->sc_iface = uaa->iface;

	config_mountroot(self, uticom_attach_hook);
}

void
uticom_attach_hook(struct device *self)
{
	struct uticom_softc		*sc = (struct uticom_softc *)self;
	usb_config_descriptor_t		*cdesc;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	usbd_status			 err;
	int				 status, i;
	usb_device_descriptor_t		*dd;
	struct ucom_attach_args		 uca;

	/* Initialize endpoints. */
	uca.bulkin = uca.bulkout = -1;
	sc->sc_intr_number = -1;
	sc->sc_intr_pipe = NULL;

	dd = usbd_get_device_descriptor(sc->sc_udev);
	DPRINTF(("%s: uticom_attach: num of configurations %d\n",
	    sc->sc_dev.dv_xname, dd->bNumConfigurations));

	/* The device without firmware has single configuration with single
	 * bulk out interface. */
	if (dd->bNumConfigurations > 1)
		goto fwload_done;

	/* Loading firmware. */
	DPRINTF(("%s: uticom_attach: starting loading firmware\n",
	    sc->sc_dev.dv_xname));

	err = usbd_set_config_index(sc->sc_udev, UTICOM_CONFIG_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Get the config descriptor. */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);

	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	err = usbd_device2interface_handle(sc->sc_udev, UTICOM_IFACE_INDEX,
	    &sc->sc_iface);
	if (err) {
		printf("%s: failed to get interface: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Find the bulk out interface used to upload firmware. */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
			DPRINTF(("%s: uticom_attach: data bulk out num: %d\n",
			    sc->sc_dev.dv_xname, ed->bEndpointAddress));
		}

		if (uca.bulkout == -1) {
			printf("%s: could not find data bulk out\n",
			    sc->sc_dev.dv_xname);
			usbd_deactivate(sc->sc_udev);
			return;
		}
	}

	status = uticom_download_fw(sc, uca.bulkout, sc->sc_udev);

	if (status) {
		printf("%s: firmware download failed\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	} else {
		DPRINTF(("%s: firmware download succeeded\n",
		    sc->sc_dev.dv_xname));
	}

	status = usbd_reload_device_desc(sc->sc_udev);
	if (status) {
		printf("%s: error reloading device descriptor\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

fwload_done:
	dd = usbd_get_device_descriptor(sc->sc_udev);
	DPRINTF(("%s: uticom_attach: num of configurations %d\n",
	    sc->sc_dev.dv_xname, dd->bNumConfigurations));

	err = usbd_set_config_index(sc->sc_udev, UTICOM_ACTIVE_INDEX, 1);
	if (err) {
		printf("%s: failed to set configuration: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Get the config descriptor. */
	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (cdesc == NULL) {
		printf("%s: failed to get configuration descriptor\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Get the interface (XXX: multiport chips are not supported yet). */
	err = usbd_device2interface_handle(sc->sc_udev, UTICOM_IFACE_INDEX,
	    &sc->sc_iface);
	if (err) {
		printf("%s: failed to get interface: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Find the interrupt endpoints. */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_intr_number = ed->bEndpointAddress;
			sc->sc_isize = UGETW(ed->wMaxPacketSize);

		}
	}

	if (sc->sc_intr_number == -1) {
		printf("%s: could not find interrupt in\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	/* Keep interface for interrupt. */
	sc->sc_intr_iface = sc->sc_iface;

	/* Find the bulk{in,out} endpoints. */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_iface_number = id->bInterfaceNumber;

	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for %d\n",
			    sc->sc_dev.dv_xname, i);
			usbd_deactivate(sc->sc_udev);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkin = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			uca.bulkout = ed->bEndpointAddress;
		}
	}

	if (uca.bulkin == -1) {
		printf("%s: could not find data bulk in\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	if (uca.bulkout == -1) {
		printf("%s: could not find data bulk out\n",
		    sc->sc_dev.dv_xname);
		usbd_deactivate(sc->sc_udev);
		return;
	}

	sc->sc_dtr = sc->sc_rts = -1;

	uca.portno = UCOM_UNK_PORTNO;
	uca.ibufsize = UTICOM_IBUFSZ;
	uca.obufsize = UTICOM_OBUFSZ;
	uca.ibufsizepad = UTICOM_IBUFSZ;
	uca.device = sc->sc_udev;
	uca.iface = sc->sc_iface;
	uca.opkthdrlen = 0;
	uca.methods = &uticom_methods;
	uca.arg = sc;
	uca.info = NULL;

	err = uticom_reset(sc);
	if (err) {
		printf("%s: reset failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		usbd_deactivate(sc->sc_udev);
		return;
	}

	DPRINTF(("%s: uticom_attach: in = 0x%x, out = 0x%x, intr = 0x%x\n",
	    sc->sc_dev.dv_xname, uca.bulkin,
	    uca.bulkout, sc->sc_intr_number));

	sc->sc_subdev = config_found_sm((struct device *)sc, &uca, ucomprint, ucomsubmatch);
}

int
uticom_detach(struct device *self, int flags)
{
	struct uticom_softc *sc = (struct uticom_softc *)self;

	DPRINTF(("%s: uticom_detach: sc = %p\n",
	    sc->sc_dev.dv_xname, sc));

	if (sc->sc_subdev != NULL) {
		config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
	}

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		usbd_close_pipe(sc->sc_intr_pipe);
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}

	return (0);
}

static usbd_status
uticom_reset(struct uticom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_SON;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err){
		printf("%s: uticom_reset: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (EIO);
	}

	DPRINTF(("%s: uticom_reset: done\n", sc->sc_dev.dv_xname));
	return (0);
}

static void
uticom_set(void *addr, int portno, int reg, int onoff)
{
	struct uticom_softc *sc = addr;

	switch (reg) {
	case UCOM_SET_DTR:
		uticom_dtr(sc, onoff);
		break;
	case UCOM_SET_RTS:
		uticom_rts(sc, onoff);
		break;
	case UCOM_SET_BREAK:
		uticom_break(sc, onoff);
		break;
	default:
		break;
	}
}

static void
uticom_dtr(struct uticom_softc *sc, int onoff)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uticom_dtr: onoff = %d\n", sc->sc_dev.dv_xname,
	    onoff));

	if (sc->sc_dtr == onoff)
		return;
	sc->sc_dtr = onoff;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_DTR;
	USETW(req.wValue, sc->sc_dtr ? UCDC_LINE_DTR : 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		printf("%s: uticom_dtr: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
}

static void
uticom_rts(struct uticom_softc *sc, int onoff)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uticom_rts: onoff = %d\n", sc->sc_dev.dv_xname,
	    onoff));

	if (sc->sc_rts == onoff)
		return;
	sc->sc_rts = onoff;
	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_RTS;
	USETW(req.wValue, sc->sc_rts ? UCDC_LINE_RTS : 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		printf("%s: uticom_rts: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
}

static void
uticom_break(struct uticom_softc *sc, int onoff)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uticom_break: onoff = %d\n", sc->sc_dev.dv_xname,
	    onoff));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_BREAK;
	USETW(req.wValue, onoff ? 1 : 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err)
		printf("%s: uticom_break: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
}

static usbd_status
uticom_set_crtscts(struct uticom_softc *sc)
{
	usb_device_request_t req;
	usbd_status err;

	DPRINTF(("%s: uticom_set_crtscts: on\n", sc->sc_dev.dv_xname));

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_CRTSCTS;
	USETW(req.wValue, 1);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uticom_set_crtscts: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	return (USBD_NORMAL_COMPLETION);
}

static int
uticom_param(void *vsc, int portno, struct termios *t)
{
	struct uticom_softc *sc = (struct uticom_softc *)vsc;
	usb_device_request_t req;
	usbd_status err;
	uint8_t data;

	DPRINTF(("%s: uticom_param\n", sc->sc_dev.dv_xname));

	switch (t->c_ospeed) {
	case 1200:
	case 2400:
	case 4800:
	case 7200:
	case 9600:
	case 14400:
	case 19200:
	case 38400:
	case 57600:
	case 115200:
	case 230400:
	case 460800:
	case 921600:
		req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
		req.bRequest = UTICOM_RQ_BAUD;
		USETW(req.wValue, (UTICOM_BRATE_REF / t->c_ospeed));
		USETW(req.wIndex, 0);
		USETW(req.wLength, 0);

		err = usbd_do_request(sc->sc_udev, &req, 0);
		if (err) {
			printf("%s: uticom_param: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
			return (EIO);
		}
		break;
	default:
		printf("%s: uticom_param: unsupported baud rate %d\n",
		    sc->sc_dev.dv_xname, t->c_ospeed);
		return (EINVAL);
	}

	switch (ISSET(t->c_cflag, CSIZE)) {
	case CS5:
		data = UTICOM_SET_DATA_BITS(5);
		break;
	case CS6:
		data = UTICOM_SET_DATA_BITS(6);
		break;
	case CS7:
		data = UTICOM_SET_DATA_BITS(7);
		break;
	case CS8:
		data = UTICOM_SET_DATA_BITS(8);
		break;
	default:
		return (EIO);
	}

	if (ISSET(t->c_cflag, CSTOPB))
		data |= UTICOM_STOP_BITS_2;
	else
		data |= UTICOM_STOP_BITS_1;

	if (ISSET(t->c_cflag, PARENB)) {
		if (ISSET(t->c_cflag, PARODD))
			data |= UTICOM_PARITY_ODD;
		else
			data |= UTICOM_PARITY_EVEN;
	} else
		data |= UTICOM_PARITY_NONE;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_LCR;
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);
	USETW(req.wValue, data);

	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uticom_param: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return (err);
	}

	if (ISSET(t->c_cflag, CRTSCTS)) {
		err = uticom_set_crtscts(sc);
		if (err)
			return (EIO);
	}

	return (0);
}

static int
uticom_open(void *addr, int portno)
{
	struct uticom_softc *sc = addr;
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	DPRINTF(("%s: uticom_open\n", sc->sc_dev.dv_xname));

	sc->sc_status = 0; /* clear status bit */

	if (sc->sc_intr_number != -1 && sc->sc_intr_pipe == NULL) {
		sc->sc_intr_buf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
		err = usbd_open_pipe_intr(sc->sc_intr_iface, sc->sc_intr_number,
		    USBD_SHORT_XFER_OK, &sc->sc_intr_pipe, sc, sc->sc_intr_buf,
		    sc->sc_isize, uticom_intr, UTICOM_INTR_INTERVAL);
		if (err) {
			printf("%s: cannot open interrupt pipe (addr %d)\n",
			    sc->sc_dev.dv_xname, sc->sc_intr_number);
			return (EIO);
		}
	}

	DPRINTF(("%s: uticom_open: port opened\n", sc->sc_dev.dv_xname));
	return (0);
}

static void
uticom_close(void *addr, int portno)
{
	struct uticom_softc *sc = addr;
	usb_device_request_t req;
	usbd_status err;

	if (usbd_is_dying(sc->sc_udev))
		return;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UTICOM_RQ_SON;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, 0);

	/* Try to reset UART part of chip. */
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (err) {
		printf("%s: uticom_close: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		return;
	}

	DPRINTF(("%s: uticom_close: close\n", sc->sc_dev.dv_xname));

	if (sc->sc_intr_pipe != NULL) {
		usbd_abort_pipe(sc->sc_intr_pipe);
		err = usbd_close_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: close interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		free(sc->sc_intr_buf, M_USBDEV, sc->sc_isize);
		sc->sc_intr_pipe = NULL;
	}
}

static void
uticom_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct uticom_softc *sc = priv;
	u_char *buf = sc->sc_intr_buf;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			DPRINTF(("%s: uticom_intr: int status: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(status)));
			return;
		}

		DPRINTF(("%s: uticom_intr: abnormal status: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(status)));
		usbd_clear_endpoint_stall_async(sc->sc_intr_pipe);
		return;
	}

	if (!xfer->actlen)
		return;

	DPRINTF(("%s: xfer_length = %d\n", sc->sc_dev.dv_xname,
	    xfer->actlen));

	sc->sc_lsr = sc->sc_msr = 0;

	if (buf[0] == 0) {
		/* msr registers */
		if (buf[1] & UTICOM_MCR_CTS)
			sc->sc_msr |= UMSR_CTS;
		if (buf[1] & UTICOM_MCR_DSR)
			sc->sc_msr |= UMSR_DSR;
		if (buf[1] & UTICOM_MCR_CD)
			sc->sc_msr |= UMSR_DCD;
		if (buf[1] & UTICOM_MCR_RI)
			sc->sc_msr |= UMSR_RI;
	} else {
		/* lsr registers */
		if (buf[0] & UTICOM_LCR_OVR)
			sc->sc_lsr |= ULSR_OE;
		if (buf[0] & UTICOM_LCR_PTE)
			sc->sc_lsr |= ULSR_PE;
		if (buf[0] & UTICOM_LCR_FRE)
			sc->sc_lsr |= ULSR_FE;
		if (buf[0] & UTICOM_LCR_BRK)
			sc->sc_lsr |= ULSR_BI;
	}

//	if (uticomstickdsr)
//		sc->sc_msr |= UMSR_DSR;

	ucom_status_change((struct ucom_softc *)sc->sc_subdev);
}

static void
uticom_get_status(void *addr, int portno, u_char *lsr, u_char *msr)
{
#if 0 /* TODO */
	struct uticom_softc *sc = addr;

	DPRINTF(("uticom_get_status:\n"));

	if (lsr != NULL)
		*lsr = sc->sc_lsr;
	if (msr != NULL)
		*msr = sc->sc_msr;
#endif
	return;
}

static int
uticom_download_fw(struct uticom_softc *sc, int pipeno,
    struct usbd_device *dev)
{
	u_char *obuf, *firmware;
	size_t firmware_size;
	int buffer_size, pos;
	uint8_t cs = 0, *buffer;
	usbd_status err;
	struct uticom_fw_header *header;
	struct usbd_xfer *oxfer = 0;
	usbd_status error = 0;
	struct usbd_pipe *pipe;

	error = loadfirmware("tusb3410", &firmware, &firmware_size);
	if (error)
		return (error);

	buffer_size = UTICOM_FW_BUFSZ + sizeof(struct uticom_fw_header);
	buffer = malloc(buffer_size, M_USBDEV, M_WAITOK | M_CANFAIL);

	if (!buffer) {
		printf("%s: uticom_download_fw: out of memory\n",
		    sc->sc_dev.dv_xname);
		free(firmware, M_DEVBUF, firmware_size);
		return ENOMEM;
	}

	memcpy(buffer, firmware, firmware_size);
	memset(buffer + firmware_size, 0xff, buffer_size - firmware_size);

	for (pos = sizeof(struct uticom_fw_header); pos < buffer_size; pos++)
		cs = (uint8_t)(cs + buffer[pos]);

	header = (struct uticom_fw_header*)buffer;
	header->length = (uint16_t)(buffer_size -
	    sizeof(struct uticom_fw_header));
	header->checkSum = cs;

	DPRINTF(("%s: downloading firmware ...\n",
	    sc->sc_dev.dv_xname));

	err = usbd_open_pipe(sc->sc_iface, pipeno, USBD_EXCLUSIVE_USE,
	    &pipe);
	if (err) {
		printf("%s: open bulk out error (addr %d): %s\n",
		    sc->sc_dev.dv_xname, pipeno, usbd_errstr(err));
		error = EIO;
		goto finish;
	}

	oxfer = usbd_alloc_xfer(dev);
	if (oxfer == NULL) {
		error = ENOMEM;
		goto finish;
	}

	obuf = usbd_alloc_buffer(oxfer, buffer_size);
	if (obuf == NULL) {
		error = ENOMEM;
		goto finish;
	}

	memcpy(obuf, buffer, buffer_size);

	usbd_setup_xfer(oxfer, pipe, (void *)sc, obuf, buffer_size,
	    USBD_NO_COPY | USBD_SYNCHRONOUS, USBD_NO_TIMEOUT, 0);
	err = usbd_transfer(oxfer);

	if (err != USBD_NORMAL_COMPLETION)
		printf("%s: uticom_download_fw: error: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));

finish:
	free(firmware, M_DEVBUF, firmware_size);
	usbd_free_buffer(oxfer);
	usbd_free_xfer(oxfer);
	oxfer = NULL;
	usbd_abort_pipe(pipe);
	usbd_close_pipe(pipe);
	free(buffer, M_USBDEV, buffer_size);
	return err;
}
@


1.31
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.30 2016/05/24 05:35:01 mpi Exp $	*/
d463 1
a463 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
d763 1
a763 1
		free(sc->sc_intr_buf, M_USBDEV, 0);
@


1.30
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.29 2016/01/08 15:54:14 jcs Exp $	*/
d866 1
a866 1
		free(firmware, M_DEVBUF, 0);
d916 1
a916 1
	free(firmware, M_DEVBUF, 0);
d922 1
a922 1
	free(buffer, M_USBDEV, 0);
@


1.29
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.28 2015/12/11 16:07:02 mpi Exp $	*/
a149 3
#if 0 /* TODO */
static	int  uticom_ioctl(void *, int, u_long, caddr_t, int, usb_proc_ptr);
#endif
d163 1
a163 1
	NULL, /* uticom_ioctl, TODO */
a840 31

#if 0 /* TODO */
static int
uticom_ioctl(void *addr, int portno, u_long cmd, caddr_t data, int flag,
    usb_proc_ptr p)
{
	struct uticom_softc *sc = addr;
	int error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTF(("uticom_ioctl: cmd = 0x%08lx\n", cmd));

	switch (cmd) {
	case TIOCNOTTY:
	case TIOCMGET:
	case TIOCMSET:
	case USB_GET_CM_OVER_DATA:
	case USB_SET_CM_OVER_DATA:
		break;

	default:
		DPRINTF(("uticom_ioctl: unknown\n"));
		error = ENOTTY;
		break;
	}

	return (error);
}
#endif
@


1.28
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.27 2015/03/14 03:38:50 jsg Exp $	*/
a37 1

@


1.27
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.26 2014/07/12 21:24:33 mpi Exp $	*/
d158 1
a158 1
void uticom_attach_hook(void *arg);
d216 1
a216 4
	if (rootvp == NULL)
		mountroothook_establish(uticom_attach_hook, sc);
	else
		uticom_attach_hook(sc);
d220 1
a220 1
uticom_attach_hook(void *arg)
d222 1
a222 1
	struct uticom_softc		*sc = arg;
@


1.26
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.25 2014/07/12 18:48:53 tedu Exp $	*/
a37 1
#include <dev/usb/usbhid.h>
@


1.25
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.24 2014/03/07 18:39:02 mpi Exp $	*/
a177 1
int	uticom_activate(struct device *, int);
d184 1
a184 5
	sizeof(struct uticom_softc),
	uticom_match,
	uticom_attach,
	uticom_detach,
	uticom_activate,
a452 13
}

int
uticom_activate(struct device *self, int act)
{
	struct uticom_softc *sc = (struct uticom_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.24
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.23 2013/11/15 10:17:39 pirofti Exp $	*/
d489 1
a489 1
		free(sc->sc_intr_buf, M_USBDEV);
d789 1
a789 1
		free(sc->sc_intr_buf, M_USBDEV);
d923 1
a923 1
		free(firmware, M_DEVBUF);
d973 1
a973 1
	free(firmware, M_DEVBUF);
d979 1
a979 1
	free(buffer, M_USBDEV);
@


1.23
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.22 2013/11/15 08:25:31 pirofti Exp $	*/
d48 2
a49 3
#ifdef USB_DEBUG
static int	uticomdebug = 0;

@


1.22
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.21 2013/11/07 10:32:51 pirofti Exp $	*/
d785 1
a785 4
		err = usbd_abort_pipe(sc->sc_intr_pipe);
		if (err)
			printf("%s: abort interrupt pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.21
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.20 2013/04/15 09:23:02 mglocker Exp $	*/
a464 1
	int rv = 0;
a467 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d471 1
a471 1
	return (rv);
@


1.20
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.19 2013/04/12 12:58:39 mpi Exp $	*/
a141 1
	u_char			 sc_dying;
d263 1
a263 1
		sc->sc_dying = 1;
d273 1
a273 1
		sc->sc_dying = 1;
d282 1
a282 1
		sc->sc_dying = 1;
d295 1
a295 1
			sc->sc_dying = 1;
d309 1
a309 1
			sc->sc_dying = 1;
d319 1
a319 1
		sc->sc_dying = 1;
d330 1
a330 1
		sc->sc_dying = 1;
d343 1
a343 1
		sc->sc_dying = 1;
d352 1
a352 1
		sc->sc_dying = 1;
d362 1
a362 1
		sc->sc_dying = 1;
d375 1
a375 1
			sc->sc_dying = 1;
d390 1
a390 1
		sc->sc_dying = 1;
d406 1
a406 1
			sc->sc_dying = 1;
d422 1
a422 1
		sc->sc_dying = 1;
d429 1
a429 1
		sc->sc_dying = 1;
d450 1
a450 1
		sc->sc_dying = 1;
d471 1
a471 1
		sc->sc_dying = 1;
d738 1
a738 1
	if (sc->sc_dying)
d768 1
a768 1
	if (sc->sc_dying)
d807 1
a807 1
	if (sc->sc_dying)
d883 1
a883 1
	if (sc->sc_ucom.sc_dying)
@


1.19
log
@Instead of using a wrapper around usbd_transfer() when submitting a
transfer synchronously just pass the USBD_SYNCHRONOUS flag like any
other flags when creating a transfer.

ok sthen@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.18 2011/08/17 18:58:45 jasper Exp $	*/
d123 2
a124 2
	usbd_device_handle	 sc_udev;	/* device */
	usbd_interface_handle	 sc_iface;	/* interface */
d128 1
a128 1
	usbd_interface_handle	sc_intr_iface;	/* interrupt interface */
d130 1
a130 1
	usbd_pipe_handle	sc_intr_pipe;	/* interrupt pipe */
d147 1
a147 1
static	void uticom_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d164 1
a164 1
	    usbd_device_handle dev);
d219 1
a219 1
	usbd_device_handle	 dev = uaa->device;
d803 1
a803 1
uticom_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d909 1
a909 1
    usbd_device_handle dev)
d917 1
a917 1
	usbd_xfer_handle oxfer = 0;
d919 1
a919 1
	usbd_pipe_handle pipe;
d972 1
a972 1
	usbd_setup_xfer(oxfer, pipe, (usbd_private_handle)sc, obuf, buffer_size,
@


1.18
log
@match on MSP-FET430UIF JTAG, so it can be used with mspdebug
from impatiens@@gmail.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.17 2011/07/03 15:47:17 matthew Exp $	*/
d974 1
a974 1
	err = usbd_sync_transfer(oxfer);
@


1.17
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.16 2011/06/19 17:55:37 jsg Exp $	*/
d196 1
@


1.16
log
@fix up unbalanced format strings
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.15 2011/06/17 07:06:47 mk Exp $	*/
a467 3
	case DVACT_ACTIVATE:
		break;

@


1.15
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.14 2011/04/05 20:42:43 jsg Exp $	*/
d360 1
a360 1
		printf("failed to get interface: %s\n",
d373 1
a373 1
			printf("no endpoint descriptor for %d\n",
@


1.14
log
@binary vs logical or, found by clang
ok mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.13 2011/01/25 20:03:36 jakemsr Exp $	*/
d928 1
a928 1
	buffer = malloc(buffer_size, M_USBDEV, M_WAITOK);
@


1.13
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.12 2010/12/17 21:02:58 jasper Exp $	*/
d975 1
a975 1
	    USBD_NO_COPY || USBD_SYNCHRONOUS, USBD_NO_TIMEOUT, 0);
@


1.12
log
@- attach to abbott stereo plug and fix it's firmware loading

from aschrijver@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.11 2010/12/17 14:53:43 jasper Exp $	*/
a499 2
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
	    &sc->sc_dev);
@


1.11
log
@- attach to moxa uport110, from rivo nurges
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.10 2010/12/15 16:22:16 jasper Exp $	*/
d122 1
a122 1
	struct device		 sc_dev;		/* base device */
d161 2
d197 2
a198 1
	{ USB_VENDOR_MOXA, USB_PRODUCT_MOXA_UPORT1110 }
d216 3
a218 10
	struct uticom_softc *sc = (struct uticom_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usbd_device_handle dev = uaa->device;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status err;
	int status, i;
	usb_device_descriptor_t *dd;
	struct ucom_attach_args uca;
d223 18
d246 1
a246 1
	dd = usbd_get_device_descriptor(dev);
d259 1
a259 1
	err = usbd_set_config_index(dev, UTICOM_CONFIG_INDEX, 1);
d277 1
a277 1
	err = usbd_device2interface_handle(dev, UTICOM_IFACE_INDEX,
d314 1
a314 1
	status = uticom_download_fw(sc, uca.bulkout, dev);
d326 1
a326 1
	status = usbd_reload_device_desc(dev);
d335 1
a335 1
	dd = usbd_get_device_descriptor(dev);
d339 1
a339 1
	err = usbd_set_config_index(dev, UTICOM_ACTIVE_INDEX, 1);
d357 1
a357 1
	err = usbd_device2interface_handle(dev, UTICOM_IFACE_INDEX,
d383 1
d439 1
a439 1
	uca.device = dev;
d458 1
a458 1
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
@


1.10
log
@- the firmware download succeeded message should be wrapped in DPRINTF().

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.9 2010/12/15 14:55:04 jasper Exp $	*/
d194 2
a195 1
	{ USB_VENDOR_STARTECH, USB_PRODUCT_STARTECH_ICUSB232X }
@


1.9
log
@- attach to the startech ICUSB232X, though only the first port can be used
on this multiport device.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.8 2010/12/15 11:09:03 jsg Exp $	*/
d307 2
a308 2
		printf("%s: firmware download succeeded\n",
		    sc->sc_dev.dv_xname);
@


1.8
log
@make this not panic on attach
from Daniel Gracia
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.7 2010/12/03 17:02:29 jakemsr Exp $	*/
d192 5
d205 2
a206 4
	if (uaa->vendor == USB_VENDOR_TI &&
	    uaa->product == USB_PRODUCT_TI_TUSB3410)
		return (UMATCH_VENDOR_PRODUCT);
	return (0);
@


1.7
log
@missing ; in previous
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.6 2010/11/20 20:11:19 miod Exp $	*/
a211 1
	usbd_interface_handle iface;
d383 1
a383 1
		ed = usbd_interface2endpoint_descriptor(iface, i);
d421 1
a421 1
	uca.iface = iface;
@


1.6
log
@__attribute__((packed)) -> __packed. The ioprbs.c chunk was commented out, and
uncommenting it is intentional.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.5 2010/09/24 08:33:59 yuo Exp $	*/
d112 1
a112 1
} __packed
@


1.5
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.4 2009/10/13 19:33:19 pirofti Exp $	*/
d112 1
a112 1
} __attribute__((packed));
@


1.4
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uticom.c,v 1.3 2008/06/14 14:33:38 fgsch Exp $	*/
a468 1
	sc->sc_dying = 1;
@


1.3
log
@id tag.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d178 1
a178 1
int	uticom_activate(struct device *, enum devact);
d444 1
a444 1
uticom_activate(struct device *self, enum devact act)
@


1.2
log
@kprintf -> printf, unbreaks USB_DEBUG

"of course" deraadt@@
@
text
@d1 1
@


1.1
log
@driver for TI TUSB3410 usb serial, written by dxi@@mail.ru and
hasso@@dragonfly.org, ported but not yet tested.. waiting for hardware
@
text
@d50 1
a50 1
#define DPRINTFN(n, x)	do { if (uticomdebug > (n)) kprintf x; } while (0)
@

