head	1.44;
access;
symbols
	OPENBSD_6_1:1.44.0.2
	OPENBSD_6_1_BASE:1.44
	OPENBSD_6_0:1.41.0.8
	OPENBSD_6_0_BASE:1.41
	OPENBSD_5_9:1.41.0.2
	OPENBSD_5_9_BASE:1.41
	OPENBSD_5_8:1.41.0.4
	OPENBSD_5_8_BASE:1.41
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.39.0.4
	OPENBSD_5_6_BASE:1.39
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.37.0.2
	OPENBSD_5_4_BASE:1.37
	OPENBSD_5_3:1.33.0.4
	OPENBSD_5_3_BASE:1.33
	OPENBSD_5_2:1.33.0.2
	OPENBSD_5_2_BASE:1.33
	OPENBSD_5_1_BASE:1.32
	OPENBSD_5_1:1.32.0.4
	OPENBSD_5_0:1.32.0.2
	OPENBSD_5_0_BASE:1.32
	OPENBSD_4_9:1.28.0.2
	OPENBSD_4_9_BASE:1.28
	OPENBSD_4_8:1.26.0.4
	OPENBSD_4_8_BASE:1.26
	OPENBSD_4_7:1.26.0.2
	OPENBSD_4_7_BASE:1.26
	OPENBSD_4_6:1.25.0.8
	OPENBSD_4_6_BASE:1.25
	OPENBSD_4_5:1.25.0.4
	OPENBSD_4_5_BASE:1.25
	OPENBSD_4_4:1.25.0.2
	OPENBSD_4_4_BASE:1.25
	OPENBSD_4_3:1.24.0.2
	OPENBSD_4_3_BASE:1.24
	OPENBSD_4_2:1.22.0.2
	OPENBSD_4_2_BASE:1.22
	OPENBSD_4_1:1.16.0.2
	OPENBSD_4_1_BASE:1.16
	OPENBSD_4_0:1.16.0.4
	OPENBSD_4_0_BASE:1.16
	OPENBSD_3_9:1.14.0.2
	OPENBSD_3_9_BASE:1.14
	OPENBSD_3_8:1.12.0.2
	OPENBSD_3_8_BASE:1.12
	OPENBSD_3_7:1.11.0.2
	OPENBSD_3_7_BASE:1.11
	OPENBSD_3_6:1.10.0.4
	OPENBSD_3_6_BASE:1.10
	SMP_SYNC_A:1.9
	SMP_SYNC_B:1.9
	OPENBSD_3_5:1.9.0.4
	OPENBSD_3_5_BASE:1.9
	OPENBSD_3_4:1.9.0.2
	OPENBSD_3_4_BASE:1.9
	UBC_SYNC_A:1.8
	SMP:1.7.0.4
	OPENBSD_3_3:1.7.0.2
	OPENBSD_3_3_BASE:1.7
	UBC:1.6.0.4
	UBC_SYNC_B:1.6
	OPENBSD_3_2:1.6.0.2
	OPENBSD_3_2_BASE:1.6;
locks; strict;
comment	@ * @;


1.44
date	2017.02.10.08.07.21;	author ratchov;	state Exp;
branches;
next	1.43;
commitid	THdT1ZpQDSrNTjXY;

1.43
date	2017.01.07.06.10.40;	author ratchov;	state Exp;
branches;
next	1.42;
commitid	LQ0nbCcsZLO7sW2m;

1.42
date	2016.12.20.15.32.07;	author ratchov;	state Exp;
branches;
next	1.41;
commitid	BYqAzYlcqE2cO2Ra;

1.41
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.40;
commitid	p4LJxGKbi0BU2cG6;

1.40
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.39;
commitid	zM5ckwX4kwwmipG0;

1.39
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.38;
commitid	OBNa5kfxQ2UXoiIw;

1.38
date	2013.11.10.10.22.39;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2013.05.15.08.29.26;	author ratchov;	state Exp;
branches;
next	1.36;

1.36
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.34;

1.34
date	2013.03.28.03.31.55;	author tedu;	state Exp;
branches;
next	1.33;

1.33
date	2012.03.30.08.18.19;	author ratchov;	state Exp;
branches;
next	1.32;

1.32
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.31;

1.31
date	2011.06.23.23.04.28;	author oga;	state Exp;
branches;
next	1.30;

1.30
date	2011.06.23.22.03.43;	author oga;	state Exp;
branches;
next	1.29;

1.29
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.28;

1.28
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.27;

1.27
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.26;

1.26
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.25;

1.25
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.06.23.50.55;	author krw;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2007.05.05.16.31.27;	author krw;	state Exp;
branches;
next	1.16;

1.16
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.15;

1.15
date	2006.04.07.22.41.33;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.13;

1.13
date	2005.09.07.05.27.47;	author jsg;	state Exp;
branches;
next	1.12;

1.12
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.20.01.29.37;	author jsg;	state Exp;
branches;
next	1.10;

1.10
date	2004.06.27.19.44.48;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2003.05.19.00.36.33;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches
	1.7.4.1;
next	1.6;

1.6
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches
	1.6.4.1;
next	1.5;

1.5
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.07.09.15.22.08;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2002.06.11.07.49.56;	author nate;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.6.4.1
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;

1.7.4.1
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.7.4.2;

1.7.4.2
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	;


desc
@@


1.44
log
@Use __func__ for DPRINTF's as we do in other parts of the
code. From Michael W. Bombardieri" <mb at ii.net>. Thanks.
@
text
@/*	$OpenBSD: umidi.c,v 1.43 2017/01/07 06:10:40 ratchov Exp $	*/
/*	$NetBSD: umidi.c,v 1.16 2002/07/11 21:14:32 augustss Exp $	*/
/*
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Takuya SHIOZAKI (tshiozak@@netbsd.org).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/uaudioreg.h>
#include <dev/usb/umidireg.h>
#include <dev/usb/umidivar.h>
#include <dev/usb/umidi_quirks.h>

#include <dev/audio_if.h>
#include <dev/midi_if.h>

#ifdef UMIDI_DEBUG
#define DPRINTF(x)	if (umididebug) printf x
#define DPRINTFN(n,x)	if (umididebug >= (n)) printf x
int	umididebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif


static int umidi_open(void *, int,
		      void (*)(void *, int), void (*)(void *), void *);
static void umidi_close(void *);
static int umidi_output(void *, int);
static void umidi_flush(void *);
static void umidi_getinfo(void *, struct midi_info *);

static usbd_status alloc_pipe(struct umidi_endpoint *);
static void free_pipe(struct umidi_endpoint *);

static usbd_status alloc_all_endpoints(struct umidi_softc *);
static void free_all_endpoints(struct umidi_softc *);

static usbd_status alloc_all_jacks(struct umidi_softc *);
static void free_all_jacks(struct umidi_softc *);
static usbd_status bind_jacks_to_mididev(struct umidi_softc *,
					 struct umidi_jack *,
					 struct umidi_jack *,
					 struct umidi_mididev *);
static void unbind_jacks_from_mididev(struct umidi_mididev *);
static void unbind_all_jacks(struct umidi_softc *);
static usbd_status assign_all_jacks_automatically(struct umidi_softc *);
static usbd_status open_out_jack(struct umidi_jack *, void *,
				 void (*)(void *));
static usbd_status open_in_jack(struct umidi_jack *, void *,
				void (*)(void *, int));
static void close_jack(struct umidi_jack *);

static usbd_status attach_mididev(struct umidi_softc *,
				  struct umidi_mididev *);
static usbd_status detach_mididev(struct umidi_mididev *, int);
static usbd_status deactivate_mididev(struct umidi_mididev *);
static usbd_status alloc_all_mididevs(struct umidi_softc *, int);
static void free_all_mididevs(struct umidi_softc *);
static usbd_status attach_all_mididevs(struct umidi_softc *);
static usbd_status detach_all_mididevs(struct umidi_softc *, int);
static usbd_status deactivate_all_mididevs(struct umidi_softc *);

#ifdef UMIDI_DEBUG
static void dump_sc(struct umidi_softc *);
static void dump_ep(struct umidi_endpoint *);
static void dump_jack(struct umidi_jack *);
#endif

static void init_packet(struct umidi_packet *);

static usbd_status start_input_transfer(struct umidi_endpoint *);
static usbd_status start_output_transfer(struct umidi_endpoint *);
static int out_jack_output(struct umidi_jack *, int);
static void out_jack_flush(struct umidi_jack *);
static void in_intr(struct usbd_xfer *, void *, usbd_status);
static void out_intr(struct usbd_xfer *, void *, usbd_status);
static int out_build_packet(int, struct umidi_packet *, uByte, u_char *);


struct midi_hw_if umidi_hw_if = {
	umidi_open,
	umidi_close,
	umidi_output,
	umidi_flush,		/* flush */
	umidi_getinfo,
	0,		/* ioctl */
};

int umidi_match(struct device *, void *, void *); 
void umidi_attach(struct device *, struct device *, void *); 
int umidi_detach(struct device *, int); 
int umidi_activate(struct device *, int); 

struct cfdriver umidi_cd = { 
	NULL, "umidi", DV_DULL 
}; 

const struct cfattach umidi_ca = { 
	sizeof(struct umidi_softc), 
	umidi_match, 
	umidi_attach, 
	umidi_detach, 
	umidi_activate, 
};

int
umidi_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;

	DPRINTFN(1,("%s\n", __func__));

	if (uaa->iface == NULL)
		return UMATCH_NONE;

	if (umidi_search_quirk(uaa->vendor, uaa->product, uaa->ifaceno))
		return UMATCH_IFACECLASS_IFACESUBCLASS;

	id = usbd_get_interface_descriptor(uaa->iface);
	if (id!=NULL &&
	    id->bInterfaceClass==UICLASS_AUDIO &&
	    id->bInterfaceSubClass==UISUBCLASS_MIDISTREAM)
		return UMATCH_IFACECLASS_IFACESUBCLASS;

	return UMATCH_NONE;
}

void
umidi_attach(struct device *parent, struct device *self, void *aux)
{
	usbd_status err;
	struct umidi_softc *sc = (struct umidi_softc *)self;
	struct usb_attach_arg *uaa = aux;
	int i;

	DPRINTFN(1,("%s\n", __func__));

	sc->sc_iface = uaa->iface;
	sc->sc_udev = uaa->device;

	sc->sc_quirk =
	    umidi_search_quirk(uaa->vendor, uaa->product, uaa->ifaceno);
	printf("%s: ", sc->sc_dev.dv_xname);
	umidi_print_quirk(sc->sc_quirk);

	err = alloc_all_endpoints(sc);
	if (err!=USBD_NORMAL_COMPLETION)
		goto error;
	err = alloc_all_jacks(sc);
	if (err!=USBD_NORMAL_COMPLETION) {
		free_all_endpoints(sc);
		goto error;
	}
	printf("%s: out=%d, in=%d\n",
	       sc->sc_dev.dv_xname,
	       sc->sc_out_num_jacks, sc->sc_in_num_jacks);

	err = assign_all_jacks_automatically(sc);
	if (err!=USBD_NORMAL_COMPLETION) {
		unbind_all_jacks(sc);
		free_all_jacks(sc);
		free_all_endpoints(sc);
		goto error;
	}
	err = attach_all_mididevs(sc);
	if (err!=USBD_NORMAL_COMPLETION) {
		free_all_jacks(sc);
		free_all_endpoints(sc);
	}

#ifdef UMIDI_DEBUG
	dump_sc(sc);
#endif

	for (i = 0; i < sc->sc_in_num_endpoints; i++)
		(void)start_input_transfer(&sc->sc_in_ep[i]);
	return;
error:
	printf("%s: disabled.\n", sc->sc_dev.dv_xname);
	usbd_deactivate(sc->sc_udev);
}

int
umidi_activate(struct device *self, int act)
{
	struct umidi_softc *sc = (struct umidi_softc *)self;

	if (act == DVACT_DEACTIVATE) {
		DPRINTFN(1,("%s (deactivate)\n", __func__));
		usbd_deactivate(sc->sc_udev);
		deactivate_all_mididevs(sc);
	}
	return 0;
}

int
umidi_detach(struct device *self, int flags)
{
	struct umidi_softc *sc = (struct umidi_softc *)self;

	DPRINTFN(1,("%s\n", __func__));

	detach_all_mididevs(sc, flags);
	free_all_mididevs(sc);
	free_all_jacks(sc);
	free_all_endpoints(sc);

	return 0;
}


/*
 * midi_if stuffs
 */
int
umidi_open(void *addr,
	   int flags,
	   void (*iintr)(void *, int),
	   void (*ointr)(void *),
	   void *arg)
{
	struct umidi_mididev *mididev = addr;
	struct umidi_softc *sc = mididev->sc;

	DPRINTF(("%s: sc=%p\n", __func__, sc));

	if (!sc)
		return ENXIO;
	if (mididev->opened)
		return EBUSY;
	if (usbd_is_dying(sc->sc_udev))
		return EIO;

	mididev->opened = 1;
	mididev->flags = flags;
	if ((mididev->flags & FWRITE) && mididev->out_jack)
		open_out_jack(mididev->out_jack, arg, ointr);
	if ((mididev->flags & FREAD) && mididev->in_jack)
		open_in_jack(mididev->in_jack, arg, iintr);
	return 0;
}

void
umidi_close(void *addr)
{
	int s;
	struct umidi_mididev *mididev = addr;

	s = splusb();
	if ((mididev->flags & FWRITE) && mididev->out_jack)
		close_jack(mididev->out_jack);
	if ((mididev->flags & FREAD) && mididev->in_jack)
		close_jack(mididev->in_jack);
	mididev->opened = 0;
	splx(s);
}

int
umidi_output(void *addr, int d)
{
	struct umidi_mididev *mididev = addr;

	if (!mididev->out_jack || !mididev->opened)
		return 1;

	return out_jack_output(mididev->out_jack, d);
}

void
umidi_flush(void *addr)
{
	struct umidi_mididev *mididev = addr;

	if (!mididev->out_jack || !mididev->opened)
		return;

	return out_jack_flush(mididev->out_jack);
}

void
umidi_getinfo(void *addr, struct midi_info *mi)
{
	struct umidi_mididev *mididev = addr;

	mi->name = "USB MIDI I/F"; /* XXX: model name */
	mi->props = MIDI_PROP_OUT_INTR;
	if (mididev->in_jack)
		mi->props |= MIDI_PROP_CAN_INPUT;
}


/*
 * each endpoint stuffs
 */

/* alloc/free pipe */
static usbd_status
alloc_pipe(struct umidi_endpoint *ep)
{
	struct umidi_softc *sc = ep->sc;
	usbd_status err;

	DPRINTF(("%s: alloc_pipe %p\n", sc->sc_dev.dv_xname, ep));
	SIMPLEQ_INIT(&ep->intrq);
	ep->pending = 0;
	ep->busy = 0;
	ep->used = 0;
	ep->xfer = usbd_alloc_xfer(sc->sc_udev);
	if (ep->xfer == NULL)
		return USBD_NOMEM;
	ep->buffer = usbd_alloc_buffer(ep->xfer, ep->packetsize);
	if (ep->buffer == NULL) {
		usbd_free_xfer(ep->xfer);
		return USBD_NOMEM;
	}
	err = usbd_open_pipe(sc->sc_iface, ep->addr, 0, &ep->pipe);
	if (err != USBD_NORMAL_COMPLETION) {
		usbd_free_xfer(ep->xfer);
		return err;
	}
	return USBD_NORMAL_COMPLETION;
}

static void
free_pipe(struct umidi_endpoint *ep)
{
	DPRINTF(("%s: %s %p\n", ep->sc->sc_dev.dv_xname, __func__, ep));
	usbd_abort_pipe(ep->pipe);
	usbd_close_pipe(ep->pipe);
	usbd_free_xfer(ep->xfer);
}


/* alloc/free the array of endpoint structures */

static usbd_status alloc_all_endpoints_fixed_ep(struct umidi_softc *);
static usbd_status alloc_all_endpoints_yamaha(struct umidi_softc *);
static usbd_status alloc_all_endpoints_genuine(struct umidi_softc *);

static usbd_status
alloc_all_endpoints(struct umidi_softc *sc)
{
	usbd_status err;
	struct umidi_endpoint *ep;
	int i;

	if (UMQ_ISTYPE(sc, UMQ_TYPE_FIXED_EP))
		err = alloc_all_endpoints_fixed_ep(sc);
	else if (UMQ_ISTYPE(sc, UMQ_TYPE_YAMAHA))
		err = alloc_all_endpoints_yamaha(sc);
	else
		err = alloc_all_endpoints_genuine(sc);
	if (err!=USBD_NORMAL_COMPLETION)
		return err;

	ep = sc->sc_endpoints;
	for (i=sc->sc_out_num_endpoints+sc->sc_in_num_endpoints; i>0; i--) {
		err = alloc_pipe(ep);
		if (err!=USBD_NORMAL_COMPLETION) {
			while(ep != sc->sc_endpoints) {
				ep--;
				free_pipe(ep);
			}
			free(sc->sc_endpoints, M_USBDEV, 0);
			sc->sc_endpoints = sc->sc_out_ep = sc->sc_in_ep = NULL;
			break;
		}
		ep++;
	}
	return err;
}

static void
free_all_endpoints(struct umidi_softc *sc)
{
	int i;

	for (i=0; i<sc->sc_in_num_endpoints+sc->sc_out_num_endpoints; i++)
	    free_pipe(&sc->sc_endpoints[i]);
	if (sc->sc_endpoints != NULL)
		free(sc->sc_endpoints, M_USBDEV, 0);
	sc->sc_endpoints = sc->sc_out_ep = sc->sc_in_ep = NULL;
}

static usbd_status
alloc_all_endpoints_fixed_ep(struct umidi_softc *sc)
{
	usbd_status err;
	struct umq_fixed_ep_desc *fp;
	struct umidi_endpoint *ep;
	usb_endpoint_descriptor_t *epd;
	int i;

	fp = umidi_get_quirk_data_from_type(sc->sc_quirk,
					    UMQ_TYPE_FIXED_EP);
	sc->sc_out_num_jacks = 0;
	sc->sc_in_num_jacks = 0;
	sc->sc_out_num_endpoints = fp->num_out_ep;
	sc->sc_in_num_endpoints = fp->num_in_ep;
	sc->sc_endpoints = mallocarray(sc->sc_out_num_endpoints +
	    sc->sc_in_num_endpoints, sizeof(*sc->sc_out_ep), M_USBDEV,
	    M_WAITOK | M_CANFAIL);
	if (!sc->sc_endpoints)
		return USBD_NOMEM;
	sc->sc_out_ep = sc->sc_out_num_endpoints ? sc->sc_endpoints : NULL;
	sc->sc_in_ep =
	    sc->sc_in_num_endpoints ?
		sc->sc_endpoints+sc->sc_out_num_endpoints : NULL;

	ep = &sc->sc_out_ep[0];
	for (i=0; i<sc->sc_out_num_endpoints; i++) {
		epd = usbd_interface2endpoint_descriptor(
			sc->sc_iface,
			fp->out_ep[i].ep);
		if (!epd) {
			DPRINTF(("%s: cannot get endpoint descriptor(out:%d)\n",
			       sc->sc_dev.dv_xname, fp->out_ep[i].ep));
			err = USBD_INVAL;
			goto error;
		}
		if (UE_GET_XFERTYPE(epd->bmAttributes)!=UE_BULK ||
		    UE_GET_DIR(epd->bEndpointAddress)!=UE_DIR_OUT) {
			printf("%s: illegal endpoint(out:%d)\n",
			       sc->sc_dev.dv_xname, fp->out_ep[i].ep);
			err = USBD_INVAL;
			goto error;
		}
		ep->sc = sc;
		ep->packetsize = UGETW(epd->wMaxPacketSize);
		ep->addr = epd->bEndpointAddress;
		ep->num_jacks = fp->out_ep[i].num_jacks;
		sc->sc_out_num_jacks += fp->out_ep[i].num_jacks;
		ep->num_open = 0;
		memset(ep->jacks, 0, sizeof(ep->jacks));
		ep++;
	}
	ep = &sc->sc_in_ep[0];
	for (i=0; i<sc->sc_in_num_endpoints; i++) {
		epd = usbd_interface2endpoint_descriptor(
			sc->sc_iface,
			fp->in_ep[i].ep);
		if (!epd) {
			DPRINTF(("%s: cannot get endpoint descriptor(in:%d)\n",
			       sc->sc_dev.dv_xname, fp->in_ep[i].ep));
			err = USBD_INVAL;
			goto error;
		}
		if (UE_GET_XFERTYPE(epd->bmAttributes)!=UE_BULK ||
		    UE_GET_DIR(epd->bEndpointAddress)!=UE_DIR_IN) {
			printf("%s: illegal endpoint(in:%d)\n",
			       sc->sc_dev.dv_xname, fp->in_ep[i].ep);
			err = USBD_INVAL;
			goto error;
		}
		ep->sc = sc;
		ep->addr = epd->bEndpointAddress;
		ep->packetsize = UGETW(epd->wMaxPacketSize);
		ep->num_jacks = fp->in_ep[i].num_jacks;
		sc->sc_in_num_jacks += fp->in_ep[i].num_jacks;
		ep->num_open = 0;
		memset(ep->jacks, 0, sizeof(ep->jacks));
		ep++;
	}

	return USBD_NORMAL_COMPLETION;
error:
	free(sc->sc_endpoints, M_USBDEV, 0);
	sc->sc_endpoints = NULL;
	return err;
}

static usbd_status
alloc_all_endpoints_yamaha(struct umidi_softc *sc)
{
	/* This driver currently supports max 1in/1out bulk endpoints */
	usb_descriptor_t *desc;
	usb_endpoint_descriptor_t *epd;
	int out_addr, in_addr, in_packetsize, i, dir;
	size_t remain, descsize;

	sc->sc_out_num_jacks = sc->sc_in_num_jacks = 0;
	out_addr = in_addr = 0;

	/* detect endpoints */
	desc = TO_D(usbd_get_interface_descriptor(sc->sc_iface));
	for (i=(int)TO_IFD(desc)->bNumEndpoints-1; i>=0; i--) {
		epd = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (UE_GET_XFERTYPE(epd->bmAttributes) == UE_BULK) {
			dir = UE_GET_DIR(epd->bEndpointAddress);
			if (dir==UE_DIR_OUT && !out_addr)
				out_addr = epd->bEndpointAddress;
			else if (dir==UE_DIR_IN && !in_addr) {
				in_addr = epd->bEndpointAddress;
				in_packetsize = UGETW(epd->wMaxPacketSize);
			}
		}
	}
	desc = NEXT_D(desc);

	/* count jacks */
	if (!(desc->bDescriptorType==UDESC_CS_INTERFACE &&
	      desc->bDescriptorSubtype==UMIDI_MS_HEADER))
		return USBD_INVAL;
	remain = (size_t)UGETW(TO_CSIFD(desc)->wTotalLength) -
		(size_t)desc->bLength;
	desc = NEXT_D(desc);

	while (remain>=sizeof(usb_descriptor_t)) {
		descsize = desc->bLength;
		if (descsize>remain || descsize==0)
			break;
		if (desc->bDescriptorType==UDESC_CS_INTERFACE &&
		    remain>=UMIDI_JACK_DESCRIPTOR_SIZE) {
			if (desc->bDescriptorSubtype==UMIDI_OUT_JACK)
				sc->sc_out_num_jacks++;
			else if (desc->bDescriptorSubtype==UMIDI_IN_JACK)
				sc->sc_in_num_jacks++;
		}
		desc = NEXT_D(desc);
		remain-=descsize;
	}

	/* validate some parameters */
	if (sc->sc_out_num_jacks>UMIDI_MAX_EPJACKS)
		sc->sc_out_num_jacks = UMIDI_MAX_EPJACKS;
	if (sc->sc_in_num_jacks>UMIDI_MAX_EPJACKS)
		sc->sc_in_num_jacks = UMIDI_MAX_EPJACKS;
	if (sc->sc_out_num_jacks && out_addr)
		sc->sc_out_num_endpoints = 1;
	else {
		sc->sc_out_num_endpoints = 0;
		sc->sc_out_num_jacks = 0;
	}
	if (sc->sc_in_num_jacks && in_addr)
		sc->sc_in_num_endpoints = 1;
	else {
		sc->sc_in_num_endpoints = 0;
		sc->sc_in_num_jacks = 0;
	}
	sc->sc_endpoints = mallocarray(sc->sc_out_num_endpoints +
	    sc->sc_in_num_endpoints, sizeof(struct umidi_endpoint),
	    M_USBDEV, M_WAITOK | M_CANFAIL);
	if (!sc->sc_endpoints)
		return USBD_NOMEM;
	if (sc->sc_out_num_endpoints) {
		sc->sc_out_ep = sc->sc_endpoints;
		sc->sc_out_ep->sc = sc;
		sc->sc_out_ep->addr = out_addr;
		sc->sc_out_ep->packetsize = UGETW(epd->wMaxPacketSize);
		sc->sc_out_ep->num_jacks = sc->sc_out_num_jacks;
		sc->sc_out_ep->num_open = 0;
		memset(sc->sc_out_ep->jacks, 0, sizeof(sc->sc_out_ep->jacks));
	} else
		sc->sc_out_ep = NULL;

	if (sc->sc_in_num_endpoints) {
		sc->sc_in_ep = sc->sc_endpoints+sc->sc_out_num_endpoints;
		sc->sc_in_ep->sc = sc;
		sc->sc_in_ep->addr = in_addr;
		sc->sc_in_ep->packetsize = in_packetsize;
		sc->sc_in_ep->num_jacks = sc->sc_in_num_jacks;
		sc->sc_in_ep->num_open = 0;
		memset(sc->sc_in_ep->jacks, 0, sizeof(sc->sc_in_ep->jacks));
	} else
		sc->sc_in_ep = NULL;

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
alloc_all_endpoints_genuine(struct umidi_softc *sc)
{
	usb_interface_descriptor_t *interface_desc;
	usb_config_descriptor_t *config_desc;
	usb_descriptor_t *desc;
	size_t remain, descsize;
	struct umidi_endpoint *p, *q, *lowest, *endep, tmpep;
	int epaddr, eppacketsize, num_ep;

	interface_desc = usbd_get_interface_descriptor(sc->sc_iface);
	num_ep = interface_desc->bNumEndpoints;
	sc->sc_endpoints = p = mallocarray(num_ep,
	    sizeof(struct umidi_endpoint), M_USBDEV, M_WAITOK | M_CANFAIL);
	if (!p)
		return USBD_NOMEM;

	sc->sc_out_num_jacks = sc->sc_in_num_jacks = 0;
	sc->sc_out_num_endpoints = sc->sc_in_num_endpoints = 0;
	epaddr = -1;

	/* get the list of endpoints for midi stream */
	config_desc = usbd_get_config_descriptor(sc->sc_udev);
	desc = (usb_descriptor_t *) config_desc;
	remain = (size_t)UGETW(config_desc->wTotalLength);
	while (remain>=sizeof(usb_descriptor_t)) {
		descsize = desc->bLength;
		if (descsize>remain || descsize==0)
			break;
		if (desc->bDescriptorType==UDESC_ENDPOINT &&
		    remain>=USB_ENDPOINT_DESCRIPTOR_SIZE &&
		    UE_GET_XFERTYPE(TO_EPD(desc)->bmAttributes) == UE_BULK) {
			epaddr = TO_EPD(desc)->bEndpointAddress;
			eppacketsize = UGETW(TO_EPD(desc)->wMaxPacketSize);
		} else if (desc->bDescriptorType==UDESC_CS_ENDPOINT &&
			   remain>=UMIDI_CS_ENDPOINT_DESCRIPTOR_SIZE &&
			   epaddr!=-1) {
			if (num_ep>0) {
				num_ep--;
				p->sc = sc;
				p->addr = epaddr;
				p->packetsize = eppacketsize;
				p->num_jacks = TO_CSEPD(desc)->bNumEmbMIDIJack;
				if (UE_GET_DIR(epaddr)==UE_DIR_OUT) {
					sc->sc_out_num_endpoints++;
					sc->sc_out_num_jacks += p->num_jacks;
				} else {
					sc->sc_in_num_endpoints++;
					sc->sc_in_num_jacks += p->num_jacks;
				}
				p++;
			}
		} else
			epaddr = -1;
		desc = NEXT_D(desc);
		remain-=descsize;
	}

	/* sort endpoints */
	num_ep = sc->sc_out_num_endpoints + sc->sc_in_num_endpoints;
	p = sc->sc_endpoints;
	endep = p + num_ep;
	while (p<endep) {
		lowest = p;
		for (q=p+1; q<endep; q++) {
			if ((UE_GET_DIR(lowest->addr)==UE_DIR_IN &&
			     UE_GET_DIR(q->addr)==UE_DIR_OUT) ||
			    ((UE_GET_DIR(lowest->addr)==
			      UE_GET_DIR(q->addr)) &&
			     (UE_GET_ADDR(lowest->addr)>
			      UE_GET_ADDR(q->addr))))
				lowest = q;
		}
		if (lowest != p) {
			memcpy((void *)&tmpep, (void *)p, sizeof(tmpep));
			memcpy((void *)p, (void *)lowest, sizeof(tmpep));
			memcpy((void *)lowest, (void *)&tmpep, sizeof(tmpep));
		}
		p->num_open = 0;
		p++;
	}

	sc->sc_out_ep = sc->sc_out_num_endpoints ? sc->sc_endpoints : NULL;
	sc->sc_in_ep =
	    sc->sc_in_num_endpoints ?
		sc->sc_endpoints+sc->sc_out_num_endpoints : NULL;

	return USBD_NORMAL_COMPLETION;
}


/*
 * jack stuffs
 */

static usbd_status
alloc_all_jacks(struct umidi_softc *sc)
{
	int i, j;
	struct umidi_endpoint *ep;
	struct umidi_jack *jack, **rjack;

	/* allocate/initialize structures */
	sc->sc_jacks = mallocarray(sc->sc_in_num_jacks + sc->sc_out_num_jacks,
	    sizeof(*sc->sc_out_jacks), M_USBDEV, M_WAITOK | M_CANFAIL);
	if (!sc->sc_jacks)
		return USBD_NOMEM;
	sc->sc_out_jacks =
	    sc->sc_out_num_jacks ? sc->sc_jacks : NULL;
	sc->sc_in_jacks =
	    sc->sc_in_num_jacks ? sc->sc_jacks+sc->sc_out_num_jacks : NULL;

	jack = &sc->sc_out_jacks[0];
	for (i=0; i<sc->sc_out_num_jacks; i++) {
		jack->opened = 0;
		jack->binded = 0;
		jack->arg = NULL;
		jack->u.out.intr = NULL;
		jack->intr = 0;
		jack->cable_number = i;
		jack++;
	}
	jack = &sc->sc_in_jacks[0];
	for (i=0; i<sc->sc_in_num_jacks; i++) {
		jack->opened = 0;
		jack->binded = 0;
		jack->arg = NULL;
		jack->u.in.intr = NULL;
		jack->cable_number = i;
		jack++;
	}

	/* assign each jacks to each endpoints */
	jack = &sc->sc_out_jacks[0];
	ep = &sc->sc_out_ep[0];
	for (i=0; i<sc->sc_out_num_endpoints; i++) {
		rjack = &ep->jacks[0];
		for (j=0; j<ep->num_jacks; j++) {
			*rjack = jack;
			jack->endpoint = ep;
			jack++;
			rjack++;
		}
		ep++;
	}
	jack = &sc->sc_in_jacks[0];
	ep = &sc->sc_in_ep[0];
	for (i=0; i<sc->sc_in_num_endpoints; i++) {
		rjack = &ep->jacks[0];
		for (j=0; j<ep->num_jacks; j++) {
			*rjack = jack;
			jack->endpoint = ep;
			jack++;
			rjack++;
		}
		ep++;
	}

	return USBD_NORMAL_COMPLETION;
}

static void
free_all_jacks(struct umidi_softc *sc)
{
	int s;

	s = splusb();
	if (sc->sc_out_jacks) {
		free(sc->sc_jacks, M_USBDEV, 0);
		sc->sc_jacks = sc->sc_in_jacks = sc->sc_out_jacks = NULL;
	}
	splx(s);
}

static usbd_status
bind_jacks_to_mididev(struct umidi_softc *sc,
		      struct umidi_jack *out_jack,
		      struct umidi_jack *in_jack,
		      struct umidi_mididev *mididev)
{
	if ((out_jack && out_jack->binded) || (in_jack && in_jack->binded))
		return USBD_IN_USE;
	if (mididev->out_jack || mididev->in_jack)
		return USBD_IN_USE;

	if (out_jack)
		out_jack->binded = 1;
	if (in_jack)
		in_jack->binded = 1;
	mididev->in_jack = in_jack;
	mididev->out_jack = out_jack;

	return USBD_NORMAL_COMPLETION;
}

static void
unbind_jacks_from_mididev(struct umidi_mididev *mididev)
{
	if ((mididev->flags & FWRITE) && mididev->out_jack)
		close_jack(mididev->out_jack);
	if ((mididev->flags & FREAD) && mididev->in_jack)
		close_jack(mididev->in_jack);

	if (mididev->out_jack)
		mididev->out_jack->binded = 0;
	if (mididev->in_jack)
		mididev->in_jack->binded = 0;
	mididev->out_jack = mididev->in_jack = NULL;
}

static void
unbind_all_jacks(struct umidi_softc *sc)
{
	int i;

	if (sc->sc_mididevs)
		for (i=0; i<sc->sc_num_mididevs; i++) {
			unbind_jacks_from_mididev(&sc->sc_mididevs[i]);
		}
}

static usbd_status
assign_all_jacks_automatically(struct umidi_softc *sc)
{
	usbd_status err;
	int i;
	struct umidi_jack *out, *in;

	err =
	    alloc_all_mididevs(sc,
			       max(sc->sc_out_num_jacks, sc->sc_in_num_jacks));
	if (err!=USBD_NORMAL_COMPLETION)
		return err;

	for (i=0; i<sc->sc_num_mididevs; i++) {
		out = (i<sc->sc_out_num_jacks) ? &sc->sc_out_jacks[i]:NULL;
		in = (i<sc->sc_in_num_jacks) ? &sc->sc_in_jacks[i]:NULL;
		err = bind_jacks_to_mididev(sc, out, in, &sc->sc_mididevs[i]);
		if (err!=USBD_NORMAL_COMPLETION) {
			free_all_mididevs(sc);
			return err;
		}
	}

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
open_out_jack(struct umidi_jack *jack, void *arg, void (*intr)(void *))
{
	if (jack->opened)
		return USBD_IN_USE;

	jack->arg = arg;
	jack->u.out.intr = intr;
	init_packet(&jack->packet);
	jack->opened = 1;
	jack->endpoint->num_open++;
	
	return USBD_NORMAL_COMPLETION;
}

static usbd_status
open_in_jack(struct umidi_jack *jack, void *arg, void (*intr)(void *, int))
{
	if (jack->opened)
		return USBD_IN_USE;

	jack->arg = arg;
	jack->u.in.intr = intr;
	jack->opened = 1;
	jack->endpoint->num_open++;	
	
	return USBD_NORMAL_COMPLETION;
}

static void
close_jack(struct umidi_jack *jack)
{
	if (jack->opened) {
		jack->opened = 0;
		jack->endpoint->num_open--;
	}
}

static usbd_status
attach_mididev(struct umidi_softc *sc, struct umidi_mididev *mididev)
{
	if (mididev->sc)
		return USBD_IN_USE;

	mididev->sc = sc;

	mididev->mdev = midi_attach_mi(&umidi_hw_if, mididev, &sc->sc_dev);

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
detach_mididev(struct umidi_mididev *mididev, int flags)
{
	if (!mididev->sc)
		return USBD_NO_ADDR;

	if (mididev->opened)
		umidi_close(mididev);
	unbind_jacks_from_mididev(mididev);

	if (mididev->mdev)
		config_detach(mididev->mdev, flags);

	mididev->sc = NULL;

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
deactivate_mididev(struct umidi_mididev *mididev)
{
	if (mididev->out_jack)
		mididev->out_jack->binded = 0;
	if (mididev->in_jack)
		mididev->in_jack->binded = 0;
	config_deactivate(mididev->mdev);

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
alloc_all_mididevs(struct umidi_softc *sc, int nmidi)
{
	sc->sc_num_mididevs = nmidi;
	sc->sc_mididevs = mallocarray(nmidi, sizeof(*sc->sc_mididevs),
	    M_USBDEV, M_WAITOK | M_CANFAIL | M_ZERO);
	if (!sc->sc_mididevs)
		return USBD_NOMEM;

	return USBD_NORMAL_COMPLETION;
}

static void
free_all_mididevs(struct umidi_softc *sc)
{
	sc->sc_num_mididevs = 0;
	if (sc->sc_mididevs)
		free(sc->sc_mididevs, M_USBDEV, 0);
}

static usbd_status
attach_all_mididevs(struct umidi_softc *sc)
{
	usbd_status err;
	int i;

	if (sc->sc_mididevs)
		for (i=0; i<sc->sc_num_mididevs; i++) {
			err = attach_mididev(sc, &sc->sc_mididevs[i]);
			if (err!=USBD_NORMAL_COMPLETION)
				return err;
		}

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
detach_all_mididevs(struct umidi_softc *sc, int flags)
{
	usbd_status err;
	int i;

	if (sc->sc_mididevs)
		for (i=0; i<sc->sc_num_mididevs; i++) {
			err = detach_mididev(&sc->sc_mididevs[i], flags);
			if (err!=USBD_NORMAL_COMPLETION)
				return err;
		}

	return USBD_NORMAL_COMPLETION;
}

static usbd_status
deactivate_all_mididevs(struct umidi_softc *sc)
{
	usbd_status err;
	int i;

	if (sc->sc_mididevs)
		for (i=0; i<sc->sc_num_mididevs; i++) {
			err = deactivate_mididev(&sc->sc_mididevs[i]);
			if (err!=USBD_NORMAL_COMPLETION)
				return err;
		}

	return USBD_NORMAL_COMPLETION;
}

#ifdef UMIDI_DEBUG
static void
dump_sc(struct umidi_softc *sc)
{
	int i;

	DPRINTFN(10, ("%s: %s\n", sc->sc_dev.dv_xname, __func__));
	for (i=0; i<sc->sc_out_num_endpoints; i++) {
		DPRINTFN(10, ("\tout_ep(%p):\n", &sc->sc_out_ep[i]));
		dump_ep(&sc->sc_out_ep[i]);
	}
	for (i=0; i<sc->sc_in_num_endpoints; i++) {
		DPRINTFN(10, ("\tin_ep(%p):\n", &sc->sc_in_ep[i]));
		dump_ep(&sc->sc_in_ep[i]);
	}
}

static void
dump_ep(struct umidi_endpoint *ep)
{
	int i;
	for (i=0; i<ep->num_jacks; i++) {
		DPRINTFN(10, ("\t\tjack(%p):\n", ep->jacks[i]));
		dump_jack(ep->jacks[i]);
	}
}
static void
dump_jack(struct umidi_jack *jack)
{
	DPRINTFN(10, ("\t\t\tep=%p\n",
		      jack->endpoint));
}

#endif /* UMIDI_DEBUG */



/*
 * MUX MIDI PACKET
 */

static const int packet_length[16] = {
	/*0*/	-1,
	/*1*/	-1,
	/*2*/	2,
	/*3*/	3,
	/*4*/	3,
	/*5*/	1,
	/*6*/	2,
	/*7*/	3,
	/*8*/	3,
	/*9*/	3,
	/*A*/	3,
	/*B*/	3,
	/*C*/	2,
	/*D*/	2,
	/*E*/	3,
	/*F*/	1,
};

#define	GET_CN(p)		(((unsigned char)(p)>>4)&0x0F)
#define GET_CIN(p)		((unsigned char)(p)&0x0F)

static void
init_packet(struct umidi_packet *packet)
{
	packet->status = 0;
	packet->index = 0;
}

static usbd_status
start_input_transfer(struct umidi_endpoint *ep)
{
	usbd_status err;
	usbd_setup_xfer(ep->xfer, ep->pipe,
			(void *)ep,
			ep->buffer, ep->packetsize,
			USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT, in_intr);
	err = usbd_transfer(ep->xfer);
	if (err != USBD_NORMAL_COMPLETION && err != USBD_IN_PROGRESS) {
		DPRINTF(("%s: %s: usbd_transfer() failed err=%s\n", 
			ep->sc->sc_dev.dv_xname, __func__, usbd_errstr(err)));
		return err;
	}
	return USBD_NORMAL_COMPLETION;
}

static usbd_status
start_output_transfer(struct umidi_endpoint *ep)
{
	usbd_status err;
	usbd_setup_xfer(ep->xfer, ep->pipe,
			(void *)ep,
			ep->buffer, ep->used,
			USBD_NO_COPY, USBD_NO_TIMEOUT, out_intr);
	err = usbd_transfer(ep->xfer);
	if (err != USBD_NORMAL_COMPLETION && err != USBD_IN_PROGRESS) {
		DPRINTF(("%s: %s: usbd_transfer() failed err=%s\n", 
			ep->sc->sc_dev.dv_xname, __func__, usbd_errstr(err)));
		return err;
	}
	ep->used = ep->packetsize;
	return USBD_NORMAL_COMPLETION;
}


#ifdef UMIDI_DEBUG
#define DPR_PACKET(dir, sc, p)						\
	DPRINTFN(500,							\
		 ("%s: umidi packet(" #dir "): %02X %02X %02X %02X\n",	\
		  sc->sc_dev.dv_xname,				\
		  (unsigned char)(p)->buffer[0],			\
		  (unsigned char)(p)->buffer[1],			\
		  (unsigned char)(p)->buffer[2],			\
		  (unsigned char)(p)->buffer[3]));
#else
#define DPR_PACKET(dir, sc, p)
#endif

static int
out_jack_output(struct umidi_jack *j, int d)
{
	struct umidi_endpoint *ep = j->endpoint;
	struct umidi_softc *sc = ep->sc;
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return 1;
	if (!j->opened)
		return 1;
	s = splusb();
	if (ep->busy) {
		if (!j->intr) {
			SIMPLEQ_INSERT_TAIL(&ep->intrq, j, intrq_entry);
			ep->pending++;
			j->intr = 1;
		}		
		splx(s);
		return 0;
	}
	if (!out_build_packet(j->cable_number, &j->packet, d,
		ep->buffer + ep->used)) {
		splx(s);
		return 1;
	}
	ep->used += UMIDI_PACKET_SIZE;
	if (ep->used == ep->packetsize) {
		ep->busy = 1;
		start_output_transfer(ep);
	}
	splx(s);
	return 1;
}

static void
out_jack_flush(struct umidi_jack *j)
{
	struct umidi_endpoint *ep = j->endpoint;
	int s;

	if (usbd_is_dying(ep->sc->sc_udev) || !j->opened)
		return;
		
	s = splusb();	
	if (ep->used != 0 && !ep->busy) {
		ep->busy = 1;
		start_output_transfer(ep);
	}
	splx(s);
}


static void
in_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	int cn, evlen, remain, i;
	unsigned char *buf;
	struct umidi_endpoint *ep = (struct umidi_endpoint *)priv;
	struct umidi_jack *jack;

	if (usbd_is_dying(ep->sc->sc_udev))
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &remain, NULL);
	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("%s: abnormal status: %s\n", __func__, usbd_errstr(status)));
		return;
	}
	buf = ep->buffer;
	while (remain >= UMIDI_PACKET_SIZE) {
		cn = GET_CN(buf[0]);
		if (cn < ep->num_jacks && (jack = ep->jacks[cn]) &&
		    jack->binded && jack->opened &&  jack->u.in.intr) {
		    	evlen = packet_length[GET_CIN(buf[0])];
			mtx_enter(&audio_lock);
			for (i=0; i<evlen; i++)
				(*jack->u.in.intr)(jack->arg, buf[i+1]);
			mtx_leave(&audio_lock);
		}
		buf += UMIDI_PACKET_SIZE;
		remain -= UMIDI_PACKET_SIZE;
	}
	(void)start_input_transfer(ep);
}

static void
out_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct umidi_endpoint *ep = (struct umidi_endpoint *)priv;
	struct umidi_softc *sc = ep->sc;
	struct umidi_jack *j;
	unsigned pending;
	
	if (usbd_is_dying(sc->sc_udev))
		return;

	ep->used = 0;
	ep->busy = 0;
	for (pending = ep->pending; pending > 0; pending--) {
		j = SIMPLEQ_FIRST(&ep->intrq);
#ifdef DIAGNOSTIC
		if (j == NULL) {
			printf("umidi: missing intr entry\n");
			break;
		}
#endif
		SIMPLEQ_REMOVE_HEAD(&ep->intrq, intrq_entry);
		ep->pending--;
		j->intr = 0;
		mtx_enter(&audio_lock);
		if (j->opened && j->u.out.intr)
			(*j->u.out.intr)(j->arg);
		mtx_leave(&audio_lock);
	}
}

#define UMIDI_VOICELEN(status) 	(umidi_evlen[((status) >> 4) & 7])
static const unsigned int umidi_evlen[] = { 4, 4, 4, 4, 3, 3, 4 };

#define EV_SYSEX	0xf0
#define EV_MTC		0xf1
#define EV_SPP		0xf2
#define EV_SONGSEL	0xf3
#define EV_TUNE_REQ	0xf6
#define EV_SYSEX_STOP	0xf7

static int
out_build_packet(int cable_number, struct umidi_packet *packet, 
    uByte data, u_char *obuf)
{
	if (data >= 0xf8) {		/* is it a realtime message ? */
		obuf[0] = data >> 4 | cable_number << 4;
		obuf[1] = data;
		obuf[2] = 0;
		obuf[3] = 0;
		return 1;
	}
	if (data >= 0xf0) {		/* is it a common message ? */
		switch(data) {
		case EV_SYSEX:
			packet->buf[1] = packet->status = data;
			packet->index = 2;
			break;
		case EV_SYSEX_STOP:
			if (packet->status != EV_SYSEX) break;
			if (packet->index == 0)
				packet->index = 1; 
			packet->status = data;
			packet->buf[packet->index++] = data;
			packet->buf[0] = (0x4 - 1 + packet->index) | cable_number << 4;
			goto packetready;
		case EV_TUNE_REQ: 
			packet->status = data;
			packet->buf[0] = 0x5 | cable_number << 4;
			packet->index = 1;
			goto packetready;
		default:
			packet->status = data;
			break;
		}
		return 0;
	}	
	if (data >= 0x80) {		/* is it a voice message ? */
		packet->status = data;
		packet->index = 0;
		return 0;
	} 

	/* else it is a data byte */	
	if (packet->status >= 0xf0) {
		switch(packet->status) {
		case EV_SYSEX:		/* sysex starts or continues */
			if (packet->index == 0)
				packet->index = 1; 

			packet->buf[packet->index++] = data;
			if (packet->index >= UMIDI_PACKET_SIZE) {
				packet->buf[0] = 0x4 | cable_number << 4;
				goto packetready;
			}
			break;
		case EV_MTC:		/* messages with 1 data byte */
		case EV_SONGSEL:	
			packet->buf[0] = 0x2 | cable_number << 4;
			packet->buf[1] = packet->status;
			packet->buf[2] = data;
			packet->index = 3;
			goto packetready;
		case EV_SPP:		/* messages with 2 data bytes */
			if (packet->index == 0) {
				packet->buf[0] = 0x3 | cable_number << 4;
				packet->index = 1;
			}
			packet->buf[packet->index++] = data;
			if (packet->index >= UMIDI_PACKET_SIZE) {
				packet->buf[1] = packet->status;
				goto packetready;
			}
			break;
		default:		/* ignore data with unknown status */
			break;
		}
		return 0;
	}
	if (packet->status >= 0x80) {	/* is it a voice message ? */
		if (packet->index == 0) {
			packet->buf[0] = packet->status >> 4 | cable_number << 4;
			packet->buf[1] = packet->status;
			packet->index = 2;
		}
		packet->buf[packet->index++] = data;
		if (packet->index >= UMIDI_VOICELEN(packet->status))
			goto packetready;
	}
	/* ignore data with unknown status */
	return 0;
	
packetready:
	while (packet->index < UMIDI_PACKET_SIZE)
		packet->buf[packet->index++] = 0;
	packet->index = 0;
	memcpy(obuf, packet->buf, UMIDI_PACKET_SIZE);
	return 1;
}
@


1.43
log
@Remove unused MIX_CN_CIN macro, make umidi_evlen[] static, style(9).
From Michael W. Bombardieri. Thanks.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.42 2016/12/20 15:32:07 ratchov Exp $	*/
d152 1
a152 1
	DPRINTFN(1,("umidi_match\n"));
d177 1
a177 1
	DPRINTFN(1,("umidi_attach\n"));
d230 1
a230 1
		DPRINTFN(1,("umidi_activate (deactivate)\n"));
d242 1
a242 1
	DPRINTFN(1,("umidi_detach\n"));
d266 1
a266 1
	DPRINTF(("umidi_open: sc=%p\n", sc));
d368 1
a368 1
	DPRINTF(("%s: free_pipe %p\n", ep->sc->sc_dev.dv_xname, ep));
d1013 1
a1013 1
	DPRINTFN(10, ("%s: dump_sc\n", sc->sc_dev.dv_xname));
d1087 2
a1088 2
		DPRINTF(("%s: start_input_transfer: usbd_transfer() failed err=%s\n", 
			ep->sc->sc_dev.dv_xname, usbd_errstr(err)));
d1104 2
a1105 2
		DPRINTF(("%s: start_output_transfer: usbd_transfer() failed err=%s\n", 
			ep->sc->sc_dev.dv_xname, usbd_errstr(err)));
d1192 1
a1192 1
		DPRINTF(("in_intr: abnormal status: %s\n", usbd_errstr(status)));
@


1.42
log
@Group identical close_in_jack() and close_out_jack() into a single
routine. From Michael W. Bombardieri <mb at ii.net>. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.41 2015/03/14 03:38:50 jsg Exp $	*/
a186 1

d188 1
a188 1
	if (err!=USBD_NORMAL_COMPLETION) {
a189 1
	}
d216 1
a216 1
	for (i = 0; i < sc->sc_in_num_endpoints; i++) {
a217 2
	}

d229 1
a229 2
	switch (act) {
	case DVACT_DEACTIVATE:
a232 1
		break;
d279 1
a279 1
	if ((mididev->flags & FREAD) && mididev->in_jack) {
a280 2
	}

d350 1
a350 1
	if (ep->xfer == NULL) {
a351 1
	}
d388 1
a388 1
	if (UMQ_ISTYPE(sc, UMQ_TYPE_FIXED_EP)) {
d390 1
a390 1
	} else if (UMQ_ISTYPE(sc, UMQ_TYPE_YAMAHA)) {
d392 1
a392 1
	} else {
a393 1
	}
d418 1
d444 1
a444 1
	if (!sc->sc_endpoints) {
a445 1
	}
d519 1
a519 2
	int out_addr, in_addr, in_packetsize, i;
	int dir;
d569 1
a569 1
	if (sc->sc_out_num_jacks && out_addr) {
d571 1
a571 1
	} else {
d575 1
a575 1
	if (sc->sc_in_num_jacks && in_addr) {
d577 1
a577 1
	} else {
a616 1
	int num_ep;
d619 1
a619 1
	int epaddr, eppacketsize;
d915 1
a915 1
	if (mididev->opened) {
a916 1
	}
a1068 3
#define MIX_CN_CIN(cn, cin) \
	((unsigned char)((((unsigned char)(cn)&0x0F)<<4)| \
			  ((unsigned char)(cin)&0x0F)))
d1244 1
a1244 1
unsigned umidi_evlen[] = { 4, 4, 4, 4, 3, 3, 4 };
@


1.41
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.40 2014/12/09 07:05:06 doug Exp $	*/
d91 1
a91 2
static void close_out_jack(struct umidi_jack *);
static void close_in_jack(struct umidi_jack *);
d300 1
a300 1
		close_out_jack(mididev->out_jack);
d302 1
a302 1
		close_in_jack(mididev->in_jack);
d822 1
a822 1
		close_out_jack(mididev->out_jack);
d824 1
a824 1
		close_in_jack(mididev->in_jack);
d900 1
a900 1
close_out_jack(struct umidi_jack *jack)
a904 9
	}
}

static void
close_in_jack(struct umidi_jack *jack)
{
	if (jack->opened) {
		jack->opened = 0;
		jack->endpoint->num_open--;	
@


1.40
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.39 2014/07/12 18:48:52 tedu Exp $	*/
a46 1
#include <dev/usb/usbdevs.h>
@


1.39
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.38 2013/11/10 10:22:39 pirofti Exp $	*/
d452 3
a454 4
	sc->sc_endpoints = malloc(sizeof(*sc->sc_out_ep)*
				  (sc->sc_out_num_endpoints+
				   sc->sc_in_num_endpoints),
				  M_USBDEV, M_WAITOK | M_CANFAIL);
d594 3
a596 4
	sc->sc_endpoints = malloc(sizeof(struct umidi_endpoint)*
				  (sc->sc_out_num_endpoints+
				   sc->sc_in_num_endpoints),
				  M_USBDEV, M_WAITOK | M_CANFAIL);
d637 2
a638 2
	sc->sc_endpoints = p = malloc(sizeof(struct umidi_endpoint) * num_ep,
				      M_USBDEV, M_WAITOK | M_CANFAIL);
d728 2
a729 4
	sc->sc_jacks =
	    malloc(sizeof(*sc->sc_out_jacks)*(sc->sc_in_num_jacks+
					      sc->sc_out_num_jacks),
		   M_USBDEV, M_WAITOK | M_CANFAIL);
d967 2
a968 2
	sc->sc_mididevs = malloc(sizeof(*sc->sc_mididevs)*nmidi, M_USBDEV,
	    M_WAITOK | M_CANFAIL | M_ZERO);
@


1.38
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.37 2013/05/15 08:29:26 ratchov Exp $	*/
d417 1
a417 1
			free(sc->sc_endpoints, M_USBDEV);
d433 1
a433 1
		free(sc->sc_endpoints, M_USBDEV);
d521 1
a521 1
	free(sc->sc_endpoints, M_USBDEV);
d797 1
a797 1
		free(sc->sc_jacks, M_USBDEV);
d984 1
a984 1
		free(sc->sc_mididevs, M_USBDEV);
@


1.37
log
@Introduce a global interrupt-aware mutex protecting data
structures (including sound-card registers) from concurent
access by syscall and interrupt code-paths. Since critical
sections remain the same, calls to splraise/spllower can be
safely replaced by calls to mtx_enter/mtx_leave with two
exceptions: (1) mutexes are not reentrant (the inner splraise
is thus removed), and (2) we're not allowed to sleep with a
mutex (either msleep is used or the mutex is released before
sleeping).

ok and help from kettenis, a lot of work from armani
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.36 2013/04/15 09:23:02 mglocker Exp $	*/
d227 1
a227 1
	sc->sc_dying = 1;
d238 1
a238 1
		sc->sc_dying = 1;
d280 1
a280 1
	if (sc->sc_dying)
d1164 1
a1164 1
	if (sc->sc_dying)
d1198 1
a1198 1
	if (ep->sc->sc_dying || !j->opened)
d1218 1
a1218 1
	if (ep->sc->sc_dying)
d1251 1
a1251 1
	if (sc->sc_dying)
@


1.36
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.35 2013/03/28 03:58:03 tedu Exp $	*/
d53 1
d795 1
a795 1
	s = splaudio();
d1232 1
d1235 1
d1267 1
d1270 1
@


1.35
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.34 2013/03/28 03:31:55 tedu Exp $	*/
d116 2
a117 2
static void in_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
static void out_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d1112 1
a1112 1
			(usbd_private_handle)ep,
d1129 1
a1129 1
			(usbd_private_handle)ep,
d1210 1
a1210 1
in_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1241 1
a1241 1
out_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.34
log
@you probably don't need to include vnode.h or reboot.h. you most definitely
absolutely do not need to include vnode.h because it includes uvm_extern.h
and you want the idiotic TRUE FALSE defines from uvm.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.33 2012/03/30 08:18:19 ratchov Exp $	*/
a40 1
#include <sys/proc.h>
@


1.33
log
@If the MIDI UART is not ready for output, don't spin at IPL_CLOCK;
just return and make the midi(4) driver retry later. UART buffers
are large enough for this, except eap(4) which uses interrupts for
output.
help from and ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.32 2011/07/03 15:47:17 matthew Exp $	*/
a41 1
#include <sys/vnode.h>
@


1.32
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.31 2011/06/23 23:04:28 oga Exp $	*/
d316 1
a316 1
		return EIO;
d748 1
a748 3
#ifdef DIAGNOSTIC
		jack->wait = 0;
#endif
d1166 1
a1166 1
		return EIO;
d1168 1
a1168 2
		return ENODEV;
		
d1170 2
a1171 5
	if (ep->used == ep->packetsize) {
#ifdef DIAGNOSTIC
		if (j->wait == 0) {
			j->wait = 1;
#endif
d1174 2
a1175 6
#ifdef DIAGNOSTIC
		} else {
			printf("umidi: (again) %d: already on intrq\n", 
			    j->cable_number);
		}
#endif
d1177 1
a1177 1
		return EAGAIN;
d1179 2
a1180 3
	
	if (!out_build_packet(j->cable_number, &j->packet, d, 
	    ep->buffer + ep->used)) {
d1182 1
a1182 1
		return EINPROGRESS;
d1185 1
a1185 17
	if (ep->used < ep->packetsize) {
		splx(s);
		return EINPROGRESS;
	}
#ifdef DIAGNOSTIC
	if (j->wait == 0) {
		j->wait = 1;		
#endif
		SIMPLEQ_INSERT_TAIL(&ep->intrq, j, intrq_entry);
		ep->pending++;
#ifdef DIAGNOSTIC
	} else {
		printf("umidi: (ok) %d: already on intrq\n", 
		    j->cable_number);
	}
#endif
	if (!ep->busy) {
d1190 1
a1190 1
	return 0;
d1254 1
d1265 1
a1265 3
#ifdef DIAGNOSTIC
		j->wait = 0;
#endif
a1267 6
	}

	if (ep->used == 0) {
		ep->busy = 0;
	} else {
		start_output_transfer(ep);
@


1.31
log
@Back out inadvertently commited change.

This one wanted some more comments before commit.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.29 2011/06/17 07:06:47 mk Exp $	*/
a236 3
	case DVACT_ACTIVATE:
		DPRINTFN(1,("umidi_activate (activate)\n"));
		break;
@


1.30
log
@Don't leak the ctrl_data in uvideo_queryctrl, uvideo_s_ctrl and uvideo_g_ctrl.

If one of the usb calls we did here failed we'd return immediately and
not free our buffer.

ok miod@@
@
text
@d87 1
d197 2
a198 1
		goto free_ends;
d206 4
a209 1
		goto free_jacks;
d213 2
a214 2
		/* XXX what about the mididevs that attached? */
		goto free_mididevs;
a225 7

free_mididevs:
	free_all_mididevs(sc);
free_jacks:
	free_all_jacks(sc);
free_ends:
	free_all_endpoints(sc);
d411 1
a411 1
		free(sc->sc_endpoints, M_USBDEV);
d845 11
d997 1
a997 1
	int i, j;
d1003 1
a1003 1
				goto detach;
a1006 5
detach:

	for (j = 0; j < i; j++)
		(void)detach_mididev(&sc->sc_mididevs[i], DETACH_QUIET);
	return err;
@


1.29
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.28 2011/01/25 20:03:36 jakemsr Exp $	*/
a86 1
static void unbind_all_jacks(struct umidi_softc *);
d196 1
a196 2
		free_all_endpoints(sc);
		goto error;
d204 1
a204 4
		unbind_all_jacks(sc);
		free_all_jacks(sc);
		free_all_endpoints(sc);
		goto error;
d208 2
a209 2
		free_all_jacks(sc);
		free_all_endpoints(sc);
d221 7
d413 1
a413 1
		return err;
a846 11
static void
unbind_all_jacks(struct umidi_softc *sc)
{
	int i;

	if (sc->sc_mididevs)
		for (i=0; i<sc->sc_num_mididevs; i++) {
			unbind_jacks_from_mididev(&sc->sc_mididevs[i]);
		}
}

d988 1
a988 1
	int i;
d994 1
a994 1
				return err;
d998 5
@


1.28
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.27 2010/09/24 08:33:59 yuo Exp $	*/
d459 1
a459 1
				  M_USBDEV, M_WAITOK);
d602 1
a602 1
				  M_USBDEV, M_WAITOK);
d644 1
a644 1
				      M_USBDEV, M_WAITOK);
d737 1
a737 1
		   M_USBDEV, M_WAITOK);
d978 1
a978 1
	    M_WAITOK | M_ZERO);
@


1.27
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.26 2009/10/13 19:33:19 pirofti Exp $	*/
a224 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH,
			   sc->sc_udev, &sc->sc_dev);

a259 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.26
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.25 2008/06/26 05:42:19 ray Exp $	*/
a258 1
	sc->sc_dying = 1;
@


1.25
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.24 2007/10/11 18:33:15 deraadt Exp $	*/
d135 1
a135 1
int umidi_activate(struct device *, enum devact); 
d235 1
a235 1
umidi_activate(struct device *self, enum devact act)
@


1.24
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.23 2007/10/06 23:50:55 krw Exp $	*/
a17 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	  This product includes software developed by the NetBSD
 *	  Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.23
log
@Simpliest memset(,0,) -> M_ZERO changes. One (caddr *) cast removal,
otherwise just adding M_ZERO to malloc() and removing the immediately
adjacent memset(,0,).
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.22 2007/06/14 10:11:16 mbalmer Exp $	*/
a184 1
	char *devinfop;
a187 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.22
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.21 2007/06/12 16:26:36 mbalmer Exp $	*/
d996 2
a997 2
	sc->sc_mididevs = malloc(sizeof(*sc->sc_mididevs)*nmidi,
				 M_USBDEV, M_WAITOK);
a999 1
	memset(sc->sc_mididevs, 0, sizeof(*sc->sc_mididevs)*nmidi);
@


1.21
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.20 2007/06/10 14:49:01 mbalmer Exp $	*/
d139 16
a154 1
USB_DECLARE_DRIVER(umidi);
@


1.20
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.19 2007/06/10 10:53:48 mbalmer Exp $	*/
d232 1
a232 1
umidi_activate(device_ptr_t self, enum devact act)
@


1.19
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.18 2007/05/27 04:00:25 jsg Exp $	*/
d176 1
a176 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d184 1
a184 1
	printf("%s: ", USBDEVNAME(sc->sc_dev));
d198 1
a198 1
	       USBDEVNAME(sc->sc_dev),
d227 1
a227 1
	printf("%s: disabled.\n", USBDEVNAME(sc->sc_dev));
d362 1
a362 1
	DPRINTF(("%s: alloc_pipe %p\n", USBDEVNAME(sc->sc_dev), ep));
d387 1
a387 1
	DPRINTF(("%s: free_pipe %p\n", USBDEVNAME(ep->sc->sc_dev), ep));
d479 1
a479 1
			       USBDEVNAME(sc->sc_dev), fp->out_ep[i].ep));
d486 1
a486 1
			       USBDEVNAME(sc->sc_dev), fp->out_ep[i].ep);
d506 1
a506 1
			       USBDEVNAME(sc->sc_dev), fp->in_ep[i].ep));
d513 1
a513 1
			       USBDEVNAME(sc->sc_dev), fp->in_ep[i].ep);
d1052 1
a1052 1
	DPRINTFN(10, ("%s: dump_sc\n", USBDEVNAME(sc->sc_dev)));
d1130 1
a1130 1
			USBDEVNAME(ep->sc->sc_dev), usbd_errstr(err)));
d1147 1
a1147 1
			USBDEVNAME(ep->sc->sc_dev), usbd_errstr(err)));
d1159 1
a1159 1
		  USBDEVNAME(sc->sc_dev),				\
@


1.18
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.17 2007/05/05 16:31:27 krw Exp $	*/
d223 1
a223 1
			   sc->sc_udev, USBDEV(sc->sc_dev));
d263 1
a263 1
			   USBDEV(sc->sc_dev));
@


1.17
log
@#include <sys/lock.h> not needed. i.e. these compile fine without it.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.16 2006/06/23 06:27:12 miod Exp $	*/
d141 2
a142 1
USB_MATCH(umidi)
d144 1
a144 1
	USB_MATCH_START(umidi, uaa);
d164 2
a165 1
USB_ATTACH(umidi)
d168 2
a169 1
	USB_ATTACH_START(umidi, sc, uaa);
d225 1
a225 1
	USB_ATTACH_SUCCESS_RETURN;
a228 1
	USB_ATTACH_ERROR_RETURN;
d249 2
a250 1
USB_DETACH(umidi)
d252 1
a252 1
	USB_DETACH_START(umidi, sc);
@


1.16
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.15 2006/04/07 22:41:33 jsg Exp $	*/
a50 1
#include <sys/lock.h>
@


1.15
log
@Add optional flush method to MIDI hardware interface.
Allow umidi(4) to send multiple events in a single USB transfer.
This greatly improves the number of interrupts umidi is able to generate.

From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.14 2005/11/21 18:16:44 millert Exp $	*/
a237 2

		return EOPNOTSUPP;
@


1.14
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.13 2005/09/07 05:27:47 jsg Exp $	*/
d79 1
d125 1
d128 1
a128 1
static int out_build_packet(int, struct umidi_packet *, uByte);
d135 1
d329 11
d363 4
a366 1
	TAILQ_INIT(&ep->queue_head);
a496 1
		TAILQ_INIT(&ep->queue_head);
d613 1
a613 1
		sc->sc_out_ep->packetsize = UMIDI_PACKET_SIZE;
d755 3
a918 5
#ifdef UMIDI_DEBUG
		if (!TAILQ_EMPTY(&jack->endpoint->queue_head)) {
			printf("close_out_jack: queue_head still not empty\n");
		}
#endif
d1142 1
a1142 1
			ep->buffer, UMIDI_PACKET_SIZE,
d1150 1
d1154 1
d1169 1
a1169 1
out_jack_output(struct umidi_jack *out_jack, int d)
d1171 1
a1171 1
	struct umidi_endpoint *ep = out_jack->endpoint;
d1177 1
a1177 2

	if (!out_jack->opened) {
d1179 10
a1188 12
	}

	if (out_build_packet(out_jack->cable_number, &out_jack->packet, d)) {
		DPR_PACKET(out, sc, &out_jack->packet);
		s = splusb();
		if (TAILQ_EMPTY(&ep->queue_head)) {
			memcpy(ep->buffer,
			       out_jack->packet.buffer,
			       UMIDI_PACKET_SIZE);
			TAILQ_INSERT_TAIL(&ep->queue_head,
					 out_jack, u.out.queue_entry);
			start_output_transfer(ep);
d1190 2
a1191 1
			DPRINTF(("%s: out_jack_output: packet ignored\n", USBDEVNAME(sc->sc_dev)));
d1193 1
d1195 1
a1195 1
		return 0;
d1198 28
a1225 1
	return EINPROGRESS;
d1229 18
d1259 3
a1261 3
		DPRINTF(("umidi: in_intr: abnormal status: %s\n", usbd_errstr(status)));
		goto quit;
	}	
d1270 1
a1270 4
		} else
			DPRINTFN(10, ("in_intr: unused packet %02x %02x %02x %02x\n",
				buf[0], buf[1], buf[2], buf[3]));

a1273 8

#ifdef UMIDI_DEBUG
	if (remain != 0) {
		DPRINTF(("umidi: in_intr: remain != 0\n"));
	}
#endif
	
quit:
d1282 2
a1283 2
	struct umidi_jack *jack;
	int s;
d1288 7
a1294 9
	s = splusb();
	jack = TAILQ_FIRST(&ep->queue_head);
	if (jack) {
		TAILQ_REMOVE(&ep->queue_head, jack, u.out.queue_entry);
		if (!TAILQ_EMPTY(&ep->queue_head)) {
			memcpy(ep->buffer,
			       TAILQ_FIRST(&ep->queue_head)->packet.buffer,
			       UMIDI_PACKET_SIZE);
			(void)start_output_transfer(ep);
d1296 14
a1309 2
		if (jack->opened && jack->u.out.intr)
			(*jack->u.out.intr)(jack->arg);
a1310 1
	splx(s);
d1324 2
a1325 1
out_build_packet(int cable_number, struct umidi_packet *packet, uByte data)
d1328 4
a1331 5
		packet->buffer_rt[0] = data >> 4 | cable_number << 4;
		packet->buffer_rt[1] = data;
		packet->buffer_rt[2] = 0;
		packet->buffer_rt[3] = 0;
		packet->buffer = packet->buffer_rt;
d1337 1
a1337 1
			packet->buffer_com[1] = packet->status = data;
d1345 2
a1346 2
			packet->buffer_com[packet->index++] = data;
			packet->buffer_com[0] = (0x4 - 1 + packet->index) | cable_number << 4;
d1350 1
a1350 1
			packet->buffer_com[0] = 0x5 | cable_number << 4;
d1372 1
a1372 1
			packet->buffer_com[packet->index++] = data;
d1374 1
a1374 1
				packet->buffer_com[0] = 0x4 | cable_number << 4;
d1380 3
a1382 3
			packet->buffer_com[0] = 0x2 | cable_number << 4;
			packet->buffer_com[1] = packet->status;
			packet->buffer_com[2] = data;
d1387 1
a1387 1
				packet->buffer_com[0] = 0x3 | cable_number << 4;
d1390 1
a1390 1
			packet->buffer_com[packet->index++] = data;
d1392 1
a1392 1
				packet->buffer_com[1] = packet->status;
d1403 2
a1404 2
			packet->buffer_com[0] = packet->status >> 4 | cable_number << 4;
			packet->buffer_com[1] = packet->status;
d1407 1
a1407 1
		packet->buffer_com[packet->index++] = data;
d1416 1
a1416 2
		packet->buffer_com[packet->index++] = 0;
		
d1418 1
a1418 1
	packet->buffer = packet->buffer_com;
@


1.13
log
@Fix bug that caused multi byte MIDI messages to get corrupted
when a single real time byte is inserted.

From Alexandre Ratchov.  While I don't have a umidi device to
test here it looks correct to me and alex has a history of sending
good MIDI diffs.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.12 2005/08/01 05:36:49 brad Exp $	*/
d47 1
a47 1
#include <sys/select.h>
@


1.12
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.11 2004/11/20 01:29:37 jsg Exp $	*/
d1165 1
a1165 1
	
d1269 5
a1273 4
		packet->buffer[0] = data >> 4 | cable_number << 4;
		packet->buffer[1] = data;
		packet->buffer[2] = 0;
		packet->buffer[3] = 0;
d1279 1
a1279 1
			packet->buffer[1] = packet->status = data;
d1287 2
a1288 2
			packet->buffer[packet->index++] = data;
			packet->buffer[0] = (0x4 - 1 + packet->index) | cable_number << 4;
d1292 1
a1292 1
			packet->buffer[0] = 0x5 | cable_number << 4;
d1314 1
a1314 1
			packet->buffer[packet->index++] = data;
d1316 1
a1316 1
				packet->buffer[0] = 0x4 | cable_number << 4;
d1322 3
a1324 3
			packet->buffer[0] = 0x2 | cable_number << 4;
			packet->buffer[1] = packet->status;
			packet->buffer[2] = data;
d1329 1
a1329 1
				packet->buffer[0] = 0x3 | cable_number << 4;
d1332 1
a1332 1
			packet->buffer[packet->index++] = data;
d1334 1
a1334 1
				packet->buffer[1] = packet->status;
d1345 2
a1346 2
			packet->buffer[0] = packet->status >> 4 | cable_number << 4;
			packet->buffer[1] = packet->status;
d1349 1
a1349 1
		packet->buffer[packet->index++] = data;
d1358 1
a1358 1
		packet->buffer[packet->index++] = 0;
d1361 1
@


1.11
log
@When processing sysex stop bytes ensure the packet is not corrupted
if we are building a new packet, from Alexandre Ratchov.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.10 2004/06/27 19:44:48 deraadt Exp $	*/
d165 1
a165 1
	char devinfo[1024];
d170 3
a172 2
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.10
log
@better midi stuff from alex@@caoua.org
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.9 2003/05/19 00:36:33 nate Exp $	*/
d1282 2
@


1.9
log
@check for null before memset
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.8 2003/05/07 04:33:33 deraadt Exp $	*/
d126 1
a126 1
static void out_build_packet(int, struct umidi_packet *, uByte);
d166 1
a183 2
		printf("%s: alloc_all_endpoints failed. (err=%d)\n",
		       USBDEVNAME(sc->sc_dev), err);
a188 2
		printf("%s: alloc_all_jacks failed. (err=%d)\n",
		       USBDEVNAME(sc->sc_dev), err);
a199 2
		printf("%s: assign_all_jacks_automatically failed. (err=%d)\n",
		       USBDEVNAME(sc->sc_dev), err);
a205 2
		printf("%s: attach_all_mididevs failed. (err=%d)\n",
		       USBDEVNAME(sc->sc_dev), err);
d212 4
a327 1
/*	struct umidi_softc *sc = mididev->sc; */
d348 1
a348 1
	LIST_INIT(&ep->queue_head);
d351 1
a351 2
	    err = USBD_NOMEM;
	    goto quit;
d353 1
a353 1
	ep->buffer = usbd_alloc_buffer(ep->xfer, UMIDI_PACKET_SIZE);
d355 2
a356 3
	    usbd_free_xfer(ep->xfer);
	    err = USBD_NOMEM;
	    goto quit;
d359 5
a363 4
	if (err)
	    usbd_free_xfer(ep->xfer);
quit:
	return err;
d401 1
a401 1
		err = alloc_pipe(ep++);
d403 4
a406 2
			for (; ep!=sc->sc_endpoints; ep--)
				free_pipe(ep-1);
d411 1
d460 2
a461 2
			printf("%s: cannot get endpoint descriptor(out:%d)\n",
			       USBDEVNAME(sc->sc_dev), fp->out_ep[i].ep);
d473 1
d479 1
a479 1
		LIST_INIT(&ep->queue_head);
d488 2
a489 2
			printf("%s: cannot get endpoint descriptor(in:%d)\n",
			       USBDEVNAME(sc->sc_dev), fp->in_ep[i].ep);
d502 1
d523 1
a523 1
	int out_addr, in_addr, i;
d538 1
a538 1
			else if (dir==UE_DIR_IN && !in_addr)
d540 2
d596 1
d607 1
d620 2
d626 1
a626 8
	int epaddr;

	desc = TO_D(usbd_get_interface_descriptor(sc->sc_iface));
	num_ep = TO_IFD(desc)->bNumEndpoints;
	desc = NEXT_D(desc); /* ifd -> csifd */
	remain = ((size_t)UGETW(TO_CSIFD(desc)->wTotalLength) -
		  (size_t)desc->bLength);
	desc = NEXT_D(desc);
d628 3
a630 1
	sc->sc_endpoints = p = malloc(sizeof(struct umidi_endpoint)*num_ep,
d640 3
d651 1
d659 1
a868 2
	struct umidi_endpoint *ep = jack->endpoint;

d876 2
a877 2
	ep->num_open++;

a883 3
	usbd_status err = USBD_NORMAL_COMPLETION;
	struct umidi_endpoint *ep = jack->endpoint;

d890 3
a892 8
	if (ep->num_open++==0 && UE_GET_DIR(ep->addr)==UE_DIR_IN) {
		err = start_input_transfer(ep);
		if (err!=USBD_NORMAL_COMPLETION) {
			ep->num_open--;
		}
	}

	return err;
a897 3
	struct umidi_jack *tail;
	int s;

d899 3
a901 17
		s = splusb();
		LIST_FOREACH(tail,
			     &jack->endpoint->queue_head,
			     u.out.queue_entry)
			if (tail == jack) {
				LIST_REMOVE(jack, u.out.queue_entry);
				break;
			}
		if (jack == jack->endpoint->queue_tail) {
			/* find tail */
			LIST_FOREACH(tail,
				     &jack->endpoint->queue_head,
				     u.out.queue_entry) {
				if (!LIST_NEXT(tail, u.out.queue_entry)) {
					jack->endpoint->queue_tail = tail;
				}
			}
d903 1
a903 1
		splx(s);
d914 1
a914 1
		jack->endpoint->num_open--;
a1090 22
static const struct {
	int		cin;
	packet_state_t	next;
} packet_0xFX[16] = {
	/*F0: SysEx */	{ 0x04, PS_EXCL_1 },
	/*F1: MTC */	{ 0x02, PS_NORMAL_1OF2 },
	/*F2: S.POS */	{ 0x03, PS_NORMAL_1OF3 },
	/*F3: S.SEL */	{ 0x02, PS_NORMAL_1OF2 },
	/*F4: UNDEF */	{ 0x00, PS_INITIAL },
	/*F5: UNDEF */	{ 0x00, PS_INITIAL },
	/*F6: Tune */	{ 0x0F, PS_END },
	/*F7: EofEx */	{ 0x00, PS_INITIAL },
	/*F8: Timing */	{ 0x0F, PS_END },
	/*F9: UNDEF */	{ 0x00, PS_INITIAL },
	/*FA: Start */	{ 0x0F, PS_END },
	/*FB: Cont */	{ 0x0F, PS_END },
	/*FC: Stop */	{ 0x0F, PS_END },
	/*FD: UNDEF */	{ 0x00, PS_INITIAL },
	/*FE: ActS */	{ 0x0F, PS_END },
	/*FF: Reset */	{ 0x0F, PS_END },
};

d1100 2
a1101 2
	memset(packet->buffer, 0, UMIDI_PACKET_SIZE);
	packet->state = PS_INITIAL;
d1107 1
d1110 9
a1118 3
			ep->buffer, UMIDI_PACKET_SIZE,
			USBD_NO_COPY, USBD_NO_TIMEOUT, in_intr);
	return usbd_transfer(ep->xfer);
d1124 1
d1129 7
a1135 1
	return usbd_transfer(ep->xfer);
a1139 1
if ((unsigned char)(p)->buffer[1]!=0xFE)				\
a1155 1
	int error;
d1161 16
a1176 26
	error = 0;
	if (out_jack->opened) {
		DPRINTFN(1000, ("umidi_output: ep=%p 0x%02x\n", ep, d));
		out_build_packet(out_jack->cable_number, &out_jack->packet, d);
		switch (out_jack->packet.state) {
		case PS_EXCL_0:
		case PS_END:
			DPR_PACKET(out, sc, &out_jack->packet);
			s = splusb();
			if (LIST_EMPTY(&ep->queue_head)) {
				memcpy(ep->buffer,
				       out_jack->packet.buffer,
				       UMIDI_PACKET_SIZE);
				start_output_transfer(ep);
			}
			if (LIST_EMPTY(&ep->queue_head))
				LIST_INSERT_HEAD(&ep->queue_head,
						 out_jack, u.out.queue_entry);
			else
				LIST_INSERT_AFTER(ep->queue_tail,
						  out_jack, u.out.queue_entry);
			ep->queue_tail = out_jack;
			splx(s);
			break;
		default:
			error = EINPROGRESS;
d1178 5
a1182 4
	} else
		error = ENODEV;

	return error;
d1188 2
a1189 1
	int cn, len, i;
d1193 1
a1193 1
	if (ep->sc->sc_dying || !ep->num_open)
d1196 19
a1214 11
	cn = GET_CN(ep->buffer[0]);
	len = packet_length[GET_CIN(ep->buffer[0])];
	jack = ep->jacks[cn];
	if (cn>=ep->num_jacks || !jack) {
		DPRINTF(("%s: stray umidi packet (in): %02X %02X %02X %02X\n",
			 USBDEVNAME(ep->sc->sc_dev),
			 (unsigned)ep->buffer[0],
			 (unsigned)ep->buffer[1],
			 (unsigned)ep->buffer[2],
			 (unsigned)ep->buffer[3]));
		return;
d1216 4
a1219 7
	if (!jack->binded || !jack->opened)
		return;
	DPR_PACKET(in, ep->sc, &jack->packet);
	if (jack->u.in.intr) {
		for (i=0; i<len; i++) {
			(*jack->u.in.intr)(jack->arg, ep->buffer[i+1]);
		}
d1221 3
a1223 1

d1233 3
a1235 2

	if (sc->sc_dying || !ep->num_open)
d1238 5
a1242 4
	jack = LIST_FIRST(&ep->queue_head);
	if (jack && jack->opened) {
		LIST_REMOVE(jack, u.out.queue_entry);
		if (!LIST_EMPTY(&ep->queue_head)) {
d1244 1
a1244 1
			       LIST_FIRST(&ep->queue_head)->packet.buffer,
d1248 1
a1248 1
		if (jack->u.out.intr) {
a1249 1
		}
d1251 1
d1254 12
a1265 2
static void
out_build_packet(int cable_number, struct umidi_packet *packet, uByte in)
d1267 26
a1292 16
	int cin;
	uByte prev;

retry:
	switch (packet->state) {
	case PS_END:
	case PS_INITIAL:
		prev = packet->buffer[1];
		memset(packet->buffer, 0, UMIDI_PACKET_SIZE);
		if (in<0x80) {
			if (prev>=0x80 && prev<0xf0) {
				/* running status */
				out_build_packet(cable_number, packet, prev);
				goto retry;
			}
			/* ??? */
d1295 19
a1313 15
		if (in>=0xf0) {
			cin=packet_0xFX[in&0x0F].cin;
			packet->state=packet_0xFX[in&0x0F].next;
		} else {
			cin=(unsigned char)in>>4;
			switch (packet_length[cin]) {
			case 2:
				packet->state = PS_NORMAL_1OF2;
				break;
			case 3:
				packet->state = PS_NORMAL_1OF3;
				break;
			default:
				/* ??? */
				packet->state = PS_INITIAL;
a1314 25
		}
		packet->buffer[0] = MIX_CN_CIN(cable_number, cin);
		packet->buffer[1] = in;
		break;
	case PS_NORMAL_1OF3:
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[2] = in;
		packet->state = PS_NORMAL_2OF3;
		break;
	case PS_NORMAL_2OF3:
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[3] = in;
		packet->state = PS_END;
		break;
	case PS_NORMAL_1OF2:
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[2] = in;
		packet->state = PS_END;
		break;
	case PS_EXCL_0:
		memset(packet->buffer, 0, UMIDI_PACKET_SIZE);
		if (in==0xF7) {
			packet->buffer[0] = MIX_CN_CIN(cable_number, 0x05);
			packet->buffer[1] = 0xF7;
			packet->state = PS_END;
d1316 17
a1332 10
		}
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[1] = in;
		packet->state = PS_EXCL_1;
		break;
	case PS_EXCL_1:
		if (in==0xF7) {
			packet->buffer[0] = MIX_CN_CIN(cable_number, 0x06);
			packet->buffer[2] = 0xF7;
			packet->state = PS_END;
d1334 1
a1334 10
		}
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[2] = in;
		packet->state = PS_EXCL_2;
		break;
	case PS_EXCL_2:
		if (in==0xF7) {
			packet->buffer[0] = MIX_CN_CIN(cable_number, 0x07);
			packet->buffer[3] = 0xF7;
			packet->state = PS_END;
d1337 11
a1347 9
		if (in>=0x80) { /* ??? */ packet->state = PS_END; break; }
		packet->buffer[0] = MIX_CN_CIN(cable_number, 0x04);
		packet->buffer[3] = in;
		packet->state = PS_EXCL_0;
		break;
	default:
		printf("umidi: ambiguous state.\n");
		packet->state = PS_INITIAL;
		goto retry;
d1349 9
a1358 1

@


1.8
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.7 2002/11/11 02:32:32 nate Exp $	*/
a988 1
	memset(sc->sc_mididevs, 0, sizeof(*sc->sc_mididevs)*nmidi);
d991 1
@


1.7
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.6 2002/07/25 04:07:33 nate Exp $	*/
d169 1
a169 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.7.4.1
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.7 2002/11/11 02:32:32 nate Exp $	*/
d169 1
a169 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.7.4.2
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.7.4.1 2003/05/13 19:35:12 ho Exp $	*/
d989 1
a991 1
	memset(sc->sc_mididevs, 0, sizeof(*sc->sc_mididevs)*nmidi);
@


1.6
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: umidi.c,v 1.5 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: umidi.c,v 1.16 2002/07/11 21:14:32 augustss Exp $ */
@


1.6.4.1
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@


1.6.4.2
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: umidi.c,v 1.16 2002/07/11 21:14:32 augustss Exp $	*/
d169 1
a169 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.5
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: umidi.c,v 1.4 2002/07/09 15:22:08 nate Exp $	*/
/*	$NetBSD: umidi.c,v 1.15 2002/06/19 13:51:34 tshiozak Exp $	*/
a989 1

@


1.4
log
@fixes from NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.3 2002/06/11 07:49:56 nate Exp $	*/
d153 1
a153 1
	if (id!=NULL && 
d221 1
a221 1
	
d693 1
a693 1
	
@


1.3
log
@add usb midi support.
untested
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: umidi.c,v 1.14 2002/03/08 17:24:06 kent Exp $	*/
d811 1
a811 1
	if ((mididev->flags&FWRITE) && mididev->out_jack)
d813 1
a813 1
	if ((mididev->flags&FWRITE) && mididev->in_jack)
d907 8
a914 2
		LIST_REMOVE(jack, u.out.queue_entry);
		if (jack==jack->endpoint->queue_tail) {
d1082 2
a1083 2
	DPRINTFN(10, ("\t\t\tep=%p, mididev=%p\n",
		      jack->endpoint, jack->mididev));
d1250 1
a1250 1
	DPR_PACKET(in, ep->sc, &jack->buffer);
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: umidi.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
d982 3
a984 1
				 M_USBDEV, M_WAITOK|M_ZERO);
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

