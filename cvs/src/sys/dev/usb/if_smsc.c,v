head	1.31;
access;
symbols
	OPENBSD_6_2:1.31.0.4
	OPENBSD_6_2_BASE:1.31
	OPENBSD_6_1:1.30.0.4
	OPENBSD_6_1_BASE:1.30
	OPENBSD_6_0:1.27.0.4
	OPENBSD_6_0_BASE:1.27
	OPENBSD_5_9:1.26.0.2
	OPENBSD_5_9_BASE:1.26
	OPENBSD_5_8:1.20.0.4
	OPENBSD_5_8_BASE:1.20
	OPENBSD_5_7:1.14.0.2
	OPENBSD_5_7_BASE:1.14
	OPENBSD_5_6:1.13.0.4
	OPENBSD_5_6_BASE:1.13
	OPENBSD_5_5:1.10.0.4
	OPENBSD_5_5_BASE:1.10
	OPENBSD_5_4:1.8.0.2
	OPENBSD_5_4_BASE:1.8
	OPENBSD_5_3:1.5.0.2
	OPENBSD_5_3_BASE:1.5;
locks; strict;
comment	@ * @;


1.31
date	2017.07.29.17.24.04;	author kettenis;	state Exp;
branches;
next	1.30;
commitid	xWdKyqf39DOpCAfj;

1.30
date	2017.02.12.04.29.57;	author jsg;	state Exp;
branches;
next	1.29;
commitid	UkPGUGbYZSx30L1z;

1.29
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.28;
commitid	VyLWTsbepAOk7VQM;

1.28
date	2016.07.31.12.51.49;	author kettenis;	state Exp;
branches;
next	1.27;
commitid	ZRQoAI0VJZE0YiuX;

1.27
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.26;
commitid	gWZDkudwxydTq8x4;

1.26
date	2016.01.20.01.31.01;	author jsg;	state Exp;
branches;
next	1.25;
commitid	JBPzWBB5o7UVMXFu;

1.25
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.24;
commitid	B0kwmVGiD5DVx4kv;

1.24
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.23;
commitid	5gdEnqVoJuTuwdTu;

1.23
date	2015.11.24.15.25.20;	author mpi;	state Exp;
branches;
next	1.22;
commitid	MfakaqIkeFe2uL7U;

1.22
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.21;
commitid	eYnPulzvLjDImPCa;

1.21
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.20;
commitid	pwYnMC1gOKohmeGw;

1.20
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.19;
commitid	MVWrtktB46JRxFWT;

1.19
date	2015.06.18.09.28.54;	author mpi;	state Exp;
branches;
next	1.18;
commitid	LUkKCu1FzKBUIcr1;

1.18
date	2015.03.23.22.48.51;	author jsg;	state Exp;
branches;
next	1.17;
commitid	7wZJzxwiURXNRUW6;

1.17
date	2015.03.23.08.41.52;	author mpi;	state Exp;
branches;
next	1.16;
commitid	9wULl4eNLt7FuCbq;

1.16
date	2015.03.19.02.02.43;	author jsg;	state Exp;
branches;
next	1.15;
commitid	WCPX47ZY6sOYhts5;

1.15
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.14;
commitid	p4LJxGKbi0BU2cG6;

1.14
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.13;
commitid	yM2VFFhpDTeFQlve;

1.13
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.12;
commitid	Pclvgy2Z4XV9hveD;

1.12
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.11;
commitid	b0VSac5dnnsxcDao;

1.11
date	2014.03.07.18.39.02;	author mpi;	state Exp;
branches;
next	1.10;

1.10
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.9;

1.9
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.8;

1.8
date	2013.07.02.19.27.15;	author brad;	state Exp;
branches;
next	1.7;

1.7
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.5;

1.5
date	2012.11.10.18.48.22;	author brad;	state Exp;
branches;
next	1.4;

1.4
date	2012.09.27.12.38.11;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2012.09.27.12.05.02;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2012.09.19.16.51.10;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2012.09.19.16.33.04;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.31
log
@Device trees for the Rasperry Pi are still in flux.  Catch up with the
latest ways to encode the MAC address for the onboard USB Ethernet.

ok visa@@
@
text
@/*	$OpenBSD: if_smsc.c,v 1.30 2017/02/12 04:29:57 jsg Exp $	*/
/* $FreeBSD: src/sys/dev/usb/net/if_smsc.c,v 1.1 2012/08/15 04:03:55 gonzo Exp $ */
/*-
 * Copyright (c) 2012
 *	Ben Gray <bgray@@freebsd.org>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * SMSC LAN9xxx devices (http://www.smsc.com/)
 * 
 * The LAN9500 & LAN9500A devices are stand-alone USB to Ethernet chips that
 * support USB 2.0 and 10/100 Mbps Ethernet.
 *
 * The LAN951x devices are an integrated USB hub and USB to Ethernet adapter.
 * The driver only covers the Ethernet part, the standard USB hub driver
 * supports the hub part.
 *
 * This driver is closely modelled on the Linux driver written and copyrighted
 * by SMSC.
 *
 * H/W TCP & UDP Checksum Offloading
 * ---------------------------------
 * The chip supports both tx and rx offloading of UDP & TCP checksums, this
 * feature can be dynamically enabled/disabled.  
 *
 * RX checksuming is performed across bytes after the IPv4 header to the end of
 * the Ethernet frame, this means if the frame is padded with non-zero values
 * the H/W checksum will be incorrect, however the rx code compensates for this.
 *
 * TX checksuming is more complicated, the device requires a special header to
 * be prefixed onto the start of the frame which indicates the start and end
 * positions of the UDP or TCP frame.  This requires the driver to manually
 * go through the packet data and decode the headers prior to sending.
 * On Linux they generally provide cues to the location of the csum and the
 * area to calculate it over, on FreeBSD we seem to have to do it all ourselves,
 * hence this is not as optimal and therefore h/w tX checksum is currently not
 * implemented.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>

#include "if_smscreg.h"

/*
 * Various supported device vendors/products.
 */
static const struct usb_devno smsc_devs[] = {
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_LAN89530 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_LAN9530 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_LAN9730 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500A },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500A_ALT },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500A_HAL },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500A_SAL10 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500_ALT },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9500_SAL10 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9505 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9505A },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9505A_HAL },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9505A_SAL10 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9505_SAL10 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9512_14 },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9512_14_ALT },
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9512_14_SAL10 }
};

#ifdef SMSC_DEBUG
static int smsc_debug = 0;
#define smsc_dbg_printf(sc, fmt, args...) \
	do { \
		if (smsc_debug > 0) \
			printf("debug: " fmt, ##args); \
	} while(0)
#else
#define smsc_dbg_printf(sc, fmt, args...)
#endif

#define smsc_warn_printf(sc, fmt, args...) \
	printf("%s: warning: " fmt, (sc)->sc_dev.dv_xname, ##args)

#define smsc_err_printf(sc, fmt, args...) \
	printf("%s: error: " fmt, (sc)->sc_dev.dv_xname, ##args)

int		 smsc_chip_init(struct smsc_softc *sc);
int		 smsc_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data);
void		 smsc_iff(struct smsc_softc *);
int		 smsc_setmacaddress(struct smsc_softc *, const uint8_t *);

int		 smsc_match(struct device *, void *, void *);
void		 smsc_attach(struct device *, struct device *, void *);
int		 smsc_detach(struct device *, int);

void		 smsc_init(void *);
void		 smsc_stop(struct smsc_softc *);
void		 smsc_start(struct ifnet *);
void		 smsc_reset(struct smsc_softc *);

void		 smsc_tick(void *);
void		 smsc_tick_task(void *);
void		 smsc_miibus_statchg(struct device *);
int		 smsc_miibus_readreg(struct device *, int, int);
void		 smsc_miibus_writereg(struct device *, int, int, int);
int		 smsc_ifmedia_upd(struct ifnet *);
void		 smsc_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void		 smsc_lock_mii(struct smsc_softc *sc);
void		 smsc_unlock_mii(struct smsc_softc *sc);

int		 smsc_tx_list_init(struct smsc_softc *);
int		 smsc_rx_list_init(struct smsc_softc *);
int		 smsc_encap(struct smsc_softc *, struct mbuf *, int);
void		 smsc_rxeof(struct usbd_xfer *, void *, usbd_status);
void		 smsc_txeof(struct usbd_xfer *, void *, usbd_status);

int		 smsc_read_reg(struct smsc_softc *, uint32_t, uint32_t *);
int		 smsc_write_reg(struct smsc_softc *, uint32_t, uint32_t);
int		 smsc_wait_for_bits(struct smsc_softc *, uint32_t, uint32_t);
int		 smsc_sethwcsum(struct smsc_softc *);

struct cfdriver smsc_cd = {
	NULL, "smsc", DV_IFNET
};

const struct cfattach smsc_ca = {
	sizeof(struct smsc_softc), smsc_match, smsc_attach, smsc_detach,
};

#if defined(__arm__) || defined(__arm64__)

#include <dev/ofw/openfirm.h>

void
smsc_enaddr_OF(struct smsc_softc *sc)
{
	char *device = "/axi/usb/hub/ethernet";
	char prop[64];
	int node;

	if (sc->sc_dev.dv_unit != 0)
		return;

	/*
	 * Get the Raspberry Pi MAC address from FDT.  This is all
	 * much more complicated than strictly needed since the
	 * firmware device tree keeps changing as drivers get
	 * upstreamed.  Sigh.
	 * 
	 * Ultimately this should just use the "ethernet0" alias and
	 * the "local-mac-address" property.
	 */

	if ((node = OF_finddevice("/aliases")) == -1)
		return;
	if (OF_getprop(node, "ethernet0", prop, sizeof(prop)) > 0 ||
	    OF_getprop(node, "ethernet", prop, sizeof(prop)) > 0)
		device = prop;

	if ((node = OF_finddevice(device)) == -1)
		return;
	if (OF_getprop(node, "local-mac-address", sc->sc_ac.ac_enaddr,
	    sizeof(sc->sc_ac.ac_enaddr)) != sizeof(sc->sc_ac.ac_enaddr)) {
		OF_getprop(node, "mac-address", sc->sc_ac.ac_enaddr,
		    sizeof(sc->sc_ac.ac_enaddr));
	}
}
#else
#define smsc_enaddr_OF(x) do {} while(0)
#endif

int
smsc_read_reg(struct smsc_softc *sc, uint32_t off, uint32_t *data)
{
	usb_device_request_t req;
	uint32_t buf;
	usbd_status err;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = SMSC_UR_READ_REG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, off);
	USETW(req.wLength, 4);

	err = usbd_do_request(sc->sc_udev, &req, &buf);
	if (err != 0)
		smsc_warn_printf(sc, "Failed to read register 0x%0x\n", off);

	*data = letoh32(buf);
	
	return (err);
}

int
smsc_write_reg(struct smsc_softc *sc, uint32_t off, uint32_t data)
{
	usb_device_request_t req;
	uint32_t buf;
	usbd_status err;

	buf = htole32(data);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = SMSC_UR_WRITE_REG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, off);
	USETW(req.wLength, 4);

	err = usbd_do_request(sc->sc_udev, &req, &buf);
	if (err != 0)
		smsc_warn_printf(sc, "Failed to write register 0x%0x\n", off);

	return (err);
}

int
smsc_wait_for_bits(struct smsc_softc *sc, uint32_t reg, uint32_t bits)
{
	uint32_t val;
	int err, i;

	for (i = 0; i < 100; i++) {
		if ((err = smsc_read_reg(sc, reg, &val)) != 0)
			return (err);
		if (!(val & bits))
			return (0);
		DELAY(5);
	}

	return (1);
}

int
smsc_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct smsc_softc *sc = (struct smsc_softc *)dev;
	uint32_t addr;
	uint32_t val = 0;

	smsc_lock_mii(sc);
	if (smsc_wait_for_bits(sc, SMSC_MII_ADDR, SMSC_MII_BUSY) != 0) {
		smsc_warn_printf(sc, "MII is busy\n");
		goto done;
	}

	addr = (phy << 11) | (reg << 6) | SMSC_MII_READ;
	smsc_write_reg(sc, SMSC_MII_ADDR, addr);

	if (smsc_wait_for_bits(sc, SMSC_MII_ADDR, SMSC_MII_BUSY) != 0)
		smsc_warn_printf(sc, "MII read timeout\n");

	smsc_read_reg(sc, SMSC_MII_DATA, &val);

done:
	smsc_unlock_mii(sc);
	return (val & 0xFFFF);
}

void
smsc_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct smsc_softc *sc = (struct smsc_softc *)dev;
	uint32_t addr;

	if (sc->sc_phyno != phy)
		return;

	smsc_lock_mii(sc);
	if (smsc_wait_for_bits(sc, SMSC_MII_ADDR, SMSC_MII_BUSY) != 0) {
		smsc_warn_printf(sc, "MII is busy\n");
		smsc_unlock_mii(sc);
		return;
	}

	smsc_write_reg(sc, SMSC_MII_DATA, val);

	addr = (phy << 11) | (reg << 6) | SMSC_MII_WRITE;
	smsc_write_reg(sc, SMSC_MII_ADDR, addr);
	smsc_unlock_mii(sc);

	if (smsc_wait_for_bits(sc, SMSC_MII_ADDR, SMSC_MII_BUSY) != 0)
		smsc_warn_printf(sc, "MII write timeout\n");
}

void
smsc_miibus_statchg(struct device *dev)
{
	struct smsc_softc *sc = (struct smsc_softc *)dev;
	struct mii_data *mii = &sc->sc_mii;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	int err;
	uint32_t flow;
	uint32_t afc_cfg;

	if (mii == NULL || ifp == NULL ||
	    (ifp->if_flags & IFF_RUNNING) == 0)
		return;

	/* Use the MII status to determine link status */
	sc->sc_flags &= ~SMSC_FLAG_LINK;
	if ((mii->mii_media_status & (IFM_ACTIVE | IFM_AVALID)) ==
	    (IFM_ACTIVE | IFM_AVALID)) {
		switch (IFM_SUBTYPE(mii->mii_media_active)) {
			case IFM_10_T:
			case IFM_100_TX:
				sc->sc_flags |= SMSC_FLAG_LINK;
				break;
			case IFM_1000_T:
				/* Gigabit ethernet not supported by chipset */
				break;
			default:
				break;
		}
	}

	/* Lost link, do nothing. */
	if ((sc->sc_flags & SMSC_FLAG_LINK) == 0) {
		smsc_dbg_printf(sc, "link flag not set\n");
		return;
	}
	
	err = smsc_read_reg(sc, SMSC_AFC_CFG, &afc_cfg);
	if (err) {
		smsc_warn_printf(sc, "failed to read initial AFC_CFG, "
		    "error %d\n", err);
		return;
	}
	
	/* Enable/disable full duplex operation and TX/RX pause */
	if ((IFM_OPTIONS(mii->mii_media_active) & IFM_FDX) != 0) {
		smsc_dbg_printf(sc, "full duplex operation\n");
		sc->sc_mac_csr &= ~SMSC_MAC_CSR_RCVOWN;
		sc->sc_mac_csr |= SMSC_MAC_CSR_FDPX;

		if ((IFM_OPTIONS(mii->mii_media_active) & IFM_ETH_RXPAUSE) != 0)
			flow = 0xffff0002;
		else
			flow = 0;
			
		if ((IFM_OPTIONS(mii->mii_media_active) & IFM_ETH_TXPAUSE) != 0)
			afc_cfg |= 0xf;
		else
			afc_cfg &= ~0xf;
		
	} else {
		smsc_dbg_printf(sc, "half duplex operation\n");
		sc->sc_mac_csr &= ~SMSC_MAC_CSR_FDPX;
		sc->sc_mac_csr |= SMSC_MAC_CSR_RCVOWN;
		
		flow = 0;
		afc_cfg |= 0xf;
	}

	err = smsc_write_reg(sc, SMSC_MAC_CSR, sc->sc_mac_csr);
	err += smsc_write_reg(sc, SMSC_FLOW, flow);
	err += smsc_write_reg(sc, SMSC_AFC_CFG, afc_cfg);
	if (err)
		smsc_warn_printf(sc, "media change failed, error %d\n", err);
}

int
smsc_ifmedia_upd(struct ifnet *ifp)
{
	struct smsc_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;
	int err;

	if (mii->mii_instance) {
		struct mii_softc *miisc;

		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	err = mii_mediachg(mii);
	return (err);
}

void
smsc_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct smsc_softc *sc = ifp->if_softc;
	struct mii_data *mii = &sc->sc_mii;

	mii_pollstat(mii);
	
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

static inline uint32_t
smsc_hash(uint8_t addr[ETHER_ADDR_LEN])
{
	return (ether_crc32_be(addr, ETHER_ADDR_LEN) >> 26) & 0x3f;
}

void
smsc_iff(struct smsc_softc *sc)
{
	struct ifnet		*ifp = &sc->sc_ac.ac_if;
	struct arpcom		*ac = &sc->sc_ac;
	struct ether_multi	*enm;
	struct ether_multistep	 step;
	uint32_t		 hashtbl[2] = { 0, 0 };
	uint32_t		 hash;

	if (usbd_is_dying(sc->sc_udev))
		return;

	sc->sc_mac_csr &= ~(SMSC_MAC_CSR_HPFILT | SMSC_MAC_CSR_MCPAS |
	    SMSC_MAC_CSR_PRMS);
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		sc->sc_mac_csr |= SMSC_MAC_CSR_MCPAS;
		if (ifp->if_flags & IFF_PROMISC)
			sc->sc_mac_csr |= SMSC_MAC_CSR_PRMS;
	} else {
		sc->sc_mac_csr |= SMSC_MAC_CSR_HPFILT;

		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			hash = smsc_hash(enm->enm_addrlo);

			hashtbl[hash >> 5] |= 1 << (hash & 0x1F);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* Debug */
	if (sc->sc_mac_csr & SMSC_MAC_CSR_MCPAS)
		smsc_dbg_printf(sc, "receive all multicast enabled\n");
	else if (sc->sc_mac_csr & SMSC_MAC_CSR_HPFILT)
		smsc_dbg_printf(sc, "receive select group of macs\n");

	/* Write the hash table and mac control registers */
	smsc_write_reg(sc, SMSC_HASHH, hashtbl[1]);
	smsc_write_reg(sc, SMSC_HASHL, hashtbl[0]);
	smsc_write_reg(sc, SMSC_MAC_CSR, sc->sc_mac_csr);
}

int
smsc_sethwcsum(struct smsc_softc *sc)
{
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	uint32_t val;
	int err;

	if (!ifp)
		return (-EIO);

	err = smsc_read_reg(sc, SMSC_COE_CTRL, &val);
	if (err != 0) {
		smsc_warn_printf(sc, "failed to read SMSC_COE_CTRL (err=%d)\n",
		    err);
		return (err);
	}

	/* Enable/disable the Rx checksum */
	if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
		val |= SMSC_COE_CTRL_RX_EN;
	else
		val &= ~SMSC_COE_CTRL_RX_EN;

	/* Enable/disable the Tx checksum (currently not supported) */
	if (ifp->if_capabilities & IFCAP_CSUM_IPv4)
		val |= SMSC_COE_CTRL_TX_EN;
	else
		val &= ~SMSC_COE_CTRL_TX_EN;

	err = smsc_write_reg(sc, SMSC_COE_CTRL, val);
	if (err != 0) {
		smsc_warn_printf(sc, "failed to write SMSC_COE_CTRL (err=%d)\n",
		    err);
		return (err);
	}

	return (0);
}

int
smsc_setmacaddress(struct smsc_softc *sc, const uint8_t *addr)
{
	int err;
	uint32_t val;

	smsc_dbg_printf(sc, "setting mac address to "
	    "%02x:%02x:%02x:%02x:%02x:%02x\n",
	    addr[0], addr[1], addr[2], addr[3], addr[4], addr[5]);

	val = (addr[3] << 24) | (addr[2] << 16) | (addr[1] << 8) | addr[0];
	if ((err = smsc_write_reg(sc, SMSC_MAC_ADDRL, val)) != 0)
		goto done;
		
	val = (addr[5] << 8) | addr[4];
	err = smsc_write_reg(sc, SMSC_MAC_ADDRH, val);
	
done:
	return (err);
}

void
smsc_reset(struct smsc_softc *sc)
{
	if (usbd_is_dying(sc->sc_udev))
		return;

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);

	/* Reinitialize controller to achieve full reset. */
	smsc_chip_init(sc);
}

void
smsc_init(void *xsc)
{
	struct smsc_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->sc_ac.ac_if;
	struct smsc_chain	*c;
	usbd_status		 err;
	int			 s, i;
	
	s = splnet();

	/* Cancel pending I/O */
	smsc_stop(sc);

	/* Reset the ethernet interface. */
	smsc_reset(sc);

	/* Init RX ring. */
	if (smsc_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init TX ring. */
	if (smsc_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return;
	}

	/* Program promiscuous mode and multicast filters. */
	smsc_iff(sc);

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->sc_iface, sc->sc_ed[SMSC_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->sc_ep[SMSC_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->sc_iface, sc->sc_ed[SMSC_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->sc_ep[SMSC_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->sc_dev.dv_xname, usbd_errstr(err));
		splx(s);
		return;
	}

	/* Start up the receive pipe. */
	for (i = 0; i < SMSC_RX_LIST_CNT; i++) {
		c = &sc->sc_cdata.rx_chain[i];
		usbd_setup_xfer(c->sc_xfer, sc->sc_ep[SMSC_ENDPT_RX],
		    c, c->sc_buf, sc->sc_bufsz,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, smsc_rxeof);
		usbd_transfer(c->sc_xfer);
	}

	/* TCP/UDP checksum offload engines. */
	smsc_sethwcsum(sc);

	/* Indicate we are up and running. */
	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_add_sec(&sc->sc_stat_ch, 1);

	splx(s);
}

void
smsc_start(struct ifnet *ifp)
{
	struct smsc_softc	*sc = ifp->if_softc;
	struct mbuf		*m_head = NULL;

	/* Don't send anything if there is no link or controller is busy. */
	if ((sc->sc_flags & SMSC_FLAG_LINK) == 0 ||
		ifq_is_oactive(&ifp->if_snd)) {
		return;
	}

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (smsc_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}
	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif
	ifq_set_oactive(&ifp->if_snd);
}

void
smsc_tick(void *xsc)
{
	struct smsc_softc *sc = xsc;

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->sc_udev))
		return;

	usb_add_task(sc->sc_udev, &sc->sc_tick_task);
}

void
smsc_stop(struct smsc_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	smsc_reset(sc);

	ifp = &sc->sc_ac.ac_if;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->sc_stat_ch);

	/* Stop transfers. */
	if (sc->sc_ep[SMSC_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_RX]);
		err = usbd_close_pipe(sc->sc_ep[SMSC_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[SMSC_ENDPT_RX] = NULL;
	}

	if (sc->sc_ep[SMSC_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_TX]);
		err = usbd_close_pipe(sc->sc_ep[SMSC_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[SMSC_ENDPT_TX] = NULL;
	}

	if (sc->sc_ep[SMSC_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_INTR]);
		err = usbd_close_pipe(sc->sc_ep[SMSC_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
		sc->sc_ep[SMSC_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < SMSC_RX_LIST_CNT; i++) {
		if (sc->sc_cdata.rx_chain[i].sc_mbuf != NULL) {
			m_freem(sc->sc_cdata.rx_chain[i].sc_mbuf);
			sc->sc_cdata.rx_chain[i].sc_mbuf = NULL;
		}
		if (sc->sc_cdata.rx_chain[i].sc_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.rx_chain[i].sc_xfer);
			sc->sc_cdata.rx_chain[i].sc_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < SMSC_TX_LIST_CNT; i++) {
		if (sc->sc_cdata.tx_chain[i].sc_mbuf != NULL) {
			m_freem(sc->sc_cdata.tx_chain[i].sc_mbuf);
			sc->sc_cdata.tx_chain[i].sc_mbuf = NULL;
		}
		if (sc->sc_cdata.tx_chain[i].sc_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.tx_chain[i].sc_xfer);
			sc->sc_cdata.tx_chain[i].sc_xfer = NULL;
		}
	}
}

int
smsc_chip_init(struct smsc_softc *sc)
{
	int err;
	uint32_t reg_val;
	int burst_cap;

	/* Enter H/W config mode */
	smsc_write_reg(sc, SMSC_HW_CFG, SMSC_HW_CFG_LRST);

	if ((err = smsc_wait_for_bits(sc, SMSC_HW_CFG,
	    SMSC_HW_CFG_LRST)) != 0) {
		smsc_warn_printf(sc, "timed-out waiting for reset to "
		    "complete\n");
		goto init_failed;
	}

	/* Reset the PHY */
	smsc_write_reg(sc, SMSC_PM_CTRL, SMSC_PM_CTRL_PHY_RST);

	if ((err = smsc_wait_for_bits(sc, SMSC_PM_CTRL,
	    SMSC_PM_CTRL_PHY_RST) != 0)) {
		smsc_warn_printf(sc, "timed-out waiting for phy reset to "
		    "complete\n");
		goto init_failed;
	}
	usbd_delay_ms(sc->sc_udev, 40);

	/* Set the mac address */
	if ((err = smsc_setmacaddress(sc, sc->sc_ac.ac_enaddr)) != 0) {
		smsc_warn_printf(sc, "failed to set the MAC address\n");
		goto init_failed;
	}

	/*
	 * Don't know what the HW_CFG_BIR bit is, but following the reset
	 * sequence as used in the Linux driver.
	 */
	if ((err = smsc_read_reg(sc, SMSC_HW_CFG, &reg_val)) != 0) {
		smsc_warn_printf(sc, "failed to read HW_CFG: %d\n", err);
		goto init_failed;
	}
	reg_val |= SMSC_HW_CFG_BIR;
	smsc_write_reg(sc, SMSC_HW_CFG, reg_val);

	/*
	 * There is a so called 'turbo mode' that the linux driver supports, it
	 * seems to allow you to jam multiple frames per Rx transaction.
	 * By default this driver supports that and therefore allows multiple
	 * frames per URB.
	 *
	 * The xfer buffer size needs to reflect this as well, therefore based
	 * on the calculations in the Linux driver the RX bufsize is set to
	 * 18944,
	 *     bufsz = (16 * 1024 + 5 * 512)
	 *
	 * Burst capability is the number of URBs that can be in a burst of
	 * data/ethernet frames.
	 */
#ifdef SMSC_TURBO
	if (sc->sc_udev->speed == USB_SPEED_HIGH)
		burst_cap = 37;
	else
		burst_cap = 128;
#else
	burst_cap = 0;
#endif

	smsc_write_reg(sc, SMSC_BURST_CAP, burst_cap);

	/* Set the default bulk in delay (magic value from Linux driver) */
	smsc_write_reg(sc, SMSC_BULK_IN_DLY, 0x00002000);



	/*
	 * Initialise the RX interface
	 */
	if ((err = smsc_read_reg(sc, SMSC_HW_CFG, &reg_val)) < 0) {
		smsc_warn_printf(sc, "failed to read HW_CFG: (err = %d)\n",
		    err);
		goto init_failed;
	}

	/*
	 * The following setings are used for 'turbo mode', a.k.a multiple
	 * frames per Rx transaction (again info taken form Linux driver).
	 */
#ifdef SMSC_TURBO
	reg_val |= (SMSC_HW_CFG_MEF | SMSC_HW_CFG_BCE);
#endif

	smsc_write_reg(sc, SMSC_HW_CFG, reg_val);

	/* Clear the status register ? */
	smsc_write_reg(sc, SMSC_INTR_STATUS, 0xffffffff);

	/* Read and display the revision register */
	if ((err = smsc_read_reg(sc, SMSC_ID_REV, &sc->sc_rev_id)) < 0) {
		smsc_warn_printf(sc, "failed to read ID_REV (err = %d)\n", err);
		goto init_failed;
	}

	/* GPIO/LED setup */
	reg_val = SMSC_LED_GPIO_CFG_SPD_LED | SMSC_LED_GPIO_CFG_LNK_LED | 
	          SMSC_LED_GPIO_CFG_FDX_LED;
	smsc_write_reg(sc, SMSC_LED_GPIO_CFG, reg_val);

	/*
	 * Initialise the TX interface
	 */
	smsc_write_reg(sc, SMSC_FLOW, 0);

	smsc_write_reg(sc, SMSC_AFC_CFG, AFC_CFG_DEFAULT);

	/* Read the current MAC configuration */
	if ((err = smsc_read_reg(sc, SMSC_MAC_CSR, &sc->sc_mac_csr)) < 0) {
		smsc_warn_printf(sc, "failed to read MAC_CSR (err=%d)\n", err);
		goto init_failed;
	}
	
	/* Vlan */
	smsc_write_reg(sc, SMSC_VLAN1, (uint32_t)ETHERTYPE_VLAN);

	/*
	 * Start TX
	 */
	sc->sc_mac_csr |= SMSC_MAC_CSR_TXEN;
	smsc_write_reg(sc, SMSC_MAC_CSR, sc->sc_mac_csr);
	smsc_write_reg(sc, SMSC_TX_CFG, SMSC_TX_CFG_ON);

	/*
	 * Start RX
	 */
	sc->sc_mac_csr |= SMSC_MAC_CSR_RXEN;
	smsc_write_reg(sc, SMSC_MAC_CSR, sc->sc_mac_csr);

	return (0);
	
init_failed:
	smsc_err_printf(sc, "smsc_chip_init failed (err=%d)\n", err);
	return (err);
}

int
smsc_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct smsc_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			smsc_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				smsc_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				smsc_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			smsc_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

int
smsc_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return UMATCH_NONE;

	return (usb_lookup(smsc_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE;
}

void
smsc_attach(struct device *parent, struct device *self, void *aux)
{
	struct smsc_softc *sc = (struct smsc_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct mii_data *mii;
	struct ifnet *ifp;
	uint32_t mac_h, mac_l;
	int s, i;

	sc->sc_udev = uaa->device;
	sc->sc_iface = uaa->iface;

	/* Setup the endpoints for the SMSC LAN95xx device(s) */
	usb_init_task(&sc->sc_tick_task, smsc_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->sc_mii_lock, "smscmii");
	usb_init_task(&sc->sc_stop_task, (void (*)(void *))smsc_stop, sc,
	    USB_TASK_TYPE_GENERIC);

	id = usbd_get_interface_descriptor(sc->sc_iface);

	if (sc->sc_udev->speed >= USB_SPEED_HIGH)
		sc->sc_bufsz = SMSC_MAX_BUFSZ;
	else
		sc->sc_bufsz = SMSC_MIN_BUFSZ;

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (!ed) {
			printf("%s: couldn't get ep %d\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_ed[SMSC_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->sc_ed[SMSC_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->sc_ed[SMSC_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	s = splnet();

	ifp = &sc->sc_ac.ac_if;
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = smsc_ioctl;
	ifp->if_start = smsc_start;
	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Setup some of the basics */
	sc->sc_phyno = 1;

	/*
	 * Attempt to get the mac address, if an EEPROM is not attached this
	 * will just return FF:FF:FF:FF:FF:FF, so in such cases we invent a MAC
	 * address based on urandom.
	 */
	memset(sc->sc_ac.ac_enaddr, 0xff, ETHER_ADDR_LEN);
	
	/* Check if there is already a MAC address in the register */
	if ((smsc_read_reg(sc, SMSC_MAC_ADDRL, &mac_l) == 0) &&
	    (smsc_read_reg(sc, SMSC_MAC_ADDRH, &mac_h) == 0)) {
		sc->sc_ac.ac_enaddr[5] = (uint8_t)((mac_h >> 8) & 0xff);
		sc->sc_ac.ac_enaddr[4] = (uint8_t)((mac_h) & 0xff);
		sc->sc_ac.ac_enaddr[3] = (uint8_t)((mac_l >> 24) & 0xff);
		sc->sc_ac.ac_enaddr[2] = (uint8_t)((mac_l >> 16) & 0xff);
		sc->sc_ac.ac_enaddr[1] = (uint8_t)((mac_l >> 8) & 0xff);
		sc->sc_ac.ac_enaddr[0] = (uint8_t)((mac_l) & 0xff);
	}

	smsc_enaddr_OF(sc);
	
	printf("%s: address %s\n", sc->sc_dev.dv_xname,
	    ether_sprintf(sc->sc_ac.ac_enaddr));
	
	/* Initialise the chip for the first time */
	smsc_chip_init(sc);

	/* Initialize MII/media info. */
	mii = &sc->sc_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = smsc_miibus_readreg;
	mii->mii_writereg = smsc_miibus_writereg;
	mii->mii_statchg = smsc_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;

	ifmedia_init(&mii->mii_media, 0, smsc_ifmedia_upd, smsc_ifmedia_sts);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_stat_ch, smsc_tick, sc);

	splx(s);
}

int
smsc_detach(struct device *self, int flags)
{
	struct smsc_softc *sc = (struct smsc_softc *)self;
	struct ifnet *ifp = &sc->sc_ac.ac_if;
	int s;

	if (timeout_initialized(&sc->sc_stat_ch))
		timeout_del(&sc->sc_stat_ch);

	if (sc->sc_ep[SMSC_ENDPT_TX] != NULL)
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_TX]);
	if (sc->sc_ep[SMSC_ENDPT_RX] != NULL)
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_RX]);
	if (sc->sc_ep[SMSC_ENDPT_INTR] != NULL)
		usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_INTR]);

	/*
	 * Remove any pending tasks.  They cannot be executing because they run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->sc_udev, &sc->sc_tick_task);
	usb_rem_task(sc->sc_udev, &sc->sc_stop_task);

	s = splusb();

	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away */
		usb_detach_wait(&sc->sc_dev);
	}

	if (ifp->if_flags & IFF_RUNNING)
		smsc_stop(sc);

	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->sc_ep[SMSC_ENDPT_TX] != NULL ||
	    sc->sc_ep[SMSC_ENDPT_RX] != NULL ||
	    sc->sc_ep[SMSC_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		    sc->sc_dev.dv_xname);
#endif

	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	return (0);
}

void
smsc_tick_task(void *xsc)
{
	int			 s;
	struct smsc_softc	*sc = xsc;
	struct mii_data		*mii;

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->sc_udev))
		return;
	mii = &sc->sc_mii;
	if (mii == NULL)
		return;

	s = splnet();

	mii_tick(mii);
	if ((sc->sc_flags & SMSC_FLAG_LINK) == 0)
		smsc_miibus_statchg(&sc->sc_dev);
	timeout_add_sec(&sc->sc_stat_ch, 1);

	splx(s);
}

void
smsc_lock_mii(struct smsc_softc *sc)
{
	sc->sc_refcnt++;
	rw_enter_write(&sc->sc_mii_lock);
}

void
smsc_unlock_mii(struct smsc_softc *sc)
{
	rw_exit_write(&sc->sc_mii_lock);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
}

void
smsc_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct smsc_chain	*c = (struct smsc_chain *)priv;
	struct smsc_softc	*sc = c->sc_sc;
	struct ifnet		*ifp = &sc->sc_ac.ac_if;
	u_char			*buf = c->sc_buf;
	uint32_t		total_len;
	uint16_t		pktlen = 0;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	int			s;
	uint32_t		rxhdr;

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			printf("%s: usb errors on rx: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(status));
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ep[SMSC_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);
	smsc_dbg_printf(sc, "xfer status total_len %d\n", total_len);

	do {
		if (total_len < sizeof(rxhdr)) {
			smsc_dbg_printf(sc, "total_len %d < sizeof(rxhdr) %d\n",
			    total_len, sizeof(rxhdr));
			ifp->if_ierrors++;
			goto done;
		}

		buf += pktlen;

		memcpy(&rxhdr, buf, sizeof(rxhdr));
		rxhdr = letoh32(rxhdr);
		total_len -= sizeof(rxhdr);

		if (rxhdr & SMSC_RX_STAT_ERROR) {
			smsc_dbg_printf(sc, "rx error (hdr 0x%08x)\n", rxhdr);
			ifp->if_ierrors++;
			goto done;
		}

		pktlen = (uint16_t)SMSC_RX_STAT_FRM_LENGTH(rxhdr);
		smsc_dbg_printf(sc, "rxeof total_len %d pktlen %d rxhdr "
		    "0x%08x\n", total_len, pktlen, rxhdr);
		if (pktlen > total_len) {
			smsc_dbg_printf(sc, "pktlen %d > total_len %d\n",
			    pktlen, total_len);
			ifp->if_ierrors++;
			goto done;
		}

		buf += sizeof(rxhdr);

		if (total_len < pktlen)
			total_len = 0;
		else
			total_len -= pktlen;
		
		m = m_devget(buf, pktlen, ETHER_ALIGN);
		if (m == NULL) {
			smsc_dbg_printf(sc, "m_devget returned NULL\n");
			ifp->if_ierrors++;
			goto done;
		}

		ml_enqueue(&ml, m);
	} while (total_len > 0);

done:
	s = splnet();
	if_input(ifp, &ml);
	splx(s);
	memset(c->sc_buf, 0, sc->sc_bufsz);

	/* Setup new transfer. */
	usbd_setup_xfer(xfer, sc->sc_ep[SMSC_ENDPT_RX],
	    c, c->sc_buf, sc->sc_bufsz,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, smsc_rxeof);
	usbd_transfer(xfer);

	return;
}

void
smsc_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct smsc_softc	*sc;
	struct smsc_chain	*c;
	struct ifnet		*ifp;
	int			s;

	c = priv;
	sc = c->sc_sc;
	ifp = &sc->sc_ac.ac_if;

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splnet();

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->sc_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_ep[SMSC_ENDPT_TX]);
		splx(s);
		return;
	}

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	m_freem(c->sc_mbuf);
	c->sc_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		smsc_start(ifp);

	splx(s);
}

int
smsc_tx_list_init(struct smsc_softc *sc)
{
	struct smsc_cdata *cd;
	struct smsc_chain *c;
	int i;

	cd = &sc->sc_cdata;
	for (i = 0; i < SMSC_TX_LIST_CNT; i++) {
		c = &cd->tx_chain[i];
		c->sc_sc = sc;
		c->sc_idx = i;
		c->sc_mbuf = NULL;
		if (c->sc_xfer == NULL) {
			c->sc_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->sc_xfer == NULL)
				return (ENOBUFS);
			c->sc_buf = usbd_alloc_buffer(c->sc_xfer,
			    sc->sc_bufsz);
			if (c->sc_buf == NULL) {
				usbd_free_xfer(c->sc_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
smsc_rx_list_init(struct smsc_softc *sc)
{
	struct smsc_cdata *cd;
	struct smsc_chain *c;
	int i;

	cd = &sc->sc_cdata;
	for (i = 0; i < SMSC_RX_LIST_CNT; i++) {
		c = &cd->rx_chain[i];
		c->sc_sc = sc;
		c->sc_idx = i;
		c->sc_mbuf = NULL;
		if (c->sc_xfer == NULL) {
			c->sc_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->sc_xfer == NULL)
				return (ENOBUFS);
			c->sc_buf = usbd_alloc_buffer(c->sc_xfer,
			    sc->sc_bufsz);
			if (c->sc_buf == NULL) {
				usbd_free_xfer(c->sc_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
smsc_encap(struct smsc_softc *sc, struct mbuf *m, int idx)
{
	struct smsc_chain	*c;
	usbd_status		 err;
	uint32_t		 txhdr;
	uint32_t		 frm_len = 0;

	c = &sc->sc_cdata.tx_chain[idx];

	/*
	 * Each frame is prefixed with two 32-bit values describing the
	 * length of the packet and buffer.
	 */
	txhdr = SMSC_TX_CTRL_0_BUF_SIZE(m->m_pkthdr.len) | 
			SMSC_TX_CTRL_0_FIRST_SEG | SMSC_TX_CTRL_0_LAST_SEG;
	txhdr = htole32(txhdr);
	memcpy(c->sc_buf, &txhdr, sizeof(txhdr));
	
	txhdr = SMSC_TX_CTRL_1_PKT_LENGTH(m->m_pkthdr.len);
	txhdr = htole32(txhdr);
	memcpy(c->sc_buf + 4, &txhdr, sizeof(txhdr));
	
	frm_len += 8;

	/* Next copy in the actual packet */
	m_copydata(m, 0, m->m_pkthdr.len, c->sc_buf + frm_len);
	frm_len += m->m_pkthdr.len;

	c->sc_mbuf = m;

	usbd_setup_xfer(c->sc_xfer, sc->sc_ep[SMSC_ENDPT_TX],
	    c, c->sc_buf, frm_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    10000, smsc_txeof);

	err = usbd_transfer(c->sc_xfer);
	if (err != USBD_IN_PROGRESS) {
		smsc_stop(sc);
		return (EIO);
	}

	sc->sc_cdata.tx_cnt++;

	return (0);
}
@


1.30
log
@The videocore portion of the raspberry pi which boots the arm cores and
runs the mailbox interface knows about a MAC address that appears to be
derived from a unique serial number along with the raspberry pi
foundation oui.

It modifies the device tree when booting to store the MAC address
in /axi/usb/hub/ethernet/mac-address so fetch and use this value
for the integrated smsc(4) Ethernet.

A different smsc adapter plugged into one of the USB ports
probes later with a different unit number and skips this path.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.29 2017/01/22 10:17:39 dlg Exp $	*/
d186 2
d194 7
a200 2
	 * Get the Raspberry Pi MAC address from FDT
	 * also available via mailbox interface
d202 2
a203 1
	if ((node = OF_finddevice("/axi/usb/hub/ethernet")) == -1)
d205 3
d209 7
a215 2
	OF_getprop(node, "mac-address", sc->sc_ac.ac_enaddr,
	    sizeof(sc->sc_ac.ac_enaddr));
@


1.29
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.28 2016/07/31 12:51:49 kettenis Exp $	*/
d179 26
d1022 2
@


1.28
log
@Use m_devget(9).

ok claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.27 2016/04/13 11:03:37 mpi Exp $	*/
a1264 1
	ifp->if_opackets++;
@


1.27
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.26 2016/01/20 01:31:01 jsg Exp $	*/
a148 1
struct mbuf	*smsc_newbuf(void);
d1199 1
a1199 1
		m = smsc_newbuf();
d1201 1
a1201 1
			smsc_dbg_printf(sc, "smc_newbuf returned NULL\n");
a1205 5
		m->m_pkthdr.len = m->m_len = pktlen;
		m_adj(m, ETHER_ALIGN);

		memcpy(mtod(m, char *), buf, pktlen);

a1324 18
}

struct mbuf *
smsc_newbuf(void)
{
	struct mbuf	*m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	return (m);
@


1.26
log
@remove an unused ifp variable
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.25 2015/11/25 03:10:00 dlg Exp $	*/
a1002 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.25
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.24 2015/11/24 17:11:40 mpi Exp $	*/
a1093 1
	struct ifnet		*ifp;
a1100 1
	ifp = &sc->sc_ac.ac_if;
@


1.24
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.23 2015/11/24 15:25:20 mpi Exp $	*/
d592 1
a592 1
	ifp->if_flags &= ~IFF_OACTIVE;
d607 1
a607 1
		(ifp->if_flags & IFF_OACTIVE) != 0) {
d617 1
a617 1
		ifp->if_flags |= IFF_OACTIVE;
d626 1
a626 1
	ifp->if_flags |= IFF_OACTIVE;
d654 2
a655 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1267 1
a1267 1
	ifp->if_flags &= ~IFF_OACTIVE;
@


1.23
log
@No need for "vlan.h" if you don't check for "#if NVLAN > 0".
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.22 2015/11/20 03:35:23 dlg Exp $	*/
a75 1
#include <net/if_dl.h>
@


1.22
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.21 2015/10/25 12:11:56 mpi Exp $	*/
a61 1
#include "vlan.h"
@


1.21
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.20 2015/06/24 09:40:54 mpi Exp $	*/
d613 1
a613 1
	IFQ_POLL(&ifp->if_snd, m_head);
d618 1
d622 1
a622 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.20
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.19 2015/06/18 09:28:54 mpi Exp $	*/
a863 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a872 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.19
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tested by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.18 2015/03/23 22:48:51 jsg Exp $	*/
a1213 1
		ifp->if_ipackets++;
@


1.18
log
@unlock MII on smsc_miibus_writereg error
from Patrick Wildt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.17 2015/03/23 08:41:52 mpi Exp $	*/
d914 1
a914 1
	if (uaa->iface != NULL)
d918 1
a918 1
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE;
a925 1
	struct usbd_device *dev = uaa->device;
a929 1
	int err, s, i;
d931 1
d933 2
a934 3
	sc->sc_udev = dev;

	err = usbd_set_config_no(dev, SMSC_CONFIG_INDEX, 1);
a941 7

	err = usbd_device2interface_handle(dev, SMSC_IFACE_IDX, &sc->sc_iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.17
log
@Convert to if_input(), tested by jsg@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.16 2015/03/19 02:02:43 jsg Exp $	*/
d281 1
@


1.16
log
@unlock MII on smsc_miibus_readreg error
from Patrick Wildt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.15 2015/03/14 03:38:49 jsg Exp $	*/
d1152 1
a1222 1
		m->m_pkthdr.rcvif = ifp;
d1228 1
a1228 9
		/* push the packet up */
		s = splnet();
#if NBPFILTER > 0
		if (ifp->if_bpf)
			bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif
		ether_input_mbuf(ifp, m);

		splx(s);
d1232 3
@


1.15
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.14 2014/12/22 02:28:52 tedu Exp $	*/
d263 2
a265 2
	
done:
@


1.14
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.13 2014/07/13 15:52:49 mpi Exp $	*/
a86 1
#include <dev/mii/mii.h>
@


1.13
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.12 2014/07/12 07:59:23 mpi Exp $	*/
a83 1
#ifdef INET
a85 1
#endif
a873 1
#ifdef INET
a875 1
#endif
@


1.12
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.11 2014/03/07 18:39:02 mpi Exp $	*/
a85 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
@


1.11
log
@Do not define per-driver DEBUG variable when USB_DEBUG is defined.  It's
really impossible to debug the USB stack when any single device you plug
in your machine starts to vomit its own poetry,
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.10 2013/11/15 10:17:39 pirofti Exp $	*/
a150 1
int		 smsc_activate(struct device *, int);
d184 1
a184 5
	sizeof(struct smsc_softc),
	smsc_match,
	smsc_attach,
	smsc_detach,
	smsc_activate
a1132 13
}

int
smsc_activate(struct device *self, int act)
{
	struct smsc_softc *sc = (struct smsc_softc *)self;

        switch (act) {
        case DVACT_DEACTIVATE:
                usbd_deactivate(sc->sc_udev);
                break;
        }
        return (0);
@


1.10
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.9 2013/08/07 01:06:42 bluhm Exp $	*/
a101 4
#ifdef USB_DEBUG
static int smsc_debug = 0;
#endif

d126 2
a127 1
#ifdef USB_DEBUG
@


1.9
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.8 2013/07/02 19:27:15 brad Exp $	*/
d673 1
a673 5
		err = usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
d683 1
a683 5
		err = usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
d693 1
a693 5
		err = usbd_abort_pipe(sc->sc_ep[SMSC_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
		}
@


1.8
log
@Rearrange the inequalities.

Pointed out by LLVM.

if_axe.c:1059:29: error: comparison of unsigned expression < 0 is always false
if_smsc.c:1250:28: error: comparison of unsigned expression < 0 is always false

ok jsg@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.7 2013/04/15 09:23:01 mglocker Exp $	*/
a86 1
#include <netinet/in_var.h>
@


1.7
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.6 2013/03/28 03:58:03 tedu Exp $	*/
d1250 1
a1250 1
		if ((total_len - pktlen) < 0)
@


1.6
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.5 2012/11/10 18:48:22 brad Exp $	*/
d176 2
a177 2
void		 smsc_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void		 smsc_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d953 1
a953 1
	usbd_device_handle dev = uaa->device;
d1185 1
a1185 1
smsc_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1294 1
a1294 1
smsc_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.5
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.4 2012/09/27 12:38:11 jsg Exp $	*/
a69 1
#include <sys/proc.h>
@


1.4
log
@Use a smaller buffer size when not attached to a high speed/usb2
controller.  Makes smsc work when attached to usb1 controllers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.3 2012/09/27 12:05:02 jsg Exp $	*/
d150 1
a150 1
void		 smsc_setmulti(struct smsc_softc *);
d421 1
a421 1
smsc_setmulti(struct smsc_softc *sc)
d424 1
d433 6
a438 3
	if (ifp->if_flags & (IFF_ALLMULTI | IFF_PROMISC)) {
allmulti:
		smsc_dbg_printf(sc, "receive all multicast enabled\n");
d440 2
a441 3
		sc->sc_mac_csr &= ~SMSC_MAC_CSR_HPFILT;
		smsc_write_reg(sc, SMSC_MAC_CSR, sc->sc_mac_csr);
		return;
d444 9
a452 12
		sc->sc_mac_csr &= ~(SMSC_MAC_CSR_PRMS | SMSC_MAC_CSR_MCPAS);
	}
		
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
		    ETHER_ADDR_LEN) != 0)
			goto allmulti;

		hash = smsc_hash(enm->enm_addrlo);
		hashtbl[hash >> 5] |= 1 << (hash & 0x1F);
		ETHER_NEXT_MULTI(step, enm);
d456 3
a458 1
	if (sc->sc_mac_csr & SMSC_MAC_CSR_HPFILT)
a459 2
	else
		smsc_dbg_printf(sc, "receive own packets only\n");
a461 1
	ifp->if_flags &= ~IFF_ALLMULTI;
d571 2
a572 2
	/* Load the multicast filter. */
	smsc_setmulti(sc);
a890 1
	struct mii_data		*mii;
d908 3
a910 15
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->sc_if_flags & IFF_PROMISC)) {
				sc->sc_mac_csr |= SMSC_MAC_CSR_PRMS;
				smsc_write_reg(sc, SMSC_MAC_CSR,
				    sc->sc_mac_csr);
				smsc_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    sc->sc_if_flags & IFF_PROMISC) {
				sc->sc_mac_csr &= ~SMSC_MAC_CSR_PRMS;
				smsc_write_reg(sc, SMSC_MAC_CSR,
				    sc->sc_mac_csr);
				smsc_setmulti(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
a915 1
		sc->sc_if_flags = ifp->if_flags;
d920 1
a920 2
		mii = &sc->sc_mii;
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
d929 1
a929 1
			smsc_setmulti(sc);
@


1.3
log
@make smsc work on big endian archs
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.2 2012/09/19 16:51:10 jsg Exp $	*/
d598 1
a598 1
		    c, c->sc_buf, SMSC_BUFSZ,
d998 5
d1298 1
a1298 1
	memset(c->sc_buf, 0, SMSC_BUFSZ);
d1302 1
a1302 1
	    c, c->sc_buf, SMSC_BUFSZ,
d1372 1
a1372 1
			    SMSC_BUFSZ);
d1401 1
a1401 1
			    SMSC_BUFSZ);
@


1.2
log
@match some more LAN95xx device ids
@
text
@d1 1
a1 1
/*	$OpenBSD: if_smsc.c,v 1.1 2012/09/19 16:33:04 jsg Exp $	*/
a278 1
	val = letoh32(val);
a298 1
	val = htole32(val);
@


1.1
log
@SMSC LAN95xx 10/100 USB Ethernet driver, ported from FreeBSD.

'turbo mode' having multiple rx packets in a single usb transaction
similiar to what newer asix chips do is disabled as it seems to cause
many rx errors and breaks fragmentation.

checksum offloading while apparently supported by the hardware is
currently disabled.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d112 18
a129 1
	{ USB_VENDOR_SMC2,	USB_PRODUCT_SMC2_SMSC9512_14 }
@

