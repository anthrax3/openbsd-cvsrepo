head	1.43;
access;
symbols
	OPENBSD_6_2_BASE:1.43
	OPENBSD_6_1:1.43.0.8
	OPENBSD_6_1_BASE:1.43
	OPENBSD_6_0:1.43.0.6
	OPENBSD_6_0_BASE:1.43
	OPENBSD_5_9:1.43.0.2
	OPENBSD_5_9_BASE:1.43
	OPENBSD_5_8:1.40.0.6
	OPENBSD_5_8_BASE:1.40
	OPENBSD_5_7:1.40.0.2
	OPENBSD_5_7_BASE:1.40
	OPENBSD_5_6:1.38.0.6
	OPENBSD_5_6_BASE:1.38
	OPENBSD_5_5:1.38.0.4
	OPENBSD_5_5_BASE:1.38
	OPENBSD_5_4:1.35.0.10
	OPENBSD_5_4_BASE:1.35
	OPENBSD_5_3:1.35.0.8
	OPENBSD_5_3_BASE:1.35
	OPENBSD_5_2:1.35.0.6
	OPENBSD_5_2_BASE:1.35
	OPENBSD_5_1_BASE:1.35
	OPENBSD_5_1:1.35.0.4
	OPENBSD_5_0:1.35.0.2
	OPENBSD_5_0_BASE:1.35
	OPENBSD_4_9:1.33.0.4
	OPENBSD_4_9_BASE:1.33
	OPENBSD_4_8:1.33.0.2
	OPENBSD_4_8_BASE:1.33
	OPENBSD_4_7:1.31.0.2
	OPENBSD_4_7_BASE:1.31
	OPENBSD_4_6:1.29.0.8
	OPENBSD_4_6_BASE:1.29
	OPENBSD_4_5:1.29.0.4
	OPENBSD_4_5_BASE:1.29
	OPENBSD_4_4:1.29.0.2
	OPENBSD_4_4_BASE:1.29
	OPENBSD_4_3:1.26.0.2
	OPENBSD_4_3_BASE:1.26
	OPENBSD_4_2:1.25.0.2
	OPENBSD_4_2_BASE:1.25
	OPENBSD_4_1:1.17.0.2
	OPENBSD_4_1_BASE:1.17
	OPENBSD_4_0:1.17.0.4
	OPENBSD_4_0_BASE:1.17
	OPENBSD_3_9:1.16.0.2
	OPENBSD_3_9_BASE:1.16
	OPENBSD_3_8:1.15.0.4
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.2
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.14.0.4
	OPENBSD_3_6_BASE:1.14
	SMP_SYNC_A:1.13
	SMP_SYNC_B:1.13
	OPENBSD_3_5:1.13.0.4
	OPENBSD_3_5_BASE:1.13
	OPENBSD_3_4:1.13.0.2
	OPENBSD_3_4_BASE:1.13
	UBC_SYNC_A:1.12
	OPENBSD_3_3:1.12.0.2
	OPENBSD_3_3_BASE:1.12
	OPENBSD_3_2:1.11.0.2
	OPENBSD_3_2_BASE:1.11
	OPENBSD_3_1:1.6.0.4
	OPENBSD_3_1_BASE:1.6
	UBC_SYNC_B:1.11
	UBC:1.6.0.2
	UBC_BASE:1.6
	OPENBSD_3_0:1.5.0.4
	OPENBSD_3_0_BASE:1.5
	SMP:1.5.0.2
	OPENBSD_2_9_BASE:1.4
	OPENBSD_2_9:1.4.0.2
	OPENBSD_2_8:1.2.0.2
	OPENBSD_2_8_BASE:1.2;
locks; strict;
comment	@ * @;


1.43
date	2016.01.12.19.16.21;	author jcs;	state Exp;
branches;
next	1.42;
commitid	Sn97Jww24us5dd5Z;

1.42
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.41;
commitid	KAeCDAijcgEnOtfF;

1.41
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.40;
commitid	kI4H556ZKYkRQGw5;

1.40
date	2014.12.28.15.24.08;	author matthieu;	state Exp;
branches;
next	1.39;
commitid	owW4mWj6fT5xK7Lj;

1.39
date	2014.08.21.14.52.56;	author mpi;	state Exp;
branches;
next	1.38;
commitid	nyUgTgf8DHNH5RDf;

1.38
date	2013.11.15.08.17.44;	author pirofti;	state Exp;
branches;
next	1.37;

1.37
date	2013.08.15.15.01.48;	author edd;	state Exp;
branches;
next	1.36;

1.36
date	2013.08.09.22.10.17;	author edd;	state Exp;
branches;
next	1.35;

1.35
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.34;

1.34
date	2011.03.04.23.57.52;	author kettenis;	state Exp;
branches;
next	1.33;

1.33
date	2010.08.02.23.17.34;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2010.07.31.16.04.50;	author miod;	state Exp;
branches;
next	1.31;

1.31
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.30;

1.30
date	2009.07.26.13.10.41;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.28;

1.28
date	2008.05.08.15.02.01;	author miod;	state Exp;
branches;
next	1.27;

1.27
date	2008.05.08.13.57.43;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2007.09.17.01.40.38;	author fgsch;	state Exp;
branches;
next	1.25;

1.25
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.24;

1.24
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.23;

1.23
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.22;

1.22
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.21;

1.21
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.20;

1.20
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.10.22.37.17;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.16;

1.16
date	2005.11.21.18.16.44;	author millert;	state Exp;
branches;
next	1.15;

1.15
date	2004.12.06.11.08.23;	author dlg;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2003.05.19.00.37.19;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.3;

1.3
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.07.22.17.48;	author matthieu;	state Exp;
branches;
next	1.1;

1.1
date	2000.09.07.21.58.50;	author matthieu;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.23;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.43.58;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.5.2.5;

1.5.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	;

1.6.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2003.05.19.22.26.19;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.43
log
@properly initialize quirks before sending them to hid layer, broken
during hid abstraction

problem noticed and fix tested by abieber
@
text
@/*	$OpenBSD: ums.c,v 1.42 2016/01/09 04:14:42 jcs Exp $ */
/*	$NetBSD: ums.c,v 1.60 2003/03/11 16:44:00 augustss Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/ioctl.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>
#include <dev/usb/usb_quirks.h>
#include <dev/usb/uhidev.h>

#include <dev/wscons/wsconsio.h>
#include <dev/wscons/wsmousevar.h>

#include <dev/hid/hidmsvar.h>

struct ums_softc {
	struct uhidev	sc_hdev;
	struct hidms	sc_ms;
};

void ums_intr(struct uhidev *addr, void *ibuf, u_int len);

int	ums_enable(void *);
void	ums_disable(void *);
int	ums_ioctl(void *, u_long, caddr_t, int, struct proc *);

const struct wsmouse_accessops ums_accessops = {
	ums_enable,
	ums_ioctl,
	ums_disable,
};

int ums_match(struct device *, void *, void *);
void ums_attach(struct device *, struct device *, void *);
int ums_detach(struct device *, int);

struct cfdriver ums_cd = {
	NULL, "ums", DV_DULL
};

const struct cfattach ums_ca = {
	sizeof(struct ums_softc), ums_match, ums_attach, ums_detach
};

int
ums_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	int size;
	void *desc;

	uhidev_get_report_desc(uha->parent, &desc, &size);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_POINTER)))
		return (UMATCH_IFACECLASS);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		return (UMATCH_IFACECLASS);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_DIGITIZERS, HUD_TOUCHSCREEN)))
		return (UMATCH_IFACECLASS);

	if (hid_is_collection(desc, size, uha->reportid,
	    HID_USAGE2(HUP_DIGITIZERS, HUD_PEN)))
		return (UMATCH_IFACECLASS);

	return (UMATCH_NONE);
}

void
ums_attach(struct device *parent, struct device *self, void *aux)
{
	struct ums_softc *sc = (struct ums_softc *)self;
	struct hidms *ms = &sc->sc_ms;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	struct usb_attach_arg *uaa = uha->uaa;
	int size, repid;
	void *desc;
	u_int32_t quirks, qflags = 0;

	sc->sc_hdev.sc_intr = ums_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_udev = uaa->device;
	sc->sc_hdev.sc_report_id = uha->reportid;

	quirks = usbd_get_quirks(sc->sc_hdev.sc_udev)->uq_flags;
	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_hdev.sc_isize = hid_report_size(desc, size, hid_input, repid);
	sc->sc_hdev.sc_osize = hid_report_size(desc, size, hid_output, repid);
	sc->sc_hdev.sc_fsize = hid_report_size(desc, size, hid_feature, repid);

	if (quirks & UQ_MS_REVZ)
		qflags |= HIDMS_REVZ;
	if (quirks & UQ_SPUR_BUT_UP)
		qflags |= HIDMS_SPUR_BUT_UP;
	if (quirks & UQ_MS_BAD_CLASS)
		qflags |= HIDMS_MS_BAD_CLASS;
	if (quirks & UQ_MS_LEADING_BYTE)
		qflags |= HIDMS_LEADINGBYTE;

	if (hidms_setup(self, ms, qflags, uha->reportid, desc, size) != 0)
		return;

	/*
	 * The Microsoft Wireless Notebook Optical Mouse 3000 Model 1049 has
	 * five Report IDs: 19, 23, 24, 17, 18 (in the order they appear in
	 * report descriptor), it seems that report 17 contains the necessary
	 * mouse information (3-buttons, X, Y, wheel) so we specify it
	 * manually.
	 */
	if (uaa->vendor == USB_VENDOR_MICROSOFT &&
	    uaa->product == USB_PRODUCT_MICROSOFT_WLNOTEBOOK3) {
		ms->sc_flags = HIDMS_Z;
		ms->sc_num_buttons = 3;
		/* XXX change sc_hdev isize to 5? */
		ms->sc_loc_x.pos = 8;
		ms->sc_loc_y.pos = 16;
		ms->sc_loc_z.pos = 24;
		ms->sc_loc_btn[0].pos = 0;
		ms->sc_loc_btn[1].pos = 1;
		ms->sc_loc_btn[2].pos = 2;
	}

	hidms_attach(ms, &ums_accessops);
}

int
ums_detach(struct device *self, int flags)
{
	struct ums_softc *sc = (struct ums_softc *)self;
	struct hidms *ms = &sc->sc_ms;

	return hidms_detach(ms, flags);
}

void
ums_intr(struct uhidev *addr, void *buf, u_int len)
{
	struct ums_softc *sc = (struct ums_softc *)addr;
	struct hidms *ms = &sc->sc_ms;

	if (ms->sc_enabled != 0)
		hidms_input(ms, (uint8_t *)buf, len);
}

int
ums_enable(void *v)
{
	struct ums_softc *sc = v;
	struct hidms *ms = &sc->sc_ms;
	int rv;

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return EIO;

	if ((rv = hidms_enable(ms)) != 0)
		return rv;

	return uhidev_open(&sc->sc_hdev);
}

void
ums_disable(void *v)
{
	struct ums_softc *sc = v;
	struct hidms *ms = &sc->sc_ms;

	hidms_disable(ms);
	uhidev_close(&sc->sc_hdev);
}

int
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
{
	struct ums_softc *sc = v;
	struct hidms *ms = &sc->sc_ms;
	int rc;

	rc = uhidev_ioctl(&sc->sc_hdev, cmd, data, flag, p);
	if (rc != -1)
		return rc;
	rc = hidms_ioctl(ms, cmd, data, flag, p);
	if (rc != -1)
		return rc;

	switch (cmd) {
	case WSMOUSEIO_GTYPE:
		*(u_int *)data = WSMOUSE_TYPE_USB;
		return 0;
	default:
		return -1;
	}
}
@


1.42
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.41 2016/01/08 15:54:14 jcs Exp $ */
d124 1
a124 1
	u_int32_t quirks, qflags;
@


1.41
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.40 2014/12/28 15:24:08 matthieu Exp $ */
a55 1
#include <dev/hid/hid.h>
@


1.40
log
@Attach USB HID devices from the Generic Destop page, usage pointer to
ums. This is how the USB Tablet from Qemu in libvirt/kvm shows up and
it works with ums(4). ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.39 2014/08/21 14:52:56 mpi Exp $ */
a51 1
#include <dev/usb/hid.h>
d56 2
a57 1
#include <dev/usb/hidmsvar.h>
d125 1
a125 1
	u_int32_t quirks;
d139 10
a148 1
	if (hidms_setup(self, ms, quirks, uha->reportid, desc, size) != 0)
@


1.39
log
@Now that DVACT_DEACTIVATE is propagated to the children of a device when
a driver does not implement a specific *_activate() handler and that our
USB stack sets the dying flag before detaching a device, these specific
handlers can die.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.38 2013/11/15 08:17:44 pirofti Exp $ */
d96 4
@


1.38
log
@Clean-up the HID environment.


This set of drivers were very very dirty.

i/ Clean-up the match/attach multi-casting hackjob
	- stop casting aux to every attach arg in existance
	- be consistent about casting it only to uhidev_attach_arg
	- fetch the usb_attach_arg from above where needed

ii/ Sort out the activate routines
	- leave the deactivation to the parent (uhidev(4))
	- ditch the sc_dying flag in favour of usbd_is_dying()

iii/ Get closer to keeping all the usb hid information in the uhidev
     structure (one uhidev per reportID)
	- store the usbd_device in the uhidev
	- use it consistently instead of always peaking at the parent's
 	  soft state

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.37 2013/08/15 15:01:48 edd Exp $ */
d76 10
a85 15
int ums_match(struct device *, void *, void *); 
void ums_attach(struct device *, struct device *, void *); 
int ums_detach(struct device *, int); 
int ums_activate(struct device *, int); 

struct cfdriver ums_cd = { 
	NULL, "ums", DV_DULL 
}; 

const struct cfattach ums_ca = { 
	sizeof(struct ums_softc), 
	ums_match, 
	ums_attach, 
	ums_detach, 
	ums_activate, 
a158 16
}

int
ums_activate(struct device *self, int act)
{
	struct ums_softc *sc = (struct ums_softc *)self;
	struct hidms *ms = &sc->sc_ms;
	int rv = 0;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (ms->sc_wsmousedev != NULL)
			rv = config_deactivate(ms->sc_wsmousedev);
		break;
	}
	return (rv);
@


1.37
log
@Blast uhts(4). This code was merged into ums(4) last week.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.36 2013/08/09 22:10:17 edd Exp $ */
a61 1
	char		sc_dying;
d96 1
a96 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d122 2
a123 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d130 1
d133 1
a133 1
	quirks = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
a176 1
		sc->sc_dying = 1;
d208 1
a208 1
	if (sc->sc_dying)
@


1.36
log
@Merge uhts(1) into ums(1). The code is amost the same, so no need to duplicate.

A part of ongoing work to improve touchscreen/digitiser support.

A diff will follow shortly to remove uhts(1).

OK matthieu@@, with input from mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.35 2011/07/03 15:47:17 matthew Exp $ */
a107 4
	/*
	 * For now return a value higher than UMATCH_IFACECLASS to make sure
	 * touchscreens and digitizers no longer attach to uhts(4).
	 */
d110 1
a110 2
		return (UMATCH_IFACECLASS_IFACESUBCLASS); /* XXX */
		/* return (UMATCH_IFACECLASS); */
d114 1
a114 2
		return (UMATCH_IFACECLASS_IFACESUBCLASS); /* XXX */
		/* return (UMATCH_IFACECLASS); */
@


1.35
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.34 2011/03/04 23:57:52 kettenis Exp $ */
a102 3
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		return (UMATCH_NONE);
d104 19
a122 1
	return (UMATCH_IFACECLASS);
@


1.34
log
@Add TouchScreen support.  Makes newer Gunze USB TouchScreen devices work.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.33 2010/08/02 23:17:34 miod Exp $ */
a165 3
	case DVACT_ACTIVATE:
		break;

@


1.33
log
@Handle USB_GET_REPORT, USB_GET_REPORT_DESC, USB_GET_REPORT_ID and
USB_SET_REPORT ioctls in ukbd and ums.
This allows usbhidctl to be used on these devices e.g. to dump the report
descriptor of troublesome models.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.32 2010/07/31 16:04:50 miod Exp $ */
d230 7
d242 1
a242 5
		rc = uhidev_ioctl(&sc->sc_hdev, cmd, data, flag, p);
		if (rc != -1)
			return rc;
		else
			return hidms_ioctl(ms, cmd, data, flag, p);
@


1.32
log
@Factorization of the bluetooth and usb hid input driver logic, to reduce code
duplication and divergence.
Thanks to mlarkin@@ for bluetooth devices tests.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.31 2009/10/13 19:33:19 pirofti Exp $ */
d117 1
a117 1
	int size;
d127 4
d228 1
d235 5
a239 1
		return hidms_ioctl(ms, cmd, data, flag, p);
@


1.31
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.30 2009/07/26 13:10:41 miod Exp $ */
a42 6
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/poll.h>
d57 1
a57 14
#ifdef USB_DEBUG
#define DPRINTF(x)	do { if (umsdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (umsdebug>(n)) printf x; } while (0)
int	umsdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UMS_BUT(i) ((i) == 1 || (i) == 2 ? 3 - (i) : i)

#define UMSUNIT(s)	(minor(s))

#define MAX_BUTTONS	16	/* must not exceed size of sc_buttons */
d60 3
a62 21
	struct uhidev sc_hdev;

	struct hid_location sc_loc_x, sc_loc_y, sc_loc_z, sc_loc_w;
	struct hid_location sc_loc_btn[MAX_BUTTONS];

	int sc_enabled;

	int flags;		/* device configuration */
#define UMS_Z		0x01	/* Z direction available */
#define UMS_SPUR_BUT_UP	0x02	/* spurious button up events */
#define UMS_REVZ	0x04	/* Z-axis is reversed */
#define UMS_W		0x08	/* W direction available */
#define UMS_REVW	0x10	/* W-axis is reversed */
#define UMS_LEADINGBYTE	0x20	/* Unknown leading byte */

	int nbuttons;

	u_int32_t sc_buttons;	/* mouse button status */
	struct device *sc_wsmousedev;

	char			sc_dying;
a64 3
#define MOUSE_FLAGS_MASK (HIO_CONST|HIO_RELATIVE)
#define MOUSE_FLAGS (HIO_RELATIVE)

d114 1
a116 1
	struct wsmousedev_attach_args a;
d119 1
a119 2
	u_int32_t flags, quirks;
	int i, wheel, twheel;
a125 7
	if (quirks & UQ_MS_REVZ)
		sc->flags |= UMS_REVZ;
	if (quirks & UQ_SPUR_BUT_UP)
		sc->flags |= UMS_SPUR_BUT_UP;
	if (quirks & UQ_MS_LEADING_BYTE)
		sc->flags |= UMS_LEADINGBYTE;

d128 1
a128 9
	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_X),
	       uha->reportid, hid_input, &sc->sc_loc_x, &flags)) {
		printf("\n%s: mouse has no X report\n",
		       sc->sc_hdev.sc_dev.dv_xname);
		return;
	}
	if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
		printf("\n%s: X report 0x%04x not supported\n",
		       sc->sc_hdev.sc_dev.dv_xname, flags);
a129 108
	}

	if (!hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Y),
	       uha->reportid, hid_input, &sc->sc_loc_y, &flags)) {
		printf("\n%s: mouse has no Y report\n",
		       sc->sc_hdev.sc_dev.dv_xname);
		return;
	}
	if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
		printf("\n%s: Y report 0x%04x not supported\n",
		       sc->sc_hdev.sc_dev.dv_xname, flags);
		return;
	}

	/*
	 * Try to guess the Z activator: check WHEEL, TWHEEL, and Z,
	 * in that order.
	 */

	wheel = hid_locate(desc, size,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_WHEEL),
	    uha->reportid, hid_input, &sc->sc_loc_z, &flags);
	if (wheel == 0)
		twheel = hid_locate(desc, size,
		    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_TWHEEL),
		    uha->reportid, hid_input, &sc->sc_loc_z, &flags);
	else
		twheel = 0;

	if (wheel || twheel) {
		if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
			DPRINTF(("\n%s: Wheel report 0x%04x not supported\n",
				sc->sc_hdev.sc_dev.dv_xname, flags));
			sc->sc_loc_z.size = 0; /* Bad Z coord, ignore it */
		} else {
			sc->flags |= UMS_Z;
			/* Wheels need the Z axis reversed. */
			sc->flags ^= UMS_REVZ;
		}
		/*
		 * We might have both a wheel and Z direction; in this case,
		 * report the Z direction on the W axis.
		*/
		if (hid_locate(desc, size,
		    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
		    uha->reportid, hid_input, &sc->sc_loc_w, &flags)) {
			if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
				DPRINTF(("\n%s: Z report 0x%04x not supported\n",
					sc->sc_hdev.sc_dev.dv_xname, flags));
				/* Bad Z coord, ignore it */
				sc->sc_loc_w.size = 0;
			}
			else
				sc->flags |= UMS_W;
		}
	} else if (hid_locate(desc, size,
	    HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
	    uha->reportid, hid_input, &sc->sc_loc_z, &flags)) {
		if ((flags & MOUSE_FLAGS_MASK) != MOUSE_FLAGS) {
			DPRINTF(("\n%s: Z report 0x%04x not supported\n",
				sc->sc_hdev.sc_dev.dv_xname, flags));
			sc->sc_loc_z.size = 0; /* Bad Z coord, ignore it */
		} else {
			sc->flags |= UMS_Z;
		}
	}

	/*
	 * The Microsoft Wireless Intellimouse 2.0 reports its wheel
	 * using 0x0048 (I've called it HUG_TWHEEL) and seems to expect
	 * us to know that the byte after the wheel is the tilt axis.
	 * There are no other HID axis descriptors other than X, Y and
	 * TWHEEL, so we report TWHEEL on the W axis.
	 */
	if (twheel) {
		sc->sc_loc_w = sc->sc_loc_z;
		sc->sc_loc_w.pos = sc->sc_loc_w.pos + 8;
		sc->flags |= UMS_W | UMS_LEADINGBYTE;
		/* Wheels need their axis reversed. */
		sc->flags ^= UMS_REVW;
	}

	/* figure out the number of buttons */
	for (i = 1; i <= MAX_BUTTONS; i++)
		if (!hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
		    uha->reportid, hid_input, &sc->sc_loc_btn[i - 1], 0))
			break;
	sc->nbuttons = i - 1;

	/*
	 * The Microsoft Wireless Notebook Optical Mouse seems to be in worse
	 * shape than the Wireless Intellimouse 2.0, as its X, Y, wheel, and
	 * all of its other button positions are all off. It also reports that
	 * it has two addional buttons and a tilt wheel.
	 */
	if (quirks & UQ_MS_BAD_CLASS) {
		/* UMS_LEADINGBYTE cleared on purpose */
		sc->flags = UMS_Z | UMS_SPUR_BUT_UP;
		sc->nbuttons = 3;
		/* XXX change sc_hdev isize to 5? */
		/* 1st byte of descriptor report contains garbage */
		sc->sc_loc_x.pos = 16;
		sc->sc_loc_y.pos = 24;
		sc->sc_loc_z.pos = 32;
		sc->sc_loc_btn[0].pos = 8;
		sc->sc_loc_btn[1].pos = 9;
		sc->sc_loc_btn[2].pos = 10;
	}
d140 2
a141 2
		sc->flags = UMS_Z;
		sc->nbuttons = 3;
d143 6
a148 20
		sc->sc_loc_x.pos = 8;
		sc->sc_loc_y.pos = 16;
		sc->sc_loc_z.pos = 24;
		sc->sc_loc_btn[0].pos = 0;
		sc->sc_loc_btn[1].pos = 1;
		sc->sc_loc_btn[2].pos = 2;
	}

	printf(": %d button%s",
	    sc->nbuttons, sc->nbuttons <= 1 ? "" : "s");
	switch (sc->flags & (UMS_Z | UMS_W)) {
	case UMS_Z:
		printf(", Z dir");
		break;
	case UMS_W:
		printf(", W dir");
		break;
	case UMS_Z | UMS_W:
		printf(", Z and W dir");
		break;
a149 1
	printf("\n");
d151 1
a151 22
#ifdef USB_DEBUG
	DPRINTF(("ums_attach: sc=%p\n", sc));
	DPRINTF(("ums_attach: X\t%d/%d\n",
	     sc->sc_loc_x.pos, sc->sc_loc_x.size));
	DPRINTF(("ums_attach: Y\t%d/%d\n",
	    sc->sc_loc_y.pos, sc->sc_loc_y.size));
	if (sc->flags & UMS_Z)
		DPRINTF(("ums_attach: Z\t%d/%d\n",
		    sc->sc_loc_z.pos, sc->sc_loc_z.size));
	if (sc->flags & UMS_W)
		DPRINTF(("ums_attach: W\t%d/%d\n",
		    sc->sc_loc_w.pos, sc->sc_loc_w.size));
	for (i = 1; i <= sc->nbuttons; i++) {
		DPRINTF(("ums_attach: B%d\t%d/%d\n",
		    i, sc->sc_loc_btn[i - 1].pos, sc->sc_loc_btn[i - 1].size));
	}
#endif

	a.accessops = &ums_accessops;
	a.accesscookie = sc;

	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
d158 1
d166 2
a167 2
		if (sc->sc_wsmousedev != NULL)
			rv = config_deactivate(sc->sc_wsmousedev);
d178 1
a178 1
	int rv = 0;
d180 1
a180 7
	DPRINTF(("ums_detach: sc=%p flags=%d\n", sc, flags));

	/* No need to do reference counting of ums, wsmouse has all the goo. */
	if (sc->sc_wsmousedev != NULL)
		rv = config_detach(sc->sc_wsmousedev, flags);

	return (rv);
d187 1
a187 5
	u_char *ibuf = (u_char *)buf;
	int dx, dy, dz, dw;
	u_int32_t buttons = 0;
	int i;
	int s;
d189 2
a190 48
	DPRINTFN(5,("ums_intr: len=%d\n", len));

	/*
	 * The Microsoft Wireless Intellimouse 2.0 sends one extra leading
	 * byte of data compared to most USB mice.  This byte frequently
	 * switches from 0x01 (usual state) to 0x02.  It may be used to
	 * report non-standard events (such as battery life).  However,
	 * at the same time, it generates a left click event on the
	 * button byte, where there shouldn't be any.  We simply discard
	 * the packet in this case.
	 *
	 * This problem affects the MS Wireless Notebook Optical Mouse, too.
	 * However, the leading byte for this mouse is normally 0x11, and
	 * the phantom mouse click occurs when it's 0x14.
	 */
	if (sc->flags & UMS_LEADINGBYTE) {
		if (*ibuf++ == 0x02)
			return;
		/* len--; */
	} else if (sc->flags & UMS_SPUR_BUT_UP) {
		if (*ibuf == 0x14 || *ibuf == 0x15)
			return;
	}

	dx =  hid_get_data(ibuf, &sc->sc_loc_x);
	dy = -hid_get_data(ibuf, &sc->sc_loc_y);
	dz =  hid_get_data(ibuf, &sc->sc_loc_z);
	dw =  hid_get_data(ibuf, &sc->sc_loc_w);
	if (sc->flags & UMS_REVZ)
		dz = -dz;
	if (sc->flags & UMS_REVW)
		dw = -dw;
	for (i = 0; i < sc->nbuttons; i++)
		if (hid_get_data(ibuf, &sc->sc_loc_btn[i]))
			buttons |= (1 << UMS_BUT(i));

	if (dx != 0 || dy != 0 || dz != 0 || dw != 0 ||
	    buttons != sc->sc_buttons) {
		DPRINTFN(10, ("ums_intr: x:%d y:%d z:%d w:%d buttons:0x%x\n",
			dx, dy, dz, dw, buttons));
		sc->sc_buttons = buttons;
		if (sc->sc_wsmousedev != NULL) {
			s = spltty();
			wsmouse_input(sc->sc_wsmousedev, buttons,
			    dx, dy, dz, dw, WSMOUSE_INPUT_DELTA);
			splx(s);
		}
	}
d197 2
a198 2

	DPRINTFN(1,("ums_enable: sc=%p\n", sc));
d201 1
a201 4
		return (EIO);

	if (sc->sc_enabled)
		return (EBUSY);
d203 2
a204 2
	sc->sc_enabled = 1;
	sc->sc_buttons = 0;
d206 1
a206 1
	return (uhidev_open(&sc->sc_hdev));
d213 1
d215 1
a215 9
	DPRINTFN(1,("ums_disable: sc=%p\n", sc));
#ifdef DIAGNOSTIC
	if (!sc->sc_enabled) {
		printf("ums_disable: not enabled\n");
		return;
	}
#endif

	sc->sc_enabled = 0;
d221 3
a224 1
{
d228 3
a230 1
		return (0);
a231 2

	return (-1);
@


1.30
log
@If we recognize a specific mouse model where we need to override locator
information, do this after the locator information has been obtained.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.29 2008/06/26 05:42:19 ray Exp $ */
d120 1
a120 1
int ums_activate(struct device *, enum devact); 
d355 1
a355 1
ums_activate(struct device *self, enum devact act)
@


1.29
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.28 2008/05/08 15:02:01 miod Exp $ */
a160 1
	struct hid_location loc_btn;
d271 1
a271 1
			uha->reportid, hid_input, &loc_btn, 0))
a329 5
	for (i = 1; i <= sc->nbuttons; i++)
		hid_locate(desc, size, HID_USAGE2(HUP_BUTTON, i),
			   uha->reportid, hid_input,
			   &sc->sc_loc_btn[i-1], 0);

d333 1
a333 1
		 sc->sc_loc_x.pos, sc->sc_loc_x.size));
d335 1
a335 1
		 sc->sc_loc_y.pos, sc->sc_loc_y.size));
d338 1
a338 1
			 sc->sc_loc_z.pos, sc->sc_loc_z.size));
d341 1
a341 1
			 sc->sc_loc_w.pos, sc->sc_loc_w.size));
d344 1
a344 1
			 i, sc->sc_loc_btn[i-1].pos,sc->sc_loc_btn[i-1].size));
@


1.28
log
@Add support for yet another exotic Microsoft Mouse, this time the
``Microsoft Notebook Optical Mouse 3000 Model 1049''. From FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.27 2008/05/08 13:57:43 miod Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.27
log
@Add support for Microsoft Wireless Intellimouse, from FreeBSD. Not only does
this device bends the uhid specs backwards, it is also completely unusable
for left-handed people due to its shape.

Tested on actual hardware thanks to a donation from Maxim Belooussov.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.26 2007/09/17 01:40:38 fgsch Exp $ */
d94 1
a94 1
#define UMS_Z		0x01	/* z direction available */
d97 1
a97 1
#define UMS_W		0x08	/* w direction available */
d303 20
d429 1
a429 2
		/* else
			len--; */
@


1.26
log
@remove unneeded malloc.h include.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.25 2007/06/14 10:11:16 mbalmer Exp $ */
a82 5
#define PS2LBUTMASK	x01
#define PS2RBUTMASK	x02
#define PS2MBUTMASK	x04
#define PS2BUTMASK 0x0f

d97 3
d167 1
a167 1
	int i;
d179 2
d208 16
a223 3
	/* Try the wheel as Z activator first */
	if (hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_WHEEL),
	    uha->reportid, hid_input, &sc->sc_loc_z, &flags)) {
d246 2
d261 15
d283 34
a316 3
	printf(": %d button%s%s\n",
	    sc->nbuttons, sc->nbuttons == 1 ? "" : "s",
	    sc->flags & UMS_Z ? " and Z dir." : "");
d332 3
d382 1
a382 1
ums_intr(struct uhidev *addr, void *ibuf, u_int len)
d385 1
d393 23
d422 2
@


1.25
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.24 2007/06/12 16:26:36 mbalmer Exp $ */
a47 1
#include <sys/malloc.h>
@


1.24
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.23 2007/06/11 16:30:31 mbalmer Exp $ */
d127 16
a142 1
USB_DECLARE_DRIVER(ums);
@


1.23
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.22 2007/06/10 14:49:01 mbalmer Exp $ */
d270 1
a270 1
ums_activate(device_ptr_t self, enum devact act)
@


1.22
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.21 2007/06/05 08:43:56 mbalmer Exp $ */
d119 1
a119 1
int	ums_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr);
d375 1
a375 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.21
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.20 2007/05/27 04:00:25 jsg Exp $ */
d173 1
a173 1
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d178 1
a178 1
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d185 1
a185 1
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d190 1
a190 1
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d199 1
a199 1
				USBDEVNAME(sc->sc_hdev.sc_dev), flags));
d215 1
a215 1
					USBDEVNAME(sc->sc_hdev.sc_dev), flags));
d225 1
a225 1
				USBDEVNAME(sc->sc_hdev.sc_dev), flags));
@


1.20
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.19 2007/05/21 05:40:28 jsg Exp $ */
d115 1
a115 1
Static void ums_intr(struct uhidev *addr, void *ibuf, u_int len);
d117 3
a119 3
Static int	ums_enable(void *);
Static void	ums_disable(void *);
Static int	ums_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr);
d338 1
a338 1
Static int
d357 1
a357 1
Static void
d374 1
a374 1
Static int
@


1.19
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.18 2007/04/10 22:37:17 miod Exp $ */
d129 2
a130 1
USB_MATCH(ums)
d132 1
a132 1
	USB_MATCH_START(ums, uaa);
d145 2
a146 1
USB_ATTACH(ums)
d148 2
a149 1
	USB_ATTACH_START(ums, sc, uaa);
d174 1
a174 1
		USB_ATTACH_ERROR_RETURN;
d179 1
a179 1
		USB_ATTACH_ERROR_RETURN;
d186 1
a186 1
		USB_ATTACH_ERROR_RETURN;
d191 1
a191 1
		USB_ATTACH_ERROR_RETURN;
a266 2

	USB_ATTACH_SUCCESS_RETURN;
d288 2
a289 1
USB_DETACH(ums)
d291 1
a291 1
	USB_DETACH_START(ums, sc);
@


1.18
log
@Add support for a fourth axis on wsmouse devices, e.g. on the Apple Might
Mouse.  Currently limited to USB mice.

Adapted from a diff from Gareth <garf@@loveandnature.co.za> on tech@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.17 2006/06/23 06:27:12 miod Exp $ */
d72 2
a73 2
#define DPRINTF(x)	do { if (umsdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (umsdebug>(n)) logprintf x; } while (0)
@


1.17
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.16 2005/11/21 18:16:44 millert Exp $ */
d94 1
a94 1
	struct hid_location sc_loc_x, sc_loc_y, sc_loc_z;
d152 1
a152 1
	int i, wheel;
d191 3
a193 7
	/* Try to guess the Z activator: first check Z, then WHEEL. */
	wheel = 0;
	if (hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_Z),
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags) ||
	    (wheel = hid_locate(desc, size, HID_USAGE2(HUP_GENERIC_DESKTOP,
						       HUG_WHEEL),
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags))) {
d195 3
a197 1
			sc->sc_loc_z.size = 0;	/* Bad Z coord, ignore it */
d201 25
a225 2
			if (wheel)
				sc->flags ^= UMS_REVZ;
d305 1
a305 1
	int dx, dy, dz;
d315 1
d322 4
a325 3
	if (dx != 0 || dy != 0 || dz != 0 || buttons != sc->sc_buttons) {
		DPRINTFN(10, ("ums_intr: x:%d y:%d z:%d buttons:0x%x\n",
			dx, dy, dz, buttons));
d329 2
a330 2
			wsmouse_input(sc->sc_wsmousedev, buttons, dx, dy, dz,
				      WSMOUSE_INPUT_DELTA);
@


1.16
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.15 2004/12/06 11:08:23 dlg Exp $ */
d255 1
a255 1
		return (EOPNOTSUPP);
@


1.15
log
@some mice have more than 7 buttons, so raise the limit in the driver.

fix submitted by Wolfgang S. Rupprecht in pr4015
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.14 2004/07/08 22:18:44 deraadt Exp $ */
d53 1
a53 1
#include <sys/select.h>
@


1.14
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.13 2003/05/19 00:37:19 nate Exp $ */
d89 1
a89 1
#define MAX_BUTTONS	7	/* must not exceed size of sc_buttons */
@


1.13
log
@update documentation url
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.12 2002/11/11 02:32:32 nate Exp $ */
d72 2
a73 2
#define DPRINTF(x)	if (umsdebug) logprintf x
#define DPRINTFN(n,x)	if (umsdebug>(n)) logprintf x
@


1.12
log
@sync with NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.11 2002/07/25 04:07:33 nate Exp $ */
/*	$NetBSD: ums.c,v 1.59 2002/09/23 05:59:01 simonb Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/devclass/hid1_1.pdf
@


1.11
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.10 2002/07/25 02:18:11 nate Exp $ */
/*	$NetBSD: ums.c,v 1.57 2002/07/11 21:14:33 augustss Exp $ */
a255 1
		break;
d346 1
a346 1
	return (uhidev_close(&sc->sc_hdev));
@


1.10
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.9 2002/05/09 15:06:29 nate Exp $ */
/*	$NetBSD: ums.c,v 1.55 2001/12/31 12:15:22 augustss Exp $	*/
@


1.9
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.8 2002/05/07 18:29:18 nate Exp $ */
d135 1
a135 1
	
d226 1
a226 1
	DPRINTF(("ums_attach: X\t%d/%d\n", 
d228 1
a228 1
	DPRINTF(("ums_attach: Y\t%d/%d\n", 
d231 1
a231 1
		DPRINTF(("ums_attach: Z\t%d/%d\n", 
@


1.8
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.6 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: ums.c,v 1.49 2001/10/26 17:58:21 augustss Exp $	*/
a44 2
/* XXX complete SPUR_UP change */

d65 1
d89 2
d92 2
a93 9
	USBBASEDEVICE sc_dev;		/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;

	u_char *sc_ibuf;
	u_int8_t sc_iid;
	int sc_isize;
d95 1
a95 1
	struct hid_location *sc_loc_btn;
a104 1
#define MAX_BUTTONS	31	/* chosen because sc_buttons is u_int32_t */
d115 1
a115 1
Static void ums_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d119 1
a119 1
Static int	ums_ioctl(void *, u_long, caddr_t, int, struct proc *);
d132 2
a133 2
	usb_interface_descriptor_t *id;
	int size, ret;
a134 1
	usbd_status err;
d136 3
a138 4
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
d141 1
a141 12
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
	if (err)
		return (UMATCH_NONE);

	if (hid_is_collection(desc, size, 
			      HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		ret = UMATCH_IFACECLASS;
	else
		ret = UMATCH_NONE;

	free(desc, M_TEMP);
	return (ret);
d147 1
a147 3
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
a150 2
	usbd_status err;
	char devinfo[1024];
a153 14
	
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d155 3
a157 15
	DPRINTFN(10,("ums_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d159 1
a159 1
	quirks = usbd_get_quirks(uaa->device)->uq_flags;
d165 1
a165 3
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
	if (err)
		USB_ATTACH_ERROR_RETURN;
d168 3
a170 2
		       hid_input, &sc->sc_loc_x, &flags)) {
		printf("%s: mouse has no X report\n", USBDEVNAME(sc->sc_dev));
d174 2
a175 2
		printf("%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
d180 3
a182 2
		       hid_input, &sc->sc_loc_y, &flags)) {
		printf("%s: mouse has no Y report\n", USBDEVNAME(sc->sc_dev));
d186 2
a187 2
		printf("%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
d194 1
a194 1
		       hid_input, &sc->sc_loc_z, &flags) ||
d197 1
a197 1
		       hid_input, &sc->sc_loc_z, &flags))) {
d211 1
a211 1
				hid_input, &loc_btn, 0))
a213 6
	sc->sc_loc_btn = malloc(sizeof(struct hid_location) * sc->nbuttons, 
				M_USBDEV, M_NOWAIT);
	if (!sc->sc_loc_btn) {
		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d215 1
a215 1
	printf("%s: %d button%s%s\n", USBDEVNAME(sc->sc_dev),
d221 2
a222 12
				hid_input, &sc->sc_loc_btn[i-1], 0);

	sc->sc_isize = hid_report_size(desc, size, hid_input, &sc->sc_iid);
	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_NOWAIT);
	if (sc->sc_ibuf == NULL) {
		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		free(sc->sc_loc_btn, M_USBDEV);
		USB_ATTACH_ERROR_RETURN;
	}

	sc->sc_ep_addr = ed->bEndpointAddress;
	free(desc, M_TEMP);
a236 1
	DPRINTF(("ums_attach: size=%d, id=%d\n", sc->sc_isize, sc->sc_iid));
a241 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

a276 7
	if (rv == 0) {
		free(sc->sc_loc_btn, M_USBDEV);
		free(sc->sc_ibuf, M_USBDEV);
	}

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d282 1
a282 1
ums_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d284 1
a284 2
	struct ums_softc *sc = addr;
	u_char *ibuf;
d290 1
a290 12
	DPRINTFN(5, ("ums_intr: sc=%p status=%d\n", sc, status));
	DPRINTFN(5, ("ums_intr: data = %02x %02x %02x\n",
		     sc->sc_ibuf[0], sc->sc_ibuf[1], sc->sc_ibuf[2]));

	if (status == USBD_CANCELLED)
		return;

	if (status) {
		DPRINTF(("ums_intr: status=%d\n", status));
		usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
		return;
	}
a291 5
	ibuf = sc->sc_ibuf;
	if (sc->sc_iid != 0) {
		if (*ibuf++ != sc->sc_iid)
			return;
	}
a318 2
	usbd_status err;

d330 1
a330 11
	/* Set up interrupt pipe. */
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, 
		  sc->sc_ibuf, sc->sc_isize, ums_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
		DPRINTF(("ums_enable: usbd_open_pipe_intr failed, error=%d\n",
			 err));
		sc->sc_enabled = 0;
		return (EIO);
	}
	return (0);
a345 4
	/* Disable interrupts. */
	usbd_abort_pipe(sc->sc_intrpipe);
	usbd_close_pipe(sc->sc_intrpipe);

d347 1
d351 1
a351 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
@


1.7
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.55 2001/12/31 12:15:22 augustss Exp $	*/
d45 2
a66 1
#include <dev/usb/uhidev.h>
a89 2
#define MAX_BUTTONS	7	/* must not exceed size of sc_buttons */

d91 9
a99 2
	struct uhidev sc_hdev;

d101 1
a101 1
	struct hid_location sc_loc_btn[MAX_BUTTONS];
d111 1
d122 1
a122 1
Static void ums_intr(struct uhidev *addr, void *ibuf, u_int len);
d126 1
a126 1
Static int	ums_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr);
d139 2
a140 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
d142 1
d144 4
a147 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
d150 12
a161 1
	return (UMATCH_IFACECLASS);
d167 3
a169 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d173 2
d178 14
d193 15
a207 3
	sc->sc_hdev.sc_intr = ums_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;
d209 1
a209 1
	quirks = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d215 3
a217 1
	uhidev_get_report_desc(uha->parent, &desc, &size);
d220 2
a221 3
	       uha->reportid, hid_input, &sc->sc_loc_x, &flags)) {
		printf("\n%s: mouse has no X report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d225 2
a226 2
		printf("\n%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d231 2
a232 3
	       uha->reportid, hid_input, &sc->sc_loc_y, &flags)) {
		printf("\n%s: mouse has no Y report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d236 2
a237 2
		printf("\n%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d244 1
a244 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags) ||
d247 1
a247 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags))) {
d261 1
a261 1
			uha->reportid, hid_input, &loc_btn, 0))
d264 6
d271 1
a271 1
	printf(": %d button%s%s\n",
d277 12
a288 2
			   uha->reportid, hid_input,
			   &sc->sc_loc_btn[i-1], 0);
d303 1
d309 3
d347 7
d359 1
a359 1
ums_intr(struct uhidev *addr, void *ibuf, u_int len)
d361 2
a362 1
	struct ums_softc *sc = (struct ums_softc *)addr;
d368 12
a379 1
	DPRINTFN(5,("ums_intr: len=%d\n", len));
d381 5
d413 2
d426 11
a436 1
	return (uhidev_open(&sc->sc_hdev));
d452 4
a456 1
	return (uhidev_close(&sc->sc_hdev));
d460 1
a460 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.6
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.5 2001/05/03 02:20:34 aaron Exp $ */
/*	$NetBSD: ums.c,v 1.49 2001/10/26 17:58:21 augustss Exp $	*/
a44 2
/* XXX complete SPUR_UP change */

d65 1
d89 2
d92 2
a93 9
	USBBASEDEVICE sc_dev;		/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;

	u_char *sc_ibuf;
	u_int8_t sc_iid;
	int sc_isize;
d95 1
a95 1
	struct hid_location *sc_loc_btn;
a104 1
#define MAX_BUTTONS	31	/* chosen because sc_buttons is u_int32_t */
d115 1
a115 1
Static void ums_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d119 1
a119 1
Static int	ums_ioctl(void *, u_long, caddr_t, int, struct proc *);
d132 2
a133 2
	usb_interface_descriptor_t *id;
	int size, ret;
a134 1
	usbd_status err;
d136 3
a138 4
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
d141 1
a141 12
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
	if (err)
		return (UMATCH_NONE);

	if (hid_is_collection(desc, size, 
			      HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
		ret = UMATCH_IFACECLASS;
	else
		ret = UMATCH_NONE;

	free(desc, M_TEMP);
	return (ret);
d147 1
a147 3
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
a150 2
	usbd_status err;
	char devinfo[1024];
a153 14
	
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d155 3
a157 15
	DPRINTFN(10,("ums_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n",
		       USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d159 1
a159 1
	quirks = usbd_get_quirks(uaa->device)->uq_flags;
d165 1
a165 3
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
	if (err)
		USB_ATTACH_ERROR_RETURN;
d168 3
a170 2
		       hid_input, &sc->sc_loc_x, &flags)) {
		printf("%s: mouse has no X report\n", USBDEVNAME(sc->sc_dev));
d174 2
a175 2
		printf("%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
d180 3
a182 2
		       hid_input, &sc->sc_loc_y, &flags)) {
		printf("%s: mouse has no Y report\n", USBDEVNAME(sc->sc_dev));
d186 2
a187 2
		printf("%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_dev), flags);
d194 1
a194 1
		       hid_input, &sc->sc_loc_z, &flags) ||
d197 1
a197 1
		       hid_input, &sc->sc_loc_z, &flags))) {
d211 1
a211 1
				hid_input, &loc_btn, 0))
a213 6
	sc->sc_loc_btn = malloc(sizeof(struct hid_location) * sc->nbuttons, 
				M_USBDEV, M_NOWAIT);
	if (!sc->sc_loc_btn) {
		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		USB_ATTACH_ERROR_RETURN;
	}
d215 1
a215 1
	printf("%s: %d button%s%s\n", USBDEVNAME(sc->sc_dev),
d221 2
a222 12
				hid_input, &sc->sc_loc_btn[i-1], 0);

	sc->sc_isize = hid_report_size(desc, size, hid_input, &sc->sc_iid);
	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_NOWAIT);
	if (sc->sc_ibuf == NULL) {
		printf("%s: no memory\n", USBDEVNAME(sc->sc_dev));
		free(sc->sc_loc_btn, M_USBDEV);
		USB_ATTACH_ERROR_RETURN;
	}

	sc->sc_ep_addr = ed->bEndpointAddress;
	free(desc, M_TEMP);
a236 1
	DPRINTF(("ums_attach: size=%d, id=%d\n", sc->sc_isize, sc->sc_iid));
a241 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

a276 7
	if (rv == 0) {
		free(sc->sc_loc_btn, M_USBDEV);
		free(sc->sc_ibuf, M_USBDEV);
	}

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d282 1
a282 1
ums_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d284 1
a284 2
	struct ums_softc *sc = addr;
	u_char *ibuf;
d290 1
a290 12
	DPRINTFN(5, ("ums_intr: sc=%p status=%d\n", sc, status));
	DPRINTFN(5, ("ums_intr: data = %02x %02x %02x\n",
		     sc->sc_ibuf[0], sc->sc_ibuf[1], sc->sc_ibuf[2]));

	if (status == USBD_CANCELLED)
		return;

	if (status) {
		DPRINTF(("ums_intr: status=%d\n", status));
		usbd_clear_endpoint_stall_async(sc->sc_intrpipe);
		return;
	}
a291 5
	ibuf = sc->sc_ibuf;
	if (sc->sc_iid != 0) {
		if (*ibuf++ != sc->sc_iid)
			return;
	}
a318 2
	usbd_status err;

d330 1
a330 11
	/* Set up interrupt pipe. */
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, 
		  sc->sc_ibuf, sc->sc_isize, ums_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
		DPRINTF(("ums_enable: usbd_open_pipe_intr failed, error=%d\n",
			 err));
		sc->sc_enabled = 0;
		return (EIO);
	}
	return (0);
a345 4
	/* Disable interrupts. */
	usbd_abort_pipe(sc->sc_intrpipe);
	usbd_close_pipe(sc->sc_intrpipe);

d347 1
d351 1
a351 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, struct proc *p)
@


1.6.2.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ums.c,v 1.55 2001/12/31 12:15:22 augustss Exp $	*/
d45 2
a66 1
#include <dev/usb/uhidev.h>
a89 2
#define MAX_BUTTONS	7	/* must not exceed size of sc_buttons */

d91 9
a99 2
	struct uhidev sc_hdev;

d101 1
a101 1
	struct hid_location sc_loc_btn[MAX_BUTTONS];
d111 1
d122 1
a122 1
Static void ums_intr(struct uhidev *addr, void *ibuf, u_int len);
d126 1
a126 1
Static int	ums_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr);
d139 2
a140 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
d142 1
d144 4
a147 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
d150 12
a161 1
	return (UMATCH_IFACECLASS);
d167 3
a169 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d173 2
d178 14
d193 15
a207 3
	sc->sc_hdev.sc_intr = ums_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;
d209 1
a209 1
	quirks = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d215 3
a217 1
	uhidev_get_report_desc(uha->parent, &desc, &size);
d220 2
a221 3
	       uha->reportid, hid_input, &sc->sc_loc_x, &flags)) {
		printf("\n%s: mouse has no X report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d225 2
a226 2
		printf("\n%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d231 2
a232 3
	       uha->reportid, hid_input, &sc->sc_loc_y, &flags)) {
		printf("\n%s: mouse has no Y report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d236 2
a237 2
		printf("\n%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d244 1
a244 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags) ||
d247 1
a247 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags))) {
d261 1
a261 1
			uha->reportid, hid_input, &loc_btn, 0))
d264 6
d271 1
a271 1
	printf(": %d button%s%s\n",
d277 12
a288 2
			   uha->reportid, hid_input,
			   &sc->sc_loc_btn[i-1], 0);
d303 1
d309 3
d347 7
d359 1
a359 1
ums_intr(struct uhidev *addr, void *ibuf, u_int len)
d361 2
a362 1
	struct ums_softc *sc = (struct ums_softc *)addr;
d368 12
a379 1
	DPRINTFN(5,("ums_intr: len=%d\n", len));
d381 5
d413 2
d426 11
a436 1
	return (uhidev_open(&sc->sc_hdev));
d452 4
a456 1
	return (uhidev_close(&sc->sc_hdev));
d460 1
a460 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.6.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.57 2002/07/11 21:14:33 augustss Exp $ */
d135 1
a135 1

d226 1
a226 1
	DPRINTF(("ums_attach: X\t%d/%d\n",
d228 1
a228 1
	DPRINTF(("ums_attach: Y\t%d/%d\n",
d231 1
a231 1
		DPRINTF(("ums_attach: Z\t%d/%d\n",
@


1.6.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.59 2002/09/23 05:59:01 simonb Exp $	*/
d256 1
d347 1
a347 1
	uhidev_close(&sc->sc_hdev);
@


1.5
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.4 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: ums.c,v 1.47 2001/01/23 14:04:14 augustss Exp $	*/
d150 1
a150 1
	err = usbd_alloc_report_desc(uaa->iface, &desc, &size, M_TEMP);
d215 1
a215 1
	err = usbd_alloc_report_desc(uaa->iface, &desc, &size, M_TEMP);
d295 1
a295 1
		 sc->sc_loc_x.pos, sc->sc_loc_x.size));
@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.45 2000/10/08 20:52:18 augustss Exp $	*/
a308 2
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);

d311 2
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ums.c,v 1.47 2001/01/23 14:04:14 augustss Exp $	*/
d309 2
a312 2

	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);
@


1.5.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.49 2001/10/26 17:58:21 augustss Exp $	*/
d150 1
a150 1
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
d215 1
a215 1
	err = usbd_read_report_desc(uaa->iface, &desc, &size, M_TEMP);
d295 1
a295 1
		 sc->sc_loc_y.pos, sc->sc_loc_y.size));
@


1.5.2.4
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.59 2002/09/23 05:59:01 simonb Exp $	*/
d45 2
a66 1
#include <dev/usb/uhidev.h>
a89 2
#define MAX_BUTTONS	7	/* must not exceed size of sc_buttons */

d91 9
a99 2
	struct uhidev sc_hdev;

d101 1
a101 1
	struct hid_location sc_loc_btn[MAX_BUTTONS];
d111 1
d122 1
a122 1
Static void ums_intr(struct uhidev *addr, void *ibuf, u_int len);
d126 1
a126 1
Static int	ums_ioctl(void *, u_long, caddr_t, int, usb_proc_ptr);
d139 2
a140 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size;
d142 7
d150 2
a151 3
	uhidev_get_report_desc(uha->parent, &desc, &size);
	if (!hid_is_collection(desc, size, uha->reportid,
			       HID_USAGE2(HUP_GENERIC_DESKTOP, HUG_MOUSE)))
d154 8
a161 1
	return (UMATCH_IFACECLASS);
d167 3
a169 1
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d173 2
d178 14
d193 15
a207 3
	sc->sc_hdev.sc_intr = ums_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;
d209 1
a209 1
	quirks = usbd_get_quirks(uha->parent->sc_udev)->uq_flags;
d215 3
a217 1
	uhidev_get_report_desc(uha->parent, &desc, &size);
d220 2
a221 3
	       uha->reportid, hid_input, &sc->sc_loc_x, &flags)) {
		printf("\n%s: mouse has no X report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d225 2
a226 2
		printf("\n%s: X report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d231 2
a232 3
	       uha->reportid, hid_input, &sc->sc_loc_y, &flags)) {
		printf("\n%s: mouse has no Y report\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev));
d236 2
a237 2
		printf("\n%s: Y report 0x%04x not supported\n",
		       USBDEVNAME(sc->sc_hdev.sc_dev), flags);
d244 1
a244 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags) ||
d247 1
a247 1
	       uha->reportid, hid_input, &sc->sc_loc_z, &flags))) {
d261 1
a261 1
			uha->reportid, hid_input, &loc_btn, 0))
d264 6
d271 1
a271 1
	printf(": %d button%s%s\n",
d277 12
a288 2
			   uha->reportid, hid_input,
			   &sc->sc_loc_btn[i-1], 0);
d292 1
a292 1
	DPRINTF(("ums_attach: X\t%d/%d\n",
d294 1
a294 1
	DPRINTF(("ums_attach: Y\t%d/%d\n",
d297 1
a297 1
		DPRINTF(("ums_attach: Z\t%d/%d\n",
d303 1
d309 3
d326 1
d347 7
d359 1
a359 1
ums_intr(struct uhidev *addr, void *ibuf, u_int len)
d361 2
a362 1
	struct ums_softc *sc = (struct ums_softc *)addr;
d368 12
a379 1
	DPRINTFN(5,("ums_intr: len=%d\n", len));
d381 5
d413 2
d426 11
a436 1
	return (uhidev_open(&sc->sc_hdev));
d452 4
a456 1
	uhidev_close(&sc->sc_hdev);
d460 1
a460 1
ums_ioctl(void *v, u_long cmd, caddr_t data, int flag, usb_proc_ptr p)
@


1.5.2.5
log
@Sync SMP branch to -current
@
text
@d2 1
a2 1
/*	$NetBSD: ums.c,v 1.60 2003/03/11 16:44:00 augustss Exp $	*/
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
@


1.4
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: ums.c,v 1.3 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: ums.c,v 1.45 2000/10/08 20:52:18 augustss Exp $	*/
a308 2
	sc->sc_wsmousedev = config_found(self, &a, wsmousedevprint);

d311 2
@


1.3
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ums.c,v 1.2 2000/09/07 22:17:48 matthieu Exp $ */
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/usbhid10.pdf
@


1.2
log
@Be gentle with the poor Apple mouse that has only 1 button (without
's').
@
text
@d1 2
a2 2
/*	$NetBSD: ums.c,v 1.44 2000/06/01 14:29:01 augustss Exp $	*/
/*	$OpenBSD$ */
d264 1
a264 1
	sc->sc_loc_btn = malloc(sizeof(struct hid_location)*sc->nbuttons, 
d272 2
a273 2
	       sc->nbuttons, sc->nbuttons == 1 ? "" : "s", 
	       sc->flags & UMS_Z ? " and Z dir." : "");
@


1.1
log
@add ums mouse support from NetBSD
@
text
@d2 1
d271 3
a273 2
	printf("%s: %d buttons%s\n", USBDEVNAME(sc->sc_dev),
	       sc->nbuttons, sc->flags & UMS_Z ? " and Z dir." : "");
@

