head	1.71;
access;
symbols
	OPENBSD_6_1:1.71.0.6
	OPENBSD_6_1_BASE:1.71
	OPENBSD_6_0:1.71.0.4
	OPENBSD_6_0_BASE:1.71
	OPENBSD_5_9:1.69.0.4
	OPENBSD_5_9_BASE:1.69
	OPENBSD_5_8:1.69.0.6
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.69.0.2
	OPENBSD_5_7_BASE:1.69
	OPENBSD_5_6:1.61.0.4
	OPENBSD_5_6_BASE:1.61
	OPENBSD_5_5:1.53.0.4
	OPENBSD_5_5_BASE:1.53
	OPENBSD_5_4:1.49.0.2
	OPENBSD_5_4_BASE:1.49
	OPENBSD_5_3:1.44.0.4
	OPENBSD_5_3_BASE:1.44
	OPENBSD_5_2:1.44.0.2
	OPENBSD_5_2_BASE:1.44
	OPENBSD_5_1_BASE:1.43
	OPENBSD_5_1:1.43.0.2
	OPENBSD_5_0:1.42.0.4
	OPENBSD_5_0_BASE:1.42
	OPENBSD_4_9:1.42.0.2
	OPENBSD_4_9_BASE:1.42
	OPENBSD_4_8:1.37.0.4
	OPENBSD_4_8_BASE:1.37
	OPENBSD_4_7:1.37.0.2
	OPENBSD_4_7_BASE:1.37
	OPENBSD_4_6:1.34.0.8
	OPENBSD_4_6_BASE:1.34
	OPENBSD_4_5:1.34.0.4
	OPENBSD_4_5_BASE:1.34
	OPENBSD_4_4:1.34.0.2
	OPENBSD_4_4_BASE:1.34
	OPENBSD_4_3:1.32.0.4
	OPENBSD_4_3_BASE:1.32
	OPENBSD_4_2:1.32.0.2
	OPENBSD_4_2_BASE:1.32
	OPENBSD_4_1:1.24.0.2
	OPENBSD_4_1_BASE:1.24
	OPENBSD_4_0:1.24.0.4
	OPENBSD_4_0_BASE:1.24
	OPENBSD_3_9:1.23.0.6
	OPENBSD_3_9_BASE:1.23
	OPENBSD_3_8:1.23.0.4
	OPENBSD_3_8_BASE:1.23
	OPENBSD_3_7:1.23.0.2
	OPENBSD_3_7_BASE:1.23
	OPENBSD_3_6:1.19.0.8
	OPENBSD_3_6_BASE:1.19
	SMP_SYNC_A:1.19
	SMP_SYNC_B:1.19
	OPENBSD_3_5:1.19.0.4
	OPENBSD_3_5_BASE:1.19
	OPENBSD_3_4:1.19.0.2
	OPENBSD_3_4_BASE:1.19
	UBC_SYNC_A:1.18
	OPENBSD_3_3:1.17.0.4
	OPENBSD_3_3_BASE:1.17
	OPENBSD_3_2:1.17.0.2
	OPENBSD_3_2_BASE:1.17
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.17
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.71
date	2016.05.23.11.31.12;	author mpi;	state Exp;
branches;
next	1.70;
commitid	osg2h5b1t4W1KLxf;

1.70
date	2016.05.18.18.28.58;	author patrick;	state Exp;
branches;
next	1.69;
commitid	SQX964uLUjZqy5aw;

1.69
date	2014.12.21.12.04.01;	author mpi;	state Exp;
branches;
next	1.68;
commitid	zKT75AtayKC42yGo;

1.68
date	2014.11.11.20.57.27;	author mpi;	state Exp;
branches;
next	1.67;
commitid	YEtlLYOabOI7wwNq;

1.67
date	2014.11.10.14.26.38;	author mpi;	state Exp;
branches;
next	1.66;
commitid	wFFFEy0v2w7LPkrT;

1.66
date	2014.11.10.11.01.13;	author mpi;	state Exp;
branches;
next	1.65;
commitid	bF7jzK0vSp194wcF;

1.65
date	2014.11.01.14.44.08;	author mpi;	state Exp;
branches;
next	1.64;
commitid	BmycRw1mcwUuxLd7;

1.64
date	2014.10.31.12.43.33;	author mpi;	state Exp;
branches;
next	1.63;
commitid	louylZALyxXoJWVz;

1.63
date	2014.10.30.23.50.25;	author mpi;	state Exp;
branches;
next	1.62;
commitid	OC2UwjyhSceyDB1n;

1.62
date	2014.08.09.09.45.14;	author mpi;	state Exp;
branches;
next	1.61;
commitid	MwiYUakpkX4F7pXj;

1.61
date	2014.07.09.18.15.04;	author mpi;	state Exp;
branches;
next	1.60;
commitid	7bxb660ER7iHPxAL;

1.60
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.59;
commitid	d8ZHVs7unt3KxWXc;

1.59
date	2014.05.28.11.20.55;	author mpi;	state Exp;
branches;
next	1.58;

1.58
date	2014.03.29.18.09.31;	author guenther;	state Exp;
branches;
next	1.57;

1.57
date	2014.03.14.14.11.31;	author pirofti;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.08.11.44.17;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2014.03.06.23.53.11;	author mpi;	state Exp;
branches;
next	1.54;

1.54
date	2014.03.06.23.51.04;	author mpi;	state Exp;
branches;
next	1.53;

1.53
date	2013.11.01.12.00.54;	author mpi;	state Exp;
branches;
next	1.52;

1.52
date	2013.10.19.08.29.30;	author mpi;	state Exp;
branches;
next	1.51;

1.51
date	2013.08.13.09.26.05;	author mpi;	state Exp;
branches;
next	1.50;

1.50
date	2013.08.08.09.44.22;	author mpi;	state Exp;
branches;
next	1.49;

1.49
date	2013.04.26.14.05.24;	author mpi;	state Exp;
branches;
next	1.48;

1.48
date	2013.04.19.08.58.53;	author mpi;	state Exp;
branches;
next	1.47;

1.47
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.46;

1.46
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.45;

1.45
date	2013.03.16.11.11.22;	author mpi;	state Exp;
branches;
next	1.44;

1.44
date	2012.05.15.12.48.32;	author mpi;	state Exp;
branches;
next	1.43;

1.43
date	2012.01.08.13.12.38;	author miod;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.41;

1.41
date	2010.12.30.05.10.35;	author jakemsr;	state Exp;
branches;
next	1.40;

1.40
date	2010.12.06.04.25.27;	author jakemsr;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.23.05.44.16;	author jakemsr;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.23.04.58.02;	author jakemsr;	state Exp;
branches;
next	1.37;

1.37
date	2009.11.12.20.16.37;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.35;

1.35
date	2009.08.30.19.15.40;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.33;

1.33
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.13.11.31.33;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.04.10.38.05;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.20.14.14.12;	author miod;	state Exp;
branches;
next	1.24;

1.24
date	2006.05.31.06.18.09;	author pascoe;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.13.02.54.04;	author pascoe;	state Exp;
branches;
next	1.22;

1.22
date	2004.12.12.05.21.14;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.12.05.17.40;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.09.11.49.55;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.31.04.24.45;	author nate;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.05.03.02.20.34;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.28.09.43.43;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.04.11.44.26;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.53;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.20;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.56;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.51;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.30;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.19.08.18.39;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.05;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.26;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.44.03;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.71
log
@Get rid of usbd_get_device_strings() because we use it only once.

Return a char * rather using a void function for usbd_get_device_string()

ok patrick@@
@
text
@/*	$OpenBSD: usbdivar.h,v 1.70 2016/05/18 18:28:58 patrick Exp $ */
/*	$NetBSD: usbdivar.h,v 1.70 2002/07/11 21:14:36 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdivar.h,v 1.11 1999/11/17 22:33:51 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef _USBDIVAR_H_
#define _USBDIVAR_H_

#include <sys/timeout.h>

/* From usb_mem.h */
struct usb_dma_block;
struct usb_dma {
	struct usb_dma_block	*block;
	u_int			 offs;
};

struct usbd_xfer;
struct usbd_pipe;

struct usbd_endpoint {
	usb_endpoint_descriptor_t *edesc;
	int			refcnt;
	int			savedtoggle;
};

struct usbd_bus_methods {
	usbd_status	      (*open_pipe)(struct usbd_pipe *);
	int		      (*dev_setaddr)(struct usbd_device *, int);
	void		      (*soft_intr)(void *);
	void		      (*do_poll)(struct usbd_bus *);
	struct usbd_xfer *    (*allocx)(struct usbd_bus *);
	void		      (*freex)(struct usbd_bus *, struct usbd_xfer *);
};

struct usbd_pipe_methods {
	usbd_status	      (*transfer)(struct usbd_xfer *);
	usbd_status	      (*start)(struct usbd_xfer *);
	void		      (*abort)(struct usbd_xfer *);
	void		      (*close)(struct usbd_pipe *);
	void		      (*cleartoggle)(struct usbd_pipe *);
	void		      (*done)(struct usbd_xfer *);
};

struct usbd_tt {
	struct usbd_hub	       *hub;
};

struct usbd_port {
	usb_port_status_t	status;
	u_int16_t		power;	/* mA of current on port */
	u_int8_t		portno;
	u_int8_t		restartcnt;
#define USBD_RESTART_MAX 5
	u_int8_t		reattach;
	struct usbd_device     *device;	/* Connected device */
	struct usbd_device     *parent;	/* The ports hub */
	struct usbd_tt	       *tt; /* Transaction translator (if any) */
};

struct usbd_hub {
	int		      (*explore)(struct usbd_device *);
	void		       *hubsoftc;
	struct usbd_port       *ports;
	int			nports;
	u_int8_t		powerdelay;
	u_int8_t		ttthink;
};

struct usbd_bus {
	/* Filled by HC driver */
	struct device		bdev; /* base device, host adapter */
	struct usbd_bus_methods	*methods;
	u_int32_t		pipe_size; /* size of a pipe struct */
	/* Filled by usb driver */
	struct usbd_device     *root_hub;
	struct usbd_device	*devices[USB_MAX_DEVICES];
	char			use_polling;
	char			dying;
	int			flags;
#define USB_BUS_CONFIG_PENDING	0x01
#define USB_BUS_DISCONNECTING	0x02
	struct device	       *usbctl;
	struct usb_device_stats	stats;
	int 			intr_context;
	u_int			no_intrs;
	int			usbrev;	/* USB revision */
#define USBREV_UNKNOWN	0
#define USBREV_PRE_1_0	1
#define USBREV_1_0	2
#define USBREV_1_1	3
#define USBREV_2_0	4
#define USBREV_3_0	5
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0", "3.0" }
	void		       *soft; /* soft interrupt cookie */
	bus_dma_tag_t		dmatag;	/* DMA tag */
};

struct usbd_device {
	struct usbd_bus	       *bus;           /* our controller */
	struct usbd_pipe       *default_pipe;  /* pipe 0 */
	u_int8_t		dying;	       /* hardware removed */
	u_int8_t		ref_cnt;       /* # of procs using device */
	u_int8_t		address;       /* device address */
	u_int8_t		config;	       /* current configuration # */
	u_int8_t		depth;         /* distance from root hub */
	u_int8_t		speed;         /* low/full/high speed */
	u_int8_t		self_powered;  /* flag for self powered */
	u_int16_t		power;         /* mA the device uses */
	int16_t			langid;	       /* language for strings */
#define USBD_NOLANG (-1)
	struct usbd_port       *powersrc;      /* upstream hub port, or 0 */
	struct usbd_device     *myhub; 	       /* upstream hub */
	struct usbd_port       *myhsport;      /* closest high speed port */
	struct usbd_endpoint	def_ep;	       /* for pipe 0 */
	usb_endpoint_descriptor_t def_ep_desc; /* for pipe 0 */
	struct usbd_interface  *ifaces;        /* array of all interfaces */
	usb_device_descriptor_t ddesc;         /* device descriptor */
	usb_config_descriptor_t *cdesc;	       /* full config descr */
	const struct usbd_quirks     *quirks;  /* device quirks, always set */
	struct usbd_hub	       *hub;           /* only if this is a hub */
	struct device         **subdevs;       /* sub-devices, 0 terminated */
	int			ndevs;	       /* # of subdevs */

	char                   *serial;        /* serial number, can be NULL */
	char                   *vendor;        /* vendor string, can be NULL */
	char                   *product;       /* product string, can be NULL */
};

struct usbd_interface {
	struct usbd_device     *device;
	usb_interface_descriptor_t *idesc;
	int			index;
	int			altindex;
	struct usbd_endpoint   *endpoints;
	void		       *priv;
	LIST_HEAD(, usbd_pipe)	pipes;
	u_int8_t		claimed;
};

struct usbd_pipe {
	struct usbd_interface  *iface;
	struct usbd_device     *device;
	struct usbd_endpoint   *endpoint;
	char			running;
	char			aborting;
	SIMPLEQ_HEAD(, usbd_xfer) queue;
	LIST_ENTRY(usbd_pipe)	next;

	struct usbd_xfer	*intrxfer; /* used for repeating requests */
	char			repeat;
	int			interval;

	/* Filled by HC driver. */
	struct usbd_pipe_methods *methods;
};

struct usbd_xfer {
	struct usbd_pipe       *pipe;
	void		       *priv;
	char		       *buffer;
	u_int32_t		length;
	u_int32_t		actlen;
	u_int16_t		flags;
	u_int32_t		timeout;
	usbd_status		status;
	usbd_callback		callback;
	volatile char		done;
#ifdef DIAGNOSTIC
	u_int32_t		busy_free;
#define XFER_FREE 0x42555359
#define XFER_ONQU 0x4f4e5155
#endif

	/* For control pipe */
	usb_device_request_t	request;

	/* For isoc */
	u_int16_t		*frlengths;
	int			nframes;

	/* For memory allocation */
	struct usbd_device     *device;
	struct usb_dma		dmabuf;

	int			rqflags;
#define URQ_REQUEST	0x01
#define URQ_AUTO_DMABUF	0x10
#define URQ_DEV_DMABUF	0x20

	SIMPLEQ_ENTRY(usbd_xfer) next;

	void		       *hcpriv; /* private use by the HC driver */

	struct usb_task		abort_task;
	struct timeout		timeout_handle;
};

void usbd_dump_iface(struct usbd_interface *);
void usbd_dump_device(struct usbd_device *);
void usbd_dump_endpoint(struct usbd_endpoint *);
void usbd_dump_queue(struct usbd_pipe *);
void usbd_dump_pipe(struct usbd_pipe *);

/* Routines from usb_subr.c */
int		usbctlprint(void *, const char *);
void		usb_delay_ms(struct usbd_bus *, u_int);
usbd_status	usbd_port_disown_to_1_1(struct usbd_device *, int);
int		usbd_reset_port(struct usbd_device *, int);
usbd_status	usbd_setup_pipe(struct usbd_device *,
		    struct usbd_interface *, struct usbd_endpoint *, int,
		    struct usbd_pipe **);
int		usbd_set_address(struct usbd_device *, int);
usbd_status	usbd_new_device(struct device *, struct usbd_bus *,
		    int, int, int, struct usbd_port *);
usbd_status	usbd_fill_iface_data(struct usbd_device *, int, int);

usbd_status	usb_insert_transfer(struct usbd_xfer *);
void		usb_transfer_complete(struct usbd_xfer *);
int		usbd_detach(struct usbd_device *, struct device *);

/* Routines from usb.c */
void		usb_needs_explore(struct usbd_device *, int);
void		usb_needs_reattach(struct usbd_device *);
void		usb_schedsoftintr(struct usbd_bus *);

#define	UHUB_UNK_CONFIGURATION	-1
#define	UHUB_UNK_INTERFACE	-1

static inline int
usbd_xfer_isread(struct usbd_xfer *xfer)
{
	if (xfer->rqflags & URQ_REQUEST)
		return (xfer->request.bmRequestType & UT_READ);

	return (xfer->pipe->endpoint->edesc->bEndpointAddress & UE_DIR_IN);
}

#endif /* _USBDIVAR_H_ */
@


1.70
log
@Cache vendor, product and serial info for each usb device.  This allows
ioctl(USB_DEVICEINFO) not to issue any further requests to gather
information.  Thus reducing stress on connected usb devices.
This fixes an issue where usbdevs called in a loop causes a USB mass
storage device to halt operation.

Adapted from a similar commit in NetBSD.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.69 2014/12/21 12:04:01 mpi Exp $ */
a235 1
void		usbd_get_device_strings(struct usbd_device *);
@


1.69
log
@Always clear a port reset feature after setting it, or at least try to.
Otherwise we might leave a port in an unwanted state.

Found while investigating timeout issues on xhci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.68 2014/11/11 20:57:27 mpi Exp $ */
d153 4
d236 1
@


1.68
log
@When a bus is explored, do not probe the ports which status hasn't
changed.  This saves a lot of I/O when attaching/detaching devices
and might help with some timing related problems.

Has been in snap for ten days, committing now so that people testing
xhci(4) test the same thing w/ snapshots and their own kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.67 2014/11/10 14:26:38 mpi Exp $ */
d234 1
a234 1
usbd_status	usbd_reset_port(struct usbd_device *, int);
@


1.67
log
@Add some fields needed for TT support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.66 2014/11/10 11:01:13 mpi Exp $ */
d186 1
a186 1
	void		       *buffer;
@


1.66
log
@Remove USB locators.  They are currently unused and this wont change due
to the way USB buses are discovered.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.65 2014/11/01 14:44:08 mpi Exp $ */
d93 4
a96 3
	int			 nports;
	u_int8_t		 powerdelay;
	struct usbd_port        *ports;
@


1.65
log
@Remove the port status argument from usbd_reset_port().  We don't do
anything with it and it simplifies this mess in order to implement
warm reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.64 2014/10/31 12:43:33 mpi Exp $ */
d251 2
a252 33
/* Locator stuff. */

/* XXX these values are used to statically bind some elements in the USB tree
 * to specific driver instances. This should be somehow emulated in FreeBSD
 * but can be done later on.
 * The values are copied from the files.usb file in the NetBSD sources.
 */
#define UHUBCF_PORT_DEFAULT -1
#define UHUBCF_CONFIGURATION_DEFAULT -1
#define UHUBCF_INTERFACE_DEFAULT -1
#define UHUBCF_VENDOR_DEFAULT -1
#define UHUBCF_PRODUCT_DEFAULT -1
#define UHUBCF_RELEASE_DEFAULT -1

#define	UHUBCF_PORT		0
#define	UHUBCF_CONFIGURATION	1
#define	UHUBCF_INTERFACE	2
#define	UHUBCF_VENDOR		3
#define	UHUBCF_PRODUCT		4
#define	UHUBCF_RELEASE		5

#define	uhubcf_port		cf_loc[UHUBCF_PORT]
#define	uhubcf_configuration	cf_loc[UHUBCF_CONFIGURATION]
#define	uhubcf_interface	cf_loc[UHUBCF_INTERFACE]
#define	uhubcf_vendor		cf_loc[UHUBCF_VENDOR]
#define	uhubcf_product		cf_loc[UHUBCF_PRODUCT]
#define	uhubcf_release		cf_loc[UHUBCF_RELEASE]
#define	UHUB_UNK_PORT		UHUBCF_PORT_DEFAULT /* wildcarded 'port' */
#define	UHUB_UNK_CONFIGURATION	UHUBCF_CONFIGURATION_DEFAULT /* wildcarded 'configuration' */
#define	UHUB_UNK_INTERFACE	UHUBCF_INTERFACE_DEFAULT /* wildcarded 'interface' */
#define	UHUB_UNK_VENDOR		UHUBCF_VENDOR_DEFAULT /* wildcarded 'vendor' */
#define	UHUB_UNK_PRODUCT	UHUBCF_PRODUCT_DEFAULT /* wildcarded 'product' */
#define	UHUB_UNK_RELEASE	UHUBCF_RELEASE_DEFAULT /* wildcarded 'release' */
@


1.64
log
@Use understandable messages when the per-xfer poison value is incorrect.
Prodded by a comment from stsp@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.63 2014/10/30 23:50:25 mpi Exp $ */
d232 2
a233 4
usbd_status	usbd_port_disown_to_1_1(struct usbd_device *, 
		    int, usb_port_status_t *);
usbd_status	usbd_reset_port(struct usbd_device *,
		    int, usb_port_status_t *);
@


1.63
log
@XFER_FREE is not used, ciao.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.62 2014/08/09 09:45:14 mpi Exp $ */
d195 1
a195 1
#define XFER_BUSY 0x42555359
a222 1
#ifdef USB_DEBUG
a227 1
#endif
@


1.62
log
@Do not store the whole USB hub descriptor in the "struct usbd_hub"
to help integrating super speed hubs that use a different descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.61 2014/07/09 18:15:04 mpi Exp $ */
a194 1
#define XFER_FREE 0x46524545
@


1.61
log
@autoconf(9) is your friend and it knows you more than you think.  It
even knows your children!  So let him handle the seperation correctly.

Do not rewrite your own custom config_detach_children(9) and as a bonus
start removing the usbd_port tentacles from the stack.

ok pirofti@@, yuo@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.60 2014/07/09 15:47:54 mpi Exp $ */
d93 2
a94 1
	usb_hub_descriptor_t	hubdesc;
@


1.60
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.59 2014/05/28 11:20:55 mpi Exp $ */
d248 1
a248 1
void		usb_disconnect_port(struct usbd_port *, struct device *);
@


1.59
log
@Apart from the early exploration done to find a console keyboard during
the boot process, USB devices must be attached or detached from the usb
task thread in order to avoid races with periodical explorations issued
by uhub(4) interrupts.

Respect this rule when detaching root hubs during a suspend/resume cycle
and avoid some hangs due to the aforementioned race.

Tested by Mattieu Baptiste, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.58 2014/03/29 18:09:31 guenther Exp $ */
d58 1
d241 1
@


1.58
log
@It's been a quarter century: we can assume volatile is present with that name.

ok dlg@@ mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.57 2014/03/14 14:11:31 pirofti Exp $ */
d108 1
@


1.57
log
@Have some style.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.56 2014/03/08 11:44:17 mpi Exp $ */
d189 1
a189 1
	__volatile char		done;
@


1.56
log
@Add defines for upcoming USB 3.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.55 2014/03/06 23:53:11 mpi Exp $ */
d57 1
a57 1
	usbd_status	      (*open_pipe)(struct usbd_pipe *pipe);
d65 6
a70 6
	usbd_status	      (*transfer)(struct usbd_xfer *xfer);
	usbd_status	      (*start)(struct usbd_xfer *xfer);
	void		      (*abort)(struct usbd_xfer *xfer);
	void		      (*close)(struct usbd_pipe *pipe);
	void		      (*cleartoggle)(struct usbd_pipe *pipe);
	void		      (*done)(struct usbd_xfer *xfer);
d90 1
a90 1
	int		      (*explore)(struct usbd_device *hub);
d222 5
a226 5
void usbd_dump_iface(struct usbd_interface *iface);
void usbd_dump_device(struct usbd_device *dev);
void usbd_dump_endpoint(struct usbd_endpoint *endp);
void usbd_dump_queue(struct usbd_pipe *pipe);
void usbd_dump_pipe(struct usbd_pipe *pipe);
d232 14
a245 14
usbd_status	usbd_port_disown_to_1_1(struct usbd_device *dev, 
		    int port, usb_port_status_t *ps);
usbd_status	usbd_reset_port(struct usbd_device *dev,
		    int port, usb_port_status_t *ps);
usbd_status	usbd_setup_pipe(struct usbd_device *dev,
		    struct usbd_interface *iface, struct usbd_endpoint *, int,
		    struct usbd_pipe **pipe);
usbd_status	usbd_new_device(struct device *parent, struct usbd_bus *bus,
		    int depth, int lowspeed, int port, struct usbd_port *);
usbd_status	usbd_fill_iface_data(struct usbd_device *dev, int i, int a);

usbd_status	usb_insert_transfer(struct usbd_xfer *xfer);
void		usb_transfer_complete(struct usbd_xfer *xfer);
void		usb_disconnect_port(struct usbd_port *up, struct device *);
@


1.55
log
@Turn usbd_xfer_isread() into a public function so that we can use
it in various drivers, mainly HC, instead of always rerolling our
own.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.54 2014/03/06 23:51:04 mpi Exp $ */
d118 2
a119 1
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }
@


1.54
log
@Add include guards.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.53 2013/11/01 12:00:54 mpi Exp $ */
d284 9
@


1.53
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.52 2013/10/19 08:29:30 mpi Exp $ */
d35 3
d284 2
@


1.52
log
@Make uhub_explore() return an int rather than a usbd_satus.  This has
no direct impact since its return value is never checked but it allows
me to get rid of one (usless) status value.

Note that usbd_status should be used for USB transfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.51 2013/08/13 09:26:05 mpi Exp $ */
d213 1
@


1.51
log
@Remove bogus and useless refcounting of usbd pipes that could lead to
memory leaks and abort the pipe if requests are still pending because
most of our drivers don't do anything if usbd_close_pipe() fails.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.50 2013/08/08 09:44:22 mpi Exp $ */
d87 1
a87 1
	usbd_status	      (*explore)(struct usbd_device *hub);
@


1.50
log
@These functions should only used in the usb-autoconf glue, do not expose
them.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.49 2013/04/26 14:05:24 mpi Exp $ */
a161 1
	int			refcnt;
@


1.49
log
@Give back to usb(4) what is usb(4)'s. In other words use the usb_* prefix
for functions related to the usb(4) driver and keep usbd_* for generic
USB layer functions.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.48 2013/04/19 08:58:53 mpi Exp $ */
a236 1
int		usbd_printBCD(char *cp, size_t len, int bcd);
a237 1
void		usb_free_device(struct usbd_device *, struct usbd_port *);
@


1.48
log
@Remove allocm() and freem() from the USB bus interface now that they
are only used as wrappers around usb_{alloc,free}mem().

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.47 2013/04/15 09:23:02 mglocker Exp $ */
a215 5

void usbd_init(void);
void usbd_finish(void);
void usb_begin_tasks(void);
void usb_end_tasks(void);
@


1.47
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.46 2013/03/28 03:58:03 tedu Exp $ */
a56 3
	usbd_status	      (*allocm)(struct usbd_bus *, struct usb_dma *,
					u_int32_t bufsize);
	void		      (*freem)(struct usbd_bus *, struct usb_dma *);
@


1.46
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.45 2013/03/16 11:11:22 mpi Exp $ */
d39 1
a39 1
typedef struct {
d42 1
a42 1
} usb_dma_t;
d57 1
a57 1
	usbd_status	      (*allocm)(struct usbd_bus *, usb_dma_t *,
d59 1
a59 1
	void		      (*freem)(struct usbd_bus *, usb_dma_t *);
d65 6
a70 6
	usbd_status	      (*transfer)(usbd_xfer_handle xfer);
	usbd_status	      (*start)(usbd_xfer_handle xfer);
	void		      (*abort)(usbd_xfer_handle xfer);
	void		      (*close)(usbd_pipe_handle pipe);
	void		      (*cleartoggle)(usbd_pipe_handle pipe);
	void		      (*done)(usbd_xfer_handle xfer);
d90 1
a90 1
	usbd_status	      (*explore)(usbd_device_handle hub);
d103 1
a103 1
	usbd_device_handle	devices[USB_MAX_DEVICES];
d171 1
a171 1
	usbd_xfer_handle	intrxfer; /* used for repeating requests */
d206 1
a206 1
	usb_dma_t		dmabuf;
d229 2
a230 2
void usbd_dump_queue(usbd_pipe_handle pipe);
void usbd_dump_pipe(usbd_pipe_handle pipe);
d235 2
a236 2
void		usb_delay_ms(usbd_bus_handle, u_int);
usbd_status	usbd_port_disown_to_1_1(usbd_device_handle dev, 
d238 1
a238 1
usbd_status	usbd_reset_port(usbd_device_handle dev,
d240 4
a243 4
usbd_status	usbd_setup_pipe(usbd_device_handle dev,
		    usbd_interface_handle iface, struct usbd_endpoint *, int,
		    usbd_pipe_handle *pipe);
usbd_status	usbd_new_device(struct device *parent, usbd_bus_handle bus,
d246 2
a247 2
usbd_status	usbd_fill_iface_data(usbd_device_handle dev, int i, int a);
void		usb_free_device(usbd_device_handle, struct usbd_port *);
d249 2
a250 2
usbd_status	usb_insert_transfer(usbd_xfer_handle xfer);
void		usb_transfer_complete(usbd_xfer_handle xfer);
d254 2
a255 2
void		usb_needs_explore(usbd_device_handle, int);
void		usb_needs_reattach(usbd_device_handle);
@


1.45
log
@No need for two similar functions to free/remove USB device descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.44 2012/05/15 12:48:32 mpi Exp $ */
d34 2
@


1.44
log
@Don't use a pointer to an opaque softc, we'll need to access its unit
number. No functional change.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.43 2012/01/08 13:12:38 miod Exp $ */
a242 1
void		usbd_remove_device(usbd_device_handle, struct usbd_port *);
d245 1
a245 1
void		usb_free_device(usbd_device_handle);
@


1.43
log
@Remove usb_event_cookie_t type and instances of it found in various structs;
leftover from the "usb event" stuff removal. Diff from Tobias Ulmer.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.42 2011/01/16 22:35:29 jakemsr Exp $ */
a93 4
struct usb_softc;

/*****/

d106 1
a106 1
	struct usb_softc       *usbctl;
@


1.42
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.41 2010/12/30 05:10:35 jakemsr Exp $ */
a137 1
	usb_event_cookie_t	cookie;	       /* unique connection id */
@


1.41
log
@* add a process reference counting variable to struct usbd_device
* add functions to increment and decrement the reference count, and a
  function to wait until the reference count is zero
ok martynas@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.40 2010/12/06 04:25:27 jakemsr Exp $ */
d150 1
d161 1
@


1.40
log
@* add dying flag to struct usbd_device
* add usbd_deactivate(), which should be use to set the dying flag in
  struct usbd_device
* add usbd_is_dying(), which can be used to check if either the device
  or the associated bus dying flag has been set
* use usbd_is_dying() to check if the deivce or bus is dying before
  issuing transfers or requests
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.39 2010/09/23 05:44:16 jakemsr Exp $ */
d128 2
a129 1
	u_int8_t		dying;	       /* removed */
@


1.39
log
@add a 'dying' flag to struct usbd_bus.  use this to signify the bus
is dying, instead of setting a flag in struct usb_softc.  as
usbd_device_handle has a pointer to the usbd_bus it's attached to,
usb devices, and functions they run or functions run on their behalf,
can now easily check if their bus is dying.  use this to stop
usbd_do_request* from running and the usb task thread from adding
new tasks when a device's bus is dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.38 2010/09/23 04:58:02 jakemsr Exp $ */
d128 1
@


1.38
log
@instead of running usb_explore() from individual kthreads for each
USB bus, make usb_explore() a usb_task.  reduces races during normal
USB device detach, since now usb_tasks and detach happen in the same
process.
ok yuo@@, matthew@@ helped with the task thread loop
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.37 2009/11/12 20:16:37 deraadt Exp $ */
d107 1
@


1.37
log
@Avoid using the trick of malloc'ing more than a struct to grow the array
of the last element.  Bad technique.  Use a pointer to the array.  The
author (or later people) will often not pay attention to the consequences
of structure padding & alignment issues when they add new fields to the
base structure, and there will be fireworks.
tested by jasper, too
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.36 2009/11/04 19:14:10 kettenis Exp $ */
a105 1
	char			needs_explore;/* a hub a signalled a change */
d107 2
d220 2
d253 1
a253 1
void		usb_needs_explore(usbd_device_handle);
@


1.36
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.35 2009/08/30 19:15:40 miod Exp $ */
d91 1
a91 1
	struct usbd_port        ports[1];
@


1.35
log
@Reinstate SPLUSBCHECK checks (DIAGNOSTIC-only), but implemented as splassert(),
which is exactly what it was trying to do.

Tested on all *hci controllers with a bunch of usb devices by at least ckuethe@@
and I.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.34 2008/06/29 10:04:15 yuo Exp $ */
a118 2

#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a119 1
#endif
@


1.34
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.33 2008/06/26 05:42:19 ray Exp $ */
a255 14

/*
 * XXX This check is extremely bogus. Bad Bad Bad.
 */
#if defined(DIAGNOSTIC) && 0
#define SPLUSBCHECK \
	do { int _s = splusb(), _su = splusb(); \
             if (!cold && _s != _su) printf("SPLUSBCHECK failed 0x%x!=0x%x, %s:%d\n", \
				   _s, _su, __FILE__, __LINE__); \
	     splx(_s); \
        } while (0)
#else
#define SPLUSBCHECK
#endif
@


1.33
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.32 2007/06/15 11:41:48 mbalmer Exp $ */
d234 2
@


1.32
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.31 2007/06/13 11:31:33 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.31
log
@Remove the definition and (single) use of the DECLARE_USB_DMA_T macro.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.30 2007/06/13 06:25:03 mbalmer Exp $ */
a126 1
#ifdef USB_USE_SOFTINTR
a128 3
#else
	struct timeout		softi;
#endif
@


1.30
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.29 2007/06/12 16:26:37 mbalmer Exp $ */
d43 5
a47 1
DECLARE_USB_DMA_T;
@


1.29
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.28 2007/06/10 10:15:35 mbalmer Exp $ */
d155 1
a155 1
	struct device *	       *subdevs;       /* sub-devices, 0 terminated */
d242 1
a242 1
				int port, usb_port_status_t *ps);
d244 4
a247 7
				usbd_interface_handle iface,
				struct usbd_endpoint *, int,
				usbd_pipe_handle *pipe);
usbd_status	usbd_new_device(struct device *parent,
				usbd_bus_handle bus, int depth,
				int lowspeed, int port,
				struct usbd_port *);
@


1.28
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.27 2007/06/06 19:25:49 mk Exp $ */
d155 1
a155 1
	device_ptr_t	       *subdevs;       /* sub-devices, 0 terminated */
d247 1
a247 1
usbd_status	usbd_new_device(device_ptr_t parent,
d258 1
a258 1
void		usb_disconnect_port(struct usbd_port *up, device_ptr_t);
@


1.27
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.26 2007/06/04 10:38:05 mbalmer Exp $ */
d127 1
a127 1
	usb_callout_t		softi;
d224 1
a224 1
	usb_callout_t		timeout_handle;
@


1.26
log
@Forgot this in my last committ.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.25 2007/05/20 14:14:12 miod Exp $ */
d103 1
a103 1
	USBBASEDEVICE		bdev; /* base device, host adapter */
@


1.25
log
@addess -> address
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.24 2006/05/31 06:18:09 pascoe Exp $ */
a41 4
#if defined(__NetBSD__)
#include <sys/callout.h>
#endif

a129 2

#if defined(__NetBSD__) || defined(__OpenBSD__)
a130 1
#endif
a280 3
#if defined(__NetBSD__)
#include "locators.h"
#elif defined(__FreeBSD__) || defined(__OpenBSD__)
a291 1
#endif
a292 1
#if defined (__OpenBSD__)
a298 1
#endif
a311 1

@


1.24
log
@Save and restore the data toggle value when a pipe to an endpoint
is closed and then reopened.  This may be necessary now that
we no longer clear endpoint stalls every time a pipe is opened.
Previously we could assume an initial toggle value of zero because
a clear-stall operation resets the device's toggle state.

Derived from work in FreeBSD.

This is most likely to affect devices like printers, which open
pipes for short periods of time and close them again.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.23 2005/03/13 02:54:04 pascoe Exp $ */
d143 1
a143 1
	u_int8_t		address;       /* device addess */
@


1.23
log
@Merge support for USB1 devices located beyond USB2 hubs, mostly from netbsd.

Supports bulk, control and interrupt pipes, letting USB1 keyboards and most
network interfaces work when connected to a USB2 hub.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.22 2004/12/12 05:21:14 dlg Exp $ */
d55 1
@


1.22
log
@get rid of uhub_reset_device
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.21 2004/12/12 05:17:40 dlg Exp $ */
d77 4
d90 1
d153 1
a153 1
	struct usbd_device     *myhighhub;     /* closest high speed hub */
@


1.21
log
@better way to do the reattachement of a device
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.20 2004/12/09 11:49:55 dlg Exp $ */
a89 1
	usbd_status	      (*reset_device)(usbd_device_handle, int);
@


1.20
log
@code to let us cause a detach and reattach of a device from software

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.19 2003/07/08 13:19:09 nate Exp $ */
d83 1
d264 1
@


1.19
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.18 2003/05/07 04:33:33 deraadt Exp $ */
d89 1
@


1.18
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.17 2002/07/25 02:18:11 nate Exp $ */
/*	$NetBSD: usbdivar.h,v 1.63 2001/01/21 19:00:06 augustss Exp $	*/
d83 1
a83 1
	struct usbd_device     *device;
a119 1
#if 0
d124 1
a124 2
	struct callout		softi;
#endif
d139 1
a139 1
	u_int8_t		lowspeed;      /* lowspeed flag */
d146 2
a181 2
	usb_callout_t		abort_handle;

d200 2
a201 1
#define XFER_BUSY 0x42555357
d229 8
@


1.17
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.16 2002/05/07 18:29:19 nate Exp $ */
d245 1
a245 1
int		usbd_printBCD(char *cp, int bcd);
@


1.16
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.14 2001/10/31 04:24:45 nate Exp $ */
d240 1
a240 1
usbd_status	usbd_new_device(device_ptr_t parent, 
d242 1
a242 1
				int lowspeed, int port, 
@


1.15
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: usbdivar.h,v 1.69 2001/12/27 18:43:46 augustss Exp $	*/
d83 1
a83 1
	struct usbd_device     *device;	/* Connected device */
d120 1
d125 2
a126 1
	usb_callout_t		softi;
d141 1
a141 1
	u_int8_t		speed;         /* low/full/high speed */
a147 2
	struct usbd_device     *myhub; 	       /* upstream hub */
	struct usbd_device     *myhighhub;     /* closest high speed hub */
d182 2
d202 1
a202 2
#define XFER_BUSY 0x42555359
#define XFER_ONQU 0x4f4e5155
a229 8

#ifdef USB_DEBUG
void usbd_dump_iface(struct usbd_interface *iface);
void usbd_dump_device(struct usbd_device *dev);
void usbd_dump_endpoint(struct usbd_endpoint *endp);
void usbd_dump_queue(usbd_pipe_handle pipe);
void usbd_dump_pipe(usbd_pipe_handle pipe);
#endif
@


1.14
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.13 2001/05/03 02:20:34 aaron Exp $ */
/*	$NetBSD: usbdivar.h,v 1.63 2001/01/21 19:00:06 augustss Exp $	*/
d83 1
a83 1
	struct usbd_device     *device;
a119 1
#if 0
d124 1
a124 2
	struct callout		softi;
#endif
d139 1
a139 1
	u_int8_t		lowspeed;      /* lowspeed flag */
d146 2
a181 2
	usb_callout_t		abort_handle;

d200 2
a201 1
#define XFER_BUSY 0x42555357
d229 8
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.14 2001/10/31 04:24:45 nate Exp $ */
@


1.14.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.14.2.1 2002/06/11 03:42:31 art Exp $ */
d240 1
a240 1
usbd_status	usbd_new_device(device_ptr_t parent,
d242 1
a242 1
				int lowspeed, int port,
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d245 1
a245 1
int		usbd_printBCD(char *cp, size_t len, int bcd);
@


1.13
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.12 2001/01/28 09:43:43 aaron Exp $ */
d59 1
a59 1
	void		      (*soft_intr)(struct usbd_bus *);
d118 11
a128 1
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1" }
@


1.12
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.11 2000/11/08 18:10:39 aaron Exp $ */
/*	$NetBSD: usbdivar.h,v 1.60 2000/12/28 10:40:36 augustss Exp $	*/
d244 1
a244 1
void		usb_needs_explore(usbd_bus_handle);
@


1.11
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.10 2000/07/04 11:44:26 fgsch Exp $ */
/*	$NetBSD: usbdivar.h,v 1.56 2000/06/01 14:29:03 augustss Exp $	*/
d117 1
d143 1
a143 1
	struct usbd_quirks     *quirks;        /* device quirks, always set */
a223 1
void		usbd_devinfo_vp(usbd_device_handle, char *, char *);
@


1.10
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.9 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: usbdivar.h,v 1.55 2000/03/30 00:18:18 augustss Exp $	*/
d58 8
a65 9
	usbd_status	      (*open_pipe)__P((struct usbd_pipe *pipe));
	void		      (*soft_intr)__P((struct usbd_bus *));
	void		      (*do_poll)__P((struct usbd_bus *));
	usbd_status	      (*allocm)__P((struct usbd_bus *, usb_dma_t *,
					    u_int32_t bufsize));
	void		      (*freem)__P((struct usbd_bus *, usb_dma_t *));
	struct usbd_xfer *    (*allocx)__P((struct usbd_bus *));
	void		      (*freex)__P((struct usbd_bus *,
					   struct usbd_xfer *));
d69 6
a74 6
	usbd_status	      (*transfer)__P((usbd_xfer_handle xfer));
	usbd_status	      (*start)__P((usbd_xfer_handle xfer));
	void		      (*abort)__P((usbd_xfer_handle xfer));
	void		      (*close)__P((usbd_pipe_handle pipe));
	void		      (*cleartoggle)__P((usbd_pipe_handle pipe));
	void		      (*done)__P((usbd_xfer_handle xfer));
d88 1
a88 1
	usbd_status	      (*explore)__P((usbd_device_handle hub));
d217 2
a218 2
void usbd_init __P((void));
void usbd_finish __P((void));
d221 21
a241 23
int		usbctlprint __P((void *, const char *));
void		usb_delay_ms __P((usbd_bus_handle, u_int));
void		usbd_devinfo_vp __P((usbd_device_handle, char *, char *));
usbd_status	usbd_reset_port __P((usbd_device_handle dev,
				     int port, usb_port_status_t *ps));
usbd_status	usbd_setup_pipe __P((usbd_device_handle dev,
				     usbd_interface_handle iface,
				     struct usbd_endpoint *, int,
				     usbd_pipe_handle *pipe));
usbd_status	usbd_new_device __P((device_ptr_t parent, 
				     usbd_bus_handle bus, int depth,
				     int lowspeed, int port, 
				     struct usbd_port *));
void		usbd_remove_device __P((usbd_device_handle,
					struct usbd_port *));
int		usbd_printBCD __P((char *cp, int bcd));
usbd_status	usbd_fill_iface_data __P((usbd_device_handle dev, 
					  int i, int a));
void		usb_free_device __P((usbd_device_handle));

usbd_status	usb_insert_transfer __P((usbd_xfer_handle xfer));
void		usb_transfer_complete __P((usbd_xfer_handle xfer));
void		usb_disconnect_port __P((struct usbd_port *up, device_ptr_t));
d244 2
a245 2
void		usb_needs_explore __P((usbd_bus_handle));
void		usb_schedsoftintr __P((struct usbd_bus *));
@


1.9
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.8 2000/03/28 19:37:53 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d250 4
a253 1
#ifdef DIAGNOSTIC
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdivar.h,v 1.52 2000/03/25 18:02:33 augustss Exp $	*/
d42 1
a42 1
#if defined(__NetBSD__) || defined(__FreeBSD__)
a43 2
#else
#include <sys/timeout.h>
d164 1
a252 1
	     extern int cold; \
@


1.7
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: usbdivar.h,v 1.6 1999/11/07 21:30:20 fgsch Exp $	*/
/*	$NetBSD: usbdivar.h,v 1.47 2000/02/22 11:30:56 augustss Exp $	*/
d42 6
d115 5
a119 5
	int			usbrev; /* USB revision */
#define USBREV_UNKNOWN 0
#define USBREV_PRE_1_0 1
#define USBREV_1_0     2
#define USBREV_1_1     3
d128 9
a136 9
	struct usbd_bus	       *bus;		/* our controller */
	struct usbd_pipe       *default_pipe;	/* pipe 0 */
	u_int8_t		address;	/* device address */
	u_int8_t		config;		/* current configuration # */
	u_int8_t		depth;		/* distance from root hub */
	u_int8_t		lowspeed;	/* lowspeed flag */
	u_int8_t		self_powered;	/* flag for self powered */
	u_int16_t		power;		/* mA the device uses */
	int16_t			langid;		/* language for strings */
d138 10
a147 10
	usb_event_cookie_t	cookie;		/* unique connection id */
	struct usbd_port       *powersrc;	/* upstream hub port, or 0 */
	struct usbd_endpoint	def_ep;		/* for pipe 0 */
	usb_endpoint_descriptor_t def_ep_desc;	/* for pipe 0 */
	struct usbd_interface  *ifaces;		/* array of all interfaces */
	usb_device_descriptor_t ddesc;		/* device descriptor */
	usb_config_descriptor_t *cdesc;		/* full config descr */
	struct usbd_quirks     *quirks;		/* device quirks, always set */
	struct usbd_hub	       *hub;		/* only if this is a hub */
	device_ptr_t	       *subdevs;	/* sub-devices, 0 terminated */
d173 2
d190 5
a214 1
	int			hcprivint;
d216 1
a216 3
#if defined(__FreeBSD__)
	struct callout_handle  timo_handle;
#endif
d257 1
a257 1
             splx(_s); \
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: usbdivar.h,v 1.38 1999/10/25 10:51:46 augustss Exp $	*/
d44 1
a44 1
struct usbd_request;
d54 1
d59 3
d65 3
a67 3
	usbd_status	      (*transfer)__P((usbd_request_handle reqh));
	usbd_status	      (*start)__P((usbd_request_handle reqh));
	void		      (*abort)__P((usbd_request_handle reqh));
d70 1
a70 1
	void		      (*done)__P((usbd_request_handle reqh));
d108 7
d121 9
a129 9
	struct usbd_bus	       *bus;
	struct usbd_pipe       *default_pipe;
	u_int8_t		address;
	u_int8_t		depth;
	u_int8_t		lowspeed;
	u_int16_t		power;
	u_int8_t		self_powered;
	int			config;
	int			langid;	/* language to use for strings */
d131 9
a139 9
	usb_event_cookie_t	cookie;	/* unique connection id */
	struct usbd_port       *powersrc;
	struct usbd_endpoint	def_ep;	/* for pipe 0 */
	usb_endpoint_descriptor_t def_ep_desc; /* for pipe 0 */
	struct usbd_interface  *ifaces;
	usb_device_descriptor_t ddesc;
	usb_config_descriptor_t *cdesc;	/* full config descr */
	struct usbd_quirks     *quirks;
	struct usbd_hub	       *hub; /* only if this is a hub */
d159 1
a159 1
	SIMPLEQ_HEAD(, usbd_request) queue;
d162 1
a162 1
	usbd_request_handle     intrreqh; /* used for repeating requests */
d164 1
d170 1
a170 1
struct usbd_request {
d198 1
a198 1
	SIMPLEQ_ENTRY(usbd_request) next;
d201 1
a201 1
	int			hcprivint; /* ditto */
d219 1
a219 1
				     struct usbd_endpoint *,
d232 2
a233 2
usbd_status	usb_insert_transfer __P((usbd_request_handle reqh));
void		usb_transfer_complete __P((usbd_request_handle reqh));
a236 1
int		usb_bus_count __P((void));
d238 1
d246 1
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: usbdivar.h,v 1.12 2001/01/28 09:43:43 aaron Exp $ */
/*	$NetBSD: usbdivar.h,v 1.60 2000/12/28 10:40:36 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/usbdivar.h,v 1.11 1999/11/17 22:33:51 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a40 4
#if defined(__NetBSD__)
#include <sys/callout.h>
#endif

d44 1
a44 1
struct usbd_xfer;
d53 5
a57 8
	usbd_status	      (*open_pipe)(struct usbd_pipe *pipe);
	void		      (*soft_intr)(struct usbd_bus *);
	void		      (*do_poll)(struct usbd_bus *);
	usbd_status	      (*allocm)(struct usbd_bus *, usb_dma_t *,
					u_int32_t bufsize);
	void		      (*freem)(struct usbd_bus *, usb_dma_t *);
	struct usbd_xfer *    (*allocx)(struct usbd_bus *);
	void		      (*freex)(struct usbd_bus *, struct usbd_xfer *);
d61 6
a66 6
	usbd_status	      (*transfer)(usbd_xfer_handle xfer);
	usbd_status	      (*start)(usbd_xfer_handle xfer);
	void		      (*abort)(usbd_xfer_handle xfer);
	void		      (*close)(usbd_pipe_handle pipe);
	void		      (*cleartoggle)(usbd_pipe_handle pipe);
	void		      (*done)(usbd_xfer_handle xfer);
d80 1
a80 1
	usbd_status	      (*explore)(usbd_device_handle hub);
a103 8
	int			usbrev;	/* USB revision */
#define USBREV_UNKNOWN	0
#define USBREV_PRE_1_0	1
#define USBREV_1_0	2
#define USBREV_1_1	3
#define USBREV_2_0	4
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1" }

d110 9
a118 9
	struct usbd_bus	       *bus;           /* our controller */
	struct usbd_pipe       *default_pipe;  /* pipe 0 */
	u_int8_t		address;       /* device addess */
	u_int8_t		config;	       /* current configuration # */
	u_int8_t		depth;         /* distance from root hub */
	u_int8_t		lowspeed;      /* lowspeed flag */
	u_int8_t		self_powered;  /* flag for self powered */
	u_int16_t		power;         /* mA the device uses */
	int16_t			langid;	       /* language for strings */
d120 3
a122 3
	usb_event_cookie_t	cookie;	       /* unique connection id */
	struct usbd_port       *powersrc;      /* upstream hub port, or 0 */
	struct usbd_endpoint	def_ep;	       /* for pipe 0 */
d124 6
a129 6
	struct usbd_interface  *ifaces;        /* array of all interfaces */
	usb_device_descriptor_t ddesc;         /* device descriptor */
	usb_config_descriptor_t *cdesc;	       /* full config descr */
	const struct usbd_quirks     *quirks;  /* device quirks, always set */
	struct usbd_hub	       *hub;           /* only if this is a hub */
	device_ptr_t	       *subdevs;       /* sub-devices, 0 terminated */
d148 1
a148 2
	char			aborting;
	SIMPLEQ_HEAD(, usbd_xfer) queue;
d151 1
a151 1
	usbd_xfer_handle	intrxfer; /* used for repeating requests */
a152 3
	int			interval;

	usb_callout_t		abort_handle;
d158 1
a158 1
struct usbd_xfer {
a168 5
#ifdef DIAGNOSTIC
	u_int32_t		busy_free;
#define XFER_FREE 0x46524545
#define XFER_BUSY 0x42555357
#endif
d186 1
a186 1
	SIMPLEQ_ENTRY(usbd_xfer) next;
d189 1
d191 3
a193 1
	usb_callout_t		timeout_handle;
d196 2
a197 2
void usbd_init(void);
void usbd_finish(void);
d200 23
a222 20
int		usbctlprint(void *, const char *);
void		usb_delay_ms(usbd_bus_handle, u_int);
usbd_status	usbd_reset_port(usbd_device_handle dev,
				int port, usb_port_status_t *ps);
usbd_status	usbd_setup_pipe(usbd_device_handle dev,
				usbd_interface_handle iface,
				struct usbd_endpoint *, int,
				usbd_pipe_handle *pipe);
usbd_status	usbd_new_device(device_ptr_t parent, 
				usbd_bus_handle bus, int depth,
				int lowspeed, int port, 
				struct usbd_port *);
void		usbd_remove_device(usbd_device_handle, struct usbd_port *);
int		usbd_printBCD(char *cp, int bcd);
usbd_status	usbd_fill_iface_data(usbd_device_handle dev, int i, int a);
void		usb_free_device(usbd_device_handle);

usbd_status	usb_insert_transfer(usbd_xfer_handle xfer);
void		usb_transfer_complete(usbd_xfer_handle xfer);
void		usb_disconnect_port(struct usbd_port *up, device_ptr_t);
d225 2
a226 2
void		usb_needs_explore(usbd_bus_handle);
void		usb_schedsoftintr(struct usbd_bus *);
d228 1
a228 4
/*
 * XXX This check is extremely bogus. Bad Bad Bad.
 */
#if defined(DIAGNOSTIC) && 0
d231 1
a233 1
	     splx(_s); \
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdivar.h,v 1.63 2001/01/21 19:00:06 augustss Exp $	*/
d244 1
a244 1
void		usb_needs_explore(usbd_device_handle);
@


1.6.2.3
log
@Merge in -current
@
text
@d59 1
a59 1
	void		      (*soft_intr)(void *);
d118 1
a118 11
#define USBREV_STR { "unknown", "pre 1.0", "1.0", "1.1", "2.0" }

#if 0
#ifdef USB_USE_SOFTINTR
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
	void		       *soft; /* soft interrupt cookie */
#else
	struct callout		softi;
#endif
#endif
#endif
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d240 1
a240 1
usbd_status	usbd_new_device(device_ptr_t parent,
d242 1
a242 1
				int lowspeed, int port,
@


1.6.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.6.2.4 2003/03/28 00:38:32 niklas Exp $ */
d245 1
a245 1
int		usbd_printBCD(char *cp, size_t len, int bcd);
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: usbdivar.h,v 1.70 2002/07/11 21:14:36 augustss Exp $	*/
d83 1
a83 1
	struct usbd_device     *device;	/* Connected device */
d120 1
d125 2
a126 1
	usb_callout_t		softi;
d141 1
a141 1
	u_int8_t		speed;         /* low/full/high speed */
a147 2
	struct usbd_device     *myhub; 	       /* upstream hub */
	struct usbd_device     *myhighhub;     /* closest high speed hub */
d182 2
d202 1
a202 2
#define XFER_BUSY 0x42555359
#define XFER_ONQU 0x4f4e5155
a229 8

#ifdef USB_DEBUG
void usbd_dump_iface(struct usbd_interface *iface);
void usbd_dump_device(struct usbd_device *dev);
void usbd_dump_endpoint(struct usbd_endpoint *endp);
void usbd_dump_queue(usbd_pipe_handle pipe);
void usbd_dump_pipe(usbd_pipe_handle pipe);
#endif
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdivar.h,v 1.35 1999/09/15 21:08:19 augustss Exp $	*/
d120 1
d197 1
d222 1
a222 1
void		usb_disconnect_port __P((struct usbd_port *up));
d231 2
a232 1
             if (_s != _su) printf("SPLUSBCHECK failed 0x%x!=0x%x, %s:%d\n", \
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: usbdivar.h,v 1.3 1999/08/27 09:00:30 fgsch Exp $	*/
/*	$NetBSD: usbdivar.h,v 1.24 1999/08/17 20:59:04 augustss Exp $	*/
d41 3
d52 9
a60 1
struct usbd_methods {
a66 2
	usbd_status	      (*isobuf)__P((usbd_pipe_handle pipe,
					    u_int32_t bufsize,u_int32_t nbuf));
d92 2
a93 2
	bdevice			bdev; /* base device, host adapter */
	usbd_status	      (*open_pipe)__P((struct usbd_pipe *pipe));
a94 1
	void		      (*do_poll)__P((struct usbd_bus *));
d102 5
d128 1
a128 1
	bdevice		      **subdevs;	/* sub-devices, 0 terminated */
d154 1
a154 1
	struct usbd_methods    *methods;
d169 1
d171 13
a183 1
	char			isreq;
d187 2
a188 1
	void		       *hcpriv; /* XXX private use by the HC driver */
d207 1
a207 1
usbd_status	usbd_new_device __P((bdevice *parent, 
d220 1
d225 9
a233 2
#if 0
usbd_status	usb_get_bus_handle __P((int, usbd_bus_handle *));
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 1
a1 1
/*	$OpenBSD: usbdivar.h,v 1.2 1999/08/19 08:18:39 fgsch Exp $	*/
d115 1
a115 1
	struct device	      **subdevs;	/* sub-devices, 0 terminated */
d154 1
a154 1
	char			done;
@


1.2
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
a48 2
typedef void (*usbd_xfercb)__P((usbd_request_handle req));

d55 1
a153 2
	usbd_xfercb		xfercb;
	u_int32_t		retries;
d157 1
a157 1
	u_int8_t		isreq;
a186 2
usbd_status	usb_insert_transfer __P((usbd_request_handle reqh));
void		usb_start_next __P((usbd_pipe_handle pipe));
d190 3
@


1.1
log
@From NetBSD; USB support.
@
text
@d2 1
a2 1
/*	$NetBSD: usbdivar.h,v 1.22 1999/06/30 06:44:23 augustss Exp $	*/
a46 1
	int			toggle;	/* XXX */
d55 2
a56 1
	void		      (*close)__P((usbd_pipe_handle pipe));	
@

