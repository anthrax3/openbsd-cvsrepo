head	1.89;
access;
symbols
	OPENBSD_6_1_BASE:1.89
	OPENBSD_6_0:1.88.0.6
	OPENBSD_6_0_BASE:1.88
	OPENBSD_5_9:1.88.0.2
	OPENBSD_5_9_BASE:1.88
	OPENBSD_5_8:1.86.0.4
	OPENBSD_5_8_BASE:1.86
	OPENBSD_5_7:1.83.0.2
	OPENBSD_5_7_BASE:1.83
	OPENBSD_5_6:1.69.0.4
	OPENBSD_5_6_BASE:1.69
	OPENBSD_5_5:1.63.0.4
	OPENBSD_5_5_BASE:1.63
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.59.0.6
	OPENBSD_5_3_BASE:1.59
	OPENBSD_5_2:1.59.0.4
	OPENBSD_5_2_BASE:1.59
	OPENBSD_5_1_BASE:1.59
	OPENBSD_5_1:1.59.0.2
	OPENBSD_5_0:1.58.0.2
	OPENBSD_5_0_BASE:1.58
	OPENBSD_4_9:1.57.0.2
	OPENBSD_4_9_BASE:1.57
	OPENBSD_4_8:1.52.0.4
	OPENBSD_4_8_BASE:1.52
	OPENBSD_4_7:1.52.0.2
	OPENBSD_4_7_BASE:1.52
	OPENBSD_4_6:1.49.0.8
	OPENBSD_4_6_BASE:1.49
	OPENBSD_4_5:1.49.0.4
	OPENBSD_4_5_BASE:1.49
	OPENBSD_4_4:1.49.0.2
	OPENBSD_4_4_BASE:1.49
	OPENBSD_4_3:1.48.0.2
	OPENBSD_4_3_BASE:1.48
	OPENBSD_4_2:1.47.0.2
	OPENBSD_4_2_BASE:1.47
	OPENBSD_4_1:1.34.0.2
	OPENBSD_4_1_BASE:1.34
	OPENBSD_4_0:1.34.0.4
	OPENBSD_4_0_BASE:1.34
	OPENBSD_3_9:1.32.0.4
	OPENBSD_3_9_BASE:1.32
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.30.0.2
	OPENBSD_3_7_BASE:1.30
	OPENBSD_3_6:1.26.0.4
	OPENBSD_3_6_BASE:1.26
	SMP_SYNC_A:1.22
	SMP_SYNC_B:1.21
	OPENBSD_3_5:1.21.0.4
	OPENBSD_3_5_BASE:1.21
	OPENBSD_3_4:1.21.0.2
	OPENBSD_3_4_BASE:1.21
	UBC_SYNC_A:1.19
	OPENBSD_3_3:1.18.0.4
	OPENBSD_3_3_BASE:1.18
	OPENBSD_3_2:1.18.0.2
	OPENBSD_3_2_BASE:1.18
	OPENBSD_3_1:1.14.0.4
	OPENBSD_3_1_BASE:1.14
	UBC_SYNC_B:1.18
	UBC:1.14.0.2
	UBC_BASE:1.14
	OPENBSD_3_0:1.13.0.2
	OPENBSD_3_0_BASE:1.13
	OPENBSD_2_9_BASE:1.12
	OPENBSD_2_9:1.12.0.2
	OPENBSD_2_8:1.10.0.2
	OPENBSD_2_8_BASE:1.10
	OPENBSD_2_7:1.9.0.2
	OPENBSD_2_7_BASE:1.9
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.89
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.88;
commitid	blfE5YU3eGM81J65;

1.88
date	2015.11.29.16.30.48;	author kettenis;	state Exp;
branches;
next	1.87;
commitid	glp86s0S4SjqIRKu;

1.87
date	2015.11.29.16.16.35;	author kettenis;	state Exp;
branches;
next	1.86;
commitid	PBROe5EmNnPCyRZP;

1.86
date	2015.06.29.18.27.40;	author mpi;	state Exp;
branches;
next	1.85;
commitid	NZHwgpcuQhNDi9RS;

1.85
date	2015.06.22.10.29.18;	author mpi;	state Exp;
branches;
next	1.84;
commitid	rkuRtn1rvEZDAwYu;

1.84
date	2015.06.15.16.46.21;	author mpi;	state Exp;
branches;
next	1.83;
commitid	nc5HAtKZDZx2UMK9;

1.83
date	2015.02.12.05.07.52;	author uebayasi;	state Exp;
branches;
next	1.82;
commitid	A0qGYdYjHNUfrLyb;

1.82
date	2015.01.02.11.58.32;	author mpi;	state Exp;
branches;
next	1.81;
commitid	T9fRSP15ruyreWVP;

1.81
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.80;
commitid	zM5ckwX4kwwmipG0;

1.80
date	2014.11.23.12.19.08;	author mpi;	state Exp;
branches;
next	1.79;
commitid	CoHNu6D7N3ZjwQRL;

1.79
date	2014.11.20.10.24.09;	author mpi;	state Exp;
branches;
next	1.78;
commitid	xfN03dtFbGNlBI9S;

1.78
date	2014.11.11.20.57.27;	author mpi;	state Exp;
branches;
next	1.77;
commitid	YEtlLYOabOI7wwNq;

1.77
date	2014.11.10.14.26.38;	author mpi;	state Exp;
branches;
next	1.76;
commitid	wFFFEy0v2w7LPkrT;

1.76
date	2014.11.07.13.56.29;	author mpi;	state Exp;
branches;
next	1.75;
commitid	gYNQMCaIWvIlAGBb;

1.75
date	2014.11.01.14.44.08;	author mpi;	state Exp;
branches;
next	1.74;
commitid	BmycRw1mcwUuxLd7;

1.74
date	2014.10.01.08.29.01;	author mpi;	state Exp;
branches;
next	1.73;
commitid	42mUihNr4YGvv5ps;

1.73
date	2014.08.10.13.32.14;	author mpi;	state Exp;
branches;
next	1.72;
commitid	AtYNNFjAJNrdSqpp;

1.72
date	2014.08.09.09.58.11;	author mpi;	state Exp;
branches;
next	1.71;
commitid	Wj779iJvRWseSFhZ;

1.71
date	2014.08.09.09.48.32;	author mpi;	state Exp;
branches;
next	1.70;
commitid	9rxHxhQTexFCzT0R;

1.70
date	2014.08.09.09.45.14;	author mpi;	state Exp;
branches;
next	1.69;
commitid	MwiYUakpkX4F7pXj;

1.69
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.68;
commitid	OBNa5kfxQ2UXoiIw;

1.68
date	2014.07.09.18.15.04;	author mpi;	state Exp;
branches;
next	1.67;
commitid	7bxb660ER7iHPxAL;

1.67
date	2014.05.28.11.20.55;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2014.03.11.10.24.42;	author mpi;	state Exp;
branches;
next	1.65;

1.65
date	2014.03.08.11.52.02;	author mpi;	state Exp;
branches;
next	1.64;

1.64
date	2014.03.07.18.57.23;	author mpi;	state Exp;
branches;
next	1.63;

1.63
date	2013.10.19.08.29.30;	author mpi;	state Exp;
branches;
next	1.62;

1.62
date	2013.05.21.17.44.30;	author mpi;	state Exp;
branches;
next	1.61;

1.61
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.60;

1.60
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.59;

1.59
date	2011.09.29.11.18.01;	author stsp;	state Exp;
branches;
next	1.58;

1.58
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.57;

1.57
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.56;

1.56
date	2010.12.06.04.41.40;	author jakemsr;	state Exp;
branches;
next	1.55;

1.55
date	2010.09.23.05.44.15;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2010.09.23.04.58.02;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2010.09.21.12.25.34;	author sasano;	state Exp;
branches;
next	1.52;

1.52
date	2009.11.13.18.06.57;	author deraadt;	state Exp;
branches;
next	1.51;

1.51
date	2009.11.12.20.16.37;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.49;

1.49
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.48;

1.48
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.06.03.23.49;	author jsg;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.01.06.12.20;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.22.05.45.57;	author pascoe;	state Exp;
branches;
next	1.36;

1.36
date	2007.03.18.20.14.51;	author mglocker;	state Exp;
branches;
next	1.35;

1.35
date	2007.03.18.06.00.45;	author pascoe;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.26.19.12.38;	author mjc;	state Exp;
branches;
next	1.33;

1.33
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2005.03.28.02.34.16;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2005.03.13.02.54.04;	author pascoe;	state Exp;
branches;
next	1.29;

1.29
date	2004.12.12.05.21.14;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2004.12.12.05.17.40;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2004.12.09.11.49.55;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2004.07.11.05.32.38;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2004.07.11.05.29.16;	author deraadt;	state Exp;
branches;
next	1.24;

1.24
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.23;

1.23
date	2004.07.07.01.26.40;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2004.06.10.17.31.15;	author pvalchev;	state Exp;
branches;
next	1.21;

1.21
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.07.10.13.15.58;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.04.11.44.23;	author fgsch;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.55;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.22;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.43.55;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.7;

1.6.2.7
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	1.6.2.8;

1.6.2.8
date	2004.06.13.08.50.14;	author niklas;	state Exp;
branches;
next	;

1.14.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.14.2.2;

1.14.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.14.2.3;

1.14.2.3
date	2003.05.19.22.24.08;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.89
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: uhub.c,v 1.88 2015/11/29 16:30:48 kettenis Exp $ */
/*	$NetBSD: uhub.c,v 1.64 2003/02/08 03:32:51 ichiro Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhub.c,v 1.18 1999/11/17 22:33:43 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>

#define UHUB_INTR_INTERVAL 255	/* ms */

#ifdef UHUB_DEBUG
#define DPRINTF(x...)	do { printf(x); } while (0)
#else
#define DPRINTF(x...)
#endif

#define DEVNAME(sc)	((sc)->sc_dev.dv_xname)

struct uhub_softc {
	struct device		sc_dev;		/* base device */
	struct usbd_device	*sc_hub;	/* USB device */
	struct usbd_pipe	*sc_ipipe;	/* interrupt pipe */

	uint32_t		 sc_status;	/* status from last interrupt */
	uint8_t			*sc_statusbuf;	/* per port status buffer */
	size_t			 sc_statuslen;	/* status bufferlen */

	u_char			sc_running;
};
#define UHUB_PROTO(sc) ((sc)->sc_hub->ddesc.bDeviceProtocol)
#define UHUB_IS_HIGH_SPEED(sc) (UHUB_PROTO(sc) != UDPROTO_FSHUB)
#define UHUB_IS_SINGLE_TT(sc) (UHUB_PROTO(sc) == UDPROTO_HSHUBSTT)

int uhub_explore(struct usbd_device *hub);
void uhub_intr(struct usbd_xfer *, void *, usbd_status);
int uhub_port_connect(struct uhub_softc *, int, int, int);

/*
 * We need two attachment points:
 * hub to usb and hub to hub
 * Every other driver only connects to hubs
 */

int uhub_match(struct device *, void *, void *); 
void uhub_attach(struct device *, struct device *, void *); 
int uhub_detach(struct device *, int); 

struct cfdriver uhub_cd = { 
	NULL, "uhub", DV_DULL 
}; 

const struct cfattach uhub_ca = {
	sizeof(struct uhub_softc), uhub_match, uhub_attach,  uhub_detach
};

const struct cfattach uhub_uhub_ca = {
	sizeof(struct uhub_softc), uhub_match, uhub_attach,  uhub_detach
};

int
uhub_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;
	usb_device_descriptor_t *dd = usbd_get_device_descriptor(uaa->device);

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	/*
	 * The subclass for hubs seems to be 0 for some and 1 for others,
	 * so we just ignore the subclass.
	 */
	if (dd->bDeviceClass == UDCLASS_HUB)
		return (UMATCH_DEVCLASS_DEVSUBCLASS);
	return (UMATCH_NONE);
}

void
uhub_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhub_softc *sc = (struct uhub_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	struct usbd_hub *hub = NULL;
	union {
		usb_hub_descriptor_t	hs;
		usb_hub_ss_descriptor_t	ss;
	} hd;
	int p, port, nports, powerdelay;
	struct usbd_interface *iface;
	usb_endpoint_descriptor_t *ed;
	struct usbd_tt *tts = NULL;
	uint8_t ttthink = 0;
	usbd_status err;
#ifdef UHUB_DEBUG
	int nremov;
#endif

	sc->sc_hub = dev;

	if (dev->depth > USB_HUB_MAX_DEPTH) {
		printf("%s: hub depth (%d) exceeded, hub ignored\n",
		       sc->sc_dev.dv_xname, USB_HUB_MAX_DEPTH);
		return;
	}

	/*
	 * Super-Speed hubs need to know their depth to be able to
	 * parse the bits of the route-string that correspond to
	 * their downstream port number.
	 *
	 * This does no apply to root hubs.
	 */
	if (dev->depth != 0 && dev->speed == USB_SPEED_SUPER) {
		if (usbd_set_hub_depth(dev, dev->depth - 1)) {
			printf("%s: unable to set HUB depth\n",
			    sc->sc_dev.dv_xname);
			return;
		}
	}

	/* Get hub descriptor. */
	if (dev->speed == USB_SPEED_SUPER) {
		err = usbd_get_hub_ss_descriptor(dev, &hd.ss, 1);
		nports = hd.ss.bNbrPorts;
		powerdelay = (hd.ss.bPwrOn2PwrGood * UHD_PWRON_FACTOR);
		if (!err && nports > 7)
			usbd_get_hub_ss_descriptor(dev, &hd.ss, nports);
	} else {
		err = usbd_get_hub_descriptor(dev, &hd.hs, 1);
		nports = hd.hs.bNbrPorts;
		powerdelay = (hd.hs.bPwrOn2PwrGood * UHD_PWRON_FACTOR);
		ttthink = UGETW(hd.hs.wHubCharacteristics) & UHD_TT_THINK;
		if (!err && nports > 7)
			usbd_get_hub_descriptor(dev, &hd.hs, nports);
	}

	if (err) {
		DPRINTF("%s: getting hub descriptor failed, error=%s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(err));
		return;
	}

#ifdef UHUB_DEBUG
	for (nremov = 0, port = 1; port <= nports; port++) {
		if (dev->speed == USB_SPEED_SUPER) {
			if (!UHD_NOT_REMOV(&hd.ss, port))
				nremov++;
		} else {
			if (!UHD_NOT_REMOV(&hd.hs, port))
				nremov++;
		}
	}

	printf("%s: %d port%s with %d removable, %s powered",
	       sc->sc_dev.dv_xname, nports, nports != 1 ? "s" : "",
	       nremov, dev->self_powered ? "self" : "bus");

	if (dev->depth > 0 && UHUB_IS_HIGH_SPEED(sc)) {
		printf(", %s transaction translator%s",
		    UHUB_IS_SINGLE_TT(sc) ? "single" : "multiple",
		    UHUB_IS_SINGLE_TT(sc) ? "" : "s");
	}

	printf("\n");
#endif

	if (nports == 0) {
		printf("%s: no ports, hub ignored\n", sc->sc_dev.dv_xname);
		goto bad;
	}

	hub = malloc(sizeof(*hub), M_USBDEV, M_NOWAIT);
	if (hub == NULL)
		return;
	hub->ports = mallocarray(nports, sizeof(struct usbd_port),
	    M_USBDEV, M_NOWAIT);
	if (hub->ports == NULL) {
		free(hub, M_USBDEV, 0);
		return;
	}
	dev->hub = hub;
	dev->hub->hubsoftc = sc;
	hub->explore = uhub_explore;
	hub->nports = nports;
	hub->powerdelay = powerdelay;
	hub->ttthink = ttthink >> 5;

	if (!dev->self_powered && dev->powersrc->parent != NULL &&
	    !dev->powersrc->parent->self_powered) {
		printf("%s: bus powered hub connected to bus powered hub, "
		       "ignored\n", sc->sc_dev.dv_xname);
		goto bad;
	}

	/* Set up interrupt pipe. */
	err = usbd_device2interface_handle(dev, 0, &iface);
	if (err) {
		printf("%s: no interface handle\n", sc->sc_dev.dv_xname);
		goto bad;
	}
	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: no endpoint descriptor\n", sc->sc_dev.dv_xname);
		goto bad;
	}
	if ((ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: bad interrupt endpoint\n", sc->sc_dev.dv_xname);
		goto bad;
	}

	sc->sc_statuslen = (nports + 1 + 7) / 8;
	sc->sc_statusbuf = malloc(sc->sc_statuslen, M_USBDEV, M_NOWAIT);
	if (!sc->sc_statusbuf)
		goto bad;

	err = usbd_open_pipe_intr(iface, ed->bEndpointAddress,
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_statusbuf,
		  sc->sc_statuslen, uhub_intr, UHUB_INTR_INTERVAL);
	if (err) {
		printf("%s: cannot open interrupt pipe\n",
		       sc->sc_dev.dv_xname);
		goto bad;
	}

	/* Wait with power off for a while. */
	usbd_delay_ms(dev, USB_POWER_DOWN_TIME);

	/*
	 * To have the best chance of success we do things in the exact same
	 * order as Windoze98.  This should not be necessary, but some
	 * devices do not follow the USB specs to the letter.
	 *
	 * These are the events on the bus when a hub is attached:
	 *  Get device and config descriptors (see attach code)
	 *  Get hub descriptor (see above)
	 *  For all ports
	 *     turn on power
	 *     wait for power to become stable
	 * (all below happens in explore code)
	 *  For all ports
	 *     clear C_PORT_CONNECTION
	 *  For all ports
	 *     get port status
	 *     if device connected
	 *        wait 100 ms
	 *        turn on reset
	 *        wait
	 *        clear C_PORT_RESET
	 *        get port status
	 *        proceed with device attachment
	 */

	if (UHUB_IS_HIGH_SPEED(sc)) {
		tts = mallocarray((UHUB_IS_SINGLE_TT(sc) ? 1 : nports),
		    sizeof (struct usbd_tt), M_USBDEV, M_NOWAIT);
		if (!tts)
			goto bad;
	}
	/* Set up data structures */
	for (p = 0; p < nports; p++) {
		struct usbd_port *up = &hub->ports[p];
		up->device = NULL;
		up->parent = dev;
		up->portno = p + 1;
		if (dev->self_powered)
			/* Self powered hub, give ports maximum current. */
			up->power = USB_MAX_POWER;
		else
			up->power = USB_MIN_POWER;
		up->restartcnt = 0;
		up->reattach = 0;
		if (UHUB_IS_HIGH_SPEED(sc)) {
			up->tt = &tts[UHUB_IS_SINGLE_TT(sc) ? 0 : p];
			up->tt->hub = hub;
		} else {
			up->tt = NULL;
		}
	}

	for (port = 1; port <= nports; port++) {
		/* Turn the power on. */
		err = usbd_set_port_feature(dev, port, UHF_PORT_POWER);
		if (err)
			printf("%s: port %d power on failed, %s\n",
			       sc->sc_dev.dv_xname, port,
			       usbd_errstr(err));
		/* Make sure we check the port status at least once. */
		sc->sc_status |= (1 << port);
	}

	/* Wait for stable power. */
        if (dev->powersrc->parent != NULL)
		usbd_delay_ms(dev, powerdelay + USB_EXTRA_POWER_UP_TIME);

	/* The usual exploration will finish the setup. */

	sc->sc_running = 1;

	return;

 bad:
	if (sc->sc_statusbuf)
		free(sc->sc_statusbuf, M_USBDEV, 0);
	if (hub) {
		if (hub->ports)
			free(hub->ports, M_USBDEV, 0);
		free(hub, M_USBDEV, 0);
	}
	dev->hub = NULL;
}

int
uhub_explore(struct usbd_device *dev)
{
	struct uhub_softc *sc = dev->hub->hubsoftc;
	struct usbd_port *up;
	int status, change;
	int port;

	if (usbd_is_dying(sc->sc_hub))
		return (EIO);

	if (!sc->sc_running)
		return (ENXIO);

	/* Ignore hubs that are too deep. */
	if (sc->sc_hub->depth > USB_HUB_MAX_DEPTH)
		return (EOPNOTSUPP);

	for (port = 1; port <= sc->sc_hub->hub->nports; port++) {
		up = &sc->sc_hub->hub->ports[port-1];

		change = 0;
		status = 0;

		if ((sc->sc_status & (1 << port)) || up->reattach) {
			sc->sc_status &= ~(1 << port);

			if (usbd_get_port_status(dev, port, &up->status))
				continue;

			status = UGETW(up->status.wPortStatus);
			change = UGETW(up->status.wPortChange);
			DPRINTF("%s: port %d status=0x%04x change=0x%04x\n",
			    sc->sc_dev.dv_xname, port, status, change);
		}

		if (up->reattach) {
			change |= UPS_C_CONNECT_STATUS;
			up->reattach = 0;
		}

		if (change & UPS_C_PORT_ENABLED) {
			usbd_clear_port_feature(sc->sc_hub, port,
			    UHF_C_PORT_ENABLE);
			if (change & UPS_C_CONNECT_STATUS) {
				/* Ignore the port error if the device
				   vanished. */
			} else if (status & UPS_PORT_ENABLED) {
				printf("%s: illegal enable change, port %d\n",
				       sc->sc_dev.dv_xname, port);
			} else {
				/* Port error condition. */
				if (up->restartcnt) /* no message first time */
					printf("%s: port error, restarting "
					       "port %d\n",
					       sc->sc_dev.dv_xname, port);

				if (up->restartcnt++ < USBD_RESTART_MAX)
					change |= UPS_C_CONNECT_STATUS;
				else
					printf("%s: port error, giving up "
					       "port %d\n",
					       sc->sc_dev.dv_xname, port);
			}
		}

		if (change & UPS_C_PORT_RESET) {
			usbd_clear_port_feature(sc->sc_hub, port,
			    UHF_C_PORT_RESET);
			change |= UPS_C_CONNECT_STATUS;
		}

		if (change & UPS_C_BH_PORT_RESET &&
		    sc->sc_hub->speed == USB_SPEED_SUPER) {
			usbd_clear_port_feature(sc->sc_hub, port,
			    UHF_C_BH_PORT_RESET);
		}

		if (change & UPS_C_CONNECT_STATUS) {
			if (uhub_port_connect(sc, port, status, change))
				continue;

			/* The port set up succeeded, reset error count. */
			up->restartcnt = 0;
		}

		if (change & UPS_C_PORT_LINK_STATE) {
			usbd_clear_port_feature(sc->sc_hub, port,
			    UHF_C_PORT_LINK_STATE);
		}

		/* Recursive explore. */
		if (up->device != NULL && up->device->hub != NULL)
			up->device->hub->explore(up->device);
	}

	return (0);
}

/*
 * Called from process context when the hub is gone.
 * Detach all devices on active ports.
 */
int
uhub_detach(struct device *self, int flags)
{
	struct uhub_softc *sc = (struct uhub_softc *)self;
	struct usbd_hub *hub = sc->sc_hub->hub;
	struct usbd_port *rup;
	int port;

	if (hub == NULL)		/* Must be partially working */
		return (0);

	usbd_abort_pipe(sc->sc_ipipe);
	usbd_close_pipe(sc->sc_ipipe);

	for (port = 0; port < hub->nports; port++) {
		rup = &hub->ports[port];
		if (rup->device != NULL) {
			usbd_detach(rup->device, self);
			rup->device = NULL;
		}
	}

	if (hub->ports[0].tt)
		free(hub->ports[0].tt, M_USBDEV, 0);
	if (sc->sc_statusbuf)
		free(sc->sc_statusbuf, M_USBDEV, 0);
	if (hub->ports)
		free(hub->ports, M_USBDEV, 0);
	free(hub, M_USBDEV, 0);
	sc->sc_hub->hub = NULL;

	return (0);
}

/*
 * This is an indication that some port has changed status.  Remember
 * the ports that need attention and notify the USB task thread that
 * we need to be explored again.
 */
void
uhub_intr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct uhub_softc *sc = addr;
	uint32_t stats = 0;
	int i;

	if (usbd_is_dying(sc->sc_hub))
		return;

	DPRINTF("%s: intr status=%d\n", sc->sc_dev.dv_xname, status);

	if (status == USBD_STALLED)
		usbd_clear_endpoint_stall_async(sc->sc_ipipe);
	else if (status == USBD_NORMAL_COMPLETION) {
		for (i = 0; i < xfer->actlen; i++)
			stats |= (uint32_t)(xfer->buffer[i]) << (i * 8);
		sc->sc_status |= stats;

		usb_needs_explore(sc->sc_hub, 0);
	}
}

int
uhub_port_connect(struct uhub_softc *sc, int port, int status, int change)
{
	struct usbd_port *up = &sc->sc_hub->hub->ports[port-1];
	int speed;

	/* We have a connect status change, handle it. */
	usbd_clear_port_feature(sc->sc_hub, port, UHF_C_PORT_CONNECTION);

	/*
	 * If there is already a device on the port the change status
	 * must mean that is has disconnected.  Looking at the
	 * current connect status is not enough to figure this out
	 * since a new unit may have been connected before we handle
	 * the disconnect.
	 */
	if (up->device != NULL) {
		/* Disconnected */
		usbd_detach(up->device, &sc->sc_dev);
		up->device = NULL;
	}

	/* Nothing connected, just ignore it. */
	if ((status & UPS_CURRENT_CONNECT_STATUS) == 0)
		return (0);

	/* Connected */
	if ((status & (UPS_PORT_POWER|UPS_PORT_POWER_SS)) == 0) {
		printf("%s: connected port %d has no power\n", DEVNAME(sc),
		    port);
		return (-1);
	}

	/* Wait for maximum device power up time. */
	usbd_delay_ms(sc->sc_hub, USB_PORT_POWERUP_DELAY);

	/* Reset port, which implies enabling it. */
	if (usbd_reset_port(sc->sc_hub, port)) {
		printf("%s: port %d reset failed\n", DEVNAME(sc), port);
		return (-1);
	}
	/* Get port status again, it might have changed during reset */
	if (usbd_get_port_status(sc->sc_hub, port, &up->status))
		return (-1);

	status = UGETW(up->status.wPortStatus);
	change = UGETW(up->status.wPortChange);
	DPRINTF("%s: port %d status=0x%04x change=0x%04x\n", DEVNAME(sc),
	    port, status, change);

	/* Nothing connected, just ignore it. */
	if ((status & UPS_CURRENT_CONNECT_STATUS) == 0) {
		DPRINTF("%s: port %d, device disappeared after reset\n",
		    DEVNAME(sc), port);
		return (-1);
	}

	/*
	 * Figure out device speed.  This is a bit tricky because
	 * UPS_PORT_POWER_SS and UPS_LOW_SPEED share the same bit.
	 */
	if ((status & UPS_PORT_POWER) == 0)
		status &= ~UPS_PORT_POWER_SS;

	if (status & UPS_HIGH_SPEED)
		speed = USB_SPEED_HIGH;
	else if (status & UPS_LOW_SPEED)
		speed = USB_SPEED_LOW;
	else {
		/*
		 * If there is no power bit set, it is certainly
		 * a Super Speed device, so use the speed of its
		 * parent hub.
		 */
		if (status & UPS_PORT_POWER)
			speed = USB_SPEED_FULL;
		else
			speed = sc->sc_hub->speed;
	}

	/*
	 * Reduce the speed, otherwise we won't setup the proper
	 * transfer methods.
	 */
	if (speed > sc->sc_hub->speed)
		speed = sc->sc_hub->speed;

	/* Get device info and set its address. */
	if (usbd_new_device(&sc->sc_dev, sc->sc_hub->bus, sc->sc_hub->depth + 1,
	    speed, port, up)) {
		/*
		 * The unit refused to accept a new address, or had
		 * some other serious problem.  Since we cannot leave
		 * at 0 we have to disable the port instead.
		 */
		printf("%s: device problem, disabling port %d\n", DEVNAME(sc),
		    port);
		usbd_clear_port_feature(sc->sc_hub, port, UHF_PORT_ENABLE);

		return (-1);
	}

	return (0);
}
@


1.88
log
@Unconnected xhci(4) super speed ports may come up with the XHCI_PS_WRC,
indicating a warm reset has happened.  Communicate this as UPS_C_BH_PORT_RESET
to the upper layers and make uhub(4) clear this bit such that we receive
further connection status change notifications.  Make sure we only do this
for super speed (USB 3.0) hubs as high speed (USB 2.0) hubs use the same bit
for UPS_C_PORT_L1.

Make hotplugging USB 3.0 devices work on my MacBookPro12,1.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.87 2015/11/29 16:16:35 kettenis Exp $ */
d105 3
d112 1
a112 1
	if (uaa->iface == NULL && dd->bDeviceClass == UDCLASS_HUB)
a138 7

	err = usbd_set_config_index(dev, 0, 1);
	if (err) {
		DPRINTF("%s: configuration failed, error=%s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(err));
		return;
	}
@


1.87
log
@Clear the UPS_C_PORT_RESET feature when exploring.  Apparently xhci(4) super
speed ports may have the XHCI_PS_PRC bit set after xhci(4) attaches.  Just
clearing this bit isn't enough though, since the device is already connected
and no further connection status change is signalled.  So fake one.

This makes the integrated SD card reader in the MacBookPro12,1 attach.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.86 2015/06/29 18:27:40 mpi Exp $ */
d426 6
@


1.86
log
@Move the logic to handle a "connect status change" from uhub_explore()
into its own functions.

Needed for upcoming "port link state" change handling.

Tested by sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.85 2015/06/22 10:29:18 mpi Exp $ */
d420 6
@


1.85
log
@Make xhci(4)'s root hub report the same status bits as physical USB3 hubs.

There's not bit to indicate the speed of a USB3.0 device attached to a hub
port so do not abuse the PORT_TEST bit.  Instead make the xhci(4) root hub
report the PORT_POWER_SS bit when appropriate and use it to determin the
speed of a new device.

While here make the root hub report the link state and config error, from
FreeBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.84 2015/06/15 16:46:21 mpi Exp $ */
d56 2
d75 1
d361 1
a361 2
	usbd_status err;
	int speed;
a362 1
	int change, status, reconnect;
d364 1
a364 1
	if (usbd_is_dying(dev))
d371 1
a371 1
	if (dev->depth > USB_HUB_MAX_DEPTH)
d374 2
a375 2
	for (port = 1; port <= dev->hub->nports; port++) {
		up = &dev->hub->ports[port-1];
a376 2
		reconnect = up->reattach;
		up->reattach = 0;
d380 1
a380 1
		if ((sc->sc_status & (1 << port)) || reconnect) {
d392 5
d398 2
a399 1
			usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);
d414 1
a414 1
					goto disco;
a420 6
		if (!reconnect && !(change & UPS_C_CONNECT_STATUS)) {
			/* No status change, just do recursive explore. */
			if (up->device != NULL && up->device->hub != NULL)
				up->device->hub->explore(up->device);
			continue;
		}
d422 3
a424 2
		/* We have a connect status change, handle it. */
		usbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);
d426 2
a427 18
		/*
		 * If there is already a device on the port the change status
		 * must mean that is has disconnected.  Looking at the
		 * current connect status is not enough to figure this out
		 * since a new unit may have been connected before we handle
		 * the disconnect.
		 */
	disco:
		if (up->device != NULL) {
			/* Disconnected */
			usbd_detach(up->device, &sc->sc_dev);
			up->device = NULL;
			usbd_clear_port_feature(dev, port,
						UHF_C_PORT_CONNECTION);
		}
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
			continue;
d430 3
a432 5
		/* Connected */
		if (!(status & (UPS_PORT_POWER|UPS_PORT_POWER_SS))) {
			printf("%s: connected port %d has no power\n",
			       sc->sc_dev.dv_xname, port);
			continue;
d435 3
a437 80
		/* Wait for maximum device power up time. */
		usbd_delay_ms(dev, USB_PORT_POWERUP_DELAY);

		/* Reset port, which implies enabling it. */
		if (usbd_reset_port(dev, port)) {
			printf("%s: port %d reset failed\n",
			       sc->sc_dev.dv_xname, port);
			continue;
		}
		/* Get port status again, it might have changed during reset */
		if (usbd_get_port_status(dev, port, &up->status))
			continue;

		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
		DPRINTF("%s: port %d status=0x%04x change=0x%04x\n",
		    sc->sc_dev.dv_xname, port, status, change);

		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
			DPRINTF("%s: port %d, device disappeared after reset\n",
			    sc->sc_dev.dv_xname, port);
			continue;
		}

		/*
		 * Figure out device speed.  This is a bit tricky because
		 * UPS_PORT_POWER_SS and UPS_LOW_SPEED share the same bit.
		 */
		if ((status & UPS_PORT_POWER) == 0)
			status &= ~UPS_PORT_POWER_SS;

		if (status & UPS_HIGH_SPEED)
			speed = USB_SPEED_HIGH;
		else if (status & UPS_LOW_SPEED)
			speed = USB_SPEED_LOW;
		else {
			/*
			 * If there is no power bit set, it is certainly
			 * a Super Speed device, so use the speed of its
			 * parent hub.
			 */
			if (status & UPS_PORT_POWER)
				speed = USB_SPEED_FULL;
			else
				speed = sc->sc_hub->speed;
		}

		/*
		 * Reduce the speed, otherwise we won't setup the proper
		 * transfer methods.
		 */
		if (speed > sc->sc_hub->speed)
			speed = sc->sc_hub->speed;

		/* Get device info and set its address. */
		err = usbd_new_device(&sc->sc_dev, dev->bus,
			  dev->depth + 1, speed, port, up);
		/* XXX retry a few times? */
		if (err) {
			DPRINTF("%s: usbd_new_device failed, error=%s\n",
			    sc->sc_dev.dv_xname, usbd_errstr(err));
			/* Avoid addressing problems by disabling. */
			/* usbd_reset_port(dev, port, &up->status); */

			/*
			 * The unit refused to accept a new address, or had
			 * some other serious problem.  Since we cannot leave
			 * at 0 we have to disable the port instead.
			 */
			printf("%s: device problem, disabling port %d\n",
			       sc->sc_dev.dv_xname, port);
			usbd_clear_port_feature(dev, port, UHF_PORT_ENABLE);
		} else {
			/* The port set up succeeded, reset error count. */
			up->restartcnt = 0;

			if (up->device->hub)
				up->device->hub->explore(up->device);
		}
d507 105
@


1.84
log
@Bring back r1.78 and r1.79, now that ajactouto@@'s regression has
been found: it was a hardware failure.

When a bus is explored, do not probe the ports which status hasn't
changed.  This saves a lot of I/O when attaching/detaching devices
and might help with some timing related problems.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.83 2015/02/12 05:07:52 uebayasi Exp $ */
d463 1
a463 4
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF("%s: get port %d status failed, error=%s\n",
			    sc->sc_dev.dv_xname, port, usbd_errstr(err));
d465 1
a465 1
		}
d468 3
d485 1
a485 3
		if (status & UPS_SUPER_SPEED)
			speed = USB_SPEED_SUPER;
		else if (status & UPS_HIGH_SPEED)
@


1.83
log
@KNF.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d60 5
a64 2
	u_int8_t		*sc_statusbuf;	/* per port status buffer */
	size_t			sc_statuslen;	/* status bufferlen */
d328 2
d375 1
a375 8
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF("%s: get port %d status failed, error=%s\n",
			    sc->sc_dev.dv_xname, port, usbd_errstr(err));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
d378 15
a392 2
		DPRINTF("%s: port %d status=0x%04x change=0x%04x\n",
		    sc->sc_dev.dv_xname, port, status, change);
d425 1
d587 2
d597 5
a601 1
	else if (status == USBD_NORMAL_COMPLETION)
d603 1
@


1.82
log
@Report the TT Think Time of USB2.0 Hubs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.81 2014/12/09 07:05:06 doug Exp $ */
d302 1
a302 1
		up->portno = p+1;
@


1.81
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.80 2014/11/23 12:19:08 mpi Exp $ */
d170 1
d224 1
a224 1
	hub->ttthink = ttthink;
@


1.80
log
@Revert the logic to skip ports which status hasn't changed, it introduces
a regression reported by ajacoutot@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.79 2014/11/20 10:24:09 mpi Exp $ */
d212 1
a212 1
	hub->ports = malloc(sizeof(struct usbd_port) * nports,
d291 1
a291 1
		tts = malloc((UHUB_IS_SINGLE_TT(sc) ? 1 : nports) *
@


1.79
log
@Force a status check of all the ports of a newly attached hub.  In the
interrupt routine properly initialize a variable.  Finally stop talking
about the "bus event handler thread".  Our USB stack has only one thread
doing discovery for all buses.

Prompted by a report from Patrick Wildt.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.78 2014/11/11 20:57:27 mpi Exp $ */
d60 2
a61 5

	uint32_t		 sc_status;	/* status from last interrupt */
	uint8_t			*sc_statusbuf;	/* per port status buffer */
	size_t			 sc_statuslen;	/* status bufferlen */

a323 2
		/* Make sure we check the port status at least once. */
		sc->sc_status |= (1 << port);
d369 8
a376 1

d379 2
a380 15
		change = 0;
		status = 0;

		if ((sc->sc_status & (1 << port)) || reconnect) {
			sc->sc_status &= ~(1 << port);

			if (usbd_get_port_status(dev, port, &up->status))
				continue;

			status = UGETW(up->status.wPortStatus);
			change = UGETW(up->status.wPortChange);
			DPRINTF("%s: port %d status=0x%04x change=0x%04x\n",
			    sc->sc_dev.dv_xname, port, status, change);
		}

a412 1

a573 2
	uint32_t stats = 0;
	int i;
d582 1
a582 5
	else if (status == USBD_NORMAL_COMPLETION) {
		for (i = 0; i < xfer->actlen; i++)
			stats |= (uint32_t)(xfer->buffer[i]) << (i * 8);
		sc->sc_status |= stats;

a583 1
	}
@


1.78
log
@When a bus is explored, do not probe the ports which status hasn't
changed.  This saves a lot of I/O when attaching/detaching devices
and might help with some timing related problems.

Has been in snap for ten days, committing now so that people testing
xhci(4) test the same thing w/ snapshots and their own kernel.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.77 2014/11/10 14:26:38 mpi Exp $ */
d327 2
d578 3
a580 4
 * Hub interrupt.
 * This an indication that some port has changed status.
 * Notify the bus event handler thread that we need
 * to be explored again.
d586 1
a586 1
	uint32_t stats;
@


1.77
log
@Add some fields needed for TT support.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.76 2014/11/07 13:56:29 mpi Exp $ */
d60 5
a64 2
	u_int8_t		*sc_statusbuf;	/* per port status buffer */
	size_t			sc_statuslen;	/* status bufferlen */
d372 1
a372 8
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF("%s: get port %d status failed, error=%s\n",
			    sc->sc_dev.dv_xname, port, usbd_errstr(err));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
d375 15
a389 2
		DPRINTF("%s: port %d status=0x%04x change=0x%04x\n",
		    sc->sc_dev.dv_xname, port, status, change);
d422 1
a422 1
		/*usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);*/
d585 2
d592 1
d595 5
a599 1
	else if (status == USBD_NORMAL_COMPLETION)
d601 1
@


1.76
log
@Give Super-Speed hubs a chance to route USB 3.0 transfers.

Without knowing their depth, hubs couldn't find the bits correspdonding
to their downstream port in the route-string.  Now USB 3.0 devices just
work(tm) anywhere in your hub chain.

This commit would not have been possible without the cheese provided by
miod@@ at #HAMoween.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.75 2014/11/01 14:44:08 mpi Exp $ */
d123 1
d223 1
@


1.75
log
@Remove the port status argument from usbd_reset_port().  We don't do
anything with it and it simplifies this mess in order to implement
warm reset.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.74 2014/10/01 08:29:01 mpi Exp $ */
d141 15
@


1.74
log
@Check that the speed of a new device does not exceed its parent's speed
prior to calling usbd_new_device().

This will let us set the specified default Max Packet Size before opening
the control pipe and reduces spaghetti!

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.73 2014/08/10 13:32:14 mpi Exp $ */
d428 1
a428 1
		if (usbd_reset_port(dev, port, &up->status)) {
@


1.73
log
@Ask for the descriptor size corresponding to the number of ports present
in the hub, not from some random value from the stack.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.72 2014/08/09 09:58:11 mpi Exp $ */
d473 7
@


1.72
log
@Correctly recognize Super Speed devices, this is part of the work to
be able to use USB 3.0 devices behind an external hub.

This is a bit tricky because the SS status use a different power bit
that maps to the Low speed one.  So no longer accept devices without
power bit and fallback to the parent hub's speed in case the status
does not report any particular speed.

Note that xhci(4) root hubs still set the traditionnal UPS_PORT_POWER
bit with the correct device speed.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.71 2014/08/09 09:48:32 mpi Exp $ */
d146 2
d152 2
a156 3

	nports = hd.hs.bNbrPorts;
	powerdelay = (hd.hs.bPwrOn2PwrGood * UHD_PWRON_FACTOR);
@


1.71
log
@Handle super speed hub descriptors.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.70 2014/08/09 09:45:14 mpi Exp $ */
d417 2
a418 2
		if (!(status & UPS_PORT_POWER))
			printf("%s: strange, connected port %d has no power\n",
d420 2
d448 7
a454 1
		/* Figure out device speed */
d461 12
a472 2
		else
			speed = USB_SPEED_FULL;
@


1.70
log
@Do not store the whole USB hub descriptor in the "struct usbd_hub"
to help integrating super speed hubs that use a different descriptor.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.69 2014/07/12 18:48:52 tedu Exp $ */
d115 4
a118 1
	usb_hub_descriptor_t hubdesc;
d144 13
a156 5
	err = usbd_get_hub_descriptor(dev, &hubdesc, 1);
	nports = hubdesc.bNbrPorts;
	powerdelay = (hubdesc.bPwrOn2PwrGood * UHD_PWRON_FACTOR);
	if (!err && nports > 7)
		usbd_get_hub_descriptor(dev, &hubdesc, nports);
d164 9
a172 3
	for (nremov = 0, port = 1; port <= nports; port++)
		if (!UHD_NOT_REMOV(&hubdesc, port))
			nremov++;
@


1.69
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.68 2014/07/09 18:15:04 mpi Exp $ */
d116 1
a116 1
	int p, port, nports, pwrdly;
d143 1
d187 2
a188 1
	hub->hubdesc = hubdesc;
a281 4
	/* XXX should check for none, individual, or ganged power? */

	pwrdly = dev->hub->hubdesc.bPwrOn2PwrGood * UHD_PWRON_FACTOR
	    + USB_EXTRA_POWER_UP_TIME;
d291 1
a291 1
	/* Wait for stable power.  Root hubs delay in their event thread. */
d293 1
a293 1
		usbd_delay_ms(dev, pwrdly);
a314 1
	usb_hub_descriptor_t *hd = &dev->hub->hubdesc;
d332 1
a332 1
	for (port = 1; port <= hd->bNbrPorts; port++) {
d478 1
a478 1
	int port, nports;
d486 1
a486 2
	nports = hub->hubdesc.bNbrPorts;
	for(port = 0; port < nports; port++) {
@


1.68
log
@autoconf(9) is your friend and it knows you more than you think.  It
even knows your children!  So let him handle the seperation correctly.

Do not rewrite your own custom config_detach_children(9) and as a bonus
start removing the usbd_port tentacles from the stack.

ok pirofti@@, yuo@@, miod@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.67 2014/05/28 11:20:55 mpi Exp $ */
d180 1
a180 1
		free(hub, M_USBDEV);
d305 1
a305 1
		free(sc->sc_statusbuf, M_USBDEV);
d308 2
a309 2
			free(hub->ports, M_USBDEV);
		free(hub, M_USBDEV);
d499 1
a499 1
		free(hub->ports[0].tt, M_USBDEV);
d501 1
a501 1
		free(sc->sc_statusbuf, M_USBDEV);
d503 2
a504 2
		free(hub->ports, M_USBDEV);
	free(hub, M_USBDEV);
@


1.67
log
@Apart from the early exploration done to find a console keyboard during
the boot process, USB devices must be attached or detached from the usb
task thread in order to avoid races with periodical explorations issued
by uhub(4) interrupts.

Respect this rule when detaching root hubs during a suspend/resume cycle
and avoid some hangs due to the aforementioned race.

Tested by Mattieu Baptiste, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.66 2014/03/11 10:24:42 mpi Exp $ */
a79 1
int uhub_activate(struct device *, int); 
d85 2
a86 6
const struct cfattach uhub_ca = { 
	sizeof(struct uhub_softc), 
	uhub_match, 
	uhub_attach, 
	uhub_detach, 
	uhub_activate, 
d89 2
a90 3
struct cfattach uhub_uhub_ca = {
	sizeof(struct uhub_softc), uhub_match, uhub_attach,
	uhub_detach, uhub_activate
d392 2
a393 1
			usb_disconnect_port(up, &sc->sc_dev);
a470 25
int
uhub_activate(struct device *self, int act)
{
	struct uhub_softc *sc = (struct uhub_softc *)self;
	struct usbd_hub *hub = sc->sc_hub->hub;
	struct usbd_device *dev;
	int nports, port, i;

	switch (act) {
	case DVACT_DEACTIVATE:
		if (hub == NULL) /* malfunctioning hub */
			break;
		nports = hub->hubdesc.bNbrPorts;
		for(port = 0; port < nports; port++) {
			dev = hub->ports[port].device;
			if (dev != NULL && dev->subdevs != NULL) {
				for (i = 0; dev->subdevs[i] != NULL; i++)
					config_deactivate(dev->subdevs[i]);
			}
		}
		break;
	}
	return (0);
}

d492 4
a495 2
		if (rup->device)
			usb_disconnect_port(rup, self);
@


1.66
log
@Kill dead links.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.65 2014/03/08 11:52:02 mpi Exp $ */
d548 3
@


1.65
log
@Recognize super speed devices, note that this driver sill uses
non-superspeed hub descriptors.  This is the minimal change I
came with to be able to properly attach and use USB 3.0 devices
attached to a xHCI root hub, uhub(4) clearly needs some love.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.64 2014/03/07 18:57:23 mpi Exp $ */
a32 4
 */

/*
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
@


1.64
log
@Indtroduce usbd_get_hub_descriptor() to start cleaning uhub(4)'s mess.
This will help us deal with the different hub device descriptors used
by super speed devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.63 2013/10/19 08:29:30 mpi Exp $ */
d442 3
a444 1
		if (status & UPS_HIGH_SPEED)
@


1.63
log
@Make uhub_explore() return an int rather than a usbd_satus.  This has
no direct impact since its return value is never checked but it allows
me to get rid of one (usless) status value.

Note that usbd_status should be used for USB transfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.62 2013/05/21 17:44:30 mpi Exp $ */
a123 1
	usbd_status err;
a124 1
	usb_device_request_t req;
d126 1
a126 1
	int p, port, nports, nremov, pwrdly;
d130 4
d151 1
a151 6
	req.bmRequestType = UT_READ_CLASS_DEVICE;
	req.bRequest = UR_GET_DESCRIPTOR;
	USETW2(req.wValue, UDESC_HUB, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE);
	err = usbd_do_request(dev, &req, &hubdesc);
d153 2
a154 4
	if (!err && nports > 7) {
		USETW(req.wLength, USB_HUB_DESCRIPTOR_SIZE + (nports+1) / 8);
		err = usbd_do_request(dev, &req, &hubdesc);
	}
d161 1
a165 1
#ifdef UHUB_DEBUG
@


1.62
log
@Simplify the debug output to help diagnose problems without needing
special glasses.

No object change if UHUB_DEBUG is not defined.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.61 2013/04/15 09:23:02 mglocker Exp $ */
d72 1
a72 1
usbd_status uhub_explore(struct usbd_device *hub);
d329 1
a329 1
usbd_status
d341 1
a341 1
		return (USBD_IOERROR);
d344 1
a344 1
		return (USBD_NOT_STARTED);
d348 1
a348 1
		return (USBD_TOO_DEEP);
d479 2
a480 1
	return (USBD_NORMAL_COMPLETION);
@


1.61
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.60 2013/03/28 03:58:03 tedu Exp $ */
d55 1
a55 3
#define DPRINTF(x)	do { if (uhubdebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhubdebug>(n)) printf x; } while (0)
int	uhubdebug = 0;
d57 1
a57 2
#define DPRINTF(x)
#define DPRINTFN(n,x)
a108 1
	DPRINTFN(5,("uhub_match, dd=%p\n", dd));
a132 1
	DPRINTFN(1,("uhub_attach\n"));
d137 2
a138 2
		DPRINTF(("%s: configuration failed, error=%s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(err)));
a153 1
	DPRINTFN(1,("usb_init_hub: getting hub descriptor\n"));
d161 2
a162 2
		DPRINTF(("%s: getting hub descriptor failed, error=%s\n",
			 sc->sc_dev.dv_xname, usbd_errstr(err)));
d180 1
a202 6
	DPRINTFN(1,("usbhub_init_hub: selfpowered=%d, parent=%p, "
		    "parent->selfpowered=%d\n",
		 dev->self_powered, dev->powersrc->parent,
		 dev->powersrc->parent ?
		 dev->powersrc->parent->self_powered : 0));

a305 1
		DPRINTF(("usb_init_port: turn on port %d power\n", port));
d340 1
a340 4
	DPRINTFN(10, ("uhub_explore dev=%p addr=%d\n", dev, dev->address));

	if (usbd_is_dying(dev)) {
		DPRINTF(("%s: dying\n", __func__));
a341 1
	}
d354 2
a355 2
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
d362 2
a363 2
		DPRINTFN(3,("uhub_explore: %s port %d status 0x%04x 0x%04x\n",
			    sc->sc_dev.dv_xname, port, status, change));
a364 1
			DPRINTF(("uhub_explore: C_PORT_ENABLED\n"));
a387 2
			DPRINTFN(3,("uhub_explore: port=%d !C_CONNECT_"
				    "STATUS\n", port));
a390 6
#if 0 && defined(DIAGNOSTIC)
			if (up->device == NULL &&
			    (status & UPS_CURRENT_CONNECT_STATUS))
				printf("%s: connected, no device\n",
				       sc->sc_dev.dv_xname);
#endif
a394 3

		DPRINTF(("uhub_explore: status change hub=%d port=%d\n",
			 dev->address, port));
a406 2
			DPRINTF(("uhub_explore: device addr=%d disappeared "
				 "on port %d\n", up->device->address, port));
a412 2
			DPRINTFN(3,("uhub_explore: port=%d !CURRENT_CONNECT"
				    "_STATUS\n", port));
a416 1

d433 2
a434 2
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
d441 2
a442 4
#ifdef UHUB_DEBUG
			printf("%s: port %d, device disappeared after reset\n",
			       sc->sc_dev.dv_xname, port);
#endif
d458 2
a459 2
			DPRINTFN(-1,("uhub_explore: usbd_new_device failed, "
				     "error=%s\n", usbd_errstr(err)));
a518 2
	DPRINTF(("uhub_detach: sc=%p flags=%d\n", sc, flags));

d555 1
a555 1
	DPRINTFN(5,("uhub_intr: sc=%p\n", sc));
a559 2
	else
		DPRINTFN(8, ("uhub_intr: unknown status, %d\n", status));
@


1.60
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.59 2011/09/29 11:18:01 stsp Exp $ */
d65 2
a66 2
	usbd_device_handle	sc_hub;		/* USB device */
	usbd_pipe_handle	sc_ipipe;	/* interrupt pipe */
d75 2
a76 2
usbd_status uhub_explore(usbd_device_handle hub);
void uhub_intr(usbd_xfer_handle, usbd_private_handle,usbd_status);
d127 1
a127 1
	usbd_device_handle dev = uaa->device;
d133 1
a133 1
	usbd_interface_handle iface;
d342 1
a342 1
uhub_explore(usbd_device_handle dev)
d522 1
a522 1
	usbd_device_handle dev;
d588 1
a588 1
uhub_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
@


1.59
log
@Avoid a potential NULL dereference if nports == 0.
Found by Amit Kulkarni using clang.
Fix from jakemsr; his diff was sitting on tech@@ since February.
ok myself, phessler, sthen, jasper
and also pirofti, mikeb, krw (back in February)
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.58 2011/07/03 15:47:17 matthew Exp $ */
a43 1
#include <sys/proc.h>
@


1.58
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.57 2011/01/25 20:03:36 jakemsr Exp $ */
d334 3
a336 3
	if (hub->ports)
		free(hub->ports, M_USBDEV);
	if (hub)
d338 1
@


1.57
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.56 2010/12/06 04:41:40 jakemsr Exp $ */
a525 3
	case DVACT_ACTIVATE:
		break;

@


1.56
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.55 2010/09/23 05:44:15 jakemsr Exp $ */
a254 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, &sc->sc_dev);

a570 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_hub,
			   &sc->sc_dev);
@


1.55
log
@add a 'dying' flag to struct usbd_bus.  use this to signify the bus
is dying, instead of setting a flag in struct usb_softc.  as
usbd_device_handle has a pointer to the usbd_bus it's attached to,
usb devices, and functions they run or functions run on their behalf,
can now easily check if their bus is dying.  use this to stop
usbd_do_request* from running and the usb task thread from adding
new tasks when a device's bus is dying.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.54 2010/09/23 04:58:02 jakemsr Exp $ */
d356 2
a357 2
	if (dev->bus->dying) {
		DPRINTF(("%s: root hub gone at start\n", __func__));
@


1.54
log
@instead of running usb_explore() from individual kthreads for each
USB bus, make usb_explore() a usb_task.  reduces races during normal
USB device detach, since now usb_tasks and detach happen in the same
process.
ok yuo@@, matthew@@ helped with the task thread loop
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.53 2010/09/21 12:25:34 sasano Exp $ */
d355 5
@


1.53
log
@The size of sc_status[] (the buffer for USB hub's interrupt pipe) will be
determined by bNbrPorts in hub descriptor.

USB hub sends status packet to host, it contains status bits for each port
and hub itself. So, the packet size is ceil((port + 1) / 8) bytes.

If host requests smaller than that size, the hub behavior is undefined.
Some hub (Intel's RMH for example) sends whole status every time,
it makes babble of USB. This is the reason that uhub_intr() of old code
was suffered from USBD_IOERROR,

Okay deraadt@@ and yuo@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.52 2009/11/13 18:06:57 deraadt Exp $ */
d599 1
a599 1
		usb_needs_explore(sc->sc_hub);
@


1.52
log
@do not need to pad up the uhub allocation anymore, from miod
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.51 2009/11/12 20:16:37 deraadt Exp $ */
d68 2
a69 1
	u_int8_t		sc_status[1];	/* XXX more ports */
d238 5
d244 2
a245 2
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
		  sizeof(sc->sc_status), uhub_intr, UHUB_INTR_INTERVAL);
d334 2
d363 1
a363 1
	for(port = 1; port <= hd->bNbrPorts; port++) {
d574 2
d600 2
@


1.51
log
@Avoid using the trick of malloc'ing more than a struct to grow the array
of the last element.  Bad technique.  Use a pointer to the array.  The
author (or later people) will often not pay attention to the consequences
of structure padding & alignment issues when they add new fields to the
base structure, and there will be fireworks.
tested by jasper, too
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.50 2009/10/13 19:33:19 pirofti Exp $ */
d194 1
a194 2
	hub = malloc(sizeof(*hub) + (nports-1) * sizeof(struct usbd_port),
		     M_USBDEV, M_NOWAIT);
@


1.50
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.49 2008/06/26 05:42:18 ray Exp $ */
d198 6
d329 2
d567 2
@


1.49
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.48 2007/10/11 18:33:15 deraadt Exp $ */
d87 1
a87 1
int uhub_activate(struct device *, enum devact); 
d500 1
a500 1
uhub_activate(struct device *self, enum devact act)
@


1.48
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.47 2007/06/14 10:11:16 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.47
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.46 2007/06/12 16:26:36 mbalmer Exp $ */
a134 1
	char *devinfop;
a145 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf(": %s\n", devinfop);
	usbd_devinfo_free(devinfop);
@


1.46
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.45 2007/06/10 14:49:01 mbalmer Exp $ */
d91 16
a106 1
USB_DECLARE_DRIVER(uhub);
@


1.45
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.44 2007/06/10 10:53:48 mbalmer Exp $ */
d497 1
a497 1
uhub_activate(device_ptr_t self, enum devact act)
@


1.44
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.43 2007/06/06 19:25:49 mk Exp $ */
d140 1
a140 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d146 1
a146 1
		       USBDEVNAME(sc->sc_dev), USB_HUB_MAX_DEPTH);
d165 1
a165 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d175 1
a175 1
	       USBDEVNAME(sc->sc_dev), nports, nports != 1 ? "s" : "",
d187 1
a187 1
		printf("%s: no ports, hub ignored\n", USBDEVNAME(sc->sc_dev));
d209 1
a209 1
		       "ignored\n", USBDEVNAME(sc->sc_dev));
d216 1
a216 1
		printf("%s: no interface handle\n", USBDEVNAME(sc->sc_dev));
d221 1
a221 1
		printf("%s: no endpoint descriptor\n", USBDEVNAME(sc->sc_dev));
d225 1
a225 1
		printf("%s: bad interrupt endpoint\n", USBDEVNAME(sc->sc_dev));
d234 1
a234 1
		       USBDEVNAME(sc->sc_dev));
d304 1
a304 1
			       USBDEVNAME(sc->sc_dev), port,
d358 1
a358 1
			    USBDEVNAME(sc->sc_dev), port, status, change));
d367 1
a367 1
				       USBDEVNAME(sc->sc_dev), port);
d373 1
a373 1
					       USBDEVNAME(sc->sc_dev), port);
d380 1
a380 1
					       USBDEVNAME(sc->sc_dev), port);
d393 1
a393 1
				       USBDEVNAME(sc->sc_dev));
d431 1
a431 1
			       USBDEVNAME(sc->sc_dev), port);
d439 1
a439 1
			       USBDEVNAME(sc->sc_dev), port);
d455 1
a455 1
			       USBDEVNAME(sc->sc_dev), port);
d483 1
a483 1
			       USBDEVNAME(sc->sc_dev), port);
@


1.43
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.42 2007/06/06 03:23:49 jsg Exp $ */
d241 1
a241 1
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, USBDEV(sc->sc_dev));
d416 1
a416 1
			usb_disconnect_port(up, USBDEV(sc->sc_dev));
d468 1
a468 1
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus,
d552 1
a552 1
			   USBDEV(sc->sc_dev));
@


1.42
log
@Shrink dmesg output.  Tweaked version of a diff from tedu@@
ok by a bunch of people
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.41 2007/06/05 08:43:55 mbalmer Exp $ */
d72 1
a72 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.41
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.40 2007/06/01 06:12:20 mbalmer Exp $ */
d134 1
a134 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d172 2
d184 1
@


1.40
log
@Remove more Free(?)BSD and NetBSD #ifdef/#endifs.  No functional nor
binary change.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.39 2007/05/27 04:00:25 jsg Exp $ */
d82 2
a83 2
Static usbd_status uhub_explore(usbd_device_handle hub);
Static void uhub_intr(usbd_xfer_handle, usbd_private_handle,usbd_status);
@


1.39
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.38 2007/05/21 05:40:28 jsg Exp $ */
a49 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a51 5
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include "bus_if.h"
#endif
a84 5
#if defined(__FreeBSD__)
Static bus_child_detached_t uhub_child_detached;
#endif


a90 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a92 5
#if defined(__NetBSD__)
/* Create the driver instance for the hub connected to hub case */
CFATTACH_DECL(uhub_uhub, sizeof(struct uhub_softc),
    uhub_match, uhub_attach, uhub_detach, uhub_activate);
#else
a96 22
#endif
#elif defined(__FreeBSD__)
USB_DECLARE_DRIVER_INIT(uhub,
			DEVMETHOD(bus_child_detached, uhub_child_detached));

/* Create the driver instance for the hub connected to usb case. */
devclass_t uhubroot_devclass;

Static device_method_t uhubroot_methods[] = {
	DEVMETHOD(device_probe, uhub_match),
	DEVMETHOD(device_attach, uhub_attach),

	/* detach is not allowed for a root hub */
	{0,0}
};

Static	driver_t uhubroot_driver = {
	"uhub",
	uhubroot_methods,
	sizeof(struct uhub_softc)
};
#endif
a492 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a519 1
#endif
a532 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a533 3
#elif defined(__FreeBSD__)
	DPRINTF(("uhub_detach: sc=%port\n", sc));
#endif
a558 32
#if defined(__FreeBSD__)
/* Called when a device has been detached from it */
Static void
uhub_child_detached(device_t self, device_t child)
{
       struct uhub_softc *sc = device_get_softc(self);
       usbd_device_handle devhub = sc->sc_hub;
       usbd_device_handle dev;
       int nports;
       int port;
       int i;

       if (!devhub->hub)
               /* should never happen; children are only created after init */
               panic("hub not fully initialised, but child deleted?");

       nports = devhub->hub->hubdesc.bNbrPorts;
       for (port = 0; port < nports; port++) {
               dev = devhub->hub->ports[port].device;
               if (dev && dev->subdevs) {
                       for (i = 0; dev->subdevs[i]; i++) {
                               if (dev->subdevs[i] == child) {
                                       dev->subdevs[i] = NULL;
                                       return;
                               }
                       }
               }
       }
}
#endif


a575 5

#if defined(__FreeBSD__)
DRIVER_MODULE(uhub, usb, uhubroot_driver, uhubroot_devclass, 0, 0);
DRIVER_MODULE(uhub, uhub, uhub_driver, uhub_devclass, usbd_driver_load, 0);
#endif
@


1.38
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.37 2007/03/22 05:45:57 pascoe Exp $ */
d137 2
a138 1
USB_MATCH(uhub)
d140 1
a140 1
	USB_MATCH_START(uhub, uaa);
d153 2
a154 1
USB_ATTACH(uhub)
d156 2
a157 1
	USB_ATTACH_START(uhub, sc, uaa);
d173 1
a173 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d180 1
a180 1
		USB_ATTACH_ERROR_RETURN;
d186 1
a186 1
		USB_ATTACH_ERROR_RETURN;
d205 1
a205 1
		USB_ATTACH_ERROR_RETURN;
d230 1
a230 1
		USB_ATTACH_ERROR_RETURN;
d353 1
a353 1
	USB_ATTACH_SUCCESS_RETURN;
a358 1
	USB_ATTACH_ERROR_RETURN;
d566 2
a567 1
USB_DETACH(uhub)
d569 1
a569 1
	USB_DETACH_START(uhub, sc);
@


1.37
log
@Reapplication of rev 1.36.

Wait the stable power delay on a USB hub only once per hub (not per port),
and defer the delay for root hubs until the host controller event thread
starts, permitting some concurrency.  Speeds up the boot process dramatically
when you have lots of host controllers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.36 2007/03/18 20:14:51 mglocker Exp $ */
d69 2
a70 2
#define DPRINTF(x)	do { if (uhubdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhubdebug>(n)) logprintf x; } while (0)
@


1.36
log
@Backout pascoe@@'s last USB change because it page faults at attachment
time.

Chris; Get your shiz fixed and tested for the next time.  We have
better todo then wasting our time by backing out untested stuff.

OK deraadt, OK ckuethe
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.34 2006/06/26 19:12:38 mjc Exp $ */
d341 4
a344 1
		/* Wait for stable power. */
a345 1
	}
@


1.35
log
@Wait the stable power delay on a USB hub only once per hub (not per port),
and defer the delay for root hubs until the host controller event thread
starts, permitting some concurrency.  Speeds up the boot process dramatically
when you have lots of host controllers.

ok dlg@@
@
text
@d341 2
a343 4

	/* Wait for stable power.  Root hubs delay in their event thread. */
	if (dev->powersrc->parent != NULL)
		usbd_delay_ms(dev, pwrdly);
@


1.34
log
@fix typos in debug messages
ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.33 2006/06/23 06:27:11 miod Exp $ */
d341 4
a344 1
		/* Wait for stable power. */
a345 1
	}
@


1.33
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.32 2005/08/01 05:36:48 brad Exp $ */
d505 1
a505 1
			DPRINTFN(-1,("uhub_explore: usb_new_device failed, "
@


1.32
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.31 2005/03/28 02:34:16 dlg Exp $ */
d540 1
a540 1
		return (EOPNOTSUPP);
@


1.31
log
@shorten dmesg

requested by deraadt@@ ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.30 2005/03/13 02:54:04 pascoe Exp $ */
d156 1
a156 1
	char devinfo[1024];
d168 2
a169 1
	usbd_devinfo(dev, 1, devinfo, sizeof devinfo);
d171 2
a172 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.30
log
@Merge support for USB1 devices located beyond USB2 hubs, mostly from netbsd.

Supports bulk, control and interrupt pipes, letting USB1 keyboards and most
network interfaces work when connected to a USB2 hub.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.29 2004/12/12 05:21:14 dlg Exp $ */
a171 7
	if (UHUB_IS_HIGH_SPEED(sc)) {
		printf("%s: %s transaction translator%s\n",
		    USBDEVNAME(sc->sc_dev),
		    UHUB_IS_SINGLE_TT(sc) ? "single" : "multiple",
		    UHUB_IS_SINGLE_TT(sc) ? "" : "s");
	}

d207 1
a207 1
	printf("%s: %d port%s with %d removable, %s powered\n",
d210 7
@


1.29
log
@get rid of uhub_reset_device
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.28 2004/12/12 05:17:40 dlg Exp $ */
d84 3
d158 1
a158 1
	struct usbd_hub *hub;
d164 1
d172 7
d218 5
d300 6
d309 1
a309 1
		up->device = 0;
d319 6
d350 3
a352 2
	free(hub, M_USBDEV);
	dev->hub = 0;
a377 2
		reconnect = up->reattach;
		up->reattach = 0;
d386 2
d590 2
@


1.28
log
@better way to do the reattachement of a device
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.27 2004/12/09 11:49:55 dlg Exp $ */
a85 1
Static usbd_status uhub_reset_device(usbd_device_handle, int);
a213 1
	hub->reset_device = uhub_reset_device;
a324 78
}

Static usbd_status
uhub_reset_device(usbd_device_handle dev, int port)
{
	struct uhub_softc *sc = dev->hub->hubsoftc;
	struct usbd_port *up;
	int status, change;
	int speed;
	usbd_status err;

	DPRINTFN(10, ("uhub_reset_device port=%d\n", port));

	if (!sc->sc_running)
		return (USBD_NOT_STARTED);

	up = &dev->hub->ports[port-1];

	/* Disconnect */
	DPRINTF(("uhub_reset_device: disconnecting device on port %d\n", port));
	usb_disconnect_port(up, USBDEV(sc->sc_dev));
	usbd_clear_port_feature(dev, port, UHF_C_PORT_CONNECTION);

	/* Wait for maximum device power up time. */
	usbd_delay_ms(dev, USB_PORT_POWERUP_DELAY);

	/* Reset port, which implies enabling it. */
	err = usbd_reset_port(dev, port, &up->status);
	if (err) {
		printf("%s: port %d reset failed\n",
		    USBDEVNAME(sc->sc_dev), port);
		return(err);
	}

	/* connect */
	err = usbd_get_port_status(dev, port, &up->status);
	if (err) {
		DPRINTF(("uhub_reset_device: get port status failed, "
		    "error=%s\n", usbd_errstr(err)));
		return (err);
	}
	status = UGETW(up->status.wPortStatus);
	change = UGETW(up->status.wPortChange);

	/* Figure out device speed */
	if (status & UPS_HIGH_SPEED)
		speed = USB_SPEED_HIGH;
	else if (status & UPS_LOW_SPEED)
		speed = USB_SPEED_LOW;
	else
		speed = USB_SPEED_FULL;
	/* Get device info and set its address. */
	err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, dev->depth + 1,
	    speed, port, up);
	/* XXX retry a few times? */
	if (err) {
		DPRINTFN(-1,("uhub_explore: usb_new_device failed, "
		    "error=%s\n", usbd_errstr(err)));
		/* Avoid addressing problems by disabling. */
		/* usbd_reset_port(dev, port, &up->status); */

		/*
		 * The unit refused to accept a new address, or had
		 * some other serious problem.  Since we cannot leave
		 * at 0 we have to disable the port instead.
		 */
		printf("%s: device problem, disabling port %d\n",
		    USBDEVNAME(sc->sc_dev), port);
		usbd_clear_port_feature(dev, port, UHF_PORT_ENABLE);
	} else {
		/* The port set up succeeded, reset error count. */
		up->restartcnt = 0;

		if (up->device->hub)
			up->device->hub->explore(up->device);
	}

	return (USBD_NORMAL_COMPLETION);
@


1.27
log
@code to let us cause a detach and reattach of a device from software

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.26 2004/07/11 05:32:38 deraadt Exp $ */
d298 1
d416 1
a416 1
	int change, status;
d429 2
d465 1
a465 1
		if (!(change & UPS_C_CONNECT_STATUS)) {
@


1.26
log
@from netbsd via loki@@animata.net, revision 1.68
Ignore a port error that happens to come in at the same time as a connect
status change.  Some root hubs seem to report both.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.25 2004/07/11 05:29:16 deraadt Exp $ */
d86 1
d215 1
d326 78
@


1.25
log
@from netbsd via loki@@animata.net
uhub.c revision 1.65, ohci.c revision 1.146, uhci.c revision 1.177
Use the correct wValue to get hub desriptors.
Also, make wValue checks of root hub codes less strict.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.24 2004/07/08 22:18:44 deraadt Exp $ */
d361 4
a364 1
			if (status & UPS_PORT_ENABLED) {
@


1.24
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.23 2004/07/07 01:26:40 deraadt Exp $ */
d184 1
a184 1
	USETW(req.wValue, 0);
@


1.23
log
@silence something
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.22 2004/06/10 17:31:15 pvalchev Exp $ */
d69 2
a70 2
#define DPRINTF(x)	if (uhubdebug) logprintf x
#define DPRINTFN(n,x)	if (uhubdebug>(n)) logprintf x
@


1.22
log
@From FreeBSD (via rees@@umich.edu and nate)
Initialise `restartcnt' in the newly malloc'd usbd_port structure,
as otherwise the junk it contains may cause uhub_explore to give
up without ever trying to restart the port. This fixes the following
errors I was seeing with a VIA UHCI controller:

  uhub0: port error, restarting port 1
  uhub0: port error, giving up port 1
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.21 2003/07/08 13:19:09 nate Exp $ */
d449 1
a449 1
#ifdef DIAGNOSTIC
@


1.21
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.20 2003/05/19 04:17:53 nate Exp $ */
d295 1
@


1.20
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.19 2003/05/07 04:33:33 deraadt Exp $ */
/*	$NetBSD: uhub.c,v 1.52 2001/10/26 17:53:59 augustss Exp $	*/
d71 1
a71 1
int	uhubdebug;
d102 1
d104 3
d111 1
d332 1
d455 7
d464 1
a464 2
			  dev->depth + 1, status & UPS_LOW_SPEED,
			  port, up);
a502 1
		break;
@


1.19
log
@string cleanup; nate ok
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.18 2002/07/25 02:18:10 nate Exp $ */
d43 1
a43 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
@


1.18
log
@get rid of trailing whitespace
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.17 2002/07/10 13:15:58 nate Exp $ */
d159 1
a159 1
	usbd_devinfo(dev, 1, devinfo);
@


1.17
log
@Handle resetting port better.
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.16 2002/05/07 18:29:18 nate Exp $ */
d93 1
a93 1
/* 
d110 1
a110 1
			
d133 1
a133 1
	
d135 1
a135 1
	/* 
d156 1
a156 1
	
d210 1
a210 1
	
d214 1
a214 1
		 dev->powersrc->parent ? 
d241 1
a241 1
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status, 
d244 1
a244 1
		printf("%s: cannot open interrupt pipe\n", 
d300 1
a300 1
			printf("%s: port %d power on failed, %s\n", 
d379 1
a379 1
			if (up->device == NULL && 
d406 1
a406 1
			usbd_clear_port_feature(dev, port, 
d450 2
a451 2
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, 
			  dev->depth + 1, status & UPS_LOW_SPEED, 
d460 1
a460 1
			/* 
d539 1
a539 1
	
d561 1
a561 1
       if (!devhub->hub)  
@


1.16
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.14 2001/10/31 04:24:44 nate Exp $ */
d271 1
d427 19
a445 2
			printf("uhub_explore: port=%d reset failed\n",
				 port);
@


1.15
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uhub.c,v 1.57 2001/11/20 16:08:37 augustss Exp $	*/
a270 1
	 *        wait 100 ms
a325 1
	int speed;
d426 2
a427 19
			printf("%s: port %d reset failed\n",
			       USBDEVNAME(sc->sc_dev), port);
			continue;
		}
		/* Get port status again, it might have changed during reset */
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
#ifdef DIAGNOSTIC
			printf("%s: port %d, device disappeared after reset\n",
			       USBDEVNAME(sc->sc_dev), port);
#endif
a430 7
		/* Figure out device speed */
		if (status & UPS_HIGH_SPEED)
			speed = USB_SPEED_HIGH;
		else if (status & UPS_LOW_SPEED)
			speed = USB_SPEED_LOW;
		else
			speed = USB_SPEED_FULL;
d433 2
a434 1
			  dev->depth + 1, speed, port, up);
@


1.14
log
@Synchronize usb code with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.13 2001/05/03 02:20:33 aaron Exp $ */
/*	$NetBSD: uhub.c,v 1.52 2001/10/26 17:53:59 augustss Exp $	*/
d271 1
d327 1
d428 19
a446 2
			printf("uhub_explore: port=%d reset failed\n",
				 port);
d450 7
d459 1
a459 2
			  dev->depth + 1, status & UPS_LOW_SPEED, 
			  port, up);
@


1.14.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.14 2001/10/31 04:24:44 nate Exp $ */
@


1.14.2.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.14.2.1 2002/06/11 03:42:30 art Exp $ */
d93 1
a93 1
/*
d110 1
a110 1

d133 1
a133 1

d135 1
a135 1
	/*
d156 1
a156 1

d210 1
a210 1

d214 1
a214 1
		 dev->powersrc->parent ?
d241 1
a241 1
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
d244 1
a244 1
		printf("%s: cannot open interrupt pipe\n",
a270 1
	 *        wait 100 ms
d299 1
a299 1
			printf("%s: port %d power on failed, %s\n",
d378 1
a378 1
			if (up->device == NULL &&
d405 1
a405 1
			usbd_clear_port_feature(dev, port,
d426 2
a427 19
			printf("%s: port %d reset failed\n",
			       USBDEVNAME(sc->sc_dev), port);
			continue;
		}
		/* Get port status again, it might have changed during reset */
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
#ifdef DIAGNOSTIC
			printf("%s: port %d, device disappeared after reset\n",
			       USBDEVNAME(sc->sc_dev), port);
#endif
d432 2
a433 2
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus,
			  dev->depth + 1, status & UPS_LOW_SPEED,
d442 1
a442 1
			/*
d521 1
a521 1

d543 1
a543 1
       if (!devhub->hub)
@


1.14.2.3
log
@sync
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d159 1
a159 1
	usbd_devinfo(dev, 1, devinfo, sizeof devinfo);
@


1.13
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.12 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: uhub.c,v 1.49 2001/01/21 19:00:06 augustss Exp $	*/
d348 2
a349 2
		DPRINTFN(3,("uhub_explore: port %d status 0x%04x 0x%04x\n",
			    port, status, change));
d375 1
a375 1
			if (up->device && up->device->hub)
d377 6
d575 1
a575 1
	if (status != USBD_NORMAL_COMPLETION)
d577 2
a578 2

	usb_needs_explore(sc->sc_hub);
@


1.12
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.11 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: uhub.c,v 1.47 2000/09/24 02:08:38 augustss Exp $	*/
d572 1
a572 1
	usb_needs_explore(sc->sc_hub->bus);
@


1.11
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.10 2000/07/04 11:44:23 fgsch Exp $ */
d43 1
a43 1
 * USB spec: http://www.usb.org/developers/docs.htm
@


1.10
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.9 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: uhub.c,v 1.41 2000/03/27 12:33:56 augustss Exp $	*/
d85 2
a86 2
Static usbd_status uhub_explore __P((usbd_device_handle hub));
Static void uhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));
d320 1
a320 2
uhub_explore(dev)
	usbd_device_handle dev;
d358 1
a358 1
				if (up->restartcnt++ < USBD_RESTART_MAX) {
d362 2
d365 1
a365 1
				} else {
a368 1
				}
a414 2
		up->restartcnt = 0;

a443 2
			/* Make sure we don't try to restart it infinitely. */
			up->restartcnt = USBD_RESTART_MAX;
d445 3
d457 1
a457 3
uhub_activate(self, act)
	device_ptr_t self;
	enum devact act;
d475 2
a476 2
			if (dev != NULL) {
				for (i = 0; dev->subdevs[i]; i++)
d528 1
a528 3
uhub_child_detached(self, child)
       device_t self;
       device_t child;
d564 1
a564 4
uhub_intr(xfer, addr, status)
	usbd_xfer_handle xfer;
	usbd_private_handle addr;
	usbd_status status;
@


1.9
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.8 2000/03/28 19:37:50 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d43 1
a43 1
 * USB spec: http://www.usb.org/cgi-usb/mailmerge.cgi/home/usb/docs/developers/cgiform.tpl
d66 2
a84 1
Static usbd_status uhub_init_port __P((struct usbd_port *));
d153 1
a153 1
	int p, port, nports, nremov;
d242 1
a242 1
		  sizeof(sc->sc_status), uhub_intr, USBD_DEFAULT_INTERVAL);
d254 25
d284 14
a297 1
		err = uhub_init_port(up);
d299 6
a304 2
			printf("%s: init of port %d failed\n", 
			    USBDEVNAME(sc->sc_dev), up->portno);
d306 3
a319 62
uhub_init_port(up)
	struct usbd_port *up;
{
	int port = up->portno;
	usbd_device_handle dev = up->parent;
	usbd_status err;
	u_int16_t pstatus;

	err = usbd_get_port_status(dev, port, &up->status);
	if (err)
		return (err);
	pstatus = UGETW(up->status.wPortStatus);
	DPRINTF(("usbd_init_port: adding hub port=%d status=0x%04x "
		 "change=0x%04x\n",
		 port, pstatus, UGETW(up->status.wPortChange)));
	if ((pstatus & UPS_PORT_POWER) == 0) {
		/* Port lacks power, turn it on */

		/* First let the device go through a good power cycle, */
		usbd_delay_ms(dev, USB_PORT_POWER_DOWN_TIME);

		/* then turn the power on. */
		err = usbd_set_port_feature(dev, port, UHF_PORT_POWER);
		if (err)
			return (err);
		DPRINTF(("usb_init_port: turn on port %d power status=0x%04x "
			 "change=0x%04x\n",
			 port, UGETW(up->status.wPortStatus),
			 UGETW(up->status.wPortChange)));
		/* Wait for stable power. */
		usbd_delay_ms(dev, dev->hub->hubdesc.bPwrOn2PwrGood * 
			           UHD_PWRON_FACTOR);
		/* Get the port status again. */
		err = usbd_get_port_status(dev, port, &up->status);
		if (err)
			return (err);
		DPRINTF(("usb_init_port: after power on status=0x%04x "
			 "change=0x%04x\n",
			 UGETW(up->status.wPortStatus),
			 UGETW(up->status.wPortChange)));

#if 0
usbd_clear_hub_feature(dev, UHF_C_HUB_OVER_CURRENT);
usbd_clear_port_feature(dev, port, UHF_C_PORT_OVER_CURRENT);
usbd_get_port_status(dev, port, &up->status);
#endif

		pstatus = UGETW(up->status.wPortStatus);
		if ((pstatus & UPS_PORT_POWER) == 0)
			printf("%s: port %d did not power up\n",
 USBDEVNAME(((struct uhub_softc *)dev->hub->hubsoftc)->sc_dev), port);

	}
	if (dev->self_powered)
		/* Self powered hub, give ports maximum current. */
		up->power = USB_MAX_POWER;
	else
		up->power = USB_MIN_POWER;
	return (USBD_NORMAL_COMPLETION);
}

usbd_status
d379 3
d385 1
a385 1
		usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);
d403 1
d410 5
d422 2
a423 2
			DPRINTF(("uhub_explore: port=%d reset failed\n",
				 port));
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhub.c,v 1.40 2000/02/29 21:37:01 augustss Exp $	*/
d83 3
a85 3
static usbd_status uhub_init_port __P((struct usbd_port *));
static usbd_status uhub_explore __P((usbd_device_handle hub));
static void uhub_intr __P((usbd_xfer_handle, usbd_private_handle,usbd_status));
d88 1
a88 1
static bus_child_detached_t uhub_child_detached;
d113 1
a113 1
static device_method_t uhubroot_methods[] = {
d121 1
a121 1
static	driver_t uhubroot_driver = {
d537 1
a537 1
static void
@


1.7
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
d3 1
d83 3
a85 3
usbd_status uhub_init_port __P((struct usbd_port *));
usbd_status uhub_explore __P((usbd_device_handle hub));
void uhub_intr __P((usbd_xfer_handle, usbd_private_handle, usbd_status));
d91 1
d107 1
a107 1
USB_DECLARE_DRIVER_INIT(uhub.
d109 1
a109 1

d240 2
a241 2
	    USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
	    sizeof(sc->sc_status), uhub_intr, USBD_DEFAULT_INTERVAL);
d368 1
d436 2
a437 2
				    dev->depth + 1, status & UPS_LOW_SPEED, 
				    port, up);
d525 1
a525 1

d528 1
a528 1
	
d539 2
a540 2
	device_t self;
	device_t child;
d542 23
a564 23
	struct uhub_softc *sc = device_get_softc(self);
	usbd_device_handle devhub = sc->sc_hub;
	usbd_device_handle dev;
	int nports;
	int port;
	int i;

	if (!devhub->hub)
		/* should never happen; children are only created after init */
		panic("hub not fully initialised, but child deleted?");

	nports = devhub->hub->hubdesc.bNbrPorts;
	for (port = 0; port < nports; port++) {
		dev = devhub->hub->ports[port].device;
		if (dev && dev->subdevs) {
			for (i = 0; dev->subdevs[i]; i++) {
				if (dev->subdevs[i] == child) {
					dev->subdevs[i] = NULL;
					return;
				}
			}
		}
	}
d567 1
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhub.c,v 1.32 1999/10/13 08:10:56 augustss Exp $	*/
d51 1
a56 1
#include <sys/proc.h>
d66 3
a68 3
#define DPRINTF(x)	if (usbdebug) logprintf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) logprintf x
extern int	usbdebug;
d84 1
a84 1
void uhub_intr __P((usbd_request_handle, usbd_private_handle, usbd_status));
a89 3
USB_DECLARE_DRIVER_INIT(uhub, 
			DEVMETHOD(bus_child_detached, uhub_child_detached));

d97 2
d105 3
d136 1
a136 1
	if (uaa->iface == 0 && dd->bDeviceClass == UCLASS_HUB)
d146 1
a146 1
	usbd_status r;
d160 2
a161 2
	r = usbd_set_config_index(dev, 0, 1);
	if (r != USBD_NORMAL_COMPLETION) {
d163 1
a163 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(r)));
d180 1
a180 1
	r = usbd_do_request(dev, &req, &hubdesc);
d182 1
a182 1
	if (r == USBD_NORMAL_COMPLETION && nports > 7) {
d184 1
a184 1
		r = usbd_do_request(dev, &req, &hubdesc);
d186 1
a186 1
	if (r != USBD_NORMAL_COMPLETION) {
d188 1
a188 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(r)));
d201 1
a201 1
	if (hub == 0)
d214 1
a214 1
	if (!dev->self_powered && dev->powersrc->parent &&
d222 2
a223 2
	r = usbd_device2interface_handle(dev, 0, &iface);
	if (r != USBD_NORMAL_COMPLETION) {
d228 1
a228 1
	if (ed == 0) {
d237 4
a240 5
	r = usbd_open_pipe_intr(iface, ed->bEndpointAddress,USBD_SHORT_XFER_OK,
				&sc->sc_ipipe, sc, sc->sc_status, 
				sizeof(sc->sc_status),
				uhub_intr);
	if (r != USBD_NORMAL_COMPLETION) {
d249 2
d256 2
a257 2
		r = uhub_init_port(up);
		if (r != USBD_NORMAL_COMPLETION)
d259 1
a259 1
			       USBDEVNAME(sc->sc_dev), up->portno);
d277 1
a277 1
	usbd_status r;
d280 3
a282 3
	r = usbd_get_port_status(dev, port, &up->status);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
a292 5
#if 0
usbd_clear_hub_feature(dev, UHF_C_HUB_OVER_CURRENT);
usbd_clear_port_feature(dev, port, UHF_C_PORT_OVER_CURRENT);
#endif

d294 3
a296 3
		r = usbd_set_port_feature(dev, port, UHF_PORT_POWER);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d305 3
a307 3
		r = usbd_get_port_status(dev, port, &up->status);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d340 1
a340 1
	usbd_status r;
d355 2
a356 2
		r = usbd_get_port_status(dev, port, &up->status);
		if (r != USBD_NORMAL_COMPLETION) {
d358 1
a358 2
				 "error=%s\n",
				 usbd_errstr(r)));
d363 2
a364 2
		DPRINTFN(5, ("uhub_explore: port %d status 0x%04x 0x%04x\n",
			     port, status, change));
d385 2
d404 1
a404 1
		if (up->device) {
d406 1
a406 1
			DPRINTF(("uhub_explore: device %d disappeared "
d412 3
a414 1
		if (!(status & UPS_CURRENT_CONNECT_STATUS))
d416 1
d425 3
a427 2
		if (usbd_reset_port(dev, port, &up->status) != 
		    USBD_NORMAL_COMPLETION)
d429 1
d432 1
a432 1
		r = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, 
d436 1
a436 1
		if (r != USBD_NORMAL_COMPLETION) {
d438 1
a438 1
				     "error=%s\n", usbd_errstr(r)));
d467 3
a469 2
	usbd_device_handle devhub = sc->sc_hub;
	int nports, p, i;
d477 6
a482 4
		nports = devhub->hub->hubdesc.bNbrPorts;
		for(p = 0; p < nports; p++) {
			usbd_device_handle dev = devhub->hub->ports[p].device;
			if (dev) {
d500 1
a500 1
	usbd_device_handle dev = sc->sc_hub;
d510 1
a510 1
	if (!dev->hub)		/* Must be partially working */
d516 1
a516 1
	nports = dev->hub->hubdesc.bNbrPorts;
d518 1
a518 1
		rup = &dev->hub->ports[port];
d522 3
d526 2
a527 2
	free(dev->hub, M_USBDEV);
	dev->hub = 0;
d532 33
d572 2
a573 2
uhub_intr(reqh, addr, status)
	usbd_request_handle reqh;
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: uhub.c,v 1.12 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: uhub.c,v 1.47 2000/09/24 02:08:38 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhub.c,v 1.18 1999/11/17 22:33:43 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d42 1
a42 1
 * USB spec: http://www.usb.org/developers/data/usbspec.zip
a50 1
#include <sys/proc.h>
d56 1
a64 2
#define UHUB_INTR_INTERVAL 255	/* ms */

d66 3
a68 3
#define DPRINTF(x)	if (uhubdebug) logprintf x
#define DPRINTFN(n,x)	if (uhubdebug>(n)) logprintf x
int	uhubdebug;
d82 3
a84 2
Static usbd_status uhub_explore(usbd_device_handle hub);
Static void uhub_intr(usbd_xfer_handle, usbd_private_handle,usbd_status);
d87 1
a87 1
Static bus_child_detached_t uhub_child_detached;
d90 2
a99 2
USB_DECLARE_DRIVER(uhub);

a105 3
USB_DECLARE_DRIVER_INIT(uhub,
			DEVMETHOD(bus_child_detached, uhub_child_detached));
			
d109 1
a109 1
Static device_method_t uhubroot_methods[] = {
d117 1
a117 1
Static	driver_t uhubroot_driver = {
d134 1
a134 1
	if (uaa->iface == NULL && dd->bDeviceClass == UDCLASS_HUB)
d144 1
a144 1
	usbd_status err;
d148 1
a148 1
	int p, port, nports, nremov, pwrdly;
d158 2
a159 2
	err = usbd_set_config_index(dev, 0, 1);
	if (err) {
d161 1
a161 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d178 1
a178 1
	err = usbd_do_request(dev, &req, &hubdesc);
d180 1
a180 1
	if (!err && nports > 7) {
d182 1
a182 1
		err = usbd_do_request(dev, &req, &hubdesc);
d184 1
a184 1
	if (err) {
d186 1
a186 1
			 USBDEVNAME(sc->sc_dev), usbd_errstr(err)));
d199 1
a199 1
	if (hub == NULL)
d212 1
a212 1
	if (!dev->self_powered && dev->powersrc->parent != NULL &&
d220 2
a221 2
	err = usbd_device2interface_handle(dev, 0, &iface);
	if (err) {
d226 1
a226 1
	if (ed == NULL) {
d235 5
a239 4
	err = usbd_open_pipe_intr(iface, ed->bEndpointAddress,
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status, 
		  sizeof(sc->sc_status), uhub_intr, UHUB_INTR_INTERVAL);
	if (err) {
a247 27
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, USBDEV(sc->sc_dev));

	/*
	 * To have the best chance of success we do things in the exact same
	 * order as Windoze98.  This should not be necessary, but some
	 * devices do not follow the USB specs to the letter.
	 *
	 * These are the events on the bus when a hub is attached:
	 *  Get device and config descriptors (see attach code)
	 *  Get hub descriptor (see above)
	 *  For all ports
	 *     turn on power
	 *     wait for power to become stable
	 * (all below happens in explore code)
	 *  For all ports
	 *     clear C_PORT_CONNECTION
	 *  For all ports
	 *     get port status
	 *     if device connected
	 *        turn on reset
	 *        wait
	 *        clear C_PORT_RESET
	 *        get port status
	 *        proceed with device attachment
	 */

	/* Set up data structures */
d253 4
a256 21
		if (dev->self_powered)
			/* Self powered hub, give ports maximum current. */
			up->power = USB_MAX_POWER;
		else
			up->power = USB_MIN_POWER;
	}

	/* XXX should check for none, individual, or ganged power? */

	pwrdly = dev->hub->hubdesc.bPwrOn2PwrGood * UHD_PWRON_FACTOR
	    + USB_EXTRA_POWER_UP_TIME;
	for (port = 1; port <= nports; port++) {
		/* Turn the power on. */
		err = usbd_set_port_feature(dev, port, UHF_PORT_POWER);
		if (err)
			printf("%s: port %d power on failed, %s\n", 
			       USBDEVNAME(sc->sc_dev), port,
			       usbd_errstr(err));
		DPRINTF(("usb_init_port: turn on port %d power\n", port));
		/* Wait for stable power. */
		usbd_delay_ms(dev, pwrdly);
a257 3

	/* The usual exploration will finish the setup. */

d269 69
a337 1
uhub_explore(usbd_device_handle dev)
d342 1
a342 1
	usbd_status err;
d357 2
a358 2
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
d360 2
a361 1
				 "error=%s\n", usbd_errstr(err)));
d366 2
a367 2
		DPRINTFN(3,("uhub_explore: port %d status 0x%04x 0x%04x\n",
			    port, status, change));
a368 1
			DPRINTF(("uhub_explore: C_PORT_ENABLED\n"));
d375 1
a375 1
				if (up->restartcnt) /* no message first time */
a378 2

				if (up->restartcnt++ < USBD_RESTART_MAX)
d380 1
a380 1
				else
d384 1
a387 2
			DPRINTFN(3,("uhub_explore: port=%d !C_CONNECT_"
				    "STATUS\n", port));
a392 3

		/* We have a connect status change, handle it. */

d396 1
a396 1
		/*usbd_clear_port_feature(dev, port, UHF_C_PORT_ENABLE);*/
d405 1
a405 1
		if (up->device != NULL) {
d407 1
a407 1
			DPRINTF(("uhub_explore: device addr=%d disappeared "
d413 1
a413 4
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
			DPRINTFN(3,("uhub_explore: port=%d !CURRENT_CONNECT"
				    "_STATUS\n", port));
a414 1
		}
d417 1
a417 4

		if (!(status & UPS_PORT_POWER))
			printf("%s: strange, connected port %d has no power\n",
			       USBDEVNAME(sc->sc_dev), port);
d423 2
a424 3
		if (usbd_reset_port(dev, port, &up->status)) {
			printf("uhub_explore: port=%d reset failed\n",
				 port);
a425 1
		}
d428 3
a430 3
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus, 
			  dev->depth + 1, status & UPS_LOW_SPEED, 
			  port, up);
d432 1
a432 1
		if (err) {
d434 1
a434 1
				     "error=%s\n", usbd_errstr(err)));
d446 2
a448 3
			/* The port set up succeeded, reset error count. */
			up->restartcnt = 0;

d458 3
a460 1
uhub_activate(device_ptr_t self, enum devact act)
d463 2
a464 3
	struct usbd_hub *hub = sc->sc_hub->hub;
	usbd_device_handle dev;
	int nports, port, i;
d472 5
a476 7
		if (hub == NULL) /* malfunctioning hub */
			break;
		nports = hub->hubdesc.bNbrPorts;
		for(port = 0; port < nports; port++) {
			dev = hub->ports[port].device;
			if (dev != NULL && dev->subdevs != NULL) {
				for (i = 0; dev->subdevs[i] != NULL; i++)
d493 1
a493 1
	struct usbd_hub *hub = sc->sc_hub->hub;
d503 1
a503 1
	if (hub == NULL)		/* Must be partially working */
d509 1
a509 1
	nports = hub->hubdesc.bNbrPorts;
d511 1
a511 1
		rup = &hub->ports[port];
d516 2
a517 5
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_hub,
			   USBDEV(sc->sc_dev));

	free(hub, M_USBDEV);
	sc->sc_hub->hub = NULL;
a521 32
#if defined(__FreeBSD__)
/* Called when a device has been detached from it */
Static void
uhub_child_detached(device_t self, device_t child)
{
       struct uhub_softc *sc = device_get_softc(self);
       usbd_device_handle devhub = sc->sc_hub;
       usbd_device_handle dev;
       int nports;
       int port;
       int i;

       if (!devhub->hub)  
               /* should never happen; children are only created after init */
               panic("hub not fully initialised, but child deleted?");

       nports = devhub->hub->hubdesc.bNbrPorts;
       for (port = 0; port < nports; port++) {
               dev = devhub->hub->ports[port].device;
               if (dev && dev->subdevs) {
                       for (i = 0; dev->subdevs[i]; i++) {
                               if (dev->subdevs[i] == child) {
                                       dev->subdevs[i] = NULL;
                                       return;
                               }
                       }
               }
       }
}
#endif


d529 4
a532 1
uhub_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhub.c,v 1.49 2001/01/21 19:00:06 augustss Exp $	*/
d572 1
a572 1
	usb_needs_explore(sc->sc_hub);
@


1.6.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uhub.c,v 1.52 2001/10/26 17:53:59 augustss Exp $	*/
d348 2
a349 2
		DPRINTFN(3,("uhub_explore: %s port %d status 0x%04x 0x%04x\n",
			    USBDEVNAME(sc->sc_dev), port, status, change));
d375 1
a375 1
			if (up->device != NULL && up->device->hub != NULL)
a376 6
#if 0 && defined(DIAGNOSTIC)
			if (up->device == NULL && 
			    (status & UPS_CURRENT_CONNECT_STATUS))
				printf("%s: connected, no device\n",
				       USBDEVNAME(sc->sc_dev));
#endif
d569 1
a569 1
	if (status == USBD_STALLED)
d571 2
a572 2
	else if (status == USBD_NORMAL_COMPLETION)
		usb_needs_explore(sc->sc_hub);
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d93 1
a93 1
/*
d110 1
a110 1

d133 1
a133 1

d135 1
a135 1
	/*
d156 1
a156 1

d210 1
a210 1

d214 1
a214 1
		 dev->powersrc->parent ?
d241 1
a241 1
		  USBD_SHORT_XFER_OK, &sc->sc_ipipe, sc, sc->sc_status,
d244 1
a244 1
		printf("%s: cannot open interrupt pipe\n",
a270 1
	 *        wait 100 ms
d299 1
a299 1
			printf("%s: port %d power on failed, %s\n",
d378 1
a378 1
			if (up->device == NULL &&
d405 1
a405 1
			usbd_clear_port_feature(dev, port,
d426 2
a427 19
			printf("%s: port %d reset failed\n",
			       USBDEVNAME(sc->sc_dev), port);
			continue;
		}
		/* Get port status again, it might have changed during reset */
		err = usbd_get_port_status(dev, port, &up->status);
		if (err) {
			DPRINTF(("uhub_explore: get port status failed, "
				 "error=%s\n", usbd_errstr(err)));
			continue;
		}
		status = UGETW(up->status.wPortStatus);
		change = UGETW(up->status.wPortChange);
		if (!(status & UPS_CURRENT_CONNECT_STATUS)) {
			/* Nothing connected, just ignore it. */
#ifdef DIAGNOSTIC
			printf("%s: port %d, device disappeared after reset\n",
			       USBDEVNAME(sc->sc_dev), port);
#endif
d432 2
a433 2
		err = usbd_new_device(USBDEV(sc->sc_dev), dev->bus,
			  dev->depth + 1, status & UPS_LOW_SPEED,
d442 1
a442 1
			/*
d521 1
a521 1

d543 1
a543 1
       if (!devhub->hub)
@


1.6.2.5
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.6.2.4 2003/03/28 00:38:32 niklas Exp $ */
d159 1
a159 1
	usbd_devinfo(dev, 1, devinfo, sizeof devinfo);
@


1.6.2.6
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhub.c,v 1.6.2.5 2003/05/13 19:35:12 ho Exp $ */
d43 1
a43 1
 * USB spec: http://www.usb.org/developers/docs/usbspec.zip
@


1.6.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhub.c,v 1.64 2003/02/08 03:32:51 ichiro Exp $	*/
d71 1
a71 1
int	uhubdebug = 0;
a101 1
#if defined(__NetBSD__)
a102 3
CFATTACH_DECL(uhub_uhub, sizeof(struct uhub_softc),
    uhub_match, uhub_attach, uhub_detach, uhub_activate);
#else
a106 1
#endif
a326 1
	int speed;
a448 7
		/* Figure out device speed */
		if (status & UPS_HIGH_SPEED)
			speed = USB_SPEED_HIGH;
		else if (status & UPS_LOW_SPEED)
			speed = USB_SPEED_LOW;
		else
			speed = USB_SPEED_FULL;
d451 2
a452 1
			  dev->depth + 1, speed, port, up);
d491 1
@


1.6.2.8
log
@sync to HEAD
@
text
@a294 1
		up->restartcnt = 0;
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: uhub.c,v 1.29 1999/09/15 10:25:31 augustss Exp $	*/
d54 1
d65 1
a65 1
#ifdef USB_DEBUG
d86 12
a97 1
USB_DECLARE_DRIVER_NAME(usb, uhub);
d100 1
d105 17
a195 1
	
d211 1
d408 2
a409 3
				 "on port %d\n", 
				 up->device->address, port));
			usb_disconnect_port(up);
d437 11
a447 19
/* XXX
 * What should we do.  The device may or may not be at its
 * assigned address.  In any case we'd like to ignore it.
 * Maybe the port should be disabled until the device is
 * disconnected.
 */
			if (r == USBD_SET_ADDR_FAILED || 1) {/* XXX */
				/* The unit refused to accept a new
				 * address, and since we cannot leave
				 * at 0 we have to disable the port
				 * instead. */
				printf("%s: device problem, disabling "
				       "port %d\n",
				       USBDEVNAME(sc->sc_dev), port);
				usbd_clear_port_feature(dev, port, 
							UHF_PORT_ENABLE);
				/* Make sure we don't try to restart it. */
				up->restartcnt = USBD_RESTART_MAX;
			}
d456 1
d484 1
d490 1
a490 4
int
uhub_detach(self, flags)
	device_ptr_t self;
	int flags;
d492 1
a492 1
	struct uhub_softc *sc = (struct uhub_softc *)self;
d495 1
a495 1
	int p, nports;
d497 1
d499 3
d503 1
a503 2
	if (!dev->hub) {
		/* Must be partially working */
a504 1
	}
d510 2
a511 2
	for(p = 0; p < nports; p++) {
		rup = &dev->hub->ports[p];
d513 1
a513 1
			usb_disconnect_port(rup);
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.3 1999/08/27 09:00:29 fgsch Exp $	*/
/*	$NetBSD: uhub.c,v 1.23 1999/08/23 22:55:14 augustss Exp $	*/
d57 2
d74 1
a74 1
	bdevice			sc_dev;		/* base device */
a81 1
void uhub_disconnect_port __P((struct usbd_port *up));
d185 1
a185 2
		       "ignored\n",
		       USBDEVNAME(sc->sc_dev));
d380 1
a380 1
			uhub_disconnect_port(up);
d399 1
a399 1
		r = usbd_new_device(&sc->sc_dev, dev->bus, 
a434 54
/*
 * The general mechanism for detaching drivers works as follows: Each
 * driver is responsible for maintaining a reference count on the
 * number of outstanding references to its softc (e.g.  from
 * processing hanging in a read or write).  The detach method of the
 * driver decrements this counter and flags in the softc that the
 * driver is dying and then wakes any sleepers.  It then sleeps on the
 * softc.  Each place that can sleep must maintain the reference
 * count.  When the reference count drops to -1 (0 is the normal value
 * of the reference count) the a wakeup on the softc is performed
 * signaling to the detach waiter that all references are gone.
 */

/*
 * Called from process context when we discover that a port has
 * been disconnected.
 */
void
uhub_disconnect_port(up)
	struct usbd_port *up;
{
	usbd_device_handle dev = up->device;
	char *hubname;
	int i;

	DPRINTFN(3,("uhub_disconnect: up=%p dev=%p port=%d\n", 
		    up, dev, up->portno));

	if (!dev->cdesc) {
		/* Partially attached device, just drop it. */
		dev->bus->devices[dev->address] = 0;
		up->device = 0;
		return;
	}

	hubname = USBDEVNAME(*up->parent->subdevs[0]);
	for (i = 0; dev->subdevs[i]; i++) {
		printf("%s: at %s port %d (addr %d) disconnected\n",
		       USBDEVNAME(*dev->subdevs[i]), hubname,
		       up->portno, dev->address);
		config_detach(dev->subdevs[i], DETACH_FORCE);
	}

	dev->bus->devices[dev->address] = 0;
	up->device = 0;
	usb_free_device(dev);

#if defined(__FreeBSD__)
      device_delete_child(
	  device_get_parent(((struct softc *)dev->softc)->sc_dev), 
	  ((struct softc *)dev->softc)->sc_dev);
#endif
}

d437 1
a437 1
	bdevice *self;
d440 4
d450 8
d469 1
a469 1
	bdevice *self;
d491 1
a491 1
			uhub_disconnect_port(rup);
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d491 1
a491 1
	struct device *self;
d511 1
a511 1
	struct device *self;
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhub.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: uhub.c,v 1.18 1999/06/30 06:44:23 augustss Exp $	*/
a65 1
extern char 	*usbd_error_strs[];
d129 2
a130 2
		DPRINTF(("%s: configuration failed, error=%d(%s)\n",
			 USBDEVNAME(sc->sc_dev), r, usbd_error_strs[r]));
d154 2
a155 2
		DPRINTF(("%s: getting hub descriptor failed, error=%d(%s)\n",
			 USBDEVNAME(sc->sc_dev), r, usbd_error_strs[r]));
d330 2
a331 2
				 "error=%d(%s)\n",
				 r, usbd_error_strs[r]));
d405 1
a405 1
				     "error=%d(%s)\n", r, usbd_error_strs[r]));
d494 8
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d63 2
a64 2
#define DPRINTF(x)	if (usbdebug) printf x
#define DPRINTFN(n,x)	if (usbdebug>(n)) printf x
d85 1
a85 1
USB_DECLARE_DRIVER_NAME(usb, uhub); 
d261 5
d281 11
d557 2
a558 1
DRIVER_MODULE(uhub, usb, uhub_driver, uhub_devclass, usbd_driver_load, 0);
@

