head	1.69;
access;
symbols
	OPENBSD_6_1:1.66.0.6
	OPENBSD_6_1_BASE:1.66
	OPENBSD_6_0:1.66.0.4
	OPENBSD_6_0_BASE:1.66
	OPENBSD_5_9:1.63.0.2
	OPENBSD_5_9_BASE:1.63
	OPENBSD_5_8:1.61.0.4
	OPENBSD_5_8_BASE:1.61
	OPENBSD_5_7:1.60.0.2
	OPENBSD_5_7_BASE:1.60
	OPENBSD_5_6:1.58.0.4
	OPENBSD_5_6_BASE:1.58
	OPENBSD_5_5:1.55.0.4
	OPENBSD_5_5_BASE:1.55
	OPENBSD_5_4:1.53.0.10
	OPENBSD_5_4_BASE:1.53
	OPENBSD_5_3:1.53.0.8
	OPENBSD_5_3_BASE:1.53
	OPENBSD_5_2:1.53.0.6
	OPENBSD_5_2_BASE:1.53
	OPENBSD_5_1_BASE:1.53
	OPENBSD_5_1:1.53.0.4
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.47.0.2
	OPENBSD_4_7_BASE:1.47
	OPENBSD_4_6:1.42.0.8
	OPENBSD_4_6_BASE:1.42
	OPENBSD_4_5:1.42.0.4
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.42.0.2
	OPENBSD_4_4_BASE:1.42
	OPENBSD_4_3:1.41.0.4
	OPENBSD_4_3_BASE:1.41
	OPENBSD_4_2:1.41.0.2
	OPENBSD_4_2_BASE:1.41
	OPENBSD_4_1:1.30.0.2
	OPENBSD_4_1_BASE:1.30
	OPENBSD_4_0:1.29.0.4
	OPENBSD_4_0_BASE:1.29
	OPENBSD_3_9:1.28.0.2
	OPENBSD_3_9_BASE:1.28
	OPENBSD_3_8:1.27.0.6
	OPENBSD_3_8_BASE:1.27
	OPENBSD_3_7:1.27.0.2
	OPENBSD_3_7_BASE:1.27
	OPENBSD_3_6:1.27.0.4
	OPENBSD_3_6_BASE:1.27
	SMP_SYNC_A:1.26
	SMP_SYNC_B:1.26
	OPENBSD_3_5:1.26.0.4
	OPENBSD_3_5_BASE:1.26
	OPENBSD_3_4:1.26.0.2
	OPENBSD_3_4_BASE:1.26
	UBC_SYNC_A:1.24
	OPENBSD_3_3:1.24.0.2
	OPENBSD_3_3_BASE:1.24
	OPENBSD_3_2:1.23.0.2
	OPENBSD_3_2_BASE:1.23
	OPENBSD_3_1:1.15.0.4
	OPENBSD_3_1_BASE:1.15
	UBC_SYNC_B:1.23
	UBC:1.15.0.2
	UBC_BASE:1.15
	OPENBSD_3_0:1.14.0.2
	OPENBSD_3_0_BASE:1.14
	OPENBSD_2_9_BASE:1.13
	OPENBSD_2_9:1.13.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.6.0.2
	SMP_BASE:1.6
	kame_19991208:1.6
	OPENBSD_2_6:1.5.0.2
	OPENBSD_2_6_BASE:1.5;
locks; strict;
comment	@ * @;


1.69
date	2017.09.23.06.12.14;	author mpi;	state Exp;
branches;
next	1.68;
commitid	nsl6DOQRSU0d2qyE;

1.68
date	2017.07.20.16.54.45;	author mpi;	state Exp;
branches;
next	1.67;
commitid	d3E97FsqRudVuIgd;

1.67
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.66;
commitid	6s3MfY9d6ZKdL2Uz;

1.66
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches
	1.66.4.1
	1.66.6.1;
next	1.65;
commitid	zkpZsVIWMnE2TPgn;

1.65
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.64;
commitid	KhGZngmPmcr1rX2x;

1.64
date	2016.02.28.17.57.50;	author stefan;	state Exp;
branches;
next	1.63;
commitid	v9vYvlfXVHFOePGU;

1.63
date	2016.01.09.04.14.42;	author jcs;	state Exp;
branches;
next	1.62;
commitid	KAeCDAijcgEnOtfF;

1.62
date	2016.01.08.15.54.14;	author jcs;	state Exp;
branches;
next	1.61;
commitid	kI4H556ZKYkRQGw5;

1.61
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.60;
commitid	p4LJxGKbi0BU2cG6;

1.60
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.59;
commitid	C5iGb36LQxjM60Q3;

1.59
date	2014.12.11.18.39.27;	author mpi;	state Exp;
branches;
next	1.58;
commitid	L2P5oN9ppxqXZsYS;

1.58
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.57;
commitid	OBNa5kfxQ2UXoiIw;

1.57
date	2014.04.15.09.14.27;	author mpi;	state Exp;
branches;
next	1.56;

1.56
date	2014.03.19.08.59.37;	author mpi;	state Exp;
branches;
next	1.55;

1.55
date	2013.11.19.14.04.07;	author pirofti;	state Exp;
branches;
next	1.54;

1.54
date	2013.11.15.08.17.44;	author pirofti;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.49;

1.49
date	2010.08.02.23.17.34;	author miod;	state Exp;
branches;
next	1.48;

1.48
date	2010.07.26.01.56.27;	author guenther;	state Exp;
branches;
next	1.47;

1.47
date	2009.11.23.11.10.16;	author yuo;	state Exp;
branches;
next	1.46;

1.46
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.45;

1.45
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.42;

1.42
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.11.12.36.52;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.06.11.09.26.55;	author mk;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.31;

1.31
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.01.03.37.24;	author tedu;	state Exp;
branches;
next	1.29;

1.29
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.28;

1.28
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches;
next	1.27;

1.27
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2003.05.19.04.17.53;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.11.03.11.17;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.07.10.21.41.50;	author mickey;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.09.15.06.29;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.16;

1.16
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2001.01.28.09.43.42;	author aaron;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.11.44.23;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.14.22.50.26;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.28.19.37.50;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.27.18.03.55;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.6.2.1
date	2001.05.14.22.26.22;	author niklas;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.07.04.10.43.54;	author niklas;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.6.2.4;

1.6.2.4
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.6.2.5;

1.6.2.5
date	2003.06.07.11.02.33;	author ho;	state Exp;
branches;
next	1.6.2.6;

1.6.2.6
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.15.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2003.05.19.22.24.07;	author tedu;	state Exp;
branches;
next	;

1.66.4.1
date	2017.08.02.16.53.49;	author deraadt;	state Exp;
branches;
next	1.66.4.2;
commitid	NGtkvRLUiFWiLMvA;

1.66.4.2
date	2017.08.02.17.18.22;	author deraadt;	state Exp;
branches;
next	;
commitid	fdRIODIqLUXyFJa4;

1.66.6.1
date	2017.08.01.21.55.02;	author bluhm;	state Exp;
branches;
next	;
commitid	95KQQD8stZphtD17;


desc
@@


1.69
log
@Add dummy FIOASYNC handler.

Without it uhid_do_ioctl() will return EINVAL which will make the
upper layer assume that uhid node do not support non-blocking reads.

Fix a regression introduced by the removal of SIGIO support.

Reported by many, fix tested by Bryan Linton, Micah Muer and Nam Nguyen.
@
text
@/*	$OpenBSD: uhid.c,v 1.68 2017/07/20 16:54:45 mpi Exp $ */
/*	$NetBSD: uhid.c,v 1.57 2003/03/11 16:44:00 augustss Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/signalvar.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/proc.h>
#include <sys/vnode.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbhid.h>

#include <dev/usb/usbdevs.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#include <dev/usb/uhidev.h>

#ifdef UHID_DEBUG
#define DPRINTF(x)	do { if (uhiddebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhiddebug>(n)) printf x; } while (0)
int	uhiddebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct uhid_softc {
	struct uhidev sc_hdev;

	u_char *sc_obuf;

	struct clist sc_q;
	struct selinfo sc_rsel;
	u_char sc_state;		/* driver state */
#define	UHID_ASLP	0x01		/* waiting for device data */

	int sc_refcnt;
};

#define	UHIDUNIT(dev)	(minor(dev))
#define	UHID_CHUNK	128	/* chunk size for read */
#define	UHID_BSIZE	1020	/* buffer size */

void uhid_intr(struct uhidev *, void *, u_int len);

int uhid_do_read(struct uhid_softc *, struct uio *uio, int);
int uhid_do_write(struct uhid_softc *, struct uio *uio, int);
int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,
			 struct proc *);

int uhid_match(struct device *, void *, void *); 
void uhid_attach(struct device *, struct device *, void *); 
int uhid_detach(struct device *, int); 

struct cfdriver uhid_cd = { 
	NULL, "uhid", DV_DULL 
}; 

const struct cfattach uhid_ca = { 
	sizeof(struct uhid_softc), 
	uhid_match, 
	uhid_attach, 
	uhid_detach, 
};

int
uhid_match(struct device *parent, void *match, void *aux)
{
	struct uhidev_attach_arg *uha = aux;

	if (uha->reportid == UHIDEV_CLAIM_ALLREPORTID)
		return (UMATCH_NONE);

	return (UMATCH_IFACECLASS_GENERIC);
}

void
uhid_attach(struct device *parent, struct device *self, void *aux)
{
	struct uhid_softc *sc = (struct uhid_softc *)self;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
	int size, repid;
	void *desc;

	sc->sc_hdev.sc_intr = uhid_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_udev = uha->uaa->device;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_hdev.sc_isize = hid_report_size(desc, size, hid_input, repid);
	sc->sc_hdev.sc_osize = hid_report_size(desc, size, hid_output, repid);
	sc->sc_hdev.sc_fsize = hid_report_size(desc, size, hid_feature, repid);

	printf(": input=%d, output=%d, feature=%d\n",
	    sc->sc_hdev.sc_isize, sc->sc_hdev.sc_osize, sc->sc_hdev.sc_fsize);
}

int
uhid_detach(struct device *self, int flags)
{
	struct uhid_softc *sc = (struct uhid_softc *)self;
	int s;
	int maj, mn;

	DPRINTF(("uhid_detach: sc=%p flags=%d\n", sc, flags));

	if (sc->sc_hdev.sc_state & UHIDEV_OPEN) {
		s = splusb();
		if (--sc->sc_refcnt >= 0) {
			/* Wake everyone */
			wakeup(&sc->sc_q);
			/* Wait for processes to go away. */
			usb_detach_wait(&sc->sc_hdev.sc_dev);
		}
		splx(s);
	}

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == uhidopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit;
	vdevgone(maj, mn, mn, VCHR);

	return (0);
}

void
uhid_intr(struct uhidev *addr, void *data, u_int len)
{
	struct uhid_softc *sc = (struct uhid_softc *)addr;

#ifdef UHID_DEBUG
	if (uhiddebug > 5) {
		u_int32_t i;

		DPRINTF(("uhid_intr: data ="));
		for (i = 0; i < len; i++)
			DPRINTF((" %02x", ((u_char *)data)[i]));
		DPRINTF(("\n"));
	}
#endif

	(void)b_to_q(data, len, &sc->sc_q);

	if (sc->sc_state & UHID_ASLP) {
		sc->sc_state &= ~UHID_ASLP;
		DPRINTFN(5, ("uhid_intr: waking %p\n", &sc->sc_q));
		wakeup(&sc->sc_q);
	}
	selwakeup(&sc->sc_rsel);
}

int
uhidopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct uhid_softc *sc;
	int error;

	if (UHIDUNIT(dev) >= uhid_cd.cd_ndevs)
		return (ENXIO);
	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];
	if (sc == NULL)
		return (ENXIO);

	DPRINTF(("uhidopen: sc=%p\n", sc));

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return (ENXIO);

	error = uhidev_open(&sc->sc_hdev);
	if (error)
		return (error);

	clalloc(&sc->sc_q, UHID_BSIZE, 0);

	sc->sc_obuf = malloc(sc->sc_hdev.sc_osize, M_USBDEV, M_WAITOK);

	return (0);
}

int
uhidclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct uhid_softc *sc;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	DPRINTF(("uhidclose: sc=%p\n", sc));

	clfree(&sc->sc_q);
	free(sc->sc_obuf, M_USBDEV, sc->sc_hdev.sc_osize);
	uhidev_close(&sc->sc_hdev);

	return (0);
}

int
uhid_do_read(struct uhid_softc *sc, struct uio *uio, int flag)
{
	int s;
	int error = 0;
	size_t length;
	u_char buffer[UHID_CHUNK];

	DPRINTFN(1, ("uhidread\n"));

	s = splusb();
	while (sc->sc_q.c_cc == 0) {
		if (flag & IO_NDELAY) {
			splx(s);
			return (EWOULDBLOCK);
		}
		sc->sc_state |= UHID_ASLP;
		DPRINTFN(5, ("uhidread: sleep on %p\n", &sc->sc_q));
		error = tsleep(&sc->sc_q, PZERO | PCATCH, "uhidrea", 0);
		DPRINTFN(5, ("uhidread: woke, error=%d\n", error));
		if (usbd_is_dying(sc->sc_hdev.sc_udev))
			error = EIO;
		if (error) {
			sc->sc_state &= ~UHID_ASLP;
			break;
		}
	}
	splx(s);

	/* Transfer as many chunks as possible. */
	while (sc->sc_q.c_cc > 0 && uio->uio_resid > 0 && !error) {
		length = ulmin(sc->sc_q.c_cc, uio->uio_resid);
		if (length > sizeof(buffer))
			length = sizeof(buffer);

		/* Remove a small chunk from the input queue. */
		(void) q_to_b(&sc->sc_q, buffer, length);
		DPRINTFN(5, ("uhidread: got %zu chars\n", length));

		/* Copy the data to the user process. */
		if ((error = uiomove(buffer, length, uio)) != 0)
			break;
	}

	return (error);
}

int
uhidread(dev_t dev, struct uio *uio, int flag)
{
	struct uhid_softc *sc;
	int error;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	sc->sc_refcnt++;
	error = uhid_do_read(sc, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_hdev.sc_dev);
	return (error);
}

int
uhid_do_write(struct uhid_softc *sc, struct uio *uio, int flag)
{
	int error;
	int size;

	DPRINTFN(1, ("uhidwrite\n"));

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return (EIO);

	size = sc->sc_hdev.sc_osize;
	error = 0;
	if (uio->uio_resid != size)
		return (EINVAL);
	error = uiomove(sc->sc_obuf, size, uio);
	if (!error) {
		if (uhidev_set_report(sc->sc_hdev.sc_parent,
		    UHID_OUTPUT_REPORT, sc->sc_hdev.sc_report_id, sc->sc_obuf,
		    size) != size)
			error = EIO;
	}

	return (error);
}

int
uhidwrite(dev_t dev, struct uio *uio, int flag)
{
	struct uhid_softc *sc;
	int error;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	sc->sc_refcnt++;
	error = uhid_do_write(sc, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_hdev.sc_dev);
	return (error);
}

int
uhid_do_ioctl(struct uhid_softc *sc, u_long cmd, caddr_t addr,
	      int flag, struct proc *p)
{
	int rc;

	DPRINTFN(2, ("uhidioctl: cmd=%lx\n", cmd));

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return (EIO);

	switch (cmd) {
	case FIONBIO:
	case FIOASYNC:
		/* All handled in the upper FS layer. */
		break;

	case USB_GET_DEVICEINFO:
		usbd_fill_deviceinfo(sc->sc_hdev.sc_udev,
				     (struct usb_device_info *)addr, 1);
		break;

	case USB_GET_REPORT_DESC:
	case USB_GET_REPORT:
	case USB_SET_REPORT:
	case USB_GET_REPORT_ID:
	default:
		rc = uhidev_ioctl(&sc->sc_hdev, cmd, addr, flag, p);
		if (rc == -1)
			rc = EINVAL;
		return rc;
	}
	return (0);
}

int
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	struct uhid_softc *sc;
	int error;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	sc->sc_refcnt++;
	error = uhid_do_ioctl(sc, cmd, addr, flag, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_hdev.sc_dev);
	return (error);
}

int
uhidpoll(dev_t dev, int events, struct proc *p)
{
	struct uhid_softc *sc;
	int revents = 0;
	int s;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return (POLLERR);

	s = splusb();
	if (events & (POLLOUT | POLLWRNORM))
		revents |= events & (POLLOUT | POLLWRNORM);
	if (events & (POLLIN | POLLRDNORM)) {
		if (sc->sc_q.c_cc > 0)
			revents |= events & (POLLIN | POLLRDNORM);
		else
			selrecord(p, &sc->sc_rsel);
	}

	splx(s);
	return (revents);
}

void filt_uhidrdetach(struct knote *);
int filt_uhidread(struct knote *, long);
int uhidkqfilter(dev_t, struct knote *);

void
filt_uhidrdetach(struct knote *kn)
{
	struct uhid_softc *sc = (void *)kn->kn_hook;
	int s;

	s = splusb();
	SLIST_REMOVE(&sc->sc_rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_uhidread(struct knote *kn, long hint)
{
	struct uhid_softc *sc = (void *)kn->kn_hook;

	kn->kn_data = sc->sc_q.c_cc;
	return (kn->kn_data > 0);
}

struct filterops uhidread_filtops =
	{ 1, NULL, filt_uhidrdetach, filt_uhidread };

struct filterops uhid_seltrue_filtops =
	{ 1, NULL, filt_uhidrdetach, filt_seltrue };

int
uhidkqfilter(dev_t dev, struct knote *kn)
{
	struct uhid_softc *sc;
	struct klist *klist;
	int s;

	sc = uhid_cd.cd_devs[UHIDUNIT(dev)];

	if (usbd_is_dying(sc->sc_hdev.sc_udev))
		return (EIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_rsel.si_note;
		kn->kn_fop = &uhidread_filtops;
		break;

	case EVFILT_WRITE:
		klist = &sc->sc_rsel.si_note;
		kn->kn_fop = &uhid_seltrue_filtops;
		break;

	default:
		return (EINVAL);
	}

	kn->kn_hook = (void *)sc;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}
@


1.68
log
@Remove SIGIO support.  Base tools do not implement it and ports relying
on libusbhid, generally via SDL, shouldn't do it either since it's not
portable.

Suggested by deraadt@@ after Ilja van Sprundel reported an issue with a
stale struct proc pointer in similar code.

ok kettenis@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.67 2017/04/08 02:57:25 deraadt Exp $ */
d362 1
@


1.67
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.66 2016/05/24 05:35:01 mpi Exp $ */
a77 1
	struct process *sc_async;	/* process that wants SIGIO */
a199 4
	if (sc->sc_async != NULL) {
		DPRINTFN(3, ("uhid_intr: sending SIGIO %p\n", sc->sc_async));
		prsignal(sc->sc_async, SIGIO);
	}
a225 1
	sc->sc_async = NULL;
a240 1
	sc->sc_async = NULL;
a362 18
		break;

	case FIOASYNC:
		if (*(int *)addr) {
			if (sc->sc_async != NULL)
				return (EBUSY);
			sc->sc_async = p->p_p;
			DPRINTF(("uhid_do_ioctl: FIOASYNC %p\n", p));
		} else
			sc->sc_async = NULL;
		break;

	/* XXX this is not the most general solution. */
	case TIOCSPGRP:
		if (sc->sc_async == NULL)
			return (EINVAL);
		if (*(int *)addr != sc->sc_async->ps_pgid)
			return (EPERM);
@


1.66
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.65 2016/03/03 18:13:24 stefan Exp $ */
d246 1
a246 1
	free(sc->sc_obuf, M_USBDEV, 0);
@


1.66.4.1
log
@Remove SIGIO support.  Base tools do not implement it and ports relying
on libusbhid, generally via SDL, shouldn't do it either since it's not
portable.
Suggested by deraadt@@ after Ilja van Sprundel reported an issue with a
stale struct proc pointer in similar code.
errata 029
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.66 2016/05/24 05:35:01 mpi Exp $ */
d78 1
d201 4
d231 1
d370 18
@


1.66.4.2
log
@Remove SIGIO support.  Base tools do not implement it and ports relying
on libusbhid, generally via SDL, shouldn't do it either since it's not
portable.
Suggested by deraadt@@ after Ilja van Sprundel reported an issue with a
stale struct proc pointer in similar code.
errata 029
(missed a piece)
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.66.4.1 2017/08/02 16:53:49 deraadt Exp $ */
d241 1
@


1.66.6.1
log
@Remove SIGIO support.  Base tools do not implement it and ports relying
on libusbhid, generally via SDL, shouldn't do it either since it's not
portable.
Suggested by deraadt@@ after Ilja van Sprundel reported an issue with a
stale struct proc pointer in similar code.
errata 015
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.66 2016/05/24 05:35:01 mpi Exp $ */
d78 1
d201 4
d231 1
d247 1
d370 18
@


1.65
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.64 2016/02/28 17:57:50 stefan Exp $ */
d360 1
a360 2
	usbd_status err;
	int rc, size;
a393 11

        case USB_GET_STRING_DESC:
	    {
		struct usb_string_desc *si = (struct usb_string_desc *)addr;
		err = usbd_get_string_desc(sc->sc_hdev.sc_udev,
			si->usd_string_index,
			si->usd_language_id, &si->usd_desc, &size);
		if (err)
			return (EINVAL);
		break;
	    }
@


1.64
log
@Remove USB_SET_IMMED ioctl and corresponding code and manpage bits.
Nothing uses it.

suggested by and ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.63 2016/01/09 04:14:42 jcs Exp $ */
d284 1
a284 1
		length = min(sc->sc_q.c_cc, uio->uio_resid);
d290 1
a290 1
		DPRINTFN(5, ("uhidread: got %lu chars\n", (u_long)length));
d293 1
a293 1
		if ((error = uiomovei(buffer, length, uio)) != 0)
d330 1
a330 1
	error = uiomovei(sc->sc_obuf, size, uio);
@


1.63
log
@revert manual additions of hid.h now that usbhid.h brings it in
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.62 2016/01/08 15:54:14 jcs Exp $ */
a80 1
#define UHID_IMMED	0x02		/* return read data immediately */
a230 1
	sc->sc_state &= ~UHID_IMMED;
a261 8
	if (sc->sc_state & UHID_IMMED) {
		DPRINTFN(1, ("uhidread immed\n"));
		if (uhidev_get_report(sc->sc_hdev.sc_parent,
		    UHID_INPUT_REPORT, sc->sc_hdev.sc_report_id, buffer,
		    sc->sc_hdev.sc_isize) != sc->sc_hdev.sc_isize)
			return (EIO);
		return (uiomovei(buffer, sc->sc_hdev.sc_isize, uio));
	}
a359 1
	u_char buffer[UHID_CHUNK];
a388 12
		break;

	case USB_SET_IMMED:
		if (*(int *)addr) {
			if (uhidev_get_report(sc->sc_hdev.sc_parent,
			    UHID_INPUT_REPORT, sc->sc_hdev.sc_report_id, buffer,
			    sc->sc_hdev.sc_isize) != sc->sc_hdev.sc_isize)
				return (EOPNOTSUPP);

			sc->sc_state |=  UHID_IMMED;
		} else
			sc->sc_state &= ~UHID_IMMED;
@


1.62
log
@Move HID support files out of dev/usb into new dev/hid directory

These files aren't USB-specific and were used by the previous
Bluetooth implementation, and will be used by the upcoming
HID-over-i2C implementation

ok deraadt
previous version ok kettenis and mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.61 2015/03/14 03:38:50 jsg Exp $ */
a60 2

#include <dev/hid/hid.h>
@


1.61
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.60 2015/02/10 21:56:09 miod Exp $ */
a58 1
#include <dev/usb/hid.h>
d61 2
@


1.60
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.59 2014/12/11 18:39:27 mpi Exp $ */
a59 1
#include <dev/usb/usb_quirks.h>
@


1.59
log
@Change uhidev(4) set/get report functions in various way.

Always pass the parent uhidev(4) descriptor corresponding to the single
USB device with multiple reportIDs instead of a child.

Make uhidev_get_report() aware of non NUL reportID by prepending a byte
to the given buffer, just like uhidev_set_report{,async}() already do.

Return the number of bytes written or read upon success and -1 otherwise.
This allow callers to deal with short reads without having do mess with
xfer error codes madness.

Reviewed and tested by David Higgs.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.58 2014/07/12 18:48:52 tedu Exp $ */
d272 1
a272 1
		return (uiomove(buffer, sc->sc_hdev.sc_isize, uio));
d305 1
a305 1
		if ((error = uiomove(buffer, length, uio)) != 0)
d342 1
a342 1
	error = uiomove(sc->sc_obuf, size, uio);
@


1.58
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.57 2014/04/15 09:14:27 mpi Exp $ */
a261 1
	int extra;
a263 1
	usbd_status err;
d268 3
a270 5
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
		    sc->sc_hdev.sc_report_id, buffer,
		    sc->sc_hdev.sc_isize + extra);
		if (err)
d272 1
a272 1
		return (uiomove(buffer+extra, sc->sc_hdev.sc_isize, uio));
a331 1
	usbd_status err;
d344 3
a346 3
		err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
		    sc->sc_hdev.sc_report_id, sc->sc_obuf, size);
		if (err)
a372 1
	int size, extra;
d374 1
a374 1
	int rc;
d406 3
a408 5
			extra = sc->sc_hdev.sc_report_id != 0;
			err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
			    sc->sc_hdev.sc_report_id, buffer,
			    sc->sc_hdev.sc_isize + extra);
			if (err)
@


1.57
log
@Modify the uhidev_*_report() methods to always take a report ID argument
instead of using the default, per-driver, one.  This is a step to move
away from the 1 report ID <-> 1 driver design which is no longer true
since the addition of upd(4).

ok andre@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.56 2014/03/19 08:59:37 mpi Exp $ */
d250 1
a250 1
	free(sc->sc_obuf, M_USBDEV);
@


1.56
log
@Add a temporary hack to let a subdriver claim all the reportIDs of
a device.  This should be removed once all the drivers attaching to
uhidev(4) are converted.

ok andre@@, sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.55 2013/11/19 14:04:07 pirofti Exp $ */
d272 2
a273 1
					buffer, sc->sc_hdev.sc_isize + extra);
d350 1
a350 1
					sc->sc_obuf, size);
d414 2
a415 1
			    buffer, sc->sc_hdev.sc_isize + extra);
@


1.55
log
@Kill matchlvl usage throughout the usb stack.

Allows us to move forward on cleaning.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.54 2013/11/15 08:17:44 pirofti Exp $ */
d117 1
a117 3
#ifdef UHID_DEBUG
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)aux;
#endif
d119 2
a120 1
	DPRINTF(("uhid_match: report=%d\n", uha->reportid));
@


1.54
log
@Clean-up the HID environment.


This set of drivers were very very dirty.

i/ Clean-up the match/attach multi-casting hackjob
	- stop casting aux to every attach arg in existance
	- be consistent about casting it only to uhidev_attach_arg
	- fetch the usb_attach_arg from above where needed

ii/ Sort out the activate routines
	- leave the deactivation to the parent (uhidev(4))
	- ditch the sc_dying flag in favour of usbd_is_dying()

iii/ Get closer to keeping all the usb hid information in the uhidev
     structure (one uhidev per reportID)
	- store the usbd_device in the uhidev
	- use it consistently instead of always peaking at the parent's
 	  soft state

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.53 2011/07/03 15:47:17 matthew Exp $ */
d117 1
d119 1
a122 2
	if (uha->matchlvl)
		return (uha->matchlvl);
@


1.53
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.52 2011/07/02 22:20:08 nicm Exp $ */
a85 1
	u_char sc_dying;
a101 1
int uhid_activate(struct device *, int); 
a111 1
	uhid_activate, 
d117 1
a117 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d130 1
a130 2
	struct usb_attach_arg *uaa = aux;
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
d136 1
a149 13
uhid_activate(struct device *self, int act)
{
	struct uhid_softc *sc = (struct uhid_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		sc->sc_dying = 1;
		break;
	}
	return (0);
}

int
d225 1
a225 1
	if (sc->sc_dying)
d289 1
a289 1
		if (sc->sc_dying)
d340 1
a340 1
	if (sc->sc_dying)
d384 1
a384 1
	if (sc->sc_dying)
d424 1
a424 1
		usbd_fill_deviceinfo(sc->sc_hdev.sc_parent->sc_udev,
d431 1
a431 1
		err = usbd_get_string_desc(sc->sc_hdev.sc_parent->sc_udev,
d476 1
a476 1
	if (sc->sc_dying)
d532 1
a532 1
	if (sc->sc_dying)
@


1.52
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.51 2011/01/25 20:03:36 jakemsr Exp $ */
a158 3
	case DVACT_ACTIVATE:
		break;

@


1.51
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.50 2010/09/24 08:33:59 yuo Exp $ */
d567 1
a567 1
		return (1);
@


1.50
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.49 2010/08/02 23:17:34 miod Exp $ */
a196 6

#if 0
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH,
			   sc->sc_hdev.sc_parent->sc_udev,
			   &sc->sc_hdev.sc_dev);
#endif
@


1.49
log
@Handle USB_GET_REPORT, USB_GET_REPORT_DESC, USB_GET_REPORT_ID and
USB_SET_REPORT ioctls in ukbd and ums.
This allows usbhidctl to be used on these devices e.g. to dump the report
descriptor of troublesome models.
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.48 2010/07/26 01:56:27 guenther Exp $ */
a176 2

	sc->sc_dying = 1;
@


1.48
log
@Correct the links between threads, processes, pgrps, and sessions,
so that the process-level stuff is to/from struct process and not
struct proc.  This fixes a bunch of problem cases in rthreads.
Based on earlier work by blambert and myself, but mostly written
at c2k10.

Tested by many: deraadt, sthen, krw, ray, and in snapshots
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.47 2009/11/23 11:10:16 yuo Exp $ */
a75 4
	int sc_isize;
	int sc_osize;
	int sc_fsize;

d145 3
a147 3
	sc->sc_isize = hid_report_size(desc, size, hid_input,   repid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  repid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, repid);
d150 1
a150 1
	       sc->sc_isize, sc->sc_osize, sc->sc_fsize);
d262 1
a262 1
	sc->sc_obuf = malloc(sc->sc_osize, M_USBDEV, M_WAITOK);
d301 1
a301 1
					buffer, sc->sc_isize + extra);
d304 1
a304 1
		return (uiomove(buffer+extra, sc->sc_isize, uio));
d371 1
a371 1
	size = sc->sc_osize;
a404 2
	struct usb_ctl_report_desc *rd;
	struct usb_ctl_report *re;
d408 1
a408 1
	void *desc;
a437 8
	case USB_GET_REPORT_DESC:
		uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
		rd = (struct usb_ctl_report_desc *)addr;
		size = min(size, sizeof rd->ucrd_data);
		rd->ucrd_size = size;
		memcpy(rd->ucrd_data, desc, size);
		break;

d442 1
a442 1
						buffer, sc->sc_isize + extra);
a450 49
	case USB_GET_REPORT:
		re = (struct usb_ctl_report *)addr;
		switch (re->ucr_report) {
		case UHID_INPUT_REPORT:
			size = sc->sc_isize;
			break;
		case UHID_OUTPUT_REPORT:
			size = sc->sc_osize;
			break;
		case UHID_FEATURE_REPORT:
			size = sc->sc_fsize;
			break;
		default:
			return (EINVAL);
		}
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size + extra);
		if (extra)
			memcpy(re->ucr_data, re->ucr_data+1, size);
		if (err)
			return (EIO);
		break;

	case USB_SET_REPORT:
		re = (struct usb_ctl_report *)addr;
		switch (re->ucr_report) {
		case UHID_INPUT_REPORT:
			size = sc->sc_isize;
			break;
		case UHID_OUTPUT_REPORT:
			size = sc->sc_osize;
			break;
		case UHID_FEATURE_REPORT:
			size = sc->sc_fsize;
			break;
		default:
			return (EINVAL);
		}
		err = uhidev_set_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size);
		if (err)
			return (EIO);
		break;

	case USB_GET_REPORT_ID:
		*(int *)addr = sc->sc_hdev.sc_report_id;
		break;

d467 4
d472 4
a475 1
		return (EINVAL);
@


1.47
log
@add USB_GET_DEVICEINFO and USB_GET_STRING_DESC ioctl to the uhid(4).

ok jsg@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.46 2009/11/09 17:53:39 nicm Exp $ */
d84 4
a87 4
	struct proc *sc_async;	/* process that wants SIGIO */
	u_char sc_state;	/* driver state */
#define	UHID_ASLP	0x01	/* waiting for device data */
#define UHID_IMMED	0x02	/* return read data immediately */
d239 1
a239 1
		psignal(sc->sc_async, SIGIO);
d430 1
a430 1
			sc->sc_async = p;
d440 1
a440 1
		if (*(int *)addr != sc->sc_async->p_pgid)
@


1.46
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.45 2009/10/31 06:40:17 deraadt Exp $ */
d513 16
@


1.45
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.44 2009/10/13 19:33:19 pirofti Exp $ */
a236 1
	KNOTE(&sc->sc_rsel.si_note, 0);
@


1.44
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.43 2009/07/19 08:16:06 blambert Exp $ */
d237 1
@


1.43
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.42 2008/06/26 05:42:18 ray Exp $ */
d107 1
a107 1
int uhid_activate(struct device *, enum devact); 
d158 1
a158 1
uhid_activate(struct device *self, enum devact act)
@


1.42
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.41 2007/06/14 10:11:15 mbalmer Exp $ */
d264 2
a265 4
	if (clalloc(&sc->sc_q, UHID_BSIZE, 0) == -1) {
		uhidev_close(&sc->sc_hdev);
		return (ENOMEM);
	}
@


1.41
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.40 2007/06/12 16:26:36 mbalmer Exp $ */
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.40
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.39 2007/06/11 16:30:31 mbalmer Exp $ */
d111 16
a126 1
USB_DECLARE_DRIVER(uhid);
@


1.39
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.38 2007/06/11 12:36:52 mbalmer Exp $ */
d150 1
a150 1
uhid_activate(device_ptr_t self, enum devact act)
@


1.38
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.37 2007/06/11 10:58:21 mbalmer Exp $ */
d91 1
a91 1
	usb_proc_ptr sc_async;	/* process that wants SIGIO */
d109 1
a109 1
			 usb_proc_ptr);
d236 1
a236 1
uhidopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d268 1
a268 1
uhidclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d401 1
a401 1
	      int flag, usb_proc_ptr p)
d515 1
a515 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d530 1
a530 1
uhidpoll(dev_t dev, int events, usb_proc_ptr p)
@


1.37
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.36 2007/06/11 09:26:55 mk Exp $ */
d241 5
a245 1
	USB_GET_SC_OPEN(uhid, UHIDUNIT(dev), sc);
@


1.36
log
@More USB cleanup:  In usb_port.h, get rid of the sel_klist #define
(which was there twice without gcc complaining) and update all uses of
it.

ok jsg mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.35 2007/06/10 10:53:48 mbalmer Exp $ */
d268 1
a268 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
d344 1
a344 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
d386 1
a386 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
d516 1
a516 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
d532 1
a532 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
d588 1
a588 1
	USB_GET_SC(uhid, UHIDUNIT(dev), sc);
@


1.35
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.34 2007/06/05 08:43:55 mbalmer Exp $ */
d562 1
a562 1
	SLIST_REMOVE(&sc->sc_rsel.sel_klist, kn, knote, kn_selnext);
d595 1
a595 1
		klist = &sc->sc_rsel.sel_klist;
d600 1
a600 1
		klist = &sc->sc_rsel.sel_klist;
@


1.34
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.33 2007/06/04 10:34:04 mbalmer Exp $ */
d182 1
a182 1
			usb_detach_wait(USBDEV(sc->sc_hdev.sc_dev));
d199 1
a199 1
			   USBDEV(sc->sc_hdev.sc_dev));
d349 1
a349 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d391 1
a391 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d521 1
a521 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
@


1.33
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.32 2007/05/27 04:00:25 jsg Exp $ */
d104 1
a104 1
Static void uhid_intr(struct uhidev *, void *, u_int len);
d106 3
a108 3
Static int uhid_do_read(struct uhid_softc *, struct uio *uio, int);
Static int uhid_do_write(struct uhid_softc *, struct uio *uio, int);
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,
d551 2
a552 2
Static void filt_uhidrdetach(struct knote *);
Static int filt_uhidread(struct knote *, long);
d555 1
a555 1
Static void
d566 1
a566 1
Static int
d575 1
a575 1
Static struct filterops uhidread_filtops =
d578 1
a578 1
Static struct filterops uhid_seltrue_filtops =
@


1.32
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.31 2007/05/21 05:40:28 jsg Exp $ */
a103 15
#if defined(__NetBSD__)
dev_type_open(uhidopen);
dev_type_close(uhidclose);
dev_type_read(uhidread);
dev_type_write(uhidwrite);
dev_type_ioctl(uhidioctl);
dev_type_poll(uhidpoll);
dev_type_kqfilter(uhidkqfilter);

const struct cdevsw uhid_cdevsw = {
	uhidopen, uhidclose, uhidread, uhidwrite, uhidioctl,
	nostop, notty, uhidpoll, nommap, uhidkqfilter,
};
#endif

a187 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uhid_cdevsw);
#elif defined(__OpenBSD__)
a190 1
#endif
@


1.31
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.30 2006/11/01 03:37:24 tedu Exp $ */
d128 2
a129 1
USB_MATCH(uhid)
d131 1
a131 1
	USB_MATCH_START(uhid, uaa);
d141 2
a142 1
USB_ATTACH(uhid)
d144 2
a145 1
	USB_ATTACH_START(uhid, sc, uaa);
a161 2

	USB_ATTACH_SUCCESS_RETURN;
d180 2
a181 1
USB_DETACH(uhid)
d183 1
a183 1
	USB_DETACH_START(uhid, sc);
@


1.30
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.29 2006/06/23 06:27:11 miod Exp $ */
d72 2
a73 2
#define DPRINTF(x)	do { if (uhiddebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (uhiddebug>(n)) logprintf x; } while (0)
@


1.29
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.28 2005/11/21 18:16:43 millert Exp $ */
d552 1
a552 1
		return (EIO);
@


1.28
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.27 2004/07/08 22:18:44 deraadt Exp $ */
d170 1
a170 1
		return (EOPNOTSUPP);
@


1.27
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.26 2003/06/27 16:57:14 nate Exp $ */
d55 1
a55 1
#include <sys/select.h>
@


1.26
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.25 2003/05/19 04:17:53 nate Exp $ */
d72 2
a73 2
#define DPRINTF(x)	if (uhiddebug) logprintf x
#define DPRINTFN(n,x)	if (uhiddebug>(n)) logprintf x
@


1.25
log
@fix documentation links from netbsd
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.24 2002/11/11 02:32:32 nate Exp $ */
/*	$NetBSD: uhid.c,v 1.55 2002/10/23 09:14:00 jdolecek Exp $	*/
d566 66
@


1.24
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.23 2002/07/25 04:07:33 nate Exp $ */
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/devclass/hid1_1.pdf
@


1.23
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.22 2002/07/25 02:18:10 nate Exp $ */
/*	$NetBSD: uhid.c,v 1.52 2002/07/11 21:14:29 augustss Exp $	*/
d105 12
a116 1
cdev_decl(uhid);
a170 1
		break;
d201 3
d207 1
@


1.22
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.21 2002/07/11 03:11:17 nate Exp $ */
/*	$NetBSD: uhid.c,v 1.51 2002/03/17 18:02:53 augustss Exp $	*/
@


1.21
log
@Please be more portable in usb land
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.20 2002/07/10 21:41:50 mickey Exp $ */
d135 1
a135 1
	
d200 1
a200 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, 
d216 1
a216 1
		
d225 1
a225 1
		
d364 1
a364 1
	
@


1.20
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.19 2002/05/09 15:06:29 nate Exp $ */
d103 4
@


1.19
log
@Sync hid stuff including ukbd, ums, and uhid with NetBSD
This adds a uhidev device which can be thought of as something like a
uhid bus.  It allows more than one ukbd, ums, or uhid to attach to the same
device instance.  This functionality is found on many of the newer keyboards
that have extra buttons.  (The extra buttons show up as uhid device(s)).

Tested by me on i386, dale on macppc, and jason on sparc64
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.18 2002/05/07 18:29:18 nate Exp $ */
a102 2

cdev_decl(uhid);
@


1.18
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 3
/*	$OpenBSD: uhid.c,v 1.16 2002/05/02 20:08:04 nate Exp $ */
/*	$NetBSD: uhid.c,v 1.45 2001/10/26 17:58:21 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhid.c,v 1.22 1999/11/17 22:33:43 n_hibma Exp $	*/
a49 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a51 7
#elif defined(__FreeBSD__)
#include <sys/ioccom.h>
#include <sys/filio.h>
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/ioccom.h>
#endif
d69 1
a69 2
/* Report descriptor for broken Wacom Graphire */
#include <dev/usb/ugraphire_rdesc.h>
d81 1
a81 5
	USBBASEDEVICE sc_dev;			/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;
a85 3
	u_int8_t sc_iid;
	u_int8_t sc_oid;
	u_int8_t sc_fid;
a86 1
	u_char *sc_ibuf;
a88 3
	void *sc_repdesc;
	int sc_repdesc_size;

d91 1
a91 1
	struct proc *sc_async;	/* process that wants SIGIO */
d93 2
a94 4
#define	UHID_OPEN	0x01	/* device is open */
#define	UHID_ASLP	0x02	/* waiting for device data */
#define UHID_NEEDCLEAR	0x04	/* needs clearing endpoint stall */
#define UHID_IMMED	0x08	/* return read data immediately */
a103 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a104 27
#elif defined(__FreeBSD__)
d_open_t	uhidopen;
d_close_t	uhidclose;
d_read_t	uhidread;
d_write_t	uhidwrite;
d_ioctl_t	uhidioctl;
d_poll_t	uhidpoll;

#define		UHID_CDEV_MAJOR 122

Static struct cdevsw uhid_cdevsw = {
	/* open */	uhidopen,
	/* close */	uhidclose,
	/* read */	uhidread,
	/* write */	uhidwrite,
	/* ioctl */	uhidioctl,
	/* poll */	uhidpoll,
	/* mmap */	nommap,
	/* strategy */	nostrategy,
	/* name */	"uhid",
	/* maj */	UHID_CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
	/* bmaj */	-1
};
#endif
d106 1
a106 1
Static void uhid_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d110 2
a111 1
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,struct proc*);
d118 6
a123 9
	usb_interface_descriptor_t *id;
	
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
		return (UMATCH_NONE);
	if (uaa->matchlvl)
		return (uaa->matchlvl);
d130 2
a131 4
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int size;
a132 58
	usbd_status err;
	char devinfo[1024];
	
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);

	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}

	DPRINTFN(10,("uhid_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}

	sc->sc_ep_addr = ed->bEndpointAddress;

	if (uaa->vendor == USB_VENDOR_WACOM &&
	    uaa->product == USB_PRODUCT_WACOM_GRAPHIRE /* &&
	    uaa->revision == 0x???? */) { /* XXX should use revision */
		/* The report descriptor for the Wacom Graphire is broken. */
		size = sizeof uhid_graphire_report_descr;
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL)
			err = USBD_NOMEM;
		else {
			err = USBD_NORMAL_COMPLETION;
			memcpy(desc, uhid_graphire_report_descr, size);
		}
	} else {
		desc = NULL;
		err = usbd_read_report_desc(uaa->iface, &desc, &size,M_USBDEV);
	}
	if (err) {
		printf("%s: no report descriptor\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
d134 9
a142 1
	(void)usbd_set_idle(iface, 0, 0);
d144 2
a145 20
	sc->sc_isize = hid_report_size(desc, size, hid_input,   &sc->sc_iid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  &sc->sc_oid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, &sc->sc_fid);

	sc->sc_repdesc = desc;
	sc->sc_repdesc_size = size;

#ifdef __FreeBSD__
	{
		static int global_init_done = 0;

		if (!global_init_done) {
			cdevsw_add(&uhid_cdevsw);
			global_init_done = 1;
		}
	}
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
a149 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a165 1
#endif
a170 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a173 3
#else
	DPRINTF(("uhid_detach: sc=%p\n", sc));
#endif
a175 2
	if (sc->sc_intrpipe != NULL)
		usbd_abort_pipe(sc->sc_intrpipe);
d177 1
a177 1
	if (sc->sc_state & UHID_OPEN) {
d183 1
a183 1
			usb_detach_wait(USBDEV(sc->sc_dev));
a187 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d196 5
a200 2
#elif defined(__FreeBSD__)
	/* XXX not implemented yet */
a202 6
	if (sc->sc_repdesc)
		free(sc->sc_repdesc, M_USBDEV);

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d207 1
a207 1
uhid_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d209 1
a209 1
	struct uhid_softc *sc = addr;
d213 1
a213 1
		u_int32_t cc, i;
a214 2
		usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);
		DPRINTF(("uhid_intr: status=%d cc=%d\n", status, cc));
d216 2
a217 2
		for (i = 0; i < cc; i++)
			DPRINTF((" %02x", sc->sc_ibuf[i]));
d222 1
a222 10
	if (status == USBD_CANCELLED)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("uhid_intr: status=%d\n", status));
		sc->sc_state |= UHID_NEEDCLEAR;
		return;
	}

	(void) b_to_q(sc->sc_ibuf, sc->sc_isize, &sc->sc_q);
d237 1
a237 1
uhidopen(dev_t dev, int flag, int mode, struct proc *p)
d240 1
a240 1
	usbd_status err;
d249 3
a251 3
	if (sc->sc_state & UHID_OPEN)
		return (EBUSY);
	sc->sc_state |= UHID_OPEN;
d254 1
a254 1
		sc->sc_state &= ~UHID_OPEN;
a256 2

	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
a257 14

	/* Set up interrupt pipe. */
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, 
		  sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
		DPRINTF(("uhidopen: usbd_open_pipe_intr failed, "
			 "error=%d\n",err));
		free(sc->sc_ibuf, M_USBDEV);
		free(sc->sc_obuf, M_USBDEV);
		sc->sc_state &= ~UHID_OPEN;
		return (EIO);
	}

d259 1
a259 2

	sc->sc_async = 0;
d265 1
a265 1
uhidclose(dev_t dev, int flag, int mode, struct proc *p)
a272 5
	/* Disable interrupts. */
	usbd_abort_pipe(sc->sc_intrpipe);
	usbd_close_pipe(sc->sc_intrpipe);
	sc->sc_intrpipe = 0;

a273 2

	free(sc->sc_ibuf, M_USBDEV);
d275 2
a276 4

	sc->sc_state &= ~UHID_OPEN;

	sc->sc_async = 0;
d286 1
d294 3
a296 3
		
		err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
				    sc->sc_iid, buffer, sc->sc_isize);
d299 1
a299 1
		return (uiomove(buffer, sc->sc_isize, uio));
a317 5
		if (sc->sc_state & UHID_NEEDCLEAR) {
			DPRINTFN(-1,("uhidread: clearing stall\n"));
			sc->sc_state &= ~UHID_NEEDCLEAR;
			usbd_clear_endpoint_stall(sc->sc_intrpipe);
		}
d350 1
a350 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d372 2
a373 6
		if (sc->sc_oid)
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  sc->sc_obuf[0], sc->sc_obuf+1, size-1);
		else
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  0, sc->sc_obuf, size);
d392 1
a392 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d398 1
a398 1
	      int flag, struct proc *p)
d402 2
a403 1
	int size, id;
d405 1
d436 1
d438 1
a438 1
		size = min(sc->sc_repdesc_size, sizeof rd->ucrd_data);
d440 1
a440 1
		memcpy(rd->ucrd_data, sc->sc_repdesc, size);
d445 3
a447 3
			/* XXX should read into ibuf, but does it matter? */
			err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
				  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);
a460 1
			id = sc->sc_iid;
a463 1
			id = sc->sc_oid;
a466 1
			id = sc->sc_fid;
d471 5
a475 2
		err = usbd_get_report(sc->sc_iface, re->ucr_report, id,
			  re->ucr_data, size);
a484 1
			id = sc->sc_iid;
a487 1
			id = sc->sc_oid;
a490 1
			id = sc->sc_fid;
d495 2
a496 3
		err = usbd_set_report(sc->sc_iface, re->ucr_report, id,
			  re->ucr_data,
			  size);
d501 4
d512 1
a512 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d522 1
a522 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d527 1
a527 1
uhidpoll(dev_t dev, int events, struct proc *p)
a550 4

#if defined(__FreeBSD__)
DRIVER_MODULE(uhid, uhub, uhid_driver, uhid_devclass, usbd_driver_load, 0);
#endif
@


1.17
log
@Sync ulpt driver with NetBSD
@
text
@d2 2
a3 1
/*	$NetBSD: uhid.c,v 1.51 2002/03/17 18:02:53 augustss Exp $	*/
d51 1
d54 7
d78 2
a79 1
#include <dev/usb/uhidev.h>
d91 5
a95 1
	struct uhidev sc_hdev;
d100 3
d104 1
d107 3
d112 1
a112 1
	usb_proc_ptr sc_async;	/* process that wants SIGIO */
d114 4
a117 2
#define	UHID_ASLP	0x01	/* waiting for device data */
#define UHID_IMMED	0x02	/* return read data immediately */
d127 1
d129 27
d157 1
a157 1
Static void uhid_intr(struct uhidev *, void *, u_int len);
d161 1
a161 2
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,
			 usb_proc_ptr);
d168 9
a176 6
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;

	DPRINTF(("uhid_match: report=%d\n", uha->reportid));

	if (uha->matchlvl)
		return (uha->matchlvl);
d183 4
a186 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size, repid;
d188 58
d247 1
a247 9
	sc->sc_hdev.sc_intr = uhid_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_isize = hid_report_size(desc, size, hid_input,   repid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  repid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, repid);
d249 20
a268 2
	printf(": input=%d, output=%d, feature=%d\n",
	       sc->sc_isize, sc->sc_osize, sc->sc_fsize);
d273 1
d290 1
d296 1
d300 3
d305 2
d308 1
a308 1
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN) {
d314 1
a314 1
			usb_detach_wait(USBDEV(sc->sc_hdev.sc_dev));
d319 1
d328 6
d335 2
a336 5
#if 0
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, 
			   sc->sc_hdev.sc_parent->sc_udev,
			   USBDEV(sc->sc_hdev.sc_dev));
#endif
d342 1
a342 1
uhid_intr(struct uhidev *addr, void *data, u_int len)
d344 1
a344 1
	struct uhid_softc *sc = (struct uhid_softc *)addr;
d348 1
a348 1
		u_int32_t i;
d350 2
d353 2
a354 2
		for (i = 0; i < len; i++)
			DPRINTF((" %02x", ((u_char *)data)[i]));
d359 10
a368 1
	(void)b_to_q(data, len, &sc->sc_q);
d383 1
a383 1
uhidopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d386 1
a386 1
	int error;
d395 3
a397 3
	error = uhidev_open(&sc->sc_hdev);
	if (error)
		return (error);
d400 1
a400 1
		uhidev_close(&sc->sc_hdev);
d403 2
d406 14
d421 2
a422 1
	sc->sc_async = NULL;
d428 1
a428 1
uhidclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d436 5
d442 2
d445 4
a448 2
	sc->sc_async = NULL;
	uhidev_close(&sc->sc_hdev);
a457 1
	int extra;
d465 3
a467 3
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
					buffer, sc->sc_isize + extra);
d470 1
a470 1
		return (uiomove(buffer+extra, sc->sc_isize, uio));
d489 5
d526 1
a526 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d548 6
a553 2
		err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
					sc->sc_obuf, size);
d572 1
a572 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d578 1
a578 1
	      int flag, usb_proc_ptr p)
d582 1
a582 2
	u_char buffer[UHID_CHUNK];
	int size, extra;
a583 1
	void *desc;
a613 1
		uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
d615 1
a615 1
		size = min(size, sizeof rd->ucrd_data);
d617 1
a617 1
		memcpy(rd->ucrd_data, desc, size);
d622 3
a624 3
			extra = sc->sc_hdev.sc_report_id != 0;
			err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
						buffer, sc->sc_isize + extra);
d638 1
d642 1
d646 1
d651 2
a652 5
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size + extra);
		if (extra)
			memcpy(re->ucr_data, re->ucr_data+1, size);
d662 1
d666 1
d670 1
d675 3
a677 2
		err = uhidev_set_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size);
a681 4
	case USB_GET_REPORT_ID:
		*(int *)addr = sc->sc_hdev.sc_report_id;
		break;

d689 1
a689 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d699 1
a699 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d704 1
a704 1
uhidpoll(dev_t dev, int events, usb_proc_ptr p)
d728 4
@


1.16
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 3
/*	$OpenBSD: uhid.c,v 1.15 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: uhid.c,v 1.45 2001/10/26 17:58:21 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhid.c,v 1.22 1999/11/17 22:33:43 n_hibma Exp $	*/
a49 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a51 7
#elif defined(__FreeBSD__)
#include <sys/ioccom.h>
#include <sys/filio.h>
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/ioccom.h>
#endif
d69 1
a69 2
/* Report descriptor for broken Wacom Graphire */
#include <dev/usb/ugraphire_rdesc.h>
d81 1
a81 5
	USBBASEDEVICE sc_dev;			/* base device */
	usbd_device_handle sc_udev;
	usbd_interface_handle sc_iface;	/* interface */
	usbd_pipe_handle sc_intrpipe;	/* interrupt pipe */
	int sc_ep_addr;
a85 3
	u_int8_t sc_iid;
	u_int8_t sc_oid;
	u_int8_t sc_fid;
a86 1
	u_char *sc_ibuf;
a88 3
	void *sc_repdesc;
	int sc_repdesc_size;

d91 1
a91 1
	struct proc *sc_async;	/* process that wants SIGIO */
d93 2
a94 4
#define	UHID_OPEN	0x01	/* device is open */
#define	UHID_ASLP	0x02	/* waiting for device data */
#define UHID_NEEDCLEAR	0x04	/* needs clearing endpoint stall */
#define UHID_IMMED	0x08	/* return read data immediately */
a103 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a104 27
#elif defined(__FreeBSD__)
d_open_t	uhidopen;
d_close_t	uhidclose;
d_read_t	uhidread;
d_write_t	uhidwrite;
d_ioctl_t	uhidioctl;
d_poll_t	uhidpoll;

#define		UHID_CDEV_MAJOR 122

Static struct cdevsw uhid_cdevsw = {
	/* open */	uhidopen,
	/* close */	uhidclose,
	/* read */	uhidread,
	/* write */	uhidwrite,
	/* ioctl */	uhidioctl,
	/* poll */	uhidpoll,
	/* mmap */	nommap,
	/* strategy */	nostrategy,
	/* name */	"uhid",
	/* maj */	UHID_CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
	/* bmaj */	-1
};
#endif
d106 1
a106 1
Static void uhid_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d110 2
a111 1
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,struct proc*);
d118 6
a123 9
	usb_interface_descriptor_t *id;
	
	if (uaa->iface == NULL)
		return (UMATCH_NONE);
	id = usbd_get_interface_descriptor(uaa->iface);
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
		return (UMATCH_NONE);
	if (uaa->matchlvl)
		return (uaa->matchlvl);
d130 2
a131 4
	usbd_interface_handle iface = uaa->iface;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	int size;
a132 58
	usbd_status err;
	char devinfo[1024];
	
	sc->sc_udev = uaa->device;
	sc->sc_iface = iface;
	id = usbd_get_interface_descriptor(iface);
	usbd_devinfo(uaa->device, 0, devinfo);
	USB_ATTACH_SETUP;
	printf("%s: %s, iclass %d/%d\n", USBDEVNAME(sc->sc_dev),
	       devinfo, id->bInterfaceClass, id->bInterfaceSubClass);

	ed = usbd_interface2endpoint_descriptor(iface, 0);
	if (ed == NULL) {
		printf("%s: could not read endpoint descriptor\n",
		       USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}

	DPRINTFN(10,("uhid_attach: bLength=%d bDescriptorType=%d "
		     "bEndpointAddress=%d-%s bmAttributes=%d wMaxPacketSize=%d"
		     " bInterval=%d\n",
		     ed->bLength, ed->bDescriptorType, 
		     ed->bEndpointAddress & UE_ADDR,
		     UE_GET_DIR(ed->bEndpointAddress)==UE_DIR_IN? "in" : "out",
		     ed->bmAttributes & UE_XFERTYPE,
		     UGETW(ed->wMaxPacketSize), ed->bInterval));

	if (UE_GET_DIR(ed->bEndpointAddress) != UE_DIR_IN ||
	    (ed->bmAttributes & UE_XFERTYPE) != UE_INTERRUPT) {
		printf("%s: unexpected endpoint\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}

	sc->sc_ep_addr = ed->bEndpointAddress;

	if (uaa->vendor == USB_VENDOR_WACOM &&
	    uaa->product == USB_PRODUCT_WACOM_GRAPHIRE /* &&
	    uaa->revision == 0x???? */) { /* XXX should use revision */
		/* The report descriptor for the Wacom Graphire is broken. */
		size = sizeof uhid_graphire_report_descr;
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL)
			err = USBD_NOMEM;
		else {
			err = USBD_NORMAL_COMPLETION;
			memcpy(desc, uhid_graphire_report_descr, size);
		}
	} else {
		desc = NULL;
		err = usbd_read_report_desc(uaa->iface, &desc, &size,M_USBDEV);
	}
	if (err) {
		printf("%s: no report descriptor\n", USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
d134 9
a142 1
	(void)usbd_set_idle(iface, 0, 0);
d144 2
a145 20
	sc->sc_isize = hid_report_size(desc, size, hid_input,   &sc->sc_iid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  &sc->sc_oid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, &sc->sc_fid);

	sc->sc_repdesc = desc;
	sc->sc_repdesc_size = size;

#ifdef __FreeBSD__
	{
		static int global_init_done = 0;

		if (!global_init_done) {
			cdevsw_add(&uhid_cdevsw);
			global_init_done = 1;
		}
	}
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
a149 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a165 1
#endif
a170 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a173 3
#else
	DPRINTF(("uhid_detach: sc=%p\n", sc));
#endif
a175 2
	if (sc->sc_intrpipe != NULL)
		usbd_abort_pipe(sc->sc_intrpipe);
d177 1
a177 1
	if (sc->sc_state & UHID_OPEN) {
d183 1
a183 1
			usb_detach_wait(USBDEV(sc->sc_dev));
a187 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d196 5
a200 2
#elif defined(__FreeBSD__)
	/* XXX not implemented yet */
a202 6
	if (sc->sc_repdesc)
		free(sc->sc_repdesc, M_USBDEV);

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d207 1
a207 1
uhid_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d209 1
a209 1
	struct uhid_softc *sc = addr;
d213 1
a213 1
		u_int32_t cc, i;
a214 2
		usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);
		DPRINTF(("uhid_intr: status=%d cc=%d\n", status, cc));
d216 2
a217 2
		for (i = 0; i < cc; i++)
			DPRINTF((" %02x", sc->sc_ibuf[i]));
d222 1
a222 10
	if (status == USBD_CANCELLED)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("uhid_intr: status=%d\n", status));
		sc->sc_state |= UHID_NEEDCLEAR;
		return;
	}

	(void) b_to_q(sc->sc_ibuf, sc->sc_isize, &sc->sc_q);
d237 1
a237 1
uhidopen(dev_t dev, int flag, int mode, struct proc *p)
d240 1
a240 1
	usbd_status err;
d249 3
a251 3
	if (sc->sc_state & UHID_OPEN)
		return (EBUSY);
	sc->sc_state |= UHID_OPEN;
d254 1
a254 1
		sc->sc_state &= ~UHID_OPEN;
a256 2

	sc->sc_ibuf = malloc(sc->sc_isize, M_USBDEV, M_WAITOK);
a257 14

	/* Set up interrupt pipe. */
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, 
		  sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
		DPRINTF(("uhidopen: usbd_open_pipe_intr failed, "
			 "error=%d\n",err));
		free(sc->sc_ibuf, M_USBDEV);
		free(sc->sc_obuf, M_USBDEV);
		sc->sc_state &= ~UHID_OPEN;
		return (EIO);
	}

d259 1
a259 2

	sc->sc_async = 0;
d265 1
a265 1
uhidclose(dev_t dev, int flag, int mode, struct proc *p)
a272 5
	/* Disable interrupts. */
	usbd_abort_pipe(sc->sc_intrpipe);
	usbd_close_pipe(sc->sc_intrpipe);
	sc->sc_intrpipe = 0;

a273 2

	free(sc->sc_ibuf, M_USBDEV);
d275 2
a276 4

	sc->sc_state &= ~UHID_OPEN;

	sc->sc_async = 0;
d286 1
d294 3
a296 3
		
		err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
				    sc->sc_iid, buffer, sc->sc_isize);
d299 1
a299 1
		return (uiomove(buffer, sc->sc_isize, uio));
a317 5
		if (sc->sc_state & UHID_NEEDCLEAR) {
			DPRINTFN(-1,("uhidread: clearing stall\n"));
			sc->sc_state &= ~UHID_NEEDCLEAR;
			usbd_clear_endpoint_stall(sc->sc_intrpipe);
		}
d350 1
a350 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d372 2
a373 6
		if (sc->sc_oid)
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  sc->sc_obuf[0], sc->sc_obuf+1, size-1);
		else
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  0, sc->sc_obuf, size);
d392 1
a392 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d398 1
a398 1
	      int flag, struct proc *p)
d402 2
a403 1
	int size, id;
d405 1
d436 1
d438 1
a438 1
		size = min(sc->sc_repdesc_size, sizeof rd->ucrd_data);
d440 1
a440 1
		memcpy(rd->ucrd_data, sc->sc_repdesc, size);
d445 3
a447 3
			/* XXX should read into ibuf, but does it matter? */
			err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
				  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);
a460 1
			id = sc->sc_iid;
a463 1
			id = sc->sc_oid;
a466 1
			id = sc->sc_fid;
d471 5
a475 2
		err = usbd_get_report(sc->sc_iface, re->ucr_report, id,
			  re->ucr_data, size);
a484 1
			id = sc->sc_iid;
a487 1
			id = sc->sc_oid;
a490 1
			id = sc->sc_fid;
d495 2
a496 3
		err = usbd_set_report(sc->sc_iface, re->ucr_report, id,
			  re->ucr_data,
			  size);
d501 4
d512 1
a512 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d522 1
a522 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d527 1
a527 1
uhidpoll(dev_t dev, int events, struct proc *p)
a550 4

#if defined(__FreeBSD__)
DRIVER_MODULE(uhid, uhub, uhid_driver, uhid_devclass, usbd_driver_load, 0);
#endif
@


1.15
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.14 2001/05/03 02:20:33 aaron Exp $ */
d615 3
a617 3
		size = min(sc->sc_repdesc_size, sizeof rd->data);
		rd->size = size;
		memcpy(rd->data, sc->sc_repdesc, size);
d635 1
a635 1
		switch (re->report) {
d651 2
a652 2
		err = usbd_get_report(sc->sc_iface, re->report, id, re->data,
			  size);
d659 1
a659 1
		switch (re->report) {
d675 2
a676 1
		err = usbd_set_report(sc->sc_iface, re->report, id, re->data,
@


1.15.2.1
log
@Sync UBC branch to -current
@
text
@d1 3
a3 2
/*	$OpenBSD$ */
/*	$NetBSD: uhid.c,v 1.51 2002/03/17 18:02:53 augustss Exp $	*/
d51 1
d54 7
d78 2
a79 1
#include <dev/usb/uhidev.h>
d91 5
a95 1
	struct uhidev sc_hdev;
d100 3
d104 1
d107 3
d112 1
a112 1
	usb_proc_ptr sc_async;	/* process that wants SIGIO */
d114 4
a117 2
#define	UHID_ASLP	0x01	/* waiting for device data */
#define UHID_IMMED	0x02	/* return read data immediately */
d127 1
d129 27
d157 1
a157 1
Static void uhid_intr(struct uhidev *, void *, u_int len);
d161 1
a161 2
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,
			 usb_proc_ptr);
d168 9
a176 6
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;

	DPRINTF(("uhid_match: report=%d\n", uha->reportid));

	if (uha->matchlvl)
		return (uha->matchlvl);
d183 4
a186 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size, repid;
d188 58
d247 1
a247 9
	sc->sc_hdev.sc_intr = uhid_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_isize = hid_report_size(desc, size, hid_input,   repid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  repid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, repid);
d249 20
a268 2
	printf(": input=%d, output=%d, feature=%d\n",
	       sc->sc_isize, sc->sc_osize, sc->sc_fsize);
d273 1
d290 1
d296 1
d300 3
d305 2
d308 1
a308 1
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN) {
d314 1
a314 1
			usb_detach_wait(USBDEV(sc->sc_hdev.sc_dev));
d319 1
d328 6
d335 2
a336 5
#if 0
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, 
			   sc->sc_hdev.sc_parent->sc_udev,
			   USBDEV(sc->sc_hdev.sc_dev));
#endif
d342 1
a342 1
uhid_intr(struct uhidev *addr, void *data, u_int len)
d344 1
a344 1
	struct uhid_softc *sc = (struct uhid_softc *)addr;
d348 1
a348 1
		u_int32_t i;
d350 2
d353 2
a354 2
		for (i = 0; i < len; i++)
			DPRINTF((" %02x", ((u_char *)data)[i]));
d359 10
a368 1
	(void)b_to_q(data, len, &sc->sc_q);
d383 1
a383 1
uhidopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d386 1
a386 1
	int error;
d395 3
a397 3
	error = uhidev_open(&sc->sc_hdev);
	if (error)
		return (error);
d400 1
a400 1
		uhidev_close(&sc->sc_hdev);
d403 2
d406 14
d421 2
a422 1
	sc->sc_async = NULL;
d428 1
a428 1
uhidclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d436 5
d442 2
d445 4
a448 2
	sc->sc_async = NULL;
	uhidev_close(&sc->sc_hdev);
a457 1
	int extra;
d465 3
a467 3
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
					buffer, sc->sc_isize + extra);
d470 1
a470 1
		return (uiomove(buffer+extra, sc->sc_isize, uio));
d489 5
d526 1
a526 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d548 6
a553 2
		err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
					sc->sc_obuf, size);
d572 1
a572 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d578 1
a578 1
	      int flag, usb_proc_ptr p)
d582 1
a582 2
	u_char buffer[UHID_CHUNK];
	int size, extra;
a583 1
	void *desc;
a613 1
		uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
d615 3
a617 3
		size = min(size, sizeof rd->ucrd_data);
		rd->ucrd_size = size;
		memcpy(rd->ucrd_data, desc, size);
d622 3
a624 3
			extra = sc->sc_hdev.sc_report_id != 0;
			err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
						buffer, sc->sc_isize + extra);
d635 1
a635 1
		switch (re->ucr_report) {
d638 1
d642 1
d646 1
d651 2
a652 5
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size + extra);
		if (extra)
			memcpy(re->ucr_data, re->ucr_data+1, size);
d659 1
a659 1
		switch (re->ucr_report) {
d662 1
d666 1
d670 1
d675 2
a676 2
		err = uhidev_set_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size);
a680 4
	case USB_GET_REPORT_ID:
		*(int *)addr = sc->sc_hdev.sc_report_id;
		break;

d688 1
a688 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d698 1
a698 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d703 1
a703 1
uhidpoll(dev_t dev, int events, usb_proc_ptr p)
d727 4
@


1.15.2.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: uhid.c,v 1.52 2002/07/11 21:14:29 augustss Exp $	*/
a103 1
#if defined(__NetBSD__)
a104 1
#endif
d133 1
a133 1

d198 1
a198 1
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH,
d214 1
a214 1

d223 1
a223 1

d362 1
a362 1

@


1.15.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uhid.c,v 1.55 2002/10/23 09:14:00 jdolecek Exp $	*/
d105 1
a105 12
dev_type_open(uhidopen);
dev_type_close(uhidclose);
dev_type_read(uhidread);
dev_type_write(uhidwrite);
dev_type_ioctl(uhidioctl);
dev_type_poll(uhidpoll);
dev_type_kqfilter(uhidkqfilter);

const struct cdevsw uhid_cdevsw = {
	uhidopen, uhidclose, uhidread, uhidwrite, uhidioctl,
	nostop, notty, uhidpoll, nommap, uhidkqfilter,
};
d160 1
a190 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uhid_cdevsw);
#elif defined(__OpenBSD__)
a193 1
#endif
@


1.14
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.13 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: uhid.c,v 1.42 2000/12/29 01:47:49 augustss Exp $	*/
d175 2
d239 1
a239 1
		err = usbd_alloc_report_desc(uaa->iface, &desc, &size,M_USBDEV);
d372 1
a372 1
		DPRINTFN(5, ("uhid_intr: waking %p\n", sc));
d480 1
a480 1
		DPRINTFN(5, ("uhidread: sleep on %p\n", sc));
@


1.13
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.12 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: uhid.c,v 1.40 2000/10/10 12:37:01 augustss Exp $	*/
@


1.12
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.11 2000/07/04 11:44:23 fgsch Exp $ */
d43 1
a43 1
 * HID spec: http://www.usb.org/developers/data/usbhid10.pdf
d72 1
d78 3
d223 16
a238 2
	desc = NULL;
	err = usbd_alloc_report_desc(uaa->iface, &desc, &size, M_USBDEV);
@


1.11
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.10 2000/04/14 22:50:26 aaron Exp $ */
/*	$NetBSD: uhid.c,v 1.37 2000/04/14 14:12:47 augustss Exp $	*/
d153 1
a153 2
Static void uhid_intr __P((usbd_xfer_handle, usbd_private_handle,
			   usbd_status));
d155 3
a157 4
Static int uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));
Static int uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));
Static int uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,
			      struct proc *));
d219 1
a219 1
	desc = 0;
d255 1
a255 3
uhid_activate(self, act)
	device_ptr_t self;
	enum devact act;
d312 2
a313 1
	free(sc->sc_repdesc, M_USBDEV);
d322 1
a322 4
uhid_intr(xfer, addr, status)
	usbd_xfer_handle xfer;
	usbd_private_handle addr;
	usbd_status status;
d363 1
a363 5
uhidopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d408 1
a408 5
uhidclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d434 1
a434 4
uhid_do_read(sc, uio, flag)
	struct uhid_softc *sc;
	struct uio *uio;
	int flag;
d496 1
a496 4
uhidread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d511 1
a511 4
uhid_do_write(sc, uio, flag)
	struct uhid_softc *sc;
	struct uio *uio;
	int flag;
d542 1
a542 4
uhidwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d557 2
a558 6
uhid_do_ioctl(sc, cmd, addr, flag, p)
	struct uhid_softc *sc;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d668 1
a668 6
uhidioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr;
	int flag;
	struct proc *p;
d683 1
a683 4
uhidpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
@


1.10
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.9 2000/03/30 16:19:33 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
@


1.9
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.8 2000/03/28 19:37:50 aaron Exp $ */
/*	$NetBSD: uhid.c,v 1.36 2000/03/27 12:33:56 augustss Exp $	*/
d50 1
d108 1
d362 4
d412 2
d442 2
d603 18
@


1.8
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhid.c,v 1.35 2000/03/19 22:23:28 augustss Exp $	*/
d133 1
a133 1
static struct cdevsw uhid_cdevsw = {
d151 1
a151 1
static void uhid_intr __P((usbd_xfer_handle, usbd_private_handle,
d154 3
a156 3
static int uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));
static int uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));
static int uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int,
@


1.7
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.6 1999/11/07 21:30:19 fgsch Exp $	*/
d3 1
d151 2
a152 1
void uhid_intr __P((usbd_xfer_handle, usbd_private_handle, usbd_status));
d154 4
a157 3
int uhid_do_read __P((struct uhid_softc *, struct uio *uio, int));
int uhid_do_write __P((struct uhid_softc *, struct uio *uio, int));
int uhid_do_ioctl __P((struct uhid_softc *, u_long, caddr_t, int, struct proc *));
d184 1
a184 1

d333 1
a333 1

d336 1
a336 1
		DPRINTF(("uhid_intr: data="));
d393 2
a394 2
	    USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf,
	    sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);
d543 1
a543 1
			    sc->sc_obuf[0], sc->sc_obuf+1, size-1);
d546 1
a546 1
			    0, sc->sc_obuf, size);
d606 1
a606 1
			    sc->sc_iid, sc->sc_ibuf, sc->sc_isize);
d634 1
a634 1
		    size);
d638 1
d658 1
a658 1
		    size);
@


1.6
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhid.c,v 1.26 1999/10/13 08:10:56 augustss Exp $	*/
d86 1
d98 2
a99 2
	char *sc_ibuf;
	char *sc_obuf;
d150 1
a150 1
void uhid_intr __P((usbd_request_handle, usbd_private_handle, usbd_status));
d163 1
a163 1
	if (!uaa->iface)
d166 1
a166 1
	if (!id || id->bInterfaceClass != UCLASS_HID)
d179 1
a179 1
	usbd_status r;
d181 2
a182 1
	
d191 1
a191 1
	if (!ed) {
d217 2
a218 2
	r = usbd_alloc_report_desc(uaa->iface, &desc, &size, M_USBDEV);
	if (r != USBD_NORMAL_COMPLETION) {
a220 2
		if (desc)
			free(desc, M_USBDEV);
d233 14
d284 1
a284 1
	if (sc->sc_intrpipe)
d313 3
d320 2
a321 2
uhid_intr(reqh, addr, status)
	usbd_request_handle reqh;
d327 12
a338 3
	DPRINTFN(5, ("uhid_intr: status=%d\n", status));
	DPRINTFN(5, ("uhid_intr: data = %02x %02x %02x\n",
		     sc->sc_ibuf[0], sc->sc_ibuf[1], sc->sc_ibuf[2]));
d367 1
a367 1
	usbd_status r;
d389 4
a392 5
	r = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
				USBD_SHORT_XFER_OK,
				&sc->sc_intrpipe, sc, sc->sc_ibuf, 
				sc->sc_isize, uhid_intr);
	if (r != USBD_NORMAL_COMPLETION) {
d394 1
a394 1
			 "error=%d\n",r));
d444 1
a444 1
	usbd_status r;
d450 1
a450 1
		r = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
d452 1
a452 1
		if (r != USBD_NORMAL_COMPLETION)
d489 1
a489 1
		DPRINTFN(5, ("uhidread: got %d chars\n", length));
d525 1
a525 1
	usbd_status r;
d539 2
a540 3
			r = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
					    sc->sc_obuf[0], 
					    sc->sc_obuf+1, size-1);
d542 3
a544 3
			r = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
					    0, sc->sc_obuf, size);
		if (r != USBD_NORMAL_COMPLETION) {
a545 1
		}
d580 1
a580 1
	usbd_status r;
d601 4
a604 5
			/* XXX should read into ibuf, but does it matter */
			r = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
					    sc->sc_iid, sc->sc_ibuf, 
					    sc->sc_isize);
			if (r != USBD_NORMAL_COMPLETION)
d630 26
a655 3
		r = usbd_get_report(sc->sc_iface, re->report, id, 
				    re->data, size);
		if (r != USBD_NORMAL_COMPLETION)
d715 1
a715 2
DEV_DRIVER_MODULE(uhid, uhub, uhid_driver, uhid_devclass, 
		  uhid_cdevsw, usbd_driver_load, 0);
@


1.6.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: uhid.c,v 1.13 2001/01/28 09:43:42 aaron Exp $ */
/*	$NetBSD: uhid.c,v 1.40 2000/10/10 12:37:01 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhid.c,v 1.22 1999/11/17 22:33:43 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/data/devclass/hid1_1.pdf
a48 1
#include <sys/signalvar.h>
a69 1
#include <dev/usb/usbdevs.h>
a74 3
/* Report descriptor for broken Wacom Graphire */
#include <dev/usb/ugraphire_rdesc.h>

a85 1
	usbd_device_handle sc_udev;
d97 2
a98 2
	u_char *sc_ibuf;
	u_char *sc_obuf;
a104 1
	struct proc *sc_async;	/* process that wants SIGIO */
d131 1
a131 1
Static struct cdevsw uhid_cdevsw = {
d149 1
a149 1
Static void uhid_intr(usbd_xfer_handle, usbd_private_handle, usbd_status);
d151 3
a153 3
Static int uhid_do_read(struct uhid_softc *, struct uio *uio, int);
Static int uhid_do_write(struct uhid_softc *, struct uio *uio, int);
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,struct proc*);
d162 1
a162 1
	if (uaa->iface == NULL)
d165 1
a165 1
	if (id == NULL || id->bInterfaceClass != UICLASS_HID)
d178 1
a178 1
	usbd_status err;
a180 1
	sc->sc_udev = uaa->device;
d189 1
a189 1
	if (ed == NULL) {
d214 3
a216 17
	if (uaa->vendor == USB_VENDOR_WACOM &&
	    uaa->product == USB_PRODUCT_WACOM_GRAPHIRE /* &&
	    uaa->revision == 0x???? */) { /* XXX should use revision */
		/* The report descriptor for the Wacom Graphire is broken. */
		size = sizeof uhid_graphire_report_descr;
		desc = malloc(size, M_USBDEV, M_NOWAIT);
		if (desc == NULL)
			err = USBD_NOMEM;
		else {
			err = USBD_NORMAL_COMPLETION;
			memcpy(desc, uhid_graphire_report_descr, size);
		}
	} else {
		desc = NULL;
		err = usbd_alloc_report_desc(uaa->iface, &desc, &size,M_USBDEV);
	}
	if (err) {
d219 2
a232 14
#ifdef __FreeBSD__
	{
		static int global_init_done = 0;

		if (!global_init_done) {
			cdevsw_add(&uhid_cdevsw);
			global_init_done = 1;
		}
	}
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d238 3
a240 1
uhid_activate(device_ptr_t self, enum devact act)
d270 1
a270 1
	if (sc->sc_intrpipe != NULL)
d297 1
a297 5
	if (sc->sc_repdesc)
		free(sc->sc_repdesc, M_USBDEV);

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));
d303 4
a306 1
uhid_intr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d310 3
a312 12
#ifdef UHID_DEBUG
	if (uhiddebug > 5) {
		u_int32_t cc, i;
		
		usbd_get_xfer_status(xfer, NULL, NULL, &cc, NULL);
		DPRINTF(("uhid_intr: status=%d cc=%d\n", status, cc));
		DPRINTF(("uhid_intr: data ="));
		for (i = 0; i < cc; i++)
			DPRINTF((" %02x", sc->sc_ibuf[i]));
		DPRINTF(("\n"));
	}
#endif
a330 4
	if (sc->sc_async != NULL) {
		DPRINTFN(3, ("uhid_intr: sending SIGIO %p\n", sc->sc_async));
		psignal(sc->sc_async, SIGIO);
	}
d334 5
a338 1
uhidopen(dev_t dev, int flag, int mode, struct proc *p)
d341 1
a341 1
	usbd_status err;
d363 5
a367 4
	err = usbd_open_pipe_intr(sc->sc_iface, sc->sc_ep_addr, 
		  USBD_SHORT_XFER_OK, &sc->sc_intrpipe, sc, sc->sc_ibuf, 
		  sc->sc_isize, uhid_intr, USBD_DEFAULT_INTERVAL);
	if (err) {
d369 1
a369 1
			 "error=%d\n",err));
a377 2
	sc->sc_async = 0;

d382 5
a386 1
uhidclose(dev_t dev, int flag, int mode, struct proc *p)
a405 2
	sc->sc_async = 0;

d410 4
a413 1
uhid_do_read(struct uhid_softc *sc, struct uio *uio, int flag)
d419 1
a419 1
	usbd_status err;
d425 1
a425 1
		err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
d427 1
a427 1
		if (err)
d464 1
a464 1
		DPRINTFN(5, ("uhidread: got %lu chars\n", (u_long)length));
d475 4
a478 1
uhidread(dev_t dev, struct uio *uio, int flag)
d493 4
a496 1
uhid_do_write(struct uhid_softc *sc, struct uio *uio, int flag)
d500 1
a500 1
	usbd_status err;
d514 3
a516 2
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  sc->sc_obuf[0], sc->sc_obuf+1, size-1);
d518 3
a520 3
			err = usbd_set_report(sc->sc_iface, UHID_OUTPUT_REPORT,
				  0, sc->sc_obuf, size);
		if (err)
d522 1
d529 4
a532 1
uhidwrite(dev_t dev, struct uio *uio, int flag)
d547 6
a552 2
uhid_do_ioctl(struct uhid_softc *sc, u_long cmd, caddr_t addr,
	      int flag, struct proc *p)
d557 1
a557 1
	usbd_status err;
a568 18
	case FIOASYNC:
		if (*(int *)addr) {
			if (sc->sc_async != NULL)
				return (EBUSY);
			sc->sc_async = p;
			DPRINTF(("uhid_do_ioctl: FIOASYNC %p\n", p));
		} else
			sc->sc_async = NULL;
		break;

	/* XXX this is not the most general solution. */
	case TIOCSPGRP:
		if (sc->sc_async == NULL)
			return (EINVAL);
		if (*(int *)addr != sc->sc_async->p_pgid)
			return (EPERM);
		break;

d578 5
a582 4
			/* XXX should read into ibuf, but does it matter? */
			err = usbd_get_report(sc->sc_iface, UHID_INPUT_REPORT,
				  sc->sc_iid, sc->sc_ibuf, sc->sc_isize);
			if (err)
d608 3
a610 27
		err = usbd_get_report(sc->sc_iface, re->report, id, re->data,
			  size);
		if (err)
			return (EIO);
		break;

	case USB_SET_REPORT:
		re = (struct usb_ctl_report *)addr;
		switch (re->report) {
		case UHID_INPUT_REPORT:
			size = sc->sc_isize;
			id = sc->sc_iid;
			break;
		case UHID_OUTPUT_REPORT:
			size = sc->sc_osize;
			id = sc->sc_oid;
			break;
		case UHID_FEATURE_REPORT:
			size = sc->sc_fsize;
			id = sc->sc_fid;
			break;
		default:
			return (EINVAL);
		}
		err = usbd_set_report(sc->sc_iface, re->report, id, re->data,
			  size);
		if (err)
d621 6
a626 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d641 4
a644 1
uhidpoll(dev_t dev, int events, struct proc *p)
d670 2
a671 1
DRIVER_MODULE(uhid, uhub, uhid_driver, uhid_devclass, usbd_driver_load, 0);
@


1.6.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhid.c,v 1.42 2000/12/29 01:47:49 augustss Exp $	*/
@


1.6.2.3
log
@Merge in -current
@
text
@d2 1
a2 1
/*	$NetBSD: uhid.c,v 1.45 2001/10/26 17:58:21 augustss Exp $	*/
a174 2
	if (uaa->matchlvl)
		return (uaa->matchlvl);
d237 1
a237 1
		err = usbd_read_report_desc(uaa->iface, &desc, &size,M_USBDEV);
d370 1
a370 1
		DPRINTFN(5, ("uhid_intr: waking %p\n", &sc->sc_q));
d478 1
a478 1
		DPRINTFN(5, ("uhidread: sleep on %p\n", &sc->sc_q));
@


1.6.2.4
log
@Sync the SMP branch with 3.3
@
text
@d2 2
a3 1
/*	$NetBSD: uhid.c,v 1.55 2002/10/23 09:14:00 jdolecek Exp $	*/
d51 1
d54 7
d78 2
a79 1
#include <dev/usb/uhidev.h>
d91 5
a95 1
	struct uhidev sc_hdev;
d100 3
d104 1
d107 3
d112 1
a112 1
	usb_proc_ptr sc_async;	/* process that wants SIGIO */
d114 4
a117 2
#define	UHID_ASLP	0x01	/* waiting for device data */
#define UHID_IMMED	0x02	/* return read data immediately */
d127 27
a153 12
#if defined(__NetBSD__)
dev_type_open(uhidopen);
dev_type_close(uhidclose);
dev_type_read(uhidread);
dev_type_write(uhidwrite);
dev_type_ioctl(uhidioctl);
dev_type_poll(uhidpoll);
dev_type_kqfilter(uhidkqfilter);

const struct cdevsw uhid_cdevsw = {
	uhidopen, uhidclose, uhidread, uhidwrite, uhidioctl,
	nostop, notty, uhidpoll, nommap, uhidkqfilter,
d157 1
a157 1
Static void uhid_intr(struct uhidev *, void *, u_int len);
d161 1
a161 2
Static int uhid_do_ioctl(struct uhid_softc*, u_long, caddr_t, int,
			 usb_proc_ptr);
d168 9
a176 6
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;

	DPRINTF(("uhid_match: report=%d\n", uha->reportid));

	if (uha->matchlvl)
		return (uha->matchlvl);
d183 4
a186 2
	struct uhidev_attach_arg *uha = (struct uhidev_attach_arg *)uaa;
	int size, repid;
d188 64
d253 13
a265 9
	sc->sc_hdev.sc_intr = uhid_intr;
	sc->sc_hdev.sc_parent = uha->parent;
	sc->sc_hdev.sc_report_id = uha->reportid;

	uhidev_get_report_desc(uha->parent, &desc, &size);
	repid = uha->reportid;
	sc->sc_isize = hid_report_size(desc, size, hid_input,   repid);
	sc->sc_osize = hid_report_size(desc, size, hid_output,  repid);
	sc->sc_fsize = hid_report_size(desc, size, hid_feature, repid);
d267 2
a268 2
	printf(": input=%d, output=%d, feature=%d\n",
	       sc->sc_isize, sc->sc_osize, sc->sc_fsize);
d273 1
d282 1
d290 1
d296 1
d300 3
d305 2
d308 1
a308 1
	if (sc->sc_hdev.sc_state & UHIDEV_OPEN) {
d314 1
a314 1
			usb_detach_wait(USBDEV(sc->sc_hdev.sc_dev));
d319 1
a320 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&uhid_cdevsw);
#elif defined(__OpenBSD__)
a323 1
#endif
d328 6
d335 2
a336 5
#if 0
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH,
			   sc->sc_hdev.sc_parent->sc_udev,
			   USBDEV(sc->sc_hdev.sc_dev));
#endif
d342 1
a342 1
uhid_intr(struct uhidev *addr, void *data, u_int len)
d344 1
a344 1
	struct uhid_softc *sc = (struct uhid_softc *)addr;
d348 4
a351 2
		u_int32_t i;

d353 2
a354 2
		for (i = 0; i < len; i++)
			DPRINTF((" %02x", ((u_char *)data)[i]));
d359 2
a360 1
	(void)b_to_q(data, len, &sc->sc_q);
d362 8
d383 1
a383 1
uhidopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d386 1
a386 1
	int error;
d395 3
a397 3
	error = uhidev_open(&sc->sc_hdev);
	if (error)
		return (error);
d400 1
a400 1
		uhidev_close(&sc->sc_hdev);
d403 2
d406 14
d421 2
a422 1
	sc->sc_async = NULL;
d428 1
a428 1
uhidclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d436 5
d442 2
d445 4
a448 2
	sc->sc_async = NULL;
	uhidev_close(&sc->sc_hdev);
a457 1
	int extra;
d465 3
a467 3
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
					buffer, sc->sc_isize + extra);
d470 1
a470 1
		return (uiomove(buffer+extra, sc->sc_isize, uio));
d489 5
d526 1
a526 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d538 1
a538 1

d548 6
a553 2
		err = uhidev_set_report(&sc->sc_hdev, UHID_OUTPUT_REPORT,
					sc->sc_obuf, size);
d572 1
a572 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d578 1
a578 1
	      int flag, usb_proc_ptr p)
d582 1
a582 2
	u_char buffer[UHID_CHUNK];
	int size, extra;
a583 1
	void *desc;
a613 1
		uhidev_get_report_desc(sc->sc_hdev.sc_parent, &desc, &size);
d615 3
a617 3
		size = min(size, sizeof rd->ucrd_data);
		rd->ucrd_size = size;
		memcpy(rd->ucrd_data, desc, size);
d622 3
a624 3
			extra = sc->sc_hdev.sc_report_id != 0;
			err = uhidev_get_report(&sc->sc_hdev, UHID_INPUT_REPORT,
						buffer, sc->sc_isize + extra);
d635 1
a635 1
		switch (re->ucr_report) {
d638 1
d642 1
d646 1
d651 2
a652 5
		extra = sc->sc_hdev.sc_report_id != 0;
		err = uhidev_get_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size + extra);
		if (extra)
			memcpy(re->ucr_data, re->ucr_data+1, size);
d659 1
a659 1
		switch (re->ucr_report) {
d662 1
d666 1
d670 1
d675 2
a676 2
		err = uhidev_set_report(&sc->sc_hdev, re->ucr_report,
		    re->ucr_data, size);
a680 4
	case USB_GET_REPORT_ID:
		*(int *)addr = sc->sc_hdev.sc_report_id;
		break;

d688 1
a688 1
uhidioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d698 1
a698 1
		usb_detach_wakeup(USBDEV(sc->sc_hdev.sc_dev));
d703 1
a703 1
uhidpoll(dev_t dev, int events, usb_proc_ptr p)
d727 4
@


1.6.2.5
log
@Sync SMP branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhid.c,v 1.6.2.4 2003/03/28 00:38:32 niklas Exp $ */
d42 1
a42 1
 * HID spec: http://www.usb.org/developers/devclass_docs/HID1_11.pdf
@


1.6.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhid.c,v 1.57 2003/03/11 16:44:00 augustss Exp $	*/
a565 66
}

Static void filt_uhidrdetach(struct knote *);
Static int filt_uhidread(struct knote *, long);
int uhidkqfilter(dev_t, struct knote *);

Static void
filt_uhidrdetach(struct knote *kn)
{
	struct uhid_softc *sc = (void *)kn->kn_hook;
	int s;

	s = splusb();
	SLIST_REMOVE(&sc->sc_rsel.sel_klist, kn, knote, kn_selnext);
	splx(s);
}

Static int
filt_uhidread(struct knote *kn, long hint)
{
	struct uhid_softc *sc = (void *)kn->kn_hook;

	kn->kn_data = sc->sc_q.c_cc;
	return (kn->kn_data > 0);
}

Static struct filterops uhidread_filtops =
	{ 1, NULL, filt_uhidrdetach, filt_uhidread };

Static struct filterops uhid_seltrue_filtops =
	{ 1, NULL, filt_uhidrdetach, filt_seltrue };

int
uhidkqfilter(dev_t dev, struct knote *kn)
{
	struct uhid_softc *sc;
	struct klist *klist;
	int s;

	USB_GET_SC(uhid, UHIDUNIT(dev), sc);

	if (sc->sc_dying)
		return (EIO);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sc->sc_rsel.sel_klist;
		kn->kn_fop = &uhidread_filtops;
		break;

	case EVFILT_WRITE:
		klist = &sc->sc_rsel.sel_klist;
		kn->kn_fop = &uhid_seltrue_filtops;
		break;

	default:
		return (1);
	}

	kn->kn_hook = (void *)sc;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
@


1.5
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: uhid.c,v 1.24 1999/09/05 19:32:18 augustss Exp $	*/
d75 1
a75 1
#ifdef USB_DEBUG
a136 3
	/* stop */	nostop,
	/* reset */	noreset,
	/* devtotty */	nodevtotty,
a140 1
	/* parms */	noparms,
a144 1
	/* maxio */	0,
d236 1
d255 1
d257 1
a257 4
int
uhid_detach(self, flags)
	device_ptr_t self;
	int flags;
d259 3
a261 1
	struct uhid_softc *sc = (struct uhid_softc *)self;
a262 1
	int s;
d265 3
d284 1
d293 3
d340 1
d342 1
a353 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a357 3
#elif defined(__FreeBSD__)
	clist_alloc_cblocks(&sc->sc_q, UHID_BSIZE, 0);
#endif
d388 2
a398 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a399 3
#elif defined(__FreeBSD__)
	clist_free_cblocks(&sc->sc_q);
#endif
d480 3
a483 1
	int error;
d534 3
a537 1
	int error;
d628 3
a631 1
	int error;
d646 1
d649 1
@


1.4
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.3 1999/08/27 09:00:29 fgsch Exp $	*/
/*	$NetBSD: uhid.c,v 1.21 1999/08/23 22:55:14 augustss Exp $	*/
d85 1
a85 1
	bdevice sc_dev;			/* base device */
d206 1
a206 1
		     ed->bEndpointAddress & UE_IN ? "in" : "out",
d210 1
a210 1
	if ((ed->bEndpointAddress & UE_IN) != UE_IN ||
d243 1
a243 1
	bdevice *self;
d262 1
a262 1
	bdevice *self;
d281 1
a281 1
			usb_detach_wait(&sc->sc_dev);
d488 1
a488 1
		usb_detach_wakeup(&sc->sc_dev);
d540 1
a540 1
		usb_detach_wakeup(&sc->sc_dev);
d632 1
a632 1
		usb_detach_wakeup(&sc->sc_dev);
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d243 1
a243 1
	struct device *self;
d262 1
a262 1
	struct device *self;
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhid.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: uhid.c,v 1.18 1999/06/30 06:44:23 augustss Exp $	*/
d246 11
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d76 2
a77 2
#define DPRINTF(x)	if (uhiddebug) printf x
#define DPRINTFN(n,x)	if (uhiddebug>(n)) printf x
d119 35
a153 6
int uhidopen __P((dev_t, int, int, struct proc *));
int uhidclose __P((dev_t, int, int, struct proc *p));
int uhidread __P((dev_t, struct uio *uio, int));
int uhidwrite __P((dev_t, struct uio *uio, int));
int uhidioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int uhidpoll __P((dev_t, int, struct proc *));
d653 2
a654 1
DRIVER_MODULE(uhid, usb, uhid_driver, uhid_devclass, usbd_driver_load, 0);
@

