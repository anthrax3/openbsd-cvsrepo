head	1.51;
access;
symbols
	OPENBSD_6_1:1.51.0.4
	OPENBSD_6_1_BASE:1.51
	OPENBSD_6_0:1.50.0.8
	OPENBSD_6_0_BASE:1.50
	OPENBSD_5_9:1.50.0.2
	OPENBSD_5_9_BASE:1.50
	OPENBSD_5_8:1.50.0.4
	OPENBSD_5_8_BASE:1.50
	OPENBSD_5_7:1.49.0.2
	OPENBSD_5_7_BASE:1.49
	OPENBSD_5_6:1.49.0.4
	OPENBSD_5_6_BASE:1.49
	OPENBSD_5_5:1.48.0.4
	OPENBSD_5_5_BASE:1.48
	OPENBSD_5_4:1.46.0.2
	OPENBSD_5_4_BASE:1.46
	OPENBSD_5_3:1.45.0.4
	OPENBSD_5_3_BASE:1.45
	OPENBSD_5_2:1.45.0.2
	OPENBSD_5_2_BASE:1.45
	OPENBSD_5_1_BASE:1.44
	OPENBSD_5_1:1.44.0.4
	OPENBSD_5_0:1.44.0.2
	OPENBSD_5_0_BASE:1.44
	OPENBSD_4_9:1.43.0.2
	OPENBSD_4_9_BASE:1.43
	OPENBSD_4_8:1.40.0.2
	OPENBSD_4_8_BASE:1.40
	OPENBSD_4_7:1.39.0.2
	OPENBSD_4_7_BASE:1.39
	OPENBSD_4_6:1.38.0.8
	OPENBSD_4_6_BASE:1.38
	OPENBSD_4_5:1.38.0.4
	OPENBSD_4_5_BASE:1.38
	OPENBSD_4_4:1.38.0.2
	OPENBSD_4_4_BASE:1.38
	OPENBSD_4_3:1.37.0.2
	OPENBSD_4_3_BASE:1.37
	OPENBSD_4_2:1.35.0.2
	OPENBSD_4_2_BASE:1.35
	OPENBSD_4_1:1.27.0.2
	OPENBSD_4_1_BASE:1.27
	OPENBSD_4_0:1.27.0.4
	OPENBSD_4_0_BASE:1.27
	OPENBSD_3_9:1.22.0.2
	OPENBSD_3_9_BASE:1.22
	OPENBSD_3_8:1.21.0.2
	OPENBSD_3_8_BASE:1.21
	OPENBSD_3_7:1.20.0.2
	OPENBSD_3_7_BASE:1.20
	OPENBSD_3_6:1.18.0.4
	OPENBSD_3_6_BASE:1.18
	SMP_SYNC_A:1.18
	SMP_SYNC_B:1.18
	OPENBSD_3_5:1.16.0.4
	OPENBSD_3_5_BASE:1.16
	OPENBSD_3_4:1.16.0.2
	OPENBSD_3_4_BASE:1.16
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.13.0.2
	OPENBSD_3_3_BASE:1.13
	OPENBSD_3_2:1.12.0.2
	OPENBSD_3_2_BASE:1.12
	OPENBSD_3_1:1.3.0.8
	OPENBSD_3_1_BASE:1.3
	UBC_SYNC_B:1.12
	UBC:1.3.0.6
	UBC_BASE:1.3
	OPENBSD_3_0:1.3.0.4
	OPENBSD_3_0_BASE:1.3
	SMP:1.3.0.2
	OPENBSD_2_9_BASE:1.2
	OPENBSD_2_9:1.2.0.2
	OPENBSD_2_8:1.1.0.2
	OPENBSD_2_8_BASE:1.1;
locks; strict;
comment	@ * @;


1.51
date	2016.09.02.09.14.59;	author mpi;	state Exp;
branches;
next	1.50;
commitid	blfE5YU3eGM81J65;

1.50
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.49;
commitid	p4LJxGKbi0BU2cG6;

1.49
date	2014.07.12.21.24.33;	author mpi;	state Exp;
branches;
next	1.48;
commitid	AGVMSdzbrCHVAlSG;

1.48
date	2013.11.15.08.25.31;	author pirofti;	state Exp;
branches;
next	1.47;

1.47
date	2013.11.07.12.54.35;	author pirofti;	state Exp;
branches;
next	1.46;

1.46
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.24.06.19.00;	author guenther;	state Exp;
branches;
next	1.44;

1.44
date	2011.07.03.15.47.18;	author matthew;	state Exp;
branches;
next	1.43;

1.43
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.42;

1.42
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.41;

1.41
date	2010.08.31.16.38.42;	author deraadt;	state Exp;
branches;
next	1.40;

1.40
date	2010.07.02.03.13.42;	author tedu;	state Exp;
branches;
next	1.39;

1.39
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.38;

1.38
date	2008.06.26.05.42.19;	author ray;	state Exp;
branches;
next	1.37;

1.37
date	2008.02.22.12.42.40;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.35;

1.35
date	2007.06.14.10.11.16;	author mbalmer;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.13.06.25.03;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.12.16.26.37;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.10.10.53.49;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.06.19.25.50;	author mk;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.05.08.43.56;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.27;

1.27
date	2006.06.23.06.27.12;	author miod;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.21.01.23.05;	author jsg;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.27.09.29.01;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2006.03.14.10.18.10;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2006.03.14.10.08.45;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2005.11.28.20.53.22;	author deraadt;	state Exp;
branches;
next	1.21;

1.21
date	2005.08.01.05.36.49;	author brad;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.23.02.24.30;	author deraadt;	state Exp;
branches;
next	1.19;

1.19
date	2004.11.28.18.59.27;	author pvalchev;	state Exp;
branches;
next	1.18;

1.18
date	2004.05.05.15.16.27;	author jcs;	state Exp;
branches;
next	1.17;

1.17
date	2004.04.10.08.04.59;	author grange;	state Exp;
branches;
next	1.16;

1.16
date	2003.08.05.14.51.18;	author jcs;	state Exp;
branches;
next	1.15;

1.15
date	2003.05.17.17.13.14;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2002.11.11.02.31.51;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.25.04.07.33;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2002.07.25.02.18.11;	author nate;	state Exp;
branches;
next	1.10;

1.10
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.9;

1.9
date	2002.07.09.17.18.48;	author nate;	state Exp;
branches;
next	1.8;

1.8
date	2002.07.09.17.15.38;	author nate;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.07.20.19.25;	author nate;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.07.20.00.38;	author nate;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.07.18.29.19;	author nate;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.07.18.08.05;	author nate;	state Exp;
branches;
next	1.3;

1.3
date	2001.05.03.02.20.35;	author aaron;	state Exp;
branches
	1.3.2.1
	1.3.6.1;
next	1.2;

1.2
date	2000.11.08.18.10.39;	author aaron;	state Exp;
branches;
next	1.1;

1.1
date	2000.07.04.11.34.31;	author fgsch;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.14.22.26.27;	author niklas;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.07.04.10.44.06;	author niklas;	state Exp;
branches;
next	1.3.2.3;

1.3.2.3
date	2003.03.28.00.38.33;	author niklas;	state Exp;
branches;
next	1.3.2.4;

1.3.2.4
date	2003.05.13.19.35.13;	author ho;	state Exp;
branches;
next	1.3.2.5;

1.3.2.5
date	2003.06.07.11.02.34;	author ho;	state Exp;
branches;
next	1.3.2.6;

1.3.2.6
date	2004.02.19.10.56.35;	author niklas;	state Exp;
branches;
next	1.3.2.7;

1.3.2.7
date	2004.06.05.23.12.59;	author niklas;	state Exp;
branches;
next	;

1.3.6.1
date	2002.06.11.03.42.31;	author art;	state Exp;
branches;
next	1.3.6.2;

1.3.6.2
date	2002.10.29.00.33.33;	author art;	state Exp;
branches;
next	1.3.6.3;

1.3.6.3
date	2003.05.19.22.26.20;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.51
log
@Avoid calling usbd_set_config_index() in *_attach() and let the stack
do it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.
@
text
@/*	$OpenBSD: uvisor.c,v 1.50 2015/03/14 03:38:50 jsg Exp $	*/
/*	$NetBSD: uvisor.c,v 1.21 2003/08/03 21:59:26 nathanw Exp $	*/

/*
 * Copyright (c) 2000 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Handspring Visor (Palmpilot compatible PDA) driver
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/device.h>
#include <sys/conf.h>
#include <sys/tty.h>

#include <dev/usb/usb.h>

#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/ucomvar.h>

#ifdef UVISOR_DEBUG
#define DPRINTF(x)	if (uvisordebug) printf x
#define DPRINTFN(n,x)	if (uvisordebug>(n)) printf x
int uvisordebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define UVISOR_IFACE_INDEX	0

/* From the Linux driver */
/*
 * UVISOR_REQUEST_BYTES_AVAILABLE asks the visor for the number of bytes that
 * are available to be transferred to the host for the specified endpoint.
 * Currently this is not used, and always returns 0x0001
 */
#define UVISOR_REQUEST_BYTES_AVAILABLE		0x01

/*
 * UVISOR_CLOSE_NOTIFICATION is set to the device to notify it that the host
 * is now closing the pipe. An empty packet is sent in response.
 */
#define UVISOR_CLOSE_NOTIFICATION		0x02

/*
 * UVISOR_GET_CONNECTION_INFORMATION is sent by the host during enumeration to
 * get the endpoints used by the connection.
 */
#define UVISOR_GET_CONNECTION_INFORMATION	0x03


/*
 * UVISOR_GET_CONNECTION_INFORMATION returns data in the following format
 */
#define UVISOR_MAX_CONN 8
struct uvisor_connection_info {
	uWord	num_ports;
	struct {
		uByte	port_function_id;
		uByte	port;
	} connections[UVISOR_MAX_CONN];
};
#define UVISOR_CONNECTION_INFO_SIZE 18

/* struct uvisor_connection_info.connection[x].port_function_id defines: */
#define UVISOR_FUNCTION_GENERIC		0x00
#define UVISOR_FUNCTION_DEBUGGER	0x01
#define UVISOR_FUNCTION_HOTSYNC		0x02
#define UVISOR_FUNCTION_CONSOLE		0x03
#define UVISOR_FUNCTION_REMOTE_FILE_SYS	0x04

/*
 * Unknown PalmOS stuff.
 */
#define UVISOR_GET_PALM_INFORMATION		0x04
#define UVISOR_GET_PALM_INFORMATION_LEN		0x44

struct uvisor_palm_connection_info {
	uByte	num_ports;
	uByte	endpoint_numbers_different;
	uWord	reserved1;
	struct {
		uDWord	port_function_id;
		uByte	port;
		uByte	end_point_info;
		uWord	reserved;
	} connections[UVISOR_MAX_CONN];
};

#define UVISORIBUFSIZE 64
#define UVISOROBUFSIZE 1024

struct uvisor_softc {
	struct device		sc_dev;		/* base device */
	struct usbd_device	*sc_udev;	/* device */
	struct usbd_interface	*sc_iface;	/* interface */
/* 
 * added sc_vendor for later interrogation in failed initialisations
 */
	int			sc_vendor;	/* USB device vendor */

	struct device		*sc_subdevs[UVISOR_MAX_CONN];
	int			sc_numcon;

	u_int16_t		sc_flags;
};

usbd_status uvisor_init(struct uvisor_softc *,
			       struct uvisor_connection_info *,
			       struct uvisor_palm_connection_info *);

void uvisor_close(void *, int);


struct ucom_methods uvisor_methods = {
	NULL,
	NULL,
	NULL,
	NULL,
	NULL,
	uvisor_close,
	NULL,
	NULL,
};

struct uvisor_type {
	struct usb_devno	uv_dev;
	u_int16_t		uv_flags;	
#define PALM4	0x0001
#define VISOR	0x0002
#define NOFRE	0x0004
#define CLIE4	(VISOR|NOFRE)
};
static const struct uvisor_type uvisor_devs[] = {
	{{ USB_VENDOR_ACEECA, USB_PRODUCT_ACEECA_MEZ1000 }, PALM4 },
	{{ USB_VENDOR_FOSSIL, USB_PRODUCT_FOSSIL_WRISTPDA }, PALM4 },
	{{ USB_VENDOR_GARMIN, USB_PRODUCT_GARMIN_IQUE3600 }, PALM4 },
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, VISOR },
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO }, PALM4 },
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO600 }, VISOR },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M500 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M505 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M515 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_I705 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M125 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M130 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_Z }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_T }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_ZIRE }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_ZIRE_31 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_40 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_S360 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_NX60 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_TJ25 }, PALM4 },
/*	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_25 }, PALM4 },*/
	{{ USB_VENDOR_TAPWAVE, USB_PRODUCT_TAPWAVE_ZODIAC }, PALM4 },
};
#define uvisor_lookup(v, p) ((struct uvisor_type *)usb_lookup(uvisor_devs, v, p))

int uvisor_match(struct device *, void *, void *);
void uvisor_attach(struct device *, struct device *, void *);
int uvisor_detach(struct device *, int);

struct cfdriver uvisor_cd = {
	NULL, "uvisor", DV_DULL
};

const struct cfattach uvisor_ca = {
	sizeof(struct uvisor_softc), uvisor_match, uvisor_attach, uvisor_detach
};

int
uvisor_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL)
		return (UMATCH_NONE);

	DPRINTFN(20,("uvisor: vendor=0x%x, product=0x%x\n",
		     uaa->vendor, uaa->product));

	return (uvisor_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

void
uvisor_attach(struct device *parent, struct device *self, void *aux)
{
	struct uvisor_softc *sc = (struct uvisor_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	struct usbd_interface *iface;
	usb_interface_descriptor_t *id;
	struct uvisor_connection_info coninfo;
	struct uvisor_palm_connection_info palmconinfo;
	usb_endpoint_descriptor_t *ed;
	int i, j, hasin, hasout, port;
	usbd_status err;
	struct ucom_attach_args uca;

	DPRINTFN(10,("\nuvisor_attach: sc=%p\n", sc));

	err = usbd_device2interface_handle(dev, UVISOR_IFACE_INDEX, &iface);
	if (err) {
		printf(": failed to get interface, err=%s\n",
		    usbd_errstr(err));
		goto bad;
	}

	sc->sc_flags = uvisor_lookup(uaa->vendor, uaa->product)->uv_flags;
	sc->sc_vendor = uaa->vendor;
	
	if ((sc->sc_flags & (VISOR | PALM4)) == 0) {
		printf("%s: device is neither visor nor palm\n", 
		    sc->sc_dev.dv_xname);
		goto bad;
	}

	id = usbd_get_interface_descriptor(iface);

	sc->sc_udev = dev;
	sc->sc_iface = iface;

	uca.ibufsize = UVISORIBUFSIZE;
	uca.obufsize = UVISOROBUFSIZE;
	uca.ibufsizepad = UVISORIBUFSIZE;
	uca.opkthdrlen = 0;
	uca.device = dev;
	uca.iface = iface;
	uca.methods = &uvisor_methods;
	uca.arg = sc;

	err = uvisor_init(sc, &coninfo, &palmconinfo);
	if (err) {
		printf("%s: init failed, %s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(err));
		goto bad;
	}

	if (sc->sc_flags & VISOR) {
		sc->sc_numcon = UGETW(coninfo.num_ports);
		if (sc->sc_numcon > UVISOR_MAX_CONN)
			sc->sc_numcon = UVISOR_MAX_CONN;

		/* Attach a ucom for each connection. */
		for (i = 0; i < sc->sc_numcon; ++i) {
			switch (coninfo.connections[i].port_function_id) {
			case UVISOR_FUNCTION_GENERIC:
				uca.info = "Generic";
				break;
			case UVISOR_FUNCTION_DEBUGGER:
				uca.info = "Debugger";
				break;
			case UVISOR_FUNCTION_HOTSYNC:
				uca.info = "HotSync";
				break;
			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
				uca.info = "Remote File System";
				break;
			default:
				uca.info = "unknown";
				break;
			}
			port = coninfo.connections[i].port;
			uca.portno = port;
			uca.bulkin = port | UE_DIR_IN;
			uca.bulkout = port | UE_DIR_OUT;
			/* Verify that endpoints exist. */
			hasin = 0;
			hasout = 0;
			for (j = 0; j < id->bNumEndpoints; j++) {
				ed = usbd_interface2endpoint_descriptor(iface, j);
				if (ed == NULL)
					break;
				if (UE_GET_ADDR(ed->bEndpointAddress) == port &&
				    (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
					if (UE_GET_DIR(ed->bEndpointAddress)
					    == UE_DIR_IN)
						hasin++;
					else
						hasout++;
				}
			}
			if (hasin == 1 && hasout == 1)
				sc->sc_subdevs[i] = config_found_sm(self, &uca,
				    ucomprint, ucomsubmatch);
			else
				printf("%s: no proper endpoints for port %d (%d,%d)\n",
				    sc->sc_dev.dv_xname, port, hasin, hasout);
		}
	} else {
		sc->sc_numcon = palmconinfo.num_ports;
		if (sc->sc_numcon > UVISOR_MAX_CONN)
			sc->sc_numcon = UVISOR_MAX_CONN;

		/* Attach a ucom for each connection. */
		for (i = 0; i < sc->sc_numcon; ++i) {
			/*
			 * XXX this should copy out 4-char string from the
			 * XXX port_function_id, but where would the string go?
			 * XXX uca.info is a const char *, not an array.
			 */
			uca.info = "sync";
			uca.portno = i;
			if (palmconinfo.endpoint_numbers_different) {
				port = palmconinfo.connections[i].end_point_info;
				uca.bulkin = (port >> 4) | UE_DIR_IN;
				uca.bulkout = (port & 0xf) | UE_DIR_OUT;
			} else {
				port = palmconinfo.connections[i].port;
				uca.bulkin = port | UE_DIR_IN;
				uca.bulkout = port | UE_DIR_OUT;
			}
			sc->sc_subdevs[i] = config_found_sm(self, &uca,
			    ucomprint, ucomsubmatch);
		}
	}

	return;

bad:
	DPRINTF(("uvisor_attach: ATTACH ERROR\n"));
	usbd_deactivate(sc->sc_udev);
}

int
uvisor_detach(struct device *self, int flags)
{
	struct uvisor_softc *sc = (struct uvisor_softc *)self;
	int rv = 0;
	int i;

	DPRINTF(("uvisor_detach: sc=%p flags=%d\n", sc, flags));
	for (i = 0; i < sc->sc_numcon; i++) {
		if (sc->sc_subdevs[i] != NULL) {
			rv |= config_detach(sc->sc_subdevs[i], flags);
			sc->sc_subdevs[i] = NULL;
		}
	}

	return (rv);
}

usbd_status
uvisor_init(struct uvisor_softc *sc, struct uvisor_connection_info *ci,
    struct uvisor_palm_connection_info *cpi)
{
	usbd_status err = 0;
	usb_device_request_t req;
	int actlen;
	uWord avail;

	if (sc->sc_flags & PALM4) {
		DPRINTF(("uvisor_init: getting Palm connection info\n"));
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request_flags(sc->sc_udev, &req, cpi,
		    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
		if (err == USBD_STALLED && sc->sc_vendor == USB_VENDOR_SONY) {
			/* some sony clie devices stall on palm4 requests,
			 * switch them over to using visor. dont do free space
			 * checks on them since they dont like them either.
			 */
			DPRINTF(("switching role for CLIE probe\n"));
			sc->sc_flags = CLIE4;
			err = 0;
		}
		if (err)
			return (err);
	}
	
	if (sc->sc_flags & VISOR) {
		DPRINTF(("uvisor_init: getting Visor connection info\n"));
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_CONNECTION_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
		err = usbd_do_request_flags(sc->sc_udev, &req, ci,
		    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
		if (err)
			return (err);
	}
	
	if (sc->sc_flags & NOFRE)
		return (err);
	
	DPRINTF(("uvisor_init: getting available bytes\n"));
	req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
	req.bRequest = UVISOR_REQUEST_BYTES_AVAILABLE;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 5);
	USETW(req.wLength, sizeof avail);
	err = usbd_do_request(sc->sc_udev, &req, &avail);
	if (err)
		return (err);
	DPRINTF(("uvisor_init: avail=%d\n", UGETW(avail)));
	DPRINTF(("uvisor_init: done\n"));
	return (err);
}

void
uvisor_close(void *addr, int portno)
{
	struct uvisor_softc *sc = addr;
	usb_device_request_t req;
	struct uvisor_connection_info coninfo; /* XXX ? */
	int actlen;

	if (usbd_is_dying(sc->sc_udev))
		return;

	req.bmRequestType = UT_READ_VENDOR_ENDPOINT; /* XXX read? */
	req.bRequest = UVISOR_CLOSE_NOTIFICATION;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
	(void)usbd_do_request_flags(sc->sc_udev, &req, &coninfo,
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
}
@


1.50
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.49 2014/07/12 21:24:33 mpi Exp $	*/
a61 1
#define UVISOR_CONFIG_INDEX	0
d211 1
a211 1
	if (uaa->iface != NULL)
a236 8

	/* Move the device into the configured state. */
	err = usbd_set_config_index(dev, UVISOR_CONFIG_INDEX, 1);
	if (err) {
		printf(": failed to set configuration, err=%s\n",
		    usbd_errstr(err));
		goto bad;
	}
@


1.49
log
@Kill the last dumb DVACT_DEACTIVATE handlers.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.48 2013/11/15 08:25:31 pirofti Exp $	*/
a45 1
#include <dev/usb/usbhid.h>
@


1.48
log
@Sort-out activate functionality for ucom(4) and it's parents.


The child should not have to call the parent for deactivation.
The parent should handle it.
So kill the activate routine in ucom(4) and adapt the parents
to no longer call it.


Also remove sc_dying in ucom(4) and use usbd_is_dying() instead.

Okay mpi@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.47 2013/11/07 12:54:35 pirofti Exp $	*/
d196 10
a205 15
int uvisor_match(struct device *, void *, void *); 
void uvisor_attach(struct device *, struct device *, void *); 
int uvisor_detach(struct device *, int); 
int uvisor_activate(struct device *, int); 

struct cfdriver uvisor_cd = { 
	NULL, "uvisor", DV_DULL 
}; 

const struct cfattach uvisor_ca = { 
	sizeof(struct uvisor_softc), 
	uvisor_match, 
	uvisor_attach, 
	uvisor_detach, 
	uvisor_activate, 
a368 13
}

int
uvisor_activate(struct device *self, int act)
{
	struct uvisor_softc *sc = (struct uvisor_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.47
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.46 2013/04/15 09:23:02 mglocker Exp $	*/
a379 1
	int i, rv = 0, r;
a382 6
		for (i = 0; i < sc->sc_numcon; i++)
			if (sc->sc_subdevs[i] != NULL) {
				r = config_deactivate(sc->sc_subdevs[i]);
				if (r)
					rv = r;
			}
d386 1
a386 1
	return (rv);
@


1.46
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.45 2012/02/24 06:19:00 guenther Exp $	*/
a140 2

	u_char			sc_dying;
d373 1
a373 1
	sc->sc_dying = 1;
d390 1
a390 1
		sc->sc_dying = 1;
d483 1
a483 1
	if (sc->sc_dying)
@


1.45
log
@Correct the spelling of "transferred" and "transferring"

from Tobias Ulmer (tobiasu at tmux.org); ok jmc@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.44 2011/07/03 15:47:18 matthew Exp $	*/
d130 2
a131 2
	usbd_device_handle	sc_udev;	/* device */
	usbd_interface_handle	sc_iface;	/* interface */
d235 2
a236 2
	usbd_device_handle dev = uaa->device;
	usbd_interface_handle iface;
@


1.44
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.43 2011/01/25 20:03:36 jakemsr Exp $	*/
d69 1
a69 1
 * are available to be transfered to the host for the specified endpoint.
@


1.43
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.42 2010/09/24 08:33:59 yuo Exp $	*/
a384 2
	case DVACT_ACTIVATE:
		break;
@


1.42
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.41 2010/08/31 16:38:42 deraadt Exp $	*/
a291 3
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);

a413 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.41
log
@In xxactivate() DVACT_DEACTIVATE, when calling a series of config_deactivate()
for sub-devices, return the last error return value instead of |'ing the
failures together and creating some value that is non-0 (bravo!) but
potentially loses the specific error value...
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.40 2010/07/02 03:13:42 tedu Exp $	*/
a410 1
	sc->sc_dying = 1;
@


1.40
log
@fix a variety of uninit errors.  ok and one correction deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.39 2009/10/13 19:33:19 pirofti Exp $	*/
d385 1
a385 2
	int rv = 0;
	int i;
a389 1

d392 5
a396 2
			if (sc->sc_subdevs[i] != NULL)
				rv = config_deactivate(sc->sc_subdevs[i]);
@


1.39
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.38 2008/06/26 05:42:19 ray Exp $	*/
d428 1
a428 1
	usbd_status err;
@


1.38
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.37 2008/02/22 12:42:40 jsg Exp $	*/
d201 1
a201 1
int uvisor_activate(struct device *, enum devact); 
d382 1
a382 1
uvisor_activate(struct device *self, enum devact act)
@


1.37
log
@Simon Dick in FreeBSD PR 96714
* Fossil Abacus Wrist PDA

Thorsten Trampisch in FreeBSD PR 113384
* Expert ISDN Control
* RS232 OptoBridge

Jonathan Charest in FreeBSD PR 110992
* Several Tactrix OpenPort (ECU) devices.

Y.Okabe in FreeBSD PR 119981
* Logitec LAN-GTJ/U2 Ethernet

HAGIMORI 'buggy' Masashige in FreeBSD PR 115933
* RATOC REX-USB60F serial
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.36 2007/10/11 18:33:15 deraadt Exp $	*/
a19 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.36
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.35 2007/06/14 10:11:16 mbalmer Exp $	*/
d180 2
a200 1
	{{ USB_VENDOR_GARMIN, USB_PRODUCT_GARMIN_IQUE3600 }, PALM4 },
@


1.35
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.34 2007/06/13 06:25:03 mbalmer Exp $	*/
a246 2
	char *devinfop;
	char *devname = sc->sc_dev.dv_xname;
d256 2
a257 2
		printf("\n%s: failed to set configuration, err=%s\n",
		       devname, usbd_errstr(err));
d263 2
a264 2
		printf("\n%s: failed to get interface, err=%s\n",
		       devname, usbd_errstr(err));
a266 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.34
log
@Apply some KNF after the recent removal of macros and type definitions.

No binary change.

ok ray.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.33 2007/06/12 16:26:37 mbalmer Exp $	*/
d204 16
a219 1
USB_DECLARE_DRIVER(uvisor);
@


1.33
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.32 2007/06/10 14:49:01 mbalmer Exp $	*/
d144 1
a144 1
	struct device *		sc_subdevs[UVISOR_MAX_CONN];
@


1.32
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.31 2007/06/10 10:53:49 mbalmer Exp $	*/
d144 1
a144 1
	device_ptr_t		sc_subdevs[UVISOR_MAX_CONN];
d379 1
a379 1
uvisor_activate(device_ptr_t self, enum devact act)
d400 1
a400 1
uvisor_detach(device_ptr_t self, int flags)
@


1.31
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.30 2007/06/06 19:25:50 mk Exp $	*/
d233 1
a233 1
	char *devname = USBDEVNAME(sc->sc_dev);
d264 1
a264 1
		    USBDEVNAME(sc->sc_dev));
d284 1
a284 1
		printf("%s: init failed, %s\n", USBDEVNAME(sc->sc_dev),
d341 1
a341 1
				    USBDEVNAME(sc->sc_dev), port, hasin, hasout);
@


1.30
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.29 2007/06/05 08:43:56 mbalmer Exp $	*/
d290 1
a290 1
			   USBDEV(sc->sc_dev));
d416 1
a416 1
			   USBDEV(sc->sc_dev));
@


1.29
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.28 2007/05/27 04:00:25 jsg Exp $	*/
d136 1
a136 1
	USBBASEDEVICE		sc_dev;		/* base device */
@


1.28
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.27 2006/06/23 06:27:12 miod Exp $	*/
d152 1
a152 1
Static usbd_status uvisor_init(struct uvisor_softc *,
d156 1
a156 1
Static void uvisor_close(void *, int);
@


1.27
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.26 2006/06/21 01:23:05 jsg Exp $	*/
d206 2
a207 1
USB_MATCH(uvisor)
d209 1
a209 1
	USB_MATCH_START(uvisor, uaa);
d221 2
a222 1
USB_ATTACH(uvisor)
d224 2
a225 1
	USB_ATTACH_START(uvisor, sc, uaa);
d256 1
a256 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", devname, devinfop);
d371 1
a371 1
	USB_ATTACH_SUCCESS_RETURN;
a375 1
	USB_ATTACH_ERROR_RETURN;
@


1.26
log
@match Aceeca MEZ1000, from Mike Durian in FreeBSD PR 82839
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.25 2006/03/27 09:29:01 jsg Exp $	*/
a385 1
		return (EOPNOTSUPP);
@


1.25
log
@Fix compilation when UVISOR_DEBUG is defined.
From Alexandre Ratchov.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.24 2006/03/14 10:18:10 dlg Exp $	*/
d179 1
@


1.24
log
@a touch of knf
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.23 2006/03/14 10:08:45 dlg Exp $	*/
d443 1
a443 1
			DPRINTF(("switching role for CLIE probe\n"))
@


1.23
log
@add support for the Sony CLIE PEG-T625 and potentially a range of other
unusually behaved CLIE products. they attach as palm4 type devices, but
they stall on a certain init command. now we catch this stall and use it
to switch the way we use the device to somethig more appropriate.

from Andrew Smith
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.22 2005/11/28 20:53:22 deraadt Exp $	*/
d176 1
a176 9
/*
 * This flag is a combination it is used to reassign the probe value later on a
 * failed PALM4 request if the error is STALLED and the vendor ID is SONY
 * Note that the init routines have been ordered to try PALM4 first allowing
 * reallocation of the sc_flags so that the Visor routine may also be called
 * It is important to also skip the free check for effected devices though, hence
 * the combined flag value.	
 */	
#define CLIE4	0x0006
d260 1
a260 1
		printf("%s: init failed, device type is neither visor nor palm\n", 
d438 5
a442 7
		if (err == USBD_STALLED && sc->sc_vendor == USB_VENDOR_SONY)
		{
/*
 * Here we switch personality in the driver to a basic Visor type with the flag set to
 * avoid the Free Space checks, this is ONLY done if the PALM4 command STALLED
 * and the Vendor of the device is Sony
 */
d464 2
a465 6
/*
 * Skip the free bytes check if NOFRE flag is set (part of the CLIE4 mask
 * some CLIE_40 devices that stall on the PALM4 commands also hang the serial
 * devices if subjected to the free space check
 */
	if (sc->sc_flags & NOFRE) return (err);
@


1.22
log
@tapwave zodiac is a uvisor interface
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.21 2005/08/01 05:36:49 brad Exp $	*/
d139 4
d172 1
a172 1
	u_int16_t		uv_flags;
d175 10
d265 2
a266 1

d437 2
a438 2
	if (sc->sc_flags & VISOR) {
		DPRINTF(("uvisor_init: getting Visor connection info\n"));
d440 1
a440 1
		req.bRequest = UVISOR_GET_CONNECTION_INFORMATION;
d443 2
a444 2
		USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
		err = usbd_do_request_flags(sc->sc_udev, &req, ci,
d446 11
d460 3
a462 3

	if (sc->sc_flags & PALM4) {
		DPRINTF(("uvisor_init: getting Palm connection info\n"));
d464 1
a464 1
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
d467 2
a468 2
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request_flags(sc->sc_udev, &req, cpi,
d473 8
a480 1

a490 1

@


1.21
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.20 2005/02/23 02:24:30 deraadt Exp $	*/
d193 1
@


1.20
log
@palm zire 31; pr 4113, jamesw@@bsdhosting.co.za
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.19 2004/11/28 18:59:27 pvalchev Exp $	*/
d221 1
a221 1
	char devinfo[1024];
d244 1
a244 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d246 2
a247 1
	printf("%s: %s\n", devname, devinfo);
@


1.19
log
@garmin palm device; from openbsd@@st.thrush.com
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.18 2004/05/05 15:16:27 jcs Exp $	*/
d185 1
@


1.18
log
@make my treo 600 attach as a uvisor instead of ugen, from netbsd
ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.17 2004/04/10 08:04:59 grange Exp $	*/
d191 1
@


1.17
log
@Support for Sony Clie PEG-TJ25; from ilya voronin <ivoronin@@ivoronin.pp.ru>
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.16 2003/08/05 14:51:18 jcs Exp $	*/
d175 1
@


1.16
log
@sync with netbsd
makes my samsung i500 attach a ucom

ok nate@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.15 2003/05/17 17:13:14 nate Exp $	*/
d188 1
@


1.15
log
@more devices from NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.14 2003/05/07 04:33:33 deraadt Exp $	*/
/*	$NetBSD: uvisor.c,v 1.20 2003/04/11 01:30:10 simonb Exp $	*/
d118 1
a118 1
#define UVISOR_GET_PALM_INFORMATION_LEN		0x14
d120 11
d132 1
a132 1
#define UVISORIBUFSIZE 1024
d149 2
a150 1
			       struct uvisor_connection_info *);
d170 1
d173 1
a173 1
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, 0 },
d185 3
a187 1
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, 0 },
d215 1
d246 6
d266 1
a266 1
	err = uvisor_init(sc, &coninfo);
d276 22
a297 31
	sc->sc_numcon = UGETW(coninfo.num_ports);
	if (sc->sc_numcon > UVISOR_MAX_CONN)
		sc->sc_numcon = UVISOR_MAX_CONN;

	/* Attach a ucom for each connection. */
	for (i = 0; i < sc->sc_numcon; ++i) {
		switch (coninfo.connections[i].port_function_id) {
		case UVISOR_FUNCTION_GENERIC:
			uca.info = "Generic";
			break;
		case UVISOR_FUNCTION_DEBUGGER:
			uca.info = "Debugger";
			break;
		case UVISOR_FUNCTION_HOTSYNC:
			uca.info = "HotSync";
			break;
		case UVISOR_FUNCTION_REMOTE_FILE_SYS:
			uca.info = "Remote File System";
			break;
		default:
			uca.info = "unknown";
			break;
		}
		port = coninfo.connections[i].port;
		uca.portno = port;
		uca.bulkin = port | UE_DIR_IN;
		uca.bulkout = port | UE_DIR_OUT;
		/* Verify that endpoints exist. */
		for (hasin = hasout = j = 0; j < id->bNumEndpoints; j++) {
			ed = usbd_interface2endpoint_descriptor(iface, j);
			if (ed == NULL)
a298 7
			if (UE_GET_ADDR(ed->bEndpointAddress) == port &&
			    (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
				if (UE_GET_DIR(ed->bEndpointAddress)
				    == UE_DIR_IN)
					hasin++;
				else
					hasout++;
d300 26
d327 23
a349 1
		if (hasin == 1 && hasout == 1)
d352 1
a352 3
		else
			printf("%s: no proper endpoints for port %d (%d,%d)\n",
			    USBDEVNAME(sc->sc_dev), port, hasin, hasout);
d408 2
a409 1
uvisor_init(struct uvisor_softc *sc, struct uvisor_connection_info *ci)
a414 12
	char buffer[256];

	DPRINTF(("uvisor_init: getting connection info\n"));
	req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
	req.bRequest = UVISOR_GET_CONNECTION_INFORMATION;
	USETW(req.wValue, 0);
	USETW(req.wIndex, 0);
	USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
	err = usbd_do_request_flags(sc->sc_udev, &req, ci,
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
	if (err)
		return (err);
d416 2
a417 2
	if (sc->sc_flags & PALM4) {
		/* Palm OS 4.0 Hack */
d419 1
a419 1
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
d422 3
a424 2
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
d427 4
d436 2
a437 1
		err = usbd_do_request(sc->sc_udev, &req, buffer);
@


1.14
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.13 2002/11/11 02:31:51 nate Exp $	*/
/*	$NetBSD: uvisor.c,v 1.17 2002/08/13 11:38:15 augustss Exp $	*/
d161 1
d165 1
d167 4
@


1.13
log
@Another device
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.12 2002/07/25 04:07:33 nate Exp $	*/
d218 1
a218 1
	usbd_devinfo(dev, 0, devinfo);
@


1.12
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.11 2002/07/25 02:18:11 nate Exp $	*/
/*	$NetBSD: uvisor.c,v 1.16 2002/07/11 21:14:36 augustss Exp $	*/
d163 1
@


1.11
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.10 2002/07/09 17:41:02 nate Exp $	*/
/*	$NetBSD: uvisor.c,v 1.15 2002/06/16 15:01:31 augustss Exp $	*/
@


1.10
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.9 2002/07/09 17:18:48 nate Exp $	*/
d175 1
a175 1
	
d419 1
a419 1
	(void)usbd_do_request_flags(sc->sc_udev, &req, &coninfo, 
@


1.9
log
@Dont use stuff that isn't committed yet
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.7 2002/05/07 20:19:25 nate Exp $	*/
d364 1
a364 1
		  USBD_SHORT_XFER_OK, &actlen);
d420 1
a420 1
		  USBD_SHORT_XFER_OK, &actlen);
@


1.8
log
@New device From NetBSD
@
text
@d364 1
a364 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
d420 1
a420 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.7
log
@Fix uvisor for what's currently in the tree
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.6 2002/05/07 20:00:38 nate Exp $	*/
/*	$NetBSD: uvisor.c,v 1.14 2002/02/27 23:00:03 augustss Exp $	*/
d165 1
d364 1
a364 1
		  USBD_SHORT_XFER_OK, &actlen);
d420 1
a420 1
		  USBD_SHORT_XFER_OK, &actlen);
@


1.6
log
@Sync uvisor driver with NetBSD.  This adds support for PALM4 devices
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.5 2002/05/07 18:29:19 nate Exp $	*/
d363 1
a363 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
d419 1
a419 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.5
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.3 2001/05/03 02:20:35 aaron Exp $	*/
/*	$NetBSD: uvisor.c,v 1.11 2001/01/23 21:56:17 augustss Exp $	*/
a106 1

d114 6
d132 2
d154 15
d181 2
a182 5
	if (uaa->vendor == USB_VENDOR_HANDSPRING &&
	    uaa->product == USB_PRODUCT_HANDSPRING_VISOR)
		return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
d220 2
d354 1
d363 1
a363 1
				    USBD_SHORT_XFER_OK, &actlen);
d367 20
d419 1
a419 1
				    USBD_SHORT_XFER_OK, &actlen);
@


1.4
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.14 2002/02/27 23:00:03 augustss Exp $	*/
d107 1
a114 6
/*
 * Unknown PalmOS stuff.
 */
#define UVISOR_GET_PALM_INFORMATION		0x04
#define UVISOR_GET_PALM_INFORMATION_LEN		0x14

a126 2
	u_int16_t		sc_flags;

a146 15
struct uvisor_type {
	struct usb_devno	uv_dev;
	u_int16_t		uv_flags;
#define PALM4	0x0001
};
static const struct uvisor_type uvisor_devs[] = {
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, 0 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M500 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M505 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M125 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_40 }, PALM4 },
/*	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_25 }, PALM4 },*/
};
#define uvisor_lookup(v, p) ((struct uvisor_type *)usb_lookup(uvisor_devs, v, p))

d159 5
a163 2
	return (uvisor_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a200 2
	sc->sc_flags = uvisor_lookup(uaa->vendor, uaa->product)->uv_flags;

a332 1
	char buffer[256];
d341 1
a341 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
a344 20
	if (sc->sc_flags & PALM4) {
		/* Palm OS 4.0 Hack */
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
	}

d377 1
a377 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.3
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.2 2000/11/08 18:10:39 aaron Exp $	*/
/*	$NetBSD: uvisor.c,v 1.11 2001/01/23 21:56:17 augustss Exp $	*/
a106 1

d114 6
d132 2
d154 15
d181 2
a182 5
	if (uaa->vendor == USB_VENDOR_HANDSPRING &&
	    uaa->product == USB_PRODUCT_HANDSPRING_VISOR)
		return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
d220 2
d354 1
d363 1
a363 1
				    USBD_SHORT_XFER_OK, &actlen);
d367 20
d419 1
a419 1
				    USBD_SHORT_XFER_OK, &actlen);
@


1.3.6.1
log
@Sync UBC branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvisor.c,v 1.14 2002/02/27 23:00:03 augustss Exp $	*/
d107 1
a114 6
/*
 * Unknown PalmOS stuff.
 */
#define UVISOR_GET_PALM_INFORMATION		0x04
#define UVISOR_GET_PALM_INFORMATION_LEN		0x14

a126 2
	u_int16_t		sc_flags;

a146 15
struct uvisor_type {
	struct usb_devno	uv_dev;
	u_int16_t		uv_flags;
#define PALM4	0x0001
};
static const struct uvisor_type uvisor_devs[] = {
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, 0 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M500 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M505 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M125 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_40 }, PALM4 },
/*	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_25 }, PALM4 },*/
};
#define uvisor_lookup(v, p) ((struct uvisor_type *)usb_lookup(uvisor_devs, v, p))

d159 5
a163 2
	return (uvisor_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a200 2
	sc->sc_flags = uvisor_lookup(uaa->vendor, uaa->product)->uv_flags;

a332 1
	char buffer[256];
d341 1
a341 1
		  USBD_SHORT_XFER_OK, &actlen);
a344 20
	if (sc->sc_flags & PALM4) {
		/* Palm OS 4.0 Hack */
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
	}

d377 1
a377 1
		  USBD_SHORT_XFER_OK, &actlen);
@


1.3.6.2
log
@sync to -current
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.16 2002/07/11 21:14:36 augustss Exp $	*/
a164 1
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, 0 },
d174 1
a174 1

d363 1
a363 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
d418 2
a419 2
	(void)usbd_do_request_flags(sc->sc_udev, &req, &coninfo,
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.3.6.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.17 2002/08/13 11:38:15 augustss Exp $	*/
a162 1
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M515 }, PALM4 },
d217 1
a217 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.3.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.8 2000/09/03 19:15:45 augustss Exp $	*/
d97 1
d103 1
a103 1
	} connections[8];
a107 4
/* struct uvisor_connection_info.connection[x].port defines: */
#define UVISOR_ENDPOINT_1		0x01
#define UVISOR_ENDPOINT_2		0x02

d124 2
a125 1
	device_ptr_t		sc_subdev;
d130 2
a131 1
Static usbd_status uvisor_init(struct uvisor_softc *);
d172 1
d176 1
a176 1
	int i;
a205 35
	uca.bulkin = uca.bulkout = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		int addr, dir, attr;
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: could not read endpoint descriptor"
			       ": %s\n", devname, usbd_errstr(err));
			goto bad;
		}
		
		addr = ed->bEndpointAddress;
		dir = UE_GET_DIR(ed->bEndpointAddress);
		attr = ed->bmAttributes & UE_XFERTYPE;
		if (dir == UE_DIR_IN && attr == UE_BULK)
			uca.bulkin = addr;
		else if (dir == UE_DIR_OUT && attr == UE_BULK)
			uca.bulkout = addr;
		else {
			printf("%s: unexpected endpoint\n", devname);
			goto bad;
		}
	}
	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
		       USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
		       USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	
	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
d215 1
a215 1
	err = uvisor_init(sc);
d222 51
a272 2
	DPRINTF(("uvisor: in=0x%x out=0x%x\n", uca.bulkin, uca.bulkout));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
d287 1
d295 3
a297 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d309 1
d313 5
a317 3
	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
d319 5
a323 1
	return (0);
d327 1
a327 1
uvisor_init(struct uvisor_softc *sc)
a330 1
	struct uvisor_connection_info coninfo;
d340 1
a340 1
	err = usbd_do_request_flags(sc->sc_udev, &req, &coninfo, 
a343 32

#ifdef UVISOR_DEBUG
	{
		int i, np;
		char *string;

		np = UGETW(coninfo.num_ports);
		printf("%s: Number of ports: %d\n", USBDEVNAME(sc->sc_dev), np);
		for (i = 0; i < np; ++i) {
			switch (coninfo.connections[i].port_function_id) {
			case UVISOR_FUNCTION_GENERIC:
				string = "Generic";
				break;
			case UVISOR_FUNCTION_DEBUGGER:
				string = "Debugger";
				break;
			case UVISOR_FUNCTION_HOTSYNC:
				string = "HotSync";
				break;
			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
				string = "Remote File System";
				break;
			default:
				string = "unknown";
				break;	
			}
			printf("%s: port %d, is for %s\n",
			    USBDEVNAME(sc->sc_dev), coninfo.connections[i].port,
			    string);
		}
	}
#endif
@


1.3.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvisor.c,v 1.11 2001/01/23 21:56:17 augustss Exp $	*/
a96 1
#define UVISOR_MAX_CONN 8
d102 1
a102 1
	} connections[UVISOR_MAX_CONN];
d107 4
d127 1
a127 2
	device_ptr_t		sc_subdevs[UVISOR_MAX_CONN];
	int			sc_numcon;
d132 1
a132 2
Static usbd_status uvisor_init(struct uvisor_softc *,
			       struct uvisor_connection_info *);
a172 1
	struct uvisor_connection_info coninfo;
d176 1
a176 1
	int i, j, hasin, hasout, port;
d206 35
d250 1
a250 1
	err = uvisor_init(sc, &coninfo);
d257 2
a258 51
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

	sc->sc_numcon = UGETW(coninfo.num_ports);
	if (sc->sc_numcon > UVISOR_MAX_CONN)
		sc->sc_numcon = UVISOR_MAX_CONN;

	/* Attach a ucom for each connection. */
	for (i = 0; i < sc->sc_numcon; ++i) {
		switch (coninfo.connections[i].port_function_id) {
		case UVISOR_FUNCTION_GENERIC:
			uca.info = "Generic";
			break;
		case UVISOR_FUNCTION_DEBUGGER:
			uca.info = "Debugger";
			break;
		case UVISOR_FUNCTION_HOTSYNC:
			uca.info = "HotSync";
			break;
		case UVISOR_FUNCTION_REMOTE_FILE_SYS:
			uca.info = "Remote File System";
			break;
		default:
			uca.info = "unknown";
			break;
		}
		port = coninfo.connections[i].port;
		uca.portno = port;
		uca.bulkin = port | UE_DIR_IN;
		uca.bulkout = port | UE_DIR_OUT;
		/* Verify that endpoints exist. */
		for (hasin = hasout = j = 0; j < id->bNumEndpoints; j++) {
			ed = usbd_interface2endpoint_descriptor(iface, j);
			if (ed == NULL)
				break;
			if (UE_GET_ADDR(ed->bEndpointAddress) == port &&
			    (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
				if (UE_GET_DIR(ed->bEndpointAddress)
				    == UE_DIR_IN)
					hasin++;
				else
					hasout++;
			}
		}
		if (hasin == 1 && hasout == 1)
			sc->sc_subdevs[i] = config_found_sm(self, &uca,
			    ucomprint, ucomsubmatch);
		else
			printf("%s: no proper endpoints for port %d (%d,%d)\n",
			    USBDEVNAME(sc->sc_dev), port, hasin, hasout);
	}
a272 1
	int i;
d280 2
a281 3
		for (i = 0; i < sc->sc_numcon; i++)
			if (sc->sc_subdevs[i] != NULL)
				rv = config_deactivate(sc->sc_subdevs[i]);
a292 1
	int i;
d296 3
a298 5
	for (i = 0; i < sc->sc_numcon; i++) {
		if (sc->sc_subdevs[i] != NULL) {
			rv |= config_detach(sc->sc_subdevs[i], flags);
			sc->sc_subdevs[i] = NULL;
		}
d300 1
a300 5

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

	return (rv);
d304 1
a304 1
uvisor_init(struct uvisor_softc *sc, struct uvisor_connection_info *ci)
d308 1
d318 1
a318 1
	err = usbd_do_request_flags(sc->sc_udev, &req, ci,
d322 32
@


1.3.2.3
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.17 2002/08/13 11:38:15 augustss Exp $	*/
d107 1
a114 6
/*
 * Unknown PalmOS stuff.
 */
#define UVISOR_GET_PALM_INFORMATION		0x04
#define UVISOR_GET_PALM_INFORMATION_LEN		0x14

a126 2
	u_int16_t		sc_flags;

a146 17
struct uvisor_type {
	struct usb_devno	uv_dev;
	u_int16_t		uv_flags;
#define PALM4	0x0001
};
static const struct uvisor_type uvisor_devs[] = {
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, 0 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M500 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M505 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M515 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M125 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_40 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, 0 },
/*	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_25 }, PALM4 },*/
};
#define uvisor_lookup(v, p) ((struct uvisor_type *)usb_lookup(uvisor_devs, v, p))

d152 1
a152 1

d159 5
a163 2
	return (uvisor_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a200 2
	sc->sc_flags = uvisor_lookup(uaa->vendor, uaa->product)->uv_flags;

a332 1
	char buffer[256];
d341 1
a341 1
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
a344 20
	if (sc->sc_flags & PALM4) {
		/* Palm OS 4.0 Hack */
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
		req.bmRequestType = UT_READ_VENDOR_ENDPOINT;
		req.bRequest = UVISOR_GET_PALM_INFORMATION;
		USETW(req.wValue, 0);
		USETW(req.wIndex, 0);
		USETW(req.wLength, UVISOR_GET_PALM_INFORMATION_LEN);
		err = usbd_do_request(sc->sc_udev, &req, buffer);
		if (err)
			return (err);
	}

d376 2
a377 2
	(void)usbd_do_request_flags(sc->sc_udev, &req, &coninfo,
		  USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.3.2.4
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: uvisor.c,v 1.3.2.3 2003/03/28 00:38:33 niklas Exp $	*/
d218 1
a218 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
@


1.3.2.5
log
@Sync SMP branch to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvisor.c,v 1.20 2003/04/11 01:30:10 simonb Exp $	*/
a160 1
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO }, PALM4 },
a163 1
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_I705 }, PALM4 },
a164 4
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_M130 }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_Z }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_TUNGSTEN_T }, PALM4 },
	{{ USB_VENDOR_PALM, USB_PRODUCT_PALM_ZIRE }, PALM4 },
@


1.3.2.6
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uvisor.c,v 1.21 2003/08/03 21:59:26 nathanw Exp $	*/
d118 1
a118 1
#define UVISOR_GET_PALM_INFORMATION_LEN		0x44
a119 11
struct uvisor_palm_connection_info {
	uByte	num_ports;
	uByte	endpoint_numbers_different;
	uWord	reserved1;
	struct {
		uDWord	port_function_id;
		uByte	port;
		uByte	end_point_info;
		uWord	reserved;
	} connections[UVISOR_MAX_CONN];
};
d121 1
a121 1
#define UVISORIBUFSIZE 64
d138 1
a138 2
			       struct uvisor_connection_info *,
			       struct uvisor_palm_connection_info *);
a157 1
#define VISOR	0x0002
d160 1
a160 1
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_VISOR }, VISOR },
d172 1
a172 3
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_41 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_S360 }, PALM4 },
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_NX60 }, PALM4 },
a199 1
	struct uvisor_palm_connection_info palmconinfo;
a229 6
	if ((sc->sc_flags & (VISOR | PALM4)) == 0) {
		printf("%s: init failed, device type is neither visor nor palm\n", 
		    USBDEVNAME(sc->sc_dev));
		goto bad;
	}

d244 1
a244 1
	err = uvisor_init(sc, &coninfo, &palmconinfo);
d254 31
a284 19
	if (sc->sc_flags & VISOR) {
		sc->sc_numcon = UGETW(coninfo.num_ports);
		if (sc->sc_numcon > UVISOR_MAX_CONN)
			sc->sc_numcon = UVISOR_MAX_CONN;

		/* Attach a ucom for each connection. */
		for (i = 0; i < sc->sc_numcon; ++i) {
			switch (coninfo.connections[i].port_function_id) {
			case UVISOR_FUNCTION_GENERIC:
				uca.info = "Generic";
				break;
			case UVISOR_FUNCTION_DEBUGGER:
				uca.info = "Debugger";
				break;
			case UVISOR_FUNCTION_HOTSYNC:
				uca.info = "HotSync";
				break;
			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
				uca.info = "Remote File System";
d286 7
a292 23
			default:
				uca.info = "unknown";
				break;
			}
			port = coninfo.connections[i].port;
			uca.portno = port;
			uca.bulkin = port | UE_DIR_IN;
			uca.bulkout = port | UE_DIR_OUT;
			/* Verify that endpoints exist. */
			hasin = 0;
			hasout = 0;
			for (j = 0; j < id->bNumEndpoints; j++) {
				ed = usbd_interface2endpoint_descriptor(iface, j);
				if (ed == NULL)
					break;
				if (UE_GET_ADDR(ed->bEndpointAddress) == port &&
				    (ed->bmAttributes & UE_XFERTYPE) == UE_BULK) {
					if (UE_GET_DIR(ed->bEndpointAddress)
					    == UE_DIR_IN)
						hasin++;
					else
						hasout++;
				}
a293 6
			if (hasin == 1 && hasout == 1)
				sc->sc_subdevs[i] = config_found_sm(self, &uca,
				    ucomprint, ucomsubmatch);
			else
				printf("%s: no proper endpoints for port %d (%d,%d)\n",
				    USBDEVNAME(sc->sc_dev), port, hasin, hasout);
d295 1
a295 23
	} else {
		sc->sc_numcon = palmconinfo.num_ports;
		if (sc->sc_numcon > UVISOR_MAX_CONN)
			sc->sc_numcon = UVISOR_MAX_CONN;

		/* Attach a ucom for each connection. */
		for (i = 0; i < sc->sc_numcon; ++i) {
			/*
			 * XXX this should copy out 4-char string from the
			 * XXX port_function_id, but where would the string go?
			 * XXX uca.info is a const char *, not an array.
			 */
			uca.info = "sync";
			uca.portno = i;
			if (palmconinfo.endpoint_numbers_different) {
				port = palmconinfo.connections[i].end_point_info;
				uca.bulkin = (port >> 4) | UE_DIR_IN;
				uca.bulkout = (port & 0xf) | UE_DIR_OUT;
			} else {
				port = palmconinfo.connections[i].port;
				uca.bulkin = port | UE_DIR_IN;
				uca.bulkout = port | UE_DIR_OUT;
			}
d298 3
a300 1
		}
d356 1
a356 2
uvisor_init(struct uvisor_softc *sc, struct uvisor_connection_info *ci,
    struct uvisor_palm_connection_info *cpi)
d362 12
d375 2
a376 2
	if (sc->sc_flags & VISOR) {
		DPRINTF(("uvisor_init: getting Visor connection info\n"));
d378 1
a378 1
		req.bRequest = UVISOR_GET_CONNECTION_INFORMATION;
d381 2
a382 3
		USETW(req.wLength, UVISOR_CONNECTION_INFO_SIZE);
		err = usbd_do_request_flags(sc->sc_udev, &req, ci,
		    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
a384 4
	}

	if (sc->sc_flags & PALM4) {
		DPRINTF(("uvisor_init: getting Palm connection info\n"));
d390 1
a390 2
		err = usbd_do_request_flags(sc->sc_udev, &req, cpi,
		    USBD_SHORT_XFER_OK, &actlen, USBD_DEFAULT_TIMEOUT);
@


1.3.2.7
log
@Merge with the trunk
@
text
@a174 1
	{{ USB_VENDOR_HANDSPRING, USB_PRODUCT_HANDSPRING_TREO600 }, VISOR },
a187 1
	{{ USB_VENDOR_SONY, USB_PRODUCT_SONY_CLIE_TJ25 }, PALM4 },
@


1.2
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 2
a2 2
/*	$OpenBSD: uvisor.c,v 1.1 2000/07/04 11:34:31 fgsch Exp $	*/
/*	$NetBSD: uvisor.c,v 1.8 2000/09/03 19:15:45 augustss Exp $	*/
d97 1
d103 1
a103 1
	} connections[8];
a107 4
/* struct uvisor_connection_info.connection[x].port defines: */
#define UVISOR_ENDPOINT_1		0x01
#define UVISOR_ENDPOINT_2		0x02

d124 2
a125 1
	device_ptr_t		sc_subdev;
d130 2
a131 1
Static usbd_status uvisor_init(struct uvisor_softc *);
d172 1
d176 1
a176 1
	int i;
a205 35
	uca.bulkin = uca.bulkout = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		int addr, dir, attr;
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: could not read endpoint descriptor"
			       ": %s\n", devname, usbd_errstr(err));
			goto bad;
		}
		
		addr = ed->bEndpointAddress;
		dir = UE_GET_DIR(ed->bEndpointAddress);
		attr = ed->bmAttributes & UE_XFERTYPE;
		if (dir == UE_DIR_IN && attr == UE_BULK)
			uca.bulkin = addr;
		else if (dir == UE_DIR_OUT && attr == UE_BULK)
			uca.bulkout = addr;
		else {
			printf("%s: unexpected endpoint\n", devname);
			goto bad;
		}
	}
	if (uca.bulkin == -1) {
		printf("%s: Could not find data bulk in\n",
		       USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	if (uca.bulkout == -1) {
		printf("%s: Could not find data bulk out\n",
		       USBDEVNAME(sc->sc_dev));
		goto bad;
	}
	
	uca.portno = UCOM_UNK_PORTNO;
	/* bulkin, bulkout set above */
d215 1
a215 1
	err = uvisor_init(sc);
d222 51
a272 2
	DPRINTF(("uvisor: in=0x%x out=0x%x\n", uca.bulkin, uca.bulkout));
	sc->sc_subdev = config_found_sm(self, &uca, ucomprint, ucomsubmatch);
d287 1
d295 3
a297 2
		if (sc->sc_subdev != NULL)
			rv = config_deactivate(sc->sc_subdev);
d309 1
d313 5
a317 3
	if (sc->sc_subdev != NULL) {
		rv = config_detach(sc->sc_subdev, flags);
		sc->sc_subdev = NULL;
d319 5
a323 1
	return (0);
d327 1
a327 1
uvisor_init(struct uvisor_softc *sc)
a330 1
	struct uvisor_connection_info coninfo;
d340 1
a340 1
	err = usbd_do_request_flags(sc->sc_udev, &req, &coninfo, 
a343 32

#ifdef UVISOR_DEBUG
	{
		int i, np;
		char *string;

		np = UGETW(coninfo.num_ports);
		printf("%s: Number of ports: %d\n", USBDEVNAME(sc->sc_dev), np);
		for (i = 0; i < np; ++i) {
			switch (coninfo.connections[i].port_function_id) {
			case UVISOR_FUNCTION_GENERIC:
				string = "Generic";
				break;
			case UVISOR_FUNCTION_DEBUGGER:
				string = "Debugger";
				break;
			case UVISOR_FUNCTION_HOTSYNC:
				string = "HotSync";
				break;
			case UVISOR_FUNCTION_REMOTE_FILE_SYS:
				string = "Remote File System";
				break;
			default:
				string = "unknown";
				break;	
			}
			printf("%s: port %d, is for %s\n",
			    USBDEVNAME(sc->sc_dev), coninfo.connections[i].port,
			    string);
		}
	}
#endif
@


1.1
log
@handspring visor driver; from NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uvisor.c,v 1.7 2000/06/01 14:29:03 augustss Exp $	*/
d244 1
a244 1
	uca.obufsizepad = UVISOROBUFSIZE;
@

