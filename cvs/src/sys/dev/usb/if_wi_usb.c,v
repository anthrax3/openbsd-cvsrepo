head	1.68;
access;
symbols
	OPENBSD_6_2_BASE:1.68
	OPENBSD_6_1:1.68.0.8
	OPENBSD_6_1_BASE:1.68
	OPENBSD_6_0:1.68.0.6
	OPENBSD_6_0_BASE:1.68
	OPENBSD_5_9:1.68.0.2
	OPENBSD_5_9_BASE:1.68
	OPENBSD_5_8:1.66.0.4
	OPENBSD_5_8_BASE:1.66
	OPENBSD_5_7:1.64.0.2
	OPENBSD_5_7_BASE:1.64
	OPENBSD_5_6:1.63.0.4
	OPENBSD_5_6_BASE:1.63
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.57.0.2
	OPENBSD_5_4_BASE:1.57
	OPENBSD_5_3:1.55.0.6
	OPENBSD_5_3_BASE:1.55
	OPENBSD_5_2:1.55.0.4
	OPENBSD_5_2_BASE:1.55
	OPENBSD_5_1_BASE:1.55
	OPENBSD_5_1:1.55.0.2
	OPENBSD_5_0:1.53.0.2
	OPENBSD_5_0_BASE:1.53
	OPENBSD_4_9:1.50.0.2
	OPENBSD_4_9_BASE:1.50
	OPENBSD_4_8:1.47.0.2
	OPENBSD_4_8_BASE:1.47
	OPENBSD_4_7:1.46.0.2
	OPENBSD_4_7_BASE:1.46
	OPENBSD_4_6:1.45.0.6
	OPENBSD_4_6_BASE:1.45
	OPENBSD_4_5:1.45.0.2
	OPENBSD_4_5_BASE:1.45
	OPENBSD_4_4:1.44.0.4
	OPENBSD_4_4_BASE:1.44
	OPENBSD_4_3:1.44.0.2
	OPENBSD_4_3_BASE:1.44
	OPENBSD_4_2:1.42.0.2
	OPENBSD_4_2_BASE:1.42
	OPENBSD_4_1:1.33.0.2
	OPENBSD_4_1_BASE:1.33
	OPENBSD_4_0:1.30.0.4
	OPENBSD_4_0_BASE:1.30
	OPENBSD_3_9:1.29.0.2
	OPENBSD_3_9_BASE:1.29
	OPENBSD_3_8:1.19.0.2
	OPENBSD_3_8_BASE:1.19
	OPENBSD_3_7:1.18.0.2
	OPENBSD_3_7_BASE:1.18
	OPENBSD_3_6:1.13.0.4
	OPENBSD_3_6_BASE:1.13
	SMP_SYNC_A:1.10
	SMP_SYNC_B:1.10
	OPENBSD_3_5:1.10.0.2
	OPENBSD_3_5_BASE:1.10
	SMP:1.7.0.2;
locks; strict;
comment	@ * @;


1.68
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.67;
commitid	5gdEnqVoJuTuwdTu;

1.67
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.66;
commitid	5DvsamK0GblTp8ww;

1.66
date	2015.06.12.15.47.31;	author mpi;	state Exp;
branches;
next	1.65;
commitid	t0sjCnxjbRqHxJe2;

1.65
date	2015.06.10.20.50.05;	author miod;	state Exp;
branches;
next	1.64;
commitid	MQR5kHnk6hKSfZ87;

1.64
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.63;
commitid	Z1vcFtHO8wRH0yRt;

1.63
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.62;
commitid	Pclvgy2Z4XV9hveD;

1.62
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.61;
commitid	OBNa5kfxQ2UXoiIw;

1.61
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.60;
commitid	b0VSac5dnnsxcDao;

1.60
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.59;

1.59
date	2013.11.11.15.00.35;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2013.08.07.01.06.43;	author bluhm;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.55;

1.55
date	2011.12.03.03.34.40;	author krw;	state Exp;
branches;
next	1.54;

1.54
date	2011.09.18.23.24.12;	author krw;	state Exp;
branches;
next	1.53;

1.53
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.52;

1.52
date	2011.06.22.16.44.29;	author tedu;	state Exp;
branches;
next	1.51;

1.51
date	2011.06.17.07.06.47;	author mk;	state Exp;
branches;
next	1.50;

1.50
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.47;

1.47
date	2010.07.02.03.13.42;	author tedu;	state Exp;
branches;
next	1.46;

1.46
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.45;

1.45
date	2009.02.14.20.05.09;	author chl;	state Exp;
branches;
next	1.44;

1.44
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.43;

1.43
date	2007.09.12.18.45.14;	author mk;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.37;

1.37
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.36;

1.36
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.35;

1.35
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.34;

1.34
date	2007.04.01.18.02.49;	author ray;	state Exp;
branches;
next	1.33;

1.33
date	2006.11.26.19.46.28;	author deraadt;	state Exp;
branches;
next	1.32;

1.32
date	2006.10.24.18.20.46;	author moritz;	state Exp;
branches;
next	1.31;

1.31
date	2006.10.16.12.30.08;	author tom;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.29;

1.29
date	2006.02.06.17.29.11;	author jmc;	state Exp;
branches;
next	1.28;

1.28
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.27;

1.27
date	2006.01.25.20.58.12;	author grange;	state Exp;
branches;
next	1.26;

1.26
date	2005.12.03.21.11.48;	author brad;	state Exp;
branches;
next	1.25;

1.25
date	2005.11.24.14.31.40;	author grange;	state Exp;
branches;
next	1.24;

1.24
date	2005.11.19.08.23.41;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2005.10.31.05.37.13;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2005.10.20.21.46.07;	author fgsch;	state Exp;
branches;
next	1.21;

1.21
date	2005.10.16.08.47.50;	author fgsch;	state Exp;
branches;
next	1.20;

1.20
date	2005.10.15.00.23.36;	author fgsch;	state Exp;
branches;
next	1.19;

1.19
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.18;

1.18
date	2005.02.18.06.47.03;	author jsg;	state Exp;
branches;
next	1.17;

1.17
date	2005.01.15.03.59.39;	author jsg;	state Exp;
branches;
next	1.16;

1.16
date	2004.11.23.21.12.23;	author fgsch;	state Exp;
branches;
next	1.15;

1.15
date	2004.10.20.12.59.13;	author jsg;	state Exp;
branches;
next	1.14;

1.14
date	2004.10.17.22.31.19;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.08.05.05.17.58;	author dlg;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.16.19.54.20;	author pedro;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.03.16.05.51.55;	author tedu;	state Exp;
branches;
next	1.9;

1.9
date	2004.03.15.16.10.07;	author drahn;	state Exp;
branches;
next	1.8;

1.8
date	2004.02.27.17.30.50;	author henning;	state Exp;
branches;
next	1.7;

1.7
date	2004.01.13.16.53.36;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2003.12.23.21.52.52;	author drahn;	state Exp;
branches;
next	1.5;

1.5
date	2003.12.05.02.23.42;	author drahn;	state Exp;
branches;
next	1.4;

1.4
date	2003.11.09.20.54.19;	author drahn;	state Exp;
branches;
next	1.3;

1.3
date	2003.11.08.19.17.28;	author jmc;	state Exp;
branches;
next	1.2;

1.2
date	2003.10.26.15.46.37;	author drahn;	state Exp;
branches;
next	1.1;

1.1
date	2003.10.26.15.34.16;	author drahn;	state Exp;
branches;
next	;

1.7.2.1
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2004.06.05.23.12.58;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.68
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@/*	$OpenBSD: if_wi_usb.c,v 1.67 2015/11/24 13:33:18 mpi Exp $ */

/*
 * Copyright (c) 2003 Dale Rahn. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * Effort sponsored in part by the Defense Advanced Research Projects
 * Agency (DARPA) and Air Force Research Laboratory, Air Force
 * Materiel Command, USAF, under agreement number F30602-01-2-0537.
 */
#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/malloc.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/device.h>
#include <sys/timeout.h>
#include <sys/kthread.h>
#include <sys/tree.h>

#include <net/if.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#define ROUNDUP64(x) (((x)+63) & ~63)

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_ioctl.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <machine/bus.h>

#include <dev/ic/if_wireg.h>
#include <dev/ic/if_wi_ieee.h>
#include <dev/ic/if_wivar.h>

#include <dev/usb/if_wi_usb.h>

int wi_usb_do_transmit_sync(struct wi_usb_softc *wsc, struct wi_usb_chain *c, 
    void *ident);
void wi_usb_txeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void wi_usb_txeof_frm(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void wi_usb_rxeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void wi_usb_intr(struct usbd_xfer *xfer, void *priv,
    usbd_status status);
void wi_usb_stop(struct wi_usb_softc *usc);
int wi_usb_tx_list_init(struct wi_usb_softc *usc);
int wi_usb_rx_list_init(struct wi_usb_softc *usc);
int wi_usb_open_pipes(struct wi_usb_softc *usc);
void wi_usb_cmdresp(struct wi_usb_chain *c);
void wi_usb_rridresp(struct wi_usb_chain *c);
void wi_usb_wridresp(struct wi_usb_chain *c);
void wi_usb_infofrm(struct wi_usb_chain *c, int len);
int wi_send_packet(struct wi_usb_softc *sc, int id);
void wi_usb_rxfrm(struct wi_usb_softc *usc, wi_usb_usbin *uin, int total_len);
void wi_usb_txfrm(struct wi_usb_softc *usc, wi_usb_usbin *uin, int total_len);
void wi_usb_start_thread(void *);

int wi_usb_tx_lock_try(struct wi_usb_softc *sc);
void wi_usb_tx_lock(struct wi_usb_softc *usc);
void wi_usb_tx_unlock(struct wi_usb_softc *usc);
void wi_usb_ctl_lock(struct wi_usb_softc *usc);
void wi_usb_ctl_unlock(struct wi_usb_softc *usc);

void wi_dump_data(void *buffer, int len);

void wi_usb_thread(void *arg);

#ifdef WI_USB_DEBUG
#define DPRINTF(x)      do { if (wi_usbdebug) printf x; } while (0)
#define DPRINTFN(n,x)   do { if (wi_usbdebug >= (n)) printf x; } while (0)
int     wi_usbdebug = 1;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct wi_usb_thread_info {
	int status;
	int dying;
	int idle;
};

/* thread status flags */
#define WI_START	0x01
#define WI_DYING	0x02
#define WI_INQUIRE	0x04
#define WI_WATCHDOG	0x08


struct wi_usb_softc {
	struct wi_softc		sc_wi;
#define wi_usb_dev sc_wi.sc_dev

	struct timeout		wi_usb_stat_ch;

	struct usbd_device	*wi_usb_udev;
	struct usbd_interface	*wi_usb_iface;
	u_int16_t		wi_usb_vendor;
	u_int16_t		wi_usb_product;
	int			wi_usb_ed[WI_USB_ENDPT_MAX];
	struct usbd_pipe	*wi_usb_ep[WI_USB_ENDPT_MAX];

	struct wi_usb_chain	wi_usb_tx_chain[WI_USB_TX_LIST_CNT];
	struct wi_usb_chain	wi_usb_rx_chain[WI_USB_RX_LIST_CNT];

	int			wi_usb_refcnt;
	char			wi_usb_attached;
	int			wi_usb_intr_errs;
	struct timeval		wi_usb_rx_notice;

	int			wi_usb_pollpending;

	wi_usb_usbin		wi_usb_ibuf;
	int			wi_usb_tx_prod;
	int			wi_usb_tx_cons;
	int			wi_usb_tx_cnt;
	int			wi_usb_rx_prod;

	struct wi_ltv_gen	*ridltv;
	int			ridresperr;

	int			cmdresp;
	int			cmdresperr;
	int			txresp;
	int			txresperr;

	/* nummem (tx/mgmt) */
	int			wi_usb_nummem;
#define MAX_WI_NMEM 3
	void			*wi_usb_txmem[MAX_WI_NMEM];
	int			wi_usb_txmemsize[MAX_WI_NMEM];
	void			*wi_usb_rxmem;
	int			wi_usb_rxmemsize;

	void			*wi_info;
	void			*wi_rxframe;

	/* prevent multiple outstanding USB requests */
	int			wi_lock;
	int			wi_lockwait;

	/* prevent multiple command requests */
	int			wi_ctllock;
	int			wi_ctllockwait;
	struct proc		*wi_curproc;

	/* kthread */
	struct wi_usb_thread_info	*wi_thread_info;
	int			wi_resetonce;
};

struct wi_funcs wi_func_usb = {
        wi_cmd_usb,
        wi_read_record_usb,
        wi_write_record_usb,
        wi_alloc_nicmem_usb,
        wi_read_data_usb,
        wi_write_data_usb,
        wi_get_fid_usb,
        wi_init_usb,

        wi_start_usb,
        wi_ioctl_usb,
        wi_watchdog_usb,
        wi_inquire_usb,
};

/*
 * Various supported device vendors/products.
 */
const struct wi_usb_type {
	struct usb_devno	wi_usb_device;
	u_int16_t	wi_usb_flags;
	/* XXX */
} wi_usb_devs[] = {
	{{ USB_VENDOR_ACCTON, USB_PRODUCT_ACCTON_111 }, 0 },
	{{ USB_VENDOR_ACERW, USB_PRODUCT_ACERW_WARPLINK }, 0 },
	{{ USB_VENDOR_ACTIONTEC, USB_PRODUCT_ACTIONTEC_FREELAN }, 0 },
	{{ USB_VENDOR_ACTIONTEC, USB_PRODUCT_ACTIONTEC_PRISM_25 }, 0 },
	{{ USB_VENDOR_ACTIONTEC, USB_PRODUCT_ACTIONTEC_PRISM_25A }, 0 },
	{{ USB_VENDOR_ADAPTEC, USB_PRODUCT_ADAPTEC_AWN8020 }, 0 },
	{{ USB_VENDOR_AMBIT, USB_PRODUCT_AMBIT_WLAN }, 0 },
	{{ USB_VENDOR_ASUSTEK, USB_PRODUCT_ASUSTEK_WL140 }, 0 },
	{{ USB_VENDOR_AVERATEC, USB_PRODUCT_AVERATEC_USBWLAN }, 0 },
	{{ USB_VENDOR_COMPAQ, USB_PRODUCT_COMPAQ_W100 }, 0 },
	{{ USB_VENDOR_COMPAQ, USB_PRODUCT_COMPAQ_W200 }, 0 },
	{{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_WLANUSB }, 0 },
	{{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_WLUSB_11_KEY }, 0 },
	{{ USB_VENDOR_DELL, USB_PRODUCT_DELL_TM1180 }, 0 },
	{{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DWL120F }, 0 },
	{{ USB_VENDOR_DLINK, USB_PRODUCT_DLINK_DWL122 }, 0 },
	{{ USB_VENDOR_INTEL, USB_PRODUCT_INTEL_I2011B }, 0 },
	{{ USB_VENDOR_INTERSIL, USB_PRODUCT_INTERSIL_PRISM_2X }, 0 },
	{{ USB_VENDOR_IODATA, USB_PRODUCT_IODATA_USBWNB11 }, 0 },
	{{ USB_VENDOR_JVC, USB_PRODUCT_JVC_MP_XP7250_WL }, 0 },
	{{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_WUSB11_25 }, 0 },
	{{ USB_VENDOR_LINKSYS, USB_PRODUCT_LINKSYS_WUSB12_11 }, 0 },
	{{ USB_VENDOR_LINKSYS3, USB_PRODUCT_LINKSYS3_WUSB11V30 }, 0 },
	{{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_KB11 }, 0 },
	{{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_KS11G }, 0 },
	{{ USB_VENDOR_MELCO, USB_PRODUCT_MELCO_S11 }, 0 },
	{{ USB_VENDOR_MICROSOFT, USB_PRODUCT_MICROSOFT_MN510 }, 0 },
	{{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_MA111NA }, 0 },
	{{ USB_VENDOR_PHEENET, USB_PRODUCT_PHEENET_WL503IA }, 0 },
	{{ USB_VENDOR_PHEENET, USB_PRODUCT_PHEENET_WM168B }, 0 },
	{{ USB_VENDOR_PLANEX, USB_PRODUCT_PLANEX_GW_US11H }, 0 },
	{{ USB_VENDOR_SIEMENS, USB_PRODUCT_SIEMENS_SPEEDSTREAM22 }, 0 },
	{{ USB_VENDOR_SITECOM2, USB_PRODUCT_SITECOM2_WL022 }, 0 },
	{{ USB_VENDOR_TEKRAM, USB_PRODUCT_TEKRAM_0193 }, 0 },
	{{ USB_VENDOR_TEKRAM, USB_PRODUCT_TEKRAM_ZYAIR_B200 }, 0 },
	{{ USB_VENDOR_USR, USB_PRODUCT_USR_USR1120 }, 0 },
	{{ USB_VENDOR_VIEWSONIC, USB_PRODUCT_VIEWSONIC_AIRSYNC }, 0 },
	{{ USB_VENDOR_ZCOM, USB_PRODUCT_ZCOM_XI725 }, 0 },
	{{ USB_VENDOR_ZCOM, USB_PRODUCT_ZCOM_XI735 }, 0 }
};
#define wi_usb_lookup(v, p) ((struct wi_usb_type *)usb_lookup(wi_usb_devs, v, p))

int wi_usb_match(struct device *, void *, void *);
void wi_usb_attach(struct device *, struct device *, void *);
int wi_usb_detach(struct device *, int);

struct cfdriver wi_usb_cd = {
	NULL, "wi_usb", DV_IFNET
};

const struct cfattach wi_usb_ca = {
	sizeof(struct wi_usb_softc), wi_usb_match, wi_usb_attach, wi_usb_detach
};

int
wi_usb_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg	*uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return (wi_usb_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}


/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
wi_usb_attach(struct device *parent, struct device *self, void *aux)
{
	struct wi_usb_softc	*sc = (struct wi_usb_softc *)self;
	struct usb_attach_arg	*uaa = aux;
/*	int			s; */
	struct usbd_device	*dev = uaa->device;
	struct usbd_interface	*iface = uaa->iface;
	usb_interface_descriptor_t	*id;
	usb_endpoint_descriptor_t	*ed;
	int			 i;

	DPRINTFN(5,(" : wi_usb_attach: sc=%p", sc));

	/* XXX - any tasks? */

	/* XXX - flags? */

	sc->wi_usb_udev = dev;
	sc->wi_usb_iface = iface;
	sc->wi_usb_product = uaa->product;
	sc->wi_usb_vendor = uaa->vendor;

	sc->sc_wi.wi_usb_cdata = sc;
	sc->sc_wi.wi_flags |= WI_FLAGS_BUS_USB;

	sc->wi_lock = 0;
	sc->wi_lockwait = 0;
	sc->wi_resetonce = 0;

	id = usbd_get_interface_descriptor(iface);

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(iface, i);
		if (ed == NULL) {
			printf("%s: couldn't get endpoint descriptor %d\n",
			    sc->wi_usb_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->wi_usb_ed[WI_USB_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->wi_usb_ed[WI_USB_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->wi_usb_ed[WI_USB_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	sc->wi_usb_nummem = 0;

	/* attach wi device */

	if (wi_usb_rx_list_init(sc)) {
		printf("%s: rx list init failed\n",
		    sc->wi_usb_dev.dv_xname);
		return;
	}
	if (wi_usb_tx_list_init(sc)) {
		printf("%s: tx list init failed\n",
		    sc->wi_usb_dev.dv_xname);
		return;
	}

	if (wi_usb_open_pipes(sc)){
		printf("%s: open pipes failed\n",
		    sc->wi_usb_dev.dv_xname);
		return;
	}

	sc->wi_usb_attached = 1;

	kthread_create_deferred(wi_usb_start_thread, sc);
}

int
wi_usb_detach(struct device *self, int flags)
{
	struct wi_usb_softc	*sc = (struct wi_usb_softc *)self;
	struct ifnet		*ifp = WI_GET_IFP(sc);
	struct wi_softc		*wsc = &sc->sc_wi;
	int s;
	int err;

	/* Detached before attach finished, so just bail out. */
	if (!sc->wi_usb_attached)
		return (0);

	if (sc->wi_thread_info != NULL) {
		sc->wi_thread_info->dying = 1;

		sc->wi_thread_info->status |= WI_DYING;
		if (sc->wi_thread_info->idle)
			wakeup(sc->wi_thread_info);
	}

	/* tasks? */

	s = splusb();
	/* detach wi */

	if (!(wsc->wi_flags & WI_FLAGS_ATTACHED)) {
		printf("%s: already detached\n", sc->wi_usb_dev.dv_xname);
		splx(s);
		return (0);
	}

	wi_detach(&sc->sc_wi);

	wsc->wi_flags = 0;

	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

	sc->wi_usb_attached = 0;

	if (--sc->wi_usb_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->wi_usb_dev);
	}

	while (sc->wi_usb_nummem) {
		sc->wi_usb_nummem--;
		if (sc->wi_usb_txmem[sc->wi_usb_nummem] != NULL)
			free(sc->wi_usb_txmem[sc->wi_usb_nummem], M_DEVBUF, 0);
		sc->wi_usb_txmem[sc->wi_usb_nummem] = NULL;
	}

	if (sc->wi_usb_ep[WI_USB_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_INTR] = NULL;
	}
	if (sc->wi_usb_ep[WI_USB_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_TX]);
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_TX] = NULL;
	}
	if (sc->wi_usb_ep[WI_USB_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_RX]);
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_RX] = NULL;
	}

	splx(s);

	return (0);
}

int
wi_send_packet(struct wi_usb_softc *sc, int id)
{
	struct wi_usb_chain	*c;
	struct wi_frame		*wibuf;
	int			total_len, rnd_len;
	int			err;

	c = &sc->wi_usb_tx_chain[0];

	DPRINTFN(10,("%s: %s: id=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, id));

	/* assemble packet from write_data buffer */
	if (id == 0 || id == 1) {
		/* tx_lock acquired before wi_start() */
		wibuf = sc->wi_usb_txmem[id];

		total_len = sizeof (struct wi_frame) +
		    letoh16(wibuf->wi_dat_len);
		rnd_len = ROUNDUP64(total_len);
		if ((total_len > sc->wi_usb_txmemsize[id]) ||
		   (rnd_len > WI_USB_BUFSZ )){
			printf("invalid packet len: %x memsz %x max %x\n",
			    total_len, sc->wi_usb_txmemsize[id], WI_USB_BUFSZ);

			err = EIO;
			goto err_ret;
		}

		sc->txresp = WI_CMD_TX;
		sc->txresperr = 0;

		bcopy(wibuf, c->wi_usb_buf, total_len);

		bzero(((char *)c->wi_usb_buf)+total_len,
		    rnd_len - total_len);

		/* zero old packet for next TX */
		bzero(wibuf, total_len);

		total_len = rnd_len;

		DPRINTFN(5,("%s: %s: id=%x len=%x\n",
		    sc->wi_usb_dev.dv_xname, __func__, id, total_len));

		usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_TX],
		    c, c->wi_usb_buf, rnd_len,
		    USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
		    WI_USB_TX_TIMEOUT, wi_usb_txeof_frm);

		err = usbd_transfer(c->wi_usb_xfer);
		if (err != USBD_IN_PROGRESS && err != USBD_NORMAL_COMPLETION) {
			printf("%s: %s: error=%s\n",
			    sc->wi_usb_dev.dv_xname, __func__,
			    usbd_errstr(err));
			/* Stop the interface from process context. */
			wi_usb_stop(sc);
			err = EIO;
		} else {
			err = 0;
		}

		DPRINTFN(5,("%s: %s: exit err=%x\n",
		    sc->wi_usb_dev.dv_xname, __func__, err));
err_ret:
		return err;
	}
	printf("%s:%s: invalid packet id sent %x\n",
	    sc->wi_usb_dev.dv_xname, __func__, id);
	return 0;
}

int
wi_cmd_usb(struct wi_softc *wsc, int cmd, int val0, int val1, int val2)
{
	struct wi_usb_chain	*c;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;
	struct wi_cmdreq	*pcmd;
	int			total_len, rnd_len;
	int			err;

	DPRINTFN(5,("%s: %s: enter cmd=%x %x %x %x\n",
	    sc->wi_usb_dev.dv_xname, __func__, cmd, val0, val1, val2));

	if ((cmd & WI_CMD_CODE_MASK) == WI_CMD_TX) {
		return wi_send_packet(sc, val0);
	}


	if ((cmd & WI_CMD_CODE_MASK) == WI_CMD_INI) {
		/* free alloc_nicmem regions */
		while (sc->wi_usb_nummem) {
			sc->wi_usb_nummem--;
			free(sc->wi_usb_txmem[sc->wi_usb_nummem], M_DEVBUF, 0);
			sc->wi_usb_txmem[sc->wi_usb_nummem] = NULL;
		}

#if 0
		/* if this is the first time, init, otherwise do not?? */
		if (sc->wi_resetonce) {
			return 0;
		} else
			sc->wi_resetonce = 1;
#endif
	}

	wi_usb_ctl_lock(sc);

	wi_usb_tx_lock(sc);

	c = &sc->wi_usb_tx_chain[0];
	pcmd = c->wi_usb_buf;


	total_len = sizeof (struct wi_cmdreq);
	rnd_len = ROUNDUP64(total_len);
	if (rnd_len > WI_USB_BUFSZ) {
		printf("read_record buf size err %x %x\n", 
		    rnd_len, WI_USB_BUFSZ);
		err = EIO;
		goto err_ret;
	}

	sc->cmdresp = cmd;
	sc->cmdresperr = 0;

	pcmd->type = htole16(WI_USB_CMDREQ);
	pcmd->cmd  = htole16(cmd);
	pcmd->param0  = htole16(val0);
	pcmd->param1  = htole16(val1);
	pcmd->param2  = htole16(val2);

	bzero(((char*)pcmd)+total_len, rnd_len - total_len);

	usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_TX],
	    c, c->wi_usb_buf, rnd_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    WI_USB_TX_TIMEOUT, wi_usb_txeof);

	err = wi_usb_do_transmit_sync(sc, c, &sc->cmdresperr);

	if (err == 0)
		err = sc->cmdresperr;

	sc->cmdresperr = 0;

err_ret:
	wi_usb_tx_unlock(sc);

	wi_usb_ctl_unlock(sc);

	DPRINTFN(5,("%s: %s: exit err=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, err));
	return err;
}


int
wi_read_record_usb(struct wi_softc *wsc, struct wi_ltv_gen *ltv)
{
	struct wi_usb_chain	*c;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;
	struct wi_rridreq	*prid;
	int			total_len, rnd_len;
	int			err;
	struct wi_ltv_gen	*oltv = NULL, p2ltv;

	DPRINTFN(5,("%s: %s: enter rid=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, ltv->wi_type));

	/* Do we need to deal with these here, as in _io version?
	 * WI_RID_ENCRYPTION -> WI_RID_P2_ENCRYPTION
	 * WI_RID_TX_CRYPT_KEY -> WI_RID_P2_TX_CRYPT_KEY
	 */
	if (wsc->sc_firmware_type != WI_LUCENT) {
		oltv = ltv;
		switch (ltv->wi_type) {
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			ltv = &p2ltv;
			break;
		}
	}

	wi_usb_tx_lock(sc);

	c = &sc->wi_usb_tx_chain[0];
	prid = c->wi_usb_buf;

	total_len = sizeof(struct wi_rridreq);
	rnd_len = ROUNDUP64(total_len);

	if (rnd_len > WI_USB_BUFSZ) {
		printf("read_record buf size err %x %x\n", 
		    rnd_len, WI_USB_BUFSZ);
		wi_usb_tx_unlock(sc);
		return EIO;
	}

	sc->ridltv = ltv;
	sc->ridresperr = 0;

	prid->type = htole16(WI_USB_RRIDREQ);
	prid->frmlen = htole16(2);	/* variable size? */
	prid->rid  = htole16(ltv->wi_type);

	bzero(((char*)prid)+total_len, rnd_len - total_len);

	usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_TX],
	    c, c->wi_usb_buf, rnd_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    WI_USB_TX_TIMEOUT, wi_usb_txeof);

	DPRINTFN(10,("%s: %s: total_len=%x, wilen %d\n",
	    sc->wi_usb_dev.dv_xname, __func__, total_len, ltv->wi_len));

	err = wi_usb_do_transmit_sync(sc, c, &sc->ridresperr);

	/* Do we need to deal with these here, as in _io version?
	 *
	 * WI_RID_TX_RATE
	 * WI_RID_CUR_TX_RATE
	 * WI_RID_ENCRYPTION
	 * WI_RID_TX_CRYPT_KEY
	 * WI_RID_CNFAUTHMODE
	 */
	if (ltv->wi_type == WI_RID_PORTTYPE && wsc->wi_ptype == WI_PORTTYPE_IBSS
	    && ltv->wi_val == wsc->wi_ibss_port) {
		/*
		 * Convert vendor IBSS port type to WI_PORTTYPE_IBSS.
		 * Since Lucent uses port type 1 for BSS *and* IBSS we
		 * have to rely on wi_ptype to distinguish this for us.
		 */
		ltv->wi_val = htole16(WI_PORTTYPE_IBSS);
	} else if (wsc->sc_firmware_type != WI_LUCENT) {
		int v;

		switch (oltv->wi_type) {
		case WI_RID_TX_RATE:
		case WI_RID_CUR_TX_RATE:
			switch (letoh16(ltv->wi_val)) {
			case 1: v = 1; break;
			case 2: v = 2; break;
			case 3:	v = 6; break;
			case 4: v = 5; break;
			case 7: v = 7; break;
			case 8: v = 11; break;
			case 15: v = 3; break;
			default: v = 0x100 + letoh16(ltv->wi_val); break;
			}
			oltv->wi_val = htole16(v);
			break;
		case WI_RID_ENCRYPTION:
			oltv->wi_len = 2;
			if (ltv->wi_val & htole16(0x01))
				oltv->wi_val = htole16(1);
			else
				oltv->wi_val = htole16(0);
			break;
		case WI_RID_TX_CRYPT_KEY:
		case WI_RID_CNFAUTHMODE:
			oltv->wi_len = 2;
			oltv->wi_val = ltv->wi_val;
			break;
		}
	}

	if (err == 0)
		err = sc->ridresperr;

	sc->ridresperr = 0;

	wi_usb_tx_unlock(sc);

	DPRINTFN(5,("%s: %s: exit err=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, err));
	return err;
}

int
wi_write_record_usb(struct wi_softc *wsc, struct wi_ltv_gen *ltv)
{
	struct wi_usb_chain	*c;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;
	struct wi_wridreq	*prid;
	int			total_len, rnd_len;
	int			err;
	struct wi_ltv_gen	p2ltv;
	u_int16_t		val = 0;
	int			i;

	DPRINTFN(5,("%s: %s: enter rid=%x wi_len %d copying %x\n",
	    sc->wi_usb_dev.dv_xname, __func__, ltv->wi_type, ltv->wi_len,
	    (ltv->wi_len-1)*2 ));

	/* Do we need to deal with these here, as in _io version?
	 * WI_PORTTYPE_IBSS -> WI_RID_PORTTYPE
	 * RID_TX_RATE munging
	 * RID_ENCRYPTION
	 * WI_RID_TX_CRYPT_KEY
	 * WI_RID_DEFLT_CRYPT_KEYS
	 */
	if (ltv->wi_type == WI_RID_PORTTYPE &&
	    letoh16(ltv->wi_val) == WI_PORTTYPE_IBSS) {
		/* Convert WI_PORTTYPE_IBSS to vendor IBSS port type. */
		p2ltv.wi_type = WI_RID_PORTTYPE;
		p2ltv.wi_len = 2;
		p2ltv.wi_val = wsc->wi_ibss_port;
		ltv = &p2ltv;
	} else if (wsc->sc_firmware_type != WI_LUCENT) {
		int v;

		switch (ltv->wi_type) {
		case WI_RID_TX_RATE:
			p2ltv.wi_type = WI_RID_TX_RATE;
			p2ltv.wi_len = 2;
			switch (letoh16(ltv->wi_val)) {
			case 1: v = 1; break;
			case 2: v = 2; break;
			case 3:	v = 15; break;
			case 5: v = 4; break;
			case 6: v = 3; break;
			case 7: v = 7; break;
			case 11: v = 8; break;
			default: return EINVAL;
			}
			p2ltv.wi_val = htole16(v);
			ltv = &p2ltv;
			break;
		case WI_RID_ENCRYPTION:
			p2ltv.wi_type = WI_RID_P2_ENCRYPTION;
			p2ltv.wi_len = 2;
			if (ltv->wi_val & htole16(0x01)) {
				val = PRIVACY_INVOKED;
				/*
				 * If using shared key WEP we must set the
				 * EXCLUDE_UNENCRYPTED bit.  Symbol cards
				 * need this bit set even when not using
				 * shared key. We can't just test for
				 * IEEE80211_AUTH_SHARED since Symbol cards
				 * have 2 shared key modes.
				 */
				if (wsc->wi_authtype != IEEE80211_AUTH_OPEN ||
				    wsc->sc_firmware_type == WI_SYMBOL)
					val |= EXCLUDE_UNENCRYPTED;

				switch (wsc->wi_crypto_algorithm) {
				case WI_CRYPTO_FIRMWARE_WEP:
					/*
					 * TX encryption is broken in
					 * Host AP mode.
					 */
					if (wsc->wi_ptype == WI_PORTTYPE_HOSTAP)
						val |= HOST_ENCRYPT;
					break;
				case WI_CRYPTO_SOFTWARE_WEP:
					val |= HOST_ENCRYPT|HOST_DECRYPT;
					break;
				}
				p2ltv.wi_val = htole16(val);
			} else
				p2ltv.wi_val = htole16(HOST_ENCRYPT | HOST_DECRYPT);
			ltv = &p2ltv;
			break;
		case WI_RID_TX_CRYPT_KEY:
			if (ltv->wi_val > WI_NLTV_KEYS)
				return (EINVAL);
			p2ltv.wi_type = WI_RID_P2_TX_CRYPT_KEY;
			p2ltv.wi_len = 2;
			p2ltv.wi_val = ltv->wi_val;
			ltv = &p2ltv;
			break;
		case WI_RID_DEFLT_CRYPT_KEYS: {
				int error;
				int keylen;
				struct wi_ltv_str ws;
				struct wi_ltv_keys *wk;

				wk = (struct wi_ltv_keys *)ltv;
				keylen = wk->wi_keys[wsc->wi_tx_key].wi_keylen;
				keylen = letoh16(keylen);

				for (i = 0; i < 4; i++) {
					bzero(&ws, sizeof(ws));
					ws.wi_len = (keylen > 5) ? 8 : 4;
					ws.wi_type = WI_RID_P2_CRYPT_KEY0 + i;
					bcopy(&wk->wi_keys[i].wi_keydat,
					    ws.wi_str, keylen);
					error = wi_write_record_usb(wsc,
					    (struct wi_ltv_gen *)&ws);
					if (error)
						return (error);
				}
			}
			return (0);
		}
	}

	wi_usb_tx_lock(sc);

	c = &sc->wi_usb_tx_chain[0];

	prid = c->wi_usb_buf;

	total_len = sizeof(prid->type) + sizeof(prid->frmlen) +
	    sizeof(prid->rid) + (ltv->wi_len-1)*2;
	rnd_len = ROUNDUP64(total_len);
	if (rnd_len > WI_USB_BUFSZ) {
		printf("write_record buf size err %x %x\n", 
		    rnd_len, WI_USB_BUFSZ);
		wi_usb_tx_unlock(sc);
		return EIO;
	}

	prid->type = htole16(WI_USB_WRIDREQ);
	prid->frmlen = htole16(ltv->wi_len);
	prid->rid  = htole16(ltv->wi_type);
	if (ltv->wi_len > 1)
		bcopy(&ltv->wi_val, &prid->data[0], (ltv->wi_len-1)*2);

	bzero(((char*)prid)+total_len, rnd_len - total_len);

	usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_TX],
	    c, c->wi_usb_buf, rnd_len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    WI_USB_TX_TIMEOUT, wi_usb_txeof);

	err = wi_usb_do_transmit_sync(sc, c, &sc->ridresperr);

	if (err == 0)
		err = sc->ridresperr;

	sc->ridresperr = 0;

	wi_usb_tx_unlock(sc);

	DPRINTFN(5,("%s: %s: exit err=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, err));
	return err;
}

/*
 * This is an ugly compat portion to emulate the I/O which writes
 * a packet or management information
 * The data is copied into local memory for the requested
 * 'id' then on the wi_cmd WI_CMD_TX, the id argument
 * will identify which buffer to use
 */
int
wi_alloc_nicmem_usb(struct wi_softc *wsc, int len, int *id)
{
	int nmem;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;

	DPRINTFN(10,("%s: %s: enter len=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, len));

	/*
	 * NOTE THIS IS A USB DEVICE WHICH WILL LIKELY HAVE MANY
	 * CONNECTS/DISCONNECTS, FREE THIS MEMORY XXX XXX XXX !!! !!!
	 */
	nmem = sc->wi_usb_nummem++;

	if (nmem >= MAX_WI_NMEM) {
		sc->wi_usb_nummem--;
		return ENOMEM;
	}

	sc->wi_usb_txmem[nmem] = malloc(len, M_DEVBUF, M_WAITOK | M_CANFAIL);
	if (sc->wi_usb_txmem[nmem] == NULL) {
		sc->wi_usb_nummem--;
		return ENOMEM;
	}
	sc->wi_usb_txmemsize[nmem] = len;

	*id = nmem;
	return 0;
}

/*
 * this is crazy, we skip the first 16 bits of the buf so that it
 * can be used as the 'type' of the usb transfer.
 */


int
wi_write_data_usb(struct wi_softc *wsc, int id, int off, caddr_t buf, int len)
{
	u_int8_t	*ptr;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;

	DPRINTFN(10,("%s: %s: id %x off %x len %d\n",
	    sc->wi_usb_dev.dv_xname, __func__, id, off, len));

	if (id < 0 && id >= sc->wi_usb_nummem)
		return EIO;

	ptr = (u_int8_t *)(sc->wi_usb_txmem[id]) + off;

	if (len + off > sc->wi_usb_txmemsize[id])
		return EIO;
	DPRINTFN(10,("%s: %s: completed \n",
	    sc->wi_usb_dev.dv_xname, __func__));

	bcopy(buf, ptr, len);
	return 0;
}

/*
 * On the prism I/O, this read_data points to the hardware buffer
 * which contains the
 */
int
wi_read_data_usb(struct wi_softc *wsc, int id, int off, caddr_t buf, int len)
{
	u_int8_t	*ptr;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;

	DPRINTFN(10,("%s: %s: id %x off %x len %d\n",
	    sc->wi_usb_dev.dv_xname, __func__, id, off, len));

	if (id == 0x1001 && sc->wi_info != NULL)
		ptr = (u_int8_t *)sc->wi_info + off;
	else if (id == 0x1000 && sc->wi_rxframe != NULL)
		ptr = (u_int8_t *)sc->wi_rxframe + off;
	else if (id >= 0 && id < sc->wi_usb_nummem) {

		if (sc->wi_usb_txmem[id] == NULL)
			return EIO;
		if (len + off > sc->wi_usb_txmemsize[id])
			return EIO;

		ptr = (u_int8_t *)(sc->wi_usb_txmem[id]) + off;
	} else
		return EIO;

	if (id < sc->wi_usb_nummem) {
		ptr = (u_int8_t *)(sc->wi_usb_txmem[id]) + off;

		if (len + off > sc->wi_usb_txmemsize[id])
			return EIO;
	}

	bcopy(ptr, buf, len);
	return 0;
}

void
wi_usb_stop(struct wi_usb_softc *sc)
{
	DPRINTFN(1,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname,__func__));
	/* XXX */

	/* Stop transfers */
}

int
wi_usb_do_transmit_sync(struct wi_usb_softc *sc, struct wi_usb_chain *c,
    void *ident)
{
	usbd_status		err;

	DPRINTFN(10,("%s: %s:\n",
	    sc->wi_usb_dev.dv_xname, __func__));

	sc->wi_usb_refcnt++;
	err = usbd_transfer(c->wi_usb_xfer);
	if (err != USBD_IN_PROGRESS && err != USBD_NORMAL_COMPLETION) {
		printf("%s: %s error=%s\n",
		    sc->wi_usb_dev.dv_xname, __func__,
		    usbd_errstr(err));
		/* Stop the interface from process context. */
		wi_usb_stop(sc);
		err = EIO;
		goto done;
	}
	err = tsleep(ident, PRIBIO, "wiTXsync", hz*1);
	if (err) {
		DPRINTFN(1,("%s: %s: err %x\n",
		    sc->wi_usb_dev.dv_xname, __func__, err));
		err = ETIMEDOUT;
	}
done:
	if (--sc->wi_usb_refcnt < 0)
		usb_detach_wakeup(&sc->wi_usb_dev);
	return err;
}


/*
 * A command/rrid/wrid  was sent to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
wi_usb_txeof(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct wi_usb_chain	*c = priv;
	struct wi_usb_softc	*sc = c->wi_usb_sc;

	int			s;

	if (usbd_is_dying(sc->wi_usb_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->wi_usb_dev.dv_xname,
		    __func__, status));

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		printf("%s: usb error on tx: %s\n", sc->wi_usb_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED) {
			sc->wi_usb_refcnt++;
			usbd_clear_endpoint_stall_async(
			    sc->wi_usb_ep[WI_USB_ENDPT_TX]);
			if (--sc->wi_usb_refcnt < 0)
				usb_detach_wakeup(&sc->wi_usb_dev);
		}
		splx(s);
		return;
	}

	splx(s);
}

/*
 * A packet was sent to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
wi_usb_txeof_frm(struct usbd_xfer *xfer, void *priv,
    usbd_status status)
{
	struct wi_usb_chain	*c = priv;
	struct wi_usb_softc	*sc = c->wi_usb_sc;
	struct wi_softc		*wsc = &sc->sc_wi;
	struct ifnet		*ifp = &wsc->sc_ic.ic_if;

	int			s;
	int			err = 0;

	if (usbd_is_dying(sc->wi_usb_udev))
		return;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->wi_usb_dev.dv_xname,
		    __func__, status));

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		printf("%s: usb error on tx: %s\n", sc->wi_usb_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED) {
			sc->wi_usb_refcnt++;
			usbd_clear_endpoint_stall_async(
			    sc->wi_usb_ep[WI_USB_ENDPT_TX]);
			if (--sc->wi_usb_refcnt < 0)
				usb_detach_wakeup(&sc->wi_usb_dev);
		}
		splx(s);
		return;
	}

	if (status)
		err = WI_EV_TX_EXC;

	wi_txeof(wsc, err);

	wi_usb_tx_unlock(sc);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		wi_start_usb(ifp);

	splx(s);
}

int
wi_usb_rx_list_init(struct wi_usb_softc *sc)
{
	struct wi_usb_chain	*c;
	int			i;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	for (i = 0; i < WI_USB_RX_LIST_CNT; i++) {
		c = &sc->wi_usb_rx_chain[i];
		c->wi_usb_sc = sc;
		c->wi_usb_idx = i;
		if (c->wi_usb_xfer != NULL) {
			printf("UGH RX\n");
		}
		if (c->wi_usb_xfer == NULL) {
			c->wi_usb_xfer = usbd_alloc_xfer(sc->wi_usb_udev);
			if (c->wi_usb_xfer == NULL)
				return (ENOBUFS);
			c->wi_usb_buf = usbd_alloc_buffer(c->wi_usb_xfer,
			    WI_USB_BUFSZ);
			if (c->wi_usb_buf == NULL)
				return (ENOBUFS); /* XXX free xfer */
		}
	}

	return (0);
}

int
wi_usb_tx_list_init(struct wi_usb_softc *sc)
{
	struct wi_usb_chain	*c;
	int			i;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	for (i = 0; i < WI_USB_TX_LIST_CNT; i++) {
		c = &sc->wi_usb_tx_chain[i];
		c->wi_usb_sc = sc;
		c->wi_usb_idx = i;
		c->wi_usb_mbuf = NULL;
		if (c->wi_usb_xfer != NULL) {
			printf("UGH TX\n");
		}
		if (c->wi_usb_xfer == NULL) {
			c->wi_usb_xfer = usbd_alloc_xfer(sc->wi_usb_udev);
			if (c->wi_usb_xfer == NULL)
				return (ENOBUFS);
			c->wi_usb_buf = usbd_alloc_buffer(c->wi_usb_xfer,
			    WI_USB_BUFSZ);
			if (c->wi_usb_buf == NULL)
				return (ENOBUFS);
		}
	}

	return (0);
}

int
wi_usb_open_pipes(struct wi_usb_softc *sc)
{
	usbd_status		err;
	int			error = 0;
	struct wi_usb_chain	*c;
	int			i;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname,__func__));

	sc->wi_usb_refcnt++;

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->wi_usb_iface, sc->wi_usb_ed[WI_USB_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->wi_usb_ep[WI_USB_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

	err = usbd_open_pipe(sc->wi_usb_iface, sc->wi_usb_ed[WI_USB_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->wi_usb_ep[WI_USB_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

	/* is this used? */
	err = usbd_open_pipe_intr(sc->wi_usb_iface,
	    sc->wi_usb_ed[WI_USB_ENDPT_INTR], USBD_EXCLUSIVE_USE,
	    &sc->wi_usb_ep[WI_USB_ENDPT_INTR], sc, &sc->wi_usb_ibuf,
	    WI_USB_INTR_PKTLEN, wi_usb_intr, WI_USB_INTR_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

	/* Start up the receive pipe. */
	for (i = 0; i < WI_USB_RX_LIST_CNT; i++) {
		c = &sc->wi_usb_rx_chain[i];
		usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_RX],
		    c, c->wi_usb_buf, WI_USB_BUFSZ,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY, USBD_NO_TIMEOUT,
		    wi_usb_rxeof);
		DPRINTFN(10,("%s: %s: start read\n", sc->wi_usb_dev.dv_xname,
			    __func__));
		usbd_transfer(c->wi_usb_xfer);
	}

done:
	if (--sc->wi_usb_refcnt < 0)
		usb_detach_wakeup(&sc->wi_usb_dev);

	return (error);
}

/*
 * This is a bit of a kludge, however wi_rxeof and wi_update_stats
 * call wi_get_fid to determine where the data associated with
 * the transaction is located, the returned id is then used to
 * wi_read_data the information out.
 *
 * This code returns which 'fid' should be used. The results are only valid
 * during a wi_usb_rxeof because the data is received packet is 'held'
 * an a variable for reading by wi_read_data_usb for that period.
 *
 * for magic numbers this uses  0x1000, 0x1001 for rx/info
 */

int
wi_get_fid_usb(struct wi_softc *sc, int fid)
{
	switch (fid) {
	case WI_RX_FID:
		return 0x1000;
	case WI_INFO_FID:
		return 0x1001;
	default:
		return 0x1111;
	}

}

#if 0
void
wi_dump_data(void *buffer, int len)
{
	int i;
	for (i = 0; i < len; i++) {
		if (((i) % 16) == 0)
			printf("\n %02x:", i);
		printf(" %02x",
		    ((uint8_t *)(buffer))[i]);

	}
	printf("\n");

}
#endif

/*
 * A frame has been received.
 */
void
wi_usb_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct wi_usb_chain	*c = priv;
	struct wi_usb_softc	*sc = c->wi_usb_sc;
	wi_usb_usbin		*uin;
	int			total_len = 0;
	u_int16_t		rtype;

	if (usbd_is_dying(sc->wi_usb_udev))
		return;

	DPRINTFN(10,("%s: %s: enter status=%d\n", sc->wi_usb_dev.dv_xname,
		    __func__, status));


	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_IOERROR
		    || status == USBD_CANCELLED) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->wi_usb_dev.dv_xname, 1,
			    /* sc->wi_usb_rx_errs, */
			    usbd_errstr(status));
			return;
		}
#if 0
		sc->wi_usb_rx_errs++;
		if (usbd_ratecheck(&sc->wi_usb_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			    sc->wi_usb_dev.dv_xname, sc->wi_usb_rx_errs,
			    usbd_errstr(status));
			sc->wi_usb_rx_errs = 0;
		}
#endif
		if (status == USBD_STALLED) {
			sc->wi_usb_refcnt++;
			usbd_clear_endpoint_stall_async(
			    sc->wi_usb_ep[WI_USB_ENDPT_RX]);
			if (--sc->wi_usb_refcnt < 0)
				usb_detach_wakeup(&sc->wi_usb_dev);
		}
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	if (total_len < 6) /* short XXX */
		goto done;

	uin = (wi_usb_usbin *)(c->wi_usb_buf);

	rtype = letoh16(uin->type);


#if 0
	wi_dump_data(c->wi_usb_buf, total_len);
#endif

	if (WI_USB_ISRXFRM(rtype)) {
		wi_usb_rxfrm(sc, uin, total_len);
		goto done;
	}
	if (WI_USB_ISTXFRM(rtype)) {
		DPRINTFN(2,("%s: %s: txfrm type %x\n",
		    sc->wi_usb_dev.dv_xname, __func__, rtype));
		wi_usb_txfrm(sc, uin, total_len);
		goto done;
	}

	switch (rtype) {
	case WI_USB_INFOFRM:
		/* info packet, INFO_FID hmm */
		DPRINTFN(10,("%s: %s: infofrm type %x\n",
		    sc->wi_usb_dev.dv_xname, __func__, rtype));
		wi_usb_infofrm(c, total_len);
		break;
	case WI_USB_CMDRESP:
		wi_usb_cmdresp(c);
		break;
	case WI_USB_WRIDRESP:
		wi_usb_wridresp(c);
		break;
	case WI_USB_RRIDRESP:
		wi_usb_rridresp(c);
		break;
	case WI_USB_WMEMRESP:
		/* Not currently used */
		DPRINTFN(2,("%s: %s: wmemresp type %x\n",
		    sc->wi_usb_dev.dv_xname, __func__, rtype));
		break;
	case WI_USB_RMEMRESP:
		/* Not currently used */
		DPRINTFN(2,("%s: %s: rmemresp type %x\n",
		    sc->wi_usb_dev.dv_xname, __func__, rtype));
		break;
	case WI_USB_BUFAVAIL:
		printf("wi_usb: received USB_BUFAVAIL packet\n"); /* XXX */
		break;
	case WI_USB_ERROR:
		printf("wi_usb: received USB_ERROR packet\n"); /* XXX */
		break;
#if 0
	default:
		printf("wi_usb: received Unknown packet 0x%x len %x\n",
		    rtype, total_len);
		wi_dump_data(c->wi_usb_buf, total_len);
#endif
	}

 done:
	/* Setup new transfer. */
	usbd_setup_xfer(c->wi_usb_xfer, sc->wi_usb_ep[WI_USB_ENDPT_RX],
	    c, c->wi_usb_buf, WI_USB_BUFSZ, USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, wi_usb_rxeof);
	sc->wi_usb_refcnt++;
	usbd_transfer(c->wi_usb_xfer);
	if (--sc->wi_usb_refcnt < 0)
		usb_detach_wakeup(&sc->wi_usb_dev);

	DPRINTFN(10,("%s: %s: start rx\n", sc->wi_usb_dev.dv_xname,
		    __func__));
}

void
wi_usb_intr(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct wi_usb_softc	*sc = priv;

	DPRINTFN(2,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->wi_usb_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;

		if (status == USBD_STALLED) {
			sc->wi_usb_refcnt++;
			usbd_clear_endpoint_stall_async(
			    sc->wi_usb_ep[WI_USB_ENDPT_RX]);
			if (--sc->wi_usb_refcnt < 0)
				usb_detach_wakeup(&sc->wi_usb_dev);
		}
		return;
	}
	/* XXX oerrors or collisions? */
}
void
wi_usb_cmdresp(struct wi_usb_chain *c)
{
	struct wi_cmdresp *presp = (struct wi_cmdresp *)(c->wi_usb_buf);
	u_int16_t status = letoh16(presp->status);
	struct wi_usb_softc	*sc = c->wi_usb_sc;
	uint16_t type;
	uint16_t cmdresperr;

	type = htole16(presp->type);
	cmdresperr = letoh16(presp->resp0);
	DPRINTFN(10,("%s: %s: enter type=%x, status=%x, cmdresp=%x, "
	    "resp=%x,%x,%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, type, status, sc->cmdresp,
	    cmdresperr, letoh16(presp->resp1),
	    letoh16(presp->resp2)));

	/* XXX */
	if (sc->cmdresp != (status & WI_STAT_CMD_CODE)) {
		DPRINTFN(1,("%s: cmd ty %x st %x cmd %x failed %x\n",
		    sc->wi_usb_dev.dv_xname,
			type, status, sc->cmdresp, cmdresperr));
		return;
	}

	sc->cmdresperr = (status & WI_STAT_CMD_RESULT) >> 8;

	sc->cmdresp = 0; /* good value for idle == INI ?? XXX  */

	wakeup(&sc->cmdresperr);
}
void
wi_usb_rridresp(struct wi_usb_chain *c)
{
	struct wi_rridresp *presp = (struct wi_rridresp *)(c->wi_usb_buf);
	u_int16_t frmlen = letoh16(presp->frmlen);
	struct wi_usb_softc	*sc = c->wi_usb_sc;
	struct wi_ltv_gen *ltv;
	uint16_t rid;

	rid = letoh16(presp->rid);
	ltv =  sc->ridltv;

	if (ltv == 0) {
		DPRINTFN(5,("%s: %s: enter ltv = 0 rid=%x len %d\n",
		    sc->wi_usb_dev.dv_xname, __func__, rid,
		    frmlen));
		return;
	}

	DPRINTFN(5,("%s: %s: enter rid=%x expecting %x len %d exptlen %d\n",
	    sc->wi_usb_dev.dv_xname, __func__, rid, ltv->wi_type,
	    frmlen, ltv->wi_len));

	rid = letoh16(presp->rid);

	if (rid != ltv->wi_type) {
		sc->ridresperr = EIO;
		return;
	}

	if (frmlen > ltv->wi_len) {
		sc->ridresperr = ENOSPC;
		sc->ridltv = 0;
		wakeup(&sc->ridresperr);
		return;
	}

	ltv->wi_len = frmlen;

	DPRINTFN(10,("%s: %s: copying %d frmlen %d\n",
	    sc->wi_usb_dev.dv_xname, __func__, (ltv->wi_len-1)*2,
	    frmlen));

	if (ltv->wi_len > 1)
		bcopy(&presp->data[0], &ltv->wi_val,
		    (ltv->wi_len-1)*2);

	sc->ridresperr = 0;
	sc->ridltv = 0;
	wakeup(&sc->ridresperr);

}

void
wi_usb_wridresp(struct wi_usb_chain *c)
{
	struct wi_wridresp *presp = (struct wi_wridresp *)(c->wi_usb_buf);
	struct wi_usb_softc	*sc = c->wi_usb_sc;
	uint16_t status;

	status = letoh16(presp->status);

	DPRINTFN(10,("%s: %s: enter status=%x\n",
	    sc->wi_usb_dev.dv_xname, __func__, status));

	sc->ridresperr = (status & WI_STAT_CMD_RESULT) >> 8;
	sc->ridltv = 0;
	wakeup(&sc->ridresperr);
}

void
wi_usb_infofrm(struct wi_usb_chain *c, int len)
{
	struct wi_usb_softc	*sc = c->wi_usb_sc;

	DPRINTFN(10,("%s: %s: enter\n",
	    sc->wi_usb_dev.dv_xname, __func__));

	sc->wi_info = ((char *)c->wi_usb_buf) + 2;
	wi_update_stats(&sc->sc_wi);
	sc->wi_info = NULL;
}

void
wi_usb_txfrm(struct wi_usb_softc *sc, wi_usb_usbin *uin, int total_len)
{
	u_int16_t		status;
	int 			s;
	struct wi_softc		*wsc = &sc->sc_wi;
	struct ifnet		*ifp = &wsc->sc_ic.ic_if;

	s = splnet();
	status = letoh16(uin->type); /* XXX -- type == status */


	DPRINTFN(2,("%s: %s: enter status=%d\n",
	    sc->wi_usb_dev.dv_xname, __func__, status));

	if (sc->txresp == WI_CMD_TX) {
		sc->txresperr=status;
		sc->txresp = 0;
		wakeup(&sc->txresperr);
	} else {
		if (status != 0) /* XXX */
			wi_watchdog_usb(ifp);
	DPRINTFN(1,("%s: %s: txresp not expected status=%d \n",
	    sc->wi_usb_dev.dv_xname, __func__, status));
	}

	splx(s);
}
void
wi_usb_rxfrm(struct wi_usb_softc *sc, wi_usb_usbin *uin, int total_len)
{
	int s;

	DPRINTFN(5,("%s: %s: enter len=%d\n",
	    sc->wi_usb_dev.dv_xname, __func__, total_len));

	s = splnet();

	sc->wi_rxframe = (void *)uin;

	wi_rxeof(&sc->sc_wi);

	sc->wi_rxframe = NULL;

	splx(s);

}


void
wi_usb_start_thread(void *arg)
{
	struct wi_usb_softc	*sc = arg;
	kthread_create (wi_usb_thread, arg, NULL, sc->wi_usb_dev.dv_xname);
}

void
wi_start_usb(struct ifnet *ifp)
{
	struct wi_softc		*wsc;
	struct wi_usb_softc	*sc;
	int s;

	wsc = ifp->if_softc;
	sc  = wsc->wi_usb_cdata;

	s = splnet();

	DPRINTFN(5,("%s: %s:\n",
	    sc->wi_usb_dev.dv_xname, __func__));

	if (wi_usb_tx_lock_try(sc)) {
		/* lock acquired do start now */
		wi_func_io.f_start(ifp);
	} else {
		sc->wi_thread_info->status |= WI_START;
		if (sc->wi_thread_info->idle)
			wakeup(sc->wi_thread_info);
	}

	splx(s);
}

/* 
 * inquire is called from interrupt context (timeout)
 * It is not possible to sleep in interrupt context so it is necessary
 * to signal the kernel thread to perform the action.
 */
void
wi_init_usb(struct wi_softc *wsc)
{
	DPRINTFN(5,("%s: %s:\n", WI_PRT_ARG(wsc), __func__));

	wi_usb_ctl_lock(wsc->wi_usb_cdata);
	wi_func_io.f_init(wsc);
	wi_usb_ctl_unlock(wsc->wi_usb_cdata);
}


/* 
 * inquire is called from interrupt context (timeout)
 * It is not possible to sleep in interrupt context so it is necessary
 * to signal the kernel thread to perform the action.
 */
void
wi_inquire_usb(void *xsc)
{
	struct wi_softc		*wsc = xsc;
	struct wi_usb_softc	*sc = wsc->wi_usb_cdata;
	int s;


	s = splnet();

	DPRINTFN(2,("%s: %s:\n",
	    sc->wi_usb_dev.dv_xname, __func__));

	sc->wi_thread_info->status |= WI_INQUIRE;

	if (sc->wi_thread_info->idle)
		wakeup(sc->wi_thread_info);
	splx(s);
}

/* 
 * Watchdog is normally called from interrupt context (timeout)
 * It is not possible to sleep in interrupt context so it is necessary
 * to signal the kernel thread to perform the action.
 */
void
wi_watchdog_usb(struct ifnet *ifp)
{
	struct wi_softc		*wsc;
	struct wi_usb_softc	*sc;
	int s;

	wsc = ifp->if_softc;
	sc = wsc->wi_usb_cdata;

	s = splnet();

	DPRINTFN(5,("%s: %s: ifp %x\n",
	    sc->wi_usb_dev.dv_xname, __func__, ifp));

	sc->wi_thread_info->status |= WI_WATCHDOG;

	if (sc->wi_thread_info->idle)
		wakeup(sc->wi_thread_info);
	splx(s);
}

/*
 * ioctl will always be called from a user context, 
 * therefore it is possible to sleep in the calling context
 * acquire the lock and call the real ioctl function directly 
 */
int
wi_ioctl_usb(struct ifnet *ifp, u_long command, caddr_t data)
{
	struct wi_softc		*wsc;
	int err;

	wsc = ifp->if_softc;

	wi_usb_ctl_lock(wsc->wi_usb_cdata);
	err = wi_func_io.f_ioctl(ifp, command, data);
	wi_usb_ctl_unlock(wsc->wi_usb_cdata);
	return err;
}

void
wi_usb_thread(void *arg)
{
	struct wi_usb_softc *sc = arg;
	struct wi_usb_thread_info *wi_thread_info;
	int s;

	wi_thread_info = malloc(sizeof(*wi_thread_info), M_DEVBUF, M_WAITOK);

	/*
	 * is there a remote possibility that the device could
	 * be removed before the kernel thread starts up?
	 */

	sc->wi_usb_refcnt++;

	sc->wi_thread_info = wi_thread_info;
	wi_thread_info->dying = 0;
	wi_thread_info->status = 0;

	wi_usb_ctl_lock(sc);

	wi_attach(&sc->sc_wi, &wi_func_usb);

	wi_usb_ctl_unlock(sc);

	for(;;) {
		if (wi_thread_info->dying) { 
			if (--sc->wi_usb_refcnt < 0)
				usb_detach_wakeup(&sc->wi_usb_dev);
			kthread_exit(0);
		}

		DPRINTFN(5,("%s: %s: dying %x status %x\n",
		    sc->wi_usb_dev.dv_xname, __func__,
			wi_thread_info->dying, wi_thread_info->status));

		wi_usb_ctl_lock(sc);

		DPRINTFN(5,("%s: %s: starting %x\n",
		    sc->wi_usb_dev.dv_xname, __func__,
		    wi_thread_info->status));

		s = splusb();
		if (wi_thread_info->status & WI_START) {
			wi_thread_info->status &= ~WI_START;
			wi_usb_tx_lock(sc);
			wi_func_io.f_start(&sc->sc_wi.sc_ic.ic_if);
			/*
			 * tx_unlock is explicitly missing here
			 * it is done in txeof_frm
			 */
		} else if (wi_thread_info->status & WI_INQUIRE) {
			wi_thread_info->status &= ~WI_INQUIRE;
			wi_func_io.f_inquire(&sc->sc_wi);
		} else if (wi_thread_info->status & WI_WATCHDOG) {
			wi_thread_info->status &= ~WI_WATCHDOG;
			wi_func_io.f_watchdog( &sc->sc_wi.sc_ic.ic_if);
		}
		splx(s);

		DPRINTFN(5,("%s: %s: ending %x\n",
		    sc->wi_usb_dev.dv_xname, __func__,
		    wi_thread_info->status));
		wi_usb_ctl_unlock(sc);

		if (wi_thread_info->status == 0) {
			s = splnet();
			wi_thread_info->idle = 1;
			tsleep(wi_thread_info, PRIBIO, "wiIDL", 0);
			wi_thread_info->idle = 0;
			splx(s);
		}
	}
}

int
wi_usb_tx_lock_try(struct wi_usb_softc *sc)
{
	int s;

	s = splnet();

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	if (sc->wi_lock != 0) {
		splx(s);
		return 0; /* failed to aquire lock */
	}

	sc->wi_lock = 1;

	splx(s);

	return 1;
}
void
wi_usb_tx_lock(struct wi_usb_softc *sc)
{
	int s;

	s = splnet();

	again:
	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	if (sc->wi_lock != 0) {
		sc->wi_lockwait++;
		DPRINTFN(10,("%s: %s: busy %d\n", sc->wi_usb_dev.dv_xname,
		__func__, sc->wi_lockwait ));
		tsleep(&sc->wi_lock, PRIBIO, "witxl", 0);
	}

	if (sc->wi_lock != 0)
		goto again;
	sc->wi_lock = 1;

	splx(s);

	return;

}

void
wi_usb_tx_unlock(struct wi_usb_softc *sc)
{
	int s;
	s = splnet();

	sc->wi_lock = 0;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	if (sc->wi_lockwait) {
		DPRINTFN(10,("%s: %s: waking\n",
		    sc->wi_usb_dev.dv_xname, __func__));
		sc->wi_lockwait = 0;
		wakeup(&sc->wi_lock);
	}

	splx(s);
}

void
wi_usb_ctl_lock(struct wi_usb_softc *sc)
{
	int s;

	s = splnet();

	again:
	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname,
	    __func__));

	if (sc->wi_ctllock != 0) {
		if (curproc == sc->wi_curproc) {
			/* allow recursion */
			sc->wi_ctllock++;
			splx(s);
			return;
		}
		sc->wi_ctllockwait++;
		DPRINTFN(10,("%s: %s: busy %d\n", sc->wi_usb_dev.dv_xname,
		__func__, sc->wi_ctllockwait ));
		tsleep(&sc->wi_ctllock, PRIBIO, "wiusbthr", 0);
	}

	if (sc->wi_ctllock != 0)
		goto again;
	sc->wi_ctllock++;
	sc->wi_curproc = curproc;

	splx(s);

	return;

}

void
wi_usb_ctl_unlock(struct wi_usb_softc *sc)
{
	int s;

	s = splnet();

	sc->wi_ctllock--;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	if (sc->wi_ctllock == 0 && sc->wi_ctllockwait) {
		DPRINTFN(10,("%s: %s: waking\n",
		    sc->wi_usb_dev.dv_xname, __func__));
		sc->wi_ctllockwait = 0;
		sc->wi_curproc = 0;
		wakeup(&sc->wi_ctllock);
	}

	splx(s);
}
@


1.67
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.66 2015/06/12 15:47:31 mpi Exp $ */
a44 1
#include <net/if_dl.h>
@


1.66
log
@Only match devices with a valid configuration.

Most of the WiFi/Ethernet USB adapter only have one configuration and always
use its first interface.  In order to improve USB descriptors parsing start
by reducing the number of places where a configuration is set.

Tests & ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.65 2015/06/10 20:50:05 miod Exp $ */
a46 1
#include <net/if_types.h>
@


1.65
log
@Typos: equalivant, fucntion, libary.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.64 2014/11/18 02:37:30 tedu Exp $ */
d274 1
a274 1
	if (uaa->iface != NULL)
d278 1
a278 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d293 1
a293 2
	struct usbd_interface	*iface;
	usbd_status		err;
a299 6
	err = usbd_set_config_no(dev, WI_USB_CONFIG_NO, 1);
	if (err) {
		printf("%s: setting config no failed\n", sc->wi_usb_dev.dv_xname);
		return;
	}

a300 7

	err = usbd_device2interface_handle(dev, WI_USB_IFACE_IDX, &iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->wi_usb_dev.dv_xname);
		return;
	}
@


1.64
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.63 2014/07/13 15:52:49 mpi Exp $ */
d1744 1
a1744 1
 * acquire the lock and call the real ioctl fucntion directly 
@


1.63
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.62 2014/07/12 18:48:52 tedu Exp $ */
a66 2

#include <dev/rndvar.h>
@


1.62
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.61 2014/07/12 07:59:23 mpi Exp $ */
a48 1
#ifdef INET
a49 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a50 1
#endif
@


1.61
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.60 2013/11/15 10:17:39 pirofti Exp $ */
d435 1
a435 1
			free(sc->wi_usb_txmem[sc->wi_usb_nummem], M_DEVBUF);
d566 1
a566 1
			free(sc->wi_usb_txmem[sc->wi_usb_nummem], M_DEVBUF);
@


1.60
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.59 2013/11/11 15:00:35 pirofti Exp $ */
d263 10
a272 15
int wi_usb_match(struct device *, void *, void *); 
void wi_usb_attach(struct device *, struct device *, void *); 
int wi_usb_detach(struct device *, int); 
int wi_usb_activate(struct device *, int); 

struct cfdriver wi_usb_cd = { 
	NULL, "wi_usb", DV_IFNET 
}; 

const struct cfattach wi_usb_ca = { 
	sizeof(struct wi_usb_softc), 
	wi_usb_match, 
	wi_usb_attach, 
	wi_usb_detach, 
	wi_usb_activate, 
a1311 16
}

int
wi_usb_activate(struct device *self, int act)
{
	struct wi_usb_softc *sc = (struct wi_usb_softc *)self;

	DPRINTFN(10,("%s: %s: enter\n", sc->wi_usb_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->wi_usb_udev);
		sc->wi_thread_info->dying = 1;
		break;
	}
	return (0);
@


1.59
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.58 2013/08/07 01:06:43 bluhm Exp $ */
d445 1
a445 5
		err = usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
d454 1
a454 5
		err = usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
d463 1
a463 5
		err = usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    sc->wi_usb_dev.dv_xname, usbd_errstr(err));
		}
@


1.58
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.57 2013/04/15 09:23:01 mglocker Exp $ */
a151 1
	char			wi_usb_dying;
d1098 1
a1098 1
	if (sc->wi_usb_dying)
d1144 1
a1144 1
	if (sc->wi_usb_dying)
d1340 1
a1340 1
		sc->wi_usb_dying = 1;
d1376 1
a1376 1
	if (sc->wi_usb_dying)
d1497 1
a1497 1
	if (sc->wi_usb_dying)
@


1.57
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.56 2013/03/28 03:58:03 tedu Exp $ */
a51 1
#include <netinet/in_var.h>
@


1.56
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.55 2011/12/03 03:34:40 krw Exp $ */
d83 1
a83 1
void wi_usb_txeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d85 1
a85 1
void wi_usb_txeof_frm(usbd_xfer_handle xfer, usbd_private_handle priv,
d87 1
a87 1
void wi_usb_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d89 1
a89 1
void wi_usb_intr(usbd_xfer_handle xfer, usbd_private_handle priv,
d142 2
a143 2
	usbd_device_handle	wi_usb_udev;
	usbd_interface_handle	wi_usb_iface;
d147 1
a147 1
	usbd_pipe_handle	wi_usb_ep[WI_USB_ENDPT_MAX];
d305 2
a306 2
	usbd_device_handle	dev = uaa->device;
	usbd_interface_handle	iface;
d1092 1
a1092 1
wi_usb_txeof(usbd_xfer_handle xfer, usbd_private_handle priv,
d1135 1
a1135 1
wi_usb_txeof_frm(usbd_xfer_handle xfer, usbd_private_handle priv,
d1370 1
a1370 1
wi_usb_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1493 1
a1493 1
wi_usb_intr(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.55
log
@Make sure splx() is called before exiting wi_usb_tx_lock_try().

Found by Jan Klemkow. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.54 2011/09/18 23:24:12 krw Exp $ */
a37 1
#include <sys/proc.h>
@


1.54
log
@usbdivar.h needs struct timeout. But don't get it indirectly via
sys/kthread.h,  use sys/timeout.h explicitly. Noted by Michael
Knudsen.

ok deraadt@@ kettenis@@ guenther@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.53 2011/07/03 15:47:17 matthew Exp $ */
d1888 1
@


1.53
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.52 2011/06/22 16:44:29 tedu Exp $ */
d41 1
@


1.52
log
@kill a few more casts that aren't helpful.  ok krw miod
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.51 2011/06/17 07:06:47 mk Exp $ */
a1340 3
	case DVACT_ACTIVATE:
		break;

@


1.51
log
@M_WAITOK cleanup of two cases:

1) Allocating with M_WAITOK, checking for NULL, and calling panic() is
pointless (malloc() will panic if it can't allocate) so remove the check
and the call.

2) Allocating with M_WAITOK, checking for NULL, and then gracefully
handling failure to allocate is pointless.  Instead also pass M_CANFAIL
so malloc() doesn't panic so we can actually handle it gracefully.

1) was done using Coccinelle.

Input from oga.

ok miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.50 2011/01/25 20:03:35 jakemsr Exp $ */
d916 1
a916 2
		bcopy((u_int8_t *)&ltv->wi_val, (u_int8_t *)&prid->data[0],
		    (ltv->wi_len-1)*2);
d1595 1
a1595 1
		bcopy(&presp->data[0], (u_int8_t *)&ltv->wi_val,
@


1.50
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.49 2010/10/27 17:51:11 jakemsr Exp $ */
d966 1
a966 1
	sc->wi_usb_txmem[nmem] = malloc(len, M_DEVBUF, M_WAITOK);
@


1.49
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.48 2010/09/24 08:33:59 yuo Exp $ */
a388 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->wi_usb_udev,
			   &sc->wi_usb_dev);
a487 2
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->wi_usb_udev,
	    &sc->wi_usb_dev);
@


1.48
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.47 2010/07/02 03:13:42 tedu Exp $ */
d430 4
a433 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.47
log
@fix a variety of uninit errors.  ok and one correction deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.46 2009/10/13 19:33:17 pirofti Exp $ */
d403 4
a406 1
	sc->wi_usb_dying = 1;
a414 4
	if (!sc->wi_usb_attached) {
		/* Detached before attach finished, so just bail out. */
		return (0);
	}
@


1.46
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.45 2009/02/14 20:05:09 chl Exp $ */
d462 1
a462 1
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_TX]);
d475 1
a475 1
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_RX]);
d660 1
a660 1
	struct wi_ltv_gen	*oltv, p2ltv;
@


1.45
log
@remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok fgsch@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.44 2007/10/11 18:33:14 deraadt Exp $ */
d268 1
a268 1
int wi_usb_activate(struct device *, enum devact); 
d1339 1
a1339 1
wi_usb_activate(struct device *self, enum devact act)
@


1.44
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.43 2007/09/12 18:45:14 mk Exp $ */
a519 1
			total_len = sc->wi_usb_txmemsize[id];
a628 2

	total_len = rnd_len;
@


1.43
log
@There is no such word as `detatch'.

ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.42 2007/06/14 10:11:15 mbalmer Exp $ */
a303 1
	char			*devinfop;
d316 1
a316 2
		printf("%s: setting config no failed\n",
		    sc->wi_usb_dev.dv_xname);
a318 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s\n", sc->wi_usb_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.42
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.41 2007/06/12 16:26:36 mbalmer Exp $ */
d425 1
a425 1
	/* detatch wi */
@


1.41
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.40 2007/06/10 14:49:00 mbalmer Exp $ */
d265 16
a280 1
USB_DECLARE_DRIVER_CLASS(wi_usb, DV_IFNET);
@


1.40
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.39 2007/06/10 10:53:48 mbalmer Exp $ */
d1333 1
a1333 1
wi_usb_activate(device_ptr_t self, enum devact act)
@


1.39
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.38 2007/06/10 10:15:35 mbalmer Exp $ */
d303 1
a303 1
		    USBDEVNAME(sc->wi_usb_dev));
d308 1
a308 1
	printf("\n%s: %s\n", USBDEVNAME(sc->wi_usb_dev), devinfop);
d316 1
a316 1
		    USBDEVNAME(sc->wi_usb_dev));
d341 1
a341 1
			    USBDEVNAME(sc->wi_usb_dev), i);
d362 1
a362 1
		    USBDEVNAME(sc->wi_usb_dev));
d367 1
a367 1
		    USBDEVNAME(sc->wi_usb_dev));
d373 1
a373 1
		    USBDEVNAME(sc->wi_usb_dev));
d413 1
a413 1
		printf("%s: already detached\n", USBDEVNAME(sc->wi_usb_dev));
d443 1
a443 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d448 1
a448 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d456 1
a456 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d461 1
a461 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d469 1
a469 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d474 1
a474 1
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d497 1
a497 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, id));
d531 1
a531 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, id, total_len));
d541 1
a541 1
			    USBDEVNAME(sc->wi_usb_dev), __func__,
d551 1
a551 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, err));
d556 1
a556 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, id);
d570 1
a570 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, cmd, val0, val1, val2));
d641 1
a641 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, err));
d657 1
a657 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, ltv->wi_type));
d710 1
a710 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, total_len, ltv->wi_len));
d771 1
a771 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, err));
d788 1
a788 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, ltv->wi_type, ltv->wi_len,
d933 1
a933 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, err));
d951 1
a951 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, len));
d988 1
a988 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, id, off, len));
d998 1
a998 1
	    USBDEVNAME(sc->wi_usb_dev), __func__));
d1015 1
a1015 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, id, off, len));
d1046 1
a1046 1
	DPRINTFN(1,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev),__func__));
d1059 1
a1059 1
	    USBDEVNAME(sc->wi_usb_dev), __func__));
d1065 1
a1065 1
		    USBDEVNAME(sc->wi_usb_dev), __func__,
d1075 1
a1075 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, err));
d1104 1
a1104 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->wi_usb_dev),
d1112 1
a1112 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->wi_usb_dev),
d1150 1
a1150 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->wi_usb_dev),
d1158 1
a1158 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->wi_usb_dev),
d1190 1
a1190 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1219 1
a1219 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1251 1
a1251 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev),__func__));
d1260 1
a1260 1
		    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d1269 1
a1269 1
		    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d1281 1
a1281 1
		    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d1293 1
a1293 1
		DPRINTFN(10,("%s: %s: start read\n", USBDEVNAME(sc->wi_usb_dev),
d1337 1
a1337 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1383 1
a1383 1
	DPRINTFN(10,("%s: %s: enter status=%d\n", USBDEVNAME(sc->wi_usb_dev),
d1391 1
a1391 1
			    USBDEVNAME(sc->wi_usb_dev), 1,
d1400 1
a1400 1
			    USBDEVNAME(sc->wi_usb_dev), sc->wi_usb_rx_errs,
d1435 1
a1435 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, rtype));
d1444 1
a1444 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, rtype));
d1459 1
a1459 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, rtype));
d1464 1
a1464 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, rtype));
d1490 1
a1490 1
	DPRINTFN(10,("%s: %s: start rx\n", USBDEVNAME(sc->wi_usb_dev),
d1499 1
a1499 1
	DPRINTFN(2,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1532 1
a1532 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, type, status, sc->cmdresp,
d1539 1
a1539 1
		    USBDEVNAME(sc->wi_usb_dev),
d1564 1
a1564 1
		    USBDEVNAME(sc->wi_usb_dev), __func__, rid,
d1570 1
a1570 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, rid, ltv->wi_type,
d1590 1
a1590 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, (ltv->wi_len-1)*2,
d1613 1
a1613 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, status));
d1626 1
a1626 1
	    USBDEVNAME(sc->wi_usb_dev), __func__));
d1646 1
a1646 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, status));
d1656 1
a1656 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, status));
d1667 1
a1667 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, total_len));
d1686 1
a1686 1
	kthread_create (wi_usb_thread, arg, NULL, USBDEVNAME(sc->wi_usb_dev));
d1702 1
a1702 1
	    USBDEVNAME(sc->wi_usb_dev), __func__));
d1748 1
a1748 1
	    USBDEVNAME(sc->wi_usb_dev), __func__));
d1775 1
a1775 1
	    USBDEVNAME(sc->wi_usb_dev), __func__, ifp));
d1837 1
a1837 1
		    USBDEVNAME(sc->wi_usb_dev), __func__,
d1843 1
a1843 1
		    USBDEVNAME(sc->wi_usb_dev), __func__,
d1865 1
a1865 1
		    USBDEVNAME(sc->wi_usb_dev), __func__,
d1886 1
a1886 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1906 1
a1906 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1910 1
a1910 1
		DPRINTFN(10,("%s: %s: busy %d\n", USBDEVNAME(sc->wi_usb_dev),
d1933 1
a1933 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1937 1
a1937 1
		    USBDEVNAME(sc->wi_usb_dev), __func__));
d1953 1
a1953 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev),
d1964 1
a1964 1
		DPRINTFN(10,("%s: %s: busy %d\n", USBDEVNAME(sc->wi_usb_dev),
d1989 1
a1989 1
	DPRINTFN(10,("%s: %s: enter\n", USBDEVNAME(sc->wi_usb_dev), __func__));
d1993 1
a1993 1
		    USBDEVNAME(sc->wi_usb_dev), __func__));
@


1.38
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.37 2007/06/09 12:22:53 mbalmer Exp $ */
d382 1
a382 1
			   USBDEV(sc->wi_usb_dev));
d429 1
a429 1
		usb_detach_wait(USBDEV(sc->wi_usb_dev));
d482 1
a482 1
	    USBDEV(sc->wi_usb_dev));
d1080 1
a1080 1
		usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1119 1
a1119 1
				usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1165 1
a1165 1
				usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1300 1
a1300 1
		usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1410 1
a1410 1
				usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1488 1
a1488 1
		usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1513 1
a1513 1
				usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
d1832 1
a1832 1
				usb_detach_wakeup(USBDEV(sc->wi_usb_dev));
@


1.37
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.36 2007/05/27 04:00:25 jsg Exp $ */
d140 1
a140 1
	usb_callout_t		wi_usb_stat_ch;
@


1.36
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.35 2007/05/21 05:40:27 jsg Exp $ */
a1343 1
		if_deactivate(&sc->sc_wi.wi_ec.ec_if);
@


1.35
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.34 2007/04/01 18:02:49 ray Exp $ */
d267 2
a268 1
USB_MATCH(wi_usb)
d270 1
a270 1
	USB_MATCH_START(wi_usb, uaa);
d284 2
a285 1
USB_ATTACH(wi_usb)
d287 2
a288 1
	USB_ATTACH_START(wi_usb, sc, uaa);
d304 1
a304 1
		USB_ATTACH_ERROR_RETURN;
d308 1
a308 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->wi_usb_dev), devinfop);
d317 1
a317 1
		USB_ATTACH_ERROR_RETURN;
d342 1
a342 1
			USB_ATTACH_ERROR_RETURN;
d363 1
a363 1
		USB_ATTACH_ERROR_RETURN;
d368 1
a368 1
		USB_ATTACH_ERROR_RETURN;
d374 1
a374 1
		USB_ATTACH_ERROR_RETURN;
a382 3


	USB_ATTACH_SUCCESS_RETURN;
d385 2
a386 1
USB_DETACH(wi_usb)
d388 1
a388 1
	USB_DETACH_START(wi_usb, sc);
@


1.34
log
@s/multpile/multiple/

From Dunceor.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.33 2006/11/26 19:46:28 deraadt Exp $ */
d115 2
a116 2
#define DPRINTF(x)      do { if (wi_usbdebug) logprintf x; } while (0)
#define DPRINTFN(n,x)   do { if (wi_usbdebug >= (n)) logprintf x; } while (0)
@


1.33
log
@avoid extra inclusions; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.32 2006/10/24 18:20:46 moritz Exp $ */
d185 1
a185 1
	/* prevent multpile outstanding USB requests */
@


1.32
log
@Fix indentation to not imply, that USB_ATTACH_ERROR_RETURN
is an argument of printf(). No binary change.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.31 2006/10/16 12:30:08 tom Exp $ */
d64 1
a64 1
#include <net80211/ieee80211.h>
a65 1
#include <net80211/ieee80211_var.h>
@


1.31
log
@Fix some "is is"s.  ok otto@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.30 2006/06/23 06:27:11 miod Exp $ */
d316 1
a316 1
		    USB_ATTACH_ERROR_RETURN;
d362 1
a362 1
		    USB_ATTACH_ERROR_RETURN;
d367 1
a367 1
		    USB_ATTACH_ERROR_RETURN;
d373 1
a373 1
		    USB_ATTACH_ERROR_RETURN;
@


1.30
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.29 2006/02/06 17:29:11 jmc Exp $ */
d1788 1
a1788 1
 * therefore is is possible to sleep in the calling context
d1855 1
a1855 1
			 * is is done in txeof_frm
@


1.29
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.28 2006/01/29 03:22:52 brad Exp $ */
a1341 1
		return (EOPNOTSUPP);
@


1.28
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.27 2006/01/25 20:58:12 grange Exp $ */
d1855 1
a1855 1
			 * tx_unlock is explictly missing here
@


1.27
log
@kthread_create_deferred() do the things right, no need for
playing with cold global.

ok miod@@ drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.26 2005/12/03 21:11:48 brad Exp $ */
d1117 1
a1117 1
			usbd_clear_endpoint_stall(
d1163 1
a1163 1
			usbd_clear_endpoint_stall(
d1410 1
a1410 1
			usbd_clear_endpoint_stall(
d1513 1
a1513 1
			usbd_clear_endpoint_stall(
@


1.26
log
@splimp -> splnet

ok marco@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.25 2005/11/24 14:31:40 grange Exp $ */
d378 1
a378 4
	if (cold)
		kthread_create_deferred(wi_usb_start_thread, sc);
	else
		wi_usb_start_thread(sc);
@


1.25
log
@wi and ubt are network drivers so should be DV_IFNET,
not DV_DULL. Spotted by miod@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.24 2005/11/19 08:23:41 jsg Exp $ */
d1705 1
a1705 1
	s = splimp();
d1751 1
a1751 1
	s = splimp();
d1778 1
a1778 1
	s = splimp();
d1876 1
a1876 1
			s = splimp();
d1890 1
a1890 1
	s = splimp(); /* right priority? */
d1909 1
a1909 1
	s = splimp(); /* right priority? */
d1935 1
a1935 1
	s = splimp(); /* right priority? */
d1956 1
a1956 1
	s = splimp(); /* right priority? */
d1991 1
a1991 1
	s = splimp(); /* right priority? */
@


1.24
log
@ViewSonic Airsync Prism 2.5 USB wlan, id found in linux-wlan driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.23 2005/10/31 05:37:13 jsg Exp $ */
d266 1
a266 1
USB_DECLARE_DRIVER(wi_usb);
@


1.23
log
@Move from arpcom to ieee80211com in wi softc.  This will be
required for net80211 support.
Updated version of a diff from dlg@@
similiar diff ok fgsch@@, ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.22 2005/10/20 21:46:07 fgsch Exp $ */
d260 1
@


1.22
log
@fix command and write rid handling and fix some fmt strings used on debug.
should avoid several errors when using wicontrol(8) and make scanning
work at some extent.  tested by jsg, joris and todd at some extent.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.21 2005/10/16 08:47:50 fgsch Exp $ */
d42 1
d66 1
d1143 1
a1143 1
	struct ifnet		*ifp = &wsc->sc_arpcom.ac_if;
d1644 1
a1644 1
	struct ifnet		*ifp = &wsc->sc_arpcom.ac_if;
d1855 1
a1855 1
			wi_func_io.f_start(&sc->sc_wi.sc_arpcom.ac_if);
d1865 1
a1865 1
			wi_func_io.f_watchdog( &sc->sc_wi.sc_arpcom.ac_if);
@


1.21
log
@better diagnostic on tx error.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.20 2005/10/15 00:23:36 fgsch Exp $ */
d1533 2
a1534 1
	DPRINTFN(10,("%s: %s: enter rid=%x status %x %x %x\n",
d1536 2
a1537 1
	    cmdresperr));
d1539 3
a1541 2
	if (sc->cmdresp != status) {
		DPRINTFN(1,("%s:cmd ty %x st %x cmd %x failed %x\n",
d1547 1
a1547 19
	if ((cmdresperr != 0) && ((sc->cmdresp == WI_CMD_INQUIRE) ||
	    (sc->cmdresp == WI_CMD_DISABLE)) ) {
		/*
		 * For some reason MA111 does not like info frame requests,
		 * or some DISABLES
		 * It responds to the request with the info
		 * but it claims the request failed
		 * reset the error code.
		 */
		cmdresperr = 0;
	}
			
	if (cmdresperr != 0) {
		DPRINTFN(1,("%s:cmd ty %x st %x cmd %x failed %x\n",
		    USBDEVNAME(sc->wi_usb_dev),
			type, status, sc->cmdresp, cmdresperr));
	}

	sc->cmdresperr = cmdresperr;
d1592 1
a1592 1
	DPRINTFN(10,("%s: %s: copying %x  frmlen %d s %x d %x\n",
d1618 1
a1618 1
	sc->ridresperr = status;
@


1.20
log
@remove `workaround' for supported data rates now that core is fixed.
ifconfig -m shows the correct rates now.
tested by joris@@, deraadt@@ go ahead.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.19 2005/08/01 05:36:48 brad Exp $ */
d541 3
a543 2
			printf("%s: wi_usb_send error=%s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
d1065 3
a1067 2
		printf("%s: wi_usb_send error=%s\n",
		    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
@


1.19
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.18 2005/02/18 06:47:03 jsg Exp $ */
a1594 4

	/* XXX */
	if (rid == WI_RID_DATA_RATES)
		frmlen = 2;
@


1.18
log
@Internal wireless on PCChips A535 laptop found in a dmesg from
Fabio Olive Leite <foleite at yahoo dot com dot br> and some
additional wi devices found in linux-wlan driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.17 2005/01/15 03:59:39 jsg Exp $ */
d284 1
a284 1
	char			devinfo[1024];
d302 1
a302 1
	usbd_devinfo(dev, 0, devinfo, sizeof devinfo);
d304 2
a305 1
	printf("%s: %s\n", USBDEVNAME(sc->wi_usb_dev), devinfo);
@


1.17
log
@Additional devices found in linux-wlan driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.16 2004/11/23 21:12:23 fgsch Exp $ */
d229 1
d236 1
d244 1
d251 1
d258 2
a259 1
	{{ USB_VENDOR_ZCOM, USB_PRODUCT_ZCOM_725 }, 0 }
@


1.16
log
@replace old net/if_ieee80211.h header with the net80211 ones, kernel part.
millert@@ mcbride@@ jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.15 2004/10/20 12:59:13 jsg Exp $ */
d228 1
d247 1
d250 1
@


1.15
log
@add devices found in linux driver
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.14 2004/10/17 22:31:19 deraadt Exp $ */
d63 2
a64 1
#include <net/if_ieee80211.h>
@


1.14
log
@another new Corega USB wireless (found in Tokyo)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.13 2004/08/05 05:17:58 dlg Exp $ */
d221 1
d223 2
d226 2
d231 2
d238 1
d240 2
d245 1
d247 4
a250 1
	{{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_WLUSB_11_KEY }, 0 }
@


1.13
log
@attach the compaq w100 and w200. the w100 should work with a bit of work. it
is yet to be determined if the w200 has hope or not though from what i've read
it should be possible.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.12 2004/07/16 19:54:20 pedro Exp $ */
d235 2
a236 1
	{{ USB_VENDOR_SIEMENS, USB_PRODUCT_SIEMENS_SPEEDSTREAM22 }, 0 }
@


1.12
log
@recognize the dwl-122 usb wireless card. from fgsch
ok'd by him and markus@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.11 2004/07/08 22:18:44 deraadt Exp $ */
d223 2
@


1.11
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.10 2004/03/16 05:51:55 tedu Exp $ */
d224 1
@


1.10
log
@unlock on error paths, from Patrick Latifi
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.9 2004/03/15 16:10:07 drahn Exp $ */
d113 2
a114 2
#define DPRINTF(x)      if (wi_usbdebug) logprintf x
#define DPRINTFN(n,x)   if (wi_usbdebug >= (n)) logprintf x
@


1.9
log
@fix if(); error, also add missing error checks and close_pipe calls.
found and ok aaron@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.8 2004/02/27 17:30:50 henning Exp $ */
d373 1
a373 1
			wakeup (sc->wi_thread_info);
d664 1
d878 1
d1702 1
a1702 1
			wakeup (sc->wi_thread_info);
d1745 1
a1745 1
		wakeup (sc->wi_thread_info);
d1772 1
a1772 1
		wakeup (sc->wi_thread_info);
@


1.8
log
@JVC MP-XP7250 Builtin USB WLAN
tested by Michael Schmidt <Michajnz@@freenet.de>
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.7 2004/01/13 16:53:36 fgsch Exp $ */
d365 1
d412 14
a425 3
	if (sc->wi_usb_ep[WI_USB_ENDPT_INTR] != NULL);
		usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
	if (sc->wi_usb_ep[WI_USB_ENDPT_TX] != NULL);
d427 12
a438 1
	if (sc->wi_usb_ep[WI_USB_ENDPT_RX] != NULL);
d440 11
@


1.7
log
@remove needs-flag from wi@@usb. drahn@@ ok.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.6 2003/12/23 21:52:52 drahn Exp $ */
d227 1
@


1.7.2.1
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
@


1.7.2.2
log
@Merge with the trunk
@
text
@a226 1
	{{ USB_VENDOR_JVC, USB_PRODUCT_JVC_MP_XP7250_WL }, 0 },
a363 1
	int err;
d371 1
a371 1
			wakeup(sc->wi_thread_info);
d410 3
a412 14
	if (sc->wi_usb_ep[WI_USB_ENDPT_INTR] != NULL) {
		err = usbd_abort_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_INTR] = NULL;
	}
	if (sc->wi_usb_ep[WI_USB_ENDPT_TX] != NULL) {
d414 1
a414 12
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_TX] = NULL;
	}
	if (sc->wi_usb_ep[WI_USB_ENDPT_RX] != NULL) {
a415 11
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		err = usbd_close_pipe(sc->wi_usb_ep[WI_USB_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    USBDEVNAME(sc->wi_usb_dev), usbd_errstr(err));
		}
		sc->wi_usb_ep[WI_USB_ENDPT_RX] = NULL;
	}
a628 1
		wi_usb_tx_unlock(sc);
a841 1
		wi_usb_tx_unlock(sc);
d1665 1
a1665 1
			wakeup(sc->wi_thread_info);
d1708 1
a1708 1
		wakeup(sc->wi_thread_info);
d1735 1
a1735 1
		wakeup(sc->wi_thread_info);
@


1.6
log
@recognize several more wi@@usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.5 2003/12/05 02:23:42 drahn Exp $ */
a76 1
#include <wi_usb.h>
@


1.5
log
@consistently treat wi_keylen as le16, fixes wicontrol crash for if_wi
and if_wi_usb ok millert@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.4 2003/11/09 20:54:19 drahn Exp $ */
d222 11
a232 1
	{{ USB_VENDOR_NETGEAR, USB_PRODUCT_NETGEAR_MA111NA }, 0 }
@


1.4
log
@Zero the tx buffer before reusing it. This way stray bits will
not remain set on the text packet sent, seems to improve wi@@usb
on large transfers.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.3 2003/11/08 19:17:28 jmc Exp $ */
d799 3
a801 1
				struct wi_ltv_keys *wk = (struct wi_ltv_keys *)ltv;
d803 1
d1399 1
a1400 1
#if 0
@


1.3
log
@typos from Jonathon Gray;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.2 2003/10/26 15:46:37 drahn Exp $ */
d453 3
@


1.2
log
@Uhm, disable debugging my default, even if it probably is good to
run with it enabled for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_wi_usb.c,v 1.1 2003/10/26 15:34:16 drahn Exp $ */
d1231 1
a1231 1
 * during a wi_usb_rxeof because the data is recieved packet is 'held'
d1290 1
a1290 1
 * A frame has been recieved.
d1388 1
a1388 1
		printf("wi_usb: recieved USB_BUFAVAIL packet\n"); /* XXX */
d1391 1
a1391 1
		printf("wi_usb: recieved USB_ERROR packet\n"); /* XXX */
d1395 1
a1395 1
		printf("wi_usb: recieved Unknown packet 0x%x len %x\n",
@


1.1
log
@Driver for PRISM 2.5/3 based (wifi) USB adapters. This is a work in progress,
it does not yet handle bulk data copies or hostap mode. Only one model
currently supported, however driver may support other PRISM based adapters.
ok millert@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
a112 1
#define WI_USB_DEBUG
@

