head	1.96;
access;
symbols
	OPENBSD_6_2:1.96.0.2
	OPENBSD_6_2_BASE:1.96
	OPENBSD_6_1:1.94.0.6
	OPENBSD_6_1_BASE:1.94
	OPENBSD_6_0:1.94.0.4
	OPENBSD_6_0_BASE:1.94
	OPENBSD_5_9:1.91.0.2
	OPENBSD_5_9_BASE:1.91
	OPENBSD_5_8:1.85.0.4
	OPENBSD_5_8_BASE:1.85
	OPENBSD_5_7:1.81.0.2
	OPENBSD_5_7_BASE:1.81
	OPENBSD_5_6:1.79.0.4
	OPENBSD_5_6_BASE:1.79
	OPENBSD_5_5:1.76.0.4
	OPENBSD_5_5_BASE:1.76
	OPENBSD_5_4:1.72.0.2
	OPENBSD_5_4_BASE:1.72
	OPENBSD_5_3:1.68.0.6
	OPENBSD_5_3_BASE:1.68
	OPENBSD_5_2:1.68.0.4
	OPENBSD_5_2_BASE:1.68
	OPENBSD_5_1_BASE:1.68
	OPENBSD_5_1:1.68.0.2
	OPENBSD_5_0:1.66.0.2
	OPENBSD_5_0_BASE:1.66
	OPENBSD_4_9:1.64.0.2
	OPENBSD_4_9_BASE:1.64
	OPENBSD_4_8:1.61.0.4
	OPENBSD_4_8_BASE:1.61
	OPENBSD_4_7:1.61.0.2
	OPENBSD_4_7_BASE:1.61
	OPENBSD_4_6:1.57.0.4
	OPENBSD_4_6_BASE:1.57
	OPENBSD_4_5:1.56.0.2
	OPENBSD_4_5_BASE:1.56
	OPENBSD_4_4:1.54.0.2
	OPENBSD_4_4_BASE:1.54
	OPENBSD_4_3:1.52.0.2
	OPENBSD_4_3_BASE:1.52
	OPENBSD_4_2:1.50.0.2
	OPENBSD_4_2_BASE:1.50
	OPENBSD_4_1:1.36.0.2
	OPENBSD_4_1_BASE:1.36
	OPENBSD_4_0:1.35.0.4
	OPENBSD_4_0_BASE:1.35
	OPENBSD_3_9:1.33.0.2
	OPENBSD_3_9_BASE:1.33
	OPENBSD_3_8:1.32.0.2
	OPENBSD_3_8_BASE:1.32
	OPENBSD_3_7:1.31.0.2
	OPENBSD_3_7_BASE:1.31
	OPENBSD_3_6:1.30.0.4
	OPENBSD_3_6_BASE:1.30
	SMP_SYNC_A:1.28
	SMP_SYNC_B:1.28
	OPENBSD_3_5:1.28.0.4
	OPENBSD_3_5_BASE:1.28
	OPENBSD_3_4:1.28.0.2
	OPENBSD_3_4_BASE:1.28
	UBC_SYNC_A:1.27
	OPENBSD_3_3:1.26.0.2
	OPENBSD_3_3_BASE:1.26
	OPENBSD_3_2:1.25.0.2
	OPENBSD_3_2_BASE:1.25
	OPENBSD_3_1:1.17.0.4
	OPENBSD_3_1_BASE:1.17
	UBC_SYNC_B:1.25
	UBC:1.17.0.2
	UBC_BASE:1.17
	OPENBSD_3_0:1.16.0.2
	OPENBSD_3_0_BASE:1.16
	OPENBSD_2_9_BASE:1.14
	OPENBSD_2_9:1.14.0.2
	OPENBSD_2_8:1.11.0.2
	OPENBSD_2_8_BASE:1.11
	OPENBSD_2_7:1.10.0.2
	OPENBSD_2_7_BASE:1.10
	SMP:1.7.0.2
	SMP_BASE:1.7
	kame_19991208:1.7
	OPENBSD_2_6:1.6.0.2
	OPENBSD_2_6_BASE:1.6;
locks; strict;
comment	@ * @;


1.96
date	2017.07.21.20.13.41;	author ians;	state Exp;
branches;
next	1.95;
commitid	gv3Xov7L0BpjRczA;

1.95
date	2017.04.08.02.57.25;	author deraadt;	state Exp;
branches;
next	1.94;
commitid	6s3MfY9d6ZKdL2Uz;

1.94
date	2016.05.24.05.35.01;	author mpi;	state Exp;
branches;
next	1.93;
commitid	zkpZsVIWMnE2TPgn;

1.93
date	2016.03.17.21.36.48;	author krw;	state Exp;
branches;
next	1.92;
commitid	idWTuX14jOpqz25n;

1.92
date	2016.03.03.18.13.24;	author stefan;	state Exp;
branches;
next	1.91;
commitid	KhGZngmPmcr1rX2x;

1.91
date	2015.10.19.14.05.01;	author mpi;	state Exp;
branches;
next	1.90;
commitid	QMYG4uMKAxTkZUnQ;

1.90
date	2015.10.13.20.57.46;	author mpi;	state Exp;
branches;
next	1.89;
commitid	elsLtpoczk1NMLPJ;

1.89
date	2015.09.15.13.37.44;	author dcoppa;	state Exp;
branches;
next	1.88;
commitid	c1UjB6908vVKR7tp;

1.88
date	2015.09.07.19.58.42;	author mpi;	state Exp;
branches;
next	1.87;
commitid	8EfUWMbdGmmIdJtC;

1.87
date	2015.09.04.08.59.43;	author mpi;	state Exp;
branches;
next	1.86;
commitid	p6NBjW4mIxJgvEYp;

1.86
date	2015.09.03.07.50.22;	author mpi;	state Exp;
branches;
next	1.85;
commitid	dsr24Jqhlk6HCfUx;

1.85
date	2015.07.10.15.45.57;	author mpi;	state Exp;
branches;
next	1.84;
commitid	52zRvk9w7t08Hszo;

1.84
date	2015.06.15.15.45.28;	author mpi;	state Exp;
branches;
next	1.83;
commitid	fJDSm2PsdeBQgvgI;

1.83
date	2015.05.25.11.52.15;	author mpi;	state Exp;
branches;
next	1.82;
commitid	8sTwVCTRYPYJd4Qk;

1.82
date	2015.03.14.03.38.50;	author jsg;	state Exp;
branches;
next	1.81;
commitid	p4LJxGKbi0BU2cG6;

1.81
date	2015.02.10.21.56.09;	author miod;	state Exp;
branches;
next	1.80;
commitid	C5iGb36LQxjM60Q3;

1.80
date	2015.01.11.03.07.44;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	Xz45JVLhYr45686T;

1.79
date	2014.07.12.20.26.33;	author mpi;	state Exp;
branches;
next	1.78;
commitid	PSjXNz8dGohZ6ZSK;

1.78
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.77;
commitid	OBNa5kfxQ2UXoiIw;

1.77
date	2014.07.11.08.45.29;	author mpi;	state Exp;
branches;
next	1.76;
commitid	Jv7k41cFCQ7Fp0sm;

1.76
date	2013.11.19.14.04.07;	author pirofti;	state Exp;
branches;
next	1.75;

1.75
date	2013.11.06.16.58.13;	author pirofti;	state Exp;
branches;
next	1.74;

1.74
date	2013.11.02.01.41.17;	author jeremy;	state Exp;
branches;
next	1.73;

1.73
date	2013.09.20.15.34.50;	author mpi;	state Exp;
branches;
next	1.72;

1.72
date	2013.05.17.09.09.11;	author mpi;	state Exp;
branches;
next	1.71;

1.71
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.70;

1.70
date	2013.04.01.19.49.53;	author mglocker;	state Exp;
branches;
next	1.69;

1.69
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.68;

1.68
date	2011.12.07.06.23.18;	author mglocker;	state Exp;
branches;
next	1.67;

1.67
date	2011.10.14.12.50.44;	author mpi;	state Exp;
branches;
next	1.66;

1.66
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.65;

1.65
date	2011.07.02.22.20.08;	author nicm;	state Exp;
branches;
next	1.64;

1.64
date	2011.01.25.20.03.36;	author jakemsr;	state Exp;
branches;
next	1.63;

1.63
date	2011.01.16.22.35.29;	author jakemsr;	state Exp;
branches;
next	1.62;

1.62
date	2010.09.24.08.33.59;	author yuo;	state Exp;
branches;
next	1.61;

1.61
date	2009.11.09.17.53.39;	author nicm;	state Exp;
branches;
next	1.60;

1.60
date	2009.10.31.06.40.17;	author deraadt;	state Exp;
branches;
next	1.59;

1.59
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.58;

1.58
date	2009.07.19.08.16.06;	author blambert;	state Exp;
branches;
next	1.57;

1.57
date	2009.06.05.20.18.03;	author yuo;	state Exp;
branches;
next	1.56;

1.56
date	2008.12.14.16.48.04;	author fgsch;	state Exp;
branches;
next	1.55;

1.55
date	2008.09.08.19.35.25;	author martynas;	state Exp;
branches;
next	1.54;

1.54
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.53;

1.53
date	2008.06.14.02.40.23;	author todd;	state Exp;
branches;
next	1.52;

1.52
date	2007.10.20.22.44.01;	author fgsch;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.11.18.33.15;	author deraadt;	state Exp;
branches;
next	1.50;

1.50
date	2007.06.29.13.31.42;	author henning;	state Exp;
branches;
next	1.49;

1.49
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.48;

1.48
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.47;

1.47
date	2007.06.11.16.30.31;	author mbalmer;	state Exp;
branches;
next	1.46;

1.46
date	2007.06.11.12.36.52;	author mbalmer;	state Exp;
branches;
next	1.45;

1.45
date	2007.06.11.10.58.21;	author mbalmer;	state Exp;
branches;
next	1.44;

1.44
date	2007.06.11.09.26.55;	author mk;	state Exp;
branches;
next	1.43;

1.43
date	2007.06.10.14.49.01;	author mbalmer;	state Exp;
branches;
next	1.42;

1.42
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.41;

1.41
date	2007.06.06.19.25.49;	author mk;	state Exp;
branches;
next	1.40;

1.40
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.05.31.17.35.45;	author mbalmer;	state Exp;
branches;
next	1.38;

1.38
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.37;

1.37
date	2007.05.21.05.40.28;	author jsg;	state Exp;
branches;
next	1.36;

1.36
date	2006.11.01.03.37.23;	author tedu;	state Exp;
branches;
next	1.35;

1.35
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.34;

1.34
date	2006.06.17.16.27.58;	author miod;	state Exp;
branches;
next	1.33;

1.33
date	2005.11.21.18.16.43;	author millert;	state Exp;
branches;
next	1.32;

1.32
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.31.12.10.52;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.07.21.00.01.07;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.07.08.22.18.44;	author deraadt;	state Exp;
branches;
next	1.28;

1.28
date	2003.06.27.16.57.14;	author nate;	state Exp;
branches;
next	1.27;

1.27
date	2003.05.07.04.33.33;	author deraadt;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.11.02.32.32;	author nate;	state Exp;
branches;
next	1.25;

1.25
date	2002.07.25.04.07.32;	author nate;	state Exp;
branches;
next	1.24;

1.24
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.23;

1.23
date	2002.07.10.21.41.50;	author mickey;	state Exp;
branches;
next	1.22;

1.22
date	2002.07.09.17.50.14;	author nate;	state Exp;
branches;
next	1.21;

1.21
date	2002.07.09.17.41.02;	author nate;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.02.20.08.04;	author nate;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.31.04.24.44;	author nate;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.09.20.17.02.31;	author mpech;	state Exp;
branches;
next	1.15;

1.15
date	2001.05.03.02.20.33;	author aaron;	state Exp;
branches;
next	1.14;

1.14
date	2001.01.28.09.43.41;	author aaron;	state Exp;
branches;
next	1.13;

1.13
date	2000.11.21.18.45.53;	author mickey;	state Exp;
branches;
next	1.12;

1.12
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.04.11.44.23;	author fgsch;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.30.16.19.33;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.28.19.37.49;	author aaron;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.26.08.39.45;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	99.09.27.18.03.55;	author fgsch;	state Exp;
branches;
next	1.5;

1.5
date	99.08.31.07.42.50;	author fgsch;	state Exp;
branches;
next	1.4;

1.4
date	99.08.29.10.35.35;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.28;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.48;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.7.2.1
date	2001.05.14.22.26.21;	author niklas;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.07.04.10.43.51;	author niklas;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2001.10.31.03.22.49;	author nate;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2001.11.13.21.10.04;	author niklas;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2003.03.28.00.38.31;	author niklas;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2003.05.13.19.35.12;	author ho;	state Exp;
branches;
next	1.7.2.7;

1.7.2.7
date	2004.02.19.10.56.33;	author niklas;	state Exp;
branches;
next	;

1.17.2.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	1.17.2.3;

1.17.2.3
date	2003.05.19.22.24.07;	author tedu;	state Exp;
branches;
next	;


desc
@@


1.96
log
@Do not permit USB ioctl handler malloc(9)'s to block as this interferes
with expected behavior.

OK mpi@@ patrick@@
@
text
@/*	$OpenBSD: ugen.c,v 1.95 2017/04/08 02:57:25 deraadt Exp $ */
/*	$NetBSD: ugen.c,v 1.63 2002/11/26 18:49:48 christos Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/ugen.c,v 1.26 1999/11/17 22:33:41 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/ioctl.h>
#include <sys/conf.h>
#include <sys/tty.h>
#include <sys/file.h>
#include <sys/selinfo.h>
#include <sys/vnode.h>
#include <sys/poll.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>

#ifdef UGEN_DEBUG
#define DPRINTF(x)	do { if (ugendebug) printf x; } while (0)
#define DPRINTFN(n,x)	do { if (ugendebug>(n)) printf x; } while (0)
int	ugendebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define	UGEN_CHUNK	128	/* chunk size for read */
#define	UGEN_IBSIZE	1020	/* buffer size */
#define	UGEN_BBSIZE	1024

#define	UGEN_NISOFRAMES	500	/* 0.5 seconds worth */
#define UGEN_NISOREQS	6	/* number of outstanding xfer requests */
#define UGEN_NISORFRMS	4	/* number of frames (milliseconds) per req */

struct ugen_endpoint {
	struct ugen_softc *sc;
	usb_endpoint_descriptor_t *edesc;
	struct usbd_interface *iface;
	int state;
#define	UGEN_ASLP	0x02	/* waiting for data */
#define UGEN_SHORT_OK	0x04	/* short xfers are OK */
	struct usbd_pipe *pipeh;
	struct clist q;
	struct selinfo rsel;
	u_char *ibuf;		/* start of buffer (circular for isoc) */
	size_t  ibuflen;
	u_char *fill;		/* location for input (isoc) */
	u_char *limit;		/* end of circular buffer (isoc) */
	u_char *cur;		/* current read location (isoc) */
	u_int32_t timeout;
	struct isoreq {
		struct ugen_endpoint *sce;
		struct usbd_xfer *xfer;
		void *dmabuf;
		u_int16_t sizes[UGEN_NISORFRMS];
	} isoreqs[UGEN_NISOREQS];
};

struct ugen_softc {
	struct device sc_dev;		/* base device */
	struct usbd_device *sc_udev;

	char sc_is_open[USB_MAX_ENDPOINTS];
	struct ugen_endpoint sc_endpoints[USB_MAX_ENDPOINTS][2];
#define OUT 0
#define IN  1

	int sc_refcnt;
	u_char sc_secondary;
};

void ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
void ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status);
int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
int ugen_do_write(struct ugen_softc *, int, struct uio *, int);
int ugen_do_ioctl(struct ugen_softc *, int, u_long, caddr_t, int,
	struct proc *);
int ugen_do_close(struct ugen_softc *, int, int);
int ugen_set_config(struct ugen_softc *sc, int configno);
int ugen_set_interface(struct ugen_softc *, int, int);
int ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx);

#define UGENUNIT(n) ((minor(n) >> 4) & 0xf)
#define UGENENDPOINT(n) (minor(n) & 0xf)
#define UGENDEV(u, e) (makedev(0, ((u) << 4) | (e)))

int ugen_match(struct device *, void *, void *);
void ugen_attach(struct device *, struct device *, void *);
int ugen_detach(struct device *, int);

struct cfdriver ugen_cd = {
	NULL, "ugen", DV_DULL
};

const struct cfattach ugen_ca = {
	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach
};

int
ugen_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->usegeneric) {
		return (UMATCH_GENERIC);
	} else
		return (UMATCH_NONE);
}

void
ugen_attach(struct device *parent, struct device *self, void *aux)
{
	struct ugen_softc *sc = (struct ugen_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *udev;
	usbd_status err;
	int conf;

	sc->sc_udev = udev = uaa->device;

	if (usbd_get_devcnt(udev) > 0)
		sc->sc_secondary = 1;

	if (!sc->sc_secondary) {
		/* First set configuration index 0, the default one for ugen. */
		err = usbd_set_config_index(udev, 0, 0);
		if (err) {
			printf("%s: setting configuration index 0 failed\n",
			       sc->sc_dev.dv_xname);
			usbd_deactivate(sc->sc_udev);
			return;
		}
	}
	conf = usbd_get_config_descriptor(udev)->bConfigurationValue;

	/* Set up all the local state for this configuration. */
	err = ugen_set_config(sc, conf);
	if (err) {
		printf("%s: setting configuration %d failed\n",
		       sc->sc_dev.dv_xname, conf);
		usbd_deactivate(sc->sc_udev);
		return;
	}
}

int
ugen_set_config(struct ugen_softc *sc, int configno)
{
	struct usbd_device *dev = sc->sc_udev;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	struct usbd_interface *iface;
	usb_endpoint_descriptor_t *ed;
	struct ugen_endpoint *sce;
	int ifaceno, endptno, endpt;
	int err, dir;

	DPRINTFN(1,("ugen_set_config: %s to configno %d, sc=%p\n",
		    sc->sc_dev.dv_xname, configno, sc));

	/*
	 * We start at 1, not 0, because we don't care whether the
	 * control endpoint is open or not. It is always present.
	 */
	for (endptno = 1; endptno < USB_MAX_ENDPOINTS; endptno++)
		if (sc->sc_is_open[endptno]) {
			DPRINTFN(1,
			     ("ugen_set_config: %s - endpoint %d is open\n",
			      sc->sc_dev.dv_xname, endptno));
			return (USBD_IN_USE);
		}

	/* Avoid setting the current value. */
	cdesc = usbd_get_config_descriptor(dev);
	if (cdesc == NULL || cdesc->bConfigurationValue != configno) {
		if (sc->sc_secondary) {
			printf("%s: secondary, not changing config to %d\n",
			    __func__, configno);
			return (USBD_IN_USE);
		} else {
			err = usbd_set_config_no(dev, configno, 1);
			if (err)
				return (err);
		}
	}

	memset(sc->sc_endpoints, 0, sizeof sc->sc_endpoints);
	for (ifaceno = 0; ifaceno < cdesc->bNumInterface; ifaceno++) {
		DPRINTFN(1,("ugen_set_config: ifaceno %d\n", ifaceno));
		if (usbd_iface_claimed(sc->sc_udev, ifaceno)) {
			DPRINTF(("%s: iface %d not available\n", __func__,
			    ifaceno));
			continue;
		}
		err = usbd_device2interface_handle(dev, ifaceno, &iface);
		if (err)
			return (err);
		id = usbd_get_interface_descriptor(iface);
		for (endptno = 0; endptno < id->bNumEndpoints; endptno++) {
			ed = usbd_interface2endpoint_descriptor(iface,endptno);
			endpt = ed->bEndpointAddress;
			dir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;
			sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];
			DPRINTFN(1,("ugen_set_config: endptno %d, endpt=0x%02x"
				    "(%d,%d), sce=%p\n",
				    endptno, endpt, UE_GET_ADDR(endpt),
				    UE_GET_DIR(endpt), sce));
			sce->sc = sc;
			sce->edesc = ed;
			sce->iface = iface;
		}
	}
	return (0);
}

int
ugenopen(dev_t dev, int flag, int mode, struct proc *p)
{
	struct ugen_softc *sc;
	int unit = UGENUNIT(dev);
	int endpt = UGENENDPOINT(dev);
	usb_endpoint_descriptor_t *edesc;
	struct ugen_endpoint *sce;
	int dir, isize;
	usbd_status err;
	struct usbd_xfer *xfer;
	void *buf;
	int i, j;

	if (unit >= ugen_cd.cd_ndevs)
		return (ENXIO);
	sc = ugen_cd.cd_devs[unit];
	if (sc == NULL)
		return (ENXIO);

	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n",
		     flag, mode, unit, endpt));

	if (sc == NULL || usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	if (sc->sc_is_open[endpt])
		return (EBUSY);

	if (endpt == USB_CONTROL_ENDPOINT) {
		sc->sc_is_open[USB_CONTROL_ENDPOINT] = 1;
		return (0);
	}

	/* Make sure there are pipes for all directions. */
	for (dir = OUT; dir <= IN; dir++) {
		if (flag & (dir == OUT ? FWRITE : FREAD)) {
			sce = &sc->sc_endpoints[endpt][dir];
			if (sce == 0 || sce->edesc == 0)
				return (ENXIO);
		}
	}

	/* Actually open the pipes. */
	/* XXX Should back out properly if it fails. */
	for (dir = OUT; dir <= IN; dir++) {
		if (!(flag & (dir == OUT ? FWRITE : FREAD)))
			continue;
		sce = &sc->sc_endpoints[endpt][dir];
		sce->state = 0;
		sce->timeout = USBD_NO_TIMEOUT;
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n",
			     sc, endpt, dir, sce));
		edesc = sce->edesc;
		switch (edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			if (dir == OUT) {
				err = usbd_open_pipe(sce->iface,
				    edesc->bEndpointAddress, 0, &sce->pipeh);
				if (err)
					return (EIO);
				break;
			}
			isize = UGETW(edesc->wMaxPacketSize);
			if (isize == 0)	/* shouldn't happen */
				return (EINVAL);
			sce->ibuflen = isize;
			sce->ibuf = malloc(sce->ibuflen, M_USBDEV, M_WAITOK);
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n",
				     endpt, isize));
			clalloc(&sce->q, UGEN_IBSIZE, 0);
			err = usbd_open_pipe_intr(sce->iface,
				  edesc->bEndpointAddress,
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce,
				  sce->ibuf, isize, ugenintr,
				  USBD_DEFAULT_INTERVAL);
			if (err) {
				free(sce->ibuf, M_USBDEV, sce->ibuflen);
				clfree(&sce->q);
				return (EIO);
			}
			DPRINTFN(5, ("ugenopen: interrupt open done\n"));
			break;
		case UE_BULK:
			err = usbd_open_pipe(sce->iface,
				  edesc->bEndpointAddress, 0, &sce->pipeh);
			if (err)
				return (EIO);
			break;
		case UE_ISOCHRONOUS:
			if (dir == OUT)
				return (EINVAL);
			isize = UGETW(edesc->wMaxPacketSize);
			if (isize == 0)	/* shouldn't happen */
				return (EINVAL);
			sce->ibuflen = isize * UGEN_NISOFRAMES;
			sce->ibuf = mallocarray(isize, UGEN_NISOFRAMES,
				M_USBDEV, M_WAITOK);
			sce->cur = sce->fill = sce->ibuf;
			sce->limit = sce->ibuf + isize * UGEN_NISOFRAMES;
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n",
				     endpt, isize));
			err = usbd_open_pipe(sce->iface,
				  edesc->bEndpointAddress, 0, &sce->pipeh);
			if (err) {
				free(sce->ibuf, M_USBDEV, sce->ibuflen);
				return (EIO);
			}
			for(i = 0; i < UGEN_NISOREQS; ++i) {
				sce->isoreqs[i].sce = sce;
				xfer = usbd_alloc_xfer(sc->sc_udev);
				if (xfer == 0)
					goto bad;
				sce->isoreqs[i].xfer = xfer;
				buf = usbd_alloc_buffer
					(xfer, isize * UGEN_NISORFRMS);
				if (buf == 0) {
					i++;
					goto bad;
				}
				sce->isoreqs[i].dmabuf = buf;
				for(j = 0; j < UGEN_NISORFRMS; ++j)
					sce->isoreqs[i].sizes[j] = isize;
				usbd_setup_isoc_xfer(xfer, sce->pipeh,
				    &sce->isoreqs[i], sce->isoreqs[i].sizes,
				    UGEN_NISORFRMS, USBD_NO_COPY |
				    USBD_SHORT_XFER_OK, ugen_isoc_rintr);
				(void)usbd_transfer(xfer);
			}
			DPRINTFN(5, ("ugenopen: isoc open done\n"));
			break;
		bad:
			while (--i >= 0) /* implicit buffer free */
				usbd_free_xfer(sce->isoreqs[i].xfer);
			return (ENOMEM);
		case UE_CONTROL:
			sce->timeout = USBD_DEFAULT_TIMEOUT;
			return (EINVAL);
		}
	}
	sc->sc_is_open[endpt] = 1;
	return (0);
}

int
ugenclose(dev_t dev, int flag, int mode, struct proc *p)
{
	struct ugen_softc *sc = ugen_cd.cd_devs[UGENUNIT(dev)];
	int endpt = UGENENDPOINT(dev);
	int error;

	if (sc == NULL || usbd_is_dying(sc->sc_udev))
		return (EIO);

	DPRINTFN(5, ("ugenclose: flag=%d, mode=%d, unit=%d, endpt=%d\n",
		     flag, mode, UGENUNIT(dev), endpt));

	sc->sc_refcnt++;
	error = ugen_do_close(sc, endpt, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
ugen_do_close(struct ugen_softc *sc, int endpt, int flag)
{
	struct ugen_endpoint *sce;
	int dir, i;

#ifdef DIAGNOSTIC
	if (!sc->sc_is_open[endpt]) {
		printf("ugenclose: not open\n");
		return (EINVAL);
	}
#endif

	if (endpt == USB_CONTROL_ENDPOINT) {
		DPRINTFN(5, ("ugenclose: close control\n"));
		sc->sc_is_open[endpt] = 0;
		return (0);
	}

	for (dir = OUT; dir <= IN; dir++) {
		if (!(flag & (dir == OUT ? FWRITE : FREAD)))
			continue;
		sce = &sc->sc_endpoints[endpt][dir];
		if (sce == NULL || sce->pipeh == NULL)
			continue;
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n",
			     endpt, dir, sce));

		usbd_close_pipe(sce->pipeh);
		sce->pipeh = NULL;

		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			ndflush(&sce->q, sce->q.c_cc);
			clfree(&sce->q);
			break;
		case UE_ISOCHRONOUS:
			for (i = 0; i < UGEN_NISOREQS; ++i)
				usbd_free_xfer(sce->isoreqs[i].xfer);

		default:
			break;
		}

		if (sce->ibuf != NULL) {
			free(sce->ibuf, M_USBDEV, sce->ibuflen);
			sce->ibuf = NULL;
		}
	}
	sc->sc_is_open[endpt] = 0;

	return (0);
}

int
ugen_do_read(struct ugen_softc *sc, int endpt, struct uio *uio, int flag)
{
	struct ugen_endpoint *sce = &sc->sc_endpoints[endpt][IN];
	u_int32_t tn;
	size_t n;
	char buf[UGEN_BBSIZE];
	struct usbd_xfer *xfer;
	usbd_status err;
	int s;
	int flags, error = 0;
	u_char buffer[UGEN_CHUNK];

	DPRINTFN(5, ("%s: ugenread: %d\n", sc->sc_dev.dv_xname, endpt));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (endpt == USB_CONTROL_ENDPOINT)
		return (ENODEV);

#ifdef DIAGNOSTIC
	if (sce->edesc == NULL) {
		printf("ugenread: no edesc\n");
		return (EIO);
	}
	if (sce->pipeh == NULL) {
		printf("ugenread: no pipe\n");
		return (EIO);
	}
#endif

	switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
	case UE_INTERRUPT:
		/* Block until activity occurred. */
		s = splusb();
		while (sce->q.c_cc == 0) {
			if (flag & IO_NDELAY) {
				splx(s);
				return (EWOULDBLOCK);
			}
			sce->state |= UGEN_ASLP;
			DPRINTFN(5, ("ugenread: sleep on %p\n", sce));
			error = tsleep(sce, PZERO | PCATCH, "ugenri",
			    (sce->timeout * hz) / 1000);
			sce->state &= ~UGEN_ASLP;
			DPRINTFN(5, ("ugenread: woke, error=%d\n", error));
			if (usbd_is_dying(sc->sc_udev))
				error = EIO;
			if (error == EWOULDBLOCK) {	/* timeout, return 0 */
				error = 0;
				break;
			}
			if (error)
				break;
		}
		splx(s);

		/* Transfer as many chunks as possible. */
		while (sce->q.c_cc > 0 && uio->uio_resid > 0 && !error) {
			n = ulmin(sce->q.c_cc, uio->uio_resid);
			if (n > sizeof(buffer))
				n = sizeof(buffer);

			/* Remove a small chunk from the input queue. */
			q_to_b(&sce->q, buffer, n);
			DPRINTFN(5, ("ugenread: got %zu chars\n", n));

			/* Copy the data to the user process. */
			error = uiomove(buffer, n, uio);
			if (error)
				break;
		}
		break;
	case UE_BULK:
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
			return (ENOMEM);
		flags = USBD_SYNCHRONOUS;
		if (sce->state & UGEN_SHORT_OK)
			flags |= USBD_SHORT_XFER_OK;
		if (sce->timeout == 0)
			flags |= USBD_CATCH;
		while ((n = ulmin(UGEN_BBSIZE, uio->uio_resid)) != 0) {
			DPRINTFN(1, ("ugenread: start transfer %zu bytes\n",n));
			usbd_setup_xfer(xfer, sce->pipeh, 0, buf, n,
			    flags, sce->timeout, NULL);
			err = usbd_transfer(xfer);
			if (err) {
				usbd_clear_endpoint_stall(sce->pipeh);
				if (err == USBD_INTERRUPTED)
					error = EINTR;
				else if (err == USBD_TIMEOUT)
					error = ETIMEDOUT;
				else
					error = EIO;
				break;
			}
			usbd_get_xfer_status(xfer, NULL, NULL, &tn, NULL);
			DPRINTFN(1, ("ugenread: got %u bytes\n", tn));
			error = uiomove(buf, tn, uio);
			if (error || tn < n)
				break;
		}
		usbd_free_xfer(xfer);
		break;
	case UE_ISOCHRONOUS:
		s = splusb();
		while (sce->cur == sce->fill) {
			if (flag & IO_NDELAY) {
				splx(s);
				return (EWOULDBLOCK);
			}
			sce->state |= UGEN_ASLP;
			DPRINTFN(5, ("ugenread: sleep on %p\n", sce));
			error = tsleep(sce, PZERO | PCATCH, "ugenri",
			    (sce->timeout * hz) / 1000);
			sce->state &= ~UGEN_ASLP;
			DPRINTFN(5, ("ugenread: woke, error=%d\n", error));
			if (usbd_is_dying(sc->sc_udev))
				error = EIO;
			if (error == EWOULDBLOCK) {	/* timeout, return 0 */
				error = 0;
				break;
			}
			if (error)
				break;
		}

		while (sce->cur != sce->fill && uio->uio_resid > 0 && !error) {
			if(sce->fill > sce->cur)
				n = ulmin(sce->fill - sce->cur, uio->uio_resid);
			else
				n = ulmin(sce->limit - sce->cur, uio->uio_resid);

			DPRINTFN(5, ("ugenread: isoc got %zu chars\n", n));

			/* Copy the data to the user process. */
			error = uiomove(sce->cur, n, uio);
			if (error)
				break;
			sce->cur += n;
			if(sce->cur >= sce->limit)
				sce->cur = sce->ibuf;
		}
		splx(s);
		break;


	default:
		return (ENXIO);
	}
	return (error);
}

int
ugenread(dev_t dev, struct uio *uio, int flag)
{
	int endpt = UGENENDPOINT(dev);
	struct ugen_softc *sc;
	int error;

	sc = ugen_cd.cd_devs[UGENUNIT(dev)];

	sc->sc_refcnt++;
	error = ugen_do_read(sc, endpt, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
ugen_do_write(struct ugen_softc *sc, int endpt, struct uio *uio, int flag)
{
	struct ugen_endpoint *sce = &sc->sc_endpoints[endpt][OUT];
	size_t n;
	int flags, error = 0;
	char buf[UGEN_BBSIZE];
	struct usbd_xfer *xfer;
	usbd_status err;

	DPRINTFN(5, ("%s: ugenwrite: %d\n", sc->sc_dev.dv_xname, endpt));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	if (endpt == USB_CONTROL_ENDPOINT)
		return (ENODEV);

#ifdef DIAGNOSTIC
	if (sce->edesc == NULL) {
		printf("ugenwrite: no edesc\n");
		return (EIO);
	}
	if (sce->pipeh == NULL) {
		printf("ugenwrite: no pipe\n");
		return (EIO);
	}
#endif
	flags = USBD_SYNCHRONOUS;
	if (sce->timeout == 0)
		flags |= USBD_CATCH;

	switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
	case UE_BULK:
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
			return (EIO);
		while ((n = ulmin(UGEN_BBSIZE, uio->uio_resid)) != 0) {
			error = uiomove(buf, n, uio);
			if (error)
				break;
			DPRINTFN(1, ("ugenwrite: transfer %zu bytes\n", n));
			usbd_setup_xfer(xfer, sce->pipeh, 0, buf, n,
			    flags, sce->timeout, NULL);
			err = usbd_transfer(xfer);
			if (err) {
				usbd_clear_endpoint_stall(sce->pipeh);
				if (err == USBD_INTERRUPTED)
					error = EINTR;
				else if (err == USBD_TIMEOUT)
					error = ETIMEDOUT;
				else
					error = EIO;
				break;
			}
		}
		usbd_free_xfer(xfer);
		break;
	case UE_INTERRUPT:
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
			return (EIO);
		while ((n = ulmin(UGETW(sce->edesc->wMaxPacketSize),
		    uio->uio_resid)) != 0) {
			error = uiomove(buf, n, uio);
			if (error)
				break;
			DPRINTFN(1, ("ugenwrite: transfer %zu bytes\n", n));
			usbd_setup_xfer(xfer, sce->pipeh, 0, buf, n,
			    flags, sce->timeout, NULL);
			err = usbd_transfer(xfer);
			if (err) {
				usbd_clear_endpoint_stall(sce->pipeh);
				if (err == USBD_INTERRUPTED)
					error = EINTR;
				else if (err == USBD_TIMEOUT)
					error = ETIMEDOUT;
				else
					error = EIO;
				break;
			}
		}
		usbd_free_xfer(xfer);
		break;
	default:
		return (ENXIO);
	}
	return (error);
}

int
ugenwrite(dev_t dev, struct uio *uio, int flag)
{
	int endpt = UGENENDPOINT(dev);
	struct ugen_softc *sc;
	int error;

	sc = ugen_cd.cd_devs[UGENUNIT(dev)];

	sc->sc_refcnt++;
	error = ugen_do_write(sc, endpt, uio, flag);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
ugen_detach(struct device *self, int flags)
{
	struct ugen_softc *sc = (struct ugen_softc *)self;
	struct ugen_endpoint *sce;
	int i, dir, endptno;
	int s, maj, mn;

	DPRINTF(("ugen_detach: sc=%p flags=%d\n", sc, flags));

	/* Abort all pipes.  Causes processes waiting for transfer to wake. */
	for (i = 0; i < USB_MAX_ENDPOINTS; i++) {
		for (dir = OUT; dir <= IN; dir++) {
			sce = &sc->sc_endpoints[i][dir];
			if (sce && sce->pipeh)
				usbd_abort_pipe(sce->pipeh);
		}
	}

	s = splusb();
	if (--sc->sc_refcnt >= 0) {
		/* Wake everyone */
		for (i = 0; i < USB_MAX_ENDPOINTS; i++)
			wakeup(&sc->sc_endpoints[i][IN]);
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->sc_dev);
	}
	splx(s);

	/* locate the major number */
	for (maj = 0; maj < nchrdev; maj++)
		if (cdevsw[maj].d_open == ugenopen)
			break;

	/* Nuke the vnodes for any open instances (calls close). */
	mn = self->dv_unit * USB_MAX_ENDPOINTS;
	vdevgone(maj, mn, mn + USB_MAX_ENDPOINTS - 1, VCHR);

	for (endptno = 0; endptno < USB_MAX_ENDPOINTS; endptno++) {
		if (sc->sc_is_open[endptno])
			ugen_do_close(sc, endptno, FREAD|FWRITE);
	}
	return (0);
}

void
ugenintr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct ugen_endpoint *sce = addr;
	/*struct ugen_softc *sc = sce->sc;*/
	u_int32_t count;
	u_char *ibuf;

	if (status == USBD_CANCELLED)
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		DPRINTF(("ugenintr: status=%d\n", status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sce->pipeh);
		return;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	ibuf = sce->ibuf;

	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n",
		     xfer, status, count));
	DPRINTFN(5, ("          data = %02x %02x %02x\n",
		     ibuf[0], ibuf[1], ibuf[2]));

	(void)b_to_q(ibuf, count, &sce->q);

	if (sce->state & UGEN_ASLP) {
		sce->state &= ~UGEN_ASLP;
		DPRINTFN(5, ("ugen_intr: waking %p\n", sce));
		wakeup(sce);
	}
	selwakeup(&sce->rsel);
}

void
ugen_isoc_rintr(struct usbd_xfer *xfer, void *addr, usbd_status status)
{
	struct isoreq *req = addr;
	struct ugen_endpoint *sce = req->sce;
	u_int32_t count, n;
	int i, isize;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("%s: xfer %ld, count=%d\n", __func__, req - sce->isoreqs,
	    count));

	/* throw away oldest input if the buffer is full */
	if(sce->fill < sce->cur && sce->cur <= sce->fill + count) {
		sce->cur += count;
		if(sce->cur >= sce->limit)
			sce->cur = sce->ibuf + (sce->limit - sce->cur);
		DPRINTFN(5, ("%s: throwing away %d bytes\n", __func__, count));
	}

	isize = UGETW(sce->edesc->wMaxPacketSize);
	for (i = 0; i < UGEN_NISORFRMS; i++) {
		u_int32_t actlen = req->sizes[i];
		char const *buf = (char const *)req->dmabuf + isize * i;

		/* copy data to buffer */
		while (actlen > 0) {
			n = min(actlen, sce->limit - sce->fill);
			memcpy(sce->fill, buf, n);

			buf += n;
			actlen -= n;
			sce->fill += n;
			if(sce->fill == sce->limit)
				sce->fill = sce->ibuf;
		}

		/* setup size for next transfer */
		req->sizes[i] = isize;
	}

	usbd_setup_isoc_xfer(xfer, sce->pipeh, req, req->sizes, UGEN_NISORFRMS,
	    USBD_NO_COPY | USBD_SHORT_XFER_OK, ugen_isoc_rintr);
	(void)usbd_transfer(xfer);

	if (sce->state & UGEN_ASLP) {
		sce->state &= ~UGEN_ASLP;
		DPRINTFN(5, ("ugen_isoc_rintr: waking %p\n", sce));
		wakeup(sce);
	}
	selwakeup(&sce->rsel);
}

int 
ugen_set_interface(struct ugen_softc *sc, int ifaceidx, int altno)
{
	struct usbd_interface *iface;
	usb_config_descriptor_t *cdesc;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	struct ugen_endpoint *sce;
	uint8_t  endptno, endpt;
	int dir, err;

	DPRINTFN(15, ("ugen_set_interface %d %d\n", ifaceidx, altno));

	cdesc = usbd_get_config_descriptor(sc->sc_udev);
	if (ifaceidx < 0 || ifaceidx >= cdesc->bNumInterface ||
	    usbd_iface_claimed(sc->sc_udev, ifaceidx))
		return (USBD_INVAL);

	err = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (err)
		return (err);
	id = usbd_get_interface_descriptor(iface);
	for (endptno = 0; endptno < id->bNumEndpoints; endptno++) {
		ed = usbd_interface2endpoint_descriptor(iface,endptno);
		endpt = ed->bEndpointAddress;
		dir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;
		sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];
		sce->sc = 0;
		sce->edesc = 0;
		sce->iface = 0;
	}

	/* Try to change setting, if this fails put back the descriptors. */
	err = usbd_set_interface(iface, altno);

	id = usbd_get_interface_descriptor(iface);
	for (endptno = 0; endptno < id->bNumEndpoints; endptno++) {
		ed = usbd_interface2endpoint_descriptor(iface,endptno);
		endpt = ed->bEndpointAddress;
		dir = UE_GET_DIR(endpt) == UE_DIR_IN ? IN : OUT;
		sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][dir];
		sce->sc = sc;
		sce->edesc = ed;
		sce->iface = iface;
	}
	return (err);
}

int
ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx)
{
	struct usbd_interface *iface;
	usbd_status err;

	err = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (err)
		return (-1);
	return (usbd_get_interface_altindex(iface));
}

int
ugen_do_ioctl(struct ugen_softc *sc, int endpt, u_long cmd, caddr_t addr,
    int flag, struct proc *p)
{
	struct ugen_endpoint *sce;
	int err;
	struct usbd_interface *iface;
	struct usb_config_desc *cd;
	usb_config_descriptor_t *cdesc;
	struct usb_interface_desc *id;
	usb_interface_descriptor_t *idesc;
	struct usb_endpoint_desc *ed;
	usb_endpoint_descriptor_t *edesc;
	struct usb_alt_interface *ai;
	u_int8_t conf, alt;

	DPRINTFN(5, ("ugenioctl: cmd=%08lx\n", cmd));
	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	switch (cmd) {
	case FIONBIO:
		/* All handled in the upper FS layer. */
		return (0);
	case USB_SET_SHORT_XFER:
		if (endpt == USB_CONTROL_ENDPOINT)
			return (EINVAL);
		/* This flag only affects read */
		sce = &sc->sc_endpoints[endpt][IN];
		if (sce == NULL || sce->pipeh == NULL)
			return (EINVAL);
		if (*(int *)addr)
			sce->state |= UGEN_SHORT_OK;
		else
			sce->state &= ~UGEN_SHORT_OK;
		return (0);
	case USB_SET_TIMEOUT:
		sce = &sc->sc_endpoints[endpt][IN];
		if (sce == NULL)
			return (EINVAL);
		sce->timeout = *(int *)addr;
		sce = &sc->sc_endpoints[endpt][OUT];
		if (sce == NULL)
			return (EINVAL);
		sce->timeout = *(int *)addr;
		return (0);
	default:
		break;
	}

	if (endpt != USB_CONTROL_ENDPOINT)
		return (EINVAL);

	switch (cmd) {
#ifdef UGEN_DEBUG
	case USB_SETDEBUG:
		ugendebug = *(int *)addr;
		break;
#endif
	case USB_GET_CONFIG:
		err = usbd_get_config(sc->sc_udev, &conf);
		if (err)
			return (EIO);
		*(int *)addr = conf;
		break;
	case USB_SET_CONFIG:
		if (!(flag & FWRITE))
			return (EPERM);
		err = ugen_set_config(sc, *(int *)addr);
		switch (err) {
		case USBD_NORMAL_COMPLETION:
			break;
		case USBD_IN_USE:
			return (EBUSY);
		default:
			return (EIO);
		}
		break;
	case USB_GET_ALTINTERFACE:
		ai = (struct usb_alt_interface *)addr;
		err = usbd_device2interface_handle(sc->sc_udev,
			  ai->uai_interface_index, &iface);
		if (err)
			return (EINVAL);
		idesc = usbd_get_interface_descriptor(iface);
		if (idesc == NULL)
			return (EIO);
		ai->uai_alt_no = idesc->bAlternateSetting;
		break;
	case USB_SET_ALTINTERFACE:
		if (!(flag & FWRITE))
			return (EPERM);
		ai = (struct usb_alt_interface *)addr;
		err = usbd_device2interface_handle(sc->sc_udev,
			  ai->uai_interface_index, &iface);
		if (err)
			return (EINVAL);
		err = ugen_set_interface(sc, ai->uai_interface_index,
		    ai->uai_alt_no);
		if (err)
			return (EINVAL);
		break;
	case USB_GET_NO_ALT:
		ai = (struct usb_alt_interface *)addr;
		cdesc = usbd_get_cdesc(sc->sc_udev, ai->uai_config_index, 0);
		if (cdesc == NULL)
			return (EINVAL);
		idesc = usbd_find_idesc(cdesc, ai->uai_interface_index, 0);
		if (idesc == NULL) {
			free(cdesc, M_TEMP, 0);
			return (EINVAL);
		}
		ai->uai_alt_no = usbd_get_no_alts(cdesc,
		    idesc->bInterfaceNumber);
		free(cdesc, M_TEMP, 0);
		break;
	case USB_GET_DEVICE_DESC:
		*(usb_device_descriptor_t *)addr =
			*usbd_get_device_descriptor(sc->sc_udev);
		break;
	case USB_GET_CONFIG_DESC:
		cd = (struct usb_config_desc *)addr;
		cdesc = usbd_get_cdesc(sc->sc_udev, cd->ucd_config_index, 0);
		if (cdesc == NULL)
			return (EINVAL);
		cd->ucd_desc = *cdesc;
		free(cdesc, M_TEMP, 0);
		break;
	case USB_GET_INTERFACE_DESC:
		id = (struct usb_interface_desc *)addr;
		cdesc = usbd_get_cdesc(sc->sc_udev, id->uid_config_index, 0);
		if (cdesc == NULL)
			return (EINVAL);
		if (id->uid_config_index == USB_CURRENT_CONFIG_INDEX &&
		    id->uid_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, id->uid_interface_index);
		else
			alt = id->uid_alt_index;
		idesc = usbd_find_idesc(cdesc, id->uid_interface_index, alt);
		if (idesc == NULL) {
			free(cdesc, M_TEMP, 0);
			return (EINVAL);
		}
		id->uid_desc = *idesc;
		free(cdesc, M_TEMP, 0);
		break;
	case USB_GET_ENDPOINT_DESC:
		ed = (struct usb_endpoint_desc *)addr;
		cdesc = usbd_get_cdesc(sc->sc_udev, ed->ued_config_index, 0);
		if (cdesc == NULL)
			return (EINVAL);
		if (ed->ued_config_index == USB_CURRENT_CONFIG_INDEX &&
		    ed->ued_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, ed->ued_interface_index);
		else
			alt = ed->ued_alt_index;
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index,
					alt, ed->ued_endpoint_index);
		if (edesc == NULL) {
			free(cdesc, M_TEMP, 0);
			return (EINVAL);
		}
		ed->ued_desc = *edesc;
		free(cdesc, M_TEMP, 0);
		break;
	case USB_GET_FULL_DESC:
	{
		u_int len;
		struct iovec iov;
		struct uio uio;
		struct usb_full_desc *fd = (struct usb_full_desc *)addr;
		int error;

		cdesc = usbd_get_cdesc(sc->sc_udev, fd->ufd_config_index, &len);
		if (cdesc == NULL)
			return (EINVAL);
		if (len > fd->ufd_size)
			len = fd->ufd_size;
		iov.iov_base = (caddr_t)fd->ufd_data;
		iov.iov_len = len;
		uio.uio_iov = &iov;
		uio.uio_iovcnt = 1;
		uio.uio_resid = len;
		uio.uio_offset = 0;
		uio.uio_segflg = UIO_USERSPACE;
		uio.uio_rw = UIO_READ;
		uio.uio_procp = p;
		error = uiomove((void *)cdesc, len, &uio);
		free(cdesc, M_TEMP, 0);
		return (error);
	}
	case USB_DO_REQUEST:
	{
		struct usb_ctl_request *ur = (void *)addr;
		size_t len = UGETW(ur->ucr_request.wLength), mlen;
		struct iovec iov;
		struct uio uio;
		void *ptr = NULL;
		int error = 0;

		if (!(flag & FWRITE))
			return (EPERM);
		/* Avoid requests that would damage the bus integrity. */
		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
			return (EINVAL);

		if (len > 32767)
			return (EINVAL);
		if (len != 0) {
			iov.iov_base = (caddr_t)ur->ucr_data;
			iov.iov_len = len;
			uio.uio_iov = &iov;
			uio.uio_iovcnt = 1;
			uio.uio_resid = len;
			uio.uio_offset = 0;
			uio.uio_segflg = UIO_USERSPACE;
			uio.uio_rw =
				ur->ucr_request.bmRequestType & UT_READ ?
				UIO_READ : UIO_WRITE;
			uio.uio_procp = p;
			if ((ptr = malloc(len, M_TEMP, M_NOWAIT)) == NULL) {
				error = ENOMEM;
				goto ret;
			}
			if (uio.uio_rw == UIO_WRITE) {
				error = uiomove(ptr, len, &uio);
				if (error)
					goto ret;
			}
		}
		sce = &sc->sc_endpoints[endpt][IN];
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
		if (err) {
			error = EIO;
			goto ret;
		}
		/* Only if USBD_SHORT_XFER_OK is set. */
		mlen = len;
		if (mlen > ur->ucr_actlen)
			mlen = ur->ucr_actlen;
		if (mlen != 0) {
			if (uio.uio_rw == UIO_READ) {
				error = uiomove(ptr, mlen, &uio);
				if (error)
					goto ret;
			}
		}
	ret:
		if (ptr)
			free(ptr, M_TEMP, len);
		return (error);
	}
	case USB_GET_DEVICEINFO:
		usbd_fill_deviceinfo(sc->sc_udev,
				     (struct usb_device_info *)addr, 1);
		break;
	default:
		return (EINVAL);
	}
	return (0);
}

int
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
{
	int endpt = UGENENDPOINT(dev);
	struct ugen_softc *sc;
	int error;

	sc = ugen_cd.cd_devs[UGENUNIT(dev)];

	sc->sc_refcnt++;
	error = ugen_do_ioctl(sc, endpt, cmd, addr, flag, p);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	return (error);
}

int
ugenpoll(dev_t dev, int events, struct proc *p)
{
	struct ugen_softc *sc;
	struct ugen_endpoint *sce;
	int revents = 0;
	int s;

	sc = ugen_cd.cd_devs[UGENUNIT(dev)];

	if (usbd_is_dying(sc->sc_udev))
		return (POLLERR);

	/* XXX always IN */
	sce = &sc->sc_endpoints[UGENENDPOINT(dev)][IN];
	if (sce == NULL)
		return (POLLERR);
#ifdef DIAGNOSTIC
	if (!sce->edesc) {
		printf("ugenpoll: no edesc\n");
		return (POLLERR);
	}
	if (!sce->pipeh) {
		printf("ugenpoll: no pipe\n");
		return (POLLERR);
	}
#endif
	s = splusb();
	switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
	case UE_INTERRUPT:
		if (events & (POLLIN | POLLRDNORM)) {
			if (sce->q.c_cc > 0)
				revents |= events & (POLLIN | POLLRDNORM);
			else
				selrecord(p, &sce->rsel);
		}
		break;
	case UE_ISOCHRONOUS:
		if (events & (POLLIN | POLLRDNORM)) {
			if (sce->cur != sce->fill)
				revents |= events & (POLLIN | POLLRDNORM);
			else
				selrecord(p, &sce->rsel);
		}
		break;
	case UE_BULK:
		/*
		 * We have no easy way of determining if a read will
		 * yield any data or a write will happen.
		 * Pretend they will.
		 */
		revents |= events &
			   (POLLIN | POLLRDNORM | POLLOUT | POLLWRNORM);
		break;
	default:
		break;
	}
	splx(s);
	return (revents);
}

void filt_ugenrdetach(struct knote *);
int filt_ugenread_intr(struct knote *, long);
int filt_ugenread_isoc(struct knote *, long);
int ugenkqfilter(dev_t, struct knote *);

void
filt_ugenrdetach(struct knote *kn)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;
	int s;

	s = splusb();
	SLIST_REMOVE(&sce->rsel.si_note, kn, knote, kn_selnext);
	splx(s);
}

int
filt_ugenread_intr(struct knote *kn, long hint)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;

	kn->kn_data = sce->q.c_cc;
	return (kn->kn_data > 0);
}

int
filt_ugenread_isoc(struct knote *kn, long hint)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;

	if (sce->cur == sce->fill)
		return (0);

	if (sce->cur < sce->fill)
		kn->kn_data = sce->fill - sce->cur;
	else
		kn->kn_data = (sce->limit - sce->cur) +
		    (sce->fill - sce->ibuf);

	return (1);
}

struct filterops ugenread_intr_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_ugenread_intr };

struct filterops ugenread_isoc_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_ugenread_isoc };

struct filterops ugen_seltrue_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_seltrue };

int
ugenkqfilter(dev_t dev, struct knote *kn)
{
	struct ugen_softc *sc;
	struct ugen_endpoint *sce;
	struct klist *klist;
	int s;

	sc = ugen_cd.cd_devs[UGENUNIT(dev)];

	if (usbd_is_dying(sc->sc_udev))
		return (ENXIO);

	/* XXX always IN */
	sce = &sc->sc_endpoints[UGENENDPOINT(dev)][IN];
	if (sce == NULL)
		return (EINVAL);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sce->rsel.si_note;
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			kn->kn_fop = &ugenread_intr_filtops;
			break;
		case UE_ISOCHRONOUS:
			kn->kn_fop = &ugenread_isoc_filtops;
			break;
		case UE_BULK:
			/* 
			 * We have no easy way of determining if a read will
			 * yield any data or a write will happen.
			 * So, emulate "seltrue".
			 */
			kn->kn_fop = &ugen_seltrue_filtops;
			break;
		default:
			return (EINVAL);
		}
		break;

	case EVFILT_WRITE:
		klist = &sce->rsel.si_note;
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
		case UE_ISOCHRONOUS:
			/* XXX poll doesn't support this */
			return (EINVAL);

		case UE_BULK:
			/*
			 * We have no easy way of determining if a read will
			 * yield any data or a write will happen.
			 * So, emulate "seltrue".
			 */
			kn->kn_fop = &ugen_seltrue_filtops;
			break;
		default:
			return (EINVAL);
		}
		break;

	default:
		return (EINVAL);
	}

	kn->kn_hook = (void *)sce;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
}
@


1.95
log
@A pile of sizes to free(9).  In test for a few days in snapshots.
Errors will result in nice clean panic messages so we know what's wrong.
Reviewed by dhill visa natano jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.94 2016/05/24 05:35:01 mpi Exp $ */
d1170 4
a1173 1
			ptr = malloc(len, M_TEMP, M_WAITOK);
@


1.94
log
@Kill unused ioctl(2)s.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.93 2016/03/17 21:36:48 krw Exp $ */
d81 1
d317 2
a318 1
			sce->ibuf = malloc(isize, M_USBDEV, M_WAITOK);
d328 1
a328 1
				free(sce->ibuf, M_USBDEV, 0);
d346 1
d356 1
a356 1
				free(sce->ibuf, M_USBDEV, 0);
d461 1
a461 1
			free(sce->ibuf, M_USBDEV, 0);
d1139 1
a1139 1
		size_t len = UGETW(ur->ucr_request.wLength);
d1142 1
a1142 1
		void *ptr = 0;
d1185 4
a1188 3
		if (len > ur->ucr_actlen)
			len = ur->ucr_actlen;
		if (len != 0) {
d1190 1
a1190 1
				error = uiomove(ptr, len, &uio);
d1197 1
a1197 1
			free(ptr, M_TEMP, 0);
@


1.93
log
@'miliseconds' -> 'milliseconds' in comments.

if_atu.c noted by Michal Mazurek.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.92 2016/03/03 18:13:24 stefan Exp $ */
a955 1
	struct usb_string_desc *si;
a1131 10
	}
	case USB_GET_STRING_DESC:
	{
		int len;
		si = (struct usb_string_desc *)addr;
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index,
			si->usd_language_id, &si->usd_desc, &len);
		if (err)
			return (EINVAL);
		break;
@


1.92
log
@Convert uiomovei to uiomove. Fixes a few integer truncations along the
way.

ok natano@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.91 2015/10/19 14:05:01 mpi Exp $ */
d68 1
a68 1
#define UGEN_NISORFRMS	4	/* number of frames (miliseconds) per req */
@


1.91
log
@Revert transfer submission to r1.85.  Seems to make okan@@'s scanner
work properly.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.90 2015/10/13 20:57:46 mpi Exp $ */
d471 2
a472 1
	u_int32_t n, tn;
d527 1
a527 1
			n = min(sce->q.c_cc, uio->uio_resid);
d533 1
a533 1
			DPRINTFN(5, ("ugenread: got %d chars\n", n));
d536 1
a536 1
			error = uiomovei(buffer, n, uio);
d550 2
a551 2
		while ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {
			DPRINTFN(1, ("ugenread: start transfer %d bytes\n",n));
d566 2
a567 2
			DPRINTFN(1, ("ugenread: got %d bytes\n", tn));
			error = uiomovei(buf, tn, uio);
d598 1
a598 1
				n = min(sce->fill - sce->cur, uio->uio_resid);
d600 1
a600 1
				n = min(sce->limit - sce->cur, uio->uio_resid);
d602 1
a602 1
			DPRINTFN(5, ("ugenread: isoc got %d chars\n", n));
d605 1
a605 1
			error = uiomovei(sce->cur, n, uio);
d642 1
a642 1
	u_int32_t n;
d675 2
a676 2
		while ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {
			error = uiomovei(buf, n, uio);
d679 1
a679 1
			DPRINTFN(1, ("ugenwrite: transfer %d bytes\n", n));
d700 1
a700 1
		while ((n = min(UGETW(sce->edesc->wMaxPacketSize),
d702 1
a702 1
			error = uiomovei(buf, n, uio);
d705 1
a705 1
			DPRINTFN(1, ("ugenwrite: transfer %d bytes\n", n));
d1110 1
a1110 1
		int len;
d1130 1
a1130 1
		error = uiomovei((void *)cdesc, len, &uio);
d1147 1
a1147 1
		int len = UGETW(ur->ucr_request.wLength);
d1164 1
a1164 1
		if (len < 0 || len > 32767)
d1180 1
a1180 1
				error = uiomovei(ptr, len, &uio);
d1197 1
a1197 1
				error = uiomovei(ptr, len, &uio);
@


1.90
log
@Prevent a NULL-pointer dereference when closing a ugen(4) node
in case the kernel failed to change the interface of a device.

Found the hardway by okan
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.89 2015/09/15 13:37:44 dcoppa Exp $ */
d472 1
a472 1
	void *buf = 0;
d544 1
a544 1
		flags = USBD_SYNCHRONOUS | USBD_NO_COPY;
d549 1
a549 6
		if ((n = uio->uio_resid) != 0) {
			buf = usbd_alloc_buffer(xfer, n);
			if (buf == NULL) {
				error = ENOMEM;
				goto end;
			}
d551 1
a551 1
			usbd_setup_xfer(xfer, sce->pipeh, 0, NULL, n,
d555 1
a555 3
				if (err == USBD_STALLED)
					usbd_clear_endpoint_stall(sce->pipeh);

d562 1
a562 1
				goto end;
d567 2
a569 1
	end:
a643 1
	void *ptr = NULL;
d674 2
a675 7
		if ((n = uio->uio_resid) != 0) {
			ptr = usbd_alloc_buffer(xfer, n);
			if (ptr == NULL) {
				error = ENOMEM;
				goto done;
			}
			error = uiomovei(ptr, n, uio);
d677 1
a677 2
				goto done;
			flags |= USBD_NO_COPY;
d679 1
a679 1
			usbd_setup_xfer(xfer, sce->pipeh, 0, NULL, n,
d683 1
a683 3
				if (err == USBD_STALLED)
					usbd_clear_endpoint_stall(sce->pipeh);

d690 1
a692 1
	done:
@


1.89
log
@
Fix kpanic I found the hard way while using pcsc-lite

From Grant Czajkowski <czajkow2 AT illinois DOT edu>
OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.88 2015/09/07 19:58:42 mpi Exp $ */
d928 1
a928 1
	/* change setting */
a929 2
	if (err)
		return (err);
@


1.88
log
@Do not set USBD_NO_COPY for interrupt transfers, only bulk transfers
are converted for the moment.

From Grant Czajkowski.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.87 2015/09/04 08:59:43 mpi Exp $ */
d560 3
a562 1
				usbd_clear_endpoint_stall(sce->pipeh);
d696 3
a698 1
				usbd_clear_endpoint_stall(sce->pipeh);
@


1.87
log
@Do not use an intermediary buffer on the stack of the caller when
submitting a bulk write request.

This also means big bulk write requests are no longer split into
multiple small transfers something that libusb consumers do not
expect.

From Grant Czajkowski <czajkow2 AT illinois DOT edu> as part of the
GSoC 2015.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.86 2015/09/03 07:50:22 mpi Exp $ */
d670 1
a670 1
	flags = USBD_SYNCHRONOUS | USBD_NO_COPY;
d688 1
@


1.86
log
@Do not use an intermediary buffer on the stack of the caller when
submitting a read request.

This also means big read requests are no longer split into multiple
small transfers something that libusb consumers do not expect.

Tested by ajacatoutot@@.

Found by Grant Czajkowski <czajkow2 AT illinois DOT edu> during the
GSoC 2015.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.85 2015/07/10 15:45:57 mpi Exp $ */
d648 1
d670 1
a670 1
	flags = USBD_SYNCHRONOUS;
d679 7
a685 2
		while ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {
			error = uiomovei(buf, n, uio);
d687 1
a687 1
				break;
d689 1
a689 1
			usbd_setup_xfer(xfer, sce->pipeh, 0, buf, n,
a699 1
				break;
d702 1
@


1.85
log
@Do not use usbd_endpoint_count() and usbd_interface_count(), theses
functions are almost unused and create confusion.  Do like the rest
of the drivers and simply get an interface or device descriptor.

Tested by ajacoutot@@ and Grant Czajkowski, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.84 2015/06/15 15:45:28 mpi Exp $ */
d472 1
a472 1
	char buf[UGEN_BBSIZE];
d544 1
a544 1
		flags = USBD_SYNCHRONOUS;
d549 6
a554 1
		while ((n = min(UGEN_BBSIZE, uio->uio_resid)) != 0) {
d556 1
a556 1
			usbd_setup_xfer(xfer, sce->pipeh, 0, buf, n,
d567 1
a567 1
				break;
a571 2
			if (error || tn < n)
				break;
d573 1
@


1.84
log
@Set the length of isochronous transfers as the sum of the frames lengths.

This reduces differences between non-isoch and isoch transfers submissions,
makes the generic DMA buffer overrun check work with isoch transfers and
will allow some code simplifications in HC drivers.

Since short-transfers were never checked for isoch transfers, we now need to
pass the USBD_SHORT_XFER_OK flag to not change this behavior.  This might be
revisited later.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.83 2015/05/25 11:52:15 mpi Exp $ */
d185 1
a188 1
	u_int8_t niface, nendpt;
d190 1
a190 2
	int err;
	int dir;
d209 1
a209 1
	if (!cdesc || cdesc->bConfigurationValue != configno) {
a220 3
	err = usbd_interface_count(dev, &niface);
	if (err)
		return (err);
d222 1
a222 1
	for (ifaceno = 0; ifaceno < niface; ifaceno++) {
d232 2
a233 4
		err = usbd_endpoint_count(iface, &nendpt);
		if (err)
			return (err);
		for (endptno = 0; endptno < nendpt; endptno++) {
d885 2
a887 1
	int err;
d889 2
a890 2
	u_int8_t niface, nendpt, endptno, endpt;
	int dir;
d894 2
a895 4
	err = usbd_interface_count(sc->sc_udev, &niface);
	if (err)
		return (err);
	if (ifaceidx < 0 || ifaceidx >= niface ||
d902 2
a903 4
	err = usbd_endpoint_count(iface, &nendpt);
	if (err)
		return (err);
	for (endptno = 0; endptno < nendpt; endptno++) {
d916 1
a916 5
		goto out;

	err = usbd_endpoint_count(iface, &nendpt);
	if (err)
		goto out;
d918 2
a919 2
out:
	for (endptno = 0; endptno < nendpt; endptno++) {
@


1.83
log
@Prevent a use after free in by closing all open endpoints upon detach.

Fix a panic reported by landry@@ with Android's ADB.

Tested and ok ajacoutot@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.82 2015/03/14 03:38:50 jsg Exp $ */
d377 4
a380 5
				usbd_setup_isoc_xfer
					(xfer, sce->pipeh, &sce->isoreqs[i],
					 sce->isoreqs[i].sizes,
					 UGEN_NISORFRMS, USBD_NO_COPY,
					 ugen_isoc_rintr);
d876 1
a876 1
			     USBD_NO_COPY, ugen_isoc_rintr);
@


1.82
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.81 2015/02/10 21:56:09 miod Exp $ */
d110 3
a112 2
int ugen_do_ioctl(struct ugen_softc *, int, u_long,
			 caddr_t, int, struct proc *);
d402 1
d404 1
a404 4
	struct ugen_softc *sc;
	struct ugen_endpoint *sce;
	int dir;
	int i;
d406 2
a407 1
	sc = ugen_cd.cd_devs[UGENUNIT(dev)];
d412 14
a447 1
		usbd_abort_pipe(sce->pipeh);
d755 2
a756 3
	int i, dir;
	int s;
	int maj, mn;
d788 4
d958 2
a959 2
ugen_do_ioctl(struct ugen_softc *sc, int endpt, u_long cmd,
	      caddr_t addr, int flag, struct proc *p)
@


1.81
log
@First step towards making uiomove() take a size_t size argument:
- rename uiomove() to uiomovei() and update all its users.
- introduce uiomove(), which is similar to uiomovei() but with a size_t.
- rewrite uiomovei() as an uiomove() wrapper.
ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.80 2015/01/11 03:07:44 deraadt Exp $ */
a51 1
#include <dev/usb/usbdevs.h>
@


1.80
log
@use mallocarray()
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.79 2014/07/12 20:26:33 mpi Exp $ */
d530 1
a530 1
			error = uiomove(buffer, n, uio);
d561 1
a561 1
			error = uiomove(buf, tn, uio);
d599 1
a599 1
			error = uiomove(sce->cur, n, uio);
d670 1
a670 1
			error = uiomove(buf, n, uio);
d696 1
a696 1
			error = uiomove(buf, n, uio);
d1130 1
a1130 1
		error = uiomove((void *)cdesc, len, &uio);
d1180 1
a1180 1
				error = uiomove(ptr, len, &uio);
d1197 1
a1197 1
				error = uiomove(ptr, len, &uio);
@


1.79
log
@tedu another bunch of DVACT_DEACTIVATE handlers that do nothing but set
the 'dying' flag.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.78 2014/07/12 18:48:52 tedu Exp $ */
d350 1
a350 1
			sce->ibuf = malloc(isize * UGEN_NISOFRAMES,
@


1.78
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.77 2014/07/11 08:45:29 mpi Exp $ */
a123 1
int ugen_activate(struct device *, int);
d130 1
a130 2
	sizeof(struct ugen_softc), ugen_match, ugen_attach, ugen_detach,
	ugen_activate,
a735 13
}

int
ugen_activate(struct device *self, int act)
{
	struct ugen_softc *sc = (struct ugen_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.77
log
@Fix debug printf formating and kill some trailing whitespaces while here.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.76 2013/11/19 14:04:07 pirofti Exp $ */
d334 1
a334 1
				free(sce->ibuf, M_USBDEV);
d361 1
a361 1
				free(sce->ibuf, M_USBDEV);
d455 1
a455 1
			free(sce->ibuf, M_USBDEV);
d1067 1
a1067 1
			free(cdesc, M_TEMP);
d1072 1
a1072 1
		free(cdesc, M_TEMP);
d1084 1
a1084 1
		free(cdesc, M_TEMP);
d1098 1
a1098 1
			free(cdesc, M_TEMP);
d1102 1
a1102 1
		free(cdesc, M_TEMP);
d1117 1
a1117 1
			free(cdesc, M_TEMP);
d1121 1
a1121 1
		free(cdesc, M_TEMP);
d1146 1
a1146 1
		free(cdesc, M_TEMP);
d1219 1
a1219 1
			free(ptr, M_TEMP);
@


1.76
log
@Kill matchlvl usage throughout the usb stack.

Allows us to move forward on cleaning.

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.75 2013/11/06 16:58:13 pirofti Exp $ */
d121 12
a132 15
int ugen_match(struct device *, void *, void *); 
void ugen_attach(struct device *, struct device *, void *); 
int ugen_detach(struct device *, int); 
int ugen_activate(struct device *, int); 

struct cfdriver ugen_cd = { 
	NULL, "ugen", DV_DULL 
}; 

const struct cfattach ugen_ca = { 
	sizeof(struct ugen_softc), 
	ugen_match, 
	ugen_attach, 
	ugen_detach, 
	ugen_activate, 
d844 2
a845 2
	DPRINTFN(5,("ugen_isoc_rintr: xfer %d, count=%d\n", req - sce->isoreqs,
		    count));
d852 1
a852 2
		DPRINTFN(5, ("ugen_isoc_rintr: throwing away %d bytes\n",
			     count));
@


1.75
log
@Replace sc_dying in favour of usbd_is_dying() and usbd_deactivate().

Okay mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.74 2013/11/02 01:41:17 jeremy Exp $ */
a142 4
#if 0
	if (uaa->matchlvl)
		return (uaa->matchlvl);
#endif
@


1.74
log
@Begin conversion of USB stack to return int instead of usbd_status,
starting with usbd_endpoint_count and usbd_interface_count.  usbd_status
should only be used to indicate the status of a USB transfer, it should
not be used for generic error codes.

Idea from and much hand-holding by mpi@@

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.73 2013/09/20 15:34:50 mpi Exp $ */
a103 1
	u_char sc_dying;
d173 1
a173 1
			sc->sc_dying = 1;
d184 1
a184 1
		sc->sc_dying = 1;
d288 1
a288 1
	if (sc == NULL || sc->sc_dying)
d485 1
a485 1
	if (sc->sc_dying)
d517 1
a517 1
			if (sc->sc_dying)
d589 1
a589 1
			if (sc->sc_dying)
d653 1
a653 1
	if (sc->sc_dying)
d754 1
a754 1
		sc->sc_dying = 1;
d983 1
a983 1
	if (sc->sc_dying)
d1266 1
a1266 1
	if (sc->sc_dying)
d1378 1
a1378 1
	if (sc->sc_dying)
@


1.73
log
@Unify and document usbd_transfer(9).

Get rid of the badly named usbd_bulk_transfer() and usbd_intr_transfer()
they were two identical wrappers to submit a synchronous transfer.

Now all synchronous transfers are submited using usbd_setup_xfer(9) and
usbd_transfer(9) explicitly using the USBD_CATCH flag when signals must
be checked.

Previous version ok'd by mglocker@@, with subtle inputs from miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.72 2013/05/17 09:09:11 mpi Exp $ */
d115 1
a115 1
usbd_status ugen_set_interface(struct ugen_softc *, int, int);
d200 1
a200 1
	usbd_status err;
d263 1
a263 1
	return (USBD_NORMAL_COMPLETION);
d897 1
a897 1
usbd_status
d902 1
a902 1
	usbd_status err;
d971 1
a971 1
	usbd_status err;
@


1.72
log
@Don't leak information to userland in case the actual transfer length is
smaller than the requested one. From ws@@NetBSD via miod@@.

This problem can only occur when the USBD_SHORT_XFER_OK flag is set,
otherwise completed transfers with a length smaller than the one
submitted are treated as errors.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.71 2013/04/15 09:23:02 mglocker Exp $ */
d481 1
a481 1
	int error = 0;
d549 5
d556 3
a558 6
			tn = n;
			err = usbd_bulk_transfer(
				  xfer, sce->pipeh,
				  sce->state & UGEN_SHORT_OK ?
				      USBD_SHORT_XFER_OK : 0,
				  sce->timeout, buf, &tn, "ugenrb");
d560 1
d569 1
d647 1
a647 1
	int error = 0;
d670 3
d684 3
a686 2
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0,
				  sce->timeout, buf, &n,"ugenwb");
d688 1
d710 3
a712 2
			err = usbd_intr_transfer(xfer, sce->pipeh, 0,
			    sce->timeout, buf, &n, "ugenwi");
d714 1
@


1.71
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.70 2013/04/01 19:49:53 mglocker Exp $ */
d1205 3
@


1.70
log
@Make ugen_get_cdesc() a generic function by renaming it to usbd_get_cdesc()
and move it to usb_subr.c.

OK mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.69 2013/03/28 03:58:03 tedu Exp $ */
d74 1
a74 1
	usbd_interface_handle iface;
d78 1
a78 1
	usbd_pipe_handle pipeh;
d88 1
a88 1
		usbd_xfer_handle xfer;
d96 1
a96 1
	usbd_device_handle sc_udev;
d108 2
a109 4
void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr,
		     usbd_status status);
void ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
			    usbd_status status);
d159 1
a159 1
	usbd_device_handle udev;
d193 1
a193 1
	usbd_device_handle dev = sc->sc_udev;
d195 1
a195 1
	usbd_interface_handle iface;
d276 1
a276 1
	usbd_xfer_handle xfer;
d478 1
a478 1
	usbd_xfer_handle xfer;
d645 1
a645 1
	usbd_xfer_handle xfer;
d793 1
a793 1
ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d829 1
a829 2
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
		usbd_status status)
d889 1
a889 1
	usbd_interface_handle iface;
d946 1
a946 1
	usbd_interface_handle iface;
d961 1
a961 1
	usbd_interface_handle iface;
@


1.69
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.68 2011/12/07 06:23:18 mglocker Exp $ */
a116 2
usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc,
					       int index, int *lenp);
a945 35
/* Retrieve a complete descriptor for a certain device and index. */
usb_config_descriptor_t *
ugen_get_cdesc(struct ugen_softc *sc, int index, int *lenp)
{
	usb_config_descriptor_t *cdesc, *tdesc, cdescr;
	int len;
	usbd_status err;

	if (index == USB_CURRENT_CONFIG_INDEX) {
		tdesc = usbd_get_config_descriptor(sc->sc_udev);
		len = UGETW(tdesc->wTotalLength);
		if (lenp)
			*lenp = len;
		cdesc = malloc(len, M_TEMP, M_WAITOK);
		memcpy(cdesc, tdesc, len);
		DPRINTFN(5,("ugen_get_cdesc: current, len=%d\n", len));
	} else {
		err = usbd_get_config_desc(sc->sc_udev, index, &cdescr);
		if (err)
			return (0);
		len = UGETW(cdescr.wTotalLength);
		DPRINTFN(5,("ugen_get_cdesc: index=%d, len=%d\n", index, len));
		if (lenp)
			*lenp = len;
		cdesc = malloc(len, M_TEMP, M_WAITOK);
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,
						len);
		if (err) {
			free(cdesc, M_TEMP);
			return (0);
		}
	}
	return (cdesc);
}

d1063 1
a1063 1
		cdesc = ugen_get_cdesc(sc, ai->uai_config_index, 0);
d1081 1
a1081 1
		cdesc = ugen_get_cdesc(sc, cd->ucd_config_index, 0);
d1089 1
a1089 1
		cdesc = ugen_get_cdesc(sc, id->uid_config_index, 0);
d1107 1
a1107 1
		cdesc = ugen_get_cdesc(sc, ed->ued_config_index, 0);
d1132 1
a1132 1
		cdesc = ugen_get_cdesc(sc, fd->ufd_config_index, &len);
@


1.68
log
@Avoid kernel crash by removing double clfree() on endpoint closing for
ugen(4) devices.

From NetBSD PR#37934 spotted by Logan Aden.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.67 2011/10/14 12:50:44 mpi Exp $ */
a45 1
#include <sys/proc.h>
@


1.67
log
@Return EINVAL when there's no config descriptor for a given index.

Problem reported by ajacoutot@@

ok deraadt@@, kettenis@@,  krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.66 2011/07/03 15:47:17 matthew Exp $ */
a469 1
			clfree(&sce->q);
@


1.66
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.65 2011/07/02 22:20:08 nicm Exp $ */
d1172 2
@


1.65
log
@kqueue attach functions should return an errno or 0, not a plain 1. Fix
the obvious cases to return EINVAL and ENXIO.

ok tedu deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.64 2011/01/25 20:03:36 jakemsr Exp $ */
a748 3
	case DVACT_ACTIVATE:
		break;

@


1.64
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.63 2011/01/16 22:35:29 jakemsr Exp $ */
d1409 1
a1409 1
		return (1);
d1414 1
a1414 1
		return (1);
d1435 1
a1435 1
			return (1);
d1445 1
a1445 1
			return (1);
d1456 1
a1456 1
			return (1);
d1461 1
a1461 1
		return (1);
@


1.63
log
@* instead of NULLing pointers to interface descriptors in the uaa, mark
  interfaces as being claimed in the usbd_device's copy of the interface
  descriptors
* allow ugen(4) to be attached if there are unused interfaces in a
  configuration that has had drivers attached
* make ugen(4) aware that it may be sharing a device with (an)other
  driver(s), and if so:
  * do not let ugen(4) change the configuration
  * do not let ugen(4) access the already claimed interfaces

discussed with deraadt and miod
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.62 2010/09/24 08:33:59 yuo Exp $ */
a192 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   &sc->sc_dev);
a796 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.62
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.61 2009/11/09 17:53:39 nicm Exp $ */
d106 1
d170 12
a181 7
	/* First set configuration index 0, the default one for ugen. */
	err = usbd_set_config_index(udev, 0, 0);
	if (err) {
		printf("%s: setting configuration index 0 failed\n",
		       sc->sc_dev.dv_xname);
		sc->sc_dying = 1;
		return;
d229 9
a237 3
		err = usbd_set_config_no(dev, configno, 1);
		if (err)
			return (err);
d246 5
d917 2
a918 1
	if (ifaceidx < 0 || ifaceidx >= niface)
@


1.61
log
@Every selwakeup() should have a matching KNOTE() (even if kqueue isn't
supported it doesn't do any harm), so put the KNOTE() in selwakeup() itself and
remove it from any occurences where both are used, except one for kqueue itself
and one in sys_pipe.c (where the selwakeup is under a PIPE_SEL flag).

Based on a diff from tedu.

ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.60 2009/10/31 06:40:17 deraadt Exp $ */
a755 1
	sc->sc_dying = 1;
@


1.60
log
@Add missing KNOTE() calls after selwakeup(), until we decide if the KNOTE()
calls can go directly into selwakeup() safely
long discussion with nicm, murmers of consent from tedu and miod, noone
else seems to care of kqueue is busted as long as it makes their sockets
move data fast... pretty sad.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.59 2009/10/13 19:33:17 pirofti Exp $ */
a824 1
	KNOTE(&sce->rsel.si_note, 0);
a883 1
	KNOTE(&sce->rsel.si_note, 0);
@


1.59
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.58 2009/07/19 08:16:06 blambert Exp $ */
d825 1
d885 1
@


1.58
log
@clalloc() can't fail, so there's no need to handle failure cases.
Change to void function.
Also, no need to have global tty stats pointer, so just return it
from clalloc, as the caller frees it immediately anyway.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.57 2009/06/05 20:18:03 yuo Exp $ */
d129 1
a129 1
int ugen_activate(struct device *, enum devact); 
d730 1
a730 1
ugen_activate(struct device *self, enum devact act)
@


1.57
log
@catch up NetBSD kern/41048.

check for a non-NULL configuration descriptor before dereferencing.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.56 2008/12/14 16:48:04 fgsch Exp $ */
d326 1
a326 2
			if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
				return (ENOMEM);
@


1.56
log
@o Correctly clear UGEN_ASLP in all cases.
o Use the timeout for isochronous transfers as well
o Allow to set the timeout for both, read and write

From FreeBSD. you@@ ok some time ago.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.55 2008/09/08 19:35:25 martynas Exp $ */
d196 1
d221 2
a222 1
	if (usbd_get_config_descriptor(dev)->bConfigurationValue != configno) {
@


1.55
log
@- don't leave nodes unconfigured, when setting alternate setting
fails.  fixes my ups
looked over by fgs@@.  ok sthen@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.54 2008/06/26 05:42:18 ray Exp $ */
d507 1
d515 1
a515 2
			if (error) {
				sce->state &= ~UGEN_ASLP;
a516 1
			}
d573 3
a575 1
			error = tsleep(sce, PZERO | PCATCH, "ugenri", 0);
d579 2
a580 2
			if (error) {
				sce->state &= ~UGEN_ASLP;
d583 2
d1027 5
a1031 5
		if (sce == NULL
		    /* XXX this shouldn't happen, but the distinction between
		       input and output pipes isn't clear enough.
		       || sce->pipeh == NULL */
			)
@


1.54
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.53 2008/06/14 02:40:23 todd Exp $ */
a905 1
	/* XXX should only do this after setting new altno has succeeded */
d919 1
a919 1
		return (err);
d923 3
a925 1
		return (err);
d935 1
a935 1
	return (0);
@


1.53
log
@remove #ifdef __macppc__ due to a misunderstanding:
 - the wskbd/wsmouse is not phantom, but actually is pre-paired keyboard/mice
   talking wskbd/wsmouse to the os
this permits the bluetooth device to attach as wskbd/wsmouse using bluetooth
 keyboards for ddb> and in general if you have paired them in an os that
 supports flipping the funny bluetooth device into full bluetooth mode
ok drahn@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.52 2007/10/20 22:44:01 fgsch Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.52
log
@Remove unneeded scope declarations that shadows existing ones. krw@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.51 2007/10/11 18:33:15 deraadt Exp $ */
a159 11
#ifdef __macppc__
		/*
		 * Some Apple laptops have USB phantom devices which match
		 * the ADB devices.  We want to ignore them to avoid
		 * confusing users, as the real hardware underneath is adb
		 * and has already attached.
		 */
		if (uaa->vendor == USB_VENDOR_APPLE &&
		    uaa->product == USB_PRODUCT_APPLE_ADB)
			return (UMATCH_NONE);
#endif
@


1.51
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.50 2007/06/29 13:31:42 henning Exp $ */
a1208 1
		usbd_status err;
@


1.50
log
@respect timeouts. prompted by freebsd pr110122, but also proplerly
calculate the timeout. help & ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.49 2007/06/14 10:11:15 mbalmer Exp $ */
a181 1
	char *devinfop;
a183 4

	devinfop = usbd_devinfo_alloc(uaa->device, 0);
	printf("\n%s: %s\n", sc->sc_dev.dv_xname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.49
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.48 2007/06/12 16:26:36 mbalmer Exp $ */
d528 2
a529 1
			error = tsleep(sce, PZERO | PCATCH, "ugenri", 0);
d533 4
@


1.48
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.47 2007/06/11 16:30:31 mbalmer Exp $ */
d133 16
a148 1
USB_DECLARE_DRIVER(ugen);
@


1.47
log
@Remove the usb_proc_ptr type definition, which was really a 'struct proc *'
only.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.46 2007/06/11 12:36:52 mbalmer Exp $ */
d729 1
a729 1
ugen_activate(device_ptr_t self, enum devact act)
@


1.46
log
@Remove the USB_GET_SC_OPEN macro.  There is a double check for sc == NULL in
ulpt.c, I am aware of that and it will be changed later.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.45 2007/06/11 10:58:21 mbalmer Exp $ */
d122 1
a122 1
			 caddr_t, int, usb_proc_ptr);
d264 1
a264 1
ugenopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d408 1
a408 1
ugenclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d989 1
a989 1
	      caddr_t addr, int flag, usb_proc_ptr p)
d1259 1
a1259 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d1275 1
a1275 1
ugenpoll(dev_t dev, int events, usb_proc_ptr p)
@


1.45
log
@Remove the definition and use of the USB_GET_SC macro, no binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.44 2007/06/11 09:26:55 mk Exp $ */
d277 5
a281 1
	USB_GET_SC_OPEN(ugen, unit, sc);
@


1.44
log
@More USB cleanup:  In usb_port.h, get rid of the sel_klist #define
(which was there twice without gcc complaining) and update all uses of
it.

ok jsg mbalmer
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.43 2007/06/10 14:49:01 mbalmer Exp $ */
d412 1
a412 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d616 1
a616 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d715 1
a715 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d1261 1
a1261 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d1278 1
a1278 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d1390 1
a1390 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
@


1.43
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.42 2007/06/10 10:53:48 mbalmer Exp $ */
d1343 1
a1343 1
	SLIST_REMOVE(&sce->rsel.sel_klist, kn, knote, kn_selnext);
d1402 1
a1402 1
		klist = &sce->rsel.sel_klist;
d1424 1
a1424 1
		klist = &sce->rsel.sel_klist;
@


1.42
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.41 2007/06/06 19:25:49 mk Exp $ */
d172 1
a172 1
	printf("\n%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d181 1
a181 1
		       USBDEVNAME(sc->sc_dev));
d191 1
a191 1
		       USBDEVNAME(sc->sc_dev), conf);
d213 1
a213 1
		    USBDEVNAME(sc->sc_dev), configno, sc));
d223 1
a223 1
			      USBDEVNAME(sc->sc_dev), endptno));
d479 1
a479 1
	DPRINTFN(5, ("%s: ugenread: %d\n", USBDEVNAME(sc->sc_dev), endpt));
d635 1
a635 1
	DPRINTFN(5, ("%s: ugenwrite: %d\n", USBDEVNAME(sc->sc_dev), endpt));
@


1.41
log
@Mechanical removal of USBBASEDEVICE.  No binary change.

Tested by thib and myself.

ok mbalmer jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.40 2007/06/05 08:43:55 mbalmer Exp $ */
d197 1
a197 1
			   USBDEV(sc->sc_dev));
d621 1
a621 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d720 1
a720 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d767 1
a767 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d781 1
a781 1
			   USBDEV(sc->sc_dev));
d1266 1
a1266 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.40
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.39 2007/05/31 17:35:45 mbalmer Exp $ */
d103 1
a103 1
	USBBASEDEVICE sc_dev;		/* base device */
@


1.39
log
@Remove some #ifdef {Free|Net}BSD/#endif to make the code more readable.

ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.38 2007/05/27 04:00:25 jsg Exp $ */
d115 1
a115 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d117 1
a117 1
Static void ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d119 3
a121 3
Static int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
Static int ugen_do_write(struct ugen_softc *, int, struct uio *, int);
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long,
d123 2
a124 2
Static int ugen_set_config(struct ugen_softc *sc, int configno);
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc,
d126 2
a127 2
Static usbd_status ugen_set_interface(struct ugen_softc *, int, int);
Static int ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx);
d200 1
a200 1
Static int
d467 1
a467 1
Static int
d625 1
a625 1
Static int
d786 1
a786 1
Static void
d822 1
a822 1
Static void
d881 1
a881 1
Static usbd_status
d937 1
a937 1
Static usb_config_descriptor_t *
d971 1
a971 1
Static int
d983 1
a983 1
Static int
d1331 3
a1333 3
Static void filt_ugenrdetach(struct knote *);
Static int filt_ugenread_intr(struct knote *, long);
Static int filt_ugenread_isoc(struct knote *, long);
d1336 1
a1336 1
Static void
d1347 1
a1347 1
Static int
d1356 1
a1356 1
Static int
d1373 1
a1373 1
Static struct filterops ugenread_intr_filtops =
d1376 1
a1376 1
Static struct filterops ugenread_isoc_filtops =
d1379 1
a1379 1
Static struct filterops ugen_seltrue_filtops =
@


1.38
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.37 2007/05/21 05:40:28 jsg Exp $ */
a46 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a48 8
#elif defined(__FreeBSD__)
#include <sys/module.h>
#include <sys/bus.h>
#include <sys/ioccom.h>
#include <sys/conf.h>
#include <sys/fcntl.h>
#include <sys/filio.h>
#endif
a114 41
#if defined(__NetBSD__)
dev_type_open(ugenopen);
dev_type_close(ugenclose);
dev_type_read(ugenread);
dev_type_write(ugenwrite);
dev_type_ioctl(ugenioctl);
dev_type_poll(ugenpoll);
dev_type_kqfilter(ugenkqfilter);

const struct cdevsw ugen_cdevsw = {
	ugenopen, ugenclose, ugenread, ugenwrite, ugenioctl,
	nostop, notty, ugenpoll, nommap, ugenkqfilter,
};
#elif defined(__FreeBSD__)
d_open_t  ugenopen;
d_close_t ugenclose;
d_read_t  ugenread;
d_write_t ugenwrite;
d_ioctl_t ugenioctl;
d_poll_t  ugenpoll;

#define UGEN_CDEV_MAJOR	114

Static struct cdevsw ugen_cdevsw = {
	/* open */	ugenopen,
	/* close */	ugenclose,
	/* read */	ugenread,
	/* write */	ugenwrite,
	/* ioctl */	ugenioctl,
	/* poll */	ugenpoll,
	/* mmap */	nommap,
	/* strategy */	nostrategy,
	/* name */	"ugen",
	/* maj */	UGEN_CDEV_MAJOR,
	/* dump */	nodump,
	/* psize */	nopsize,
	/* flags */	0,
	/* bmaj */	-1
};
#endif

a195 10
#ifdef __FreeBSD__
	{
		static int global_init_done = 0;
		if (!global_init_done) {
			cdevsw_add(&ugen_cdevsw);
			global_init_done = 1;
		}
	}
#endif

a723 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a738 1
#endif
a746 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a749 3
#elif defined(__FreeBSD__)
	DPRINTF(("ugen_detach: sc=%p\n", sc));
#endif
a771 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ugen_cdevsw);
#elif defined(__OpenBSD__)
a774 1
#endif
a1455 4

#if defined(__FreeBSD__)
DRIVER_MODULE(ugen, uhub, ugen_driver, ugen_devclass, usbd_driver_load, 0);
#endif
@


1.37
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.36 2006/11/01 03:37:23 tedu Exp $ */
d185 2
a186 1
USB_MATCH(ugen)
d188 1
a188 1
	USB_MATCH_START(ugen, uaa);
d211 2
a212 1
USB_ATTACH(ugen)
d214 2
a215 1
	USB_ATTACH_START(ugen, sc, uaa);
d222 1
a222 2
	USB_ATTACH_SETUP;
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfop);
d233 1
a233 1
		USB_ATTACH_ERROR_RETURN;
d243 1
a243 1
		USB_ATTACH_ERROR_RETURN;
a257 2

	USB_ATTACH_SUCCESS_RETURN;
d802 2
a803 1
USB_DETACH(ugen)
d805 1
a805 1
	USB_DETACH_START(ugen, sc);
@


1.36
log
@poll errors should be POLLERR, not some random E value
from alexandre ratchov.  ok claudio
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.35 2006/06/23 06:27:11 miod Exp $ */
d72 2
a73 2
#define DPRINTF(x)	do { if (ugendebug) logprintf x; } while (0)
#define DPRINTFN(n,x)	do { if (ugendebug>(n)) logprintf x; } while (0)
@


1.35
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.34 2006/06/17 16:27:58 miod Exp $ */
d1350 1
a1350 1
		return (EIO);
d1355 1
a1355 1
		return (EINVAL);
d1359 1
a1359 1
		return (EIO);
d1363 1
a1363 1
		return (EIO);
@


1.34
log
@Recent Powerbook systems have their on-board keyboard and mouse devices
also showing up as usb devices, but both devices are tied.
To make things less confusing, do not attach the usb phantoms at all.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.33 2005/11/21 18:16:43 millert Exp $ */
d792 1
a792 1
		return (EOPNOTSUPP);
@


1.33
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.32 2005/08/01 05:36:48 brad Exp $ */
d69 1
d193 12
a204 1
	if (uaa->usegeneric)
d206 1
a206 1
	else
@


1.32
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.31 2004/10/31 12:10:52 dlg Exp $ */
d61 1
a61 1
#include <sys/select.h>
@


1.31
log
@from netbsd via freebsd via jsg@@

usbdi_util.h (1.29), uhid.c (1.62), ugen.c (1.68), usb_subr.c (1.114)
   Yes, some devices return incorrect lengths in their string
   descriptors.  Rather than losing, do what Windows does: just
   request the maximum size, and allow a shorter response.  Obsoletes
   the need for UQ_NO_STRINGS, and therefore these "quirks" are removed.

usb_subr.c (1.116)
    In the "seemed like a good idea until I found the fatal flaw"
    department...  Attempting to read a maximum-size string descriptor
    causes my kue device to go completely apeshit.  So, go back to the
    original method, but allow the device to return a shorter string than
    it claimed.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.30 2004/07/21 00:01:07 dlg Exp $ */
d202 1
a202 1
	char devinfo[1024];
d206 1
a206 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d208 2
a209 1
	printf("%s: %s\n", USBDEVNAME(sc->sc_dev), devinfo);
@


1.30
log
@from freebsd, ugen.c 1.68 usbdi_util.c 1.27 usbdi_util.h 1.15
log message:
Implement outgoing interrupt pipes. It is part of the USB 1.1 spec.
The Lego Infrared Tower use it.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.29 2004/07/08 22:18:44 deraadt Exp $ */
d1230 2
d1234 1
a1234 1
			  si->usd_language_id, &si->usd_desc);
d1238 1
@


1.29
log
@put "do { } while (0)" wrappers on all the debug maroc functions
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.28 2003/06/27 16:57:14 nate Exp $ */
d362 7
d713 24
@


1.28
log
@kqueue support for various usb devices including: usb, uhid, ugen,
and uscanner
From NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.27 2003/05/07 04:33:33 deraadt Exp $ */
d71 2
a72 2
#define DPRINTF(x)	if (ugendebug) logprintf x
#define DPRINTFN(n,x)	if (ugendebug>(n)) logprintf x
@


1.27
log
@string cleanup; nate ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.26 2002/11/11 02:32:32 nate Exp $ */
/*	$NetBSD: ugen.c,v 1.62 2002/10/23 09:13:59 jdolecek Exp $	*/
d1351 126
@


1.26
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.25 2002/07/25 04:07:32 nate Exp $ */
d206 1
a206 1
	usbd_devinfo(uaa->device, 0, devinfo);
@


1.25
log
@update $NetBSD$ tags
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.24 2002/07/25 02:18:10 nate Exp $ */
/*	$NetBSD: ugen.c,v 1.59 2002/07/11 21:14:28 augustss Exp $	*/
d124 12
a135 1
cdev_decl(ugen);
a748 1
		break;
a791 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d793 3
d799 1
a803 3
#elif defined(__FreeBSD__)
	/* XXX not implemented yet */
#endif
@


1.24
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.23 2002/07/10 21:41:50 mickey Exp $ */
/*	$NetBSD: ugen.c,v 1.58 2002/02/20 20:30:12 christos Exp $	*/
@


1.23
log
@no provate cdev_decl()s, they are in sys/conf.h now
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.22 2002/07/09 17:50:14 nate Exp $ */
d194 1
a194 1
	
d467 1
a467 1
		
d631 1
a631 1
		
d828 1
a828 1
		
d913 1
a913 1
	
d1037 1
a1037 1
		if (sce == NULL 
@


1.22
log
@sync with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.21 2002/07/09 17:41:02 nate Exp $ */
d123 1
a123 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
@


1.21
log
@make the timeout a function parameter
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.20 2002/05/07 18:29:18 nate Exp $ */
/*	$NetBSD: ugen.c,v 1.49 2001/10/24 22:31:04 augustss Exp $	*/
d23 2
a24 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d153 1
a153 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
d159 2
a160 2
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long, 
			 caddr_t, int, struct proc *);
d162 1
a162 1
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc, 
d204 1
a204 1
		printf("%s: setting configuration index 0 failed\n", 
d214 1
a214 1
		printf("%s: setting configuration %d failed\n", 
d250 13
d288 1
a288 1
				    "(%d,%d), sce=%p\n", 
d300 1
a300 1
ugenopen(dev_t dev, int flag, int mode, struct proc *p)
d315 1
a315 1
 	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n", 
d346 1
a346 1
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n", 
d355 1
a355 1
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n", 
d357 6
a362 6
                        if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
                                return (ENOMEM);
			err = usbd_open_pipe_intr(sce->iface, 
				  edesc->bEndpointAddress, 
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce, 
				  sce->ibuf, isize, ugenintr, 
d372 1
a372 1
			err = usbd_open_pipe(sce->iface, 
d387 1
a387 1
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n", 
d424 1
d433 1
a433 1
ugenclose(dev_t dev, int flag, int mode, struct proc *p)
d465 1
a465 1
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n", 
d472 8
a479 8
                switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
                case UE_INTERRUPT:
                        ndflush(&sce->q, sce->q.c_cc);
                        clfree(&sce->q);
                        break;
                case UE_ISOCHRONOUS:
                        for (i = 0; i < UGEN_NISOREQS; ++i)
                                usbd_free_xfer(sce->isoreqs[i].xfer);
d481 2
a482 2
                default:
                        break;
a488 1

d574 2
a575 2
				  sce->state & UGEN_SHORT_OK ? 
				      USBD_SHORT_XFER_OK : 0, 
d693 1
a693 1
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0, 
d814 2
a815 1
		usbd_clear_endpoint_stall_async(sce->pipeh);
d822 1
a822 1
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n", 
d838 1
a838 1
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
d976 2
a977 1
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);
d1000 1
a1000 1
	      caddr_t addr, int flag, struct proc *p)
a1023 1
		/* This flag only affects read */
d1026 1
d1028 1
a1028 1
		if (sce == NULL)
a1029 6
#ifdef DIAGNOSTIC
		if (sce->pipeh == NULL) {
			printf("ugenioctl: USB_SET_SHORT_XFER, no pipe\n");
			return (EIO);
		}
#endif
d1037 5
a1041 1
		if (sce == NULL)
a1042 6
#ifdef DIAGNOSTIC
		if (sce->pipeh == NULL) {
			printf("ugenioctl: USB_SET_TIMEOUT, no pipe\n");
			return (EIO);
		}
#endif
d1068 6
a1073 1
		if (err)
d1075 1
d1079 1
a1079 1
		err = usbd_device2interface_handle(sc->sc_udev, 
d1092 1
a1092 1
		err = usbd_device2interface_handle(sc->sc_udev, 
d1096 2
a1097 1
		err = ugen_set_interface(sc, ai->uai_interface_index, ai->uai_alt_no);
d1111 2
a1112 1
		ai->uai_alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);
d1155 1
a1155 1
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index, 
d1190 1
a1190 1
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index, 
d1227 1
a1227 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d1237 3
a1239 3
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request, 
			  ptr, ur->ucr_flags, &ur->ucr_actlen,
			  USBD_DEFAULT_TIMEOUT);
d1267 1
a1267 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d1283 1
a1283 1
ugenpoll(dev_t dev, int events, struct proc *p)
d1328 1
a1328 1
		/* 
d1333 1
a1333 1
		revents |= events & 
@


1.20
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.18 2002/05/02 20:08:04 nate Exp $ */
d1223 2
a1224 1
			  ptr, ur->ucr_flags, &ur->ucr_actlen);
@


1.19
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: ugen.c,v 1.58 2002/02/20 20:30:12 christos Exp $	*/
d23 2
a24 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d153 1
a153 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d159 2
a160 2
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long,
			 caddr_t, int, usb_proc_ptr);
d162 1
a162 1
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc,
d204 1
a204 1
		printf("%s: setting configuration index 0 failed\n",
d214 1
a214 1
		printf("%s: setting configuration %d failed\n",
a249 13

	/*
	 * We start at 1, not 0, because we don't care whether the
	 * control endpoint is open or not. It is always present.
	 */
	for (endptno = 1; endptno < USB_MAX_ENDPOINTS; endptno++)
		if (sc->sc_is_open[endptno]) {
			DPRINTFN(1,
			     ("ugen_set_config: %s - endpoint %d is open\n",
			      USBDEVNAME(sc->sc_dev), endptno));
			return (USBD_IN_USE);
		}

d275 1
a275 1
				    "(%d,%d), sce=%p\n",
d287 1
a287 1
ugenopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d302 1
a302 1
	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n",
d333 1
a333 1
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n",
d342 1
a342 1
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n",
d344 6
a349 6
			if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
				return (ENOMEM);
			err = usbd_open_pipe_intr(sce->iface,
				  edesc->bEndpointAddress,
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce,
				  sce->ibuf, isize, ugenintr,
d359 1
a359 1
			err = usbd_open_pipe(sce->iface,
d374 1
a374 1
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n",
a410 1
			sce->timeout = USBD_DEFAULT_TIMEOUT;
d419 1
a419 1
ugenclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d451 1
a451 1
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n",
d458 8
a465 8
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			ndflush(&sce->q, sce->q.c_cc);
			clfree(&sce->q);
			break;
		case UE_ISOCHRONOUS:
			for (i = 0; i < UGEN_NISOREQS; ++i)
				usbd_free_xfer(sce->isoreqs[i].xfer);
d467 2
a468 2
		default:
			break;
d475 1
d561 2
a562 2
				  sce->state & UGEN_SHORT_OK ?
				      USBD_SHORT_XFER_OK : 0,
d680 1
a680 1
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0,
d801 1
a801 2
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sce->pipeh);
d808 1
a808 1
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n",
d824 1
a824 1
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d962 1
a962 2
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,
						len);
d985 1
a985 1
	      caddr_t addr, int flag, usb_proc_ptr p)
d1009 1
a1011 1
		/* This flag only affects read */
d1013 1
a1013 1
		if (sce == NULL || sce->pipeh == NULL)
d1015 6
d1028 1
a1028 5
		if (sce == NULL 
		    /* XXX this shouldn't happen, but the distinction between
		       input and output pipes isn't clear enough.
		       || sce->pipeh == NULL */
			)
d1030 6
d1061 1
a1061 6
		switch (err) {
		case USBD_NORMAL_COMPLETION:
			break;
		case USBD_IN_USE:
			return (EBUSY);
		default:
a1062 1
		}
d1066 2
a1067 2
		err = usbd_device2interface_handle(sc->sc_udev,
		          ai->uai_interface_index, &iface);
d1079 2
a1080 2
		err = usbd_device2interface_handle(sc->sc_udev,
		          ai->uai_interface_index, &iface);
d1083 1
a1083 2
		err = ugen_set_interface(sc, ai->uai_interface_index,
		    ai->uai_alt_no);
d1097 1
a1097 2
		ai->uai_alt_no = usbd_get_no_alts(cdesc,
		    idesc->bInterfaceNumber);
d1140 1
a1140 1
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index,
d1175 1
a1175 1
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index,
d1212 1
a1212 1
				ur->ucr_request.bmRequestType & UT_READ ?
d1222 2
a1223 3
		sce = &sc->sc_endpoints[endpt][IN];
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
d1251 1
a1251 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d1267 1
a1267 1
ugenpoll(dev_t dev, int events, usb_proc_ptr p)
d1312 1
a1312 1
		/*
d1317 1
a1317 1
		revents |= events &
@


1.18
log
@prefix structure members to avoid name clashes.
From NetBSD
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.17 2001/10/31 04:24:44 nate Exp $ */
/*	$NetBSD: ugen.c,v 1.49 2001/10/24 22:31:04 augustss Exp $	*/
d23 2
a24 2
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
d153 1
a153 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
d159 2
a160 2
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long, 
			 caddr_t, int, struct proc *);
d162 1
a162 1
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc, 
d204 1
a204 1
		printf("%s: setting configuration index 0 failed\n", 
d214 1
a214 1
		printf("%s: setting configuration %d failed\n", 
d250 13
d288 1
a288 1
				    "(%d,%d), sce=%p\n", 
d300 1
a300 1
ugenopen(dev_t dev, int flag, int mode, struct proc *p)
d315 1
a315 1
 	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n", 
d346 1
a346 1
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n", 
d355 1
a355 1
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n", 
d357 6
a362 6
                        if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
                                return (ENOMEM);
			err = usbd_open_pipe_intr(sce->iface, 
				  edesc->bEndpointAddress, 
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce, 
				  sce->ibuf, isize, ugenintr, 
d372 1
a372 1
			err = usbd_open_pipe(sce->iface, 
d387 1
a387 1
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n", 
d424 1
d433 1
a433 1
ugenclose(dev_t dev, int flag, int mode, struct proc *p)
d465 1
a465 1
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n", 
d472 8
a479 8
                switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
                case UE_INTERRUPT:
                        ndflush(&sce->q, sce->q.c_cc);
                        clfree(&sce->q);
                        break;
                case UE_ISOCHRONOUS:
                        for (i = 0; i < UGEN_NISOREQS; ++i)
                                usbd_free_xfer(sce->isoreqs[i].xfer);
d481 2
a482 2
                default:
                        break;
a488 1

d574 2
a575 2
				  sce->state & UGEN_SHORT_OK ? 
				      USBD_SHORT_XFER_OK : 0, 
d693 1
a693 1
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0, 
d814 2
a815 1
		usbd_clear_endpoint_stall_async(sce->pipeh);
d822 1
a822 1
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n", 
d838 1
a838 1
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
d976 2
a977 1
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);
d1000 1
a1000 1
	      caddr_t addr, int flag, struct proc *p)
a1023 1
		/* This flag only affects read */
d1026 1
d1028 1
a1028 1
		if (sce == NULL)
a1029 6
#ifdef DIAGNOSTIC
		if (sce->pipeh == NULL) {
			printf("ugenioctl: USB_SET_SHORT_XFER, no pipe\n");
			return (EIO);
		}
#endif
d1037 5
a1041 1
		if (sce == NULL)
a1042 6
#ifdef DIAGNOSTIC
		if (sce->pipeh == NULL) {
			printf("ugenioctl: USB_SET_TIMEOUT, no pipe\n");
			return (EIO);
		}
#endif
d1068 6
a1073 1
		if (err)
d1075 1
d1079 2
a1080 2
		err = usbd_device2interface_handle(sc->sc_udev, 
			  ai->uai_interface_index, &iface);
d1092 2
a1093 2
		err = usbd_device2interface_handle(sc->sc_udev, 
			  ai->uai_interface_index, &iface);
d1096 2
a1097 1
		err = ugen_set_interface(sc, ai->uai_interface_index, ai->uai_alt_no);
d1111 2
a1112 1
		ai->uai_alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);
d1155 1
a1155 1
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index, 
d1190 1
a1190 1
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index, 
d1227 1
a1227 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d1237 3
a1239 2
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request, 
			  ptr, ur->ucr_flags, &ur->ucr_actlen);
d1267 1
a1267 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
d1283 1
a1283 1
ugenpoll(dev_t dev, int events, struct proc *p)
d1328 1
a1328 1
		/* 
d1333 1
a1333 1
		revents |= events & 
@


1.17
log
@Synchronize usb code with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.16 2001/09/20 17:02:31 mpech Exp $ */
d1067 1
a1067 1
			  ai->interface_index, &iface);
d1073 1
a1073 1
		ai->alt_no = idesc->bAlternateSetting;
d1080 1
a1080 1
			  ai->interface_index, &iface);
d1083 1
a1083 1
		err = ugen_set_interface(sc, ai->interface_index, ai->alt_no);
d1089 1
a1089 1
		cdesc = ugen_get_cdesc(sc, ai->config_index, 0);
d1092 1
a1092 1
		idesc = usbd_find_idesc(cdesc, ai->interface_index, 0);
d1097 1
a1097 1
		ai->alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);
d1106 1
a1106 1
		cdesc = ugen_get_cdesc(sc, cd->config_index, 0);
d1109 1
a1109 1
		cd->desc = *cdesc;
d1114 1
a1114 1
		cdesc = ugen_get_cdesc(sc, id->config_index, 0);
d1117 3
a1119 3
		if (id->config_index == USB_CURRENT_CONFIG_INDEX &&
		    id->alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, id->interface_index);
d1121 2
a1122 2
			alt = id->alt_index;
		idesc = usbd_find_idesc(cdesc, id->interface_index, alt);
d1127 1
a1127 1
		id->desc = *idesc;
d1132 1
a1132 1
		cdesc = ugen_get_cdesc(sc, ed->config_index, 0);
d1135 3
a1137 3
		if (ed->config_index == USB_CURRENT_CONFIG_INDEX &&
		    ed->alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, ed->interface_index);
d1139 3
a1141 3
			alt = ed->alt_index;
		edesc = usbd_find_edesc(cdesc, ed->interface_index, 
					alt, ed->endpoint_index);
d1146 1
a1146 1
		ed->desc = *edesc;
d1157 4
a1160 4
		cdesc = ugen_get_cdesc(sc, fd->config_index, &len);
		if (len > fd->size)
			len = fd->size;
		iov.iov_base = (caddr_t)fd->data;
d1175 2
a1176 2
		err = usbd_get_string_desc(sc->sc_udev, si->string_index, 
			  si->language_id, &si->desc);
d1183 1
a1183 1
		int len = UGETW(ur->request.wLength);
d1193 6
a1198 6
		if ((ur->request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->request.bRequest == UR_SET_ADDRESS) ||
		    (ur->request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->request.bRequest == UR_SET_CONFIG) ||
		    (ur->request.bmRequestType == UT_WRITE_INTERFACE &&
		     ur->request.bRequest == UR_SET_INTERFACE))
d1204 1
a1204 1
			iov.iov_base = (caddr_t)ur->data;
d1212 1
a1212 1
				ur->request.bmRequestType & UT_READ ? 
d1222 2
a1223 2
		err = usbd_do_request_flags(sc->sc_udev, &ur->request, 
			  ptr, ur->flags, &ur->actlen);
@


1.17.2.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.17 2001/10/31 04:24:44 nate Exp $ */
d1067 1
a1067 1
			  ai->uai_interface_index, &iface);
d1073 1
a1073 1
		ai->uai_alt_no = idesc->bAlternateSetting;
d1080 1
a1080 1
			  ai->uai_interface_index, &iface);
d1083 1
a1083 1
		err = ugen_set_interface(sc, ai->uai_interface_index, ai->uai_alt_no);
d1089 1
a1089 1
		cdesc = ugen_get_cdesc(sc, ai->uai_config_index, 0);
d1092 1
a1092 1
		idesc = usbd_find_idesc(cdesc, ai->uai_interface_index, 0);
d1097 1
a1097 1
		ai->uai_alt_no = usbd_get_no_alts(cdesc, idesc->bInterfaceNumber);
d1106 1
a1106 1
		cdesc = ugen_get_cdesc(sc, cd->ucd_config_index, 0);
d1109 1
a1109 1
		cd->ucd_desc = *cdesc;
d1114 1
a1114 1
		cdesc = ugen_get_cdesc(sc, id->uid_config_index, 0);
d1117 3
a1119 3
		if (id->uid_config_index == USB_CURRENT_CONFIG_INDEX &&
		    id->uid_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, id->uid_interface_index);
d1121 2
a1122 2
			alt = id->uid_alt_index;
		idesc = usbd_find_idesc(cdesc, id->uid_interface_index, alt);
d1127 1
a1127 1
		id->uid_desc = *idesc;
d1132 1
a1132 1
		cdesc = ugen_get_cdesc(sc, ed->ued_config_index, 0);
d1135 3
a1137 3
		if (ed->ued_config_index == USB_CURRENT_CONFIG_INDEX &&
		    ed->ued_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, ed->ued_interface_index);
d1139 3
a1141 3
			alt = ed->ued_alt_index;
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index, 
					alt, ed->ued_endpoint_index);
d1146 1
a1146 1
		ed->ued_desc = *edesc;
d1157 4
a1160 4
		cdesc = ugen_get_cdesc(sc, fd->ufd_config_index, &len);
		if (len > fd->ufd_size)
			len = fd->ufd_size;
		iov.iov_base = (caddr_t)fd->ufd_data;
d1175 2
a1176 2
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index, 
			  si->usd_language_id, &si->usd_desc);
d1183 1
a1183 1
		int len = UGETW(ur->ucr_request.wLength);
d1193 6
a1198 6
		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
d1204 1
a1204 1
			iov.iov_base = (caddr_t)ur->ucr_data;
d1212 1
a1212 1
				ur->ucr_request.bmRequestType & UT_READ ? 
d1222 2
a1223 2
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request, 
			  ptr, ur->ucr_flags, &ur->ucr_actlen);
@


1.17.2.2
log
@sync to -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ugen.c,v 1.59 2002/07/11 21:14:28 augustss Exp $	*/
d23 2
a24 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d123 1
a123 1
#if defined(__NetBSD__)
d153 1
a153 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d159 2
a160 2
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long,
			 caddr_t, int, usb_proc_ptr);
d162 1
a162 1
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc,
d194 1
a194 1

d204 1
a204 1
		printf("%s: setting configuration index 0 failed\n",
d214 1
a214 1
		printf("%s: setting configuration %d failed\n",
a249 13

	/*
	 * We start at 1, not 0, because we don't care whether the
	 * control endpoint is open or not. It is always present.
	 */
	for (endptno = 1; endptno < USB_MAX_ENDPOINTS; endptno++)
		if (sc->sc_is_open[endptno]) {
			DPRINTFN(1,
			     ("ugen_set_config: %s - endpoint %d is open\n",
			      USBDEVNAME(sc->sc_dev), endptno));
			return (USBD_IN_USE);
		}

d275 1
a275 1
				    "(%d,%d), sce=%p\n",
d287 1
a287 1
ugenopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d302 1
a302 1
	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n",
d333 1
a333 1
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n",
d342 1
a342 1
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n",
d344 6
a349 6
			if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
				return (ENOMEM);
			err = usbd_open_pipe_intr(sce->iface,
				  edesc->bEndpointAddress,
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce,
				  sce->ibuf, isize, ugenintr,
d359 1
a359 1
			err = usbd_open_pipe(sce->iface,
d374 1
a374 1
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n",
a410 1
			sce->timeout = USBD_DEFAULT_TIMEOUT;
d419 1
a419 1
ugenclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d451 1
a451 1
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n",
d453 1
a453 1

d458 8
a465 8
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			ndflush(&sce->q, sce->q.c_cc);
			clfree(&sce->q);
			break;
		case UE_ISOCHRONOUS:
			for (i = 0; i < UGEN_NISOREQS; ++i)
				usbd_free_xfer(sce->isoreqs[i].xfer);
d467 2
a468 2
		default:
			break;
d475 1
d561 2
a562 2
				  sce->state & UGEN_SHORT_OK ?
				      USBD_SHORT_XFER_OK : 0,
d618 1
a618 1

d680 1
a680 1
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0,
d801 1
a801 2
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sce->pipeh);
d808 1
a808 1
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n",
d814 1
a814 1

d824 1
a824 1
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d899 1
a899 1

d962 1
a962 2
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,
						len);
d985 1
a985 1
	      caddr_t addr, int flag, usb_proc_ptr p)
d1009 1
a1011 1
		/* This flag only affects read */
d1013 1
a1013 1
		if (sce == NULL || sce->pipeh == NULL)
d1015 6
d1028 1
a1028 5
		if (sce == NULL
		    /* XXX this shouldn't happen, but the distinction between
		       input and output pipes isn't clear enough.
		       || sce->pipeh == NULL */
			)
d1030 6
d1061 1
a1061 6
		switch (err) {
		case USBD_NORMAL_COMPLETION:
			break;
		case USBD_IN_USE:
			return (EBUSY);
		default:
a1062 1
		}
d1066 1
a1066 1
		err = usbd_device2interface_handle(sc->sc_udev,
d1079 1
a1079 1
		err = usbd_device2interface_handle(sc->sc_udev,
d1083 1
a1083 2
		err = ugen_set_interface(sc, ai->uai_interface_index,
		    ai->uai_alt_no);
d1097 1
a1097 2
		ai->uai_alt_no = usbd_get_no_alts(cdesc,
		    idesc->bInterfaceNumber);
d1140 1
a1140 1
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index,
d1175 1
a1175 1
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index,
d1212 1
a1212 1
				ur->ucr_request.bmRequestType & UT_READ ?
d1222 2
a1223 3
		sce = &sc->sc_endpoints[endpt][IN];
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
d1251 1
a1251 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d1267 1
a1267 1
ugenpoll(dev_t dev, int events, usb_proc_ptr p)
d1312 1
a1312 1
		/*
d1317 1
a1317 1
		revents |= events &
@


1.17.2.3
log
@sync
@
text
@d2 1
a2 1
/*	$NetBSD: ugen.c,v 1.62 2002/10/23 09:13:59 jdolecek Exp $	*/
d124 1
a124 12
dev_type_open(ugenopen);
dev_type_close(ugenclose);
dev_type_read(ugenread);
dev_type_write(ugenwrite);
dev_type_ioctl(ugenioctl);
dev_type_poll(ugenpoll);
dev_type_kqfilter(ugenkqfilter);

const struct cdevsw ugen_cdevsw = {
	ugenopen, ugenclose, ugenread, ugenwrite, ugenioctl,
	nostop, notty, ugenpoll, nommap, ugenkqfilter,
};
d195 1
a195 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
d738 1
d782 1
a783 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ugen_cdevsw);
#elif defined(__OpenBSD__)
a786 1
#endif
d791 3
@


1.16
log
@occured->occurred

idea from deraadt@@ via NetBSD
millert@@ ok
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.15 2001/05/03 02:20:33 aaron Exp $ */
/*	$NetBSD: ugen.c,v 1.45 2000/12/13 04:05:14 augustss Exp $	*/
d177 4
d524 1
a524 1
			DPRINTFN(5, ("ugenread: sleep on %p\n", sc));
d588 1
a588 1
			DPRINTFN(5, ("ugenread: sleep on %p\n", sc));
d830 1
d849 19
a867 9
	/* copy data to buffer */
	while (count > 0) {
		n = min(count, sce->limit - sce->fill);
		memcpy(sce->fill, req->dmabuf, n);

		count -= n;
		sce->fill += n;
		if(sce->fill == sce->limit)
			sce->fill = sce->ibuf;
@


1.15
log
@Sync with NetBSD. Tested with a USB keyboard, USB mouse, and three different
kue(4) Ethernet devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.14 2001/01/28 09:43:41 aaron Exp $ */
d512 1
a512 1
		/* Block until activity occured. */
@


1.14
log
@Another USB sync with NetBSD. We are still lacking an up-to-date umass(4)
driver. I would appreciate it if someone with the hardware looked into it.
I also have to take a closer look at changes to the USB Ethernet drivers,
as well as import some drivers we are missing (uftdi, if_upl, yap, etc.)
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.13 2000/11/21 18:45:53 mickey Exp $ */
/*	$NetBSD: ugen.c,v 1.43 2000/10/24 14:53:59 augustss Exp $	*/
@


1.13
log
@be consistant w/ ugenwrite on dprintf; aaron@@ ok
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.12 2000/11/08 18:10:38 aaron Exp $ */
d1227 1
a1227 1
				     (struct usb_device_info *)addr);
@


1.12
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.11 2000/07/04 11:44:23 fgsch Exp $ */
d491 1
a491 3
#ifdef __NetBSD__
	DPRINTFN(5, ("ugenread: %d:%d\n", sc->sc_dev.dv_unit, endpt));
#endif
@


1.11
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.10 2000/03/30 16:19:33 aaron Exp $ */
/*	$NetBSD: ugen.c,v 1.37 2000/03/27 12:33:55 augustss Exp $	*/
d79 8
d97 4
a100 1
	void *ibuf;
d102 6
a109 4
#define	UGEN_CHUNK	128	/* chunk size for read */
#define	UGEN_IBSIZE	1020	/* buffer size */
#define	UGEN_BBSIZE	1024

d153 13
a165 12
Static void ugenintr __P((usbd_xfer_handle xfer, usbd_private_handle addr, 
			  usbd_status status));

Static int ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));
Static int ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));
Static int ugen_do_ioctl __P((struct ugen_softc *, int, u_long, 
			      caddr_t, int, struct proc *));
Static int ugen_set_config __P((struct ugen_softc *sc, int configno));
Static usb_config_descriptor_t *ugen_get_cdesc __P((struct ugen_softc *sc, 
						    int index, int *lenp));
Static usbd_status ugen_set_interface __P((struct ugen_softc *, int, int));
Static int ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));
d233 1
a233 3
ugen_set_config(sc, configno)
	struct ugen_softc *sc;
	int configno;
d248 1
a248 1
		err = usbd_set_config_no(dev, configno, 0);
d283 1
a283 5
ugenopen(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d292 3
d360 46
a406 1
		case UE_ISOCHRONOUS:
d415 1
a415 5
ugenclose(dev, flag, mode, p)
	dev_t dev;
	int flag;
	int mode;
	struct proc *p;
d421 1
d453 14
a466 1
		
d480 1
a480 5
ugen_do_read(sc, endpt, uio, flag)
	struct ugen_softc *sc;
	int endpt;
	struct uio *uio;
	int flag;
d578 39
d624 1
a624 4
ugenread(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d640 1
a640 5
ugen_do_write(sc, endpt, uio, flag)
	struct ugen_softc *sc;
	int endpt;
	struct uio *uio;
	int flag;
d699 1
a699 4
ugenwrite(dev, uio, flag)
	dev_t dev;
	struct uio *uio;
	int flag;
d716 1
a716 3
ugen_activate(self, act)
	device_ptr_t self;
	enum devact act;
d787 1
a787 4
ugenintr(xfer, addr, status)
	usbd_xfer_handle xfer;
	usbd_private_handle addr;
	usbd_status status;
d821 48
d870 1
a870 3
ugen_set_interface(sc, ifaceidx, altno)
	struct ugen_softc *sc;
	int ifaceidx, altno;
d926 1
a926 4
ugen_get_cdesc(sc, index, lenp)
	struct ugen_softc *sc;
	int index;
	int *lenp;
d959 1
a959 3
ugen_get_alt_index(sc, ifaceidx)
	struct ugen_softc *sc;
	int ifaceidx;
d971 2
a972 7
ugen_do_ioctl(sc, endpt, cmd, addr, flag, p)
	struct ugen_softc *sc;
	int endpt;
	u_long cmd;
	caddr_t addr; 
	int flag;
	struct proc *p;
d1238 1
a1238 6
ugenioctl(dev, cmd, addr, flag, p)
	dev_t dev;
	u_long cmd;
	caddr_t addr; 
	int flag;
	struct proc *p;
d1254 1
a1254 4
ugenpoll(dev, events, p)
	dev_t dev;
	int events;
	struct proc *p;
d1285 8
@


1.10
log
@Sync with NetBSD. USB Ethernet drivers should work now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.9 2000/03/28 19:37:49 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d761 1
d839 1
a839 1
			return (-1);
@


1.9
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ugen.c,v 1.36 2000/03/06 20:59:17 augustss Exp $	*/
d122 1
a122 1
static struct cdevsw ugen_cdevsw = {
d140 1
a140 1
static void ugenintr __P((usbd_xfer_handle xfer, usbd_private_handle addr, 
d143 3
a145 3
static int ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));
static int ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));
static int ugen_do_ioctl __P((struct ugen_softc *, int, u_long, 
d147 2
a148 2
static int ugen_set_config __P((struct ugen_softc *sc, int configno));
static usb_config_descriptor_t *ugen_get_cdesc __P((struct ugen_softc *sc, 
d150 2
a151 2
static usbd_status ugen_set_interface __P((struct ugen_softc *, int, int));
static int ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));
d218 1
a218 1
static int
d413 1
a413 1
static int
d541 1
a541 1
static int
d697 1
a697 1
static void
d735 1
a735 1
static usbd_status
d792 1
a792 1
static usb_config_descriptor_t *
d828 1
a828 1
static int
d842 1
a842 1
static int
@


1.8
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.7 1999/11/07 21:30:19 fgsch Exp $	*/
d3 1
d140 2
a141 2
void ugenintr __P((usbd_xfer_handle xfer, usbd_private_handle addr, 
		   usbd_status status));
d143 9
a151 9
int ugen_do_read __P((struct ugen_softc *, int, struct uio *, int));
int ugen_do_write __P((struct ugen_softc *, int, struct uio *, int));
int ugen_do_ioctl __P((struct ugen_softc *, int, u_long, 
		       caddr_t, int, struct proc *));
int ugen_set_config __P((struct ugen_softc *sc, int configno));
usb_config_descriptor_t *ugen_get_cdesc __P((struct ugen_softc *sc, int index,
					     int *lenp));
usbd_status ugen_set_interface __P((struct ugen_softc *, int, int));
int ugen_get_alt_index __P((struct ugen_softc *sc, int ifaceidx));
d186 1
a186 1
		printf("%s: setting configuration index 0 failed\n",
d204 1
a204 1
		struct int global_init_done = 0;
d218 1
a218 1
int
d332 4
a335 4
				edesc->bEndpointAddress, 
				USBD_SHORT_XFER_OK, &sce->pipeh, sce, 
				sce->ibuf, isize, ugenintr,
				USBD_DEFAULT_INTERVAL);
d345 1
a345 2
					   edesc->bEndpointAddress, 0, 
					   &sce->pipeh);
d399 1
a399 1
		sce->pipeh = 0;
d401 1
a401 1
		if (sce->ibuf) {
d405 1
d413 1
a413 1
int
d429 1
a429 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
d440 1
a440 1
	if (!sce->edesc) {
d444 1
a444 1
	if (!sce->pipeh) {
d496 4
a499 4
				xfer, sce->pipeh,
				sce->state & UGEN_SHORT_OK ? 
				    USBD_SHORT_XFER_OK : 0, 
				sce->timeout, buf, &tn, "ugenrb");
d541 1
a541 1
int
d555 1
a555 1
	DPRINTFN(5, ("ugenwrite: %d:%d\n", sc->sc_dev.dv_unit, endpt));
d564 1
a564 1
	if (!sce->edesc) {
d568 1
a568 1
	if (!sce->pipeh) {
d585 1
a585 1
					       sce->timeout, buf, &n,"ugenwb");
d697 1
a697 1
void
d717 1
a717 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, 0);
d735 1
a735 1
usbd_status
d792 1
a792 1
usb_config_descriptor_t *
d819 1
a819 1
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc, len);
d828 1
a828 1
int
d838 1
a838 1
		return (-1);
d842 1
a842 1
int
d880 1
a880 1
		if (!sce->pipeh) {
d895 1
a895 1
		if (!sce->pipeh) {
d931 1
a931 1
						 ai->interface_index, &iface);
d944 1
a944 1
						 ai->interface_index, &iface);
d1033 1
a1033 1
		error = uiomove((caddr_t)cdesc, len, &uio);
d1040 1
a1040 1
					 si->language_id, &si->desc);
d1087 1
a1087 1
					  ptr, ur->flags, &ur->actlen);
d1147 1
@


1.7
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: ugen.c,v 1.27 1999/10/28 12:08:38 augustss Exp $	*/
a126 3
	/* stop */	nostop,
	/* reset */	noreset,
	/* devtotty */	nodevtotty,
a130 1
	/* parms */	noparms,
a134 1
	/* maxio */	0,
d139 1
a139 1
void ugenintr __P((usbd_request_handle reqh, usbd_private_handle addr, 
d171 1
d173 1
a173 1
	usbd_status r;
d180 15
a194 4
	sc->sc_udev = uaa->device;
	conf = 1;		/* XXX should not hard code 1 */
	r = ugen_set_config(sc, conf);
	if (r != USBD_NORMAL_COMPLETION) {
d200 14
d228 1
a228 1
	usbd_status r;
d233 1
d235 3
a237 4
		/* Avoid setting the current value. */
		r = usbd_set_config_no(dev, configno, 0);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d240 3
a242 3
	r = usbd_interface_count(dev, &niface);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d246 6
a251 6
		r = usbd_device2interface_handle(dev, ifaceno, &iface);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
		r = usbd_endpoint_count(iface, &nendpt);
		if (r != USBD_NORMAL_COMPLETION)
			return (r);
d282 1
a282 1
	usbd_status r;
d285 1
d289 1
a289 1
	if (sc->sc_dying)
d299 1
d330 1
a330 1
			r = usbd_open_pipe_intr(sce->iface, 
d333 3
a335 2
				sce->ibuf, isize, ugenintr);
			if (r != USBD_NORMAL_COMPLETION) {
d343 1
a343 1
			r = usbd_open_pipe(sce->iface, 
d346 1
a346 1
			if (r != USBD_NORMAL_COMPLETION)
d371 1
d392 1
a392 1
		if (!sce || !sce->pipeh)
d403 1
a403 1
			sce->ibuf = 0;
d422 2
a423 2
	usbd_request_handle reqh;
	usbd_status r;
d488 2
a489 2
		reqh = usbd_alloc_request(sc->sc_udev);
		if (reqh == 0)
d494 2
a495 2
			r = usbd_bulk_transfer(
				reqh, sce->pipeh,
d499 2
a500 2
			if (r != USBD_NORMAL_COMPLETION) {
				if (r == USBD_INTERRUPTED)
d502 1
a502 1
				else if (r == USBD_TIMEOUT)
d513 1
a513 1
		usbd_free_request(reqh);
d532 1
d551 2
a552 2
	usbd_request_handle reqh;
	usbd_status r;
a553 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a554 1
#endif
d575 2
a576 2
		reqh = usbd_alloc_request(sc->sc_udev);
		if (reqh == 0)
d583 1
a583 1
			r = usbd_bulk_transfer(reqh, sce->pipeh, 0, 
d585 2
a586 2
			if (r != USBD_NORMAL_COMPLETION) {
				if (r == USBD_INTERRUPTED)
d588 2
d595 1
a595 1
		usbd_free_request(reqh);
d614 1
d690 3
d697 2
a698 2
ugenintr(reqh, addr, status)
	usbd_request_handle reqh;
d716 1
a716 1
	usbd_get_request_status(reqh, 0, 0, &count, 0);
d719 2
a720 2
	DPRINTFN(5, ("ugenintr: reqh=%p status=%d count=%d\n", 
		     reqh, status, count));
d741 1
a741 1
	usbd_status r;
d748 3
a750 3
	r = usbd_interface_count(sc->sc_udev, &niface);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d754 6
a759 6
	r = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
	r = usbd_endpoint_count(iface, &nendpt);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d771 7
a777 7
	r = usbd_set_interface(iface, altno);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);

	r = usbd_endpoint_count(iface, &nendpt);
	if (r != USBD_NORMAL_COMPLETION)
		return (r);
d799 1
a799 1
	usbd_status r;
d810 2
a811 2
		r = usbd_get_config_desc(sc->sc_udev, index, &cdescr);
		if (r != USBD_NORMAL_COMPLETION)
d818 2
a819 2
		r = usbd_get_config_desc_full(sc->sc_udev, index, cdesc, len);
		if (r != USBD_NORMAL_COMPLETION) {
d833 1
a833 1
	usbd_status r;
d835 3
a837 3
	r = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (r != USBD_NORMAL_COMPLETION)
			return (-1);
d851 1
a851 1
	usbd_status r;
d909 1
a909 1
#ifdef USB_DEBUG
d915 2
a916 2
		r = usbd_get_config(sc->sc_udev, &conf);
		if (r != USBD_NORMAL_COMPLETION)
d923 2
a924 2
		r = ugen_set_config(sc, *(int *)addr);
		if (r != USBD_NORMAL_COMPLETION)
d929 1
a929 1
		r = usbd_device2interface_handle(sc->sc_udev, 
d931 1
a931 1
		if (r != USBD_NORMAL_COMPLETION)
d934 1
a934 1
		if (!idesc)
d942 1
a942 1
		r = usbd_device2interface_handle(sc->sc_udev, 
d944 1
a944 1
		if (r != USBD_NORMAL_COMPLETION)
d946 2
a947 2
		r = ugen_set_interface(sc, ai->interface_index, ai->alt_no);
		if (r != USBD_NORMAL_COMPLETION)
d953 1
a953 1
		if (!cdesc)
d956 1
a956 1
		if (!idesc) {
d970 1
a970 1
		if (!cdesc)
d978 1
a978 1
		if (!cdesc)
d986 1
a986 1
		if (!idesc) {
d996 1
a996 1
		if (!cdesc)
d1005 1
a1005 1
		if (!edesc) {
d1038 1
a1038 1
		r = usbd_get_string_desc(sc->sc_udev, si->string_index, 
d1040 1
a1040 1
		if (r != USBD_NORMAL_COMPLETION)
d1050 1
a1050 1
		usbd_status r;
d1085 1
a1085 1
		r = usbd_do_request_flags(sc->sc_udev, &ur->request, 
d1087 1
a1087 1
		if (r != USBD_NORMAL_COMPLETION) {
d1126 1
d1155 1
a1155 1
		printf("ugenwrite: no edesc\n");
d1190 1
a1190 1
DEV_DRIVER_MODULE(ugen, uhub, ugen_driver, ugen_devclass, ugen_cdevsw, usbd_driver_load, 0);
@


1.7.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: ugen.c,v 1.14 2001/01/28 09:43:41 aaron Exp $ */
/*	$NetBSD: ugen.c,v 1.43 2000/10/24 14:53:59 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/ugen.c,v 1.26 1999/11/17 22:33:41 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
a77 8
#define	UGEN_CHUNK	128	/* chunk size for read */
#define	UGEN_IBSIZE	1020	/* buffer size */
#define	UGEN_BBSIZE	1024

#define	UGEN_NISOFRAMES	500	/* 0.5 seconds worth */
#define UGEN_NISOREQS	6	/* number of outstanding xfer requests */
#define UGEN_NISORFRMS	4	/* number of frames (miliseconds) per req */

d88 1
a88 4
	u_char *ibuf;		/* start of buffer (circular for isoc) */
	u_char *fill;		/* location for input (isoc) */
	u_char *limit;		/* end of circular buffer (isoc) */
	u_char *cur;		/* current read location (isoc) */
a89 6
	struct isoreq {
		struct ugen_endpoint *sce;
		usbd_xfer_handle xfer;
		void *dmabuf;
		u_int16_t sizes[UGEN_NISORFRMS];
	} isoreqs[UGEN_NISOREQS];
d92 4
d121 1
a121 1
Static struct cdevsw ugen_cdevsw = {
d127 3
d134 1
d139 1
d144 12
a155 13
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
		     usbd_status status);
Static void ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
			    usbd_status status);
Static int ugen_do_read(struct ugen_softc *, int, struct uio *, int);
Static int ugen_do_write(struct ugen_softc *, int, struct uio *, int);
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long, 
			 caddr_t, int, struct proc *);
Static int ugen_set_config(struct ugen_softc *sc, int configno);
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc, 
					       int index, int *lenp);
Static usbd_status ugen_set_interface(struct ugen_softc *, int, int);
Static int ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx);
a175 1
	usbd_device_handle udev;
d177 1
a177 1
	usbd_status err;
d184 4
a187 15
	sc->sc_udev = udev = uaa->device;

	/* First set configuration index 0, the default one for ugen. */
	err = usbd_set_config_index(udev, 0, 0);
	if (err) {
		printf("%s: setting configuration index 0 failed\n", 
		       USBDEVNAME(sc->sc_dev));
		sc->sc_dying = 1;
		USB_ATTACH_ERROR_RETURN;
	}
	conf = usbd_get_config_descriptor(udev)->bConfigurationValue;

	/* Set up all the local state for this configuration. */
	err = ugen_set_config(sc, conf);
	if (err) {
a192 14

#ifdef __FreeBSD__
	{
		static int global_init_done = 0;
		if (!global_init_done) {
			cdevsw_add(&ugen_cdevsw);
			global_init_done = 1;
		}
	}
#endif

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d196 4
a199 2
Static int
ugen_set_config(struct ugen_softc *sc, int configno)
d207 1
a207 1
	usbd_status err;
a211 1
	/* Avoid setting the current value. */
d213 4
a216 3
		err = usbd_set_config_no(dev, configno, 1);
		if (err)
			return (err);
d219 3
a221 3
	err = usbd_interface_count(dev, &niface);
	if (err)
		return (err);
d225 6
a230 6
		err = usbd_device2interface_handle(dev, ifaceno, &iface);
		if (err)
			return (err);
		err = usbd_endpoint_count(iface, &nendpt);
		if (err)
			return (err);
d249 5
a253 1
ugenopen(dev_t dev, int flag, int mode, struct proc *p)
d261 1
a261 4
	usbd_status err;
	usbd_xfer_handle xfer;
	void *buf;
	int i, j;
a263 1

d267 1
a267 1
	if (sc == NULL || sc->sc_dying)
a276 1

d307 5
a311 6
			err = usbd_open_pipe_intr(sce->iface, 
				  edesc->bEndpointAddress, 
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce, 
				  sce->ibuf, isize, ugenintr, 
				  USBD_DEFAULT_INTERVAL);
			if (err) {
d319 4
a322 3
			err = usbd_open_pipe(sce->iface, 
				  edesc->bEndpointAddress, 0, &sce->pipeh);
			if (err)
d325 1
a326 46
			if (dir == OUT)
				return (EINVAL);
			isize = UGETW(edesc->wMaxPacketSize);
			if (isize == 0)	/* shouldn't happen */
				return (EINVAL);
			sce->ibuf = malloc(isize * UGEN_NISOFRAMES,
				M_USBDEV, M_WAITOK);
			sce->cur = sce->fill = sce->ibuf;
			sce->limit = sce->ibuf + isize * UGEN_NISOFRAMES;
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n", 
				     endpt, isize));
			err = usbd_open_pipe(sce->iface,
				  edesc->bEndpointAddress, 0, &sce->pipeh);
			if (err) {
				free(sce->ibuf, M_USBDEV);
				return (EIO);
			}
			for(i = 0; i < UGEN_NISOREQS; ++i) {
				sce->isoreqs[i].sce = sce;
				xfer = usbd_alloc_xfer(sc->sc_udev);
				if (xfer == 0)
					goto bad;
				sce->isoreqs[i].xfer = xfer;
				buf = usbd_alloc_buffer
					(xfer, isize * UGEN_NISORFRMS);
				if (buf == 0) {
					i++;
					goto bad;
				}
				sce->isoreqs[i].dmabuf = buf;
				for(j = 0; j < UGEN_NISORFRMS; ++j)
					sce->isoreqs[i].sizes[j] = isize;
				usbd_setup_isoc_xfer
					(xfer, sce->pipeh, &sce->isoreqs[i],
					 sce->isoreqs[i].sizes,
					 UGEN_NISORFRMS, USBD_NO_COPY,
					 ugen_isoc_rintr);
				(void)usbd_transfer(xfer);
			}
			DPRINTFN(5, ("ugenopen: isoc open done\n"));
			break;
		bad:
			while (--i >= 0) /* implicit buffer free */
				usbd_free_xfer(sce->isoreqs[i].xfer);
			return (ENOMEM);
		case UE_CONTROL:
d335 5
a339 1
ugenclose(dev_t dev, int flag, int mode, struct proc *p)
a344 1
	int i;
a346 1

d367 1
a367 1
		if (sce == NULL || sce->pipeh == NULL)
d374 3
a376 16
		sce->pipeh = NULL;

                switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
                case UE_INTERRUPT:
                        ndflush(&sce->q, sce->q.c_cc);
                        clfree(&sce->q);
                        break;
                case UE_ISOCHRONOUS:
                        for (i = 0; i < UGEN_NISOREQS; ++i)
                                usbd_free_xfer(sce->isoreqs[i].xfer);

                default:
                        break;
		}

		if (sce->ibuf != NULL) {
d378 1
a378 1
			sce->ibuf = NULL;
a379 1

d387 6
a392 2
Static int
ugen_do_read(struct ugen_softc *sc, int endpt, struct uio *uio, int flag)
d397 2
a398 2
	usbd_xfer_handle xfer;
	usbd_status err;
d403 3
a405 1
	DPRINTFN(5, ("%s: ugenread: %d\n", USBDEVNAME(sc->sc_dev), endpt));
d414 1
a414 1
	if (sce->edesc == NULL) {
d418 1
a418 1
	if (sce->pipeh == NULL) {
d463 2
a464 2
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
d469 7
a475 7
			err = usbd_bulk_transfer(
				  xfer, sce->pipeh,
				  sce->state & UGEN_SHORT_OK ? 
				      USBD_SHORT_XFER_OK : 0, 
				  sce->timeout, buf, &tn, "ugenrb");
			if (err) {
				if (err == USBD_INTERRUPTED)
d477 1
a477 1
				else if (err == USBD_TIMEOUT)
d488 1
a488 38
		usbd_free_xfer(xfer);
		break;
	case UE_ISOCHRONOUS:
		s = splusb();
		while (sce->cur == sce->fill) {
			if (flag & IO_NDELAY) {
				splx(s);
				return (EWOULDBLOCK);
			}
			sce->state |= UGEN_ASLP;
			DPRINTFN(5, ("ugenread: sleep on %p\n", sc));
			error = tsleep(sce, PZERO | PCATCH, "ugenri", 0);
			DPRINTFN(5, ("ugenread: woke, error=%d\n", error));
			if (sc->sc_dying)
				error = EIO;
			if (error) {
				sce->state &= ~UGEN_ASLP;
				break;
			}
		}

		while (sce->cur != sce->fill && uio->uio_resid > 0 && !error) {
			if(sce->fill > sce->cur)
				n = min(sce->fill - sce->cur, uio->uio_resid);
			else
				n = min(sce->limit - sce->cur, uio->uio_resid);

			DPRINTFN(5, ("ugenread: isoc got %d chars\n", n));

			/* Copy the data to the user process. */
			error = uiomove(sce->cur, n, uio);
			if (error)
				break;
			sce->cur += n;
			if(sce->cur >= sce->limit)
				sce->cur = sce->ibuf;
		}
		splx(s);
a489 2

		
d497 4
a500 1
ugenread(dev_t dev, struct uio *uio, int flag)
a506 1

d514 6
a519 2
Static int
ugen_do_write(struct ugen_softc *sc, int endpt, struct uio *uio, int flag)
d525 2
a526 2
	usbd_xfer_handle xfer;
	usbd_status err;
d528 3
a530 1
	DPRINTFN(5, ("%s: ugenwrite: %d\n", USBDEVNAME(sc->sc_dev), endpt));
d539 1
a539 1
	if (sce->edesc == NULL) {
d543 1
a543 1
	if (sce->pipeh == NULL) {
d551 2
a552 2
		xfer = usbd_alloc_xfer(sc->sc_udev);
		if (xfer == 0)
d559 4
a562 4
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0, 
				  sce->timeout, buf, &n,"ugenwb");
			if (err) {
				if (err == USBD_INTERRUPTED)
a563 2
				else if (err == USBD_TIMEOUT)
					error = ETIMEDOUT;
d569 1
a569 1
		usbd_free_xfer(xfer);
d578 4
a581 1
ugenwrite(dev_t dev, struct uio *uio, int flag)
a587 1

d597 3
a599 1
ugen_activate(device_ptr_t self, enum devact act)
a662 3
	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   USBDEV(sc->sc_dev));

d666 5
a670 2
Static void
ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr, usbd_status status)
d686 1
a686 1
	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
d689 2
a690 2
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n", 
		     xfer, status, count));
d704 4
a707 50
Static void
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr, 
		usbd_status status)
{
	struct isoreq *req = addr;
	struct ugen_endpoint *sce = req->sce;
	u_int32_t count, n;

	/* Return if we are aborting. */
	if (status == USBD_CANCELLED)
		return;

	usbd_get_xfer_status(xfer, NULL, NULL, &count, NULL);
	DPRINTFN(5,("ugen_isoc_rintr: xfer %d, count=%d\n", req - sce->isoreqs,
		    count));

	/* throw away oldest input if the buffer is full */
	if(sce->fill < sce->cur && sce->cur <= sce->fill + count) {
		sce->cur += count;
		if(sce->cur >= sce->limit)
			sce->cur = sce->ibuf + (sce->limit - sce->cur);
		DPRINTFN(5, ("ugen_isoc_rintr: throwing away %d bytes\n",
			     count));
	}

	/* copy data to buffer */
	while (count > 0) {
		n = min(count, sce->limit - sce->fill);
		memcpy(sce->fill, req->dmabuf, n);

		count -= n;
		sce->fill += n;
		if(sce->fill == sce->limit)
			sce->fill = sce->ibuf;
	}

	usbd_setup_isoc_xfer(xfer, sce->pipeh, req, req->sizes, UGEN_NISORFRMS,
			     USBD_NO_COPY, ugen_isoc_rintr);
	(void)usbd_transfer(xfer);

	if (sce->state & UGEN_ASLP) {
		sce->state &= ~UGEN_ASLP;
		DPRINTFN(5, ("ugen_isoc_rintr: waking %p\n", sce));
		wakeup(sce);
	}
	selwakeup(&sce->rsel);
}

Static usbd_status
ugen_set_interface(struct ugen_softc *sc, int ifaceidx, int altno)
d711 1
a711 1
	usbd_status err;
d718 3
a720 3
	err = usbd_interface_count(sc->sc_udev, &niface);
	if (err)
		return (err);
d724 6
a729 7
	err = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (err)
		return (err);
	err = usbd_endpoint_count(iface, &nendpt);
	if (err)
		return (err);
	/* XXX should only do this after setting new altno has succeeded */
d741 7
a747 7
	err = usbd_set_interface(iface, altno);
	if (err)
		return (err);

	err = usbd_endpoint_count(iface, &nendpt);
	if (err)
		return (err);
d761 5
a765 2
Static usb_config_descriptor_t *
ugen_get_cdesc(struct ugen_softc *sc, int index, int *lenp)
d769 1
a769 1
	usbd_status err;
d780 2
a781 2
		err = usbd_get_config_desc(sc->sc_udev, index, &cdescr);
		if (err)
d788 2
a789 2
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,len);
		if (err) {
d797 4
a800 2
Static int
ugen_get_alt_index(struct ugen_softc *sc, int ifaceidx)
d803 1
a803 1
	usbd_status err;
d805 3
a807 3
	err = usbd_device2interface_handle(sc->sc_udev, ifaceidx, &iface);
	if (err)
		return (-1);
d811 8
a818 3
Static int
ugen_do_ioctl(struct ugen_softc *sc, int endpt, u_long cmd,
	      caddr_t addr, int flag, struct proc *p)
d821 1
a821 1
	usbd_status err;
d849 1
a849 1
		if (sce->pipeh == NULL) {
d864 1
a864 1
		if (sce->pipeh == NULL) {
d879 1
a879 1
#ifdef UGEN_DEBUG
d885 2
a886 2
		err = usbd_get_config(sc->sc_udev, &conf);
		if (err)
d893 2
a894 2
		err = ugen_set_config(sc, *(int *)addr);
		if (err)
d899 3
a901 3
		err = usbd_device2interface_handle(sc->sc_udev, 
			  ai->interface_index, &iface);
		if (err)
d904 1
a904 1
		if (idesc == NULL)
d912 3
a914 3
		err = usbd_device2interface_handle(sc->sc_udev, 
			  ai->interface_index, &iface);
		if (err)
d916 2
a917 2
		err = ugen_set_interface(sc, ai->interface_index, ai->alt_no);
		if (err)
d923 1
a923 1
		if (cdesc == NULL)
d926 1
a926 1
		if (idesc == NULL) {
d940 1
a940 1
		if (cdesc == NULL)
d948 1
a948 1
		if (cdesc == NULL)
d956 1
a956 1
		if (idesc == NULL) {
d966 1
a966 1
		if (cdesc == NULL)
d975 1
a975 1
		if (edesc == NULL) {
d1002 1
a1002 1
		error = uiomove((void *)cdesc, len, &uio);
d1008 3
a1010 3
		err = usbd_get_string_desc(sc->sc_udev, si->string_index, 
			  si->language_id, &si->desc);
		if (err)
d1020 1
a1020 1
		usbd_status err;
d1055 3
a1057 3
		err = usbd_do_request_flags(sc->sc_udev, &ur->request, 
			  ptr, ur->flags, &ur->actlen);
		if (err) {
d1075 1
a1075 1
				     (struct usb_device_info *)addr, 1);
d1084 6
a1089 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, struct proc *p)
a1095 1

d1104 4
a1107 1
ugenpoll(dev_t dev, int events, struct proc *p)
a1114 1

d1124 1
a1124 1
		printf("ugenpoll: no edesc\n");
a1141 8
	case UE_ISOCHRONOUS:
		if (events & (POLLIN | POLLRDNORM)) {
			if (sce->cur != sce->fill)
				revents |= events & (POLLIN | POLLRDNORM);
			else
				selrecord(p, &sce->rsel);
		}
		break;
d1159 1
a1159 1
DRIVER_MODULE(ugen, uhub, ugen_driver, ugen_devclass, usbd_driver_load, 0);
@


1.7.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ugen.c,v 1.45 2000/12/13 04:05:14 augustss Exp $	*/
@


1.7.2.3
log
@Sync the SMP branch to something just after 3.0
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.7.2.2 2001/07/04 10:43:51 niklas Exp $ */
d512 1
a512 1
		/* Block until activity occurred. */
@


1.7.2.4
log
@Merge in -current
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ugen.c,v 1.49 2001/10/24 22:31:04 augustss Exp $	*/
a176 4
#if 0
	if (uaa->matchlvl)
		return (uaa->matchlvl);
#endif
d520 1
a520 1
			DPRINTFN(5, ("ugenread: sleep on %p\n", sce));
d584 1
a584 1
			DPRINTFN(5, ("ugenread: sleep on %p\n", sce));
a825 1
	int i, isize;
d844 9
a852 19
	isize = UGETW(sce->edesc->wMaxPacketSize);
	for (i = 0; i < UGEN_NISORFRMS; i++) {
		u_int32_t actlen = req->sizes[i];
		char const *buf = (char const *)req->dmabuf + isize * i;

		/* copy data to buffer */
		while (actlen > 0) {
			n = min(actlen, sce->limit - sce->fill);
			memcpy(sce->fill, buf, n);

			buf += n;
			actlen -= n;
			sce->fill += n;
			if(sce->fill == sce->limit)
				sce->fill = sce->ibuf;
		}

		/* setup size for next transfer */
		req->sizes[i] = isize;
@


1.7.2.5
log
@Sync the SMP branch with 3.3
@
text
@d2 1
a2 1
/*	$NetBSD: ugen.c,v 1.62 2002/10/23 09:13:59 jdolecek Exp $	*/
d23 2
a24 2
 *	This product includes software developed by the NetBSD
 *	Foundation, Inc. and its contributors.
d123 2
a124 13
#if defined(__NetBSD__)
dev_type_open(ugenopen);
dev_type_close(ugenclose);
dev_type_read(ugenread);
dev_type_write(ugenwrite);
dev_type_ioctl(ugenioctl);
dev_type_poll(ugenpoll);
dev_type_kqfilter(ugenkqfilter);

const struct cdevsw ugen_cdevsw = {
	ugenopen, ugenclose, ugenread, ugenwrite, ugenioctl,
	nostop, notty, ugenpoll, nommap, ugenkqfilter,
};
d153 1
a153 1
Static void ugenintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d159 2
a160 2
Static int ugen_do_ioctl(struct ugen_softc *, int, u_long,
			 caddr_t, int, usb_proc_ptr);
d162 1
a162 1
Static usb_config_descriptor_t *ugen_get_cdesc(struct ugen_softc *sc,
d194 1
a194 1

d204 1
a204 1
		printf("%s: setting configuration index 0 failed\n",
d214 1
a214 1
		printf("%s: setting configuration %d failed\n",
a249 13

	/*
	 * We start at 1, not 0, because we don't care whether the
	 * control endpoint is open or not. It is always present.
	 */
	for (endptno = 1; endptno < USB_MAX_ENDPOINTS; endptno++)
		if (sc->sc_is_open[endptno]) {
			DPRINTFN(1,
			     ("ugen_set_config: %s - endpoint %d is open\n",
			      USBDEVNAME(sc->sc_dev), endptno));
			return (USBD_IN_USE);
		}

d275 1
a275 1
				    "(%d,%d), sce=%p\n",
d287 1
a287 1
ugenopen(dev_t dev, int flag, int mode, usb_proc_ptr p)
d302 1
a302 1
	DPRINTFN(5, ("ugenopen: flag=%d, mode=%d, unit=%d endpt=%d\n",
d333 1
a333 1
		DPRINTFN(5, ("ugenopen: sc=%p, endpt=%d, dir=%d, sce=%p\n",
d342 1
a342 1
			DPRINTFN(5, ("ugenopen: intr endpt=%d,isize=%d\n",
d344 6
a349 6
			if (clalloc(&sce->q, UGEN_IBSIZE, 0) == -1)
				return (ENOMEM);
			err = usbd_open_pipe_intr(sce->iface,
				  edesc->bEndpointAddress,
				  USBD_SHORT_XFER_OK, &sce->pipeh, sce,
				  sce->ibuf, isize, ugenintr,
d359 1
a359 1
			err = usbd_open_pipe(sce->iface,
d374 1
a374 1
			DPRINTFN(5, ("ugenopen: isoc endpt=%d, isize=%d\n",
a410 1
			sce->timeout = USBD_DEFAULT_TIMEOUT;
d419 1
a419 1
ugenclose(dev_t dev, int flag, int mode, usb_proc_ptr p)
d451 1
a451 1
		DPRINTFN(5, ("ugenclose: endpt=%d dir=%d sce=%p\n",
d453 1
a453 1

d458 8
a465 8
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			ndflush(&sce->q, sce->q.c_cc);
			clfree(&sce->q);
			break;
		case UE_ISOCHRONOUS:
			for (i = 0; i < UGEN_NISOREQS; ++i)
				usbd_free_xfer(sce->isoreqs[i].xfer);
d467 2
a468 2
		default:
			break;
d475 1
d561 2
a562 2
				  sce->state & UGEN_SHORT_OK ?
				      USBD_SHORT_XFER_OK : 0,
d618 1
a618 1

d680 1
a680 1
			err = usbd_bulk_transfer(xfer, sce->pipeh, 0,
d725 1
d769 1
a770 3
#if defined(__NetBSD__)
	maj = cdevsw_lookup_major(&ugen_cdevsw);
#elif defined(__OpenBSD__)
a773 1
#endif
d778 3
d801 1
a801 2
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sce->pipeh);
d808 1
a808 1
	DPRINTFN(5, ("ugenintr: xfer=%p status=%d count=%d\n",
d814 1
a814 1

d824 1
a824 1
ugen_isoc_rintr(usbd_xfer_handle xfer, usbd_private_handle addr,
d899 1
a899 1

d962 1
a962 2
		err = usbd_get_config_desc_full(sc->sc_udev, index, cdesc,
						len);
d985 1
a985 1
	      caddr_t addr, int flag, usb_proc_ptr p)
d1009 1
a1011 1
		/* This flag only affects read */
d1013 1
a1013 1
		if (sce == NULL || sce->pipeh == NULL)
d1015 6
d1028 1
a1028 5
		if (sce == NULL
		    /* XXX this shouldn't happen, but the distinction between
		       input and output pipes isn't clear enough.
		       || sce->pipeh == NULL */
			)
d1030 6
d1061 1
a1061 6
		switch (err) {
		case USBD_NORMAL_COMPLETION:
			break;
		case USBD_IN_USE:
			return (EBUSY);
		default:
a1062 1
		}
d1066 2
a1067 2
		err = usbd_device2interface_handle(sc->sc_udev,
			  ai->uai_interface_index, &iface);
d1073 1
a1073 1
		ai->uai_alt_no = idesc->bAlternateSetting;
d1079 2
a1080 2
		err = usbd_device2interface_handle(sc->sc_udev,
			  ai->uai_interface_index, &iface);
d1083 1
a1083 2
		err = ugen_set_interface(sc, ai->uai_interface_index,
		    ai->uai_alt_no);
d1089 1
a1089 1
		cdesc = ugen_get_cdesc(sc, ai->uai_config_index, 0);
d1092 1
a1092 1
		idesc = usbd_find_idesc(cdesc, ai->uai_interface_index, 0);
d1097 1
a1097 2
		ai->uai_alt_no = usbd_get_no_alts(cdesc,
		    idesc->bInterfaceNumber);
d1106 1
a1106 1
		cdesc = ugen_get_cdesc(sc, cd->ucd_config_index, 0);
d1109 1
a1109 1
		cd->ucd_desc = *cdesc;
d1114 1
a1114 1
		cdesc = ugen_get_cdesc(sc, id->uid_config_index, 0);
d1117 3
a1119 3
		if (id->uid_config_index == USB_CURRENT_CONFIG_INDEX &&
		    id->uid_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, id->uid_interface_index);
d1121 2
a1122 2
			alt = id->uid_alt_index;
		idesc = usbd_find_idesc(cdesc, id->uid_interface_index, alt);
d1127 1
a1127 1
		id->uid_desc = *idesc;
d1132 1
a1132 1
		cdesc = ugen_get_cdesc(sc, ed->ued_config_index, 0);
d1135 3
a1137 3
		if (ed->ued_config_index == USB_CURRENT_CONFIG_INDEX &&
		    ed->ued_alt_index == USB_CURRENT_ALT_INDEX)
			alt = ugen_get_alt_index(sc, ed->ued_interface_index);
d1139 3
a1141 3
			alt = ed->ued_alt_index;
		edesc = usbd_find_edesc(cdesc, ed->ued_interface_index,
					alt, ed->ued_endpoint_index);
d1146 1
a1146 1
		ed->ued_desc = *edesc;
d1157 4
a1160 4
		cdesc = ugen_get_cdesc(sc, fd->ufd_config_index, &len);
		if (len > fd->ufd_size)
			len = fd->ufd_size;
		iov.iov_base = (caddr_t)fd->ufd_data;
d1175 2
a1176 2
		err = usbd_get_string_desc(sc->sc_udev, si->usd_string_index,
			  si->usd_language_id, &si->usd_desc);
d1183 1
a1183 1
		int len = UGETW(ur->ucr_request.wLength);
d1193 6
a1198 6
		if ((ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_ADDRESS) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_DEVICE &&
		     ur->ucr_request.bRequest == UR_SET_CONFIG) ||
		    (ur->ucr_request.bmRequestType == UT_WRITE_INTERFACE &&
		     ur->ucr_request.bRequest == UR_SET_INTERFACE))
d1204 1
a1204 1
			iov.iov_base = (caddr_t)ur->ucr_data;
d1212 1
a1212 1
				ur->ucr_request.bmRequestType & UT_READ ?
d1222 2
a1223 3
		sce = &sc->sc_endpoints[endpt][IN];
		err = usbd_do_request_flags(sc->sc_udev, &ur->ucr_request,
			  ptr, ur->ucr_flags, &ur->ucr_actlen, sce->timeout);
d1251 1
a1251 1
ugenioctl(dev_t dev, u_long cmd, caddr_t addr, int flag, usb_proc_ptr p)
d1267 1
a1267 1
ugenpoll(dev_t dev, int events, usb_proc_ptr p)
d1312 1
a1312 1
		/*
d1317 1
a1317 1
		revents |= events &
@


1.7.2.6
log
@Sync the SMP branch to -current. This includes moving to ELF.
@
text
@d1 1
a1 1
/*	$OpenBSD: ugen.c,v 1.7.2.5 2003/03/28 00:38:31 niklas Exp $ */
d206 1
a206 1
	usbd_devinfo(uaa->device, 0, devinfo, sizeof devinfo);
@


1.7.2.7
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: ugen.c,v 1.63 2002/11/26 18:49:48 christos Exp $	*/
a1350 126
}

Static void filt_ugenrdetach(struct knote *);
Static int filt_ugenread_intr(struct knote *, long);
Static int filt_ugenread_isoc(struct knote *, long);
int ugenkqfilter(dev_t, struct knote *);

Static void
filt_ugenrdetach(struct knote *kn)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;
	int s;

	s = splusb();
	SLIST_REMOVE(&sce->rsel.sel_klist, kn, knote, kn_selnext);
	splx(s);
}

Static int
filt_ugenread_intr(struct knote *kn, long hint)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;

	kn->kn_data = sce->q.c_cc;
	return (kn->kn_data > 0);
}

Static int
filt_ugenread_isoc(struct knote *kn, long hint)
{
	struct ugen_endpoint *sce = (void *)kn->kn_hook;

	if (sce->cur == sce->fill)
		return (0);

	if (sce->cur < sce->fill)
		kn->kn_data = sce->fill - sce->cur;
	else
		kn->kn_data = (sce->limit - sce->cur) +
		    (sce->fill - sce->ibuf);

	return (1);
}

Static struct filterops ugenread_intr_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_ugenread_intr };

Static struct filterops ugenread_isoc_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_ugenread_isoc };

Static struct filterops ugen_seltrue_filtops =
	{ 1, NULL, filt_ugenrdetach, filt_seltrue };

int
ugenkqfilter(dev_t dev, struct knote *kn)
{
	struct ugen_softc *sc;
	struct ugen_endpoint *sce;
	struct klist *klist;
	int s;

	USB_GET_SC(ugen, UGENUNIT(dev), sc);

	if (sc->sc_dying)
		return (1);

	/* XXX always IN */
	sce = &sc->sc_endpoints[UGENENDPOINT(dev)][IN];
	if (sce == NULL)
		return (1);

	switch (kn->kn_filter) {
	case EVFILT_READ:
		klist = &sce->rsel.sel_klist;
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
			kn->kn_fop = &ugenread_intr_filtops;
			break;
		case UE_ISOCHRONOUS:
			kn->kn_fop = &ugenread_isoc_filtops;
			break;
		case UE_BULK:
			/* 
			 * We have no easy way of determining if a read will
			 * yield any data or a write will happen.
			 * So, emulate "seltrue".
			 */
			kn->kn_fop = &ugen_seltrue_filtops;
			break;
		default:
			return (1);
		}
		break;

	case EVFILT_WRITE:
		klist = &sce->rsel.sel_klist;
		switch (sce->edesc->bmAttributes & UE_XFERTYPE) {
		case UE_INTERRUPT:
		case UE_ISOCHRONOUS:
			/* XXX poll doesn't support this */
			return (1);

		case UE_BULK:
			/*
			 * We have no easy way of determining if a read will
			 * yield any data or a write will happen.
			 * So, emulate "seltrue".
			 */
			kn->kn_fop = &ugen_seltrue_filtops;
			break;
		default:
			return (1);
		}
		break;

	default:
		return (1);
	}

	kn->kn_hook = (void *)sce;

	s = splusb();
	SLIST_INSERT_HEAD(klist, kn, kn_selnext);
	splx(s);

	return (0);
@


1.6
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: ugen.c,v 1.23 1999/09/09 12:26:44 augustss Exp $	*/
d69 1
a69 1
#ifdef USB_DEBUG
d255 1
a296 2
		if (!edesc)
			return (ENXIO);
a304 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a306 3
#elif defined(__FreeBSD__)
			clist_alloc_cblocks(&sce->q, UGEN_IBSIZE, 0);
#endif
a312 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a313 3
#elif defined(__FreeBSD__)
				clist_free_cblocks(&sce->q);
#endif
a340 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d342 1
d346 1
d403 1
a403 1
#ifdef __NetBSD__
d406 1
d410 3
a501 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d503 1
d506 1
d528 4
d535 3
a548 1
	DPRINTF(("ugenwrite\n"));
a582 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d584 1
d587 1
d595 1
d614 1
d616 1
a616 4
int
ugen_detach(self, flags)
	device_ptr_t self;
	int flags;
d618 1
a618 1
	struct ugen_softc *sc = (struct ugen_softc *)self;
a619 1
	int maj, mn;
d622 2
d626 3
d650 1
d659 3
d846 2
d861 2
a1090 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d1092 1
d1095 1
d1109 1
a1109 1
	USB_GET_SC(ugen, UGENUNIT(dev), sc);
d1114 1
d1120 2
@


1.5
log
@sync with NetBSD;
struct device->bdevice.
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.4 1999/08/29 10:35:35 fgsch Exp $	*/
/*	$NetBSD: ugen.c,v 1.19 1999/08/28 10:01:59 augustss Exp $	*/
d97 1
a97 1
	bdevice sc_dev;		/* base device */
d102 2
a103 2
#define OUT 0			/* index order is important, from UE_OUT */
#define IN  1			/* from UE_IN */
d208 1
d234 2
a235 2
			sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)]
				               [UE_GET_IN(endpt)];
d239 1
a239 1
				    UE_GET_IN(endpt), sce));
d411 1
d413 1
d467 1
a467 1
		reqh = usbd_alloc_request();
d513 1
a513 1
		usb_detach_wakeup(&sc->sc_dev);
d548 1
a548 1
		reqh = usbd_alloc_request();
d587 1
a587 1
		usb_detach_wakeup(&sc->sc_dev);
d593 1
a593 1
	bdevice *self;
d612 1
a612 1
	bdevice *self;
d639 1
a639 1
		usb_detach_wait(&sc->sc_dev);
d703 1
d722 2
a723 1
		sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][UE_GET_IN(endpt)];
d740 2
a741 1
		sce = &sc->sc_endpoints[UE_GET_ADDR(endpt)][UE_GET_IN(endpt)];
d1083 1
a1083 1
		usb_detach_wakeup(&sc->sc_dev);
@


1.4
log
@Sync with NetBSD;
Add some comments.  Change a type name.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d590 1
a590 1
	struct device *self;
d609 1
a609 1
	struct device  *self;
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d2 1
a2 1
/*	$NetBSD: ugen.c,v 1.18 1999/08/23 22:55:14 augustss Exp $	*/
d98 1
a98 1
	struct usbd_device *sc_udev;
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: ugen.c,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: ugen.c,v 1.13 1999/08/02 19:32:56 augustss Exp $	*/
d89 1
d291 1
d474 1
a474 1
				buf, &tn, "ugenrb");
d478 2
d522 1
a522 1
	size_t n;
d553 2
a554 2
			r = usbd_bulk_transfer(reqh, sce->pipeh, 0, buf, 
					       &n, "ugenwb");
d593 11
a659 2
	usbd_private_handle priv;
	void *buffer;
a660 1
	usbd_status xstatus;
d672 1
a672 1
	(void)usbd_get_request_status(reqh, &priv, &buffer, &count, &xstatus);
d676 1
a676 1
		     reqh, xstatus, count));
d831 1
a831 1
			printf("ugenioctl: no pipe\n");
d840 10
a980 1
#if defined(__OpenBSD__)
a981 3
#else
		error = uiomove(cdesc, len, &uio);
#endif
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d70 2
a71 2
#define DPRINTF(x)	if (ugendebug) printf x
#define DPRINTFN(n,x)	if (ugendebug>(n)) printf x
d108 35
a142 6
int ugenopen __P((dev_t, int, int, struct proc *));
int ugenclose __P((dev_t, int, int, struct proc *));
int ugenread __P((dev_t, struct uio *, int));
int ugenwrite __P((dev_t, struct uio *, int));
int ugenioctl __P((dev_t, u_long, caddr_t, int, struct proc *));
int ugenpoll __P((dev_t, int, struct proc *));
d1116 1
a1116 1
DRIVER_MODULE(ugen, usb, ugen_driver, ugen_devclass, usbd_driver_load, 0);
@

