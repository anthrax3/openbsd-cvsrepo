head	1.38;
access;
symbols
	OPENBSD_6_2:1.38.0.6
	OPENBSD_6_2_BASE:1.38
	OPENBSD_6_1:1.38.0.4
	OPENBSD_6_1_BASE:1.38
	OPENBSD_6_0:1.36.0.4
	OPENBSD_6_0_BASE:1.36
	OPENBSD_5_9:1.35.0.2
	OPENBSD_5_9_BASE:1.35
	OPENBSD_5_8:1.31.0.4
	OPENBSD_5_8_BASE:1.31
	OPENBSD_5_7:1.27.0.2
	OPENBSD_5_7_BASE:1.27
	OPENBSD_5_6:1.26.0.4
	OPENBSD_5_6_BASE:1.26
	OPENBSD_5_5:1.24.0.4
	OPENBSD_5_5_BASE:1.24
	OPENBSD_5_4:1.20.0.2
	OPENBSD_5_4_BASE:1.20
	OPENBSD_5_3:1.18.0.2
	OPENBSD_5_3_BASE:1.18
	OPENBSD_5_2:1.16.0.2
	OPENBSD_5_2_BASE:1.16
	OPENBSD_5_1_BASE:1.15
	OPENBSD_5_1:1.15.0.4
	OPENBSD_5_0:1.15.0.2
	OPENBSD_5_0_BASE:1.15
	OPENBSD_4_9:1.14.0.2
	OPENBSD_4_9_BASE:1.14
	OPENBSD_4_8:1.7.0.4
	OPENBSD_4_8_BASE:1.7
	OPENBSD_4_7:1.7.0.2
	OPENBSD_4_7_BASE:1.7
	OPENBSD_4_6:1.6.0.6
	OPENBSD_4_6_BASE:1.6
	OPENBSD_4_5:1.6.0.2
	OPENBSD_4_5_BASE:1.6;
locks; strict;
comment	@ * @;


1.38
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.37;
commitid	VyLWTsbepAOk7VQM;

1.37
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.36;
commitid	xlY19nmD0cBL53l1;

1.36
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.35;
commitid	gWZDkudwxydTq8x4;

1.35
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.34;
commitid	B0kwmVGiD5DVx4kv;

1.34
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.33;
commitid	5gdEnqVoJuTuwdTu;

1.33
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.32;
commitid	eYnPulzvLjDImPCa;

1.32
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.31;
commitid	pwYnMC1gOKohmeGw;

1.31
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.30;
commitid	MVWrtktB46JRxFWT;

1.30
date	2015.05.02.10.44.29;	author jsg;	state Exp;
branches;
next	1.29;
commitid	bVmCCZZhAZIaB19k;

1.29
date	2015.04.10.08.41.43;	author mpi;	state Exp;
branches;
next	1.28;
commitid	aqezguXMYUVIGMPW;

1.28
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.27;
commitid	p4LJxGKbi0BU2cG6;

1.27
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.26;
commitid	yM2VFFhpDTeFQlve;

1.26
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.25;
commitid	Pclvgy2Z4XV9hveD;

1.25
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.24;
commitid	b0VSac5dnnsxcDao;

1.24
date	2014.01.21.09.57.33;	author brad;	state Exp;
branches;
next	1.23;

1.23
date	2014.01.18.15.18.01;	author stsp;	state Exp;
branches;
next	1.22;

1.22
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.21;

1.21
date	2013.08.07.01.06.41;	author bluhm;	state Exp;
branches;
next	1.20;

1.20
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.18;

1.18
date	2012.12.05.23.20.21;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2012.10.22.03.23.19;	author brad;	state Exp;
branches;
next	1.16;

1.16
date	2012.02.28.08.58.30;	author jsg;	state Exp;
branches;
next	1.15;

1.15
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.14;

1.14
date	2011.02.21.19.48.41;	author stsp;	state Exp;
branches;
next	1.13;

1.13
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.11;

1.11
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.10;

1.10
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.9;

1.9
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.8;

1.8
date	2010.09.24.08.33.58;	author yuo;	state Exp;
branches;
next	1.7;

1.7
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.6;

1.6
date	2008.11.22.09.46.12;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2008.11.12.23.42.40;	author sthen;	state Exp;
branches;
next	1.4;

1.4
date	2008.11.06.02.32.29;	author brad;	state Exp;
branches;
next	1.3;

1.3
date	2008.11.02.23.50.48;	author jsg;	state Exp;
branches;
next	1.2;

1.2
date	2008.11.02.12.19.04;	author jsg;	state Exp;
branches;
next	1.1;

1.1
date	2008.10.23.17.21.22;	author deraadt;	state Exp;
branches;
next	;


desc
@@


1.38
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_mos.c,v 1.37 2016/11/06 12:58:01 mpi Exp $	*/

/*
 * Copyright (c) 2008 Johann Christian Rode <jcrode@@gmx.net>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 2005, 2006, 2007 Jonathan Gray <jsg@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Copyright (c) 1997, 1998, 1999, 2000-2003
 *	Bill Paul <wpaul@@windriver.com>.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *	This product includes software developed by Bill Paul.
 * 4. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY Bill Paul AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL Bill Paul OR THE VOICES IN HIS HEAD
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
 * THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Moschip MCS7730/MCS7830/MCS7832 USB to Ethernet controller 
 * The datasheet is available at the following URL: 
 * http://www.moschip.com/data/products/MCS7830/Data%20Sheet_7830.pdf
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/sockio.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <machine/bus.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_mosreg.h>

#ifdef MOS_DEBUG
#define DPRINTF(x)      do { if (mosdebug) printf x; } while (0)
#define DPRINTFN(n,x)   do { if (mosdebug >= (n)) printf x; } while (0)
int     mosdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

/*
 * Various supported device vendors/products.
 */
const struct mos_type mos_devs[] = {
	{ { USB_VENDOR_MOSCHIP, USB_PRODUCT_MOSCHIP_MCS7730 }, MCS7730 },
	{ { USB_VENDOR_MOSCHIP, USB_PRODUCT_MOSCHIP_MCS7830 }, MCS7830 },
	{ { USB_VENDOR_MOSCHIP, USB_PRODUCT_MOSCHIP_MCS7832 }, MCS7832 },
	{ { USB_VENDOR_SITECOMEU, USB_PRODUCT_SITECOMEU_LN030 }, MCS7830 },
};
#define mos_lookup(v, p) ((struct mos_type *)usb_lookup(mos_devs, v, p))

int mos_match(struct device *, void *, void *);
void mos_attach(struct device *, struct device *, void *);
int mos_detach(struct device *, int);

struct cfdriver mos_cd = {
	NULL, "mos", DV_IFNET
};

const struct cfattach mos_ca = {
	sizeof(struct mos_softc), mos_match, mos_attach, mos_detach
};

int mos_tx_list_init(struct mos_softc *);
int mos_rx_list_init(struct mos_softc *);
struct mbuf *mos_newbuf(void);
int mos_encap(struct mos_softc *, struct mbuf *, int);
void mos_rxeof(struct usbd_xfer *, void *, usbd_status);
void mos_txeof(struct usbd_xfer *, void *, usbd_status);
void mos_tick(void *);
void mos_tick_task(void *);
void mos_start(struct ifnet *);
int mos_ioctl(struct ifnet *, u_long, caddr_t);
void mos_init(void *);
void mos_chip_init(struct mos_softc *);
void mos_stop(struct mos_softc *);
void mos_watchdog(struct ifnet *);
int mos_miibus_readreg(struct device *, int, int);
void mos_miibus_writereg(struct device *, int, int, int);
void mos_miibus_statchg(struct device *);
int mos_ifmedia_upd(struct ifnet *);
void mos_ifmedia_sts(struct ifnet *, struct ifmediareq *);
void mos_reset(struct mos_softc *sc);

int mos_reg_read_1(struct mos_softc *, int);
int mos_reg_read_2(struct mos_softc *, int);
int mos_reg_write_1(struct mos_softc *, int, int);
int mos_reg_write_2(struct mos_softc *, int, int);
int mos_readmac(struct mos_softc *, u_char *);
int mos_writemac(struct mos_softc *, u_char *);
int mos_write_mcast(struct mos_softc *, u_char *);

void mos_iff(struct mos_softc *);
void mos_lock_mii(struct mos_softc *);
void mos_unlock_mii(struct mos_softc *);

/*
 * Get exclusive access to the MII registers
 */
void
mos_lock_mii(struct mos_softc *sc)
{
	sc->mos_refcnt++;
	rw_enter_write(&sc->mos_mii_lock);
}

void
mos_unlock_mii(struct mos_softc *sc)
{
	rw_exit_write(&sc->mos_mii_lock);
	if (--sc->mos_refcnt < 0)
		usb_detach_wakeup(&sc->mos_dev);
}

int
mos_reg_read_1(struct mos_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	uByte			val = 0;

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = MOS_UR_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 1);

	err = usbd_do_request(sc->mos_udev, &req, &val);

	if (err) {
		DPRINTF(("mos_reg_read_1 error, reg: %d\n", reg));
		return (-1);
	}

	return (val);
}

int
mos_reg_read_2(struct mos_softc *sc, int reg)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;

	USETW(val,0);

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = MOS_UR_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->mos_udev, &req, &val);

	if (err) {
		DPRINTF(("mos_reg_read_2 error, reg: %d\n", reg));
		return (-1);
	}

	return(UGETW(val));
}

int
mos_reg_write_1(struct mos_softc *sc, int reg, int aval)
{
	usb_device_request_t	req;
	usbd_status		err;
	uByte			val;

	val = aval;

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = MOS_UR_WRITEREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 1);

	err = usbd_do_request(sc->mos_udev, &req, &val);

	if (err) {
		DPRINTF(("mos_reg_write_1 error, reg: %d\n", reg));
		return (-1);
	}

	return(0);
}

int
mos_reg_write_2(struct mos_softc *sc, int reg, int aval)
{
	usb_device_request_t	req;
	usbd_status		err;
	uWord			val;

	USETW(val, aval);

	if (usbd_is_dying(sc->mos_udev))
		return (0);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = MOS_UR_WRITEREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, reg);
	USETW(req.wLength, 2);

	err = usbd_do_request(sc->mos_udev, &req, &val);

	if (err) {
		DPRINTF(("mos_reg_write_2 error, reg: %d\n", reg));
		return (-1);
	}

	return (0);
}

int
mos_readmac(struct mos_softc *sc, u_char *mac)
{
	usb_device_request_t	req;
	usbd_status		err;

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = MOS_UR_READREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, MOS_MAC);
	USETW(req.wLength, ETHER_ADDR_LEN);

	err = usbd_do_request(sc->mos_udev, &req, mac);

	if (err) {
		DPRINTF(("mos_readmac error"));
		return (-1);
	}

	return (0);
}

int
mos_writemac(struct mos_softc *sc, u_char *mac)
{
	usb_device_request_t	req;
	usbd_status		err;

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = MOS_UR_WRITEREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, MOS_MAC);
	USETW(req.wLength, ETHER_ADDR_LEN);

	err = usbd_do_request(sc->mos_udev, &req, mac);

	if (err) {
		DPRINTF(("mos_writemac error"));
		return (-1);
	}

	return (0);
}

int
mos_write_mcast(struct mos_softc *sc, u_char *hashtbl)
{
	usb_device_request_t	req;
	usbd_status		err;

	if (usbd_is_dying(sc->mos_udev))
		return(0);

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = MOS_UR_WRITEREG;
	USETW(req.wValue, 0);
	USETW(req.wIndex, MOS_MCAST_TABLE);
	USETW(req.wLength, 8);

	err = usbd_do_request(sc->mos_udev, &req, hashtbl);

	if (err) {
		DPRINTF(("mos_reg_mcast error\n"));
		return(-1);
	}

	return(0);
}

int
mos_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct mos_softc	*sc = (void *)dev;
	uWord			val;
	int			i,res;

	if (usbd_is_dying(sc->mos_udev)) {
		DPRINTF(("mos: dying\n"));
		return (0);
	}

	USETW(val, 0);

	mos_lock_mii(sc);

	mos_reg_write_2(sc, MOS_PHY_DATA, 0);
	mos_reg_write_1(sc, MOS_PHY_CTL, (phy & MOS_PHYCTL_PHYADDR) |
	    MOS_PHYCTL_READ);
	mos_reg_write_1(sc, MOS_PHY_STS, (reg & MOS_PHYSTS_PHYREG) |
	    MOS_PHYSTS_PENDING);

	for (i = 0; i < MOS_TIMEOUT; i++) {
		if (mos_reg_read_1(sc, MOS_PHY_STS) & MOS_PHYSTS_READY)
			break;
	}
	if (i == MOS_TIMEOUT) {
		printf("%s: MII read timeout\n", sc->mos_dev.dv_xname);
	}

	res = mos_reg_read_2(sc, MOS_PHY_DATA);

	mos_unlock_mii(sc);

	return (res);
}

void
mos_miibus_writereg(struct device *dev, int phy, int reg, int val)
{
	struct mos_softc	*sc = (void *)dev;
	int			i;

	if (usbd_is_dying(sc->mos_udev))
		return;

	mos_lock_mii(sc);

	mos_reg_write_2(sc, MOS_PHY_DATA, val);
	mos_reg_write_1(sc, MOS_PHY_CTL, (phy & MOS_PHYCTL_PHYADDR) |
	    MOS_PHYCTL_WRITE);
	mos_reg_write_1(sc, MOS_PHY_STS, (reg & MOS_PHYSTS_PHYREG) |
	    MOS_PHYSTS_PENDING);

	for (i = 0; i < MOS_TIMEOUT; i++) {
		if (mos_reg_read_1(sc, MOS_PHY_STS) & MOS_PHYSTS_READY)
			break;
	}
	if (i == MOS_TIMEOUT) {
		printf("%s: MII write timeout\n", sc->mos_dev.dv_xname);
	}

	mos_unlock_mii(sc);

	return;
}

void
mos_miibus_statchg(struct device *dev)
{
	struct mos_softc	*sc = (void *)dev;
	struct mii_data		*mii = GET_MII(sc);
	int			val, err;

	mos_lock_mii(sc);

	/* disable RX, TX prior to changing FDX, SPEEDSEL */
	val = mos_reg_read_1(sc, MOS_CTL);
	val &= ~(MOS_CTL_TX_ENB | MOS_CTL_RX_ENB);
	mos_reg_write_1(sc, MOS_CTL, val);

	/* reset register which counts dropped frames */
	mos_reg_write_1(sc, MOS_FRAME_DROP_CNT, 0);

	if ((mii->mii_media_active & IFM_GMASK) == IFM_FDX)
		val |= MOS_CTL_FDX_ENB;
	else
		val &= ~(MOS_CTL_FDX_ENB);

	switch (IFM_SUBTYPE(mii->mii_media_active)) {
		case IFM_100_TX:
			val |=  MOS_CTL_SPEEDSEL;
			break;
		case IFM_10_T:
			val &= ~(MOS_CTL_SPEEDSEL);
			break;
	}

	/* re-enable TX, RX */
	val |= (MOS_CTL_TX_ENB | MOS_CTL_RX_ENB);
	err = mos_reg_write_1(sc, MOS_CTL, val);
	mos_unlock_mii(sc);

	if (err) {
		printf("%s: media change failed\n", sc->mos_dev.dv_xname);
		return;
	}
}

/*
 * Set media options.
 */
int
mos_ifmedia_upd(struct ifnet *ifp)
{
	struct mos_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	sc->mos_link = 0;
	if (mii->mii_instance) {
		struct mii_softc	*miisc;
		LIST_FOREACH(miisc, &mii->mii_phys, mii_list)
			mii_phy_reset(miisc);
	}
	mii_mediachg(mii);

	return (0);
}

/*
 * Report current media status.
 */
void
mos_ifmedia_sts(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct mos_softc	*sc = ifp->if_softc;
	struct mii_data		*mii = GET_MII(sc);

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

void
mos_iff(struct mos_softc *sc)
{
	struct ifnet		*ifp = GET_IFP(sc);
	struct arpcom		*ac = &sc->arpcom;
	struct ether_multi	*enm;
	struct ether_multistep	step;
	u_int32_t		h = 0;
	u_int8_t		rxmode, hashtbl[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };

	if (usbd_is_dying(sc->mos_udev))
		return;

	rxmode = mos_reg_read_1(sc, MOS_CTL);
	rxmode &= ~(MOS_CTL_ALLMULTI | MOS_CTL_RX_PROMISC);
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		rxmode |= MOS_CTL_ALLMULTI;
		if (ifp->if_flags & IFF_PROMISC)
			rxmode |= MOS_CTL_RX_PROMISC;
	} else {
		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;

			hashtbl[h / 8] |= 1 << (h % 8);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	/* 
	 * The datasheet claims broadcast frames were always accepted
	 * regardless of filter settings. But the hardware seems to
	 * filter broadcast frames, so pass them explicitly.
	 */
	h = ether_crc32_be(etherbroadcastaddr, ETHER_ADDR_LEN) >> 26;
	hashtbl[h / 8] |= 1 << (h % 8);

	mos_write_mcast(sc, (void *)&hashtbl);
	mos_reg_write_1(sc, MOS_CTL, rxmode);
}

void
mos_reset(struct mos_softc *sc)
{
	u_int8_t ctl;
	if (usbd_is_dying(sc->mos_udev))
		return;

	ctl = mos_reg_read_1(sc, MOS_CTL);
	ctl &= ~(MOS_CTL_RX_PROMISC | MOS_CTL_ALLMULTI | MOS_CTL_TX_ENB |
	    MOS_CTL_RX_ENB);
	/* Disable RX, TX, promiscuous and allmulticast mode */
	mos_reg_write_1(sc, MOS_CTL, ctl);

	/* Reset frame drop counter register to zero */
	mos_reg_write_1(sc, MOS_FRAME_DROP_CNT, 0);

	/* Wait a little while for the chip to get its brains in order. */
	DELAY(1000);
	return;
}

void
mos_chip_init(struct mos_softc *sc)
{
	int	i;

	/*
	 * Rev.C devices have a pause threshold register which needs to be set
	 * at startup.
	 */
	if (mos_reg_read_1(sc, MOS_PAUSE_TRHD) != -1) {
		for (i=0;i<MOS_PAUSE_REWRITES;i++)
			mos_reg_write_1(sc, MOS_PAUSE_TRHD, 0);
	}

	sc->mos_phyaddrs[0] = 1; sc->mos_phyaddrs[1] = 0xFF;
}

/*
 * Probe for a MCS7x30 chip.
 */
int
mos_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != MOS_CONFIG_NO)
		return(UMATCH_NONE);

	return (mos_lookup(uaa->vendor, uaa->product) != NULL ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
}

/*
 * Attach the interface. Allocate softc structures, do ifmedia
 * setup and ethernet/BPF attach.
 */
void
mos_attach(struct device *parent, struct device *self, void *aux)
{
	struct mos_softc	*sc = (struct mos_softc *)self;
	struct usb_attach_arg	*uaa = aux;
	struct ifnet		*ifp;
	struct usbd_device	*dev = uaa->device;
	usbd_status		err;
	usb_interface_descriptor_t 	*id;
	usb_endpoint_descriptor_t 	*ed;
	struct mii_data 	*mii;
	u_char			eaddr[ETHER_ADDR_LEN];
	int			i,s;

	sc->mos_udev = dev;
	sc->mos_unit = self->dv_unit;

	usb_init_task(&sc->mos_tick_task, mos_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->mos_mii_lock, "mosmii");
	usb_init_task(&sc->mos_stop_task, (void (*)(void *))mos_stop, sc,
	    USB_TASK_TYPE_GENERIC);

	err = usbd_device2interface_handle(dev, MOS_IFACE_IDX, &sc->mos_iface);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->mos_dev.dv_xname);
		return;
	}

	sc->mos_flags = mos_lookup(uaa->vendor, uaa->product)->mos_flags;

	id = usbd_get_interface_descriptor(sc->mos_iface);

	sc->mos_bufsz = MOS_BUFSZ;

	/* Find endpoints. */
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->mos_iface, i);
		if (!ed) {
			printf("%s: couldn't get ep %d\n",
			    sc->mos_dev.dv_xname, i);
			return;
		}
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->mos_ed[MOS_ENDPT_RX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK) {
			sc->mos_ed[MOS_ENDPT_TX] = ed->bEndpointAddress;
		} else if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
			   UE_GET_XFERTYPE(ed->bmAttributes) == UE_INTERRUPT) {
			sc->mos_ed[MOS_ENDPT_INTR] = ed->bEndpointAddress;
		}
	}

	s = splnet();

	printf("%s:", sc->mos_dev.dv_xname);

	if (sc->mos_flags & MCS7730)
		printf(" MCS7730");
	else if (sc->mos_flags & MCS7830)
		printf(" MCS7830");
	else if (sc->mos_flags & MCS7832)
		printf(" MCS7832");

	mos_chip_init(sc);

	/*
	 * Read MAC address, inform the world.
	 */
	err = mos_readmac(sc, (void*)&eaddr);
	if (err) {
		printf("%s: couldn't get MAC address\n",
		    sc->mos_dev.dv_xname);
		splx(s);
		return;
	}
	bcopy(eaddr, (char *)&sc->arpcom.ac_enaddr, ETHER_ADDR_LEN);
	printf(", address %s\n", ether_sprintf(eaddr));

	/* Initialize interface info.*/
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = mos_ioctl;
	ifp->if_start = mos_start;
	ifp->if_watchdog = mos_watchdog;
	strlcpy(ifp->if_xname, sc->mos_dev.dv_xname, IFNAMSIZ);

	ifp->if_capabilities = IFCAP_VLAN_MTU;

	/* Initialize MII/media info. */
	mii = GET_MII(sc);
	mii->mii_ifp = ifp;
	mii->mii_readreg = mos_miibus_readreg;
	mii->mii_writereg = mos_miibus_writereg;
	mii->mii_statchg = mos_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;

	ifmedia_init(&mii->mii_media, 0, mos_ifmedia_upd, mos_ifmedia_sts);
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);

	if (LIST_FIRST(&mii->mii_phys) == NULL) {
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);

	/* Attach the interface. */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->mos_stat_ch, mos_tick, sc);

	splx(s);
}

int
mos_detach(struct device *self, int flags)
{
	struct mos_softc	*sc = (struct mos_softc *)self;
	struct ifnet		*ifp = GET_IFP(sc);
	int			s;

	DPRINTFN(2,("%s: %s: enter\n", sc->mos_dev.dv_xname, __func__));

	if (timeout_initialized(&sc->mos_stat_ch))
		timeout_del(&sc->mos_stat_ch);

	if (sc->mos_ep[MOS_ENDPT_TX] != NULL)
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_TX]);
	if (sc->mos_ep[MOS_ENDPT_RX] != NULL)
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_RX]);
	if (sc->mos_ep[MOS_ENDPT_INTR] != NULL)
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_INTR]);

	/*
	 * Remove any pending tasks.  They cannot be executing because they run
	 * in the same thread as detach.
	 */
	usb_rem_task(sc->mos_udev, &sc->mos_tick_task);
	usb_rem_task(sc->mos_udev, &sc->mos_stop_task);
	s = splusb();

	if (--sc->mos_refcnt >= 0) {
		/* Wait for processes to go away */
		usb_detach_wait(&sc->mos_dev);
	}

	if (ifp->if_flags & IFF_RUNNING)
		mos_stop(sc);

	mii_detach(&sc->mos_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->mos_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->mos_ep[MOS_ENDPT_TX] != NULL ||
	    sc->mos_ep[MOS_ENDPT_RX] != NULL ||
	    sc->mos_ep[MOS_ENDPT_INTR] != NULL)
		printf("%s: detach has active endpoints\n",
		    sc->mos_dev.dv_xname);
#endif

	if (--sc->mos_refcnt >= 0) {
		/* Wait for processes to go away. */
		usb_detach_wait(&sc->mos_dev);
	}
	splx(s);

	return (0);
}

struct mbuf *
mos_newbuf(void)
{
	struct mbuf		*m;

	MGETHDR(m, M_DONTWAIT, MT_DATA);
	if (m == NULL)
		return (NULL);

	MCLGET(m, M_DONTWAIT);
	if (!(m->m_flags & M_EXT)) {
		m_freem(m);
		return (NULL);
	}

	m->m_len = m->m_pkthdr.len = MCLBYTES;
	m_adj(m, ETHER_ALIGN);

	return (m);
}

int
mos_rx_list_init(struct mos_softc *sc)
{
	struct mos_cdata	*cd;
	struct mos_chain	*c;
	int 			i;

	DPRINTF(("%s: %s: enter\n", sc->mos_dev.dv_xname, __func__));

	cd = &sc->mos_cdata;
	for (i = 0; i < MOS_RX_LIST_CNT; i++) {
		c = &cd->mos_rx_chain[i];
		c->mos_sc = sc;
		c->mos_idx = i;
		c->mos_mbuf = NULL;
		if (c->mos_xfer == NULL) {
			c->mos_xfer = usbd_alloc_xfer(sc->mos_udev);
			if (c->mos_xfer == NULL)
				return (ENOBUFS);
			c->mos_buf = usbd_alloc_buffer(c->mos_xfer,
			    sc->mos_bufsz);
			if (c->mos_buf == NULL) {
				usbd_free_xfer(c->mos_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
mos_tx_list_init(struct mos_softc *sc)
{
	struct mos_cdata	*cd;
	struct mos_chain	*c;
	int			i;

	DPRINTF(("%s: %s: enter\n", sc->mos_dev.dv_xname, __func__));

	cd = &sc->mos_cdata;
	for (i = 0; i < MOS_TX_LIST_CNT; i++) {
		c = &cd->mos_tx_chain[i];
		c->mos_sc = sc;
		c->mos_idx = i;
		c->mos_mbuf = NULL;
		if (c->mos_xfer == NULL) {
			c->mos_xfer = usbd_alloc_xfer(sc->mos_udev);
			if (c->mos_xfer == NULL)
				return (ENOBUFS);
			c->mos_buf = usbd_alloc_buffer(c->mos_xfer,
			    sc->mos_bufsz);
			if (c->mos_buf == NULL) {
				usbd_free_xfer(c->mos_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

/*
 * A frame has been uploaded: pass the resulting mbuf chain up to
 * the higher level protocols.
 */
void
mos_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct mos_chain	*c = (struct mos_chain *)priv;
	struct mos_softc	*sc = c->mos_sc;
	struct ifnet		*ifp = GET_IFP(sc);
	u_char			*buf = c->mos_buf;
	u_int8_t		rxstat;
	u_int32_t		total_len;
	u_int16_t		pktlen = 0;
	struct mbuf_list	ml = MBUF_LIST_INITIALIZER();
	struct mbuf		*m;
	int			s;

	DPRINTFN(10,("%s: %s: enter\n", sc->mos_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->mos_udev))
		return;

	if (!(ifp->if_flags & IFF_RUNNING))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (usbd_ratecheck(&sc->mos_rx_notice)) {
			printf("%s: usb errors on rx: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(status));
		}
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->mos_ep[MOS_ENDPT_RX]);
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	if (total_len <= 1)
		goto done;

	/* evaluate status byte at the end */
	pktlen = total_len - 1;
	rxstat = buf[pktlen] & MOS_RXSTS_MASK;

	if (rxstat != MOS_RXSTS_VALID) {
		DPRINTF(("%s: erroneous frame received: ", 
		    sc->mos_dev.dv_xname));
		if (rxstat & MOS_RXSTS_SHORT_FRAME)
			DPRINTF(("frame size less than 64 bytes\n"));
		if (rxstat & MOS_RXSTS_LARGE_FRAME)
			DPRINTF(("frame size larger than 1532 bytes\n"));
		if (rxstat & MOS_RXSTS_CRC_ERROR)
			DPRINTF(("CRC error\n"));
		if (rxstat & MOS_RXSTS_ALIGN_ERROR)
			DPRINTF(("alignment error\n"));
		ifp->if_ierrors++;
		goto done;
	}

	if ( pktlen < sizeof(struct ether_header) ) {
		ifp->if_ierrors++;
		goto done;
	}

	m = mos_newbuf();
	if (m == NULL) {
		ifp->if_ierrors++;
		goto done;
	}

	m->m_pkthdr.len = m->m_len = pktlen;

	memcpy(mtod(m, char *), buf, pktlen);

	ml_enqueue(&ml, m);

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

done:
	memset(c->mos_buf, 0, sc->mos_bufsz);

	/* Setup new transfer. */
	usbd_setup_xfer(xfer, sc->mos_ep[MOS_ENDPT_RX],
	    c, c->mos_buf, sc->mos_bufsz,
	    USBD_SHORT_XFER_OK | USBD_NO_COPY,
	    USBD_NO_TIMEOUT, mos_rxeof);
	usbd_transfer(xfer);

	DPRINTFN(10,("%s: %s: start rx\n", sc->mos_dev.dv_xname, __func__));

	return;
}

/*
 * A frame was downloaded to the chip. It's safe for us to clean up
 * the list buffers.
 */

void
mos_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct mos_softc	*sc;
	struct mos_chain	*c;
	struct ifnet		*ifp;
	int			s;

	c = priv;
	sc = c->mos_sc;
	ifp = &sc->arpcom.ac_if;

	if (usbd_is_dying(sc->mos_udev))
		return;

	s = splnet();

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->mos_dev.dv_xname,
		    usbd_errstr(status));
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->mos_ep[MOS_ENDPT_TX]);
		splx(s);
		return;
	}

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	m_freem(c->mos_mbuf);
	c->mos_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		mos_start(ifp);

	splx(s);
	return;
}

void
mos_tick(void *xsc)
{
	struct mos_softc *sc = xsc;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->mos_dev.dv_xname,
			__func__));

	if (usbd_is_dying(sc->mos_udev))
		return;

	/* Perform periodic stuff in process context */
	usb_add_task(sc->mos_udev, &sc->mos_tick_task);

}

void
mos_tick_task(void *xsc)
{
	int			s;
	struct mos_softc	*sc;
	struct ifnet		*ifp;
	struct mii_data		*mii;

	sc = xsc;

	if (sc == NULL)
		return;

	if (usbd_is_dying(sc->mos_udev))
		return;

	ifp = GET_IFP(sc);
	mii = GET_MII(sc);
	if (mii == NULL)
		return;

	s = splnet();

	mii_tick(mii);
	if (!sc->mos_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
		DPRINTF(("%s: %s: got link\n",
			 sc->mos_dev.dv_xname, __func__));
		sc->mos_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			mos_start(ifp);
	}

	timeout_add_sec(&sc->mos_stat_ch, 1);

	splx(s);
}

int
mos_encap(struct mos_softc *sc, struct mbuf *m, int idx)
{
	struct mos_chain	*c;
	usbd_status		err;
	int			length;

	c = &sc->mos_cdata.mos_tx_chain[idx];

	m_copydata(m, 0, m->m_pkthdr.len, c->mos_buf);
	length = m->m_pkthdr.len;

	c->mos_mbuf = m;

	usbd_setup_xfer(c->mos_xfer, sc->mos_ep[MOS_ENDPT_TX],
	    c, c->mos_buf, length, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
	    10000, mos_txeof);

	/* Transmit */
	err = usbd_transfer(c->mos_xfer);
	if (err != USBD_IN_PROGRESS) {
		mos_stop(sc);
		return(EIO);
	}

	sc->mos_cdata.mos_tx_cnt++;

	return(0);
}

void
mos_start(struct ifnet *ifp)
{
	struct mos_softc	*sc;
	struct mbuf		*m_head = NULL;

	sc = ifp->if_softc;

	if (!sc->mos_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (mos_encap(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}
	ifq_deq_commit(&ifp->if_snd, m_head);

	/*
	 * If there's a BPF listener, bounce a copy of this frame
	 * to him.
	 */
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/*
	 * Set a timeout in case the chip goes out to lunch.
	 */
	ifp->if_timer = 5;

	return;
}

void
mos_init(void *xsc)
{
	struct mos_softc	*sc = xsc;
	struct ifnet		*ifp = &sc->arpcom.ac_if;
	struct mos_chain	*c;
	usbd_status		err;
	u_int8_t		rxmode;
	int			i, s;

	s = splnet();

	/*
	 * Cancel pending I/O and free all RX/TX buffers.
	 */
	mos_reset(sc);

	/*
	 * Write MAC address
	 */
	mos_writemac(sc, sc->arpcom.ac_enaddr);

	/* Init RX ring. */
	if (mos_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->mos_dev.dv_xname);
		splx(s);
		return;
	}

	/* Init TX ring. */
	if (mos_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->mos_dev.dv_xname);
		splx(s);
		return;
	}

	/* Read and set transmitter IPG values */
	sc->mos_ipgs[0] = mos_reg_read_1(sc, MOS_IPG0);
	sc->mos_ipgs[1] = mos_reg_read_1(sc, MOS_IPG1);
	mos_reg_write_1(sc, MOS_IPG0, sc->mos_ipgs[0]);
	mos_reg_write_1(sc, MOS_IPG1, sc->mos_ipgs[1]);

	/* Program promiscuous mode and multicast filters. */
	mos_iff(sc);

	/* Enable receiver and transmitter, bridge controls speed/duplex mode */
	rxmode = mos_reg_read_1(sc, MOS_CTL);
	rxmode |= MOS_CTL_RX_ENB | MOS_CTL_TX_ENB | MOS_CTL_BS_ENB;
	rxmode &= ~(MOS_CTL_SLEEP);
	mos_reg_write_1(sc, MOS_CTL, rxmode);

	mii_mediachg(GET_MII(sc));

	/* Open RX and TX pipes. */
	err = usbd_open_pipe(sc->mos_iface, sc->mos_ed[MOS_ENDPT_RX],
	    USBD_EXCLUSIVE_USE, &sc->mos_ep[MOS_ENDPT_RX]);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		    sc->mos_dev.dv_xname, usbd_errstr(err));
		splx(s);
		return;
	}

	err = usbd_open_pipe(sc->mos_iface, sc->mos_ed[MOS_ENDPT_TX],
	    USBD_EXCLUSIVE_USE, &sc->mos_ep[MOS_ENDPT_TX]);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		    sc->mos_dev.dv_xname, usbd_errstr(err));
		splx(s);
		return;
	}

	/* Start up the receive pipe. */
	for (i = 0; i < MOS_RX_LIST_CNT; i++) {
		c = &sc->mos_cdata.mos_rx_chain[i];
		usbd_setup_xfer(c->mos_xfer, sc->mos_ep[MOS_ENDPT_RX],
		    c, c->mos_buf, sc->mos_bufsz,
		    USBD_SHORT_XFER_OK | USBD_NO_COPY,
		    USBD_NO_TIMEOUT, mos_rxeof);
		usbd_transfer(c->mos_xfer);
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->mos_stat_ch, 1);
	return;
}

int
mos_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct mos_softc	*sc = ifp->if_softc;
	struct ifreq		*ifr = (struct ifreq *)data;
	int			s, error = 0;

	s = splnet();

	switch(cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			mos_init(sc);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				mos_init(sc);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				mos_stop(sc);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->mos_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->arpcom, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			mos_iff(sc);
		error = 0;
	}

	splx(s);
	return(error);
}

void
mos_watchdog(struct ifnet *ifp)
{
	struct mos_softc	*sc;
	struct mos_chain	*c;
	usbd_status		stat;
	int			s;

	sc = ifp->if_softc;

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->mos_dev.dv_xname);

	s = splusb();
	c = &sc->mos_cdata.mos_tx_chain[0];
	usbd_get_xfer_status(c->mos_xfer, NULL, NULL, NULL, &stat);
	mos_txeof(c->mos_xfer, c, stat);

	if (!IFQ_IS_EMPTY(&ifp->if_snd))
		mos_start(ifp);
	splx(s);
}


/*
 * Stop the adapter and free any mbufs allocated to the
 * RX and TX lists.
 */
void
mos_stop(struct mos_softc *sc)
{
	usbd_status		err;
	struct ifnet		*ifp;
	int			i;

	mos_reset(sc);

	ifp = &sc->arpcom.ac_if;
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	timeout_del(&sc->mos_stat_ch);

	/* Stop transfers. */
	if (sc->mos_ep[MOS_ENDPT_RX] != NULL) {
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_RX]);
		err = usbd_close_pipe(sc->mos_ep[MOS_ENDPT_RX]);
		if (err) {
			printf("%s: close rx pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
		sc->mos_ep[MOS_ENDPT_RX] = NULL;
	}

	if (sc->mos_ep[MOS_ENDPT_TX] != NULL) {
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_TX]);
		err = usbd_close_pipe(sc->mos_ep[MOS_ENDPT_TX]);
		if (err) {
			printf("%s: close tx pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
		sc->mos_ep[MOS_ENDPT_TX] = NULL;
	}

	if (sc->mos_ep[MOS_ENDPT_INTR] != NULL) {
		usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_INTR]);
		err = usbd_close_pipe(sc->mos_ep[MOS_ENDPT_INTR]);
		if (err) {
			printf("%s: close intr pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
		sc->mos_ep[MOS_ENDPT_INTR] = NULL;
	}

	/* Free RX resources. */
	for (i = 0; i < MOS_RX_LIST_CNT; i++) {
		if (sc->mos_cdata.mos_rx_chain[i].mos_mbuf != NULL) {
			m_freem(sc->mos_cdata.mos_rx_chain[i].mos_mbuf);
			sc->mos_cdata.mos_rx_chain[i].mos_mbuf = NULL;
		}
		if (sc->mos_cdata.mos_rx_chain[i].mos_xfer != NULL) {
			usbd_free_xfer(sc->mos_cdata.mos_rx_chain[i].mos_xfer);
			sc->mos_cdata.mos_rx_chain[i].mos_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < MOS_TX_LIST_CNT; i++) {
		if (sc->mos_cdata.mos_tx_chain[i].mos_mbuf != NULL) {
			m_freem(sc->mos_cdata.mos_tx_chain[i].mos_mbuf);
			sc->mos_cdata.mos_tx_chain[i].mos_mbuf = NULL;
		}
		if (sc->mos_cdata.mos_tx_chain[i].mos_xfer != NULL) {
			usbd_free_xfer(sc->mos_cdata.mos_tx_chain[i].mos_xfer);
			sc->mos_cdata.mos_tx_chain[i].mos_xfer = NULL;
		}
	}

	sc->mos_link = 0;
}

@


1.37
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.36 2016/04/13 11:03:37 mpi Exp $	*/
a1024 1
	ifp->if_opackets++;
@


1.36
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.35 2015/11/25 03:10:00 dlg Exp $	*/
d610 1
a610 1
	if (!uaa->iface)
a636 7

	err = usbd_set_config_no(dev, MOS_CONFIG_NO, 1);
	if (err) {
		printf("%s: getting interface handle failed\n",
		    sc->mos_dev.dv_xname);
		return;
	}
@


1.35
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.34 2015/11/24 17:11:40 mpi Exp $	*/
a717 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.34
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.33 2015/11/20 03:35:23 dlg Exp $	*/
d1026 1
a1026 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1137 1
a1137 1
	if (ifp->if_flags & IFF_OACTIVE)
d1146 1
a1146 1
		ifp->if_flags |= IFF_OACTIVE;
d1160 1
a1160 1
	ifp->if_flags |= IFF_OACTIVE;
d1253 1
a1253 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1347 2
a1348 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.33
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.32 2015/10/25 12:11:56 mpi Exp $	*/
a87 1
#include <net/if_dl.h>
@


1.32
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.31 2015/06/24 09:40:54 mpi Exp $	*/
d1141 1
a1141 1
	IFQ_POLL(&ifp->if_snd, m_head);
d1146 1
d1150 1
a1150 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.31
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.30 2015/05/02 10:44:29 jsg Exp $	*/
a1265 1
	struct ifaddr		*ifa = (struct ifaddr *)data;
a1274 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->arpcom, ifa);
@


1.30
log
@add missing splx calls
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.29 2015/04/10 08:41:43 mpi Exp $	*/
a964 1
	ifp->if_ipackets++;
@


1.29
log
@Convert remaining USB Ethernet adapter to if_input().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.28 2015/03/14 03:38:49 jsg Exp $	*/
d705 1
@


1.28
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.27 2014/12/22 02:28:52 tedu Exp $	*/
d905 1
a964 1
	m->m_pkthdr.rcvif = ifp;
d969 2
a970 1
	/* push the packet up */
d972 1
a972 7
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	ether_input_mbuf(ifp, m);

@


1.27
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.26 2014/07/13 15:52:49 mpi Exp $	*/
a97 1
#include <dev/mii/mii.h>
@


1.26
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.25 2014/07/12 07:59:23 mpi Exp $	*/
a1281 1
#ifdef INET
a1283 1
#endif
@


1.25
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.24 2014/01/21 09:57:33 brad Exp $	*/
a94 1
#ifdef INET
a95 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a96 1
#endif
@


1.24
log
@Always fill in the broadcast address so as to handle broadcast packets if
the interface is put into all multicast mode.

ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.23 2014/01/18 15:18:01 stsp Exp $	*/
a135 1
int mos_activate(struct device *, int);
d142 1
a142 5
	sizeof(struct mos_softc),
	mos_match,
	mos_attach,
	mos_detach,
	mos_activate,
a809 16
	return (0);
}


int
mos_activate(struct device *self, int act)
{
	struct mos_softc *sc = (struct mos_softc *)self;

	DPRINTFN(2,("%s: %s: enter\n", sc->mos_dev.dv_xname, __func__));

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->mos_udev);
		break;
	}
@


1.23
log
@Make mos(4) pass received broadcast frames explicitly if not in promiscuous
mode. Fixes a problem with initiating connections to a mos(4) interface.
Reported by Petr Hoffmann on bugs@@.
ok sthen
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.22 2013/11/15 10:17:39 pirofti Exp $	*/
a560 7
		/* 
		 * The datasheet claims broadcast frames were always accepted
		 * regardless of filter settings. But the hardware seems to
		 * filter broadcast frames, so pass them explicitly.
		 */
		h = ether_crc32_be(etherbroadcastaddr, ETHER_ADDR_LEN) >> 26;
		hashtbl[h / 8] |= 1 << (h % 8);
d562 8
@


1.22
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.21 2013/08/07 01:06:41 bluhm Exp $	*/
d561 7
@


1.21
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.20 2013/04/15 09:23:01 mglocker Exp $	*/
d1381 1
a1381 5
		err = usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_RX]);
		if (err) {
			printf("%s: abort rx pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
d1391 1
a1391 5
		err = usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_TX]);
		if (err) {
			printf("%s: abort tx pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
d1401 1
a1401 5
		err = usbd_abort_pipe(sc->mos_ep[MOS_ENDPT_INTR]);
		if (err) {
			printf("%s: abort intr pipe failed: %s\n",
			    sc->mos_dev.dv_xname, usbd_errstr(err));
		}
@


1.20
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.19 2013/03/28 03:58:03 tedu Exp $	*/
a97 1
#include <netinet/in_var.h>
@


1.19
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.18 2012/12/05 23:20:21 deraadt Exp $	*/
d155 2
a156 2
void mos_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void mos_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d631 1
a631 1
	usbd_device_handle	dev = uaa->device;
d915 1
a915 1
mos_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1020 1
a1020 1
mos_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.18
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.17 2012/10/22 03:23:19 brad Exp $	*/
a80 1
#include <sys/proc.h>
@


1.17
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

Tested by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.16 2012/02/28 08:58:30 jsg Exp $	*/
a65 2

#include <sys/cdefs.h>
@


1.16
log
@add support for the MCS7832 which is apparently a low pin count
version of the MCS7830 with no software visible changes besides
a new product id.

from brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.15 2011/07/03 15:47:17 matthew Exp $	*/
d183 1
a183 1
void mos_setmulti(struct mos_softc *);
d534 1
a534 1
mos_setmulti(struct mos_softc *sc)
d536 2
a537 1
	struct ifnet		*ifp;
d541 1
a541 2
	u_int8_t		rxmode;
	u_int8_t		hashtbl[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
a545 2
	ifp = GET_IFP(sc);

d547 2
d550 2
a551 2
	if (ifp->if_flags & IFF_ALLMULTI || ifp->if_flags & IFF_PROMISC) {
allmulti:
d553 9
a561 4
		mos_reg_write_1(sc, MOS_CTL, rxmode);
		return;
	} else
		rxmode &= ~MOS_CTL_ALLMULTI;
d563 2
a564 10
	/* now program new ones */
	ETHER_FIRST_MULTI(step, &sc->arpcom, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
		   ETHER_ADDR_LEN) != 0)
			goto allmulti;

		h = ether_crc32_be(enm->enm_addrlo, ETHER_ADDR_LEN) >> 26;
		hashtbl[h / 8] |= 1 << (h % 8);
		ETHER_NEXT_MULTI(step, enm);
a566 1
	ifp->if_flags &= ~IFF_ALLMULTI;
a568 1
	return;
d1239 3
a1245 7

	/* If we want promiscuous mode, set the allframes bit. */
	if (ifp->if_flags & IFF_PROMISC)
		rxmode |= MOS_CTL_RX_PROMISC;

	/* XXX: broadcast mode? */

a1247 3
	/* Load the multicast filter. */
	mos_setmulti(sc);

a1293 2
	struct mii_data		*mii;
	u_int8_t		rxmode;
a1308 7
	case SIOCSIFMTU:
		if (ifr->ifr_mtu < ETHERMIN || ifr->ifr_mtu > ifp->if_hardmtu)
			error = EINVAL;
		else if (ifp->if_mtu != ifr->ifr_mtu)
			ifp->if_mtu = ifr->ifr_mtu;
		break;

d1311 3
a1313 15
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC &&
			    !(sc->mos_if_flags & IFF_PROMISC)) {
				rxmode = mos_reg_read_1(sc, MOS_CTL);
				rxmode |= MOS_CTL_RX_PROMISC;
				mos_reg_write_1(sc, MOS_CTL, rxmode);
				mos_setmulti(sc);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC) &&
			    !(sc->mos_if_flags & IFF_PROMISC)) {
				rxmode = mos_reg_read_1(sc, MOS_CTL);
				rxmode |= MOS_CTL_RX_PROMISC;
				mos_reg_write_1(sc, MOS_CTL, rxmode);
				mos_setmulti(sc);
			} else if (!(ifp->if_flags & IFF_RUNNING))
a1318 17
		sc->mos_if_flags = ifp->if_flags;
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->arpcom) :
		    ether_delmulti(ifr, &sc->arpcom);

		if (error == ENETRESET) {
			/*
			 * Multicast list has changed; set the hardware
			 * filter accordingly.
			 */
			if (ifp->if_flags & IFF_RUNNING)
				mos_setmulti(sc);
			error = 0;
		}
d1320 1
d1323 1
a1323 2
		mii = GET_MII(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
d1328 6
@


1.15
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.14 2011/02/21 19:48:41 stsp Exp $	*/
d70 1
a70 1
 * Moschip MCS7730/MCS7830 USB to Ethernet controller 
d132 1
d700 1
a700 1
	if (sc->mos_flags & MCS7730) {
d702 1
a702 1
	} else if (sc->mos_flags & MCS7830) {
d704 2
a705 1
	}
@


1.14
log
@Make mos(4) set IFF_BROADCAST in if_flags.
ok jsg kevlo claudio; committing with miod's permission (src is soft-locked)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.13 2011/01/25 20:03:35 jakemsr Exp $	*/
a825 3
	case DVACT_ACTIVATE:
		break;

@


1.13
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.12 2010/12/06 04:41:39 jakemsr Exp $	*/
d722 1
a722 1
	ifp->if_flags = IFF_SIMPLEX | IFF_MULTICAST;
@


1.12
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.11 2010/10/27 17:51:11 jakemsr Exp $	*/
a755 3

	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->mos_udev,
			   &sc->mos_dev);
a812 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->mos_udev,
			   &sc->mos_dev);
@


1.11
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.10 2010/10/23 16:14:07 jakemsr Exp $	*/
d211 2
a212 2
	if (sc->mos_dying)
		return (0);
d239 1
a239 1
	if (sc->mos_dying)
d267 1
a267 1
	if (sc->mos_dying)
d295 1
a295 1
	if (sc->mos_dying)
d320 1
a320 1
	if (sc->mos_dying)
d345 1
a345 1
	if (sc->mos_dying)
d370 1
a370 1
	if (sc->mos_dying)
d396 1
a396 1
	if (sc->mos_dying) {
d432 1
a432 1
	if (sc->mos_dying)
d542 1
a542 1
	if (sc->mos_dying)
d579 1
a579 1
	if (sc->mos_dying)
d646 1
a668 1
	sc->mos_udev = dev;
a754 1
	sc->mos_attached = 1;
a769 3
	if (!sc->mos_attached)
		return (0);

a810 2
	sc->mos_attached = 0;

d836 1
a836 1
		sc->mos_dying = 1;
d944 1
a944 1
	if (sc->mos_dying)
d1046 1
a1046 1
	if (sc->mos_dying)
d1090 1
a1090 1
	if (sc->mos_dying)
d1111 1
a1111 1
	if (sc->mos_dying)
@


1.10
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.9 2010/10/23 15:42:09 jakemsr Exp $	*/
d802 4
a805 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.9
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.8 2010/09/24 08:33:58 yuo Exp $	*/
d774 2
a775 1
	timeout_del(&sc->mos_stat_ch);
@


1.8
log
@remove dying flag in detach() function.
The dying flag will be set in activate()/DEACTIVATE.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.7 2009/10/13 19:33:17 pirofti Exp $	*/
d655 2
a656 1
	usb_init_task(&sc->mos_tick_task, mos_tick_task, sc);
d658 2
a659 1
	usb_init_task(&sc->mos_stop_task, (void (*)(void *))mos_stop, sc);
@


1.7
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.6 2008/11/22 09:46:12 deraadt Exp $	*/
a772 2

	sc->mos_dying = 1;
@


1.6
log
@some cosmetics and changes based on reading newer docs, from the original
author Johann Christian Rode
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.5 2008/11/12 23:42:40 sthen Exp $	*/
d139 1
a139 1
int mos_activate(struct device *, enum devact);
d828 1
a828 1
mos_activate(struct device *self, enum devact act)
@


1.5
log
@KNF (whitespace fixes). ok brad@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.4 2008/11/06 02:32:29 brad Exp $	*/
d224 1
a224 1
		return (0);
d252 1
a252 1
		return(0);
d280 1
a280 1
		return(-1);
d296 1
a296 1
		return(0);
d308 1
a308 1
		return(-1);
d311 1
a311 1
	return(0);
d333 1
a333 1
		return(-1);
d336 1
a336 1
	return(0);
d358 1
a358 1
		return(-1);
d361 1
a361 1
	return(0);
d463 3
d467 6
d487 2
d490 2
d588 3
a598 1
	uByte	val;
d605 1
a605 2
	val = mos_reg_read_1(sc, MOS_MAC0);
	if (val) {
d607 1
a607 1
			mos_reg_write_1(sc, MOS_CTL, 0);
d671 1
a671 2
	sc->mos_bufsz = (sc->mos_udev->speed == USB_SPEED_HIGH) ?
		    MOS_MAX_BUFSZ : MOS_MIN_BUFSZ;
d939 1
d970 1
a970 1
	/* status byte at the end */
d972 16
d989 1
a989 3
	/* 0x20 seems to indicate that the packet is OK */
	if ( ( pktlen < sizeof(struct ether_header) )
	    || ( buf[pktlen] != 0x20 ) ) {
d1131 1
a1131 1
			   mos_start(ifp);
d1248 3
a1250 1
	/* Set transmitter IPG values */
@


1.4
log
@Set the IFCAP_VLAN_MTU capabilities flag so these interfaces are allowed
to transmit full sized VLAN tagged frames.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_mos.c,v 1.3 2008/11/02 23:50:48 jsg Exp $	*/
d548 1
a548 1
			   ETHER_ADDR_LEN) != 0)
d611 1
a611 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
a702 1

@


1.3
log
@rcs tags
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d715 2
@


1.2
log
@Remove second commented out call to ether_ifdetach() in
mos_detach().
@
text
@d1 2
@


1.1
log
@Driver for MOSCHIP MCS7x30 usb ethernet chips by Johann Christian Rode
@
text
@a759 2
	// ether_ifdetach(ifp);

@

