head	1.33;
access;
symbols
	OPENBSD_6_1:1.33.0.10
	OPENBSD_6_1_BASE:1.33
	OPENBSD_6_0:1.33.0.12
	OPENBSD_6_0_BASE:1.33
	OPENBSD_5_9:1.33.0.6
	OPENBSD_5_9_BASE:1.33
	OPENBSD_5_8:1.33.0.8
	OPENBSD_5_8_BASE:1.33
	OPENBSD_5_7:1.33.0.2
	OPENBSD_5_7_BASE:1.33
	OPENBSD_5_6:1.33.0.4
	OPENBSD_5_6_BASE:1.33
	OPENBSD_5_5:1.28.0.4
	OPENBSD_5_5_BASE:1.28
	OPENBSD_5_4:1.26.0.2
	OPENBSD_5_4_BASE:1.26
	OPENBSD_5_3:1.24.0.10
	OPENBSD_5_3_BASE:1.24
	OPENBSD_5_2:1.24.0.8
	OPENBSD_5_2_BASE:1.24
	OPENBSD_5_1_BASE:1.24
	OPENBSD_5_1:1.24.0.6
	OPENBSD_5_0:1.24.0.4
	OPENBSD_5_0_BASE:1.24
	OPENBSD_4_9:1.24.0.2
	OPENBSD_4_9_BASE:1.24
	OPENBSD_4_8:1.22.0.4
	OPENBSD_4_8_BASE:1.22
	OPENBSD_4_7:1.22.0.2
	OPENBSD_4_7_BASE:1.22
	OPENBSD_4_6:1.20.0.8
	OPENBSD_4_6_BASE:1.20
	OPENBSD_4_5:1.20.0.4
	OPENBSD_4_5_BASE:1.20
	OPENBSD_4_4:1.20.0.2
	OPENBSD_4_4_BASE:1.20
	OPENBSD_4_3:1.19.0.4
	OPENBSD_4_3_BASE:1.19
	OPENBSD_4_2:1.19.0.2
	OPENBSD_4_2_BASE:1.19
	OPENBSD_4_1:1.15.0.14
	OPENBSD_4_1_BASE:1.15
	OPENBSD_4_0:1.15.0.16
	OPENBSD_4_0_BASE:1.15
	OPENBSD_3_9:1.15.0.12
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.15.0.10
	OPENBSD_3_8_BASE:1.15
	OPENBSD_3_7:1.15.0.6
	OPENBSD_3_7_BASE:1.15
	OPENBSD_3_6:1.15.0.8
	OPENBSD_3_6_BASE:1.15
	SMP_SYNC_A:1.15
	SMP_SYNC_B:1.15
	OPENBSD_3_5:1.15.0.4
	OPENBSD_3_5_BASE:1.15
	OPENBSD_3_4:1.15.0.2
	OPENBSD_3_4_BASE:1.15
	UBC_SYNC_A:1.14
	OPENBSD_3_3:1.14.0.4
	OPENBSD_3_3_BASE:1.14
	OPENBSD_3_2:1.14.0.2
	OPENBSD_3_2_BASE:1.14
	OPENBSD_3_1:1.11.0.6
	OPENBSD_3_1_BASE:1.11
	UBC_SYNC_B:1.14
	UBC:1.11.0.4
	UBC_BASE:1.11
	OPENBSD_3_0:1.11.0.2
	OPENBSD_3_0_BASE:1.11
	OPENBSD_2_9_BASE:1.10
	OPENBSD_2_9:1.10.0.2
	OPENBSD_2_8:1.9.0.2
	OPENBSD_2_8_BASE:1.9
	OPENBSD_2_7:1.8.0.2
	OPENBSD_2_7_BASE:1.8
	SMP:1.5.0.2
	SMP_BASE:1.5
	kame_19991208:1.5
	OPENBSD_2_6:1.4.0.2
	OPENBSD_2_6_BASE:1.4;
locks; strict;
comment	@ * @;


1.33
date	2014.05.18.17.10.27;	author mpi;	state Exp;
branches;
next	1.32;

1.32
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.31;

1.31
date	2014.04.29.21.51.18;	author mpi;	state Exp;
branches;
next	1.30;

1.30
date	2014.04.27.14.48.10;	author mpi;	state Exp;
branches;
next	1.29;

1.29
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.28;

1.28
date	2013.11.01.17.29.02;	author mpi;	state Exp;
branches;
next	1.27;

1.27
date	2013.11.01.12.00.54;	author mpi;	state Exp;
branches;
next	1.26;

1.26
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.25;

1.25
date	2013.04.15.09.23.02;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.23;

1.23
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.22;

1.22
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.21;

1.21
date	2009.10.13.19.33.19;	author pirofti;	state Exp;
branches;
next	1.20;

1.20
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.19;

1.19
date	2007.06.15.11.41.48;	author mbalmer;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.17;

1.17
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.16;

1.16
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.15;

1.15
date	2003.07.08.13.19.09;	author nate;	state Exp;
branches;
next	1.14;

1.14
date	2002.07.25.02.18.10;	author nate;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.07.18.29.18;	author nate;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	1.11;

1.11
date	2001.06.12.19.11.59;	author mickey;	state Exp;
branches
	1.11.4.1;
next	1.10;

1.10
date	2000.11.08.18.10.38;	author aaron;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.04.11.44.23;	author fgsch;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.14.22.50.26;	author aaron;	state Exp;
branches;
next	1.7;

1.7
date	2000.03.28.19.37.49;	author aaron;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.08.39.46;	author aaron;	state Exp;
branches;
next	1.5;

1.5
date	99.11.07.21.30.19;	author fgsch;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.09.27.18.03.55;	author fgsch;	state Exp;
branches;
next	1.3;

1.3
date	99.08.27.09.00.29;	author fgsch;	state Exp;
branches;
next	1.2;

1.2
date	99.08.16.22.08.49;	author fgsch;	state Exp;
branches;
next	1.1;

1.1
date	99.08.13.05.28.04;	author fgsch;	state Exp;
branches;
next	;

1.5.2.1
date	2001.05.14.22.26.22;	author niklas;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2001.07.04.10.43.54;	author niklas;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.03.28.00.38.32;	author niklas;	state Exp;
branches;
next	1.5.2.4;

1.5.2.4
date	2004.02.19.10.56.34;	author niklas;	state Exp;
branches;
next	;

1.11.4.1
date	2002.06.11.03.42.30;	author art;	state Exp;
branches;
next	1.11.4.2;

1.11.4.2
date	2002.10.29.00.33.32;	author art;	state Exp;
branches;
next	;


desc
@@


1.33
log
@Do not pass an xfer pointer to the timeout routine checking for root hub
status changes because it might be freed when detaching the root uhub(4).

Also do not reschedule a timeout if the pipe is being aborted.

Finally do not add more code to retrieve the 'bInterval' value of the
root hub endpoint descriptor since this value is hardcoded in the uhci(4)
driver.
@
text
@/*	$OpenBSD: uhcivar.h,v 1.32 2014/05/16 18:17:03 mpi Exp $ */
/*	$NetBSD: uhcivar.h,v 1.36 2002/12/31 00:39:11 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhcivar.h,v 1.14 1999/11/17 22:33:42 n_hibma Exp $	*/

/*
 * Copyright (c) 1998 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net) at
 * Carlstedt Research & Technology.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * To avoid having 1024 TDs for each isochronous transfer we introduce
 * a virtual frame list.  Every UHCI_VFRAMELIST_COUNT entries in the real
 * frame list points to a non-active TD.  These, in turn, form the
 * starts of the virtual frame list.  This also has the advantage that it
 * simplifies linking in/out of TDs/QHs in the schedule.
 * Furthermore, initially each of the inactive TDs point to an inactive
 * QH that forms the start of the interrupt traffic for that slot.
 * Each of these QHs point to the same QH that is the start of control
 * traffic.  This QH points at another QH which is the start of the
 * bulk traffic.
 *
 * UHCI_VFRAMELIST_COUNT should be a power of 2 and <= UHCI_FRAMELIST_COUNT.
 */
#define UHCI_VFRAMELIST_COUNT 128

struct uhci_soft_qh;
struct uhci_soft_td;

typedef union {
	struct uhci_soft_qh *sqh;
	struct uhci_soft_td *std;
} uhci_soft_td_qh_t;

/*
 * An interrupt info struct contains the information needed to
 * execute a requested routine when the controller generates an
 * interrupt.  Since we cannot know which transfer generated
 * the interrupt all structs are linked together so they can be
 * searched at interrupt time.
 */
struct uhci_xfer {
	struct usbd_xfer xfer;
	LIST_ENTRY(uhci_xfer) inext;
	struct uhci_soft_td *stdstart;
	struct uhci_soft_td *stdend;
	int curframe;
#ifdef DIAGNOSTIC
	int isdone;
#endif
};

/*
 * Extra information that we need for a TD.
 */
struct uhci_soft_td {
	struct uhci_td td;		/* The real TD, must be first */
	uhci_soft_td_qh_t link; 	/* soft version of the td_link field */
	uhci_physaddr_t physaddr;	/* TD's physical address. */
};
/*
 * Make the size such that it is a multiple of UHCI_TD_ALIGN.  This way
 * we can pack a number of soft TD together and have the real TD well
 * aligned.
 * NOTE: Minimum size is 32 bytes.
 */
#define UHCI_STD_SIZE ((sizeof (struct uhci_soft_td) + UHCI_TD_ALIGN - 1) / UHCI_TD_ALIGN * UHCI_TD_ALIGN)
#define UHCI_STD_CHUNK 128 /*(PAGE_SIZE / UHCI_TD_SIZE)*/

/*
 * Extra information that we need for a QH.
 */
struct uhci_soft_qh {
	struct uhci_qh qh;		/* The real QH, must be first */
	struct uhci_soft_qh *hlink;	/* soft version of qh_hlink */
	struct uhci_soft_td *elink;	/* soft version of qh_elink */
	uhci_physaddr_t physaddr;	/* QH's physical address. */
	int pos;			/* Timeslot position */
};
/* See comment about UHCI_STD_SIZE. */
#define UHCI_SQH_SIZE ((sizeof (struct uhci_soft_qh) + UHCI_QH_ALIGN - 1) / UHCI_QH_ALIGN * UHCI_QH_ALIGN)
#define UHCI_SQH_CHUNK 128 /*(PAGE_SIZE / UHCI_QH_SIZE)*/

/*
 * Information about an entry in the virtual frame list.
 */
struct uhci_vframe {
	struct uhci_soft_td *htd;	/* pointer to dummy TD */
	struct uhci_soft_td *etd;	/* pointer to last TD */
	struct uhci_soft_qh *hqh;	/* pointer to dummy QH */
	struct uhci_soft_qh *eqh;	/* pointer to last QH */
	u_int bandwidth;		/* max bandwidth used by this frame */
};

struct uhci_softc {
	struct usbd_bus sc_bus;		/* base device */
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
	bus_size_t sc_size;

	uhci_physaddr_t *sc_pframes;
	struct usb_dma sc_dma;
	struct uhci_vframe sc_vframes[UHCI_VFRAMELIST_COUNT];

	struct uhci_soft_qh *sc_lctl_start; /* dummy QH for low speed control */
	struct uhci_soft_qh *sc_lctl_end; /* last control QH */
	struct uhci_soft_qh *sc_hctl_start;/* dummy QH for high speed control */
	struct uhci_soft_qh *sc_hctl_end; /* last control QH */
	struct uhci_soft_qh *sc_bulk_start; /* dummy QH for bulk */
	struct uhci_soft_qh *sc_bulk_end; /* last bulk transfer */
	struct uhci_soft_qh *sc_last_qh; /* dummy QH at the end */
	u_int32_t sc_loops;		/* number of QHs that wants looping */

	struct uhci_soft_td *sc_freetds; /* TD free list */
	struct uhci_soft_qh *sc_freeqhs; /* QH free list */

	u_int8_t sc_conf;		/* device configuration */

	u_int8_t sc_saved_sof;
	u_int16_t sc_saved_frnum;

	char sc_softwake;

	char sc_isreset;
	char sc_suspend;

	LIST_HEAD(, uhci_xfer) sc_intrhead;

	/* Info for the root hub interrupt "pipe". */
	struct usbd_xfer	*sc_intrxfer;
	struct timeout		 sc_root_intr;

	char sc_vendor[32];		/* vendor string for root hub */
	int sc_id_vendor;		/* vendor ID for root hub */
};

usbd_status	uhci_init(struct uhci_softc *);
usbd_status	uhci_run(struct uhci_softc *, int run);
int		uhci_intr(void *);
int		uhci_detach(struct device *, int);
int		uhci_activate(struct device *, int);
@


1.32
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.31 2014/04/29 21:51:18 mpi Exp $ */
d154 2
a155 3
	int sc_ival;			/* time between root hub intrs */
	struct usbd_xfer *sc_intr_xfer;	/* root hub interrupt transfer */
	struct timeout sc_poll_handle;
@


1.31
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.30 2014/04/27 14:48:10 mpi Exp $ */
a159 2

	struct device *sc_child;		/* /dev/usb# device */
d165 1
a165 1
int		uhci_detach(struct uhci_softc *, int);
@


1.30
log
@Start de-obfuscating the HC drivers.

Since pipe methods have an xfer argument, always use it to get acces to
various data structure (pipe, bus, device) instead of having a different
way to get a pointer to these descriptors in every function.

Also kill the {E,U}XFER() macro and use a consistent name accross all the
methods for {e,u}hci_xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.29 2014/03/25 20:27:37 mpi Exp $ */
a139 2

	SIMPLEQ_HEAD(, usbd_xfer) sc_free_xfers; /* free xfers */
@


1.29
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.28 2013/11/01 17:29:02 mpi Exp $ */
a75 2

#define UXFER(xfer) ((struct uhci_xfer *)(xfer))
@


1.28
log
@Reduce the differences with ehci(4)'s transfer decriptors.  This is a
first step to merge the code of our controllers that deal with usbd
transfers.

Tested with miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.27 2013/11/01 12:00:54 mpi Exp $ */
a144 1
	u_int8_t sc_addr;		/* device address */
@


1.27
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.26 2013/05/30 16:15:02 deraadt Exp $ */
d66 3
a68 3
struct uhci_intr_info {
	struct uhci_softc *sc;
	struct usbd_xfer *xfer;
d71 1
a71 1
	LIST_ENTRY(uhci_intr_info) list;
a76 6
struct uhci_xfer {
	struct usbd_xfer xfer;
	struct uhci_intr_info iinfo;
	int curframe;
};

d156 1
a156 1
	LIST_HEAD(, uhci_intr_info) sc_intrhead;
@


1.26
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.25 2013/04/15 09:23:02 mglocker Exp $ */
a79 1
	struct usb_task	abort_task;
@


1.25
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.24 2010/12/14 16:13:16 jakemsr Exp $ */
a171 2

	void *sc_shutdownhook;		/* cookie from shutdown hook */
@


1.24
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.23 2010/09/07 16:21:46 deraadt Exp $ */
d51 2
a52 2
typedef struct uhci_soft_qh uhci_soft_qh_t;
typedef struct uhci_soft_td uhci_soft_td_t;
d66 1
a66 1
typedef struct uhci_intr_info {
d68 3
a70 3
	usbd_xfer_handle xfer;
	uhci_soft_td_t *stdstart;
	uhci_soft_td_t *stdend;
d75 1
a75 1
} uhci_intr_info_t;
d79 1
a79 1
	uhci_intr_info_t iinfo;
d90 1
a90 1
	uhci_td_t td;			/* The real TD, must be first */
d107 3
a109 3
	uhci_qh_t qh;			/* The real QH, must be first */
	uhci_soft_qh_t *hlink;		/* soft version of qh_hlink */
	uhci_soft_td_t *elink;		/* soft version of qh_elink */
d121 4
a124 4
	uhci_soft_td_t *htd;		/* pointer to dummy TD */
	uhci_soft_td_t *etd;		/* pointer to last TD */
	uhci_soft_qh_t *hqh;		/* pointer to dummy QH */
	uhci_soft_qh_t *eqh;		/* pointer to last QH */
d128 1
a128 1
typedef struct uhci_softc {
d135 1
a135 1
	usb_dma_t sc_dma;
d138 7
a144 7
	uhci_soft_qh_t *sc_lctl_start;	/* dummy QH for low speed control */
	uhci_soft_qh_t *sc_lctl_end;	/* last control QH */
	uhci_soft_qh_t *sc_hctl_start;	/* dummy QH for high speed control */
	uhci_soft_qh_t *sc_hctl_end;	/* last control QH */
	uhci_soft_qh_t *sc_bulk_start;	/* dummy QH for bulk */
	uhci_soft_qh_t *sc_bulk_end;	/* last bulk transfer */
	uhci_soft_qh_t *sc_last_qh;	/* dummy QH at the end */
d147 2
a148 2
	uhci_soft_td_t *sc_freetds;	/* TD free list */
	uhci_soft_qh_t *sc_freeqhs;	/* QH free list */
d167 1
a167 1
	usbd_xfer_handle sc_intr_xfer;	/* root hub interrupt transfer */
d176 1
a176 1
} uhci_softc_t;
d178 2
a179 2
usbd_status	uhci_init(uhci_softc_t *);
usbd_status	uhci_run(uhci_softc_t *, int run);
d181 1
a181 1
int		uhci_detach(uhci_softc_t *, int);
@


1.23
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.22 2009/11/04 19:14:10 kettenis Exp $ */
a161 1
	char sc_dying;
@


1.22
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.21 2009/10/13 19:33:19 pirofti Exp $ */
a173 1
	void *sc_powerhook;		/* cookie from power hook */
@


1.21
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.20 2008/06/26 05:42:18 ray Exp $ */
a157 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a158 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
@


1.20
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.19 2007/06/15 11:41:48 mbalmer Exp $ */
d186 1
a186 1
int		uhci_activate(struct device *, enum devact);
@


1.19
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.18 2007/06/12 16:26:36 mbalmer Exp $ */
a20 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.18
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.17 2007/06/10 10:15:35 mbalmer Exp $ */
d165 1
a165 1
#ifdef USB_USE_SOFTINTR
d167 1
a167 1
#endif /* USB_USE_SOFTINTR */
@


1.17
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.16 2007/06/04 10:34:04 mbalmer Exp $ */
d186 1
a186 1
	device_ptr_t sc_child;		/* /dev/usb# device */
d193 1
a193 1
int		uhci_activate(device_ptr_t, enum devact);
@


1.16
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.15 2003/07/08 13:19:09 nate Exp $ */
d178 1
a178 1
	usb_callout_t sc_poll_handle;
@


1.15
log
@Sync USB code with NetBSD.
This includes numerous fixes and paves the way for usb 2.0 support.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.14 2002/07/25 02:18:10 nate Exp $ */
a191 1
#if defined(__NetBSD__) || defined(__OpenBSD__)
a193 2
#endif

@


1.14
log
@get rid of trailing whitespace
@
text
@d1 2
a2 2
/*	$OpenBSD: uhcivar.h,v 1.13 2002/05/07 18:29:18 nate Exp $ */
/*	$NetBSD: uhcivar.h,v 1.32 2000/08/13 16:18:09 augustss Exp $	*/
d87 1
d165 4
d180 1
a180 1
	char sc_vendor[16];		/* vendor string for root hub */
@


1.13
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.11 2001/06/12 19:11:59 mickey Exp $ */
d45 2
a46 2
 * frame list points to a non-active TD.  These, in turn, form the 
 * starts of the virtual frame list.  This also has the advantage that it 
d100 1
a100 1
/* 
@


1.12
log
@Sync ulpt driver with NetBSD
@
text
@d2 1
a2 1
/*	$NetBSD: uhcivar.h,v 1.33 2002/02/11 11:41:30 augustss Exp $	*/
a86 1
	struct usb_task	abort_task;
a163 1
	char sc_softwake;
@


1.11
log
@interrupts cannot happen before
*hci cannot receive interrupts before it has been initialized.
this was changed to accomodate the pcibios strategy change back
in pre-2.9 times since *hci_init enables interrupts at it's end
and thus unmapped pci interrupt hangs the machine in the
endless loop trying to deliver it (and no hci handler to ack it).
this new way we disable interrupts by hands before we map 'em
on pci and thus ensure that they will not crash an uninitialized
*hci which, in turn, will run right after the interrupt map/establish
and by the time it enables *hci interrupts all gonna be just fine.
please allow us to end this stretched remark for cvs
is getting a power outage in less than 20 minutes.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhcivar.h,v 1.10 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: uhcivar.h,v 1.32 2000/08/13 16:18:09 augustss Exp $	*/
d87 1
d165 1
@


1.11.4.1
log
@Sync UBC branch to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.11 2001/06/12 19:11:59 mickey Exp $ */
@


1.11.4.2
log
@sync to -current
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.11.4.1 2002/06/11 03:42:30 art Exp $ */
d45 2
a46 2
 * frame list points to a non-active TD.  These, in turn, form the
 * starts of the virtual frame list.  This also has the advantage that it
d100 1
a100 1
/*
@


1.10
log
@Sync with NetBSD. Too many changes to mention. For now I have skipped
umass.c and ukbd.c as the diffs are a bit hairier.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.9 2000/07/04 11:44:23 fgsch Exp $ */
d185 1
@


1.9
log
@sync with NetBSD... well almost. someone w/ the hw should check umass.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhcivar.h,v 1.8 2000/04/14 22:50:26 aaron Exp $ */
/*	$NetBSD: uhcivar.h,v 1.28 2000/04/06 23:44:21 augustss Exp $	*/
d144 4
a147 2
	uhci_soft_qh_t *sc_ctl_start;	/* dummy QH for control */
	uhci_soft_qh_t *sc_ctl_end;	/* last control QH */
d150 2
d184 2
a185 2
usbd_status	uhci_init __P((uhci_softc_t *));
int		uhci_intr __P((void *));
d187 2
a188 2
int		uhci_detach __P((uhci_softc_t *, int));
int		uhci_activate __P((device_ptr_t, enum devact));
@


1.8
log
@Sync with NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.7 2000/03/28 19:37:49 aaron Exp $ */
d10 1
a10 1
 * by Lennart Augustsson (augustss@@carlstedt.se) at
d138 1
@


1.7
log
@Much cleaner sync with NetBSD. Some #if defined() magic has been sent in the
form of a diff to augustss@@netbsd.org so that future syncs will be very easy.
This commit also adds support for ADMtek AN986 "Pegasus" based USB Ethernet,
CATC USB-EL1210A based USB Ethernet, and USB Printers (all untested).
@
text
@d1 2
a2 2
/*	$OpenBSD$ */
/*	$NetBSD: uhcivar.h,v 1.27 2000/03/25 18:02:33 augustss Exp $	*/
d45 1
a45 1
 * frame list points to a non-active TD.  These, in turn, which form the 
d47 1
a47 1
 * simplifies linking in/out TD/QH in the schedule.
d51 2
a52 1
 * traffic.
d165 2
a166 2
	/* Info for the root hub interrupt channel. */
	int sc_ival;			/* time between root hug intrs */
d176 1
a176 1
	device_ptr_t sc_child;		/* /dev/usb device */
@


1.6
log
@Sync with NetBSD.
@
text
@d1 3
a3 2
/*	$OpenBSD: uhcivar.h,v 1.5 1999/11/07 21:30:19 fgsch Exp $	*/
/*	$NetBSD: uhcivar.h,v 1.23 2000/02/22 16:03:44 augustss Exp $	*/
a77 3
#if defined(__FreeBSD__)
	struct callout_handle timeout_handle;
#endif /* defined(__FreeBSD__) */
d83 8
a116 2
	uhci_intr_info_t *intr_info;	/* Who to call on completion. */
/* XXX should try to shrink with 4 bytes to fit into 32 bytes */
d165 3
a167 6
	int sc_ival;			/* time between root hub intrs */
	usbd_xfer_handle sc_has_timo;	/* root hub interrupt transfer */

	char sc_vflock;			/* for lock virtual frame list */
#define UHCI_HAS_LOCK 1
#define UHCI_WANT_LOCK 2
d184 1
@


1.5
log
@sync with NetBSD.
@
text
@d1 2
a2 2
/*	$OpenBSD$	*/
/*	$NetBSD: uhcivar.h,v 1.16 1999/10/13 08:10:56 augustss Exp $	*/
d73 1
a73 1
	usbd_request_handle reqh;
d95 1
a95 1
 * we can pack a number of soft TD together and have the real TS well
d119 1
a119 1
 * Information about an entry in the virtial frame list.
d143 4
a146 2
	uhci_soft_td_t *sc_freetds;
	uhci_soft_qh_t *sc_freeqhs;
d151 3
a154 1

d156 1
a156 1
	usbd_request_handle sc_has_timo;
d161 2
a162 1
	int sc_ival;
d164 1
a164 1
	char sc_vflock;
d168 2
a169 2
	char sc_vendor[16];
	int sc_id_vendor;
d171 4
a174 2
	void *sc_powerhook;
	device_ptr_t sc_child;
d179 1
d182 1
a182 1

@


1.5.2.1
log
@merge in approximately 2.9 into SMP branch
@
text
@d1 2
a2 3
/*	$OpenBSD: uhcivar.h,v 1.10 2000/11/08 18:10:38 aaron Exp $ */
/*	$NetBSD: uhcivar.h,v 1.32 2000/08/13 16:18:09 augustss Exp $	*/
/*	$FreeBSD: src/sys/dev/usb/uhcivar.h,v 1.14 1999/11/17 22:33:42 n_hibma Exp $	*/
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net) at
d44 1
a44 1
 * frame list points to a non-active TD.  These, in turn, form the 
d46 1
a46 1
 * simplifies linking in/out of TDs/QHs in the schedule.
d50 1
a50 2
 * traffic.  This QH points at another QH which is the start of the
 * bulk traffic.
d73 1
a73 1
	usbd_xfer_handle xfer;
d77 3
a84 8
struct uhci_xfer {
	struct usbd_xfer xfer;
	uhci_intr_info_t iinfo;
	int curframe;
};

#define UXFER(xfer) ((struct uhci_xfer *)(xfer))

d95 1
a95 1
 * we can pack a number of soft TD together and have the real TD well
d111 2
d119 1
a119 1
 * Information about an entry in the virtual frame list.
a132 1
	bus_size_t sc_size;
d138 2
a139 4
	uhci_soft_qh_t *sc_lctl_start;	/* dummy QH for low speed control */
	uhci_soft_qh_t *sc_lctl_end;	/* last control QH */
	uhci_soft_qh_t *sc_hctl_start;	/* dummy QH for high speed control */
	uhci_soft_qh_t *sc_hctl_end;	/* last control QH */
a141 5
	uhci_soft_qh_t *sc_last_qh;	/* dummy QH at the end */
	u_int32_t sc_loops;		/* number of QHs that wants looping */

	uhci_soft_td_t *sc_freetds;	/* TD free list */
	uhci_soft_qh_t *sc_freeqhs;	/* QH free list */
d143 2
a144 1
	SIMPLEQ_HEAD(, usbd_xfer) sc_free_xfers; /* free xfers */
d149 1
a149 2
	u_int8_t sc_saved_sof;
	u_int16_t sc_saved_frnum;
a150 1
	char sc_isreset;
d152 1
a152 1
	char sc_dying;
d156 2
a157 4
	/* Info for the root hub interrupt "pipe". */
	int sc_ival;			/* time between root hub intrs */
	usbd_xfer_handle sc_intr_xfer;	/* root hub interrupt transfer */
	usb_callout_t sc_poll_handle;
d159 3
a161 2
	char sc_vendor[16];		/* vendor string for root hub */
	int sc_id_vendor;		/* vendor ID for root hub */
d163 2
a164 2
	void *sc_powerhook;		/* cookie from power hook */
	void *sc_shutdownhook;		/* cookie from shutdown hook */
d166 2
a167 1
	device_ptr_t sc_child;		/* /dev/usb# device */
d170 4
a173 6
usbd_status	uhci_init(uhci_softc_t *);
int		uhci_intr(void *);
#if defined(__NetBSD__) || defined(__OpenBSD__)
int		uhci_detach(uhci_softc_t *, int);
int		uhci_activate(device_ptr_t, enum devact);
#endif
@


1.5.2.2
log
@Merge in -current from two days ago in the SMP branch.
As usual with merges, they do not indicate progress, so do not hold
your breath for working SMP, and do not mail me and ask about the
state of it.  It has not changed.  There is work ongoing, but very, very
slowly.  The commit is done in parts as to not lock up the tree in too
big chunks at a time.
@
text
@d1 1
a1 1
/*	$OpenBSD: uhcivar.h,v 1.5.2.1 2001/05/14 22:26:22 niklas Exp $ */
a184 1
usbd_status	uhci_run(uhci_softc_t *, int run);
@


1.5.2.3
log
@Sync the SMP branch with 3.3
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d45 2
a46 2
 * frame list points to a non-active TD.  These, in turn, form the
 * starts of the virtual frame list.  This also has the advantage that it
d100 1
a100 1
/*
@


1.5.2.4
log
@Merge of current from two weeks agointo the SMP branch
@
text
@d2 1
a2 1
/*	$NetBSD: uhcivar.h,v 1.36 2002/12/31 00:39:11 augustss Exp $	*/
a86 1
	struct usb_task	abort_task;
a163 4
#ifdef USB_USE_SOFTINTR
	char sc_softwake;
#endif /* USB_USE_SOFTINTR */

d175 1
a175 1
	char sc_vendor[32];		/* vendor string for root hub */
@


1.4
log
@Sync with NetBSD.
@
text
@d2 1
a2 1
/*	$NetBSD: uhcivar.h,v 1.14 1999/09/15 10:25:31 augustss Exp $	*/
a132 5
#if defined(__NetBSD__) || defined(__OpenBSD__)
	void *sc_ih;			/* interrupt vectoring */

	/* XXX should keep track of all DMA memory */
#endif /* defined(__FreeBSD__) */
d172 1
a172 1
int		uhci_detach __P((device_ptr_t, int));
a173 9

#ifdef USB_DEBUG
#define DPRINTF(x)	if (uhcidebug) printf x
#define DPRINTFN(n,x)	if (uhcidebug>(n)) printf x
extern int uhcidebug;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif
@


1.3
log
@Sync with NetBSD;
Make sure not to call tsleep() from suspend/resume routine.
Move more of the transfer completion processing to HC independent code.
Fix some problems with transfer abort & timeout.
Merge the soft_{td,qh} with the real {td,qh}.  This saves time and space.
@
text
@d2 1
a2 1
/*	$NetBSD: uhcivar.h,v 1.12 1999/08/22 23:41:00 augustss Exp $	*/
a135 1
	bus_dma_tag_t sc_dmatag;	/* DMA tag */
a158 1
	int sc_intrs;
d170 3
d177 2
a178 3
#if 0
void		uhci_reset __P((void *));
#endif
@


1.2
log
@Sync with NetBSD. Mostly FreeBSD related changes.
Diffs sent to augustsson.
@
text
@d1 2
a2 2
/*	$OpenBSD: uhcivar.h,v 1.1 1999/08/13 05:28:04 fgsch Exp $	*/
/*	$NetBSD: uhcivar.h,v 1.7 1999/06/26 08:30:18 augustss Exp $	*/
d59 5
d89 3
a91 2
	uhci_td_t *td;			/* The real TD */
	uhci_physaddr_t physaddr;	/* and its physical address. */
d93 8
a100 1
#define UHCI_TD_CHUNK 128 /*(PAGE_SIZE / UHCI_TD_SIZE)*/
d106 4
a109 2
	uhci_qh_t *qh;			/* The real QH */
	uhci_physaddr_t physaddr;	/* and its physical address. */
d112 1
d114 3
a116 8
#define UHCI_QH_CHUNK 128 /*(PAGE_SIZE / UHCI_QH_SIZE)*/

/* Only used for buffer free list. */
struct uhci_buffer {
	struct uhci_buffer *next;
};
#define UHCI_BUFFER_SIZE 64
#define UHCI_BUFFER_CHUNK 64 	/*(PAGE_SIZE / UHCI_BUFFER_SIZE)*/
a150 1
	struct uhci_buffer *sc_freebuffers;
a168 4

#if defined(__NetBSD__) || defined(__OpenBSD__)
	usb_dma_t *sc_mallocs;
#endif
@


1.1
log
@From NetBSD; USB support.
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
d120 2
a123 2
	bus_space_tag_t iot;
	bus_space_handle_t ioh;
a126 3
#elif defined(__FreeBSD__)
	int		sc_iobase;
	int		unit;
@

