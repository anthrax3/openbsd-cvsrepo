head	1.79;
access;
symbols
	OPENBSD_6_0:1.78.0.4
	OPENBSD_6_0_BASE:1.78
	OPENBSD_5_9:1.77.0.2
	OPENBSD_5_9_BASE:1.77
	OPENBSD_5_8:1.72.0.4
	OPENBSD_5_8_BASE:1.72
	OPENBSD_5_7:1.68.0.2
	OPENBSD_5_7_BASE:1.68
	OPENBSD_5_6:1.67.0.4
	OPENBSD_5_6_BASE:1.67
	OPENBSD_5_5:1.65.0.4
	OPENBSD_5_5_BASE:1.65
	OPENBSD_5_4:1.62.0.2
	OPENBSD_5_4_BASE:1.62
	OPENBSD_5_3:1.60.0.2
	OPENBSD_5_3_BASE:1.60
	OPENBSD_5_2:1.58.0.4
	OPENBSD_5_2_BASE:1.58
	OPENBSD_5_1_BASE:1.58
	OPENBSD_5_1:1.58.0.2
	OPENBSD_5_0:1.57.0.2
	OPENBSD_5_0_BASE:1.57
	OPENBSD_4_9:1.51.0.2
	OPENBSD_4_9_BASE:1.51
	OPENBSD_4_8:1.45.0.4
	OPENBSD_4_8_BASE:1.45
	OPENBSD_4_7:1.45.0.2
	OPENBSD_4_7_BASE:1.45
	OPENBSD_4_6:1.43.0.6
	OPENBSD_4_6_BASE:1.43
	OPENBSD_4_5:1.43.0.2
	OPENBSD_4_5_BASE:1.43
	OPENBSD_4_4:1.40.0.4
	OPENBSD_4_4_BASE:1.40
	OPENBSD_4_3:1.40.0.2
	OPENBSD_4_3_BASE:1.40
	OPENBSD_4_2:1.34.0.2
	OPENBSD_4_2_BASE:1.34
	OPENBSD_4_1:1.20.0.2
	OPENBSD_4_1_BASE:1.20
	OPENBSD_4_0:1.18.0.4
	OPENBSD_4_0_BASE:1.18
	OPENBSD_3_9:1.15.0.2
	OPENBSD_3_9_BASE:1.15
	OPENBSD_3_8:1.13.0.2
	OPENBSD_3_8_BASE:1.13
	OPENBSD_3_7:1.9.0.2
	OPENBSD_3_7_BASE:1.9;
locks; strict;
comment	@ * @;


1.79
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.78;
commitid	VyLWTsbepAOk7VQM;

1.78
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.77;
commitid	gWZDkudwxydTq8x4;

1.77
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.76;
commitid	B0kwmVGiD5DVx4kv;

1.76
date	2015.11.24.17.11.40;	author mpi;	state Exp;
branches;
next	1.75;
commitid	5gdEnqVoJuTuwdTu;

1.75
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.74;
commitid	FuSD2mFDJWATHIDx;

1.74
date	2015.11.20.03.35.23;	author dlg;	state Exp;
branches;
next	1.73;
commitid	eYnPulzvLjDImPCa;

1.73
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.72;
commitid	pwYnMC1gOKohmeGw;

1.72
date	2015.06.24.09.40.54;	author mpi;	state Exp;
branches;
next	1.71;
commitid	MVWrtktB46JRxFWT;

1.71
date	2015.06.19.20.39.34;	author uaa;	state Exp;
branches;
next	1.70;
commitid	FNybUU20eX9u5b1s;

1.70
date	2015.03.23.08.41.52;	author mpi;	state Exp;
branches;
next	1.69;
commitid	9wULl4eNLt7FuCbq;

1.69
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.68;
commitid	p4LJxGKbi0BU2cG6;

1.68
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.67;
commitid	yM2VFFhpDTeFQlve;

1.67
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.66;
commitid	Pclvgy2Z4XV9hveD;

1.66
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.65;
commitid	b0VSac5dnnsxcDao;

1.65
date	2014.01.22.04.13.22;	author sasano;	state Exp;
branches;
next	1.64;

1.64
date	2013.11.15.10.17.39;	author pirofti;	state Exp;
branches;
next	1.63;

1.63
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.62;

1.62
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.61;

1.61
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.60;

1.60
date	2013.01.29.02.06.55;	author brad;	state Exp;
branches;
next	1.59;

1.59
date	2012.12.05.23.20.21;	author deraadt;	state Exp;
branches;
next	1.58;

1.58
date	2011.09.04.18.34.02;	author jsg;	state Exp;
branches;
next	1.57;

1.57
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.56;

1.56
date	2011.06.23.16.31.16;	author deraadt;	state Exp;
branches;
next	1.55;

1.55
date	2011.03.31.17.06.25;	author mk;	state Exp;
branches;
next	1.54;

1.54
date	2011.03.20.17.58.26;	author mk;	state Exp;
branches;
next	1.53;

1.53
date	2011.03.16.22.39.13;	author jasper;	state Exp;
branches;
next	1.52;

1.52
date	2011.03.16.07.39.22;	author jsg;	state Exp;
branches;
next	1.51;

1.51
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.49;

1.49
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.48;

1.48
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.47;

1.47
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.46;

1.46
date	2010.08.27.07.08.22;	author deraadt;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.22.22.13.51;	author jsg;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.43;

1.43
date	2008.11.28.02.44.18;	author brad;	state Exp;
branches;
next	1.42;

1.42
date	2008.10.02.20.21.14;	author brad;	state Exp;
branches;
next	1.41;

1.41
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.40;

1.40
date	2007.11.23.15.43.02;	author mbalmer;	state Exp;
branches;
next	1.39;

1.39
date	2007.11.01.17.10.34;	author deraadt;	state Exp;
branches;
next	1.38;

1.38
date	2007.11.01.11.43.28;	author deraadt;	state Exp;
branches;
next	1.37;

1.37
date	2007.11.01.00.51.36;	author deraadt;	state Exp;
branches;
next	1.36;

1.36
date	2007.10.20.01.05.46;	author beck;	state Exp;
branches;
next	1.35;

1.35
date	2007.10.11.18.33.14;	author deraadt;	state Exp;
branches;
next	1.34;

1.34
date	2007.06.14.10.11.15;	author mbalmer;	state Exp;
branches;
next	1.33;

1.33
date	2007.06.13.11.15.29;	author mbalmer;	state Exp;
branches;
next	1.32;

1.32
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.11.05.42.53;	author mbalmer;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.29;

1.29
date	2007.06.10.10.53.48;	author mbalmer;	state Exp;
branches;
next	1.28;

1.28
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.27;

1.27
date	2007.06.09.12.22.53;	author mbalmer;	state Exp;
branches;
next	1.26;

1.26
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.27.04.00.25;	author jsg;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.21.05.40.27;	author jsg;	state Exp;
branches;
next	1.23;

1.23
date	2007.05.21.05.18.56;	author jsg;	state Exp;
branches;
next	1.22;

1.22
date	2007.05.06.04.08.47;	author krw;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.16.09.13.41;	author jsg;	state Exp;
branches;
next	1.20;

1.20
date	2007.02.18.14.44.44;	author jsg;	state Exp;
branches;
next	1.19;

1.19
date	2006.09.29.08.43.07;	author jsg;	state Exp;
branches;
next	1.18;

1.18
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.17;

1.17
date	2006.03.25.22.41.47;	author djm;	state Exp;
branches;
next	1.16;

1.16
date	2006.03.07.04.41.19;	author krw;	state Exp;
branches;
next	1.15;

1.15
date	2006.02.06.17.29.11;	author jmc;	state Exp;
branches;
next	1.14;

1.14
date	2006.01.29.03.22.52;	author brad;	state Exp;
branches;
next	1.13;

1.13
date	2005.08.01.05.36.48;	author brad;	state Exp;
branches;
next	1.12;

1.12
date	2005.07.02.22.21.12;	author brad;	state Exp;
branches;
next	1.11;

1.11
date	2005.07.02.22.17.58;	author brad;	state Exp;
branches;
next	1.10;

1.10
date	2005.06.08.17.03.02;	author henning;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.03.22.45.52;	author brad;	state Exp;
branches;
next	1.8;

1.8
date	2004.12.30.07.43.09;	author dlg;	state Exp;
branches;
next	1.7;

1.7
date	2004.12.26.03.48.19;	author jsg;	state Exp;
branches;
next	1.6;

1.6
date	2004.12.26.03.29.26;	author jsg;	state Exp;
branches;
next	1.5;

1.5
date	2004.12.03.14.23.18;	author jsg;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.03.13.21.04;	author jsg;	state Exp;
branches;
next	1.3;

1.3
date	2004.11.11.22.46.30;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2004.10.05.14.12.56;	author deraadt;	state Exp;
branches;
next	1.1;

1.1
date	2004.10.05.02.01.18;	author jsg;	state Exp;
branches;
next	;


desc
@@


1.79
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@/*	$OpenBSD: if_udav.c,v 1.78 2016/04/13 11:03:37 mpi Exp $ */
/*	$NetBSD: if_udav.c,v 1.3 2004/04/23 17:25:25 itojun Exp $	*/
/*	$nabe: if_udav.c,v 1.3 2003/08/21 16:57:19 nabe Exp $	*/
/*
 * Copyright (c) 2003
 *     Shingo WATANABE <nabe@@nabechan.org>.  All rights reserved.
 * Copyright (c) 2014
 *     Takayoshi SASANO <uaa@@uaa.org.uk> (RD9700 support)
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. Neither the name of the author nor the names of any co-contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 *
 */

/*
 * DM9601(DAVICOM USB to Ethernet MAC Controller with Integrated 10/100 PHY)
 * The spec can be found at the following url.
 *  http://www.meworks.net/userfile/24247/DM9601-DS-P03-102908.pdf
 */

/*
 * TODO:
 *	Interrupt Endpoint support
 *	External PHYs
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/rwlock.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>

#include <sys/device.h>

#include <net/if.h>
#include <net/if_media.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <dev/mii/miivar.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_udavreg.h>

int udav_match(struct device *, void *, void *);
void udav_attach(struct device *, struct device *, void *);
int udav_detach(struct device *, int);

struct cfdriver udav_cd = {
	NULL, "udav", DV_IFNET
};

const struct cfattach udav_ca = {
	sizeof(struct udav_softc), udav_match, udav_attach, udav_detach
};

int udav_openpipes(struct udav_softc *);
int udav_rx_list_init(struct udav_softc *);
int udav_tx_list_init(struct udav_softc *);
int udav_newbuf(struct udav_softc *, struct udav_chain *, struct mbuf *);
void udav_start(struct ifnet *);
int udav_send(struct udav_softc *, struct mbuf *, int);
void udav_txeof(struct usbd_xfer *, void *, usbd_status);
void udav_rxeof(struct usbd_xfer *, void *, usbd_status);
void udav_tick(void *);
void udav_tick_task(void *);
int udav_ioctl(struct ifnet *, u_long, caddr_t);
void udav_stop_task(struct udav_softc *);
void udav_stop(struct ifnet *, int);
void udav_watchdog(struct ifnet *);
int udav_ifmedia_change(struct ifnet *);
void udav_ifmedia_status(struct ifnet *, struct ifmediareq *);
void udav_lock_mii(struct udav_softc *);
void udav_unlock_mii(struct udav_softc *);
int udav_miibus_readreg(struct device *, int, int);
void udav_miibus_writereg(struct device *, int, int, int);
void udav_miibus_statchg(struct device *);
int udav_init(struct ifnet *);
void udav_iff(struct udav_softc *);
void udav_reset(struct udav_softc *);

int udav_csr_read(struct udav_softc *, int, void *, int);
int udav_csr_write(struct udav_softc *, int, void *, int);
int udav_csr_read1(struct udav_softc *, int);
int udav_csr_write1(struct udav_softc *, int, unsigned char);

#if 0
int udav_mem_read(struct udav_softc *, int, void *, int);
int udav_mem_write(struct udav_softc *, int, void *, int);
int udav_mem_write1(struct udav_softc *, int, unsigned char);
#endif

/* Macros */
#ifdef UDAV_DEBUG
#define DPRINTF(x)	do { if (udavdebug) printf x; } while(0)
#define DPRINTFN(n,x)	do { if (udavdebug >= (n)) printf x; } while(0)
int udavdebug = 0;
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

#define	UDAV_SETBIT(sc, reg, x)	\
	udav_csr_write1(sc, reg, udav_csr_read1(sc, reg) | (x))

#define	UDAV_CLRBIT(sc, reg, x)	\
	udav_csr_write1(sc, reg, udav_csr_read1(sc, reg) & ~(x))

static const struct udav_type {
	struct usb_devno udav_dev;
	u_int16_t udav_flags;
#define UDAV_EXT_PHY	0x0001
#define UDAV_RD9700	0x0002
} udav_devs [] = {
	{{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_FETHER_USB_TXC }, 0 },
	{{ USB_VENDOR_DAVICOM, USB_PRODUCT_DAVICOM_DM9601 }, 0 },
	{{ USB_VENDOR_DAVICOM, USB_PRODUCT_DAVICOM_WK668 }, 0 },
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_DM9601 }, 0 },
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ST268 }, 0 },
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ZT6688 }, 0 },
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ADM8515 }, 0 },
	{{ USB_VENDOR_UNKNOWN4, USB_PRODUCT_UNKNOWN4_DM9601 }, 0 },
	{{ USB_VENDOR_UNKNOWN6, USB_PRODUCT_UNKNOWN6_DM9601 }, 0 },
	{{ USB_VENDOR_UNKNOWN4, USB_PRODUCT_UNKNOWN4_RD9700 }, UDAV_RD9700 },
};
#define udav_lookup(v, p) ((struct udav_type *)usb_lookup(udav_devs, v, p))


/* Probe */
int
udav_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != 1)
		return (UMATCH_NONE);

	return (udav_lookup(uaa->vendor, uaa->product) != NULL ?
		UMATCH_VENDOR_PRODUCT_CONF_IFACE : UMATCH_NONE);
}

/* Attach */
void
udav_attach(struct device *parent, struct device *self, void *aux)
{
	struct udav_softc *sc = (struct udav_softc *)self;
	struct usb_attach_arg *uaa = aux;
	struct usbd_device *dev = uaa->device;
	struct usbd_interface *iface = uaa->iface;
	usbd_status err;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	char *devname = sc->sc_dev.dv_xname;
	struct ifnet *ifp;
	struct mii_data *mii;
	u_char eaddr[ETHER_ADDR_LEN];
	int i, s;

	printf("%s: ", devname);

	sc->sc_udev = dev;

	usb_init_task(&sc->sc_tick_task, udav_tick_task, sc,
	    USB_TASK_TYPE_GENERIC);
	rw_init(&sc->sc_mii_lock, "udavmii");
	usb_init_task(&sc->sc_stop_task, (void (*)(void *)) udav_stop_task, sc,
	    USB_TASK_TYPE_GENERIC);

	sc->sc_ctl_iface = iface;
	sc->sc_flags = udav_lookup(uaa->vendor, uaa->product)->udav_flags;

	/* get interface descriptor */
	id = usbd_get_interface_descriptor(sc->sc_ctl_iface);

	/* find endpoints */
	sc->sc_bulkin_no = sc->sc_bulkout_no = sc->sc_intrin_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_ctl_iface, i);
		if (ed == NULL) {
			printf("couldn't get endpoint %d\n", i);
			goto bad;
		}
		if ((ed->bmAttributes & UE_XFERTYPE) == UE_BULK &&
		    UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
			sc->sc_bulkin_no = ed->bEndpointAddress; /* RX */
		else if ((ed->bmAttributes & UE_XFERTYPE) == UE_BULK &&
			 UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT)
			sc->sc_bulkout_no = ed->bEndpointAddress; /* TX */
		else if ((ed->bmAttributes & UE_XFERTYPE) == UE_INTERRUPT &&
			 UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN)
			sc->sc_intrin_no = ed->bEndpointAddress; /* Status */
	}

	if (sc->sc_bulkin_no == -1 || sc->sc_bulkout_no == -1 ||
	    sc->sc_intrin_no == -1) {
		printf("missing endpoint\n");
		goto bad;
	}

	s = splnet();

	/* reset the adapter */
	udav_reset(sc);

	/* Get Ethernet Address */
	err = udav_csr_read(sc, UDAV_PAR, (void *)eaddr, ETHER_ADDR_LEN);
	if (err) {
		printf("read MAC address failed\n");
		splx(s);
		goto bad;
	}

	/* Print Ethernet Address */
	printf("address %s\n", ether_sprintf(eaddr));

        bcopy(eaddr, (char *)&sc->sc_ac.ac_enaddr, ETHER_ADDR_LEN);

	/* initialize interface information */
	ifp = GET_IFP(sc);
	ifp->if_softc = sc;
	strlcpy(ifp->if_xname, devname, IFNAMSIZ);
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_start = udav_start;
	ifp->if_ioctl = udav_ioctl;
	ifp->if_watchdog = udav_watchdog;

	/*
	 * Do ifmedia setup.
	 */
	mii = &sc->sc_mii;
	mii->mii_ifp = ifp;
	mii->mii_readreg = udav_miibus_readreg;
	mii->mii_writereg = udav_miibus_writereg;
	mii->mii_statchg = udav_miibus_statchg;
	mii->mii_flags = MIIF_AUTOTSLEEP;
	ifmedia_init(&mii->mii_media, 0,
		     udav_ifmedia_change, udav_ifmedia_status);
	if (sc->sc_flags & UDAV_RD9700) {
		/* no MII-PHY */
		ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE, 0, NULL);
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
	} else {
		mii_attach(self, mii, 0xffffffff, 
			   MII_PHY_ANY, MII_OFFSET_ANY, 0);
		if (LIST_FIRST(&mii->mii_phys) == NULL) {
			ifmedia_add(&mii->mii_media, IFM_ETHER | IFM_NONE,
				    0, NULL);
			ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_NONE);
		} else
			ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);
	}

	/* attach the interface */
	if_attach(ifp);
	ether_ifattach(ifp);

	timeout_set(&sc->sc_stat_ch, udav_tick, sc);

	splx(s);

	return;

 bad:
	usbd_deactivate(sc->sc_udev);
}

/* detach */
int
udav_detach(struct device *self, int flags)
{
	struct udav_softc *sc = (struct udav_softc *)self;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));


	if (timeout_initialized(&sc->sc_stat_ch))
		timeout_del(&sc->sc_stat_ch);

	/* Remove any pending tasks */
	usb_rem_task(sc->sc_udev, &sc->sc_tick_task);
	usb_rem_task(sc->sc_udev, &sc->sc_stop_task);

	s = splusb();

	if (--sc->sc_refcnt >= 0) {
		/* Wait for processes to go away */
		usb_detach_wait(&sc->sc_dev);
	}
	if (ifp->if_flags & IFF_RUNNING)
		udav_stop(GET_IFP(sc), 1);

	if (!(sc->sc_flags & UDAV_RD9700))
		mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
	ifmedia_delete_instance(&sc->sc_mii.mii_media, IFM_INST_ANY);
	if (ifp->if_softc != NULL) {
		ether_ifdetach(ifp);
		if_detach(ifp);
	}

#ifdef DIAGNOSTIC
	if (sc->sc_pipe_tx != NULL)
		printf("%s: detach has active tx endpoint.\n",
		       sc->sc_dev.dv_xname);
	if (sc->sc_pipe_rx != NULL)
		printf("%s: detach has active rx endpoint.\n",
		       sc->sc_dev.dv_xname);
	if (sc->sc_pipe_intr != NULL)
		printf("%s: detach has active intr endpoint.\n",
		       sc->sc_dev.dv_xname);
#endif
	splx(s);

	return (0);
}

#if 0
/* read memory */
int
udav_mem_read(struct udav_softc *sc, int offset, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xffff;
	len &= 0xff;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_MEM_READ;
	USETW(req.wValue, 0x0000);
	USETW(req.wIndex, offset);
	USETW(req.wLength, len);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, buf);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: read failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}

/* write memory */
int
udav_mem_write(struct udav_softc *sc, int offset, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xffff;
	len &= 0xff;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_MEM_WRITE;
	USETW(req.wValue, 0x0000);
	USETW(req.wIndex, offset);
	USETW(req.wLength, len);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, buf);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}

/* write memory */
int
udav_mem_write1(struct udav_softc *sc, int offset, unsigned char ch)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xffff;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_MEM_WRITE1;
	USETW(req.wValue, ch);
	USETW(req.wIndex, offset);
	USETW(req.wLength, 0x0000);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}
#endif

/* read register(s) */
int
udav_csr_read(struct udav_softc *sc, int offset, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xff;
	len &= 0xff;

	req.bmRequestType = UT_READ_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_REG_READ;
	USETW(req.wValue, 0x0000);
	USETW(req.wIndex, offset);
	USETW(req.wLength, len);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, buf);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: read failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}

/* write register(s) */
int
udav_csr_write(struct udav_softc *sc, int offset, void *buf, int len)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xff;
	len &= 0xff;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_REG_WRITE;
	USETW(req.wValue, 0x0000);
	USETW(req.wIndex, offset);
	USETW(req.wLength, len);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, buf);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}

int
udav_csr_read1(struct udav_softc *sc, int offset)
{
	u_int8_t val = 0;
	
	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	return (udav_csr_read(sc, offset, &val, 1) ? 0 : val);
}

/* write a register */
int
udav_csr_write1(struct udav_softc *sc, int offset, unsigned char ch)
{
	usb_device_request_t req;
	usbd_status err;

	if (sc == NULL)
		return (0);

	DPRINTFN(0x200,
		("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	offset &= 0xff;

	req.bmRequestType = UT_WRITE_VENDOR_DEVICE;
	req.bRequest = UDAV_REQ_REG_WRITE1;
	USETW(req.wValue, ch);
	USETW(req.wIndex, offset);
	USETW(req.wLength, 0x0000);

	sc->sc_refcnt++;
	err = usbd_do_request(sc->sc_udev, &req, NULL);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err) {
		DPRINTF(("%s: %s: write failed. off=%04x, err=%d\n",
			 sc->sc_dev.dv_xname, __func__, offset, err));
	}

	return (err);
}

int
udav_init(struct ifnet *ifp)
{
	struct udav_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);
	u_char *eaddr;
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	s = splnet();

	/* Cancel pending I/O and free all TX/RX buffers */
	udav_stop(ifp, 1);

        eaddr = sc->sc_ac.ac_enaddr;
	udav_csr_write(sc, UDAV_PAR, eaddr, ETHER_ADDR_LEN);

	/* Initialize network control register */
	/*  Disable loopback  */
	UDAV_CLRBIT(sc, UDAV_NCR, UDAV_NCR_LBK0 | UDAV_NCR_LBK1);

	/* Initialize RX control register */
	UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_DIS_LONG | UDAV_RCR_DIS_CRC);

	/* Initialize transmit ring */
	if (udav_tx_list_init(sc) == ENOBUFS) {
		printf("%s: tx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return (EIO);
	}

	/* Initialize receive ring */
	if (udav_rx_list_init(sc) == ENOBUFS) {
		printf("%s: rx list init failed\n", sc->sc_dev.dv_xname);
		splx(s);
		return (EIO);
	}

	/* Program promiscuous mode and multicast filters */
	udav_iff(sc);

	/* Enable RX */
	UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_RXEN);

	/* clear POWER_DOWN state of internal PHY */
	UDAV_SETBIT(sc, UDAV_GPCR, UDAV_GPCR_GEP_CNTL0);
	UDAV_CLRBIT(sc, UDAV_GPR, UDAV_GPR_GEPIO0);

	if (!(sc->sc_flags & UDAV_RD9700))
		mii_mediachg(mii);

	if (sc->sc_pipe_tx == NULL || sc->sc_pipe_rx == NULL) {
		if (udav_openpipes(sc)) {
			splx(s);
			return (EIO);
		}
	}

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	splx(s);

	timeout_add_sec(&sc->sc_stat_ch, 1);

	return (0);
}

void
udav_reset(struct udav_softc *sc)
{
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	/* Select PHY */
#if 1
	/*
	 * XXX: force select internal phy.
	 *	external phy routines are not tested.
	 */
	UDAV_CLRBIT(sc, UDAV_NCR, UDAV_NCR_EXT_PHY);
#else
	if (sc->sc_flags & UDAV_EXT_PHY) {
		UDAV_SETBIT(sc, UDAV_NCR, UDAV_NCR_EXT_PHY);
	} else {
		UDAV_CLRBIT(sc, UDAV_NCR, UDAV_NCR_EXT_PHY);
	}
#endif

	UDAV_SETBIT(sc, UDAV_NCR, UDAV_NCR_RST);

	for (i = 0; i < UDAV_TX_TIMEOUT; i++) {
		if (!(udav_csr_read1(sc, UDAV_NCR) & UDAV_NCR_RST))
			break;
		delay(10);	/* XXX */
	}
	delay(10000);		/* XXX */
}

#define UDAV_BITS	6

void
udav_iff(struct udav_softc *sc)
{
	struct ifnet *ifp = GET_IFP(sc);
	struct arpcom *ac = &sc->sc_ac;
	struct ether_multi *enm;
	struct ether_multistep step;
	u_int8_t hashes[8];
	int h = 0;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	UDAV_CLRBIT(sc, UDAV_RCR, UDAV_RCR_ALL | UDAV_RCR_PRMSC);
	memset(hashes, 0x00, sizeof(hashes));
	ifp->if_flags &= ~IFF_ALLMULTI;

	if (ifp->if_flags & IFF_PROMISC || ac->ac_multirangecnt > 0) {
		ifp->if_flags |= IFF_ALLMULTI;
		UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_ALL);
		if (ifp->if_flags & IFF_PROMISC)
			UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_PRMSC);
	} else {
		hashes[7] |= 0x80;	/* broadcast address */

		/* now program new ones */
		ETHER_FIRST_MULTI(step, ac, enm);
		while (enm != NULL) {
			h = ether_crc32_le(enm->enm_addrlo, ETHER_ADDR_LEN) &
			    ((1 << UDAV_BITS) - 1);

			hashes[h>>3] |= 1 << (h & 0x7);

			ETHER_NEXT_MULTI(step, enm);
		}
	}

	udav_csr_write(sc, UDAV_MAR, hashes, sizeof(hashes));
}

int
udav_openpipes(struct udav_softc *sc)
{
	struct udav_chain *c;
	usbd_status err;
	int i;
	int error = 0;

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	sc->sc_refcnt++;

	/* Open RX pipe */
	err = usbd_open_pipe(sc->sc_ctl_iface, sc->sc_bulkin_no,
			     USBD_EXCLUSIVE_USE, &sc->sc_pipe_rx);
	if (err) {
		printf("%s: open rx pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

	/* Open TX pipe */
	err = usbd_open_pipe(sc->sc_ctl_iface, sc->sc_bulkout_no,
			     USBD_EXCLUSIVE_USE, &sc->sc_pipe_tx);
	if (err) {
		printf("%s: open tx pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}

#if 0
	/* XXX: interrupt endpoint is not yet supported */
	/* Open Interrupt pipe */
	err = usbd_open_pipe_intr(sc->sc_ctl_iface, sc->sc_intrin_no,
				  USBD_EXCLUSIVE_USE, &sc->sc_pipe_intr, sc,
				  &sc->sc_cdata.udav_ibuf, UDAV_INTR_PKGLEN,
				  udav_intr, UDAV_INTR_INTERVAL);
	if (err) {
		printf("%s: open intr pipe failed: %s\n",
		       sc->sc_dev.dv_xname, usbd_errstr(err));
		error = EIO;
		goto done;
	}
#endif


	/* Start up the receive pipe. */
	for (i = 0; i < UDAV_RX_LIST_CNT; i++) {
		c = &sc->sc_cdata.udav_rx_chain[i];
		usbd_setup_xfer(c->udav_xfer, sc->sc_pipe_rx,
				c, c->udav_buf, UDAV_BUFSZ,
				USBD_SHORT_XFER_OK | USBD_NO_COPY,
				USBD_NO_TIMEOUT, udav_rxeof);
		(void)usbd_transfer(c->udav_xfer);
		DPRINTF(("%s: %s: start read\n", sc->sc_dev.dv_xname,
			 __func__));
	}

 done:
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	return (error);
}

int
udav_newbuf(struct udav_softc *sc, struct udav_chain *c, struct mbuf *m)
{
	struct mbuf *m_new = NULL;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (m == NULL) {
		MGETHDR(m_new, M_DONTWAIT, MT_DATA);
		if (m_new == NULL) {
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dev.dv_xname);
			return (ENOBUFS);
		}
		MCLGET(m_new, M_DONTWAIT);
		if (!(m_new->m_flags & M_EXT)) {
			printf("%s: no memory for rx list "
			       "-- packet dropped!\n", sc->sc_dev.dv_xname);
			m_freem(m_new);
			return (ENOBUFS);
		}
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
	} else {
		m_new = m;
		m_new->m_len = m_new->m_pkthdr.len = MCLBYTES;
		m_new->m_data = m_new->m_ext.ext_buf;
	}

	m_adj(m_new, ETHER_ALIGN);
	c->udav_mbuf = m_new;

	return (0);
}


int
udav_rx_list_init(struct udav_softc *sc)
{
	struct udav_cdata *cd;
	struct udav_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < UDAV_RX_LIST_CNT; i++) {
		c = &cd->udav_rx_chain[i];
		c->udav_sc = sc;
		c->udav_idx = i;
		if (udav_newbuf(sc, c, NULL) == ENOBUFS)
			return (ENOBUFS);
		if (c->udav_xfer == NULL) {
			c->udav_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->udav_xfer == NULL)
				return (ENOBUFS);
			c->udav_buf = usbd_alloc_buffer(c->udav_xfer, UDAV_BUFSZ);
			if (c->udav_buf == NULL) {
				usbd_free_xfer(c->udav_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

int
udav_tx_list_init(struct udav_softc *sc)
{
	struct udav_cdata *cd;
	struct udav_chain *c;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	cd = &sc->sc_cdata;
	for (i = 0; i < UDAV_TX_LIST_CNT; i++) {
		c = &cd->udav_tx_chain[i];
		c->udav_sc = sc;
		c->udav_idx = i;
		c->udav_mbuf = NULL;
		if (c->udav_xfer == NULL) {
			c->udav_xfer = usbd_alloc_xfer(sc->sc_udev);
			if (c->udav_xfer == NULL)
				return (ENOBUFS);
			c->udav_buf = usbd_alloc_buffer(c->udav_xfer, UDAV_BUFSZ);
			if (c->udav_buf == NULL) {
				usbd_free_xfer(c->udav_xfer);
				return (ENOBUFS);
			}
		}
	}

	return (0);
}

void
udav_start(struct ifnet *ifp)
{
	struct udav_softc *sc = ifp->if_softc;
	struct mbuf *m_head = NULL;

	DPRINTF(("%s: %s: enter, link=%d\n", sc->sc_dev.dv_xname,
		 __func__, sc->sc_link));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (!sc->sc_link)
		return;

	if (ifq_is_oactive(&ifp->if_snd))
		return;

	m_head = ifq_deq_begin(&ifp->if_snd);
	if (m_head == NULL)
		return;

	if (udav_send(sc, m_head, 0)) {
		ifq_deq_rollback(&ifp->if_snd, m_head);
		ifq_set_oactive(&ifp->if_snd);
		return;
	}

	ifq_deq_commit(&ifp->if_snd, m_head);

#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m_head, BPF_DIRECTION_OUT);
#endif

	ifq_set_oactive(&ifp->if_snd);

	/* Set a timeout in case the chip goes out to lunch. */
	ifp->if_timer = 5;
}

int
udav_send(struct udav_softc *sc, struct mbuf *m, int idx)
{
	int total_len;
	struct udav_chain *c;
	usbd_status err;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	c = &sc->sc_cdata.udav_tx_chain[idx];

	/* Copy the mbuf data into a contiguous buffer */
	/*  first 2 bytes are packet length */
	m_copydata(m, 0, m->m_pkthdr.len, c->udav_buf + 2);
	c->udav_mbuf = m;
	total_len = m->m_pkthdr.len;
	if (total_len < UDAV_MIN_FRAME_LEN) {
		memset(c->udav_buf + 2 + total_len, 0,
		    UDAV_MIN_FRAME_LEN - total_len);
		total_len = UDAV_MIN_FRAME_LEN;
	}

	/* Frame length is specified in the first 2bytes of the buffer */
	c->udav_buf[0] = (u_int8_t)total_len;
	c->udav_buf[1] = (u_int8_t)(total_len >> 8);
	total_len += 2;

	usbd_setup_xfer(c->udav_xfer, sc->sc_pipe_tx, c, c->udav_buf, total_len,
			USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
			UDAV_TX_TIMEOUT, udav_txeof);

	/* Transmit */
	sc->sc_refcnt++;
	err = usbd_transfer(c->udav_xfer);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
	if (err != USBD_IN_PROGRESS) {
		printf("%s: udav_send error=%s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(err));
		/* Stop the interface */
		usb_add_task(sc->sc_udev, &sc->sc_stop_task);
		return (EIO);
	}

	DPRINTF(("%s: %s: send %d bytes\n", sc->sc_dev.dv_xname,
		 __func__, total_len));

	sc->sc_cdata.udav_tx_cnt++;

	return (0);
}

void
udav_txeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct udav_chain *c = priv;
	struct udav_softc *sc = c->udav_sc;
	struct ifnet *ifp = GET_IFP(sc);
	int s;

	if (usbd_is_dying(sc->sc_udev))
		return;

	s = splnet();

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_timer = 0;
	ifq_clr_oactive(&ifp->if_snd);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED) {
			splx(s);
			return;
		}
		ifp->if_oerrors++;
		printf("%s: usb error on tx: %s\n", sc->sc_dev.dv_xname,
		       usbd_errstr(status));
		if (status == USBD_STALLED) {
			sc->sc_refcnt++;
			usbd_clear_endpoint_stall_async(sc->sc_pipe_tx);
			if (--sc->sc_refcnt < 0)
				usb_detach_wakeup(&sc->sc_dev);
		}
		splx(s);
		return;
	}

	m_freem(c->udav_mbuf);
	c->udav_mbuf = NULL;

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		udav_start(ifp);

	splx(s);
}

void
udav_rxeof(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct udav_chain *c = priv;
	struct udav_softc *sc = c->udav_sc;
	struct ifnet *ifp = GET_IFP(sc);
	struct udav_rx_hdr *h;
	struct mbuf_list ml = MBUF_LIST_INITIALIZER();
	struct mbuf *m;
	u_int32_t total_len;
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname,__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		sc->sc_rx_errs++;
		if (usbd_ratecheck(&sc->sc_rx_notice)) {
			printf("%s: %u usb errors on rx: %s\n",
			       sc->sc_dev.dv_xname, sc->sc_rx_errs,
			       usbd_errstr(status));
			sc->sc_rx_errs = 0;
		}
		if (status == USBD_STALLED) {
			sc->sc_refcnt++;
			usbd_clear_endpoint_stall_async(sc->sc_pipe_rx);
			if (--sc->sc_refcnt < 0)
				usb_detach_wakeup(&sc->sc_dev);
		}
		goto done;
	}

	usbd_get_xfer_status(xfer, NULL, NULL, &total_len, NULL);

	if (total_len < UDAV_RX_HDRLEN) {
		ifp->if_ierrors++;
		goto done;
	}
	
	h = (struct udav_rx_hdr *)c->udav_buf;
	total_len = UGETW(h->length) - ETHER_CRC_LEN;
	
	DPRINTF(("%s: RX Status: 0x%02x\n", sc->sc_dev.dv_xname, h->pktstat));

	if (h->pktstat & UDAV_RSR_LCS) {
		ifp->if_collisions++;
		goto done;
	}

	/* RX status may still be correct but total_len is bogus */
	if (total_len < sizeof(struct ether_header) ||
	    h->pktstat & UDAV_RSR_ERR ||
	    total_len > UDAV_BUFSZ ) {
		ifp->if_ierrors++;
		goto done;
	}

	/* copy data to mbuf */
	m = c->udav_mbuf;
	memcpy(mtod(m, char *), c->udav_buf + UDAV_RX_HDRLEN, total_len);

	m->m_pkthdr.len = m->m_len = total_len;
	ml_enqueue(&ml, m);

	if (udav_newbuf(sc, c, NULL) == ENOBUFS) {
		ifp->if_ierrors++;
		goto done;
	}

	s = splnet();
	if_input(ifp, &ml);
	splx(s);

 done:
	/* Setup new transfer */
	usbd_setup_xfer(xfer, sc->sc_pipe_rx, c, c->udav_buf, UDAV_BUFSZ,
			USBD_SHORT_XFER_OK | USBD_NO_COPY,
			USBD_NO_TIMEOUT, udav_rxeof);
	sc->sc_refcnt++;
	usbd_transfer(xfer);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);

	DPRINTF(("%s: %s: start rx\n", sc->sc_dev.dv_xname, __func__));
}

int
udav_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct udav_softc *sc = ifp->if_softc;
	struct ifreq *ifr = (struct ifreq *)data;
	int s, error = 0;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (EIO);

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		if (!(ifp->if_flags & IFF_RUNNING))
			udav_init(ifp);
		break;

	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if (ifp->if_flags & IFF_RUNNING)
				error = ENETRESET;
			else
				udav_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				udav_stop(ifp, 1);
		}
		break;

	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		error = ifmedia_ioctl(ifp, ifr, &sc->sc_mii.mii_media, cmd);
		break;

	default:
		error = ether_ioctl(ifp, &sc->sc_ac, cmd, data);
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & IFF_RUNNING)
			udav_iff(sc);
		error = 0;
	}

	splx(s);
	return (error);
}

void
udav_watchdog(struct ifnet *ifp)
{
	struct udav_softc *sc = ifp->if_softc;
	struct udav_chain *c;
	usbd_status stat;
	int s;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_oerrors++;
	printf("%s: watchdog timeout\n", sc->sc_dev.dv_xname);

	s = splusb();
	c = &sc->sc_cdata.udav_tx_chain[0];
	usbd_get_xfer_status(c->udav_xfer, NULL, NULL, NULL, &stat);
	udav_txeof(c->udav_xfer, c, stat);

	if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
		udav_start(ifp);
	splx(s);
}

void
udav_stop_task(struct udav_softc *sc)
{
	udav_stop(GET_IFP(sc), 1);
}

/* Stop the adapter and free any mbufs allocated to the RX and TX lists. */
void
udav_stop(struct ifnet *ifp, int disable)
{
	struct udav_softc *sc = ifp->if_softc;
	usbd_status err;
	int i;

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	udav_reset(sc);

	timeout_del(&sc->sc_stat_ch);

	/* Stop transfers */
	/* RX endpoint */
	if (sc->sc_pipe_rx != NULL) {
		usbd_abort_pipe(sc->sc_pipe_rx);
		err = usbd_close_pipe(sc->sc_pipe_rx);
		if (err)
			printf("%s: close rx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_rx = NULL;
	}

	/* TX endpoint */
	if (sc->sc_pipe_tx != NULL) {
		usbd_abort_pipe(sc->sc_pipe_tx);
		err = usbd_close_pipe(sc->sc_pipe_tx);
		if (err)
			printf("%s: close tx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_tx = NULL;
	}

#if 0
	/* XXX: Interrupt endpoint is not yet supported!! */
	/* Interrupt endpoint */
	if (sc->sc_pipe_intr != NULL) {
		usbd_abort_pipe(sc->sc_pipe_intr);
		err = usbd_close_pipe(sc->sc_pipe_intr);
		if (err)
			printf("%s: close intr pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
		sc->sc_pipe_intr = NULL;
	}
#endif

	/* Free RX resources. */
	for (i = 0; i < UDAV_RX_LIST_CNT; i++) {
		if (sc->sc_cdata.udav_rx_chain[i].udav_mbuf != NULL) {
			m_freem(sc->sc_cdata.udav_rx_chain[i].udav_mbuf);
			sc->sc_cdata.udav_rx_chain[i].udav_mbuf = NULL;
		}
		if (sc->sc_cdata.udav_rx_chain[i].udav_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.udav_rx_chain[i].udav_xfer);
			sc->sc_cdata.udav_rx_chain[i].udav_xfer = NULL;
		}
	}

	/* Free TX resources. */
	for (i = 0; i < UDAV_TX_LIST_CNT; i++) {
		if (sc->sc_cdata.udav_tx_chain[i].udav_mbuf != NULL) {
			m_freem(sc->sc_cdata.udav_tx_chain[i].udav_mbuf);
			sc->sc_cdata.udav_tx_chain[i].udav_mbuf = NULL;
		}
		if (sc->sc_cdata.udav_tx_chain[i].udav_xfer != NULL) {
			usbd_free_xfer(sc->sc_cdata.udav_tx_chain[i].udav_xfer);
			sc->sc_cdata.udav_tx_chain[i].udav_xfer = NULL;
		}
	}

	sc->sc_link = 0;
}

/* Set media options */
int
udav_ifmedia_change(struct ifnet *ifp)
{
	struct udav_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return (0);

	sc->sc_link = 0;

	if (sc->sc_flags & UDAV_RD9700)
		return (0);

	if (mii->mii_instance) {
		struct mii_softc *miisc;
		for (miisc = LIST_FIRST(&mii->mii_phys); miisc != NULL;
		     miisc = LIST_NEXT(miisc, mii_list))
			mii_phy_reset(miisc);
	}

	return (mii_mediachg(mii));
}

/* Report current media status. */
void
udav_ifmedia_status(struct ifnet *ifp, struct ifmediareq *ifmr)
{
	struct udav_softc *sc = ifp->if_softc;
	struct mii_data *mii = GET_MII(sc);

	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	if ((ifp->if_flags & IFF_RUNNING) == 0) {
		ifmr->ifm_active = IFM_ETHER | IFM_NONE;
		ifmr->ifm_status = 0;
		return;
	}

	if (sc->sc_flags & UDAV_RD9700) {
		ifmr->ifm_active = IFM_ETHER | IFM_10_T;
		ifmr->ifm_status = IFM_AVALID;
		if (sc->sc_link) ifmr->ifm_status |= IFM_ACTIVE;
		return;
	}

	mii_pollstat(mii);
	ifmr->ifm_active = mii->mii_media_active;
	ifmr->ifm_status = mii->mii_media_status;
}

void
udav_tick(void *xsc)
{
	struct udav_softc *sc = xsc;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	/* Perform periodic stuff in process context */
	usb_add_task(sc->sc_udev, &sc->sc_tick_task);
}

void
udav_tick_task(void *xsc)
{
	struct udav_softc *sc = xsc;
	struct ifnet *ifp;
	struct mii_data *mii;
	int s, sts;

	if (sc == NULL)
		return;

	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	if (usbd_is_dying(sc->sc_udev))
		return;

	ifp = GET_IFP(sc);
	mii = GET_MII(sc);

	if (mii == NULL)
		return;

	s = splnet();

	if (sc->sc_flags & UDAV_RD9700) {
		sts = udav_csr_read1(sc, UDAV_NSR) & UDAV_NSR_LINKST;
		if (!sts)
			sc->sc_link = 0;
	} else {
		mii_tick(mii);
		sts = (mii->mii_media_status & IFM_ACTIVE &&
		       IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) ? 1 : 0;
	}

	if (!sc->sc_link && sts) {
		DPRINTF(("%s: %s: got link\n",
			 sc->sc_dev.dv_xname, __func__));
		sc->sc_link++;
		if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
			   udav_start(ifp);
	}

	timeout_add_sec(&sc->sc_stat_ch, 1);

	splx(s);
}

/* Get exclusive access to the MII registers */
void
udav_lock_mii(struct udav_softc *sc)
{
	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
			__func__));

	sc->sc_refcnt++;
	rw_enter_write(&sc->sc_mii_lock);
}

void
udav_unlock_mii(struct udav_softc *sc)
{
	DPRINTFN(0xff, ("%s: %s: enter\n", sc->sc_dev.dv_xname,
		       __func__));

	rw_exit_write(&sc->sc_mii_lock);
	if (--sc->sc_refcnt < 0)
		usb_detach_wakeup(&sc->sc_dev);
}

int
udav_miibus_readreg(struct device *dev, int phy, int reg)
{
	struct udav_softc *sc;
	u_int8_t val[2];
	u_int16_t data16;

	if (dev == NULL)
		return (0);

	sc = (void *)dev;

	DPRINTFN(0xff, ("%s: %s: enter, phy=%d reg=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return (0);
	}

	/* XXX: one PHY only for the internal PHY */
	if (phy != 0) {
		DPRINTFN(0xff, ("%s: %s: phy=%d is not supported\n",
			 sc->sc_dev.dv_xname, __func__, phy));
		return (0);
	}

	udav_lock_mii(sc);

	/* select internal PHY and set PHY register address */
	udav_csr_write1(sc, UDAV_EPAR,
			UDAV_EPAR_PHY_ADR0 | (reg & UDAV_EPAR_EROA_MASK));

	/* select PHY operation and start read command */
	udav_csr_write1(sc, UDAV_EPCR, UDAV_EPCR_EPOS | UDAV_EPCR_ERPRR);

	/* XXX: should be wait? */

	/* end read command */
	UDAV_CLRBIT(sc, UDAV_EPCR, UDAV_EPCR_ERPRR);

	/* retrieve the result from data registers */
	udav_csr_read(sc, UDAV_EPDRL, val, 2);

	udav_unlock_mii(sc);

	data16 = val[0] | (val[1] << 8);

	DPRINTFN(0xff, ("%s: %s: phy=%d reg=0x%04x => 0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, data16));

	return (data16);
}

void
udav_miibus_writereg(struct device *dev, int phy, int reg, int data)
{
	struct udav_softc *sc;
	u_int8_t val[2];

	if (dev == NULL)
		return;

	sc = (void *)dev;

	DPRINTFN(0xff, ("%s: %s: enter, phy=%d reg=0x%04x data=0x%04x\n",
		 sc->sc_dev.dv_xname, __func__, phy, reg, data));

	if (usbd_is_dying(sc->sc_udev)) {
#ifdef DIAGNOSTIC
		printf("%s: %s: dying\n", sc->sc_dev.dv_xname,
		       __func__);
#endif
		return;
	}

	/* XXX: one PHY only for the internal PHY */
	if (phy != 0) {
		DPRINTFN(0xff, ("%s: %s: phy=%d is not supported\n",
			 sc->sc_dev.dv_xname, __func__, phy));
		return;
	}

	udav_lock_mii(sc);

	/* select internal PHY and set PHY register address */
	udav_csr_write1(sc, UDAV_EPAR,
			UDAV_EPAR_PHY_ADR0 | (reg & UDAV_EPAR_EROA_MASK));

	/* put the value to the data registers */
	val[0] = data & 0xff;
	val[1] = (data >> 8) & 0xff;
	udav_csr_write(sc, UDAV_EPDRL, val, 2);

	/* select PHY operation and start write command */
	udav_csr_write1(sc, UDAV_EPCR, UDAV_EPCR_EPOS | UDAV_EPCR_ERPRW);

	/* XXX: should be wait? */

	/* end write command */
	UDAV_CLRBIT(sc, UDAV_EPCR, UDAV_EPCR_ERPRW);

	udav_unlock_mii(sc);

	return;
}

void
udav_miibus_statchg(struct device *dev)
{
#ifdef UDAV_DEBUG
	struct udav_softc *sc;

	if (dev == NULL)
		return;

	sc = (void *)dev;
	DPRINTF(("%s: %s: enter\n", sc->sc_dev.dv_xname, __func__));
#endif
	/* Nothing to do */
}
@


1.78
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.77 2015/11/25 03:10:00 dlg Exp $ */
a1026 2

	ifp->if_opackets++;
@


1.77
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.76 2015/11/24 17:11:40 mpi Exp $ */
a258 2

	IFQ_SET_READY(&ifp->if_snd);
@


1.76
log
@You only need <net/if_dl.h> if you're using LLADDR() or a sockaddr_dl.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.75 2015/11/24 13:45:07 mpi Exp $ */
d649 1
a649 1
	ifp->if_flags &= ~IFF_OACTIVE;
d916 1
a916 1
	if (ifp->if_flags & IFF_OACTIVE)
d925 1
a925 1
		ifp->if_flags |= IFF_OACTIVE;
d936 1
a936 1
	ifp->if_flags |= IFF_OACTIVE;
d1010 1
a1010 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1223 2
a1224 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.75
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.74 2015/11/20 03:35:23 dlg Exp $ */
a59 1
#include <net/if_dl.h>
@


1.74
log
@shuffle struct ifqueue so in flight mbufs are protected by a mutex.

the code is refactored so the IFQ macros call newly implemented ifq
functions. the ifq code is split so each discipline (priq and hfsc
in our case) is an opaque set of operations that the common ifq
code can call. the common code does the locking, accounting (ifq_len
manipulation), and freeing of the mbuf if the disciplines enqueue
function rejects it. theyre kind of like bufqs in the block layer
with their fifo and nscan disciplines.

the new api also supports atomic switching of disciplines at runtime.
the hfsc setup in pf_ioctl.c has been tweaked to build a complete
hfsc_if structure which it attaches to the send queue in a single
operation, rather than attaching to the interface up front and
building up a list of queues.

the send queue is now mutexed, which raises the expectation that
packets can be enqueued or purged on one cpu while another cpu is
dequeueing them in a driver for transmission. a lot of drivers use
IFQ_POLL to peek at an mbuf and attempt to fit it on the ring before
committing to it with a later IFQ_DEQUEUE operation. if the mbuf
gets freed in between the POLL and DEQUEUE operations, fireworks
will ensue.

to avoid this, the ifq api introduces ifq_deq_begin, ifq_deq_rollback,
and ifq_deq_commit. ifq_deq_begin allows a driver to take the ifq
mutex and get a reference to the mbuf they wish to try and tx. if
there's space, they can ifq_deq_commit it to remove the mbuf and
release the mutex. if there's no space, ifq_deq_rollback simply
releases the mutex. this api was developed to make updating the
drivers using IFQ_POLL easy, instead of having to do significant
semantic changes to avoid POLL that we cannot test on all the
hardware.

the common code has been tested pretty hard, and all the driver
modifications are straightforward except for de(4). if that breaks
it can be dealt with later.

ok mpi@@ jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.73 2015/10/25 12:11:56 mpi Exp $ */
a59 1
#include <net/if_arp.h>
@


1.73
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.72 2015/06/24 09:40:54 mpi Exp $ */
d921 1
a921 1
	IFQ_POLL(&ifp->if_snd, m_head);
d926 1
d931 1
a931 1
	IFQ_DEQUEUE(&ifp->if_snd, m_head);
@


1.72
log
@Increment if_ipackets in if_input().

Note that pseudo-drivers not using if_input() are not affected by this
conversion.

ok mikeb@@, kettenis@@, claudio@@, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.71 2015/06/19 20:39:34 uaa Exp $ */
a1135 1
	struct ifaddr *ifa = (struct ifaddr *)data;
a1150 3

		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&sc->sc_ac, ifa);
@


1.71
log
@Only match devices with a valid configuration.

ok by mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.70 2015/03/23 08:41:52 mpi Exp $ */
a1106 1
	ifp->if_ipackets++;
@


1.70
log
@Convert to if_input(), tested by jsg@@, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.69 2015/03/14 03:38:49 jsg Exp $ */
d170 1
a170 1
	if (uaa->iface != NULL)
d174 1
a174 1
		UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d184 1
a184 1
	struct usbd_interface *iface;
a197 7
	/* Move the device into the configured state. */
	err = usbd_set_config_no(dev, UDAV_CONFIG_NO, 1);
	if (err) {
		printf("setting config no failed\n");
		goto bad;
	}

a202 7

	/* get control interface */
	err = usbd_device2interface_handle(dev, UDAV_IFACE_INDEX, &iface);
	if (err) {
		printf("failed to get interface, err=%s\n", usbd_errstr(err));
		goto bad;
	}
@


1.69
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.68 2014/12/22 02:28:52 tedu Exp $ */
d1063 1
a1121 1

d1123 1
a1123 3
	m->m_pkthdr.rcvif = ifp;

	s = splnet();
d1127 1
a1127 1
		goto done1;
d1130 2
a1131 10
#if NBPFILTER > 0
	if (ifp->if_bpf)
		bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_IN);
#endif

	DPRINTF(("%s: %s: deliver %d\n", sc->sc_dev.dv_xname,
		 __func__, m->m_len));
	ether_input_mbuf(ifp, m);

 done1:
@


1.68
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.67 2014/07/13 15:52:49 mpi Exp $ */
a70 1
#include <dev/mii/mii.h>
@


1.67
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.66 2014/07/12 07:59:23 mpi Exp $ */
a1178 1
#ifdef INET
a1180 1
#endif
@


1.66
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.65 2014/01/22 04:13:22 sasano Exp $ */
a67 1
#ifdef INET
a68 2
#include <netinet/in_systm.h>
#include <netinet/ip.h>
a69 1
#endif
@


1.65
log
@udav(4): add CoreChip RD9700 support

RD9700 has no MII-PHY, no serial EEPROM.

ok by deraadt@@, brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.64 2013/11/15 10:17:39 pirofti Exp $ */
d85 3
d89 6
a94 16
/* Function declarations */
int udav_match(struct device *, void *, void *); 
void udav_attach(struct device *, struct device *, void *); 
int udav_detach(struct device *, int); 
int udav_activate(struct device *, int); 

struct cfdriver udav_cd = { 
	NULL, "udav", DV_IFNET 
}; 

const struct cfattach udav_ca = { 
	sizeof(struct udav_softc), 
	udav_match, 
	udav_attach, 
	udav_detach, 
	udav_activate, 
a711 15
}

int
udav_activate(struct device *self, int act)
{
	struct udav_softc *sc = (struct udav_softc *)self;

	DPRINTF(("%s: %s: enter, act=%d\n", sc->sc_dev.dv_xname,
		 __func__, act));
	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
	return (0);
@


1.64
log
@Clean-up usbd_abort_pipe() usage.


This function never fails. So change it's return type to void and
adjust the copy-pasted callers that were checking the return.

"If it compiles, ok" mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.63 2013/08/07 01:06:42 bluhm Exp $ */
d7 2
d160 1
d170 2
a171 1
	{{ USB_VENDOR_UNKNOWN6, USB_PRODUCT_UNKNOWN6_DM9601 }, 0 }
d301 2
a302 2
	mii_attach(self, mii, 0xffffffff, MII_PHY_ANY, MII_OFFSET_ANY, 0);
	if (LIST_FIRST(&mii->mii_phys) == NULL) {
d305 10
a314 2
	} else
		ifmedia_set(&mii->mii_media, IFM_ETHER | IFM_AUTO);
d357 2
a358 1
	mii_detach(&sc->sc_mii, MII_PHY_ANY, MII_OFFSET_ANY);
d666 2
a667 1
	mii_mediachg(mii);
d1362 4
d1394 7
d1427 1
a1427 1
	int s;
d1446 11
a1456 3
	mii_tick(mii);
	if (!sc->sc_link && mii->mii_media_status & IFM_ACTIVE &&
	    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
@


1.63
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.62 2013/04/15 09:23:01 mglocker Exp $ */
d1277 1
a1277 4
		err = usbd_abort_pipe(sc->sc_pipe_rx);
		if (err)
			printf("%s: abort rx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
d1287 1
a1287 4
		err = usbd_abort_pipe(sc->sc_pipe_tx);
		if (err)
			printf("%s: abort tx pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
d1299 1
a1299 4
		err = usbd_abort_pipe(sc->sc_pipe_intr);
		if (err)
			printf("%s: abort intr pipe failed: %s\n",
			       sc->sc_dev.dv_xname, usbd_errstr(err));
@


1.62
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.61 2013/03/28 03:58:03 tedu Exp $ */
a68 1
#include <netinet/in_var.h>
@


1.61
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.60 2013/01/29 02:06:55 brad Exp $ */
d109 2
a110 2
void udav_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
void udav_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
d192 2
a193 2
	usbd_device_handle dev = uaa->device;
	usbd_interface_handle iface;
d1024 1
a1024 1
udav_txeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d1071 1
a1071 1
udav_rxeof(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
@


1.60
log
@Rewrite the receive filter handling code and cleanup the ioctl bits.

Fixes a bug when going in and out of promiscuous mode results in the
driver not disabling all multicast mode.

Tested by kili@@ jasper@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.59 2012/12/05 23:20:21 deraadt Exp $ */
a52 1
#include <sys/proc.h>
@


1.59
log
@Remove excessive sys/cdefs.h inclusion
ok guenther millert kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.58 2011/09/04 18:34:02 jsg Exp $ */
d126 1
a126 1
void udav_setmulti(struct udav_softc *);
a630 6
	/* If we want promiscuous mode, accept all physical frames. */
	if (ifp->if_flags & IFF_PROMISC)
		UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_ALL|UDAV_RCR_PRMSC);
	else
		UDAV_CLRBIT(sc, UDAV_RCR, UDAV_RCR_ALL|UDAV_RCR_PRMSC);

d645 2
a646 2
	/* Load the multicast filter */
	udav_setmulti(sc);
a725 3
#define UDAV_CALCHASH(addr) \
	(ether_crc32_le((addr), ETHER_ADDR_LEN) & ((1 << UDAV_BITS) - 1))

d727 1
a727 1
udav_setmulti(struct udav_softc *sc)
d729 2
a730 1
	struct ifnet *ifp;
d741 3
a743 1
	ifp = GET_IFP(sc);
d745 1
a745 5
	if (ifp->if_flags & IFF_PROMISC) {
		UDAV_SETBIT(sc, UDAV_RCR, UDAV_RCR_ALL|UDAV_RCR_PRMSC);
		return;
	} else if (ifp->if_flags & IFF_ALLMULTI) {
	allmulti:
d748 10
a757 3
		UDAV_CLRBIT(sc, UDAV_RCR, UDAV_RCR_PRMSC);
		return;
	}
d759 1
a759 4
	/* first, zot all the existing hash bits */
	memset(hashes, 0x00, sizeof(hashes));
	hashes[7] |= 0x80;	/* broadcast address */
	udav_csr_write(sc, UDAV_MAR, hashes, sizeof(hashes));
d761 2
a762 10
	/* now program new ones */
	ETHER_FIRST_MULTI(step, &sc->sc_ac, enm);
	while (enm != NULL) {
		if (memcmp(enm->enm_addrlo, enm->enm_addrhi,
			   ETHER_ADDR_LEN) != 0)
			goto allmulti;

		h = UDAV_CALCHASH(enm->enm_addrlo);
		hashes[h>>3] |= 1 << (h & 0x7);
		ETHER_NEXT_MULTI(step, enm);
a764 5
	/* disable all multicast */
	ifp->if_flags &= ~IFF_ALLMULTI;
	UDAV_CLRBIT(sc, UDAV_RCR, UDAV_RCR_ALL);

	/* write hash value to the register */
a1177 1
	struct mii_data *mii;
a1187 6
	case SIOCGIFMEDIA:
	case SIOCSIFMEDIA:
		mii = GET_MII(sc);
		error = ifmedia_ioctl(ifp, ifr, &mii->mii_media, cmd);
		break;

d1190 2
a1191 1
		udav_init(ifp);
a1192 1
		switch (ifa->ifa_addr->sa_family) {
d1194 1
a1194 1
		case AF_INET:
d1196 1
a1196 3
			break;
#endif /* INET */
		}
d1201 3
a1203 9
			if (ifp->if_flags & IFF_RUNNING &&
			    ifp->if_flags & IFF_PROMISC) {
				UDAV_SETBIT(sc, UDAV_RCR,
				    UDAV_RCR_ALL|UDAV_RCR_PRMSC);
			} else if (ifp->if_flags & IFF_RUNNING &&
			    !(ifp->if_flags & IFF_PROMISC)) {
				UDAV_CLRBIT(sc, UDAV_RCR,
				    UDAV_RCR_PRMSC);
			} else if (!(ifp->if_flags & IFF_RUNNING))
d1209 5
a1213 1
		error = 0;
d1222 1
a1222 1
			udav_setmulti(sc);
@


1.58
log
@another udav device from Loganaden Velvindron
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.57 2011/07/03 15:47:17 matthew Exp $ */
a44 2

#include <sys/cdefs.h>
@


1.57
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.56 2011/06/23 16:31:16 deraadt Exp $ */
d170 2
a171 1
	{{ USB_VENDOR_UNKNOWN4, USB_PRODUCT_UNKNOWN4_DM9601 }, 0 }
@


1.56
log
@a bit more ansi; ok tedu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.55 2011/03/31 17:06:25 mk Exp $ */
a723 3
	case DVACT_ACTIVATE:
		break;

@


1.55
log
@Don't process packets where the USB xfer length is shorter than a packet
header, and don't process packets where the packet header length field
says the packet is longer than the size of the USB xfer.

While there, fix a debug print that was missing the device name from the
parameter list, causing it to crash when enabled.

Also, use correct MTU from datasheet.

From Loganaden Velvindrom with input from me.

Tested by kili.

ok jasper sthen (with a whitespace nit)
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.54 2011/03/20 17:58:26 mk Exp $ */
a1193 6

#if 0
void udav_intr()
{
}
#endif
@


1.54
log
@Update URI to data sheet.  New location found on www.davicom.com.tw but
points to some other domain for some reason.

Noticed while looking into a udav(4) issue with Loganaden Velvindron.

OK jasper
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.53 2011/03/16 22:39:13 jasper Exp $ */
d1131 5
d1139 1
a1139 1
	DPRINTF(("%s: RX Status: 0x%02x\n", h->pktstat));
d1146 1
d1148 2
a1149 1
	    h->pktstat & UDAV_RSR_ERR) {
@


1.53
log
@revert previous as it breaks nfs client as reported by kili@@

req'd by jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.51 2011/01/25 20:03:35 jakemsr Exp $ */
d37 1
a37 1
 *  http://www.davicom.com.tw/big5/download/Data%20Sheet/DM9601-DS-P01-930914.pdf 
@


1.52
log
@If we get a packet larger than if_hardmtu skip it.
Tweaked version of a diff from Loganaden Velvindron
who sees a large garbage frame on his device.
@
text
@d1141 1
a1141 2
	if (total_len < ETHERMIN ||
	    total_len > ifp->if_hardmtu ||
@


1.51
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.50 2010/12/06 04:41:39 jakemsr Exp $ */
d1141 2
a1142 1
	if (total_len < sizeof(struct ether_header) ||
@


1.50
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.49 2010/10/27 17:51:11 jakemsr Exp $ */
a314 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, &sc->sc_dev);

a366 3

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev,
			   &sc->sc_dev);
@


1.49
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.48 2010/10/23 16:14:07 jakemsr Exp $ */
d207 2
a228 1
	sc->sc_udev = dev;
d312 1
a312 1
	sc->sc_attached = 1;
d320 1
a320 1
	sc->sc_dying = 1;
a332 3
	/* Detached before attached finished */
	if (!sc->sc_attached)
		return (0);
a367 2
	sc->sc_attached = 0;

d390 1
a390 1
	if (sc->sc_dying)
d427 1
a427 1
	if (sc->sc_dying)
d464 1
a464 1
	if (sc->sc_dying)
d501 1
a501 1
	if (sc->sc_dying)
d538 1
a538 1
	if (sc->sc_dying)
a572 3
	if (sc->sc_dying)
		return (0);

d589 1
a589 1
	if (sc->sc_dying)
a621 3
	if (sc->sc_dying)
		return (EIO);

d693 1
a693 1
	if (sc->sc_dying)
d733 1
a733 1
		sc->sc_dying = 1;
d755 1
a755 1
	if (sc->sc_dying)
d804 1
a804 1
	if (sc->sc_dying)
d969 1
a969 1
	if (sc->sc_dying)
d1060 1
a1060 1
	if (sc->sc_dying)
d1112 1
a1112 1
	if (sc->sc_dying)
d1210 1
a1210 1
	if (sc->sc_dying)
d1249 1
a1249 1
			udav_stop(ifp, 1);
d1393 1
a1393 1
	if (sc->sc_dying)
d1416 1
a1416 1
	if (sc->sc_dying)
a1440 3
	if (sc->sc_dying)
		return;

d1459 1
a1459 1
	if (sc->sc_dying)
d1522 1
a1522 1
	if (sc->sc_dying) {
d1578 1
a1578 1
	if (sc->sc_dying) {
@


1.48
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.47 2010/10/23 15:42:09 jakemsr Exp $ */
d354 4
a357 2
	ether_ifdetach(ifp);
	if_detach(ifp);
@


1.47
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.46 2010/08/27 07:08:22 deraadt Exp $ */
d336 2
a337 1
	timeout_del(&sc->sc_stat_ch);
@


1.46
log
@Delete comments about these drivers needing powerhook support; they don't.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.45 2009/11/22 22:13:51 jsg Exp $ */
d214 2
a215 1
	usb_init_task(&sc->sc_tick_task, udav_tick_task, sc);
d217 2
a218 1
	usb_init_task(&sc->sc_stop_task, (void (*)(void *)) udav_stop_task, sc);
@


1.45
log
@add a bunch of devices found in linux drivers
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.44 2009/10/13 19:33:17 pirofti Exp $ */
a43 1
 *	powerhook() support?
@


1.44
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.43 2008/11/28 02:44:18 brad Exp $ */
d170 2
a171 1
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ADM8515 }, 0 }
@


1.43
log
@Eliminate the redundant bits of code for MTU and multicast handling
from the individual drivers now that ether_ioctl() handles this.

Shrinks the i386 kernels by..
RAMDISK - 2176 bytes
RAMDISKB - 1504 bytes
RAMDISKC - 736 bytes

Tested by naddy@@/okan@@/sthen@@/brad@@/todd@@/jmc@@ and lots of users.
Build tested on almost all archs by todd@@/brad@@

ok naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.42 2008/10/02 20:21:14 brad Exp $ */
d93 1
a93 1
int udav_activate(struct device *, enum devact); 
d727 1
a727 1
udav_activate(struct device *self, enum devact act)
@


1.42
log
@First step towards cleaning up the Ethernet driver ioctl handling.
Move calling ether_ioctl() from the top of the ioctl function, which
at the moment does absolutely nothing, to the default switch case.
Thus allowing drivers to define their own ioctl handlers and then
falling back on ether_ioctl(). The only functional change this results
in at the moment is having all Ethernet drivers returning the proper
errno of ENOTTY instead of EINVAL/ENXIO when encountering unknown
ioctl's.

Shrinks the i386 kernels by..
RAMDISK - 1024 bytes
RAMDISKB -  1120 bytes
RAMDISKC - 832 bytes

Tested by martin@@/jsing@@/todd@@/brad@@
Build tested on almost all archs by todd@@/brad@@

ok jsing@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.41 2008/09/10 14:01:23 blambert Exp $ */
d1226 1
a1239 6
	case SIOCSIFMTU:
		if (ifr->ifr_mtu > ETHERMTU)
			error = EINVAL;
		else
			ifp->if_mtu = ifr->ifr_mtu;
		break;
a1257 5
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &sc->sc_ac) :
		    ether_delmulti(ifr, &sc->sc_ac);
a1258 6
		if (error == ENETRESET) {
			if (ifp->if_flags & IFF_RUNNING)
				udav_setmulti(sc);
			error = 0;
		}
		break;
d1261 6
@


1.41
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.40 2007/11/23 15:43:02 mbalmer Exp $ */
d1276 1
a1276 2
		error = EINVAL;
		break;
a1279 1

@


1.40
log
@Sanitize the use of timeouts:

Instead of calling timeout_set(..., NULL, NULL) in attach routines and
later
timeout_del(...)
timeout_set(..., func, arg)
timeout_add(..., time)
set the function and argument in the initial timeout_set() call and only
use timeout_add(..., time) later.

ok dlg, fgsch, krw, winiger
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.39 2007/11/01 17:10:34 deraadt Exp $ */
d686 1
a686 1
	timeout_add(&sc->sc_stat_ch, hz);
d1500 1
a1500 1
	timeout_add(&sc->sc_stat_ch, hz);
@


1.39
log
@even better attach printing; Nicholas Marriott
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.38 2007/11/01 11:43:28 deraadt Exp $ */
d308 1
a308 1
	timeout_set(&sc->sc_stat_ch, NULL, NULL);
a685 2
	timeout_del(&sc->sc_stat_ch);
	timeout_set(&sc->sc_stat_ch, udav_tick, sc);
a1499 2
	timeout_del(&sc->sc_stat_ch);
	timeout_set(&sc->sc_stat_ch, udav_tick, sc);
@


1.38
log
@fix attach time messages; tested by Nicholas Marriott
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.37 2007/11/01 00:51:36 deraadt Exp $ */
d237 1
a237 1
			printf(", couldn't get endpoint %d\n", i);
d271 1
a271 1
	printf("address %s\n", devname, ether_sprintf(eaddr));
@


1.37
log
@Admtek/Shantou ADM8515; nicm__@@ntlworld.com
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.36 2007/10/20 01:05:46 beck Exp $ */
d205 2
d210 1
a210 1
		printf(", setting config no failed\n");
d221 1
a221 1
		printf(", failed to get interface, err=%s\n", usbd_errstr(err));
d253 1
a253 1
		printf(", missing endpoint\n");
d265 1
a265 1
		printf(", read MAC address failed\n");
d271 1
a271 1
	printf(" address %s\n", ether_sprintf(eaddr));
@


1.36
log
@Add ShanTou ZT6688 usb 10/000 nic - A udav sold in a generic package.
ok jsg@@, krw@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.35 2007/10/11 18:33:14 deraadt Exp $ */
d169 2
a170 1
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ZT6688 }, 0 }
@


1.35
log
@treat usb vendor/product names as a locator, and have usbd_print handle it,
so that it shows up before the :.  as a result, all the usb devices do not
need to have name printing code anymore.  all this now works and prints
nicely because usbd_probe_and_attach() is serialized.  ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.34 2007/06/14 10:11:15 mbalmer Exp $ */
d168 2
a169 1
	{{ USB_VENDOR_SHANTOU, USB_PRODUCT_SHANTOU_ST268 }, 0 }
@


1.34
log
@Remove the definition and usage of the USB_DECLARE_DRIVER_CLASS and
USB_DECLARE_DRIVER macros.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.33 2007/06/13 11:15:29 mbalmer Exp $ */
a196 1
	char *devinfop;
a201 4

	devinfop = usbd_devinfo_alloc(dev, 0);
	printf("\n%s: %s", devname, devinfop);
	usbd_devinfo_free(devinfop);
@


1.33
log
@Remove the definition and usage of the IF_INPUT macro which was defined
as ether_input_mbuf which is itself a macro for ether_input.

No binary change.

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.32 2007/06/12 16:26:36 mbalmer Exp $ */
d90 16
a105 1
USB_DECLARE_DRIVER_CLASS(udav, DV_IFNET);
@


1.32
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.31 2007/06/11 05:42:53 mbalmer Exp $ */
d1168 1
a1168 1
	IF_INPUT(ifp, m);
@


1.31
log
@Remove the definition and usage of the USBGETSOFTC macro, which was really
only a cast to (void *).

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.30 2007/06/10 14:49:00 mbalmer Exp $ */
d110 3
a112 3
int udav_miibus_readreg(device_ptr_t, int, int);
void udav_miibus_writereg(device_ptr_t, int, int, int);
void udav_miibus_statchg(device_ptr_t);
d715 1
a715 1
udav_activate(device_ptr_t self, enum devact act)
d1518 1
a1518 1
udav_miibus_readreg(device_ptr_t dev, int phy, int reg)
d1575 1
a1575 1
udav_miibus_writereg(device_ptr_t dev, int phy, int reg, int data)
d1628 1
a1628 1
udav_miibus_statchg(device_ptr_t dev)
@


1.30
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.29 2007/06/10 10:53:48 mbalmer Exp $ */
d1527 1
a1527 1
	sc = USBGETSOFTC(dev);
d1583 1
a1583 1
	sc = USBGETSOFTC(dev);
d1636 1
a1636 1
	sc = USBGETSOFTC(dev);
@


1.29
log
@Remove the definition and use of the USBDEV macro.  It only created confusion
and the address of it's argument:  USBDEV(sc->sc_dev) yields &sc->sc_dev.

No binary changes.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.28 2007/06/10 10:15:35 mbalmer Exp $ */
d183 1
a183 1
	char *devname = USBDEVNAME(sc->sc_dev);
d314 1
a314 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d343 1
a343 1
		       USBDEVNAME(sc->sc_dev));
d346 1
a346 1
		       USBDEVNAME(sc->sc_dev));
d349 1
a349 1
		       USBDEVNAME(sc->sc_dev));
d373 1
a373 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d393 1
a393 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d410 1
a410 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d430 1
a430 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d447 1
a447 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d466 1
a466 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d484 1
a484 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d504 1
a504 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d521 1
a521 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d541 1
a541 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d556 1
a556 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d575 1
a575 1
		("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d594 1
a594 1
			 USBDEVNAME(sc->sc_dev), __func__, offset, err));
d608 1
a608 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d636 1
a636 1
		printf("%s: tx list init failed\n", USBDEVNAME(sc->sc_dev));
d643 1
a643 1
		printf("%s: rx list init failed\n", USBDEVNAME(sc->sc_dev));
d684 1
a684 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d719 1
a719 1
	DPRINTF(("%s: %s: enter, act=%d\n", USBDEVNAME(sc->sc_dev),
d746 1
a746 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d807 1
a807 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d817 1
a817 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d831 1
a831 1
		       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d846 1
a846 1
		DPRINTF(("%s: %s: start read\n", USBDEVNAME(sc->sc_dev),
d862 1
a862 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d868 1
a868 1
			       "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d874 1
a874 1
			       "-- packet dropped!\n", USBDEVNAME(sc->sc_dev));
d899 1
a899 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d930 1
a930 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d959 1
a959 1
	DPRINTF(("%s: %s: enter, link=%d\n", USBDEVNAME(sc->sc_dev),
d1000 1
a1000 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d1030 1
a1030 1
		printf("%s: udav_send error=%s\n", USBDEVNAME(sc->sc_dev),
d1037 1
a1037 1
	DPRINTF(("%s: %s: send %d bytes\n", USBDEVNAME(sc->sc_dev),
d1058 1
a1058 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1069 1
a1069 1
		printf("%s: usb error on tx: %s\n", USBDEVNAME(sc->sc_dev),
d1103 1
a1103 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),__func__));
d1114 1
a1114 1
			       USBDEVNAME(sc->sc_dev), sc->sc_rx_errs,
d1166 1
a1166 1
	DPRINTF(("%s: %s: deliver %d\n", USBDEVNAME(sc->sc_dev),
d1183 1
a1183 1
	DPRINTF(("%s: %s: start rx\n", USBDEVNAME(sc->sc_dev), __func__));
d1201 1
a1201 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1281 1
a1281 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1284 1
a1284 1
	printf("%s: watchdog timeout\n", USBDEVNAME(sc->sc_dev));
d1310 1
a1310 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1325 1
a1325 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1329 1
a1329 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1338 1
a1338 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1342 1
a1342 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1353 1
a1353 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1357 1
a1357 1
			       USBDEVNAME(sc->sc_dev), usbd_errstr(err));
d1396 1
a1396 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1419 1
a1419 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
d1443 1
a1443 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1464 1
a1464 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1482 1
a1482 1
			 USBDEVNAME(sc->sc_dev), __func__));
d1499 1
a1499 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1509 1
a1509 1
	DPRINTFN(0xff, ("%s: %s: enter\n", USBDEVNAME(sc->sc_dev),
d1530 1
a1530 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg));
d1534 1
a1534 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1543 1
a1543 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1569 1
a1569 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data16));
d1586 1
a1586 1
		 USBDEVNAME(sc->sc_dev), __func__, phy, reg, data));
d1590 1
a1590 1
		printf("%s: %s: dying\n", USBDEVNAME(sc->sc_dev),
d1599 1
a1599 1
			 USBDEVNAME(sc->sc_dev), __func__, phy));
d1637 1
a1637 1
	DPRINTF(("%s: %s: enter\n", USBDEVNAME(sc->sc_dev), __func__));
@


1.28
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.27 2007/06/09 12:22:53 mbalmer Exp $ */
d298 1
a298 1
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, dev, USBDEV(sc->sc_dev));
d330 1
a330 1
		usb_detach_wait(USBDEV(sc->sc_dev));
d356 1
a356 1
			   USBDEV(sc->sc_dev));
d390 1
a390 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d427 1
a427 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d463 1
a463 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d501 1
a501 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d538 1
a538 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d591 1
a591 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d852 1
a852 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d1028 1
a1028 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d1075 1
a1075 1
				usb_detach_wakeup(USBDEV(sc->sc_dev));
d1122 1
a1122 1
				usb_detach_wakeup(USBDEV(sc->sc_dev));
d1181 1
a1181 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
d1514 1
a1514 1
		usb_detach_wakeup(USBDEV(sc->sc_dev));
@


1.27
log
@Remove the definition and use of if_deactivate().  It was defined empty and
thus produced no code at all.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.26 2007/06/05 08:43:55 mbalmer Exp $ */
d294 1
a294 1
	usb_callout_init(sc->sc_stat_ch);
d320 1
a320 1
	usb_uncallout(sc->sc_stat_ch, udav_tick, sc);
d672 3
a674 1
	usb_callout(sc->sc_stat_ch, hz, udav_tick, sc);
d1317 1
a1317 1
	usb_uncallout(sc->sc_stat_ch, udav_tick, sc);
d1488 3
a1490 1
	usb_callout(sc->sc_stat_ch, hz, udav_tick, sc);
@


1.26
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.25 2007/05/27 04:00:25 jsg Exp $ */
a723 1
		if_deactivate(&sc->sc_ec.ec_if);
@


1.25
log
@Farewell USB_{ATTACH,MATCH,DETACH}* you will not be missed.
ok deraadt@@ krw@@ mbalmer@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.24 2007/05/21 05:40:27 jsg Exp $ */
d92 29
a120 29
Static int udav_openpipes(struct udav_softc *);
Static int udav_rx_list_init(struct udav_softc *);
Static int udav_tx_list_init(struct udav_softc *);
Static int udav_newbuf(struct udav_softc *, struct udav_chain *, struct mbuf *);
Static void udav_start(struct ifnet *);
Static int udav_send(struct udav_softc *, struct mbuf *, int);
Static void udav_txeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void udav_rxeof(usbd_xfer_handle, usbd_private_handle, usbd_status);
Static void udav_tick(void *);
Static void udav_tick_task(void *);
Static int udav_ioctl(struct ifnet *, u_long, caddr_t);
Static void udav_stop_task(struct udav_softc *);
Static void udav_stop(struct ifnet *, int);
Static void udav_watchdog(struct ifnet *);
Static int udav_ifmedia_change(struct ifnet *);
Static void udav_ifmedia_status(struct ifnet *, struct ifmediareq *);
Static void udav_lock_mii(struct udav_softc *);
Static void udav_unlock_mii(struct udav_softc *);
Static int udav_miibus_readreg(device_ptr_t, int, int);
Static void udav_miibus_writereg(device_ptr_t, int, int, int);
Static void udav_miibus_statchg(device_ptr_t);
Static int udav_init(struct ifnet *);
Static void udav_setmulti(struct udav_softc *);
Static void udav_reset(struct udav_softc *);

Static int udav_csr_read(struct udav_softc *, int, void *, int);
Static int udav_csr_write(struct udav_softc *, int, void *, int);
Static int udav_csr_read1(struct udav_softc *, int);
Static int udav_csr_write1(struct udav_softc *, int, unsigned char);
d123 3
a125 3
Static int udav_mem_read(struct udav_softc *, int, void *, int);
Static int udav_mem_write(struct udav_softc *, int, void *, int);
Static int udav_mem_write1(struct udav_softc *, int, unsigned char);
d363 1
a363 1
Static int
d400 1
a400 1
Static int
d437 1
a437 1
Static int
d474 1
a474 1
Static int
d511 1
a511 1
Static int
d547 1
a547 1
Static int
d565 1
a565 1
Static int
d600 1
a600 1
Static int
d677 1
a677 1
Static void
d736 1
a736 1
Static void
d788 1
a788 1
Static int
d856 1
a856 1
Static int
d891 1
a891 1
Static int
d922 1
a922 1
Static int
d952 1
a952 1
Static void
d992 1
a992 1
Static int
d1044 1
a1044 1
Static void
d1091 1
a1091 1
Static void
d1186 1
a1186 1
Static void udav_intr()
d1191 1
a1191 1
Static int
d1272 1
a1272 1
Static void
d1295 1
a1295 1
Static void
d1302 1
a1302 1
Static void
d1389 1
a1389 1
Static int
d1412 1
a1412 1
Static void
d1434 1
a1434 1
Static void
d1452 1
a1452 1
Static void
d1493 1
a1493 1
Static void
d1503 1
a1503 1
Static void
d1514 1
a1514 1
Static int
d1571 1
a1571 1
Static void
d1624 1
a1624 1
Static void
@


1.24
log
@Remove logprintf macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.23 2007/05/21 05:18:56 jsg Exp $ */
d159 2
a160 1
USB_MATCH(udav)
d162 1
a162 1
	USB_MATCH_START(udav, uaa);
d172 2
a173 1
USB_ATTACH(udav)
d175 2
a176 1
	USB_ATTACH_START(udav, sc, uaa);
d190 1
a190 2
	USB_ATTACH_SETUP;
	printf("%s: %s", devname, devinfop);
d300 1
a300 1
	USB_ATTACH_SUCCESS_RETURN;
a303 1
	USB_ATTACH_ERROR_RETURN;
d307 2
a308 1
USB_DETACH(udav)
d310 1
a310 1
	USB_DETACH_START(udav, sc);
@


1.23
log
@Remove Ether_ifattach macro
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.22 2007/05/06 04:08:47 krw Exp $ */
d130 2
a131 2
#define DPRINTF(x)	do { if (udavdebug) logprintf x; } while(0)
#define DPRINTFN(n,x)	do { if (udavdebug >= (n)) logprintf x; } while(0)
@


1.22
log
@More lockmgr -> rwlock low hanging fruit.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.21 2007/04/16 09:13:41 jsg Exp $ */
d290 1
a290 1
	Ether_ifattach(ifp, eaddr);
@


1.21
log
@Another unbranded udav(4) device.

From laurent FANIS <laurent.fanis@@gmail.com>
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.20 2007/02/18 14:44:44 jsg Exp $ */
d53 1
a53 1
#include <sys/lock.h>
d199 1
a199 1
	lockinit(&sc->sc_mii_lock, PZERO, "udavmii", 0, 0);
d1498 1
a1498 1
	usb_lockmgr(&sc->sc_mii_lock, LK_EXCLUSIVE, NULL, curproc);
d1507 1
a1507 1
	usb_lockmgr(&sc->sc_mii_lock, LK_RELEASE, NULL, curproc);
@


1.20
log
@Add support for ShanTou ST268.
Tested by Paul de Weerd.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.19 2006/09/29 08:43:07 jsg Exp $ */
d152 1
@


1.19
log
@Add support for HenTong WK-668, and match the generic DM9601 id
while here.
WK-668 id reported by mk at freeweb.ozi.nu
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.18 2006/06/23 06:27:11 miod Exp $ */
d151 2
a152 1
	{{ USB_VENDOR_DAVICOM, USB_PRODUCT_DAVICOM_WK668 }, 0 }
@


1.18
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.17 2006/03/25 22:41:47 djm Exp $ */
d149 3
a151 7
	/* Corega USB-TXC */
	{{ USB_VENDOR_COREGA, USB_PRODUCT_COREGA_FETHER_USB_TXC }, 0},
#if 0
	/* DAVICOM DM9601 Generic? */
	/*  XXX: The following ids was obtained from the data sheet. */
	{{ 0x0a46, 0x9601 }, 0},
#endif
@


1.17
log
@allow bpf(4) to ignore packets based on their direction (inbound or
outbound), using a new BIOCSDIRFILT ioctl;
guidance, feedback and ok canacar@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.16 2006/03/07 04:41:19 krw Exp $ */
a720 1
		return (EOPNOTSUPP);
@


1.16
log
@Remove last NRND NetBSDisms from tree.

ok deraadt@@ brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.15 2006/02/06 17:29:11 jmc Exp $ */
a68 1
#define	BPF_MTAP(ifp, m)	bpf_mtap((ifp)->if_bpf, (m))
d984 1
a984 1
		bpf_mtap(ifp->if_bpf, m_head);
d1163 1
a1163 1
		BPF_MTAP(ifp, m);
@


1.15
log
@typos from alexey dobriyan;
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.14 2006/01/29 03:22:52 brad Exp $ */
a59 3
#if NRND > 0
#include <sys/rnd.h>
#endif
a294 4
#if NRND > 0
	rnd_attach_source(&sc->rnd_source, devname, RND_TYPE_NET, 0);
#endif

a335 3
#if NRND > 0
	rnd_detach_source(&sc->rnd_source);
#endif
@


1.14
log
@Use usbd_clear_endpoint_stall_async() when clearing endpoint stalls in
an interrupt context.

From NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.13 2005/08/01 05:36:48 brad Exp $ */
d265 1
a265 1
	/* initialize interface infomation */
@


1.13
log
@Don't keep the devinfo string on the stack, instead use malloc/free.
This should cure some rare stack overflows.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.12 2005/07/02 22:21:12 brad Exp $ */
d1084 1
a1084 1
			usbd_clear_endpoint_stall(sc->sc_pipe_tx);
d1131 1
a1131 1
			usbd_clear_endpoint_stall(sc->sc_pipe_rx);
@


1.12
log
@clear IFF_RUNNING & IFF_OACTIVE in foo_stop() before de-allocating resources.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.11 2005/07/02 22:17:58 brad Exp $ */
d185 1
a185 1
	char devinfo[1024];
d192 1
a192 1
	usbd_devinfo(dev, 0, devinfo, sizeof(devinfo));
d194 2
a195 1
	printf("%s: %s", devname, devinfo);
@


1.11
log
@don't call mii_pollstat() right after mii_tick() in foo_tick_task()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.10 2005/06/08 17:03:02 henning Exp $ */
d1323 1
a1396 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
@


1.10
log
@remove netns crud.
some drivers actually had hooks for SIOCSIFADDR, most just useless includes
"looks good" deraadt miod brad
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.9 2005/01/03 22:45:52 brad Exp $ */
d1489 7
a1495 10
	if (!sc->sc_link) {
		mii_pollstat(mii);
		if (mii->mii_media_status & IFM_ACTIVE &&
		    IFM_SUBTYPE(mii->mii_media_active) != IFM_NONE) {
			DPRINTF(("%s: %s: got link\n",
				 USBDEVNAME(sc->sc_dev), __func__));
			sc->sc_link++;
			if (IFQ_IS_EMPTY(&ifp->if_snd) == 0)
				   udav_start(ifp);
		}
@


1.9
log
@- make sure int is in running state before touching the multicast filters
- call foo_setmulti only instead of init'ing the chip
- don't overwrite potential error return with success when calling
ether_addmulti/ether_delmulti

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.8 2004/12/30 07:43:09 dlg Exp $ */
a81 5
#ifdef NS
#include <netns/ns.h>
#include <netns/ns_if.h>
#endif

a1233 14
#ifdef NS
		case AF_NS:
		{
			struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

			if (ns_nullhost(*ina))
				ina->x_host = *(union ns_host *)
				    LLADDR(ifp->if_sadl);
			else
				memcpy(LLADDR(ifp->if_sadl),
				    ina->x_host.c_host, ifp->if_addrlen);
			break;
		}
#endif /* NS */
@


1.8
log
@fix for some archs that don't like unaligned accesses, eg sparc64 and alpha

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.7 2004/12/26 03:48:19 jsg Exp $ */
d1285 6
a1290 4
		if (error == ENETRESET)
			udav_init(ifp);
		udav_setmulti(sc);
		error = 0;
@


1.7
log
@Properly indent with tabs rather than spaces.
Noticed by brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.6 2004/12/26 03:29:26 jsg Exp $ */
d1113 1
a1115 1
	u_int8_t *pktstat;
d1144 4
a1147 8
	/* copy data to mbuf */
	m = c->udav_mbuf;
	memcpy(mtod(m, char *), c->udav_buf, total_len);

	/* first byte in received data */
	pktstat = mtod(m, u_int8_t *);
	m_adj(m, sizeof(u_int8_t));
	DPRINTF(("%s: RX Status: 0x%02x\n", *pktstat));
d1149 1
a1149 4
	total_len = UGETW(mtod(m, u_int8_t *));
	m_adj(m, sizeof(u_int16_t));

	if (*pktstat & UDAV_RSR_LCS) {
d1155 1
a1155 1
	    *pktstat & UDAV_RSR_ERR) {
d1160 4
a1164 1
	total_len -= ETHER_CRC_LEN;
@


1.6
log
@Remove uneeded ifdefs/code.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.5 2004/12/03 14:23:18 jsg Exp $ */
d1233 3
a1235 3
        case SIOCSIFADDR:
                ifp->if_flags |= IFF_UP;
                udav_init(ifp);
d1237 1
a1237 1
                switch (ifa->ifa_addr->sa_family) {
d1239 3
a1241 3
                case AF_INET:
                        arp_ifinit(&sc->sc_ac, ifa);
                        break;
d1244 12
a1255 13
                case AF_NS:
                    {
                        struct ns_addr *ina = &IA_SNS(ifa)->sns_addr;

                        if (ns_nullhost(*ina))
                                ina->x_host = *(union ns_host *)
                                        LLADDR(ifp->if_sadl);
                        else
                                memcpy(LLADDR(ifp->if_sadl),
                                       ina->x_host.c_host,
                                       ifp->if_addrlen);
                        break;
                    }
d1257 2
a1258 2
                }
                break;
d1260 24
a1283 24
        case SIOCSIFMTU:
                if (ifr->ifr_mtu > ETHERMTU)
                        error = EINVAL;
                else
                        ifp->if_mtu = ifr->ifr_mtu;
                break;
        case SIOCSIFFLAGS:
                if (ifp->if_flags & IFF_UP) {
                        if (ifp->if_flags & IFF_RUNNING &&
                            ifp->if_flags & IFF_PROMISC) {
                                UDAV_SETBIT(sc, UDAV_RCR,
                                            UDAV_RCR_ALL|UDAV_RCR_PRMSC);
                        } else if (ifp->if_flags & IFF_RUNNING &&
                                   !(ifp->if_flags & IFF_PROMISC)) {
                                UDAV_CLRBIT(sc, UDAV_RCR,
                                            UDAV_RCR_PRMSC);
                        } else if (!(ifp->if_flags & IFF_RUNNING))
                                udav_init(ifp);
                } else {
                        if (ifp->if_flags & IFF_RUNNING)
                                udav_stop(ifp, 1);
                }
                error = 0;
                break;
d1286 8
a1293 9
                error = (cmd == SIOCADDMULTI) ?
                        ether_addmulti(ifr, &sc->sc_ac) :
                        ether_delmulti(ifr, &sc->sc_ac);
                if (error == ENETRESET) {
                        udav_init(ifp);
                }
                udav_setmulti(sc);
                error = 0;
                break;
d1295 3
a1297 3
                error = EINVAL;
                break;
        }
@


1.5
log
@URL of data sheet has changed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.4 2004/12/03 13:21:04 jsg Exp $ */
a47 9
#if defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: if_udav.c,v 1.3 2004/04/23 17:25:25 itojun Exp $");
#endif

#if defined(__NetBSD__)
#include "opt_inet.h"
#include "opt_ns.h"
#include "rnd.h"
#endif
a55 1
#if defined(__OpenBSD__)
a56 1
#endif
a73 9
#if defined(__NetBSD__)
#include <net/if_ether.h>
#ifdef INET
#include <netinet/in.h>
#include <netinet/if_inarp.h>
#endif
#endif /* defined(__NetBSD__) */

#if defined(__OpenBSD__)
a80 1
#endif /* defined(__OpenBSD__) */
a266 1
#if defined(__OpenBSD__)
a267 1
#endif
a276 4
#if defined(__NetBSD__)
	ifp->if_init = udav_init;
	ifp->if_stop = udav_stop;
#endif
a632 1
#if defined(__OpenBSD__)
a633 3
#elif defined(__NetBSD__)
        eaddr = LLADDR(ifp->if_sadl);
#endif
a784 3
#if defined(__NetBSD__)
	ETHER_FIRST_MULTI(step, &sc->sc_ec, enm);
#else
a785 1
#endif
a1232 1
#if defined(__OpenBSD__)
a1299 11
#else
	default:
		error = ether_ioctl(ifp, cmd, data);
		if (error == ENETRESET) {
			udav_setmulti(sc);
			error = 0;
		}
		break;
	}
#endif /* defined(__OpenBSD__) */

a1536 3
#if defined(__NetBSD__)
	lockmgr(&sc->sc_mii_lock, LK_EXCLUSIVE, NULL);
#else
a1537 1
#endif
a1545 3
#if defined(__NetBSD__)
	lockmgr(&sc->sc_mii_lock, LK_RELEASE, NULL);
#else
a1546 1
#endif
@


1.4
log
@Don't need to set ifp->if_mtu as ether_ifattach does this for us.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.3 2004/11/11 22:46:30 deraadt Exp $ */
d37 1
a37 1
 *   http://www.davicom.com.tw/big5/download/Data%20Sheet/DM9601-DS-F01-062202s.pdf
@


1.3
log
@strlcpy
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.2 2004/10/05 14:12:56 deraadt Exp $ */
a294 1
	ifp->if_mtu = ETHERMTU;
@


1.2
log
@pretty dmesg print
@
text
@d1 1
a1 1
/*	$OpenBSD: if_udav.c,v 1.1 2004/10/05 02:01:18 jsg Exp $ */
d296 1
a296 1
	strncpy(ifp->if_xname, devname, IFNAMSIZ);
@


1.1
log
@Port of NetBSD's udav driver for Davicom USB DM960 based Ethernet.
Thanks to Mark Uemura for donating several of these adapters.
Tested by and ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: $ */
d220 1
a220 1
	printf("%s: %s\n", devname, devinfo);
d225 1
a225 1
		printf("%s: setting config no failed\n", devname);
d236 1
a236 2
		printf("%s: failed to get interface, err=%s\n", devname,
		       usbd_errstr(err));
d252 1
a252 1
			printf("%s: couldn't get endpoint %d\n", devname, i);
d268 1
a268 1
		printf("%s: missing endpoint\n", devname);
d280 1
a280 1
		printf("%s: read MAC address failed\n", devname);
d286 1
a286 1
	printf("%s: address %s\n", devname, ether_sprintf(eaddr));
@

