head	1.80;
access;
symbols
	OPENBSD_6_0:1.77.0.4
	OPENBSD_6_0_BASE:1.77
	OPENBSD_5_9:1.76.0.2
	OPENBSD_5_9_BASE:1.76
	OPENBSD_5_8:1.69.0.4
	OPENBSD_5_8_BASE:1.69
	OPENBSD_5_7:1.66.0.2
	OPENBSD_5_7_BASE:1.66
	OPENBSD_5_6:1.64.0.4
	OPENBSD_5_6_BASE:1.64
	OPENBSD_5_5:1.60.0.4
	OPENBSD_5_5_BASE:1.60
	OPENBSD_5_4:1.58.0.2
	OPENBSD_5_4_BASE:1.58
	OPENBSD_5_3:1.56.0.8
	OPENBSD_5_3_BASE:1.56
	OPENBSD_5_2:1.56.0.6
	OPENBSD_5_2_BASE:1.56
	OPENBSD_5_1_BASE:1.56
	OPENBSD_5_1:1.56.0.4
	OPENBSD_5_0:1.56.0.2
	OPENBSD_5_0_BASE:1.56
	OPENBSD_4_9:1.55.0.2
	OPENBSD_4_9_BASE:1.55
	OPENBSD_4_8:1.49.0.2
	OPENBSD_4_8_BASE:1.49
	OPENBSD_4_7:1.48.0.2
	OPENBSD_4_7_BASE:1.48
	OPENBSD_4_6:1.44.0.4
	OPENBSD_4_6_BASE:1.44
	OPENBSD_4_5:1.42.0.2
	OPENBSD_4_5_BASE:1.42
	OPENBSD_4_4:1.36.0.2
	OPENBSD_4_4_BASE:1.36
	OPENBSD_4_3:1.34.0.2
	OPENBSD_4_3_BASE:1.34;
locks; strict;
comment	@ * @;


1.80
date	2017.03.26.15.31.15;	author deraadt;	state Exp;
branches;
next	1.79;
commitid	x5RWYO05Q3UFL5Oq;

1.79
date	2017.01.22.10.17.39;	author dlg;	state Exp;
branches;
next	1.78;
commitid	VyLWTsbepAOk7VQM;

1.78
date	2016.11.06.12.58.01;	author mpi;	state Exp;
branches;
next	1.77;
commitid	xlY19nmD0cBL53l1;

1.77
date	2016.04.13.11.03.37;	author mpi;	state Exp;
branches;
next	1.76;
commitid	gWZDkudwxydTq8x4;

1.76
date	2015.12.11.16.07.02;	author mpi;	state Exp;
branches;
next	1.75;
commitid	fbhqfhfdKxBcsetK;

1.75
date	2015.11.25.03.10.00;	author dlg;	state Exp;
branches;
next	1.74;
commitid	B0kwmVGiD5DVx4kv;

1.74
date	2015.11.24.13.45.07;	author mpi;	state Exp;
branches;
next	1.73;
commitid	FuSD2mFDJWATHIDx;

1.73
date	2015.11.24.13.33.18;	author mpi;	state Exp;
branches;
next	1.72;
commitid	5DvsamK0GblTp8ww;

1.72
date	2015.11.11.10.07.25;	author mpi;	state Exp;
branches;
next	1.71;
commitid	9FpLdI4B7Tx69D1N;

1.71
date	2015.11.04.12.12.00;	author dlg;	state Exp;
branches;
next	1.70;
commitid	YT6fyIEviv9qwbl6;

1.70
date	2015.10.25.12.11.56;	author mpi;	state Exp;
branches;
next	1.69;
commitid	pwYnMC1gOKohmeGw;

1.69
date	2015.05.02.10.44.29;	author jsg;	state Exp;
branches;
next	1.68;
commitid	bVmCCZZhAZIaB19k;

1.68
date	2015.04.13.08.45.48;	author mpi;	state Exp;
branches;
next	1.67;
commitid	aiRvgNOa4qke9vft;

1.67
date	2015.03.14.03.38.49;	author jsg;	state Exp;
branches;
next	1.66;
commitid	p4LJxGKbi0BU2cG6;

1.66
date	2014.12.22.02.28.52;	author tedu;	state Exp;
branches;
next	1.65;
commitid	yM2VFFhpDTeFQlve;

1.65
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.64;
commitid	LS2TNeCue5R9L67C;

1.64
date	2014.07.13.15.52.49;	author mpi;	state Exp;
branches;
next	1.63;
commitid	Pclvgy2Z4XV9hveD;

1.63
date	2014.07.12.18.48.52;	author tedu;	state Exp;
branches;
next	1.62;
commitid	OBNa5kfxQ2UXoiIw;

1.62
date	2014.07.12.07.59.23;	author mpi;	state Exp;
branches;
next	1.61;
commitid	b0VSac5dnnsxcDao;

1.61
date	2014.03.19.10.09.19;	author mpi;	state Exp;
branches;
next	1.60;

1.60
date	2013.08.21.05.21.45;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2013.08.07.01.06.42;	author bluhm;	state Exp;
branches;
next	1.58;

1.58
date	2013.04.26.14.43.22;	author mpi;	state Exp;
branches;
next	1.57;

1.57
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.56;

1.56
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.55;

1.55
date	2011.01.25.20.03.35;	author jakemsr;	state Exp;
branches;
next	1.54;

1.54
date	2010.12.06.04.41.39;	author jakemsr;	state Exp;
branches;
next	1.53;

1.53
date	2010.10.27.17.51.11;	author jakemsr;	state Exp;
branches;
next	1.52;

1.52
date	2010.10.23.16.14.07;	author jakemsr;	state Exp;
branches;
next	1.51;

1.51
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.50;

1.50
date	2010.08.27.17.08.01;	author jsg;	state Exp;
branches;
next	1.49;

1.49
date	2010.04.20.22.05.43;	author tedu;	state Exp;
branches;
next	1.48;

1.48
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.47;

1.47
date	2009.08.10.20.02.19;	author deraadt;	state Exp;
branches;
next	1.46;

1.46
date	2009.08.03.09.33.10;	author blambert;	state Exp;
branches;
next	1.45;

1.45
date	2009.08.02.10.38.34;	author miod;	state Exp;
branches;
next	1.44;

1.44
date	2009.04.09.09.15.24;	author mglocker;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.27.11.11.37;	author jsg;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.14.20.05.09;	author chl;	state Exp;
branches;
next	1.41;

1.41
date	2008.11.27.14.05.18;	author kevlo;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.25.08.25.02;	author kevlo;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.14.18.01.53;	author naddy;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.27.10.34.24;	author damien;	state Exp;
branches;
next	1.37;

1.37
date	2008.08.08.12.20.24;	author thib;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.21.18.43.19;	author damien;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.16.18.32.15;	author damien;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.16.21.56.43;	author mglocker;	state Exp;
branches;
next	1.33;

1.33
date	2008.02.02.13.48.44;	author mglocker;	state Exp;
branches;
next	1.32;

1.32
date	2008.01.27.21.05.59;	author mglocker;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.25.07.12.41;	author mglocker;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.24.22.35.08;	author mglocker;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.24.21.44.32;	author mglocker;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.24.21.24.05;	author mglocker;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.22.21.26.25;	author mglocker;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.21.19.37.36;	author mglocker;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.20.23.34.12;	author mglocker;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.20.23.31.50;	author mglocker;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.20.11.55.07;	author mglocker;	state Exp;
branches;
next	1.22;

1.22
date	2008.01.20.10.49.55;	author mglocker;	state Exp;
branches;
next	1.21;

1.21
date	2008.01.20.00.14.41;	author mglocker;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.19.10.39.22;	author mglocker;	state Exp;
branches;
next	1.19;

1.19
date	2008.01.18.21.31.16;	author mglocker;	state Exp;
branches;
next	1.18;

1.18
date	2008.01.17.20.46.51;	author mglocker;	state Exp;
branches;
next	1.17;

1.17
date	2008.01.17.07.23.45;	author mglocker;	state Exp;
branches;
next	1.16;

1.16
date	2008.01.04.11.50.14;	author mglocker;	state Exp;
branches;
next	1.15;

1.15
date	2008.01.04.10.04.07;	author mglocker;	state Exp;
branches;
next	1.14;

1.14
date	2008.01.03.14.47.19;	author mglocker;	state Exp;
branches;
next	1.13;

1.13
date	2008.01.02.10.07.26;	author mglocker;	state Exp;
branches;
next	1.12;

1.12
date	2008.01.01.20.20.30;	author mglocker;	state Exp;
branches;
next	1.11;

1.11
date	2008.01.01.11.43.48;	author mglocker;	state Exp;
branches;
next	1.10;

1.10
date	2008.01.01.10.10.20;	author mglocker;	state Exp;
branches;
next	1.9;

1.9
date	2008.01.01.10.03.44;	author mglocker;	state Exp;
branches;
next	1.8;

1.8
date	2007.12.22.11.16.40;	author mglocker;	state Exp;
branches;
next	1.7;

1.7
date	2007.12.20.20.38.31;	author mglocker;	state Exp;
branches;
next	1.6;

1.6
date	2007.12.19.22.43.59;	author mglocker;	state Exp;
branches;
next	1.5;

1.5
date	2007.12.19.22.37.01;	author mglocker;	state Exp;
branches;
next	1.4;

1.4
date	2007.12.17.19.01.41;	author mglocker;	state Exp;
branches;
next	1.3;

1.3
date	2007.12.17.00.10.03;	author mglocker;	state Exp;
branches;
next	1.2;

1.2
date	2007.12.16.18.19.57;	author mglocker;	state Exp;
branches;
next	1.1;

1.1
date	2007.12.16.09.05.53;	author mglocker;	state Exp;
branches;
next	;


desc
@@


1.80
log
@Add sizes to various free(9) calls.  Fixing the simpler ones first.
ok natano visa
@
text
@/*	$OpenBSD: if_upgt.c,v 1.79 2017/01/22 10:17:39 dlg Exp $ */

/*
 * Copyright (c) 2007 Marcus Glocker <mglocker@@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "bpfilter.h"

#include <sys/param.h>
#include <sys/sockio.h>
#include <sys/mbuf.h>
#include <sys/kernel.h>
#include <sys/socket.h>
#include <sys/systm.h>
#include <sys/timeout.h>
#include <sys/conf.h>
#include <sys/device.h>
#include <sys/endian.h>

#include <machine/intr.h>

#if NBPFILTER > 0
#include <net/bpf.h>
#endif
#include <net/if.h>
#include <net/if_dl.h>
#include <net/if_media.h>

#include <netinet/in.h>
#include <netinet/if_ether.h>

#include <net80211/ieee80211_var.h>
#include <net80211/ieee80211_radiotap.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdi_util.h>
#include <dev/usb/usbdevs.h>

#include <dev/usb/if_upgtvar.h>

/*
 * Driver for the USB PrismGT devices.
 *
 * For now just USB 2.0 devices with the GW3887 chipset are supported.
 * The driver has been written based on the firmware version 2.13.1.0_LM87.
 *
 * TODO's:
 * - Fix MONITOR mode (MAC filter).
 * - Add HOSTAP mode.
 * - Add IBSS mode.
 * - Support the USB 1.0 devices (NET2280, ISL3880, ISL3886 chipsets).
 *
 * Parts of this driver has been influenced by reading the p54u driver
 * written by Jean-Baptiste Note <jean-baptiste.note@@m4x.org> and
 * Sebastien Bourdeauducq <lekernel@@prism54.org>.
 */

#ifdef UPGT_DEBUG
int upgt_debug = 2;
#define DPRINTF(l, x...) do { if ((l) <= upgt_debug) printf(x); } while (0)
#else
#define DPRINTF(l, x...)
#endif

/*
 * Prototypes.
 */
int		upgt_match(struct device *, void *, void *);
void		upgt_attach(struct device *, struct device *, void *);
void		upgt_attach_hook(struct device *);
int		upgt_detach(struct device *, int);

int		upgt_device_type(struct upgt_softc *, uint16_t, uint16_t);
int		upgt_device_init(struct upgt_softc *);
int		upgt_mem_init(struct upgt_softc *);
uint32_t	upgt_mem_alloc(struct upgt_softc *);
void		upgt_mem_free(struct upgt_softc *, uint32_t);
int		upgt_fw_alloc(struct upgt_softc *);
void		upgt_fw_free(struct upgt_softc *);
int		upgt_fw_verify(struct upgt_softc *);
int		upgt_fw_load(struct upgt_softc *);
int		upgt_fw_copy(char *, char *, int);
int		upgt_eeprom_read(struct upgt_softc *);
int		upgt_eeprom_parse(struct upgt_softc *);
void		upgt_eeprom_parse_hwrx(struct upgt_softc *, uint8_t *);
void		upgt_eeprom_parse_freq3(struct upgt_softc *, uint8_t *, int);
void		upgt_eeprom_parse_freq4(struct upgt_softc *, uint8_t *, int);
void		upgt_eeprom_parse_freq6(struct upgt_softc *, uint8_t *, int);

int		upgt_ioctl(struct ifnet *, u_long, caddr_t);
int		upgt_init(struct ifnet *);
void		upgt_stop(struct upgt_softc *);
int		upgt_media_change(struct ifnet *);
void		upgt_newassoc(struct ieee80211com *, struct ieee80211_node *,
		    int);
int		upgt_newstate(struct ieee80211com *, enum ieee80211_state, int);
void		upgt_newstate_task(void *);
void		upgt_next_scan(void *);
void		upgt_start(struct ifnet *);
void		upgt_watchdog(struct ifnet *);
void		upgt_tx_task(void *);
void		upgt_tx_done(struct upgt_softc *, uint8_t *);
void		upgt_rx_cb(struct usbd_xfer *, void *, usbd_status);
void		upgt_rx(struct upgt_softc *, uint8_t *, int);
void		upgt_setup_rates(struct upgt_softc *);
uint8_t		upgt_rx_rate(struct upgt_softc *, const int);
int		upgt_set_macfilter(struct upgt_softc *, uint8_t state);
int		upgt_set_channel(struct upgt_softc *, unsigned);
void		upgt_set_led(struct upgt_softc *, int);
void		upgt_set_led_blink(void *);
int		upgt_get_stats(struct upgt_softc *);

int		upgt_alloc_tx(struct upgt_softc *);
int		upgt_alloc_rx(struct upgt_softc *);
int		upgt_alloc_cmd(struct upgt_softc *);
void		upgt_free_tx(struct upgt_softc *);
void		upgt_free_rx(struct upgt_softc *);
void		upgt_free_cmd(struct upgt_softc *);
int		upgt_bulk_xmit(struct upgt_softc *, struct upgt_data *,
		    struct usbd_pipe *, uint32_t *, int);

void		upgt_hexdump(void *, int);
uint32_t	upgt_crc32_le(const void *, size_t);
uint32_t	upgt_chksum_le(const uint32_t *, size_t);

struct cfdriver upgt_cd = {
	NULL, "upgt", DV_IFNET
};

const struct cfattach upgt_ca = {
	sizeof(struct upgt_softc), upgt_match, upgt_attach, upgt_detach
};

static const struct usb_devno upgt_devs_1[] = {
	/* version 1 devices */
	{ USB_VENDOR_ALCATELT,		USB_PRODUCT_ALCATELT_ST120G }
};

static const struct usb_devno upgt_devs_2[] = {
	/* version 2 devices */
	{ USB_VENDOR_ACCTON,		USB_PRODUCT_ACCTON_PRISM_GT },
	{ USB_VENDOR_ALCATELT,		USB_PRODUCT_ALCATELT_ST121G },
	{ USB_VENDOR_BELKIN,		USB_PRODUCT_BELKIN_F5D7050 },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54AG },
	{ USB_VENDOR_CISCOLINKSYS,	USB_PRODUCT_CISCOLINKSYS_WUSB54GV2 },
	{ USB_VENDOR_CONCEPTRONIC,	USB_PRODUCT_CONCEPTRONIC_PRISM_GT },
	{ USB_VENDOR_DELL,		USB_PRODUCT_DELL_PRISM_GT_1 },
	{ USB_VENDOR_DELL,		USB_PRODUCT_DELL_PRISM_GT_2 },
	{ USB_VENDOR_DLINK,		USB_PRODUCT_DLINK_DWLG122A2 },
	{ USB_VENDOR_FSC,		USB_PRODUCT_FSC_E5400 },
	{ USB_VENDOR_GLOBESPAN,		USB_PRODUCT_GLOBESPAN_PRISM_GT_1 },
	{ USB_VENDOR_GLOBESPAN,		USB_PRODUCT_GLOBESPAN_PRISM_GT_2 },
	{ USB_VENDOR_INTERSIL,		USB_PRODUCT_INTERSIL_PRISM_GT },
	{ USB_VENDOR_PHEENET,		USB_PRODUCT_PHEENET_GWU513 },
	{ USB_VENDOR_PHILIPS,		USB_PRODUCT_PHILIPS_CPWUA054 },
	{ USB_VENDOR_SMC,		USB_PRODUCT_SMC_2862WG },
	{ USB_VENDOR_USR,		USB_PRODUCT_USR_USR5422 },
	{ USB_VENDOR_WISTRONNEWEB,	USB_PRODUCT_WISTRONNEWEB_UR045G },
	{ USB_VENDOR_XYRATEX,		USB_PRODUCT_XYRATEX_PRISM_GT_1 },
	{ USB_VENDOR_XYRATEX,		USB_PRODUCT_XYRATEX_PRISM_GT_2 },
	{ USB_VENDOR_ZCOM,		USB_PRODUCT_ZCOM_MD40900 },
	{ USB_VENDOR_ZCOM,		USB_PRODUCT_ZCOM_XG703A }
};

int
upgt_match(struct device *parent, void *match, void *aux)
{
	struct usb_attach_arg *uaa = aux;

	if (uaa->iface == NULL || uaa->configno != UPGT_CONFIG_NO)
		return (UMATCH_NONE);

	if (usb_lookup(upgt_devs_1, uaa->vendor, uaa->product) != NULL)
		return (UMATCH_VENDOR_PRODUCT);

	if (usb_lookup(upgt_devs_2, uaa->vendor, uaa->product) != NULL)
		return (UMATCH_VENDOR_PRODUCT);

	return (UMATCH_NONE);
}

void
upgt_attach(struct device *parent, struct device *self, void *aux)
{
	struct upgt_softc *sc = (struct upgt_softc *)self;
	struct usb_attach_arg *uaa = aux;
	usb_interface_descriptor_t *id;
	usb_endpoint_descriptor_t *ed;
	usbd_status error;
	int i;

	/*
	 * Attach USB device.
	 */
	sc->sc_udev = uaa->device;

	/* check device type */
	if (upgt_device_type(sc, uaa->vendor, uaa->product) != 0)
		return;

	/* get the first interface handle */
	error = usbd_device2interface_handle(sc->sc_udev, UPGT_IFACE_INDEX,
	    &sc->sc_iface);
	if (error != 0) {
		printf("%s: could not get interface handle!\n",
		    sc->sc_dev.dv_xname);
		return;
	}

	/* find endpoints */
	id = usbd_get_interface_descriptor(sc->sc_iface);
	sc->sc_rx_no = sc->sc_tx_no = -1;
	for (i = 0; i < id->bNumEndpoints; i++) {
		ed = usbd_interface2endpoint_descriptor(sc->sc_iface, i);
		if (ed == NULL) {
			printf("%s: no endpoint descriptor for iface %d!\n",
			    sc->sc_dev.dv_xname, i);
			return;
		}

		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_OUT &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_tx_no = ed->bEndpointAddress;
		if (UE_GET_DIR(ed->bEndpointAddress) == UE_DIR_IN &&
		    UE_GET_XFERTYPE(ed->bmAttributes) == UE_BULK)
			sc->sc_rx_no = ed->bEndpointAddress;

		/*
		 * 0x01 TX pipe
		 * 0x81 RX pipe
		 *
		 * Deprecated scheme (not used with fw version >2.5.6.x):
		 * 0x02 TX MGMT pipe
		 * 0x82 TX MGMT pipe
		 */
		if (sc->sc_tx_no != -1 && sc->sc_rx_no != -1)
			break;
	}
	if (sc->sc_rx_no == -1 || sc->sc_tx_no == -1) {
		printf("%s: missing endpoint!\n", sc->sc_dev.dv_xname);
		return;
	}

	/* setup tasks and timeouts */
	usb_init_task(&sc->sc_task_newstate, upgt_newstate_task, sc,
	    USB_TASK_TYPE_GENERIC);
	usb_init_task(&sc->sc_task_tx, upgt_tx_task, sc, USB_TASK_TYPE_GENERIC);
	timeout_set(&sc->scan_to, upgt_next_scan, sc);
	timeout_set(&sc->led_to, upgt_set_led_blink, sc);

	/*
	 * Open TX and RX USB bulk pipes.
	 */
	error = usbd_open_pipe(sc->sc_iface, sc->sc_tx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_tx_pipeh);
	if (error != 0) {
		printf("%s: could not open TX pipe: %s!\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}
	error = usbd_open_pipe(sc->sc_iface, sc->sc_rx_no, USBD_EXCLUSIVE_USE,
	    &sc->sc_rx_pipeh);
	if (error != 0) {
		printf("%s: could not open RX pipe: %s!\n",
		    sc->sc_dev.dv_xname, usbd_errstr(error));
		goto fail;
	}

	/*
	 * Allocate TX, RX, and CMD xfers.
	 */
	if (upgt_alloc_tx(sc) != 0)
		goto fail;
	if (upgt_alloc_rx(sc) != 0)
		goto fail;
	if (upgt_alloc_cmd(sc) != 0)
		goto fail;

	/*
	 * We need the firmware loaded to complete the attach.
	 */
	config_mountroot(self, upgt_attach_hook);

	return;
fail:
	printf("%s: %s failed!\n", sc->sc_dev.dv_xname, __func__);
}

void
upgt_attach_hook(struct device *self)
{
	struct upgt_softc *sc = (struct upgt_softc *)self;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	usbd_status error;
	int i;

	/*
	 * Load firmware file into memory.
	 */
	if (upgt_fw_alloc(sc) != 0)
		goto fail;

	/*
	 * Initialize the device.
	 */
	if (upgt_device_init(sc) != 0)
		goto fail;

	/*
	 * Verify the firmware.
	 */
	if (upgt_fw_verify(sc) != 0)
		goto fail;

	/*
	 * Calculate device memory space.
	 */
	if (sc->sc_memaddr_frame_start == 0 || sc->sc_memaddr_frame_end == 0) {
		printf("%s: could not find memory space addresses on FW!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	sc->sc_memaddr_frame_end -= UPGT_MEMSIZE_RX + 1;
	sc->sc_memaddr_rx_start = sc->sc_memaddr_frame_end + 1;

	DPRINTF(1, "%s: memory address frame start=0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_memaddr_frame_start);
	DPRINTF(1, "%s: memory address frame end=0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_memaddr_frame_end);
	DPRINTF(1, "%s: memory address rx start=0x%08x\n",
	    sc->sc_dev.dv_xname, sc->sc_memaddr_rx_start);

	upgt_mem_init(sc);

	/*
	 * Load the firmware.
	 */
	if (upgt_fw_load(sc) != 0)
		goto fail;

	/*
	 * Startup the RX pipe.
	 */
	struct upgt_data *data_rx = &sc->rx_data;

	usbd_setup_xfer(data_rx->xfer, sc->sc_rx_pipeh, data_rx, data_rx->buf,
	    MCLBYTES, USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, upgt_rx_cb);
	error = usbd_transfer(data_rx->xfer);
	if (error != 0 && error != USBD_IN_PROGRESS) {
		printf("%s: could not queue RX transfer!\n",
		    sc->sc_dev.dv_xname);
		goto fail;
	}
	usbd_delay_ms(sc->sc_udev, 100);

	/*
	 * Read the whole EEPROM content and parse it.
	 */
	if (upgt_eeprom_read(sc) != 0)
		goto fail;
	if (upgt_eeprom_parse(sc) != 0)
		goto fail;

	/*
	 * Setup the 802.11 device.
	 */
	ic->ic_phytype = IEEE80211_T_OFDM;
	ic->ic_opmode = IEEE80211_M_STA;
	ic->ic_state = IEEE80211_S_INIT;
	ic->ic_caps =
	    IEEE80211_C_MONITOR |
	    IEEE80211_C_SHPREAMBLE |
	    IEEE80211_C_SHSLOT |
	    IEEE80211_C_WEP |
	    IEEE80211_C_RSN;

	ic->ic_sup_rates[IEEE80211_MODE_11B] = ieee80211_std_rateset_11b;
	ic->ic_sup_rates[IEEE80211_MODE_11G] = ieee80211_std_rateset_11g;

	for (i = 1; i <= 14; i++) {
		ic->ic_channels[i].ic_freq =
		    ieee80211_ieee2mhz(i, IEEE80211_CHAN_2GHZ);
		ic->ic_channels[i].ic_flags =
		    IEEE80211_CHAN_CCK | IEEE80211_CHAN_OFDM |
		    IEEE80211_CHAN_DYN | IEEE80211_CHAN_2GHZ;
	}

	ifp->if_softc = sc;
	ifp->if_flags = IFF_BROADCAST | IFF_SIMPLEX | IFF_MULTICAST;
	ifp->if_ioctl = upgt_ioctl;
	ifp->if_start = upgt_start;
	ifp->if_watchdog = upgt_watchdog;
	memcpy(ifp->if_xname, sc->sc_dev.dv_xname, IFNAMSIZ);

	if_attach(ifp);
	ieee80211_ifattach(ifp);
	ic->ic_newassoc = upgt_newassoc;

	sc->sc_newstate = ic->ic_newstate;
	ic->ic_newstate = upgt_newstate;
	ieee80211_media_init(ifp, upgt_media_change, ieee80211_media_status);

#if NBPFILTER > 0
	bpfattach(&sc->sc_drvbpf, ifp, DLT_IEEE802_11_RADIO,
	    sizeof(struct ieee80211_frame) + IEEE80211_RADIOTAP_HDRLEN);

	sc->sc_rxtap_len = sizeof(sc->sc_rxtapu);
	sc->sc_rxtap.wr_ihdr.it_len = htole16(sc->sc_rxtap_len);
	sc->sc_rxtap.wr_ihdr.it_present = htole32(UPGT_RX_RADIOTAP_PRESENT);

	sc->sc_txtap_len = sizeof(sc->sc_txtapu);
	sc->sc_txtap.wt_ihdr.it_len = htole16(sc->sc_txtap_len);
	sc->sc_txtap.wt_ihdr.it_present = htole32(UPGT_TX_RADIOTAP_PRESENT);
#endif

	printf("%s: address %s\n",
	    sc->sc_dev.dv_xname, ether_sprintf(ic->ic_myaddr));

	return;
fail:
	printf("%s: %s failed!\n", sc->sc_dev.dv_xname, __func__);
}

int
upgt_detach(struct device *self, int flags)
{
	struct upgt_softc *sc = (struct upgt_softc *)self;
	struct ifnet *ifp = &sc->sc_ic.ic_if;
	int s;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	s = splusb();

	/* abort and close TX / RX pipes */
	if (sc->sc_tx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_tx_pipeh);
		usbd_close_pipe(sc->sc_tx_pipeh);
	}
	if (sc->sc_rx_pipeh != NULL) {
		usbd_abort_pipe(sc->sc_rx_pipeh);
		usbd_close_pipe(sc->sc_rx_pipeh);
	}

	/* remove tasks and timeouts */
	usb_rem_task(sc->sc_udev, &sc->sc_task_newstate);
	usb_rem_task(sc->sc_udev, &sc->sc_task_tx);
	if (timeout_initialized(&sc->scan_to))
		timeout_del(&sc->scan_to);
	if (timeout_initialized(&sc->led_to))
		timeout_del(&sc->led_to);

	/* free xfers */
	upgt_free_tx(sc);
	upgt_free_rx(sc);
	upgt_free_cmd(sc);

	/* free firmware */
	upgt_fw_free(sc);

	if (ifp->if_softc != NULL) {
		/* detach interface */
		ieee80211_ifdetach(ifp);
		if_detach(ifp);
	}

	splx(s);

	return (0);
}

int
upgt_device_type(struct upgt_softc *sc, uint16_t vendor, uint16_t product)
{
	if (usb_lookup(upgt_devs_1, vendor, product) != NULL) {
		sc->sc_device_type = 1;
		/* XXX */
		printf("%s: version 1 devices not supported yet!\n",
		    sc->sc_dev.dv_xname);
		return (1);
	} else {
		sc->sc_device_type = 2;
	}

	return (0);
}

int
upgt_device_init(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;
	char init_cmd[] = { 0x7e, 0x7e, 0x7e, 0x7e };
	int len;

	len = sizeof(init_cmd);
	bcopy(init_cmd, data_cmd->buf, len);
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not send device init string!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}
	usbd_delay_ms(sc->sc_udev, 100);

	DPRINTF(1, "%s: device initialized\n", sc->sc_dev.dv_xname);

	return (0);
}

int
upgt_mem_init(struct upgt_softc *sc)
{
	int i;

	for (i = 0; i < UPGT_MEMORY_MAX_PAGES; i++) {
		sc->sc_memory.page[i].used = 0;

		if (i == 0) {
			/*
			 * The first memory page is always reserved for
			 * command data.
			 */
			sc->sc_memory.page[i].addr =
			    sc->sc_memaddr_frame_start + MCLBYTES;
		} else {
			sc->sc_memory.page[i].addr =
			    sc->sc_memory.page[i - 1].addr + MCLBYTES;
		}

		if (sc->sc_memory.page[i].addr + MCLBYTES >=
		    sc->sc_memaddr_frame_end)
			break;

		DPRINTF(2, "%s: memory address page %d=0x%08x\n",
		    sc->sc_dev.dv_xname, i, sc->sc_memory.page[i].addr);
	}

	sc->sc_memory.pages = i;

	DPRINTF(2, "%s: memory pages=%d\n",
	    sc->sc_dev.dv_xname, sc->sc_memory.pages);

	return (0);
}

uint32_t
upgt_mem_alloc(struct upgt_softc *sc)
{
	int i;

	for (i = 0; i < sc->sc_memory.pages; i++) {
		if (sc->sc_memory.page[i].used == 0) {
			sc->sc_memory.page[i].used = 1;
			return (sc->sc_memory.page[i].addr);
		}
	}

	return (0);
}

void
upgt_mem_free(struct upgt_softc *sc, uint32_t addr)
{
	int i;

	for (i = 0; i < sc->sc_memory.pages; i++) {
		if (sc->sc_memory.page[i].addr == addr) {
			sc->sc_memory.page[i].used = 0;
			return;
		}
	}

	printf("%s: could not free memory address 0x%08x!\n",
	    sc->sc_dev.dv_xname, addr);
}


int
upgt_fw_alloc(struct upgt_softc *sc)
{
	const char *name = "upgt-gw3887";
	int error;

	if (sc->sc_fw == NULL) {
		error = loadfirmware(name, &sc->sc_fw, &sc->sc_fw_size);
		if (error != 0) {
			printf("%s: error %d, could not read firmware %s!\n",
			    sc->sc_dev.dv_xname, error, name);
			return (EIO);
		}
	}

	DPRINTF(1, "%s: firmware %s allocated\n", sc->sc_dev.dv_xname, name);

	return (0);
}

void
upgt_fw_free(struct upgt_softc *sc)
{
	if (sc->sc_fw != NULL) {
		free(sc->sc_fw, M_DEVBUF, sc->sc_fw_size);
		sc->sc_fw = NULL;
		DPRINTF(1, "%s: firmware freed\n", sc->sc_dev.dv_xname);
	}
}

int
upgt_fw_verify(struct upgt_softc *sc)
{
	struct upgt_fw_bra_option *bra_option;
	uint32_t bra_option_type, bra_option_len;
	uint32_t *uc;
	int offset, bra_end = 0;

	/*
	 * Seek to beginning of Boot Record Area (BRA).
	 */
	for (offset = 0; offset < sc->sc_fw_size; offset += sizeof(*uc)) {
		uc = (uint32_t *)(sc->sc_fw + offset);
		if (*uc == 0)
			break;
	}
	for (; offset < sc->sc_fw_size; offset += sizeof(*uc)) {
		uc = (uint32_t *)(sc->sc_fw + offset);
		if (*uc != 0)
			break;
	}
	if (offset == sc->sc_fw_size) { 
		printf("%s: firmware Boot Record Area not found!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}
	DPRINTF(1, "%s: firmware Boot Record Area found at offset %d\n",
	    sc->sc_dev.dv_xname, offset);

	/*
	 * Parse Boot Record Area (BRA) options.
	 */
	while (offset < sc->sc_fw_size && bra_end == 0) {
		/* get current BRA option */
		bra_option = (struct upgt_fw_bra_option *)(sc->sc_fw + offset);
		bra_option_type = letoh32(bra_option->type);
		bra_option_len = letoh32(bra_option->len) * sizeof(*uc);

		switch (bra_option_type) {
		case UPGT_BRA_TYPE_FW:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_FW len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);

			if (bra_option_len != UPGT_BRA_FWTYPE_SIZE) {
				printf("%s: wrong UPGT_BRA_TYPE_FW len!\n",
				    sc->sc_dev.dv_xname);
				return (EIO);
			}
			if (memcmp(UPGT_BRA_FWTYPE_LM86, bra_option->data,
			    bra_option_len) == 0) {
				sc->sc_fw_type = UPGT_FWTYPE_LM86;
				break;
			}
			if (memcmp(UPGT_BRA_FWTYPE_LM87, bra_option->data,
			    bra_option_len) == 0) {
				sc->sc_fw_type = UPGT_FWTYPE_LM87;
				break;
			}
			if (memcmp(UPGT_BRA_FWTYPE_FMAC, bra_option->data,
			    bra_option_len) == 0) {
				sc->sc_fw_type = UPGT_FWTYPE_FMAC;
				break;
			}
			printf("%s: unsupported firmware type!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		case UPGT_BRA_TYPE_VERSION:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_VERSION len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);
			break;
		case UPGT_BRA_TYPE_DEPIF:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_DEPIF len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);
			break;
		case UPGT_BRA_TYPE_EXPIF:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_EXPIF len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);
			break;
		case UPGT_BRA_TYPE_DESCR:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_DESCR len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);

			struct upgt_fw_bra_descr *descr =
				(struct upgt_fw_bra_descr *)bra_option->data;

			sc->sc_memaddr_frame_start =
			    letoh32(descr->memaddr_space_start);
			sc->sc_memaddr_frame_end =
			    letoh32(descr->memaddr_space_end);

			DPRINTF(2, "%s: memory address space start=0x%08x\n",
			    sc->sc_dev.dv_xname, sc->sc_memaddr_frame_start);
			DPRINTF(2, "%s: memory address space end=0x%08x\n",
			    sc->sc_dev.dv_xname, sc->sc_memaddr_frame_end);
			break;
		case UPGT_BRA_TYPE_END:
			DPRINTF(1, "%s: UPGT_BRA_TYPE_END len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);
			bra_end = 1;
			break;
		default:
			DPRINTF(1, "%s: unknown BRA option len=%d\n",
			    sc->sc_dev.dv_xname, bra_option_len);
			return (EIO);
		}

		/* jump to next BRA option */
		offset += sizeof(struct upgt_fw_bra_option) + bra_option_len;
	}

	DPRINTF(1, "%s: firmware verified\n", sc->sc_dev.dv_xname);

	return (0);
}

int
upgt_fw_load(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_data *data_rx = &sc->rx_data;
	char start_fwload_cmd[] = { 0x3c, 0x0d };
	int offset, bsize, n, i, len;
	uint32_t crc32;

	/* send firmware start load command */
	len = sizeof(start_fwload_cmd);
	bcopy(start_fwload_cmd, data_cmd->buf, len);
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not send start_firmware_load command!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	/* send X2 header */
	len = sizeof(struct upgt_fw_x2_header);
	struct upgt_fw_x2_header *x2 = data_cmd->buf;
	bcopy(UPGT_X2_SIGNATURE, x2->signature, UPGT_X2_SIGNATURE_SIZE);
	x2->startaddr = htole32(UPGT_MEMADDR_FIRMWARE_START);
	x2->len = htole32(sc->sc_fw_size);
	x2->crc = upgt_crc32_le(data_cmd->buf + UPGT_X2_SIGNATURE_SIZE,
	    sizeof(struct upgt_fw_x2_header) - UPGT_X2_SIGNATURE_SIZE -
	    sizeof(uint32_t));
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not send firmware X2 header!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	/* download firmware */
	for (offset = 0; offset < sc->sc_fw_size; offset += bsize) {
		if (sc->sc_fw_size - offset > UPGT_FW_BLOCK_SIZE)
			bsize = UPGT_FW_BLOCK_SIZE;
		else
			bsize = sc->sc_fw_size - offset;

		n = upgt_fw_copy(sc->sc_fw + offset, data_cmd->buf, bsize);

		DPRINTF(1, "%s: FW offset=%d, read=%d, sent=%d\n",
		    sc->sc_dev.dv_xname, offset, n, bsize);

		if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &bsize, 0)
		    != 0) {
			printf("%s: error while downloading firmware block!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}

		bsize = n;
	}
	DPRINTF(1, "%s: firmware downloaded\n", sc->sc_dev.dv_xname);

	/* load firmware */
	crc32 = upgt_crc32_le(sc->sc_fw, sc->sc_fw_size);
	*((uint32_t *)(data_cmd->buf)    ) = crc32;
	*((uint8_t  *)(data_cmd->buf) + 4) = 'g';
	*((uint8_t  *)(data_cmd->buf) + 5) = '\r';
	len = 6;
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not send load_firmware command!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	for (i = 0; i < UPGT_FIRMWARE_TIMEOUT; i++) {
		len = UPGT_FW_BLOCK_SIZE;
		bzero(data_rx->buf, MCLBYTES);
		if (upgt_bulk_xmit(sc, data_rx, sc->sc_rx_pipeh, &len,
		    USBD_SHORT_XFER_OK) != 0) {
			printf("%s: could not read firmware response!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}

		if (memcmp(data_rx->buf, "OK", 2) == 0)
			break;	/* firmware load was successful */
	}
	if (i == UPGT_FIRMWARE_TIMEOUT) {
		printf("%s: firmware load failed!\n", sc->sc_dev.dv_xname);
		return (EIO);
	}
	DPRINTF(1, "%s: firmware loaded\n", sc->sc_dev.dv_xname);

	return (0);
}

/*
 * While copying the version 2 firmware, we need to replace two characters:
 *
 * 0x7e -> 0x7d 0x5e
 * 0x7d -> 0x7d 0x5d
 */
int
upgt_fw_copy(char *src, char *dst, int size)
{
	int i, j;

	for (i = 0, j = 0; i < size && j < size; i++) {
		switch (src[i]) {
		case 0x7e:
			dst[j] = 0x7d;
			j++;
			dst[j] = 0x5e;
			j++;
			break;
		case 0x7d:
			dst[j] = 0x7d;
			j++;
			dst[j] = 0x5d;
			j++;
			break;
		default:
			dst[j] = src[i];
			j++;
			break;
		}
	}

	return (i);
}

int
upgt_eeprom_read(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_eeprom	*eeprom;
	int offset, block, len;

	offset = 0;
	block = UPGT_EEPROM_BLOCK_SIZE;
	while (offset < UPGT_EEPROM_SIZE) {
		DPRINTF(1, "%s: request EEPROM block (offset=%d, len=%d)\n",
		    sc->sc_dev.dv_xname, offset, block);

		/*
		 * Transmit the URB containing the CMD data.
		 */
		bzero(data_cmd->buf, MCLBYTES);

		mem = (struct upgt_lmac_mem *)data_cmd->buf;
		mem->addr = htole32(sc->sc_memaddr_frame_start +
		    UPGT_MEMSIZE_FRAME_HEAD);

		eeprom = (struct upgt_lmac_eeprom *)(mem + 1);
		eeprom->header1.flags = 0;
		eeprom->header1.type = UPGT_H1_TYPE_CTRL;
		eeprom->header1.len = htole16((
		    sizeof(struct upgt_lmac_eeprom) -
		    sizeof(struct upgt_lmac_header)) + block);

		eeprom->header2.reqid = htole32(sc->sc_memaddr_frame_start);
		eeprom->header2.type = htole16(UPGT_H2_TYPE_EEPROM);
		eeprom->header2.flags = 0;

		eeprom->offset = htole16(offset);
		eeprom->len = htole16(block);

		len = sizeof(*mem) + sizeof(*eeprom) + block;

		mem->chksum = upgt_chksum_le((uint32_t *)eeprom,
		    len - sizeof(*mem));

		if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len,
		    USBD_FORCE_SHORT_XFER) != 0) {
			printf("%s: could not transmit EEPROM data URB!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}
		if (tsleep(sc, 0, "eeprom_request", UPGT_USB_TIMEOUT)) {
			printf("%s: timeout while waiting for EEPROM data!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}

		offset += block;
		if (UPGT_EEPROM_SIZE - offset < block)
			block = UPGT_EEPROM_SIZE - offset;
	}

	return (0);
}

int
upgt_eeprom_parse(struct upgt_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct upgt_eeprom_header *eeprom_header;
	struct upgt_eeprom_option *eeprom_option;
	uint16_t option_len;
	uint16_t option_type;
	uint16_t preamble_len;
	int option_end = 0;

	/* calculate eeprom options start offset */
	eeprom_header = (struct upgt_eeprom_header *)sc->sc_eeprom;
	preamble_len = letoh16(eeprom_header->preamble_len);
	eeprom_option = (struct upgt_eeprom_option *)(sc->sc_eeprom +
	    (sizeof(struct upgt_eeprom_header) + preamble_len));

	while (!option_end) {
		/* the eeprom option length is stored in words */
		option_len =
		    (letoh16(eeprom_option->len) - 1) * sizeof(uint16_t);
		option_type =
		    letoh16(eeprom_option->type);

		switch (option_type) {
		case UPGT_EEPROM_TYPE_NAME:
			DPRINTF(1, "%s: EEPROM name len=%d\n",
			    sc->sc_dev.dv_xname, option_len);
			break;
		case UPGT_EEPROM_TYPE_SERIAL:
			DPRINTF(1, "%s: EEPROM serial len=%d\n",
			    sc->sc_dev.dv_xname, option_len);
			break;
		case UPGT_EEPROM_TYPE_MAC:
			DPRINTF(1, "%s: EEPROM mac len=%d\n",
			    sc->sc_dev.dv_xname, option_len);

			IEEE80211_ADDR_COPY(ic->ic_myaddr, eeprom_option->data);
			break;
		case UPGT_EEPROM_TYPE_HWRX:
			DPRINTF(1, "%s: EEPROM hwrx len=%d\n",
			    sc->sc_dev.dv_xname, option_len);

			upgt_eeprom_parse_hwrx(sc, eeprom_option->data);
			break;
		case UPGT_EEPROM_TYPE_CHIP:
			DPRINTF(1, "%s: EEPROM chip len=%d\n",
			    sc->sc_dev.dv_xname, option_len);
			break;
		case UPGT_EEPROM_TYPE_FREQ3:
			DPRINTF(1, "%s: EEPROM freq3 len=%d\n",
			    sc->sc_dev.dv_xname, option_len);

			upgt_eeprom_parse_freq3(sc, eeprom_option->data,
			    option_len);
			break;
		case UPGT_EEPROM_TYPE_FREQ4:
			DPRINTF(1, "%s: EEPROM freq4 len=%d\n",
			    sc->sc_dev.dv_xname, option_len);

			upgt_eeprom_parse_freq4(sc, eeprom_option->data,
			    option_len);
			break;
		case UPGT_EEPROM_TYPE_FREQ5:
			DPRINTF(1, "%s: EEPROM freq5 len=%d\n",
			    sc->sc_dev.dv_xname, option_len);
			break;
		case UPGT_EEPROM_TYPE_FREQ6:
			DPRINTF(1, "%s: EEPROM freq6 len=%d\n",
			    sc->sc_dev.dv_xname, option_len);

			upgt_eeprom_parse_freq6(sc, eeprom_option->data,
			    option_len);
			break;
		case UPGT_EEPROM_TYPE_END:
			DPRINTF(1, "%s: EEPROM end len=%d\n",
			    sc->sc_dev.dv_xname, option_len);
			option_end = 1;
			break;
		case UPGT_EEPROM_TYPE_OFF:
			DPRINTF(1, "%s: EEPROM off without end option!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		default:
			DPRINTF(1, "%s: EEPROM unknown type 0x%04x len=%d\n",
			    sc->sc_dev.dv_xname, option_type, option_len);
			break;
		}

		/* jump to next EEPROM option */
		eeprom_option = (struct upgt_eeprom_option *)
		    (eeprom_option->data + option_len);
	}

	return (0);
}

void
upgt_eeprom_parse_hwrx(struct upgt_softc *sc, uint8_t *data)
{
	struct upgt_eeprom_option_hwrx *option_hwrx;

	option_hwrx = (struct upgt_eeprom_option_hwrx *)data;

	sc->sc_eeprom_hwrx = option_hwrx->rxfilter - UPGT_EEPROM_RX_CONST;

	DPRINTF(2, "%s: hwrx option value=0x%04x\n",
	    sc->sc_dev.dv_xname, sc->sc_eeprom_hwrx);
}

void
upgt_eeprom_parse_freq3(struct upgt_softc *sc, uint8_t *data, int len)
{
	struct upgt_eeprom_freq3_header *freq3_header;
	struct upgt_lmac_freq3 *freq3;
	int i, elements, flags;
	unsigned channel;

	freq3_header = (struct upgt_eeprom_freq3_header *)data;
	freq3 = (struct upgt_lmac_freq3 *)(freq3_header + 1);

	flags = freq3_header->flags;
	elements = freq3_header->elements;

	DPRINTF(2, "%s: flags=0x%02x\n", sc->sc_dev.dv_xname, flags);
	DPRINTF(2, "%s: elements=%d\n", sc->sc_dev.dv_xname, elements);

	for (i = 0; i < elements; i++) {
		channel = ieee80211_mhz2ieee(letoh16(freq3[i].freq), 0);

		sc->sc_eeprom_freq3[channel] = freq3[i];

		DPRINTF(2, "%s: frequence=%d, channel=%d\n",
		    sc->sc_dev.dv_xname,
		    letoh16(sc->sc_eeprom_freq3[channel].freq), channel);
	}
}

void
upgt_eeprom_parse_freq4(struct upgt_softc *sc, uint8_t *data, int len)
{
	struct upgt_eeprom_freq4_header *freq4_header;
	struct upgt_eeprom_freq4_1 *freq4_1;
	struct upgt_eeprom_freq4_2 *freq4_2;
	int i, j, elements, settings, flags;
	unsigned channel;

	freq4_header = (struct upgt_eeprom_freq4_header *)data;
	freq4_1 = (struct upgt_eeprom_freq4_1 *)(freq4_header + 1);

	flags = freq4_header->flags;
	elements = freq4_header->elements;
	settings = freq4_header->settings;

	/* we need this value later */
	sc->sc_eeprom_freq6_settings = freq4_header->settings;

	DPRINTF(2, "%s: flags=0x%02x\n", sc->sc_dev.dv_xname, flags);
	DPRINTF(2, "%s: elements=%d\n", sc->sc_dev.dv_xname, elements);
	DPRINTF(2, "%s: settings=%d\n", sc->sc_dev.dv_xname, settings);

	for (i = 0; i < elements; i++) {
		channel = ieee80211_mhz2ieee(letoh16(freq4_1[i].freq), 0);

		freq4_2 = (struct upgt_eeprom_freq4_2 *)freq4_1[i].data;

		for (j = 0; j < settings; j++) {
			sc->sc_eeprom_freq4[channel][j].cmd = freq4_2[j];
			sc->sc_eeprom_freq4[channel][j].pad = 0;
		}

		DPRINTF(2, "%s: frequence=%d, channel=%d\n",
		    sc->sc_dev.dv_xname,
		    letoh16(freq4_1[i].freq), channel);
	}
}

void
upgt_eeprom_parse_freq6(struct upgt_softc *sc, uint8_t *data, int len)
{
	struct upgt_lmac_freq6 *freq6;
	int i, elements;
	unsigned channel;

	freq6 = (struct upgt_lmac_freq6 *)data;

	elements = len / sizeof(struct upgt_lmac_freq6);

	DPRINTF(2, "%s: elements=%d\n", sc->sc_dev.dv_xname, elements);

	for (i = 0; i < elements; i++) {
		channel = ieee80211_mhz2ieee(letoh16(freq6[i].freq), 0);

		sc->sc_eeprom_freq6[channel] = freq6[i];

		DPRINTF(2, "%s: frequence=%d, channel=%d\n",
		    sc->sc_dev.dv_xname,
		    letoh16(sc->sc_eeprom_freq6[channel].freq), channel);
	}
}

int
upgt_ioctl(struct ifnet *ifp, u_long cmd, caddr_t data)
{
	struct upgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifreq *ifr;
	int s, error = 0;
	uint8_t chan;

	s = splnet();

	switch (cmd) {
	case SIOCSIFADDR:
		ifp->if_flags |= IFF_UP;
		/* FALLTHROUGH */
	case SIOCSIFFLAGS:
		if (ifp->if_flags & IFF_UP) {
			if ((ifp->if_flags & IFF_RUNNING) == 0)
				upgt_init(ifp);
		} else {
			if (ifp->if_flags & IFF_RUNNING)
				upgt_stop(sc);
		}
		break;
	case SIOCADDMULTI:
	case SIOCDELMULTI:
		ifr = (struct ifreq *)data;
		error = (cmd == SIOCADDMULTI) ?
		    ether_addmulti(ifr, &ic->ic_ac) :
		    ether_delmulti(ifr, &ic->ic_ac);
		if (error == ENETRESET)
			error = 0;
		break;
	case SIOCS80211CHANNEL:
		/* allow fast channel switching in monitor mode */
		error = ieee80211_ioctl(ifp, cmd, data);
		if (error == ENETRESET &&
		    ic->ic_opmode == IEEE80211_M_MONITOR) {
			if ((ifp->if_flags & (IFF_UP | IFF_RUNNING)) ==
			    (IFF_UP | IFF_RUNNING)) {
				ic->ic_bss->ni_chan = ic->ic_ibss_chan;
				chan = ieee80211_chan2ieee(ic,
				    ic->ic_bss->ni_chan);
				upgt_set_channel(sc, chan);
			}
			error = 0;
		}
		break;
	default:
		error = ieee80211_ioctl(ifp, cmd, data);
		break;
	}

	if (error == ENETRESET) {
		if (ifp->if_flags & (IFF_UP | IFF_RUNNING))
			upgt_init(ifp);
		error = 0;
	}

	splx(s);

	return (error);
}

int
upgt_init(struct ifnet *ifp)
{
	struct upgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	IEEE80211_ADDR_COPY(ic->ic_myaddr, LLADDR(ifp->if_sadl));

	/* select default channel */
	ic->ic_bss->ni_chan = ic->ic_ibss_chan;
	sc->sc_cur_chan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);

	/* setup device rates */
	upgt_setup_rates(sc);

	ifp->if_flags |= IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	upgt_set_macfilter(sc, IEEE80211_S_SCAN);

	if (ic->ic_opmode == IEEE80211_M_MONITOR) {
		upgt_set_channel(sc, sc->sc_cur_chan);
		ieee80211_new_state(ic, IEEE80211_S_RUN, -1);
	} else
		ieee80211_new_state(ic, IEEE80211_S_SCAN, -1);

	return (0);
}

void
upgt_stop(struct upgt_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	/* device down */
	ifp->if_timer = 0;
	ifp->if_flags &= ~IFF_RUNNING;
	ifq_clr_oactive(&ifp->if_snd);

	upgt_set_led(sc, UPGT_LED_OFF);

	/* change device back to initial state */
	ieee80211_new_state(ic, IEEE80211_S_INIT, -1);
}

int
upgt_media_change(struct ifnet *ifp)
{
	struct upgt_softc *sc = ifp->if_softc;
	int error;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if ((error = ieee80211_media_change(ifp) != ENETRESET))
		return (error);

	if (ifp->if_flags & (IFF_UP | IFF_RUNNING)) {
		/* give pending USB transfers a chance to finish */
		usbd_delay_ms(sc->sc_udev, 100);
		upgt_init(ifp);
	}

	return (0);
}

void
upgt_newassoc(struct ieee80211com *ic, struct ieee80211_node *ni, int isnew)
{
	ni->ni_txrate = 0;
}

int
upgt_newstate(struct ieee80211com *ic, enum ieee80211_state nstate, int arg)
{
	struct upgt_softc *sc = ic->ic_if.if_softc;

	usb_rem_task(sc->sc_udev, &sc->sc_task_newstate);
	timeout_del(&sc->scan_to);

	/* do it in a process context */
	sc->sc_state = nstate;
	sc->sc_arg = arg;
	usb_add_task(sc->sc_udev, &sc->sc_task_newstate);

	return (0);
}

void
upgt_newstate_task(void *arg)
{
	struct upgt_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	unsigned channel;

	switch (sc->sc_state) {
	case IEEE80211_S_INIT:
		DPRINTF(1, "%s: newstate is IEEE80211_S_INIT\n",
		    sc->sc_dev.dv_xname);

		/* do not accept any frames if the device is down */
		upgt_set_macfilter(sc, IEEE80211_S_INIT);
		upgt_set_led(sc, UPGT_LED_OFF);
		break;
	case IEEE80211_S_SCAN:
		DPRINTF(1, "%s: newstate is IEEE80211_S_SCAN\n",
		    sc->sc_dev.dv_xname);

		channel = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
		upgt_set_channel(sc, channel);
		timeout_add_msec(&sc->scan_to, 200);
		break;
	case IEEE80211_S_AUTH:
		DPRINTF(1, "%s: newstate is IEEE80211_S_AUTH\n",
		    sc->sc_dev.dv_xname);

		channel = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
		upgt_set_channel(sc, channel);
		break;
	case IEEE80211_S_ASSOC:
		DPRINTF(1, "%s: newstate is IEEE80211_S_ASSOC\n",
		    sc->sc_dev.dv_xname);
		break;
	case IEEE80211_S_RUN:
		DPRINTF(1, "%s: newstate is IEEE80211_S_RUN\n",
		    sc->sc_dev.dv_xname);

		ni = ic->ic_bss;

		/*
		 * TX rate control is done by the firmware.
		 * Report the maximum rate which is available therefore.
		 */
		ni->ni_txrate = ni->ni_rates.rs_nrates - 1;

		if (ic->ic_opmode != IEEE80211_M_MONITOR)
			upgt_set_macfilter(sc, IEEE80211_S_RUN);
		upgt_set_led(sc, UPGT_LED_ON);
		break;
	}

	sc->sc_newstate(ic, sc->sc_state, sc->sc_arg);
}

void
upgt_next_scan(void *arg)
{
	struct upgt_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if (ic->ic_state == IEEE80211_S_SCAN)
		ieee80211_next_scan(ifp);
}

void
upgt_start(struct ifnet *ifp)
{
	struct upgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni;
	struct mbuf *m;
	int i;

	/* don't transmit packets if interface is busy or down */
	if (!(ifp->if_flags & IFF_RUNNING) || ifq_is_oactive(&ifp->if_snd))
		return;

	DPRINTF(2, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	for (i = 0; i < UPGT_TX_COUNT; i++) {
		struct upgt_data *data_tx = &sc->tx_data[i];

		m = mq_dequeue(&ic->ic_mgtq);
		if (m != NULL) {
			/* management frame */
			ni = m->m_pkthdr.ph_cookie;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
			if ((data_tx->addr = upgt_mem_alloc(sc)) == 0) {
				printf("%s: no free prism memory!\n",
				    sc->sc_dev.dv_xname);
				return;
			}
			data_tx->ni = ni;
			data_tx->m = m;
			sc->tx_queued++;
		} else {
			/* data frame */
			if (ic->ic_state != IEEE80211_S_RUN)
				break;

			IFQ_DEQUEUE(&ifp->if_snd, m);
			if (m == NULL)
				break;

#if NBPFILTER > 0
			if (ifp->if_bpf != NULL)
				bpf_mtap(ifp->if_bpf, m, BPF_DIRECTION_OUT);
#endif
			m = ieee80211_encap(ifp, m, &ni);
			if (m == NULL)
				continue;
#if NBPFILTER > 0
			if (ic->ic_rawbpf != NULL)
				bpf_mtap(ic->ic_rawbpf, m, BPF_DIRECTION_OUT);
#endif
			if ((data_tx->addr = upgt_mem_alloc(sc)) == 0) {
				printf("%s: no free prism memory!\n",
				    sc->sc_dev.dv_xname);
				return;
			}
			data_tx->ni = ni;
			data_tx->m = m;
			sc->tx_queued++;
		}
	}

	if (sc->tx_queued > 0) {
		DPRINTF(2, "%s: tx_queued=%d\n",
		    sc->sc_dev.dv_xname, sc->tx_queued);
		/* process the TX queue in process context */
		ifp->if_timer = 5;
		ifq_set_oactive(&ifp->if_snd);
		usb_rem_task(sc->sc_udev, &sc->sc_task_tx);
		usb_add_task(sc->sc_udev, &sc->sc_task_tx);
	}
}

void
upgt_watchdog(struct ifnet *ifp)
{
	struct upgt_softc *sc = ifp->if_softc;
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_state == IEEE80211_S_INIT)
		return;

	printf("%s: watchdog timeout!\n", sc->sc_dev.dv_xname);

	/* TODO: what shall we do on TX timeout? */

	ieee80211_watchdog(ifp);
}

void
upgt_tx_task(void *arg)
{
	struct upgt_softc *sc = arg;
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_frame *wh;
	struct ieee80211_key *k;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_tx_desc *txdesc;
	struct mbuf *m;
	uint32_t addr;
	int len, i, s;
	usbd_status error;

	s = splusb();

	upgt_set_led(sc, UPGT_LED_BLINK);

	for (i = 0; i < UPGT_TX_COUNT; i++) {
		struct upgt_data *data_tx = &sc->tx_data[i];

		if (data_tx->m == NULL) {
			DPRINTF(2, "%s: %d: m is NULL\n",
			    sc->sc_dev.dv_xname, i);
			continue;
		}

		m = data_tx->m;
		addr = data_tx->addr + UPGT_MEMSIZE_FRAME_HEAD;

		/*
		 * Software crypto.
		 */
		wh = mtod(m, struct ieee80211_frame *);

		if (wh->i_fc[1] & IEEE80211_FC1_PROTECTED) {
			k = ieee80211_get_txkey(ic, wh, ic->ic_bss);

			if ((m = ieee80211_encrypt(ic, m, k)) == NULL) {
				splx(s);
				return;
			}

			/* in case packet header moved, reset pointer */
			wh = mtod(m, struct ieee80211_frame *);
		}

		/*
		 * Transmit the URB containing the TX data.
		 */
		bzero(data_tx->buf, MCLBYTES);

		mem = (struct upgt_lmac_mem *)data_tx->buf;
		mem->addr = htole32(addr);

		txdesc = (struct upgt_lmac_tx_desc *)(mem + 1);

		/* XXX differ between data and mgmt frames? */
		txdesc->header1.flags = UPGT_H1_FLAGS_TX_DATA;
		txdesc->header1.type = UPGT_H1_TYPE_TX_DATA;
		txdesc->header1.len = htole16(m->m_pkthdr.len);

		txdesc->header2.reqid = htole32(data_tx->addr);
		txdesc->header2.type = htole16(UPGT_H2_TYPE_TX_ACK_YES);
		txdesc->header2.flags = htole16(UPGT_H2_FLAGS_TX_ACK_YES);

		if ((wh->i_fc[0] & IEEE80211_FC0_TYPE_MASK) ==
		    IEEE80211_FC0_TYPE_MGT) {
			/* always send mgmt frames at lowest rate (DS1) */
			memset(txdesc->rates, 0x10, sizeof(txdesc->rates));
		} else {
			bcopy(sc->sc_cur_rateset, txdesc->rates,
			    sizeof(txdesc->rates));
		}
		txdesc->type = htole32(UPGT_TX_DESC_TYPE_DATA);
		txdesc->pad3[0] = UPGT_TX_DESC_PAD3_SIZE;

#if NBPFILTER > 0
		if (sc->sc_drvbpf != NULL) {
			struct mbuf mb;
			struct upgt_tx_radiotap_header *tap = &sc->sc_txtap;

			tap->wt_flags = 0;
			tap->wt_rate = 0;	/* TODO: where to get from? */
			tap->wt_chan_freq =
			    htole16(ic->ic_bss->ni_chan->ic_freq);
			tap->wt_chan_flags =
			    htole16(ic->ic_bss->ni_chan->ic_flags);

			mb.m_data = (caddr_t)tap;
			mb.m_len = sc->sc_txtap_len;
			mb.m_next = m;
			mb.m_nextpkt = NULL;
			mb.m_type = 0;
			mb.m_flags = 0;
			bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_OUT);
		}
#endif
		/* copy frame below our TX descriptor header */
		m_copydata(m, 0, m->m_pkthdr.len,
		    data_tx->buf + (sizeof(*mem) + sizeof(*txdesc)));

		/* calculate frame size */
		len = sizeof(*mem) + sizeof(*txdesc) + m->m_pkthdr.len;

		/* we need to align the frame to a 4 byte boundary */
		len = (len + 3) & ~3;

		/* calculate frame checksum */
		mem->chksum = upgt_chksum_le((uint32_t *)txdesc,
		    len - sizeof(*mem));

		/* we do not need the mbuf anymore */
		m_freem(m);
		data_tx->m = NULL;

		DPRINTF(2, "%s: TX start data sending\n", sc->sc_dev.dv_xname);

		usbd_setup_xfer(data_tx->xfer, sc->sc_tx_pipeh, data_tx,
		    data_tx->buf, len, USBD_FORCE_SHORT_XFER | USBD_NO_COPY,
		    UPGT_USB_TIMEOUT, NULL);
		error = usbd_transfer(data_tx->xfer);
		if (error != 0 && error != USBD_IN_PROGRESS) {
			printf("%s: could not transmit TX data URB!\n",
			    sc->sc_dev.dv_xname);
			splx(s);
			return;
		}

		DPRINTF(2, "%s: TX sent (%d bytes)\n",
		    sc->sc_dev.dv_xname, len);
	}

	/*
	 * If we don't regulary read the device statistics, the RX queue
	 * will stall.  It's strange, but it works, so we keep reading
	 * the statistics here.  *shrug*
	 */
	upgt_get_stats(sc);

	splx(s);
}

void
upgt_tx_done(struct upgt_softc *sc, uint8_t *data)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct upgt_lmac_tx_done_desc *desc;
	int i, s;

	s = splnet();

	desc = (struct upgt_lmac_tx_done_desc *)data;

	for (i = 0; i < UPGT_TX_COUNT; i++) {
		struct upgt_data *data_tx = &sc->tx_data[i];

		if (data_tx->addr == letoh32(desc->header2.reqid)) {
			upgt_mem_free(sc, data_tx->addr);
			ieee80211_release_node(ic, data_tx->ni);
			data_tx->ni = NULL;
			data_tx->addr = 0;

			sc->tx_queued--;

			DPRINTF(2, "%s: TX done: ", sc->sc_dev.dv_xname);
			DPRINTF(2, "memaddr=0x%08x, status=0x%04x, rssi=%d, ",
			    letoh32(desc->header2.reqid),
			    letoh16(desc->status),
			    letoh16(desc->rssi));
			DPRINTF(2, "seq=%d\n", letoh16(desc->seq));
			break;
		}
	}

	if (sc->tx_queued == 0) {
		/* TX queued was processed, continue */
		ifp->if_timer = 0;
		ifq_clr_oactive(&ifp->if_snd);
		upgt_start(ifp);
	}

	splx(s);
}

void
upgt_rx_cb(struct usbd_xfer *xfer, void *priv, usbd_status status)
{
	struct upgt_data *data_rx = priv;
	struct upgt_softc *sc = data_rx->sc;
	int len;
	struct upgt_lmac_header *header;
	struct upgt_lmac_eeprom *eeprom;
	uint8_t h1_type;
	uint16_t h2_type;

	DPRINTF(3, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	if (status != USBD_NORMAL_COMPLETION) {
		if (status == USBD_NOT_STARTED || status == USBD_CANCELLED)
			return;
		if (status == USBD_STALLED)
			usbd_clear_endpoint_stall_async(sc->sc_rx_pipeh);
		goto skip;
	}
	usbd_get_xfer_status(xfer, NULL, NULL, &len, NULL);

	/*
	 * Check what type of frame came in.
	 */
	header = (struct upgt_lmac_header *)(data_rx->buf + 4);

	h1_type = header->header1.type;
	h2_type = letoh16(header->header2.type);

	if (h1_type == UPGT_H1_TYPE_CTRL &&
	    h2_type == UPGT_H2_TYPE_EEPROM) {
		eeprom = (struct upgt_lmac_eeprom *)(data_rx->buf + 4);
		uint16_t eeprom_offset = letoh16(eeprom->offset);
		uint16_t eeprom_len = letoh16(eeprom->len);

		DPRINTF(2, "%s: received EEPROM block (offset=%d, len=%d)\n",
			sc->sc_dev.dv_xname, eeprom_offset, eeprom_len);

		bcopy(data_rx->buf + sizeof(struct upgt_lmac_eeprom) + 4,
			sc->sc_eeprom + eeprom_offset, eeprom_len);

		/* EEPROM data has arrived in time, wakeup tsleep() */
		wakeup(sc);
	} else
	if (h1_type == UPGT_H1_TYPE_CTRL &&
	    h2_type == UPGT_H2_TYPE_TX_DONE) {
		DPRINTF(2, "%s: received 802.11 TX done\n",
		    sc->sc_dev.dv_xname);

		upgt_tx_done(sc, data_rx->buf + 4);
	} else
	if (h1_type == UPGT_H1_TYPE_RX_DATA ||
	    h1_type == UPGT_H1_TYPE_RX_DATA_MGMT) {
		DPRINTF(3, "%s: received 802.11 RX data\n",
		    sc->sc_dev.dv_xname);

		upgt_rx(sc, data_rx->buf + 4, letoh16(header->header1.len));
	} else
	if (h1_type == UPGT_H1_TYPE_CTRL &&
	    h2_type == UPGT_H2_TYPE_STATS) {
		DPRINTF(2, "%s: received statistic data\n",
		    sc->sc_dev.dv_xname);

		/* TODO: what could we do with the statistic data? */
	} else {
		/* ignore unknown frame types */
		DPRINTF(1, "%s: received unknown frame type 0x%02x\n",
		    sc->sc_dev.dv_xname, header->header1.type);
	}

skip:	/* setup new transfer */
	usbd_setup_xfer(xfer, sc->sc_rx_pipeh, data_rx, data_rx->buf, MCLBYTES,
	    USBD_SHORT_XFER_OK, USBD_NO_TIMEOUT, upgt_rx_cb);
	(void)usbd_transfer(xfer);
}

void
upgt_rx(struct upgt_softc *sc, uint8_t *data, int pkglen)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ifnet *ifp = &ic->ic_if;
	struct upgt_lmac_rx_desc *rxdesc;
	struct ieee80211_frame *wh;
	struct ieee80211_rxinfo rxi;
	struct ieee80211_node *ni;
	struct mbuf *m;
	int s;

	/* access RX packet descriptor */
	rxdesc = (struct upgt_lmac_rx_desc *)data;

	/* create mbuf which is suitable for strict alignment archs */
	m = m_devget(rxdesc->data, pkglen, ETHER_ALIGN);
	if (m == NULL) {
		DPRINTF(1, "%s: could not create RX mbuf!\n", sc->sc_dev.dv_xname);
		ifp->if_ierrors++;
		return;
	}

	s = splnet();

#if NBPFILTER > 0
	if (sc->sc_drvbpf != NULL) {
		struct mbuf mb;
		struct upgt_rx_radiotap_header *tap = &sc->sc_rxtap;

		tap->wr_flags = IEEE80211_RADIOTAP_F_FCS;
		tap->wr_rate = upgt_rx_rate(sc, rxdesc->rate);
		tap->wr_chan_freq = htole16(ic->ic_bss->ni_chan->ic_freq);
		tap->wr_chan_flags = htole16(ic->ic_bss->ni_chan->ic_flags);
		tap->wr_antsignal = rxdesc->rssi;

		mb.m_data = (caddr_t)tap;
		mb.m_len = sc->sc_rxtap_len;
		mb.m_next = m;
		mb.m_nextpkt = NULL;
		mb.m_type = 0;
		mb.m_flags = 0;
		bpf_mtap(sc->sc_drvbpf, &mb, BPF_DIRECTION_IN);
	}
#endif
	/* trim FCS */
	m_adj(m, -IEEE80211_CRC_LEN);

	wh = mtod(m, struct ieee80211_frame *);
	ni = ieee80211_find_rxnode(ic, wh);

	/* push the frame up to the 802.11 stack */
	rxi.rxi_flags = 0;
	rxi.rxi_rssi = rxdesc->rssi;
	rxi.rxi_tstamp = 0;	/* unused */
	ieee80211_input(ifp, m, ni, &rxi);

	/* node is no longer needed */
	ieee80211_release_node(ic, ni);

	splx(s);

	DPRINTF(3, "%s: RX done\n", sc->sc_dev.dv_xname);
}

void
upgt_setup_rates(struct upgt_softc *sc)
{
	struct ieee80211com *ic = &sc->sc_ic;

	/*
	 * 0x01 = OFMD6   0x10 = DS1
	 * 0x04 = OFDM9   0x11 = DS2
	 * 0x06 = OFDM12  0x12 = DS5
	 * 0x07 = OFDM18  0x13 = DS11
	 * 0x08 = OFDM24
	 * 0x09 = OFDM36
	 * 0x0a = OFDM48
	 * 0x0b = OFDM54
	 */
	const uint8_t rateset_auto_11b[] =
	    { 0x13, 0x13, 0x12, 0x11, 0x11, 0x10, 0x10, 0x10 };
	const uint8_t rateset_auto_11g[] =
	    { 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x04, 0x01 };
	const uint8_t rateset_fix_11bg[] =
	    { 0x10, 0x11, 0x12, 0x13, 0x01, 0x04, 0x06, 0x07,
	      0x08, 0x09, 0x0a, 0x0b };

	if (ic->ic_fixed_rate == -1) {
		/*
		 * Automatic rate control is done by the device.
		 * We just pass the rateset from which the device
		 * will pickup a rate.
		 */
		if (ic->ic_curmode == IEEE80211_MODE_11B)
			bcopy(rateset_auto_11b, sc->sc_cur_rateset,
			    sizeof(sc->sc_cur_rateset));
		if (ic->ic_curmode == IEEE80211_MODE_11G ||
		    ic->ic_curmode == IEEE80211_MODE_AUTO)
			bcopy(rateset_auto_11g, sc->sc_cur_rateset,
			    sizeof(sc->sc_cur_rateset));
	} else {
		/* set a fixed rate */
		memset(sc->sc_cur_rateset, rateset_fix_11bg[ic->ic_fixed_rate],
		    sizeof(sc->sc_cur_rateset));
	}
}

uint8_t
upgt_rx_rate(struct upgt_softc *sc, const int rate)
{
	struct ieee80211com *ic = &sc->sc_ic;

	if (ic->ic_curmode == IEEE80211_MODE_11B) {
		if (rate < 0 || rate > 3)
			/* invalid rate */
			return (0);

		switch (rate) {
		case 0:
			return (2);
		case 1:
			return (4);
		case 2:
			return (11);
		case 3:
			return (22);
		default:
			return (0);
		}
	}

	if (ic->ic_curmode == IEEE80211_MODE_11G) {
		if (rate < 0 || rate > 11)
			/* invalid rate */
			return (0);

		switch (rate) {
		case 0:
			return (2);
		case 1:
			return (4);
		case 2:
			return (11);
		case 3:
			return (22);
		case 4:
			return (12);
		case 5:
			return (18);
		case 6:
			return (24);
		case 7:
			return (36);
		case 8:
			return (48);
		case 9:
			return (72);
		case 10:
			return (96);
		case 11:
			return (108);
		default:
			return (0);
		}
	}

	return (0);
}

int
upgt_set_macfilter(struct upgt_softc *sc, uint8_t state)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct ieee80211_node *ni = ic->ic_bss;
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_filter *filter;
	int len;
	uint8_t broadcast[] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };

	/*
	 * Transmit the URB containing the CMD data.
	 */
	bzero(data_cmd->buf, MCLBYTES);

	mem = (struct upgt_lmac_mem *)data_cmd->buf;
	mem->addr = htole32(sc->sc_memaddr_frame_start +
	    UPGT_MEMSIZE_FRAME_HEAD);

	filter = (struct upgt_lmac_filter *)(mem + 1);

	filter->header1.flags = UPGT_H1_FLAGS_TX_NO_CALLBACK;
	filter->header1.type = UPGT_H1_TYPE_CTRL;
	filter->header1.len = htole16(
	    sizeof(struct upgt_lmac_filter) -
	    sizeof(struct upgt_lmac_header));

	filter->header2.reqid = htole32(sc->sc_memaddr_frame_start);
	filter->header2.type = htole16(UPGT_H2_TYPE_MACFILTER);
	filter->header2.flags = 0;

	switch (state) {
	case IEEE80211_S_INIT:
		DPRINTF(1, "%s: set MAC filter to INIT\n",
		    sc->sc_dev.dv_xname);

		filter->type = htole16(UPGT_FILTER_TYPE_RESET);
		break;
	case IEEE80211_S_SCAN:
		DPRINTF(1, "%s: set MAC filter to SCAN (bssid %s)\n",
		    sc->sc_dev.dv_xname, ether_sprintf(broadcast));

		filter->type = htole16(UPGT_FILTER_TYPE_NONE);
		IEEE80211_ADDR_COPY(filter->dst, ic->ic_myaddr);
		IEEE80211_ADDR_COPY(filter->src, broadcast);
		filter->unknown1 = htole16(UPGT_FILTER_UNKNOWN1);
		filter->rxaddr = htole32(sc->sc_memaddr_rx_start);
		filter->unknown2 = htole16(UPGT_FILTER_UNKNOWN2);
		filter->rxhw = htole32(sc->sc_eeprom_hwrx);
		filter->unknown3 = htole16(UPGT_FILTER_UNKNOWN3);
		break;
	case IEEE80211_S_RUN:
		DPRINTF(1, "%s: set MAC filter to RUN (bssid %s)\n",
		    sc->sc_dev.dv_xname, ether_sprintf(ni->ni_bssid));

		filter->type = htole16(UPGT_FILTER_TYPE_STA);
		IEEE80211_ADDR_COPY(filter->dst, ic->ic_myaddr);
		IEEE80211_ADDR_COPY(filter->src, ni->ni_bssid);
		filter->unknown1 = htole16(UPGT_FILTER_UNKNOWN1);
		filter->rxaddr = htole32(sc->sc_memaddr_rx_start);
		filter->unknown2 = htole16(UPGT_FILTER_UNKNOWN2);
		filter->rxhw = htole32(sc->sc_eeprom_hwrx);
		filter->unknown3 = htole16(UPGT_FILTER_UNKNOWN3);
		break;
	default:
		printf("%s: MAC filter does not know that state!\n",
		    sc->sc_dev.dv_xname);
		break;
	}

	len = sizeof(*mem) + sizeof(*filter);

	mem->chksum = upgt_chksum_le((uint32_t *)filter,
	    len - sizeof(*mem));

	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit macfilter CMD data URB!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);
}

int
upgt_set_channel(struct upgt_softc *sc, unsigned channel)
{
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_channel *chan;
	int len;

	DPRINTF(1, "%s: %s: %d\n", sc->sc_dev.dv_xname, __func__, channel);

	/*
	 * Transmit the URB containing the CMD data.
	 */
	bzero(data_cmd->buf, MCLBYTES);

	mem = (struct upgt_lmac_mem *)data_cmd->buf;
	mem->addr = htole32(sc->sc_memaddr_frame_start +
	    UPGT_MEMSIZE_FRAME_HEAD);

	chan = (struct upgt_lmac_channel *)(mem + 1);

	chan->header1.flags = UPGT_H1_FLAGS_TX_NO_CALLBACK;
	chan->header1.type = UPGT_H1_TYPE_CTRL;
	chan->header1.len = htole16(
	    sizeof(struct upgt_lmac_channel) -
	    sizeof(struct upgt_lmac_header));

	chan->header2.reqid = htole32(sc->sc_memaddr_frame_start);
	chan->header2.type = htole16(UPGT_H2_TYPE_CHANNEL);
	chan->header2.flags = 0;

	chan->unknown1 = htole16(UPGT_CHANNEL_UNKNOWN1);
	chan->unknown2 = htole16(UPGT_CHANNEL_UNKNOWN2);
	chan->freq6 = sc->sc_eeprom_freq6[channel];
	chan->settings = sc->sc_eeprom_freq6_settings;
	chan->unknown3 = UPGT_CHANNEL_UNKNOWN3;

	bcopy(&sc->sc_eeprom_freq3[channel].data, chan->freq3_1,
	    sizeof(chan->freq3_1));

	bcopy(&sc->sc_eeprom_freq4[channel], chan->freq4,
	    sizeof(sc->sc_eeprom_freq4[channel]));

	bcopy(&sc->sc_eeprom_freq3[channel].data, chan->freq3_2,
	    sizeof(chan->freq3_2));

	len = sizeof(*mem) + sizeof(*chan);

	mem->chksum = upgt_chksum_le((uint32_t *)chan,
	    len - sizeof(*mem));

	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit channel CMD data URB!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);
}

void
upgt_set_led(struct upgt_softc *sc, int action)
{
	struct ieee80211com *ic = &sc->sc_ic;
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_led *led;
	struct timeval t;
	int len;

	/*
	 * Transmit the URB containing the CMD data.
	 */
	bzero(data_cmd->buf, MCLBYTES);

	mem = (struct upgt_lmac_mem *)data_cmd->buf;
	mem->addr = htole32(sc->sc_memaddr_frame_start +
	    UPGT_MEMSIZE_FRAME_HEAD);

	led = (struct upgt_lmac_led *)(mem + 1);

	led->header1.flags = UPGT_H1_FLAGS_TX_NO_CALLBACK;
	led->header1.type = UPGT_H1_TYPE_CTRL;
	led->header1.len = htole16(
	    sizeof(struct upgt_lmac_led) -
	    sizeof(struct upgt_lmac_header));

	led->header2.reqid = htole32(sc->sc_memaddr_frame_start);
	led->header2.type = htole16(UPGT_H2_TYPE_LED);
	led->header2.flags = 0;

	switch (action) {
	case UPGT_LED_OFF:
		led->mode = htole16(UPGT_LED_MODE_SET);
		led->action_fix = 0;
		led->action_tmp = htole16(UPGT_LED_ACTION_OFF);
		led->action_tmp_dur = 0;
		break;
	case UPGT_LED_ON:
		led->mode = htole16(UPGT_LED_MODE_SET);
		led->action_fix = 0;
		led->action_tmp = htole16(UPGT_LED_ACTION_ON);
		led->action_tmp_dur = 0;
		break;
	case UPGT_LED_BLINK:
		if (ic->ic_state != IEEE80211_S_RUN)
			return;
		if (sc->sc_led_blink)
			/* previous blink was not finished */
			return;
		led->mode = htole16(UPGT_LED_MODE_SET);
		led->action_fix = htole16(UPGT_LED_ACTION_OFF);
		led->action_tmp = htole16(UPGT_LED_ACTION_ON);
		led->action_tmp_dur = htole16(UPGT_LED_ACTION_TMP_DUR);
		/* lock blink */
		sc->sc_led_blink = 1;
		t.tv_sec = 0;
		t.tv_usec = UPGT_LED_ACTION_TMP_DUR * 1000L;
		timeout_add(&sc->led_to, tvtohz(&t));
		break;
	default:
		return;
	}

	len = sizeof(*mem) + sizeof(*led);

	mem->chksum = upgt_chksum_le((uint32_t *)led,
	    len - sizeof(*mem));

	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit led CMD URB!\n",
		    sc->sc_dev.dv_xname);
	}
}

void
upgt_set_led_blink(void *arg)
{
	struct upgt_softc *sc = arg;

	/* blink finished, we are ready for a next one */
	sc->sc_led_blink = 0;
	timeout_del(&sc->led_to);
}

int
upgt_get_stats(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;
	struct upgt_lmac_mem *mem;
	struct upgt_lmac_stats *stats;
	int len;

	/*
	 * Transmit the URB containing the CMD data.
	 */
	bzero(data_cmd->buf, MCLBYTES);

	mem = (struct upgt_lmac_mem *)data_cmd->buf;
	mem->addr = htole32(sc->sc_memaddr_frame_start +
	    UPGT_MEMSIZE_FRAME_HEAD);

	stats = (struct upgt_lmac_stats *)(mem + 1);

	stats->header1.flags = 0;
	stats->header1.type = UPGT_H1_TYPE_CTRL;
	stats->header1.len = htole16(
	    sizeof(struct upgt_lmac_stats) -
	    sizeof(struct upgt_lmac_header));

	stats->header2.reqid = htole32(sc->sc_memaddr_frame_start);
	stats->header2.type = htole16(UPGT_H2_TYPE_STATS);
	stats->header2.flags = 0;

	len = sizeof(*mem) + sizeof(*stats);

	mem->chksum = upgt_chksum_le((uint32_t *)stats,
	    len - sizeof(*mem));

	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit statistics CMD data URB!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}

	return (0);

}

int
upgt_alloc_tx(struct upgt_softc *sc)
{
	int i;

	sc->tx_queued = 0;

	for (i = 0; i < UPGT_TX_COUNT; i++) {
		struct upgt_data *data_tx = &sc->tx_data[i];

		data_tx->sc = sc;

		data_tx->xfer = usbd_alloc_xfer(sc->sc_udev);
		if (data_tx->xfer == NULL) {
			printf("%s: could not allocate TX xfer!\n",
			    sc->sc_dev.dv_xname);
			return (ENOMEM);
		}

		data_tx->buf = usbd_alloc_buffer(data_tx->xfer, MCLBYTES);
		if (data_tx->buf == NULL) {
			printf("%s: could not allocate TX buffer!\n",
			    sc->sc_dev.dv_xname);
			return (ENOMEM);
		}

		bzero(data_tx->buf, MCLBYTES);
	}

	return (0);
}

int
upgt_alloc_rx(struct upgt_softc *sc)
{
	struct upgt_data *data_rx = &sc->rx_data;

	data_rx->sc = sc;

	data_rx->xfer = usbd_alloc_xfer(sc->sc_udev);
	if (data_rx->xfer == NULL) {
		printf("%s: could not allocate RX xfer!\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	data_rx->buf = usbd_alloc_buffer(data_rx->xfer, MCLBYTES);
	if (data_rx->buf == NULL) {
		printf("%s: could not allocate RX buffer!\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	bzero(data_rx->buf, MCLBYTES);

	return (0);
}

int
upgt_alloc_cmd(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;

	data_cmd->sc = sc;

	data_cmd->xfer = usbd_alloc_xfer(sc->sc_udev);
	if (data_cmd->xfer == NULL) {
		printf("%s: could not allocate RX xfer!\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	data_cmd->buf = usbd_alloc_buffer(data_cmd->xfer, MCLBYTES);
	if (data_cmd->buf == NULL) {
		printf("%s: could not allocate RX buffer!\n",
		    sc->sc_dev.dv_xname);
		return (ENOMEM);
	}

	bzero(data_cmd->buf, MCLBYTES);

	return (0);
}

void
upgt_free_tx(struct upgt_softc *sc)
{
	int i;

	for (i = 0; i < UPGT_TX_COUNT; i++) {
		struct upgt_data *data_tx = &sc->tx_data[i];

		if (data_tx->xfer != NULL) {
			usbd_free_xfer(data_tx->xfer);
			data_tx->xfer = NULL;
		}

		data_tx->ni = NULL;
	}
}

void
upgt_free_rx(struct upgt_softc *sc)
{
	struct upgt_data *data_rx = &sc->rx_data;

	if (data_rx->xfer != NULL) {
		usbd_free_xfer(data_rx->xfer);
		data_rx->xfer = NULL;
	}

	data_rx->ni = NULL;
}

void
upgt_free_cmd(struct upgt_softc *sc)
{
	struct upgt_data *data_cmd = &sc->cmd_data;

	if (data_cmd->xfer != NULL) {
		usbd_free_xfer(data_cmd->xfer);
		data_cmd->xfer = NULL;
	}
}

int
upgt_bulk_xmit(struct upgt_softc *sc, struct upgt_data *data,
    struct usbd_pipe *pipeh, uint32_t *size, int flags)
{
        usbd_status status;

	usbd_setup_xfer(data->xfer, pipeh, 0, data->buf, *size,
	    USBD_NO_COPY | USBD_SYNCHRONOUS | flags, UPGT_USB_TIMEOUT, NULL);
	status = usbd_transfer(data->xfer);
	if (status != USBD_NORMAL_COMPLETION) {
		printf("%s: %s: error %s!\n",
		    sc->sc_dev.dv_xname, __func__, usbd_errstr(status));
		return (EIO);
	}

	return (0);
}

void
upgt_hexdump(void *buf, int len)
{
	int i;

	for (i = 0; i < len; i++) {
		if (i % 16 == 0)
			printf("%s%5i:", i ? "\n" : "", i);
		if (i % 4 == 0)
			printf(" ");
		printf("%02x", (int)*((u_char *)buf + i));
	}
	printf("\n");
}

uint32_t
upgt_crc32_le(const void *buf, size_t size)
{
	uint32_t crc;

	crc = ether_crc32_le(buf, size);

	/* apply final XOR value as common for CRC-32 */
	crc = htole32(crc ^ 0xffffffffU);

	return (crc);
}

/*
 * The firmware awaits a checksum for each frame we send to it.
 * The algorithm used therefor is uncommon but somehow similar to CRC32.
 */
uint32_t
upgt_chksum_le(const uint32_t *buf, size_t size)
{
	int i;
	uint32_t crc = 0;

	for (i = 0; i < size; i += sizeof(uint32_t)) {
		crc = htole32(crc ^ *buf++);
		crc = htole32((crc >> 5) ^ (crc << 3));
	}

	return (crc);
}
@


1.79
log
@move counting if_opackets next to counting if_obytes in if_enqueue.

this means packets are consistently counted in one place, unlike the
many and various ways that drivers thought they should do it.

ok mpi@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.78 2016/11/06 12:58:01 mpi Exp $ */
d615 1
a615 1
		free(sc->sc_fw, M_DEVBUF, 0);
@


1.78
log
@Avoid calling usbd_set_config_no() in *_attach() and let the stack do
it instead.

If anything bad happen due to a malformed descriptor it makes no sense
to try to attach a driver, and bail before probing.

This is similar to the change to avoid calling usbd_set_config_index().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.77 2016/04/13 11:03:37 mpi Exp $ */
a1606 1
			ifp->if_opackets++;
@


1.77
log
@G/C IFQ_SET_READY().
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.76 2015/12/11 16:07:02 mpi Exp $ */
d183 1
a183 1
	if (uaa->iface != NULL)
a212 7

	/* set configuration number */
	if (usbd_set_config_no(sc->sc_udev, UPGT_CONFIG_NO, 0) != 0) {
		printf("%s: could not set configuration no!\n",
		    sc->sc_dev.dv_xname);
		return;
	}
@


1.76
log
@Replace mountroothook_establish(9) by config_mountroot(9) a narrower API
similar to config_defer(9).

ok mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.75 2015/11/25 03:10:00 dlg Exp $ */
a413 1
	IFQ_SET_READY(&ifp->if_snd);
@


1.75
log
@replace IFF_OACTIVE manipulation with mpsafe operations.

there are two things shared between the network stack and drivers
in the send path: the send queue and the IFF_OACTIVE flag. the send
queue is now protected by a mutex. this diff makes the oactive
functionality mpsafe too.

IFF_OACTIVE is part of if_flags. there are two problems with that.
firstly, if_flags is a short and we dont have any MI atomic operations
to manipulate a short. secondly, while we could make the IFF_OACTIVE
operates mpsafe, all changes to other flags would have to be made
safe at the same time, otherwise a read-modify-write cycle on their
updates could clobber the oactive change.

instead, this moves the oactive mark into struct ifqueue and provides
an API for changing it. there's ifq_set_oactive, ifq_clr_oactive,
and ifq_is_oactive. these are modelled on ifsq_set_oactive,
ifsq_clr_oactive, and ifsq_is_oactive in dragonflybsd.

this diff includes changes to all the drivers manipulating IFF_OACTIVE
to now use the ifsq_{set,clr_is}_oactive API too.

ok kettenis@@ mpi@@ jmatthew@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.74 2015/11/24 13:45:07 mpi Exp $ */
d83 1
a83 1
void		upgt_attach_hook(void *);
d302 1
a302 4
	if (rootvp == NULL)
		mountroothook_establish(upgt_attach_hook, sc);
	else
		upgt_attach_hook(sc);
d310 1
a310 1
upgt_attach_hook(void *arg)
d312 1
a312 1
	struct upgt_softc *sc = arg;
@


1.74
log
@No need to include <net/if_arp.h>

This header is only needed because <netinet/if_ether.h> declares a
structure that needs it.  But it turns out that <net/if.h> already
includes it as workaround.

A proper solution would be to stop declarting "struct ether_arp"
there.  But no driver should need this header.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.73 2015/11/24 13:33:18 mpi Exp $ */
d1217 1
a1217 1
	ifp->if_flags &= ~IFF_OACTIVE;
d1240 2
a1241 1
	ifp->if_flags &= ~(IFF_RUNNING | IFF_OACTIVE);
d1371 1
a1371 1
	if ((ifp->if_flags & (IFF_RUNNING | IFF_OACTIVE)) != IFF_RUNNING)
d1431 1
a1431 1
		ifp->if_flags |= IFF_OACTIVE;
d1633 1
a1633 1
		ifp->if_flags &= ~IFF_OACTIVE;
@


1.73
log
@The only network driver needing <net/if_types.h> is upl(4) for IFT_OTHER.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.72 2015/11/11 10:07:25 mpi Exp $ */
a37 1
#include <net/if_arp.h>
@


1.72
log
@Kill useless IFQ_POLL().

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.71 2015/11/04 12:12:00 dlg Exp $ */
a40 1
#include <net/if_types.h>
@


1.71
log
@replace the ifqueues in net80211 with mbuf_queues.

the specific queues are ic_mgtq, ic_pwrsaveq, and ni_savedq. rtw
had its own queue for beacons.

tested by mpi@@ and jmc@@
ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.70 2015/10/25 12:11:56 mpi Exp $ */
d1401 1
a1401 1
			IFQ_POLL(&ifp->if_snd, m);
a1404 1
			IFQ_DEQUEUE(&ifp->if_snd, m);
@


1.70
log
@arp_ifinit() is no longer needed.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.69 2015/05/02 10:44:29 jsg Exp $ */
d1380 1
a1380 1
		IF_POLL(&ic->ic_mgtq, m);
a1382 2
			IF_DEQUEUE(&ic->ic_mgtq, m);

@


1.69
log
@add missing splx calls
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.68 2015/04/13 08:45:48 mpi Exp $ */
a1141 1
	struct ifaddr *ifa;
a1149 1
		ifa = (struct ifaddr *)data;
a1150 2
		if (ifa->ifa_addr->sa_family == AF_INET)
			arp_ifinit(&ic->ic_ac, ifa);
@


1.68
log
@Now that if_input() set the receiving interface pointer on mbufs for us
there's no need to do it in m_devget(9).

Stop passing an ``ifp'' will help for upcoming interface pointer -> index
conversion.

While here remove unused ``ifp'' argument from m_clget(9) and kill two
birds^W layer violations in one commit.

ok henning@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.67 2015/03/14 03:38:49 jsg Exp $ */
d1499 2
a1500 1
			if ((m = ieee80211_encrypt(ic, m, k)) == NULL)
d1502 1
d1586 1
@


1.67
log
@Remove some includes include-what-you-use claims don't
have any direct symbols used.  Tested for indirect use by compiling
amd64/i386/sparc64 kernels.

ok tedu@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.66 2014/12/22 02:28:52 tedu Exp $ */
d1738 1
a1738 1
	m = m_devget(rxdesc->data, pkglen, ETHER_ALIGN, ifp);
@


1.66
log
@unifdef INET
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.65 2014/12/19 22:44:59 guenther Exp $ */
a31 1
#include <machine/bus.h>
@


1.65
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.64 2014/07/13 15:52:49 mpi Exp $ */
a1153 1
#ifdef INET
a1155 1
#endif
@


1.64
log
@No need for <netinet/in_systm.h> here.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.63 2014/07/12 18:48:52 tedu Exp $ */
d30 1
a32 1
#include <machine/endian.h>
@


1.63
log
@add a size argument to free. will be used soon, but for now default to 0.
after discussions with beck deraadt kettenis.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.62 2014/07/12 07:59:23 mpi Exp $ */
a44 1
#include <netinet/in_systm.h>
a45 1
#include <netinet/ip.h>
@


1.62
log
@Kill a bunch of DVACT_DEACTIVATE handlers whose only purpose were to
set the 'dying' flag of a device.  Such handlers are useless now that
usbd_detach() already set this flag.

Even if the purpose of this flag is questionnable on OpenBSD because
DVACT_DEACTIVATE acts as a pre-detach event, this is just a first small
step towards the simplification of the autoconf(9) device states.

This cleaning is now possible thanks to the work of pirofti@@ to convert
all the USB drivers to properly use usbd_is_dying().

Discussed many times with deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.61 2014/03/19 10:09:19 mpi Exp $ */
d631 1
a631 1
		free(sc->sc_fw, M_DEVBUF);
@


1.61
log
@Stop abusing the rcvif pointer to pass wireless nodes down to the
driver start routines.  Instead add & use a pointer in the pkthdr
since we don't want the overhead of using a mbuf_tags(9).

claudio@@ pointed out that other subsystems might want to use this
pointer too, so here's a new cookie!

ok claudio@@, mikeb@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.60 2013/08/21 05:21:45 dlg Exp $ */
a89 1
int		upgt_activate(struct device *, int);
d149 1
a149 5
	sizeof(struct upgt_softc),
	upgt_match,
	upgt_attach,
	upgt_detach,
	upgt_activate,
a497 14

	return (0);
}

int
upgt_activate(struct device *self, int act)
{
	struct upgt_softc *sc = (struct upgt_softc *)self;

	switch (act) {
	case DVACT_DEACTIVATE:
		usbd_deactivate(sc->sc_udev);
		break;
	}
@


1.60
log
@get rid of the copy argument in m_devget that let you provide an
alternative to bcopy since noone uses it.

while there use memcpy instead of bcopy because we know the memory cannot
overlap.

ok henning@@ matthew@@ mikeb@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.59 2013/08/07 01:06:42 bluhm Exp $ */
d1413 1
a1413 2
			ni = (struct ieee80211_node *)m->m_pkthdr.rcvif;
			m->m_pkthdr.rcvif = NULL;
@


1.59
log
@Most network drivers include netinet/in_var.h, but apparently they
don't have to.  Just remove these include lines.
Compiled on amd64 i386 sparc64; OK henning@@ mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.58 2013/04/26 14:43:22 mpi Exp $ */
d1763 1
a1763 1
	m = m_devget(rxdesc->data, pkglen, ETHER_ALIGN, ifp, NULL);
@


1.58
log
@Don't use usbd_bulk_transfer() to submit a synchronous transfer. This
function is badly named and checks for posted signals before and after
sleeping only if there's no timeout set, which is not the case here.

Tested by and ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.57 2013/04/15 09:23:01 mglocker Exp $ */
a45 1
#include <netinet/in_var.h>
@


1.57
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.56 2011/07/03 15:47:17 matthew Exp $ */
d2323 3
a2325 3
	status = usbd_bulk_transfer(data->xfer, pipeh,
	    USBD_NO_COPY | flags, UPGT_USB_TIMEOUT, data->buf, size,
	    "upgt_bulk_xmit");
@


1.56
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.55 2011/01/25 20:03:35 jakemsr Exp $ */
d123 1
a123 1
void		upgt_rx_cb(usbd_xfer_handle, usbd_private_handle, usbd_status);
d140 1
a140 1
		    usbd_pipe_handle, uint32_t *, int);
d1672 1
a1672 1
upgt_rx_cb(usbd_xfer_handle xfer, usbd_private_handle priv, usbd_status status)
d2319 1
a2319 1
    usbd_pipe_handle pipeh, uint32_t *size, int flags)
@


1.55
log
@garbage collect "usb events".  without /dev/usb there is no way to access
them from userland, and nothing in the kernel uses them.

ok krw@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.54 2010/12/06 04:41:39 jakemsr Exp $ */
a513 2
	case DVACT_ACTIVATE:
		break;
@


1.54
log
@* replace per-driver dying and/or other state variables with use of
  usbd_deactivete() and usbd_is_dying()
* use usbd_deactivate() in activate()/DEACTIVATE
* convert a few more direct checks of the associated bus' dying flag
  with usbd_is_dying()
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.53 2010/10/27 17:51:11 jakemsr Exp $ */
a451 2
	usbd_add_drv_event(USB_EVENT_DRIVER_ATTACH, sc->sc_udev, &sc->sc_dev);

a503 2

	usbd_add_drv_event(USB_EVENT_DRIVER_DETACH, sc->sc_udev, &sc->sc_dev);
@


1.53
log
@don't free network related resources if they were not allocated
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.52 2010/10/23 16:14:07 jakemsr Exp $ */
a456 3
	/* device attached */
	sc->sc_flags |= UPGT_DEVICE_ATTACHED;

d515 2
d521 1
@


1.52
log
@check that a timeout(9) has been initialized before deleting it

ok phessler
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.51 2010/10/23 15:42:09 jakemsr Exp $ */
d502 1
a502 1
	if (sc->sc_flags & UPGT_DEVICE_ATTACHED) {
@


1.51
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.50 2010/08/27 17:08:01 jsg Exp $ */
d489 4
a492 2
	timeout_del(&sc->scan_to);
	timeout_del(&sc->led_to);
@


1.50
log
@remove the unused if_init callback in struct ifnet
ok deraadt@@ henning@@ claudio@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.49 2010/04/20 22:05:43 tedu Exp $ */
d276 3
a278 2
	usb_init_task(&sc->sc_task_newstate, upgt_newstate_task, sc);
	usb_init_task(&sc->sc_task_tx, upgt_tx_task, sc);
@


1.49
log
@remove proc.h include from uvm_map.h.  This has far reaching effects, as
sysctl.h was reliant on this particular include, and many drivers included
sysctl.h unnecessarily.  remove sysctl.h or add proc.h as needed.
ok deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.48 2009/10/13 19:33:17 pirofti Exp $ */
a423 1
	ifp->if_init = upgt_init;
@


1.48
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.47 2009/08/10 20:02:19 deraadt Exp $ */
a22 1
#include <sys/sysctl.h>
@


1.47
log
@USB network devices do not DMA in a way that requires a shutdown function
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.46 2009/08/03 09:33:10 blambert Exp $ */
d92 1
a92 1
int		upgt_activate(struct device *, enum devact);
d515 1
a515 1
upgt_activate(struct device *self, enum devact act)
@


1.46
log
@timeout_add -> timeout_add_msec

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.45 2009/08/02 10:38:34 miod Exp $ */
a90 1
void		upgt_shutdown_hook(void *);
a457 3
	/* setup shutdown hook */
	sc->sc_sdhook = shutdownhook_establish(upgt_shutdown_hook, sc);

a465 12
void
upgt_shutdown_hook(void *arg)
{
	struct upgt_softc *sc = (struct upgt_softc *)arg;

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);

	/* reset device */
	upgt_set_led(sc, UPGT_LED_OFF);
	(void)upgt_device_init(sc);
}

a506 3
	if (sc->sc_sdhook != NULL)
		shutdownhook_disestablish(sc->sc_sdhook);

d1277 2
@


1.45
log
@Never return nonzero in a device activate method invoked with DVACT_ACTIVATE,
for this prevents it to be invoked with DVACT_DEACTIVATE later. This had
been sweeped some time ago already, but bad constructs crept in again.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.44 2009/04/09 09:15:24 mglocker Exp $ */
d1366 1
a1366 1
		timeout_add(&sc->scan_to, hz / 5);
@


1.44
log
@Remove obsolete braces around case switch.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.43 2009/03/27 11:11:37 jsg Exp $ */
d538 1
a538 1
		return (EOPNOTSUPP);
@


1.43
log
@Add a bunch of GW3887/v2 based upgt devices found in linux driver.
ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.42 2009/02/14 20:05:09 chl Exp $ */
d539 1
a539 1
	case (DVACT_DEACTIVATE):
@


1.42
log
@remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok fgsch@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.41 2008/11/27 14:05:18 kevlo Exp $ */
d168 1
d170 2
d175 1
d180 2
d183 1
d187 1
@


1.41
log
@The Netgear WG1111v2 wifi dongle contains a RTL8187 chip,
not a GW3887 chip.

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.40 2008/11/25 08:25:02 kevlo Exp $ */
a1340 1
	enum ieee80211_state ostate;
a1341 2

	ostate = ic->ic_state;
@


1.40
log
@upgt(4) doesn't use amrr, remove useless header net80211/ieee80211_amrr.h

ok mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.39 2008/10/14 18:01:53 naddy Exp $ */
a175 1
	{ USB_VENDOR_NETGEAR,		USB_PRODUCT_NETGEAR_WG111V2_2 },
@


1.39
log
@Change m_devget()'s outdated and unused "offset" argument:  It is
now the offset into the first mbuf of the target chain before copying
the source data over.  From FreeBSD.

Convert drivers' use of m_devget().  Mostly from thib@@.

Update mbuf(9) man page.

ok claudio@@, thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.38 2008/08/27 10:34:24 damien Exp $ */
a51 1
#include <net80211/ieee80211_amrr.h>
@


1.38
log
@pass FCS to radiotap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.37 2008/08/08 12:20:24 thib Exp $ */
d1783 1
a1783 2
	m = m_devget(rxdesc->data - ETHER_ALIGN, pkglen + ETHER_ALIGN, 0, ifp,
	    NULL);
a1788 1
	m_adj(m, ETHER_ALIGN);
@


1.37
log
@if we fail to extract the mbuf in the Rx routine, increment
the if_ierrors before bailing out;
Turn a printf() that fires in this case too a DPRINTF since we
the interface error counters now reflect this.

OK mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.36 2008/07/21 18:43:19 damien Exp $ */
a1791 3
	/* trim FCS */
	m_adj(m, -IEEE80211_CRC_LEN);

d1799 1
a1799 1
		tap->wr_flags = 0;
d1814 2
@


1.36
log
@instead of passing rx tstamp and rssi to the ieee80211_input function,
pass a pointer to an ieee80211_rxinfo structure containing those two
fields plus an extra flags field that indicates whether the frame was
decrypted by hardware or not.
required for a future fix.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.35 2008/04/16 18:32:15 damien Exp $ */
d1786 2
a1787 1
		printf("%s: could not create RX mbuf!\n", sc->sc_dev.dv_xname);
@


1.35
log
@Kernel implementation of the 4-way handshake and group-key
handshake protocols (both supplicant and authenticator state
machines) as defined in the IEEE 802.11i standard.

Software implementation of the TKIP (Temporal Key Integrity
Protocol) and CCMP (CTR with CBC-MAC Protocol) protocols.

This diff doesn't implement any of the 802.1X authentication
protocols and thus only PSK authentication (using pre-shared
keys) is currently supported.

In concrete terms, this adds support for WPA-PSK and WPA2-PSK
protocols, both in station and hostap modes.

The following drivers are marked as WPA-capable and should
work:  bwi(4), malo(4), ral(4), iwn(4), wpi(4), ural(4),
rum(4), upgt(4), and zyd(4)

The following options have been added to ifconfig(8):
wpa, wpapsk, wpaprotos, wpaakms, wpaciphers, wpagroupcipher

wpa-psk(8) can be used to generate keys from passphrases.

tested by many@@
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.34 2008/02/16 21:56:43 mglocker Exp $ */
d1774 1
d1821 4
a1824 1
	ieee80211_input(ifp, m, ni, rxdesc->rssi, 0);
@


1.34
log
@Remove if_ipackets++ since ieee80211_input() already does that.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.33 2008/02/02 13:48:44 mglocker Exp $ */
d404 2
a405 1
	    IEEE80211_C_WEP;
a1510 1
	struct ifnet *ifp = &ic->ic_if;
d1512 1
d1537 1
a1537 1
		 * Software WEP.
d1541 4
a1544 3
		if (wh->i_fc[1] & IEEE80211_FC1_WEP) {
			m = ieee80211_wep_crypt(ifp, m, 1);
			if (m == NULL)
d1546 1
@


1.33
log
@- Add a v1 device which I found here.
- Differ between v1 and v2 devices for later v1 support.
- Tell the end-user that v1 is not supported yet.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.32 2008/01/27 21:05:59 mglocker Exp $ */
a1820 3

	/* increment success incoming packet counter */
	ifp->if_ipackets++;
@


1.32
log
@Add TODO's to comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.31 2008/01/25 07:12:41 mglocker Exp $ */
d96 1
d161 7
a167 1
static const struct usb_devno upgt_devs[] = {
d193 7
a199 2
	return ((usb_lookup(upgt_devs, uaa->vendor, uaa->product) != NULL) ?
	    UMATCH_VENDOR_PRODUCT : UMATCH_NONE);
d217 4
d534 16
@


1.31
log
@Since TX rate control is done by the firmware, we report the maximum
rate which is available.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.30 2008/01/24 22:35:08 mglocker Exp $ */
d66 7
d1552 1
a1552 1
			tap->wt_rate = 0;	/* TODO: where to get? */
@


1.30
log
@Fix some comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.29 2008/01/24 21:44:32 mglocker Exp $ */
d1341 6
@


1.29
log
@We don't report the antenna in the bpf tap.  Remove it.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.28 2008/01/24 21:24:05 mglocker Exp $ */
a232 1
		 * XXX Just get the version 2 bulk pipes for now.
d235 4
a238 2
		 * 0x02 TX MGMT pipe (not used with fw version >2.5.x)
		 * 0x82 TX MGMT pipe (not used with fw version >2.5.x)
d1539 1
a1539 1
			tap->wt_rate = 0;
@


1.28
log
@Report RX rates in radio tap.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.27 2008/01/22 21:26:25 mglocker Exp $ */
a1542 1
			tap->wt_antenna = 0;
a1754 1
		tap->wr_antenna = 0;
@


1.27
log
@- Fix some ifconfig up / down tweaks.
- Make monitor mode work again.
- Enable fast channel switching.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.26 2008/01/21 19:37:36 mglocker Exp $ */
d121 1
d1753 1
a1753 1
		tap->wr_rate = 0;
d1827 62
@


1.26
log
@Add shutdown hook which resets the device when called.  This solves
re-attach issues when rebooting with upgt attached.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.25 2008/01/20 23:34:12 mglocker Exp $ */
d1144 1
d1170 2
a1171 2
			ether_addmulti(ifr, &ic->ic_ac) :
			ether_delmulti(ifr, &ic->ic_ac);
d1175 15
d1226 4
a1229 1
	if (ic->ic_opmode == IEEE80211_M_MONITOR)
d1231 1
a1231 2
	else {
		upgt_set_macfilter(sc, IEEE80211_S_SCAN);
a1232 1
	}
d1256 1
d1259 2
d1264 3
a1266 1
	if (ifp->if_flags & (IFF_UP | IFF_RUNNING))
d1268 1
d1340 2
a1341 1
		upgt_set_macfilter(sc, IEEE80211_S_RUN);
@


1.25
log
@Remove obsolete rateset variables.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.24 2008/01/20 23:31:50 mglocker Exp $ */
d84 2
a85 1
void		upgt_attachhook(void *);
d284 1
a284 1
		mountroothook_establish(upgt_attachhook, sc);
d286 1
a286 1
		upgt_attachhook(sc);
d294 1
a294 1
upgt_attachhook(void *arg)
d427 3
d438 12
d490 3
@


1.24
log
@Cleanup rates:
- The device (firmware) does automatic rate control for 11b/g.
- Allow user to set fixed rates.
- Send management frames always at DS1.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.23 2008/01/20 11:55:07 mglocker Exp $ */
a167 8

/*
 * XXX For now just keep the device ratesets here.
 * It seems the device does hardware rate control based on those available
 * ratesets.
 */
uint8_t rates_11g[] = { 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x04, 0x01 };
uint8_t rates_11b[] = { 0x13, 0x13, 0x12, 0x11, 0x11, 0x10, 0x10, 0x10 };
@


1.23
log
@Read EEPROM content the other way around (from start to end).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.22 2008/01/20 10:49:55 mglocker Exp $ */
d119 1
d1191 4
a1194 1
	sc->sc_curchan = ieee80211_chan2ieee(ic, ic->ic_bss->ni_chan);
d1462 2
d1485 8
a1492 6
		/*
		 * XXX As soon we have found out why the device crashes on
		 * higher rates, we need to switch dynamically between 11b
		 * and 11g here.  For now we set 11b fix.
		 */
		bcopy(rates_11g, txdesc->rates, sizeof(txdesc->rates));
d1748 43
@


1.22
log
@Adjust level 1 debug messages.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.21 2008/01/20 00:14:41 mglocker Exp $ */
d869 1
d871 1
a871 4
	offset = UPGT_EEPROM_SIZE;
	while (offset > 0) {
		offset = offset - block;

d915 3
a917 2
		if (offset < block)
			block = offset;
@


1.21
log
@Add one more device which could work.  Fix comment typo in usbdevs while
there.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.20 2008/01/19 10:39:22 mglocker Exp $ */
d448 2
d1212 2
a1979 2

	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);
@


1.20
log
@Make the device work again on big endian archs (after firmware upgrade).

Tested on macppc.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.19 2008/01/18 21:31:16 mglocker Exp $ */
d156 1
@


1.19
log
@Add LED support.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.18 2008/01/17 20:46:51 mglocker Exp $ */
d135 2
a136 2
uint32_t	upgt_crc32(const void *, size_t);
uint32_t	upgt_chksum(const uint32_t *, size_t);
d757 1
a757 1
	x2->crc = htole32(upgt_crc32(data_cmd->buf + UPGT_X2_SIGNATURE_SIZE,
d759 1
a759 1
	    sizeof(uint32_t)));
d790 1
a790 1
	crc32 = htole32(upgt_crc32(sc->sc_fw, sc->sc_fw_size));
d899 2
a900 2
		mem->chksum = htole32(upgt_chksum((uint32_t *)eeprom,
		    len - sizeof(*mem)));
d1517 2
a1518 2
		mem->chksum = htole32(upgt_chksum((uint32_t *)txdesc,
		    len - sizeof(*mem)));
d1787 1
a1787 1
		filter->rxhw = htole16(sc->sc_eeprom_hwrx);
d1800 1
a1800 1
		filter->rxhw = htole16(sc->sc_eeprom_hwrx);
d1811 2
a1812 2
	mem->chksum = htole32(upgt_chksum((uint32_t *)filter,
	    len - sizeof(*mem)));
d1871 2
a1872 2
	mem->chksum = htole32(upgt_chksum((uint32_t *)chan,
	    len - sizeof(*mem)));
d1949 2
a1950 2
	mem->chksum = htole32(upgt_chksum((uint32_t *)led,
	    len - sizeof(*mem)));
d2001 2
a2002 2
	mem->chksum = htole32(upgt_chksum((uint32_t *)stats,
	    len - sizeof(*mem)));
d2173 1
a2173 1
upgt_crc32(const void *buf, size_t size)
d2180 1
a2180 1
	crc = crc ^ 0xffffffffU;
d2190 1
a2190 1
upgt_chksum(const uint32_t *buf, size_t size)
d2196 2
a2197 2
		crc ^= *buf++;
		crc = (crc >> 5) ^ (crc << 3);
@


1.18
log
@Fix RX queue stalling by regulary reading the device statistics (with a
firmware command).  Doh!  We can now reliable communicate in 11g.

Took me about 3 weeks to find out (just had to say that).
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.17 2008/01/17 07:23:45 mglocker Exp $ */
d121 2
d251 1
a251 1
	/* init tasks */
d255 1
d463 1
d1271 1
d1299 1
d1431 2
d1881 85
@


1.17
log
@Replace firmware version 2.5.8.0 with 2.13.1.0.  Firmware API slightly
changes.

You need to update the firmware package to upgt-firmware-1.1.tgz.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.16 2008/01/04 11:50:14 mglocker Exp $ */
d121 1
d1532 7
d1644 7
d1873 46
@


1.16
log
@Fix wrong sizeof().  Makes driver work on amd64, too.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.15 2008/01/04 10:04:07 mglocker Exp $ */
d133 1
d360 1
d857 1
d870 1
a870 1
		 * Transmit the first URB containing the Prism memory address.
d872 4
a875 2
		*((uint32_t *)data_cmd->buf) =
		    htole32(sc->sc_memaddr_frame_start +
d878 1
a878 12
		len = sizeof(uint32_t);
		if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0)
		    != 0) {
			printf("%s: could not transmit EEPROM memaddr URB!\n",
			    sc->sc_dev.dv_xname);
			return (EIO);
		}

		/*
		 * Transmit the second URB containing the CMD data itself.
		 */
		eeprom = (struct upgt_lmac_eeprom *)data_cmd->buf;
d892 7
a898 3
		len = sizeof(struct upgt_lmac_eeprom) + block;
		if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0)
		    != 0) {
d1415 1
d1419 4
a1422 1
	int len, i;
d1448 1
a1448 1
		 * Transmit the first URB containing the Prism memory address.
d1450 1
a1450 1
		*((uint32_t *)data_tx->buf) = htole32(addr);
d1452 2
a1453 7
		len = sizeof(uint32_t);
		if (upgt_bulk_xmit(sc, data_tx, sc->sc_tx_pipeh, &len, 0)
		    != 0) {
			printf("%s: could not transmit TX memaddr URB!\n",
			    sc->sc_dev.dv_xname);
			return;
		}
d1455 1
a1455 8
		DPRINTF(2, "%s: TX memaddr sent (0x%08x)\n",
		    sc->sc_dev.dv_xname, data_tx->addr);

		/*
		 * Transmit the second URB containing the TX data itself.
		 */
		bzero(data_tx->buf, MCLBYTES);
		txdesc = (struct upgt_lmac_tx_desc *)data_tx->buf;
d1471 1
a1471 1
		bcopy(rates_11b, txdesc->rates, sizeof(txdesc->rates));
a1496 1

d1499 4
a1502 1
		    data_tx->buf + sizeof(struct upgt_lmac_tx_desc));
d1504 6
a1509 1
		len = sizeof(struct upgt_lmac_tx_desc) + m->m_pkthdr.len;
d1517 5
a1521 2
		if (upgt_bulk_xmit(sc, data_tx, sc->sc_tx_pipeh, &len, 0)
		    != 0) {
d1530 2
d1603 1
a1603 1
	header = (struct upgt_lmac_header *)data_rx->buf;
d1610 1
a1610 1
		eeprom = (struct upgt_lmac_eeprom *)data_rx->buf;
d1617 1
a1617 1
		bcopy(data_rx->buf + sizeof(struct upgt_lmac_eeprom),
d1628 1
a1628 1
		upgt_tx_done(sc, data_rx->buf);
d1635 1
a1635 1
		upgt_rx(sc, data_rx->buf, letoh16(header->header1.len));
d1721 1
d1727 1
a1727 1
	 * Transmit the first URB containing the Prism memory address.
d1729 1
a1729 9
	*((uint32_t *)data_cmd->buf) =
	    htole32(sc->sc_memaddr_frame_start + UPGT_MEMSIZE_FRAME_HEAD);

	len = sizeof(uint32_t);
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit macfilter CMD memaddr URB!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}
d1731 3
a1733 4
	/*
	 * Transmit the second URB containing the CMD data itself.
	 */
	bzero(data_cmd->buf, MCLBYTES);
d1735 1
a1735 1
	filter = (struct upgt_lmac_filter *)data_cmd->buf;
d1761 1
d1763 1
d1765 1
a1765 1
		filter->unknown5 = htole16(UPGT_FILTER_UNKNOWN5_V2);
d1774 1
a1774 1
		filter->unknown2 = htole32(UPGT_FILTER_UNKNOWN2_STA);
d1776 1
a1776 1
		filter->unknown5 = htole16(UPGT_FILTER_UNKNOWN5_V2);
d1778 1
a1778 1
		filter->unknown6 = htole16(UPGT_FILTER_UNKNOWN6_STA);
d1786 5
a1790 1
	len = sizeof(struct upgt_lmac_filter);
d1804 1
d1811 1
a1811 1
	 * Transmit the first URB containing the Prism memory address.
d1813 1
a1813 9
	*((uint32_t *)data_cmd->buf) =
	    htole32(sc->sc_memaddr_frame_start + UPGT_MEMSIZE_FRAME_HEAD);

	len = sizeof(uint32_t);
	if (upgt_bulk_xmit(sc, data_cmd, sc->sc_tx_pipeh, &len, 0) != 0) {
		printf("%s: could not transmit channel CMD memaddr URB!\n",
		    sc->sc_dev.dv_xname);
		return (EIO);
	}
d1815 3
a1817 4
	/*
	 * Transmit the second URB containing the CMD data itself.
	 */
	bzero(data_cmd->buf, MCLBYTES);
d1819 1
a1819 1
	chan = (struct upgt_lmac_channel *)data_cmd->buf;
d1846 5
a1850 1
	len = sizeof(struct upgt_lmac_channel);
a1984 3
/*
 * For this device we use usbd_bulk_transfer() for all TX transfers.
 */
d2027 18
@


1.15
log
@Fix TX padding.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.14 2008/01/03 14:47:19 mglocker Exp $ */
d622 1
a622 1
	for (offset = 0; offset < sc->sc_fw_size; offset += sizeof(uc)) {
d627 1
a627 1
	for (; offset < sc->sc_fw_size; offset += sizeof(uc)) {
d647 1
a647 1
		bra_option_len = letoh32(bra_option->len) * sizeof(uc);
@


1.14
log
@Fix page fault trap which occured when device was detached after a failed
attach attempt.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.13 2008/01/02 10:07:26 mglocker Exp $ */
a71 1
#define UPGT_DEBUG
d1483 1
a1483 1
		txdesc->pad3 = UPGT_TX_DESC_PAD3_SIZE;
@


1.13
log
@Make network scanning work correctly.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.12 2008/01/01 20:20:30 mglocker Exp $ */
d72 1
a441 4
	if (!(sc->sc_flags & UPGT_DEVICE_ATTACHED))
		/* device was not properly attached */
		return (0);

a443 5
	/* remove tasks and timeouts */
	usb_rem_task(sc->sc_udev, &sc->sc_task_newstate);
	usb_rem_task(sc->sc_udev, &sc->sc_task_tx);
	timeout_del(&sc->scan_to);

d454 5
d467 5
a471 3
	/* detach interface */
	ieee80211_ifdetach(ifp);
	if_detach(ifp);
@


1.12
log
@Add devices 11b rateset.  Add/Adjust comments.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.11 2008/01/01 11:43:48 mglocker Exp $ */
a1188 5
	/* set default channel */
	upgt_set_channel(sc, sc->sc_curchan);

	upgt_set_macfilter(sc, IEEE80211_S_SCAN);

d1194 2
a1195 1
	else
d1197 1
a1207 3
	/* do not accept any frames if the device is down */
	upgt_set_macfilter(sc, IEEE80211_S_INIT);

d1267 3
a1276 1

@


1.11
log
@No watchdog operations if device is not running.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.10 2008/01/01 10:10:20 mglocker Exp $ */
d163 7
a169 2
/* XXX for now just keep a rateset here */
uint8_t rates[] = { 0x0b, 0x0a, 0x09, 0x08, 0x07, 0x06, 0x04, 0x01 };
d233 1
a233 2
		 * XXX
		 * Just get the version 2 bulk pipes for now.
d1482 6
a1487 1
		bcopy(rates, txdesc->rates, sizeof(txdesc->rates));
d1489 1
a1489 1
		txdesc->pad3[0] = UPGT_TX_DESC_PAD3_SIZE;
@


1.10
log
@More constant naming for some defines.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.9 2008/01/01 10:03:44 mglocker Exp $ */
d1400 4
@


1.9
log
@Tune TX descriptor so we can successfully set some TX rates.  Could
do transfers between 1.3MB/s - 2MB/s.  Though still unreliable because
we have random TX watchdog timeouts.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.8 2007/12/22 11:16:40 mglocker Exp $ */
d1467 1
a1467 1
		txdesc->header1.type = UPGT_H1_TYPE_DATA_TX;
d1621 2
a1622 2
	if (h1_type == UPGT_H1_TYPE_DATA_RX ||
	    h1_type == UPGT_H1_TYPE_DATA_RX_MGMT) {
@


1.8
log
@Reset the MAC filter if we stop the device, so no frames are accepted
anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.7 2007/12/20 20:38:31 mglocker Exp $ */
a71 2
#define UPGT_DEBUG

d163 3
d1462 1
d1471 2
a1472 2
		txdesc->header2.type = htole16(UPGT_H2_TYPE_TX_NOACK);
		txdesc->header2.flags = 0;
d1474 1
d1476 1
a1476 4
		txdesc->unknown1 = 0;
		txdesc->unknown2 = 0;
		/* round TX descriptor header up to 4 byte boundary */
		txdesc->frame_pad = UPGT_TX_DESC_FRAME_PAD;
@


1.7
log
@More minor TX fixing (still sucks).  Add more debug info and leave debug
mode on for now.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.6 2007/12/19 22:43:59 mglocker Exp $ */
d1206 3
d1747 6
@


1.6
log
@Move watchdog timeout message from DPRINTF to printf.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.5 2007/12/19 22:37:01 mglocker Exp $ */
d72 2
d1420 2
a1421 1
			DPRINTF(2, "%d: m is NULL\n", i);
d1452 2
a1453 1
		DPRINTF(2, "%s: TX memaddr sent\n", sc->sc_dev.dv_xname);
d1503 7
d1517 2
a1518 5
		/* we do not need the mbuf anymore */
		m_freem(m);
		data_tx->m = NULL;

		DPRINTF(2, "%s: TX sent: len=%d\n", sc->sc_dev.dv_xname, len);
a1540 1
			data_tx->m = NULL;
d1552 1
@


1.5
log
@Fix page fault trap in TX path.  Though TX path is still not working
sane, resulting in watchdog timeout.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.4 2007/12/17 19:01:41 mglocker Exp $ */
d1393 1
a1393 3
	struct upgt_softc *sc;

	sc = ifp->if_softc;
d1395 1
a1395 1
	DPRINTF(1, "%s: %s\n", sc->sc_dev.dv_xname, __func__);
@


1.4
log
@Add new devices to match list.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.3 2007/12/17 00:10:03 mglocker Exp $ */
a1324 2
	usb_rem_task(sc->sc_udev, &sc->sc_task_tx);

d1340 1
a1340 1
				printf("%s: no free memory!\n",
d1369 1
a1369 1
				printf("%s: no free memory!\n",
d1385 1
d1419 2
a1420 1
		if (data_tx->m == NULL)
d1422 1
a1455 2
		bzero(data_tx->buf, MCLBYTES);

d1510 1
d1532 1
a1535 1
			upgt_mem_free(sc, data_tx->addr);
a1546 2

			break;
@


1.3
log
@Make ether_crc32_le() work for our needs and therefore remove the large
CRC-32 table.

Suggested by deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.2 2007/12/16 18:19:57 mglocker Exp $ */
d147 14
a160 1
	{ USB_VENDOR_SMC,	USB_PRODUCT_SMC_2862WG }
@


1.2
log
@Add comment.
@
text
@d1 1
a1 1
/*	$OpenBSD: if_upgt.c,v 1.1 2007/12/16 09:05:53 mglocker Exp $ */
a1991 50
/*
 * COPYRIGHT (C) 1986 Gary S. Brown.  You may use this program, or
 * code or tables extracted from it, as desired without restriction.
 */
static uint32_t upgt_crc32_tab[] = {
	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
};

a1994 1
	const uint8_t *p;
d1997 1
a1997 2
	p = buf;
	crc = ~0U;
d1999 2
a2000 2
	while (size--)
		crc = upgt_crc32_tab[(crc ^ *p++) & 0xff] ^ (crc >> 8);
d2002 1
a2002 1
	return (crc ^ ~0U);
@


1.1
log
@Inital driver for the Conexant/Intersil PrismGT SoftMAC USB 2.0 devices
based on the GW3887 chipset (b/g).

We are able to communicate more or less reliable with DS1 (1Mbps) yet.

Tested on i386 and macppc.

Short term TODOs:
- Find out how to set TX rates.
- Fix device hangup while high RX load.
- Improve device reset (reload firmware on init, watchdog, etc.).
- Fill man page with supported devices (need reports).
- Add AMRR rate control.
- Add HostAP mode.
- Add IBSS mode.
- Add LED support.
- ...

Long term TODOs:
- Support the USB 1.0 devices (NET2280, ISL3880, ISL3886 chipsets).

OK deraadt@@, OK laurent@@
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d66 4
@

