head	1.198;
access;
symbols
	OPENBSD_6_0:1.191.0.4
	OPENBSD_6_0_BASE:1.191
	OPENBSD_5_9:1.190.0.2
	OPENBSD_5_9_BASE:1.190
	OPENBSD_5_8:1.187.0.4
	OPENBSD_5_8_BASE:1.187
	OPENBSD_5_7:1.176.0.4
	OPENBSD_5_7_BASE:1.176
	OPENBSD_5_6:1.164.0.4
	OPENBSD_5_6_BASE:1.164
	OPENBSD_5_5:1.141.0.4
	OPENBSD_5_5_BASE:1.141
	OPENBSD_5_4:1.134.0.2
	OPENBSD_5_4_BASE:1.134
	OPENBSD_5_3:1.128.0.2
	OPENBSD_5_3_BASE:1.128
	OPENBSD_5_2:1.124.0.2
	OPENBSD_5_2_BASE:1.124
	OPENBSD_5_1_BASE:1.118
	OPENBSD_5_1:1.118.0.4
	OPENBSD_5_0:1.118.0.2
	OPENBSD_5_0_BASE:1.118
	OPENBSD_4_9:1.115.0.2
	OPENBSD_4_9_BASE:1.115
	OPENBSD_4_8:1.106.0.4
	OPENBSD_4_8_BASE:1.106
	OPENBSD_4_7:1.106.0.2
	OPENBSD_4_7_BASE:1.106
	OPENBSD_4_6:1.100.0.4
	OPENBSD_4_6_BASE:1.100
	OPENBSD_4_5:1.98.0.2
	OPENBSD_4_5_BASE:1.98
	OPENBSD_4_4:1.84.0.2
	OPENBSD_4_4_BASE:1.84
	OPENBSD_4_3:1.77.0.4
	OPENBSD_4_3_BASE:1.77
	OPENBSD_4_2:1.77.0.2
	OPENBSD_4_2_BASE:1.77
	OPENBSD_4_1:1.67.0.2
	OPENBSD_4_1_BASE:1.67
	OPENBSD_4_0:1.67.0.4
	OPENBSD_4_0_BASE:1.67
	OPENBSD_3_9:1.53.0.2
	OPENBSD_3_9_BASE:1.53
	OPENBSD_3_8:1.48.0.2
	OPENBSD_3_8_BASE:1.48
	OPENBSD_3_7:1.45.0.2
	OPENBSD_3_7_BASE:1.45
	OPENBSD_3_6:1.21.0.4
	OPENBSD_3_6_BASE:1.21
	SMP_SYNC_A:1.5
	SMP_SYNC_B:1.5
	SMP:1.5.0.2
	UBC_SYNC_A:1.2
	UBC_SYNC_B:1.2;
locks; strict;
comment	@ * @;


1.198
date	2017.03.30.14.44.36;	author deraadt;	state Exp;
branches;
next	1.197;
commitid	KUKKknQ7CM6pTxJV;

1.197
date	2017.03.10.11.18.48;	author mpi;	state Exp;
branches;
next	1.196;
commitid	KVR8Na3SYXI1y1RS;

1.196
date	2017.03.10.09.14.06;	author mpi;	state Exp;
branches;
next	1.195;
commitid	3KSzSoIpPvZCUNqm;

1.195
date	2016.11.08.10.31.30;	author mpi;	state Exp;
branches;
next	1.194;
commitid	O7aOV0gp3jDbAW9d;

1.194
date	2016.10.02.06.36.39;	author kettenis;	state Exp;
branches;
next	1.193;
commitid	IMFyKh2keS7O5Fww;

1.193
date	2016.09.15.02.00.17;	author dlg;	state Exp;
branches;
next	1.192;
commitid	RlO92XR575sygHqm;

1.192
date	2016.08.18.11.59.58;	author jsg;	state Exp;
branches;
next	1.191;
commitid	8TQLVxHwXJgLkkLj;

1.191
date	2016.07.20.09.48.07;	author mpi;	state Exp;
branches;
next	1.190;
commitid	Hguddd2oJVbTACZE;

1.190
date	2015.12.11.12.23.09;	author mpi;	state Exp;
branches;
next	1.189;
commitid	KM4shsQ5lF2T8T1j;

1.189
date	2015.11.14.17.27.21;	author mpi;	state Exp;
branches;
next	1.188;
commitid	v3iUfc72QW0H8bnK;

1.188
date	2015.11.02.14.55.41;	author mpi;	state Exp;
branches;
next	1.187;
commitid	vJlf2yHM5thwrjmA;

1.187
date	2015.06.26.11.17.34;	author mpi;	state Exp;
branches;
next	1.186;
commitid	EHLAwh7vfwmK7jPG;

1.186
date	2015.06.22.12.56.55;	author mpi;	state Exp;
branches;
next	1.185;
commitid	tsYSHGCfv1hy9V5u;

1.185
date	2015.04.16.14.23.48;	author mpi;	state Exp;
branches;
next	1.184;
commitid	eRle8DOk7C2XRFRd;

1.184
date	2015.04.10.15.33.20;	author mpi;	state Exp;
branches;
next	1.183;
commitid	cmVxVzfMOS7M0MGi;

1.183
date	2015.04.10.13.56.42;	author mpi;	state Exp;
branches;
next	1.182;
commitid	NEEggNm5YeE2QUZC;

1.182
date	2015.03.25.13.23.05;	author mpi;	state Exp;
branches;
next	1.181;
commitid	rVF7TOANKzoHy3PS;

1.181
date	2015.03.25.13.12.45;	author mpi;	state Exp;
branches;
next	1.180;
commitid	1YRWbcm9xnOBJbi4;

1.180
date	2015.03.25.13.06.04;	author mpi;	state Exp;
branches;
next	1.179;
commitid	2Y0pcrHjDc4bqH5b;

1.179
date	2015.03.25.13.00.38;	author mpi;	state Exp;
branches;
next	1.178;
commitid	1CQrdxdbDK6Bs55b;

1.178
date	2015.03.25.12.56.11;	author mpi;	state Exp;
branches;
next	1.177;
commitid	T5mDJcn4xLz0Droy;

1.177
date	2015.03.17.14.45.07;	author mpi;	state Exp;
branches;
next	1.176;
commitid	hKhWHNxk3ggqA3em;

1.176
date	2015.03.06.22.53.03;	author mpi;	state Exp;
branches;
next	1.175;
commitid	eKmCiqkUzvYBbnNO;

1.175
date	2015.02.28.09.22.59;	author mpi;	state Exp;
branches;
next	1.174;
commitid	dCZkWFdufOrlJLdp;

1.174
date	2015.02.09.22.14.43;	author uebayasi;	state Exp;
branches;
next	1.173;
commitid	LGSxLRcnrxn6dxQ9;

1.173
date	2014.12.19.22.44.59;	author guenther;	state Exp;
branches;
next	1.172;
commitid	LS2TNeCue5R9L67C;

1.172
date	2014.12.17.15.27.49;	author kettenis;	state Exp;
branches;
next	1.171;
commitid	nyx881EUiIK6OGRj;

1.171
date	2014.12.09.07.05.06;	author doug;	state Exp;
branches;
next	1.170;
commitid	zM5ckwX4kwwmipG0;

1.170
date	2014.11.18.02.37.30;	author tedu;	state Exp;
branches;
next	1.169;
commitid	Z1vcFtHO8wRH0yRt;

1.169
date	2014.10.05.08.40.29;	author mpi;	state Exp;
branches;
next	1.168;
commitid	gcxpPOCDYm495eL7;

1.168
date	2014.09.01.08.13.02;	author mpi;	state Exp;
branches;
next	1.167;
commitid	J2I4AIhHGYjRpuoh;

1.167
date	2014.08.30.09.33.11;	author mpi;	state Exp;
branches;
next	1.166;
commitid	jlL5Vn6KFEAcR9aL;

1.166
date	2014.08.10.11.18.57;	author mpi;	state Exp;
branches;
next	1.165;
commitid	soKLg6qedOsGZg3L;

1.165
date	2014.08.10.11.00.35;	author mpi;	state Exp;
branches;
next	1.164;
commitid	EhRr39ksGEEyKpMd;

1.164
date	2014.08.05.20.26.15;	author mpi;	state Exp;
branches;
next	1.163;
commitid	kKc3w7FVrfZXrW2N;

1.163
date	2014.08.03.14.30.28;	author jsg;	state Exp;
branches;
next	1.162;
commitid	zAXpknN5mfGpGsdQ;

1.162
date	2014.07.12.20.13.48;	author mpi;	state Exp;
branches;
next	1.161;
commitid	2p79UAVIqrMYziEA;

1.161
date	2014.07.12.08.21.10;	author mpi;	state Exp;
branches;
next	1.160;
commitid	vjBEvarlXElSm4JF;

1.160
date	2014.07.10.20.57.40;	author mpi;	state Exp;
branches;
next	1.159;
commitid	x8n2LAVH0xAVN591;

1.159
date	2014.07.09.15.47.54;	author mpi;	state Exp;
branches;
next	1.158;
commitid	d8ZHVs7unt3KxWXc;

1.158
date	2014.06.04.13.52.30;	author mpi;	state Exp;
branches;
next	1.157;
commitid	MFXEmVLW2RJQYk5A;

1.157
date	2014.06.04.12.28.21;	author mpi;	state Exp;
branches;
next	1.156;
commitid	omWT0R9guKUnrNWN;

1.156
date	2014.05.30.13.24.59;	author mpi;	state Exp;
branches;
next	1.155;

1.155
date	2014.05.16.19.00.18;	author mpi;	state Exp;
branches;
next	1.154;

1.154
date	2014.05.16.18.17.03;	author mpi;	state Exp;
branches;
next	1.153;

1.153
date	2014.05.09.11.01.06;	author mpi;	state Exp;
branches;
next	1.152;

1.152
date	2014.05.08.14.00.52;	author mpi;	state Exp;
branches;
next	1.151;

1.151
date	2014.05.04.14.42.36;	author mpi;	state Exp;
branches;
next	1.150;

1.150
date	2014.05.04.14.31.50;	author mpi;	state Exp;
branches;
next	1.149;

1.149
date	2014.04.29.14.11.23;	author mpi;	state Exp;
branches;
next	1.148;

1.148
date	2014.04.29.12.45.29;	author mpi;	state Exp;
branches;
next	1.147;

1.147
date	2014.04.27.14.48.10;	author mpi;	state Exp;
branches;
next	1.146;

1.146
date	2014.03.25.20.27.37;	author mpi;	state Exp;
branches;
next	1.145;

1.145
date	2014.03.15.09.49.28;	author mpi;	state Exp;
branches;
next	1.144;

1.144
date	2014.03.11.10.24.42;	author mpi;	state Exp;
branches;
next	1.143;

1.143
date	2014.03.07.09.51.50;	author mpi;	state Exp;
branches;
next	1.142;

1.142
date	2014.03.07.09.38.14;	author mpi;	state Exp;
branches;
next	1.141;

1.141
date	2014.02.24.18.21.20;	author mpi;	state Exp;
branches;
next	1.140;

1.140
date	2014.01.15.11.10.40;	author mpi;	state Exp;
branches;
next	1.139;

1.139
date	2013.12.06.21.03.04;	author deraadt;	state Exp;
branches;
next	1.138;

1.138
date	2013.11.09.08.46.05;	author mpi;	state Exp;
branches;
next	1.137;

1.137
date	2013.11.09.08.40.32;	author mpi;	state Exp;
branches;
next	1.136;

1.136
date	2013.11.07.10.15.15;	author mpi;	state Exp;
branches;
next	1.135;

1.135
date	2013.11.01.12.00.53;	author mpi;	state Exp;
branches;
next	1.134;

1.134
date	2013.06.12.11.42.01;	author mpi;	state Exp;
branches;
next	1.133;

1.133
date	2013.05.30.16.15.02;	author deraadt;	state Exp;
branches;
next	1.132;

1.132
date	2013.05.20.08.19.47;	author yasuoka;	state Exp;
branches;
next	1.131;

1.131
date	2013.04.19.08.58.53;	author mpi;	state Exp;
branches;
next	1.130;

1.130
date	2013.04.15.09.23.01;	author mglocker;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.28.03.58.03;	author tedu;	state Exp;
branches;
next	1.128;

1.128
date	2012.10.09.13.41.04;	author deraadt;	state Exp;
branches;
next	1.127;

1.127
date	2012.10.08.21.47.50;	author deraadt;	state Exp;
branches;
next	1.126;

1.126
date	2012.08.17.17.29.00;	author krw;	state Exp;
branches;
next	1.125;

1.125
date	2012.08.07.23.51.36;	author krw;	state Exp;
branches;
next	1.124;

1.124
date	2012.07.07.12.54.04;	author mpi;	state Exp;
branches;
next	1.123;

1.123
date	2012.06.23.14.15.02;	author mpi;	state Exp;
branches;
next	1.122;

1.122
date	2012.06.23.14.09.42;	author mpi;	state Exp;
branches;
next	1.121;

1.121
date	2012.05.13.08.37.52;	author mpi;	state Exp;
branches;
next	1.120;

1.120
date	2012.05.12.17.39.51;	author mpi;	state Exp;
branches;
next	1.119;

1.119
date	2012.05.12.17.36.34;	author mpi;	state Exp;
branches;
next	1.118;

1.118
date	2011.07.10.17.34.53;	author eric;	state Exp;
branches;
next	1.117;

1.117
date	2011.07.03.15.47.17;	author matthew;	state Exp;
branches;
next	1.116;

1.116
date	2011.06.23.16.02.33;	author tedu;	state Exp;
branches;
next	1.115;

1.115
date	2010.12.14.16.13.16;	author jakemsr;	state Exp;
branches;
next	1.114;

1.114
date	2010.12.06.06.09.08;	author jakemsr;	state Exp;
branches;
next	1.113;

1.113
date	2010.10.23.15.42.09;	author jakemsr;	state Exp;
branches;
next	1.112;

1.112
date	2010.09.29.20.06.38;	author kettenis;	state Exp;
branches;
next	1.111;

1.111
date	2010.09.23.08.39.32;	author jakemsr;	state Exp;
branches;
next	1.110;

1.110
date	2010.09.07.16.21.46;	author deraadt;	state Exp;
branches;
next	1.109;

1.109
date	2010.08.31.17.13.47;	author deraadt;	state Exp;
branches;
next	1.108;

1.108
date	2010.08.30.21.30.15;	author deraadt;	state Exp;
branches;
next	1.107;

1.107
date	2010.08.27.04.09.20;	author deraadt;	state Exp;
branches;
next	1.106;

1.106
date	2009.11.26.12.27.48;	author deraadt;	state Exp;
branches;
next	1.105;

1.105
date	2009.11.24.00.31.13;	author jakemsr;	state Exp;
branches;
next	1.104;

1.104
date	2009.11.04.19.14.10;	author kettenis;	state Exp;
branches;
next	1.103;

1.103
date	2009.10.13.19.33.17;	author pirofti;	state Exp;
branches;
next	1.102;

1.102
date	2009.09.05.10.25.55;	author miod;	state Exp;
branches;
next	1.101;

1.101
date	2009.07.24.08.15.38;	author blambert;	state Exp;
branches;
next	1.100;

1.100
date	2009.06.02.23.49.33;	author deraadt;	state Exp;
branches;
next	1.99;

1.99
date	2009.04.20.14.11.57;	author reyk;	state Exp;
branches;
next	1.98;

1.98
date	2009.02.14.20.05.09;	author chl;	state Exp;
branches;
next	1.97;

1.97
date	2008.11.29.08.52.03;	author mglocker;	state Exp;
branches;
next	1.96;

1.96
date	2008.11.21.17.08.42;	author deraadt;	state Exp;
branches;
next	1.95;

1.95
date	2008.10.30.08.11.13;	author mglocker;	state Exp;
branches;
next	1.94;

1.94
date	2008.10.07.11.31.09;	author mglocker;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.06.20.18.56;	author mglocker;	state Exp;
branches;
next	1.92;

1.92
date	2008.09.15.13.44.09;	author mglocker;	state Exp;
branches;
next	1.91;

1.91
date	2008.09.15.11.31.06;	author mglocker;	state Exp;
branches;
next	1.90;

1.90
date	2008.09.10.14.01.23;	author blambert;	state Exp;
branches;
next	1.89;

1.89
date	2008.09.08.07.08.27;	author brad;	state Exp;
branches;
next	1.88;

1.88
date	2008.08.18.04.28.18;	author kevlo;	state Exp;
branches;
next	1.87;

1.87
date	2008.08.16.16.47.32;	author mglocker;	state Exp;
branches;
next	1.86;

1.86
date	2008.08.16.16.37.30;	author mglocker;	state Exp;
branches;
next	1.85;

1.85
date	2008.08.09.22.59.20;	author mglocker;	state Exp;
branches;
next	1.84;

1.84
date	2008.06.29.10.04.15;	author yuo;	state Exp;
branches;
next	1.83;

1.83
date	2008.06.26.05.42.18;	author ray;	state Exp;
branches;
next	1.82;

1.82
date	2008.06.09.23.21.48;	author kettenis;	state Exp;
branches;
next	1.81;

1.81
date	2008.06.02.09.58.15;	author yuo;	state Exp;
branches;
next	1.80;

1.80
date	2008.05.25.21.00.17;	author mbalmer;	state Exp;
branches;
next	1.79;

1.79
date	2008.05.15.08.10.03;	author kettenis;	state Exp;
branches;
next	1.78;

1.78
date	2008.04.16.16.08.39;	author mk;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.15.11.41.47;	author mbalmer;	state Exp;
branches;
next	1.76;

1.76
date	2007.06.14.12.58.09;	author mbalmer;	state Exp;
branches;
next	1.75;

1.75
date	2007.06.14.06.55.09;	author mbalmer;	state Exp;
branches;
next	1.74;

1.74
date	2007.06.12.16.26.36;	author mbalmer;	state Exp;
branches;
next	1.73;

1.73
date	2007.06.10.14.49.00;	author mbalmer;	state Exp;
branches;
next	1.72;

1.72
date	2007.06.10.10.15.35;	author mbalmer;	state Exp;
branches;
next	1.71;

1.71
date	2007.06.05.08.43.55;	author mbalmer;	state Exp;
branches;
next	1.70;

1.70
date	2007.06.04.10.34.04;	author mbalmer;	state Exp;
branches;
next	1.69;

1.69
date	2007.05.21.06.10.43;	author jsg;	state Exp;
branches;
next	1.68;

1.68
date	2007.05.20.00.52.25;	author jsg;	state Exp;
branches;
next	1.67;

1.67
date	2006.08.22.01.53.42;	author pascoe;	state Exp;
branches;
next	1.66;

1.66
date	2006.08.22.01.34.08;	author pascoe;	state Exp;
branches;
next	1.65;

1.65
date	2006.08.17.03.44.56;	author pascoe;	state Exp;
branches;
next	1.64;

1.64
date	2006.08.14.00.41.11;	author pascoe;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.14.00.28.07;	author pascoe;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.06.12.12.44;	author pascoe;	state Exp;
branches;
next	1.61;

1.61
date	2006.06.23.06.27.11;	author miod;	state Exp;
branches;
next	1.60;

1.60
date	2006.05.31.07.27.28;	author dlg;	state Exp;
branches;
next	1.59;

1.59
date	2006.05.31.06.59.56;	author pascoe;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.31.06.18.09;	author pascoe;	state Exp;
branches;
next	1.57;

1.57
date	2006.05.30.19.21.07;	author pascoe;	state Exp;
branches;
next	1.56;

1.56
date	2006.05.29.04.02.10;	author pascoe;	state Exp;
branches;
next	1.55;

1.55
date	2006.05.29.00.16.10;	author pascoe;	state Exp;
branches;
next	1.54;

1.54
date	2006.05.28.23.52.27;	author pascoe;	state Exp;
branches;
next	1.53;

1.53
date	2005.12.03.03.40.52;	author brad;	state Exp;
branches;
next	1.52;

1.52
date	2005.11.21.18.16.42;	author millert;	state Exp;
branches;
next	1.51;

1.51
date	2005.11.15.07.02.37;	author miod;	state Exp;
branches;
next	1.50;

1.50
date	2005.10.04.22.55.30;	author brad;	state Exp;
branches;
next	1.49;

1.49
date	2005.09.24.07.28.58;	author pascoe;	state Exp;
branches;
next	1.48;

1.48
date	2005.04.11.08.09.32;	author dlg;	state Exp;
branches;
next	1.47;

1.47
date	2005.04.10.09.57.02;	author dlg;	state Exp;
branches;
next	1.46;

1.46
date	2005.04.10.04.22.51;	author dlg;	state Exp;
branches;
next	1.45;

1.45
date	2005.03.13.02.54.04;	author pascoe;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.13.02.32.57;	author pascoe;	state Exp;
branches;
next	1.43;

1.43
date	2005.03.13.02.30.31;	author pascoe;	state Exp;
branches;
next	1.42;

1.42
date	2005.03.08.14.14.11;	author dlg;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.08.08.17.16;	author pascoe;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.08.08.06.36;	author pascoe;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.07.12.58.19;	author pascoe;	state Exp;
branches;
next	1.38;

1.38
date	2005.03.07.11.12.04;	author pascoe;	state Exp;
branches;
next	1.37;

1.37
date	2005.03.06.05.18.34;	author pascoe;	state Exp;
branches;
next	1.36;

1.36
date	2005.03.06.05.12.00;	author pascoe;	state Exp;
branches;
next	1.35;

1.35
date	2005.02.28.12.35.44;	author pascoe;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.28.00.34.09;	author pascoe;	state Exp;
branches;
next	1.33;

1.33
date	2004.12.29.01.52.27;	author dlg;	state Exp;
branches;
next	1.32;

1.32
date	2004.10.31.10.29.45;	author dlg;	state Exp;
branches;
next	1.31;

1.31
date	2004.10.31.10.24.16;	author dlg;	state Exp;
branches;
next	1.30;

1.30
date	2004.10.31.09.35.41;	author dlg;	state Exp;
branches;
next	1.29;

1.29
date	2004.10.31.09.26.57;	author dlg;	state Exp;
branches;
next	1.28;

1.28
date	2004.10.31.09.16.22;	author dlg;	state Exp;
branches;
next	1.27;

1.27
date	2004.10.31.08.29.53;	author dlg;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.31.08.09.16;	author dlg;	state Exp;
branches;
next	1.25;

1.25
date	2004.10.27.12.07.48;	author dlg;	state Exp;
branches;
next	1.24;

1.24
date	2004.10.20.12.45.31;	author dlg;	state Exp;
branches;
next	1.23;

1.23
date	2004.10.19.08.10.27;	author dlg;	state Exp;
branches;
next	1.22;

1.22
date	2004.09.30.11.33.56;	author dlg;	state Exp;
branches;
next	1.21;

1.21
date	2004.08.11.11.45.57;	author dlg;	state Exp;
branches;
next	1.20;

1.20
date	2004.08.11.04.29.13;	author dlg;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.12.15.30.28;	author deraadt;	state Exp;
branches;
next	1.18;

1.18
date	2004.07.10.13.08.41;	author deraadt;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.10.12.25.49;	author deraadt;	state Exp;
branches;
next	1.16;

1.16
date	2004.07.07.16.55.08;	author deraadt;	state Exp;
branches;
next	1.15;

1.15
date	2004.07.07.01.27.06;	author deraadt;	state Exp;
branches;
next	1.14;

1.14
date	2004.07.07.00.58.42;	author deraadt;	state Exp;
branches;
next	1.13;

1.13
date	2004.07.07.00.58.05;	author deraadt;	state Exp;
branches;
next	1.12;

1.12
date	2004.07.06.02.51.46;	author deraadt;	state Exp;
branches;
next	1.11;

1.11
date	2004.07.06.02.51.14;	author deraadt;	state Exp;
branches;
next	1.10;

1.10
date	2004.07.06.02.49.47;	author deraadt;	state Exp;
branches;
next	1.9;

1.9
date	2004.07.06.02.49.05;	author deraadt;	state Exp;
branches;
next	1.8;

1.8
date	2004.07.05.03.07.45;	author deraadt;	state Exp;
branches;
next	1.7;

1.7
date	2004.06.24.00.00.20;	author jolan;	state Exp;
branches;
next	1.6;

1.6
date	2004.06.20.00.17.49;	author deraadt;	state Exp;
branches;
next	1.5;

1.5
date	2004.05.30.01.25.17;	author tedu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2004.05.27.01.34.34;	author deraadt;	state Exp;
branches;
next	1.3;

1.3
date	2004.05.23.03.23.01;	author deraadt;	state Exp;
branches;
next	1.2;

1.2
date	2002.05.07.18.29.18;	author nate;	state dead;
branches;
next	1.1;

1.1
date	2002.05.07.18.08.04;	author nate;	state Exp;
branches;
next	;

1.5.2.1
date	2004.06.05.23.12.57;	author niklas;	state Exp;
branches;
next	;


desc
@@


1.198
log
@these free() size choices appear to be wrong.  joel has a diff that fixes
them, but for release let's be conservative and use 0.
@
text
@/*	$OpenBSD: ehci.c,v 1.197 2017/03/10 11:18:48 mpi Exp $ */
/*	$NetBSD: ehci.c,v 1.66 2004/06/30 03:11:56 mycroft Exp $	*/

/*
 * Copyright (c) 2014-2015 Martin Pieuchot
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */
/*
 * Copyright (c) 2004-2008 The NetBSD Foundation, Inc.
 * All rights reserved.
 *
 * This code is derived from software contributed to The NetBSD Foundation
 * by Lennart Augustsson (lennart@@augustsson.net), Charles M. Hannum and
 * Jeremy Morse (jeremy.morse@@gmail.com).
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE NETBSD FOUNDATION, INC. AND CONTRIBUTORS
 * ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
 * TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE FOUNDATION OR CONTRIBUTORS
 * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * TODO:
 * 1) The hub driver needs to handle and schedule the transaction translator,
 *    to assign place in frame where different devices get to go. See chapter
 *    on hubs in USB 2.0 for details.
 *
 * 2) Command failures are not recovered correctly.
 */

#include <sys/param.h>
#include <sys/systm.h>
#include <sys/kernel.h>
#include <sys/rwlock.h>
#include <sys/malloc.h>
#include <sys/device.h>
#include <sys/queue.h>
#include <sys/timeout.h>
#include <sys/pool.h>
#include <sys/endian.h>
#include <sys/atomic.h>

#include <machine/bus.h>

#include <dev/usb/usb.h>
#include <dev/usb/usbdi.h>
#include <dev/usb/usbdivar.h>
#include <dev/usb/usb_mem.h>

#include <dev/usb/ehcireg.h>
#include <dev/usb/ehcivar.h>

struct cfdriver ehci_cd = {
	NULL, "ehci", DV_DULL
};

#ifdef EHCI_DEBUG
#define DPRINTF(x)	do { if (ehcidebug) printf x; } while(0)
#define DPRINTFN(n,x)	do { if (ehcidebug>(n)) printf x; } while (0)
int ehcidebug = 0;
#define bitmask_snprintf(q,f,b,l) snprintf((b), (l), "%b", (q), (f))
#else
#define DPRINTF(x)
#define DPRINTFN(n,x)
#endif

struct pool *ehcixfer;

struct ehci_pipe {
	struct usbd_pipe pipe;

	struct ehci_soft_qh *sqh;
	union {
		/* Control pipe */
		struct {
			struct usb_dma reqdma;
		} ctl;
		/* Iso pipe */
		struct {
			u_int next_frame;
			u_int cur_xfers;
		} isoc;
	} u;
};

u_int8_t		ehci_reverse_bits(u_int8_t, int);

usbd_status	ehci_open(struct usbd_pipe *);
int		ehci_setaddr(struct usbd_device *, int);
void		ehci_poll(struct usbd_bus *);
void		ehci_softintr(void *);
int		ehci_intr1(struct ehci_softc *);
void		ehci_check_intr(struct ehci_softc *, struct usbd_xfer *);
void		ehci_check_qh_intr(struct ehci_softc *, struct usbd_xfer *);
void		ehci_check_itd_intr(struct ehci_softc *, struct usbd_xfer *);
void		ehci_idone(struct usbd_xfer *);
void		ehci_isoc_idone(struct usbd_xfer *);
void		ehci_timeout(void *);
void		ehci_timeout_task(void *);
void		ehci_intrlist_timeout(void *);

struct usbd_xfer *ehci_allocx(struct usbd_bus *);
void		ehci_freex(struct usbd_bus *, struct usbd_xfer *);

usbd_status	ehci_root_ctrl_transfer(struct usbd_xfer *);
usbd_status	ehci_root_ctrl_start(struct usbd_xfer *);
void		ehci_root_ctrl_abort(struct usbd_xfer *);
void		ehci_root_ctrl_close(struct usbd_pipe *);
void		ehci_root_ctrl_done(struct usbd_xfer *);

usbd_status	ehci_root_intr_transfer(struct usbd_xfer *);
usbd_status	ehci_root_intr_start(struct usbd_xfer *);
void		ehci_root_intr_abort(struct usbd_xfer *);
void		ehci_root_intr_close(struct usbd_pipe *);
void		ehci_root_intr_done(struct usbd_xfer *);

usbd_status	ehci_device_ctrl_transfer(struct usbd_xfer *);
usbd_status	ehci_device_ctrl_start(struct usbd_xfer *);
void		ehci_device_ctrl_abort(struct usbd_xfer *);
void		ehci_device_ctrl_close(struct usbd_pipe *);
void		ehci_device_ctrl_done(struct usbd_xfer *);

usbd_status	ehci_device_bulk_transfer(struct usbd_xfer *);
usbd_status	ehci_device_bulk_start(struct usbd_xfer *);
void		ehci_device_bulk_abort(struct usbd_xfer *);
void		ehci_device_bulk_close(struct usbd_pipe *);
void		ehci_device_bulk_done(struct usbd_xfer *);

usbd_status	ehci_device_intr_transfer(struct usbd_xfer *);
usbd_status	ehci_device_intr_start(struct usbd_xfer *);
void		ehci_device_intr_abort(struct usbd_xfer *);
void		ehci_device_intr_close(struct usbd_pipe *);
void		ehci_device_intr_done(struct usbd_xfer *);

usbd_status	ehci_device_isoc_transfer(struct usbd_xfer *);
usbd_status	ehci_device_isoc_start(struct usbd_xfer *);
void		ehci_device_isoc_abort(struct usbd_xfer *);
void		ehci_device_isoc_close(struct usbd_pipe *);
void		ehci_device_isoc_done(struct usbd_xfer *);

void		ehci_device_clear_toggle(struct usbd_pipe *pipe);

void		ehci_pcd(struct ehci_softc *, struct usbd_xfer *);
void		ehci_disown(struct ehci_softc *, int, int);

struct ehci_soft_qh *ehci_alloc_sqh(struct ehci_softc *);
void		ehci_free_sqh(struct ehci_softc *, struct ehci_soft_qh *);

struct ehci_soft_qtd *ehci_alloc_sqtd(struct ehci_softc *);
void		ehci_free_sqtd(struct ehci_softc *, struct ehci_soft_qtd *);
usbd_status	ehci_alloc_sqtd_chain(struct ehci_softc *, u_int,
		    struct usbd_xfer *, struct ehci_soft_qtd **, struct ehci_soft_qtd **);
void		ehci_free_sqtd_chain(struct ehci_softc *, struct ehci_xfer *);

struct ehci_soft_itd *ehci_alloc_itd(struct ehci_softc *);
void		ehci_free_itd(struct ehci_softc *, struct ehci_soft_itd *);
void		ehci_rem_itd_chain(struct ehci_softc *, struct ehci_xfer *);
void		ehci_free_itd_chain(struct ehci_softc *, struct ehci_xfer *);
int		ehci_alloc_itd_chain(struct ehci_softc *, struct usbd_xfer *);
int		ehci_alloc_sitd_chain(struct ehci_softc *, struct usbd_xfer *);
void		ehci_abort_isoc_xfer(struct usbd_xfer *xfer,
		    usbd_status status);

usbd_status	ehci_device_setintr(struct ehci_softc *, struct ehci_soft_qh *,
			    int ival);

void		ehci_add_qh(struct ehci_soft_qh *, struct ehci_soft_qh *);
void		ehci_rem_qh(struct ehci_softc *, struct ehci_soft_qh *);
void		ehci_set_qh_qtd(struct ehci_soft_qh *, struct ehci_soft_qtd *);
void		ehci_sync_hc(struct ehci_softc *);

void		ehci_close_pipe(struct usbd_pipe *);
void		ehci_abort_xfer(struct usbd_xfer *, usbd_status);

#ifdef EHCI_DEBUG
void		ehci_dump_regs(struct ehci_softc *);
void		ehci_dump(void);
struct ehci_softc *theehci;
void		ehci_dump_link(ehci_link_t, int);
void		ehci_dump_sqtds(struct ehci_soft_qtd *);
void		ehci_dump_sqtd(struct ehci_soft_qtd *);
void		ehci_dump_qtd(struct ehci_qtd *);
void		ehci_dump_sqh(struct ehci_soft_qh *);
#if notyet
void		ehci_dump_itd(struct ehci_soft_itd *);
#endif
#ifdef DIAGNOSTIC
void		ehci_dump_exfer(struct ehci_xfer *);
#endif
#endif

#define EHCI_INTR_ENDPT 1

struct usbd_bus_methods ehci_bus_methods = {
	.open_pipe = ehci_open,
	.dev_setaddr = ehci_setaddr,
	.soft_intr = ehci_softintr,
	.do_poll = ehci_poll,
	.allocx = ehci_allocx,
	.freex = ehci_freex,
};

struct usbd_pipe_methods ehci_root_ctrl_methods = {
	.transfer = ehci_root_ctrl_transfer,
	.start = ehci_root_ctrl_start,
	.abort = ehci_root_ctrl_abort,
	.close = ehci_root_ctrl_close,
	.done = ehci_root_ctrl_done,
};

struct usbd_pipe_methods ehci_root_intr_methods = {
	.transfer = ehci_root_intr_transfer,
	.start = ehci_root_intr_start,
	.abort = ehci_root_intr_abort,
	.close = ehci_root_intr_close,
	.done = ehci_root_intr_done,
};

struct usbd_pipe_methods ehci_device_ctrl_methods = {
	.transfer = ehci_device_ctrl_transfer,
	.start = ehci_device_ctrl_start,
	.abort = ehci_device_ctrl_abort,
	.close = ehci_device_ctrl_close,
	.done = ehci_device_ctrl_done,
};

struct usbd_pipe_methods ehci_device_intr_methods = {
	.transfer = ehci_device_intr_transfer,
	.start = ehci_device_intr_start,
	.abort = ehci_device_intr_abort,
	.close = ehci_device_intr_close,
	.cleartoggle = ehci_device_clear_toggle,
	.done = ehci_device_intr_done,
};

struct usbd_pipe_methods ehci_device_bulk_methods = {
	.transfer = ehci_device_bulk_transfer,
	.start = ehci_device_bulk_start,
	.abort = ehci_device_bulk_abort,
	.close = ehci_device_bulk_close,
	.cleartoggle = ehci_device_clear_toggle,
	.done = ehci_device_bulk_done,
};

struct usbd_pipe_methods ehci_device_isoc_methods = {
	.transfer = ehci_device_isoc_transfer,
	.start = ehci_device_isoc_start,
	.abort = ehci_device_isoc_abort,
	.close = ehci_device_isoc_close,
	.done = ehci_device_isoc_done,
};

/*
 * Reverse a number with nbits bits.  Used to evenly distribute lower-level
 * interrupt heads in the periodic schedule.
 * Suitable for use with EHCI_IPOLLRATES <= 9.
 */
u_int8_t
ehci_reverse_bits(u_int8_t c, int nbits)
{
	c = ((c >> 1) & 0x55) | ((c << 1) & 0xaa);
	c = ((c >> 2) & 0x33) | ((c << 2) & 0xcc);
	c = ((c >> 4) & 0x0f) | ((c << 4) & 0xf0);

	return c >> (8 - nbits);
}

usbd_status
ehci_init(struct ehci_softc *sc)
{
	u_int32_t sparams, cparams, hcr;
	u_int i, j;
	usbd_status err;
	struct ehci_soft_qh *sqh;

#ifdef EHCI_DEBUG
	u_int32_t vers;
	theehci = sc;

	DPRINTF(("ehci_init: start\n"));

	vers = EREAD2(sc, EHCI_HCIVERSION);
	DPRINTF(("%s: EHCI version %x.%x\n", sc->sc_bus.bdev.dv_xname,
	    vers >> 8, vers & 0xff));
#endif

	sc->sc_offs = EREAD1(sc, EHCI_CAPLENGTH);

	sparams = EREAD4(sc, EHCI_HCSPARAMS);
	DPRINTF(("ehci_init: sparams=0x%x\n", sparams));
	sc->sc_noport = EHCI_HCS_N_PORTS(sparams);
	cparams = EREAD4(sc, EHCI_HCCPARAMS);
	DPRINTF(("ehci_init: cparams=0x%x\n", cparams));

	/* MUST clear segment register if 64 bit capable. */
	if (EHCI_HCC_64BIT(cparams))
		EWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);

	sc->sc_bus.usbrev = USBREV_2_0;

	DPRINTF(("%s: resetting\n", sc->sc_bus.bdev.dv_xname));
	err = ehci_reset(sc);
	if (err)
		return (err);

	if (ehcixfer == NULL) {
		ehcixfer = malloc(sizeof(struct pool), M_DEVBUF, M_NOWAIT);
		if (ehcixfer == NULL) {
			printf("%s: unable to allocate pool descriptor\n",
			    sc->sc_bus.bdev.dv_xname);
			return (ENOMEM);
		}
		pool_init(ehcixfer, sizeof(struct ehci_xfer), 0, IPL_SOFTUSB,
		    0, "ehcixfer", NULL);
	}

	/* frame list size at default, read back what we got and use that */
	switch (EHCI_CMD_FLS(EOREAD4(sc, EHCI_USBCMD))) {
	case 0:
		sc->sc_flsize = 1024;
		break;
	case 1:
		sc->sc_flsize = 512;
		break;
	case 2:
		sc->sc_flsize = 256;
		break;
	case 3:
		return (USBD_IOERROR);
	}
	err = usb_allocmem(&sc->sc_bus, sc->sc_flsize * sizeof(ehci_link_t),
	    EHCI_FLALIGN_ALIGN, &sc->sc_fldma);
	if (err)
		return (err);
	DPRINTF(("%s: flsize=%d\n", sc->sc_bus.bdev.dv_xname,sc->sc_flsize));
	sc->sc_flist = KERNADDR(&sc->sc_fldma, 0);

	for (i = 0; i < sc->sc_flsize; i++)
		sc->sc_flist[i] = htole32(EHCI_LINK_TERMINATE);

	EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));

	sc->sc_softitds = mallocarray(sc->sc_flsize,
	    sizeof(struct ehci_soft_itd *), M_USB, M_NOWAIT | M_ZERO);
	if (sc->sc_softitds == NULL) {
		usb_freemem(&sc->sc_bus, &sc->sc_fldma);
		return (ENOMEM);
	}
	LIST_INIT(&sc->sc_freeitds);
	TAILQ_INIT(&sc->sc_intrhead);

	/* Set up the bus struct. */
	sc->sc_bus.methods = &ehci_bus_methods;
	sc->sc_bus.pipe_size = sizeof(struct ehci_pipe);

	sc->sc_eintrs = EHCI_NORMAL_INTRS;

	/*
	 * Allocate the interrupt dummy QHs. These are arranged to give poll
	 * intervals that are powers of 2 times 1ms.
	 */
	for (i = 0; i < EHCI_INTRQHS; i++) {
		sqh = ehci_alloc_sqh(sc);
		if (sqh == NULL) {
			err = USBD_NOMEM;
			goto bad1;
		}
		sc->sc_islots[i].sqh = sqh;
	}
	for (i = 0; i < EHCI_INTRQHS; i++) {
		sqh = sc->sc_islots[i].sqh;
		if (i == 0) {
			/* The last (1ms) QH terminates. */
			sqh->qh.qh_link = htole32(EHCI_LINK_TERMINATE);
			sqh->next = NULL;
		} else {
			/* Otherwise the next QH has half the poll interval */
			sqh->next = sc->sc_islots[(i + 1) / 2 - 1].sqh;
			sqh->qh.qh_link = htole32(sqh->next->physaddr |
			    EHCI_LINK_QH);
		}
		sqh->qh.qh_endp = htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH));
		sqh->qh.qh_endphub = htole32(EHCI_QH_SET_MULT(1));
		sqh->qh.qh_curqtd = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
		sqh->sqtd = NULL;
		usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	/* Point the frame list at the last level (128ms). */
	for (i = 0; i < (1 << (EHCI_IPOLLRATES - 1)); i++)
		for (j = i; j < sc->sc_flsize; j += 1 << (EHCI_IPOLLRATES - 1))
			sc->sc_flist[j] = htole32(EHCI_LINK_QH | sc->sc_islots[
			    EHCI_IQHIDX(EHCI_IPOLLRATES - 1, ehci_reverse_bits(
			    i, EHCI_IPOLLRATES - 1))].sqh->physaddr);
	usb_syncmem(&sc->sc_fldma, 0, sc->sc_flsize * sizeof(ehci_link_t),
	    BUS_DMASYNC_PREWRITE);

	/* Allocate dummy QH that starts the async list. */
	sqh = ehci_alloc_sqh(sc);
	if (sqh == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	/* Fill the QH */
	sqh->qh.qh_endp =
	    htole32(EHCI_QH_SET_EPS(EHCI_QH_SPEED_HIGH) | EHCI_QH_HRECL);
	sqh->qh.qh_link =
	    htole32(sqh->physaddr | EHCI_LINK_QH);
	sqh->qh.qh_curqtd = htole32(EHCI_LINK_TERMINATE);
	sqh->prev = sqh; /*It's a circular list.. */
	sqh->next = sqh;
	/* Fill the overlay qTD */
	sqh->qh.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
	sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
	sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
	sqh->sqtd = NULL;
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	/* Point to async list */
	sc->sc_async_head = sqh;
	EOWRITE4(sc, EHCI_ASYNCLISTADDR, sqh->physaddr | EHCI_LINK_QH);

	timeout_set(&sc->sc_tmo_intrlist, ehci_intrlist_timeout, sc);

	rw_init(&sc->sc_doorbell_lock, "ehcidb");

	/* Turn on controller */
	EOWRITE4(sc, EHCI_USBCMD,
	    EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
	    (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
	    EHCI_CMD_ASE |
	    EHCI_CMD_PSE |
	    EHCI_CMD_RS);

	/* Take over port ownership */
	EOWRITE4(sc, EHCI_CONFIGFLAG, EHCI_CONF_CF);

	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
		if (!hcr)
			break;
	}
	if (hcr) {
		printf("%s: run timeout\n", sc->sc_bus.bdev.dv_xname);
		return (USBD_IOERROR);
	}

	/* Enable interrupts */
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

	return (USBD_NORMAL_COMPLETION);

#if 0
 bad2:
	ehci_free_sqh(sc, sc->sc_async_head);
#endif
 bad1:
	free(sc->sc_softitds, M_USB, 0);
	usb_freemem(&sc->sc_bus, &sc->sc_fldma);
	return (err);
}

int
ehci_intr(void *v)
{
	struct ehci_softc *sc = v;

	if (sc == NULL || sc->sc_bus.dying)
		return (0);

	/* If we get an interrupt while polling, then just ignore it. */
	if (sc->sc_bus.use_polling) {
		u_int32_t intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));

		if (intrs)
			EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
		return (0);
	}

	return (ehci_intr1(sc));
}

int
ehci_intr1(struct ehci_softc *sc)
{
	u_int32_t intrs, eintrs;

	/* In case the interrupt occurs before initialization has completed. */
	if (sc == NULL) {
#ifdef DIAGNOSTIC
		printf("ehci_intr1: sc == NULL\n");
#endif
		return (0);
	}

	intrs = EOREAD4(sc, EHCI_USBSTS);
	if (intrs == 0xffffffff) {
		sc->sc_bus.dying = 1;
		return (0);
	}
	intrs = EHCI_STS_INTRS(intrs);
	if (!intrs)
		return (0);

	eintrs = intrs & sc->sc_eintrs;
	if (!eintrs)
		return (0);

	EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
	sc->sc_bus.no_intrs++;

	if (eintrs & EHCI_STS_HSE) {
		printf("%s: unrecoverable error, controller halted\n",
		       sc->sc_bus.bdev.dv_xname);
		sc->sc_bus.dying = 1;
		return (1);
	}
	if (eintrs & EHCI_STS_IAA) {
		wakeup(&sc->sc_async_head);
		eintrs &= ~EHCI_STS_IAA;
	}
	if (eintrs & (EHCI_STS_INT | EHCI_STS_ERRINT)) {
		usb_schedsoftintr(&sc->sc_bus);
		eintrs &= ~(EHCI_STS_INT | EHCI_STS_ERRINT);
	}
	if (eintrs & EHCI_STS_PCD) {
		atomic_setbits_int(&sc->sc_flags, EHCIF_PCB_INTR);
		usb_schedsoftintr(&sc->sc_bus);
		eintrs &= ~EHCI_STS_PCD;
	}

	if (eintrs != 0) {
		/* Block unprocessed interrupts. */
		sc->sc_eintrs &= ~eintrs;
		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
		printf("%s: blocking intrs 0x%x\n",
		       sc->sc_bus.bdev.dv_xname, eintrs);
	}

	return (1);
}

void
ehci_pcd(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	u_char *p;
	int i, m;

	if (xfer == NULL) {
		/* Just ignore the change. */
		return;
	}

	p = KERNADDR(&xfer->dmabuf, 0);
	m = min(sc->sc_noport, xfer->length * 8 - 1);
	memset(p, 0, xfer->length);
	for (i = 1; i <= m; i++) {
		/* Pick out CHANGE bits from the status reg. */
		if (EOREAD4(sc, EHCI_PORTSC(i)) & EHCI_PS_CLEAR)
			p[i / 8] |= 1 << (i % 8);
	}
	xfer->actlen = xfer->length;
	xfer->status = USBD_NORMAL_COMPLETION;

	usb_transfer_complete(xfer);
}

/*
 * Work around the half configured control (default) pipe when setting
 * the address of a device.
 *
 * Because a single QH is setup per endpoint in ehci_open(), and the
 * control pipe is configured before we could have set the address
 * of the device or read the wMaxPacketSize of the endpoint, we have
 * to re-open the pipe twice here.
 */
int
ehci_setaddr(struct usbd_device *dev, int addr)
{
	/* Root Hub */
	if (dev->depth == 0)
		return (0);

	/* Re-establish the default pipe with the new max packet size. */
	ehci_close_pipe(dev->default_pipe);
	if (ehci_open(dev->default_pipe))
		return (EINVAL);

	if (usbd_set_address(dev, addr))
		return (1);

	dev->address = addr;

	/* Re-establish the default pipe with the new address. */
	ehci_close_pipe(dev->default_pipe);
	if (ehci_open(dev->default_pipe))
		return (EINVAL);

	return (0);
}

void
ehci_softintr(void *v)
{
	struct ehci_softc *sc = v;
	struct ehci_xfer *ex, *nextex;

	if (sc->sc_bus.dying)
		return;

	sc->sc_bus.intr_context++;

	if (sc->sc_flags & EHCIF_PCB_INTR) {
		atomic_clearbits_int(&sc->sc_flags, EHCIF_PCB_INTR);
		ehci_pcd(sc, sc->sc_intrxfer);
	}

	/*
	 * The only explanation I can think of for why EHCI is as brain dead
	 * as UHCI interrupt-wise is that Intel was involved in both.
	 * An interrupt just tells us that something is done, we have no
	 * clue what, so we need to scan through all active transfers. :-(
	 */
	for (ex = TAILQ_FIRST(&sc->sc_intrhead); ex; ex = nextex) {
		nextex = TAILQ_NEXT(ex, inext);
		ehci_check_intr(sc, &ex->xfer);
	}

	/* Schedule a callout to catch any dropped transactions. */
	if ((sc->sc_flags & EHCIF_DROPPED_INTR_WORKAROUND) &&
	    !TAILQ_EMPTY(&sc->sc_intrhead)) {
		timeout_add_sec(&sc->sc_tmo_intrlist, 1);
	}

	if (sc->sc_softwake) {
		sc->sc_softwake = 0;
		wakeup(&sc->sc_softwake);
	}

	sc->sc_bus.intr_context--;
}

void
ehci_check_intr(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	int attr = xfer->pipe->endpoint->edesc->bmAttributes;

	if (UE_GET_XFERTYPE(attr) == UE_ISOCHRONOUS)
		ehci_check_itd_intr(sc, xfer);
	else
		ehci_check_qh_intr(sc, xfer);
}

void
ehci_check_qh_intr(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_qtd *sqtd, *lsqtd = ex->sqtdend;
	uint32_t status;

	KASSERT(ex->sqtdstart != NULL && ex->sqtdend != NULL);

	usb_syncmem(&lsqtd->dma,
	    lsqtd->offs + offsetof(struct ehci_qtd, qtd_status),
	    sizeof(lsqtd->qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

	/*
	 * If the last TD is still active we need to check whether there
	 * is a an error somewhere in the middle, or whether there was a
	 * short packet (SPD and not ACTIVE).
	 */
	if (letoh32(lsqtd->qtd.qtd_status) & EHCI_QTD_ACTIVE) {
		DPRINTFN(12, ("ehci_check_intr: active ex=%p\n", ex));
		for (sqtd = ex->sqtdstart; sqtd != lsqtd; sqtd=sqtd->nextqtd) {
			usb_syncmem(&sqtd->dma,
			    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
			    sizeof(sqtd->qtd.qtd_status),
			    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
			status = letoh32(sqtd->qtd.qtd_status);
			usb_syncmem(&sqtd->dma,
			    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
			    sizeof(sqtd->qtd.qtd_status), BUS_DMASYNC_PREREAD);
			/* If there's an active QTD the xfer isn't done. */
			if (status & EHCI_QTD_ACTIVE)
				break;
			/* Any kind of error makes the xfer done. */
			if (status & EHCI_QTD_HALTED)
				goto done;
			/* We want short packets, and it is short: it's done */
			if (EHCI_QTD_GET_BYTES(status) != 0)
				goto done;
		}
		DPRINTFN(12, ("ehci_check_intr: ex=%p std=%p still active\n",
			      ex, ex->sqtdstart));
		usb_syncmem(&lsqtd->dma,
		    lsqtd->offs + offsetof(struct ehci_qtd, qtd_status),
		    sizeof(lsqtd->qtd.qtd_status), BUS_DMASYNC_PREREAD);
		return;
	}
 done:
	TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->pipe->device, &xfer->abort_task);
	ehci_idone(xfer);
}

void
ehci_check_itd_intr(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_itd *itd = ex->itdend;
	int i;

	if (xfer != SIMPLEQ_FIRST(&xfer->pipe->queue))
		return;

	KASSERT(ex->itdstart != NULL && ex->itdend != NULL);

	/* Check no active transfers in last itd, meaning we're finished */
	if (xfer->device->speed == USB_SPEED_HIGH) {
		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(struct ehci_itd, itd_ctl),
		    sizeof(itd->itd.itd_ctl),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

		for (i = 0; i < 8; i++) {
			if (letoh32(itd->itd.itd_ctl[i]) & EHCI_ITD_ACTIVE)
				return;
		}
	} else {
		usb_syncmem(&itd->dma,
		    itd->offs + offsetof(struct ehci_sitd, sitd_trans),
		    sizeof(itd->sitd.sitd_trans),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

		if (le32toh(itd->sitd.sitd_trans) & EHCI_SITD_ACTIVE)
			return;
	}

	/* All descriptor(s) inactive, it's done */
	TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->pipe->device, &xfer->abort_task);
	ehci_isoc_idone(xfer);
}

void
ehci_isoc_idone(struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_itd *itd;
	int i, len, uframes, nframes = 0, actlen = 0;
	uint32_t status = 0;

	if (xfer->status == USBD_CANCELLED || xfer->status == USBD_TIMEOUT)
		return;

	if (xfer->device->speed == USB_SPEED_HIGH) {
		switch (xfer->pipe->endpoint->edesc->bInterval) {
		case 0:
			panic("isoc xfer suddenly has 0 bInterval, invalid");
		case 1:
			uframes = 1;
			break;
		case 2:
			uframes = 2;
			break;
		case 3:
			uframes = 4;
			break;
		default:
			uframes = 8;
			break;
		}

		for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_itd, itd_ctl),
			    sizeof(itd->itd.itd_ctl), BUS_DMASYNC_POSTWRITE |
			    BUS_DMASYNC_POSTREAD);

			for (i = 0; i < 8; i += uframes) {
				/* XXX - driver didn't fill in the frame full
				 *   of uframes. This leads to scheduling
				 *   inefficiencies, but working around
				 *   this doubles complexity of tracking
				 *   an xfer.
				 */
				if (nframes >= xfer->nframes)
					break;

				status = letoh32(itd->itd.itd_ctl[i]);
				len = EHCI_ITD_GET_LEN(status);
				if (EHCI_ITD_GET_STATUS(status) != 0)
					len = 0; /*No valid data on error*/

				xfer->frlengths[nframes++] = len;
				actlen += len;
			}
		}
	} else {
		for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_sitd, sitd_trans),
			    sizeof(itd->sitd.sitd_trans),
			    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

			status = le32toh(itd->sitd.sitd_trans);
			len = EHCI_SITD_GET_LEN(status);
			if (xfer->frlengths[nframes] >= len)
				len = xfer->frlengths[nframes] - len;
			else
				len = 0;

			xfer->frlengths[nframes++] = len;
			actlen += len;
	    	}
	}

#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
	xfer->actlen = actlen;
	xfer->status = USBD_NORMAL_COMPLETION;
	usb_transfer_complete(xfer);
}

void
ehci_idone(struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_qtd *sqtd;
	u_int32_t status = 0, nstatus = 0;
	int actlen, cerr;

#ifdef DIAGNOSTIC
	{
		int s = splhigh();
		if (ex->isdone) {
			splx(s);
			printf("ehci_idone: ex=%p is done!\n", ex);
			return;
		}
		ex->isdone = 1;
		splx(s);
	}
#endif
	if (xfer->status == USBD_CANCELLED || xfer->status == USBD_TIMEOUT)
		return;

	actlen = 0;
	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
		usb_syncmem(&sqtd->dma, sqtd->offs, sizeof(sqtd->qtd),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		nstatus = letoh32(sqtd->qtd.qtd_status);
		if (nstatus & EHCI_QTD_ACTIVE)
			break;

		status = nstatus;
		/* halt is ok if descriptor is last, and complete */
		if (sqtd->qtd.qtd_next == htole32(EHCI_LINK_TERMINATE) &&
		    EHCI_QTD_GET_BYTES(status) == 0)
			status &= ~EHCI_QTD_HALTED;
		if (EHCI_QTD_GET_PID(status) !=	EHCI_QTD_PID_SETUP)
			actlen += sqtd->len - EHCI_QTD_GET_BYTES(status);
	}

	cerr = EHCI_QTD_GET_CERR(status);
	DPRINTFN(/*10*/2, ("ehci_idone: len=%d, actlen=%d, cerr=%d, "
	    "status=0x%x\n", xfer->length, actlen, cerr, status));
	xfer->actlen = actlen;
	if ((status & EHCI_QTD_HALTED) != 0) {
		if ((status & EHCI_QTD_BABBLE) == 0 && cerr > 0)
			xfer->status = USBD_STALLED;
		else
			xfer->status = USBD_IOERROR; /* more info XXX */
	} else
		xfer->status = USBD_NORMAL_COMPLETION;

	/* XXX transfer_complete memcpys out transfer data (for in endpoints)
	 * during this call, before methods->done is called: dma sync required
	 * beforehand? */
	usb_transfer_complete(xfer);
	DPRINTFN(/*12*/2, ("ehci_idone: ex=%p done\n", ex));
}

void
ehci_poll(struct usbd_bus *bus)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;

	if (EOREAD4(sc, EHCI_USBSTS) & sc->sc_eintrs)
		ehci_intr1(sc);
}

int
ehci_detach(struct device *self, int flags)
{
	struct ehci_softc *sc = (struct ehci_softc *)self;
	int rv;

	rv = config_detach_children(self, flags);
	if (rv != 0)
		return (rv);

	timeout_del(&sc->sc_tmo_intrlist);

	ehci_reset(sc);

	usb_delay_ms(&sc->sc_bus, 300); /* XXX let stray task complete */

	free(sc->sc_softitds, M_USB, 0);
	usb_freemem(&sc->sc_bus, &sc->sc_fldma);
	/* XXX free other data structures XXX */

	return (rv);
}


int
ehci_activate(struct device *self, int act)
{
	struct ehci_softc *sc = (struct ehci_softc *)self;
	u_int32_t cmd, hcr, cparams;
	int i, rv = 0;

	switch (act) {
	case DVACT_SUSPEND:
		rv = config_activate_children(self, act);

#ifdef DIAGNOSTIC
		if (!TAILQ_EMPTY(&sc->sc_intrhead)) {
			printf("%s: interrupt list not empty\n",
			    sc->sc_bus.bdev.dv_xname);
			return (-1);
		}
#endif

		sc->sc_bus.use_polling++;

		for (i = 1; i <= sc->sc_noport; i++) {
			cmd = EOREAD4(sc, EHCI_PORTSC(i));
			if ((cmd & (EHCI_PS_PO|EHCI_PS_PE)) == EHCI_PS_PE)
				EOWRITE4(sc, EHCI_PORTSC(i),
				    cmd | EHCI_PS_SUSP);
		}

		/*
		 * First tell the host to stop processing Asynchronous
		 * and Periodic schedules.
		 */
		cmd = EOREAD4(sc, EHCI_USBCMD) & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
		EOWRITE4(sc, EHCI_USBCMD, cmd);
		for (i = 0; i < 100; i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			hcr = EOREAD4(sc, EHCI_USBSTS) &
			    (EHCI_STS_ASS | EHCI_STS_PSS);
			if (hcr == 0)
				break;
		}
		if (hcr != 0)
			printf("%s: disable schedules timeout\n",
			    sc->sc_bus.bdev.dv_xname);

		/*
		 * Then reset the host as if it was a shutdown.
		 *
		 * All USB devices are disconnected/reconnected during
		 * a suspend/resume cycle so keep it simple.
		 */
		ehci_reset(sc);

		sc->sc_bus.use_polling--;
		break;
	case DVACT_RESUME:
		sc->sc_bus.use_polling++;

		ehci_reset(sc);

		cparams = EREAD4(sc, EHCI_HCCPARAMS);
		/* MUST clear segment register if 64 bit capable. */
		if (EHCI_HCC_64BIT(cparams))
			EWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);

		EOWRITE4(sc, EHCI_PERIODICLISTBASE, DMAADDR(&sc->sc_fldma, 0));
		EOWRITE4(sc, EHCI_ASYNCLISTADDR,
	  	    sc->sc_async_head->physaddr | EHCI_LINK_QH);

		hcr = 0;
		for (i = 1; i <= sc->sc_noport; i++) {
			cmd = EOREAD4(sc, EHCI_PORTSC(i));
			if ((cmd & (EHCI_PS_PO|EHCI_PS_SUSP)) == EHCI_PS_SUSP) {
				EOWRITE4(sc, EHCI_PORTSC(i), cmd | EHCI_PS_FPR);
				hcr = 1;
			}
		}

		if (hcr) {
			usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
			for (i = 1; i <= sc->sc_noport; i++) {
				cmd = EOREAD4(sc, EHCI_PORTSC(i));
				if ((cmd & (EHCI_PS_PO|EHCI_PS_SUSP)) ==
				   EHCI_PS_SUSP)
					EOWRITE4(sc, EHCI_PORTSC(i),
					   cmd & ~EHCI_PS_FPR);
			}
		}

		/* Turn on controller */
		EOWRITE4(sc, EHCI_USBCMD,
		    EHCI_CMD_ITC_2 | /* 2 microframes interrupt delay */
		    (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
		    EHCI_CMD_ASE |
		    EHCI_CMD_PSE |
		    EHCI_CMD_RS);

		/* Take over port ownership */
		EOWRITE4(sc, EHCI_CONFIGFLAG, EHCI_CONF_CF);
		for (i = 0; i < 100; i++) {
			usb_delay_ms(&sc->sc_bus, 1);
			hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
			if (!hcr)
				break;
		}

		if (hcr) {
			printf("%s: run timeout\n", sc->sc_bus.bdev.dv_xname);
			/* XXX should we bail here? */
		}

		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);

		sc->sc_bus.use_polling--;
		rv = config_activate_children(self, act);
		break;
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		ehci_reset(sc);
		break;
	default:
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

usbd_status
ehci_reset(struct ehci_softc *sc)
{
	u_int32_t hcr, usbmode;
	int i;

	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
		if (hcr)
			break;
	}

	if (!hcr)
		printf("%s: halt timeout\n", sc->sc_bus.bdev.dv_xname);

	if (sc->sc_flags & EHCIF_USBMODE)
		usbmode = EOREAD4(sc, EHCI_USBMODE);

	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_HCRESET;
		if (!hcr)
			break;
	}

	if (hcr) {
		printf("%s: reset timeout\n", sc->sc_bus.bdev.dv_xname);
		return (USBD_IOERROR);
	}

	if (sc->sc_flags & EHCIF_USBMODE)
		EOWRITE4(sc, EHCI_USBMODE, usbmode);

	return (USBD_NORMAL_COMPLETION);
}

struct usbd_xfer *
ehci_allocx(struct usbd_bus *bus)
{
	struct ehci_xfer *ex;

	ex = pool_get(ehcixfer, PR_NOWAIT | PR_ZERO);
#ifdef DIAGNOSTIC
	if (ex != NULL)
		ex->isdone = 1;
#endif
	return ((struct usbd_xfer *)ex);
}

void
ehci_freex(struct usbd_bus *bus, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer*)xfer;

#ifdef DIAGNOSTIC
	if (!ex->isdone) {
		printf("%s: !isdone\n", __func__);
		return;
	}
#endif
	pool_put(ehcixfer, ex);
}

void
ehci_device_clear_toggle(struct usbd_pipe *pipe)
{
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;

#ifdef DIAGNOSTIC
	if ((epipe->sqh->qh.qh_qtd.qtd_status & htole32(EHCI_QTD_ACTIVE)) != 0)
		panic("ehci_device_clear_toggle: queue active");
#endif
	epipe->sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE_MASK);
}

#ifdef EHCI_DEBUG
void
ehci_dump_regs(struct ehci_softc *sc)
{
	int i;

	printf("cmd=0x%08x, sts=0x%08x, ien=0x%08x\n",
	    EOREAD4(sc, EHCI_USBCMD),
	    EOREAD4(sc, EHCI_USBSTS),
	    EOREAD4(sc, EHCI_USBINTR));
	printf("frindex=0x%08x ctrdsegm=0x%08x periodic=0x%08x async=0x%08x\n",
	    EOREAD4(sc, EHCI_FRINDEX),
	    EOREAD4(sc, EHCI_CTRLDSSEGMENT),
	    EOREAD4(sc, EHCI_PERIODICLISTBASE),
	    EOREAD4(sc, EHCI_ASYNCLISTADDR));
	for (i = 1; i <= sc->sc_noport; i++)
		printf("port %d status=0x%08x\n", i,
		    EOREAD4(sc, EHCI_PORTSC(i)));
}

/*
 * Unused function - this is meant to be called from a kernel
 * debugger.
 */
void
ehci_dump(void)
{
	ehci_dump_regs(theehci);
}

void
ehci_dump_link(ehci_link_t link, int type)
{
	link = letoh32(link);
	printf("0x%08x", link);
	if (link & EHCI_LINK_TERMINATE)
		printf("<T>");
	else {
		printf("<");
		if (type) {
			switch (EHCI_LINK_TYPE(link)) {
			case EHCI_LINK_ITD:
				printf("ITD");
				break;
			case EHCI_LINK_QH:
				printf("QH");
				break;
			case EHCI_LINK_SITD:
				printf("SITD");
				break;
			case EHCI_LINK_FSTN:
				printf("FSTN");
				break;
			}
		}
		printf(">");
	}
}

void
ehci_dump_sqtds(struct ehci_soft_qtd *sqtd)
{
	int i;
	u_int32_t stop;

	stop = 0;
	for (i = 0; sqtd && i < 20 && !stop; sqtd = sqtd->nextqtd, i++) {
		ehci_dump_sqtd(sqtd);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_next),
		    sizeof(sqtd->qtd),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		stop = sqtd->qtd.qtd_next & htole32(EHCI_LINK_TERMINATE);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_next),
		    sizeof(sqtd->qtd), BUS_DMASYNC_PREREAD);
	}
	if (!stop)
		printf("dump aborted, too many TDs\n");
}

void
ehci_dump_sqtd(struct ehci_soft_qtd *sqtd)
{
	usb_syncmem(&sqtd->dma, sqtd->offs, 
	    sizeof(sqtd->qtd), BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	printf("QTD(%p) at 0x%08x:\n", sqtd, sqtd->physaddr);
	ehci_dump_qtd(&sqtd->qtd);
	usb_syncmem(&sqtd->dma, sqtd->offs, 
	    sizeof(sqtd->qtd), BUS_DMASYNC_PREREAD);
}

void
ehci_dump_qtd(struct ehci_qtd *qtd)
{
	u_int32_t s;
	char sbuf[128];

	printf("  next="); ehci_dump_link(qtd->qtd_next, 0);
	printf(" altnext="); ehci_dump_link(qtd->qtd_altnext, 0);
	printf("\n");
	s = letoh32(qtd->qtd_status);
	bitmask_snprintf(EHCI_QTD_GET_STATUS(s), "\20\10ACTIVE\7HALTED"
	    "\6BUFERR\5BABBLE\4XACTERR\3MISSED\2SPLIT\1PING",
	    sbuf, sizeof(sbuf));
	printf("  status=0x%08x: toggle=%d bytes=0x%x ioc=%d c_page=0x%x\n",
	    s, EHCI_QTD_GET_TOGGLE(s), EHCI_QTD_GET_BYTES(s),
	    EHCI_QTD_GET_IOC(s), EHCI_QTD_GET_C_PAGE(s));
	printf("    cerr=%d pid=%d stat=0x%s\n", EHCI_QTD_GET_CERR(s),
	    EHCI_QTD_GET_PID(s), sbuf);
	for (s = 0; s < 5; s++)
		printf("  buffer[%d]=0x%08x\n", s, letoh32(qtd->qtd_buffer[s]));
}

void
ehci_dump_sqh(struct ehci_soft_qh *sqh)
{
	struct ehci_qh *qh = &sqh->qh;
	u_int32_t endp, endphub;

	usb_syncmem(&sqh->dma, sqh->offs,
	    sizeof(sqh->qh), BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	printf("QH(%p) at 0x%08x:\n", sqh, sqh->physaddr);
	printf("  link="); ehci_dump_link(qh->qh_link, 1); printf("\n");
	endp = letoh32(qh->qh_endp);
	printf("  endp=0x%08x\n", endp);
	printf("    addr=0x%02x inact=%d endpt=%d eps=%d dtc=%d hrecl=%d\n",
	    EHCI_QH_GET_ADDR(endp), EHCI_QH_GET_INACT(endp),
	    EHCI_QH_GET_ENDPT(endp),  EHCI_QH_GET_EPS(endp),
	    EHCI_QH_GET_DTC(endp), EHCI_QH_GET_HRECL(endp));
	printf("    mpl=0x%x ctl=%d nrl=%d\n",
	    EHCI_QH_GET_MPL(endp), EHCI_QH_GET_CTL(endp),
	    EHCI_QH_GET_NRL(endp));
	endphub = letoh32(qh->qh_endphub);
	printf("  endphub=0x%08x\n", endphub);
	printf("    smask=0x%02x cmask=0x%02x huba=0x%02x port=%d mult=%d\n",
	    EHCI_QH_GET_SMASK(endphub), EHCI_QH_GET_CMASK(endphub),
	    EHCI_QH_GET_HUBA(endphub), EHCI_QH_GET_PORT(endphub),
	    EHCI_QH_GET_MULT(endphub));
	printf("  curqtd="); ehci_dump_link(qh->qh_curqtd, 0); printf("\n");
	printf("Overlay qTD:\n");
	ehci_dump_qtd(&qh->qh_qtd);
	usb_syncmem(&sqh->dma, sqh->offs,
	    sizeof(sqh->qh), BUS_DMASYNC_PREREAD);
}

#if notyet
void
ehci_dump_itd(struct ehci_soft_itd *itd)
{
	ehci_isoc_trans_t t;
	ehci_isoc_bufr_ptr_t b, b2, b3;
	int i;

	printf("ITD: next phys=%X\n", itd->itd.itd_next);

	for (i = 0; i < 8; i++) {
		t = letoh32(itd->itd.itd_ctl[i]);
		printf("ITDctl %d: stat=%X len=%X ioc=%X pg=%X offs=%X\n", i,
		    EHCI_ITD_GET_STATUS(t), EHCI_ITD_GET_LEN(t),
		    EHCI_ITD_GET_IOC(t), EHCI_ITD_GET_PG(t),
		    EHCI_ITD_GET_OFFS(t));
	}
	printf("ITDbufr: ");
	for (i = 0; i < 7; i++)
		printf("%X,", EHCI_ITD_GET_BPTR(letoh32(itd->itd.itd_bufr[i])));

	b = letoh32(itd->itd.itd_bufr[0]);
	b2 = letoh32(itd->itd.itd_bufr[1]);
	b3 = letoh32(itd->itd.itd_bufr[2]);
	printf("\nep=%X daddr=%X dir=%d maxpkt=%X multi=%X\n",
	    EHCI_ITD_GET_EP(b), EHCI_ITD_GET_DADDR(b), EHCI_ITD_GET_DIR(b2),
	    EHCI_ITD_GET_MAXPKT(b2), EHCI_ITD_GET_MULTI(b3));
}
#endif

#ifdef DIAGNOSTIC
void
ehci_dump_exfer(struct ehci_xfer *ex)
{
	printf("ehci_dump_exfer: ex=%p sqtdstart=%p end=%p itdstart=%p end=%p "
	    "isdone=%d\n", ex, ex->sqtdstart, ex->sqtdend, ex->itdstart,
	    ex->itdend, ex->isdone);
}
#endif

#endif /* EHCI_DEBUG */

usbd_status
ehci_open(struct usbd_pipe *pipe)
{
	struct usbd_device *dev = pipe->device;
	struct ehci_softc *sc = (struct ehci_softc *)dev->bus;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	struct ehci_soft_qh *sqh;
	usbd_status err;
	int s;
	int ival, speed, naks;
	int hshubaddr, hshubport;

	DPRINTFN(1, ("ehci_open: pipe=%p, addr=%d, endpt=%d\n",
	    pipe, addr, ed->bEndpointAddress));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	if (dev->myhsport) {
		hshubaddr = dev->myhsport->parent->address;
		hshubport = dev->myhsport->portno;
	} else {
		hshubaddr = 0;
		hshubport = 0;
	}

	/* Root Hub */
	if (pipe->device->depth == 0) {
		switch (ed->bEndpointAddress) {
		case USB_CONTROL_ENDPOINT:
			pipe->methods = &ehci_root_ctrl_methods;
			break;
		case UE_DIR_IN | EHCI_INTR_ENDPT:
			pipe->methods = &ehci_root_intr_methods;
			break;
		default:
			return (USBD_INVAL);
		}
		return (USBD_NORMAL_COMPLETION);
	}

	/* XXX All this stuff is only valid for async. */
	switch (dev->speed) {
	case USB_SPEED_LOW:
		speed = EHCI_QH_SPEED_LOW;
		break;
	case USB_SPEED_FULL:
		speed = EHCI_QH_SPEED_FULL;
		break;
	case USB_SPEED_HIGH:
		speed = EHCI_QH_SPEED_HIGH;
		break;
	default:
		panic("ehci_open: bad device speed %d", dev->speed);
	}

	naks = 8;		/* XXX */

	/* Allocate sqh for everything, save isoc xfers */
	if (xfertype != UE_ISOCHRONOUS) {
		sqh = ehci_alloc_sqh(sc);
		if (sqh == NULL)
			return (USBD_NOMEM);
		/* qh_link filled when the QH is added */
		sqh->qh.qh_endp = htole32(
		    EHCI_QH_SET_ADDR(addr) |
		    EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
		    EHCI_QH_SET_EPS(speed) |
		    (xfertype == UE_CONTROL ? EHCI_QH_DTC : 0) |
		    EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
		    (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
		    EHCI_QH_CTL : 0) |
		    EHCI_QH_SET_NRL(naks)
		);
		sqh->qh.qh_endphub = htole32(
		    EHCI_QH_SET_MULT(1) |
		    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0)
		);
		if (speed != EHCI_QH_SPEED_HIGH) {
			sqh->qh.qh_endphub |= htole32(
			    EHCI_QH_SET_HUBA(hshubaddr) |
			    EHCI_QH_SET_PORT(hshubport) |
			    EHCI_QH_SET_CMASK(0x1c) /* XXX */
			);
		}
		sqh->qh.qh_curqtd = htole32(EHCI_LINK_TERMINATE);
		/* Fill the overlay qTD */
		sqh->qh.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_status =
		    htole32(EHCI_QTD_SET_TOGGLE(pipe->endpoint->savedtoggle));

		usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		epipe->sqh = sqh;
	} /*xfertype == UE_ISOC*/

	switch (xfertype) {
	case UE_CONTROL:
		err = usb_allocmem(&sc->sc_bus, sizeof(usb_device_request_t),
		    0, &epipe->u.ctl.reqdma);
		if (err) {
			ehci_free_sqh(sc, sqh);
			return (err);
		}
		pipe->methods = &ehci_device_ctrl_methods;
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
		break;
	case UE_BULK:
		pipe->methods = &ehci_device_bulk_methods;
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
		break;
	case UE_INTERRUPT:
		pipe->methods = &ehci_device_intr_methods;
		ival = pipe->interval;
		if (ival == USBD_DEFAULT_INTERVAL)
			ival = ed->bInterval;
		s = splusb();
		err = ehci_device_setintr(sc, sqh, ival);
		splx(s);
		return (err);
	case UE_ISOCHRONOUS:
		switch (speed) {
		case EHCI_QH_SPEED_HIGH:
		case EHCI_QH_SPEED_FULL:
			pipe->methods = &ehci_device_isoc_methods;
			break;
		case EHCI_QH_SPEED_LOW:
		default:
			return (USBD_INVAL);
		}
		/* Spec page 271 says intervals > 16 are invalid */
		if (ed->bInterval == 0 || ed->bInterval > 16) {
			printf("ehci: opening pipe with invalid bInterval\n");
			return (USBD_INVAL);
		}
		if (UGETW(ed->wMaxPacketSize) == 0) {
			printf("ehci: zero length endpoint open request\n");
			return (USBD_INVAL);
		}
		epipe->u.isoc.next_frame = 0;
		epipe->u.isoc.cur_xfers = 0;
		break;
	default:
		DPRINTF(("ehci: bad xfer type %d\n", xfertype));
		return (USBD_INVAL);
	}
	return (USBD_NORMAL_COMPLETION);
}

/*
 * Add an ED to the schedule.  Called at splusb().
 * If in the async schedule, it will always have a next.
 * If in the intr schedule it may not.
 */
void
ehci_add_qh(struct ehci_soft_qh *sqh, struct ehci_soft_qh *head)
{
	SPLUSBCHECK;

	usb_syncmem(&head->dma, head->offs + offsetof(struct ehci_qh, qh_link),
	    sizeof(head->qh.qh_link), BUS_DMASYNC_POSTWRITE);
	sqh->next = head->next;
	sqh->prev = head;
	sqh->qh.qh_link = head->qh.qh_link;
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(struct ehci_qh, qh_link),
	    sizeof(sqh->qh.qh_link), BUS_DMASYNC_PREWRITE);
	head->next = sqh;
	if (sqh->next)
		sqh->next->prev = sqh;
	head->qh.qh_link = htole32(sqh->physaddr | EHCI_LINK_QH);
	usb_syncmem(&head->dma, head->offs + offsetof(struct ehci_qh, qh_link),
	    sizeof(head->qh.qh_link), BUS_DMASYNC_PREWRITE);
}

/*
 * Remove an ED from the schedule.  Called at splusb().
 * Will always have a 'next' if it's in the async list as it's circular.
 */
void
ehci_rem_qh(struct ehci_softc *sc, struct ehci_soft_qh *sqh)
{
	SPLUSBCHECK;
	/* XXX */
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(struct ehci_qh, qh_link),
	    sizeof(sqh->qh.qh_link), BUS_DMASYNC_POSTWRITE);
	sqh->prev->qh.qh_link = sqh->qh.qh_link;
	sqh->prev->next = sqh->next;
	if (sqh->next)
		sqh->next->prev = sqh->prev;
	usb_syncmem(&sqh->prev->dma,
	    sqh->prev->offs + offsetof(struct ehci_qh, qh_link),
	    sizeof(sqh->prev->qh.qh_link), BUS_DMASYNC_PREWRITE);

	ehci_sync_hc(sc);
}

void
ehci_set_qh_qtd(struct ehci_soft_qh *sqh, struct ehci_soft_qtd *sqtd)
{
	int i;
	u_int32_t status;

	/* Save toggle bit and ping status. */
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	status = sqh->qh.qh_qtd.qtd_status &
	    htole32(EHCI_QTD_TOGGLE_MASK |
		EHCI_QTD_SET_STATUS(EHCI_QTD_PINGSTATE));
	/* Set HALTED to make hw leave it alone. */
	sqh->qh.qh_qtd.qtd_status =
	    htole32(EHCI_QTD_SET_STATUS(EHCI_QTD_HALTED));
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	sqh->qh.qh_curqtd = 0;
	sqh->qh.qh_qtd.qtd_next = htole32(sqtd->physaddr);
	sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
	for (i = 0; i < EHCI_QTD_NBUFFERS; i++)
		sqh->qh.qh_qtd.qtd_buffer[i] = 0;
	sqh->sqtd = sqtd;
	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	/* Set !HALTED && !ACTIVE to start execution, preserve some fields */
	sqh->qh.qh_qtd.qtd_status = status;
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
}

/*
 * Ensure that the HC has released all references to the QH.  We do this
 * by asking for a Async Advance Doorbell interrupt and then we wait for
 * the interrupt.
 * To make this easier we first obtain exclusive use of the doorbell.
 */
void
ehci_sync_hc(struct ehci_softc *sc)
{
	int s, error;
	int tries = 0;

	if (sc->sc_bus.dying) {
		return;
	}

	/* get doorbell */
	rw_enter_write(&sc->sc_doorbell_lock);
	s = splhardusb();
	do {
		EOWRITE4(sc, EHCI_USBCMD, EOREAD4(sc, EHCI_USBCMD) |
		    EHCI_CMD_IAAD);
		error = tsleep(&sc->sc_async_head, PZERO, "ehcidi", hz / 2);
	} while (error && ++tries < 10);
	splx(s);
	/* release doorbell */
	rw_exit_write(&sc->sc_doorbell_lock);
#ifdef DIAGNOSTIC
	if (error)
		printf("ehci_sync_hc: tsleep() = %d\n", error);
#endif
}

void
ehci_rem_itd_chain(struct ehci_softc *sc, struct ehci_xfer *ex)
{
	struct ehci_soft_itd *itd, *prev = NULL;

	splsoftassert(IPL_SOFTUSB);

	KASSERT(ex->itdstart != NULL && ex->itdend != NULL);

	for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
		prev = itd->u.frame_list.prev;
		/* Unlink itd from hardware chain, or frame array */
		if (prev == NULL) { /* We're at the table head */
			sc->sc_softitds[itd->slot] = itd->u.frame_list.next;
			sc->sc_flist[itd->slot] = itd->itd.itd_next;
			usb_syncmem(&sc->sc_fldma,
			    sizeof(uint32_t) * itd->slot, sizeof(uint32_t),
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

			if (itd->u.frame_list.next != NULL)
				itd->u.frame_list.next->u.frame_list.prev =
				    NULL;
		} else {
			/* XXX this part is untested... */
			prev->itd.itd_next = itd->itd.itd_next;
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_itd, itd_next),
			    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE);

			prev->u.frame_list.next = itd->u.frame_list.next;
			if (itd->u.frame_list.next != NULL)
				itd->u.frame_list.next->u.frame_list.prev =
				    prev;
		}
	}
}

void
ehci_free_itd_chain(struct ehci_softc *sc, struct ehci_xfer *ex)
{
	struct ehci_soft_itd *itd, *prev = NULL;

	splsoftassert(IPL_SOFTUSB);

	KASSERT(ex->itdstart != NULL && ex->itdend != NULL);

	for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
		if (prev != NULL)
			ehci_free_itd(sc, prev);
		prev = itd;
	}
	if (prev)
		ehci_free_itd(sc, prev);
	ex->itdstart = NULL;
	ex->itdend = NULL;
}

/*
 * Data structures and routines to emulate the root hub.
 */
usb_device_descriptor_t ehci_devd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE,		/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_HSHUBSTT,	/* protocol */
	64,			/* max packet */
	{0},{0},{0x00,0x01},	/* device id */
	1,2,0,			/* string indicies */
	1			/* # of configurations */
};

usb_device_qualifier_t ehci_odevd = {
	USB_DEVICE_DESCRIPTOR_SIZE,
	UDESC_DEVICE_QUALIFIER,	/* type */
	{0x00, 0x02},		/* USB version */
	UDCLASS_HUB,		/* class */
	UDSUBCLASS_HUB,		/* subclass */
	UDPROTO_FSHUB,		/* protocol */
	64,			/* max packet */
	1,			/* # of configurations */
	0
};

usb_config_descriptor_t ehci_confd = {
	USB_CONFIG_DESCRIPTOR_SIZE,
	UDESC_CONFIG,
	{USB_CONFIG_DESCRIPTOR_SIZE +
	 USB_INTERFACE_DESCRIPTOR_SIZE +
	 USB_ENDPOINT_DESCRIPTOR_SIZE},
	1,
	1,
	0,
	UC_SELF_POWERED,
	0			/* max power */
};

usb_interface_descriptor_t ehci_ifcd = {
	USB_INTERFACE_DESCRIPTOR_SIZE,
	UDESC_INTERFACE,
	0,
	0,
	1,
	UICLASS_HUB,
	UISUBCLASS_HUB,
	UIPROTO_HSHUBSTT,
	0
};

usb_endpoint_descriptor_t ehci_endpd = {
	USB_ENDPOINT_DESCRIPTOR_SIZE,
	UDESC_ENDPOINT,
	UE_DIR_IN | EHCI_INTR_ENDPT,
	UE_INTERRUPT,
	{8, 0},			/* max packet */
	12
};

usb_hub_descriptor_t ehci_hubd = {
	USB_HUB_DESCRIPTOR_SIZE,
	UDESC_HUB,
	0,
	{0,0},
	0,
	0,
	{0},
};

/*
 * Simulate a hardware hub by handling all the necessary requests.
 */
usbd_status
ehci_root_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_root_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ehci_root_ctrl_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	usb_device_request_t *req;
	void *buf = NULL;
	int port, i;
	int s, len, value, index, l, totlen = 0;
	usb_port_status_t ps;
	usb_hub_descriptor_t hubd;
	usbd_status err;
	u_int32_t v;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST))
		/* XXX panic */
		return (USBD_INVAL);
#endif
	req = &xfer->request;

	DPRINTFN(4,("ehci_root_ctrl_start: type=0x%02x request=%02x\n",
		    req->bmRequestType, req->bRequest));

	len = UGETW(req->wLength);
	value = UGETW(req->wValue);
	index = UGETW(req->wIndex);

	if (len != 0)
		buf = KERNADDR(&xfer->dmabuf, 0);

#define C(x,y) ((x) | ((y) << 8))
	switch(C(req->bRequest, req->bmRequestType)) {
	case C(UR_CLEAR_FEATURE, UT_WRITE_DEVICE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_CLEAR_FEATURE, UT_WRITE_ENDPOINT):
		/*
		 * DEVICE_REMOTE_WAKEUP and ENDPOINT_HALT are no-ops
		 * for the integrated root hub.
		 */
		break;
	case C(UR_GET_CONFIG, UT_READ_DEVICE):
		if (len > 0) {
			*(u_int8_t *)buf = sc->sc_conf;
			totlen = 1;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_DEVICE):
		DPRINTFN(8,("ehci_root_ctrl_start: wValue=0x%04x\n", value));
		switch(value >> 8) {
		case UDESC_DEVICE:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			USETW(ehci_devd.idVendor, sc->sc_id_vendor);
			memcpy(buf, &ehci_devd, l);
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_DEVICE_QUALIFIER:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_DEVICE_DESCRIPTOR_SIZE);
			memcpy(buf, &ehci_odevd, l);
			break;
		/*
		 * We can't really operate at another speed, but the spec says
		 * we need this descriptor.
		 */
		case UDESC_OTHER_SPEED_CONFIGURATION:
		case UDESC_CONFIG:
			if ((value & 0xff) != 0) {
				err = USBD_IOERROR;
				goto ret;
			}
			totlen = l = min(len, USB_CONFIG_DESCRIPTOR_SIZE);
			memcpy(buf, &ehci_confd, l);
			((usb_config_descriptor_t *)buf)->bDescriptorType =
			    value >> 8;
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_INTERFACE_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &ehci_ifcd, l);
			buf = (char *)buf + l;
			len -= l;
			l = min(len, USB_ENDPOINT_DESCRIPTOR_SIZE);
			totlen += l;
			memcpy(buf, &ehci_endpd, l);
			break;
		case UDESC_STRING:
			if (len == 0)
				break;
			*(u_int8_t *)buf = 0;
			totlen = 1;
			switch (value & 0xff) {
			case 0: /* Language table */
				totlen = usbd_str(buf, len, "\001");
				break;
			case 1: /* Vendor */
				totlen = usbd_str(buf, len, sc->sc_vendor);
				break;
			case 2: /* Product */
				totlen = usbd_str(buf, len, "EHCI root hub");
				break;
			}
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_INTERFACE, UT_READ_INTERFACE):
		if (len > 0) {
			*(u_int8_t *)buf = 0;
			totlen = 1;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_DEVICE):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus,UDS_SELF_POWERED);
			totlen = 2;
		}
		break;
	case C(UR_GET_STATUS, UT_READ_INTERFACE):
	case C(UR_GET_STATUS, UT_READ_ENDPOINT):
		if (len > 1) {
			USETW(((usb_status_t *)buf)->wStatus, 0);
			totlen = 2;
		}
		break;
	case C(UR_SET_ADDRESS, UT_WRITE_DEVICE):
		if (value >= USB_MAX_DEVICES) {
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_SET_CONFIG, UT_WRITE_DEVICE):
		if (value != 0 && value != 1) {
			err = USBD_IOERROR;
			goto ret;
		}
		sc->sc_conf = value;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_DEVICE):
	case C(UR_SET_FEATURE, UT_WRITE_INTERFACE):
	case C(UR_SET_FEATURE, UT_WRITE_ENDPOINT):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_INTERFACE, UT_WRITE_INTERFACE):
		break;
	case C(UR_SYNCH_FRAME, UT_WRITE_ENDPOINT):
		break;
	/* Hub requests */
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_CLEAR_FEATURE, UT_WRITE_CLASS_OTHER):
		DPRINTFN(8, ("ehci_root_ctrl_start: UR_CLEAR_PORT_FEATURE "
		    "port=%d feature=%d\n", index, value));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = EHCI_PORTSC(index);
		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
		switch(value) {
		case UHF_PORT_ENABLE:
			EOWRITE4(sc, port, v &~ EHCI_PS_PE);
			break;
		case UHF_PORT_SUSPEND:
			EOWRITE4(sc, port, v &~ EHCI_PS_SUSP);
			break;
		case UHF_PORT_POWER:
			EOWRITE4(sc, port, v &~ EHCI_PS_PP);
			break;
		case UHF_PORT_TEST:
			DPRINTFN(2,("ehci_root_ctrl_start: "
			    "clear port test %d\n", index));
			break;
		case UHF_PORT_INDICATOR:
			DPRINTFN(2,("ehci_root_ctrl_start: "
			    "clear port index %d\n", index));
			EOWRITE4(sc, port, v &~ EHCI_PS_PIC);
			break;
		case UHF_C_PORT_CONNECTION:
			EOWRITE4(sc, port, v | EHCI_PS_CSC);
			break;
		case UHF_C_PORT_ENABLE:
			EOWRITE4(sc, port, v | EHCI_PS_PEC);
			break;
		case UHF_C_PORT_SUSPEND:
			/* how? */
			break;
		case UHF_C_PORT_OVER_CURRENT:
			EOWRITE4(sc, port, v | EHCI_PS_OCC);
			break;
		case UHF_C_PORT_RESET:
			sc->sc_isreset = 0;
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_GET_DESCRIPTOR, UT_READ_CLASS_DEVICE):
		if ((value & 0xff) != 0) {
			err = USBD_IOERROR;
			goto ret;
		}
		hubd = ehci_hubd;
		hubd.bNbrPorts = sc->sc_noport;
		v = EREAD4(sc, EHCI_HCSPARAMS);
		USETW(hubd.wHubCharacteristics,
		    (EHCI_HCS_PPC(v) ? UHD_PWR_INDIVIDUAL : UHD_PWR_NO_SWITCH) |
		    (EHCI_HCS_P_INDICATOR(v) ? UHD_PORT_IND : 0));
		hubd.bPwrOn2PwrGood = 200; /* XXX can't find out? */
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8)
			hubd.DeviceRemovable[i++] = 0; /* XXX can't find out? */
		hubd.bDescLength = USB_HUB_DESCRIPTOR_SIZE + i;
		l = min(len, hubd.bDescLength);
		totlen = l;
		memcpy(buf, &hubd, l);
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_DEVICE):
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		memset(buf, 0, len); /* ? XXX */
		totlen = len;
		break;
	case C(UR_GET_STATUS, UT_READ_CLASS_OTHER):
		DPRINTFN(8,("ehci_root_ctrl_start: get port status i=%d\n",
		    index));
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		if (len != 4) {
			err = USBD_IOERROR;
			goto ret;
		}
		v = EOREAD4(sc, EHCI_PORTSC(index));
		DPRINTFN(8,("ehci_root_ctrl_start: port status=0x%04x\n", v));
		i = UPS_HIGH_SPEED;
		if (v & EHCI_PS_CS)	i |= UPS_CURRENT_CONNECT_STATUS;
		if (v & EHCI_PS_PE)	i |= UPS_PORT_ENABLED;
		if (v & EHCI_PS_SUSP)	i |= UPS_SUSPEND;
		if (v & EHCI_PS_OCA)	i |= UPS_OVERCURRENT_INDICATOR;
		if (v & EHCI_PS_PR)	i |= UPS_RESET;
		if (v & EHCI_PS_PP)	i |= UPS_PORT_POWER;
		USETW(ps.wPortStatus, i);
		i = 0;
		if (v & EHCI_PS_CSC)	i |= UPS_C_CONNECT_STATUS;
		if (v & EHCI_PS_PEC)	i |= UPS_C_PORT_ENABLED;
		if (v & EHCI_PS_OCC)	i |= UPS_C_OVERCURRENT_INDICATOR;
		if (sc->sc_isreset)	i |= UPS_C_PORT_RESET;
		USETW(ps.wPortChange, i);
		l = min(len, sizeof(ps));
		memcpy(buf, &ps, l);
		totlen = l;
		break;
	case C(UR_SET_DESCRIPTOR, UT_WRITE_CLASS_DEVICE):
		err = USBD_IOERROR;
		goto ret;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_DEVICE):
		break;
	case C(UR_SET_FEATURE, UT_WRITE_CLASS_OTHER):
		if (index < 1 || index > sc->sc_noport) {
			err = USBD_IOERROR;
			goto ret;
		}
		port = EHCI_PORTSC(index);
		v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
		switch(value) {
		case UHF_PORT_ENABLE:
			EOWRITE4(sc, port, v | EHCI_PS_PE);
			break;
		case UHF_PORT_SUSPEND:
			EOWRITE4(sc, port, v | EHCI_PS_SUSP);
			break;
		case UHF_PORT_DISOWN_TO_1_1:
			/* enter to Port Reset State */
			v &= ~EHCI_PS_PE;
			EOWRITE4(sc, port, v | EHCI_PS_PR);
			ehci_disown(sc, index, 0);
			break;
		case UHF_PORT_RESET:
			DPRINTFN(5,("ehci_root_ctrl_start: reset port %d\n",
			    index));
			if (EHCI_PS_IS_LOWSPEED(v)) {
				/* Low speed device, give up ownership. */
				ehci_disown(sc, index, 1);
				break;
			}
			/* Start reset sequence. */
			v &= ~ (EHCI_PS_PE | EHCI_PS_PR);
			EOWRITE4(sc, port, v | EHCI_PS_PR);
			/* Wait for reset to complete. */
			usb_delay_ms(&sc->sc_bus, USB_PORT_ROOT_RESET_DELAY);
			if (sc->sc_bus.dying) {
				err = USBD_IOERROR;
				goto ret;
			}
			/* Terminate reset sequence. */
			v = EOREAD4(sc, port);
			EOWRITE4(sc, port, v & ~EHCI_PS_PR);
			/* Wait for HC to complete reset. */
			usb_delay_ms(&sc->sc_bus, EHCI_PORT_RESET_COMPLETE);
			if (sc->sc_bus.dying) {
				err = USBD_IOERROR;
				goto ret;
			}
			v = EOREAD4(sc, port);
			DPRINTF(("ehci after reset, status=0x%08x\n", v));
			if (v & EHCI_PS_PR) {
				printf("%s: port reset timeout\n",
				    sc->sc_bus.bdev.dv_xname);
				err = USBD_IOERROR;
				goto ret;
			}
			if (!(v & EHCI_PS_PE)) {
				/* Not a high speed device, give up ownership.*/
				ehci_disown(sc, index, 0);
				break;
			}
			sc->sc_isreset = 1;
			DPRINTF(("ehci port %d reset, status = 0x%08x\n",
			    index, v));
			break;
		case UHF_PORT_POWER:
			DPRINTFN(2,("ehci_root_ctrl_start: "
			    "set port power %d\n", index));
			EOWRITE4(sc, port, v | EHCI_PS_PP);
			break;
		case UHF_PORT_TEST:
			DPRINTFN(2,("ehci_root_ctrl_start: "
			    "set port test %d\n", index));
			break;
		case UHF_PORT_INDICATOR:
			DPRINTFN(2,("ehci_root_ctrl_start: "
			    "set port ind %d\n", index));
			EOWRITE4(sc, port, v | EHCI_PS_PIC);
			break;
		default:
			err = USBD_IOERROR;
			goto ret;
		}
		break;
	case C(UR_CLEAR_TT_BUFFER, UT_WRITE_CLASS_OTHER):
	case C(UR_RESET_TT, UT_WRITE_CLASS_OTHER):
	case C(UR_GET_TT_STATE, UT_READ_CLASS_OTHER):
	case C(UR_STOP_TT, UT_WRITE_CLASS_OTHER):
		break;
	default:
		err = USBD_IOERROR;
		goto ret;
	}
	xfer->actlen = totlen;
	err = USBD_NORMAL_COMPLETION;
 ret:
	xfer->status = err;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
	return (err);
}

void
ehci_disown(struct ehci_softc *sc, int index, int lowspeed)
{
	int port;
	u_int32_t v;

	port = EHCI_PORTSC(index);
	v = EOREAD4(sc, port) &~ EHCI_PS_CLEAR;
	EOWRITE4(sc, port, v | EHCI_PS_PO);
}

/* Abort a root control request. */
void
ehci_root_ctrl_abort(struct usbd_xfer *xfer)
{
	/* Nothing to do, all transfers are synchronous. */
}

/* Close the root pipe. */
void
ehci_root_ctrl_close(struct usbd_pipe *pipe)
{
	/* Nothing to do. */
}

void
ehci_root_intr_done(struct usbd_xfer *xfer)
{
}

usbd_status
ehci_root_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_root_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ehci_root_intr_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	sc->sc_intrxfer = xfer;

	return (USBD_IN_PROGRESS);
}

void
ehci_root_intr_abort(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	int s;

	sc->sc_intrxfer = NULL;

	xfer->status = USBD_CANCELLED;
	s = splusb();
	usb_transfer_complete(xfer);
	splx(s);
}

void
ehci_root_intr_close(struct usbd_pipe *pipe)
{
}

void
ehci_root_ctrl_done(struct usbd_xfer *xfer)
{
}

struct ehci_soft_qh *
ehci_alloc_sqh(struct ehci_softc *sc)
{
	struct ehci_soft_qh *sqh = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freeqhs == NULL) {
		DPRINTFN(2, ("ehci_alloc_sqh: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, EHCI_SQH_SIZE * EHCI_SQH_CHUNK,
		    EHCI_PAGE_SIZE, &dma);
		if (err)
			goto out;
		for (i = 0; i < EHCI_SQH_CHUNK; i++) {
			offs = i * EHCI_SQH_SIZE;
			sqh = KERNADDR(&dma, offs);
			sqh->physaddr = DMAADDR(&dma, offs);
			sqh->dma = dma;
			sqh->offs = offs;
			sqh->next = sc->sc_freeqhs;
			sc->sc_freeqhs = sqh;
		}
	}
	sqh = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh->next;
	memset(&sqh->qh, 0, sizeof(struct ehci_qh));
	sqh->next = NULL;
	sqh->prev = NULL;

out:
	splx(s);
	return (sqh);
}

void
ehci_free_sqh(struct ehci_softc *sc, struct ehci_soft_qh *sqh)
{
	int s;

	s = splusb();
	sqh->next = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh;
	splx(s);
}

struct ehci_soft_qtd *
ehci_alloc_sqtd(struct ehci_softc *sc)
{
	struct ehci_soft_qtd *sqtd = NULL;
	usbd_status err;
	int i, offs;
	struct usb_dma dma;
	int s;

	s = splusb();
	if (sc->sc_freeqtds == NULL) {
		DPRINTFN(2, ("ehci_alloc_sqtd: allocating chunk\n"));
		err = usb_allocmem(&sc->sc_bus, EHCI_SQTD_SIZE*EHCI_SQTD_CHUNK,
		    EHCI_PAGE_SIZE, &dma);
		if (err)
			goto out;
		for(i = 0; i < EHCI_SQTD_CHUNK; i++) {
			offs = i * EHCI_SQTD_SIZE;
			sqtd = KERNADDR(&dma, offs);
			sqtd->physaddr = DMAADDR(&dma, offs);
			sqtd->dma = dma;
			sqtd->offs = offs;
			sqtd->nextqtd = sc->sc_freeqtds;
			sc->sc_freeqtds = sqtd;
		}
	}

	sqtd = sc->sc_freeqtds;
	sc->sc_freeqtds = sqtd->nextqtd;
	memset(&sqtd->qtd, 0, sizeof(struct ehci_qtd));
	sqtd->nextqtd = NULL;

out:
	splx(s);
	return (sqtd);
}

void
ehci_free_sqtd(struct ehci_softc *sc, struct ehci_soft_qtd *sqtd)
{
	int s;

	s = splusb();
	sqtd->nextqtd = sc->sc_freeqtds;
	sc->sc_freeqtds = sqtd;
	splx(s);
}

usbd_status
ehci_alloc_sqtd_chain(struct ehci_softc *sc, u_int alen, struct usbd_xfer *xfer,
    struct ehci_soft_qtd **sp, struct ehci_soft_qtd **ep)
{
	struct ehci_soft_qtd *next, *cur;
	ehci_physaddr_t dataphys, dataphyspage, dataphyslastpage, nextphys;
	u_int32_t qtdstatus;
	u_int len, curlen;
	int mps, i, iscontrol, forceshort;
	int rd = usbd_xfer_isread(xfer);
	struct usb_dma *dma = &xfer->dmabuf;

	DPRINTFN(alen<4*4096,("ehci_alloc_sqtd_chain: start len=%d\n", alen));

	len = alen;
	iscontrol = (xfer->pipe->endpoint->edesc->bmAttributes & UE_XFERTYPE) ==
	    UE_CONTROL;

	dataphys = DMAADDR(dma, 0);
	dataphyslastpage = EHCI_PAGE(dataphys + len - 1);
	qtdstatus = EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(rd ? EHCI_QTD_PID_IN : EHCI_QTD_PID_OUT) |
	    EHCI_QTD_SET_CERR(3); /* IOC and BYTES set below */
	mps = UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
	forceshort = ((xfer->flags & USBD_FORCE_SHORT_XFER) || len == 0) &&
	    len % mps == 0;
	/*
	 * The control transfer data stage always starts with a toggle of 1.
	 * For other transfers we let the hardware track the toggle state.
	 */
	if (iscontrol)
		qtdstatus |= EHCI_QTD_SET_TOGGLE(1);

	cur = ehci_alloc_sqtd(sc);
	*sp = cur;
	if (cur == NULL)
		goto nomem;

	usb_syncmem(dma, 0, alen,
	    rd ? BUS_DMASYNC_PREREAD : BUS_DMASYNC_PREWRITE);
	for (;;) {
		dataphyspage = EHCI_PAGE(dataphys);
		/* The EHCI hardware can handle at most 5 pages. */
		if (dataphyslastpage - dataphyspage <
		    EHCI_QTD_NBUFFERS * EHCI_PAGE_SIZE) {
			/* we can handle it in this QTD */
			curlen = len;
		} else {
			/* must use multiple TDs, fill as much as possible. */
			curlen = EHCI_QTD_NBUFFERS * EHCI_PAGE_SIZE -
				 EHCI_PAGE_OFFSET(dataphys);
#ifdef DIAGNOSTIC
			if (curlen > len) {
				printf("ehci_alloc_sqtd_chain: curlen=%u "
				    "len=%u offs=0x%x\n", curlen, len,
				    EHCI_PAGE_OFFSET(dataphys));
				printf("lastpage=0x%x page=0x%x phys=0x%x\n",
				    dataphyslastpage, dataphyspage, dataphys);
				curlen = len;
			}
#endif
			/* the length must be a multiple of the max size */
			curlen -= curlen % mps;
			DPRINTFN(1,("ehci_alloc_sqtd_chain: multiple QTDs, "
			    "curlen=%u\n", curlen));
#ifdef DIAGNOSTIC
			if (curlen == 0)
				panic("ehci_alloc_std: curlen == 0");
#endif
		}

		DPRINTFN(4,("ehci_alloc_sqtd_chain: dataphys=0x%08x "
		    "dataphyslastpage=0x%08x len=%u curlen=%u\n",
		    dataphys, dataphyslastpage, len, curlen));
		len -= curlen;

		/*
		 * Allocate another transfer if there's more data left,
		 * or if force last short transfer flag is set and we're
		 * allocating a multiple of the max packet size.
		 */
		if (len != 0 || forceshort) {
			next = ehci_alloc_sqtd(sc);
			if (next == NULL)
				goto nomem;
			nextphys = htole32(next->physaddr);
		} else {
			next = NULL;
			nextphys = htole32(EHCI_LINK_TERMINATE);
		}

		for (i = 0; i * EHCI_PAGE_SIZE <
		    curlen + EHCI_PAGE_OFFSET(dataphys); i++) {
			ehci_physaddr_t a = dataphys + i * EHCI_PAGE_SIZE;
			if (i != 0) /* use offset only in first buffer */
				a = EHCI_PAGE(a);
#ifdef DIAGNOSTIC
			if (i >= EHCI_QTD_NBUFFERS) {
				printf("ehci_alloc_sqtd_chain: i=%d\n", i);
				goto nomem;
			}
#endif
			cur->qtd.qtd_buffer[i] = htole32(a);
			cur->qtd.qtd_buffer_hi[i] = 0;
		}
		cur->nextqtd = next;
		cur->qtd.qtd_next = cur->qtd.qtd_altnext = nextphys;
		cur->qtd.qtd_status = htole32(qtdstatus |
		    EHCI_QTD_SET_BYTES(curlen));
		cur->len = curlen;
		DPRINTFN(10,("ehci_alloc_sqtd_chain: cbp=0x%08x end=0x%08x\n",
		    dataphys, dataphys + curlen));
		DPRINTFN(10,("ehci_alloc_sqtd_chain: curlen=%u\n", curlen));
		if (iscontrol) {
			/*
			 * adjust the toggle based on the number of packets
			 * in this qtd
			 */
			if ((((curlen + mps - 1) / mps) & 1) || curlen == 0)
				qtdstatus ^= EHCI_QTD_TOGGLE_MASK;
		}
		if (len == 0) {
			if (! forceshort)
				break;
			forceshort = 0;
		}
		usb_syncmem(&cur->dma, cur->offs, sizeof(cur->qtd),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		DPRINTFN(10,("ehci_alloc_sqtd_chain: extend chain\n"));
		dataphys += curlen;
		cur = next;
	}
	cur->qtd.qtd_status |= htole32(EHCI_QTD_IOC);
	usb_syncmem(&cur->dma, cur->offs, sizeof(cur->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	*ep = cur;

	DPRINTFN(10,("ehci_alloc_sqtd_chain: return sqtd=%p sqtdend=%p\n",
	    *sp, *ep));

	return (USBD_NORMAL_COMPLETION);

 nomem:
	/* XXX free chain */
	DPRINTFN(-1,("ehci_alloc_sqtd_chain: no memory\n"));
	return (USBD_NOMEM);
}

void
ehci_free_sqtd_chain(struct ehci_softc *sc, struct ehci_xfer *ex)
{
	struct ehci_pipe *epipe = (struct ehci_pipe *)ex->xfer.pipe;
	struct ehci_soft_qtd *sqtd, *next;

	DPRINTFN(10,("ehci_free_sqtd_chain: sqtd=%p\n", ex->sqtdstart));

	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = next) {
		next = sqtd->nextqtd;
		ehci_free_sqtd(sc, sqtd);
	}
	ex->sqtdstart = ex->sqtdend = NULL;
	epipe->sqh->sqtd = NULL;
}

struct ehci_soft_itd *
ehci_alloc_itd(struct ehci_softc *sc)
{
	struct ehci_soft_itd *itd, *freeitd;
	usbd_status err;
	int i, s, offs, frindex, previndex;
	struct usb_dma dma;

	s = splusb();

	/* Find an itd that wasn't freed this frame or last frame. This can
	 * discard itds that were freed before frindex wrapped around
	 * XXX - can this lead to thrashing? Could fix by enabling wrap-around
	 *       interrupt and fiddling with list when that happens */
	frindex = (EOREAD4(sc, EHCI_FRINDEX) + 1) >> 3;
	previndex = (frindex != 0) ? frindex - 1 : sc->sc_flsize;

	freeitd = NULL;
	LIST_FOREACH(itd, &sc->sc_freeitds, u.free_list) {
		if (itd == NULL)
			break;
		if (itd->slot != frindex && itd->slot != previndex) {
			freeitd = itd;
			break;
		}
	}

	if (freeitd == NULL) {
		err = usb_allocmem(&sc->sc_bus, EHCI_ITD_SIZE * EHCI_ITD_CHUNK,
		    EHCI_PAGE_SIZE, &dma);
		if (err) {
			splx(s);
			return (NULL);
		}

		for (i = 0; i < EHCI_ITD_CHUNK; i++) {
			offs = i * EHCI_ITD_SIZE;
			itd = KERNADDR(&dma, offs);
			itd->physaddr = DMAADDR(&dma, offs);
			itd->dma = dma;
			itd->offs = offs;
			LIST_INSERT_HEAD(&sc->sc_freeitds, itd, u.free_list);
		}
		freeitd = LIST_FIRST(&sc->sc_freeitds);
	}

	itd = freeitd;
	LIST_REMOVE(itd, u.free_list);
	memset(&itd->itd, 0, sizeof(struct ehci_itd));
	usb_syncmem(&itd->dma, itd->offs + offsetof(struct ehci_itd, itd_next),
	    sizeof(itd->itd.itd_next), BUS_DMASYNC_PREWRITE |
	    BUS_DMASYNC_PREREAD);

	itd->u.frame_list.next = NULL;
	itd->u.frame_list.prev = NULL;
	itd->xfer_next = NULL;
	itd->slot = 0;
	splx(s);

	return (itd);
}

void
ehci_free_itd(struct ehci_softc *sc, struct ehci_soft_itd *itd)
{
	int s;

	s = splusb();
	LIST_INSERT_HEAD(&sc->sc_freeitds, itd, u.free_list);
	splx(s);
}

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
void
ehci_close_pipe(struct usbd_pipe *pipe)
{
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	struct ehci_softc *sc = (struct ehci_softc *)pipe->device->bus;
	struct ehci_soft_qh *sqh = epipe->sqh;
	int s;

	s = splusb();
	ehci_rem_qh(sc, sqh);
	splx(s);
	pipe->endpoint->savedtoggle =
	    EHCI_QTD_GET_TOGGLE(letoh32(sqh->qh.qh_qtd.qtd_status));
	ehci_free_sqh(sc, epipe->sqh);
}

/*
 * Abort a device request.
 * If this routine is called at splusb() it guarantees that the request
 * will be removed from the hardware scheduling and that the callback
 * for it will be called with USBD_CANCELLED status.
 * It's impossible to guarantee that the requested transfer will not
 * have happened since the hardware runs concurrently.
 * If the transaction has already happened we rely on the ordinary
 * interrupt processing to process it.
 */
void
ehci_abort_xfer(struct usbd_xfer *xfer, usbd_status status)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer*)xfer;
	struct ehci_soft_qh *sqh = epipe->sqh;
	struct ehci_soft_qtd *sqtd;
	int s;

	if (sc->sc_bus.dying || xfer->status == USBD_NOT_STARTED) {
		s = splusb();
		if (xfer->status != USBD_NOT_STARTED)
			TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
		xfer->status = status;	/* make software ignore it */
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);
#ifdef DIAGNOSTIC
		ex->isdone = 1;
#endif
		usb_transfer_complete(xfer);
		splx(s);
		return;
	}

	if (xfer->device->bus->intr_context)
		panic("ehci_abort_xfer: not in process context");

	/*
	 * If an abort is already in progress then just wait for it to
	 * complete and return.
	 */
	if (ex->ehci_xfer_flags & EHCI_XFER_ABORTING) {
		DPRINTFN(2, ("ehci_abort_xfer: already aborting\n"));
		/* No need to wait if we're aborting from a timeout. */
		if (status == USBD_TIMEOUT)
			return;
		/* Override the status which might be USBD_TIMEOUT. */
		xfer->status = status;
		DPRINTFN(2, ("ehci_abort_xfer: waiting for abort to finish\n"));
		ex->ehci_xfer_flags |= EHCI_XFER_ABORTWAIT;
		while (ex->ehci_xfer_flags & EHCI_XFER_ABORTING)
			tsleep(&ex->ehci_xfer_flags, PZERO, "ehciaw", 0);
		return;
	}

	/*
	 * Step 1: Make interrupt routine and timeouts ignore xfer.
	 */
	s = splusb();
	ex->ehci_xfer_flags |= EHCI_XFER_ABORTING;
	xfer->status = status;	/* make software ignore it */
	TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);
	splx(s);

	/*
	 * Step 2: Deactivate all of the qTDs that we will be removing,
	 * otherwise the queue head may go active again.
	 */
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		sqtd->qtd.qtd_status = htole32(EHCI_QTD_HALTED);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
	ehci_sync_hc(sc);

	/*
	 * Step 3: Make sure the soft interrupt routine has run. This
	 * should remove any completed items off the queue.
	 * The hardware has no reference to completed items (TDs).
	 * It's safe to remove them at any time.
	 */
	s = splusb();
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0);

#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
	/* Do the wakeup first to avoid touching the xfer after the callback. */
	ex->ehci_xfer_flags &= ~EHCI_XFER_ABORTING;
	if (ex->ehci_xfer_flags & EHCI_XFER_ABORTWAIT) {
		ex->ehci_xfer_flags &= ~EHCI_XFER_ABORTWAIT;
		wakeup(&ex->ehci_xfer_flags);
	}
	usb_transfer_complete(xfer);

	splx(s);
}

void
ehci_abort_isoc_xfer(struct usbd_xfer *xfer, usbd_status status)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	ehci_isoc_trans_t trans_status;
	struct ehci_soft_itd *itd;
	int i;

	splsoftassert(IPL_SOFTUSB);

	if (sc->sc_bus.dying || xfer->status == USBD_NOT_STARTED) {
		if (xfer->status != USBD_NOT_STARTED)
			TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
		xfer->status = status;
		timeout_del(&xfer->timeout_handle);
		usb_rem_task(xfer->device, &xfer->abort_task);
		usb_transfer_complete(xfer);
		return;
	}

	/* Transfer is already done. */
	if (xfer->status != USBD_IN_PROGRESS) {
		DPRINTF(("%s: already done \n", __func__));
		return;
	}


#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
	xfer->status = status;
	TAILQ_REMOVE(&sc->sc_intrhead, ex, inext);
	timeout_del(&xfer->timeout_handle);
	usb_rem_task(xfer->device, &xfer->abort_task);

	if (xfer->device->speed == USB_SPEED_HIGH) {
		for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_itd, itd_ctl),
			    sizeof(itd->itd.itd_ctl),
			    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

			for (i = 0; i < 8; i++) {
				trans_status = le32toh(itd->itd.itd_ctl[i]);
				trans_status &= ~EHCI_ITD_ACTIVE;
				itd->itd.itd_ctl[i] = htole32(trans_status);
			}

			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_itd, itd_ctl),
			    sizeof(itd->itd.itd_ctl),
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		}
	} else {
		for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_sitd, sitd_trans),
			    sizeof(itd->sitd.sitd_trans),
			    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);

			trans_status = le32toh(itd->sitd.sitd_trans);
			trans_status &= ~EHCI_SITD_ACTIVE;
			itd->sitd.sitd_trans = htole32(trans_status);

			usb_syncmem(&itd->dma,
			    itd->offs + offsetof(struct ehci_sitd, sitd_trans),
			    sizeof(itd->sitd.sitd_trans),
			    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		}
	}

	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0);

	usb_transfer_complete(xfer);
}

void
ehci_timeout(void *addr)
{
	struct usbd_xfer *xfer = addr;
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;

	if (sc->sc_bus.dying) {
		ehci_timeout_task(addr);
		return;
	}

	usb_init_task(&xfer->abort_task, ehci_timeout_task, addr,
	    USB_TASK_TYPE_ABORT);
	usb_add_task(xfer->device, &xfer->abort_task);
}

void
ehci_timeout_task(void *addr)
{
	struct usbd_xfer *xfer = addr;
	int s;

	s = splusb();
	ehci_abort_xfer(xfer, USBD_TIMEOUT);
	splx(s);
}

/*
 * Some EHCI chips from VIA / ATI seem to trigger interrupts before writing
 * back the qTD status, or miss signalling occasionally under heavy load.
 * If the host machine is too fast, we can miss transaction completion - when
 * we scan the active list the transaction still seems to be active. This
 * generally exhibits itself as a umass stall that never recovers.
 *
 * We work around this behaviour by setting up this callback after any softintr
 * that completes with transactions still pending, giving us another chance to
 * check for completion after the writeback has taken place.
 */
void
ehci_intrlist_timeout(void *arg)
{
	struct ehci_softc *sc = arg;
	int s;

	if (sc->sc_bus.dying)
		return;

	s = splusb();
	DPRINTFN(1, ("ehci_intrlist_timeout\n"));
	usb_schedsoftintr(&sc->sc_bus);
	splx(s);
}

usbd_status
ehci_device_ctrl_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_device_ctrl_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ehci_device_ctrl_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	usb_device_request_t *req = &xfer->request;
	struct ehci_soft_qtd *setup, *stat, *next;
	struct ehci_soft_qh *sqh;
	u_int len = UGETW(req->wLength);
	usbd_status err;
	int s;

	KASSERT(xfer->rqflags & URQ_REQUEST);

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	setup = ehci_alloc_sqtd(sc);
	if (setup == NULL) {
		err = USBD_NOMEM;
		goto bad1;
	}
	stat = ehci_alloc_sqtd(sc);
	if (stat == NULL) {
		err = USBD_NOMEM;
		goto bad2;
	}

	sqh = epipe->sqh;

	/* Set up data transaction */
	if (len != 0) {
		struct ehci_soft_qtd *end;

		err = ehci_alloc_sqtd_chain(sc, len, xfer, &next, &end);
		if (err)
			goto bad3;
		end->qtd.qtd_status &= htole32(~EHCI_QTD_IOC);
		end->nextqtd = stat;
		end->qtd.qtd_next =
		    end->qtd.qtd_altnext = htole32(stat->physaddr);
		usb_syncmem(&end->dma, end->offs, sizeof(end->qtd),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	} else {
		next = stat;
	}

	memcpy(KERNADDR(&epipe->u.ctl.reqdma, 0), req, sizeof(*req));
	usb_syncmem(&epipe->u.ctl.reqdma, 0, sizeof *req, BUS_DMASYNC_PREWRITE);

	/* Clear toggle */
	setup->qtd.qtd_status = htole32(
	    EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(EHCI_QTD_PID_SETUP) |
	    EHCI_QTD_SET_CERR(3) |
	    EHCI_QTD_SET_TOGGLE(0) |
	    EHCI_QTD_SET_BYTES(sizeof(*req)));
	setup->qtd.qtd_buffer[0] = htole32(DMAADDR(&epipe->u.ctl.reqdma, 0));
	setup->qtd.qtd_buffer_hi[0] = 0;
	setup->nextqtd = next;
	setup->qtd.qtd_next = setup->qtd.qtd_altnext = htole32(next->physaddr);
	setup->len = sizeof(*req);
	usb_syncmem(&setup->dma, setup->offs, sizeof(setup->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	stat->qtd.qtd_status = htole32(
	    EHCI_QTD_ACTIVE |
	    EHCI_QTD_SET_PID(usbd_xfer_isread(xfer) ?
		EHCI_QTD_PID_OUT : EHCI_QTD_PID_IN) |
	    EHCI_QTD_SET_CERR(3) |
	    EHCI_QTD_SET_TOGGLE(1) |
	    EHCI_QTD_IOC);
	stat->qtd.qtd_buffer[0] = 0; /* XXX not needed? */
	stat->qtd.qtd_buffer_hi[0] = 0; /* XXX not needed? */
	stat->nextqtd = NULL;
	stat->qtd.qtd_next = stat->qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
	stat->len = 0;
	usb_syncmem(&stat->dma, stat->offs, sizeof(stat->qtd),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	ex->sqtdstart = setup;
	ex->sqtdend = stat;
#ifdef DIAGNOSTIC
	if (!ex->isdone) {
		printf("%s: not done, ex=%p\n", __func__, ex);
	}
	ex->isdone = 0;
#endif

	/* Insert qTD in QH list. */
	s = splusb();
	ehci_set_qh_qtd(sqh, setup);
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_del(&xfer->timeout_handle);
		timeout_set(&xfer->timeout_handle, ehci_timeout, xfer);
		timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

	return (USBD_IN_PROGRESS);

 bad3:
	ehci_free_sqtd(sc, stat);
 bad2:
	ehci_free_sqtd(sc, setup);
 bad1:
	xfer->status = err;
	usb_transfer_complete(xfer);
	return (err);
}

void
ehci_device_ctrl_done(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;

	KASSERT(xfer->rqflags & URQ_REQUEST);

	if (xfer->status != USBD_NOMEM) {
		ehci_free_sqtd_chain(sc, ex);
	}
}

void
ehci_device_ctrl_abort(struct usbd_xfer *xfer)
{
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

void
ehci_device_ctrl_close(struct usbd_pipe *pipe)
{
	ehci_close_pipe(pipe);
}

usbd_status
ehci_device_bulk_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/* Pipe isn't running, start first */
	return (ehci_device_bulk_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ehci_device_bulk_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_qtd *data, *dataend;
	struct ehci_soft_qh *sqh;
	usbd_status err;
	int s;

	KASSERT(!(xfer->rqflags & URQ_REQUEST));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	sqh = epipe->sqh;

	err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
	if (err) {
		xfer->status = err;
		usb_transfer_complete(xfer);
		return (err);
	}

	/* Set up interrupt info. */
	ex->sqtdstart = data;
	ex->sqtdend = dataend;
#ifdef DIAGNOSTIC
	if (!ex->isdone) {
		printf("ehci_device_bulk_start: not done, ex=%p\n", ex);
	}
	ex->isdone = 0;
#endif

	s = splusb();
	ehci_set_qh_qtd(sqh, data);
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_del(&xfer->timeout_handle);
		timeout_set(&xfer->timeout_handle, ehci_timeout, xfer);
		timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

	return (USBD_IN_PROGRESS);
}

void
ehci_device_bulk_abort(struct usbd_xfer *xfer)
{
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

/*
 * Close a device bulk pipe.
 */
void
ehci_device_bulk_close(struct usbd_pipe *pipe)
{
	ehci_close_pipe(pipe);
}

void
ehci_device_bulk_done(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;

	if (xfer->status != USBD_NOMEM) {
		ehci_free_sqtd_chain(sc, ex);
	}
}

usbd_status
ehci_device_setintr(struct ehci_softc *sc, struct ehci_soft_qh *sqh, int ival)
{
	struct ehci_soft_islot *isp;
	int islot, lev;

	/* Find a poll rate that is large enough. */
	for (lev = EHCI_IPOLLRATES - 1; lev > 0; lev--)
		if (EHCI_ILEV_IVAL(lev) <= ival)
			break;

	/* Pick an interrupt slot at the right level. */
	/* XXX could do better than picking at random */
	islot = EHCI_IQHIDX(lev, arc4random());

	sqh->islot = islot;
	isp = &sc->sc_islots[islot];
	ehci_add_qh(sqh, isp->sqh);

	return (USBD_NORMAL_COMPLETION);
}

usbd_status
ehci_device_intr_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	/* Insert last in queue. */
	err = usb_insert_transfer(xfer);
	if (err)
		return (err);

	/*
	 * Pipe isn't running (otherwise err would be USBD_INPROG),
	 * so start it first.
	 */
	return (ehci_device_intr_start(SIMPLEQ_FIRST(&xfer->pipe->queue)));
}

usbd_status
ehci_device_intr_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_soft_qtd *data, *dataend;
	struct ehci_soft_qh *sqh;
	usbd_status err;
	int s;

	KASSERT(!(xfer->rqflags & URQ_REQUEST));

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	sqh = epipe->sqh;

	err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
	if (err) {
		xfer->status = err;
		usb_transfer_complete(xfer);
		return (err);
	}

	/* Set up interrupt info. */
	ex->sqtdstart = data;
	ex->sqtdend = dataend;
#ifdef DIAGNOSTIC
	if (!ex->isdone)
		printf("ehci_device_intr_start: not done, ex=%p\n", ex);
	ex->isdone = 0;
#endif

	s = splusb();
	ehci_set_qh_qtd(sqh, data);
	if (xfer->timeout && !sc->sc_bus.use_polling) {
		timeout_del(&xfer->timeout_handle);
		timeout_set(&xfer->timeout_handle, ehci_timeout, xfer);
		timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
	}
	TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
	xfer->status = USBD_IN_PROGRESS;
	splx(s);

	return (USBD_IN_PROGRESS);
}

void
ehci_device_intr_abort(struct usbd_xfer *xfer)
{
	KASSERT(!xfer->pipe->repeat || xfer->pipe->intrxfer == xfer);

	/*
	 * XXX - abort_xfer uses ehci_sync_hc, which syncs via the advance
	 *       async doorbell. That's dependant on the async list, wheras
	 *       intr xfers are periodic, should not use this?
	 */
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

void
ehci_device_intr_close(struct usbd_pipe *pipe)
{
	ehci_close_pipe(pipe);
}

void
ehci_device_intr_done(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct ehci_soft_qtd *data, *dataend;
	struct ehci_soft_qh *sqh;
	usbd_status err;
	int s;

	if (xfer->pipe->repeat) {
		ehci_free_sqtd_chain(sc, ex);

		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    usbd_xfer_isread(xfer) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
		sqh = epipe->sqh;

		err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
		if (err) {
			xfer->status = err;
			return;
		}

		/* Set up interrupt info. */
		ex->sqtdstart = data;
		ex->sqtdend = dataend;
#ifdef DIAGNOSTIC
		if (!ex->isdone) {
			printf("ehci_device_intr_done: not done, ex=%p\n",
					ex);
		}
		ex->isdone = 0;
#endif

		s = splusb();
		ehci_set_qh_qtd(sqh, data);
		if (xfer->timeout && !sc->sc_bus.use_polling) {
			timeout_del(&xfer->timeout_handle);
			timeout_set(&xfer->timeout_handle, ehci_timeout, xfer);
			timeout_add_msec(&xfer->timeout_handle, xfer->timeout);
		}
		TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
		xfer->status = USBD_IN_PROGRESS;
		splx(s);
	} else if (xfer->status != USBD_NOMEM) {
		ehci_free_sqtd_chain(sc, ex);
	}
}

usbd_status
ehci_device_isoc_transfer(struct usbd_xfer *xfer)
{
	usbd_status err;

	err = usb_insert_transfer(xfer);
	if (err && err != USBD_IN_PROGRESS)
		return (err);

	return (ehci_device_isoc_start(xfer));
}

usbd_status
ehci_device_isoc_start(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	uint8_t ival = ed->bInterval;
	struct ehci_soft_itd *itd;
	int s, frindex;
	uint32_t link;

	KASSERT(!(xfer->rqflags & URQ_REQUEST));
	KASSERT(ival > 0 && ival <= 16);

	/*
	 * To allow continuous transfers, above we start all transfers
	 * immediately. However, we're still going to get usbd_start_next call
	 * this when another xfer completes. So, check if this is already
	 * in progress or not
	 */
	if (ex->itdstart != NULL)
		return (USBD_IN_PROGRESS);

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	/* Why would you do that anyway? */
	if (sc->sc_bus.use_polling)
		return (USBD_INVAL);

	/*
	 * To avoid complication, don't allow a request right now that'll span
	 * the entire frame table. To within 4 frames, to allow some leeway
	 * on either side of where the hc currently is.
	 */
	if ((1 << (ival - 1)) * xfer->nframes >= (sc->sc_flsize - 4) * 8)
		return (USBD_INVAL);

	/*
	 * Step 1: Allocate and initialize itds.
	 */
	if (xfer->device->speed == USB_SPEED_HIGH) {
		if (ehci_alloc_itd_chain(sc, xfer))
			return (USBD_INVAL);

		link = EHCI_LINK_ITD;
	} else {
		if (ehci_alloc_sitd_chain(sc, xfer))
			return (USBD_INVAL);

		link = EHCI_LINK_SITD;
	}

#ifdef DIAGNOSTIC
	if (!ex->isdone) {
		printf("%s: not done, ex=%p\n", __func__, ex);
	}
	ex->isdone = 0;
#endif

	/*
	 * Part 2: Transfer descriptors have now been set up, now they must
	 * be scheduled into the period frame list. Erk. Not wanting to
	 * complicate matters, transfer is denied if the transfer spans
	 * more than the period frame list.
	 */
	s = splusb();

	/* Start inserting frames */
	if (epipe->u.isoc.cur_xfers > 0) {
		frindex = epipe->u.isoc.next_frame;
	} else {
		frindex = EOREAD4(sc, EHCI_FRINDEX);
		frindex = frindex >> 3; /* Erase microframe index */
		frindex += 2;
	}

	if (frindex >= sc->sc_flsize)
		frindex &= (sc->sc_flsize - 1);

	/* What's the frame interval? */
	ival = (1 << (ival - 1));
	if (ival / 8 == 0)
		ival = 1;
	else
		ival /= 8;

	/* Abuse the fact that itd_next == sitd_next. */
	for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
		itd->itd.itd_next = sc->sc_flist[frindex];
		if (itd->itd.itd_next == 0)
			itd->itd.itd_next = htole32(EHCI_LINK_TERMINATE);

		sc->sc_flist[frindex] = htole32(link | itd->physaddr);
		itd->u.frame_list.next = sc->sc_softitds[frindex];
		sc->sc_softitds[frindex] = itd;
		if (itd->u.frame_list.next != NULL)
			itd->u.frame_list.next->u.frame_list.prev = itd;
		itd->slot = frindex;
		itd->u.frame_list.prev = NULL;

		frindex += ival;
		if (frindex >= sc->sc_flsize)
			frindex -= sc->sc_flsize;
	}

	epipe->u.isoc.cur_xfers++;
	epipe->u.isoc.next_frame = frindex;

	TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
	xfer->status = USBD_IN_PROGRESS;
	xfer->done = 0;
	splx(s);

	return (USBD_IN_PROGRESS);
}

int
ehci_alloc_itd_chain(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	const uint32_t mps = UGETW(ed->wMaxPacketSize);
	struct ehci_soft_itd *itd = NULL, *pitd = NULL;
	int i, j, nframes, uframes, ufrperframe;
	int offs = 0, trans_count = 0;

	/*
	 * How many itds do we need?  One per transfer if interval >= 8
	 * microframes, fewer if we use multiple microframes per frame.
	 */
	switch (ed->bInterval) {
	case 1:
		ufrperframe = 8;
		break;
	case 2:
		ufrperframe = 4;
		break;
	case 3:
		ufrperframe = 2;
		break;
	default:
		ufrperframe = 1;
		break;
	}
	nframes = (xfer->nframes + (ufrperframe - 1)) / ufrperframe;
	uframes = 8 / ufrperframe;
	if (nframes == 0)
		return (1);

	for (i = 0; i < nframes; i++) {
		uint32_t froffs = offs;

		itd = ehci_alloc_itd(sc);
		if (itd == NULL) {
			ehci_free_itd_chain(sc, ex);
			return (1);
		}

		if (pitd != NULL)
			pitd->xfer_next = itd;
		else
			ex->itdstart = itd;

		/*
		 * Step 1.5, initialize uframes
		 */
		for (j = 0; j < 8; j += uframes) {
			/* Calculate which page in the list this starts in */
			int addr = DMAADDR(&xfer->dmabuf, froffs);
			addr = EHCI_PAGE_OFFSET(addr) + (offs - froffs);
			addr = EHCI_PAGE(addr) / EHCI_PAGE_SIZE;

			/* This gets the initial offset into the first page,
			 * looks how far further along the current uframe
			 * offset is. Works out how many pages that is.
			 */
			itd->itd.itd_ctl[j] = htole32(
			    EHCI_ITD_ACTIVE |
			    EHCI_ITD_SET_LEN(xfer->frlengths[trans_count]) |
			    EHCI_ITD_SET_PG(addr) |
			    EHCI_ITD_SET_OFFS(DMAADDR(&xfer->dmabuf, offs))
			);

			offs += xfer->frlengths[trans_count];
			trans_count++;

			if (trans_count >= xfer->nframes) { /*Set IOC*/
				itd->itd.itd_ctl[j] |= htole32(EHCI_ITD_IOC);
				break;
			}
		}

		/* Step 1.75, set buffer pointers. To simplify matters, all
		 * pointers are filled out for the next 7 hardware pages in
		 * the dma block, so no need to worry what pages to cover
		 * and what to not.
		 */

		for (j = 0; j < 7; j++) {
			/*
			 * Don't try to lookup a page that's past the end
			 * of buffer
			 */
			int page_offs = EHCI_PAGE(froffs +
			    (EHCI_PAGE_SIZE * j));

			if (page_offs >= xfer->dmabuf.block->size)
				break;

			long long page = DMAADDR(&xfer->dmabuf, page_offs);
			page = EHCI_PAGE(page);
			itd->itd.itd_bufr[j] = htole32(page);
			itd->itd.itd_bufr_hi[j] = htole32(page >> 32);
		}

		/*
		 * Other special values
		 */
		itd->itd.itd_bufr[0] |= htole32(
		    EHCI_ITD_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
		    EHCI_ITD_SET_DADDR(xfer->pipe->device->address)
		);

		itd->itd.itd_bufr[1] |= htole32(
		    (usbd_xfer_isread(xfer) ? EHCI_ITD_SET_DIR(1) : 0) |
		    EHCI_ITD_SET_MAXPKT(UE_GET_SIZE(mps))
		);
		/* FIXME: handle invalid trans */
		itd->itd.itd_bufr[2] |= htole32(
		    EHCI_ITD_SET_MULTI(UE_GET_TRANS(mps)+1)
		);

		pitd = itd;
	}

	ex->itdend = itd;

	return (0);
}

int
ehci_alloc_sitd_chain(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	struct usbd_device *hshub = xfer->device->myhsport->parent;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	struct ehci_soft_itd *itd = NULL, *pitd = NULL;
	uint8_t smask, cmask, tp, uf;
	int i, nframes, offs = 0;
	uint32_t endp;

	nframes = xfer->nframes;
	if (nframes == 0)
		return (1);

	endp = EHCI_SITD_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
	    EHCI_SITD_SET_ADDR(xfer->device->address) |
	    EHCI_SITD_SET_PORT(xfer->device->myhsport->portno) |
	    EHCI_SITD_SET_HUBA(hshub->address);

	if (usbd_xfer_isread(xfer))
		endp |= EHCI_SITD_SET_DIR(1);

	for (i = 0; i < nframes; i++) {
		uint32_t addr = DMAADDR(&xfer->dmabuf, offs);
		uint32_t page = EHCI_PAGE(addr + xfer->frlengths[i] - 1);

		itd = ehci_alloc_itd(sc);
		if (itd == NULL) {
			ehci_free_itd_chain(sc, ex);
			return (1);
		}
		if (pitd)
			pitd->xfer_next = itd;
		else
			ex->itdstart = itd;

		itd->sitd.sitd_endp = htole32(endp);
		itd->sitd.sitd_back = htole32(EHCI_LINK_TERMINATE);
		itd->sitd.sitd_trans = htole32(
		    EHCI_SITD_ACTIVE |
		    EHCI_SITD_SET_LEN(xfer->frlengths[i]) |
		    ((i == nframes - 1) ? EHCI_SITD_IOC : 0)
		);

		uf = max(1, ((xfer->frlengths[i] + 187) / 188));

		/*
		 * Since we do not yet budget and schedule micro-frames
		 * we assume there is no other transfer using the same
		 * TT.
		 */
		if (usbd_xfer_isread(xfer)) {
			smask = 0x01;
			cmask = ((1 << (uf + 2)) - 1) << 2;
		} else {
			/* Is the payload is greater than 188 bytes? */
			if (uf == 1)
				tp = EHCI_SITD_TP_ALL;
			else
				tp = EHCI_SITD_TP_BEGIN;

			page |=	EHCI_SITD_SET_TCOUNT(uf) | EHCI_SITD_SET_TP(tp);
			smask = (1 << uf) - 1;
			cmask = 0x00;
		}

		itd->sitd.sitd_sched = htole32(
		    EHCI_SITD_SET_SMASK(smask) | EHCI_SITD_SET_CMASK(cmask)
		);
		itd->sitd.sitd_bufr[0] = htole32(addr);
		itd->sitd.sitd_bufr[1] = htole32(page);

		offs += xfer->frlengths[i];
		pitd = itd;
	}

	ex->itdend = itd;

	return (0);
}

void
ehci_device_isoc_abort(struct usbd_xfer *xfer)
{
	int s;

	s = splusb();
	ehci_abort_isoc_xfer(xfer, USBD_CANCELLED);
	splx(s);
}

void
ehci_device_isoc_close(struct usbd_pipe *pipe)
{
}

void
ehci_device_isoc_done(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	int s;

	s = splusb();
	epipe->u.isoc.cur_xfers--;
	if (xfer->status != USBD_NOMEM) {
		ehci_rem_itd_chain(sc, ex);
		ehci_free_itd_chain(sc, ex);
	}
	splx(s);
}
@


1.197
log
@Fix a use-after-free when sending root hub control transfers.

*_root_ctrl_start() routines are synchronous and all end up calling
usb_transfer_complete() in the non-error case.  After calling this
function it is unsafe to dereference ``xfer'' since the transfer
callback has been called.  So returning USBD_IN_PROGRESS is wrong in
this case since transfers are always completed at this point.

So return USBD_NORMAL_COMPLETION or the corresponding error code if
something wrong happen.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.196 2017/03/10 09:14:06 mpi Exp $ */
d490 1
a490 1
	free(sc->sc_softitds, M_USB, sc->sc_flsize);
d945 1
a945 1
	free(sc->sc_softitds, M_USB, sc->sc_flsize);
@


1.196
log
@Move per HC polling code to the stack.

This code contains a use-after-free which be addressed in an upcoming
diff.

This fix xhci(4) polling mode.

ok kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.195 2016/11/08 10:31:30 mpi Exp $ */
d2141 1
a2141 1
	return (USBD_IN_PROGRESS);
@


1.195
log
@Remove superfluous DMA synchronization now that the stack is doing it for
all HCs.

ok patrick@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.194 2016/10/02 06:36:39 kettenis Exp $ */
a119 1
void		ehci_waitintr(struct ehci_softc *, struct usbd_xfer *);
a919 31
/*
 * Wait here until controller claims to have an interrupt.
 * Then call ehci_intr and return.  Use timeout to avoid waiting
 * too long.
 */
void
ehci_waitintr(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	int timo;
	u_int32_t intrs;

	xfer->status = USBD_IN_PROGRESS;
	for (timo = xfer->timeout; timo >= 0; timo--) {
		usb_delay_ms(&sc->sc_bus, 1);
		if (sc->sc_bus.dying)
			break;
		intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS)) &
			sc->sc_eintrs;
		if (intrs) {
			ehci_intr1(sc);
			if (xfer->status != USBD_IN_PROGRESS)
				return;
		}
	}

	/* Timeout */
	xfer->status = USBD_TIMEOUT;
	usb_transfer_complete(xfer);
	/* XXX should free TD */
}

a2943 3
	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);

a3040 3
	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);

a3152 3

	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);
@


1.194
log
@Save and restore the (non-standard) USBMODE register around a reset of the
controller.  This register controls whether the controller is in device or
host mode on many dual role controllers and gets reset during a reset of
the controller, placing the controller in (non-functional) idle mode.  By
saving and restoring it, we keep the controller in host mode.  Since this is
a non-standard register, add a new EHCIF_USBMODE flag and only do the save and
restore if it has been set.

Makes the upper "OTG" port of the Cubox-i work.

ok mpi@@, jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.193 2016/09/15 02:00:17 dlg Exp $ */
a3104 3
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    usbd_xfer_isread(xfer) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
a3264 3
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    usbd_xfer_isread(xfer) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
@


1.193
log
@all pools have their ipl set via pool_setipl, so fold it into pool_init.

the ioff argument to pool_init() is unused and has been for many
years, so this replaces it with an ipl argument. because the ipl
will be set on init we no longer need pool_setipl.

most of these changes have been done with coccinelle using the spatch
below. cocci sucks at formatting code though, so i fixed that by hand.

the manpage and subr_pool.c bits i did myself.

ok tedu@@ jmatthew@@

@@ipl@@
expression pp;
expression ipl;
expression s, a, o, f, m, p;
@@@@
-pool_init(pp, s, a, o, f, m, p);
-pool_setipl(pp, ipl);
+pool_init(pp, s, a, ipl, f, m, p);
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.192 2016/08/18 11:59:58 jsg Exp $ */
d1117 1
a1117 1
	u_int32_t hcr;
d1131 3
d1146 3
@


1.192
log
@add a missing splx in an error path
ok millert@@ stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.191 2016/07/20 09:48:07 mpi Exp $ */
d341 2
a342 3
		pool_init(ehcixfer, sizeof(struct ehci_xfer), 0, 0, 0,
		    "ehcixfer", NULL);
		pool_setipl(ehcixfer, IPL_SOFTUSB);
@


1.191
log
@ATI controllers seem to need the same workaround as VIA controllers.

This should hopefully help people reporting errors with SB700.

From FreeBSD, ok kettenis@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.190 2015/12/11 12:23:09 mpi Exp $ */
d2542 2
a2543 1
		if (err)
d2545 1
@


1.190
log
@Work around Nvidia EHCI controllers bugs.

Do not set the "Port Number", "Hub Address" and "Split Completion Mask"
fields in Isochronous Queue Heads for high-speed devices.

These fields should be ignored by the host controller unless the EPS
field indicates a full- or low-speed device, but that's not the case
with Nvidia controllers.

From NetBSD via miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.189 2015/11/14 17:27:21 mpi Exp $ */
d2828 5
a2832 5
 * Some EHCI chips from VIA seem to trigger interrupts before writing back the
 * qTD status, or miss signalling occasionally under heavy load.  If the host
 * machine is too fast, we we can miss transaction completion - when we scan
 * the active list the transaction still seems to be active.  This generally
 * exhibits itself as a umass stall that never recovers.
@


1.189
log
@Add missing header found while removing <sys/srp.h> from <sys/param.h>
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.188 2015/11/02 14:55:41 mpi Exp $ */
d1451 1
a1451 1
		    );
a1453 3
		    EHCI_QH_SET_HUBA(hshubaddr) |
		    EHCI_QH_SET_PORT(hshubport) |
		    EHCI_QH_SET_CMASK(0x1c) | /* XXX */
d1455 8
a1462 1
		    );
@


1.188
log
@Delay root hub interrupt processing to the soft-interrupt path in order
to mark ehci_intr() as IPL_MPSAFE.

Earlier version tested by ratchov@@, ok visa@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.187 2015/06/26 11:17:34 mpi Exp $ */
d68 1
@


1.187
log
@Revert previous.  uvideo checks the transfered length of every frame and
this break some devices.

As found the hardway by Hugo Sastre via sobrado@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.186 2015/06/22 12:56:55 mpi Exp $ */
a542 1
	sc->sc_bus.intr_context++;
d544 1
a548 1
		sc->sc_bus.intr_context--;
d560 2
a561 1
		ehci_pcd(sc, sc->sc_intrxfer);
a564 2
	sc->sc_bus.intr_context--;

d645 5
@


1.186
log
@Do not update frame lengths to reflect what has really been transfered
when an isochronous transfer is done.

Frame lengths are just input values and no driver mess with them.

ok ratchov@@, jmatthew@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.185 2015/04/16 14:23:48 mpi Exp $ */
d828 1
d846 1
@


1.185
log
@Make sure LLVM static analyzer do not report a false positive,
found by and fix confirmed by jsg@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.184 2015/04/10 15:33:20 mpi Exp $ */
a827 1
				xfer->frlengths[nframes++] = len;
a844 1
			xfer->frlengths[nframes++] = len;
@


1.184
log
@I did quite some changes to this driver, so add copyright.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.183 2015/04/10 13:56:42 mpi Exp $ */
d3395 1
a3395 1
	struct ehci_soft_itd *itd, *pitd = NULL;
a3507 1
	itd->xfer_next = NULL;
d3519 1
a3519 1
	struct ehci_soft_itd *itd, *pitd = NULL;
a3589 1
	itd->xfer_next = NULL;
@


1.183
log
@Full-speed isochronous transfers support with opportunistic micro-frames
scheduling.

More work is required to properly budget and schedule micro-frames, most
of it at the HUB level.  But this let people use USB1.1 uaudio(4) devices
on ehci(4)-only systems.

Thanks to all the testers!

ok ratchov@@, sthen@@, naddy@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.182 2015/03/25 13:23:05 mpi Exp $ */
d4 15
@


1.182
log
@Expand ehci_{add,del}_intr_list() macros.

ehci(4) is using a TAILQ_* to keep track of the pending transfers.  In
this context "pending" means submitted to the hardware.  Now that we
are no longer fiddling with the internal of the TAILQ_* there's no good
reason to keep these macro, but more importantly this will let us reuse
the 'inext' field to get rid of the other hand-rolled lists of xfers.

No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.181 2015/03/25 13:12:45 mpi Exp $ */
d109 1
d167 6
a172 4
struct ehci_soft_itd *ehci_alloc_itd(struct ehci_softc *sc);
void		ehci_free_itd(struct ehci_softc *sc, struct ehci_soft_itd *itd);
void		ehci_rem_free_itd_chain(struct ehci_softc *sc,
		    struct ehci_xfer *);
a196 1
void		ehci_dump_sitd(struct ehci_soft_itd *itd);
d358 2
a359 1
	if (sc->sc_softitds == NULL)
d361 1
d476 1
a657 1
/* Check for an interrupt. */
d661 1
a661 1
	int attr;
a662 1
	attr = xfer->pipe->endpoint->edesc->bmAttributes;
a666 2

	return;
d673 1
a673 1
	struct ehci_soft_qtd *sqtd, *lsqtd;
d676 6
a681 4
	if (ex->sqtdstart == NULL) {
		printf("ehci_check_qh_intr: not valid sqtd\n");
		return;
	}
a682 7
	lsqtd = ex->sqtdend;
#ifdef DIAGNOSTIC
	if (lsqtd == NULL) {
		printf("ehci_check_qh_intr: lsqtd==0\n");
		return;
	}
#endif
a687 4
	usb_syncmem(&lsqtd->dma,
	    lsqtd->offs + offsetof(struct ehci_qtd, qtd_status),
	    sizeof(lsqtd->qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
d727 1
a727 1
	struct ehci_soft_itd *itd;
d733 1
a733 4
	if (ex->itdstart == NULL) {
		printf("ehci_check_itd_intr: not valid itd\n");
		return;
	}
d735 6
a740 7
	itd = ex->itdend;
#ifdef DIAGNOSTIC
	if (itd == NULL) {
		printf("ehci_check_itd_intr: itdend == 0\n");
		return;
	}
#endif
d742 9
a750 3
	/*
	 * check no active transfers in last itd, meaning we're finished
	 */
d752 2
a753 7
	usb_syncmem(&itd->dma, itd->offs + offsetof(struct ehci_itd, itd_ctl),
	    sizeof(itd->itd.itd_ctl), BUS_DMASYNC_POSTWRITE |
	    BUS_DMASYNC_POSTREAD);

	for (i = 0; i < 8; i++) {
		if (letoh32(itd->itd.itd_ctl[i]) & EHCI_ITD_ACTIVE)
			break;
d756 1
a756 9
	if (i == 8) {
		goto done; /* All 8 descriptors inactive, it's done */
	}

	DPRINTFN(12, ("ehci_check_itd_intr: ex %p itd %p still active\n", ex,
	    ex->itdstart));
	return;
done:
	DPRINTFN(12, ("ehci_check_itd_intr: ex=%p done\n", ex));
d760 1
a760 1
	ehci_idone(xfer);
d764 1
a764 1
ehci_idone(struct usbd_xfer *xfer)
d767 3
a769 3
	struct ehci_soft_qtd *sqtd;
	u_int32_t status = 0, nstatus = 0;
	int actlen, cerr;
d771 1
a771 14
#ifdef DIAGNOSTIC
	{
		int s = splhigh();
		if (ex->isdone) {
			splx(s);
			printf("ehci_idone: ex=%p is done!\n", ex);
			return;
		}
		ex->isdone = 1;
		splx(s);
	}
#endif
	if (xfer->status == USBD_CANCELLED ||
	    xfer->status == USBD_TIMEOUT) {
a772 11
	}

	/* The transfer is done, compute actual length and status. */
	if (UE_GET_XFERTYPE(xfer->pipe->endpoint->edesc->bmAttributes)
	    == UE_ISOCHRONOUS) {
		/* Isoc transfer */
		struct ehci_soft_itd *itd;
		int i, nframes, len, uframes;

		nframes = 0;
		actlen = 0;
d774 1
d777 1
a777 2
			panic("ehci: isoc xfer suddenly has 0 bInterval, "
			    "invalid");
d816 19
d836 7
a842 3
			if (nframes >= xfer->nframes)
				break;
		}
d844 7
a850 2
		xfer->actlen = actlen;
		xfer->status = USBD_NORMAL_COMPLETION;
d852 10
a861 1
		goto end;
d863 3
a865 2

	/* Continue processing xfers using queue heads */
d895 1
a895 1
	end:
d959 2
a1341 8

void
ehci_dump_sitd(struct ehci_soft_itd *itd)
{
	printf("SITD %p next=%p prev=%p xfernext=%p physaddr=%X slot=%d\n",
	    itd, itd->u.frame_list.next, itd->u.frame_list.prev,
	    itd->xfer_next, itd->physaddr, itd->slot);
}
a1413 10
	if (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_ISOCHRONOUS) {
		printf("%s: Error opening low/full speed isoc endpoint.\n"
		    "A low/full speed device is attached to a USB2 hub, and "
		    "transaction translations are not yet supported.\n"
		    "Reattach the device to the root hub instead.\n",
		    sc->sc_bus.bdev.dv_xname);
		DPRINTFN(1,("ehci_open: hshubaddr=%d hshubport=%d\n",
		    hshubaddr, hshubport));
		return (USBD_INVAL);
	}
a1449 2
	} else {
		sqh = NULL;
d1456 4
a1459 2
		if (err)
			goto bad;
d1481 10
a1490 1
		pipe->methods = &ehci_device_isoc_methods;
d1493 1
a1493 2
			err = USBD_INVAL;
			goto bad;
d1497 1
a1497 2
			err = USBD_INVAL;
			goto bad;
a1506 5

bad:
	if (sqh != NULL)
		ehci_free_sqh(sc, sqh);
	return (err);
a1623 1
/*Call at splusb*/
d1625 1
a1625 1
ehci_rem_free_itd_chain(struct ehci_softc *sc, struct ehci_xfer *ex)
d1627 1
a1627 1
	struct ehci_soft_itd *itd, *prev;
d1629 1
a1629 1
	prev = NULL;
d1631 1
a1631 2
	if (ex->itdstart == NULL || ex->itdend == NULL)
		panic("ehci isoc xfer being freed, but with no itd chain");
d1640 1
a1640 2
			    sizeof(ehci_link_t) * itd->slot,
			    sizeof(ehci_link_t),
d1659 10
a1669 1
	prev = NULL;
a1680 2
/***********/

a2516 1
		DPRINTFN(2, ("ehci_alloc_itd allocating chunk\n"));
d2519 1
a2519 3

		if (err) {
			DPRINTF(("ehci_alloc_itd, alloc returned %d\n", err));
a2520 1
		}
a2558 2
/****************/

d2705 3
a2707 1
	int s, i, wake;
a2709 1
		s = splusb();
a2715 1
		splx(s);
d2719 6
a2724 2
	if (ex->ehci_xfer_flags & EHCI_XFER_ABORTING) {
		DPRINTFN(2, ("ehci_abort_isoc_xfer: already aborting\n"));
d2727 1
a2727 2
		if (status == USBD_TIMEOUT)
		printf("ehci_abort_xfer: TIMEOUT while aborting\n");
a2728 10

		xfer->status = status;
		DPRINTFN(2, ("ehci_abort_xfer: waiting for abort to finish\n"));
		ex->ehci_xfer_flags |= EHCI_XFER_ABORTING;
		while (ex->ehci_xfer_flags & EHCI_XFER_ABORTING)
			tsleep(&ex->ehci_xfer_flags, PZERO, "ehciiaw", 0);
		return;
	}

	ex->ehci_xfer_flags |= EHCI_XFER_ABORTING;
d2734 33
a2766 6
	s = splusb();
	for (itd = ex->itdstart; itd != NULL; itd = itd->xfer_next) {
		for (i = 0; i < 8; i++) {
			trans_status = letoh32(itd->itd.itd_ctl[i]);
			trans_status &= ~EHCI_ITD_ACTIVE;
			itd->itd.itd_ctl[i] = htole32(trans_status);
a2768 1
	splx(s);
a2769 1
	s = splusb();
a2772 1
	splx(s);
a2773 5
#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
	wake = ex->ehci_xfer_flags & EHCI_XFER_ABORTING;
	ex->ehci_xfer_flags &= ~(EHCI_XFER_ABORTING | EHCI_XFER_ABORTWAIT);
a2774 4
	if (wake)
		wakeup(&ex->ehci_xfer_flags);

	return;
a2829 2
/************************/

d3221 1
a3221 1
			    ex);
a3243 2
/************************/

d3262 5
a3266 5
	struct ehci_soft_itd *itd, *prev, *start, *stop;
	struct usb_dma *dma_buf;
	int i, j, k, frames, uframes, ufrperframe;
	int s, trans_count, offs;
	int frindex;
d3269 1
a3269 5

	start = NULL;
	prev = NULL;
	itd = NULL;
	trans_count = 0;
a3276 1

d3283 4
d3292 1
a3292 4
	if ((1 << (xfer->pipe->endpoint->edesc->bInterval - 1)) *
	    xfer->nframes >= (sc->sc_flsize - 4) * 8) {
		printf("ehci: isoc descriptor requested that spans the entire "
		    "frametable, too many frames\n");
d3294 14
d3311 3
a3313 2
	if (!ex->isdone)
		printf("ehci_device_isoc_start: not done, ex = %p\n", ex);
d3318 4
a3321 3
	 * Step 1: Allocate and initialize itds, how many do we need?
	 * One per transfer if interval >= 8 microframes, fewer if we use
	 * multiple microframes per frame.
d3323 1
d3325 36
a3360 5
	i = xfer->pipe->endpoint->edesc->bInterval;
	if (i > 16 || i == 0) {
		/* Spec page 271 says intervals > 16 are invalid */
		DPRINTF(("ehci_device_isoc_start: bInvertal %d invalid\n", i));
		return (USBD_INVAL);
d3363 26
a3388 1
	switch (i) {
d3402 1
a3402 1
	frames = (xfer->nframes + (ufrperframe - 1)) / ufrperframe;
d3404 2
d3407 2
a3408 7
	if (frames == 0) {
		DPRINTF(("ehci_device_isoc_start: frames == 0\n"));
		return (USBD_INVAL);
	}

	dma_buf = &xfer->dmabuf;
	offs = 0;
a3409 2
	for (i = 0; i < frames; i++) {
		int froffs = offs;
d3411 4
d3416 4
a3419 7
		if (prev != NULL) {
			prev->itd.itd_next =
			    htole32(itd->physaddr | EHCI_LINK_ITD);
			prev->xfer_next = itd;
		} else {
			start = itd;
		}
d3426 3
a3428 5
			int addr = DMAADDR(dma_buf, froffs);
			addr = EHCI_PAGE_OFFSET(addr);
			addr += (offs - froffs);
			addr = EHCI_PAGE(addr);
			addr /= EHCI_PAGE_SIZE;
d3434 3
a3436 3

			itd->itd.itd_ctl[j] = htole32 ( EHCI_ITD_ACTIVE |
			    EHCI_ITD_SET_LEN(xfer->frlengths[trans_count]) | 
d3438 2
a3439 2
			    EHCI_ITD_SET_OFFS(EHCI_PAGE_OFFSET(DMAADDR(dma_buf,
			    offs))));
d3464 1
a3464 1
			if (page_offs >= dma_buf->block->size)
d3467 1
a3467 1
			long long page = DMAADDR(dma_buf, page_offs);
d3469 2
a3470 4
			itd->itd.itd_bufr[j] =
			    htole32(EHCI_ITD_SET_BPTR(page));
			itd->itd.itd_bufr_hi[j] =
			    htole32(page >> 32);
d3476 9
a3484 12

		k = xfer->pipe->endpoint->edesc->bEndpointAddress;
		itd->itd.itd_bufr[0] |=
		    htole32(EHCI_ITD_SET_EP(UE_GET_ADDR(k)) |
		    EHCI_ITD_SET_DADDR(xfer->pipe->device->address));

		k = (UE_GET_DIR(xfer->pipe->endpoint->edesc->bEndpointAddress))
		    ? 1 : 0;
		j = UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
		itd->itd.itd_bufr[1] |= htole32(EHCI_ITD_SET_DIR(k) |
		    EHCI_ITD_SET_MAXPKT(UE_GET_SIZE(j)));

d3486 3
a3488 4
		itd->itd.itd_bufr[2] |= 
		    htole32(EHCI_ITD_SET_MULTI(UE_GET_TRANS(j)+1));
		prev = itd;
	} /* End of frame */
d3490 2
a3491 2
	stop = itd;
	stop->xfer_next = NULL;
d3493 2
a3494 6
	/*
	 * Part 2: Transfer descriptors have now been set up, now they must
	 * be scheduled into the period frame list. Erk. Not wanting to
	 * complicate matters, transfer is denied if the transfer spans
	 * more than the period frame list.
	 */
d3496 2
a3497 1
	s = splusb();
d3499 10
a3508 8
	/* Start inserting frames */
	if (epipe->u.isoc.cur_xfers > 0) {
		frindex = epipe->u.isoc.next_frame;
	} else {
		frindex = EOREAD4(sc, EHCI_FRINDEX);
		frindex = frindex >> 3; /* Erase microframe index */
		frindex += 2;
	}
d3510 3
a3512 2
	if (frindex >= sc->sc_flsize)
		frindex &= (sc->sc_flsize - 1);
d3514 11
a3524 6
	/* Whats the frame interval? */
	i = (1 << (xfer->pipe->endpoint->edesc->bInterval - 1));
	if (i / 8 == 0)
		i = 1;
	else
		i /= 8;
d3526 9
a3534 5
	itd = start;
	for (j = 0; j < frames; j++) {
		if (itd == NULL)
			panic("ehci: unexpectedly ran out of isoc itds, "
			    "isoc_start");
d3536 7
a3542 5
		itd->itd.itd_next = sc->sc_flist[frindex];
		if (itd->itd.itd_next == 0)
			/* FIXME: frindex table gets initialized to NULL
			 * or htole32(EHCI_LINK_TERMINATE)? */
			itd->itd.itd_next = htole32(htole32(EHCI_LINK_TERMINATE));
d3544 1
a3544 7
		sc->sc_flist[frindex] = htole32(EHCI_LINK_ITD | itd->physaddr);
		itd->u.frame_list.next = sc->sc_softitds[frindex];
		sc->sc_softitds[frindex] = itd;
		if (itd->u.frame_list.next != NULL)
			itd->u.frame_list.next->u.frame_list.prev = itd;
		itd->slot = frindex;
		itd->u.frame_list.prev = NULL;
d3546 25
a3570 3
		frindex += i;
		if (frindex >= sc->sc_flsize)
			frindex -= sc->sc_flsize;
d3572 2
a3573 1
		itd = itd->xfer_next;
d3576 2
a3577 2
	epipe->u.isoc.cur_xfers++;
	epipe->u.isoc.next_frame = frindex;
d3579 1
a3579 16
	ex->itdstart = start;
	ex->itdend = stop;
	ex->sqtdstart = NULL;
	ex->sqtdend = NULL;

	TAILQ_INSERT_TAIL(&sc->sc_intrhead, ex, inext);
	xfer->status = USBD_IN_PROGRESS;
	xfer->done = 0;
	splx(s);

	if (sc->sc_bus.use_polling) {
		DPRINTF(("Starting ehci isoc xfer with polling. Bad idea?\n"));
		ehci_waitintr(sc, xfer);
	}

	return (USBD_IN_PROGRESS);
d3585 3
d3589 1
d3608 2
a3609 1
		ehci_rem_free_itd_chain(sc, ex);
@


1.181
log
@Merge ehci_device_request() into ehci_device_ctrl_start() to match
what's done with other transfer types.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.180 2015/03/25 13:06:04 mpi Exp $ */
a203 5
#define ehci_add_intr_list(sc, ex) \
	TAILQ_INSERT_TAIL(&(sc)->sc_intrhead, (ex), inext);
#define ehci_del_intr_list(sc, ex) \
	TAILQ_REMOVE(&sc->sc_intrhead, (ex), inext);

d725 1
a725 1
	ehci_del_intr_list(sc, ex);
d776 1
a776 1
	ehci_del_intr_list(sc, ex);
d2623 1
a2623 1
			ehci_del_intr_list(sc, ex);
d2662 1
a2662 1
	ehci_del_intr_list(sc, ex);
d2731 1
a2731 1
			ehci_del_intr_list(sc, ex);
d2758 1
a2758 1
	ehci_del_intr_list(sc, ex);
d2957 1
a2957 1
	ehci_add_intr_list(sc, ex);
d3057 1
a3057 1
	ehci_add_intr_list(sc, ex);
d3176 1
a3176 1
	ehci_add_intr_list(sc, ex);
d3248 1
a3248 1
		ehci_add_intr_list(sc, ex);
d3516 1
a3516 1
	ehci_add_intr_list(sc, ex);
@


1.180
log
@Remove more DPRINTFs, this file is almost in a readable state now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.179 2015/03/25 13:00:38 mpi Exp $ */
a172 2
usbd_status	ehci_device_request(struct usbd_xfer *xfer);

a2867 46
	usbd_status err;

	KASSERT(xfer->rqflags & URQ_REQUEST);

	if (sc->sc_bus.dying)
		return (USBD_IOERROR);

	err = ehci_device_request(xfer);
	if (err)
		return (err);

	if (sc->sc_bus.use_polling)
		ehci_waitintr(sc, xfer);

	return (USBD_IN_PROGRESS);
}

void
ehci_device_ctrl_done(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;

	KASSERT(xfer->rqflags & URQ_REQUEST);

	if (xfer->status != USBD_NOMEM) {
		ehci_free_sqtd_chain(sc, ex);
	}
}

void
ehci_device_ctrl_abort(struct usbd_xfer *xfer)
{
	ehci_abort_xfer(xfer, USBD_CANCELLED);
}

void
ehci_device_ctrl_close(struct usbd_pipe *pipe)
{
	ehci_close_pipe(pipe);
}

usbd_status
ehci_device_request(struct usbd_xfer *xfer)
{
	struct ehci_softc *sc = (struct ehci_softc *)xfer->device->bus;
d2877 5
d2949 1
a2949 1
		printf("ehci_device_request: not done, ex=%p\n", ex);
d2966 4
a2969 1
	return (USBD_NORMAL_COMPLETION);
d2981 24
a3004 1
/************************/
@


1.179
log
@Use KASSERT() to check when/if URQ_REQUEST is correctly set just like
xhci(4) does.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.178 2015/03/25 12:56:11 mpi Exp $ */
a469 1
	DPRINTFN(1,("ehci_init: enabling\n"));
a507 2
	DPRINTFN(20,("ehci_intr1: enter\n"));

a525 2
	DPRINTFN(7, ("ehci_intr1: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
	     sc, (u_int)intrs, EOREAD4(sc, EHCI_USBSTS), (u_int)eintrs));
a543 3
		DPRINTFN(5,("ehci_intr1: %s %s\n",
			    eintrs & EHCI_STS_INT ? "INT" : "",
			    eintrs & EHCI_STS_ERRINT ? "ERRINT" : ""));
a629 3
	DPRINTFN(10,("%s: ehci_softintr (%d)\n", sc->sc_bus.bdev.dv_xname,
		     sc->sc_bus.intr_context));

a665 2
	DPRINTFN(2, ("%s: xfer=%p\n", __func__, xfer));

a731 1
	DPRINTFN(12, ("ehci_check_intr: ex=%p done\n", ex));
a1629 1
		DPRINTFN(2,("ehci_sync_hc: dying\n"));
d1632 1
a1632 1
	DPRINTFN(2,("ehci_sync_hc: enter\n"));
d1636 1
a1636 2
	do { 
		/* ask for doorbell */
a1638 3
		DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
		/* bell wait */
a1639 2
		DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
a1647 1
	DPRINTFN(2,("ehci_sync_hc: exit\n"));
a2897 2

	DPRINTFN(5, ("ehci_ctrl_done: length=%u\n", xfer->actlen));
a2899 1
/* Abort a device control request. */
a2905 1
/* Close a device control pipe. */
a2924 6
	DPRINTFN(3,("ehci_device_request: type=0x%02x, request=0x%02x, "
	    "wValue=0x%04x, wIndex=0x%04x len=%u, addr=%d, endpt=%d\n",
	    req->bmRequestType, req->bRequest, UGETW(req->wValue),
	    UGETW(req->wIndex), UGETW(req->wLength), xfer->device->address,
	    xfer->pipe->endpoint->edesc->bEndpointAddress));

a3015 1
	DPRINTFN(-1,("ehci_device_request: no memory\n"));
a3056 1
		DPRINTFN(-1,("ehci_device_bulk_start: no memory\n"));
a3109 3
	DPRINTFN(10,("ehci_bulk_done: xfer=%p, actlen=%d\n",
	    xfer, xfer->actlen));

a3115 2

	DPRINTFN(5, ("ehci_bulk_done: length=%d\n", xfer->actlen));
a3117 2
/************************/

a3237 3
	DPRINTFN(10, ("ehci_device_intr_done: xfer=%p, actlen=%d\n",
	    xfer, xfer->actlen));

a3247 1
			DPRINTFN(-1, ("ehci_device_intr_done: no memory\n"));
a3323 3
	DPRINTFN(2, ("ehci_device_isoc_start: xfer %p len %u flags %d\n",
	    xfer, xfer->length, xfer->flags));

a3553 1
	DPRINTFN(1, ("ehci_device_isoc_abort: xfer = %p\n", xfer));
a3559 1
	DPRINTFN(1, ("ehci_device_isoc_close: nothing in the pipe to free?\n"));
@


1.178
log
@Remove EHCI_DEBUG chunks that make things harder to understand.

Over the years I understood that debugging USB HCD problems without
hardware access do not work and even in this case it's easier to write
a specific debug/prinf diff.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.177 2015/03/17 14:45:07 mpi Exp $ */
d2894 2
a2898 8
#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		/* XXX panic */
		printf("ehci_device_ctrl_transfer: not a request\n");
		return (USBD_INVAL);
	}
#endif

d2915 1
a2915 7
	DPRINTFN(10,("ehci_ctrl_done: xfer=%p\n", xfer));

#ifdef DIAGNOSTIC
	if (!(xfer->rqflags & URQ_REQUEST)) {
		panic("ehci_ctrl_done: not a request");
	}
#endif
d3081 1
a3081 2
	DPRINTFN(2, ("ehci_device_bulk_start: xfer=%p len=%u flags=%d\n",
	    xfer, xfer->length, xfer->flags));
a3085 5
#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_bulk_start: a request");
#endif

d3209 2
a3213 5
#ifdef DIAGNOSTIC
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_intr_start: a request");
#endif

d3352 2
a3387 3
	if (xfer->rqflags & URQ_REQUEST)
		panic("ehci_device_isoc_start: request");

@


1.177
log
@Prevent a race resulting in an infinite loop printing "ehci_idone" messages.

As soon as a transfer is being cancelled, remove it from the list of pending
xfers.  This way the soft interrupt routine won't try to process it before
ehci_abort() gives it back to the stack.

Problem analysed by and previous diff ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.176 2015/03/06 22:53:03 mpi Exp $ */
a437 4
#ifdef EHCI_DEBUG
	if (ehcidebug)
		ehci_dump_sqh(sqh);
#endif
a544 1
		DPRINTF(("ehci_intr1: door bell\n"));
a591 1
	DPRINTF(("ehci_pcd: change=0x%02x\n", *p));
a806 3
#ifdef EHCI_DEBUG
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
#endif
a810 1
	DPRINTFN(/*12*/2, ("ehci_idone: ex=%p\n", ex));
a815 4
#ifdef EHCI_DEBUG
			printf("ehci_idone: ex is done!\n   ");
			ehci_dump_exfer(ex);
#else
a816 1
#endif
a824 1
		DPRINTF(("ehci_idone: aborted xfer=%p\n", xfer));
a827 6
#ifdef EHCI_DEBUG
	DPRINTFN(/*10*/2, ("ehci_idone: xfer=%p, pipe=%p ready\n", xfer, epipe));
	if (ehcidebug > 10)
		ehci_dump_sqtds(ex->sqtdstart);
#endif

a828 1

a914 18
#ifdef EHCI_DEBUG
		char sbuf[128];

		bitmask_snprintf((u_int32_t)status,
		    "\20\7HALTED\6BUFERR\5BABBLE\4XACTERR"
		    "\3MISSED\2SPLIT\1PING", sbuf, sizeof(sbuf));

		DPRINTFN(2,
			 ("ehci_idone: error, addr=%d, endpt=0x%02x, "
			  "status 0x%s\n",
			  xfer->device->address,
			  xfer->pipe->endpoint->edesc->bEndpointAddress,
			  sbuf));
		if (ehcidebug > 2) {
			ehci_dump_sqh(epipe->sqh);
			ehci_dump_sqtds(ex->sqtdstart);
		}
#endif
a946 5
		DPRINTFN(15,("ehci_waitintr: 0x%04x\n", intrs));
#ifdef EHCI_DEBUG
		if (ehcidebug > 15)
			ehci_dump_regs(sc);
#endif
a954 1
	DPRINTF(("ehci_waitintr: timeout\n"));
a963 9
#ifdef EHCI_DEBUG
	static int last;
	int new;
	new = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
	if (new != last) {
		DPRINTFN(10,("ehci_poll: intrs=0x%04x\n", new));
		last = new;
	}
#endif
a1125 1
	DPRINTF(("%s: stopping the HC\n", __func__));
a1184 6
	DPRINTF(("ehci_device_clear_toggle: epipe=%p status=0x%x\n",
	    epipe, epipe->sqh->qh.qh_qtd.qtd_status));
#if defined(EHCI_DEBUG) && defined(USB_DEBUG)
	if (ehcidebug)
		usbd_dump_pipe(pipe);
#endif
a1499 4
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_open: usb_allocmem()=%d\n", err);
#endif
a1571 7

#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		printf("ehci_add_qh:\n");
		ehci_dump_sqh(sqh);
	}
#endif
a2197 2
	DPRINTF(("ehci_disown: index=%d lowspeed=%d\n", index, lowspeed));

a2213 1
	DPRINTF(("ehci_root_ctrl_close\n"));
a2648 2
	DPRINTF(("ehci_abort_xfer: xfer=%p pipe=%p\n", xfer, epipe));

d2748 1
a2748 1
 void
a2756 3

	DPRINTF(("ehci_abort_isoc_xfer: xfer %p pipe %p\n", xfer, xfer->pipe));

a2840 2
	DPRINTF(("%s: xfer=%p\n", __func__, xfer));

a2939 1
	DPRINTF(("ehci_device_ctrl_abort: xfer=%p\n", xfer));
a2946 1
	DPRINTF(("ehci_device_ctrl_close: pipe=%p\n", pipe));
a3031 8
#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_request:\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(setup);
	}
#endif

a3052 12
#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_request: status=%x\n",
		    EOREAD4(sc, EHCI_USBSTS)));
		delay(10000);
		ehci_dump_regs(sc);
		ehci_dump_sqh(sc->sc_async_head);
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(setup);
	}
#endif

a3113 8
#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_bulk_start: data(1)\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

a3134 16
#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_bulk_start: data(2)\n"));
		delay(10000);
		DPRINTF(("ehci_device_bulk_start: data(3)\n"));
		ehci_dump_regs(sc);
#if 0
		printf("async_head:\n");
		ehci_dump_sqh(sc->sc_async_head);
#endif
		printf("sqh:\n");
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

a3143 1
	DPRINTF(("ehci_device_bulk_abort: xfer=%p\n", xfer));
a3152 1
	DPRINTF(("ehci_device_bulk_close: pipe=%p\n", pipe));
a3226 3
	DPRINTFN(2, ("ehci_device_intr_start: xfer=%p len=%u flags=%d\n",
	    xfer, xfer->length, xfer->flags));

a3238 1
		DPRINTFN(-1, ("ehci_device_intr_start: no memory\n"));
a3243 8
#ifdef EHCI_DEBUG
	if (ehcidebug > 5) {
		DPRINTF(("ehci_device_intr_start: data(1)\n"));
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

a3263 12
#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_intr_start: data(2)\n"));
		delay(10000);
		DPRINTF(("ehci_device_intr_start: data(3)\n"));
		ehci_dump_regs(sc);
		printf("sqh:\n");
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

a3285 1
	DPRINTF(("ehci_device_intr_close: pipe=%p\n", pipe));
@


1.176
log
@Revert previous, the fix is not right and causes a regression as
reported by Remi Locherer on bugs@@.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.175 2015/02/28 09:22:59 mpi Exp $ */
d209 1
a209 5
	do { \
		TAILQ_REMOVE(&sc->sc_intrhead, (ex), inext); \
		(ex)->inext.tqe_prev = NULL; \
	} while (0)
#define ehci_active_intr_list(ex) ((ex)->inext.tqe_prev != NULL)
d752 1
d803 1
d1057 9
d2728 1
a2728 2
	if (sc->sc_bus.dying) {
		/* If we're dying, just do the software part. */
d2730 2
d2770 1
d2839 1
a2839 1
	if (sc->sc_bus.dying) {
d2841 2
d2866 1
a2867 1

d2869 1
d3013 1
a3013 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
d3297 1
a3297 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
d3493 2
d3496 1
a3496 4

		xfer->status = USBD_IN_PROGRESS;
	} else if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex); /* remove from active list */
d3801 1
a3801 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);
@


1.175
log
@Prevent a race resulting in an infinite loop printing "ehci_idone" messages.

As soon as a transfer is being cancelled, remove it from the list of pending
xfers.  This way the soft interrupt routine won't try to process it before
ehci_abort() gives it back to the stack.

Problem analysed by and ok stsp@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.174 2015/02/09 22:14:43 uebayasi Exp $ */
d209 5
a213 1
	TAILQ_REMOVE(&(sc)->sc_intrhead, (ex), inext);
a755 1
	ehci_del_intr_list(sc, ex);
a805 1
	ehci_del_intr_list(sc, ex);
a2724 1
		ehci_del_intr_list(sc, ex);
a2761 1
	ehci_del_intr_list(sc, ex);
a2832 1
		ehci_del_intr_list(sc, ex);
d2855 1
a2856 1
	ex->ehci_xfer_flags |= EHCI_XFER_ABORTING;
a2857 1
	ehci_del_intr_list(sc, ex);
d3001 2
a3002 1
	if (xfer->status != USBD_NOMEM) {
d3286 2
a3287 1
	if (xfer->status != USBD_NOMEM) {
d3483 2
a3484 1
		ehci_add_intr_list(sc, ex);
d3486 2
a3487 2
		splx(s);
	} else if (xfer->status != USBD_NOMEM) {
d3792 2
a3793 1
	if (xfer->status != USBD_NOMEM) {
@


1.174
log
@Whitespace.
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d209 1
a209 5
	do { \
		TAILQ_REMOVE(&sc->sc_intrhead, (ex), inext); \
		(ex)->inext.tqe_prev = NULL; \
	} while (0)
#define ehci_active_intr_list(ex) ((ex)->inext.tqe_prev != NULL)
d752 1
d803 1
d2723 1
d2761 1
d2833 1
d2856 1
a2857 1

d2859 1
d3003 1
a3003 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
d3287 1
a3287 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
d3483 2
d3486 1
a3486 4

		xfer->status = USBD_IN_PROGRESS;
	} else if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex); /* remove from active list */
d3791 1
a3791 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);
@


1.173
log
@Use <sys/endian.h> instead of <machine/endian.h>

ok dlg@@ mpi@@ bcook@@ millert@@ miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.172 2014/12/17 15:27:49 kettenis Exp $ */
d599 1
a599 1
			p[i/8] |= 1 << (i%8);
d1404 1
a1404 1
	for (i = 0; i < 8;i++) {
d3650 1
a3650 1
		for (j=0; j < 7; j++) {
@


1.172
log
@Avoid premature masking in the interrupt handler code that checks for removed
hardware.

ok mpi@@, deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.171 2014/12/09 07:05:06 doug Exp $ */
d52 1
a54 1
#include <machine/endian.h>
@


1.171
log
@More malloc() -> mallocarray() in the kernel.

ok deraadt@@ tedu@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.170 2014/11/18 02:37:30 tedu Exp $ */
d527 1
a527 1
	intrs = EHCI_STS_INTRS(EOREAD4(sc, EHCI_USBSTS));
d532 1
@


1.170
log
@move arc4random prototype to systm.h. more appropriate for most code
to include that than rdnvar.h. ok deraadt dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.169 2014/10/05 08:40:29 mpi Exp $ */
d365 2
a366 2
	sc->sc_softitds = malloc(sc->sc_flsize * sizeof(struct ehci_soft_itd *),
	    M_USB, M_NOWAIT | M_ZERO);
@


1.169
log
@Do not re-establish the default pipe twice for every controller.  Move
this hack in the drivers that need it.

Tested by many, thanks!  ok pirofti@@, kettenis@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.168 2014/09/01 08:13:02 mpi Exp $ */
a62 2

#include <dev/rndvar.h>
@


1.168
log
@Revert previous, it puts too much pressure on memory allocation as
reported by Bryan Linton on bugs@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.167 2014/08/30 09:33:11 mpi Exp $ */
d102 1
d219 1
a219 1
	.dev_setaddr = usbd_set_address,
d607 34
@


1.167
log
@Rewrite how queue heads are inserted and removed from the asynchronous
list.  Use a queue head per xfer and no longer per pipe.  Since queue
heads are now setup when a transfer is submited we do not need to open
the control pipe more than once.  This also simplify transfer abortion.

Tested by many, thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.166 2014/08/10 11:18:57 mpi Exp $ */
d85 1
d159 1
a159 2
void		ehci_free_sqh(struct ehci_softc *, struct usbd_xfer *);
int		ehci_setup_sqh(struct ehci_softc *, struct usbd_xfer *);
d163 1
a163 1
int		ehci_alloc_sqtd_chain(struct ehci_softc *, u_int,
d181 1
a181 2
void		ehci_insert_qh(struct ehci_softc *, struct usbd_xfer *,
		    struct ehci_soft_qtd *);
d484 4
a723 6
	ehci_rem_qh(sc, ex->sqh);

	/* XXX Not needed for all transfers. */
	xfer->pipe->endpoint->savedtoggle =
	    EHCI_QTD_GET_TOGGLE(letoh32(ex->sqh->qh.qh_qtd.qtd_status));

d781 3
d813 1
a813 1
	DPRINTFN(2, ("ehci_idone: xfer=%p, pipe=%p ready\n", xfer, xfer->pipe));
a900 1

d920 1
a920 1
			ehci_dump_sqh(ex->sqh);
d1199 4
d1207 5
a1211 1
	pipe->endpoint->savedtoggle = 0;
d1413 5
a1417 1
	struct ehci_softc *sc = (struct ehci_softc *)pipe->device->bus;
d1419 1
a1419 2
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
	u_int8_t xfertype = UE_GET_XFERTYPE(ed->bmAttributes);
d1421 3
d1426 1
a1426 1
	    pipe, pipe->device->address, ed->bEndpointAddress));
d1431 8
d1454 64
d1522 4
d1527 1
a1527 1
			return (err);
d1529 3
d1535 3
d1541 7
a1547 1
		break;
d1549 1
a1549 6
		if (pipe->device->speed != USB_SPEED_HIGH) {
			printf("%s: transaction translator not supported.\n",
			    sc->sc_bus.bdev.dv_xname);
			return (USBD_INVAL);
		}

d1552 2
a1553 1
			return (USBD_INVAL);
d1557 2
a1558 1
			return (USBD_INVAL);
a1561 1
		pipe->methods = &ehci_device_isoc_methods;
a1566 1

a1567 1
}
d1569 4
a1572 68
int
ehci_setup_sqh(struct ehci_softc *sc, struct usbd_xfer *xfer)
{
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	u_int8_t xfertype = UE_GET_XFERTYPE(ed->bmAttributes);
	int speed, hshubaddr, hshubport;
	struct ehci_soft_qh *sqh;


	if (xfer->device->myhsport) {
		hshubaddr = xfer->device->myhsport->parent->address;
		hshubport = xfer->device->myhsport->portno;
	} else {
		hshubaddr = 0;
		hshubport = 0;
	}

	/* XXX All this stuff is only valid for async. */
	switch (xfer->device->speed) {
	case USB_SPEED_LOW:
		speed = EHCI_QH_SPEED_LOW;
		break;
	case USB_SPEED_FULL:
		speed = EHCI_QH_SPEED_FULL;
		break;
	case USB_SPEED_HIGH:
		speed = EHCI_QH_SPEED_HIGH;
		break;
	default:
		panic("ehci_open: bad device speed %d", xfer->device->speed);
	}

	sqh = ehci_alloc_sqh(sc);
	if (sqh == NULL)
		return (ENOMEM);

	/* qh_link filled when the QH is added */
	sqh->qh.qh_endp = htole32(
	    EHCI_QH_SET_ADDR(xfer->device->address) |
	    EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
	    EHCI_QH_SET_EPS(speed) |
	    (xfertype == UE_CONTROL ? EHCI_QH_DTC : 0) |
	    EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
	    (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
	    EHCI_QH_CTL : 0) |
	    EHCI_QH_SET_NRL(8)
	);
	sqh->qh.qh_endphub = htole32(
	    EHCI_QH_SET_MULT(1) |
	    EHCI_QH_SET_HUBA(hshubaddr) |
	    EHCI_QH_SET_PORT(hshubport) |
	    EHCI_QH_SET_CMASK(0x1c) | /* XXX */
	    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0)
	);
	sqh->qh.qh_curqtd = htole32(EHCI_LINK_TERMINATE);

	/* Fill the overlay qTD */
	sqh->qh.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
	sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
	sqh->qh.qh_qtd.qtd_status =
	     htole32(EHCI_QTD_SET_TOGGLE(xfer->pipe->endpoint->savedtoggle));

	usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	ex->sqh = sqh;

	return (0);
d1625 2
d1630 1
a1630 2
ehci_insert_qh(struct ehci_softc *sc, struct usbd_xfer *xfer,
    struct ehci_soft_qtd *sqtd)
d1632 1
a1632 4
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
	usb_endpoint_descriptor_t *ed = xfer->pipe->endpoint->edesc;
	struct ehci_soft_qh *sqh = ex->sqh;
	int i, ival;
a1634 2
	SPLUSBCHECK;

a1661 17

	switch (UE_GET_XFERTYPE(ed->bmAttributes)) {
	case UE_CONTROL:
	case UE_BULK:
		ehci_add_qh(sqh, sc->sc_async_head);
		break;
	case UE_INTERRUPT:
		ival = xfer->pipe->interval;
		if (ival == USBD_DEFAULT_INTERVAL)
			ival = ed->bInterval;
		ehci_device_setintr(sc, sqh, ival);
		break;
	default:
		panic("wrong xfer type");
	}

	ehci_add_intr_list(sc, ex);
d2347 1
a2347 1
ehci_free_sqh(struct ehci_softc *sc, struct usbd_xfer *xfer)
a2348 1
	struct ehci_xfer *ex = (struct ehci_xfer *)xfer;
d2352 2
a2353 3
	ex->sqh->next = sc->sc_freeqhs;
	sc->sc_freeqhs = ex->sqh;
	ex->sqh = NULL;
d2405 1
a2405 1
int
a2430 1

d2545 1
a2545 1
	return (0);
d2549 2
a2550 1
	return (ENOMEM);
d2556 1
d2566 1
a2566 2
	ex->sqh->sqtd = NULL;
	ex->sqh = NULL;
d2643 6
d2652 1
d2654 2
a2655 2
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	usb_endpoint_descriptor_t *ed = pipe->endpoint->edesc;
d2657 6
a2662 6
	/* Root Hub */
	if (pipe->device->depth == 0)
		return;

	if (UE_GET_XFERTYPE(ed->bmAttributes) == UE_CONTROL)
		usb_freemem(&sc->sc_bus, &epipe->u.ctl.reqdma);
d2679 1
d2681 2
d2685 1
a2685 1
	DPRINTF(("ehci_abort_xfer: xfer=%p pipe=%p\n", xfer, xfer->pipe));
d2722 3
a2724 3
#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
a2727 1

d2730 1
a2730 1
	ehci_rem_qh(sc, ex->sqh);
d2732 25
a2756 1
	/* Issue a handshake to ensure we can free the tranfer's DMA memory. */
d2759 10
a2768 4
	usb_syncmem(&ex->sqh->dma, ex->sqh->offs, sizeof(ex->sqh->qh),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	xfer->pipe->endpoint->savedtoggle =
	    EHCI_QTD_GET_TOGGLE(letoh32(ex->sqh->qh.qh_qtd.qtd_status));
d2770 3
d2999 1
a3009 3
	if (ehci_setup_sqh(sc, xfer))
		return (USBD_NOMEM);

d3021 1
a3021 4
	KASSERT(EHCI_QH_GET_ADDR(letoh32(ex->sqh->qh.qh_endp)) ==
	    xfer->device->address);
	KASSERT(EHCI_QH_GET_MPL(letoh32(ex->sqh->qh.qh_endp)) ==
	    UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize));
d3027 2
a3028 2
		if (ehci_alloc_sqtd_chain(sc, len, xfer, &next, &end)) {
			err = USBD_NOMEM;
a3029 1
		}
d3076 1
a3076 1
		ehci_dump_sqh(ex->sqh);
d3084 3
d3090 1
a3090 2
	xfer->status = USBD_IN_PROGRESS;

d3092 1
a3092 1
	ehci_insert_qh(sc, xfer, setup);
d3098 2
d3109 1
a3109 1
		ehci_dump_sqh(ex->sqh);
a3121 1
	ehci_free_sqh(sc, xfer);
d3147 1
d3150 2
d3165 1
a3165 2
	if (ehci_setup_sqh(sc, xfer))
		return (USBD_NOMEM);
d3167 2
a3168 1
	if (ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend)) {
d3170 1
a3170 2
		ehci_free_sqh(sc, xfer);
		xfer->status = USBD_NOMEM;
d3172 1
a3172 1
		return (USBD_NOMEM);
d3178 1
a3178 1
		ehci_dump_sqh(ex->sqh);
d3187 3
a3192 2
	xfer->status = USBD_IN_PROGRESS;

d3194 1
a3194 1
	ehci_insert_qh(sc, xfer, data);
d3200 2
d3204 16
d3309 1
d3311 2
d3326 1
a3326 2
	if (ehci_setup_sqh(sc, xfer))
		return (USBD_NOMEM);
d3328 2
a3329 1
	if (ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend)) {
d3331 1
a3331 2
		ehci_free_sqh(sc, xfer);
		xfer->status = USBD_NOMEM;
d3333 1
a3333 1
		return (USBD_NOMEM);
d3339 1
a3339 1
		ehci_dump_sqh(ex->sqh);
a3352 2
	xfer->status = USBD_IN_PROGRESS;

d3354 1
a3354 1
	ehci_insert_qh(sc, xfer, data);
d3360 2
d3371 1
a3371 1
		ehci_dump_sqh(ex->sqh);
d3406 1
d3409 2
d3413 4
a3416 2
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex);	/* remove from active list */
d3418 1
d3422 1
a3422 1
	}
d3424 4
a3427 9
	if (xfer->pipe->repeat) {
		if (ehci_setup_sqh(sc, xfer)) {
			xfer->status = USBD_NOMEM;
			return;
		}

		if (ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data,
		     &dataend)) {
			xfer->status = USBD_NOMEM;
d3431 1
a3441 2
		xfer->status = USBD_IN_PROGRESS;

d3443 1
a3443 1
		ehci_insert_qh(sc, xfer, data);
d3450 8
@


1.166
log
@Since USB xfer pools are accessed in interrupt context, initialize them
with the correct ipl to prevent your CPU from locking against itself.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.165 2014/08/10 11:00:35 mpi Exp $ */
a84 1
	struct ehci_soft_qh *sqh;
d158 2
a159 1
void		ehci_free_sqh(struct ehci_softc *, struct ehci_soft_qh *);
d163 1
a163 1
usbd_status	ehci_alloc_sqtd_chain(struct ehci_softc *, u_int,
d181 2
a182 1
void		ehci_set_qh_qtd(struct ehci_soft_qh *, struct ehci_soft_qtd *);
a484 4
#if 0
 bad2:
	ehci_free_sqh(sc, sc->sc_async_head);
#endif
d721 6
a783 3
#ifdef EHCI_DEBUG
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
#endif
d813 1
a813 1
	DPRINTFN(/*10*/2, ("ehci_idone: xfer=%p, pipe=%p ready\n", xfer, epipe));
d901 1
d921 1
a921 1
			ehci_dump_sqh(epipe->sqh);
a1199 4
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;

	DPRINTF(("ehci_device_clear_toggle: epipe=%p status=0x%x\n",
	    epipe, epipe->sqh->qh.qh_qtd.qtd_status));
d1204 1
a1204 5
#ifdef DIAGNOSTIC
	if ((epipe->sqh->qh.qh_qtd.qtd_status & htole32(EHCI_QTD_ACTIVE)) != 0)
		panic("ehci_device_clear_toggle: queue active");
#endif
	epipe->sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE_MASK);
d1406 2
a1407 2
	struct usbd_device *dev = pipe->device;
	struct ehci_softc *sc = (struct ehci_softc *)dev->bus;
d1409 1
a1409 4
	u_int8_t addr = dev->address;
	u_int8_t xfertype = ed->bmAttributes & UE_XFERTYPE;
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	struct ehci_soft_qh *sqh;
a1410 3
	int s;
	int ival, speed, naks;
	int hshubaddr, hshubport;
d1413 1
a1413 1
	    pipe, addr, ed->bEndpointAddress));
a1417 8
	if (dev->myhsport) {
		hshubaddr = dev->myhsport->parent->address;
		hshubport = dev->myhsport->portno;
	} else {
		hshubaddr = 0;
		hshubport = 0;
	}

a1432 64
	/* XXX All this stuff is only valid for async. */
	switch (dev->speed) {
	case USB_SPEED_LOW:
		speed = EHCI_QH_SPEED_LOW;
		break;
	case USB_SPEED_FULL:
		speed = EHCI_QH_SPEED_FULL;
		break;
	case USB_SPEED_HIGH:
		speed = EHCI_QH_SPEED_HIGH;
		break;
	default:
		panic("ehci_open: bad device speed %d", dev->speed);
	}
	if (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_ISOCHRONOUS) {
		printf("%s: Error opening low/full speed isoc endpoint.\n"
		    "A low/full speed device is attached to a USB2 hub, and "
		    "transaction translations are not yet supported.\n"
		    "Reattach the device to the root hub instead.\n",
		    sc->sc_bus.bdev.dv_xname);
		DPRINTFN(1,("ehci_open: hshubaddr=%d hshubport=%d\n",
		    hshubaddr, hshubport));
		return (USBD_INVAL);
	}

	naks = 8;		/* XXX */

	/* Allocate sqh for everything, save isoc xfers */
	if (xfertype != UE_ISOCHRONOUS) {
		sqh = ehci_alloc_sqh(sc);
		if (sqh == NULL)
			return (USBD_NOMEM);
		/* qh_link filled when the QH is added */
		sqh->qh.qh_endp = htole32(
		    EHCI_QH_SET_ADDR(addr) |
		    EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
		    EHCI_QH_SET_EPS(speed) |
		    (xfertype == UE_CONTROL ? EHCI_QH_DTC : 0) |
		    EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
		    (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
		    EHCI_QH_CTL : 0) |
		    EHCI_QH_SET_NRL(naks)
		    );
		sqh->qh.qh_endphub = htole32(
		    EHCI_QH_SET_MULT(1) |
		    EHCI_QH_SET_HUBA(hshubaddr) |
		    EHCI_QH_SET_PORT(hshubport) |
		    EHCI_QH_SET_CMASK(0x1c) | /* XXX */
		    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0)
		    );
		sqh->qh.qh_curqtd = htole32(EHCI_LINK_TERMINATE);
		/* Fill the overlay qTD */
		sqh->qh.qh_qtd.qtd_next = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_altnext = htole32(EHCI_LINK_TERMINATE);
		sqh->qh.qh_qtd.qtd_status =
		    htole32(EHCI_QTD_SET_TOGGLE(pipe->endpoint->savedtoggle));

		usb_syncmem(&sqh->dma, sqh->offs, sizeof(sqh->qh),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
		epipe->sqh = sqh;
	} else {
		sqh = NULL;
	} /*xfertype == UE_ISOC*/

a1436 4
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_open: usb_allocmem()=%d\n", err);
#endif
d1438 1
a1438 1
			goto bad;
a1439 3
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
a1442 3
		s = splusb();
		ehci_add_qh(sqh, sc->sc_async_head);
		splx(s);
d1446 1
a1446 7
		ival = pipe->interval;
		if (ival == USBD_DEFAULT_INTERVAL)
			ival = ed->bInterval;
		s = splusb();
		err = ehci_device_setintr(sc, sqh, ival);
		splx(s);
		return (err);
d1448 6
a1453 1
		pipe->methods = &ehci_device_isoc_methods;
d1456 1
a1456 2
			err = USBD_INVAL;
			goto bad;
d1460 1
a1460 2
			err = USBD_INVAL;
			goto bad;
d1464 1
d1470 1
d1472 19
d1492 50
a1541 4
bad:
	if (sqh != NULL)
		ehci_free_sqh(sc, sqh);
	return (err);
a1593 2

	ehci_sync_hc(sc);
d1597 2
a1598 1
ehci_set_qh_qtd(struct ehci_soft_qh *sqh, struct ehci_soft_qtd *sqtd)
d1600 4
a1603 1
	int i;
d1606 2
d1635 17
d2337 1
a2337 1
ehci_free_sqh(struct ehci_softc *sc, struct ehci_soft_qh *sqh)
d2339 1
d2343 3
a2345 2
	sqh->next = sc->sc_freeqhs;
	sc->sc_freeqhs = sqh;
d2397 1
a2397 1
usbd_status
d2423 1
d2538 1
a2538 1
	return (USBD_NORMAL_COMPLETION);
d2542 1
a2542 2
	DPRINTFN(-1,("ehci_alloc_sqtd_chain: no memory\n"));
	return (USBD_NOMEM);
a2547 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)ex->xfer.pipe;
d2557 2
a2558 1
	epipe->sqh->sqtd = NULL;
a2634 6
/****************/

/*
 * Close a reqular pipe.
 * Assumes that there are no pending transactions.
 */
d2638 1
d2640 5
a2644 3
	struct ehci_softc *sc = (struct ehci_softc *)pipe->device->bus;
	struct ehci_soft_qh *sqh = epipe->sqh;
	int s;
d2646 2
a2647 6
	s = splusb();
	ehci_rem_qh(sc, sqh);
	splx(s);
	pipe->endpoint->savedtoggle =
	    EHCI_QTD_GET_TOGGLE(letoh32(sqh->qh.qh_qtd.qtd_status));
	ehci_free_sqh(sc, epipe->sqh);
a2663 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
a2664 2
	struct ehci_soft_qh *sqh = epipe->sqh;
	struct ehci_soft_qtd *sqtd;
d2667 1
a2667 1
	DPRINTF(("ehci_abort_xfer: xfer=%p pipe=%p\n", xfer, epipe));
d2704 3
a2706 3
	/*
	 * Step 1: Make interrupt routine and timeouts ignore xfer.
	 */
d2710 1
d2713 1
a2713 1
	splx(s);
d2715 1
a2715 25
	/*
	 * Step 2: Deactivate all of the qTDs that we will be removing,
	 * otherwise the queue head may go active again.
	 */
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	sqh->qh.qh_qtd.qtd_status = htole32(EHCI_QTD_HALTED);
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(struct ehci_qh, qh_qtd.qtd_status),
	    sizeof(sqh->qh.qh_qtd.qtd_status),
	    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);

	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
		sqtd->qtd.qtd_status = htole32(EHCI_QTD_HALTED);
		usb_syncmem(&sqtd->dma,
		    sqtd->offs + offsetof(struct ehci_qtd, qtd_status),
		    sizeof(sqtd->qtd.qtd_status),
		    BUS_DMASYNC_PREWRITE | BUS_DMASYNC_PREREAD);
	}
d2718 4
a2721 10
	/*
	 * Step 3: Make sure the soft interrupt routine has run. This
	 * should remove any completed items off the queue.
	 * The hardware has no reference to completed items (TDs).
	 * It's safe to remove them at any time.
	 */
	s = splusb();
	sc->sc_softwake = 1;
	usb_schedsoftintr(&sc->sc_bus);
	tsleep(&sc->sc_softwake, PZERO, "ehciab", 0);
a2722 3
#ifdef DIAGNOSTIC
	ex->isdone = 1;
#endif
a2948 1
	struct ehci_soft_qh *sqh;
d2959 3
d2973 4
a2976 1
	sqh = epipe->sqh;
d2982 2
a2983 2
		err = ehci_alloc_sqtd_chain(sc, len, xfer, &next, &end);
		if (err)
d2985 1
d3032 1
a3032 1
		ehci_dump_sqh(sqh);
a3039 3
	if (!ex->isdone) {
		printf("ehci_device_request: not done, ex=%p\n", ex);
	}
d3043 2
a3044 1
	/* Insert qTD in QH list. */
d3046 1
a3046 1
	ehci_set_qh_qtd(sqh, setup);
a3051 2
	ehci_add_intr_list(sc, ex);
	xfer->status = USBD_IN_PROGRESS;
d3061 1
a3061 1
		ehci_dump_sqh(sqh);
d3074 1
a3099 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
a3101 2
	struct ehci_soft_qh *sqh;
	usbd_status err;
d3115 2
a3116 1
	sqh = epipe->sqh;
d3118 1
a3118 2
	err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
	if (err) {
d3120 2
a3121 1
		xfer->status = err;
d3123 1
a3123 1
		return (err);
d3129 1
a3129 1
		ehci_dump_sqh(sqh);
a3137 3
	if (!ex->isdone) {
		printf("ehci_device_bulk_start: not done, ex=%p\n", ex);
	}
d3141 2
d3144 1
a3144 1
	ehci_set_qh_qtd(sqh, data);
a3149 2
	ehci_add_intr_list(sc, ex);
	xfer->status = USBD_IN_PROGRESS;
a3151 16
#ifdef EHCI_DEBUG
	if (ehcidebug > 10) {
		DPRINTF(("ehci_device_bulk_start: data(2)\n"));
		delay(10000);
		DPRINTF(("ehci_device_bulk_start: data(3)\n"));
		ehci_dump_regs(sc);
#if 0
		printf("async_head:\n");
		ehci_dump_sqh(sc->sc_async_head);
#endif
		printf("sqh:\n");
		ehci_dump_sqh(sqh);
		ehci_dump_sqtds(data);
	}
#endif

a3240 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
a3241 2
	struct ehci_soft_qh *sqh;
	usbd_status err;
d3255 2
a3256 1
	sqh = epipe->sqh;
d3258 1
a3258 2
	err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
	if (err) {
d3260 2
a3261 1
		xfer->status = err;
d3263 1
a3263 1
		return (err);
d3269 1
a3269 1
		ehci_dump_sqh(sqh);
d3283 2
d3286 1
a3286 1
	ehci_set_qh_qtd(sqh, data);
a3291 2
	ehci_add_intr_list(sc, ex);
	xfer->status = USBD_IN_PROGRESS;
d3301 1
a3301 1
		ehci_dump_sqh(sqh);
a3335 1
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
a3337 2
	struct ehci_soft_qh *sqh;
	usbd_status err;
d3340 2
a3341 4
	DPRINTFN(10, ("ehci_device_intr_done: xfer=%p, actlen=%d\n",
	    xfer, xfer->actlen));

	if (xfer->pipe->repeat) {
a3342 1

d3346 7
a3352 1
		sqh = epipe->sqh;
d3354 3
a3356 4
		err = ehci_alloc_sqtd_chain(sc, xfer->length, xfer, &data, &dataend);
		if (err) {
			DPRINTFN(-1, ("ehci_device_intr_done: no memory\n"));
			xfer->status = err;
a3359 1
		/* Set up interrupt info. */
d3370 2
d3373 1
a3373 1
		ehci_set_qh_qtd(sqh, data);
a3379 8

		xfer->status = USBD_IN_PROGRESS;
	} else if (xfer->status != USBD_NOMEM && ehci_active_intr_list(ex)) {
		ehci_del_intr_list(sc, ex); /* remove from active list */
		ehci_free_sqtd_chain(sc, ex);
		usb_syncmem(&xfer->dmabuf, 0, xfer->length,
		    usbd_xfer_isread(xfer) ?
		    BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
@


1.165
log
@Set and check for XFER_BUSY in the common methods instead of doing it
in every HC driver.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.164 2014/08/05 20:26:15 mpi Exp $ */
d337 1
@


1.164
log
@Only check if the abort transfer is the interrupt one if the pipe is
opened with a callback.

If a driver opens an interrupt pipe without callback function, like
umct(4) does with one of its bulk in endpoints being reported as an
interrupt endpoint, then we can end up aborting a transfer which is
different from the interrupt one.

Issue reported by Roberto E. Vargas Caballero, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.163 2014/08/03 14:30:28 jsg Exp $ */
d1175 1
a1175 1
	if (ex != NULL) {
a1176 2
		ex->xfer.busy_free = XFER_BUSY;
	}
a1186 5
	if (xfer->busy_free != XFER_BUSY) {
		printf("%s: xfer=%p not busy, 0x%08x\n", __func__, xfer,
		    xfer->busy_free);
		return;
	}
@


1.163
log
@don't return unitialised memory on error in ehci_alloc_sqtd()

It seems mpi introduced a problem into ehci.c rev 1.162
two weeks ago.  An error check that used to return NULL
now jumps to the end of the function, but sqtd isn't
initialised at that point.

ok miod@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.162 2014/07/12 20:13:48 mpi Exp $ */
d3391 1
a3391 1
	KASSERT(xfer->pipe->intrxfer == xfer);
@


1.162
log
@Protect the freelists of transfer descriptors with the appropriate spl
so that we do not end up allocating two times new descriptors.

This happens if a thread finds an empty list, start allocating, got
interrupted and the interrupt also finds an empty list.

Fix an issue reported by Nils Frohberg.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.161 2014/07/12 08:21:10 mpi Exp $ */
d2366 1
a2366 1
	struct ehci_soft_qtd *sqtd;
@


1.161
log
@Use the correct poll interval for HS root hub before it gets copied, no
real impact since this descriptor is not used in the kernel. From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.160 2014/07/10 20:57:40 mpi Exp $ */
a59 1
#include <dev/usb/usb_quirks.h>
d2318 1
a2318 1
	struct ehci_soft_qh *sqh;
d2322 1
d2324 1
a2328 4
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_alloc_sqh: usb_allocmem()=%d\n", err);
#endif
d2330 2
a2331 2
			return (NULL);
		for(i = 0; i < EHCI_SQH_CHUNK; i++) {
d2346 3
d2355 3
d2360 1
d2372 1
a2376 4
#ifdef EHCI_DEBUG
		if (err)
			printf("ehci_alloc_sqtd: usb_allocmem()=%d\n", err);
#endif
d2378 1
a2378 2
			return (NULL);
		s = splusb();
a2387 1
		splx(s);
a2389 1
	s = splusb();
d2394 2
a2396 1

@


1.160
log
@Do not set the bus dying flag during DVACT_DEACTIVATE otherwise the
explore thread will not disconnect the root hub.  The flag will be
set before detaching the children, like it is done during a suspend-
resume cycle.

Fix a panic when unplugging a cardbus *hci(4).
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.159 2014/07/09 15:47:54 mpi Exp $ */
d1824 1
a1824 1
	255
@


1.159
log
@Adds an optional bus function to set the address of a new device and
explicitly set it when required.

Right now xhci(4) does not need such function because it assigns
addresses when the first pipe of a device is opened.

ok yuo@@, pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.158 2014/06/04 13:52:30 mpi Exp $ */
a1122 4
		break;
	case DVACT_DEACTIVATE:
		rv = config_activate_children(self, act);
		sc->sc_bus.dying = 1;
@


1.158
log
@Clearing the data toggle bit only makes sense for endpoints that use it,
since this function is optional get rid of the no-op ones.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.157 2014/06/04 12:28:21 mpi Exp $ */
d219 1
@


1.157
log
@Use C99 initializers for pipe and bus methods.

Apart from improving readability, this will help us reduce the number of
no-op functions now that some of them are optional.

ok ratchov@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.156 2014/05/30 13:24:59 mpi Exp $ */
a154 1
void		ehci_noop(struct usbd_pipe *pipe);
a229 1
	.cleartoggle = ehci_noop,
a237 1
	.cleartoggle = ehci_noop,
a245 1
	.cleartoggle = ehci_noop,
a271 1
	.cleartoggle = ehci_noop,
a1221 5
}

void
ehci_noop(struct usbd_pipe *pipe)
{
@


1.156
log
@Remove unused fields from the pipes.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.155 2014/05/16 19:00:18 mpi Exp $ */
d219 5
a223 5
	ehci_open,
	ehci_softintr,
	ehci_poll,
	ehci_allocx,
	ehci_freex,
d227 6
a232 6
	ehci_root_ctrl_transfer,
	ehci_root_ctrl_start,
	ehci_root_ctrl_abort,
	ehci_root_ctrl_close,
	ehci_noop,
	ehci_root_ctrl_done,
d236 6
a241 6
	ehci_root_intr_transfer,
	ehci_root_intr_start,
	ehci_root_intr_abort,
	ehci_root_intr_close,
	ehci_noop,
	ehci_root_intr_done,
d245 6
a250 6
	ehci_device_ctrl_transfer,
	ehci_device_ctrl_start,
	ehci_device_ctrl_abort,
	ehci_device_ctrl_close,
	ehci_noop,
	ehci_device_ctrl_done,
d254 6
a259 6
	ehci_device_intr_transfer,
	ehci_device_intr_start,
	ehci_device_intr_abort,
	ehci_device_intr_close,
	ehci_device_clear_toggle,
	ehci_device_intr_done,
d263 6
a268 6
	ehci_device_bulk_transfer,
	ehci_device_bulk_start,
	ehci_device_bulk_abort,
	ehci_device_bulk_close,
	ehci_device_clear_toggle,
	ehci_device_bulk_done,
d272 6
a277 6
	ehci_device_isoc_transfer,
	ehci_device_isoc_start,
	ehci_device_isoc_abort,
	ehci_device_isoc_close,
	ehci_noop,
	ehci_device_isoc_done,
@


1.155
log
@Reduce the difference between HC drivers by always passing a generic
usbd_xfer pointer to the routines processing finished transfers to make
it crystal clear that the timeout and abort logic is the same everywhere.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.154 2014/05/16 18:17:03 mpi Exp $ */
a87 4
		struct ehci_soft_qtd *qtd;
		/* struct ehci_soft_itd *itd; */
	} tail;
	union {
a90 2
			u_int length;
			/* struct ehci_soft_qtd *setup, *data, *stat; */
a91 8
		/* Interrupt pipe */
		struct {
			u_int length;
		} intr;
		/* Bulk pipe */
		struct {
			u_int length;
		} bulk;
a3041 1
	epipe->u.ctl.length = len;
a3186 2
	epipe->u.bulk.length = xfer->length;

a3347 2
	epipe->u.intr.length = xfer->length;

a3438 1
		xfer->length = epipe->u.intr.length;
@


1.154
log
@There is no need to remember which usb(4) device is the child of an USB
host controller because autoconf(9) already does it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.153 2014/05/09 11:01:06 mpi Exp $ */
d121 4
a124 4
void		ehci_check_intr(struct ehci_softc *, struct ehci_xfer *);
void		ehci_check_qh_intr(struct ehci_softc *, struct ehci_xfer *);
void		ehci_check_itd_intr(struct ehci_softc *, struct ehci_xfer *);
void		ehci_idone(struct ehci_xfer *);
d648 1
a648 1
		ehci_check_intr(sc, ex);
d667 1
a667 1
ehci_check_intr(struct ehci_softc *sc, struct ehci_xfer *ex)
d671 1
a671 1
	DPRINTFN(/*15*/2, ("ehci_check_intr: ex=%p\n", ex));
d673 1
a673 1
	attr = ex->xfer.pipe->endpoint->edesc->bmAttributes;
d675 1
a675 1
		ehci_check_itd_intr(sc, ex);
d677 1
a677 1
		ehci_check_qh_intr(sc, ex);
d683 1
a683 1
ehci_check_qh_intr(struct ehci_softc *sc, struct ehci_xfer *ex)
d685 1
d687 1
a687 1
	__uint32_t status;
d740 3
a742 3
	timeout_del(&ex->xfer.timeout_handle);
	usb_rem_task(ex->xfer.pipe->device, &ex->xfer.abort_task);
	ehci_idone(ex);
d746 3
a748 1
ehci_check_itd_intr(struct ehci_softc *sc, struct ehci_xfer *ex) {
d752 1
a752 1
	if (&ex->xfer != SIMPLEQ_FIRST(&ex->xfer.pipe->queue))
d790 3
a792 3
	timeout_del(&ex->xfer.timeout_handle);
	usb_rem_task(ex->xfer.pipe->device, &ex->xfer.abort_task);
	ehci_idone(ex);
d796 1
a796 1
ehci_idone(struct ehci_xfer *ex)
d798 1
a798 1
	struct usbd_xfer *xfer = &ex->xfer;
@


1.153
log
@Plug an xfer leak when detaching root hubs.

This leak is similar to the public xfer leak #1 that was affecting
device interrupt pipes except that root hubs are rarely detached.

Note that this xfer is never associated to any TD and is just used
to indicate that some of the HC ports has changed status, so there
is no need to flag it as "done" before completing it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.152 2014/05/08 14:00:52 mpi Exp $ */
d1009 1
a1009 1
ehci_detach(struct ehci_softc *sc, int flags)
d1011 2
a1012 4
	int rv = 0;

	if (sc->sc_child != NULL)
		rv = config_detach(sc->sc_child, flags);
d1014 1
d1140 1
a1140 2
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
@


1.152
log
@Plug one more xfer leak.

Now that aborting interrupt pipes does not prevent us from freeing
the associated xfer, make sure to flag this xfer as "done" even if
there's no need to abort it in hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.151 2014/05/04 14:42:36 mpi Exp $ */
d2308 1
a2308 2
	struct usbd_pipe *pipe = xfer->pipe;
	struct ehci_softc *sc = (struct ehci_softc *)pipe->device->bus;
a2317 1
/* Abort a root interrupt request. */
d2321 1
d2324 2
a2325 4
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTF(("ehci_root_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
a2331 1
/* Close the root pipe. */
a2334 5
	struct ehci_softc *sc = (struct ehci_softc *)pipe->device->bus;

	DPRINTF(("ehci_root_intr_close\n"));

	sc->sc_intrxfer = NULL;
a2340 2

/************************/
@


1.151
log
@Make use of usbd_xfer_isread() instead of rerolling it everywhere.

This has the side effect of simplifying and reducing the differences
between the various *hci_alloc_*_chain() functions since they are the
principal place where we want to known if the transfer is a read or a
write.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.150 2014/05/04 14:31:50 mpi Exp $ */
d2737 3
@


1.150
log
@Get rid of EHCI_NULL.  No functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.149 2014/04/29 14:11:23 mpi Exp $ */
d179 2
a180 3
usbd_status	ehci_alloc_sqtd_chain(struct ehci_pipe *,
		    struct ehci_softc *, u_int, int, struct usbd_xfer *,
		    struct ehci_soft_qtd **, struct ehci_soft_qtd **);
d2450 2
a2451 3
ehci_alloc_sqtd_chain(struct ehci_pipe *epipe, struct ehci_softc *sc,
    u_int alen, int rd, struct usbd_xfer *xfer, struct ehci_soft_qtd **sp,
    struct ehci_soft_qtd **ep)
d2458 1
d3041 1
a3041 2
	int isread;
	u_int len;
a3044 3
	isread = req->bmRequestType & UT_READ;
	len = UGETW(req->wLength);

d3048 1
a3048 1
	    UGETW(req->wIndex), len, xfer->device->address,
d3069 1
a3069 2
		err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer,
			  &next, &end);
d3102 2
a3103 1
	    EHCI_QTD_SET_PID(isread ? EHCI_QTD_PID_OUT : EHCI_QTD_PID_IN) |
a3193 2
	u_int len;
	int isread, endpt;
a3206 3
	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d3209 1
a3209 1
	epipe->u.bulk.length = len;
d3211 1
a3211 2
	err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer, &data,
	    &dataend);
a3291 2
	int endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	int rd = UE_GET_DIR(endpt) == UE_DIR_IN;
d3300 2
a3301 1
		    rd ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
a3356 2
	u_int len;
	int isread, endpt;
a3369 3
	len = xfer->length;
	endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
	isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d3372 1
a3372 1
	epipe->u.intr.length = len;
d3374 1
a3374 2
	err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer, &data,
	    &dataend);
d3457 1
a3457 2
	u_int len;
	int isread, endpt, s;
d3465 4
a3468 6
		len = epipe->u.intr.length;
		xfer->length = len;
		endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
		isread = UE_GET_DIR(endpt) == UE_DIR_IN;
		usb_syncmem(&xfer->dmabuf, 0, len,
		    isread ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
d3471 1
a3471 2
		err = ehci_alloc_sqtd_chain(epipe, sc, len, isread, xfer,
		    &data, &dataend);
a3501 2
		endpt = xfer->pipe->endpoint->edesc->bEndpointAddress;
		isread = UE_GET_DIR(endpt) == UE_DIR_IN;
d3503 2
a3504 1
		    isread ? BUS_DMASYNC_POSTREAD : BUS_DMASYNC_POSTWRITE);
@


1.149
log
@Finally plug the public xfer leak #1 in our USB stack.

Every call to usbd_abort_pipe() on an interrupt pipe would simply
reset the intrxfer pointer, which would prevent usbd_close_pipe()
to free it.  Since we abort pipes in a lot of situations: when a
device is detached, when a USB-to-serial adapter is closed, when
an error occurs, when the machine is suspended, etc, this would
result in hundreds of leaked xfers in most of my machines.

xhci(4) is not affected, but you can't enable it right now since
the stack is not ready :)

While here put a KASSERT() to make sure drivers are only calling
the interrupt abort method for intrxfer, if that's not the case,
please let met know.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.148 2014/04/29 12:45:29 mpi Exp $ */
a221 2
#define EHCI_NULL htole32(EHCI_LINK_TERMINATE)

d381 1
a381 1
		sc->sc_flist[i] = EHCI_NULL;
d414 1
a414 1
			sqh->qh.qh_link = EHCI_NULL;
d424 3
a426 3
		sqh->qh.qh_curqtd = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
d452 1
a452 1
	sqh->qh.qh_curqtd = EHCI_NULL;
d456 2
a457 2
	sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
d910 1
a910 1
		if (sqtd->qtd.qtd_next == EHCI_NULL &&
d1538 1
a1538 1
		sqh->qh.qh_curqtd = EHCI_NULL;
d1540 2
a1541 2
		sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
		sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
d1684 1
a1684 1
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
d2538 1
a2538 1
			nextphys = EHCI_NULL;
d3115 1
a3115 1
	stat->qtd.qtd_next = stat->qtd.qtd_altnext = EHCI_NULL;
d3766 2
a3767 2
			 * or EHCI_NULL? */
			itd->itd.itd_next = htole32(EHCI_NULL);
@


1.148
log
@Get rid of the per-softc freelist of transfer descriptors and use a
per-driver pool(9) instead.

With inputs from mikeb@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.147 2014/04/27 14:48:10 mpi Exp $ */
d3451 2
a3452 5
	DPRINTFN(1, ("ehci_device_intr_abort: xfer=%p\n", xfer));
	if (xfer->pipe->intrxfer == xfer) {
		DPRINTFN(1, ("ehci_device_intr_abort: remove\n"));
		xfer->pipe->intrxfer = NULL;
	}
@


1.147
log
@Start de-obfuscating the HC drivers.

Since pipe methods have an xfer argument, always use it to get acces to
various data structure (pipe, bus, device) instead of having a different
way to get a pointer to these descriptors in every function.

Also kill the {E,U}XFER() macro and use a consistent name accross all the
methods for {e,u}hci_xfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.146 2014/03/25 20:27:37 mpi Exp $ */
a48 1
#include <sys/selinfo.h>
d51 1
d81 2
d350 11
d1196 1
a1196 2
	struct ehci_softc *sc = (struct ehci_softc *)bus;
	struct usbd_xfer *xfer;
d1198 1
a1198 3
	xfer = SIMPLEQ_FIRST(&sc->sc_free_xfers);
	if (xfer != NULL) {
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, next);
d1200 4
a1203 3
		if (xfer->busy_free != XFER_FREE)
			printf("ehci_allocx: xfer=%p not free, 0x%08x\n",
			    xfer, xfer->busy_free);
d1205 1
a1205 12
	} else
		xfer = malloc(sizeof(struct ehci_xfer), M_USB, M_NOWAIT);

	if (xfer != NULL) {
		memset(xfer, 0, sizeof(struct ehci_xfer));
		((struct ehci_xfer *)xfer)->ehci_xfer_flags = 0;
#ifdef DIAGNOSTIC
		((struct ehci_xfer *)xfer)->isdone = 1;
		xfer->busy_free = XFER_BUSY;
#endif
	}
	return (xfer);
d1211 1
a1211 1
	struct ehci_softc *sc = (struct ehci_softc *)bus;
d1215 1
a1215 1
		printf("ehci_freex: xfer=%p not busy, 0x%08x\n", xfer,
d1219 2
a1220 3
	xfer->busy_free = XFER_FREE;
	if (!((struct ehci_xfer *)xfer)->isdone) {
		printf("ehci_freex: !isdone\n");
d1224 1
a1224 1
	SIMPLEQ_INSERT_HEAD(&sc->sc_free_xfers, xfer, next);
@


1.146
log
@Instead of matching root hubs with a custom address, that only works
because USB_START_ADDR is defined to 0 and the softc is M_ZERO'd,
assume that root hubs are the only devices with a depth of 0.

Root hubs can now happily be detached and reattached.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.145 2014/03/15 09:49:28 mpi Exp $ */
d180 1
a180 2
void		ehci_free_sqtd_chain(struct ehci_softc *,
		    struct ehci_xfer *exfer);
d185 1
a185 1
		    struct ehci_xfer *exfer);
d1199 1
a1199 1
		EXFER(xfer)->ehci_xfer_flags = 0;
d1201 1
a1201 1
		EXFER(xfer)->isdone = 1;
d1220 1
a1220 1
	if (!EXFER(xfer)->isdone) {
d1744 1
a1744 1
ehci_rem_free_itd_chain(struct ehci_softc *sc, struct ehci_xfer *exfer)
d1750 1
a1750 1
	if (exfer->itdstart == NULL || exfer->itdend == NULL)
d1753 1
a1753 1
	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
d1782 1
a1782 1
	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
d1789 2
a1790 2
	exfer->itdstart = NULL;
	exfer->itdend = NULL;
d2468 1
a2468 1
	iscontrol = (epipe->pipe.endpoint->edesc->bmAttributes & UE_XFERTYPE) ==
d2476 1
a2476 1
	mps = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
d2726 1
a2726 1
#define exfer EXFER(xfer)
d2728 1
a2728 1
	struct ehci_softc *sc = (struct ehci_softc *)epipe->pipe.device->bus;
d2740 1
a2740 1
		usb_rem_task(epipe->pipe.device, &xfer->abort_task);
d2753 1
a2753 1
	if (exfer->ehci_xfer_flags & EHCI_XFER_ABORTING) {
d2761 3
a2763 3
		exfer->ehci_xfer_flags |= EHCI_XFER_ABORTWAIT;
		while (exfer->ehci_xfer_flags & EHCI_XFER_ABORTING)
			tsleep(&exfer->ehci_xfer_flags, PZERO, "ehciaw", 0);
d2771 1
a2771 1
	exfer->ehci_xfer_flags |= EHCI_XFER_ABORTING;
d2774 1
a2774 1
	usb_rem_task(epipe->pipe.device, &xfer->abort_task);
d2791 1
a2791 1
	for (sqtd = exfer->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
d2816 1
a2816 1
	exfer->isdone = 1;
d2819 4
a2822 4
	exfer->ehci_xfer_flags &= ~EHCI_XFER_ABORTING;
	if (exfer->ehci_xfer_flags & EHCI_XFER_ABORTWAIT) {
		exfer->ehci_xfer_flags &= ~EHCI_XFER_ABORTWAIT;
		wakeup(&exfer->ehci_xfer_flags);
a2826 1
#undef exfer
d2832 2
a2834 3
	struct ehci_pipe *epipe;
	struct ehci_xfer *exfer;
	struct ehci_softc *sc;
a2837 3
	epipe = (struct ehci_pipe *) xfer->pipe;
	exfer = EXFER(xfer);
	sc = (struct ehci_softc *)epipe->pipe.device->bus;
d2839 1
a2839 1
	DPRINTF(("ehci_abort_isoc_xfer: xfer %p pipe %p\n", xfer, epipe));
d2845 1
a2845 1
		usb_rem_task(epipe->pipe.device, &xfer->abort_task);
d2851 1
a2851 1
	if (exfer->ehci_xfer_flags & EHCI_XFER_ABORTING) {
d2861 3
a2863 3
		exfer->ehci_xfer_flags |= EHCI_XFER_ABORTING;
		while (exfer->ehci_xfer_flags & EHCI_XFER_ABORTING)
			tsleep(&exfer->ehci_xfer_flags, PZERO, "ehciiaw", 0);
d2866 1
a2866 1
	exfer->ehci_xfer_flags |= EHCI_XFER_ABORTING;
d2870 1
a2870 1
	usb_rem_task(epipe->pipe.device, &xfer->abort_task);
d2873 1
a2873 1
	for (itd = exfer->itdstart; itd != NULL; itd = itd->xfer_next) {
d2889 1
a2889 1
	exfer->isdone = 1;
d2891 2
a2892 2
	wake = exfer->ehci_xfer_flags & EHCI_XFER_ABORTING;
	exfer->ehci_xfer_flags &= ~(EHCI_XFER_ABORTING | EHCI_XFER_ABORTWAIT);
d2895 1
a2895 1
		wakeup(&exfer->ehci_xfer_flags);
a3000 1
	struct ehci_xfer *ex = EXFER(xfer);
d3002 1
a3002 1
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;*/
d3039 1
a3039 1
#define exfer EXFER(xfer)
d3041 1
a3042 2
	struct usbd_device *dev = epipe->pipe.device;
	struct ehci_softc *sc = (struct ehci_softc *)dev->bus;
d3056 2
a3057 2
	    UGETW(req->wIndex), len, dev->address,
	    epipe->pipe.endpoint->edesc->bEndpointAddress));
d3131 2
a3132 2
	exfer->sqtdstart = setup;
	exfer->sqtdend = stat;
d3134 2
a3135 2
	if (!exfer->isdone) {
		printf("ehci_device_request: not done, exfer=%p\n", exfer);
d3137 1
a3137 1
	exfer->isdone = 0;
d3148 1
a3148 1
	ehci_add_intr_list(sc, exfer);
a3174 1
#undef exfer
d3196 1
a3196 1
#define exfer EXFER(xfer)
d3198 1
a3198 2
	struct usbd_device *dev = epipe->pipe.device;
	struct ehci_softc *sc = (struct ehci_softc *)dev->bus;
d3218 1
a3218 1
	endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
d3242 2
a3243 2
	exfer->sqtdstart = data;
	exfer->sqtdend = dataend;
d3245 2
a3246 2
	if (!exfer->isdone) {
		printf("ehci_device_bulk_start: not done, ex=%p\n", exfer);
d3248 1
a3248 1
	exfer->isdone = 0;
d3258 1
a3258 1
	ehci_add_intr_list(sc, exfer);
a3281 1
#undef exfer
a3303 1
	struct ehci_xfer *ex = EXFER(xfer);
d3305 2
a3306 2
	struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;
	int endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
d3366 2
a3367 1
#define exfer EXFER(xfer)
a3368 2
	struct usbd_device *dev = xfer->device;
	struct ehci_softc *sc = (struct ehci_softc *)dev->bus;
d3388 1
a3388 1
	endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
d3412 2
a3413 2
	exfer->sqtdstart = data;
	exfer->sqtdend = dataend;
d3415 3
a3417 3
	if (!exfer->isdone)
		printf("ehci_device_intr_start: not done, ex=%p\n", exfer);
	exfer->isdone = 0;
d3427 1
a3427 1
	ehci_add_intr_list(sc, exfer);
a3446 1
#undef exfer
a3474 2
#define exfer EXFER(xfer)
	struct ehci_xfer *ex = EXFER(xfer);
d3477 1
d3492 1
a3492 1
		endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
d3507 2
a3508 2
		exfer->sqtdstart = data;
		exfer->sqtdend = dataend;
d3510 1
a3510 1
		if (!exfer->isdone) {
d3512 1
a3512 1
			    exfer);
d3514 1
a3514 1
		exfer->isdone = 0;
d3530 1
a3530 1
		endpt = epipe->pipe.endpoint->edesc->bEndpointAddress;
a3534 1
#undef exfer
d3554 3
a3556 3
	struct ehci_pipe *epipe;
	struct ehci_softc *sc;
	struct ehci_xfer *exfer;
a3566 3
	exfer = (struct ehci_xfer *) xfer;
	sc = (struct ehci_softc *)xfer->device->bus;
	epipe = (struct ehci_pipe *)xfer->pipe;
d3575 1
a3575 1
	if (exfer->itdstart != NULL)
d3589 1
a3589 1
	if ((1 << (epipe->pipe.endpoint->edesc->bInterval - 1)) *
d3600 3
a3602 3
	if (!exfer->isdone)
		printf("ehci_device_isoc_start: not done, ex = %p\n", exfer);
	exfer->isdone = 0;
d3611 1
a3611 1
	i = epipe->pipe.endpoint->edesc->bInterval;
d3715 1
a3715 1
		k = epipe->pipe.endpoint->edesc->bEndpointAddress;
d3718 1
a3718 1
		    EHCI_ITD_SET_DADDR(epipe->pipe.device->address));
d3720 1
a3720 1
		k = (UE_GET_DIR(epipe->pipe.endpoint->edesc->bEndpointAddress))
d3722 1
a3722 1
		j = UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
d3757 1
a3757 1
	i = (1 << (epipe->pipe.endpoint->edesc->bInterval - 1));
d3793 4
a3796 4
	exfer->itdstart = start;
	exfer->itdend = stop;
	exfer->sqtdstart = NULL;
	exfer->sqtdend = NULL;
d3798 1
a3798 1
	ehci_add_intr_list(sc, exfer);
a3826 1
	struct ehci_xfer *exfer = EXFER(xfer);
d3829 1
a3831 1

d3834 3
a3836 3
	if (xfer->status != USBD_NOMEM && ehci_active_intr_list(exfer)) {
		ehci_del_intr_list(sc, exfer);
		ehci_rem_free_itd_chain(sc, exfer);
@


1.145
log
@Unify the *hci_timeout() functions, there should be no functional change.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.144 2014/03/11 10:24:42 mpi Exp $ */
d1463 2
a1464 2
	DPRINTFN(1, ("ehci_open: pipe=%p, addr=%d, endpt=%d (%d)\n",
	    pipe, addr, ed->bEndpointAddress, sc->sc_addr));
d1477 2
a1478 1
	if (addr == sc->sc_addr) {
a2028 1
		sc->sc_addr = value;
@


1.144
log
@Kill dead links.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.143 2014/03/07 09:51:50 mpi Exp $ */
d2909 2
a2910 5
	struct ehci_xfer *exfer = addr;
	struct ehci_pipe *epipe = (struct ehci_pipe *)exfer->xfer.pipe;
	struct ehci_softc *sc = (struct ehci_softc *)epipe->pipe.device->bus;

	DPRINTF(("ehci_timeout: exfer=%p\n", exfer));
d2913 1
a2913 1
		ehci_abort_xfer(&exfer->xfer, USBD_TIMEOUT);
d2917 1
a2917 2
	/* Execute the abort in a process context. */
	usb_init_task(&exfer->xfer.abort_task, ehci_timeout_task, addr,
d2919 1
a2919 1
	usb_add_task(exfer->xfer.pipe->device, &exfer->xfer.abort_task);
d2928 1
a2928 1
	DPRINTF(("ehci_timeout_task: xfer=%p\n", xfer));
@


1.143
log
@Transfer descriptors already have a back pointer to the USB device
descriptor they are linked to, so no need to dereference their pipe
pointer.  Simplify a lot of affectations, no functional change.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.142 2014/03/07 09:38:14 mpi Exp $ */
a31 9
 */

/*
 * USB Enhanced Host Controller Driver, a.k.a. USB 2.0 controller.
 *
 * The EHCI 1.0 spec can be found at
 * http://developer.intel.com/technology/usb/download/ehci-r10.pdf
 * and the USB 2.0 spec at
 * http://www.usb.org/developers/docs/usb_20.zip
@


1.142
log
@We already have three identical copies of the *hci_str() function,
so merge them into usbd_str() to not introduce other copies with
the upcoming HC drivers.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.141 2014/02/24 18:21:20 mpi Exp $ */
d931 1
a931 1
			  xfer->pipe->device->address,
d1896 1
a1896 1
	struct ehci_softc *sc = (struct ehci_softc *)xfer->pipe->device->bus;
d2993 1
a2993 1
	struct ehci_softc *sc = (struct ehci_softc *)xfer->pipe->device->bus;
d3021 1
a3021 1
	struct ehci_softc *sc = (struct ehci_softc *)xfer->pipe->device->bus;
d3329 1
a3329 1
	struct ehci_softc *sc = (struct ehci_softc *)xfer->pipe->device->bus;
d3393 1
a3393 1
	struct usbd_device *dev = xfer->pipe->device;
d3504 1
a3504 1
	struct ehci_softc *sc = (struct ehci_softc *)xfer->pipe->device->bus;
d3597 1
a3597 1
	sc = (struct ehci_softc *)xfer->pipe->device->bus;
d3859 3
a3861 3
	struct ehci_xfer *exfer;
	struct ehci_softc *sc;
	struct ehci_pipe *epipe;
a3863 3
	exfer = EXFER(xfer);
	sc = (struct ehci_softc *)xfer->pipe->device->bus;
	epipe = (struct ehci_pipe *) xfer->pipe;
@


1.141
log
@Partially revert r1.134, bring back the code suspending root hub's ports
before reseting the controller in order to save power when the machine is
suspended.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.140 2014/01/15 11:10:40 mpi Exp $ */
a177 1
int		ehci_str(usb_string_descriptor_t *, int, const char *);
a1875 17
int
ehci_str(usb_string_descriptor_t *p, int l, const char *s)
{
	int i;

	if (l == 0)
		return (0);
	p->bLength = 2 * strlen(s) + 2;
	if (l == 1)
		return (1);
	p->bDescriptorType = UDESC_STRING;
	l -= 2;
	for (i = 0; s[i] && l > 1; i++, l -= 2)
		USETW2(p->bString[i], 0, s[i]);
	return (2*i+2);
}

d1998 1
a1998 1
				totlen = ehci_str(buf, len, "\001");
d2001 1
a2001 1
				totlen = ehci_str(buf, len, sc->sc_vendor);
d2004 1
a2004 1
				totlen = ehci_str(buf, len, "EHCI root hub");
@


1.140
log
@Remove a hack to update the address and packet length for every device
request and instead re-open the default pipe with updated values when
attaching a new device, adapted from FreeBSD r162977.

This fixes a problem where the controller could have cached the previous
values and would fail to get the device descriptor, leaving the device
unrecognized with a message like: "device problem, disabling port n".
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.139 2013/12/06 21:03:04 deraadt Exp $ */
d1044 7
d1090 21
a1110 1
		    sc->sc_async_head->physaddr | EHCI_LINK_QH);
@


1.139
log
@Add a DVACT_WAKEUP op to the *_activate() API.  This is called after the
kernel resumes normal (non-cold, able to run processes, etc) operation.
Previously we were relying on specific DVACT_RESUME op's in drivers
creating callback/threads themselves, but that has become too common,
indicating the need for a built-in mechanism.
ok dlg kettenis, tested by a sufficient amount of people
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.138 2013/11/09 08:46:05 mpi Exp $ */
a3054 1
	int addr = dev->address;
d3068 1
a3068 1
	    UGETW(req->wIndex), len, addr,
a3083 11

	/* Update device address and length since they may have changed
	   during the setup of the control pipe in usbd_new_device(). */
	/* XXX This only needs to be done once, but it's too early in open. */
	/* XXXX Should not touch ED here! */
	sqh->qh.qh_endp =
	    (sqh->qh.qh_endp & htole32(~(EHCI_QH_ADDRMASK | EHCI_QH_MPLMASK))) |
	    htole32(
	     EHCI_QH_SET_ADDR(addr) |
	     EHCI_QH_SET_MPL(UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize))
	    );
@


1.138
log
@In our USB world, timeouts are in milliseconds, so use timeout_add_msec()
coherently through all our controller drivers and kill the mstohz() macro.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.137 2013/11/09 08:40:32 mpi Exp $ */
a1039 3
	case DVACT_QUIESCE:
		rv = config_activate_children(self, act);
		break;
a1070 4
	case DVACT_POWERDOWN:
		rv = config_activate_children(self, act);
		ehci_reset(sc);
		break;
d1118 7
@


1.137
log
@Reduce the differences between our controller drivers and initialize
the timeout task in the *_timeout() routine.  It now becomes obvious
that the allocx/freex hooks can be merged.

ok pirofti@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.136 2013/11/07 10:15:15 mpi Exp $ */
a88 2

#define mstohz(ms) ((ms) * hz / 1000)
@


1.136
log
@Remove isoc_len from the transfer descriptor, it is assigned once but
never read.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.135 2013/11/01 12:00:53 mpi Exp $ */
a1184 2
		usb_init_task(&xfer->abort_task, ehci_timeout_task,
		    xfer, USB_TASK_TYPE_ABORT);
a2915 4
#if defined(EHCI_DEBUG) && defined(USB_DEBUG)
	if (ehcidebug > 1)
		usbd_dump_pipe(exfer->xfer.pipe);
#endif
d2923 2
@


1.135
log
@Move the abort_task storage to the generic USB xfer structure instead
of defining it in every controller specific structure.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.134 2013/06/12 11:42:01 mpi Exp $ */
d3598 1
a3598 1
	int s, trans_count, offs, total_length;
a3604 1
	total_length = 0;
a3717 1
			total_length += xfer->frlengths[trans_count];
d3725 1
a3725 1
		}       
a3774 1
	exfer->isoc_len = total_length;
@


1.134
log
@Rework of the suspend/resume logic.

Do not places the ports into suspend mode now that we detach/attach
all USB devicess during a suspend/resume cycle.

Emit a reset when reinitializing the controller after resume and
try to use the same logic as in ehci_init().

Correctly wait for the controller to set the HCHalted bit to one
before attempting a reset.

Tested by many and have been in snap for a week.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.133 2013/05/30 16:15:02 deraadt Exp $ */
d743 1
a743 1
	usb_rem_task(ex->xfer.pipe->device, &ex->abort_task);
d791 1
a791 1
	usb_rem_task(ex->xfer.pipe->device, &ex->abort_task);
d1185 1
a1185 1
		usb_init_task(&EXFER(xfer)->abort_task, ehci_timeout_task,
d2745 1
a2745 1
		usb_rem_task(epipe->pipe.device, &exfer->abort_task);
d2779 1
a2779 1
	usb_rem_task(epipe->pipe.device, &exfer->abort_task);
d2855 1
a2855 1
		usb_rem_task(epipe->pipe.device, &exfer->abort_task);
d2880 1
a2880 1
	usb_rem_task(epipe->pipe.device, &exfer->abort_task);
d2929 1
a2929 1
	usb_add_task(exfer->xfer.pipe->device, &exfer->abort_task);
@


1.133
log
@Enforce ca_activate tree-walks over the entire heirarchy for all events,
cleaning up some shutdown-hook related code on the way.
(A few drivers related to sparc are still skipped at kettenis' request)
ok kettenis mlarkin, tested by many others too
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.132 2013/05/20 08:19:47 yasuoka Exp $ */
a355 1
	/* Reset the controller */
d357 3
a359 14
	EOWRITE4(sc, EHCI_USBCMD, 0);	/* Halt controller */
	usb_delay_ms(&sc->sc_bus, 1);
	EOWRITE4(sc, EHCI_USBCMD, EHCI_CMD_HCRESET);
	for (i = 0; i < 100; i++) {
		usb_delay_ms(&sc->sc_bus, 1);
		hcr = EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_HCRESET;
		if (!hcr)
			break;
	}
	if (hcr) {
		printf("%s: reset timeout\n",
		    sc->sc_bus.bdev.dv_xname);
		return (USBD_IOERROR);
	}
d1024 2
d1038 1
a1038 1
	u_int32_t cmd, hcr;
d1049 5
a1053 9
		for (i = 1; i <= sc->sc_noport; i++) {
			cmd = EOREAD4(sc, EHCI_PORTSC(i));
			if ((cmd & (EHCI_PS_PO|EHCI_PS_PE)) == EHCI_PS_PE)
				EOWRITE4(sc, EHCI_PORTSC(i),
				    cmd | EHCI_PS_SUSP);
		}

		sc->sc_cmd = EOREAD4(sc, EHCI_USBCMD);
		cmd = sc->sc_cmd & ~(EHCI_CMD_ASE | EHCI_CMD_PSE);
a1054 1

d1056 1
a1060 2

			usb_delay_ms(&sc->sc_bus, 1);
d1063 1
a1063 1
			printf("%s: reset timeout\n",
d1066 7
a1072 13
		cmd &= ~EHCI_CMD_RS;
		EOWRITE4(sc, EHCI_USBCMD, cmd);

		for (i = 0; i < 100; i++) {
			hcr = EOREAD4(sc, EHCI_USBSTS) & EHCI_STS_HCH;
			if (hcr == EHCI_STS_HCH)
				break;

			usb_delay_ms(&sc->sc_bus, 1);
		}
		if (hcr != EHCI_STS_HCH)
			printf("%s: config timeout\n",
			    sc->sc_bus.bdev.dv_xname);
d1078 1
a1078 1
		ehci_shutdown(sc);
d1083 7
a1089 2
		/* restore things in case the bios sucks */
		EOWRITE4(sc, EHCI_CTRLDSSEGMENT, 0);
a1092 22
		EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

		hcr = 0;
		for (i = 1; i <= sc->sc_noport; i++) {
			cmd = EOREAD4(sc, EHCI_PORTSC(i));
			if ((cmd & (EHCI_PS_PO|EHCI_PS_SUSP)) == EHCI_PS_SUSP) {
				EOWRITE4(sc, EHCI_PORTSC(i),
				    cmd | EHCI_PS_FPR);
				hcr = 1;
			}
		}

		if (hcr) {
			usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
			for (i = 1; i <= sc->sc_noport; i++) {
				cmd = EOREAD4(sc, EHCI_PORTSC(i));
				if ((cmd & (EHCI_PS_PO|EHCI_PS_SUSP)) ==
				    EHCI_PS_SUSP)
					EOWRITE4(sc, EHCI_PORTSC(i),
					    cmd & ~EHCI_PS_FPR);
			}
		}
d1094 7
a1100 1
		EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);
a1103 1

d1105 1
d1107 1
a1107 1
			if (hcr != EHCI_STS_HCH)
d1109 1
d1111 3
a1113 1
			usb_delay_ms(&sc->sc_bus, 1);
d1115 2
a1116 3
		if (hcr == EHCI_STS_HCH)
			printf("%s: config timeout\n",
			    sc->sc_bus.bdev.dv_xname);
d1132 2
a1133 5
/*
 * Shut down the controller when the system is going down.
 */
void
ehci_shutdown(void *v)
d1135 2
a1136 1
	struct ehci_softc *sc = v;
d1138 1
a1138 1
	DPRINTF(("ehci_shutdown: stopping the HC\n"));
d1140 10
d1151 13
@


1.132
log
@Remove `abort_task' from usb task queue before recycling a `struct
usbd_xfer object' which includes the `abort_task'.  Otherwise
usb_abort_task_thread() may try to dequeue the recycled task then it
causes panic with page fault.

reported by Edd Barrett and Wade, Daniel.
ok mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.131 2013/04/19 08:58:53 mpi Exp $ */
d1056 1
d1099 1
@


1.131
log
@Remove allocm() and freem() from the USB bus interface now that they
are only used as wrappers around usb_{alloc,free}mem().

ok deraadt@@, mglocker@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.130 2013/04/15 09:23:01 mglocker Exp $ */
d803 1
d2863 1
d2888 1
@


1.130
log
@Get rid of various 'typedef struct' definitions and use plain structure
definitions instead.  We don't change usb.h for now to stay compatible
with userland.

Tested by mpi@@ on macppc and myself on i386.

ok mpi@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.129 2013/03/28 03:58:03 tedu Exp $ */
a137 3
usbd_status	ehci_allocm(struct usbd_bus *, struct usb_dma *, u_int32_t);
void		ehci_freem(struct usbd_bus *, struct usb_dma *);

a249 2
	ehci_allocm,
	ehci_freem,
a1170 22
}

usbd_status
ehci_allocm(struct usbd_bus *bus, struct usb_dma *dma, u_int32_t size)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;
	usbd_status err;

	err = usb_allocmem(&sc->sc_bus, size, 0, dma);
#ifdef EHCI_DEBUG
	if (err)
		printf("ehci_allocm: usb_allocmem()=%d\n", err);
#endif
	return (err);
}

void
ehci_freem(struct usbd_bus *bus, struct usb_dma *dma)
{
	struct ehci_softc *sc = (struct ehci_softc *)bus;

	usb_freemem(&sc->sc_bus, dma);
@


1.129
log
@proc.h is way too much header for usb to handle.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.128 2012/10/09 13:41:04 deraadt Exp $ */
d95 1
a95 1
	ehci_soft_qh_t *sqh;
d97 2
a98 2
		ehci_soft_qtd_t *qtd;
		/* ehci_soft_itd_t *itd; */
d103 1
a103 1
			usb_dma_t reqdma;
d105 1
a105 1
			/*ehci_soft_qtd_t *setup, *data, *stat;*/
d125 1
a125 1
usbd_status	ehci_open(usbd_pipe_handle);
d128 5
a132 5
int		ehci_intr1(ehci_softc_t *);
void		ehci_waitintr(ehci_softc_t *, usbd_xfer_handle);
void		ehci_check_intr(ehci_softc_t *, struct ehci_xfer *);
void		ehci_check_qh_intr(ehci_softc_t *, struct ehci_xfer *);
void		ehci_check_itd_intr(ehci_softc_t *, struct ehci_xfer *);
d138 2
a139 2
usbd_status	ehci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
void		ehci_freem(struct usbd_bus *, usb_dma_t *);
d141 2
a142 2
usbd_xfer_handle	ehci_allocx(struct usbd_bus *);
void		ehci_freex(struct usbd_bus *, usbd_xfer_handle);
d144 35
a178 35
usbd_status	ehci_root_ctrl_transfer(usbd_xfer_handle);
usbd_status	ehci_root_ctrl_start(usbd_xfer_handle);
void		ehci_root_ctrl_abort(usbd_xfer_handle);
void		ehci_root_ctrl_close(usbd_pipe_handle);
void		ehci_root_ctrl_done(usbd_xfer_handle);

usbd_status	ehci_root_intr_transfer(usbd_xfer_handle);
usbd_status	ehci_root_intr_start(usbd_xfer_handle);
void		ehci_root_intr_abort(usbd_xfer_handle);
void		ehci_root_intr_close(usbd_pipe_handle);
void		ehci_root_intr_done(usbd_xfer_handle);

usbd_status	ehci_device_ctrl_transfer(usbd_xfer_handle);
usbd_status	ehci_device_ctrl_start(usbd_xfer_handle);
void		ehci_device_ctrl_abort(usbd_xfer_handle);
void		ehci_device_ctrl_close(usbd_pipe_handle);
void		ehci_device_ctrl_done(usbd_xfer_handle);

usbd_status	ehci_device_bulk_transfer(usbd_xfer_handle);
usbd_status	ehci_device_bulk_start(usbd_xfer_handle);
void		ehci_device_bulk_abort(usbd_xfer_handle);
void		ehci_device_bulk_close(usbd_pipe_handle);
void		ehci_device_bulk_done(usbd_xfer_handle);

usbd_status	ehci_device_intr_transfer(usbd_xfer_handle);
usbd_status	ehci_device_intr_start(usbd_xfer_handle);
void		ehci_device_intr_abort(usbd_xfer_handle);
void		ehci_device_intr_close(usbd_pipe_handle);
void		ehci_device_intr_done(usbd_xfer_handle);

usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle);
usbd_status	ehci_device_isoc_start(usbd_xfer_handle);
void		ehci_device_isoc_abort(usbd_xfer_handle);
void		ehci_device_isoc_close(usbd_pipe_handle);
void		ehci_device_isoc_done(usbd_xfer_handle);
d180 2
a181 2
void		ehci_device_clear_toggle(usbd_pipe_handle pipe);
void		ehci_noop(usbd_pipe_handle pipe);
d184 2
a185 2
void		ehci_pcd(ehci_softc_t *, usbd_xfer_handle);
void		ehci_disown(ehci_softc_t *, int, int);
d187 2
a188 2
ehci_soft_qh_t  *ehci_alloc_sqh(ehci_softc_t *);
void		ehci_free_sqh(ehci_softc_t *, ehci_soft_qh_t *);
d190 2
a191 2
ehci_soft_qtd_t  *ehci_alloc_sqtd(ehci_softc_t *);
void		ehci_free_sqtd(ehci_softc_t *, ehci_soft_qtd_t *);
d193 3
a195 7
			    ehci_softc_t *, u_int, int, usbd_xfer_handle,
			    ehci_soft_qtd_t **, ehci_soft_qtd_t **);
void		ehci_free_sqtd_chain(ehci_softc_t *, struct ehci_xfer *exfer);

ehci_soft_itd_t	*ehci_alloc_itd(ehci_softc_t *sc);
void		ehci_free_itd(ehci_softc_t *sc, ehci_soft_itd_t *itd);
void		ehci_rem_free_itd_chain(ehci_softc_t *sc,
d197 6
a202 1
void		ehci_abort_isoc_xfer(usbd_xfer_handle xfer,
d205 1
a205 1
usbd_status	ehci_device_request(usbd_xfer_handle xfer);
d207 1
a207 1
usbd_status	ehci_device_setintr(ehci_softc_t *, ehci_soft_qh_t *,
d210 4
a213 4
void		ehci_add_qh(ehci_soft_qh_t *, ehci_soft_qh_t *);
void		ehci_rem_qh(ehci_softc_t *, ehci_soft_qh_t *);
void		ehci_set_qh_qtd(ehci_soft_qh_t *, ehci_soft_qtd_t *);
void		ehci_sync_hc(ehci_softc_t *);
d215 2
a216 2
void		ehci_close_pipe(usbd_pipe_handle);
void		ehci_abort_xfer(usbd_xfer_handle, usbd_status);
d219 1
a219 1
void		ehci_dump_regs(ehci_softc_t *);
d221 1
a221 1
ehci_softc_t	*theehci;
d223 4
a226 4
void		ehci_dump_sqtds(ehci_soft_qtd_t *);
void		ehci_dump_sqtd(ehci_soft_qtd_t *);
void		ehci_dump_qtd(ehci_qtd_t *);
void		ehci_dump_sqh(ehci_soft_qh_t *);
d329 1
a329 1
ehci_init(ehci_softc_t *sc)
d334 1
a334 1
	ehci_soft_qh_t *sqh;
d404 1
a404 1
	sc->sc_softitds = malloc(sc->sc_flsize * sizeof(ehci_soft_itd_t *),
d534 1
a534 1
	ehci_softc_t *sc = v;
d552 1
a552 1
ehci_intr1(ehci_softc_t *sc)
d621 1
a621 1
ehci_pcd(ehci_softc_t *sc, usbd_xfer_handle xfer)
d649 1
a649 1
	ehci_softc_t *sc = v;
d687 1
a687 1
ehci_check_intr(ehci_softc_t *sc, struct ehci_xfer *ex)
d703 1
a703 1
ehci_check_qh_intr(ehci_softc_t *sc, struct ehci_xfer *ex)
d705 1
a705 1
	ehci_soft_qtd_t *sqtd, *lsqtd;
d726 1
a726 1
	    lsqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d733 1
a733 1
			    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d738 1
a738 1
			    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d753 1
a753 1
		    lsqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d765 2
a766 2
ehci_check_itd_intr(ehci_softc_t *sc, struct ehci_xfer *ex) {
	ehci_soft_itd_t *itd;
d789 1
a789 1
	usb_syncmem(&itd->dma, itd->offs + offsetof(ehci_itd_t, itd_ctl),
d814 1
a814 1
	usbd_xfer_handle xfer = &ex->xfer;
d818 1
a818 1
	ehci_soft_qtd_t *sqtd;
d883 1
a883 1
			    itd->offs + offsetof(ehci_itd_t, itd_ctl),
d978 1
a978 1
ehci_waitintr(ehci_softc_t *sc, usbd_xfer_handle xfer)
d1012 1
a1012 1
	ehci_softc_t *sc = (ehci_softc_t *)bus;
d1171 1
a1171 1
	ehci_softc_t *sc = v;
d1179 1
a1179 1
ehci_allocm(struct usbd_bus *bus, usb_dma_t *dma, u_int32_t size)
d1193 1
a1193 1
ehci_freem(struct usbd_bus *bus, usb_dma_t *dma)
d1200 1
a1200 1
usbd_xfer_handle
d1204 1
a1204 1
	usbd_xfer_handle xfer;
d1231 1
a1231 1
ehci_freex(struct usbd_bus *bus, usbd_xfer_handle xfer)
d1251 1
a1251 1
ehci_device_clear_toggle(usbd_pipe_handle pipe)
d1269 1
a1269 1
ehci_noop(usbd_pipe_handle pipe)
d1275 1
a1275 1
ehci_dump_regs(ehci_softc_t *sc)
d1333 1
a1333 1
ehci_dump_sqtds(ehci_soft_qtd_t *sqtd)
d1342 1
a1342 1
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_next),
d1347 1
a1347 1
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_next),
d1355 1
a1355 1
ehci_dump_sqtd(ehci_soft_qtd_t *sqtd)
d1366 1
a1366 1
ehci_dump_qtd(ehci_qtd_t *qtd)
d1388 1
a1388 1
ehci_dump_sqh(ehci_soft_qh_t *sqh)
d1390 1
a1390 1
	ehci_qh_t *qh = &sqh->qh;
d1470 1
a1470 1
ehci_open(usbd_pipe_handle pipe)
d1472 2
a1473 2
	usbd_device_handle dev = pipe->device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
d1478 1
a1478 1
	ehci_soft_qh_t *sqh;
d1639 1
a1639 1
ehci_add_qh(ehci_soft_qh_t *sqh, ehci_soft_qh_t *head)
d1643 1
a1643 1
	usb_syncmem(&head->dma, head->offs + offsetof(ehci_qh_t, qh_link),
d1648 1
a1648 1
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(ehci_qh_t, qh_link),
d1654 1
a1654 1
	usb_syncmem(&head->dma, head->offs + offsetof(ehci_qh_t, qh_link),
d1670 1
a1670 1
ehci_rem_qh(ehci_softc_t *sc, ehci_soft_qh_t *sqh)
d1674 1
a1674 1
	usb_syncmem(&sqh->dma, sqh->offs + offsetof(ehci_qh_t, qh_link),
d1681 1
a1681 1
	    sqh->prev->offs + offsetof(ehci_qh_t, qh_link),
d1688 1
a1688 1
ehci_set_qh_qtd(ehci_soft_qh_t *sqh, ehci_soft_qtd_t *sqtd)
d1703 1
a1703 1
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
d1717 1
a1717 1
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
d1729 1
a1729 1
ehci_sync_hc(ehci_softc_t *sc)
d1765 1
a1765 1
ehci_rem_free_itd_chain(ehci_softc_t *sc, struct ehci_xfer *exfer)
d1792 1
a1792 1
			    itd->offs + offsetof(ehci_itd_t, itd_next),
d1909 1
a1909 1
ehci_root_ctrl_transfer(usbd_xfer_handle xfer)
d1923 1
a1923 1
ehci_root_ctrl_start(usbd_xfer_handle xfer)
d1925 1
a1925 1
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
d2302 1
a2302 1
ehci_disown(ehci_softc_t *sc, int index, int lowspeed)
d2316 1
a2316 1
ehci_root_ctrl_abort(usbd_xfer_handle xfer)
d2323 1
a2323 1
ehci_root_ctrl_close(usbd_pipe_handle pipe)
d2330 1
a2330 1
ehci_root_intr_done(usbd_xfer_handle xfer)
d2335 1
a2335 1
ehci_root_intr_transfer(usbd_xfer_handle xfer)
d2349 1
a2349 1
ehci_root_intr_start(usbd_xfer_handle xfer)
d2351 2
a2352 2
	usbd_pipe_handle pipe = xfer->pipe;
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
d2364 1
a2364 1
ehci_root_intr_abort(usbd_xfer_handle xfer)
d2380 1
a2380 1
ehci_root_intr_close(usbd_pipe_handle pipe)
d2382 1
a2382 1
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
d2390 1
a2390 1
ehci_root_ctrl_done(usbd_xfer_handle xfer)
d2396 2
a2397 2
ehci_soft_qh_t *
ehci_alloc_sqh(ehci_softc_t *sc)
d2399 1
a2399 1
	ehci_soft_qh_t *sqh;
d2402 1
a2402 1
	usb_dma_t dma;
d2426 1
a2426 1
	memset(&sqh->qh, 0, sizeof(ehci_qh_t));
d2433 1
a2433 1
ehci_free_sqh(ehci_softc_t *sc, ehci_soft_qh_t *sqh)
d2439 2
a2440 2
ehci_soft_qtd_t *
ehci_alloc_sqtd(ehci_softc_t *sc)
d2442 1
a2442 1
	ehci_soft_qtd_t *sqtd;
d2445 1
a2445 1
	usb_dma_t dma;
d2474 1
a2474 1
	memset(&sqtd->qtd, 0, sizeof(ehci_qtd_t));
d2482 1
a2482 1
ehci_free_sqtd(ehci_softc_t *sc, ehci_soft_qtd_t *sqtd)
d2493 3
a2495 2
ehci_alloc_sqtd_chain(struct ehci_pipe *epipe, ehci_softc_t *sc, u_int alen,
    int rd, usbd_xfer_handle xfer, ehci_soft_qtd_t **sp, ehci_soft_qtd_t **ep)
d2497 1
a2497 1
	ehci_soft_qtd_t *next, *cur;
d2502 1
a2502 1
	usb_dma_t *dma = &xfer->dmabuf;
d2641 1
a2641 1
ehci_free_sqtd_chain(ehci_softc_t *sc, struct ehci_xfer *ex)
d2644 1
a2644 1
	ehci_soft_qtd_t *sqtd, *next;
d2656 2
a2657 2
ehci_soft_itd_t *
ehci_alloc_itd(ehci_softc_t *sc)
d2662 1
a2662 1
	usb_dma_t dma;
d2706 2
a2707 2
	memset(&itd->itd, 0, sizeof(ehci_itd_t));
	usb_syncmem(&itd->dma, itd->offs + offsetof(ehci_itd_t, itd_next),
d2721 1
a2721 1
ehci_free_itd(ehci_softc_t *sc, ehci_soft_itd_t *itd)
d2737 1
a2737 1
ehci_close_pipe(usbd_pipe_handle pipe)
d2740 2
a2741 2
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	ehci_soft_qh_t *sqh = epipe->sqh;
d2763 1
a2763 1
ehci_abort_xfer(usbd_xfer_handle xfer, usbd_status status)
d2767 3
a2769 3
	ehci_softc_t *sc = (ehci_softc_t *)epipe->pipe.device->bus;
	ehci_soft_qh_t *sqh = epipe->sqh;
	ehci_soft_qtd_t *sqtd;
d2821 1
a2821 1
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
d2826 1
a2826 1
	    sqh->offs + offsetof(ehci_qh_t, qh_qtd.qtd_status),
d2832 1
a2832 1
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d2837 1
a2837 1
		    sqtd->offs + offsetof(ehci_qtd_t, qtd_status),
d2870 1
a2870 1
ehci_abort_isoc_xfer(usbd_xfer_handle xfer, usbd_status status)
d2875 1
a2875 1
	ehci_softc_t *sc;
d2881 1
a2881 1
	sc = (ehci_softc_t *)epipe->pipe.device->bus;
d2947 1
a2947 1
	ehci_softc_t *sc = (ehci_softc_t *)epipe->pipe.device->bus;
d2967 1
a2967 1
	usbd_xfer_handle xfer = addr;
d2991 1
a2991 1
	ehci_softc_t *sc = arg;
d3006 1
a3006 1
ehci_device_ctrl_transfer(usbd_xfer_handle xfer)
d3020 1
a3020 1
ehci_device_ctrl_start(usbd_xfer_handle xfer)
d3022 1
a3022 1
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
d3047 1
a3047 1
ehci_device_ctrl_done(usbd_xfer_handle xfer)
d3050 1
a3050 1
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
d3071 1
a3071 1
ehci_device_ctrl_abort(usbd_xfer_handle xfer)
d3079 1
a3079 1
ehci_device_ctrl_close(usbd_pipe_handle pipe)
d3086 1
a3086 1
ehci_device_request(usbd_xfer_handle xfer)
d3091 2
a3092 2
	usbd_device_handle dev = epipe->pipe.device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
d3094 2
a3095 2
	ehci_soft_qtd_t *setup, *stat, *next;
	ehci_soft_qh_t *sqh;
d3137 1
a3137 1
		ehci_soft_qtd_t *end;
d3243 1
a3243 1
ehci_device_bulk_transfer(usbd_xfer_handle xfer)
d3257 1
a3257 1
ehci_device_bulk_start(usbd_xfer_handle xfer)
d3261 4
a3264 4
	usbd_device_handle dev = epipe->pipe.device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
d3350 1
a3350 1
ehci_device_bulk_abort(usbd_xfer_handle xfer)
d3360 1
a3360 1
ehci_device_bulk_close(usbd_pipe_handle pipe)
d3367 1
a3367 1
ehci_device_bulk_done(usbd_xfer_handle xfer)
d3370 1
a3370 1
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
d3391 1
a3391 1
ehci_device_setintr(ehci_softc_t *sc, ehci_soft_qh_t *sqh, int ival)
d3413 1
a3413 1
ehci_device_intr_transfer(usbd_xfer_handle xfer)
d3430 1
a3430 1
ehci_device_intr_start(usbd_xfer_handle xfer)
d3434 4
a3437 4
	usbd_device_handle dev = xfer->pipe->device;
	ehci_softc_t *sc = (ehci_softc_t *)dev->bus;
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
d3518 1
a3518 1
ehci_device_intr_abort(usbd_xfer_handle xfer)
d3534 1
a3534 1
ehci_device_intr_close(usbd_pipe_handle pipe)
d3541 1
a3541 1
ehci_device_intr_done(usbd_xfer_handle xfer)
d3545 1
a3545 1
	ehci_softc_t *sc = (ehci_softc_t *)xfer->pipe->device->bus;
d3547 2
a3548 2
	ehci_soft_qtd_t *data, *dataend;
	ehci_soft_qh_t *sqh;
d3610 1
a3610 1
ehci_device_isoc_transfer(usbd_xfer_handle xfer)
d3622 1
a3622 1
ehci_device_isoc_start(usbd_xfer_handle xfer)
d3625 1
a3625 1
	ehci_softc_t *sc;
d3627 2
a3628 2
	ehci_soft_itd_t *itd, *prev, *start, *stop;
	usb_dma_t *dma_buf;
d3639 1
a3639 1
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
d3888 1
a3888 1
ehci_device_isoc_abort(usbd_xfer_handle xfer)
d3895 1
a3895 1
ehci_device_isoc_close(usbd_pipe_handle pipe)
d3901 1
a3901 1
ehci_device_isoc_done(usbd_xfer_handle xfer)
d3904 1
a3904 1
	ehci_softc_t *sc;
d3909 1
a3909 1
	sc = (ehci_softc_t *)xfer->pipe->device->bus;
@


1.128
log
@Our arc4random() is safe to use in any context, so we don't the crazy
fake randomizer for pre-boot.  We still need better interrupt scheduling,
but this makes that more clear.
ok yuo mpi
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.127 2012/10/08 21:47:50 deraadt Exp $ */
a58 1
#include <sys/proc.h>
@


1.127
log
@Revamp the sequences for suspend/hibernate -> resume so that the code
paths are reflexive.  It is now possible to fail part-way through a
suspend sequence, and recover along the resume code path.
Split DVACT_SUSPEND by adding a new DVACT_POWERDOWN method is used
after hibernate (and suspend too) to finish the job.  Some drivers
must be converted at the same time to use this instead of shutdown hooks
(the others will follow at a later time)
ok kettenis mlarkin
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.126 2012/08/17 17:29:00 krw Exp $ */
a377 3
	/* XXX need proper intr scheduling */
	sc->sc_rand = 96;

d3402 1
a3402 6
	if (cold) {
		/* XXX prevent panics at boot by not using arc4random */
		sc->sc_rand = (sc->sc_rand + 192) % sc->sc_flsize;
		islot = EHCI_IQHIDX(lev, sc->sc_rand);
	} else
		islot = EHCI_IQHIDX(lev, arc4random());
@


1.126
log
@Fix typos in DPRINTF() so error messages refer to correct *hci.

Spotted by Artturi Alm. Thanks!
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.125 2012/08/07 23:51:36 krw Exp $ */
a1042 3
	if (sc->sc_shutdownhook != NULL)
		shutdownhook_disestablish(sc->sc_shutdownhook);

d1103 3
@


1.125
log
@Make all *_device_*_start() functions (e.g. ohci_device_intr_start())
wait for an interrupt when the bus is in polling mode. Otherwise
some devices like my YE-Data USB Floppy take a short sharp trip to
ddb> at 'halt -p'.

Most of the functions were already doing the wait.

ok miod@@. With modification that printf's become DPRINTF's.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.124 2012/07/07 12:54:04 mpi Exp $ */
d3887 1
a3887 1
		DPRINTF(("Starting ohci isoc xfer with polling. Bad idea?\n"));
@


1.124
log
@When aborting a transfer set the halted bit to the QH's qTD and remove
superflous code. This fix an abort loop problem reported by Gerhard Roth,
based on his initial diff. Has been in snap for some weeks, ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.123 2012/06/23 14:15:02 mpi Exp $ */
d3044 1
d3887 1
a3887 1
		printf("Starting ehci isoc xfer with polling. Bad idea?\n");
@


1.123
log
@There's no need to check for the last qTD of a list because they are
NULL-terminated.

Part of a larger diff from Gerhard Roth
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.122 2012/06/23 14:09:42 mpi Exp $ */
d2771 1
a2771 2
	ehci_soft_qtd_t *sqtd, *snext, **psqtd;
	ehci_physaddr_t cur, us, next;
a2772 2
	int hit;
	ehci_soft_qh_t *psqh;
d2819 2
a2820 4
	 * Step 2: Wait until we know hardware has finished any possible
	 * use of the xfer. We do this by removing the entire
	 * queue from the async schedule and waiting for the doorbell.
	 * Nothing else should be touching the queue now.
d2822 9
a2830 2
	psqh = sqh->prev;
	ehci_rem_qh(sc, sqh);
d2832 1
a2832 8
	/*
	 * Step 3: Deactivate all of the qTDs that we will be removing,
	 * otherwise the queue head may go active again.  The EHCI spec
	 * suggests we should perform the deactivation before removing the
	 * queue head from the schedule, however the VT6202 (at least) only
	 * behaves correctly when we deactivate them afterwards.
	 */
	for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
a2841 2
		if (sqtd == exfer->sqtdend)
			break;
d2846 2
a2847 2
	 * Step 4:  make sure the soft interrupt routine
	 * has run. This should remove any completed items off the queue.
a2849 2
	 * use of the xfer.  Also make sure the soft interrupt routine
	 * has run.
a2855 87
	/*
	 * Step 5: Remove any vestiges of the xfer from the hardware.
	 * The complication here is that the hardware may have executed
	 * into or even beyond the xfer we're trying to abort.
	 * So as we're scanning the TDs of this xfer we check if
	 * the hardware points to any of them.
	 *
	 * first we need to see if there are any transfers
	 * on this queue before the xfer we are aborting.. we need
	 * to update any pointers that point to us to point past
	 * the aborting xfer.  (If there is something past us).
	 * Hardware and software.
	 */
	usb_syncmem(&sqh->dma,
	    sqh->offs + offsetof(ehci_qh_t, qh_curqtd),
	    sizeof(sqh->qh.qh_curqtd),
	    BUS_DMASYNC_POSTWRITE | BUS_DMASYNC_POSTREAD);
	cur = EHCI_LINK_ADDR(letoh32(sqh->qh.qh_curqtd));
	hit = 0;

	/* If they initially point here. */
	us = exfer->sqtdstart->physaddr;

	/* We will change them to point here */
	snext = exfer->sqtdend->nextqtd;
	next = snext ? snext->physaddr : EHCI_NULL;

	/*
	 * Now loop through any qTDs before us and keep track of the pointer
	 * that points to us for the end.
	 */
	psqtd = &sqh->sqtd;
	sqtd = sqh->sqtd;
	while (sqtd && sqtd != exfer->sqtdstart) {
		hit |= (cur == sqtd->physaddr);
		if (EHCI_LINK_ADDR(letoh32(sqtd->qtd.qtd_next)) == us)
			sqtd->qtd.qtd_next = next;
		if (EHCI_LINK_ADDR(letoh32(sqtd->qtd.qtd_altnext)) == us)
			sqtd->qtd.qtd_altnext = next;
		psqtd = &sqtd->nextqtd;
		sqtd = sqtd->nextqtd;
	}
		/* make the software pointer bypass us too */
	*psqtd = exfer->sqtdend->nextqtd;

	/*
	 * If we already saw the active one then we are pretty much done.
	 * We've done all the relinking we need to do.
	 */
	if (!hit) {

		/*
		 * Now reinitialise the QH to point to the next qTD
		 * (if there is one). We only need to do this if
		 * it was previously pointing to us.
		 * XXX Not quite sure what to do about the data toggle.
		 */
		sqtd = exfer->sqtdstart;
		for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
			if (cur == sqtd->physaddr) {
				hit++;
			}
			if (sqtd == exfer->sqtdend)
				break;
		}
		/*
		 * Only need to alter the QH if it was pointing at a qTD
		 * that we are removing.
		 */
		if (hit) {
			if (snext) {
				ehci_set_qh_qtd(sqh, snext);
			} else {

				sqh->qh.qh_curqtd = 0; /* unlink qTDs */
				sqh->qh.qh_qtd.qtd_status = 0;
				sqh->qh.qh_qtd.qtd_next =
				    sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
				DPRINTFN(1,("ehci_abort_xfer: no hit\n"));
			}
		}
	}
	ehci_add_qh(sqh, psqh);

	/*
	 * Step 6: Execute callback.
	 */
@


1.122
log
@Fix a bad copy/paste; when starting an isochronous transfer set the
first and last qTD pointers to NULL because only iTDs will be used.

Part of a larger diff from Gerhard Roth
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.121 2012/05/13 08:37:52 mpi Exp $ */
d821 1
a821 1
	ehci_soft_qtd_t *sqtd, *lsqtd;
a920 1
	lsqtd = ex->sqtdend;
d922 1
a922 2
	for (sqtd = ex->sqtdstart; sqtd != lsqtd->nextqtd;
	    sqtd = sqtd->nextqtd) {
@


1.121
log
@Remove unused and confusing 'head' argument.

Part of a larger diff from Gerhard Roth, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.120 2012/05/12 17:39:51 mpi Exp $ */
d3976 1
a3976 1
	exfer->sqtdstart = NULL;
@


1.120
log
@Remove unused xfer pointer from the qTD structure.

ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.119 2012/05/12 17:36:34 mpi Exp $ */
d211 1
a211 2
void		ehci_rem_qh(ehci_softc_t *, ehci_soft_qh_t *,
			    ehci_soft_qh_t *);
d215 1
a215 1
void		ehci_close_pipe(usbd_pipe_handle, ehci_soft_qh_t *);
d1675 1
a1675 1
ehci_rem_qh(ehci_softc_t *sc, ehci_soft_qh_t *sqh, ehci_soft_qh_t *head)
d2741 1
a2741 1
ehci_close_pipe(usbd_pipe_handle pipe, ehci_soft_qh_t *head)
d2749 1
a2749 1
	ehci_rem_qh(sc, sqh, head);
d2830 1
a2830 1
	ehci_rem_qh(sc, sqh, psqh);
a3179 3
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;*/

d3181 1
a3181 1
	ehci_close_pipe(pipe, sc->sc_async_head);
a3460 2
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;

d3462 1
a3462 1
	ehci_close_pipe(pipe, sc->sc_async_head);
d3640 2
a3641 6
	ehci_softc_t *sc = (ehci_softc_t *)pipe->device->bus;
	struct ehci_pipe *epipe = (struct ehci_pipe *)pipe;
	struct ehci_soft_islot *isp;

	isp = &sc->sc_islots[epipe->sqh->islot];
	ehci_close_pipe(pipe, isp->sqh);
@


1.119
log
@Because qTD lists are NULL terminated, there is no need for an extra
'sqtdend' argument when freeing one of them.

Part of a larger diff from Gerhard Roth with some tweaks, ok miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.118 2011/07/10 17:34:53 eric Exp $ */
a2481 1
	sqtd->xfer = NULL;
a2605 1
		cur->xfer = xfer;
a3269 1
	setup->xfer = xfer;
a3283 1
	stat->xfer = xfer;
@


1.118
log
@Read the HCSPARAMS register from the correct location, and add
parentheses where needed to get the resulting mask right.

ok krw@@ yuo@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.117 2011/07/03 15:47:17 matthew Exp $ */
d196 1
a196 2
void		ehci_free_sqtd_chain(ehci_softc_t *, ehci_soft_qtd_t *,
			    ehci_soft_qtd_t *);
d2648 1
a2648 2
ehci_free_sqtd_chain(ehci_softc_t *sc, ehci_soft_qtd_t *sqtd,
		    ehci_soft_qtd_t *sqtdend)
d2650 2
a2651 2
	ehci_soft_qtd_t *p;
	int i;
d2653 1
a2653 2
	DPRINTFN(10,("ehci_free_sqtd_chain: sqtd=%p sqtdend=%p\n",
	    sqtd, sqtdend));
d2655 2
a2656 2
	for (i = 0; sqtd != sqtdend; sqtd = p, i++) {
		p = sqtd->nextqtd;
d2659 2
d3165 1
a3165 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
d3489 1
a3489 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
d3675 1
a3675 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
d3716 1
a3716 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, NULL);
@


1.117
log
@Remove config_activate() and DVACT_ACTIVATE.  PCMCIA's the only thing
that's ever used it, and it's long since been changed to use
DVACT_{QUIESCE,SUSPEND,RESUME} instead.

ok deraadt@@, dlg@@; miod@@ also agreed with this idea when I brought it
up a few weeks ago
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.116 2011/06/23 16:02:33 tedu Exp $ */
d2151 1
a2151 1
		v = EOREAD4(sc, EHCI_HCSPARAMS);
d2153 2
a2154 3
		    EHCI_HCS_PPC(v) ? UHD_PWR_INDIVIDUAL : UHD_PWR_NO_SWITCH |
		    EHCI_HCS_P_INDICATOR(EREAD4(sc, EHCI_HCSPARAMS))
		        ? UHD_PORT_IND : 0);
@


1.116
log
@ansify a few files.  ok deraadt dlg krw matthew
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.115 2010/12/14 16:13:16 jakemsr Exp $ */
a1065 2
	case DVACT_ACTIVATE:
		break;
@


1.115
log
@use the dying flag in struct usbd_bus instead of a private dying flag
in *hci_softc

ok miod@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.114 2010/12/06 06:09:08 jakemsr Exp $ */
d1307 1
a1307 1
ehci_dump()
@


1.114
log
@* if we got an undercoverable error, set the dying flag
* check the dying flag in timeout and interrupt handlers

fixes crash when disconnecting cardbus usb adapters
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.113 2010/10/23 15:42:09 jakemsr Exp $ */
d541 1
a541 1
	if (sc == NULL || sc->sc_dying)
d573 1
a573 1
		sc->sc_dying = 1;
d591 1
a591 1
		sc->sc_dying = 1;
d660 1
a660 1
	if (sc->sc_dying)
d993 1
a993 1
		if (sc->sc_dying)
d1168 1
a1168 1
		sc->sc_dying = 1;
d1496 1
a1496 1
	if (sc->sc_dying)
d1743 1
a1743 1
	if (sc->sc_dying) {
d1944 1
a1944 1
	if (sc->sc_dying)
d2243 1
a2243 1
			if (sc->sc_dying) {
d2252 1
a2252 1
			if (sc->sc_dying) {
d2364 1
a2364 1
	if (sc->sc_dying)
d2788 1
a2788 1
	if (sc->sc_dying) {
d2992 1
a2992 1
	if (sc->sc_dying) {
d3062 1
a3062 1
	if (sc->sc_dying) {
d3101 1
a3101 1
	if (sc->sc_dying)
d3132 1
a3132 1
	if (sc->sc_dying)
d3384 1
a3384 1
	if (sc->sc_dying)
d3564 1
a3564 1
	if (sc->sc_dying)
d3777 1
a3777 1
	if (sc->sc_dying)
@


1.113
log
@create another kthread to run xfer abort tasks.  xfer abort tasks cannot
be run from the generic task kthread, because xfers that need to be
aborted block newly queued tasks from running (i.e. the xfer to be aborted
blocks the abort of that task).  as there are now three types of usb
tasks, add an argument to usb_init_task() and another member to struct
usb_task to specify the task type.

fixes boot hangs that are showing up because we now use usb tasks to
attach/detach usb devices.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.112 2010/09/29 20:06:38 kettenis Exp $ */
d588 7
a606 5
	if (eintrs & EHCI_STS_HSE) {
		printf("%s: unrecoverable error, controller halted\n",
		       sc->sc_bus.bdev.dv_xname);
		/* XXX what else */
	}
d660 3
d3099 1
a3099 1
	int s = splusb();
d3101 4
a3106 1

@


1.112
log
@Add DMA sync operations.  Fixes problems on macppc with gcc4 because
apparently it reorders stores in a bad way.  Mostly from NetBSD.

earlier diff tested by landry@@ (who noticed the problems on macppc)
ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.111 2010/09/23 08:39:32 jakemsr Exp $ */
d1224 1
a1224 1
		    xfer);
@


1.111
log
@returning here can cause the usb task thread to go to sleep forever,
becaue it skips a wakeup() later on.  this is the only error condition
that returns before the wakeup.  not sure why this particular case is
handled differently, and not certain what the error code should be, but
this is better than breaking all of usb because of a problem on one port.
dicussed with deraadt
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.110 2010/09/07 16:21:46 deraadt Exp $ */
d453 2
d462 2
d484 2
d725 4
d732 4
d737 3
d752 3
a785 1
	 * Step 1, check no active transfers in last itd, meaning we're finished
d788 5
d882 5
d922 2
d1345 4
d1350 3
d1361 2
d1365 2
d1397 2
d1419 2
d1572 3
d1647 2
d1652 2
d1658 2
d1678 2
d1684 4
d1698 2
d1706 4
d1716 2
d1720 4
d1784 4
d1795 4
d2423 2
d2468 2
d2534 3
d2624 2
d2631 2
d2713 4
d2842 4
d2847 4
d2882 4
d3248 2
d3255 1
d3270 2
d3285 2
d3476 3
a3478 1
	/*struct ehci_pipe *epipe = (struct ehci_pipe *)xfer->pipe;*/
d3486 2
d3677 2
d3713 4
@


1.110
log
@remove the powerhook code.  All architectures now use the ca_activate tree
traversal code to suspend/resume
ok oga kettenis blambert
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.109 2010/08/31 17:13:47 deraadt Exp $ */
d2175 2
a2176 1
				return (USBD_TIMEOUT);
@


1.109
log
@Add DVACT_QUIECE support.  This is called before splhigh() and before
DVACT_SUSPEND, therefore DVACT_QUIECE can do standard sleeping operations
to get ready.
Discussed quite a while back with kettenis and jakemsr, oga suddenly needed
it as well and wrote half of it, so it was time to finish it.
proofread by miod.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.108 2010/08/30 21:30:15 deraadt Exp $ */
a125 2
void		ehci_powerhook(int, void *);

a419 2
	sc->sc_powerhook = powerhook_establish(ehci_powerhook, sc);

a1010 2
	if (sc->sc_powerhook != NULL)
		powerhook_disestablish(sc->sc_powerhook);
a1135 6
}

void
ehci_powerhook(int why, void *v)
{
	ehci_activate(v, why);
@


1.108
log
@Change powerhooks into activate functions, and provide stub powerhook
functions
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.107 2010/08/27 04:09:20 deraadt Exp $ */
d1038 2
a1039 4
	case DVACT_DEACTIVATE:
		if (sc->sc_child != NULL)
			rv = config_deactivate(sc->sc_child);
		sc->sc_dying = 1;
d1134 5
@


1.107
log
@kill PWR_STANDBY (apm can use PWR_SUSPEND instead).  While here, renumber
PWR_{SUSPEND,RESUME} so that they match the values of DAVCT_{SUSPEND,RESUME}
so that we can eventually (many more steps...) kill the powerhook garbage
and use the activate mechanism.
no objections
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.106 2009/11/26 12:27:48 deraadt Exp $ */
d126 1
a126 1
void		ehci_power(int, void *);
d422 1
a422 1
	sc->sc_powerhook = powerhook_establish(ehci_power, sc);
d1032 2
a1033 1
	int rv = 0;
a1037 1

a1043 33
		ehci_power(PWR_SUSPEND, sc);
		break;
	case DVACT_RESUME:
		ehci_power(PWR_RESUME, sc);
		rv = config_activate_children(self, act);
		break;
	}
	return (rv);
}

/*
 * Handle suspend/resume.
 *
 * We need to switch to polling mode here, because this routine is
 * called from an interrupt context.  This is all right since we
 * are almost suspended anyway.
 */
void
ehci_power(int why, void *v)
{
	ehci_softc_t *sc = v;
	u_int32_t cmd, hcr;
	int s, i;

#ifdef EHCI_DEBUG
	DPRINTF(("ehci_power: sc=%p, why=%d\n", sc, why));
	if (ehcidebug > 0)
		ehci_dump_regs(sc);
#endif

	s = splhardusb();
	switch (why) {
	case PWR_SUSPEND:
d1085 1
a1085 2

	case PWR_RESUME:
d1135 1
d1138 2
a1139 1
	splx(s);
d1141 4
a1144 5
#ifdef EHCI_DEBUG
	DPRINTF(("ehci_power: sc=%p\n", sc));
	if (ehcidebug > 0)
		ehci_dump_regs(sc);
#endif
@


1.106
log
@Call the existing power functions with our activate function for
the suspend and resume operations
ok kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.105 2009/11/24 00:31:13 jakemsr Exp $ */
a1076 1
	case PWR_STANDBY:
@


1.105
log
@fix hardware polling interval calculation.  uaudio on my Logitech webcam
now records properly.

ok miod, yuo
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.104 2009/11/04 19:14:10 kettenis Exp $ */
d1042 7
@


1.104
log
@Get rid of __HAVE_GENERIC_SOFT_INTERRUPTS now that all our platforms support it.

ok jsing@@, miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.103 2009/10/13 19:33:17 pirofti Exp $ */
d3687 1
a3687 1
	if ((1 << (epipe->pipe.endpoint->edesc->bInterval)) *
d3857 1
a3857 1
	i = (1 << epipe->pipe.endpoint->edesc->bInterval);
@


1.103
log
@Get rid of devact enum, substitute it with an int and coresponding defines.

This is needed for the addition of further suspend/resume actions.

Okay deraadt@@, marco@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.102 2009/09/05 10:25:55 miod Exp $ */
a674 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a678 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a2795 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a2796 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a2797 1
#ifdef __HAVE_GENERIC_SOFT_INTERRUPTS
a2798 1
#endif /* __HAVE_GENERIC_SOFT_INTERRUPTS */
a2953 1
#ifdef USB_USE_SOFTINTR
a2954 1
#endif /* USB_USE_SOFTINTR */
a2955 1
#ifdef USB_USE_SOFTINTR
a2956 1
#endif /* USB_USE_SOFTINTR */
@


1.102
log
@Make sure ehci_open() invokes ehci_device_setintr() at splusb; found with
splassert.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.101 2009/07/24 08:15:38 blambert Exp $ */
d1031 1
a1031 1
ehci_activate(struct device *self, enum devact act)
@


1.101
log
@timeout_add -> timeout_add_msec

ok krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.100 2009/06/02 23:49:33 deraadt Exp $ */
d1595 4
a1598 1
		return (ehci_device_setintr(sc, sqh, ival));
@


1.100
log
@ehci_alloc_sqtd_chain() was doing signed math on len, thus the great code
	curlen -= curlen % mps;
can for very large transfers result in an intermediate variable growing
larger than it should.  Probably can't really happen in the real world.
Do the same u_int repairs to the other matching drivers
ok blambert kjell miod kettenis
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.99 2009/04/20 14:11:57 reyk Exp $ */
d3238 1
a3238 1
		timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
d3350 1
a3350 1
		timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
d3525 1
a3525 1
		timeout_add(&xfer->timeout_handle, mstohz(xfer->timeout));
d3626 1
a3626 2
			timeout_add(&xfer->timeout_handle,
			    mstohz(xfer->timeout));
@


1.99
log
@unbreak EHCI_DEBUG - usbd_dump_pipe() is only defined if USB_DEBUG is
also true.  no binary change without EHCI_DEBUG.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.98 2009/02/14 20:05:09 chl Exp $ */
d196 1
a196 1
			    ehci_softc_t *, int, int, usbd_xfer_handle,
d2448 1
a2448 1
ehci_alloc_sqtd_chain(struct ehci_pipe *epipe, ehci_softc_t *sc, int alen,
d2454 2
a2455 2
	int len, curlen, mps;
	int i, iscontrol, forceshort;
d2496 2
a2497 2
				printf("ehci_alloc_sqtd_chain: curlen=0x%x "
				    "len=0x%x offs=0x%x\n", curlen, len,
d2507 1
a2507 1
			    "curlen=%d\n", curlen));
d2513 1
d2515 1
a2515 1
		    "dataphyslastpage=0x%08x len=%d curlen=%d\n",
a2538 2
			cur->qtd.qtd_buffer[i] = htole32(a);
			cur->qtd.qtd_buffer_hi[i] = 0;
d2545 2
d2556 1
a2556 1
		DPRINTFN(10,("ehci_alloc_sqtd_chain: curlen=%d\n", curlen));
d3098 1
a3098 1
	DPRINTFN(5, ("ehci_ctrl_done: length=%d\n", xfer->actlen));
d3132 1
a3132 1
	int len;
d3140 1
a3140 1
	    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
d3296 2
a3297 1
	int len, isread, endpt;
d3300 1
a3300 1
	DPRINTFN(2, ("ehci_device_bulk_start: xfer=%p len=%d flags=%d\n",
d3472 2
a3473 1
	int len, isread, endpt;
d3476 1
a3476 1
	DPRINTFN(2, ("ehci_device_intr_start: xfer=%p len=%d flags=%d\n",
d3587 2
a3588 1
	int len, isread, endpt, s;
d3684 1
a3684 1
	DPRINTFN(2, ("ehci_device_isoc_start: xfer %p len %d flags %d\n",
@


1.98
log
@remove dead assignments and newly created unused variables.

Found by LLVM/Clang Static Analyzer.

ok fgsch@@ krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.97 2008/11/29 08:52:03 mglocker Exp $ */
d1268 1
a1268 1
#ifdef EHCI_DEBUG
d2985 1
a2985 1
#ifdef ECHI_DEBUG
@


1.97
log
@Fix high-speed isoc USB transfers;  64bit capable USB host controllers
have a different transfer descriptor than non-64bit capable ones.

This fixes isoc transfer issues (resulting in broken image data) for
uvideo(4) devices attached to ehci(4) seen on USB Intel host controllers.

From Jeremy Morse via NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.96 2008/11/21 17:08:42 deraadt Exp $ */
a623 1
	usbd_pipe_handle pipe;
a631 2
	pipe = xfer->pipe;

a2862 1
		sqtd = sqtd->nextqtd;
a3652 1
	usbd_device_handle dev;
a3667 1
	dev = xfer->pipe->device;
@


1.96
log
@if interrupt register is all 1s, we know we are dead; ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.95 2008/10/30 08:11:13 mglocker Exp $ */
d879 3
d3812 1
a3812 1
			int page = DMAADDR(dma_buf, page_offs);
d3815 3
a3817 2
			    htole32(EHCI_ITD_SET_BPTR(page) | 
			    EHCI_LINK_ITD);
@


1.95
log
@From Jeremy Morse via NetBSD:

  * Serialize access to the ehci intrlist.
  * Change the ehci intrlist to a tailq so xfers are not queued out of order.
  * In ehci_check_itd_intr, don't treat a transfer error as an indication
    that the xfer is no longer active.

This also fixes "ehci_allocx not free" errors seen recently.

Tested and OK brad@@, kevlo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.94 2008/10/07 11:31:09 mglocker Exp $ */
d570 4
@


1.94
log
@In ehci_free_itd() replace LIST_INSERT_AFTER(LIST_FIRST(..), ..) with
LIST_INSERT_HEAD(..) to prevent a crash when the freelist is empty. From
NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.93 2008/10/06 20:18:56 mglocker Exp $ */
d245 2
a246 2
	LIST_INSERT_HEAD(&(sc)->sc_intrhead, (ex), inext);
#define ehci_del_intr_list(ex) \
d248 2
a249 2
		LIST_REMOVE((ex), inext); \
		(ex)->inext.le_prev = NULL; \
d251 1
a251 1
#define ehci_active_intr_list(ex) ((ex)->inext.le_prev != NULL)
d416 1
d663 2
a664 2
	for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = nextex) {
		nextex = LIST_NEXT(ex, inext);
d670 1
a670 1
	    !LIST_EMPTY(&sc->sc_intrhead)) {
d754 3
d772 1
a782 17
	/*
	 * Step 2, check for errors in status bits, throughout chain...
	 */

	DPRINTFN(12, ("ehci_check_itd_intr: active ex=%p\n", ex));

	for (itd = ex->itdstart; itd != ex->itdend; itd = itd->xfer_next) {
		for (i = 0; i < 8; i++) {
			if (letoh32(itd->itd.itd_ctl[i]) & (EHCI_ITD_BUF_ERR |
			    EHCI_ITD_BABBLE | EHCI_ITD_ERROR))
				break;
		}
		if (i != 8) { /* Error in one of the itds */
			goto done;
		}
	} /* itd search loop */

a785 1

d3090 1
a3090 1
		ehci_del_intr_list(ex);	/* remove from active list */
d3404 1
a3404 1
		ehci_del_intr_list(ex);	/* remove from active list */
d3626 1
a3626 1
		ehci_del_intr_list(ex); /* remove from active list */
d3941 1
a3941 1
		ehci_del_intr_list(exfer);
@


1.93
log
@Don't force multi transaction endpoints (>1024 bytes) down to single
transactions.  From NetBSD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.92 2008/09/15 13:44:09 mglocker Exp $ */
d2678 1
a2678 1
	LIST_INSERT_AFTER(LIST_FIRST(&sc->sc_freeitds), itd, u.free_list);
@


1.92
log
@I forgot to sync the NetBSD Copyright 2004-2008 update.  Fix it.

Spotted by stu@@ and miod@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.91 2008/09/15 11:31:06 mglocker Exp $ */
d3836 1
a3836 3
		j = UE_GET_SIZE(
		    UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize));

@


1.91
log
@Sync ehci-isoc part a bit up with NetBSD:
- Sign over Jeremy Morse's copyright (who contributed ehci-isoc support)
to NetBSD copyright but still mention him as contributor. OK'd by
Jeremy Morse.
- Update TODO list.
- Clarify the error message in case when a low/full speed isoc device
has been attached to ehci.
- Add a missing break so that the isoc setup code doesn't access
uninitialized microframe content which has been request by the driver
but not been used.

OK kevlo@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.90 2008/09/10 14:01:23 blambert Exp $ */
d5 1
a5 1
 * Copyright (c) 2004,2005 The NetBSD Foundation, Inc.
@


1.90
log
@Convert timeout_add() calls using multiples of hz to timeout_add_sec()

Really just the low-hanging fruit of (hopefully) forthcoming timeout
conversions.

ok art@@, krw@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.89 2008/09/08 07:08:27 brad Exp $ */
a5 1
 * Copyright (c) 2008 Jeremy Morse <jeremy.morse@@gmail.com>
d9 2
a10 1
 * by Lennart Augustsson (lennart@@augustsson.net) and by Charles M. Hannum.
d45 2
a46 6
 * 1) The meaty part to implement is isochronous transactions. They are
 *    needed for USB 1 devices below USB 2.0 hubs. They are quite complicated
 *    since they need to be able to do "transaction translation", ie,
 *    converting to/from USB 2 and USB 1.
 *    So the hub driver needs to handle and schedule these things, to
 *    assign place in frame where different devices get to go. See chapter
d50 1
a50 1
*/
d1532 4
a1535 2
		printf("%s: *** Error: opening low/full speed isoc device on"
		    "ehci, this does not work yet. Feel free to implement\n",
d3797 1
@


1.89
log
@expand switch cases so they're not so ugly and easier to read.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.88 2008/08/18 04:28:18 kevlo Exp $ */
d674 1
a674 1
		timeout_add(&sc->sc_tmo_intrlist, hz);
@


1.88
log
@use M_NOWAIT instead of M_WAITOK to cause malloc() to return NULL
ok mglocker
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.87 2008/08/16 16:47:32 mglocker Exp $ */
d391 11
a401 4
	case 0: sc->sc_flsize = 1024; break;
	case 1: sc->sc_flsize = 512; break;
	case 2: sc->sc_flsize = 256; break;
	case 3: return (USBD_IOERROR);
d410 1
a410 1
	for (i = 0; i < sc->sc_flsize; i++) {
a411 1
	}
d865 12
a876 4
		case 1: uframes = 1; break;
		case 2: uframes = 2; break;
		case 3: uframes = 4; break;
		default: uframes = 8; break;
d1338 12
a1349 4
			case EHCI_LINK_ITD: printf("ITD"); break;
			case EHCI_LINK_QH: printf("QH"); break;
			case EHCI_LINK_SITD: printf("SITD"); break;
			case EHCI_LINK_FSTN: printf("FSTN"); break;
d1523 11
a1533 4
	case USB_SPEED_LOW:  speed = EHCI_QH_SPEED_LOW;  break;
	case USB_SPEED_FULL: speed = EHCI_QH_SPEED_FULL; break;
	case USB_SPEED_HIGH: speed = EHCI_QH_SPEED_HIGH; break;
	default: panic("ehci_open: bad device speed %d", dev->speed);
@


1.87
log
@Spacing.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.86 2008/08/16 16:37:30 mglocker Exp $ */
d410 1
a410 1
	    M_USB, M_WAITOK | M_ZERO);
@


1.86
log
@Sync ehci isochronous part with NetBSD:
- Fix check for maximum bInterval value.
- Calculate frames/microframes values slightly different (but with mostly
same result finally).
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.85 2008/08/09 22:59:20 mglocker Exp $ */
d3705 1
a3705 1
	switch (i) { 
d3707 1
a3707 1
		ufrperframe = 8; 
d3710 1
a3710 1
		ufrperframe = 4; 
d3713 1
a3713 1
		ufrperframe = 2; 
d3716 1
a3716 1
		ufrperframe = 1; 
d3718 3
a3720 3
	} 
	frames = (xfer->nframes + (ufrperframe - 1)) / ufrperframe; 
	uframes = 8 / ufrperframe; 
@


1.85
log
@Add isochronous xfer support for ehci(4).  From NetBSD.

OK brad@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.84 2008/06/29 10:04:15 yuo Exp $ */
d1580 1
a1580 1
		if (ed->bInterval == 0 || ed->bInterval >= 16) {
d3641 1
a3641 1
	int i, j, k, frames, uframes;
a3702 11
	} else if (i >= 4) {
		frames = xfer->nframes;
		uframes = 8;
	} else {
		frames = xfer->nframes + 0x7; /* 7 added for rounding up */
		uframes = 0;
		switch (i) {
			case 1: frames /= 8; uframes = 1; break;
			case 2: frames /= 4; uframes = 2; break;
			case 3: frames /= 2; uframes = 4; break;
		}
d3704 17
@


1.84
log
@add usb2.0 to usb1.1(ohci/uchi) handover request to usb subsystem.
add new quirk entry for uvideo which is required isoc transfer.

Some usb2.0 devices use isochronous transfer but current usb
subsystem does not support isoc transfer in ehci(usb2.0) bus.
This patch introduce new psuedo usb hub request UHF_PORT_DISOWN_TO_1_1
to handover the device to ehci to usb1.1 bus(ohci or uhci).

ok mglocker@@ deraadt@@ fgsch@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.83 2008/06/26 05:42:18 ray Exp $ */
d5 2
a6 1
 * Copyright (c) 2004 The NetBSD Foundation, Inc.
d121 4
a124 1
		/* XXX */
d138 2
d205 7
d235 4
d402 5
d409 6
d685 1
a685 2
	ehci_soft_qtd_t *sqtd, *lsqtd;
	u_int32_t status;
d689 15
d705 1
a705 1
		printf("ehci_check_intr: sqtdstart=NULL\n");
d708 1
d712 1
a712 1
		printf("ehci_check_intr: lsqtd==0\n");
d747 57
a831 1

d845 49
d940 4
a943 1

d1406 38
d1448 3
a1450 1
	printf("ehci_dump_exfer: ex=%p\n", ex);
d1453 1
d1507 2
a1508 2
		printf("%s: *** WARNING: opening low/full speed isochronous "
		    "device, this does not work yet.\n",
a1515 25
	sqh = ehci_alloc_sqh(sc);
	if (sqh == NULL)
		goto bad0;
	/* qh_link filled when the QH is added */
	sqh->qh.qh_endp = htole32(
	    EHCI_QH_SET_ADDR(addr) |
	    EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
	    EHCI_QH_SET_EPS(speed) |
	    (xfertype == UE_CONTROL ? EHCI_QH_DTC : 0) |
	    EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
	    (speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
	     EHCI_QH_CTL : 0) |
	    EHCI_QH_SET_NRL(naks));
	sqh->qh.qh_endphub = htole32(
	    EHCI_QH_SET_MULT(1) |
	    EHCI_QH_SET_HUBA(hshubaddr) |
	    EHCI_QH_SET_PORT(hshubport) |
	    EHCI_QH_SET_CMASK(0x1c) | /* XXX */
	    EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0));
	sqh->qh.qh_curqtd = EHCI_NULL;
	/* Fill the overlay qTD */
	sqh->qh.qh_qtd.qtd_next = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_altnext = EHCI_NULL;
	sqh->qh.qh_qtd.qtd_status =
	    htole32(EHCI_QTD_SET_TOGGLE(pipe->endpoint->savedtoggle));
d1517 33
a1549 1
	epipe->sqh = sqh;
d1560 1
a1560 1
			goto bad1;
d1580 13
a1592 1
		return (USBD_INVAL);
d1594 1
d1599 4
a1602 4
bad1:
	ehci_free_sqh(sc, sqh);
bad0:
	return (USBD_NOMEM);
d1711 43
d2585 70
d2713 1
a2713 1
	if (xfer->device->bus->intr_context || !curproc)
d2883 77
d3538 5
d3620 307
a3926 5
usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
usbd_status	ehci_device_isoc_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
void		ehci_device_isoc_abort(usbd_xfer_handle xfer) { }
void		ehci_device_isoc_close(usbd_pipe_handle pipe) { }
void		ehci_device_isoc_done(usbd_xfer_handle xfer) { }
@


1.83
log
@First pass at removing clauses 3 and 4 from NetBSD licenses.

Not sure what's more surprising: how long it took for NetBSD to
catch up to the rest of the BSDs (including UCB), or the amount of
code that NetBSD has claimed for itself without attributing to the
actual authors.

OK deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.82 2008/06/09 23:21:48 kettenis Exp $ */
d1899 6
@


1.82
log
@Don't play games with the PCD interrupt.  It delays the detection of
connect/disconnect events.  From NetBSD.

ok deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.81 2008/06/02 09:58:15 yuo Exp $ */
a18 7
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *        This product includes software developed by the NetBSD
 *        Foundation, Inc. and its contributors.
 * 4. Neither the name of The NetBSD Foundation nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
@


1.81
log
@fix DEBUG flag. without EHCI_DEBUG, ehcidebug is not defined.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.80 2008/05/25 21:00:17 mbalmer Exp $ */
a192 2
void		ehci_pcd_able(ehci_softc_t *, int);
void		ehci_pcd_enable(void *);
a468 1
	timeout_set(&sc->sc_tmo_pcd, ehci_pcd_enable, sc);
a576 7
		/*
		 * Disable PCD interrupt for now, because it will be
		 * on until the port has been reset.
		 */
		ehci_pcd_able(sc, 0);
		/* Do not allow RHSC interrupts > 1 per second */
		timeout_add(&sc->sc_tmo_pcd, hz);
a593 19
ehci_pcd_able(ehci_softc_t *sc, int on)
{
	DPRINTFN(4, ("ehci_pcd_able: on=%d\n", on));
	if (on)
		sc->sc_eintrs |= EHCI_STS_PCD;
	else
		sc->sc_eintrs &= ~EHCI_STS_PCD;
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);
}

void
ehci_pcd_enable(void *v_sc)
{
	ehci_softc_t *sc = v_sc;

	ehci_pcd_able(sc, 1);
}

void
a870 1
	timeout_del(&sc->sc_tmo_pcd);
a1827 15
#if 0
		switch(value) {
		case UHF_C_PORT_CONNECTION:
		case UHF_C_PORT_ENABLE:
		case UHF_C_PORT_SUSPEND:
		case UHF_C_PORT_OVER_CURRENT:
		case UHF_C_PORT_RESET:
			/* Enable RHSC interrupt if condition is cleared. */
			if ((OREAD4(sc, port) >> 16) == 0)
				ehci_pcd_able(sc, 1);
			break;
		default:
			break;
		}
#endif
@


1.80
log
@Don't define EHCI_DEBUG when USB_DEBUG is defined.  This to be consistent
with other USB host controller interfaces.

From Karl Sjodahl <dunceor@@gmail.com>; ok jsg
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.79 2008/05/15 08:10:03 kettenis Exp $ */
d1153 1
a1153 1
#ifdef USB_DEBUG
d2612 1
a2612 1
#ifdef USB_DEBUG
@


1.79
log
@Avoid clearing the port enable bit when bringing the port out of reset.
Makes the on-board ehci(4) on the Freescale MPC8349E work.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.78 2008/04/16 16:08:39 mk Exp $ */
a89 4

#ifdef USB_DEBUG
#define EHCI_DEBUG
#endif
@


1.78
log
@Use the timeout(9) API the right way:  Don't initialize the timeout
cookie all the time, and only call timeout_del if we're not going to
timeout_add right away.

Testing by johan@@, oga@@, sthen@@, and possibly some more people (thanks).

Ok krw@@, oga@@, sthen@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.77 2007/06/15 11:41:47 mbalmer Exp $ */
d1974 2
a1975 1
			EOWRITE4(sc, port, v);
@


1.77
log
@Replace the USB_USE_SOFTINTR macro with __HAVE_GENERIC_SOFT_INTTERUPTS
(which was used to define USB_USE_SOFTINTR).

No binary changes.

ok dlg, mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.76 2007/06/14 12:58:09 mbalmer Exp $ */
d475 2
a476 2
	timeout_set(&sc->sc_tmo_pcd, NULL, NULL);
	timeout_set(&sc->sc_tmo_intrlist, NULL, NULL);
a589 2
		timeout_del(&sc->sc_tmo_pcd);
		timeout_set(&sc->sc_tmo_pcd, ehci_pcd_enable, sc);
a679 2
		timeout_del(&sc->sc_tmo_intrlist);
		timeout_set(&sc->sc_tmo_intrlist, ehci_intrlist_timeout, sc);
@


1.76
log
@Move the mstohz macro out of ubs_port.h and to the three places where it is
used.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.75 2007/06/14 06:55:09 mbalmer Exp $ */
d687 1
a687 1
#ifdef USB_USE_SOFTINTR
d692 1
a692 1
#endif /* USB_USE_SOFTINTR */
d2504 1
a2504 1
#ifdef USB_USE_SOFTINTR
d2506 1
a2506 1
#endif /* USB_USE_SOFTINTR */
d2508 1
a2508 1
#ifdef USB_USE_SOFTINTR
d2510 1
a2510 1
#endif /* USB_USE_SOFTINTR */
@


1.75
log
@Move the inclusion of sys/timeout.h from usb_port.h to the drivers that
need it.

If a USB driver uses timeout(9) functions, the header file sys/timeout.h
must be included.

Tested by me (i386, macppc, sparc64), ckuethe (amd64), & todd (sparc, zaurus).

ok dlg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.74 2007/06/12 16:26:36 mbalmer Exp $ */
d104 2
@


1.74
log
@Remove the definition and use of the device_ptr_t which was a struct device *.

No binary change.

ok mk.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.73 2007/06/10 14:49:00 mbalmer Exp $ */
d71 1
@


1.73
log
@Remove the definition and use of the USBDEVNAME macro.

(This might look easy, but it was a big diff.  Thanks to dlg and especially jsg
for looking over it; we found at least four mistakes in the initial diff.)

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.72 2007/06/10 10:15:35 mbalmer Exp $ */
d921 1
a921 1
ehci_activate(device_ptr_t self, enum devact act)
@


1.72
log
@Remove definitions and usage of usb_callout and related macros.  These macros
were used as a layer of confusion^Wabstraction around the timeout(9) API.

No binary change.

ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.71 2007/06/05 08:43:55 mbalmer Exp $ */
d344 1
a344 1
	DPRINTF(("%s: EHCI version %x.%x\n", USBDEVNAME(sc->sc_bus.bdev),
d363 1
a363 1
	DPRINTF(("%s: resetting\n", USBDEVNAME(sc->sc_bus.bdev)));
d375 1
a375 1
		    USBDEVNAME(sc->sc_bus.bdev));
d393 1
a393 1
	DPRINTF(("%s: flsize=%d\n", USBDEVNAME(sc->sc_bus.bdev),sc->sc_flsize));
d495 1
a495 1
		printf("%s: run timeout\n", USBDEVNAME(sc->sc_bus.bdev));
d576 1
a576 1
		       USBDEVNAME(sc->sc_bus.bdev));
d600 1
a600 1
		       USBDEVNAME(sc->sc_bus.bdev), eintrs);
d660 1
a660 1
	DPRINTFN(10,("%s: ehci_softintr (%d)\n", USBDEVNAME(sc->sc_bus.bdev),
d986 1
a986 1
			    USBDEVNAME(sc->sc_bus.bdev));
d1000 1
a1000 1
			    USBDEVNAME(sc->sc_bus.bdev));
d1050 1
a1050 1
			    USBDEVNAME(sc->sc_bus.bdev));
d1359 1
a1359 1
		    USBDEVNAME(sc->sc_bus.bdev));
d1986 1
a1986 1
				    USBDEVNAME(sc->sc_bus.bdev));
@


1.71
log
@Remove the "Static" declaration of many functions.  It was defined to be empty
and it was not consistently used.  It was confusing as it suggested these
functions were static, which they were not.

discussed with dlg and jsg, ok jsg.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.70 2007/06/04 10:34:04 mbalmer Exp $ */
d472 2
a473 2
	usb_callout_init(sc->sc_tmo_pcd);
	usb_callout_init(sc->sc_tmo_intrlist);
d587 3
a589 1
		usb_callout(sc->sc_tmo_pcd, hz, ehci_pcd_enable, sc);
d678 5
a682 3
	    !LIST_EMPTY(&sc->sc_intrhead))
		usb_callout(sc->sc_tmo_intrlist, hz,
			    ehci_intrlist_timeout, sc);
d739 1
a739 1
	usb_uncallout(ex->xfer.timeout_handle, ehci_timeout, ex);
d904 2
a905 2
	usb_uncallout(sc->sc_tmo_intrlist, ehci_intrlist_timeout, sc);
	usb_uncallout(sc->sc_tmo_pcd, ehci_pcd_enable, sc);
d2431 1
a2431 1
		usb_uncallout(xfer->timeout_handle, ehci_timeout, xfer);
d2465 1
a2465 1
	usb_uncallout(xfer->timeout_handle, ehci_timeout, xfer);
d2866 3
a2868 2
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
		    ehci_timeout, xfer);
d2977 3
a2979 2
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
		    ehci_timeout, xfer);
d3150 5
a3154 3
	if (xfer->timeout && !sc->sc_bus.use_polling)
		usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
		    ehci_timeout, xfer);
d3246 4
a3249 2
			usb_callout(xfer->timeout_handle,
			    mstohz(xfer->timeout), ehci_timeout, xfer);
@


1.70
log
@Last part of FreeBSD/NetBSD sepcific code removal.

ok jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.69 2007/05/21 06:10:43 jsg Exp $ */
d132 1
a132 1
Static u_int8_t		ehci_reverse_bits(u_int8_t, int);
d134 1
a134 1
Static void		ehci_power(int, void *);
d136 68
a203 68
Static usbd_status	ehci_open(usbd_pipe_handle);
Static void		ehci_poll(struct usbd_bus *);
Static void		ehci_softintr(void *);
Static int		ehci_intr1(ehci_softc_t *);
Static void		ehci_waitintr(ehci_softc_t *, usbd_xfer_handle);
Static void		ehci_check_intr(ehci_softc_t *, struct ehci_xfer *);
Static void		ehci_idone(struct ehci_xfer *);
Static void		ehci_timeout(void *);
Static void		ehci_timeout_task(void *);
Static void		ehci_intrlist_timeout(void *);

Static usbd_status	ehci_allocm(struct usbd_bus *, usb_dma_t *, u_int32_t);
Static void		ehci_freem(struct usbd_bus *, usb_dma_t *);

Static usbd_xfer_handle	ehci_allocx(struct usbd_bus *);
Static void		ehci_freex(struct usbd_bus *, usbd_xfer_handle);

Static usbd_status	ehci_root_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ehci_root_ctrl_start(usbd_xfer_handle);
Static void		ehci_root_ctrl_abort(usbd_xfer_handle);
Static void		ehci_root_ctrl_close(usbd_pipe_handle);
Static void		ehci_root_ctrl_done(usbd_xfer_handle);

Static usbd_status	ehci_root_intr_transfer(usbd_xfer_handle);
Static usbd_status	ehci_root_intr_start(usbd_xfer_handle);
Static void		ehci_root_intr_abort(usbd_xfer_handle);
Static void		ehci_root_intr_close(usbd_pipe_handle);
Static void		ehci_root_intr_done(usbd_xfer_handle);

Static usbd_status	ehci_device_ctrl_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_ctrl_start(usbd_xfer_handle);
Static void		ehci_device_ctrl_abort(usbd_xfer_handle);
Static void		ehci_device_ctrl_close(usbd_pipe_handle);
Static void		ehci_device_ctrl_done(usbd_xfer_handle);

Static usbd_status	ehci_device_bulk_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_bulk_start(usbd_xfer_handle);
Static void		ehci_device_bulk_abort(usbd_xfer_handle);
Static void		ehci_device_bulk_close(usbd_pipe_handle);
Static void		ehci_device_bulk_done(usbd_xfer_handle);

Static usbd_status	ehci_device_intr_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_intr_start(usbd_xfer_handle);
Static void		ehci_device_intr_abort(usbd_xfer_handle);
Static void		ehci_device_intr_close(usbd_pipe_handle);
Static void		ehci_device_intr_done(usbd_xfer_handle);

Static usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle);
Static usbd_status	ehci_device_isoc_start(usbd_xfer_handle);
Static void		ehci_device_isoc_abort(usbd_xfer_handle);
Static void		ehci_device_isoc_close(usbd_pipe_handle);
Static void		ehci_device_isoc_done(usbd_xfer_handle);

Static void		ehci_device_clear_toggle(usbd_pipe_handle pipe);
Static void		ehci_noop(usbd_pipe_handle pipe);

Static int		ehci_str(usb_string_descriptor_t *, int, const char *);
Static void		ehci_pcd(ehci_softc_t *, usbd_xfer_handle);
Static void		ehci_pcd_able(ehci_softc_t *, int);
Static void		ehci_pcd_enable(void *);
Static void		ehci_disown(ehci_softc_t *, int, int);

Static ehci_soft_qh_t  *ehci_alloc_sqh(ehci_softc_t *);
Static void		ehci_free_sqh(ehci_softc_t *, ehci_soft_qh_t *);

Static ehci_soft_qtd_t  *ehci_alloc_sqtd(ehci_softc_t *);
Static void		ehci_free_sqtd(ehci_softc_t *, ehci_soft_qtd_t *);
Static usbd_status	ehci_alloc_sqtd_chain(struct ehci_pipe *,
d206 1
a206 1
Static void		ehci_free_sqtd_chain(ehci_softc_t *, ehci_soft_qtd_t *,
d209 1
a209 1
Static usbd_status	ehci_device_request(usbd_xfer_handle xfer);
d211 1
a211 1
Static usbd_status	ehci_device_setintr(ehci_softc_t *, ehci_soft_qh_t *,
d214 2
a215 2
Static void		ehci_add_qh(ehci_soft_qh_t *, ehci_soft_qh_t *);
Static void		ehci_rem_qh(ehci_softc_t *, ehci_soft_qh_t *,
d217 2
a218 2
Static void		ehci_set_qh_qtd(ehci_soft_qh_t *, ehci_soft_qtd_t *);
Static void		ehci_sync_hc(ehci_softc_t *);
d220 2
a221 2
Static void		ehci_close_pipe(usbd_pipe_handle, ehci_soft_qh_t *);
Static void		ehci_abort_xfer(usbd_xfer_handle, usbd_status);
d224 8
a231 8
Static void		ehci_dump_regs(ehci_softc_t *);
Static void		ehci_dump(void);
Static ehci_softc_t	*theehci;
Static void		ehci_dump_link(ehci_link_t, int);
Static void		ehci_dump_sqtds(ehci_soft_qtd_t *);
Static void		ehci_dump_sqtd(ehci_soft_qtd_t *);
Static void		ehci_dump_qtd(ehci_qtd_t *);
Static void		ehci_dump_sqh(ehci_soft_qh_t *);
d233 1
a233 1
Static void		ehci_dump_exfer(struct ehci_xfer *);
d250 1
a250 1
Static struct usbd_bus_methods ehci_bus_methods = {
d260 1
a260 1
Static struct usbd_pipe_methods ehci_root_ctrl_methods = {
d269 1
a269 1
Static struct usbd_pipe_methods ehci_root_intr_methods = {
d278 1
a278 1
Static struct usbd_pipe_methods ehci_device_ctrl_methods = {
d287 1
a287 1
Static struct usbd_pipe_methods ehci_device_intr_methods = {
d296 1
a296 1
Static struct usbd_pipe_methods ehci_device_bulk_methods = {
d305 1
a305 1
Static struct usbd_pipe_methods ehci_device_isoc_methods = {
d319 1
a319 1
Static u_int8_t
d534 1
a534 1
Static int
d1147 1
a1147 1
Static void
d1165 1
a1165 1
Static void
d1294 1
a1294 1
Static void
d1542 1
a1542 1
Static usb_device_descriptor_t ehci_devd = {
d1555 1
a1555 1
Static usb_device_qualifier_t ehci_odevd = {
d1567 1
a1567 1
Static usb_config_descriptor_t ehci_confd = {
d1580 1
a1580 1
Static usb_interface_descriptor_t ehci_ifcd = {
d1592 1
a1592 1
Static usb_endpoint_descriptor_t ehci_endpd = {
d1601 1
a1601 1
Static usb_hub_descriptor_t ehci_hubd = {
d1611 1
a1611 1
Static int
d1631 1
a1631 1
Static usbd_status
d1645 1
a1645 1
Static usbd_status
d2046 1
a2046 1
Static void
d2053 1
a2053 1
Static void
d2065 1
a2065 1
Static usbd_status
d2079 1
a2079 1
Static usbd_status
d2094 1
a2094 1
Static void
d2110 1
a2110 1
Static void
d2360 1
a2360 1
Static void
d2664 1
a2664 1
Static usbd_status
d2678 1
a2678 1
Static usbd_status
d2728 1
a2728 1
Static void
d2736 1
a2736 1
Static void
d2897 1
a2897 1
Static usbd_status
d3002 1
a3002 1
Static void
d3012 1
a3012 1
Static void
d3041 1
a3041 1
Static usbd_status
d3068 1
a3068 1
Static usbd_status
d3085 1
a3085 1
Static usbd_status
d3170 1
a3170 1
Static void
d3181 1
a3181 1
Static void
d3192 1
a3192 1
Static void
d3253 5
a3257 5
Static usbd_status	ehci_device_isoc_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static usbd_status	ehci_device_isoc_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static void		ehci_device_isoc_abort(usbd_xfer_handle xfer) { }
Static void		ehci_device_isoc_close(usbd_pipe_handle pipe) { }
Static void		ehci_device_isoc_done(usbd_xfer_handle xfer) { }
@


1.69
log
@Remove le{16,32}toh macros
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.68 2007/05/20 00:52:25 jsg Exp $ */
a85 1
#if defined(__OpenBSD__)
a88 1
#endif
a97 1
#ifndef __NetBSD__
a98 1
#endif
a1051 6
#if defined(__NetBSD__)
	case PWR_SOFTSUSPEND:
	case PWR_SOFTSTANDBY:
	case PWR_SOFTRESUME:
		break;
#endif
@


1.68
log
@Convert ehci and ucom to rwlock.
Kill the usb specific lockmgr wrapper as nothing uses it now.

ok thib@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.67 2006/08/22 01:53:42 pascoe Exp $ */
d719 1
a719 1
	if (le32toh(lsqtd->qtd.qtd_status) & EHCI_QTD_ACTIVE) {
d722 1
a722 1
			status = le32toh(sqtd->qtd.qtd_status);
d791 1
a791 1
		nstatus = le32toh(sqtd->qtd.qtd_status);
d1213 1
a1213 1
	link = le32toh(link);
d1262 1
a1262 1
	s = le32toh(qtd->qtd_status);
d1272 1
a1272 1
		printf("  buffer[%d]=0x%08x\n", s, le32toh(qtd->qtd_buffer[s]));
d1283 1
a1283 1
	endp = le32toh(qh->qh_endp);
d1292 1
a1292 1
	endphub = le32toh(qh->qh_endphub);
d2404 1
a2404 1
	    EHCI_QTD_GET_TOGGLE(le32toh(sqh->qh.qh_qtd.qtd_status));
d2528 1
a2528 1
	cur = EHCI_LINK_ADDR(le32toh(sqh->qh.qh_curqtd));
d2546 1
a2546 1
		if (EHCI_LINK_ADDR(le32toh(sqtd->qtd.qtd_next)) == us)
d2548 1
a2548 1
		if (EHCI_LINK_ADDR(le32toh(sqtd->qtd.qtd_altnext)) == us)
@


1.67
log
@Deactivate the QTDs when removing a queue head to prevent the host
controller from reactivating it.  Slight variation on what is
suggested in the EHCI spec to work around problems with VIA
controllers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.66 2006/08/22 01:34:08 pascoe Exp $ */
d65 1
d479 1
a479 1
	lockinit(&sc->sc_doorbell_lock, PZERO, "ehcidb", 0, 0);
d1524 1
a1524 1
	usb_lockmgr(&sc->sc_doorbell_lock, LK_EXCLUSIVE, NULL, curproc);
d1539 1
a1539 1
	usb_lockmgr(&sc->sc_doorbell_lock, LK_RELEASE, NULL, curproc);
@


1.66
log
@Be more aggressive about waiting for the host controller doorbell,
re-requesting it at half second intervals for up to five seconds.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.65 2006/08/17 03:44:56 pascoe Exp $ */
d2465 1
a2465 1
	 * Step 1: Make interrupt routine and hardware ignore xfer.
d2484 15
a2498 1
	 * Step 3:  make sure the soft interrupt routine
d2515 1
a2515 1
	 * Step 4: Remove any vestiges of the xfer from the hardware.
d2594 1
d2596 1
a2596 1
	 * Step 4: Execute callback.
@


1.65
log
@EHCI_NULL is already endian swapped.  Don't swap it back.

ok dlg
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.64 2006/08/14 00:41:11 pascoe Exp $ */
d1515 1
d1525 11
a1535 7
	/* ask for doorbell */
	EOWRITE4(sc, EHCI_USBCMD, EOREAD4(sc, EHCI_USBCMD) | EHCI_CMD_IAAD);
	DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
	    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
	error = tsleep(&sc->sc_async_head, PZERO, "ehcidi", hz); /* bell wait */
	DPRINTFN(1,("ehci_sync_hc: cmd=0x%08x sts=0x%08x\n",
	    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
@


1.64
log
@Pull in abort path code from FreeBSD.  Without this, the hardware data toggle
code doesn't work correctly when errored transactions occur.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.63 2006/08/14 00:28:07 pascoe Exp $ */
d2516 1
a2516 1
	next = snext ? snext->physaddr : htole32(EHCI_NULL);
d2569 1
a2569 2
				    sqh->qh.qh_qtd.qtd_altnext
				        = htole32(EHCI_NULL);
@


1.63
log
@Fix mismerge in PWR_RESUME path.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.62 2006/08/06 12:12:44 pascoe Exp $ */
d459 2
a460 1
	sqh->next = NULL;
d739 1
d1125 3
d1442 2
d1451 1
d1454 2
d1468 1
a1472 2
	ehci_soft_qh_t *p;

d1475 4
a1478 7
	for (p = head; p != NULL && p->next != sqh; p = p->next)
		;
	if (p == NULL)
		panic("ehci_rem_qh: ED not found");
	p->next = sqh->next;
	p->qh.qh_link = sqh->qh.qh_link;

d2161 1
a2410 1
 * XXX This is most probably wrong.
d2419 2
a2420 3
	ehci_soft_qtd_t *sqtd;
	ehci_physaddr_t cur;
	u_int32_t qhstatus;
d2423 1
d2432 1
d2442 18
d2463 1
d2466 1
a2466 7
	qhstatus = sqh->qh.qh_qtd.qtd_status;
	sqh->qh.qh_qtd.qtd_status = qhstatus | htole32(EHCI_QTD_HALTED);
	for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
		sqtd->qtd.qtd_status |= htole32(EHCI_QTD_HALTED);
		if (sqtd == exfer->sqtdend)
			break;
	}
d2471 12
a2485 1
	ehci_sync_hc(sc);
a2493 1
	splx(s);
d2496 1
a2496 1
	 * Step 3: Remove any vestiges of the xfer from the hardware.
d2498 9
a2506 3
	 * beyond the xfer we're trying to abort.  So as we're scanning
	 * the TDs of this xfer we check if the hardware points to
	 * any of them.
a2507 1
	s = splusb();		/* XXX why? */
d2510 22
a2531 4
	for (sqtd = exfer->sqtdstart; ; sqtd = sqtd->nextqtd) {
		hit |= cur == sqtd->physaddr;
		if (sqtd == exfer->sqtdend)
			break;
d2533 41
a2573 8
	sqtd = sqtd->nextqtd;
	/* Zap curqtd register if hardware pointed inside the xfer. */
	if (hit && sqtd != NULL) {
		DPRINTFN(1,("ehci_abort_xfer: cur=0x%08x\n", sqtd->physaddr));
		sqh->qh.qh_curqtd = htole32(sqtd->physaddr); /* unlink qTDs */
		sqh->qh.qh_qtd.qtd_status = qhstatus;
	} else {
		DPRINTFN(1,("ehci_abort_xfer: no hit\n"));
d2575 1
a2575 1

d2582 6
a2612 1
	usb_init_task(&exfer->abort_task, ehci_timeout_task, addr);
@


1.62
log
@Minor spelling and whitespace fixes - for diff reduction.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.61 2006/06/23 06:27:11 miod Exp $ */
d1015 1
a1015 1
			if ((cmd & (EHCI_PS_PO|EHCI_PS_SUSP)) == EHCI_PS_SUSP)
d1018 2
a1019 1
			hcr = 1;
@


1.61
log
@In a drivers activate() entry point, if on DVACT_DEACTIVATE it does
something, then it MUST return zero on DVACT_ACTIVATE, not EOPNOTSUPP;
this very popular bug has been cut and pasted a lot of times...
ok deraadt@@ mickey@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.60 2006/05/31 07:27:28 dlg Exp $ */
d87 1
a87 1
        NULL, "ehci", DV_DULL
d210 1
a210 1
					    ehci_soft_qtd_t *);
d219 1
a219 1
				    ehci_soft_qh_t *);
d229 1
a229 1
Static ehci_softc_t 	*theehci;
d589 1
a589 1
                usb_callout(sc->sc_tmo_pcd, hz, ehci_pcd_enable, sc);
d1328 1
a1328 1
    		hshubport = dev->myhsport->portno;
d1548 1
a1548 1
	1,2,0,			/* string indices */
d2334 1
a2334 1
			if (! forceshort) {
a2335 1
			}
d2760 1
a2760 1
                usb_callout(xfer->timeout_handle, mstohz(xfer->timeout),
d2843 1
a2843 1
		DPRINTFN(-1,("ehci_device_bulk_transfer: no memory\n"));
d3073 1
a3073 1
		DPRINTFN(1, ("echi_device_intr_abort: remove\n"));
@


1.60
log
@make non debug kernels compile again
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.59 2006/05/31 06:59:56 pascoe Exp $ */
d925 1
a925 1
		return (EOPNOTSUPP);
@


1.59
log
@Let the EHCI hardware track the toggle state for bulk and interrupt
transfers. This fixes some cases where the software toggle tracking
was not doing the right thing.  For example, a short transfer that
transferred 0 bytes of the requested qTD transfer size does cause
a toggle change, but the existing code was assuming it didn't.

Derived from work in FreeBSD.

Fixes at least one USB2 cdce device, which would otherwise drop
every second packet due to incorrect toggle state.

commit it, dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.56 2006/05/29 04:02:10 pascoe Exp $ */
d745 1
d747 1
@


1.58
log
@Save and restore the data toggle value when a pipe to an endpoint
is closed and then reopened.  This may be necessary now that
we no longer clear endpoint stalls every time a pipe is opened.
Previously we could assume an initial toggle value of zero because
a clear-stall operation resets the device's toggle state.

Derived from work in FreeBSD.

This is most likely to affect devices like printers, which open
pipes for short periods of time and close them again.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.57 2006/05/30 19:21:07 pascoe Exp $ */
a108 1
	int nexttoggle;
a748 1
	uint pkts_left;
a798 20
	/*
	 * If there are left over TDs we need to update the toggle.
	 * The default pipe doesn't need it since control transfers
	 * start the toggle at 0 every time.
	 */
	if (sqtd != lsqtd->nextqtd &&
	    xfer->pipe->device->default_pipe != xfer->pipe) {
		DPRINTF(("ehci_idone: need toggle update status=%08x "
		    "nstatus=%08x\n", status, nstatus));
		epipe->nexttoggle = EHCI_QTD_GET_TOGGLE(nstatus);
	}

	/*
	 * For a short transfer we need to update the toggle for the missing
	 * packets within the qTD.
	 */
	pkts_left = EHCI_QTD_GET_BYTES(status) /
	    UGETW(xfer->pipe->endpoint->edesc->wMaxPacketSize);
	epipe->nexttoggle ^= pkts_left % 2;

d1159 5
a1163 1
	epipe->nexttoggle = 0;
a1331 2
	epipe->nexttoggle = 0;

d1371 1
a1371 1
	    EHCI_QH_DTC |
d2222 1
a2222 1
	int i, tog, forceshort;
d2228 3
a2236 2
	tog = epipe->nexttoggle;
	qtdstatus |= EHCI_QTD_SET_TOGGLE(tog);
d2239 6
d2322 9
a2330 4
		/* adjust the toggle based on the number of packets
		 * in this qtd */
		if ((((curlen + mps - 1) / mps) & 1) || curlen == 0)
			tog ^= 1;
a2342 1
	epipe->nexttoggle = tog;
a2696 2
		/* Start toggle at 1. */
		epipe->nexttoggle = 1;
@


1.57
log
@If a zero-length bulk or interrupt transfer is requested then assume
USBD_FORCE_SHORT_XFER to ensure that we actually build and execute
a transfer.

Based on changes in FreeBSD rev1.47
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.56 2006/05/29 04:02:10 pascoe Exp $ */
d1406 2
a1407 1
	sqh->qh.qh_qtd.qtd_status = htole32(0);
d2397 2
@


1.56
log
@Eliminate variable shadowing.

From NetBSD r1.104
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.55 2006/05/29 00:16:10 pascoe Exp $ */
d2241 1
a2241 1
	int i, tog;
a2242 1
	u_int16_t flags = xfer->flags;
d2255 2
d2302 1
a2302 3
		if (len != 0 ||
		    ((curlen % mps) == 0 && !rd && curlen != 0 &&
		     (flags & USBD_FORCE_SHORT_XFER))) {
d2334 3
a2336 3
		/* adjust the toggle based on the number of packets in this
		   qtd */
		if (((curlen + mps - 1) / mps) & 1) {
d2338 5
a2342 1
			qtdstatus ^= EHCI_QTD_TOGGLE_MASK;
a2343 2
		if (next == NULL)
			break;
@


1.55
log
@Make sure all physical addresses are filled in the qTD even when we have
a page offset.

From Dan Ellis via NetBSD rev 1.103
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.54 2006/05/28 23:52:27 pascoe Exp $ */
d196 1
a196 1
Static int		ehci_str(usb_string_descriptor_t *, int, char *);
d342 1
a342 1
	u_int32_t version;
d347 1
a347 1
	version = EREAD2(sc, EHCI_HCIVERSION);
d349 1
a349 1
	    version >> 8, version & 0xff));
d1626 1
a1626 1
ehci_str(usb_string_descriptor_t *p, int l, char *s)
@


1.54
log
@Make sure to honor the USBD_FORCE_SHORT_XFER flag and generate an empty
transfer when necessary.

From Dan Ellis via NetBSD rev 1.102
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.53 2005/12/03 03:40:52 brad Exp $ */
d2313 2
a2314 1
		for (i = 0; i * EHCI_PAGE_SIZE < curlen; i++) {
@


1.53
log
@Allow strings descriptor 0 to be fetched.  It's the default language index.

From augustss NetBSD

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.52 2005/11/21 18:16:42 millert Exp $ */
d2243 1
d2296 8
a2303 1
		if (len != 0) {
d2340 1
a2340 1
		if (len == 0)
@


1.52
log
@Move contents of sys/select.h to sys/selinfo.h in preparation for a
userland-visible sys/select.h.  Consistent with what Net and Free do.
OK deraadt@@, tested with full ports build by naddy@@.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.51 2005/11/15 07:02:37 miod Exp $ */
d482 1
a482 1
	    EHCI_CMD_ITC_2 | /* 2 microframes */
d1763 3
@


1.51
log
@More typos (especially indicies -> indices), checked with jmc@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.50 2005/10/04 22:55:30 brad Exp $ */
d67 1
a67 1
#include <sys/select.h>
@


1.50
log
@Make sure we don't enable host controller interrupts until all
initialization is finished.

From augustss NetBSD

ok dlg@@ pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.49 2005/09/24 07:28:58 pascoe Exp $ */
d1565 1
a1565 1
	1,2,0,			/* string indicies */
@


1.49
log
@Force takeover of host ports after hibernate/resume, otherwise devices will
incorrectly attach to the companion controller.

Patch from Sebastiaan Indesteege on tech@@

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.48 2005/04/11 08:09:32 dlg Exp $ */
a479 3
	/* Enable interrupts */
	EOWRITE4(sc, EHCI_USBINTR, sc->sc_eintrs);

d501 4
@


1.48
log
@get rid of the lines on ehci attach that show the version and the companion
controllers. remove the insane amount of support code needed just for the
printing of the companion controllers while here.

zap it deraadt@@ sure pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.47 2005/04/10 09:57:02 dlg Exp $ */
d1051 1
d1053 2
a1054 1
		EOWRITE4(sc, EHCI_USBCMD, sc->sc_cmd);
@


1.47
log
@mostly knf while here remove the todo item regarding deferring attach of
devices. usb probe/attach now happens before root is mounted so there is no
requirement to do anything special anymore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.46 2005/04/10 04:22:51 dlg Exp $ */
a61 3
#include "ohci.h"
#include "uhci.h"

d336 1
a336 1
	u_int32_t version, sparams, cparams, hcr;
a340 1
	DPRINTF(("ehci_init: start\n"));
d342 1
d344 6
a353 4
	version = EREAD2(sc, EHCI_HCIVERSION);
	printf("%s: EHCI version %x.%x\n", USBDEVNAME(sc->sc_bus.bdev),
	    version >> 8, version & 0xff);

a355 20
	sc->sc_npcomp = EHCI_HCS_N_PCC(sparams);
	if (EHCI_HCS_N_CC(sparams) != sc->sc_ncomp) {
		printf("%s: wrong number of companions (%d != %d)\n",
		    USBDEVNAME(sc->sc_bus.bdev),
		    EHCI_HCS_N_CC(sparams), sc->sc_ncomp);
#if NOHCI == 0 || NUHCI == 0
		printf("%s: ohci or uhci probably not configured\n",
		    USBDEVNAME(sc->sc_bus.bdev));
#endif
		return (USBD_IOERROR);
	}
	if (sc->sc_ncomp > 0) {
		printf("%s: companion controller%s, %d port%s each:",
		    USBDEVNAME(sc->sc_bus.bdev), sc->sc_ncomp!=1 ? "s" : "",
		    EHCI_HCS_N_PCC(sparams),
		    EHCI_HCS_N_PCC(sparams)!=1 ? "s" : "");
		for (i = 0; i < sc->sc_ncomp; i++)
			printf(" %s", USBDEVNAME(sc->sc_comps[i]->bdev));
		printf("\n");
	}
a2045 1
#if 0
d2047 1
a2047 16
#endif
#ifdef EHCI_DEBUG
	if (sc->sc_npcomp != 0) {
		int i = (index-1) / sc->sc_npcomp;
		if (i >= sc->sc_ncomp)
			DPRINTF(("%s: strange port\n",
			    USBDEVNAME(sc->sc_bus.bdev)));
		else
			DPRINTF(("%s: handing over %s speed device on "
			    "port %d to %s\n", USBDEVNAME(sc->sc_bus.bdev),
			    lowspeed ? "low" : "full", index,
			    USBDEVNAME(sc->sc_comps[i]->bdev)));
	} else {
		DPRINTF(("%s: npcomp == 0\n", USBDEVNAME(sc->sc_bus.bdev)));
	}
#endif
@


1.46
log
@properly handle suspend/resume of ports with devices attached. devices
should not detach and reattach when you resume now.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.45 2005/03/13 02:54:04 pascoe Exp $ */
a46 1
 *
d51 1
a51 3
 * 1) Hold off explorations by companion controllers until ehci has started.
 *
 * 2) The meaty part to implement is isochronous transactions. They are
d59 1
a59 1
 * 3) Command failures are not recovered correctly.
a61 5
#include <sys/cdefs.h>
#if defined(__NetBSD__)
__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.66 2004/06/30 03:11:56 mycroft Exp $");
#endif

d96 1
a96 1
#endif /* USB_DEBUG */
d353 1
a353 1
	       version >> 8, version & 0xff);
d360 2
a361 2
		       USBDEVNAME(sc->sc_bus.bdev),
		       EHCI_HCS_N_CC(sparams), sc->sc_ncomp);
d364 1
a364 1
			     USBDEVNAME(sc->sc_bus.bdev));
d381 2
a382 2
	if (EHCI_HCC_64BIT(cparams)) {
		/* MUST clear segment register if 64 bit capable. */
a383 1
	}
d488 1
a488 1
	if (ehcidebug) {
a489 1
	}
d506 5
a510 5
		 EHCI_CMD_ITC_2 | /* 2 microframes */
		 (EOREAD4(sc, EHCI_USBCMD) & EHCI_CMD_FLS_M) |
		 EHCI_CMD_ASE |
		 EHCI_CMD_PSE |
		 EHCI_CMD_RS);
d578 1
a578 2
		     sc, (u_int)intrs, EOREAD4(sc, EHCI_USBSTS),
		     (u_int)eintrs));
d1151 3
a1153 4
		if (xfer->busy_free != XFER_FREE) {
			printf("ehci_allocx: xfer=%p not free, 0x%08x\n", xfer,
			       xfer->busy_free);
		}
d1155 1
a1155 1
	} else {
d1157 1
a1157 1
	}
d1176 1
a1176 1
		       xfer->busy_free);
d1194 1
a1194 1
		 epipe, epipe->sqh->qh.qh_qtd.qtd_status));
d1212 1
d1214 3
a1216 3
	       EOREAD4(sc, EHCI_USBCMD),
	       EOREAD4(sc, EHCI_USBSTS),
	       EOREAD4(sc, EHCI_USBINTR));
d1218 4
a1221 4
	       EOREAD4(sc, EHCI_FRINDEX),
	       EOREAD4(sc, EHCI_CTRLDSSEGMENT),
	       EOREAD4(sc, EHCI_PERIODICLISTBASE),
	       EOREAD4(sc, EHCI_ASYNCLISTADDR));
d1224 1
a1224 1
		       EOREAD4(sc, EHCI_PORTSC(i)));
d1290 3
a1292 3
	bitmask_snprintf(EHCI_QTD_GET_STATUS(s),
			 "\20\10ACTIVE\7HALTED\6BUFERR\5BABBLE\4XACTERR"
			 "\3MISSED\2SPLIT\1PING", sbuf, sizeof(sbuf));
d1294 2
a1295 2
	       s, EHCI_QTD_GET_TOGGLE(s), EHCI_QTD_GET_BYTES(s),
	       EHCI_QTD_GET_IOC(s), EHCI_QTD_GET_C_PAGE(s));
d1297 1
a1297 1
	       EHCI_QTD_GET_PID(s), sbuf);
d1313 3
a1315 3
	       EHCI_QH_GET_ADDR(endp), EHCI_QH_GET_INACT(endp),
	       EHCI_QH_GET_ENDPT(endp),  EHCI_QH_GET_EPS(endp),
	       EHCI_QH_GET_DTC(endp), EHCI_QH_GET_HRECL(endp));
d1317 2
a1318 2
	       EHCI_QH_GET_MPL(endp), EHCI_QH_GET_CTL(endp),
	       EHCI_QH_GET_NRL(endp));
d1322 3
a1324 3
	       EHCI_QH_GET_SMASK(endphub), EHCI_QH_GET_CMASK(endphub),
	       EHCI_QH_GET_HUBA(endphub), EHCI_QH_GET_PORT(endphub),
	       EHCI_QH_GET_MULT(endphub));
d1337 1
a1337 1
#endif
d1355 1
a1355 1
		     pipe, addr, ed->bEndpointAddress, sc->sc_addr));
d1406 8
a1413 9
		EHCI_QH_SET_ADDR(addr) |
		EHCI_QH_SET_ENDPT(UE_GET_ADDR(ed->bEndpointAddress)) |
		EHCI_QH_SET_EPS(speed) |
		EHCI_QH_DTC |
		EHCI_QH_SET_MPL(UGETW(ed->wMaxPacketSize)) |
		(speed != EHCI_QH_SPEED_HIGH && xfertype == UE_CONTROL ?
		 EHCI_QH_CTL : 0) |
		EHCI_QH_SET_NRL(naks)
		);
d1415 5
a1419 6
		EHCI_QH_SET_MULT(1) |
		EHCI_QH_SET_HUBA(hshubaddr) |
		EHCI_QH_SET_PORT(hshubport) |
		EHCI_QH_SET_CMASK(0x1c) | /* XXX */
		EHCI_QH_SET_SMASK(xfertype == UE_INTERRUPT ? 0x01 : 0)
		);
d1431 1
a1431 1
				   0, &epipe->u.ctl.reqdma);
d1463 1
a1463 1
 bad1:
d1465 1
a1465 1
 bad0:
d1555 1
a1555 1
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
d1558 1
a1558 1
		    EOREAD4(sc, EHCI_USBCMD), EOREAD4(sc, EHCI_USBSTS)));
d1763 1
a1763 1
				value >> 8;
d1843 1
a1843 2
			     "port=%d feature=%d\n",
			     index, value));
d1861 2
a1862 2
			DPRINTFN(2,("ehci_root_ctrl_start: clear port test "
				    "%d\n", index));
d1865 2
a1866 2
			DPRINTFN(2,("ehci_root_ctrl_start: clear port ind "
				    "%d\n", index));
d1934 1
a1934 1
			    index));
d1944 1
a1944 2
		DPRINTFN(8,("ehci_root_ctrl_start: port status=0x%04x\n",
			    v));
d1984 1
a1984 1
				    index));
d2011 1
a2011 1
				       USBDEVNAME(sc->sc_bus.bdev));
d2021 1
a2021 1
				 index, v));
d2024 2
a2025 2
			DPRINTFN(2,("ehci_root_ctrl_start: set port power "
				    "%d\n", index));
d2029 2
a2030 2
			DPRINTFN(2,("ehci_root_ctrl_start: set port test "
				    "%d\n", index));
d2033 2
a2034 2
			DPRINTFN(2,("ehci_root_ctrl_start: set port ind "
				    "%d\n", index));
d2075 1
a2075 1
			       USBDEVNAME(sc->sc_bus.bdev)));
d2078 3
a2080 4
			       "port %d to %s\n",
			       USBDEVNAME(sc->sc_bus.bdev),
			       lowspeed ? "low" : "full",
			       index, USBDEVNAME(sc->sc_comps[i]->bdev)));
d2183 1
a2183 1
			  EHCI_PAGE_SIZE, &dma);
d2224 1
a2224 1
			  EHCI_PAGE_SIZE, &dma);
d2265 2
a2266 3
ehci_alloc_sqtd_chain(struct ehci_pipe *epipe, ehci_softc_t *sc,
		     int alen, int rd, usbd_xfer_handle xfer,
		     ehci_soft_qtd_t **sp, ehci_soft_qtd_t **ep)
d2282 1
a2282 1
	    EHCI_QTD_SET_CERR(3); /* IOC set below and BYTES set below */
d2305 2
a2306 2
				       "len=0x%x offs=0x%x\n", curlen, len,
				       EHCI_PAGE_OFFSET(dataphys));
d2308 1
a2308 2
				       dataphyslastpage, dataphyspage,
				       dataphys);
d2315 1
a2315 1
				    "curlen=%d\n", curlen));
d2322 2
a2323 3
			    "dataphyslastpage=0x%08x len=%d curlen=%d\n",
			    dataphys, dataphyslastpage,
			    len, curlen));
d2356 1
a2356 1
			    dataphys, dataphys + curlen));
d2374 1
a2374 1
		     *sp, *ep));
d2392 1
a2392 1
		     sqtd, sqtdend));
d2690 4
a2693 4
		    "wValue=0x%04x, wIndex=0x%04x len=%d, addr=%d, endpt=%d\n",
		    req->bmRequestType, req->bRequest, UGETW(req->wValue),
		    UGETW(req->wIndex), len, addr,
		    epipe->pipe.endpoint->edesc->bEndpointAddress));
d2746 1
a2746 2
	    EHCI_QTD_SET_BYTES(sizeof(*req))
	    );
d2759 1
a2759 2
	    EHCI_QTD_IOC
	    );
d2789 1
a2789 1
			    ehci_timeout, xfer);
d2798 1
a2798 1
			 EOREAD4(sc, EHCI_USBSTS)));
d2851 1
a2851 1
		     xfer, xfer->length, xfer->flags));
d2869 1
a2869 1
				   &dataend);
d2899 1
a2899 1
			    ehci_timeout, xfer);
d2955 1
a2955 1
		     xfer, xfer->actlen));
d3063 1
a3063 1
	if (!exfer->isdone) {
a3064 1
	}
d3070 1
a3070 1
	if (xfer->timeout && !sc->sc_bus.use_polling) {
a3072 1
	}
@


1.45
log
@Merge support for USB1 devices located beyond USB2 hubs, mostly from netbsd.

Supports bulk, control and interrupt pipes, letting USB1 keyboards and most
network interfaces work when connected to a USB2 hub.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.44 2005/03/13 02:32:57 pascoe Exp $ */
d1013 7
a1020 1

d1032 1
a1032 1
		if (hcr != 0) {
a1034 1
		}
d1046 1
a1046 1
		if (hcr != EHCI_STS_HCH) {
a1048 1
		}
d1063 21
d1093 1
a1093 1
		if (hcr == EHCI_STS_HCH) {
a1095 1
		}
@


1.44
log
@Order the top-level interrupt heads in the periodic framelist such that
downstream interupt heads have an even temporal distribution.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.43 2005/03/13 02:30:31 pascoe Exp $ */
d1339 1
d1347 8
d1378 9
d1404 3
a1406 1
		/* XXX TT stuff */
@


1.43
log
@Be even more liberal in what we accept as a completed transaction, as
XActErr is not the only qH warning bit that "sticks" during a transaction.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.42 2005/03/08 14:14:11 dlg Exp $ */
d147 2
d329 15
d348 1
a348 1
	u_int i;
d472 5
a476 5
	for (i = 0; i < sc->sc_flsize; i++) {
		sc->sc_flist[i] = htole32(EHCI_LINK_QH |
		    sc->sc_islots[EHCI_IQHIDX(EHCI_IPOLLRATES - 1,
		    i)].sqh->physaddr);
	}
@


1.42
log
@only print if we hit the via quirk timeout when debugging

ok pascoe@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.41 2005/03/08 08:17:16 pascoe Exp $ */
a835 1
	status &= EHCI_QTD_STATERRS;
d839 1
a840 1
	if (status != 0) {
d844 2
a845 2
				 "\20\7HALTED\6BUFERR\5BABBLE\4XACTERR"
				 "\3MISSED", sbuf, sizeof(sbuf));
d847 1
a847 1
		DPRINTFN((status == EHCI_QTD_HALTED) ? 2 : 0,
a856 1
	}
d858 5
a862 10
	/*
	 * XactErr with CErr > 0 indicates that there were one or more retries
	 * on the wire, but the transfer succeeded before the host controller
	 * gave up.  Ignore the XactErr bit in this case, and determine the
	 * overall transfer status from the remaining bits.
	 */
	if (status & EHCI_QTD_XACTERR && cerr > 0)
		status &= ~EHCI_QTD_XACTERR;

	if (status == 0)
a863 4
	else if (status == EHCI_QTD_HALTED)
		xfer->status = USBD_STALLED;
	else
		xfer->status = USBD_IOERROR; /* more info XXX */
@


1.41
log
@Initialise the alternate next pointer in the queue head with EHCI_NULL, not
zero. The host controller should, in theory, never follow this pointer, but
it is a minor spec violation.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.40 2005/03/08 08:06:36 pascoe Exp $ */
d2549 1
a2549 1
	printf("ehci_intrlist_timeout\n");
@


1.40
log
@From FreeBSD rev1.30:
 - always initialise the pipe multiplier to a valid value
 - do not unchain the the interrupt QHs immediately after initialisation

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.39 2005/03/07 12:58:19 pascoe Exp $ */
d1488 1
a1488 1
	sqh->qh.qh_qtd.qtd_altnext = 0;
@


1.39
log
@Ignore XactErr status if the host controller also indicates that the
transaction completed successfully on retry.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.38 2005/03/07 11:12:04 pascoe Exp $ */
d447 1
a447 1
		sqh->qh.qh_link = EHCI_NULL;
a448 1
		sqh->next = NULL;
@


1.38
log
@Add a workaround for VIA EHCI controllers which, under load, signal qTD
completion before they have performed writeback from the overlay qTD.

This condition would exhibit itself as a umass stall that never recovers.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.37 2005/03/06 05:18:34 pascoe Exp $ */
d764 1
a764 1
	int actlen;
d836 1
d838 2
a839 2
	DPRINTFN(/*10*/2, ("ehci_idone: len=%d, actlen=%d, status=0x%x\n",
			   xfer->length, actlen, status));
d841 1
a842 1
#ifdef EHCI_DEBUG
d859 1
d861 10
a870 5
		if (status == EHCI_QTD_HALTED)
			xfer->status = USBD_STALLED;
		else
			xfer->status = USBD_IOERROR; /* more info XXX */
	} else {
d872 4
a875 1
	}
@


1.37
log
@Fix incorrect comment about interrupt threshold control level.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.36 2005/03/06 05:12:00 pascoe Exp $ */
d158 1
d491 1
d692 6
d937 1
d2520 23
@


1.36
log
@In [eo]hci_waitintr, xfer->timeout is in ms, not hz.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.35 2005/02/28 12:35:44 pascoe Exp $ */
d498 1
a498 1
		 EHCI_CMD_ITC_2 | /* 8 microframes */
@


1.35
log
@Fix minor KNF nit that hurts every time I analyse this code.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.34 2005/02/28 00:34:09 pascoe Exp $ */
d871 1
a871 2
	int timo = xfer->timeout;
	int usecs;
d875 1
a875 1
	for (usecs = timo * 1000000 / hz; usecs > 0; usecs -= 1000) {
@


1.34
log
@Do not incorrectly emit "too many" message in debugging code.

ok dlg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.33 2004/12/29 01:52:27 dlg Exp $ */
d2662 1
a2662 1
		end->qtd.qtd_altnext = htole32(stat->physaddr);
@


1.33
log
@from freebsd: ehci.c 1.13, ehci_pci.c 1.13, ehcireg.h 1.5, ehcivar.h 1.3
log message:
Attempt to follow the correct procedure for synchronising with the
system BIOS to disable legacy device emulation as per the "EHCI
Extended Capability: Pre-OS to OS Handoff Synchronisation" section
of the EHCI spec. BIOSes that implement legacy emulation using SMIs
are supposed to disable the emulation when this procedure is performed.

tested on various archs by jsg@@ and me
ok pascoe@@, looks sane jsg@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.32 2004/10/31 10:29:45 dlg Exp $ */
d1233 1
a1233 1
	if (sqtd)
@


1.32
log
@from netbsd: ehci.c revision 1.84

Only delay interrupt my 2 miucroframes instead of 8.  This improves
Ethernet performance.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.31 2004/10/31 10:24:16 dlg Exp $ */
a146 1
Static void		ehci_shutdown(void *);
a417 1
	sc->sc_shutdownhook = shutdownhook_establish(ehci_shutdown, sc);
@


1.31
log
@fix some comments, spelling and printfs
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.30 2004/10/31 09:35:41 dlg Exp $ */
d500 1
a500 1
		 EHCI_CMD_ITC_8 | /* 8 microframes */
@


1.30
log
@netbsd reduced their difference to us in revision 1.76. they use usb_lockmgr
like us, so get rid of the ifdefs.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.29 2004/10/31 09:26:57 dlg Exp $ */
d423 2
a424 1
	/* Allocate the interrupt dummy QHs. These are arranged to give poll
a566 1

d718 1
a718 1
		printf("ehci_check_intr: sqtd==0\n");
d810 5
a814 1
	/* If there are left over TDs we need to update the toggle. */
d822 2
a823 1
	/* For a short transfer we need to update teh toggle for the missing
d842 1
a842 1
		DPRINTFN((status & EHCI_QTD_HALTED) ? 2 : 0,
d1162 1
a1162 1
#if defined(USB_DEBUG) && defined(EHCI_DEBUG)
d1468 1
a1468 1
	/* Set HALTED to make gw leave it alone */
d1474 1
a1474 1
	for (i = 0; i < EHCI_QTD_NBUFFERS; i++ )
d2489 1
a2489 1
#if defined(USB_DEBUG) && defined(EHCI_DEBUG)
@


1.29
log
@from netbsd: ehci.c revision 1.69

hcpriv is not actually used here.  Remove references to it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.28 2004/10/31 09:16:22 dlg Exp $ */
d1492 2
a1493 5
#if defined(__OpenBSD__) 
	usb_lockmgr(&sc->sc_doorbell_lock, LK_EXCLUSIVE, NULL, curproc); /* get doorbell */
#else
	lockmgr(&sc->sc_doorbell_lock, LK_EXCLUSIVE, NULL); /* get doorbell */
#endif
d1503 2
a1504 5
#if defined(__OpenBSD__) 
	usb_lockmgr(&sc->sc_doorbell_lock, LK_RELEASE, NULL, curproc); /* release doorbell */
#else
	lockmgr(&sc->sc_doorbell_lock, LK_RELEASE, NULL); /* release doorbell */
#endif
@


1.28
log
@from netbsd: ehci.c revisions 1.185 and 1.187:

Follow the spec more closely when updating the overlay qTD in the QH.

Preserve some bits in the overlay qTD.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.27 2004/10/31 08:29:53 dlg Exp $ */
a2059 1
	xfer->hcpriv = NULL;
a2119 1
	xfer->hcpriv = NULL;
@


1.27
log
@from netbsd: ehci.c revision 1.83

No need to generate an interrupt at the data part of a control transfer,
it's generated by the status transfer.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.26 2004/10/31 08:09:16 dlg Exp $ */
d1456 10
a1465 2
	/* Halt while we are messing. */
	sqh->qh.qh_qtd.qtd_status |= htole32(EHCI_QTD_HALTED);
d1468 3
d1472 2
a1473 2
	/* Clear halt */
	sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_HALTED);
@


1.26
log
@from netbsd: ehci.c revision 1.82

Make sure to update the data toggle on short transfers.
This makes my Ethernet adapter much happier.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.25 2004/10/27 12:07:48 dlg Exp $ */
d2653 1
@


1.25
log
@update todo to better reflect reality
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.24 2004/10/20 12:45:31 dlg Exp $ */
d756 2
a757 2
	ehci_soft_qtd_t *sqtd;
	u_int32_t status = 0, nstatus;
d759 1
d793 1
d795 2
a796 1
	for (sqtd = ex->sqtdstart; sqtd != NULL; sqtd = sqtd->nextqtd) {
d811 2
a812 1
	if (sqtd != NULL) {
d817 7
@


1.24
log
@interrupt transfer support on usb2 controllers. allows the use of usb2 hubs
with usb2 hardware.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.23 2004/10/19 08:10:27 dlg Exp $ */
d52 1
a52 1
 * 1) hold off explorations by companion controllers until ehci has started.
d54 4
a57 7
 * 2) The EHCI driver lacks support for interrupt isochronous transfers, so
 *    devices using them don't work.
 *    Interrupt transfers are not difficult, it's just not done. 
 *
 * 3) The meaty part to implement is the support for USB 2.0 hubs.
 *    They are quite compolicated since the need to be able to do
 *    "transaction translation", i.e., converting to/from USB 2 and USB 1.
d60 1
a60 1
 *    on hubs in USB 2.0 for details. 
d62 1
a62 1
 * 4) command failures are not recovered correctly
@


1.23
log
@suspend/resume support

while here define EHCI_DEBUG when USB_DEBUG is defined

ok pvalchev@@ deraadt@@
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.22 2004/09/30 11:33:56 dlg Exp $ */
d97 2
d138 3
a140 1
		/* XXX */
d227 3
d399 3
d404 3
a406 3
	case 0: sc->sc_flsize = 1024*4; break;
	case 1: sc->sc_flsize = 512*4; break;
	case 2: sc->sc_flsize = 256*4; break;
d409 2
a410 2
	err = usb_allocmem(&sc->sc_bus, sc->sc_flsize,
			   EHCI_FLALIGN_ALIGN, &sc->sc_fldma);
d414 2
d426 39
d505 1
a505 1
		 /* EHCI_CMD_PSE | */
d695 1
d700 1
d1304 1
a1304 1
	int speed, naks;
d1351 1
a1351 1
		EHCI_QH_SET_MULT(1)
d1353 1
a1353 1
		/* XXX interrupt mask */
d1386 4
a1389 1
		return (USBD_INVAL);
d2419 1
d2421 1
d2423 1
d2425 1
d2883 211
a3093 5
Static usbd_status	ehci_device_intr_transfer(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static usbd_status	ehci_device_intr_start(usbd_xfer_handle xfer) { return USBD_IOERROR; }
Static void		ehci_device_intr_abort(usbd_xfer_handle xfer) { }
Static void		ehci_device_intr_close(usbd_pipe_handle pipe) { }
Static void		ehci_device_intr_done(usbd_xfer_handle xfer) { }
@


1.22
log
@spelling nit
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.21 2004/08/11 11:45:57 dlg Exp $ */
d103 4
d911 2
a912 2
	//u_int32_t ctl;
	int s;
d916 2
a917 1
	ehci_dump_regs(sc);
d925 32
a956 10
#if 0
OOO
		ctl = OREAD4(sc, EHCI_CONTROL) & ~EHCI_HCFS_MASK;
		if (sc->sc_control == 0) {
			/*
			 * Preserve register values, in case that APM BIOS
			 * does not recover them.
			 */
			sc->sc_control = ctl;
			sc->sc_intre = OREAD4(sc, EHCI_INTERRUPT_ENABLE);
d958 1
a958 4
		ctl |= EHCI_HCFS_SUSPEND;
		OWRITE4(sc, EHCI_CONTROL, ctl);
#endif
		usb_delay_ms(&sc->sc_bus, USB_RESUME_WAIT);
d961 1
d964 24
a987 21
#if 0
OOO
		/* Some broken BIOSes do not recover these values */
		OWRITE4(sc, EHCI_HCCA, DMAADDR(&sc->sc_hccadma, 0));
		OWRITE4(sc, EHCI_CONTROL_HEAD_ED, sc->sc_ctrl_head->physaddr);
		OWRITE4(sc, EHCI_BULK_HEAD_ED, sc->sc_bulk_head->physaddr);
		if (sc->sc_intre)
			OWRITE4(sc, EHCI_INTERRUPT_ENABLE,
				sc->sc_intre & (EHCI_ALL_INTRS | EHCI_MIE));
		if (sc->sc_control)
			ctl = sc->sc_control;
		else
			ctl = OREAD4(sc, EHCI_CONTROL);
		ctl |= EHCI_HCFS_RESUME;
		OWRITE4(sc, EHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_DELAY);
		ctl = (ctl & ~EHCI_HCFS_MASK) | EHCI_HCFS_OPERATIONAL;
		OWRITE4(sc, EHCI_CONTROL, ctl);
		usb_delay_ms(&sc->sc_bus, USB_RESUME_RECOVERY);
		sc->sc_control = sc->sc_intre = 0;
#endif
d998 6
@


1.21
log
@a few debug cleanups:

function names in messages didnt always match the actual name of the function.
endian fix when dumping a qtd chain so it terminates correctly on big endian
archs.
dont blame uhci for problems ehci has.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.20 2004/08/11 04:29:13 dlg Exp $ */
d900 1
a900 1
 * called from an intterupt context.  This is all right since we
@


1.20
log
@slight KNF and ANSI
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.19 2004/07/12 15:30:28 deraadt Exp $ */
d508 1
a508 1
		printf("ehci_intr: sc == NULL\n");
d519 1
a519 1
	DPRINTFN(7, ("ehci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n",
d1018 1
a1018 1
			printf("uhci_allocx: xfer=%p not free, 0x%08x\n", xfer,
d1133 1
a1133 1
		stop = sqtd->qtd.qtd_next & EHCI_LINK_TERMINATE;
d1540 1
a1540 1
	DPRINTFN(4,("ehci_root_ctrl_control type=0x%02x request=%02x\n",
d1567 1
a1567 1
		DPRINTFN(8,("ehci_root_ctrl_control wValue=0x%04x\n", value));
d1682 1
a1682 1
		DPRINTFN(8, ("ehci_root_ctrl_control: UR_CLEAR_PORT_FEATURE "
d1702 1
a1702 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: clear port test "
d1706 1
a1706 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: clear port ind "
d1774 1
a1774 1
		DPRINTFN(8,("ehci_root_ctrl_transfer: get port status i=%d\n",
d1785 1
a1785 1
		DPRINTFN(8,("ehci_root_ctrl_transfer: port status=0x%04x\n",
d1825 1
a1825 1
			DPRINTFN(5,("ehci_root_ctrl_transfer: reset port %d\n",
d1866 1
a1866 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port power "
d1871 1
a1871 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port test "
d1875 1
a1875 1
			DPRINTFN(2,("ehci_root_ctrl_transfer: set port ind "
d2510 1
a2510 1
	DPRINTFN(3,("ehci_device_control type=0x%02x, request=0x%02x, "
d2672 1
a2672 1
	DPRINTFN(2, ("ehci_device_bulk_transfer: xfer=%p len=%d flags=%d\n",
d2680 1
a2680 1
		panic("ehci_device_bulk_transfer: a request");
d2701 1
a2701 1
		DPRINTF(("ehci_device_bulk_transfer: data(1)\n"));
d2712 1
a2712 1
		printf("ehci_device_bulk_transfer: not done, ex=%p\n", exfer);
d2729 1
a2729 1
		DPRINTF(("ehci_device_bulk_transfer: data(2)\n"));
d2731 1
a2731 1
		DPRINTF(("ehci_device_bulk_transfer: data(3)\n"));
@


1.19
log
@merge error; loki
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.18 2004/07/10 13:08:41 deraadt Exp $ */
d1026 1
a1026 1
		memset(xfer, 0, sizeof (struct ehci_xfer));
d1484 1
a1484 4
ehci_str(p, l, s)
	usb_string_descriptor_t *p;
	int l;
	char *s;
d1801 1
a1801 1
		l = min(len, sizeof ps);
d2558 1
a2558 1
	memcpy(KERNADDR(&epipe->u.ctl.reqdma, 0), req, sizeof *req);
d2566 1
a2566 1
	    EHCI_QTD_SET_BYTES(sizeof *req)
d2573 1
a2573 1
	setup->len = sizeof *req;
@


1.18
log
@from loki@@animata.net:
this is netbsds fix for the endian problems they had with the data toggle
change. do the swap when the var is assigned to the qtd, rather than swap
everything that is assigned to the var and just assign the var. instead of 4
or so htole32s we now do 1.
from netbsd, ehci.c 1.67 (i made a mistake, the last patch i gave you was
from 1.68) log message:
Fix a byte order error.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.17 2004/07/10 12:25:49 deraadt Exp $ */
d755 3
a757 3
		if (!(xfer->rqflags & URQ_REQUEST))
			printf("ehci_idone: need toggle update\n");
		epipe->nexttoggle = EHCI_QTD_GET_TOGGLE(status);
d772 1
a772 1
		DPRINTFN((status == EHCI_QTD_HALTED)*/*10*/2,
@


1.17
log
@from netbsd, via loki@@animata.net, revision 1.67
Adjust some silliness that was causing us to do extra work for "frame list
rollover" interrupts, which we pretty much ignore.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.16 2004/07/07 16:55:08 deraadt Exp $ */
d2129 1
a2129 2
	qtdstatus = htole32(
	    EHCI_QTD_ACTIVE |
d2131 1
a2131 4
	    EHCI_QTD_SET_CERR(3)
	    /* IOC set below */
	    /* BYTES set below */
	    );
d2134 1
a2134 1
	qtdstatus |= htole32(EHCI_QTD_SET_TOGGLE(tog));
d2202 2
a2203 2
		cur->qtd.qtd_status =
		    qtdstatus | htole32(EHCI_QTD_SET_BYTES(curlen));
d2212 1
a2212 1
			qtdstatus ^= htole32(EHCI_QTD_TOGGLE_MASK);
@


1.16
log
@use the do { .. } while(0) wrapper
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.15 2004/07/07 01:27:06 deraadt Exp $ */
a517 1
	EOWRITE4(sc, EHCI_USBSTS, intrs); /* Acknowledge */
d525 1
@


1.15
log
@a bit more silence during bus handovers; loki@@animata.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.14 2004/07/07 00:58:42 deraadt Exp $ */
d104 2
a105 2
#define DPRINTF(x)	if (ehcidebug) printf x
#define DPRINTFN(n,x)	if (ehcidebug>(n)) printf x
@


1.14
log
@copyright dates sync; loki@@animata.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.13 2004/07/07 00:58:05 deraadt Exp $ */
d1912 1
d1914 2
a1915 1
#ifdef DIAGNOSTIC
d1919 2
a1920 2
			printf("%s: strange port\n",
			       USBDEVNAME(sc->sc_bus.bdev));
d1922 1
a1922 1
			printf("%s: handing over %s speed device on "
d1926 1
a1926 1
			       index, USBDEVNAME(sc->sc_comps[i]->bdev));
d1928 1
a1928 1
		printf("%s: npcomp == 0\n", USBDEVNAME(sc->sc_bus.bdev));
@


1.13
log
@Changes EHCI_QTD_TOGGLE to EHCI_QTD_TOGGLE_MASK; loki@@animata.net
@
text
@d1 2
a2 2
/*	$OpenBSD: ehci.c,v 1.12 2004/07/06 02:51:46 deraadt Exp $ */
/*	$NetBSD: ehci.c,v 1.54 2004/01/17 13:15:05 jdolecek Exp $	*/
d5 1
a5 1
 * Copyright (c) 2001 The NetBSD Foundation, Inc.
d9 1
a9 1
 * by Lennart Augustsson (lennart@@augustsson.net).
d70 1
a70 1
__KERNEL_RCSID(0, "$NetBSD: ehci.c,v 1.54 2004/01/17 13:15:05 jdolecek Exp $");
@


1.12
log
@from netbsd, via loki@@animata.net: revision 1.62. Log message:
Fix an error in a debug printf().
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.11 2004/07/06 02:51:14 deraadt Exp $ */
d2214 1
a2214 1
			qtdstatus ^= htole32(EHCI_QTD_TOGGLE);
@


1.11
log
@sent in by loki@@animata.net: This includes all the changes from netbsd
related to working with the data toggle, but also includes some endian
fixes. The major changes in the netbsd code were in revisions 1.55 and
1.64. their log messages are:
1.55:  Set the data toggle correctly, and use EHCI_QTD_DTC.  This fixes
problems with my ALi-based drive enclosure (it works now, rather than
failing to attach). Also seems to work with a GL811-based enclosure and
an ASUS enclosure with a CD-RW, on both Intel and NEC controllers.
Note: The ALi enclosure is currently very SLOW, due to some issue with
taking too long to notice that the QTD is complete.  This requires more
investigation.
1.64: Further cleanup of toggle handling.  Now that we use EHCI_QH_DTC,
we don't need to fiddle with the TOGGLE bit in the overlay descriptor,
so minimize how much we fuss with it.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.10 2004/07/06 02:49:47 deraadt Exp $ */
d769 2
a770 3
				 "\20\3MISSEDMICRO\4XACT\5BABBLE\6BABBLE"
				 "\7HALTED",
				 sbuf, sizeof(sbuf));
@


1.10
log
@from netbsd, via loki@@animata.net, ehci.c revision 1.58 without some
printfs that are more related to the data toggle. log message:
Fix a stupid bug in ehci_check_intr() that caused use to try to complete
a transaction that was still running.  Now ehci can handle multiple devices
being active at once.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.9 2004/07/06 02:49:05 deraadt Exp $ */
d58 1
a58 5
 * 3) There might also be some issues with the data toggle, it was not
 *    completely tested to work properly under all condistions. If wrong
 *    toggle would be sent/recvd, bulk data transfers would stop working.
 *
 * 4) The meaty part to implement is the support for USB 2.0 hubs.
d65 1
a65 1
 * 5) command failures are not recovered correctly
d117 2
a700 1
#ifdef EHCI_DEBUG
a701 1
#endif
d757 1
a757 3
#if 0
		epipe->nexttoggle = EHCI_TD_GET_DT(le32toh(std->td.td_token));
#endif
d1067 1
a1067 1
	epipe->sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE);
d1226 2
d1257 2
a1258 2
		EHCI_QH_SET_EPS(speed) | /* XXX */
		/* XXX EHCI_QH_DTC ? */
d1364 2
a1365 2
	/* Keep toggle, clear the rest, including length. */
	sqh->qh.qh_qtd.qtd_status &= htole32(EHCI_QTD_TOGGLE);
d2119 2
a2120 2
	int len, curlen;
	int i;
a2133 1
	    /* XXX Data toggle */
d2135 3
a2164 2

			/* XXX true for EHCI? */
d2166 1
a2166 1
			curlen -= curlen % UGETW(epipe->pipe.endpoint->edesc->wMaxPacketSize);
d2211 6
d2225 1
d2536 2
a2537 9
	/* XXX
	 * Since we're messing with the QH we must know the HC is in sync.
	 * This needs to go away since it slows down control transfers.
	 * Removing it entails:
	 *  - fill the QH only once with addr & wMaxPacketSize
	 *  - put the correct data toggles in the qtds and set DTC
	 */
	/* ehci_sync_hc(sc); */
	/* Update device address and length since they may have changed. */
a2543 1
	     /* EHCI_QH_DTC | */
a2545 2
	/* Clear toggle */
	sqh->qh.qh_qtd.qtd_status &= htole32(~EHCI_QTD_TOGGLE);
d2551 2
a2559 2
		/* Start toggle at 1. */
		/*next->qtd.td_flags |= htole32(EHCI_QTD_TOGGLE);*/
d2566 1
d2571 1
d2585 1
@


1.9
log
@from netbsd, via loki@@animata.net, ehci.c revision 1.56 sans some debugging
printfs that crept in. log message:
Failure to properly mask off UE_DIR_IN from the endpoint address was
causing OHCI_ED_FORMAT_ISO and EHCI_QH_HRECL to get set spuriously,
causing rather interesting lossage.
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.8 2004/07/05 03:07:45 deraadt Exp $ */
d686 1
a686 1
			if (EHCI_QTD_SET_BYTES(status) != 0)
@


1.8
log
@This fixes a couple of spelling errors (EHCI_HCS_P_INCICATOR to
EHCI_HCS_P_INDICATOR and EHCI_QG_MPLMASK to EHCI_QH_MPLMASK);
from netbsd; via, loki@@animata.net
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.7 2004/06/24 00:00:20 jolan Exp $ */
d1260 1
a1260 1
		EHCI_QH_SET_ENDPT(ed->bEndpointAddress) |
@


1.7
log
@endian fix from chris pascoe

tested by nordin@@ and david gwynne
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.6 2004/06/20 00:17:49 deraadt Exp $ */
d1763 1
a1763 1
		    EHCI_HCS_P_INCICATOR(EREAD4(sc, EHCI_HCSPARAMS))
d2545 1
a2545 1
	    (sqh->qh.qh_endp & htole32(~(EHCI_QH_ADDRMASK | EHCI_QG_MPLMASK))) |
@


1.6
log
@fix EHCI_DEBUG crud; aratchov@@magphy.ujf-grenoble.fr
@
text
@d1 1
a1 1
/*	$OpenBSD: ehci.c,v 1.5 2004/05/30 01:25:17 tedu Exp $ */
d2188 1
a2188 1
			nextphys = next->physaddr;
d2208 1
a2208 1
		cur->qtd.qtd_next = cur->qtd.qtd_altnext = htole32(nextphys);
@


1.5
log
@rcsids
@
text
@d1 1
a1 1
/*	$OpenBSD$ */
d822 1
a822 1
#ifdef OHCI_DEBUG
d1069 1
a1069 1
#ifdef USB_DEBUG
d2382 1
a2382 1
#ifdef USB_DEBUG
@


1.5.2.1
log
@Merge with the trunk
@
text
@@


1.4
log
@while polling, ack & ignore interrupts.  this will have to do until
someone writes a better diff.  from peter
@
text
@d1 1
@


1.3
log
@ehci support; hacked into working shape by jonathon@@gateway.zenbu.net
@
text
@d489 4
a492 3
#ifdef DIAGNOSTIC
		printf("ehci_intr: ignored interrupt while polling\n");
#endif
@


1.2
log
@Meant to commit only ulpt and committed everything.  Most things weren't ready
@
text
@d1 1
a1 7
/*	$OpenBSD: ehci.c,v 1.1 2002/05/07 18:08:04 nate Exp $	*/
/*	$NetBSD: ehci.c,v 1.29 2001/12/31 12:16:57 augustss Exp $	*/

/*
 * TODO
 *  hold off explorations by companion controllers until ehci has started.
 */
d42 2
a43 2
 * The EHCI 0.96 spec can be found at
 * http://developer.intel.com/technology/usb/download/ehci-r096.pdf
d45 1
a45 1
 * http://www.usb.org/developers/data/usb_20.zip
d49 30
d102 1
a102 1
	NULL, "ehci", DV_DULL
d238 1
d241 1
a241 2

#define MS_TO_TICKS(ms) ((ms) * hz / 1000)
d250 5
a254 1
	LIST_REMOVE((ex), inext)
d266 1
a266 1
Static struct usbd_pipe_methods ehci_root_ctrl_methods = {	
d275 1
a275 1
Static struct usbd_pipe_methods ehci_root_intr_methods = {	
d284 1
a284 1
Static struct usbd_pipe_methods ehci_device_ctrl_methods = {	
d293 1
a293 1
Static struct usbd_pipe_methods ehci_device_intr_methods = {	
d302 1
a302 1
Static struct usbd_pipe_methods ehci_device_bulk_methods = {	
d346 4
d364 6
a369 1
	
d378 1
a378 1
		delay(10);
d384 2
a385 1
		printf("%s: reset timeout\n", USBDEVNAME(sc->sc_bus.bdev));
d458 1
a458 1
		delay(10);
d495 1
a495 1
	return (ehci_intr1(sc)); 
d520 1
a520 1
	DPRINTFN(7, ("ehci_intr: sc=%p intrs=0x%x(0x%x) eintrs=0x%x\n", 
d534 3
a536 3
		DPRINTF(("ehci_intr1: %s %s\n", 
			 eintrs & EHCI_STS_INT ? "INT" : "",
			 eintrs & EHCI_STS_ERRINT ? "ERRINT" : ""));
d547 1
a547 1
		/* 
a592 1
	struct ehci_pipe *epipe;
a601 1
	epipe = (struct ehci_pipe *)pipe;
d603 1
a603 1
	p = KERNADDR(&xfer->dmabuf);
d622 1
a622 1
	struct ehci_xfer *ex;
d635 2
a636 1
	for (ex = LIST_FIRST(&sc->sc_intrhead); ex; ex = LIST_NEXT(ex, inext))
d638 1
d668 1
a668 1
	/* 
d747 4
d820 1
a820 1
#ifdef EHCI_DEBUG
d863 1
a863 1
	
a890 1
		break;
d947 1
a947 1
		OWRITE4(sc, EHCI_HCCA, DMAADDR(&sc->sc_hccadma));
d1020 1
a1020 1
		SIMPLEQ_REMOVE_HEAD(&sc->sc_free_xfers, xfer, next);
d1094 1
a1094 1
		printf("port %d status=0x%08x\n", i, 
d1098 4
d1201 1
d1208 1
d1249 1
a1249 1
	default: panic("ehci_open: bad device speed %d\n", dev->speed);
d1281 1
a1281 1
		err = usb_allocmem(&sc->sc_bus, sizeof(usb_device_request_t), 
d1344 1
a1344 1
	ehci_soft_qh_t *p; 
d1348 1
a1348 1
	for (p = head; p == NULL && p->next != sqh; p = p->next)
d1351 1
a1351 1
		panic("ehci_rem_qh: ED not found\n");
d1386 5
a1390 4

	/* get doorbell */
	usb_lockmgr(&sc->sc_doorbell_lock, LK_EXCLUSIVE, NULL, curproc);

d1400 5
a1404 4

	/* release doorbell */
	usb_lockmgr(&sc->sc_doorbell_lock, LK_RELEASE, NULL, curproc);

d1546 1
a1546 1
	DPRINTFN(4,("ehci_root_ctrl_control type=0x%02x request=%02x\n", 
d1554 1
a1554 1
		buf = KERNADDR(&xfer->dmabuf);
d1561 1
a1561 1
		/* 
d1584 1
a1584 1
		/* 
d1596 1
a1596 1
		/* 
d1752 1
a1752 1
		if (value != 0) {
d1764 1
a1764 1
		for (i = 0, l = sc->sc_noport; l > 0; i++, l -= 8, v >>= 8) 
d2007 1
a2007 1
	
d2041 2
a2042 2
			sqh = (ehci_soft_qh_t *)((char *)KERNADDR(&dma) + offs);
			sqh->physaddr = DMAADDR(&dma) + offs;
d2083 2
a2084 2
			sqtd = (ehci_soft_qtd_t *)((char *)KERNADDR(&dma)+offs);
			sqtd->physaddr = DMAADDR(&dma) + offs;
d2128 1
a2128 1
	dataphys = DMAADDR(dma);
d2146 1
a2146 1
		if (dataphyslastpage - dataphyspage < 
d2152 1
a2152 1
			curlen = EHCI_QTD_NBUFFERS * EHCI_PAGE_SIZE - 
d2173 1
a2173 1
				panic("ehci_alloc_std: curlen == 0\n");
d2197 1
d2269 1
a2269 1
/* 
d2306 1
a2306 1
		panic("ehci_abort_xfer: not in process context\n");
d2323 1
a2323 1
	/* 
d2334 2
a2335 2
		
	/* 
d2461 1
a2461 1
		panic("ehci_ctrl_done: not a request\n");
d2465 1
a2465 1
	if (xfer->status != USBD_NOMEM) {
d2514 1
a2514 1
		    UGETW(req->wIndex), len, addr, 
d2531 1
a2531 1
	/* XXX 
d2542 1
a2542 1
	sqh->qh.qh_endp = 
d2561 1
a2561 1
		end->qtd.qtd_next = 
d2569 1
a2569 1
	memcpy(KERNADDR(&epipe->u.ctl.reqdma), req, sizeof *req);
d2577 2
a2578 1
	setup->qtd.qtd_buffer[0] = htole32(DMAADDR(&epipe->u.ctl.reqdma));
d2591 1
d2618 1
a2618 1
                usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d2688 1
a2688 1
		panic("ehci_device_bulk_transfer: a request\n");
d2728 1
a2728 1
		usb_callout(xfer->timeout_handle, MS_TO_TICKS(xfer->timeout),
d2765 1
a2765 1
/* 
d2784 1
a2784 1
	DPRINTFN(10,("ehci_bulk_done: xfer=%p, actlen=%d\n", 
d2787 1
a2787 1
	if (xfer->status != USBD_NOMEM) {
d2789 1
a2789 1
		ehci_free_sqtd_chain(sc, ex->sqtdstart, 0);
@


1.1
log
@Sync ulpt driver with NetBSD
@
text
@d1 1
a1 1
/*	$OpenBSD$	*/
@

